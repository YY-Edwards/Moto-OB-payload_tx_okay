
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009db4  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000be00  8000be00  0000c200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000114c  8000c000  8000c000  0000c400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8000d14c  8000d14c  0000d54c  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a40  00000008  8000d150  0000d808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          000036b8  00000a48  00000a48  00000000  2**2
                  ALLOC
  9 .heap         00012f00  00004100  00004100  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000e248  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 000010e8  00000000  00000000  0000e278  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002447  00000000  00000000  0000f360  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   000273a4  00000000  00000000  000117a7  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000064c3  00000000  00000000  00038b4b  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000be36  00000000  00000000  0003f00e  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002c0c  00000000  00000000  0004ae44  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006b23  00000000  00000000  0004da50  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000c68c  00000000  00000000  00054573  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 000011d8  00000000  00000000  00060c00  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 9b 68 	sub	pc,pc,-25752

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf bb 6c 	sub	pc,pc,-17556

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 7c       	ld.ub	r12,--r6

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 60       	and	r0,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	20 94       	sub	r4,9
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 58       	sub	r8,-123
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 f8       	sub	r8,-113
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3e 78       	mov	r8,-25
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c0 00       	breq	80002086 <app_init+0x46>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	27 bc       	sub	r12,123
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	5c 14       	scr	r4
80002090:	00 00       	add	r0,r0
80002092:	0a 5c       	eor	r12,r5

80002094 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002094:	d4 01       	pushm	lr
  log("R");
80002096:	48 3c       	lddpc	r12,800020a0 <app_payload_tx_proc+0xc>
80002098:	f0 1f 00 03 	mcall	800020a4 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000209c:	d8 02       	popm	pc
8000209e:	00 00       	add	r0,r0
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	c0 08       	rjmp	800020a2 <app_payload_tx_proc+0xe>
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	5f d8       	srvc	r8

800020a8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020aa:	48 3c       	lddpc	r12,800020b4 <FD_brdcst_func+0xc>
800020ac:	f0 1f 00 03 	mcall	800020b8 <FD_brdcst_func+0x10>
	
}
800020b0:	d8 02       	popm	pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	c0 0c       	rcall	800020b6 <FD_brdcst_func+0xe>
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	5f d8       	srvc	r8

800020bc <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020bc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020be:	48 3c       	lddpc	r12,800020c8 <FD_reply_func+0xc>
800020c0:	f0 1f 00 03 	mcall	800020cc <FD_reply_func+0x10>
	
	
}
800020c4:	d8 02       	popm	pc
800020c6:	00 00       	add	r0,r0
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	c0 2c       	rcall	800020ce <FD_reply_func+0x12>
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	5f d8       	srvc	r8

800020d0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020d0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020d2:	48 3c       	lddpc	r12,800020dc <FD_request_func+0xc>
800020d4:	f0 1f 00 03 	mcall	800020e0 <FD_request_func+0x10>
	
	
}
800020d8:	d8 02       	popm	pc
800020da:	00 00       	add	r0,r0
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	c0 48       	rjmp	800020e6 <EnOB_brdcst_func+0x2>
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	5f d8       	srvc	r8

800020e4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e6:	48 3c       	lddpc	r12,800020f0 <EnOB_brdcst_func+0xc>
800020e8:	f0 1f 00 03 	mcall	800020f4 <EnOB_brdcst_func+0x10>
}
800020ec:	d8 02       	popm	pc
800020ee:	00 00       	add	r0,r0
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	c0 64       	brge	800020fe <EnOB_reply_func+0x6>
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	5f d8       	srvc	r8

800020f8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f8:	eb cd 40 80 	pushm	r7,lr
800020fc:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fe:	19 a9       	ld.ub	r9,r12[0x2]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c1 91       	brne	80002138 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002108:	19 b8       	ld.ub	r8,r12[0x3]
8000210a:	30 19       	mov	r9,1
8000210c:	f2 08 18 00 	cp.b	r8,r9
80002110:	c0 61       	brne	8000211c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002112:	49 0c       	lddpc	r12,80002150 <EnOB_reply_func+0x58>
80002114:	f0 1f 00 10 	mcall	80002154 <EnOB_reply_func+0x5c>
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000211c:	58 08       	cp.w	r8,0
8000211e:	c0 61       	brne	8000212a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002120:	48 ec       	lddpc	r12,80002158 <EnOB_reply_func+0x60>
80002122:	f0 1f 00 0d 	mcall	80002154 <EnOB_reply_func+0x5c>
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000212a:	1a d8       	st.w	--sp,r8
8000212c:	48 cc       	lddpc	r12,8000215c <EnOB_reply_func+0x64>
8000212e:	f0 1f 00 0a 	mcall	80002154 <EnOB_reply_func+0x5c>
80002132:	2f fd       	sub	sp,-4
80002134:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002138:	48 ac       	lddpc	r12,80002160 <EnOB_reply_func+0x68>
8000213a:	f0 1f 00 07 	mcall	80002154 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213e:	0f a8       	ld.ub	r8,r7[0x2]
80002140:	1a d8       	st.w	--sp,r8
80002142:	48 9c       	lddpc	r12,80002164 <EnOB_reply_func+0x6c>
80002144:	f0 1f 00 04 	mcall	80002154 <EnOB_reply_func+0x5c>
80002148:	2f fd       	sub	sp,-4
8000214a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	c0 7c       	rcall	80002160 <EnOB_reply_func+0x68>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	5f d8       	srvc	r8
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	c0 94       	brge	8000216c <SingleDetection_brdcst_func+0x4>
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	c0 a8       	rjmp	80002172 <SingleDetection_brdcst_func+0xa>
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	c0 c0       	breq	8000217a <SingleDetection_brdcst_func+0x12>
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	c0 dc       	rcall	80002180 <SingleDetection_brdcst_func+0x18>

80002168 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002168:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000216a:	19 a9       	ld.ub	r9,r12[0x2]
8000216c:	31 18       	mov	r8,17
8000216e:	f0 09 18 00 	cp.b	r9,r8
80002172:	c0 41       	brne	8000217a <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002174:	48 2c       	lddpc	r12,8000217c <SingleDetection_brdcst_func+0x14>
80002176:	f0 1f 00 03 	mcall	80002180 <SingleDetection_brdcst_func+0x18>
8000217a:	d8 02       	popm	pc
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	c0 f4       	brge	8000219c <ButtonConfig_brdcst_func+0x18>
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	5f d8       	srvc	r8

80002184 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002184:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002186:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
8000218a:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
8000218c:	4a bc       	lddpc	r12,80002238 <ButtonConfig_brdcst_func+0xb4>
8000218e:	f0 1f 00 2c 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002192:	0f 88       	ld.ub	r8,r7[0x0]
80002194:	1a d8       	st.w	--sp,r8
80002196:	4a bc       	lddpc	r12,80002240 <ButtonConfig_brdcst_func+0xbc>
80002198:	f0 1f 00 29 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000219c:	1a d5       	st.w	--sp,r5
8000219e:	4a ac       	lddpc	r12,80002244 <ButtonConfig_brdcst_func+0xc0>
800021a0:	f0 1f 00 27 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021a4:	0f a8       	ld.ub	r8,r7[0x2]
800021a6:	1a d8       	st.w	--sp,r8
800021a8:	4a 8c       	lddpc	r12,80002248 <ButtonConfig_brdcst_func+0xc4>
800021aa:	f0 1f 00 25 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021ae:	2f dd       	sub	sp,-12
800021b0:	58 05       	cp.w	r5,0
800021b2:	c4 10       	breq	80002234 <ButtonConfig_brdcst_func+0xb0>
800021b4:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021b6:	4a 64       	lddpc	r4,8000224c <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021b8:	4a 63       	lddpc	r3,80002250 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ba:	4a 72       	lddpc	r2,80002254 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021bc:	4a 71       	lddpc	r1,80002258 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021be:	4a 80       	lddpc	r0,8000225c <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021c0:	0f b9       	ld.ub	r9,r7[0x3]
800021c2:	0f c8       	ld.ub	r8,r7[0x4]
800021c4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021c8:	1a d8       	st.w	--sp,r8
800021ca:	1a d6       	st.w	--sp,r6
800021cc:	08 9c       	mov	r12,r4
800021ce:	f0 1f 00 1c 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021d2:	0f d9       	ld.ub	r9,r7[0x5]
800021d4:	0f e8       	ld.ub	r8,r7[0x6]
800021d6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021da:	1a d8       	st.w	--sp,r8
800021dc:	1a d6       	st.w	--sp,r6
800021de:	06 9c       	mov	r12,r3
800021e0:	f0 1f 00 17 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021e4:	0f f9       	ld.ub	r9,r7[0x7]
800021e6:	ef 38 00 08 	ld.ub	r8,r7[8]
800021ea:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ee:	1a d8       	st.w	--sp,r8
800021f0:	1a d6       	st.w	--sp,r6
800021f2:	04 9c       	mov	r12,r2
800021f4:	f0 1f 00 12 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021f8:	ef 39 00 09 	ld.ub	r9,r7[9]
800021fc:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002200:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002204:	1a d8       	st.w	--sp,r8
80002206:	1a d6       	st.w	--sp,r6
80002208:	02 9c       	mov	r12,r1
8000220a:	f0 1f 00 0d 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000220e:	2f 8d       	sub	sp,-32
80002210:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002214:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002218:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221c:	1a d8       	st.w	--sp,r8
8000221e:	1a d6       	st.w	--sp,r6
80002220:	00 9c       	mov	r12,r0
80002222:	f0 1f 00 07 	mcall	8000223c <ButtonConfig_brdcst_func+0xb8>
80002226:	2f f6       	sub	r6,-1
80002228:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000222a:	2f ed       	sub	sp,-8
8000222c:	ec 05 18 00 	cp.b	r5,r6
80002230:	fe 9b ff c8 	brhi	800021c0 <ButtonConfig_brdcst_func+0x3c>
80002234:	d8 32       	popm	r0-r7,pc
80002236:	00 00       	add	r0,r0
80002238:	80 00       	ld.sh	r0,r0[0x0]
8000223a:	c1 08       	rjmp	8000225a <ButtonConfig_brdcst_func+0xd6>
8000223c:	80 00       	ld.sh	r0,r0[0x0]
8000223e:	5f d8       	srvc	r8
80002240:	80 00       	ld.sh	r0,r0[0x0]
80002242:	c1 28       	rjmp	80002266 <Phyuserinput_brdcst_func+0x6>
80002244:	80 00       	ld.sh	r0,r0[0x0]
80002246:	c1 3c       	rcall	8000226c <Phyuserinput_brdcst_func+0xc>
80002248:	80 00       	ld.sh	r0,r0[0x0]
8000224a:	c1 54       	brge	80002274 <Phyuserinput_brdcst_func+0x14>
8000224c:	80 00       	ld.sh	r0,r0[0x0]
8000224e:	c1 74       	brge	8000227c <Phyuserinput_brdcst_func+0x1c>
80002250:	80 00       	ld.sh	r0,r0[0x0]
80002252:	c1 9c       	rcall	80002284 <Phyuserinput_brdcst_func+0x24>
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	c1 c4       	brge	8000228e <Phyuserinput_brdcst_func+0x2e>
80002258:	80 00       	ld.sh	r0,r0[0x0]
8000225a:	c1 e8       	rjmp	80002296 <Phyuserinput_brdcst_func+0x36>
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	c2 10       	breq	800022a0 <Phyuserinput_brdcst_func+0x40>

80002260 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002260:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002264:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
80002266:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002268:	19 c7       	ld.ub	r7,r12[0x4]
8000226a:	19 d8       	ld.ub	r8,r12[0x5]
8000226c:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002270:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002272:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002274:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002278:	49 0c       	lddpc	r12,800022b8 <Phyuserinput_brdcst_func+0x58>
8000227a:	f0 1f 00 11 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000227e:	1a d6       	st.w	--sp,r6
80002280:	49 0c       	lddpc	r12,800022c0 <Phyuserinput_brdcst_func+0x60>
80002282:	f0 1f 00 0f 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002286:	1a d5       	st.w	--sp,r5
80002288:	48 fc       	lddpc	r12,800022c4 <Phyuserinput_brdcst_func+0x64>
8000228a:	f0 1f 00 0d 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000228e:	5c 77       	castu.h	r7
80002290:	1a d7       	st.w	--sp,r7
80002292:	48 ec       	lddpc	r12,800022c8 <Phyuserinput_brdcst_func+0x68>
80002294:	f0 1f 00 0a 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002298:	1a d4       	st.w	--sp,r4
8000229a:	48 dc       	lddpc	r12,800022cc <Phyuserinput_brdcst_func+0x6c>
8000229c:	f0 1f 00 08 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022a0:	1a d3       	st.w	--sp,r3
800022a2:	48 cc       	lddpc	r12,800022d0 <Phyuserinput_brdcst_func+0x70>
800022a4:	f0 1f 00 06 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022a8:	1a d2       	st.w	--sp,r2
800022aa:	48 bc       	lddpc	r12,800022d4 <Phyuserinput_brdcst_func+0x74>
800022ac:	f0 1f 00 04 	mcall	800022bc <Phyuserinput_brdcst_func+0x5c>
800022b0:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022b2:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022b6:	00 00       	add	r0,r0
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	c2 34       	brge	80002300 <ButtonConfig_reply_func+0x28>
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	5f d8       	srvc	r8
800022c0:	80 00       	ld.sh	r0,r0[0x0]
800022c2:	c2 58       	rjmp	8000230c <ButtonConfig_reply_func+0x34>
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	c2 70       	breq	80002314 <ButtonConfig_reply_func+0x3c>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	c2 84       	brge	8000231a <ButtonConfig_reply_func+0x42>
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c2 98       	rjmp	80002320 <DataSession_brdcst_func+0x4>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c2 ac       	rcall	80002326 <DataSession_brdcst_func+0xa>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c2 cc       	rcall	8000232e <DataSession_brdcst_func+0x12>

800022d8 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022dc:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022e0:	0f 89       	ld.ub	r9,r7[0x0]
800022e2:	30 08       	mov	r8,0
800022e4:	f0 09 18 00 	cp.b	r9,r8
800022e8:	c0 c1       	brne	80002300 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022ea:	48 9c       	lddpc	r12,8000230c <ButtonConfig_reply_func+0x34>
800022ec:	f0 1f 00 09 	mcall	80002310 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022f0:	0f 98       	ld.ub	r8,r7[0x1]
800022f2:	1a d8       	st.w	--sp,r8
800022f4:	48 8c       	lddpc	r12,80002314 <ButtonConfig_reply_func+0x3c>
800022f6:	f0 1f 00 07 	mcall	80002310 <ButtonConfig_reply_func+0x38>
800022fa:	2f fd       	sub	sp,-4
800022fc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002300:	48 6c       	lddpc	r12,80002318 <ButtonConfig_reply_func+0x40>
80002302:	f0 1f 00 04 	mcall	80002310 <ButtonConfig_reply_func+0x38>
80002306:	e3 cd 80 80 	ldm	sp++,r7,pc
8000230a:	00 00       	add	r0,r0
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	c2 ec       	rcall	8000236a <DataSession_brdcst_func+0x4e>
80002310:	80 00       	ld.sh	r0,r0[0x0]
80002312:	5f d8       	srvc	r8
80002314:	80 00       	ld.sh	r0,r0[0x0]
80002316:	c1 28       	rjmp	8000233a <DataSession_brdcst_func+0x1e>
80002318:	80 00       	ld.sh	r0,r0[0x0]
8000231a:	c3 04       	brge	8000237a <DataSession_brdcst_func+0x5e>

8000231c <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
8000231c:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000231e:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002322:	0d 88       	ld.ub	r8,r6[0x0]
80002324:	32 49       	mov	r9,36
80002326:	f2 08 18 00 	cp.b	r8,r9
8000232a:	c2 91       	brne	8000237c <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000232c:	49 7c       	lddpc	r12,80002388 <DataSession_brdcst_func+0x6c>
8000232e:	f0 1f 00 18 	mcall	8000238c <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002332:	0d a5       	ld.ub	r5,r6[0x2]
80002334:	0d b8       	ld.ub	r8,r6[0x3]
80002336:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000233a:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000233c:	0d 98       	ld.ub	r8,r6[0x1]
8000233e:	1a d8       	st.w	--sp,r8
80002340:	49 4c       	lddpc	r12,80002390 <DataSession_brdcst_func+0x74>
80002342:	f0 1f 00 13 	mcall	8000238c <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002346:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000234a:	1a d8       	st.w	--sp,r8
8000234c:	49 2c       	lddpc	r12,80002394 <DataSession_brdcst_func+0x78>
8000234e:	f0 1f 00 10 	mcall	8000238c <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002352:	2f ed       	sub	sp,-8
80002354:	58 05       	cp.w	r5,0
80002356:	c1 80       	breq	80002386 <DataSession_brdcst_func+0x6a>
80002358:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000235a:	49 04       	lddpc	r4,80002398 <DataSession_brdcst_func+0x7c>
8000235c:	ec 07 00 08 	add	r8,r6,r7
80002360:	11 c8       	ld.ub	r8,r8[0x4]
80002362:	1a d8       	st.w	--sp,r8
80002364:	1a d7       	st.w	--sp,r7
80002366:	08 9c       	mov	r12,r4
80002368:	f0 1f 00 09 	mcall	8000238c <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000236c:	2f f7       	sub	r7,-1
8000236e:	5c 57       	castu.b	r7
80002370:	2f ed       	sub	sp,-8
80002372:	ee 05 19 00 	cp.h	r5,r7
80002376:	fe 9b ff f3 	brhi	8000235c <DataSession_brdcst_func+0x40>
8000237a:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
8000237c:	1a d8       	st.w	--sp,r8
8000237e:	48 8c       	lddpc	r12,8000239c <DataSession_brdcst_func+0x80>
80002380:	f0 1f 00 03 	mcall	8000238c <DataSession_brdcst_func+0x70>
80002384:	2f fd       	sub	sp,-4
80002386:	d8 22       	popm	r4-r7,pc
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	c3 20       	breq	800023ee <DataSession_reply_func+0x4e>
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	5f d8       	srvc	r8
80002390:	80 00       	ld.sh	r0,r0[0x0]
80002392:	c3 34       	brge	800023f8 <CallControl_brdcst_func>
80002394:	80 00       	ld.sh	r0,r0[0x0]
80002396:	c3 4c       	rcall	800023fe <CallControl_brdcst_func+0x6>
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	c3 68       	rjmp	80002406 <CallControl_brdcst_func+0xe>
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	c3 80       	breq	8000240e <CallControl_brdcst_func+0x16>

800023a0 <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023a0:	eb cd 40 80 	pushm	r7,lr
800023a4:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023a6:	19 a8       	ld.ub	r8,r12[0x2]
800023a8:	58 08       	cp.w	r8,0
800023aa:	c0 61       	brne	800023b6 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023ac:	48 dc       	lddpc	r12,800023e0 <DataSession_reply_func+0x40>
800023ae:	f0 1f 00 0e 	mcall	800023e4 <DataSession_reply_func+0x44>
800023b2:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023b6:	1a d8       	st.w	--sp,r8
800023b8:	48 cc       	lddpc	r12,800023e8 <DataSession_reply_func+0x48>
800023ba:	f0 1f 00 0b 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023be:	48 cc       	lddpc	r12,800023ec <DataSession_reply_func+0x4c>
800023c0:	f0 1f 00 09 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023c4:	0f b8       	ld.ub	r8,r7[0x3]
800023c6:	1a d8       	st.w	--sp,r8
800023c8:	48 ac       	lddpc	r12,800023f0 <DataSession_reply_func+0x50>
800023ca:	f0 1f 00 07 	mcall	800023e4 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023ce:	0f c8       	ld.ub	r8,r7[0x4]
800023d0:	1a d8       	st.w	--sp,r8
800023d2:	48 9c       	lddpc	r12,800023f4 <DataSession_reply_func+0x54>
800023d4:	f0 1f 00 04 	mcall	800023e4 <DataSession_reply_func+0x44>
800023d8:	2f dd       	sub	sp,-12
800023da:	e3 cd 80 80 	ldm	sp++,r7,pc
800023de:	00 00       	add	r0,r0
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	c3 94       	brge	80002454 <TransmitControl_brdcst_func+0x18>
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	5f d8       	srvc	r8
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	c3 a8       	rjmp	8000245e <TransmitControl_brdcst_func+0x22>
800023ec:	80 00       	ld.sh	r0,r0[0x0]
800023ee:	c3 bc       	rcall	80002464 <TransmitControl_brdcst_func+0x28>
800023f0:	80 00       	ld.sh	r0,r0[0x0]
800023f2:	c3 d0       	breq	8000246c <TransmitControl_brdcst_func+0x30>
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	c3 e0       	breq	80002472 <TransmitControl_brdcst_func+0x36>

800023f8 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800023fc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002400:	0f 98       	ld.ub	r8,r7[0x1]
80002402:	1a d8       	st.w	--sp,r8
80002404:	48 bc       	lddpc	r12,80002430 <CallControl_brdcst_func+0x38>
80002406:	f0 1f 00 0c 	mcall	80002434 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
8000240a:	2f fd       	sub	sp,-4
8000240c:	0f 99       	ld.ub	r9,r7[0x1]
8000240e:	30 38       	mov	r8,3
80002410:	f0 09 18 00 	cp.b	r9,r8
80002414:	c0 41       	brne	8000241c <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002416:	30 09       	mov	r9,0
80002418:	48 88       	lddpc	r8,80002438 <CallControl_brdcst_func+0x40>
8000241a:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
8000241c:	0f 99       	ld.ub	r9,r7[0x1]
8000241e:	30 48       	mov	r8,4
80002420:	f0 09 18 00 	cp.b	r9,r8
80002424:	c0 41       	brne	8000242c <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
80002426:	30 19       	mov	r9,1
80002428:	48 48       	lddpc	r8,80002438 <CallControl_brdcst_func+0x40>
8000242a:	b0 89       	st.b	r8[0x0],r9
8000242c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	c3 f0       	breq	800024b0 <TransmitControl_reply_func+0x2c>
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	5f d8       	srvc	r8
80002438:	00 00       	add	r0,r0
8000243a:	0a 56       	eor	r6,r5

8000243c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000243c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002440:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002444:	0f 99       	ld.ub	r9,r7[0x1]
80002446:	30 08       	mov	r8,0
80002448:	f0 09 18 00 	cp.b	r9,r8
8000244c:	c0 71       	brne	8000245a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000244e:	48 ac       	lddpc	r12,80002474 <TransmitControl_brdcst_func+0x38>
80002450:	f0 1f 00 0a 	mcall	80002478 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002454:	30 09       	mov	r9,0
80002456:	48 a8       	lddpc	r8,8000247c <TransmitControl_brdcst_func+0x40>
80002458:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000245a:	0f 99       	ld.ub	r9,r7[0x1]
8000245c:	30 18       	mov	r8,1
8000245e:	f0 09 18 00 	cp.b	r9,r8
80002462:	c0 71       	brne	80002470 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002464:	48 7c       	lddpc	r12,80002480 <TransmitControl_brdcst_func+0x44>
80002466:	f0 1f 00 05 	mcall	80002478 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000246a:	30 19       	mov	r9,1
8000246c:	48 48       	lddpc	r8,8000247c <TransmitControl_brdcst_func+0x40>
8000246e:	b0 89       	st.b	r8[0x0],r9
80002470:	e3 cd 80 80 	ldm	sp++,r7,pc
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	c4 08       	rjmp	800024f6 <AudioRoutingControl_reply_func+0x12>
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	5f d8       	srvc	r8
8000247c:	00 00       	add	r0,r0
8000247e:	0a 55       	eor	r5,r5
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	c4 20       	breq	80002506 <AudioRoutingControl_reply_func+0x22>

80002484 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000248c:	0f 89       	ld.ub	r9,r7[0x0]
8000248e:	30 08       	mov	r8,0
80002490:	f0 09 18 00 	cp.b	r9,r8
80002494:	c1 61       	brne	800024c0 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002496:	48 ec       	lddpc	r12,800024cc <TransmitControl_reply_func+0x48>
80002498:	f0 1f 00 0e 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
8000249c:	0f 98       	ld.ub	r8,r7[0x1]
8000249e:	1a d8       	st.w	--sp,r8
800024a0:	48 dc       	lddpc	r12,800024d4 <TransmitControl_reply_func+0x50>
800024a2:	f0 1f 00 0c 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024a6:	0f a8       	ld.ub	r8,r7[0x2]
800024a8:	1a d8       	st.w	--sp,r8
800024aa:	48 cc       	lddpc	r12,800024d8 <TransmitControl_reply_func+0x54>
800024ac:	f0 1f 00 09 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024b0:	0f b8       	ld.ub	r8,r7[0x3]
800024b2:	1a d8       	st.w	--sp,r8
800024b4:	48 ac       	lddpc	r12,800024dc <TransmitControl_reply_func+0x58>
800024b6:	f0 1f 00 07 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
800024ba:	2f dd       	sub	sp,-12
800024bc:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024c0:	48 8c       	lddpc	r12,800024e0 <TransmitControl_reply_func+0x5c>
800024c2:	f0 1f 00 04 	mcall	800024d0 <TransmitControl_reply_func+0x4c>
800024c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800024ca:	00 00       	add	r0,r0
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	c4 34       	brge	80002554 <Volume_reply_func+0x40>
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	5f d8       	srvc	r8
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	c4 50       	breq	80002560 <Volume_reply_func+0x4c>
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	c4 64       	brge	80002566 <Volume_reply_func+0x52>
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	c4 80       	breq	8000256e <Volume_reply_func+0x5a>
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	c4 90       	breq	80002574 <Volume_reply_func+0x60>

800024e4 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024e4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024e6:	19 a9       	ld.ub	r9,r12[0x2]
800024e8:	30 08       	mov	r8,0
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 71       	brne	800024fc <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
800024f0:	48 5c       	lddpc	r12,80002504 <AudioRoutingControl_reply_func+0x20>
800024f2:	f0 1f 00 06 	mcall	80002508 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
800024f6:	f0 1f 00 06 	mcall	8000250c <AudioRoutingControl_reply_func+0x28>
800024fa:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800024fc:	48 5c       	lddpc	r12,80002510 <AudioRoutingControl_reply_func+0x2c>
800024fe:	f0 1f 00 03 	mcall	80002508 <AudioRoutingControl_reply_func+0x24>
80002502:	d8 02       	popm	pc
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	c4 a8       	rjmp	8000259a <spk_brdcst_func+0x22>
80002508:	80 00       	ld.sh	r0,r0[0x0]
8000250a:	5f d8       	srvc	r8
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	3f e0       	mov	r0,-2
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	c4 b8       	rjmp	800025a8 <spk_brdcst_func+0x30>

80002514 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002514:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002518:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000251c:	0f 89       	ld.ub	r9,r7[0x0]
8000251e:	30 08       	mov	r8,0
80002520:	f0 09 18 00 	cp.b	r9,r8
80002524:	c1 b1       	brne	8000255a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002526:	0f b8       	ld.ub	r8,r7[0x3]
80002528:	31 09       	mov	r9,16
8000252a:	f2 08 18 00 	cp.b	r8,r9
8000252e:	c0 f1       	brne	8000254c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002530:	48 dc       	lddpc	r12,80002564 <Volume_reply_func+0x50>
80002532:	f0 1f 00 0e 	mcall	80002568 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002536:	0f 99       	ld.ub	r9,r7[0x1]
80002538:	0f a8       	ld.ub	r8,r7[0x2]
8000253a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000253e:	1a d8       	st.w	--sp,r8
80002540:	48 bc       	lddpc	r12,8000256c <Volume_reply_func+0x58>
80002542:	f0 1f 00 0a 	mcall	80002568 <Volume_reply_func+0x54>
80002546:	2f fd       	sub	sp,-4
80002548:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 9c       	lddpc	r12,80002570 <Volume_reply_func+0x5c>
80002550:	f0 1f 00 06 	mcall	80002568 <Volume_reply_func+0x54>
80002554:	2f fd       	sub	sp,-4
80002556:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000255a:	48 7c       	lddpc	r12,80002574 <Volume_reply_func+0x60>
8000255c:	f0 1f 00 03 	mcall	80002568 <Volume_reply_func+0x54>
80002560:	e3 cd 80 80 	ldm	sp++,r7,pc
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	c4 cc       	rcall	800025fe <mic_brdcst_func+0x6>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	5f d8       	srvc	r8
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	c4 e0       	breq	8000260a <mic_brdcst_func+0x12>
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	c4 fc       	rcall	80002610 <mic_brdcst_func+0x18>
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	c5 14       	brge	80002618 <mic_brdcst_func+0x20>

80002578 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000257a:	19 d9       	ld.ub	r9,r12[0x5]
8000257c:	30 08       	mov	r8,0
8000257e:	f0 09 18 00 	cp.b	r9,r8
80002582:	c0 81       	brne	80002592 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002584:	10 99       	mov	r9,r8
80002586:	48 78       	lddpc	r8,800025a0 <spk_brdcst_func+0x28>
80002588:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000258a:	48 7c       	lddpc	r12,800025a4 <spk_brdcst_func+0x2c>
8000258c:	f0 1f 00 07 	mcall	800025a8 <spk_brdcst_func+0x30>
80002590:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002592:	30 19       	mov	r9,1
80002594:	48 38       	lddpc	r8,800025a0 <spk_brdcst_func+0x28>
80002596:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002598:	48 5c       	lddpc	r12,800025ac <spk_brdcst_func+0x34>
8000259a:	f0 1f 00 04 	mcall	800025a8 <spk_brdcst_func+0x30>
8000259e:	d8 02       	popm	pc
800025a0:	00 00       	add	r0,r0
800025a2:	0a 48       	or	r8,r5
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	c5 2c       	rcall	8000264a <mic_brdcst_func+0x52>
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	5f d8       	srvc	r8
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	c5 3c       	rcall	80002654 <mic_reply_func+0x4>

800025b0 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025b0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025b2:	19 a9       	ld.ub	r9,r12[0x2]
800025b4:	30 08       	mov	r8,0
800025b6:	f0 09 18 00 	cp.b	r9,r8
800025ba:	c0 f1       	brne	800025d8 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025bc:	19 e9       	ld.ub	r9,r12[0x6]
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 40       	breq	800025ca <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025c4:	30 19       	mov	r9,1
800025c6:	48 98       	lddpc	r8,800025e8 <spk_reply_func+0x38>
800025c8:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025ca:	19 e8       	ld.ub	r8,r12[0x6]
800025cc:	1a d8       	st.w	--sp,r8
800025ce:	48 8c       	lddpc	r12,800025ec <spk_reply_func+0x3c>
800025d0:	f0 1f 00 08 	mcall	800025f0 <spk_reply_func+0x40>
800025d4:	2f fd       	sub	sp,-4
800025d6:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025d8:	30 09       	mov	r9,0
800025da:	48 48       	lddpc	r8,800025e8 <spk_reply_func+0x38>
800025dc:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025de:	48 6c       	lddpc	r12,800025f4 <spk_reply_func+0x44>
800025e0:	f0 1f 00 04 	mcall	800025f0 <spk_reply_func+0x40>
800025e4:	d8 02       	popm	pc
800025e6:	00 00       	add	r0,r0
800025e8:	00 00       	add	r0,r0
800025ea:	0a 48       	or	r8,r5
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	c5 48       	rjmp	80002696 <mic_reply_func+0x46>
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	5f d8       	srvc	r8
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	c5 58       	rjmp	800026a0 <mic_reply_func+0x50>

800025f8 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800025f8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800025fc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002600:	0f a9       	ld.ub	r9,r7[0x2]
80002602:	30 08       	mov	r8,0
80002604:	f0 09 18 00 	cp.b	r9,r8
80002608:	c0 71       	brne	80002616 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000260a:	48 dc       	lddpc	r12,8000263c <mic_brdcst_func+0x44>
8000260c:	f0 1f 00 0d 	mcall	80002640 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002610:	30 09       	mov	r9,0
80002612:	48 d8       	lddpc	r8,80002644 <mic_brdcst_func+0x4c>
80002614:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002616:	0f a9       	ld.ub	r9,r7[0x2]
80002618:	31 18       	mov	r8,17
8000261a:	f0 09 18 00 	cp.b	r9,r8
8000261e:	c0 d1       	brne	80002638 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002620:	48 ac       	lddpc	r12,80002648 <mic_brdcst_func+0x50>
80002622:	f0 1f 00 08 	mcall	80002640 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002626:	48 89       	lddpc	r9,80002644 <mic_brdcst_func+0x4c>
80002628:	30 18       	mov	r8,1
8000262a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000262c:	13 89       	ld.ub	r9,r9[0x0]
8000262e:	f0 09 18 00 	cp.b	r9,r8
80002632:	c0 31       	brne	80002638 <mic_brdcst_func+0x40>
80002634:	48 68       	lddpc	r8,8000264c <mic_brdcst_func+0x54>
80002636:	11 88       	ld.ub	r8,r8[0x0]
80002638:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	c5 64       	brge	800026ea <dcm_brdcst_func+0x6>
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	5f d8       	srvc	r8
80002644:	00 00       	add	r0,r0
80002646:	0a 59       	eor	r9,r5
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	c5 78       	rjmp	800026f8 <dcm_brdcst_func+0x14>
8000264c:	00 00       	add	r0,r0
8000264e:	0a 56       	eor	r6,r5

80002650 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002650:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002654:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002658:	49 ac       	lddpc	r12,800026c0 <mic_reply_func+0x70>
8000265a:	f0 1f 00 1b 	mcall	800026c4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000265e:	0f 89       	ld.ub	r9,r7[0x0]
80002660:	30 08       	mov	r8,0
80002662:	f0 09 18 00 	cp.b	r9,r8
80002666:	c2 71       	brne	800026b4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002668:	0f 98       	ld.ub	r8,r7[0x1]
8000266a:	30 29       	mov	r9,2
8000266c:	f2 08 18 00 	cp.b	r8,r9
80002670:	c1 b1       	brne	800026a6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002672:	49 6c       	lddpc	r12,800026c8 <mic_reply_func+0x78>
80002674:	f0 1f 00 14 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002678:	0f a8       	ld.ub	r8,r7[0x2]
8000267a:	1a d8       	st.w	--sp,r8
8000267c:	49 4c       	lddpc	r12,800026cc <mic_reply_func+0x7c>
8000267e:	f0 1f 00 12 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002682:	0f b8       	ld.ub	r8,r7[0x3]
80002684:	1a d8       	st.w	--sp,r8
80002686:	49 3c       	lddpc	r12,800026d0 <mic_reply_func+0x80>
80002688:	f0 1f 00 0f 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000268c:	0f c8       	ld.ub	r8,r7[0x4]
8000268e:	1a d8       	st.w	--sp,r8
80002690:	49 1c       	lddpc	r12,800026d4 <mic_reply_func+0x84>
80002692:	f0 1f 00 0d 	mcall	800026c4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002696:	0f d8       	ld.ub	r8,r7[0x5]
80002698:	1a d8       	st.w	--sp,r8
8000269a:	49 0c       	lddpc	r12,800026d8 <mic_reply_func+0x88>
8000269c:	f0 1f 00 0a 	mcall	800026c4 <mic_reply_func+0x74>
800026a0:	2f cd       	sub	sp,-16
800026a2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026a6:	1a d8       	st.w	--sp,r8
800026a8:	48 dc       	lddpc	r12,800026dc <mic_reply_func+0x8c>
800026aa:	f0 1f 00 07 	mcall	800026c4 <mic_reply_func+0x74>
800026ae:	2f fd       	sub	sp,-4
800026b0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026b4:	48 bc       	lddpc	r12,800026e0 <mic_reply_func+0x90>
800026b6:	f0 1f 00 04 	mcall	800026c4 <mic_reply_func+0x74>
800026ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800026be:	00 00       	add	r0,r0
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	c5 8c       	rcall	80002772 <dcm_reply_func+0x46>
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	5f d8       	srvc	r8
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	c5 9c       	rcall	8000277c <dcm_reply_func+0x50>
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	c5 b0       	breq	80002784 <dcm_reply_func+0x58>
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	c5 c4       	brge	8000278a <dcm_reply_func+0x5e>
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	c5 e0       	breq	80002792 <dcm_reply_func+0x66>
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	c5 f8       	rjmp	80002798 <ToneControl_reply_func+0x4>
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	c6 10       	breq	800027a0 <ToneControl_reply_func+0xc>
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	c6 28       	rjmp	800027a6 <ToneControl_reply_func+0x12>

800026e4 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026e4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026e8:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026ec:	48 bc       	lddpc	r12,80002718 <dcm_brdcst_func+0x34>
800026ee:	f0 1f 00 0c 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026f2:	0f 88       	ld.ub	r8,r7[0x0]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	48 bc       	lddpc	r12,80002720 <dcm_brdcst_func+0x3c>
800026f8:	f0 1f 00 09 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026fc:	0f a8       	ld.ub	r8,r7[0x2]
800026fe:	1a d8       	st.w	--sp,r8
80002700:	48 9c       	lddpc	r12,80002724 <dcm_brdcst_func+0x40>
80002702:	f0 1f 00 07 	mcall	8000271c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002706:	0f 98       	ld.ub	r8,r7[0x1]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	48 8c       	lddpc	r12,80002728 <dcm_brdcst_func+0x44>
8000270c:	f0 1f 00 04 	mcall	8000271c <dcm_brdcst_func+0x38>
80002710:	2f dd       	sub	sp,-12
	
	
}
80002712:	e3 cd 80 80 	ldm	sp++,r7,pc
80002716:	00 00       	add	r0,r0
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	c6 38       	rjmp	800027e0 <app_cfg+0x24>
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	5f d8       	srvc	r8
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	c6 4c       	rcall	800027ea <app_cfg+0x2e>
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	c6 60       	breq	800027f2 <app_cfg+0x36>
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	c6 78       	rjmp	800027f8 <app_cfg+0x3c>

8000272c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000272c:	eb cd 40 80 	pushm	r7,lr
80002730:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002732:	19 a9       	ld.ub	r9,r12[0x2]
80002734:	30 08       	mov	r8,0
80002736:	f0 09 18 00 	cp.b	r9,r8
8000273a:	c1 b1       	brne	80002770 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000273c:	19 b8       	ld.ub	r8,r12[0x3]
8000273e:	30 19       	mov	r9,1
80002740:	f2 08 18 00 	cp.b	r8,r9
80002744:	c0 51       	brne	8000274e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002746:	48 ec       	lddpc	r12,8000277c <dcm_reply_func+0x50>
80002748:	f0 1f 00 0e 	mcall	80002780 <dcm_reply_func+0x54>
8000274c:	c0 a8       	rjmp	80002760 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000274e:	58 08       	cp.w	r8,0
80002750:	c0 51       	brne	8000275a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002752:	48 dc       	lddpc	r12,80002784 <dcm_reply_func+0x58>
80002754:	f0 1f 00 0b 	mcall	80002780 <dcm_reply_func+0x54>
80002758:	c0 48       	rjmp	80002760 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000275a:	48 cc       	lddpc	r12,80002788 <dcm_reply_func+0x5c>
8000275c:	f0 1f 00 09 	mcall	80002780 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002760:	0f d8       	ld.ub	r8,r7[0x5]
80002762:	1a d8       	st.w	--sp,r8
80002764:	48 ac       	lddpc	r12,8000278c <dcm_reply_func+0x60>
80002766:	f0 1f 00 07 	mcall	80002780 <dcm_reply_func+0x54>
8000276a:	2f fd       	sub	sp,-4
8000276c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002770:	48 8c       	lddpc	r12,80002790 <dcm_reply_func+0x64>
80002772:	f0 1f 00 04 	mcall	80002780 <dcm_reply_func+0x54>
80002776:	e3 cd 80 80 	ldm	sp++,r7,pc
8000277a:	00 00       	add	r0,r0
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	c6 94       	brge	80002850 <app_cfg+0x94>
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	5f d8       	srvc	r8
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	c6 a8       	rjmp	8000285a <app_payload_rx_proc+0x2>
80002788:	80 00       	ld.sh	r0,r0[0x0]
8000278a:	c6 bc       	rcall	80002860 <app_payload_rx_proc+0x8>
8000278c:	80 00       	ld.sh	r0,r0[0x0]
8000278e:	c6 d0       	breq	80002868 <app_payload_rx_proc+0x10>
80002790:	80 00       	ld.sh	r0,r0[0x0]
80002792:	c6 dc       	rcall	8000286c <app_payload_rx_proc+0x14>

80002794 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002794:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002796:	19 a9       	ld.ub	r9,r12[0x2]
80002798:	30 08       	mov	r8,0
8000279a:	f0 09 18 00 	cp.b	r9,r8
8000279e:	c0 51       	brne	800027a8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027a0:	48 4c       	lddpc	r12,800027b0 <ToneControl_reply_func+0x1c>
800027a2:	f0 1f 00 05 	mcall	800027b4 <ToneControl_reply_func+0x20>
800027a6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027a8:	48 4c       	lddpc	r12,800027b8 <ToneControl_reply_func+0x24>
800027aa:	f0 1f 00 03 	mcall	800027b4 <ToneControl_reply_func+0x20>
800027ae:	d8 02       	popm	pc
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	c6 e8       	rjmp	8000288e <app_payload_rx_proc+0x36>
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	5f d8       	srvc	r8
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	c6 f0       	breq	80002898 <app_payload_rx_proc+0x40>

800027bc <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027bc:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027be:	f0 1f 00 1d 	mcall	80002830 <app_cfg+0x74>
800027c2:	49 d8       	lddpc	r8,80002834 <app_cfg+0x78>
800027c4:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027c6:	49 d6       	lddpc	r6,80002838 <app_cfg+0x7c>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027c8:	49 d4       	lddpc	r4,8000283c <app_cfg+0x80>
				else
				{
					isAudioRouting++;
				}

				log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
800027ca:	49 e3       	lddpc	r3,80002840 <app_cfg+0x84>
800027cc:	49 e5       	lddpc	r5,80002844 <app_cfg+0x88>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027ce:	30 40       	mov	r0,4
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027d0:	30 21       	mov	r1,2
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027d2:	30 12       	mov	r2,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800027d4:	10 97       	mov	r7,r8
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800027d6:	6c 08       	ld.w	r8,r6[0x0]
800027d8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027dc:	58 38       	cp.w	r8,3
800027de:	c2 21       	brne	80002822 <app_cfg+0x66>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800027e0:	f0 1f 00 1a 	mcall	80002848 <app_cfg+0x8c>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800027e4:	68 08       	ld.w	r8,r4[0x0]
800027e6:	58 08       	cp.w	r8,0
800027e8:	c0 51       	brne	800027f2 <app_cfg+0x36>
				{
					xcmp_data_session();
800027ea:	f0 1f 00 19 	mcall	8000284c <app_cfg+0x90>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027ee:	89 02       	st.w	r4[0x0],r2
800027f0:	c1 38       	rjmp	80002816 <app_cfg+0x5a>
				}
				else if(isAudioRouting == 1)
800027f2:	58 18       	cp.w	r8,1
800027f4:	c0 31       	brne	800027fa <app_cfg+0x3e>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027f6:	89 01       	st.w	r4[0x0],r1
800027f8:	c0 f8       	rjmp	80002816 <app_cfg+0x5a>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800027fa:	58 28       	cp.w	r8,2
800027fc:	c0 61       	brne	80002808 <app_cfg+0x4c>
				{
					xcmp_data_session();
800027fe:	f0 1f 00 14 	mcall	8000284c <app_cfg+0x90>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002802:	30 38       	mov	r8,3
80002804:	89 08       	st.w	r4[0x0],r8
80002806:	c0 88       	rjmp	80002816 <app_cfg+0x5a>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
80002808:	58 38       	cp.w	r8,3
8000280a:	e9 f0 0a 00 	st.weq	r4[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
8000280e:	f7 b8 01 ff 	subne	r8,-1
80002812:	e9 f8 1a 00 	st.wne	r4[0x0],r8
				}

				log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
80002816:	6a 08       	ld.w	r8,r5[0x0]
80002818:	1a d8       	st.w	--sp,r8
8000281a:	06 9c       	mov	r12,r3
8000281c:	f0 1f 00 0d 	mcall	80002850 <app_cfg+0x94>
80002820:	2f fd       	sub	sp,-4
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002822:	e0 6b 07 d0 	mov	r11,2000
80002826:	0e 9c       	mov	r12,r7
80002828:	f0 1f 00 0b 	mcall	80002854 <app_cfg+0x98>
	}
8000282c:	cd 5b       	rjmp	800027d6 <app_cfg+0x1a>
8000282e:	00 00       	add	r0,r0
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	59 4c       	cp.w	r12,20
80002834:	00 00       	add	r0,r0
80002836:	0a 50       	eor	r0,r5
80002838:	00 00       	add	r0,r0
8000283a:	0d 7c       	ld.ub	r12,--r6
8000283c:	00 00       	add	r0,r0
8000283e:	0a 4c       	or	r12,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	c6 fc       	rcall	80002920 <payload_init+0x28>
80002844:	00 00       	add	r0,r0
80002846:	0a 60       	and	r0,r5
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	3f e0       	mov	r0,-2
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	3e cc       	mov	r12,-20
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	5f d8       	srvc	r8
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	5a b4       	cp.w	r4,-21

80002858 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80002858:	eb cd 40 80 	pushm	r7,lr
8000285c:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000285e:	48 c9       	lddpc	r9,8000288c <app_payload_rx_proc+0x34>
80002860:	13 88       	ld.ub	r8,r9[0x0]
80002862:	2f f8       	sub	r8,-1
80002864:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002866:	30 39       	mov	r9,3
80002868:	f2 08 18 00 	cp.b	r8,r9
8000286c:	c0 71       	brne	8000287a <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000286e:	30 09       	mov	r9,0
80002870:	48 78       	lddpc	r8,8000288c <app_payload_rx_proc+0x34>
80002872:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002874:	48 7c       	lddpc	r12,80002890 <app_payload_rx_proc+0x38>
80002876:	f0 1f 00 08 	mcall	80002894 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000287a:	48 88       	lddpc	r8,80002898 <app_payload_rx_proc+0x40>
8000287c:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000287e:	48 88       	lddpc	r8,8000289c <app_payload_rx_proc+0x44>
80002880:	70 0c       	ld.w	r12,r8[0x0]
80002882:	0e 9b       	mov	r11,r7
80002884:	f0 1f 00 07 	mcall	800028a0 <app_payload_rx_proc+0x48>

}
80002888:	e3 cd 80 80 	ldm	sp++,r7,pc
8000288c:	00 00       	add	r0,r0
8000288e:	0a 5a       	eor	r10,r5
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	c7 18       	rjmp	80002974 <payload_rx_process+0x44>
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	5f d8       	srvc	r8
80002898:	00 00       	add	r0,r0
8000289a:	0a 54       	eor	r4,r5
8000289c:	00 00       	add	r0,r0
8000289e:	0a 78       	tst	r8,r5
800028a0:	80 00       	ld.sh	r0,r0[0x0]
800028a2:	29 d0       	sub	r0,-99

800028a4 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028a4:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028a6:	19 e8       	ld.ub	r8,r12[0x6]
800028a8:	30 19       	mov	r9,1
800028aa:	f2 08 18 00 	cp.b	r8,r9
800028ae:	c0 61       	brne	800028ba <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028b0:	48 98       	lddpc	r8,800028d4 <DeviceInitializationStatus_brdcst_func+0x30>
800028b2:	70 09       	ld.w	r9,r8[0x0]
800028b4:	a1 a9       	sbr	r9,0x0
800028b6:	91 09       	st.w	r8[0x0],r9
800028b8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028ba:	30 29       	mov	r9,2
800028bc:	f2 08 18 00 	cp.b	r8,r9
800028c0:	c0 80       	breq	800028d0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028c2:	48 58       	lddpc	r8,800028d4 <DeviceInitializationStatus_brdcst_func+0x30>
800028c4:	70 09       	ld.w	r9,r8[0x0]
800028c6:	e0 19 ff fc 	andl	r9,0xfffc
800028ca:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028cc:	f0 1f 00 03 	mcall	800028d8 <DeviceInitializationStatus_brdcst_func+0x34>
800028d0:	d8 02       	popm	pc
800028d2:	00 00       	add	r0,r0
800028d4:	00 00       	add	r0,r0
800028d6:	0d 7c       	ld.ub	r12,--r6
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	3f 34       	mov	r4,-13

800028dc <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028dc:	20 1c       	sub	r12,1
800028de:	5c 5c       	castu.b	r12
800028e0:	31 18       	mov	r8,17
800028e2:	f0 0c 18 00 	cp.b	r12,r8
800028e6:	e0 88 00 03 	brls	800028ec <CalculateBurst+0x10>
800028ea:	5e fd       	retal	0
800028ec:	48 28       	lddpc	r8,800028f4 <CalculateBurst+0x18>
800028ee:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028f2:	5e fc       	retal	r12
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	c7 2c       	rcall	800029da <set_idle_store+0xa>

800028f8 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028f8:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028fa:	48 98       	lddpc	r8,8000291c <payload_init+0x24>
800028fc:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028fe:	48 98       	lddpc	r8,80002920 <payload_init+0x28>
80002900:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002902:	30 09       	mov	r9,0
80002904:	1a d9       	st.w	--sp,r9
80002906:	1a d9       	st.w	--sp,r9
80002908:	1a d9       	st.w	--sp,r9
8000290a:	30 28       	mov	r8,2
8000290c:	e0 6a 04 00 	mov	r10,1024
80002910:	48 5b       	lddpc	r11,80002924 <payload_init+0x2c>
80002912:	48 6c       	lddpc	r12,80002928 <payload_init+0x30>
80002914:	f0 1f 00 06 	mcall	8000292c <payload_init+0x34>
80002918:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000291a:	d8 02       	popm	pc
8000291c:	00 00       	add	r0,r0
8000291e:	0a 64       	and	r4,r5
80002920:	00 00       	add	r0,r0
80002922:	0a 68       	and	r8,r5
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	c7 74       	brge	80002a14 <phy_tx+0x24>
80002928:	80 00       	ld.sh	r0,r0[0x0]
8000292a:	29 30       	sub	r0,-109
8000292c:	80 00       	ld.sh	r0,r0[0x0]
8000292e:	5c 14       	scr	r4

80002930 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002930:	eb cd 40 f8 	pushm	r3-r7,lr
80002934:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002936:	48 e8       	lddpc	r8,8000296c <payload_rx_process+0x3c>
80002938:	70 08       	ld.w	r8,r8[0x0]
8000293a:	58 08       	cp.w	r8,0
8000293c:	c0 71       	brne	8000294a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000293e:	30 4b       	mov	r11,4
80002940:	30 5c       	mov	r12,5
80002942:	f0 1f 00 0c 	mcall	80002970 <payload_rx_process+0x40>
80002946:	48 a8       	lddpc	r8,8000296c <payload_rx_process+0x3c>
80002948:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000294a:	48 96       	lddpc	r6,8000296c <payload_rx_process+0x3c>
8000294c:	30 05       	mov	r5,0
8000294e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002950:	48 93       	lddpc	r3,80002974 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002952:	6c 0c       	ld.w	r12,r6[0x0]
80002954:	0a 99       	mov	r9,r5
80002956:	08 9a       	mov	r10,r4
80002958:	1a 9b       	mov	r11,sp
8000295a:	f0 1f 00 08 	mcall	80002978 <payload_rx_process+0x48>
8000295e:	58 1c       	cp.w	r12,1
80002960:	cf 91       	brne	80002952 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002962:	66 08       	ld.w	r8,r3[0x0]
80002964:	40 0c       	lddsp	r12,sp[0x0]
80002966:	5d 18       	icall	r8
80002968:	cf 5b       	rjmp	80002952 <payload_rx_process+0x22>
8000296a:	00 00       	add	r0,r0
8000296c:	00 00       	add	r0,r0
8000296e:	0a 94       	mov	r4,r5
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	55 40       	stdsp	sp[0x150],r0
80002974:	00 00       	add	r0,r0
80002976:	0a 64       	and	r4,r5
80002978:	80 00       	ld.sh	r0,r0[0x0]
8000297a:	52 34       	stdsp	sp[0x8c],r4

8000297c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000297c:	d4 01       	pushm	lr
8000297e:	20 2d       	sub	sp,8
80002980:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002982:	30 09       	mov	r9,0
80002984:	fa ca ff f8 	sub	r10,sp,-8
80002988:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000298a:	1a 9b       	mov	r11,sp
8000298c:	f0 1f 00 02 	mcall	80002994 <set_idle_store_isr+0x18>
}
80002990:	2f ed       	sub	sp,-8
80002992:	d8 02       	popm	pc
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	53 f0       	stdsp	sp[0xfc],r0

80002998 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002998:	d4 01       	pushm	lr
8000299a:	20 2d       	sub	sp,8
8000299c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000299e:	58 0c       	cp.w	r12,0
800029a0:	c1 10       	breq	800029c2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029a2:	30 08       	mov	r8,0
800029a4:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029a6:	98 88       	ld.uh	r8,r12[0x0]
800029a8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029ac:	e0 48 40 00 	cp.w	r8,16384
800029b0:	c0 91       	brne	800029c2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029b2:	48 68       	lddpc	r8,800029c8 <phy_rx+0x30>
800029b4:	70 0c       	ld.w	r12,r8[0x0]
800029b6:	30 09       	mov	r9,0
800029b8:	fa ca ff fc 	sub	r10,sp,-4
800029bc:	1a 9b       	mov	r11,sp
800029be:	f0 1f 00 04 	mcall	800029cc <phy_rx+0x34>
		}	

    }
		
 
}
800029c2:	2f ed       	sub	sp,-8
800029c4:	d8 02       	popm	pc
800029c6:	00 00       	add	r0,r0
800029c8:	00 00       	add	r0,r0
800029ca:	0a c4       	st.b	r5++,r4
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	53 f0       	stdsp	sp[0xfc],r0

800029d0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029d0:	eb cd 40 80 	pushm	r7,lr
800029d4:	20 1d       	sub	sp,4
800029d6:	fa c7 ff fc 	sub	r7,sp,-4
800029da:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029dc:	30 09       	mov	r9,0
800029de:	12 9a       	mov	r10,r9
800029e0:	1a 9b       	mov	r11,sp
800029e2:	f0 1f 00 03 	mcall	800029ec <set_idle_store+0x1c>
}
800029e6:	2f fd       	sub	sp,-4
800029e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029ec:	80 00       	ld.sh	r0,r0[0x0]
800029ee:	54 40       	stdsp	sp[0x110],r0

800029f0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029f0:	d4 01       	pushm	lr
800029f2:	20 1d       	sub	sp,4
800029f4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029f6:	98 88       	ld.uh	r8,r12[0x0]
800029f8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029fc:	e0 48 40 00 	cp.w	r8,16384
80002a00:	c0 d1       	brne	80002a1a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a02:	49 08       	lddpc	r8,80002a40 <phy_tx+0x50>
80002a04:	70 08       	ld.w	r8,r8[0x0]
80002a06:	58 08       	cp.w	r8,0
80002a08:	c1 a0       	breq	80002a3c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a0a:	48 e8       	lddpc	r8,80002a40 <phy_tx+0x50>
80002a0c:	70 0c       	ld.w	r12,r8[0x0]
80002a0e:	30 09       	mov	r9,0
80002a10:	12 9a       	mov	r10,r9
80002a12:	1a 9b       	mov	r11,sp
80002a14:	f0 1f 00 0c 	mcall	80002a44 <phy_tx+0x54>
80002a18:	c1 28       	rjmp	80002a3c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a1a:	e0 48 10 00 	cp.w	r8,4096
80002a1e:	5f 0a       	sreq	r10
80002a20:	e0 48 20 00 	cp.w	r8,8192
80002a24:	5f 09       	sreq	r9
80002a26:	f5 e9 10 09 	or	r9,r10,r9
80002a2a:	c0 71       	brne	80002a38 <phy_tx+0x48>
80002a2c:	e0 48 50 00 	cp.w	r8,20480
80002a30:	c0 40       	breq	80002a38 <phy_tx+0x48>
80002a32:	e0 48 60 00 	cp.w	r8,24576
80002a36:	c0 31       	brne	80002a3c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a38:	48 48       	lddpc	r8,80002a48 <phy_tx+0x58>
80002a3a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a3c:	2f fd       	sub	sp,-4
80002a3e:	d8 02       	popm	pc
80002a40:	00 00       	add	r0,r0
80002a42:	0a d0       	st.w	--r5,r0
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	54 40       	stdsp	sp[0x110],r0
80002a48:	00 00       	add	r0,r0
80002a4a:	0a c0       	st.b	r5++,r0

80002a4c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a4c:	d4 01       	pushm	lr
80002a4e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a50:	30 08       	mov	r8,0
80002a52:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a54:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a56:	1a 9a       	mov	r10,sp
80002a58:	fa cb ff fc 	sub	r11,sp,-4
80002a5c:	f0 1f 00 05 	mcall	80002a70 <get_idle_store_isr+0x24>
80002a60:	58 1c       	cp.w	r12,1
80002a62:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a66:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a6a:	2f ed       	sub	sp,-8
80002a6c:	d8 02       	popm	pc
80002a6e:	00 00       	add	r0,r0
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	51 44       	stdsp	sp[0x50],r4

80002a74 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a74:	eb cd 40 c0 	pushm	r6-r7,lr
80002a78:	20 1d       	sub	sp,4
80002a7a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a7c:	fe f8 04 70 	ld.w	r8,pc[1136]
80002a80:	70 08       	ld.w	r8,r8[0x0]
80002a82:	58 08       	cp.w	r8,0
80002a84:	c7 40       	breq	80002b6c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a86:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a88:	30 08       	mov	r8,0
80002a8a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a8c:	fe f8 04 64 	ld.w	r8,pc[1124]
80002a90:	70 08       	ld.w	r8,r8[0x0]
80002a92:	58 18       	cp.w	r8,1
80002a94:	c2 90       	breq	80002ae6 <phy_tx_func+0x72>
80002a96:	c0 43       	brcs	80002a9e <phy_tx_func+0x2a>
80002a98:	58 28       	cp.w	r8,2
80002a9a:	c6 91       	brne	80002b6c <phy_tx_func+0xf8>
80002a9c:	c6 18       	rjmp	80002b5e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a9e:	fe f8 04 4e 	ld.w	r8,pc[1102]
80002aa2:	70 0c       	ld.w	r12,r8[0x0]
80002aa4:	1a 9a       	mov	r10,sp
80002aa6:	fe fb 04 4e 	ld.w	r11,pc[1102]
80002aaa:	f0 1f 01 14 	mcall	80002ef8 <phy_tx_func+0x484>
80002aae:	58 1c       	cp.w	r12,1
80002ab0:	c1 51       	brne	80002ada <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002ab2:	fe f8 04 42 	ld.w	r8,pc[1090]
80002ab6:	70 08       	ld.w	r8,r8[0x0]
80002ab8:	11 9a       	ld.ub	r10,r8[0x1]
80002aba:	fe f9 04 42 	ld.w	r9,pc[1090]
80002abe:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ac0:	90 88       	ld.uh	r8,r8[0x0]
80002ac2:	ea 18 ab cd 	orh	r8,0xabcd
80002ac6:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ac8:	30 19       	mov	r9,1
80002aca:	fe f8 04 36 	ld.w	r8,pc[1078]
80002ace:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ad0:	30 19       	mov	r9,1
80002ad2:	fe f8 04 1e 	ld.w	r8,pc[1054]
80002ad6:	91 09       	st.w	r8[0x0],r9
80002ad8:	c4 a8       	rjmp	80002b6c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002ada:	e0 68 5a 5a 	mov	r8,23130
80002ade:	ea 18 ab cd 	orh	r8,0xabcd
80002ae2:	8f 18       	st.w	r7[0x4],r8
80002ae4:	c4 48       	rjmp	80002b6c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ae6:	fe f9 04 1a 	ld.w	r9,pc[1050]
80002aea:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002aec:	fe fa 04 08 	ld.w	r10,pc[1032]
80002af0:	74 0a       	ld.w	r10,r10[0x0]
80002af2:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002af6:	b1 6a       	lsl	r10,0x10
80002af8:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002afa:	2f f8       	sub	r8,-1
80002afc:	5c 58       	castu.b	r8
80002afe:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b00:	fe fa 03 fc 	ld.w	r10,pc[1020]
80002b04:	94 09       	ld.sh	r9,r10[0x0]
80002b06:	20 29       	sub	r9,2
80002b08:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b0a:	30 0a       	mov	r10,0
80002b0c:	f4 09 19 00 	cp.h	r9,r10
80002b10:	e0 89 00 0b 	brgt	80002b26 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b14:	78 18       	ld.w	r8,r12[0x4]
80002b16:	e8 18 00 ba 	orl	r8,0xba
80002b1a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b1c:	30 09       	mov	r9,0
80002b1e:	fe f8 03 d2 	ld.w	r8,pc[978]
80002b22:	91 09       	st.w	r8[0x0],r9
80002b24:	c2 48       	rjmp	80002b6c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b26:	fe f9 03 ce 	ld.w	r9,pc[974]
80002b2a:	72 09       	ld.w	r9,r9[0x0]
80002b2c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b30:	78 1a       	ld.w	r10,r12[0x4]
80002b32:	f5 e9 10 09 	or	r9,r10,r9
80002b36:	99 19       	st.w	r12[0x4],r9
80002b38:	2f f8       	sub	r8,-1
80002b3a:	fe f9 03 c6 	ld.w	r9,pc[966]
80002b3e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b40:	fe f9 03 bc 	ld.w	r9,pc[956]
80002b44:	92 08       	ld.sh	r8,r9[0x0]
80002b46:	20 28       	sub	r8,2
80002b48:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b4a:	30 09       	mov	r9,0
80002b4c:	f2 08 19 00 	cp.h	r8,r9
80002b50:	e0 89 00 0e 	brgt	80002b6c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b54:	30 29       	mov	r9,2
80002b56:	fe f8 03 9a 	ld.w	r8,pc[922]
80002b5a:	91 09       	st.w	r8[0x0],r9
80002b5c:	c0 88       	rjmp	80002b6c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b5e:	fc 18 00 ba 	movh	r8,0xba
80002b62:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b64:	30 09       	mov	r9,0
80002b66:	fe f8 03 8a 	ld.w	r8,pc[906]
80002b6a:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002b6c:	fe f8 03 98 	ld.w	r8,pc[920]
80002b70:	11 89       	ld.ub	r9,r8[0x0]
80002b72:	30 18       	mov	r8,1
80002b74:	f0 09 18 00 	cp.b	r9,r8
80002b78:	e0 81 01 af 	brne	80002ed6 <phy_tx_func+0x462>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b7c:	fe f8 03 8c 	ld.w	r8,pc[908]
80002b80:	70 08       	ld.w	r8,r8[0x0]
80002b82:	e0 48 05 b0 	cp.w	r8,1456
80002b86:	f9 b8 02 00 	movhs	r8,0
80002b8a:	fe f9 03 7e 	ld.w	r9,pc[894]
80002b8e:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002b90:	fe f8 03 7c 	ld.w	r8,pc[892]
80002b94:	70 08       	ld.w	r8,r8[0x0]
80002b96:	58 68       	cp.w	r8,6
80002b98:	e0 8b 01 95 	brhi	80002ec2 <phy_tx_func+0x44e>
80002b9c:	fe f9 03 74 	ld.w	r9,pc[884]
80002ba0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002ba4:	fe f8 03 70 	ld.w	r8,pc[880]
80002ba8:	70 08       	ld.w	r8,r8[0x0]
80002baa:	58 08       	cp.w	r8,0
80002bac:	c0 b0       	breq	80002bc2 <phy_tx_func+0x14e>
80002bae:	fe f8 03 66 	ld.w	r8,pc[870]
80002bb2:	70 08       	ld.w	r8,r8[0x0]
80002bb4:	58 a8       	cp.w	r8,10
80002bb6:	c0 60       	breq	80002bc2 <phy_tx_func+0x14e>
80002bb8:	fe f8 03 5c 	ld.w	r8,pc[860]
80002bbc:	70 08       	ld.w	r8,r8[0x0]
80002bbe:	58 18       	cp.w	r8,1
80002bc0:	c0 a1       	brne	80002bd4 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bc2:	e0 68 5a 5a 	mov	r8,23130
80002bc6:	ea 18 ab cd 	orh	r8,0xabcd
80002bca:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002bcc:	30 08       	mov	r8,0
80002bce:	8f 38       	st.w	r7[0xc],r8
80002bd0:	e0 8f 01 8a 	bral	80002ee4 <phy_tx_func+0x470>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002bd4:	fe f8 03 40 	ld.w	r8,pc[832]
80002bd8:	70 08       	ld.w	r8,r8[0x0]
80002bda:	58 38       	cp.w	r8,3
80002bdc:	c0 91       	brne	80002bee <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bde:	fe f8 03 3a 	ld.w	r8,pc[826]
80002be2:	70 09       	ld.w	r9,r8[0x0]
80002be4:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002be6:	70 18       	ld.w	r8,r8[0x4]
80002be8:	8f 38       	st.w	r7[0xc],r8
80002bea:	e0 8f 01 7d 	bral	80002ee4 <phy_tx_func+0x470>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002bee:	fe f8 03 26 	ld.w	r8,pc[806]
80002bf2:	70 08       	ld.w	r8,r8[0x0]
80002bf4:	58 28       	cp.w	r8,2
80002bf6:	c1 31       	brne	80002c1c <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002bf8:	e0 68 c0 32 	mov	r8,49202
80002bfc:	ea 18 ab cd 	orh	r8,0xabcd
80002c00:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c02:	fe 78 84 7f 	mov	r8,-31617
80002c06:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c08:	fe f8 03 14 	ld.w	r8,pc[788]
80002c0c:	90 08       	ld.sh	r8,r8[0x0]
80002c0e:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c10:	30 39       	mov	r9,3
80002c12:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c16:	91 09       	st.w	r8[0x0],r9
80002c18:	e0 8f 01 66 	bral	80002ee4 <phy_tx_func+0x470>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c1c:	e0 68 c0 0e 	mov	r8,49166
80002c20:	ea 18 ab cd 	orh	r8,0xabcd
80002c24:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c26:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c2a:	90 09       	ld.sh	r9,r8[0x0]
80002c2c:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c2e:	90 18       	ld.sh	r8,r8[0x2]
80002c30:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c32:	30 19       	mov	r9,1
80002c34:	fe f8 02 d8 	ld.w	r8,pc[728]
80002c38:	91 09       	st.w	r8[0x0],r9
80002c3a:	e0 8f 01 55 	bral	80002ee4 <phy_tx_func+0x470>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c3e:	fe 78 88 f2 	mov	r8,-30478
80002c42:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c44:	fe f8 02 d0 	ld.w	r8,pc[720]
80002c48:	70 08       	ld.w	r8,r8[0x0]
80002c4a:	58 48       	cp.w	r8,4
80002c4c:	c0 60       	breq	80002c58 <phy_tx_func+0x1e4>
80002c4e:	c4 53       	brcs	80002cd8 <phy_tx_func+0x264>
80002c50:	58 98       	cp.w	r8,9
80002c52:	e0 8b 00 43 	brhi	80002cd8 <phy_tx_func+0x264>
80002c56:	c2 98       	rjmp	80002ca8 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c58:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c5c:	11 89       	ld.ub	r9,r8[0x0]
80002c5e:	30 18       	mov	r8,1
80002c60:	f0 09 18 00 	cp.b	r9,r8
80002c64:	c0 a1       	brne	80002c78 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c66:	fe f8 02 c2 	ld.w	r8,pc[706]
80002c6a:	90 09       	ld.sh	r9,r8[0x0]
80002c6c:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002c6e:	90 19       	ld.sh	r9,r8[0x2]
80002c70:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002c72:	90 28       	ld.sh	r8,r8[0x4]
80002c74:	ae 78       	st.h	r7[0xe],r8
80002c76:	c1 48       	rjmp	80002c9e <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c78:	fe f9 02 b4 	ld.w	r9,pc[692]
80002c7c:	92 0b       	ld.sh	r11,r9[0x0]
80002c7e:	fe f8 02 aa 	ld.w	r8,pc[682]
80002c82:	90 0a       	ld.sh	r10,r8[0x0]
80002c84:	f7 ea 20 0a 	eor	r10,r11,r10
80002c88:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002c8a:	92 1b       	ld.sh	r11,r9[0x2]
80002c8c:	90 1a       	ld.sh	r10,r8[0x2]
80002c8e:	f7 ea 20 0a 	eor	r10,r11,r10
80002c92:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002c94:	92 29       	ld.sh	r9,r9[0x4]
80002c96:	90 28       	ld.sh	r8,r8[0x4]
80002c98:	f3 e8 20 08 	eor	r8,r9,r8
80002c9c:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002c9e:	30 29       	mov	r9,2
80002ca0:	fe f8 02 6c 	ld.w	r8,pc[620]
80002ca4:	91 09       	st.w	r8[0x0],r9
80002ca6:	c1 f9       	rjmp	80002ee4 <phy_tx_func+0x470>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002ca8:	fe f9 02 84 	ld.w	r9,pc[644]
80002cac:	92 0b       	ld.sh	r11,r9[0x0]
80002cae:	fe f8 02 7a 	ld.w	r8,pc[634]
80002cb2:	90 0a       	ld.sh	r10,r8[0x0]
80002cb4:	f7 ea 20 0a 	eor	r10,r11,r10
80002cb8:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002cba:	92 1b       	ld.sh	r11,r9[0x2]
80002cbc:	90 1a       	ld.sh	r10,r8[0x2]
80002cbe:	f7 ea 20 0a 	eor	r10,r11,r10
80002cc2:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cc4:	92 29       	ld.sh	r9,r9[0x4]
80002cc6:	90 28       	ld.sh	r8,r8[0x4]
80002cc8:	f3 e8 20 08 	eor	r8,r9,r8
80002ccc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cce:	30 29       	mov	r9,2
80002cd0:	fe f8 02 3c 	ld.w	r8,pc[572]
80002cd4:	91 09       	st.w	r8[0x0],r9
80002cd6:	c0 79       	rjmp	80002ee4 <phy_tx_func+0x470>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002cd8:	e0 68 5a 5a 	mov	r8,23130
80002cdc:	ea 18 ab cd 	orh	r8,0xabcd
80002ce0:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ce2:	30 08       	mov	r8,0
80002ce4:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002ce6:	fe f9 02 26 	ld.w	r9,pc[550]
80002cea:	93 08       	st.w	r9[0x0],r8
80002cec:	cf c8       	rjmp	80002ee4 <phy_tx_func+0x470>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80002cee:	fe f8 02 3e 	ld.w	r8,pc[574]
80002cf2:	90 38       	ld.sh	r8,r8[0x6]
80002cf4:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002cf6:	e0 68 00 ba 	mov	r8,186
80002cfa:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002cfc:	30 08       	mov	r8,0
80002cfe:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d00:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d02:	30 09       	mov	r9,0
80002d04:	fe f8 02 08 	ld.w	r8,pc[520]
80002d08:	91 09       	st.w	r8[0x0],r9
80002d0a:	ce d8       	rjmp	80002ee4 <phy_tx_func+0x470>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d0c:	fe f8 02 10 	ld.w	r8,pc[528]
80002d10:	90 18       	ld.sh	r8,r8[0x2]
80002d12:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d14:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d18:	90 08       	ld.sh	r8,r8[0x0]
80002d1a:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d1c:	4f e8       	lddpc	r8,80002f14 <phy_tx_func+0x4a0>
80002d1e:	70 08       	ld.w	r8,r8[0x0]
80002d20:	58 48       	cp.w	r8,4
80002d22:	c0 d1       	brne	80002d3c <phy_tx_func+0x2c8>
80002d24:	fe f8 02 00 	ld.w	r8,pc[512]
80002d28:	11 89       	ld.ub	r9,r8[0x0]
80002d2a:	30 18       	mov	r8,1
80002d2c:	f0 09 18 00 	cp.b	r9,r8
80002d30:	c0 61       	brne	80002d3c <phy_tx_func+0x2c8>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d32:	4f c8       	lddpc	r8,80002f20 <phy_tx_func+0x4ac>
80002d34:	90 18       	ld.sh	r8,r8[0x2]
80002d36:	a9 a8       	sbr	r8,0x8
80002d38:	ae 68       	st.h	r7[0xc],r8
80002d3a:	c0 48       	rjmp	80002d42 <phy_tx_func+0x2ce>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d3c:	4f 98       	lddpc	r8,80002f20 <phy_tx_func+0x4ac>
80002d3e:	90 18       	ld.sh	r8,r8[0x2]
80002d40:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d42:	fe 78 9a 13 	mov	r8,-26093
80002d46:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d48:	30 49       	mov	r9,4
80002d4a:	4f 18       	lddpc	r8,80002f0c <phy_tx_func+0x498>
80002d4c:	91 09       	st.w	r8[0x0],r9
80002d4e:	cc b8       	rjmp	80002ee4 <phy_tx_func+0x470>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d50:	4f 88       	lddpc	r8,80002f30 <phy_tx_func+0x4bc>
80002d52:	70 0a       	ld.w	r10,r8[0x0]
80002d54:	4f 89       	lddpc	r9,80002f34 <phy_tx_func+0x4c0>
80002d56:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d5a:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d5c:	70 0a       	ld.w	r10,r8[0x0]
80002d5e:	2f fa       	sub	r10,-1
80002d60:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d64:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d66:	70 0a       	ld.w	r10,r8[0x0]
80002d68:	2f ea       	sub	r10,-2
80002d6a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d6e:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002d70:	70 0a       	ld.w	r10,r8[0x0]
80002d72:	2f da       	sub	r10,-3
80002d74:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d78:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002d7a:	70 09       	ld.w	r9,r8[0x0]
80002d7c:	2f c9       	sub	r9,-4
80002d7e:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002d80:	58 c9       	cp.w	r9,12
80002d82:	c0 51       	brne	80002d8c <phy_tx_func+0x318>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002d84:	30 59       	mov	r9,5
80002d86:	4e 28       	lddpc	r8,80002f0c <phy_tx_func+0x498>
80002d88:	91 09       	st.w	r8[0x0],r9
80002d8a:	ca d8       	rjmp	80002ee4 <phy_tx_func+0x470>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d8c:	30 49       	mov	r9,4
80002d8e:	4e 08       	lddpc	r8,80002f0c <phy_tx_func+0x498>
80002d90:	91 09       	st.w	r8[0x0],r9
80002d92:	ca 98       	rjmp	80002ee4 <phy_tx_func+0x470>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d94:	4e 78       	lddpc	r8,80002f30 <phy_tx_func+0x4bc>
80002d96:	70 0a       	ld.w	r10,r8[0x0]
80002d98:	4e 79       	lddpc	r9,80002f34 <phy_tx_func+0x4c0>
80002d9a:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d9e:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002da0:	30 09       	mov	r9,0
80002da2:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002da4:	fe 78 80 03 	mov	r8,-32765
80002da8:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002daa:	fe 78 88 f3 	mov	r8,-30477
80002dae:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002db0:	4d 98       	lddpc	r8,80002f14 <phy_tx_func+0x4a0>
80002db2:	70 08       	ld.w	r8,r8[0x0]
80002db4:	58 48       	cp.w	r8,4
80002db6:	c0 60       	breq	80002dc2 <phy_tx_func+0x34e>
80002db8:	c2 83       	brcs	80002e08 <phy_tx_func+0x394>
80002dba:	58 98       	cp.w	r8,9
80002dbc:	e0 8b 00 26 	brhi	80002e08 <phy_tx_func+0x394>
80002dc0:	c1 98       	rjmp	80002df2 <phy_tx_func+0x37e>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002dc2:	4d 98       	lddpc	r8,80002f24 <phy_tx_func+0x4b0>
80002dc4:	11 89       	ld.ub	r9,r8[0x0]
80002dc6:	30 18       	mov	r8,1
80002dc8:	f0 09 18 00 	cp.b	r9,r8
80002dcc:	c0 81       	brne	80002ddc <phy_tx_func+0x368>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002dce:	4d 88       	lddpc	r8,80002f2c <phy_tx_func+0x4b8>
80002dd0:	90 0a       	ld.sh	r10,r8[0x0]
80002dd2:	4d a9       	lddpc	r9,80002f38 <phy_tx_func+0x4c4>
80002dd4:	b2 0a       	st.h	r9[0x0],r10
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002dd6:	90 08       	ld.sh	r8,r8[0x0]
80002dd8:	ae 78       	st.h	r7[0xe],r8
80002dda:	c0 88       	rjmp	80002dea <phy_tx_func+0x376>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002ddc:	4d 78       	lddpc	r8,80002f38 <phy_tx_func+0x4c4>
80002dde:	90 08       	ld.sh	r8,r8[0x0]
80002de0:	4d 39       	lddpc	r9,80002f2c <phy_tx_func+0x4b8>
80002de2:	92 09       	ld.sh	r9,r9[0x0]
80002de4:	f3 e8 20 08 	eor	r8,r9,r8
80002de8:	ae 78       	st.h	r7[0xe],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002dea:	30 69       	mov	r9,6
80002dec:	4c 88       	lddpc	r8,80002f0c <phy_tx_func+0x498>
80002dee:	91 09       	st.w	r8[0x0],r9
80002df0:	c7 a8       	rjmp	80002ee4 <phy_tx_func+0x470>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002df2:	4d 28       	lddpc	r8,80002f38 <phy_tx_func+0x4c4>
80002df4:	90 08       	ld.sh	r8,r8[0x0]
80002df6:	4c e9       	lddpc	r9,80002f2c <phy_tx_func+0x4b8>
80002df8:	92 09       	ld.sh	r9,r9[0x0]
80002dfa:	f3 e8 20 08 	eor	r8,r9,r8
80002dfe:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e00:	30 69       	mov	r9,6
80002e02:	4c 38       	lddpc	r8,80002f0c <phy_tx_func+0x498>
80002e04:	91 09       	st.w	r8[0x0],r9
80002e06:	c6 f8       	rjmp	80002ee4 <phy_tx_func+0x470>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e08:	e0 68 5a 5a 	mov	r8,23130
80002e0c:	ea 18 ab cd 	orh	r8,0xabcd
80002e10:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e12:	30 08       	mov	r8,0
80002e14:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e16:	4b e9       	lddpc	r9,80002f0c <phy_tx_func+0x498>
80002e18:	93 08       	st.w	r9[0x0],r8
80002e1a:	c6 58       	rjmp	80002ee4 <phy_tx_func+0x470>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e1c:	4b e8       	lddpc	r8,80002f14 <phy_tx_func+0x4a0>
80002e1e:	70 08       	ld.w	r8,r8[0x0]
80002e20:	58 48       	cp.w	r8,4
80002e22:	c0 60       	breq	80002e2e <phy_tx_func+0x3ba>
80002e24:	c4 53       	brcs	80002eae <phy_tx_func+0x43a>
80002e26:	58 98       	cp.w	r8,9
80002e28:	e0 8b 00 43 	brhi	80002eae <phy_tx_func+0x43a>
80002e2c:	c2 d8       	rjmp	80002e86 <phy_tx_func+0x412>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e2e:	4b e8       	lddpc	r8,80002f24 <phy_tx_func+0x4b0>
80002e30:	11 89       	ld.ub	r9,r8[0x0]
80002e32:	30 18       	mov	r8,1
80002e34:	f0 09 18 00 	cp.b	r9,r8
80002e38:	c1 31       	brne	80002e5e <phy_tx_func+0x3ea>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e3a:	4b d8       	lddpc	r8,80002f2c <phy_tx_func+0x4b8>
80002e3c:	90 1a       	ld.sh	r10,r8[0x2]
80002e3e:	4b f9       	lddpc	r9,80002f38 <phy_tx_func+0x4c4>
80002e40:	b2 1a       	st.h	r9[0x2],r10
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e42:	90 2a       	ld.sh	r10,r8[0x4]
80002e44:	b2 2a       	st.h	r9[0x4],r10
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e46:	90 3a       	ld.sh	r10,r8[0x6]
80002e48:	b2 3a       	st.h	r9[0x6],r10
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e4a:	90 19       	ld.sh	r9,r8[0x2]
80002e4c:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e4e:	90 29       	ld.sh	r9,r8[0x4]
80002e50:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e52:	90 38       	ld.sh	r8,r8[0x6]
80002e54:	ae 68       	st.h	r7[0xc],r8
									payload_tx_channel->word[3] = 0x00BA ;
80002e56:	e0 68 00 ba 	mov	r8,186
80002e5a:	ae 78       	st.h	r7[0xe],r8
80002e5c:	c1 18       	rjmp	80002e7e <phy_tx_func+0x40a>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e5e:	4b 48       	lddpc	r8,80002f2c <phy_tx_func+0x4b8>
80002e60:	90 1a       	ld.sh	r10,r8[0x2]
80002e62:	4b 69       	lddpc	r9,80002f38 <phy_tx_func+0x4c4>
80002e64:	92 1b       	ld.sh	r11,r9[0x2]
80002e66:	f7 ea 20 0a 	eor	r10,r11,r10
80002e6a:	ae 4a       	st.h	r7[0x8],r10
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e6c:	90 2a       	ld.sh	r10,r8[0x4]
80002e6e:	92 29       	ld.sh	r9,r9[0x4]
80002e70:	14 59       	eor	r9,r10
80002e72:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e74:	90 38       	ld.sh	r8,r8[0x6]
80002e76:	ae 68       	st.h	r7[0xc],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80002e78:	e0 68 00 ba 	mov	r8,186
80002e7c:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e7e:	30 09       	mov	r9,0
80002e80:	4a 38       	lddpc	r8,80002f0c <phy_tx_func+0x498>
80002e82:	91 09       	st.w	r8[0x0],r9
80002e84:	c3 08       	rjmp	80002ee4 <phy_tx_func+0x470>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80002e86:	4a a8       	lddpc	r8,80002f2c <phy_tx_func+0x4b8>
80002e88:	90 1a       	ld.sh	r10,r8[0x2]
80002e8a:	4a c9       	lddpc	r9,80002f38 <phy_tx_func+0x4c4>
80002e8c:	92 1b       	ld.sh	r11,r9[0x2]
80002e8e:	f7 ea 20 0a 	eor	r10,r11,r10
80002e92:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80002e94:	90 2a       	ld.sh	r10,r8[0x4]
80002e96:	92 29       	ld.sh	r9,r9[0x4]
80002e98:	14 59       	eor	r9,r10
80002e9a:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80002e9c:	90 38       	ld.sh	r8,r8[0x6]
80002e9e:	ae 68       	st.h	r7[0xc],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80002ea0:	e0 68 00 ba 	mov	r8,186
80002ea4:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002ea6:	30 09       	mov	r9,0
80002ea8:	49 98       	lddpc	r8,80002f0c <phy_tx_func+0x498>
80002eaa:	91 09       	st.w	r8[0x0],r9
80002eac:	c1 c8       	rjmp	80002ee4 <phy_tx_func+0x470>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eae:	e0 68 5a 5a 	mov	r8,23130
80002eb2:	ea 18 ab cd 	orh	r8,0xabcd
80002eb6:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002eb8:	30 08       	mov	r8,0
80002eba:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002ebc:	49 49       	lddpc	r9,80002f0c <phy_tx_func+0x498>
80002ebe:	93 08       	st.w	r9[0x0],r8
80002ec0:	c1 28       	rjmp	80002ee4 <phy_tx_func+0x470>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ec2:	e0 68 5a 5a 	mov	r8,23130
80002ec6:	ea 18 ab cd 	orh	r8,0xabcd
80002eca:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ecc:	30 08       	mov	r8,0
80002ece:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002ed0:	48 f9       	lddpc	r9,80002f0c <phy_tx_func+0x498>
80002ed2:	93 08       	st.w	r9[0x0],r8
80002ed4:	c0 88       	rjmp	80002ee4 <phy_tx_func+0x470>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ed6:	e0 68 5a 5a 	mov	r8,23130
80002eda:	ea 18 ab cd 	orh	r8,0xabcd
80002ede:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ee0:	30 08       	mov	r8,0
80002ee2:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002ee4:	2f fd       	sub	sp,-4
80002ee6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002eea:	00 00       	add	r0,r0
80002eec:	00 00       	add	r0,r0
80002eee:	0a d0       	st.w	--r5,r0
80002ef0:	00 00       	add	r0,r0
80002ef2:	0a a8       	st.w	r5++,r8
80002ef4:	00 00       	add	r0,r0
80002ef6:	0a 84       	andn	r4,r5
80002ef8:	80 00       	ld.sh	r0,r0[0x0]
80002efa:	51 44       	stdsp	sp[0x50],r4
80002efc:	00 00       	add	r0,r0
80002efe:	0a c8       	st.b	r5++,r8
80002f00:	00 00       	add	r0,r0
80002f02:	0a 8d       	andn	sp,r5
80002f04:	00 00       	add	r0,r0
80002f06:	0a 57       	eor	r7,r5
80002f08:	00 00       	add	r0,r0
80002f0a:	0a 80       	andn	r0,r5
80002f0c:	00 00       	add	r0,r0
80002f0e:	0a b8       	st.h	r5++,r8
80002f10:	80 00       	ld.sh	r0,r0[0x0]
80002f12:	c7 80       	breq	80003002 <phy_init+0x9e>
80002f14:	00 00       	add	r0,r0
80002f16:	0a 74       	tst	r4,r5
80002f18:	00 00       	add	r0,r0
80002f1a:	0a d8       	st.w	--r5,r8
80002f1c:	00 00       	add	r0,r0
80002f1e:	0d 88       	ld.ub	r8,r6[0x0]
80002f20:	00 00       	add	r0,r0
80002f22:	0e 84       	andn	r4,r7
80002f24:	00 00       	add	r0,r0
80002f26:	0a 58       	eor	r8,r5
80002f28:	80 00       	ld.sh	r0,r0[0x0]
80002f2a:	c7 22       	brcc	8000300e <phy_init+0xaa>
80002f2c:	00 00       	add	r0,r0
80002f2e:	0d 80       	ld.ub	r0,r6[0x0]
80002f30:	00 00       	add	r0,r0
80002f32:	0a a4       	st.w	r5++,r4
80002f34:	00 00       	add	r0,r0
80002f36:	0e 88       	andn	r8,r7
80002f38:	00 00       	add	r0,r0
80002f3a:	0d 8c       	ld.ub	r12,r6[0x0]

80002f3c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f3c:	d4 01       	pushm	lr
80002f3e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f40:	30 0a       	mov	r10,0
80002f42:	fa cb ff fc 	sub	r11,sp,-4
80002f46:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f48:	14 99       	mov	r9,r10
80002f4a:	1a 9b       	mov	r11,sp
80002f4c:	f0 1f 00 05 	mcall	80002f60 <get_idle_store+0x24>
80002f50:	58 1c       	cp.w	r12,1
80002f52:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f56:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f5a:	2f fd       	sub	sp,-4
80002f5c:	d8 02       	popm	pc
80002f5e:	00 00       	add	r0,r0
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	52 34       	stdsp	sp[0x8c],r4

80002f64 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f64:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002f68:	f0 1f 00 21 	mcall	80002fec <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f6c:	4a 1b       	lddpc	r11,80002ff0 <phy_init+0x8c>
80002f6e:	4a 2c       	lddpc	r12,80002ff4 <phy_init+0x90>
80002f70:	f0 1f 00 22 	mcall	80002ff8 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002f74:	30 4b       	mov	r11,4
80002f76:	31 ec       	mov	r12,30
80002f78:	f0 1f 00 21 	mcall	80002ffc <phy_init+0x98>
80002f7c:	4a 18       	lddpc	r8,80003000 <phy_init+0x9c>
80002f7e:	91 0c       	st.w	r8[0x0],r12
80002f80:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002f82:	10 96       	mov	r6,r8
80002f84:	4a 05       	lddpc	r5,80003004 <phy_init+0xa0>
80002f86:	6c 0c       	ld.w	r12,r6[0x0]
80002f88:	ea 07 00 0b 	add	r11,r5,r7
80002f8c:	f0 1f 00 1f 	mcall	80003008 <phy_init+0xa4>
80002f90:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002f94:	e0 47 1e 00 	cp.w	r7,7680
80002f98:	cf 71       	brne	80002f86 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f9a:	30 4b       	mov	r11,4
80002f9c:	31 4c       	mov	r12,20
80002f9e:	f0 1f 00 18 	mcall	80002ffc <phy_init+0x98>
80002fa2:	49 b8       	lddpc	r8,8000300c <phy_init+0xa8>
80002fa4:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002fa6:	30 4b       	mov	r11,4
80002fa8:	30 ac       	mov	r12,10
80002faa:	f0 1f 00 15 	mcall	80002ffc <phy_init+0x98>
80002fae:	49 98       	lddpc	r8,80003010 <phy_init+0xac>
80002fb0:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002fb2:	30 4b       	mov	r11,4
80002fb4:	30 ac       	mov	r12,10
80002fb6:	f0 1f 00 12 	mcall	80002ffc <phy_init+0x98>
80002fba:	49 78       	lddpc	r8,80003014 <phy_init+0xb0>
80002fbc:	91 0c       	st.w	r8[0x0],r12
80002fbe:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002fc0:	10 96       	mov	r6,r8
80002fc2:	49 65       	lddpc	r5,80003018 <phy_init+0xb4>
80002fc4:	6c 0c       	ld.w	r12,r6[0x0]
80002fc6:	ea 07 00 0b 	add	r11,r5,r7
80002fca:	f0 1f 00 10 	mcall	80003008 <phy_init+0xa4>
80002fce:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002fd2:	e0 47 14 00 	cp.w	r7,5120
80002fd6:	cf 71       	brne	80002fc4 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80002fd8:	e0 6b 01 00 	mov	r11,256
80002fdc:	30 5c       	mov	r12,5
80002fde:	f0 1f 00 08 	mcall	80002ffc <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80002fe2:	48 f8       	lddpc	r8,8000301c <phy_init+0xb8>
80002fe4:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80002fe6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002fea:	00 00       	add	r0,r0
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	3e 10       	mov	r0,-31
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	2a 74       	sub	r4,-89
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	30 80       	mov	r0,8
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	3d fc       	mov	r12,-33
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	55 40       	stdsp	sp[0x150],r0
80003000:	00 00       	add	r0,r0
80003002:	0a 9c       	mov	r12,r5
80003004:	00 00       	add	r0,r0
80003006:	22 a2       	sub	r2,42
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	29 d0       	sub	r0,-99
8000300c:	00 00       	add	r0,r0
8000300e:	0a d0       	st.w	--r5,r0
80003010:	00 00       	add	r0,r0
80003012:	0a c4       	st.b	r5++,r4
80003014:	00 00       	add	r0,r0
80003016:	0a 78       	tst	r8,r5
80003018:	00 00       	add	r0,r0
8000301a:	0e a2       	st.w	r7++,r2
8000301c:	00 00       	add	r0,r0
8000301e:	0a c0       	st.b	r5++,r0

80003020 <payload_rx>:




static void payload_rx(void * payload)
{
80003020:	d4 01       	pushm	lr
80003022:	20 2d       	sub	sp,8
80003024:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003026:	30 08       	mov	r8,0
80003028:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
8000302a:	48 f8       	lddpc	r8,80003064 <payload_rx+0x44>
8000302c:	70 08       	ld.w	r8,r8[0x0]
8000302e:	58 08       	cp.w	r8,0
80003030:	c0 71       	brne	8000303e <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80003032:	30 4b       	mov	r11,4
80003034:	30 5c       	mov	r12,5
80003036:	f0 1f 00 0d 	mcall	80003068 <payload_rx+0x48>
8000303a:	48 b8       	lddpc	r8,80003064 <payload_rx+0x44>
8000303c:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000303e:	48 a8       	lddpc	r8,80003064 <payload_rx+0x44>
80003040:	70 0c       	ld.w	r12,r8[0x0]
80003042:	30 09       	mov	r9,0
80003044:	fa ca ff fc 	sub	r10,sp,-4
80003048:	1a 9b       	mov	r11,sp
8000304a:	f0 1f 00 09 	mcall	8000306c <payload_rx+0x4c>
8000304e:	c0 91       	brne	80003060 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003050:	48 88       	lddpc	r8,80003070 <payload_rx+0x50>
80003052:	70 0c       	ld.w	r12,r8[0x0]
80003054:	40 0b       	lddsp	r11,sp[0x0]
80003056:	f0 1f 00 08 	mcall	80003074 <payload_rx+0x54>
		logFromISR("mm");
8000305a:	48 8c       	lddpc	r12,80003078 <payload_rx+0x58>
8000305c:	f0 1f 00 08 	mcall	8000307c <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80003060:	2f ed       	sub	sp,-8
80003062:	d8 02       	popm	pc
80003064:	00 00       	add	r0,r0
80003066:	0a 94       	mov	r4,r5
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	55 40       	stdsp	sp[0x150],r0
8000306c:	80 00       	ld.sh	r0,r0[0x0]
8000306e:	53 f0       	stdsp	sp[0xfc],r0
80003070:	00 00       	add	r0,r0
80003072:	0a 78       	tst	r8,r5
80003074:	80 00       	ld.sh	r0,r0[0x0]
80003076:	29 7c       	sub	r12,-105
80003078:	80 00       	ld.sh	r0,r0[0x0]
8000307a:	c7 9c       	rcall	8000316c <phy_rx_func+0xec>
8000307c:	80 00       	ld.sh	r0,r0[0x0]
8000307e:	61 64       	ld.w	r4,r0[0x58]

80003080 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003080:	eb cd 40 e0 	pushm	r5-r7,lr
80003084:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003086:	fe f8 0b be 	ld.w	r8,pc[3006]
8000308a:	70 08       	ld.w	r8,r8[0x0]
8000308c:	58 08       	cp.w	r8,0
8000308e:	e0 80 01 05 	breq	80003298 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003092:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003094:	fe f8 0b b4 	ld.w	r8,pc[2996]
80003098:	70 09       	ld.w	r9,r8[0x0]
8000309a:	2f f9       	sub	r9,-1
8000309c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000309e:	fe f8 0b ae 	ld.w	r8,pc[2990]
800030a2:	70 08       	ld.w	r8,r8[0x0]
800030a4:	58 18       	cp.w	r8,1
800030a6:	e0 80 00 84 	breq	800031ae <phy_rx_func+0x12e>
800030aa:	c0 73       	brcs	800030b8 <phy_rx_func+0x38>
800030ac:	58 28       	cp.w	r8,2
800030ae:	c5 b0       	breq	80003164 <phy_rx_func+0xe4>
800030b0:	58 38       	cp.w	r8,3
800030b2:	e0 81 00 f3 	brne	80003298 <phy_rx_func+0x218>
800030b6:	cd 38       	rjmp	8000325c <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800030b8:	e0 6a 5a 5a 	mov	r10,23130
800030bc:	ea 1a ab cd 	orh	r10,0xabcd
800030c0:	14 36       	cp.w	r6,r10
800030c2:	e0 80 00 eb 	breq	80003298 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800030c6:	ec 08 16 10 	lsr	r8,r6,0x10
800030ca:	e0 48 ab cd 	cp.w	r8,43981
800030ce:	e0 81 00 e5 	brne	80003298 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800030d2:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800030d6:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800030da:	20 28       	sub	r8,2
800030dc:	fe f9 0b 74 	ld.w	r9,pc[2932]
800030e0:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800030e2:	30 09       	mov	r9,0
800030e4:	f2 08 19 00 	cp.h	r8,r9
800030e8:	e0 8a 00 d8 	brle	80003298 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800030ec:	fe f8 0b 68 	ld.w	r8,pc[2920]
800030f0:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800030f2:	fe f8 0b 66 	ld.w	r8,pc[2918]
800030f6:	70 0c       	ld.w	r12,r8[0x0]
800030f8:	f0 1f 02 d9 	mcall	80003c5c <phy_rx_func+0xbdc>
800030fc:	fe f8 0b 64 	ld.w	r8,pc[2916]
80003100:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003102:	58 0c       	cp.w	r12,0
80003104:	e0 80 00 ca 	breq	80003298 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003108:	fe f8 0b 4c 	ld.w	r8,pc[2892]
8000310c:	90 09       	ld.sh	r9,r8[0x0]
8000310e:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003112:	2f f9       	sub	r9,-1
80003114:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003116:	fe fa 0b 4a 	ld.w	r10,pc[2890]
8000311a:	74 0a       	ld.w	r10,r10[0x0]
8000311c:	fe fb 0b 2c 	ld.w	r11,pc[2860]
80003120:	76 0b       	ld.w	r11,r11[0x0]
80003122:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003126:	2f f9       	sub	r9,-1
80003128:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000312a:	e2 16 0f 00 	andl	r6,0xf00,COH
8000312e:	e0 46 01 00 	cp.w	r6,256
80003132:	c0 c0       	breq	8000314a <phy_rx_func+0xca>
80003134:	e0 8b 00 05 	brhi	8000313e <phy_rx_func+0xbe>
80003138:	58 06       	cp.w	r6,0
8000313a:	c0 80       	breq	8000314a <phy_rx_func+0xca>
8000313c:	c0 c8       	rjmp	80003154 <phy_rx_func+0xd4>
8000313e:	e0 46 02 00 	cp.w	r6,512
80003142:	c0 40       	breq	8000314a <phy_rx_func+0xca>
80003144:	e0 46 03 00 	cp.w	r6,768
80003148:	c0 61       	brne	80003154 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
8000314a:	30 29       	mov	r9,2
8000314c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003150:	91 09       	st.w	r8[0x0],r9
80003152:	ca 38       	rjmp	80003298 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003154:	fe f6 0b 0c 	ld.w	r6,pc[2828]
80003158:	6c 0c       	ld.w	r12,r6[0x0]
8000315a:	f0 1f 02 c3 	mcall	80003c64 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
8000315e:	30 08       	mov	r8,0
80003160:	8d 08       	st.w	r6[0x0],r8
80003162:	c9 b8       	rjmp	80003298 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003164:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003168:	b1 86       	lsr	r6,0x10
8000316a:	14 06       	add	r6,r10
8000316c:	fe f8 0a fc 	ld.w	r8,pc[2812]
80003170:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003172:	fe f8 0a e2 	ld.w	r8,pc[2786]
80003176:	90 09       	ld.sh	r9,r8[0x0]
80003178:	fe fb 0a e8 	ld.w	r11,pc[2792]
8000317c:	76 0b       	ld.w	r11,r11[0x0]
8000317e:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003182:	2f f9       	sub	r9,-1
80003184:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003186:	fe f9 0a ca 	ld.w	r9,pc[2762]
8000318a:	92 08       	ld.sh	r8,r9[0x0]
8000318c:	20 28       	sub	r8,2
8000318e:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003190:	30 09       	mov	r9,0
80003192:	f2 08 19 00 	cp.h	r8,r9
80003196:	e0 8a 00 07 	brle	800031a4 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000319a:	30 19       	mov	r9,1
8000319c:	fe f8 0a b0 	ld.w	r8,pc[2736]
800031a0:	91 09       	st.w	r8[0x0],r9
800031a2:	c7 b8       	rjmp	80003298 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800031a4:	30 39       	mov	r9,3
800031a6:	fe f8 0a a6 	ld.w	r8,pc[2726]
800031aa:	91 09       	st.w	r8[0x0],r9
800031ac:	c7 68       	rjmp	80003298 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800031ae:	ec 0a 14 10 	asr	r10,r6,0x10
800031b2:	fe f8 0a b6 	ld.w	r8,pc[2742]
800031b6:	90 09       	ld.sh	r9,r8[0x0]
800031b8:	14 09       	add	r9,r10
800031ba:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800031bc:	fe f9 0a 98 	ld.w	r9,pc[2712]
800031c0:	92 08       	ld.sh	r8,r9[0x0]
800031c2:	fe fb 0a 9e 	ld.w	r11,pc[2718]
800031c6:	76 0b       	ld.w	r11,r11[0x0]
800031c8:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800031cc:	2f f8       	sub	r8,-1
800031ce:	5c 88       	casts.h	r8
800031d0:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800031d2:	fe fa 0a 7e 	ld.w	r10,pc[2686]
800031d6:	94 09       	ld.sh	r9,r10[0x0]
800031d8:	20 29       	sub	r9,2
800031da:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800031dc:	30 0a       	mov	r10,0
800031de:	f4 09 19 00 	cp.h	r9,r10
800031e2:	e0 89 00 1f 	brgt	80003220 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800031e6:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800031ea:	e0 46 00 ba 	cp.w	r6,186
800031ee:	c0 d1       	brne	80003208 <phy_rx_func+0x188>
800031f0:	fe f8 0a 78 	ld.w	r8,pc[2680]
800031f4:	90 09       	ld.sh	r9,r8[0x0]
800031f6:	f4 09 19 00 	cp.h	r9,r10
800031fa:	c0 71       	brne	80003208 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800031fc:	fe f8 0a 64 	ld.w	r8,pc[2660]
80003200:	70 0c       	ld.w	r12,r8[0x0]
80003202:	f0 1f 02 9b 	mcall	80003c6c <phy_rx_func+0xbec>
80003206:	c0 88       	rjmp	80003216 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003208:	fe f6 0a 58 	ld.w	r6,pc[2648]
8000320c:	6c 0c       	ld.w	r12,r6[0x0]
8000320e:	f0 1f 02 96 	mcall	80003c64 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
80003212:	30 08       	mov	r8,0
80003214:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003216:	30 09       	mov	r9,0
80003218:	fe f8 0a 34 	ld.w	r8,pc[2612]
8000321c:	91 09       	st.w	r8[0x0],r9
8000321e:	c3 d8       	rjmp	80003298 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003220:	5c 86       	casts.h	r6
80003222:	fe f9 0a 46 	ld.w	r9,pc[2630]
80003226:	92 0a       	ld.sh	r10,r9[0x0]
80003228:	0c 0a       	add	r10,r6
8000322a:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000322c:	fe f9 0a 34 	ld.w	r9,pc[2612]
80003230:	72 09       	ld.w	r9,r9[0x0]
80003232:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003236:	2f f8       	sub	r8,-1
80003238:	fe f9 0a 1c 	ld.w	r9,pc[2588]
8000323c:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000323e:	fe f9 0a 12 	ld.w	r9,pc[2578]
80003242:	92 08       	ld.sh	r8,r9[0x0]
80003244:	20 28       	sub	r8,2
80003246:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003248:	30 09       	mov	r9,0
8000324a:	f2 08 19 00 	cp.h	r8,r9
8000324e:	e0 89 00 25 	brgt	80003298 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003252:	30 39       	mov	r9,3
80003254:	fe f8 09 f8 	ld.w	r8,pc[2552]
80003258:	91 09       	st.w	r8[0x0],r9
8000325a:	c1 f8       	rjmp	80003298 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000325c:	e6 16 00 ff 	andh	r6,0xff,COH
80003260:	fc 19 00 ba 	movh	r9,0xba
80003264:	12 36       	cp.w	r6,r9
80003266:	c0 e1       	brne	80003282 <phy_rx_func+0x202>
80003268:	fe f8 0a 00 	ld.w	r8,pc[2560]
8000326c:	90 09       	ld.sh	r9,r8[0x0]
8000326e:	30 08       	mov	r8,0
80003270:	f0 09 19 00 	cp.h	r9,r8
80003274:	c0 71       	brne	80003282 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003276:	fe f8 09 ea 	ld.w	r8,pc[2538]
8000327a:	70 0c       	ld.w	r12,r8[0x0]
8000327c:	f0 1f 02 7c 	mcall	80003c6c <phy_rx_func+0xbec>
80003280:	c0 88       	rjmp	80003290 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003282:	fe f6 09 de 	ld.w	r6,pc[2526]
80003286:	6c 0c       	ld.w	r12,r6[0x0]
80003288:	f0 1f 02 77 	mcall	80003c64 <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
8000328c:	30 08       	mov	r8,0
8000328e:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003290:	30 09       	mov	r9,0
80003292:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003296:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80003298:	fe f8 09 d8 	ld.w	r8,pc[2520]
8000329c:	11 89       	ld.ub	r9,r8[0x0]
8000329e:	30 08       	mov	r8,0
800032a0:	f0 09 18 00 	cp.b	r9,r8
800032a4:	c0 d1       	brne	800032be <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
800032a6:	fe f8 09 ce 	ld.w	r8,pc[2510]
800032aa:	70 0c       	ld.w	r12,r8[0x0]
800032ac:	f0 1f 02 6c 	mcall	80003c5c <phy_rx_func+0xbdc>
800032b0:	fe f8 09 c8 	ld.w	r8,pc[2504]
800032b4:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800032b6:	30 19       	mov	r9,1
800032b8:	fe f8 09 b8 	ld.w	r8,pc[2488]
800032bc:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800032be:	fe f8 09 be 	ld.w	r8,pc[2494]
800032c2:	70 08       	ld.w	r8,r8[0x0]
800032c4:	58 38       	cp.w	r8,3
800032c6:	e0 80 04 7a 	breq	80003bba <phy_rx_func+0xb3a>
800032ca:	58 48       	cp.w	r8,4
800032cc:	e0 80 01 02 	breq	800034d0 <phy_rx_func+0x450>
800032d0:	58 08       	cp.w	r8,0
800032d2:	e0 81 04 b7 	brne	80003c40 <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800032d6:	6e 28       	ld.w	r8,r7[0x8]
800032d8:	e0 6a 5a 5a 	mov	r10,23130
800032dc:	ea 1a ab cd 	orh	r10,0xabcd
800032e0:	14 38       	cp.w	r8,r10
800032e2:	c0 71       	brne	800032f0 <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
800032e4:	30 09       	mov	r9,0
800032e6:	fe f8 09 9a 	ld.w	r8,pc[2458]
800032ea:	91 09       	st.w	r8[0x0],r9
800032ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800032f0:	10 99       	mov	r9,r8
800032f2:	e0 19 00 00 	andl	r9,0x0
800032f6:	fc 1a ab cd 	movh	r10,0xabcd
800032fa:	14 39       	cp.w	r9,r10
800032fc:	e0 81 04 a2 	brne	80003c40 <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003300:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003304:	fe f9 09 80 	ld.w	r9,pc[2432]
80003308:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
8000330a:	fe f8 09 6e 	ld.w	r8,pc[2414]
8000330e:	70 08       	ld.w	r8,r8[0x0]
80003310:	58 08       	cp.w	r8,0
80003312:	c1 11       	brne	80003334 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
80003314:	fe f8 09 60 	ld.w	r8,pc[2400]
80003318:	70 0c       	ld.w	r12,r8[0x0]
8000331a:	f0 1f 02 51 	mcall	80003c5c <phy_rx_func+0xbdc>
8000331e:	fe f8 09 5a 	ld.w	r8,pc[2394]
80003322:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
80003324:	58 0c       	cp.w	r12,0
80003326:	c0 71       	brne	80003334 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003328:	fe fc 09 60 	ld.w	r12,pc[2400]
8000332c:	f0 1f 02 58 	mcall	80003c8c <phy_rx_func+0xc0c>
80003330:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003334:	6e 28       	ld.w	r8,r7[0x8]
80003336:	e2 18 f0 00 	andl	r8,0xf000,COH
8000333a:	e0 48 c0 00 	cp.w	r8,49152
8000333e:	e0 81 00 c3 	brne	800034c4 <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
80003342:	30 19       	mov	r9,1
80003344:	fe f8 09 4c 	ld.w	r8,pc[2380]
80003348:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
8000334a:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000334e:	fe f8 09 46 	ld.w	r8,pc[2374]
80003352:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003354:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003358:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
8000335c:	fe f9 09 3c 	ld.w	r9,pc[2364]
80003360:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
80003362:	11 88       	ld.ub	r8,r8[0x0]
80003364:	37 f9       	mov	r9,127
80003366:	f2 08 18 00 	cp.b	r8,r9
8000336a:	c6 d0       	breq	80003444 <phy_rx_func+0x3c4>
8000336c:	e0 8b 00 0c 	brhi	80003384 <phy_rx_func+0x304>
80003370:	31 29       	mov	r9,18
80003372:	f2 08 18 00 	cp.b	r8,r9
80003376:	c4 20       	breq	800033fa <phy_rx_func+0x37a>
80003378:	31 39       	mov	r9,19
8000337a:	f2 08 18 00 	cp.b	r8,r9
8000337e:	e0 81 00 83 	brne	80003484 <phy_rx_func+0x404>
80003382:	c5 b8       	rjmp	80003438 <phy_rx_func+0x3b8>
80003384:	2f 08       	sub	r8,-16
80003386:	30 19       	mov	r9,1
80003388:	f2 08 18 00 	cp.b	r8,r9
8000338c:	e0 8b 00 7c 	brhi	80003484 <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003390:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003394:	e2 18 00 f0 	andl	r8,0xf0,COH
80003398:	59 08       	cp.w	r8,16
8000339a:	c0 71       	brne	800033a8 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
8000339c:	30 19       	mov	r9,1
8000339e:	fe f8 08 e2 	ld.w	r8,pc[2274]
800033a2:	91 09       	st.w	r8[0x0],r9
800033a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800033a8:	e0 48 00 20 	cp.w	r8,32
800033ac:	c2 11       	brne	800033ee <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
800033ae:	30 a9       	mov	r9,10
800033b0:	fe f8 08 d0 	ld.w	r8,pc[2256]
800033b4:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800033b6:	fe f6 08 e6 	ld.w	r6,pc[2278]
800033ba:	6c 08       	ld.w	r8,r6[0x0]
800033bc:	f0 0a 11 ff 	rsub	r10,r8,-1
800033c0:	fe f7 08 b8 	ld.w	r7,pc[2232]
800033c4:	2f f8       	sub	r8,-1
800033c6:	6e 0c       	ld.w	r12,r7[0x0]
800033c8:	f4 ca fe 00 	sub	r10,r10,-512
800033cc:	30 0b       	mov	r11,0
800033ce:	10 0c       	add	r12,r8
800033d0:	f0 1f 02 34 	mcall	80003ca0 <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
800033d4:	30 08       	mov	r8,0
800033d6:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800033d8:	6e 0c       	ld.w	r12,r7[0x0]
800033da:	f0 1f 02 33 	mcall	80003ca4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800033de:	fe f8 08 96 	ld.w	r8,pc[2198]
800033e2:	70 0c       	ld.w	r12,r8[0x0]
800033e4:	f0 1f 02 1e 	mcall	80003c5c <phy_rx_func+0xbdc>
800033e8:	8f 0c       	st.w	r7[0x0],r12
800033ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800033ee:	30 09       	mov	r9,0
800033f0:	fe f8 08 90 	ld.w	r8,pc[2192]
800033f4:	91 09       	st.w	r8[0x0],r9
800033f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033fa:	fe f9 08 8a 	ld.w	r9,pc[2186]
800033fe:	72 08       	ld.w	r8,r9[0x0]
80003400:	20 48       	sub	r8,4
80003402:	93 08       	st.w	r9[0x0],r8
80003404:	e0 80 04 1e 	breq	80003c40 <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003408:	ef 3c 00 0f 	ld.ub	r12,r7[15]
8000340c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003410:	fe f8 08 98 	ld.w	r8,pc[2200]
80003414:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003416:	8e 69       	ld.sh	r9,r7[0xc]
80003418:	fe f8 08 94 	ld.w	r8,pc[2196]
8000341c:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000341e:	8e 79       	ld.sh	r9,r7[0xe]
80003420:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003422:	f0 1f 02 24 	mcall	80003cb0 <phy_rx_func+0xc30>
80003426:	fe f8 08 5a 	ld.w	r8,pc[2138]
8000342a:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000342c:	30 49       	mov	r9,4
8000342e:	fe f8 08 4e 	ld.w	r8,pc[2126]
80003432:	91 09       	st.w	r8[0x0],r9
80003434:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003438:	30 09       	mov	r9,0
8000343a:	fe f8 08 46 	ld.w	r8,pc[2118]
8000343e:	91 09       	st.w	r8[0x0],r9
80003440:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003444:	fe f9 08 40 	ld.w	r9,pc[2112]
80003448:	72 08       	ld.w	r8,r9[0x0]
8000344a:	20 48       	sub	r8,4
8000344c:	93 08       	st.w	r9[0x0],r8
8000344e:	e0 80 03 f9 	breq	80003c40 <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003452:	fe f8 08 62 	ld.w	r8,pc[2146]
80003456:	70 09       	ld.w	r9,r8[0x0]
80003458:	8e 7b       	ld.sh	r11,r7[0xe]
8000345a:	fe fa 08 5e 	ld.w	r10,pc[2142]
8000345e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003462:	2f f9       	sub	r9,-1
80003464:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003466:	fe f8 08 32 	ld.w	r8,pc[2098]
8000346a:	70 09       	ld.w	r9,r8[0x0]
8000346c:	20 29       	sub	r9,2
8000346e:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003470:	30 29       	mov	r9,2
80003472:	fe f8 08 0e 	ld.w	r8,pc[2062]
80003476:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003478:	30 39       	mov	r9,3
8000347a:	fe f8 08 02 	ld.w	r8,pc[2050]
8000347e:	91 09       	st.w	r8[0x0],r9
80003480:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003484:	30 39       	mov	r9,3
80003486:	fe f8 07 fa 	ld.w	r8,pc[2042]
8000348a:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000348c:	6e 29       	ld.w	r9,r7[0x8]
8000348e:	fe f8 08 2e 	ld.w	r8,pc[2094]
80003492:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003494:	6e 39       	ld.w	r9,r7[0xc]
80003496:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003498:	fe f8 07 ec 	ld.w	r8,pc[2028]
8000349c:	70 08       	ld.w	r8,r8[0x0]
8000349e:	59 48       	cp.w	r8,20
800034a0:	c0 61       	brne	800034ac <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800034a2:	31 89       	mov	r9,24
800034a4:	fe f8 07 e0 	ld.w	r8,pc[2016]
800034a8:	91 09       	st.w	r8[0x0],r9
800034aa:	c0 78       	rjmp	800034b8 <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800034ac:	59 08       	cp.w	r8,16
800034ae:	c0 51       	brne	800034b8 <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800034b0:	31 09       	mov	r9,16
800034b2:	fe f8 07 d2 	ld.w	r8,pc[2002]
800034b6:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034b8:	30 49       	mov	r9,4
800034ba:	fe f8 07 c2 	ld.w	r8,pc[1986]
800034be:	91 09       	st.w	r8[0x0],r9
800034c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
800034c4:	30 09       	mov	r9,0
800034c6:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034ca:	b0 89       	st.b	r8[0x0],r9
800034cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034d0:	fe f8 07 c4 	ld.w	r8,pc[1988]
800034d4:	11 89       	ld.ub	r9,r8[0x0]
800034d6:	31 28       	mov	r8,18
800034d8:	f0 09 18 00 	cp.b	r9,r8
800034dc:	e0 81 01 4c 	brne	80003774 <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
800034e0:	ef 39 00 09 	ld.ub	r9,r7[9]
800034e4:	fe f8 07 b0 	ld.w	r8,pc[1968]
800034e8:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800034ea:	11 89       	ld.ub	r9,r8[0x0]
800034ec:	3f 28       	mov	r8,-14
800034ee:	f0 09 18 00 	cp.b	r9,r8
800034f2:	e0 81 01 3b 	brne	80003768 <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
800034f6:	30 19       	mov	r9,1
800034f8:	fe f8 07 c8 	ld.w	r8,pc[1992]
800034fc:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800034fe:	6e 29       	ld.w	r9,r7[0x8]
80003500:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003504:	fe f8 07 80 	ld.w	r8,pc[1920]
80003508:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000350a:	8e 59       	ld.sh	r9,r7[0xa]
8000350c:	fe f8 07 b8 	ld.w	r8,pc[1976]
80003510:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003512:	8e 69       	ld.sh	r9,r7[0xc]
80003514:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003516:	8e 79       	ld.sh	r9,r7[0xe]
80003518:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000351a:	fe f8 07 82 	ld.w	r8,pc[1922]
8000351e:	fe f9 07 5a 	ld.w	r9,pc[1882]
80003522:	72 0a       	ld.w	r10,r9[0x0]
80003524:	70 09       	ld.w	r9,r8[0x0]
80003526:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000352a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000352e:	70 09       	ld.w	r9,r8[0x0]
80003530:	2f f9       	sub	r9,-1
80003532:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003534:	e0 49 01 ff 	cp.w	r9,511
80003538:	e0 88 00 16 	brls	80003564 <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
8000353c:	30 09       	mov	r9,0
8000353e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003540:	fe f6 07 38 	ld.w	r6,pc[1848]
80003544:	6c 0c       	ld.w	r12,r6[0x0]
80003546:	f0 1f 01 d8 	mcall	80003ca4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000354a:	fe f8 07 2a 	ld.w	r8,pc[1834]
8000354e:	70 0c       	ld.w	r12,r8[0x0]
80003550:	f0 1f 01 c3 	mcall	80003c5c <phy_rx_func+0xbdc>
80003554:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003556:	c0 71       	brne	80003564 <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003558:	30 09       	mov	r9,0
8000355a:	fe f8 07 22 	ld.w	r8,pc[1826]
8000355e:	91 09       	st.w	r8[0x0],r9
80003560:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003564:	fe f9 07 20 	ld.w	r9,pc[1824]
80003568:	72 08       	ld.w	r8,r9[0x0]
8000356a:	20 18       	sub	r8,1
8000356c:	93 08       	st.w	r9[0x0],r8
8000356e:	c0 71       	brne	8000357c <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
80003570:	30 09       	mov	r9,0
80003572:	fe f8 07 0a 	ld.w	r8,pc[1802]
80003576:	91 09       	st.w	r8[0x0],r9
80003578:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
8000357c:	fe f8 07 20 	ld.w	r8,pc[1824]
80003580:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003584:	72 0a       	ld.w	r10,r9[0x0]
80003586:	70 09       	ld.w	r9,r8[0x0]
80003588:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000358c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003590:	70 09       	ld.w	r9,r8[0x0]
80003592:	2f f9       	sub	r9,-1
80003594:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003596:	e0 49 01 ff 	cp.w	r9,511
8000359a:	e0 88 00 16 	brls	800035c6 <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
8000359e:	30 09       	mov	r9,0
800035a0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035a2:	fe f6 06 d6 	ld.w	r6,pc[1750]
800035a6:	6c 0c       	ld.w	r12,r6[0x0]
800035a8:	f0 1f 01 bf 	mcall	80003ca4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ac:	fe f8 06 c8 	ld.w	r8,pc[1736]
800035b0:	70 0c       	ld.w	r12,r8[0x0]
800035b2:	f0 1f 01 ab 	mcall	80003c5c <phy_rx_func+0xbdc>
800035b6:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035b8:	c0 71       	brne	800035c6 <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
800035ba:	30 09       	mov	r9,0
800035bc:	fe f8 06 c0 	ld.w	r8,pc[1728]
800035c0:	91 09       	st.w	r8[0x0],r9
800035c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035c6:	fe f9 06 be 	ld.w	r9,pc[1726]
800035ca:	72 08       	ld.w	r8,r9[0x0]
800035cc:	20 18       	sub	r8,1
800035ce:	93 08       	st.w	r9[0x0],r8
800035d0:	c0 71       	brne	800035de <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
800035d2:	30 09       	mov	r9,0
800035d4:	fe f8 06 a8 	ld.w	r8,pc[1704]
800035d8:	91 09       	st.w	r8[0x0],r9
800035da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035de:	fe f8 06 be 	ld.w	r8,pc[1726]
800035e2:	fe f9 06 96 	ld.w	r9,pc[1686]
800035e6:	72 0a       	ld.w	r10,r9[0x0]
800035e8:	70 09       	ld.w	r9,r8[0x0]
800035ea:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800035ee:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035f2:	70 09       	ld.w	r9,r8[0x0]
800035f4:	2f f9       	sub	r9,-1
800035f6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035f8:	e0 49 01 ff 	cp.w	r9,511
800035fc:	e0 88 00 16 	brls	80003628 <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
80003600:	30 09       	mov	r9,0
80003602:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003604:	fe f6 06 74 	ld.w	r6,pc[1652]
80003608:	6c 0c       	ld.w	r12,r6[0x0]
8000360a:	f0 1f 01 a7 	mcall	80003ca4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000360e:	fe f8 06 66 	ld.w	r8,pc[1638]
80003612:	70 0c       	ld.w	r12,r8[0x0]
80003614:	f0 1f 01 92 	mcall	80003c5c <phy_rx_func+0xbdc>
80003618:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000361a:	c0 71       	brne	80003628 <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
8000361c:	30 09       	mov	r9,0
8000361e:	fe f8 06 5e 	ld.w	r8,pc[1630]
80003622:	91 09       	st.w	r8[0x0],r9
80003624:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003628:	fe f9 06 5c 	ld.w	r9,pc[1628]
8000362c:	72 08       	ld.w	r8,r9[0x0]
8000362e:	20 18       	sub	r8,1
80003630:	93 08       	st.w	r9[0x0],r8
80003632:	c0 71       	brne	80003640 <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003634:	30 09       	mov	r9,0
80003636:	fe f8 06 46 	ld.w	r8,pc[1606]
8000363a:	91 09       	st.w	r8[0x0],r9
8000363c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003640:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003644:	fe f9 06 34 	ld.w	r9,pc[1588]
80003648:	72 0a       	ld.w	r10,r9[0x0]
8000364a:	70 09       	ld.w	r9,r8[0x0]
8000364c:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003650:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003654:	70 09       	ld.w	r9,r8[0x0]
80003656:	2f f9       	sub	r9,-1
80003658:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000365a:	e0 49 01 ff 	cp.w	r9,511
8000365e:	e0 88 00 16 	brls	8000368a <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003662:	30 09       	mov	r9,0
80003664:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003666:	fe f6 06 12 	ld.w	r6,pc[1554]
8000366a:	6c 0c       	ld.w	r12,r6[0x0]
8000366c:	f0 1f 01 8e 	mcall	80003ca4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003670:	fe f8 06 04 	ld.w	r8,pc[1540]
80003674:	70 0c       	ld.w	r12,r8[0x0]
80003676:	f0 1f 01 7a 	mcall	80003c5c <phy_rx_func+0xbdc>
8000367a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000367c:	c0 71       	brne	8000368a <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
8000367e:	30 09       	mov	r9,0
80003680:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003684:	91 09       	st.w	r8[0x0],r9
80003686:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000368a:	fe f9 05 fa 	ld.w	r9,pc[1530]
8000368e:	72 08       	ld.w	r8,r9[0x0]
80003690:	20 18       	sub	r8,1
80003692:	93 08       	st.w	r9[0x0],r8
80003694:	c0 71       	brne	800036a2 <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
80003696:	30 09       	mov	r9,0
80003698:	fe f8 05 e4 	ld.w	r8,pc[1508]
8000369c:	91 09       	st.w	r8[0x0],r9
8000369e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036a2:	fe f8 05 fa 	ld.w	r8,pc[1530]
800036a6:	fe f9 05 d2 	ld.w	r9,pc[1490]
800036aa:	72 0a       	ld.w	r10,r9[0x0]
800036ac:	70 09       	ld.w	r9,r8[0x0]
800036ae:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036b2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036b6:	70 09       	ld.w	r9,r8[0x0]
800036b8:	2f f9       	sub	r9,-1
800036ba:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036bc:	e0 49 01 ff 	cp.w	r9,511
800036c0:	e0 88 00 16 	brls	800036ec <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
800036c4:	30 09       	mov	r9,0
800036c6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036c8:	fe f6 05 b0 	ld.w	r6,pc[1456]
800036cc:	6c 0c       	ld.w	r12,r6[0x0]
800036ce:	f0 1f 01 76 	mcall	80003ca4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800036d2:	fe f8 05 a2 	ld.w	r8,pc[1442]
800036d6:	70 0c       	ld.w	r12,r8[0x0]
800036d8:	f0 1f 01 61 	mcall	80003c5c <phy_rx_func+0xbdc>
800036dc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036de:	c0 71       	brne	800036ec <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
800036e0:	30 09       	mov	r9,0
800036e2:	fe f8 05 9a 	ld.w	r8,pc[1434]
800036e6:	91 09       	st.w	r8[0x0],r9
800036e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036ec:	fe f9 05 98 	ld.w	r9,pc[1432]
800036f0:	72 08       	ld.w	r8,r9[0x0]
800036f2:	20 18       	sub	r8,1
800036f4:	93 08       	st.w	r9[0x0],r8
800036f6:	c0 71       	brne	80003704 <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
800036f8:	30 09       	mov	r9,0
800036fa:	fe f8 05 82 	ld.w	r8,pc[1410]
800036fe:	91 09       	st.w	r8[0x0],r9
80003700:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003704:	fe f8 05 98 	ld.w	r8,pc[1432]
80003708:	fe f9 05 70 	ld.w	r9,pc[1392]
8000370c:	72 0a       	ld.w	r10,r9[0x0]
8000370e:	70 09       	ld.w	r9,r8[0x0]
80003710:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003714:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003718:	70 09       	ld.w	r9,r8[0x0]
8000371a:	2f f9       	sub	r9,-1
8000371c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000371e:	e0 49 01 ff 	cp.w	r9,511
80003722:	e0 88 00 16 	brls	8000374e <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80003726:	30 09       	mov	r9,0
80003728:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000372a:	fe f7 05 4e 	ld.w	r7,pc[1358]
8000372e:	6e 0c       	ld.w	r12,r7[0x0]
80003730:	f0 1f 01 5d 	mcall	80003ca4 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003734:	fe f8 05 40 	ld.w	r8,pc[1344]
80003738:	70 0c       	ld.w	r12,r8[0x0]
8000373a:	f0 1f 01 49 	mcall	80003c5c <phy_rx_func+0xbdc>
8000373e:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003740:	c0 71       	brne	8000374e <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80003742:	30 09       	mov	r9,0
80003744:	fe f8 05 38 	ld.w	r8,pc[1336]
80003748:	91 09       	st.w	r8[0x0],r9
8000374a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000374e:	fe f9 05 36 	ld.w	r9,pc[1334]
80003752:	72 08       	ld.w	r8,r9[0x0]
80003754:	20 18       	sub	r8,1
80003756:	93 08       	st.w	r9[0x0],r8
80003758:	e0 81 02 74 	brne	80003c40 <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
8000375c:	30 09       	mov	r9,0
8000375e:	fe f8 05 1e 	ld.w	r8,pc[1310]
80003762:	91 09       	st.w	r8[0x0],r9
80003764:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003768:	30 09       	mov	r9,0
8000376a:	fe f8 05 12 	ld.w	r8,pc[1298]
8000376e:	91 09       	st.w	r8[0x0],r9
80003770:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003774:	fe f8 05 20 	ld.w	r8,pc[1312]
80003778:	11 89       	ld.ub	r9,r8[0x0]
8000377a:	3f 28       	mov	r8,-14
8000377c:	f0 09 18 00 	cp.b	r9,r8
80003780:	c4 31       	brne	80003806 <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003782:	8e 49       	ld.sh	r9,r7[0x8]
80003784:	fe f8 05 40 	ld.w	r8,pc[1344]
80003788:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
8000378a:	fe f8 05 12 	ld.w	r8,pc[1298]
8000378e:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003792:	72 0a       	ld.w	r10,r9[0x0]
80003794:	70 09       	ld.w	r9,r8[0x0]
80003796:	ef 3b 00 08 	ld.ub	r11,r7[8]
8000379a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000379e:	70 09       	ld.w	r9,r8[0x0]
800037a0:	2f f9       	sub	r9,-1
800037a2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037a4:	e0 49 01 ff 	cp.w	r9,511
800037a8:	e0 88 00 16 	brls	800037d4 <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
800037ac:	30 09       	mov	r9,0
800037ae:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037b0:	fe f7 04 c8 	ld.w	r7,pc[1224]
800037b4:	6e 0c       	ld.w	r12,r7[0x0]
800037b6:	f0 1f 01 3c 	mcall	80003ca4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800037ba:	fe f8 04 ba 	ld.w	r8,pc[1210]
800037be:	70 0c       	ld.w	r12,r8[0x0]
800037c0:	f0 1f 01 27 	mcall	80003c5c <phy_rx_func+0xbdc>
800037c4:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037c6:	c0 71       	brne	800037d4 <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
800037c8:	30 09       	mov	r9,0
800037ca:	fe f8 04 b2 	ld.w	r8,pc[1202]
800037ce:	91 09       	st.w	r8[0x0],r9
800037d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037d4:	fe f9 04 b0 	ld.w	r9,pc[1200]
800037d8:	72 08       	ld.w	r8,r9[0x0]
800037da:	20 18       	sub	r8,1
800037dc:	93 08       	st.w	r9[0x0],r8
800037de:	c0 71       	brne	800037ec <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
800037e0:	30 09       	mov	r9,0
800037e2:	fe f8 04 9a 	ld.w	r8,pc[1178]
800037e6:	91 09       	st.w	r8[0x0],r9
800037e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800037ec:	20 18       	sub	r8,1
800037ee:	fe f9 04 96 	ld.w	r9,pc[1174]
800037f2:	93 08       	st.w	r9[0x0],r8
800037f4:	58 08       	cp.w	r8,0
800037f6:	e0 81 02 25 	brne	80003c40 <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
800037fa:	30 09       	mov	r9,0
800037fc:	fe f8 04 80 	ld.w	r8,pc[1152]
80003800:	91 09       	st.w	r8[0x0],r9
80003802:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003806:	fe f8 04 8e 	ld.w	r8,pc[1166]
8000380a:	11 89       	ld.ub	r9,r8[0x0]
8000380c:	3f 38       	mov	r8,-13
8000380e:	f0 09 18 00 	cp.b	r9,r8
80003812:	e0 81 01 0c 	brne	80003a2a <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003816:	8e 49       	ld.sh	r9,r7[0x8]
80003818:	fe f8 04 ac 	ld.w	r8,pc[1196]
8000381c:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000381e:	8e 59       	ld.sh	r9,r7[0xa]
80003820:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003822:	8e 69       	ld.sh	r9,r7[0xc]
80003824:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003826:	fe f8 04 76 	ld.w	r8,pc[1142]
8000382a:	fe f9 04 4e 	ld.w	r9,pc[1102]
8000382e:	72 0a       	ld.w	r10,r9[0x0]
80003830:	70 09       	ld.w	r9,r8[0x0]
80003832:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003836:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000383a:	70 09       	ld.w	r9,r8[0x0]
8000383c:	2f f9       	sub	r9,-1
8000383e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003840:	e0 49 01 ff 	cp.w	r9,511
80003844:	e0 88 00 16 	brls	80003870 <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003848:	30 09       	mov	r9,0
8000384a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000384c:	fe f6 04 2c 	ld.w	r6,pc[1068]
80003850:	6c 0c       	ld.w	r12,r6[0x0]
80003852:	f0 1f 01 15 	mcall	80003ca4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003856:	fe f8 04 1e 	ld.w	r8,pc[1054]
8000385a:	70 0c       	ld.w	r12,r8[0x0]
8000385c:	f0 1f 01 00 	mcall	80003c5c <phy_rx_func+0xbdc>
80003860:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003862:	c0 71       	brne	80003870 <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003864:	30 09       	mov	r9,0
80003866:	fe f8 04 16 	ld.w	r8,pc[1046]
8000386a:	91 09       	st.w	r8[0x0],r9
8000386c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003870:	fe f9 04 14 	ld.w	r9,pc[1044]
80003874:	72 08       	ld.w	r8,r9[0x0]
80003876:	20 18       	sub	r8,1
80003878:	93 08       	st.w	r9[0x0],r8
8000387a:	c0 71       	brne	80003888 <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
8000387c:	30 09       	mov	r9,0
8000387e:	fe f8 03 fe 	ld.w	r8,pc[1022]
80003882:	91 09       	st.w	r8[0x0],r9
80003884:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003888:	fe f8 04 14 	ld.w	r8,pc[1044]
8000388c:	fe f9 03 ec 	ld.w	r9,pc[1004]
80003890:	72 0a       	ld.w	r10,r9[0x0]
80003892:	70 09       	ld.w	r9,r8[0x0]
80003894:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003898:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000389c:	70 09       	ld.w	r9,r8[0x0]
8000389e:	2f f9       	sub	r9,-1
800038a0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038a2:	e0 49 01 ff 	cp.w	r9,511
800038a6:	e0 88 00 16 	brls	800038d2 <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
800038aa:	30 09       	mov	r9,0
800038ac:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038ae:	fe f6 03 ca 	ld.w	r6,pc[970]
800038b2:	6c 0c       	ld.w	r12,r6[0x0]
800038b4:	f0 1f 00 fc 	mcall	80003ca4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800038b8:	fe f8 03 bc 	ld.w	r8,pc[956]
800038bc:	70 0c       	ld.w	r12,r8[0x0]
800038be:	f0 1f 00 e8 	mcall	80003c5c <phy_rx_func+0xbdc>
800038c2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038c4:	c0 71       	brne	800038d2 <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
800038c6:	30 09       	mov	r9,0
800038c8:	fe f8 03 b4 	ld.w	r8,pc[948]
800038cc:	91 09       	st.w	r8[0x0],r9
800038ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038d2:	fe f9 03 b2 	ld.w	r9,pc[946]
800038d6:	72 08       	ld.w	r8,r9[0x0]
800038d8:	20 18       	sub	r8,1
800038da:	93 08       	st.w	r9[0x0],r8
800038dc:	c0 71       	brne	800038ea <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
800038de:	30 09       	mov	r9,0
800038e0:	fe f8 03 9c 	ld.w	r8,pc[924]
800038e4:	91 09       	st.w	r8[0x0],r9
800038e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800038ea:	fe f8 03 b2 	ld.w	r8,pc[946]
800038ee:	fe f9 03 8a 	ld.w	r9,pc[906]
800038f2:	72 0a       	ld.w	r10,r9[0x0]
800038f4:	70 09       	ld.w	r9,r8[0x0]
800038f6:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800038fa:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038fe:	70 09       	ld.w	r9,r8[0x0]
80003900:	2f f9       	sub	r9,-1
80003902:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003904:	e0 49 01 ff 	cp.w	r9,511
80003908:	e0 88 00 16 	brls	80003934 <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
8000390c:	30 09       	mov	r9,0
8000390e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003910:	fe f6 03 68 	ld.w	r6,pc[872]
80003914:	6c 0c       	ld.w	r12,r6[0x0]
80003916:	f0 1f 00 e4 	mcall	80003ca4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000391a:	fe f8 03 5a 	ld.w	r8,pc[858]
8000391e:	70 0c       	ld.w	r12,r8[0x0]
80003920:	f0 1f 00 cf 	mcall	80003c5c <phy_rx_func+0xbdc>
80003924:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003926:	c0 71       	brne	80003934 <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003928:	30 09       	mov	r9,0
8000392a:	fe f8 03 52 	ld.w	r8,pc[850]
8000392e:	91 09       	st.w	r8[0x0],r9
80003930:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003934:	fe f9 03 50 	ld.w	r9,pc[848]
80003938:	72 08       	ld.w	r8,r9[0x0]
8000393a:	20 18       	sub	r8,1
8000393c:	93 08       	st.w	r9[0x0],r8
8000393e:	c0 71       	brne	8000394c <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
80003940:	30 09       	mov	r9,0
80003942:	fe f8 03 3a 	ld.w	r8,pc[826]
80003946:	91 09       	st.w	r8[0x0],r9
80003948:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
8000394c:	fe f8 03 50 	ld.w	r8,pc[848]
80003950:	fe f9 03 28 	ld.w	r9,pc[808]
80003954:	72 0a       	ld.w	r10,r9[0x0]
80003956:	70 09       	ld.w	r9,r8[0x0]
80003958:	ef 3b 00 0b 	ld.ub	r11,r7[11]
8000395c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003960:	70 09       	ld.w	r9,r8[0x0]
80003962:	2f f9       	sub	r9,-1
80003964:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003966:	e0 49 01 ff 	cp.w	r9,511
8000396a:	e0 88 00 16 	brls	80003996 <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
8000396e:	30 09       	mov	r9,0
80003970:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003972:	fe f6 03 06 	ld.w	r6,pc[774]
80003976:	6c 0c       	ld.w	r12,r6[0x0]
80003978:	f0 1f 00 cb 	mcall	80003ca4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
8000397c:	fe f8 02 f8 	ld.w	r8,pc[760]
80003980:	70 0c       	ld.w	r12,r8[0x0]
80003982:	f0 1f 00 b7 	mcall	80003c5c <phy_rx_func+0xbdc>
80003986:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003988:	c0 71       	brne	80003996 <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
8000398a:	30 09       	mov	r9,0
8000398c:	fe f8 02 f0 	ld.w	r8,pc[752]
80003990:	91 09       	st.w	r8[0x0],r9
80003992:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003996:	fe f9 02 ee 	ld.w	r9,pc[750]
8000399a:	72 08       	ld.w	r8,r9[0x0]
8000399c:	20 18       	sub	r8,1
8000399e:	93 08       	st.w	r9[0x0],r8
800039a0:	c0 71       	brne	800039ae <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
800039a2:	30 09       	mov	r9,0
800039a4:	fe f8 02 d8 	ld.w	r8,pc[728]
800039a8:	91 09       	st.w	r8[0x0],r9
800039aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039ae:	fe f8 02 ee 	ld.w	r8,pc[750]
800039b2:	fe f9 02 c6 	ld.w	r9,pc[710]
800039b6:	72 0a       	ld.w	r10,r9[0x0]
800039b8:	70 09       	ld.w	r9,r8[0x0]
800039ba:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039be:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039c2:	70 09       	ld.w	r9,r8[0x0]
800039c4:	2f f9       	sub	r9,-1
800039c6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039c8:	e0 49 01 ff 	cp.w	r9,511
800039cc:	e0 88 00 16 	brls	800039f8 <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
800039d0:	30 09       	mov	r9,0
800039d2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039d4:	fe f7 02 a4 	ld.w	r7,pc[676]
800039d8:	6e 0c       	ld.w	r12,r7[0x0]
800039da:	f0 1f 00 b3 	mcall	80003ca4 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800039de:	fe f8 02 96 	ld.w	r8,pc[662]
800039e2:	70 0c       	ld.w	r12,r8[0x0]
800039e4:	f0 1f 00 9e 	mcall	80003c5c <phy_rx_func+0xbdc>
800039e8:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039ea:	c0 71       	brne	800039f8 <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
800039ec:	30 09       	mov	r9,0
800039ee:	fe f8 02 8e 	ld.w	r8,pc[654]
800039f2:	91 09       	st.w	r8[0x0],r9
800039f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039f8:	fe f9 02 8c 	ld.w	r9,pc[652]
800039fc:	72 08       	ld.w	r8,r9[0x0]
800039fe:	20 18       	sub	r8,1
80003a00:	93 08       	st.w	r9[0x0],r8
80003a02:	c0 71       	brne	80003a10 <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
80003a04:	30 09       	mov	r9,0
80003a06:	fe f8 02 76 	ld.w	r8,pc[630]
80003a0a:	91 09       	st.w	r8[0x0],r9
80003a0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a10:	20 18       	sub	r8,1
80003a12:	fe f9 02 72 	ld.w	r9,pc[626]
80003a16:	93 08       	st.w	r9[0x0],r8
80003a18:	58 08       	cp.w	r8,0
80003a1a:	e0 81 01 13 	brne	80003c40 <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a1e:	30 09       	mov	r9,0
80003a20:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a24:	91 09       	st.w	r8[0x0],r9
80003a26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a2a:	fe f8 02 6a 	ld.w	r8,pc[618]
80003a2e:	11 89       	ld.ub	r9,r8[0x0]
80003a30:	30 48       	mov	r8,4
80003a32:	f0 09 18 00 	cp.b	r9,r8
80003a36:	c0 80       	breq	80003a46 <phy_rx_func+0x9c6>
80003a38:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a3c:	11 89       	ld.ub	r9,r8[0x0]
80003a3e:	30 38       	mov	r8,3
80003a40:	f0 09 18 00 	cp.b	r9,r8
80003a44:	c1 41       	brne	80003a6c <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a46:	6e 29       	ld.w	r9,r7[0x8]
80003a48:	fe f8 02 74 	ld.w	r8,pc[628]
80003a4c:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a4e:	6e 39       	ld.w	r9,r7[0xc]
80003a50:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a52:	fe f9 02 32 	ld.w	r9,pc[562]
80003a56:	72 08       	ld.w	r8,r9[0x0]
80003a58:	20 88       	sub	r8,8
80003a5a:	93 08       	st.w	r9[0x0],r8
80003a5c:	e0 81 00 f2 	brne	80003c40 <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80003a60:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a62:	fe f9 02 1a 	ld.w	r9,pc[538]
80003a66:	93 08       	st.w	r9[0x0],r8
80003a68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a6c:	fe f8 02 28 	ld.w	r8,pc[552]
80003a70:	11 89       	ld.ub	r9,r8[0x0]
80003a72:	31 38       	mov	r8,19
80003a74:	f0 09 18 00 	cp.b	r9,r8
80003a78:	e0 81 00 9c 	brne	80003bb0 <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
80003a7c:	fe f8 02 4c 	ld.w	r8,pc[588]
80003a80:	11 88       	ld.ub	r8,r8[0x0]
80003a82:	30 c9       	mov	r9,12
80003a84:	f2 08 18 00 	cp.b	r8,r9
80003a88:	e0 81 00 7b 	brne	80003b7e <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003a8c:	8e 49       	ld.sh	r9,r7[0x8]
80003a8e:	fe f8 02 3e 	ld.w	r8,pc[574]
80003a92:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003a96:	30 09       	mov	r9,0
80003a98:	fe f8 02 30 	ld.w	r8,pc[560]
80003a9c:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a9e:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003aa2:	3f 38       	mov	r8,-13
80003aa4:	f0 09 18 00 	cp.b	r9,r8
80003aa8:	c6 61       	brne	80003b74 <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003aaa:	10 99       	mov	r9,r8
80003aac:	4f a8       	lddpc	r8,80003c94 <phy_rx_func+0xc14>
80003aae:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003ab0:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003ab4:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003ab8:	4f 38       	lddpc	r8,80003c84 <phy_rx_func+0xc04>
80003aba:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003abc:	30 19       	mov	r9,1
80003abe:	fe f8 02 12 	ld.w	r8,pc[530]
80003ac2:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ac4:	8e 79       	ld.sh	r9,r7[0xe]
80003ac6:	fe f8 01 fe 	ld.w	r8,pc[510]
80003aca:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003acc:	4f 48       	lddpc	r8,80003c9c <phy_rx_func+0xc1c>
80003ace:	4e b9       	lddpc	r9,80003c78 <phy_rx_func+0xbf8>
80003ad0:	72 0a       	ld.w	r10,r9[0x0]
80003ad2:	70 09       	ld.w	r9,r8[0x0]
80003ad4:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ad8:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003adc:	70 09       	ld.w	r9,r8[0x0]
80003ade:	2f f9       	sub	r9,-1
80003ae0:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ae2:	e0 49 01 ff 	cp.w	r9,511
80003ae6:	e0 88 00 13 	brls	80003b0c <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
80003aea:	30 09       	mov	r9,0
80003aec:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003aee:	4e 36       	lddpc	r6,80003c78 <phy_rx_func+0xbf8>
80003af0:	6c 0c       	ld.w	r12,r6[0x0]
80003af2:	f0 1f 00 6d 	mcall	80003ca4 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003af6:	4e 08       	lddpc	r8,80003c74 <phy_rx_func+0xbf4>
80003af8:	70 0c       	ld.w	r12,r8[0x0]
80003afa:	f0 1f 00 59 	mcall	80003c5c <phy_rx_func+0xbdc>
80003afe:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b00:	c0 61       	brne	80003b0c <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80003b02:	30 09       	mov	r9,0
80003b04:	4d e8       	lddpc	r8,80003c7c <phy_rx_func+0xbfc>
80003b06:	91 09       	st.w	r8[0x0],r9
80003b08:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b0c:	4d e9       	lddpc	r9,80003c84 <phy_rx_func+0xc04>
80003b0e:	72 08       	ld.w	r8,r9[0x0]
80003b10:	20 18       	sub	r8,1
80003b12:	93 08       	st.w	r9[0x0],r8
80003b14:	c0 61       	brne	80003b20 <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80003b16:	30 09       	mov	r9,0
80003b18:	4d 98       	lddpc	r8,80003c7c <phy_rx_func+0xbfc>
80003b1a:	91 09       	st.w	r8[0x0],r9
80003b1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b20:	4d f8       	lddpc	r8,80003c9c <phy_rx_func+0xc1c>
80003b22:	4d 69       	lddpc	r9,80003c78 <phy_rx_func+0xbf8>
80003b24:	72 0a       	ld.w	r10,r9[0x0]
80003b26:	70 09       	ld.w	r9,r8[0x0]
80003b28:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b2c:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b30:	70 09       	ld.w	r9,r8[0x0]
80003b32:	2f f9       	sub	r9,-1
80003b34:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b36:	e0 49 01 ff 	cp.w	r9,511
80003b3a:	e0 88 00 13 	brls	80003b60 <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b3e:	30 09       	mov	r9,0
80003b40:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b42:	4c e7       	lddpc	r7,80003c78 <phy_rx_func+0xbf8>
80003b44:	6e 0c       	ld.w	r12,r7[0x0]
80003b46:	f0 1f 00 58 	mcall	80003ca4 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b4a:	4c b8       	lddpc	r8,80003c74 <phy_rx_func+0xbf4>
80003b4c:	70 0c       	ld.w	r12,r8[0x0]
80003b4e:	f0 1f 00 44 	mcall	80003c5c <phy_rx_func+0xbdc>
80003b52:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b54:	c0 61       	brne	80003b60 <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
80003b56:	30 09       	mov	r9,0
80003b58:	4c 98       	lddpc	r8,80003c7c <phy_rx_func+0xbfc>
80003b5a:	91 09       	st.w	r8[0x0],r9
80003b5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b60:	4c 99       	lddpc	r9,80003c84 <phy_rx_func+0xc04>
80003b62:	72 08       	ld.w	r8,r9[0x0]
80003b64:	20 18       	sub	r8,1
80003b66:	93 08       	st.w	r9[0x0],r8
80003b68:	c6 c1       	brne	80003c40 <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
80003b6a:	30 09       	mov	r9,0
80003b6c:	4c 48       	lddpc	r8,80003c7c <phy_rx_func+0xbfc>
80003b6e:	91 09       	st.w	r8[0x0],r9
80003b70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b74:	30 09       	mov	r9,0
80003b76:	4c 28       	lddpc	r8,80003c7c <phy_rx_func+0xbfc>
80003b78:	91 09       	st.w	r8[0x0],r9
80003b7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b7e:	8e 4a       	ld.sh	r10,r7[0x8]
80003b80:	4d 39       	lddpc	r9,80003ccc <phy_rx_func+0xc4c>
80003b82:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003b86:	4d 1a       	lddpc	r10,80003cc8 <phy_rx_func+0xc48>
80003b88:	15 88       	ld.ub	r8,r10[0x0]
80003b8a:	f0 cb ff ff 	sub	r11,r8,-1
80003b8e:	8e 5c       	ld.sh	r12,r7[0xa]
80003b90:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003b94:	f0 cb ff fe 	sub	r11,r8,-2
80003b98:	8e 6c       	ld.sh	r12,r7[0xc]
80003b9a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003b9e:	f0 cb ff fd 	sub	r11,r8,-3
80003ba2:	8e 7c       	ld.sh	r12,r7[0xe]
80003ba4:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003ba8:	2f c8       	sub	r8,-4
80003baa:	b4 88       	st.b	r10[0x0],r8
80003bac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003bb0:	30 09       	mov	r9,0
80003bb2:	4b 38       	lddpc	r8,80003c7c <phy_rx_func+0xbfc>
80003bb4:	91 09       	st.w	r8[0x0],r9
80003bb6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bba:	4b f8       	lddpc	r8,80003cb4 <phy_rx_func+0xc34>
80003bbc:	70 09       	ld.w	r9,r8[0x0]
80003bbe:	8e 4b       	ld.sh	r11,r7[0x8]
80003bc0:	4b ea       	lddpc	r10,80003cb8 <phy_rx_func+0xc38>
80003bc2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003bc6:	2f f9       	sub	r9,-1
80003bc8:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003bca:	4b 48       	lddpc	r8,80003c98 <phy_rx_func+0xc18>
80003bcc:	70 09       	ld.w	r9,r8[0x0]
80003bce:	20 29       	sub	r9,2
80003bd0:	91 09       	st.w	r8[0x0],r9
80003bd2:	70 08       	ld.w	r8,r8[0x0]
80003bd4:	58 08       	cp.w	r8,0
80003bd6:	c2 f1       	brne	80003c34 <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
80003bd8:	30 09       	mov	r9,0
80003bda:	4b 78       	lddpc	r8,80003cb4 <phy_rx_func+0xc34>
80003bdc:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bde:	8e 59       	ld.sh	r9,r7[0xa]
80003be0:	fe 78 82 12 	mov	r8,-32238
80003be4:	f0 09 19 00 	cp.h	r9,r8
80003be8:	c2 11       	brne	80003c2a <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003bea:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003bee:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003bf2:	4a e8       	lddpc	r8,80003ca8 <phy_rx_func+0xc28>
80003bf4:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003bf6:	8e 59       	ld.sh	r9,r7[0xa]
80003bf8:	4a d8       	lddpc	r8,80003cac <phy_rx_func+0xc2c>
80003bfa:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003bfc:	8e 69       	ld.sh	r9,r7[0xc]
80003bfe:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c00:	f0 1f 00 2c 	mcall	80003cb0 <phy_rx_func+0xc30>
80003c04:	49 f8       	lddpc	r8,80003c80 <phy_rx_func+0xc00>
80003c06:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c08:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c0c:	31 38       	mov	r8,19
80003c0e:	f0 09 18 00 	cp.b	r9,r8
80003c12:	c0 71       	brne	80003c20 <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c14:	10 99       	mov	r9,r8
80003c16:	4a 08       	lddpc	r8,80003c94 <phy_rx_func+0xc14>
80003c18:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c1a:	30 09       	mov	r9,0
80003c1c:	49 a8       	lddpc	r8,80003c84 <phy_rx_func+0xc04>
80003c1e:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c20:	30 49       	mov	r9,4
80003c22:	49 78       	lddpc	r8,80003c7c <phy_rx_func+0xbfc>
80003c24:	91 09       	st.w	r8[0x0],r9
80003c26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c2a:	30 09       	mov	r9,0
80003c2c:	49 48       	lddpc	r8,80003c7c <phy_rx_func+0xbfc>
80003c2e:	91 09       	st.w	r8[0x0],r9
80003c30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c34:	4a 8c       	lddpc	r12,80003cd4 <phy_rx_func+0xc54>
80003c36:	f0 1f 00 16 	mcall	80003c8c <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
80003c3a:	30 09       	mov	r9,0
80003c3c:	49 08       	lddpc	r8,80003c7c <phy_rx_func+0xbfc>
80003c3e:	91 09       	st.w	r8[0x0],r9
80003c40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c44:	00 00       	add	r0,r0
80003c46:	0a c4       	st.b	r5++,r4
80003c48:	00 00       	add	r0,r0
80003c4a:	0a bc       	st.h	r5++,r12
80003c4c:	00 00       	add	r0,r0
80003c4e:	0a 90       	mov	r0,r5
80003c50:	00 00       	add	r0,r0
80003c52:	0a 6c       	and	r12,r5
80003c54:	00 00       	add	r0,r0
80003c56:	0a d6       	st.w	--r5,r6
80003c58:	00 00       	add	r0,r0
80003c5a:	0a 9c       	mov	r12,r5
80003c5c:	80 00       	ld.sh	r0,r0[0x0]
80003c5e:	2a 4c       	sub	r12,-92
80003c60:	00 00       	add	r0,r0
80003c62:	0a 7c       	tst	r12,r5
80003c64:	80 00       	ld.sh	r0,r0[0x0]
80003c66:	50 c4       	stdsp	sp[0x30],r4
80003c68:	00 00       	add	r0,r0
80003c6a:	0a 98       	mov	r8,r5
80003c6c:	80 00       	ld.sh	r0,r0[0x0]
80003c6e:	29 98       	sub	r8,-103
80003c70:	00 00       	add	r0,r0
80003c72:	0a ac       	st.w	r5++,r12
80003c74:	00 00       	add	r0,r0
80003c76:	0a 78       	tst	r8,r5
80003c78:	00 00       	add	r0,r0
80003c7a:	0a b4       	st.h	r5++,r4
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a 88       	andn	r8,r5
80003c80:	00 00       	add	r0,r0
80003c82:	0a 74       	tst	r4,r5
80003c84:	00 00       	add	r0,r0
80003c86:	0a a0       	st.w	r5++,r0
80003c88:	80 00       	ld.sh	r0,r0[0x0]
80003c8a:	c7 a0       	breq	80003d7e <local_start_SSC+0x32>
80003c8c:	80 00       	ld.sh	r0,r0[0x0]
80003c8e:	61 64       	ld.w	r4,r0[0x58]
80003c90:	00 00       	add	r0,r0
80003c92:	0a 57       	eor	r7,r5
80003c94:	00 00       	add	r0,r0
80003c96:	0a d4       	st.w	--r5,r4
80003c98:	00 00       	add	r0,r0
80003c9a:	0a 70       	tst	r0,r5
80003c9c:	00 00       	add	r0,r0
80003c9e:	0a b0       	st.h	r5++,r0
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	6a 78       	ld.w	r8,r5[0x1c]
80003ca4:	80 00       	ld.sh	r0,r0[0x0]
80003ca6:	30 20       	mov	r0,2
80003ca8:	00 00       	add	r0,r0
80003caa:	0a 58       	eor	r8,r5
80003cac:	00 00       	add	r0,r0
80003cae:	0e 84       	andn	r4,r7
80003cb0:	80 00       	ld.sh	r0,r0[0x0]
80003cb2:	28 dc       	sub	r12,-115
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a cc       	st.b	r5++,r12
80003cb8:	00 00       	add	r0,r0
80003cba:	0d 88       	ld.ub	r8,r6[0x0]
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a d8       	st.w	--r5,r8
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a 54       	eor	r4,r5
80003cc4:	00 00       	add	r0,r0
80003cc6:	0d 80       	ld.ub	r0,r6[0x0]
80003cc8:	00 00       	add	r0,r0
80003cca:	0a 8c       	andn	r12,r5
80003ccc:	00 00       	add	r0,r0
80003cce:	0e 88       	andn	r8,r7
80003cd0:	00 00       	add	r0,r0
80003cd2:	0a 49       	or	r9,r5
80003cd4:	80 00       	ld.sh	r0,r0[0x0]
80003cd6:	c7 b8       	rjmp	80003dcc <local_start_PDC+0x3c>

80003cd8 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003cd8:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003cda:	49 88       	lddpc	r8,80003d38 <pdca_int_handler+0x60>
80003cdc:	11 89       	ld.ub	r9,r8[0x0]
80003cde:	ec 19 00 01 	eorl	r9,0x1
80003ce2:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003ce4:	11 89       	ld.ub	r9,r8[0x0]
80003ce6:	a5 69       	lsl	r9,0x4
80003ce8:	2f c9       	sub	r9,-4
80003cea:	49 5a       	lddpc	r10,80003d3c <pdca_int_handler+0x64>
80003cec:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003cee:	fe 7a 00 40 	mov	r10,-65472
80003cf2:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003cf4:	30 39       	mov	r9,3
80003cf6:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003cf8:	11 8a       	ld.ub	r10,r8[0x0]
80003cfa:	a5 6a       	lsl	r10,0x4
80003cfc:	2f ca       	sub	r10,-4
80003cfe:	49 18       	lddpc	r8,80003d40 <pdca_int_handler+0x68>
80003d00:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d02:	fe 78 00 00 	mov	r8,-65536
80003d06:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d08:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d0a:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d0c:	48 e8       	lddpc	r8,80003d44 <pdca_int_handler+0x6c>
80003d0e:	70 08       	ld.w	r8,r8[0x0]
80003d10:	58 08       	cp.w	r8,0
80003d12:	c0 70       	breq	80003d20 <pdca_int_handler+0x48>
80003d14:	48 99       	lddpc	r9,80003d38 <pdca_int_handler+0x60>
80003d16:	13 89       	ld.ub	r9,r9[0x0]
80003d18:	a5 69       	lsl	r9,0x4
80003d1a:	48 ac       	lddpc	r12,80003d40 <pdca_int_handler+0x68>
80003d1c:	12 0c       	add	r12,r9
80003d1e:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d20:	48 a8       	lddpc	r8,80003d48 <pdca_int_handler+0x70>
80003d22:	70 08       	ld.w	r8,r8[0x0]
80003d24:	58 08       	cp.w	r8,0
80003d26:	c0 70       	breq	80003d34 <pdca_int_handler+0x5c>
80003d28:	48 49       	lddpc	r9,80003d38 <pdca_int_handler+0x60>
80003d2a:	13 89       	ld.ub	r9,r9[0x0]
80003d2c:	a5 69       	lsl	r9,0x4
80003d2e:	48 4c       	lddpc	r12,80003d3c <pdca_int_handler+0x64>
80003d30:	12 0c       	add	r12,r9
80003d32:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d34:	d4 02       	popm	lr
80003d36:	d6 03       	rete
80003d38:	00 00       	add	r0,r0
80003d3a:	40 a8       	lddsp	r8,sp[0x28]
80003d3c:	00 00       	add	r0,r0
80003d3e:	40 d0       	lddsp	r0,sp[0x34]
80003d40:	00 00       	add	r0,r0
80003d42:	40 b0       	lddsp	r0,sp[0x2c]
80003d44:	00 00       	add	r0,r0
80003d46:	0a e0       	st.h	--r5,r0
80003d48:	00 00       	add	r0,r0
80003d4a:	0a e4       	st.h	--r5,r4

80003d4c <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d4c:	fe 78 10 00 	mov	r8,-61440
80003d50:	e0 69 0d c0 	mov	r9,3520
80003d54:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d58:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d5c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d60:	fe 78 34 00 	mov	r8,-52224
80003d64:	e0 69 80 00 	mov	r9,32768
80003d68:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003d6a:	30 09       	mov	r9,0
80003d6c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003d6e:	e0 69 04 21 	mov	r9,1057
80003d72:	ea 19 3f 20 	orh	r9,0x3f20
80003d76:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003d78:	e0 69 02 9f 	mov	r9,671
80003d7c:	ea 19 01 00 	orh	r9,0x100
80003d80:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003d82:	e0 6a 04 02 	mov	r10,1026
80003d86:	ea 1a 3f 20 	orh	r10,0x3f20
80003d8a:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003d8c:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003d8e:	5e fc       	retal	r12

80003d90 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003d90:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003d92:	30 19       	mov	r9,1
80003d94:	49 78       	lddpc	r8,80003df0 <local_start_PDC+0x60>
80003d96:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003d98:	fe 78 00 00 	mov	r8,-65536
80003d9c:	30 7b       	mov	r11,7
80003d9e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003da0:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003da2:	49 59       	lddpc	r9,80003df4 <local_start_PDC+0x64>
80003da4:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003da8:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003daa:	30 3a       	mov	r10,3
80003dac:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003dae:	30 1c       	mov	r12,1
80003db0:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003db2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003db4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003db6:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003db8:	30 2c       	mov	r12,2
80003dba:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003dbc:	48 f9       	lddpc	r9,80003df8 <local_start_PDC+0x68>
80003dbe:	e0 68 5a 5a 	mov	r8,23130
80003dc2:	ea 18 ab cd 	orh	r8,0xabcd
80003dc6:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003dc8:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003dca:	30 0e       	mov	lr,0
80003dcc:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003dce:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003dd0:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003dd2:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003dd4:	fe 78 00 40 	mov	r8,-65472
80003dd8:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003dda:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003ddc:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003de0:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003de2:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003de4:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003de6:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003de8:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003dea:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003dec:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003dee:	d8 02       	popm	pc
80003df0:	00 00       	add	r0,r0
80003df2:	40 a8       	lddsp	r8,sp[0x28]
80003df4:	00 00       	add	r0,r0
80003df6:	40 b0       	lddsp	r0,sp[0x2c]
80003df8:	00 00       	add	r0,r0
80003dfa:	40 d0       	lddsp	r0,sp[0x34]

80003dfc <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003dfc:	48 38       	lddpc	r8,80003e08 <register_rx_tx_func+0xc>
80003dfe:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e00:	48 38       	lddpc	r8,80003e0c <register_rx_tx_func+0x10>
80003e02:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e04:	5e fc       	retal	r12
80003e06:	00 00       	add	r0,r0
80003e08:	00 00       	add	r0,r0
80003e0a:	0a e0       	st.h	--r5,r0
80003e0c:	00 00       	add	r0,r0
80003e0e:	0a e4       	st.h	--r5,r4

80003e10 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e10:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e12:	fe 78 10 00 	mov	r8,-61440
80003e16:	30 29       	mov	r9,2
80003e18:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e1c:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e20:	10 99       	mov	r9,r8
80003e22:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e26:	e2 18 00 02 	andl	r8,0x2,COH
80003e2a:	cf c0       	breq	80003e22 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e2c:	fe 79 10 00 	mov	r9,-61440
80003e30:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e34:	e2 18 00 02 	andl	r8,0x2,COH
80003e38:	cf c1       	brne	80003e30 <ssc_init+0x20>
				
    INTC_register_interrupt (
80003e3a:	30 3a       	mov	r10,3
80003e3c:	36 0b       	mov	r11,96
80003e3e:	48 bc       	lddpc	r12,80003e68 <ssc_init+0x58>
80003e40:	f0 1f 00 0b 	mcall	80003e6c <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003e44:	f0 1f 00 0b 	mcall	80003e70 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003e48:	f0 1f 00 0b 	mcall	80003e74 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e4c:	fe 79 00 00 	mov	r9,-65536
80003e50:	30 18       	mov	r8,1
80003e52:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e54:	fe 7a 00 40 	mov	r10,-65472
80003e58:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e5a:	e0 6b 01 01 	mov	r11,257
80003e5e:	fe 7a 34 00 	mov	r10,-52224
80003e62:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003e64:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003e66:	d8 02       	popm	pc
80003e68:	80 00       	ld.sh	r0,r0[0x0]
80003e6a:	3c d8       	mov	r8,-51
80003e6c:	80 00       	ld.sh	r0,r0[0x0]
80003e6e:	48 4c       	lddpc	r12,80003e7c <xcmp_register_app_list+0x4>
80003e70:	80 00       	ld.sh	r0,r0[0x0]
80003e72:	3d 4c       	mov	r12,-44
80003e74:	80 00       	ld.sh	r0,r0[0x0]
80003e76:	3d 90       	mov	r0,-39

80003e78 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003e78:	48 28       	lddpc	r8,80003e80 <xcmp_register_app_list+0x8>
80003e7a:	91 0c       	st.w	r8[0x0],r12
}
80003e7c:	5e fc       	retal	r12
80003e7e:	00 00       	add	r0,r0
80003e80:	00 00       	add	r0,r0
80003e82:	40 f0       	lddsp	r0,sp[0x3c]

80003e84 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003e84:	eb cd 40 80 	pushm	r7,lr
80003e88:	fa cd 01 00 	sub	sp,sp,256
80003e8c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003e8e:	16 98       	mov	r8,r11
80003e90:	2f 08       	sub	r8,-16
80003e92:	af a8       	sbr	r8,0xe
80003e94:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003e96:	3f f8       	mov	r8,-1
80003e98:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003e9a:	30 b9       	mov	r9,11
80003e9c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003e9e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003ea0:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003ea2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003ea4:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003ea6:	f6 ca ff fe 	sub	r10,r11,-2
80003eaa:	18 9b       	mov	r11,r12
80003eac:	fa cc ff f0 	sub	r12,sp,-16
80003eb0:	f0 1f 00 05 	mcall	80003ec4 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003eb4:	2f e7       	sub	r7,-2
80003eb6:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003eb8:	1a 9c       	mov	r12,sp
80003eba:	f0 1f 00 04 	mcall	80003ec8 <xcmp_tx+0x44>
}
80003ebe:	2c 0d       	sub	sp,-256
80003ec0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ec4:	80 00       	ld.sh	r0,r0[0x0]
80003ec6:	69 30       	ld.w	r0,r4[0x4c]
80003ec8:	80 00       	ld.sh	r0,r0[0x0]
80003eca:	43 3c       	lddsp	r12,sp[0xcc]

80003ecc <xcmp_data_session>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session(void)
{
80003ecc:	d4 01       	pushm	lr
80003ece:	fa cd 00 cc 	sub	sp,sp,204
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_DATA_REQUEST;
80003ed2:	e0 68 04 1d 	mov	r8,1053
80003ed6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003ed8:	fa c8 ff fc 	sub	r8,sp,-4
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//ID:2
	//
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
	
	ptr->Function = Single_Data_Uint;//0x01
80003edc:	30 19       	mov	r9,1
80003ede:	b0 89       	st.b	r8[0x0],r9
	
	ptr->DataDefinition.Data_Protocol_Version = DMR_CSBK_Data;//0x70
80003ee0:	37 0a       	mov	r10,112
80003ee2:	b0 9a       	st.b	r8[0x1],r10
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_Mototrbo_Address;//0x01
80003ee4:	b0 a9       	st.b	r8[0x2],r9
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_Mototrbo_Address_Size;//0x03
80003ee6:	30 39       	mov	r9,3
80003ee8:	b0 b9       	st.b	r8[0x3],r9
	
	ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x00;
80003eea:	30 09       	mov	r9,0
80003eec:	b0 c9       	st.b	r8[0x4],r9
	ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;
80003eee:	b0 d9       	st.b	r8[0x5],r9
	ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x02;//ID:2
80003ef0:	30 2a       	mov	r10,2
80003ef2:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
80003ef4:	34 0a       	mov	r10,64
80003ef6:	b0 fa       	st.b	r8[0x7],r10
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
80003ef8:	36 1a       	mov	r10,97
80003efa:	f1 6a 00 08 	st.b	r8[8],r10
	    ////
    ////}
	//
	
	//
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003efe:	f1 69 00 09 	st.b	r8[9],r9
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//可能会变化
80003f02:	f1 69 00 0a 	st.b	r8[10],r9
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//可能会变化
80003f06:	31 49       	mov	r9,20
80003f08:	f1 69 00 0b 	st.b	r8[11],r9
80003f0c:	48 88       	lddpc	r8,80003f2c <xcmp_data_session+0x60>
80003f0e:	fa c9 ff f0 	sub	r9,sp,-16
Parameters:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session(void)
80003f12:	f0 cb ff ec 	sub	r11,r8,-20
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//可能会变化
	
	for (i=0; i< sizeof(DataPayload) ; i++)
	{
	
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//长度计算了吗？
80003f16:	11 3a       	ld.ub	r10,r8++
80003f18:	12 ca       	st.b	r9++,r10
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//可能会变化
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//可能会变化
	
	for (i=0; i< sizeof(DataPayload) ; i++)
80003f1a:	16 38       	cp.w	r8,r11
80003f1c:	cf d1       	brne	80003f16 <xcmp_data_session+0x4a>
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//长度计算了吗？
		
	}
	
	/*send xcmp frame*///注意！！！！！！！！！！
	xcmp_tx( &xcmp_farme, sizeof(DataSession_req_t));
80003f1e:	32 0b       	mov	r11,32
80003f20:	fa cc ff fe 	sub	r12,sp,-2
80003f24:	f0 1f 00 03 	mcall	80003f30 <xcmp_data_session+0x64>
}
80003f28:	2c dd       	sub	sp,-204
80003f2a:	d8 02       	popm	pc
80003f2c:	00 00       	add	r0,r0
80003f2e:	04 f4       	st.b	--r2,r4
80003f30:	80 00       	ld.sh	r0,r0[0x0]
80003f32:	3e 84       	mov	r4,-24

80003f34 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003f34:	d4 01       	pushm	lr
80003f36:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003f3a:	fe 78 b4 00 	mov	r8,-19456
80003f3e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003f40:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003f44:	30 89       	mov	r9,8
80003f46:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003f48:	30 19       	mov	r9,1
80003f4a:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003f4c:	30 09       	mov	r9,0
80003f4e:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003f50:	30 5a       	mov	r10,5
80003f52:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003f54:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003f56:	30 7a       	mov	r10,7
80003f58:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003f5a:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003f5c:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003f5e:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003f62:	30 9b       	mov	r11,9
80003f64:	fa cc ff fe 	sub	r12,sp,-2
80003f68:	f0 1f 00 02 	mcall	80003f70 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003f6c:	2c dd       	sub	sp,-204
80003f6e:	d8 02       	popm	pc
80003f70:	80 00       	ld.sh	r0,r0[0x0]
80003f72:	3e 84       	mov	r4,-24

80003f74 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003f74:	d4 01       	pushm	lr
80003f76:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003f7a:	fe 78 80 00 	mov	r8,-32768
80003f7e:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003f80:	30 38       	mov	r8,3
80003f82:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003f84:	30 1b       	mov	r11,1
80003f86:	fa cc ff fe 	sub	r12,sp,-2
80003f8a:	f0 1f 00 03 	mcall	80003f94 <xcmp_opcode_not_supported+0x20>
}
80003f8e:	2c dd       	sub	sp,-204
80003f90:	d8 02       	popm	pc
80003f92:	00 00       	add	r0,r0
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	3e 84       	mov	r4,-24

80003f98 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003f98:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003f9a:	96 88       	ld.uh	r8,r11[0x0]
80003f9c:	e2 18 f0 00 	andl	r8,0xf000,COH
80003fa0:	e0 48 80 00 	cp.w	r8,32768
80003fa4:	c0 f0       	breq	80003fc2 <xcmp_exec_func+0x2a>
80003fa6:	e0 48 b0 00 	cp.w	r8,45056
80003faa:	c1 20       	breq	80003fce <xcmp_exec_func+0x36>
80003fac:	58 08       	cp.w	r8,0
80003fae:	c1 51       	brne	80003fd8 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003fb0:	78 08       	ld.w	r8,r12[0x0]
80003fb2:	58 08       	cp.w	r8,0
80003fb4:	c0 40       	breq	80003fbc <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003fb6:	16 9c       	mov	r12,r11
80003fb8:	5d 18       	icall	r8
80003fba:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
80003fbc:	f0 1f 00 08 	mcall	80003fdc <xcmp_exec_func+0x44>
80003fc0:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003fc2:	78 18       	ld.w	r8,r12[0x4]
80003fc4:	58 08       	cp.w	r8,0
80003fc6:	c0 90       	breq	80003fd8 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003fc8:	16 9c       	mov	r12,r11
80003fca:	5d 18       	icall	r8
80003fcc:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003fce:	78 28       	ld.w	r8,r12[0x8]
80003fd0:	58 08       	cp.w	r8,0
80003fd2:	c0 30       	breq	80003fd8 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003fd4:	16 9c       	mov	r12,r11
80003fd6:	5d 18       	icall	r8
80003fd8:	d8 02       	popm	pc
80003fda:	00 00       	add	r0,r0
80003fdc:	80 00       	ld.sh	r0,r0[0x0]
80003fde:	3f 74       	mov	r4,-9

80003fe0 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80003fe0:	d4 01       	pushm	lr
80003fe2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003fe6:	e0 68 04 09 	mov	r8,1033
80003fea:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003fec:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80003ff0:	30 19       	mov	r9,1
80003ff2:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80003ff4:	30 09       	mov	r9,0
80003ff6:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80003ff8:	30 ca       	mov	r10,12
80003ffa:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003ffc:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003ffe:	fb 69 00 08 	st.b	sp[8],r9
80004002:	fa c8 ff f7 	sub	r8,sp,-9
80004006:	b0 89       	st.b	r8[0x0],r9
80004008:	fa c8 ff f6 	sub	r8,sp,-10
8000400c:	b0 89       	st.b	r8[0x0],r9
8000400e:	fa c8 ff f5 	sub	r8,sp,-11
80004012:	b0 89       	st.b	r8[0x0],r9
80004014:	fa c8 ff f4 	sub	r8,sp,-12
80004018:	b0 89       	st.b	r8[0x0],r9
8000401a:	fa c8 ff f3 	sub	r8,sp,-13
8000401e:	b0 89       	st.b	r8[0x0],r9
80004020:	fa c8 ff f2 	sub	r8,sp,-14
80004024:	b0 89       	st.b	r8[0x0],r9
80004026:	fa c8 ff f1 	sub	r8,sp,-15
8000402a:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
8000402c:	30 cb       	mov	r11,12
8000402e:	fa cc ff fe 	sub	r12,sp,-2
80004032:	f0 1f 00 03 	mcall	8000403c <xcmp_IdleTestTone+0x5c>
}
80004036:	2c dd       	sub	sp,-204
80004038:	d8 02       	popm	pc
8000403a:	00 00       	add	r0,r0
8000403c:	80 00       	ld.sh	r0,r0[0x0]
8000403e:	3e 84       	mov	r4,-24

80004040 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80004040:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80004042:	f0 1f 00 0d 	mcall	80004074 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80004046:	48 dc       	lddpc	r12,80004078 <xcmp_init+0x38>
80004048:	f0 1f 00 0d 	mcall	8000407c <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
8000404c:	30 4b       	mov	r11,4
8000404e:	31 4c       	mov	r12,20
80004050:	f0 1f 00 0c 	mcall	80004080 <xcmp_init+0x40>
80004054:	48 c8       	lddpc	r8,80004084 <xcmp_init+0x44>
80004056:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80004058:	30 09       	mov	r9,0
8000405a:	1a d9       	st.w	--sp,r9
8000405c:	1a d9       	st.w	--sp,r9
8000405e:	1a d9       	st.w	--sp,r9
80004060:	30 38       	mov	r8,3
80004062:	e0 6a 01 80 	mov	r10,384
80004066:	48 9b       	lddpc	r11,80004088 <xcmp_init+0x48>
80004068:	48 9c       	lddpc	r12,8000408c <xcmp_init+0x4c>
8000406a:	f0 1f 00 0a 	mcall	80004090 <xcmp_init+0x50>
8000406e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80004070:	d8 02       	popm	pc
80004072:	00 00       	add	r0,r0
80004074:	80 00       	ld.sh	r0,r0[0x0]
80004076:	44 20       	lddsp	r0,sp[0x108]
80004078:	80 00       	ld.sh	r0,r0[0x0]
8000407a:	41 90       	lddsp	r0,sp[0x64]
8000407c:	80 00       	ld.sh	r0,r0[0x0]
8000407e:	41 dc       	lddsp	r12,sp[0x74]
80004080:	80 00       	ld.sh	r0,r0[0x0]
80004082:	55 40       	stdsp	sp[0x150],r0
80004084:	00 00       	add	r0,r0
80004086:	0a f4       	st.b	--r5,r4
80004088:	80 00       	ld.sh	r0,r0[0x0]
8000408a:	c7 e4       	brge	80004186 <xcmp_rx_process+0xf2>
8000408c:	80 00       	ld.sh	r0,r0[0x0]
8000408e:	40 94       	lddsp	r4,sp[0x24]
80004090:	80 00       	ld.sh	r0,r0[0x0]
80004092:	5c 14       	scr	r4

80004094 <xcmp_rx_process>:
Calls: xQueueReceive -- freertos
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004094:	d4 31       	pushm	r0-r7,lr
80004096:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004098:	4b 16       	lddpc	r6,8000415c <xcmp_rx_process+0xc8>
8000409a:	30 05       	mov	r5,0
8000409c:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000409e:	4b 13       	lddpc	r3,80004160 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800040a0:	4b 12       	lddpc	r2,80004164 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800040a2:	4b 21       	lddpc	r1,80004168 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800040a4:	4b 20       	lddpc	r0,8000416c <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800040a6:	6c 0c       	ld.w	r12,r6[0x0]
800040a8:	0a 99       	mov	r9,r5
800040aa:	08 9a       	mov	r10,r4
800040ac:	1a 9b       	mov	r11,sp
800040ae:	f0 1f 00 31 	mcall	80004170 <xcmp_rx_process+0xdc>
800040b2:	58 1c       	cp.w	r12,1
800040b4:	cf 91       	brne	800040a6 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800040b6:	40 0b       	lddsp	r11,sp[0x0]
800040b8:	58 0b       	cp.w	r11,0
800040ba:	cf 60       	breq	800040a6 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800040bc:	96 0a       	ld.sh	r10,r11[0x0]
800040be:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800040c2:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800040c6:	59 c8       	cp.w	r8,28
800040c8:	c1 e0       	breq	80004104 <xcmp_rx_process+0x70>
800040ca:	e0 89 00 07 	brgt	800040d8 <xcmp_rx_process+0x44>
800040ce:	58 e8       	cp.w	r8,14
800040d0:	c0 e0       	breq	800040ec <xcmp_rx_process+0x58>
800040d2:	58 f8       	cp.w	r8,15
800040d4:	c2 41       	brne	8000411c <xcmp_rx_process+0x88>
800040d6:	c0 f8       	rjmp	800040f4 <xcmp_rx_process+0x60>
800040d8:	e0 48 01 09 	cp.w	r8,265
800040dc:	c1 80       	breq	8000410c <xcmp_rx_process+0x78>
800040de:	e0 48 01 0a 	cp.w	r8,266
800040e2:	c1 90       	breq	80004114 <xcmp_rx_process+0x80>
800040e4:	e0 48 00 2c 	cp.w	r8,44
800040e8:	c1 a1       	brne	8000411c <xcmp_rx_process+0x88>
800040ea:	c0 98       	rjmp	800040fc <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800040ec:	4a 2c       	lddpc	r12,80004174 <xcmp_rx_process+0xe0>
800040ee:	f0 1f 00 23 	mcall	80004178 <xcmp_rx_process+0xe4>
					break;
800040f2:	c2 f8       	rjmp	80004150 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800040f4:	4a 2c       	lddpc	r12,8000417c <xcmp_rx_process+0xe8>
800040f6:	f0 1f 00 21 	mcall	80004178 <xcmp_rx_process+0xe4>
					break;
800040fa:	c2 b8       	rjmp	80004150 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800040fc:	4a 1c       	lddpc	r12,80004180 <xcmp_rx_process+0xec>
800040fe:	f0 1f 00 1f 	mcall	80004178 <xcmp_rx_process+0xe4>
					break;
80004102:	c2 78       	rjmp	80004150 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004104:	04 9c       	mov	r12,r2
80004106:	f0 1f 00 1d 	mcall	80004178 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000410a:	c2 38       	rjmp	80004150 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000410c:	02 9c       	mov	r12,r1
8000410e:	f0 1f 00 1b 	mcall	80004178 <xcmp_rx_process+0xe4>
					break;
80004112:	c1 f8       	rjmp	80004150 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004114:	00 9c       	mov	r12,r0
80004116:	f0 1f 00 19 	mcall	80004178 <xcmp_rx_process+0xe4>
					break;
8000411a:	c1 b8       	rjmp	80004150 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000411c:	12 98       	mov	r8,r9
8000411e:	e2 18 04 00 	andl	r8,0x400,COH
80004122:	c0 70       	breq	80004130 <xcmp_rx_process+0x9c>
80004124:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004128:	e0 48 00 68 	cp.w	r8,104
8000412c:	e0 8a 00 08 	brle	8000413c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004130:	e2 19 f0 00 	andl	r9,0xf000,COH
80004134:	c0 e1       	brne	80004150 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80004136:	f0 1f 00 14 	mcall	80004184 <xcmp_rx_process+0xf0>
8000413a:	c0 b8       	rjmp	80004150 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000413c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004140:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80004144:	49 19       	lddpc	r9,80004188 <xcmp_rx_process+0xf4>
80004146:	72 08       	ld.w	r8,r9[0x0]
80004148:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000414c:	f0 1f 00 0b 	mcall	80004178 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004150:	66 0c       	ld.w	r12,r3[0x0]
80004152:	40 0b       	lddsp	r11,sp[0x0]
80004154:	f0 1f 00 0e 	mcall	8000418c <xcmp_rx_process+0xf8>
80004158:	ca 7b       	rjmp	800040a6 <xcmp_rx_process+0x12>
8000415a:	00 00       	add	r0,r0
8000415c:	00 00       	add	r0,r0
8000415e:	0a f4       	st.b	--r5,r4
80004160:	00 00       	add	r0,r0
80004162:	0a 9c       	mov	r12,r5
80004164:	00 00       	add	r0,r0
80004166:	0b 04       	ld.w	r4,r5++
80004168:	00 00       	add	r0,r0
8000416a:	0a f8       	st.b	--r5,r8
8000416c:	00 00       	add	r0,r0
8000416e:	0b 10       	ld.sh	r0,r5++
80004170:	80 00       	ld.sh	r0,r0[0x0]
80004172:	52 34       	stdsp	sp[0x8c],r4
80004174:	00 00       	add	r0,r0
80004176:	0b 28       	ld.uh	r8,r5++
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	3f 98       	mov	r8,-7
8000417c:	00 00       	add	r0,r0
8000417e:	0a e8       	st.h	--r5,r8
80004180:	00 00       	add	r0,r0
80004182:	0b 1c       	ld.sh	r12,r5++
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	3f 74       	mov	r4,-9
80004188:	00 00       	add	r0,r0
8000418a:	40 f0       	lddsp	r0,sp[0x3c]
8000418c:	80 00       	ld.sh	r0,r0[0x0]
8000418e:	29 d0       	sub	r0,-99

80004190 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004190:	eb cd 40 90 	pushm	r4,r7,lr
80004194:	20 1d       	sub	sp,4
80004196:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000419a:	48 c8       	lddpc	r8,800041c8 <xcmp_rx+0x38>
8000419c:	70 0c       	ld.w	r12,r8[0x0]
8000419e:	f0 1f 00 0c 	mcall	800041cc <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800041a2:	c1 00       	breq	800041c2 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800041a4:	fa c7 ff fc 	sub	r7,sp,-4
800041a8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800041aa:	e0 6a 00 ca 	mov	r10,202
800041ae:	08 9b       	mov	r11,r4
800041b0:	f0 1f 00 08 	mcall	800041d0 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800041b4:	48 88       	lddpc	r8,800041d4 <xcmp_rx+0x44>
800041b6:	70 0c       	ld.w	r12,r8[0x0]
800041b8:	30 09       	mov	r9,0
800041ba:	12 9a       	mov	r10,r9
800041bc:	1a 9b       	mov	r11,sp
800041be:	f0 1f 00 07 	mcall	800041d8 <xcmp_rx+0x48>
	}	
}
800041c2:	2f fd       	sub	sp,-4
800041c4:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800041c8:	00 00       	add	r0,r0
800041ca:	0a 9c       	mov	r12,r5
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	2f 3c       	sub	r12,-13
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	69 30       	ld.w	r0,r4[0x4c]
800041d4:	00 00       	add	r0,r0
800041d6:	0a f4       	st.b	--r5,r4
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	54 40       	stdsp	sp[0x110],r0

800041dc <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800041dc:	48 28       	lddpc	r8,800041e4 <xnl_register_xcmp_func+0x8>
800041de:	91 0c       	st.w	r8[0x0],r12
}
800041e0:	5e fc       	retal	r12
800041e2:	00 00       	add	r0,r0
800041e4:	00 00       	add	r0,r0
800041e6:	0b 54       	ld.sh	r4,--r5

800041e8 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800041e8:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800041ea:	48 88       	lddpc	r8,80004208 <xnl_get_msg_ack_func+0x20>
800041ec:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800041ee:	98 49       	ld.sh	r9,r12[0x8]
800041f0:	f0 09 19 00 	cp.h	r9,r8
800041f4:	c0 81       	brne	80004204 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800041f6:	48 68       	lddpc	r8,8000420c <xnl_get_msg_ack_func+0x24>
800041f8:	70 0c       	ld.w	r12,r8[0x0]
800041fa:	30 09       	mov	r9,0
800041fc:	12 9a       	mov	r10,r9
800041fe:	12 9b       	mov	r11,r9
80004200:	f0 1f 00 04 	mcall	80004210 <xnl_get_msg_ack_func+0x28>
80004204:	d8 02       	popm	pc
80004206:	00 00       	add	r0,r0
80004208:	00 00       	add	r0,r0
8000420a:	0b 3a       	ld.ub	r10,r5++
8000420c:	00 00       	add	r0,r0
8000420e:	0b 34       	ld.ub	r4,r5++
80004210:	80 00       	ld.sh	r0,r0[0x0]
80004212:	54 40       	stdsp	sp[0x110],r0

80004214 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004214:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004216:	4a 86       	lddpc	r6,800042b4 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004218:	4a 82       	lddpc	r2,800042b8 <xnl_tx_process+0xa4>
8000421a:	4a 94       	lddpc	r4,800042bc <xnl_tx_process+0xa8>
8000421c:	30 07       	mov	r7,0
8000421e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004220:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004222:	4a 85       	lddpc	r5,800042c0 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004224:	4a 83       	lddpc	r3,800042c4 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80004226:	6c 08       	ld.w	r8,r6[0x0]
80004228:	58 08       	cp.w	r8,0
8000422a:	c0 40       	breq	80004232 <xnl_tx_process+0x1e>
8000422c:	58 18       	cp.w	r8,1
8000422e:	cf d1       	brne	80004228 <xnl_tx_process+0x14>
80004230:	c2 08       	rjmp	80004270 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004232:	64 0c       	ld.w	r12,r2[0x0]
80004234:	0e 99       	mov	r9,r7
80004236:	02 9a       	mov	r10,r1
80004238:	08 9b       	mov	r11,r4
8000423a:	f0 1f 00 24 	mcall	800042c8 <xnl_tx_process+0xb4>
8000423e:	58 1c       	cp.w	r12,1
80004240:	cf 31       	brne	80004226 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004242:	68 0c       	ld.w	r12,r4[0x0]
80004244:	58 0c       	cp.w	r12,0
80004246:	cf 00       	breq	80004226 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004248:	98 28       	ld.sh	r8,r12[0x4]
8000424a:	e0 08 19 00 	cp.h	r8,r0
8000424e:	c0 41       	brne	80004256 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80004250:	f0 1f 00 1f 	mcall	800042cc <xnl_tx_process+0xb8>
						break;
80004254:	ce 9b       	rjmp	80004226 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004256:	f0 1f 00 1f 	mcall	800042d0 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000425a:	30 18       	mov	r8,1
8000425c:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000425e:	66 0c       	ld.w	r12,r3[0x0]
80004260:	0e 99       	mov	r9,r7
80004262:	0e 9a       	mov	r10,r7
80004264:	0e 9b       	mov	r11,r7
80004266:	f0 1f 00 19 	mcall	800042c8 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
8000426a:	30 18       	mov	r8,1
8000426c:	8d 08       	st.w	r6[0x0],r8
8000426e:	cd cb       	rjmp	80004226 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004270:	66 0c       	ld.w	r12,r3[0x0]
80004272:	0e 99       	mov	r9,r7
80004274:	36 4a       	mov	r10,100
80004276:	0e 9b       	mov	r11,r7
80004278:	f0 1f 00 14 	mcall	800042c8 <xnl_tx_process+0xb4>
8000427c:	58 1c       	cp.w	r12,1
8000427e:	c0 81       	brne	8000428e <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80004280:	49 58       	lddpc	r8,800042d4 <xnl_tx_process+0xc0>
80004282:	70 0c       	ld.w	r12,r8[0x0]
80004284:	68 0b       	ld.w	r11,r4[0x0]
80004286:	f0 1f 00 15 	mcall	800042d8 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000428a:	8d 07       	st.w	r6[0x0],r7
8000428c:	cc db       	rjmp	80004226 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
8000428e:	6a 08       	ld.w	r8,r5[0x0]
80004290:	58 38       	cp.w	r8,3
80004292:	e0 89 00 09 	brgt	800042a4 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004296:	68 0c       	ld.w	r12,r4[0x0]
80004298:	f0 1f 00 0e 	mcall	800042d0 <xnl_tx_process+0xbc>
						xnl_send_times++;
8000429c:	6a 08       	ld.w	r8,r5[0x0]
8000429e:	2f f8       	sub	r8,-1
800042a0:	8b 08       	st.w	r5[0x0],r8
800042a2:	cc 2b       	rjmp	80004226 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800042a4:	48 c8       	lddpc	r8,800042d4 <xnl_tx_process+0xc0>
800042a6:	70 0c       	ld.w	r12,r8[0x0]
800042a8:	68 0b       	ld.w	r11,r4[0x0]
800042aa:	f0 1f 00 0c 	mcall	800042d8 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800042ae:	8d 07       	st.w	r6[0x0],r7
800042b0:	cb bb       	rjmp	80004226 <xnl_tx_process+0x12>
800042b2:	00 00       	add	r0,r0
800042b4:	00 00       	add	r0,r0
800042b6:	0b 50       	ld.sh	r0,--r5
800042b8:	00 00       	add	r0,r0
800042ba:	0b 44       	ld.w	r4,--r5
800042bc:	00 00       	add	r0,r0
800042be:	0b 48       	ld.w	r8,--r5
800042c0:	00 00       	add	r0,r0
800042c2:	0b 4c       	ld.w	r12,--r5
800042c4:	00 00       	add	r0,r0
800042c6:	0b 34       	ld.ub	r4,r5++
800042c8:	80 00       	ld.sh	r0,r0[0x0]
800042ca:	52 34       	stdsp	sp[0x8c],r4
800042cc:	80 00       	ld.sh	r0,r0[0x0]
800042ce:	50 c4       	stdsp	sp[0x30],r4
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	29 f0       	sub	r0,-97
800042d4:	00 00       	add	r0,r0
800042d6:	0a 9c       	mov	r12,r5
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	29 d0       	sub	r0,-99

800042dc <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800042dc:	eb cd 40 fe 	pushm	r1-r7,lr
800042e0:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042e2:	49 26       	lddpc	r6,80004328 <xnl_rx_process+0x4c>
800042e4:	30 05       	mov	r5,0
800042e6:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042e8:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042ea:	49 11       	lddpc	r1,8000432c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042ec:	49 12       	lddpc	r2,80004330 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042ee:	6c 0c       	ld.w	r12,r6[0x0]
800042f0:	0a 99       	mov	r9,r5
800042f2:	08 9a       	mov	r10,r4
800042f4:	1a 9b       	mov	r11,sp
800042f6:	f0 1f 00 10 	mcall	80004334 <xnl_rx_process+0x58>
800042fa:	58 1c       	cp.w	r12,1
800042fc:	cf 91       	brne	800042ee <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800042fe:	40 0c       	lddsp	r12,sp[0x0]
80004300:	58 0c       	cp.w	r12,0
80004302:	cf 60       	breq	800042ee <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004304:	98 28       	ld.sh	r8,r12[0x4]
80004306:	e6 08 19 00 	cp.h	r8,r3
8000430a:	e0 8b 00 0a 	brhi	8000431e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000430e:	5c 78       	castu.h	r8
80004310:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004314:	58 09       	cp.w	r9,0
80004316:	c0 40       	breq	8000431e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004318:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000431c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000431e:	62 0c       	ld.w	r12,r1[0x0]
80004320:	40 0b       	lddsp	r11,sp[0x0]
80004322:	f0 1f 00 06 	mcall	80004338 <xnl_rx_process+0x5c>
80004326:	ce 4b       	rjmp	800042ee <xnl_rx_process+0x12>
80004328:	00 00       	add	r0,r0
8000432a:	0a c4       	st.b	r5++,r4
8000432c:	00 00       	add	r0,r0
8000432e:	0a 9c       	mov	r12,r5
80004330:	00 00       	add	r0,r0
80004332:	05 08       	ld.w	r8,r2++
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	52 34       	stdsp	sp[0x8c],r4
80004338:	80 00       	ld.sh	r0,r0[0x0]
8000433a:	29 d0       	sub	r0,-99

8000433c <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
8000433c:	eb cd 40 c0 	pushm	r6-r7,lr
80004340:	20 1d       	sub	sp,4
80004342:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80004344:	98 39       	ld.sh	r9,r12[0x6]
80004346:	3f f8       	mov	r8,-1
80004348:	f0 09 19 00 	cp.h	r9,r8
8000434c:	c0 a1       	brne	80004360 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000434e:	4a e9       	lddpc	r9,80004404 <xnl_tx+0xc8>
80004350:	13 88       	ld.ub	r8,r9[0x0]
80004352:	2f f8       	sub	r8,-1
80004354:	5c 58       	castu.b	r8
80004356:	b2 88       	st.b	r9[0x0],r8
80004358:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000435c:	a9 a8       	sbr	r8,0x8
8000435e:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004360:	8c 49       	ld.sh	r9,r6[0x8]
80004362:	3f f8       	mov	r8,-1
80004364:	f0 09 19 00 	cp.h	r9,r8
80004368:	c0 41       	brne	80004370 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000436a:	4a 88       	lddpc	r8,80004408 <xnl_tx+0xcc>
8000436c:	90 18       	ld.sh	r8,r8[0x2]
8000436e:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004370:	8c 59       	ld.sh	r9,r6[0xa]
80004372:	3f f8       	mov	r8,-1
80004374:	f0 09 19 00 	cp.h	r9,r8
80004378:	c0 41       	brne	80004380 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000437a:	4a 48       	lddpc	r8,80004408 <xnl_tx+0xcc>
8000437c:	90 28       	ld.sh	r8,r8[0x4]
8000437e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004380:	8c 69       	ld.sh	r9,r6[0xc]
80004382:	3f f8       	mov	r8,-1
80004384:	f0 09 19 00 	cp.h	r9,r8
80004388:	c0 e1       	brne	800043a4 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000438a:	4a 08       	lddpc	r8,80004408 <xnl_tx+0xcc>
8000438c:	90 49       	ld.sh	r9,r8[0x8]
8000438e:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004390:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004392:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004394:	90 49       	ld.sh	r9,r8[0x8]
80004396:	e0 19 ff 00 	andl	r9,0xff00
8000439a:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
8000439e:	f3 e8 10 08 	or	r8,r9,r8
800043a2:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800043a4:	0d 98       	ld.ub	r8,r6[0x1]
800043a6:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800043a8:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800043ac:	10 0c       	add	r12,r8
800043ae:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043b0:	58 0c       	cp.w	r12,0
800043b2:	e0 89 00 04 	brgt	800043ba <xnl_tx+0x7e>
800043b6:	30 09       	mov	r9,0
800043b8:	c0 d8       	rjmp	800043d2 <xnl_tx+0x96>
800043ba:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800043be:	2f ec       	sub	r12,-2
800043c0:	30 09       	mov	r9,0
800043c2:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800043c4:	15 1b       	ld.sh	r11,r10++
800043c6:	f6 09 00 09 	add	r9,r11,r9
800043ca:	5c 89       	casts.h	r9
		indextohWord     += 1;
800043cc:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043ce:	18 38       	cp.w	r8,r12
800043d0:	cf a1       	brne	800043c4 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800043d2:	5c 39       	neg	r9
800043d4:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043d6:	48 e8       	lddpc	r8,8000440c <xnl_tx+0xd0>
800043d8:	70 0c       	ld.w	r12,r8[0x0]
800043da:	f0 1f 00 0e 	mcall	80004410 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800043de:	c1 00       	breq	800043fe <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043e0:	fa c7 ff fc 	sub	r7,sp,-4
800043e4:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800043e6:	e0 6a 01 00 	mov	r10,256
800043ea:	0c 9b       	mov	r11,r6
800043ec:	f0 1f 00 0a 	mcall	80004414 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800043f0:	48 a8       	lddpc	r8,80004418 <xnl_tx+0xdc>
800043f2:	70 0c       	ld.w	r12,r8[0x0]
800043f4:	30 09       	mov	r9,0
800043f6:	12 9a       	mov	r10,r9
800043f8:	1a 9b       	mov	r11,sp
800043fa:	f0 1f 00 09 	mcall	8000441c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800043fe:	2f fd       	sub	sp,-4
80004400:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004404:	00 00       	add	r0,r0
80004406:	0b 38       	ld.ub	r8,r5++
80004408:	00 00       	add	r0,r0
8000440a:	0b 3a       	ld.ub	r10,r5++
8000440c:	00 00       	add	r0,r0
8000440e:	0a 9c       	mov	r12,r5
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	2f 3c       	sub	r12,-13
80004414:	80 00       	ld.sh	r0,r0[0x0]
80004416:	69 30       	ld.w	r0,r4[0x4c]
80004418:	00 00       	add	r0,r0
8000441a:	0b 44       	ld.w	r4,--r5
8000441c:	80 00       	ld.sh	r0,r0[0x0]
8000441e:	54 40       	stdsp	sp[0x110],r0

80004420 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004420:	eb cd 40 80 	pushm	r7,lr
80004424:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80004428:	f0 1f 00 27 	mcall	800044c4 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
8000442c:	30 09       	mov	r9,0
8000442e:	4a 78       	lddpc	r8,800044c8 <xnl_init+0xa8>
80004430:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004432:	30 0b       	mov	r11,0
80004434:	30 1c       	mov	r12,1
80004436:	f0 1f 00 26 	mcall	800044cc <xnl_init+0xac>
8000443a:	4a 68       	lddpc	r8,800044d0 <xnl_init+0xb0>
8000443c:	91 0c       	st.w	r8[0x0],r12
8000443e:	70 08       	ld.w	r8,r8[0x0]
80004440:	58 08       	cp.w	r8,0
80004442:	c0 80       	breq	80004452 <xnl_init+0x32>
80004444:	4a 38       	lddpc	r8,800044d0 <xnl_init+0xb0>
80004446:	70 0c       	ld.w	r12,r8[0x0]
80004448:	30 09       	mov	r9,0
8000444a:	12 9a       	mov	r10,r9
8000444c:	12 9b       	mov	r11,r9
8000444e:	f0 1f 00 22 	mcall	800044d4 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004452:	30 4b       	mov	r11,4
80004454:	31 4c       	mov	r12,20
80004456:	f0 1f 00 1e 	mcall	800044cc <xnl_init+0xac>
8000445a:	4a 08       	lddpc	r8,800044d8 <xnl_init+0xb8>
8000445c:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000445e:	30 07       	mov	r7,0
80004460:	1a d7       	st.w	--sp,r7
80004462:	1a d7       	st.w	--sp,r7
80004464:	1a d7       	st.w	--sp,r7
80004466:	30 38       	mov	r8,3
80004468:	0e 99       	mov	r9,r7
8000446a:	e0 6a 02 00 	mov	r10,512
8000446e:	49 cb       	lddpc	r11,800044dc <xnl_init+0xbc>
80004470:	49 cc       	lddpc	r12,800044e0 <xnl_init+0xc0>
80004472:	f0 1f 00 1d 	mcall	800044e4 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80004476:	1a d7       	st.w	--sp,r7
80004478:	1a d7       	st.w	--sp,r7
8000447a:	1a d7       	st.w	--sp,r7
8000447c:	30 38       	mov	r8,3
8000447e:	0e 99       	mov	r9,r7
80004480:	e0 6a 03 20 	mov	r10,800
80004484:	49 9b       	lddpc	r11,800044e8 <xnl_init+0xc8>
80004486:	49 ac       	lddpc	r12,800044ec <xnl_init+0xcc>
80004488:	f0 1f 00 17 	mcall	800044e4 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000448c:	e0 68 40 0e 	mov	r8,16398
80004490:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004494:	3f f8       	mov	r8,-1
80004496:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000449a:	30 38       	mov	r8,3
8000449c:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800044a0:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800044a4:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800044a8:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800044ac:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800044b0:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800044b4:	fa cc ff e8 	sub	r12,sp,-24
800044b8:	f0 1f 00 0e 	mcall	800044f0 <xnl_init+0xd0>
800044bc:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
800044be:	2c 0d       	sub	sp,-256
800044c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800044c4:	80 00       	ld.sh	r0,r0[0x0]
800044c6:	2f 64       	sub	r4,-10
800044c8:	00 00       	add	r0,r0
800044ca:	0b 3a       	ld.ub	r10,r5++
800044cc:	80 00       	ld.sh	r0,r0[0x0]
800044ce:	55 40       	stdsp	sp[0x150],r0
800044d0:	00 00       	add	r0,r0
800044d2:	0b 34       	ld.ub	r4,r5++
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	54 40       	stdsp	sp[0x110],r0
800044d8:	00 00       	add	r0,r0
800044da:	0b 44       	ld.w	r4,--r5
800044dc:	80 00       	ld.sh	r0,r0[0x0]
800044de:	c7 ec       	rcall	800045da <xnl_device_auth_reply_func+0x86>
800044e0:	80 00       	ld.sh	r0,r0[0x0]
800044e2:	42 dc       	lddsp	r12,sp[0xb4]
800044e4:	80 00       	ld.sh	r0,r0[0x0]
800044e6:	5c 14       	scr	r4
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	c0 00       	breq	800044ea <xnl_init+0xca>
800044ec:	80 00       	ld.sh	r0,r0[0x0]
800044ee:	42 14       	lddsp	r4,sp[0x84]
800044f0:	80 00       	ld.sh	r0,r0[0x0]
800044f2:	43 3c       	lddsp	r12,sp[0xcc]

800044f4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800044f4:	eb cd 40 80 	pushm	r7,lr
800044f8:	fa cd 01 00 	sub	sp,sp,256
800044fc:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044fe:	e0 68 40 0e 	mov	r8,16398
80004502:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004504:	3f f8       	mov	r8,-1
80004506:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80004508:	30 c8       	mov	r8,12
8000450a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
8000450c:	98 38       	ld.sh	r8,r12[0x6]
8000450e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004510:	98 58       	ld.sh	r8,r12[0xa]
80004512:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004514:	98 48       	ld.sh	r8,r12[0x8]
80004516:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80004518:	98 68       	ld.sh	r8,r12[0xc]
8000451a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000451c:	30 08       	mov	r8,0
8000451e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004520:	1a 9c       	mov	r12,sp
80004522:	f0 1f 00 0a 	mcall	80004548 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80004526:	fa cd 00 cc 	sub	sp,sp,204
8000452a:	e0 6a 00 ca 	mov	r10,202
8000452e:	ee cb ff f0 	sub	r11,r7,-16
80004532:	1a 9c       	mov	r12,sp
80004534:	f0 1f 00 06 	mcall	8000454c <xnl_data_msg_func+0x58>
80004538:	48 68       	lddpc	r8,80004550 <xnl_data_msg_func+0x5c>
8000453a:	70 08       	ld.w	r8,r8[0x0]
8000453c:	5d 18       	icall	r8
8000453e:	fa cd ff 34 	sub	sp,sp,-204
}
80004542:	2c 0d       	sub	sp,-256
80004544:	e3 cd 80 80 	ldm	sp++,r7,pc
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	43 3c       	lddsp	r12,sp[0xcc]
8000454c:	80 00       	ld.sh	r0,r0[0x0]
8000454e:	69 30       	ld.w	r0,r4[0x4c]
80004550:	00 00       	add	r0,r0
80004552:	0b 54       	ld.sh	r4,--r5

80004554 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004554:	d4 21       	pushm	r4-r7,lr
80004556:	fa cd 01 00 	sub	sp,sp,256
8000455a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000455c:	4c 28       	lddpc	r8,80004664 <xnl_device_auth_reply_func+0x110>
8000455e:	11 88       	ld.ub	r8,r8[0x0]
80004560:	58 08       	cp.w	r8,0
80004562:	c7 e1       	brne	8000465e <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80004564:	4c 18       	lddpc	r8,80004668 <xnl_device_auth_reply_func+0x114>
80004566:	70 0c       	ld.w	r12,r8[0x0]
80004568:	30 09       	mov	r9,0
8000456a:	12 9a       	mov	r10,r9
8000456c:	12 9b       	mov	r11,r9
8000456e:	f0 1f 00 40 	mcall	8000466c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004572:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004576:	4b c8       	lddpc	r8,80004664 <xnl_device_auth_reply_func+0x110>
80004578:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000457a:	ef 39 00 12 	ld.ub	r9,r7[18]
8000457e:	ef 38 00 13 	ld.ub	r8,r7[19]
80004582:	b1 68       	lsl	r8,0x10
80004584:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004588:	ef 38 00 15 	ld.ub	r8,r7[21]
8000458c:	f3 e8 10 08 	or	r8,r9,r8
80004590:	ef 39 00 14 	ld.ub	r9,r7[20]
80004594:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004598:	ef 3a 00 16 	ld.ub	r10,r7[22]
8000459c:	ef 38 00 17 	ld.ub	r8,r7[23]
800045a0:	b1 68       	lsl	r8,0x10
800045a2:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800045a6:	ef 38 00 19 	ld.ub	r8,r7[25]
800045aa:	f5 e8 10 08 	or	r8,r10,r8
800045ae:	ef 3a 00 18 	ld.ub	r10,r7[24]
800045b2:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800045b6:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045b8:	e0 64 79 b9 	mov	r4,31161
800045bc:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045c0:	e0 65 45 07 	mov	r5,17671
800045c4:	ea 15 8a bd 	orh	r5,0x8abd
800045c8:	e0 66 f9 3d 	mov	r6,63805
800045cc:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045d0:	e0 6e b8 cf 	mov	lr,47311
800045d4:	ea 1e 36 83 	orh	lr,0x3683
800045d8:	e0 67 aa 1c 	mov	r7,43548
800045dc:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045e0:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045e2:	f4 08 00 0c 	add	r12,r10,r8
800045e6:	f0 0b 15 04 	lsl	r11,r8,0x4
800045ea:	0a 0b       	add	r11,r5
800045ec:	f9 eb 20 0b 	eor	r11,r12,r11
800045f0:	f0 0c 16 05 	lsr	r12,r8,0x5
800045f4:	0c 0c       	add	r12,r6
800045f6:	18 5b       	eor	r11,r12
800045f8:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045fa:	f2 0c 15 04 	lsl	r12,r9,0x4
800045fe:	1c 0c       	add	r12,lr
80004600:	f2 0b 16 05 	lsr	r11,r9,0x5
80004604:	0e 0b       	add	r11,r7
80004606:	f9 eb 20 0b 	eor	r11,r12,r11
8000460a:	f2 0a 00 0c 	add	r12,r9,r10
8000460e:	18 5b       	eor	r11,r12
80004610:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004612:	e0 6b 37 20 	mov	r11,14112
80004616:	ea 1b c6 ef 	orh	r11,0xc6ef
8000461a:	16 3a       	cp.w	r10,r11
8000461c:	ce 21       	brne	800045e0 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000461e:	e0 6a 40 1a 	mov	r10,16410
80004622:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004624:	3f fa       	mov	r10,-1
80004626:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004628:	30 6b       	mov	r11,6
8000462a:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000462c:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000462e:	48 eb       	lddpc	r11,80004664 <xnl_device_auth_reply_func+0x110>
80004630:	96 1c       	ld.sh	r12,r11[0x2]
80004632:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004634:	96 2b       	ld.sh	r11,r11[0x4]
80004636:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004638:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000463a:	30 ca       	mov	r10,12
8000463c:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
8000463e:	30 0a       	mov	r10,0
80004640:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004644:	30 7a       	mov	r10,7
80004646:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000464a:	30 2a       	mov	r10,2
8000464c:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004650:	fa ca ff ec 	sub	r10,sp,-20
80004654:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004656:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004658:	1a 9c       	mov	r12,sp
8000465a:	f0 1f 00 06 	mcall	80004670 <xnl_device_auth_reply_func+0x11c>
}
8000465e:	2c 0d       	sub	sp,-256
80004660:	d8 22       	popm	r4-r7,pc
80004662:	00 00       	add	r0,r0
80004664:	00 00       	add	r0,r0
80004666:	0b 3a       	ld.ub	r10,r5++
80004668:	00 00       	add	r0,r0
8000466a:	0b 34       	ld.ub	r4,r5++
8000466c:	80 00       	ld.sh	r0,r0[0x0]
8000466e:	54 40       	stdsp	sp[0x110],r0
80004670:	80 00       	ld.sh	r0,r0[0x0]
80004672:	43 3c       	lddsp	r12,sp[0xcc]

80004674 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004674:	eb cd 40 80 	pushm	r7,lr
80004678:	fa cd 01 00 	sub	sp,sp,256
8000467c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000467e:	49 28       	lddpc	r8,800046c4 <xnl_master_status_brdcst_func+0x50>
80004680:	11 88       	ld.ub	r8,r8[0x0]
80004682:	58 08       	cp.w	r8,0
80004684:	c1 c1       	brne	800046bc <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004686:	49 18       	lddpc	r8,800046c8 <xnl_master_status_brdcst_func+0x54>
80004688:	70 0c       	ld.w	r12,r8[0x0]
8000468a:	30 09       	mov	r9,0
8000468c:	12 9a       	mov	r10,r9
8000468e:	12 9b       	mov	r11,r9
80004690:	f0 1f 00 0f 	mcall	800046cc <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004694:	8e 58       	ld.sh	r8,r7[0xa]
80004696:	48 c9       	lddpc	r9,800046c4 <xnl_master_status_brdcst_func+0x50>
80004698:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000469a:	e0 68 40 0e 	mov	r8,16398
8000469e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046a0:	3f f8       	mov	r8,-1
800046a2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800046a4:	30 4a       	mov	r10,4
800046a6:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046a8:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046aa:	92 19       	ld.sh	r9,r9[0x2]
800046ac:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800046ae:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046b0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800046b2:	30 08       	mov	r8,0
800046b4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800046b6:	1a 9c       	mov	r12,sp
800046b8:	f0 1f 00 06 	mcall	800046d0 <xnl_master_status_brdcst_func+0x5c>
}
800046bc:	2c 0d       	sub	sp,-256
800046be:	e3 cd 80 80 	ldm	sp++,r7,pc
800046c2:	00 00       	add	r0,r0
800046c4:	00 00       	add	r0,r0
800046c6:	0b 3a       	ld.ub	r10,r5++
800046c8:	00 00       	add	r0,r0
800046ca:	0b 34       	ld.ub	r4,r5++
800046cc:	80 00       	ld.sh	r0,r0[0x0]
800046ce:	54 40       	stdsp	sp[0x110],r0
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	43 3c       	lddsp	r12,sp[0xcc]

800046d4 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800046d4:	eb cd 40 80 	pushm	r7,lr
800046d8:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800046da:	49 38       	lddpc	r8,80004724 <xnl_device_conn_reply_func+0x50>
800046dc:	70 0c       	ld.w	r12,r8[0x0]
800046de:	30 09       	mov	r9,0
800046e0:	12 9a       	mov	r10,r9
800046e2:	12 9b       	mov	r11,r9
800046e4:	f0 1f 00 11 	mcall	80004728 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800046e8:	ef 18 00 10 	ld.uh	r8,r7[16]
800046ec:	10 99       	mov	r9,r8
800046ee:	e2 19 ff 00 	andl	r9,0xff00,COH
800046f2:	e0 49 01 00 	cp.w	r9,256
800046f6:	c0 60       	breq	80004702 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800046f8:	0e 9c       	mov	r12,r7
800046fa:	f0 1f 00 0d 	mcall	8000472c <xnl_device_conn_reply_func+0x58>
800046fe:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004702:	a9 68       	lsl	r8,0x8
80004704:	48 b9       	lddpc	r9,80004730 <xnl_device_conn_reply_func+0x5c>
80004706:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004708:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
8000470c:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000470e:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004712:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004714:	30 18       	mov	r8,1
80004716:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80004718:	48 7c       	lddpc	r12,80004734 <xnl_device_conn_reply_func+0x60>
8000471a:	f0 1f 00 08 	mcall	80004738 <xnl_device_conn_reply_func+0x64>
8000471e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004722:	00 00       	add	r0,r0
80004724:	00 00       	add	r0,r0
80004726:	0b 34       	ld.ub	r4,r5++
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	54 40       	stdsp	sp[0x110],r0
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	46 74       	lddsp	r4,sp[0x19c]
80004730:	00 00       	add	r0,r0
80004732:	0b 3a       	ld.ub	r10,r5++
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	c7 f4       	brge	80004834 <_tc_interrupt+0xc>
80004738:	80 00       	ld.sh	r0,r0[0x0]
8000473a:	5f d8       	srvc	r8

8000473c <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
8000473c:	fe 78 0c 00 	mov	r8,-62464
80004740:	e0 69 03 07 	mov	r9,775
80004744:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004746:	30 49       	mov	r9,4
80004748:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000474a:	71 59       	ld.w	r9,r8[0x54]
8000474c:	e2 19 00 80 	andl	r9,0x80,COH
80004750:	cf d0       	breq	8000474a <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004752:	fe 78 0c 00 	mov	r8,-62464
80004756:	30 59       	mov	r9,5
80004758:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
8000475a:	e0 69 01 0d 	mov	r9,269
8000475e:	ea 19 10 07 	orh	r9,0x1007
80004762:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004764:	71 59       	ld.w	r9,r8[0x54]
80004766:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000476a:	cf d0       	breq	80004764 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
8000476c:	fe 78 0c 00 	mov	r8,-62464
80004770:	fc 19 00 80 	movh	r9,0x80
80004774:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004776:	34 0a       	mov	r10,64
80004778:	fe 69 14 00 	mov	r9,-125952
8000477c:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000477e:	30 69       	mov	r9,6
80004780:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004782:	30 19       	mov	r9,1
80004784:	fe 68 10 00 	mov	r8,-126976
80004788:	91 19       	st.w	r8[0x4],r9
}
8000478a:	5e fc       	retal	r12

8000478c <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
8000478c:	fe 78 10 00 	mov	r8,-61440
80004790:	fc 19 00 10 	movh	r9,0x10
80004794:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004796:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004798:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
8000479a:	30 39       	mov	r9,3
8000479c:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
800047a0:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800047a4:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800047a8:	fe 78 38 00 	mov	r8,-51200
800047ac:	30 49       	mov	r9,4
800047ae:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800047b2:	e0 69 91 0d 	mov	r9,37133
800047b6:	ea 19 00 52 	orh	r9,0x52
800047ba:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800047bc:	32 09       	mov	r9,32
800047be:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800047c0:	30 59       	mov	r9,5
800047c2:	91 09       	st.w	r8[0x0],r9
}
800047c4:	5e fc       	retal	r12
800047c6:	d7 03       	nop

800047c8 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
800047c8:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
800047ca:	30 2a       	mov	r10,2
800047cc:	e0 6b 01 c1 	mov	r11,449
800047d0:	48 ec       	lddpc	r12,80004808 <tc_init+0x40>
800047d2:	f0 1f 00 0f 	mcall	8000480c <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
800047d6:	48 fb       	lddpc	r11,80004810 <tc_init+0x48>
800047d8:	fe 7c 38 00 	mov	r12,-51200
800047dc:	f0 1f 00 0e 	mcall	80004814 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
800047e0:	e0 6a 75 30 	mov	r10,30000
800047e4:	30 1b       	mov	r11,1
800047e6:	fe 7c 38 00 	mov	r12,-51200
800047ea:	f0 1f 00 0c 	mcall	80004818 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
800047ee:	48 ca       	lddpc	r10,8000481c <tc_init+0x54>
800047f0:	30 1b       	mov	r11,1
800047f2:	fe 7c 38 00 	mov	r12,-51200
800047f6:	f0 1f 00 0b 	mcall	80004820 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
800047fa:	30 1b       	mov	r11,1
800047fc:	fe 7c 38 00 	mov	r12,-51200
80004800:	f0 1f 00 09 	mcall	80004824 <tc_init+0x5c>
80004804:	d8 02       	popm	pc
80004806:	00 00       	add	r0,r0
80004808:	80 00       	ld.sh	r0,r0[0x0]
8000480a:	48 28       	lddpc	r8,80004810 <tc_init+0x48>
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	48 4c       	lddpc	r12,8000481c <tc_init+0x54>
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	c8 0c       	rcall	80004912 <INTC_init_interrupts+0x46>
80004814:	80 00       	ld.sh	r0,r0[0x0]
80004816:	49 58       	lddpc	r8,80004868 <INTC_register_interrupt+0x1c>
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	4a 18       	lddpc	r8,8000489c <INTC_register_interrupt+0x50>
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	c8 08       	rjmp	8000491e <INTC_init_interrupts+0x52>
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	4a 4c       	lddpc	r12,800048b0 <INTC_register_interrupt+0x64>
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	49 f4       	lddpc	r4,800048a0 <INTC_register_interrupt+0x54>

80004828 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004828:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
8000482a:	48 68       	lddpc	r8,80004840 <_tc_interrupt+0x18>
8000482c:	70 09       	ld.w	r9,r8[0x0]
8000482e:	2f f9       	sub	r9,-1
80004830:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004832:	30 1b       	mov	r11,1
80004834:	fe 7c 38 00 	mov	r12,-51200
80004838:	f0 1f 00 03 	mcall	80004844 <_tc_interrupt+0x1c>
	
}
8000483c:	d4 02       	popm	lr
8000483e:	d6 03       	rete
80004840:	00 00       	add	r0,r0
80004842:	0b 58       	ld.sh	r8,--r5
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	4a 06       	lddpc	r6,800048c4 <INTC_register_interrupt+0x78>

80004848 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004848:	c0 08       	rjmp	80004848 <_unhandled_interrupt>
8000484a:	d7 03       	nop

8000484c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000484c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004850:	49 99       	lddpc	r9,800048b4 <INTC_register_interrupt+0x68>
80004852:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004856:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000485a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000485c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004860:	58 0a       	cp.w	r10,0
80004862:	c0 91       	brne	80004874 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004864:	49 59       	lddpc	r9,800048b8 <INTC_register_interrupt+0x6c>
80004866:	49 6a       	lddpc	r10,800048bc <INTC_register_interrupt+0x70>
80004868:	12 1a       	sub	r10,r9
8000486a:	fe 79 08 00 	mov	r9,-63488
8000486e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004872:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004874:	58 1a       	cp.w	r10,1
80004876:	c0 a1       	brne	8000488a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004878:	49 09       	lddpc	r9,800048b8 <INTC_register_interrupt+0x6c>
8000487a:	49 2a       	lddpc	r10,800048c0 <INTC_register_interrupt+0x74>
8000487c:	12 1a       	sub	r10,r9
8000487e:	bf aa       	sbr	r10,0x1e
80004880:	fe 79 08 00 	mov	r9,-63488
80004884:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004888:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000488a:	58 2a       	cp.w	r10,2
8000488c:	c0 a1       	brne	800048a0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000488e:	48 b9       	lddpc	r9,800048b8 <INTC_register_interrupt+0x6c>
80004890:	48 da       	lddpc	r10,800048c4 <INTC_register_interrupt+0x78>
80004892:	12 1a       	sub	r10,r9
80004894:	bf ba       	sbr	r10,0x1f
80004896:	fe 79 08 00 	mov	r9,-63488
8000489a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000489e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800048a0:	48 69       	lddpc	r9,800048b8 <INTC_register_interrupt+0x6c>
800048a2:	48 aa       	lddpc	r10,800048c8 <INTC_register_interrupt+0x7c>
800048a4:	12 1a       	sub	r10,r9
800048a6:	ea 1a c0 00 	orh	r10,0xc000
800048aa:	fe 79 08 00 	mov	r9,-63488
800048ae:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800048b2:	5e fc       	retal	r12
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	c8 14       	brge	800047b8 <local_start_timer+0x2c>
800048b8:	80 00       	ld.sh	r0,r0[0x0]
800048ba:	be 00       	st.h	pc[0x0],r0
800048bc:	80 00       	ld.sh	r0,r0[0x0]
800048be:	bf 04       	ld.d	r4,pc
800048c0:	80 00       	ld.sh	r0,r0[0x0]
800048c2:	bf 12       	ld.d	r2,--pc
800048c4:	80 00       	ld.sh	r0,r0[0x0]
800048c6:	bf 20       	st.d	pc++,r0
800048c8:	80 00       	ld.sh	r0,r0[0x0]
800048ca:	bf 2e       	st.d	pc++,lr

800048cc <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800048cc:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800048ce:	49 18       	lddpc	r8,80004910 <INTC_init_interrupts+0x44>
800048d0:	e3 b8 00 01 	mtsr	0x4,r8
800048d4:	49 0e       	lddpc	lr,80004914 <INTC_init_interrupts+0x48>
800048d6:	30 07       	mov	r7,0
800048d8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800048da:	49 0c       	lddpc	r12,80004918 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800048dc:	49 05       	lddpc	r5,8000491c <INTC_init_interrupts+0x50>
800048de:	10 15       	sub	r5,r8
800048e0:	fe 76 08 00 	mov	r6,-63488
800048e4:	c1 08       	rjmp	80004904 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800048e6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800048e8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800048ea:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800048ec:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800048f0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800048f2:	10 3a       	cp.w	r10,r8
800048f4:	fe 9b ff fc 	brhi	800048ec <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800048f8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800048fc:	2f f7       	sub	r7,-1
800048fe:	2f 8e       	sub	lr,-8
80004900:	59 37       	cp.w	r7,19
80004902:	c0 50       	breq	8000490c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004904:	7c 08       	ld.w	r8,lr[0x0]
80004906:	58 08       	cp.w	r8,0
80004908:	ce f1       	brne	800048e6 <INTC_init_interrupts+0x1a>
8000490a:	cf 7b       	rjmp	800048f8 <INTC_init_interrupts+0x2c>
8000490c:	d8 22       	popm	r4-r7,pc
8000490e:	00 00       	add	r0,r0
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	be 00       	st.h	pc[0x0],r0
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	c8 14       	brge	80004818 <tc_init+0x50>
80004918:	80 00       	ld.sh	r0,r0[0x0]
8000491a:	48 48       	lddpc	r8,80004928 <_get_interrupt_handler+0x8>
8000491c:	80 00       	ld.sh	r0,r0[0x0]
8000491e:	bf 04       	ld.d	r4,pc

80004920 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004920:	fe 78 08 00 	mov	r8,-63488
80004924:	e0 69 00 83 	mov	r9,131
80004928:	f2 0c 01 0c 	sub	r12,r9,r12
8000492c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004930:	f2 ca ff c0 	sub	r10,r9,-64
80004934:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004938:	58 08       	cp.w	r8,0
8000493a:	c0 21       	brne	8000493e <_get_interrupt_handler+0x1e>
8000493c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000493e:	f0 08 12 00 	clz	r8,r8
80004942:	48 5a       	lddpc	r10,80004954 <_get_interrupt_handler+0x34>
80004944:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004948:	f0 08 11 1f 	rsub	r8,r8,31
8000494c:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
8000494e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004952:	5e fc       	retal	r12
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	c8 14       	brge	80004858 <INTC_register_interrupt+0xc>

80004958 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004958:	76 09       	ld.w	r9,r11[0x0]
8000495a:	58 29       	cp.w	r9,2
8000495c:	e0 88 00 03 	brls	80004962 <tc_init_waveform+0xa>
80004960:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004962:	76 18       	ld.w	r8,r11[0x4]
80004964:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004968:	af ba       	sbr	r10,0xf
8000496a:	10 9b       	mov	r11,r8
8000496c:	e6 1b c0 00 	andh	r11,0xc000,COH
80004970:	16 4a       	or	r10,r11
80004972:	10 9b       	mov	r11,r8
80004974:	e6 1b 30 00 	andh	r11,0x3000,COH
80004978:	16 4a       	or	r10,r11
8000497a:	10 9b       	mov	r11,r8
8000497c:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004980:	16 4a       	or	r10,r11
80004982:	10 9b       	mov	r11,r8
80004984:	e6 1b 03 00 	andh	r11,0x300,COH
80004988:	16 4a       	or	r10,r11
8000498a:	10 9b       	mov	r11,r8
8000498c:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004990:	16 4a       	or	r10,r11
80004992:	10 9b       	mov	r11,r8
80004994:	e6 1b 00 30 	andh	r11,0x30,COH
80004998:	16 4a       	or	r10,r11
8000499a:	10 9b       	mov	r11,r8
8000499c:	e6 1b 00 0c 	andh	r11,0xc,COH
800049a0:	16 4a       	or	r10,r11
800049a2:	10 9b       	mov	r11,r8
800049a4:	e6 1b 00 03 	andh	r11,0x3,COH
800049a8:	16 4a       	or	r10,r11
800049aa:	10 9b       	mov	r11,r8
800049ac:	e2 1b 60 00 	andl	r11,0x6000,COH
800049b0:	16 4a       	or	r10,r11
800049b2:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
800049b6:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
800049ba:	10 9b       	mov	r11,r8
800049bc:	e2 1b 0c 00 	andl	r11,0xc00,COH
800049c0:	16 4a       	or	r10,r11
800049c2:	10 9b       	mov	r11,r8
800049c4:	e2 1b 03 00 	andl	r11,0x300,COH
800049c8:	16 4a       	or	r10,r11
800049ca:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
800049ce:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
800049d2:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
800049d6:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
800049da:	10 9b       	mov	r11,r8
800049dc:	e2 1b 00 30 	andl	r11,0x30,COH
800049e0:	16 4a       	or	r10,r11
800049e2:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800049e6:	f5 e8 10 38 	or	r8,r10,r8<<0x3
800049ea:	a5 69       	lsl	r9,0x4
800049ec:	2f f9       	sub	r9,-1
800049ee:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
800049f2:	5e fd       	retal	0

800049f4 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800049f4:	58 2b       	cp.w	r11,2
800049f6:	e0 88 00 03 	brls	800049fc <tc_start+0x8>
800049fa:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800049fc:	a7 6b       	lsl	r11,0x6
800049fe:	16 0c       	add	r12,r11
80004a00:	30 58       	mov	r8,5
80004a02:	99 08       	st.w	r12[0x0],r8
80004a04:	5e fd       	retal	0

80004a06 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a06:	58 2b       	cp.w	r11,2
80004a08:	e0 88 00 03 	brls	80004a0e <tc_read_sr+0x8>
80004a0c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004a0e:	a7 6b       	lsl	r11,0x6
80004a10:	2e 0b       	sub	r11,-32
80004a12:	16 0c       	add	r12,r11
80004a14:	78 0c       	ld.w	r12,r12[0x0]
}
80004a16:	5e fc       	retal	r12

80004a18 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a18:	58 2b       	cp.w	r11,2
80004a1a:	e0 88 00 03 	brls	80004a20 <tc_write_rc+0x8>
80004a1e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004a20:	f6 08 15 04 	lsl	r8,r11,0x4
80004a24:	2f f8       	sub	r8,-1
80004a26:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004a2a:	e2 18 80 00 	andl	r8,0x8000,COH
80004a2e:	c0 c0       	breq	80004a46 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004a30:	a7 6b       	lsl	r11,0x6
80004a32:	16 0c       	add	r12,r11
80004a34:	2e 4c       	sub	r12,-28
80004a36:	78 08       	ld.w	r8,r12[0x0]
80004a38:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004a3c:	e0 18 00 00 	andl	r8,0x0
80004a40:	f3 e8 10 08 	or	r8,r9,r8
80004a44:	99 08       	st.w	r12[0x0],r8

  return value;
80004a46:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004a4a:	5e fc       	retal	r12

80004a4c <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004a4c:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004a50:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004a54:	58 2b       	cp.w	r11,2
80004a56:	e0 88 00 04 	brls	80004a5e <tc_configure_interrupts+0x12>
80004a5a:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004a5e:	ee 19 00 01 	eorh	r9,0x1
80004a62:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004a66:	74 08       	ld.w	r8,r10[0x0]
80004a68:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004a6c:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004a70:	a7 6e       	lsl	lr,0x6
80004a72:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004a76:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004a7a:	0e 4e       	or	lr,r7
80004a7c:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004a80:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004a84:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004a88:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004a8c:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004a90:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004a94:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004a98:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004a9c:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004aa0:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004aa4:	f6 0e 15 06 	lsl	lr,r11,0x6
80004aa8:	f8 0e 00 0e 	add	lr,r12,lr
80004aac:	2d ce       	sub	lr,-36
80004aae:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004ab0:	58 09       	cp.w	r9,0
80004ab2:	c0 20       	breq	80004ab6 <tc_configure_interrupts+0x6a>
80004ab4:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004ab6:	74 08       	ld.w	r8,r10[0x0]
80004ab8:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004abc:	e0 65 00 80 	mov	r5,128
80004ac0:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004ac4:	74 08       	ld.w	r8,r10[0x0]
80004ac6:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004aca:	f9 b4 00 40 	moveq	r4,64
80004ace:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004ad2:	74 08       	ld.w	r8,r10[0x0]
80004ad4:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004ad8:	f9 b3 00 20 	moveq	r3,32
80004adc:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004ae0:	74 08       	ld.w	r8,r10[0x0]
80004ae2:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80004ae6:	f9 b2 00 10 	moveq	r2,16
80004aea:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004aee:	74 08       	ld.w	r8,r10[0x0]
80004af0:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004af4:	f9 b6 00 08 	moveq	r6,8
80004af8:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004afc:	74 08       	ld.w	r8,r10[0x0]
80004afe:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004b02:	f9 b7 00 04 	moveq	r7,4
80004b06:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004b0a:	74 08       	ld.w	r8,r10[0x0]
80004b0c:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004b10:	f9 be 00 02 	moveq	lr,2
80004b14:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004b18:	74 08       	ld.w	r8,r10[0x0]
80004b1a:	ec 18 00 01 	eorl	r8,0x1
80004b1e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004b22:	eb e8 10 08 	or	r8,r5,r8
80004b26:	08 48       	or	r8,r4
80004b28:	06 48       	or	r8,r3
80004b2a:	04 48       	or	r8,r2
80004b2c:	0c 48       	or	r8,r6
80004b2e:	0e 48       	or	r8,r7
80004b30:	1c 48       	or	r8,lr
80004b32:	f6 0a 15 06 	lsl	r10,r11,0x6
80004b36:	f8 0a 00 0a 	add	r10,r12,r10
80004b3a:	2d 8a       	sub	r10,-40
80004b3c:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004b3e:	a7 6b       	lsl	r11,0x6
80004b40:	2e 0b       	sub	r11,-32
80004b42:	16 0c       	add	r12,r11
80004b44:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004b46:	58 09       	cp.w	r9,0
80004b48:	c0 31       	brne	80004b4e <tc_configure_interrupts+0x102>
80004b4a:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004b4e:	d5 03       	csrf	0x10
80004b50:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004b54 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004b54:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004b56:	f6 08 15 04 	lsl	r8,r11,0x4
80004b5a:	14 38       	cp.w	r8,r10
80004b5c:	f9 b8 08 10 	movls	r8,16
80004b60:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004b64:	f0 0b 02 4b 	mul	r11,r8,r11
80004b68:	f6 09 16 01 	lsr	r9,r11,0x1
80004b6c:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004b70:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004b74:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004b78:	f2 cb 00 01 	sub	r11,r9,1
80004b7c:	e0 4b ff fe 	cp.w	r11,65534
80004b80:	e0 88 00 03 	brls	80004b86 <usart_set_async_baudrate+0x32>
80004b84:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004b86:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004b88:	e8 6e 00 00 	mov	lr,524288
80004b8c:	59 08       	cp.w	r8,16
80004b8e:	fc 08 17 10 	movne	r8,lr
80004b92:	f9 b8 00 00 	moveq	r8,0
80004b96:	e4 1b ff f7 	andh	r11,0xfff7
80004b9a:	e0 1b fe cf 	andl	r11,0xfecf
80004b9e:	16 48       	or	r8,r11
80004ba0:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004ba2:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004ba6:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004baa:	99 89       	st.w	r12[0x20],r9
80004bac:	d8 0a       	popm	pc,r12=0

80004bae <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004bae:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004bb0:	e2 18 00 02 	andl	r8,0x2,COH
80004bb4:	c0 31       	brne	80004bba <usart_write_char+0xc>
80004bb6:	30 2c       	mov	r12,2
80004bb8:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004bba:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004bbe:	99 7b       	st.w	r12[0x1c],r11
80004bc0:	5e fd       	retal	0
80004bc2:	d7 03       	nop

80004bc4 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004bc4:	eb cd 40 e0 	pushm	r5-r7,lr
80004bc8:	18 96       	mov	r6,r12
80004bca:	16 95       	mov	r5,r11
80004bcc:	e0 67 27 0f 	mov	r7,9999
80004bd0:	c0 68       	rjmp	80004bdc <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004bd2:	58 07       	cp.w	r7,0
80004bd4:	c0 31       	brne	80004bda <usart_putchar+0x16>
80004bd6:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004bda:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004bdc:	0a 9b       	mov	r11,r5
80004bde:	0c 9c       	mov	r12,r6
80004be0:	f0 1f 00 03 	mcall	80004bec <usart_putchar+0x28>
80004be4:	cf 71       	brne	80004bd2 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004be6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004bea:	00 00       	add	r0,r0
80004bec:	80 00       	ld.sh	r0,r0[0x0]
80004bee:	4b ae       	lddpc	lr,80004cd4 <usart_init_rs232+0x44>

80004bf0 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004bf0:	78 58       	ld.w	r8,r12[0x14]
80004bf2:	e2 18 00 e0 	andl	r8,0xe0,COH
80004bf6:	c0 30       	breq	80004bfc <usart_read_char+0xc>
80004bf8:	30 4c       	mov	r12,4
80004bfa:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004bfc:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004bfe:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004c02:	c0 31       	brne	80004c08 <usart_read_char+0x18>
80004c04:	30 3c       	mov	r12,3
80004c06:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004c08:	78 68       	ld.w	r8,r12[0x18]
80004c0a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004c0e:	97 08       	st.w	r11[0x0],r8
80004c10:	5e fd       	retal	0
80004c12:	d7 03       	nop

80004c14 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004c14:	eb cd 40 c0 	pushm	r6-r7,lr
80004c18:	20 1d       	sub	sp,4
80004c1a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004c1c:	1a 97       	mov	r7,sp
80004c1e:	1a 9b       	mov	r11,sp
80004c20:	0c 9c       	mov	r12,r6
80004c22:	f0 1f 00 07 	mcall	80004c3c <usart_getchar+0x28>
80004c26:	58 3c       	cp.w	r12,3
80004c28:	cf b0       	breq	80004c1e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004c2a:	58 4c       	cp.w	r12,4
80004c2c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004c30:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004c34:	2f fd       	sub	sp,-4
80004c36:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c3a:	00 00       	add	r0,r0
80004c3c:	80 00       	ld.sh	r0,r0[0x0]
80004c3e:	4b f0       	lddpc	r0,80004d38 <usart_init_rs232+0xa8>

80004c40 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004c40:	eb cd 40 c0 	pushm	r6-r7,lr
80004c44:	18 96       	mov	r6,r12
80004c46:	16 97       	mov	r7,r11
  while (*string != '\0')
80004c48:	17 8b       	ld.ub	r11,r11[0x0]
80004c4a:	58 0b       	cp.w	r11,0
80004c4c:	c0 80       	breq	80004c5c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004c4e:	2f f7       	sub	r7,-1
80004c50:	0c 9c       	mov	r12,r6
80004c52:	f0 1f 00 04 	mcall	80004c60 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004c56:	0f 8b       	ld.ub	r11,r7[0x0]
80004c58:	58 0b       	cp.w	r11,0
80004c5a:	cf a1       	brne	80004c4e <usart_write_line+0xe>
80004c5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	4b c4       	lddpc	r4,80004d50 <usart_init_rs232+0xc0>

80004c64 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004c64:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004c68:	e6 18 00 01 	andh	r8,0x1,COH
80004c6c:	c0 71       	brne	80004c7a <usart_reset+0x16>
80004c6e:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004c70:	3f f8       	mov	r8,-1
80004c72:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004c74:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004c76:	d5 03       	csrf	0x10
80004c78:	c0 48       	rjmp	80004c80 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004c7a:	3f f8       	mov	r8,-1
80004c7c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004c7e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004c80:	30 08       	mov	r8,0
80004c82:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004c84:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004c86:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004c88:	ea 68 61 0c 	mov	r8,680204
80004c8c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004c8e:	5e fc       	retal	r12

80004c90 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004c90:	eb cd 40 e0 	pushm	r5-r7,lr
80004c94:	18 96       	mov	r6,r12
80004c96:	16 97       	mov	r7,r11
80004c98:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004c9a:	f0 1f 00 2f 	mcall	80004d54 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004c9e:	58 07       	cp.w	r7,0
80004ca0:	c5 80       	breq	80004d50 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004ca2:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004ca4:	30 49       	mov	r9,4
80004ca6:	f2 08 18 00 	cp.b	r8,r9
80004caa:	e0 88 00 53 	brls	80004d50 <usart_init_rs232+0xc0>
80004cae:	30 99       	mov	r9,9
80004cb0:	f2 08 18 00 	cp.b	r8,r9
80004cb4:	e0 8b 00 4e 	brhi	80004d50 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004cb8:	0f d9       	ld.ub	r9,r7[0x5]
80004cba:	30 78       	mov	r8,7
80004cbc:	f0 09 18 00 	cp.b	r9,r8
80004cc0:	e0 8b 00 48 	brhi	80004d50 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004cc4:	8e 39       	ld.sh	r9,r7[0x6]
80004cc6:	e0 68 01 01 	mov	r8,257
80004cca:	f0 09 19 00 	cp.h	r9,r8
80004cce:	e0 8b 00 41 	brhi	80004d50 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004cd2:	ef 39 00 08 	ld.ub	r9,r7[8]
80004cd6:	30 38       	mov	r8,3
80004cd8:	f0 09 18 00 	cp.b	r9,r8
80004cdc:	e0 8b 00 3a 	brhi	80004d50 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004ce0:	0a 9a       	mov	r10,r5
80004ce2:	6e 0b       	ld.w	r11,r7[0x0]
80004ce4:	0c 9c       	mov	r12,r6
80004ce6:	f0 1f 00 1d 	mcall	80004d58 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004cea:	58 1c       	cp.w	r12,1
80004cec:	c3 20       	breq	80004d50 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004cee:	0f c8       	ld.ub	r8,r7[0x4]
80004cf0:	30 99       	mov	r9,9
80004cf2:	f2 08 18 00 	cp.b	r8,r9
80004cf6:	c0 51       	brne	80004d00 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004cf8:	6c 18       	ld.w	r8,r6[0x4]
80004cfa:	b1 b8       	sbr	r8,0x11
80004cfc:	8d 18       	st.w	r6[0x4],r8
80004cfe:	c0 68       	rjmp	80004d0a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004d00:	6c 19       	ld.w	r9,r6[0x4]
80004d02:	20 58       	sub	r8,5
80004d04:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004d08:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004d0a:	6c 19       	ld.w	r9,r6[0x4]
80004d0c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004d10:	0f d8       	ld.ub	r8,r7[0x5]
80004d12:	a9 78       	lsl	r8,0x9
80004d14:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004d18:	12 48       	or	r8,r9
80004d1a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004d1c:	8e 38       	ld.sh	r8,r7[0x6]
80004d1e:	30 29       	mov	r9,2
80004d20:	f2 08 19 00 	cp.h	r8,r9
80004d24:	e0 88 00 09 	brls	80004d36 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004d28:	6c 18       	ld.w	r8,r6[0x4]
80004d2a:	ad b8       	sbr	r8,0xd
80004d2c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004d2e:	8e b8       	ld.uh	r8,r7[0x6]
80004d30:	20 28       	sub	r8,2
80004d32:	8d a8       	st.w	r6[0x28],r8
80004d34:	c0 68       	rjmp	80004d40 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004d36:	6c 19       	ld.w	r9,r6[0x4]
80004d38:	5c 78       	castu.h	r8
80004d3a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004d3e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004d40:	6c 18       	ld.w	r8,r6[0x4]
80004d42:	e0 18 ff f0 	andl	r8,0xfff0
80004d46:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004d48:	35 08       	mov	r8,80
80004d4a:	8d 08       	st.w	r6[0x0],r8
80004d4c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004d50:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004d54:	80 00       	ld.sh	r0,r0[0x0]
80004d56:	4c 64       	lddpc	r4,80004e6c <pxPortInitialiseStack+0x80>
80004d58:	80 00       	ld.sh	r0,r0[0x0]
80004d5a:	4b 54       	lddpc	r4,80004e2c <pxPortInitialiseStack+0x40>

80004d5c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004d5c:	f8 c8 ff f8 	sub	r8,r12,-8
80004d60:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004d62:	3f f9       	mov	r9,-1
80004d64:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004d66:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004d68:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004d6a:	30 08       	mov	r8,0
80004d6c:	99 08       	st.w	r12[0x0],r8
}
80004d6e:	5e fc       	retal	r12

80004d70 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004d70:	30 08       	mov	r8,0
80004d72:	99 48       	st.w	r12[0x10],r8
}
80004d74:	5e fc       	retal	r12

80004d76 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004d76:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004d78:	70 19       	ld.w	r9,r8[0x4]
80004d7a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004d7c:	78 19       	ld.w	r9,r12[0x4]
80004d7e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004d80:	70 19       	ld.w	r9,r8[0x4]
80004d82:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004d84:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004d86:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004d88:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004d8a:	78 08       	ld.w	r8,r12[0x0]
80004d8c:	2f f8       	sub	r8,-1
80004d8e:	99 08       	st.w	r12[0x0],r8
}
80004d90:	5e fc       	retal	r12

80004d92 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004d92:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004d94:	5b fa       	cp.w	r10,-1
80004d96:	c0 31       	brne	80004d9c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004d98:	78 48       	ld.w	r8,r12[0x10]
80004d9a:	c0 c8       	rjmp	80004db2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004d9c:	f8 c8 ff f8 	sub	r8,r12,-8
80004da0:	70 19       	ld.w	r9,r8[0x4]
80004da2:	72 09       	ld.w	r9,r9[0x0]
80004da4:	12 3a       	cp.w	r10,r9
80004da6:	c0 63       	brcs	80004db2 <vListInsert+0x20>
80004da8:	70 18       	ld.w	r8,r8[0x4]
80004daa:	70 19       	ld.w	r9,r8[0x4]
80004dac:	72 09       	ld.w	r9,r9[0x0]
80004dae:	12 3a       	cp.w	r10,r9
80004db0:	cf c2       	brcc	80004da8 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004db2:	70 19       	ld.w	r9,r8[0x4]
80004db4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004db6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004db8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004dba:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004dbc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004dbe:	78 08       	ld.w	r8,r12[0x0]
80004dc0:	2f f8       	sub	r8,-1
80004dc2:	99 08       	st.w	r12[0x0],r8
}
80004dc4:	5e fc       	retal	r12

80004dc6 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004dc6:	78 18       	ld.w	r8,r12[0x4]
80004dc8:	78 29       	ld.w	r9,r12[0x8]
80004dca:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004dcc:	78 28       	ld.w	r8,r12[0x8]
80004dce:	78 19       	ld.w	r9,r12[0x4]
80004dd0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004dd2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004dd4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004dd6:	18 39       	cp.w	r9,r12
80004dd8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004ddc:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004de0:	30 09       	mov	r9,0
80004de2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004de4:	70 09       	ld.w	r9,r8[0x0]
80004de6:	20 19       	sub	r9,1
80004de8:	91 09       	st.w	r8[0x0],r9
}
80004dea:	5e fc       	retal	r12

80004dec <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004dec:	e0 68 08 08 	mov	r8,2056
80004df0:	ea 18 08 08 	orh	r8,0x808
80004df4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004df6:	e0 68 09 09 	mov	r8,2313
80004dfa:	ea 18 09 09 	orh	r8,0x909
80004dfe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004e00:	e0 68 0a 0a 	mov	r8,2570
80004e04:	ea 18 0a 0a 	orh	r8,0xa0a
80004e08:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004e0a:	e0 68 0b 0b 	mov	r8,2827
80004e0e:	ea 18 0b 0b 	orh	r8,0xb0b
80004e12:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004e14:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004e16:	e0 68 be ef 	mov	r8,48879
80004e1a:	ea 18 de ad 	orh	r8,0xdead
80004e1e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004e20:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004e22:	fc 18 00 40 	movh	r8,0x40
80004e26:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004e28:	e0 68 00 ff 	mov	r8,255
80004e2c:	ea 18 ff 00 	orh	r8,0xff00
80004e30:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004e32:	e0 68 01 01 	mov	r8,257
80004e36:	ea 18 01 01 	orh	r8,0x101
80004e3a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004e3c:	e0 68 02 02 	mov	r8,514
80004e40:	ea 18 02 02 	orh	r8,0x202
80004e44:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004e46:	e0 68 03 03 	mov	r8,771
80004e4a:	ea 18 03 03 	orh	r8,0x303
80004e4e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004e50:	e0 68 04 04 	mov	r8,1028
80004e54:	ea 18 04 04 	orh	r8,0x404
80004e58:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004e5a:	e0 68 05 05 	mov	r8,1285
80004e5e:	ea 18 05 05 	orh	r8,0x505
80004e62:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004e64:	e0 68 06 06 	mov	r8,1542
80004e68:	ea 18 06 06 	orh	r8,0x606
80004e6c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004e6e:	e0 68 07 07 	mov	r8,1799
80004e72:	ea 18 07 07 	orh	r8,0x707
80004e76:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004e78:	30 08       	mov	r8,0
80004e7a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004e7c:	5e fc       	retal	r12
80004e7e:	d7 03       	nop

80004e80 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004e80:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004e82:	48 38       	lddpc	r8,80004e8c <vPortEnterCritical+0xc>
80004e84:	70 09       	ld.w	r9,r8[0x0]
80004e86:	2f f9       	sub	r9,-1
80004e88:	91 09       	st.w	r8[0x0],r9
}
80004e8a:	5e fc       	retal	r12
80004e8c:	00 00       	add	r0,r0
80004e8e:	05 3c       	ld.ub	r12,r2++

80004e90 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004e90:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004e92:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004e94:	30 0a       	mov	r10,0
80004e96:	14 9b       	mov	r11,r10
80004e98:	49 2c       	lddpc	r12,80004ee0 <xPortStartScheduler+0x50>
80004e9a:	f0 1f 00 13 	mcall	80004ee4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004e9e:	e0 68 5d c0 	mov	r8,24000
80004ea2:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004ea6:	30 08       	mov	r8,0
80004ea8:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004eac:	e0 68 0c d4 	mov	r8,3284
80004eb0:	ea 18 00 00 	orh	r8,0x0
80004eb4:	70 00       	ld.w	r0,r8[0x0]
80004eb6:	60 0d       	ld.w	sp,r0[0x0]
80004eb8:	1b 00       	ld.w	r0,sp++
80004eba:	e0 68 05 3c 	mov	r8,1340
80004ebe:	ea 18 00 00 	orh	r8,0x0
80004ec2:	91 00       	st.w	r8[0x0],r0
80004ec4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004ec8:	2f ed       	sub	sp,-8
80004eca:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004ece:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004ed2:	e3 b0 00 00 	mtsr	0x0,r0
80004ed6:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004eda:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004ede:	d8 0a       	popm	pc,r12=0
80004ee0:	80 00       	ld.sh	r0,r0[0x0]
80004ee2:	4f ac       	lddpc	r12,800050c8 <vPortFree+0x4>
80004ee4:	80 00       	ld.sh	r0,r0[0x0]
80004ee6:	48 4c       	lddpc	r12,80004ef4 <SCALLYield+0xc>

80004ee8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004ee8:	20 6d       	sub	sp,24
80004eea:	eb cd 00 ff 	pushm	r0-r7
80004eee:	fa c7 ff c0 	sub	r7,sp,-64
80004ef2:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004ef6:	ef 40 ff e0 	st.w	r7[-32],r0
80004efa:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004efe:	ef 40 ff e4 	st.w	r7[-28],r0
80004f02:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004f06:	e0 68 05 3c 	mov	r8,1340
80004f0a:	ea 18 00 00 	orh	r8,0x0
80004f0e:	70 00       	ld.w	r0,r8[0x0]
80004f10:	1a d0       	st.w	--sp,r0
80004f12:	f0 1f 00 1a 	mcall	80004f78 <LABEL_RET_SCALL_263+0x14>
80004f16:	e0 68 0c d4 	mov	r8,3284
80004f1a:	ea 18 00 00 	orh	r8,0x0
80004f1e:	70 00       	ld.w	r0,r8[0x0]
80004f20:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004f22:	f0 1f 00 17 	mcall	80004f7c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004f26:	e0 68 0c d4 	mov	r8,3284
80004f2a:	ea 18 00 00 	orh	r8,0x0
80004f2e:	70 00       	ld.w	r0,r8[0x0]
80004f30:	60 0d       	ld.w	sp,r0[0x0]
80004f32:	1b 00       	ld.w	r0,sp++
80004f34:	e0 68 05 3c 	mov	r8,1340
80004f38:	ea 18 00 00 	orh	r8,0x0
80004f3c:	91 00       	st.w	r8[0x0],r0
80004f3e:	fa c7 ff d8 	sub	r7,sp,-40
80004f42:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004f46:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004f4a:	e0 61 05 3c 	mov	r1,1340
80004f4e:	ea 11 00 00 	orh	r1,0x0
80004f52:	62 02       	ld.w	r2,r1[0x0]
80004f54:	58 02       	cp.w	r2,0
80004f56:	c0 70       	breq	80004f64 <LABEL_RET_SCALL_263>
80004f58:	e4 c2 00 01 	sub	r2,r2,1
80004f5c:	83 02       	st.w	r1[0x0],r2
80004f5e:	58 02       	cp.w	r2,0
80004f60:	c0 21       	brne	80004f64 <LABEL_RET_SCALL_263>
80004f62:	b1 c0       	cbr	r0,0x10

80004f64 <LABEL_RET_SCALL_263>:
80004f64:	ef 40 ff f8 	st.w	r7[-8],r0
80004f68:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004f6c:	ef 40 ff fc 	st.w	r7[-4],r0
80004f70:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004f74:	2f ad       	sub	sp,-24
80004f76:	d6 13       	rets
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	4e 80       	lddpc	r0,80005118 <prvCopyDataFromQueue+0x4>
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	55 c4       	stdsp	sp[0x170],r4

80004f80 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004f80:	e1 b8 00 43 	mfsr	r8,0x10c
80004f84:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004f88:	5e fc       	retal	r12
80004f8a:	d7 03       	nop

80004f8c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004f8c:	48 78       	lddpc	r8,80004fa8 <vPortExitCritical+0x1c>
80004f8e:	70 08       	ld.w	r8,r8[0x0]
80004f90:	58 08       	cp.w	r8,0
80004f92:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004f94:	48 58       	lddpc	r8,80004fa8 <vPortExitCritical+0x1c>
80004f96:	70 09       	ld.w	r9,r8[0x0]
80004f98:	20 19       	sub	r9,1
80004f9a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004f9c:	70 08       	ld.w	r8,r8[0x0]
80004f9e:	58 08       	cp.w	r8,0
80004fa0:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004fa2:	d5 03       	csrf	0x10
80004fa4:	5e fc       	retal	r12
80004fa6:	00 00       	add	r0,r0
80004fa8:	00 00       	add	r0,r0
80004faa:	05 3c       	ld.ub	r12,r2++

80004fac <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004fac:	eb cd 00 ff 	pushm	r0-r7
80004fb0:	e0 68 05 3c 	mov	r8,1340
80004fb4:	ea 18 00 00 	orh	r8,0x0
80004fb8:	70 00       	ld.w	r0,r8[0x0]
80004fba:	1a d0       	st.w	--sp,r0
80004fbc:	7a 90       	ld.w	r0,sp[0x24]
80004fbe:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004fc2:	58 10       	cp.w	r0,1
80004fc4:	e0 8b 00 08 	brhi	80004fd4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80004fc8:	e0 68 0c d4 	mov	r8,3284
80004fcc:	ea 18 00 00 	orh	r8,0x0
80004fd0:	70 00       	ld.w	r0,r8[0x0]
80004fd2:	81 0d       	st.w	r0[0x0],sp

80004fd4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004fd4:	f0 1f 00 12 	mcall	8000501c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004fd8:	f0 1f 00 12 	mcall	80005020 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80004fdc:	f0 1f 00 12 	mcall	80005024 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80004fe0:	f0 1f 00 12 	mcall	80005028 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004fe4:	7a 90       	ld.w	r0,sp[0x24]
80004fe6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004fea:	58 10       	cp.w	r0,1
80004fec:	e0 8b 00 0e 	brhi	80005008 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80004ff0:	f0 1f 00 0c 	mcall	80005020 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80004ff4:	f0 1f 00 0e 	mcall	8000502c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80004ff8:	f0 1f 00 0c 	mcall	80005028 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004ffc:	e0 68 0c d4 	mov	r8,3284
80005000:	ea 18 00 00 	orh	r8,0x0
80005004:	70 00       	ld.w	r0,r8[0x0]
80005006:	60 0d       	ld.w	sp,r0[0x0]

80005008 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005008:	1b 00       	ld.w	r0,sp++
8000500a:	e0 68 05 3c 	mov	r8,1340
8000500e:	ea 18 00 00 	orh	r8,0x0
80005012:	91 00       	st.w	r8[0x0],r0
80005014:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005018:	d6 03       	rete
8000501a:	00 00       	add	r0,r0
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	4f 80       	lddpc	r0,800051fc <prvUnlockQueue+0x68>
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	4e 80       	lddpc	r0,800051c0 <prvUnlockQueue+0x2c>
80005024:	80 00       	ld.sh	r0,r0[0x0]
80005026:	57 c8       	stdsp	sp[0x1f0],r8
80005028:	80 00       	ld.sh	r0,r0[0x0]
8000502a:	4f 8c       	lddpc	r12,80005208 <prvUnlockQueue+0x74>
8000502c:	80 00       	ld.sh	r0,r0[0x0]
8000502e:	55 c4       	stdsp	sp[0x170],r4

80005030 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005030:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005032:	f0 1f 00 02 	mcall	80005038 <__malloc_lock+0x8>
}
80005036:	d8 02       	popm	pc
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	55 b4       	stdsp	sp[0x16c],r4

8000503c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000503c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000503e:	f0 1f 00 02 	mcall	80005044 <__malloc_unlock+0x8>
}
80005042:	d8 02       	popm	pc
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	59 70       	cp.w	r0,23

80005048 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005048:	d4 21       	pushm	r4-r7,lr
8000504a:	16 95       	mov	r5,r11
8000504c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000504e:	58 0c       	cp.w	r12,0
80005050:	c0 30       	breq	80005056 <_read+0xe>
80005052:	3f f7       	mov	r7,-1
80005054:	c1 48       	rjmp	8000507c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005056:	58 0a       	cp.w	r10,0
80005058:	e0 89 00 04 	brgt	80005060 <_read+0x18>
8000505c:	30 07       	mov	r7,0
8000505e:	c0 f8       	rjmp	8000507c <_read+0x34>
80005060:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005062:	48 84       	lddpc	r4,80005080 <_read+0x38>
80005064:	68 0c       	ld.w	r12,r4[0x0]
80005066:	f0 1f 00 08 	mcall	80005084 <_read+0x3c>
    if (c < 0)
8000506a:	c0 95       	brlt	8000507c <_read+0x34>
      break;

    *ptr++ = c;
8000506c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005070:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005072:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005076:	58 08       	cp.w	r8,0
80005078:	fe 99 ff f6 	brgt	80005064 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000507c:	0e 9c       	mov	r12,r7
8000507e:	d8 22       	popm	r4-r7,pc
80005080:	00 00       	add	r0,r0
80005082:	40 f4       	lddsp	r4,sp[0x3c]
80005084:	80 00       	ld.sh	r0,r0[0x0]
80005086:	4c 14       	lddpc	r4,80005188 <xQueueReceiveFromISR+0x44>

80005088 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005088:	d4 21       	pushm	r4-r7,lr
8000508a:	16 95       	mov	r5,r11
8000508c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000508e:	20 1c       	sub	r12,1
80005090:	58 2c       	cp.w	r12,2
80005092:	e0 8b 00 12 	brhi	800050b6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005096:	58 0a       	cp.w	r10,0
80005098:	c0 31       	brne	8000509e <_write+0x16>
8000509a:	30 07       	mov	r7,0
8000509c:	c0 e8       	rjmp	800050b8 <_write+0x30>
8000509e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800050a0:	48 74       	lddpc	r4,800050bc <_write+0x34>
800050a2:	68 0c       	ld.w	r12,r4[0x0]
800050a4:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800050a8:	f0 1f 00 06 	mcall	800050c0 <_write+0x38>
800050ac:	c0 55       	brlt	800050b6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800050ae:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800050b0:	0e 36       	cp.w	r6,r7
800050b2:	cf 81       	brne	800050a2 <_write+0x1a>
800050b4:	c0 28       	rjmp	800050b8 <_write+0x30>
800050b6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800050b8:	0e 9c       	mov	r12,r7
800050ba:	d8 22       	popm	r4-r7,pc
800050bc:	00 00       	add	r0,r0
800050be:	40 f4       	lddsp	r4,sp[0x3c]
800050c0:	80 00       	ld.sh	r0,r0[0x0]
800050c2:	4b c4       	lddpc	r4,800051b0 <prvUnlockQueue+0x1c>

800050c4 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800050c4:	eb cd 40 80 	pushm	r7,lr
800050c8:	18 97       	mov	r7,r12
	if( pv )
800050ca:	58 0c       	cp.w	r12,0
800050cc:	c0 80       	breq	800050dc <vPortFree+0x18>
	{
		vTaskSuspendAll();
800050ce:	f0 1f 00 05 	mcall	800050e0 <vPortFree+0x1c>
		{
			free( pv );
800050d2:	0e 9c       	mov	r12,r7
800050d4:	f0 1f 00 04 	mcall	800050e4 <vPortFree+0x20>
		}
		xTaskResumeAll();
800050d8:	f0 1f 00 04 	mcall	800050e8 <vPortFree+0x24>
800050dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	55 b4       	stdsp	sp[0x16c],r4
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	64 d8       	ld.w	r8,r2[0x34]
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	59 70       	cp.w	r0,23

800050ec <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800050ec:	eb cd 40 80 	pushm	r7,lr
800050f0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800050f2:	f0 1f 00 06 	mcall	80005108 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800050f6:	0e 9c       	mov	r12,r7
800050f8:	f0 1f 00 05 	mcall	8000510c <pvPortMalloc+0x20>
800050fc:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800050fe:	f0 1f 00 05 	mcall	80005110 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005102:	0e 9c       	mov	r12,r7
80005104:	e3 cd 80 80 	ldm	sp++,r7,pc
80005108:	80 00       	ld.sh	r0,r0[0x0]
8000510a:	55 b4       	stdsp	sp[0x16c],r4
8000510c:	80 00       	ld.sh	r0,r0[0x0]
8000510e:	64 e8       	ld.w	r8,r2[0x38]
80005110:	80 00       	ld.sh	r0,r0[0x0]
80005112:	59 70       	cp.w	r0,23

80005114 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005114:	d4 01       	pushm	lr
80005116:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005118:	78 09       	ld.w	r9,r12[0x0]
8000511a:	58 09       	cp.w	r9,0
8000511c:	c1 10       	breq	8000513e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000511e:	78 3a       	ld.w	r10,r12[0xc]
80005120:	79 09       	ld.w	r9,r12[0x40]
80005122:	f4 09 00 09 	add	r9,r10,r9
80005126:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005128:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000512a:	14 39       	cp.w	r9,r10
8000512c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005130:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005134:	79 0a       	ld.w	r10,r12[0x40]
80005136:	78 3b       	ld.w	r11,r12[0xc]
80005138:	10 9c       	mov	r12,r8
8000513a:	f0 1f 00 02 	mcall	80005140 <prvCopyDataFromQueue+0x2c>
8000513e:	d8 02       	popm	pc
80005140:	80 00       	ld.sh	r0,r0[0x0]
80005142:	69 30       	ld.w	r0,r4[0x4c]

80005144 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005144:	eb cd 40 c0 	pushm	r6-r7,lr
80005148:	18 97       	mov	r7,r12
8000514a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000514c:	78 e8       	ld.w	r8,r12[0x38]
8000514e:	58 08       	cp.w	r8,0
80005150:	c0 31       	brne	80005156 <xQueueReceiveFromISR+0x12>
80005152:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005156:	f0 1f 00 0e 	mcall	8000518c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000515a:	6e e8       	ld.w	r8,r7[0x38]
8000515c:	20 18       	sub	r8,1
8000515e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005160:	6f 18       	ld.w	r8,r7[0x44]
80005162:	5b f8       	cp.w	r8,-1
80005164:	c0 d1       	brne	8000517e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005166:	6e 48       	ld.w	r8,r7[0x10]
80005168:	58 08       	cp.w	r8,0
8000516a:	c0 f0       	breq	80005188 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000516c:	ee cc ff f0 	sub	r12,r7,-16
80005170:	f0 1f 00 08 	mcall	80005190 <xQueueReceiveFromISR+0x4c>
80005174:	c0 a0       	breq	80005188 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005176:	30 1c       	mov	r12,1
80005178:	8d 0c       	st.w	r6[0x0],r12
8000517a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000517e:	2f f8       	sub	r8,-1
80005180:	ef 48 00 44 	st.w	r7[68],r8
80005184:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005188:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000518c:	80 00       	ld.sh	r0,r0[0x0]
8000518e:	51 14       	stdsp	sp[0x44],r4
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	57 4c       	stdsp	sp[0x1d0],r12

80005194 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005194:	eb cd 40 c0 	pushm	r6-r7,lr
80005198:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000519a:	f0 1f 00 23 	mcall	80005224 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000519e:	6f 28       	ld.w	r8,r7[0x48]
800051a0:	58 08       	cp.w	r8,0
800051a2:	e0 8a 00 18 	brle	800051d2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800051a6:	6e 98       	ld.w	r8,r7[0x24]
800051a8:	58 08       	cp.w	r8,0
800051aa:	c1 40       	breq	800051d2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800051ac:	ee c6 ff dc 	sub	r6,r7,-36
800051b0:	c0 48       	rjmp	800051b8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800051b2:	6e 98       	ld.w	r8,r7[0x24]
800051b4:	58 08       	cp.w	r8,0
800051b6:	c0 e0       	breq	800051d2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800051b8:	0c 9c       	mov	r12,r6
800051ba:	f0 1f 00 1c 	mcall	80005228 <prvUnlockQueue+0x94>
800051be:	c0 30       	breq	800051c4 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
800051c0:	f0 1f 00 1b 	mcall	8000522c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
800051c4:	6f 28       	ld.w	r8,r7[0x48]
800051c6:	20 18       	sub	r8,1
800051c8:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800051cc:	58 08       	cp.w	r8,0
800051ce:	fe 99 ff f2 	brgt	800051b2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800051d2:	3f f8       	mov	r8,-1
800051d4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800051d8:	f0 1f 00 16 	mcall	80005230 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800051dc:	f0 1f 00 12 	mcall	80005224 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800051e0:	6f 18       	ld.w	r8,r7[0x44]
800051e2:	58 08       	cp.w	r8,0
800051e4:	e0 8a 00 18 	brle	80005214 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800051e8:	6e 48       	ld.w	r8,r7[0x10]
800051ea:	58 08       	cp.w	r8,0
800051ec:	c1 40       	breq	80005214 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800051ee:	ee c6 ff f0 	sub	r6,r7,-16
800051f2:	c0 48       	rjmp	800051fa <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800051f4:	6e 48       	ld.w	r8,r7[0x10]
800051f6:	58 08       	cp.w	r8,0
800051f8:	c0 e0       	breq	80005214 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800051fa:	0c 9c       	mov	r12,r6
800051fc:	f0 1f 00 0b 	mcall	80005228 <prvUnlockQueue+0x94>
80005200:	c0 30       	breq	80005206 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005202:	f0 1f 00 0b 	mcall	8000522c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005206:	6f 18       	ld.w	r8,r7[0x44]
80005208:	20 18       	sub	r8,1
8000520a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000520e:	58 08       	cp.w	r8,0
80005210:	fe 99 ff f2 	brgt	800051f4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005214:	3f f8       	mov	r8,-1
80005216:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000521a:	f0 1f 00 06 	mcall	80005230 <prvUnlockQueue+0x9c>
}
8000521e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005222:	00 00       	add	r0,r0
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	4e 80       	lddpc	r0,800053c4 <prvCopyDataToQueue+0x4c>
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	57 4c       	stdsp	sp[0x1d0],r12
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	56 58       	stdsp	sp[0x194],r8
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	4f 8c       	lddpc	r12,80005410 <xQueueGenericSendFromISR+0x20>

80005234 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005234:	d4 31       	pushm	r0-r7,lr
80005236:	20 5d       	sub	sp,20
80005238:	18 97       	mov	r7,r12
8000523a:	50 0b       	stdsp	sp[0x0],r11
8000523c:	50 2a       	stdsp	sp[0x8],r10
8000523e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005240:	f8 c2 ff dc 	sub	r2,r12,-36
80005244:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005246:	fa c4 ff f4 	sub	r4,sp,-12
8000524a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000524c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000524e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005252:	f0 1f 00 3e 	mcall	80005348 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005256:	6e e8       	ld.w	r8,r7[0x38]
80005258:	58 08       	cp.w	r8,0
8000525a:	c2 a0       	breq	800052ae <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000525c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000525e:	40 0b       	lddsp	r11,sp[0x0]
80005260:	0e 9c       	mov	r12,r7
80005262:	f0 1f 00 3b 	mcall	8000534c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80005266:	40 18       	lddsp	r8,sp[0x4]
80005268:	58 08       	cp.w	r8,0
8000526a:	c1 51       	brne	80005294 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000526c:	6e e8       	ld.w	r8,r7[0x38]
8000526e:	20 18       	sub	r8,1
80005270:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005272:	6e 08       	ld.w	r8,r7[0x0]
80005274:	58 08       	cp.w	r8,0
80005276:	c0 41       	brne	8000527e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80005278:	f0 1f 00 36 	mcall	80005350 <xQueueGenericReceive+0x11c>
8000527c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000527e:	6e 48       	ld.w	r8,r7[0x10]
80005280:	58 08       	cp.w	r8,0
80005282:	c1 20       	breq	800052a6 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80005284:	ee cc ff f0 	sub	r12,r7,-16
80005288:	f0 1f 00 33 	mcall	80005354 <xQueueGenericReceive+0x120>
8000528c:	58 1c       	cp.w	r12,1
8000528e:	c0 c1       	brne	800052a6 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005290:	d7 33       	scall
80005292:	c0 a8       	rjmp	800052a6 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005294:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005296:	6e 98       	ld.w	r8,r7[0x24]
80005298:	58 08       	cp.w	r8,0
8000529a:	c0 60       	breq	800052a6 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000529c:	04 9c       	mov	r12,r2
8000529e:	f0 1f 00 2e 	mcall	80005354 <xQueueGenericReceive+0x120>
800052a2:	c0 20       	breq	800052a6 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800052a4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800052a6:	f0 1f 00 2d 	mcall	80005358 <xQueueGenericReceive+0x124>
800052aa:	30 1c       	mov	r12,1
				return pdPASS;
800052ac:	c4 c8       	rjmp	80005344 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800052ae:	40 28       	lddsp	r8,sp[0x8]
800052b0:	58 08       	cp.w	r8,0
800052b2:	c0 51       	brne	800052bc <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800052b4:	f0 1f 00 29 	mcall	80005358 <xQueueGenericReceive+0x124>
800052b8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800052ba:	c4 58       	rjmp	80005344 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800052bc:	58 05       	cp.w	r5,0
800052be:	c0 51       	brne	800052c8 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800052c0:	08 9c       	mov	r12,r4
800052c2:	f0 1f 00 27 	mcall	8000535c <xQueueGenericReceive+0x128>
800052c6:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800052c8:	f0 1f 00 24 	mcall	80005358 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800052cc:	f0 1f 00 25 	mcall	80005360 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800052d0:	f0 1f 00 1e 	mcall	80005348 <xQueueGenericReceive+0x114>
800052d4:	6f 18       	ld.w	r8,r7[0x44]
800052d6:	5b f8       	cp.w	r8,-1
800052d8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800052dc:	6f 28       	ld.w	r8,r7[0x48]
800052de:	5b f8       	cp.w	r8,-1
800052e0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800052e4:	f0 1f 00 1d 	mcall	80005358 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800052e8:	06 9b       	mov	r11,r3
800052ea:	08 9c       	mov	r12,r4
800052ec:	f0 1f 00 1e 	mcall	80005364 <xQueueGenericReceive+0x130>
800052f0:	c2 41       	brne	80005338 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800052f2:	f0 1f 00 16 	mcall	80005348 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800052f6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800052f8:	f0 1f 00 18 	mcall	80005358 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800052fc:	58 06       	cp.w	r6,0
800052fe:	c1 71       	brne	8000532c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005300:	6e 08       	ld.w	r8,r7[0x0]
80005302:	58 08       	cp.w	r8,0
80005304:	c0 81       	brne	80005314 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005306:	f0 1f 00 11 	mcall	80005348 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000530a:	6e 1c       	ld.w	r12,r7[0x4]
8000530c:	f0 1f 00 17 	mcall	80005368 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005310:	f0 1f 00 12 	mcall	80005358 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005314:	40 2b       	lddsp	r11,sp[0x8]
80005316:	04 9c       	mov	r12,r2
80005318:	f0 1f 00 15 	mcall	8000536c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000531c:	0e 9c       	mov	r12,r7
8000531e:	f0 1f 00 15 	mcall	80005370 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005322:	f0 1f 00 15 	mcall	80005374 <xQueueGenericReceive+0x140>
80005326:	c9 61       	brne	80005252 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005328:	d7 33       	scall
8000532a:	c9 4b       	rjmp	80005252 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000532c:	0e 9c       	mov	r12,r7
8000532e:	f0 1f 00 11 	mcall	80005370 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005332:	f0 1f 00 11 	mcall	80005374 <xQueueGenericReceive+0x140>
80005336:	c8 eb       	rjmp	80005252 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005338:	0e 9c       	mov	r12,r7
8000533a:	f0 1f 00 0e 	mcall	80005370 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000533e:	f0 1f 00 0e 	mcall	80005374 <xQueueGenericReceive+0x140>
80005342:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005344:	2f bd       	sub	sp,-20
80005346:	d8 32       	popm	r0-r7,pc
80005348:	80 00       	ld.sh	r0,r0[0x0]
8000534a:	4e 80       	lddpc	r0,800054e8 <xQueueGenericSend+0xa8>
8000534c:	80 00       	ld.sh	r0,r0[0x0]
8000534e:	51 14       	stdsp	sp[0x44],r4
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	56 64       	stdsp	sp[0x198],r4
80005354:	80 00       	ld.sh	r0,r0[0x0]
80005356:	57 4c       	stdsp	sp[0x1d0],r12
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	4f 8c       	lddpc	r12,80005538 <xQueueGenericSend+0xf8>
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	56 40       	stdsp	sp[0x190],r0
80005360:	80 00       	ld.sh	r0,r0[0x0]
80005362:	55 b4       	stdsp	sp[0x16c],r4
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	58 dc       	cp.w	r12,13
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	56 c8       	stdsp	sp[0x1b0],r8
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	5b 34       	cp.w	r4,-13
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	51 94       	stdsp	sp[0x64],r4
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	59 70       	cp.w	r0,23

80005378 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005378:	eb cd 40 80 	pushm	r7,lr
8000537c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000537e:	79 08       	ld.w	r8,r12[0x40]
80005380:	58 08       	cp.w	r8,0
80005382:	c0 a1       	brne	80005396 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005384:	78 08       	ld.w	r8,r12[0x0]
80005386:	58 08       	cp.w	r8,0
80005388:	c2 b1       	brne	800053de <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000538a:	78 1c       	ld.w	r12,r12[0x4]
8000538c:	f0 1f 00 17 	mcall	800053e8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005390:	30 08       	mov	r8,0
80005392:	8f 18       	st.w	r7[0x4],r8
80005394:	c2 58       	rjmp	800053de <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005396:	58 0a       	cp.w	r10,0
80005398:	c1 01       	brne	800053b8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000539a:	10 9a       	mov	r10,r8
8000539c:	78 2c       	ld.w	r12,r12[0x8]
8000539e:	f0 1f 00 14 	mcall	800053ec <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800053a2:	6e 29       	ld.w	r9,r7[0x8]
800053a4:	6f 08       	ld.w	r8,r7[0x40]
800053a6:	f2 08 00 08 	add	r8,r9,r8
800053aa:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800053ac:	6e 19       	ld.w	r9,r7[0x4]
800053ae:	12 38       	cp.w	r8,r9
800053b0:	c1 73       	brcs	800053de <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800053b2:	6e 08       	ld.w	r8,r7[0x0]
800053b4:	8f 28       	st.w	r7[0x8],r8
800053b6:	c1 48       	rjmp	800053de <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800053b8:	10 9a       	mov	r10,r8
800053ba:	78 3c       	ld.w	r12,r12[0xc]
800053bc:	f0 1f 00 0c 	mcall	800053ec <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
800053c0:	6f 08       	ld.w	r8,r7[0x40]
800053c2:	6e 39       	ld.w	r9,r7[0xc]
800053c4:	f2 08 01 08 	sub	r8,r9,r8
800053c8:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800053ca:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800053cc:	12 38       	cp.w	r8,r9
800053ce:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800053d2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800053d6:	f3 d8 e3 19 	subcs	r9,r9,r8
800053da:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800053de:	6e e8       	ld.w	r8,r7[0x38]
800053e0:	2f f8       	sub	r8,-1
800053e2:	8f e8       	st.w	r7[0x38],r8
}
800053e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	56 70       	stdsp	sp[0x19c],r0
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	69 30       	ld.w	r0,r4[0x4c]

800053f0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800053f0:	eb cd 40 c0 	pushm	r6-r7,lr
800053f4:	18 97       	mov	r7,r12
800053f6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800053f8:	78 ec       	ld.w	r12,r12[0x38]
800053fa:	6e f8       	ld.w	r8,r7[0x3c]
800053fc:	10 3c       	cp.w	r12,r8
800053fe:	c0 33       	brcs	80005404 <xQueueGenericSendFromISR+0x14>
80005400:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005404:	12 9a       	mov	r10,r9
80005406:	0e 9c       	mov	r12,r7
80005408:	f0 1f 00 0c 	mcall	80005438 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000540c:	6f 28       	ld.w	r8,r7[0x48]
8000540e:	5b f8       	cp.w	r8,-1
80005410:	c0 d1       	brne	8000542a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005412:	6e 98       	ld.w	r8,r7[0x24]
80005414:	58 08       	cp.w	r8,0
80005416:	c0 f0       	breq	80005434 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005418:	ee cc ff dc 	sub	r12,r7,-36
8000541c:	f0 1f 00 08 	mcall	8000543c <xQueueGenericSendFromISR+0x4c>
80005420:	c0 a0       	breq	80005434 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005422:	30 1c       	mov	r12,1
80005424:	8d 0c       	st.w	r6[0x0],r12
80005426:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000542a:	2f f8       	sub	r8,-1
8000542c:	ef 48 00 48 	st.w	r7[72],r8
80005430:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005434:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005438:	80 00       	ld.sh	r0,r0[0x0]
8000543a:	53 78       	stdsp	sp[0xdc],r8
8000543c:	80 00       	ld.sh	r0,r0[0x0]
8000543e:	57 4c       	stdsp	sp[0x1d0],r12

80005440 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005440:	d4 31       	pushm	r0-r7,lr
80005442:	20 5d       	sub	sp,20
80005444:	18 97       	mov	r7,r12
80005446:	50 0b       	stdsp	sp[0x0],r11
80005448:	50 2a       	stdsp	sp[0x8],r10
8000544a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000544c:	f8 c0 ff f0 	sub	r0,r12,-16
80005450:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005452:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005456:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005458:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000545c:	f0 1f 00 2f 	mcall	80005518 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005460:	6e e9       	ld.w	r9,r7[0x38]
80005462:	6e f8       	ld.w	r8,r7[0x3c]
80005464:	10 39       	cp.w	r9,r8
80005466:	c1 42       	brcc	8000548e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005468:	40 1a       	lddsp	r10,sp[0x4]
8000546a:	40 0b       	lddsp	r11,sp[0x0]
8000546c:	0e 9c       	mov	r12,r7
8000546e:	f0 1f 00 2c 	mcall	8000551c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005472:	6e 98       	ld.w	r8,r7[0x24]
80005474:	58 08       	cp.w	r8,0
80005476:	c0 80       	breq	80005486 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005478:	ee cc ff dc 	sub	r12,r7,-36
8000547c:	f0 1f 00 29 	mcall	80005520 <xQueueGenericSend+0xe0>
80005480:	58 1c       	cp.w	r12,1
80005482:	c0 21       	brne	80005486 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005484:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005486:	f0 1f 00 28 	mcall	80005524 <xQueueGenericSend+0xe4>
8000548a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000548c:	c4 38       	rjmp	80005512 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000548e:	40 28       	lddsp	r8,sp[0x8]
80005490:	58 08       	cp.w	r8,0
80005492:	c0 51       	brne	8000549c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005494:	f0 1f 00 24 	mcall	80005524 <xQueueGenericSend+0xe4>
80005498:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000549a:	c3 c8       	rjmp	80005512 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000549c:	58 04       	cp.w	r4,0
8000549e:	c0 51       	brne	800054a8 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800054a0:	06 9c       	mov	r12,r3
800054a2:	f0 1f 00 22 	mcall	80005528 <xQueueGenericSend+0xe8>
800054a6:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800054a8:	f0 1f 00 1f 	mcall	80005524 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800054ac:	f0 1f 00 20 	mcall	8000552c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800054b0:	f0 1f 00 1a 	mcall	80005518 <xQueueGenericSend+0xd8>
800054b4:	6f 18       	ld.w	r8,r7[0x44]
800054b6:	5b f8       	cp.w	r8,-1
800054b8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800054bc:	6f 28       	ld.w	r8,r7[0x48]
800054be:	5b f8       	cp.w	r8,-1
800054c0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800054c4:	f0 1f 00 18 	mcall	80005524 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800054c8:	04 9b       	mov	r11,r2
800054ca:	06 9c       	mov	r12,r3
800054cc:	f0 1f 00 19 	mcall	80005530 <xQueueGenericSend+0xf0>
800054d0:	c1 b1       	brne	80005506 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800054d2:	f0 1f 00 12 	mcall	80005518 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800054d6:	6e e5       	ld.w	r5,r7[0x38]
800054d8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800054da:	f0 1f 00 13 	mcall	80005524 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800054de:	0c 35       	cp.w	r5,r6
800054e0:	c0 d1       	brne	800054fa <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800054e2:	40 2b       	lddsp	r11,sp[0x8]
800054e4:	00 9c       	mov	r12,r0
800054e6:	f0 1f 00 14 	mcall	80005534 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800054ea:	0e 9c       	mov	r12,r7
800054ec:	f0 1f 00 13 	mcall	80005538 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800054f0:	f0 1f 00 13 	mcall	8000553c <xQueueGenericSend+0xfc>
800054f4:	cb 41       	brne	8000545c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800054f6:	d7 33       	scall
800054f8:	cb 2b       	rjmp	8000545c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800054fa:	0e 9c       	mov	r12,r7
800054fc:	f0 1f 00 0f 	mcall	80005538 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005500:	f0 1f 00 0f 	mcall	8000553c <xQueueGenericSend+0xfc>
80005504:	ca cb       	rjmp	8000545c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005506:	0e 9c       	mov	r12,r7
80005508:	f0 1f 00 0c 	mcall	80005538 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000550c:	f0 1f 00 0c 	mcall	8000553c <xQueueGenericSend+0xfc>
80005510:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005512:	2f bd       	sub	sp,-20
80005514:	d8 32       	popm	r0-r7,pc
80005516:	00 00       	add	r0,r0
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	4e 80       	lddpc	r0,800056b8 <vTaskPriorityDisinherit+0x48>
8000551c:	80 00       	ld.sh	r0,r0[0x0]
8000551e:	53 78       	stdsp	sp[0xdc],r8
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	57 4c       	stdsp	sp[0x1d0],r12
80005524:	80 00       	ld.sh	r0,r0[0x0]
80005526:	4f 8c       	lddpc	r12,80005704 <vTaskPriorityInherit+0x3c>
80005528:	80 00       	ld.sh	r0,r0[0x0]
8000552a:	56 40       	stdsp	sp[0x190],r0
8000552c:	80 00       	ld.sh	r0,r0[0x0]
8000552e:	55 b4       	stdsp	sp[0x16c],r4
80005530:	80 00       	ld.sh	r0,r0[0x0]
80005532:	58 dc       	cp.w	r12,13
80005534:	80 00       	ld.sh	r0,r0[0x0]
80005536:	5b 34       	cp.w	r4,-13
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	51 94       	stdsp	sp[0x64],r4
8000553c:	80 00       	ld.sh	r0,r0[0x0]
8000553e:	59 70       	cp.w	r0,23

80005540 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005540:	d4 21       	pushm	r4-r7,lr
80005542:	18 97       	mov	r7,r12
80005544:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005546:	58 0c       	cp.w	r12,0
80005548:	c2 f0       	breq	800055a6 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000554a:	34 cc       	mov	r12,76
8000554c:	f0 1f 00 17 	mcall	800055a8 <xQueueCreate+0x68>
80005550:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005552:	c2 a0       	breq	800055a6 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005554:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005558:	e8 cc ff ff 	sub	r12,r4,-1
8000555c:	f0 1f 00 13 	mcall	800055a8 <xQueueCreate+0x68>
80005560:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005562:	c1 e0       	breq	8000559e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005564:	f8 04 00 04 	add	r4,r12,r4
80005568:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000556a:	30 08       	mov	r8,0
8000556c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000556e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005570:	ee c8 00 01 	sub	r8,r7,1
80005574:	ad 38       	mul	r8,r6
80005576:	10 0c       	add	r12,r8
80005578:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000557a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000557c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005580:	3f f8       	mov	r8,-1
80005582:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005586:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000558a:	ea cc ff f0 	sub	r12,r5,-16
8000558e:	f0 1f 00 08 	mcall	800055ac <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005592:	ea cc ff dc 	sub	r12,r5,-36
80005596:	f0 1f 00 06 	mcall	800055ac <xQueueCreate+0x6c>
8000559a:	0a 9c       	mov	r12,r5
8000559c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000559e:	0a 9c       	mov	r12,r5
800055a0:	f0 1f 00 04 	mcall	800055b0 <xQueueCreate+0x70>
800055a4:	d8 2a       	popm	r4-r7,pc,r12=0
800055a6:	d8 2a       	popm	r4-r7,pc,r12=0
800055a8:	80 00       	ld.sh	r0,r0[0x0]
800055aa:	50 ec       	stdsp	sp[0x38],r12
800055ac:	80 00       	ld.sh	r0,r0[0x0]
800055ae:	4d 5c       	lddpc	r12,80005700 <vTaskPriorityInherit+0x38>
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	50 c4       	stdsp	sp[0x30],r4

800055b4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800055b4:	48 38       	lddpc	r8,800055c0 <vTaskSuspendAll+0xc>
800055b6:	70 09       	ld.w	r9,r8[0x0]
800055b8:	2f f9       	sub	r9,-1
800055ba:	91 09       	st.w	r8[0x0],r9
}
800055bc:	5e fc       	retal	r12
800055be:	00 00       	add	r0,r0
800055c0:	00 00       	add	r0,r0
800055c2:	0d 04       	ld.w	r4,r6++

800055c4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800055c4:	49 a8       	lddpc	r8,8000562c <vTaskSwitchContext+0x68>
800055c6:	70 08       	ld.w	r8,r8[0x0]
800055c8:	58 08       	cp.w	r8,0
800055ca:	c0 b1       	brne	800055e0 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800055cc:	49 98       	lddpc	r8,80005630 <vTaskSwitchContext+0x6c>
800055ce:	70 08       	ld.w	r8,r8[0x0]
800055d0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800055d4:	49 89       	lddpc	r9,80005634 <vTaskSwitchContext+0x70>
800055d6:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800055da:	58 08       	cp.w	r8,0
800055dc:	c0 60       	breq	800055e8 <vTaskSwitchContext+0x24>
800055de:	c1 18       	rjmp	80005600 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800055e0:	30 19       	mov	r9,1
800055e2:	49 68       	lddpc	r8,80005638 <vTaskSwitchContext+0x74>
800055e4:	91 09       	st.w	r8[0x0],r9
800055e6:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800055e8:	49 28       	lddpc	r8,80005630 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800055ea:	49 3a       	lddpc	r10,80005634 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800055ec:	70 09       	ld.w	r9,r8[0x0]
800055ee:	20 19       	sub	r9,1
800055f0:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800055f2:	70 09       	ld.w	r9,r8[0x0]
800055f4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800055f8:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800055fc:	58 09       	cp.w	r9,0
800055fe:	cf 70       	breq	800055ec <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005600:	48 c8       	lddpc	r8,80005630 <vTaskSwitchContext+0x6c>
80005602:	70 08       	ld.w	r8,r8[0x0]
80005604:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005608:	48 b9       	lddpc	r9,80005634 <vTaskSwitchContext+0x70>
8000560a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000560e:	70 19       	ld.w	r9,r8[0x4]
80005610:	72 19       	ld.w	r9,r9[0x4]
80005612:	91 19       	st.w	r8[0x4],r9
80005614:	f0 ca ff f8 	sub	r10,r8,-8
80005618:	14 39       	cp.w	r9,r10
8000561a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000561e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005622:	70 18       	ld.w	r8,r8[0x4]
80005624:	70 39       	ld.w	r9,r8[0xc]
80005626:	48 68       	lddpc	r8,8000563c <vTaskSwitchContext+0x78>
80005628:	91 09       	st.w	r8[0x0],r9
8000562a:	5e fc       	retal	r12
8000562c:	00 00       	add	r0,r0
8000562e:	0d 04       	ld.w	r4,r6++
80005630:	00 00       	add	r0,r0
80005632:	0d 3c       	ld.ub	r12,r6++
80005634:	00 00       	add	r0,r0
80005636:	0c 20       	rsub	r0,r6
80005638:	00 00       	add	r0,r0
8000563a:	0d 24       	ld.uh	r4,r6++
8000563c:	00 00       	add	r0,r0
8000563e:	0c d4       	st.w	--r6,r4

80005640 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005640:	48 48       	lddpc	r8,80005650 <vTaskSetTimeOutState+0x10>
80005642:	70 08       	ld.w	r8,r8[0x0]
80005644:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005646:	48 48       	lddpc	r8,80005654 <vTaskSetTimeOutState+0x14>
80005648:	70 08       	ld.w	r8,r8[0x0]
8000564a:	99 18       	st.w	r12[0x4],r8
}
8000564c:	5e fc       	retal	r12
8000564e:	00 00       	add	r0,r0
80005650:	00 00       	add	r0,r0
80005652:	0c 18       	sub	r8,r6
80005654:	00 00       	add	r0,r0
80005656:	0d 00       	ld.w	r0,r6++

80005658 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005658:	30 19       	mov	r9,1
8000565a:	48 28       	lddpc	r8,80005660 <vTaskMissedYield+0x8>
8000565c:	91 09       	st.w	r8[0x0],r9
}
8000565e:	5e fc       	retal	r12
80005660:	00 00       	add	r0,r0
80005662:	0d 24       	ld.uh	r4,r6++

80005664 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005664:	48 28       	lddpc	r8,8000566c <xTaskGetCurrentTaskHandle+0x8>
80005666:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005668:	5e fc       	retal	r12
8000566a:	00 00       	add	r0,r0
8000566c:	00 00       	add	r0,r0
8000566e:	0c d4       	st.w	--r6,r4

80005670 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005670:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005674:	58 0c       	cp.w	r12,0
80005676:	c1 f0       	breq	800056b4 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005678:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000567a:	78 b9       	ld.w	r9,r12[0x2c]
8000567c:	79 18       	ld.w	r8,r12[0x44]
8000567e:	10 39       	cp.w	r9,r8
80005680:	c1 a0       	breq	800056b4 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005682:	f8 c6 ff fc 	sub	r6,r12,-4
80005686:	0c 9c       	mov	r12,r6
80005688:	f0 1f 00 0c 	mcall	800056b8 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000568c:	6f 1c       	ld.w	r12,r7[0x44]
8000568e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005690:	f8 08 11 08 	rsub	r8,r12,8
80005694:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005696:	48 a8       	lddpc	r8,800056bc <vTaskPriorityDisinherit+0x4c>
80005698:	70 08       	ld.w	r8,r8[0x0]
8000569a:	10 3c       	cp.w	r12,r8
8000569c:	e0 88 00 04 	brls	800056a4 <vTaskPriorityDisinherit+0x34>
800056a0:	48 78       	lddpc	r8,800056bc <vTaskPriorityDisinherit+0x4c>
800056a2:	91 0c       	st.w	r8[0x0],r12
800056a4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800056a8:	0c 9b       	mov	r11,r6
800056aa:	48 68       	lddpc	r8,800056c0 <vTaskPriorityDisinherit+0x50>
800056ac:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800056b0:	f0 1f 00 05 	mcall	800056c4 <vTaskPriorityDisinherit+0x54>
800056b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056b8:	80 00       	ld.sh	r0,r0[0x0]
800056ba:	4d c6       	lddpc	r6,80005828 <vTaskIncrementTick+0x60>
800056bc:	00 00       	add	r0,r0
800056be:	0d 3c       	ld.ub	r12,r6++
800056c0:	00 00       	add	r0,r0
800056c2:	0c 20       	rsub	r0,r6
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	4d 76       	lddpc	r6,80005820 <vTaskIncrementTick+0x58>

800056c8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800056c8:	eb cd 40 c0 	pushm	r6-r7,lr
800056cc:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800056ce:	49 b8       	lddpc	r8,80005738 <vTaskPriorityInherit+0x70>
800056d0:	70 08       	ld.w	r8,r8[0x0]
800056d2:	78 b9       	ld.w	r9,r12[0x2c]
800056d4:	70 b8       	ld.w	r8,r8[0x2c]
800056d6:	10 39       	cp.w	r9,r8
800056d8:	c2 d2       	brcc	80005732 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800056da:	49 88       	lddpc	r8,80005738 <vTaskPriorityInherit+0x70>
800056dc:	70 08       	ld.w	r8,r8[0x0]
800056de:	70 b8       	ld.w	r8,r8[0x2c]
800056e0:	f0 08 11 08 	rsub	r8,r8,8
800056e4:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800056e6:	f2 09 00 28 	add	r8,r9,r9<<0x2
800056ea:	49 59       	lddpc	r9,8000573c <vTaskPriorityInherit+0x74>
800056ec:	f2 08 00 28 	add	r8,r9,r8<<0x2
800056f0:	78 59       	ld.w	r9,r12[0x14]
800056f2:	10 39       	cp.w	r9,r8
800056f4:	c1 b1       	brne	8000572a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800056f6:	f8 c6 ff fc 	sub	r6,r12,-4
800056fa:	0c 9c       	mov	r12,r6
800056fc:	f0 1f 00 11 	mcall	80005740 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005700:	48 e8       	lddpc	r8,80005738 <vTaskPriorityInherit+0x70>
80005702:	70 08       	ld.w	r8,r8[0x0]
80005704:	70 bc       	ld.w	r12,r8[0x2c]
80005706:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005708:	48 f8       	lddpc	r8,80005744 <vTaskPriorityInherit+0x7c>
8000570a:	70 08       	ld.w	r8,r8[0x0]
8000570c:	10 3c       	cp.w	r12,r8
8000570e:	e0 88 00 04 	brls	80005716 <vTaskPriorityInherit+0x4e>
80005712:	48 d8       	lddpc	r8,80005744 <vTaskPriorityInherit+0x7c>
80005714:	91 0c       	st.w	r8[0x0],r12
80005716:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000571a:	0c 9b       	mov	r11,r6
8000571c:	48 88       	lddpc	r8,8000573c <vTaskPriorityInherit+0x74>
8000571e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005722:	f0 1f 00 0a 	mcall	80005748 <vTaskPriorityInherit+0x80>
80005726:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000572a:	48 48       	lddpc	r8,80005738 <vTaskPriorityInherit+0x70>
8000572c:	70 08       	ld.w	r8,r8[0x0]
8000572e:	70 b8       	ld.w	r8,r8[0x2c]
80005730:	99 b8       	st.w	r12[0x2c],r8
80005732:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005736:	00 00       	add	r0,r0
80005738:	00 00       	add	r0,r0
8000573a:	0c d4       	st.w	--r6,r4
8000573c:	00 00       	add	r0,r0
8000573e:	0c 20       	rsub	r0,r6
80005740:	80 00       	ld.sh	r0,r0[0x0]
80005742:	4d c6       	lddpc	r6,800058b0 <vTaskIncrementTick+0xe8>
80005744:	00 00       	add	r0,r0
80005746:	0d 3c       	ld.ub	r12,r6++
80005748:	80 00       	ld.sh	r0,r0[0x0]
8000574a:	4d 76       	lddpc	r6,800058a4 <vTaskIncrementTick+0xdc>

8000574c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000574c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005750:	78 38       	ld.w	r8,r12[0xc]
80005752:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005754:	ee c6 ff e8 	sub	r6,r7,-24
80005758:	0c 9c       	mov	r12,r6
8000575a:	f0 1f 00 15 	mcall	800057ac <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000575e:	49 58       	lddpc	r8,800057b0 <xTaskRemoveFromEventList+0x64>
80005760:	70 08       	ld.w	r8,r8[0x0]
80005762:	58 08       	cp.w	r8,0
80005764:	c1 71       	brne	80005792 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005766:	ee c6 ff fc 	sub	r6,r7,-4
8000576a:	0c 9c       	mov	r12,r6
8000576c:	f0 1f 00 10 	mcall	800057ac <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005770:	6e bc       	ld.w	r12,r7[0x2c]
80005772:	49 18       	lddpc	r8,800057b4 <xTaskRemoveFromEventList+0x68>
80005774:	70 08       	ld.w	r8,r8[0x0]
80005776:	10 3c       	cp.w	r12,r8
80005778:	e0 88 00 04 	brls	80005780 <xTaskRemoveFromEventList+0x34>
8000577c:	48 e8       	lddpc	r8,800057b4 <xTaskRemoveFromEventList+0x68>
8000577e:	91 0c       	st.w	r8[0x0],r12
80005780:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005784:	0c 9b       	mov	r11,r6
80005786:	48 d8       	lddpc	r8,800057b8 <xTaskRemoveFromEventList+0x6c>
80005788:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000578c:	f0 1f 00 0c 	mcall	800057bc <xTaskRemoveFromEventList+0x70>
80005790:	c0 58       	rjmp	8000579a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005792:	0c 9b       	mov	r11,r6
80005794:	48 bc       	lddpc	r12,800057c0 <xTaskRemoveFromEventList+0x74>
80005796:	f0 1f 00 0a 	mcall	800057bc <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000579a:	48 b8       	lddpc	r8,800057c4 <xTaskRemoveFromEventList+0x78>
8000579c:	70 08       	ld.w	r8,r8[0x0]
8000579e:	6e b9       	ld.w	r9,r7[0x2c]
800057a0:	70 b8       	ld.w	r8,r8[0x2c]
800057a2:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800057a4:	5f 2c       	srhs	r12
800057a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057aa:	00 00       	add	r0,r0
800057ac:	80 00       	ld.sh	r0,r0[0x0]
800057ae:	4d c6       	lddpc	r6,8000591c <xTaskCheckForTimeOut+0x40>
800057b0:	00 00       	add	r0,r0
800057b2:	0d 04       	ld.w	r4,r6++
800057b4:	00 00       	add	r0,r0
800057b6:	0d 3c       	ld.ub	r12,r6++
800057b8:	00 00       	add	r0,r0
800057ba:	0c 20       	rsub	r0,r6
800057bc:	80 00       	ld.sh	r0,r0[0x0]
800057be:	4d 76       	lddpc	r6,80005918 <xTaskCheckForTimeOut+0x3c>
800057c0:	00 00       	add	r0,r0
800057c2:	0c d8       	st.w	--r6,r8
800057c4:	00 00       	add	r0,r0
800057c6:	0c d4       	st.w	--r6,r4

800057c8 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800057c8:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800057cc:	4b 98       	lddpc	r8,800058b0 <vTaskIncrementTick+0xe8>
800057ce:	70 08       	ld.w	r8,r8[0x0]
800057d0:	58 08       	cp.w	r8,0
800057d2:	c6 91       	brne	800058a4 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800057d4:	4b 88       	lddpc	r8,800058b4 <vTaskIncrementTick+0xec>
800057d6:	70 09       	ld.w	r9,r8[0x0]
800057d8:	2f f9       	sub	r9,-1
800057da:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800057dc:	70 08       	ld.w	r8,r8[0x0]
800057de:	58 08       	cp.w	r8,0
800057e0:	c1 a1       	brne	80005814 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800057e2:	4b 68       	lddpc	r8,800058b8 <vTaskIncrementTick+0xf0>
800057e4:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800057e6:	4b 69       	lddpc	r9,800058bc <vTaskIncrementTick+0xf4>
800057e8:	72 0b       	ld.w	r11,r9[0x0]
800057ea:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800057ec:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800057ee:	4b 59       	lddpc	r9,800058c0 <vTaskIncrementTick+0xf8>
800057f0:	72 0a       	ld.w	r10,r9[0x0]
800057f2:	2f fa       	sub	r10,-1
800057f4:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800057f6:	70 08       	ld.w	r8,r8[0x0]
800057f8:	70 08       	ld.w	r8,r8[0x0]
800057fa:	58 08       	cp.w	r8,0
800057fc:	c0 51       	brne	80005806 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800057fe:	3f f9       	mov	r9,-1
80005800:	4b 18       	lddpc	r8,800058c4 <vTaskIncrementTick+0xfc>
80005802:	91 09       	st.w	r8[0x0],r9
80005804:	c0 88       	rjmp	80005814 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005806:	4a d8       	lddpc	r8,800058b8 <vTaskIncrementTick+0xf0>
80005808:	70 08       	ld.w	r8,r8[0x0]
8000580a:	70 38       	ld.w	r8,r8[0xc]
8000580c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000580e:	70 19       	ld.w	r9,r8[0x4]
80005810:	4a d8       	lddpc	r8,800058c4 <vTaskIncrementTick+0xfc>
80005812:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005814:	4a 88       	lddpc	r8,800058b4 <vTaskIncrementTick+0xec>
80005816:	70 09       	ld.w	r9,r8[0x0]
80005818:	4a b8       	lddpc	r8,800058c4 <vTaskIncrementTick+0xfc>
8000581a:	70 08       	ld.w	r8,r8[0x0]
8000581c:	10 39       	cp.w	r9,r8
8000581e:	c4 73       	brcs	800058ac <vTaskIncrementTick+0xe4>
80005820:	4a 68       	lddpc	r8,800058b8 <vTaskIncrementTick+0xf0>
80005822:	70 08       	ld.w	r8,r8[0x0]
80005824:	70 08       	ld.w	r8,r8[0x0]
80005826:	58 08       	cp.w	r8,0
80005828:	c0 c0       	breq	80005840 <vTaskIncrementTick+0x78>
8000582a:	4a 48       	lddpc	r8,800058b8 <vTaskIncrementTick+0xf0>
8000582c:	70 08       	ld.w	r8,r8[0x0]
8000582e:	70 38       	ld.w	r8,r8[0xc]
80005830:	70 37       	ld.w	r7,r8[0xc]
80005832:	6e 18       	ld.w	r8,r7[0x4]
80005834:	4a 09       	lddpc	r9,800058b4 <vTaskIncrementTick+0xec>
80005836:	72 09       	ld.w	r9,r9[0x0]
80005838:	12 38       	cp.w	r8,r9
8000583a:	e0 88 00 14 	brls	80005862 <vTaskIncrementTick+0x9a>
8000583e:	c0 e8       	rjmp	8000585a <vTaskIncrementTick+0x92>
80005840:	3f f9       	mov	r9,-1
80005842:	4a 18       	lddpc	r8,800058c4 <vTaskIncrementTick+0xfc>
80005844:	91 09       	st.w	r8[0x0],r9
80005846:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000584a:	6a 08       	ld.w	r8,r5[0x0]
8000584c:	70 38       	ld.w	r8,r8[0xc]
8000584e:	70 37       	ld.w	r7,r8[0xc]
80005850:	6e 18       	ld.w	r8,r7[0x4]
80005852:	64 09       	ld.w	r9,r2[0x0]
80005854:	12 38       	cp.w	r8,r9
80005856:	e0 88 00 0a 	brls	8000586a <vTaskIncrementTick+0xa2>
8000585a:	49 b9       	lddpc	r9,800058c4 <vTaskIncrementTick+0xfc>
8000585c:	93 08       	st.w	r9[0x0],r8
8000585e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005862:	49 a4       	lddpc	r4,800058c8 <vTaskIncrementTick+0x100>
80005864:	49 a3       	lddpc	r3,800058cc <vTaskIncrementTick+0x104>
80005866:	49 55       	lddpc	r5,800058b8 <vTaskIncrementTick+0xf0>
80005868:	49 32       	lddpc	r2,800058b4 <vTaskIncrementTick+0xec>
8000586a:	ee c6 ff fc 	sub	r6,r7,-4
8000586e:	0c 9c       	mov	r12,r6
80005870:	f0 1f 00 18 	mcall	800058d0 <vTaskIncrementTick+0x108>
80005874:	6e a8       	ld.w	r8,r7[0x28]
80005876:	58 08       	cp.w	r8,0
80005878:	c0 50       	breq	80005882 <vTaskIncrementTick+0xba>
8000587a:	ee cc ff e8 	sub	r12,r7,-24
8000587e:	f0 1f 00 15 	mcall	800058d0 <vTaskIncrementTick+0x108>
80005882:	6e bc       	ld.w	r12,r7[0x2c]
80005884:	68 08       	ld.w	r8,r4[0x0]
80005886:	10 3c       	cp.w	r12,r8
80005888:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000588c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005890:	0c 9b       	mov	r11,r6
80005892:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005896:	f0 1f 00 10 	mcall	800058d4 <vTaskIncrementTick+0x10c>
8000589a:	6a 08       	ld.w	r8,r5[0x0]
8000589c:	70 08       	ld.w	r8,r8[0x0]
8000589e:	58 08       	cp.w	r8,0
800058a0:	cd 51       	brne	8000584a <vTaskIncrementTick+0x82>
800058a2:	cc fb       	rjmp	80005840 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800058a4:	48 d8       	lddpc	r8,800058d8 <vTaskIncrementTick+0x110>
800058a6:	70 09       	ld.w	r9,r8[0x0]
800058a8:	2f f9       	sub	r9,-1
800058aa:	91 09       	st.w	r8[0x0],r9
800058ac:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800058b0:	00 00       	add	r0,r0
800058b2:	0d 04       	ld.w	r4,r6++
800058b4:	00 00       	add	r0,r0
800058b6:	0d 00       	ld.w	r0,r6++
800058b8:	00 00       	add	r0,r0
800058ba:	0c 0c       	add	r12,r6
800058bc:	00 00       	add	r0,r0
800058be:	0c 1c       	sub	r12,r6
800058c0:	00 00       	add	r0,r0
800058c2:	0c 18       	sub	r8,r6
800058c4:	00 00       	add	r0,r0
800058c6:	05 40       	ld.w	r0,--r2
800058c8:	00 00       	add	r0,r0
800058ca:	0d 3c       	ld.ub	r12,r6++
800058cc:	00 00       	add	r0,r0
800058ce:	0c 20       	rsub	r0,r6
800058d0:	80 00       	ld.sh	r0,r0[0x0]
800058d2:	4d c6       	lddpc	r6,80005a40 <xTaskResumeAll+0xd0>
800058d4:	80 00       	ld.sh	r0,r0[0x0]
800058d6:	4d 76       	lddpc	r6,80005a30 <xTaskResumeAll+0xc0>
800058d8:	00 00       	add	r0,r0
800058da:	0c 04       	add	r4,r6

800058dc <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800058dc:	eb cd 40 c0 	pushm	r6-r7,lr
800058e0:	18 97       	mov	r7,r12
800058e2:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800058e4:	f0 1f 00 15 	mcall	80005938 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800058e8:	6c 08       	ld.w	r8,r6[0x0]
800058ea:	5b f8       	cp.w	r8,-1
800058ec:	c0 31       	brne	800058f2 <xTaskCheckForTimeOut+0x16>
800058ee:	30 07       	mov	r7,0
800058f0:	c1 f8       	rjmp	8000592e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800058f2:	49 39       	lddpc	r9,8000593c <xTaskCheckForTimeOut+0x60>
800058f4:	72 09       	ld.w	r9,r9[0x0]
800058f6:	6e 0a       	ld.w	r10,r7[0x0]
800058f8:	12 3a       	cp.w	r10,r9
800058fa:	c0 70       	breq	80005908 <xTaskCheckForTimeOut+0x2c>
800058fc:	49 19       	lddpc	r9,80005940 <xTaskCheckForTimeOut+0x64>
800058fe:	72 09       	ld.w	r9,r9[0x0]
80005900:	6e 1a       	ld.w	r10,r7[0x4]
80005902:	12 3a       	cp.w	r10,r9
80005904:	e0 88 00 14 	brls	8000592c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005908:	48 e9       	lddpc	r9,80005940 <xTaskCheckForTimeOut+0x64>
8000590a:	72 0a       	ld.w	r10,r9[0x0]
8000590c:	6e 19       	ld.w	r9,r7[0x4]
8000590e:	12 1a       	sub	r10,r9
80005910:	14 38       	cp.w	r8,r10
80005912:	e0 88 00 0d 	brls	8000592c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005916:	48 ba       	lddpc	r10,80005940 <xTaskCheckForTimeOut+0x64>
80005918:	74 0a       	ld.w	r10,r10[0x0]
8000591a:	14 19       	sub	r9,r10
8000591c:	f2 08 00 08 	add	r8,r9,r8
80005920:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005922:	0e 9c       	mov	r12,r7
80005924:	f0 1f 00 08 	mcall	80005944 <xTaskCheckForTimeOut+0x68>
80005928:	30 07       	mov	r7,0
8000592a:	c0 28       	rjmp	8000592e <xTaskCheckForTimeOut+0x52>
8000592c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000592e:	f0 1f 00 07 	mcall	80005948 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005932:	0e 9c       	mov	r12,r7
80005934:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005938:	80 00       	ld.sh	r0,r0[0x0]
8000593a:	4e 80       	lddpc	r0,80005ad8 <vTaskDelayUntil+0x24>
8000593c:	00 00       	add	r0,r0
8000593e:	0c 18       	sub	r8,r6
80005940:	00 00       	add	r0,r0
80005942:	0d 00       	ld.w	r0,r6++
80005944:	80 00       	ld.sh	r0,r0[0x0]
80005946:	56 40       	stdsp	sp[0x190],r0
80005948:	80 00       	ld.sh	r0,r0[0x0]
8000594a:	4f 8c       	lddpc	r12,80005b28 <vTaskDelayUntil+0x74>

8000594c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
8000594c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005950:	f0 1f 00 05 	mcall	80005964 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005954:	48 58       	lddpc	r8,80005968 <xTaskGetTickCount+0x1c>
80005956:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005958:	f0 1f 00 05 	mcall	8000596c <xTaskGetTickCount+0x20>

	return xTicks;
}
8000595c:	0e 9c       	mov	r12,r7
8000595e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005962:	00 00       	add	r0,r0
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	4e 80       	lddpc	r0,80005b04 <vTaskDelayUntil+0x50>
80005968:	00 00       	add	r0,r0
8000596a:	0d 00       	ld.w	r0,r6++
8000596c:	80 00       	ld.sh	r0,r0[0x0]
8000596e:	4f 8c       	lddpc	r12,80005b4c <vTaskPlaceOnEventList+0x18>

80005970 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005970:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005974:	f0 1f 00 2c 	mcall	80005a24 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005978:	4a c8       	lddpc	r8,80005a28 <xTaskResumeAll+0xb8>
8000597a:	70 09       	ld.w	r9,r8[0x0]
8000597c:	20 19       	sub	r9,1
8000597e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005980:	70 08       	ld.w	r8,r8[0x0]
80005982:	58 08       	cp.w	r8,0
80005984:	c4 91       	brne	80005a16 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005986:	4a a8       	lddpc	r8,80005a2c <xTaskResumeAll+0xbc>
80005988:	70 08       	ld.w	r8,r8[0x0]
8000598a:	58 08       	cp.w	r8,0
8000598c:	c4 50       	breq	80005a16 <xTaskResumeAll+0xa6>
8000598e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005990:	4a 85       	lddpc	r5,80005a30 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005992:	4a 93       	lddpc	r3,80005a34 <xTaskResumeAll+0xc4>
80005994:	4a 92       	lddpc	r2,80005a38 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005996:	4a a1       	lddpc	r1,80005a3c <xTaskResumeAll+0xcc>
80005998:	c1 e8       	rjmp	800059d4 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000599a:	6a 38       	ld.w	r8,r5[0xc]
8000599c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000599e:	ee cc ff e8 	sub	r12,r7,-24
800059a2:	f0 1f 00 28 	mcall	80005a40 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800059a6:	ee c6 ff fc 	sub	r6,r7,-4
800059aa:	0c 9c       	mov	r12,r6
800059ac:	f0 1f 00 25 	mcall	80005a40 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800059b0:	6e bc       	ld.w	r12,r7[0x2c]
800059b2:	66 08       	ld.w	r8,r3[0x0]
800059b4:	10 3c       	cp.w	r12,r8
800059b6:	e7 fc ba 00 	st.whi	r3[0x0],r12
800059ba:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800059be:	0c 9b       	mov	r11,r6
800059c0:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800059c4:	f0 1f 00 20 	mcall	80005a44 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800059c8:	62 08       	ld.w	r8,r1[0x0]
800059ca:	6e b9       	ld.w	r9,r7[0x2c]
800059cc:	70 b8       	ld.w	r8,r8[0x2c]
800059ce:	10 39       	cp.w	r9,r8
800059d0:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800059d4:	6a 08       	ld.w	r8,r5[0x0]
800059d6:	58 08       	cp.w	r8,0
800059d8:	ce 11       	brne	8000599a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800059da:	49 c8       	lddpc	r8,80005a48 <xTaskResumeAll+0xd8>
800059dc:	70 08       	ld.w	r8,r8[0x0]
800059de:	58 08       	cp.w	r8,0
800059e0:	c0 f0       	breq	800059fe <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800059e2:	49 a8       	lddpc	r8,80005a48 <xTaskResumeAll+0xd8>
800059e4:	70 08       	ld.w	r8,r8[0x0]
800059e6:	58 08       	cp.w	r8,0
800059e8:	c1 10       	breq	80005a0a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800059ea:	49 87       	lddpc	r7,80005a48 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800059ec:	f0 1f 00 18 	mcall	80005a4c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800059f0:	6e 08       	ld.w	r8,r7[0x0]
800059f2:	20 18       	sub	r8,1
800059f4:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800059f6:	6e 08       	ld.w	r8,r7[0x0]
800059f8:	58 08       	cp.w	r8,0
800059fa:	cf 91       	brne	800059ec <xTaskResumeAll+0x7c>
800059fc:	c0 78       	rjmp	80005a0a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800059fe:	58 14       	cp.w	r4,1
80005a00:	c0 50       	breq	80005a0a <xTaskResumeAll+0x9a>
80005a02:	49 48       	lddpc	r8,80005a50 <xTaskResumeAll+0xe0>
80005a04:	70 08       	ld.w	r8,r8[0x0]
80005a06:	58 18       	cp.w	r8,1
80005a08:	c0 71       	brne	80005a16 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005a0a:	30 09       	mov	r9,0
80005a0c:	49 18       	lddpc	r8,80005a50 <xTaskResumeAll+0xe0>
80005a0e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005a10:	d7 33       	scall
80005a12:	30 17       	mov	r7,1
80005a14:	c0 28       	rjmp	80005a18 <xTaskResumeAll+0xa8>
80005a16:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005a18:	f0 1f 00 0f 	mcall	80005a54 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005a1c:	0e 9c       	mov	r12,r7
80005a1e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005a22:	00 00       	add	r0,r0
80005a24:	80 00       	ld.sh	r0,r0[0x0]
80005a26:	4e 80       	lddpc	r0,80005bc4 <prvIdleTask+0x38>
80005a28:	00 00       	add	r0,r0
80005a2a:	0d 04       	ld.w	r4,r6++
80005a2c:	00 00       	add	r0,r0
80005a2e:	0d 20       	ld.uh	r0,r6++
80005a30:	00 00       	add	r0,r0
80005a32:	0c d8       	st.w	--r6,r8
80005a34:	00 00       	add	r0,r0
80005a36:	0d 3c       	ld.ub	r12,r6++
80005a38:	00 00       	add	r0,r0
80005a3a:	0c 20       	rsub	r0,r6
80005a3c:	00 00       	add	r0,r0
80005a3e:	0c d4       	st.w	--r6,r4
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	4d c6       	lddpc	r6,80005bb0 <prvIdleTask+0x24>
80005a44:	80 00       	ld.sh	r0,r0[0x0]
80005a46:	4d 76       	lddpc	r6,80005ba0 <prvIdleTask+0x14>
80005a48:	00 00       	add	r0,r0
80005a4a:	0c 04       	add	r4,r6
80005a4c:	80 00       	ld.sh	r0,r0[0x0]
80005a4e:	57 c8       	stdsp	sp[0x1f0],r8
80005a50:	00 00       	add	r0,r0
80005a52:	0d 24       	ld.uh	r4,r6++
80005a54:	80 00       	ld.sh	r0,r0[0x0]
80005a56:	4f 8c       	lddpc	r12,80005c34 <xTaskGenericCreate+0x20>

80005a58 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005a58:	eb cd 40 80 	pushm	r7,lr
80005a5c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005a5e:	49 08       	lddpc	r8,80005a9c <prvAddCurrentTaskToDelayedList+0x44>
80005a60:	70 08       	ld.w	r8,r8[0x0]
80005a62:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005a64:	48 f8       	lddpc	r8,80005aa0 <prvAddCurrentTaskToDelayedList+0x48>
80005a66:	70 08       	ld.w	r8,r8[0x0]
80005a68:	10 3c       	cp.w	r12,r8
80005a6a:	c0 a2       	brcc	80005a7e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005a6c:	48 c8       	lddpc	r8,80005a9c <prvAddCurrentTaskToDelayedList+0x44>
80005a6e:	70 0b       	ld.w	r11,r8[0x0]
80005a70:	48 d8       	lddpc	r8,80005aa4 <prvAddCurrentTaskToDelayedList+0x4c>
80005a72:	70 0c       	ld.w	r12,r8[0x0]
80005a74:	2f cb       	sub	r11,-4
80005a76:	f0 1f 00 0d 	mcall	80005aa8 <prvAddCurrentTaskToDelayedList+0x50>
80005a7a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005a7e:	48 88       	lddpc	r8,80005a9c <prvAddCurrentTaskToDelayedList+0x44>
80005a80:	70 0b       	ld.w	r11,r8[0x0]
80005a82:	48 b8       	lddpc	r8,80005aac <prvAddCurrentTaskToDelayedList+0x54>
80005a84:	70 0c       	ld.w	r12,r8[0x0]
80005a86:	2f cb       	sub	r11,-4
80005a88:	f0 1f 00 08 	mcall	80005aa8 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005a8c:	48 98       	lddpc	r8,80005ab0 <prvAddCurrentTaskToDelayedList+0x58>
80005a8e:	70 08       	ld.w	r8,r8[0x0]
80005a90:	10 37       	cp.w	r7,r8
80005a92:	c0 32       	brcc	80005a98 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005a94:	48 78       	lddpc	r8,80005ab0 <prvAddCurrentTaskToDelayedList+0x58>
80005a96:	91 07       	st.w	r8[0x0],r7
80005a98:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a9c:	00 00       	add	r0,r0
80005a9e:	0c d4       	st.w	--r6,r4
80005aa0:	00 00       	add	r0,r0
80005aa2:	0d 00       	ld.w	r0,r6++
80005aa4:	00 00       	add	r0,r0
80005aa6:	0c 1c       	sub	r12,r6
80005aa8:	80 00       	ld.sh	r0,r0[0x0]
80005aaa:	4d 92       	lddpc	r2,80005c0c <prvIdleTask+0x80>
80005aac:	00 00       	add	r0,r0
80005aae:	0c 0c       	add	r12,r6
80005ab0:	00 00       	add	r0,r0
80005ab2:	05 40       	ld.w	r0,--r2

80005ab4 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005ab4:	eb cd 40 c0 	pushm	r6-r7,lr
80005ab8:	18 96       	mov	r6,r12
80005aba:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005abc:	f0 1f 00 18 	mcall	80005b1c <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005ac0:	6c 08       	ld.w	r8,r6[0x0]
80005ac2:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005ac4:	49 79       	lddpc	r9,80005b20 <vTaskDelayUntil+0x6c>
80005ac6:	72 09       	ld.w	r9,r9[0x0]
80005ac8:	12 38       	cp.w	r8,r9
80005aca:	e0 88 00 0c 	brls	80005ae2 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005ace:	0e 38       	cp.w	r8,r7
80005ad0:	e0 88 00 22 	brls	80005b14 <vTaskDelayUntil+0x60>
80005ad4:	49 38       	lddpc	r8,80005b20 <vTaskDelayUntil+0x6c>
80005ad6:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005ad8:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005ada:	10 37       	cp.w	r7,r8
80005adc:	e0 88 00 14 	brls	80005b04 <vTaskDelayUntil+0x50>
80005ae0:	c0 a8       	rjmp	80005af4 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005ae2:	0e 38       	cp.w	r8,r7
80005ae4:	e0 8b 00 16 	brhi	80005b10 <vTaskDelayUntil+0x5c>
80005ae8:	48 e8       	lddpc	r8,80005b20 <vTaskDelayUntil+0x6c>
80005aea:	70 08       	ld.w	r8,r8[0x0]
80005aec:	10 37       	cp.w	r7,r8
80005aee:	e0 8b 00 11 	brhi	80005b10 <vTaskDelayUntil+0x5c>
80005af2:	c1 18       	rjmp	80005b14 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005af4:	48 c8       	lddpc	r8,80005b24 <vTaskDelayUntil+0x70>
80005af6:	70 0c       	ld.w	r12,r8[0x0]
80005af8:	2f cc       	sub	r12,-4
80005afa:	f0 1f 00 0c 	mcall	80005b28 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005afe:	0e 9c       	mov	r12,r7
80005b00:	f0 1f 00 0b 	mcall	80005b2c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005b04:	f0 1f 00 0b 	mcall	80005b30 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005b08:	c0 81       	brne	80005b18 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005b0a:	d7 33       	scall
80005b0c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005b10:	8d 07       	st.w	r6[0x0],r7
80005b12:	cf 1b       	rjmp	80005af4 <vTaskDelayUntil+0x40>
80005b14:	8d 07       	st.w	r6[0x0],r7
80005b16:	cf 7b       	rjmp	80005b04 <vTaskDelayUntil+0x50>
80005b18:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b1c:	80 00       	ld.sh	r0,r0[0x0]
80005b1e:	55 b4       	stdsp	sp[0x16c],r4
80005b20:	00 00       	add	r0,r0
80005b22:	0d 00       	ld.w	r0,r6++
80005b24:	00 00       	add	r0,r0
80005b26:	0c d4       	st.w	--r6,r4
80005b28:	80 00       	ld.sh	r0,r0[0x0]
80005b2a:	4d c6       	lddpc	r6,80005c98 <xTaskGenericCreate+0x84>
80005b2c:	80 00       	ld.sh	r0,r0[0x0]
80005b2e:	5a 58       	cp.w	r8,-27
80005b30:	80 00       	ld.sh	r0,r0[0x0]
80005b32:	59 70       	cp.w	r0,23

80005b34 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005b34:	eb cd 40 c0 	pushm	r6-r7,lr
80005b38:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005b3a:	48 e7       	lddpc	r7,80005b70 <vTaskPlaceOnEventList+0x3c>
80005b3c:	6e 0b       	ld.w	r11,r7[0x0]
80005b3e:	2e 8b       	sub	r11,-24
80005b40:	f0 1f 00 0d 	mcall	80005b74 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005b44:	6e 0c       	ld.w	r12,r7[0x0]
80005b46:	2f cc       	sub	r12,-4
80005b48:	f0 1f 00 0c 	mcall	80005b78 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005b4c:	5b f6       	cp.w	r6,-1
80005b4e:	c0 81       	brne	80005b5e <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005b50:	6e 0b       	ld.w	r11,r7[0x0]
80005b52:	2f cb       	sub	r11,-4
80005b54:	48 ac       	lddpc	r12,80005b7c <vTaskPlaceOnEventList+0x48>
80005b56:	f0 1f 00 0b 	mcall	80005b80 <vTaskPlaceOnEventList+0x4c>
80005b5a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005b5e:	48 a8       	lddpc	r8,80005b84 <vTaskPlaceOnEventList+0x50>
80005b60:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005b62:	ec 0c 00 0c 	add	r12,r6,r12
80005b66:	f0 1f 00 09 	mcall	80005b88 <vTaskPlaceOnEventList+0x54>
80005b6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b6e:	00 00       	add	r0,r0
80005b70:	00 00       	add	r0,r0
80005b72:	0c d4       	st.w	--r6,r4
80005b74:	80 00       	ld.sh	r0,r0[0x0]
80005b76:	4d 92       	lddpc	r2,80005cd8 <xTaskGenericCreate+0xc4>
80005b78:	80 00       	ld.sh	r0,r0[0x0]
80005b7a:	4d c6       	lddpc	r6,80005ce8 <xTaskGenericCreate+0xd4>
80005b7c:	00 00       	add	r0,r0
80005b7e:	0d 28       	ld.uh	r8,r6++
80005b80:	80 00       	ld.sh	r0,r0[0x0]
80005b82:	4d 76       	lddpc	r6,80005cdc <xTaskGenericCreate+0xc8>
80005b84:	00 00       	add	r0,r0
80005b86:	0d 00       	ld.w	r0,r6++
80005b88:	80 00       	ld.sh	r0,r0[0x0]
80005b8a:	5a 58       	cp.w	r8,-27

80005b8c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005b8c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005b90:	49 67       	lddpc	r7,80005be8 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005b92:	49 74       	lddpc	r4,80005bec <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005b94:	49 73       	lddpc	r3,80005bf0 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005b96:	49 85       	lddpc	r5,80005bf4 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005b98:	6e 08       	ld.w	r8,r7[0x0]
80005b9a:	58 08       	cp.w	r8,0
80005b9c:	c1 e0       	breq	80005bd8 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005b9e:	f0 1f 00 17 	mcall	80005bf8 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005ba2:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005ba4:	f0 1f 00 16 	mcall	80005bfc <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005ba8:	58 06       	cp.w	r6,0
80005baa:	c1 70       	breq	80005bd8 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005bac:	f0 1f 00 15 	mcall	80005c00 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005bb0:	68 38       	ld.w	r8,r4[0xc]
80005bb2:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005bb4:	ec cc ff fc 	sub	r12,r6,-4
80005bb8:	f0 1f 00 13 	mcall	80005c04 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005bbc:	66 08       	ld.w	r8,r3[0x0]
80005bbe:	20 18       	sub	r8,1
80005bc0:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005bc2:	6e 08       	ld.w	r8,r7[0x0]
80005bc4:	20 18       	sub	r8,1
80005bc6:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005bc8:	f0 1f 00 10 	mcall	80005c08 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005bcc:	6c cc       	ld.w	r12,r6[0x30]
80005bce:	f0 1f 00 10 	mcall	80005c0c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005bd2:	0c 9c       	mov	r12,r6
80005bd4:	f0 1f 00 0e 	mcall	80005c0c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005bd8:	6a 08       	ld.w	r8,r5[0x0]
80005bda:	58 18       	cp.w	r8,1
80005bdc:	e0 88 00 03 	brls	80005be2 <prvIdleTask+0x56>
			{
				taskYIELD();
80005be0:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005be2:	f0 1f 00 0c 	mcall	80005c10 <prvIdleTask+0x84>
		}
		#endif
	}
80005be6:	cd 9b       	rjmp	80005b98 <prvIdleTask+0xc>
80005be8:	00 00       	add	r0,r0
80005bea:	0c 14       	sub	r4,r6
80005bec:	00 00       	add	r0,r0
80005bee:	0c c0       	st.b	r6++,r0
80005bf0:	00 00       	add	r0,r0
80005bf2:	0d 20       	ld.uh	r0,r6++
80005bf4:	00 00       	add	r0,r0
80005bf6:	0c 20       	rsub	r0,r6
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	55 b4       	stdsp	sp[0x16c],r4
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	59 70       	cp.w	r0,23
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	4e 80       	lddpc	r0,80005da0 <xTaskGenericCreate+0x18c>
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	4d c6       	lddpc	r6,80005d74 <xTaskGenericCreate+0x160>
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	4f 8c       	lddpc	r12,80005de8 <xTaskGenericCreate+0x1d4>
80005c0c:	80 00       	ld.sh	r0,r0[0x0]
80005c0e:	50 c4       	stdsp	sp[0x30],r4
80005c10:	80 00       	ld.sh	r0,r0[0x0]
80005c12:	20 30       	sub	r0,3

80005c14 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005c14:	d4 31       	pushm	r0-r7,lr
80005c16:	20 1d       	sub	sp,4
80005c18:	fa c4 ff d8 	sub	r4,sp,-40
80005c1c:	50 0c       	stdsp	sp[0x0],r12
80005c1e:	16 91       	mov	r1,r11
80005c20:	14 97       	mov	r7,r10
80005c22:	12 90       	mov	r0,r9
80005c24:	10 93       	mov	r3,r8
80005c26:	68 02       	ld.w	r2,r4[0x0]
80005c28:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005c2a:	34 8c       	mov	r12,72
80005c2c:	f0 1f 00 5c 	mcall	80005d9c <xTaskGenericCreate+0x188>
80005c30:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005c32:	c0 31       	brne	80005c38 <xTaskGenericCreate+0x24>
80005c34:	3f fc       	mov	r12,-1
80005c36:	ca f8       	rjmp	80005d94 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005c38:	58 06       	cp.w	r6,0
80005c3a:	e0 81 00 af 	brne	80005d98 <xTaskGenericCreate+0x184>
80005c3e:	0e 9c       	mov	r12,r7
80005c40:	5c 7c       	castu.h	r12
80005c42:	a3 6c       	lsl	r12,0x2
80005c44:	f0 1f 00 56 	mcall	80005d9c <xTaskGenericCreate+0x188>
80005c48:	18 96       	mov	r6,r12
80005c4a:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005c4c:	c0 61       	brne	80005c58 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005c4e:	0a 9c       	mov	r12,r5
80005c50:	f0 1f 00 54 	mcall	80005da0 <xTaskGenericCreate+0x18c>
80005c54:	3f fc       	mov	r12,-1
80005c56:	c9 f8       	rjmp	80005d94 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005c58:	5c 77       	castu.h	r7
80005c5a:	ee 0a 15 02 	lsl	r10,r7,0x2
80005c5e:	e0 6b 00 a5 	mov	r11,165
80005c62:	0c 9c       	mov	r12,r6
80005c64:	f0 1f 00 50 	mcall	80005da4 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005c68:	ee c6 00 01 	sub	r6,r7,1
80005c6c:	6a c8       	ld.w	r8,r5[0x30]
80005c6e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005c72:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005c76:	31 0a       	mov	r10,16
80005c78:	02 9b       	mov	r11,r1
80005c7a:	ea cc ff cc 	sub	r12,r5,-52
80005c7e:	f0 1f 00 4b 	mcall	80005da8 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005c82:	30 08       	mov	r8,0
80005c84:	eb 68 00 43 	st.b	r5[67],r8
80005c88:	58 73       	cp.w	r3,7
80005c8a:	e6 07 17 80 	movls	r7,r3
80005c8e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005c92:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005c94:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005c98:	ea c4 ff fc 	sub	r4,r5,-4
80005c9c:	08 9c       	mov	r12,r4
80005c9e:	f0 1f 00 44 	mcall	80005dac <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005ca2:	ea cc ff e8 	sub	r12,r5,-24
80005ca6:	f0 1f 00 42 	mcall	80005dac <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005caa:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005cac:	ee 07 11 08 	rsub	r7,r7,8
80005cb0:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005cb2:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005cb4:	00 9a       	mov	r10,r0
80005cb6:	40 0b       	lddsp	r11,sp[0x0]
80005cb8:	0c 9c       	mov	r12,r6
80005cba:	f0 1f 00 3e 	mcall	80005db0 <xTaskGenericCreate+0x19c>
80005cbe:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005cc0:	58 02       	cp.w	r2,0
80005cc2:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005cc6:	f0 1f 00 3c 	mcall	80005db4 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005cca:	4b c8       	lddpc	r8,80005db8 <xTaskGenericCreate+0x1a4>
80005ccc:	70 09       	ld.w	r9,r8[0x0]
80005cce:	2f f9       	sub	r9,-1
80005cd0:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005cd2:	4b b8       	lddpc	r8,80005dbc <xTaskGenericCreate+0x1a8>
80005cd4:	70 08       	ld.w	r8,r8[0x0]
80005cd6:	58 08       	cp.w	r8,0
80005cd8:	c2 61       	brne	80005d24 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005cda:	4b 98       	lddpc	r8,80005dbc <xTaskGenericCreate+0x1a8>
80005cdc:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005cde:	4b 78       	lddpc	r8,80005db8 <xTaskGenericCreate+0x1a4>
80005ce0:	70 08       	ld.w	r8,r8[0x0]
80005ce2:	58 18       	cp.w	r8,1
80005ce4:	c2 b1       	brne	80005d3a <xTaskGenericCreate+0x126>
80005ce6:	4b 77       	lddpc	r7,80005dc0 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005ce8:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005cec:	0e 9c       	mov	r12,r7
80005cee:	f0 1f 00 36 	mcall	80005dc4 <xTaskGenericCreate+0x1b0>
80005cf2:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005cf4:	0c 37       	cp.w	r7,r6
80005cf6:	cf b1       	brne	80005cec <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005cf8:	4b 47       	lddpc	r7,80005dc8 <xTaskGenericCreate+0x1b4>
80005cfa:	0e 9c       	mov	r12,r7
80005cfc:	f0 1f 00 32 	mcall	80005dc4 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005d00:	4b 36       	lddpc	r6,80005dcc <xTaskGenericCreate+0x1b8>
80005d02:	0c 9c       	mov	r12,r6
80005d04:	f0 1f 00 30 	mcall	80005dc4 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005d08:	4b 2c       	lddpc	r12,80005dd0 <xTaskGenericCreate+0x1bc>
80005d0a:	f0 1f 00 2f 	mcall	80005dc4 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005d0e:	4b 2c       	lddpc	r12,80005dd4 <xTaskGenericCreate+0x1c0>
80005d10:	f0 1f 00 2d 	mcall	80005dc4 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005d14:	4b 1c       	lddpc	r12,80005dd8 <xTaskGenericCreate+0x1c4>
80005d16:	f0 1f 00 2c 	mcall	80005dc4 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005d1a:	4b 18       	lddpc	r8,80005ddc <xTaskGenericCreate+0x1c8>
80005d1c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005d1e:	4b 18       	lddpc	r8,80005de0 <xTaskGenericCreate+0x1cc>
80005d20:	91 06       	st.w	r8[0x0],r6
80005d22:	c0 c8       	rjmp	80005d3a <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005d24:	4b 08       	lddpc	r8,80005de4 <xTaskGenericCreate+0x1d0>
80005d26:	70 08       	ld.w	r8,r8[0x0]
80005d28:	58 08       	cp.w	r8,0
80005d2a:	c0 81       	brne	80005d3a <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005d2c:	4a 48       	lddpc	r8,80005dbc <xTaskGenericCreate+0x1a8>
80005d2e:	70 08       	ld.w	r8,r8[0x0]
80005d30:	70 b8       	ld.w	r8,r8[0x2c]
80005d32:	10 33       	cp.w	r3,r8
80005d34:	c0 33       	brcs	80005d3a <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005d36:	4a 28       	lddpc	r8,80005dbc <xTaskGenericCreate+0x1a8>
80005d38:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005d3a:	6a b8       	ld.w	r8,r5[0x2c]
80005d3c:	4a b9       	lddpc	r9,80005de8 <xTaskGenericCreate+0x1d4>
80005d3e:	72 09       	ld.w	r9,r9[0x0]
80005d40:	12 38       	cp.w	r8,r9
80005d42:	e0 88 00 04 	brls	80005d4a <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005d46:	4a 99       	lddpc	r9,80005de8 <xTaskGenericCreate+0x1d4>
80005d48:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005d4a:	4a 98       	lddpc	r8,80005dec <xTaskGenericCreate+0x1d8>
80005d4c:	70 09       	ld.w	r9,r8[0x0]
80005d4e:	2f f9       	sub	r9,-1
80005d50:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005d52:	6a b8       	ld.w	r8,r5[0x2c]
80005d54:	4a 79       	lddpc	r9,80005df0 <xTaskGenericCreate+0x1dc>
80005d56:	72 09       	ld.w	r9,r9[0x0]
80005d58:	12 38       	cp.w	r8,r9
80005d5a:	e0 88 00 04 	brls	80005d62 <xTaskGenericCreate+0x14e>
80005d5e:	4a 59       	lddpc	r9,80005df0 <xTaskGenericCreate+0x1dc>
80005d60:	93 08       	st.w	r9[0x0],r8
80005d62:	6a bc       	ld.w	r12,r5[0x2c]
80005d64:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005d68:	08 9b       	mov	r11,r4
80005d6a:	49 68       	lddpc	r8,80005dc0 <xTaskGenericCreate+0x1ac>
80005d6c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005d70:	f0 1f 00 21 	mcall	80005df4 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005d74:	f0 1f 00 21 	mcall	80005df8 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005d78:	49 b8       	lddpc	r8,80005de4 <xTaskGenericCreate+0x1d0>
80005d7a:	70 08       	ld.w	r8,r8[0x0]
80005d7c:	58 08       	cp.w	r8,0
80005d7e:	c0 a0       	breq	80005d92 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005d80:	48 f8       	lddpc	r8,80005dbc <xTaskGenericCreate+0x1a8>
80005d82:	70 08       	ld.w	r8,r8[0x0]
80005d84:	70 b8       	ld.w	r8,r8[0x2c]
80005d86:	10 33       	cp.w	r3,r8
80005d88:	e0 88 00 05 	brls	80005d92 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005d8c:	d7 33       	scall
80005d8e:	30 1c       	mov	r12,1
80005d90:	c0 28       	rjmp	80005d94 <xTaskGenericCreate+0x180>
80005d92:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005d94:	2f fd       	sub	sp,-4
80005d96:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005d98:	99 c6       	st.w	r12[0x30],r6
80005d9a:	c5 fb       	rjmp	80005c58 <xTaskGenericCreate+0x44>
80005d9c:	80 00       	ld.sh	r0,r0[0x0]
80005d9e:	50 ec       	stdsp	sp[0x38],r12
80005da0:	80 00       	ld.sh	r0,r0[0x0]
80005da2:	50 c4       	stdsp	sp[0x30],r4
80005da4:	80 00       	ld.sh	r0,r0[0x0]
80005da6:	6a 78       	ld.w	r8,r5[0x1c]
80005da8:	80 00       	ld.sh	r0,r0[0x0]
80005daa:	6d bc       	ld.w	r12,r6[0x6c]
80005dac:	80 00       	ld.sh	r0,r0[0x0]
80005dae:	4d 70       	lddpc	r0,80005f08 <PrintDec+0xa>
80005db0:	80 00       	ld.sh	r0,r0[0x0]
80005db2:	4d ec       	lddpc	r12,80005f28 <PrintDec+0x2a>
80005db4:	80 00       	ld.sh	r0,r0[0x0]
80005db6:	4e 80       	lddpc	r0,80005f54 <PrintDec+0x56>
80005db8:	00 00       	add	r0,r0
80005dba:	0d 20       	ld.uh	r0,r6++
80005dbc:	00 00       	add	r0,r0
80005dbe:	0c d4       	st.w	--r6,r4
80005dc0:	00 00       	add	r0,r0
80005dc2:	0c 20       	rsub	r0,r6
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	4d 5c       	lddpc	r12,80005f18 <PrintDec+0x1a>
80005dc8:	00 00       	add	r0,r0
80005dca:	0c ec       	st.h	--r6,r12
80005dcc:	00 00       	add	r0,r0
80005dce:	0d 08       	ld.w	r8,r6++
80005dd0:	00 00       	add	r0,r0
80005dd2:	0c d8       	st.w	--r6,r8
80005dd4:	00 00       	add	r0,r0
80005dd6:	0c c0       	st.b	r6++,r0
80005dd8:	00 00       	add	r0,r0
80005dda:	0d 28       	ld.uh	r8,r6++
80005ddc:	00 00       	add	r0,r0
80005dde:	0c 0c       	add	r12,r6
80005de0:	00 00       	add	r0,r0
80005de2:	0c 1c       	sub	r12,r6
80005de4:	00 00       	add	r0,r0
80005de6:	0c 10       	sub	r0,r6
80005de8:	00 00       	add	r0,r0
80005dea:	0c 08       	add	r8,r6
80005dec:	00 00       	add	r0,r0
80005dee:	0d 1c       	ld.sh	r12,r6++
80005df0:	00 00       	add	r0,r0
80005df2:	0d 3c       	ld.ub	r12,r6++
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	4d 76       	lddpc	r6,80005f50 <PrintDec+0x52>
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	4f 8c       	lddpc	r12,80005fd8 <log>

80005dfc <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005dfc:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005dfe:	30 09       	mov	r9,0
80005e00:	1a d9       	st.w	--sp,r9
80005e02:	1a d9       	st.w	--sp,r9
80005e04:	1a d9       	st.w	--sp,r9
80005e06:	12 98       	mov	r8,r9
80005e08:	e0 6a 01 00 	mov	r10,256
80005e0c:	48 9b       	lddpc	r11,80005e30 <vTaskStartScheduler+0x34>
80005e0e:	48 ac       	lddpc	r12,80005e34 <vTaskStartScheduler+0x38>
80005e10:	f0 1f 00 0a 	mcall	80005e38 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005e14:	2f dd       	sub	sp,-12
80005e16:	58 1c       	cp.w	r12,1
80005e18:	c0 a1       	brne	80005e2c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005e1a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005e1c:	30 19       	mov	r9,1
80005e1e:	48 88       	lddpc	r8,80005e3c <vTaskStartScheduler+0x40>
80005e20:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005e22:	30 09       	mov	r9,0
80005e24:	48 78       	lddpc	r8,80005e40 <vTaskStartScheduler+0x44>
80005e26:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005e28:	f0 1f 00 07 	mcall	80005e44 <vTaskStartScheduler+0x48>
80005e2c:	d8 02       	popm	pc
80005e2e:	00 00       	add	r0,r0
80005e30:	80 00       	ld.sh	r0,r0[0x0]
80005e32:	c8 ac       	rcall	80005f46 <PrintDec+0x48>
80005e34:	80 00       	ld.sh	r0,r0[0x0]
80005e36:	5b 8c       	cp.w	r12,-8
80005e38:	80 00       	ld.sh	r0,r0[0x0]
80005e3a:	5c 14       	scr	r4
80005e3c:	00 00       	add	r0,r0
80005e3e:	0c 10       	sub	r0,r6
80005e40:	00 00       	add	r0,r0
80005e42:	0d 00       	ld.w	r0,r6++
80005e44:	80 00       	ld.sh	r0,r0[0x0]
80005e46:	4e 90       	lddpc	r0,80005fe8 <log+0x10>

80005e48 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005e48:	16 cc       	st.b	r11++,r12
	return str;
}
80005e4a:	5e fb       	retal	r11

80005e4c <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005e4c:	eb cd 40 c0 	pushm	r6-r7,lr
80005e50:	20 3d       	sub	sp,12
80005e52:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005e54:	30 06       	mov	r6,0
80005e56:	30 07       	mov	r7,0
80005e58:	fa e7 00 00 	st.d	sp[0],r6
80005e5c:	30 0c       	mov	r12,0
80005e5e:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005e60:	58 08       	cp.w	r8,0
80005e62:	c1 30       	breq	80005e88 <PrintHex+0x3c>
80005e64:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005e66:	1a 9c       	mov	r12,sp
80005e68:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005e6c:	58 9e       	cp.w	lr,9
80005e6e:	e0 8a 00 04 	brle	80005e76 <PrintHex+0x2a>
80005e72:	2c 9e       	sub	lr,-55
80005e74:	c0 48       	rjmp	80005e7c <PrintHex+0x30>
80005e76:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005e7a:	2d 0e       	sub	lr,-48
80005e7c:	f8 09 0b 0e 	st.b	r12[r9],lr
80005e80:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80005e82:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005e84:	cf 21       	brne	80005e68 <PrintHex+0x1c>
80005e86:	c0 48       	rjmp	80005e8e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005e88:	33 08       	mov	r8,48
80005e8a:	ba 88       	st.b	sp[0x0],r8
80005e8c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80005e8e:	f6 09 01 08 	sub	r8,r11,r9
80005e92:	58 08       	cp.w	r8,0
80005e94:	e0 8a 00 13 	brle	80005eba <PrintHex+0x6e>
	{
		char num = len - cnt;
80005e98:	12 1b       	sub	r11,r9
80005e9a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005e9e:	18 9e       	mov	lr,r12
80005ea0:	58 0c       	cp.w	r12,0
80005ea2:	e0 8a 00 0c 	brle	80005eba <PrintHex+0x6e>
80005ea6:	1a 9b       	mov	r11,sp
80005ea8:	12 0b       	add	r11,r9
80005eaa:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005eac:	33 07       	mov	r7,48
80005eae:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005eb0:	2f f8       	sub	r8,-1
80005eb2:	1c 38       	cp.w	r8,lr
80005eb4:	cf d5       	brlt	80005eae <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005eb6:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005eba:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005ebe:	f0 cb ff ff 	sub	r11,r8,-1
80005ec2:	58 0b       	cp.w	r11,0
80005ec4:	e0 8a 00 19 	brle	80005ef6 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005ec8:	fa cb ff f4 	sub	r11,sp,-12
80005ecc:	f6 09 00 09 	add	r9,r11,r9
80005ed0:	37 8b       	mov	r11,120
80005ed2:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005ed6:	fa c9 ff f4 	sub	r9,sp,-12
80005eda:	10 09       	add	r9,r8
80005edc:	33 0b       	mov	r11,48
80005ede:	f3 6b ff f4 	st.b	r9[-12],r11
80005ee2:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005ee6:	fa ce 00 01 	sub	lr,sp,1
80005eea:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005eec:	11 8b       	ld.ub	r11,r8[0x0]
80005eee:	12 cb       	st.b	r9++,r11
80005ef0:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005ef2:	1c 38       	cp.w	r8,lr
80005ef4:	cf c1       	brne	80005eec <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005ef6:	14 9c       	mov	r12,r10
80005ef8:	2f dd       	sub	sp,-12
80005efa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005efe <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005efe:	d4 21       	pushm	r4-r7,lr
80005f00:	20 3d       	sub	sp,12
80005f02:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005f04:	30 06       	mov	r6,0
80005f06:	30 07       	mov	r7,0
80005f08:	fa e7 00 00 	st.d	sp[0],r6
80005f0c:	30 0c       	mov	r12,0
80005f0e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005f10:	58 08       	cp.w	r8,0
80005f12:	c0 35       	brlt	80005f18 <PrintDec+0x1a>
80005f14:	14 97       	mov	r7,r10
80005f16:	c0 58       	rjmp	80005f20 <PrintDec+0x22>
	{
		*p++ = '-';
80005f18:	14 97       	mov	r7,r10
80005f1a:	32 d9       	mov	r9,45
80005f1c:	0e c9       	st.b	r7++,r9
		i = -i;
80005f1e:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005f20:	58 08       	cp.w	r8,0
80005f22:	c0 51       	brne	80005f2c <PrintDec+0x2e>
80005f24:	33 08       	mov	r8,48
80005f26:	ba 88       	st.b	sp[0x0],r8
80005f28:	30 1e       	mov	lr,1
80005f2a:	c2 f8       	rjmp	80005f88 <PrintDec+0x8a>
	
	int ten = i%10;
80005f2c:	e0 65 66 67 	mov	r5,26215
80005f30:	ea 15 66 66 	orh	r5,0x6666
80005f34:	f0 05 04 44 	muls.d	r4,r8,r5
80005f38:	ea 0c 14 02 	asr	r12,r5,0x2
80005f3c:	f0 09 14 1f 	asr	r9,r8,0x1f
80005f40:	f8 09 01 09 	sub	r9,r12,r9
80005f44:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005f48:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005f4c:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005f4e:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005f50:	e0 66 66 67 	mov	r6,26215
80005f54:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005f58:	2d 09       	sub	r9,-48
80005f5a:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005f5e:	2f fe       	sub	lr,-1
		i /= 10;
80005f60:	f0 06 04 44 	muls.d	r4,r8,r6
80005f64:	ea 09 14 02 	asr	r9,r5,0x2
80005f68:	bf 58       	asr	r8,0x1f
80005f6a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005f6e:	f0 06 04 44 	muls.d	r4,r8,r6
80005f72:	ea 09 14 02 	asr	r9,r5,0x2
80005f76:	f0 05 14 1f 	asr	r5,r8,0x1f
80005f7a:	0a 19       	sub	r9,r5
80005f7c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005f80:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005f84:	58 08       	cp.w	r8,0
80005f86:	ce 91       	brne	80005f58 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005f88:	f6 0e 01 08 	sub	r8,r11,lr
80005f8c:	58 08       	cp.w	r8,0
80005f8e:	e0 89 00 06 	brgt	80005f9a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005f92:	58 0e       	cp.w	lr,0
80005f94:	e0 89 00 14 	brgt	80005fbc <PrintDec+0xbe>
80005f98:	c1 d8       	rjmp	80005fd2 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005f9a:	1c 1b       	sub	r11,lr
80005f9c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80005f9e:	16 9c       	mov	r12,r11
80005fa0:	58 0b       	cp.w	r11,0
80005fa2:	fe 9a ff f8 	brle	80005f92 <PrintDec+0x94>
80005fa6:	1a 99       	mov	r9,sp
80005fa8:	1c 09       	add	r9,lr
80005faa:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005fac:	33 06       	mov	r6,48
80005fae:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005fb0:	2f f8       	sub	r8,-1
80005fb2:	18 38       	cp.w	r8,r12
80005fb4:	cf d5       	brlt	80005fae <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80005fb6:	f6 0e 00 0e 	add	lr,r11,lr
80005fba:	ce cb       	rjmp	80005f92 <PrintDec+0x94>
80005fbc:	fa c8 ff f4 	sub	r8,sp,-12
80005fc0:	1c 08       	add	r8,lr
80005fc2:	20 d8       	sub	r8,13
80005fc4:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80005fc8:	11 89       	ld.ub	r9,r8[0x0]
80005fca:	0e c9       	st.b	r7++,r9
80005fcc:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005fce:	16 38       	cp.w	r8,r11
80005fd0:	cf c1       	brne	80005fc8 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005fd2:	14 9c       	mov	r12,r10
80005fd4:	2f dd       	sub	sp,-12
80005fd6:	d8 22       	popm	r4-r7,pc

80005fd8 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80005fd8:	d4 31       	pushm	r0-r7,lr
80005fda:	fa cd 02 08 	sub	sp,sp,520
80005fde:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80005fe0:	e0 6a 01 00 	mov	r10,256
80005fe4:	30 0b       	mov	r11,0
80005fe6:	fa cc fe f8 	sub	r12,sp,-264
80005fea:	f0 1f 00 4e 	mcall	80006120 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80005fee:	fa c4 fd d4 	sub	r4,sp,-556
80005ff2:	30 0a       	mov	r10,0
80005ff4:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005ff6:	fa c3 ff fc 	sub	r3,sp,-4
80005ffa:	e0 61 01 00 	mov	r1,256
80005ffe:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006000:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006002:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006006:	02 9a       	mov	r10,r1
80006008:	00 9b       	mov	r11,r0
8000600a:	06 9c       	mov	r12,r3
8000600c:	f0 1f 00 45 	mcall	80006120 <log+0x148>
			
					if(*str == '%')
80006010:	0f 88       	ld.ub	r8,r7[0x0]
80006012:	e4 08 18 00 	cp.b	r8,r2
80006016:	c5 71       	brne	800060c4 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006018:	ee c8 ff ff 	sub	r8,r7,-1
8000601c:	11 89       	ld.ub	r9,r8[0x0]
8000601e:	4c 2a       	lddpc	r10,80006124 <log+0x14c>
80006020:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006022:	23 09       	sub	r9,48
80006024:	30 9a       	mov	r10,9
80006026:	f4 09 18 00 	cp.b	r9,r10
8000602a:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
8000602e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006032:	f7 b9 08 30 	subls	r9,48
80006036:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
8000603a:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000603e:	0f 88       	ld.ub	r8,r7[0x0]
80006040:	22 58       	sub	r8,37
80006042:	e0 48 00 53 	cp.w	r8,83
80006046:	e0 8b 00 31 	brhi	800060a8 <log+0xd0>
8000604a:	4b 89       	lddpc	r9,80006128 <log+0x150>
8000604c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006050:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006054:	06 9a       	mov	r10,r3
80006056:	40 0b       	lddsp	r11,sp[0x0]
80006058:	5c 5b       	castu.b	r11
8000605a:	68 0c       	ld.w	r12,r4[0x0]
8000605c:	f0 1f 00 34 	mcall	8000612c <log+0x154>
							break;
80006060:	c2 98       	rjmp	800060b2 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006062:	4b 4c       	lddpc	r12,80006130 <log+0x158>
80006064:	f0 1f 00 34 	mcall	80006134 <log+0x15c>
80006068:	08 95       	mov	r5,r4
8000606a:	06 9c       	mov	r12,r3
							break;
8000606c:	c2 38       	rjmp	800060b2 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000606e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006072:	06 9a       	mov	r10,r3
80006074:	40 0b       	lddsp	r11,sp[0x0]
80006076:	5c 5b       	castu.b	r11
80006078:	68 0c       	ld.w	r12,r4[0x0]
8000607a:	f0 1f 00 30 	mcall	80006138 <log+0x160>
8000607e:	06 9c       	mov	r12,r3
							break;
80006080:	c1 98       	rjmp	800060b2 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006082:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006086:	06 9b       	mov	r11,r3
80006088:	09 bc       	ld.ub	r12,r4[0x3]
8000608a:	f0 1f 00 2d 	mcall	8000613c <log+0x164>
8000608e:	06 9c       	mov	r12,r3
							break;
80006090:	c1 18       	rjmp	800060b2 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006092:	e8 c5 ff fc 	sub	r5,r4,-4
80006096:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006098:	c0 d8       	rjmp	800060b2 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000609a:	06 9b       	mov	r11,r3
8000609c:	32 5c       	mov	r12,37
8000609e:	f0 1f 00 28 	mcall	8000613c <log+0x164>
800060a2:	08 95       	mov	r5,r4
800060a4:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800060a6:	c0 68       	rjmp	800060b2 <log+0xda>
							
							default:
							log("I need relax.");
800060a8:	4a 6c       	lddpc	r12,80006140 <log+0x168>
800060aa:	f0 1f 00 23 	mcall	80006134 <log+0x15c>
800060ae:	08 95       	mov	r5,r4
800060b0:	06 9c       	mov	r12,r3
						}
						str++;
800060b2:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800060b4:	1a dc       	st.w	--sp,r12
800060b6:	1a d6       	st.w	--sp,r6
800060b8:	4a 3b       	lddpc	r11,80006144 <log+0x16c>
800060ba:	0c 9c       	mov	r12,r6
800060bc:	f0 1f 00 23 	mcall	80006148 <log+0x170>
800060c0:	2f ed       	sub	sp,-8
800060c2:	c0 a8       	rjmp	800060d6 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800060c4:	2f f7       	sub	r7,-1
800060c6:	1a d8       	st.w	--sp,r8
800060c8:	1a d6       	st.w	--sp,r6
800060ca:	4a 1b       	lddpc	r11,8000614c <log+0x174>
800060cc:	0c 9c       	mov	r12,r6
800060ce:	f0 1f 00 1f 	mcall	80006148 <log+0x170>
800060d2:	08 95       	mov	r5,r4
800060d4:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800060d6:	0f 89       	ld.ub	r9,r7[0x0]
800060d8:	30 08       	mov	r8,0
800060da:	f0 09 18 00 	cp.b	r9,r8
800060de:	c0 30       	breq	800060e4 <log+0x10c>
800060e0:	0a 94       	mov	r4,r5
800060e2:	c9 2b       	rjmp	80006006 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
800060e4:	fa c7 fe f8 	sub	r7,sp,-264
800060e8:	1a d7       	st.w	--sp,r7
800060ea:	49 ab       	lddpc	r11,80006150 <log+0x178>
800060ec:	0e 9c       	mov	r12,r7
800060ee:	f0 1f 00 17 	mcall	80006148 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800060f2:	5c 5c       	castu.b	r12
800060f4:	f8 c6 ff ff 	sub	r6,r12,-1
800060f8:	0c 9c       	mov	r12,r6
800060fa:	f0 1f 00 17 	mcall	80006154 <log+0x17c>
800060fe:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006100:	0c 9a       	mov	r10,r6
80006102:	0e 9b       	mov	r11,r7
80006104:	f0 1f 00 15 	mcall	80006158 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006108:	30 09       	mov	r9,0
8000610a:	30 5a       	mov	r10,5
8000610c:	fa cb fe f8 	sub	r11,sp,-264
80006110:	49 38       	lddpc	r8,8000615c <log+0x184>
80006112:	70 0c       	ld.w	r12,r8[0x0]
80006114:	f0 1f 00 13 	mcall	80006160 <log+0x188>
80006118:	2f fd       	sub	sp,-4
	
	
}
8000611a:	fe 3d fd f8 	sub	sp,-520
8000611e:	d8 32       	popm	r0-r7,pc
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	6a 78       	ld.w	r8,r5[0x1c]
80006124:	00 00       	add	r0,r0
80006126:	0d 40       	ld.w	r0,--r6
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	c8 b4       	brge	80006040 <log+0x68>
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	5e fe       	retal	-1
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	cb 60       	breq	8000609e <log+0xc6>
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	5f d8       	srvc	r8
80006138:	80 00       	ld.sh	r0,r0[0x0]
8000613a:	5e 4c       	retge	r12
8000613c:	80 00       	ld.sh	r0,r0[0x0]
8000613e:	5e 48       	retge	r8
80006140:	80 00       	ld.sh	r0,r0[0x0]
80006142:	cb 70       	breq	800060b0 <log+0xd8>
80006144:	80 00       	ld.sh	r0,r0[0x0]
80006146:	cb 80       	breq	800060b6 <log+0xde>
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	6d 68       	ld.w	r8,r6[0x58]
8000614c:	80 00       	ld.sh	r0,r0[0x0]
8000614e:	cb 88       	rjmp	800062be <logFromISR+0x15a>
80006150:	80 00       	ld.sh	r0,r0[0x0]
80006152:	cb 90       	breq	800060c4 <log+0xec>
80006154:	80 00       	ld.sh	r0,r0[0x0]
80006156:	50 ec       	stdsp	sp[0x38],r12
80006158:	80 00       	ld.sh	r0,r0[0x0]
8000615a:	69 30       	ld.w	r0,r4[0x4c]
8000615c:	00 00       	add	r0,r0
8000615e:	40 f8       	lddsp	r8,sp[0x3c]
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	54 40       	stdsp	sp[0x110],r0

80006164 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006164:	d4 31       	pushm	r0-r7,lr
80006166:	fa cd 02 0c 	sub	sp,sp,524
8000616a:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000616c:	e0 6a 01 00 	mov	r10,256
80006170:	30 0b       	mov	r11,0
80006172:	fa cc fe f4 	sub	r12,sp,-268
80006176:	f0 1f 00 4c 	mcall	800062a4 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
8000617a:	fa c4 fd d0 	sub	r4,sp,-560
8000617e:	30 0a       	mov	r10,0
80006180:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006182:	fa c3 ff fc 	sub	r3,sp,-4
80006186:	e0 61 01 00 	mov	r1,256
8000618a:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000618c:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000618e:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006192:	02 9a       	mov	r10,r1
80006194:	00 9b       	mov	r11,r0
80006196:	06 9c       	mov	r12,r3
80006198:	f0 1f 00 43 	mcall	800062a4 <logFromISR+0x140>
			
			if(*str == '%')
8000619c:	0f 88       	ld.ub	r8,r7[0x0]
8000619e:	e4 08 18 00 	cp.b	r8,r2
800061a2:	c5 11       	brne	80006244 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800061a4:	ee c8 ff ff 	sub	r8,r7,-1
800061a8:	11 89       	ld.ub	r9,r8[0x0]
800061aa:	4c 0a       	lddpc	r10,800062a8 <logFromISR+0x144>
800061ac:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800061ae:	23 09       	sub	r9,48
800061b0:	30 9a       	mov	r10,9
800061b2:	f4 09 18 00 	cp.b	r9,r10
800061b6:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800061ba:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800061be:	f7 b9 08 30 	subls	r9,48
800061c2:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800061c6:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
800061ca:	0f 88       	ld.ub	r8,r7[0x0]
800061cc:	22 58       	sub	r8,37
800061ce:	e0 48 00 53 	cp.w	r8,83
800061d2:	e0 8b 00 2b 	brhi	80006228 <logFromISR+0xc4>
800061d6:	4b 69       	lddpc	r9,800062ac <logFromISR+0x148>
800061d8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
800061dc:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
800061e0:	06 9a       	mov	r10,r3
800061e2:	40 0b       	lddsp	r11,sp[0x0]
800061e4:	5c 5b       	castu.b	r11
800061e6:	68 0c       	ld.w	r12,r4[0x0]
800061e8:	f0 1f 00 32 	mcall	800062b0 <logFromISR+0x14c>
					break;
800061ec:	c2 38       	rjmp	80006232 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800061ee:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800061f2:	06 9a       	mov	r10,r3
800061f4:	40 0b       	lddsp	r11,sp[0x0]
800061f6:	5c 5b       	castu.b	r11
800061f8:	68 0c       	ld.w	r12,r4[0x0]
800061fa:	f0 1f 00 2f 	mcall	800062b4 <logFromISR+0x150>
800061fe:	06 9c       	mov	r12,r3
					break;
80006200:	c1 98       	rjmp	80006232 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80006202:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80006206:	06 9b       	mov	r11,r3
80006208:	09 bc       	ld.ub	r12,r4[0x3]
8000620a:	f0 1f 00 2c 	mcall	800062b8 <logFromISR+0x154>
8000620e:	06 9c       	mov	r12,r3
					break;
80006210:	c1 18       	rjmp	80006232 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80006212:	e8 c5 ff fc 	sub	r5,r4,-4
80006216:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80006218:	c0 d8       	rjmp	80006232 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000621a:	06 9b       	mov	r11,r3
8000621c:	32 5c       	mov	r12,37
8000621e:	f0 1f 00 27 	mcall	800062b8 <logFromISR+0x154>
80006222:	08 95       	mov	r5,r4
80006224:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80006226:	c0 68       	rjmp	80006232 <logFromISR+0xce>
					default:
					log("I need relax.");
80006228:	4a 5c       	lddpc	r12,800062bc <logFromISR+0x158>
8000622a:	f0 1f 00 26 	mcall	800062c0 <logFromISR+0x15c>
8000622e:	08 95       	mov	r5,r4
80006230:	06 9c       	mov	r12,r3
				}
				str++;
80006232:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006234:	1a dc       	st.w	--sp,r12
80006236:	1a d6       	st.w	--sp,r6
80006238:	4a 3b       	lddpc	r11,800062c4 <logFromISR+0x160>
8000623a:	0c 9c       	mov	r12,r6
8000623c:	f0 1f 00 23 	mcall	800062c8 <logFromISR+0x164>
80006240:	2f ed       	sub	sp,-8
80006242:	c0 a8       	rjmp	80006256 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006244:	2f f7       	sub	r7,-1
80006246:	1a d8       	st.w	--sp,r8
80006248:	1a d6       	st.w	--sp,r6
8000624a:	4a 1b       	lddpc	r11,800062cc <logFromISR+0x168>
8000624c:	0c 9c       	mov	r12,r6
8000624e:	f0 1f 00 1f 	mcall	800062c8 <logFromISR+0x164>
80006252:	08 95       	mov	r5,r4
80006254:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006256:	0f 89       	ld.ub	r9,r7[0x0]
80006258:	30 08       	mov	r8,0
8000625a:	f0 09 18 00 	cp.b	r9,r8
8000625e:	c0 30       	breq	80006264 <logFromISR+0x100>
80006260:	0a 94       	mov	r4,r5
80006262:	c9 8b       	rjmp	80006192 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006264:	fa c7 fe f4 	sub	r7,sp,-268
80006268:	1a d7       	st.w	--sp,r7
8000626a:	49 ab       	lddpc	r11,800062d0 <logFromISR+0x16c>
8000626c:	0e 9c       	mov	r12,r7
8000626e:	f0 1f 00 17 	mcall	800062c8 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80006272:	5c 5c       	castu.b	r12
80006274:	f8 c6 ff ff 	sub	r6,r12,-1
80006278:	0c 9c       	mov	r12,r6
8000627a:	f0 1f 00 17 	mcall	800062d4 <logFromISR+0x170>
8000627e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006280:	0c 9a       	mov	r10,r6
80006282:	0e 9b       	mov	r11,r7
80006284:	f0 1f 00 15 	mcall	800062d8 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006288:	30 09       	mov	r9,0
8000628a:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000628c:	fa ca fe f8 	sub	r10,sp,-264
80006290:	fa cb fe f4 	sub	r11,sp,-268
80006294:	49 28       	lddpc	r8,800062dc <logFromISR+0x178>
80006296:	70 0c       	ld.w	r12,r8[0x0]
80006298:	f0 1f 00 12 	mcall	800062e0 <logFromISR+0x17c>
8000629c:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000629e:	fe 3d fd f4 	sub	sp,-524
800062a2:	d8 32       	popm	r0-r7,pc
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	6a 78       	ld.w	r8,r5[0x1c]
800062a8:	00 00       	add	r0,r0
800062aa:	0d 41       	ld.w	r1,--r6
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	ca 04       	brge	800061ee <logFromISR+0x8a>
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	5e fe       	retal	-1
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	5e 4c       	retge	r12
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	5e 48       	retge	r8
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	cb 70       	breq	8000622c <logFromISR+0xc8>
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	5f d8       	srvc	r8
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	cb 80       	breq	80006236 <logFromISR+0xd2>
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	6d 68       	ld.w	r8,r6[0x58]
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	cb 88       	rjmp	8000643e <gpio_enable_module_pin+0x2a>
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	cb 90       	breq	80006244 <logFromISR+0xe0>
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	50 ec       	stdsp	sp[0x38],r12
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	69 30       	ld.w	r0,r4[0x4c]
800062dc:	00 00       	add	r0,r0
800062de:	40 f8       	lddsp	r8,sp[0x3c]
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	53 f0       	stdsp	sp[0xfc],r0

800062e4 <log_init>:
		
	return str;
}

void log_init(void)
{
800062e4:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800062e6:	30 2b       	mov	r11,2
800062e8:	49 0c       	lddpc	r12,80006328 <log_init+0x44>
800062ea:	f0 1f 00 11 	mcall	8000632c <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);		
800062ee:	e0 6a 36 00 	mov	r10,13824
800062f2:	ea 1a 01 6e 	orh	r10,0x16e
800062f6:	48 fb       	lddpc	r11,80006330 <log_init+0x4c>
800062f8:	fe 7c 18 00 	mov	r12,-59392
800062fc:	f0 1f 00 0e 	mcall	80006334 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006300:	30 4b       	mov	r11,4
80006302:	33 2c       	mov	r12,50
80006304:	f0 1f 00 0d 	mcall	80006338 <log_init+0x54>
80006308:	48 d8       	lddpc	r8,8000633c <log_init+0x58>
8000630a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000630c:	30 09       	mov	r9,0
8000630e:	1a d9       	st.w	--sp,r9
80006310:	1a d9       	st.w	--sp,r9
80006312:	1a d9       	st.w	--sp,r9
80006314:	30 28       	mov	r8,2
80006316:	e0 6a 01 80 	mov	r10,384
8000631a:	48 ab       	lddpc	r11,80006340 <log_init+0x5c>
8000631c:	48 ac       	lddpc	r12,80006344 <log_init+0x60>
8000631e:	f0 1f 00 0b 	mcall	80006348 <log_init+0x64>
80006322:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80006324:	d8 02       	popm	pc
80006326:	00 00       	add	r0,r0
80006328:	80 00       	ld.sh	r0,r0[0x0]
8000632a:	cb 9c       	rcall	8000649c <_stext+0x4>
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	64 68       	ld.w	r8,r2[0x18]
80006330:	80 00       	ld.sh	r0,r0[0x0]
80006332:	cb 54       	brge	8000629c <logFromISR+0x138>
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	4c 90       	lddpc	r0,80006458 <gpio_enable_module_pin+0x44>
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	55 40       	stdsp	sp[0x150],r0
8000633c:	00 00       	add	r0,r0
8000633e:	40 f8       	lddsp	r8,sp[0x3c]
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	cb 98       	rjmp	800064b4 <idata_load_loop>
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	63 4c       	ld.w	r12,r1[0x50]
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	5c 14       	scr	r4

8000634c <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
8000634c:	eb cd 40 f8 	pushm	r3-r7,lr
80006350:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006352:	48 c7       	lddpc	r7,80006380 <task_log+0x34>
80006354:	30 05       	mov	r5,0
80006356:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006358:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000635c:	0a 99       	mov	r9,r5
8000635e:	08 9a       	mov	r10,r4
80006360:	1a 9b       	mov	r11,sp
80006362:	6e 0c       	ld.w	r12,r7[0x0]
80006364:	f0 1f 00 08 	mcall	80006384 <task_log+0x38>
80006368:	58 1c       	cp.w	r12,1
8000636a:	cf 91       	brne	8000635c <task_log+0x10>
		{
			if( NULL != str)
8000636c:	40 0b       	lddsp	r11,sp[0x0]
8000636e:	58 0b       	cp.w	r11,0
80006370:	cf 60       	breq	8000635c <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006372:	06 9c       	mov	r12,r3
80006374:	f0 1f 00 05 	mcall	80006388 <task_log+0x3c>
				vPortFree(str);
80006378:	40 0c       	lddsp	r12,sp[0x0]
8000637a:	f0 1f 00 05 	mcall	8000638c <task_log+0x40>
8000637e:	ce fb       	rjmp	8000635c <task_log+0x10>
80006380:	00 00       	add	r0,r0
80006382:	40 f8       	lddsp	r8,sp[0x3c]
80006384:	80 00       	ld.sh	r0,r0[0x0]
80006386:	52 34       	stdsp	sp[0x8c],r4
80006388:	80 00       	ld.sh	r0,r0[0x0]
8000638a:	4c 40       	lddpc	r0,80006498 <_stext>
8000638c:	80 00       	ld.sh	r0,r0[0x0]
8000638e:	50 c4       	stdsp	sp[0x30],r4

80006390 <main>:
#include "fs/fs.h"
#include "rtc/rtc.h"
#include "data_flash/data_flash.h"

int main(void)
{
80006390:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006392:	fe 78 10 00 	mov	r8,-61440
80006396:	30 19       	mov	r9,1
80006398:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000639c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800063a0:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
800063a4:	d3 03       	ssrf	0x10
	local_start_pll0();
800063a6:	f0 1f 00 12 	mcall	800063ec <main+0x5c>
		
	INTC_init_interrupts();
800063aa:	f0 1f 00 12 	mcall	800063f0 <main+0x60>
	
	log_init();		
800063ae:	f0 1f 00 12 	mcall	800063f4 <main+0x64>
	log("----start debug， yoyo----");	
800063b2:	49 2c       	lddpc	r12,800063f8 <main+0x68>
800063b4:	f0 1f 00 12 	mcall	800063fc <main+0x6c>
	

	//fs_init();//data_flash_init();
	//65795机器无法通过文件系统初始化,究起原因，貌似是Radio对OB板的输出功率无法满足SD卡的正常工作。

	tc_init();	
800063b8:	f0 1f 00 12 	mcall	80006400 <main+0x70>
			
	xcmp_init();
800063bc:	f0 1f 00 12 	mcall	80006404 <main+0x74>
	
	app_init();
800063c0:	f0 1f 00 12 	mcall	80006408 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800063c4:	fe 79 10 00 	mov	r9,-61440
800063c8:	f2 f8 01 60 	ld.w	r8,r9[352]
800063cc:	e2 18 00 02 	andl	r8,0x2,COH
800063d0:	cf c0       	breq	800063c8 <main+0x38>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800063d2:	fe 79 10 00 	mov	r9,-61440
800063d6:	f2 f8 01 60 	ld.w	r8,r9[352]
800063da:	e2 18 00 02 	andl	r8,0x2,COH
800063de:	cf c1       	brne	800063d6 <main+0x46>
	local_start_timer();
800063e0:	f0 1f 00 0b 	mcall	8000640c <main+0x7c>
	
	Enable_global_interrupt();
800063e4:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
800063e6:	f0 1f 00 0b 	mcall	80006410 <main+0x80>
	return 0;
}
800063ea:	d8 0a       	popm	pc,r12=0
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	47 3c       	lddsp	r12,sp[0x1cc]
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	48 cc       	lddpc	r12,80006420 <gpio_enable_module_pin+0xc>
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	62 e4       	ld.w	r4,r1[0x38]
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	cb ac       	rcall	8000656e <_malloc_r+0x76>
800063fc:	80 00       	ld.sh	r0,r0[0x0]
800063fe:	5f d8       	srvc	r8
80006400:	80 00       	ld.sh	r0,r0[0x0]
80006402:	47 c8       	lddsp	r8,sp[0x1f0]
80006404:	80 00       	ld.sh	r0,r0[0x0]
80006406:	40 40       	lddsp	r0,sp[0x10]
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	20 40       	sub	r0,4
8000640c:	80 00       	ld.sh	r0,r0[0x0]
8000640e:	47 8c       	lddsp	r12,sp[0x1e0]
80006410:	80 00       	ld.sh	r0,r0[0x0]
80006412:	5d fc       	*unknown*

80006414 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006414:	f8 08 16 05 	lsr	r8,r12,0x5
80006418:	a9 68       	lsl	r8,0x8
8000641a:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000641e:	58 1b       	cp.w	r11,1
80006420:	c0 d0       	breq	8000643a <gpio_enable_module_pin+0x26>
80006422:	c0 63       	brcs	8000642e <gpio_enable_module_pin+0x1a>
80006424:	58 2b       	cp.w	r11,2
80006426:	c1 00       	breq	80006446 <gpio_enable_module_pin+0x32>
80006428:	58 3b       	cp.w	r11,3
8000642a:	c1 40       	breq	80006452 <gpio_enable_module_pin+0x3e>
8000642c:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000642e:	30 19       	mov	r9,1
80006430:	f2 0c 09 49 	lsl	r9,r9,r12
80006434:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006436:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006438:	c1 28       	rjmp	8000645c <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000643a:	30 19       	mov	r9,1
8000643c:	f2 0c 09 49 	lsl	r9,r9,r12
80006440:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006442:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006444:	c0 c8       	rjmp	8000645c <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006446:	30 19       	mov	r9,1
80006448:	f2 0c 09 49 	lsl	r9,r9,r12
8000644c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000644e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006450:	c0 68       	rjmp	8000645c <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006452:	30 19       	mov	r9,1
80006454:	f2 0c 09 49 	lsl	r9,r9,r12
80006458:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000645a:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000645c:	30 19       	mov	r9,1
8000645e:	f2 0c 09 4c 	lsl	r12,r9,r12
80006462:	91 2c       	st.w	r8[0x8],r12
80006464:	5e fd       	retal	0
80006466:	d7 03       	nop

80006468 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006468:	d4 21       	pushm	r4-r7,lr
8000646a:	18 97       	mov	r7,r12
8000646c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000646e:	58 0b       	cp.w	r11,0
80006470:	c0 31       	brne	80006476 <gpio_enable_module+0xe>
80006472:	30 05       	mov	r5,0
80006474:	c0 d8       	rjmp	8000648e <gpio_enable_module+0x26>
80006476:	30 06       	mov	r6,0
80006478:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000647a:	6e 1b       	ld.w	r11,r7[0x4]
8000647c:	6e 0c       	ld.w	r12,r7[0x0]
8000647e:	f0 1f 00 06 	mcall	80006494 <gpio_enable_module+0x2c>
80006482:	18 45       	or	r5,r12
		gpiomap++;
80006484:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006486:	2f f6       	sub	r6,-1
80006488:	0c 34       	cp.w	r4,r6
8000648a:	fe 9b ff f8 	brhi	8000647a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000648e:	0a 9c       	mov	r12,r5
80006490:	d8 22       	popm	r4-r7,pc
80006492:	00 00       	add	r0,r0
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	64 14       	ld.w	r4,r2[0x4]

80006498 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006498:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000649c:	fe c0 a6 9c 	sub	r0,pc,-22884

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800064a0:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800064a4:	d5 53       	csrf	0x15
  cp      r0, r1
800064a6:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
800064a8:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
800064ac:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
800064ae:	c0 72       	brcc	800064bc <idata_load_loop_end>
  cp      r0, r1
800064b0:	fe c2 93 60 	sub	r2,pc,-27808

800064b4 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
800064b4:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
800064b6:	a1 24       	st.d	r0++,r4
  cp      r0, r1
800064b8:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
800064ba:	cf d3       	brcs	800064b4 <idata_load_loop>

800064bc <idata_load_loop_end>:
  mov     r2, 0
800064bc:	e0 60 0a 48 	mov	r0,2632
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
800064c0:	e0 61 41 00 	mov	r1,16640
  cp      r0, r1
  brlo    udata_clear_loop
800064c4:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800064c6:	c0 62       	brcc	800064d2 <udata_clear_loop_end>
800064c8:	30 02       	mov	r2,0
800064ca:	30 03       	mov	r3,0

800064cc <udata_clear_loop>:
800064cc:	a1 22       	st.d	r0++,r2
800064ce:	02 30       	cp.w	r0,r1
800064d0:	cf e3       	brcs	800064cc <udata_clear_loop>

800064d2 <udata_clear_loop_end>:
800064d2:	fe cf 01 42 	sub	pc,pc,322
800064d6:	d7 03       	nop

800064d8 <free>:
800064d8:	d4 01       	pushm	lr
800064da:	e0 68 0a 44 	mov	r8,2628
800064de:	18 9b       	mov	r11,r12
800064e0:	70 0c       	ld.w	r12,r8[0x0]
800064e2:	e0 a0 1e 6d 	rcall	8000a1bc <_free_r>
800064e6:	d8 02       	popm	pc

800064e8 <malloc>:
800064e8:	d4 01       	pushm	lr
800064ea:	e0 68 0a 44 	mov	r8,2628
800064ee:	18 9b       	mov	r11,r12
800064f0:	70 0c       	ld.w	r12,r8[0x0]
800064f2:	c0 3c       	rcall	800064f8 <_malloc_r>
800064f4:	d8 02       	popm	pc
800064f6:	d7 03       	nop

800064f8 <_malloc_r>:
800064f8:	d4 31       	pushm	r0-r7,lr
800064fa:	f6 c8 ff f5 	sub	r8,r11,-11
800064fe:	18 95       	mov	r5,r12
80006500:	10 97       	mov	r7,r8
80006502:	e0 17 ff f8 	andl	r7,0xfff8
80006506:	59 68       	cp.w	r8,22
80006508:	f9 b7 08 10 	movls	r7,16
8000650c:	16 37       	cp.w	r7,r11
8000650e:	5f 38       	srlo	r8
80006510:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006514:	c0 50       	breq	8000651e <_malloc_r+0x26>
80006516:	30 c8       	mov	r8,12
80006518:	99 38       	st.w	r12[0xc],r8
8000651a:	e0 8f 01 fa 	bral	8000690e <_malloc_r+0x416>
8000651e:	fe b0 f5 89 	rcall	80005030 <__malloc_lock>
80006522:	e0 47 01 f7 	cp.w	r7,503
80006526:	e0 8b 00 1d 	brhi	80006560 <_malloc_r+0x68>
8000652a:	ee 03 16 03 	lsr	r3,r7,0x3
8000652e:	e0 68 05 44 	mov	r8,1348
80006532:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006536:	70 36       	ld.w	r6,r8[0xc]
80006538:	10 36       	cp.w	r6,r8
8000653a:	c0 61       	brne	80006546 <_malloc_r+0x4e>
8000653c:	ec c8 ff f8 	sub	r8,r6,-8
80006540:	70 36       	ld.w	r6,r8[0xc]
80006542:	10 36       	cp.w	r6,r8
80006544:	c0 c0       	breq	8000655c <_malloc_r+0x64>
80006546:	6c 18       	ld.w	r8,r6[0x4]
80006548:	e0 18 ff fc 	andl	r8,0xfffc
8000654c:	6c 3a       	ld.w	r10,r6[0xc]
8000654e:	ec 08 00 09 	add	r9,r6,r8
80006552:	0a 9c       	mov	r12,r5
80006554:	6c 28       	ld.w	r8,r6[0x8]
80006556:	95 28       	st.w	r10[0x8],r8
80006558:	91 3a       	st.w	r8[0xc],r10
8000655a:	c4 78       	rjmp	800065e8 <_malloc_r+0xf0>
8000655c:	2f e3       	sub	r3,-2
8000655e:	c4 d8       	rjmp	800065f8 <_malloc_r+0x100>
80006560:	ee 03 16 09 	lsr	r3,r7,0x9
80006564:	c0 41       	brne	8000656c <_malloc_r+0x74>
80006566:	ee 03 16 03 	lsr	r3,r7,0x3
8000656a:	c2 68       	rjmp	800065b6 <_malloc_r+0xbe>
8000656c:	58 43       	cp.w	r3,4
8000656e:	e0 8b 00 06 	brhi	8000657a <_malloc_r+0x82>
80006572:	ee 03 16 06 	lsr	r3,r7,0x6
80006576:	2c 83       	sub	r3,-56
80006578:	c1 f8       	rjmp	800065b6 <_malloc_r+0xbe>
8000657a:	59 43       	cp.w	r3,20
8000657c:	e0 8b 00 04 	brhi	80006584 <_malloc_r+0x8c>
80006580:	2a 53       	sub	r3,-91
80006582:	c1 a8       	rjmp	800065b6 <_malloc_r+0xbe>
80006584:	e0 43 00 54 	cp.w	r3,84
80006588:	e0 8b 00 06 	brhi	80006594 <_malloc_r+0x9c>
8000658c:	ee 03 16 0c 	lsr	r3,r7,0xc
80006590:	29 23       	sub	r3,-110
80006592:	c1 28       	rjmp	800065b6 <_malloc_r+0xbe>
80006594:	e0 43 01 54 	cp.w	r3,340
80006598:	e0 8b 00 06 	brhi	800065a4 <_malloc_r+0xac>
8000659c:	ee 03 16 0f 	lsr	r3,r7,0xf
800065a0:	28 93       	sub	r3,-119
800065a2:	c0 a8       	rjmp	800065b6 <_malloc_r+0xbe>
800065a4:	e0 43 05 54 	cp.w	r3,1364
800065a8:	e0 88 00 04 	brls	800065b0 <_malloc_r+0xb8>
800065ac:	37 e3       	mov	r3,126
800065ae:	c0 48       	rjmp	800065b6 <_malloc_r+0xbe>
800065b0:	ee 03 16 12 	lsr	r3,r7,0x12
800065b4:	28 43       	sub	r3,-124
800065b6:	e0 6a 05 44 	mov	r10,1348
800065ba:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800065be:	74 36       	ld.w	r6,r10[0xc]
800065c0:	c1 98       	rjmp	800065f2 <_malloc_r+0xfa>
800065c2:	6c 19       	ld.w	r9,r6[0x4]
800065c4:	e0 19 ff fc 	andl	r9,0xfffc
800065c8:	f2 07 01 0b 	sub	r11,r9,r7
800065cc:	58 fb       	cp.w	r11,15
800065ce:	e0 8a 00 04 	brle	800065d6 <_malloc_r+0xde>
800065d2:	20 13       	sub	r3,1
800065d4:	c1 18       	rjmp	800065f6 <_malloc_r+0xfe>
800065d6:	6c 38       	ld.w	r8,r6[0xc]
800065d8:	58 0b       	cp.w	r11,0
800065da:	c0 b5       	brlt	800065f0 <_malloc_r+0xf8>
800065dc:	6c 2a       	ld.w	r10,r6[0x8]
800065de:	ec 09 00 09 	add	r9,r6,r9
800065e2:	0a 9c       	mov	r12,r5
800065e4:	91 2a       	st.w	r8[0x8],r10
800065e6:	95 38       	st.w	r10[0xc],r8
800065e8:	72 18       	ld.w	r8,r9[0x4]
800065ea:	a1 a8       	sbr	r8,0x0
800065ec:	93 18       	st.w	r9[0x4],r8
800065ee:	cb c8       	rjmp	80006766 <_malloc_r+0x26e>
800065f0:	10 96       	mov	r6,r8
800065f2:	14 36       	cp.w	r6,r10
800065f4:	ce 71       	brne	800065c2 <_malloc_r+0xca>
800065f6:	2f f3       	sub	r3,-1
800065f8:	e0 6a 05 44 	mov	r10,1348
800065fc:	f4 cc ff f8 	sub	r12,r10,-8
80006600:	78 26       	ld.w	r6,r12[0x8]
80006602:	18 36       	cp.w	r6,r12
80006604:	c6 c0       	breq	800066dc <_malloc_r+0x1e4>
80006606:	6c 19       	ld.w	r9,r6[0x4]
80006608:	e0 19 ff fc 	andl	r9,0xfffc
8000660c:	f2 07 01 08 	sub	r8,r9,r7
80006610:	58 f8       	cp.w	r8,15
80006612:	e0 89 00 8f 	brgt	80006730 <_malloc_r+0x238>
80006616:	99 3c       	st.w	r12[0xc],r12
80006618:	99 2c       	st.w	r12[0x8],r12
8000661a:	58 08       	cp.w	r8,0
8000661c:	c0 55       	brlt	80006626 <_malloc_r+0x12e>
8000661e:	ec 09 00 09 	add	r9,r6,r9
80006622:	0a 9c       	mov	r12,r5
80006624:	ce 2b       	rjmp	800065e8 <_malloc_r+0xf0>
80006626:	e0 49 01 ff 	cp.w	r9,511
8000662a:	e0 8b 00 13 	brhi	80006650 <_malloc_r+0x158>
8000662e:	a3 99       	lsr	r9,0x3
80006630:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006634:	70 2b       	ld.w	r11,r8[0x8]
80006636:	8d 38       	st.w	r6[0xc],r8
80006638:	8d 2b       	st.w	r6[0x8],r11
8000663a:	97 36       	st.w	r11[0xc],r6
8000663c:	91 26       	st.w	r8[0x8],r6
8000663e:	a3 49       	asr	r9,0x2
80006640:	74 18       	ld.w	r8,r10[0x4]
80006642:	30 1b       	mov	r11,1
80006644:	f6 09 09 49 	lsl	r9,r11,r9
80006648:	f1 e9 10 09 	or	r9,r8,r9
8000664c:	95 19       	st.w	r10[0x4],r9
8000664e:	c4 78       	rjmp	800066dc <_malloc_r+0x1e4>
80006650:	f2 0a 16 09 	lsr	r10,r9,0x9
80006654:	58 4a       	cp.w	r10,4
80006656:	e0 8b 00 07 	brhi	80006664 <_malloc_r+0x16c>
8000665a:	f2 0a 16 06 	lsr	r10,r9,0x6
8000665e:	2c 8a       	sub	r10,-56
80006660:	c2 08       	rjmp	800066a0 <_malloc_r+0x1a8>
80006662:	d7 03       	nop
80006664:	59 4a       	cp.w	r10,20
80006666:	e0 8b 00 04 	brhi	8000666e <_malloc_r+0x176>
8000666a:	2a 5a       	sub	r10,-91
8000666c:	c1 a8       	rjmp	800066a0 <_malloc_r+0x1a8>
8000666e:	e0 4a 00 54 	cp.w	r10,84
80006672:	e0 8b 00 06 	brhi	8000667e <_malloc_r+0x186>
80006676:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000667a:	29 2a       	sub	r10,-110
8000667c:	c1 28       	rjmp	800066a0 <_malloc_r+0x1a8>
8000667e:	e0 4a 01 54 	cp.w	r10,340
80006682:	e0 8b 00 06 	brhi	8000668e <_malloc_r+0x196>
80006686:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000668a:	28 9a       	sub	r10,-119
8000668c:	c0 a8       	rjmp	800066a0 <_malloc_r+0x1a8>
8000668e:	e0 4a 05 54 	cp.w	r10,1364
80006692:	e0 88 00 04 	brls	8000669a <_malloc_r+0x1a2>
80006696:	37 ea       	mov	r10,126
80006698:	c0 48       	rjmp	800066a0 <_malloc_r+0x1a8>
8000669a:	f2 0a 16 12 	lsr	r10,r9,0x12
8000669e:	28 4a       	sub	r10,-124
800066a0:	e0 6b 05 44 	mov	r11,1348
800066a4:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800066a8:	68 28       	ld.w	r8,r4[0x8]
800066aa:	08 38       	cp.w	r8,r4
800066ac:	c0 e1       	brne	800066c8 <_malloc_r+0x1d0>
800066ae:	76 19       	ld.w	r9,r11[0x4]
800066b0:	a3 4a       	asr	r10,0x2
800066b2:	30 1e       	mov	lr,1
800066b4:	fc 0a 09 4a 	lsl	r10,lr,r10
800066b8:	f3 ea 10 0a 	or	r10,r9,r10
800066bc:	10 99       	mov	r9,r8
800066be:	97 1a       	st.w	r11[0x4],r10
800066c0:	c0 a8       	rjmp	800066d4 <_malloc_r+0x1dc>
800066c2:	70 28       	ld.w	r8,r8[0x8]
800066c4:	08 38       	cp.w	r8,r4
800066c6:	c0 60       	breq	800066d2 <_malloc_r+0x1da>
800066c8:	70 1a       	ld.w	r10,r8[0x4]
800066ca:	e0 1a ff fc 	andl	r10,0xfffc
800066ce:	14 39       	cp.w	r9,r10
800066d0:	cf 93       	brcs	800066c2 <_malloc_r+0x1ca>
800066d2:	70 39       	ld.w	r9,r8[0xc]
800066d4:	8d 39       	st.w	r6[0xc],r9
800066d6:	8d 28       	st.w	r6[0x8],r8
800066d8:	91 36       	st.w	r8[0xc],r6
800066da:	93 26       	st.w	r9[0x8],r6
800066dc:	e6 08 14 02 	asr	r8,r3,0x2
800066e0:	30 1b       	mov	r11,1
800066e2:	e0 64 05 44 	mov	r4,1348
800066e6:	f6 08 09 4b 	lsl	r11,r11,r8
800066ea:	68 18       	ld.w	r8,r4[0x4]
800066ec:	10 3b       	cp.w	r11,r8
800066ee:	e0 8b 00 6b 	brhi	800067c4 <_malloc_r+0x2cc>
800066f2:	f7 e8 00 09 	and	r9,r11,r8
800066f6:	c0 b1       	brne	8000670c <_malloc_r+0x214>
800066f8:	e0 13 ff fc 	andl	r3,0xfffc
800066fc:	a1 7b       	lsl	r11,0x1
800066fe:	2f c3       	sub	r3,-4
80006700:	c0 38       	rjmp	80006706 <_malloc_r+0x20e>
80006702:	2f c3       	sub	r3,-4
80006704:	a1 7b       	lsl	r11,0x1
80006706:	f7 e8 00 09 	and	r9,r11,r8
8000670a:	cf c0       	breq	80006702 <_malloc_r+0x20a>
8000670c:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006710:	06 92       	mov	r2,r3
80006712:	1c 91       	mov	r1,lr
80006714:	62 36       	ld.w	r6,r1[0xc]
80006716:	c2 e8       	rjmp	80006772 <_malloc_r+0x27a>
80006718:	6c 1a       	ld.w	r10,r6[0x4]
8000671a:	e0 1a ff fc 	andl	r10,0xfffc
8000671e:	f4 07 01 08 	sub	r8,r10,r7
80006722:	58 f8       	cp.w	r8,15
80006724:	e0 8a 00 15 	brle	8000674e <_malloc_r+0x256>
80006728:	6c 3a       	ld.w	r10,r6[0xc]
8000672a:	6c 29       	ld.w	r9,r6[0x8]
8000672c:	95 29       	st.w	r10[0x8],r9
8000672e:	93 3a       	st.w	r9[0xc],r10
80006730:	0e 99       	mov	r9,r7
80006732:	ec 07 00 07 	add	r7,r6,r7
80006736:	a1 a9       	sbr	r9,0x0
80006738:	99 37       	st.w	r12[0xc],r7
8000673a:	99 27       	st.w	r12[0x8],r7
8000673c:	8d 19       	st.w	r6[0x4],r9
8000673e:	ee 08 09 08 	st.w	r7[r8],r8
80006742:	8f 2c       	st.w	r7[0x8],r12
80006744:	8f 3c       	st.w	r7[0xc],r12
80006746:	a1 a8       	sbr	r8,0x0
80006748:	0a 9c       	mov	r12,r5
8000674a:	8f 18       	st.w	r7[0x4],r8
8000674c:	c0 d8       	rjmp	80006766 <_malloc_r+0x26e>
8000674e:	6c 39       	ld.w	r9,r6[0xc]
80006750:	58 08       	cp.w	r8,0
80006752:	c0 f5       	brlt	80006770 <_malloc_r+0x278>
80006754:	ec 0a 00 0a 	add	r10,r6,r10
80006758:	74 18       	ld.w	r8,r10[0x4]
8000675a:	a1 a8       	sbr	r8,0x0
8000675c:	0a 9c       	mov	r12,r5
8000675e:	95 18       	st.w	r10[0x4],r8
80006760:	6c 28       	ld.w	r8,r6[0x8]
80006762:	93 28       	st.w	r9[0x8],r8
80006764:	91 39       	st.w	r8[0xc],r9
80006766:	fe b0 f4 6b 	rcall	8000503c <__malloc_unlock>
8000676a:	ec cc ff f8 	sub	r12,r6,-8
8000676e:	d8 32       	popm	r0-r7,pc
80006770:	12 96       	mov	r6,r9
80006772:	02 36       	cp.w	r6,r1
80006774:	cd 21       	brne	80006718 <_malloc_r+0x220>
80006776:	2f f2       	sub	r2,-1
80006778:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000677c:	c0 30       	breq	80006782 <_malloc_r+0x28a>
8000677e:	2f 81       	sub	r1,-8
80006780:	cc ab       	rjmp	80006714 <_malloc_r+0x21c>
80006782:	1c 98       	mov	r8,lr
80006784:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006788:	c0 81       	brne	80006798 <_malloc_r+0x2a0>
8000678a:	68 19       	ld.w	r9,r4[0x4]
8000678c:	f6 08 11 ff 	rsub	r8,r11,-1
80006790:	f3 e8 00 08 	and	r8,r9,r8
80006794:	89 18       	st.w	r4[0x4],r8
80006796:	c0 78       	rjmp	800067a4 <_malloc_r+0x2ac>
80006798:	f0 c9 00 08 	sub	r9,r8,8
8000679c:	20 13       	sub	r3,1
8000679e:	70 08       	ld.w	r8,r8[0x0]
800067a0:	12 38       	cp.w	r8,r9
800067a2:	cf 10       	breq	80006784 <_malloc_r+0x28c>
800067a4:	a1 7b       	lsl	r11,0x1
800067a6:	68 18       	ld.w	r8,r4[0x4]
800067a8:	10 3b       	cp.w	r11,r8
800067aa:	e0 8b 00 0d 	brhi	800067c4 <_malloc_r+0x2cc>
800067ae:	58 0b       	cp.w	r11,0
800067b0:	c0 a0       	breq	800067c4 <_malloc_r+0x2cc>
800067b2:	04 93       	mov	r3,r2
800067b4:	c0 38       	rjmp	800067ba <_malloc_r+0x2c2>
800067b6:	2f c3       	sub	r3,-4
800067b8:	a1 7b       	lsl	r11,0x1
800067ba:	f7 e8 00 09 	and	r9,r11,r8
800067be:	ca 71       	brne	8000670c <_malloc_r+0x214>
800067c0:	cf bb       	rjmp	800067b6 <_malloc_r+0x2be>
800067c2:	d7 03       	nop
800067c4:	68 23       	ld.w	r3,r4[0x8]
800067c6:	66 12       	ld.w	r2,r3[0x4]
800067c8:	e0 12 ff fc 	andl	r2,0xfffc
800067cc:	0e 32       	cp.w	r2,r7
800067ce:	5f 39       	srlo	r9
800067d0:	e4 07 01 08 	sub	r8,r2,r7
800067d4:	58 f8       	cp.w	r8,15
800067d6:	5f aa       	srle	r10
800067d8:	f5 e9 10 09 	or	r9,r10,r9
800067dc:	e0 80 00 9a 	breq	80006910 <_malloc_r+0x418>
800067e0:	e0 68 0d 4c 	mov	r8,3404
800067e4:	70 01       	ld.w	r1,r8[0x0]
800067e6:	e0 68 09 50 	mov	r8,2384
800067ea:	2f 01       	sub	r1,-16
800067ec:	70 08       	ld.w	r8,r8[0x0]
800067ee:	0e 01       	add	r1,r7
800067f0:	5b f8       	cp.w	r8,-1
800067f2:	c0 40       	breq	800067fa <_malloc_r+0x302>
800067f4:	28 11       	sub	r1,-127
800067f6:	e0 11 ff 80 	andl	r1,0xff80
800067fa:	02 9b       	mov	r11,r1
800067fc:	0a 9c       	mov	r12,r5
800067fe:	e0 a0 02 a5 	rcall	80006d48 <_sbrk_r>
80006802:	18 96       	mov	r6,r12
80006804:	5b fc       	cp.w	r12,-1
80006806:	c7 50       	breq	800068f0 <_malloc_r+0x3f8>
80006808:	e6 02 00 08 	add	r8,r3,r2
8000680c:	10 3c       	cp.w	r12,r8
8000680e:	c0 32       	brcc	80006814 <_malloc_r+0x31c>
80006810:	08 33       	cp.w	r3,r4
80006812:	c6 f1       	brne	800068f0 <_malloc_r+0x3f8>
80006814:	e0 6a 0d 50 	mov	r10,3408
80006818:	74 09       	ld.w	r9,r10[0x0]
8000681a:	e2 09 00 09 	add	r9,r1,r9
8000681e:	95 09       	st.w	r10[0x0],r9
80006820:	10 36       	cp.w	r6,r8
80006822:	c0 a1       	brne	80006836 <_malloc_r+0x33e>
80006824:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006828:	c0 71       	brne	80006836 <_malloc_r+0x33e>
8000682a:	e2 02 00 02 	add	r2,r1,r2
8000682e:	68 28       	ld.w	r8,r4[0x8]
80006830:	a1 a2       	sbr	r2,0x0
80006832:	91 12       	st.w	r8[0x4],r2
80006834:	c4 f8       	rjmp	800068d2 <_malloc_r+0x3da>
80006836:	e0 6a 09 50 	mov	r10,2384
8000683a:	74 0b       	ld.w	r11,r10[0x0]
8000683c:	5b fb       	cp.w	r11,-1
8000683e:	c0 31       	brne	80006844 <_malloc_r+0x34c>
80006840:	95 06       	st.w	r10[0x0],r6
80006842:	c0 78       	rjmp	80006850 <_malloc_r+0x358>
80006844:	ec 09 00 09 	add	r9,r6,r9
80006848:	e0 6a 0d 50 	mov	r10,3408
8000684c:	10 19       	sub	r9,r8
8000684e:	95 09       	st.w	r10[0x0],r9
80006850:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006854:	f0 09 11 08 	rsub	r9,r8,8
80006858:	58 08       	cp.w	r8,0
8000685a:	f2 08 17 10 	movne	r8,r9
8000685e:	ed d8 e1 06 	addne	r6,r6,r8
80006862:	28 08       	sub	r8,-128
80006864:	ec 01 00 01 	add	r1,r6,r1
80006868:	0a 9c       	mov	r12,r5
8000686a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000686e:	f0 01 01 01 	sub	r1,r8,r1
80006872:	02 9b       	mov	r11,r1
80006874:	e0 a0 02 6a 	rcall	80006d48 <_sbrk_r>
80006878:	e0 68 0d 50 	mov	r8,3408
8000687c:	5b fc       	cp.w	r12,-1
8000687e:	ec 0c 17 00 	moveq	r12,r6
80006882:	f9 b1 00 00 	moveq	r1,0
80006886:	70 09       	ld.w	r9,r8[0x0]
80006888:	0c 1c       	sub	r12,r6
8000688a:	89 26       	st.w	r4[0x8],r6
8000688c:	02 0c       	add	r12,r1
8000688e:	12 01       	add	r1,r9
80006890:	a1 ac       	sbr	r12,0x0
80006892:	91 01       	st.w	r8[0x0],r1
80006894:	8d 1c       	st.w	r6[0x4],r12
80006896:	08 33       	cp.w	r3,r4
80006898:	c1 d0       	breq	800068d2 <_malloc_r+0x3da>
8000689a:	58 f2       	cp.w	r2,15
8000689c:	e0 8b 00 05 	brhi	800068a6 <_malloc_r+0x3ae>
800068a0:	30 18       	mov	r8,1
800068a2:	8d 18       	st.w	r6[0x4],r8
800068a4:	c2 68       	rjmp	800068f0 <_malloc_r+0x3f8>
800068a6:	30 59       	mov	r9,5
800068a8:	20 c2       	sub	r2,12
800068aa:	e0 12 ff f8 	andl	r2,0xfff8
800068ae:	e6 02 00 08 	add	r8,r3,r2
800068b2:	91 29       	st.w	r8[0x8],r9
800068b4:	91 19       	st.w	r8[0x4],r9
800068b6:	66 18       	ld.w	r8,r3[0x4]
800068b8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068bc:	e5 e8 10 08 	or	r8,r2,r8
800068c0:	87 18       	st.w	r3[0x4],r8
800068c2:	58 f2       	cp.w	r2,15
800068c4:	e0 88 00 07 	brls	800068d2 <_malloc_r+0x3da>
800068c8:	e6 cb ff f8 	sub	r11,r3,-8
800068cc:	0a 9c       	mov	r12,r5
800068ce:	e0 a0 1c 77 	rcall	8000a1bc <_free_r>
800068d2:	e0 69 0d 48 	mov	r9,3400
800068d6:	72 0a       	ld.w	r10,r9[0x0]
800068d8:	e0 68 0d 50 	mov	r8,3408
800068dc:	70 08       	ld.w	r8,r8[0x0]
800068de:	14 38       	cp.w	r8,r10
800068e0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800068e4:	e0 69 0d 44 	mov	r9,3396
800068e8:	72 0a       	ld.w	r10,r9[0x0]
800068ea:	14 38       	cp.w	r8,r10
800068ec:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800068f0:	68 28       	ld.w	r8,r4[0x8]
800068f2:	70 18       	ld.w	r8,r8[0x4]
800068f4:	e0 18 ff fc 	andl	r8,0xfffc
800068f8:	0e 38       	cp.w	r8,r7
800068fa:	5f 39       	srlo	r9
800068fc:	0e 18       	sub	r8,r7
800068fe:	58 f8       	cp.w	r8,15
80006900:	5f aa       	srle	r10
80006902:	f5 e9 10 09 	or	r9,r10,r9
80006906:	c0 50       	breq	80006910 <_malloc_r+0x418>
80006908:	0a 9c       	mov	r12,r5
8000690a:	fe b0 f3 99 	rcall	8000503c <__malloc_unlock>
8000690e:	d8 3a       	popm	r0-r7,pc,r12=0
80006910:	68 26       	ld.w	r6,r4[0x8]
80006912:	a1 a8       	sbr	r8,0x0
80006914:	0e 99       	mov	r9,r7
80006916:	a1 a9       	sbr	r9,0x0
80006918:	8d 19       	st.w	r6[0x4],r9
8000691a:	ec 07 00 07 	add	r7,r6,r7
8000691e:	0a 9c       	mov	r12,r5
80006920:	89 27       	st.w	r4[0x8],r7
80006922:	8f 18       	st.w	r7[0x4],r8
80006924:	fe b0 f3 8c 	rcall	8000503c <__malloc_unlock>
80006928:	ec cc ff f8 	sub	r12,r6,-8
8000692c:	d8 32       	popm	r0-r7,pc
8000692e:	d7 03       	nop

80006930 <memcpy>:
80006930:	58 8a       	cp.w	r10,8
80006932:	c2 f5       	brlt	80006990 <memcpy+0x60>
80006934:	f9 eb 10 09 	or	r9,r12,r11
80006938:	e2 19 00 03 	andl	r9,0x3,COH
8000693c:	e0 81 00 97 	brne	80006a6a <memcpy+0x13a>
80006940:	e0 4a 00 20 	cp.w	r10,32
80006944:	c3 b4       	brge	800069ba <memcpy+0x8a>
80006946:	f4 08 14 02 	asr	r8,r10,0x2
8000694a:	f0 09 11 08 	rsub	r9,r8,8
8000694e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006952:	76 69       	ld.w	r9,r11[0x18]
80006954:	99 69       	st.w	r12[0x18],r9
80006956:	76 59       	ld.w	r9,r11[0x14]
80006958:	99 59       	st.w	r12[0x14],r9
8000695a:	76 49       	ld.w	r9,r11[0x10]
8000695c:	99 49       	st.w	r12[0x10],r9
8000695e:	76 39       	ld.w	r9,r11[0xc]
80006960:	99 39       	st.w	r12[0xc],r9
80006962:	76 29       	ld.w	r9,r11[0x8]
80006964:	99 29       	st.w	r12[0x8],r9
80006966:	76 19       	ld.w	r9,r11[0x4]
80006968:	99 19       	st.w	r12[0x4],r9
8000696a:	76 09       	ld.w	r9,r11[0x0]
8000696c:	99 09       	st.w	r12[0x0],r9
8000696e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006972:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006976:	e0 1a 00 03 	andl	r10,0x3
8000697a:	f4 0a 11 04 	rsub	r10,r10,4
8000697e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006982:	17 a9       	ld.ub	r9,r11[0x2]
80006984:	b0 a9       	st.b	r8[0x2],r9
80006986:	17 99       	ld.ub	r9,r11[0x1]
80006988:	b0 99       	st.b	r8[0x1],r9
8000698a:	17 89       	ld.ub	r9,r11[0x0]
8000698c:	b0 89       	st.b	r8[0x0],r9
8000698e:	5e fc       	retal	r12
80006990:	f4 0a 11 09 	rsub	r10,r10,9
80006994:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006998:	17 f9       	ld.ub	r9,r11[0x7]
8000699a:	b8 f9       	st.b	r12[0x7],r9
8000699c:	17 e9       	ld.ub	r9,r11[0x6]
8000699e:	b8 e9       	st.b	r12[0x6],r9
800069a0:	17 d9       	ld.ub	r9,r11[0x5]
800069a2:	b8 d9       	st.b	r12[0x5],r9
800069a4:	17 c9       	ld.ub	r9,r11[0x4]
800069a6:	b8 c9       	st.b	r12[0x4],r9
800069a8:	17 b9       	ld.ub	r9,r11[0x3]
800069aa:	b8 b9       	st.b	r12[0x3],r9
800069ac:	17 a9       	ld.ub	r9,r11[0x2]
800069ae:	b8 a9       	st.b	r12[0x2],r9
800069b0:	17 99       	ld.ub	r9,r11[0x1]
800069b2:	b8 99       	st.b	r12[0x1],r9
800069b4:	17 89       	ld.ub	r9,r11[0x0]
800069b6:	b8 89       	st.b	r12[0x0],r9
800069b8:	5e fc       	retal	r12
800069ba:	eb cd 40 c0 	pushm	r6-r7,lr
800069be:	18 99       	mov	r9,r12
800069c0:	22 0a       	sub	r10,32
800069c2:	b7 07       	ld.d	r6,r11++
800069c4:	b3 26       	st.d	r9++,r6
800069c6:	b7 07       	ld.d	r6,r11++
800069c8:	b3 26       	st.d	r9++,r6
800069ca:	b7 07       	ld.d	r6,r11++
800069cc:	b3 26       	st.d	r9++,r6
800069ce:	b7 07       	ld.d	r6,r11++
800069d0:	b3 26       	st.d	r9++,r6
800069d2:	22 0a       	sub	r10,32
800069d4:	cf 74       	brge	800069c2 <memcpy+0x92>
800069d6:	2f 0a       	sub	r10,-16
800069d8:	c0 65       	brlt	800069e4 <memcpy+0xb4>
800069da:	b7 07       	ld.d	r6,r11++
800069dc:	b3 26       	st.d	r9++,r6
800069de:	b7 07       	ld.d	r6,r11++
800069e0:	b3 26       	st.d	r9++,r6
800069e2:	21 0a       	sub	r10,16
800069e4:	5c 3a       	neg	r10
800069e6:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800069ea:	d7 03       	nop
800069ec:	d7 03       	nop
800069ee:	f7 36 00 0e 	ld.ub	r6,r11[14]
800069f2:	f3 66 00 0e 	st.b	r9[14],r6
800069f6:	f7 36 00 0d 	ld.ub	r6,r11[13]
800069fa:	f3 66 00 0d 	st.b	r9[13],r6
800069fe:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006a02:	f3 66 00 0c 	st.b	r9[12],r6
80006a06:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006a0a:	f3 66 00 0b 	st.b	r9[11],r6
80006a0e:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006a12:	f3 66 00 0a 	st.b	r9[10],r6
80006a16:	f7 36 00 09 	ld.ub	r6,r11[9]
80006a1a:	f3 66 00 09 	st.b	r9[9],r6
80006a1e:	f7 36 00 08 	ld.ub	r6,r11[8]
80006a22:	f3 66 00 08 	st.b	r9[8],r6
80006a26:	f7 36 00 07 	ld.ub	r6,r11[7]
80006a2a:	f3 66 00 07 	st.b	r9[7],r6
80006a2e:	f7 36 00 06 	ld.ub	r6,r11[6]
80006a32:	f3 66 00 06 	st.b	r9[6],r6
80006a36:	f7 36 00 05 	ld.ub	r6,r11[5]
80006a3a:	f3 66 00 05 	st.b	r9[5],r6
80006a3e:	f7 36 00 04 	ld.ub	r6,r11[4]
80006a42:	f3 66 00 04 	st.b	r9[4],r6
80006a46:	f7 36 00 03 	ld.ub	r6,r11[3]
80006a4a:	f3 66 00 03 	st.b	r9[3],r6
80006a4e:	f7 36 00 02 	ld.ub	r6,r11[2]
80006a52:	f3 66 00 02 	st.b	r9[2],r6
80006a56:	f7 36 00 01 	ld.ub	r6,r11[1]
80006a5a:	f3 66 00 01 	st.b	r9[1],r6
80006a5e:	f7 36 00 00 	ld.ub	r6,r11[0]
80006a62:	f3 66 00 00 	st.b	r9[0],r6
80006a66:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a6a:	20 1a       	sub	r10,1
80006a6c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006a70:	f8 0a 0b 09 	st.b	r12[r10],r9
80006a74:	cf b1       	brne	80006a6a <memcpy+0x13a>
80006a76:	5e fc       	retal	r12

80006a78 <memset>:
80006a78:	18 98       	mov	r8,r12
80006a7a:	c0 38       	rjmp	80006a80 <memset+0x8>
80006a7c:	10 cb       	st.b	r8++,r11
80006a7e:	20 1a       	sub	r10,1
80006a80:	58 0a       	cp.w	r10,0
80006a82:	cf d1       	brne	80006a7c <memset+0x4>
80006a84:	5e fc       	retal	r12
80006a86:	d7 03       	nop

80006a88 <_realloc_r>:
80006a88:	d4 31       	pushm	r0-r7,lr
80006a8a:	20 1d       	sub	sp,4
80006a8c:	16 94       	mov	r4,r11
80006a8e:	18 92       	mov	r2,r12
80006a90:	14 9b       	mov	r11,r10
80006a92:	58 04       	cp.w	r4,0
80006a94:	c0 51       	brne	80006a9e <_realloc_r+0x16>
80006a96:	fe b0 fd 31 	rcall	800064f8 <_malloc_r>
80006a9a:	18 95       	mov	r5,r12
80006a9c:	c5 39       	rjmp	80006d42 <_realloc_r+0x2ba>
80006a9e:	50 0a       	stdsp	sp[0x0],r10
80006aa0:	fe b0 f2 c8 	rcall	80005030 <__malloc_lock>
80006aa4:	40 0b       	lddsp	r11,sp[0x0]
80006aa6:	f6 c8 ff f5 	sub	r8,r11,-11
80006aaa:	e8 c1 00 08 	sub	r1,r4,8
80006aae:	10 96       	mov	r6,r8
80006ab0:	62 1c       	ld.w	r12,r1[0x4]
80006ab2:	e0 16 ff f8 	andl	r6,0xfff8
80006ab6:	59 68       	cp.w	r8,22
80006ab8:	f9 b6 08 10 	movls	r6,16
80006abc:	16 36       	cp.w	r6,r11
80006abe:	5f 38       	srlo	r8
80006ac0:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006ac4:	c0 50       	breq	80006ace <_realloc_r+0x46>
80006ac6:	30 c8       	mov	r8,12
80006ac8:	30 05       	mov	r5,0
80006aca:	85 38       	st.w	r2[0xc],r8
80006acc:	c3 b9       	rjmp	80006d42 <_realloc_r+0x2ba>
80006ace:	18 90       	mov	r0,r12
80006ad0:	e0 10 ff fc 	andl	r0,0xfffc
80006ad4:	0c 30       	cp.w	r0,r6
80006ad6:	e0 84 01 0b 	brge	80006cec <_realloc_r+0x264>
80006ada:	e0 68 05 44 	mov	r8,1348
80006ade:	e2 00 00 09 	add	r9,r1,r0
80006ae2:	70 25       	ld.w	r5,r8[0x8]
80006ae4:	0a 39       	cp.w	r9,r5
80006ae6:	c0 90       	breq	80006af8 <_realloc_r+0x70>
80006ae8:	72 1a       	ld.w	r10,r9[0x4]
80006aea:	a1 ca       	cbr	r10,0x0
80006aec:	f2 0a 00 0a 	add	r10,r9,r10
80006af0:	74 1a       	ld.w	r10,r10[0x4]
80006af2:	ed ba 00 00 	bld	r10,0x0
80006af6:	c2 20       	breq	80006b3a <_realloc_r+0xb2>
80006af8:	72 1a       	ld.w	r10,r9[0x4]
80006afa:	e0 1a ff fc 	andl	r10,0xfffc
80006afe:	f4 00 00 03 	add	r3,r10,r0
80006b02:	0a 39       	cp.w	r9,r5
80006b04:	c1 31       	brne	80006b2a <_realloc_r+0xa2>
80006b06:	ec c7 ff f0 	sub	r7,r6,-16
80006b0a:	0e 33       	cp.w	r3,r7
80006b0c:	c1 95       	brlt	80006b3e <_realloc_r+0xb6>
80006b0e:	e2 06 00 09 	add	r9,r1,r6
80006b12:	0c 13       	sub	r3,r6
80006b14:	a1 a3       	sbr	r3,0x0
80006b16:	93 13       	st.w	r9[0x4],r3
80006b18:	91 29       	st.w	r8[0x8],r9
80006b1a:	04 9c       	mov	r12,r2
80006b1c:	62 18       	ld.w	r8,r1[0x4]
80006b1e:	08 95       	mov	r5,r4
80006b20:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006b24:	10 46       	or	r6,r8
80006b26:	83 16       	st.w	r1[0x4],r6
80006b28:	c0 b9       	rjmp	80006d3e <_realloc_r+0x2b6>
80006b2a:	0c 33       	cp.w	r3,r6
80006b2c:	c0 95       	brlt	80006b3e <_realloc_r+0xb6>
80006b2e:	72 28       	ld.w	r8,r9[0x8]
80006b30:	02 97       	mov	r7,r1
80006b32:	72 39       	ld.w	r9,r9[0xc]
80006b34:	93 28       	st.w	r9[0x8],r8
80006b36:	91 39       	st.w	r8[0xc],r9
80006b38:	cd c8       	rjmp	80006cf0 <_realloc_r+0x268>
80006b3a:	30 0a       	mov	r10,0
80006b3c:	14 99       	mov	r9,r10
80006b3e:	ed bc 00 00 	bld	r12,0x0
80006b42:	e0 80 00 95 	breq	80006c6c <_realloc_r+0x1e4>
80006b46:	62 07       	ld.w	r7,r1[0x0]
80006b48:	e2 07 01 07 	sub	r7,r1,r7
80006b4c:	6e 1c       	ld.w	r12,r7[0x4]
80006b4e:	e0 1c ff fc 	andl	r12,0xfffc
80006b52:	58 09       	cp.w	r9,0
80006b54:	c5 60       	breq	80006c00 <_realloc_r+0x178>
80006b56:	f8 00 00 03 	add	r3,r12,r0
80006b5a:	0a 39       	cp.w	r9,r5
80006b5c:	c4 81       	brne	80006bec <_realloc_r+0x164>
80006b5e:	14 03       	add	r3,r10
80006b60:	ec c9 ff f0 	sub	r9,r6,-16
80006b64:	12 33       	cp.w	r3,r9
80006b66:	c4 d5       	brlt	80006c00 <_realloc_r+0x178>
80006b68:	6e 3a       	ld.w	r10,r7[0xc]
80006b6a:	6e 29       	ld.w	r9,r7[0x8]
80006b6c:	95 29       	st.w	r10[0x8],r9
80006b6e:	93 3a       	st.w	r9[0xc],r10
80006b70:	ee c5 ff f8 	sub	r5,r7,-8
80006b74:	e0 ca 00 04 	sub	r10,r0,4
80006b78:	e0 4a 00 24 	cp.w	r10,36
80006b7c:	e0 8b 00 25 	brhi	80006bc6 <_realloc_r+0x13e>
80006b80:	0a 99       	mov	r9,r5
80006b82:	59 3a       	cp.w	r10,19
80006b84:	e0 88 00 1a 	brls	80006bb8 <_realloc_r+0x130>
80006b88:	09 09       	ld.w	r9,r4++
80006b8a:	8b 09       	st.w	r5[0x0],r9
80006b8c:	09 09       	ld.w	r9,r4++
80006b8e:	8f 39       	st.w	r7[0xc],r9
80006b90:	ee c9 ff f0 	sub	r9,r7,-16
80006b94:	59 ba       	cp.w	r10,27
80006b96:	e0 88 00 11 	brls	80006bb8 <_realloc_r+0x130>
80006b9a:	09 0b       	ld.w	r11,r4++
80006b9c:	93 0b       	st.w	r9[0x0],r11
80006b9e:	09 09       	ld.w	r9,r4++
80006ba0:	8f 59       	st.w	r7[0x14],r9
80006ba2:	ee c9 ff e8 	sub	r9,r7,-24
80006ba6:	e0 4a 00 24 	cp.w	r10,36
80006baa:	c0 71       	brne	80006bb8 <_realloc_r+0x130>
80006bac:	09 0a       	ld.w	r10,r4++
80006bae:	93 0a       	st.w	r9[0x0],r10
80006bb0:	ee c9 ff e0 	sub	r9,r7,-32
80006bb4:	09 0a       	ld.w	r10,r4++
80006bb6:	8f 7a       	st.w	r7[0x1c],r10
80006bb8:	09 0a       	ld.w	r10,r4++
80006bba:	12 aa       	st.w	r9++,r10
80006bbc:	68 0a       	ld.w	r10,r4[0x0]
80006bbe:	93 0a       	st.w	r9[0x0],r10
80006bc0:	68 1a       	ld.w	r10,r4[0x4]
80006bc2:	93 1a       	st.w	r9[0x4],r10
80006bc4:	c0 78       	rjmp	80006bd2 <_realloc_r+0x14a>
80006bc6:	50 08       	stdsp	sp[0x0],r8
80006bc8:	08 9b       	mov	r11,r4
80006bca:	0a 9c       	mov	r12,r5
80006bcc:	e0 a0 1d 9b 	rcall	8000a702 <memmove>
80006bd0:	40 08       	lddsp	r8,sp[0x0]
80006bd2:	ee 06 00 09 	add	r9,r7,r6
80006bd6:	0c 13       	sub	r3,r6
80006bd8:	a1 a3       	sbr	r3,0x0
80006bda:	93 13       	st.w	r9[0x4],r3
80006bdc:	91 29       	st.w	r8[0x8],r9
80006bde:	04 9c       	mov	r12,r2
80006be0:	6e 18       	ld.w	r8,r7[0x4]
80006be2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006be6:	10 46       	or	r6,r8
80006be8:	8f 16       	st.w	r7[0x4],r6
80006bea:	ca a8       	rjmp	80006d3e <_realloc_r+0x2b6>
80006bec:	14 03       	add	r3,r10
80006bee:	0c 33       	cp.w	r3,r6
80006bf0:	c0 85       	brlt	80006c00 <_realloc_r+0x178>
80006bf2:	72 28       	ld.w	r8,r9[0x8]
80006bf4:	72 39       	ld.w	r9,r9[0xc]
80006bf6:	93 28       	st.w	r9[0x8],r8
80006bf8:	91 39       	st.w	r8[0xc],r9
80006bfa:	6e 28       	ld.w	r8,r7[0x8]
80006bfc:	6e 39       	ld.w	r9,r7[0xc]
80006bfe:	c0 78       	rjmp	80006c0c <_realloc_r+0x184>
80006c00:	f8 00 00 03 	add	r3,r12,r0
80006c04:	0c 33       	cp.w	r3,r6
80006c06:	c3 35       	brlt	80006c6c <_realloc_r+0x1e4>
80006c08:	6e 39       	ld.w	r9,r7[0xc]
80006c0a:	6e 28       	ld.w	r8,r7[0x8]
80006c0c:	93 28       	st.w	r9[0x8],r8
80006c0e:	91 39       	st.w	r8[0xc],r9
80006c10:	e0 ca 00 04 	sub	r10,r0,4
80006c14:	ee cc ff f8 	sub	r12,r7,-8
80006c18:	e0 4a 00 24 	cp.w	r10,36
80006c1c:	e0 8b 00 24 	brhi	80006c64 <_realloc_r+0x1dc>
80006c20:	59 3a       	cp.w	r10,19
80006c22:	e0 88 00 1a 	brls	80006c56 <_realloc_r+0x1ce>
80006c26:	09 08       	ld.w	r8,r4++
80006c28:	99 08       	st.w	r12[0x0],r8
80006c2a:	09 08       	ld.w	r8,r4++
80006c2c:	8f 38       	st.w	r7[0xc],r8
80006c2e:	ee cc ff f0 	sub	r12,r7,-16
80006c32:	59 ba       	cp.w	r10,27
80006c34:	e0 88 00 11 	brls	80006c56 <_realloc_r+0x1ce>
80006c38:	09 08       	ld.w	r8,r4++
80006c3a:	99 08       	st.w	r12[0x0],r8
80006c3c:	09 08       	ld.w	r8,r4++
80006c3e:	8f 58       	st.w	r7[0x14],r8
80006c40:	ee cc ff e8 	sub	r12,r7,-24
80006c44:	e0 4a 00 24 	cp.w	r10,36
80006c48:	c0 71       	brne	80006c56 <_realloc_r+0x1ce>
80006c4a:	09 08       	ld.w	r8,r4++
80006c4c:	99 08       	st.w	r12[0x0],r8
80006c4e:	ee cc ff e0 	sub	r12,r7,-32
80006c52:	09 08       	ld.w	r8,r4++
80006c54:	8f 78       	st.w	r7[0x1c],r8
80006c56:	09 08       	ld.w	r8,r4++
80006c58:	18 a8       	st.w	r12++,r8
80006c5a:	68 08       	ld.w	r8,r4[0x0]
80006c5c:	99 08       	st.w	r12[0x0],r8
80006c5e:	68 18       	ld.w	r8,r4[0x4]
80006c60:	99 18       	st.w	r12[0x4],r8
80006c62:	c4 78       	rjmp	80006cf0 <_realloc_r+0x268>
80006c64:	08 9b       	mov	r11,r4
80006c66:	e0 a0 1d 4e 	rcall	8000a702 <memmove>
80006c6a:	c4 38       	rjmp	80006cf0 <_realloc_r+0x268>
80006c6c:	04 9c       	mov	r12,r2
80006c6e:	fe b0 fc 45 	rcall	800064f8 <_malloc_r>
80006c72:	18 95       	mov	r5,r12
80006c74:	c3 a0       	breq	80006ce8 <_realloc_r+0x260>
80006c76:	62 18       	ld.w	r8,r1[0x4]
80006c78:	f8 c9 00 08 	sub	r9,r12,8
80006c7c:	a1 c8       	cbr	r8,0x0
80006c7e:	e2 08 00 08 	add	r8,r1,r8
80006c82:	10 39       	cp.w	r9,r8
80006c84:	c0 71       	brne	80006c92 <_realloc_r+0x20a>
80006c86:	72 13       	ld.w	r3,r9[0x4]
80006c88:	02 97       	mov	r7,r1
80006c8a:	e0 13 ff fc 	andl	r3,0xfffc
80006c8e:	00 03       	add	r3,r0
80006c90:	c3 08       	rjmp	80006cf0 <_realloc_r+0x268>
80006c92:	e0 ca 00 04 	sub	r10,r0,4
80006c96:	e0 4a 00 24 	cp.w	r10,36
80006c9a:	e0 8b 00 20 	brhi	80006cda <_realloc_r+0x252>
80006c9e:	08 99       	mov	r9,r4
80006ca0:	18 98       	mov	r8,r12
80006ca2:	59 3a       	cp.w	r10,19
80006ca4:	e0 88 00 14 	brls	80006ccc <_realloc_r+0x244>
80006ca8:	13 0b       	ld.w	r11,r9++
80006caa:	10 ab       	st.w	r8++,r11
80006cac:	13 0b       	ld.w	r11,r9++
80006cae:	10 ab       	st.w	r8++,r11
80006cb0:	59 ba       	cp.w	r10,27
80006cb2:	e0 88 00 0d 	brls	80006ccc <_realloc_r+0x244>
80006cb6:	13 0b       	ld.w	r11,r9++
80006cb8:	10 ab       	st.w	r8++,r11
80006cba:	13 0b       	ld.w	r11,r9++
80006cbc:	10 ab       	st.w	r8++,r11
80006cbe:	e0 4a 00 24 	cp.w	r10,36
80006cc2:	c0 51       	brne	80006ccc <_realloc_r+0x244>
80006cc4:	13 0a       	ld.w	r10,r9++
80006cc6:	10 aa       	st.w	r8++,r10
80006cc8:	13 0a       	ld.w	r10,r9++
80006cca:	10 aa       	st.w	r8++,r10
80006ccc:	13 0a       	ld.w	r10,r9++
80006cce:	10 aa       	st.w	r8++,r10
80006cd0:	72 0a       	ld.w	r10,r9[0x0]
80006cd2:	91 0a       	st.w	r8[0x0],r10
80006cd4:	72 19       	ld.w	r9,r9[0x4]
80006cd6:	91 19       	st.w	r8[0x4],r9
80006cd8:	c0 48       	rjmp	80006ce0 <_realloc_r+0x258>
80006cda:	08 9b       	mov	r11,r4
80006cdc:	e0 a0 1d 13 	rcall	8000a702 <memmove>
80006ce0:	08 9b       	mov	r11,r4
80006ce2:	04 9c       	mov	r12,r2
80006ce4:	e0 a0 1a 6c 	rcall	8000a1bc <_free_r>
80006ce8:	04 9c       	mov	r12,r2
80006cea:	c2 a8       	rjmp	80006d3e <_realloc_r+0x2b6>
80006cec:	00 93       	mov	r3,r0
80006cee:	02 97       	mov	r7,r1
80006cf0:	e6 06 01 09 	sub	r9,r3,r6
80006cf4:	6e 18       	ld.w	r8,r7[0x4]
80006cf6:	58 f9       	cp.w	r9,15
80006cf8:	e0 88 00 16 	brls	80006d24 <_realloc_r+0x29c>
80006cfc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d00:	ed e8 10 08 	or	r8,r6,r8
80006d04:	8f 18       	st.w	r7[0x4],r8
80006d06:	12 98       	mov	r8,r9
80006d08:	a1 a8       	sbr	r8,0x0
80006d0a:	ee 06 00 0b 	add	r11,r7,r6
80006d0e:	f6 09 00 09 	add	r9,r11,r9
80006d12:	97 18       	st.w	r11[0x4],r8
80006d14:	72 18       	ld.w	r8,r9[0x4]
80006d16:	a1 a8       	sbr	r8,0x0
80006d18:	2f 8b       	sub	r11,-8
80006d1a:	93 18       	st.w	r9[0x4],r8
80006d1c:	04 9c       	mov	r12,r2
80006d1e:	e0 a0 1a 4f 	rcall	8000a1bc <_free_r>
80006d22:	c0 b8       	rjmp	80006d38 <_realloc_r+0x2b0>
80006d24:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d28:	e7 e8 10 08 	or	r8,r3,r8
80006d2c:	8f 18       	st.w	r7[0x4],r8
80006d2e:	ee 03 00 03 	add	r3,r7,r3
80006d32:	66 18       	ld.w	r8,r3[0x4]
80006d34:	a1 a8       	sbr	r8,0x0
80006d36:	87 18       	st.w	r3[0x4],r8
80006d38:	04 9c       	mov	r12,r2
80006d3a:	ee c5 ff f8 	sub	r5,r7,-8
80006d3e:	fe b0 f1 7f 	rcall	8000503c <__malloc_unlock>
80006d42:	0a 9c       	mov	r12,r5
80006d44:	2f fd       	sub	sp,-4
80006d46:	d8 32       	popm	r0-r7,pc

80006d48 <_sbrk_r>:
80006d48:	d4 21       	pushm	r4-r7,lr
80006d4a:	30 08       	mov	r8,0
80006d4c:	18 97       	mov	r7,r12
80006d4e:	e0 66 40 fc 	mov	r6,16636
80006d52:	16 9c       	mov	r12,r11
80006d54:	8d 08       	st.w	r6[0x0],r8
80006d56:	c9 1c       	rcall	80006e78 <_sbrk>
80006d58:	5b fc       	cp.w	r12,-1
80006d5a:	c0 51       	brne	80006d64 <_sbrk_r+0x1c>
80006d5c:	6c 08       	ld.w	r8,r6[0x0]
80006d5e:	58 08       	cp.w	r8,0
80006d60:	ef f8 1a 03 	st.wne	r7[0xc],r8
80006d64:	d8 22       	popm	r4-r7,pc
80006d66:	d7 03       	nop

80006d68 <sprintf>:
80006d68:	d4 01       	pushm	lr
80006d6a:	21 7d       	sub	sp,92
80006d6c:	e0 68 ff ff 	mov	r8,65535
80006d70:	ea 18 7f ff 	orh	r8,0x7fff
80006d74:	50 58       	stdsp	sp[0x14],r8
80006d76:	50 28       	stdsp	sp[0x8],r8
80006d78:	e0 68 02 08 	mov	r8,520
80006d7c:	ba 68       	st.h	sp[0xc],r8
80006d7e:	3f f8       	mov	r8,-1
80006d80:	ba 78       	st.h	sp[0xe],r8
80006d82:	e0 68 0a 44 	mov	r8,2628
80006d86:	50 4c       	stdsp	sp[0x10],r12
80006d88:	16 9a       	mov	r10,r11
80006d8a:	50 0c       	stdsp	sp[0x0],r12
80006d8c:	fa c9 ff a0 	sub	r9,sp,-96
80006d90:	70 0c       	ld.w	r12,r8[0x0]
80006d92:	1a 9b       	mov	r11,sp
80006d94:	e0 a0 02 26 	rcall	800071e0 <_vfprintf_r>
80006d98:	30 09       	mov	r9,0
80006d9a:	40 08       	lddsp	r8,sp[0x0]
80006d9c:	b0 89       	st.b	r8[0x0],r9
80006d9e:	2e 9d       	sub	sp,-92
80006da0:	d8 02       	popm	pc
80006da2:	d7 03       	nop

80006da4 <strlen>:
80006da4:	30 09       	mov	r9,0
80006da6:	18 98       	mov	r8,r12
80006da8:	c0 28       	rjmp	80006dac <strlen+0x8>
80006daa:	2f f8       	sub	r8,-1
80006dac:	11 8a       	ld.ub	r10,r8[0x0]
80006dae:	f2 0a 18 00 	cp.b	r10,r9
80006db2:	cf c1       	brne	80006daa <strlen+0x6>
80006db4:	f0 0c 01 0c 	sub	r12,r8,r12
80006db8:	5e fc       	retal	r12
80006dba:	d7 03       	nop

80006dbc <strncpy>:
80006dbc:	30 08       	mov	r8,0
80006dbe:	10 3a       	cp.w	r10,r8
80006dc0:	5e 0c       	reteq	r12
80006dc2:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006dc6:	f8 08 0b 09 	st.b	r12[r8],r9
80006dca:	2f f8       	sub	r8,-1
80006dcc:	58 09       	cp.w	r9,0
80006dce:	cf 81       	brne	80006dbe <strncpy+0x2>
80006dd0:	10 3a       	cp.w	r10,r8
80006dd2:	5e 0c       	reteq	r12
80006dd4:	f8 08 0b 09 	st.b	r12[r8],r9
80006dd8:	2f f8       	sub	r8,-1
80006dda:	cf bb       	rjmp	80006dd0 <strncpy+0x14>

80006ddc <_close>:
80006ddc:	30 28       	mov	r8,2
80006dde:	d6 73       	breakpoint
80006de0:	3f fc       	mov	r12,-1
80006de2:	35 8b       	mov	r11,88
80006de4:	58 0c       	cp.w	r12,0
80006de6:	5e 4c       	retge	r12
80006de8:	e0 6a 40 fc 	mov	r10,16636
80006dec:	95 0b       	st.w	r10[0x0],r11
80006dee:	5e fc       	retal	r12

80006df0 <_lseek>:
80006df0:	30 58       	mov	r8,5
80006df2:	d6 73       	breakpoint
80006df4:	3f fc       	mov	r12,-1
80006df6:	35 8b       	mov	r11,88
80006df8:	58 0c       	cp.w	r12,0
80006dfa:	5e 4c       	retge	r12
80006dfc:	e0 6a 40 fc 	mov	r10,16636
80006e00:	95 0b       	st.w	r10[0x0],r11
80006e02:	5e fc       	retal	r12

80006e04 <isatty>:
80006e04:	30 b8       	mov	r8,11
80006e06:	d6 73       	breakpoint
80006e08:	3f fc       	mov	r12,-1
80006e0a:	35 8b       	mov	r11,88
80006e0c:	58 0c       	cp.w	r12,0
80006e0e:	5e 4c       	retge	r12
80006e10:	e0 6a 40 fc 	mov	r10,16636
80006e14:	95 0b       	st.w	r10[0x0],r11
80006e16:	5e fc       	retal	r12

80006e18 <_fstat_host>:
80006e18:	30 98       	mov	r8,9
80006e1a:	d6 73       	breakpoint
80006e1c:	3f fc       	mov	r12,-1
80006e1e:	35 8b       	mov	r11,88
80006e20:	58 0c       	cp.w	r12,0
80006e22:	5e 4c       	retge	r12
80006e24:	e0 6a 40 fc 	mov	r10,16636
80006e28:	95 0b       	st.w	r10[0x0],r11
80006e2a:	5e fc       	retal	r12

80006e2c <_fstat>:
80006e2c:	d4 21       	pushm	r4-r7,lr
80006e2e:	21 0d       	sub	sp,64
80006e30:	16 97       	mov	r7,r11
80006e32:	1a 9b       	mov	r11,sp
80006e34:	cf 2f       	rcall	80006e18 <_fstat_host>
80006e36:	c0 34       	brge	80006e3c <_fstat+0x10>
80006e38:	3f fc       	mov	r12,-1
80006e3a:	c1 c8       	rjmp	80006e72 <_fstat+0x46>
80006e3c:	40 08       	lddsp	r8,sp[0x0]
80006e3e:	ae 08       	st.h	r7[0x0],r8
80006e40:	40 18       	lddsp	r8,sp[0x4]
80006e42:	ae 18       	st.h	r7[0x2],r8
80006e44:	40 28       	lddsp	r8,sp[0x8]
80006e46:	8f 18       	st.w	r7[0x4],r8
80006e48:	40 38       	lddsp	r8,sp[0xc]
80006e4a:	ae 48       	st.h	r7[0x8],r8
80006e4c:	40 48       	lddsp	r8,sp[0x10]
80006e4e:	ae 58       	st.h	r7[0xa],r8
80006e50:	40 58       	lddsp	r8,sp[0x14]
80006e52:	ae 68       	st.h	r7[0xc],r8
80006e54:	40 68       	lddsp	r8,sp[0x18]
80006e56:	ae 78       	st.h	r7[0xe],r8
80006e58:	40 88       	lddsp	r8,sp[0x20]
80006e5a:	8f 48       	st.w	r7[0x10],r8
80006e5c:	40 a8       	lddsp	r8,sp[0x28]
80006e5e:	8f b8       	st.w	r7[0x2c],r8
80006e60:	40 c8       	lddsp	r8,sp[0x30]
80006e62:	8f c8       	st.w	r7[0x30],r8
80006e64:	40 d8       	lddsp	r8,sp[0x34]
80006e66:	8f 58       	st.w	r7[0x14],r8
80006e68:	40 e8       	lddsp	r8,sp[0x38]
80006e6a:	30 0c       	mov	r12,0
80006e6c:	8f 78       	st.w	r7[0x1c],r8
80006e6e:	40 f8       	lddsp	r8,sp[0x3c]
80006e70:	8f 98       	st.w	r7[0x24],r8
80006e72:	2f 0d       	sub	sp,-64
80006e74:	d8 22       	popm	r4-r7,pc
80006e76:	d7 03       	nop

80006e78 <_sbrk>:
80006e78:	d4 01       	pushm	lr
80006e7a:	e0 68 0d 78 	mov	r8,3448
80006e7e:	70 09       	ld.w	r9,r8[0x0]
80006e80:	58 09       	cp.w	r9,0
80006e82:	c0 41       	brne	80006e8a <_sbrk+0x12>
80006e84:	e0 69 41 00 	mov	r9,16640
80006e88:	91 09       	st.w	r8[0x0],r9
80006e8a:	e0 69 0d 78 	mov	r9,3448
80006e8e:	e0 7a 70 00 	mov	r10,94208
80006e92:	72 08       	ld.w	r8,r9[0x0]
80006e94:	f0 0c 00 0c 	add	r12,r8,r12
80006e98:	14 3c       	cp.w	r12,r10
80006e9a:	e0 8b 00 04 	brhi	80006ea2 <_sbrk+0x2a>
80006e9e:	93 0c       	st.w	r9[0x0],r12
80006ea0:	c0 68       	rjmp	80006eac <_sbrk+0x34>
80006ea2:	e0 a0 18 15 	rcall	80009ecc <__errno>
80006ea6:	30 c8       	mov	r8,12
80006ea8:	99 08       	st.w	r12[0x0],r8
80006eaa:	3f f8       	mov	r8,-1
80006eac:	10 9c       	mov	r12,r8
80006eae:	d8 02       	popm	pc

80006eb0 <get_arg>:
80006eb0:	d4 31       	pushm	r0-r7,lr
80006eb2:	20 8d       	sub	sp,32
80006eb4:	fa c4 ff bc 	sub	r4,sp,-68
80006eb8:	50 4b       	stdsp	sp[0x10],r11
80006eba:	68 2e       	ld.w	lr,r4[0x8]
80006ebc:	50 58       	stdsp	sp[0x14],r8
80006ebe:	12 96       	mov	r6,r9
80006ec0:	7c 0b       	ld.w	r11,lr[0x0]
80006ec2:	70 05       	ld.w	r5,r8[0x0]
80006ec4:	50 6e       	stdsp	sp[0x18],lr
80006ec6:	58 0b       	cp.w	r11,0
80006ec8:	f4 0b 17 00 	moveq	r11,r10
80006ecc:	68 03       	ld.w	r3,r4[0x0]
80006ece:	68 11       	ld.w	r1,r4[0x4]
80006ed0:	40 49       	lddsp	r9,sp[0x10]
80006ed2:	30 08       	mov	r8,0
80006ed4:	c2 89       	rjmp	80007124 <get_arg+0x274>
80006ed6:	2f fb       	sub	r11,-1
80006ed8:	32 5c       	mov	r12,37
80006eda:	17 8a       	ld.ub	r10,r11[0x0]
80006edc:	f8 0a 18 00 	cp.b	r10,r12
80006ee0:	5f 1e       	srne	lr
80006ee2:	f0 0a 18 00 	cp.b	r10,r8
80006ee6:	5f 1c       	srne	r12
80006ee8:	fd ec 00 0c 	and	r12,lr,r12
80006eec:	f0 0c 18 00 	cp.b	r12,r8
80006ef0:	cf 31       	brne	80006ed6 <get_arg+0x26>
80006ef2:	58 0a       	cp.w	r10,0
80006ef4:	e0 80 01 25 	breq	8000713e <get_arg+0x28e>
80006ef8:	30 0c       	mov	r12,0
80006efa:	3f fa       	mov	r10,-1
80006efc:	18 90       	mov	r0,r12
80006efe:	50 3a       	stdsp	sp[0xc],r10
80006f00:	18 94       	mov	r4,r12
80006f02:	18 92       	mov	r2,r12
80006f04:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006f08:	16 97       	mov	r7,r11
80006f0a:	50 7c       	stdsp	sp[0x1c],r12
80006f0c:	fe cc a0 70 	sub	r12,pc,-24464
80006f10:	0f 3a       	ld.ub	r10,r7++
80006f12:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006f16:	40 7c       	lddsp	r12,sp[0x1c]
80006f18:	1c 0c       	add	r12,lr
80006f1a:	fe ce a1 46 	sub	lr,pc,-24250
80006f1e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006f22:	20 1e       	sub	lr,1
80006f24:	50 0e       	stdsp	sp[0x0],lr
80006f26:	fe ce a1 be 	sub	lr,pc,-24130
80006f2a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006f2e:	50 7c       	stdsp	sp[0x1c],r12
80006f30:	40 0c       	lddsp	r12,sp[0x0]
80006f32:	58 7c       	cp.w	r12,7
80006f34:	e0 8b 00 f1 	brhi	80007116 <get_arg+0x266>
80006f38:	fe ce a3 70 	sub	lr,pc,-23696
80006f3c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006f40:	36 8b       	mov	r11,104
80006f42:	f6 0a 18 00 	cp.b	r10,r11
80006f46:	e0 80 00 e8 	breq	80007116 <get_arg+0x266>
80006f4a:	37 1b       	mov	r11,113
80006f4c:	f6 0a 18 00 	cp.b	r10,r11
80006f50:	c0 70       	breq	80006f5e <get_arg+0xae>
80006f52:	34 cb       	mov	r11,76
80006f54:	f6 0a 18 00 	cp.b	r10,r11
80006f58:	c0 51       	brne	80006f62 <get_arg+0xb2>
80006f5a:	a3 b4       	sbr	r4,0x3
80006f5c:	cd d8       	rjmp	80007116 <get_arg+0x266>
80006f5e:	a5 b4       	sbr	r4,0x5
80006f60:	cd b8       	rjmp	80007116 <get_arg+0x266>
80006f62:	08 9a       	mov	r10,r4
80006f64:	0e 9b       	mov	r11,r7
80006f66:	a5 aa       	sbr	r10,0x4
80006f68:	17 3c       	ld.ub	r12,r11++
80006f6a:	a5 b4       	sbr	r4,0x5
80006f6c:	36 ce       	mov	lr,108
80006f6e:	fc 0c 18 00 	cp.b	r12,lr
80006f72:	e0 80 00 d3 	breq	80007118 <get_arg+0x268>
80006f76:	14 94       	mov	r4,r10
80006f78:	cc f8       	rjmp	80007116 <get_arg+0x266>
80006f7a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006f7e:	36 7c       	mov	r12,103
80006f80:	f8 0a 18 00 	cp.b	r10,r12
80006f84:	e0 8b 00 27 	brhi	80006fd2 <get_arg+0x122>
80006f88:	36 5b       	mov	r11,101
80006f8a:	f6 0a 18 00 	cp.b	r10,r11
80006f8e:	c4 82       	brcc	8000701e <get_arg+0x16e>
80006f90:	34 fb       	mov	r11,79
80006f92:	f6 0a 18 00 	cp.b	r10,r11
80006f96:	c4 80       	breq	80007026 <get_arg+0x176>
80006f98:	e0 8b 00 0c 	brhi	80006fb0 <get_arg+0x100>
80006f9c:	34 5b       	mov	r11,69
80006f9e:	f6 0a 18 00 	cp.b	r10,r11
80006fa2:	c3 e0       	breq	8000701e <get_arg+0x16e>
80006fa4:	34 7b       	mov	r11,71
80006fa6:	f6 0a 18 00 	cp.b	r10,r11
80006faa:	c3 a0       	breq	8000701e <get_arg+0x16e>
80006fac:	34 4b       	mov	r11,68
80006fae:	c0 88       	rjmp	80006fbe <get_arg+0x10e>
80006fb0:	35 8b       	mov	r11,88
80006fb2:	f6 0a 18 00 	cp.b	r10,r11
80006fb6:	c2 c0       	breq	8000700e <get_arg+0x15e>
80006fb8:	e0 8b 00 07 	brhi	80006fc6 <get_arg+0x116>
80006fbc:	35 5b       	mov	r11,85
80006fbe:	f6 0a 18 00 	cp.b	r10,r11
80006fc2:	c3 51       	brne	8000702c <get_arg+0x17c>
80006fc4:	c3 18       	rjmp	80007026 <get_arg+0x176>
80006fc6:	36 3b       	mov	r11,99
80006fc8:	f6 0a 18 00 	cp.b	r10,r11
80006fcc:	c2 f0       	breq	8000702a <get_arg+0x17a>
80006fce:	36 4b       	mov	r11,100
80006fd0:	c0 e8       	rjmp	80006fec <get_arg+0x13c>
80006fd2:	37 0b       	mov	r11,112
80006fd4:	f6 0a 18 00 	cp.b	r10,r11
80006fd8:	c2 50       	breq	80007022 <get_arg+0x172>
80006fda:	e0 8b 00 0d 	brhi	80006ff4 <get_arg+0x144>
80006fde:	36 eb       	mov	r11,110
80006fe0:	f6 0a 18 00 	cp.b	r10,r11
80006fe4:	c1 f0       	breq	80007022 <get_arg+0x172>
80006fe6:	e0 8b 00 14 	brhi	8000700e <get_arg+0x15e>
80006fea:	36 9b       	mov	r11,105
80006fec:	f6 0a 18 00 	cp.b	r10,r11
80006ff0:	c1 e1       	brne	8000702c <get_arg+0x17c>
80006ff2:	c0 e8       	rjmp	8000700e <get_arg+0x15e>
80006ff4:	37 5b       	mov	r11,117
80006ff6:	f6 0a 18 00 	cp.b	r10,r11
80006ffa:	c0 a0       	breq	8000700e <get_arg+0x15e>
80006ffc:	37 8b       	mov	r11,120
80006ffe:	f6 0a 18 00 	cp.b	r10,r11
80007002:	c0 60       	breq	8000700e <get_arg+0x15e>
80007004:	37 3b       	mov	r11,115
80007006:	f6 0a 18 00 	cp.b	r10,r11
8000700a:	c1 11       	brne	8000702c <get_arg+0x17c>
8000700c:	c0 b8       	rjmp	80007022 <get_arg+0x172>
8000700e:	ed b4 00 04 	bld	r4,0x4
80007012:	c0 a0       	breq	80007026 <get_arg+0x176>
80007014:	ed b4 00 05 	bld	r4,0x5
80007018:	c0 91       	brne	8000702a <get_arg+0x17a>
8000701a:	30 20       	mov	r0,2
8000701c:	c0 88       	rjmp	8000702c <get_arg+0x17c>
8000701e:	30 40       	mov	r0,4
80007020:	c0 68       	rjmp	8000702c <get_arg+0x17c>
80007022:	30 30       	mov	r0,3
80007024:	c0 48       	rjmp	8000702c <get_arg+0x17c>
80007026:	30 10       	mov	r0,1
80007028:	c0 28       	rjmp	8000702c <get_arg+0x17c>
8000702a:	30 00       	mov	r0,0
8000702c:	40 3b       	lddsp	r11,sp[0xc]
8000702e:	5b fb       	cp.w	r11,-1
80007030:	c0 40       	breq	80007038 <get_arg+0x188>
80007032:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007036:	c7 08       	rjmp	80007116 <get_arg+0x266>
80007038:	58 60       	cp.w	r0,6
8000703a:	e0 8b 00 6e 	brhi	80007116 <get_arg+0x266>
8000703e:	6c 0a       	ld.w	r10,r6[0x0]
80007040:	ea cc ff ff 	sub	r12,r5,-1
80007044:	fe ce a4 5c 	sub	lr,pc,-23460
80007048:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000704c:	f4 cb ff f8 	sub	r11,r10,-8
80007050:	8d 0b       	st.w	r6[0x0],r11
80007052:	f4 ea 00 00 	ld.d	r10,r10[0]
80007056:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000705a:	c0 f8       	rjmp	80007078 <get_arg+0x1c8>
8000705c:	f4 cb ff fc 	sub	r11,r10,-4
80007060:	8d 0b       	st.w	r6[0x0],r11
80007062:	74 0a       	ld.w	r10,r10[0x0]
80007064:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007068:	c0 88       	rjmp	80007078 <get_arg+0x1c8>
8000706a:	f4 cb ff f8 	sub	r11,r10,-8
8000706e:	8d 0b       	st.w	r6[0x0],r11
80007070:	f4 ea 00 00 	ld.d	r10,r10[0]
80007074:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007078:	0e 9b       	mov	r11,r7
8000707a:	18 95       	mov	r5,r12
8000707c:	c4 e8       	rjmp	80007118 <get_arg+0x268>
8000707e:	62 0a       	ld.w	r10,r1[0x0]
80007080:	5b fa       	cp.w	r10,-1
80007082:	c0 b1       	brne	80007098 <get_arg+0x1e8>
80007084:	50 19       	stdsp	sp[0x4],r9
80007086:	50 28       	stdsp	sp[0x8],r8
80007088:	e0 6a 00 80 	mov	r10,128
8000708c:	30 0b       	mov	r11,0
8000708e:	02 9c       	mov	r12,r1
80007090:	fe b0 fc f4 	rcall	80006a78 <memset>
80007094:	40 28       	lddsp	r8,sp[0x8]
80007096:	40 19       	lddsp	r9,sp[0x4]
80007098:	e4 cc 00 01 	sub	r12,r2,1
8000709c:	0e 9b       	mov	r11,r7
8000709e:	50 3c       	stdsp	sp[0xc],r12
800070a0:	f2 0c 0c 49 	max	r9,r9,r12
800070a4:	c3 a8       	rjmp	80007118 <get_arg+0x268>
800070a6:	62 0a       	ld.w	r10,r1[0x0]
800070a8:	5b fa       	cp.w	r10,-1
800070aa:	c0 b1       	brne	800070c0 <get_arg+0x210>
800070ac:	50 19       	stdsp	sp[0x4],r9
800070ae:	50 28       	stdsp	sp[0x8],r8
800070b0:	e0 6a 00 80 	mov	r10,128
800070b4:	30 0b       	mov	r11,0
800070b6:	02 9c       	mov	r12,r1
800070b8:	fe b0 fc e0 	rcall	80006a78 <memset>
800070bc:	40 28       	lddsp	r8,sp[0x8]
800070be:	40 19       	lddsp	r9,sp[0x4]
800070c0:	20 12       	sub	r2,1
800070c2:	30 0a       	mov	r10,0
800070c4:	0e 9b       	mov	r11,r7
800070c6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800070ca:	f2 02 0c 49 	max	r9,r9,r2
800070ce:	c2 58       	rjmp	80007118 <get_arg+0x268>
800070d0:	16 97       	mov	r7,r11
800070d2:	6c 0a       	ld.w	r10,r6[0x0]
800070d4:	f4 cb ff fc 	sub	r11,r10,-4
800070d8:	8d 0b       	st.w	r6[0x0],r11
800070da:	74 0a       	ld.w	r10,r10[0x0]
800070dc:	0e 9b       	mov	r11,r7
800070de:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800070e2:	2f f5       	sub	r5,-1
800070e4:	c1 a8       	rjmp	80007118 <get_arg+0x268>
800070e6:	f4 c2 00 30 	sub	r2,r10,48
800070ea:	c0 68       	rjmp	800070f6 <get_arg+0x246>
800070ec:	e4 02 00 22 	add	r2,r2,r2<<0x2
800070f0:	2f f7       	sub	r7,-1
800070f2:	f4 02 00 12 	add	r2,r10,r2<<0x1
800070f6:	0f 8a       	ld.ub	r10,r7[0x0]
800070f8:	58 0a       	cp.w	r10,0
800070fa:	c0 e0       	breq	80007116 <get_arg+0x266>
800070fc:	23 0a       	sub	r10,48
800070fe:	58 9a       	cp.w	r10,9
80007100:	fe 98 ff f6 	brls	800070ec <get_arg+0x23c>
80007104:	c0 98       	rjmp	80007116 <get_arg+0x266>
80007106:	2f f7       	sub	r7,-1
80007108:	0f 8a       	ld.ub	r10,r7[0x0]
8000710a:	58 0a       	cp.w	r10,0
8000710c:	c0 50       	breq	80007116 <get_arg+0x266>
8000710e:	23 0a       	sub	r10,48
80007110:	58 9a       	cp.w	r10,9
80007112:	fe 98 ff fa 	brls	80007106 <get_arg+0x256>
80007116:	0e 9b       	mov	r11,r7
80007118:	40 7c       	lddsp	r12,sp[0x1c]
8000711a:	30 ba       	mov	r10,11
8000711c:	f4 0c 18 00 	cp.b	r12,r10
80007120:	fe 91 fe f2 	brne	80006f04 <get_arg+0x54>
80007124:	40 42       	lddsp	r2,sp[0x10]
80007126:	17 8c       	ld.ub	r12,r11[0x0]
80007128:	0a 32       	cp.w	r2,r5
8000712a:	5f 4a       	srge	r10
8000712c:	f0 0c 18 00 	cp.b	r12,r8
80007130:	5f 1c       	srne	r12
80007132:	f9 ea 00 0a 	and	r10,r12,r10
80007136:	f0 0a 18 00 	cp.b	r10,r8
8000713a:	fe 91 fe cf 	brne	80006ed8 <get_arg+0x28>
8000713e:	30 08       	mov	r8,0
80007140:	40 4e       	lddsp	lr,sp[0x10]
80007142:	17 8a       	ld.ub	r10,r11[0x0]
80007144:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007148:	f0 0a 18 00 	cp.b	r10,r8
8000714c:	fc 09 17 10 	movne	r9,lr
80007150:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007154:	06 9e       	mov	lr,r3
80007156:	c2 a8       	rjmp	800071aa <get_arg+0x2fa>
80007158:	62 0a       	ld.w	r10,r1[0x0]
8000715a:	58 3a       	cp.w	r10,3
8000715c:	c1 e0       	breq	80007198 <get_arg+0x2e8>
8000715e:	e0 89 00 07 	brgt	8000716c <get_arg+0x2bc>
80007162:	58 1a       	cp.w	r10,1
80007164:	c1 a0       	breq	80007198 <get_arg+0x2e8>
80007166:	58 2a       	cp.w	r10,2
80007168:	c1 81       	brne	80007198 <get_arg+0x2e8>
8000716a:	c0 58       	rjmp	80007174 <get_arg+0x2c4>
8000716c:	58 5a       	cp.w	r10,5
8000716e:	c0 c0       	breq	80007186 <get_arg+0x2d6>
80007170:	c0 b5       	brlt	80007186 <get_arg+0x2d6>
80007172:	c1 38       	rjmp	80007198 <get_arg+0x2e8>
80007174:	6c 0a       	ld.w	r10,r6[0x0]
80007176:	f4 cc ff f8 	sub	r12,r10,-8
8000717a:	8d 0c       	st.w	r6[0x0],r12
8000717c:	f4 e2 00 00 	ld.d	r2,r10[0]
80007180:	f0 e3 00 00 	st.d	r8[0],r2
80007184:	c1 08       	rjmp	800071a4 <get_arg+0x2f4>
80007186:	6c 0a       	ld.w	r10,r6[0x0]
80007188:	f4 cc ff f8 	sub	r12,r10,-8
8000718c:	8d 0c       	st.w	r6[0x0],r12
8000718e:	f4 e2 00 00 	ld.d	r2,r10[0]
80007192:	f0 e3 00 00 	st.d	r8[0],r2
80007196:	c0 78       	rjmp	800071a4 <get_arg+0x2f4>
80007198:	6c 0a       	ld.w	r10,r6[0x0]
8000719a:	f4 cc ff fc 	sub	r12,r10,-4
8000719e:	8d 0c       	st.w	r6[0x0],r12
800071a0:	74 0a       	ld.w	r10,r10[0x0]
800071a2:	91 0a       	st.w	r8[0x0],r10
800071a4:	2f f5       	sub	r5,-1
800071a6:	2f 88       	sub	r8,-8
800071a8:	2f c1       	sub	r1,-4
800071aa:	12 35       	cp.w	r5,r9
800071ac:	fe 9a ff d6 	brle	80007158 <get_arg+0x2a8>
800071b0:	1c 93       	mov	r3,lr
800071b2:	40 52       	lddsp	r2,sp[0x14]
800071b4:	40 6e       	lddsp	lr,sp[0x18]
800071b6:	85 05       	st.w	r2[0x0],r5
800071b8:	9d 0b       	st.w	lr[0x0],r11
800071ba:	40 4b       	lddsp	r11,sp[0x10]
800071bc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800071c0:	2f 8d       	sub	sp,-32
800071c2:	d8 32       	popm	r0-r7,pc

800071c4 <__sprint_r>:
800071c4:	d4 21       	pushm	r4-r7,lr
800071c6:	14 97       	mov	r7,r10
800071c8:	74 28       	ld.w	r8,r10[0x8]
800071ca:	58 08       	cp.w	r8,0
800071cc:	c0 41       	brne	800071d4 <__sprint_r+0x10>
800071ce:	95 18       	st.w	r10[0x4],r8
800071d0:	10 9c       	mov	r12,r8
800071d2:	d8 22       	popm	r4-r7,pc
800071d4:	e0 a0 18 ba 	rcall	8000a348 <__sfvwrite_r>
800071d8:	30 08       	mov	r8,0
800071da:	8f 18       	st.w	r7[0x4],r8
800071dc:	8f 28       	st.w	r7[0x8],r8
800071de:	d8 22       	popm	r4-r7,pc

800071e0 <_vfprintf_r>:
800071e0:	d4 31       	pushm	r0-r7,lr
800071e2:	fa cd 06 bc 	sub	sp,sp,1724
800071e6:	51 09       	stdsp	sp[0x40],r9
800071e8:	16 91       	mov	r1,r11
800071ea:	14 97       	mov	r7,r10
800071ec:	18 95       	mov	r5,r12
800071ee:	e0 a0 1a 1d 	rcall	8000a628 <_localeconv_r>
800071f2:	78 0c       	ld.w	r12,r12[0x0]
800071f4:	50 cc       	stdsp	sp[0x30],r12
800071f6:	58 05       	cp.w	r5,0
800071f8:	c0 70       	breq	80007206 <_vfprintf_r+0x26>
800071fa:	6a 68       	ld.w	r8,r5[0x18]
800071fc:	58 08       	cp.w	r8,0
800071fe:	c0 41       	brne	80007206 <_vfprintf_r+0x26>
80007200:	0a 9c       	mov	r12,r5
80007202:	e0 a0 17 43 	rcall	8000a088 <__sinit>
80007206:	fe c8 a2 5a 	sub	r8,pc,-23974
8000720a:	10 31       	cp.w	r1,r8
8000720c:	c0 31       	brne	80007212 <_vfprintf_r+0x32>
8000720e:	6a 01       	ld.w	r1,r5[0x0]
80007210:	c0 c8       	rjmp	80007228 <_vfprintf_r+0x48>
80007212:	fe c8 a2 46 	sub	r8,pc,-23994
80007216:	10 31       	cp.w	r1,r8
80007218:	c0 31       	brne	8000721e <_vfprintf_r+0x3e>
8000721a:	6a 11       	ld.w	r1,r5[0x4]
8000721c:	c0 68       	rjmp	80007228 <_vfprintf_r+0x48>
8000721e:	fe c8 a2 32 	sub	r8,pc,-24014
80007222:	10 31       	cp.w	r1,r8
80007224:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007228:	82 68       	ld.sh	r8,r1[0xc]
8000722a:	ed b8 00 03 	bld	r8,0x3
8000722e:	c0 41       	brne	80007236 <_vfprintf_r+0x56>
80007230:	62 48       	ld.w	r8,r1[0x10]
80007232:	58 08       	cp.w	r8,0
80007234:	c0 71       	brne	80007242 <_vfprintf_r+0x62>
80007236:	02 9b       	mov	r11,r1
80007238:	0a 9c       	mov	r12,r5
8000723a:	e0 a0 0f 5d 	rcall	800090f4 <__swsetup_r>
8000723e:	e0 81 0f 54 	brne	800090e6 <_vfprintf_r+0x1f06>
80007242:	82 68       	ld.sh	r8,r1[0xc]
80007244:	10 99       	mov	r9,r8
80007246:	e2 19 00 1a 	andl	r9,0x1a,COH
8000724a:	58 a9       	cp.w	r9,10
8000724c:	c3 c1       	brne	800072c4 <_vfprintf_r+0xe4>
8000724e:	82 79       	ld.sh	r9,r1[0xe]
80007250:	30 0a       	mov	r10,0
80007252:	f4 09 19 00 	cp.h	r9,r10
80007256:	c3 75       	brlt	800072c4 <_vfprintf_r+0xe4>
80007258:	a1 d8       	cbr	r8,0x1
8000725a:	fb 58 05 d0 	st.h	sp[1488],r8
8000725e:	62 88       	ld.w	r8,r1[0x20]
80007260:	fb 48 05 e4 	st.w	sp[1508],r8
80007264:	62 a8       	ld.w	r8,r1[0x28]
80007266:	fb 48 05 ec 	st.w	sp[1516],r8
8000726a:	fa c8 ff bc 	sub	r8,sp,-68
8000726e:	fb 48 05 d4 	st.w	sp[1492],r8
80007272:	fb 48 05 c4 	st.w	sp[1476],r8
80007276:	e0 68 04 00 	mov	r8,1024
8000727a:	fb 48 05 d8 	st.w	sp[1496],r8
8000727e:	fb 48 05 cc 	st.w	sp[1484],r8
80007282:	30 08       	mov	r8,0
80007284:	fb 59 05 d2 	st.h	sp[1490],r9
80007288:	0e 9a       	mov	r10,r7
8000728a:	41 09       	lddsp	r9,sp[0x40]
8000728c:	fa c7 fa 3c 	sub	r7,sp,-1476
80007290:	fb 48 05 dc 	st.w	sp[1500],r8
80007294:	0a 9c       	mov	r12,r5
80007296:	0e 9b       	mov	r11,r7
80007298:	ca 4f       	rcall	800071e0 <_vfprintf_r>
8000729a:	50 bc       	stdsp	sp[0x2c],r12
8000729c:	c0 95       	brlt	800072ae <_vfprintf_r+0xce>
8000729e:	0e 9b       	mov	r11,r7
800072a0:	0a 9c       	mov	r12,r5
800072a2:	e0 a0 16 1b 	rcall	80009ed8 <_fflush_r>
800072a6:	40 be       	lddsp	lr,sp[0x2c]
800072a8:	f9 be 01 ff 	movne	lr,-1
800072ac:	50 be       	stdsp	sp[0x2c],lr
800072ae:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800072b2:	ed b8 00 06 	bld	r8,0x6
800072b6:	e0 81 0f 1a 	brne	800090ea <_vfprintf_r+0x1f0a>
800072ba:	82 68       	ld.sh	r8,r1[0xc]
800072bc:	a7 a8       	sbr	r8,0x6
800072be:	a2 68       	st.h	r1[0xc],r8
800072c0:	e0 8f 0f 15 	bral	800090ea <_vfprintf_r+0x1f0a>
800072c4:	30 08       	mov	r8,0
800072c6:	fb 48 06 b4 	st.w	sp[1716],r8
800072ca:	fb 48 06 90 	st.w	sp[1680],r8
800072ce:	fb 48 06 8c 	st.w	sp[1676],r8
800072d2:	fb 48 06 b0 	st.w	sp[1712],r8
800072d6:	30 08       	mov	r8,0
800072d8:	30 09       	mov	r9,0
800072da:	50 a7       	stdsp	sp[0x28],r7
800072dc:	50 78       	stdsp	sp[0x1c],r8
800072de:	fa c3 f9 e0 	sub	r3,sp,-1568
800072e2:	3f f8       	mov	r8,-1
800072e4:	50 59       	stdsp	sp[0x14],r9
800072e6:	fb 43 06 88 	st.w	sp[1672],r3
800072ea:	fb 48 05 44 	st.w	sp[1348],r8
800072ee:	12 9c       	mov	r12,r9
800072f0:	50 69       	stdsp	sp[0x18],r9
800072f2:	50 d9       	stdsp	sp[0x34],r9
800072f4:	50 e9       	stdsp	sp[0x38],r9
800072f6:	50 b9       	stdsp	sp[0x2c],r9
800072f8:	12 97       	mov	r7,r9
800072fa:	0a 94       	mov	r4,r5
800072fc:	40 a2       	lddsp	r2,sp[0x28]
800072fe:	32 5a       	mov	r10,37
80007300:	30 08       	mov	r8,0
80007302:	c0 28       	rjmp	80007306 <_vfprintf_r+0x126>
80007304:	2f f2       	sub	r2,-1
80007306:	05 89       	ld.ub	r9,r2[0x0]
80007308:	f0 09 18 00 	cp.b	r9,r8
8000730c:	5f 1b       	srne	r11
8000730e:	f4 09 18 00 	cp.b	r9,r10
80007312:	5f 19       	srne	r9
80007314:	f3 eb 00 0b 	and	r11,r9,r11
80007318:	f0 0b 18 00 	cp.b	r11,r8
8000731c:	cf 41       	brne	80007304 <_vfprintf_r+0x124>
8000731e:	40 ab       	lddsp	r11,sp[0x28]
80007320:	e4 0b 01 06 	sub	r6,r2,r11
80007324:	c1 e0       	breq	80007360 <_vfprintf_r+0x180>
80007326:	fa f8 06 90 	ld.w	r8,sp[1680]
8000732a:	0c 08       	add	r8,r6
8000732c:	87 0b       	st.w	r3[0x0],r11
8000732e:	fb 48 06 90 	st.w	sp[1680],r8
80007332:	87 16       	st.w	r3[0x4],r6
80007334:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007338:	2f f8       	sub	r8,-1
8000733a:	fb 48 06 8c 	st.w	sp[1676],r8
8000733e:	58 78       	cp.w	r8,7
80007340:	e0 89 00 04 	brgt	80007348 <_vfprintf_r+0x168>
80007344:	2f 83       	sub	r3,-8
80007346:	c0 a8       	rjmp	8000735a <_vfprintf_r+0x17a>
80007348:	fa ca f9 78 	sub	r10,sp,-1672
8000734c:	02 9b       	mov	r11,r1
8000734e:	08 9c       	mov	r12,r4
80007350:	c3 af       	rcall	800071c4 <__sprint_r>
80007352:	e0 81 0e c6 	brne	800090de <_vfprintf_r+0x1efe>
80007356:	fa c3 f9 e0 	sub	r3,sp,-1568
8000735a:	40 ba       	lddsp	r10,sp[0x2c]
8000735c:	0c 0a       	add	r10,r6
8000735e:	50 ba       	stdsp	sp[0x2c],r10
80007360:	05 89       	ld.ub	r9,r2[0x0]
80007362:	30 08       	mov	r8,0
80007364:	f0 09 18 00 	cp.b	r9,r8
80007368:	e0 80 0e aa 	breq	800090bc <_vfprintf_r+0x1edc>
8000736c:	30 09       	mov	r9,0
8000736e:	fb 68 06 bb 	st.b	sp[1723],r8
80007372:	0e 96       	mov	r6,r7
80007374:	e4 c8 ff ff 	sub	r8,r2,-1
80007378:	3f fe       	mov	lr,-1
8000737a:	50 93       	stdsp	sp[0x24],r3
8000737c:	50 41       	stdsp	sp[0x10],r1
8000737e:	0e 93       	mov	r3,r7
80007380:	04 91       	mov	r1,r2
80007382:	50 89       	stdsp	sp[0x20],r9
80007384:	50 a8       	stdsp	sp[0x28],r8
80007386:	50 2e       	stdsp	sp[0x8],lr
80007388:	50 39       	stdsp	sp[0xc],r9
8000738a:	12 95       	mov	r5,r9
8000738c:	12 90       	mov	r0,r9
8000738e:	10 97       	mov	r7,r8
80007390:	08 92       	mov	r2,r4
80007392:	c0 78       	rjmp	800073a0 <_vfprintf_r+0x1c0>
80007394:	3f fc       	mov	r12,-1
80007396:	08 97       	mov	r7,r4
80007398:	50 2c       	stdsp	sp[0x8],r12
8000739a:	c0 38       	rjmp	800073a0 <_vfprintf_r+0x1c0>
8000739c:	30 0b       	mov	r11,0
8000739e:	50 3b       	stdsp	sp[0xc],r11
800073a0:	0f 38       	ld.ub	r8,r7++
800073a2:	c0 28       	rjmp	800073a6 <_vfprintf_r+0x1c6>
800073a4:	12 90       	mov	r0,r9
800073a6:	f0 c9 00 20 	sub	r9,r8,32
800073aa:	e0 49 00 58 	cp.w	r9,88
800073ae:	e0 8b 0a 30 	brhi	8000880e <_vfprintf_r+0x162e>
800073b2:	fe ca a7 ae 	sub	r10,pc,-22610
800073b6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800073ba:	50 a7       	stdsp	sp[0x28],r7
800073bc:	50 80       	stdsp	sp[0x20],r0
800073be:	0c 97       	mov	r7,r6
800073c0:	04 94       	mov	r4,r2
800073c2:	06 96       	mov	r6,r3
800073c4:	02 92       	mov	r2,r1
800073c6:	fe c9 a5 86 	sub	r9,pc,-23162
800073ca:	40 93       	lddsp	r3,sp[0x24]
800073cc:	10 90       	mov	r0,r8
800073ce:	40 41       	lddsp	r1,sp[0x10]
800073d0:	50 d9       	stdsp	sp[0x34],r9
800073d2:	e0 8f 08 8e 	bral	800084ee <_vfprintf_r+0x130e>
800073d6:	30 08       	mov	r8,0
800073d8:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800073dc:	f0 09 18 00 	cp.b	r9,r8
800073e0:	ce 01       	brne	800073a0 <_vfprintf_r+0x1c0>
800073e2:	32 08       	mov	r8,32
800073e4:	c6 e8       	rjmp	800074c0 <_vfprintf_r+0x2e0>
800073e6:	a1 a5       	sbr	r5,0x0
800073e8:	cd cb       	rjmp	800073a0 <_vfprintf_r+0x1c0>
800073ea:	0f 89       	ld.ub	r9,r7[0x0]
800073ec:	f2 c8 00 30 	sub	r8,r9,48
800073f0:	58 98       	cp.w	r8,9
800073f2:	e0 8b 00 1d 	brhi	8000742c <_vfprintf_r+0x24c>
800073f6:	ee c8 ff ff 	sub	r8,r7,-1
800073fa:	30 0b       	mov	r11,0
800073fc:	23 09       	sub	r9,48
800073fe:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007402:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007406:	11 39       	ld.ub	r9,r8++
80007408:	f2 ca 00 30 	sub	r10,r9,48
8000740c:	58 9a       	cp.w	r10,9
8000740e:	fe 98 ff f7 	brls	800073fc <_vfprintf_r+0x21c>
80007412:	e0 49 00 24 	cp.w	r9,36
80007416:	cc 31       	brne	8000739c <_vfprintf_r+0x1bc>
80007418:	e0 4b 00 20 	cp.w	r11,32
8000741c:	e0 89 0e 60 	brgt	800090dc <_vfprintf_r+0x1efc>
80007420:	20 1b       	sub	r11,1
80007422:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007426:	12 3b       	cp.w	r11,r9
80007428:	c0 95       	brlt	8000743a <_vfprintf_r+0x25a>
8000742a:	c1 08       	rjmp	8000744a <_vfprintf_r+0x26a>
8000742c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007430:	ec ca ff ff 	sub	r10,r6,-1
80007434:	12 36       	cp.w	r6,r9
80007436:	c1 f5       	brlt	80007474 <_vfprintf_r+0x294>
80007438:	c2 68       	rjmp	80007484 <_vfprintf_r+0x2a4>
8000743a:	fa ce f9 44 	sub	lr,sp,-1724
8000743e:	10 97       	mov	r7,r8
80007440:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007444:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007448:	c3 58       	rjmp	800074b2 <_vfprintf_r+0x2d2>
8000744a:	10 97       	mov	r7,r8
8000744c:	fa c8 f9 50 	sub	r8,sp,-1712
80007450:	1a d8       	st.w	--sp,r8
80007452:	fa c8 fa b8 	sub	r8,sp,-1352
80007456:	1a d8       	st.w	--sp,r8
80007458:	fa c8 fb b4 	sub	r8,sp,-1100
8000745c:	02 9a       	mov	r10,r1
8000745e:	1a d8       	st.w	--sp,r8
80007460:	04 9c       	mov	r12,r2
80007462:	fa c8 f9 40 	sub	r8,sp,-1728
80007466:	fa c9 ff b4 	sub	r9,sp,-76
8000746a:	fe b0 fd 23 	rcall	80006eb0 <get_arg>
8000746e:	2f dd       	sub	sp,-12
80007470:	78 00       	ld.w	r0,r12[0x0]
80007472:	c2 08       	rjmp	800074b2 <_vfprintf_r+0x2d2>
80007474:	fa cc f9 44 	sub	r12,sp,-1724
80007478:	14 96       	mov	r6,r10
8000747a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000747e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007482:	c1 88       	rjmp	800074b2 <_vfprintf_r+0x2d2>
80007484:	41 08       	lddsp	r8,sp[0x40]
80007486:	59 f9       	cp.w	r9,31
80007488:	e0 89 00 11 	brgt	800074aa <_vfprintf_r+0x2ca>
8000748c:	f0 cb ff fc 	sub	r11,r8,-4
80007490:	51 0b       	stdsp	sp[0x40],r11
80007492:	70 00       	ld.w	r0,r8[0x0]
80007494:	fa cb f9 44 	sub	r11,sp,-1724
80007498:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000749c:	f1 40 fd 88 	st.w	r8[-632],r0
800074a0:	2f f9       	sub	r9,-1
800074a2:	14 96       	mov	r6,r10
800074a4:	fb 49 06 b4 	st.w	sp[1716],r9
800074a8:	c0 58       	rjmp	800074b2 <_vfprintf_r+0x2d2>
800074aa:	70 00       	ld.w	r0,r8[0x0]
800074ac:	14 96       	mov	r6,r10
800074ae:	2f c8       	sub	r8,-4
800074b0:	51 08       	stdsp	sp[0x40],r8
800074b2:	58 00       	cp.w	r0,0
800074b4:	fe 94 ff 76 	brge	800073a0 <_vfprintf_r+0x1c0>
800074b8:	5c 30       	neg	r0
800074ba:	a3 a5       	sbr	r5,0x2
800074bc:	c7 2b       	rjmp	800073a0 <_vfprintf_r+0x1c0>
800074be:	32 b8       	mov	r8,43
800074c0:	fb 68 06 bb 	st.b	sp[1723],r8
800074c4:	c6 eb       	rjmp	800073a0 <_vfprintf_r+0x1c0>
800074c6:	0f 38       	ld.ub	r8,r7++
800074c8:	e0 48 00 2a 	cp.w	r8,42
800074cc:	c0 30       	breq	800074d2 <_vfprintf_r+0x2f2>
800074ce:	30 09       	mov	r9,0
800074d0:	c7 98       	rjmp	800075c2 <_vfprintf_r+0x3e2>
800074d2:	0f 88       	ld.ub	r8,r7[0x0]
800074d4:	f0 c9 00 30 	sub	r9,r8,48
800074d8:	58 99       	cp.w	r9,9
800074da:	e0 8b 00 1f 	brhi	80007518 <_vfprintf_r+0x338>
800074de:	ee c4 ff ff 	sub	r4,r7,-1
800074e2:	30 0b       	mov	r11,0
800074e4:	23 08       	sub	r8,48
800074e6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800074ea:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800074ee:	09 38       	ld.ub	r8,r4++
800074f0:	f0 c9 00 30 	sub	r9,r8,48
800074f4:	58 99       	cp.w	r9,9
800074f6:	fe 98 ff f7 	brls	800074e4 <_vfprintf_r+0x304>
800074fa:	e0 48 00 24 	cp.w	r8,36
800074fe:	fe 91 ff 4f 	brne	8000739c <_vfprintf_r+0x1bc>
80007502:	e0 4b 00 20 	cp.w	r11,32
80007506:	e0 89 0d eb 	brgt	800090dc <_vfprintf_r+0x1efc>
8000750a:	20 1b       	sub	r11,1
8000750c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007510:	10 3b       	cp.w	r11,r8
80007512:	c0 a5       	brlt	80007526 <_vfprintf_r+0x346>
80007514:	c1 18       	rjmp	80007536 <_vfprintf_r+0x356>
80007516:	d7 03       	nop
80007518:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000751c:	ec c9 ff ff 	sub	r9,r6,-1
80007520:	14 36       	cp.w	r6,r10
80007522:	c1 f5       	brlt	80007560 <_vfprintf_r+0x380>
80007524:	c2 88       	rjmp	80007574 <_vfprintf_r+0x394>
80007526:	fa ca f9 44 	sub	r10,sp,-1724
8000752a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000752e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007532:	50 2b       	stdsp	sp[0x8],r11
80007534:	c3 c8       	rjmp	800075ac <_vfprintf_r+0x3cc>
80007536:	fa c8 f9 50 	sub	r8,sp,-1712
8000753a:	1a d8       	st.w	--sp,r8
8000753c:	fa c8 fa b8 	sub	r8,sp,-1352
80007540:	1a d8       	st.w	--sp,r8
80007542:	fa c8 fb b4 	sub	r8,sp,-1100
80007546:	02 9a       	mov	r10,r1
80007548:	1a d8       	st.w	--sp,r8
8000754a:	04 9c       	mov	r12,r2
8000754c:	fa c8 f9 40 	sub	r8,sp,-1728
80007550:	fa c9 ff b4 	sub	r9,sp,-76
80007554:	fe b0 fc ae 	rcall	80006eb0 <get_arg>
80007558:	2f dd       	sub	sp,-12
8000755a:	78 0c       	ld.w	r12,r12[0x0]
8000755c:	50 2c       	stdsp	sp[0x8],r12
8000755e:	c2 78       	rjmp	800075ac <_vfprintf_r+0x3cc>
80007560:	12 96       	mov	r6,r9
80007562:	0e 94       	mov	r4,r7
80007564:	fa c9 f9 44 	sub	r9,sp,-1724
80007568:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000756c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007570:	50 28       	stdsp	sp[0x8],r8
80007572:	c1 d8       	rjmp	800075ac <_vfprintf_r+0x3cc>
80007574:	41 08       	lddsp	r8,sp[0x40]
80007576:	59 fa       	cp.w	r10,31
80007578:	e0 89 00 14 	brgt	800075a0 <_vfprintf_r+0x3c0>
8000757c:	f0 cb ff fc 	sub	r11,r8,-4
80007580:	70 08       	ld.w	r8,r8[0x0]
80007582:	51 0b       	stdsp	sp[0x40],r11
80007584:	50 28       	stdsp	sp[0x8],r8
80007586:	fa c6 f9 44 	sub	r6,sp,-1724
8000758a:	40 2e       	lddsp	lr,sp[0x8]
8000758c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007590:	f1 4e fd 88 	st.w	r8[-632],lr
80007594:	2f fa       	sub	r10,-1
80007596:	0e 94       	mov	r4,r7
80007598:	fb 4a 06 b4 	st.w	sp[1716],r10
8000759c:	12 96       	mov	r6,r9
8000759e:	c0 78       	rjmp	800075ac <_vfprintf_r+0x3cc>
800075a0:	70 0c       	ld.w	r12,r8[0x0]
800075a2:	0e 94       	mov	r4,r7
800075a4:	2f c8       	sub	r8,-4
800075a6:	50 2c       	stdsp	sp[0x8],r12
800075a8:	12 96       	mov	r6,r9
800075aa:	51 08       	stdsp	sp[0x40],r8
800075ac:	40 2b       	lddsp	r11,sp[0x8]
800075ae:	58 0b       	cp.w	r11,0
800075b0:	fe 95 fe f2 	brlt	80007394 <_vfprintf_r+0x1b4>
800075b4:	08 97       	mov	r7,r4
800075b6:	cf 5a       	rjmp	800073a0 <_vfprintf_r+0x1c0>
800075b8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800075bc:	0f 38       	ld.ub	r8,r7++
800075be:	f4 09 00 19 	add	r9,r10,r9<<0x1
800075c2:	f0 ca 00 30 	sub	r10,r8,48
800075c6:	58 9a       	cp.w	r10,9
800075c8:	fe 98 ff f8 	brls	800075b8 <_vfprintf_r+0x3d8>
800075cc:	3f fa       	mov	r10,-1
800075ce:	f2 0a 0c 49 	max	r9,r9,r10
800075d2:	50 29       	stdsp	sp[0x8],r9
800075d4:	ce 9a       	rjmp	800073a6 <_vfprintf_r+0x1c6>
800075d6:	a7 b5       	sbr	r5,0x7
800075d8:	ce 4a       	rjmp	800073a0 <_vfprintf_r+0x1c0>
800075da:	30 09       	mov	r9,0
800075dc:	23 08       	sub	r8,48
800075de:	f2 09 00 29 	add	r9,r9,r9<<0x2
800075e2:	f0 09 00 19 	add	r9,r8,r9<<0x1
800075e6:	0f 38       	ld.ub	r8,r7++
800075e8:	f0 ca 00 30 	sub	r10,r8,48
800075ec:	58 9a       	cp.w	r10,9
800075ee:	fe 98 ff f7 	brls	800075dc <_vfprintf_r+0x3fc>
800075f2:	e0 48 00 24 	cp.w	r8,36
800075f6:	fe 91 fe d7 	brne	800073a4 <_vfprintf_r+0x1c4>
800075fa:	e0 49 00 20 	cp.w	r9,32
800075fe:	e0 89 0d 6f 	brgt	800090dc <_vfprintf_r+0x1efc>
80007602:	f2 c3 00 01 	sub	r3,r9,1
80007606:	30 19       	mov	r9,1
80007608:	50 39       	stdsp	sp[0xc],r9
8000760a:	cc ba       	rjmp	800073a0 <_vfprintf_r+0x1c0>
8000760c:	a3 b5       	sbr	r5,0x3
8000760e:	cc 9a       	rjmp	800073a0 <_vfprintf_r+0x1c0>
80007610:	a7 a5       	sbr	r5,0x6
80007612:	cc 7a       	rjmp	800073a0 <_vfprintf_r+0x1c0>
80007614:	0a 98       	mov	r8,r5
80007616:	a5 b5       	sbr	r5,0x5
80007618:	a5 a8       	sbr	r8,0x4
8000761a:	0f 89       	ld.ub	r9,r7[0x0]
8000761c:	36 ce       	mov	lr,108
8000761e:	fc 09 18 00 	cp.b	r9,lr
80007622:	f7 b7 00 ff 	subeq	r7,-1
80007626:	f0 05 17 10 	movne	r5,r8
8000762a:	cb ba       	rjmp	800073a0 <_vfprintf_r+0x1c0>
8000762c:	a5 b5       	sbr	r5,0x5
8000762e:	cb 9a       	rjmp	800073a0 <_vfprintf_r+0x1c0>
80007630:	50 a7       	stdsp	sp[0x28],r7
80007632:	50 80       	stdsp	sp[0x20],r0
80007634:	0c 97       	mov	r7,r6
80007636:	10 90       	mov	r0,r8
80007638:	06 96       	mov	r6,r3
8000763a:	04 94       	mov	r4,r2
8000763c:	40 93       	lddsp	r3,sp[0x24]
8000763e:	02 92       	mov	r2,r1
80007640:	0e 99       	mov	r9,r7
80007642:	40 41       	lddsp	r1,sp[0x10]
80007644:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007648:	40 3c       	lddsp	r12,sp[0xc]
8000764a:	58 0c       	cp.w	r12,0
8000764c:	c1 d0       	breq	80007686 <_vfprintf_r+0x4a6>
8000764e:	10 36       	cp.w	r6,r8
80007650:	c0 64       	brge	8000765c <_vfprintf_r+0x47c>
80007652:	fa cb f9 44 	sub	r11,sp,-1724
80007656:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000765a:	c1 d8       	rjmp	80007694 <_vfprintf_r+0x4b4>
8000765c:	fa c8 f9 50 	sub	r8,sp,-1712
80007660:	1a d8       	st.w	--sp,r8
80007662:	fa c8 fa b8 	sub	r8,sp,-1352
80007666:	1a d8       	st.w	--sp,r8
80007668:	fa c8 fb b4 	sub	r8,sp,-1100
8000766c:	1a d8       	st.w	--sp,r8
8000766e:	fa c8 f9 40 	sub	r8,sp,-1728
80007672:	fa c9 ff b4 	sub	r9,sp,-76
80007676:	04 9a       	mov	r10,r2
80007678:	0c 9b       	mov	r11,r6
8000767a:	08 9c       	mov	r12,r4
8000767c:	fe b0 fc 1a 	rcall	80006eb0 <get_arg>
80007680:	2f dd       	sub	sp,-12
80007682:	19 b8       	ld.ub	r8,r12[0x3]
80007684:	c2 28       	rjmp	800076c8 <_vfprintf_r+0x4e8>
80007686:	2f f7       	sub	r7,-1
80007688:	10 39       	cp.w	r9,r8
8000768a:	c0 84       	brge	8000769a <_vfprintf_r+0x4ba>
8000768c:	fa ca f9 44 	sub	r10,sp,-1724
80007690:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007694:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007698:	c1 88       	rjmp	800076c8 <_vfprintf_r+0x4e8>
8000769a:	41 09       	lddsp	r9,sp[0x40]
8000769c:	59 f8       	cp.w	r8,31
8000769e:	e0 89 00 12 	brgt	800076c2 <_vfprintf_r+0x4e2>
800076a2:	f2 ca ff fc 	sub	r10,r9,-4
800076a6:	51 0a       	stdsp	sp[0x40],r10
800076a8:	72 09       	ld.w	r9,r9[0x0]
800076aa:	fa c6 f9 44 	sub	r6,sp,-1724
800076ae:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800076b2:	2f f8       	sub	r8,-1
800076b4:	f5 49 fd 88 	st.w	r10[-632],r9
800076b8:	fb 48 06 b4 	st.w	sp[1716],r8
800076bc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800076c0:	c0 48       	rjmp	800076c8 <_vfprintf_r+0x4e8>
800076c2:	13 b8       	ld.ub	r8,r9[0x3]
800076c4:	2f c9       	sub	r9,-4
800076c6:	51 09       	stdsp	sp[0x40],r9
800076c8:	fb 68 06 60 	st.b	sp[1632],r8
800076cc:	30 0e       	mov	lr,0
800076ce:	30 08       	mov	r8,0
800076d0:	30 12       	mov	r2,1
800076d2:	fb 68 06 bb 	st.b	sp[1723],r8
800076d6:	50 2e       	stdsp	sp[0x8],lr
800076d8:	e0 8f 08 ad 	bral	80008832 <_vfprintf_r+0x1652>
800076dc:	50 a7       	stdsp	sp[0x28],r7
800076de:	50 80       	stdsp	sp[0x20],r0
800076e0:	0c 97       	mov	r7,r6
800076e2:	04 94       	mov	r4,r2
800076e4:	06 96       	mov	r6,r3
800076e6:	02 92       	mov	r2,r1
800076e8:	40 93       	lddsp	r3,sp[0x24]
800076ea:	10 90       	mov	r0,r8
800076ec:	40 41       	lddsp	r1,sp[0x10]
800076ee:	a5 a5       	sbr	r5,0x4
800076f0:	c0 a8       	rjmp	80007704 <_vfprintf_r+0x524>
800076f2:	50 a7       	stdsp	sp[0x28],r7
800076f4:	50 80       	stdsp	sp[0x20],r0
800076f6:	0c 97       	mov	r7,r6
800076f8:	04 94       	mov	r4,r2
800076fa:	06 96       	mov	r6,r3
800076fc:	02 92       	mov	r2,r1
800076fe:	40 93       	lddsp	r3,sp[0x24]
80007700:	10 90       	mov	r0,r8
80007702:	40 41       	lddsp	r1,sp[0x10]
80007704:	ed b5 00 05 	bld	r5,0x5
80007708:	c5 11       	brne	800077aa <_vfprintf_r+0x5ca>
8000770a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000770e:	40 3c       	lddsp	r12,sp[0xc]
80007710:	58 0c       	cp.w	r12,0
80007712:	c1 e0       	breq	8000774e <_vfprintf_r+0x56e>
80007714:	10 36       	cp.w	r6,r8
80007716:	c0 64       	brge	80007722 <_vfprintf_r+0x542>
80007718:	fa cb f9 44 	sub	r11,sp,-1724
8000771c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007720:	c2 08       	rjmp	80007760 <_vfprintf_r+0x580>
80007722:	fa c8 f9 50 	sub	r8,sp,-1712
80007726:	1a d8       	st.w	--sp,r8
80007728:	fa c8 fa b8 	sub	r8,sp,-1352
8000772c:	0c 9b       	mov	r11,r6
8000772e:	1a d8       	st.w	--sp,r8
80007730:	fa c8 fb b4 	sub	r8,sp,-1100
80007734:	1a d8       	st.w	--sp,r8
80007736:	fa c9 ff b4 	sub	r9,sp,-76
8000773a:	fa c8 f9 40 	sub	r8,sp,-1728
8000773e:	04 9a       	mov	r10,r2
80007740:	08 9c       	mov	r12,r4
80007742:	fe b0 fb b7 	rcall	80006eb0 <get_arg>
80007746:	2f dd       	sub	sp,-12
80007748:	78 1b       	ld.w	r11,r12[0x4]
8000774a:	78 09       	ld.w	r9,r12[0x0]
8000774c:	c2 b8       	rjmp	800077a2 <_vfprintf_r+0x5c2>
8000774e:	ee ca ff ff 	sub	r10,r7,-1
80007752:	10 37       	cp.w	r7,r8
80007754:	c0 b4       	brge	8000776a <_vfprintf_r+0x58a>
80007756:	fa c9 f9 44 	sub	r9,sp,-1724
8000775a:	14 97       	mov	r7,r10
8000775c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007760:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007764:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007768:	c1 d8       	rjmp	800077a2 <_vfprintf_r+0x5c2>
8000776a:	41 09       	lddsp	r9,sp[0x40]
8000776c:	59 f8       	cp.w	r8,31
8000776e:	e0 89 00 14 	brgt	80007796 <_vfprintf_r+0x5b6>
80007772:	f2 cb ff f8 	sub	r11,r9,-8
80007776:	51 0b       	stdsp	sp[0x40],r11
80007778:	fa c6 f9 44 	sub	r6,sp,-1724
8000777c:	72 1b       	ld.w	r11,r9[0x4]
8000777e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007782:	72 09       	ld.w	r9,r9[0x0]
80007784:	f9 4b fd 8c 	st.w	r12[-628],r11
80007788:	f9 49 fd 88 	st.w	r12[-632],r9
8000778c:	2f f8       	sub	r8,-1
8000778e:	14 97       	mov	r7,r10
80007790:	fb 48 06 b4 	st.w	sp[1716],r8
80007794:	c0 78       	rjmp	800077a2 <_vfprintf_r+0x5c2>
80007796:	f2 c8 ff f8 	sub	r8,r9,-8
8000779a:	72 1b       	ld.w	r11,r9[0x4]
8000779c:	14 97       	mov	r7,r10
8000779e:	51 08       	stdsp	sp[0x40],r8
800077a0:	72 09       	ld.w	r9,r9[0x0]
800077a2:	16 98       	mov	r8,r11
800077a4:	fa e9 00 00 	st.d	sp[0],r8
800077a8:	ca e8       	rjmp	80007904 <_vfprintf_r+0x724>
800077aa:	ed b5 00 04 	bld	r5,0x4
800077ae:	c1 71       	brne	800077dc <_vfprintf_r+0x5fc>
800077b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077b4:	40 3e       	lddsp	lr,sp[0xc]
800077b6:	58 0e       	cp.w	lr,0
800077b8:	c0 80       	breq	800077c8 <_vfprintf_r+0x5e8>
800077ba:	10 36       	cp.w	r6,r8
800077bc:	c6 94       	brge	8000788e <_vfprintf_r+0x6ae>
800077be:	fa cc f9 44 	sub	r12,sp,-1724
800077c2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800077c6:	c8 28       	rjmp	800078ca <_vfprintf_r+0x6ea>
800077c8:	ee ca ff ff 	sub	r10,r7,-1
800077cc:	10 37       	cp.w	r7,r8
800077ce:	e0 84 00 81 	brge	800078d0 <_vfprintf_r+0x6f0>
800077d2:	fa cb f9 44 	sub	r11,sp,-1724
800077d6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077da:	c7 78       	rjmp	800078c8 <_vfprintf_r+0x6e8>
800077dc:	ed b5 00 06 	bld	r5,0x6
800077e0:	c4 b1       	brne	80007876 <_vfprintf_r+0x696>
800077e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077e6:	40 3c       	lddsp	r12,sp[0xc]
800077e8:	58 0c       	cp.w	r12,0
800077ea:	c1 d0       	breq	80007824 <_vfprintf_r+0x644>
800077ec:	10 36       	cp.w	r6,r8
800077ee:	c0 64       	brge	800077fa <_vfprintf_r+0x61a>
800077f0:	fa cb f9 44 	sub	r11,sp,-1724
800077f4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800077f8:	c1 f8       	rjmp	80007836 <_vfprintf_r+0x656>
800077fa:	fa c8 f9 50 	sub	r8,sp,-1712
800077fe:	1a d8       	st.w	--sp,r8
80007800:	fa c8 fa b8 	sub	r8,sp,-1352
80007804:	1a d8       	st.w	--sp,r8
80007806:	fa c8 fb b4 	sub	r8,sp,-1100
8000780a:	1a d8       	st.w	--sp,r8
8000780c:	fa c8 f9 40 	sub	r8,sp,-1728
80007810:	fa c9 ff b4 	sub	r9,sp,-76
80007814:	04 9a       	mov	r10,r2
80007816:	0c 9b       	mov	r11,r6
80007818:	08 9c       	mov	r12,r4
8000781a:	fe b0 fb 4b 	rcall	80006eb0 <get_arg>
8000781e:	2f dd       	sub	sp,-12
80007820:	98 18       	ld.sh	r8,r12[0x2]
80007822:	c2 68       	rjmp	8000786e <_vfprintf_r+0x68e>
80007824:	ee ca ff ff 	sub	r10,r7,-1
80007828:	10 37       	cp.w	r7,r8
8000782a:	c0 94       	brge	8000783c <_vfprintf_r+0x65c>
8000782c:	fa c9 f9 44 	sub	r9,sp,-1724
80007830:	14 97       	mov	r7,r10
80007832:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007836:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000783a:	c1 a8       	rjmp	8000786e <_vfprintf_r+0x68e>
8000783c:	41 09       	lddsp	r9,sp[0x40]
8000783e:	59 f8       	cp.w	r8,31
80007840:	e0 89 00 13 	brgt	80007866 <_vfprintf_r+0x686>
80007844:	f2 cb ff fc 	sub	r11,r9,-4
80007848:	51 0b       	stdsp	sp[0x40],r11
8000784a:	72 09       	ld.w	r9,r9[0x0]
8000784c:	fa c6 f9 44 	sub	r6,sp,-1724
80007850:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007854:	2f f8       	sub	r8,-1
80007856:	f7 49 fd 88 	st.w	r11[-632],r9
8000785a:	fb 48 06 b4 	st.w	sp[1716],r8
8000785e:	14 97       	mov	r7,r10
80007860:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007864:	c0 58       	rjmp	8000786e <_vfprintf_r+0x68e>
80007866:	92 18       	ld.sh	r8,r9[0x2]
80007868:	14 97       	mov	r7,r10
8000786a:	2f c9       	sub	r9,-4
8000786c:	51 09       	stdsp	sp[0x40],r9
8000786e:	50 18       	stdsp	sp[0x4],r8
80007870:	bf 58       	asr	r8,0x1f
80007872:	50 08       	stdsp	sp[0x0],r8
80007874:	c4 88       	rjmp	80007904 <_vfprintf_r+0x724>
80007876:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000787a:	40 3c       	lddsp	r12,sp[0xc]
8000787c:	58 0c       	cp.w	r12,0
8000787e:	c1 d0       	breq	800078b8 <_vfprintf_r+0x6d8>
80007880:	10 36       	cp.w	r6,r8
80007882:	c0 64       	brge	8000788e <_vfprintf_r+0x6ae>
80007884:	fa cb f9 44 	sub	r11,sp,-1724
80007888:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000788c:	c1 f8       	rjmp	800078ca <_vfprintf_r+0x6ea>
8000788e:	fa c8 f9 50 	sub	r8,sp,-1712
80007892:	1a d8       	st.w	--sp,r8
80007894:	fa c8 fa b8 	sub	r8,sp,-1352
80007898:	0c 9b       	mov	r11,r6
8000789a:	1a d8       	st.w	--sp,r8
8000789c:	fa c8 fb b4 	sub	r8,sp,-1100
800078a0:	04 9a       	mov	r10,r2
800078a2:	1a d8       	st.w	--sp,r8
800078a4:	08 9c       	mov	r12,r4
800078a6:	fa c8 f9 40 	sub	r8,sp,-1728
800078aa:	fa c9 ff b4 	sub	r9,sp,-76
800078ae:	fe b0 fb 01 	rcall	80006eb0 <get_arg>
800078b2:	2f dd       	sub	sp,-12
800078b4:	78 0b       	ld.w	r11,r12[0x0]
800078b6:	c2 48       	rjmp	800078fe <_vfprintf_r+0x71e>
800078b8:	ee ca ff ff 	sub	r10,r7,-1
800078bc:	10 37       	cp.w	r7,r8
800078be:	c0 94       	brge	800078d0 <_vfprintf_r+0x6f0>
800078c0:	fa c9 f9 44 	sub	r9,sp,-1724
800078c4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800078c8:	14 97       	mov	r7,r10
800078ca:	ec fb fd 88 	ld.w	r11,r6[-632]
800078ce:	c1 88       	rjmp	800078fe <_vfprintf_r+0x71e>
800078d0:	41 09       	lddsp	r9,sp[0x40]
800078d2:	59 f8       	cp.w	r8,31
800078d4:	e0 89 00 11 	brgt	800078f6 <_vfprintf_r+0x716>
800078d8:	f2 cb ff fc 	sub	r11,r9,-4
800078dc:	51 0b       	stdsp	sp[0x40],r11
800078de:	fa c6 f9 44 	sub	r6,sp,-1724
800078e2:	72 0b       	ld.w	r11,r9[0x0]
800078e4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800078e8:	f3 4b fd 88 	st.w	r9[-632],r11
800078ec:	2f f8       	sub	r8,-1
800078ee:	14 97       	mov	r7,r10
800078f0:	fb 48 06 b4 	st.w	sp[1716],r8
800078f4:	c0 58       	rjmp	800078fe <_vfprintf_r+0x71e>
800078f6:	72 0b       	ld.w	r11,r9[0x0]
800078f8:	14 97       	mov	r7,r10
800078fa:	2f c9       	sub	r9,-4
800078fc:	51 09       	stdsp	sp[0x40],r9
800078fe:	50 1b       	stdsp	sp[0x4],r11
80007900:	bf 5b       	asr	r11,0x1f
80007902:	50 0b       	stdsp	sp[0x0],r11
80007904:	fa ea 00 00 	ld.d	r10,sp[0]
80007908:	58 0a       	cp.w	r10,0
8000790a:	5c 2b       	cpc	r11
8000790c:	c0 e4       	brge	80007928 <_vfprintf_r+0x748>
8000790e:	30 08       	mov	r8,0
80007910:	fa ea 00 00 	ld.d	r10,sp[0]
80007914:	30 09       	mov	r9,0
80007916:	f0 0a 01 0a 	sub	r10,r8,r10
8000791a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000791e:	32 d8       	mov	r8,45
80007920:	fa eb 00 00 	st.d	sp[0],r10
80007924:	fb 68 06 bb 	st.b	sp[1723],r8
80007928:	30 18       	mov	r8,1
8000792a:	e0 8f 06 fa 	bral	8000871e <_vfprintf_r+0x153e>
8000792e:	50 a7       	stdsp	sp[0x28],r7
80007930:	50 80       	stdsp	sp[0x20],r0
80007932:	0c 97       	mov	r7,r6
80007934:	04 94       	mov	r4,r2
80007936:	06 96       	mov	r6,r3
80007938:	02 92       	mov	r2,r1
8000793a:	40 93       	lddsp	r3,sp[0x24]
8000793c:	10 90       	mov	r0,r8
8000793e:	40 41       	lddsp	r1,sp[0x10]
80007940:	0e 99       	mov	r9,r7
80007942:	ed b5 00 03 	bld	r5,0x3
80007946:	c4 11       	brne	800079c8 <_vfprintf_r+0x7e8>
80007948:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000794c:	40 3a       	lddsp	r10,sp[0xc]
8000794e:	58 0a       	cp.w	r10,0
80007950:	c1 90       	breq	80007982 <_vfprintf_r+0x7a2>
80007952:	10 36       	cp.w	r6,r8
80007954:	c6 45       	brlt	80007a1c <_vfprintf_r+0x83c>
80007956:	fa c8 f9 50 	sub	r8,sp,-1712
8000795a:	1a d8       	st.w	--sp,r8
8000795c:	fa c8 fa b8 	sub	r8,sp,-1352
80007960:	1a d8       	st.w	--sp,r8
80007962:	fa c8 fb b4 	sub	r8,sp,-1100
80007966:	0c 9b       	mov	r11,r6
80007968:	1a d8       	st.w	--sp,r8
8000796a:	04 9a       	mov	r10,r2
8000796c:	fa c8 f9 40 	sub	r8,sp,-1728
80007970:	fa c9 ff b4 	sub	r9,sp,-76
80007974:	08 9c       	mov	r12,r4
80007976:	fe b0 fa 9d 	rcall	80006eb0 <get_arg>
8000797a:	2f dd       	sub	sp,-12
8000797c:	78 16       	ld.w	r6,r12[0x4]
8000797e:	50 76       	stdsp	sp[0x1c],r6
80007980:	c4 88       	rjmp	80007a10 <_vfprintf_r+0x830>
80007982:	2f f7       	sub	r7,-1
80007984:	10 39       	cp.w	r9,r8
80007986:	c0 c4       	brge	8000799e <_vfprintf_r+0x7be>
80007988:	fa ce f9 44 	sub	lr,sp,-1724
8000798c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007990:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007994:	50 7c       	stdsp	sp[0x1c],r12
80007996:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000799a:	50 56       	stdsp	sp[0x14],r6
8000799c:	c6 68       	rjmp	80007a68 <_vfprintf_r+0x888>
8000799e:	41 09       	lddsp	r9,sp[0x40]
800079a0:	59 f8       	cp.w	r8,31
800079a2:	e0 89 00 10 	brgt	800079c2 <_vfprintf_r+0x7e2>
800079a6:	f2 ca ff f8 	sub	r10,r9,-8
800079aa:	72 1b       	ld.w	r11,r9[0x4]
800079ac:	51 0a       	stdsp	sp[0x40],r10
800079ae:	72 09       	ld.w	r9,r9[0x0]
800079b0:	fa ca f9 44 	sub	r10,sp,-1724
800079b4:	50 7b       	stdsp	sp[0x1c],r11
800079b6:	50 59       	stdsp	sp[0x14],r9
800079b8:	f4 08 00 39 	add	r9,r10,r8<<0x3
800079bc:	40 5b       	lddsp	r11,sp[0x14]
800079be:	40 7a       	lddsp	r10,sp[0x1c]
800079c0:	c4 78       	rjmp	80007a4e <_vfprintf_r+0x86e>
800079c2:	72 18       	ld.w	r8,r9[0x4]
800079c4:	50 78       	stdsp	sp[0x1c],r8
800079c6:	c4 c8       	rjmp	80007a5e <_vfprintf_r+0x87e>
800079c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079cc:	40 3e       	lddsp	lr,sp[0xc]
800079ce:	58 0e       	cp.w	lr,0
800079d0:	c2 30       	breq	80007a16 <_vfprintf_r+0x836>
800079d2:	10 36       	cp.w	r6,r8
800079d4:	c0 94       	brge	800079e6 <_vfprintf_r+0x806>
800079d6:	fa cc f9 44 	sub	r12,sp,-1724
800079da:	f8 06 00 36 	add	r6,r12,r6<<0x3
800079de:	ec fb fd 8c 	ld.w	r11,r6[-628]
800079e2:	50 7b       	stdsp	sp[0x1c],r11
800079e4:	cd 9b       	rjmp	80007996 <_vfprintf_r+0x7b6>
800079e6:	fa c8 f9 50 	sub	r8,sp,-1712
800079ea:	1a d8       	st.w	--sp,r8
800079ec:	fa c8 fa b8 	sub	r8,sp,-1352
800079f0:	04 9a       	mov	r10,r2
800079f2:	1a d8       	st.w	--sp,r8
800079f4:	fa c8 fb b4 	sub	r8,sp,-1100
800079f8:	0c 9b       	mov	r11,r6
800079fa:	1a d8       	st.w	--sp,r8
800079fc:	08 9c       	mov	r12,r4
800079fe:	fa c8 f9 40 	sub	r8,sp,-1728
80007a02:	fa c9 ff b4 	sub	r9,sp,-76
80007a06:	fe b0 fa 55 	rcall	80006eb0 <get_arg>
80007a0a:	2f dd       	sub	sp,-12
80007a0c:	78 1a       	ld.w	r10,r12[0x4]
80007a0e:	50 7a       	stdsp	sp[0x1c],r10
80007a10:	78 0c       	ld.w	r12,r12[0x0]
80007a12:	50 5c       	stdsp	sp[0x14],r12
80007a14:	c2 a8       	rjmp	80007a68 <_vfprintf_r+0x888>
80007a16:	2f f7       	sub	r7,-1
80007a18:	10 39       	cp.w	r9,r8
80007a1a:	c0 94       	brge	80007a2c <_vfprintf_r+0x84c>
80007a1c:	fa c9 f9 44 	sub	r9,sp,-1724
80007a20:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007a24:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007a28:	50 78       	stdsp	sp[0x1c],r8
80007a2a:	cb 6b       	rjmp	80007996 <_vfprintf_r+0x7b6>
80007a2c:	41 09       	lddsp	r9,sp[0x40]
80007a2e:	59 f8       	cp.w	r8,31
80007a30:	e0 89 00 15 	brgt	80007a5a <_vfprintf_r+0x87a>
80007a34:	f2 ca ff f8 	sub	r10,r9,-8
80007a38:	72 16       	ld.w	r6,r9[0x4]
80007a3a:	72 09       	ld.w	r9,r9[0x0]
80007a3c:	51 0a       	stdsp	sp[0x40],r10
80007a3e:	50 59       	stdsp	sp[0x14],r9
80007a40:	fa ce f9 44 	sub	lr,sp,-1724
80007a44:	50 76       	stdsp	sp[0x1c],r6
80007a46:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007a4a:	40 5b       	lddsp	r11,sp[0x14]
80007a4c:	0c 9a       	mov	r10,r6
80007a4e:	f2 eb fd 88 	st.d	r9[-632],r10
80007a52:	2f f8       	sub	r8,-1
80007a54:	fb 48 06 b4 	st.w	sp[1716],r8
80007a58:	c0 88       	rjmp	80007a68 <_vfprintf_r+0x888>
80007a5a:	72 1c       	ld.w	r12,r9[0x4]
80007a5c:	50 7c       	stdsp	sp[0x1c],r12
80007a5e:	f2 c8 ff f8 	sub	r8,r9,-8
80007a62:	51 08       	stdsp	sp[0x40],r8
80007a64:	72 09       	ld.w	r9,r9[0x0]
80007a66:	50 59       	stdsp	sp[0x14],r9
80007a68:	40 5b       	lddsp	r11,sp[0x14]
80007a6a:	40 7a       	lddsp	r10,sp[0x1c]
80007a6c:	e0 a0 19 54 	rcall	8000ad14 <__isinfd>
80007a70:	18 96       	mov	r6,r12
80007a72:	c1 70       	breq	80007aa0 <_vfprintf_r+0x8c0>
80007a74:	30 08       	mov	r8,0
80007a76:	30 09       	mov	r9,0
80007a78:	40 5b       	lddsp	r11,sp[0x14]
80007a7a:	40 7a       	lddsp	r10,sp[0x1c]
80007a7c:	e0 a0 1d a8 	rcall	8000b5cc <__avr32_f64_cmp_lt>
80007a80:	c0 40       	breq	80007a88 <_vfprintf_r+0x8a8>
80007a82:	32 d8       	mov	r8,45
80007a84:	fb 68 06 bb 	st.b	sp[1723],r8
80007a88:	fe c8 ac 34 	sub	r8,pc,-21452
80007a8c:	fe c6 ac 34 	sub	r6,pc,-21452
80007a90:	a7 d5       	cbr	r5,0x7
80007a92:	e0 40 00 47 	cp.w	r0,71
80007a96:	f0 06 17 a0 	movle	r6,r8
80007a9a:	30 32       	mov	r2,3
80007a9c:	e0 8f 06 ce 	bral	80008838 <_vfprintf_r+0x1658>
80007aa0:	40 5b       	lddsp	r11,sp[0x14]
80007aa2:	40 7a       	lddsp	r10,sp[0x1c]
80007aa4:	e0 a0 19 4d 	rcall	8000ad3e <__isnand>
80007aa8:	c0 e0       	breq	80007ac4 <_vfprintf_r+0x8e4>
80007aaa:	50 26       	stdsp	sp[0x8],r6
80007aac:	fe c8 ac 50 	sub	r8,pc,-21424
80007ab0:	fe c6 ac 50 	sub	r6,pc,-21424
80007ab4:	a7 d5       	cbr	r5,0x7
80007ab6:	e0 40 00 47 	cp.w	r0,71
80007aba:	f0 06 17 a0 	movle	r6,r8
80007abe:	30 32       	mov	r2,3
80007ac0:	e0 8f 06 c2 	bral	80008844 <_vfprintf_r+0x1664>
80007ac4:	40 2a       	lddsp	r10,sp[0x8]
80007ac6:	5b fa       	cp.w	r10,-1
80007ac8:	c0 41       	brne	80007ad0 <_vfprintf_r+0x8f0>
80007aca:	30 69       	mov	r9,6
80007acc:	50 29       	stdsp	sp[0x8],r9
80007ace:	c1 18       	rjmp	80007af0 <_vfprintf_r+0x910>
80007ad0:	e0 40 00 47 	cp.w	r0,71
80007ad4:	5f 09       	sreq	r9
80007ad6:	e0 40 00 67 	cp.w	r0,103
80007ada:	5f 08       	sreq	r8
80007adc:	f3 e8 10 08 	or	r8,r9,r8
80007ae0:	f8 08 18 00 	cp.b	r8,r12
80007ae4:	c0 60       	breq	80007af0 <_vfprintf_r+0x910>
80007ae6:	40 28       	lddsp	r8,sp[0x8]
80007ae8:	58 08       	cp.w	r8,0
80007aea:	f9 b8 00 01 	moveq	r8,1
80007aee:	50 28       	stdsp	sp[0x8],r8
80007af0:	40 78       	lddsp	r8,sp[0x1c]
80007af2:	40 59       	lddsp	r9,sp[0x14]
80007af4:	fa e9 06 94 	st.d	sp[1684],r8
80007af8:	a9 a5       	sbr	r5,0x8
80007afa:	fa f8 06 94 	ld.w	r8,sp[1684]
80007afe:	58 08       	cp.w	r8,0
80007b00:	c0 65       	brlt	80007b0c <_vfprintf_r+0x92c>
80007b02:	40 5e       	lddsp	lr,sp[0x14]
80007b04:	30 0c       	mov	r12,0
80007b06:	50 6e       	stdsp	sp[0x18],lr
80007b08:	50 9c       	stdsp	sp[0x24],r12
80007b0a:	c0 78       	rjmp	80007b18 <_vfprintf_r+0x938>
80007b0c:	40 5b       	lddsp	r11,sp[0x14]
80007b0e:	32 da       	mov	r10,45
80007b10:	ee 1b 80 00 	eorh	r11,0x8000
80007b14:	50 9a       	stdsp	sp[0x24],r10
80007b16:	50 6b       	stdsp	sp[0x18],r11
80007b18:	e0 40 00 46 	cp.w	r0,70
80007b1c:	5f 09       	sreq	r9
80007b1e:	e0 40 00 66 	cp.w	r0,102
80007b22:	5f 08       	sreq	r8
80007b24:	f3 e8 10 08 	or	r8,r9,r8
80007b28:	50 48       	stdsp	sp[0x10],r8
80007b2a:	c0 40       	breq	80007b32 <_vfprintf_r+0x952>
80007b2c:	40 22       	lddsp	r2,sp[0x8]
80007b2e:	30 39       	mov	r9,3
80007b30:	c1 08       	rjmp	80007b50 <_vfprintf_r+0x970>
80007b32:	e0 40 00 45 	cp.w	r0,69
80007b36:	5f 09       	sreq	r9
80007b38:	e0 40 00 65 	cp.w	r0,101
80007b3c:	5f 08       	sreq	r8
80007b3e:	40 22       	lddsp	r2,sp[0x8]
80007b40:	10 49       	or	r9,r8
80007b42:	2f f2       	sub	r2,-1
80007b44:	40 46       	lddsp	r6,sp[0x10]
80007b46:	ec 09 18 00 	cp.b	r9,r6
80007b4a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007b4e:	30 29       	mov	r9,2
80007b50:	fa c8 f9 5c 	sub	r8,sp,-1700
80007b54:	1a d8       	st.w	--sp,r8
80007b56:	fa c8 f9 54 	sub	r8,sp,-1708
80007b5a:	1a d8       	st.w	--sp,r8
80007b5c:	fa c8 f9 4c 	sub	r8,sp,-1716
80007b60:	08 9c       	mov	r12,r4
80007b62:	1a d8       	st.w	--sp,r8
80007b64:	04 98       	mov	r8,r2
80007b66:	40 9b       	lddsp	r11,sp[0x24]
80007b68:	40 aa       	lddsp	r10,sp[0x28]
80007b6a:	e0 a0 0b c3 	rcall	800092f0 <_dtoa_r>
80007b6e:	e0 40 00 47 	cp.w	r0,71
80007b72:	5f 19       	srne	r9
80007b74:	e0 40 00 67 	cp.w	r0,103
80007b78:	5f 18       	srne	r8
80007b7a:	18 96       	mov	r6,r12
80007b7c:	2f dd       	sub	sp,-12
80007b7e:	f3 e8 00 08 	and	r8,r9,r8
80007b82:	c0 41       	brne	80007b8a <_vfprintf_r+0x9aa>
80007b84:	ed b5 00 00 	bld	r5,0x0
80007b88:	c3 01       	brne	80007be8 <_vfprintf_r+0xa08>
80007b8a:	ec 02 00 0e 	add	lr,r6,r2
80007b8e:	50 3e       	stdsp	sp[0xc],lr
80007b90:	40 4c       	lddsp	r12,sp[0x10]
80007b92:	58 0c       	cp.w	r12,0
80007b94:	c1 50       	breq	80007bbe <_vfprintf_r+0x9de>
80007b96:	0d 89       	ld.ub	r9,r6[0x0]
80007b98:	33 08       	mov	r8,48
80007b9a:	f0 09 18 00 	cp.b	r9,r8
80007b9e:	c0 b1       	brne	80007bb4 <_vfprintf_r+0x9d4>
80007ba0:	30 08       	mov	r8,0
80007ba2:	30 09       	mov	r9,0
80007ba4:	40 6b       	lddsp	r11,sp[0x18]
80007ba6:	40 7a       	lddsp	r10,sp[0x1c]
80007ba8:	e0 a0 1c cb 	rcall	8000b53e <__avr32_f64_cmp_eq>
80007bac:	fb b2 00 01 	rsubeq	r2,1
80007bb0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007bb4:	40 3b       	lddsp	r11,sp[0xc]
80007bb6:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007bba:	10 0b       	add	r11,r8
80007bbc:	50 3b       	stdsp	sp[0xc],r11
80007bbe:	40 6b       	lddsp	r11,sp[0x18]
80007bc0:	30 08       	mov	r8,0
80007bc2:	30 09       	mov	r9,0
80007bc4:	40 7a       	lddsp	r10,sp[0x1c]
80007bc6:	e0 a0 1c bc 	rcall	8000b53e <__avr32_f64_cmp_eq>
80007bca:	c0 90       	breq	80007bdc <_vfprintf_r+0x9fc>
80007bcc:	40 3a       	lddsp	r10,sp[0xc]
80007bce:	fb 4a 06 a4 	st.w	sp[1700],r10
80007bd2:	c0 58       	rjmp	80007bdc <_vfprintf_r+0x9fc>
80007bd4:	10 c9       	st.b	r8++,r9
80007bd6:	fb 48 06 a4 	st.w	sp[1700],r8
80007bda:	c0 28       	rjmp	80007bde <_vfprintf_r+0x9fe>
80007bdc:	33 09       	mov	r9,48
80007bde:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007be2:	40 3e       	lddsp	lr,sp[0xc]
80007be4:	1c 38       	cp.w	r8,lr
80007be6:	cf 73       	brcs	80007bd4 <_vfprintf_r+0x9f4>
80007be8:	e0 40 00 47 	cp.w	r0,71
80007bec:	5f 09       	sreq	r9
80007bee:	e0 40 00 67 	cp.w	r0,103
80007bf2:	5f 08       	sreq	r8
80007bf4:	f3 e8 10 08 	or	r8,r9,r8
80007bf8:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007bfc:	0c 19       	sub	r9,r6
80007bfe:	50 69       	stdsp	sp[0x18],r9
80007c00:	58 08       	cp.w	r8,0
80007c02:	c0 b0       	breq	80007c18 <_vfprintf_r+0xa38>
80007c04:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007c08:	5b d8       	cp.w	r8,-3
80007c0a:	c0 55       	brlt	80007c14 <_vfprintf_r+0xa34>
80007c0c:	40 2c       	lddsp	r12,sp[0x8]
80007c0e:	18 38       	cp.w	r8,r12
80007c10:	e0 8a 00 6a 	brle	80007ce4 <_vfprintf_r+0xb04>
80007c14:	20 20       	sub	r0,2
80007c16:	c0 58       	rjmp	80007c20 <_vfprintf_r+0xa40>
80007c18:	e0 40 00 65 	cp.w	r0,101
80007c1c:	e0 89 00 46 	brgt	80007ca8 <_vfprintf_r+0xac8>
80007c20:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007c24:	fb 60 06 9c 	st.b	sp[1692],r0
80007c28:	20 1b       	sub	r11,1
80007c2a:	fb 4b 06 ac 	st.w	sp[1708],r11
80007c2e:	c0 47       	brpl	80007c36 <_vfprintf_r+0xa56>
80007c30:	5c 3b       	neg	r11
80007c32:	32 d8       	mov	r8,45
80007c34:	c0 28       	rjmp	80007c38 <_vfprintf_r+0xa58>
80007c36:	32 b8       	mov	r8,43
80007c38:	fb 68 06 9d 	st.b	sp[1693],r8
80007c3c:	58 9b       	cp.w	r11,9
80007c3e:	e0 8a 00 1d 	brle	80007c78 <_vfprintf_r+0xa98>
80007c42:	fa c9 fa 35 	sub	r9,sp,-1483
80007c46:	30 aa       	mov	r10,10
80007c48:	12 98       	mov	r8,r9
80007c4a:	0e 9c       	mov	r12,r7
80007c4c:	0c 92       	mov	r2,r6
80007c4e:	f6 0a 0c 06 	divs	r6,r11,r10
80007c52:	0e 9b       	mov	r11,r7
80007c54:	2d 0b       	sub	r11,-48
80007c56:	10 fb       	st.b	--r8,r11
80007c58:	0c 9b       	mov	r11,r6
80007c5a:	58 96       	cp.w	r6,9
80007c5c:	fe 99 ff f9 	brgt	80007c4e <_vfprintf_r+0xa6e>
80007c60:	2d 0b       	sub	r11,-48
80007c62:	18 97       	mov	r7,r12
80007c64:	04 96       	mov	r6,r2
80007c66:	10 fb       	st.b	--r8,r11
80007c68:	fa ca f9 62 	sub	r10,sp,-1694
80007c6c:	c0 38       	rjmp	80007c72 <_vfprintf_r+0xa92>
80007c6e:	11 3b       	ld.ub	r11,r8++
80007c70:	14 cb       	st.b	r10++,r11
80007c72:	12 38       	cp.w	r8,r9
80007c74:	cf d3       	brcs	80007c6e <_vfprintf_r+0xa8e>
80007c76:	c0 98       	rjmp	80007c88 <_vfprintf_r+0xaa8>
80007c78:	2d 0b       	sub	r11,-48
80007c7a:	33 08       	mov	r8,48
80007c7c:	fb 6b 06 9f 	st.b	sp[1695],r11
80007c80:	fb 68 06 9e 	st.b	sp[1694],r8
80007c84:	fa ca f9 60 	sub	r10,sp,-1696
80007c88:	fa c8 f9 64 	sub	r8,sp,-1692
80007c8c:	f4 08 01 08 	sub	r8,r10,r8
80007c90:	50 e8       	stdsp	sp[0x38],r8
80007c92:	10 92       	mov	r2,r8
80007c94:	40 6b       	lddsp	r11,sp[0x18]
80007c96:	16 02       	add	r2,r11
80007c98:	58 1b       	cp.w	r11,1
80007c9a:	e0 89 00 05 	brgt	80007ca4 <_vfprintf_r+0xac4>
80007c9e:	ed b5 00 00 	bld	r5,0x0
80007ca2:	c3 51       	brne	80007d0c <_vfprintf_r+0xb2c>
80007ca4:	2f f2       	sub	r2,-1
80007ca6:	c3 38       	rjmp	80007d0c <_vfprintf_r+0xb2c>
80007ca8:	e0 40 00 66 	cp.w	r0,102
80007cac:	c1 c1       	brne	80007ce4 <_vfprintf_r+0xb04>
80007cae:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007cb2:	58 02       	cp.w	r2,0
80007cb4:	e0 8a 00 0c 	brle	80007ccc <_vfprintf_r+0xaec>
80007cb8:	40 2a       	lddsp	r10,sp[0x8]
80007cba:	58 0a       	cp.w	r10,0
80007cbc:	c0 41       	brne	80007cc4 <_vfprintf_r+0xae4>
80007cbe:	ed b5 00 00 	bld	r5,0x0
80007cc2:	c2 51       	brne	80007d0c <_vfprintf_r+0xb2c>
80007cc4:	2f f2       	sub	r2,-1
80007cc6:	40 29       	lddsp	r9,sp[0x8]
80007cc8:	12 02       	add	r2,r9
80007cca:	c0 b8       	rjmp	80007ce0 <_vfprintf_r+0xb00>
80007ccc:	40 28       	lddsp	r8,sp[0x8]
80007cce:	58 08       	cp.w	r8,0
80007cd0:	c0 61       	brne	80007cdc <_vfprintf_r+0xafc>
80007cd2:	ed b5 00 00 	bld	r5,0x0
80007cd6:	c0 30       	breq	80007cdc <_vfprintf_r+0xafc>
80007cd8:	30 12       	mov	r2,1
80007cda:	c1 98       	rjmp	80007d0c <_vfprintf_r+0xb2c>
80007cdc:	40 22       	lddsp	r2,sp[0x8]
80007cde:	2f e2       	sub	r2,-2
80007ce0:	36 60       	mov	r0,102
80007ce2:	c1 58       	rjmp	80007d0c <_vfprintf_r+0xb2c>
80007ce4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007ce8:	40 6e       	lddsp	lr,sp[0x18]
80007cea:	1c 32       	cp.w	r2,lr
80007cec:	c0 65       	brlt	80007cf8 <_vfprintf_r+0xb18>
80007cee:	ed b5 00 00 	bld	r5,0x0
80007cf2:	f7 b2 00 ff 	subeq	r2,-1
80007cf6:	c0 a8       	rjmp	80007d0a <_vfprintf_r+0xb2a>
80007cf8:	e4 08 11 02 	rsub	r8,r2,2
80007cfc:	40 6c       	lddsp	r12,sp[0x18]
80007cfe:	58 02       	cp.w	r2,0
80007d00:	f0 02 17 a0 	movle	r2,r8
80007d04:	f9 b2 09 01 	movgt	r2,1
80007d08:	18 02       	add	r2,r12
80007d0a:	36 70       	mov	r0,103
80007d0c:	40 9b       	lddsp	r11,sp[0x24]
80007d0e:	58 0b       	cp.w	r11,0
80007d10:	e0 80 05 94 	breq	80008838 <_vfprintf_r+0x1658>
80007d14:	32 d8       	mov	r8,45
80007d16:	fb 68 06 bb 	st.b	sp[1723],r8
80007d1a:	e0 8f 05 93 	bral	80008840 <_vfprintf_r+0x1660>
80007d1e:	50 a7       	stdsp	sp[0x28],r7
80007d20:	04 94       	mov	r4,r2
80007d22:	0c 97       	mov	r7,r6
80007d24:	02 92       	mov	r2,r1
80007d26:	06 96       	mov	r6,r3
80007d28:	40 41       	lddsp	r1,sp[0x10]
80007d2a:	40 93       	lddsp	r3,sp[0x24]
80007d2c:	0e 99       	mov	r9,r7
80007d2e:	ed b5 00 05 	bld	r5,0x5
80007d32:	c4 81       	brne	80007dc2 <_vfprintf_r+0xbe2>
80007d34:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d38:	40 3e       	lddsp	lr,sp[0xc]
80007d3a:	58 0e       	cp.w	lr,0
80007d3c:	c1 d0       	breq	80007d76 <_vfprintf_r+0xb96>
80007d3e:	10 36       	cp.w	r6,r8
80007d40:	c0 64       	brge	80007d4c <_vfprintf_r+0xb6c>
80007d42:	fa cc f9 44 	sub	r12,sp,-1724
80007d46:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007d4a:	c1 d8       	rjmp	80007d84 <_vfprintf_r+0xba4>
80007d4c:	fa c8 f9 50 	sub	r8,sp,-1712
80007d50:	1a d8       	st.w	--sp,r8
80007d52:	fa c8 fa b8 	sub	r8,sp,-1352
80007d56:	04 9a       	mov	r10,r2
80007d58:	1a d8       	st.w	--sp,r8
80007d5a:	fa c8 fb b4 	sub	r8,sp,-1100
80007d5e:	0c 9b       	mov	r11,r6
80007d60:	1a d8       	st.w	--sp,r8
80007d62:	08 9c       	mov	r12,r4
80007d64:	fa c8 f9 40 	sub	r8,sp,-1728
80007d68:	fa c9 ff b4 	sub	r9,sp,-76
80007d6c:	fe b0 f8 a2 	rcall	80006eb0 <get_arg>
80007d70:	2f dd       	sub	sp,-12
80007d72:	78 0a       	ld.w	r10,r12[0x0]
80007d74:	c2 08       	rjmp	80007db4 <_vfprintf_r+0xbd4>
80007d76:	2f f7       	sub	r7,-1
80007d78:	10 39       	cp.w	r9,r8
80007d7a:	c0 84       	brge	80007d8a <_vfprintf_r+0xbaa>
80007d7c:	fa cb f9 44 	sub	r11,sp,-1724
80007d80:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d84:	ec fa fd 88 	ld.w	r10,r6[-632]
80007d88:	c1 68       	rjmp	80007db4 <_vfprintf_r+0xbd4>
80007d8a:	41 09       	lddsp	r9,sp[0x40]
80007d8c:	59 f8       	cp.w	r8,31
80007d8e:	e0 89 00 10 	brgt	80007dae <_vfprintf_r+0xbce>
80007d92:	f2 ca ff fc 	sub	r10,r9,-4
80007d96:	51 0a       	stdsp	sp[0x40],r10
80007d98:	fa c6 f9 44 	sub	r6,sp,-1724
80007d9c:	72 0a       	ld.w	r10,r9[0x0]
80007d9e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007da2:	f3 4a fd 88 	st.w	r9[-632],r10
80007da6:	2f f8       	sub	r8,-1
80007da8:	fb 48 06 b4 	st.w	sp[1716],r8
80007dac:	c0 48       	rjmp	80007db4 <_vfprintf_r+0xbd4>
80007dae:	72 0a       	ld.w	r10,r9[0x0]
80007db0:	2f c9       	sub	r9,-4
80007db2:	51 09       	stdsp	sp[0x40],r9
80007db4:	40 be       	lddsp	lr,sp[0x2c]
80007db6:	1c 98       	mov	r8,lr
80007db8:	95 1e       	st.w	r10[0x4],lr
80007dba:	bf 58       	asr	r8,0x1f
80007dbc:	95 08       	st.w	r10[0x0],r8
80007dbe:	fe 9f fa 9f 	bral	800072fc <_vfprintf_r+0x11c>
80007dc2:	ed b5 00 04 	bld	r5,0x4
80007dc6:	c4 80       	breq	80007e56 <_vfprintf_r+0xc76>
80007dc8:	e2 15 00 40 	andl	r5,0x40,COH
80007dcc:	c4 50       	breq	80007e56 <_vfprintf_r+0xc76>
80007dce:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dd2:	40 3c       	lddsp	r12,sp[0xc]
80007dd4:	58 0c       	cp.w	r12,0
80007dd6:	c1 d0       	breq	80007e10 <_vfprintf_r+0xc30>
80007dd8:	10 36       	cp.w	r6,r8
80007dda:	c0 64       	brge	80007de6 <_vfprintf_r+0xc06>
80007ddc:	fa cb f9 44 	sub	r11,sp,-1724
80007de0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007de4:	c1 d8       	rjmp	80007e1e <_vfprintf_r+0xc3e>
80007de6:	fa c8 f9 50 	sub	r8,sp,-1712
80007dea:	1a d8       	st.w	--sp,r8
80007dec:	fa c8 fa b8 	sub	r8,sp,-1352
80007df0:	04 9a       	mov	r10,r2
80007df2:	1a d8       	st.w	--sp,r8
80007df4:	fa c8 fb b4 	sub	r8,sp,-1100
80007df8:	0c 9b       	mov	r11,r6
80007dfa:	1a d8       	st.w	--sp,r8
80007dfc:	08 9c       	mov	r12,r4
80007dfe:	fa c8 f9 40 	sub	r8,sp,-1728
80007e02:	fa c9 ff b4 	sub	r9,sp,-76
80007e06:	fe b0 f8 55 	rcall	80006eb0 <get_arg>
80007e0a:	2f dd       	sub	sp,-12
80007e0c:	78 0a       	ld.w	r10,r12[0x0]
80007e0e:	c2 08       	rjmp	80007e4e <_vfprintf_r+0xc6e>
80007e10:	2f f7       	sub	r7,-1
80007e12:	10 39       	cp.w	r9,r8
80007e14:	c0 84       	brge	80007e24 <_vfprintf_r+0xc44>
80007e16:	fa ca f9 44 	sub	r10,sp,-1724
80007e1a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007e1e:	ec fa fd 88 	ld.w	r10,r6[-632]
80007e22:	c1 68       	rjmp	80007e4e <_vfprintf_r+0xc6e>
80007e24:	41 09       	lddsp	r9,sp[0x40]
80007e26:	59 f8       	cp.w	r8,31
80007e28:	e0 89 00 10 	brgt	80007e48 <_vfprintf_r+0xc68>
80007e2c:	f2 ca ff fc 	sub	r10,r9,-4
80007e30:	51 0a       	stdsp	sp[0x40],r10
80007e32:	fa c6 f9 44 	sub	r6,sp,-1724
80007e36:	72 0a       	ld.w	r10,r9[0x0]
80007e38:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e3c:	f3 4a fd 88 	st.w	r9[-632],r10
80007e40:	2f f8       	sub	r8,-1
80007e42:	fb 48 06 b4 	st.w	sp[1716],r8
80007e46:	c0 48       	rjmp	80007e4e <_vfprintf_r+0xc6e>
80007e48:	72 0a       	ld.w	r10,r9[0x0]
80007e4a:	2f c9       	sub	r9,-4
80007e4c:	51 09       	stdsp	sp[0x40],r9
80007e4e:	40 be       	lddsp	lr,sp[0x2c]
80007e50:	b4 0e       	st.h	r10[0x0],lr
80007e52:	fe 9f fa 55 	bral	800072fc <_vfprintf_r+0x11c>
80007e56:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e5a:	40 3c       	lddsp	r12,sp[0xc]
80007e5c:	58 0c       	cp.w	r12,0
80007e5e:	c1 d0       	breq	80007e98 <_vfprintf_r+0xcb8>
80007e60:	10 36       	cp.w	r6,r8
80007e62:	c0 64       	brge	80007e6e <_vfprintf_r+0xc8e>
80007e64:	fa cb f9 44 	sub	r11,sp,-1724
80007e68:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e6c:	c1 d8       	rjmp	80007ea6 <_vfprintf_r+0xcc6>
80007e6e:	fa c8 f9 50 	sub	r8,sp,-1712
80007e72:	1a d8       	st.w	--sp,r8
80007e74:	fa c8 fa b8 	sub	r8,sp,-1352
80007e78:	04 9a       	mov	r10,r2
80007e7a:	1a d8       	st.w	--sp,r8
80007e7c:	fa c8 fb b4 	sub	r8,sp,-1100
80007e80:	0c 9b       	mov	r11,r6
80007e82:	1a d8       	st.w	--sp,r8
80007e84:	08 9c       	mov	r12,r4
80007e86:	fa c8 f9 40 	sub	r8,sp,-1728
80007e8a:	fa c9 ff b4 	sub	r9,sp,-76
80007e8e:	fe b0 f8 11 	rcall	80006eb0 <get_arg>
80007e92:	2f dd       	sub	sp,-12
80007e94:	78 0a       	ld.w	r10,r12[0x0]
80007e96:	c2 08       	rjmp	80007ed6 <_vfprintf_r+0xcf6>
80007e98:	2f f7       	sub	r7,-1
80007e9a:	10 39       	cp.w	r9,r8
80007e9c:	c0 84       	brge	80007eac <_vfprintf_r+0xccc>
80007e9e:	fa ca f9 44 	sub	r10,sp,-1724
80007ea2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007ea6:	ec fa fd 88 	ld.w	r10,r6[-632]
80007eaa:	c1 68       	rjmp	80007ed6 <_vfprintf_r+0xcf6>
80007eac:	41 09       	lddsp	r9,sp[0x40]
80007eae:	59 f8       	cp.w	r8,31
80007eb0:	e0 89 00 10 	brgt	80007ed0 <_vfprintf_r+0xcf0>
80007eb4:	f2 ca ff fc 	sub	r10,r9,-4
80007eb8:	51 0a       	stdsp	sp[0x40],r10
80007eba:	fa c6 f9 44 	sub	r6,sp,-1724
80007ebe:	72 0a       	ld.w	r10,r9[0x0]
80007ec0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ec4:	f3 4a fd 88 	st.w	r9[-632],r10
80007ec8:	2f f8       	sub	r8,-1
80007eca:	fb 48 06 b4 	st.w	sp[1716],r8
80007ece:	c0 48       	rjmp	80007ed6 <_vfprintf_r+0xcf6>
80007ed0:	72 0a       	ld.w	r10,r9[0x0]
80007ed2:	2f c9       	sub	r9,-4
80007ed4:	51 09       	stdsp	sp[0x40],r9
80007ed6:	40 be       	lddsp	lr,sp[0x2c]
80007ed8:	95 0e       	st.w	r10[0x0],lr
80007eda:	fe 9f fa 11 	bral	800072fc <_vfprintf_r+0x11c>
80007ede:	50 a7       	stdsp	sp[0x28],r7
80007ee0:	50 80       	stdsp	sp[0x20],r0
80007ee2:	0c 97       	mov	r7,r6
80007ee4:	04 94       	mov	r4,r2
80007ee6:	06 96       	mov	r6,r3
80007ee8:	02 92       	mov	r2,r1
80007eea:	40 93       	lddsp	r3,sp[0x24]
80007eec:	10 90       	mov	r0,r8
80007eee:	40 41       	lddsp	r1,sp[0x10]
80007ef0:	a5 a5       	sbr	r5,0x4
80007ef2:	c0 a8       	rjmp	80007f06 <_vfprintf_r+0xd26>
80007ef4:	50 a7       	stdsp	sp[0x28],r7
80007ef6:	50 80       	stdsp	sp[0x20],r0
80007ef8:	0c 97       	mov	r7,r6
80007efa:	04 94       	mov	r4,r2
80007efc:	06 96       	mov	r6,r3
80007efe:	02 92       	mov	r2,r1
80007f00:	40 93       	lddsp	r3,sp[0x24]
80007f02:	10 90       	mov	r0,r8
80007f04:	40 41       	lddsp	r1,sp[0x10]
80007f06:	ed b5 00 05 	bld	r5,0x5
80007f0a:	c5 d1       	brne	80007fc4 <_vfprintf_r+0xde4>
80007f0c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f10:	40 3c       	lddsp	r12,sp[0xc]
80007f12:	58 0c       	cp.w	r12,0
80007f14:	c2 60       	breq	80007f60 <_vfprintf_r+0xd80>
80007f16:	10 36       	cp.w	r6,r8
80007f18:	c0 a4       	brge	80007f2c <_vfprintf_r+0xd4c>
80007f1a:	fa cb f9 44 	sub	r11,sp,-1724
80007f1e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f22:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007f26:	fa e9 00 00 	st.d	sp[0],r8
80007f2a:	c1 88       	rjmp	80007f5a <_vfprintf_r+0xd7a>
80007f2c:	fa c8 f9 50 	sub	r8,sp,-1712
80007f30:	1a d8       	st.w	--sp,r8
80007f32:	fa c8 fa b8 	sub	r8,sp,-1352
80007f36:	04 9a       	mov	r10,r2
80007f38:	1a d8       	st.w	--sp,r8
80007f3a:	0c 9b       	mov	r11,r6
80007f3c:	fa c8 fb b4 	sub	r8,sp,-1100
80007f40:	08 9c       	mov	r12,r4
80007f42:	1a d8       	st.w	--sp,r8
80007f44:	fa c8 f9 40 	sub	r8,sp,-1728
80007f48:	fa c9 ff b4 	sub	r9,sp,-76
80007f4c:	fe b0 f7 b2 	rcall	80006eb0 <get_arg>
80007f50:	2f dd       	sub	sp,-12
80007f52:	f8 ea 00 00 	ld.d	r10,r12[0]
80007f56:	fa eb 00 00 	st.d	sp[0],r10
80007f5a:	30 08       	mov	r8,0
80007f5c:	e0 8f 03 de 	bral	80008718 <_vfprintf_r+0x1538>
80007f60:	ee ca ff ff 	sub	r10,r7,-1
80007f64:	10 37       	cp.w	r7,r8
80007f66:	c0 b4       	brge	80007f7c <_vfprintf_r+0xd9c>
80007f68:	fa c9 f9 44 	sub	r9,sp,-1724
80007f6c:	14 97       	mov	r7,r10
80007f6e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f72:	ec ea fd 88 	ld.d	r10,r6[-632]
80007f76:	fa eb 00 00 	st.d	sp[0],r10
80007f7a:	c1 88       	rjmp	80007faa <_vfprintf_r+0xdca>
80007f7c:	41 09       	lddsp	r9,sp[0x40]
80007f7e:	59 f8       	cp.w	r8,31
80007f80:	e0 89 00 18 	brgt	80007fb0 <_vfprintf_r+0xdd0>
80007f84:	f2 e6 00 00 	ld.d	r6,r9[0]
80007f88:	f2 cb ff f8 	sub	r11,r9,-8
80007f8c:	fa e7 00 00 	st.d	sp[0],r6
80007f90:	51 0b       	stdsp	sp[0x40],r11
80007f92:	fa c6 f9 44 	sub	r6,sp,-1724
80007f96:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007f9a:	fa e6 00 00 	ld.d	r6,sp[0]
80007f9e:	f2 e7 fd 88 	st.d	r9[-632],r6
80007fa2:	2f f8       	sub	r8,-1
80007fa4:	14 97       	mov	r7,r10
80007fa6:	fb 48 06 b4 	st.w	sp[1716],r8
80007faa:	40 38       	lddsp	r8,sp[0xc]
80007fac:	e0 8f 03 b6 	bral	80008718 <_vfprintf_r+0x1538>
80007fb0:	f2 e6 00 00 	ld.d	r6,r9[0]
80007fb4:	40 38       	lddsp	r8,sp[0xc]
80007fb6:	fa e7 00 00 	st.d	sp[0],r6
80007fba:	2f 89       	sub	r9,-8
80007fbc:	14 97       	mov	r7,r10
80007fbe:	51 09       	stdsp	sp[0x40],r9
80007fc0:	e0 8f 03 ac 	bral	80008718 <_vfprintf_r+0x1538>
80007fc4:	ed b5 00 04 	bld	r5,0x4
80007fc8:	c1 61       	brne	80007ff4 <_vfprintf_r+0xe14>
80007fca:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fce:	40 3e       	lddsp	lr,sp[0xc]
80007fd0:	58 0e       	cp.w	lr,0
80007fd2:	c0 80       	breq	80007fe2 <_vfprintf_r+0xe02>
80007fd4:	10 36       	cp.w	r6,r8
80007fd6:	c6 74       	brge	800080a4 <_vfprintf_r+0xec4>
80007fd8:	fa cc f9 44 	sub	r12,sp,-1724
80007fdc:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007fe0:	c8 08       	rjmp	800080e0 <_vfprintf_r+0xf00>
80007fe2:	ee ca ff ff 	sub	r10,r7,-1
80007fe6:	10 37       	cp.w	r7,r8
80007fe8:	c7 f4       	brge	800080e6 <_vfprintf_r+0xf06>
80007fea:	fa cb f9 44 	sub	r11,sp,-1724
80007fee:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ff2:	c7 68       	rjmp	800080de <_vfprintf_r+0xefe>
80007ff4:	ed b5 00 06 	bld	r5,0x6
80007ff8:	c4 a1       	brne	8000808c <_vfprintf_r+0xeac>
80007ffa:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ffe:	40 3c       	lddsp	r12,sp[0xc]
80008000:	58 0c       	cp.w	r12,0
80008002:	c1 d0       	breq	8000803c <_vfprintf_r+0xe5c>
80008004:	10 36       	cp.w	r6,r8
80008006:	c0 64       	brge	80008012 <_vfprintf_r+0xe32>
80008008:	fa cb f9 44 	sub	r11,sp,-1724
8000800c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008010:	c1 f8       	rjmp	8000804e <_vfprintf_r+0xe6e>
80008012:	fa c8 f9 50 	sub	r8,sp,-1712
80008016:	1a d8       	st.w	--sp,r8
80008018:	fa c8 fa b8 	sub	r8,sp,-1352
8000801c:	1a d8       	st.w	--sp,r8
8000801e:	fa c8 fb b4 	sub	r8,sp,-1100
80008022:	1a d8       	st.w	--sp,r8
80008024:	fa c8 f9 40 	sub	r8,sp,-1728
80008028:	fa c9 ff b4 	sub	r9,sp,-76
8000802c:	04 9a       	mov	r10,r2
8000802e:	0c 9b       	mov	r11,r6
80008030:	08 9c       	mov	r12,r4
80008032:	fe b0 f7 3f 	rcall	80006eb0 <get_arg>
80008036:	2f dd       	sub	sp,-12
80008038:	98 18       	ld.sh	r8,r12[0x2]
8000803a:	c2 68       	rjmp	80008086 <_vfprintf_r+0xea6>
8000803c:	ee ca ff ff 	sub	r10,r7,-1
80008040:	10 37       	cp.w	r7,r8
80008042:	c0 94       	brge	80008054 <_vfprintf_r+0xe74>
80008044:	fa c9 f9 44 	sub	r9,sp,-1724
80008048:	14 97       	mov	r7,r10
8000804a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000804e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008052:	c1 a8       	rjmp	80008086 <_vfprintf_r+0xea6>
80008054:	41 09       	lddsp	r9,sp[0x40]
80008056:	59 f8       	cp.w	r8,31
80008058:	e0 89 00 13 	brgt	8000807e <_vfprintf_r+0xe9e>
8000805c:	f2 cb ff fc 	sub	r11,r9,-4
80008060:	51 0b       	stdsp	sp[0x40],r11
80008062:	72 09       	ld.w	r9,r9[0x0]
80008064:	fa c6 f9 44 	sub	r6,sp,-1724
80008068:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000806c:	2f f8       	sub	r8,-1
8000806e:	f7 49 fd 88 	st.w	r11[-632],r9
80008072:	fb 48 06 b4 	st.w	sp[1716],r8
80008076:	14 97       	mov	r7,r10
80008078:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000807c:	c0 58       	rjmp	80008086 <_vfprintf_r+0xea6>
8000807e:	92 18       	ld.sh	r8,r9[0x2]
80008080:	14 97       	mov	r7,r10
80008082:	2f c9       	sub	r9,-4
80008084:	51 09       	stdsp	sp[0x40],r9
80008086:	5c 78       	castu.h	r8
80008088:	50 18       	stdsp	sp[0x4],r8
8000808a:	c4 68       	rjmp	80008116 <_vfprintf_r+0xf36>
8000808c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008090:	40 3c       	lddsp	r12,sp[0xc]
80008092:	58 0c       	cp.w	r12,0
80008094:	c1 d0       	breq	800080ce <_vfprintf_r+0xeee>
80008096:	10 36       	cp.w	r6,r8
80008098:	c0 64       	brge	800080a4 <_vfprintf_r+0xec4>
8000809a:	fa cb f9 44 	sub	r11,sp,-1724
8000809e:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080a2:	c1 f8       	rjmp	800080e0 <_vfprintf_r+0xf00>
800080a4:	fa c8 f9 50 	sub	r8,sp,-1712
800080a8:	1a d8       	st.w	--sp,r8
800080aa:	fa c8 fa b8 	sub	r8,sp,-1352
800080ae:	0c 9b       	mov	r11,r6
800080b0:	1a d8       	st.w	--sp,r8
800080b2:	fa c8 fb b4 	sub	r8,sp,-1100
800080b6:	04 9a       	mov	r10,r2
800080b8:	1a d8       	st.w	--sp,r8
800080ba:	08 9c       	mov	r12,r4
800080bc:	fa c8 f9 40 	sub	r8,sp,-1728
800080c0:	fa c9 ff b4 	sub	r9,sp,-76
800080c4:	fe b0 f6 f6 	rcall	80006eb0 <get_arg>
800080c8:	2f dd       	sub	sp,-12
800080ca:	78 0b       	ld.w	r11,r12[0x0]
800080cc:	c2 48       	rjmp	80008114 <_vfprintf_r+0xf34>
800080ce:	ee ca ff ff 	sub	r10,r7,-1
800080d2:	10 37       	cp.w	r7,r8
800080d4:	c0 94       	brge	800080e6 <_vfprintf_r+0xf06>
800080d6:	fa c9 f9 44 	sub	r9,sp,-1724
800080da:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080de:	14 97       	mov	r7,r10
800080e0:	ec fb fd 88 	ld.w	r11,r6[-632]
800080e4:	c1 88       	rjmp	80008114 <_vfprintf_r+0xf34>
800080e6:	41 09       	lddsp	r9,sp[0x40]
800080e8:	59 f8       	cp.w	r8,31
800080ea:	e0 89 00 11 	brgt	8000810c <_vfprintf_r+0xf2c>
800080ee:	f2 cb ff fc 	sub	r11,r9,-4
800080f2:	51 0b       	stdsp	sp[0x40],r11
800080f4:	fa c6 f9 44 	sub	r6,sp,-1724
800080f8:	72 0b       	ld.w	r11,r9[0x0]
800080fa:	ec 08 00 39 	add	r9,r6,r8<<0x3
800080fe:	f3 4b fd 88 	st.w	r9[-632],r11
80008102:	2f f8       	sub	r8,-1
80008104:	14 97       	mov	r7,r10
80008106:	fb 48 06 b4 	st.w	sp[1716],r8
8000810a:	c0 58       	rjmp	80008114 <_vfprintf_r+0xf34>
8000810c:	72 0b       	ld.w	r11,r9[0x0]
8000810e:	14 97       	mov	r7,r10
80008110:	2f c9       	sub	r9,-4
80008112:	51 09       	stdsp	sp[0x40],r9
80008114:	50 1b       	stdsp	sp[0x4],r11
80008116:	30 0e       	mov	lr,0
80008118:	50 0e       	stdsp	sp[0x0],lr
8000811a:	1c 98       	mov	r8,lr
8000811c:	e0 8f 02 fe 	bral	80008718 <_vfprintf_r+0x1538>
80008120:	50 a7       	stdsp	sp[0x28],r7
80008122:	50 80       	stdsp	sp[0x20],r0
80008124:	0c 97       	mov	r7,r6
80008126:	04 94       	mov	r4,r2
80008128:	06 96       	mov	r6,r3
8000812a:	02 92       	mov	r2,r1
8000812c:	40 93       	lddsp	r3,sp[0x24]
8000812e:	40 41       	lddsp	r1,sp[0x10]
80008130:	0e 99       	mov	r9,r7
80008132:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008136:	40 3c       	lddsp	r12,sp[0xc]
80008138:	58 0c       	cp.w	r12,0
8000813a:	c1 d0       	breq	80008174 <_vfprintf_r+0xf94>
8000813c:	10 36       	cp.w	r6,r8
8000813e:	c0 64       	brge	8000814a <_vfprintf_r+0xf6a>
80008140:	fa cb f9 44 	sub	r11,sp,-1724
80008144:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008148:	c1 d8       	rjmp	80008182 <_vfprintf_r+0xfa2>
8000814a:	fa c8 f9 50 	sub	r8,sp,-1712
8000814e:	1a d8       	st.w	--sp,r8
80008150:	fa c8 fa b8 	sub	r8,sp,-1352
80008154:	1a d8       	st.w	--sp,r8
80008156:	fa c8 fb b4 	sub	r8,sp,-1100
8000815a:	1a d8       	st.w	--sp,r8
8000815c:	fa c9 ff b4 	sub	r9,sp,-76
80008160:	fa c8 f9 40 	sub	r8,sp,-1728
80008164:	04 9a       	mov	r10,r2
80008166:	0c 9b       	mov	r11,r6
80008168:	08 9c       	mov	r12,r4
8000816a:	fe b0 f6 a3 	rcall	80006eb0 <get_arg>
8000816e:	2f dd       	sub	sp,-12
80008170:	78 09       	ld.w	r9,r12[0x0]
80008172:	c2 18       	rjmp	800081b4 <_vfprintf_r+0xfd4>
80008174:	2f f7       	sub	r7,-1
80008176:	10 39       	cp.w	r9,r8
80008178:	c0 84       	brge	80008188 <_vfprintf_r+0xfa8>
8000817a:	fa ca f9 44 	sub	r10,sp,-1724
8000817e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008182:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008186:	c1 78       	rjmp	800081b4 <_vfprintf_r+0xfd4>
80008188:	41 09       	lddsp	r9,sp[0x40]
8000818a:	59 f8       	cp.w	r8,31
8000818c:	e0 89 00 10 	brgt	800081ac <_vfprintf_r+0xfcc>
80008190:	f2 ca ff fc 	sub	r10,r9,-4
80008194:	51 0a       	stdsp	sp[0x40],r10
80008196:	fa c6 f9 44 	sub	r6,sp,-1724
8000819a:	72 09       	ld.w	r9,r9[0x0]
8000819c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800081a0:	f5 49 fd 88 	st.w	r10[-632],r9
800081a4:	2f f8       	sub	r8,-1
800081a6:	fb 48 06 b4 	st.w	sp[1716],r8
800081aa:	c0 58       	rjmp	800081b4 <_vfprintf_r+0xfd4>
800081ac:	f2 c8 ff fc 	sub	r8,r9,-4
800081b0:	51 08       	stdsp	sp[0x40],r8
800081b2:	72 09       	ld.w	r9,r9[0x0]
800081b4:	33 08       	mov	r8,48
800081b6:	fb 68 06 b8 	st.b	sp[1720],r8
800081ba:	37 88       	mov	r8,120
800081bc:	30 0e       	mov	lr,0
800081be:	fb 68 06 b9 	st.b	sp[1721],r8
800081c2:	fe cc b3 5e 	sub	r12,pc,-19618
800081c6:	50 19       	stdsp	sp[0x4],r9
800081c8:	a1 b5       	sbr	r5,0x1
800081ca:	50 0e       	stdsp	sp[0x0],lr
800081cc:	50 dc       	stdsp	sp[0x34],r12
800081ce:	30 28       	mov	r8,2
800081d0:	37 80       	mov	r0,120
800081d2:	e0 8f 02 a3 	bral	80008718 <_vfprintf_r+0x1538>
800081d6:	50 a7       	stdsp	sp[0x28],r7
800081d8:	50 80       	stdsp	sp[0x20],r0
800081da:	10 90       	mov	r0,r8
800081dc:	30 08       	mov	r8,0
800081de:	fb 68 06 bb 	st.b	sp[1723],r8
800081e2:	0c 97       	mov	r7,r6
800081e4:	04 94       	mov	r4,r2
800081e6:	06 96       	mov	r6,r3
800081e8:	02 92       	mov	r2,r1
800081ea:	40 93       	lddsp	r3,sp[0x24]
800081ec:	40 41       	lddsp	r1,sp[0x10]
800081ee:	0e 99       	mov	r9,r7
800081f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081f4:	40 3b       	lddsp	r11,sp[0xc]
800081f6:	58 0b       	cp.w	r11,0
800081f8:	c1 d0       	breq	80008232 <_vfprintf_r+0x1052>
800081fa:	10 36       	cp.w	r6,r8
800081fc:	c0 64       	brge	80008208 <_vfprintf_r+0x1028>
800081fe:	fa ca f9 44 	sub	r10,sp,-1724
80008202:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008206:	c1 d8       	rjmp	80008240 <_vfprintf_r+0x1060>
80008208:	fa c8 f9 50 	sub	r8,sp,-1712
8000820c:	1a d8       	st.w	--sp,r8
8000820e:	fa c8 fa b8 	sub	r8,sp,-1352
80008212:	1a d8       	st.w	--sp,r8
80008214:	fa c8 fb b4 	sub	r8,sp,-1100
80008218:	0c 9b       	mov	r11,r6
8000821a:	1a d8       	st.w	--sp,r8
8000821c:	04 9a       	mov	r10,r2
8000821e:	fa c8 f9 40 	sub	r8,sp,-1728
80008222:	fa c9 ff b4 	sub	r9,sp,-76
80008226:	08 9c       	mov	r12,r4
80008228:	fe b0 f6 44 	rcall	80006eb0 <get_arg>
8000822c:	2f dd       	sub	sp,-12
8000822e:	78 06       	ld.w	r6,r12[0x0]
80008230:	c2 08       	rjmp	80008270 <_vfprintf_r+0x1090>
80008232:	2f f7       	sub	r7,-1
80008234:	10 39       	cp.w	r9,r8
80008236:	c0 84       	brge	80008246 <_vfprintf_r+0x1066>
80008238:	fa c9 f9 44 	sub	r9,sp,-1724
8000823c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008240:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008244:	c1 68       	rjmp	80008270 <_vfprintf_r+0x1090>
80008246:	41 09       	lddsp	r9,sp[0x40]
80008248:	59 f8       	cp.w	r8,31
8000824a:	e0 89 00 10 	brgt	8000826a <_vfprintf_r+0x108a>
8000824e:	f2 ca ff fc 	sub	r10,r9,-4
80008252:	51 0a       	stdsp	sp[0x40],r10
80008254:	72 06       	ld.w	r6,r9[0x0]
80008256:	fa ce f9 44 	sub	lr,sp,-1724
8000825a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000825e:	f3 46 fd 88 	st.w	r9[-632],r6
80008262:	2f f8       	sub	r8,-1
80008264:	fb 48 06 b4 	st.w	sp[1716],r8
80008268:	c0 48       	rjmp	80008270 <_vfprintf_r+0x1090>
8000826a:	72 06       	ld.w	r6,r9[0x0]
8000826c:	2f c9       	sub	r9,-4
8000826e:	51 09       	stdsp	sp[0x40],r9
80008270:	40 2c       	lddsp	r12,sp[0x8]
80008272:	58 0c       	cp.w	r12,0
80008274:	c1 05       	brlt	80008294 <_vfprintf_r+0x10b4>
80008276:	18 9a       	mov	r10,r12
80008278:	30 0b       	mov	r11,0
8000827a:	0c 9c       	mov	r12,r6
8000827c:	e0 a0 12 38 	rcall	8000a6ec <memchr>
80008280:	e0 80 02 df 	breq	8000883e <_vfprintf_r+0x165e>
80008284:	f8 06 01 02 	sub	r2,r12,r6
80008288:	40 2b       	lddsp	r11,sp[0x8]
8000828a:	16 32       	cp.w	r2,r11
8000828c:	e0 89 02 d9 	brgt	8000883e <_vfprintf_r+0x165e>
80008290:	e0 8f 02 d4 	bral	80008838 <_vfprintf_r+0x1658>
80008294:	30 0a       	mov	r10,0
80008296:	0c 9c       	mov	r12,r6
80008298:	50 2a       	stdsp	sp[0x8],r10
8000829a:	fe b0 f5 85 	rcall	80006da4 <strlen>
8000829e:	18 92       	mov	r2,r12
800082a0:	e0 8f 02 d2 	bral	80008844 <_vfprintf_r+0x1664>
800082a4:	50 a7       	stdsp	sp[0x28],r7
800082a6:	50 80       	stdsp	sp[0x20],r0
800082a8:	0c 97       	mov	r7,r6
800082aa:	04 94       	mov	r4,r2
800082ac:	06 96       	mov	r6,r3
800082ae:	02 92       	mov	r2,r1
800082b0:	40 93       	lddsp	r3,sp[0x24]
800082b2:	10 90       	mov	r0,r8
800082b4:	40 41       	lddsp	r1,sp[0x10]
800082b6:	a5 a5       	sbr	r5,0x4
800082b8:	c0 a8       	rjmp	800082cc <_vfprintf_r+0x10ec>
800082ba:	50 a7       	stdsp	sp[0x28],r7
800082bc:	50 80       	stdsp	sp[0x20],r0
800082be:	0c 97       	mov	r7,r6
800082c0:	04 94       	mov	r4,r2
800082c2:	06 96       	mov	r6,r3
800082c4:	02 92       	mov	r2,r1
800082c6:	40 93       	lddsp	r3,sp[0x24]
800082c8:	10 90       	mov	r0,r8
800082ca:	40 41       	lddsp	r1,sp[0x10]
800082cc:	ed b5 00 05 	bld	r5,0x5
800082d0:	c5 61       	brne	8000837c <_vfprintf_r+0x119c>
800082d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082d6:	40 39       	lddsp	r9,sp[0xc]
800082d8:	58 09       	cp.w	r9,0
800082da:	c2 10       	breq	8000831c <_vfprintf_r+0x113c>
800082dc:	10 36       	cp.w	r6,r8
800082de:	c0 74       	brge	800082ec <_vfprintf_r+0x110c>
800082e0:	fa c8 f9 44 	sub	r8,sp,-1724
800082e4:	f0 06 00 36 	add	r6,r8,r6<<0x3
800082e8:	c2 38       	rjmp	8000832e <_vfprintf_r+0x114e>
800082ea:	d7 03       	nop
800082ec:	fa c8 f9 50 	sub	r8,sp,-1712
800082f0:	1a d8       	st.w	--sp,r8
800082f2:	fa c8 fa b8 	sub	r8,sp,-1352
800082f6:	1a d8       	st.w	--sp,r8
800082f8:	fa c8 fb b4 	sub	r8,sp,-1100
800082fc:	1a d8       	st.w	--sp,r8
800082fe:	fa c8 f9 40 	sub	r8,sp,-1728
80008302:	fa c9 ff b4 	sub	r9,sp,-76
80008306:	04 9a       	mov	r10,r2
80008308:	0c 9b       	mov	r11,r6
8000830a:	08 9c       	mov	r12,r4
8000830c:	fe b0 f5 d2 	rcall	80006eb0 <get_arg>
80008310:	2f dd       	sub	sp,-12
80008312:	f8 e8 00 00 	ld.d	r8,r12[0]
80008316:	fa e9 00 00 	st.d	sp[0],r8
8000831a:	c2 e8       	rjmp	80008376 <_vfprintf_r+0x1196>
8000831c:	ee ca ff ff 	sub	r10,r7,-1
80008320:	10 37       	cp.w	r7,r8
80008322:	c0 b4       	brge	80008338 <_vfprintf_r+0x1158>
80008324:	fa c8 f9 44 	sub	r8,sp,-1724
80008328:	14 97       	mov	r7,r10
8000832a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000832e:	ec ea fd 88 	ld.d	r10,r6[-632]
80008332:	fa eb 00 00 	st.d	sp[0],r10
80008336:	c2 08       	rjmp	80008376 <_vfprintf_r+0x1196>
80008338:	41 09       	lddsp	r9,sp[0x40]
8000833a:	59 f8       	cp.w	r8,31
8000833c:	e0 89 00 16 	brgt	80008368 <_vfprintf_r+0x1188>
80008340:	f2 e6 00 00 	ld.d	r6,r9[0]
80008344:	f2 cb ff f8 	sub	r11,r9,-8
80008348:	fa e7 00 00 	st.d	sp[0],r6
8000834c:	51 0b       	stdsp	sp[0x40],r11
8000834e:	fa c6 f9 44 	sub	r6,sp,-1724
80008352:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008356:	fa e6 00 00 	ld.d	r6,sp[0]
8000835a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000835e:	2f f8       	sub	r8,-1
80008360:	14 97       	mov	r7,r10
80008362:	fb 48 06 b4 	st.w	sp[1716],r8
80008366:	c0 88       	rjmp	80008376 <_vfprintf_r+0x1196>
80008368:	f2 e6 00 00 	ld.d	r6,r9[0]
8000836c:	2f 89       	sub	r9,-8
8000836e:	fa e7 00 00 	st.d	sp[0],r6
80008372:	51 09       	stdsp	sp[0x40],r9
80008374:	14 97       	mov	r7,r10
80008376:	30 18       	mov	r8,1
80008378:	e0 8f 01 d0 	bral	80008718 <_vfprintf_r+0x1538>
8000837c:	ed b5 00 04 	bld	r5,0x4
80008380:	c1 61       	brne	800083ac <_vfprintf_r+0x11cc>
80008382:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008386:	40 3e       	lddsp	lr,sp[0xc]
80008388:	58 0e       	cp.w	lr,0
8000838a:	c0 80       	breq	8000839a <_vfprintf_r+0x11ba>
8000838c:	10 36       	cp.w	r6,r8
8000838e:	c6 74       	brge	8000845c <_vfprintf_r+0x127c>
80008390:	fa cc f9 44 	sub	r12,sp,-1724
80008394:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008398:	c8 08       	rjmp	80008498 <_vfprintf_r+0x12b8>
8000839a:	ee ca ff ff 	sub	r10,r7,-1
8000839e:	10 37       	cp.w	r7,r8
800083a0:	c7 f4       	brge	8000849e <_vfprintf_r+0x12be>
800083a2:	fa cb f9 44 	sub	r11,sp,-1724
800083a6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083aa:	c7 68       	rjmp	80008496 <_vfprintf_r+0x12b6>
800083ac:	ed b5 00 06 	bld	r5,0x6
800083b0:	c4 a1       	brne	80008444 <_vfprintf_r+0x1264>
800083b2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083b6:	40 3c       	lddsp	r12,sp[0xc]
800083b8:	58 0c       	cp.w	r12,0
800083ba:	c1 d0       	breq	800083f4 <_vfprintf_r+0x1214>
800083bc:	10 36       	cp.w	r6,r8
800083be:	c0 64       	brge	800083ca <_vfprintf_r+0x11ea>
800083c0:	fa cb f9 44 	sub	r11,sp,-1724
800083c4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083c8:	c1 f8       	rjmp	80008406 <_vfprintf_r+0x1226>
800083ca:	fa c8 f9 50 	sub	r8,sp,-1712
800083ce:	1a d8       	st.w	--sp,r8
800083d0:	fa c8 fa b8 	sub	r8,sp,-1352
800083d4:	1a d8       	st.w	--sp,r8
800083d6:	fa c8 fb b4 	sub	r8,sp,-1100
800083da:	1a d8       	st.w	--sp,r8
800083dc:	fa c8 f9 40 	sub	r8,sp,-1728
800083e0:	fa c9 ff b4 	sub	r9,sp,-76
800083e4:	04 9a       	mov	r10,r2
800083e6:	0c 9b       	mov	r11,r6
800083e8:	08 9c       	mov	r12,r4
800083ea:	fe b0 f5 63 	rcall	80006eb0 <get_arg>
800083ee:	2f dd       	sub	sp,-12
800083f0:	98 18       	ld.sh	r8,r12[0x2]
800083f2:	c2 68       	rjmp	8000843e <_vfprintf_r+0x125e>
800083f4:	ee ca ff ff 	sub	r10,r7,-1
800083f8:	10 37       	cp.w	r7,r8
800083fa:	c0 94       	brge	8000840c <_vfprintf_r+0x122c>
800083fc:	fa c9 f9 44 	sub	r9,sp,-1724
80008400:	14 97       	mov	r7,r10
80008402:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008406:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000840a:	c1 a8       	rjmp	8000843e <_vfprintf_r+0x125e>
8000840c:	41 09       	lddsp	r9,sp[0x40]
8000840e:	59 f8       	cp.w	r8,31
80008410:	e0 89 00 13 	brgt	80008436 <_vfprintf_r+0x1256>
80008414:	f2 cb ff fc 	sub	r11,r9,-4
80008418:	51 0b       	stdsp	sp[0x40],r11
8000841a:	72 09       	ld.w	r9,r9[0x0]
8000841c:	fa c6 f9 44 	sub	r6,sp,-1724
80008420:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008424:	2f f8       	sub	r8,-1
80008426:	f7 49 fd 88 	st.w	r11[-632],r9
8000842a:	fb 48 06 b4 	st.w	sp[1716],r8
8000842e:	14 97       	mov	r7,r10
80008430:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008434:	c0 58       	rjmp	8000843e <_vfprintf_r+0x125e>
80008436:	92 18       	ld.sh	r8,r9[0x2]
80008438:	14 97       	mov	r7,r10
8000843a:	2f c9       	sub	r9,-4
8000843c:	51 09       	stdsp	sp[0x40],r9
8000843e:	5c 78       	castu.h	r8
80008440:	50 18       	stdsp	sp[0x4],r8
80008442:	c4 68       	rjmp	800084ce <_vfprintf_r+0x12ee>
80008444:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008448:	40 3c       	lddsp	r12,sp[0xc]
8000844a:	58 0c       	cp.w	r12,0
8000844c:	c1 d0       	breq	80008486 <_vfprintf_r+0x12a6>
8000844e:	10 36       	cp.w	r6,r8
80008450:	c0 64       	brge	8000845c <_vfprintf_r+0x127c>
80008452:	fa cb f9 44 	sub	r11,sp,-1724
80008456:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000845a:	c1 f8       	rjmp	80008498 <_vfprintf_r+0x12b8>
8000845c:	fa c8 f9 50 	sub	r8,sp,-1712
80008460:	1a d8       	st.w	--sp,r8
80008462:	fa c8 fa b8 	sub	r8,sp,-1352
80008466:	0c 9b       	mov	r11,r6
80008468:	1a d8       	st.w	--sp,r8
8000846a:	fa c8 fb b4 	sub	r8,sp,-1100
8000846e:	04 9a       	mov	r10,r2
80008470:	1a d8       	st.w	--sp,r8
80008472:	08 9c       	mov	r12,r4
80008474:	fa c8 f9 40 	sub	r8,sp,-1728
80008478:	fa c9 ff b4 	sub	r9,sp,-76
8000847c:	fe b0 f5 1a 	rcall	80006eb0 <get_arg>
80008480:	2f dd       	sub	sp,-12
80008482:	78 0b       	ld.w	r11,r12[0x0]
80008484:	c2 48       	rjmp	800084cc <_vfprintf_r+0x12ec>
80008486:	ee ca ff ff 	sub	r10,r7,-1
8000848a:	10 37       	cp.w	r7,r8
8000848c:	c0 94       	brge	8000849e <_vfprintf_r+0x12be>
8000848e:	fa c9 f9 44 	sub	r9,sp,-1724
80008492:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008496:	14 97       	mov	r7,r10
80008498:	ec fb fd 88 	ld.w	r11,r6[-632]
8000849c:	c1 88       	rjmp	800084cc <_vfprintf_r+0x12ec>
8000849e:	41 09       	lddsp	r9,sp[0x40]
800084a0:	59 f8       	cp.w	r8,31
800084a2:	e0 89 00 11 	brgt	800084c4 <_vfprintf_r+0x12e4>
800084a6:	f2 cb ff fc 	sub	r11,r9,-4
800084aa:	51 0b       	stdsp	sp[0x40],r11
800084ac:	fa c6 f9 44 	sub	r6,sp,-1724
800084b0:	72 0b       	ld.w	r11,r9[0x0]
800084b2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800084b6:	f3 4b fd 88 	st.w	r9[-632],r11
800084ba:	2f f8       	sub	r8,-1
800084bc:	14 97       	mov	r7,r10
800084be:	fb 48 06 b4 	st.w	sp[1716],r8
800084c2:	c0 58       	rjmp	800084cc <_vfprintf_r+0x12ec>
800084c4:	72 0b       	ld.w	r11,r9[0x0]
800084c6:	14 97       	mov	r7,r10
800084c8:	2f c9       	sub	r9,-4
800084ca:	51 09       	stdsp	sp[0x40],r9
800084cc:	50 1b       	stdsp	sp[0x4],r11
800084ce:	30 0e       	mov	lr,0
800084d0:	30 18       	mov	r8,1
800084d2:	50 0e       	stdsp	sp[0x0],lr
800084d4:	c2 29       	rjmp	80008718 <_vfprintf_r+0x1538>
800084d6:	50 a7       	stdsp	sp[0x28],r7
800084d8:	50 80       	stdsp	sp[0x20],r0
800084da:	0c 97       	mov	r7,r6
800084dc:	04 94       	mov	r4,r2
800084de:	06 96       	mov	r6,r3
800084e0:	02 92       	mov	r2,r1
800084e2:	fe cc b6 7e 	sub	r12,pc,-18818
800084e6:	40 93       	lddsp	r3,sp[0x24]
800084e8:	10 90       	mov	r0,r8
800084ea:	40 41       	lddsp	r1,sp[0x10]
800084ec:	50 dc       	stdsp	sp[0x34],r12
800084ee:	ed b5 00 05 	bld	r5,0x5
800084f2:	c5 51       	brne	8000859c <_vfprintf_r+0x13bc>
800084f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084f8:	40 3b       	lddsp	r11,sp[0xc]
800084fa:	58 0b       	cp.w	r11,0
800084fc:	c2 20       	breq	80008540 <_vfprintf_r+0x1360>
800084fe:	10 36       	cp.w	r6,r8
80008500:	c0 a4       	brge	80008514 <_vfprintf_r+0x1334>
80008502:	fa ca f9 44 	sub	r10,sp,-1724
80008506:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000850a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000850e:	fa e9 00 00 	st.d	sp[0],r8
80008512:	cf 28       	rjmp	800086f6 <_vfprintf_r+0x1516>
80008514:	fa c8 f9 50 	sub	r8,sp,-1712
80008518:	1a d8       	st.w	--sp,r8
8000851a:	fa c8 fa b8 	sub	r8,sp,-1352
8000851e:	04 9a       	mov	r10,r2
80008520:	1a d8       	st.w	--sp,r8
80008522:	0c 9b       	mov	r11,r6
80008524:	fa c8 fb b4 	sub	r8,sp,-1100
80008528:	08 9c       	mov	r12,r4
8000852a:	1a d8       	st.w	--sp,r8
8000852c:	fa c8 f9 40 	sub	r8,sp,-1728
80008530:	fa c9 ff b4 	sub	r9,sp,-76
80008534:	fe b0 f4 be 	rcall	80006eb0 <get_arg>
80008538:	2f dd       	sub	sp,-12
8000853a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000853e:	c0 c8       	rjmp	80008556 <_vfprintf_r+0x1376>
80008540:	ee ca ff ff 	sub	r10,r7,-1
80008544:	10 37       	cp.w	r7,r8
80008546:	c0 b4       	brge	8000855c <_vfprintf_r+0x137c>
80008548:	fa c9 f9 44 	sub	r9,sp,-1724
8000854c:	14 97       	mov	r7,r10
8000854e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008552:	ec ea fd 88 	ld.d	r10,r6[-632]
80008556:	fa eb 00 00 	st.d	sp[0],r10
8000855a:	cc e8       	rjmp	800086f6 <_vfprintf_r+0x1516>
8000855c:	41 09       	lddsp	r9,sp[0x40]
8000855e:	59 f8       	cp.w	r8,31
80008560:	e0 89 00 16 	brgt	8000858c <_vfprintf_r+0x13ac>
80008564:	f2 e6 00 00 	ld.d	r6,r9[0]
80008568:	f2 cb ff f8 	sub	r11,r9,-8
8000856c:	fa e7 00 00 	st.d	sp[0],r6
80008570:	51 0b       	stdsp	sp[0x40],r11
80008572:	fa c6 f9 44 	sub	r6,sp,-1724
80008576:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000857a:	fa e6 00 00 	ld.d	r6,sp[0]
8000857e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008582:	2f f8       	sub	r8,-1
80008584:	14 97       	mov	r7,r10
80008586:	fb 48 06 b4 	st.w	sp[1716],r8
8000858a:	cb 68       	rjmp	800086f6 <_vfprintf_r+0x1516>
8000858c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008590:	2f 89       	sub	r9,-8
80008592:	fa e7 00 00 	st.d	sp[0],r6
80008596:	51 09       	stdsp	sp[0x40],r9
80008598:	14 97       	mov	r7,r10
8000859a:	ca e8       	rjmp	800086f6 <_vfprintf_r+0x1516>
8000859c:	ed b5 00 04 	bld	r5,0x4
800085a0:	c1 71       	brne	800085ce <_vfprintf_r+0x13ee>
800085a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085a6:	40 3e       	lddsp	lr,sp[0xc]
800085a8:	58 0e       	cp.w	lr,0
800085aa:	c0 80       	breq	800085ba <_vfprintf_r+0x13da>
800085ac:	10 36       	cp.w	r6,r8
800085ae:	c6 94       	brge	80008680 <_vfprintf_r+0x14a0>
800085b0:	fa cc f9 44 	sub	r12,sp,-1724
800085b4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800085b8:	c8 28       	rjmp	800086bc <_vfprintf_r+0x14dc>
800085ba:	ee ca ff ff 	sub	r10,r7,-1
800085be:	10 37       	cp.w	r7,r8
800085c0:	e0 84 00 81 	brge	800086c2 <_vfprintf_r+0x14e2>
800085c4:	fa cb f9 44 	sub	r11,sp,-1724
800085c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085cc:	c7 78       	rjmp	800086ba <_vfprintf_r+0x14da>
800085ce:	ed b5 00 06 	bld	r5,0x6
800085d2:	c4 b1       	brne	80008668 <_vfprintf_r+0x1488>
800085d4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085d8:	40 3c       	lddsp	r12,sp[0xc]
800085da:	58 0c       	cp.w	r12,0
800085dc:	c1 d0       	breq	80008616 <_vfprintf_r+0x1436>
800085de:	10 36       	cp.w	r6,r8
800085e0:	c0 64       	brge	800085ec <_vfprintf_r+0x140c>
800085e2:	fa cb f9 44 	sub	r11,sp,-1724
800085e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085ea:	c1 f8       	rjmp	80008628 <_vfprintf_r+0x1448>
800085ec:	fa c8 f9 50 	sub	r8,sp,-1712
800085f0:	1a d8       	st.w	--sp,r8
800085f2:	fa c8 fa b8 	sub	r8,sp,-1352
800085f6:	1a d8       	st.w	--sp,r8
800085f8:	fa c8 fb b4 	sub	r8,sp,-1100
800085fc:	1a d8       	st.w	--sp,r8
800085fe:	fa c8 f9 40 	sub	r8,sp,-1728
80008602:	fa c9 ff b4 	sub	r9,sp,-76
80008606:	04 9a       	mov	r10,r2
80008608:	0c 9b       	mov	r11,r6
8000860a:	08 9c       	mov	r12,r4
8000860c:	fe b0 f4 52 	rcall	80006eb0 <get_arg>
80008610:	2f dd       	sub	sp,-12
80008612:	98 18       	ld.sh	r8,r12[0x2]
80008614:	c2 78       	rjmp	80008662 <_vfprintf_r+0x1482>
80008616:	ee ca ff ff 	sub	r10,r7,-1
8000861a:	10 37       	cp.w	r7,r8
8000861c:	c0 a4       	brge	80008630 <_vfprintf_r+0x1450>
8000861e:	fa c9 f9 44 	sub	r9,sp,-1724
80008622:	14 97       	mov	r7,r10
80008624:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008628:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000862c:	c1 b8       	rjmp	80008662 <_vfprintf_r+0x1482>
8000862e:	d7 03       	nop
80008630:	41 09       	lddsp	r9,sp[0x40]
80008632:	59 f8       	cp.w	r8,31
80008634:	e0 89 00 13 	brgt	8000865a <_vfprintf_r+0x147a>
80008638:	f2 cb ff fc 	sub	r11,r9,-4
8000863c:	51 0b       	stdsp	sp[0x40],r11
8000863e:	72 09       	ld.w	r9,r9[0x0]
80008640:	fa c6 f9 44 	sub	r6,sp,-1724
80008644:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008648:	2f f8       	sub	r8,-1
8000864a:	f7 49 fd 88 	st.w	r11[-632],r9
8000864e:	fb 48 06 b4 	st.w	sp[1716],r8
80008652:	14 97       	mov	r7,r10
80008654:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008658:	c0 58       	rjmp	80008662 <_vfprintf_r+0x1482>
8000865a:	92 18       	ld.sh	r8,r9[0x2]
8000865c:	14 97       	mov	r7,r10
8000865e:	2f c9       	sub	r9,-4
80008660:	51 09       	stdsp	sp[0x40],r9
80008662:	5c 78       	castu.h	r8
80008664:	50 18       	stdsp	sp[0x4],r8
80008666:	c4 68       	rjmp	800086f2 <_vfprintf_r+0x1512>
80008668:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000866c:	40 3c       	lddsp	r12,sp[0xc]
8000866e:	58 0c       	cp.w	r12,0
80008670:	c1 d0       	breq	800086aa <_vfprintf_r+0x14ca>
80008672:	10 36       	cp.w	r6,r8
80008674:	c0 64       	brge	80008680 <_vfprintf_r+0x14a0>
80008676:	fa cb f9 44 	sub	r11,sp,-1724
8000867a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000867e:	c1 f8       	rjmp	800086bc <_vfprintf_r+0x14dc>
80008680:	fa c8 f9 50 	sub	r8,sp,-1712
80008684:	1a d8       	st.w	--sp,r8
80008686:	fa c8 fa b8 	sub	r8,sp,-1352
8000868a:	0c 9b       	mov	r11,r6
8000868c:	1a d8       	st.w	--sp,r8
8000868e:	fa c8 fb b4 	sub	r8,sp,-1100
80008692:	04 9a       	mov	r10,r2
80008694:	1a d8       	st.w	--sp,r8
80008696:	08 9c       	mov	r12,r4
80008698:	fa c8 f9 40 	sub	r8,sp,-1728
8000869c:	fa c9 ff b4 	sub	r9,sp,-76
800086a0:	fe b0 f4 08 	rcall	80006eb0 <get_arg>
800086a4:	2f dd       	sub	sp,-12
800086a6:	78 0b       	ld.w	r11,r12[0x0]
800086a8:	c2 48       	rjmp	800086f0 <_vfprintf_r+0x1510>
800086aa:	ee ca ff ff 	sub	r10,r7,-1
800086ae:	10 37       	cp.w	r7,r8
800086b0:	c0 94       	brge	800086c2 <_vfprintf_r+0x14e2>
800086b2:	fa c9 f9 44 	sub	r9,sp,-1724
800086b6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086ba:	14 97       	mov	r7,r10
800086bc:	ec fb fd 88 	ld.w	r11,r6[-632]
800086c0:	c1 88       	rjmp	800086f0 <_vfprintf_r+0x1510>
800086c2:	41 09       	lddsp	r9,sp[0x40]
800086c4:	59 f8       	cp.w	r8,31
800086c6:	e0 89 00 11 	brgt	800086e8 <_vfprintf_r+0x1508>
800086ca:	f2 cb ff fc 	sub	r11,r9,-4
800086ce:	51 0b       	stdsp	sp[0x40],r11
800086d0:	fa c6 f9 44 	sub	r6,sp,-1724
800086d4:	72 0b       	ld.w	r11,r9[0x0]
800086d6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800086da:	f3 4b fd 88 	st.w	r9[-632],r11
800086de:	2f f8       	sub	r8,-1
800086e0:	14 97       	mov	r7,r10
800086e2:	fb 48 06 b4 	st.w	sp[1716],r8
800086e6:	c0 58       	rjmp	800086f0 <_vfprintf_r+0x1510>
800086e8:	72 0b       	ld.w	r11,r9[0x0]
800086ea:	14 97       	mov	r7,r10
800086ec:	2f c9       	sub	r9,-4
800086ee:	51 09       	stdsp	sp[0x40],r9
800086f0:	50 1b       	stdsp	sp[0x4],r11
800086f2:	30 0e       	mov	lr,0
800086f4:	50 0e       	stdsp	sp[0x0],lr
800086f6:	40 08       	lddsp	r8,sp[0x0]
800086f8:	40 1c       	lddsp	r12,sp[0x4]
800086fa:	18 48       	or	r8,r12
800086fc:	5f 19       	srne	r9
800086fe:	0a 98       	mov	r8,r5
80008700:	eb e9 00 09 	and	r9,r5,r9
80008704:	a1 b8       	sbr	r8,0x1
80008706:	58 09       	cp.w	r9,0
80008708:	c0 70       	breq	80008716 <_vfprintf_r+0x1536>
8000870a:	10 95       	mov	r5,r8
8000870c:	fb 60 06 b9 	st.b	sp[1721],r0
80008710:	33 08       	mov	r8,48
80008712:	fb 68 06 b8 	st.b	sp[1720],r8
80008716:	30 28       	mov	r8,2
80008718:	30 09       	mov	r9,0
8000871a:	fb 69 06 bb 	st.b	sp[1723],r9
8000871e:	0a 99       	mov	r9,r5
80008720:	a7 d9       	cbr	r9,0x7
80008722:	40 2b       	lddsp	r11,sp[0x8]
80008724:	40 16       	lddsp	r6,sp[0x4]
80008726:	58 0b       	cp.w	r11,0
80008728:	5f 1a       	srne	r10
8000872a:	f2 05 17 40 	movge	r5,r9
8000872e:	fa c2 f9 78 	sub	r2,sp,-1672
80008732:	40 09       	lddsp	r9,sp[0x0]
80008734:	0c 49       	or	r9,r6
80008736:	5f 19       	srne	r9
80008738:	f5 e9 10 09 	or	r9,r10,r9
8000873c:	c5 c0       	breq	800087f4 <_vfprintf_r+0x1614>
8000873e:	30 19       	mov	r9,1
80008740:	f2 08 18 00 	cp.b	r8,r9
80008744:	c0 60       	breq	80008750 <_vfprintf_r+0x1570>
80008746:	30 29       	mov	r9,2
80008748:	f2 08 18 00 	cp.b	r8,r9
8000874c:	c0 41       	brne	80008754 <_vfprintf_r+0x1574>
8000874e:	c3 c8       	rjmp	800087c6 <_vfprintf_r+0x15e6>
80008750:	04 96       	mov	r6,r2
80008752:	c3 08       	rjmp	800087b2 <_vfprintf_r+0x15d2>
80008754:	04 96       	mov	r6,r2
80008756:	fa e8 00 00 	ld.d	r8,sp[0]
8000875a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000875e:	2d 0a       	sub	r10,-48
80008760:	0c fa       	st.b	--r6,r10
80008762:	f0 0b 16 03 	lsr	r11,r8,0x3
80008766:	f2 0c 16 03 	lsr	r12,r9,0x3
8000876a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000876e:	18 99       	mov	r9,r12
80008770:	16 98       	mov	r8,r11
80008772:	58 08       	cp.w	r8,0
80008774:	5c 29       	cpc	r9
80008776:	cf 21       	brne	8000875a <_vfprintf_r+0x157a>
80008778:	fa e9 00 00 	st.d	sp[0],r8
8000877c:	ed b5 00 00 	bld	r5,0x0
80008780:	c4 51       	brne	8000880a <_vfprintf_r+0x162a>
80008782:	33 09       	mov	r9,48
80008784:	f2 0a 18 00 	cp.b	r10,r9
80008788:	c4 10       	breq	8000880a <_vfprintf_r+0x162a>
8000878a:	0c f9       	st.b	--r6,r9
8000878c:	c3 f8       	rjmp	8000880a <_vfprintf_r+0x162a>
8000878e:	fa ea 00 00 	ld.d	r10,sp[0]
80008792:	30 a8       	mov	r8,10
80008794:	30 09       	mov	r9,0
80008796:	e0 a0 1a 0d 	rcall	8000bbb0 <__avr32_umod64>
8000879a:	30 a8       	mov	r8,10
8000879c:	2d 0a       	sub	r10,-48
8000879e:	30 09       	mov	r9,0
800087a0:	ac 8a       	st.b	r6[0x0],r10
800087a2:	fa ea 00 00 	ld.d	r10,sp[0]
800087a6:	e0 a0 18 d3 	rcall	8000b94c <__avr32_udiv64>
800087aa:	16 99       	mov	r9,r11
800087ac:	14 98       	mov	r8,r10
800087ae:	fa e9 00 00 	st.d	sp[0],r8
800087b2:	20 16       	sub	r6,1
800087b4:	fa ea 00 00 	ld.d	r10,sp[0]
800087b8:	58 9a       	cp.w	r10,9
800087ba:	5c 2b       	cpc	r11
800087bc:	fe 9b ff e9 	brhi	8000878e <_vfprintf_r+0x15ae>
800087c0:	1b f8       	ld.ub	r8,sp[0x7]
800087c2:	2d 08       	sub	r8,-48
800087c4:	c2 08       	rjmp	80008804 <_vfprintf_r+0x1624>
800087c6:	04 96       	mov	r6,r2
800087c8:	fa e8 00 00 	ld.d	r8,sp[0]
800087cc:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800087d0:	40 de       	lddsp	lr,sp[0x34]
800087d2:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800087d6:	0c fa       	st.b	--r6,r10
800087d8:	f2 0b 16 04 	lsr	r11,r9,0x4
800087dc:	f0 0a 16 04 	lsr	r10,r8,0x4
800087e0:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800087e4:	16 99       	mov	r9,r11
800087e6:	14 98       	mov	r8,r10
800087e8:	58 08       	cp.w	r8,0
800087ea:	5c 29       	cpc	r9
800087ec:	cf 01       	brne	800087cc <_vfprintf_r+0x15ec>
800087ee:	fa e9 00 00 	st.d	sp[0],r8
800087f2:	c0 c8       	rjmp	8000880a <_vfprintf_r+0x162a>
800087f4:	58 08       	cp.w	r8,0
800087f6:	c0 91       	brne	80008808 <_vfprintf_r+0x1628>
800087f8:	ed b5 00 00 	bld	r5,0x0
800087fc:	c0 61       	brne	80008808 <_vfprintf_r+0x1628>
800087fe:	fa c6 f9 79 	sub	r6,sp,-1671
80008802:	33 08       	mov	r8,48
80008804:	ac 88       	st.b	r6[0x0],r8
80008806:	c0 28       	rjmp	8000880a <_vfprintf_r+0x162a>
80008808:	04 96       	mov	r6,r2
8000880a:	0c 12       	sub	r2,r6
8000880c:	c1 c8       	rjmp	80008844 <_vfprintf_r+0x1664>
8000880e:	50 a7       	stdsp	sp[0x28],r7
80008810:	50 80       	stdsp	sp[0x20],r0
80008812:	40 93       	lddsp	r3,sp[0x24]
80008814:	0c 97       	mov	r7,r6
80008816:	10 90       	mov	r0,r8
80008818:	04 94       	mov	r4,r2
8000881a:	40 41       	lddsp	r1,sp[0x10]
8000881c:	58 08       	cp.w	r8,0
8000881e:	e0 80 04 4f 	breq	800090bc <_vfprintf_r+0x1edc>
80008822:	fb 68 06 60 	st.b	sp[1632],r8
80008826:	30 0c       	mov	r12,0
80008828:	30 08       	mov	r8,0
8000882a:	30 12       	mov	r2,1
8000882c:	fb 68 06 bb 	st.b	sp[1723],r8
80008830:	50 2c       	stdsp	sp[0x8],r12
80008832:	fa c6 f9 a0 	sub	r6,sp,-1632
80008836:	c0 78       	rjmp	80008844 <_vfprintf_r+0x1664>
80008838:	30 0b       	mov	r11,0
8000883a:	50 2b       	stdsp	sp[0x8],r11
8000883c:	c0 48       	rjmp	80008844 <_vfprintf_r+0x1664>
8000883e:	40 22       	lddsp	r2,sp[0x8]
80008840:	30 0a       	mov	r10,0
80008842:	50 2a       	stdsp	sp[0x8],r10
80008844:	40 29       	lddsp	r9,sp[0x8]
80008846:	e4 09 0c 49 	max	r9,r2,r9
8000884a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000884e:	50 39       	stdsp	sp[0xc],r9
80008850:	0a 9e       	mov	lr,r5
80008852:	30 09       	mov	r9,0
80008854:	e2 1e 00 02 	andl	lr,0x2,COH
80008858:	f2 08 18 00 	cp.b	r8,r9
8000885c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008860:	f7 b8 01 ff 	subne	r8,-1
80008864:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008868:	0a 9b       	mov	r11,r5
8000886a:	58 0e       	cp.w	lr,0
8000886c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008870:	f7 bc 01 fe 	subne	r12,-2
80008874:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008878:	e2 1b 00 84 	andl	r11,0x84,COH
8000887c:	50 fe       	stdsp	sp[0x3c],lr
8000887e:	50 9b       	stdsp	sp[0x24],r11
80008880:	c4 71       	brne	8000890e <_vfprintf_r+0x172e>
80008882:	40 8a       	lddsp	r10,sp[0x20]
80008884:	40 39       	lddsp	r9,sp[0xc]
80008886:	12 1a       	sub	r10,r9
80008888:	50 4a       	stdsp	sp[0x10],r10
8000888a:	58 0a       	cp.w	r10,0
8000888c:	e0 89 00 20 	brgt	800088cc <_vfprintf_r+0x16ec>
80008890:	c3 f8       	rjmp	8000890e <_vfprintf_r+0x172e>
80008892:	2f 09       	sub	r9,-16
80008894:	2f f8       	sub	r8,-1
80008896:	fe ce ba 1a 	sub	lr,pc,-17894
8000889a:	31 0c       	mov	r12,16
8000889c:	fb 49 06 90 	st.w	sp[1680],r9
800088a0:	87 0e       	st.w	r3[0x0],lr
800088a2:	87 1c       	st.w	r3[0x4],r12
800088a4:	fb 48 06 8c 	st.w	sp[1676],r8
800088a8:	58 78       	cp.w	r8,7
800088aa:	e0 89 00 04 	brgt	800088b2 <_vfprintf_r+0x16d2>
800088ae:	2f 83       	sub	r3,-8
800088b0:	c0 b8       	rjmp	800088c6 <_vfprintf_r+0x16e6>
800088b2:	fa ca f9 78 	sub	r10,sp,-1672
800088b6:	02 9b       	mov	r11,r1
800088b8:	08 9c       	mov	r12,r4
800088ba:	fe b0 f4 85 	rcall	800071c4 <__sprint_r>
800088be:	e0 81 04 10 	brne	800090de <_vfprintf_r+0x1efe>
800088c2:	fa c3 f9 e0 	sub	r3,sp,-1568
800088c6:	40 4b       	lddsp	r11,sp[0x10]
800088c8:	21 0b       	sub	r11,16
800088ca:	50 4b       	stdsp	sp[0x10],r11
800088cc:	fa f9 06 90 	ld.w	r9,sp[1680]
800088d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088d4:	fe ca ba 58 	sub	r10,pc,-17832
800088d8:	40 4e       	lddsp	lr,sp[0x10]
800088da:	59 0e       	cp.w	lr,16
800088dc:	fe 99 ff db 	brgt	80008892 <_vfprintf_r+0x16b2>
800088e0:	1c 09       	add	r9,lr
800088e2:	2f f8       	sub	r8,-1
800088e4:	87 0a       	st.w	r3[0x0],r10
800088e6:	fb 49 06 90 	st.w	sp[1680],r9
800088ea:	87 1e       	st.w	r3[0x4],lr
800088ec:	fb 48 06 8c 	st.w	sp[1676],r8
800088f0:	58 78       	cp.w	r8,7
800088f2:	e0 89 00 04 	brgt	800088fa <_vfprintf_r+0x171a>
800088f6:	2f 83       	sub	r3,-8
800088f8:	c0 b8       	rjmp	8000890e <_vfprintf_r+0x172e>
800088fa:	fa ca f9 78 	sub	r10,sp,-1672
800088fe:	02 9b       	mov	r11,r1
80008900:	08 9c       	mov	r12,r4
80008902:	fe b0 f4 61 	rcall	800071c4 <__sprint_r>
80008906:	e0 81 03 ec 	brne	800090de <_vfprintf_r+0x1efe>
8000890a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000890e:	30 09       	mov	r9,0
80008910:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008914:	f2 08 18 00 	cp.b	r8,r9
80008918:	c1 f0       	breq	80008956 <_vfprintf_r+0x1776>
8000891a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000891e:	fa c9 f9 45 	sub	r9,sp,-1723
80008922:	2f f8       	sub	r8,-1
80008924:	87 09       	st.w	r3[0x0],r9
80008926:	fb 48 06 90 	st.w	sp[1680],r8
8000892a:	30 19       	mov	r9,1
8000892c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008930:	87 19       	st.w	r3[0x4],r9
80008932:	2f f8       	sub	r8,-1
80008934:	fb 48 06 8c 	st.w	sp[1676],r8
80008938:	58 78       	cp.w	r8,7
8000893a:	e0 89 00 04 	brgt	80008942 <_vfprintf_r+0x1762>
8000893e:	2f 83       	sub	r3,-8
80008940:	c0 b8       	rjmp	80008956 <_vfprintf_r+0x1776>
80008942:	fa ca f9 78 	sub	r10,sp,-1672
80008946:	02 9b       	mov	r11,r1
80008948:	08 9c       	mov	r12,r4
8000894a:	fe b0 f4 3d 	rcall	800071c4 <__sprint_r>
8000894e:	e0 81 03 c8 	brne	800090de <_vfprintf_r+0x1efe>
80008952:	fa c3 f9 e0 	sub	r3,sp,-1568
80008956:	40 fc       	lddsp	r12,sp[0x3c]
80008958:	58 0c       	cp.w	r12,0
8000895a:	c1 f0       	breq	80008998 <_vfprintf_r+0x17b8>
8000895c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008960:	fa c9 f9 48 	sub	r9,sp,-1720
80008964:	2f e8       	sub	r8,-2
80008966:	87 09       	st.w	r3[0x0],r9
80008968:	fb 48 06 90 	st.w	sp[1680],r8
8000896c:	30 29       	mov	r9,2
8000896e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008972:	87 19       	st.w	r3[0x4],r9
80008974:	2f f8       	sub	r8,-1
80008976:	fb 48 06 8c 	st.w	sp[1676],r8
8000897a:	58 78       	cp.w	r8,7
8000897c:	e0 89 00 04 	brgt	80008984 <_vfprintf_r+0x17a4>
80008980:	2f 83       	sub	r3,-8
80008982:	c0 b8       	rjmp	80008998 <_vfprintf_r+0x17b8>
80008984:	fa ca f9 78 	sub	r10,sp,-1672
80008988:	02 9b       	mov	r11,r1
8000898a:	08 9c       	mov	r12,r4
8000898c:	fe b0 f4 1c 	rcall	800071c4 <__sprint_r>
80008990:	e0 81 03 a7 	brne	800090de <_vfprintf_r+0x1efe>
80008994:	fa c3 f9 e0 	sub	r3,sp,-1568
80008998:	40 9b       	lddsp	r11,sp[0x24]
8000899a:	e0 4b 00 80 	cp.w	r11,128
8000899e:	c4 71       	brne	80008a2c <_vfprintf_r+0x184c>
800089a0:	40 8a       	lddsp	r10,sp[0x20]
800089a2:	40 39       	lddsp	r9,sp[0xc]
800089a4:	12 1a       	sub	r10,r9
800089a6:	50 4a       	stdsp	sp[0x10],r10
800089a8:	58 0a       	cp.w	r10,0
800089aa:	e0 89 00 20 	brgt	800089ea <_vfprintf_r+0x180a>
800089ae:	c3 f8       	rjmp	80008a2c <_vfprintf_r+0x184c>
800089b0:	2f 09       	sub	r9,-16
800089b2:	2f f8       	sub	r8,-1
800089b4:	fe ce bb 28 	sub	lr,pc,-17624
800089b8:	31 0c       	mov	r12,16
800089ba:	fb 49 06 90 	st.w	sp[1680],r9
800089be:	87 0e       	st.w	r3[0x0],lr
800089c0:	87 1c       	st.w	r3[0x4],r12
800089c2:	fb 48 06 8c 	st.w	sp[1676],r8
800089c6:	58 78       	cp.w	r8,7
800089c8:	e0 89 00 04 	brgt	800089d0 <_vfprintf_r+0x17f0>
800089cc:	2f 83       	sub	r3,-8
800089ce:	c0 b8       	rjmp	800089e4 <_vfprintf_r+0x1804>
800089d0:	fa ca f9 78 	sub	r10,sp,-1672
800089d4:	02 9b       	mov	r11,r1
800089d6:	08 9c       	mov	r12,r4
800089d8:	fe b0 f3 f6 	rcall	800071c4 <__sprint_r>
800089dc:	e0 81 03 81 	brne	800090de <_vfprintf_r+0x1efe>
800089e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800089e4:	40 4b       	lddsp	r11,sp[0x10]
800089e6:	21 0b       	sub	r11,16
800089e8:	50 4b       	stdsp	sp[0x10],r11
800089ea:	fa f9 06 90 	ld.w	r9,sp[1680]
800089ee:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089f2:	fe ca bb 66 	sub	r10,pc,-17562
800089f6:	40 4e       	lddsp	lr,sp[0x10]
800089f8:	59 0e       	cp.w	lr,16
800089fa:	fe 99 ff db 	brgt	800089b0 <_vfprintf_r+0x17d0>
800089fe:	1c 09       	add	r9,lr
80008a00:	2f f8       	sub	r8,-1
80008a02:	87 0a       	st.w	r3[0x0],r10
80008a04:	fb 49 06 90 	st.w	sp[1680],r9
80008a08:	87 1e       	st.w	r3[0x4],lr
80008a0a:	fb 48 06 8c 	st.w	sp[1676],r8
80008a0e:	58 78       	cp.w	r8,7
80008a10:	e0 89 00 04 	brgt	80008a18 <_vfprintf_r+0x1838>
80008a14:	2f 83       	sub	r3,-8
80008a16:	c0 b8       	rjmp	80008a2c <_vfprintf_r+0x184c>
80008a18:	fa ca f9 78 	sub	r10,sp,-1672
80008a1c:	02 9b       	mov	r11,r1
80008a1e:	08 9c       	mov	r12,r4
80008a20:	fe b0 f3 d2 	rcall	800071c4 <__sprint_r>
80008a24:	e0 81 03 5d 	brne	800090de <_vfprintf_r+0x1efe>
80008a28:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a2c:	40 2c       	lddsp	r12,sp[0x8]
80008a2e:	04 1c       	sub	r12,r2
80008a30:	50 2c       	stdsp	sp[0x8],r12
80008a32:	58 0c       	cp.w	r12,0
80008a34:	e0 89 00 20 	brgt	80008a74 <_vfprintf_r+0x1894>
80008a38:	c3 f8       	rjmp	80008ab6 <_vfprintf_r+0x18d6>
80008a3a:	2f 09       	sub	r9,-16
80008a3c:	2f f8       	sub	r8,-1
80008a3e:	fe cb bb b2 	sub	r11,pc,-17486
80008a42:	31 0a       	mov	r10,16
80008a44:	fb 49 06 90 	st.w	sp[1680],r9
80008a48:	87 0b       	st.w	r3[0x0],r11
80008a4a:	87 1a       	st.w	r3[0x4],r10
80008a4c:	fb 48 06 8c 	st.w	sp[1676],r8
80008a50:	58 78       	cp.w	r8,7
80008a52:	e0 89 00 04 	brgt	80008a5a <_vfprintf_r+0x187a>
80008a56:	2f 83       	sub	r3,-8
80008a58:	c0 b8       	rjmp	80008a6e <_vfprintf_r+0x188e>
80008a5a:	fa ca f9 78 	sub	r10,sp,-1672
80008a5e:	02 9b       	mov	r11,r1
80008a60:	08 9c       	mov	r12,r4
80008a62:	fe b0 f3 b1 	rcall	800071c4 <__sprint_r>
80008a66:	e0 81 03 3c 	brne	800090de <_vfprintf_r+0x1efe>
80008a6a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a6e:	40 29       	lddsp	r9,sp[0x8]
80008a70:	21 09       	sub	r9,16
80008a72:	50 29       	stdsp	sp[0x8],r9
80008a74:	fa f9 06 90 	ld.w	r9,sp[1680]
80008a78:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a7c:	fe ca bb f0 	sub	r10,pc,-17424
80008a80:	40 2e       	lddsp	lr,sp[0x8]
80008a82:	59 0e       	cp.w	lr,16
80008a84:	fe 99 ff db 	brgt	80008a3a <_vfprintf_r+0x185a>
80008a88:	1c 09       	add	r9,lr
80008a8a:	2f f8       	sub	r8,-1
80008a8c:	87 0a       	st.w	r3[0x0],r10
80008a8e:	fb 49 06 90 	st.w	sp[1680],r9
80008a92:	87 1e       	st.w	r3[0x4],lr
80008a94:	fb 48 06 8c 	st.w	sp[1676],r8
80008a98:	58 78       	cp.w	r8,7
80008a9a:	e0 89 00 04 	brgt	80008aa2 <_vfprintf_r+0x18c2>
80008a9e:	2f 83       	sub	r3,-8
80008aa0:	c0 b8       	rjmp	80008ab6 <_vfprintf_r+0x18d6>
80008aa2:	fa ca f9 78 	sub	r10,sp,-1672
80008aa6:	02 9b       	mov	r11,r1
80008aa8:	08 9c       	mov	r12,r4
80008aaa:	fe b0 f3 8d 	rcall	800071c4 <__sprint_r>
80008aae:	e0 81 03 18 	brne	800090de <_vfprintf_r+0x1efe>
80008ab2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ab6:	ed b5 00 08 	bld	r5,0x8
80008aba:	c0 b0       	breq	80008ad0 <_vfprintf_r+0x18f0>
80008abc:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ac0:	87 12       	st.w	r3[0x4],r2
80008ac2:	87 06       	st.w	r3[0x0],r6
80008ac4:	f0 02 00 02 	add	r2,r8,r2
80008ac8:	fb 42 06 90 	st.w	sp[1680],r2
80008acc:	e0 8f 01 d4 	bral	80008e74 <_vfprintf_r+0x1c94>
80008ad0:	e0 40 00 65 	cp.w	r0,101
80008ad4:	e0 8a 01 d6 	brle	80008e80 <_vfprintf_r+0x1ca0>
80008ad8:	30 08       	mov	r8,0
80008ada:	30 09       	mov	r9,0
80008adc:	40 5b       	lddsp	r11,sp[0x14]
80008ade:	40 7a       	lddsp	r10,sp[0x1c]
80008ae0:	e0 a0 15 2f 	rcall	8000b53e <__avr32_f64_cmp_eq>
80008ae4:	c7 90       	breq	80008bd6 <_vfprintf_r+0x19f6>
80008ae6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008aea:	fe c9 bc 72 	sub	r9,pc,-17294
80008aee:	2f f8       	sub	r8,-1
80008af0:	87 09       	st.w	r3[0x0],r9
80008af2:	fb 48 06 90 	st.w	sp[1680],r8
80008af6:	30 19       	mov	r9,1
80008af8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008afc:	87 19       	st.w	r3[0x4],r9
80008afe:	2f f8       	sub	r8,-1
80008b00:	fb 48 06 8c 	st.w	sp[1676],r8
80008b04:	58 78       	cp.w	r8,7
80008b06:	e0 89 00 05 	brgt	80008b10 <_vfprintf_r+0x1930>
80008b0a:	2f 83       	sub	r3,-8
80008b0c:	c0 c8       	rjmp	80008b24 <_vfprintf_r+0x1944>
80008b0e:	d7 03       	nop
80008b10:	fa ca f9 78 	sub	r10,sp,-1672
80008b14:	02 9b       	mov	r11,r1
80008b16:	08 9c       	mov	r12,r4
80008b18:	fe b0 f3 56 	rcall	800071c4 <__sprint_r>
80008b1c:	e0 81 02 e1 	brne	800090de <_vfprintf_r+0x1efe>
80008b20:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b24:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008b28:	40 6c       	lddsp	r12,sp[0x18]
80008b2a:	18 38       	cp.w	r8,r12
80008b2c:	c0 55       	brlt	80008b36 <_vfprintf_r+0x1956>
80008b2e:	ed b5 00 00 	bld	r5,0x0
80008b32:	e0 81 02 6b 	brne	80009008 <_vfprintf_r+0x1e28>
80008b36:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b3a:	2f f8       	sub	r8,-1
80008b3c:	40 cb       	lddsp	r11,sp[0x30]
80008b3e:	fb 48 06 90 	st.w	sp[1680],r8
80008b42:	30 19       	mov	r9,1
80008b44:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b48:	87 0b       	st.w	r3[0x0],r11
80008b4a:	2f f8       	sub	r8,-1
80008b4c:	87 19       	st.w	r3[0x4],r9
80008b4e:	fb 48 06 8c 	st.w	sp[1676],r8
80008b52:	58 78       	cp.w	r8,7
80008b54:	e0 89 00 04 	brgt	80008b5c <_vfprintf_r+0x197c>
80008b58:	2f 83       	sub	r3,-8
80008b5a:	c0 b8       	rjmp	80008b70 <_vfprintf_r+0x1990>
80008b5c:	fa ca f9 78 	sub	r10,sp,-1672
80008b60:	02 9b       	mov	r11,r1
80008b62:	08 9c       	mov	r12,r4
80008b64:	fe b0 f3 30 	rcall	800071c4 <__sprint_r>
80008b68:	e0 81 02 bb 	brne	800090de <_vfprintf_r+0x1efe>
80008b6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b70:	40 66       	lddsp	r6,sp[0x18]
80008b72:	20 16       	sub	r6,1
80008b74:	58 06       	cp.w	r6,0
80008b76:	e0 89 00 1d 	brgt	80008bb0 <_vfprintf_r+0x19d0>
80008b7a:	e0 8f 02 47 	bral	80009008 <_vfprintf_r+0x1e28>
80008b7e:	2f 09       	sub	r9,-16
80008b80:	2f f8       	sub	r8,-1
80008b82:	fb 49 06 90 	st.w	sp[1680],r9
80008b86:	87 02       	st.w	r3[0x0],r2
80008b88:	87 10       	st.w	r3[0x4],r0
80008b8a:	fb 48 06 8c 	st.w	sp[1676],r8
80008b8e:	58 78       	cp.w	r8,7
80008b90:	e0 89 00 04 	brgt	80008b98 <_vfprintf_r+0x19b8>
80008b94:	2f 83       	sub	r3,-8
80008b96:	c0 b8       	rjmp	80008bac <_vfprintf_r+0x19cc>
80008b98:	fa ca f9 78 	sub	r10,sp,-1672
80008b9c:	02 9b       	mov	r11,r1
80008b9e:	08 9c       	mov	r12,r4
80008ba0:	fe b0 f3 12 	rcall	800071c4 <__sprint_r>
80008ba4:	e0 81 02 9d 	brne	800090de <_vfprintf_r+0x1efe>
80008ba8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bac:	21 06       	sub	r6,16
80008bae:	c0 48       	rjmp	80008bb6 <_vfprintf_r+0x19d6>
80008bb0:	fe c2 bd 24 	sub	r2,pc,-17116
80008bb4:	31 00       	mov	r0,16
80008bb6:	fa f9 06 90 	ld.w	r9,sp[1680]
80008bba:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bbe:	fe ca bd 32 	sub	r10,pc,-17102
80008bc2:	59 06       	cp.w	r6,16
80008bc4:	fe 99 ff dd 	brgt	80008b7e <_vfprintf_r+0x199e>
80008bc8:	0c 09       	add	r9,r6
80008bca:	87 0a       	st.w	r3[0x0],r10
80008bcc:	fb 49 06 90 	st.w	sp[1680],r9
80008bd0:	2f f8       	sub	r8,-1
80008bd2:	87 16       	st.w	r3[0x4],r6
80008bd4:	c5 39       	rjmp	80008e7a <_vfprintf_r+0x1c9a>
80008bd6:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008bda:	58 0a       	cp.w	r10,0
80008bdc:	e0 89 00 92 	brgt	80008d00 <_vfprintf_r+0x1b20>
80008be0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008be4:	fe c9 bd 6c 	sub	r9,pc,-17044
80008be8:	2f f8       	sub	r8,-1
80008bea:	87 09       	st.w	r3[0x0],r9
80008bec:	fb 48 06 90 	st.w	sp[1680],r8
80008bf0:	30 19       	mov	r9,1
80008bf2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bf6:	87 19       	st.w	r3[0x4],r9
80008bf8:	2f f8       	sub	r8,-1
80008bfa:	fb 48 06 8c 	st.w	sp[1676],r8
80008bfe:	58 78       	cp.w	r8,7
80008c00:	e0 89 00 04 	brgt	80008c08 <_vfprintf_r+0x1a28>
80008c04:	2f 83       	sub	r3,-8
80008c06:	c0 b8       	rjmp	80008c1c <_vfprintf_r+0x1a3c>
80008c08:	fa ca f9 78 	sub	r10,sp,-1672
80008c0c:	02 9b       	mov	r11,r1
80008c0e:	08 9c       	mov	r12,r4
80008c10:	fe b0 f2 da 	rcall	800071c4 <__sprint_r>
80008c14:	e0 81 02 65 	brne	800090de <_vfprintf_r+0x1efe>
80008c18:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c1c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008c20:	58 08       	cp.w	r8,0
80008c22:	c0 81       	brne	80008c32 <_vfprintf_r+0x1a52>
80008c24:	40 6a       	lddsp	r10,sp[0x18]
80008c26:	58 0a       	cp.w	r10,0
80008c28:	c0 51       	brne	80008c32 <_vfprintf_r+0x1a52>
80008c2a:	ed b5 00 00 	bld	r5,0x0
80008c2e:	e0 81 01 ed 	brne	80009008 <_vfprintf_r+0x1e28>
80008c32:	40 c9       	lddsp	r9,sp[0x30]
80008c34:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c38:	2f f8       	sub	r8,-1
80008c3a:	87 09       	st.w	r3[0x0],r9
80008c3c:	fb 48 06 90 	st.w	sp[1680],r8
80008c40:	30 19       	mov	r9,1
80008c42:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c46:	87 19       	st.w	r3[0x4],r9
80008c48:	2f f8       	sub	r8,-1
80008c4a:	fb 48 06 8c 	st.w	sp[1676],r8
80008c4e:	58 78       	cp.w	r8,7
80008c50:	e0 89 00 04 	brgt	80008c58 <_vfprintf_r+0x1a78>
80008c54:	2f 83       	sub	r3,-8
80008c56:	c0 b8       	rjmp	80008c6c <_vfprintf_r+0x1a8c>
80008c58:	fa ca f9 78 	sub	r10,sp,-1672
80008c5c:	02 9b       	mov	r11,r1
80008c5e:	08 9c       	mov	r12,r4
80008c60:	fe b0 f2 b2 	rcall	800071c4 <__sprint_r>
80008c64:	e0 81 02 3d 	brne	800090de <_vfprintf_r+0x1efe>
80008c68:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c6c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008c70:	5c 32       	neg	r2
80008c72:	58 02       	cp.w	r2,0
80008c74:	e0 89 00 1d 	brgt	80008cae <_vfprintf_r+0x1ace>
80008c78:	c3 d8       	rjmp	80008cf2 <_vfprintf_r+0x1b12>
80008c7a:	2f 09       	sub	r9,-16
80008c7c:	2f f8       	sub	r8,-1
80008c7e:	31 0e       	mov	lr,16
80008c80:	fb 49 06 90 	st.w	sp[1680],r9
80008c84:	87 00       	st.w	r3[0x0],r0
80008c86:	87 1e       	st.w	r3[0x4],lr
80008c88:	fb 48 06 8c 	st.w	sp[1676],r8
80008c8c:	58 78       	cp.w	r8,7
80008c8e:	e0 89 00 04 	brgt	80008c96 <_vfprintf_r+0x1ab6>
80008c92:	2f 83       	sub	r3,-8
80008c94:	c0 b8       	rjmp	80008caa <_vfprintf_r+0x1aca>
80008c96:	fa ca f9 78 	sub	r10,sp,-1672
80008c9a:	02 9b       	mov	r11,r1
80008c9c:	08 9c       	mov	r12,r4
80008c9e:	fe b0 f2 93 	rcall	800071c4 <__sprint_r>
80008ca2:	e0 81 02 1e 	brne	800090de <_vfprintf_r+0x1efe>
80008ca6:	fa c3 f9 e0 	sub	r3,sp,-1568
80008caa:	21 02       	sub	r2,16
80008cac:	c0 38       	rjmp	80008cb2 <_vfprintf_r+0x1ad2>
80008cae:	fe c0 be 22 	sub	r0,pc,-16862
80008cb2:	fa f9 06 90 	ld.w	r9,sp[1680]
80008cb6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008cba:	fe ca be 2e 	sub	r10,pc,-16850
80008cbe:	59 02       	cp.w	r2,16
80008cc0:	fe 99 ff dd 	brgt	80008c7a <_vfprintf_r+0x1a9a>
80008cc4:	04 09       	add	r9,r2
80008cc6:	2f f8       	sub	r8,-1
80008cc8:	87 0a       	st.w	r3[0x0],r10
80008cca:	fb 49 06 90 	st.w	sp[1680],r9
80008cce:	87 12       	st.w	r3[0x4],r2
80008cd0:	fb 48 06 8c 	st.w	sp[1676],r8
80008cd4:	58 78       	cp.w	r8,7
80008cd6:	e0 89 00 04 	brgt	80008cde <_vfprintf_r+0x1afe>
80008cda:	2f 83       	sub	r3,-8
80008cdc:	c0 b8       	rjmp	80008cf2 <_vfprintf_r+0x1b12>
80008cde:	fa ca f9 78 	sub	r10,sp,-1672
80008ce2:	02 9b       	mov	r11,r1
80008ce4:	08 9c       	mov	r12,r4
80008ce6:	fe b0 f2 6f 	rcall	800071c4 <__sprint_r>
80008cea:	e0 81 01 fa 	brne	800090de <_vfprintf_r+0x1efe>
80008cee:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cf2:	40 6c       	lddsp	r12,sp[0x18]
80008cf4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008cf8:	87 06       	st.w	r3[0x0],r6
80008cfa:	87 1c       	st.w	r3[0x4],r12
80008cfc:	18 08       	add	r8,r12
80008cfe:	cb 98       	rjmp	80008e70 <_vfprintf_r+0x1c90>
80008d00:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d08:	40 6b       	lddsp	r11,sp[0x18]
80008d0a:	16 3a       	cp.w	r10,r11
80008d0c:	c6 f5       	brlt	80008dea <_vfprintf_r+0x1c0a>
80008d0e:	16 09       	add	r9,r11
80008d10:	2f f8       	sub	r8,-1
80008d12:	87 06       	st.w	r3[0x0],r6
80008d14:	fb 49 06 90 	st.w	sp[1680],r9
80008d18:	87 1b       	st.w	r3[0x4],r11
80008d1a:	fb 48 06 8c 	st.w	sp[1676],r8
80008d1e:	58 78       	cp.w	r8,7
80008d20:	e0 89 00 04 	brgt	80008d28 <_vfprintf_r+0x1b48>
80008d24:	2f 83       	sub	r3,-8
80008d26:	c0 b8       	rjmp	80008d3c <_vfprintf_r+0x1b5c>
80008d28:	fa ca f9 78 	sub	r10,sp,-1672
80008d2c:	02 9b       	mov	r11,r1
80008d2e:	08 9c       	mov	r12,r4
80008d30:	fe b0 f2 4a 	rcall	800071c4 <__sprint_r>
80008d34:	e0 81 01 d5 	brne	800090de <_vfprintf_r+0x1efe>
80008d38:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d3c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008d40:	40 6a       	lddsp	r10,sp[0x18]
80008d42:	14 16       	sub	r6,r10
80008d44:	58 06       	cp.w	r6,0
80008d46:	e0 89 00 1c 	brgt	80008d7e <_vfprintf_r+0x1b9e>
80008d4a:	c3 d8       	rjmp	80008dc4 <_vfprintf_r+0x1be4>
80008d4c:	2f 09       	sub	r9,-16
80008d4e:	2f f8       	sub	r8,-1
80008d50:	fb 49 06 90 	st.w	sp[1680],r9
80008d54:	87 02       	st.w	r3[0x0],r2
80008d56:	87 10       	st.w	r3[0x4],r0
80008d58:	fb 48 06 8c 	st.w	sp[1676],r8
80008d5c:	58 78       	cp.w	r8,7
80008d5e:	e0 89 00 04 	brgt	80008d66 <_vfprintf_r+0x1b86>
80008d62:	2f 83       	sub	r3,-8
80008d64:	c0 b8       	rjmp	80008d7a <_vfprintf_r+0x1b9a>
80008d66:	fa ca f9 78 	sub	r10,sp,-1672
80008d6a:	02 9b       	mov	r11,r1
80008d6c:	08 9c       	mov	r12,r4
80008d6e:	fe b0 f2 2b 	rcall	800071c4 <__sprint_r>
80008d72:	e0 81 01 b6 	brne	800090de <_vfprintf_r+0x1efe>
80008d76:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d7a:	21 06       	sub	r6,16
80008d7c:	c0 48       	rjmp	80008d84 <_vfprintf_r+0x1ba4>
80008d7e:	fe c2 be f2 	sub	r2,pc,-16654
80008d82:	31 00       	mov	r0,16
80008d84:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d8c:	fe ca bf 00 	sub	r10,pc,-16640
80008d90:	59 06       	cp.w	r6,16
80008d92:	fe 99 ff dd 	brgt	80008d4c <_vfprintf_r+0x1b6c>
80008d96:	0c 09       	add	r9,r6
80008d98:	2f f8       	sub	r8,-1
80008d9a:	87 0a       	st.w	r3[0x0],r10
80008d9c:	fb 49 06 90 	st.w	sp[1680],r9
80008da0:	87 16       	st.w	r3[0x4],r6
80008da2:	fb 48 06 8c 	st.w	sp[1676],r8
80008da6:	58 78       	cp.w	r8,7
80008da8:	e0 89 00 04 	brgt	80008db0 <_vfprintf_r+0x1bd0>
80008dac:	2f 83       	sub	r3,-8
80008dae:	c0 b8       	rjmp	80008dc4 <_vfprintf_r+0x1be4>
80008db0:	fa ca f9 78 	sub	r10,sp,-1672
80008db4:	02 9b       	mov	r11,r1
80008db6:	08 9c       	mov	r12,r4
80008db8:	fe b0 f2 06 	rcall	800071c4 <__sprint_r>
80008dbc:	e0 81 01 91 	brne	800090de <_vfprintf_r+0x1efe>
80008dc0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dc4:	ed b5 00 00 	bld	r5,0x0
80008dc8:	e0 81 01 20 	brne	80009008 <_vfprintf_r+0x1e28>
80008dcc:	40 c9       	lddsp	r9,sp[0x30]
80008dce:	fa f8 06 90 	ld.w	r8,sp[1680]
80008dd2:	2f f8       	sub	r8,-1
80008dd4:	87 09       	st.w	r3[0x0],r9
80008dd6:	fb 48 06 90 	st.w	sp[1680],r8
80008dda:	30 19       	mov	r9,1
80008ddc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008de0:	87 19       	st.w	r3[0x4],r9
80008de2:	2f f8       	sub	r8,-1
80008de4:	fb 48 06 8c 	st.w	sp[1676],r8
80008de8:	c0 29       	rjmp	80008fec <_vfprintf_r+0x1e0c>
80008dea:	14 09       	add	r9,r10
80008dec:	2f f8       	sub	r8,-1
80008dee:	fb 49 06 90 	st.w	sp[1680],r9
80008df2:	87 06       	st.w	r3[0x0],r6
80008df4:	87 1a       	st.w	r3[0x4],r10
80008df6:	fb 48 06 8c 	st.w	sp[1676],r8
80008dfa:	58 78       	cp.w	r8,7
80008dfc:	e0 89 00 04 	brgt	80008e04 <_vfprintf_r+0x1c24>
80008e00:	2f 83       	sub	r3,-8
80008e02:	c0 b8       	rjmp	80008e18 <_vfprintf_r+0x1c38>
80008e04:	fa ca f9 78 	sub	r10,sp,-1672
80008e08:	02 9b       	mov	r11,r1
80008e0a:	08 9c       	mov	r12,r4
80008e0c:	fe b0 f1 dc 	rcall	800071c4 <__sprint_r>
80008e10:	e0 81 01 67 	brne	800090de <_vfprintf_r+0x1efe>
80008e14:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e18:	40 c8       	lddsp	r8,sp[0x30]
80008e1a:	87 08       	st.w	r3[0x0],r8
80008e1c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e20:	2f f8       	sub	r8,-1
80008e22:	30 19       	mov	r9,1
80008e24:	fb 48 06 90 	st.w	sp[1680],r8
80008e28:	87 19       	st.w	r3[0x4],r9
80008e2a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e2e:	2f f8       	sub	r8,-1
80008e30:	fb 48 06 8c 	st.w	sp[1676],r8
80008e34:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008e38:	58 78       	cp.w	r8,7
80008e3a:	e0 89 00 04 	brgt	80008e42 <_vfprintf_r+0x1c62>
80008e3e:	2f 83       	sub	r3,-8
80008e40:	c0 b8       	rjmp	80008e56 <_vfprintf_r+0x1c76>
80008e42:	fa ca f9 78 	sub	r10,sp,-1672
80008e46:	02 9b       	mov	r11,r1
80008e48:	08 9c       	mov	r12,r4
80008e4a:	fe b0 f1 bd 	rcall	800071c4 <__sprint_r>
80008e4e:	e0 81 01 48 	brne	800090de <_vfprintf_r+0x1efe>
80008e52:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e56:	04 06       	add	r6,r2
80008e58:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008e5c:	87 06       	st.w	r3[0x0],r6
80008e5e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e62:	40 66       	lddsp	r6,sp[0x18]
80008e64:	40 6e       	lddsp	lr,sp[0x18]
80008e66:	10 16       	sub	r6,r8
80008e68:	f2 08 01 08 	sub	r8,r9,r8
80008e6c:	87 16       	st.w	r3[0x4],r6
80008e6e:	1c 08       	add	r8,lr
80008e70:	fb 48 06 90 	st.w	sp[1680],r8
80008e74:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e78:	2f f8       	sub	r8,-1
80008e7a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e7e:	cb 78       	rjmp	80008fec <_vfprintf_r+0x1e0c>
80008e80:	40 6c       	lddsp	r12,sp[0x18]
80008e82:	58 1c       	cp.w	r12,1
80008e84:	e0 89 00 06 	brgt	80008e90 <_vfprintf_r+0x1cb0>
80008e88:	ed b5 00 00 	bld	r5,0x0
80008e8c:	e0 81 00 85 	brne	80008f96 <_vfprintf_r+0x1db6>
80008e90:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e94:	2f f8       	sub	r8,-1
80008e96:	30 19       	mov	r9,1
80008e98:	fb 48 06 90 	st.w	sp[1680],r8
80008e9c:	87 06       	st.w	r3[0x0],r6
80008e9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ea2:	87 19       	st.w	r3[0x4],r9
80008ea4:	2f f8       	sub	r8,-1
80008ea6:	fb 48 06 8c 	st.w	sp[1676],r8
80008eaa:	58 78       	cp.w	r8,7
80008eac:	e0 89 00 04 	brgt	80008eb4 <_vfprintf_r+0x1cd4>
80008eb0:	2f 83       	sub	r3,-8
80008eb2:	c0 b8       	rjmp	80008ec8 <_vfprintf_r+0x1ce8>
80008eb4:	fa ca f9 78 	sub	r10,sp,-1672
80008eb8:	02 9b       	mov	r11,r1
80008eba:	08 9c       	mov	r12,r4
80008ebc:	fe b0 f1 84 	rcall	800071c4 <__sprint_r>
80008ec0:	e0 81 01 0f 	brne	800090de <_vfprintf_r+0x1efe>
80008ec4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ec8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ecc:	2f f8       	sub	r8,-1
80008ece:	40 cb       	lddsp	r11,sp[0x30]
80008ed0:	fb 48 06 90 	st.w	sp[1680],r8
80008ed4:	30 19       	mov	r9,1
80008ed6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008eda:	87 0b       	st.w	r3[0x0],r11
80008edc:	2f f8       	sub	r8,-1
80008ede:	87 19       	st.w	r3[0x4],r9
80008ee0:	fb 48 06 8c 	st.w	sp[1676],r8
80008ee4:	58 78       	cp.w	r8,7
80008ee6:	e0 89 00 05 	brgt	80008ef0 <_vfprintf_r+0x1d10>
80008eea:	2f 83       	sub	r3,-8
80008eec:	c0 c8       	rjmp	80008f04 <_vfprintf_r+0x1d24>
80008eee:	d7 03       	nop
80008ef0:	fa ca f9 78 	sub	r10,sp,-1672
80008ef4:	02 9b       	mov	r11,r1
80008ef6:	08 9c       	mov	r12,r4
80008ef8:	fe b0 f1 66 	rcall	800071c4 <__sprint_r>
80008efc:	e0 81 00 f1 	brne	800090de <_vfprintf_r+0x1efe>
80008f00:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f04:	30 08       	mov	r8,0
80008f06:	30 09       	mov	r9,0
80008f08:	40 5b       	lddsp	r11,sp[0x14]
80008f0a:	40 7a       	lddsp	r10,sp[0x1c]
80008f0c:	e0 a0 13 19 	rcall	8000b53e <__avr32_f64_cmp_eq>
80008f10:	40 68       	lddsp	r8,sp[0x18]
80008f12:	20 18       	sub	r8,1
80008f14:	58 0c       	cp.w	r12,0
80008f16:	c0 d1       	brne	80008f30 <_vfprintf_r+0x1d50>
80008f18:	2f f6       	sub	r6,-1
80008f1a:	87 18       	st.w	r3[0x4],r8
80008f1c:	87 06       	st.w	r3[0x0],r6
80008f1e:	fa f6 06 90 	ld.w	r6,sp[1680]
80008f22:	10 06       	add	r6,r8
80008f24:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f28:	fb 46 06 90 	st.w	sp[1680],r6
80008f2c:	2f f8       	sub	r8,-1
80008f2e:	c3 18       	rjmp	80008f90 <_vfprintf_r+0x1db0>
80008f30:	10 96       	mov	r6,r8
80008f32:	58 08       	cp.w	r8,0
80008f34:	e0 89 00 1c 	brgt	80008f6c <_vfprintf_r+0x1d8c>
80008f38:	c4 b8       	rjmp	80008fce <_vfprintf_r+0x1dee>
80008f3a:	2f 09       	sub	r9,-16
80008f3c:	2f f8       	sub	r8,-1
80008f3e:	fb 49 06 90 	st.w	sp[1680],r9
80008f42:	87 02       	st.w	r3[0x0],r2
80008f44:	87 10       	st.w	r3[0x4],r0
80008f46:	fb 48 06 8c 	st.w	sp[1676],r8
80008f4a:	58 78       	cp.w	r8,7
80008f4c:	e0 89 00 04 	brgt	80008f54 <_vfprintf_r+0x1d74>
80008f50:	2f 83       	sub	r3,-8
80008f52:	c0 b8       	rjmp	80008f68 <_vfprintf_r+0x1d88>
80008f54:	fa ca f9 78 	sub	r10,sp,-1672
80008f58:	02 9b       	mov	r11,r1
80008f5a:	08 9c       	mov	r12,r4
80008f5c:	fe b0 f1 34 	rcall	800071c4 <__sprint_r>
80008f60:	e0 81 00 bf 	brne	800090de <_vfprintf_r+0x1efe>
80008f64:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f68:	21 06       	sub	r6,16
80008f6a:	c0 48       	rjmp	80008f72 <_vfprintf_r+0x1d92>
80008f6c:	fe c2 c0 e0 	sub	r2,pc,-16160
80008f70:	31 00       	mov	r0,16
80008f72:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f76:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f7a:	fe ca c0 ee 	sub	r10,pc,-16146
80008f7e:	59 06       	cp.w	r6,16
80008f80:	fe 99 ff dd 	brgt	80008f3a <_vfprintf_r+0x1d5a>
80008f84:	0c 09       	add	r9,r6
80008f86:	87 0a       	st.w	r3[0x0],r10
80008f88:	fb 49 06 90 	st.w	sp[1680],r9
80008f8c:	2f f8       	sub	r8,-1
80008f8e:	87 16       	st.w	r3[0x4],r6
80008f90:	fb 48 06 8c 	st.w	sp[1676],r8
80008f94:	c0 e8       	rjmp	80008fb0 <_vfprintf_r+0x1dd0>
80008f96:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f9a:	2f f8       	sub	r8,-1
80008f9c:	30 19       	mov	r9,1
80008f9e:	fb 48 06 90 	st.w	sp[1680],r8
80008fa2:	87 06       	st.w	r3[0x0],r6
80008fa4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fa8:	87 19       	st.w	r3[0x4],r9
80008faa:	2f f8       	sub	r8,-1
80008fac:	fb 48 06 8c 	st.w	sp[1676],r8
80008fb0:	58 78       	cp.w	r8,7
80008fb2:	e0 89 00 04 	brgt	80008fba <_vfprintf_r+0x1dda>
80008fb6:	2f 83       	sub	r3,-8
80008fb8:	c0 b8       	rjmp	80008fce <_vfprintf_r+0x1dee>
80008fba:	fa ca f9 78 	sub	r10,sp,-1672
80008fbe:	02 9b       	mov	r11,r1
80008fc0:	08 9c       	mov	r12,r4
80008fc2:	fe b0 f1 01 	rcall	800071c4 <__sprint_r>
80008fc6:	e0 81 00 8c 	brne	800090de <_vfprintf_r+0x1efe>
80008fca:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fce:	40 ea       	lddsp	r10,sp[0x38]
80008fd0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fd4:	14 08       	add	r8,r10
80008fd6:	fa c9 f9 64 	sub	r9,sp,-1692
80008fda:	fb 48 06 90 	st.w	sp[1680],r8
80008fde:	87 1a       	st.w	r3[0x4],r10
80008fe0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fe4:	87 09       	st.w	r3[0x0],r9
80008fe6:	2f f8       	sub	r8,-1
80008fe8:	fb 48 06 8c 	st.w	sp[1676],r8
80008fec:	58 78       	cp.w	r8,7
80008fee:	e0 89 00 04 	brgt	80008ff6 <_vfprintf_r+0x1e16>
80008ff2:	2f 83       	sub	r3,-8
80008ff4:	c0 a8       	rjmp	80009008 <_vfprintf_r+0x1e28>
80008ff6:	fa ca f9 78 	sub	r10,sp,-1672
80008ffa:	02 9b       	mov	r11,r1
80008ffc:	08 9c       	mov	r12,r4
80008ffe:	fe b0 f0 e3 	rcall	800071c4 <__sprint_r>
80009002:	c6 e1       	brne	800090de <_vfprintf_r+0x1efe>
80009004:	fa c3 f9 e0 	sub	r3,sp,-1568
80009008:	e2 15 00 04 	andl	r5,0x4,COH
8000900c:	c3 f0       	breq	8000908a <_vfprintf_r+0x1eaa>
8000900e:	40 86       	lddsp	r6,sp[0x20]
80009010:	40 39       	lddsp	r9,sp[0xc]
80009012:	12 16       	sub	r6,r9
80009014:	58 06       	cp.w	r6,0
80009016:	e0 89 00 1a 	brgt	8000904a <_vfprintf_r+0x1e6a>
8000901a:	c3 88       	rjmp	8000908a <_vfprintf_r+0x1eaa>
8000901c:	2f 09       	sub	r9,-16
8000901e:	2f f8       	sub	r8,-1
80009020:	fb 49 06 90 	st.w	sp[1680],r9
80009024:	87 05       	st.w	r3[0x0],r5
80009026:	87 12       	st.w	r3[0x4],r2
80009028:	fb 48 06 8c 	st.w	sp[1676],r8
8000902c:	58 78       	cp.w	r8,7
8000902e:	e0 89 00 04 	brgt	80009036 <_vfprintf_r+0x1e56>
80009032:	2f 83       	sub	r3,-8
80009034:	c0 98       	rjmp	80009046 <_vfprintf_r+0x1e66>
80009036:	00 9a       	mov	r10,r0
80009038:	02 9b       	mov	r11,r1
8000903a:	08 9c       	mov	r12,r4
8000903c:	fe b0 f0 c4 	rcall	800071c4 <__sprint_r>
80009040:	c4 f1       	brne	800090de <_vfprintf_r+0x1efe>
80009042:	fa c3 f9 e0 	sub	r3,sp,-1568
80009046:	21 06       	sub	r6,16
80009048:	c0 68       	rjmp	80009054 <_vfprintf_r+0x1e74>
8000904a:	fe c5 c1 ce 	sub	r5,pc,-15922
8000904e:	31 02       	mov	r2,16
80009050:	fa c0 f9 78 	sub	r0,sp,-1672
80009054:	fa f9 06 90 	ld.w	r9,sp[1680]
80009058:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000905c:	fe ca c1 e0 	sub	r10,pc,-15904
80009060:	59 06       	cp.w	r6,16
80009062:	fe 99 ff dd 	brgt	8000901c <_vfprintf_r+0x1e3c>
80009066:	0c 09       	add	r9,r6
80009068:	2f f8       	sub	r8,-1
8000906a:	87 0a       	st.w	r3[0x0],r10
8000906c:	87 16       	st.w	r3[0x4],r6
8000906e:	fb 49 06 90 	st.w	sp[1680],r9
80009072:	fb 48 06 8c 	st.w	sp[1676],r8
80009076:	58 78       	cp.w	r8,7
80009078:	e0 8a 00 09 	brle	8000908a <_vfprintf_r+0x1eaa>
8000907c:	fa ca f9 78 	sub	r10,sp,-1672
80009080:	02 9b       	mov	r11,r1
80009082:	08 9c       	mov	r12,r4
80009084:	fe b0 f0 a0 	rcall	800071c4 <__sprint_r>
80009088:	c2 b1       	brne	800090de <_vfprintf_r+0x1efe>
8000908a:	40 bc       	lddsp	r12,sp[0x2c]
8000908c:	40 36       	lddsp	r6,sp[0xc]
8000908e:	40 8e       	lddsp	lr,sp[0x20]
80009090:	ec 0e 0c 48 	max	r8,r6,lr
80009094:	10 0c       	add	r12,r8
80009096:	50 bc       	stdsp	sp[0x2c],r12
80009098:	fa f8 06 90 	ld.w	r8,sp[1680]
8000909c:	58 08       	cp.w	r8,0
8000909e:	c0 80       	breq	800090ae <_vfprintf_r+0x1ece>
800090a0:	fa ca f9 78 	sub	r10,sp,-1672
800090a4:	02 9b       	mov	r11,r1
800090a6:	08 9c       	mov	r12,r4
800090a8:	fe b0 f0 8e 	rcall	800071c4 <__sprint_r>
800090ac:	c1 91       	brne	800090de <_vfprintf_r+0x1efe>
800090ae:	30 0b       	mov	r11,0
800090b0:	fa c3 f9 e0 	sub	r3,sp,-1568
800090b4:	fb 4b 06 8c 	st.w	sp[1676],r11
800090b8:	fe 9f f1 22 	bral	800072fc <_vfprintf_r+0x11c>
800090bc:	08 95       	mov	r5,r4
800090be:	fa f8 06 90 	ld.w	r8,sp[1680]
800090c2:	58 08       	cp.w	r8,0
800090c4:	c0 80       	breq	800090d4 <_vfprintf_r+0x1ef4>
800090c6:	08 9c       	mov	r12,r4
800090c8:	fa ca f9 78 	sub	r10,sp,-1672
800090cc:	02 9b       	mov	r11,r1
800090ce:	fe b0 f0 7b 	rcall	800071c4 <__sprint_r>
800090d2:	c0 61       	brne	800090de <_vfprintf_r+0x1efe>
800090d4:	30 08       	mov	r8,0
800090d6:	fb 48 06 8c 	st.w	sp[1676],r8
800090da:	c0 28       	rjmp	800090de <_vfprintf_r+0x1efe>
800090dc:	40 41       	lddsp	r1,sp[0x10]
800090de:	82 68       	ld.sh	r8,r1[0xc]
800090e0:	ed b8 00 06 	bld	r8,0x6
800090e4:	c0 31       	brne	800090ea <_vfprintf_r+0x1f0a>
800090e6:	3f fa       	mov	r10,-1
800090e8:	50 ba       	stdsp	sp[0x2c],r10
800090ea:	40 bc       	lddsp	r12,sp[0x2c]
800090ec:	fe 3d f9 44 	sub	sp,-1724
800090f0:	d8 32       	popm	r0-r7,pc
800090f2:	d7 03       	nop

800090f4 <__swsetup_r>:
800090f4:	d4 21       	pushm	r4-r7,lr
800090f6:	e0 68 0a 44 	mov	r8,2628
800090fa:	18 96       	mov	r6,r12
800090fc:	16 97       	mov	r7,r11
800090fe:	70 0c       	ld.w	r12,r8[0x0]
80009100:	58 0c       	cp.w	r12,0
80009102:	c0 60       	breq	8000910e <__swsetup_r+0x1a>
80009104:	78 68       	ld.w	r8,r12[0x18]
80009106:	58 08       	cp.w	r8,0
80009108:	c0 31       	brne	8000910e <__swsetup_r+0x1a>
8000910a:	e0 a0 07 bf 	rcall	8000a088 <__sinit>
8000910e:	fe c8 c1 62 	sub	r8,pc,-16030
80009112:	10 37       	cp.w	r7,r8
80009114:	c0 61       	brne	80009120 <__swsetup_r+0x2c>
80009116:	e0 68 0a 44 	mov	r8,2628
8000911a:	70 08       	ld.w	r8,r8[0x0]
8000911c:	70 07       	ld.w	r7,r8[0x0]
8000911e:	c1 28       	rjmp	80009142 <__swsetup_r+0x4e>
80009120:	fe c8 c1 54 	sub	r8,pc,-16044
80009124:	10 37       	cp.w	r7,r8
80009126:	c0 61       	brne	80009132 <__swsetup_r+0x3e>
80009128:	e0 68 0a 44 	mov	r8,2628
8000912c:	70 08       	ld.w	r8,r8[0x0]
8000912e:	70 17       	ld.w	r7,r8[0x4]
80009130:	c0 98       	rjmp	80009142 <__swsetup_r+0x4e>
80009132:	fe c8 c1 46 	sub	r8,pc,-16058
80009136:	10 37       	cp.w	r7,r8
80009138:	c0 51       	brne	80009142 <__swsetup_r+0x4e>
8000913a:	e0 68 0a 44 	mov	r8,2628
8000913e:	70 08       	ld.w	r8,r8[0x0]
80009140:	70 27       	ld.w	r7,r8[0x8]
80009142:	8e 68       	ld.sh	r8,r7[0xc]
80009144:	ed b8 00 03 	bld	r8,0x3
80009148:	c1 e0       	breq	80009184 <__swsetup_r+0x90>
8000914a:	ed b8 00 04 	bld	r8,0x4
8000914e:	c3 e1       	brne	800091ca <__swsetup_r+0xd6>
80009150:	ed b8 00 02 	bld	r8,0x2
80009154:	c1 51       	brne	8000917e <__swsetup_r+0x8a>
80009156:	6e db       	ld.w	r11,r7[0x34]
80009158:	58 0b       	cp.w	r11,0
8000915a:	c0 a0       	breq	8000916e <__swsetup_r+0x7a>
8000915c:	ee c8 ff bc 	sub	r8,r7,-68
80009160:	10 3b       	cp.w	r11,r8
80009162:	c0 40       	breq	8000916a <__swsetup_r+0x76>
80009164:	0c 9c       	mov	r12,r6
80009166:	e0 a0 08 2b 	rcall	8000a1bc <_free_r>
8000916a:	30 08       	mov	r8,0
8000916c:	8f d8       	st.w	r7[0x34],r8
8000916e:	8e 68       	ld.sh	r8,r7[0xc]
80009170:	e0 18 ff db 	andl	r8,0xffdb
80009174:	ae 68       	st.h	r7[0xc],r8
80009176:	30 08       	mov	r8,0
80009178:	8f 18       	st.w	r7[0x4],r8
8000917a:	6e 48       	ld.w	r8,r7[0x10]
8000917c:	8f 08       	st.w	r7[0x0],r8
8000917e:	8e 68       	ld.sh	r8,r7[0xc]
80009180:	a3 b8       	sbr	r8,0x3
80009182:	ae 68       	st.h	r7[0xc],r8
80009184:	6e 48       	ld.w	r8,r7[0x10]
80009186:	58 08       	cp.w	r8,0
80009188:	c0 b1       	brne	8000919e <__swsetup_r+0xaa>
8000918a:	8e 68       	ld.sh	r8,r7[0xc]
8000918c:	e2 18 02 80 	andl	r8,0x280,COH
80009190:	e0 48 02 00 	cp.w	r8,512
80009194:	c0 50       	breq	8000919e <__swsetup_r+0xaa>
80009196:	0c 9c       	mov	r12,r6
80009198:	0e 9b       	mov	r11,r7
8000919a:	e0 a0 0a 4b 	rcall	8000a630 <__smakebuf_r>
8000919e:	8e 69       	ld.sh	r9,r7[0xc]
800091a0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
800091a4:	c0 70       	breq	800091b2 <__swsetup_r+0xbe>
800091a6:	30 08       	mov	r8,0
800091a8:	8f 28       	st.w	r7[0x8],r8
800091aa:	6e 58       	ld.w	r8,r7[0x14]
800091ac:	5c 38       	neg	r8
800091ae:	8f 68       	st.w	r7[0x18],r8
800091b0:	c0 68       	rjmp	800091bc <__swsetup_r+0xc8>
800091b2:	ed b9 00 01 	bld	r9,0x1
800091b6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
800091ba:	8f 28       	st.w	r7[0x8],r8
800091bc:	6e 48       	ld.w	r8,r7[0x10]
800091be:	58 08       	cp.w	r8,0
800091c0:	c0 61       	brne	800091cc <__swsetup_r+0xd8>
800091c2:	8e 68       	ld.sh	r8,r7[0xc]
800091c4:	ed b8 00 07 	bld	r8,0x7
800091c8:	c0 21       	brne	800091cc <__swsetup_r+0xd8>
800091ca:	dc 2a       	popm	r4-r7,pc,r12=-1
800091cc:	d8 2a       	popm	r4-r7,pc,r12=0
800091ce:	d7 03       	nop

800091d0 <quorem>:
800091d0:	d4 31       	pushm	r0-r7,lr
800091d2:	20 2d       	sub	sp,8
800091d4:	18 97       	mov	r7,r12
800091d6:	78 48       	ld.w	r8,r12[0x10]
800091d8:	76 46       	ld.w	r6,r11[0x10]
800091da:	0c 38       	cp.w	r8,r6
800091dc:	c0 34       	brge	800091e2 <quorem+0x12>
800091de:	30 0c       	mov	r12,0
800091e0:	c8 58       	rjmp	800092ea <quorem+0x11a>
800091e2:	ec c2 ff fc 	sub	r2,r6,-4
800091e6:	f6 c3 ff ec 	sub	r3,r11,-20
800091ea:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800091ee:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800091f2:	2f f9       	sub	r9,-1
800091f4:	20 16       	sub	r6,1
800091f6:	f8 09 0d 08 	divu	r8,r12,r9
800091fa:	f6 02 00 22 	add	r2,r11,r2<<0x2
800091fe:	ee c4 ff ec 	sub	r4,r7,-20
80009202:	10 95       	mov	r5,r8
80009204:	58 08       	cp.w	r8,0
80009206:	c4 10       	breq	80009288 <quorem+0xb8>
80009208:	30 09       	mov	r9,0
8000920a:	06 9a       	mov	r10,r3
8000920c:	08 98       	mov	r8,r4
8000920e:	12 91       	mov	r1,r9
80009210:	50 0b       	stdsp	sp[0x0],r11
80009212:	70 0e       	ld.w	lr,r8[0x0]
80009214:	b1 8e       	lsr	lr,0x10
80009216:	50 1e       	stdsp	sp[0x4],lr
80009218:	15 0e       	ld.w	lr,r10++
8000921a:	fc 00 16 10 	lsr	r0,lr,0x10
8000921e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009222:	ea 0e 03 41 	mac	r1,r5,lr
80009226:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000922a:	b1 81       	lsr	r1,0x10
8000922c:	40 1b       	lddsp	r11,sp[0x4]
8000922e:	ea 00 02 40 	mul	r0,r5,r0
80009232:	e2 00 00 00 	add	r0,r1,r0
80009236:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000923a:	02 1b       	sub	r11,r1
8000923c:	50 1b       	stdsp	sp[0x4],r11
8000923e:	70 0b       	ld.w	r11,r8[0x0]
80009240:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009244:	02 09       	add	r9,r1
80009246:	f2 0e 01 0e 	sub	lr,r9,lr
8000924a:	b0 1e       	st.h	r8[0x2],lr
8000924c:	fc 09 14 10 	asr	r9,lr,0x10
80009250:	40 1e       	lddsp	lr,sp[0x4]
80009252:	fc 09 00 09 	add	r9,lr,r9
80009256:	b0 09       	st.h	r8[0x0],r9
80009258:	e0 01 16 10 	lsr	r1,r0,0x10
8000925c:	2f c8       	sub	r8,-4
8000925e:	b1 49       	asr	r9,0x10
80009260:	04 3a       	cp.w	r10,r2
80009262:	fe 98 ff d8 	brls	80009212 <quorem+0x42>
80009266:	40 0b       	lddsp	r11,sp[0x0]
80009268:	58 0c       	cp.w	r12,0
8000926a:	c0 f1       	brne	80009288 <quorem+0xb8>
8000926c:	ec c8 ff fb 	sub	r8,r6,-5
80009270:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009274:	c0 28       	rjmp	80009278 <quorem+0xa8>
80009276:	20 16       	sub	r6,1
80009278:	20 48       	sub	r8,4
8000927a:	08 38       	cp.w	r8,r4
8000927c:	e0 88 00 05 	brls	80009286 <quorem+0xb6>
80009280:	70 09       	ld.w	r9,r8[0x0]
80009282:	58 09       	cp.w	r9,0
80009284:	cf 90       	breq	80009276 <quorem+0xa6>
80009286:	8f 46       	st.w	r7[0x10],r6
80009288:	0e 9c       	mov	r12,r7
8000928a:	e0 a0 0a d2 	rcall	8000a82e <__mcmp>
8000928e:	c2 d5       	brlt	800092e8 <quorem+0x118>
80009290:	2f f5       	sub	r5,-1
80009292:	08 98       	mov	r8,r4
80009294:	30 09       	mov	r9,0
80009296:	07 0b       	ld.w	r11,r3++
80009298:	f6 0a 16 10 	lsr	r10,r11,0x10
8000929c:	70 0c       	ld.w	r12,r8[0x0]
8000929e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800092a2:	f8 0e 16 10 	lsr	lr,r12,0x10
800092a6:	14 1e       	sub	lr,r10
800092a8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800092ac:	16 1a       	sub	r10,r11
800092ae:	12 0a       	add	r10,r9
800092b0:	b0 1a       	st.h	r8[0x2],r10
800092b2:	b1 4a       	asr	r10,0x10
800092b4:	fc 0a 00 09 	add	r9,lr,r10
800092b8:	b0 09       	st.h	r8[0x0],r9
800092ba:	2f c8       	sub	r8,-4
800092bc:	b1 49       	asr	r9,0x10
800092be:	04 33       	cp.w	r3,r2
800092c0:	fe 98 ff eb 	brls	80009296 <quorem+0xc6>
800092c4:	ec c8 ff fb 	sub	r8,r6,-5
800092c8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800092cc:	58 09       	cp.w	r9,0
800092ce:	c0 d1       	brne	800092e8 <quorem+0x118>
800092d0:	ee 08 00 28 	add	r8,r7,r8<<0x2
800092d4:	c0 28       	rjmp	800092d8 <quorem+0x108>
800092d6:	20 16       	sub	r6,1
800092d8:	20 48       	sub	r8,4
800092da:	08 38       	cp.w	r8,r4
800092dc:	e0 88 00 05 	brls	800092e6 <quorem+0x116>
800092e0:	70 09       	ld.w	r9,r8[0x0]
800092e2:	58 09       	cp.w	r9,0
800092e4:	cf 90       	breq	800092d6 <quorem+0x106>
800092e6:	8f 46       	st.w	r7[0x10],r6
800092e8:	0a 9c       	mov	r12,r5
800092ea:	2f ed       	sub	sp,-8
800092ec:	d8 32       	popm	r0-r7,pc
800092ee:	d7 03       	nop

800092f0 <_dtoa_r>:
800092f0:	d4 31       	pushm	r0-r7,lr
800092f2:	21 ad       	sub	sp,104
800092f4:	fa c4 ff 74 	sub	r4,sp,-140
800092f8:	18 97       	mov	r7,r12
800092fa:	16 95       	mov	r5,r11
800092fc:	68 2c       	ld.w	r12,r4[0x8]
800092fe:	50 c9       	stdsp	sp[0x30],r9
80009300:	68 16       	ld.w	r6,r4[0x4]
80009302:	68 09       	ld.w	r9,r4[0x0]
80009304:	50 e8       	stdsp	sp[0x38],r8
80009306:	14 94       	mov	r4,r10
80009308:	51 2c       	stdsp	sp[0x48],r12
8000930a:	fa e5 00 08 	st.d	sp[8],r4
8000930e:	51 59       	stdsp	sp[0x54],r9
80009310:	6e 95       	ld.w	r5,r7[0x24]
80009312:	58 05       	cp.w	r5,0
80009314:	c0 91       	brne	80009326 <_dtoa_r+0x36>
80009316:	31 0c       	mov	r12,16
80009318:	fe b0 e8 e8 	rcall	800064e8 <malloc>
8000931c:	99 35       	st.w	r12[0xc],r5
8000931e:	8f 9c       	st.w	r7[0x24],r12
80009320:	99 15       	st.w	r12[0x4],r5
80009322:	99 25       	st.w	r12[0x8],r5
80009324:	99 05       	st.w	r12[0x0],r5
80009326:	6e 99       	ld.w	r9,r7[0x24]
80009328:	72 08       	ld.w	r8,r9[0x0]
8000932a:	58 08       	cp.w	r8,0
8000932c:	c0 f0       	breq	8000934a <_dtoa_r+0x5a>
8000932e:	72 1a       	ld.w	r10,r9[0x4]
80009330:	91 1a       	st.w	r8[0x4],r10
80009332:	30 1a       	mov	r10,1
80009334:	72 19       	ld.w	r9,r9[0x4]
80009336:	f4 09 09 49 	lsl	r9,r10,r9
8000933a:	10 9b       	mov	r11,r8
8000933c:	91 29       	st.w	r8[0x8],r9
8000933e:	0e 9c       	mov	r12,r7
80009340:	e0 a0 0a 90 	rcall	8000a860 <_Bfree>
80009344:	6e 98       	ld.w	r8,r7[0x24]
80009346:	30 09       	mov	r9,0
80009348:	91 09       	st.w	r8[0x0],r9
8000934a:	40 28       	lddsp	r8,sp[0x8]
8000934c:	10 94       	mov	r4,r8
8000934e:	58 08       	cp.w	r8,0
80009350:	c0 64       	brge	8000935c <_dtoa_r+0x6c>
80009352:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009356:	50 28       	stdsp	sp[0x8],r8
80009358:	30 18       	mov	r8,1
8000935a:	c0 28       	rjmp	8000935e <_dtoa_r+0x6e>
8000935c:	30 08       	mov	r8,0
8000935e:	8d 08       	st.w	r6[0x0],r8
80009360:	fc 1c 7f f0 	movh	r12,0x7ff0
80009364:	40 26       	lddsp	r6,sp[0x8]
80009366:	0c 98       	mov	r8,r6
80009368:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000936c:	18 38       	cp.w	r8,r12
8000936e:	c2 01       	brne	800093ae <_dtoa_r+0xbe>
80009370:	e0 68 27 0f 	mov	r8,9999
80009374:	41 5b       	lddsp	r11,sp[0x54]
80009376:	97 08       	st.w	r11[0x0],r8
80009378:	40 3a       	lddsp	r10,sp[0xc]
8000937a:	58 0a       	cp.w	r10,0
8000937c:	c0 71       	brne	8000938a <_dtoa_r+0x9a>
8000937e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009382:	c0 41       	brne	8000938a <_dtoa_r+0x9a>
80009384:	fe cc c3 e8 	sub	r12,pc,-15384
80009388:	c0 38       	rjmp	8000938e <_dtoa_r+0x9e>
8000938a:	fe cc c3 e2 	sub	r12,pc,-15390
8000938e:	41 29       	lddsp	r9,sp[0x48]
80009390:	58 09       	cp.w	r9,0
80009392:	e0 80 05 9a 	breq	80009ec6 <_dtoa_r+0xbd6>
80009396:	f8 c8 ff fd 	sub	r8,r12,-3
8000939a:	f8 c9 ff f8 	sub	r9,r12,-8
8000939e:	11 8b       	ld.ub	r11,r8[0x0]
800093a0:	30 0a       	mov	r10,0
800093a2:	41 25       	lddsp	r5,sp[0x48]
800093a4:	f4 0b 18 00 	cp.b	r11,r10
800093a8:	f2 08 17 10 	movne	r8,r9
800093ac:	c1 68       	rjmp	800093d8 <_dtoa_r+0xe8>
800093ae:	fa ea 00 08 	ld.d	r10,sp[8]
800093b2:	30 08       	mov	r8,0
800093b4:	fa eb 00 3c 	st.d	sp[60],r10
800093b8:	30 09       	mov	r9,0
800093ba:	e0 a0 10 c2 	rcall	8000b53e <__avr32_f64_cmp_eq>
800093be:	c1 00       	breq	800093de <_dtoa_r+0xee>
800093c0:	30 18       	mov	r8,1
800093c2:	41 5a       	lddsp	r10,sp[0x54]
800093c4:	95 08       	st.w	r10[0x0],r8
800093c6:	fe cc c5 4e 	sub	r12,pc,-15026
800093ca:	41 29       	lddsp	r9,sp[0x48]
800093cc:	f8 08 00 08 	add	r8,r12,r8
800093d0:	58 09       	cp.w	r9,0
800093d2:	e0 80 05 7a 	breq	80009ec6 <_dtoa_r+0xbd6>
800093d6:	12 95       	mov	r5,r9
800093d8:	8b 08       	st.w	r5[0x0],r8
800093da:	e0 8f 05 76 	bral	80009ec6 <_dtoa_r+0xbd6>
800093de:	fa c8 ff 9c 	sub	r8,sp,-100
800093e2:	fa c9 ff a0 	sub	r9,sp,-96
800093e6:	fa ea 00 3c 	ld.d	r10,sp[60]
800093ea:	0e 9c       	mov	r12,r7
800093ec:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
800093f0:	e0 a0 0a 8a 	rcall	8000a904 <__d2b>
800093f4:	18 93       	mov	r3,r12
800093f6:	58 05       	cp.w	r5,0
800093f8:	c0 d0       	breq	80009412 <_dtoa_r+0x122>
800093fa:	fa ea 00 3c 	ld.d	r10,sp[60]
800093fe:	30 04       	mov	r4,0
80009400:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009404:	ea c5 03 ff 	sub	r5,r5,1023
80009408:	10 9b       	mov	r11,r8
8000940a:	51 74       	stdsp	sp[0x5c],r4
8000940c:	ea 1b 3f f0 	orh	r11,0x3ff0
80009410:	c2 58       	rjmp	8000945a <_dtoa_r+0x16a>
80009412:	41 88       	lddsp	r8,sp[0x60]
80009414:	41 9c       	lddsp	r12,sp[0x64]
80009416:	10 0c       	add	r12,r8
80009418:	f8 c5 fb ce 	sub	r5,r12,-1074
8000941c:	e0 45 00 20 	cp.w	r5,32
80009420:	e0 8a 00 0e 	brle	8000943c <_dtoa_r+0x14c>
80009424:	f8 cc fb ee 	sub	r12,r12,-1042
80009428:	40 3b       	lddsp	r11,sp[0xc]
8000942a:	ea 08 11 40 	rsub	r8,r5,64
8000942e:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009432:	ec 08 09 46 	lsl	r6,r6,r8
80009436:	0c 4c       	or	r12,r6
80009438:	c0 78       	rjmp	80009446 <_dtoa_r+0x156>
8000943a:	d7 03       	nop
8000943c:	ea 0c 11 20 	rsub	r12,r5,32
80009440:	40 3a       	lddsp	r10,sp[0xc]
80009442:	f4 0c 09 4c 	lsl	r12,r10,r12
80009446:	e0 a0 10 08 	rcall	8000b456 <__avr32_u32_to_f64>
8000944a:	fc 18 fe 10 	movh	r8,0xfe10
8000944e:	30 19       	mov	r9,1
80009450:	ea c5 04 33 	sub	r5,r5,1075
80009454:	f0 0b 00 0b 	add	r11,r8,r11
80009458:	51 79       	stdsp	sp[0x5c],r9
8000945a:	30 08       	mov	r8,0
8000945c:	fc 19 3f f8 	movh	r9,0x3ff8
80009460:	e0 a0 0e 90 	rcall	8000b180 <__avr32_f64_sub>
80009464:	e0 68 43 61 	mov	r8,17249
80009468:	ea 18 63 6f 	orh	r8,0x636f
8000946c:	e0 69 87 a7 	mov	r9,34727
80009470:	ea 19 3f d2 	orh	r9,0x3fd2
80009474:	e0 a0 0d 9a 	rcall	8000afa8 <__avr32_f64_mul>
80009478:	e0 68 c8 b3 	mov	r8,51379
8000947c:	ea 18 8b 60 	orh	r8,0x8b60
80009480:	e0 69 8a 28 	mov	r9,35368
80009484:	ea 19 3f c6 	orh	r9,0x3fc6
80009488:	e0 a0 0f 4a 	rcall	8000b31c <__avr32_f64_add>
8000948c:	0a 9c       	mov	r12,r5
8000948e:	14 90       	mov	r0,r10
80009490:	16 91       	mov	r1,r11
80009492:	e0 a0 0f e6 	rcall	8000b45e <__avr32_s32_to_f64>
80009496:	e0 68 79 fb 	mov	r8,31227
8000949a:	ea 18 50 9f 	orh	r8,0x509f
8000949e:	e0 69 44 13 	mov	r9,17427
800094a2:	ea 19 3f d3 	orh	r9,0x3fd3
800094a6:	e0 a0 0d 81 	rcall	8000afa8 <__avr32_f64_mul>
800094aa:	14 98       	mov	r8,r10
800094ac:	16 99       	mov	r9,r11
800094ae:	00 9a       	mov	r10,r0
800094b0:	02 9b       	mov	r11,r1
800094b2:	e0 a0 0f 35 	rcall	8000b31c <__avr32_f64_add>
800094b6:	14 90       	mov	r0,r10
800094b8:	16 91       	mov	r1,r11
800094ba:	e0 a0 0f bb 	rcall	8000b430 <__avr32_f64_to_s32>
800094be:	30 08       	mov	r8,0
800094c0:	18 96       	mov	r6,r12
800094c2:	30 09       	mov	r9,0
800094c4:	00 9a       	mov	r10,r0
800094c6:	02 9b       	mov	r11,r1
800094c8:	e0 a0 10 82 	rcall	8000b5cc <__avr32_f64_cmp_lt>
800094cc:	c0 c0       	breq	800094e4 <_dtoa_r+0x1f4>
800094ce:	0c 9c       	mov	r12,r6
800094d0:	e0 a0 0f c7 	rcall	8000b45e <__avr32_s32_to_f64>
800094d4:	14 98       	mov	r8,r10
800094d6:	16 99       	mov	r9,r11
800094d8:	00 9a       	mov	r10,r0
800094da:	02 9b       	mov	r11,r1
800094dc:	e0 a0 10 31 	rcall	8000b53e <__avr32_f64_cmp_eq>
800094e0:	f7 b6 00 01 	subeq	r6,1
800094e4:	59 66       	cp.w	r6,22
800094e6:	e0 88 00 05 	brls	800094f0 <_dtoa_r+0x200>
800094ea:	30 18       	mov	r8,1
800094ec:	51 48       	stdsp	sp[0x50],r8
800094ee:	c1 38       	rjmp	80009514 <_dtoa_r+0x224>
800094f0:	fe c8 c4 94 	sub	r8,pc,-15212
800094f4:	fa ea 00 3c 	ld.d	r10,sp[60]
800094f8:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800094fc:	e0 a0 10 68 	rcall	8000b5cc <__avr32_f64_cmp_lt>
80009500:	f9 b4 00 00 	moveq	r4,0
80009504:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009508:	f7 b6 01 01 	subne	r6,1
8000950c:	f9 bc 01 00 	movne	r12,0
80009510:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009514:	41 90       	lddsp	r0,sp[0x64]
80009516:	20 10       	sub	r0,1
80009518:	0a 10       	sub	r0,r5
8000951a:	c0 46       	brmi	80009522 <_dtoa_r+0x232>
8000951c:	50 40       	stdsp	sp[0x10],r0
8000951e:	30 00       	mov	r0,0
80009520:	c0 48       	rjmp	80009528 <_dtoa_r+0x238>
80009522:	30 0b       	mov	r11,0
80009524:	5c 30       	neg	r0
80009526:	50 4b       	stdsp	sp[0x10],r11
80009528:	ec 02 11 00 	rsub	r2,r6,0
8000952c:	58 06       	cp.w	r6,0
8000952e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009532:	f5 d6 e4 0a 	addge	r10,r10,r6
80009536:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000953a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000953e:	f9 b2 04 00 	movge	r2,0
80009542:	e1 d6 e5 10 	sublt	r0,r0,r6
80009546:	f9 b9 05 00 	movlt	r9,0
8000954a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000954e:	40 c8       	lddsp	r8,sp[0x30]
80009550:	58 98       	cp.w	r8,9
80009552:	e0 8b 00 20 	brhi	80009592 <_dtoa_r+0x2a2>
80009556:	58 58       	cp.w	r8,5
80009558:	f9 b4 0a 01 	movle	r4,1
8000955c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009560:	f7 b5 09 04 	subgt	r5,4
80009564:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009568:	f9 b4 09 00 	movgt	r4,0
8000956c:	40 cc       	lddsp	r12,sp[0x30]
8000956e:	58 3c       	cp.w	r12,3
80009570:	c2 d0       	breq	800095ca <_dtoa_r+0x2da>
80009572:	e0 89 00 05 	brgt	8000957c <_dtoa_r+0x28c>
80009576:	58 2c       	cp.w	r12,2
80009578:	c1 01       	brne	80009598 <_dtoa_r+0x2a8>
8000957a:	c1 88       	rjmp	800095aa <_dtoa_r+0x2ba>
8000957c:	40 cb       	lddsp	r11,sp[0x30]
8000957e:	58 4b       	cp.w	r11,4
80009580:	c0 60       	breq	8000958c <_dtoa_r+0x29c>
80009582:	58 5b       	cp.w	r11,5
80009584:	c0 a1       	brne	80009598 <_dtoa_r+0x2a8>
80009586:	30 1a       	mov	r10,1
80009588:	50 da       	stdsp	sp[0x34],r10
8000958a:	c2 28       	rjmp	800095ce <_dtoa_r+0x2de>
8000958c:	30 19       	mov	r9,1
8000958e:	50 d9       	stdsp	sp[0x34],r9
80009590:	c0 f8       	rjmp	800095ae <_dtoa_r+0x2be>
80009592:	30 08       	mov	r8,0
80009594:	30 14       	mov	r4,1
80009596:	50 c8       	stdsp	sp[0x30],r8
80009598:	3f f5       	mov	r5,-1
8000959a:	30 1c       	mov	r12,1
8000959c:	30 0b       	mov	r11,0
8000959e:	50 95       	stdsp	sp[0x24],r5
800095a0:	50 dc       	stdsp	sp[0x34],r12
800095a2:	0a 91       	mov	r1,r5
800095a4:	31 28       	mov	r8,18
800095a6:	50 eb       	stdsp	sp[0x38],r11
800095a8:	c2 08       	rjmp	800095e8 <_dtoa_r+0x2f8>
800095aa:	30 0a       	mov	r10,0
800095ac:	50 da       	stdsp	sp[0x34],r10
800095ae:	40 e9       	lddsp	r9,sp[0x38]
800095b0:	58 09       	cp.w	r9,0
800095b2:	e0 89 00 07 	brgt	800095c0 <_dtoa_r+0x2d0>
800095b6:	30 18       	mov	r8,1
800095b8:	50 98       	stdsp	sp[0x24],r8
800095ba:	10 91       	mov	r1,r8
800095bc:	50 e8       	stdsp	sp[0x38],r8
800095be:	c1 58       	rjmp	800095e8 <_dtoa_r+0x2f8>
800095c0:	40 e5       	lddsp	r5,sp[0x38]
800095c2:	50 95       	stdsp	sp[0x24],r5
800095c4:	0a 91       	mov	r1,r5
800095c6:	0a 98       	mov	r8,r5
800095c8:	c1 08       	rjmp	800095e8 <_dtoa_r+0x2f8>
800095ca:	30 0c       	mov	r12,0
800095cc:	50 dc       	stdsp	sp[0x34],r12
800095ce:	40 eb       	lddsp	r11,sp[0x38]
800095d0:	ec 0b 00 0b 	add	r11,r6,r11
800095d4:	50 9b       	stdsp	sp[0x24],r11
800095d6:	16 98       	mov	r8,r11
800095d8:	2f f8       	sub	r8,-1
800095da:	58 08       	cp.w	r8,0
800095dc:	e0 89 00 05 	brgt	800095e6 <_dtoa_r+0x2f6>
800095e0:	10 91       	mov	r1,r8
800095e2:	30 18       	mov	r8,1
800095e4:	c0 28       	rjmp	800095e8 <_dtoa_r+0x2f8>
800095e6:	10 91       	mov	r1,r8
800095e8:	30 09       	mov	r9,0
800095ea:	6e 9a       	ld.w	r10,r7[0x24]
800095ec:	95 19       	st.w	r10[0x4],r9
800095ee:	30 49       	mov	r9,4
800095f0:	c0 68       	rjmp	800095fc <_dtoa_r+0x30c>
800095f2:	d7 03       	nop
800095f4:	6a 1a       	ld.w	r10,r5[0x4]
800095f6:	a1 79       	lsl	r9,0x1
800095f8:	2f fa       	sub	r10,-1
800095fa:	8b 1a       	st.w	r5[0x4],r10
800095fc:	6e 95       	ld.w	r5,r7[0x24]
800095fe:	f2 ca ff ec 	sub	r10,r9,-20
80009602:	10 3a       	cp.w	r10,r8
80009604:	fe 98 ff f8 	brls	800095f4 <_dtoa_r+0x304>
80009608:	6a 1b       	ld.w	r11,r5[0x4]
8000960a:	0e 9c       	mov	r12,r7
8000960c:	e0 a0 09 44 	rcall	8000a894 <_Balloc>
80009610:	58 e1       	cp.w	r1,14
80009612:	5f 88       	srls	r8
80009614:	8b 0c       	st.w	r5[0x0],r12
80009616:	f1 e4 00 04 	and	r4,r8,r4
8000961a:	6e 98       	ld.w	r8,r7[0x24]
8000961c:	70 08       	ld.w	r8,r8[0x0]
8000961e:	50 88       	stdsp	sp[0x20],r8
80009620:	e0 80 01 82 	breq	80009924 <_dtoa_r+0x634>
80009624:	58 06       	cp.w	r6,0
80009626:	e0 8a 00 43 	brle	800096ac <_dtoa_r+0x3bc>
8000962a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000962e:	fe c8 c5 d2 	sub	r8,pc,-14894
80009632:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009636:	fa e5 00 18 	st.d	sp[24],r4
8000963a:	ec 04 14 04 	asr	r4,r6,0x4
8000963e:	ed b4 00 04 	bld	r4,0x4
80009642:	c0 30       	breq	80009648 <_dtoa_r+0x358>
80009644:	30 25       	mov	r5,2
80009646:	c1 08       	rjmp	80009666 <_dtoa_r+0x376>
80009648:	fe c8 c5 24 	sub	r8,pc,-15068
8000964c:	f0 e8 00 20 	ld.d	r8,r8[32]
80009650:	fa ea 00 3c 	ld.d	r10,sp[60]
80009654:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009658:	e0 a0 0f ee 	rcall	8000b634 <__avr32_f64_div>
8000965c:	30 35       	mov	r5,3
8000965e:	14 98       	mov	r8,r10
80009660:	16 99       	mov	r9,r11
80009662:	fa e9 00 08 	st.d	sp[8],r8
80009666:	fe cc c5 42 	sub	r12,pc,-15038
8000966a:	50 a3       	stdsp	sp[0x28],r3
8000966c:	0c 93       	mov	r3,r6
8000966e:	18 96       	mov	r6,r12
80009670:	c0 f8       	rjmp	8000968e <_dtoa_r+0x39e>
80009672:	fa ea 00 18 	ld.d	r10,sp[24]
80009676:	ed b4 00 00 	bld	r4,0x0
8000967a:	c0 81       	brne	8000968a <_dtoa_r+0x39a>
8000967c:	ec e8 00 00 	ld.d	r8,r6[0]
80009680:	2f f5       	sub	r5,-1
80009682:	e0 a0 0c 93 	rcall	8000afa8 <__avr32_f64_mul>
80009686:	fa eb 00 18 	st.d	sp[24],r10
8000968a:	a1 54       	asr	r4,0x1
8000968c:	2f 86       	sub	r6,-8
8000968e:	58 04       	cp.w	r4,0
80009690:	cf 11       	brne	80009672 <_dtoa_r+0x382>
80009692:	fa e8 00 18 	ld.d	r8,sp[24]
80009696:	fa ea 00 08 	ld.d	r10,sp[8]
8000969a:	06 96       	mov	r6,r3
8000969c:	e0 a0 0f cc 	rcall	8000b634 <__avr32_f64_div>
800096a0:	40 a3       	lddsp	r3,sp[0x28]
800096a2:	14 98       	mov	r8,r10
800096a4:	16 99       	mov	r9,r11
800096a6:	fa e9 00 08 	st.d	sp[8],r8
800096aa:	c2 f8       	rjmp	80009708 <_dtoa_r+0x418>
800096ac:	ec 08 11 00 	rsub	r8,r6,0
800096b0:	c0 31       	brne	800096b6 <_dtoa_r+0x3c6>
800096b2:	30 25       	mov	r5,2
800096b4:	c2 a8       	rjmp	80009708 <_dtoa_r+0x418>
800096b6:	fe cc c5 92 	sub	r12,pc,-14958
800096ba:	f0 04 14 04 	asr	r4,r8,0x4
800096be:	50 1c       	stdsp	sp[0x4],r12
800096c0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800096c4:	fe c9 c6 68 	sub	r9,pc,-14744
800096c8:	fa ea 00 3c 	ld.d	r10,sp[60]
800096cc:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800096d0:	e0 a0 0c 6c 	rcall	8000afa8 <__avr32_f64_mul>
800096d4:	40 1c       	lddsp	r12,sp[0x4]
800096d6:	50 63       	stdsp	sp[0x18],r3
800096d8:	30 25       	mov	r5,2
800096da:	0c 93       	mov	r3,r6
800096dc:	fa eb 00 08 	st.d	sp[8],r10
800096e0:	18 96       	mov	r6,r12
800096e2:	c0 f8       	rjmp	80009700 <_dtoa_r+0x410>
800096e4:	fa ea 00 08 	ld.d	r10,sp[8]
800096e8:	ed b4 00 00 	bld	r4,0x0
800096ec:	c0 81       	brne	800096fc <_dtoa_r+0x40c>
800096ee:	ec e8 00 00 	ld.d	r8,r6[0]
800096f2:	2f f5       	sub	r5,-1
800096f4:	e0 a0 0c 5a 	rcall	8000afa8 <__avr32_f64_mul>
800096f8:	fa eb 00 08 	st.d	sp[8],r10
800096fc:	a1 54       	asr	r4,0x1
800096fe:	2f 86       	sub	r6,-8
80009700:	58 04       	cp.w	r4,0
80009702:	cf 11       	brne	800096e4 <_dtoa_r+0x3f4>
80009704:	06 96       	mov	r6,r3
80009706:	40 63       	lddsp	r3,sp[0x18]
80009708:	41 4a       	lddsp	r10,sp[0x50]
8000970a:	58 0a       	cp.w	r10,0
8000970c:	c2 a0       	breq	80009760 <_dtoa_r+0x470>
8000970e:	fa e8 00 08 	ld.d	r8,sp[8]
80009712:	58 01       	cp.w	r1,0
80009714:	5f 94       	srgt	r4
80009716:	fa e9 00 18 	st.d	sp[24],r8
8000971a:	30 08       	mov	r8,0
8000971c:	fc 19 3f f0 	movh	r9,0x3ff0
80009720:	fa ea 00 18 	ld.d	r10,sp[24]
80009724:	e0 a0 0f 54 	rcall	8000b5cc <__avr32_f64_cmp_lt>
80009728:	f9 bc 00 00 	moveq	r12,0
8000972c:	f9 bc 01 01 	movne	r12,1
80009730:	e9 ec 00 0c 	and	r12,r4,r12
80009734:	c1 60       	breq	80009760 <_dtoa_r+0x470>
80009736:	40 98       	lddsp	r8,sp[0x24]
80009738:	58 08       	cp.w	r8,0
8000973a:	e0 8a 00 f1 	brle	8000991c <_dtoa_r+0x62c>
8000973e:	30 08       	mov	r8,0
80009740:	fc 19 40 24 	movh	r9,0x4024
80009744:	ec c4 00 01 	sub	r4,r6,1
80009748:	fa ea 00 18 	ld.d	r10,sp[24]
8000974c:	2f f5       	sub	r5,-1
8000974e:	50 64       	stdsp	sp[0x18],r4
80009750:	e0 a0 0c 2c 	rcall	8000afa8 <__avr32_f64_mul>
80009754:	40 94       	lddsp	r4,sp[0x24]
80009756:	14 98       	mov	r8,r10
80009758:	16 99       	mov	r9,r11
8000975a:	fa e9 00 08 	st.d	sp[8],r8
8000975e:	c0 38       	rjmp	80009764 <_dtoa_r+0x474>
80009760:	50 66       	stdsp	sp[0x18],r6
80009762:	02 94       	mov	r4,r1
80009764:	0a 9c       	mov	r12,r5
80009766:	e0 a0 0e 7c 	rcall	8000b45e <__avr32_s32_to_f64>
8000976a:	fa e8 00 08 	ld.d	r8,sp[8]
8000976e:	e0 a0 0c 1d 	rcall	8000afa8 <__avr32_f64_mul>
80009772:	30 08       	mov	r8,0
80009774:	fc 19 40 1c 	movh	r9,0x401c
80009778:	e0 a0 0d d2 	rcall	8000b31c <__avr32_f64_add>
8000977c:	14 98       	mov	r8,r10
8000977e:	16 99       	mov	r9,r11
80009780:	fa e9 00 28 	st.d	sp[40],r8
80009784:	fc 18 fc c0 	movh	r8,0xfcc0
80009788:	40 a5       	lddsp	r5,sp[0x28]
8000978a:	10 05       	add	r5,r8
8000978c:	50 a5       	stdsp	sp[0x28],r5
8000978e:	58 04       	cp.w	r4,0
80009790:	c2 11       	brne	800097d2 <_dtoa_r+0x4e2>
80009792:	fa ea 00 08 	ld.d	r10,sp[8]
80009796:	30 08       	mov	r8,0
80009798:	fc 19 40 14 	movh	r9,0x4014
8000979c:	e0 a0 0c f2 	rcall	8000b180 <__avr32_f64_sub>
800097a0:	40 bc       	lddsp	r12,sp[0x2c]
800097a2:	fa eb 00 08 	st.d	sp[8],r10
800097a6:	14 98       	mov	r8,r10
800097a8:	16 99       	mov	r9,r11
800097aa:	18 9a       	mov	r10,r12
800097ac:	0a 9b       	mov	r11,r5
800097ae:	e0 a0 0f 0f 	rcall	8000b5cc <__avr32_f64_cmp_lt>
800097b2:	e0 81 02 54 	brne	80009c5a <_dtoa_r+0x96a>
800097b6:	0a 98       	mov	r8,r5
800097b8:	40 b9       	lddsp	r9,sp[0x2c]
800097ba:	ee 18 80 00 	eorh	r8,0x8000
800097be:	fa ea 00 08 	ld.d	r10,sp[8]
800097c2:	10 95       	mov	r5,r8
800097c4:	12 98       	mov	r8,r9
800097c6:	0a 99       	mov	r9,r5
800097c8:	e0 a0 0f 02 	rcall	8000b5cc <__avr32_f64_cmp_lt>
800097cc:	e0 81 02 3e 	brne	80009c48 <_dtoa_r+0x958>
800097d0:	ca 68       	rjmp	8000991c <_dtoa_r+0x62c>
800097d2:	fe c9 c7 76 	sub	r9,pc,-14474
800097d6:	e8 c8 00 01 	sub	r8,r4,1
800097da:	40 d5       	lddsp	r5,sp[0x34]
800097dc:	58 05       	cp.w	r5,0
800097de:	c4 f0       	breq	8000987c <_dtoa_r+0x58c>
800097e0:	30 0c       	mov	r12,0
800097e2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800097e6:	51 3c       	stdsp	sp[0x4c],r12
800097e8:	30 0a       	mov	r10,0
800097ea:	fc 1b 3f e0 	movh	r11,0x3fe0
800097ee:	e0 a0 0f 23 	rcall	8000b634 <__avr32_f64_div>
800097f2:	fa e8 00 28 	ld.d	r8,sp[40]
800097f6:	40 85       	lddsp	r5,sp[0x20]
800097f8:	e0 a0 0c c4 	rcall	8000b180 <__avr32_f64_sub>
800097fc:	fa eb 00 28 	st.d	sp[40],r10
80009800:	fa ea 00 08 	ld.d	r10,sp[8]
80009804:	e0 a0 0e 16 	rcall	8000b430 <__avr32_f64_to_s32>
80009808:	51 6c       	stdsp	sp[0x58],r12
8000980a:	e0 a0 0e 2a 	rcall	8000b45e <__avr32_s32_to_f64>
8000980e:	14 98       	mov	r8,r10
80009810:	16 99       	mov	r9,r11
80009812:	fa ea 00 08 	ld.d	r10,sp[8]
80009816:	e0 a0 0c b5 	rcall	8000b180 <__avr32_f64_sub>
8000981a:	fa eb 00 08 	st.d	sp[8],r10
8000981e:	41 68       	lddsp	r8,sp[0x58]
80009820:	2d 08       	sub	r8,-48
80009822:	0a c8       	st.b	r5++,r8
80009824:	41 39       	lddsp	r9,sp[0x4c]
80009826:	2f f9       	sub	r9,-1
80009828:	51 39       	stdsp	sp[0x4c],r9
8000982a:	fa e8 00 28 	ld.d	r8,sp[40]
8000982e:	e0 a0 0e cf 	rcall	8000b5cc <__avr32_f64_cmp_lt>
80009832:	e0 81 03 39 	brne	80009ea4 <_dtoa_r+0xbb4>
80009836:	fa e8 00 08 	ld.d	r8,sp[8]
8000983a:	30 0a       	mov	r10,0
8000983c:	fc 1b 3f f0 	movh	r11,0x3ff0
80009840:	e0 a0 0c a0 	rcall	8000b180 <__avr32_f64_sub>
80009844:	fa e8 00 28 	ld.d	r8,sp[40]
80009848:	e0 a0 0e c2 	rcall	8000b5cc <__avr32_f64_cmp_lt>
8000984c:	fa ea 00 28 	ld.d	r10,sp[40]
80009850:	30 08       	mov	r8,0
80009852:	fc 19 40 24 	movh	r9,0x4024
80009856:	e0 81 00 da 	brne	80009a0a <_dtoa_r+0x71a>
8000985a:	41 3c       	lddsp	r12,sp[0x4c]
8000985c:	08 3c       	cp.w	r12,r4
8000985e:	c5 f4       	brge	8000991c <_dtoa_r+0x62c>
80009860:	e0 a0 0b a4 	rcall	8000afa8 <__avr32_f64_mul>
80009864:	30 08       	mov	r8,0
80009866:	fa eb 00 28 	st.d	sp[40],r10
8000986a:	fc 19 40 24 	movh	r9,0x4024
8000986e:	fa ea 00 08 	ld.d	r10,sp[8]
80009872:	e0 a0 0b 9b 	rcall	8000afa8 <__avr32_f64_mul>
80009876:	fa eb 00 08 	st.d	sp[8],r10
8000987a:	cc 3b       	rjmp	80009800 <_dtoa_r+0x510>
8000987c:	40 85       	lddsp	r5,sp[0x20]
8000987e:	08 05       	add	r5,r4
80009880:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009884:	51 35       	stdsp	sp[0x4c],r5
80009886:	fa e8 00 28 	ld.d	r8,sp[40]
8000988a:	40 85       	lddsp	r5,sp[0x20]
8000988c:	e0 a0 0b 8e 	rcall	8000afa8 <__avr32_f64_mul>
80009890:	fa eb 00 28 	st.d	sp[40],r10
80009894:	fa ea 00 08 	ld.d	r10,sp[8]
80009898:	e0 a0 0d cc 	rcall	8000b430 <__avr32_f64_to_s32>
8000989c:	51 6c       	stdsp	sp[0x58],r12
8000989e:	e0 a0 0d e0 	rcall	8000b45e <__avr32_s32_to_f64>
800098a2:	14 98       	mov	r8,r10
800098a4:	16 99       	mov	r9,r11
800098a6:	fa ea 00 08 	ld.d	r10,sp[8]
800098aa:	e0 a0 0c 6b 	rcall	8000b180 <__avr32_f64_sub>
800098ae:	fa eb 00 08 	st.d	sp[8],r10
800098b2:	41 68       	lddsp	r8,sp[0x58]
800098b4:	2d 08       	sub	r8,-48
800098b6:	0a c8       	st.b	r5++,r8
800098b8:	41 3c       	lddsp	r12,sp[0x4c]
800098ba:	18 35       	cp.w	r5,r12
800098bc:	c2 81       	brne	8000990c <_dtoa_r+0x61c>
800098be:	30 08       	mov	r8,0
800098c0:	fc 19 3f e0 	movh	r9,0x3fe0
800098c4:	fa ea 00 28 	ld.d	r10,sp[40]
800098c8:	e0 a0 0d 2a 	rcall	8000b31c <__avr32_f64_add>
800098cc:	40 85       	lddsp	r5,sp[0x20]
800098ce:	fa e8 00 08 	ld.d	r8,sp[8]
800098d2:	08 05       	add	r5,r4
800098d4:	e0 a0 0e 7c 	rcall	8000b5cc <__avr32_f64_cmp_lt>
800098d8:	e0 81 00 99 	brne	80009a0a <_dtoa_r+0x71a>
800098dc:	fa e8 00 28 	ld.d	r8,sp[40]
800098e0:	30 0a       	mov	r10,0
800098e2:	fc 1b 3f e0 	movh	r11,0x3fe0
800098e6:	e0 a0 0c 4d 	rcall	8000b180 <__avr32_f64_sub>
800098ea:	14 98       	mov	r8,r10
800098ec:	16 99       	mov	r9,r11
800098ee:	fa ea 00 08 	ld.d	r10,sp[8]
800098f2:	e0 a0 0e 6d 	rcall	8000b5cc <__avr32_f64_cmp_lt>
800098f6:	c1 30       	breq	8000991c <_dtoa_r+0x62c>
800098f8:	33 09       	mov	r9,48
800098fa:	0a 98       	mov	r8,r5
800098fc:	11 7a       	ld.ub	r10,--r8
800098fe:	f2 0a 18 00 	cp.b	r10,r9
80009902:	e0 81 02 d1 	brne	80009ea4 <_dtoa_r+0xbb4>
80009906:	10 95       	mov	r5,r8
80009908:	cf 9b       	rjmp	800098fa <_dtoa_r+0x60a>
8000990a:	d7 03       	nop
8000990c:	30 08       	mov	r8,0
8000990e:	fc 19 40 24 	movh	r9,0x4024
80009912:	e0 a0 0b 4b 	rcall	8000afa8 <__avr32_f64_mul>
80009916:	fa eb 00 08 	st.d	sp[8],r10
8000991a:	cb db       	rjmp	80009894 <_dtoa_r+0x5a4>
8000991c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009920:	fa eb 00 08 	st.d	sp[8],r10
80009924:	58 e6       	cp.w	r6,14
80009926:	5f ab       	srle	r11
80009928:	41 8a       	lddsp	r10,sp[0x60]
8000992a:	30 08       	mov	r8,0
8000992c:	f4 09 11 ff 	rsub	r9,r10,-1
80009930:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009934:	f0 09 18 00 	cp.b	r9,r8
80009938:	e0 80 00 82 	breq	80009a3c <_dtoa_r+0x74c>
8000993c:	40 ea       	lddsp	r10,sp[0x38]
8000993e:	58 01       	cp.w	r1,0
80009940:	5f a9       	srle	r9
80009942:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009946:	fe ca c8 ea 	sub	r10,pc,-14102
8000994a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000994e:	fa e5 00 10 	st.d	sp[16],r4
80009952:	f0 09 18 00 	cp.b	r9,r8
80009956:	c1 40       	breq	8000997e <_dtoa_r+0x68e>
80009958:	58 01       	cp.w	r1,0
8000995a:	e0 81 01 77 	brne	80009c48 <_dtoa_r+0x958>
8000995e:	30 08       	mov	r8,0
80009960:	fc 19 40 14 	movh	r9,0x4014
80009964:	08 9a       	mov	r10,r4
80009966:	0a 9b       	mov	r11,r5
80009968:	e0 a0 0b 20 	rcall	8000afa8 <__avr32_f64_mul>
8000996c:	fa e8 00 08 	ld.d	r8,sp[8]
80009970:	e0 a0 0d fa 	rcall	8000b564 <__avr32_f64_cmp_ge>
80009974:	e0 81 01 6a 	brne	80009c48 <_dtoa_r+0x958>
80009978:	02 92       	mov	r2,r1
8000997a:	e0 8f 01 72 	bral	80009c5e <_dtoa_r+0x96e>
8000997e:	40 85       	lddsp	r5,sp[0x20]
80009980:	30 14       	mov	r4,1
80009982:	fa e8 00 10 	ld.d	r8,sp[16]
80009986:	fa ea 00 08 	ld.d	r10,sp[8]
8000998a:	e0 a0 0e 55 	rcall	8000b634 <__avr32_f64_div>
8000998e:	e0 a0 0d 51 	rcall	8000b430 <__avr32_f64_to_s32>
80009992:	18 92       	mov	r2,r12
80009994:	e0 a0 0d 65 	rcall	8000b45e <__avr32_s32_to_f64>
80009998:	fa e8 00 10 	ld.d	r8,sp[16]
8000999c:	e0 a0 0b 06 	rcall	8000afa8 <__avr32_f64_mul>
800099a0:	14 98       	mov	r8,r10
800099a2:	16 99       	mov	r9,r11
800099a4:	fa ea 00 08 	ld.d	r10,sp[8]
800099a8:	e0 a0 0b ec 	rcall	8000b180 <__avr32_f64_sub>
800099ac:	fa eb 00 08 	st.d	sp[8],r10
800099b0:	e4 c8 ff d0 	sub	r8,r2,-48
800099b4:	0a c8       	st.b	r5++,r8
800099b6:	fc 19 40 24 	movh	r9,0x4024
800099ba:	30 08       	mov	r8,0
800099bc:	02 34       	cp.w	r4,r1
800099be:	c3 31       	brne	80009a24 <_dtoa_r+0x734>
800099c0:	fa e8 00 08 	ld.d	r8,sp[8]
800099c4:	e0 a0 0c ac 	rcall	8000b31c <__avr32_f64_add>
800099c8:	16 91       	mov	r1,r11
800099ca:	14 90       	mov	r0,r10
800099cc:	14 98       	mov	r8,r10
800099ce:	02 99       	mov	r9,r1
800099d0:	fa ea 00 10 	ld.d	r10,sp[16]
800099d4:	e0 a0 0d fc 	rcall	8000b5cc <__avr32_f64_cmp_lt>
800099d8:	c1 a1       	brne	80009a0c <_dtoa_r+0x71c>
800099da:	fa e8 00 10 	ld.d	r8,sp[16]
800099de:	00 9a       	mov	r10,r0
800099e0:	02 9b       	mov	r11,r1
800099e2:	e0 a0 0d ae 	rcall	8000b53e <__avr32_f64_cmp_eq>
800099e6:	e0 80 02 5e 	breq	80009ea2 <_dtoa_r+0xbb2>
800099ea:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
800099ee:	c0 f1       	brne	80009a0c <_dtoa_r+0x71c>
800099f0:	e0 8f 02 59 	bral	80009ea2 <_dtoa_r+0xbb2>
800099f4:	40 8a       	lddsp	r10,sp[0x20]
800099f6:	14 38       	cp.w	r8,r10
800099f8:	c0 30       	breq	800099fe <_dtoa_r+0x70e>
800099fa:	10 95       	mov	r5,r8
800099fc:	c0 98       	rjmp	80009a0e <_dtoa_r+0x71e>
800099fe:	33 08       	mov	r8,48
80009a00:	40 89       	lddsp	r9,sp[0x20]
80009a02:	2f f6       	sub	r6,-1
80009a04:	b2 88       	st.b	r9[0x0],r8
80009a06:	40 88       	lddsp	r8,sp[0x20]
80009a08:	c0 88       	rjmp	80009a18 <_dtoa_r+0x728>
80009a0a:	40 66       	lddsp	r6,sp[0x18]
80009a0c:	33 99       	mov	r9,57
80009a0e:	0a 98       	mov	r8,r5
80009a10:	11 7a       	ld.ub	r10,--r8
80009a12:	f2 0a 18 00 	cp.b	r10,r9
80009a16:	ce f0       	breq	800099f4 <_dtoa_r+0x704>
80009a18:	50 66       	stdsp	sp[0x18],r6
80009a1a:	11 89       	ld.ub	r9,r8[0x0]
80009a1c:	2f f9       	sub	r9,-1
80009a1e:	b0 89       	st.b	r8[0x0],r9
80009a20:	e0 8f 02 42 	bral	80009ea4 <_dtoa_r+0xbb4>
80009a24:	e0 a0 0a c2 	rcall	8000afa8 <__avr32_f64_mul>
80009a28:	2f f4       	sub	r4,-1
80009a2a:	fa eb 00 08 	st.d	sp[8],r10
80009a2e:	30 08       	mov	r8,0
80009a30:	30 09       	mov	r9,0
80009a32:	e0 a0 0d 86 	rcall	8000b53e <__avr32_f64_cmp_eq>
80009a36:	ca 60       	breq	80009982 <_dtoa_r+0x692>
80009a38:	e0 8f 02 35 	bral	80009ea2 <_dtoa_r+0xbb2>
80009a3c:	40 d8       	lddsp	r8,sp[0x34]
80009a3e:	58 08       	cp.w	r8,0
80009a40:	c0 51       	brne	80009a4a <_dtoa_r+0x75a>
80009a42:	04 98       	mov	r8,r2
80009a44:	00 95       	mov	r5,r0
80009a46:	40 d4       	lddsp	r4,sp[0x34]
80009a48:	c3 78       	rjmp	80009ab6 <_dtoa_r+0x7c6>
80009a4a:	40 c5       	lddsp	r5,sp[0x30]
80009a4c:	58 15       	cp.w	r5,1
80009a4e:	e0 89 00 0f 	brgt	80009a6c <_dtoa_r+0x77c>
80009a52:	41 74       	lddsp	r4,sp[0x5c]
80009a54:	58 04       	cp.w	r4,0
80009a56:	c0 40       	breq	80009a5e <_dtoa_r+0x76e>
80009a58:	f4 c9 fb cd 	sub	r9,r10,-1075
80009a5c:	c0 48       	rjmp	80009a64 <_dtoa_r+0x774>
80009a5e:	41 99       	lddsp	r9,sp[0x64]
80009a60:	f2 09 11 36 	rsub	r9,r9,54
80009a64:	04 98       	mov	r8,r2
80009a66:	00 95       	mov	r5,r0
80009a68:	c1 c8       	rjmp	80009aa0 <_dtoa_r+0x7b0>
80009a6a:	d7 03       	nop
80009a6c:	e2 c8 00 01 	sub	r8,r1,1
80009a70:	58 01       	cp.w	r1,0
80009a72:	e0 05 17 40 	movge	r5,r0
80009a76:	e2 09 17 40 	movge	r9,r1
80009a7a:	e1 d1 e5 15 	sublt	r5,r0,r1
80009a7e:	f9 b9 05 00 	movlt	r9,0
80009a82:	10 32       	cp.w	r2,r8
80009a84:	e5 d8 e4 18 	subge	r8,r2,r8
80009a88:	f1 d2 e5 18 	sublt	r8,r8,r2
80009a8c:	e5 d8 e5 02 	addlt	r2,r2,r8
80009a90:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009a94:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009a98:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009a9c:	f9 b8 05 00 	movlt	r8,0
80009aa0:	40 4b       	lddsp	r11,sp[0x10]
80009aa2:	12 0b       	add	r11,r9
80009aa4:	50 08       	stdsp	sp[0x0],r8
80009aa6:	50 4b       	stdsp	sp[0x10],r11
80009aa8:	12 00       	add	r0,r9
80009aaa:	30 1b       	mov	r11,1
80009aac:	0e 9c       	mov	r12,r7
80009aae:	e0 a0 08 a7 	rcall	8000abfc <__i2b>
80009ab2:	40 08       	lddsp	r8,sp[0x0]
80009ab4:	18 94       	mov	r4,r12
80009ab6:	40 4a       	lddsp	r10,sp[0x10]
80009ab8:	58 05       	cp.w	r5,0
80009aba:	5f 99       	srgt	r9
80009abc:	58 0a       	cp.w	r10,0
80009abe:	5f 9a       	srgt	r10
80009ac0:	f5 e9 00 09 	and	r9,r10,r9
80009ac4:	c0 80       	breq	80009ad4 <_dtoa_r+0x7e4>
80009ac6:	40 4c       	lddsp	r12,sp[0x10]
80009ac8:	f8 05 0d 49 	min	r9,r12,r5
80009acc:	12 1c       	sub	r12,r9
80009ace:	12 10       	sub	r0,r9
80009ad0:	50 4c       	stdsp	sp[0x10],r12
80009ad2:	12 15       	sub	r5,r9
80009ad4:	58 02       	cp.w	r2,0
80009ad6:	e0 8a 00 27 	brle	80009b24 <_dtoa_r+0x834>
80009ada:	40 db       	lddsp	r11,sp[0x34]
80009adc:	58 0b       	cp.w	r11,0
80009ade:	c1 d0       	breq	80009b18 <_dtoa_r+0x828>
80009ae0:	58 08       	cp.w	r8,0
80009ae2:	e0 8a 00 17 	brle	80009b10 <_dtoa_r+0x820>
80009ae6:	10 9a       	mov	r10,r8
80009ae8:	50 08       	stdsp	sp[0x0],r8
80009aea:	08 9b       	mov	r11,r4
80009aec:	0e 9c       	mov	r12,r7
80009aee:	e0 a0 08 cd 	rcall	8000ac88 <__pow5mult>
80009af2:	06 9a       	mov	r10,r3
80009af4:	18 9b       	mov	r11,r12
80009af6:	18 94       	mov	r4,r12
80009af8:	0e 9c       	mov	r12,r7
80009afa:	e0 a0 08 01 	rcall	8000aafc <__multiply>
80009afe:	18 99       	mov	r9,r12
80009b00:	06 9b       	mov	r11,r3
80009b02:	50 19       	stdsp	sp[0x4],r9
80009b04:	0e 9c       	mov	r12,r7
80009b06:	e0 a0 06 ad 	rcall	8000a860 <_Bfree>
80009b0a:	40 19       	lddsp	r9,sp[0x4]
80009b0c:	40 08       	lddsp	r8,sp[0x0]
80009b0e:	12 93       	mov	r3,r9
80009b10:	e4 08 01 0a 	sub	r10,r2,r8
80009b14:	c0 80       	breq	80009b24 <_dtoa_r+0x834>
80009b16:	c0 28       	rjmp	80009b1a <_dtoa_r+0x82a>
80009b18:	04 9a       	mov	r10,r2
80009b1a:	06 9b       	mov	r11,r3
80009b1c:	0e 9c       	mov	r12,r7
80009b1e:	e0 a0 08 b5 	rcall	8000ac88 <__pow5mult>
80009b22:	18 93       	mov	r3,r12
80009b24:	30 1b       	mov	r11,1
80009b26:	0e 9c       	mov	r12,r7
80009b28:	e0 a0 08 6a 	rcall	8000abfc <__i2b>
80009b2c:	41 1a       	lddsp	r10,sp[0x44]
80009b2e:	18 92       	mov	r2,r12
80009b30:	58 0a       	cp.w	r10,0
80009b32:	e0 8a 00 07 	brle	80009b40 <_dtoa_r+0x850>
80009b36:	18 9b       	mov	r11,r12
80009b38:	0e 9c       	mov	r12,r7
80009b3a:	e0 a0 08 a7 	rcall	8000ac88 <__pow5mult>
80009b3e:	18 92       	mov	r2,r12
80009b40:	40 c9       	lddsp	r9,sp[0x30]
80009b42:	58 19       	cp.w	r9,1
80009b44:	e0 89 00 14 	brgt	80009b6c <_dtoa_r+0x87c>
80009b48:	40 38       	lddsp	r8,sp[0xc]
80009b4a:	58 08       	cp.w	r8,0
80009b4c:	c1 01       	brne	80009b6c <_dtoa_r+0x87c>
80009b4e:	40 29       	lddsp	r9,sp[0x8]
80009b50:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009b54:	c0 c1       	brne	80009b6c <_dtoa_r+0x87c>
80009b56:	12 98       	mov	r8,r9
80009b58:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009b5c:	c0 80       	breq	80009b6c <_dtoa_r+0x87c>
80009b5e:	40 4c       	lddsp	r12,sp[0x10]
80009b60:	30 1b       	mov	r11,1
80009b62:	2f fc       	sub	r12,-1
80009b64:	2f f0       	sub	r0,-1
80009b66:	50 4c       	stdsp	sp[0x10],r12
80009b68:	50 6b       	stdsp	sp[0x18],r11
80009b6a:	c0 38       	rjmp	80009b70 <_dtoa_r+0x880>
80009b6c:	30 0a       	mov	r10,0
80009b6e:	50 6a       	stdsp	sp[0x18],r10
80009b70:	41 19       	lddsp	r9,sp[0x44]
80009b72:	58 09       	cp.w	r9,0
80009b74:	c0 31       	brne	80009b7a <_dtoa_r+0x88a>
80009b76:	30 1c       	mov	r12,1
80009b78:	c0 98       	rjmp	80009b8a <_dtoa_r+0x89a>
80009b7a:	64 48       	ld.w	r8,r2[0x10]
80009b7c:	2f c8       	sub	r8,-4
80009b7e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009b82:	e0 a0 05 df 	rcall	8000a740 <__hi0bits>
80009b86:	f8 0c 11 20 	rsub	r12,r12,32
80009b8a:	40 4b       	lddsp	r11,sp[0x10]
80009b8c:	f8 0b 00 08 	add	r8,r12,r11
80009b90:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009b94:	c0 c0       	breq	80009bac <_dtoa_r+0x8bc>
80009b96:	f0 08 11 20 	rsub	r8,r8,32
80009b9a:	58 48       	cp.w	r8,4
80009b9c:	e0 8a 00 06 	brle	80009ba8 <_dtoa_r+0x8b8>
80009ba0:	20 48       	sub	r8,4
80009ba2:	10 0b       	add	r11,r8
80009ba4:	50 4b       	stdsp	sp[0x10],r11
80009ba6:	c0 78       	rjmp	80009bb4 <_dtoa_r+0x8c4>
80009ba8:	58 48       	cp.w	r8,4
80009baa:	c0 70       	breq	80009bb8 <_dtoa_r+0x8c8>
80009bac:	40 4a       	lddsp	r10,sp[0x10]
80009bae:	2e 48       	sub	r8,-28
80009bb0:	10 0a       	add	r10,r8
80009bb2:	50 4a       	stdsp	sp[0x10],r10
80009bb4:	10 00       	add	r0,r8
80009bb6:	10 05       	add	r5,r8
80009bb8:	58 00       	cp.w	r0,0
80009bba:	e0 8a 00 08 	brle	80009bca <_dtoa_r+0x8da>
80009bbe:	06 9b       	mov	r11,r3
80009bc0:	00 9a       	mov	r10,r0
80009bc2:	0e 9c       	mov	r12,r7
80009bc4:	e0 a0 07 58 	rcall	8000aa74 <__lshift>
80009bc8:	18 93       	mov	r3,r12
80009bca:	40 49       	lddsp	r9,sp[0x10]
80009bcc:	58 09       	cp.w	r9,0
80009bce:	e0 8a 00 08 	brle	80009bde <_dtoa_r+0x8ee>
80009bd2:	04 9b       	mov	r11,r2
80009bd4:	12 9a       	mov	r10,r9
80009bd6:	0e 9c       	mov	r12,r7
80009bd8:	e0 a0 07 4e 	rcall	8000aa74 <__lshift>
80009bdc:	18 92       	mov	r2,r12
80009bde:	41 48       	lddsp	r8,sp[0x50]
80009be0:	58 08       	cp.w	r8,0
80009be2:	c1 b0       	breq	80009c18 <_dtoa_r+0x928>
80009be4:	04 9b       	mov	r11,r2
80009be6:	06 9c       	mov	r12,r3
80009be8:	e0 a0 06 23 	rcall	8000a82e <__mcmp>
80009bec:	c1 64       	brge	80009c18 <_dtoa_r+0x928>
80009bee:	06 9b       	mov	r11,r3
80009bf0:	30 09       	mov	r9,0
80009bf2:	30 aa       	mov	r10,10
80009bf4:	0e 9c       	mov	r12,r7
80009bf6:	e0 a0 08 0b 	rcall	8000ac0c <__multadd>
80009bfa:	20 16       	sub	r6,1
80009bfc:	18 93       	mov	r3,r12
80009bfe:	40 dc       	lddsp	r12,sp[0x34]
80009c00:	58 0c       	cp.w	r12,0
80009c02:	c0 31       	brne	80009c08 <_dtoa_r+0x918>
80009c04:	40 91       	lddsp	r1,sp[0x24]
80009c06:	c0 98       	rjmp	80009c18 <_dtoa_r+0x928>
80009c08:	08 9b       	mov	r11,r4
80009c0a:	40 91       	lddsp	r1,sp[0x24]
80009c0c:	30 09       	mov	r9,0
80009c0e:	30 aa       	mov	r10,10
80009c10:	0e 9c       	mov	r12,r7
80009c12:	e0 a0 07 fd 	rcall	8000ac0c <__multadd>
80009c16:	18 94       	mov	r4,r12
80009c18:	58 01       	cp.w	r1,0
80009c1a:	5f a9       	srle	r9
80009c1c:	40 cb       	lddsp	r11,sp[0x30]
80009c1e:	58 2b       	cp.w	r11,2
80009c20:	5f 98       	srgt	r8
80009c22:	f3 e8 00 08 	and	r8,r9,r8
80009c26:	c2 50       	breq	80009c70 <_dtoa_r+0x980>
80009c28:	58 01       	cp.w	r1,0
80009c2a:	c1 11       	brne	80009c4c <_dtoa_r+0x95c>
80009c2c:	04 9b       	mov	r11,r2
80009c2e:	02 99       	mov	r9,r1
80009c30:	30 5a       	mov	r10,5
80009c32:	0e 9c       	mov	r12,r7
80009c34:	e0 a0 07 ec 	rcall	8000ac0c <__multadd>
80009c38:	18 92       	mov	r2,r12
80009c3a:	18 9b       	mov	r11,r12
80009c3c:	06 9c       	mov	r12,r3
80009c3e:	e0 a0 05 f8 	rcall	8000a82e <__mcmp>
80009c42:	e0 89 00 0f 	brgt	80009c60 <_dtoa_r+0x970>
80009c46:	c0 38       	rjmp	80009c4c <_dtoa_r+0x95c>
80009c48:	30 02       	mov	r2,0
80009c4a:	04 94       	mov	r4,r2
80009c4c:	40 ea       	lddsp	r10,sp[0x38]
80009c4e:	30 09       	mov	r9,0
80009c50:	5c da       	com	r10
80009c52:	40 85       	lddsp	r5,sp[0x20]
80009c54:	50 6a       	stdsp	sp[0x18],r10
80009c56:	50 49       	stdsp	sp[0x10],r9
80009c58:	c0 f9       	rjmp	80009e76 <_dtoa_r+0xb86>
80009c5a:	08 92       	mov	r2,r4
80009c5c:	40 66       	lddsp	r6,sp[0x18]
80009c5e:	04 94       	mov	r4,r2
80009c60:	2f f6       	sub	r6,-1
80009c62:	50 66       	stdsp	sp[0x18],r6
80009c64:	33 18       	mov	r8,49
80009c66:	40 85       	lddsp	r5,sp[0x20]
80009c68:	0a c8       	st.b	r5++,r8
80009c6a:	30 08       	mov	r8,0
80009c6c:	50 48       	stdsp	sp[0x10],r8
80009c6e:	c0 49       	rjmp	80009e76 <_dtoa_r+0xb86>
80009c70:	40 dc       	lddsp	r12,sp[0x34]
80009c72:	58 0c       	cp.w	r12,0
80009c74:	e0 80 00 b5 	breq	80009dde <_dtoa_r+0xaee>
80009c78:	58 05       	cp.w	r5,0
80009c7a:	e0 8a 00 08 	brle	80009c8a <_dtoa_r+0x99a>
80009c7e:	08 9b       	mov	r11,r4
80009c80:	0a 9a       	mov	r10,r5
80009c82:	0e 9c       	mov	r12,r7
80009c84:	e0 a0 06 f8 	rcall	8000aa74 <__lshift>
80009c88:	18 94       	mov	r4,r12
80009c8a:	40 6b       	lddsp	r11,sp[0x18]
80009c8c:	58 0b       	cp.w	r11,0
80009c8e:	c0 31       	brne	80009c94 <_dtoa_r+0x9a4>
80009c90:	08 9c       	mov	r12,r4
80009c92:	c1 38       	rjmp	80009cb8 <_dtoa_r+0x9c8>
80009c94:	68 1b       	ld.w	r11,r4[0x4]
80009c96:	0e 9c       	mov	r12,r7
80009c98:	e0 a0 05 fe 	rcall	8000a894 <_Balloc>
80009c9c:	68 4a       	ld.w	r10,r4[0x10]
80009c9e:	18 95       	mov	r5,r12
80009ca0:	e8 cb ff f4 	sub	r11,r4,-12
80009ca4:	2f ea       	sub	r10,-2
80009ca6:	2f 4c       	sub	r12,-12
80009ca8:	a3 6a       	lsl	r10,0x2
80009caa:	fe b0 e6 43 	rcall	80006930 <memcpy>
80009cae:	0a 9b       	mov	r11,r5
80009cb0:	30 1a       	mov	r10,1
80009cb2:	0e 9c       	mov	r12,r7
80009cb4:	e0 a0 06 e0 	rcall	8000aa74 <__lshift>
80009cb8:	50 44       	stdsp	sp[0x10],r4
80009cba:	40 3a       	lddsp	r10,sp[0xc]
80009cbc:	30 19       	mov	r9,1
80009cbe:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009cc2:	18 94       	mov	r4,r12
80009cc4:	50 da       	stdsp	sp[0x34],r10
80009cc6:	40 85       	lddsp	r5,sp[0x20]
80009cc8:	50 99       	stdsp	sp[0x24],r9
80009cca:	50 26       	stdsp	sp[0x8],r6
80009ccc:	50 e1       	stdsp	sp[0x38],r1
80009cce:	04 9b       	mov	r11,r2
80009cd0:	06 9c       	mov	r12,r3
80009cd2:	fe b0 fa 7f 	rcall	800091d0 <quorem>
80009cd6:	40 4b       	lddsp	r11,sp[0x10]
80009cd8:	f8 c0 ff d0 	sub	r0,r12,-48
80009cdc:	06 9c       	mov	r12,r3
80009cde:	e0 a0 05 a8 	rcall	8000a82e <__mcmp>
80009ce2:	08 9a       	mov	r10,r4
80009ce4:	50 6c       	stdsp	sp[0x18],r12
80009ce6:	04 9b       	mov	r11,r2
80009ce8:	0e 9c       	mov	r12,r7
80009cea:	e0 a0 06 5d 	rcall	8000a9a4 <__mdiff>
80009cee:	18 91       	mov	r1,r12
80009cf0:	78 38       	ld.w	r8,r12[0xc]
80009cf2:	58 08       	cp.w	r8,0
80009cf4:	c0 30       	breq	80009cfa <_dtoa_r+0xa0a>
80009cf6:	30 16       	mov	r6,1
80009cf8:	c0 68       	rjmp	80009d04 <_dtoa_r+0xa14>
80009cfa:	18 9b       	mov	r11,r12
80009cfc:	06 9c       	mov	r12,r3
80009cfe:	e0 a0 05 98 	rcall	8000a82e <__mcmp>
80009d02:	18 96       	mov	r6,r12
80009d04:	0e 9c       	mov	r12,r7
80009d06:	02 9b       	mov	r11,r1
80009d08:	e0 a0 05 ac 	rcall	8000a860 <_Bfree>
80009d0c:	40 cc       	lddsp	r12,sp[0x30]
80009d0e:	ed ec 10 08 	or	r8,r6,r12
80009d12:	c0 d1       	brne	80009d2c <_dtoa_r+0xa3c>
80009d14:	40 db       	lddsp	r11,sp[0x34]
80009d16:	58 0b       	cp.w	r11,0
80009d18:	c0 a1       	brne	80009d2c <_dtoa_r+0xa3c>
80009d1a:	40 26       	lddsp	r6,sp[0x8]
80009d1c:	e0 40 00 39 	cp.w	r0,57
80009d20:	c3 00       	breq	80009d80 <_dtoa_r+0xa90>
80009d22:	40 6a       	lddsp	r10,sp[0x18]
80009d24:	58 0a       	cp.w	r10,0
80009d26:	e0 89 00 24 	brgt	80009d6e <_dtoa_r+0xa7e>
80009d2a:	c2 f8       	rjmp	80009d88 <_dtoa_r+0xa98>
80009d2c:	40 69       	lddsp	r9,sp[0x18]
80009d2e:	58 09       	cp.w	r9,0
80009d30:	c0 85       	brlt	80009d40 <_dtoa_r+0xa50>
80009d32:	12 98       	mov	r8,r9
80009d34:	40 cc       	lddsp	r12,sp[0x30]
80009d36:	18 48       	or	r8,r12
80009d38:	c1 d1       	brne	80009d72 <_dtoa_r+0xa82>
80009d3a:	40 db       	lddsp	r11,sp[0x34]
80009d3c:	58 0b       	cp.w	r11,0
80009d3e:	c1 a1       	brne	80009d72 <_dtoa_r+0xa82>
80009d40:	0c 99       	mov	r9,r6
80009d42:	40 26       	lddsp	r6,sp[0x8]
80009d44:	58 09       	cp.w	r9,0
80009d46:	e0 8a 00 21 	brle	80009d88 <_dtoa_r+0xa98>
80009d4a:	06 9b       	mov	r11,r3
80009d4c:	30 1a       	mov	r10,1
80009d4e:	0e 9c       	mov	r12,r7
80009d50:	e0 a0 06 92 	rcall	8000aa74 <__lshift>
80009d54:	04 9b       	mov	r11,r2
80009d56:	18 93       	mov	r3,r12
80009d58:	e0 a0 05 6b 	rcall	8000a82e <__mcmp>
80009d5c:	e0 89 00 06 	brgt	80009d68 <_dtoa_r+0xa78>
80009d60:	c1 41       	brne	80009d88 <_dtoa_r+0xa98>
80009d62:	ed b0 00 00 	bld	r0,0x0
80009d66:	c1 11       	brne	80009d88 <_dtoa_r+0xa98>
80009d68:	e0 40 00 39 	cp.w	r0,57
80009d6c:	c0 a0       	breq	80009d80 <_dtoa_r+0xa90>
80009d6e:	2f f0       	sub	r0,-1
80009d70:	c0 c8       	rjmp	80009d88 <_dtoa_r+0xa98>
80009d72:	58 06       	cp.w	r6,0
80009d74:	e0 8a 00 0c 	brle	80009d8c <_dtoa_r+0xa9c>
80009d78:	40 26       	lddsp	r6,sp[0x8]
80009d7a:	e0 40 00 39 	cp.w	r0,57
80009d7e:	c0 41       	brne	80009d86 <_dtoa_r+0xa96>
80009d80:	33 98       	mov	r8,57
80009d82:	0a c8       	st.b	r5++,r8
80009d84:	c6 78       	rjmp	80009e52 <_dtoa_r+0xb62>
80009d86:	2f f0       	sub	r0,-1
80009d88:	0a c0       	st.b	r5++,r0
80009d8a:	c7 58       	rjmp	80009e74 <_dtoa_r+0xb84>
80009d8c:	0a c0       	st.b	r5++,r0
80009d8e:	40 9a       	lddsp	r10,sp[0x24]
80009d90:	40 e9       	lddsp	r9,sp[0x38]
80009d92:	12 3a       	cp.w	r10,r9
80009d94:	c4 30       	breq	80009e1a <_dtoa_r+0xb2a>
80009d96:	06 9b       	mov	r11,r3
80009d98:	30 09       	mov	r9,0
80009d9a:	30 aa       	mov	r10,10
80009d9c:	0e 9c       	mov	r12,r7
80009d9e:	e0 a0 07 37 	rcall	8000ac0c <__multadd>
80009da2:	40 48       	lddsp	r8,sp[0x10]
80009da4:	18 93       	mov	r3,r12
80009da6:	08 38       	cp.w	r8,r4
80009da8:	c0 91       	brne	80009dba <_dtoa_r+0xaca>
80009daa:	10 9b       	mov	r11,r8
80009dac:	30 09       	mov	r9,0
80009dae:	30 aa       	mov	r10,10
80009db0:	0e 9c       	mov	r12,r7
80009db2:	e0 a0 07 2d 	rcall	8000ac0c <__multadd>
80009db6:	50 4c       	stdsp	sp[0x10],r12
80009db8:	c0 e8       	rjmp	80009dd4 <_dtoa_r+0xae4>
80009dba:	40 4b       	lddsp	r11,sp[0x10]
80009dbc:	30 09       	mov	r9,0
80009dbe:	30 aa       	mov	r10,10
80009dc0:	0e 9c       	mov	r12,r7
80009dc2:	e0 a0 07 25 	rcall	8000ac0c <__multadd>
80009dc6:	08 9b       	mov	r11,r4
80009dc8:	50 4c       	stdsp	sp[0x10],r12
80009dca:	30 09       	mov	r9,0
80009dcc:	30 aa       	mov	r10,10
80009dce:	0e 9c       	mov	r12,r7
80009dd0:	e0 a0 07 1e 	rcall	8000ac0c <__multadd>
80009dd4:	18 94       	mov	r4,r12
80009dd6:	40 9c       	lddsp	r12,sp[0x24]
80009dd8:	2f fc       	sub	r12,-1
80009dda:	50 9c       	stdsp	sp[0x24],r12
80009ddc:	c7 9b       	rjmp	80009cce <_dtoa_r+0x9de>
80009dde:	30 18       	mov	r8,1
80009de0:	06 90       	mov	r0,r3
80009de2:	40 85       	lddsp	r5,sp[0x20]
80009de4:	08 93       	mov	r3,r4
80009de6:	0c 94       	mov	r4,r6
80009de8:	10 96       	mov	r6,r8
80009dea:	04 9b       	mov	r11,r2
80009dec:	00 9c       	mov	r12,r0
80009dee:	fe b0 f9 f1 	rcall	800091d0 <quorem>
80009df2:	2d 0c       	sub	r12,-48
80009df4:	0a cc       	st.b	r5++,r12
80009df6:	02 36       	cp.w	r6,r1
80009df8:	c0 a4       	brge	80009e0c <_dtoa_r+0xb1c>
80009dfa:	00 9b       	mov	r11,r0
80009dfc:	30 09       	mov	r9,0
80009dfe:	30 aa       	mov	r10,10
80009e00:	0e 9c       	mov	r12,r7
80009e02:	2f f6       	sub	r6,-1
80009e04:	e0 a0 07 04 	rcall	8000ac0c <__multadd>
80009e08:	18 90       	mov	r0,r12
80009e0a:	cf 0b       	rjmp	80009dea <_dtoa_r+0xafa>
80009e0c:	08 96       	mov	r6,r4
80009e0e:	30 0b       	mov	r11,0
80009e10:	06 94       	mov	r4,r3
80009e12:	50 4b       	stdsp	sp[0x10],r11
80009e14:	00 93       	mov	r3,r0
80009e16:	18 90       	mov	r0,r12
80009e18:	c0 28       	rjmp	80009e1c <_dtoa_r+0xb2c>
80009e1a:	40 26       	lddsp	r6,sp[0x8]
80009e1c:	06 9b       	mov	r11,r3
80009e1e:	30 1a       	mov	r10,1
80009e20:	0e 9c       	mov	r12,r7
80009e22:	e0 a0 06 29 	rcall	8000aa74 <__lshift>
80009e26:	04 9b       	mov	r11,r2
80009e28:	18 93       	mov	r3,r12
80009e2a:	e0 a0 05 02 	rcall	8000a82e <__mcmp>
80009e2e:	e0 89 00 12 	brgt	80009e52 <_dtoa_r+0xb62>
80009e32:	c1 b1       	brne	80009e68 <_dtoa_r+0xb78>
80009e34:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009e38:	c0 d1       	brne	80009e52 <_dtoa_r+0xb62>
80009e3a:	c1 78       	rjmp	80009e68 <_dtoa_r+0xb78>
80009e3c:	40 89       	lddsp	r9,sp[0x20]
80009e3e:	12 38       	cp.w	r8,r9
80009e40:	c0 30       	breq	80009e46 <_dtoa_r+0xb56>
80009e42:	10 95       	mov	r5,r8
80009e44:	c0 88       	rjmp	80009e54 <_dtoa_r+0xb64>
80009e46:	2f f6       	sub	r6,-1
80009e48:	50 66       	stdsp	sp[0x18],r6
80009e4a:	33 18       	mov	r8,49
80009e4c:	40 8c       	lddsp	r12,sp[0x20]
80009e4e:	b8 88       	st.b	r12[0x0],r8
80009e50:	c1 38       	rjmp	80009e76 <_dtoa_r+0xb86>
80009e52:	33 9a       	mov	r10,57
80009e54:	0a 98       	mov	r8,r5
80009e56:	11 79       	ld.ub	r9,--r8
80009e58:	f4 09 18 00 	cp.b	r9,r10
80009e5c:	cf 00       	breq	80009e3c <_dtoa_r+0xb4c>
80009e5e:	2f f9       	sub	r9,-1
80009e60:	b0 89       	st.b	r8[0x0],r9
80009e62:	c0 98       	rjmp	80009e74 <_dtoa_r+0xb84>
80009e64:	10 95       	mov	r5,r8
80009e66:	c0 28       	rjmp	80009e6a <_dtoa_r+0xb7a>
80009e68:	33 09       	mov	r9,48
80009e6a:	0a 98       	mov	r8,r5
80009e6c:	11 7a       	ld.ub	r10,--r8
80009e6e:	f2 0a 18 00 	cp.b	r10,r9
80009e72:	cf 90       	breq	80009e64 <_dtoa_r+0xb74>
80009e74:	50 66       	stdsp	sp[0x18],r6
80009e76:	04 9b       	mov	r11,r2
80009e78:	0e 9c       	mov	r12,r7
80009e7a:	e0 a0 04 f3 	rcall	8000a860 <_Bfree>
80009e7e:	58 04       	cp.w	r4,0
80009e80:	c1 20       	breq	80009ea4 <_dtoa_r+0xbb4>
80009e82:	40 4b       	lddsp	r11,sp[0x10]
80009e84:	08 3b       	cp.w	r11,r4
80009e86:	5f 19       	srne	r9
80009e88:	58 0b       	cp.w	r11,0
80009e8a:	5f 18       	srne	r8
80009e8c:	f3 e8 00 08 	and	r8,r9,r8
80009e90:	c0 40       	breq	80009e98 <_dtoa_r+0xba8>
80009e92:	0e 9c       	mov	r12,r7
80009e94:	e0 a0 04 e6 	rcall	8000a860 <_Bfree>
80009e98:	08 9b       	mov	r11,r4
80009e9a:	0e 9c       	mov	r12,r7
80009e9c:	e0 a0 04 e2 	rcall	8000a860 <_Bfree>
80009ea0:	c0 28       	rjmp	80009ea4 <_dtoa_r+0xbb4>
80009ea2:	50 66       	stdsp	sp[0x18],r6
80009ea4:	0e 9c       	mov	r12,r7
80009ea6:	06 9b       	mov	r11,r3
80009ea8:	e0 a0 04 dc 	rcall	8000a860 <_Bfree>
80009eac:	30 08       	mov	r8,0
80009eae:	aa 88       	st.b	r5[0x0],r8
80009eb0:	40 68       	lddsp	r8,sp[0x18]
80009eb2:	41 5a       	lddsp	r10,sp[0x54]
80009eb4:	2f f8       	sub	r8,-1
80009eb6:	41 29       	lddsp	r9,sp[0x48]
80009eb8:	95 08       	st.w	r10[0x0],r8
80009eba:	40 8c       	lddsp	r12,sp[0x20]
80009ebc:	58 09       	cp.w	r9,0
80009ebe:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009ec2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009ec6:	2e 6d       	sub	sp,-104
80009ec8:	d8 32       	popm	r0-r7,pc
80009eca:	d7 03       	nop

80009ecc <__errno>:
80009ecc:	e0 68 0a 44 	mov	r8,2628
80009ed0:	70 0c       	ld.w	r12,r8[0x0]
80009ed2:	2f 4c       	sub	r12,-12
80009ed4:	5e fc       	retal	r12
80009ed6:	d7 03       	nop

80009ed8 <_fflush_r>:
80009ed8:	d4 21       	pushm	r4-r7,lr
80009eda:	16 97       	mov	r7,r11
80009edc:	18 96       	mov	r6,r12
80009ede:	76 48       	ld.w	r8,r11[0x10]
80009ee0:	58 08       	cp.w	r8,0
80009ee2:	c7 f0       	breq	80009fe0 <_fflush_r+0x108>
80009ee4:	58 0c       	cp.w	r12,0
80009ee6:	c0 50       	breq	80009ef0 <_fflush_r+0x18>
80009ee8:	78 68       	ld.w	r8,r12[0x18]
80009eea:	58 08       	cp.w	r8,0
80009eec:	c0 21       	brne	80009ef0 <_fflush_r+0x18>
80009eee:	cc dc       	rcall	8000a088 <__sinit>
80009ef0:	fe c8 cf 44 	sub	r8,pc,-12476
80009ef4:	10 37       	cp.w	r7,r8
80009ef6:	c0 31       	brne	80009efc <_fflush_r+0x24>
80009ef8:	6c 07       	ld.w	r7,r6[0x0]
80009efa:	c0 c8       	rjmp	80009f12 <_fflush_r+0x3a>
80009efc:	fe c8 cf 30 	sub	r8,pc,-12496
80009f00:	10 37       	cp.w	r7,r8
80009f02:	c0 31       	brne	80009f08 <_fflush_r+0x30>
80009f04:	6c 17       	ld.w	r7,r6[0x4]
80009f06:	c0 68       	rjmp	80009f12 <_fflush_r+0x3a>
80009f08:	fe c8 cf 1c 	sub	r8,pc,-12516
80009f0c:	10 37       	cp.w	r7,r8
80009f0e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009f12:	8e 6a       	ld.sh	r10,r7[0xc]
80009f14:	14 98       	mov	r8,r10
80009f16:	ed ba 00 03 	bld	r10,0x3
80009f1a:	c4 20       	breq	80009f9e <_fflush_r+0xc6>
80009f1c:	ab ba       	sbr	r10,0xb
80009f1e:	ae 6a       	st.h	r7[0xc],r10
80009f20:	6e 18       	ld.w	r8,r7[0x4]
80009f22:	58 08       	cp.w	r8,0
80009f24:	e0 89 00 06 	brgt	80009f30 <_fflush_r+0x58>
80009f28:	6f 08       	ld.w	r8,r7[0x40]
80009f2a:	58 08       	cp.w	r8,0
80009f2c:	e0 8a 00 5a 	brle	80009fe0 <_fflush_r+0x108>
80009f30:	6e b8       	ld.w	r8,r7[0x2c]
80009f32:	58 08       	cp.w	r8,0
80009f34:	c5 60       	breq	80009fe0 <_fflush_r+0x108>
80009f36:	e2 1a 10 00 	andl	r10,0x1000,COH
80009f3a:	c0 30       	breq	80009f40 <_fflush_r+0x68>
80009f3c:	6f 55       	ld.w	r5,r7[0x54]
80009f3e:	c0 f8       	rjmp	80009f5c <_fflush_r+0x84>
80009f40:	30 19       	mov	r9,1
80009f42:	6e 8b       	ld.w	r11,r7[0x20]
80009f44:	0c 9c       	mov	r12,r6
80009f46:	5d 18       	icall	r8
80009f48:	18 95       	mov	r5,r12
80009f4a:	5b fc       	cp.w	r12,-1
80009f4c:	c0 81       	brne	80009f5c <_fflush_r+0x84>
80009f4e:	6c 38       	ld.w	r8,r6[0xc]
80009f50:	59 d8       	cp.w	r8,29
80009f52:	c4 70       	breq	80009fe0 <_fflush_r+0x108>
80009f54:	8e 68       	ld.sh	r8,r7[0xc]
80009f56:	a7 a8       	sbr	r8,0x6
80009f58:	ae 68       	st.h	r7[0xc],r8
80009f5a:	d8 22       	popm	r4-r7,pc
80009f5c:	8e 68       	ld.sh	r8,r7[0xc]
80009f5e:	ed b8 00 02 	bld	r8,0x2
80009f62:	c0 91       	brne	80009f74 <_fflush_r+0x9c>
80009f64:	6e 18       	ld.w	r8,r7[0x4]
80009f66:	10 15       	sub	r5,r8
80009f68:	6e d8       	ld.w	r8,r7[0x34]
80009f6a:	58 08       	cp.w	r8,0
80009f6c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009f70:	eb d8 e1 15 	subne	r5,r5,r8
80009f74:	6e b8       	ld.w	r8,r7[0x2c]
80009f76:	0c 9c       	mov	r12,r6
80009f78:	30 09       	mov	r9,0
80009f7a:	0a 9a       	mov	r10,r5
80009f7c:	6e 8b       	ld.w	r11,r7[0x20]
80009f7e:	5d 18       	icall	r8
80009f80:	8e 68       	ld.sh	r8,r7[0xc]
80009f82:	0a 3c       	cp.w	r12,r5
80009f84:	c2 61       	brne	80009fd0 <_fflush_r+0xf8>
80009f86:	ab d8       	cbr	r8,0xb
80009f88:	30 0c       	mov	r12,0
80009f8a:	6e 49       	ld.w	r9,r7[0x10]
80009f8c:	ae 68       	st.h	r7[0xc],r8
80009f8e:	8f 1c       	st.w	r7[0x4],r12
80009f90:	8f 09       	st.w	r7[0x0],r9
80009f92:	ed b8 00 0c 	bld	r8,0xc
80009f96:	c2 51       	brne	80009fe0 <_fflush_r+0x108>
80009f98:	ef 45 00 54 	st.w	r7[84],r5
80009f9c:	d8 22       	popm	r4-r7,pc
80009f9e:	6e 45       	ld.w	r5,r7[0x10]
80009fa0:	58 05       	cp.w	r5,0
80009fa2:	c1 f0       	breq	80009fe0 <_fflush_r+0x108>
80009fa4:	6e 04       	ld.w	r4,r7[0x0]
80009fa6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009faa:	8f 05       	st.w	r7[0x0],r5
80009fac:	f9 b8 01 00 	movne	r8,0
80009fb0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009fb4:	0a 14       	sub	r4,r5
80009fb6:	8f 28       	st.w	r7[0x8],r8
80009fb8:	c1 18       	rjmp	80009fda <_fflush_r+0x102>
80009fba:	08 99       	mov	r9,r4
80009fbc:	0a 9a       	mov	r10,r5
80009fbe:	6e a8       	ld.w	r8,r7[0x28]
80009fc0:	6e 8b       	ld.w	r11,r7[0x20]
80009fc2:	0c 9c       	mov	r12,r6
80009fc4:	5d 18       	icall	r8
80009fc6:	18 14       	sub	r4,r12
80009fc8:	58 0c       	cp.w	r12,0
80009fca:	e0 89 00 07 	brgt	80009fd8 <_fflush_r+0x100>
80009fce:	8e 68       	ld.sh	r8,r7[0xc]
80009fd0:	a7 a8       	sbr	r8,0x6
80009fd2:	3f fc       	mov	r12,-1
80009fd4:	ae 68       	st.h	r7[0xc],r8
80009fd6:	d8 22       	popm	r4-r7,pc
80009fd8:	18 05       	add	r5,r12
80009fda:	58 04       	cp.w	r4,0
80009fdc:	fe 99 ff ef 	brgt	80009fba <_fflush_r+0xe2>
80009fe0:	d8 2a       	popm	r4-r7,pc,r12=0
80009fe2:	d7 03       	nop

80009fe4 <__sfp_lock_acquire>:
80009fe4:	5e fc       	retal	r12

80009fe6 <__sfp_lock_release>:
80009fe6:	5e fc       	retal	r12

80009fe8 <_cleanup_r>:
80009fe8:	d4 01       	pushm	lr
80009fea:	fe cb f0 c6 	sub	r11,pc,-3898
80009fee:	e0 a0 02 f7 	rcall	8000a5dc <_fwalk>
80009ff2:	d8 02       	popm	pc

80009ff4 <__sfmoreglue>:
80009ff4:	d4 21       	pushm	r4-r7,lr
80009ff6:	16 95       	mov	r5,r11
80009ff8:	f6 06 10 5c 	mul	r6,r11,92
80009ffc:	ec cb ff f4 	sub	r11,r6,-12
8000a000:	fe b0 e2 7c 	rcall	800064f8 <_malloc_r>
8000a004:	18 97       	mov	r7,r12
8000a006:	c0 90       	breq	8000a018 <__sfmoreglue+0x24>
8000a008:	99 15       	st.w	r12[0x4],r5
8000a00a:	30 0b       	mov	r11,0
8000a00c:	2f 4c       	sub	r12,-12
8000a00e:	0c 9a       	mov	r10,r6
8000a010:	8f 2c       	st.w	r7[0x8],r12
8000a012:	8f 0b       	st.w	r7[0x0],r11
8000a014:	fe b0 e5 32 	rcall	80006a78 <memset>
8000a018:	0e 9c       	mov	r12,r7
8000a01a:	d8 22       	popm	r4-r7,pc

8000a01c <__sfp>:
8000a01c:	d4 21       	pushm	r4-r7,lr
8000a01e:	fe c8 d0 0e 	sub	r8,pc,-12274
8000a022:	18 96       	mov	r6,r12
8000a024:	70 07       	ld.w	r7,r8[0x0]
8000a026:	6e 68       	ld.w	r8,r7[0x18]
8000a028:	58 08       	cp.w	r8,0
8000a02a:	c0 31       	brne	8000a030 <__sfp+0x14>
8000a02c:	0e 9c       	mov	r12,r7
8000a02e:	c2 dc       	rcall	8000a088 <__sinit>
8000a030:	ee c7 ff 28 	sub	r7,r7,-216
8000a034:	30 05       	mov	r5,0
8000a036:	6e 2c       	ld.w	r12,r7[0x8]
8000a038:	6e 18       	ld.w	r8,r7[0x4]
8000a03a:	c0 68       	rjmp	8000a046 <__sfp+0x2a>
8000a03c:	98 69       	ld.sh	r9,r12[0xc]
8000a03e:	ea 09 19 00 	cp.h	r9,r5
8000a042:	c1 10       	breq	8000a064 <__sfp+0x48>
8000a044:	2a 4c       	sub	r12,-92
8000a046:	20 18       	sub	r8,1
8000a048:	cf a7       	brpl	8000a03c <__sfp+0x20>
8000a04a:	6e 08       	ld.w	r8,r7[0x0]
8000a04c:	58 08       	cp.w	r8,0
8000a04e:	c0 61       	brne	8000a05a <__sfp+0x3e>
8000a050:	30 4b       	mov	r11,4
8000a052:	0c 9c       	mov	r12,r6
8000a054:	cd 0f       	rcall	80009ff4 <__sfmoreglue>
8000a056:	8f 0c       	st.w	r7[0x0],r12
8000a058:	c0 30       	breq	8000a05e <__sfp+0x42>
8000a05a:	6e 07       	ld.w	r7,r7[0x0]
8000a05c:	ce db       	rjmp	8000a036 <__sfp+0x1a>
8000a05e:	30 c8       	mov	r8,12
8000a060:	8d 38       	st.w	r6[0xc],r8
8000a062:	d8 22       	popm	r4-r7,pc
8000a064:	30 08       	mov	r8,0
8000a066:	f9 48 00 4c 	st.w	r12[76],r8
8000a06a:	99 08       	st.w	r12[0x0],r8
8000a06c:	99 28       	st.w	r12[0x8],r8
8000a06e:	99 18       	st.w	r12[0x4],r8
8000a070:	99 48       	st.w	r12[0x10],r8
8000a072:	99 58       	st.w	r12[0x14],r8
8000a074:	99 68       	st.w	r12[0x18],r8
8000a076:	99 d8       	st.w	r12[0x34],r8
8000a078:	99 e8       	st.w	r12[0x38],r8
8000a07a:	f9 48 00 48 	st.w	r12[72],r8
8000a07e:	3f f8       	mov	r8,-1
8000a080:	b8 78       	st.h	r12[0xe],r8
8000a082:	30 18       	mov	r8,1
8000a084:	b8 68       	st.h	r12[0xc],r8
8000a086:	d8 22       	popm	r4-r7,pc

8000a088 <__sinit>:
8000a088:	d4 21       	pushm	r4-r7,lr
8000a08a:	18 96       	mov	r6,r12
8000a08c:	78 67       	ld.w	r7,r12[0x18]
8000a08e:	58 07       	cp.w	r7,0
8000a090:	c4 91       	brne	8000a122 <__sinit+0x9a>
8000a092:	fe c8 00 aa 	sub	r8,pc,170
8000a096:	30 15       	mov	r5,1
8000a098:	99 a8       	st.w	r12[0x28],r8
8000a09a:	f9 47 00 d8 	st.w	r12[216],r7
8000a09e:	f9 47 00 dc 	st.w	r12[220],r7
8000a0a2:	f9 47 00 e0 	st.w	r12[224],r7
8000a0a6:	99 65       	st.w	r12[0x18],r5
8000a0a8:	cb af       	rcall	8000a01c <__sfp>
8000a0aa:	8d 0c       	st.w	r6[0x0],r12
8000a0ac:	0c 9c       	mov	r12,r6
8000a0ae:	cb 7f       	rcall	8000a01c <__sfp>
8000a0b0:	8d 1c       	st.w	r6[0x4],r12
8000a0b2:	0c 9c       	mov	r12,r6
8000a0b4:	cb 4f       	rcall	8000a01c <__sfp>
8000a0b6:	6c 09       	ld.w	r9,r6[0x0]
8000a0b8:	30 48       	mov	r8,4
8000a0ba:	93 07       	st.w	r9[0x0],r7
8000a0bc:	b2 68       	st.h	r9[0xc],r8
8000a0be:	93 17       	st.w	r9[0x4],r7
8000a0c0:	93 27       	st.w	r9[0x8],r7
8000a0c2:	6c 18       	ld.w	r8,r6[0x4]
8000a0c4:	b2 77       	st.h	r9[0xe],r7
8000a0c6:	93 47       	st.w	r9[0x10],r7
8000a0c8:	93 57       	st.w	r9[0x14],r7
8000a0ca:	93 67       	st.w	r9[0x18],r7
8000a0cc:	93 89       	st.w	r9[0x20],r9
8000a0ce:	91 07       	st.w	r8[0x0],r7
8000a0d0:	91 17       	st.w	r8[0x4],r7
8000a0d2:	91 27       	st.w	r8[0x8],r7
8000a0d4:	fe ce f3 24 	sub	lr,pc,-3292
8000a0d8:	fe cb f3 54 	sub	r11,pc,-3244
8000a0dc:	93 9e       	st.w	r9[0x24],lr
8000a0de:	93 ab       	st.w	r9[0x28],r11
8000a0e0:	fe ca f3 7c 	sub	r10,pc,-3204
8000a0e4:	fe c4 f3 88 	sub	r4,pc,-3192
8000a0e8:	93 ba       	st.w	r9[0x2c],r10
8000a0ea:	93 c4       	st.w	r9[0x30],r4
8000a0ec:	30 99       	mov	r9,9
8000a0ee:	b0 69       	st.h	r8[0xc],r9
8000a0f0:	b0 75       	st.h	r8[0xe],r5
8000a0f2:	91 c4       	st.w	r8[0x30],r4
8000a0f4:	91 47       	st.w	r8[0x10],r7
8000a0f6:	91 57       	st.w	r8[0x14],r7
8000a0f8:	91 67       	st.w	r8[0x18],r7
8000a0fa:	91 88       	st.w	r8[0x20],r8
8000a0fc:	91 9e       	st.w	r8[0x24],lr
8000a0fe:	91 ab       	st.w	r8[0x28],r11
8000a100:	91 ba       	st.w	r8[0x2c],r10
8000a102:	8d 2c       	st.w	r6[0x8],r12
8000a104:	31 28       	mov	r8,18
8000a106:	99 07       	st.w	r12[0x0],r7
8000a108:	b8 68       	st.h	r12[0xc],r8
8000a10a:	99 17       	st.w	r12[0x4],r7
8000a10c:	99 27       	st.w	r12[0x8],r7
8000a10e:	30 28       	mov	r8,2
8000a110:	b8 78       	st.h	r12[0xe],r8
8000a112:	99 c4       	st.w	r12[0x30],r4
8000a114:	99 67       	st.w	r12[0x18],r7
8000a116:	99 9e       	st.w	r12[0x24],lr
8000a118:	99 ab       	st.w	r12[0x28],r11
8000a11a:	99 ba       	st.w	r12[0x2c],r10
8000a11c:	99 47       	st.w	r12[0x10],r7
8000a11e:	99 57       	st.w	r12[0x14],r7
8000a120:	99 8c       	st.w	r12[0x20],r12
8000a122:	d8 22       	popm	r4-r7,pc

8000a124 <_malloc_trim_r>:
8000a124:	d4 21       	pushm	r4-r7,lr
8000a126:	16 95       	mov	r5,r11
8000a128:	18 97       	mov	r7,r12
8000a12a:	fe b0 d7 83 	rcall	80005030 <__malloc_lock>
8000a12e:	e0 64 05 44 	mov	r4,1348
8000a132:	68 28       	ld.w	r8,r4[0x8]
8000a134:	70 16       	ld.w	r6,r8[0x4]
8000a136:	e0 16 ff fc 	andl	r6,0xfffc
8000a13a:	ec c8 ff 91 	sub	r8,r6,-111
8000a13e:	f0 05 01 05 	sub	r5,r8,r5
8000a142:	e0 15 ff 80 	andl	r5,0xff80
8000a146:	ea c5 00 80 	sub	r5,r5,128
8000a14a:	e0 45 00 7f 	cp.w	r5,127
8000a14e:	e0 8a 00 25 	brle	8000a198 <_malloc_trim_r+0x74>
8000a152:	30 0b       	mov	r11,0
8000a154:	0e 9c       	mov	r12,r7
8000a156:	fe b0 e5 f9 	rcall	80006d48 <_sbrk_r>
8000a15a:	68 28       	ld.w	r8,r4[0x8]
8000a15c:	0c 08       	add	r8,r6
8000a15e:	10 3c       	cp.w	r12,r8
8000a160:	c1 c1       	brne	8000a198 <_malloc_trim_r+0x74>
8000a162:	ea 0b 11 00 	rsub	r11,r5,0
8000a166:	0e 9c       	mov	r12,r7
8000a168:	fe b0 e5 f0 	rcall	80006d48 <_sbrk_r>
8000a16c:	5b fc       	cp.w	r12,-1
8000a16e:	c1 91       	brne	8000a1a0 <_malloc_trim_r+0x7c>
8000a170:	30 0b       	mov	r11,0
8000a172:	0e 9c       	mov	r12,r7
8000a174:	fe b0 e5 ea 	rcall	80006d48 <_sbrk_r>
8000a178:	68 28       	ld.w	r8,r4[0x8]
8000a17a:	f8 08 01 09 	sub	r9,r12,r8
8000a17e:	58 f9       	cp.w	r9,15
8000a180:	e0 8a 00 0c 	brle	8000a198 <_malloc_trim_r+0x74>
8000a184:	a1 a9       	sbr	r9,0x0
8000a186:	91 19       	st.w	r8[0x4],r9
8000a188:	e0 68 09 50 	mov	r8,2384
8000a18c:	70 09       	ld.w	r9,r8[0x0]
8000a18e:	e0 68 0d 50 	mov	r8,3408
8000a192:	f8 09 01 09 	sub	r9,r12,r9
8000a196:	91 09       	st.w	r8[0x0],r9
8000a198:	0e 9c       	mov	r12,r7
8000a19a:	fe b0 d7 51 	rcall	8000503c <__malloc_unlock>
8000a19e:	d8 2a       	popm	r4-r7,pc,r12=0
8000a1a0:	68 28       	ld.w	r8,r4[0x8]
8000a1a2:	0a 16       	sub	r6,r5
8000a1a4:	a1 a6       	sbr	r6,0x0
8000a1a6:	91 16       	st.w	r8[0x4],r6
8000a1a8:	e0 68 0d 50 	mov	r8,3408
8000a1ac:	70 09       	ld.w	r9,r8[0x0]
8000a1ae:	0a 19       	sub	r9,r5
8000a1b0:	0e 9c       	mov	r12,r7
8000a1b2:	91 09       	st.w	r8[0x0],r9
8000a1b4:	fe b0 d7 44 	rcall	8000503c <__malloc_unlock>
8000a1b8:	da 2a       	popm	r4-r7,pc,r12=1
8000a1ba:	d7 03       	nop

8000a1bc <_free_r>:
8000a1bc:	d4 21       	pushm	r4-r7,lr
8000a1be:	16 96       	mov	r6,r11
8000a1c0:	18 97       	mov	r7,r12
8000a1c2:	58 0b       	cp.w	r11,0
8000a1c4:	e0 80 00 c0 	breq	8000a344 <_free_r+0x188>
8000a1c8:	fe b0 d7 34 	rcall	80005030 <__malloc_lock>
8000a1cc:	20 86       	sub	r6,8
8000a1ce:	e0 6a 05 44 	mov	r10,1348
8000a1d2:	6c 18       	ld.w	r8,r6[0x4]
8000a1d4:	74 2e       	ld.w	lr,r10[0x8]
8000a1d6:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a1da:	a1 c8       	cbr	r8,0x0
8000a1dc:	ec 08 00 09 	add	r9,r6,r8
8000a1e0:	72 1b       	ld.w	r11,r9[0x4]
8000a1e2:	e0 1b ff fc 	andl	r11,0xfffc
8000a1e6:	1c 39       	cp.w	r9,lr
8000a1e8:	c1 e1       	brne	8000a224 <_free_r+0x68>
8000a1ea:	f6 08 00 08 	add	r8,r11,r8
8000a1ee:	58 0c       	cp.w	r12,0
8000a1f0:	c0 81       	brne	8000a200 <_free_r+0x44>
8000a1f2:	6c 09       	ld.w	r9,r6[0x0]
8000a1f4:	12 16       	sub	r6,r9
8000a1f6:	12 08       	add	r8,r9
8000a1f8:	6c 3b       	ld.w	r11,r6[0xc]
8000a1fa:	6c 29       	ld.w	r9,r6[0x8]
8000a1fc:	97 29       	st.w	r11[0x8],r9
8000a1fe:	93 3b       	st.w	r9[0xc],r11
8000a200:	10 99       	mov	r9,r8
8000a202:	95 26       	st.w	r10[0x8],r6
8000a204:	a1 a9       	sbr	r9,0x0
8000a206:	8d 19       	st.w	r6[0x4],r9
8000a208:	e0 69 09 4c 	mov	r9,2380
8000a20c:	72 09       	ld.w	r9,r9[0x0]
8000a20e:	12 38       	cp.w	r8,r9
8000a210:	c0 63       	brcs	8000a21c <_free_r+0x60>
8000a212:	e0 68 0d 4c 	mov	r8,3404
8000a216:	0e 9c       	mov	r12,r7
8000a218:	70 0b       	ld.w	r11,r8[0x0]
8000a21a:	c8 5f       	rcall	8000a124 <_malloc_trim_r>
8000a21c:	0e 9c       	mov	r12,r7
8000a21e:	fe b0 d7 0f 	rcall	8000503c <__malloc_unlock>
8000a222:	d8 22       	popm	r4-r7,pc
8000a224:	93 1b       	st.w	r9[0x4],r11
8000a226:	58 0c       	cp.w	r12,0
8000a228:	c0 30       	breq	8000a22e <_free_r+0x72>
8000a22a:	30 0c       	mov	r12,0
8000a22c:	c1 08       	rjmp	8000a24c <_free_r+0x90>
8000a22e:	6c 0e       	ld.w	lr,r6[0x0]
8000a230:	f4 c5 ff f8 	sub	r5,r10,-8
8000a234:	1c 16       	sub	r6,lr
8000a236:	1c 08       	add	r8,lr
8000a238:	6c 2e       	ld.w	lr,r6[0x8]
8000a23a:	0a 3e       	cp.w	lr,r5
8000a23c:	f9 bc 00 01 	moveq	r12,1
8000a240:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a244:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a248:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a24c:	f2 0b 00 0e 	add	lr,r9,r11
8000a250:	7c 1e       	ld.w	lr,lr[0x4]
8000a252:	ed be 00 00 	bld	lr,0x0
8000a256:	c1 40       	breq	8000a27e <_free_r+0xc2>
8000a258:	16 08       	add	r8,r11
8000a25a:	58 0c       	cp.w	r12,0
8000a25c:	c0 d1       	brne	8000a276 <_free_r+0xba>
8000a25e:	e0 6e 05 44 	mov	lr,1348
8000a262:	72 2b       	ld.w	r11,r9[0x8]
8000a264:	2f 8e       	sub	lr,-8
8000a266:	1c 3b       	cp.w	r11,lr
8000a268:	c0 71       	brne	8000a276 <_free_r+0xba>
8000a26a:	97 36       	st.w	r11[0xc],r6
8000a26c:	97 26       	st.w	r11[0x8],r6
8000a26e:	8d 2b       	st.w	r6[0x8],r11
8000a270:	8d 3b       	st.w	r6[0xc],r11
8000a272:	30 1c       	mov	r12,1
8000a274:	c0 58       	rjmp	8000a27e <_free_r+0xc2>
8000a276:	72 2b       	ld.w	r11,r9[0x8]
8000a278:	72 39       	ld.w	r9,r9[0xc]
8000a27a:	93 2b       	st.w	r9[0x8],r11
8000a27c:	97 39       	st.w	r11[0xc],r9
8000a27e:	10 99       	mov	r9,r8
8000a280:	ec 08 09 08 	st.w	r6[r8],r8
8000a284:	a1 a9       	sbr	r9,0x0
8000a286:	8d 19       	st.w	r6[0x4],r9
8000a288:	58 0c       	cp.w	r12,0
8000a28a:	c5 a1       	brne	8000a33e <_free_r+0x182>
8000a28c:	e0 48 01 ff 	cp.w	r8,511
8000a290:	e0 8b 00 13 	brhi	8000a2b6 <_free_r+0xfa>
8000a294:	a3 98       	lsr	r8,0x3
8000a296:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a29a:	72 2b       	ld.w	r11,r9[0x8]
8000a29c:	8d 39       	st.w	r6[0xc],r9
8000a29e:	8d 2b       	st.w	r6[0x8],r11
8000a2a0:	97 36       	st.w	r11[0xc],r6
8000a2a2:	93 26       	st.w	r9[0x8],r6
8000a2a4:	a3 48       	asr	r8,0x2
8000a2a6:	74 19       	ld.w	r9,r10[0x4]
8000a2a8:	30 1b       	mov	r11,1
8000a2aa:	f6 08 09 48 	lsl	r8,r11,r8
8000a2ae:	f3 e8 10 08 	or	r8,r9,r8
8000a2b2:	95 18       	st.w	r10[0x4],r8
8000a2b4:	c4 58       	rjmp	8000a33e <_free_r+0x182>
8000a2b6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a2ba:	58 4b       	cp.w	r11,4
8000a2bc:	e0 8b 00 06 	brhi	8000a2c8 <_free_r+0x10c>
8000a2c0:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a2c4:	2c 8b       	sub	r11,-56
8000a2c6:	c2 08       	rjmp	8000a306 <_free_r+0x14a>
8000a2c8:	59 4b       	cp.w	r11,20
8000a2ca:	e0 8b 00 04 	brhi	8000a2d2 <_free_r+0x116>
8000a2ce:	2a 5b       	sub	r11,-91
8000a2d0:	c1 b8       	rjmp	8000a306 <_free_r+0x14a>
8000a2d2:	e0 4b 00 54 	cp.w	r11,84
8000a2d6:	e0 8b 00 06 	brhi	8000a2e2 <_free_r+0x126>
8000a2da:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a2de:	29 2b       	sub	r11,-110
8000a2e0:	c1 38       	rjmp	8000a306 <_free_r+0x14a>
8000a2e2:	e0 4b 01 54 	cp.w	r11,340
8000a2e6:	e0 8b 00 06 	brhi	8000a2f2 <_free_r+0x136>
8000a2ea:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a2ee:	28 9b       	sub	r11,-119
8000a2f0:	c0 b8       	rjmp	8000a306 <_free_r+0x14a>
8000a2f2:	e0 4b 05 54 	cp.w	r11,1364
8000a2f6:	e0 88 00 05 	brls	8000a300 <_free_r+0x144>
8000a2fa:	37 eb       	mov	r11,126
8000a2fc:	c0 58       	rjmp	8000a306 <_free_r+0x14a>
8000a2fe:	d7 03       	nop
8000a300:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a304:	28 4b       	sub	r11,-124
8000a306:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a30a:	78 29       	ld.w	r9,r12[0x8]
8000a30c:	18 39       	cp.w	r9,r12
8000a30e:	c0 e1       	brne	8000a32a <_free_r+0x16e>
8000a310:	74 18       	ld.w	r8,r10[0x4]
8000a312:	a3 4b       	asr	r11,0x2
8000a314:	30 1c       	mov	r12,1
8000a316:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a31a:	f1 eb 10 0b 	or	r11,r8,r11
8000a31e:	12 98       	mov	r8,r9
8000a320:	95 1b       	st.w	r10[0x4],r11
8000a322:	c0 a8       	rjmp	8000a336 <_free_r+0x17a>
8000a324:	72 29       	ld.w	r9,r9[0x8]
8000a326:	18 39       	cp.w	r9,r12
8000a328:	c0 60       	breq	8000a334 <_free_r+0x178>
8000a32a:	72 1a       	ld.w	r10,r9[0x4]
8000a32c:	e0 1a ff fc 	andl	r10,0xfffc
8000a330:	14 38       	cp.w	r8,r10
8000a332:	cf 93       	brcs	8000a324 <_free_r+0x168>
8000a334:	72 38       	ld.w	r8,r9[0xc]
8000a336:	8d 38       	st.w	r6[0xc],r8
8000a338:	8d 29       	st.w	r6[0x8],r9
8000a33a:	93 36       	st.w	r9[0xc],r6
8000a33c:	91 26       	st.w	r8[0x8],r6
8000a33e:	0e 9c       	mov	r12,r7
8000a340:	fe b0 d6 7e 	rcall	8000503c <__malloc_unlock>
8000a344:	d8 22       	popm	r4-r7,pc
8000a346:	d7 03       	nop

8000a348 <__sfvwrite_r>:
8000a348:	d4 31       	pushm	r0-r7,lr
8000a34a:	20 3d       	sub	sp,12
8000a34c:	14 94       	mov	r4,r10
8000a34e:	18 95       	mov	r5,r12
8000a350:	16 97       	mov	r7,r11
8000a352:	74 28       	ld.w	r8,r10[0x8]
8000a354:	58 08       	cp.w	r8,0
8000a356:	e0 80 01 40 	breq	8000a5d6 <__sfvwrite_r+0x28e>
8000a35a:	96 68       	ld.sh	r8,r11[0xc]
8000a35c:	ed b8 00 03 	bld	r8,0x3
8000a360:	c0 41       	brne	8000a368 <__sfvwrite_r+0x20>
8000a362:	76 48       	ld.w	r8,r11[0x10]
8000a364:	58 08       	cp.w	r8,0
8000a366:	c0 c1       	brne	8000a37e <__sfvwrite_r+0x36>
8000a368:	0e 9b       	mov	r11,r7
8000a36a:	0a 9c       	mov	r12,r5
8000a36c:	fe b0 f6 c4 	rcall	800090f4 <__swsetup_r>
8000a370:	c0 70       	breq	8000a37e <__sfvwrite_r+0x36>
8000a372:	8e 68       	ld.sh	r8,r7[0xc]
8000a374:	a7 a8       	sbr	r8,0x6
8000a376:	ae 68       	st.h	r7[0xc],r8
8000a378:	30 98       	mov	r8,9
8000a37a:	8b 38       	st.w	r5[0xc],r8
8000a37c:	c2 b9       	rjmp	8000a5d2 <__sfvwrite_r+0x28a>
8000a37e:	8e 63       	ld.sh	r3,r7[0xc]
8000a380:	68 00       	ld.w	r0,r4[0x0]
8000a382:	06 96       	mov	r6,r3
8000a384:	e2 16 00 02 	andl	r6,0x2,COH
8000a388:	c2 10       	breq	8000a3ca <__sfvwrite_r+0x82>
8000a38a:	30 03       	mov	r3,0
8000a38c:	e0 62 04 00 	mov	r2,1024
8000a390:	06 96       	mov	r6,r3
8000a392:	c0 48       	rjmp	8000a39a <__sfvwrite_r+0x52>
8000a394:	60 03       	ld.w	r3,r0[0x0]
8000a396:	60 16       	ld.w	r6,r0[0x4]
8000a398:	2f 80       	sub	r0,-8
8000a39a:	58 06       	cp.w	r6,0
8000a39c:	cf c0       	breq	8000a394 <__sfvwrite_r+0x4c>
8000a39e:	e0 46 04 00 	cp.w	r6,1024
8000a3a2:	ec 09 17 80 	movls	r9,r6
8000a3a6:	e4 09 17 b0 	movhi	r9,r2
8000a3aa:	06 9a       	mov	r10,r3
8000a3ac:	6e a8       	ld.w	r8,r7[0x28]
8000a3ae:	6e 8b       	ld.w	r11,r7[0x20]
8000a3b0:	0a 9c       	mov	r12,r5
8000a3b2:	5d 18       	icall	r8
8000a3b4:	18 16       	sub	r6,r12
8000a3b6:	58 0c       	cp.w	r12,0
8000a3b8:	e0 8a 01 0a 	brle	8000a5cc <__sfvwrite_r+0x284>
8000a3bc:	68 28       	ld.w	r8,r4[0x8]
8000a3be:	18 18       	sub	r8,r12
8000a3c0:	89 28       	st.w	r4[0x8],r8
8000a3c2:	e0 80 01 0a 	breq	8000a5d6 <__sfvwrite_r+0x28e>
8000a3c6:	18 03       	add	r3,r12
8000a3c8:	ce 9b       	rjmp	8000a39a <__sfvwrite_r+0x52>
8000a3ca:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a3ce:	c0 70       	breq	8000a3dc <__sfvwrite_r+0x94>
8000a3d0:	50 06       	stdsp	sp[0x0],r6
8000a3d2:	0c 93       	mov	r3,r6
8000a3d4:	0c 91       	mov	r1,r6
8000a3d6:	50 15       	stdsp	sp[0x4],r5
8000a3d8:	08 92       	mov	r2,r4
8000a3da:	c9 c8       	rjmp	8000a512 <__sfvwrite_r+0x1ca>
8000a3dc:	06 96       	mov	r6,r3
8000a3de:	08 91       	mov	r1,r4
8000a3e0:	c0 48       	rjmp	8000a3e8 <__sfvwrite_r+0xa0>
8000a3e2:	60 03       	ld.w	r3,r0[0x0]
8000a3e4:	60 16       	ld.w	r6,r0[0x4]
8000a3e6:	2f 80       	sub	r0,-8
8000a3e8:	58 06       	cp.w	r6,0
8000a3ea:	cf c0       	breq	8000a3e2 <__sfvwrite_r+0x9a>
8000a3ec:	8e 68       	ld.sh	r8,r7[0xc]
8000a3ee:	6e 24       	ld.w	r4,r7[0x8]
8000a3f0:	10 99       	mov	r9,r8
8000a3f2:	e2 19 02 00 	andl	r9,0x200,COH
8000a3f6:	c5 50       	breq	8000a4a0 <__sfvwrite_r+0x158>
8000a3f8:	08 36       	cp.w	r6,r4
8000a3fa:	c4 43       	brcs	8000a482 <__sfvwrite_r+0x13a>
8000a3fc:	10 99       	mov	r9,r8
8000a3fe:	e2 19 04 80 	andl	r9,0x480,COH
8000a402:	c4 00       	breq	8000a482 <__sfvwrite_r+0x13a>
8000a404:	6e 4b       	ld.w	r11,r7[0x10]
8000a406:	6e 09       	ld.w	r9,r7[0x0]
8000a408:	16 19       	sub	r9,r11
8000a40a:	50 09       	stdsp	sp[0x0],r9
8000a40c:	6e 59       	ld.w	r9,r7[0x14]
8000a40e:	10 9c       	mov	r12,r8
8000a410:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a414:	30 28       	mov	r8,2
8000a416:	f4 08 0c 08 	divs	r8,r10,r8
8000a41a:	fa e9 00 04 	st.d	sp[4],r8
8000a41e:	10 94       	mov	r4,r8
8000a420:	40 09       	lddsp	r9,sp[0x0]
8000a422:	e2 1c 04 00 	andl	r12,0x400,COH
8000a426:	2f f9       	sub	r9,-1
8000a428:	0c 09       	add	r9,r6
8000a42a:	12 38       	cp.w	r8,r9
8000a42c:	f2 04 17 30 	movlo	r4,r9
8000a430:	58 0c       	cp.w	r12,0
8000a432:	c1 10       	breq	8000a454 <__sfvwrite_r+0x10c>
8000a434:	08 9b       	mov	r11,r4
8000a436:	0a 9c       	mov	r12,r5
8000a438:	fe b0 e0 60 	rcall	800064f8 <_malloc_r>
8000a43c:	18 92       	mov	r2,r12
8000a43e:	c1 40       	breq	8000a466 <__sfvwrite_r+0x11e>
8000a440:	40 0a       	lddsp	r10,sp[0x0]
8000a442:	6e 4b       	ld.w	r11,r7[0x10]
8000a444:	fe b0 e2 76 	rcall	80006930 <memcpy>
8000a448:	8e 68       	ld.sh	r8,r7[0xc]
8000a44a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a44e:	a7 b8       	sbr	r8,0x7
8000a450:	ae 68       	st.h	r7[0xc],r8
8000a452:	c0 d8       	rjmp	8000a46c <__sfvwrite_r+0x124>
8000a454:	08 9a       	mov	r10,r4
8000a456:	0a 9c       	mov	r12,r5
8000a458:	fe b0 e3 18 	rcall	80006a88 <_realloc_r>
8000a45c:	18 92       	mov	r2,r12
8000a45e:	c0 71       	brne	8000a46c <__sfvwrite_r+0x124>
8000a460:	6e 4b       	ld.w	r11,r7[0x10]
8000a462:	0a 9c       	mov	r12,r5
8000a464:	ca ce       	rcall	8000a1bc <_free_r>
8000a466:	30 c8       	mov	r8,12
8000a468:	8b 38       	st.w	r5[0xc],r8
8000a46a:	cb 18       	rjmp	8000a5cc <__sfvwrite_r+0x284>
8000a46c:	40 0a       	lddsp	r10,sp[0x0]
8000a46e:	40 09       	lddsp	r9,sp[0x0]
8000a470:	e8 0a 01 0a 	sub	r10,r4,r10
8000a474:	e4 09 00 08 	add	r8,r2,r9
8000a478:	8f 54       	st.w	r7[0x14],r4
8000a47a:	8f 2a       	st.w	r7[0x8],r10
8000a47c:	8f 08       	st.w	r7[0x0],r8
8000a47e:	8f 42       	st.w	r7[0x10],r2
8000a480:	0c 94       	mov	r4,r6
8000a482:	08 36       	cp.w	r6,r4
8000a484:	ec 04 17 30 	movlo	r4,r6
8000a488:	06 9b       	mov	r11,r3
8000a48a:	08 9a       	mov	r10,r4
8000a48c:	6e 0c       	ld.w	r12,r7[0x0]
8000a48e:	c3 ad       	rcall	8000a702 <memmove>
8000a490:	6e 08       	ld.w	r8,r7[0x0]
8000a492:	08 08       	add	r8,r4
8000a494:	8f 08       	st.w	r7[0x0],r8
8000a496:	6e 28       	ld.w	r8,r7[0x8]
8000a498:	08 18       	sub	r8,r4
8000a49a:	0c 94       	mov	r4,r6
8000a49c:	8f 28       	st.w	r7[0x8],r8
8000a49e:	c2 e8       	rjmp	8000a4fa <__sfvwrite_r+0x1b2>
8000a4a0:	08 36       	cp.w	r6,r4
8000a4a2:	5f ba       	srhi	r10
8000a4a4:	6e 0c       	ld.w	r12,r7[0x0]
8000a4a6:	6e 48       	ld.w	r8,r7[0x10]
8000a4a8:	10 3c       	cp.w	r12,r8
8000a4aa:	5f b8       	srhi	r8
8000a4ac:	f5 e8 00 08 	and	r8,r10,r8
8000a4b0:	f2 08 18 00 	cp.b	r8,r9
8000a4b4:	c0 d0       	breq	8000a4ce <__sfvwrite_r+0x186>
8000a4b6:	06 9b       	mov	r11,r3
8000a4b8:	08 9a       	mov	r10,r4
8000a4ba:	c2 4d       	rcall	8000a702 <memmove>
8000a4bc:	6e 08       	ld.w	r8,r7[0x0]
8000a4be:	08 08       	add	r8,r4
8000a4c0:	0e 9b       	mov	r11,r7
8000a4c2:	8f 08       	st.w	r7[0x0],r8
8000a4c4:	0a 9c       	mov	r12,r5
8000a4c6:	fe b0 fd 09 	rcall	80009ed8 <_fflush_r>
8000a4ca:	c1 80       	breq	8000a4fa <__sfvwrite_r+0x1b2>
8000a4cc:	c8 08       	rjmp	8000a5cc <__sfvwrite_r+0x284>
8000a4ce:	6e 59       	ld.w	r9,r7[0x14]
8000a4d0:	12 36       	cp.w	r6,r9
8000a4d2:	c0 a3       	brcs	8000a4e6 <__sfvwrite_r+0x19e>
8000a4d4:	6e a8       	ld.w	r8,r7[0x28]
8000a4d6:	06 9a       	mov	r10,r3
8000a4d8:	6e 8b       	ld.w	r11,r7[0x20]
8000a4da:	0a 9c       	mov	r12,r5
8000a4dc:	5d 18       	icall	r8
8000a4de:	18 94       	mov	r4,r12
8000a4e0:	e0 89 00 0d 	brgt	8000a4fa <__sfvwrite_r+0x1b2>
8000a4e4:	c7 48       	rjmp	8000a5cc <__sfvwrite_r+0x284>
8000a4e6:	0c 9a       	mov	r10,r6
8000a4e8:	06 9b       	mov	r11,r3
8000a4ea:	c0 cd       	rcall	8000a702 <memmove>
8000a4ec:	6e 08       	ld.w	r8,r7[0x0]
8000a4ee:	0c 08       	add	r8,r6
8000a4f0:	0c 94       	mov	r4,r6
8000a4f2:	8f 08       	st.w	r7[0x0],r8
8000a4f4:	6e 28       	ld.w	r8,r7[0x8]
8000a4f6:	0c 18       	sub	r8,r6
8000a4f8:	8f 28       	st.w	r7[0x8],r8
8000a4fa:	62 28       	ld.w	r8,r1[0x8]
8000a4fc:	08 18       	sub	r8,r4
8000a4fe:	83 28       	st.w	r1[0x8],r8
8000a500:	c6 b0       	breq	8000a5d6 <__sfvwrite_r+0x28e>
8000a502:	08 16       	sub	r6,r4
8000a504:	08 03       	add	r3,r4
8000a506:	c7 1b       	rjmp	8000a3e8 <__sfvwrite_r+0xa0>
8000a508:	60 03       	ld.w	r3,r0[0x0]
8000a50a:	60 11       	ld.w	r1,r0[0x4]
8000a50c:	30 08       	mov	r8,0
8000a50e:	2f 80       	sub	r0,-8
8000a510:	50 08       	stdsp	sp[0x0],r8
8000a512:	58 01       	cp.w	r1,0
8000a514:	cf a0       	breq	8000a508 <__sfvwrite_r+0x1c0>
8000a516:	40 0a       	lddsp	r10,sp[0x0]
8000a518:	58 0a       	cp.w	r10,0
8000a51a:	c1 41       	brne	8000a542 <__sfvwrite_r+0x1fa>
8000a51c:	e2 c6 ff ff 	sub	r6,r1,-1
8000a520:	02 9a       	mov	r10,r1
8000a522:	30 ab       	mov	r11,10
8000a524:	06 9c       	mov	r12,r3
8000a526:	ce 3c       	rcall	8000a6ec <memchr>
8000a528:	f8 c8 ff ff 	sub	r8,r12,-1
8000a52c:	58 0c       	cp.w	r12,0
8000a52e:	f1 d3 e1 16 	subne	r6,r8,r3
8000a532:	f9 b9 01 01 	movne	r9,1
8000a536:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a53a:	f9 b8 00 01 	moveq	r8,1
8000a53e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a542:	02 36       	cp.w	r6,r1
8000a544:	ec 04 17 80 	movls	r4,r6
8000a548:	e2 04 17 b0 	movhi	r4,r1
8000a54c:	6e 59       	ld.w	r9,r7[0x14]
8000a54e:	6e 25       	ld.w	r5,r7[0x8]
8000a550:	f2 05 00 05 	add	r5,r9,r5
8000a554:	0a 34       	cp.w	r4,r5
8000a556:	5f 9a       	srgt	r10
8000a558:	6e 0c       	ld.w	r12,r7[0x0]
8000a55a:	6e 48       	ld.w	r8,r7[0x10]
8000a55c:	10 3c       	cp.w	r12,r8
8000a55e:	5f b8       	srhi	r8
8000a560:	f5 e8 00 08 	and	r8,r10,r8
8000a564:	30 0a       	mov	r10,0
8000a566:	f4 08 18 00 	cp.b	r8,r10
8000a56a:	c0 d0       	breq	8000a584 <__sfvwrite_r+0x23c>
8000a56c:	06 9b       	mov	r11,r3
8000a56e:	0a 9a       	mov	r10,r5
8000a570:	cc 9c       	rcall	8000a702 <memmove>
8000a572:	6e 08       	ld.w	r8,r7[0x0]
8000a574:	0a 08       	add	r8,r5
8000a576:	0e 9b       	mov	r11,r7
8000a578:	8f 08       	st.w	r7[0x0],r8
8000a57a:	40 1c       	lddsp	r12,sp[0x4]
8000a57c:	fe b0 fc ae 	rcall	80009ed8 <_fflush_r>
8000a580:	c1 70       	breq	8000a5ae <__sfvwrite_r+0x266>
8000a582:	c2 58       	rjmp	8000a5cc <__sfvwrite_r+0x284>
8000a584:	12 34       	cp.w	r4,r9
8000a586:	c0 a5       	brlt	8000a59a <__sfvwrite_r+0x252>
8000a588:	6e a8       	ld.w	r8,r7[0x28]
8000a58a:	06 9a       	mov	r10,r3
8000a58c:	6e 8b       	ld.w	r11,r7[0x20]
8000a58e:	40 1c       	lddsp	r12,sp[0x4]
8000a590:	5d 18       	icall	r8
8000a592:	18 95       	mov	r5,r12
8000a594:	e0 89 00 0d 	brgt	8000a5ae <__sfvwrite_r+0x266>
8000a598:	c1 a8       	rjmp	8000a5cc <__sfvwrite_r+0x284>
8000a59a:	08 9a       	mov	r10,r4
8000a59c:	06 9b       	mov	r11,r3
8000a59e:	cb 2c       	rcall	8000a702 <memmove>
8000a5a0:	6e 08       	ld.w	r8,r7[0x0]
8000a5a2:	08 08       	add	r8,r4
8000a5a4:	08 95       	mov	r5,r4
8000a5a6:	8f 08       	st.w	r7[0x0],r8
8000a5a8:	6e 28       	ld.w	r8,r7[0x8]
8000a5aa:	08 18       	sub	r8,r4
8000a5ac:	8f 28       	st.w	r7[0x8],r8
8000a5ae:	0a 16       	sub	r6,r5
8000a5b0:	c0 71       	brne	8000a5be <__sfvwrite_r+0x276>
8000a5b2:	0e 9b       	mov	r11,r7
8000a5b4:	40 1c       	lddsp	r12,sp[0x4]
8000a5b6:	fe b0 fc 91 	rcall	80009ed8 <_fflush_r>
8000a5ba:	c0 91       	brne	8000a5cc <__sfvwrite_r+0x284>
8000a5bc:	50 06       	stdsp	sp[0x0],r6
8000a5be:	64 28       	ld.w	r8,r2[0x8]
8000a5c0:	0a 18       	sub	r8,r5
8000a5c2:	85 28       	st.w	r2[0x8],r8
8000a5c4:	c0 90       	breq	8000a5d6 <__sfvwrite_r+0x28e>
8000a5c6:	0a 11       	sub	r1,r5
8000a5c8:	0a 03       	add	r3,r5
8000a5ca:	ca 4b       	rjmp	8000a512 <__sfvwrite_r+0x1ca>
8000a5cc:	8e 68       	ld.sh	r8,r7[0xc]
8000a5ce:	a7 a8       	sbr	r8,0x6
8000a5d0:	ae 68       	st.h	r7[0xc],r8
8000a5d2:	3f fc       	mov	r12,-1
8000a5d4:	c0 28       	rjmp	8000a5d8 <__sfvwrite_r+0x290>
8000a5d6:	30 0c       	mov	r12,0
8000a5d8:	2f dd       	sub	sp,-12
8000a5da:	d8 32       	popm	r0-r7,pc

8000a5dc <_fwalk>:
8000a5dc:	d4 31       	pushm	r0-r7,lr
8000a5de:	30 05       	mov	r5,0
8000a5e0:	16 91       	mov	r1,r11
8000a5e2:	f8 c7 ff 28 	sub	r7,r12,-216
8000a5e6:	0a 92       	mov	r2,r5
8000a5e8:	fe b0 fc fe 	rcall	80009fe4 <__sfp_lock_acquire>
8000a5ec:	3f f3       	mov	r3,-1
8000a5ee:	c1 68       	rjmp	8000a61a <_fwalk+0x3e>
8000a5f0:	6e 26       	ld.w	r6,r7[0x8]
8000a5f2:	6e 14       	ld.w	r4,r7[0x4]
8000a5f4:	2f 46       	sub	r6,-12
8000a5f6:	c0 c8       	rjmp	8000a60e <_fwalk+0x32>
8000a5f8:	8c 08       	ld.sh	r8,r6[0x0]
8000a5fa:	e4 08 19 00 	cp.h	r8,r2
8000a5fe:	c0 70       	breq	8000a60c <_fwalk+0x30>
8000a600:	8c 18       	ld.sh	r8,r6[0x2]
8000a602:	e6 08 19 00 	cp.h	r8,r3
8000a606:	c0 30       	breq	8000a60c <_fwalk+0x30>
8000a608:	5d 11       	icall	r1
8000a60a:	18 45       	or	r5,r12
8000a60c:	2a 46       	sub	r6,-92
8000a60e:	20 14       	sub	r4,1
8000a610:	ec cc 00 0c 	sub	r12,r6,12
8000a614:	58 04       	cp.w	r4,0
8000a616:	cf 14       	brge	8000a5f8 <_fwalk+0x1c>
8000a618:	6e 07       	ld.w	r7,r7[0x0]
8000a61a:	58 07       	cp.w	r7,0
8000a61c:	ce a1       	brne	8000a5f0 <_fwalk+0x14>
8000a61e:	fe b0 fc e4 	rcall	80009fe6 <__sfp_lock_release>
8000a622:	0a 9c       	mov	r12,r5
8000a624:	d8 32       	popm	r0-r7,pc
8000a626:	d7 03       	nop

8000a628 <_localeconv_r>:
8000a628:	fe cc d6 14 	sub	r12,pc,-10732
8000a62c:	5e fc       	retal	r12
8000a62e:	d7 03       	nop

8000a630 <__smakebuf_r>:
8000a630:	d4 21       	pushm	r4-r7,lr
8000a632:	20 fd       	sub	sp,60
8000a634:	96 68       	ld.sh	r8,r11[0xc]
8000a636:	16 97       	mov	r7,r11
8000a638:	18 96       	mov	r6,r12
8000a63a:	e2 18 00 02 	andl	r8,0x2,COH
8000a63e:	c3 d1       	brne	8000a6b8 <__smakebuf_r+0x88>
8000a640:	96 7b       	ld.sh	r11,r11[0xe]
8000a642:	f0 0b 19 00 	cp.h	r11,r8
8000a646:	c0 55       	brlt	8000a650 <__smakebuf_r+0x20>
8000a648:	1a 9a       	mov	r10,sp
8000a64a:	e0 a0 04 75 	rcall	8000af34 <_fstat_r>
8000a64e:	c0 f4       	brge	8000a66c <__smakebuf_r+0x3c>
8000a650:	8e 65       	ld.sh	r5,r7[0xc]
8000a652:	0a 98       	mov	r8,r5
8000a654:	ab b8       	sbr	r8,0xb
8000a656:	e2 15 00 80 	andl	r5,0x80,COH
8000a65a:	ae 68       	st.h	r7[0xc],r8
8000a65c:	30 04       	mov	r4,0
8000a65e:	e0 68 04 00 	mov	r8,1024
8000a662:	f9 b5 01 40 	movne	r5,64
8000a666:	f0 05 17 00 	moveq	r5,r8
8000a66a:	c1 c8       	rjmp	8000a6a2 <__smakebuf_r+0x72>
8000a66c:	40 18       	lddsp	r8,sp[0x4]
8000a66e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a672:	e0 48 20 00 	cp.w	r8,8192
8000a676:	5f 04       	sreq	r4
8000a678:	e0 48 80 00 	cp.w	r8,32768
8000a67c:	c0 e1       	brne	8000a698 <__smakebuf_r+0x68>
8000a67e:	6e b9       	ld.w	r9,r7[0x2c]
8000a680:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a684:	10 39       	cp.w	r9,r8
8000a686:	c0 91       	brne	8000a698 <__smakebuf_r+0x68>
8000a688:	8e 68       	ld.sh	r8,r7[0xc]
8000a68a:	e0 65 04 00 	mov	r5,1024
8000a68e:	ab a8       	sbr	r8,0xa
8000a690:	ef 45 00 50 	st.w	r7[80],r5
8000a694:	ae 68       	st.h	r7[0xc],r8
8000a696:	c0 68       	rjmp	8000a6a2 <__smakebuf_r+0x72>
8000a698:	8e 68       	ld.sh	r8,r7[0xc]
8000a69a:	e0 65 04 00 	mov	r5,1024
8000a69e:	ab b8       	sbr	r8,0xb
8000a6a0:	ae 68       	st.h	r7[0xc],r8
8000a6a2:	0a 9b       	mov	r11,r5
8000a6a4:	0c 9c       	mov	r12,r6
8000a6a6:	fe b0 df 29 	rcall	800064f8 <_malloc_r>
8000a6aa:	8e 68       	ld.sh	r8,r7[0xc]
8000a6ac:	c0 d1       	brne	8000a6c6 <__smakebuf_r+0x96>
8000a6ae:	ed b8 00 09 	bld	r8,0x9
8000a6b2:	c1 b0       	breq	8000a6e8 <__smakebuf_r+0xb8>
8000a6b4:	a1 b8       	sbr	r8,0x1
8000a6b6:	ae 68       	st.h	r7[0xc],r8
8000a6b8:	ee c8 ff b9 	sub	r8,r7,-71
8000a6bc:	8f 48       	st.w	r7[0x10],r8
8000a6be:	8f 08       	st.w	r7[0x0],r8
8000a6c0:	30 18       	mov	r8,1
8000a6c2:	8f 58       	st.w	r7[0x14],r8
8000a6c4:	c1 28       	rjmp	8000a6e8 <__smakebuf_r+0xb8>
8000a6c6:	a7 b8       	sbr	r8,0x7
8000a6c8:	8f 4c       	st.w	r7[0x10],r12
8000a6ca:	ae 68       	st.h	r7[0xc],r8
8000a6cc:	8f 55       	st.w	r7[0x14],r5
8000a6ce:	fe c8 06 e6 	sub	r8,pc,1766
8000a6d2:	8f 0c       	st.w	r7[0x0],r12
8000a6d4:	8d a8       	st.w	r6[0x28],r8
8000a6d6:	58 04       	cp.w	r4,0
8000a6d8:	c0 80       	breq	8000a6e8 <__smakebuf_r+0xb8>
8000a6da:	8e 7c       	ld.sh	r12,r7[0xe]
8000a6dc:	fe b0 e3 94 	rcall	80006e04 <isatty>
8000a6e0:	c0 40       	breq	8000a6e8 <__smakebuf_r+0xb8>
8000a6e2:	8e 68       	ld.sh	r8,r7[0xc]
8000a6e4:	a1 a8       	sbr	r8,0x0
8000a6e6:	ae 68       	st.h	r7[0xc],r8
8000a6e8:	2f 1d       	sub	sp,-60
8000a6ea:	d8 22       	popm	r4-r7,pc

8000a6ec <memchr>:
8000a6ec:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a6f0:	c0 68       	rjmp	8000a6fc <memchr+0x10>
8000a6f2:	20 1a       	sub	r10,1
8000a6f4:	19 88       	ld.ub	r8,r12[0x0]
8000a6f6:	16 38       	cp.w	r8,r11
8000a6f8:	5e 0c       	reteq	r12
8000a6fa:	2f fc       	sub	r12,-1
8000a6fc:	58 0a       	cp.w	r10,0
8000a6fe:	cf a1       	brne	8000a6f2 <memchr+0x6>
8000a700:	5e fa       	retal	r10

8000a702 <memmove>:
8000a702:	d4 01       	pushm	lr
8000a704:	18 3b       	cp.w	r11,r12
8000a706:	c1 92       	brcc	8000a738 <memmove+0x36>
8000a708:	f6 0a 00 09 	add	r9,r11,r10
8000a70c:	12 3c       	cp.w	r12,r9
8000a70e:	c1 52       	brcc	8000a738 <memmove+0x36>
8000a710:	f8 0a 00 0b 	add	r11,r12,r10
8000a714:	30 08       	mov	r8,0
8000a716:	c0 68       	rjmp	8000a722 <memmove+0x20>
8000a718:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a71c:	20 1a       	sub	r10,1
8000a71e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a722:	20 18       	sub	r8,1
8000a724:	58 0a       	cp.w	r10,0
8000a726:	cf 91       	brne	8000a718 <memmove+0x16>
8000a728:	d8 02       	popm	pc
8000a72a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a72e:	20 1a       	sub	r10,1
8000a730:	f8 08 0b 09 	st.b	r12[r8],r9
8000a734:	2f f8       	sub	r8,-1
8000a736:	c0 28       	rjmp	8000a73a <memmove+0x38>
8000a738:	30 08       	mov	r8,0
8000a73a:	58 0a       	cp.w	r10,0
8000a73c:	cf 71       	brne	8000a72a <memmove+0x28>
8000a73e:	d8 02       	popm	pc

8000a740 <__hi0bits>:
8000a740:	18 98       	mov	r8,r12
8000a742:	e0 1c 00 00 	andl	r12,0x0
8000a746:	f0 09 15 10 	lsl	r9,r8,0x10
8000a74a:	58 0c       	cp.w	r12,0
8000a74c:	f2 08 17 00 	moveq	r8,r9
8000a750:	f9 bc 00 10 	moveq	r12,16
8000a754:	f9 bc 01 00 	movne	r12,0
8000a758:	10 9a       	mov	r10,r8
8000a75a:	f0 09 15 08 	lsl	r9,r8,0x8
8000a75e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a762:	f7 bc 00 f8 	subeq	r12,-8
8000a766:	f2 08 17 00 	moveq	r8,r9
8000a76a:	10 9a       	mov	r10,r8
8000a76c:	f0 09 15 04 	lsl	r9,r8,0x4
8000a770:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a774:	f7 bc 00 fc 	subeq	r12,-4
8000a778:	f2 08 17 00 	moveq	r8,r9
8000a77c:	10 9a       	mov	r10,r8
8000a77e:	f0 09 15 02 	lsl	r9,r8,0x2
8000a782:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a786:	f7 bc 00 fe 	subeq	r12,-2
8000a78a:	f2 08 17 00 	moveq	r8,r9
8000a78e:	58 08       	cp.w	r8,0
8000a790:	5e 5c       	retlt	r12
8000a792:	ed b8 00 1e 	bld	r8,0x1e
8000a796:	f9 bc 01 20 	movne	r12,32
8000a79a:	f7 bc 00 ff 	subeq	r12,-1
8000a79e:	5e fc       	retal	r12

8000a7a0 <__lo0bits>:
8000a7a0:	18 99       	mov	r9,r12
8000a7a2:	78 08       	ld.w	r8,r12[0x0]
8000a7a4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a7a8:	c1 50       	breq	8000a7d2 <__lo0bits+0x32>
8000a7aa:	ed b8 00 00 	bld	r8,0x0
8000a7ae:	c0 21       	brne	8000a7b2 <__lo0bits+0x12>
8000a7b0:	5e fd       	retal	0
8000a7b2:	10 9b       	mov	r11,r8
8000a7b4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a7b8:	e2 1b 00 02 	andl	r11,0x2,COH
8000a7bc:	a3 88       	lsr	r8,0x2
8000a7be:	58 0b       	cp.w	r11,0
8000a7c0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a7c4:	f9 bc 01 01 	movne	r12,1
8000a7c8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a7cc:	f9 bc 00 02 	moveq	r12,2
8000a7d0:	5e fc       	retal	r12
8000a7d2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a7d6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a7da:	58 0a       	cp.w	r10,0
8000a7dc:	f6 08 17 00 	moveq	r8,r11
8000a7e0:	f9 bc 00 10 	moveq	r12,16
8000a7e4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a7e8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a7ec:	58 0b       	cp.w	r11,0
8000a7ee:	f7 bc 00 f8 	subeq	r12,-8
8000a7f2:	f4 08 17 00 	moveq	r8,r10
8000a7f6:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a7fa:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a7fe:	58 0b       	cp.w	r11,0
8000a800:	f7 bc 00 fc 	subeq	r12,-4
8000a804:	f4 08 17 00 	moveq	r8,r10
8000a808:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a80c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a810:	58 0b       	cp.w	r11,0
8000a812:	f7 bc 00 fe 	subeq	r12,-2
8000a816:	f4 08 17 00 	moveq	r8,r10
8000a81a:	ed b8 00 00 	bld	r8,0x0
8000a81e:	c0 60       	breq	8000a82a <__lo0bits+0x8a>
8000a820:	a1 98       	lsr	r8,0x1
8000a822:	c0 31       	brne	8000a828 <__lo0bits+0x88>
8000a824:	32 0c       	mov	r12,32
8000a826:	5e fc       	retal	r12
8000a828:	2f fc       	sub	r12,-1
8000a82a:	93 08       	st.w	r9[0x0],r8
8000a82c:	5e fc       	retal	r12

8000a82e <__mcmp>:
8000a82e:	d4 01       	pushm	lr
8000a830:	18 98       	mov	r8,r12
8000a832:	76 49       	ld.w	r9,r11[0x10]
8000a834:	78 4c       	ld.w	r12,r12[0x10]
8000a836:	12 1c       	sub	r12,r9
8000a838:	c1 31       	brne	8000a85e <__mcmp+0x30>
8000a83a:	2f b9       	sub	r9,-5
8000a83c:	a3 69       	lsl	r9,0x2
8000a83e:	12 0b       	add	r11,r9
8000a840:	f0 09 00 09 	add	r9,r8,r9
8000a844:	2e c8       	sub	r8,-20
8000a846:	13 4e       	ld.w	lr,--r9
8000a848:	17 4a       	ld.w	r10,--r11
8000a84a:	14 3e       	cp.w	lr,r10
8000a84c:	c0 60       	breq	8000a858 <__mcmp+0x2a>
8000a84e:	f9 bc 03 ff 	movlo	r12,-1
8000a852:	f9 bc 02 01 	movhs	r12,1
8000a856:	d8 02       	popm	pc
8000a858:	10 39       	cp.w	r9,r8
8000a85a:	fe 9b ff f6 	brhi	8000a846 <__mcmp+0x18>
8000a85e:	d8 02       	popm	pc

8000a860 <_Bfree>:
8000a860:	d4 21       	pushm	r4-r7,lr
8000a862:	18 97       	mov	r7,r12
8000a864:	16 95       	mov	r5,r11
8000a866:	78 96       	ld.w	r6,r12[0x24]
8000a868:	58 06       	cp.w	r6,0
8000a86a:	c0 91       	brne	8000a87c <_Bfree+0x1c>
8000a86c:	31 0c       	mov	r12,16
8000a86e:	fe b0 de 3d 	rcall	800064e8 <malloc>
8000a872:	99 36       	st.w	r12[0xc],r6
8000a874:	8f 9c       	st.w	r7[0x24],r12
8000a876:	99 16       	st.w	r12[0x4],r6
8000a878:	99 26       	st.w	r12[0x8],r6
8000a87a:	99 06       	st.w	r12[0x0],r6
8000a87c:	58 05       	cp.w	r5,0
8000a87e:	c0 90       	breq	8000a890 <_Bfree+0x30>
8000a880:	6a 19       	ld.w	r9,r5[0x4]
8000a882:	6e 98       	ld.w	r8,r7[0x24]
8000a884:	70 38       	ld.w	r8,r8[0xc]
8000a886:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a88a:	8b 0a       	st.w	r5[0x0],r10
8000a88c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a890:	d8 22       	popm	r4-r7,pc
8000a892:	d7 03       	nop

8000a894 <_Balloc>:
8000a894:	d4 21       	pushm	r4-r7,lr
8000a896:	18 97       	mov	r7,r12
8000a898:	16 96       	mov	r6,r11
8000a89a:	78 95       	ld.w	r5,r12[0x24]
8000a89c:	58 05       	cp.w	r5,0
8000a89e:	c0 91       	brne	8000a8b0 <_Balloc+0x1c>
8000a8a0:	31 0c       	mov	r12,16
8000a8a2:	fe b0 de 23 	rcall	800064e8 <malloc>
8000a8a6:	99 35       	st.w	r12[0xc],r5
8000a8a8:	8f 9c       	st.w	r7[0x24],r12
8000a8aa:	99 15       	st.w	r12[0x4],r5
8000a8ac:	99 25       	st.w	r12[0x8],r5
8000a8ae:	99 05       	st.w	r12[0x0],r5
8000a8b0:	6e 95       	ld.w	r5,r7[0x24]
8000a8b2:	6a 38       	ld.w	r8,r5[0xc]
8000a8b4:	58 08       	cp.w	r8,0
8000a8b6:	c0 b1       	brne	8000a8cc <_Balloc+0x38>
8000a8b8:	31 0a       	mov	r10,16
8000a8ba:	30 4b       	mov	r11,4
8000a8bc:	0e 9c       	mov	r12,r7
8000a8be:	e0 a0 02 9b 	rcall	8000adf4 <_calloc_r>
8000a8c2:	8b 3c       	st.w	r5[0xc],r12
8000a8c4:	6e 98       	ld.w	r8,r7[0x24]
8000a8c6:	70 3c       	ld.w	r12,r8[0xc]
8000a8c8:	58 0c       	cp.w	r12,0
8000a8ca:	c1 b0       	breq	8000a900 <_Balloc+0x6c>
8000a8cc:	6e 98       	ld.w	r8,r7[0x24]
8000a8ce:	70 38       	ld.w	r8,r8[0xc]
8000a8d0:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a8d4:	70 0c       	ld.w	r12,r8[0x0]
8000a8d6:	58 0c       	cp.w	r12,0
8000a8d8:	c0 40       	breq	8000a8e0 <_Balloc+0x4c>
8000a8da:	78 09       	ld.w	r9,r12[0x0]
8000a8dc:	91 09       	st.w	r8[0x0],r9
8000a8de:	c0 e8       	rjmp	8000a8fa <_Balloc+0x66>
8000a8e0:	0e 9c       	mov	r12,r7
8000a8e2:	30 17       	mov	r7,1
8000a8e4:	0e 9b       	mov	r11,r7
8000a8e6:	ee 06 09 47 	lsl	r7,r7,r6
8000a8ea:	ee ca ff fb 	sub	r10,r7,-5
8000a8ee:	a3 6a       	lsl	r10,0x2
8000a8f0:	e0 a0 02 82 	rcall	8000adf4 <_calloc_r>
8000a8f4:	c0 60       	breq	8000a900 <_Balloc+0x6c>
8000a8f6:	99 16       	st.w	r12[0x4],r6
8000a8f8:	99 27       	st.w	r12[0x8],r7
8000a8fa:	30 08       	mov	r8,0
8000a8fc:	99 38       	st.w	r12[0xc],r8
8000a8fe:	99 48       	st.w	r12[0x10],r8
8000a900:	d8 22       	popm	r4-r7,pc
8000a902:	d7 03       	nop

8000a904 <__d2b>:
8000a904:	d4 31       	pushm	r0-r7,lr
8000a906:	20 2d       	sub	sp,8
8000a908:	16 93       	mov	r3,r11
8000a90a:	12 96       	mov	r6,r9
8000a90c:	10 95       	mov	r5,r8
8000a90e:	14 92       	mov	r2,r10
8000a910:	30 1b       	mov	r11,1
8000a912:	cc 1f       	rcall	8000a894 <_Balloc>
8000a914:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a918:	50 09       	stdsp	sp[0x0],r9
8000a91a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a91e:	b5 a9       	sbr	r9,0x14
8000a920:	f0 01 16 14 	lsr	r1,r8,0x14
8000a924:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a928:	18 94       	mov	r4,r12
8000a92a:	58 02       	cp.w	r2,0
8000a92c:	c1 d0       	breq	8000a966 <__d2b+0x62>
8000a92e:	fa cc ff f8 	sub	r12,sp,-8
8000a932:	18 d2       	st.w	--r12,r2
8000a934:	c3 6f       	rcall	8000a7a0 <__lo0bits>
8000a936:	40 18       	lddsp	r8,sp[0x4]
8000a938:	c0 d0       	breq	8000a952 <__d2b+0x4e>
8000a93a:	40 09       	lddsp	r9,sp[0x0]
8000a93c:	f8 0a 11 20 	rsub	r10,r12,32
8000a940:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a944:	f5 e8 10 08 	or	r8,r10,r8
8000a948:	89 58       	st.w	r4[0x14],r8
8000a94a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a94e:	50 09       	stdsp	sp[0x0],r9
8000a950:	c0 28       	rjmp	8000a954 <__d2b+0x50>
8000a952:	89 58       	st.w	r4[0x14],r8
8000a954:	40 08       	lddsp	r8,sp[0x0]
8000a956:	58 08       	cp.w	r8,0
8000a958:	f9 b3 01 02 	movne	r3,2
8000a95c:	f9 b3 00 01 	moveq	r3,1
8000a960:	89 68       	st.w	r4[0x18],r8
8000a962:	89 43       	st.w	r4[0x10],r3
8000a964:	c0 88       	rjmp	8000a974 <__d2b+0x70>
8000a966:	1a 9c       	mov	r12,sp
8000a968:	c1 cf       	rcall	8000a7a0 <__lo0bits>
8000a96a:	30 13       	mov	r3,1
8000a96c:	40 08       	lddsp	r8,sp[0x0]
8000a96e:	2e 0c       	sub	r12,-32
8000a970:	89 43       	st.w	r4[0x10],r3
8000a972:	89 58       	st.w	r4[0x14],r8
8000a974:	58 01       	cp.w	r1,0
8000a976:	c0 90       	breq	8000a988 <__d2b+0x84>
8000a978:	e2 c1 04 33 	sub	r1,r1,1075
8000a97c:	18 01       	add	r1,r12
8000a97e:	8d 01       	st.w	r6[0x0],r1
8000a980:	f8 0c 11 35 	rsub	r12,r12,53
8000a984:	8b 0c       	st.w	r5[0x0],r12
8000a986:	c0 c8       	rjmp	8000a99e <__d2b+0x9a>
8000a988:	e6 c8 ff fc 	sub	r8,r3,-4
8000a98c:	f8 cc 04 32 	sub	r12,r12,1074
8000a990:	a5 73       	lsl	r3,0x5
8000a992:	8d 0c       	st.w	r6[0x0],r12
8000a994:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a998:	cd 4e       	rcall	8000a740 <__hi0bits>
8000a99a:	18 13       	sub	r3,r12
8000a99c:	8b 03       	st.w	r5[0x0],r3
8000a99e:	08 9c       	mov	r12,r4
8000a9a0:	2f ed       	sub	sp,-8
8000a9a2:	d8 32       	popm	r0-r7,pc

8000a9a4 <__mdiff>:
8000a9a4:	d4 31       	pushm	r0-r7,lr
8000a9a6:	74 48       	ld.w	r8,r10[0x10]
8000a9a8:	76 45       	ld.w	r5,r11[0x10]
8000a9aa:	16 97       	mov	r7,r11
8000a9ac:	14 96       	mov	r6,r10
8000a9ae:	10 15       	sub	r5,r8
8000a9b0:	c1 31       	brne	8000a9d6 <__mdiff+0x32>
8000a9b2:	2f b8       	sub	r8,-5
8000a9b4:	ee ce ff ec 	sub	lr,r7,-20
8000a9b8:	a3 68       	lsl	r8,0x2
8000a9ba:	f4 08 00 0b 	add	r11,r10,r8
8000a9be:	ee 08 00 08 	add	r8,r7,r8
8000a9c2:	11 4a       	ld.w	r10,--r8
8000a9c4:	17 49       	ld.w	r9,--r11
8000a9c6:	12 3a       	cp.w	r10,r9
8000a9c8:	c0 30       	breq	8000a9ce <__mdiff+0x2a>
8000a9ca:	c0 e2       	brcc	8000a9e6 <__mdiff+0x42>
8000a9cc:	c0 78       	rjmp	8000a9da <__mdiff+0x36>
8000a9ce:	1c 38       	cp.w	r8,lr
8000a9d0:	fe 9b ff f9 	brhi	8000a9c2 <__mdiff+0x1e>
8000a9d4:	c4 98       	rjmp	8000aa66 <__mdiff+0xc2>
8000a9d6:	58 05       	cp.w	r5,0
8000a9d8:	c0 64       	brge	8000a9e4 <__mdiff+0x40>
8000a9da:	0e 98       	mov	r8,r7
8000a9dc:	30 15       	mov	r5,1
8000a9de:	0c 97       	mov	r7,r6
8000a9e0:	10 96       	mov	r6,r8
8000a9e2:	c0 28       	rjmp	8000a9e6 <__mdiff+0x42>
8000a9e4:	30 05       	mov	r5,0
8000a9e6:	6e 1b       	ld.w	r11,r7[0x4]
8000a9e8:	c5 6f       	rcall	8000a894 <_Balloc>
8000a9ea:	6e 49       	ld.w	r9,r7[0x10]
8000a9ec:	6c 44       	ld.w	r4,r6[0x10]
8000a9ee:	99 35       	st.w	r12[0xc],r5
8000a9f0:	2f b4       	sub	r4,-5
8000a9f2:	f2 c5 ff fb 	sub	r5,r9,-5
8000a9f6:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a9fa:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a9fe:	2e c6       	sub	r6,-20
8000aa00:	2e c7       	sub	r7,-20
8000aa02:	f8 c8 ff ec 	sub	r8,r12,-20
8000aa06:	30 0a       	mov	r10,0
8000aa08:	0f 0e       	ld.w	lr,r7++
8000aa0a:	0d 0b       	ld.w	r11,r6++
8000aa0c:	fc 02 16 10 	lsr	r2,lr,0x10
8000aa10:	f6 03 16 10 	lsr	r3,r11,0x10
8000aa14:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000aa18:	e4 03 01 03 	sub	r3,r2,r3
8000aa1c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa20:	fc 0b 01 0b 	sub	r11,lr,r11
8000aa24:	f6 0a 00 0a 	add	r10,r11,r10
8000aa28:	b0 1a       	st.h	r8[0x2],r10
8000aa2a:	b1 4a       	asr	r10,0x10
8000aa2c:	e6 0a 00 0a 	add	r10,r3,r10
8000aa30:	b0 0a       	st.h	r8[0x0],r10
8000aa32:	2f c8       	sub	r8,-4
8000aa34:	b1 4a       	asr	r10,0x10
8000aa36:	08 36       	cp.w	r6,r4
8000aa38:	ce 83       	brcs	8000aa08 <__mdiff+0x64>
8000aa3a:	c0 d8       	rjmp	8000aa54 <__mdiff+0xb0>
8000aa3c:	0f 0b       	ld.w	r11,r7++
8000aa3e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000aa42:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aa46:	16 0a       	add	r10,r11
8000aa48:	b0 1a       	st.h	r8[0x2],r10
8000aa4a:	b1 4a       	asr	r10,0x10
8000aa4c:	1c 0a       	add	r10,lr
8000aa4e:	b0 0a       	st.h	r8[0x0],r10
8000aa50:	2f c8       	sub	r8,-4
8000aa52:	b1 4a       	asr	r10,0x10
8000aa54:	0a 37       	cp.w	r7,r5
8000aa56:	cf 33       	brcs	8000aa3c <__mdiff+0x98>
8000aa58:	c0 28       	rjmp	8000aa5c <__mdiff+0xb8>
8000aa5a:	20 19       	sub	r9,1
8000aa5c:	11 4a       	ld.w	r10,--r8
8000aa5e:	58 0a       	cp.w	r10,0
8000aa60:	cf d0       	breq	8000aa5a <__mdiff+0xb6>
8000aa62:	99 49       	st.w	r12[0x10],r9
8000aa64:	d8 32       	popm	r0-r7,pc
8000aa66:	30 0b       	mov	r11,0
8000aa68:	c1 6f       	rcall	8000a894 <_Balloc>
8000aa6a:	30 18       	mov	r8,1
8000aa6c:	99 48       	st.w	r12[0x10],r8
8000aa6e:	30 08       	mov	r8,0
8000aa70:	99 58       	st.w	r12[0x14],r8
8000aa72:	d8 32       	popm	r0-r7,pc

8000aa74 <__lshift>:
8000aa74:	d4 31       	pushm	r0-r7,lr
8000aa76:	16 97       	mov	r7,r11
8000aa78:	76 46       	ld.w	r6,r11[0x10]
8000aa7a:	f4 02 14 05 	asr	r2,r10,0x5
8000aa7e:	2f f6       	sub	r6,-1
8000aa80:	14 93       	mov	r3,r10
8000aa82:	18 94       	mov	r4,r12
8000aa84:	04 06       	add	r6,r2
8000aa86:	76 1b       	ld.w	r11,r11[0x4]
8000aa88:	6e 28       	ld.w	r8,r7[0x8]
8000aa8a:	c0 38       	rjmp	8000aa90 <__lshift+0x1c>
8000aa8c:	2f fb       	sub	r11,-1
8000aa8e:	a1 78       	lsl	r8,0x1
8000aa90:	10 36       	cp.w	r6,r8
8000aa92:	fe 99 ff fd 	brgt	8000aa8c <__lshift+0x18>
8000aa96:	08 9c       	mov	r12,r4
8000aa98:	cf ee       	rcall	8000a894 <_Balloc>
8000aa9a:	30 09       	mov	r9,0
8000aa9c:	18 95       	mov	r5,r12
8000aa9e:	f8 c8 ff ec 	sub	r8,r12,-20
8000aaa2:	12 9a       	mov	r10,r9
8000aaa4:	c0 38       	rjmp	8000aaaa <__lshift+0x36>
8000aaa6:	10 aa       	st.w	r8++,r10
8000aaa8:	2f f9       	sub	r9,-1
8000aaaa:	04 39       	cp.w	r9,r2
8000aaac:	cf d5       	brlt	8000aaa6 <__lshift+0x32>
8000aaae:	6e 4b       	ld.w	r11,r7[0x10]
8000aab0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000aab4:	2f bb       	sub	r11,-5
8000aab6:	ee c9 ff ec 	sub	r9,r7,-20
8000aaba:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000aabe:	58 03       	cp.w	r3,0
8000aac0:	c1 30       	breq	8000aae6 <__lshift+0x72>
8000aac2:	e6 0c 11 20 	rsub	r12,r3,32
8000aac6:	30 0a       	mov	r10,0
8000aac8:	72 02       	ld.w	r2,r9[0x0]
8000aaca:	e4 03 09 42 	lsl	r2,r2,r3
8000aace:	04 4a       	or	r10,r2
8000aad0:	10 aa       	st.w	r8++,r10
8000aad2:	13 0a       	ld.w	r10,r9++
8000aad4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000aad8:	16 39       	cp.w	r9,r11
8000aada:	cf 73       	brcs	8000aac8 <__lshift+0x54>
8000aadc:	91 0a       	st.w	r8[0x0],r10
8000aade:	58 0a       	cp.w	r10,0
8000aae0:	c0 70       	breq	8000aaee <__lshift+0x7a>
8000aae2:	2f f6       	sub	r6,-1
8000aae4:	c0 58       	rjmp	8000aaee <__lshift+0x7a>
8000aae6:	13 0a       	ld.w	r10,r9++
8000aae8:	10 aa       	st.w	r8++,r10
8000aaea:	16 39       	cp.w	r9,r11
8000aaec:	cf d3       	brcs	8000aae6 <__lshift+0x72>
8000aaee:	08 9c       	mov	r12,r4
8000aaf0:	20 16       	sub	r6,1
8000aaf2:	0e 9b       	mov	r11,r7
8000aaf4:	8b 46       	st.w	r5[0x10],r6
8000aaf6:	cb 5e       	rcall	8000a860 <_Bfree>
8000aaf8:	0a 9c       	mov	r12,r5
8000aafa:	d8 32       	popm	r0-r7,pc

8000aafc <__multiply>:
8000aafc:	d4 31       	pushm	r0-r7,lr
8000aafe:	20 2d       	sub	sp,8
8000ab00:	76 49       	ld.w	r9,r11[0x10]
8000ab02:	74 48       	ld.w	r8,r10[0x10]
8000ab04:	16 96       	mov	r6,r11
8000ab06:	14 95       	mov	r5,r10
8000ab08:	10 39       	cp.w	r9,r8
8000ab0a:	ec 08 17 50 	movlt	r8,r6
8000ab0e:	ea 06 17 50 	movlt	r6,r5
8000ab12:	f0 05 17 50 	movlt	r5,r8
8000ab16:	6c 28       	ld.w	r8,r6[0x8]
8000ab18:	76 43       	ld.w	r3,r11[0x10]
8000ab1a:	74 42       	ld.w	r2,r10[0x10]
8000ab1c:	76 1b       	ld.w	r11,r11[0x4]
8000ab1e:	e4 03 00 07 	add	r7,r2,r3
8000ab22:	10 37       	cp.w	r7,r8
8000ab24:	f7 bb 09 ff 	subgt	r11,-1
8000ab28:	cb 6e       	rcall	8000a894 <_Balloc>
8000ab2a:	ee c4 ff fb 	sub	r4,r7,-5
8000ab2e:	f8 c9 ff ec 	sub	r9,r12,-20
8000ab32:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ab36:	30 0a       	mov	r10,0
8000ab38:	12 98       	mov	r8,r9
8000ab3a:	c0 28       	rjmp	8000ab3e <__multiply+0x42>
8000ab3c:	10 aa       	st.w	r8++,r10
8000ab3e:	08 38       	cp.w	r8,r4
8000ab40:	cf e3       	brcs	8000ab3c <__multiply+0x40>
8000ab42:	2f b3       	sub	r3,-5
8000ab44:	2f b2       	sub	r2,-5
8000ab46:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ab4a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ab4e:	ec cb ff ec 	sub	r11,r6,-20
8000ab52:	50 12       	stdsp	sp[0x4],r2
8000ab54:	ea ca ff ec 	sub	r10,r5,-20
8000ab58:	c4 48       	rjmp	8000abe0 <__multiply+0xe4>
8000ab5a:	94 95       	ld.uh	r5,r10[0x2]
8000ab5c:	58 05       	cp.w	r5,0
8000ab5e:	c2 00       	breq	8000ab9e <__multiply+0xa2>
8000ab60:	12 98       	mov	r8,r9
8000ab62:	16 96       	mov	r6,r11
8000ab64:	30 0e       	mov	lr,0
8000ab66:	50 09       	stdsp	sp[0x0],r9
8000ab68:	0d 02       	ld.w	r2,r6++
8000ab6a:	e4 00 16 10 	lsr	r0,r2,0x10
8000ab6e:	70 01       	ld.w	r1,r8[0x0]
8000ab70:	70 09       	ld.w	r9,r8[0x0]
8000ab72:	b1 81       	lsr	r1,0x10
8000ab74:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ab78:	e0 05 03 41 	mac	r1,r0,r5
8000ab7c:	ab 32       	mul	r2,r5
8000ab7e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ab82:	00 02       	add	r2,r0
8000ab84:	e4 0e 00 0e 	add	lr,r2,lr
8000ab88:	b0 1e       	st.h	r8[0x2],lr
8000ab8a:	b1 8e       	lsr	lr,0x10
8000ab8c:	1c 01       	add	r1,lr
8000ab8e:	b0 01       	st.h	r8[0x0],r1
8000ab90:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ab94:	2f c8       	sub	r8,-4
8000ab96:	06 36       	cp.w	r6,r3
8000ab98:	ce 83       	brcs	8000ab68 <__multiply+0x6c>
8000ab9a:	40 09       	lddsp	r9,sp[0x0]
8000ab9c:	91 0e       	st.w	r8[0x0],lr
8000ab9e:	94 86       	ld.uh	r6,r10[0x0]
8000aba0:	58 06       	cp.w	r6,0
8000aba2:	c1 d0       	breq	8000abdc <__multiply+0xe0>
8000aba4:	72 02       	ld.w	r2,r9[0x0]
8000aba6:	12 98       	mov	r8,r9
8000aba8:	16 9e       	mov	lr,r11
8000abaa:	30 05       	mov	r5,0
8000abac:	b0 12       	st.h	r8[0x2],r2
8000abae:	1d 01       	ld.w	r1,lr++
8000abb0:	90 82       	ld.uh	r2,r8[0x0]
8000abb2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000abb6:	ad 30       	mul	r0,r6
8000abb8:	e0 02 00 02 	add	r2,r0,r2
8000abbc:	e4 05 00 05 	add	r5,r2,r5
8000abc0:	b0 05       	st.h	r8[0x0],r5
8000abc2:	b1 85       	lsr	r5,0x10
8000abc4:	b1 81       	lsr	r1,0x10
8000abc6:	2f c8       	sub	r8,-4
8000abc8:	ad 31       	mul	r1,r6
8000abca:	90 92       	ld.uh	r2,r8[0x2]
8000abcc:	e2 02 00 02 	add	r2,r1,r2
8000abd0:	0a 02       	add	r2,r5
8000abd2:	e4 05 16 10 	lsr	r5,r2,0x10
8000abd6:	06 3e       	cp.w	lr,r3
8000abd8:	ce a3       	brcs	8000abac <__multiply+0xb0>
8000abda:	91 02       	st.w	r8[0x0],r2
8000abdc:	2f ca       	sub	r10,-4
8000abde:	2f c9       	sub	r9,-4
8000abe0:	40 18       	lddsp	r8,sp[0x4]
8000abe2:	10 3a       	cp.w	r10,r8
8000abe4:	cb b3       	brcs	8000ab5a <__multiply+0x5e>
8000abe6:	c0 28       	rjmp	8000abea <__multiply+0xee>
8000abe8:	20 17       	sub	r7,1
8000abea:	58 07       	cp.w	r7,0
8000abec:	e0 8a 00 05 	brle	8000abf6 <__multiply+0xfa>
8000abf0:	09 48       	ld.w	r8,--r4
8000abf2:	58 08       	cp.w	r8,0
8000abf4:	cf a0       	breq	8000abe8 <__multiply+0xec>
8000abf6:	99 47       	st.w	r12[0x10],r7
8000abf8:	2f ed       	sub	sp,-8
8000abfa:	d8 32       	popm	r0-r7,pc

8000abfc <__i2b>:
8000abfc:	d4 21       	pushm	r4-r7,lr
8000abfe:	16 97       	mov	r7,r11
8000ac00:	30 1b       	mov	r11,1
8000ac02:	c4 9e       	rcall	8000a894 <_Balloc>
8000ac04:	30 19       	mov	r9,1
8000ac06:	99 57       	st.w	r12[0x14],r7
8000ac08:	99 49       	st.w	r12[0x10],r9
8000ac0a:	d8 22       	popm	r4-r7,pc

8000ac0c <__multadd>:
8000ac0c:	d4 31       	pushm	r0-r7,lr
8000ac0e:	30 08       	mov	r8,0
8000ac10:	12 95       	mov	r5,r9
8000ac12:	16 97       	mov	r7,r11
8000ac14:	18 96       	mov	r6,r12
8000ac16:	76 44       	ld.w	r4,r11[0x10]
8000ac18:	f6 c9 ff ec 	sub	r9,r11,-20
8000ac1c:	72 0b       	ld.w	r11,r9[0x0]
8000ac1e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ac22:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ac26:	f4 0c 02 4c 	mul	r12,r10,r12
8000ac2a:	f4 0b 03 45 	mac	r5,r10,r11
8000ac2e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ac32:	b1 85       	lsr	r5,0x10
8000ac34:	18 05       	add	r5,r12
8000ac36:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ac3a:	f8 0b 00 0b 	add	r11,r12,r11
8000ac3e:	12 ab       	st.w	r9++,r11
8000ac40:	2f f8       	sub	r8,-1
8000ac42:	b1 85       	lsr	r5,0x10
8000ac44:	08 38       	cp.w	r8,r4
8000ac46:	ce b5       	brlt	8000ac1c <__multadd+0x10>
8000ac48:	58 05       	cp.w	r5,0
8000ac4a:	c1 c0       	breq	8000ac82 <__multadd+0x76>
8000ac4c:	6e 28       	ld.w	r8,r7[0x8]
8000ac4e:	10 34       	cp.w	r4,r8
8000ac50:	c1 35       	brlt	8000ac76 <__multadd+0x6a>
8000ac52:	6e 1b       	ld.w	r11,r7[0x4]
8000ac54:	0c 9c       	mov	r12,r6
8000ac56:	2f fb       	sub	r11,-1
8000ac58:	c1 ee       	rcall	8000a894 <_Balloc>
8000ac5a:	6e 4a       	ld.w	r10,r7[0x10]
8000ac5c:	ee cb ff f4 	sub	r11,r7,-12
8000ac60:	18 93       	mov	r3,r12
8000ac62:	2f ea       	sub	r10,-2
8000ac64:	2f 4c       	sub	r12,-12
8000ac66:	a3 6a       	lsl	r10,0x2
8000ac68:	fe b0 de 64 	rcall	80006930 <memcpy>
8000ac6c:	0e 9b       	mov	r11,r7
8000ac6e:	0c 9c       	mov	r12,r6
8000ac70:	fe b0 fd f8 	rcall	8000a860 <_Bfree>
8000ac74:	06 97       	mov	r7,r3
8000ac76:	e8 c8 ff ff 	sub	r8,r4,-1
8000ac7a:	2f b4       	sub	r4,-5
8000ac7c:	8f 48       	st.w	r7[0x10],r8
8000ac7e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ac82:	0e 9c       	mov	r12,r7
8000ac84:	d8 32       	popm	r0-r7,pc
8000ac86:	d7 03       	nop

8000ac88 <__pow5mult>:
8000ac88:	d4 31       	pushm	r0-r7,lr
8000ac8a:	14 96       	mov	r6,r10
8000ac8c:	18 97       	mov	r7,r12
8000ac8e:	16 94       	mov	r4,r11
8000ac90:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ac94:	c0 90       	breq	8000aca6 <__pow5mult+0x1e>
8000ac96:	20 18       	sub	r8,1
8000ac98:	fe c9 dc 48 	sub	r9,pc,-9144
8000ac9c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000aca0:	30 09       	mov	r9,0
8000aca2:	cb 5f       	rcall	8000ac0c <__multadd>
8000aca4:	18 94       	mov	r4,r12
8000aca6:	a3 46       	asr	r6,0x2
8000aca8:	c3 40       	breq	8000ad10 <__pow5mult+0x88>
8000acaa:	6e 95       	ld.w	r5,r7[0x24]
8000acac:	58 05       	cp.w	r5,0
8000acae:	c0 91       	brne	8000acc0 <__pow5mult+0x38>
8000acb0:	31 0c       	mov	r12,16
8000acb2:	fe b0 dc 1b 	rcall	800064e8 <malloc>
8000acb6:	99 35       	st.w	r12[0xc],r5
8000acb8:	8f 9c       	st.w	r7[0x24],r12
8000acba:	99 15       	st.w	r12[0x4],r5
8000acbc:	99 25       	st.w	r12[0x8],r5
8000acbe:	99 05       	st.w	r12[0x0],r5
8000acc0:	6e 93       	ld.w	r3,r7[0x24]
8000acc2:	66 25       	ld.w	r5,r3[0x8]
8000acc4:	58 05       	cp.w	r5,0
8000acc6:	c0 c1       	brne	8000acde <__pow5mult+0x56>
8000acc8:	e0 6b 02 71 	mov	r11,625
8000accc:	0e 9c       	mov	r12,r7
8000acce:	c9 7f       	rcall	8000abfc <__i2b>
8000acd0:	87 2c       	st.w	r3[0x8],r12
8000acd2:	30 08       	mov	r8,0
8000acd4:	18 95       	mov	r5,r12
8000acd6:	99 08       	st.w	r12[0x0],r8
8000acd8:	c0 38       	rjmp	8000acde <__pow5mult+0x56>
8000acda:	06 9c       	mov	r12,r3
8000acdc:	18 95       	mov	r5,r12
8000acde:	ed b6 00 00 	bld	r6,0x0
8000ace2:	c0 b1       	brne	8000acf8 <__pow5mult+0x70>
8000ace4:	08 9b       	mov	r11,r4
8000ace6:	0a 9a       	mov	r10,r5
8000ace8:	0e 9c       	mov	r12,r7
8000acea:	c0 9f       	rcall	8000aafc <__multiply>
8000acec:	08 9b       	mov	r11,r4
8000acee:	18 93       	mov	r3,r12
8000acf0:	0e 9c       	mov	r12,r7
8000acf2:	06 94       	mov	r4,r3
8000acf4:	fe b0 fd b6 	rcall	8000a860 <_Bfree>
8000acf8:	a1 56       	asr	r6,0x1
8000acfa:	c0 b0       	breq	8000ad10 <__pow5mult+0x88>
8000acfc:	6a 03       	ld.w	r3,r5[0x0]
8000acfe:	58 03       	cp.w	r3,0
8000ad00:	ce d1       	brne	8000acda <__pow5mult+0x52>
8000ad02:	0a 9a       	mov	r10,r5
8000ad04:	0a 9b       	mov	r11,r5
8000ad06:	0e 9c       	mov	r12,r7
8000ad08:	cf ae       	rcall	8000aafc <__multiply>
8000ad0a:	8b 0c       	st.w	r5[0x0],r12
8000ad0c:	99 03       	st.w	r12[0x0],r3
8000ad0e:	ce 7b       	rjmp	8000acdc <__pow5mult+0x54>
8000ad10:	08 9c       	mov	r12,r4
8000ad12:	d8 32       	popm	r0-r7,pc

8000ad14 <__isinfd>:
8000ad14:	14 98       	mov	r8,r10
8000ad16:	fc 19 7f f0 	movh	r9,0x7ff0
8000ad1a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ad1e:	f0 0b 11 00 	rsub	r11,r8,0
8000ad22:	f7 e8 10 08 	or	r8,r11,r8
8000ad26:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ad2a:	f2 08 01 08 	sub	r8,r9,r8
8000ad2e:	f0 0c 11 00 	rsub	r12,r8,0
8000ad32:	f9 e8 10 08 	or	r8,r12,r8
8000ad36:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ad3a:	2f fc       	sub	r12,-1
8000ad3c:	5e fc       	retal	r12

8000ad3e <__isnand>:
8000ad3e:	14 98       	mov	r8,r10
8000ad40:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ad44:	f0 0c 11 00 	rsub	r12,r8,0
8000ad48:	10 4c       	or	r12,r8
8000ad4a:	fc 18 7f f0 	movh	r8,0x7ff0
8000ad4e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ad52:	f0 0c 01 0c 	sub	r12,r8,r12
8000ad56:	bf 9c       	lsr	r12,0x1f
8000ad58:	5e fc       	retal	r12
8000ad5a:	d7 03       	nop

8000ad5c <__sclose>:
8000ad5c:	d4 01       	pushm	lr
8000ad5e:	96 7b       	ld.sh	r11,r11[0xe]
8000ad60:	c7 6c       	rcall	8000ae4c <_close_r>
8000ad62:	d8 02       	popm	pc

8000ad64 <__sseek>:
8000ad64:	d4 21       	pushm	r4-r7,lr
8000ad66:	16 97       	mov	r7,r11
8000ad68:	96 7b       	ld.sh	r11,r11[0xe]
8000ad6a:	cf 7c       	rcall	8000af58 <_lseek_r>
8000ad6c:	8e 68       	ld.sh	r8,r7[0xc]
8000ad6e:	10 99       	mov	r9,r8
8000ad70:	ad c8       	cbr	r8,0xc
8000ad72:	ad a9       	sbr	r9,0xc
8000ad74:	5b fc       	cp.w	r12,-1
8000ad76:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ad7a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ad7e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ad82:	d8 22       	popm	r4-r7,pc

8000ad84 <__swrite>:
8000ad84:	d4 21       	pushm	r4-r7,lr
8000ad86:	96 68       	ld.sh	r8,r11[0xc]
8000ad88:	16 97       	mov	r7,r11
8000ad8a:	14 95       	mov	r5,r10
8000ad8c:	12 94       	mov	r4,r9
8000ad8e:	e2 18 01 00 	andl	r8,0x100,COH
8000ad92:	18 96       	mov	r6,r12
8000ad94:	c0 50       	breq	8000ad9e <__swrite+0x1a>
8000ad96:	30 29       	mov	r9,2
8000ad98:	30 0a       	mov	r10,0
8000ad9a:	96 7b       	ld.sh	r11,r11[0xe]
8000ad9c:	cd ec       	rcall	8000af58 <_lseek_r>
8000ad9e:	8e 68       	ld.sh	r8,r7[0xc]
8000ada0:	ad c8       	cbr	r8,0xc
8000ada2:	08 99       	mov	r9,r4
8000ada4:	0a 9a       	mov	r10,r5
8000ada6:	8e 7b       	ld.sh	r11,r7[0xe]
8000ada8:	0c 9c       	mov	r12,r6
8000adaa:	ae 68       	st.h	r7[0xc],r8
8000adac:	c1 0c       	rcall	8000adcc <_write_r>
8000adae:	d8 22       	popm	r4-r7,pc

8000adb0 <__sread>:
8000adb0:	d4 21       	pushm	r4-r7,lr
8000adb2:	16 97       	mov	r7,r11
8000adb4:	96 7b       	ld.sh	r11,r11[0xe]
8000adb6:	ce 5c       	rcall	8000af80 <_read_r>
8000adb8:	c0 65       	brlt	8000adc4 <__sread+0x14>
8000adba:	6f 58       	ld.w	r8,r7[0x54]
8000adbc:	18 08       	add	r8,r12
8000adbe:	ef 48 00 54 	st.w	r7[84],r8
8000adc2:	d8 22       	popm	r4-r7,pc
8000adc4:	8e 68       	ld.sh	r8,r7[0xc]
8000adc6:	ad c8       	cbr	r8,0xc
8000adc8:	ae 68       	st.h	r7[0xc],r8
8000adca:	d8 22       	popm	r4-r7,pc

8000adcc <_write_r>:
8000adcc:	d4 21       	pushm	r4-r7,lr
8000adce:	16 98       	mov	r8,r11
8000add0:	18 97       	mov	r7,r12
8000add2:	10 9c       	mov	r12,r8
8000add4:	30 08       	mov	r8,0
8000add6:	14 9b       	mov	r11,r10
8000add8:	e0 66 40 fc 	mov	r6,16636
8000addc:	12 9a       	mov	r10,r9
8000adde:	8d 08       	st.w	r6[0x0],r8
8000ade0:	fe b0 d1 54 	rcall	80005088 <_write>
8000ade4:	5b fc       	cp.w	r12,-1
8000ade6:	c0 51       	brne	8000adf0 <_write_r+0x24>
8000ade8:	6c 08       	ld.w	r8,r6[0x0]
8000adea:	58 08       	cp.w	r8,0
8000adec:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000adf0:	d8 22       	popm	r4-r7,pc
8000adf2:	d7 03       	nop

8000adf4 <_calloc_r>:
8000adf4:	d4 21       	pushm	r4-r7,lr
8000adf6:	f4 0b 02 4b 	mul	r11,r10,r11
8000adfa:	fe b0 db 7f 	rcall	800064f8 <_malloc_r>
8000adfe:	18 97       	mov	r7,r12
8000ae00:	c2 30       	breq	8000ae46 <_calloc_r+0x52>
8000ae02:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ae06:	e0 1a ff fc 	andl	r10,0xfffc
8000ae0a:	20 4a       	sub	r10,4
8000ae0c:	e0 4a 00 24 	cp.w	r10,36
8000ae10:	e0 8b 00 18 	brhi	8000ae40 <_calloc_r+0x4c>
8000ae14:	18 98       	mov	r8,r12
8000ae16:	59 3a       	cp.w	r10,19
8000ae18:	e0 88 00 0f 	brls	8000ae36 <_calloc_r+0x42>
8000ae1c:	30 09       	mov	r9,0
8000ae1e:	10 a9       	st.w	r8++,r9
8000ae20:	10 a9       	st.w	r8++,r9
8000ae22:	59 ba       	cp.w	r10,27
8000ae24:	e0 88 00 09 	brls	8000ae36 <_calloc_r+0x42>
8000ae28:	10 a9       	st.w	r8++,r9
8000ae2a:	10 a9       	st.w	r8++,r9
8000ae2c:	e0 4a 00 24 	cp.w	r10,36
8000ae30:	c0 31       	brne	8000ae36 <_calloc_r+0x42>
8000ae32:	10 a9       	st.w	r8++,r9
8000ae34:	10 a9       	st.w	r8++,r9
8000ae36:	30 09       	mov	r9,0
8000ae38:	10 a9       	st.w	r8++,r9
8000ae3a:	91 19       	st.w	r8[0x4],r9
8000ae3c:	91 09       	st.w	r8[0x0],r9
8000ae3e:	c0 48       	rjmp	8000ae46 <_calloc_r+0x52>
8000ae40:	30 0b       	mov	r11,0
8000ae42:	fe b0 de 1b 	rcall	80006a78 <memset>
8000ae46:	0e 9c       	mov	r12,r7
8000ae48:	d8 22       	popm	r4-r7,pc
8000ae4a:	d7 03       	nop

8000ae4c <_close_r>:
8000ae4c:	d4 21       	pushm	r4-r7,lr
8000ae4e:	30 08       	mov	r8,0
8000ae50:	18 97       	mov	r7,r12
8000ae52:	e0 66 40 fc 	mov	r6,16636
8000ae56:	16 9c       	mov	r12,r11
8000ae58:	8d 08       	st.w	r6[0x0],r8
8000ae5a:	fe b0 df c1 	rcall	80006ddc <_close>
8000ae5e:	5b fc       	cp.w	r12,-1
8000ae60:	c0 51       	brne	8000ae6a <_close_r+0x1e>
8000ae62:	6c 08       	ld.w	r8,r6[0x0]
8000ae64:	58 08       	cp.w	r8,0
8000ae66:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ae6a:	d8 22       	popm	r4-r7,pc

8000ae6c <_fclose_r>:
8000ae6c:	d4 21       	pushm	r4-r7,lr
8000ae6e:	18 96       	mov	r6,r12
8000ae70:	16 97       	mov	r7,r11
8000ae72:	58 0b       	cp.w	r11,0
8000ae74:	c0 31       	brne	8000ae7a <_fclose_r+0xe>
8000ae76:	16 95       	mov	r5,r11
8000ae78:	c5 38       	rjmp	8000af1e <_fclose_r+0xb2>
8000ae7a:	fe b0 f8 b5 	rcall	80009fe4 <__sfp_lock_acquire>
8000ae7e:	58 06       	cp.w	r6,0
8000ae80:	c0 70       	breq	8000ae8e <_fclose_r+0x22>
8000ae82:	6c 68       	ld.w	r8,r6[0x18]
8000ae84:	58 08       	cp.w	r8,0
8000ae86:	c0 41       	brne	8000ae8e <_fclose_r+0x22>
8000ae88:	0c 9c       	mov	r12,r6
8000ae8a:	fe b0 f8 ff 	rcall	8000a088 <__sinit>
8000ae8e:	fe c8 de e2 	sub	r8,pc,-8478
8000ae92:	10 37       	cp.w	r7,r8
8000ae94:	c0 31       	brne	8000ae9a <_fclose_r+0x2e>
8000ae96:	6c 07       	ld.w	r7,r6[0x0]
8000ae98:	c0 c8       	rjmp	8000aeb0 <_fclose_r+0x44>
8000ae9a:	fe c8 de ce 	sub	r8,pc,-8498
8000ae9e:	10 37       	cp.w	r7,r8
8000aea0:	c0 31       	brne	8000aea6 <_fclose_r+0x3a>
8000aea2:	6c 17       	ld.w	r7,r6[0x4]
8000aea4:	c0 68       	rjmp	8000aeb0 <_fclose_r+0x44>
8000aea6:	fe c8 de ba 	sub	r8,pc,-8518
8000aeaa:	10 37       	cp.w	r7,r8
8000aeac:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000aeb0:	8e 69       	ld.sh	r9,r7[0xc]
8000aeb2:	30 08       	mov	r8,0
8000aeb4:	f0 09 19 00 	cp.h	r9,r8
8000aeb8:	c0 51       	brne	8000aec2 <_fclose_r+0x56>
8000aeba:	fe b0 f8 96 	rcall	80009fe6 <__sfp_lock_release>
8000aebe:	30 05       	mov	r5,0
8000aec0:	c2 f8       	rjmp	8000af1e <_fclose_r+0xb2>
8000aec2:	0e 9b       	mov	r11,r7
8000aec4:	0c 9c       	mov	r12,r6
8000aec6:	fe b0 f8 09 	rcall	80009ed8 <_fflush_r>
8000aeca:	6e c8       	ld.w	r8,r7[0x30]
8000aecc:	18 95       	mov	r5,r12
8000aece:	58 08       	cp.w	r8,0
8000aed0:	c0 60       	breq	8000aedc <_fclose_r+0x70>
8000aed2:	6e 8b       	ld.w	r11,r7[0x20]
8000aed4:	0c 9c       	mov	r12,r6
8000aed6:	5d 18       	icall	r8
8000aed8:	f9 b5 05 ff 	movlt	r5,-1
8000aedc:	8e 68       	ld.sh	r8,r7[0xc]
8000aede:	ed b8 00 07 	bld	r8,0x7
8000aee2:	c0 51       	brne	8000aeec <_fclose_r+0x80>
8000aee4:	6e 4b       	ld.w	r11,r7[0x10]
8000aee6:	0c 9c       	mov	r12,r6
8000aee8:	fe b0 f9 6a 	rcall	8000a1bc <_free_r>
8000aeec:	6e db       	ld.w	r11,r7[0x34]
8000aeee:	58 0b       	cp.w	r11,0
8000aef0:	c0 a0       	breq	8000af04 <_fclose_r+0x98>
8000aef2:	ee c8 ff bc 	sub	r8,r7,-68
8000aef6:	10 3b       	cp.w	r11,r8
8000aef8:	c0 40       	breq	8000af00 <_fclose_r+0x94>
8000aefa:	0c 9c       	mov	r12,r6
8000aefc:	fe b0 f9 60 	rcall	8000a1bc <_free_r>
8000af00:	30 08       	mov	r8,0
8000af02:	8f d8       	st.w	r7[0x34],r8
8000af04:	6f 2b       	ld.w	r11,r7[0x48]
8000af06:	58 0b       	cp.w	r11,0
8000af08:	c0 70       	breq	8000af16 <_fclose_r+0xaa>
8000af0a:	0c 9c       	mov	r12,r6
8000af0c:	fe b0 f9 58 	rcall	8000a1bc <_free_r>
8000af10:	30 08       	mov	r8,0
8000af12:	ef 48 00 48 	st.w	r7[72],r8
8000af16:	30 08       	mov	r8,0
8000af18:	ae 68       	st.h	r7[0xc],r8
8000af1a:	fe b0 f8 66 	rcall	80009fe6 <__sfp_lock_release>
8000af1e:	0a 9c       	mov	r12,r5
8000af20:	d8 22       	popm	r4-r7,pc
8000af22:	d7 03       	nop

8000af24 <fclose>:
8000af24:	d4 01       	pushm	lr
8000af26:	e0 68 0a 44 	mov	r8,2628
8000af2a:	18 9b       	mov	r11,r12
8000af2c:	70 0c       	ld.w	r12,r8[0x0]
8000af2e:	c9 ff       	rcall	8000ae6c <_fclose_r>
8000af30:	d8 02       	popm	pc
8000af32:	d7 03       	nop

8000af34 <_fstat_r>:
8000af34:	d4 21       	pushm	r4-r7,lr
8000af36:	16 98       	mov	r8,r11
8000af38:	18 97       	mov	r7,r12
8000af3a:	10 9c       	mov	r12,r8
8000af3c:	30 08       	mov	r8,0
8000af3e:	e0 66 40 fc 	mov	r6,16636
8000af42:	14 9b       	mov	r11,r10
8000af44:	8d 08       	st.w	r6[0x0],r8
8000af46:	fe b0 df 73 	rcall	80006e2c <_fstat>
8000af4a:	5b fc       	cp.w	r12,-1
8000af4c:	c0 51       	brne	8000af56 <_fstat_r+0x22>
8000af4e:	6c 08       	ld.w	r8,r6[0x0]
8000af50:	58 08       	cp.w	r8,0
8000af52:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af56:	d8 22       	popm	r4-r7,pc

8000af58 <_lseek_r>:
8000af58:	d4 21       	pushm	r4-r7,lr
8000af5a:	16 98       	mov	r8,r11
8000af5c:	18 97       	mov	r7,r12
8000af5e:	10 9c       	mov	r12,r8
8000af60:	30 08       	mov	r8,0
8000af62:	14 9b       	mov	r11,r10
8000af64:	e0 66 40 fc 	mov	r6,16636
8000af68:	12 9a       	mov	r10,r9
8000af6a:	8d 08       	st.w	r6[0x0],r8
8000af6c:	fe b0 df 42 	rcall	80006df0 <_lseek>
8000af70:	5b fc       	cp.w	r12,-1
8000af72:	c0 51       	brne	8000af7c <_lseek_r+0x24>
8000af74:	6c 08       	ld.w	r8,r6[0x0]
8000af76:	58 08       	cp.w	r8,0
8000af78:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000af7c:	d8 22       	popm	r4-r7,pc
8000af7e:	d7 03       	nop

8000af80 <_read_r>:
8000af80:	d4 21       	pushm	r4-r7,lr
8000af82:	16 98       	mov	r8,r11
8000af84:	18 97       	mov	r7,r12
8000af86:	10 9c       	mov	r12,r8
8000af88:	30 08       	mov	r8,0
8000af8a:	14 9b       	mov	r11,r10
8000af8c:	e0 66 40 fc 	mov	r6,16636
8000af90:	12 9a       	mov	r10,r9
8000af92:	8d 08       	st.w	r6[0x0],r8
8000af94:	fe b0 d0 5a 	rcall	80005048 <_read>
8000af98:	5b fc       	cp.w	r12,-1
8000af9a:	c0 51       	brne	8000afa4 <_read_r+0x24>
8000af9c:	6c 08       	ld.w	r8,r6[0x0]
8000af9e:	58 08       	cp.w	r8,0
8000afa0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000afa4:	d8 22       	popm	r4-r7,pc
8000afa6:	d7 03       	nop

8000afa8 <__avr32_f64_mul>:
8000afa8:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000afac:	e0 80 00 dc 	breq	8000b164 <__avr32_f64_mul_op1_zero>
8000afb0:	d4 21       	pushm	r4-r7,lr
8000afb2:	f7 e9 20 0e 	eor	lr,r11,r9
8000afb6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000afba:	30 15       	mov	r5,1
8000afbc:	c4 30       	breq	8000b042 <__avr32_f64_mul_op1_subnormal>
8000afbe:	ab 6b       	lsl	r11,0xa
8000afc0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000afc4:	ab 6a       	lsl	r10,0xa
8000afc6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000afca:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000afce:	c5 c0       	breq	8000b086 <__avr32_f64_mul_op2_subnormal>
8000afd0:	a1 78       	lsl	r8,0x1
8000afd2:	5c f9       	rol	r9
8000afd4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000afd8:	e0 47 07 ff 	cp.w	r7,2047
8000afdc:	c7 70       	breq	8000b0ca <__avr32_f64_mul_op_nan_or_inf>
8000afde:	e0 46 07 ff 	cp.w	r6,2047
8000afe2:	c7 40       	breq	8000b0ca <__avr32_f64_mul_op_nan_or_inf>
8000afe4:	ee 06 00 0c 	add	r12,r7,r6
8000afe8:	e0 2c 03 fe 	sub	r12,1022
8000afec:	f6 08 06 44 	mulu.d	r4,r11,r8
8000aff0:	f4 09 07 44 	macu.d	r4,r10,r9
8000aff4:	f4 08 06 46 	mulu.d	r6,r10,r8
8000aff8:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000affc:	08 07       	add	r7,r4
8000affe:	f4 05 00 4a 	adc	r10,r10,r5
8000b002:	5c 0b       	acr	r11
8000b004:	ed bb 00 14 	bld	r11,0x14
8000b008:	c0 50       	breq	8000b012 <__avr32_f64_mul+0x6a>
8000b00a:	a1 77       	lsl	r7,0x1
8000b00c:	5c fa       	rol	r10
8000b00e:	5c fb       	rol	r11
8000b010:	20 1c       	sub	r12,1
8000b012:	58 0c       	cp.w	r12,0
8000b014:	e0 8a 00 6f 	brle	8000b0f2 <__avr32_f64_mul_res_subnormal>
8000b018:	e0 4c 07 ff 	cp.w	r12,2047
8000b01c:	e0 84 00 9c 	brge	8000b154 <__avr32_f64_mul_res_inf>
8000b020:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b024:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b028:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b02c:	ee 17 80 00 	eorh	r7,0x8000
8000b030:	f1 b7 04 20 	satu	r7,0x1
8000b034:	0e 0a       	add	r10,r7
8000b036:	5c 0b       	acr	r11
8000b038:	ed be 00 1f 	bld	lr,0x1f
8000b03c:	ef bb 00 1f 	bst	r11,0x1f
8000b040:	d8 22       	popm	r4-r7,pc

8000b042 <__avr32_f64_mul_op1_subnormal>:
8000b042:	e4 1b 00 0f 	andh	r11,0xf
8000b046:	f4 0c 12 00 	clz	r12,r10
8000b04a:	f6 06 12 00 	clz	r6,r11
8000b04e:	f7 bc 03 e1 	sublo	r12,-31
8000b052:	f8 06 17 30 	movlo	r6,r12
8000b056:	f7 b6 02 01 	subhs	r6,1
8000b05a:	e0 46 00 20 	cp.w	r6,32
8000b05e:	c0 d4       	brge	8000b078 <__avr32_f64_mul_op1_subnormal+0x36>
8000b060:	ec 0c 11 20 	rsub	r12,r6,32
8000b064:	f6 06 09 4b 	lsl	r11,r11,r6
8000b068:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b06c:	18 4b       	or	r11,r12
8000b06e:	f4 06 09 4a 	lsl	r10,r10,r6
8000b072:	20 b6       	sub	r6,11
8000b074:	0c 17       	sub	r7,r6
8000b076:	ca ab       	rjmp	8000afca <__avr32_f64_mul+0x22>
8000b078:	f4 06 09 4b 	lsl	r11,r10,r6
8000b07c:	c6 40       	breq	8000b144 <__avr32_f64_mul_res_zero>
8000b07e:	30 0a       	mov	r10,0
8000b080:	20 b6       	sub	r6,11
8000b082:	0c 17       	sub	r7,r6
8000b084:	ca 3b       	rjmp	8000afca <__avr32_f64_mul+0x22>

8000b086 <__avr32_f64_mul_op2_subnormal>:
8000b086:	e4 19 00 0f 	andh	r9,0xf
8000b08a:	f0 0c 12 00 	clz	r12,r8
8000b08e:	f2 05 12 00 	clz	r5,r9
8000b092:	f7 bc 03 ea 	sublo	r12,-22
8000b096:	f8 05 17 30 	movlo	r5,r12
8000b09a:	f7 b5 02 0a 	subhs	r5,10
8000b09e:	e0 45 00 20 	cp.w	r5,32
8000b0a2:	c0 d4       	brge	8000b0bc <__avr32_f64_mul_op2_subnormal+0x36>
8000b0a4:	ea 0c 11 20 	rsub	r12,r5,32
8000b0a8:	f2 05 09 49 	lsl	r9,r9,r5
8000b0ac:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b0b0:	18 49       	or	r9,r12
8000b0b2:	f0 05 09 48 	lsl	r8,r8,r5
8000b0b6:	20 25       	sub	r5,2
8000b0b8:	0a 16       	sub	r6,r5
8000b0ba:	c8 fb       	rjmp	8000afd8 <__avr32_f64_mul+0x30>
8000b0bc:	f0 05 09 49 	lsl	r9,r8,r5
8000b0c0:	c4 20       	breq	8000b144 <__avr32_f64_mul_res_zero>
8000b0c2:	30 08       	mov	r8,0
8000b0c4:	20 25       	sub	r5,2
8000b0c6:	0a 16       	sub	r6,r5
8000b0c8:	c8 8b       	rjmp	8000afd8 <__avr32_f64_mul+0x30>

8000b0ca <__avr32_f64_mul_op_nan_or_inf>:
8000b0ca:	e4 19 00 0f 	andh	r9,0xf
8000b0ce:	e4 1b 00 0f 	andh	r11,0xf
8000b0d2:	14 4b       	or	r11,r10
8000b0d4:	10 49       	or	r9,r8
8000b0d6:	e0 47 07 ff 	cp.w	r7,2047
8000b0da:	c0 91       	brne	8000b0ec <__avr32_f64_mul_op1_not_naninf>
8000b0dc:	58 0b       	cp.w	r11,0
8000b0de:	c3 81       	brne	8000b14e <__avr32_f64_mul_res_nan>
8000b0e0:	e0 46 07 ff 	cp.w	r6,2047
8000b0e4:	c3 81       	brne	8000b154 <__avr32_f64_mul_res_inf>
8000b0e6:	58 09       	cp.w	r9,0
8000b0e8:	c3 60       	breq	8000b154 <__avr32_f64_mul_res_inf>
8000b0ea:	c3 28       	rjmp	8000b14e <__avr32_f64_mul_res_nan>

8000b0ec <__avr32_f64_mul_op1_not_naninf>:
8000b0ec:	58 09       	cp.w	r9,0
8000b0ee:	c3 30       	breq	8000b154 <__avr32_f64_mul_res_inf>
8000b0f0:	c2 f8       	rjmp	8000b14e <__avr32_f64_mul_res_nan>

8000b0f2 <__avr32_f64_mul_res_subnormal>:
8000b0f2:	5c 3c       	neg	r12
8000b0f4:	2f fc       	sub	r12,-1
8000b0f6:	f1 bc 04 c0 	satu	r12,0x6
8000b0fa:	e0 4c 00 20 	cp.w	r12,32
8000b0fe:	c1 14       	brge	8000b120 <__avr32_f64_mul_res_subnormal+0x2e>
8000b100:	f8 08 11 20 	rsub	r8,r12,32
8000b104:	0e 46       	or	r6,r7
8000b106:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b10a:	f4 08 09 49 	lsl	r9,r10,r8
8000b10e:	12 47       	or	r7,r9
8000b110:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b114:	f6 08 09 49 	lsl	r9,r11,r8
8000b118:	12 4a       	or	r10,r9
8000b11a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b11e:	c8 3b       	rjmp	8000b024 <__avr32_f64_mul+0x7c>
8000b120:	f8 08 11 20 	rsub	r8,r12,32
8000b124:	f9 b9 00 00 	moveq	r9,0
8000b128:	c0 30       	breq	8000b12e <__avr32_f64_mul_res_subnormal+0x3c>
8000b12a:	f6 08 09 49 	lsl	r9,r11,r8
8000b12e:	0e 46       	or	r6,r7
8000b130:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b134:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b138:	f3 ea 10 07 	or	r7,r9,r10
8000b13c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b140:	30 0b       	mov	r11,0
8000b142:	c7 1b       	rjmp	8000b024 <__avr32_f64_mul+0x7c>

8000b144 <__avr32_f64_mul_res_zero>:
8000b144:	1c 9b       	mov	r11,lr
8000b146:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b14a:	30 0a       	mov	r10,0
8000b14c:	d8 22       	popm	r4-r7,pc

8000b14e <__avr32_f64_mul_res_nan>:
8000b14e:	3f fb       	mov	r11,-1
8000b150:	3f fa       	mov	r10,-1
8000b152:	d8 22       	popm	r4-r7,pc

8000b154 <__avr32_f64_mul_res_inf>:
8000b154:	f0 6b 00 00 	mov	r11,-1048576
8000b158:	ed be 00 1f 	bld	lr,0x1f
8000b15c:	ef bb 00 1f 	bst	r11,0x1f
8000b160:	30 0a       	mov	r10,0
8000b162:	d8 22       	popm	r4-r7,pc

8000b164 <__avr32_f64_mul_op1_zero>:
8000b164:	f7 e9 20 0b 	eor	r11,r11,r9
8000b168:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b16c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b170:	e0 4c 07 ff 	cp.w	r12,2047
8000b174:	5e 1c       	retne	r12
8000b176:	3f fa       	mov	r10,-1
8000b178:	3f fb       	mov	r11,-1
8000b17a:	5e fc       	retal	r12

8000b17c <__avr32_f64_sub_from_add>:
8000b17c:	ee 19 80 00 	eorh	r9,0x8000

8000b180 <__avr32_f64_sub>:
8000b180:	f7 e9 20 0c 	eor	r12,r11,r9
8000b184:	e0 86 00 ca 	brmi	8000b318 <__avr32_f64_add_from_sub>
8000b188:	eb cd 40 e0 	pushm	r5-r7,lr
8000b18c:	16 9c       	mov	r12,r11
8000b18e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b192:	bf db       	cbr	r11,0x1f
8000b194:	bf d9       	cbr	r9,0x1f
8000b196:	10 3a       	cp.w	r10,r8
8000b198:	f2 0b 13 00 	cpc	r11,r9
8000b19c:	c0 92       	brcc	8000b1ae <__avr32_f64_sub+0x2e>
8000b19e:	16 97       	mov	r7,r11
8000b1a0:	12 9b       	mov	r11,r9
8000b1a2:	0e 99       	mov	r9,r7
8000b1a4:	14 97       	mov	r7,r10
8000b1a6:	10 9a       	mov	r10,r8
8000b1a8:	0e 98       	mov	r8,r7
8000b1aa:	ee 1c 80 00 	eorh	r12,0x8000
8000b1ae:	f6 07 16 14 	lsr	r7,r11,0x14
8000b1b2:	ab 7b       	lsl	r11,0xb
8000b1b4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b1b8:	ab 7a       	lsl	r10,0xb
8000b1ba:	bf bb       	sbr	r11,0x1f
8000b1bc:	f2 06 16 14 	lsr	r6,r9,0x14
8000b1c0:	c4 40       	breq	8000b248 <__avr32_f64_sub_opL_subnormal>
8000b1c2:	ab 79       	lsl	r9,0xb
8000b1c4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b1c8:	ab 78       	lsl	r8,0xb
8000b1ca:	bf b9       	sbr	r9,0x1f

8000b1cc <__avr32_f64_sub_opL_subnormal_done>:
8000b1cc:	e0 47 07 ff 	cp.w	r7,2047
8000b1d0:	c4 f0       	breq	8000b26e <__avr32_f64_sub_opH_nan_or_inf>
8000b1d2:	0e 26       	rsub	r6,r7
8000b1d4:	c1 20       	breq	8000b1f8 <__avr32_f64_sub_shift_done>
8000b1d6:	ec 05 11 20 	rsub	r5,r6,32
8000b1da:	e0 46 00 20 	cp.w	r6,32
8000b1de:	c7 c2       	brcc	8000b2d6 <__avr32_f64_sub_longshift>
8000b1e0:	f0 05 09 4e 	lsl	lr,r8,r5
8000b1e4:	f2 05 09 45 	lsl	r5,r9,r5
8000b1e8:	f0 06 0a 48 	lsr	r8,r8,r6
8000b1ec:	f2 06 0a 49 	lsr	r9,r9,r6
8000b1f0:	0a 48       	or	r8,r5
8000b1f2:	58 0e       	cp.w	lr,0
8000b1f4:	5f 1e       	srne	lr
8000b1f6:	1c 48       	or	r8,lr

8000b1f8 <__avr32_f64_sub_shift_done>:
8000b1f8:	10 1a       	sub	r10,r8
8000b1fa:	f6 09 01 4b 	sbc	r11,r11,r9
8000b1fe:	f6 06 12 00 	clz	r6,r11
8000b202:	c0 e0       	breq	8000b21e <__avr32_f64_sub_longnormalize_done>
8000b204:	c7 83       	brcs	8000b2f4 <__avr32_f64_sub_longnormalize>
8000b206:	ec 0e 11 20 	rsub	lr,r6,32
8000b20a:	f6 06 09 4b 	lsl	r11,r11,r6
8000b20e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b212:	1c 4b       	or	r11,lr
8000b214:	f4 06 09 4a 	lsl	r10,r10,r6
8000b218:	0c 17       	sub	r7,r6
8000b21a:	e0 8a 00 39 	brle	8000b28c <__avr32_f64_sub_subnormal_result>

8000b21e <__avr32_f64_sub_longnormalize_done>:
8000b21e:	f4 09 15 15 	lsl	r9,r10,0x15
8000b222:	ab 9a       	lsr	r10,0xb
8000b224:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b228:	ab 9b       	lsr	r11,0xb
8000b22a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b22e:	18 4b       	or	r11,r12

8000b230 <__avr32_f64_sub_round>:
8000b230:	fc 17 80 00 	movh	r7,0x8000
8000b234:	ed ba 00 00 	bld	r10,0x0
8000b238:	f7 b7 01 ff 	subne	r7,-1
8000b23c:	0e 39       	cp.w	r9,r7
8000b23e:	5f 29       	srhs	r9
8000b240:	12 0a       	add	r10,r9
8000b242:	5c 0b       	acr	r11
8000b244:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b248 <__avr32_f64_sub_opL_subnormal>:
8000b248:	ab 79       	lsl	r9,0xb
8000b24a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b24e:	ab 78       	lsl	r8,0xb
8000b250:	f3 e8 10 0e 	or	lr,r9,r8
8000b254:	f9 b6 01 01 	movne	r6,1
8000b258:	ee 0e 11 00 	rsub	lr,r7,0
8000b25c:	f9 b7 00 01 	moveq	r7,1
8000b260:	ef bb 00 1f 	bst	r11,0x1f
8000b264:	f7 ea 10 0e 	or	lr,r11,r10
8000b268:	f9 b7 00 00 	moveq	r7,0
8000b26c:	cb 0b       	rjmp	8000b1cc <__avr32_f64_sub_opL_subnormal_done>

8000b26e <__avr32_f64_sub_opH_nan_or_inf>:
8000b26e:	bf db       	cbr	r11,0x1f
8000b270:	f7 ea 10 0e 	or	lr,r11,r10
8000b274:	c0 81       	brne	8000b284 <__avr32_f64_sub_return_nan>
8000b276:	e0 46 07 ff 	cp.w	r6,2047
8000b27a:	c0 50       	breq	8000b284 <__avr32_f64_sub_return_nan>
8000b27c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b280:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b284 <__avr32_f64_sub_return_nan>:
8000b284:	3f fa       	mov	r10,-1
8000b286:	3f fb       	mov	r11,-1
8000b288:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b28c <__avr32_f64_sub_subnormal_result>:
8000b28c:	5c 37       	neg	r7
8000b28e:	2f f7       	sub	r7,-1
8000b290:	f1 b7 04 c0 	satu	r7,0x6
8000b294:	e0 47 00 20 	cp.w	r7,32
8000b298:	c1 14       	brge	8000b2ba <__avr32_f64_sub_subnormal_result+0x2e>
8000b29a:	ee 08 11 20 	rsub	r8,r7,32
8000b29e:	f4 08 09 49 	lsl	r9,r10,r8
8000b2a2:	5f 16       	srne	r6
8000b2a4:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b2a8:	0c 4a       	or	r10,r6
8000b2aa:	f6 08 09 49 	lsl	r9,r11,r8
8000b2ae:	f5 e9 10 0a 	or	r10,r10,r9
8000b2b2:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b2b6:	30 07       	mov	r7,0
8000b2b8:	cb 3b       	rjmp	8000b21e <__avr32_f64_sub_longnormalize_done>
8000b2ba:	ee 08 11 40 	rsub	r8,r7,64
8000b2be:	f6 08 09 49 	lsl	r9,r11,r8
8000b2c2:	14 49       	or	r9,r10
8000b2c4:	5f 16       	srne	r6
8000b2c6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b2ca:	0c 4a       	or	r10,r6
8000b2cc:	30 0b       	mov	r11,0
8000b2ce:	30 07       	mov	r7,0
8000b2d0:	ca 7b       	rjmp	8000b21e <__avr32_f64_sub_longnormalize_done>
8000b2d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b2d6 <__avr32_f64_sub_longshift>:
8000b2d6:	f1 b6 04 c0 	satu	r6,0x6
8000b2da:	f0 0e 17 00 	moveq	lr,r8
8000b2de:	c0 40       	breq	8000b2e6 <__avr32_f64_sub_longshift+0x10>
8000b2e0:	f2 05 09 4e 	lsl	lr,r9,r5
8000b2e4:	10 4e       	or	lr,r8
8000b2e6:	f2 06 0a 48 	lsr	r8,r9,r6
8000b2ea:	30 09       	mov	r9,0
8000b2ec:	58 0e       	cp.w	lr,0
8000b2ee:	5f 1e       	srne	lr
8000b2f0:	1c 48       	or	r8,lr
8000b2f2:	c8 3b       	rjmp	8000b1f8 <__avr32_f64_sub_shift_done>

8000b2f4 <__avr32_f64_sub_longnormalize>:
8000b2f4:	f4 06 12 00 	clz	r6,r10
8000b2f8:	f9 b7 03 00 	movlo	r7,0
8000b2fc:	f9 b6 03 00 	movlo	r6,0
8000b300:	f9 bc 03 00 	movlo	r12,0
8000b304:	f7 b6 02 e0 	subhs	r6,-32
8000b308:	f4 06 09 4b 	lsl	r11,r10,r6
8000b30c:	30 0a       	mov	r10,0
8000b30e:	0c 17       	sub	r7,r6
8000b310:	fe 9a ff be 	brle	8000b28c <__avr32_f64_sub_subnormal_result>
8000b314:	c8 5b       	rjmp	8000b21e <__avr32_f64_sub_longnormalize_done>
8000b316:	d7 03       	nop

8000b318 <__avr32_f64_add_from_sub>:
8000b318:	ee 19 80 00 	eorh	r9,0x8000

8000b31c <__avr32_f64_add>:
8000b31c:	f7 e9 20 0c 	eor	r12,r11,r9
8000b320:	fe 96 ff 2e 	brmi	8000b17c <__avr32_f64_sub_from_add>
8000b324:	eb cd 40 e0 	pushm	r5-r7,lr
8000b328:	16 9c       	mov	r12,r11
8000b32a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b32e:	bf db       	cbr	r11,0x1f
8000b330:	bf d9       	cbr	r9,0x1f
8000b332:	12 3b       	cp.w	r11,r9
8000b334:	c0 72       	brcc	8000b342 <__avr32_f64_add+0x26>
8000b336:	16 97       	mov	r7,r11
8000b338:	12 9b       	mov	r11,r9
8000b33a:	0e 99       	mov	r9,r7
8000b33c:	14 97       	mov	r7,r10
8000b33e:	10 9a       	mov	r10,r8
8000b340:	0e 98       	mov	r8,r7
8000b342:	30 0e       	mov	lr,0
8000b344:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b348:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b34c:	b5 ab       	sbr	r11,0x14
8000b34e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b352:	c6 20       	breq	8000b416 <__avr32_f64_add_op2_subnormal>
8000b354:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b358:	b5 a9       	sbr	r9,0x14
8000b35a:	e0 47 07 ff 	cp.w	r7,2047
8000b35e:	c2 80       	breq	8000b3ae <__avr32_f64_add_opH_nan_or_inf>
8000b360:	0e 26       	rsub	r6,r7
8000b362:	c1 20       	breq	8000b386 <__avr32_f64_add_shift_done>
8000b364:	e0 46 00 36 	cp.w	r6,54
8000b368:	c1 52       	brcc	8000b392 <__avr32_f64_add_res_of_done>
8000b36a:	ec 05 11 20 	rsub	r5,r6,32
8000b36e:	e0 46 00 20 	cp.w	r6,32
8000b372:	c3 52       	brcc	8000b3dc <__avr32_f64_add_longshift>
8000b374:	f0 05 09 4e 	lsl	lr,r8,r5
8000b378:	f2 05 09 45 	lsl	r5,r9,r5
8000b37c:	f0 06 0a 48 	lsr	r8,r8,r6
8000b380:	f2 06 0a 49 	lsr	r9,r9,r6
8000b384:	0a 48       	or	r8,r5

8000b386 <__avr32_f64_add_shift_done>:
8000b386:	10 0a       	add	r10,r8
8000b388:	f6 09 00 4b 	adc	r11,r11,r9
8000b38c:	ed bb 00 15 	bld	r11,0x15
8000b390:	c3 40       	breq	8000b3f8 <__avr32_f64_add_res_of>

8000b392 <__avr32_f64_add_res_of_done>:
8000b392:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b396:	18 4b       	or	r11,r12

8000b398 <__avr32_f64_add_round>:
8000b398:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b39c:	18 4e       	or	lr,r12
8000b39e:	ee 1e 80 00 	eorh	lr,0x8000
8000b3a2:	f1 be 04 20 	satu	lr,0x1
8000b3a6:	1c 0a       	add	r10,lr
8000b3a8:	5c 0b       	acr	r11
8000b3aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3ae <__avr32_f64_add_opH_nan_or_inf>:
8000b3ae:	b5 cb       	cbr	r11,0x14
8000b3b0:	f7 ea 10 0e 	or	lr,r11,r10
8000b3b4:	c1 01       	brne	8000b3d4 <__avr32_f64_add_return_nan>
8000b3b6:	e0 46 07 ff 	cp.w	r6,2047
8000b3ba:	c0 30       	breq	8000b3c0 <__avr32_f64_add_opL_nan_or_inf>
8000b3bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3c0 <__avr32_f64_add_opL_nan_or_inf>:
8000b3c0:	b5 c9       	cbr	r9,0x14
8000b3c2:	f3 e8 10 0e 	or	lr,r9,r8
8000b3c6:	c0 71       	brne	8000b3d4 <__avr32_f64_add_return_nan>
8000b3c8:	30 0a       	mov	r10,0
8000b3ca:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b3ce:	18 4b       	or	r11,r12
8000b3d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3d4 <__avr32_f64_add_return_nan>:
8000b3d4:	3f fa       	mov	r10,-1
8000b3d6:	3f fb       	mov	r11,-1
8000b3d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b3dc <__avr32_f64_add_longshift>:
8000b3dc:	f1 b6 04 c0 	satu	r6,0x6
8000b3e0:	f0 0e 17 00 	moveq	lr,r8
8000b3e4:	c0 60       	breq	8000b3f0 <__avr32_f64_add_longshift+0x14>
8000b3e6:	f2 05 09 4e 	lsl	lr,r9,r5
8000b3ea:	58 08       	cp.w	r8,0
8000b3ec:	5f 18       	srne	r8
8000b3ee:	10 4e       	or	lr,r8
8000b3f0:	f2 06 0a 48 	lsr	r8,r9,r6
8000b3f4:	30 09       	mov	r9,0
8000b3f6:	cc 8b       	rjmp	8000b386 <__avr32_f64_add_shift_done>

8000b3f8 <__avr32_f64_add_res_of>:
8000b3f8:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b3fc:	a1 9b       	lsr	r11,0x1
8000b3fe:	5d 0a       	ror	r10
8000b400:	5d 0e       	ror	lr
8000b402:	2f f7       	sub	r7,-1
8000b404:	e0 47 07 ff 	cp.w	r7,2047
8000b408:	f9 ba 00 00 	moveq	r10,0
8000b40c:	f9 bb 00 00 	moveq	r11,0
8000b410:	f9 be 00 00 	moveq	lr,0
8000b414:	cb fb       	rjmp	8000b392 <__avr32_f64_add_res_of_done>

8000b416 <__avr32_f64_add_op2_subnormal>:
8000b416:	30 16       	mov	r6,1
8000b418:	58 07       	cp.w	r7,0
8000b41a:	ca 01       	brne	8000b35a <__avr32_f64_add+0x3e>
8000b41c:	b5 cb       	cbr	r11,0x14
8000b41e:	10 0a       	add	r10,r8
8000b420:	f6 09 00 4b 	adc	r11,r11,r9
8000b424:	18 4b       	or	r11,r12
8000b426:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b42a:	d7 03       	nop

8000b42c <__avr32_f64_to_u32>:
8000b42c:	58 0b       	cp.w	r11,0
8000b42e:	5e 6d       	retmi	0

8000b430 <__avr32_f64_to_s32>:
8000b430:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b434:	b5 9c       	lsr	r12,0x15
8000b436:	e0 2c 03 ff 	sub	r12,1023
8000b43a:	5e 3d       	retlo	0
8000b43c:	f8 0c 11 1f 	rsub	r12,r12,31
8000b440:	16 99       	mov	r9,r11
8000b442:	ab 7b       	lsl	r11,0xb
8000b444:	bf bb       	sbr	r11,0x1f
8000b446:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b44a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b44e:	a1 79       	lsl	r9,0x1
8000b450:	5e 2b       	reths	r11
8000b452:	5c 3b       	neg	r11
8000b454:	5e fb       	retal	r11

8000b456 <__avr32_u32_to_f64>:
8000b456:	f8 cb 00 00 	sub	r11,r12,0
8000b45a:	30 0c       	mov	r12,0
8000b45c:	c0 38       	rjmp	8000b462 <__avr32_s32_to_f64+0x4>

8000b45e <__avr32_s32_to_f64>:
8000b45e:	18 9b       	mov	r11,r12
8000b460:	5c 4b       	abs	r11
8000b462:	30 0a       	mov	r10,0
8000b464:	5e 0b       	reteq	r11
8000b466:	d4 01       	pushm	lr
8000b468:	e0 69 04 1e 	mov	r9,1054
8000b46c:	f6 08 12 00 	clz	r8,r11
8000b470:	c1 70       	breq	8000b49e <__avr32_s32_to_f64+0x40>
8000b472:	c0 c3       	brcs	8000b48a <__avr32_s32_to_f64+0x2c>
8000b474:	f0 0e 11 20 	rsub	lr,r8,32
8000b478:	f6 08 09 4b 	lsl	r11,r11,r8
8000b47c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b480:	1c 4b       	or	r11,lr
8000b482:	f4 08 09 4a 	lsl	r10,r10,r8
8000b486:	10 19       	sub	r9,r8
8000b488:	c0 b8       	rjmp	8000b49e <__avr32_s32_to_f64+0x40>
8000b48a:	f4 08 12 00 	clz	r8,r10
8000b48e:	f9 b8 03 00 	movlo	r8,0
8000b492:	f7 b8 02 e0 	subhs	r8,-32
8000b496:	f4 08 09 4b 	lsl	r11,r10,r8
8000b49a:	30 0a       	mov	r10,0
8000b49c:	10 19       	sub	r9,r8
8000b49e:	58 09       	cp.w	r9,0
8000b4a0:	e0 89 00 30 	brgt	8000b500 <__avr32_s32_to_f64+0xa2>
8000b4a4:	5c 39       	neg	r9
8000b4a6:	2f f9       	sub	r9,-1
8000b4a8:	e0 49 00 36 	cp.w	r9,54
8000b4ac:	c0 43       	brcs	8000b4b4 <__avr32_s32_to_f64+0x56>
8000b4ae:	30 0b       	mov	r11,0
8000b4b0:	30 0a       	mov	r10,0
8000b4b2:	c2 68       	rjmp	8000b4fe <__avr32_s32_to_f64+0xa0>
8000b4b4:	2f 69       	sub	r9,-10
8000b4b6:	f2 08 11 20 	rsub	r8,r9,32
8000b4ba:	e0 49 00 20 	cp.w	r9,32
8000b4be:	c0 b2       	brcc	8000b4d4 <__avr32_s32_to_f64+0x76>
8000b4c0:	f4 08 09 4e 	lsl	lr,r10,r8
8000b4c4:	f6 08 09 48 	lsl	r8,r11,r8
8000b4c8:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b4cc:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b4d0:	10 4b       	or	r11,r8
8000b4d2:	c0 88       	rjmp	8000b4e2 <__avr32_s32_to_f64+0x84>
8000b4d4:	f6 08 09 4e 	lsl	lr,r11,r8
8000b4d8:	14 4e       	or	lr,r10
8000b4da:	16 9a       	mov	r10,r11
8000b4dc:	30 0b       	mov	r11,0
8000b4de:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b4e2:	ed ba 00 00 	bld	r10,0x0
8000b4e6:	c0 92       	brcc	8000b4f8 <__avr32_s32_to_f64+0x9a>
8000b4e8:	1c 7e       	tst	lr,lr
8000b4ea:	c0 41       	brne	8000b4f2 <__avr32_s32_to_f64+0x94>
8000b4ec:	ed ba 00 01 	bld	r10,0x1
8000b4f0:	c0 42       	brcc	8000b4f8 <__avr32_s32_to_f64+0x9a>
8000b4f2:	2f fa       	sub	r10,-1
8000b4f4:	f7 bb 02 ff 	subhs	r11,-1
8000b4f8:	5c fc       	rol	r12
8000b4fa:	5d 0b       	ror	r11
8000b4fc:	5d 0a       	ror	r10
8000b4fe:	d8 02       	popm	pc
8000b500:	e0 68 03 ff 	mov	r8,1023
8000b504:	ed ba 00 0b 	bld	r10,0xb
8000b508:	f7 b8 00 ff 	subeq	r8,-1
8000b50c:	10 0a       	add	r10,r8
8000b50e:	5c 0b       	acr	r11
8000b510:	f7 b9 03 fe 	sublo	r9,-2
8000b514:	e0 49 07 ff 	cp.w	r9,2047
8000b518:	c0 55       	brlt	8000b522 <__avr32_s32_to_f64+0xc4>
8000b51a:	30 0a       	mov	r10,0
8000b51c:	fc 1b ff e0 	movh	r11,0xffe0
8000b520:	c0 c8       	rjmp	8000b538 <__floatsidf_return_op1>
8000b522:	ed bb 00 1f 	bld	r11,0x1f
8000b526:	f7 b9 01 01 	subne	r9,1
8000b52a:	ab 9a       	lsr	r10,0xb
8000b52c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b530:	a1 7b       	lsl	r11,0x1
8000b532:	ab 9b       	lsr	r11,0xb
8000b534:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b538 <__floatsidf_return_op1>:
8000b538:	a1 7c       	lsl	r12,0x1
8000b53a:	5d 0b       	ror	r11
8000b53c:	d8 02       	popm	pc

8000b53e <__avr32_f64_cmp_eq>:
8000b53e:	10 3a       	cp.w	r10,r8
8000b540:	f2 0b 13 00 	cpc	r11,r9
8000b544:	c0 80       	breq	8000b554 <__avr32_f64_cmp_eq+0x16>
8000b546:	a1 7b       	lsl	r11,0x1
8000b548:	a1 79       	lsl	r9,0x1
8000b54a:	14 4b       	or	r11,r10
8000b54c:	12 4b       	or	r11,r9
8000b54e:	10 4b       	or	r11,r8
8000b550:	5e 0f       	reteq	1
8000b552:	5e fd       	retal	0
8000b554:	a1 7b       	lsl	r11,0x1
8000b556:	fc 1c ff e0 	movh	r12,0xffe0
8000b55a:	58 0a       	cp.w	r10,0
8000b55c:	f8 0b 13 00 	cpc	r11,r12
8000b560:	5e 8f       	retls	1
8000b562:	5e fd       	retal	0

8000b564 <__avr32_f64_cmp_ge>:
8000b564:	1a de       	st.w	--sp,lr
8000b566:	1a d7       	st.w	--sp,r7
8000b568:	a1 7b       	lsl	r11,0x1
8000b56a:	5f 3c       	srlo	r12
8000b56c:	a1 79       	lsl	r9,0x1
8000b56e:	5f 37       	srlo	r7
8000b570:	5c fc       	rol	r12
8000b572:	fc 1e ff e0 	movh	lr,0xffe0
8000b576:	58 0a       	cp.w	r10,0
8000b578:	fc 0b 13 00 	cpc	r11,lr
8000b57c:	e0 8b 00 1d 	brhi	8000b5b6 <__avr32_f64_cmp_ge+0x52>
8000b580:	58 08       	cp.w	r8,0
8000b582:	fc 09 13 00 	cpc	r9,lr
8000b586:	e0 8b 00 18 	brhi	8000b5b6 <__avr32_f64_cmp_ge+0x52>
8000b58a:	58 0b       	cp.w	r11,0
8000b58c:	f5 ba 00 00 	subfeq	r10,0
8000b590:	c1 50       	breq	8000b5ba <__avr32_f64_cmp_ge+0x56>
8000b592:	1b 07       	ld.w	r7,sp++
8000b594:	1b 0e       	ld.w	lr,sp++
8000b596:	58 3c       	cp.w	r12,3
8000b598:	c0 a0       	breq	8000b5ac <__avr32_f64_cmp_ge+0x48>
8000b59a:	58 1c       	cp.w	r12,1
8000b59c:	c0 33       	brcs	8000b5a2 <__avr32_f64_cmp_ge+0x3e>
8000b59e:	5e 0f       	reteq	1
8000b5a0:	5e 1d       	retne	0
8000b5a2:	10 3a       	cp.w	r10,r8
8000b5a4:	f2 0b 13 00 	cpc	r11,r9
8000b5a8:	5e 2f       	reths	1
8000b5aa:	5e 3d       	retlo	0
8000b5ac:	14 38       	cp.w	r8,r10
8000b5ae:	f6 09 13 00 	cpc	r9,r11
8000b5b2:	5e 2f       	reths	1
8000b5b4:	5e 3d       	retlo	0
8000b5b6:	1b 07       	ld.w	r7,sp++
8000b5b8:	d8 0a       	popm	pc,r12=0
8000b5ba:	58 17       	cp.w	r7,1
8000b5bc:	5f 0c       	sreq	r12
8000b5be:	58 09       	cp.w	r9,0
8000b5c0:	f5 b8 00 00 	subfeq	r8,0
8000b5c4:	1b 07       	ld.w	r7,sp++
8000b5c6:	1b 0e       	ld.w	lr,sp++
8000b5c8:	5e 0f       	reteq	1
8000b5ca:	5e fc       	retal	r12

8000b5cc <__avr32_f64_cmp_lt>:
8000b5cc:	1a de       	st.w	--sp,lr
8000b5ce:	1a d7       	st.w	--sp,r7
8000b5d0:	a1 7b       	lsl	r11,0x1
8000b5d2:	5f 3c       	srlo	r12
8000b5d4:	a1 79       	lsl	r9,0x1
8000b5d6:	5f 37       	srlo	r7
8000b5d8:	5c fc       	rol	r12
8000b5da:	fc 1e ff e0 	movh	lr,0xffe0
8000b5de:	58 0a       	cp.w	r10,0
8000b5e0:	fc 0b 13 00 	cpc	r11,lr
8000b5e4:	e0 8b 00 1d 	brhi	8000b61e <__avr32_f64_cmp_lt+0x52>
8000b5e8:	58 08       	cp.w	r8,0
8000b5ea:	fc 09 13 00 	cpc	r9,lr
8000b5ee:	e0 8b 00 18 	brhi	8000b61e <__avr32_f64_cmp_lt+0x52>
8000b5f2:	58 0b       	cp.w	r11,0
8000b5f4:	f5 ba 00 00 	subfeq	r10,0
8000b5f8:	c1 50       	breq	8000b622 <__avr32_f64_cmp_lt+0x56>
8000b5fa:	1b 07       	ld.w	r7,sp++
8000b5fc:	1b 0e       	ld.w	lr,sp++
8000b5fe:	58 3c       	cp.w	r12,3
8000b600:	c0 a0       	breq	8000b614 <__avr32_f64_cmp_lt+0x48>
8000b602:	58 1c       	cp.w	r12,1
8000b604:	c0 33       	brcs	8000b60a <__avr32_f64_cmp_lt+0x3e>
8000b606:	5e 0d       	reteq	0
8000b608:	5e 1f       	retne	1
8000b60a:	10 3a       	cp.w	r10,r8
8000b60c:	f2 0b 13 00 	cpc	r11,r9
8000b610:	5e 2d       	reths	0
8000b612:	5e 3f       	retlo	1
8000b614:	14 38       	cp.w	r8,r10
8000b616:	f6 09 13 00 	cpc	r9,r11
8000b61a:	5e 2d       	reths	0
8000b61c:	5e 3f       	retlo	1
8000b61e:	1b 07       	ld.w	r7,sp++
8000b620:	d8 0a       	popm	pc,r12=0
8000b622:	58 17       	cp.w	r7,1
8000b624:	5f 1c       	srne	r12
8000b626:	58 09       	cp.w	r9,0
8000b628:	f5 b8 00 00 	subfeq	r8,0
8000b62c:	1b 07       	ld.w	r7,sp++
8000b62e:	1b 0e       	ld.w	lr,sp++
8000b630:	5e 0d       	reteq	0
8000b632:	5e fc       	retal	r12

8000b634 <__avr32_f64_div>:
8000b634:	eb cd 40 ff 	pushm	r0-r7,lr
8000b638:	f7 e9 20 0e 	eor	lr,r11,r9
8000b63c:	f6 07 16 14 	lsr	r7,r11,0x14
8000b640:	a9 7b       	lsl	r11,0x9
8000b642:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b646:	a9 7a       	lsl	r10,0x9
8000b648:	bd bb       	sbr	r11,0x1d
8000b64a:	e4 1b 3f ff 	andh	r11,0x3fff
8000b64e:	ab d7       	cbr	r7,0xb
8000b650:	e0 80 00 cc 	breq	8000b7e8 <__avr32_f64_div_round_subnormal+0x54>
8000b654:	e0 47 07 ff 	cp.w	r7,2047
8000b658:	e0 84 00 b5 	brge	8000b7c2 <__avr32_f64_div_round_subnormal+0x2e>
8000b65c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b660:	a9 79       	lsl	r9,0x9
8000b662:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b666:	a9 78       	lsl	r8,0x9
8000b668:	bd b9       	sbr	r9,0x1d
8000b66a:	e4 19 3f ff 	andh	r9,0x3fff
8000b66e:	ab d6       	cbr	r6,0xb
8000b670:	e0 80 00 e2 	breq	8000b834 <__avr32_f64_div_round_subnormal+0xa0>
8000b674:	e0 46 07 ff 	cp.w	r6,2047
8000b678:	e0 84 00 b2 	brge	8000b7dc <__avr32_f64_div_round_subnormal+0x48>
8000b67c:	0c 17       	sub	r7,r6
8000b67e:	fe 37 fc 01 	sub	r7,-1023
8000b682:	fc 1c 80 00 	movh	r12,0x8000
8000b686:	f8 03 16 01 	lsr	r3,r12,0x1
8000b68a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b68e:	5c d4       	com	r4
8000b690:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b694:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b698:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b69c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6a0:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6a4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6a8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b6ac:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6b0:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6b4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6b8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b6bc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6c0:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6c4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b6c8:	e4 09 07 40 	macu.d	r0,r2,r9
8000b6cc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b6d0:	02 04       	add	r4,r1
8000b6d2:	5c 05       	acr	r5
8000b6d4:	a3 65       	lsl	r5,0x2
8000b6d6:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b6da:	a3 64       	lsl	r4,0x2
8000b6dc:	5c 34       	neg	r4
8000b6de:	f8 05 01 45 	sbc	r5,r12,r5
8000b6e2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b6e6:	e4 05 07 40 	macu.d	r0,r2,r5
8000b6ea:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b6ee:	02 04       	add	r4,r1
8000b6f0:	5c 05       	acr	r5
8000b6f2:	ea 03 15 02 	lsl	r3,r5,0x2
8000b6f6:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b6fa:	e8 02 15 02 	lsl	r2,r4,0x2
8000b6fe:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b702:	e4 09 07 40 	macu.d	r0,r2,r9
8000b706:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b70a:	02 04       	add	r4,r1
8000b70c:	5c 05       	acr	r5
8000b70e:	a3 65       	lsl	r5,0x2
8000b710:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b714:	a3 64       	lsl	r4,0x2
8000b716:	5c 34       	neg	r4
8000b718:	f8 05 01 45 	sbc	r5,r12,r5
8000b71c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b720:	e4 05 07 40 	macu.d	r0,r2,r5
8000b724:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b728:	02 04       	add	r4,r1
8000b72a:	5c 05       	acr	r5
8000b72c:	ea 03 15 02 	lsl	r3,r5,0x2
8000b730:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b734:	e8 02 15 02 	lsl	r2,r4,0x2
8000b738:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b73c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b740:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b744:	02 02       	add	r2,r1
8000b746:	5c 03       	acr	r3
8000b748:	ed b3 00 1c 	bld	r3,0x1c
8000b74c:	c0 90       	breq	8000b75e <__avr32_f64_div+0x12a>
8000b74e:	a1 72       	lsl	r2,0x1
8000b750:	5c f3       	rol	r3
8000b752:	20 17       	sub	r7,1
8000b754:	a3 9a       	lsr	r10,0x3
8000b756:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b75a:	a3 9b       	lsr	r11,0x3
8000b75c:	c0 58       	rjmp	8000b766 <__avr32_f64_div+0x132>
8000b75e:	a5 8a       	lsr	r10,0x4
8000b760:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b764:	a5 8b       	lsr	r11,0x4
8000b766:	58 07       	cp.w	r7,0
8000b768:	e0 8a 00 8b 	brle	8000b87e <__avr32_f64_div_res_subnormal>
8000b76c:	e0 12 ff 00 	andl	r2,0xff00
8000b770:	e8 12 00 80 	orl	r2,0x80
8000b774:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b778:	e4 09 07 40 	macu.d	r0,r2,r9
8000b77c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b780:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b784:	00 05       	add	r5,r0
8000b786:	f0 01 00 48 	adc	r8,r8,r1
8000b78a:	5c 09       	acr	r9
8000b78c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b790:	58 04       	cp.w	r4,0
8000b792:	5c 25       	cpc	r5

8000b794 <__avr32_f64_div_round_subnormal>:
8000b794:	f4 08 13 00 	cpc	r8,r10
8000b798:	f6 09 13 00 	cpc	r9,r11
8000b79c:	5f 36       	srlo	r6
8000b79e:	f8 06 17 00 	moveq	r6,r12
8000b7a2:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b7a6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b7aa:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b7ae:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b7b2:	ed be 00 1f 	bld	lr,0x1f
8000b7b6:	ef bb 00 1f 	bst	r11,0x1f
8000b7ba:	0c 0a       	add	r10,r6
8000b7bc:	5c 0b       	acr	r11
8000b7be:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b7c2:	e4 1b 00 0f 	andh	r11,0xf
8000b7c6:	14 4b       	or	r11,r10
8000b7c8:	e0 81 00 a7 	brne	8000b916 <__avr32_f64_div_res_subnormal+0x98>
8000b7cc:	f2 06 16 14 	lsr	r6,r9,0x14
8000b7d0:	ab d6       	cbr	r6,0xb
8000b7d2:	e0 46 07 ff 	cp.w	r6,2047
8000b7d6:	e0 81 00 a4 	brne	8000b91e <__avr32_f64_div_res_subnormal+0xa0>
8000b7da:	c9 e8       	rjmp	8000b916 <__avr32_f64_div_res_subnormal+0x98>
8000b7dc:	e4 19 00 0f 	andh	r9,0xf
8000b7e0:	10 49       	or	r9,r8
8000b7e2:	e0 81 00 9a 	brne	8000b916 <__avr32_f64_div_res_subnormal+0x98>
8000b7e6:	c9 28       	rjmp	8000b90a <__avr32_f64_div_res_subnormal+0x8c>
8000b7e8:	a3 7b       	lsl	r11,0x3
8000b7ea:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b7ee:	a3 7a       	lsl	r10,0x3
8000b7f0:	f5 eb 10 04 	or	r4,r10,r11
8000b7f4:	e0 80 00 a0 	breq	8000b934 <__avr32_f64_div_op1_zero>
8000b7f8:	f6 04 12 00 	clz	r4,r11
8000b7fc:	c1 70       	breq	8000b82a <__avr32_f64_div_round_subnormal+0x96>
8000b7fe:	c0 c3       	brcs	8000b816 <__avr32_f64_div_round_subnormal+0x82>
8000b800:	e8 05 11 20 	rsub	r5,r4,32
8000b804:	f6 04 09 4b 	lsl	r11,r11,r4
8000b808:	f4 05 0a 45 	lsr	r5,r10,r5
8000b80c:	0a 4b       	or	r11,r5
8000b80e:	f4 04 09 4a 	lsl	r10,r10,r4
8000b812:	08 17       	sub	r7,r4
8000b814:	c0 b8       	rjmp	8000b82a <__avr32_f64_div_round_subnormal+0x96>
8000b816:	f4 04 12 00 	clz	r4,r10
8000b81a:	f9 b4 03 00 	movlo	r4,0
8000b81e:	f7 b4 02 e0 	subhs	r4,-32
8000b822:	f4 04 09 4b 	lsl	r11,r10,r4
8000b826:	30 0a       	mov	r10,0
8000b828:	08 17       	sub	r7,r4
8000b82a:	a3 8a       	lsr	r10,0x2
8000b82c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b830:	a3 8b       	lsr	r11,0x2
8000b832:	c1 1b       	rjmp	8000b654 <__avr32_f64_div+0x20>
8000b834:	a3 79       	lsl	r9,0x3
8000b836:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b83a:	a3 78       	lsl	r8,0x3
8000b83c:	f3 e8 10 04 	or	r4,r9,r8
8000b840:	c6 f0       	breq	8000b91e <__avr32_f64_div_res_subnormal+0xa0>
8000b842:	f2 04 12 00 	clz	r4,r9
8000b846:	c1 70       	breq	8000b874 <__avr32_f64_div_round_subnormal+0xe0>
8000b848:	c0 c3       	brcs	8000b860 <__avr32_f64_div_round_subnormal+0xcc>
8000b84a:	e8 05 11 20 	rsub	r5,r4,32
8000b84e:	f2 04 09 49 	lsl	r9,r9,r4
8000b852:	f0 05 0a 45 	lsr	r5,r8,r5
8000b856:	0a 49       	or	r9,r5
8000b858:	f0 04 09 48 	lsl	r8,r8,r4
8000b85c:	08 16       	sub	r6,r4
8000b85e:	c0 b8       	rjmp	8000b874 <__avr32_f64_div_round_subnormal+0xe0>
8000b860:	f0 04 12 00 	clz	r4,r8
8000b864:	f9 b4 03 00 	movlo	r4,0
8000b868:	f7 b4 02 e0 	subhs	r4,-32
8000b86c:	f0 04 09 49 	lsl	r9,r8,r4
8000b870:	30 08       	mov	r8,0
8000b872:	08 16       	sub	r6,r4
8000b874:	a3 88       	lsr	r8,0x2
8000b876:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b87a:	a3 89       	lsr	r9,0x2
8000b87c:	cf ca       	rjmp	8000b674 <__avr32_f64_div+0x40>

8000b87e <__avr32_f64_div_res_subnormal>:
8000b87e:	5c 37       	neg	r7
8000b880:	2f f7       	sub	r7,-1
8000b882:	f1 b7 04 c0 	satu	r7,0x6
8000b886:	e0 47 00 20 	cp.w	r7,32
8000b88a:	c1 54       	brge	8000b8b4 <__avr32_f64_div_res_subnormal+0x36>
8000b88c:	ee 06 11 20 	rsub	r6,r7,32
8000b890:	e4 07 0a 42 	lsr	r2,r2,r7
8000b894:	e6 06 09 4c 	lsl	r12,r3,r6
8000b898:	18 42       	or	r2,r12
8000b89a:	e6 07 0a 43 	lsr	r3,r3,r7
8000b89e:	f4 06 09 41 	lsl	r1,r10,r6
8000b8a2:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b8a6:	f6 06 09 4c 	lsl	r12,r11,r6
8000b8aa:	18 4a       	or	r10,r12
8000b8ac:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b8b0:	30 00       	mov	r0,0
8000b8b2:	c1 58       	rjmp	8000b8dc <__avr32_f64_div_res_subnormal+0x5e>
8000b8b4:	ee 06 11 20 	rsub	r6,r7,32
8000b8b8:	f9 b0 00 00 	moveq	r0,0
8000b8bc:	f9 bc 00 00 	moveq	r12,0
8000b8c0:	c0 50       	breq	8000b8ca <__avr32_f64_div_res_subnormal+0x4c>
8000b8c2:	f4 06 09 40 	lsl	r0,r10,r6
8000b8c6:	f6 06 09 4c 	lsl	r12,r11,r6
8000b8ca:	e6 07 0a 42 	lsr	r2,r3,r7
8000b8ce:	30 03       	mov	r3,0
8000b8d0:	f4 07 0a 41 	lsr	r1,r10,r7
8000b8d4:	18 41       	or	r1,r12
8000b8d6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b8da:	30 0b       	mov	r11,0
8000b8dc:	e0 12 ff 00 	andl	r2,0xff00
8000b8e0:	e8 12 00 80 	orl	r2,0x80
8000b8e4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b8e8:	e4 09 07 46 	macu.d	r6,r2,r9
8000b8ec:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b8f0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b8f4:	0c 05       	add	r5,r6
8000b8f6:	f0 07 00 48 	adc	r8,r8,r7
8000b8fa:	5c 09       	acr	r9
8000b8fc:	30 07       	mov	r7,0
8000b8fe:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b902:	00 34       	cp.w	r4,r0
8000b904:	e2 05 13 00 	cpc	r5,r1
8000b908:	c4 6b       	rjmp	8000b794 <__avr32_f64_div_round_subnormal>
8000b90a:	1c 9b       	mov	r11,lr
8000b90c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b910:	30 0a       	mov	r10,0
8000b912:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b916:	3f fb       	mov	r11,-1
8000b918:	30 0a       	mov	r10,0
8000b91a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b91e:	f5 eb 10 04 	or	r4,r10,r11
8000b922:	c0 90       	breq	8000b934 <__avr32_f64_div_op1_zero>
8000b924:	1c 9b       	mov	r11,lr
8000b926:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b92a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b92e:	30 0a       	mov	r10,0
8000b930:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b934 <__avr32_f64_div_op1_zero>:
8000b934:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b938:	ce f0       	breq	8000b916 <__avr32_f64_div_res_subnormal+0x98>
8000b93a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b93e:	e0 44 07 ff 	cp.w	r4,2047
8000b942:	ce 41       	brne	8000b90a <__avr32_f64_div_res_subnormal+0x8c>
8000b944:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b948:	ce 10       	breq	8000b90a <__avr32_f64_div_res_subnormal+0x8c>
8000b94a:	ce 6b       	rjmp	8000b916 <__avr32_f64_div_res_subnormal+0x98>

8000b94c <__avr32_udiv64>:
8000b94c:	d4 31       	pushm	r0-r7,lr
8000b94e:	1a 97       	mov	r7,sp
8000b950:	20 3d       	sub	sp,12
8000b952:	10 9c       	mov	r12,r8
8000b954:	12 9e       	mov	lr,r9
8000b956:	14 93       	mov	r3,r10
8000b958:	58 09       	cp.w	r9,0
8000b95a:	e0 81 00 bd 	brne	8000bad4 <__avr32_udiv64+0x188>
8000b95e:	16 38       	cp.w	r8,r11
8000b960:	e0 88 00 40 	brls	8000b9e0 <__avr32_udiv64+0x94>
8000b964:	f0 08 12 00 	clz	r8,r8
8000b968:	c0 d0       	breq	8000b982 <__avr32_udiv64+0x36>
8000b96a:	f6 08 09 4b 	lsl	r11,r11,r8
8000b96e:	f0 09 11 20 	rsub	r9,r8,32
8000b972:	f8 08 09 4c 	lsl	r12,r12,r8
8000b976:	f4 09 0a 49 	lsr	r9,r10,r9
8000b97a:	f4 08 09 43 	lsl	r3,r10,r8
8000b97e:	f3 eb 10 0b 	or	r11,r9,r11
8000b982:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b986:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b98a:	f6 0e 0d 00 	divu	r0,r11,lr
8000b98e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b992:	00 99       	mov	r9,r0
8000b994:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b998:	e0 0a 02 48 	mul	r8,r0,r10
8000b99c:	10 3b       	cp.w	r11,r8
8000b99e:	c0 a2       	brcc	8000b9b2 <__avr32_udiv64+0x66>
8000b9a0:	20 19       	sub	r9,1
8000b9a2:	18 0b       	add	r11,r12
8000b9a4:	18 3b       	cp.w	r11,r12
8000b9a6:	c0 63       	brcs	8000b9b2 <__avr32_udiv64+0x66>
8000b9a8:	10 3b       	cp.w	r11,r8
8000b9aa:	f7 b9 03 01 	sublo	r9,1
8000b9ae:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b9b2:	f6 08 01 01 	sub	r1,r11,r8
8000b9b6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b9ba:	e2 0e 0d 00 	divu	r0,r1,lr
8000b9be:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b9c2:	00 98       	mov	r8,r0
8000b9c4:	e0 0a 02 4a 	mul	r10,r0,r10
8000b9c8:	14 33       	cp.w	r3,r10
8000b9ca:	c0 82       	brcc	8000b9da <__avr32_udiv64+0x8e>
8000b9cc:	20 18       	sub	r8,1
8000b9ce:	18 03       	add	r3,r12
8000b9d0:	18 33       	cp.w	r3,r12
8000b9d2:	c0 43       	brcs	8000b9da <__avr32_udiv64+0x8e>
8000b9d4:	14 33       	cp.w	r3,r10
8000b9d6:	f7 b8 03 01 	sublo	r8,1
8000b9da:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b9de:	cd f8       	rjmp	8000bb9c <__avr32_udiv64+0x250>
8000b9e0:	58 08       	cp.w	r8,0
8000b9e2:	c0 51       	brne	8000b9ec <__avr32_udiv64+0xa0>
8000b9e4:	30 19       	mov	r9,1
8000b9e6:	f2 08 0d 08 	divu	r8,r9,r8
8000b9ea:	10 9c       	mov	r12,r8
8000b9ec:	f8 06 12 00 	clz	r6,r12
8000b9f0:	c0 41       	brne	8000b9f8 <__avr32_udiv64+0xac>
8000b9f2:	18 1b       	sub	r11,r12
8000b9f4:	30 19       	mov	r9,1
8000b9f6:	c4 08       	rjmp	8000ba76 <__avr32_udiv64+0x12a>
8000b9f8:	ec 01 11 20 	rsub	r1,r6,32
8000b9fc:	f4 01 0a 49 	lsr	r9,r10,r1
8000ba00:	f8 06 09 4c 	lsl	r12,r12,r6
8000ba04:	f6 06 09 48 	lsl	r8,r11,r6
8000ba08:	f6 01 0a 41 	lsr	r1,r11,r1
8000ba0c:	f3 e8 10 08 	or	r8,r9,r8
8000ba10:	f8 03 16 10 	lsr	r3,r12,0x10
8000ba14:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ba18:	e2 03 0d 00 	divu	r0,r1,r3
8000ba1c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ba20:	00 9e       	mov	lr,r0
8000ba22:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba26:	e0 05 02 49 	mul	r9,r0,r5
8000ba2a:	12 3b       	cp.w	r11,r9
8000ba2c:	c0 a2       	brcc	8000ba40 <__avr32_udiv64+0xf4>
8000ba2e:	20 1e       	sub	lr,1
8000ba30:	18 0b       	add	r11,r12
8000ba32:	18 3b       	cp.w	r11,r12
8000ba34:	c0 63       	brcs	8000ba40 <__avr32_udiv64+0xf4>
8000ba36:	12 3b       	cp.w	r11,r9
8000ba38:	f7 be 03 01 	sublo	lr,1
8000ba3c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ba40:	12 1b       	sub	r11,r9
8000ba42:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000ba46:	f6 03 0d 02 	divu	r2,r11,r3
8000ba4a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000ba4e:	04 99       	mov	r9,r2
8000ba50:	e4 05 02 4b 	mul	r11,r2,r5
8000ba54:	16 38       	cp.w	r8,r11
8000ba56:	c0 a2       	brcc	8000ba6a <__avr32_udiv64+0x11e>
8000ba58:	20 19       	sub	r9,1
8000ba5a:	18 08       	add	r8,r12
8000ba5c:	18 38       	cp.w	r8,r12
8000ba5e:	c0 63       	brcs	8000ba6a <__avr32_udiv64+0x11e>
8000ba60:	16 38       	cp.w	r8,r11
8000ba62:	f7 b9 03 01 	sublo	r9,1
8000ba66:	f1 dc e3 08 	addcs	r8,r8,r12
8000ba6a:	f4 06 09 43 	lsl	r3,r10,r6
8000ba6e:	f0 0b 01 0b 	sub	r11,r8,r11
8000ba72:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000ba76:	f8 06 16 10 	lsr	r6,r12,0x10
8000ba7a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000ba7e:	f6 06 0d 00 	divu	r0,r11,r6
8000ba82:	e6 0b 16 10 	lsr	r11,r3,0x10
8000ba86:	00 9a       	mov	r10,r0
8000ba88:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ba8c:	e0 0e 02 48 	mul	r8,r0,lr
8000ba90:	10 3b       	cp.w	r11,r8
8000ba92:	c0 a2       	brcc	8000baa6 <__avr32_udiv64+0x15a>
8000ba94:	20 1a       	sub	r10,1
8000ba96:	18 0b       	add	r11,r12
8000ba98:	18 3b       	cp.w	r11,r12
8000ba9a:	c0 63       	brcs	8000baa6 <__avr32_udiv64+0x15a>
8000ba9c:	10 3b       	cp.w	r11,r8
8000ba9e:	f7 ba 03 01 	sublo	r10,1
8000baa2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000baa6:	f6 08 01 01 	sub	r1,r11,r8
8000baaa:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000baae:	e2 06 0d 00 	divu	r0,r1,r6
8000bab2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bab6:	00 98       	mov	r8,r0
8000bab8:	e0 0e 02 4b 	mul	r11,r0,lr
8000babc:	16 33       	cp.w	r3,r11
8000babe:	c0 82       	brcc	8000bace <__avr32_udiv64+0x182>
8000bac0:	20 18       	sub	r8,1
8000bac2:	18 03       	add	r3,r12
8000bac4:	18 33       	cp.w	r3,r12
8000bac6:	c0 43       	brcs	8000bace <__avr32_udiv64+0x182>
8000bac8:	16 33       	cp.w	r3,r11
8000baca:	f7 b8 03 01 	sublo	r8,1
8000bace:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bad2:	c6 98       	rjmp	8000bba4 <__avr32_udiv64+0x258>
8000bad4:	16 39       	cp.w	r9,r11
8000bad6:	e0 8b 00 65 	brhi	8000bba0 <__avr32_udiv64+0x254>
8000bada:	f2 09 12 00 	clz	r9,r9
8000bade:	c0 b1       	brne	8000baf4 <__avr32_udiv64+0x1a8>
8000bae0:	10 3a       	cp.w	r10,r8
8000bae2:	5f 2a       	srhs	r10
8000bae4:	1c 3b       	cp.w	r11,lr
8000bae6:	5f b8       	srhi	r8
8000bae8:	10 4a       	or	r10,r8
8000baea:	f2 0a 18 00 	cp.b	r10,r9
8000baee:	c5 90       	breq	8000bba0 <__avr32_udiv64+0x254>
8000baf0:	30 18       	mov	r8,1
8000baf2:	c5 98       	rjmp	8000bba4 <__avr32_udiv64+0x258>
8000baf4:	f0 09 09 46 	lsl	r6,r8,r9
8000baf8:	f2 03 11 20 	rsub	r3,r9,32
8000bafc:	fc 09 09 4e 	lsl	lr,lr,r9
8000bb00:	f0 03 0a 48 	lsr	r8,r8,r3
8000bb04:	f6 09 09 4c 	lsl	r12,r11,r9
8000bb08:	f4 03 0a 42 	lsr	r2,r10,r3
8000bb0c:	ef 46 ff f4 	st.w	r7[-12],r6
8000bb10:	f6 03 0a 43 	lsr	r3,r11,r3
8000bb14:	18 42       	or	r2,r12
8000bb16:	f1 ee 10 0c 	or	r12,r8,lr
8000bb1a:	f8 01 16 10 	lsr	r1,r12,0x10
8000bb1e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bb22:	e6 01 0d 04 	divu	r4,r3,r1
8000bb26:	e4 03 16 10 	lsr	r3,r2,0x10
8000bb2a:	08 9e       	mov	lr,r4
8000bb2c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bb30:	e8 06 02 48 	mul	r8,r4,r6
8000bb34:	10 33       	cp.w	r3,r8
8000bb36:	c0 a2       	brcc	8000bb4a <__avr32_udiv64+0x1fe>
8000bb38:	20 1e       	sub	lr,1
8000bb3a:	18 03       	add	r3,r12
8000bb3c:	18 33       	cp.w	r3,r12
8000bb3e:	c0 63       	brcs	8000bb4a <__avr32_udiv64+0x1fe>
8000bb40:	10 33       	cp.w	r3,r8
8000bb42:	f7 be 03 01 	sublo	lr,1
8000bb46:	e7 dc e3 03 	addcs	r3,r3,r12
8000bb4a:	10 13       	sub	r3,r8
8000bb4c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bb50:	e6 01 0d 00 	divu	r0,r3,r1
8000bb54:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bb58:	00 98       	mov	r8,r0
8000bb5a:	e0 06 02 46 	mul	r6,r0,r6
8000bb5e:	0c 3b       	cp.w	r11,r6
8000bb60:	c0 a2       	brcc	8000bb74 <__avr32_udiv64+0x228>
8000bb62:	20 18       	sub	r8,1
8000bb64:	18 0b       	add	r11,r12
8000bb66:	18 3b       	cp.w	r11,r12
8000bb68:	c0 63       	brcs	8000bb74 <__avr32_udiv64+0x228>
8000bb6a:	0c 3b       	cp.w	r11,r6
8000bb6c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bb70:	f7 b8 03 01 	sublo	r8,1
8000bb74:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000bb78:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000bb7c:	0c 1b       	sub	r11,r6
8000bb7e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000bb82:	06 95       	mov	r5,r3
8000bb84:	16 35       	cp.w	r5,r11
8000bb86:	e0 8b 00 0a 	brhi	8000bb9a <__avr32_udiv64+0x24e>
8000bb8a:	5f 0b       	sreq	r11
8000bb8c:	f4 09 09 49 	lsl	r9,r10,r9
8000bb90:	12 32       	cp.w	r2,r9
8000bb92:	5f b9       	srhi	r9
8000bb94:	f7 e9 00 09 	and	r9,r11,r9
8000bb98:	c0 60       	breq	8000bba4 <__avr32_udiv64+0x258>
8000bb9a:	20 18       	sub	r8,1
8000bb9c:	30 09       	mov	r9,0
8000bb9e:	c0 38       	rjmp	8000bba4 <__avr32_udiv64+0x258>
8000bba0:	30 09       	mov	r9,0
8000bba2:	12 98       	mov	r8,r9
8000bba4:	10 9a       	mov	r10,r8
8000bba6:	12 93       	mov	r3,r9
8000bba8:	10 92       	mov	r2,r8
8000bbaa:	12 9b       	mov	r11,r9
8000bbac:	2f dd       	sub	sp,-12
8000bbae:	d8 32       	popm	r0-r7,pc

8000bbb0 <__avr32_umod64>:
8000bbb0:	d4 31       	pushm	r0-r7,lr
8000bbb2:	1a 97       	mov	r7,sp
8000bbb4:	20 3d       	sub	sp,12
8000bbb6:	10 9c       	mov	r12,r8
8000bbb8:	12 95       	mov	r5,r9
8000bbba:	14 9e       	mov	lr,r10
8000bbbc:	16 91       	mov	r1,r11
8000bbbe:	16 96       	mov	r6,r11
8000bbc0:	58 09       	cp.w	r9,0
8000bbc2:	e0 81 00 81 	brne	8000bcc4 <__avr32_umod64+0x114>
8000bbc6:	16 38       	cp.w	r8,r11
8000bbc8:	e0 88 00 12 	brls	8000bbec <__avr32_umod64+0x3c>
8000bbcc:	f0 08 12 00 	clz	r8,r8
8000bbd0:	c4 e0       	breq	8000bc6c <__avr32_umod64+0xbc>
8000bbd2:	f6 08 09 46 	lsl	r6,r11,r8
8000bbd6:	f8 08 09 4c 	lsl	r12,r12,r8
8000bbda:	f0 0b 11 20 	rsub	r11,r8,32
8000bbde:	f4 08 09 4e 	lsl	lr,r10,r8
8000bbe2:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bbe6:	f7 e6 10 06 	or	r6,r11,r6
8000bbea:	c4 18       	rjmp	8000bc6c <__avr32_umod64+0xbc>
8000bbec:	58 08       	cp.w	r8,0
8000bbee:	c0 51       	brne	8000bbf8 <__avr32_umod64+0x48>
8000bbf0:	30 19       	mov	r9,1
8000bbf2:	f2 08 0d 08 	divu	r8,r9,r8
8000bbf6:	10 9c       	mov	r12,r8
8000bbf8:	f8 08 12 00 	clz	r8,r12
8000bbfc:	c0 31       	brne	8000bc02 <__avr32_umod64+0x52>
8000bbfe:	18 16       	sub	r6,r12
8000bc00:	c3 68       	rjmp	8000bc6c <__avr32_umod64+0xbc>
8000bc02:	f0 03 11 20 	rsub	r3,r8,32
8000bc06:	f4 03 0a 4b 	lsr	r11,r10,r3
8000bc0a:	f8 08 09 4c 	lsl	r12,r12,r8
8000bc0e:	ec 08 09 49 	lsl	r9,r6,r8
8000bc12:	ec 03 0a 43 	lsr	r3,r6,r3
8000bc16:	f7 e9 10 09 	or	r9,r11,r9
8000bc1a:	f8 05 16 10 	lsr	r5,r12,0x10
8000bc1e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bc22:	e6 05 0d 02 	divu	r2,r3,r5
8000bc26:	f2 0e 16 10 	lsr	lr,r9,0x10
8000bc2a:	ec 02 02 4b 	mul	r11,r6,r2
8000bc2e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bc32:	16 3e       	cp.w	lr,r11
8000bc34:	c0 72       	brcc	8000bc42 <__avr32_umod64+0x92>
8000bc36:	18 0e       	add	lr,r12
8000bc38:	18 3e       	cp.w	lr,r12
8000bc3a:	c0 43       	brcs	8000bc42 <__avr32_umod64+0x92>
8000bc3c:	16 3e       	cp.w	lr,r11
8000bc3e:	fd dc e3 0e 	addcs	lr,lr,r12
8000bc42:	fc 0b 01 03 	sub	r3,lr,r11
8000bc46:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bc4a:	e6 05 0d 02 	divu	r2,r3,r5
8000bc4e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bc52:	a5 36       	mul	r6,r2
8000bc54:	0c 39       	cp.w	r9,r6
8000bc56:	c0 72       	brcc	8000bc64 <__avr32_umod64+0xb4>
8000bc58:	18 09       	add	r9,r12
8000bc5a:	18 39       	cp.w	r9,r12
8000bc5c:	c0 43       	brcs	8000bc64 <__avr32_umod64+0xb4>
8000bc5e:	0c 39       	cp.w	r9,r6
8000bc60:	f3 dc e3 09 	addcs	r9,r9,r12
8000bc64:	f2 06 01 06 	sub	r6,r9,r6
8000bc68:	f4 08 09 4e 	lsl	lr,r10,r8
8000bc6c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bc70:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bc74:	ec 0a 0d 02 	divu	r2,r6,r10
8000bc78:	fc 09 16 10 	lsr	r9,lr,0x10
8000bc7c:	ea 02 02 4b 	mul	r11,r5,r2
8000bc80:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bc84:	16 39       	cp.w	r9,r11
8000bc86:	c0 72       	brcc	8000bc94 <__avr32_umod64+0xe4>
8000bc88:	18 09       	add	r9,r12
8000bc8a:	18 39       	cp.w	r9,r12
8000bc8c:	c0 43       	brcs	8000bc94 <__avr32_umod64+0xe4>
8000bc8e:	16 39       	cp.w	r9,r11
8000bc90:	f3 dc e3 09 	addcs	r9,r9,r12
8000bc94:	f2 0b 01 0b 	sub	r11,r9,r11
8000bc98:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bc9c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bca0:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bca4:	ea 0a 02 4a 	mul	r10,r5,r10
8000bca8:	14 3e       	cp.w	lr,r10
8000bcaa:	c0 72       	brcc	8000bcb8 <__avr32_umod64+0x108>
8000bcac:	18 0e       	add	lr,r12
8000bcae:	18 3e       	cp.w	lr,r12
8000bcb0:	c0 43       	brcs	8000bcb8 <__avr32_umod64+0x108>
8000bcb2:	14 3e       	cp.w	lr,r10
8000bcb4:	fd dc e3 0e 	addcs	lr,lr,r12
8000bcb8:	fc 0a 01 0a 	sub	r10,lr,r10
8000bcbc:	30 0b       	mov	r11,0
8000bcbe:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bcc2:	c7 b8       	rjmp	8000bdb8 <__avr32_umod64+0x208>
8000bcc4:	16 39       	cp.w	r9,r11
8000bcc6:	e0 8b 00 79 	brhi	8000bdb8 <__avr32_umod64+0x208>
8000bcca:	f2 09 12 00 	clz	r9,r9
8000bcce:	c1 21       	brne	8000bcf2 <__avr32_umod64+0x142>
8000bcd0:	10 3a       	cp.w	r10,r8
8000bcd2:	5f 2b       	srhs	r11
8000bcd4:	0a 31       	cp.w	r1,r5
8000bcd6:	5f ba       	srhi	r10
8000bcd8:	f7 ea 10 0a 	or	r10,r11,r10
8000bcdc:	f2 0a 18 00 	cp.b	r10,r9
8000bce0:	c0 60       	breq	8000bcec <__avr32_umod64+0x13c>
8000bce2:	fc 08 01 0c 	sub	r12,lr,r8
8000bce6:	e2 05 01 46 	sbc	r6,r1,r5
8000bcea:	18 9e       	mov	lr,r12
8000bcec:	0c 9b       	mov	r11,r6
8000bcee:	1c 9a       	mov	r10,lr
8000bcf0:	c6 48       	rjmp	8000bdb8 <__avr32_umod64+0x208>
8000bcf2:	ea 09 09 4c 	lsl	r12,r5,r9
8000bcf6:	f2 06 11 20 	rsub	r6,r9,32
8000bcfa:	f6 09 09 4b 	lsl	r11,r11,r9
8000bcfe:	f0 09 09 42 	lsl	r2,r8,r9
8000bd02:	ef 46 ff f4 	st.w	r7[-12],r6
8000bd06:	f0 06 0a 48 	lsr	r8,r8,r6
8000bd0a:	18 48       	or	r8,r12
8000bd0c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bd10:	f4 09 09 43 	lsl	r3,r10,r9
8000bd14:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bd18:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bd1c:	16 4a       	or	r10,r11
8000bd1e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bd22:	f8 0b 0d 04 	divu	r4,r12,r11
8000bd26:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bd2a:	08 91       	mov	r1,r4
8000bd2c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bd30:	e8 0e 02 46 	mul	r6,r4,lr
8000bd34:	0c 3c       	cp.w	r12,r6
8000bd36:	c0 a2       	brcc	8000bd4a <__avr32_umod64+0x19a>
8000bd38:	20 11       	sub	r1,1
8000bd3a:	10 0c       	add	r12,r8
8000bd3c:	10 3c       	cp.w	r12,r8
8000bd3e:	c0 63       	brcs	8000bd4a <__avr32_umod64+0x19a>
8000bd40:	0c 3c       	cp.w	r12,r6
8000bd42:	f7 b1 03 01 	sublo	r1,1
8000bd46:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bd4a:	0c 1c       	sub	r12,r6
8000bd4c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bd50:	f8 0b 0d 04 	divu	r4,r12,r11
8000bd54:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000bd58:	08 96       	mov	r6,r4
8000bd5a:	e8 0e 02 4e 	mul	lr,r4,lr
8000bd5e:	1c 3b       	cp.w	r11,lr
8000bd60:	c0 a2       	brcc	8000bd74 <__avr32_umod64+0x1c4>
8000bd62:	20 16       	sub	r6,1
8000bd64:	10 0b       	add	r11,r8
8000bd66:	10 3b       	cp.w	r11,r8
8000bd68:	c0 63       	brcs	8000bd74 <__avr32_umod64+0x1c4>
8000bd6a:	1c 3b       	cp.w	r11,lr
8000bd6c:	f7 b6 03 01 	sublo	r6,1
8000bd70:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000bd74:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000bd78:	1c 1b       	sub	r11,lr
8000bd7a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000bd7e:	00 9e       	mov	lr,r0
8000bd80:	02 9c       	mov	r12,r1
8000bd82:	16 3c       	cp.w	r12,r11
8000bd84:	e0 8b 00 08 	brhi	8000bd94 <__avr32_umod64+0x1e4>
8000bd88:	5f 06       	sreq	r6
8000bd8a:	06 30       	cp.w	r0,r3
8000bd8c:	5f ba       	srhi	r10
8000bd8e:	ed ea 00 0a 	and	r10,r6,r10
8000bd92:	c0 60       	breq	8000bd9e <__avr32_umod64+0x1ee>
8000bd94:	fc 02 01 04 	sub	r4,lr,r2
8000bd98:	f8 08 01 4c 	sbc	r12,r12,r8
8000bd9c:	08 9e       	mov	lr,r4
8000bd9e:	e6 0e 01 0a 	sub	r10,r3,lr
8000bda2:	f6 0c 01 4c 	sbc	r12,r11,r12
8000bda6:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000bdaa:	f8 09 0a 4b 	lsr	r11,r12,r9
8000bdae:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bdb2:	f8 01 09 4c 	lsl	r12,r12,r1
8000bdb6:	18 4a       	or	r10,r12
8000bdb8:	2f dd       	sub	sp,-12
8000bdba:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000be00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000be00:	c0 08       	rjmp	8000be00 <_evba>
	...

8000be04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000be04:	c0 08       	rjmp	8000be04 <_handle_TLB_Multiple_Hit>
	...

8000be08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000be08:	c0 08       	rjmp	8000be08 <_handle_Bus_Error_Data_Fetch>
	...

8000be0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000be0c:	c0 08       	rjmp	8000be0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000be10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000be10:	c0 08       	rjmp	8000be10 <_handle_NMI>
	...

8000be14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000be14:	c0 08       	rjmp	8000be14 <_handle_Instruction_Address>
	...

8000be18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000be18:	c0 08       	rjmp	8000be18 <_handle_ITLB_Protection>
	...

8000be1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000be1c:	c0 08       	rjmp	8000be1c <_handle_Breakpoint>
	...

8000be20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000be20:	c0 08       	rjmp	8000be20 <_handle_Illegal_Opcode>
	...

8000be24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000be24:	c0 08       	rjmp	8000be24 <_handle_Unimplemented_Instruction>
	...

8000be28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000be28:	c0 08       	rjmp	8000be28 <_handle_Privilege_Violation>
	...

8000be2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000be2c:	c0 08       	rjmp	8000be2c <_handle_Floating_Point>
	...

8000be30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000be30:	c0 08       	rjmp	8000be30 <_handle_Coprocessor_Absent>
	...

8000be34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000be34:	c0 08       	rjmp	8000be34 <_handle_Data_Address_Read>
	...

8000be38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000be38:	c0 08       	rjmp	8000be38 <_handle_Data_Address_Write>
	...

8000be3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000be3c:	c0 08       	rjmp	8000be3c <_handle_DTLB_Protection_Read>
	...

8000be40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000be40:	c0 08       	rjmp	8000be40 <_handle_DTLB_Protection_Write>
	...

8000be44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000be44:	c0 08       	rjmp	8000be44 <_handle_DTLB_Modified>
	...

8000be50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000be50:	c0 08       	rjmp	8000be50 <_handle_ITLB_Miss>
	...

8000be60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000be60:	c0 08       	rjmp	8000be60 <_handle_DTLB_Miss_Read>
	...

8000be70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000be70:	c0 08       	rjmp	8000be70 <_handle_DTLB_Miss_Write>
	...

8000bf00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bf00:	fe cf 70 18 	sub	pc,pc,28696

8000bf04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bf04:	30 0c       	mov	r12,0
8000bf06:	fe b0 c5 0d 	rcall	80004920 <_get_interrupt_handler>
8000bf0a:	58 0c       	cp.w	r12,0
8000bf0c:	f8 0f 17 10 	movne	pc,r12
8000bf10:	d6 03       	rete

8000bf12 <_int1>:
8000bf12:	30 1c       	mov	r12,1
8000bf14:	fe b0 c5 06 	rcall	80004920 <_get_interrupt_handler>
8000bf18:	58 0c       	cp.w	r12,0
8000bf1a:	f8 0f 17 10 	movne	pc,r12
8000bf1e:	d6 03       	rete

8000bf20 <_int2>:
8000bf20:	30 2c       	mov	r12,2
8000bf22:	fe b0 c4 ff 	rcall	80004920 <_get_interrupt_handler>
8000bf26:	58 0c       	cp.w	r12,0
8000bf28:	f8 0f 17 10 	movne	pc,r12
8000bf2c:	d6 03       	rete

8000bf2e <_int3>:
8000bf2e:	30 3c       	mov	r12,3
8000bf30:	fe b0 c4 f8 	rcall	80004920 <_get_interrupt_handler>
8000bf34:	58 0c       	cp.w	r12,0
8000bf36:	f8 0f 17 10 	movne	pc,r12
8000bf3a:	d6 03       	rete

8000bf3c <ipr_val>:
8000bf3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bf4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bf9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bfec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bffc:	d7 03 d7 03                                         ....
