
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000200c  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000cc08  8000200c  8000200c  0000240c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ee00  8000ee00  0000f200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000094c  8000f000  8000f000  0000f400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8000f94c  8000f94c  0000fd4c  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a2c  00000008  8000f950  00010008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  00000a34  8001037c  00010a34  2**0
                  ALLOC
  9 .bss          000036c0  00000a38  00000a38  00000000  2**2
                  ALLOC
 10 .heap         00012f08  000040f8  000040f8  00000000  2**0
                  ALLOC
 11 .comment      00000030  00000000  00000000  00010a34  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 000010c0  00000000  00000000  00010a68  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 00002117  00000000  00000000  00011b28  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   0002677a  00000000  00000000  00013c3f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 00005c79  00000000  00000000  0003a3b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   00014259  00000000  00000000  00040032  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00002d20  00000000  00000000  0005428c  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    0000683a  00000000  00000000  00056fac  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0000a528  00000000  00000000  0005d7e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_macinfo 0127a10c  00000000  00000000  00067d0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 22 .debug_ranges 00001120  00000000  00000000  012e1e20  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	92 f0       	ld.uh	r0,r9[0xe]

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe cf 8d 18 	sub	pc,pc,-29416

Disassembly of section .text:

8000200c <DeviceInitializationStatus_brdcst_func-0x708>:
8000200c:	54 6f       	stdsp	sp[0x118],pc
8000200e:	6e 65       	ld.w	r5,r7[0x18]
80002010:	20 4f       	sub	pc,4
80002012:	4b 00       	lddpc	r0,800020d0 <program_start+0xc8>
80002014:	54 6f       	stdsp	sp[0x118],pc
80002016:	6e 65       	ld.w	r5,r7[0x18]
80002018:	20 65       	sub	r5,6
8000201a:	72 72       	ld.w	r2,r9[0x1c]
8000201c:	6f 72       	ld.w	r2,r7[0x5c]
8000201e:	00 00       	add	r0,r0
80002020:	0a 0d       	add	sp,r5
80002022:	20 44       	sub	r4,4
80002024:	63 6d       	ld.w	sp,r1[0x58]
80002026:	2d 45       	sub	r5,-44
80002028:	6e 74       	ld.w	r4,r7[0x1c]
8000202a:	65 72       	ld.w	r2,r2[0x5c]
8000202c:	20 4f       	sub	pc,4
8000202e:	4b 20       	lddpc	r0,800020f4 <program_start+0xec>
80002030:	0a 0d       	add	sp,r5
80002032:	00 00       	add	r0,r0
80002034:	0a 0d       	add	sp,r5
80002036:	20 44       	sub	r4,4
80002038:	63 6d       	ld.w	sp,r1[0x58]
8000203a:	2d 45       	sub	r5,-44
8000203c:	78 69       	ld.w	r9,r12[0x18]
8000203e:	74 20       	ld.w	r0,r10[0x8]
80002040:	4f 4b       	lddpc	r11,80002210 <program_start+0x208>
80002042:	20 0a       	sub	r10,0
80002044:	0d 00       	ld.w	r0,r6++
80002046:	00 00       	add	r0,r0
80002048:	0a 0d       	add	sp,r5
8000204a:	20 44       	sub	r4,4
8000204c:	63 6d       	ld.w	sp,r1[0x58]
8000204e:	2d 52       	sub	r2,-43
80002050:	65 76       	ld.w	r6,r2[0x5c]
80002052:	6f 6b       	ld.w	r11,r7[0x58]
80002054:	65 20       	ld.w	r0,r2[0x48]
80002056:	0a 0d       	add	sp,r5
80002058:	00 00       	add	r0,r0
8000205a:	00 00       	add	r0,r0
8000205c:	64 63       	ld.w	r3,r2[0x18]
8000205e:	6d 20       	ld.w	r0,r6[0x48]
80002060:	4f 4b       	lddpc	r11,80002230 <program_start+0x228>
80002062:	2d 6d       	sub	sp,-168
80002064:	6f 25       	ld.w	r5,r7[0x48]
80002066:	58 00       	cp.w	r0,0
80002068:	64 63       	ld.w	r3,r2[0x18]
8000206a:	6d 20       	ld.w	r0,r6[0x48]
8000206c:	65 72       	ld.w	r2,r2[0x5c]
8000206e:	72 6f       	ld.w	pc,r9[0x18]
80002070:	72 00       	ld.w	r0,r9[0x0]
80002072:	00 00       	add	r0,r0
80002074:	0a 0d       	add	sp,r5
80002076:	20 44       	sub	r4,4
80002078:	63 6d       	ld.w	sp,r1[0x58]
8000207a:	5f 62       	srmi	r2
8000207c:	72 64       	ld.w	r4,r9[0x18]
8000207e:	63 73       	ld.w	r3,r1[0x5c]
80002080:	74 20       	ld.w	r0,r10[0x8]
80002082:	0a 0d       	add	sp,r5
80002084:	00 00       	add	r0,r0
80002086:	00 00       	add	r0,r0
80002088:	0a 0d       	add	sp,r5
8000208a:	20 46       	sub	r6,4
8000208c:	75 6e       	ld.w	lr,r10[0x58]
8000208e:	63 74       	ld.w	r4,r1[0x5c]
80002090:	69 6f       	ld.w	pc,r4[0x58]
80002092:	6e 3a       	ld.w	r10,r7[0xc]
80002094:	20 25       	sub	r5,2
80002096:	78 20       	ld.w	r0,r12[0x8]
80002098:	0a 0d       	add	sp,r5
8000209a:	20 00       	sub	r0,0
8000209c:	0a 0d       	add	sp,r5
8000209e:	20 43       	sub	r3,4
800020a0:	6f 6e       	ld.w	lr,r7[0x58]
800020a2:	74 72       	ld.w	r2,r10[0x1c]
800020a4:	6f 6c       	ld.w	r12,r7[0x58]
800020a6:	54 79       	stdsp	sp[0x11c],r9
800020a8:	70 65       	ld.w	r5,r8[0x18]
800020aa:	3a 20       	mov	r0,-94
800020ac:	25 78       	sub	r8,87
800020ae:	20 0a       	sub	r10,0
800020b0:	0d 20       	ld.uh	r0,r6++
800020b2:	00 00       	add	r0,r0
800020b4:	0a 0d       	add	sp,r5
800020b6:	20 43       	sub	r3,4
800020b8:	6f 6e       	ld.w	lr,r7[0x58]
800020ba:	74 72       	ld.w	r2,r10[0x1c]
800020bc:	6f 6c       	ld.w	r12,r7[0x58]
800020be:	54 79       	stdsp	sp[0x11c],r9
800020c0:	70 65       	ld.w	r5,r8[0x18]
800020c2:	53 69       	stdsp	sp[0xd8],r9
800020c4:	7a 65       	ld.w	r5,sp[0x18]
800020c6:	3a 20       	mov	r0,-94
800020c8:	25 78       	sub	r8,87
800020ca:	20 0a       	sub	r10,0
800020cc:	0d 20       	ld.uh	r0,r6++
800020ce:	00 00       	add	r0,r0
800020d0:	0a 0d       	add	sp,r5
800020d2:	20 4d       	sub	sp,16
800020d4:	69 63       	ld.w	r3,r4[0x58]
800020d6:	5f 72       	srpl	r2
800020d8:	65 70       	ld.w	r0,r2[0x5c]
800020da:	6c 79       	ld.w	r9,r6[0x1c]
800020dc:	20 0a       	sub	r10,0
800020de:	0d 00       	ld.w	r0,r6++
800020e0:	0a 0d       	add	sp,r5
800020e2:	20 4d       	sub	sp,16
800020e4:	69 63       	ld.w	r3,r4[0x58]
800020e6:	5f 63       	srmi	r3
800020e8:	6c 6f       	ld.w	pc,r6[0x18]
800020ea:	73 65       	ld.w	r5,r9[0x58]
800020ec:	5f 6f       	srmi	pc
800020ee:	6b 20       	ld.w	r0,r5[0x48]
800020f0:	0a 0d       	add	sp,r5
800020f2:	20 00       	sub	r0,0
800020f4:	0a 0d       	add	sp,r5
800020f6:	20 4d       	sub	sp,16
800020f8:	69 63       	ld.w	r3,r4[0x58]
800020fa:	5f 74       	srpl	r4
800020fc:	79 70       	ld.w	r0,r12[0x5c]
800020fe:	65 3a       	ld.w	r10,r2[0x4c]
80002100:	20 25       	sub	r5,2
80002102:	78 20       	ld.w	r0,r12[0x8]
80002104:	0a 0d       	add	sp,r5
80002106:	20 00       	sub	r0,0
80002108:	0a 0d       	add	sp,r5
8000210a:	20 53       	sub	r3,5
8000210c:	69 67       	ld.w	r7,r4[0x58]
8000210e:	6e 61       	ld.w	r1,r7[0x18]
80002110:	6c 69       	ld.w	r9,r6[0x18]
80002112:	6e 67       	ld.w	r7,r7[0x18]
80002114:	5f 74       	srpl	r4
80002116:	79 70       	ld.w	r0,r12[0x5c]
80002118:	65 3a       	ld.w	r10,r2[0x4c]
8000211a:	20 25       	sub	r5,2
8000211c:	78 20       	ld.w	r0,r12[0x8]
8000211e:	0a 0d       	add	sp,r5
80002120:	20 00       	sub	r0,0
80002122:	00 00       	add	r0,r0
80002124:	0a 0d       	add	sp,r5
80002126:	20 4d       	sub	sp,16
80002128:	69 63       	ld.w	r3,r4[0x58]
8000212a:	5f 73       	srpl	r3
8000212c:	74 61       	ld.w	r1,r10[0x18]
8000212e:	74 65       	ld.w	r5,r10[0x18]
80002130:	3a 20       	mov	r0,-94
80002132:	25 78       	sub	r8,87
80002134:	20 0a       	sub	r10,0
80002136:	0d 20       	ld.uh	r0,r6++
80002138:	00 00       	add	r0,r0
8000213a:	00 00       	add	r0,r0
8000213c:	0a 0d       	add	sp,r5
8000213e:	20 47       	sub	r7,4
80002140:	61 69       	ld.w	r9,r0[0x58]
80002142:	6e 5f       	ld.w	pc,r7[0x14]
80002144:	6f 66       	ld.w	r6,r7[0x58]
80002146:	66 73       	ld.w	r3,r3[0x1c]
80002148:	65 74       	ld.w	r4,r2[0x5c]
8000214a:	3a 20       	mov	r0,-94
8000214c:	25 78       	sub	r8,87
8000214e:	20 0a       	sub	r10,0
80002150:	0d 20       	ld.uh	r0,r6++
80002152:	00 00       	add	r0,r0
80002154:	0a 0d       	add	sp,r5
80002156:	20 4d       	sub	sp,16
80002158:	69 63       	ld.w	r3,r4[0x58]
8000215a:	5f 66       	srmi	r6
8000215c:	75 6e       	ld.w	lr,r10[0x58]
8000215e:	63 74       	ld.w	r4,r1[0x5c]
80002160:	69 6f       	ld.w	pc,r4[0x58]
80002162:	6e 3a       	ld.w	r10,r7[0xc]
80002164:	20 25       	sub	r5,2
80002166:	78 20       	ld.w	r0,r12[0x8]
80002168:	0a 0d       	add	sp,r5
8000216a:	20 00       	sub	r0,0
8000216c:	0a 0d       	add	sp,r5
8000216e:	20 4d       	sub	sp,16
80002170:	69 63       	ld.w	r3,r4[0x58]
80002172:	20 65       	sub	r5,6
80002174:	72 72       	ld.w	r2,r9[0x1c]
80002176:	6f 72       	ld.w	r2,r7[0x5c]
80002178:	20 0a       	sub	r10,0
8000217a:	0d 00       	ld.w	r0,r6++
8000217c:	0a 0d       	add	sp,r5
8000217e:	20 4d       	sub	sp,16
80002180:	69 63       	ld.w	r3,r4[0x58]
80002182:	5f 44       	srge	r4
80002184:	69 73       	ld.w	r3,r4[0x5c]
80002186:	61 62       	ld.w	r2,r0[0x58]
80002188:	6c 65       	ld.w	r5,r6[0x18]
8000218a:	64 20       	ld.w	r0,r2[0x8]
8000218c:	0a 0d       	add	sp,r5
8000218e:	00 00       	add	r0,r0
80002190:	0a 0d       	add	sp,r5
80002192:	20 4d       	sub	sp,16
80002194:	69 63       	ld.w	r3,r4[0x58]
80002196:	5f 45       	srge	r5
80002198:	6e 61       	ld.w	r1,r7[0x18]
8000219a:	62 6c       	ld.w	r12,r1[0x18]
8000219c:	65 64       	ld.w	r4,r2[0x58]
8000219e:	20 0a       	sub	r10,0
800021a0:	0d 00       	ld.w	r0,r6++
800021a2:	00 00       	add	r0,r0
800021a4:	73 70       	ld.w	r0,r9[0x5c]
800021a6:	6b 20       	ld.w	r0,r5[0x48]
800021a8:	4f 4b       	lddpc	r11,80002378 <program_start+0x370>
800021aa:	20 2d       	sub	sp,8
800021ac:	73 74       	ld.w	r4,r9[0x5c]
800021ae:	25 32       	sub	r2,83
800021b0:	78 00       	ld.w	r0,r12[0x0]
800021b2:	00 00       	add	r0,r0
800021b4:	73 70       	ld.w	r0,r9[0x5c]
800021b6:	6b 20       	ld.w	r0,r5[0x48]
800021b8:	65 72       	ld.w	r2,r2[0x5c]
800021ba:	72 6f       	ld.w	pc,r9[0x18]
800021bc:	72 00       	ld.w	r0,r9[0x0]
800021be:	00 00       	add	r0,r0
800021c0:	73 70       	ld.w	r0,r9[0x5c]
800021c2:	6b 5f       	ld.w	pc,r5[0x54]
800021c4:	73 5f       	ld.w	pc,r9[0x54]
800021c6:	63 6c       	ld.w	r12,r1[0x58]
800021c8:	6f 73       	ld.w	r3,r7[0x5c]
800021ca:	65 20       	ld.w	r0,r2[0x48]
800021cc:	00 00       	add	r0,r0
800021ce:	00 00       	add	r0,r0
800021d0:	73 70       	ld.w	r0,r9[0x5c]
800021d2:	6b 5f       	ld.w	pc,r5[0x54]
800021d4:	73 5f       	ld.w	pc,r9[0x54]
800021d6:	6f 70       	ld.w	r0,r7[0x5c]
800021d8:	65 6e       	ld.w	lr,r2[0x58]
800021da:	20 00       	sub	r0,0
800021dc:	0a 0d       	add	sp,r5
800021de:	20 45       	sub	r5,4
800021e0:	6e 61       	ld.w	r1,r7[0x18]
800021e2:	62 6c       	ld.w	r12,r1[0x18]
800021e4:	65 5f       	ld.w	pc,r2[0x54]
800021e6:	49 41       	lddpc	r1,80002234 <program_start+0x22c>
800021e8:	20 4f       	sub	pc,4
800021ea:	4b 20       	lddpc	r0,800022b0 <program_start+0x2a8>
800021ec:	0a 0d       	add	sp,r5
800021ee:	00 00       	add	r0,r0
800021f0:	0a 0d       	add	sp,r5
800021f2:	20 41       	sub	r1,4
800021f4:	74 74       	ld.w	r4,r10[0x1c]
800021f6:	65 6e       	ld.w	lr,r2[0x58]
800021f8:	75 61       	ld.w	r1,r10[0x58]
800021fa:	74 6f       	ld.w	pc,r10[0x18]
800021fc:	72 5f       	ld.w	pc,r9[0x14]
800021fe:	4e 75       	lddpc	r5,80002398 <program_start+0x390>
80002200:	6d 62       	ld.w	r2,r6[0x58]
80002202:	65 72       	ld.w	r2,r2[0x5c]
80002204:	3a 20       	mov	r0,-94
80002206:	25 78       	sub	r8,87
80002208:	20 0a       	sub	r10,0
8000220a:	0d 00       	ld.w	r0,r6++
8000220c:	0a 0d       	add	sp,r5
8000220e:	20 56       	sub	r6,5
80002210:	6f 6c       	ld.w	r12,r7[0x58]
80002212:	75 6d       	ld.w	sp,r10[0x58]
80002214:	65 43       	ld.w	r3,r2[0x50]
80002216:	6f 6e       	ld.w	lr,r7[0x58]
80002218:	74 72       	ld.w	r2,r10[0x1c]
8000221a:	6f 6c       	ld.w	r12,r7[0x58]
8000221c:	3a 20       	mov	r0,-94
8000221e:	25 78       	sub	r8,87
80002220:	20 0a       	sub	r10,0
80002222:	0d 00       	ld.w	r0,r6++
80002224:	0a 0d       	add	sp,r5
80002226:	20 45       	sub	r5,4
80002228:	6e 61       	ld.w	r1,r7[0x18]
8000222a:	62 6c       	ld.w	r12,r1[0x18]
8000222c:	65 5f       	ld.w	pc,r2[0x54]
8000222e:	49 41       	lddpc	r1,8000227c <program_start+0x274>
80002230:	20 65       	sub	r5,6
80002232:	72 72       	ld.w	r2,r9[0x1c]
80002234:	6f 72       	ld.w	r2,r7[0x5c]
80002236:	20 0a       	sub	r10,0
80002238:	0d 00       	ld.w	r0,r6++
8000223a:	00 00       	add	r0,r0
8000223c:	41 75       	lddsp	r5,sp[0x5c]
8000223e:	64 69       	ld.w	r9,r2[0x18]
80002240:	6f 52       	ld.w	r2,r7[0x54]
80002242:	6f 75       	ld.w	r5,r7[0x5c]
80002244:	74 69       	ld.w	r9,r10[0x18]
80002246:	6e 67       	ld.w	r7,r7[0x18]
80002248:	20 4f       	sub	pc,4
8000224a:	4b 00       	lddpc	r0,80002308 <program_start+0x300>
8000224c:	41 75       	lddsp	r5,sp[0x5c]
8000224e:	64 69       	ld.w	r9,r2[0x18]
80002250:	6f 52       	ld.w	r2,r7[0x54]
80002252:	6f 75       	ld.w	r5,r7[0x5c]
80002254:	74 69       	ld.w	r9,r10[0x18]
80002256:	6e 67       	ld.w	r7,r7[0x18]
80002258:	20 65       	sub	r5,6
8000225a:	72 72       	ld.w	r2,r9[0x1c]
8000225c:	6f 72       	ld.w	r2,r7[0x5c]
8000225e:	00 00       	add	r0,r0
80002260:	0a 0d       	add	sp,r5
80002262:	20 20       	sub	r0,2
80002264:	54 72       	stdsp	sp[0x11c],r2
80002266:	61 6e       	ld.w	lr,r0[0x58]
80002268:	73 6d       	ld.w	sp,r9[0x58]
8000226a:	69 74       	ld.w	r4,r4[0x5c]
8000226c:	43 6f       	lddsp	pc,sp[0xd8]
8000226e:	6e 74       	ld.w	r4,r7[0x1c]
80002270:	72 6f       	ld.w	pc,r9[0x18]
80002272:	6c 20       	ld.w	r0,r6[0x8]
80002274:	4f 4b       	lddpc	r11,80002444 <program_start+0x43c>
80002276:	20 0a       	sub	r10,0
80002278:	0d 20       	ld.uh	r0,r6++
8000227a:	00 00       	add	r0,r0
8000227c:	0a 0d       	add	sp,r5
8000227e:	20 46       	sub	r6,4
80002280:	75 6e       	ld.w	lr,r10[0x58]
80002282:	63 74       	ld.w	r4,r1[0x5c]
80002284:	69 6f       	ld.w	pc,r4[0x58]
80002286:	6e 3a       	ld.w	r10,r7[0xc]
80002288:	20 25       	sub	r5,2
8000228a:	78 20       	ld.w	r0,r12[0x8]
8000228c:	0a 0d       	add	sp,r5
8000228e:	00 00       	add	r0,r0
80002290:	0a 0d       	add	sp,r5
80002292:	20 4d       	sub	sp,16
80002294:	6f 64       	ld.w	r4,r7[0x58]
80002296:	65 20       	ld.w	r0,r2[0x48]
80002298:	6f 66       	ld.w	r6,r7[0x58]
8000229a:	20 4f       	sub	pc,4
8000229c:	70 65       	ld.w	r5,r8[0x18]
8000229e:	72 61       	ld.w	r1,r9[0x18]
800022a0:	74 69       	ld.w	r9,r10[0x18]
800022a2:	6f 6e       	ld.w	lr,r7[0x58]
800022a4:	3a 20       	mov	r0,-94
800022a6:	25 78       	sub	r8,87
800022a8:	20 0a       	sub	r10,0
800022aa:	0d 00       	ld.w	r0,r6++
800022ac:	0a 0d       	add	sp,r5
800022ae:	20 53       	sub	r3,5
800022b0:	74 61       	ld.w	r1,r10[0x18]
800022b2:	74 65       	ld.w	r5,r10[0x18]
800022b4:	3a 20       	mov	r0,-94
800022b6:	25 78       	sub	r8,87
800022b8:	20 0a       	sub	r10,0
800022ba:	0d 00       	ld.w	r0,r6++
800022bc:	54 72       	stdsp	sp[0x11c],r2
800022be:	61 6e       	ld.w	lr,r0[0x58]
800022c0:	73 6d       	ld.w	sp,r9[0x58]
800022c2:	69 74       	ld.w	r4,r4[0x5c]
800022c4:	43 6f       	lddsp	pc,sp[0xd8]
800022c6:	6e 74       	ld.w	r4,r7[0x1c]
800022c8:	72 6f       	ld.w	pc,r9[0x18]
800022ca:	6c 20       	ld.w	r0,r6[0x8]
800022cc:	65 72       	ld.w	r2,r2[0x5c]
800022ce:	72 6f       	ld.w	pc,r9[0x18]
800022d0:	72 00       	ld.w	r0,r9[0x0]
800022d2:	00 00       	add	r0,r0
800022d4:	0a 0d       	add	sp,r5
800022d6:	20 20       	sub	r0,2
800022d8:	53 74       	stdsp	sp[0xdc],r4
800022da:	61 6e       	ld.w	lr,r0[0x58]
800022dc:	64 62       	ld.w	r2,r2[0x18]
800022de:	79 2d       	ld.w	sp,r12[0x48]
800022e0:	52 65       	stdsp	sp[0x98],r5
800022e2:	63 65       	ld.w	r5,r1[0x58]
800022e4:	69 76       	ld.w	r6,r4[0x5c]
800022e6:	65 20       	ld.w	r0,r2[0x48]
800022e8:	0a 0d       	add	sp,r5
800022ea:	20 00       	sub	r0,0
800022ec:	0a 0d       	add	sp,r5
800022ee:	20 20       	sub	r0,2
800022f0:	54 72       	stdsp	sp[0x11c],r2
800022f2:	61 6e       	ld.w	lr,r0[0x58]
800022f4:	73 6d       	ld.w	sp,r9[0x58]
800022f6:	69 74       	ld.w	r4,r4[0x5c]
800022f8:	20 0a       	sub	r10,0
800022fa:	0d 20       	ld.uh	r0,r6++
800022fc:	00 00       	add	r0,r0
800022fe:	00 00       	add	r0,r0
80002300:	0a 0d       	add	sp,r5
80002302:	20 20       	sub	r0,2
80002304:	43 61       	lddsp	r1,sp[0xd8]
80002306:	6c 6c       	ld.w	r12,r6[0x18]
80002308:	5f 73       	srpl	r3
8000230a:	74 61       	ld.w	r1,r10[0x18]
8000230c:	74 65       	ld.w	r5,r10[0x18]
8000230e:	3a 20       	mov	r0,-94
80002310:	25 78       	sub	r8,87
80002312:	20 0a       	sub	r10,0
80002314:	0d 20       	ld.uh	r0,r6++
80002316:	00 00       	add	r0,r0
80002318:	0a 0d       	add	sp,r5
8000231a:	20 44       	sub	r4,4
8000231c:	41 54       	lddsp	r4,sp[0x54]
8000231e:	41 72       	lddsp	r2,sp[0x5c]
80002320:	65 70       	ld.w	r0,r2[0x5c]
80002322:	20 4f       	sub	pc,4
80002324:	4b 20       	lddpc	r0,800023ec <program_start+0x3e4>
80002326:	0a 0d       	add	sp,r5
80002328:	00 00       	add	r0,r0
8000232a:	00 00       	add	r0,r0
8000232c:	0a 0d       	add	sp,r5
8000232e:	20 52       	sub	r2,5
80002330:	65 73       	ld.w	r3,r2[0x5c]
80002332:	75 6c       	ld.w	r12,r10[0x58]
80002334:	74 3a       	ld.w	r10,r10[0xc]
80002336:	20 20       	sub	r0,2
80002338:	25 58       	sub	r8,85
8000233a:	20 0a       	sub	r10,0
8000233c:	0d 00       	ld.w	r0,r6++
8000233e:	00 00       	add	r0,r0
80002340:	0a 0d       	add	sp,r5
80002342:	20 44       	sub	r4,4
80002344:	41 54       	lddsp	r4,sp[0x54]
80002346:	41 72       	lddsp	r2,sp[0x5c]
80002348:	65 70       	ld.w	r0,r2[0x5c]
8000234a:	20 65       	sub	r5,6
8000234c:	72 72       	ld.w	r2,r9[0x1c]
8000234e:	6f 72       	ld.w	r2,r7[0x5c]
80002350:	20 0a       	sub	r10,0
80002352:	0d 00       	ld.w	r0,r6++
80002354:	0a 0d       	add	sp,r5
80002356:	20 46       	sub	r6,4
80002358:	75 6e       	ld.w	lr,r10[0x58]
8000235a:	63 3a       	ld.w	r10,r1[0x4c]
8000235c:	20 20       	sub	r0,2
8000235e:	25 58       	sub	r8,85
80002360:	20 0a       	sub	r10,0
80002362:	0d 00       	ld.w	r0,r6++
80002364:	0a 0d       	add	sp,r5
80002366:	20 49       	sub	r9,4
80002368:	44 3a       	lddsp	r10,sp[0x10c]
8000236a:	20 20       	sub	r0,2
8000236c:	25 58       	sub	r8,85
8000236e:	20 0a       	sub	r10,0
80002370:	0d 00       	ld.w	r0,r6++
80002372:	00 00       	add	r0,r0
80002374:	0a 0d       	add	sp,r5
80002376:	20 43       	sub	r3,4
80002378:	53 42       	stdsp	sp[0xd0],r2
8000237a:	4b 5f       	lddpc	pc,8000244c <program_start+0x444>
8000237c:	52 58       	stdsp	sp[0x94],r8
8000237e:	20 4f       	sub	pc,4
80002380:	4b 20       	lddpc	r0,80002448 <program_start+0x440>
80002382:	0a 0d       	add	sp,r5
80002384:	00 00       	add	r0,r0
80002386:	00 00       	add	r0,r0
80002388:	0a 0d       	add	sp,r5
8000238a:	20 53       	sub	r3,5
8000238c:	65 73       	ld.w	r3,r2[0x5c]
8000238e:	73 69       	ld.w	r9,r9[0x58]
80002390:	6f 6e       	ld.w	lr,r7[0x58]
80002392:	5f 49       	srge	r9
80002394:	44 3a       	lddsp	r10,sp[0x10c]
80002396:	20 25       	sub	r5,2
80002398:	78 20       	ld.w	r0,r12[0x8]
8000239a:	0a 0d       	add	sp,r5
8000239c:	00 00       	add	r0,r0
8000239e:	00 00       	add	r0,r0
800023a0:	0a 0d       	add	sp,r5
800023a2:	20 70       	sub	r0,7
800023a4:	61 79       	ld.w	r9,r0[0x5c]
800023a6:	6c 61       	ld.w	r1,r6[0x18]
800023a8:	6f 64       	ld.w	r4,r7[0x58]
800023aa:	5f 6c       	srmi	r12
800023ac:	65 6e       	ld.w	lr,r2[0x58]
800023ae:	67 74       	ld.w	r4,r3[0x5c]
800023b0:	68 3a       	ld.w	r10,r4[0xc]
800023b2:	20 25       	sub	r5,2
800023b4:	64 20       	ld.w	r0,r2[0x8]
800023b6:	0a 0d       	add	sp,r5
800023b8:	00 00       	add	r0,r0
800023ba:	00 00       	add	r0,r0
800023bc:	0a 0d       	add	sp,r5
800023be:	20 70       	sub	r0,7
800023c0:	61 79       	ld.w	r9,r0[0x5c]
800023c2:	6c 6f       	ld.w	pc,r6[0x18]
800023c4:	61 64       	ld.w	r4,r0[0x58]
800023c6:	5b 25       	cp.w	r5,-14
800023c8:	64 5d       	ld.w	sp,r2[0x14]
800023ca:	3a 20       	mov	r0,-94
800023cc:	25 58       	sub	r8,85
800023ce:	20 0a       	sub	r10,0
800023d0:	0d 00       	ld.w	r0,r6++
800023d2:	00 00       	add	r0,r0
800023d4:	0a 0d       	add	sp,r5
800023d6:	20 53       	sub	r3,5
800023d8:	74 61       	ld.w	r1,r10[0x18]
800023da:	74 65       	ld.w	r5,r10[0x18]
800023dc:	3a 20       	mov	r0,-94
800023de:	30 78       	mov	r8,7
800023e0:	20 25       	sub	r5,2
800023e2:	58 20       	cp.w	r0,2
800023e4:	0a 0d       	add	sp,r5
800023e6:	00 00       	add	r0,r0
800023e8:	0a 0d       	add	sp,r5
800023ea:	20 42       	sub	r2,4
800023ec:	75 74       	ld.w	r4,r10[0x5c]
800023ee:	74 6f       	ld.w	pc,r10[0x18]
800023f0:	6e 5f       	ld.w	pc,r7[0x14]
800023f2:	43 6f       	lddsp	pc,sp[0xd8]
800023f4:	6e 66       	ld.w	r6,r7[0x18]
800023f6:	69 67       	ld.w	r7,r4[0x58]
800023f8:	20 4f       	sub	pc,4
800023fa:	4b 20       	lddpc	r0,800024c0 <program_start+0x4b8>
800023fc:	0a 0d       	add	sp,r5
800023fe:	00 00       	add	r0,r0
80002400:	0a 0d       	add	sp,r5
80002402:	20 46       	sub	r6,4
80002404:	75 6e       	ld.w	lr,r10[0x58]
80002406:	63 74       	ld.w	r4,r1[0x5c]
80002408:	69 6f       	ld.w	pc,r4[0x58]
8000240a:	6e 3a       	ld.w	r10,r7[0xc]
8000240c:	20 25       	sub	r5,2
8000240e:	58 20       	cp.w	r0,2
80002410:	0a 0d       	add	sp,r5
80002412:	00 00       	add	r0,r0
80002414:	0a 0d       	add	sp,r5
80002416:	20 42       	sub	r2,4
80002418:	75 74       	ld.w	r4,r10[0x5c]
8000241a:	74 6f       	ld.w	pc,r10[0x18]
8000241c:	6e 5f       	ld.w	pc,r7[0x14]
8000241e:	52 65       	stdsp	sp[0x98],r5
80002420:	71 75       	ld.w	r5,r8[0x5c]
80002422:	65 73       	ld.w	r3,r2[0x5c]
80002424:	74 20       	ld.w	r0,r10[0x8]
80002426:	65 72       	ld.w	r2,r2[0x5c]
80002428:	72 6f       	ld.w	pc,r9[0x18]
8000242a:	72 20       	ld.w	r0,r9[0x8]
8000242c:	0a 0d       	add	sp,r5
8000242e:	00 00       	add	r0,r0
80002430:	0a 0d       	add	sp,r5
80002432:	20 50       	sub	r0,5
80002434:	68 79       	ld.w	r9,r4[0x1c]
80002436:	73 69       	ld.w	r9,r9[0x58]
80002438:	63 61       	ld.w	r1,r1[0x58]
8000243a:	6c 55       	ld.w	r5,r6[0x14]
8000243c:	73 65       	ld.w	r5,r9[0x58]
8000243e:	72 49       	ld.w	r9,r9[0x10]
80002440:	6e 70       	ld.w	r0,r7[0x1c]
80002442:	75 74       	ld.w	r4,r10[0x5c]
80002444:	5f 62       	srmi	r2
80002446:	72 6f       	ld.w	pc,r9[0x18]
80002448:	61 64       	ld.w	r4,r0[0x58]
8000244a:	63 61       	ld.w	r1,r1[0x58]
8000244c:	73 74       	ld.w	r4,r9[0x5c]
8000244e:	20 20       	sub	r0,2
80002450:	0a 0d       	add	sp,r5
80002452:	00 00       	add	r0,r0
80002454:	0a 0d       	add	sp,r5
80002456:	20 50       	sub	r0,5
80002458:	55 49       	stdsp	sp[0x150],r9
8000245a:	5f 53       	srlt	r3
8000245c:	6f 75       	ld.w	r5,r7[0x5c]
8000245e:	72 63       	ld.w	r3,r9[0x18]
80002460:	65 3a       	ld.w	r10,r2[0x4c]
80002462:	20 25       	sub	r5,2
80002464:	58 20       	cp.w	r0,2
80002466:	0a 0d       	add	sp,r5
80002468:	00 00       	add	r0,r0
8000246a:	00 00       	add	r0,r0
8000246c:	0a 0d       	add	sp,r5
8000246e:	20 50       	sub	r0,5
80002470:	55 49       	stdsp	sp[0x150],r9
80002472:	5f 54       	srlt	r4
80002474:	79 70       	ld.w	r0,r12[0x5c]
80002476:	65 3a       	ld.w	r10,r2[0x4c]
80002478:	20 25       	sub	r5,2
8000247a:	58 20       	cp.w	r0,2
8000247c:	0a 0d       	add	sp,r5
8000247e:	00 00       	add	r0,r0
80002480:	0a 0d       	add	sp,r5
80002482:	20 50       	sub	r0,5
80002484:	55 49       	stdsp	sp[0x150],r9
80002486:	5f 49       	srge	r9
80002488:	44 3a       	lddsp	r10,sp[0x10c]
8000248a:	20 25       	sub	r5,2
8000248c:	58 20       	cp.w	r0,2
8000248e:	0a 0d       	add	sp,r5
80002490:	00 00       	add	r0,r0
80002492:	00 00       	add	r0,r0
80002494:	0a 0d       	add	sp,r5
80002496:	20 50       	sub	r0,5
80002498:	55 49       	stdsp	sp[0x150],r9
8000249a:	5f 53       	srlt	r3
8000249c:	74 61       	ld.w	r1,r10[0x18]
8000249e:	74 65       	ld.w	r5,r10[0x18]
800024a0:	3a 20       	mov	r0,-94
800024a2:	25 58       	sub	r8,85
800024a4:	20 0a       	sub	r10,0
800024a6:	0d 00       	ld.w	r0,r6++
800024a8:	0a 0d       	add	sp,r5
800024aa:	20 50       	sub	r0,5
800024ac:	55 49       	stdsp	sp[0x150],r9
800024ae:	5f 53       	srlt	r3
800024b0:	74 61       	ld.w	r1,r10[0x18]
800024b2:	74 65       	ld.w	r5,r10[0x18]
800024b4:	5f 4d       	srge	sp
800024b6:	69 6e       	ld.w	lr,r4[0x58]
800024b8:	5f 56       	srlt	r6
800024ba:	61 6c       	ld.w	r12,r0[0x58]
800024bc:	75 65       	ld.w	r5,r10[0x58]
800024be:	3a 20       	mov	r0,-94
800024c0:	25 58       	sub	r8,85
800024c2:	20 0a       	sub	r10,0
800024c4:	0d 00       	ld.w	r0,r6++
800024c6:	00 00       	add	r0,r0
800024c8:	0a 0d       	add	sp,r5
800024ca:	20 50       	sub	r0,5
800024cc:	55 49       	stdsp	sp[0x150],r9
800024ce:	5f 53       	srlt	r3
800024d0:	74 61       	ld.w	r1,r10[0x18]
800024d2:	74 65       	ld.w	r5,r10[0x18]
800024d4:	5f 4d       	srge	sp
800024d6:	61 78       	ld.w	r8,r0[0x5c]
800024d8:	5f 56       	srlt	r6
800024da:	61 6c       	ld.w	r12,r0[0x58]
800024dc:	75 65       	ld.w	r5,r10[0x58]
800024de:	3a 20       	mov	r0,-94
800024e0:	25 58       	sub	r8,85
800024e2:	20 0a       	sub	r10,0
800024e4:	0d 00       	ld.w	r0,r6++
800024e6:	00 00       	add	r0,r0
800024e8:	0a 0d       	add	sp,r5
800024ea:	20 42       	sub	r2,4
800024ec:	75 74       	ld.w	r4,r10[0x5c]
800024ee:	74 6f       	ld.w	pc,r10[0x18]
800024f0:	6e 43       	ld.w	r3,r7[0x10]
800024f2:	6f 6e       	ld.w	lr,r7[0x58]
800024f4:	66 69       	ld.w	r9,r3[0x18]
800024f6:	67 5f       	ld.w	pc,r3[0x54]
800024f8:	62 72       	ld.w	r2,r1[0x1c]
800024fa:	6f 61       	ld.w	r1,r7[0x58]
800024fc:	64 63       	ld.w	r3,r2[0x18]
800024fe:	61 73       	ld.w	r3,r0[0x5c]
80002500:	74 20       	ld.w	r0,r10[0x8]
80002502:	20 0a       	sub	r10,0
80002504:	0d 00       	ld.w	r0,r6++
80002506:	00 00       	add	r0,r0
80002508:	0a 0d       	add	sp,r5
8000250a:	20 4e       	sub	lr,4
8000250c:	75 6d       	ld.w	sp,r10[0x58]
8000250e:	4f 66       	lddpc	r6,800026e4 <program_start+0x6dc>
80002510:	42 75       	lddsp	r5,sp[0x9c]
80002512:	74 74       	ld.w	r4,r10[0x1c]
80002514:	6f 6e       	ld.w	lr,r7[0x58]
80002516:	73 3a       	ld.w	r10,r9[0x4c]
80002518:	20 25       	sub	r5,2
8000251a:	64 20       	ld.w	r0,r2[0x8]
8000251c:	0a 0d       	add	sp,r5
8000251e:	00 00       	add	r0,r0
80002520:	0a 0d       	add	sp,r5
80002522:	20 42       	sub	r2,4
80002524:	75 74       	ld.w	r4,r10[0x5c]
80002526:	74 6f       	ld.w	pc,r10[0x18]
80002528:	6e 49       	ld.w	r9,r7[0x10]
8000252a:	6e 66       	ld.w	r6,r7[0x18]
8000252c:	6f 53       	ld.w	r3,r7[0x54]
8000252e:	74 72       	ld.w	r2,r10[0x1c]
80002530:	75 63       	ld.w	r3,r10[0x58]
80002532:	74 53       	ld.w	r3,r10[0x14]
80002534:	69 7a       	ld.w	r10,r4[0x5c]
80002536:	65 3a       	ld.w	r10,r2[0x4c]
80002538:	20 25       	sub	r5,2
8000253a:	78 20       	ld.w	r0,r12[0x8]
8000253c:	0a 0d       	add	sp,r5
8000253e:	00 00       	add	r0,r0
80002540:	0a 0d       	add	sp,r5
80002542:	20 42       	sub	r2,4
80002544:	75 74       	ld.w	r4,r10[0x5c]
80002546:	74 6f       	ld.w	pc,r10[0x18]
80002548:	6e 49       	ld.w	r9,r7[0x10]
8000254a:	6e 66       	ld.w	r6,r7[0x18]
8000254c:	6f 5b       	ld.w	r11,r7[0x54]
8000254e:	25 64       	sub	r4,86
80002550:	5d 2e       	mustr	lr
80002552:	42 74       	lddsp	r4,sp[0x9c]
80002554:	5f 49       	srge	r9
80002556:	64 65       	ld.w	r5,r2[0x18]
80002558:	6e 74       	ld.w	r4,r7[0x1c]
8000255a:	69 66       	ld.w	r6,r4[0x58]
8000255c:	69 65       	ld.w	r5,r4[0x58]
8000255e:	72 3a       	ld.w	r10,r9[0xc]
80002560:	20 25       	sub	r5,2
80002562:	78 20       	ld.w	r0,r12[0x8]
80002564:	0a 0d       	add	sp,r5
80002566:	00 00       	add	r0,r0
80002568:	0a 0d       	add	sp,r5
8000256a:	20 42       	sub	r2,4
8000256c:	75 74       	ld.w	r4,r10[0x5c]
8000256e:	74 6f       	ld.w	pc,r10[0x18]
80002570:	6e 49       	ld.w	r9,r7[0x10]
80002572:	6e 66       	ld.w	r6,r7[0x18]
80002574:	6f 5b       	ld.w	r11,r7[0x54]
80002576:	25 64       	sub	r4,86
80002578:	5d 2e       	mustr	lr
8000257a:	53 5f       	stdsp	sp[0xd4],pc
8000257c:	50 72       	stdsp	sp[0x1c],r2
8000257e:	65 73       	ld.w	r3,r2[0x5c]
80002580:	73 46       	ld.w	r6,r9[0x50]
80002582:	65 61       	ld.w	r1,r2[0x58]
80002584:	74 75       	ld.w	r5,r10[0x1c]
80002586:	72 65       	ld.w	r5,r9[0x18]
80002588:	3a 20       	mov	r0,-94
8000258a:	25 78       	sub	r8,87
8000258c:	20 0a       	sub	r10,0
8000258e:	0d 00       	ld.w	r0,r6++
80002590:	0a 0d       	add	sp,r5
80002592:	20 42       	sub	r2,4
80002594:	75 74       	ld.w	r4,r10[0x5c]
80002596:	74 6f       	ld.w	pc,r10[0x18]
80002598:	6e 49       	ld.w	r9,r7[0x10]
8000259a:	6e 66       	ld.w	r6,r7[0x18]
8000259c:	6f 5b       	ld.w	r11,r7[0x54]
8000259e:	25 64       	sub	r4,86
800025a0:	5d 2e       	mustr	lr
800025a2:	52 65       	stdsp	sp[0x98],r5
800025a4:	73 65       	ld.w	r5,r9[0x58]
800025a6:	72 76       	ld.w	r6,r9[0x1c]
800025a8:	65 64       	ld.w	r4,r2[0x58]
800025aa:	31 3a       	mov	r10,19
800025ac:	20 25       	sub	r5,2
800025ae:	78 20       	ld.w	r0,r12[0x8]
800025b0:	0a 0d       	add	sp,r5
800025b2:	00 00       	add	r0,r0
800025b4:	0a 0d       	add	sp,r5
800025b6:	20 42       	sub	r2,4
800025b8:	75 74       	ld.w	r4,r10[0x5c]
800025ba:	74 6f       	ld.w	pc,r10[0x18]
800025bc:	6e 49       	ld.w	r9,r7[0x10]
800025be:	6e 66       	ld.w	r6,r7[0x18]
800025c0:	6f 5b       	ld.w	r11,r7[0x54]
800025c2:	25 64       	sub	r4,86
800025c4:	5d 2e       	mustr	lr
800025c6:	4c 5f       	lddpc	pc,800026d8 <program_start+0x6d0>
800025c8:	50 72       	stdsp	sp[0x1c],r2
800025ca:	65 73       	ld.w	r3,r2[0x5c]
800025cc:	73 46       	ld.w	r6,r9[0x50]
800025ce:	65 61       	ld.w	r1,r2[0x58]
800025d0:	74 75       	ld.w	r5,r10[0x1c]
800025d2:	72 65       	ld.w	r5,r9[0x18]
800025d4:	3a 20       	mov	r0,-94
800025d6:	25 78       	sub	r8,87
800025d8:	20 0a       	sub	r10,0
800025da:	0d 00       	ld.w	r0,r6++
800025dc:	0a 0d       	add	sp,r5
800025de:	20 42       	sub	r2,4
800025e0:	75 74       	ld.w	r4,r10[0x5c]
800025e2:	74 6f       	ld.w	pc,r10[0x18]
800025e4:	6e 49       	ld.w	r9,r7[0x10]
800025e6:	6e 66       	ld.w	r6,r7[0x18]
800025e8:	6f 5b       	ld.w	r11,r7[0x54]
800025ea:	25 64       	sub	r4,86
800025ec:	5d 2e       	mustr	lr
800025ee:	52 65       	stdsp	sp[0x98],r5
800025f0:	73 65       	ld.w	r5,r9[0x58]
800025f2:	72 76       	ld.w	r6,r9[0x1c]
800025f4:	65 64       	ld.w	r4,r2[0x58]
800025f6:	32 3a       	mov	r10,35
800025f8:	20 25       	sub	r5,2
800025fa:	78 20       	ld.w	r0,r12[0x8]
800025fc:	0a 0d       	add	sp,r5
800025fe:	00 00       	add	r0,r0
80002600:	0a 0d       	add	sp,r5
80002602:	20 44       	sub	r4,4
80002604:	4d 52       	lddpc	r2,80002758 <DeviceInitializationStatus_brdcst_func+0x44>
80002606:	5f 43       	srge	r3
80002608:	53 42       	stdsp	sp[0xd0],r2
8000260a:	4b 20       	lddpc	r0,800026d0 <program_start+0x6c8>
8000260c:	4f 4b       	lddpc	r11,800027dc <ToneControl_reply_func+0x14>
8000260e:	20 0a       	sub	r10,0
80002610:	0d 00       	ld.w	r0,r6++
80002612:	00 00       	add	r0,r0
80002614:	0a 0d       	add	sp,r5
80002616:	20 45       	sub	r5,4
80002618:	6e 5f       	ld.w	pc,r7[0x14]
8000261a:	4f 42       	lddpc	r2,800027e8 <ToneControl_reply_func+0x20>
8000261c:	5f 45       	srge	r5
8000261e:	6e 74       	ld.w	r4,r7[0x1c]
80002620:	65 72       	ld.w	r2,r2[0x5c]
80002622:	20 4f       	sub	pc,4
80002624:	4b 20       	lddpc	r0,800026ec <program_start+0x6e4>
80002626:	0a 0d       	add	sp,r5
80002628:	00 00       	add	r0,r0
8000262a:	00 00       	add	r0,r0
8000262c:	0a 0d       	add	sp,r5
8000262e:	20 45       	sub	r5,4
80002630:	6e 5f       	ld.w	pc,r7[0x14]
80002632:	4f 42       	lddpc	r2,80002800 <dcm_reply_func>
80002634:	5f 45       	srge	r5
80002636:	78 69       	ld.w	r9,r12[0x18]
80002638:	74 20       	ld.w	r0,r10[0x8]
8000263a:	4f 4b       	lddpc	r11,80002808 <dcm_reply_func+0x8>
8000263c:	20 0a       	sub	r10,0
8000263e:	0d 00       	ld.w	r0,r6++
80002640:	0a 0d       	add	sp,r5
80002642:	20 45       	sub	r5,4
80002644:	6e 5f       	ld.w	pc,r7[0x14]
80002646:	4f 42       	lddpc	r2,80002814 <dcm_reply_func+0x14>
80002648:	5f 43       	srge	r3
8000264a:	6f 6e       	ld.w	lr,r7[0x58]
8000264c:	74 72       	ld.w	r2,r10[0x1c]
8000264e:	6f 6c       	ld.w	r12,r7[0x58]
80002650:	3a 20       	mov	r0,-94
80002652:	25 78       	sub	r8,87
80002654:	20 0a       	sub	r10,0
80002656:	0d 00       	ld.w	r0,r6++
80002658:	0a 0d       	add	sp,r5
8000265a:	20 45       	sub	r5,4
8000265c:	6e 5f       	ld.w	pc,r7[0x14]
8000265e:	4f 42       	lddpc	r2,8000282c <dcm_reply_func+0x2c>
80002660:	5f 43       	srge	r3
80002662:	6f 6e       	ld.w	lr,r7[0x58]
80002664:	74 72       	ld.w	r2,r10[0x1c]
80002666:	6f 6c       	ld.w	r12,r7[0x58]
80002668:	20 65       	sub	r5,6
8000266a:	72 72       	ld.w	r2,r9[0x1c]
8000266c:	6f 72       	ld.w	r2,r7[0x5c]
8000266e:	20 0a       	sub	r10,0
80002670:	0d 00       	ld.w	r0,r6++
80002672:	00 00       	add	r0,r0
80002674:	0a 0d       	add	sp,r5
80002676:	20 45       	sub	r5,4
80002678:	6e 5f       	ld.w	pc,r7[0x14]
8000267a:	4f 42       	lddpc	r2,80002848 <dcm_reply_func+0x48>
8000267c:	5f 72       	srpl	r2
8000267e:	65 73       	ld.w	r3,r2[0x5c]
80002680:	75 6c       	ld.w	r12,r10[0x58]
80002682:	74 3a       	ld.w	r10,r10[0xc]
80002684:	20 25       	sub	r5,2
80002686:	78 20       	ld.w	r0,r12[0x8]
80002688:	0a 0d       	add	sp,r5
8000268a:	00 00       	add	r0,r0
8000268c:	0a 0d       	add	sp,r5
8000268e:	20 45       	sub	r5,4
80002690:	6e 5f       	ld.w	pc,r7[0x14]
80002692:	4f 42       	lddpc	r2,80002860 <dcm_reply_func+0x60>
80002694:	20 42       	sub	r2,4
80002696:	72 6f       	ld.w	pc,r9[0x18]
80002698:	61 64       	ld.w	r4,r0[0x58]
8000269a:	63 61       	ld.w	r1,r1[0x58]
8000269c:	73 74       	ld.w	r4,r9[0x5c]
8000269e:	20 0a       	sub	r10,0
800026a0:	0d 00       	ld.w	r0,r6++
800026a2:	00 00       	add	r0,r0
800026a4:	0a 0d       	add	sp,r5
800026a6:	20 46       	sub	r6,4
800026a8:	6f 72       	ld.w	r2,r7[0x5c]
800026aa:	77 61       	ld.w	r1,r11[0x58]
800026ac:	72 64       	ld.w	r4,r9[0x18]
800026ae:	20 44       	sub	r4,4
800026b0:	61 74       	ld.w	r4,r0[0x5c]
800026b2:	61 20       	ld.w	r0,r0[0x48]
800026b4:	52 65       	stdsp	sp[0x98],r5
800026b6:	71 75       	ld.w	r5,r8[0x5c]
800026b8:	65 73       	ld.w	r3,r2[0x5c]
800026ba:	74 20       	ld.w	r0,r10[0x8]
800026bc:	0a 0d       	add	sp,r5
800026be:	00 00       	add	r0,r0
800026c0:	0a 0d       	add	sp,r5
800026c2:	20 46       	sub	r6,4
800026c4:	6f 72       	ld.w	r2,r7[0x5c]
800026c6:	77 61       	ld.w	r1,r11[0x58]
800026c8:	72 64       	ld.w	r4,r9[0x18]
800026ca:	20 44       	sub	r4,4
800026cc:	61 74       	ld.w	r4,r0[0x5c]
800026ce:	61 20       	ld.w	r0,r0[0x48]
800026d0:	52 65       	stdsp	sp[0x98],r5
800026d2:	70 6c       	ld.w	r12,r8[0x18]
800026d4:	79 20       	ld.w	r0,r12[0x48]
800026d6:	0a 0d       	add	sp,r5
800026d8:	00 00       	add	r0,r0
800026da:	00 00       	add	r0,r0
800026dc:	0a 0d       	add	sp,r5
800026de:	20 46       	sub	r6,4
800026e0:	6f 72       	ld.w	r2,r7[0x5c]
800026e2:	77 61       	ld.w	r1,r11[0x58]
800026e4:	72 64       	ld.w	r4,r9[0x18]
800026e6:	20 44       	sub	r4,4
800026e8:	61 74       	ld.w	r4,r0[0x5c]
800026ea:	61 20       	ld.w	r0,r0[0x48]
800026ec:	42 72       	lddsp	r2,sp[0x9c]
800026ee:	6f 61       	ld.w	r1,r7[0x58]
800026f0:	64 63       	ld.w	r3,r2[0x18]
800026f2:	61 73       	ld.w	r3,r0[0x5c]
800026f4:	74 20       	ld.w	r0,r10[0x8]
800026f6:	0a 0d       	add	sp,r5
800026f8:	00 00       	add	r0,r0
800026fa:	00 00       	add	r0,r0
800026fc:	58 4e       	cp.w	lr,4
800026fe:	4c 5f       	lddpc	pc,80002810 <dcm_reply_func+0x10>
80002700:	54 58       	stdsp	sp[0x114],r8
80002702:	00 00       	add	r0,r0
80002704:	0a 0d       	add	sp,r5
80002706:	20 77       	sub	r7,7
80002708:	3a 20       	mov	r0,-94
8000270a:	0a 0d       	add	sp,r5
8000270c:	00 00       	add	r0,r0
8000270e:	00 00       	add	r0,r0
80002710:	52 00       	stdsp	sp[0x80],r0
	...

80002714 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002714:	eb cd 40 80 	pushm	r7,lr
80002718:	1a 97       	mov	r7,sp
8000271a:	20 1d       	sub	sp,4
8000271c:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[4] == 0x01)
80002720:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002724:	11 e9       	ld.ub	r9,r8[0x6]
80002726:	30 18       	mov	r8,1
80002728:	f0 09 18 00 	cp.b	r9,r8
8000272c:	c0 81       	brne	8000273c <DeviceInitializationStatus_brdcst_func+0x28>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
8000272e:	48 e8       	lddpc	r8,80002764 <DeviceInitializationStatus_brdcst_func+0x50>
80002730:	70 08       	ld.w	r8,r8[0x0]
80002732:	10 99       	mov	r9,r8
80002734:	a1 a9       	sbr	r9,0x0
80002736:	48 c8       	lddpc	r8,80002764 <DeviceInitializationStatus_brdcst_func+0x50>
80002738:	91 09       	st.w	r8[0x0],r9
8000273a:	c1 18       	rjmp	8000275c <DeviceInitializationStatus_brdcst_func+0x48>
	}
	else if(xcmp->u8[4] != 0x02)
8000273c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002740:	11 e9       	ld.ub	r9,r8[0x6]
80002742:	30 28       	mov	r8,2
80002744:	f0 09 18 00 	cp.b	r9,r8
80002748:	c0 a0       	breq	8000275c <DeviceInitializationStatus_brdcst_func+0x48>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
8000274a:	48 78       	lddpc	r8,80002764 <DeviceInitializationStatus_brdcst_func+0x50>
8000274c:	70 08       	ld.w	r8,r8[0x0]
8000274e:	10 99       	mov	r9,r8
80002750:	e0 19 ff fc 	andl	r9,0xfffc
80002754:	48 48       	lddpc	r8,80002764 <DeviceInitializationStatus_brdcst_func+0x50>
80002756:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002758:	f0 1f 00 04 	mcall	80002768 <DeviceInitializationStatus_brdcst_func+0x54>
	}
}
8000275c:	2f fd       	sub	sp,-4
8000275e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002762:	00 00       	add	r0,r0
80002764:	00 00       	add	r0,r0
80002766:	0d 74       	ld.ub	r4,--r6
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	59 d0       	cp.w	r0,29

8000276c <DeviceManagement_brdcst_func>:

void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
8000276c:	eb cd 40 80 	pushm	r7,lr
80002770:	1a 97       	mov	r7,sp
80002772:	20 2d       	sub	sp,8
80002774:	ef 4c ff f8 	st.w	r7[-8],r12
		U8 temp = 0;
80002778:	30 08       	mov	r8,0
8000277a:	ef 68 ff ff 	st.b	r7[-1],r8
		temp  = xcmp->u8[1] << 8;
8000277e:	30 08       	mov	r8,0
80002780:	ef 68 ff ff 	st.b	r7[-1],r8
		temp |= xcmp->u8[2];
80002784:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002788:	11 c9       	ld.ub	r9,r8[0x4]
8000278a:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000278e:	f3 e8 10 08 	or	r8,r9,r8
80002792:	ef 68 ff ff 	st.b	r7[-1],r8
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002796:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000279a:	11 a9       	ld.ub	r9,r8[0x2]
8000279c:	30 18       	mov	r8,1
8000279e:	f0 09 18 00 	cp.b	r9,r8
800027a2:	c0 81       	brne	800027b2 <DeviceManagement_brdcst_func+0x46>
			{
				bunchofrandomstatusflags |= 0x00000002;
800027a4:	48 88       	lddpc	r8,800027c4 <DeviceManagement_brdcst_func+0x58>
800027a6:	70 08       	ld.w	r8,r8[0x0]
800027a8:	10 99       	mov	r9,r8
800027aa:	a1 b9       	sbr	r9,0x1
800027ac:	48 68       	lddpc	r8,800027c4 <DeviceManagement_brdcst_func+0x58>
800027ae:	91 09       	st.w	r8[0x0],r9
800027b0:	c0 78       	rjmp	800027be <DeviceManagement_brdcst_func+0x52>
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
800027b2:	48 58       	lddpc	r8,800027c4 <DeviceManagement_brdcst_func+0x58>
800027b4:	70 08       	ld.w	r8,r8[0x0]
800027b6:	10 99       	mov	r9,r8
800027b8:	a1 d9       	cbr	r9,0x1
800027ba:	48 38       	lddpc	r8,800027c4 <DeviceManagement_brdcst_func+0x58>
800027bc:	91 09       	st.w	r8[0x0],r9
			}
		}
}
800027be:	2f ed       	sub	sp,-8
800027c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800027c4:	00 00       	add	r0,r0
800027c6:	0d 74       	ld.ub	r4,--r6

800027c8 <ToneControl_reply_func>:

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027c8:	eb cd 40 80 	pushm	r7,lr
800027cc:	1a 97       	mov	r7,sp
800027ce:	20 1d       	sub	sp,4
800027d0:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800027d8:	11 a8       	ld.ub	r8,r8[0x2]
800027da:	58 08       	cp.w	r8,0
800027dc:	c0 51       	brne	800027e6 <ToneControl_reply_func+0x1e>
	{		
		log("Tone OK");
800027de:	48 6c       	lddpc	r12,800027f4 <ToneControl_reply_func+0x2c>
800027e0:	f0 1f 00 06 	mcall	800027f8 <ToneControl_reply_func+0x30>
800027e4:	c0 48       	rjmp	800027ec <ToneControl_reply_func+0x24>
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027e6:	48 6c       	lddpc	r12,800027fc <ToneControl_reply_func+0x34>
800027e8:	f0 1f 00 04 	mcall	800027f8 <ToneControl_reply_func+0x30>
	}
}
800027ec:	2f fd       	sub	sp,-4
800027ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800027f2:	00 00       	add	r0,r0
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	20 0c       	sub	r12,0
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	8d 90       	st.w	r6[0x24],r0
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	20 14       	sub	r4,1

80002800 <dcm_reply_func>:

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002800:	eb cd 40 80 	pushm	r7,lr
80002804:	1a 97       	mov	r7,sp
80002806:	20 1d       	sub	sp,4
80002808:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000280c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002810:	11 a8       	ld.ub	r8,r8[0x2]
80002812:	58 08       	cp.w	r8,0
80002814:	c2 11       	brne	80002856 <dcm_reply_func+0x56>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002816:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000281a:	11 b9       	ld.ub	r9,r8[0x3]
8000281c:	30 18       	mov	r8,1
8000281e:	f0 09 18 00 	cp.b	r9,r8
80002822:	c0 51       	brne	8000282c <dcm_reply_func+0x2c>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002824:	49 0c       	lddpc	r12,80002864 <dcm_reply_func+0x64>
80002826:	f0 1f 00 11 	mcall	80002868 <dcm_reply_func+0x68>
8000282a:	c0 d8       	rjmp	80002844 <dcm_reply_func+0x44>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000282c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002830:	11 b8       	ld.ub	r8,r8[0x3]
80002832:	58 08       	cp.w	r8,0
80002834:	c0 51       	brne	8000283e <dcm_reply_func+0x3e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002836:	48 ec       	lddpc	r12,8000286c <dcm_reply_func+0x6c>
80002838:	f0 1f 00 0c 	mcall	80002868 <dcm_reply_func+0x68>
8000283c:	c0 48       	rjmp	80002844 <dcm_reply_func+0x44>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000283e:	48 dc       	lddpc	r12,80002870 <dcm_reply_func+0x70>
80002840:	f0 1f 00 0a 	mcall	80002868 <dcm_reply_func+0x68>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002844:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002848:	11 d8       	ld.ub	r8,r8[0x5]
8000284a:	1a d8       	st.w	--sp,r8
8000284c:	48 ac       	lddpc	r12,80002874 <dcm_reply_func+0x74>
8000284e:	f0 1f 00 07 	mcall	80002868 <dcm_reply_func+0x68>
80002852:	2f fd       	sub	sp,-4
80002854:	c0 48       	rjmp	8000285c <dcm_reply_func+0x5c>
	}
	else
	{
		log("dcm error");
80002856:	48 9c       	lddpc	r12,80002878 <dcm_reply_func+0x78>
80002858:	f0 1f 00 04 	mcall	80002868 <dcm_reply_func+0x68>
	}
}
8000285c:	2f fd       	sub	sp,-4
8000285e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002862:	00 00       	add	r0,r0
80002864:	80 00       	ld.sh	r0,r0[0x0]
80002866:	20 20       	sub	r0,2
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	8d 90       	st.w	r6[0x24],r0
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	20 34       	sub	r4,3
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	20 48       	sub	r8,4
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	20 5c       	sub	r12,5
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	20 68       	sub	r8,6

8000287c <dcm_brdcst_func>:


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000287c:	eb cd 40 80 	pushm	r7,lr
80002880:	1a 97       	mov	r7,sp
80002882:	20 2d       	sub	sp,8
80002884:	ef 4c ff f8 	st.w	r7[-8],r12
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002888:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000288c:	2f e8       	sub	r8,-2
8000288e:	ef 48 ff fc 	st.w	r7[-4],r8
	
	log("\n\r Dcm_brdcst \n\r");		
80002892:	49 0c       	lddpc	r12,800028d0 <dcm_brdcst_func+0x54>
80002894:	f0 1f 00 10 	mcall	800028d4 <dcm_brdcst_func+0x58>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002898:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000289c:	11 88       	ld.ub	r8,r8[0x0]
8000289e:	1a d8       	st.w	--sp,r8
800028a0:	48 ec       	lddpc	r12,800028d8 <dcm_brdcst_func+0x5c>
800028a2:	f0 1f 00 0d 	mcall	800028d4 <dcm_brdcst_func+0x58>
800028a6:	2f fd       	sub	sp,-4
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800028a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028ac:	11 a8       	ld.ub	r8,r8[0x2]
800028ae:	1a d8       	st.w	--sp,r8
800028b0:	48 bc       	lddpc	r12,800028dc <dcm_brdcst_func+0x60>
800028b2:	f0 1f 00 09 	mcall	800028d4 <dcm_brdcst_func+0x58>
800028b6:	2f fd       	sub	sp,-4
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800028b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028bc:	11 98       	ld.ub	r8,r8[0x1]
800028be:	1a d8       	st.w	--sp,r8
800028c0:	48 8c       	lddpc	r12,800028e0 <dcm_brdcst_func+0x64>
800028c2:	f0 1f 00 05 	mcall	800028d4 <dcm_brdcst_func+0x58>
800028c6:	2f fd       	sub	sp,-4
	
	
}
800028c8:	2f ed       	sub	sp,-8
800028ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800028ce:	00 00       	add	r0,r0
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	20 74       	sub	r4,7
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	8d 90       	st.w	r6[0x24],r0
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	20 88       	sub	r8,8
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	20 9c       	sub	r12,9
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	20 b4       	sub	r4,11

800028e4 <mic_reply_func>:

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800028e4:	eb cd 40 80 	pushm	r7,lr
800028e8:	1a 97       	mov	r7,sp
800028ea:	20 2d       	sub	sp,8
800028ec:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800028f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028f4:	2f e8       	sub	r8,-2
800028f6:	ef 48 ff fc 	st.w	r7[-4],r8
	
	log("\n\r Mic_reply \n\r");
800028fa:	4a 2c       	lddpc	r12,80002980 <mic_reply_func+0x9c>
800028fc:	f0 1f 00 22 	mcall	80002984 <mic_reply_func+0xa0>
	if (ptr->Result == 0x00)
80002900:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002904:	11 88       	ld.ub	r8,r8[0x0]
80002906:	58 08       	cp.w	r8,0
80002908:	c3 51       	brne	80002972 <mic_reply_func+0x8e>
	{
		
		if (ptr->Function == Mic_Disable)
8000290a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000290e:	11 99       	ld.ub	r9,r8[0x1]
80002910:	30 28       	mov	r8,2
80002912:	f0 09 18 00 	cp.b	r9,r8
80002916:	c2 51       	brne	80002960 <mic_reply_func+0x7c>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002918:	49 cc       	lddpc	r12,80002988 <mic_reply_func+0xa4>
8000291a:	f0 1f 00 1b 	mcall	80002984 <mic_reply_func+0xa0>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
8000291e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002922:	11 a8       	ld.ub	r8,r8[0x2]
80002924:	1a d8       	st.w	--sp,r8
80002926:	49 ac       	lddpc	r12,8000298c <mic_reply_func+0xa8>
80002928:	f0 1f 00 17 	mcall	80002984 <mic_reply_func+0xa0>
8000292c:	2f fd       	sub	sp,-4
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000292e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002932:	11 b8       	ld.ub	r8,r8[0x3]
80002934:	1a d8       	st.w	--sp,r8
80002936:	49 7c       	lddpc	r12,80002990 <mic_reply_func+0xac>
80002938:	f0 1f 00 13 	mcall	80002984 <mic_reply_func+0xa0>
8000293c:	2f fd       	sub	sp,-4
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000293e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002942:	11 c8       	ld.ub	r8,r8[0x4]
80002944:	1a d8       	st.w	--sp,r8
80002946:	49 4c       	lddpc	r12,80002994 <mic_reply_func+0xb0>
80002948:	f0 1f 00 0f 	mcall	80002984 <mic_reply_func+0xa0>
8000294c:	2f fd       	sub	sp,-4
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000294e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002952:	11 d8       	ld.ub	r8,r8[0x5]
80002954:	1a d8       	st.w	--sp,r8
80002956:	49 1c       	lddpc	r12,80002998 <mic_reply_func+0xb4>
80002958:	f0 1f 00 0b 	mcall	80002984 <mic_reply_func+0xa0>
8000295c:	2f fd       	sub	sp,-4
8000295e:	c0 d8       	rjmp	80002978 <mic_reply_func+0x94>
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002960:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002964:	11 98       	ld.ub	r8,r8[0x1]
80002966:	1a d8       	st.w	--sp,r8
80002968:	48 dc       	lddpc	r12,8000299c <mic_reply_func+0xb8>
8000296a:	f0 1f 00 07 	mcall	80002984 <mic_reply_func+0xa0>
8000296e:	2f fd       	sub	sp,-4
80002970:	c0 48       	rjmp	80002978 <mic_reply_func+0x94>
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002972:	48 cc       	lddpc	r12,800029a0 <mic_reply_func+0xbc>
80002974:	f0 1f 00 04 	mcall	80002984 <mic_reply_func+0xa0>
		
	}
	
	
	
}
80002978:	2f ed       	sub	sp,-8
8000297a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000297e:	00 00       	add	r0,r0
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	20 d0       	sub	r0,13
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	8d 90       	st.w	r6[0x24],r0
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	20 e0       	sub	r0,14
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	20 f4       	sub	r4,15
80002990:	80 00       	ld.sh	r0,r0[0x0]
80002992:	21 08       	sub	r8,16
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	21 24       	sub	r4,18
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	21 3c       	sub	r12,19
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	21 54       	sub	r4,21
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	21 6c       	sub	r12,22

800029a4 <mic_brdcst_func>:

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800029a4:	eb cd 40 80 	pushm	r7,lr
800029a8:	1a 97       	mov	r7,sp
800029aa:	20 2d       	sub	sp,8
800029ac:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800029b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800029b4:	2f e8       	sub	r8,-2
800029b6:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800029ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800029be:	11 a8       	ld.ub	r8,r8[0x2]
800029c0:	58 08       	cp.w	r8,0
800029c2:	c0 71       	brne	800029d0 <mic_brdcst_func+0x2c>
	{
		log("\n\r Mic_Disabled \n\r");	
800029c4:	49 0c       	lddpc	r12,80002a04 <mic_brdcst_func+0x60>
800029c6:	f0 1f 00 11 	mcall	80002a08 <mic_brdcst_func+0x64>
		Mic_is_Enabled = 0;
800029ca:	49 19       	lddpc	r9,80002a0c <mic_brdcst_func+0x68>
800029cc:	30 08       	mov	r8,0
800029ce:	b2 88       	st.b	r9[0x0],r8
	} 
	if(ptr->Mic_State == 0x11)
800029d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800029d4:	11 a9       	ld.ub	r9,r8[0x2]
800029d6:	31 18       	mov	r8,17
800029d8:	f0 09 18 00 	cp.b	r9,r8
800029dc:	c1 11       	brne	800029fe <mic_brdcst_func+0x5a>
	{
		log("\n\r Mic_Enabled \n\r");
800029de:	48 dc       	lddpc	r12,80002a10 <mic_brdcst_func+0x6c>
800029e0:	f0 1f 00 0a 	mcall	80002a08 <mic_brdcst_func+0x64>
		Mic_is_Enabled = 1;
800029e4:	48 a9       	lddpc	r9,80002a0c <mic_brdcst_func+0x68>
800029e6:	30 18       	mov	r8,1
800029e8:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800029ea:	48 98       	lddpc	r8,80002a0c <mic_brdcst_func+0x68>
800029ec:	11 88       	ld.ub	r8,r8[0x0]
800029ee:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800029f2:	30 18       	mov	r8,1
800029f4:	f0 09 18 00 	cp.b	r9,r8
800029f8:	c0 31       	brne	800029fe <mic_brdcst_func+0x5a>
800029fa:	48 78       	lddpc	r8,80002a14 <mic_brdcst_func+0x70>
800029fc:	11 88       	ld.ub	r8,r8[0x0]
	}
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
800029fe:	2f ed       	sub	sp,-8
80002a00:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a04:	80 00       	ld.sh	r0,r0[0x0]
80002a06:	21 7c       	sub	r12,23
80002a08:	80 00       	ld.sh	r0,r0[0x0]
80002a0a:	8d 90       	st.w	r6[0x24],r0
80002a0c:	00 00       	add	r0,r0
80002a0e:	0a 3d       	cp.w	sp,r5
80002a10:	80 00       	ld.sh	r0,r0[0x0]
80002a12:	21 90       	sub	r0,25
80002a14:	00 00       	add	r0,r0
80002a16:	0a 3e       	cp.w	lr,r5

80002a18 <spk_reply_func>:

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002a18:	eb cd 40 80 	pushm	r7,lr
80002a1c:	1a 97       	mov	r7,sp
80002a1e:	20 1d       	sub	sp,4
80002a20:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002a24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a28:	11 a8       	ld.ub	r8,r8[0x2]
80002a2a:	58 08       	cp.w	r8,0
80002a2c:	c1 21       	brne	80002a50 <spk_reply_func+0x38>
	{
		
		if(xcmp->u8[4])
80002a2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a32:	11 e8       	ld.ub	r8,r8[0x6]
80002a34:	58 08       	cp.w	r8,0
80002a36:	c0 40       	breq	80002a3e <spk_reply_func+0x26>
		{
			Speaker_is_unmute = 1;
80002a38:	48 b9       	lddpc	r9,80002a64 <spk_reply_func+0x4c>
80002a3a:	30 18       	mov	r8,1
80002a3c:	b2 88       	st.b	r9[0x0],r8
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002a3e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a42:	11 e8       	ld.ub	r8,r8[0x6]
80002a44:	1a d8       	st.w	--sp,r8
80002a46:	48 9c       	lddpc	r12,80002a68 <spk_reply_func+0x50>
80002a48:	f0 1f 00 09 	mcall	80002a6c <spk_reply_func+0x54>
80002a4c:	2f fd       	sub	sp,-4
80002a4e:	c0 78       	rjmp	80002a5c <spk_reply_func+0x44>
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002a50:	48 59       	lddpc	r9,80002a64 <spk_reply_func+0x4c>
80002a52:	30 08       	mov	r8,0
80002a54:	b2 88       	st.b	r9[0x0],r8
		log("spk error");
80002a56:	48 7c       	lddpc	r12,80002a70 <spk_reply_func+0x58>
80002a58:	f0 1f 00 05 	mcall	80002a6c <spk_reply_func+0x54>
	}
}
80002a5c:	2f fd       	sub	sp,-4
80002a5e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a62:	00 00       	add	r0,r0
80002a64:	00 00       	add	r0,r0
80002a66:	0a 38       	cp.w	r8,r5
80002a68:	80 00       	ld.sh	r0,r0[0x0]
80002a6a:	21 a4       	sub	r4,26
80002a6c:	80 00       	ld.sh	r0,r0[0x0]
80002a6e:	8d 90       	st.w	r6[0x24],r0
80002a70:	80 00       	ld.sh	r0,r0[0x0]
80002a72:	21 b4       	sub	r4,27

80002a74 <spk_brdcst_func>:

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002a74:	eb cd 40 80 	pushm	r7,lr
80002a78:	1a 97       	mov	r7,sp
80002a7a:	20 1d       	sub	sp,4
80002a7c:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002a80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a84:	11 d8       	ld.ub	r8,r8[0x5]
80002a86:	58 08       	cp.w	r8,0
80002a88:	c0 81       	brne	80002a98 <spk_brdcst_func+0x24>
	{
		Speaker_is_unmute =0;
80002a8a:	48 99       	lddpc	r9,80002aac <spk_brdcst_func+0x38>
80002a8c:	30 08       	mov	r8,0
80002a8e:	b2 88       	st.b	r9[0x0],r8
		//Silent_flag = 0;
		log("spk_s_close ");
80002a90:	48 8c       	lddpc	r12,80002ab0 <spk_brdcst_func+0x3c>
80002a92:	f0 1f 00 09 	mcall	80002ab4 <spk_brdcst_func+0x40>
80002a96:	c0 78       	rjmp	80002aa4 <spk_brdcst_func+0x30>
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002a98:	48 59       	lddpc	r9,80002aac <spk_brdcst_func+0x38>
80002a9a:	30 18       	mov	r8,1
80002a9c:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_open ");	
80002a9e:	48 7c       	lddpc	r12,80002ab8 <spk_brdcst_func+0x44>
80002aa0:	f0 1f 00 05 	mcall	80002ab4 <spk_brdcst_func+0x40>
	}
	
	
	
	
}
80002aa4:	2f fd       	sub	sp,-4
80002aa6:	e3 cd 80 80 	ldm	sp++,r7,pc
80002aaa:	00 00       	add	r0,r0
80002aac:	00 00       	add	r0,r0
80002aae:	0a 38       	cp.w	r8,r5
80002ab0:	80 00       	ld.sh	r0,r0[0x0]
80002ab2:	21 c0       	sub	r0,28
80002ab4:	80 00       	ld.sh	r0,r0[0x0]
80002ab6:	8d 90       	st.w	r6[0x24],r0
80002ab8:	80 00       	ld.sh	r0,r0[0x0]
80002aba:	21 d0       	sub	r0,29

80002abc <Volume_reply_func>:


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002abc:	eb cd 40 80 	pushm	r7,lr
80002ac0:	1a 97       	mov	r7,sp
80002ac2:	20 2d       	sub	sp,8
80002ac4:	ef 4c ff f8 	st.w	r7[-8],r12
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002ac8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002acc:	2f e8       	sub	r8,-2
80002ace:	ef 48 ff fc 	st.w	r7[-4],r8
	
		if (ptr->Result == xcmp_Res_Success)
80002ad2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ad6:	11 88       	ld.ub	r8,r8[0x0]
80002ad8:	58 08       	cp.w	r8,0
80002ada:	c2 41       	brne	80002b22 <Volume_reply_func+0x66>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002adc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ae0:	11 b9       	ld.ub	r9,r8[0x3]
80002ae2:	31 08       	mov	r8,16
80002ae4:	f0 09 18 00 	cp.b	r9,r8
80002ae8:	c1 41       	brne	80002b10 <Volume_reply_func+0x54>
			{
				log("\n\r Enable_IA OK \n\r");
80002aea:	49 2c       	lddpc	r12,80002b30 <Volume_reply_func+0x74>
80002aec:	f0 1f 00 12 	mcall	80002b34 <Volume_reply_func+0x78>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002af0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002af4:	11 98       	ld.ub	r8,r8[0x1]
80002af6:	f0 09 15 08 	lsl	r9,r8,0x8
80002afa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002afe:	11 a8       	ld.ub	r8,r8[0x2]
80002b00:	f3 e8 10 08 	or	r8,r9,r8
80002b04:	1a d8       	st.w	--sp,r8
80002b06:	48 dc       	lddpc	r12,80002b38 <Volume_reply_func+0x7c>
80002b08:	f0 1f 00 0b 	mcall	80002b34 <Volume_reply_func+0x78>
80002b0c:	2f fd       	sub	sp,-4
80002b0e:	c0 d8       	rjmp	80002b28 <Volume_reply_func+0x6c>
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002b10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b14:	11 b8       	ld.ub	r8,r8[0x3]
80002b16:	1a d8       	st.w	--sp,r8
80002b18:	48 9c       	lddpc	r12,80002b3c <Volume_reply_func+0x80>
80002b1a:	f0 1f 00 07 	mcall	80002b34 <Volume_reply_func+0x78>
80002b1e:	2f fd       	sub	sp,-4
80002b20:	c0 48       	rjmp	80002b28 <Volume_reply_func+0x6c>
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002b22:	48 8c       	lddpc	r12,80002b40 <Volume_reply_func+0x84>
80002b24:	f0 1f 00 04 	mcall	80002b34 <Volume_reply_func+0x78>
		}
	
	
	
}
80002b28:	2f ed       	sub	sp,-8
80002b2a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b2e:	00 00       	add	r0,r0
80002b30:	80 00       	ld.sh	r0,r0[0x0]
80002b32:	21 dc       	sub	r12,29
80002b34:	80 00       	ld.sh	r0,r0[0x0]
80002b36:	8d 90       	st.w	r6[0x24],r0
80002b38:	80 00       	ld.sh	r0,r0[0x0]
80002b3a:	21 f0       	sub	r0,31
80002b3c:	80 00       	ld.sh	r0,r0[0x0]
80002b3e:	22 0c       	sub	r12,32
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	22 24       	sub	r4,34

80002b44 <Volume_brdcst_func>:

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
80002b44:	eb cd 40 80 	pushm	r7,lr
80002b48:	1a 97       	mov	r7,sp
80002b4a:	20 2d       	sub	sp,8
80002b4c:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
80002b50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b54:	2f e8       	sub	r8,-2
80002b56:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002b5a:	2f ed       	sub	sp,-8
80002b5c:	e3 cd 80 80 	ldm	sp++,r7,pc

80002b60 <AudioRoutingControl_reply_func>:


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002b60:	eb cd 40 80 	pushm	r7,lr
80002b64:	1a 97       	mov	r7,sp
80002b66:	20 1d       	sub	sp,4
80002b68:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002b6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b70:	11 a8       	ld.ub	r8,r8[0x2]
80002b72:	58 08       	cp.w	r8,0
80002b74:	c0 71       	brne	80002b82 <AudioRoutingControl_reply_func+0x22>
	{
		log("AudioRouting OK");
80002b76:	48 7c       	lddpc	r12,80002b90 <AudioRoutingControl_reply_func+0x30>
80002b78:	f0 1f 00 07 	mcall	80002b94 <AudioRoutingControl_reply_func+0x34>
		xcmp_IdleTestTone();//
80002b7c:	f0 1f 00 07 	mcall	80002b98 <AudioRoutingControl_reply_func+0x38>
80002b80:	c0 48       	rjmp	80002b88 <AudioRoutingControl_reply_func+0x28>
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002b82:	48 7c       	lddpc	r12,80002b9c <AudioRoutingControl_reply_func+0x3c>
80002b84:	f0 1f 00 04 	mcall	80002b94 <AudioRoutingControl_reply_func+0x34>
		//log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
		
	}
}
80002b88:	2f fd       	sub	sp,-4
80002b8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b8e:	00 00       	add	r0,r0
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	22 3c       	sub	r12,35
80002b94:	80 00       	ld.sh	r0,r0[0x0]
80002b96:	8d 90       	st.w	r6[0x24],r0
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	5a 4c       	cp.w	r12,-28
80002b9c:	80 00       	ld.sh	r0,r0[0x0]
80002b9e:	22 4c       	sub	r12,36

80002ba0 <AudioRoutingControl_brdcst_func>:


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002ba0:	eb cd 40 80 	pushm	r7,lr
80002ba4:	1a 97       	mov	r7,sp
80002ba6:	20 2d       	sub	sp,8
80002ba8:	ef 4c ff f8 	st.w	r7[-8],r12
	
	U16 num_routings = 0;
80002bac:	30 08       	mov	r8,0
80002bae:	ef 58 ff fc 	st.h	r7[-4],r8
	U8 j = 0 ;
80002bb2:	30 08       	mov	r8,0
80002bb4:	ef 68 ff ff 	st.b	r7[-1],r8
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
80002bb8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bbc:	11 a8       	ld.ub	r8,r8[0x2]
80002bbe:	a9 68       	lsl	r8,0x8
80002bc0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002bc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bc8:	11 b8       	ld.ub	r8,r8[0x3]
80002bca:	f3 e8 10 08 	or	r8,r9,r8
80002bce:	5c 88       	casts.h	r8
80002bd0:	ef 58 ff fc 	st.h	r7[-4],r8
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002bd4:	2f ed       	sub	sp,-8
80002bd6:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bda:	d7 03       	nop

80002bdc <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002bdc:	eb cd 40 80 	pushm	r7,lr
80002be0:	1a 97       	mov	r7,sp
80002be2:	20 2d       	sub	sp,8
80002be4:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002be8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bec:	2f e8       	sub	r8,-2
80002bee:	ef 48 ff fc 	st.w	r7[-4],r8
	
	if (ptr->Result == xcmp_Res_Success)
80002bf2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bf6:	11 88       	ld.ub	r8,r8[0x0]
80002bf8:	58 08       	cp.w	r8,0
80002bfa:	c1 d1       	brne	80002c34 <TransmitControl_reply_func+0x58>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002bfc:	49 1c       	lddpc	r12,80002c40 <TransmitControl_reply_func+0x64>
80002bfe:	f0 1f 00 12 	mcall	80002c44 <TransmitControl_reply_func+0x68>
		log("\n\r Function: %x \n\r", ptr->Function);
80002c02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c06:	11 98       	ld.ub	r8,r8[0x1]
80002c08:	1a d8       	st.w	--sp,r8
80002c0a:	49 0c       	lddpc	r12,80002c48 <TransmitControl_reply_func+0x6c>
80002c0c:	f0 1f 00 0e 	mcall	80002c44 <TransmitControl_reply_func+0x68>
80002c10:	2f fd       	sub	sp,-4
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002c12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c16:	11 a8       	ld.ub	r8,r8[0x2]
80002c18:	1a d8       	st.w	--sp,r8
80002c1a:	48 dc       	lddpc	r12,80002c4c <TransmitControl_reply_func+0x70>
80002c1c:	f0 1f 00 0a 	mcall	80002c44 <TransmitControl_reply_func+0x68>
80002c20:	2f fd       	sub	sp,-4
		log("\n\r State: %x \n\r", ptr->State);
80002c22:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c26:	11 b8       	ld.ub	r8,r8[0x3]
80002c28:	1a d8       	st.w	--sp,r8
80002c2a:	48 ac       	lddpc	r12,80002c50 <TransmitControl_reply_func+0x74>
80002c2c:	f0 1f 00 06 	mcall	80002c44 <TransmitControl_reply_func+0x68>
80002c30:	2f fd       	sub	sp,-4
80002c32:	c0 48       	rjmp	80002c3a <TransmitControl_reply_func+0x5e>
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002c34:	48 8c       	lddpc	r12,80002c54 <TransmitControl_reply_func+0x78>
80002c36:	f0 1f 00 04 	mcall	80002c44 <TransmitControl_reply_func+0x68>
	}
	

}
80002c3a:	2f ed       	sub	sp,-8
80002c3c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c40:	80 00       	ld.sh	r0,r0[0x0]
80002c42:	22 60       	sub	r0,38
80002c44:	80 00       	ld.sh	r0,r0[0x0]
80002c46:	8d 90       	st.w	r6[0x24],r0
80002c48:	80 00       	ld.sh	r0,r0[0x0]
80002c4a:	22 7c       	sub	r12,39
80002c4c:	80 00       	ld.sh	r0,r0[0x0]
80002c4e:	22 90       	sub	r0,41
80002c50:	80 00       	ld.sh	r0,r0[0x0]
80002c52:	22 ac       	sub	r12,42
80002c54:	80 00       	ld.sh	r0,r0[0x0]
80002c56:	22 bc       	sub	r12,43

80002c58 <TransmitControl_brdcst_func>:


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002c58:	eb cd 40 80 	pushm	r7,lr
80002c5c:	1a 97       	mov	r7,sp
80002c5e:	20 2d       	sub	sp,8
80002c60:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002c64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c68:	2f e8       	sub	r8,-2
80002c6a:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002c6e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c72:	11 98       	ld.ub	r8,r8[0x1]
80002c74:	58 08       	cp.w	r8,0
80002c76:	c0 71       	brne	80002c84 <TransmitControl_brdcst_func+0x2c>
	{
		log("\n\r  Standby-Receive \n\r ");
80002c78:	48 bc       	lddpc	r12,80002ca4 <TransmitControl_brdcst_func+0x4c>
80002c7a:	f0 1f 00 0c 	mcall	80002ca8 <TransmitControl_brdcst_func+0x50>
		Radio_Transmit_State = 0;
80002c7e:	48 c9       	lddpc	r9,80002cac <TransmitControl_brdcst_func+0x54>
80002c80:	30 08       	mov	r8,0
80002c82:	b2 88       	st.b	r9[0x0],r8
	}
	if (ptr->State == 0x01)
80002c84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c88:	11 99       	ld.ub	r9,r8[0x1]
80002c8a:	30 18       	mov	r8,1
80002c8c:	f0 09 18 00 	cp.b	r9,r8
80002c90:	c0 71       	brne	80002c9e <TransmitControl_brdcst_func+0x46>
	{
		log("\n\r  Transmit \n\r ");
80002c92:	48 8c       	lddpc	r12,80002cb0 <TransmitControl_brdcst_func+0x58>
80002c94:	f0 1f 00 05 	mcall	80002ca8 <TransmitControl_brdcst_func+0x50>
		Radio_Transmit_State = 1;
80002c98:	48 59       	lddpc	r9,80002cac <TransmitControl_brdcst_func+0x54>
80002c9a:	30 18       	mov	r8,1
80002c9c:	b2 88       	st.b	r9[0x0],r8
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002c9e:	2f ed       	sub	sp,-8
80002ca0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ca4:	80 00       	ld.sh	r0,r0[0x0]
80002ca6:	22 d4       	sub	r4,45
80002ca8:	80 00       	ld.sh	r0,r0[0x0]
80002caa:	8d 90       	st.w	r6[0x24],r0
80002cac:	00 00       	add	r0,r0
80002cae:	0a 3c       	cp.w	r12,r5
80002cb0:	80 00       	ld.sh	r0,r0[0x0]
80002cb2:	22 ec       	sub	r12,46

80002cb4 <CallControl_brdcst_func>:


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002cb4:	eb cd 40 80 	pushm	r7,lr
80002cb8:	1a 97       	mov	r7,sp
80002cba:	20 2d       	sub	sp,8
80002cbc:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002cc0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cc4:	2f e8       	sub	r8,-2
80002cc6:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002cca:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cce:	11 98       	ld.ub	r8,r8[0x1]
80002cd0:	1a d8       	st.w	--sp,r8
80002cd2:	48 ec       	lddpc	r12,80002d08 <CallControl_brdcst_func+0x54>
80002cd4:	f0 1f 00 0e 	mcall	80002d0c <CallControl_brdcst_func+0x58>
80002cd8:	2f fd       	sub	sp,-4
	if (ptr->Callstate == Call_Ended)//0x03
80002cda:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cde:	11 99       	ld.ub	r9,r8[0x1]
80002ce0:	30 38       	mov	r8,3
80002ce2:	f0 09 18 00 	cp.b	r9,r8
80002ce6:	c0 41       	brne	80002cee <CallControl_brdcst_func+0x3a>
	{
		//
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002ce8:	48 a9       	lddpc	r9,80002d10 <CallControl_brdcst_func+0x5c>
80002cea:	30 08       	mov	r8,0
80002cec:	b2 88       	st.b	r9[0x0],r8
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002cee:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cf2:	11 99       	ld.ub	r9,r8[0x1]
80002cf4:	30 48       	mov	r8,4
80002cf6:	f0 09 18 00 	cp.b	r9,r8
80002cfa:	c0 41       	brne	80002d02 <CallControl_brdcst_func+0x4e>
	{
		Call_Begin = 1;
80002cfc:	48 59       	lddpc	r9,80002d10 <CallControl_brdcst_func+0x5c>
80002cfe:	30 18       	mov	r8,1
80002d00:	b2 88       	st.b	r9[0x0],r8
		//xcmp_audio_route_decoder_AMBE();

	}
	
	
}
80002d02:	2f ed       	sub	sp,-8
80002d04:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d08:	80 00       	ld.sh	r0,r0[0x0]
80002d0a:	23 00       	sub	r0,48
80002d0c:	80 00       	ld.sh	r0,r0[0x0]
80002d0e:	8d 90       	st.w	r6[0x24],r0
80002d10:	00 00       	add	r0,r0
80002d12:	0a 3e       	cp.w	lr,r5

80002d14 <DataSession_reply_func>:



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002d14:	eb cd 40 80 	pushm	r7,lr
80002d18:	1a 97       	mov	r7,sp
80002d1a:	20 1d       	sub	sp,4
80002d1c:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002d20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d24:	11 a8       	ld.ub	r8,r8[0x2]
80002d26:	58 08       	cp.w	r8,0
80002d28:	c0 51       	brne	80002d32 <DataSession_reply_func+0x1e>
	{
		log("\n\r DATArep OK \n\r");
80002d2a:	49 2c       	lddpc	r12,80002d70 <DataSession_reply_func+0x5c>
80002d2c:	f0 1f 00 12 	mcall	80002d74 <DataSession_reply_func+0x60>
80002d30:	c1 c8       	rjmp	80002d68 <DataSession_reply_func+0x54>
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002d32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d36:	11 a8       	ld.ub	r8,r8[0x2]
80002d38:	1a d8       	st.w	--sp,r8
80002d3a:	49 0c       	lddpc	r12,80002d78 <DataSession_reply_func+0x64>
80002d3c:	f0 1f 00 0e 	mcall	80002d74 <DataSession_reply_func+0x60>
80002d40:	2f fd       	sub	sp,-4
		log("\n\r DATArep error \n\r");
80002d42:	48 fc       	lddpc	r12,80002d7c <DataSession_reply_func+0x68>
80002d44:	f0 1f 00 0c 	mcall	80002d74 <DataSession_reply_func+0x60>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002d48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d4c:	11 b8       	ld.ub	r8,r8[0x3]
80002d4e:	1a d8       	st.w	--sp,r8
80002d50:	48 cc       	lddpc	r12,80002d80 <DataSession_reply_func+0x6c>
80002d52:	f0 1f 00 09 	mcall	80002d74 <DataSession_reply_func+0x60>
80002d56:	2f fd       	sub	sp,-4
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
80002d58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d5c:	11 c8       	ld.ub	r8,r8[0x4]
80002d5e:	1a d8       	st.w	--sp,r8
80002d60:	48 9c       	lddpc	r12,80002d84 <DataSession_reply_func+0x70>
80002d62:	f0 1f 00 05 	mcall	80002d74 <DataSession_reply_func+0x60>
80002d66:	2f fd       	sub	sp,-4
	}
	
}
80002d68:	2f fd       	sub	sp,-4
80002d6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d6e:	00 00       	add	r0,r0
80002d70:	80 00       	ld.sh	r0,r0[0x0]
80002d72:	23 18       	sub	r8,49
80002d74:	80 00       	ld.sh	r0,r0[0x0]
80002d76:	8d 90       	st.w	r6[0x24],r0
80002d78:	80 00       	ld.sh	r0,r0[0x0]
80002d7a:	23 2c       	sub	r12,50
80002d7c:	80 00       	ld.sh	r0,r0[0x0]
80002d7e:	23 40       	sub	r0,52
80002d80:	80 00       	ld.sh	r0,r0[0x0]
80002d82:	23 54       	sub	r4,53
80002d84:	80 00       	ld.sh	r0,r0[0x0]
80002d86:	23 64       	sub	r4,54

80002d88 <DataSession_brdcst_func>:

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002d88:	eb cd 40 80 	pushm	r7,lr
80002d8c:	1a 97       	mov	r7,sp
80002d8e:	20 4d       	sub	sp,16
80002d90:	ef 4c ff f0 	st.w	r7[-16],r12
	U8 Session_number = 0;
80002d94:	30 08       	mov	r8,0
80002d96:	ef 68 ff f7 	st.b	r7[-9],r8
	U16 data_length = 0;
80002d9a:	30 08       	mov	r8,0
80002d9c:	ef 58 ff f8 	st.h	r7[-8],r8
	U8 i = 0;
80002da0:	30 08       	mov	r8,0
80002da2:	ef 68 ff fb 	st.b	r7[-5],r8
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002da6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002daa:	2f e8       	sub	r8,-2
80002dac:	ef 48 ff fc 	st.w	r7[-4],r8

	if (ptr->State == CSBK_DATA_RX_Suc)
80002db0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002db4:	11 89       	ld.ub	r9,r8[0x0]
80002db6:	32 48       	mov	r8,36
80002db8:	f0 09 18 00 	cp.b	r9,r8
80002dbc:	c4 71       	brne	80002e4a <DataSession_brdcst_func+0xc2>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002dbe:	4a 9c       	lddpc	r12,80002e60 <DataSession_brdcst_func+0xd8>
80002dc0:	f0 1f 00 29 	mcall	80002e64 <DataSession_brdcst_func+0xdc>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
80002dc4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dc8:	11 98       	ld.ub	r8,r8[0x1]
80002dca:	ef 68 ff f7 	st.b	r7[-9],r8
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002dce:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dd2:	11 a8       	ld.ub	r8,r8[0x2]
80002dd4:	a9 68       	lsl	r8,0x8
80002dd6:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002dda:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dde:	11 b8       	ld.ub	r8,r8[0x3]
80002de0:	f3 e8 10 08 	or	r8,r9,r8
80002de4:	5c 88       	casts.h	r8
80002de6:	ef 58 ff f8 	st.h	r7[-8],r8

		log("\n\r Session_ID: %x \n\r",Session_number );
80002dea:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80002dee:	1a d8       	st.w	--sp,r8
80002df0:	49 ec       	lddpc	r12,80002e68 <DataSession_brdcst_func+0xe0>
80002df2:	f0 1f 00 1d 	mcall	80002e64 <DataSession_brdcst_func+0xdc>
80002df6:	2f fd       	sub	sp,-4
		log("\n\r paylaod_length: %d \n\r",data_length );
80002df8:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80002dfc:	1a d8       	st.w	--sp,r8
80002dfe:	49 cc       	lddpc	r12,80002e6c <DataSession_brdcst_func+0xe4>
80002e00:	f0 1f 00 19 	mcall	80002e64 <DataSession_brdcst_func+0xdc>
80002e04:	2f fd       	sub	sp,-4
		for(i=0; i<data_length; i++)
80002e06:	30 08       	mov	r8,0
80002e08:	ef 68 ff fb 	st.b	r7[-5],r8
80002e0c:	c1 68       	rjmp	80002e38 <DataSession_brdcst_func+0xb0>
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002e0e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e12:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002e16:	f2 08 00 08 	add	r8,r9,r8
80002e1a:	11 c8       	ld.ub	r8,r8[0x4]
80002e1c:	10 99       	mov	r9,r8
80002e1e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e22:	1a d9       	st.w	--sp,r9
80002e24:	1a d8       	st.w	--sp,r8
80002e26:	49 3c       	lddpc	r12,80002e70 <DataSession_brdcst_func+0xe8>
80002e28:	f0 1f 00 0f 	mcall	80002e64 <DataSession_brdcst_func+0xdc>
80002e2c:	2f ed       	sub	sp,-8
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002e2e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e32:	2f f8       	sub	r8,-1
80002e34:	ef 68 ff fb 	st.b	r7[-5],r8
80002e38:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e3c:	ef 09 ff f8 	ld.sh	r9,r7[-8]
80002e40:	f0 09 19 00 	cp.h	r9,r8
80002e44:	fe 9b ff e5 	brhi	80002e0e <DataSession_brdcst_func+0x86>
80002e48:	c0 98       	rjmp	80002e5a <DataSession_brdcst_func+0xd2>
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002e4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e4e:	11 88       	ld.ub	r8,r8[0x0]
80002e50:	1a d8       	st.w	--sp,r8
80002e52:	48 9c       	lddpc	r12,80002e74 <DataSession_brdcst_func+0xec>
80002e54:	f0 1f 00 04 	mcall	80002e64 <DataSession_brdcst_func+0xdc>
80002e58:	2f fd       	sub	sp,-4
		
	}
	
}
80002e5a:	2f cd       	sub	sp,-16
80002e5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e60:	80 00       	ld.sh	r0,r0[0x0]
80002e62:	23 74       	sub	r4,55
80002e64:	80 00       	ld.sh	r0,r0[0x0]
80002e66:	8d 90       	st.w	r6[0x24],r0
80002e68:	80 00       	ld.sh	r0,r0[0x0]
80002e6a:	23 88       	sub	r8,56
80002e6c:	80 00       	ld.sh	r0,r0[0x0]
80002e6e:	23 a0       	sub	r0,58
80002e70:	80 00       	ld.sh	r0,r0[0x0]
80002e72:	23 bc       	sub	r12,59
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	23 d4       	sub	r4,61

80002e78 <ButtonConfig_reply_func>:

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002e78:	eb cd 40 80 	pushm	r7,lr
80002e7c:	1a 97       	mov	r7,sp
80002e7e:	20 2d       	sub	sp,8
80002e80:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002e84:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e88:	2f e8       	sub	r8,-2
80002e8a:	ef 48 ff fc 	st.w	r7[-4],r8
	if (ptr->Result == xcmp_Res_Success)
80002e8e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e92:	11 88       	ld.ub	r8,r8[0x0]
80002e94:	58 08       	cp.w	r8,0
80002e96:	c0 d1       	brne	80002eb0 <ButtonConfig_reply_func+0x38>
	{
		log("\n\r Button_Config OK \n\r");
80002e98:	48 9c       	lddpc	r12,80002ebc <ButtonConfig_reply_func+0x44>
80002e9a:	f0 1f 00 0a 	mcall	80002ec0 <ButtonConfig_reply_func+0x48>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002e9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ea2:	11 98       	ld.ub	r8,r8[0x1]
80002ea4:	1a d8       	st.w	--sp,r8
80002ea6:	48 8c       	lddpc	r12,80002ec4 <ButtonConfig_reply_func+0x4c>
80002ea8:	f0 1f 00 06 	mcall	80002ec0 <ButtonConfig_reply_func+0x48>
80002eac:	2f fd       	sub	sp,-4
80002eae:	c0 48       	rjmp	80002eb6 <ButtonConfig_reply_func+0x3e>
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002eb0:	48 6c       	lddpc	r12,80002ec8 <ButtonConfig_reply_func+0x50>
80002eb2:	f0 1f 00 04 	mcall	80002ec0 <ButtonConfig_reply_func+0x48>
	}
	
}
80002eb6:	2f ed       	sub	sp,-8
80002eb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ebc:	80 00       	ld.sh	r0,r0[0x0]
80002ebe:	23 e8       	sub	r8,62
80002ec0:	80 00       	ld.sh	r0,r0[0x0]
80002ec2:	8d 90       	st.w	r6[0x24],r0
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	24 00       	sub	r0,64
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	24 14       	sub	r4,65

80002ecc <Phyuserinput_brdcst_func>:


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002ecc:	eb cd 40 80 	pushm	r7,lr
80002ed0:	1a 97       	mov	r7,sp
80002ed2:	20 3d       	sub	sp,12
80002ed4:	ef 4c ff f4 	st.w	r7[-12],r12
	U8 PUI_Source =0;
80002ed8:	30 08       	mov	r8,0
80002eda:	ef 68 ff f8 	st.b	r7[-8],r8
	U8 PUI_Type =0;
80002ede:	30 08       	mov	r8,0
80002ee0:	ef 68 ff f9 	st.b	r7[-7],r8
	U16 PUI_ID =0;
80002ee4:	30 08       	mov	r8,0
80002ee6:	ef 58 ff fa 	st.h	r7[-6],r8
	U8 PUI_State =0;
80002eea:	30 08       	mov	r8,0
80002eec:	ef 68 ff fd 	st.b	r7[-3],r8
	U8 PUI_State_Min_Value =0;
80002ef0:	30 08       	mov	r8,0
80002ef2:	ef 68 ff fe 	st.b	r7[-2],r8
	U8 PUI_State_Max_Value =0;
80002ef6:	30 08       	mov	r8,0
80002ef8:	ef 68 ff ff 	st.b	r7[-1],r8
	
	PUI_Source = xcmp->u8[0];
80002efc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f00:	11 a8       	ld.ub	r8,r8[0x2]
80002f02:	ef 68 ff f8 	st.b	r7[-8],r8
	PUI_Type = xcmp ->u8[1];
80002f06:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f0a:	11 b8       	ld.ub	r8,r8[0x3]
80002f0c:	ef 68 ff f9 	st.b	r7[-7],r8
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002f10:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f14:	11 c8       	ld.ub	r8,r8[0x4]
80002f16:	a9 68       	lsl	r8,0x8
80002f18:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002f1c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f20:	11 d8       	ld.ub	r8,r8[0x5]
80002f22:	f3 e8 10 08 	or	r8,r9,r8
80002f26:	5c 88       	casts.h	r8
80002f28:	ef 58 ff fa 	st.h	r7[-6],r8
	PUI_State = xcmp->u8[4];
80002f2c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f30:	11 e8       	ld.ub	r8,r8[0x6]
80002f32:	ef 68 ff fd 	st.b	r7[-3],r8
	PUI_State_Min_Value = xcmp->u8[5];
80002f36:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f3a:	11 f8       	ld.ub	r8,r8[0x7]
80002f3c:	ef 68 ff fe 	st.b	r7[-2],r8
	PUI_State_Max_Value = xcmp->u8[6];
80002f40:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f44:	f1 38 00 08 	ld.ub	r8,r8[8]
80002f48:	ef 68 ff ff 	st.b	r7[-1],r8
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002f4c:	49 8c       	lddpc	r12,80002fac <Phyuserinput_brdcst_func+0xe0>
80002f4e:	f0 1f 00 19 	mcall	80002fb0 <Phyuserinput_brdcst_func+0xe4>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002f52:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80002f56:	1a d8       	st.w	--sp,r8
80002f58:	49 7c       	lddpc	r12,80002fb4 <Phyuserinput_brdcst_func+0xe8>
80002f5a:	f0 1f 00 16 	mcall	80002fb0 <Phyuserinput_brdcst_func+0xe4>
80002f5e:	2f fd       	sub	sp,-4
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002f60:	ef 38 ff f9 	ld.ub	r8,r7[-7]
80002f64:	1a d8       	st.w	--sp,r8
80002f66:	49 5c       	lddpc	r12,80002fb8 <Phyuserinput_brdcst_func+0xec>
80002f68:	f0 1f 00 12 	mcall	80002fb0 <Phyuserinput_brdcst_func+0xe4>
80002f6c:	2f fd       	sub	sp,-4
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
80002f6e:	ef 18 ff fa 	ld.uh	r8,r7[-6]
80002f72:	1a d8       	st.w	--sp,r8
80002f74:	49 2c       	lddpc	r12,80002fbc <Phyuserinput_brdcst_func+0xf0>
80002f76:	f0 1f 00 0f 	mcall	80002fb0 <Phyuserinput_brdcst_func+0xe4>
80002f7a:	2f fd       	sub	sp,-4
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002f7c:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80002f80:	1a d8       	st.w	--sp,r8
80002f82:	49 0c       	lddpc	r12,80002fc0 <Phyuserinput_brdcst_func+0xf4>
80002f84:	f0 1f 00 0b 	mcall	80002fb0 <Phyuserinput_brdcst_func+0xe4>
80002f88:	2f fd       	sub	sp,-4
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002f8a:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80002f8e:	1a d8       	st.w	--sp,r8
80002f90:	48 dc       	lddpc	r12,80002fc4 <Phyuserinput_brdcst_func+0xf8>
80002f92:	f0 1f 00 08 	mcall	80002fb0 <Phyuserinput_brdcst_func+0xe4>
80002f96:	2f fd       	sub	sp,-4
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002f98:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002f9c:	1a d8       	st.w	--sp,r8
80002f9e:	48 bc       	lddpc	r12,80002fc8 <Phyuserinput_brdcst_func+0xfc>
80002fa0:	f0 1f 00 04 	mcall	80002fb0 <Phyuserinput_brdcst_func+0xe4>
80002fa4:	2f fd       	sub	sp,-4
	
	
	
	
	
}
80002fa6:	2f dd       	sub	sp,-12
80002fa8:	e3 cd 80 80 	ldm	sp++,r7,pc
80002fac:	80 00       	ld.sh	r0,r0[0x0]
80002fae:	24 30       	sub	r0,67
80002fb0:	80 00       	ld.sh	r0,r0[0x0]
80002fb2:	8d 90       	st.w	r6[0x24],r0
80002fb4:	80 00       	ld.sh	r0,r0[0x0]
80002fb6:	24 54       	sub	r4,69
80002fb8:	80 00       	ld.sh	r0,r0[0x0]
80002fba:	24 6c       	sub	r12,70
80002fbc:	80 00       	ld.sh	r0,r0[0x0]
80002fbe:	24 80       	sub	r0,72
80002fc0:	80 00       	ld.sh	r0,r0[0x0]
80002fc2:	24 94       	sub	r4,73
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	24 a8       	sub	r8,74
80002fc8:	80 00       	ld.sh	r0,r0[0x0]
80002fca:	24 c8       	sub	r8,76

80002fcc <ButtonConfig_brdcst_func>:


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002fcc:	eb cd 40 80 	pushm	r7,lr
80002fd0:	1a 97       	mov	r7,sp
80002fd2:	20 3d       	sub	sp,12
80002fd4:	ef 4c ff f4 	st.w	r7[-12],r12
	U8 Num_Button =0;
80002fd8:	30 08       	mov	r8,0
80002fda:	ef 68 ff fa 	st.b	r7[-6],r8
	U8 i = 0 ;
80002fde:	30 08       	mov	r8,0
80002fe0:	ef 68 ff fb 	st.b	r7[-5],r8
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002fe4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002fe8:	2f e8       	sub	r8,-2
80002fea:	ef 48 ff fc 	st.w	r7[-4],r8
	
	Num_Button = ptr->NumOfButtons;
80002fee:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ff2:	11 98       	ld.ub	r8,r8[0x1]
80002ff4:	ef 68 ff fa 	st.b	r7[-6],r8
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002ff8:	4f 0c       	lddpc	r12,800031b8 <ButtonConfig_brdcst_func+0x1ec>
80002ffa:	f0 1f 00 71 	mcall	800031bc <ButtonConfig_brdcst_func+0x1f0>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80002ffe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003002:	11 88       	ld.ub	r8,r8[0x0]
80003004:	1a d8       	st.w	--sp,r8
80003006:	4e fc       	lddpc	r12,800031c0 <ButtonConfig_brdcst_func+0x1f4>
80003008:	f0 1f 00 6d 	mcall	800031bc <ButtonConfig_brdcst_func+0x1f0>
8000300c:	2f fd       	sub	sp,-4
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
8000300e:	ef 38 ff fa 	ld.ub	r8,r7[-6]
80003012:	1a d8       	st.w	--sp,r8
80003014:	4e cc       	lddpc	r12,800031c4 <ButtonConfig_brdcst_func+0x1f8>
80003016:	f0 1f 00 6a 	mcall	800031bc <ButtonConfig_brdcst_func+0x1f0>
8000301a:	2f fd       	sub	sp,-4
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
8000301c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003020:	11 a8       	ld.ub	r8,r8[0x2]
80003022:	1a d8       	st.w	--sp,r8
80003024:	4e 9c       	lddpc	r12,800031c8 <ButtonConfig_brdcst_func+0x1fc>
80003026:	f0 1f 00 66 	mcall	800031bc <ButtonConfig_brdcst_func+0x1f0>
8000302a:	2f fd       	sub	sp,-4
	
	for (i; i<Num_Button; i++)
8000302c:	cb a8       	rjmp	800031a0 <ButtonConfig_brdcst_func+0x1d4>
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
8000302e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003032:	ee fa ff fc 	ld.w	r10,r7[-4]
80003036:	12 98       	mov	r8,r9
80003038:	a3 68       	lsl	r8,0x2
8000303a:	12 08       	add	r8,r9
8000303c:	a1 78       	lsl	r8,0x1
8000303e:	f4 08 00 08 	add	r8,r10,r8
80003042:	2f d8       	sub	r8,-3
80003044:	11 88       	ld.ub	r8,r8[0x0]
80003046:	f0 0a 15 08 	lsl	r10,r8,0x8
8000304a:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000304e:	ee fb ff fc 	ld.w	r11,r7[-4]
80003052:	12 98       	mov	r8,r9
80003054:	a3 68       	lsl	r8,0x2
80003056:	12 08       	add	r8,r9
80003058:	a1 78       	lsl	r8,0x1
8000305a:	f6 08 00 08 	add	r8,r11,r8
8000305e:	2f c8       	sub	r8,-4
80003060:	11 88       	ld.ub	r8,r8[0x0]
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80003062:	f5 e8 10 09 	or	r9,r10,r8
80003066:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000306a:	1a d9       	st.w	--sp,r9
8000306c:	1a d8       	st.w	--sp,r8
8000306e:	4d 8c       	lddpc	r12,800031cc <ButtonConfig_brdcst_func+0x200>
80003070:	f0 1f 00 53 	mcall	800031bc <ButtonConfig_brdcst_func+0x1f0>
80003074:	2f ed       	sub	sp,-8
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
80003076:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000307a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000307e:	12 98       	mov	r8,r9
80003080:	a3 68       	lsl	r8,0x2
80003082:	12 08       	add	r8,r9
80003084:	a1 78       	lsl	r8,0x1
80003086:	f4 08 00 08 	add	r8,r10,r8
8000308a:	2f b8       	sub	r8,-5
8000308c:	11 88       	ld.ub	r8,r8[0x0]
8000308e:	f0 0a 15 08 	lsl	r10,r8,0x8
80003092:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003096:	ee fb ff fc 	ld.w	r11,r7[-4]
8000309a:	12 98       	mov	r8,r9
8000309c:	a3 68       	lsl	r8,0x2
8000309e:	12 08       	add	r8,r9
800030a0:	a1 78       	lsl	r8,0x1
800030a2:	f6 08 00 08 	add	r8,r11,r8
800030a6:	2f a8       	sub	r8,-6
800030a8:	11 88       	ld.ub	r8,r8[0x0]
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800030aa:	f5 e8 10 09 	or	r9,r10,r8
800030ae:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800030b2:	1a d9       	st.w	--sp,r9
800030b4:	1a d8       	st.w	--sp,r8
800030b6:	4c 7c       	lddpc	r12,800031d0 <ButtonConfig_brdcst_func+0x204>
800030b8:	f0 1f 00 41 	mcall	800031bc <ButtonConfig_brdcst_func+0x1f0>
800030bc:	2f ed       	sub	sp,-8
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
800030be:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030c2:	ee fa ff fc 	ld.w	r10,r7[-4]
800030c6:	12 98       	mov	r8,r9
800030c8:	a3 68       	lsl	r8,0x2
800030ca:	12 08       	add	r8,r9
800030cc:	a1 78       	lsl	r8,0x1
800030ce:	f4 08 00 08 	add	r8,r10,r8
800030d2:	2f 98       	sub	r8,-7
800030d4:	11 88       	ld.ub	r8,r8[0x0]
800030d6:	f0 0a 15 08 	lsl	r10,r8,0x8
800030da:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030de:	ee fb ff fc 	ld.w	r11,r7[-4]
800030e2:	12 98       	mov	r8,r9
800030e4:	a3 68       	lsl	r8,0x2
800030e6:	12 08       	add	r8,r9
800030e8:	a1 78       	lsl	r8,0x1
800030ea:	f6 08 00 08 	add	r8,r11,r8
800030ee:	2f 88       	sub	r8,-8
800030f0:	11 88       	ld.ub	r8,r8[0x0]
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800030f2:	f5 e8 10 09 	or	r9,r10,r8
800030f6:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800030fa:	1a d9       	st.w	--sp,r9
800030fc:	1a d8       	st.w	--sp,r8
800030fe:	4b 6c       	lddpc	r12,800031d4 <ButtonConfig_brdcst_func+0x208>
80003100:	f0 1f 00 2f 	mcall	800031bc <ButtonConfig_brdcst_func+0x1f0>
80003104:	2f ed       	sub	sp,-8
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
80003106:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000310a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000310e:	12 98       	mov	r8,r9
80003110:	a3 68       	lsl	r8,0x2
80003112:	12 08       	add	r8,r9
80003114:	a1 78       	lsl	r8,0x1
80003116:	f4 08 00 08 	add	r8,r10,r8
8000311a:	2f 78       	sub	r8,-9
8000311c:	11 88       	ld.ub	r8,r8[0x0]
8000311e:	f0 0a 15 08 	lsl	r10,r8,0x8
80003122:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003126:	ee fb ff fc 	ld.w	r11,r7[-4]
8000312a:	12 98       	mov	r8,r9
8000312c:	a3 68       	lsl	r8,0x2
8000312e:	12 08       	add	r8,r9
80003130:	a1 78       	lsl	r8,0x1
80003132:	f6 08 00 08 	add	r8,r11,r8
80003136:	2f 68       	sub	r8,-10
80003138:	11 88       	ld.ub	r8,r8[0x0]
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000313a:	f5 e8 10 09 	or	r9,r10,r8
8000313e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80003142:	1a d9       	st.w	--sp,r9
80003144:	1a d8       	st.w	--sp,r8
80003146:	4a 5c       	lddpc	r12,800031d8 <ButtonConfig_brdcst_func+0x20c>
80003148:	f0 1f 00 1d 	mcall	800031bc <ButtonConfig_brdcst_func+0x1f0>
8000314c:	2f ed       	sub	sp,-8
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved2[0]<<8) | (ptr->ButtonInfo[i].Reserved2[1]));
8000314e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003152:	ee fa ff fc 	ld.w	r10,r7[-4]
80003156:	12 98       	mov	r8,r9
80003158:	a3 68       	lsl	r8,0x2
8000315a:	12 08       	add	r8,r9
8000315c:	a1 78       	lsl	r8,0x1
8000315e:	f4 08 00 08 	add	r8,r10,r8
80003162:	2f 58       	sub	r8,-11
80003164:	11 88       	ld.ub	r8,r8[0x0]
80003166:	f0 0a 15 08 	lsl	r10,r8,0x8
8000316a:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000316e:	ee fb ff fc 	ld.w	r11,r7[-4]
80003172:	12 98       	mov	r8,r9
80003174:	a3 68       	lsl	r8,0x2
80003176:	12 08       	add	r8,r9
80003178:	a1 78       	lsl	r8,0x1
8000317a:	f6 08 00 08 	add	r8,r11,r8
8000317e:	2f 48       	sub	r8,-12
80003180:	11 88       	ld.ub	r8,r8[0x0]
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80003182:	f5 e8 10 09 	or	r9,r10,r8
80003186:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000318a:	1a d9       	st.w	--sp,r9
8000318c:	1a d8       	st.w	--sp,r8
8000318e:	49 4c       	lddpc	r12,800031dc <ButtonConfig_brdcst_func+0x210>
80003190:	f0 1f 00 0b 	mcall	800031bc <ButtonConfig_brdcst_func+0x1f0>
80003194:	2f ed       	sub	sp,-8
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80003196:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000319a:	2f f8       	sub	r8,-1
8000319c:	ef 68 ff fb 	st.b	r7[-5],r8
800031a0:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800031a4:	ef 38 ff fa 	ld.ub	r8,r7[-6]
800031a8:	f0 09 18 00 	cp.b	r9,r8
800031ac:	fe 93 ff 41 	brlo	8000302e <ButtonConfig_brdcst_func+0x62>
		
	}
	

	
}
800031b0:	2f dd       	sub	sp,-12
800031b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800031b6:	00 00       	add	r0,r0
800031b8:	80 00       	ld.sh	r0,r0[0x0]
800031ba:	24 e8       	sub	r8,78
800031bc:	80 00       	ld.sh	r0,r0[0x0]
800031be:	8d 90       	st.w	r6[0x24],r0
800031c0:	80 00       	ld.sh	r0,r0[0x0]
800031c2:	24 00       	sub	r0,64
800031c4:	80 00       	ld.sh	r0,r0[0x0]
800031c6:	25 08       	sub	r8,80
800031c8:	80 00       	ld.sh	r0,r0[0x0]
800031ca:	25 20       	sub	r0,82
800031cc:	80 00       	ld.sh	r0,r0[0x0]
800031ce:	25 40       	sub	r0,84
800031d0:	80 00       	ld.sh	r0,r0[0x0]
800031d2:	25 68       	sub	r8,86
800031d4:	80 00       	ld.sh	r0,r0[0x0]
800031d6:	25 90       	sub	r0,89
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	25 b4       	sub	r4,91
800031dc:	80 00       	ld.sh	r0,r0[0x0]
800031de:	25 dc       	sub	r12,93

800031e0 <SingleDetection_brdcst_func>:


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800031e0:	eb cd 40 80 	pushm	r7,lr
800031e4:	1a 97       	mov	r7,sp
800031e6:	20 1d       	sub	sp,4
800031e8:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == 0x11)
800031ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031f0:	11 a9       	ld.ub	r9,r8[0x2]
800031f2:	31 18       	mov	r8,17
800031f4:	f0 09 18 00 	cp.b	r9,r8
800031f8:	c0 41       	brne	80003200 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800031fa:	48 4c       	lddpc	r12,80003208 <SingleDetection_brdcst_func+0x28>
800031fc:	f0 1f 00 04 	mcall	8000320c <SingleDetection_brdcst_func+0x2c>
		//log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
	}
	

	//;
}
80003200:	2f fd       	sub	sp,-4
80003202:	e3 cd 80 80 	ldm	sp++,r7,pc
80003206:	00 00       	add	r0,r0
80003208:	80 00       	ld.sh	r0,r0[0x0]
8000320a:	26 00       	sub	r0,96
8000320c:	80 00       	ld.sh	r0,r0[0x0]
8000320e:	8d 90       	st.w	r6[0x24],r0

80003210 <EnOB_reply_func>:



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80003210:	eb cd 40 80 	pushm	r7,lr
80003214:	1a 97       	mov	r7,sp
80003216:	20 1d       	sub	sp,4
80003218:	ef 4c ff fc 	st.w	r7[-4],r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000321c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003220:	11 a8       	ld.ub	r8,r8[0x2]
80003222:	58 08       	cp.w	r8,0
80003224:	c1 e1       	brne	80003260 <EnOB_reply_func+0x50>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80003226:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000322a:	11 b9       	ld.ub	r9,r8[0x3]
8000322c:	30 18       	mov	r8,1
8000322e:	f0 09 18 00 	cp.b	r9,r8
80003232:	c0 51       	brne	8000323c <EnOB_reply_func+0x2c>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80003234:	49 2c       	lddpc	r12,8000327c <EnOB_reply_func+0x6c>
80003236:	f0 1f 00 13 	mcall	80003280 <EnOB_reply_func+0x70>
8000323a:	c1 e8       	rjmp	80003276 <EnOB_reply_func+0x66>
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000323c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003240:	11 b8       	ld.ub	r8,r8[0x3]
80003242:	58 08       	cp.w	r8,0
80003244:	c0 51       	brne	8000324e <EnOB_reply_func+0x3e>
		{
			log("\n\r En_OB_Exit OK \n\r");
80003246:	49 0c       	lddpc	r12,80003284 <EnOB_reply_func+0x74>
80003248:	f0 1f 00 0e 	mcall	80003280 <EnOB_reply_func+0x70>
8000324c:	c1 58       	rjmp	80003276 <EnOB_reply_func+0x66>
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000324e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003252:	11 b8       	ld.ub	r8,r8[0x3]
80003254:	1a d8       	st.w	--sp,r8
80003256:	48 dc       	lddpc	r12,80003288 <EnOB_reply_func+0x78>
80003258:	f0 1f 00 0a 	mcall	80003280 <EnOB_reply_func+0x70>
8000325c:	2f fd       	sub	sp,-4
8000325e:	c0 c8       	rjmp	80003276 <EnOB_reply_func+0x66>
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80003260:	48 bc       	lddpc	r12,8000328c <EnOB_reply_func+0x7c>
80003262:	f0 1f 00 08 	mcall	80003280 <EnOB_reply_func+0x70>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80003266:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000326a:	11 a8       	ld.ub	r8,r8[0x2]
8000326c:	1a d8       	st.w	--sp,r8
8000326e:	48 9c       	lddpc	r12,80003290 <EnOB_reply_func+0x80>
80003270:	f0 1f 00 04 	mcall	80003280 <EnOB_reply_func+0x70>
80003274:	2f fd       	sub	sp,-4
		
	}
	
	
}
80003276:	2f fd       	sub	sp,-4
80003278:	e3 cd 80 80 	ldm	sp++,r7,pc
8000327c:	80 00       	ld.sh	r0,r0[0x0]
8000327e:	26 14       	sub	r4,97
80003280:	80 00       	ld.sh	r0,r0[0x0]
80003282:	8d 90       	st.w	r6[0x24],r0
80003284:	80 00       	ld.sh	r0,r0[0x0]
80003286:	26 2c       	sub	r12,98
80003288:	80 00       	ld.sh	r0,r0[0x0]
8000328a:	26 40       	sub	r0,100
8000328c:	80 00       	ld.sh	r0,r0[0x0]
8000328e:	26 58       	sub	r8,101
80003290:	80 00       	ld.sh	r0,r0[0x0]
80003292:	26 74       	sub	r4,103

80003294 <EnOB_brdcst_func>:

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80003294:	eb cd 40 80 	pushm	r7,lr
80003298:	1a 97       	mov	r7,sp
8000329a:	20 1d       	sub	sp,4
8000329c:	ef 4c ff fc 	st.w	r7[-4],r12
	
	
	log("\n\r En_OB Broadcast \n\r");
800032a0:	48 3c       	lddpc	r12,800032ac <EnOB_brdcst_func+0x18>
800032a2:	f0 1f 00 04 	mcall	800032b0 <EnOB_brdcst_func+0x1c>
}
800032a6:	2f fd       	sub	sp,-4
800032a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800032ac:	80 00       	ld.sh	r0,r0[0x0]
800032ae:	26 8c       	sub	r12,104
800032b0:	80 00       	ld.sh	r0,r0[0x0]
800032b2:	8d 90       	st.w	r6[0x24],r0

800032b4 <FD_request_func>:



void FD_request_func(xcmp_fragment_t * xcmp)
{
800032b4:	eb cd 40 80 	pushm	r7,lr
800032b8:	1a 97       	mov	r7,sp
800032ba:	20 1d       	sub	sp,4
800032bc:	ef 4c ff fc 	st.w	r7[-4],r12
	
	log("\n\r Forward Data Request \n\r");
800032c0:	48 3c       	lddpc	r12,800032cc <FD_request_func+0x18>
800032c2:	f0 1f 00 04 	mcall	800032d0 <FD_request_func+0x1c>
	
	
}
800032c6:	2f fd       	sub	sp,-4
800032c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800032cc:	80 00       	ld.sh	r0,r0[0x0]
800032ce:	26 a4       	sub	r4,106
800032d0:	80 00       	ld.sh	r0,r0[0x0]
800032d2:	8d 90       	st.w	r6[0x24],r0

800032d4 <FD_reply_func>:

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800032d4:	eb cd 40 80 	pushm	r7,lr
800032d8:	1a 97       	mov	r7,sp
800032da:	20 1d       	sub	sp,4
800032dc:	ef 4c ff fc 	st.w	r7[-4],r12
	
	log("\n\r Forward Data Reply \n\r");
800032e0:	48 3c       	lddpc	r12,800032ec <FD_reply_func+0x18>
800032e2:	f0 1f 00 04 	mcall	800032f0 <FD_reply_func+0x1c>
	
	
}
800032e6:	2f fd       	sub	sp,-4
800032e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800032ec:	80 00       	ld.sh	r0,r0[0x0]
800032ee:	26 c0       	sub	r0,108
800032f0:	80 00       	ld.sh	r0,r0[0x0]
800032f2:	8d 90       	st.w	r6[0x24],r0

800032f4 <FD_brdcst_func>:

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800032f4:	eb cd 40 80 	pushm	r7,lr
800032f8:	1a 97       	mov	r7,sp
800032fa:	20 1d       	sub	sp,4
800032fc:	ef 4c ff fc 	st.w	r7[-4],r12
	
	
	log("\n\r Forward Data Broadcast \n\r");
80003300:	48 3c       	lddpc	r12,8000330c <FD_brdcst_func+0x18>
80003302:	f0 1f 00 04 	mcall	80003310 <FD_brdcst_func+0x1c>
	
}
80003306:	2f fd       	sub	sp,-4
80003308:	e3 cd 80 80 	ldm	sp++,r7,pc
8000330c:	80 00       	ld.sh	r0,r0[0x0]
8000330e:	26 dc       	sub	r12,109
80003310:	80 00       	ld.sh	r0,r0[0x0]
80003312:	8d 90       	st.w	r6[0x24],r0

80003314 <app_init>:
														
		
};

void app_init(void)
{	
80003314:	eb cd 40 80 	pushm	r7,lr
80003318:	1a 97       	mov	r7,sp
	//app_payload_rx_procPCM
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
8000331a:	48 eb       	lddpc	r11,80003350 <app_init+0x3c>
8000331c:	48 ec       	lddpc	r12,80003354 <app_init+0x40>
8000331e:	f0 1f 00 0f 	mcall	80003358 <app_init+0x44>
	xcmp_register_app_list(the_app_list);
80003322:	48 fc       	lddpc	r12,8000335c <app_init+0x48>
80003324:	f0 1f 00 0f 	mcall	80003360 <app_init+0x4c>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80003328:	48 fb       	lddpc	r11,80003364 <app_init+0x50>
8000332a:	30 08       	mov	r8,0
8000332c:	1a d8       	st.w	--sp,r8
8000332e:	30 08       	mov	r8,0
80003330:	1a d8       	st.w	--sp,r8
80003332:	30 08       	mov	r8,0
80003334:	1a d8       	st.w	--sp,r8
80003336:	30 18       	mov	r8,1
80003338:	30 09       	mov	r9,0
8000333a:	e0 6a 01 80 	mov	r10,384
8000333e:	48 bc       	lddpc	r12,80003368 <app_init+0x54>
80003340:	f0 1f 00 0b 	mcall	8000336c <app_init+0x58>
80003344:	2f dd       	sub	sp,-12
80003346:	18 99       	mov	r9,r12
80003348:	48 a8       	lddpc	r8,80003370 <app_init+0x5c>
8000334a:	91 09       	st.w	r8[0x0],r9
	,  NULL
	,  1
	,  NULL );
	
	
}
8000334c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003350:	80 00       	ld.sh	r0,r0[0x0]
80003352:	34 88       	mov	r8,72
80003354:	80 00       	ld.sh	r0,r0[0x0]
80003356:	34 28       	mov	r8,66
80003358:	80 00       	ld.sh	r0,r0[0x0]
8000335a:	35 a4       	mov	r4,90
8000335c:	00 00       	add	r0,r0
8000335e:	00 08       	add	r8,r0
80003360:	80 00       	ld.sh	r0,r0[0x0]
80003362:	59 80       	cp.w	r0,24
80003364:	80 00       	ld.sh	r0,r0[0x0]
80003366:	26 fc       	sub	r12,111
80003368:	80 00       	ld.sh	r0,r0[0x0]
8000336a:	33 74       	mov	r4,55
8000336c:	80 00       	ld.sh	r0,r0[0x0]
8000336e:	7c 30       	ld.w	r0,lr[0xc]
80003370:	00 00       	add	r0,r0
80003372:	0a 54       	eor	r4,r5

80003374 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80003374:	eb cd 40 80 	pushm	r7,lr
80003378:	1a 97       	mov	r7,sp
8000337a:	20 3d       	sub	sp,12
8000337c:	ef 4c ff f4 	st.w	r7[-12],r12
	static int counter=0;
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
80003380:	e0 68 0f a0 	mov	r8,4000
80003384:	ef 48 ff f8 	st.w	r7[-8],r8
	U8 Burst_ID = 0;
80003388:	30 08       	mov	r8,0
8000338a:	ef 68 ff ff 	st.b	r7[-1],r8
	
	 xLastWakeTime = xTaskGetTickCount();
8000338e:	f0 1f 00 20 	mcall	8000340c <app_cfg+0x98>
80003392:	18 99       	mov	r9,r12
80003394:	49 f8       	lddpc	r8,80003410 <app_cfg+0x9c>
80003396:	91 09       	st.w	r8[0x0],r9
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
80003398:	49 f8       	lddpc	r8,80003414 <app_cfg+0xa0>
8000339a:	70 08       	ld.w	r8,r8[0x0]
8000339c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800033a0:	58 38       	cp.w	r8,3
800033a2:	c2 91       	brne	800033f4 <app_cfg+0x80>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800033a4:	f0 1f 00 1d 	mcall	80003418 <app_cfg+0xa4>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800033a8:	49 d8       	lddpc	r8,8000341c <app_cfg+0xa8>
800033aa:	70 08       	ld.w	r8,r8[0x0]
800033ac:	58 08       	cp.w	r8,0
800033ae:	c0 51       	brne	800033b8 <app_cfg+0x44>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800033b0:	49 b8       	lddpc	r8,8000341c <app_cfg+0xa8>
800033b2:	30 19       	mov	r9,1
800033b4:	91 09       	st.w	r8[0x0],r9
800033b6:	c1 f8       	rjmp	800033f4 <app_cfg+0x80>
				}
				else if(isAudioRouting == 1)
800033b8:	49 98       	lddpc	r8,8000341c <app_cfg+0xa8>
800033ba:	70 08       	ld.w	r8,r8[0x0]
800033bc:	58 18       	cp.w	r8,1
800033be:	c0 51       	brne	800033c8 <app_cfg+0x54>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800033c0:	49 78       	lddpc	r8,8000341c <app_cfg+0xa8>
800033c2:	30 29       	mov	r9,2
800033c4:	91 09       	st.w	r8[0x0],r9
800033c6:	c1 78       	rjmp	800033f4 <app_cfg+0x80>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800033c8:	49 58       	lddpc	r8,8000341c <app_cfg+0xa8>
800033ca:	70 08       	ld.w	r8,r8[0x0]
800033cc:	58 28       	cp.w	r8,2
800033ce:	c0 51       	brne	800033d8 <app_cfg+0x64>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800033d0:	49 38       	lddpc	r8,8000341c <app_cfg+0xa8>
800033d2:	30 39       	mov	r9,3
800033d4:	91 09       	st.w	r8[0x0],r9
800033d6:	c0 f8       	rjmp	800033f4 <app_cfg+0x80>
					
				}
				else if(isAudioRouting == 3)
800033d8:	49 18       	lddpc	r8,8000341c <app_cfg+0xa8>
800033da:	70 08       	ld.w	r8,r8[0x0]
800033dc:	58 38       	cp.w	r8,3
800033de:	c0 51       	brne	800033e8 <app_cfg+0x74>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800033e0:	48 f8       	lddpc	r8,8000341c <app_cfg+0xa8>
800033e2:	30 49       	mov	r9,4
800033e4:	91 09       	st.w	r8[0x0],r9
800033e6:	c0 78       	rjmp	800033f4 <app_cfg+0x80>
					
				}
				else
				{
					isAudioRouting++;
800033e8:	48 d8       	lddpc	r8,8000341c <app_cfg+0xa8>
800033ea:	70 08       	ld.w	r8,r8[0x0]
800033ec:	f0 c9 ff ff 	sub	r9,r8,-1
800033f0:	48 b8       	lddpc	r8,8000341c <app_cfg+0xa8>
800033f2:	91 09       	st.w	r8[0x0],r9
				//}
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		counter++;
800033f4:	48 b8       	lddpc	r8,80003420 <app_cfg+0xac>
800033f6:	70 08       	ld.w	r8,r8[0x0]
800033f8:	f0 c9 ff ff 	sub	r9,r8,-1
800033fc:	48 98       	lddpc	r8,80003420 <app_cfg+0xac>
800033fe:	91 09       	st.w	r8[0x0],r9
		//log("\n\r counter: %d \n\r", counter);
		//log("\n\r xLastWakeTime: %d \n\r", xLastWakeTime);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//1000ms
80003400:	e0 6b 07 d0 	mov	r11,2000
80003404:	48 3c       	lddpc	r12,80003410 <app_cfg+0x9c>
80003406:	f0 1f 00 08 	mcall	80003424 <app_cfg+0xb0>
	}
8000340a:	cc 7b       	rjmp	80003398 <app_cfg+0x24>
8000340c:	80 00       	ld.sh	r0,r0[0x0]
8000340e:	80 80       	ld.uh	r0,r0[0x0]
80003410:	00 00       	add	r0,r0
80003412:	0a 48       	or	r8,r5
80003414:	00 00       	add	r0,r0
80003416:	0d 74       	ld.ub	r4,--r6
80003418:	80 00       	ld.sh	r0,r0[0x0]
8000341a:	5a 4c       	cp.w	r12,-28
8000341c:	00 00       	add	r0,r0
8000341e:	0a 4c       	or	r12,r5
80003420:	00 00       	add	r0,r0
80003422:	0a 50       	eor	r0,r5
80003424:	80 00       	ld.sh	r0,r0[0x0]
80003426:	7d f8       	ld.w	r8,lr[0x7c]

80003428 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80003428:	eb cd 40 80 	pushm	r7,lr
8000342c:	1a 97       	mov	r7,sp
8000342e:	20 1d       	sub	sp,4
80003430:	ef 4c ff fc 	st.w	r7[-4],r12
	static  U8 times_counter = 0;
	
	times_counter++;
80003434:	48 f8       	lddpc	r8,80003470 <app_payload_rx_proc+0x48>
80003436:	11 88       	ld.ub	r8,r8[0x0]
80003438:	2f f8       	sub	r8,-1
8000343a:	5c 58       	castu.b	r8
8000343c:	48 d9       	lddpc	r9,80003470 <app_payload_rx_proc+0x48>
8000343e:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80003440:	48 c8       	lddpc	r8,80003470 <app_payload_rx_proc+0x48>
80003442:	11 89       	ld.ub	r9,r8[0x0]
80003444:	30 38       	mov	r8,3
80003446:	f0 09 18 00 	cp.b	r9,r8
8000344a:	c0 71       	brne	80003458 <app_payload_rx_proc+0x30>
	{
		times_counter = 0 ;
8000344c:	48 99       	lddpc	r9,80003470 <app_payload_rx_proc+0x48>
8000344e:	30 08       	mov	r8,0
80003450:	b2 88       	st.b	r9[0x0],r8
		log("\n\r w: \n\r");
80003452:	48 9c       	lddpc	r12,80003474 <app_payload_rx_proc+0x4c>
80003454:	f0 1f 00 09 	mcall	80003478 <app_payload_rx_proc+0x50>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//mic
80003458:	48 98       	lddpc	r8,8000347c <app_payload_rx_proc+0x54>
8000345a:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000345c:	48 98       	lddpc	r8,80003480 <app_payload_rx_proc+0x58>
8000345e:	70 08       	ld.w	r8,r8[0x0]
80003460:	ee fb ff fc 	ld.w	r11,r7[-4]
80003464:	10 9c       	mov	r12,r8
80003466:	f0 1f 00 08 	mcall	80003484 <app_payload_rx_proc+0x5c>

}
8000346a:	2f fd       	sub	sp,-4
8000346c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003470:	00 00       	add	r0,r0
80003472:	0a 44       	or	r4,r5
80003474:	80 00       	ld.sh	r0,r0[0x0]
80003476:	27 04       	sub	r4,112
80003478:	80 00       	ld.sh	r0,r0[0x0]
8000347a:	8d 90       	st.w	r6[0x24],r0
8000347c:	00 00       	add	r0,r0
8000347e:	0a 3a       	cp.w	r10,r5
80003480:	00 00       	add	r0,r0
80003482:	0a 6c       	and	r12,r5
80003484:	80 00       	ld.sh	r0,r0[0x0]
80003486:	53 20       	stdsp	sp[0xc8],r0

80003488 <app_payload_tx_proc>:


static void app_payload_tx_proc(void  * payload)
{
80003488:	eb cd 40 80 	pushm	r7,lr
8000348c:	1a 97       	mov	r7,sp
8000348e:	20 1d       	sub	sp,4
80003490:	ef 4c ff fc 	st.w	r7[-4],r12
  log("R");
80003494:	48 3c       	lddpc	r12,800034a0 <app_payload_tx_proc+0x18>
80003496:	f0 1f 00 04 	mcall	800034a4 <app_payload_tx_proc+0x1c>
  //
  //
  //set_payload_idle(payload);


}
8000349a:	2f fd       	sub	sp,-4
8000349c:	e3 cd 80 80 	ldm	sp++,r7,pc
800034a0:	80 00       	ld.sh	r0,r0[0x0]
800034a2:	27 10       	sub	r0,113
800034a4:	80 00       	ld.sh	r0,r0[0x0]
800034a6:	8d 90       	st.w	r6[0x24],r0

800034a8 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
800034a8:	eb cd 40 80 	pushm	r7,lr
800034ac:	1a 97       	mov	r7,sp
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
800034ae:	48 58       	lddpc	r8,800034c0 <vApplicationIdleHook+0x18>
800034b0:	70 08       	ld.w	r8,r8[0x0]
800034b2:	f0 c9 ff ff 	sub	r9,r8,-1
800034b6:	48 38       	lddpc	r8,800034c0 <vApplicationIdleHook+0x18>
800034b8:	91 09       	st.w	r8[0x0],r9
	
}
800034ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800034be:	00 00       	add	r0,r0
800034c0:	00 00       	add	r0,r0
800034c2:	0a 40       	or	r0,r5

800034c4 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800034c4:	eb cd 40 80 	pushm	r7,lr
800034c8:	1a 97       	mov	r7,sp
800034ca:	20 2d       	sub	sp,8
800034cc:	18 98       	mov	r8,r12
800034ce:	ef 68 ff f8 	st.b	r7[-8],r8
	U8 Burst_ID = 0;
800034d2:	30 08       	mov	r8,0
800034d4:	ef 68 ff ff 	st.b	r7[-1],r8
	
	switch(vf_sn)
800034d8:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800034dc:	20 18       	sub	r8,1
800034de:	59 18       	cp.w	r8,17
800034e0:	e0 8b 00 23 	brhi	80003526 <CalculateBurst+0x62>
800034e4:	49 59       	lddpc	r9,80003538 <CalculateBurst+0x74>
800034e6:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
	{
		case 0x01:
		case 0x02:
		case 0x03:
		
			Burst_ID = 0x0A;
800034ea:	30 a8       	mov	r8,10
800034ec:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_A;
800034f0:	30 48       	mov	r8,4
800034f2:	c1 e8       	rjmp	8000352e <CalculateBurst+0x6a>
		
		case 0x04:
		case 0x05:
		case 0x06:
		
			Burst_ID = 0x0B;
800034f4:	30 b8       	mov	r8,11
800034f6:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_B;
800034fa:	30 58       	mov	r8,5
800034fc:	c1 98       	rjmp	8000352e <CalculateBurst+0x6a>
		
		case 0x07:
		case 0x08:
		case 0x09:
		
			Burst_ID = 0x0C;
800034fe:	30 c8       	mov	r8,12
80003500:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_C;
80003504:	30 68       	mov	r8,6
80003506:	c1 48       	rjmp	8000352e <CalculateBurst+0x6a>
		
		case 0x0A:
		case 0x0B:
		case 0x0C:
		
			Burst_ID = 0x0D;
80003508:	30 d8       	mov	r8,13
8000350a:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_D;
8000350e:	30 78       	mov	r8,7
80003510:	c0 f8       	rjmp	8000352e <CalculateBurst+0x6a>
		
		case 0x0D:
		case 0x0E:
		case 0x0F:
		
			Burst_ID = 0x0E;
80003512:	30 e8       	mov	r8,14
80003514:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_E;
80003518:	30 88       	mov	r8,8
8000351a:	c0 a8       	rjmp	8000352e <CalculateBurst+0x6a>
			
		case 0x10:
		case 0x11:
		case 0x12:
		
				Burst_ID = 0x0F;
8000351c:	30 f8       	mov	r8,15
8000351e:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_F;     
80003522:	30 98       	mov	r8,9
80003524:	c0 58       	rjmp	8000352e <CalculateBurst+0x6a>
		
		default:
		
			Burst_ID = 0x00;
80003526:	30 08       	mov	r8,0
80003528:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICE_WATING;
8000352c:	30 08       	mov	r8,0
		
	}
	
}
8000352e:	10 9c       	mov	r12,r8
80003530:	2f ed       	sub	sp,-8
80003532:	e3 cd 80 80 	ldm	sp++,r7,pc
80003536:	00 00       	add	r0,r0
80003538:	80 00       	ld.sh	r0,r0[0x0]
8000353a:	f0 08       	*unknown*
8000353c:	50 41       	stdsp	sp[0x10],r1
8000353e:	59 4c       	cp.w	r12,20
80003540:	4f 41       	lddpc	r1,80003710 <phy_init+0xcc>
80003542:	44 5f       	lddsp	pc,sp[0x114]
80003544:	52 58       	stdsp	sp[0x94],r8
	...

80003548 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80003548:	eb cd 40 80 	pushm	r7,lr
8000354c:	1a 97       	mov	r7,sp
8000354e:	20 2d       	sub	sp,8
80003550:	ef 4c ff f8 	st.w	r7[-8],r12
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80003554:	49 08       	lddpc	r8,80003594 <payload_rx_process+0x4c>
80003556:	70 08       	ld.w	r8,r8[0x0]
80003558:	58 08       	cp.w	r8,0
8000355a:	c0 a1       	brne	8000356e <payload_rx_process+0x26>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000355c:	30 4b       	mov	r11,4
8000355e:	30 5c       	mov	r12,5
80003560:	f0 1f 00 0e 	mcall	80003598 <payload_rx_process+0x50>
80003564:	18 99       	mov	r9,r12
80003566:	48 c8       	lddpc	r8,80003594 <payload_rx_process+0x4c>
80003568:	91 09       	st.w	r8[0x0],r9
8000356a:	c0 28       	rjmp	8000356e <payload_rx_process+0x26>
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
		}
	
	}
8000356c:	d7 03       	nop
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000356e:	48 a8       	lddpc	r8,80003594 <payload_rx_process+0x4c>
80003570:	70 08       	ld.w	r8,r8[0x0]
80003572:	ee cb 00 04 	sub	r11,r7,4
80003576:	30 09       	mov	r9,0
80003578:	3f fa       	mov	r10,-1
8000357a:	10 9c       	mov	r12,r8
8000357c:	f0 1f 00 08 	mcall	8000359c <payload_rx_process+0x54>
80003580:	18 98       	mov	r8,r12
80003582:	58 18       	cp.w	r8,1
80003584:	cf 41       	brne	8000356c <payload_rx_process+0x24>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003586:	48 78       	lddpc	r8,800035a0 <payload_rx_process+0x58>
80003588:	70 08       	ld.w	r8,r8[0x0]
8000358a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000358e:	12 9c       	mov	r12,r9
80003590:	5d 18       	icall	r8
		}
	
	}
80003592:	ce eb       	rjmp	8000356e <payload_rx_process+0x26>
80003594:	00 00       	add	r0,r0
80003596:	0a 74       	tst	r4,r5
80003598:	80 00       	ld.sh	r0,r0[0x0]
8000359a:	73 c0       	ld.w	r0,r9[0x70]
8000359c:	80 00       	ld.sh	r0,r0[0x0]
8000359e:	76 e4       	ld.w	r4,r11[0x38]
800035a0:	00 00       	add	r0,r0
800035a2:	0a 58       	eor	r8,r5

800035a4 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800035a4:	eb cd 40 80 	pushm	r7,lr
800035a8:	1a 97       	mov	r7,sp
800035aa:	20 2d       	sub	sp,8
800035ac:	ef 4c ff fc 	st.w	r7[-4],r12
800035b0:	ef 4b ff f8 	st.w	r7[-8],r11
	payload_rx_exec = payload_rx_func;
800035b4:	48 d8       	lddpc	r8,800035e8 <payload_init+0x44>
800035b6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800035ba:	91 09       	st.w	r8[0x0],r9
	payload_tx_exec = payload_tx_func;
800035bc:	48 c8       	lddpc	r8,800035ec <payload_init+0x48>
800035be:	ee f9 ff f8 	ld.w	r9,r7[-8]
800035c2:	91 09       	st.w	r8[0x0],r9
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800035c4:	48 bb       	lddpc	r11,800035f0 <payload_init+0x4c>
800035c6:	30 08       	mov	r8,0
800035c8:	1a d8       	st.w	--sp,r8
800035ca:	30 08       	mov	r8,0
800035cc:	1a d8       	st.w	--sp,r8
800035ce:	30 08       	mov	r8,0
800035d0:	1a d8       	st.w	--sp,r8
800035d2:	30 28       	mov	r8,2
800035d4:	30 09       	mov	r9,0
800035d6:	e0 6a 04 00 	mov	r10,1024
800035da:	48 7c       	lddpc	r12,800035f4 <payload_init+0x50>
800035dc:	f0 1f 00 07 	mcall	800035f8 <payload_init+0x54>
800035e0:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
800035e2:	2f ed       	sub	sp,-8
800035e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800035e8:	00 00       	add	r0,r0
800035ea:	0a 58       	eor	r8,r5
800035ec:	00 00       	add	r0,r0
800035ee:	0a 5c       	eor	r12,r5
800035f0:	80 00       	ld.sh	r0,r0[0x0]
800035f2:	35 3c       	mov	r12,83
800035f4:	80 00       	ld.sh	r0,r0[0x0]
800035f6:	35 48       	mov	r8,84
800035f8:	80 00       	ld.sh	r0,r0[0x0]
800035fa:	7c 30       	ld.w	r0,lr[0xc]
800035fc:	6d 6d       	ld.w	sp,r6[0x58]
800035fe:	00 00       	add	r0,r0
80003600:	0a 0d       	add	sp,r5
80003602:	20 78       	sub	r8,7
80003604:	78 78       	ld.w	r8,r12[0x1c]
80003606:	78 78       	ld.w	r8,r12[0x1c]
80003608:	5f 51       	srlt	r1
8000360a:	51 5f       	stdsp	sp[0x54],pc
8000360c:	78 78       	ld.w	r8,r12[0x1c]
8000360e:	78 78       	ld.w	r8,r12[0x1c]
80003610:	78 20       	ld.w	r0,r12[0x8]
80003612:	0a 0d       	add	sp,r5
80003614:	00 00       	add	r0,r0
80003616:	00 00       	add	r0,r0
80003618:	0a 0d       	add	sp,r5
8000361a:	20 52       	sub	r2,5
8000361c:	61 64       	ld.w	r4,r0[0x58]
8000361e:	69 6f       	ld.w	pc,r4[0x58]
80003620:	20 49       	sub	r9,4
80003622:	6e 74       	ld.w	r4,r7[0x1c]
80003624:	65 72       	ld.w	r2,r2[0x5c]
80003626:	6e 61       	ld.w	r1,r7[0x18]
80003628:	6c 20       	ld.w	r0,r6[0x8]
8000362a:	70 61       	ld.w	r1,r8[0x18]
8000362c:	72 61       	ld.w	r1,r9[0x18]
8000362e:	6d 65       	ld.w	r5,r6[0x58]
80003630:	74 65       	ld.w	r5,r10[0x18]
80003632:	72 20       	ld.w	r0,r9[0x8]
80003634:	6c 65       	ld.w	r5,r6[0x18]
80003636:	6e 67       	ld.w	r7,r7[0x18]
80003638:	74 68       	ld.w	r8,r10[0x18]
8000363a:	20 65       	sub	r5,6
8000363c:	72 72       	ld.w	r2,r9[0x1c]
8000363e:	6f 72       	ld.w	r2,r7[0x5c]
80003640:	20 0a       	sub	r10,0
80003642:	0d 00       	ld.w	r0,r6++

80003644 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80003644:	eb cd 40 80 	pushm	r7,lr
80003648:	1a 97       	mov	r7,sp
8000364a:	20 4d       	sub	sp,16
    /*initialize the SSC*/
    ssc_init();
8000364c:	f0 1f 00 34 	mcall	8000371c <phy_init+0xd8>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80003650:	4b 4b       	lddpc	r11,80003720 <phy_init+0xdc>
80003652:	4b 5c       	lddpc	r12,80003724 <phy_init+0xe0>
80003654:	f0 1f 00 35 	mcall	80003728 <phy_init+0xe4>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80003658:	30 4b       	mov	r11,4
8000365a:	31 ec       	mov	r12,30
8000365c:	f0 1f 00 34 	mcall	8000372c <phy_init+0xe8>
80003660:	18 99       	mov	r9,r12
80003662:	4b 48       	lddpc	r8,80003730 <phy_init+0xec>
80003664:	91 09       	st.w	r8[0x0],r9
	phy_fragment_t * xnl_ptr = NULL;
80003666:	30 08       	mov	r8,0
80003668:	ef 48 ff f0 	st.w	r7[-16],r8
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000366c:	30 08       	mov	r8,0
8000366e:	ef 48 ff f8 	st.w	r7[-8],r8
80003672:	c1 28       	rjmp	80003696 <phy_init+0x52>
	{
		set_xnl_idle(&xnl_store[i]);
80003674:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003678:	f0 09 15 08 	lsl	r9,r8,0x8
8000367c:	4a e8       	lddpc	r8,80003734 <phy_init+0xf0>
8000367e:	10 09       	add	r9,r8
80003680:	4a c8       	lddpc	r8,80003730 <phy_init+0xec>
80003682:	70 08       	ld.w	r8,r8[0x0]
80003684:	12 9b       	mov	r11,r9
80003686:	10 9c       	mov	r12,r8
80003688:	f0 1f 00 2c 	mcall	80003738 <phy_init+0xf4>
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000368c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003690:	2f f8       	sub	r8,-1
80003692:	ef 48 ff f8 	st.w	r7[-8],r8
80003696:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000369a:	59 d8       	cp.w	r8,29
8000369c:	fe 9a ff ec 	brle	80003674 <phy_init+0x30>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800036a0:	30 4b       	mov	r11,4
800036a2:	31 4c       	mov	r12,20
800036a4:	f0 1f 00 22 	mcall	8000372c <phy_init+0xe8>
800036a8:	18 99       	mov	r9,r12
800036aa:	4a 58       	lddpc	r8,8000373c <phy_init+0xf8>
800036ac:	91 09       	st.w	r8[0x0],r9
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800036ae:	30 4b       	mov	r11,4
800036b0:	30 ac       	mov	r12,10
800036b2:	f0 1f 00 1f 	mcall	8000372c <phy_init+0xe8>
800036b6:	18 99       	mov	r9,r12
800036b8:	4a 28       	lddpc	r8,80003740 <phy_init+0xfc>
800036ba:	91 09       	st.w	r8[0x0],r9
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800036bc:	30 4b       	mov	r11,4
800036be:	30 ac       	mov	r12,10
800036c0:	f0 1f 00 1b 	mcall	8000372c <phy_init+0xe8>
800036c4:	18 99       	mov	r9,r12
800036c6:	4a 08       	lddpc	r8,80003744 <phy_init+0x100>
800036c8:	91 09       	st.w	r8[0x0],r9
	U8 * payload_ptr = NULL;
800036ca:	30 08       	mov	r8,0
800036cc:	ef 48 ff f4 	st.w	r7[-12],r8
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800036d0:	30 08       	mov	r8,0
800036d2:	ef 48 ff fc 	st.w	r7[-4],r8
800036d6:	c1 28       	rjmp	800036fa <phy_init+0xb6>
	{
		set_payload_idle(payload_store[i]);
800036d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800036dc:	f0 09 15 09 	lsl	r9,r8,0x9
800036e0:	49 a8       	lddpc	r8,80003748 <phy_init+0x104>
800036e2:	10 09       	add	r9,r8
800036e4:	49 88       	lddpc	r8,80003744 <phy_init+0x100>
800036e6:	70 08       	ld.w	r8,r8[0x0]
800036e8:	12 9b       	mov	r11,r9
800036ea:	10 9c       	mov	r12,r8
800036ec:	f0 1f 00 13 	mcall	80003738 <phy_init+0xf4>
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800036f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800036f4:	2f f8       	sub	r8,-1
800036f6:	ef 48 ff fc 	st.w	r7[-4],r8
800036fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800036fe:	58 98       	cp.w	r8,9
80003700:	fe 9a ff ec 	brle	800036d8 <phy_init+0x94>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80003704:	e0 6b 01 00 	mov	r11,256
80003708:	30 5c       	mov	r12,5
8000370a:	f0 1f 00 09 	mcall	8000372c <phy_init+0xe8>
8000370e:	18 99       	mov	r9,r12
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80003710:	48 f8       	lddpc	r8,8000374c <phy_init+0x108>
80003712:	91 09       	st.w	r8[0x0],r9
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80003714:	2f cd       	sub	sp,-16
80003716:	e3 cd 80 80 	ldm	sp++,r7,pc
8000371a:	00 00       	add	r0,r0
8000371c:	80 00       	ld.sh	r0,r0[0x0]
8000371e:	55 90       	stdsp	sp[0x164],r0
80003720:	80 00       	ld.sh	r0,r0[0x0]
80003722:	38 5c       	mov	r12,-123
80003724:	80 00       	ld.sh	r0,r0[0x0]
80003726:	38 9c       	mov	r12,-119
80003728:	80 00       	ld.sh	r0,r0[0x0]
8000372a:	56 10       	stdsp	sp[0x184],r0
8000372c:	80 00       	ld.sh	r0,r0[0x0]
8000372e:	73 c0       	ld.w	r0,r9[0x70]
80003730:	00 00       	add	r0,r0
80003732:	0a 60       	and	r0,r5
80003734:	00 00       	add	r0,r0
80003736:	22 9a       	sub	r10,41
80003738:	80 00       	ld.sh	r0,r0[0x0]
8000373a:	53 20       	stdsp	sp[0xc8],r0
8000373c:	00 00       	add	r0,r0
8000373e:	0a 64       	and	r4,r5
80003740:	00 00       	add	r0,r0
80003742:	0a 68       	and	r8,r5
80003744:	00 00       	add	r0,r0
80003746:	0a 6c       	and	r12,r5
80003748:	00 00       	add	r0,r0
8000374a:	0e 9a       	mov	r10,r7
8000374c:	00 00       	add	r0,r0
8000374e:	0a 70       	tst	r0,r5

80003750 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003750:	eb cd 40 80 	pushm	r7,lr
80003754:	1a 97       	mov	r7,sp
80003756:	20 2d       	sub	sp,8
80003758:	ef 4c ff f8 	st.w	r7[-8],r12
    Bool res = FALSE;
8000375c:	30 08       	mov	r8,0
8000375e:	ef 68 ff fd 	st.b	r7[-3],r8
	
	U16 phy_ctrl = phy->xnl_fragment.phy_header.phy_control;
80003762:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003766:	90 08       	ld.sh	r8,r8[0x0]
80003768:	ef 58 ff fe 	st.h	r7[-2],r8
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
8000376c:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80003770:	e2 18 f0 00 	andl	r8,0xf000,COH
80003774:	e0 48 40 00 	cp.w	r8,16384
80003778:	c1 51       	brne	800037a2 <phy_tx+0x52>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
8000377a:	49 b8       	lddpc	r8,800037e4 <phy_tx+0x94>
8000377c:	70 08       	ld.w	r8,r8[0x0]
8000377e:	58 08       	cp.w	r8,0
80003780:	c2 f0       	breq	800037de <phy_tx+0x8e>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003782:	49 98       	lddpc	r8,800037e4 <phy_tx+0x94>
80003784:	70 08       	ld.w	r8,r8[0x0]
80003786:	ee cb 00 08 	sub	r11,r7,8
8000378a:	30 09       	mov	r9,0
8000378c:	30 0a       	mov	r10,0
8000378e:	10 9c       	mov	r12,r8
80003790:	f0 1f 00 16 	mcall	800037e8 <phy_tx+0x98>
80003794:	18 98       	mov	r8,r12
80003796:	58 18       	cp.w	r8,1
80003798:	c2 31       	brne	800037de <phy_tx+0x8e>
			{
				res = TRUE;
8000379a:	30 18       	mov	r8,1
8000379c:	ef 68 ff fd 	st.b	r7[-3],r8
800037a0:	c1 f8       	rjmp	800037de <phy_tx+0x8e>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800037a2:	ef 18 ff fe 	ld.uh	r8,r7[-2]
800037a6:	e2 18 f0 00 	andl	r8,0xf000,COH
800037aa:	e0 48 10 00 	cp.w	r8,4096
800037ae:	c1 60       	breq	800037da <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
800037b0:	ef 18 ff fe 	ld.uh	r8,r7[-2]
800037b4:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800037b8:	e0 48 20 00 	cp.w	r8,8192
800037bc:	c0 f0       	breq	800037da <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
800037be:	ef 18 ff fe 	ld.uh	r8,r7[-2]
800037c2:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800037c6:	e0 48 50 00 	cp.w	r8,20480
800037ca:	c0 80       	breq	800037da <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
800037cc:	ef 18 ff fe 	ld.uh	r8,r7[-2]
800037d0:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800037d4:	e0 48 60 00 	cp.w	r8,24576
800037d8:	c0 31       	brne	800037de <phy_tx+0x8e>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
800037da:	48 58       	lddpc	r8,800037ec <phy_tx+0x9c>
800037dc:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
800037de:	2f ed       	sub	sp,-8
800037e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800037e4:	00 00       	add	r0,r0
800037e6:	0a 64       	and	r4,r5
800037e8:	80 00       	ld.sh	r0,r0[0x0]
800037ea:	74 d8       	ld.w	r8,r10[0x34]
800037ec:	00 00       	add	r0,r0
800037ee:	0a 70       	tst	r0,r5

800037f0 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800037f0:	eb cd 40 80 	pushm	r7,lr
800037f4:	1a 97       	mov	r7,sp
800037f6:	20 3d       	sub	sp,12
800037f8:	ef 4c ff f4 	st.w	r7[-12],r12
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800037fc:	30 08       	mov	r8,0
800037fe:	ef 48 ff f8 	st.w	r7[-8],r8
	
	//phy_fragment_t * xx = pvPortMalloc(sizeof(phy_fragment_t));
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
80003802:	30 08       	mov	r8,0
80003804:	ef 68 ff fd 	st.b	r7[-3],r8
	
	if(NULL == phy_ptr)
80003808:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000380c:	58 08       	cp.w	r8,0
8000380e:	c1 e0       	breq	8000384a <phy_rx+0x5a>
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003810:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003814:	90 08       	ld.sh	r8,r8[0x0]
80003816:	ef 58 ff fe 	st.h	r7[-2],r8

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
8000381a:	ef 18 ff fe 	ld.uh	r8,r7[-2]
8000381e:	e2 18 f0 00 	andl	r8,0xf000,COH
80003822:	e0 48 40 00 	cp.w	r8,16384
80003826:	c1 31       	brne	8000384c <phy_rx+0x5c>
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003828:	48 b8       	lddpc	r8,80003854 <phy_rx+0x64>
8000382a:	70 08       	ld.w	r8,r8[0x0]
8000382c:	ee ca 00 08 	sub	r10,r7,8
80003830:	ee cb 00 0c 	sub	r11,r7,12
80003834:	30 09       	mov	r9,0
80003836:	10 9c       	mov	r12,r8
80003838:	f0 1f 00 08 	mcall	80003858 <phy_rx+0x68>
8000383c:	18 98       	mov	r8,r12
8000383e:	58 18       	cp.w	r8,1
80003840:	c0 61       	brne	8000384c <phy_rx+0x5c>
			///*  */
			//if (xHigherPriorityTaskWoken == pdTRUE)
			//{
				//taskYIELD();
			//}
			res = TRUE;
80003842:	30 18       	mov	r8,1
80003844:	ef 68 ff fd 	st.b	r7[-3],r8
80003848:	c0 28       	rjmp	8000384c <phy_rx+0x5c>
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
	{
		return;
8000384a:	d7 03       	nop
		}	

    }
		
 
}
8000384c:	2f dd       	sub	sp,-12
8000384e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003852:	00 00       	add	r0,r0
80003854:	00 00       	add	r0,r0
80003856:	0a 68       	and	r8,r5
80003858:	80 00       	ld.sh	r0,r0[0x0]
8000385a:	76 40       	ld.w	r0,r11[0x10]

8000385c <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
8000385c:	eb cd 40 80 	pushm	r7,lr
80003860:	1a 97       	mov	r7,sp
80003862:	20 1d       	sub	sp,4
80003864:	ef 4c ff fc 	st.w	r7[-4],r12
    if(NULL != phy_xnl_frame_tx)
80003868:	48 a8       	lddpc	r8,80003890 <phy_tx_func+0x34>
8000386a:	70 08       	ld.w	r8,r8[0x0]
8000386c:	58 08       	cp.w	r8,0
8000386e:	c0 70       	breq	8000387c <phy_tx_func+0x20>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003870:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003874:	2f c8       	sub	r8,-4
80003876:	10 9c       	mov	r12,r8
80003878:	f0 1f 00 07 	mcall	80003894 <phy_tx_func+0x38>
    {
		//
		//if (ENABLE == PLAYBACK_ENABLE)
		{
			/*send ssc data in payload(media) frame*/
			phy_payload_tx(&(((ssc_fragment_t * )ssc)->payload_channel));	
8000387c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003880:	2f 88       	sub	r8,-8
80003882:	10 9c       	mov	r12,r8
80003884:	f0 1f 00 05 	mcall	80003898 <phy_tx_func+0x3c>
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80003888:	2f fd       	sub	sp,-4
8000388a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000388e:	00 00       	add	r0,r0
80003890:	00 00       	add	r0,r0
80003892:	0a 64       	and	r4,r5
80003894:	80 00       	ld.sh	r0,r0[0x0]
80003896:	38 dc       	mov	r12,-115
80003898:	80 00       	ld.sh	r0,r0[0x0]
8000389a:	3d 44       	mov	r4,-44

8000389c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
8000389c:	eb cd 40 80 	pushm	r7,lr
800038a0:	1a 97       	mov	r7,sp
800038a2:	20 1d       	sub	sp,4
800038a4:	ef 4c ff fc 	st.w	r7[-4],r12
		
	if(NULL != phy_xnl_frame_rx)
800038a8:	48 a8       	lddpc	r8,800038d0 <phy_rx_func+0x34>
800038aa:	70 08       	ld.w	r8,r8[0x0]
800038ac:	58 08       	cp.w	r8,0
800038ae:	c0 70       	breq	800038bc <phy_rx_func+0x20>
	{
		/*receive ssc data in xnl frame*/
		phy_xnl_rx(&(((ssc_fragment_t * )ssc)->xnl_channel));
800038b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038b4:	2f c8       	sub	r8,-4
800038b6:	10 9c       	mov	r12,r8
800038b8:	f0 1f 00 07 	mcall	800038d4 <phy_rx_func+0x38>
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800038bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800038c0:	2f 88       	sub	r8,-8
800038c2:	10 9c       	mov	r12,r8
800038c4:	f0 1f 00 05 	mcall	800038d8 <phy_rx_func+0x3c>
	}
	#endif /*end if*/
	
	
}
800038c8:	2f fd       	sub	sp,-4
800038ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800038ce:	00 00       	add	r0,r0
800038d0:	00 00       	add	r0,r0
800038d2:	0a 68       	and	r8,r5
800038d4:	80 00       	ld.sh	r0,r0[0x0]
800038d6:	3a 3c       	mov	r12,-93
800038d8:	80 00       	ld.sh	r0,r0[0x0]
800038da:	43 bc       	lddsp	r12,sp[0xec]

800038dc <phy_xnl_tx>:
Calls:   
    xQueueReceiveFromISR -- freertos
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
800038dc:	eb cd 40 80 	pushm	r7,lr
800038e0:	1a 97       	mov	r7,sp
800038e2:	20 2d       	sub	sp,8
800038e4:	ef 4c ff f8 	st.w	r7[-8],r12
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800038e8:	30 08       	mov	r8,0
800038ea:	ef 48 ff fc 	st.w	r7[-4],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800038ee:	4c e8       	lddpc	r8,80003a24 <phy_xnl_tx+0x148>
800038f0:	70 08       	ld.w	r8,r8[0x0]
800038f2:	58 18       	cp.w	r8,1
800038f4:	c3 a0       	breq	80003968 <phy_xnl_tx+0x8c>
800038f6:	c0 53       	brcs	80003900 <phy_xnl_tx+0x24>
800038f8:	58 28       	cp.w	r8,2
800038fa:	e0 80 00 88 	breq	80003a0a <phy_xnl_tx+0x12e>
800038fe:	c9 08       	rjmp	80003a1e <phy_xnl_tx+0x142>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003900:	4c a8       	lddpc	r8,80003a28 <phy_xnl_tx+0x14c>
80003902:	70 08       	ld.w	r8,r8[0x0]
80003904:	ee c9 00 04 	sub	r9,r7,4
80003908:	12 9a       	mov	r10,r9
8000390a:	4c 9b       	lddpc	r11,80003a2c <phy_xnl_tx+0x150>
8000390c:	10 9c       	mov	r12,r8
8000390e:	f0 1f 00 49 	mcall	80003a30 <phy_xnl_tx+0x154>
80003912:	18 98       	mov	r8,r12
80003914:	58 18       	cp.w	r8,1
80003916:	c2 11       	brne	80003958 <phy_xnl_tx+0x7c>
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
				     phy_ptr->xnl_fragment.phy_header.phy_control & 0x000000FF;
80003918:	4c 58       	lddpc	r8,80003a2c <phy_xnl_tx+0x150>
8000391a:	70 08       	ld.w	r8,r8[0x0]
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
8000391c:	90 08       	ld.sh	r8,r8[0x0]
8000391e:	5c 88       	casts.h	r8
80003920:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003924:	4c 49       	lddpc	r9,80003a34 <phy_xnl_tx+0x158>
80003926:	b2 08       	st.h	r9[0x0],r8
				/*
				Handle to first fragment. Assume index to a valid fragment block.
                Points to first hWord in fragment block.
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
80003928:	4c 18       	lddpc	r8,80003a2c <phy_xnl_tx+0x150>
8000392a:	70 08       	ld.w	r8,r8[0x0]
8000392c:	90 08       	ld.sh	r8,r8[0x0]
				
				/*
				Handle to first fragment. Assume index to a valid fragment block.
                Points to first hWord in fragment block.
				*/
				xnl_tx_channel->dword = 
8000392e:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003932:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003936:	91 09       	st.w	r8[0x0],r9
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003938:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000393c:	70 08       	ld.w	r8,r8[0x0]
8000393e:	10 99       	mov	r9,r8
80003940:	ea 19 ab cd 	orh	r9,0xabcd
80003944:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003948:	91 09       	st.w	r8[0x0],r9
				
				phy_tx_index = 1;
8000394a:	4b c9       	lddpc	r9,80003a38 <phy_xnl_tx+0x15c>
8000394c:	30 18       	mov	r8,1
8000394e:	b2 88       	st.b	r9[0x0],r8
				phy_tx_state = WRITE_NEXT_DWORD;	
80003950:	4b 58       	lddpc	r8,80003a24 <phy_xnl_tx+0x148>
80003952:	30 19       	mov	r9,1
80003954:	91 09       	st.w	r8[0x0],r9
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
80003956:	c6 48       	rjmp	80003a1e <phy_xnl_tx+0x142>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003958:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000395c:	e0 69 5a 5a 	mov	r9,23130
80003960:	ea 19 ab cd 	orh	r9,0xabcd
80003964:	91 09       	st.w	r8[0x0],r9
			}			
			break;
80003966:	c5 c8       	rjmp	80003a1e <phy_xnl_tx+0x142>
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003968:	4b 18       	lddpc	r8,80003a2c <phy_xnl_tx+0x150>
8000396a:	70 09       	ld.w	r9,r8[0x0]
8000396c:	4b 38       	lddpc	r8,80003a38 <phy_xnl_tx+0x15c>
8000396e:	11 88       	ld.ub	r8,r8[0x0]
80003970:	10 9a       	mov	r10,r8
80003972:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80003976:	5c 79       	castu.h	r9
80003978:	b1 69       	lsl	r9,0x10
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
8000397a:	12 9a       	mov	r10,r9
8000397c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003980:	93 0a       	st.w	r9[0x0],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003982:	2f f8       	sub	r8,-1
80003984:	5c 58       	castu.b	r8
80003986:	4a d9       	lddpc	r9,80003a38 <phy_xnl_tx+0x15c>
80003988:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000398a:	4a b8       	lddpc	r8,80003a34 <phy_xnl_tx+0x158>
8000398c:	90 08       	ld.sh	r8,r8[0x0]
8000398e:	20 28       	sub	r8,2
80003990:	5c 88       	casts.h	r8
80003992:	5c 88       	casts.h	r8
80003994:	4a 89       	lddpc	r9,80003a34 <phy_xnl_tx+0x158>
80003996:	b2 08       	st.h	r9[0x0],r8
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003998:	4a 78       	lddpc	r8,80003a34 <phy_xnl_tx+0x158>
8000399a:	90 09       	ld.sh	r9,r8[0x0]
8000399c:	30 08       	mov	r8,0
8000399e:	f0 09 19 00 	cp.h	r9,r8
800039a2:	e0 89 00 0f 	brgt	800039c0 <phy_xnl_tx+0xe4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
800039a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800039aa:	70 08       	ld.w	r8,r8[0x0]
800039ac:	10 99       	mov	r9,r8
800039ae:	e8 19 00 ba 	orl	r9,0xba
800039b2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800039b6:	91 09       	st.w	r8[0x0],r9
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
800039b8:	49 b8       	lddpc	r8,80003a24 <phy_xnl_tx+0x148>
800039ba:	30 09       	mov	r9,0
800039bc:	91 09       	st.w	r8[0x0],r9
				break;
800039be:	c3 08       	rjmp	80003a1e <phy_xnl_tx+0x142>
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
800039c0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800039c4:	70 0a       	ld.w	r10,r8[0x0]
800039c6:	49 a8       	lddpc	r8,80003a2c <phy_xnl_tx+0x150>
800039c8:	70 09       	ld.w	r9,r8[0x0]
800039ca:	49 c8       	lddpc	r8,80003a38 <phy_xnl_tx+0x15c>
800039cc:	11 88       	ld.ub	r8,r8[0x0]
800039ce:	10 9b       	mov	r11,r8
800039d0:	f2 0b 04 19 	ld.sh	r9,r9[r11<<0x1]
800039d4:	5c 79       	castu.h	r9
800039d6:	12 4a       	or	r10,r9
800039d8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800039dc:	93 0a       	st.w	r9[0x0],r10
800039de:	2f f8       	sub	r8,-1
800039e0:	5c 58       	castu.b	r8
800039e2:	49 69       	lddpc	r9,80003a38 <phy_xnl_tx+0x15c>
800039e4:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
800039e6:	49 48       	lddpc	r8,80003a34 <phy_xnl_tx+0x158>
800039e8:	90 08       	ld.sh	r8,r8[0x0]
800039ea:	20 28       	sub	r8,2
800039ec:	5c 88       	casts.h	r8
800039ee:	5c 88       	casts.h	r8
800039f0:	49 19       	lddpc	r9,80003a34 <phy_xnl_tx+0x158>
800039f2:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800039f4:	49 08       	lddpc	r8,80003a34 <phy_xnl_tx+0x158>
800039f6:	90 09       	ld.sh	r9,r8[0x0]
800039f8:	30 08       	mov	r8,0
800039fa:	f0 09 19 00 	cp.h	r9,r8
800039fe:	e0 89 00 0f 	brgt	80003a1c <phy_xnl_tx+0x140>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003a02:	48 98       	lddpc	r8,80003a24 <phy_xnl_tx+0x148>
80003a04:	30 29       	mov	r9,2
80003a06:	91 09       	st.w	r8[0x0],r9
			}
			break;
80003a08:	c0 b8       	rjmp	80003a1e <phy_xnl_tx+0x142>

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003a0a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a0e:	fc 19 00 ba 	movh	r9,0xba
80003a12:	91 09       	st.w	r8[0x0],r9
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003a14:	48 48       	lddpc	r8,80003a24 <phy_xnl_tx+0x148>
80003a16:	30 09       	mov	r9,0
80003a18:	91 09       	st.w	r8[0x0],r9
80003a1a:	c0 28       	rjmp	80003a1e <phy_xnl_tx+0x142>
			if (phy_tx_expexted_length <= 0)
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
			}
			break;
80003a1c:	d7 03       	nop
			/*This fragment finished.*/
			
		default:
			break;
	}
}
80003a1e:	2f ed       	sub	sp,-8
80003a20:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a24:	00 00       	add	r0,r0
80003a26:	0a c8       	st.b	r5++,r8
80003a28:	00 00       	add	r0,r0
80003a2a:	0a 64       	and	r4,r5
80003a2c:	00 00       	add	r0,r0
80003a2e:	0a cc       	st.b	r5++,r12
80003a30:	80 00       	ld.sh	r0,r0[0x0]
80003a32:	78 d0       	ld.w	r0,r12[0x34]
80003a34:	00 00       	add	r0,r0
80003a36:	0a d0       	st.w	--r5,r0
80003a38:	00 00       	add	r0,r0
80003a3a:	0a d2       	st.w	--r5,r2

80003a3c <phy_xnl_rx>:
Calls:   
    phy_rx
Called By: phy_rx_func
*/
static void phy_xnl_rx(xnl_channel_t * xnl_rx_channel)
{
80003a3c:	eb cd 40 80 	pushm	r7,lr
80003a40:	1a 97       	mov	r7,sp
80003a42:	20 3d       	sub	sp,12
80003a44:	ef 4c ff f4 	st.w	r7[-12],r12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003a48:	30 08       	mov	r8,0
80003a4a:	ef 48 ff f8 	st.w	r7[-8],r8
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003a4e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003a52:	70 08       	ld.w	r8,r8[0x0]
80003a54:	ef 48 ff fc 	st.w	r7[-4],r8

	phy_rx_count++;
80003a58:	fe f8 02 c4 	ld.w	r8,pc[708]
80003a5c:	70 08       	ld.w	r8,r8[0x0]
80003a5e:	f0 c9 ff ff 	sub	r9,r8,-1
80003a62:	fe f8 02 ba 	ld.w	r8,pc[698]
80003a66:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003a68:	fe f8 02 b8 	ld.w	r8,pc[696]
80003a6c:	70 08       	ld.w	r8,r8[0x0]
80003a6e:	58 18       	cp.w	r8,1
80003a70:	e0 80 00 ba 	breq	80003be4 <phy_xnl_rx+0x1a8>
80003a74:	c0 93       	brcs	80003a86 <phy_xnl_rx+0x4a>
80003a76:	58 28       	cp.w	r8,2
80003a78:	e0 80 00 81 	breq	80003b7a <phy_xnl_rx+0x13e>
80003a7c:	58 38       	cp.w	r8,3
80003a7e:	e0 80 01 24 	breq	80003cc6 <phy_xnl_rx+0x28a>
80003a82:	e0 8f 01 49 	bral	80003d14 <phy_xnl_rx+0x2d8>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003a86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a8a:	e0 69 5a 5a 	mov	r9,23130
80003a8e:	ea 19 ab cd 	orh	r9,0xabcd
80003a92:	12 38       	cp.w	r8,r9
80003a94:	e0 80 01 37 	breq	80003d02 <phy_xnl_rx+0x2c6>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003a98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a9c:	b1 88       	lsr	r8,0x10
80003a9e:	e0 48 ab cd 	cp.w	r8,43981
80003aa2:	e0 81 01 32 	brne	80003d06 <phy_xnl_rx+0x2ca>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003aa6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003aaa:	5c 88       	casts.h	r8
80003aac:	5c 88       	casts.h	r8
80003aae:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003ab2:	20 28       	sub	r8,2
80003ab4:	5c 88       	casts.h	r8
80003ab6:	5c 88       	casts.h	r8
80003ab8:	fe f9 02 6c 	ld.w	r9,pc[620]
80003abc:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003abe:	fe f8 02 66 	ld.w	r8,pc[614]
80003ac2:	90 09       	ld.sh	r9,r8[0x0]
80003ac4:	30 08       	mov	r8,0
80003ac6:	f0 09 19 00 	cp.h	r9,r8
80003aca:	e0 8a 01 20 	brle	80003d0a <phy_xnl_rx+0x2ce>
			{
				break;
			}
		
			phy_rx_length = 0;
80003ace:	fe f9 02 5a 	ld.w	r9,pc[602]
80003ad2:	30 08       	mov	r8,0
80003ad4:	b2 08       	st.h	r9[0x0],r8
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80003ad6:	fe f8 02 56 	ld.w	r8,pc[598]
80003ada:	70 08       	ld.w	r8,r8[0x0]
80003adc:	10 9c       	mov	r12,r8
80003ade:	f0 1f 00 95 	mcall	80003d30 <phy_xnl_rx+0x2f4>
80003ae2:	18 98       	mov	r8,r12
80003ae4:	10 99       	mov	r9,r8
80003ae6:	fe f8 02 4e 	ld.w	r8,pc[590]
80003aea:	91 09       	st.w	r8[0x0],r9
			if(NULL == phy_frame_ptr)
80003aec:	fe f8 02 48 	ld.w	r8,pc[584]
80003af0:	70 08       	ld.w	r8,r8[0x0]
80003af2:	58 08       	cp.w	r8,0
80003af4:	e0 80 01 0d 	breq	80003d0e <phy_xnl_rx+0x2d2>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003af8:	fe f8 02 3c 	ld.w	r8,pc[572]
80003afc:	70 0a       	ld.w	r10,r8[0x0]
80003afe:	fe f8 02 2a 	ld.w	r8,pc[554]
80003b02:	90 08       	ld.sh	r8,r8[0x0]
80003b04:	10 9b       	mov	r11,r8
80003b06:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003b0a:	5c 89       	casts.h	r9
80003b0c:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80003b10:	2f f8       	sub	r8,-1
80003b12:	5c 88       	casts.h	r8
80003b14:	fe f9 02 14 	ld.w	r9,pc[532]
80003b18:	b2 08       	st.h	r9[0x0],r8
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003b1a:	fe f8 02 1a 	ld.w	r8,pc[538]
80003b1e:	70 0a       	ld.w	r10,r8[0x0]
80003b20:	fe f8 02 08 	ld.w	r8,pc[520]
80003b24:	90 08       	ld.sh	r8,r8[0x0]
80003b26:	10 9b       	mov	r11,r8
80003b28:	4f d9       	lddpc	r9,80003d1c <phy_xnl_rx+0x2e0>
80003b2a:	72 09       	ld.w	r9,r9[0x0]
80003b2c:	5c 89       	casts.h	r9
80003b2e:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80003b32:	2f f8       	sub	r8,-1
80003b34:	5c 88       	casts.h	r8
80003b36:	4f d9       	lddpc	r9,80003d28 <phy_xnl_rx+0x2ec>
80003b38:	b2 08       	st.h	r9[0x0],r8
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003b3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b3e:	e2 18 0f 00 	andl	r8,0xf00,COH
80003b42:	e0 48 01 00 	cp.w	r8,256
80003b46:	c0 c0       	breq	80003b5e <phy_xnl_rx+0x122>
80003b48:	e0 8b 00 05 	brhi	80003b52 <phy_xnl_rx+0x116>
80003b4c:	58 08       	cp.w	r8,0
80003b4e:	c0 80       	breq	80003b5e <phy_xnl_rx+0x122>
80003b50:	c0 c8       	rjmp	80003b68 <phy_xnl_rx+0x12c>
80003b52:	e0 48 02 00 	cp.w	r8,512
80003b56:	c0 40       	breq	80003b5e <phy_xnl_rx+0x122>
80003b58:	e0 48 03 00 	cp.w	r8,768
80003b5c:	c0 61       	brne	80003b68 <phy_xnl_rx+0x12c>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003b5e:	4f 18       	lddpc	r8,80003d20 <phy_xnl_rx+0x2e4>
80003b60:	30 29       	mov	r9,2
80003b62:	91 09       	st.w	r8[0x0],r9
				break;
80003b64:	d7 03       	nop
				default:
					vPortFree(phy_frame_ptr);
					phy_frame_ptr = NULL;					
				break;
			}	
			break;
80003b66:	cd 78       	rjmp	80003d14 <phy_xnl_rx+0x2d8>
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
				break;
				default:
					vPortFree(phy_frame_ptr);
80003b68:	4f 38       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003b6a:	70 08       	ld.w	r8,r8[0x0]
80003b6c:	10 9c       	mov	r12,r8
80003b6e:	f0 1f 00 73 	mcall	80003d38 <phy_xnl_rx+0x2fc>
					phy_frame_ptr = NULL;					
80003b72:	4f 18       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003b74:	30 09       	mov	r9,0
80003b76:	91 09       	st.w	r8[0x0],r9
				break;
			}	
			break;
80003b78:	cc e8       	rjmp	80003d14 <phy_xnl_rx+0x2d8>
		Gets here on CSUM. Expect at least one hWord payload. Gets here once 
		on every fragment.*/	
		case WAITING_CHECK_SUM:
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
80003b7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b7e:	b1 88       	lsr	r8,0x10
80003b80:	5c 88       	casts.h	r8
80003b82:	4e f9       	lddpc	r9,80003d3c <phy_xnl_rx+0x300>
80003b84:	b2 08       	st.h	r9[0x0],r8
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003b86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b8a:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80003b8e:	4e c8       	lddpc	r8,80003d3c <phy_xnl_rx+0x300>
80003b90:	90 08       	ld.sh	r8,r8[0x0]
80003b92:	f2 08 00 08 	add	r8,r9,r8
80003b96:	5c 88       	casts.h	r8
80003b98:	4e 99       	lddpc	r9,80003d3c <phy_xnl_rx+0x300>
80003b9a:	b2 08       	st.h	r9[0x0],r8
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003b9c:	4e 68       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003b9e:	70 0a       	ld.w	r10,r8[0x0]
80003ba0:	4e 28       	lddpc	r8,80003d28 <phy_xnl_rx+0x2ec>
80003ba2:	90 08       	ld.sh	r8,r8[0x0]
80003ba4:	10 9b       	mov	r11,r8
80003ba6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003baa:	5c 89       	casts.h	r9
80003bac:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80003bb0:	2f f8       	sub	r8,-1
80003bb2:	5c 88       	casts.h	r8
80003bb4:	4d d9       	lddpc	r9,80003d28 <phy_xnl_rx+0x2ec>
80003bb6:	b2 08       	st.h	r9[0x0],r8
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003bb8:	4d b8       	lddpc	r8,80003d24 <phy_xnl_rx+0x2e8>
80003bba:	90 08       	ld.sh	r8,r8[0x0]
80003bbc:	20 28       	sub	r8,2
80003bbe:	5c 88       	casts.h	r8
80003bc0:	5c 88       	casts.h	r8
80003bc2:	4d 99       	lddpc	r9,80003d24 <phy_xnl_rx+0x2e8>
80003bc4:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003bc6:	4d 88       	lddpc	r8,80003d24 <phy_xnl_rx+0x2e8>
80003bc8:	90 09       	ld.sh	r9,r8[0x0]
80003bca:	30 08       	mov	r8,0
80003bcc:	f0 09 19 00 	cp.h	r9,r8
80003bd0:	e0 8a 00 06 	brle	80003bdc <phy_xnl_rx+0x1a0>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003bd4:	4d 38       	lddpc	r8,80003d20 <phy_xnl_rx+0x2e4>
80003bd6:	30 19       	mov	r9,1
80003bd8:	91 09       	st.w	r8[0x0],r9
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
			}			
		
			break;
80003bda:	c9 d8       	rjmp	80003d14 <phy_xnl_rx+0x2d8>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003bdc:	4d 18       	lddpc	r8,80003d20 <phy_xnl_rx+0x2e4>
80003bde:	30 39       	mov	r9,3
80003be0:	91 09       	st.w	r8[0x0],r9
			}			
		
			break;
80003be2:	c9 98       	rjmp	80003d14 <phy_xnl_rx+0x2d8>

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003be4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003be8:	b1 88       	lsr	r8,0x10
80003bea:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80003bee:	4d 48       	lddpc	r8,80003d3c <phy_xnl_rx+0x300>
80003bf0:	90 08       	ld.sh	r8,r8[0x0]
80003bf2:	f2 08 00 08 	add	r8,r9,r8
80003bf6:	5c 88       	casts.h	r8
80003bf8:	4d 19       	lddpc	r9,80003d3c <phy_xnl_rx+0x300>
80003bfa:	b2 08       	st.h	r9[0x0],r8
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003bfc:	4c e8       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003bfe:	70 0a       	ld.w	r10,r8[0x0]
80003c00:	4c a8       	lddpc	r8,80003d28 <phy_xnl_rx+0x2ec>
80003c02:	90 08       	ld.sh	r8,r8[0x0]
80003c04:	10 9b       	mov	r11,r8
												 (phy_dword & 0xFFFF0000) >> 16;
80003c06:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003c0a:	b1 89       	lsr	r9,0x10
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003c0c:	5c 89       	casts.h	r9
80003c0e:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80003c12:	2f f8       	sub	r8,-1
80003c14:	5c 88       	casts.h	r8
80003c16:	4c 59       	lddpc	r9,80003d28 <phy_xnl_rx+0x2ec>
80003c18:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003c1a:	4c 38       	lddpc	r8,80003d24 <phy_xnl_rx+0x2e8>
80003c1c:	90 08       	ld.sh	r8,r8[0x0]
80003c1e:	20 28       	sub	r8,2
80003c20:	5c 88       	casts.h	r8
80003c22:	5c 88       	casts.h	r8
80003c24:	4c 09       	lddpc	r9,80003d24 <phy_xnl_rx+0x2e8>
80003c26:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003c28:	4b f8       	lddpc	r8,80003d24 <phy_xnl_rx+0x2e8>
80003c2a:	90 09       	ld.sh	r9,r8[0x0]
80003c2c:	30 08       	mov	r8,0
80003c2e:	f0 09 19 00 	cp.h	r9,r8
80003c32:	e0 89 00 1f 	brgt	80003c70 <phy_xnl_rx+0x234>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003c36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c3a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80003c3e:	e0 48 00 ba 	cp.w	r8,186
80003c42:	c0 b1       	brne	80003c58 <phy_xnl_rx+0x21c>
					&& (phy_check_sum == 0))
80003c44:	4b e8       	lddpc	r8,80003d3c <phy_xnl_rx+0x300>
80003c46:	90 08       	ld.sh	r8,r8[0x0]
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003c48:	58 08       	cp.w	r8,0
80003c4a:	c0 71       	brne	80003c58 <phy_xnl_rx+0x21c>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003c4c:	4b a8       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003c4e:	70 08       	ld.w	r8,r8[0x0]
80003c50:	10 9c       	mov	r12,r8
80003c52:	f0 1f 00 3c 	mcall	80003d40 <phy_xnl_rx+0x304>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003c56:	c0 98       	rjmp	80003c68 <phy_xnl_rx+0x22c>
				{
					phy_rx(phy_frame_ptr);
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003c58:	4b 78       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003c5a:	70 08       	ld.w	r8,r8[0x0]
80003c5c:	10 9c       	mov	r12,r8
80003c5e:	f0 1f 00 37 	mcall	80003d38 <phy_xnl_rx+0x2fc>
					phy_frame_ptr = NULL;
80003c62:	4b 58       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003c64:	30 09       	mov	r9,0
80003c66:	91 09       	st.w	r8[0x0],r9
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003c68:	4a e8       	lddpc	r8,80003d20 <phy_xnl_rx+0x2e4>
80003c6a:	30 09       	mov	r9,0
80003c6c:	91 09       	st.w	r8[0x0],r9
				break;
80003c6e:	c5 38       	rjmp	80003d14 <phy_xnl_rx+0x2d8>
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003c70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c74:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80003c78:	4b 18       	lddpc	r8,80003d3c <phy_xnl_rx+0x300>
80003c7a:	90 08       	ld.sh	r8,r8[0x0]
80003c7c:	f2 08 00 08 	add	r8,r9,r8
80003c80:	5c 88       	casts.h	r8
80003c82:	4a f9       	lddpc	r9,80003d3c <phy_xnl_rx+0x300>
80003c84:	b2 08       	st.h	r9[0x0],r8
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003c86:	4a c8       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003c88:	70 0a       	ld.w	r10,r8[0x0]
80003c8a:	4a 88       	lddpc	r8,80003d28 <phy_xnl_rx+0x2ec>
80003c8c:	90 08       	ld.sh	r8,r8[0x0]
80003c8e:	10 9b       	mov	r11,r8
80003c90:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003c94:	5c 89       	casts.h	r9
80003c96:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80003c9a:	2f f8       	sub	r8,-1
80003c9c:	5c 88       	casts.h	r8
80003c9e:	4a 39       	lddpc	r9,80003d28 <phy_xnl_rx+0x2ec>
80003ca0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003ca2:	4a 18       	lddpc	r8,80003d24 <phy_xnl_rx+0x2e8>
80003ca4:	90 08       	ld.sh	r8,r8[0x0]
80003ca6:	20 28       	sub	r8,2
80003ca8:	5c 88       	casts.h	r8
80003caa:	5c 88       	casts.h	r8
80003cac:	49 e9       	lddpc	r9,80003d24 <phy_xnl_rx+0x2e8>
80003cae:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003cb0:	49 d8       	lddpc	r8,80003d24 <phy_xnl_rx+0x2e8>
80003cb2:	90 09       	ld.sh	r9,r8[0x0]
80003cb4:	30 08       	mov	r8,0
80003cb6:	f0 09 19 00 	cp.h	r9,r8
80003cba:	e0 89 00 2c 	brgt	80003d12 <phy_xnl_rx+0x2d6>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80003cbe:	49 98       	lddpc	r8,80003d20 <phy_xnl_rx+0x2e4>
80003cc0:	30 39       	mov	r9,3
80003cc2:	91 09       	st.w	r8[0x0],r9
			}/*else, next Word contains more payload.*/
			break;
80003cc4:	c2 88       	rjmp	80003d14 <phy_xnl_rx+0x2d8>

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003cc6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003cca:	e6 18 00 ff 	andh	r8,0xff,COH
80003cce:	fc 19 00 ba 	movh	r9,0xba
80003cd2:	12 38       	cp.w	r8,r9
80003cd4:	c0 b1       	brne	80003cea <phy_xnl_rx+0x2ae>
				&& (phy_check_sum == 0))/*Good checksum*/
80003cd6:	49 a8       	lddpc	r8,80003d3c <phy_xnl_rx+0x300>
80003cd8:	90 08       	ld.sh	r8,r8[0x0]
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003cda:	58 08       	cp.w	r8,0
80003cdc:	c0 71       	brne	80003cea <phy_xnl_rx+0x2ae>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003cde:	49 68       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003ce0:	70 08       	ld.w	r8,r8[0x0]
80003ce2:	10 9c       	mov	r12,r8
80003ce4:	f0 1f 00 17 	mcall	80003d40 <phy_xnl_rx+0x304>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003ce8:	c0 98       	rjmp	80003cfa <phy_xnl_rx+0x2be>
				phy_rx(phy_frame_ptr);

			}
			else
			{
				vPortFree(phy_frame_ptr);
80003cea:	49 38       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003cec:	70 08       	ld.w	r8,r8[0x0]
80003cee:	10 9c       	mov	r12,r8
80003cf0:	f0 1f 00 12 	mcall	80003d38 <phy_xnl_rx+0x2fc>
				phy_frame_ptr = NULL;
80003cf4:	49 08       	lddpc	r8,80003d34 <phy_xnl_rx+0x2f8>
80003cf6:	30 09       	mov	r9,0
80003cf8:	91 09       	st.w	r8[0x0],r9
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003cfa:	48 a8       	lddpc	r8,80003d20 <phy_xnl_rx+0x2e4>
80003cfc:	30 09       	mov	r9,0
80003cfe:	91 09       	st.w	r8[0x0],r9
80003d00:	c0 a8       	rjmp	80003d14 <phy_xnl_rx+0x2d8>
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
			{
				break;
80003d02:	d7 03       	nop
80003d04:	c0 88       	rjmp	80003d14 <phy_xnl_rx+0x2d8>
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
			{			
				break;
80003d06:	d7 03       	nop
80003d08:	c0 68       	rjmp	80003d14 <phy_xnl_rx+0x2d8>
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
			{
				break;
80003d0a:	d7 03       	nop
80003d0c:	c0 48       	rjmp	80003d14 <phy_xnl_rx+0x2d8>
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
			if(NULL == phy_frame_ptr)
			{
				break;
80003d0e:	d7 03       	nop
80003d10:	c0 28       	rjmp	80003d14 <phy_xnl_rx+0x2d8>
			if (phy_rx_expexted_length <= 0)
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
			}/*else, next Word contains more payload.*/
			break;
80003d12:	d7 03       	nop
			phy_rx_state = WAITING_FOR_HEADER;
			break;
		default:
		break;
	}/*End of phy_rx_state switch.*/
}
80003d14:	2f dd       	sub	sp,-12
80003d16:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d1a:	00 00       	add	r0,r0
80003d1c:	00 00       	add	r0,r0
80003d1e:	0a b4       	st.h	r5++,r4
80003d20:	00 00       	add	r0,r0
80003d22:	0a b8       	st.h	r5++,r8
80003d24:	00 00       	add	r0,r0
80003d26:	0a bc       	st.h	r5++,r12
80003d28:	00 00       	add	r0,r0
80003d2a:	0a be       	st.h	r5++,lr
80003d2c:	00 00       	add	r0,r0
80003d2e:	0a 60       	and	r0,r5
80003d30:	80 00       	ld.sh	r0,r0[0x0]
80003d32:	52 d8       	stdsp	sp[0xb4],r8
80003d34:	00 00       	add	r0,r0
80003d36:	0a c0       	st.b	r5++,r0
80003d38:	80 00       	ld.sh	r0,r0[0x0]
80003d3a:	73 88       	ld.w	r8,r9[0x60]
80003d3c:	00 00       	add	r0,r0
80003d3e:	0a c4       	st.b	r5++,r4
80003d40:	80 00       	ld.sh	r0,r0[0x0]
80003d42:	37 f0       	mov	r0,127

80003d44 <phy_payload_tx>:
Calls: 
Called By:phy_tx_func
*/

static void phy_payload_tx(payload_channel_t * payload_tx_channel)
{
80003d44:	eb cd 40 80 	pushm	r7,lr
80003d48:	1a 97       	mov	r7,sp
80003d4a:	20 1d       	sub	sp,4
80003d4c:	ef 4c ff fc 	st.w	r7[-4],r12
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80003d50:	fe f8 05 b8 	ld.w	r8,pc[1464]
80003d54:	11 89       	ld.ub	r9,r8[0x0]
80003d56:	30 18       	mov	r8,1
80003d58:	f0 09 18 00 	cp.b	r9,r8
80003d5c:	e0 81 02 c8 	brne	800042ec <phy_payload_tx+0x5a8>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80003d60:	fe f8 05 ac 	ld.w	r8,pc[1452]
80003d64:	70 08       	ld.w	r8,r8[0x0]
80003d66:	e0 48 05 af 	cp.w	r8,1455
80003d6a:	e0 8b 00 06 	brhi	80003d76 <phy_payload_tx+0x32>
80003d6e:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003d72:	70 08       	ld.w	r8,r8[0x0]
80003d74:	c0 28       	rjmp	80003d78 <phy_payload_tx+0x34>
80003d76:	30 08       	mov	r8,0
80003d78:	fe f9 05 94 	ld.w	r9,pc[1428]
80003d7c:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80003d7e:	fe f8 05 92 	ld.w	r8,pc[1426]
80003d82:	70 08       	ld.w	r8,r8[0x0]
80003d84:	58 68       	cp.w	r8,6
80003d86:	e0 8b 02 a4 	brhi	800042ce <phy_payload_tx+0x58a>
80003d8a:	fe f9 05 8a 	ld.w	r9,pc[1418]
80003d8e:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003d92:	fe f8 05 86 	ld.w	r8,pc[1414]
80003d96:	70 08       	ld.w	r8,r8[0x0]
80003d98:	58 08       	cp.w	r8,0
80003d9a:	c0 b0       	breq	80003db0 <phy_payload_tx+0x6c>
80003d9c:	fe f8 05 7c 	ld.w	r8,pc[1404]
80003da0:	70 08       	ld.w	r8,r8[0x0]
80003da2:	58 a8       	cp.w	r8,10
80003da4:	c0 60       	breq	80003db0 <phy_payload_tx+0x6c>
80003da6:	fe f8 05 72 	ld.w	r8,pc[1394]
80003daa:	70 08       	ld.w	r8,r8[0x0]
80003dac:	58 18       	cp.w	r8,1
80003dae:	c0 f1       	brne	80003dcc <phy_payload_tx+0x88>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003db0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003db4:	e0 69 5a 5a 	mov	r9,23130
80003db8:	ea 19 ab cd 	orh	r9,0xabcd
80003dbc:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003dbe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dc2:	30 09       	mov	r9,0
80003dc4:	91 19       	st.w	r8[0x4],r9
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003dc6:	d7 03       	nop
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
80003dc8:	e0 8f 02 9d 	bral	80004302 <phy_payload_tx+0x5be>
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003dcc:	fe f8 05 4c 	ld.w	r8,pc[1356]
80003dd0:	70 08       	ld.w	r8,r8[0x0]
80003dd2:	58 38       	cp.w	r8,3
80003dd4:	c0 f1       	brne	80003df2 <phy_payload_tx+0xae>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80003dd6:	fe f8 05 46 	ld.w	r8,pc[1350]
80003dda:	70 09       	ld.w	r9,r8[0x0]
80003ddc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003de0:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003de2:	fe f8 05 3a 	ld.w	r8,pc[1338]
80003de6:	70 19       	ld.w	r9,r8[0x4]
80003de8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003dec:	91 19       	st.w	r8[0x4],r9
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
80003dee:	e0 8f 02 8a 	bral	80004302 <phy_payload_tx+0x5be>
				else//
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//
80003df2:	fe f8 05 26 	ld.w	r8,pc[1318]
80003df6:	70 08       	ld.w	r8,r8[0x0]
80003df8:	58 28       	cp.w	r8,2
80003dfa:	c1 a1       	brne	80003e2e <phy_payload_tx+0xea>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80003dfc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e00:	e0 69 c0 32 	mov	r9,49202
80003e04:	ea 19 ab cd 	orh	r9,0xabcd
80003e08:	91 09       	st.w	r8[0x0],r9
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80003e0a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003e0e:	fe 78 84 7f 	mov	r8,-31617
80003e12:	b2 28       	st.h	r9[0x4],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80003e14:	fe f8 05 0c 	ld.w	r8,pc[1292]
80003e18:	90 08       	ld.sh	r8,r8[0x0]
80003e1a:	5c 88       	casts.h	r8
80003e1c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003e20:	b2 38       	st.h	r9[0x6],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80003e22:	fe f8 04 ee 	ld.w	r8,pc[1262]
80003e26:	30 39       	mov	r9,3
80003e28:	91 09       	st.w	r8[0x0],r9
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
80003e2a:	e0 8f 02 6c 	bral	80004302 <phy_payload_tx+0x5be>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003e2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003e32:	e0 69 c0 0e 	mov	r9,49166
80003e36:	ea 19 ab cd 	orh	r9,0xabcd
80003e3a:	91 09       	st.w	r8[0x0],r9
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80003e3c:	fe f8 04 e8 	ld.w	r8,pc[1256]
80003e40:	90 08       	ld.sh	r8,r8[0x0]
80003e42:	5c 88       	casts.h	r8
80003e44:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003e48:	b2 28       	st.h	r9[0x4],r8
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80003e4a:	fe f8 04 da 	ld.w	r8,pc[1242]
80003e4e:	90 18       	ld.sh	r8,r8[0x2]
80003e50:	5c 88       	casts.h	r8
80003e52:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003e56:	b2 38       	st.h	r9[0x6],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80003e58:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003e5c:	30 19       	mov	r9,1
80003e5e:	91 09       	st.w	r8[0x0],r9
					}

				}
				
				break;
80003e60:	e0 8f 02 51 	bral	80004302 <phy_payload_tx+0x5be>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003e64:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003e68:	fe 78 88 f2 	mov	r8,-30478
80003e6c:	b2 08       	st.h	r9[0x0],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//
80003e6e:	fe f8 04 aa 	ld.w	r8,pc[1194]
80003e72:	70 08       	ld.w	r8,r8[0x0]
80003e74:	58 48       	cp.w	r8,4
80003e76:	c0 60       	breq	80003e82 <phy_payload_tx+0x13e>
80003e78:	c7 73       	brcs	80003f66 <phy_payload_tx+0x222>
80003e7a:	58 98       	cp.w	r8,9
80003e7c:	e0 8b 00 75 	brhi	80003f66 <phy_payload_tx+0x222>
80003e80:	c4 78       	rjmp	80003f0e <phy_payload_tx+0x1ca>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80003e82:	fe f8 04 a6 	ld.w	r8,pc[1190]
80003e86:	11 89       	ld.ub	r9,r8[0x0]
80003e88:	30 18       	mov	r8,1
80003e8a:	f0 09 18 00 	cp.b	r9,r8
80003e8e:	c1 41       	brne	80003eb6 <phy_payload_tx+0x172>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80003e90:	fe f8 04 9c 	ld.w	r8,pc[1180]
80003e94:	90 08       	ld.sh	r8,r8[0x0]
80003e96:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003e9a:	b2 18       	st.h	r9[0x2],r8
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80003e9c:	fe f8 04 90 	ld.w	r8,pc[1168]
80003ea0:	90 18       	ld.sh	r8,r8[0x2]
80003ea2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003ea6:	b2 28       	st.h	r9[0x4],r8
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80003ea8:	fe f8 04 84 	ld.w	r8,pc[1156]
80003eac:	90 28       	ld.sh	r8,r8[0x4]
80003eae:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003eb2:	b2 38       	st.h	r9[0x6],r8
80003eb4:	c2 88       	rjmp	80003f04 <phy_payload_tx+0x1c0>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003eb6:	fe f8 04 76 	ld.w	r8,pc[1142]
80003eba:	90 09       	ld.sh	r9,r8[0x0]
80003ebc:	fe f8 04 74 	ld.w	r8,pc[1140]
80003ec0:	90 08       	ld.sh	r8,r8[0x0]
80003ec2:	5c 88       	casts.h	r8
80003ec4:	f3 e8 20 08 	eor	r8,r9,r8
80003ec8:	5c 88       	casts.h	r8
80003eca:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003ece:	b2 18       	st.h	r9[0x2],r8
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003ed0:	fe f8 04 5c 	ld.w	r8,pc[1116]
80003ed4:	90 19       	ld.sh	r9,r8[0x2]
80003ed6:	fe f8 04 5a 	ld.w	r8,pc[1114]
80003eda:	90 18       	ld.sh	r8,r8[0x2]
80003edc:	5c 88       	casts.h	r8
80003ede:	f3 e8 20 08 	eor	r8,r9,r8
80003ee2:	5c 88       	casts.h	r8
80003ee4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003ee8:	b2 28       	st.h	r9[0x4],r8
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003eea:	fe f8 04 42 	ld.w	r8,pc[1090]
80003eee:	90 29       	ld.sh	r9,r8[0x4]
80003ef0:	fe f8 04 40 	ld.w	r8,pc[1088]
80003ef4:	90 28       	ld.sh	r8,r8[0x4]
80003ef6:	5c 88       	casts.h	r8
80003ef8:	f3 e8 20 08 	eor	r8,r9,r8
80003efc:	5c 88       	casts.h	r8
80003efe:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003f02:	b2 38       	st.h	r9[0x6],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80003f04:	fe f8 04 0c 	ld.w	r8,pc[1036]
80003f08:	30 29       	mov	r9,2
80003f0a:	91 09       	st.w	r8[0x0],r9
					
						break;
80003f0c:	c3 e8       	rjmp	80003f88 <phy_payload_tx+0x244>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80003f0e:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003f12:	90 09       	ld.sh	r9,r8[0x0]
80003f14:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003f18:	90 08       	ld.sh	r8,r8[0x0]
80003f1a:	5c 88       	casts.h	r8
80003f1c:	f3 e8 20 08 	eor	r8,r9,r8
80003f20:	5c 88       	casts.h	r8
80003f22:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003f26:	b2 18       	st.h	r9[0x2],r8
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80003f28:	fe f8 04 04 	ld.w	r8,pc[1028]
80003f2c:	90 19       	ld.sh	r9,r8[0x2]
80003f2e:	fe f8 04 02 	ld.w	r8,pc[1026]
80003f32:	90 18       	ld.sh	r8,r8[0x2]
80003f34:	5c 88       	casts.h	r8
80003f36:	f3 e8 20 08 	eor	r8,r9,r8
80003f3a:	5c 88       	casts.h	r8
80003f3c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003f40:	b2 28       	st.h	r9[0x4],r8
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80003f42:	fe f8 03 ea 	ld.w	r8,pc[1002]
80003f46:	90 29       	ld.sh	r9,r8[0x4]
80003f48:	fe f8 03 e8 	ld.w	r8,pc[1000]
80003f4c:	90 28       	ld.sh	r8,r8[0x4]
80003f4e:	5c 88       	casts.h	r8
80003f50:	f3 e8 20 08 	eor	r8,r9,r8
80003f54:	5c 88       	casts.h	r8
80003f56:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003f5a:	b2 38       	st.h	r9[0x6],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80003f5c:	fe f8 03 b4 	ld.w	r8,pc[948]
80003f60:	30 29       	mov	r9,2
80003f62:	91 09       	st.w	r8[0x0],r9
				
						break;
80003f64:	c1 28       	rjmp	80003f88 <phy_payload_tx+0x244>
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003f66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f6a:	e0 69 5a 5a 	mov	r9,23130
80003f6e:	ea 19 ab cd 	orh	r9,0xabcd
80003f72:	91 09       	st.w	r8[0x0],r9
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003f74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f78:	30 09       	mov	r9,0
80003f7a:	91 19       	st.w	r8[0x4],r9
							
							AMBEpayload_tx_state = AMBE_IDLE;
80003f7c:	fe f8 03 94 	ld.w	r8,pc[916]
80003f80:	30 09       	mov	r9,0
80003f82:	91 09       	st.w	r8[0x0],r9
				}
		
		
		
		
				break;
80003f84:	e0 8f 01 bf 	bral	80004302 <phy_payload_tx+0x5be>
80003f88:	e0 8f 01 bd 	bral	80004302 <phy_payload_tx+0x5be>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80003f8c:	fe f8 03 a4 	ld.w	r8,pc[932]
80003f90:	90 38       	ld.sh	r8,r8[0x6]
80003f92:	5c 88       	casts.h	r8
80003f94:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003f98:	b2 08       	st.h	r9[0x0],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//Pad_bits
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80003f9a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003f9e:	e0 68 00 ba 	mov	r8,186
80003fa2:	b2 18       	st.h	r9[0x2],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80003fa4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003fa8:	30 08       	mov	r8,0
80003faa:	b2 28       	st.h	r9[0x4],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003fac:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003fb0:	30 08       	mov	r8,0
80003fb2:	b2 38       	st.h	r9[0x6],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80003fb4:	fe f8 03 5c 	ld.w	r8,pc[860]
80003fb8:	30 09       	mov	r9,0
80003fba:	91 09       	st.w	r8[0x0],r9
				
				break;
80003fbc:	e0 8f 01 a3 	bral	80004302 <phy_payload_tx+0x5be>
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80003fc0:	fe f8 03 60 	ld.w	r8,pc[864]
80003fc4:	90 18       	ld.sh	r8,r8[0x2]
80003fc6:	5c 88       	casts.h	r8
80003fc8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003fcc:	b2 08       	st.h	r9[0x0],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80003fce:	fe f8 03 56 	ld.w	r8,pc[854]
80003fd2:	90 08       	ld.sh	r8,r8[0x0]
80003fd4:	5c 88       	casts.h	r8
80003fd6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003fda:	b2 18       	st.h	r9[0x2],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80003fdc:	fe f8 03 3c 	ld.w	r8,pc[828]
80003fe0:	70 08       	ld.w	r8,r8[0x0]
80003fe2:	58 48       	cp.w	r8,4
80003fe4:	c1 21       	brne	80004008 <phy_payload_tx+0x2c4>
80003fe6:	fe f8 03 42 	ld.w	r8,pc[834]
80003fea:	11 89       	ld.ub	r9,r8[0x0]
80003fec:	30 18       	mov	r8,1
80003fee:	f0 09 18 00 	cp.b	r9,r8
80003ff2:	c0 b1       	brne	80004008 <phy_payload_tx+0x2c4>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80003ff4:	fe f8 03 30 	ld.w	r8,pc[816]
80003ff8:	90 18       	ld.sh	r8,r8[0x2]
80003ffa:	5c 88       	casts.h	r8
80003ffc:	a9 a8       	sbr	r8,0x8
80003ffe:	5c 88       	casts.h	r8
80004000:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004004:	b2 28       	st.h	r9[0x4],r8
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80004006:	c0 88       	rjmp	80004016 <phy_payload_tx+0x2d2>
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80004008:	fe f8 03 1c 	ld.w	r8,pc[796]
8000400c:	90 18       	ld.sh	r8,r8[0x2]
8000400e:	5c 88       	casts.h	r8
80004010:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004014:	b2 28       	st.h	r9[0x4],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80004016:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000401a:	fe 78 9a 13 	mov	r8,-26093
8000401e:	b2 38       	st.h	r9[0x6],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80004020:	fe f8 02 f0 	ld.w	r8,pc[752]
80004024:	30 49       	mov	r9,4
80004026:	91 09       	st.w	r8[0x0],r9
					
				break;
80004028:	e0 8f 01 6d 	bral	80004302 <phy_payload_tx+0x5be>
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
8000402c:	fe f8 03 08 	ld.w	r8,pc[776]
80004030:	70 09       	ld.w	r9,r8[0x0]
80004032:	fe f8 03 06 	ld.w	r8,pc[774]
80004036:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000403a:	5c 88       	casts.h	r8
8000403c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004040:	b2 08       	st.h	r9[0x0],r8
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80004042:	fe f8 02 f2 	ld.w	r8,pc[754]
80004046:	70 08       	ld.w	r8,r8[0x0]
80004048:	f0 c9 ff ff 	sub	r9,r8,-1
8000404c:	fe f8 02 ec 	ld.w	r8,pc[748]
80004050:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80004054:	5c 88       	casts.h	r8
80004056:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000405a:	b2 18       	st.h	r9[0x2],r8
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
8000405c:	fe f8 02 d8 	ld.w	r8,pc[728]
80004060:	70 08       	ld.w	r8,r8[0x0]
80004062:	f0 c9 ff fe 	sub	r9,r8,-2
80004066:	fe f8 02 d2 	ld.w	r8,pc[722]
8000406a:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000406e:	5c 88       	casts.h	r8
80004070:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004074:	b2 28       	st.h	r9[0x4],r8
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80004076:	fe f8 02 be 	ld.w	r8,pc[702]
8000407a:	70 08       	ld.w	r8,r8[0x0]
8000407c:	f0 c9 ff fd 	sub	r9,r8,-3
80004080:	fe f8 02 b8 	ld.w	r8,pc[696]
80004084:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80004088:	5c 88       	casts.h	r8
8000408a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000408e:	b2 38       	st.h	r9[0x6],r8
						Soft_index +=4;
80004090:	fe f8 02 a4 	ld.w	r8,pc[676]
80004094:	70 08       	ld.w	r8,r8[0x0]
80004096:	f0 c9 ff fc 	sub	r9,r8,-4
8000409a:	fe f8 02 9a 	ld.w	r8,pc[666]
8000409e:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
800040a0:	fe f8 02 94 	ld.w	r8,pc[660]
800040a4:	70 08       	ld.w	r8,r8[0x0]
800040a6:	58 c8       	cp.w	r8,12
800040a8:	c0 71       	brne	800040b6 <phy_payload_tx+0x372>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
800040aa:	fe f8 02 66 	ld.w	r8,pc[614]
800040ae:	30 59       	mov	r9,5
800040b0:	91 09       	st.w	r8[0x0],r9
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
			
				break;	
800040b2:	e0 8f 01 28 	bral	80004302 <phy_payload_tx+0x5be>
							AMBEpayload_tx_state = AMBE_DE_THIRD;
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
800040b6:	fe f8 02 5a 	ld.w	r8,pc[602]
800040ba:	30 49       	mov	r9,4
800040bc:	91 09       	st.w	r8[0x0],r9
			
				break;	
800040be:	e0 8f 01 22 	bral	80004302 <phy_payload_tx+0x5be>
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
800040c2:	fe f8 02 72 	ld.w	r8,pc[626]
800040c6:	70 09       	ld.w	r9,r8[0x0]
800040c8:	fe f8 02 70 	ld.w	r8,pc[624]
800040cc:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800040d0:	5c 88       	casts.h	r8
800040d2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800040d6:	b2 08       	st.h	r9[0x0],r8
					Soft_index = 0 ;//
800040d8:	fe f8 02 5c 	ld.w	r8,pc[604]
800040dc:	30 09       	mov	r9,0
800040de:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 
					payload_tx_channel->word[1] = 0x8003;
800040e0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800040e4:	fe 78 80 03 	mov	r8,-32765
800040e8:	b2 18       	st.h	r9[0x2],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
800040ea:	ee f9 ff fc 	ld.w	r9,r7[-4]
800040ee:	fe 78 88 f3 	mov	r8,-30477
800040f2:	b2 28       	st.h	r9[0x4],r8
				
					switch (m_RxBurstType)//
800040f4:	fe f8 02 24 	ld.w	r8,pc[548]
800040f8:	70 08       	ld.w	r8,r8[0x0]
800040fa:	58 48       	cp.w	r8,4
800040fc:	c0 60       	breq	80004108 <phy_payload_tx+0x3c4>
800040fe:	c3 e3       	brcs	8000417a <phy_payload_tx+0x436>
80004100:	58 98       	cp.w	r8,9
80004102:	e0 8b 00 3c 	brhi	8000417a <phy_payload_tx+0x436>
80004106:	c2 98       	rjmp	80004158 <phy_payload_tx+0x414>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80004108:	fe f8 02 20 	ld.w	r8,pc[544]
8000410c:	11 89       	ld.ub	r9,r8[0x0]
8000410e:	30 18       	mov	r8,1
80004110:	f0 09 18 00 	cp.b	r9,r8
80004114:	c1 01       	brne	80004134 <phy_payload_tx+0x3f0>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80004116:	fe f8 02 1a 	ld.w	r8,pc[538]
8000411a:	90 08       	ld.sh	r8,r8[0x0]
8000411c:	5c 88       	casts.h	r8
8000411e:	fe f9 02 1e 	ld.w	r9,pc[542]
80004122:	b2 08       	st.h	r9[0x0],r8
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80004124:	fe f8 02 0c 	ld.w	r8,pc[524]
80004128:	90 08       	ld.sh	r8,r8[0x0]
8000412a:	5c 88       	casts.h	r8
8000412c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004130:	b2 38       	st.h	r9[0x6],r8
80004132:	c0 f8       	rjmp	80004150 <phy_payload_tx+0x40c>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80004134:	fe f8 02 08 	ld.w	r8,pc[520]
80004138:	90 08       	ld.sh	r8,r8[0x0]
8000413a:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000413e:	4f d8       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
80004140:	90 08       	ld.sh	r8,r8[0x0]
80004142:	5c 88       	casts.h	r8
80004144:	f3 e8 20 08 	eor	r8,r9,r8
80004148:	5c 88       	casts.h	r8
8000414a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000414e:	b2 38       	st.h	r9[0x6],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80004150:	4f 08       	lddpc	r8,80004310 <phy_payload_tx+0x5cc>
80004152:	30 69       	mov	r9,6
80004154:	91 09       	st.w	r8[0x0],r9
					
							break;
80004156:	c2 18       	rjmp	80004198 <phy_payload_tx+0x454>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80004158:	4f 98       	lddpc	r8,8000433c <phy_payload_tx+0x5f8>
8000415a:	90 08       	ld.sh	r8,r8[0x0]
8000415c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004160:	4f 48       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
80004162:	90 08       	ld.sh	r8,r8[0x0]
80004164:	5c 88       	casts.h	r8
80004166:	f3 e8 20 08 	eor	r8,r9,r8
8000416a:	5c 88       	casts.h	r8
8000416c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004170:	b2 38       	st.h	r9[0x6],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80004172:	4e 88       	lddpc	r8,80004310 <phy_payload_tx+0x5cc>
80004174:	30 69       	mov	r9,6
80004176:	91 09       	st.w	r8[0x0],r9
				
							break;
80004178:	c1 08       	rjmp	80004198 <phy_payload_tx+0x454>
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000417a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000417e:	e0 69 5a 5a 	mov	r9,23130
80004182:	ea 19 ab cd 	orh	r9,0xabcd
80004186:	91 09       	st.w	r8[0x0],r9
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004188:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000418c:	30 09       	mov	r9,0
8000418e:	91 19       	st.w	r8[0x4],r9
								AMBEpayload_tx_state = AMBE_IDLE;
80004190:	4e 08       	lddpc	r8,80004310 <phy_payload_tx+0x5cc>
80004192:	30 09       	mov	r9,0
80004194:	91 09       	st.w	r8[0x0],r9
					
							break;
					}
		
					break;
80004196:	cb 68       	rjmp	80004302 <phy_payload_tx+0x5be>
80004198:	cb 58       	rjmp	80004302 <phy_payload_tx+0x5be>
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//
8000419a:	4e 08       	lddpc	r8,80004318 <phy_payload_tx+0x5d4>
8000419c:	70 08       	ld.w	r8,r8[0x0]
8000419e:	58 48       	cp.w	r8,4
800041a0:	c0 70       	breq	800041ae <phy_payload_tx+0x46a>
800041a2:	e0 83 00 85 	brlo	800042ac <phy_payload_tx+0x568>
800041a6:	58 98       	cp.w	r8,9
800041a8:	e0 8b 00 82 	brhi	800042ac <phy_payload_tx+0x568>
800041ac:	c5 78       	rjmp	8000425a <phy_payload_tx+0x516>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
800041ae:	4d f8       	lddpc	r8,80004328 <phy_payload_tx+0x5e4>
800041b0:	11 89       	ld.ub	r9,r8[0x0]
800041b2:	30 18       	mov	r8,1
800041b4:	f0 09 18 00 	cp.b	r9,r8
800041b8:	c2 81       	brne	80004208 <phy_payload_tx+0x4c4>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
800041ba:	4d e8       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
800041bc:	90 18       	ld.sh	r8,r8[0x2]
800041be:	5c 88       	casts.h	r8
800041c0:	4d f9       	lddpc	r9,8000433c <phy_payload_tx+0x5f8>
800041c2:	b2 18       	st.h	r9[0x2],r8
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
800041c4:	4d b8       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
800041c6:	90 28       	ld.sh	r8,r8[0x4]
800041c8:	5c 88       	casts.h	r8
800041ca:	4d d9       	lddpc	r9,8000433c <phy_payload_tx+0x5f8>
800041cc:	b2 28       	st.h	r9[0x4],r8
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
800041ce:	4d 98       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
800041d0:	90 38       	ld.sh	r8,r8[0x6]
800041d2:	5c 88       	casts.h	r8
800041d4:	4d a9       	lddpc	r9,8000433c <phy_payload_tx+0x5f8>
800041d6:	b2 38       	st.h	r9[0x6],r8
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
800041d8:	4d 68       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
800041da:	90 18       	ld.sh	r8,r8[0x2]
800041dc:	5c 88       	casts.h	r8
800041de:	ee f9 ff fc 	ld.w	r9,r7[-4]
800041e2:	b2 08       	st.h	r9[0x0],r8
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
800041e4:	4d 38       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
800041e6:	90 28       	ld.sh	r8,r8[0x4]
800041e8:	5c 88       	casts.h	r8
800041ea:	ee f9 ff fc 	ld.w	r9,r7[-4]
800041ee:	b2 18       	st.h	r9[0x2],r8
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
800041f0:	4d 08       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
800041f2:	90 38       	ld.sh	r8,r8[0x6]
800041f4:	5c 88       	casts.h	r8
800041f6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800041fa:	b2 28       	st.h	r9[0x4],r8
									payload_tx_channel->word[3] = 0x00BA ;
800041fc:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004200:	e0 68 00 ba 	mov	r8,186
80004204:	b2 38       	st.h	r9[0x6],r8
80004206:	c2 68       	rjmp	80004252 <phy_payload_tx+0x50e>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80004208:	4c a8       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
8000420a:	90 18       	ld.sh	r8,r8[0x2]
8000420c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004210:	4c b8       	lddpc	r8,8000433c <phy_payload_tx+0x5f8>
80004212:	90 18       	ld.sh	r8,r8[0x2]
80004214:	5c 88       	casts.h	r8
80004216:	f3 e8 20 08 	eor	r8,r9,r8
8000421a:	5c 88       	casts.h	r8
8000421c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004220:	b2 08       	st.h	r9[0x0],r8
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80004222:	4c 48       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
80004224:	90 28       	ld.sh	r8,r8[0x4]
80004226:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000422a:	4c 58       	lddpc	r8,8000433c <phy_payload_tx+0x5f8>
8000422c:	90 28       	ld.sh	r8,r8[0x4]
8000422e:	5c 88       	casts.h	r8
80004230:	f3 e8 20 08 	eor	r8,r9,r8
80004234:	5c 88       	casts.h	r8
80004236:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000423a:	b2 18       	st.h	r9[0x2],r8
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
8000423c:	4b d8       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
8000423e:	90 38       	ld.sh	r8,r8[0x6]
80004240:	5c 88       	casts.h	r8
80004242:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004246:	b2 28       	st.h	r9[0x4],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80004248:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000424c:	e0 68 00 ba 	mov	r8,186
80004250:	b2 38       	st.h	r9[0x6],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80004252:	4b 08       	lddpc	r8,80004310 <phy_payload_tx+0x5cc>
80004254:	30 09       	mov	r9,0
80004256:	91 09       	st.w	r8[0x0],r9
						
						break;
80004258:	c3 98       	rjmp	800042ca <phy_payload_tx+0x586>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
8000425a:	4b 68       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
8000425c:	90 18       	ld.sh	r8,r8[0x2]
8000425e:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004262:	4b 78       	lddpc	r8,8000433c <phy_payload_tx+0x5f8>
80004264:	90 18       	ld.sh	r8,r8[0x2]
80004266:	5c 88       	casts.h	r8
80004268:	f3 e8 20 08 	eor	r8,r9,r8
8000426c:	5c 88       	casts.h	r8
8000426e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004272:	b2 08       	st.h	r9[0x0],r8
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80004274:	4a f8       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
80004276:	90 28       	ld.sh	r8,r8[0x4]
80004278:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000427c:	4b 08       	lddpc	r8,8000433c <phy_payload_tx+0x5f8>
8000427e:	90 28       	ld.sh	r8,r8[0x4]
80004280:	5c 88       	casts.h	r8
80004282:	f3 e8 20 08 	eor	r8,r9,r8
80004286:	5c 88       	casts.h	r8
80004288:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000428c:	b2 18       	st.h	r9[0x2],r8
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
8000428e:	4a 98       	lddpc	r8,80004330 <phy_payload_tx+0x5ec>
80004290:	90 38       	ld.sh	r8,r8[0x6]
80004292:	5c 88       	casts.h	r8
80004294:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004298:	b2 28       	st.h	r9[0x4],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
8000429a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000429e:	e0 68 00 ba 	mov	r8,186
800042a2:	b2 38       	st.h	r9[0x6],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
800042a4:	49 b8       	lddpc	r8,80004310 <phy_payload_tx+0x5cc>
800042a6:	30 09       	mov	r9,0
800042a8:	91 09       	st.w	r8[0x0],r9
						
							break;
800042aa:	c1 08       	rjmp	800042ca <phy_payload_tx+0x586>
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
800042ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042b0:	e0 69 5a 5a 	mov	r9,23130
800042b4:	ea 19 ab cd 	orh	r9,0xabcd
800042b8:	91 09       	st.w	r8[0x0],r9
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
800042ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042be:	30 09       	mov	r9,0
800042c0:	91 19       	st.w	r8[0x4],r9
							AMBEpayload_tx_state = AMBE_IDLE;
800042c2:	49 48       	lddpc	r8,80004310 <phy_payload_tx+0x5cc>
800042c4:	30 09       	mov	r9,0
800042c6:	91 09       	st.w	r8[0x0],r9
							
							break;
					}

				break;
800042c8:	c1 d8       	rjmp	80004302 <phy_payload_tx+0x5be>
800042ca:	d7 03       	nop
800042cc:	c1 b8       	rjmp	80004302 <phy_payload_tx+0x5be>
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
800042ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042d2:	e0 69 5a 5a 	mov	r9,23130
800042d6:	ea 19 ab cd 	orh	r9,0xabcd
800042da:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
800042dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042e0:	30 09       	mov	r9,0
800042e2:	91 19       	st.w	r8[0x4],r9
					
					AMBEpayload_tx_state = AMBE_IDLE;
800042e4:	48 b8       	lddpc	r8,80004310 <phy_payload_tx+0x5cc>
800042e6:	30 09       	mov	r9,0
800042e8:	91 09       	st.w	r8[0x0],r9
800042ea:	c0 c8       	rjmp	80004302 <phy_payload_tx+0x5be>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
800042ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042f0:	e0 69 5a 5a 	mov	r9,23130
800042f4:	ea 19 ab cd 	orh	r9,0xabcd
800042f8:	91 09       	st.w	r8[0x0],r9
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
800042fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042fe:	30 09       	mov	r9,0
80004300:	91 19       	st.w	r8[0x4],r9

	}//end of Send-PCM-data
	
#endif

}
80004302:	2f fd       	sub	sp,-4
80004304:	e3 cd 80 80 	ldm	sp++,r7,pc
80004308:	00 00       	add	r0,r0
8000430a:	0a 3b       	cp.w	r11,r5
8000430c:	00 00       	add	r0,r0
8000430e:	0a a8       	st.w	r5++,r8
80004310:	00 00       	add	r0,r0
80004312:	0a ac       	st.w	r5++,r12
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	f0 50 00 00 	cp.w	r0,-983040
8000431a:	0a 78       	tst	r8,r5
8000431c:	00 00       	add	r0,r0
8000431e:	0a 7c       	tst	r12,r5
80004320:	00 00       	add	r0,r0
80004322:	0d 80       	ld.ub	r0,r6[0x0]
80004324:	00 00       	add	r0,r0
80004326:	0e 7c       	tst	r12,r7
80004328:	00 00       	add	r0,r0
8000432a:	0a 3f       	cp.w	pc,r5
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	f0 00 00 00 	add	r0,r8,r0
80004332:	0d 78       	ld.ub	r8,--r6
80004334:	00 00       	add	r0,r0
80004336:	0a b0       	st.h	r5++,r0
80004338:	00 00       	add	r0,r0
8000433a:	0e 80       	andn	r0,r7
8000433c:	00 00       	add	r0,r0
8000433e:	0d 84       	ld.ub	r4,r6[0x0]

80004340 <payload_rx>:




static void payload_rx(void * payload)
{
80004340:	eb cd 40 80 	pushm	r7,lr
80004344:	1a 97       	mov	r7,sp
80004346:	20 2d       	sub	sp,8
80004348:	ef 4c ff f8 	st.w	r7[-8],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000434c:	30 08       	mov	r8,0
8000434e:	ef 48 ff fc 	st.w	r7[-4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80004352:	49 48       	lddpc	r8,800043a0 <payload_rx+0x60>
80004354:	70 08       	ld.w	r8,r8[0x0]
80004356:	58 08       	cp.w	r8,0
80004358:	c0 81       	brne	80004368 <payload_rx+0x28>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
8000435a:	30 4b       	mov	r11,4
8000435c:	30 5c       	mov	r12,5
8000435e:	f0 1f 00 12 	mcall	800043a4 <payload_rx+0x64>
80004362:	18 99       	mov	r9,r12
80004364:	48 f8       	lddpc	r8,800043a0 <payload_rx+0x60>
80004366:	91 09       	st.w	r8[0x0],r9
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80004368:	48 e8       	lddpc	r8,800043a0 <payload_rx+0x60>
8000436a:	70 08       	ld.w	r8,r8[0x0]
8000436c:	ee ca 00 04 	sub	r10,r7,4
80004370:	ee cb 00 08 	sub	r11,r7,8
80004374:	30 09       	mov	r9,0
80004376:	10 9c       	mov	r12,r8
80004378:	f0 1f 00 0c 	mcall	800043a8 <payload_rx+0x68>
8000437c:	18 98       	mov	r8,r12
8000437e:	58 08       	cp.w	r8,0
80004380:	c0 c1       	brne	80004398 <payload_rx+0x58>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80004382:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004386:	48 a8       	lddpc	r8,800043ac <payload_rx+0x6c>
80004388:	70 08       	ld.w	r8,r8[0x0]
8000438a:	12 9b       	mov	r11,r9
8000438c:	10 9c       	mov	r12,r8
8000438e:	f0 1f 00 09 	mcall	800043b0 <payload_rx+0x70>
		logFromISR("mm");
80004392:	48 9c       	lddpc	r12,800043b4 <payload_rx+0x74>
80004394:	f0 1f 00 09 	mcall	800043b8 <payload_rx+0x78>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80004398:	2f ed       	sub	sp,-8
8000439a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000439e:	00 00       	add	r0,r0
800043a0:	00 00       	add	r0,r0
800043a2:	0a 74       	tst	r4,r5
800043a4:	80 00       	ld.sh	r0,r0[0x0]
800043a6:	73 c0       	ld.w	r0,r9[0x70]
800043a8:	80 00       	ld.sh	r0,r0[0x0]
800043aa:	76 40       	ld.w	r0,r11[0x10]
800043ac:	00 00       	add	r0,r0
800043ae:	0a 6c       	and	r12,r5
800043b0:	80 00       	ld.sh	r0,r0[0x0]
800043b2:	53 4c       	stdsp	sp[0xd0],r12
800043b4:	80 00       	ld.sh	r0,r0[0x0]
800043b6:	35 fc       	mov	r12,95
800043b8:	80 00       	ld.sh	r0,r0[0x0]
800043ba:	90 00       	ld.sh	r0,r8[0x0]

800043bc <phy_payload_rx>:
Description: receive payload(mdia) packet
Calls: 
Called By:phy_rx_func
*/
static void phy_payload_rx(payload_channel_t * payload_rx_channel)
{
800043bc:	eb cd 40 80 	pushm	r7,lr
800043c0:	1a 97       	mov	r7,sp
800043c2:	20 2d       	sub	sp,8
800043c4:	ef 4c ff f8 	st.w	r7[-8],r12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800043c8:	30 08       	mov	r8,0
800043ca:	ef 48 ff fc 	st.w	r7[-4],r8
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800043ce:	fe f8 0e 5e 	ld.w	r8,pc[3678]
800043d2:	11 88       	ld.ub	r8,r8[0x0]
800043d4:	58 08       	cp.w	r8,0
800043d6:	c1 01       	brne	800043f6 <phy_payload_rx+0x3a>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
800043d8:	fe f8 0e 58 	ld.w	r8,pc[3672]
800043dc:	70 08       	ld.w	r8,r8[0x0]
800043de:	10 9c       	mov	r12,r8
800043e0:	f0 1f 03 95 	mcall	80005234 <phy_payload_rx+0xe78>
800043e4:	18 98       	mov	r8,r12
800043e6:	10 99       	mov	r9,r8
800043e8:	fe f8 0e 50 	ld.w	r8,pc[3664]
800043ec:	91 09       	st.w	r8[0x0],r9
		is_first = TRUE;
800043ee:	fe f9 0e 3e 	ld.w	r9,pc[3646]
800043f2:	30 18       	mov	r8,1
800043f4:	b2 88       	st.b	r9[0x0],r8
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800043f6:	fe f8 0e 46 	ld.w	r8,pc[3654]
800043fa:	70 08       	ld.w	r8,r8[0x0]
800043fc:	58 38       	cp.w	r8,3
800043fe:	e0 80 06 ad 	breq	80005158 <phy_payload_rx+0xd9c>
80004402:	58 48       	cp.w	r8,4
80004404:	e0 80 01 4e 	breq	800046a0 <phy_payload_rx+0x2e4>
80004408:	58 08       	cp.w	r8,0
8000440a:	e0 81 07 0e 	brne	80005226 <phy_payload_rx+0xe6a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000440e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004412:	70 08       	ld.w	r8,r8[0x0]
80004414:	e0 69 5a 5a 	mov	r9,23130
80004418:	ea 19 ab cd 	orh	r9,0xabcd
8000441c:	12 38       	cp.w	r8,r9
8000441e:	c0 71       	brne	8000442c <phy_payload_rx+0x70>
			{
				m_RxBurstType = VOICE_WATING;
80004420:	fe f8 0e 20 	ld.w	r8,pc[3616]
80004424:	30 09       	mov	r9,0
80004426:	91 09       	st.w	r8[0x0],r9
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
80004428:	e0 8f 06 ff 	bral	80005226 <phy_payload_rx+0xe6a>
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
8000442c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004430:	70 08       	ld.w	r8,r8[0x0]
80004432:	e0 18 00 00 	andl	r8,0x0
80004436:	fc 19 ab cd 	movh	r9,0xabcd
8000443a:	12 38       	cp.w	r8,r9
8000443c:	e0 81 06 ea 	brne	80005210 <phy_payload_rx+0xe54>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80004440:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004444:	70 08       	ld.w	r8,r8[0x0]
80004446:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000444a:	fe f8 0d fa 	ld.w	r8,pc[3578]
8000444e:	91 09       	st.w	r8[0x0],r9
		
			if( (NULL== AMBE_payload_ptr))
80004450:	fe f8 0d e8 	ld.w	r8,pc[3560]
80004454:	70 08       	ld.w	r8,r8[0x0]
80004456:	58 08       	cp.w	r8,0
80004458:	c1 71       	brne	80004486 <phy_payload_rx+0xca>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
8000445a:	fe f8 0d d6 	ld.w	r8,pc[3542]
8000445e:	70 08       	ld.w	r8,r8[0x0]
80004460:	10 9c       	mov	r12,r8
80004462:	f0 1f 03 75 	mcall	80005234 <phy_payload_rx+0xe78>
80004466:	18 98       	mov	r8,r12
80004468:	10 99       	mov	r9,r8
8000446a:	fe f8 0d ce 	ld.w	r8,pc[3534]
8000446e:	91 09       	st.w	r8[0x0],r9
				
				if (NULL== AMBE_payload_ptr)
80004470:	fe f8 0d c8 	ld.w	r8,pc[3528]
80004474:	70 08       	ld.w	r8,r8[0x0]
80004476:	58 08       	cp.w	r8,0
80004478:	c0 71       	brne	80004486 <phy_payload_rx+0xca>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//
8000447a:	fe fc 0d ce 	ld.w	r12,pc[3534]
8000447e:	f0 1f 03 74 	mcall	8000524c <phy_payload_rx+0xe90>
					break;
80004482:	e0 8f 06 d2 	bral	80005226 <phy_payload_rx+0xe6a>
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80004486:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000448a:	70 08       	ld.w	r8,r8[0x0]
8000448c:	e2 18 f0 00 	andl	r8,0xf000,COH
80004490:	e0 48 c0 00 	cp.w	r8,49152
80004494:	e0 81 01 00 	brne	80004694 <phy_payload_rx+0x2d8>
			{
				AMBE_Media = 1;	
80004498:	fe f9 0d b8 	ld.w	r9,pc[3512]
8000449c:	30 18       	mov	r8,1
8000449e:	b2 88       	st.b	r9[0x0],r8
											
				Item_ID = payload_rx_channel->byte[5];
800044a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044a4:	11 d8       	ld.ub	r8,r8[0x5]
800044a6:	fe f9 0d ae 	ld.w	r9,pc[3502]
800044aa:	b2 88       	st.b	r9[0x0],r8
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800044ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044b0:	11 c8       	ld.ub	r8,r8[0x4]
800044b2:	f3 d8 c0 07 	bfextu	r9,r8,0x0,0x7
800044b6:	fe f8 0d a2 	ld.w	r8,pc[3490]
800044ba:	91 09       	st.w	r8[0x0],r9
								
				switch(Item_ID)
800044bc:	fe f8 0d 98 	ld.w	r8,pc[3480]
800044c0:	11 88       	ld.ub	r8,r8[0x0]
800044c2:	5c 58       	castu.b	r8
800044c4:	e0 48 00 7f 	cp.w	r8,127
800044c8:	e0 80 00 8b 	breq	800045de <phy_payload_rx+0x222>
800044cc:	e0 89 00 07 	brgt	800044da <phy_payload_rx+0x11e>
800044d0:	59 28       	cp.w	r8,18
800044d2:	c5 00       	breq	80004572 <phy_payload_rx+0x1b6>
800044d4:	59 38       	cp.w	r8,19
800044d6:	c7 f0       	breq	800045d4 <phy_payload_rx+0x218>
800044d8:	cb 48       	rjmp	80004640 <phy_payload_rx+0x284>
800044da:	f0 c8 00 f0 	sub	r8,r8,240
800044de:	58 18       	cp.w	r8,1
800044e0:	e0 8b 00 b0 	brhi	80004640 <phy_payload_rx+0x284>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
800044e4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044e8:	11 e8       	ld.ub	r8,r8[0x6]
800044ea:	e2 18 00 f0 	andl	r8,0xf0,COH
800044ee:	59 08       	cp.w	r8,16
800044f0:	c0 61       	brne	800044fc <phy_payload_rx+0x140>
							{
								m_RxBurstType = VOICEHEADER;
800044f2:	fe f8 0d 4e 	ld.w	r8,pc[3406]
800044f6:	30 19       	mov	r9,1
800044f8:	91 09       	st.w	r8[0x0],r9
800044fa:	c3 b8       	rjmp	80004570 <phy_payload_rx+0x1b4>

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800044fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004500:	11 e8       	ld.ub	r8,r8[0x6]
80004502:	e2 18 00 f0 	andl	r8,0xf0,COH
80004506:	e0 48 00 20 	cp.w	r8,32
8000450a:	c2 f1       	brne	80004568 <phy_payload_rx+0x1ac>
							{
								m_RxBurstType = VOICETERMINATOR;
8000450c:	fe f8 0d 34 	ld.w	r8,pc[3380]
80004510:	30 a9       	mov	r9,10
80004512:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//0
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80004514:	fe f8 0d 48 	ld.w	r8,pc[3400]
80004518:	70 08       	ld.w	r8,r8[0x0]
8000451a:	5c d8       	com	r8
8000451c:	f0 c9 fe 00 	sub	r9,r8,-512
80004520:	fe f8 0d 18 	ld.w	r8,pc[3352]
80004524:	70 0a       	ld.w	r10,r8[0x0]
80004526:	fe f8 0d 36 	ld.w	r8,pc[3382]
8000452a:	70 08       	ld.w	r8,r8[0x0]
8000452c:	2f f8       	sub	r8,-1
8000452e:	f4 08 00 08 	add	r8,r10,r8
80004532:	12 9a       	mov	r10,r9
80004534:	30 0b       	mov	r11,0
80004536:	10 9c       	mov	r12,r8
80004538:	f0 1f 03 4a 	mcall	80005260 <phy_payload_rx+0xea4>
								
								RxAMBE_IsFillingNext8 = 0;
8000453c:	fe f8 0d 20 	ld.w	r8,pc[3360]
80004540:	30 09       	mov	r9,0
80004542:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004544:	fe f8 0c f4 	ld.w	r8,pc[3316]
80004548:	70 08       	ld.w	r8,r8[0x0]
8000454a:	10 9c       	mov	r12,r8
8000454c:	f0 1f 03 46 	mcall	80005264 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80004550:	fe f8 0c e0 	ld.w	r8,pc[3296]
80004554:	70 08       	ld.w	r8,r8[0x0]
80004556:	10 9c       	mov	r12,r8
80004558:	f0 1f 03 37 	mcall	80005234 <phy_payload_rx+0xe78>
8000455c:	18 98       	mov	r8,r12
8000455e:	10 99       	mov	r9,r8
80004560:	fe f8 0c d8 	ld.w	r8,pc[3288]
80004564:	91 09       	st.w	r8[0x0],r9
80004566:	c0 58       	rjmp	80004570 <phy_payload_rx+0x1b4>
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80004568:	fe f8 0c d8 	ld.w	r8,pc[3288]
8000456c:	30 09       	mov	r9,0
8000456e:	91 09       	st.w	r8[0x0],r9
							}
							
						break;//WAITINGABAB.
80004570:	c9 08       	rjmp	80004690 <phy_payload_rx+0x2d4>
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80004572:	fe f8 0c d2 	ld.w	r8,pc[3282]
80004576:	70 08       	ld.w	r8,r8[0x0]
80004578:	f0 c9 00 04 	sub	r9,r8,4
8000457c:	fe f8 0c c8 	ld.w	r8,pc[3272]
80004580:	91 09       	st.w	r8[0x0],r9
80004582:	fe f8 0c c2 	ld.w	r8,pc[3266]
80004586:	70 08       	ld.w	r8,r8[0x0]
80004588:	58 08       	cp.w	r8,0
8000458a:	c0 21       	brne	8000458e <phy_payload_rx+0x1d2>
8000458c:	c8 28       	rjmp	80004690 <phy_payload_rx+0x2d4>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000458e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004592:	11 f8       	ld.ub	r8,r8[0x7]
80004594:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004598:	fe f9 0c d0 	ld.w	r9,pc[3280]
8000459c:	b2 88       	st.b	r9[0x0],r8
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000459e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045a2:	90 28       	ld.sh	r8,r8[0x4]
800045a4:	fe f9 0c c8 	ld.w	r9,pc[3272]
800045a8:	b2 08       	st.h	r9[0x0],r8
							VBSP_data[1] = payload_rx_channel->word[3];
800045aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045ae:	90 38       	ld.sh	r8,r8[0x6]
800045b0:	fe f9 0c bc 	ld.w	r9,pc[3260]
800045b4:	b2 18       	st.h	r9[0x2],r8
							
							m_RxBurstType = CalculateBurst(VF_SN);
800045b6:	fe f8 0c b2 	ld.w	r8,pc[3250]
800045ba:	11 88       	ld.ub	r8,r8[0x0]
800045bc:	10 9c       	mov	r12,r8
800045be:	f0 1f 03 2d 	mcall	80005270 <phy_payload_rx+0xeb4>
800045c2:	18 99       	mov	r9,r12
800045c4:	fe f8 0c 7c 	ld.w	r8,pc[3196]
800045c8:	91 09       	st.w	r8[0x0],r9
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800045ca:	fe f8 0c 72 	ld.w	r8,pc[3186]
800045ce:	30 49       	mov	r9,4
800045d0:	91 09       	st.w	r8[0x0],r9
							
					
						break;//Jump to READING_AMBE_MEDIA
800045d2:	c5 f8       	rjmp	80004690 <phy_payload_rx+0x2d4>
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800045d4:	fe f8 0c 6c 	ld.w	r8,pc[3180]
800045d8:	30 09       	mov	r9,0
800045da:	91 09       	st.w	r8[0x0],r9
						
						break;//WAITINGABAB.
800045dc:	c5 a8       	rjmp	80004690 <phy_payload_rx+0x2d4>
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800045de:	fe f8 0c 66 	ld.w	r8,pc[3174]
800045e2:	70 08       	ld.w	r8,r8[0x0]
800045e4:	f0 c9 00 04 	sub	r9,r8,4
800045e8:	fe f8 0c 5c 	ld.w	r8,pc[3164]
800045ec:	91 09       	st.w	r8[0x0],r9
800045ee:	fe f8 0c 56 	ld.w	r8,pc[3158]
800045f2:	70 08       	ld.w	r8,r8[0x0]
800045f4:	58 08       	cp.w	r8,0
800045f6:	c0 21       	brne	800045fa <phy_payload_rx+0x23e>
800045f8:	c4 c8       	rjmp	80004690 <phy_payload_rx+0x2d4>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800045fa:	fe f8 0c 7a 	ld.w	r8,pc[3194]
800045fe:	70 0a       	ld.w	r10,r8[0x0]
80004600:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004604:	90 38       	ld.sh	r8,r8[0x6]
80004606:	fe f9 0c 72 	ld.w	r9,pc[3186]
8000460a:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							RxData_IsFillingNext16 += 1; 
8000460e:	fe f8 0c 66 	ld.w	r8,pc[3174]
80004612:	70 08       	ld.w	r8,r8[0x0]
80004614:	f0 c9 ff ff 	sub	r9,r8,-1
80004618:	fe f8 0c 5c 	ld.w	r8,pc[3164]
8000461c:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
8000461e:	fe f8 0c 3a 	ld.w	r8,pc[3130]
80004622:	70 08       	ld.w	r8,r8[0x0]
80004624:	f0 c9 00 02 	sub	r9,r8,2
80004628:	fe f8 0c 30 	ld.w	r8,pc[3120]
8000462c:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000462e:	fe f8 0c 12 	ld.w	r8,pc[3090]
80004632:	30 29       	mov	r9,2
80004634:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80004636:	fe f8 0c 06 	ld.w	r8,pc[3078]
8000463a:	30 39       	mov	r9,3
8000463c:	91 09       	st.w	r8[0x0],r9
							
					
						break;//Jump to READING_AMBE_AUX
8000463e:	c2 98       	rjmp	80004690 <phy_payload_rx+0x2d4>
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80004640:	fe f8 0c 00 	ld.w	r8,pc[3072]
80004644:	30 39       	mov	r9,3
80004646:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80004648:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000464c:	70 09       	ld.w	r9,r8[0x0]
8000464e:	fe f8 0c 2e 	ld.w	r8,pc[3118]
80004652:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80004654:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004658:	70 19       	ld.w	r9,r8[0x4]
8000465a:	fe f8 0c 22 	ld.w	r8,pc[3106]
8000465e:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80004660:	fe f8 0b e4 	ld.w	r8,pc[3044]
80004664:	70 08       	ld.w	r8,r8[0x0]
80004666:	59 48       	cp.w	r8,20
80004668:	c0 51       	brne	80004672 <phy_payload_rx+0x2b6>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000466a:	fe f8 0b da 	ld.w	r8,pc[3034]
8000466e:	31 89       	mov	r9,24
80004670:	91 09       	st.w	r8[0x0],r9
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80004672:	fe f8 0b d2 	ld.w	r8,pc[3026]
80004676:	70 08       	ld.w	r8,r8[0x0]
80004678:	59 08       	cp.w	r8,16
8000467a:	c0 51       	brne	80004684 <phy_payload_rx+0x2c8>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000467c:	fe f8 0b c8 	ld.w	r8,pc[3016]
80004680:	31 09       	mov	r9,16
80004682:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80004684:	fe f8 0b b8 	ld.w	r8,pc[3000]
80004688:	30 49       	mov	r9,4
8000468a:	91 09       	st.w	r8[0x0],r9
					
						break;//Jump to READING_AMBE_MEDIA
									
			
				}
				break;
8000468c:	e0 8f 05 cd 	bral	80005226 <phy_payload_rx+0xe6a>
80004690:	e0 8f 05 cb 	bral	80005226 <phy_payload_rx+0xe6a>
			}
			
			else
			{
				AMBE_Media = 0;	
80004694:	fe f9 0b bc 	ld.w	r9,pc[3004]
80004698:	30 08       	mov	r8,0
8000469a:	b2 88       	st.b	r9[0x0],r8
				break;
8000469c:	e0 8f 05 c5 	bral	80005226 <phy_payload_rx+0xe6a>

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800046a0:	fe f8 0b b4 	ld.w	r8,pc[2996]
800046a4:	11 88       	ld.ub	r8,r8[0x0]
800046a6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800046aa:	31 28       	mov	r8,18
800046ac:	f0 09 18 00 	cp.b	r9,r8
800046b0:	e0 81 02 07 	brne	80004abe <phy_payload_rx+0x702>
					{
						Item_ID = payload_rx_channel->byte[1];
800046b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046b8:	11 98       	ld.ub	r8,r8[0x1]
800046ba:	fe f9 0b 9a 	ld.w	r9,pc[2970]
800046be:	b2 88       	st.b	r9[0x0],r8
						if (Item_ID == Post_Voice_Encoder_Data)//
800046c0:	fe f8 0b 94 	ld.w	r8,pc[2964]
800046c4:	11 88       	ld.ub	r8,r8[0x0]
800046c6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800046ca:	3f 28       	mov	r8,-14
800046cc:	f0 09 18 00 	cp.b	r9,r8
800046d0:	e0 81 01 f1 	brne	80004ab2 <phy_payload_rx+0x6f6>
						{
							AMBE_tx_flag = 1;
800046d4:	fe f9 0b ac 	ld.w	r9,pc[2988]
800046d8:	30 18       	mov	r8,1
800046da:	b2 88       	st.b	r9[0x0],r8
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800046dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046e0:	70 08       	ld.w	r8,r8[0x0]
800046e2:	e6 18 7f 00 	andh	r8,0x7f00,COH
800046e6:	f0 09 16 18 	lsr	r9,r8,0x18
800046ea:	fe f8 0b 5a 	ld.w	r8,pc[2906]
800046ee:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800046f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046f4:	90 18       	ld.sh	r8,r8[0x2]
800046f6:	fe f9 0b 8e 	ld.w	r9,pc[2958]
800046fa:	b2 08       	st.h	r9[0x0],r8
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800046fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004700:	90 28       	ld.sh	r8,r8[0x4]
80004702:	fe f9 0b 82 	ld.w	r9,pc[2946]
80004706:	b2 18       	st.h	r9[0x2],r8
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80004708:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000470c:	90 38       	ld.sh	r8,r8[0x6]
8000470e:	fe f9 0b 76 	ld.w	r9,pc[2934]
80004712:	b2 28       	st.h	r9[0x4],r8
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80004714:	fe f8 0b 24 	ld.w	r8,pc[2852]
80004718:	70 09       	ld.w	r9,r8[0x0]
8000471a:	fe f8 0b 42 	ld.w	r8,pc[2882]
8000471e:	70 08       	ld.w	r8,r8[0x0]
80004720:	10 09       	add	r9,r8
80004722:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004726:	11 a8       	ld.ub	r8,r8[0x2]
80004728:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
8000472a:	fe f8 0b 32 	ld.w	r8,pc[2866]
8000472e:	70 08       	ld.w	r8,r8[0x0]
80004730:	f0 c9 ff ff 	sub	r9,r8,-1
80004734:	fe f8 0b 28 	ld.w	r8,pc[2856]
80004738:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000473a:	fe f8 0b 22 	ld.w	r8,pc[2850]
8000473e:	70 08       	ld.w	r8,r8[0x0]
80004740:	e0 48 01 ff 	cp.w	r8,511
80004744:	e0 88 00 22 	brls	80004788 <phy_payload_rx+0x3cc>
							{
								RxAMBE_IsFillingNext8 = 0;
80004748:	fe f8 0b 14 	ld.w	r8,pc[2836]
8000474c:	30 09       	mov	r9,0
8000474e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004750:	fe f8 0a e8 	ld.w	r8,pc[2792]
80004754:	70 08       	ld.w	r8,r8[0x0]
80004756:	10 9c       	mov	r12,r8
80004758:	f0 1f 02 c3 	mcall	80005264 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
8000475c:	fe f8 0a d4 	ld.w	r8,pc[2772]
80004760:	70 08       	ld.w	r8,r8[0x0]
80004762:	10 9c       	mov	r12,r8
80004764:	f0 1f 02 b4 	mcall	80005234 <phy_payload_rx+0xe78>
80004768:	18 98       	mov	r8,r12
8000476a:	10 99       	mov	r9,r8
8000476c:	fe f8 0a cc 	ld.w	r8,pc[2764]
80004770:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80004772:	fe f8 0a c6 	ld.w	r8,pc[2758]
80004776:	70 08       	ld.w	r8,r8[0x0]
80004778:	58 08       	cp.w	r8,0
8000477a:	c0 71       	brne	80004788 <phy_payload_rx+0x3cc>
								{
									RxMediaState = WAITINGABAB;
8000477c:	fe f8 0a c0 	ld.w	r8,pc[2752]
80004780:	30 09       	mov	r9,0
80004782:	91 09       	st.w	r8[0x0],r9
									break;
80004784:	e0 8f 05 51 	bral	80005226 <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004788:	fe f8 0a bc 	ld.w	r8,pc[2748]
8000478c:	70 08       	ld.w	r8,r8[0x0]
8000478e:	f0 c9 00 01 	sub	r9,r8,1
80004792:	fe f8 0a b2 	ld.w	r8,pc[2738]
80004796:	91 09       	st.w	r8[0x0],r9
80004798:	fe f8 0a ac 	ld.w	r8,pc[2732]
8000479c:	70 08       	ld.w	r8,r8[0x0]
8000479e:	58 08       	cp.w	r8,0
800047a0:	c0 71       	brne	800047ae <phy_payload_rx+0x3f2>
								RxMediaState = WAITINGABAB;
800047a2:	fe f8 0a 9a 	ld.w	r8,pc[2714]
800047a6:	30 09       	mov	r9,0
800047a8:	91 09       	st.w	r8[0x0],r9
								break;
800047aa:	e0 8f 05 3e 	bral	80005226 <phy_payload_rx+0xe6a>
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800047ae:	fe f8 0a 8a 	ld.w	r8,pc[2698]
800047b2:	70 09       	ld.w	r9,r8[0x0]
800047b4:	fe f8 0a a8 	ld.w	r8,pc[2728]
800047b8:	70 08       	ld.w	r8,r8[0x0]
800047ba:	10 09       	add	r9,r8
800047bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800047c0:	11 b8       	ld.ub	r8,r8[0x3]
800047c2:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
800047c4:	fe f8 0a 98 	ld.w	r8,pc[2712]
800047c8:	70 08       	ld.w	r8,r8[0x0]
800047ca:	f0 c9 ff ff 	sub	r9,r8,-1
800047ce:	fe f8 0a 8e 	ld.w	r8,pc[2702]
800047d2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800047d4:	fe f8 0a 88 	ld.w	r8,pc[2696]
800047d8:	70 08       	ld.w	r8,r8[0x0]
800047da:	e0 48 01 ff 	cp.w	r8,511
800047de:	e0 88 00 22 	brls	80004822 <phy_payload_rx+0x466>
							{
								RxAMBE_IsFillingNext8 = 0;
800047e2:	fe f8 0a 7a 	ld.w	r8,pc[2682]
800047e6:	30 09       	mov	r9,0
800047e8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800047ea:	fe f8 0a 4e 	ld.w	r8,pc[2638]
800047ee:	70 08       	ld.w	r8,r8[0x0]
800047f0:	10 9c       	mov	r12,r8
800047f2:	f0 1f 02 9d 	mcall	80005264 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
800047f6:	fe f8 0a 3a 	ld.w	r8,pc[2618]
800047fa:	70 08       	ld.w	r8,r8[0x0]
800047fc:	10 9c       	mov	r12,r8
800047fe:	f0 1f 02 8e 	mcall	80005234 <phy_payload_rx+0xe78>
80004802:	18 98       	mov	r8,r12
80004804:	10 99       	mov	r9,r8
80004806:	fe f8 0a 32 	ld.w	r8,pc[2610]
8000480a:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
8000480c:	fe f8 0a 2c 	ld.w	r8,pc[2604]
80004810:	70 08       	ld.w	r8,r8[0x0]
80004812:	58 08       	cp.w	r8,0
80004814:	c0 71       	brne	80004822 <phy_payload_rx+0x466>
								{
									RxMediaState = WAITINGABAB;
80004816:	fe f8 0a 26 	ld.w	r8,pc[2598]
8000481a:	30 09       	mov	r9,0
8000481c:	91 09       	st.w	r8[0x0],r9
									break;
8000481e:	e0 8f 05 04 	bral	80005226 <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004822:	fe f8 0a 22 	ld.w	r8,pc[2594]
80004826:	70 08       	ld.w	r8,r8[0x0]
80004828:	f0 c9 00 01 	sub	r9,r8,1
8000482c:	fe f8 0a 18 	ld.w	r8,pc[2584]
80004830:	91 09       	st.w	r8[0x0],r9
80004832:	fe f8 0a 12 	ld.w	r8,pc[2578]
80004836:	70 08       	ld.w	r8,r8[0x0]
80004838:	58 08       	cp.w	r8,0
8000483a:	c0 71       	brne	80004848 <phy_payload_rx+0x48c>
								RxMediaState = WAITINGABAB;
8000483c:	fe f8 0a 00 	ld.w	r8,pc[2560]
80004840:	30 09       	mov	r9,0
80004842:	91 09       	st.w	r8[0x0],r9
								break;
80004844:	e0 8f 04 f1 	bral	80005226 <phy_payload_rx+0xe6a>
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80004848:	fe f8 09 f0 	ld.w	r8,pc[2544]
8000484c:	70 09       	ld.w	r9,r8[0x0]
8000484e:	fe f8 0a 0e 	ld.w	r8,pc[2574]
80004852:	70 08       	ld.w	r8,r8[0x0]
80004854:	10 09       	add	r9,r8
80004856:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000485a:	11 c8       	ld.ub	r8,r8[0x4]
8000485c:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
8000485e:	fe f8 09 fe 	ld.w	r8,pc[2558]
80004862:	70 08       	ld.w	r8,r8[0x0]
80004864:	f0 c9 ff ff 	sub	r9,r8,-1
80004868:	fe f8 09 f4 	ld.w	r8,pc[2548]
8000486c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000486e:	fe f8 09 ee 	ld.w	r8,pc[2542]
80004872:	70 08       	ld.w	r8,r8[0x0]
80004874:	e0 48 01 ff 	cp.w	r8,511
80004878:	e0 88 00 22 	brls	800048bc <phy_payload_rx+0x500>
							{
								RxAMBE_IsFillingNext8 = 0;
8000487c:	fe f8 09 e0 	ld.w	r8,pc[2528]
80004880:	30 09       	mov	r9,0
80004882:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004884:	fe f8 09 b4 	ld.w	r8,pc[2484]
80004888:	70 08       	ld.w	r8,r8[0x0]
8000488a:	10 9c       	mov	r12,r8
8000488c:	f0 1f 02 76 	mcall	80005264 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80004890:	fe f8 09 a0 	ld.w	r8,pc[2464]
80004894:	70 08       	ld.w	r8,r8[0x0]
80004896:	10 9c       	mov	r12,r8
80004898:	f0 1f 02 67 	mcall	80005234 <phy_payload_rx+0xe78>
8000489c:	18 98       	mov	r8,r12
8000489e:	10 99       	mov	r9,r8
800048a0:	fe f8 09 98 	ld.w	r8,pc[2456]
800048a4:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
800048a6:	fe f8 09 92 	ld.w	r8,pc[2450]
800048aa:	70 08       	ld.w	r8,r8[0x0]
800048ac:	58 08       	cp.w	r8,0
800048ae:	c0 71       	brne	800048bc <phy_payload_rx+0x500>
								{
									RxMediaState = WAITINGABAB;
800048b0:	fe f8 09 8c 	ld.w	r8,pc[2444]
800048b4:	30 09       	mov	r9,0
800048b6:	91 09       	st.w	r8[0x0],r9
									break;
800048b8:	e0 8f 04 b7 	bral	80005226 <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800048bc:	fe f8 09 88 	ld.w	r8,pc[2440]
800048c0:	70 08       	ld.w	r8,r8[0x0]
800048c2:	f0 c9 00 01 	sub	r9,r8,1
800048c6:	fe f8 09 7e 	ld.w	r8,pc[2430]
800048ca:	91 09       	st.w	r8[0x0],r9
800048cc:	fe f8 09 78 	ld.w	r8,pc[2424]
800048d0:	70 08       	ld.w	r8,r8[0x0]
800048d2:	58 08       	cp.w	r8,0
800048d4:	c0 71       	brne	800048e2 <phy_payload_rx+0x526>
								RxMediaState = WAITINGABAB;
800048d6:	fe f8 09 66 	ld.w	r8,pc[2406]
800048da:	30 09       	mov	r9,0
800048dc:	91 09       	st.w	r8[0x0],r9
								break;
800048de:	e0 8f 04 a4 	bral	80005226 <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800048e2:	fe f8 09 56 	ld.w	r8,pc[2390]
800048e6:	70 09       	ld.w	r9,r8[0x0]
800048e8:	fe f8 09 74 	ld.w	r8,pc[2420]
800048ec:	70 08       	ld.w	r8,r8[0x0]
800048ee:	10 09       	add	r9,r8
800048f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048f4:	11 d8       	ld.ub	r8,r8[0x5]
800048f6:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
800048f8:	fe f8 09 64 	ld.w	r8,pc[2404]
800048fc:	70 08       	ld.w	r8,r8[0x0]
800048fe:	f0 c9 ff ff 	sub	r9,r8,-1
80004902:	fe f8 09 5a 	ld.w	r8,pc[2394]
80004906:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004908:	fe f8 09 54 	ld.w	r8,pc[2388]
8000490c:	70 08       	ld.w	r8,r8[0x0]
8000490e:	e0 48 01 ff 	cp.w	r8,511
80004912:	e0 88 00 22 	brls	80004956 <phy_payload_rx+0x59a>
							{
								RxAMBE_IsFillingNext8 = 0;
80004916:	fe f8 09 46 	ld.w	r8,pc[2374]
8000491a:	30 09       	mov	r9,0
8000491c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000491e:	fe f8 09 1a 	ld.w	r8,pc[2330]
80004922:	70 08       	ld.w	r8,r8[0x0]
80004924:	10 9c       	mov	r12,r8
80004926:	f0 1f 02 50 	mcall	80005264 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
8000492a:	fe f8 09 06 	ld.w	r8,pc[2310]
8000492e:	70 08       	ld.w	r8,r8[0x0]
80004930:	10 9c       	mov	r12,r8
80004932:	f0 1f 02 41 	mcall	80005234 <phy_payload_rx+0xe78>
80004936:	18 98       	mov	r8,r12
80004938:	10 99       	mov	r9,r8
8000493a:	fe f8 08 fe 	ld.w	r8,pc[2302]
8000493e:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80004940:	fe f8 08 f8 	ld.w	r8,pc[2296]
80004944:	70 08       	ld.w	r8,r8[0x0]
80004946:	58 08       	cp.w	r8,0
80004948:	c0 71       	brne	80004956 <phy_payload_rx+0x59a>
								{
									RxMediaState = WAITINGABAB;
8000494a:	fe f8 08 f2 	ld.w	r8,pc[2290]
8000494e:	30 09       	mov	r9,0
80004950:	91 09       	st.w	r8[0x0],r9
									break;
80004952:	e0 8f 04 6a 	bral	80005226 <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004956:	fe f8 08 ee 	ld.w	r8,pc[2286]
8000495a:	70 08       	ld.w	r8,r8[0x0]
8000495c:	f0 c9 00 01 	sub	r9,r8,1
80004960:	fe f8 08 e4 	ld.w	r8,pc[2276]
80004964:	91 09       	st.w	r8[0x0],r9
80004966:	fe f8 08 de 	ld.w	r8,pc[2270]
8000496a:	70 08       	ld.w	r8,r8[0x0]
8000496c:	58 08       	cp.w	r8,0
8000496e:	c0 71       	brne	8000497c <phy_payload_rx+0x5c0>
								RxMediaState = WAITINGABAB;
80004970:	fe f8 08 cc 	ld.w	r8,pc[2252]
80004974:	30 09       	mov	r9,0
80004976:	91 09       	st.w	r8[0x0],r9
								break;
80004978:	e0 8f 04 57 	bral	80005226 <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
8000497c:	fe f8 08 bc 	ld.w	r8,pc[2236]
80004980:	70 09       	ld.w	r9,r8[0x0]
80004982:	fe f8 08 da 	ld.w	r8,pc[2266]
80004986:	70 08       	ld.w	r8,r8[0x0]
80004988:	10 09       	add	r9,r8
8000498a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000498e:	11 e8       	ld.ub	r8,r8[0x6]
80004990:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80004992:	fe f8 08 ca 	ld.w	r8,pc[2250]
80004996:	70 08       	ld.w	r8,r8[0x0]
80004998:	f0 c9 ff ff 	sub	r9,r8,-1
8000499c:	fe f8 08 c0 	ld.w	r8,pc[2240]
800049a0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800049a2:	fe f8 08 ba 	ld.w	r8,pc[2234]
800049a6:	70 08       	ld.w	r8,r8[0x0]
800049a8:	e0 48 01 ff 	cp.w	r8,511
800049ac:	e0 88 00 22 	brls	800049f0 <phy_payload_rx+0x634>
							{
								RxAMBE_IsFillingNext8 = 0;
800049b0:	fe f8 08 ac 	ld.w	r8,pc[2220]
800049b4:	30 09       	mov	r9,0
800049b6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800049b8:	fe f8 08 80 	ld.w	r8,pc[2176]
800049bc:	70 08       	ld.w	r8,r8[0x0]
800049be:	10 9c       	mov	r12,r8
800049c0:	f0 1f 02 29 	mcall	80005264 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
800049c4:	fe f8 08 6c 	ld.w	r8,pc[2156]
800049c8:	70 08       	ld.w	r8,r8[0x0]
800049ca:	10 9c       	mov	r12,r8
800049cc:	f0 1f 02 1a 	mcall	80005234 <phy_payload_rx+0xe78>
800049d0:	18 98       	mov	r8,r12
800049d2:	10 99       	mov	r9,r8
800049d4:	fe f8 08 64 	ld.w	r8,pc[2148]
800049d8:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
800049da:	fe f8 08 5e 	ld.w	r8,pc[2142]
800049de:	70 08       	ld.w	r8,r8[0x0]
800049e0:	58 08       	cp.w	r8,0
800049e2:	c0 71       	brne	800049f0 <phy_payload_rx+0x634>
								{
									RxMediaState = WAITINGABAB;
800049e4:	fe f8 08 58 	ld.w	r8,pc[2136]
800049e8:	30 09       	mov	r9,0
800049ea:	91 09       	st.w	r8[0x0],r9
									break;
800049ec:	e0 8f 04 1d 	bral	80005226 <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800049f0:	fe f8 08 54 	ld.w	r8,pc[2132]
800049f4:	70 08       	ld.w	r8,r8[0x0]
800049f6:	f0 c9 00 01 	sub	r9,r8,1
800049fa:	fe f8 08 4a 	ld.w	r8,pc[2122]
800049fe:	91 09       	st.w	r8[0x0],r9
80004a00:	fe f8 08 44 	ld.w	r8,pc[2116]
80004a04:	70 08       	ld.w	r8,r8[0x0]
80004a06:	58 08       	cp.w	r8,0
80004a08:	c0 71       	brne	80004a16 <phy_payload_rx+0x65a>
								RxMediaState = WAITINGABAB;
80004a0a:	fe f8 08 32 	ld.w	r8,pc[2098]
80004a0e:	30 09       	mov	r9,0
80004a10:	91 09       	st.w	r8[0x0],r9
								break;
80004a12:	e0 8f 04 0a 	bral	80005226 <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80004a16:	fe f8 08 22 	ld.w	r8,pc[2082]
80004a1a:	70 09       	ld.w	r9,r8[0x0]
80004a1c:	fe f8 08 40 	ld.w	r8,pc[2112]
80004a20:	70 08       	ld.w	r8,r8[0x0]
80004a22:	10 09       	add	r9,r8
80004a24:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004a28:	11 f8       	ld.ub	r8,r8[0x7]
80004a2a:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80004a2c:	fe f8 08 30 	ld.w	r8,pc[2096]
80004a30:	70 08       	ld.w	r8,r8[0x0]
80004a32:	f0 c9 ff ff 	sub	r9,r8,-1
80004a36:	fe f8 08 26 	ld.w	r8,pc[2086]
80004a3a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004a3c:	fe f8 08 20 	ld.w	r8,pc[2080]
80004a40:	70 08       	ld.w	r8,r8[0x0]
80004a42:	e0 48 01 ff 	cp.w	r8,511
80004a46:	e0 88 00 22 	brls	80004a8a <phy_payload_rx+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80004a4a:	fe f8 08 12 	ld.w	r8,pc[2066]
80004a4e:	30 09       	mov	r9,0
80004a50:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004a52:	fe f8 07 e6 	ld.w	r8,pc[2022]
80004a56:	70 08       	ld.w	r8,r8[0x0]
80004a58:	10 9c       	mov	r12,r8
80004a5a:	f0 1f 02 03 	mcall	80005264 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80004a5e:	fe f8 07 d2 	ld.w	r8,pc[2002]
80004a62:	70 08       	ld.w	r8,r8[0x0]
80004a64:	10 9c       	mov	r12,r8
80004a66:	f0 1f 01 f4 	mcall	80005234 <phy_payload_rx+0xe78>
80004a6a:	18 98       	mov	r8,r12
80004a6c:	10 99       	mov	r9,r8
80004a6e:	fe f8 07 ca 	ld.w	r8,pc[1994]
80004a72:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80004a74:	fe f8 07 c4 	ld.w	r8,pc[1988]
80004a78:	70 08       	ld.w	r8,r8[0x0]
80004a7a:	58 08       	cp.w	r8,0
80004a7c:	c0 71       	brne	80004a8a <phy_payload_rx+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80004a7e:	fe f8 07 be 	ld.w	r8,pc[1982]
80004a82:	30 09       	mov	r9,0
80004a84:	91 09       	st.w	r8[0x0],r9
									break;
80004a86:	e0 8f 03 d0 	bral	80005226 <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004a8a:	fe f8 07 ba 	ld.w	r8,pc[1978]
80004a8e:	70 08       	ld.w	r8,r8[0x0]
80004a90:	f0 c9 00 01 	sub	r9,r8,1
80004a94:	fe f8 07 b0 	ld.w	r8,pc[1968]
80004a98:	91 09       	st.w	r8[0x0],r9
80004a9a:	fe f8 07 aa 	ld.w	r8,pc[1962]
80004a9e:	70 08       	ld.w	r8,r8[0x0]
80004aa0:	58 08       	cp.w	r8,0
80004aa2:	e0 81 03 b9 	brne	80005214 <phy_payload_rx+0xe58>
								RxMediaState = WAITINGABAB;
80004aa6:	fe f8 07 96 	ld.w	r8,pc[1942]
80004aaa:	30 09       	mov	r9,0
80004aac:	91 09       	st.w	r8[0x0],r9
								break;
80004aae:	e0 8f 03 bc 	bral	80005226 <phy_payload_rx+0xe6a>
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80004ab2:	fe f8 07 8a 	ld.w	r8,pc[1930]
80004ab6:	30 09       	mov	r9,0
80004ab8:	91 09       	st.w	r8[0x0],r9
							break;
80004aba:	e0 8f 03 b6 	bral	80005226 <phy_payload_rx+0xe6a>
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004abe:	fe f8 07 96 	ld.w	r8,pc[1942]
80004ac2:	11 88       	ld.ub	r8,r8[0x0]
80004ac4:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004ac8:	3f 28       	mov	r8,-14
80004aca:	f0 09 18 00 	cp.b	r9,r8
80004ace:	c6 81       	brne	80004b9e <phy_payload_rx+0x7e2>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004ad0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ad4:	90 08       	ld.sh	r8,r8[0x0]
80004ad6:	fe f9 07 ae 	ld.w	r9,pc[1966]
80004ada:	b2 38       	st.h	r9[0x6],r8
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80004adc:	fe f8 07 5c 	ld.w	r8,pc[1884]
80004ae0:	70 09       	ld.w	r9,r8[0x0]
80004ae2:	fe f8 07 7a 	ld.w	r8,pc[1914]
80004ae6:	70 08       	ld.w	r8,r8[0x0]
80004ae8:	10 09       	add	r9,r8
80004aea:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004aee:	11 88       	ld.ub	r8,r8[0x0]
80004af0:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80004af2:	fe f8 07 6a 	ld.w	r8,pc[1898]
80004af6:	70 08       	ld.w	r8,r8[0x0]
80004af8:	f0 c9 ff ff 	sub	r9,r8,-1
80004afc:	fe f8 07 60 	ld.w	r8,pc[1888]
80004b00:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004b02:	fe f8 07 5a 	ld.w	r8,pc[1882]
80004b06:	70 08       	ld.w	r8,r8[0x0]
80004b08:	e0 48 01 ff 	cp.w	r8,511
80004b0c:	e0 88 00 22 	brls	80004b50 <phy_payload_rx+0x794>
						{
							RxAMBE_IsFillingNext8 = 0;
80004b10:	fe f8 07 4c 	ld.w	r8,pc[1868]
80004b14:	30 09       	mov	r9,0
80004b16:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004b18:	fe f8 07 20 	ld.w	r8,pc[1824]
80004b1c:	70 08       	ld.w	r8,r8[0x0]
80004b1e:	10 9c       	mov	r12,r8
80004b20:	f0 1f 01 d1 	mcall	80005264 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80004b24:	fe f8 07 0c 	ld.w	r8,pc[1804]
80004b28:	70 08       	ld.w	r8,r8[0x0]
80004b2a:	10 9c       	mov	r12,r8
80004b2c:	f0 1f 01 c2 	mcall	80005234 <phy_payload_rx+0xe78>
80004b30:	18 98       	mov	r8,r12
80004b32:	10 99       	mov	r9,r8
80004b34:	fe f8 07 04 	ld.w	r8,pc[1796]
80004b38:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80004b3a:	fe f8 06 fe 	ld.w	r8,pc[1790]
80004b3e:	70 08       	ld.w	r8,r8[0x0]
80004b40:	58 08       	cp.w	r8,0
80004b42:	c0 71       	brne	80004b50 <phy_payload_rx+0x794>
							{
								RxMediaState = WAITINGABAB;
80004b44:	fe f8 06 f8 	ld.w	r8,pc[1784]
80004b48:	30 09       	mov	r9,0
80004b4a:	91 09       	st.w	r8[0x0],r9
								break;
80004b4c:	e0 8f 03 6d 	bral	80005226 <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004b50:	fe f8 06 f4 	ld.w	r8,pc[1780]
80004b54:	70 08       	ld.w	r8,r8[0x0]
80004b56:	f0 c9 00 01 	sub	r9,r8,1
80004b5a:	fe f8 06 ea 	ld.w	r8,pc[1770]
80004b5e:	91 09       	st.w	r8[0x0],r9
80004b60:	fe f8 06 e4 	ld.w	r8,pc[1764]
80004b64:	70 08       	ld.w	r8,r8[0x0]
80004b66:	58 08       	cp.w	r8,0
80004b68:	c0 71       	brne	80004b76 <phy_payload_rx+0x7ba>
							RxMediaState = WAITINGABAB;
80004b6a:	fe f8 06 d2 	ld.w	r8,pc[1746]
80004b6e:	30 09       	mov	r9,0
80004b70:	91 09       	st.w	r8[0x0],r9
							break;
80004b72:	e0 8f 03 5a 	bral	80005226 <phy_payload_rx+0xe6a>
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
80004b76:	fe f8 06 ce 	ld.w	r8,pc[1742]
80004b7a:	70 08       	ld.w	r8,r8[0x0]
80004b7c:	f0 c9 00 01 	sub	r9,r8,1
80004b80:	fe f8 06 c4 	ld.w	r8,pc[1732]
80004b84:	91 09       	st.w	r8[0x0],r9
80004b86:	fe f8 06 be 	ld.w	r8,pc[1726]
80004b8a:	70 08       	ld.w	r8,r8[0x0]
80004b8c:	58 08       	cp.w	r8,0
80004b8e:	e0 81 03 45 	brne	80005218 <phy_payload_rx+0xe5c>
							RxMediaState = WAITINGABAB;
80004b92:	fe f8 06 aa 	ld.w	r8,pc[1706]
80004b96:	30 09       	mov	r9,0
80004b98:	91 09       	st.w	r8[0x0],r9
							break;
80004b9a:	e0 8f 03 46 	bral	80005226 <phy_payload_rx+0xe6a>
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80004b9e:	fe f8 06 b6 	ld.w	r8,pc[1718]
80004ba2:	11 88       	ld.ub	r8,r8[0x0]
80004ba4:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004ba8:	3f 38       	mov	r8,-13
80004baa:	f0 09 18 00 	cp.b	r9,r8
80004bae:	e0 81 01 a9 	brne	80004f00 <phy_payload_rx+0xb44>
					{
						//
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80004bb2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bb6:	90 08       	ld.sh	r8,r8[0x0]
80004bb8:	fe f9 06 cc 	ld.w	r9,pc[1740]
80004bbc:	b2 18       	st.h	r9[0x2],r8
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80004bbe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bc2:	90 18       	ld.sh	r8,r8[0x2]
80004bc4:	fe f9 06 c0 	ld.w	r9,pc[1728]
80004bc8:	b2 28       	st.h	r9[0x4],r8
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80004bca:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004bce:	90 28       	ld.sh	r8,r8[0x4]
80004bd0:	fe f9 06 b4 	ld.w	r9,pc[1716]
80004bd4:	b2 38       	st.h	r9[0x6],r8
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80004bd6:	fe f8 06 62 	ld.w	r8,pc[1634]
80004bda:	70 09       	ld.w	r9,r8[0x0]
80004bdc:	fe f8 06 80 	ld.w	r8,pc[1664]
80004be0:	70 08       	ld.w	r8,r8[0x0]
80004be2:	10 09       	add	r9,r8
80004be4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004be8:	11 88       	ld.ub	r8,r8[0x0]
80004bea:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80004bec:	fe f8 06 70 	ld.w	r8,pc[1648]
80004bf0:	70 08       	ld.w	r8,r8[0x0]
80004bf2:	f0 c9 ff ff 	sub	r9,r8,-1
80004bf6:	fe f8 06 66 	ld.w	r8,pc[1638]
80004bfa:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004bfc:	fe f8 06 60 	ld.w	r8,pc[1632]
80004c00:	70 08       	ld.w	r8,r8[0x0]
80004c02:	e0 48 01 ff 	cp.w	r8,511
80004c06:	e0 88 00 22 	brls	80004c4a <phy_payload_rx+0x88e>
						{
							RxAMBE_IsFillingNext8 = 0;
80004c0a:	fe f8 06 52 	ld.w	r8,pc[1618]
80004c0e:	30 09       	mov	r9,0
80004c10:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004c12:	fe f8 06 26 	ld.w	r8,pc[1574]
80004c16:	70 08       	ld.w	r8,r8[0x0]
80004c18:	10 9c       	mov	r12,r8
80004c1a:	f0 1f 01 93 	mcall	80005264 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80004c1e:	fe f8 06 12 	ld.w	r8,pc[1554]
80004c22:	70 08       	ld.w	r8,r8[0x0]
80004c24:	10 9c       	mov	r12,r8
80004c26:	f0 1f 01 84 	mcall	80005234 <phy_payload_rx+0xe78>
80004c2a:	18 98       	mov	r8,r12
80004c2c:	10 99       	mov	r9,r8
80004c2e:	fe f8 06 0a 	ld.w	r8,pc[1546]
80004c32:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80004c34:	fe f8 06 04 	ld.w	r8,pc[1540]
80004c38:	70 08       	ld.w	r8,r8[0x0]
80004c3a:	58 08       	cp.w	r8,0
80004c3c:	c0 71       	brne	80004c4a <phy_payload_rx+0x88e>
							{
								RxMediaState = WAITINGABAB;
80004c3e:	fe f8 05 fe 	ld.w	r8,pc[1534]
80004c42:	30 09       	mov	r9,0
80004c44:	91 09       	st.w	r8[0x0],r9
								break;
80004c46:	e0 8f 02 f0 	bral	80005226 <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004c4a:	fe f8 05 fa 	ld.w	r8,pc[1530]
80004c4e:	70 08       	ld.w	r8,r8[0x0]
80004c50:	f0 c9 00 01 	sub	r9,r8,1
80004c54:	fe f8 05 f0 	ld.w	r8,pc[1520]
80004c58:	91 09       	st.w	r8[0x0],r9
80004c5a:	fe f8 05 ea 	ld.w	r8,pc[1514]
80004c5e:	70 08       	ld.w	r8,r8[0x0]
80004c60:	58 08       	cp.w	r8,0
80004c62:	c0 71       	brne	80004c70 <phy_payload_rx+0x8b4>
							RxMediaState = WAITINGABAB;
80004c64:	fe f8 05 d8 	ld.w	r8,pc[1496]
80004c68:	30 09       	mov	r9,0
80004c6a:	91 09       	st.w	r8[0x0],r9
							break;
80004c6c:	e0 8f 02 dd 	bral	80005226 <phy_payload_rx+0xe6a>
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80004c70:	fe f8 05 c8 	ld.w	r8,pc[1480]
80004c74:	70 09       	ld.w	r9,r8[0x0]
80004c76:	fe f8 05 e6 	ld.w	r8,pc[1510]
80004c7a:	70 08       	ld.w	r8,r8[0x0]
80004c7c:	10 09       	add	r9,r8
80004c7e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004c82:	11 98       	ld.ub	r8,r8[0x1]
80004c84:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80004c86:	fe f8 05 d6 	ld.w	r8,pc[1494]
80004c8a:	70 08       	ld.w	r8,r8[0x0]
80004c8c:	f0 c9 ff ff 	sub	r9,r8,-1
80004c90:	fe f8 05 cc 	ld.w	r8,pc[1484]
80004c94:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004c96:	fe f8 05 c6 	ld.w	r8,pc[1478]
80004c9a:	70 08       	ld.w	r8,r8[0x0]
80004c9c:	e0 48 01 ff 	cp.w	r8,511
80004ca0:	e0 88 00 22 	brls	80004ce4 <phy_payload_rx+0x928>
						{
							RxAMBE_IsFillingNext8 = 0;
80004ca4:	fe f8 05 b8 	ld.w	r8,pc[1464]
80004ca8:	30 09       	mov	r9,0
80004caa:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004cac:	fe f8 05 8c 	ld.w	r8,pc[1420]
80004cb0:	70 08       	ld.w	r8,r8[0x0]
80004cb2:	10 9c       	mov	r12,r8
80004cb4:	f0 1f 01 6c 	mcall	80005264 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80004cb8:	fe f8 05 78 	ld.w	r8,pc[1400]
80004cbc:	70 08       	ld.w	r8,r8[0x0]
80004cbe:	10 9c       	mov	r12,r8
80004cc0:	f0 1f 01 5d 	mcall	80005234 <phy_payload_rx+0xe78>
80004cc4:	18 98       	mov	r8,r12
80004cc6:	10 99       	mov	r9,r8
80004cc8:	fe f8 05 70 	ld.w	r8,pc[1392]
80004ccc:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80004cce:	fe f8 05 6a 	ld.w	r8,pc[1386]
80004cd2:	70 08       	ld.w	r8,r8[0x0]
80004cd4:	58 08       	cp.w	r8,0
80004cd6:	c0 71       	brne	80004ce4 <phy_payload_rx+0x928>
							{
								RxMediaState = WAITINGABAB;
80004cd8:	fe f8 05 64 	ld.w	r8,pc[1380]
80004cdc:	30 09       	mov	r9,0
80004cde:	91 09       	st.w	r8[0x0],r9
								break;
80004ce0:	e0 8f 02 a3 	bral	80005226 <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004ce4:	fe f8 05 60 	ld.w	r8,pc[1376]
80004ce8:	70 08       	ld.w	r8,r8[0x0]
80004cea:	f0 c9 00 01 	sub	r9,r8,1
80004cee:	fe f8 05 56 	ld.w	r8,pc[1366]
80004cf2:	91 09       	st.w	r8[0x0],r9
80004cf4:	fe f8 05 50 	ld.w	r8,pc[1360]
80004cf8:	70 08       	ld.w	r8,r8[0x0]
80004cfa:	58 08       	cp.w	r8,0
80004cfc:	c0 71       	brne	80004d0a <phy_payload_rx+0x94e>
							RxMediaState = WAITINGABAB;
80004cfe:	fe f8 05 3e 	ld.w	r8,pc[1342]
80004d02:	30 09       	mov	r9,0
80004d04:	91 09       	st.w	r8[0x0],r9
							break;
80004d06:	e0 8f 02 90 	bral	80005226 <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80004d0a:	fe f8 05 2e 	ld.w	r8,pc[1326]
80004d0e:	70 09       	ld.w	r9,r8[0x0]
80004d10:	fe f8 05 4c 	ld.w	r8,pc[1356]
80004d14:	70 08       	ld.w	r8,r8[0x0]
80004d16:	10 09       	add	r9,r8
80004d18:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004d1c:	11 a8       	ld.ub	r8,r8[0x2]
80004d1e:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80004d20:	fe f8 05 3c 	ld.w	r8,pc[1340]
80004d24:	70 08       	ld.w	r8,r8[0x0]
80004d26:	f0 c9 ff ff 	sub	r9,r8,-1
80004d2a:	fe f8 05 32 	ld.w	r8,pc[1330]
80004d2e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004d30:	fe f8 05 2c 	ld.w	r8,pc[1324]
80004d34:	70 08       	ld.w	r8,r8[0x0]
80004d36:	e0 48 01 ff 	cp.w	r8,511
80004d3a:	e0 88 00 22 	brls	80004d7e <phy_payload_rx+0x9c2>
						{
							RxAMBE_IsFillingNext8 = 0;
80004d3e:	fe f8 05 1e 	ld.w	r8,pc[1310]
80004d42:	30 09       	mov	r9,0
80004d44:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004d46:	fe f8 04 f2 	ld.w	r8,pc[1266]
80004d4a:	70 08       	ld.w	r8,r8[0x0]
80004d4c:	10 9c       	mov	r12,r8
80004d4e:	f0 1f 01 46 	mcall	80005264 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80004d52:	fe f8 04 de 	ld.w	r8,pc[1246]
80004d56:	70 08       	ld.w	r8,r8[0x0]
80004d58:	10 9c       	mov	r12,r8
80004d5a:	f0 1f 01 37 	mcall	80005234 <phy_payload_rx+0xe78>
80004d5e:	18 98       	mov	r8,r12
80004d60:	10 99       	mov	r9,r8
80004d62:	fe f8 04 d6 	ld.w	r8,pc[1238]
80004d66:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80004d68:	fe f8 04 d0 	ld.w	r8,pc[1232]
80004d6c:	70 08       	ld.w	r8,r8[0x0]
80004d6e:	58 08       	cp.w	r8,0
80004d70:	c0 71       	brne	80004d7e <phy_payload_rx+0x9c2>
							{
								RxMediaState = WAITINGABAB;
80004d72:	fe f8 04 ca 	ld.w	r8,pc[1226]
80004d76:	30 09       	mov	r9,0
80004d78:	91 09       	st.w	r8[0x0],r9
								break;
80004d7a:	e0 8f 02 56 	bral	80005226 <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004d7e:	fe f8 04 c6 	ld.w	r8,pc[1222]
80004d82:	70 08       	ld.w	r8,r8[0x0]
80004d84:	f0 c9 00 01 	sub	r9,r8,1
80004d88:	fe f8 04 bc 	ld.w	r8,pc[1212]
80004d8c:	91 09       	st.w	r8[0x0],r9
80004d8e:	fe f8 04 b6 	ld.w	r8,pc[1206]
80004d92:	70 08       	ld.w	r8,r8[0x0]
80004d94:	58 08       	cp.w	r8,0
80004d96:	c0 71       	brne	80004da4 <phy_payload_rx+0x9e8>
							RxMediaState = WAITINGABAB;
80004d98:	fe f8 04 a4 	ld.w	r8,pc[1188]
80004d9c:	30 09       	mov	r9,0
80004d9e:	91 09       	st.w	r8[0x0],r9
							break;
80004da0:	e0 8f 02 43 	bral	80005226 <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80004da4:	fe f8 04 94 	ld.w	r8,pc[1172]
80004da8:	70 09       	ld.w	r9,r8[0x0]
80004daa:	fe f8 04 b2 	ld.w	r8,pc[1202]
80004dae:	70 08       	ld.w	r8,r8[0x0]
80004db0:	10 09       	add	r9,r8
80004db2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004db6:	11 b8       	ld.ub	r8,r8[0x3]
80004db8:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80004dba:	fe f8 04 a2 	ld.w	r8,pc[1186]
80004dbe:	70 08       	ld.w	r8,r8[0x0]
80004dc0:	f0 c9 ff ff 	sub	r9,r8,-1
80004dc4:	fe f8 04 98 	ld.w	r8,pc[1176]
80004dc8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004dca:	fe f8 04 92 	ld.w	r8,pc[1170]
80004dce:	70 08       	ld.w	r8,r8[0x0]
80004dd0:	e0 48 01 ff 	cp.w	r8,511
80004dd4:	e0 88 00 22 	brls	80004e18 <phy_payload_rx+0xa5c>
						{
							RxAMBE_IsFillingNext8 = 0;
80004dd8:	fe f8 04 84 	ld.w	r8,pc[1156]
80004ddc:	30 09       	mov	r9,0
80004dde:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004de0:	fe f8 04 58 	ld.w	r8,pc[1112]
80004de4:	70 08       	ld.w	r8,r8[0x0]
80004de6:	10 9c       	mov	r12,r8
80004de8:	f0 1f 01 1f 	mcall	80005264 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80004dec:	fe f8 04 44 	ld.w	r8,pc[1092]
80004df0:	70 08       	ld.w	r8,r8[0x0]
80004df2:	10 9c       	mov	r12,r8
80004df4:	f0 1f 01 10 	mcall	80005234 <phy_payload_rx+0xe78>
80004df8:	18 98       	mov	r8,r12
80004dfa:	10 99       	mov	r9,r8
80004dfc:	fe f8 04 3c 	ld.w	r8,pc[1084]
80004e00:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80004e02:	fe f8 04 36 	ld.w	r8,pc[1078]
80004e06:	70 08       	ld.w	r8,r8[0x0]
80004e08:	58 08       	cp.w	r8,0
80004e0a:	c0 71       	brne	80004e18 <phy_payload_rx+0xa5c>
							{
								RxMediaState = WAITINGABAB;
80004e0c:	fe f8 04 30 	ld.w	r8,pc[1072]
80004e10:	30 09       	mov	r9,0
80004e12:	91 09       	st.w	r8[0x0],r9
								break;
80004e14:	e0 8f 02 09 	bral	80005226 <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004e18:	fe f8 04 2c 	ld.w	r8,pc[1068]
80004e1c:	70 08       	ld.w	r8,r8[0x0]
80004e1e:	f0 c9 00 01 	sub	r9,r8,1
80004e22:	fe f8 04 22 	ld.w	r8,pc[1058]
80004e26:	91 09       	st.w	r8[0x0],r9
80004e28:	fe f8 04 1c 	ld.w	r8,pc[1052]
80004e2c:	70 08       	ld.w	r8,r8[0x0]
80004e2e:	58 08       	cp.w	r8,0
80004e30:	c0 71       	brne	80004e3e <phy_payload_rx+0xa82>
							RxMediaState = WAITINGABAB;
80004e32:	fe f8 04 0a 	ld.w	r8,pc[1034]
80004e36:	30 09       	mov	r9,0
80004e38:	91 09       	st.w	r8[0x0],r9
							break;
80004e3a:	e0 8f 01 f6 	bral	80005226 <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80004e3e:	fe f8 03 fa 	ld.w	r8,pc[1018]
80004e42:	70 09       	ld.w	r9,r8[0x0]
80004e44:	fe f8 04 18 	ld.w	r8,pc[1048]
80004e48:	70 08       	ld.w	r8,r8[0x0]
80004e4a:	10 09       	add	r9,r8
80004e4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e50:	11 c8       	ld.ub	r8,r8[0x4]
80004e52:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80004e54:	fe f8 04 08 	ld.w	r8,pc[1032]
80004e58:	70 08       	ld.w	r8,r8[0x0]
80004e5a:	f0 c9 ff ff 	sub	r9,r8,-1
80004e5e:	fe f8 03 fe 	ld.w	r8,pc[1022]
80004e62:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004e64:	fe f8 03 f8 	ld.w	r8,pc[1016]
80004e68:	70 08       	ld.w	r8,r8[0x0]
80004e6a:	e0 48 01 ff 	cp.w	r8,511
80004e6e:	e0 88 00 22 	brls	80004eb2 <phy_payload_rx+0xaf6>
						{
							RxAMBE_IsFillingNext8 = 0;
80004e72:	fe f8 03 ea 	ld.w	r8,pc[1002]
80004e76:	30 09       	mov	r9,0
80004e78:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004e7a:	fe f8 03 be 	ld.w	r8,pc[958]
80004e7e:	70 08       	ld.w	r8,r8[0x0]
80004e80:	10 9c       	mov	r12,r8
80004e82:	f0 1f 00 f9 	mcall	80005264 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80004e86:	fe f8 03 aa 	ld.w	r8,pc[938]
80004e8a:	70 08       	ld.w	r8,r8[0x0]
80004e8c:	10 9c       	mov	r12,r8
80004e8e:	f0 1f 00 ea 	mcall	80005234 <phy_payload_rx+0xe78>
80004e92:	18 98       	mov	r8,r12
80004e94:	10 99       	mov	r9,r8
80004e96:	fe f8 03 a2 	ld.w	r8,pc[930]
80004e9a:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80004e9c:	fe f8 03 9c 	ld.w	r8,pc[924]
80004ea0:	70 08       	ld.w	r8,r8[0x0]
80004ea2:	58 08       	cp.w	r8,0
80004ea4:	c0 71       	brne	80004eb2 <phy_payload_rx+0xaf6>
							{
								RxMediaState = WAITINGABAB;
80004ea6:	fe f8 03 96 	ld.w	r8,pc[918]
80004eaa:	30 09       	mov	r9,0
80004eac:	91 09       	st.w	r8[0x0],r9
								break;
80004eae:	e0 8f 01 bc 	bral	80005226 <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004eb2:	fe f8 03 92 	ld.w	r8,pc[914]
80004eb6:	70 08       	ld.w	r8,r8[0x0]
80004eb8:	f0 c9 00 01 	sub	r9,r8,1
80004ebc:	fe f8 03 88 	ld.w	r8,pc[904]
80004ec0:	91 09       	st.w	r8[0x0],r9
80004ec2:	fe f8 03 82 	ld.w	r8,pc[898]
80004ec6:	70 08       	ld.w	r8,r8[0x0]
80004ec8:	58 08       	cp.w	r8,0
80004eca:	c0 71       	brne	80004ed8 <phy_payload_rx+0xb1c>
							RxMediaState = WAITINGABAB;
80004ecc:	fe f8 03 70 	ld.w	r8,pc[880]
80004ed0:	30 09       	mov	r9,0
80004ed2:	91 09       	st.w	r8[0x0],r9
							break;
80004ed4:	e0 8f 01 a9 	bral	80005226 <phy_payload_rx+0xe6a>
						}
						
						//AMBE Vocoder Bits Stream(bit59~63),
						if ((RxBytesWaiting -= 1) <= 0){
80004ed8:	fe f8 03 6c 	ld.w	r8,pc[876]
80004edc:	70 08       	ld.w	r8,r8[0x0]
80004ede:	f0 c9 00 01 	sub	r9,r8,1
80004ee2:	fe f8 03 62 	ld.w	r8,pc[866]
80004ee6:	91 09       	st.w	r8[0x0],r9
80004ee8:	fe f8 03 5c 	ld.w	r8,pc[860]
80004eec:	70 08       	ld.w	r8,r8[0x0]
80004eee:	58 08       	cp.w	r8,0
80004ef0:	e0 81 01 96 	brne	8000521c <phy_payload_rx+0xe60>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80004ef4:	fe f8 03 48 	ld.w	r8,pc[840]
80004ef8:	30 09       	mov	r9,0
80004efa:	91 09       	st.w	r8[0x0],r9
							break;
80004efc:	e0 8f 01 95 	bral	80005226 <phy_payload_rx+0xe6a>
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004f00:	fe f8 03 54 	ld.w	r8,pc[852]
80004f04:	11 88       	ld.ub	r8,r8[0x0]
80004f06:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004f0a:	30 48       	mov	r8,4
80004f0c:	f0 09 18 00 	cp.b	r9,r8
80004f10:	c0 a0       	breq	80004f24 <phy_payload_rx+0xb68>
80004f12:	fe f8 03 42 	ld.w	r8,pc[834]
80004f16:	11 88       	ld.ub	r8,r8[0x0]
80004f18:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004f1c:	30 38       	mov	r8,3
80004f1e:	f0 09 18 00 	cp.b	r9,r8
80004f22:	c2 51       	brne	80004f6c <phy_payload_rx+0xbb0>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004f24:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f28:	70 09       	ld.w	r9,r8[0x0]
80004f2a:	fe f8 03 52 	ld.w	r8,pc[850]
80004f2e:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004f30:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f34:	70 19       	ld.w	r9,r8[0x4]
80004f36:	fe f8 03 46 	ld.w	r8,pc[838]
80004f3a:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004f3c:	fe f8 03 08 	ld.w	r8,pc[776]
80004f40:	70 08       	ld.w	r8,r8[0x0]
80004f42:	f0 c9 00 08 	sub	r9,r8,8
80004f46:	fe f8 02 fe 	ld.w	r8,pc[766]
80004f4a:	91 09       	st.w	r8[0x0],r9
80004f4c:	fe f8 02 f8 	ld.w	r8,pc[760]
80004f50:	70 08       	ld.w	r8,r8[0x0]
80004f52:	58 08       	cp.w	r8,0
80004f54:	e0 81 01 66 	brne	80005220 <phy_payload_rx+0xe64>
						{
					
							RxBytesWaiting = 0;
80004f58:	fe f8 02 ec 	ld.w	r8,pc[748]
80004f5c:	30 09       	mov	r9,0
80004f5e:	91 09       	st.w	r8[0x0],r9
							RxMediaState = WAITINGABAB;
80004f60:	fe f8 02 dc 	ld.w	r8,pc[732]
80004f64:	30 09       	mov	r9,0
80004f66:	91 09       	st.w	r8[0x0],r9
							break;
80004f68:	e0 8f 01 5f 	bral	80005226 <phy_payload_rx+0xe6a>
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80004f6c:	fe f8 02 e8 	ld.w	r8,pc[744]
80004f70:	11 88       	ld.ub	r8,r8[0x0]
80004f72:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80004f76:	31 38       	mov	r8,19
80004f78:	f0 09 18 00 	cp.b	r9,r8
80004f7c:	e0 81 00 ea 	brne	80005150 <phy_payload_rx+0xd94>
					{							
						if (SDV_Index == 12)
80004f80:	fe f8 03 08 	ld.w	r8,pc[776]
80004f84:	11 89       	ld.ub	r9,r8[0x0]
80004f86:	30 c8       	mov	r8,12
80004f88:	f0 09 18 00 	cp.b	r9,r8
80004f8c:	e0 81 00 b4 	brne	800050f4 <phy_payload_rx+0xd38>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80004f90:	fe f8 02 f8 	ld.w	r8,pc[760]
80004f94:	11 88       	ld.ub	r8,r8[0x0]
80004f96:	10 9a       	mov	r10,r8
80004f98:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f9c:	90 08       	ld.sh	r8,r8[0x0]
80004f9e:	fe f9 02 ee 	ld.w	r9,pc[750]
80004fa2:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							
							SDV_Index = 0;
80004fa6:	fe f9 02 e2 	ld.w	r9,pc[738]
80004faa:	30 08       	mov	r8,0
80004fac:	b2 88       	st.b	r9[0x0],r8
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
80004fae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fb2:	11 d9       	ld.ub	r9,r8[0x5]
80004fb4:	3f 38       	mov	r8,-13
80004fb6:	f0 09 18 00 	cp.b	r9,r8
80004fba:	e0 81 00 99 	brne	800050ec <phy_payload_rx+0xd30>
							{
									Item_ID = Pre_Voice_Decoder_Data;
80004fbe:	fe f9 02 96 	ld.w	r9,pc[662]
80004fc2:	3f 38       	mov	r8,-13
80004fc4:	b2 88       	st.b	r9[0x0],r8
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80004fc6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fca:	11 c8       	ld.ub	r8,r8[0x4]
80004fcc:	f3 d8 c0 07 	bfextu	r9,r8,0x0,0x7
80004fd0:	fe f8 02 74 	ld.w	r8,pc[628]
80004fd4:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//AMBE
80004fd6:	fe f9 02 ba 	ld.w	r9,pc[698]
80004fda:	30 18       	mov	r8,1
80004fdc:	b2 88       	st.b	r9[0x0],r8
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//
80004fde:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004fe2:	90 38       	ld.sh	r8,r8[0x6]
80004fe4:	fe f9 02 a0 	ld.w	r9,pc[672]
80004fe8:	b2 08       	st.h	r9[0x0],r8
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80004fea:	fe f8 02 4e 	ld.w	r8,pc[590]
80004fee:	70 09       	ld.w	r9,r8[0x0]
80004ff0:	fe f8 02 6c 	ld.w	r8,pc[620]
80004ff4:	70 08       	ld.w	r8,r8[0x0]
80004ff6:	10 09       	add	r9,r8
80004ff8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ffc:	11 e8       	ld.ub	r8,r8[0x6]
80004ffe:	b2 88       	st.b	r9[0x0],r8
									RxAMBE_IsFillingNext8 += 1;
80005000:	fe f8 02 5c 	ld.w	r8,pc[604]
80005004:	70 08       	ld.w	r8,r8[0x0]
80005006:	f0 c9 ff ff 	sub	r9,r8,-1
8000500a:	fe f8 02 52 	ld.w	r8,pc[594]
8000500e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005010:	fe f8 02 4c 	ld.w	r8,pc[588]
80005014:	70 08       	ld.w	r8,r8[0x0]
80005016:	e0 48 01 ff 	cp.w	r8,511
8000501a:	e0 88 00 1e 	brls	80005056 <phy_payload_rx+0xc9a>
									{
										RxAMBE_IsFillingNext8 = 0;
8000501e:	fe f8 02 3e 	ld.w	r8,pc[574]
80005022:	30 09       	mov	r9,0
80005024:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80005026:	fe f8 02 12 	ld.w	r8,pc[530]
8000502a:	70 08       	ld.w	r8,r8[0x0]
8000502c:	10 9c       	mov	r12,r8
8000502e:	f0 1f 00 8e 	mcall	80005264 <phy_payload_rx+0xea8>
										AMBE_payload_ptr = get_payload_idle_isr();
80005032:	fe f8 01 fe 	ld.w	r8,pc[510]
80005036:	70 08       	ld.w	r8,r8[0x0]
80005038:	10 9c       	mov	r12,r8
8000503a:	f0 1f 00 7f 	mcall	80005234 <phy_payload_rx+0xe78>
8000503e:	18 98       	mov	r8,r12
80005040:	10 99       	mov	r9,r8
80005042:	4f e8       	lddpc	r8,80005238 <phy_payload_rx+0xe7c>
80005044:	91 09       	st.w	r8[0x0],r9
										if(NULL == AMBE_payload_ptr)
80005046:	4f d8       	lddpc	r8,80005238 <phy_payload_rx+0xe7c>
80005048:	70 08       	ld.w	r8,r8[0x0]
8000504a:	58 08       	cp.w	r8,0
8000504c:	c0 51       	brne	80005056 <phy_payload_rx+0xc9a>
										{
											RxMediaState = WAITINGABAB;
8000504e:	4f c8       	lddpc	r8,8000523c <phy_payload_rx+0xe80>
80005050:	30 09       	mov	r9,0
80005052:	91 09       	st.w	r8[0x0],r9
											break;
80005054:	ce 98       	rjmp	80005226 <phy_payload_rx+0xe6a>
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80005056:	4f c8       	lddpc	r8,80005244 <phy_payload_rx+0xe88>
80005058:	70 08       	ld.w	r8,r8[0x0]
8000505a:	f0 c9 00 01 	sub	r9,r8,1
8000505e:	4f a8       	lddpc	r8,80005244 <phy_payload_rx+0xe88>
80005060:	91 09       	st.w	r8[0x0],r9
80005062:	4f 98       	lddpc	r8,80005244 <phy_payload_rx+0xe88>
80005064:	70 08       	ld.w	r8,r8[0x0]
80005066:	58 08       	cp.w	r8,0
80005068:	c0 51       	brne	80005072 <phy_payload_rx+0xcb6>
										RxMediaState = WAITINGABAB;
8000506a:	4f 58       	lddpc	r8,8000523c <phy_payload_rx+0xe80>
8000506c:	30 09       	mov	r9,0
8000506e:	91 09       	st.w	r8[0x0],r9
										break;
80005070:	cd b8       	rjmp	80005226 <phy_payload_rx+0xe6a>
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80005072:	4f 28       	lddpc	r8,80005238 <phy_payload_rx+0xe7c>
80005074:	70 09       	ld.w	r9,r8[0x0]
80005076:	4f a8       	lddpc	r8,8000525c <phy_payload_rx+0xea0>
80005078:	70 08       	ld.w	r8,r8[0x0]
8000507a:	10 09       	add	r9,r8
8000507c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005080:	11 f8       	ld.ub	r8,r8[0x7]
80005082:	b2 88       	st.b	r9[0x0],r8
									RxAMBE_IsFillingNext8 += 1;
80005084:	4f 68       	lddpc	r8,8000525c <phy_payload_rx+0xea0>
80005086:	70 08       	ld.w	r8,r8[0x0]
80005088:	f0 c9 ff ff 	sub	r9,r8,-1
8000508c:	4f 48       	lddpc	r8,8000525c <phy_payload_rx+0xea0>
8000508e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005090:	4f 38       	lddpc	r8,8000525c <phy_payload_rx+0xea0>
80005092:	70 08       	ld.w	r8,r8[0x0]
80005094:	e0 48 01 ff 	cp.w	r8,511
80005098:	e0 88 00 1b 	brls	800050ce <phy_payload_rx+0xd12>
									{
										RxAMBE_IsFillingNext8 = 0;
8000509c:	4f 08       	lddpc	r8,8000525c <phy_payload_rx+0xea0>
8000509e:	30 09       	mov	r9,0
800050a0:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800050a2:	4e 68       	lddpc	r8,80005238 <phy_payload_rx+0xe7c>
800050a4:	70 08       	ld.w	r8,r8[0x0]
800050a6:	10 9c       	mov	r12,r8
800050a8:	f0 1f 00 6f 	mcall	80005264 <phy_payload_rx+0xea8>
										AMBE_payload_ptr = get_payload_idle_isr();
800050ac:	4e 18       	lddpc	r8,80005230 <phy_payload_rx+0xe74>
800050ae:	70 08       	ld.w	r8,r8[0x0]
800050b0:	10 9c       	mov	r12,r8
800050b2:	f0 1f 00 61 	mcall	80005234 <phy_payload_rx+0xe78>
800050b6:	18 98       	mov	r8,r12
800050b8:	10 99       	mov	r9,r8
800050ba:	4e 08       	lddpc	r8,80005238 <phy_payload_rx+0xe7c>
800050bc:	91 09       	st.w	r8[0x0],r9
										if(NULL == AMBE_payload_ptr)
800050be:	4d f8       	lddpc	r8,80005238 <phy_payload_rx+0xe7c>
800050c0:	70 08       	ld.w	r8,r8[0x0]
800050c2:	58 08       	cp.w	r8,0
800050c4:	c0 51       	brne	800050ce <phy_payload_rx+0xd12>
										{
											RxMediaState = WAITINGABAB;
800050c6:	4d e8       	lddpc	r8,8000523c <phy_payload_rx+0xe80>
800050c8:	30 09       	mov	r9,0
800050ca:	91 09       	st.w	r8[0x0],r9
											break;
800050cc:	ca d8       	rjmp	80005226 <phy_payload_rx+0xe6a>
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800050ce:	4d e8       	lddpc	r8,80005244 <phy_payload_rx+0xe88>
800050d0:	70 08       	ld.w	r8,r8[0x0]
800050d2:	f0 c9 00 01 	sub	r9,r8,1
800050d6:	4d c8       	lddpc	r8,80005244 <phy_payload_rx+0xe88>
800050d8:	91 09       	st.w	r8[0x0],r9
800050da:	4d b8       	lddpc	r8,80005244 <phy_payload_rx+0xe88>
800050dc:	70 08       	ld.w	r8,r8[0x0]
800050de:	58 08       	cp.w	r8,0
800050e0:	e0 81 00 a2 	brne	80005224 <phy_payload_rx+0xe68>
										RxMediaState = WAITINGABAB;
800050e4:	4d 68       	lddpc	r8,8000523c <phy_payload_rx+0xe80>
800050e6:	30 09       	mov	r9,0
800050e8:	91 09       	st.w	r8[0x0],r9
										break;
800050ea:	c9 e8       	rjmp	80005226 <phy_payload_rx+0xe6a>
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
800050ec:	4d 48       	lddpc	r8,8000523c <phy_payload_rx+0xe80>
800050ee:	30 09       	mov	r9,0
800050f0:	91 09       	st.w	r8[0x0],r9
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
							SDV_Index +=4;
									
						}
							
							break;
800050f2:	c9 a8       	rjmp	80005226 <phy_payload_rx+0xe6a>
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
800050f4:	4e 58       	lddpc	r8,80005288 <phy_payload_rx+0xecc>
800050f6:	11 88       	ld.ub	r8,r8[0x0]
800050f8:	10 9a       	mov	r10,r8
800050fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050fe:	90 08       	ld.sh	r8,r8[0x0]
80005100:	4e 39       	lddpc	r9,8000528c <phy_payload_rx+0xed0>
80005102:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80005106:	4e 18       	lddpc	r8,80005288 <phy_payload_rx+0xecc>
80005108:	11 88       	ld.ub	r8,r8[0x0]
8000510a:	f0 ca ff ff 	sub	r10,r8,-1
8000510e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005112:	90 18       	ld.sh	r8,r8[0x2]
80005114:	4d e9       	lddpc	r9,8000528c <phy_payload_rx+0xed0>
80005116:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
8000511a:	4d c8       	lddpc	r8,80005288 <phy_payload_rx+0xecc>
8000511c:	11 88       	ld.ub	r8,r8[0x0]
8000511e:	f0 ca ff fe 	sub	r10,r8,-2
80005122:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005126:	90 28       	ld.sh	r8,r8[0x4]
80005128:	4d 99       	lddpc	r9,8000528c <phy_payload_rx+0xed0>
8000512a:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
8000512e:	4d 78       	lddpc	r8,80005288 <phy_payload_rx+0xecc>
80005130:	11 88       	ld.ub	r8,r8[0x0]
80005132:	f0 ca ff fd 	sub	r10,r8,-3
80005136:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000513a:	90 38       	ld.sh	r8,r8[0x6]
8000513c:	4d 49       	lddpc	r9,8000528c <phy_payload_rx+0xed0>
8000513e:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							SDV_Index +=4;
80005142:	4d 28       	lddpc	r8,80005288 <phy_payload_rx+0xecc>
80005144:	11 88       	ld.ub	r8,r8[0x0]
80005146:	2f c8       	sub	r8,-4
80005148:	5c 58       	castu.b	r8
8000514a:	4d 09       	lddpc	r9,80005288 <phy_payload_rx+0xecc>
8000514c:	b2 88       	st.b	r9[0x0],r8
									
						}
							
							break;
8000514e:	c6 c8       	rjmp	80005226 <phy_payload_rx+0xe6a>
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80005150:	4b b8       	lddpc	r8,8000523c <phy_payload_rx+0xe80>
80005152:	30 09       	mov	r9,0
80005154:	91 09       	st.w	r8[0x0],r9
						break;
80005156:	c6 88       	rjmp	80005226 <phy_payload_rx+0xe6a>
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80005158:	4c 78       	lddpc	r8,80005274 <phy_payload_rx+0xeb8>
8000515a:	70 0a       	ld.w	r10,r8[0x0]
8000515c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005160:	90 08       	ld.sh	r8,r8[0x0]
80005162:	4c 69       	lddpc	r9,80005278 <phy_payload_rx+0xebc>
80005164:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
				RxData_IsFillingNext16 += 1;
80005168:	4c 38       	lddpc	r8,80005274 <phy_payload_rx+0xeb8>
8000516a:	70 08       	ld.w	r8,r8[0x0]
8000516c:	f0 c9 ff ff 	sub	r9,r8,-1
80005170:	4c 18       	lddpc	r8,80005274 <phy_payload_rx+0xeb8>
80005172:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80005174:	4b 98       	lddpc	r8,80005258 <phy_payload_rx+0xe9c>
80005176:	70 08       	ld.w	r8,r8[0x0]
80005178:	f0 c9 00 02 	sub	r9,r8,2
8000517c:	4b 78       	lddpc	r8,80005258 <phy_payload_rx+0xe9c>
8000517e:	91 09       	st.w	r8[0x0],r9
80005180:	4b 68       	lddpc	r8,80005258 <phy_payload_rx+0xe9c>
80005182:	70 08       	ld.w	r8,r8[0x0]
80005184:	58 08       	cp.w	r8,0
80005186:	c3 e1       	brne	80005202 <phy_payload_rx+0xe46>
				{
					RxData_IsFillingNext16 = 0;
80005188:	4b b8       	lddpc	r8,80005274 <phy_payload_rx+0xeb8>
8000518a:	30 09       	mov	r9,0
8000518c:	91 09       	st.w	r8[0x0],r9
				
					if (payload_rx_channel->word[1] == 0x8212 )
8000518e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005192:	90 19       	ld.sh	r9,r8[0x2]
80005194:	fe 78 82 12 	mov	r8,-32238
80005198:	f0 09 19 00 	cp.h	r9,r8
8000519c:	c2 f1       	brne	800051fa <phy_payload_rx+0xe3e>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
8000519e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800051a2:	11 d8       	ld.ub	r8,r8[0x5]
800051a4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800051a8:	4b 09       	lddpc	r9,80005268 <phy_payload_rx+0xeac>
800051aa:	b2 88       	st.b	r9[0x0],r8
							
						VBSP_data[0] = payload_rx_channel->word[1];
800051ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800051b0:	90 18       	ld.sh	r8,r8[0x2]
800051b2:	4a f9       	lddpc	r9,8000526c <phy_payload_rx+0xeb0>
800051b4:	b2 08       	st.h	r9[0x0],r8
						VBSP_data[1] = payload_rx_channel->word[2];
800051b6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800051ba:	90 28       	ld.sh	r8,r8[0x4]
800051bc:	4a c9       	lddpc	r9,8000526c <phy_payload_rx+0xeb0>
800051be:	b2 18       	st.h	r9[0x2],r8
							
						m_RxBurstType = CalculateBurst(VF_SN);
800051c0:	4a a8       	lddpc	r8,80005268 <phy_payload_rx+0xeac>
800051c2:	11 88       	ld.ub	r8,r8[0x0]
800051c4:	10 9c       	mov	r12,r8
800051c6:	f0 1f 00 2b 	mcall	80005270 <phy_payload_rx+0xeb4>
800051ca:	18 99       	mov	r9,r12
800051cc:	49 d8       	lddpc	r8,80005240 <phy_payload_rx+0xe84>
800051ce:	91 09       	st.w	r8[0x0],r9
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
800051d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800051d4:	11 f9       	ld.ub	r9,r8[0x7]
800051d6:	31 38       	mov	r8,19
800051d8:	f0 09 18 00 	cp.b	r9,r8
800051dc:	c0 81       	brne	800051ec <phy_payload_rx+0xe30>
						{
							Item_ID = Soft_Decision_Value;	
800051de:	49 e9       	lddpc	r9,80005254 <phy_payload_rx+0xe98>
800051e0:	31 38       	mov	r8,19
800051e2:	b2 88       	st.b	r9[0x0],r8
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
800051e4:	49 88       	lddpc	r8,80005244 <phy_payload_rx+0xe88>
800051e6:	30 09       	mov	r9,0
800051e8:	91 09       	st.w	r8[0x0],r9
800051ea:	c0 48       	rjmp	800051f2 <phy_payload_rx+0xe36>
						}
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
800051ec:	49 48       	lddpc	r8,8000523c <phy_payload_rx+0xe80>
800051ee:	30 09       	mov	r9,0
800051f0:	91 09       	st.w	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
800051f2:	49 38       	lddpc	r8,8000523c <phy_payload_rx+0xe80>
800051f4:	30 49       	mov	r9,4
800051f6:	91 09       	st.w	r8[0x0],r9
800051f8:	c1 78       	rjmp	80005226 <phy_payload_rx+0xe6a>
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
800051fa:	49 18       	lddpc	r8,8000523c <phy_payload_rx+0xe80>
800051fc:	30 09       	mov	r9,0
800051fe:	91 09       	st.w	r8[0x0],r9
80005200:	c1 38       	rjmp	80005226 <phy_payload_rx+0xe6a>
					}

				}
				else
				{//
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80005202:	4a 5c       	lddpc	r12,80005294 <phy_payload_rx+0xed8>
80005204:	f0 1f 00 12 	mcall	8000524c <phy_payload_rx+0xe90>
					RxMediaState = WAITINGABAB;//Jump
80005208:	48 d8       	lddpc	r8,8000523c <phy_payload_rx+0xe80>
8000520a:	30 09       	mov	r9,0
8000520c:	91 09       	st.w	r8[0x0],r9
8000520e:	c0 c8       	rjmp	80005226 <phy_payload_rx+0xe6a>
				m_RxBurstType = VOICE_WATING;
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80005210:	d7 03       	nop
80005212:	c0 a8       	rjmp	80005226 <phy_payload_rx+0xe6a>
						RxMediaState  = WAITINGABAB;
						break;
					}
			
			
			break;//End of READING_AMBE_MEDIA.
80005214:	d7 03       	nop
80005216:	c0 88       	rjmp	80005226 <phy_payload_rx+0xe6a>
80005218:	d7 03       	nop
8000521a:	c0 68       	rjmp	80005226 <phy_payload_rx+0xe6a>
8000521c:	d7 03       	nop
8000521e:	c0 48       	rjmp	80005226 <phy_payload_rx+0xe6a>
							RxBytesWaiting = 0;
							RxMediaState = WAITINGABAB;
							break;
			
						}
						break;
80005220:	d7 03       	nop
80005222:	c0 28       	rjmp	80005226 <phy_payload_rx+0xe6a>
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
							SDV_Index +=4;
									
						}
							
							break;
80005224:	d7 03       	nop

#endif
		case BGFORCERESET: //Do nothing.
		break;
	}//End of RxMedia Phy Handler.
}
80005226:	2f ed       	sub	sp,-8
80005228:	e3 cd 80 80 	ldm	sp++,r7,pc
8000522c:	00 00       	add	r0,r0
8000522e:	0a 84       	andn	r4,r5
80005230:	00 00       	add	r0,r0
80005232:	0a 6c       	and	r12,r5
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	52 d8       	stdsp	sp[0xb4],r8
80005238:	00 00       	add	r0,r0
8000523a:	0a 88       	andn	r8,r5
8000523c:	00 00       	add	r0,r0
8000523e:	0a 8c       	andn	r12,r5
80005240:	00 00       	add	r0,r0
80005242:	0a 78       	tst	r8,r5
80005244:	00 00       	add	r0,r0
80005246:	0a 90       	mov	r0,r5
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	36 00       	mov	r0,96
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	90 00       	ld.sh	r0,r8[0x0]
80005250:	00 00       	add	r0,r0
80005252:	0a 3b       	cp.w	r11,r5
80005254:	00 00       	add	r0,r0
80005256:	0a 94       	mov	r4,r5
80005258:	00 00       	add	r0,r0
8000525a:	0a 98       	mov	r8,r5
8000525c:	00 00       	add	r0,r0
8000525e:	0a 9c       	mov	r12,r5
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	98 d0       	ld.uh	r0,r12[0xa]
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	43 40       	lddsp	r0,sp[0xd0]
80005268:	00 00       	add	r0,r0
8000526a:	0a 3f       	cp.w	pc,r5
8000526c:	00 00       	add	r0,r0
8000526e:	0e 7c       	tst	r12,r7
80005270:	80 00       	ld.sh	r0,r0[0x0]
80005272:	34 c4       	mov	r4,76
80005274:	00 00       	add	r0,r0
80005276:	0a a0       	st.w	r5++,r0
80005278:	00 00       	add	r0,r0
8000527a:	0d 80       	ld.ub	r0,r6[0x0]
8000527c:	00 00       	add	r0,r0
8000527e:	0a 7c       	tst	r12,r5
80005280:	00 00       	add	r0,r0
80005282:	0a 3a       	cp.w	r10,r5
80005284:	00 00       	add	r0,r0
80005286:	0d 78       	ld.ub	r8,--r6
80005288:	00 00       	add	r0,r0
8000528a:	0a a4       	st.w	r5++,r4
8000528c:	00 00       	add	r0,r0
8000528e:	0e 80       	andn	r0,r7
80005290:	00 00       	add	r0,r0
80005292:	0a 39       	cp.w	r9,r5
80005294:	80 00       	ld.sh	r0,r0[0x0]
80005296:	36 18       	mov	r8,97

80005298 <get_idle_store>:
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80005298:	eb cd 40 80 	pushm	r7,lr
8000529c:	1a 97       	mov	r7,sp
8000529e:	20 2d       	sub	sp,8
800052a0:	ef 4c ff f8 	st.w	r7[-8],r12
	void * ptr = NULL;
800052a4:	30 08       	mov	r8,0
800052a6:	ef 48 ff fc 	st.w	r7[-4],r8

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800052aa:	ee c8 00 04 	sub	r8,r7,4
800052ae:	30 09       	mov	r9,0
800052b0:	30 0a       	mov	r10,0
800052b2:	10 9b       	mov	r11,r8
800052b4:	ee fc ff f8 	ld.w	r12,r7[-8]
800052b8:	f0 1f 00 07 	mcall	800052d4 <get_idle_store+0x3c>
800052bc:	18 98       	mov	r8,r12
800052be:	58 18       	cp.w	r8,1
800052c0:	c0 41       	brne	800052c8 <get_idle_store+0x30>
	{
		return ptr;
800052c2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052c6:	c0 28       	rjmp	800052ca <get_idle_store+0x32>
	}
	else
	{
		return NULL;
800052c8:	30 08       	mov	r8,0
	}
}
800052ca:	10 9c       	mov	r12,r8
800052cc:	2f ed       	sub	sp,-8
800052ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800052d2:	00 00       	add	r0,r0
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	76 e4       	ld.w	r4,r11[0x38]

800052d8 <get_idle_store_isr>:

void * get_idle_store_isr(xQueueHandle store)
{
800052d8:	eb cd 40 80 	pushm	r7,lr
800052dc:	1a 97       	mov	r7,sp
800052de:	20 3d       	sub	sp,12
800052e0:	ef 4c ff f4 	st.w	r7[-12],r12
	void * ptr = NULL;
800052e4:	30 08       	mov	r8,0
800052e6:	ef 48 ff fc 	st.w	r7[-4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800052ea:	30 08       	mov	r8,0
800052ec:	ef 48 ff f8 	st.w	r7[-8],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
800052f0:	ee c9 00 08 	sub	r9,r7,8
800052f4:	ee c8 00 04 	sub	r8,r7,4
800052f8:	12 9a       	mov	r10,r9
800052fa:	10 9b       	mov	r11,r8
800052fc:	ee fc ff f4 	ld.w	r12,r7[-12]
80005300:	f0 1f 00 07 	mcall	8000531c <get_idle_store_isr+0x44>
80005304:	18 98       	mov	r8,r12
80005306:	58 18       	cp.w	r8,1
80005308:	c0 41       	brne	80005310 <get_idle_store_isr+0x38>
	{
		return ptr;
8000530a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000530e:	c0 28       	rjmp	80005312 <get_idle_store_isr+0x3a>
	}
	else
	{
		return NULL;
80005310:	30 08       	mov	r8,0
	}
}
80005312:	10 9c       	mov	r12,r8
80005314:	2f dd       	sub	sp,-12
80005316:	e3 cd 80 80 	ldm	sp++,r7,pc
8000531a:	00 00       	add	r0,r0
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	78 d0       	ld.w	r0,r12[0x34]

80005320 <set_idle_store>:


void set_idle_store(xQueueHandle store, void * ptr)
{
80005320:	eb cd 40 80 	pushm	r7,lr
80005324:	1a 97       	mov	r7,sp
80005326:	20 2d       	sub	sp,8
80005328:	ef 4c ff fc 	st.w	r7[-4],r12
8000532c:	ef 4b ff f8 	st.w	r7[-8],r11
	xQueueSend(store, &ptr, 0);
80005330:	ee c8 00 08 	sub	r8,r7,8
80005334:	30 09       	mov	r9,0
80005336:	30 0a       	mov	r10,0
80005338:	10 9b       	mov	r11,r8
8000533a:	ee fc ff fc 	ld.w	r12,r7[-4]
8000533e:	f0 1f 00 03 	mcall	80005348 <set_idle_store+0x28>
}
80005342:	2f ed       	sub	sp,-8
80005344:	e3 cd 80 80 	ldm	sp++,r7,pc
80005348:	80 00       	ld.sh	r0,r0[0x0]
8000534a:	74 d8       	ld.w	r8,r10[0x34]

8000534c <set_idle_store_isr>:

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000534c:	eb cd 40 80 	pushm	r7,lr
80005350:	1a 97       	mov	r7,sp
80005352:	20 3d       	sub	sp,12
80005354:	ef 4c ff f8 	st.w	r7[-8],r12
80005358:	ef 4b ff f4 	st.w	r7[-12],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000535c:	30 08       	mov	r8,0
8000535e:	ef 48 ff fc 	st.w	r7[-4],r8
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80005362:	ee ca 00 04 	sub	r10,r7,4
80005366:	ee c8 00 0c 	sub	r8,r7,12
8000536a:	30 09       	mov	r9,0
8000536c:	10 9b       	mov	r11,r8
8000536e:	ee fc ff f8 	ld.w	r12,r7[-8]
80005372:	f0 1f 00 03 	mcall	8000537c <set_idle_store_isr+0x30>
}
80005376:	2f dd       	sub	sp,-12
80005378:	e3 cd 80 80 	ldm	sp++,r7,pc
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	76 40       	ld.w	r0,r11[0x10]

80005380 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80005380:	eb cd 40 80 	pushm	r7,lr
80005384:	1a 97       	mov	r7,sp
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80005386:	4a 98       	lddpc	r8,80005428 <pdca_int_handler+0xa8>
80005388:	11 88       	ld.ub	r8,r8[0x0]
8000538a:	5c 58       	castu.b	r8
8000538c:	ec 18 00 01 	eorl	r8,0x1
80005390:	5c 58       	castu.b	r8
80005392:	4a 69       	lddpc	r9,80005428 <pdca_int_handler+0xa8>
80005394:	b2 88       	st.b	r9[0x0],r8
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80005396:	fe 79 00 40 	mov	r9,-65472
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
8000539a:	4a 48       	lddpc	r8,80005428 <pdca_int_handler+0xa8>
8000539c:	11 88       	ld.ub	r8,r8[0x0]
8000539e:	5c 58       	castu.b	r8
800053a0:	a3 68       	lsl	r8,0x2
800053a2:	2f f8       	sub	r8,-1
800053a4:	f0 0a 15 02 	lsl	r10,r8,0x2
800053a8:	4a 18       	lddpc	r8,8000542c <pdca_int_handler+0xac>
800053aa:	f4 08 00 08 	add	r8,r10,r8
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
800053ae:	93 38       	st.w	r9[0xc],r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800053b0:	fe 78 00 40 	mov	r8,-65472
800053b4:	30 39       	mov	r9,3
800053b6:	91 49       	st.w	r8[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
800053b8:	fe 79 00 00 	mov	r9,-65536
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
800053bc:	49 b8       	lddpc	r8,80005428 <pdca_int_handler+0xa8>
800053be:	11 88       	ld.ub	r8,r8[0x0]
800053c0:	5c 58       	castu.b	r8
800053c2:	a3 68       	lsl	r8,0x2
800053c4:	2f f8       	sub	r8,-1
800053c6:	f0 0a 15 02 	lsl	r10,r8,0x2
800053ca:	49 a8       	lddpc	r8,80005430 <pdca_int_handler+0xb0>
800053cc:	f4 08 00 08 	add	r8,r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
800053d0:	93 38       	st.w	r9[0xc],r8
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800053d2:	fe 78 00 00 	mov	r8,-65536
800053d6:	30 39       	mov	r9,3
800053d8:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
800053da:	fe 78 00 00 	mov	r8,-65536
800053de:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800053e0:	49 58       	lddpc	r8,80005434 <pdca_int_handler+0xb4>
800053e2:	70 08       	ld.w	r8,r8[0x0]
800053e4:	58 08       	cp.w	r8,0
800053e6:	c0 d0       	breq	80005400 <pdca_int_handler+0x80>
800053e8:	49 38       	lddpc	r8,80005434 <pdca_int_handler+0xb4>
800053ea:	70 09       	ld.w	r9,r8[0x0]
800053ec:	48 f8       	lddpc	r8,80005428 <pdca_int_handler+0xa8>
800053ee:	11 88       	ld.ub	r8,r8[0x0]
800053f0:	5c 58       	castu.b	r8
800053f2:	f0 0a 15 04 	lsl	r10,r8,0x4
800053f6:	48 f8       	lddpc	r8,80005430 <pdca_int_handler+0xb0>
800053f8:	f4 08 00 08 	add	r8,r10,r8
800053fc:	10 9c       	mov	r12,r8
800053fe:	5d 19       	icall	r9

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80005400:	48 e8       	lddpc	r8,80005438 <pdca_int_handler+0xb8>
80005402:	70 08       	ld.w	r8,r8[0x0]
80005404:	58 08       	cp.w	r8,0
80005406:	c0 d0       	breq	80005420 <pdca_int_handler+0xa0>
80005408:	48 c8       	lddpc	r8,80005438 <pdca_int_handler+0xb8>
8000540a:	70 09       	ld.w	r9,r8[0x0]
8000540c:	48 78       	lddpc	r8,80005428 <pdca_int_handler+0xa8>
8000540e:	11 88       	ld.ub	r8,r8[0x0]
80005410:	5c 58       	castu.b	r8
80005412:	f0 0a 15 04 	lsl	r10,r8,0x4
80005416:	48 68       	lddpc	r8,8000542c <pdca_int_handler+0xac>
80005418:	f4 08 00 08 	add	r8,r10,r8
8000541c:	10 9c       	mov	r12,r8
8000541e:	5d 19       	icall	r9

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80005420:	e3 cd 40 80 	ldm	sp++,r7,lr
80005424:	d6 03       	rete
80005426:	00 00       	add	r0,r0
80005428:	00 00       	add	r0,r0
8000542a:	40 a0       	lddsp	r0,sp[0x28]
8000542c:	00 00       	add	r0,r0
8000542e:	40 c8       	lddsp	r8,sp[0x30]
80005430:	00 00       	add	r0,r0
80005432:	40 a8       	lddsp	r8,sp[0x28]
80005434:	00 00       	add	r0,r0
80005436:	0a d4       	st.w	--r5,r4
80005438:	00 00       	add	r0,r0
8000543a:	0a d8       	st.w	--r5,r8

8000543c <local_start_SSC>:
    Before using the SSC transmitter, the PIO controller must be configured to 
    dedicate the SSC,transmitter I/O lines to the SSC peripheral mode. [23.6.1]
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_SSC(void)
{
8000543c:	eb cd 40 80 	pushm	r7,lr
80005440:	1a 97       	mov	r7,sp
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80005442:	fe 78 10 00 	mov	r8,-61440
80005446:	e0 69 0d c0 	mov	r9,3520
8000544a:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
8000544e:	fe 78 10 00 	mov	r8,-61440
80005452:	e0 69 0d c0 	mov	r9,3520
80005456:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
8000545a:	fe 78 10 00 	mov	r8,-61440
8000545e:	e0 69 0d c0 	mov	r9,3520
80005462:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80005466:	fe 78 34 00 	mov	r8,-52224
8000546a:	e0 69 80 00 	mov	r9,32768
8000546e:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80005470:	fe 78 34 00 	mov	r8,-52224
80005474:	30 09       	mov	r9,0
80005476:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80005478:	fe 78 34 00 	mov	r8,-52224
8000547c:	e0 69 04 21 	mov	r9,1057
80005480:	ea 19 3f 20 	orh	r9,0x3f20
80005484:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80005486:	fe 78 34 00 	mov	r8,-52224
8000548a:	e0 69 02 9f 	mov	r9,671
8000548e:	ea 19 01 00 	orh	r9,0x100
80005492:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80005494:	fe 78 34 00 	mov	r8,-52224
80005498:	e0 69 04 02 	mov	r9,1026
8000549c:	ea 19 3f 20 	orh	r9,0x3f20
800054a0:	91 49       	st.w	r8[0x10],r9
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
800054a2:	fe 78 34 00 	mov	r8,-52224
800054a6:	e0 69 02 9f 	mov	r9,671
800054aa:	ea 19 01 00 	orh	r9,0x100
800054ae:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
800054b0:	e3 cd 80 80 	ldm	sp++,r7,pc

800054b4 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800054b4:	eb cd 40 80 	pushm	r7,lr
800054b8:	1a 97       	mov	r7,sp
    /*Toggle Index*/	
    BufferIndex = 1;
800054ba:	4b 39       	lddpc	r9,80005584 <local_start_PDC+0xd0>
800054bc:	30 18       	mov	r8,1
800054be:	b2 88       	st.b	r9[0x0],r8
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
800054c0:	fe 78 00 00 	mov	r8,-65536
800054c4:	30 79       	mov	r9,7
800054c6:	91 99       	st.w	r8[0x24],r9
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
800054c8:	fe 78 00 00 	mov	r8,-65536
800054cc:	70 b8       	ld.w	r8,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800054ce:	fe 78 00 00 	mov	r8,-65536
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
800054d2:	4a e9       	lddpc	r9,80005588 <local_start_PDC+0xd4>
800054d4:	2f c9       	sub	r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
800054d6:	91 09       	st.w	r8[0x0],r9
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
800054d8:	fe 78 00 00 	mov	r8,-65536
800054dc:	30 39       	mov	r9,3
800054de:	91 29       	st.w	r8[0x8],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
800054e0:	fe 78 00 00 	mov	r8,-65536
800054e4:	30 19       	mov	r9,1
800054e6:	91 19       	st.w	r8[0x4],r9
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800054e8:	fe 78 00 00 	mov	r8,-65536
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800054ec:	4a 79       	lddpc	r9,80005588 <local_start_PDC+0xd4>
800054ee:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800054f0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800054f2:	fe 78 00 00 	mov	r8,-65536
800054f6:	30 39       	mov	r9,3
800054f8:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800054fa:	fe 78 00 00 	mov	r8,-65536
800054fe:	30 29       	mov	r9,2
80005500:	91 69       	st.w	r8[0x18],r9

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80005502:	4a 38       	lddpc	r8,8000558c <local_start_PDC+0xd8>
80005504:	e0 69 5a 5a 	mov	r9,23130
80005508:	ea 19 ab cd 	orh	r9,0xabcd
8000550c:	91 19       	st.w	r8[0x4],r9
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
8000550e:	4a 08       	lddpc	r8,8000558c <local_start_PDC+0xd8>
80005510:	e0 69 5a 5a 	mov	r9,23130
80005514:	ea 19 ab cd 	orh	r9,0xabcd
80005518:	91 29       	st.w	r8[0x8],r9
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
8000551a:	49 d8       	lddpc	r8,8000558c <local_start_PDC+0xd8>
8000551c:	30 09       	mov	r9,0
8000551e:	91 39       	st.w	r8[0xc],r9
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80005520:	49 b8       	lddpc	r8,8000558c <local_start_PDC+0xd8>
80005522:	e0 69 5a 5a 	mov	r9,23130
80005526:	ea 19 ab cd 	orh	r9,0xabcd
8000552a:	91 59       	st.w	r8[0x14],r9
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
8000552c:	49 88       	lddpc	r8,8000558c <local_start_PDC+0xd8>
8000552e:	e0 69 5a 5a 	mov	r9,23130
80005532:	ea 19 ab cd 	orh	r9,0xabcd
80005536:	91 69       	st.w	r8[0x18],r9
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80005538:	49 58       	lddpc	r8,8000558c <local_start_PDC+0xd8>
8000553a:	30 09       	mov	r9,0
8000553c:	91 79       	st.w	r8[0x1c],r9

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
8000553e:	fe 78 00 40 	mov	r8,-65472
80005542:	30 79       	mov	r9,7
80005544:	91 99       	st.w	r8[0x24],r9
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80005546:	fe 78 00 40 	mov	r8,-65472
8000554a:	70 b8       	ld.w	r8,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
8000554c:	fe 78 00 40 	mov	r8,-65472
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80005550:	48 f9       	lddpc	r9,8000558c <local_start_PDC+0xd8>
80005552:	2f c9       	sub	r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80005554:	91 09       	st.w	r8[0x0],r9
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80005556:	fe 78 00 40 	mov	r8,-65472
8000555a:	30 39       	mov	r9,3
8000555c:	91 29       	st.w	r8[0x8],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
8000555e:	fe 78 00 40 	mov	r8,-65472
80005562:	30 79       	mov	r9,7
80005564:	91 19       	st.w	r8[0x4],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80005566:	fe 78 00 40 	mov	r8,-65472
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000556a:	48 99       	lddpc	r9,8000558c <local_start_PDC+0xd8>
8000556c:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
8000556e:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80005570:	fe 78 00 40 	mov	r8,-65472
80005574:	30 39       	mov	r9,3
80005576:	91 49       	st.w	r8[0x10],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80005578:	fe 78 00 40 	mov	r8,-65472
8000557c:	30 29       	mov	r9,2
8000557e:	91 69       	st.w	r8[0x18],r9
}/*End of local_start_PDC.*/
80005580:	e3 cd 80 80 	ldm	sp++,r7,pc
80005584:	00 00       	add	r0,r0
80005586:	40 a0       	lddsp	r0,sp[0x28]
80005588:	00 00       	add	r0,r0
8000558a:	40 a8       	lddsp	r8,sp[0x28]
8000558c:	00 00       	add	r0,r0
8000558e:	40 c8       	lddsp	r8,sp[0x30]

80005590 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80005590:	eb cd 40 80 	pushm	r7,lr
80005594:	1a 97       	mov	r7,sp
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;	
80005596:	fe 78 10 00 	mov	r8,-61440
8000559a:	30 29       	mov	r9,2
8000559c:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800055a0:	fe 78 10 00 	mov	r8,-61440
800055a4:	30 29       	mov	r9,2
800055a6:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800055aa:	fe 78 10 00 	mov	r8,-61440
800055ae:	f0 f8 01 60 	ld.w	r8,r8[352]
800055b2:	e2 18 00 02 	andl	r8,0x2,COH
800055b6:	cf a0       	breq	800055aa <ssc_init+0x1a>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800055b8:	fe 78 10 00 	mov	r8,-61440
800055bc:	f0 f8 01 60 	ld.w	r8,r8[352]
800055c0:	e2 18 00 02 	andl	r8,0x2,COH
800055c4:	cf a1       	brne	800055b8 <ssc_init+0x28>
				
    INTC_register_interrupt (
800055c6:	30 3a       	mov	r10,3
800055c8:	36 0b       	mov	r11,96
800055ca:	48 ec       	lddpc	r12,80005600 <ssc_init+0x70>
800055cc:	f0 1f 00 0e 	mcall	80005604 <ssc_init+0x74>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
800055d0:	f0 1f 00 0e 	mcall	80005608 <ssc_init+0x78>

    /*config the PDCA*/
    local_start_PDC();
800055d4:	f0 1f 00 0e 	mcall	8000560c <ssc_init+0x7c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800055d8:	fe 78 00 00 	mov	r8,-65536
800055dc:	30 19       	mov	r9,1
800055de:	91 59       	st.w	r8[0x14],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800055e0:	fe 78 00 40 	mov	r8,-65472
800055e4:	30 19       	mov	r9,1
800055e6:	91 59       	st.w	r8[0x14],r9
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800055e8:	fe 78 34 00 	mov	r8,-52224
800055ec:	e0 69 01 01 	mov	r9,257
800055f0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
800055f2:	fe 78 00 00 	mov	r8,-65536
800055f6:	30 19       	mov	r9,1
800055f8:	91 89       	st.w	r8[0x20],r9
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
800055fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800055fe:	00 00       	add	r0,r0
80005600:	80 00       	ld.sh	r0,r0[0x0]
80005602:	53 80       	stdsp	sp[0xe0],r0
80005604:	80 00       	ld.sh	r0,r0[0x0]
80005606:	66 20       	ld.w	r0,r3[0x8]
80005608:	80 00       	ld.sh	r0,r0[0x0]
8000560a:	54 3c       	stdsp	sp[0x10c],r12
8000560c:	80 00       	ld.sh	r0,r0[0x0]
8000560e:	54 b4       	stdsp	sp[0x12c],r4

80005610 <register_rx_tx_func>:
	void ( *tx_exec)(void *) -- send ssc function
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
80005610:	eb cd 40 80 	pushm	r7,lr
80005614:	1a 97       	mov	r7,sp
80005616:	20 2d       	sub	sp,8
80005618:	ef 4c ff fc 	st.w	r7[-4],r12
8000561c:	ef 4b ff f8 	st.w	r7[-8],r11
	 phy_rx_exec = rx_exec;
80005620:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005624:	48 58       	lddpc	r8,80005638 <register_rx_tx_func+0x28>
80005626:	91 09       	st.w	r8[0x0],r9
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80005628:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000562c:	48 48       	lddpc	r8,8000563c <register_rx_tx_func+0x2c>
8000562e:	91 09       	st.w	r8[0x0],r9
	 
}/*End of register_tx_rx_func.*/
80005630:	2f ed       	sub	sp,-8
80005632:	e3 cd 80 80 	ldm	sp++,r7,pc
80005636:	00 00       	add	r0,r0
80005638:	00 00       	add	r0,r0
8000563a:	0a d4       	st.w	--r5,r4
8000563c:	00 00       	add	r0,r0
8000563e:	0a d8       	st.w	--r5,r8
80005640:	58 43       	cp.w	r3,4
80005642:	4d 50       	lddpc	r0,80005794 <xcmp_exec_func+0x60>
80005644:	5f 52       	srlt	r2
80005646:	58 00       	cp.w	r0,0

80005648 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80005648:	eb cd 40 80 	pushm	r7,lr
8000564c:	1a 97       	mov	r7,sp
8000564e:	fa cd 01 08 	sub	sp,sp,264
80005652:	ef 4c fe fc 	st.w	r7[-260],r12
80005656:	16 98       	mov	r8,r11
80005658:	ef 68 fe f8 	st.b	r7[-264],r8
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000565c:	ef 38 fe f8 	ld.ub	r8,r7[-264]
80005660:	2f 08       	sub	r8,-16
80005662:	5c 88       	casts.h	r8
80005664:	5c 88       	casts.h	r8
80005666:	af a8       	sbr	r8,0xe
80005668:	5c 88       	casts.h	r8
8000566a:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
8000566e:	3f f8       	mov	r8,-1
80005670:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80005674:	30 b8       	mov	r8,11
80005676:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000567a:	3f f8       	mov	r8,-1
8000567c:	ef 58 ff 06 	st.h	r7[-250],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80005680:	3f f8       	mov	r8,-1
80005682:	ef 58 ff 08 	st.h	r7[-248],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80005686:	3f f8       	mov	r8,-1
80005688:	ef 58 ff 0a 	st.h	r7[-246],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000568c:	3f f8       	mov	r8,-1
8000568e:	ef 58 ff 0c 	st.h	r7[-244],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80005692:	ef 38 fe f8 	ld.ub	r8,r7[-264]
80005696:	2f e8       	sub	r8,-2
80005698:	10 99       	mov	r9,r8
8000569a:	ee c8 01 00 	sub	r8,r7,256
8000569e:	2f 08       	sub	r8,-16
800056a0:	12 9a       	mov	r10,r9
800056a2:	ee fb fe fc 	ld.w	r11,r7[-260]
800056a6:	10 9c       	mov	r12,r8
800056a8:	f0 1f 00 09 	mcall	800056cc <xcmp_tx+0x84>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800056ac:	ef 38 fe f8 	ld.ub	r8,r7[-264]
800056b0:	2f e8       	sub	r8,-2
800056b2:	5c 88       	casts.h	r8
800056b4:	5c 88       	casts.h	r8
800056b6:	ef 58 ff 0e 	st.h	r7[-242],r8
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800056ba:	ee c8 01 00 	sub	r8,r7,256
800056be:	10 9c       	mov	r12,r8
800056c0:	f0 1f 00 04 	mcall	800056d0 <xcmp_tx+0x88>
}
800056c4:	2b ed       	sub	sp,-264
800056c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800056ca:	00 00       	add	r0,r0
800056cc:	80 00       	ld.sh	r0,r0[0x0]
800056ce:	97 88       	st.w	r11[0x20],r8
800056d0:	80 00       	ld.sh	r0,r0[0x0]
800056d2:	5f e0       	srqs	r0

800056d4 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800056d4:	eb cd 40 c0 	pushm	r6-r7,lr
800056d8:	1a 97       	mov	r7,sp
800056da:	20 1d       	sub	sp,4
800056dc:	ee c6 ff f4 	sub	r6,r7,-12
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800056e0:	49 08       	lddpc	r8,80005720 <xcmp_rx+0x4c>
800056e2:	70 08       	ld.w	r8,r8[0x0]
800056e4:	10 9c       	mov	r12,r8
800056e6:	f0 1f 00 10 	mcall	80005724 <xcmp_rx+0x50>
800056ea:	18 98       	mov	r8,r12
800056ec:	ef 48 ff fc 	st.w	r7[-4],r8
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800056f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056f4:	58 08       	cp.w	r8,0
800056f6:	c1 20       	breq	8000571a <xcmp_rx+0x46>
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800056f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800056fc:	e0 6a 00 ca 	mov	r10,202
80005700:	0c 9b       	mov	r11,r6
80005702:	10 9c       	mov	r12,r8
80005704:	f0 1f 00 09 	mcall	80005728 <xcmp_rx+0x54>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80005708:	48 98       	lddpc	r8,8000572c <xcmp_rx+0x58>
8000570a:	70 08       	ld.w	r8,r8[0x0]
8000570c:	ee cb 00 04 	sub	r11,r7,4
80005710:	30 09       	mov	r9,0
80005712:	30 0a       	mov	r10,0
80005714:	10 9c       	mov	r12,r8
80005716:	f0 1f 00 07 	mcall	80005730 <xcmp_rx+0x5c>
	}	
}
8000571a:	2f fd       	sub	sp,-4
8000571c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005720:	00 00       	add	r0,r0
80005722:	0a 60       	and	r0,r5
80005724:	80 00       	ld.sh	r0,r0[0x0]
80005726:	52 98       	stdsp	sp[0xa4],r8
80005728:	80 00       	ld.sh	r0,r0[0x0]
8000572a:	97 88       	st.w	r11[0x20],r8
8000572c:	00 00       	add	r0,r0
8000572e:	0a dc       	st.w	--r5,r12
80005730:	80 00       	ld.sh	r0,r0[0x0]
80005732:	74 d8       	ld.w	r8,r10[0x34]

80005734 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80005734:	eb cd 40 80 	pushm	r7,lr
80005738:	1a 97       	mov	r7,sp
8000573a:	20 2d       	sub	sp,8
8000573c:	ef 4c ff fc 	st.w	r7[-4],r12
80005740:	ef 4b ff f8 	st.w	r7[-8],r11
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80005744:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005748:	90 08       	ld.sh	r8,r8[0x0]
8000574a:	5c 78       	castu.h	r8
8000574c:	e2 18 f0 00 	andl	r8,0xf000,COH
80005750:	e0 48 80 00 	cp.w	r8,32768
80005754:	c1 50       	breq	8000577e <xcmp_exec_func+0x4a>
80005756:	e0 48 b0 00 	cp.w	r8,45056
8000575a:	c1 e0       	breq	80005796 <xcmp_exec_func+0x62>
8000575c:	58 08       	cp.w	r8,0
8000575e:	c2 91       	brne	800057b0 <xcmp_exec_func+0x7c>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80005760:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005764:	70 08       	ld.w	r8,r8[0x0]
80005766:	58 08       	cp.w	r8,0
80005768:	c0 80       	breq	80005778 <xcmp_exec_func+0x44>
			{
				exec->xcmp_rx_req(xcmp);
8000576a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000576e:	70 08       	ld.w	r8,r8[0x0]
80005770:	ee fc ff f8 	ld.w	r12,r7[-8]
80005774:	5d 18       	icall	r8
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
			}
			break;
80005776:	c1 d8       	rjmp	800057b0 <xcmp_exec_func+0x7c>
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
80005778:	f0 1f 00 10 	mcall	800057b8 <xcmp_exec_func+0x84>
			}
			break;
8000577c:	c1 a8       	rjmp	800057b0 <xcmp_exec_func+0x7c>
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000577e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005782:	70 18       	ld.w	r8,r8[0x4]
80005784:	58 08       	cp.w	r8,0
80005786:	c1 40       	breq	800057ae <xcmp_exec_func+0x7a>
			{
				exec->xcmp_rx_reply(xcmp);
80005788:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000578c:	70 18       	ld.w	r8,r8[0x4]
8000578e:	ee fc ff f8 	ld.w	r12,r7[-8]
80005792:	5d 18       	icall	r8
			}
			break;
80005794:	c0 e8       	rjmp	800057b0 <xcmp_exec_func+0x7c>
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80005796:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000579a:	70 28       	ld.w	r8,r8[0x8]
8000579c:	58 08       	cp.w	r8,0
8000579e:	c0 90       	breq	800057b0 <xcmp_exec_func+0x7c>
			{
				exec->xcmp_rx_brdcst(xcmp);
800057a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800057a4:	70 28       	ld.w	r8,r8[0x8]
800057a6:	ee fc ff f8 	ld.w	r12,r7[-8]
800057aa:	5d 18       	icall	r8
800057ac:	c0 28       	rjmp	800057b0 <xcmp_exec_func+0x7c>
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
			{
				exec->xcmp_rx_reply(xcmp);
			}
			break;
800057ae:	d7 03       	nop
			break;
			
		default:
			break;
	}
}
800057b0:	2f ed       	sub	sp,-8
800057b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800057b6:	00 00       	add	r0,r0
800057b8:	80 00       	ld.sh	r0,r0[0x0]
800057ba:	59 a0       	cp.w	r0,26

800057bc <xcmp_rx_process>:
Calls: xQueueReceive -- freertos
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800057bc:	eb cd 40 80 	pushm	r7,lr
800057c0:	1a 97       	mov	r7,sp
800057c2:	fa cd 00 d4 	sub	sp,sp,212
800057c6:	ef 4c ff 2c 	st.w	r7[-212],r12
800057ca:	c0 28       	rjmp	800057ce <xcmp_rx_process+0x12>
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
		}

	}
800057cc:	d7 03       	nop
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
800057ce:	4c 88       	lddpc	r8,800058ec <xcmp_rx_process+0x130>
800057d0:	70 08       	ld.w	r8,r8[0x0]
800057d2:	ee cb 00 d0 	sub	r11,r7,208
800057d6:	30 09       	mov	r9,0
800057d8:	31 4a       	mov	r10,20
800057da:	10 9c       	mov	r12,r8
800057dc:	f0 1f 00 45 	mcall	800058f0 <xcmp_rx_process+0x134>
800057e0:	18 98       	mov	r8,r12
800057e2:	58 18       	cp.w	r8,1
800057e4:	cf 41       	brne	800057cc <xcmp_rx_process+0x10>
		{									
			if(NULL == ptr)
800057e6:	ee f8 ff 30 	ld.w	r8,r7[-208]
800057ea:	58 08       	cp.w	r8,0
800057ec:	c0 31       	brne	800057f2 <xcmp_rx_process+0x36>
			{
				continue;
800057ee:	d7 03       	nop
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
		}

	}
800057f0:	ce fb       	rjmp	800057ce <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800057f2:	ee f8 ff 30 	ld.w	r8,r7[-208]
800057f6:	90 08       	ld.sh	r8,r8[0x0]
800057f8:	5c 78       	castu.h	r8
800057fa:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
800057fe:	59 c8       	cp.w	r8,28
80005800:	c2 70       	breq	8000584e <xcmp_rx_process+0x92>
80005802:	e0 89 00 07 	brgt	80005810 <xcmp_rx_process+0x54>
80005806:	58 e8       	cp.w	r8,14
80005808:	c0 e0       	breq	80005824 <xcmp_rx_process+0x68>
8000580a:	58 f8       	cp.w	r8,15
8000580c:	c1 30       	breq	80005832 <xcmp_rx_process+0x76>
8000580e:	c3 58       	rjmp	80005878 <xcmp_rx_process+0xbc>
80005810:	e0 48 01 09 	cp.w	r8,265
80005814:	c2 40       	breq	8000585c <xcmp_rx_process+0xa0>
80005816:	e0 48 01 0a 	cp.w	r8,266
8000581a:	c2 80       	breq	8000586a <xcmp_rx_process+0xae>
8000581c:	e0 48 00 2c 	cp.w	r8,44
80005820:	c1 00       	breq	80005840 <xcmp_rx_process+0x84>
80005822:	c2 b8       	rjmp	80005878 <xcmp_rx_process+0xbc>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80005824:	ee f8 ff 30 	ld.w	r8,r7[-208]
80005828:	10 9b       	mov	r11,r8
8000582a:	4b 3c       	lddpc	r12,800058f4 <xcmp_rx_process+0x138>
8000582c:	f0 1f 00 33 	mcall	800058f8 <xcmp_rx_process+0x13c>
					break;
80005830:	c5 58       	rjmp	800058da <xcmp_rx_process+0x11e>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80005832:	ee f8 ff 30 	ld.w	r8,r7[-208]
80005836:	10 9b       	mov	r11,r8
80005838:	4b 1c       	lddpc	r12,800058fc <xcmp_rx_process+0x140>
8000583a:	f0 1f 00 30 	mcall	800058f8 <xcmp_rx_process+0x13c>
					break;
8000583e:	c4 e8       	rjmp	800058da <xcmp_rx_process+0x11e>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80005840:	ee f8 ff 30 	ld.w	r8,r7[-208]
80005844:	10 9b       	mov	r11,r8
80005846:	4a fc       	lddpc	r12,80005900 <xcmp_rx_process+0x144>
80005848:	f0 1f 00 2c 	mcall	800058f8 <xcmp_rx_process+0x13c>
					break;
8000584c:	c4 78       	rjmp	800058da <xcmp_rx_process+0x11e>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000584e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80005852:	10 9b       	mov	r11,r8
80005854:	4a cc       	lddpc	r12,80005904 <xcmp_rx_process+0x148>
80005856:	f0 1f 00 29 	mcall	800058f8 <xcmp_rx_process+0x13c>
						, ptr);
					break;
8000585a:	c4 08       	rjmp	800058da <xcmp_rx_process+0x11e>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000585c:	ee f8 ff 30 	ld.w	r8,r7[-208]
80005860:	10 9b       	mov	r11,r8
80005862:	4a ac       	lddpc	r12,80005908 <xcmp_rx_process+0x14c>
80005864:	f0 1f 00 25 	mcall	800058f8 <xcmp_rx_process+0x13c>
					break;
80005868:	c3 98       	rjmp	800058da <xcmp_rx_process+0x11e>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000586a:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000586e:	10 9b       	mov	r11,r8
80005870:	4a 7c       	lddpc	r12,8000590c <xcmp_rx_process+0x150>
80005872:	f0 1f 00 22 	mcall	800058f8 <xcmp_rx_process+0x13c>
					break;
80005876:	c3 28       	rjmp	800058da <xcmp_rx_process+0x11e>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80005878:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000587c:	90 08       	ld.sh	r8,r8[0x0]
8000587e:	5c 78       	castu.h	r8
80005880:	e2 18 04 00 	andl	r8,0x400,COH
80005884:	c0 b0       	breq	8000589a <xcmp_rx_process+0xde>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
80005886:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000588a:	90 08       	ld.sh	r8,r8[0x0]
8000588c:	5c 78       	castu.h	r8
8000588e:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80005892:	e0 48 00 68 	cp.w	r8,104
80005896:	e0 8a 00 0c 	brle	800058ae <xcmp_rx_process+0xf2>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000589a:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000589e:	90 08       	ld.sh	r8,r8[0x0]
800058a0:	5c 78       	castu.h	r8
800058a2:	e2 18 f0 00 	andl	r8,0xf000,COH
800058a6:	c1 91       	brne	800058d8 <xcmp_rx_process+0x11c>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800058a8:	f0 1f 00 1a 	mcall	80005910 <xcmp_rx_process+0x154>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800058ac:	c1 78       	rjmp	800058da <xcmp_rx_process+0x11e>
							xcmp_opcode_not_supported();
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800058ae:	ee fa ff 30 	ld.w	r10,r7[-208]
800058b2:	49 98       	lddpc	r8,80005914 <xcmp_rx_process+0x158>
800058b4:	70 0b       	ld.w	r11,r8[0x0]
800058b6:	ee f8 ff 30 	ld.w	r8,r7[-208]
800058ba:	90 08       	ld.sh	r8,r8[0x0]
800058bc:	5c 78       	castu.h	r8
800058be:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800058c2:	12 98       	mov	r8,r9
800058c4:	a1 78       	lsl	r8,0x1
800058c6:	12 08       	add	r8,r9
800058c8:	a3 68       	lsl	r8,0x2
800058ca:	f6 08 00 08 	add	r8,r11,r8
800058ce:	14 9b       	mov	r11,r10
800058d0:	10 9c       	mov	r12,r8
800058d2:	f0 1f 00 0a 	mcall	800058f8 <xcmp_rx_process+0x13c>
800058d6:	c0 28       	rjmp	800058da <xcmp_rx_process+0x11e>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800058d8:	d7 03       	nop
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800058da:	ee f9 ff 30 	ld.w	r9,r7[-208]
800058de:	48 f8       	lddpc	r8,80005918 <xcmp_rx_process+0x15c>
800058e0:	70 08       	ld.w	r8,r8[0x0]
800058e2:	12 9b       	mov	r11,r9
800058e4:	10 9c       	mov	r12,r8
800058e6:	f0 1f 00 0e 	mcall	8000591c <xcmp_rx_process+0x160>
		}

	}
800058ea:	c7 2b       	rjmp	800057ce <xcmp_rx_process+0x12>
800058ec:	00 00       	add	r0,r0
800058ee:	0a dc       	st.w	--r5,r12
800058f0:	80 00       	ld.sh	r0,r0[0x0]
800058f2:	76 e4       	ld.w	r4,r11[0x38]
800058f4:	00 00       	add	r0,r0
800058f6:	0a e0       	st.h	--r5,r0
800058f8:	80 00       	ld.sh	r0,r0[0x0]
800058fa:	57 34       	stdsp	sp[0x1cc],r4
800058fc:	00 00       	add	r0,r0
800058fe:	0a ec       	st.h	--r5,r12
80005900:	00 00       	add	r0,r0
80005902:	0a f8       	st.b	--r5,r8
80005904:	00 00       	add	r0,r0
80005906:	0b 04       	ld.w	r4,r5++
80005908:	00 00       	add	r0,r0
8000590a:	0b 10       	ld.sh	r0,r5++
8000590c:	00 00       	add	r0,r0
8000590e:	0b 1c       	ld.sh	r12,r5++
80005910:	80 00       	ld.sh	r0,r0[0x0]
80005912:	59 a0       	cp.w	r0,26
80005914:	00 00       	add	r0,r0
80005916:	40 e8       	lddsp	r8,sp[0x38]
80005918:	00 00       	add	r0,r0
8000591a:	0a 60       	and	r0,r5
8000591c:	80 00       	ld.sh	r0,r0[0x0]
8000591e:	53 20       	stdsp	sp[0xc8],r0

80005920 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80005920:	eb cd 40 80 	pushm	r7,lr
80005924:	1a 97       	mov	r7,sp
	/*initialize the xnl*/
	xnl_init();
80005926:	f0 1f 00 0f 	mcall	80005960 <xcmp_init+0x40>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
8000592a:	48 fc       	lddpc	r12,80005964 <xcmp_init+0x44>
8000592c:	f0 1f 00 0f 	mcall	80005968 <xcmp_init+0x48>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80005930:	30 4b       	mov	r11,4
80005932:	31 4c       	mov	r12,20
80005934:	f0 1f 00 0e 	mcall	8000596c <xcmp_init+0x4c>
80005938:	18 99       	mov	r9,r12
8000593a:	48 e8       	lddpc	r8,80005970 <xcmp_init+0x50>
8000593c:	91 09       	st.w	r8[0x0],r9
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000593e:	48 eb       	lddpc	r11,80005974 <xcmp_init+0x54>
80005940:	30 08       	mov	r8,0
80005942:	1a d8       	st.w	--sp,r8
80005944:	30 08       	mov	r8,0
80005946:	1a d8       	st.w	--sp,r8
80005948:	30 08       	mov	r8,0
8000594a:	1a d8       	st.w	--sp,r8
8000594c:	30 38       	mov	r8,3
8000594e:	30 09       	mov	r9,0
80005950:	e0 6a 01 80 	mov	r10,384
80005954:	48 9c       	lddpc	r12,80005978 <xcmp_init+0x58>
80005956:	f0 1f 00 0a 	mcall	8000597c <xcmp_init+0x5c>
8000595a:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
8000595c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005960:	80 00       	ld.sh	r0,r0[0x0]
80005962:	62 cc       	ld.w	r12,r1[0x30]
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	56 d4       	stdsp	sp[0x1b4],r4
80005968:	80 00       	ld.sh	r0,r0[0x0]
8000596a:	5f c0       	srvs	r0
8000596c:	80 00       	ld.sh	r0,r0[0x0]
8000596e:	73 c0       	ld.w	r0,r9[0x70]
80005970:	00 00       	add	r0,r0
80005972:	0a dc       	st.w	--r5,r12
80005974:	80 00       	ld.sh	r0,r0[0x0]
80005976:	56 40       	stdsp	sp[0x190],r0
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	57 bc       	stdsp	sp[0x1ec],r12
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	7c 30       	ld.w	r0,lr[0xc]

80005980 <xcmp_register_app_list>:
Description: register the app list
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
80005980:	eb cd 40 80 	pushm	r7,lr
80005984:	1a 97       	mov	r7,sp
80005986:	20 1d       	sub	sp,4
80005988:	ef 4c ff fc 	st.w	r7[-4],r12
	app_list = (app_exec_t *)list;
8000598c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005990:	48 38       	lddpc	r8,8000599c <xcmp_register_app_list+0x1c>
80005992:	91 09       	st.w	r8[0x0],r9
}
80005994:	2f fd       	sub	sp,-4
80005996:	e3 cd 80 80 	ldm	sp++,r7,pc
8000599a:	00 00       	add	r0,r0
8000599c:	00 00       	add	r0,r0
8000599e:	40 e8       	lddsp	r8,sp[0x38]

800059a0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800059a0:	eb cd 40 80 	pushm	r7,lr
800059a4:	1a 97       	mov	r7,sp
800059a6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800059aa:	fe 78 80 00 	mov	r8,-32768
800059ae:	ef 58 ff 36 	st.h	r7[-202],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800059b2:	30 38       	mov	r8,3
800059b4:	ef 68 ff 38 	st.b	r7[-200],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800059b8:	ee c8 00 ca 	sub	r8,r7,202
800059bc:	30 1b       	mov	r11,1
800059be:	10 9c       	mov	r12,r8
800059c0:	f0 1f 00 03 	mcall	800059cc <xcmp_opcode_not_supported+0x2c>
}
800059c4:	2c dd       	sub	sp,-204
800059c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800059ca:	00 00       	add	r0,r0
800059cc:	80 00       	ld.sh	r0,r0[0x0]
800059ce:	56 48       	stdsp	sp[0x190],r8

800059d0 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800059d0:	eb cd 40 80 	pushm	r7,lr
800059d4:	1a 97       	mov	r7,sp
800059d6:	fa cd 00 d0 	sub	sp,sp,208
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800059da:	fe 78 b4 00 	mov	r8,-19456
800059de:	ef 58 ff 32 	st.h	r7[-206],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800059e2:	ee c8 00 ce 	sub	r8,r7,206
800059e6:	2f e8       	sub	r8,-2
800059e8:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
800059ec:	ee f9 ff fc 	ld.w	r9,r7[-4]
800059f0:	30 88       	mov	r8,8
800059f2:	b2 88       	st.b	r9[0x0],r8
	ptr->XCMPVersion[1] = 0x01;
800059f4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800059f8:	30 18       	mov	r8,1
800059fa:	b2 98       	st.b	r9[0x1],r8
	ptr->XCMPVersion[2] = 0x00;
800059fc:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a00:	30 08       	mov	r8,0
80005a02:	b2 a8       	st.b	r9[0x2],r8
	ptr->XCMPVersion[3] = 0x05;
80005a04:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a08:	30 58       	mov	r8,5
80005a0a:	b2 b8       	st.b	r9[0x3],r8
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80005a0c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a10:	30 08       	mov	r8,0
80005a12:	b2 c8       	st.b	r9[0x4],r8
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80005a14:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a18:	30 78       	mov	r8,7
80005a1a:	b2 d8       	st.b	r9[0x5],r8
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80005a1c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a20:	30 08       	mov	r8,0
80005a22:	b2 e8       	st.b	r9[0x6],r8
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80005a24:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a28:	30 08       	mov	r8,0
80005a2a:	b2 f8       	st.b	r9[0x7],r8
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80005a2c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a30:	30 08       	mov	r8,0
80005a32:	f3 68 00 08 	st.b	r9[8],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80005a36:	ee c8 00 ce 	sub	r8,r7,206
80005a3a:	30 9b       	mov	r11,9
80005a3c:	10 9c       	mov	r12,r8
80005a3e:	f0 1f 00 03 	mcall	80005a48 <xcmp_DeviceInitializationStatus_request+0x78>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80005a42:	2c cd       	sub	sp,-208
80005a44:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a48:	80 00       	ld.sh	r0,r0[0x0]
80005a4a:	56 48       	stdsp	sp[0x190],r8

80005a4c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80005a4c:	eb cd 40 80 	pushm	r7,lr
80005a50:	1a 97       	mov	r7,sp
80005a52:	fa cd 00 d0 	sub	sp,sp,208
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80005a56:	e0 68 04 09 	mov	r8,1033
80005a5a:	ef 58 ff 32 	st.h	r7[-206],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80005a5e:	ee c8 00 ce 	sub	r8,r7,206
80005a62:	2f e8       	sub	r8,-2
80005a64:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80005a68:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a6c:	30 18       	mov	r8,1
80005a6e:	b2 88       	st.b	r9[0x0],r8
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80005a70:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a74:	30 08       	mov	r8,0
80005a76:	b2 98       	st.b	r9[0x1],r8
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80005a78:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a7c:	30 c8       	mov	r8,12
80005a7e:	b2 a8       	st.b	r9[0x2],r8
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80005a80:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005a84:	30 08       	mov	r8,0
80005a86:	b2 b8       	st.b	r9[0x3],r8
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80005a88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005a8c:	2f c8       	sub	r8,-4
80005a8e:	30 8a       	mov	r10,8
80005a90:	30 0b       	mov	r11,0
80005a92:	10 9c       	mov	r12,r8
80005a94:	f0 1f 00 06 	mcall	80005aac <xcmp_IdleTestTone+0x60>
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80005a98:	ee c8 00 ce 	sub	r8,r7,206
80005a9c:	30 cb       	mov	r11,12
80005a9e:	10 9c       	mov	r12,r8
80005aa0:	f0 1f 00 04 	mcall	80005ab0 <xcmp_IdleTestTone+0x64>
}
80005aa4:	2c cd       	sub	sp,-208
80005aa6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005aaa:	00 00       	add	r0,r0
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	98 d0       	ld.uh	r0,r12[0xa]
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	56 48       	stdsp	sp[0x190],r8
80005ab4:	63 6f       	ld.w	pc,r1[0x58]
80005ab6:	6e 6e       	ld.w	lr,r7[0x18]
80005ab8:	65 63       	ld.w	r3,r2[0x58]
80005aba:	74 65       	ld.w	r5,r10[0x18]
80005abc:	64 20       	ld.w	r0,r2[0x8]
80005abe:	66 69       	ld.w	r9,r3[0x18]
80005ac0:	6e 69       	ld.w	r9,r7[0x18]
80005ac2:	73 68       	ld.w	r8,r9[0x58]
80005ac4:	00 00       	add	r0,r0
80005ac6:	00 00       	add	r0,r0
80005ac8:	58 4e       	cp.w	lr,4
80005aca:	4c 5f       	lddpc	pc,80005bdc <check_sum+0x58>
80005acc:	52 58       	stdsp	sp[0x94],r8
80005ace:	00 00       	add	r0,r0
80005ad0:	58 4e       	cp.w	lr,4
80005ad2:	4c 5f       	lddpc	pc,80005be4 <check_sum+0x60>
80005ad4:	54 58       	stdsp	sp[0x114],r8
	...

80005ad8 <encipher>:
Calls:   
Called By: xnl_device_auth_reply_func
Output: U32 *const w
*/
static void encipher(U32 *const v, U32 *const w, const U32 *const k)
{
80005ad8:	eb cd 40 ef 	pushm	r0-r3,r5-r7,lr
80005adc:	1a 97       	mov	r7,sp
80005ade:	20 4d       	sub	sp,16
80005ae0:	ef 4c ff fc 	st.w	r7[-4],r12
80005ae4:	ef 4b ff f8 	st.w	r7[-8],r11
80005ae8:	ef 4a ff f4 	st.w	r7[-12],r10
	register U32 y=v[0], z=v[1], sum=0;
80005aec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005af0:	70 06       	ld.w	r6,r8[0x0]
80005af2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005af6:	2f c8       	sub	r8,-4
80005af8:	70 0e       	ld.w	lr,r8[0x0]
80005afa:	30 05       	mov	r5,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
80005afc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b00:	70 08       	ld.w	r8,r8[0x0]
80005b02:	ef 48 ff f0 	st.w	r7[-16],r8
80005b06:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b0a:	2f c8       	sub	r8,-4
80005b0c:	70 00       	ld.w	r0,r8[0x0]
80005b0e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b12:	2f 88       	sub	r8,-8
80005b14:	70 01       	ld.w	r1,r8[0x0]
80005b16:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005b1a:	2f 48       	sub	r8,-12
80005b1c:	70 02       	ld.w	r2,r8[0x0]
	register U32 n=32;
80005b1e:	32 03       	mov	r3,32

	while(n-->0)
80005b20:	c2 08       	rjmp	80005b60 <encipher+0x88>
	{
		sum += authDelta;		
80005b22:	49 88       	lddpc	r8,80005b80 <encipher+0xa8>
80005b24:	70 08       	ld.w	r8,r8[0x0]
80005b26:	10 05       	add	r5,r8
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005b28:	fc 08 15 04 	lsl	r8,lr,0x4
80005b2c:	ee fa ff f0 	ld.w	r10,r7[-16]
80005b30:	f0 0a 00 09 	add	r9,r8,r10
80005b34:	fc 05 00 08 	add	r8,lr,r5
80005b38:	10 59       	eor	r9,r8
80005b3a:	fc 08 16 05 	lsr	r8,lr,0x5
80005b3e:	00 08       	add	r8,r0
80005b40:	f3 e8 20 08 	eor	r8,r9,r8
80005b44:	10 06       	add	r6,r8
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005b46:	ec 08 15 04 	lsl	r8,r6,0x4
80005b4a:	f0 01 00 09 	add	r9,r8,r1
80005b4e:	ec 05 00 08 	add	r8,r6,r5
80005b52:	10 59       	eor	r9,r8
80005b54:	ec 08 16 05 	lsr	r8,r6,0x5
80005b58:	04 08       	add	r8,r2
80005b5a:	f3 e8 20 08 	eor	r8,r9,r8
80005b5e:	10 0e       	add	lr,r8
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80005b60:	58 03       	cp.w	r3,0
80005b62:	5f 18       	srne	r8
80005b64:	5c 58       	castu.b	r8
80005b66:	20 13       	sub	r3,1
80005b68:	58 08       	cp.w	r8,0
80005b6a:	cd c1       	brne	80005b22 <encipher+0x4a>
		sum += authDelta;		
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
	}

	w[0]=y; w[1]=z;
80005b6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b70:	91 06       	st.w	r8[0x0],r6
80005b72:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b76:	2f c8       	sub	r8,-4
80005b78:	91 0e       	st.w	r8[0x0],lr
}
80005b7a:	2f cd       	sub	sp,-16
80005b7c:	e3 cd 80 ef 	ldm	sp++,r0-r3,r5-r7,pc
80005b80:	80 00       	ld.sh	r0,r0[0x0]
80005b82:	f0 7c eb cd 	mov	r12,-922675

80005b84 <check_sum>:
Calls:   
Called By: xnl_tx
Return:U16
*/
static U16 check_sum (xnl_fragment_t * xnl)
{
80005b84:	eb cd 40 80 	pushm	r7,lr
80005b88:	1a 97       	mov	r7,sp
80005b8a:	20 4d       	sub	sp,16
80005b8c:	ef 4c ff f0 	st.w	r7[-16],r12
	*/	
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
80005b90:	30 08       	mov	r8,0
80005b92:	ef 58 ff f6 	st.h	r7[-10],r8
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80005b96:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005b9a:	90 08       	ld.sh	r8,r8[0x0]
80005b9c:	5c 78       	castu.h	r8
80005b9e:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80005ba2:	20 28       	sub	r8,2
80005ba4:	ef 48 ff fc 	st.w	r7[-4],r8
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80005ba8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bac:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80005bb0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bb4:	f2 08 00 08 	add	r8,r9,r8
80005bb8:	a1 58       	asr	r8,0x1
80005bba:	ef 48 ff fc 	st.w	r7[-4],r8
	indextohWord = 2;
80005bbe:	30 28       	mov	r8,2
80005bc0:	ef 48 ff f8 	st.w	r7[-8],r8
	while (hWordswithinFrag > 0)
80005bc4:	c1 98       	rjmp	80005bf6 <check_sum+0x72>
	{
		sumScratch += *((U16*)xnl + indextohWord);
80005bc6:	ee f9 ff f0 	ld.w	r9,r7[-16]
80005bca:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bce:	a1 78       	lsl	r8,0x1
80005bd0:	f2 08 00 08 	add	r8,r9,r8
80005bd4:	90 08       	ld.sh	r8,r8[0x0]
80005bd6:	ef 09 ff f6 	ld.sh	r9,r7[-10]
80005bda:	f2 08 00 08 	add	r8,r9,r8
80005bde:	ef 58 ff f6 	st.h	r7[-10],r8
		indextohWord     += 1;
80005be2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005be6:	2f f8       	sub	r8,-1
80005be8:	ef 48 ff f8 	st.w	r7[-8],r8
		hWordswithinFrag -= 1;
80005bec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bf0:	20 18       	sub	r8,1
80005bf2:	ef 48 ff fc 	st.w	r7[-4],r8
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80005bf6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005bfa:	58 08       	cp.w	r8,0
80005bfc:	fe 99 ff e5 	brgt	80005bc6 <check_sum+0x42>
		sumScratch += *((U16*)xnl + indextohWord);
		indextohWord     += 1;
		hWordswithinFrag -= 1;
	}
	
	return -sumScratch;
80005c00:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80005c04:	5c 38       	neg	r8
80005c06:	5c 88       	casts.h	r8
}
80005c08:	10 9c       	mov	r12,r8
80005c0a:	2f cd       	sub	sp,-16
80005c0c:	e3 cd 80 80 	ldm	sp++,r7,pc

80005c10 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
static void xnl_send_device_master_query(void)
{
80005c10:	eb cd 40 80 	pushm	r7,lr
80005c14:	1a 97       	mov	r7,sp
80005c16:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005c1a:	e0 68 40 0e 	mov	r8,16398
80005c1e:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005c22:	3f f8       	mov	r8,-1
80005c24:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80005c28:	30 38       	mov	r8,3
80005c2a:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80005c2e:	30 08       	mov	r8,0
80005c30:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80005c34:	30 08       	mov	r8,0
80005c36:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80005c3a:	30 08       	mov	r8,0
80005c3c:	ef 58 ff 0a 	st.h	r7[-246],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80005c40:	30 08       	mov	r8,0
80005c42:	ef 58 ff 0c 	st.h	r7[-244],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80005c46:	30 08       	mov	r8,0
80005c48:	ef 58 ff 0e 	st.h	r7[-242],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005c4c:	ee c8 01 00 	sub	r8,r7,256
80005c50:	10 9c       	mov	r12,r8
80005c52:	f0 1f 00 03 	mcall	80005c5c <xnl_send_device_master_query+0x4c>
}
80005c56:	2c 0d       	sub	sp,-256
80005c58:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c5c:	80 00       	ld.sh	r0,r0[0x0]
80005c5e:	5f e0       	srqs	r0

80005c60 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80005c60:	eb cd 40 80 	pushm	r7,lr
80005c64:	1a 97       	mov	r7,sp
80005c66:	fa cd 01 04 	sub	sp,sp,260
80005c6a:	ef 4c fe fc 	st.w	r7[-260],r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80005c6e:	49 c8       	lddpc	r8,80005cdc <xnl_master_status_brdcst_func+0x7c>
80005c70:	11 88       	ld.ub	r8,r8[0x0]
80005c72:	5c 58       	castu.b	r8
80005c74:	c2 f1       	brne	80005cd2 <xnl_master_status_brdcst_func+0x72>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80005c76:	49 b8       	lddpc	r8,80005ce0 <xnl_master_status_brdcst_func+0x80>
80005c78:	70 08       	ld.w	r8,r8[0x0]
80005c7a:	30 09       	mov	r9,0
80005c7c:	30 0a       	mov	r10,0
80005c7e:	30 0b       	mov	r11,0
80005c80:	10 9c       	mov	r12,r8
80005c82:	f0 1f 00 19 	mcall	80005ce4 <xnl_master_status_brdcst_func+0x84>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80005c86:	ee f8 fe fc 	ld.w	r8,r7[-260]
80005c8a:	90 58       	ld.sh	r8,r8[0xa]
80005c8c:	49 49       	lddpc	r9,80005cdc <xnl_master_status_brdcst_func+0x7c>
80005c8e:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005c90:	e0 68 40 0e 	mov	r8,16398
80005c94:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005c98:	3f f8       	mov	r8,-1
80005c9a:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80005c9e:	30 48       	mov	r8,4
80005ca0:	ef 58 ff 04 	st.h	r7[-252],r8
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005ca4:	3f f8       	mov	r8,-1
80005ca6:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005caa:	48 d8       	lddpc	r8,80005cdc <xnl_master_status_brdcst_func+0x7c>
80005cac:	90 18       	ld.sh	r8,r8[0x2]
80005cae:	5c 88       	casts.h	r8
80005cb0:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80005cb4:	3f f8       	mov	r8,-1
80005cb6:	ef 58 ff 0a 	st.h	r7[-246],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005cba:	3f f8       	mov	r8,-1
80005cbc:	ef 58 ff 0c 	st.h	r7[-244],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80005cc0:	30 08       	mov	r8,0
80005cc2:	ef 58 ff 0e 	st.h	r7[-242],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80005cc6:	ee c8 01 00 	sub	r8,r7,256
80005cca:	10 9c       	mov	r12,r8
80005ccc:	f0 1f 00 07 	mcall	80005ce8 <xnl_master_status_brdcst_func+0x88>
80005cd0:	c0 28       	rjmp	80005cd4 <xnl_master_status_brdcst_func+0x74>
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
	{
		return;	
80005cd2:	d7 03       	nop
		
	xnl_frame.xnl_header.payload_length = 0;
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
}
80005cd4:	2b fd       	sub	sp,-260
80005cd6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005cda:	00 00       	add	r0,r0
80005cdc:	00 00       	add	r0,r0
80005cde:	0b 28       	ld.uh	r8,r5++
80005ce0:	00 00       	add	r0,r0
80005ce2:	0b 3c       	ld.ub	r12,r5++
80005ce4:	80 00       	ld.sh	r0,r0[0x0]
80005ce6:	74 d8       	ld.w	r8,r10[0x34]
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	5f e0       	srqs	r0

80005cec <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80005cec:	eb cd 40 80 	pushm	r7,lr
80005cf0:	1a 97       	mov	r7,sp
80005cf2:	fa cd 01 14 	sub	sp,sp,276
80005cf6:	ef 4c fe ec 	st.w	r7[-276],r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80005cfa:	4c 78       	lddpc	r8,80005e14 <xnl_device_auth_reply_func+0x128>
80005cfc:	11 88       	ld.ub	r8,r8[0x0]
80005cfe:	5c 58       	castu.b	r8
80005d00:	e0 81 00 86 	brne	80005e0c <xnl_device_auth_reply_func+0x120>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80005d04:	4c 58       	lddpc	r8,80005e18 <xnl_device_auth_reply_func+0x12c>
80005d06:	70 08       	ld.w	r8,r8[0x0]
80005d08:	30 09       	mov	r9,0
80005d0a:	30 0a       	mov	r10,0
80005d0c:	30 0b       	mov	r11,0
80005d0e:	10 9c       	mov	r12,r8
80005d10:	f0 1f 00 43 	mcall	80005e1c <xnl_device_auth_reply_func+0x130>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80005d14:	ee f8 fe ec 	ld.w	r8,r7[-276]
80005d18:	f1 08 00 10 	ld.sh	r8,r8[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80005d1c:	4b e9       	lddpc	r9,80005e14 <xnl_device_auth_reply_func+0x128>
80005d1e:	b2 28       	st.h	r9[0x4],r8
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80005d20:	ee f8 fe ec 	ld.w	r8,r7[-276]
80005d24:	f1 38 00 12 	ld.ub	r8,r8[18]
	  .unencrypted_authentication_value[0])<<24	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80005d28:	f0 09 15 18 	lsl	r9,r8,0x18
80005d2c:	ee f8 fe ec 	ld.w	r8,r7[-276]
80005d30:	f1 38 00 13 	ld.ub	r8,r8[19]
	  .unencrypted_authentication_value[1])<<16	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80005d34:	b1 68       	lsl	r8,0x10
80005d36:	10 49       	or	r9,r8
80005d38:	ee f8 fe ec 	ld.w	r8,r7[-276]
80005d3c:	f1 38 00 14 	ld.ub	r8,r8[20]
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80005d40:	a9 68       	lsl	r8,0x8
80005d42:	10 49       	or	r9,r8
80005d44:	ee f8 fe ec 	ld.w	r8,r7[-276]
80005d48:	f1 38 00 15 	ld.ub	r8,r8[21]
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80005d4c:	f3 e8 10 08 	or	r8,r9,r8
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80005d50:	ef 48 ff f8 	st.w	r7[-8],r8
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80005d54:	ee f8 fe ec 	ld.w	r8,r7[-276]
80005d58:	f1 38 00 16 	ld.ub	r8,r8[22]
	  .unencrypted_authentication_value[4])<<24
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80005d5c:	f0 09 15 18 	lsl	r9,r8,0x18
80005d60:	ee f8 fe ec 	ld.w	r8,r7[-276]
80005d64:	f1 38 00 17 	ld.ub	r8,r8[23]
	   .unencrypted_authentication_value[5])<<16
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80005d68:	b1 68       	lsl	r8,0x10
80005d6a:	10 49       	or	r9,r8
80005d6c:	ee f8 fe ec 	ld.w	r8,r7[-276]
80005d70:	f1 38 00 18 	ld.ub	r8,r8[24]
	   .unencrypted_authentication_value[6])<<8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80005d74:	a9 68       	lsl	r8,0x8
80005d76:	10 49       	or	r9,r8
80005d78:	ee f8 fe ec 	ld.w	r8,r7[-276]
80005d7c:	f1 38 00 19 	ld.ub	r8,r8[25]
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80005d80:	f3 e8 10 08 	or	r8,r9,r8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80005d84:	ef 48 ff fc 	st.w	r7[-4],r8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	   .unencrypted_authentication_value[6])<<8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	   .unencrypted_authentication_value[7]);
	
	encipher(&v_vector[0], &w_vector[0], &authKey[0]);
80005d88:	ee c9 00 10 	sub	r9,r7,16
80005d8c:	ee c8 00 08 	sub	r8,r7,8
80005d90:	4a 4a       	lddpc	r10,80005e20 <xnl_device_auth_reply_func+0x134>
80005d92:	12 9b       	mov	r11,r9
80005d94:	10 9c       	mov	r12,r8
80005d96:	f0 1f 00 24 	mcall	80005e24 <xnl_device_auth_reply_func+0x138>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80005d9a:	e0 68 40 1a 	mov	r8,16410
80005d9e:	ef 58 fe f0 	st.h	r7[-272],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005da2:	3f f8       	mov	r8,-1
80005da4:	ef 58 fe f2 	st.h	r7[-270],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80005da8:	30 68       	mov	r8,6
80005daa:	ef 58 fe f4 	st.h	r7[-268],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80005dae:	3f f8       	mov	r8,-1
80005db0:	ef 58 fe f6 	st.h	r7[-266],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80005db4:	49 88       	lddpc	r8,80005e14 <xnl_device_auth_reply_func+0x128>
80005db6:	90 18       	ld.sh	r8,r8[0x2]
80005db8:	5c 88       	casts.h	r8
80005dba:	ef 58 fe f8 	st.h	r7[-264],r8
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80005dbe:	49 68       	lddpc	r8,80005e14 <xnl_device_auth_reply_func+0x128>
80005dc0:	90 28       	ld.sh	r8,r8[0x4]
80005dc2:	5c 88       	casts.h	r8
80005dc4:	ef 58 fe fa 	st.h	r7[-262],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005dc8:	3f f8       	mov	r8,-1
80005dca:	ef 58 fe fc 	st.h	r7[-260],r8
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80005dce:	30 c8       	mov	r8,12
80005dd0:	ef 58 fe fe 	st.h	r7[-258],r8
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80005dd4:	30 08       	mov	r8,0
80005dd6:	ef 58 ff 00 	st.h	r7[-256],r8
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80005dda:	30 78       	mov	r8,7
80005ddc:	ef 68 ff 02 	st.b	r7[-254],r8
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80005de0:	30 28       	mov	r8,2
80005de2:	ef 68 ff 03 	st.b	r7[-253],r8
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005de6:	ee c8 01 10 	sub	r8,r7,272
80005dea:	2e c8       	sub	r8,-20
	                         .encrypted_authentication_value[0])) = w_vector[0];
80005dec:	ee f9 ff f0 	ld.w	r9,r7[-16]
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005df0:	91 09       	st.w	r8[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005df2:	ee c8 01 10 	sub	r8,r7,272
80005df6:	2e c8       	sub	r8,-20
80005df8:	2f c8       	sub	r8,-4
	                         .encrypted_authentication_value[4])) = w_vector[1];
80005dfa:	ee f9 ff f4 	ld.w	r9,r7[-12]
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005dfe:	91 09       	st.w	r8[0x0],r9
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005e00:	ee c8 01 10 	sub	r8,r7,272
80005e04:	10 9c       	mov	r12,r8
80005e06:	f0 1f 00 09 	mcall	80005e28 <xnl_device_auth_reply_func+0x13c>
80005e0a:	c0 28       	rjmp	80005e0e <xnl_device_auth_reply_func+0x122>
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
	{
		return;		
80005e0c:	d7 03       	nop
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
}
80005e0e:	2b bd       	sub	sp,-276
80005e10:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e14:	00 00       	add	r0,r0
80005e16:	0b 28       	ld.uh	r8,r5++
80005e18:	00 00       	add	r0,r0
80005e1a:	0b 3c       	ld.ub	r12,r5++
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	74 d8       	ld.w	r8,r10[0x34]
80005e20:	80 00       	ld.sh	r0,r0[0x0]
80005e22:	f0 6c 80 00 	mov	r12,-1015808
80005e26:	5a d8       	cp.w	r8,-19
80005e28:	80 00       	ld.sh	r0,r0[0x0]
80005e2a:	5f e0       	srqs	r0

80005e2c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80005e2c:	eb cd 40 80 	pushm	r7,lr
80005e30:	1a 97       	mov	r7,sp
80005e32:	20 1d       	sub	sp,4
80005e34:	ef 4c ff fc 	st.w	r7[-4],r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80005e38:	49 b8       	lddpc	r8,80005ea4 <xnl_device_conn_reply_func+0x78>
80005e3a:	70 08       	ld.w	r8,r8[0x0]
80005e3c:	30 09       	mov	r9,0
80005e3e:	30 0a       	mov	r10,0
80005e40:	30 0b       	mov	r11,0
80005e42:	10 9c       	mov	r12,r8
80005e44:	f0 1f 00 19 	mcall	80005ea8 <xnl_device_conn_reply_func+0x7c>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005e48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e4c:	f1 08 00 10 	ld.sh	r8,r8[16]
80005e50:	5c 78       	castu.h	r8
80005e52:	e2 18 ff 00 	andl	r8,0xff00,COH
80005e56:	e0 48 01 00 	cp.w	r8,256
80005e5a:	c0 60       	breq	80005e66 <xnl_device_conn_reply_func+0x3a>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005e5c:	ee fc ff fc 	ld.w	r12,r7[-4]
80005e60:	f0 1f 00 13 	mcall	80005eac <xnl_device_conn_reply_func+0x80>
80005e64:	c1 c8       	rjmp	80005e9c <xnl_device_conn_reply_func+0x70>
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80005e66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e6a:	f1 08 00 10 	ld.sh	r8,r8[16]
80005e6e:	5c 78       	castu.h	r8
80005e70:	a9 68       	lsl	r8,0x8
80005e72:	5c 88       	casts.h	r8
80005e74:	48 f9       	lddpc	r9,80005eb0 <xnl_device_conn_reply_func+0x84>
80005e76:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005e78:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e7c:	f1 08 00 14 	ld.sh	r8,r8[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80005e80:	48 c9       	lddpc	r9,80005eb0 <xnl_device_conn_reply_func+0x84>
80005e82:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80005e84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005e88:	f1 08 00 12 	ld.sh	r8,r8[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80005e8c:	48 99       	lddpc	r9,80005eb0 <xnl_device_conn_reply_func+0x84>
80005e8e:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80005e90:	48 89       	lddpc	r9,80005eb0 <xnl_device_conn_reply_func+0x84>
80005e92:	30 18       	mov	r8,1
80005e94:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80005e96:	48 8c       	lddpc	r12,80005eb4 <xnl_device_conn_reply_func+0x88>
80005e98:	f0 1f 00 08 	mcall	80005eb8 <xnl_device_conn_reply_func+0x8c>
	}
	
	//xcmp_audio_route_speaker();
	
}
80005e9c:	2f fd       	sub	sp,-4
80005e9e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ea2:	00 00       	add	r0,r0
80005ea4:	00 00       	add	r0,r0
80005ea6:	0b 3c       	ld.ub	r12,r5++
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	74 d8       	ld.w	r8,r10[0x34]
80005eac:	80 00       	ld.sh	r0,r0[0x0]
80005eae:	5c 60       	casts.b	r0
80005eb0:	00 00       	add	r0,r0
80005eb2:	0b 28       	ld.uh	r8,r5++
80005eb4:	80 00       	ld.sh	r0,r0[0x0]
80005eb6:	5a b4       	cp.w	r4,-21
80005eb8:	80 00       	ld.sh	r0,r0[0x0]
80005eba:	8d 90       	st.w	r6[0x24],r0

80005ebc <xnl_send_msg_ack>:
Description: send data message ack.
Calls:xnl_tx
Register:xnl_data_msg_func
*/
static void xnl_send_msg_ack(xnl_header_t * hdr)
{	
80005ebc:	eb cd 40 80 	pushm	r7,lr
80005ec0:	1a 97       	mov	r7,sp
80005ec2:	fa cd 01 04 	sub	sp,sp,260
80005ec6:	ef 4c fe fc 	st.w	r7[-260],r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005eca:	e0 68 40 0e 	mov	r8,16398
80005ece:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005ed2:	3f f8       	mov	r8,-1
80005ed4:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80005ed8:	30 c8       	mov	r8,12
80005eda:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80005ede:	ee f8 fe fc 	ld.w	r8,r7[-260]
80005ee2:	90 18       	ld.sh	r8,r8[0x2]
80005ee4:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80005ee8:	ee f8 fe fc 	ld.w	r8,r7[-260]
80005eec:	90 38       	ld.sh	r8,r8[0x6]
80005eee:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80005ef2:	ee f8 fe fc 	ld.w	r8,r7[-260]
80005ef6:	90 28       	ld.sh	r8,r8[0x4]
80005ef8:	ef 58 ff 0a 	st.h	r7[-246],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80005efc:	ee f8 fe fc 	ld.w	r8,r7[-260]
80005f00:	90 48       	ld.sh	r8,r8[0x8]
80005f02:	ef 58 ff 0c 	st.h	r7[-244],r8
	xnl_frame.xnl_header.payload_length = 0;
80005f06:	30 08       	mov	r8,0
80005f08:	ef 58 ff 0e 	st.h	r7[-242],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005f0c:	ee c8 01 00 	sub	r8,r7,256
80005f10:	10 9c       	mov	r12,r8
80005f12:	f0 1f 00 03 	mcall	80005f1c <xnl_send_msg_ack+0x60>
}
80005f16:	2b fd       	sub	sp,-260
80005f18:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f1c:	80 00       	ld.sh	r0,r0[0x0]
80005f1e:	5f e0       	srqs	r0

80005f20 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80005f20:	eb cd 40 c0 	pushm	r6-r7,lr
80005f24:	1a 97       	mov	r7,sp
80005f26:	20 1d       	sub	sp,4
80005f28:	ef 4c ff fc 	st.w	r7[-4],r12
	If cannot schedule ACK, just leave without processing message; 
	XNL will retry again, and hopefully our Tx resources will then be free. If 
	ACK has been scheduled. It most likely is already owned by the 
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
80005f2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f30:	2f c8       	sub	r8,-4
80005f32:	10 9c       	mov	r12,r8
80005f34:	f0 1f 00 0b 	mcall	80005f60 <xnl_data_msg_func+0x40>
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80005f38:	48 b8       	lddpc	r8,80005f64 <xnl_data_msg_func+0x44>
80005f3a:	70 06       	ld.w	r6,r8[0x0]
80005f3c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005f40:	fa cd 00 cc 	sub	sp,sp,204
80005f44:	1a 98       	mov	r8,sp
80005f46:	2f 09       	sub	r9,-16
80005f48:	e0 6a 00 ca 	mov	r10,202
80005f4c:	12 9b       	mov	r11,r9
80005f4e:	10 9c       	mov	r12,r8
80005f50:	f0 1f 00 06 	mcall	80005f68 <xnl_data_msg_func+0x48>
80005f54:	5d 16       	icall	r6
80005f56:	fa cd ff 34 	sub	sp,sp,-204
}
80005f5a:	2f fd       	sub	sp,-4
80005f5c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	5e bc       	rethi	r12
80005f64:	00 00       	add	r0,r0
80005f66:	0b 34       	ld.ub	r4,r5++
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	97 88       	st.w	r11[0x20],r8

80005f6c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80005f6c:	eb cd 40 80 	pushm	r7,lr
80005f70:	1a 97       	mov	r7,sp
80005f72:	20 2d       	sub	sp,8
80005f74:	ef 4c ff f8 	st.w	r7[-8],r12
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80005f78:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005f7c:	90 48       	ld.sh	r8,r8[0x8]
80005f7e:	ef 58 ff fc 	st.h	r7[-4],r8
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80005f82:	48 d8       	lddpc	r8,80005fb4 <xnl_get_msg_ack_func+0x48>
80005f84:	90 28       	ld.sh	r8,r8[0x4]
80005f86:	5c 88       	casts.h	r8
80005f88:	ef 09 ff fc 	ld.sh	r9,r7[-4]
80005f8c:	f0 09 19 00 	cp.h	r9,r8
80005f90:	c0 e1       	brne	80005fac <xnl_get_msg_ack_func+0x40>
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
80005f92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005f96:	90 68       	ld.sh	r8,r8[0xc]
80005f98:	ef 58 ff fe 	st.h	r7[-2],r8
		xSemaphoreGive(xnl_timeout_semphr);	
80005f9c:	48 78       	lddpc	r8,80005fb8 <xnl_get_msg_ack_func+0x4c>
80005f9e:	70 08       	ld.w	r8,r8[0x0]
80005fa0:	30 09       	mov	r9,0
80005fa2:	30 0a       	mov	r10,0
80005fa4:	30 0b       	mov	r11,0
80005fa6:	10 9c       	mov	r12,r8
80005fa8:	f0 1f 00 05 	mcall	80005fbc <xnl_get_msg_ack_func+0x50>
	}
	
	
	
	//xSemaphoreGive(xnl_timeout_semphr);	
}
80005fac:	2f ed       	sub	sp,-8
80005fae:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fb2:	00 00       	add	r0,r0
80005fb4:	00 00       	add	r0,r0
80005fb6:	0b 28       	ld.uh	r8,r5++
80005fb8:	00 00       	add	r0,r0
80005fba:	0b 3c       	ld.ub	r12,r5++
80005fbc:	80 00       	ld.sh	r0,r0[0x0]
80005fbe:	74 d8       	ld.w	r8,r10[0x34]

80005fc0 <xnl_register_xcmp_func>:
/**
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
80005fc0:	eb cd 40 80 	pushm	r7,lr
80005fc4:	1a 97       	mov	r7,sp
80005fc6:	20 1d       	sub	sp,4
80005fc8:	ef 4c ff fc 	st.w	r7[-4],r12
	 xcmp_exec = func;
80005fcc:	48 48       	lddpc	r8,80005fdc <xnl_register_xcmp_func+0x1c>
80005fce:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005fd2:	91 09       	st.w	r8[0x0],r9
}
80005fd4:	2f fd       	sub	sp,-4
80005fd6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fda:	00 00       	add	r0,r0
80005fdc:	00 00       	add	r0,r0
80005fde:	0b 34       	ld.ub	r4,r5++

80005fe0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80005fe0:	eb cd 40 80 	pushm	r7,lr
80005fe4:	1a 97       	mov	r7,sp
80005fe6:	20 3d       	sub	sp,12
80005fe8:	ef 4c ff f4 	st.w	r7[-12],r12
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80005fec:	30 08       	mov	r8,0
80005fee:	ef 48 ff fc 	st.w	r7[-4],r8
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80005ff2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005ff6:	90 39       	ld.sh	r9,r8[0x6]
80005ff8:	3f f8       	mov	r8,-1
80005ffa:	f0 09 19 00 	cp.h	r9,r8
80005ffe:	c1 01       	brne	8000601e <xnl_tx+0x3e>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80006000:	4b a8       	lddpc	r8,800060e8 <xnl_tx+0x108>
80006002:	11 88       	ld.ub	r8,r8[0x0]
80006004:	2f f8       	sub	r8,-1
80006006:	5c 58       	castu.b	r8
80006008:	4b 89       	lddpc	r9,800060e8 <xnl_tx+0x108>
8000600a:	b2 88       	st.b	r9[0x0],r8
8000600c:	4b 78       	lddpc	r8,800060e8 <xnl_tx+0x108>
8000600e:	11 88       	ld.ub	r8,r8[0x0]
80006010:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80006014:	a9 a8       	sbr	r8,0x8
80006016:	5c 88       	casts.h	r8
80006018:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000601c:	b2 38       	st.h	r9[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
8000601e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006022:	90 49       	ld.sh	r9,r8[0x8]
80006024:	3f f8       	mov	r8,-1
80006026:	f0 09 19 00 	cp.h	r9,r8
8000602a:	c0 71       	brne	80006038 <xnl_tx+0x58>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000602c:	4b 08       	lddpc	r8,800060ec <xnl_tx+0x10c>
8000602e:	90 18       	ld.sh	r8,r8[0x2]
80006030:	5c 88       	casts.h	r8
80006032:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006036:	b2 48       	st.h	r9[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80006038:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000603c:	90 59       	ld.sh	r9,r8[0xa]
8000603e:	3f f8       	mov	r8,-1
80006040:	f0 09 19 00 	cp.h	r9,r8
80006044:	c0 71       	brne	80006052 <xnl_tx+0x72>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80006046:	4a a8       	lddpc	r8,800060ec <xnl_tx+0x10c>
80006048:	90 28       	ld.sh	r8,r8[0x4]
8000604a:	5c 88       	casts.h	r8
8000604c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006050:	b2 58       	st.h	r9[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80006052:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006056:	90 69       	ld.sh	r9,r8[0xc]
80006058:	3f f8       	mov	r8,-1
8000605a:	f0 09 19 00 	cp.h	r9,r8
8000605e:	c1 a1       	brne	80006092 <xnl_tx+0xb2>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80006060:	4a 38       	lddpc	r8,800060ec <xnl_tx+0x10c>
80006062:	90 48       	ld.sh	r8,r8[0x8]
80006064:	5c 88       	casts.h	r8
80006066:	2f f8       	sub	r8,-1
80006068:	5c 88       	casts.h	r8
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000606a:	4a 19       	lddpc	r9,800060ec <xnl_tx+0x10c>
8000606c:	b2 48       	st.h	r9[0x8],r8
		  ((++xnl_information.transaction_id) & 0xFF) 
8000606e:	4a 08       	lddpc	r8,800060ec <xnl_tx+0x10c>
80006070:	90 48       	ld.sh	r8,r8[0x8]
80006072:	5c 88       	casts.h	r8
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80006074:	5c 88       	casts.h	r8
80006076:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000607a:	49 d9       	lddpc	r9,800060ec <xnl_tx+0x10c>
8000607c:	92 49       	ld.sh	r9,r9[0x8]
8000607e:	5c 89       	casts.h	r9
80006080:	5c 89       	casts.h	r9
80006082:	e0 19 ff 00 	andl	r9,0xff00
80006086:	5c 89       	casts.h	r9
80006088:	12 48       	or	r8,r9
8000608a:	5c 88       	casts.h	r8
8000608c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006090:	b2 68       	st.h	r9[0xc],r8
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80006092:	ee fc ff f4 	ld.w	r12,r7[-12]
80006096:	f0 1f 00 17 	mcall	800060f0 <xnl_tx+0x110>
8000609a:	18 98       	mov	r8,r12
8000609c:	5c 88       	casts.h	r8
8000609e:	ee f9 ff f4 	ld.w	r9,r7[-12]
800060a2:	b2 18       	st.h	r9[0x2],r8
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800060a4:	49 48       	lddpc	r8,800060f4 <xnl_tx+0x114>
800060a6:	70 08       	ld.w	r8,r8[0x0]
800060a8:	10 9c       	mov	r12,r8
800060aa:	f0 1f 00 14 	mcall	800060f8 <xnl_tx+0x118>
800060ae:	18 98       	mov	r8,r12
800060b0:	ef 48 ff f8 	st.w	r7[-8],r8
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800060b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800060b8:	58 08       	cp.w	r8,0
800060ba:	c1 30       	breq	800060e0 <xnl_tx+0x100>
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800060bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800060c0:	e0 6a 01 00 	mov	r10,256
800060c4:	ee fb ff f4 	ld.w	r11,r7[-12]
800060c8:	10 9c       	mov	r12,r8
800060ca:	f0 1f 00 0d 	mcall	800060fc <xnl_tx+0x11c>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800060ce:	48 d8       	lddpc	r8,80006100 <xnl_tx+0x120>
800060d0:	70 08       	ld.w	r8,r8[0x0]
800060d2:	ee cb 00 08 	sub	r11,r7,8
800060d6:	30 09       	mov	r9,0
800060d8:	30 0a       	mov	r10,0
800060da:	10 9c       	mov	r12,r8
800060dc:	f0 1f 00 0a 	mcall	80006104 <xnl_tx+0x124>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800060e0:	2f dd       	sub	sp,-12
800060e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800060e6:	00 00       	add	r0,r0
800060e8:	00 00       	add	r0,r0
800060ea:	0b 4c       	ld.w	r12,--r5
800060ec:	00 00       	add	r0,r0
800060ee:	0b 28       	ld.uh	r8,r5++
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	5b 84       	cp.w	r4,-8
800060f4:	00 00       	add	r0,r0
800060f6:	0a 60       	and	r0,r5
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	52 98       	stdsp	sp[0xa4],r8
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	97 88       	st.w	r11[0x20],r8
80006100:	00 00       	add	r0,r0
80006102:	0b 38       	ld.ub	r8,r5++
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	74 d8       	ld.w	r8,r10[0x34]

80006108 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80006108:	eb cd 40 80 	pushm	r7,lr
8000610c:	1a 97       	mov	r7,sp
8000610e:	20 1d       	sub	sp,4
80006110:	ef 4c ff fc 	st.w	r7[-4],r12
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80006114:	4b 68       	lddpc	r8,800061ec <xnl_tx_process+0xe4>
80006116:	70 08       	ld.w	r8,r8[0x0]
80006118:	58 08       	cp.w	r8,0
8000611a:	c0 40       	breq	80006122 <xnl_tx_process+0x1a>
8000611c:	58 18       	cp.w	r8,1
8000611e:	c3 10       	breq	80006180 <xnl_tx_process+0x78>
				}
				break;
			default:
				break;
		}
	}
80006120:	cf ab       	rjmp	80006114 <xnl_tx_process+0xc>
	for(;;)
	{		
		switch(xnl_tx_state)
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80006122:	4b 48       	lddpc	r8,800061f0 <xnl_tx_process+0xe8>
80006124:	70 08       	ld.w	r8,r8[0x0]
80006126:	30 09       	mov	r9,0
80006128:	3f fa       	mov	r10,-1
8000612a:	4b 3b       	lddpc	r11,800061f4 <xnl_tx_process+0xec>
8000612c:	10 9c       	mov	r12,r8
8000612e:	f0 1f 00 33 	mcall	800061f8 <xnl_tx_process+0xf0>
80006132:	18 98       	mov	r8,r12
80006134:	58 18       	cp.w	r8,1
80006136:	c2 41       	brne	8000617e <xnl_tx_process+0x76>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80006138:	4a f8       	lddpc	r8,800061f4 <xnl_tx_process+0xec>
8000613a:	70 08       	ld.w	r8,r8[0x0]
8000613c:	58 08       	cp.w	r8,0
8000613e:	c0 21       	brne	80006142 <xnl_tx_process+0x3a>
					{
						break;
80006140:	c5 48       	rjmp	800061e8 <xnl_tx_process+0xe0>
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80006142:	4a d8       	lddpc	r8,800061f4 <xnl_tx_process+0xec>
80006144:	70 08       	ld.w	r8,r8[0x0]
80006146:	90 28       	ld.sh	r8,r8[0x4]
80006148:	58 08       	cp.w	r8,0
8000614a:	c0 71       	brne	80006158 <xnl_tx_process+0x50>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
8000614c:	4a a8       	lddpc	r8,800061f4 <xnl_tx_process+0xec>
8000614e:	70 08       	ld.w	r8,r8[0x0]
80006150:	10 9c       	mov	r12,r8
80006152:	f0 1f 00 2b 	mcall	800061fc <xnl_tx_process+0xf4>
						break;
80006156:	c4 98       	rjmp	800061e8 <xnl_tx_process+0xe0>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80006158:	4a 78       	lddpc	r8,800061f4 <xnl_tx_process+0xec>
8000615a:	70 08       	ld.w	r8,r8[0x0]
8000615c:	10 9c       	mov	r12,r8
8000615e:	f0 1f 00 29 	mcall	80006200 <xnl_tx_process+0xf8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80006162:	4a 98       	lddpc	r8,80006204 <xnl_tx_process+0xfc>
80006164:	30 19       	mov	r9,1
80006166:	91 09       	st.w	r8[0x0],r9
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80006168:	4a 88       	lddpc	r8,80006208 <xnl_tx_process+0x100>
8000616a:	70 08       	ld.w	r8,r8[0x0]
8000616c:	30 09       	mov	r9,0
8000616e:	30 0a       	mov	r10,0
80006170:	30 0b       	mov	r11,0
80006172:	10 9c       	mov	r12,r8
80006174:	f0 1f 00 21 	mcall	800061f8 <xnl_tx_process+0xf0>
					xnl_tx_state = WAITING_FOR_REPLY;
80006178:	49 d8       	lddpc	r8,800061ec <xnl_tx_process+0xe4>
8000617a:	30 19       	mov	r9,1
8000617c:	91 09       	st.w	r8[0x0],r9
				}
				break;
8000617e:	c3 58       	rjmp	800061e8 <xnl_tx_process+0xe0>
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80006180:	4a 28       	lddpc	r8,80006208 <xnl_tx_process+0x100>
80006182:	70 08       	ld.w	r8,r8[0x0]
80006184:	30 09       	mov	r9,0
80006186:	36 4a       	mov	r10,100
80006188:	30 0b       	mov	r11,0
8000618a:	10 9c       	mov	r12,r8
8000618c:	f0 1f 00 1b 	mcall	800061f8 <xnl_tx_process+0xf0>
80006190:	18 98       	mov	r8,r12
80006192:	58 18       	cp.w	r8,1
80006194:	c0 d1       	brne	800061ae <xnl_tx_process+0xa6>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80006196:	49 88       	lddpc	r8,800061f4 <xnl_tx_process+0xec>
80006198:	70 09       	ld.w	r9,r8[0x0]
8000619a:	49 d8       	lddpc	r8,8000620c <xnl_tx_process+0x104>
8000619c:	70 08       	ld.w	r8,r8[0x0]
8000619e:	12 9b       	mov	r11,r9
800061a0:	10 9c       	mov	r12,r8
800061a2:	f0 1f 00 1c 	mcall	80006210 <xnl_tx_process+0x108>
					xnl_tx_state = WAITING_FOR_TX;
800061a6:	49 28       	lddpc	r8,800061ec <xnl_tx_process+0xe4>
800061a8:	30 09       	mov	r9,0
800061aa:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
800061ac:	cb 4b       	rjmp	80006114 <xnl_tx_process+0xc>
					xnl_tx_state = WAITING_FOR_TX;
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800061ae:	49 68       	lddpc	r8,80006204 <xnl_tx_process+0xfc>
800061b0:	70 08       	ld.w	r8,r8[0x0]
800061b2:	58 38       	cp.w	r8,3
800061b4:	e0 89 00 0e 	brgt	800061d0 <xnl_tx_process+0xc8>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800061b8:	48 f8       	lddpc	r8,800061f4 <xnl_tx_process+0xec>
800061ba:	70 08       	ld.w	r8,r8[0x0]
800061bc:	10 9c       	mov	r12,r8
800061be:	f0 1f 00 11 	mcall	80006200 <xnl_tx_process+0xf8>
						xnl_send_times++;
800061c2:	49 18       	lddpc	r8,80006204 <xnl_tx_process+0xfc>
800061c4:	70 08       	ld.w	r8,r8[0x0]
800061c6:	f0 c9 ff ff 	sub	r9,r8,-1
800061ca:	48 f8       	lddpc	r8,80006204 <xnl_tx_process+0xfc>
800061cc:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
800061ce:	ca 3b       	rjmp	80006114 <xnl_tx_process+0xc>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800061d0:	48 98       	lddpc	r8,800061f4 <xnl_tx_process+0xec>
800061d2:	70 09       	ld.w	r9,r8[0x0]
800061d4:	48 e8       	lddpc	r8,8000620c <xnl_tx_process+0x104>
800061d6:	70 08       	ld.w	r8,r8[0x0]
800061d8:	12 9b       	mov	r11,r9
800061da:	10 9c       	mov	r12,r8
800061dc:	f0 1f 00 0d 	mcall	80006210 <xnl_tx_process+0x108>
						xnl_tx_state = WAITING_FOR_TX;
800061e0:	48 38       	lddpc	r8,800061ec <xnl_tx_process+0xe4>
800061e2:	30 09       	mov	r9,0
800061e4:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
800061e6:	c9 7b       	rjmp	80006114 <xnl_tx_process+0xc>
800061e8:	c9 6b       	rjmp	80006114 <xnl_tx_process+0xc>
800061ea:	00 00       	add	r0,r0
800061ec:	00 00       	add	r0,r0
800061ee:	0b 40       	ld.w	r0,--r5
800061f0:	00 00       	add	r0,r0
800061f2:	0b 38       	ld.ub	r8,r5++
800061f4:	00 00       	add	r0,r0
800061f6:	0b 44       	ld.w	r4,--r5
800061f8:	80 00       	ld.sh	r0,r0[0x0]
800061fa:	76 e4       	ld.w	r4,r11[0x38]
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	73 88       	ld.w	r8,r9[0x60]
80006200:	80 00       	ld.sh	r0,r0[0x0]
80006202:	37 50       	mov	r0,117
80006204:	00 00       	add	r0,r0
80006206:	0b 48       	ld.w	r8,--r5
80006208:	00 00       	add	r0,r0
8000620a:	0b 3c       	ld.ub	r12,r5++
8000620c:	00 00       	add	r0,r0
8000620e:	0a 60       	and	r0,r5
80006210:	80 00       	ld.sh	r0,r0[0x0]
80006212:	53 20       	stdsp	sp[0xc8],r0

80006214 <xnl_rx>:
Description: Receive the XNL and perform the corresponding functions
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
80006214:	eb cd 40 80 	pushm	r7,lr
80006218:	1a 97       	mov	r7,sp
8000621a:	20 1d       	sub	sp,4
8000621c:	ef 4c ff fc 	st.w	r7[-4],r12
	if(xnl->xnl_header.opcode > 0x0C)	
80006220:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006224:	90 29       	ld.sh	r9,r8[0x4]
80006226:	30 c8       	mov	r8,12
80006228:	f0 09 19 00 	cp.h	r9,r8
8000622c:	e0 8b 00 18 	brhi	8000625c <xnl_rx+0x48>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80006230:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006234:	90 28       	ld.sh	r8,r8[0x4]
80006236:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000623a:	48 b8       	lddpc	r8,80006264 <xnl_rx+0x50>
8000623c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006240:	58 08       	cp.w	r8,0
80006242:	c0 e0       	breq	8000625e <xnl_rx+0x4a>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80006244:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006248:	90 28       	ld.sh	r8,r8[0x4]
8000624a:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000624e:	48 68       	lddpc	r8,80006264 <xnl_rx+0x50>
80006250:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006254:	ee fc ff fc 	ld.w	r12,r7[-4]
80006258:	5d 18       	icall	r8
8000625a:	c0 28       	rjmp	8000625e <xnl_rx+0x4a>
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
8000625c:	d7 03       	nop
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
	}
}
8000625e:	2f fd       	sub	sp,-4
80006260:	e3 cd 80 80 	ldm	sp++,r7,pc
80006264:	00 00       	add	r0,r0
80006266:	04 f4       	st.b	--r2,r4

80006268 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80006268:	eb cd 40 80 	pushm	r7,lr
8000626c:	1a 97       	mov	r7,sp
8000626e:	20 2d       	sub	sp,8
80006270:	ef 4c ff f8 	st.w	r7[-8],r12
80006274:	c0 48       	rjmp	8000627c <xnl_rx_process+0x14>
				
				//vPortFree(xnl_ptr);
			}			
		}
		
	}
80006276:	d7 03       	nop
80006278:	c0 28       	rjmp	8000627c <xnl_rx_process+0x14>
8000627a:	d7 03       	nop
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000627c:	48 f8       	lddpc	r8,800062b8 <xnl_rx_process+0x50>
8000627e:	70 08       	ld.w	r8,r8[0x0]
80006280:	ee cb 00 04 	sub	r11,r7,4
80006284:	30 09       	mov	r9,0
80006286:	3f fa       	mov	r10,-1
80006288:	10 9c       	mov	r12,r8
8000628a:	f0 1f 00 0d 	mcall	800062bc <xnl_rx_process+0x54>
8000628e:	18 98       	mov	r8,r12
80006290:	58 18       	cp.w	r8,1
80006292:	cf 21       	brne	80006276 <xnl_rx_process+0xe>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80006294:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006298:	58 08       	cp.w	r8,0
8000629a:	cf 00       	breq	8000627a <xnl_rx_process+0x12>
			{
				xnl_rx(xnl_ptr);
8000629c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800062a0:	10 9c       	mov	r12,r8
800062a2:	f0 1f 00 08 	mcall	800062c0 <xnl_rx_process+0x58>
				set_xnl_idle(xnl_ptr);
800062a6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062aa:	48 78       	lddpc	r8,800062c4 <xnl_rx_process+0x5c>
800062ac:	70 08       	ld.w	r8,r8[0x0]
800062ae:	12 9b       	mov	r11,r9
800062b0:	10 9c       	mov	r12,r8
800062b2:	f0 1f 00 06 	mcall	800062c8 <xnl_rx_process+0x60>
				
				//vPortFree(xnl_ptr);
			}			
		}
		
	}
800062b6:	ce 3b       	rjmp	8000627c <xnl_rx_process+0x14>
800062b8:	00 00       	add	r0,r0
800062ba:	0a 68       	and	r8,r5
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	76 e4       	ld.w	r4,r11[0x38]
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	62 14       	ld.w	r4,r1[0x4]
800062c4:	00 00       	add	r0,r0
800062c6:	0a 60       	and	r0,r5
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	53 20       	stdsp	sp[0xc8],r0

800062cc <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800062cc:	eb cd 40 80 	pushm	r7,lr
800062d0:	1a 97       	mov	r7,sp
	/*initialize the physical layer*/
	phy_init();
800062d2:	f0 1f 00 21 	mcall	80006354 <xnl_init+0x88>
	
	xnl_information.is_connected = FALSE;
800062d6:	4a 19       	lddpc	r9,80006358 <xnl_init+0x8c>
800062d8:	30 08       	mov	r8,0
800062da:	b2 88       	st.b	r9[0x0],r8

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800062dc:	30 0b       	mov	r11,0
800062de:	30 1c       	mov	r12,1
800062e0:	f0 1f 00 1f 	mcall	8000635c <xnl_init+0x90>
800062e4:	18 99       	mov	r9,r12
800062e6:	49 f8       	lddpc	r8,80006360 <xnl_init+0x94>
800062e8:	91 09       	st.w	r8[0x0],r9
800062ea:	49 e8       	lddpc	r8,80006360 <xnl_init+0x94>
800062ec:	70 08       	ld.w	r8,r8[0x0]
800062ee:	58 08       	cp.w	r8,0
800062f0:	c0 90       	breq	80006302 <xnl_init+0x36>
800062f2:	49 c8       	lddpc	r8,80006360 <xnl_init+0x94>
800062f4:	70 08       	ld.w	r8,r8[0x0]
800062f6:	30 09       	mov	r9,0
800062f8:	30 0a       	mov	r10,0
800062fa:	30 0b       	mov	r11,0
800062fc:	10 9c       	mov	r12,r8
800062fe:	f0 1f 00 1a 	mcall	80006364 <xnl_init+0x98>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
80006302:	30 4b       	mov	r11,4
80006304:	31 4c       	mov	r12,20
80006306:	f0 1f 00 16 	mcall	8000635c <xnl_init+0x90>
8000630a:	18 99       	mov	r9,r12
8000630c:	49 78       	lddpc	r8,80006368 <xnl_init+0x9c>
8000630e:	91 09       	st.w	r8[0x0],r9
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80006310:	49 7b       	lddpc	r11,8000636c <xnl_init+0xa0>
80006312:	30 08       	mov	r8,0
80006314:	1a d8       	st.w	--sp,r8
80006316:	30 08       	mov	r8,0
80006318:	1a d8       	st.w	--sp,r8
8000631a:	30 08       	mov	r8,0
8000631c:	1a d8       	st.w	--sp,r8
8000631e:	30 38       	mov	r8,3
80006320:	30 09       	mov	r9,0
80006322:	e0 6a 02 00 	mov	r10,512
80006326:	49 3c       	lddpc	r12,80006370 <xnl_init+0xa4>
80006328:	f0 1f 00 13 	mcall	80006374 <xnl_init+0xa8>
8000632c:	2f dd       	sub	sp,-12
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000632e:	49 3b       	lddpc	r11,80006378 <xnl_init+0xac>
80006330:	30 08       	mov	r8,0
80006332:	1a d8       	st.w	--sp,r8
80006334:	30 08       	mov	r8,0
80006336:	1a d8       	st.w	--sp,r8
80006338:	30 08       	mov	r8,0
8000633a:	1a d8       	st.w	--sp,r8
8000633c:	30 38       	mov	r8,3
8000633e:	30 09       	mov	r9,0
80006340:	e0 6a 03 20 	mov	r10,800
80006344:	48 ec       	lddpc	r12,8000637c <xnl_init+0xb0>
80006346:	f0 1f 00 0c 	mcall	80006374 <xnl_init+0xa8>
8000634a:	2f dd       	sub	sp,-12
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
8000634c:	f0 1f 00 0d 	mcall	80006380 <xnl_init+0xb4>
}
80006350:	e3 cd 80 80 	ldm	sp++,r7,pc
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	36 44       	mov	r4,100
80006358:	00 00       	add	r0,r0
8000635a:	0b 28       	ld.uh	r8,r5++
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	73 c0       	ld.w	r0,r9[0x70]
80006360:	00 00       	add	r0,r0
80006362:	0b 3c       	ld.ub	r12,r5++
80006364:	80 00       	ld.sh	r0,r0[0x0]
80006366:	74 d8       	ld.w	r8,r10[0x34]
80006368:	00 00       	add	r0,r0
8000636a:	0b 38       	ld.ub	r8,r5++
8000636c:	80 00       	ld.sh	r0,r0[0x0]
8000636e:	5a c8       	cp.w	r8,-20
80006370:	80 00       	ld.sh	r0,r0[0x0]
80006372:	62 68       	ld.w	r8,r1[0x18]
80006374:	80 00       	ld.sh	r0,r0[0x0]
80006376:	7c 30       	ld.w	r0,lr[0xc]
80006378:	80 00       	ld.sh	r0,r0[0x0]
8000637a:	5a d0       	cp.w	r0,-19
8000637c:	80 00       	ld.sh	r0,r0[0x0]
8000637e:	61 08       	ld.w	r8,r0[0x40]
80006380:	80 00       	ld.sh	r0,r0[0x0]
80006382:	5c 10       	scr	r0

80006384 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80006384:	eb cd 40 80 	pushm	r7,lr
80006388:	1a 97       	mov	r7,sp
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
8000638a:	fe 78 0c 00 	mov	r8,-62464
8000638e:	e0 69 03 07 	mov	r9,775
80006392:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80006394:	fe 78 0c 00 	mov	r8,-62464
80006398:	30 49       	mov	r9,4
8000639a:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000639c:	fe 78 0c 00 	mov	r8,-62464
800063a0:	71 58       	ld.w	r8,r8[0x54]
800063a2:	e2 18 00 80 	andl	r8,0x80,COH
800063a6:	cf b0       	breq	8000639c <local_start_pll0+0x18>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800063a8:	fe 78 0c 00 	mov	r8,-62464
800063ac:	30 59       	mov	r9,5
800063ae:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800063b0:	fe 78 0c 00 	mov	r8,-62464
800063b4:	e0 69 01 0d 	mov	r9,269
800063b8:	ea 19 10 07 	orh	r9,0x1007
800063bc:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800063be:	fe 78 0c 00 	mov	r8,-62464
800063c2:	71 58       	ld.w	r8,r8[0x54]
800063c4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800063c8:	cf b0       	breq	800063be <local_start_pll0+0x3a>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800063ca:	fe 78 0c 00 	mov	r8,-62464
800063ce:	fc 19 00 80 	movh	r9,0x80
800063d2:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800063d4:	fe 68 14 00 	mov	r8,-125952
800063d8:	34 09       	mov	r9,64
800063da:	91 09       	st.w	r8[0x0],r9

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800063dc:	fe 78 0c 00 	mov	r8,-62464
800063e0:	30 69       	mov	r9,6
800063e2:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800063e4:	fe 68 10 00 	mov	r8,-126976
800063e8:	30 19       	mov	r9,1
800063ea:	91 19       	st.w	r8[0x4],r9
}
800063ec:	e3 cd 80 80 	ldm	sp++,r7,pc

800063f0 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
800063f0:	eb cd 40 80 	pushm	r7,lr
800063f4:	1a 97       	mov	r7,sp
	// Increment the 10ms seconds counter
	tc_tick++;
800063f6:	48 88       	lddpc	r8,80006414 <_tc_interrupt+0x24>
800063f8:	70 08       	ld.w	r8,r8[0x0]
800063fa:	f0 c9 ff ff 	sub	r9,r8,-1
800063fe:	48 68       	lddpc	r8,80006414 <_tc_interrupt+0x24>
80006400:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80006402:	30 1b       	mov	r11,1
80006404:	fe 7c 38 00 	mov	r12,-51200
80006408:	f0 1f 00 04 	mcall	80006418 <_tc_interrupt+0x28>
	
}
8000640c:	e3 cd 40 80 	ldm	sp++,r7,lr
80006410:	d6 03       	rete
80006412:	00 00       	add	r0,r0
80006414:	00 00       	add	r0,r0
80006416:	0b 50       	ld.sh	r0,--r5
80006418:	80 00       	ld.sh	r0,r0[0x0]
8000641a:	6a 8a       	ld.w	r10,r5[0x20]

8000641c <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
8000641c:	eb cd 40 80 	pushm	r7,lr
80006420:	1a 97       	mov	r7,sp
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80006422:	fe 78 10 00 	mov	r8,-61440
80006426:	fc 19 00 10 	movh	r9,0x10
8000642a:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
8000642c:	fe 78 10 00 	mov	r8,-61440
80006430:	fc 19 00 10 	movh	r9,0x10
80006434:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80006436:	fe 78 10 00 	mov	r8,-61440
8000643a:	fc 19 00 10 	movh	r9,0x10
8000643e:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80006440:	fe 78 10 00 	mov	r8,-61440
80006444:	30 39       	mov	r9,3
80006446:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
8000644a:	fe 78 10 00 	mov	r8,-61440
8000644e:	30 39       	mov	r9,3
80006450:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80006454:	fe 78 10 00 	mov	r8,-61440
80006458:	30 39       	mov	r9,3
8000645a:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
8000645e:	fe 78 38 00 	mov	r8,-51200
80006462:	30 49       	mov	r9,4
80006464:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80006468:	fe 78 38 00 	mov	r8,-51200
8000646c:	e0 69 91 0d 	mov	r9,37133
80006470:	ea 19 00 52 	orh	r9,0x52
80006474:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80006476:	fe 78 38 00 	mov	r8,-51200
8000647a:	32 09       	mov	r9,32
8000647c:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
8000647e:	fe 78 38 00 	mov	r8,-51200
80006482:	30 59       	mov	r9,5
80006484:	91 09       	st.w	r8[0x0],r9
}
80006486:	e3 cd 80 80 	ldm	sp++,r7,pc
8000648a:	d7 03       	nop

8000648c <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
8000648c:	eb cd 40 80 	pushm	r7,lr
80006490:	1a 97       	mov	r7,sp
80006492:	20 1d       	sub	sp,4

	volatile avr32_tc_t * tc = EXAMPLE_TC;
80006494:	fe 78 38 00 	mov	r8,-51200
80006498:	ef 48 ff fc 	st.w	r7[-4],r8
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
8000649c:	30 2a       	mov	r10,2
8000649e:	e0 6b 01 c1 	mov	r11,449
800064a2:	48 fc       	lddpc	r12,800064dc <tc_init+0x50>
800064a4:	f0 1f 00 0f 	mcall	800064e0 <tc_init+0x54>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
800064a8:	48 fb       	lddpc	r11,800064e4 <tc_init+0x58>
800064aa:	ee fc ff fc 	ld.w	r12,r7[-4]
800064ae:	f0 1f 00 0f 	mcall	800064e8 <tc_init+0x5c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
800064b2:	e0 6a 75 30 	mov	r10,30000
800064b6:	30 1b       	mov	r11,1
800064b8:	ee fc ff fc 	ld.w	r12,r7[-4]
800064bc:	f0 1f 00 0c 	mcall	800064ec <tc_init+0x60>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
800064c0:	48 ca       	lddpc	r10,800064f0 <tc_init+0x64>
800064c2:	30 1b       	mov	r11,1
800064c4:	ee fc ff fc 	ld.w	r12,r7[-4]
800064c8:	f0 1f 00 0b 	mcall	800064f4 <tc_init+0x68>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
800064cc:	30 1b       	mov	r11,1
800064ce:	ee fc ff fc 	ld.w	r12,r7[-4]
800064d2:	f0 1f 00 0a 	mcall	800064f8 <tc_init+0x6c>
800064d6:	2f fd       	sub	sp,-4
800064d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800064dc:	80 00       	ld.sh	r0,r0[0x0]
800064de:	63 f0       	ld.w	r0,r1[0x7c]
800064e0:	80 00       	ld.sh	r0,r0[0x0]
800064e2:	66 20       	ld.w	r0,r3[0x8]
800064e4:	80 00       	ld.sh	r0,r0[0x0]
800064e6:	f0 80 80 00 	breq	7fe164e6 <_estack+0x7fdfe4e6>
800064ea:	68 fc       	ld.w	r12,r4[0x3c]
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	6a c4       	ld.w	r4,r5[0x30]
800064f0:	80 00       	ld.sh	r0,r0[0x0]
800064f2:	f0 88 80 00 	brls	7fe164f2 <_estack+0x7fdfe4f2>
800064f6:	67 14       	ld.w	r4,r3[0x44]
800064f8:	80 00       	ld.sh	r0,r0[0x0]
800064fa:	6a 50       	ld.w	r0,r5[0x14]

800064fc <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800064fc:	eb cd 40 80 	pushm	r7,lr
80006500:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
80006502:	c0 08       	rjmp	80006502 <_unhandled_interrupt+0x6>

80006504 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
80006504:	eb cd 40 80 	pushm	r7,lr
80006508:	1a 97       	mov	r7,sp
8000650a:	20 3d       	sub	sp,12
8000650c:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80006510:	fe 78 08 00 	mov	r8,-63488
80006514:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006518:	f2 09 11 03 	rsub	r9,r9,3
8000651c:	28 09       	sub	r9,-128
8000651e:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006522:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80006526:	fe 78 08 00 	mov	r8,-63488
8000652a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000652e:	2c 09       	sub	r9,-64
80006530:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006534:	ef 48 ff fc 	st.w	r7[-4],r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80006538:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000653c:	58 08       	cp.w	r8,0
8000653e:	c1 30       	breq	80006564 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80006540:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006544:	48 b8       	lddpc	r8,80006570 <_get_interrupt_handler+0x6c>
80006546:	a1 79       	lsl	r9,0x1
80006548:	2f f9       	sub	r9,-1
8000654a:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
8000654e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006552:	f0 08 12 00 	clz	r8,r8
80006556:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
8000655a:	a3 68       	lsl	r8,0x2
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000655c:	f2 08 00 08 	add	r8,r9,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80006560:	70 08       	ld.w	r8,r8[0x0]
80006562:	c0 28       	rjmp	80006566 <_get_interrupt_handler+0x62>
80006564:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80006566:	10 9c       	mov	r12,r8
80006568:	2f dd       	sub	sp,-12
8000656a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000656e:	00 00       	add	r0,r0
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	f0 8c eb cd 	brvs	7fe23d0c <_estack+0x7fe0bd0c>

80006574 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80006574:	eb cd 40 80 	pushm	r7,lr
80006578:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000657a:	48 38       	lddpc	r8,80006584 <INTC_init_evba+0x10>
8000657c:	e3 b8 00 01 	mtsr	0x4,r8
}
80006580:	e3 cd 80 80 	ldm	sp++,r7,pc
80006584:	80 00       	ld.sh	r0,r0[0x0]
80006586:	ee 00       	*unknown*

80006588 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80006588:	eb cd 40 80 	pushm	r7,lr
8000658c:	1a 97       	mov	r7,sp
8000658e:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80006590:	f0 1f 00 1f 	mcall	8000660c <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80006594:	30 08       	mov	r8,0
80006596:	ef 48 ff f8 	st.w	r7[-8],r8
8000659a:	c3 18       	rjmp	800065fc <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000659c:	30 08       	mov	r8,0
8000659e:	ef 48 ff fc 	st.w	r7[-4],r8
800065a2:	c1 48       	rjmp	800065ca <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800065a4:	ee f9 ff f8 	ld.w	r9,r7[-8]
800065a8:	49 a8       	lddpc	r8,80006610 <INTC_init_interrupts+0x88>
800065aa:	a1 79       	lsl	r9,0x1
800065ac:	2f f9       	sub	r9,-1
800065ae:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800065b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800065b6:	a3 68       	lsl	r8,0x2
800065b8:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800065bc:	49 69       	lddpc	r9,80006614 <INTC_init_interrupts+0x8c>
800065be:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800065c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800065c4:	2f f8       	sub	r8,-1
800065c6:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
800065ca:	ee f9 ff f8 	ld.w	r9,r7[-8]
800065ce:	49 18       	lddpc	r8,80006610 <INTC_init_interrupts+0x88>
800065d0:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800065d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800065d8:	10 39       	cp.w	r9,r8
800065da:	fe 9b ff e5 	brhi	800065a4 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800065de:	fe 78 08 00 	mov	r8,-63488
800065e2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800065e6:	48 db       	lddpc	r11,80006618 <INTC_init_interrupts+0x90>
800065e8:	48 da       	lddpc	r10,8000661c <INTC_init_interrupts+0x94>
800065ea:	f6 0a 01 0a 	sub	r10,r11,r10
800065ee:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800065f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800065f6:	2f f8       	sub	r8,-1
800065f8:	ef 48 ff f8 	st.w	r7[-8],r8
800065fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006600:	59 28       	cp.w	r8,18
80006602:	fe 98 ff cd 	brls	8000659c <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
80006606:	2f ed       	sub	sp,-8
80006608:	e3 cd 80 80 	ldm	sp++,r7,pc
8000660c:	80 00       	ld.sh	r0,r0[0x0]
8000660e:	65 74       	ld.w	r4,r2[0x5c]
80006610:	80 00       	ld.sh	r0,r0[0x0]
80006612:	f0 8c 80 00 	brvs	7fe16612 <_estack+0x7fdfe612>
80006616:	64 fc       	ld.w	r12,r2[0x3c]
80006618:	80 00       	ld.sh	r0,r0[0x0]
8000661a:	ef 04 80 00 	ld.sh	r4,r7[-32768]
8000661e:	ee 00       	*unknown*

80006620 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
80006620:	eb cd 40 80 	pushm	r7,lr
80006624:	1a 97       	mov	r7,sp
80006626:	20 4d       	sub	sp,16
80006628:	ef 4c ff f8 	st.w	r7[-8],r12
8000662c:	ef 4b ff f4 	st.w	r7[-12],r11
80006630:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80006634:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006638:	a5 98       	lsr	r8,0x5
8000663a:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000663e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006642:	4a 78       	lddpc	r8,800066dc <INTC_register_interrupt+0xbc>
80006644:	a1 79       	lsl	r9,0x1
80006646:	2f f9       	sub	r9,-1
80006648:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
8000664c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006650:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80006654:	a3 68       	lsl	r8,0x2
80006656:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000665a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000665e:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80006660:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006664:	58 08       	cp.w	r8,0
80006666:	c0 c1       	brne	8000667e <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006668:	fe 78 08 00 	mov	r8,-63488
8000666c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006670:	49 cb       	lddpc	r11,800066e0 <INTC_register_interrupt+0xc0>
80006672:	49 da       	lddpc	r10,800066e4 <INTC_register_interrupt+0xc4>
80006674:	f6 0a 01 0a 	sub	r10,r11,r10
80006678:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
8000667c:	c2 d8       	rjmp	800066d6 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
8000667e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006682:	58 18       	cp.w	r8,1
80006684:	c0 d1       	brne	8000669e <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80006686:	fe 78 08 00 	mov	r8,-63488
8000668a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000668e:	49 7b       	lddpc	r11,800066e8 <INTC_register_interrupt+0xc8>
80006690:	49 5a       	lddpc	r10,800066e4 <INTC_register_interrupt+0xc4>
80006692:	f6 0a 01 0a 	sub	r10,r11,r10
80006696:	bf aa       	sbr	r10,0x1e
80006698:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
8000669c:	c1 d8       	rjmp	800066d6 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
8000669e:	ee f8 ff f0 	ld.w	r8,r7[-16]
800066a2:	58 28       	cp.w	r8,2
800066a4:	c0 d1       	brne	800066be <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800066a6:	fe 78 08 00 	mov	r8,-63488
800066aa:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066ae:	49 0b       	lddpc	r11,800066ec <INTC_register_interrupt+0xcc>
800066b0:	48 da       	lddpc	r10,800066e4 <INTC_register_interrupt+0xc4>
800066b2:	f6 0a 01 0a 	sub	r10,r11,r10
800066b6:	bf ba       	sbr	r10,0x1f
800066b8:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
800066bc:	c0 d8       	rjmp	800066d6 <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800066be:	fe 78 08 00 	mov	r8,-63488
800066c2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066c6:	48 bb       	lddpc	r11,800066f0 <INTC_register_interrupt+0xd0>
800066c8:	48 7a       	lddpc	r10,800066e4 <INTC_register_interrupt+0xc4>
800066ca:	f6 0a 01 0a 	sub	r10,r11,r10
800066ce:	ea 1a c0 00 	orh	r10,0xc000
800066d2:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
800066d6:	2f cd       	sub	sp,-16
800066d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800066dc:	80 00       	ld.sh	r0,r0[0x0]
800066de:	f0 8c 80 00 	brvs	7fe166de <_estack+0x7fdfe6de>
800066e2:	ef 04 80 00 	ld.sh	r4,r7[-32768]
800066e6:	ee 00       	*unknown*
800066e8:	80 00       	ld.sh	r0,r0[0x0]
800066ea:	ef 12 80 00 	ld.uh	r2,r7[-32768]
800066ee:	ef 20 80 00 	ld.sb	r0,r7[-32768]
800066f2:	ef 2e eb cd 	ld.sb	lr,r7[-5171]

800066f4 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
800066f4:	eb cd 40 80 	pushm	r7,lr
800066f8:	1a 97       	mov	r7,sp
800066fa:	20 1d       	sub	sp,4
800066fc:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80006700:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006704:	e6 18 00 01 	andh	r8,0x1,COH
80006708:	5f 08       	sreq	r8
8000670a:	5c 58       	castu.b	r8
}
8000670c:	10 9c       	mov	r12,r8
8000670e:	2f fd       	sub	sp,-4
80006710:	e3 cd 80 80 	ldm	sp++,r7,pc

80006714 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80006714:	eb cd 40 80 	pushm	r7,lr
80006718:	1a 97       	mov	r7,sp
8000671a:	20 4d       	sub	sp,16
8000671c:	ef 4c ff f8 	st.w	r7[-8],r12
80006720:	ef 4b ff f4 	st.w	r7[-12],r11
80006724:	ef 4a ff f0 	st.w	r7[-16],r10
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80006728:	e1 b8 00 00 	mfsr	r8,0x0
8000672c:	10 9c       	mov	r12,r8
8000672e:	f0 1f 00 73 	mcall	800068f8 <tc_configure_interrupts+0x1e4>
80006732:	18 98       	mov	r8,r12
80006734:	ef 68 ff ff 	st.b	r7[-1],r8

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80006738:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000673c:	58 28       	cp.w	r8,2
8000673e:	e0 88 00 04 	brls	80006746 <tc_configure_interrupts+0x32>
    return TC_INVALID_ARGUMENT;
80006742:	3f f8       	mov	r8,-1
80006744:	cd 68       	rjmp	800068f0 <tc_configure_interrupts+0x1dc>

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80006746:	ee fb ff f4 	ld.w	r11,r7[-12]
8000674a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000674e:	70 08       	ld.w	r8,r8[0x0]
80006750:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80006754:	5c 58       	castu.b	r8
80006756:	f0 09 15 07 	lsl	r9,r8,0x7
                             bitfield->ldrbs << AVR32_TC_LDRBS_OFFSET |
8000675a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000675e:	70 08       	ld.w	r8,r8[0x0]
80006760:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80006764:	5c 58       	castu.b	r8
80006766:	a7 68       	lsl	r8,0x6
80006768:	10 49       	or	r9,r8
                             bitfield->ldras << AVR32_TC_LDRAS_OFFSET |
8000676a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000676e:	70 08       	ld.w	r8,r8[0x0]
80006770:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80006774:	5c 58       	castu.b	r8
80006776:	a5 78       	lsl	r8,0x5
80006778:	10 49       	or	r9,r8
                             bitfield->cpcs << AVR32_TC_CPCS_OFFSET |
8000677a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000677e:	70 08       	ld.w	r8,r8[0x0]
80006780:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80006784:	5c 58       	castu.b	r8
80006786:	a5 68       	lsl	r8,0x4
80006788:	10 49       	or	r9,r8
                             bitfield->cpbs << AVR32_TC_CPBS_OFFSET |
8000678a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000678e:	70 08       	ld.w	r8,r8[0x0]
80006790:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80006794:	5c 58       	castu.b	r8
80006796:	a3 78       	lsl	r8,0x3
80006798:	10 49       	or	r9,r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
8000679a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000679e:	70 08       	ld.w	r8,r8[0x0]
800067a0:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800067a4:	5c 58       	castu.b	r8
800067a6:	a3 68       	lsl	r8,0x2
800067a8:	10 49       	or	r9,r8
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
800067aa:	ee f8 ff f0 	ld.w	r8,r7[-16]
800067ae:	70 08       	ld.w	r8,r8[0x0]
800067b0:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800067b4:	5c 58       	castu.b	r8
800067b6:	a1 78       	lsl	r8,0x1
800067b8:	10 49       	or	r9,r8
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;
800067ba:	ee f8 ff f0 	ld.w	r8,r7[-16]
800067be:	70 08       	ld.w	r8,r8[0x0]
800067c0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800067c4:	5c 58       	castu.b	r8
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
800067c6:	f3 e8 10 08 	or	r8,r9,r8
800067ca:	10 99       	mov	r9,r8
800067cc:	ee fa ff f8 	ld.w	r10,r7[-8]
800067d0:	f6 08 15 06 	lsl	r8,r11,0x6
800067d4:	f4 08 00 08 	add	r8,r10,r8
800067d8:	2d c8       	sub	r8,-36
800067da:	91 09       	st.w	r8[0x0],r9
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
800067dc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800067e0:	30 08       	mov	r8,0
800067e2:	f0 09 18 00 	cp.b	r9,r8
800067e6:	c0 20       	breq	800067ea <tc_configure_interrupts+0xd6>
800067e8:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800067ea:	ee fb ff f4 	ld.w	r11,r7[-12]
800067ee:	ee f8 ff f0 	ld.w	r8,r7[-16]
800067f2:	70 08       	ld.w	r8,r8[0x0]
800067f4:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
800067f8:	5c 58       	castu.b	r8
800067fa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800067fe:	c0 41       	brne	80006806 <tc_configure_interrupts+0xf2>
80006800:	e0 69 00 80 	mov	r9,128
80006804:	c0 28       	rjmp	80006808 <tc_configure_interrupts+0xf4>
80006806:	30 09       	mov	r9,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80006808:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000680c:	70 08       	ld.w	r8,r8[0x0]
8000680e:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80006812:	5c 58       	castu.b	r8
80006814:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006818:	c0 31       	brne	8000681e <tc_configure_interrupts+0x10a>
8000681a:	34 08       	mov	r8,64
8000681c:	c0 28       	rjmp	80006820 <tc_configure_interrupts+0x10c>
8000681e:	30 08       	mov	r8,0
80006820:	10 49       	or	r9,r8
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80006822:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006826:	70 08       	ld.w	r8,r8[0x0]
80006828:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
8000682c:	5c 58       	castu.b	r8
8000682e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006832:	c0 31       	brne	80006838 <tc_configure_interrupts+0x124>
80006834:	32 08       	mov	r8,32
80006836:	c0 28       	rjmp	8000683a <tc_configure_interrupts+0x126>
80006838:	30 08       	mov	r8,0
8000683a:	10 49       	or	r9,r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
8000683c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006840:	70 08       	ld.w	r8,r8[0x0]
80006842:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80006846:	5c 58       	castu.b	r8
80006848:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000684c:	c0 31       	brne	80006852 <tc_configure_interrupts+0x13e>
8000684e:	31 08       	mov	r8,16
80006850:	c0 28       	rjmp	80006854 <tc_configure_interrupts+0x140>
80006852:	30 08       	mov	r8,0
80006854:	10 49       	or	r9,r8
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80006856:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000685a:	70 08       	ld.w	r8,r8[0x0]
8000685c:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80006860:	5c 58       	castu.b	r8
80006862:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006866:	c0 31       	brne	8000686c <tc_configure_interrupts+0x158>
80006868:	30 88       	mov	r8,8
8000686a:	c0 28       	rjmp	8000686e <tc_configure_interrupts+0x15a>
8000686c:	30 08       	mov	r8,0
8000686e:	10 49       	or	r9,r8
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80006870:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006874:	70 08       	ld.w	r8,r8[0x0]
80006876:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
8000687a:	5c 58       	castu.b	r8
8000687c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006880:	c0 31       	brne	80006886 <tc_configure_interrupts+0x172>
80006882:	30 48       	mov	r8,4
80006884:	c0 28       	rjmp	80006888 <tc_configure_interrupts+0x174>
80006886:	30 08       	mov	r8,0
80006888:	10 49       	or	r9,r8
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
8000688a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000688e:	70 08       	ld.w	r8,r8[0x0]
80006890:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80006894:	5c 58       	castu.b	r8
80006896:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000689a:	c0 31       	brne	800068a0 <tc_configure_interrupts+0x18c>
8000689c:	30 28       	mov	r8,2
8000689e:	c0 28       	rjmp	800068a2 <tc_configure_interrupts+0x18e>
800068a0:	30 08       	mov	r8,0
800068a2:	10 49       	or	r9,r8
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
800068a4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800068a8:	70 08       	ld.w	r8,r8[0x0]
800068aa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068ae:	5c 58       	castu.b	r8
800068b0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068b4:	5f 08       	sreq	r8
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800068b6:	f3 e8 10 08 	or	r8,r9,r8
800068ba:	10 99       	mov	r9,r8
800068bc:	ee fa ff f8 	ld.w	r10,r7[-8]
800068c0:	f6 08 15 06 	lsl	r8,r11,0x6
800068c4:	f4 08 00 08 	add	r8,r10,r8
800068c8:	2d 88       	sub	r8,-40
800068ca:	91 09       	st.w	r8[0x0],r9
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
800068cc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800068d0:	ee f9 ff f8 	ld.w	r9,r7[-8]
800068d4:	a1 78       	lsl	r8,0x1
800068d6:	2f f8       	sub	r8,-1
800068d8:	a5 78       	lsl	r8,0x5
800068da:	f2 08 00 08 	add	r8,r9,r8
800068de:	70 08       	ld.w	r8,r8[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
800068e0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800068e4:	30 08       	mov	r8,0
800068e6:	f0 09 18 00 	cp.b	r9,r8
800068ea:	c0 20       	breq	800068ee <tc_configure_interrupts+0x1da>
800068ec:	d5 03       	csrf	0x10

  return 0;
800068ee:	30 08       	mov	r8,0
}
800068f0:	10 9c       	mov	r12,r8
800068f2:	2f cd       	sub	sp,-16
800068f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800068f8:	80 00       	ld.sh	r0,r0[0x0]
800068fa:	66 f4       	ld.w	r4,r3[0x3c]

800068fc <tc_init_waveform>:
  return 0;
}


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
800068fc:	eb cd 40 80 	pushm	r7,lr
80006900:	1a 97       	mov	r7,sp
80006902:	20 2d       	sub	sp,8
80006904:	ef 4c ff fc 	st.w	r7[-4],r12
80006908:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
8000690c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006910:	70 08       	ld.w	r8,r8[0x0]
80006912:	58 28       	cp.w	r8,2
80006914:	e0 88 00 04 	brls	8000691c <tc_init_waveform+0x20>
    return TC_INVALID_ARGUMENT;
80006918:	3f f8       	mov	r8,-1
8000691a:	c9 78       	rjmp	80006a48 <tc_init_waveform+0x14c>

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
8000691c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006920:	70 09       	ld.w	r9,r8[0x0]
80006922:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006926:	70 18       	ld.w	r8,r8[0x4]
80006928:	f1 d8 c3 c2 	bfextu	r8,r8,0x1e,0x2
8000692c:	5c 58       	castu.b	r8
8000692e:	f0 0a 15 1e 	lsl	r10,r8,0x1e
                                  opt->beevt << AVR32_TC_BEEVT_OFFSET |
80006932:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006936:	70 18       	ld.w	r8,r8[0x4]
80006938:	f1 d8 c3 82 	bfextu	r8,r8,0x1c,0x2
8000693c:	5c 58       	castu.b	r8
8000693e:	bd 68       	lsl	r8,0x1c
80006940:	10 4a       	or	r10,r8
                                  opt->bcpc << AVR32_TC_BCPC_OFFSET |
80006942:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006946:	70 18       	ld.w	r8,r8[0x4]
80006948:	f1 d8 c3 42 	bfextu	r8,r8,0x1a,0x2
8000694c:	5c 58       	castu.b	r8
8000694e:	bb 68       	lsl	r8,0x1a
80006950:	10 4a       	or	r10,r8
                                  opt->bcpb << AVR32_TC_BCPB_OFFSET |
80006952:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006956:	70 18       	ld.w	r8,r8[0x4]
80006958:	f1 d8 c3 02 	bfextu	r8,r8,0x18,0x2
8000695c:	5c 58       	castu.b	r8
8000695e:	b9 68       	lsl	r8,0x18
80006960:	10 4a       	or	r10,r8
                                  opt->aswtrg << AVR32_TC_ASWTRG_OFFSET |
80006962:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006966:	70 18       	ld.w	r8,r8[0x4]
80006968:	f1 d8 c2 c2 	bfextu	r8,r8,0x16,0x2
8000696c:	5c 58       	castu.b	r8
8000696e:	b7 68       	lsl	r8,0x16
80006970:	10 4a       	or	r10,r8
                                  opt->aeevt << AVR32_TC_AEEVT_OFFSET |
80006972:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006976:	70 18       	ld.w	r8,r8[0x4]
80006978:	f1 d8 c2 82 	bfextu	r8,r8,0x14,0x2
8000697c:	5c 58       	castu.b	r8
8000697e:	b5 68       	lsl	r8,0x14
80006980:	10 4a       	or	r10,r8
                                  opt->acpc << AVR32_TC_ACPC_OFFSET |
80006982:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006986:	70 18       	ld.w	r8,r8[0x4]
80006988:	f1 d8 c2 42 	bfextu	r8,r8,0x12,0x2
8000698c:	5c 58       	castu.b	r8
8000698e:	b3 68       	lsl	r8,0x12
80006990:	10 4a       	or	r10,r8
                                  opt->acpa << AVR32_TC_ACPA_OFFSET |
80006992:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006996:	70 18       	ld.w	r8,r8[0x4]
80006998:	f1 d8 c2 02 	bfextu	r8,r8,0x10,0x2
8000699c:	5c 58       	castu.b	r8
8000699e:	b1 68       	lsl	r8,0x10
800069a0:	f5 e8 10 08 	or	r8,r10,r8
                                  1 << AVR32_TC_WAVE_OFFSET |
800069a4:	10 9a       	mov	r10,r8
800069a6:	af ba       	sbr	r10,0xf
                                  opt->wavsel << AVR32_TC_WAVSEL_OFFSET |
800069a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800069ac:	70 18       	ld.w	r8,r8[0x4]
800069ae:	f1 d8 c1 a2 	bfextu	r8,r8,0xd,0x2
800069b2:	5c 58       	castu.b	r8
800069b4:	ad 78       	lsl	r8,0xd
800069b6:	10 4a       	or	r10,r8
                                  opt->enetrg << AVR32_TC_ENETRG_OFFSET |
800069b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800069bc:	70 18       	ld.w	r8,r8[0x4]
800069be:	f1 d8 c1 81 	bfextu	r8,r8,0xc,0x1
800069c2:	5c 58       	castu.b	r8
800069c4:	ad 68       	lsl	r8,0xc
800069c6:	10 4a       	or	r10,r8
                                  opt->eevt << AVR32_TC_EEVT_OFFSET |
800069c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800069cc:	70 18       	ld.w	r8,r8[0x4]
800069ce:	f1 d8 c1 42 	bfextu	r8,r8,0xa,0x2
800069d2:	5c 58       	castu.b	r8
800069d4:	ab 68       	lsl	r8,0xa
800069d6:	10 4a       	or	r10,r8
                                  opt->eevtedg << AVR32_TC_EEVTEDG_OFFSET |
800069d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800069dc:	70 18       	ld.w	r8,r8[0x4]
800069de:	f1 d8 c1 02 	bfextu	r8,r8,0x8,0x2
800069e2:	5c 58       	castu.b	r8
800069e4:	a9 68       	lsl	r8,0x8
800069e6:	10 4a       	or	r10,r8
                                  opt->cpcdis << AVR32_TC_CPCDIS_OFFSET |
800069e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800069ec:	70 18       	ld.w	r8,r8[0x4]
800069ee:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
800069f2:	5c 58       	castu.b	r8
800069f4:	a7 78       	lsl	r8,0x7
800069f6:	10 4a       	or	r10,r8
                                  opt->cpcstop << AVR32_TC_CPCSTOP_OFFSET |
800069f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800069fc:	70 18       	ld.w	r8,r8[0x4]
800069fe:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80006a02:	5c 58       	castu.b	r8
80006a04:	a7 68       	lsl	r8,0x6
80006a06:	10 4a       	or	r10,r8
                                  opt->burst << AVR32_TC_BURST_OFFSET |
80006a08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006a0c:	70 18       	ld.w	r8,r8[0x4]
80006a0e:	f1 d8 c0 82 	bfextu	r8,r8,0x4,0x2
80006a12:	5c 58       	castu.b	r8
80006a14:	a5 68       	lsl	r8,0x4
80006a16:	10 4a       	or	r10,r8
                                  opt->clki << AVR32_TC_CLKI_OFFSET |
80006a18:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006a1c:	70 18       	ld.w	r8,r8[0x4]
80006a1e:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80006a22:	5c 58       	castu.b	r8
80006a24:	a3 78       	lsl	r8,0x3
80006a26:	10 4a       	or	r10,r8
                                  opt->tcclks << AVR32_TC_TCCLKS_OFFSET;
80006a28:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006a2c:	70 18       	ld.w	r8,r8[0x4]
80006a2e:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80006a32:	5c 58       	castu.b	r8
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80006a34:	f5 e8 10 08 	or	r8,r10,r8
80006a38:	10 9a       	mov	r10,r8
80006a3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006a3e:	a5 69       	lsl	r9,0x4
80006a40:	2f f9       	sub	r9,-1
80006a42:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
                                  opt->cpcstop << AVR32_TC_CPCSTOP_OFFSET |
                                  opt->burst << AVR32_TC_BURST_OFFSET |
                                  opt->clki << AVR32_TC_CLKI_OFFSET |
                                  opt->tcclks << AVR32_TC_TCCLKS_OFFSET;

  return 0;
80006a46:	30 08       	mov	r8,0
}
80006a48:	10 9c       	mov	r12,r8
80006a4a:	2f ed       	sub	sp,-8
80006a4c:	e3 cd 80 80 	ldm	sp++,r7,pc

80006a50 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
80006a50:	eb cd 40 80 	pushm	r7,lr
80006a54:	1a 97       	mov	r7,sp
80006a56:	20 2d       	sub	sp,8
80006a58:	ef 4c ff fc 	st.w	r7[-4],r12
80006a5c:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80006a60:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006a64:	58 28       	cp.w	r8,2
80006a66:	e0 88 00 04 	brls	80006a6e <tc_start+0x1e>
    return TC_INVALID_ARGUMENT;
80006a6a:	3f f8       	mov	r8,-1
80006a6c:	c0 b8       	rjmp	80006a82 <tc_start+0x32>

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80006a6e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006a72:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006a76:	a7 68       	lsl	r8,0x6
80006a78:	f2 08 00 08 	add	r8,r9,r8
80006a7c:	30 59       	mov	r9,5
80006a7e:	91 09       	st.w	r8[0x0],r9

  return 0;
80006a80:	30 08       	mov	r8,0
}
80006a82:	10 9c       	mov	r12,r8
80006a84:	2f ed       	sub	sp,-8
80006a86:	e3 cd 80 80 	ldm	sp++,r7,pc

80006a8a <tc_read_sr>:
  tc->bcr = AVR32_TC_BCR_SYNC_MASK;
}


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
80006a8a:	eb cd 40 80 	pushm	r7,lr
80006a8e:	1a 97       	mov	r7,sp
80006a90:	20 2d       	sub	sp,8
80006a92:	ef 4c ff fc 	st.w	r7[-4],r12
80006a96:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80006a9a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006a9e:	58 28       	cp.w	r8,2
80006aa0:	e0 88 00 04 	brls	80006aa8 <tc_read_sr+0x1e>
    return TC_INVALID_ARGUMENT;
80006aa4:	3f f8       	mov	r8,-1
80006aa6:	c0 b8       	rjmp	80006abc <tc_read_sr+0x32>

  return tc->channel[channel].sr;
80006aa8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006aac:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006ab0:	a1 78       	lsl	r8,0x1
80006ab2:	2f f8       	sub	r8,-1
80006ab4:	a5 78       	lsl	r8,0x5
80006ab6:	f2 08 00 08 	add	r8,r9,r8
80006aba:	70 08       	ld.w	r8,r8[0x0]
}
80006abc:	10 9c       	mov	r12,r8
80006abe:	2f ed       	sub	sp,-8
80006ac0:	e3 cd 80 80 	ldm	sp++,r7,pc

80006ac4 <tc_write_rc>:
  return value;
}


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
80006ac4:	eb cd 40 80 	pushm	r7,lr
80006ac8:	1a 97       	mov	r7,sp
80006aca:	20 3d       	sub	sp,12
80006acc:	ef 4c ff fc 	st.w	r7[-4],r12
80006ad0:	ef 4b ff f8 	st.w	r7[-8],r11
80006ad4:	14 98       	mov	r8,r10
80006ad6:	ef 58 ff f4 	st.h	r7[-12],r8
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80006ada:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006ade:	58 28       	cp.w	r8,2
80006ae0:	e0 88 00 04 	brls	80006ae8 <tc_write_rc+0x24>
    return TC_INVALID_ARGUMENT;
80006ae4:	3f f8       	mov	r8,-1
80006ae6:	c2 78       	rjmp	80006b34 <tc_write_rc+0x70>

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80006ae8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006aec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006af0:	a5 69       	lsl	r9,0x4
80006af2:	2f f9       	sub	r9,-1
80006af4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006af8:	e2 18 80 00 	andl	r8,0x8000,COH
80006afc:	c1 a0       	breq	80006b30 <tc_write_rc+0x6c>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80006afe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006b02:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006b06:	ee fa ff fc 	ld.w	r10,r7[-4]
80006b0a:	a7 69       	lsl	r9,0x6
80006b0c:	f4 09 00 09 	add	r9,r10,r9
80006b10:	2e 49       	sub	r9,-28
80006b12:	72 09       	ld.w	r9,r9[0x0]
80006b14:	12 9a       	mov	r10,r9
80006b16:	e0 1a 00 00 	andl	r10,0x0
80006b1a:	ef 19 ff f4 	ld.uh	r9,r7[-12]
80006b1e:	f5 e9 10 09 	or	r9,r10,r9
80006b22:	ee fa ff fc 	ld.w	r10,r7[-4]
80006b26:	a7 68       	lsl	r8,0x6
80006b28:	f4 08 00 08 	add	r8,r10,r8
80006b2c:	2e 48       	sub	r8,-28
80006b2e:	91 09       	st.w	r8[0x0],r9

  return value;
80006b30:	ef 18 ff f4 	ld.uh	r8,r7[-12]
}
80006b34:	10 9c       	mov	r12,r8
80006b36:	2f dd       	sub	sp,-12
80006b38:	e3 cd 80 80 	ldm	sp++,r7,pc

80006b3c <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80006b3c:	eb cd 40 80 	pushm	r7,lr
80006b40:	1a 97       	mov	r7,sp
80006b42:	20 3d       	sub	sp,12
80006b44:	ef 4c ff f8 	st.w	r7[-8],r12
80006b48:	ef 4b ff f4 	st.w	r7[-12],r11
80006b4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006b50:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006b54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006b58:	70 58       	ld.w	r8,r8[0x14]
80006b5a:	e2 18 00 02 	andl	r8,0x2,COH
80006b5e:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80006b60:	58 08       	cp.w	r8,0
80006b62:	c0 a0       	breq	80006b76 <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80006b64:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006b68:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80006b6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006b70:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80006b72:	30 08       	mov	r8,0
80006b74:	c0 28       	rjmp	80006b78 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80006b76:	30 28       	mov	r8,2
}
80006b78:	10 9c       	mov	r12,r8
80006b7a:	2f dd       	sub	sp,-12
80006b7c:	e3 cd 80 80 	ldm	sp++,r7,pc

80006b80 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006b80:	eb cd 40 80 	pushm	r7,lr
80006b84:	1a 97       	mov	r7,sp
80006b86:	20 3d       	sub	sp,12
80006b88:	ef 4c ff f8 	st.w	r7[-8],r12
80006b8c:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80006b90:	e0 68 27 10 	mov	r8,10000
80006b94:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
80006b98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006b9c:	58 08       	cp.w	r8,0
80006b9e:	5f 08       	sreq	r8
80006ba0:	5c 58       	castu.b	r8
80006ba2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006ba6:	20 19       	sub	r9,1
80006ba8:	ef 49 ff fc 	st.w	r7[-4],r9
80006bac:	58 08       	cp.w	r8,0
80006bae:	c0 30       	breq	80006bb4 <usart_putchar+0x34>
80006bb0:	3f f8       	mov	r8,-1
80006bb2:	c0 b8       	rjmp	80006bc8 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006bb4:	ee fb ff f4 	ld.w	r11,r7[-12]
80006bb8:	ee fc ff f8 	ld.w	r12,r7[-8]
80006bbc:	f0 1f 00 05 	mcall	80006bd0 <usart_putchar+0x50>
80006bc0:	18 98       	mov	r8,r12
80006bc2:	58 08       	cp.w	r8,0
80006bc4:	ce a1       	brne	80006b98 <usart_putchar+0x18>

  return USART_SUCCESS;
80006bc6:	30 08       	mov	r8,0
}
80006bc8:	10 9c       	mov	r12,r8
80006bca:	2f dd       	sub	sp,-12
80006bcc:	e3 cd 80 80 	ldm	sp++,r7,pc
80006bd0:	80 00       	ld.sh	r0,r0[0x0]
80006bd2:	6b 3c       	ld.w	r12,r5[0x4c]

80006bd4 <usart_read_char>:


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80006bd4:	eb cd 40 80 	pushm	r7,lr
80006bd8:	1a 97       	mov	r7,sp
80006bda:	20 3d       	sub	sp,12
80006bdc:	ef 4c ff f8 	st.w	r7[-8],r12
80006be0:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006be4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006be8:	70 58       	ld.w	r8,r8[0x14]
80006bea:	e2 18 00 e0 	andl	r8,0xe0,COH
80006bee:	c0 30       	breq	80006bf4 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
80006bf0:	30 48       	mov	r8,4
80006bf2:	c1 68       	rjmp	80006c1e <usart_read_char+0x4a>
80006bf4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006bf8:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006bfc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c00:	70 58       	ld.w	r8,r8[0x14]
80006c02:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80006c06:	c0 b0       	breq	80006c1c <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80006c08:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006c0c:	70 68       	ld.w	r8,r8[0x18]
80006c0e:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80006c12:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006c16:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
80006c18:	30 08       	mov	r8,0
80006c1a:	c0 28       	rjmp	80006c1e <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80006c1c:	30 38       	mov	r8,3
}
80006c1e:	10 9c       	mov	r12,r8
80006c20:	2f dd       	sub	sp,-12
80006c22:	e3 cd 80 80 	ldm	sp++,r7,pc
80006c26:	d7 03       	nop

80006c28 <usart_getchar>:


int usart_getchar(volatile avr32_usart_t *usart)
{
80006c28:	eb cd 40 80 	pushm	r7,lr
80006c2c:	1a 97       	mov	r7,sp
80006c2e:	20 3d       	sub	sp,12
80006c30:	ef 4c ff f4 	st.w	r7[-12],r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006c34:	ee c8 00 08 	sub	r8,r7,8
80006c38:	10 9b       	mov	r11,r8
80006c3a:	ee fc ff f4 	ld.w	r12,r7[-12]
80006c3e:	f0 1f 00 0b 	mcall	80006c68 <usart_getchar+0x40>
80006c42:	18 98       	mov	r8,r12
80006c44:	ef 48 ff fc 	st.w	r7[-4],r8
80006c48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c4c:	58 38       	cp.w	r8,3
80006c4e:	cf 30       	breq	80006c34 <usart_getchar+0xc>

  if (ret == USART_RX_ERROR)
80006c50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c54:	58 48       	cp.w	r8,4
80006c56:	c0 31       	brne	80006c5c <usart_getchar+0x34>
    return USART_FAILURE;
80006c58:	3f f8       	mov	r8,-1
80006c5a:	c0 38       	rjmp	80006c60 <usart_getchar+0x38>

  return c;
80006c5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80006c60:	10 9c       	mov	r12,r8
80006c62:	2f dd       	sub	sp,-12
80006c64:	e3 cd 80 80 	ldm	sp++,r7,pc
80006c68:	80 00       	ld.sh	r0,r0[0x0]
80006c6a:	6b d4       	ld.w	r4,r5[0x74]

80006c6c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
80006c6c:	eb cd 40 80 	pushm	r7,lr
80006c70:	1a 97       	mov	r7,sp
80006c72:	20 1d       	sub	sp,4
80006c74:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80006c78:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c7c:	2f 88       	sub	r8,-8
80006c7e:	10 99       	mov	r9,r8
80006c80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c84:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80006c86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c8a:	3f f9       	mov	r9,-1
80006c8c:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80006c8e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c92:	2f 88       	sub	r8,-8
80006c94:	10 99       	mov	r9,r8
80006c96:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c9a:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80006c9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006ca0:	2f 88       	sub	r8,-8
80006ca2:	10 99       	mov	r9,r8
80006ca4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006ca8:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80006caa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006cae:	30 09       	mov	r9,0
80006cb0:	91 09       	st.w	r8[0x0],r9
}
80006cb2:	2f fd       	sub	sp,-4
80006cb4:	e3 cd 80 80 	ldm	sp++,r7,pc

80006cb8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80006cb8:	eb cd 40 80 	pushm	r7,lr
80006cbc:	1a 97       	mov	r7,sp
80006cbe:	20 1d       	sub	sp,4
80006cc0:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80006cc4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006cc8:	30 09       	mov	r9,0
80006cca:	91 49       	st.w	r8[0x10],r9
}
80006ccc:	2f fd       	sub	sp,-4
80006cce:	e3 cd 80 80 	ldm	sp++,r7,pc

80006cd2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
80006cd2:	eb cd 40 80 	pushm	r7,lr
80006cd6:	1a 97       	mov	r7,sp
80006cd8:	20 3d       	sub	sp,12
80006cda:	ef 4c ff f8 	st.w	r7[-8],r12
80006cde:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80006ce2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006ce6:	70 18       	ld.w	r8,r8[0x4]
80006ce8:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80006cec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006cf0:	70 19       	ld.w	r9,r8[0x4]
80006cf2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006cf6:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80006cf8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006cfc:	70 19       	ld.w	r9,r8[0x4]
80006cfe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006d02:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006d04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006d08:	70 18       	ld.w	r8,r8[0x4]
80006d0a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006d0e:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80006d10:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006d14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006d18:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80006d1a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006d1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006d22:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006d24:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006d28:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006d2c:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80006d2e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006d32:	70 08       	ld.w	r8,r8[0x0]
80006d34:	f0 c9 ff ff 	sub	r9,r8,-1
80006d38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006d3c:	91 09       	st.w	r8[0x0],r9
}
80006d3e:	2f dd       	sub	sp,-12
80006d40:	e3 cd 80 80 	ldm	sp++,r7,pc

80006d44 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
80006d44:	eb cd 40 80 	pushm	r7,lr
80006d48:	1a 97       	mov	r7,sp
80006d4a:	20 4d       	sub	sp,16
80006d4c:	ef 4c ff f4 	st.w	r7[-12],r12
80006d50:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80006d54:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006d58:	70 08       	ld.w	r8,r8[0x0]
80006d5a:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80006d5e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006d62:	5b f8       	cp.w	r8,-1
80006d64:	c0 71       	brne	80006d72 <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80006d66:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006d6a:	70 48       	ld.w	r8,r8[0x10]
80006d6c:	ef 48 ff f8 	st.w	r7[-8],r8
80006d70:	c1 58       	rjmp	80006d9a <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80006d72:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006d76:	2f 88       	sub	r8,-8
80006d78:	ef 48 ff f8 	st.w	r7[-8],r8
80006d7c:	c0 68       	rjmp	80006d88 <vListInsert+0x44>
80006d7e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006d82:	70 18       	ld.w	r8,r8[0x4]
80006d84:	ef 48 ff f8 	st.w	r7[-8],r8
80006d88:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006d8c:	70 18       	ld.w	r8,r8[0x4]
80006d8e:	70 09       	ld.w	r9,r8[0x0]
80006d90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006d94:	10 39       	cp.w	r9,r8
80006d96:	fe 98 ff f4 	brls	80006d7e <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80006d9a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006d9e:	70 19       	ld.w	r9,r8[0x4]
80006da0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006da4:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80006da6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006daa:	70 18       	ld.w	r8,r8[0x4]
80006dac:	ee f9 ff f0 	ld.w	r9,r7[-16]
80006db0:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
80006db2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006db6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006dba:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80006dbc:	ee f9 ff f0 	ld.w	r9,r7[-16]
80006dc0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006dc4:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80006dc6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006dca:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006dce:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
80006dd0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006dd4:	70 08       	ld.w	r8,r8[0x0]
80006dd6:	f0 c9 ff ff 	sub	r9,r8,-1
80006dda:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006dde:	91 09       	st.w	r8[0x0],r9
}
80006de0:	2f cd       	sub	sp,-16
80006de2:	e3 cd 80 80 	ldm	sp++,r7,pc

80006de6 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80006de6:	eb cd 40 80 	pushm	r7,lr
80006dea:	1a 97       	mov	r7,sp
80006dec:	20 2d       	sub	sp,8
80006dee:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80006df2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006df6:	70 18       	ld.w	r8,r8[0x4]
80006df8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006dfc:	72 29       	ld.w	r9,r9[0x8]
80006dfe:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80006e00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006e04:	70 28       	ld.w	r8,r8[0x8]
80006e06:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006e0a:	72 19       	ld.w	r9,r9[0x4]
80006e0c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80006e0e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006e12:	70 48       	ld.w	r8,r8[0x10]
80006e14:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80006e18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006e1c:	70 19       	ld.w	r9,r8[0x4]
80006e1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006e22:	10 39       	cp.w	r9,r8
80006e24:	c0 71       	brne	80006e32 <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80006e26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006e2a:	70 29       	ld.w	r9,r8[0x8]
80006e2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006e30:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80006e32:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006e36:	30 09       	mov	r9,0
80006e38:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
80006e3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006e3e:	70 08       	ld.w	r8,r8[0x0]
80006e40:	f0 c9 00 01 	sub	r9,r8,1
80006e44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006e48:	91 09       	st.w	r8[0x0],r9
}
80006e4a:	2f ed       	sub	sp,-8
80006e4c:	e3 cd 80 80 	ldm	sp++,r7,pc

80006e50 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006e50:	eb cd 40 80 	pushm	r7,lr
80006e54:	1a 97       	mov	r7,sp
80006e56:	20 1d       	sub	sp,4
80006e58:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
80006e5c:	f0 1f 00 03 	mcall	80006e68 <__malloc_lock+0x18>
}
80006e60:	2f fd       	sub	sp,-4
80006e62:	e3 cd 80 80 	ldm	sp++,r7,pc
80006e66:	00 00       	add	r0,r0
80006e68:	80 00       	ld.sh	r0,r0[0x0]
80006e6a:	7f 3c       	ld.w	r12,pc[0x4c]

80006e6c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80006e6c:	eb cd 40 80 	pushm	r7,lr
80006e70:	1a 97       	mov	r7,sp
80006e72:	20 1d       	sub	sp,4
80006e74:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
80006e78:	f0 1f 00 03 	mcall	80006e84 <__malloc_unlock+0x18>
}
80006e7c:	2f fd       	sub	sp,-4
80006e7e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006e82:	00 00       	add	r0,r0
80006e84:	80 00       	ld.sh	r0,r0[0x0]
80006e86:	7f 58       	ld.w	r8,pc[0x54]

80006e88 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006e88:	eb cd 00 ff 	pushm	r0-r7
80006e8c:	e0 68 05 28 	mov	r8,1320
80006e90:	ea 18 00 00 	orh	r8,0x0
80006e94:	70 00       	ld.w	r0,r8[0x0]
80006e96:	1a d0       	st.w	--sp,r0
80006e98:	7a 90       	ld.w	r0,sp[0x24]
80006e9a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006e9e:	58 10       	cp.w	r0,1
80006ea0:	e0 8b 00 08 	brhi	80006eb0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006ea4:	e0 68 0b fc 	mov	r8,3068
80006ea8:	ea 18 00 00 	orh	r8,0x0
80006eac:	70 00       	ld.w	r0,r8[0x0]
80006eae:	81 0d       	st.w	r0[0x0],sp

80006eb0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80006eb0:	f0 1f 00 12 	mcall	80006ef8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006eb4:	f0 1f 00 12 	mcall	80006efc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80006eb8:	f0 1f 00 12 	mcall	80006f00 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006ebc:	f0 1f 00 12 	mcall	80006f04 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80006ec0:	7a 90       	ld.w	r0,sp[0x24]
80006ec2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006ec6:	58 10       	cp.w	r0,1
80006ec8:	e0 8b 00 0e 	brhi	80006ee4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006ecc:	f0 1f 00 0c 	mcall	80006efc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80006ed0:	f0 1f 00 0e 	mcall	80006f08 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006ed4:	f0 1f 00 0c 	mcall	80006f04 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006ed8:	e0 68 0b fc 	mov	r8,3068
80006edc:	ea 18 00 00 	orh	r8,0x0
80006ee0:	70 00       	ld.w	r0,r8[0x0]
80006ee2:	60 0d       	ld.w	sp,r0[0x0]

80006ee4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80006ee4:	1b 00       	ld.w	r0,sp++
80006ee6:	e0 68 05 28 	mov	r8,1320
80006eea:	ea 18 00 00 	orh	r8,0x0
80006eee:	91 00       	st.w	r8[0x0],r0
80006ef0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006ef4:	d6 03       	rete
80006ef6:	00 00       	add	r0,r0
80006ef8:	80 00       	ld.sh	r0,r0[0x0]
80006efa:	71 f4       	ld.w	r4,r8[0x7c]
80006efc:	80 00       	ld.sh	r0,r0[0x0]
80006efe:	6f a4       	ld.w	r4,r7[0x68]
80006f00:	80 00       	ld.sh	r0,r0[0x0]
80006f02:	80 b0       	ld.uh	r0,r0[0x6]
80006f04:	80 00       	ld.sh	r0,r0[0x0]
80006f06:	6f c0       	ld.w	r0,r7[0x70]
80006f08:	80 00       	ld.sh	r0,r0[0x0]
80006f0a:	82 10       	ld.sh	r0,r1[0x2]

80006f0c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80006f0c:	20 6d       	sub	sp,24
80006f0e:	eb cd 00 ff 	pushm	r0-r7
80006f12:	fa c7 ff c0 	sub	r7,sp,-64
80006f16:	ee f0 ff f8 	ld.w	r0,r7[-8]
80006f1a:	ef 40 ff e0 	st.w	r7[-32],r0
80006f1e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80006f22:	ef 40 ff e4 	st.w	r7[-28],r0
80006f26:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80006f2a:	e0 68 05 28 	mov	r8,1320
80006f2e:	ea 18 00 00 	orh	r8,0x0
80006f32:	70 00       	ld.w	r0,r8[0x0]
80006f34:	1a d0       	st.w	--sp,r0
80006f36:	f0 1f 00 1a 	mcall	80006f9c <LABEL_RET_SCALL_263+0x14>
80006f3a:	e0 68 0b fc 	mov	r8,3068
80006f3e:	ea 18 00 00 	orh	r8,0x0
80006f42:	70 00       	ld.w	r0,r8[0x0]
80006f44:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80006f46:	f0 1f 00 17 	mcall	80006fa0 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80006f4a:	e0 68 0b fc 	mov	r8,3068
80006f4e:	ea 18 00 00 	orh	r8,0x0
80006f52:	70 00       	ld.w	r0,r8[0x0]
80006f54:	60 0d       	ld.w	sp,r0[0x0]
80006f56:	1b 00       	ld.w	r0,sp++
80006f58:	e0 68 05 28 	mov	r8,1320
80006f5c:	ea 18 00 00 	orh	r8,0x0
80006f60:	91 00       	st.w	r8[0x0],r0
80006f62:	fa c7 ff d8 	sub	r7,sp,-40
80006f66:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006f6a:	ee f0 ff e0 	ld.w	r0,r7[-32]
80006f6e:	e0 61 05 28 	mov	r1,1320
80006f72:	ea 11 00 00 	orh	r1,0x0
80006f76:	62 02       	ld.w	r2,r1[0x0]
80006f78:	58 02       	cp.w	r2,0
80006f7a:	c0 70       	breq	80006f88 <LABEL_RET_SCALL_263>
80006f7c:	e4 c2 00 01 	sub	r2,r2,1
80006f80:	83 02       	st.w	r1[0x0],r2
80006f82:	58 02       	cp.w	r2,0
80006f84:	c0 21       	brne	80006f88 <LABEL_RET_SCALL_263>
80006f86:	b1 c0       	cbr	r0,0x10

80006f88 <LABEL_RET_SCALL_263>:
80006f88:	ef 40 ff f8 	st.w	r7[-8],r0
80006f8c:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006f90:	ef 40 ff fc 	st.w	r7[-4],r0
80006f94:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006f98:	2f ad       	sub	sp,-24
80006f9a:	d6 13       	rets
80006f9c:	80 00       	ld.sh	r0,r0[0x0]
80006f9e:	6f a4       	ld.w	r4,r7[0x68]
80006fa0:	80 00       	ld.sh	r0,r0[0x0]
80006fa2:	82 10       	ld.sh	r0,r1[0x2]

80006fa4 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80006fa4:	eb cd 40 80 	pushm	r7,lr
80006fa8:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006faa:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006fac:	48 48       	lddpc	r8,80006fbc <vPortEnterCritical+0x18>
80006fae:	70 08       	ld.w	r8,r8[0x0]
80006fb0:	f0 c9 ff ff 	sub	r9,r8,-1
80006fb4:	48 28       	lddpc	r8,80006fbc <vPortEnterCritical+0x18>
80006fb6:	91 09       	st.w	r8[0x0],r9
}
80006fb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fbc:	00 00       	add	r0,r0
80006fbe:	05 28       	ld.uh	r8,r2++

80006fc0 <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
80006fc0:	eb cd 40 80 	pushm	r7,lr
80006fc4:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006fc6:	48 98       	lddpc	r8,80006fe8 <vPortExitCritical+0x28>
80006fc8:	70 08       	ld.w	r8,r8[0x0]
80006fca:	58 08       	cp.w	r8,0
80006fcc:	c0 c0       	breq	80006fe4 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
80006fce:	48 78       	lddpc	r8,80006fe8 <vPortExitCritical+0x28>
80006fd0:	70 08       	ld.w	r8,r8[0x0]
80006fd2:	f0 c9 00 01 	sub	r9,r8,1
80006fd6:	48 58       	lddpc	r8,80006fe8 <vPortExitCritical+0x28>
80006fd8:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006fda:	48 48       	lddpc	r8,80006fe8 <vPortExitCritical+0x28>
80006fdc:	70 08       	ld.w	r8,r8[0x0]
80006fde:	58 08       	cp.w	r8,0
80006fe0:	c0 21       	brne	80006fe4 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006fe2:	d5 03       	csrf	0x10
		}
	}
}
80006fe4:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fe8:	00 00       	add	r0,r0
80006fea:	05 28       	ld.uh	r8,r2++

80006fec <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80006fec:	eb cd 40 80 	pushm	r7,lr
80006ff0:	1a 97       	mov	r7,sp
80006ff2:	20 3d       	sub	sp,12
80006ff4:	ef 4c ff fc 	st.w	r7[-4],r12
80006ff8:	ef 4b ff f8 	st.w	r7[-8],r11
80006ffc:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
80007000:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007004:	20 48       	sub	r8,4
80007006:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000700a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000700e:	e0 69 08 08 	mov	r9,2056
80007012:	ea 19 08 08 	orh	r9,0x808
80007016:	91 09       	st.w	r8[0x0],r9
80007018:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000701c:	20 48       	sub	r8,4
8000701e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80007022:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007026:	e0 69 09 09 	mov	r9,2313
8000702a:	ea 19 09 09 	orh	r9,0x909
8000702e:	91 09       	st.w	r8[0x0],r9
80007030:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007034:	20 48       	sub	r8,4
80007036:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
8000703a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000703e:	e0 69 0a 0a 	mov	r9,2570
80007042:	ea 19 0a 0a 	orh	r9,0xa0a
80007046:	91 09       	st.w	r8[0x0],r9
80007048:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000704c:	20 48       	sub	r8,4
8000704e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80007052:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007056:	e0 69 0b 0b 	mov	r9,2827
8000705a:	ea 19 0b 0b 	orh	r9,0xb0b
8000705e:	91 09       	st.w	r8[0x0],r9
80007060:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007064:	20 48       	sub	r8,4
80007066:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
8000706a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000706e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007072:	91 09       	st.w	r8[0x0],r9
80007074:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007078:	20 48       	sub	r8,4
8000707a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000707e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007082:	e0 69 be ef 	mov	r9,48879
80007086:	ea 19 de ad 	orh	r9,0xdead
8000708a:	91 09       	st.w	r8[0x0],r9
8000708c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007090:	20 48       	sub	r8,4
80007092:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80007096:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000709a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000709e:	91 09       	st.w	r8[0x0],r9
800070a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070a4:	20 48       	sub	r8,4
800070a6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800070aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070ae:	fc 19 00 40 	movh	r9,0x40
800070b2:	91 09       	st.w	r8[0x0],r9
800070b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070b8:	20 48       	sub	r8,4
800070ba:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800070be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070c2:	e0 69 00 ff 	mov	r9,255
800070c6:	ea 19 ff 00 	orh	r9,0xff00
800070ca:	91 09       	st.w	r8[0x0],r9
800070cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070d0:	20 48       	sub	r8,4
800070d2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800070d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070da:	e0 69 01 01 	mov	r9,257
800070de:	ea 19 01 01 	orh	r9,0x101
800070e2:	91 09       	st.w	r8[0x0],r9
800070e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070e8:	20 48       	sub	r8,4
800070ea:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800070ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800070f2:	e0 69 02 02 	mov	r9,514
800070f6:	ea 19 02 02 	orh	r9,0x202
800070fa:	91 09       	st.w	r8[0x0],r9
800070fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007100:	20 48       	sub	r8,4
80007102:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80007106:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000710a:	e0 69 03 03 	mov	r9,771
8000710e:	ea 19 03 03 	orh	r9,0x303
80007112:	91 09       	st.w	r8[0x0],r9
80007114:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007118:	20 48       	sub	r8,4
8000711a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000711e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007122:	e0 69 04 04 	mov	r9,1028
80007126:	ea 19 04 04 	orh	r9,0x404
8000712a:	91 09       	st.w	r8[0x0],r9
8000712c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007130:	20 48       	sub	r8,4
80007132:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80007136:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000713a:	e0 69 05 05 	mov	r9,1285
8000713e:	ea 19 05 05 	orh	r9,0x505
80007142:	91 09       	st.w	r8[0x0],r9
80007144:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007148:	20 48       	sub	r8,4
8000714a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
8000714e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007152:	e0 69 06 06 	mov	r9,1542
80007156:	ea 19 06 06 	orh	r9,0x606
8000715a:	91 09       	st.w	r8[0x0],r9
8000715c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007160:	20 48       	sub	r8,4
80007162:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80007166:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000716a:	e0 69 07 07 	mov	r9,1799
8000716e:	ea 19 07 07 	orh	r9,0x707
80007172:	91 09       	st.w	r8[0x0],r9
80007174:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007178:	20 48       	sub	r8,4
8000717a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
8000717e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007182:	30 09       	mov	r9,0
80007184:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
80007186:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000718a:	10 9c       	mov	r12,r8
8000718c:	2f dd       	sub	sp,-12
8000718e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007192:	d7 03       	nop

80007194 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80007194:	eb cd 40 80 	pushm	r7,lr
80007198:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
8000719a:	f0 1f 00 10 	mcall	800071d8 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000719e:	e0 68 0b fc 	mov	r8,3068
800071a2:	ea 18 00 00 	orh	r8,0x0
800071a6:	70 00       	ld.w	r0,r8[0x0]
800071a8:	60 0d       	ld.w	sp,r0[0x0]
800071aa:	1b 00       	ld.w	r0,sp++
800071ac:	e0 68 05 28 	mov	r8,1320
800071b0:	ea 18 00 00 	orh	r8,0x0
800071b4:	91 00       	st.w	r8[0x0],r0
800071b6:	e3 cd 00 ff 	ldm	sp++,r0-r7
800071ba:	2f ed       	sub	sp,-8
800071bc:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800071c0:	fa f0 ff e0 	ld.w	r0,sp[-32]
800071c4:	e3 b0 00 00 	mtsr	0x0,r0
800071c8:	fa f0 ff dc 	ld.w	r0,sp[-36]
800071cc:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
800071d0:	30 08       	mov	r8,0
}
800071d2:	10 9c       	mov	r12,r8
800071d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800071d8:	80 00       	ld.sh	r0,r0[0x0]
800071da:	72 08       	ld.w	r8,r9[0x0]

800071dc <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
800071dc:	eb cd 40 80 	pushm	r7,lr
800071e0:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800071e2:	e0 68 5d c0 	mov	r8,24000
800071e6:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800071ea:	30 08       	mov	r8,0
800071ec:	e3 b8 00 42 	mtsr	0x108,r8
	}
800071f0:	e3 cd 80 80 	ldm	sp++,r7,pc

800071f4 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
800071f4:	eb cd 40 80 	pushm	r7,lr
800071f8:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800071fa:	e1 b8 00 43 	mfsr	r8,0x10c
800071fe:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80007202:	e3 cd 80 80 	ldm	sp++,r7,pc
80007206:	d7 03       	nop

80007208 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
80007208:	eb cd 40 80 	pushm	r7,lr
8000720c:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000720e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80007210:	30 0a       	mov	r10,0
80007212:	30 0b       	mov	r11,0
80007214:	48 4c       	lddpc	r12,80007224 <prvSetupTimerInterrupt+0x1c>
80007216:	f0 1f 00 05 	mcall	80007228 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
8000721a:	f0 1f 00 05 	mcall	8000722c <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
8000721e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007222:	00 00       	add	r0,r0
80007224:	80 00       	ld.sh	r0,r0[0x0]
80007226:	6e 88       	ld.w	r8,r7[0x20]
80007228:	80 00       	ld.sh	r0,r0[0x0]
8000722a:	66 20       	ld.w	r0,r3[0x8]
8000722c:	80 00       	ld.sh	r0,r0[0x0]
8000722e:	71 dc       	ld.w	r12,r8[0x74]

80007230 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80007230:	eb cd 40 80 	pushm	r7,lr
80007234:	1a 97       	mov	r7,sp
80007236:	20 5d       	sub	sp,20
80007238:	ef 4c ff f4 	st.w	r7[-12],r12
8000723c:	ef 4b ff f0 	st.w	r7[-16],r11
80007240:	ef 4a ff ec 	st.w	r7[-20],r10
  int nChars = 0;
80007244:	30 08       	mov	r8,0
80007246:	ef 48 ff f8 	st.w	r7[-8],r8

  if (file != 0)
8000724a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000724e:	58 08       	cp.w	r8,0
80007250:	c2 40       	breq	80007298 <_read+0x68>
    return -1;
80007252:	3f f8       	mov	r8,-1
80007254:	c2 b8       	rjmp	800072aa <_read+0x7a>

  for (; len > 0; --len)
  {
    int c = usart_getchar(stdio_usart_base);
80007256:	49 88       	lddpc	r8,800072b4 <_read+0x84>
80007258:	70 08       	ld.w	r8,r8[0x0]
8000725a:	10 9c       	mov	r12,r8
8000725c:	f0 1f 00 17 	mcall	800072b8 <_read+0x88>
80007260:	18 98       	mov	r8,r12
80007262:	ef 48 ff fc 	st.w	r7[-4],r8
    if (c < 0)
80007266:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000726a:	58 08       	cp.w	r8,0
8000726c:	c1 c5       	brlt	800072a4 <_read+0x74>
      break;

    *ptr++ = c;
8000726e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007272:	5c 58       	castu.b	r8
80007274:	ee f9 ff f0 	ld.w	r9,r7[-16]
80007278:	b2 88       	st.b	r9[0x0],r8
8000727a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000727e:	2f f8       	sub	r8,-1
80007280:	ef 48 ff f0 	st.w	r7[-16],r8
    ++nChars;
80007284:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007288:	2f f8       	sub	r8,-1
8000728a:	ef 48 ff f8 	st.w	r7[-8],r8
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000728e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007292:	20 18       	sub	r8,1
80007294:	ef 48 ff ec 	st.w	r7[-20],r8
80007298:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000729c:	58 08       	cp.w	r8,0
8000729e:	fe 99 ff dc 	brgt	80007256 <_read+0x26>
800072a2:	c0 28       	rjmp	800072a6 <_read+0x76>
  {
    int c = usart_getchar(stdio_usart_base);
    if (c < 0)
      break;
800072a4:	d7 03       	nop

    *ptr++ = c;
    ++nChars;
  }

  return nChars;
800072a6:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800072aa:	10 9c       	mov	r12,r8
800072ac:	2f bd       	sub	sp,-20
800072ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800072b2:	00 00       	add	r0,r0
800072b4:	00 00       	add	r0,r0
800072b6:	40 ec       	lddsp	r12,sp[0x38]
800072b8:	80 00       	ld.sh	r0,r0[0x0]
800072ba:	6c 28       	ld.w	r8,r6[0x8]

800072bc <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800072bc:	eb cd 40 80 	pushm	r7,lr
800072c0:	1a 97       	mov	r7,sp
800072c2:	20 4d       	sub	sp,16
800072c4:	ef 4c ff f8 	st.w	r7[-8],r12
800072c8:	ef 4b ff f4 	st.w	r7[-12],r11
800072cc:	ef 4a ff f0 	st.w	r7[-16],r10
  int nChars = 0;
800072d0:	30 08       	mov	r8,0
800072d2:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
800072d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800072da:	58 18       	cp.w	r8,1
800072dc:	c2 90       	breq	8000732e <_write+0x72>
800072de:	ee f8 ff f8 	ld.w	r8,r7[-8]
800072e2:	58 28       	cp.w	r8,2
800072e4:	c2 50       	breq	8000732e <_write+0x72>
800072e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800072ea:	58 38       	cp.w	r8,3
800072ec:	c2 10       	breq	8000732e <_write+0x72>
       && (file != 2) && (file!=3))
    return -1;
800072ee:	3f f8       	mov	r8,-1
800072f0:	c2 58       	rjmp	8000733a <_write+0x7e>

  for (; len != 0; --len)
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800072f2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800072f6:	11 88       	ld.ub	r8,r8[0x0]
800072f8:	10 99       	mov	r9,r8
800072fa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800072fe:	2f f8       	sub	r8,-1
80007300:	ef 48 ff f4 	st.w	r7[-12],r8
80007304:	49 08       	lddpc	r8,80007344 <_write+0x88>
80007306:	70 08       	ld.w	r8,r8[0x0]
80007308:	12 9b       	mov	r11,r9
8000730a:	10 9c       	mov	r12,r8
8000730c:	f0 1f 00 0f 	mcall	80007348 <_write+0x8c>
80007310:	18 98       	mov	r8,r12
80007312:	58 08       	cp.w	r8,0
80007314:	c0 34       	brge	8000731a <_write+0x5e>
    {
      return -1;
80007316:	3f f8       	mov	r8,-1
80007318:	c1 18       	rjmp	8000733a <_write+0x7e>
    }

    ++nChars;
8000731a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000731e:	2f f8       	sub	r8,-1
80007320:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80007324:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007328:	20 18       	sub	r8,1
8000732a:	ef 48 ff f0 	st.w	r7[-16],r8
8000732e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007332:	58 08       	cp.w	r8,0
80007334:	cd f1       	brne	800072f2 <_write+0x36>
    }

    ++nChars;
  }

  return nChars;
80007336:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000733a:	10 9c       	mov	r12,r8
8000733c:	2f cd       	sub	sp,-16
8000733e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007342:	00 00       	add	r0,r0
80007344:	00 00       	add	r0,r0
80007346:	40 ec       	lddsp	r12,sp[0x38]
80007348:	80 00       	ld.sh	r0,r0[0x0]
8000734a:	6b 80       	ld.w	r0,r5[0x60]

8000734c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000734c:	eb cd 40 80 	pushm	r7,lr
80007350:	1a 97       	mov	r7,sp
80007352:	20 2d       	sub	sp,8
80007354:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
80007358:	f0 1f 00 09 	mcall	8000737c <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
8000735c:	ee fc ff f8 	ld.w	r12,r7[-8]
80007360:	f0 1f 00 08 	mcall	80007380 <pvPortMalloc+0x34>
80007364:	18 98       	mov	r8,r12
80007366:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
8000736a:	f0 1f 00 07 	mcall	80007384 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
8000736e:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80007372:	10 9c       	mov	r12,r8
80007374:	2f ed       	sub	sp,-8
80007376:	e3 cd 80 80 	ldm	sp++,r7,pc
8000737a:	00 00       	add	r0,r0
8000737c:	80 00       	ld.sh	r0,r0[0x0]
8000737e:	7f 3c       	ld.w	r12,pc[0x4c]
80007380:	80 00       	ld.sh	r0,r0[0x0]
80007382:	93 40       	st.w	r9[0x10],r0
80007384:	80 00       	ld.sh	r0,r0[0x0]
80007386:	7f 58       	ld.w	r8,pc[0x54]

80007388 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80007388:	eb cd 40 80 	pushm	r7,lr
8000738c:	1a 97       	mov	r7,sp
8000738e:	20 1d       	sub	sp,4
80007390:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
80007394:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007398:	58 08       	cp.w	r8,0
8000739a:	c0 90       	breq	800073ac <vPortFree+0x24>
	{
		vTaskSuspendAll();
8000739c:	f0 1f 00 06 	mcall	800073b4 <vPortFree+0x2c>
		{
			free( pv );
800073a0:	ee fc ff fc 	ld.w	r12,r7[-4]
800073a4:	f0 1f 00 05 	mcall	800073b8 <vPortFree+0x30>
		}
		xTaskResumeAll();
800073a8:	f0 1f 00 05 	mcall	800073bc <vPortFree+0x34>
	}
}
800073ac:	2f fd       	sub	sp,-4
800073ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800073b2:	00 00       	add	r0,r0
800073b4:	80 00       	ld.sh	r0,r0[0x0]
800073b6:	7f 3c       	ld.w	r12,pc[0x4c]
800073b8:	80 00       	ld.sh	r0,r0[0x0]
800073ba:	93 30       	st.w	r9[0xc],r0
800073bc:	80 00       	ld.sh	r0,r0[0x0]
800073be:	7f 58       	ld.w	r8,pc[0x54]

800073c0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800073c0:	eb cd 40 80 	pushm	r7,lr
800073c4:	1a 97       	mov	r7,sp
800073c6:	20 5d       	sub	sp,20
800073c8:	ef 4c ff f0 	st.w	r7[-16],r12
800073cc:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
800073d0:	30 08       	mov	r8,0
800073d2:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800073d6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800073da:	58 08       	cp.w	r8,0
800073dc:	c7 20       	breq	800074c0 <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800073de:	34 cc       	mov	r12,76
800073e0:	f0 1f 00 3b 	mcall	800074cc <xQueueCreate+0x10c>
800073e4:	18 98       	mov	r8,r12
800073e6:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
800073ea:	ee f8 ff f4 	ld.w	r8,r7[-12]
800073ee:	58 08       	cp.w	r8,0
800073f0:	c6 80       	breq	800074c0 <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800073f2:	ee f9 ff f0 	ld.w	r9,r7[-16]
800073f6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800073fa:	f2 08 02 48 	mul	r8,r9,r8
800073fe:	2f f8       	sub	r8,-1
80007400:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80007404:	ee fc ff f8 	ld.w	r12,r7[-8]
80007408:	f0 1f 00 31 	mcall	800074cc <xQueueCreate+0x10c>
8000740c:	18 98       	mov	r8,r12
8000740e:	10 99       	mov	r9,r8
80007410:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007414:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
80007416:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000741a:	70 08       	ld.w	r8,r8[0x0]
8000741c:	58 08       	cp.w	r8,0
8000741e:	c4 d0       	breq	800074b8 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80007420:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007424:	70 09       	ld.w	r9,r8[0x0]
80007426:	ee fa ff f0 	ld.w	r10,r7[-16]
8000742a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000742e:	f4 08 02 48 	mul	r8,r10,r8
80007432:	10 09       	add	r9,r8
80007434:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007438:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000743a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000743e:	30 09       	mov	r9,0
80007440:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80007442:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007446:	70 09       	ld.w	r9,r8[0x0]
80007448:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000744c:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000744e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007452:	70 09       	ld.w	r9,r8[0x0]
80007454:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007458:	f0 ca 00 01 	sub	r10,r8,1
8000745c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007460:	f4 08 02 48 	mul	r8,r10,r8
80007464:	10 09       	add	r9,r8
80007466:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000746a:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
8000746c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007470:	ee f9 ff f0 	ld.w	r9,r7[-16]
80007474:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
80007476:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000747a:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000747e:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
80007482:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007486:	3f f9       	mov	r9,-1
80007488:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
8000748c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007490:	3f f9       	mov	r9,-1
80007492:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80007496:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000749a:	2f 08       	sub	r8,-16
8000749c:	10 9c       	mov	r12,r8
8000749e:	f0 1f 00 0d 	mcall	800074d0 <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800074a2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800074a6:	2d c8       	sub	r8,-36
800074a8:	10 9c       	mov	r12,r8
800074aa:	f0 1f 00 0a 	mcall	800074d0 <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
800074ae:	ee f8 ff f4 	ld.w	r8,r7[-12]
800074b2:	ef 48 ff fc 	st.w	r7[-4],r8
800074b6:	c0 58       	rjmp	800074c0 <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800074b8:	ee fc ff f4 	ld.w	r12,r7[-12]
800074bc:	f0 1f 00 06 	mcall	800074d4 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
800074c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800074c4:	10 9c       	mov	r12,r8
800074c6:	2f bd       	sub	sp,-20
800074c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800074cc:	80 00       	ld.sh	r0,r0[0x0]
800074ce:	73 4c       	ld.w	r12,r9[0x50]
800074d0:	80 00       	ld.sh	r0,r0[0x0]
800074d2:	6c 6c       	ld.w	r12,r6[0x18]
800074d4:	80 00       	ld.sh	r0,r0[0x0]
800074d6:	73 88       	ld.w	r8,r9[0x60]

800074d8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800074d8:	eb cd 40 80 	pushm	r7,lr
800074dc:	1a 97       	mov	r7,sp
800074de:	20 7d       	sub	sp,28
800074e0:	ef 4c ff f0 	st.w	r7[-16],r12
800074e4:	ef 4b ff ec 	st.w	r7[-20],r11
800074e8:	ef 4a ff e8 	st.w	r7[-24],r10
800074ec:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
800074f0:	30 08       	mov	r8,0
800074f2:	ef 48 ff fc 	st.w	r7[-4],r8
800074f6:	c0 28       	rjmp	800074fa <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
800074f8:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800074fa:	f0 1f 00 47 	mcall	80007614 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800074fe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007502:	70 e9       	ld.w	r9,r8[0x38]
80007504:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007508:	70 f8       	ld.w	r8,r8[0x3c]
8000750a:	10 39       	cp.w	r9,r8
8000750c:	c1 c2       	brcc	80007544 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000750e:	ee fa ff e4 	ld.w	r10,r7[-28]
80007512:	ee fb ff ec 	ld.w	r11,r7[-20]
80007516:	ee fc ff f0 	ld.w	r12,r7[-16]
8000751a:	f0 1f 00 40 	mcall	80007618 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000751e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007522:	70 98       	ld.w	r8,r8[0x24]
80007524:	58 08       	cp.w	r8,0
80007526:	c0 b0       	breq	8000753c <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80007528:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000752c:	2d c8       	sub	r8,-36
8000752e:	10 9c       	mov	r12,r8
80007530:	f0 1f 00 3b 	mcall	8000761c <xQueueGenericSend+0x144>
80007534:	18 98       	mov	r8,r12
80007536:	58 18       	cp.w	r8,1
80007538:	c0 21       	brne	8000753c <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000753a:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000753c:	f0 1f 00 39 	mcall	80007620 <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80007540:	30 18       	mov	r8,1
80007542:	c6 58       	rjmp	8000760c <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80007544:	ee f8 ff e8 	ld.w	r8,r7[-24]
80007548:	58 08       	cp.w	r8,0
8000754a:	c0 51       	brne	80007554 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000754c:	f0 1f 00 35 	mcall	80007620 <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80007550:	30 08       	mov	r8,0
80007552:	c5 d8       	rjmp	8000760c <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
80007554:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007558:	58 08       	cp.w	r8,0
8000755a:	c0 91       	brne	8000756c <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000755c:	ee c8 00 0c 	sub	r8,r7,12
80007560:	10 9c       	mov	r12,r8
80007562:	f0 1f 00 31 	mcall	80007624 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
80007566:	30 18       	mov	r8,1
80007568:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
8000756c:	f0 1f 00 2d 	mcall	80007620 <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80007570:	f0 1f 00 2e 	mcall	80007628 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
80007574:	f0 1f 00 28 	mcall	80007614 <xQueueGenericSend+0x13c>
80007578:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000757c:	71 18       	ld.w	r8,r8[0x44]
8000757e:	5b f8       	cp.w	r8,-1
80007580:	c0 61       	brne	8000758c <xQueueGenericSend+0xb4>
80007582:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007586:	30 09       	mov	r9,0
80007588:	f1 49 00 44 	st.w	r8[68],r9
8000758c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007590:	71 28       	ld.w	r8,r8[0x48]
80007592:	5b f8       	cp.w	r8,-1
80007594:	c0 61       	brne	800075a0 <xQueueGenericSend+0xc8>
80007596:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000759a:	30 09       	mov	r9,0
8000759c:	f1 49 00 48 	st.w	r8[72],r9
800075a0:	f0 1f 00 20 	mcall	80007620 <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800075a4:	ee c9 00 18 	sub	r9,r7,24
800075a8:	ee c8 00 0c 	sub	r8,r7,12
800075ac:	12 9b       	mov	r11,r9
800075ae:	10 9c       	mov	r12,r8
800075b0:	f0 1f 00 1f 	mcall	8000762c <xQueueGenericSend+0x154>
800075b4:	18 98       	mov	r8,r12
800075b6:	58 08       	cp.w	r8,0
800075b8:	c2 31       	brne	800075fe <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
800075ba:	ee fc ff f0 	ld.w	r12,r7[-16]
800075be:	f0 1f 00 1d 	mcall	80007630 <xQueueGenericSend+0x158>
800075c2:	18 98       	mov	r8,r12
800075c4:	58 08       	cp.w	r8,0
800075c6:	c1 50       	breq	800075f0 <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800075c8:	ee f9 ff e8 	ld.w	r9,r7[-24]
800075cc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800075d0:	2f 08       	sub	r8,-16
800075d2:	12 9b       	mov	r11,r9
800075d4:	10 9c       	mov	r12,r8
800075d6:	f0 1f 00 18 	mcall	80007634 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800075da:	ee fc ff f0 	ld.w	r12,r7[-16]
800075de:	f0 1f 00 17 	mcall	80007638 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800075e2:	f0 1f 00 17 	mcall	8000763c <xQueueGenericSend+0x164>
800075e6:	18 98       	mov	r8,r12
800075e8:	58 08       	cp.w	r8,0
800075ea:	c8 71       	brne	800074f8 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
800075ec:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
800075ee:	c8 6b       	rjmp	800074fa <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800075f0:	ee fc ff f0 	ld.w	r12,r7[-16]
800075f4:	f0 1f 00 11 	mcall	80007638 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
800075f8:	f0 1f 00 11 	mcall	8000763c <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
800075fc:	c7 fb       	rjmp	800074fa <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800075fe:	ee fc ff f0 	ld.w	r12,r7[-16]
80007602:	f0 1f 00 0e 	mcall	80007638 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80007606:	f0 1f 00 0e 	mcall	8000763c <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
8000760a:	30 08       	mov	r8,0
		}
	}
}
8000760c:	10 9c       	mov	r12,r8
8000760e:	2f 9d       	sub	sp,-28
80007610:	e3 cd 80 80 	ldm	sp++,r7,pc
80007614:	80 00       	ld.sh	r0,r0[0x0]
80007616:	6f a4       	ld.w	r4,r7[0x68]
80007618:	80 00       	ld.sh	r0,r0[0x0]
8000761a:	79 74       	ld.w	r4,r12[0x5c]
8000761c:	80 00       	ld.sh	r0,r0[0x0]
8000761e:	83 40       	st.w	r1[0x10],r0
80007620:	80 00       	ld.sh	r0,r0[0x0]
80007622:	6f c0       	ld.w	r0,r7[0x70]
80007624:	80 00       	ld.sh	r0,r0[0x0]
80007626:	84 10       	ld.sh	r0,r2[0x2]
80007628:	80 00       	ld.sh	r0,r0[0x0]
8000762a:	7f 3c       	ld.w	r12,pc[0x4c]
8000762c:	80 00       	ld.sh	r0,r0[0x0]
8000762e:	84 40       	ld.sh	r0,r2[0x8]
80007630:	80 00       	ld.sh	r0,r0[0x0]
80007632:	7b ec       	ld.w	r12,sp[0x78]
80007634:	80 00       	ld.sh	r0,r0[0x0]
80007636:	82 c0       	ld.uh	r0,r1[0x8]
80007638:	80 00       	ld.sh	r0,r0[0x0]
8000763a:	7a e4       	ld.w	r4,sp[0x38]
8000763c:	80 00       	ld.sh	r0,r0[0x0]
8000763e:	7f 58       	ld.w	r8,pc[0x54]

80007640 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80007640:	eb cd 40 80 	pushm	r7,lr
80007644:	1a 97       	mov	r7,sp
80007646:	20 6d       	sub	sp,24
80007648:	ef 4c ff f4 	st.w	r7[-12],r12
8000764c:	ef 4b ff f0 	st.w	r7[-16],r11
80007650:	ef 4a ff ec 	st.w	r7[-20],r10
80007654:	ef 49 ff e8 	st.w	r7[-24],r9
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80007658:	30 08       	mov	r8,0
8000765a:	ef 48 ff fc 	st.w	r7[-4],r8
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000765e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007662:	70 e9       	ld.w	r9,r8[0x38]
80007664:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007668:	70 f8       	ld.w	r8,r8[0x3c]
8000766a:	10 39       	cp.w	r9,r8
8000766c:	c2 e2       	brcc	800076c8 <xQueueGenericSendFromISR+0x88>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000766e:	ee fa ff e8 	ld.w	r10,r7[-24]
80007672:	ee fb ff f0 	ld.w	r11,r7[-16]
80007676:	ee fc ff f4 	ld.w	r12,r7[-12]
8000767a:	f0 1f 00 19 	mcall	800076dc <xQueueGenericSendFromISR+0x9c>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000767e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007682:	71 28       	ld.w	r8,r8[0x48]
80007684:	5b f8       	cp.w	r8,-1
80007686:	c1 41       	brne	800076ae <xQueueGenericSendFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007688:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000768c:	70 98       	ld.w	r8,r8[0x24]
8000768e:	58 08       	cp.w	r8,0
80007690:	c1 80       	breq	800076c0 <xQueueGenericSendFromISR+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007692:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007696:	2d c8       	sub	r8,-36
80007698:	10 9c       	mov	r12,r8
8000769a:	f0 1f 00 12 	mcall	800076e0 <xQueueGenericSendFromISR+0xa0>
8000769e:	18 98       	mov	r8,r12
800076a0:	58 08       	cp.w	r8,0
800076a2:	c0 f0       	breq	800076c0 <xQueueGenericSendFromISR+0x80>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800076a4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800076a8:	30 19       	mov	r9,1
800076aa:	91 09       	st.w	r8[0x0],r9
800076ac:	c0 a8       	rjmp	800076c0 <xQueueGenericSendFromISR+0x80>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800076ae:	ee f8 ff f4 	ld.w	r8,r7[-12]
800076b2:	71 28       	ld.w	r8,r8[0x48]
800076b4:	f0 c9 ff ff 	sub	r9,r8,-1
800076b8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800076bc:	f1 49 00 48 	st.w	r8[72],r9
			}

			xReturn = pdPASS;
800076c0:	30 18       	mov	r8,1
800076c2:	ef 48 ff f8 	st.w	r7[-8],r8
800076c6:	c0 48       	rjmp	800076ce <xQueueGenericSendFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
800076c8:	30 08       	mov	r8,0
800076ca:	ef 48 ff f8 	st.w	r7[-8],r8
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
800076ce:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800076d2:	10 9c       	mov	r12,r8
800076d4:	2f ad       	sub	sp,-24
800076d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800076da:	00 00       	add	r0,r0
800076dc:	80 00       	ld.sh	r0,r0[0x0]
800076de:	79 74       	ld.w	r4,r12[0x5c]
800076e0:	80 00       	ld.sh	r0,r0[0x0]
800076e2:	83 40       	st.w	r1[0x10],r0

800076e4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800076e4:	eb cd 40 80 	pushm	r7,lr
800076e8:	1a 97       	mov	r7,sp
800076ea:	20 8d       	sub	sp,32
800076ec:	ef 4c ff ec 	st.w	r7[-20],r12
800076f0:	ef 4b ff e8 	st.w	r7[-24],r11
800076f4:	ef 4a ff e4 	st.w	r7[-28],r10
800076f8:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
800076fc:	30 08       	mov	r8,0
800076fe:	ef 48 ff f8 	st.w	r7[-8],r8
80007702:	c0 28       	rjmp	80007706 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80007704:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80007706:	f0 1f 00 66 	mcall	8000789c <xQueueGenericReceive+0x1b8>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000770a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000770e:	70 e8       	ld.w	r8,r8[0x38]
80007710:	58 08       	cp.w	r8,0
80007712:	c4 c0       	breq	800077aa <xQueueGenericReceive+0xc6>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80007714:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007718:	70 38       	ld.w	r8,r8[0xc]
8000771a:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000771e:	ee fb ff e8 	ld.w	r11,r7[-24]
80007722:	ee fc ff ec 	ld.w	r12,r7[-20]
80007726:	f0 1f 00 5f 	mcall	800078a0 <xQueueGenericReceive+0x1bc>

				if( xJustPeeking == pdFALSE )
8000772a:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000772e:	58 08       	cp.w	r8,0
80007730:	c2 51       	brne	8000777a <xQueueGenericReceive+0x96>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80007732:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007736:	70 e8       	ld.w	r8,r8[0x38]
80007738:	f0 c9 00 01 	sub	r9,r8,1
8000773c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007740:	91 e9       	st.w	r8[0x38],r9

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007742:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007746:	70 08       	ld.w	r8,r8[0x0]
80007748:	58 08       	cp.w	r8,0
8000774a:	c0 81       	brne	8000775a <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
8000774c:	f0 1f 00 56 	mcall	800078a4 <xQueueGenericReceive+0x1c0>
80007750:	18 98       	mov	r8,r12
80007752:	10 99       	mov	r9,r8
80007754:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007758:	91 19       	st.w	r8[0x4],r9
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000775a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000775e:	70 48       	ld.w	r8,r8[0x10]
80007760:	58 08       	cp.w	r8,0
80007762:	c2 00       	breq	800077a2 <xQueueGenericReceive+0xbe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80007764:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007768:	2f 08       	sub	r8,-16
8000776a:	10 9c       	mov	r12,r8
8000776c:	f0 1f 00 4f 	mcall	800078a8 <xQueueGenericReceive+0x1c4>
80007770:	18 98       	mov	r8,r12
80007772:	58 18       	cp.w	r8,1
80007774:	c1 71       	brne	800077a2 <xQueueGenericReceive+0xbe>
						{
							portYIELD_WITHIN_API();
80007776:	d7 33       	scall
80007778:	c1 58       	rjmp	800077a2 <xQueueGenericReceive+0xbe>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000777a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000777e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007782:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007784:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007788:	70 98       	ld.w	r8,r8[0x24]
8000778a:	58 08       	cp.w	r8,0
8000778c:	c0 b0       	breq	800077a2 <xQueueGenericReceive+0xbe>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000778e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007792:	2d c8       	sub	r8,-36
80007794:	10 9c       	mov	r12,r8
80007796:	f0 1f 00 45 	mcall	800078a8 <xQueueGenericReceive+0x1c4>
8000779a:	18 98       	mov	r8,r12
8000779c:	58 08       	cp.w	r8,0
8000779e:	c0 20       	breq	800077a2 <xQueueGenericReceive+0xbe>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800077a0:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800077a2:	f0 1f 00 43 	mcall	800078ac <xQueueGenericReceive+0x1c8>
				return pdPASS;
800077a6:	30 18       	mov	r8,1
800077a8:	c7 58       	rjmp	80007892 <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800077aa:	ee f8 ff e4 	ld.w	r8,r7[-28]
800077ae:	58 08       	cp.w	r8,0
800077b0:	c0 51       	brne	800077ba <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800077b2:	f0 1f 00 3f 	mcall	800078ac <xQueueGenericReceive+0x1c8>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800077b6:	30 08       	mov	r8,0
800077b8:	c6 d8       	rjmp	80007892 <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
800077ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077be:	58 08       	cp.w	r8,0
800077c0:	c0 91       	brne	800077d2 <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800077c2:	ee c8 00 10 	sub	r8,r7,16
800077c6:	10 9c       	mov	r12,r8
800077c8:	f0 1f 00 3a 	mcall	800078b0 <xQueueGenericReceive+0x1cc>
					xEntryTimeSet = pdTRUE;
800077cc:	30 18       	mov	r8,1
800077ce:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
800077d2:	f0 1f 00 37 	mcall	800078ac <xQueueGenericReceive+0x1c8>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800077d6:	f0 1f 00 38 	mcall	800078b4 <xQueueGenericReceive+0x1d0>
		prvLockQueue( pxQueue );
800077da:	f0 1f 00 31 	mcall	8000789c <xQueueGenericReceive+0x1b8>
800077de:	ee f8 ff ec 	ld.w	r8,r7[-20]
800077e2:	71 18       	ld.w	r8,r8[0x44]
800077e4:	5b f8       	cp.w	r8,-1
800077e6:	c0 61       	brne	800077f2 <xQueueGenericReceive+0x10e>
800077e8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800077ec:	30 09       	mov	r9,0
800077ee:	f1 49 00 44 	st.w	r8[68],r9
800077f2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800077f6:	71 28       	ld.w	r8,r8[0x48]
800077f8:	5b f8       	cp.w	r8,-1
800077fa:	c0 61       	brne	80007806 <xQueueGenericReceive+0x122>
800077fc:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007800:	30 09       	mov	r9,0
80007802:	f1 49 00 48 	st.w	r8[72],r9
80007806:	f0 1f 00 2a 	mcall	800078ac <xQueueGenericReceive+0x1c8>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000780a:	ee c9 00 1c 	sub	r9,r7,28
8000780e:	ee c8 00 10 	sub	r8,r7,16
80007812:	12 9b       	mov	r11,r9
80007814:	10 9c       	mov	r12,r8
80007816:	f0 1f 00 29 	mcall	800078b8 <xQueueGenericReceive+0x1d4>
8000781a:	18 98       	mov	r8,r12
8000781c:	58 08       	cp.w	r8,0
8000781e:	c3 31       	brne	80007884 <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) )
80007820:	ee fc ff ec 	ld.w	r12,r7[-20]
80007824:	f0 1f 00 26 	mcall	800078bc <xQueueGenericReceive+0x1d8>
80007828:	18 98       	mov	r8,r12
8000782a:	58 08       	cp.w	r8,0
8000782c:	c2 50       	breq	80007876 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000782e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007832:	70 08       	ld.w	r8,r8[0x0]
80007834:	58 08       	cp.w	r8,0
80007836:	c0 b1       	brne	8000784c <xQueueGenericReceive+0x168>
					{
						portENTER_CRITICAL();
80007838:	f0 1f 00 19 	mcall	8000789c <xQueueGenericReceive+0x1b8>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000783c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007840:	70 18       	ld.w	r8,r8[0x4]
80007842:	10 9c       	mov	r12,r8
80007844:	f0 1f 00 1f 	mcall	800078c0 <xQueueGenericReceive+0x1dc>
						}
						portEXIT_CRITICAL();
80007848:	f0 1f 00 19 	mcall	800078ac <xQueueGenericReceive+0x1c8>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000784c:	ee f9 ff e4 	ld.w	r9,r7[-28]
80007850:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007854:	2d c8       	sub	r8,-36
80007856:	12 9b       	mov	r11,r9
80007858:	10 9c       	mov	r12,r8
8000785a:	f0 1f 00 1b 	mcall	800078c4 <xQueueGenericReceive+0x1e0>
				prvUnlockQueue( pxQueue );
8000785e:	ee fc ff ec 	ld.w	r12,r7[-20]
80007862:	f0 1f 00 1a 	mcall	800078c8 <xQueueGenericReceive+0x1e4>
				if( !xTaskResumeAll() )
80007866:	f0 1f 00 1a 	mcall	800078cc <xQueueGenericReceive+0x1e8>
8000786a:	18 98       	mov	r8,r12
8000786c:	58 08       	cp.w	r8,0
8000786e:	fe 91 ff 4b 	brne	80007704 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
80007872:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80007874:	c4 9b       	rjmp	80007706 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80007876:	ee fc ff ec 	ld.w	r12,r7[-20]
8000787a:	f0 1f 00 14 	mcall	800078c8 <xQueueGenericReceive+0x1e4>
				( void ) xTaskResumeAll();
8000787e:	f0 1f 00 14 	mcall	800078cc <xQueueGenericReceive+0x1e8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80007882:	c4 2b       	rjmp	80007706 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80007884:	ee fc ff ec 	ld.w	r12,r7[-20]
80007888:	f0 1f 00 10 	mcall	800078c8 <xQueueGenericReceive+0x1e4>
			( void ) xTaskResumeAll();
8000788c:	f0 1f 00 10 	mcall	800078cc <xQueueGenericReceive+0x1e8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
80007890:	30 08       	mov	r8,0
		}
	}
}
80007892:	10 9c       	mov	r12,r8
80007894:	2f 8d       	sub	sp,-32
80007896:	e3 cd 80 80 	ldm	sp++,r7,pc
8000789a:	00 00       	add	r0,r0
8000789c:	80 00       	ld.sh	r0,r0[0x0]
8000789e:	6f a4       	ld.w	r4,r7[0x68]
800078a0:	80 00       	ld.sh	r0,r0[0x0]
800078a2:	7a 78       	ld.w	r8,sp[0x1c]
800078a4:	80 00       	ld.sh	r0,r0[0x0]
800078a6:	88 50       	ld.sh	r0,r4[0xa]
800078a8:	80 00       	ld.sh	r0,r0[0x0]
800078aa:	83 40       	st.w	r1[0x10],r0
800078ac:	80 00       	ld.sh	r0,r0[0x0]
800078ae:	6f c0       	ld.w	r0,r7[0x70]
800078b0:	80 00       	ld.sh	r0,r0[0x0]
800078b2:	84 10       	ld.sh	r0,r2[0x2]
800078b4:	80 00       	ld.sh	r0,r0[0x0]
800078b6:	7f 3c       	ld.w	r12,pc[0x4c]
800078b8:	80 00       	ld.sh	r0,r0[0x0]
800078ba:	84 40       	ld.sh	r0,r2[0x8]
800078bc:	80 00       	ld.sh	r0,r0[0x0]
800078be:	7b b4       	ld.w	r4,sp[0x6c]
800078c0:	80 00       	ld.sh	r0,r0[0x0]
800078c2:	88 70       	ld.sh	r0,r4[0xe]
800078c4:	80 00       	ld.sh	r0,r0[0x0]
800078c6:	82 c0       	ld.uh	r0,r1[0x8]
800078c8:	80 00       	ld.sh	r0,r0[0x0]
800078ca:	7a e4       	ld.w	r4,sp[0x38]
800078cc:	80 00       	ld.sh	r0,r0[0x0]
800078ce:	7f 58       	ld.w	r8,pc[0x54]

800078d0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800078d0:	eb cd 40 80 	pushm	r7,lr
800078d4:	1a 97       	mov	r7,sp
800078d6:	20 5d       	sub	sp,20
800078d8:	ef 4c ff f4 	st.w	r7[-12],r12
800078dc:	ef 4b ff f0 	st.w	r7[-16],r11
800078e0:	ef 4a ff ec 	st.w	r7[-20],r10

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
800078e4:	30 08       	mov	r8,0
800078e6:	ef 48 ff fc 	st.w	r7[-4],r8
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800078ea:	ee f8 ff f4 	ld.w	r8,r7[-12]
800078ee:	70 e8       	ld.w	r8,r8[0x38]
800078f0:	58 08       	cp.w	r8,0
800078f2:	c3 40       	breq	8000795a <xQueueReceiveFromISR+0x8a>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800078f4:	ee fb ff f0 	ld.w	r11,r7[-16]
800078f8:	ee fc ff f4 	ld.w	r12,r7[-12]
800078fc:	f0 1f 00 1c 	mcall	8000796c <xQueueReceiveFromISR+0x9c>
			--( pxQueue->uxMessagesWaiting );
80007900:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007904:	70 e8       	ld.w	r8,r8[0x38]
80007906:	f0 c9 00 01 	sub	r9,r8,1
8000790a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000790e:	91 e9       	st.w	r8[0x38],r9

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80007910:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007914:	71 18       	ld.w	r8,r8[0x44]
80007916:	5b f8       	cp.w	r8,-1
80007918:	c1 41       	brne	80007940 <xQueueReceiveFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000791a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000791e:	70 48       	ld.w	r8,r8[0x10]
80007920:	58 08       	cp.w	r8,0
80007922:	c1 80       	breq	80007952 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007924:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007928:	2f 08       	sub	r8,-16
8000792a:	10 9c       	mov	r12,r8
8000792c:	f0 1f 00 11 	mcall	80007970 <xQueueReceiveFromISR+0xa0>
80007930:	18 98       	mov	r8,r12
80007932:	58 08       	cp.w	r8,0
80007934:	c0 f0       	breq	80007952 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80007936:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000793a:	30 19       	mov	r9,1
8000793c:	91 09       	st.w	r8[0x0],r9
8000793e:	c0 a8       	rjmp	80007952 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80007940:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007944:	71 18       	ld.w	r8,r8[0x44]
80007946:	f0 c9 ff ff 	sub	r9,r8,-1
8000794a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000794e:	f1 49 00 44 	st.w	r8[68],r9
			}

			xReturn = pdPASS;
80007952:	30 18       	mov	r8,1
80007954:	ef 48 ff f8 	st.w	r7[-8],r8
80007958:	c0 48       	rjmp	80007960 <xQueueReceiveFromISR+0x90>
		}
		else
		{
			xReturn = pdFAIL;
8000795a:	30 08       	mov	r8,0
8000795c:	ef 48 ff f8 	st.w	r7[-8],r8
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
80007960:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80007964:	10 9c       	mov	r12,r8
80007966:	2f bd       	sub	sp,-20
80007968:	e3 cd 80 80 	ldm	sp++,r7,pc
8000796c:	80 00       	ld.sh	r0,r0[0x0]
8000796e:	7a 78       	ld.w	r8,sp[0x1c]
80007970:	80 00       	ld.sh	r0,r0[0x0]
80007972:	83 40       	st.w	r1[0x10],r0

80007974 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80007974:	eb cd 40 80 	pushm	r7,lr
80007978:	1a 97       	mov	r7,sp
8000797a:	20 3d       	sub	sp,12
8000797c:	ef 4c ff fc 	st.w	r7[-4],r12
80007980:	ef 4b ff f8 	st.w	r7[-8],r11
80007984:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80007988:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000798c:	71 08       	ld.w	r8,r8[0x40]
8000798e:	58 08       	cp.w	r8,0
80007990:	c1 11       	brne	800079b2 <prvCopyDataToQueue+0x3e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80007992:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007996:	70 08       	ld.w	r8,r8[0x0]
80007998:	58 08       	cp.w	r8,0
8000799a:	c5 f1       	brne	80007a58 <prvCopyDataToQueue+0xe4>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000799c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079a0:	70 18       	ld.w	r8,r8[0x4]
800079a2:	10 9c       	mov	r12,r8
800079a4:	f0 1f 00 33 	mcall	80007a70 <prvCopyDataToQueue+0xfc>
				pxQueue->pxMutexHolder = NULL;
800079a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079ac:	30 09       	mov	r9,0
800079ae:	91 19       	st.w	r8[0x4],r9
800079b0:	c5 48       	rjmp	80007a58 <prvCopyDataToQueue+0xe4>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800079b2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800079b6:	58 08       	cp.w	r8,0
800079b8:	c2 61       	brne	80007a04 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800079ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079be:	71 09       	ld.w	r9,r8[0x40]
800079c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079c4:	70 28       	ld.w	r8,r8[0x8]
800079c6:	12 9a       	mov	r10,r9
800079c8:	ee fb ff f8 	ld.w	r11,r7[-8]
800079cc:	10 9c       	mov	r12,r8
800079ce:	f0 1f 00 2a 	mcall	80007a74 <prvCopyDataToQueue+0x100>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800079d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079d6:	70 29       	ld.w	r9,r8[0x8]
800079d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079dc:	71 08       	ld.w	r8,r8[0x40]
800079de:	10 09       	add	r9,r8
800079e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079e4:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800079e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079ea:	70 29       	ld.w	r9,r8[0x8]
800079ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079f0:	70 18       	ld.w	r8,r8[0x4]
800079f2:	10 39       	cp.w	r9,r8
800079f4:	c3 23       	brcs	80007a58 <prvCopyDataToQueue+0xe4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800079f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800079fa:	70 09       	ld.w	r9,r8[0x0]
800079fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a00:	91 29       	st.w	r8[0x8],r9
80007a02:	c2 b8       	rjmp	80007a58 <prvCopyDataToQueue+0xe4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80007a04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a08:	71 09       	ld.w	r9,r8[0x40]
80007a0a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a0e:	70 38       	ld.w	r8,r8[0xc]
80007a10:	12 9a       	mov	r10,r9
80007a12:	ee fb ff f8 	ld.w	r11,r7[-8]
80007a16:	10 9c       	mov	r12,r8
80007a18:	f0 1f 00 17 	mcall	80007a74 <prvCopyDataToQueue+0x100>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80007a1c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a20:	70 39       	ld.w	r9,r8[0xc]
80007a22:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a26:	71 08       	ld.w	r8,r8[0x40]
80007a28:	5c 38       	neg	r8
80007a2a:	10 09       	add	r9,r8
80007a2c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a30:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80007a32:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a36:	70 39       	ld.w	r9,r8[0xc]
80007a38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a3c:	70 08       	ld.w	r8,r8[0x0]
80007a3e:	10 39       	cp.w	r9,r8
80007a40:	c0 c2       	brcc	80007a58 <prvCopyDataToQueue+0xe4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80007a42:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a46:	70 19       	ld.w	r9,r8[0x4]
80007a48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a4c:	71 08       	ld.w	r8,r8[0x40]
80007a4e:	5c 38       	neg	r8
80007a50:	10 09       	add	r9,r8
80007a52:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a56:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80007a58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a5c:	70 e8       	ld.w	r8,r8[0x38]
80007a5e:	f0 c9 ff ff 	sub	r9,r8,-1
80007a62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a66:	91 e9       	st.w	r8[0x38],r9
}
80007a68:	2f dd       	sub	sp,-12
80007a6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80007a6e:	00 00       	add	r0,r0
80007a70:	80 00       	ld.sh	r0,r0[0x0]
80007a72:	89 44       	st.w	r4[0x10],r4
80007a74:	80 00       	ld.sh	r0,r0[0x0]
80007a76:	97 88       	st.w	r11[0x20],r8

80007a78 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80007a78:	eb cd 40 80 	pushm	r7,lr
80007a7c:	1a 97       	mov	r7,sp
80007a7e:	20 2d       	sub	sp,8
80007a80:	ef 4c ff fc 	st.w	r7[-4],r12
80007a84:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80007a88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a8c:	70 08       	ld.w	r8,r8[0x0]
80007a8e:	58 08       	cp.w	r8,0
80007a90:	c2 50       	breq	80007ada <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80007a92:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a96:	70 39       	ld.w	r9,r8[0xc]
80007a98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007a9c:	71 08       	ld.w	r8,r8[0x40]
80007a9e:	10 09       	add	r9,r8
80007aa0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007aa4:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80007aa6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007aaa:	70 39       	ld.w	r9,r8[0xc]
80007aac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007ab0:	70 18       	ld.w	r8,r8[0x4]
80007ab2:	10 39       	cp.w	r9,r8
80007ab4:	c0 73       	brcs	80007ac2 <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80007ab6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007aba:	70 09       	ld.w	r9,r8[0x0]
80007abc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007ac0:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80007ac2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007ac6:	71 09       	ld.w	r9,r8[0x40]
80007ac8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007acc:	70 38       	ld.w	r8,r8[0xc]
80007ace:	12 9a       	mov	r10,r9
80007ad0:	10 9b       	mov	r11,r8
80007ad2:	ee fc ff f8 	ld.w	r12,r7[-8]
80007ad6:	f0 1f 00 03 	mcall	80007ae0 <prvCopyDataFromQueue+0x68>
	}
}
80007ada:	2f ed       	sub	sp,-8
80007adc:	e3 cd 80 80 	ldm	sp++,r7,pc
80007ae0:	80 00       	ld.sh	r0,r0[0x0]
80007ae2:	97 88       	st.w	r11[0x20],r8

80007ae4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80007ae4:	eb cd 40 80 	pushm	r7,lr
80007ae8:	1a 97       	mov	r7,sp
80007aea:	20 1d       	sub	sp,4
80007aec:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80007af0:	f0 1f 00 2d 	mcall	80007ba4 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80007af4:	c1 a8       	rjmp	80007b28 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80007af6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007afa:	70 98       	ld.w	r8,r8[0x24]
80007afc:	58 08       	cp.w	r8,0
80007afe:	c1 c0       	breq	80007b36 <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80007b00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b04:	2d c8       	sub	r8,-36
80007b06:	10 9c       	mov	r12,r8
80007b08:	f0 1f 00 28 	mcall	80007ba8 <prvUnlockQueue+0xc4>
80007b0c:	18 98       	mov	r8,r12
80007b0e:	58 08       	cp.w	r8,0
80007b10:	c0 30       	breq	80007b16 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80007b12:	f0 1f 00 27 	mcall	80007bac <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
80007b16:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b1a:	71 28       	ld.w	r8,r8[0x48]
80007b1c:	f0 c9 00 01 	sub	r9,r8,1
80007b20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b24:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80007b28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b2c:	71 28       	ld.w	r8,r8[0x48]
80007b2e:	58 08       	cp.w	r8,0
80007b30:	fe 99 ff e3 	brgt	80007af6 <prvUnlockQueue+0x12>
80007b34:	c0 28       	rjmp	80007b38 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
80007b36:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80007b38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b3c:	3f f9       	mov	r9,-1
80007b3e:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
80007b42:	f0 1f 00 1c 	mcall	80007bb0 <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80007b46:	f0 1f 00 18 	mcall	80007ba4 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80007b4a:	c1 a8       	rjmp	80007b7e <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80007b4c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b50:	70 48       	ld.w	r8,r8[0x10]
80007b52:	58 08       	cp.w	r8,0
80007b54:	c1 c0       	breq	80007b8c <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80007b56:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b5a:	2f 08       	sub	r8,-16
80007b5c:	10 9c       	mov	r12,r8
80007b5e:	f0 1f 00 13 	mcall	80007ba8 <prvUnlockQueue+0xc4>
80007b62:	18 98       	mov	r8,r12
80007b64:	58 08       	cp.w	r8,0
80007b66:	c0 30       	breq	80007b6c <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
80007b68:	f0 1f 00 11 	mcall	80007bac <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
80007b6c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b70:	71 18       	ld.w	r8,r8[0x44]
80007b72:	f0 c9 00 01 	sub	r9,r8,1
80007b76:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b7a:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80007b7e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b82:	71 18       	ld.w	r8,r8[0x44]
80007b84:	58 08       	cp.w	r8,0
80007b86:	fe 99 ff e3 	brgt	80007b4c <prvUnlockQueue+0x68>
80007b8a:	c0 28       	rjmp	80007b8e <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
80007b8c:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80007b8e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007b92:	3f f9       	mov	r9,-1
80007b94:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80007b98:	f0 1f 00 06 	mcall	80007bb0 <prvUnlockQueue+0xcc>
}
80007b9c:	2f fd       	sub	sp,-4
80007b9e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007ba2:	00 00       	add	r0,r0
80007ba4:	80 00       	ld.sh	r0,r0[0x0]
80007ba6:	6f a4       	ld.w	r4,r7[0x68]
80007ba8:	80 00       	ld.sh	r0,r0[0x0]
80007baa:	83 40       	st.w	r1[0x10],r0
80007bac:	80 00       	ld.sh	r0,r0[0x0]
80007bae:	84 f8       	ld.uh	r8,r2[0xe]
80007bb0:	80 00       	ld.sh	r0,r0[0x0]
80007bb2:	6f c0       	ld.w	r0,r7[0x70]

80007bb4 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80007bb4:	eb cd 40 80 	pushm	r7,lr
80007bb8:	1a 97       	mov	r7,sp
80007bba:	20 2d       	sub	sp,8
80007bbc:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80007bc0:	f0 1f 00 09 	mcall	80007be4 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80007bc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007bc8:	70 e8       	ld.w	r8,r8[0x38]
80007bca:	58 08       	cp.w	r8,0
80007bcc:	5f 08       	sreq	r8
80007bce:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80007bd2:	f0 1f 00 06 	mcall	80007be8 <prvIsQueueEmpty+0x34>

	return xReturn;
80007bd6:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80007bda:	10 9c       	mov	r12,r8
80007bdc:	2f ed       	sub	sp,-8
80007bde:	e3 cd 80 80 	ldm	sp++,r7,pc
80007be2:	00 00       	add	r0,r0
80007be4:	80 00       	ld.sh	r0,r0[0x0]
80007be6:	6f a4       	ld.w	r4,r7[0x68]
80007be8:	80 00       	ld.sh	r0,r0[0x0]
80007bea:	6f c0       	ld.w	r0,r7[0x70]

80007bec <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80007bec:	eb cd 40 80 	pushm	r7,lr
80007bf0:	1a 97       	mov	r7,sp
80007bf2:	20 2d       	sub	sp,8
80007bf4:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80007bf8:	f0 1f 00 0a 	mcall	80007c20 <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80007bfc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c00:	70 e9       	ld.w	r9,r8[0x38]
80007c02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c06:	70 f8       	ld.w	r8,r8[0x3c]
80007c08:	10 39       	cp.w	r9,r8
80007c0a:	5f 08       	sreq	r8
80007c0c:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
80007c10:	f0 1f 00 05 	mcall	80007c24 <prvIsQueueFull+0x38>

	return xReturn;
80007c14:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80007c18:	10 9c       	mov	r12,r8
80007c1a:	2f ed       	sub	sp,-8
80007c1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007c20:	80 00       	ld.sh	r0,r0[0x0]
80007c22:	6f a4       	ld.w	r4,r7[0x68]
80007c24:	80 00       	ld.sh	r0,r0[0x0]
80007c26:	6f c0       	ld.w	r0,r7[0x70]
80007c28:	49 44       	lddpc	r4,80007c78 <xTaskGenericCreate+0x48>
80007c2a:	4c 45       	lddpc	r5,80007d38 <xTaskGenericCreate+0x108>
80007c2c:	00 00       	add	r0,r0
	...

80007c30 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80007c30:	eb cd 40 c0 	pushm	r6-r7,lr
80007c34:	1a 97       	mov	r7,sp
80007c36:	20 8d       	sub	sp,32
80007c38:	ee c6 ff f4 	sub	r6,r7,-12
80007c3c:	ef 4c ff f0 	st.w	r7[-16],r12
80007c40:	ef 4b ff ec 	st.w	r7[-20],r11
80007c44:	ef 49 ff e4 	st.w	r7[-28],r9
80007c48:	ef 48 ff e0 	st.w	r7[-32],r8
80007c4c:	14 98       	mov	r8,r10
80007c4e:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
80007c52:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80007c56:	6c 1b       	ld.w	r11,r6[0x4]
80007c58:	10 9c       	mov	r12,r8
80007c5a:	f0 1f 00 5a 	mcall	80007dc0 <xTaskGenericCreate+0x190>
80007c5e:	18 98       	mov	r8,r12
80007c60:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
80007c64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c68:	58 08       	cp.w	r8,0
80007c6a:	e0 80 00 92 	breq	80007d8e <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
80007c6e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c72:	70 c9       	ld.w	r9,r8[0x30]
80007c74:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80007c78:	20 18       	sub	r8,1
80007c7a:	a3 68       	lsl	r8,0x2
80007c7c:	f2 08 00 08 	add	r8,r9,r8
80007c80:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80007c84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007c88:	e0 18 ff fc 	andl	r8,0xfffc
80007c8c:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
80007c90:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80007c94:	6c 29       	ld.w	r9,r6[0x8]
80007c96:	ee fa ff e0 	ld.w	r10,r7[-32]
80007c9a:	ee fb ff ec 	ld.w	r11,r7[-20]
80007c9e:	ee fc ff f8 	ld.w	r12,r7[-8]
80007ca2:	f0 1f 00 49 	mcall	80007dc4 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80007ca6:	ee fa ff e4 	ld.w	r10,r7[-28]
80007caa:	ee fb ff f0 	ld.w	r11,r7[-16]
80007cae:	ee fc ff fc 	ld.w	r12,r7[-4]
80007cb2:	f0 1f 00 46 	mcall	80007dc8 <xTaskGenericCreate+0x198>
80007cb6:	18 98       	mov	r8,r12
80007cb8:	10 99       	mov	r9,r8
80007cba:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007cbe:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
80007cc0:	6c 08       	ld.w	r8,r6[0x0]
80007cc2:	58 08       	cp.w	r8,0
80007cc4:	c0 50       	breq	80007cce <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80007cc6:	6c 08       	ld.w	r8,r6[0x0]
80007cc8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007ccc:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80007cce:	f0 1f 00 40 	mcall	80007dcc <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80007cd2:	4c 08       	lddpc	r8,80007dd0 <xTaskGenericCreate+0x1a0>
80007cd4:	70 08       	ld.w	r8,r8[0x0]
80007cd6:	f0 c9 ff ff 	sub	r9,r8,-1
80007cda:	4b e8       	lddpc	r8,80007dd0 <xTaskGenericCreate+0x1a0>
80007cdc:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80007cde:	4b e8       	lddpc	r8,80007dd4 <xTaskGenericCreate+0x1a4>
80007ce0:	70 08       	ld.w	r8,r8[0x0]
80007ce2:	58 08       	cp.w	r8,0
80007ce4:	c0 c1       	brne	80007cfc <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80007ce6:	4b c8       	lddpc	r8,80007dd4 <xTaskGenericCreate+0x1a4>
80007ce8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007cec:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80007cee:	4b 98       	lddpc	r8,80007dd0 <xTaskGenericCreate+0x1a0>
80007cf0:	70 08       	ld.w	r8,r8[0x0]
80007cf2:	58 18       	cp.w	r8,1
80007cf4:	c1 41       	brne	80007d1c <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80007cf6:	f0 1f 00 39 	mcall	80007dd8 <xTaskGenericCreate+0x1a8>
80007cfa:	c1 18       	rjmp	80007d1c <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80007cfc:	4b 88       	lddpc	r8,80007ddc <xTaskGenericCreate+0x1ac>
80007cfe:	70 08       	ld.w	r8,r8[0x0]
80007d00:	58 08       	cp.w	r8,0
80007d02:	c0 d1       	brne	80007d1c <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80007d04:	4b 48       	lddpc	r8,80007dd4 <xTaskGenericCreate+0x1a4>
80007d06:	70 08       	ld.w	r8,r8[0x0]
80007d08:	70 b9       	ld.w	r9,r8[0x2c]
80007d0a:	ee f8 ff e0 	ld.w	r8,r7[-32]
80007d0e:	10 39       	cp.w	r9,r8
80007d10:	e0 8b 00 06 	brhi	80007d1c <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80007d14:	4b 08       	lddpc	r8,80007dd4 <xTaskGenericCreate+0x1a4>
80007d16:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007d1a:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80007d1c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d20:	70 b9       	ld.w	r9,r8[0x2c]
80007d22:	4b 08       	lddpc	r8,80007de0 <xTaskGenericCreate+0x1b0>
80007d24:	70 08       	ld.w	r8,r8[0x0]
80007d26:	10 39       	cp.w	r9,r8
80007d28:	e0 88 00 07 	brls	80007d36 <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80007d2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d30:	70 b9       	ld.w	r9,r8[0x2c]
80007d32:	4a c8       	lddpc	r8,80007de0 <xTaskGenericCreate+0x1b0>
80007d34:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80007d36:	4a c8       	lddpc	r8,80007de4 <xTaskGenericCreate+0x1b4>
80007d38:	70 08       	ld.w	r8,r8[0x0]
80007d3a:	f0 c9 ff ff 	sub	r9,r8,-1
80007d3e:	4a a8       	lddpc	r8,80007de4 <xTaskGenericCreate+0x1b4>
80007d40:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80007d42:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d46:	70 b9       	ld.w	r9,r8[0x2c]
80007d48:	4a 88       	lddpc	r8,80007de8 <xTaskGenericCreate+0x1b8>
80007d4a:	70 08       	ld.w	r8,r8[0x0]
80007d4c:	10 39       	cp.w	r9,r8
80007d4e:	e0 88 00 07 	brls	80007d5c <xTaskGenericCreate+0x12c>
80007d52:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d56:	70 b9       	ld.w	r9,r8[0x2c]
80007d58:	4a 48       	lddpc	r8,80007de8 <xTaskGenericCreate+0x1b8>
80007d5a:	91 09       	st.w	r8[0x0],r9
80007d5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d60:	f0 ca ff fc 	sub	r10,r8,-4
80007d64:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d68:	70 b9       	ld.w	r9,r8[0x2c]
80007d6a:	12 98       	mov	r8,r9
80007d6c:	a3 68       	lsl	r8,0x2
80007d6e:	12 08       	add	r8,r9
80007d70:	a3 68       	lsl	r8,0x2
80007d72:	10 99       	mov	r9,r8
80007d74:	49 e8       	lddpc	r8,80007dec <xTaskGenericCreate+0x1bc>
80007d76:	f2 08 00 08 	add	r8,r9,r8
80007d7a:	14 9b       	mov	r11,r10
80007d7c:	10 9c       	mov	r12,r8
80007d7e:	f0 1f 00 1d 	mcall	80007df0 <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
80007d82:	30 18       	mov	r8,1
80007d84:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80007d88:	f0 1f 00 1b 	mcall	80007df4 <xTaskGenericCreate+0x1c4>
80007d8c:	c0 48       	rjmp	80007d94 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80007d8e:	3f f8       	mov	r8,-1
80007d90:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80007d94:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007d98:	58 18       	cp.w	r8,1
80007d9a:	c0 d1       	brne	80007db4 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80007d9c:	49 08       	lddpc	r8,80007ddc <xTaskGenericCreate+0x1ac>
80007d9e:	70 08       	ld.w	r8,r8[0x0]
80007da0:	58 08       	cp.w	r8,0
80007da2:	c0 90       	breq	80007db4 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007da4:	48 c8       	lddpc	r8,80007dd4 <xTaskGenericCreate+0x1a4>
80007da6:	70 08       	ld.w	r8,r8[0x0]
80007da8:	70 b9       	ld.w	r9,r8[0x2c]
80007daa:	ee f8 ff e0 	ld.w	r8,r7[-32]
80007dae:	10 39       	cp.w	r9,r8
80007db0:	c0 22       	brcc	80007db4 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
80007db2:	d7 33       	scall
			}
		}
	}

	return xReturn;
80007db4:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80007db8:	10 9c       	mov	r12,r8
80007dba:	2f 8d       	sub	sp,-32
80007dbc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007dc0:	80 00       	ld.sh	r0,r0[0x0]
80007dc2:	87 90       	st.w	r3[0x24],r0
80007dc4:	80 00       	ld.sh	r0,r0[0x0]
80007dc6:	85 3c       	st.w	r2[0xc],r12
80007dc8:	80 00       	ld.sh	r0,r0[0x0]
80007dca:	6f ec       	ld.w	r12,r7[0x78]
80007dcc:	80 00       	ld.sh	r0,r0[0x0]
80007dce:	6f a4       	ld.w	r4,r7[0x68]
80007dd0:	00 00       	add	r0,r0
80007dd2:	0d 10       	ld.sh	r0,r6++
80007dd4:	00 00       	add	r0,r0
80007dd6:	0b fc       	ld.ub	r12,r5[0x7]
80007dd8:	80 00       	ld.sh	r0,r0[0x0]
80007dda:	85 e4       	st.w	r2[0x38],r4
80007ddc:	00 00       	add	r0,r0
80007dde:	0d 20       	ld.uh	r0,r6++
80007de0:	00 00       	add	r0,r0
80007de2:	0d 18       	ld.sh	r8,r6++
80007de4:	00 00       	add	r0,r0
80007de6:	0d 34       	ld.ub	r4,r6++
80007de8:	00 00       	add	r0,r0
80007dea:	0d 1c       	ld.sh	r12,r6++
80007dec:	00 00       	add	r0,r0
80007dee:	0c 00       	add	r0,r6
80007df0:	80 00       	ld.sh	r0,r0[0x0]
80007df2:	6c d2       	ld.w	r2,r6[0x34]
80007df4:	80 00       	ld.sh	r0,r0[0x0]
80007df6:	6f c0       	ld.w	r0,r7[0x70]

80007df8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80007df8:	eb cd 40 80 	pushm	r7,lr
80007dfc:	1a 97       	mov	r7,sp
80007dfe:	20 5d       	sub	sp,20
80007e00:	ef 4c ff f0 	st.w	r7[-16],r12
80007e04:	ef 4b ff ec 	st.w	r7[-20],r11
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
80007e08:	30 08       	mov	r8,0
80007e0a:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80007e0e:	f0 1f 00 2d 	mcall	80007ec0 <vTaskDelayUntil+0xc8>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80007e12:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007e16:	70 09       	ld.w	r9,r8[0x0]
80007e18:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007e1c:	f2 08 00 08 	add	r8,r9,r8
80007e20:	ef 48 ff f4 	st.w	r7[-12],r8

			if( xTickCount < *pxPreviousWakeTime )
80007e24:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007e28:	70 09       	ld.w	r9,r8[0x0]
80007e2a:	4a 78       	lddpc	r8,80007ec4 <vTaskDelayUntil+0xcc>
80007e2c:	70 08       	ld.w	r8,r8[0x0]
80007e2e:	10 39       	cp.w	r9,r8
80007e30:	e0 88 00 15 	brls	80007e5a <vTaskDelayUntil+0x62>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80007e34:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007e38:	70 09       	ld.w	r9,r8[0x0]
80007e3a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007e3e:	10 39       	cp.w	r9,r8
80007e40:	e0 88 00 1f 	brls	80007e7e <vTaskDelayUntil+0x86>
80007e44:	4a 08       	lddpc	r8,80007ec4 <vTaskDelayUntil+0xcc>
80007e46:	70 08       	ld.w	r8,r8[0x0]
80007e48:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007e4c:	10 39       	cp.w	r9,r8
80007e4e:	e0 88 00 18 	brls	80007e7e <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
80007e52:	30 18       	mov	r8,1
80007e54:	ef 48 ff fc 	st.w	r7[-4],r8
80007e58:	c1 38       	rjmp	80007e7e <vTaskDelayUntil+0x86>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80007e5a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007e5e:	70 09       	ld.w	r9,r8[0x0]
80007e60:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007e64:	10 39       	cp.w	r9,r8
80007e66:	e0 8b 00 09 	brhi	80007e78 <vTaskDelayUntil+0x80>
80007e6a:	49 78       	lddpc	r8,80007ec4 <vTaskDelayUntil+0xcc>
80007e6c:	70 08       	ld.w	r8,r8[0x0]
80007e6e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007e72:	10 39       	cp.w	r9,r8
80007e74:	e0 88 00 05 	brls	80007e7e <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
80007e78:	30 18       	mov	r8,1
80007e7a:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80007e7e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007e82:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007e86:	91 09       	st.w	r8[0x0],r9

			if( xShouldDelay != pdFALSE )
80007e88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e8c:	58 08       	cp.w	r8,0
80007e8e:	c0 b0       	breq	80007ea4 <vTaskDelayUntil+0xac>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80007e90:	48 e8       	lddpc	r8,80007ec8 <vTaskDelayUntil+0xd0>
80007e92:	70 08       	ld.w	r8,r8[0x0]
80007e94:	2f c8       	sub	r8,-4
80007e96:	10 9c       	mov	r12,r8
80007e98:	f0 1f 00 0d 	mcall	80007ecc <vTaskDelayUntil+0xd4>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80007e9c:	ee fc ff f4 	ld.w	r12,r7[-12]
80007ea0:	f0 1f 00 0c 	mcall	80007ed0 <vTaskDelayUntil+0xd8>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80007ea4:	f0 1f 00 0c 	mcall	80007ed4 <vTaskDelayUntil+0xdc>
80007ea8:	18 98       	mov	r8,r12
80007eaa:	ef 48 ff f8 	st.w	r7[-8],r8

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80007eae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007eb2:	58 08       	cp.w	r8,0
80007eb4:	c0 21       	brne	80007eb8 <vTaskDelayUntil+0xc0>
		{
			portYIELD_WITHIN_API();
80007eb6:	d7 33       	scall
		}
	}
80007eb8:	2f bd       	sub	sp,-20
80007eba:	e3 cd 80 80 	ldm	sp++,r7,pc
80007ebe:	00 00       	add	r0,r0
80007ec0:	80 00       	ld.sh	r0,r0[0x0]
80007ec2:	7f 3c       	ld.w	r12,pc[0x4c]
80007ec4:	00 00       	add	r0,r0
80007ec6:	0d 14       	ld.sh	r4,r6++
80007ec8:	00 00       	add	r0,r0
80007eca:	0b fc       	ld.ub	r12,r5[0x7]
80007ecc:	80 00       	ld.sh	r0,r0[0x0]
80007ece:	6d e6       	ld.w	r6,r6[0x78]
80007ed0:	80 00       	ld.sh	r0,r0[0x0]
80007ed2:	87 10       	st.w	r3[0x4],r0
80007ed4:	80 00       	ld.sh	r0,r0[0x0]
80007ed6:	7f 58       	ld.w	r8,pc[0x54]

80007ed8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80007ed8:	eb cd 40 80 	pushm	r7,lr
80007edc:	1a 97       	mov	r7,sp
80007ede:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80007ee0:	49 1b       	lddpc	r11,80007f24 <vTaskStartScheduler+0x4c>
80007ee2:	30 08       	mov	r8,0
80007ee4:	1a d8       	st.w	--sp,r8
80007ee6:	30 08       	mov	r8,0
80007ee8:	1a d8       	st.w	--sp,r8
80007eea:	30 08       	mov	r8,0
80007eec:	1a d8       	st.w	--sp,r8
80007eee:	30 08       	mov	r8,0
80007ef0:	30 09       	mov	r9,0
80007ef2:	e0 6a 01 00 	mov	r10,256
80007ef6:	48 dc       	lddpc	r12,80007f28 <vTaskStartScheduler+0x50>
80007ef8:	f0 1f 00 0d 	mcall	80007f2c <vTaskStartScheduler+0x54>
80007efc:	2f dd       	sub	sp,-12
80007efe:	18 98       	mov	r8,r12
80007f00:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80007f04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007f08:	58 18       	cp.w	r8,1
80007f0a:	c0 a1       	brne	80007f1e <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80007f0c:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80007f0e:	48 98       	lddpc	r8,80007f30 <vTaskStartScheduler+0x58>
80007f10:	30 19       	mov	r9,1
80007f12:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80007f14:	48 88       	lddpc	r8,80007f34 <vTaskStartScheduler+0x5c>
80007f16:	30 09       	mov	r9,0
80007f18:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80007f1a:	f0 1f 00 08 	mcall	80007f38 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
80007f1e:	2f fd       	sub	sp,-4
80007f20:	e3 cd 80 80 	ldm	sp++,r7,pc
80007f24:	80 00       	ld.sh	r0,r0[0x0]
80007f26:	7c 28       	ld.w	r8,lr[0x8]
80007f28:	80 00       	ld.sh	r0,r0[0x0]
80007f2a:	85 0c       	st.w	r2[0x0],r12
80007f2c:	80 00       	ld.sh	r0,r0[0x0]
80007f2e:	7c 30       	ld.w	r0,lr[0xc]
80007f30:	00 00       	add	r0,r0
80007f32:	0d 20       	ld.uh	r0,r6++
80007f34:	00 00       	add	r0,r0
80007f36:	0d 14       	ld.sh	r4,r6++
80007f38:	80 00       	ld.sh	r0,r0[0x0]
80007f3a:	71 94       	ld.w	r4,r8[0x64]

80007f3c <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80007f3c:	eb cd 40 80 	pushm	r7,lr
80007f40:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80007f42:	48 58       	lddpc	r8,80007f54 <vTaskSuspendAll+0x18>
80007f44:	70 08       	ld.w	r8,r8[0x0]
80007f46:	f0 c9 ff ff 	sub	r9,r8,-1
80007f4a:	48 38       	lddpc	r8,80007f54 <vTaskSuspendAll+0x18>
80007f4c:	91 09       	st.w	r8[0x0],r9
}
80007f4e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007f52:	00 00       	add	r0,r0
80007f54:	00 00       	add	r0,r0
80007f56:	0d 24       	ld.uh	r4,r6++

80007f58 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80007f58:	eb cd 40 c0 	pushm	r6-r7,lr
80007f5c:	1a 97       	mov	r7,sp
80007f5e:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
80007f60:	30 08       	mov	r8,0
80007f62:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80007f66:	f0 1f 00 3a 	mcall	8000804c <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
80007f6a:	4b a8       	lddpc	r8,80008050 <xTaskResumeAll+0xf8>
80007f6c:	70 08       	ld.w	r8,r8[0x0]
80007f6e:	f0 c9 00 01 	sub	r9,r8,1
80007f72:	4b 88       	lddpc	r8,80008050 <xTaskResumeAll+0xf8>
80007f74:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80007f76:	4b 78       	lddpc	r8,80008050 <xTaskResumeAll+0xf8>
80007f78:	70 08       	ld.w	r8,r8[0x0]
80007f7a:	58 08       	cp.w	r8,0
80007f7c:	c5 f1       	brne	8000803a <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80007f7e:	4b 68       	lddpc	r8,80008054 <xTaskResumeAll+0xfc>
80007f80:	70 08       	ld.w	r8,r8[0x0]
80007f82:	58 08       	cp.w	r8,0
80007f84:	c5 b0       	breq	8000803a <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80007f86:	30 08       	mov	r8,0
80007f88:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80007f8c:	c3 08       	rjmp	80007fec <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80007f8e:	4b 38       	lddpc	r8,80008058 <xTaskResumeAll+0x100>
80007f90:	70 38       	ld.w	r8,r8[0xc]
80007f92:	70 38       	ld.w	r8,r8[0xc]
80007f94:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80007f96:	ec c8 ff e8 	sub	r8,r6,-24
80007f9a:	10 9c       	mov	r12,r8
80007f9c:	f0 1f 00 30 	mcall	8000805c <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
80007fa0:	ec c8 ff fc 	sub	r8,r6,-4
80007fa4:	10 9c       	mov	r12,r8
80007fa6:	f0 1f 00 2e 	mcall	8000805c <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80007faa:	6c b9       	ld.w	r9,r6[0x2c]
80007fac:	4a d8       	lddpc	r8,80008060 <xTaskResumeAll+0x108>
80007fae:	70 08       	ld.w	r8,r8[0x0]
80007fb0:	10 39       	cp.w	r9,r8
80007fb2:	e0 88 00 05 	brls	80007fbc <xTaskResumeAll+0x64>
80007fb6:	6c b9       	ld.w	r9,r6[0x2c]
80007fb8:	4a a8       	lddpc	r8,80008060 <xTaskResumeAll+0x108>
80007fba:	91 09       	st.w	r8[0x0],r9
80007fbc:	ec ca ff fc 	sub	r10,r6,-4
80007fc0:	6c b9       	ld.w	r9,r6[0x2c]
80007fc2:	12 98       	mov	r8,r9
80007fc4:	a3 68       	lsl	r8,0x2
80007fc6:	12 08       	add	r8,r9
80007fc8:	a3 68       	lsl	r8,0x2
80007fca:	10 99       	mov	r9,r8
80007fcc:	4a 68       	lddpc	r8,80008064 <xTaskResumeAll+0x10c>
80007fce:	f2 08 00 08 	add	r8,r9,r8
80007fd2:	14 9b       	mov	r11,r10
80007fd4:	10 9c       	mov	r12,r8
80007fd6:	f0 1f 00 25 	mcall	80008068 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80007fda:	6c b9       	ld.w	r9,r6[0x2c]
80007fdc:	4a 48       	lddpc	r8,8000806c <xTaskResumeAll+0x114>
80007fde:	70 08       	ld.w	r8,r8[0x0]
80007fe0:	70 b8       	ld.w	r8,r8[0x2c]
80007fe2:	10 39       	cp.w	r9,r8
80007fe4:	c0 43       	brcs	80007fec <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80007fe6:	30 18       	mov	r8,1
80007fe8:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80007fec:	49 b8       	lddpc	r8,80008058 <xTaskResumeAll+0x100>
80007fee:	70 08       	ld.w	r8,r8[0x0]
80007ff0:	58 08       	cp.w	r8,0
80007ff2:	cc e1       	brne	80007f8e <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007ff4:	49 f8       	lddpc	r8,80008070 <xTaskResumeAll+0x118>
80007ff6:	70 08       	ld.w	r8,r8[0x0]
80007ff8:	58 08       	cp.w	r8,0
80007ffa:	c1 10       	breq	8000801c <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80007ffc:	c0 98       	rjmp	8000800e <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
80007ffe:	f0 1f 00 1e 	mcall	80008074 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
80008002:	49 c8       	lddpc	r8,80008070 <xTaskResumeAll+0x118>
80008004:	70 08       	ld.w	r8,r8[0x0]
80008006:	f0 c9 00 01 	sub	r9,r8,1
8000800a:	49 a8       	lddpc	r8,80008070 <xTaskResumeAll+0x118>
8000800c:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000800e:	49 98       	lddpc	r8,80008070 <xTaskResumeAll+0x118>
80008010:	70 08       	ld.w	r8,r8[0x0]
80008012:	58 08       	cp.w	r8,0
80008014:	cf 51       	brne	80007ffe <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80008016:	30 18       	mov	r8,1
80008018:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000801c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008020:	58 18       	cp.w	r8,1
80008022:	c0 50       	breq	8000802c <xTaskResumeAll+0xd4>
80008024:	49 58       	lddpc	r8,80008078 <xTaskResumeAll+0x120>
80008026:	70 08       	ld.w	r8,r8[0x0]
80008028:	58 18       	cp.w	r8,1
8000802a:	c0 81       	brne	8000803a <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
8000802c:	30 18       	mov	r8,1
8000802e:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
80008032:	49 28       	lddpc	r8,80008078 <xTaskResumeAll+0x120>
80008034:	30 09       	mov	r9,0
80008036:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80008038:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
8000803a:	f0 1f 00 11 	mcall	8000807c <xTaskResumeAll+0x124>

	return xAlreadyYielded;
8000803e:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80008042:	10 9c       	mov	r12,r8
80008044:	2f ed       	sub	sp,-8
80008046:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000804a:	00 00       	add	r0,r0
8000804c:	80 00       	ld.sh	r0,r0[0x0]
8000804e:	6f a4       	ld.w	r4,r7[0x68]
80008050:	00 00       	add	r0,r0
80008052:	0d 24       	ld.uh	r4,r6++
80008054:	00 00       	add	r0,r0
80008056:	0d 10       	ld.sh	r0,r6++
80008058:	00 00       	add	r0,r0
8000805a:	0c d0       	st.w	--r6,r0
8000805c:	80 00       	ld.sh	r0,r0[0x0]
8000805e:	6d e6       	ld.w	r6,r6[0x78]
80008060:	00 00       	add	r0,r0
80008062:	0d 1c       	ld.sh	r12,r6++
80008064:	00 00       	add	r0,r0
80008066:	0c 00       	add	r0,r6
80008068:	80 00       	ld.sh	r0,r0[0x0]
8000806a:	6c d2       	ld.w	r2,r6[0x34]
8000806c:	00 00       	add	r0,r0
8000806e:	0b fc       	ld.ub	r12,r5[0x7]
80008070:	00 00       	add	r0,r0
80008072:	0d 28       	ld.uh	r8,r6++
80008074:	80 00       	ld.sh	r0,r0[0x0]
80008076:	80 b0       	ld.uh	r0,r0[0x6]
80008078:	00 00       	add	r0,r0
8000807a:	0d 2c       	ld.uh	r12,r6++
8000807c:	80 00       	ld.sh	r0,r0[0x0]
8000807e:	6f c0       	ld.w	r0,r7[0x70]

80008080 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80008080:	eb cd 40 80 	pushm	r7,lr
80008084:	1a 97       	mov	r7,sp
80008086:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80008088:	f0 1f 00 07 	mcall	800080a4 <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
8000808c:	48 78       	lddpc	r8,800080a8 <xTaskGetTickCount+0x28>
8000808e:	70 08       	ld.w	r8,r8[0x0]
80008090:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80008094:	f0 1f 00 06 	mcall	800080ac <xTaskGetTickCount+0x2c>

	return xTicks;
80008098:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000809c:	10 9c       	mov	r12,r8
8000809e:	2f fd       	sub	sp,-4
800080a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800080a4:	80 00       	ld.sh	r0,r0[0x0]
800080a6:	6f a4       	ld.w	r4,r7[0x68]
800080a8:	00 00       	add	r0,r0
800080aa:	0d 14       	ld.sh	r4,r6++
800080ac:	80 00       	ld.sh	r0,r0[0x0]
800080ae:	6f c0       	ld.w	r0,r7[0x70]

800080b0 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800080b0:	eb cd 40 80 	pushm	r7,lr
800080b4:	1a 97       	mov	r7,sp
800080b6:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800080b8:	4c b8       	lddpc	r8,800081e4 <vTaskIncrementTick+0x134>
800080ba:	70 08       	ld.w	r8,r8[0x0]
800080bc:	58 08       	cp.w	r8,0
800080be:	e0 81 00 89 	brne	800081d0 <vTaskIncrementTick+0x120>
	{
		++xTickCount;
800080c2:	4c a8       	lddpc	r8,800081e8 <vTaskIncrementTick+0x138>
800080c4:	70 08       	ld.w	r8,r8[0x0]
800080c6:	f0 c9 ff ff 	sub	r9,r8,-1
800080ca:	4c 88       	lddpc	r8,800081e8 <vTaskIncrementTick+0x138>
800080cc:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800080ce:	4c 78       	lddpc	r8,800081e8 <vTaskIncrementTick+0x138>
800080d0:	70 08       	ld.w	r8,r8[0x0]
800080d2:	58 08       	cp.w	r8,0
800080d4:	c2 71       	brne	80008122 <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800080d6:	4c 68       	lddpc	r8,800081ec <vTaskIncrementTick+0x13c>
800080d8:	70 08       	ld.w	r8,r8[0x0]
800080da:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800080de:	4c 58       	lddpc	r8,800081f0 <vTaskIncrementTick+0x140>
800080e0:	70 09       	ld.w	r9,r8[0x0]
800080e2:	4c 38       	lddpc	r8,800081ec <vTaskIncrementTick+0x13c>
800080e4:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
800080e6:	4c 38       	lddpc	r8,800081f0 <vTaskIncrementTick+0x140>
800080e8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800080ec:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
800080ee:	4c 28       	lddpc	r8,800081f4 <vTaskIncrementTick+0x144>
800080f0:	70 08       	ld.w	r8,r8[0x0]
800080f2:	f0 c9 ff ff 	sub	r9,r8,-1
800080f6:	4c 08       	lddpc	r8,800081f4 <vTaskIncrementTick+0x144>
800080f8:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800080fa:	4b d8       	lddpc	r8,800081ec <vTaskIncrementTick+0x13c>
800080fc:	70 08       	ld.w	r8,r8[0x0]
800080fe:	70 08       	ld.w	r8,r8[0x0]
80008100:	58 08       	cp.w	r8,0
80008102:	c0 51       	brne	8000810c <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80008104:	4b d8       	lddpc	r8,800081f8 <vTaskIncrementTick+0x148>
80008106:	3f f9       	mov	r9,-1
80008108:	91 09       	st.w	r8[0x0],r9
8000810a:	c0 c8       	rjmp	80008122 <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000810c:	4b 88       	lddpc	r8,800081ec <vTaskIncrementTick+0x13c>
8000810e:	70 08       	ld.w	r8,r8[0x0]
80008110:	70 38       	ld.w	r8,r8[0xc]
80008112:	70 38       	ld.w	r8,r8[0xc]
80008114:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80008118:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000811c:	70 19       	ld.w	r9,r8[0x4]
8000811e:	4b 78       	lddpc	r8,800081f8 <vTaskIncrementTick+0x148>
80008120:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80008122:	4b 28       	lddpc	r8,800081e8 <vTaskIncrementTick+0x138>
80008124:	70 09       	ld.w	r9,r8[0x0]
80008126:	4b 58       	lddpc	r8,800081f8 <vTaskIncrementTick+0x148>
80008128:	70 08       	ld.w	r8,r8[0x0]
8000812a:	10 39       	cp.w	r9,r8
8000812c:	c5 83       	brcs	800081dc <vTaskIncrementTick+0x12c>
8000812e:	4b 08       	lddpc	r8,800081ec <vTaskIncrementTick+0x13c>
80008130:	70 08       	ld.w	r8,r8[0x0]
80008132:	70 08       	ld.w	r8,r8[0x0]
80008134:	58 08       	cp.w	r8,0
80008136:	c0 51       	brne	80008140 <vTaskIncrementTick+0x90>
80008138:	4b 08       	lddpc	r8,800081f8 <vTaskIncrementTick+0x148>
8000813a:	3f f9       	mov	r9,-1
8000813c:	91 09       	st.w	r8[0x0],r9
8000813e:	c4 f8       	rjmp	800081dc <vTaskIncrementTick+0x12c>
80008140:	4a b8       	lddpc	r8,800081ec <vTaskIncrementTick+0x13c>
80008142:	70 08       	ld.w	r8,r8[0x0]
80008144:	70 38       	ld.w	r8,r8[0xc]
80008146:	70 38       	ld.w	r8,r8[0xc]
80008148:	ef 48 ff f4 	st.w	r7[-12],r8
8000814c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008150:	70 18       	ld.w	r8,r8[0x4]
80008152:	ef 48 ff fc 	st.w	r7[-4],r8
80008156:	4a 58       	lddpc	r8,800081e8 <vTaskIncrementTick+0x138>
80008158:	70 09       	ld.w	r9,r8[0x0]
8000815a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000815e:	10 39       	cp.w	r9,r8
80008160:	c0 62       	brcc	8000816c <vTaskIncrementTick+0xbc>
80008162:	4a 68       	lddpc	r8,800081f8 <vTaskIncrementTick+0x148>
80008164:	ee f9 ff fc 	ld.w	r9,r7[-4]
80008168:	91 09       	st.w	r8[0x0],r9
8000816a:	c3 98       	rjmp	800081dc <vTaskIncrementTick+0x12c>
8000816c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008170:	2f c8       	sub	r8,-4
80008172:	10 9c       	mov	r12,r8
80008174:	f0 1f 00 22 	mcall	800081fc <vTaskIncrementTick+0x14c>
80008178:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000817c:	70 a8       	ld.w	r8,r8[0x28]
8000817e:	58 08       	cp.w	r8,0
80008180:	c0 70       	breq	8000818e <vTaskIncrementTick+0xde>
80008182:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008186:	2e 88       	sub	r8,-24
80008188:	10 9c       	mov	r12,r8
8000818a:	f0 1f 00 1d 	mcall	800081fc <vTaskIncrementTick+0x14c>
8000818e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008192:	70 b9       	ld.w	r9,r8[0x2c]
80008194:	49 b8       	lddpc	r8,80008200 <vTaskIncrementTick+0x150>
80008196:	70 08       	ld.w	r8,r8[0x0]
80008198:	10 39       	cp.w	r9,r8
8000819a:	e0 88 00 07 	brls	800081a8 <vTaskIncrementTick+0xf8>
8000819e:	ee f8 ff f4 	ld.w	r8,r7[-12]
800081a2:	70 b9       	ld.w	r9,r8[0x2c]
800081a4:	49 78       	lddpc	r8,80008200 <vTaskIncrementTick+0x150>
800081a6:	91 09       	st.w	r8[0x0],r9
800081a8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800081ac:	f0 ca ff fc 	sub	r10,r8,-4
800081b0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800081b4:	70 b9       	ld.w	r9,r8[0x2c]
800081b6:	12 98       	mov	r8,r9
800081b8:	a3 68       	lsl	r8,0x2
800081ba:	12 08       	add	r8,r9
800081bc:	a3 68       	lsl	r8,0x2
800081be:	10 99       	mov	r9,r8
800081c0:	49 18       	lddpc	r8,80008204 <vTaskIncrementTick+0x154>
800081c2:	f2 08 00 08 	add	r8,r9,r8
800081c6:	14 9b       	mov	r11,r10
800081c8:	10 9c       	mov	r12,r8
800081ca:	f0 1f 00 10 	mcall	80008208 <vTaskIncrementTick+0x158>
800081ce:	cb 0b       	rjmp	8000812e <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
800081d0:	48 f8       	lddpc	r8,8000820c <vTaskIncrementTick+0x15c>
800081d2:	70 08       	ld.w	r8,r8[0x0]
800081d4:	f0 c9 ff ff 	sub	r9,r8,-1
800081d8:	48 d8       	lddpc	r8,8000820c <vTaskIncrementTick+0x15c>
800081da:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
800081dc:	2f dd       	sub	sp,-12
800081de:	e3 cd 80 80 	ldm	sp++,r7,pc
800081e2:	00 00       	add	r0,r0
800081e4:	00 00       	add	r0,r0
800081e6:	0d 24       	ld.uh	r4,r6++
800081e8:	00 00       	add	r0,r0
800081ea:	0d 14       	ld.sh	r4,r6++
800081ec:	00 00       	add	r0,r0
800081ee:	0c c8       	st.b	r6++,r8
800081f0:	00 00       	add	r0,r0
800081f2:	0c cc       	st.b	r6++,r12
800081f4:	00 00       	add	r0,r0
800081f6:	0d 30       	ld.ub	r0,r6++
800081f8:	00 00       	add	r0,r0
800081fa:	05 2c       	ld.uh	r12,r2++
800081fc:	80 00       	ld.sh	r0,r0[0x0]
800081fe:	6d e6       	ld.w	r6,r6[0x78]
80008200:	00 00       	add	r0,r0
80008202:	0d 1c       	ld.sh	r12,r6++
80008204:	00 00       	add	r0,r0
80008206:	0c 00       	add	r0,r6
80008208:	80 00       	ld.sh	r0,r0[0x0]
8000820a:	6c d2       	ld.w	r2,r6[0x34]
8000820c:	00 00       	add	r0,r0
8000820e:	0d 28       	ld.uh	r8,r6++

80008210 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80008210:	eb cd 40 80 	pushm	r7,lr
80008214:	1a 97       	mov	r7,sp
80008216:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80008218:	4a 58       	lddpc	r8,800082ac <vTaskSwitchContext+0x9c>
8000821a:	70 08       	ld.w	r8,r8[0x0]
8000821c:	58 08       	cp.w	r8,0
8000821e:	c0 c0       	breq	80008236 <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80008220:	4a 48       	lddpc	r8,800082b0 <vTaskSwitchContext+0xa0>
80008222:	30 19       	mov	r9,1
80008224:	91 09       	st.w	r8[0x0],r9
80008226:	c3 f8       	rjmp	800082a4 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80008228:	4a 38       	lddpc	r8,800082b4 <vTaskSwitchContext+0xa4>
8000822a:	70 08       	ld.w	r8,r8[0x0]
8000822c:	f0 c9 00 01 	sub	r9,r8,1
80008230:	4a 18       	lddpc	r8,800082b4 <vTaskSwitchContext+0xa4>
80008232:	91 09       	st.w	r8[0x0],r9
80008234:	c0 28       	rjmp	80008238 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80008236:	d7 03       	nop
80008238:	49 f8       	lddpc	r8,800082b4 <vTaskSwitchContext+0xa4>
8000823a:	70 09       	ld.w	r9,r8[0x0]
8000823c:	12 98       	mov	r8,r9
8000823e:	a3 68       	lsl	r8,0x2
80008240:	12 08       	add	r8,r9
80008242:	a3 68       	lsl	r8,0x2
80008244:	10 99       	mov	r9,r8
80008246:	49 d8       	lddpc	r8,800082b8 <vTaskSwitchContext+0xa8>
80008248:	f2 08 00 08 	add	r8,r9,r8
8000824c:	70 08       	ld.w	r8,r8[0x0]
8000824e:	58 08       	cp.w	r8,0
80008250:	ce c0       	breq	80008228 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80008252:	49 98       	lddpc	r8,800082b4 <vTaskSwitchContext+0xa4>
80008254:	70 09       	ld.w	r9,r8[0x0]
80008256:	12 98       	mov	r8,r9
80008258:	a3 68       	lsl	r8,0x2
8000825a:	12 08       	add	r8,r9
8000825c:	a3 68       	lsl	r8,0x2
8000825e:	10 99       	mov	r9,r8
80008260:	49 68       	lddpc	r8,800082b8 <vTaskSwitchContext+0xa8>
80008262:	f2 08 00 08 	add	r8,r9,r8
80008266:	ef 48 ff fc 	st.w	r7[-4],r8
8000826a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000826e:	70 18       	ld.w	r8,r8[0x4]
80008270:	70 19       	ld.w	r9,r8[0x4]
80008272:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008276:	91 19       	st.w	r8[0x4],r9
80008278:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000827c:	70 19       	ld.w	r9,r8[0x4]
8000827e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008282:	2f 88       	sub	r8,-8
80008284:	10 39       	cp.w	r9,r8
80008286:	c0 81       	brne	80008296 <vTaskSwitchContext+0x86>
80008288:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000828c:	70 18       	ld.w	r8,r8[0x4]
8000828e:	70 19       	ld.w	r9,r8[0x4]
80008290:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008294:	91 19       	st.w	r8[0x4],r9
80008296:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000829a:	70 18       	ld.w	r8,r8[0x4]
8000829c:	70 38       	ld.w	r8,r8[0xc]
8000829e:	10 99       	mov	r9,r8
800082a0:	48 78       	lddpc	r8,800082bc <vTaskSwitchContext+0xac>
800082a2:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
800082a4:	2f fd       	sub	sp,-4
800082a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800082aa:	00 00       	add	r0,r0
800082ac:	00 00       	add	r0,r0
800082ae:	0d 24       	ld.uh	r4,r6++
800082b0:	00 00       	add	r0,r0
800082b2:	0d 2c       	ld.uh	r12,r6++
800082b4:	00 00       	add	r0,r0
800082b6:	0d 1c       	ld.sh	r12,r6++
800082b8:	00 00       	add	r0,r0
800082ba:	0c 00       	add	r0,r6
800082bc:	00 00       	add	r0,r0
800082be:	0b fc       	ld.ub	r12,r5[0x7]

800082c0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800082c0:	eb cd 40 80 	pushm	r7,lr
800082c4:	1a 97       	mov	r7,sp
800082c6:	20 3d       	sub	sp,12
800082c8:	ef 4c ff f8 	st.w	r7[-8],r12
800082cc:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800082d0:	49 58       	lddpc	r8,80008324 <vTaskPlaceOnEventList+0x64>
800082d2:	70 08       	ld.w	r8,r8[0x0]
800082d4:	2e 88       	sub	r8,-24
800082d6:	10 9b       	mov	r11,r8
800082d8:	ee fc ff f8 	ld.w	r12,r7[-8]
800082dc:	f0 1f 00 13 	mcall	80008328 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800082e0:	49 18       	lddpc	r8,80008324 <vTaskPlaceOnEventList+0x64>
800082e2:	70 08       	ld.w	r8,r8[0x0]
800082e4:	2f c8       	sub	r8,-4
800082e6:	10 9c       	mov	r12,r8
800082e8:	f0 1f 00 11 	mcall	8000832c <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800082ec:	ee f8 ff f4 	ld.w	r8,r7[-12]
800082f0:	5b f8       	cp.w	r8,-1
800082f2:	c0 91       	brne	80008304 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800082f4:	48 c8       	lddpc	r8,80008324 <vTaskPlaceOnEventList+0x64>
800082f6:	70 08       	ld.w	r8,r8[0x0]
800082f8:	2f c8       	sub	r8,-4
800082fa:	10 9b       	mov	r11,r8
800082fc:	48 dc       	lddpc	r12,80008330 <vTaskPlaceOnEventList+0x70>
800082fe:	f0 1f 00 0e 	mcall	80008334 <vTaskPlaceOnEventList+0x74>
80008302:	c0 d8       	rjmp	8000831c <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80008304:	48 d8       	lddpc	r8,80008338 <vTaskPlaceOnEventList+0x78>
80008306:	70 09       	ld.w	r9,r8[0x0]
80008308:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000830c:	f2 08 00 08 	add	r8,r9,r8
80008310:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80008314:	ee fc ff fc 	ld.w	r12,r7[-4]
80008318:	f0 1f 00 09 	mcall	8000833c <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
8000831c:	2f dd       	sub	sp,-12
8000831e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008322:	00 00       	add	r0,r0
80008324:	00 00       	add	r0,r0
80008326:	0b fc       	ld.ub	r12,r5[0x7]
80008328:	80 00       	ld.sh	r0,r0[0x0]
8000832a:	6d 44       	ld.w	r4,r6[0x50]
8000832c:	80 00       	ld.sh	r0,r0[0x0]
8000832e:	6d e6       	ld.w	r6,r6[0x78]
80008330:	00 00       	add	r0,r0
80008332:	0c fc       	st.b	--r6,r12
80008334:	80 00       	ld.sh	r0,r0[0x0]
80008336:	6c d2       	ld.w	r2,r6[0x34]
80008338:	00 00       	add	r0,r0
8000833a:	0d 14       	ld.sh	r4,r6++
8000833c:	80 00       	ld.sh	r0,r0[0x0]
8000833e:	87 10       	st.w	r3[0x4],r0

80008340 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80008340:	eb cd 40 80 	pushm	r7,lr
80008344:	1a 97       	mov	r7,sp
80008346:	20 3d       	sub	sp,12
80008348:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000834c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008350:	70 38       	ld.w	r8,r8[0xc]
80008352:	70 38       	ld.w	r8,r8[0xc]
80008354:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80008358:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000835c:	2e 88       	sub	r8,-24
8000835e:	10 9c       	mov	r12,r8
80008360:	f0 1f 00 25 	mcall	800083f4 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80008364:	4a 58       	lddpc	r8,800083f8 <xTaskRemoveFromEventList+0xb8>
80008366:	70 08       	ld.w	r8,r8[0x0]
80008368:	58 08       	cp.w	r8,0
8000836a:	c2 81       	brne	800083ba <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000836c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008370:	2f c8       	sub	r8,-4
80008372:	10 9c       	mov	r12,r8
80008374:	f0 1f 00 20 	mcall	800083f4 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80008378:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000837c:	70 b9       	ld.w	r9,r8[0x2c]
8000837e:	4a 08       	lddpc	r8,800083fc <xTaskRemoveFromEventList+0xbc>
80008380:	70 08       	ld.w	r8,r8[0x0]
80008382:	10 39       	cp.w	r9,r8
80008384:	e0 88 00 07 	brls	80008392 <xTaskRemoveFromEventList+0x52>
80008388:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000838c:	70 b9       	ld.w	r9,r8[0x2c]
8000838e:	49 c8       	lddpc	r8,800083fc <xTaskRemoveFromEventList+0xbc>
80008390:	91 09       	st.w	r8[0x0],r9
80008392:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008396:	f0 ca ff fc 	sub	r10,r8,-4
8000839a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000839e:	70 b9       	ld.w	r9,r8[0x2c]
800083a0:	12 98       	mov	r8,r9
800083a2:	a3 68       	lsl	r8,0x2
800083a4:	12 08       	add	r8,r9
800083a6:	a3 68       	lsl	r8,0x2
800083a8:	10 99       	mov	r9,r8
800083aa:	49 68       	lddpc	r8,80008400 <xTaskRemoveFromEventList+0xc0>
800083ac:	f2 08 00 08 	add	r8,r9,r8
800083b0:	14 9b       	mov	r11,r10
800083b2:	10 9c       	mov	r12,r8
800083b4:	f0 1f 00 14 	mcall	80008404 <xTaskRemoveFromEventList+0xc4>
800083b8:	c0 88       	rjmp	800083c8 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800083ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800083be:	2e 88       	sub	r8,-24
800083c0:	10 9b       	mov	r11,r8
800083c2:	49 2c       	lddpc	r12,80008408 <xTaskRemoveFromEventList+0xc8>
800083c4:	f0 1f 00 10 	mcall	80008404 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800083c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800083cc:	70 b9       	ld.w	r9,r8[0x2c]
800083ce:	49 08       	lddpc	r8,8000840c <xTaskRemoveFromEventList+0xcc>
800083d0:	70 08       	ld.w	r8,r8[0x0]
800083d2:	70 b8       	ld.w	r8,r8[0x2c]
800083d4:	10 39       	cp.w	r9,r8
800083d6:	c0 53       	brcs	800083e0 <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
800083d8:	30 18       	mov	r8,1
800083da:	ef 48 ff fc 	st.w	r7[-4],r8
800083de:	c0 48       	rjmp	800083e6 <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
800083e0:	30 08       	mov	r8,0
800083e2:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
800083e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800083ea:	10 9c       	mov	r12,r8
800083ec:	2f dd       	sub	sp,-12
800083ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800083f2:	00 00       	add	r0,r0
800083f4:	80 00       	ld.sh	r0,r0[0x0]
800083f6:	6d e6       	ld.w	r6,r6[0x78]
800083f8:	00 00       	add	r0,r0
800083fa:	0d 24       	ld.uh	r4,r6++
800083fc:	00 00       	add	r0,r0
800083fe:	0d 1c       	ld.sh	r12,r6++
80008400:	00 00       	add	r0,r0
80008402:	0c 00       	add	r0,r6
80008404:	80 00       	ld.sh	r0,r0[0x0]
80008406:	6c d2       	ld.w	r2,r6[0x34]
80008408:	00 00       	add	r0,r0
8000840a:	0c d0       	st.w	--r6,r0
8000840c:	00 00       	add	r0,r0
8000840e:	0b fc       	ld.ub	r12,r5[0x7]

80008410 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
80008410:	eb cd 40 80 	pushm	r7,lr
80008414:	1a 97       	mov	r7,sp
80008416:	20 1d       	sub	sp,4
80008418:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000841c:	48 78       	lddpc	r8,80008438 <vTaskSetTimeOutState+0x28>
8000841e:	70 09       	ld.w	r9,r8[0x0]
80008420:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008424:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
80008426:	48 68       	lddpc	r8,8000843c <vTaskSetTimeOutState+0x2c>
80008428:	70 09       	ld.w	r9,r8[0x0]
8000842a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000842e:	91 19       	st.w	r8[0x4],r9
}
80008430:	2f fd       	sub	sp,-4
80008432:	e3 cd 80 80 	ldm	sp++,r7,pc
80008436:	00 00       	add	r0,r0
80008438:	00 00       	add	r0,r0
8000843a:	0d 30       	ld.ub	r0,r6++
8000843c:	00 00       	add	r0,r0
8000843e:	0d 14       	ld.sh	r4,r6++

80008440 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80008440:	eb cd 40 80 	pushm	r7,lr
80008444:	1a 97       	mov	r7,sp
80008446:	20 3d       	sub	sp,12
80008448:	ef 4c ff f8 	st.w	r7[-8],r12
8000844c:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80008450:	f0 1f 00 25 	mcall	800084e4 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80008454:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008458:	70 08       	ld.w	r8,r8[0x0]
8000845a:	5b f8       	cp.w	r8,-1
8000845c:	c0 51       	brne	80008466 <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
8000845e:	30 08       	mov	r8,0
80008460:	ef 48 ff fc 	st.w	r7[-4],r8
80008464:	c3 88       	rjmp	800084d4 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80008466:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000846a:	70 09       	ld.w	r9,r8[0x0]
8000846c:	49 f8       	lddpc	r8,800084e8 <xTaskCheckForTimeOut+0xa8>
8000846e:	70 08       	ld.w	r8,r8[0x0]
80008470:	10 39       	cp.w	r9,r8
80008472:	c0 d0       	breq	8000848c <xTaskCheckForTimeOut+0x4c>
80008474:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008478:	70 19       	ld.w	r9,r8[0x4]
8000847a:	49 d8       	lddpc	r8,800084ec <xTaskCheckForTimeOut+0xac>
8000847c:	70 08       	ld.w	r8,r8[0x0]
8000847e:	10 39       	cp.w	r9,r8
80008480:	e0 8b 00 06 	brhi	8000848c <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
80008484:	30 18       	mov	r8,1
80008486:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000848a:	c2 58       	rjmp	800084d4 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
8000848c:	49 88       	lddpc	r8,800084ec <xTaskCheckForTimeOut+0xac>
8000848e:	70 09       	ld.w	r9,r8[0x0]
80008490:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008494:	70 18       	ld.w	r8,r8[0x4]
80008496:	10 19       	sub	r9,r8
80008498:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000849c:	70 08       	ld.w	r8,r8[0x0]
8000849e:	10 39       	cp.w	r9,r8
800084a0:	c1 72       	brcc	800084ce <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800084a2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800084a6:	70 09       	ld.w	r9,r8[0x0]
800084a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800084ac:	70 1a       	ld.w	r10,r8[0x4]
800084ae:	49 08       	lddpc	r8,800084ec <xTaskCheckForTimeOut+0xac>
800084b0:	70 08       	ld.w	r8,r8[0x0]
800084b2:	f4 08 01 08 	sub	r8,r10,r8
800084b6:	10 09       	add	r9,r8
800084b8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800084bc:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
800084be:	ee fc ff f8 	ld.w	r12,r7[-8]
800084c2:	f0 1f 00 0c 	mcall	800084f0 <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
800084c6:	30 08       	mov	r8,0
800084c8:	ef 48 ff fc 	st.w	r7[-4],r8
800084cc:	c0 48       	rjmp	800084d4 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
800084ce:	30 18       	mov	r8,1
800084d0:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
800084d4:	f0 1f 00 08 	mcall	800084f4 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
800084d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800084dc:	10 9c       	mov	r12,r8
800084de:	2f dd       	sub	sp,-12
800084e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800084e4:	80 00       	ld.sh	r0,r0[0x0]
800084e6:	6f a4       	ld.w	r4,r7[0x68]
800084e8:	00 00       	add	r0,r0
800084ea:	0d 30       	ld.ub	r0,r6++
800084ec:	00 00       	add	r0,r0
800084ee:	0d 14       	ld.sh	r4,r6++
800084f0:	80 00       	ld.sh	r0,r0[0x0]
800084f2:	84 10       	ld.sh	r0,r2[0x2]
800084f4:	80 00       	ld.sh	r0,r0[0x0]
800084f6:	6f c0       	ld.w	r0,r7[0x70]

800084f8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
800084f8:	eb cd 40 80 	pushm	r7,lr
800084fc:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
800084fe:	48 38       	lddpc	r8,80008508 <vTaskMissedYield+0x10>
80008500:	30 19       	mov	r9,1
80008502:	91 09       	st.w	r8[0x0],r9
}
80008504:	e3 cd 80 80 	ldm	sp++,r7,pc
80008508:	00 00       	add	r0,r0
8000850a:	0d 2c       	ld.uh	r12,r6++

8000850c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
8000850c:	eb cd 40 80 	pushm	r7,lr
80008510:	1a 97       	mov	r7,sp
80008512:	20 1d       	sub	sp,4
80008514:	ef 4c ff fc 	st.w	r7[-4],r12
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
80008518:	f0 1f 00 06 	mcall	80008530 <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000851c:	48 68       	lddpc	r8,80008534 <prvIdleTask+0x28>
8000851e:	70 08       	ld.w	r8,r8[0x0]
80008520:	58 18       	cp.w	r8,1
80008522:	e0 88 00 03 	brls	80008528 <prvIdleTask+0x1c>
			{
				taskYIELD();
80008526:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80008528:	f0 1f 00 04 	mcall	80008538 <prvIdleTask+0x2c>
		}
		#endif
	}
8000852c:	cf 6b       	rjmp	80008518 <prvIdleTask+0xc>
8000852e:	00 00       	add	r0,r0
80008530:	80 00       	ld.sh	r0,r0[0x0]
80008532:	86 78       	ld.sh	r8,r3[0xe]
80008534:	00 00       	add	r0,r0
80008536:	0c 00       	add	r0,r6
80008538:	80 00       	ld.sh	r0,r0[0x0]
8000853a:	34 a8       	mov	r8,74

8000853c <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
8000853c:	eb cd 40 80 	pushm	r7,lr
80008540:	1a 97       	mov	r7,sp
80008542:	20 5d       	sub	sp,20
80008544:	ef 4c ff fc 	st.w	r7[-4],r12
80008548:	ef 4b ff f8 	st.w	r7[-8],r11
8000854c:	ef 4a ff f4 	st.w	r7[-12],r10
80008550:	ef 49 ff f0 	st.w	r7[-16],r9
80008554:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80008558:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000855c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008560:	2c c8       	sub	r8,-52
80008562:	31 0a       	mov	r10,16
80008564:	12 9b       	mov	r11,r9
80008566:	10 9c       	mov	r12,r8
80008568:	f0 1f 00 1d 	mcall	800085dc <prvInitialiseTCBVariables+0xa0>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000856c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80008570:	30 08       	mov	r8,0
80008572:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
80008576:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000857a:	58 78       	cp.w	r8,7
8000857c:	e0 88 00 05 	brls	80008586 <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80008580:	30 78       	mov	r8,7
80008582:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
80008586:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000858a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000858e:	91 b9       	st.w	r8[0x2c],r9
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80008590:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008594:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008598:	f1 49 00 44 	st.w	r8[68],r9
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
8000859c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085a0:	2f c8       	sub	r8,-4
800085a2:	10 9c       	mov	r12,r8
800085a4:	f0 1f 00 0f 	mcall	800085e0 <prvInitialiseTCBVariables+0xa4>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800085a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085ac:	2e 88       	sub	r8,-24
800085ae:	10 9c       	mov	r12,r8
800085b0:	f0 1f 00 0c 	mcall	800085e0 <prvInitialiseTCBVariables+0xa4>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800085b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085b8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800085bc:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800085be:	ee f8 ff f4 	ld.w	r8,r7[-12]
800085c2:	f0 09 11 08 	rsub	r9,r8,8
800085c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085ca:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800085cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085d0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800085d4:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
800085d6:	2f bd       	sub	sp,-20
800085d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800085dc:	80 00       	ld.sh	r0,r0[0x0]
800085de:	9c 14       	ld.sh	r4,lr[0x2]
800085e0:	80 00       	ld.sh	r0,r0[0x0]
800085e2:	6c b8       	ld.w	r8,r6[0x2c]

800085e4 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
800085e4:	eb cd 40 80 	pushm	r7,lr
800085e8:	1a 97       	mov	r7,sp
800085ea:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800085ec:	30 08       	mov	r8,0
800085ee:	ef 48 ff fc 	st.w	r7[-4],r8
800085f2:	c1 38       	rjmp	80008618 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800085f4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800085f8:	12 98       	mov	r8,r9
800085fa:	a3 68       	lsl	r8,0x2
800085fc:	12 08       	add	r8,r9
800085fe:	a3 68       	lsl	r8,0x2
80008600:	10 99       	mov	r9,r8
80008602:	49 58       	lddpc	r8,80008654 <prvInitialiseTaskLists+0x70>
80008604:	f2 08 00 08 	add	r8,r9,r8
80008608:	10 9c       	mov	r12,r8
8000860a:	f0 1f 00 14 	mcall	80008658 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
8000860e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008612:	2f f8       	sub	r8,-1
80008614:	ef 48 ff fc 	st.w	r7[-4],r8
80008618:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000861c:	58 78       	cp.w	r8,7
8000861e:	fe 98 ff eb 	brls	800085f4 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80008622:	48 fc       	lddpc	r12,8000865c <prvInitialiseTaskLists+0x78>
80008624:	f0 1f 00 0d 	mcall	80008658 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80008628:	48 ec       	lddpc	r12,80008660 <prvInitialiseTaskLists+0x7c>
8000862a:	f0 1f 00 0c 	mcall	80008658 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000862e:	48 ec       	lddpc	r12,80008664 <prvInitialiseTaskLists+0x80>
80008630:	f0 1f 00 0a 	mcall	80008658 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80008634:	48 dc       	lddpc	r12,80008668 <prvInitialiseTaskLists+0x84>
80008636:	f0 1f 00 09 	mcall	80008658 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
8000863a:	48 dc       	lddpc	r12,8000866c <prvInitialiseTaskLists+0x88>
8000863c:	f0 1f 00 07 	mcall	80008658 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80008640:	48 c8       	lddpc	r8,80008670 <prvInitialiseTaskLists+0x8c>
80008642:	48 79       	lddpc	r9,8000865c <prvInitialiseTaskLists+0x78>
80008644:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80008646:	48 c8       	lddpc	r8,80008674 <prvInitialiseTaskLists+0x90>
80008648:	48 69       	lddpc	r9,80008660 <prvInitialiseTaskLists+0x7c>
8000864a:	91 09       	st.w	r8[0x0],r9
}
8000864c:	2f fd       	sub	sp,-4
8000864e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008652:	00 00       	add	r0,r0
80008654:	00 00       	add	r0,r0
80008656:	0c 00       	add	r0,r6
80008658:	80 00       	ld.sh	r0,r0[0x0]
8000865a:	6c 6c       	ld.w	r12,r6[0x18]
8000865c:	00 00       	add	r0,r0
8000865e:	0c a0       	st.w	r6++,r0
80008660:	00 00       	add	r0,r0
80008662:	0c b4       	st.h	r6++,r4
80008664:	00 00       	add	r0,r0
80008666:	0c d0       	st.w	--r6,r0
80008668:	00 00       	add	r0,r0
8000866a:	0c e4       	st.h	--r6,r4
8000866c:	00 00       	add	r0,r0
8000866e:	0c fc       	st.b	--r6,r12
80008670:	00 00       	add	r0,r0
80008672:	0c c8       	st.b	r6++,r8
80008674:	00 00       	add	r0,r0
80008676:	0c cc       	st.b	r6++,r12

80008678 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
80008678:	eb cd 40 80 	pushm	r7,lr
8000867c:	1a 97       	mov	r7,sp
8000867e:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80008680:	49 b8       	lddpc	r8,800086ec <prvCheckTasksWaitingTermination+0x74>
80008682:	70 08       	ld.w	r8,r8[0x0]
80008684:	58 08       	cp.w	r8,0
80008686:	c2 f0       	breq	800086e4 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
80008688:	f0 1f 00 1a 	mcall	800086f0 <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000868c:	49 a8       	lddpc	r8,800086f4 <prvCheckTasksWaitingTermination+0x7c>
8000868e:	70 08       	ld.w	r8,r8[0x0]
80008690:	58 08       	cp.w	r8,0
80008692:	5f 08       	sreq	r8
80008694:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
80008698:	f0 1f 00 18 	mcall	800086f8 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
8000869c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800086a0:	58 08       	cp.w	r8,0
800086a2:	c2 11       	brne	800086e4 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800086a4:	f0 1f 00 16 	mcall	800086fc <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800086a8:	49 38       	lddpc	r8,800086f4 <prvCheckTasksWaitingTermination+0x7c>
800086aa:	2f 88       	sub	r8,-8
800086ac:	70 18       	ld.w	r8,r8[0x4]
800086ae:	70 38       	ld.w	r8,r8[0xc]
800086b0:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
800086b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086b8:	2f c8       	sub	r8,-4
800086ba:	10 9c       	mov	r12,r8
800086bc:	f0 1f 00 11 	mcall	80008700 <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
800086c0:	49 18       	lddpc	r8,80008704 <prvCheckTasksWaitingTermination+0x8c>
800086c2:	70 08       	ld.w	r8,r8[0x0]
800086c4:	f0 c9 00 01 	sub	r9,r8,1
800086c8:	48 f8       	lddpc	r8,80008704 <prvCheckTasksWaitingTermination+0x8c>
800086ca:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
800086cc:	48 88       	lddpc	r8,800086ec <prvCheckTasksWaitingTermination+0x74>
800086ce:	70 08       	ld.w	r8,r8[0x0]
800086d0:	f0 c9 00 01 	sub	r9,r8,1
800086d4:	48 68       	lddpc	r8,800086ec <prvCheckTasksWaitingTermination+0x74>
800086d6:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
800086d8:	f0 1f 00 0c 	mcall	80008708 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
800086dc:	ee fc ff fc 	ld.w	r12,r7[-4]
800086e0:	f0 1f 00 0b 	mcall	8000870c <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
800086e4:	2f ed       	sub	sp,-8
800086e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800086ea:	00 00       	add	r0,r0
800086ec:	00 00       	add	r0,r0
800086ee:	0c f8       	st.b	--r6,r8
800086f0:	80 00       	ld.sh	r0,r0[0x0]
800086f2:	7f 3c       	ld.w	r12,pc[0x4c]
800086f4:	00 00       	add	r0,r0
800086f6:	0c e4       	st.h	--r6,r4
800086f8:	80 00       	ld.sh	r0,r0[0x0]
800086fa:	7f 58       	ld.w	r8,pc[0x54]
800086fc:	80 00       	ld.sh	r0,r0[0x0]
800086fe:	6f a4       	ld.w	r4,r7[0x68]
80008700:	80 00       	ld.sh	r0,r0[0x0]
80008702:	6d e6       	ld.w	r6,r6[0x78]
80008704:	00 00       	add	r0,r0
80008706:	0d 10       	ld.sh	r0,r6++
80008708:	80 00       	ld.sh	r0,r0[0x0]
8000870a:	6f c0       	ld.w	r0,r7[0x70]
8000870c:	80 00       	ld.sh	r0,r0[0x0]
8000870e:	88 24       	ld.sh	r4,r4[0x4]

80008710 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80008710:	eb cd 40 80 	pushm	r7,lr
80008714:	1a 97       	mov	r7,sp
80008716:	20 1d       	sub	sp,4
80008718:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000871c:	49 78       	lddpc	r8,80008778 <prvAddCurrentTaskToDelayedList+0x68>
8000871e:	70 08       	ld.w	r8,r8[0x0]
80008720:	ee f9 ff fc 	ld.w	r9,r7[-4]
80008724:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
80008726:	49 68       	lddpc	r8,8000877c <prvAddCurrentTaskToDelayedList+0x6c>
80008728:	70 08       	ld.w	r8,r8[0x0]
8000872a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000872e:	10 39       	cp.w	r9,r8
80008730:	c0 c2       	brcc	80008748 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80008732:	49 28       	lddpc	r8,80008778 <prvAddCurrentTaskToDelayedList+0x68>
80008734:	70 08       	ld.w	r8,r8[0x0]
80008736:	f0 c9 ff fc 	sub	r9,r8,-4
8000873a:	49 28       	lddpc	r8,80008780 <prvAddCurrentTaskToDelayedList+0x70>
8000873c:	70 08       	ld.w	r8,r8[0x0]
8000873e:	12 9b       	mov	r11,r9
80008740:	10 9c       	mov	r12,r8
80008742:	f0 1f 00 11 	mcall	80008784 <prvAddCurrentTaskToDelayedList+0x74>
80008746:	c1 58       	rjmp	80008770 <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80008748:	48 c8       	lddpc	r8,80008778 <prvAddCurrentTaskToDelayedList+0x68>
8000874a:	70 08       	ld.w	r8,r8[0x0]
8000874c:	f0 c9 ff fc 	sub	r9,r8,-4
80008750:	48 e8       	lddpc	r8,80008788 <prvAddCurrentTaskToDelayedList+0x78>
80008752:	70 08       	ld.w	r8,r8[0x0]
80008754:	12 9b       	mov	r11,r9
80008756:	10 9c       	mov	r12,r8
80008758:	f0 1f 00 0b 	mcall	80008784 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
8000875c:	48 c8       	lddpc	r8,8000878c <prvAddCurrentTaskToDelayedList+0x7c>
8000875e:	70 08       	ld.w	r8,r8[0x0]
80008760:	ee f9 ff fc 	ld.w	r9,r7[-4]
80008764:	10 39       	cp.w	r9,r8
80008766:	c0 52       	brcc	80008770 <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
80008768:	48 98       	lddpc	r8,8000878c <prvAddCurrentTaskToDelayedList+0x7c>
8000876a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000876e:	91 09       	st.w	r8[0x0],r9
		}
	}
}
80008770:	2f fd       	sub	sp,-4
80008772:	e3 cd 80 80 	ldm	sp++,r7,pc
80008776:	00 00       	add	r0,r0
80008778:	00 00       	add	r0,r0
8000877a:	0b fc       	ld.ub	r12,r5[0x7]
8000877c:	00 00       	add	r0,r0
8000877e:	0d 14       	ld.sh	r4,r6++
80008780:	00 00       	add	r0,r0
80008782:	0c cc       	st.b	r6++,r12
80008784:	80 00       	ld.sh	r0,r0[0x0]
80008786:	6d 44       	ld.w	r4,r6[0x50]
80008788:	00 00       	add	r0,r0
8000878a:	0c c8       	st.b	r6++,r8
8000878c:	00 00       	add	r0,r0
8000878e:	05 2c       	ld.uh	r12,r2++

80008790 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
80008790:	eb cd 40 80 	pushm	r7,lr
80008794:	1a 97       	mov	r7,sp
80008796:	20 3d       	sub	sp,12
80008798:	18 98       	mov	r8,r12
8000879a:	ef 4b ff f4 	st.w	r7[-12],r11
8000879e:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800087a2:	34 8c       	mov	r12,72
800087a4:	f0 1f 00 1d 	mcall	80008818 <prvAllocateTCBAndStack+0x88>
800087a8:	18 98       	mov	r8,r12
800087aa:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
800087ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800087b2:	58 08       	cp.w	r8,0
800087b4:	c2 c0       	breq	8000880c <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800087b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800087ba:	58 08       	cp.w	r8,0
800087bc:	c0 91       	brne	800087ce <prvAllocateTCBAndStack+0x3e>
800087be:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800087c2:	a3 68       	lsl	r8,0x2
800087c4:	10 9c       	mov	r12,r8
800087c6:	f0 1f 00 15 	mcall	80008818 <prvAllocateTCBAndStack+0x88>
800087ca:	18 98       	mov	r8,r12
800087cc:	c0 38       	rjmp	800087d2 <prvAllocateTCBAndStack+0x42>
800087ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800087d2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800087d6:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
800087d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800087dc:	70 c8       	ld.w	r8,r8[0x30]
800087de:	58 08       	cp.w	r8,0
800087e0:	c0 91       	brne	800087f2 <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800087e2:	ee fc ff fc 	ld.w	r12,r7[-4]
800087e6:	f0 1f 00 0e 	mcall	8000881c <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
800087ea:	30 08       	mov	r8,0
800087ec:	ef 48 ff fc 	st.w	r7[-4],r8
800087f0:	c0 e8       	rjmp	8000880c <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800087f2:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800087f6:	f0 09 15 02 	lsl	r9,r8,0x2
800087fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800087fe:	70 c8       	ld.w	r8,r8[0x30]
80008800:	12 9a       	mov	r10,r9
80008802:	e0 6b 00 a5 	mov	r11,165
80008806:	10 9c       	mov	r12,r8
80008808:	f0 1f 00 06 	mcall	80008820 <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
8000880c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80008810:	10 9c       	mov	r12,r8
80008812:	2f dd       	sub	sp,-12
80008814:	e3 cd 80 80 	ldm	sp++,r7,pc
80008818:	80 00       	ld.sh	r0,r0[0x0]
8000881a:	73 4c       	ld.w	r12,r9[0x50]
8000881c:	80 00       	ld.sh	r0,r0[0x0]
8000881e:	73 88       	ld.w	r8,r9[0x60]
80008820:	80 00       	ld.sh	r0,r0[0x0]
80008822:	98 d0       	ld.uh	r0,r12[0xa]

80008824 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
80008824:	eb cd 40 80 	pushm	r7,lr
80008828:	1a 97       	mov	r7,sp
8000882a:	20 1d       	sub	sp,4
8000882c:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80008830:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008834:	70 c8       	ld.w	r8,r8[0x30]
80008836:	10 9c       	mov	r12,r8
80008838:	f0 1f 00 05 	mcall	8000884c <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
8000883c:	ee fc ff fc 	ld.w	r12,r7[-4]
80008840:	f0 1f 00 03 	mcall	8000884c <prvDeleteTCB+0x28>
	}
80008844:	2f fd       	sub	sp,-4
80008846:	e3 cd 80 80 	ldm	sp++,r7,pc
8000884a:	00 00       	add	r0,r0
8000884c:	80 00       	ld.sh	r0,r0[0x0]
8000884e:	73 88       	ld.w	r8,r9[0x60]

80008850 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
80008850:	eb cd 40 80 	pushm	r7,lr
80008854:	1a 97       	mov	r7,sp
80008856:	20 1d       	sub	sp,4
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80008858:	48 58       	lddpc	r8,8000886c <xTaskGetCurrentTaskHandle+0x1c>
8000885a:	70 08       	ld.w	r8,r8[0x0]
8000885c:	ef 48 ff fc 	st.w	r7[-4],r8

		return xReturn;
80008860:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
80008864:	10 9c       	mov	r12,r8
80008866:	2f fd       	sub	sp,-4
80008868:	e3 cd 80 80 	ldm	sp++,r7,pc
8000886c:	00 00       	add	r0,r0
8000886e:	0b fc       	ld.ub	r12,r5[0x7]

80008870 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80008870:	eb cd 40 80 	pushm	r7,lr
80008874:	1a 97       	mov	r7,sp
80008876:	20 2d       	sub	sp,8
80008878:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000887c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008880:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80008884:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008888:	70 b9       	ld.w	r9,r8[0x2c]
8000888a:	4a a8       	lddpc	r8,80008930 <vTaskPriorityInherit+0xc0>
8000888c:	70 08       	ld.w	r8,r8[0x0]
8000888e:	70 b8       	ld.w	r8,r8[0x2c]
80008890:	10 39       	cp.w	r9,r8
80008892:	c4 c2       	brcc	8000892a <vTaskPriorityInherit+0xba>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80008894:	4a 78       	lddpc	r8,80008930 <vTaskPriorityInherit+0xc0>
80008896:	70 08       	ld.w	r8,r8[0x0]
80008898:	70 b8       	ld.w	r8,r8[0x2c]
8000889a:	f0 09 11 08 	rsub	r9,r8,8
8000889e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088a2:	91 69       	st.w	r8[0x18],r9

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800088a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088a8:	70 5a       	ld.w	r10,r8[0x14]
800088aa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088ae:	70 b9       	ld.w	r9,r8[0x2c]
800088b0:	12 98       	mov	r8,r9
800088b2:	a3 68       	lsl	r8,0x2
800088b4:	12 08       	add	r8,r9
800088b6:	a3 68       	lsl	r8,0x2
800088b8:	10 99       	mov	r9,r8
800088ba:	49 f8       	lddpc	r8,80008934 <vTaskPriorityInherit+0xc4>
800088bc:	f2 08 00 08 	add	r8,r9,r8
800088c0:	10 3a       	cp.w	r10,r8
800088c2:	c2 e1       	brne	8000891e <vTaskPriorityInherit+0xae>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800088c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088c8:	2f c8       	sub	r8,-4
800088ca:	10 9c       	mov	r12,r8
800088cc:	f0 1f 00 1b 	mcall	80008938 <vTaskPriorityInherit+0xc8>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800088d0:	49 88       	lddpc	r8,80008930 <vTaskPriorityInherit+0xc0>
800088d2:	70 08       	ld.w	r8,r8[0x0]
800088d4:	70 b9       	ld.w	r9,r8[0x2c]
800088d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088da:	91 b9       	st.w	r8[0x2c],r9
				prvAddTaskToReadyQueue( pxTCB );
800088dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088e0:	70 b9       	ld.w	r9,r8[0x2c]
800088e2:	49 78       	lddpc	r8,8000893c <vTaskPriorityInherit+0xcc>
800088e4:	70 08       	ld.w	r8,r8[0x0]
800088e6:	10 39       	cp.w	r9,r8
800088e8:	e0 88 00 07 	brls	800088f6 <vTaskPriorityInherit+0x86>
800088ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088f0:	70 b9       	ld.w	r9,r8[0x2c]
800088f2:	49 38       	lddpc	r8,8000893c <vTaskPriorityInherit+0xcc>
800088f4:	91 09       	st.w	r8[0x0],r9
800088f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800088fa:	f0 ca ff fc 	sub	r10,r8,-4
800088fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008902:	70 b9       	ld.w	r9,r8[0x2c]
80008904:	12 98       	mov	r8,r9
80008906:	a3 68       	lsl	r8,0x2
80008908:	12 08       	add	r8,r9
8000890a:	a3 68       	lsl	r8,0x2
8000890c:	10 99       	mov	r9,r8
8000890e:	48 a8       	lddpc	r8,80008934 <vTaskPriorityInherit+0xc4>
80008910:	f2 08 00 08 	add	r8,r9,r8
80008914:	14 9b       	mov	r11,r10
80008916:	10 9c       	mov	r12,r8
80008918:	f0 1f 00 0a 	mcall	80008940 <vTaskPriorityInherit+0xd0>
8000891c:	c0 78       	rjmp	8000892a <vTaskPriorityInherit+0xba>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000891e:	48 58       	lddpc	r8,80008930 <vTaskPriorityInherit+0xc0>
80008920:	70 08       	ld.w	r8,r8[0x0]
80008922:	70 b9       	ld.w	r9,r8[0x2c]
80008924:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008928:	91 b9       	st.w	r8[0x2c],r9
			}
		}
	}
8000892a:	2f ed       	sub	sp,-8
8000892c:	e3 cd 80 80 	ldm	sp++,r7,pc
80008930:	00 00       	add	r0,r0
80008932:	0b fc       	ld.ub	r12,r5[0x7]
80008934:	00 00       	add	r0,r0
80008936:	0c 00       	add	r0,r6
80008938:	80 00       	ld.sh	r0,r0[0x0]
8000893a:	6d e6       	ld.w	r6,r6[0x78]
8000893c:	00 00       	add	r0,r0
8000893e:	0d 1c       	ld.sh	r12,r6++
80008940:	80 00       	ld.sh	r0,r0[0x0]
80008942:	6c d2       	ld.w	r2,r6[0x34]

80008944 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80008944:	eb cd 40 80 	pushm	r7,lr
80008948:	1a 97       	mov	r7,sp
8000894a:	20 2d       	sub	sp,8
8000894c:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80008950:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008954:	ef 48 ff fc 	st.w	r7[-4],r8

		if( pxMutexHolder != NULL )
80008958:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000895c:	58 08       	cp.w	r8,0
8000895e:	c3 d0       	breq	800089d8 <vTaskPriorityDisinherit+0x94>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80008960:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008964:	70 b9       	ld.w	r9,r8[0x2c]
80008966:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000896a:	71 18       	ld.w	r8,r8[0x44]
8000896c:	10 39       	cp.w	r9,r8
8000896e:	c3 50       	breq	800089d8 <vTaskPriorityDisinherit+0x94>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80008970:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008974:	2f c8       	sub	r8,-4
80008976:	10 9c       	mov	r12,r8
80008978:	f0 1f 00 1a 	mcall	800089e0 <vTaskPriorityDisinherit+0x9c>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000897c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008980:	71 19       	ld.w	r9,r8[0x44]
80008982:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008986:	91 b9       	st.w	r8[0x2c],r9
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80008988:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000898c:	70 b8       	ld.w	r8,r8[0x2c]
8000898e:	f0 09 11 08 	rsub	r9,r8,8
80008992:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008996:	91 69       	st.w	r8[0x18],r9
				prvAddTaskToReadyQueue( pxTCB );
80008998:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000899c:	70 b9       	ld.w	r9,r8[0x2c]
8000899e:	49 28       	lddpc	r8,800089e4 <vTaskPriorityDisinherit+0xa0>
800089a0:	70 08       	ld.w	r8,r8[0x0]
800089a2:	10 39       	cp.w	r9,r8
800089a4:	e0 88 00 07 	brls	800089b2 <vTaskPriorityDisinherit+0x6e>
800089a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800089ac:	70 b9       	ld.w	r9,r8[0x2c]
800089ae:	48 e8       	lddpc	r8,800089e4 <vTaskPriorityDisinherit+0xa0>
800089b0:	91 09       	st.w	r8[0x0],r9
800089b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800089b6:	f0 ca ff fc 	sub	r10,r8,-4
800089ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800089be:	70 b9       	ld.w	r9,r8[0x2c]
800089c0:	12 98       	mov	r8,r9
800089c2:	a3 68       	lsl	r8,0x2
800089c4:	12 08       	add	r8,r9
800089c6:	a3 68       	lsl	r8,0x2
800089c8:	10 99       	mov	r9,r8
800089ca:	48 88       	lddpc	r8,800089e8 <vTaskPriorityDisinherit+0xa4>
800089cc:	f2 08 00 08 	add	r8,r9,r8
800089d0:	14 9b       	mov	r11,r10
800089d2:	10 9c       	mov	r12,r8
800089d4:	f0 1f 00 06 	mcall	800089ec <vTaskPriorityDisinherit+0xa8>
			}
		}
	}
800089d8:	2f ed       	sub	sp,-8
800089da:	e3 cd 80 80 	ldm	sp++,r7,pc
800089de:	00 00       	add	r0,r0
800089e0:	80 00       	ld.sh	r0,r0[0x0]
800089e2:	6d e6       	ld.w	r6,r6[0x78]
800089e4:	00 00       	add	r0,r0
800089e6:	0d 1c       	ld.sh	r12,r6++
800089e8:	00 00       	add	r0,r0
800089ea:	0c 00       	add	r0,r6
800089ec:	80 00       	ld.sh	r0,r0[0x0]
800089ee:	6c d2       	ld.w	r2,r6[0x34]
800089f0:	4c 4f       	lddpc	pc,80008b00 <PrintDec+0xa0>
800089f2:	47 00       	lddsp	r0,sp[0x1c0]
800089f4:	49 20       	lddpc	r0,80008a3c <PrintChar+0x10>
800089f6:	6e 65       	ld.w	r5,r7[0x18]
800089f8:	65 64       	ld.w	r4,r2[0x58]
800089fa:	20 66       	sub	r6,6
800089fc:	6c 6f       	ld.w	pc,r6[0x18]
800089fe:	61 74       	ld.w	r4,r0[0x5c]
80008a00:	2e 00       	sub	r0,-32
80008a02:	00 00       	add	r0,r0
80008a04:	49 20       	lddpc	r0,80008a4c <PrintChar+0x20>
80008a06:	6e 65       	ld.w	r5,r7[0x18]
80008a08:	65 64       	ld.w	r4,r2[0x58]
80008a0a:	20 72       	sub	r2,7
80008a0c:	65 6c       	ld.w	r12,r2[0x58]
80008a0e:	61 78       	ld.w	r8,r0[0x5c]
80008a10:	2e 00       	sub	r0,-32
80008a12:	00 00       	add	r0,r0
80008a14:	25 73       	sub	r3,87
80008a16:	25 73       	sub	r3,87
80008a18:	00 00       	add	r0,r0
80008a1a:	00 00       	add	r0,r0
80008a1c:	25 73       	sub	r3,87
80008a1e:	25 63       	sub	r3,86
80008a20:	00 00       	add	r0,r0
80008a22:	00 00       	add	r0,r0
80008a24:	25 73       	sub	r3,87
80008a26:	0d 0a       	ld.w	r10,r6++
80008a28:	00 00       	add	r0,r0
	...

80008a2c <PrintChar>:

	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
80008a2c:	eb cd 40 80 	pushm	r7,lr
80008a30:	1a 97       	mov	r7,sp
80008a32:	20 2d       	sub	sp,8
80008a34:	18 98       	mov	r8,r12
80008a36:	ef 4b ff f8 	st.w	r7[-8],r11
80008a3a:	ef 68 ff fc 	st.b	r7[-4],r8
	*str++ = c;
80008a3e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008a42:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80008a46:	b2 88       	st.b	r9[0x0],r8
80008a48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008a4c:	2f f8       	sub	r8,-1
80008a4e:	ef 48 ff f8 	st.w	r7[-8],r8
	return str;
80008a52:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80008a56:	10 9c       	mov	r12,r8
80008a58:	2f ed       	sub	sp,-8
80008a5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80008a5e:	d7 03       	nop

80008a60 <PrintDec>:

char * PrintDec(int i, char len, char * str)
{
80008a60:	eb cd 40 80 	pushm	r7,lr
80008a64:	1a 97       	mov	r7,sp
80008a66:	20 cd       	sub	sp,48
80008a68:	ef 4c ff d8 	st.w	r7[-40],r12
80008a6c:	16 98       	mov	r8,r11
80008a6e:	ef 4a ff d0 	st.w	r7[-48],r10
80008a72:	ef 68 ff d4 	st.b	r7[-44],r8
	char * p = str;
80008a76:	ee f8 ff d0 	ld.w	r8,r7[-48]
80008a7a:	ef 48 ff e8 	st.w	r7[-24],r8
	
	int sign = i>=0 ? 0 : 1;
80008a7e:	ee f8 ff d8 	ld.w	r8,r7[-40]
80008a82:	bf 98       	lsr	r8,0x1f
80008a84:	ef 48 ff ec 	st.w	r7[-20],r8
	char s[10];
	memset(s, 0 , 10);
80008a88:	ee c8 00 24 	sub	r8,r7,36
80008a8c:	30 aa       	mov	r10,10
80008a8e:	30 0b       	mov	r11,0
80008a90:	10 9c       	mov	r12,r8
80008a92:	f0 1f 00 61 	mcall	80008c14 <PrintDec+0x1b4>
	int cnt=0;
80008a96:	30 08       	mov	r8,0
80008a98:	ef 48 ff f0 	st.w	r7[-16],r8
	if(sign)
80008a9c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008aa0:	58 08       	cp.w	r8,0
80008aa2:	c0 f0       	breq	80008ac0 <PrintDec+0x60>
	{
		*p++ = '-';
80008aa4:	ee f9 ff e8 	ld.w	r9,r7[-24]
80008aa8:	32 d8       	mov	r8,45
80008aaa:	b2 88       	st.b	r9[0x0],r8
80008aac:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008ab0:	2f f8       	sub	r8,-1
80008ab2:	ef 48 ff e8 	st.w	r7[-24],r8
		i = -i;
80008ab6:	ee f8 ff d8 	ld.w	r8,r7[-40]
80008aba:	5c 38       	neg	r8
80008abc:	ef 48 ff d8 	st.w	r7[-40],r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80008ac0:	ee f8 ff d8 	ld.w	r8,r7[-40]
80008ac4:	58 08       	cp.w	r8,0
80008ac6:	c0 d1       	brne	80008ae0 <PrintDec+0x80>
80008ac8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008acc:	ee 08 00 09 	add	r9,r7,r8
80008ad0:	33 08       	mov	r8,48
80008ad2:	f3 68 ff dc 	st.b	r9[-36],r8
80008ad6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008ada:	2f f8       	sub	r8,-1
80008adc:	ef 48 ff f0 	st.w	r7[-16],r8
	
	int ten = i%10;
80008ae0:	ee f9 ff d8 	ld.w	r9,r7[-40]
80008ae4:	e0 68 66 67 	mov	r8,26215
80008ae8:	ea 18 66 66 	orh	r8,0x6666
80008aec:	f2 08 04 4a 	muls.d	r10,r9,r8
80008af0:	f6 0a 14 02 	asr	r10,r11,0x2
80008af4:	f2 08 14 1f 	asr	r8,r9,0x1f
80008af8:	10 1a       	sub	r10,r8
80008afa:	14 98       	mov	r8,r10
80008afc:	a3 68       	lsl	r8,0x2
80008afe:	14 08       	add	r8,r10
80008b00:	a1 78       	lsl	r8,0x1
80008b02:	f2 08 01 08 	sub	r8,r9,r8
80008b06:	ef 48 ff f4 	st.w	r7[-12],r8
	while(i)
80008b0a:	c3 58       	rjmp	80008b74 <PrintDec+0x114>
	{
		s[cnt] = ten+'0';
80008b0c:	ee f9 ff f0 	ld.w	r9,r7[-16]
80008b10:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008b14:	5c 58       	castu.b	r8
80008b16:	2d 08       	sub	r8,-48
80008b18:	5c 58       	castu.b	r8
80008b1a:	ee 09 00 09 	add	r9,r7,r9
80008b1e:	f3 68 ff dc 	st.b	r9[-36],r8
		cnt++;
80008b22:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008b26:	2f f8       	sub	r8,-1
80008b28:	ef 48 ff f0 	st.w	r7[-16],r8
		i /= 10;
80008b2c:	ee fa ff d8 	ld.w	r10,r7[-40]
80008b30:	e0 68 66 67 	mov	r8,26215
80008b34:	ea 18 66 66 	orh	r8,0x6666
80008b38:	f4 08 04 48 	muls.d	r8,r10,r8
80008b3c:	a3 49       	asr	r9,0x2
80008b3e:	f4 08 14 1f 	asr	r8,r10,0x1f
80008b42:	f2 08 01 08 	sub	r8,r9,r8
80008b46:	ef 48 ff d8 	st.w	r7[-40],r8
		ten = i%10;
80008b4a:	ee f9 ff d8 	ld.w	r9,r7[-40]
80008b4e:	e0 68 66 67 	mov	r8,26215
80008b52:	ea 18 66 66 	orh	r8,0x6666
80008b56:	f2 08 04 4a 	muls.d	r10,r9,r8
80008b5a:	f6 0a 14 02 	asr	r10,r11,0x2
80008b5e:	f2 08 14 1f 	asr	r8,r9,0x1f
80008b62:	10 1a       	sub	r10,r8
80008b64:	14 98       	mov	r8,r10
80008b66:	a3 68       	lsl	r8,0x2
80008b68:	14 08       	add	r8,r10
80008b6a:	a1 78       	lsl	r8,0x1
80008b6c:	f2 08 01 08 	sub	r8,r9,r8
80008b70:	ef 48 ff f4 	st.w	r7[-12],r8
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80008b74:	ee f8 ff d8 	ld.w	r8,r7[-40]
80008b78:	58 08       	cp.w	r8,0
80008b7a:	cc 91       	brne	80008b0c <PrintDec+0xac>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80008b7c:	ef 39 ff d4 	ld.ub	r9,r7[-44]
80008b80:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008b84:	f2 08 01 08 	sub	r8,r9,r8
80008b88:	58 08       	cp.w	r8,0
80008b8a:	e0 8a 00 3a 	brle	80008bfe <PrintDec+0x19e>
	{
		char num = len - cnt;
80008b8e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008b92:	5c 58       	castu.b	r8
80008b94:	ef 39 ff d4 	ld.ub	r9,r7[-44]
80008b98:	10 19       	sub	r9,r8
80008b9a:	ef 69 ff fb 	st.b	r7[-5],r9
		for(int i = 0; i < num; i++)
80008b9e:	30 08       	mov	r8,0
80008ba0:	ef 48 ff fc 	st.w	r7[-4],r8
80008ba4:	c1 28       	rjmp	80008bc8 <PrintDec+0x168>
		{
			s[cnt++] = '0';
80008ba6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008baa:	ee 08 00 09 	add	r9,r7,r8
80008bae:	33 08       	mov	r8,48
80008bb0:	f3 68 ff dc 	st.b	r9[-36],r8
80008bb4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008bb8:	2f f8       	sub	r8,-1
80008bba:	ef 48 ff f0 	st.w	r7[-16],r8
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80008bbe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bc2:	2f f8       	sub	r8,-1
80008bc4:	ef 48 ff fc 	st.w	r7[-4],r8
80008bc8:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80008bcc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008bd0:	10 39       	cp.w	r9,r8
80008bd2:	fe 99 ff ea 	brgt	80008ba6 <PrintDec+0x146>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80008bd6:	c1 48       	rjmp	80008bfe <PrintDec+0x19e>
	*p++ = s[--cnt];
80008bd8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008bdc:	20 18       	sub	r8,1
80008bde:	ef 48 ff f0 	st.w	r7[-16],r8
80008be2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008be6:	ee 08 00 08 	add	r8,r7,r8
80008bea:	f1 38 ff dc 	ld.ub	r8,r8[-36]
80008bee:	ee f9 ff e8 	ld.w	r9,r7[-24]
80008bf2:	b2 88       	st.b	r9[0x0],r8
80008bf4:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008bf8:	2f f8       	sub	r8,-1
80008bfa:	ef 48 ff e8 	st.w	r7[-24],r8
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80008bfe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008c02:	58 08       	cp.w	r8,0
80008c04:	fe 99 ff ea 	brgt	80008bd8 <PrintDec+0x178>
	*p++ = s[--cnt];
	
	return str;
80008c08:	ee f8 ff d0 	ld.w	r8,r7[-48]
}
80008c0c:	10 9c       	mov	r12,r8
80008c0e:	2f 4d       	sub	sp,-48
80008c10:	e3 cd 80 80 	ldm	sp++,r7,pc
80008c14:	80 00       	ld.sh	r0,r0[0x0]
80008c16:	98 d0       	ld.uh	r0,r12[0xa]

80008c18 <PrintHex>:

char * PrintHex(int i,char len, char * str)
{
80008c18:	eb cd 40 80 	pushm	r7,lr
80008c1c:	1a 97       	mov	r7,sp
80008c1e:	20 ad       	sub	sp,40
80008c20:	ef 4c ff e0 	st.w	r7[-32],r12
80008c24:	16 98       	mov	r8,r11
80008c26:	ef 4a ff d8 	st.w	r7[-40],r10
80008c2a:	ef 68 ff dc 	st.b	r7[-36],r8
	char * p = str;
80008c2e:	ee f8 ff d8 	ld.w	r8,r7[-40]
80008c32:	ef 48 ff f0 	st.w	r7[-16],r8
	char s[12];
	memset(s, 0 , 12);
80008c36:	ee c8 00 1c 	sub	r8,r7,28
80008c3a:	30 ca       	mov	r10,12
80008c3c:	30 0b       	mov	r11,0
80008c3e:	10 9c       	mov	r12,r8
80008c40:	f0 1f 00 53 	mcall	80008d8c <PrintHex+0x174>
	int cnt=0;
80008c44:	30 08       	mov	r8,0
80008c46:	ef 48 ff f4 	st.w	r7[-12],r8
	
	if(i)
80008c4a:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008c4e:	58 08       	cp.w	r8,0
80008c50:	c2 d0       	breq	80008caa <PrintHex+0x92>
	while(i)
80008c52:	c2 78       	rjmp	80008ca0 <PrintHex+0x88>
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80008c54:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008c58:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008c5c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80008c60:	58 98       	cp.w	r8,9
80008c62:	e0 8a 00 0a 	brle	80008c76 <PrintHex+0x5e>
80008c66:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008c6a:	5c 58       	castu.b	r8
80008c6c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80008c70:	2c 98       	sub	r8,-55
80008c72:	5c 58       	castu.b	r8
80008c74:	c0 88       	rjmp	80008c84 <PrintHex+0x6c>
80008c76:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008c7a:	5c 58       	castu.b	r8
80008c7c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80008c80:	2d 08       	sub	r8,-48
80008c82:	5c 58       	castu.b	r8
80008c84:	ee 09 00 09 	add	r9,r7,r9
80008c88:	f3 68 ff e4 	st.b	r9[-28],r8
80008c8c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008c90:	2f f8       	sub	r8,-1
80008c92:	ef 48 ff f4 	st.w	r7[-12],r8
		i = (i >> 4 ) & 0x0FFFFFFF;
80008c96:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008c9a:	a5 88       	lsr	r8,0x4
80008c9c:	ef 48 ff e0 	st.w	r7[-32],r8
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80008ca0:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008ca4:	58 08       	cp.w	r8,0
80008ca6:	cd 71       	brne	80008c54 <PrintHex+0x3c>
80008ca8:	c0 d8       	rjmp	80008cc2 <PrintHex+0xaa>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80008caa:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008cae:	ee 08 00 09 	add	r9,r7,r8
80008cb2:	33 08       	mov	r8,48
80008cb4:	f3 68 ff e4 	st.b	r9[-28],r8
80008cb8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008cbc:	2f f8       	sub	r8,-1
80008cbe:	ef 48 ff f4 	st.w	r7[-12],r8
	
	if(len - cnt > 0 )
80008cc2:	ef 39 ff dc 	ld.ub	r9,r7[-36]
80008cc6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008cca:	f2 08 01 08 	sub	r8,r9,r8
80008cce:	58 08       	cp.w	r8,0
80008cd0:	e0 8a 00 26 	brle	80008d1c <PrintHex+0x104>
	{
		char num = len - cnt;
80008cd4:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008cd8:	5c 58       	castu.b	r8
80008cda:	ef 39 ff dc 	ld.ub	r9,r7[-36]
80008cde:	10 19       	sub	r9,r8
80008ce0:	ef 69 ff fb 	st.b	r7[-5],r9
		for(int i = 0; i < num; i++)
80008ce4:	30 08       	mov	r8,0
80008ce6:	ef 48 ff fc 	st.w	r7[-4],r8
80008cea:	c1 28       	rjmp	80008d0e <PrintHex+0xf6>
		{
			s[cnt++] = '0';
80008cec:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008cf0:	ee 08 00 09 	add	r9,r7,r8
80008cf4:	33 08       	mov	r8,48
80008cf6:	f3 68 ff e4 	st.b	r9[-28],r8
80008cfa:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008cfe:	2f f8       	sub	r8,-1
80008d00:	ef 48 ff f4 	st.w	r7[-12],r8
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80008d04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008d08:	2f f8       	sub	r8,-1
80008d0a:	ef 48 ff fc 	st.w	r7[-4],r8
80008d0e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80008d12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008d16:	10 39       	cp.w	r9,r8
80008d18:	fe 99 ff ea 	brgt	80008cec <PrintHex+0xd4>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80008d1c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008d20:	ee 08 00 09 	add	r9,r7,r8
80008d24:	37 88       	mov	r8,120
80008d26:	f3 68 ff e4 	st.b	r9[-28],r8
80008d2a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008d2e:	2f f8       	sub	r8,-1
80008d30:	ef 48 ff f4 	st.w	r7[-12],r8
	s[cnt++] = '0';
80008d34:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008d38:	ee 08 00 09 	add	r9,r7,r8
80008d3c:	33 08       	mov	r8,48
80008d3e:	f3 68 ff e4 	st.b	r9[-28],r8
80008d42:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008d46:	2f f8       	sub	r8,-1
80008d48:	ef 48 ff f4 	st.w	r7[-12],r8
	
	while(cnt>0)
80008d4c:	c1 48       	rjmp	80008d74 <PrintHex+0x15c>
	*p++ = s[--cnt];
80008d4e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008d52:	20 18       	sub	r8,1
80008d54:	ef 48 ff f4 	st.w	r7[-12],r8
80008d58:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008d5c:	ee 08 00 08 	add	r8,r7,r8
80008d60:	f1 38 ff e4 	ld.ub	r8,r8[-28]
80008d64:	ee f9 ff f0 	ld.w	r9,r7[-16]
80008d68:	b2 88       	st.b	r9[0x0],r8
80008d6a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008d6e:	2f f8       	sub	r8,-1
80008d70:	ef 48 ff f0 	st.w	r7[-16],r8
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80008d74:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008d78:	58 08       	cp.w	r8,0
80008d7a:	fe 99 ff ea 	brgt	80008d4e <PrintHex+0x136>
	*p++ = s[--cnt];
		
	return str;
80008d7e:	ee f8 ff d8 	ld.w	r8,r7[-40]
}
80008d82:	10 9c       	mov	r12,r8
80008d84:	2f 6d       	sub	sp,-40
80008d86:	e3 cd 80 80 	ldm	sp++,r7,pc
80008d8a:	00 00       	add	r0,r0
80008d8c:	80 00       	ld.sh	r0,r0[0x0]
80008d8e:	98 d0       	ld.uh	r0,r12[0xa]

80008d90 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80008d90:	eb cd 40 c0 	pushm	r6-r7,lr
80008d94:	1a 97       	mov	r7,sp
80008d96:	fa cd 02 28 	sub	sp,sp,552
80008d9a:	ee c6 ff f4 	sub	r6,r7,-12
80008d9e:	ef 4c fd d8 	st.w	r7[-552],r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80008da2:	ee c8 01 1c 	sub	r8,r7,284
80008da6:	e0 6a 01 00 	mov	r10,256
80008daa:	30 0b       	mov	r11,0
80008dac:	10 9c       	mov	r12,r8
80008dae:	f0 1f 00 84 	mcall	80008fbc <log+0x22c>
	
	int len = 0 ;
80008db2:	30 08       	mov	r8,0
80008db4:	ef 48 ff e4 	st.w	r7[-28],r8
	

	va_list arg_ptr;
	char* str = content;
80008db8:	ee f8 fd d8 	ld.w	r8,r7[-552]
80008dbc:	ef 48 ff e8 	st.w	r7[-24],r8
	int x;
	char y;
	float f;
	//char* s;
	char length= 0;
80008dc0:	30 08       	mov	r8,0
80008dc2:	ef 68 ff fb 	st.b	r7[-5],r8
		
	va_start(arg_ptr, content);
80008dc6:	ec c8 00 00 	sub	r8,r6,0
80008dca:	ef 48 fe e0 	st.w	r7[-288],r8
		//str += 4;
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
80008dce:	ee c8 02 24 	sub	r8,r7,548
80008dd2:	ef 48 ff fc 	st.w	r7[-4],r8
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80008dd6:	e0 6a 01 00 	mov	r10,256
80008dda:	30 0b       	mov	r11,0
80008ddc:	ee fc ff fc 	ld.w	r12,r7[-4]
80008de0:	f0 1f 00 77 	mcall	80008fbc <log+0x22c>
			
					if(*str == '%')
80008de4:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008de8:	11 89       	ld.ub	r9,r8[0x0]
80008dea:	32 58       	mov	r8,37
80008dec:	f0 09 18 00 	cp.b	r9,r8
80008df0:	e0 81 00 9a 	brne	80008f24 <log+0x194>
					{
						static char lench = 0;
						lench =*(str + 1);
80008df4:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008df8:	2f f8       	sub	r8,-1
80008dfa:	11 88       	ld.ub	r8,r8[0x0]
80008dfc:	4f 19       	lddpc	r9,80008fc0 <log+0x230>
80008dfe:	b2 88       	st.b	r9[0x0],r8
						if((lench >= '0') &&  (lench <= '9'))
80008e00:	4f 08       	lddpc	r8,80008fc0 <log+0x230>
80008e02:	11 89       	ld.ub	r9,r8[0x0]
80008e04:	32 f8       	mov	r8,47
80008e06:	f0 09 18 00 	cp.b	r9,r8
80008e0a:	e0 88 00 14 	brls	80008e32 <log+0xa2>
80008e0e:	4e d8       	lddpc	r8,80008fc0 <log+0x230>
80008e10:	11 89       	ld.ub	r9,r8[0x0]
80008e12:	33 98       	mov	r8,57
80008e14:	f0 09 18 00 	cp.b	r9,r8
80008e18:	e0 8b 00 0d 	brhi	80008e32 <log+0xa2>
						{
							len = *(++str) - '0';
80008e1c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008e20:	2f f8       	sub	r8,-1
80008e22:	ef 48 ff e8 	st.w	r7[-24],r8
80008e26:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008e2a:	11 88       	ld.ub	r8,r8[0x0]
80008e2c:	23 08       	sub	r8,48
80008e2e:	ef 48 ff e4 	st.w	r7[-28],r8
						}
						
						str++;
80008e32:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008e36:	2f f8       	sub	r8,-1
80008e38:	ef 48 ff e8 	st.w	r7[-24],r8
						
						switch(*(str))
80008e3c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008e40:	11 88       	ld.ub	r8,r8[0x0]
80008e42:	22 58       	sub	r8,37
80008e44:	e0 48 00 53 	cp.w	r8,83
80008e48:	e0 8b 00 55 	brhi	80008ef2 <log+0x162>
80008e4c:	4d e9       	lddpc	r9,80008fc4 <log+0x234>
80008e4e:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80008e52:	ee f8 fe e0 	ld.w	r8,r7[-288]
80008e56:	f0 c9 ff fc 	sub	r9,r8,-4
80008e5a:	ef 49 fe e0 	st.w	r7[-288],r9
80008e5e:	70 08       	ld.w	r8,r8[0x0]
80008e60:	ef 48 ff ec 	st.w	r7[-20],r8
							strTmp = PrintDec(x, len, strTmp);
80008e64:	ee f8 ff e4 	ld.w	r8,r7[-28]
80008e68:	5c 58       	castu.b	r8
80008e6a:	ee fa ff fc 	ld.w	r10,r7[-4]
80008e6e:	10 9b       	mov	r11,r8
80008e70:	ee fc ff ec 	ld.w	r12,r7[-20]
80008e74:	f0 1f 00 55 	mcall	80008fc8 <log+0x238>
80008e78:	18 98       	mov	r8,r12
80008e7a:	ef 48 ff fc 	st.w	r7[-4],r8
							break;
80008e7e:	c3 d8       	rjmp	80008ef8 <log+0x168>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80008e80:	4d 3c       	lddpc	r12,80008fcc <log+0x23c>
80008e82:	f0 1f 00 54 	mcall	80008fd0 <log+0x240>
							break;
80008e86:	c3 98       	rjmp	80008ef8 <log+0x168>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80008e88:	ee f8 fe e0 	ld.w	r8,r7[-288]
80008e8c:	f0 c9 ff fc 	sub	r9,r8,-4
80008e90:	ef 49 fe e0 	st.w	r7[-288],r9
80008e94:	70 08       	ld.w	r8,r8[0x0]
80008e96:	ef 48 ff ec 	st.w	r7[-20],r8
							PrintHex(x,len, strTmp);
80008e9a:	ee f8 ff e4 	ld.w	r8,r7[-28]
80008e9e:	5c 58       	castu.b	r8
80008ea0:	ee fa ff fc 	ld.w	r10,r7[-4]
80008ea4:	10 9b       	mov	r11,r8
80008ea6:	ee fc ff ec 	ld.w	r12,r7[-20]
80008eaa:	f0 1f 00 4b 	mcall	80008fd4 <log+0x244>
							break;
80008eae:	c2 58       	rjmp	80008ef8 <log+0x168>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80008eb0:	ee f8 fe e0 	ld.w	r8,r7[-288]
80008eb4:	f0 c9 ff fc 	sub	r9,r8,-4
80008eb8:	ef 49 fe e0 	st.w	r7[-288],r9
80008ebc:	70 08       	ld.w	r8,r8[0x0]
80008ebe:	ef 68 ff f3 	st.b	r7[-13],r8
							PrintChar(y, strTmp);
80008ec2:	ef 38 ff f3 	ld.ub	r8,r7[-13]
80008ec6:	ee fb ff fc 	ld.w	r11,r7[-4]
80008eca:	10 9c       	mov	r12,r8
80008ecc:	f0 1f 00 43 	mcall	80008fd8 <log+0x248>
							break;
80008ed0:	c1 48       	rjmp	80008ef8 <log+0x168>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80008ed2:	ee f8 fe e0 	ld.w	r8,r7[-288]
80008ed6:	f0 c9 ff fc 	sub	r9,r8,-4
80008eda:	ef 49 fe e0 	st.w	r7[-288],r9
80008ede:	70 08       	ld.w	r8,r8[0x0]
80008ee0:	ef 48 ff fc 	st.w	r7[-4],r8
							//PrintStr(s);
							break;
80008ee4:	c0 a8       	rjmp	80008ef8 <log+0x168>
							
							case('%'):
							PrintChar('%', strTmp);
80008ee6:	ee fb ff fc 	ld.w	r11,r7[-4]
80008eea:	32 5c       	mov	r12,37
80008eec:	f0 1f 00 3b 	mcall	80008fd8 <log+0x248>
							//PrintChar('%');
							break;
80008ef0:	c0 48       	rjmp	80008ef8 <log+0x168>
							
							default:
							log("I need relax.");
80008ef2:	4b bc       	lddpc	r12,80008fdc <log+0x24c>
80008ef4:	f0 1f 00 37 	mcall	80008fd0 <log+0x240>
						}
						str++;
80008ef8:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008efc:	2f f8       	sub	r8,-1
80008efe:	ef 48 ff e8 	st.w	r7[-24],r8
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80008f02:	ee c8 01 1c 	sub	r8,r7,284
80008f06:	ee f9 ff fc 	ld.w	r9,r7[-4]
80008f0a:	1a d9       	st.w	--sp,r9
80008f0c:	ee c9 01 1c 	sub	r9,r7,284
80008f10:	1a d9       	st.w	--sp,r9
80008f12:	4b 4b       	lddpc	r11,80008fe0 <log+0x250>
80008f14:	10 9c       	mov	r12,r8
80008f16:	f0 1f 00 34 	mcall	80008fe4 <log+0x254>
80008f1a:	2f ed       	sub	sp,-8
80008f1c:	18 98       	mov	r8,r12
80008f1e:	ef 68 ff fb 	st.b	r7[-5],r8
80008f22:	c1 88       	rjmp	80008f52 <log+0x1c2>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80008f24:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008f28:	11 88       	ld.ub	r8,r8[0x0]
80008f2a:	10 99       	mov	r9,r8
80008f2c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008f30:	2f f8       	sub	r8,-1
80008f32:	ef 48 ff e8 	st.w	r7[-24],r8
80008f36:	ee c8 01 1c 	sub	r8,r7,284
80008f3a:	1a d9       	st.w	--sp,r9
80008f3c:	ee c9 01 1c 	sub	r9,r7,284
80008f40:	1a d9       	st.w	--sp,r9
80008f42:	4a ab       	lddpc	r11,80008fe8 <log+0x258>
80008f44:	10 9c       	mov	r12,r8
80008f46:	f0 1f 00 28 	mcall	80008fe4 <log+0x254>
80008f4a:	2f ed       	sub	sp,-8
80008f4c:	18 98       	mov	r8,r12
80008f4e:	ef 68 ff fb 	st.b	r7[-5],r8
			
			
			
	}while(*str != '\0');
80008f52:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008f56:	11 88       	ld.ub	r8,r8[0x0]
80008f58:	58 08       	cp.w	r8,0
80008f5a:	fe 91 ff 3a 	brne	80008dce <log+0x3e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80008f5e:	ee c8 01 1c 	sub	r8,r7,284
80008f62:	ee c9 01 1c 	sub	r9,r7,284
80008f66:	1a d9       	st.w	--sp,r9
80008f68:	4a 1b       	lddpc	r11,80008fec <log+0x25c>
80008f6a:	10 9c       	mov	r12,r8
80008f6c:	f0 1f 00 1e 	mcall	80008fe4 <log+0x254>
80008f70:	2f fd       	sub	sp,-4
80008f72:	18 98       	mov	r8,r12
80008f74:	ef 68 ff fb 	st.b	r7[-5],r8
	
	char * p = pvPortMalloc(length+1);
80008f78:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80008f7c:	2f f8       	sub	r8,-1
80008f7e:	10 9c       	mov	r12,r8
80008f80:	f0 1f 00 1c 	mcall	80008ff0 <log+0x260>
80008f84:	18 98       	mov	r8,r12
80008f86:	ef 48 fe dc 	st.w	r7[-292],r8
	memcpy(p, logTmp, length+1);
80008f8a:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80008f8e:	2f f8       	sub	r8,-1
80008f90:	10 9a       	mov	r10,r8
80008f92:	ee f8 fe dc 	ld.w	r8,r7[-292]
80008f96:	ee c9 01 1c 	sub	r9,r7,284
80008f9a:	12 9b       	mov	r11,r9
80008f9c:	10 9c       	mov	r12,r8
80008f9e:	f0 1f 00 16 	mcall	80008ff4 <log+0x264>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80008fa2:	49 68       	lddpc	r8,80008ff8 <log+0x268>
80008fa4:	70 08       	ld.w	r8,r8[0x0]
80008fa6:	ee cb 01 24 	sub	r11,r7,292
80008faa:	30 09       	mov	r9,0
80008fac:	30 5a       	mov	r10,5
80008fae:	10 9c       	mov	r12,r8
80008fb0:	f0 1f 00 13 	mcall	80008ffc <log+0x26c>
	
	
}
80008fb4:	fe 3d fd d8 	sub	sp,-552
80008fb8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008fbc:	80 00       	ld.sh	r0,r0[0x0]
80008fbe:	98 d0       	ld.uh	r0,r12[0xa]
80008fc0:	00 00       	add	r0,r0
80008fc2:	0d 39       	ld.ub	r9,r6++
80008fc4:	80 00       	ld.sh	r0,r0[0x0]
80008fc6:	f1 24 80 00 	ld.sb	r4,r8[-32768]
80008fca:	8a 60       	ld.sh	r0,r5[0xc]
80008fcc:	80 00       	ld.sh	r0,r0[0x0]
80008fce:	89 f4       	st.w	r4[0x3c],r4
80008fd0:	80 00       	ld.sh	r0,r0[0x0]
80008fd2:	8d 90       	st.w	r6[0x24],r0
80008fd4:	80 00       	ld.sh	r0,r0[0x0]
80008fd6:	8c 18       	ld.sh	r8,r6[0x2]
80008fd8:	80 00       	ld.sh	r0,r0[0x0]
80008fda:	8a 2c       	ld.sh	r12,r5[0x4]
80008fdc:	80 00       	ld.sh	r0,r0[0x0]
80008fde:	8a 04       	ld.sh	r4,r5[0x0]
80008fe0:	80 00       	ld.sh	r0,r0[0x0]
80008fe2:	8a 14       	ld.sh	r4,r5[0x2]
80008fe4:	80 00       	ld.sh	r0,r0[0x0]
80008fe6:	9b c0       	st.w	sp[0x30],r0
80008fe8:	80 00       	ld.sh	r0,r0[0x0]
80008fea:	8a 1c       	ld.sh	r12,r5[0x2]
80008fec:	80 00       	ld.sh	r0,r0[0x0]
80008fee:	8a 24       	ld.sh	r4,r5[0x4]
80008ff0:	80 00       	ld.sh	r0,r0[0x0]
80008ff2:	73 4c       	ld.w	r12,r9[0x50]
80008ff4:	80 00       	ld.sh	r0,r0[0x0]
80008ff6:	97 88       	st.w	r11[0x20],r8
80008ff8:	00 00       	add	r0,r0
80008ffa:	40 f0       	lddsp	r0,sp[0x3c]
80008ffc:	80 00       	ld.sh	r0,r0[0x0]
80008ffe:	74 d8       	ld.w	r8,r10[0x34]

80009000 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80009000:	eb cd 40 c0 	pushm	r6-r7,lr
80009004:	1a 97       	mov	r7,sp
80009006:	fa cd 02 24 	sub	sp,sp,548
8000900a:	ee c6 ff f4 	sub	r6,r7,-12
8000900e:	ef 4c fd dc 	st.w	r7[-548],r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80009012:	ee c8 01 14 	sub	r8,r7,276
80009016:	e0 6a 01 00 	mov	r10,256
8000901a:	30 0b       	mov	r11,0
8000901c:	10 9c       	mov	r12,r8
8000901e:	f0 1f 00 84 	mcall	8000922c <logFromISR+0x22c>
		
		int len = 0 ;
80009022:	30 08       	mov	r8,0
80009024:	ef 48 ff ec 	st.w	r7[-20],r8
		

		va_list arg_ptr;
		char* str = content;
80009028:	ee f8 fd dc 	ld.w	r8,r7[-548]
8000902c:	ef 48 ff f0 	st.w	r7[-16],r8
		int x;
		char y;
		//char* s;
		char length= 0;
80009030:	30 08       	mov	r8,0
80009032:	ef 68 ff fb 	st.b	r7[-5],r8
		
		va_start(arg_ptr, content);
80009036:	ec c8 00 00 	sub	r8,r6,0
8000903a:	ef 48 fe e8 	st.w	r7[-280],r8
		//str += 4;
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
8000903e:	ee c8 02 20 	sub	r8,r7,544
80009042:	ef 48 ff fc 	st.w	r7[-4],r8
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009046:	e0 6a 01 00 	mov	r10,256
8000904a:	30 0b       	mov	r11,0
8000904c:	ee fc ff fc 	ld.w	r12,r7[-4]
80009050:	f0 1f 00 77 	mcall	8000922c <logFromISR+0x22c>
			
			if(*str == '%')
80009054:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009058:	11 89       	ld.ub	r9,r8[0x0]
8000905a:	32 58       	mov	r8,37
8000905c:	f0 09 18 00 	cp.b	r9,r8
80009060:	e0 81 00 96 	brne	8000918c <logFromISR+0x18c>
			{
				static char lench = 0;
				lench =*(str + 1);
80009064:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009068:	2f f8       	sub	r8,-1
8000906a:	11 88       	ld.ub	r8,r8[0x0]
8000906c:	4f 19       	lddpc	r9,80009230 <logFromISR+0x230>
8000906e:	b2 88       	st.b	r9[0x0],r8
				if((lench >= '0') &&  (lench <= '9'))
80009070:	4f 08       	lddpc	r8,80009230 <logFromISR+0x230>
80009072:	11 89       	ld.ub	r9,r8[0x0]
80009074:	32 f8       	mov	r8,47
80009076:	f0 09 18 00 	cp.b	r9,r8
8000907a:	e0 88 00 14 	brls	800090a2 <logFromISR+0xa2>
8000907e:	4e d8       	lddpc	r8,80009230 <logFromISR+0x230>
80009080:	11 89       	ld.ub	r9,r8[0x0]
80009082:	33 98       	mov	r8,57
80009084:	f0 09 18 00 	cp.b	r9,r8
80009088:	e0 8b 00 0d 	brhi	800090a2 <logFromISR+0xa2>
				{
					len = *(++str) - '0';
8000908c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009090:	2f f8       	sub	r8,-1
80009092:	ef 48 ff f0 	st.w	r7[-16],r8
80009096:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000909a:	11 88       	ld.ub	r8,r8[0x0]
8000909c:	23 08       	sub	r8,48
8000909e:	ef 48 ff ec 	st.w	r7[-20],r8
				}
				
				str++;
800090a2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800090a6:	2f f8       	sub	r8,-1
800090a8:	ef 48 ff f0 	st.w	r7[-16],r8
				
				switch(*(str))
800090ac:	ee f8 ff f0 	ld.w	r8,r7[-16]
800090b0:	11 88       	ld.ub	r8,r8[0x0]
800090b2:	22 58       	sub	r8,37
800090b4:	e0 48 00 53 	cp.w	r8,83
800090b8:	e0 8b 00 51 	brhi	8000915a <logFromISR+0x15a>
800090bc:	4d e9       	lddpc	r9,80009234 <logFromISR+0x234>
800090be:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
800090c2:	ee f8 fe e8 	ld.w	r8,r7[-280]
800090c6:	f0 c9 ff fc 	sub	r9,r8,-4
800090ca:	ef 49 fe e8 	st.w	r7[-280],r9
800090ce:	70 08       	ld.w	r8,r8[0x0]
800090d0:	ef 48 ff f4 	st.w	r7[-12],r8
					strTmp = PrintDec(x, len, strTmp);
800090d4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800090d8:	5c 58       	castu.b	r8
800090da:	ee fa ff fc 	ld.w	r10,r7[-4]
800090de:	10 9b       	mov	r11,r8
800090e0:	ee fc ff f4 	ld.w	r12,r7[-12]
800090e4:	f0 1f 00 55 	mcall	80009238 <logFromISR+0x238>
800090e8:	18 98       	mov	r8,r12
800090ea:	ef 48 ff fc 	st.w	r7[-4],r8
					break;
800090ee:	c3 98       	rjmp	80009160 <logFromISR+0x160>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800090f0:	ee f8 fe e8 	ld.w	r8,r7[-280]
800090f4:	f0 c9 ff fc 	sub	r9,r8,-4
800090f8:	ef 49 fe e8 	st.w	r7[-280],r9
800090fc:	70 08       	ld.w	r8,r8[0x0]
800090fe:	ef 48 ff f4 	st.w	r7[-12],r8
					PrintHex(x,len, strTmp);
80009102:	ee f8 ff ec 	ld.w	r8,r7[-20]
80009106:	5c 58       	castu.b	r8
80009108:	ee fa ff fc 	ld.w	r10,r7[-4]
8000910c:	10 9b       	mov	r11,r8
8000910e:	ee fc ff f4 	ld.w	r12,r7[-12]
80009112:	f0 1f 00 4b 	mcall	8000923c <logFromISR+0x23c>
					break;
80009116:	c2 58       	rjmp	80009160 <logFromISR+0x160>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80009118:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000911c:	f0 c9 ff fc 	sub	r9,r8,-4
80009120:	ef 49 fe e8 	st.w	r7[-280],r9
80009124:	70 08       	ld.w	r8,r8[0x0]
80009126:	ef 68 ff fa 	st.b	r7[-6],r8
					PrintChar(y, strTmp);
8000912a:	ef 38 ff fa 	ld.ub	r8,r7[-6]
8000912e:	ee fb ff fc 	ld.w	r11,r7[-4]
80009132:	10 9c       	mov	r12,r8
80009134:	f0 1f 00 43 	mcall	80009240 <logFromISR+0x240>
					break;
80009138:	c1 48       	rjmp	80009160 <logFromISR+0x160>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000913a:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000913e:	f0 c9 ff fc 	sub	r9,r8,-4
80009142:	ef 49 fe e8 	st.w	r7[-280],r9
80009146:	70 08       	ld.w	r8,r8[0x0]
80009148:	ef 48 ff fc 	st.w	r7[-4],r8
					//PrintStr(s);
					break;
8000914c:	c0 a8       	rjmp	80009160 <logFromISR+0x160>
					case('%'):
					PrintChar('%', strTmp);
8000914e:	ee fb ff fc 	ld.w	r11,r7[-4]
80009152:	32 5c       	mov	r12,37
80009154:	f0 1f 00 3b 	mcall	80009240 <logFromISR+0x240>
					//PrintChar('%');
					break;
80009158:	c0 48       	rjmp	80009160 <logFromISR+0x160>
					default:
					log("I need relax.");
8000915a:	4b bc       	lddpc	r12,80009244 <logFromISR+0x244>
8000915c:	f0 1f 00 3b 	mcall	80009248 <logFromISR+0x248>
				}
				str++;
80009160:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009164:	2f f8       	sub	r8,-1
80009166:	ef 48 ff f0 	st.w	r7[-16],r8
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000916a:	ee c8 01 14 	sub	r8,r7,276
8000916e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009172:	1a d9       	st.w	--sp,r9
80009174:	ee c9 01 14 	sub	r9,r7,276
80009178:	1a d9       	st.w	--sp,r9
8000917a:	4b 5b       	lddpc	r11,8000924c <logFromISR+0x24c>
8000917c:	10 9c       	mov	r12,r8
8000917e:	f0 1f 00 35 	mcall	80009250 <logFromISR+0x250>
80009182:	2f ed       	sub	sp,-8
80009184:	18 98       	mov	r8,r12
80009186:	ef 68 ff fb 	st.b	r7[-5],r8
8000918a:	c1 88       	rjmp	800091ba <logFromISR+0x1ba>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000918c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009190:	11 88       	ld.ub	r8,r8[0x0]
80009192:	10 99       	mov	r9,r8
80009194:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009198:	2f f8       	sub	r8,-1
8000919a:	ef 48 ff f0 	st.w	r7[-16],r8
8000919e:	ee c8 01 14 	sub	r8,r7,276
800091a2:	1a d9       	st.w	--sp,r9
800091a4:	ee c9 01 14 	sub	r9,r7,276
800091a8:	1a d9       	st.w	--sp,r9
800091aa:	4a bb       	lddpc	r11,80009254 <logFromISR+0x254>
800091ac:	10 9c       	mov	r12,r8
800091ae:	f0 1f 00 29 	mcall	80009250 <logFromISR+0x250>
800091b2:	2f ed       	sub	sp,-8
800091b4:	18 98       	mov	r8,r12
800091b6:	ef 68 ff fb 	st.b	r7[-5],r8
			
			
			
		}while(*str != '\0');
800091ba:	ee f8 ff f0 	ld.w	r8,r7[-16]
800091be:	11 88       	ld.ub	r8,r8[0x0]
800091c0:	58 08       	cp.w	r8,0
800091c2:	fe 91 ff 3e 	brne	8000903e <logFromISR+0x3e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800091c6:	ee c8 01 14 	sub	r8,r7,276
800091ca:	ee c9 01 14 	sub	r9,r7,276
800091ce:	1a d9       	st.w	--sp,r9
800091d0:	4a 2b       	lddpc	r11,80009258 <logFromISR+0x258>
800091d2:	10 9c       	mov	r12,r8
800091d4:	f0 1f 00 1f 	mcall	80009250 <logFromISR+0x250>
800091d8:	2f fd       	sub	sp,-4
800091da:	18 98       	mov	r8,r12
800091dc:	ef 68 ff fb 	st.b	r7[-5],r8
		
		char * p = pvPortMalloc(length+1);
800091e0:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800091e4:	2f f8       	sub	r8,-1
800091e6:	10 9c       	mov	r12,r8
800091e8:	f0 1f 00 1d 	mcall	8000925c <logFromISR+0x25c>
800091ec:	18 98       	mov	r8,r12
800091ee:	ef 48 fe e4 	st.w	r7[-284],r8
		memcpy(p, logTmp, length+1);
800091f2:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800091f6:	2f f8       	sub	r8,-1
800091f8:	10 9a       	mov	r10,r8
800091fa:	ee f8 fe e4 	ld.w	r8,r7[-284]
800091fe:	ee c9 01 14 	sub	r9,r7,276
80009202:	12 9b       	mov	r11,r9
80009204:	10 9c       	mov	r12,r8
80009206:	f0 1f 00 17 	mcall	80009260 <logFromISR+0x260>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000920a:	30 08       	mov	r8,0
8000920c:	ef 48 fe e0 	st.w	r7[-288],r8
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80009210:	49 58       	lddpc	r8,80009264 <logFromISR+0x264>
80009212:	70 08       	ld.w	r8,r8[0x0]
80009214:	ee ca 01 20 	sub	r10,r7,288
80009218:	ee cb 01 1c 	sub	r11,r7,284
8000921c:	30 09       	mov	r9,0
8000921e:	10 9c       	mov	r12,r8
80009220:	f0 1f 00 12 	mcall	80009268 <logFromISR+0x268>
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80009224:	fe 3d fd dc 	sub	sp,-548
80009228:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000922c:	80 00       	ld.sh	r0,r0[0x0]
8000922e:	98 d0       	ld.uh	r0,r12[0xa]
80009230:	00 00       	add	r0,r0
80009232:	0d 38       	ld.ub	r8,r6++
80009234:	80 00       	ld.sh	r0,r0[0x0]
80009236:	f2 74 80 00 	mov	r4,-819200
8000923a:	8a 60       	ld.sh	r0,r5[0xc]
8000923c:	80 00       	ld.sh	r0,r0[0x0]
8000923e:	8c 18       	ld.sh	r8,r6[0x2]
80009240:	80 00       	ld.sh	r0,r0[0x0]
80009242:	8a 2c       	ld.sh	r12,r5[0x4]
80009244:	80 00       	ld.sh	r0,r0[0x0]
80009246:	8a 04       	ld.sh	r4,r5[0x0]
80009248:	80 00       	ld.sh	r0,r0[0x0]
8000924a:	8d 90       	st.w	r6[0x24],r0
8000924c:	80 00       	ld.sh	r0,r0[0x0]
8000924e:	8a 14       	ld.sh	r4,r5[0x2]
80009250:	80 00       	ld.sh	r0,r0[0x0]
80009252:	9b c0       	st.w	sp[0x30],r0
80009254:	80 00       	ld.sh	r0,r0[0x0]
80009256:	8a 1c       	ld.sh	r12,r5[0x2]
80009258:	80 00       	ld.sh	r0,r0[0x0]
8000925a:	8a 24       	ld.sh	r4,r5[0x4]
8000925c:	80 00       	ld.sh	r0,r0[0x0]
8000925e:	73 4c       	ld.w	r12,r9[0x50]
80009260:	80 00       	ld.sh	r0,r0[0x0]
80009262:	97 88       	st.w	r11[0x20],r8
80009264:	00 00       	add	r0,r0
80009266:	40 f0       	lddsp	r0,sp[0x3c]
80009268:	80 00       	ld.sh	r0,r0[0x0]
8000926a:	76 40       	ld.w	r0,r11[0x10]

8000926c <main>:
//#include "fs/fs.h"
#include "rtc/rtc.h"
#include "data_flash/data_flash.h"

int main(void)
{
8000926c:	eb cd 40 80 	pushm	r7,lr
80009270:	1a 97       	mov	r7,sp
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80009272:	fe 78 10 00 	mov	r8,-61440
80009276:	30 19       	mov	r9,1
80009278:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000927c:	fe 78 10 00 	mov	r8,-61440
80009280:	30 19       	mov	r9,1
80009282:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80009286:	fe 78 10 00 	mov	r8,-61440
8000928a:	30 19       	mov	r9,1
8000928c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80009290:	d3 03       	ssrf	0x10
	local_start_pll0();
80009292:	f0 1f 00 11 	mcall	800092d4 <main+0x68>
		
	INTC_init_interrupts();
80009296:	f0 1f 00 11 	mcall	800092d8 <main+0x6c>
		
	//rtc_init();
	
	//fs_init();//65795,RadioOBSD

	tc_init();	
8000929a:	f0 1f 00 11 	mcall	800092dc <main+0x70>
			
	xcmp_init();
8000929e:	f0 1f 00 11 	mcall	800092e0 <main+0x74>
	
	app_init();
800092a2:	f0 1f 00 11 	mcall	800092e4 <main+0x78>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800092a6:	fe 78 10 00 	mov	r8,-61440
800092aa:	f0 f8 01 60 	ld.w	r8,r8[352]
800092ae:	e2 18 00 02 	andl	r8,0x2,COH
800092b2:	cf a0       	breq	800092a6 <main+0x3a>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800092b4:	fe 78 10 00 	mov	r8,-61440
800092b8:	f0 f8 01 60 	ld.w	r8,r8[352]
800092bc:	e2 18 00 02 	andl	r8,0x2,COH
800092c0:	cf a1       	brne	800092b4 <main+0x48>
	local_start_timer();
800092c2:	f0 1f 00 0a 	mcall	800092e8 <main+0x7c>
	
	Enable_global_interrupt();
800092c6:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
800092c8:	f0 1f 00 09 	mcall	800092ec <main+0x80>
	return 0;
800092cc:	30 08       	mov	r8,0
}
800092ce:	10 9c       	mov	r12,r8
800092d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800092d4:	80 00       	ld.sh	r0,r0[0x0]
800092d6:	63 84       	ld.w	r4,r1[0x60]
800092d8:	80 00       	ld.sh	r0,r0[0x0]
800092da:	65 88       	ld.w	r8,r2[0x60]
800092dc:	80 00       	ld.sh	r0,r0[0x0]
800092de:	64 8c       	ld.w	r12,r2[0x20]
800092e0:	80 00       	ld.sh	r0,r0[0x0]
800092e2:	59 20       	cp.w	r0,18
800092e4:	80 00       	ld.sh	r0,r0[0x0]
800092e6:	33 14       	mov	r4,49
800092e8:	80 00       	ld.sh	r0,r0[0x0]
800092ea:	64 1c       	ld.w	r12,r2[0x4]
800092ec:	80 00       	ld.sh	r0,r0[0x0]
800092ee:	7e d8       	ld.w	r8,pc[0x34]

800092f0 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800092f0:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800092f4:	fe c0 a4 f4 	sub	r0,pc,-23308

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800092f8:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800092fc:	d5 53       	csrf	0x15
  cp      r0, r1
800092fe:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80009300:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80009304:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80009306:	c0 72       	brcc	80009314 <idata_load_loop_end>
  cp      r0, r1
80009308:	fe c2 99 b8 	sub	r2,pc,-26184

8000930c <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000930c:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000930e:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80009310:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80009312:	cf d3       	brcs	8000930c <idata_load_loop>

80009314 <idata_load_loop_end>:
  mov     r2, 0
80009314:	e0 60 0a 38 	mov	r0,2616
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80009318:	e0 61 40 f8 	mov	r1,16632
  cp      r0, r1
  brlo    udata_clear_loop
8000931c:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000931e:	c0 62       	brcc	8000932a <udata_clear_loop_end>
80009320:	30 02       	mov	r2,0
80009322:	30 03       	mov	r3,0

80009324 <udata_clear_loop>:
80009324:	a1 22       	st.d	r0++,r2
80009326:	02 30       	cp.w	r0,r1
80009328:	cf e3       	brcs	80009324 <udata_clear_loop>

8000932a <udata_clear_loop_end>:
8000932a:	fe cf 00 be 	sub	pc,pc,190
8000932e:	d7 03       	nop

80009330 <free>:
80009330:	d4 01       	pushm	lr
80009332:	e0 68 0a 30 	mov	r8,2608
80009336:	18 9b       	mov	r11,r12
80009338:	70 0c       	ld.w	r12,r8[0x0]
8000933a:	e0 a0 1e 6d 	rcall	8000d014 <_free_r>
8000933e:	d8 02       	popm	pc

80009340 <malloc>:
80009340:	d4 01       	pushm	lr
80009342:	e0 68 0a 30 	mov	r8,2608
80009346:	18 9b       	mov	r11,r12
80009348:	70 0c       	ld.w	r12,r8[0x0]
8000934a:	c0 3c       	rcall	80009350 <_malloc_r>
8000934c:	d8 02       	popm	pc
8000934e:	d7 03       	nop

80009350 <_malloc_r>:
80009350:	d4 31       	pushm	r0-r7,lr
80009352:	f6 c8 ff f5 	sub	r8,r11,-11
80009356:	18 95       	mov	r5,r12
80009358:	10 97       	mov	r7,r8
8000935a:	e0 17 ff f8 	andl	r7,0xfff8
8000935e:	59 68       	cp.w	r8,22
80009360:	f9 b7 08 10 	movls	r7,16
80009364:	16 37       	cp.w	r7,r11
80009366:	5f 38       	srlo	r8
80009368:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000936c:	c0 50       	breq	80009376 <_malloc_r+0x26>
8000936e:	30 c8       	mov	r8,12
80009370:	99 38       	st.w	r12[0xc],r8
80009372:	e0 8f 01 fa 	bral	80009766 <_malloc_r+0x416>
80009376:	fe b0 ed 6d 	rcall	80006e50 <__malloc_lock>
8000937a:	e0 47 01 f7 	cp.w	r7,503
8000937e:	e0 8b 00 1d 	brhi	800093b8 <_malloc_r+0x68>
80009382:	ee 03 16 03 	lsr	r3,r7,0x3
80009386:	e0 68 05 30 	mov	r8,1328
8000938a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000938e:	70 36       	ld.w	r6,r8[0xc]
80009390:	10 36       	cp.w	r6,r8
80009392:	c0 61       	brne	8000939e <_malloc_r+0x4e>
80009394:	ec c8 ff f8 	sub	r8,r6,-8
80009398:	70 36       	ld.w	r6,r8[0xc]
8000939a:	10 36       	cp.w	r6,r8
8000939c:	c0 c0       	breq	800093b4 <_malloc_r+0x64>
8000939e:	6c 18       	ld.w	r8,r6[0x4]
800093a0:	e0 18 ff fc 	andl	r8,0xfffc
800093a4:	6c 3a       	ld.w	r10,r6[0xc]
800093a6:	ec 08 00 09 	add	r9,r6,r8
800093aa:	0a 9c       	mov	r12,r5
800093ac:	6c 28       	ld.w	r8,r6[0x8]
800093ae:	95 28       	st.w	r10[0x8],r8
800093b0:	91 3a       	st.w	r8[0xc],r10
800093b2:	c4 78       	rjmp	80009440 <_malloc_r+0xf0>
800093b4:	2f e3       	sub	r3,-2
800093b6:	c4 d8       	rjmp	80009450 <_malloc_r+0x100>
800093b8:	ee 03 16 09 	lsr	r3,r7,0x9
800093bc:	c0 41       	brne	800093c4 <_malloc_r+0x74>
800093be:	ee 03 16 03 	lsr	r3,r7,0x3
800093c2:	c2 68       	rjmp	8000940e <_malloc_r+0xbe>
800093c4:	58 43       	cp.w	r3,4
800093c6:	e0 8b 00 06 	brhi	800093d2 <_malloc_r+0x82>
800093ca:	ee 03 16 06 	lsr	r3,r7,0x6
800093ce:	2c 83       	sub	r3,-56
800093d0:	c1 f8       	rjmp	8000940e <_malloc_r+0xbe>
800093d2:	59 43       	cp.w	r3,20
800093d4:	e0 8b 00 04 	brhi	800093dc <_malloc_r+0x8c>
800093d8:	2a 53       	sub	r3,-91
800093da:	c1 a8       	rjmp	8000940e <_malloc_r+0xbe>
800093dc:	e0 43 00 54 	cp.w	r3,84
800093e0:	e0 8b 00 06 	brhi	800093ec <_malloc_r+0x9c>
800093e4:	ee 03 16 0c 	lsr	r3,r7,0xc
800093e8:	29 23       	sub	r3,-110
800093ea:	c1 28       	rjmp	8000940e <_malloc_r+0xbe>
800093ec:	e0 43 01 54 	cp.w	r3,340
800093f0:	e0 8b 00 06 	brhi	800093fc <_malloc_r+0xac>
800093f4:	ee 03 16 0f 	lsr	r3,r7,0xf
800093f8:	28 93       	sub	r3,-119
800093fa:	c0 a8       	rjmp	8000940e <_malloc_r+0xbe>
800093fc:	e0 43 05 54 	cp.w	r3,1364
80009400:	e0 88 00 04 	brls	80009408 <_malloc_r+0xb8>
80009404:	37 e3       	mov	r3,126
80009406:	c0 48       	rjmp	8000940e <_malloc_r+0xbe>
80009408:	ee 03 16 12 	lsr	r3,r7,0x12
8000940c:	28 43       	sub	r3,-124
8000940e:	e0 6a 05 30 	mov	r10,1328
80009412:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80009416:	74 36       	ld.w	r6,r10[0xc]
80009418:	c1 98       	rjmp	8000944a <_malloc_r+0xfa>
8000941a:	6c 19       	ld.w	r9,r6[0x4]
8000941c:	e0 19 ff fc 	andl	r9,0xfffc
80009420:	f2 07 01 0b 	sub	r11,r9,r7
80009424:	58 fb       	cp.w	r11,15
80009426:	e0 8a 00 04 	brle	8000942e <_malloc_r+0xde>
8000942a:	20 13       	sub	r3,1
8000942c:	c1 18       	rjmp	8000944e <_malloc_r+0xfe>
8000942e:	6c 38       	ld.w	r8,r6[0xc]
80009430:	58 0b       	cp.w	r11,0
80009432:	c0 b5       	brlt	80009448 <_malloc_r+0xf8>
80009434:	6c 2a       	ld.w	r10,r6[0x8]
80009436:	ec 09 00 09 	add	r9,r6,r9
8000943a:	0a 9c       	mov	r12,r5
8000943c:	91 2a       	st.w	r8[0x8],r10
8000943e:	95 38       	st.w	r10[0xc],r8
80009440:	72 18       	ld.w	r8,r9[0x4]
80009442:	a1 a8       	sbr	r8,0x0
80009444:	93 18       	st.w	r9[0x4],r8
80009446:	cb c8       	rjmp	800095be <_malloc_r+0x26e>
80009448:	10 96       	mov	r6,r8
8000944a:	14 36       	cp.w	r6,r10
8000944c:	ce 71       	brne	8000941a <_malloc_r+0xca>
8000944e:	2f f3       	sub	r3,-1
80009450:	e0 6a 05 30 	mov	r10,1328
80009454:	f4 cc ff f8 	sub	r12,r10,-8
80009458:	78 26       	ld.w	r6,r12[0x8]
8000945a:	18 36       	cp.w	r6,r12
8000945c:	c6 c0       	breq	80009534 <_malloc_r+0x1e4>
8000945e:	6c 19       	ld.w	r9,r6[0x4]
80009460:	e0 19 ff fc 	andl	r9,0xfffc
80009464:	f2 07 01 08 	sub	r8,r9,r7
80009468:	58 f8       	cp.w	r8,15
8000946a:	e0 89 00 8f 	brgt	80009588 <_malloc_r+0x238>
8000946e:	99 3c       	st.w	r12[0xc],r12
80009470:	99 2c       	st.w	r12[0x8],r12
80009472:	58 08       	cp.w	r8,0
80009474:	c0 55       	brlt	8000947e <_malloc_r+0x12e>
80009476:	ec 09 00 09 	add	r9,r6,r9
8000947a:	0a 9c       	mov	r12,r5
8000947c:	ce 2b       	rjmp	80009440 <_malloc_r+0xf0>
8000947e:	e0 49 01 ff 	cp.w	r9,511
80009482:	e0 8b 00 13 	brhi	800094a8 <_malloc_r+0x158>
80009486:	a3 99       	lsr	r9,0x3
80009488:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000948c:	70 2b       	ld.w	r11,r8[0x8]
8000948e:	8d 38       	st.w	r6[0xc],r8
80009490:	8d 2b       	st.w	r6[0x8],r11
80009492:	97 36       	st.w	r11[0xc],r6
80009494:	91 26       	st.w	r8[0x8],r6
80009496:	a3 49       	asr	r9,0x2
80009498:	74 18       	ld.w	r8,r10[0x4]
8000949a:	30 1b       	mov	r11,1
8000949c:	f6 09 09 49 	lsl	r9,r11,r9
800094a0:	f1 e9 10 09 	or	r9,r8,r9
800094a4:	95 19       	st.w	r10[0x4],r9
800094a6:	c4 78       	rjmp	80009534 <_malloc_r+0x1e4>
800094a8:	f2 0a 16 09 	lsr	r10,r9,0x9
800094ac:	58 4a       	cp.w	r10,4
800094ae:	e0 8b 00 07 	brhi	800094bc <_malloc_r+0x16c>
800094b2:	f2 0a 16 06 	lsr	r10,r9,0x6
800094b6:	2c 8a       	sub	r10,-56
800094b8:	c2 08       	rjmp	800094f8 <_malloc_r+0x1a8>
800094ba:	d7 03       	nop
800094bc:	59 4a       	cp.w	r10,20
800094be:	e0 8b 00 04 	brhi	800094c6 <_malloc_r+0x176>
800094c2:	2a 5a       	sub	r10,-91
800094c4:	c1 a8       	rjmp	800094f8 <_malloc_r+0x1a8>
800094c6:	e0 4a 00 54 	cp.w	r10,84
800094ca:	e0 8b 00 06 	brhi	800094d6 <_malloc_r+0x186>
800094ce:	f2 0a 16 0c 	lsr	r10,r9,0xc
800094d2:	29 2a       	sub	r10,-110
800094d4:	c1 28       	rjmp	800094f8 <_malloc_r+0x1a8>
800094d6:	e0 4a 01 54 	cp.w	r10,340
800094da:	e0 8b 00 06 	brhi	800094e6 <_malloc_r+0x196>
800094de:	f2 0a 16 0f 	lsr	r10,r9,0xf
800094e2:	28 9a       	sub	r10,-119
800094e4:	c0 a8       	rjmp	800094f8 <_malloc_r+0x1a8>
800094e6:	e0 4a 05 54 	cp.w	r10,1364
800094ea:	e0 88 00 04 	brls	800094f2 <_malloc_r+0x1a2>
800094ee:	37 ea       	mov	r10,126
800094f0:	c0 48       	rjmp	800094f8 <_malloc_r+0x1a8>
800094f2:	f2 0a 16 12 	lsr	r10,r9,0x12
800094f6:	28 4a       	sub	r10,-124
800094f8:	e0 6b 05 30 	mov	r11,1328
800094fc:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80009500:	68 28       	ld.w	r8,r4[0x8]
80009502:	08 38       	cp.w	r8,r4
80009504:	c0 e1       	brne	80009520 <_malloc_r+0x1d0>
80009506:	76 19       	ld.w	r9,r11[0x4]
80009508:	a3 4a       	asr	r10,0x2
8000950a:	30 1e       	mov	lr,1
8000950c:	fc 0a 09 4a 	lsl	r10,lr,r10
80009510:	f3 ea 10 0a 	or	r10,r9,r10
80009514:	10 99       	mov	r9,r8
80009516:	97 1a       	st.w	r11[0x4],r10
80009518:	c0 a8       	rjmp	8000952c <_malloc_r+0x1dc>
8000951a:	70 28       	ld.w	r8,r8[0x8]
8000951c:	08 38       	cp.w	r8,r4
8000951e:	c0 60       	breq	8000952a <_malloc_r+0x1da>
80009520:	70 1a       	ld.w	r10,r8[0x4]
80009522:	e0 1a ff fc 	andl	r10,0xfffc
80009526:	14 39       	cp.w	r9,r10
80009528:	cf 93       	brcs	8000951a <_malloc_r+0x1ca>
8000952a:	70 39       	ld.w	r9,r8[0xc]
8000952c:	8d 39       	st.w	r6[0xc],r9
8000952e:	8d 28       	st.w	r6[0x8],r8
80009530:	91 36       	st.w	r8[0xc],r6
80009532:	93 26       	st.w	r9[0x8],r6
80009534:	e6 08 14 02 	asr	r8,r3,0x2
80009538:	30 1b       	mov	r11,1
8000953a:	e0 64 05 30 	mov	r4,1328
8000953e:	f6 08 09 4b 	lsl	r11,r11,r8
80009542:	68 18       	ld.w	r8,r4[0x4]
80009544:	10 3b       	cp.w	r11,r8
80009546:	e0 8b 00 6b 	brhi	8000961c <_malloc_r+0x2cc>
8000954a:	f7 e8 00 09 	and	r9,r11,r8
8000954e:	c0 b1       	brne	80009564 <_malloc_r+0x214>
80009550:	e0 13 ff fc 	andl	r3,0xfffc
80009554:	a1 7b       	lsl	r11,0x1
80009556:	2f c3       	sub	r3,-4
80009558:	c0 38       	rjmp	8000955e <_malloc_r+0x20e>
8000955a:	2f c3       	sub	r3,-4
8000955c:	a1 7b       	lsl	r11,0x1
8000955e:	f7 e8 00 09 	and	r9,r11,r8
80009562:	cf c0       	breq	8000955a <_malloc_r+0x20a>
80009564:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80009568:	06 92       	mov	r2,r3
8000956a:	1c 91       	mov	r1,lr
8000956c:	62 36       	ld.w	r6,r1[0xc]
8000956e:	c2 e8       	rjmp	800095ca <_malloc_r+0x27a>
80009570:	6c 1a       	ld.w	r10,r6[0x4]
80009572:	e0 1a ff fc 	andl	r10,0xfffc
80009576:	f4 07 01 08 	sub	r8,r10,r7
8000957a:	58 f8       	cp.w	r8,15
8000957c:	e0 8a 00 15 	brle	800095a6 <_malloc_r+0x256>
80009580:	6c 3a       	ld.w	r10,r6[0xc]
80009582:	6c 29       	ld.w	r9,r6[0x8]
80009584:	95 29       	st.w	r10[0x8],r9
80009586:	93 3a       	st.w	r9[0xc],r10
80009588:	0e 99       	mov	r9,r7
8000958a:	ec 07 00 07 	add	r7,r6,r7
8000958e:	a1 a9       	sbr	r9,0x0
80009590:	99 37       	st.w	r12[0xc],r7
80009592:	99 27       	st.w	r12[0x8],r7
80009594:	8d 19       	st.w	r6[0x4],r9
80009596:	ee 08 09 08 	st.w	r7[r8],r8
8000959a:	8f 2c       	st.w	r7[0x8],r12
8000959c:	8f 3c       	st.w	r7[0xc],r12
8000959e:	a1 a8       	sbr	r8,0x0
800095a0:	0a 9c       	mov	r12,r5
800095a2:	8f 18       	st.w	r7[0x4],r8
800095a4:	c0 d8       	rjmp	800095be <_malloc_r+0x26e>
800095a6:	6c 39       	ld.w	r9,r6[0xc]
800095a8:	58 08       	cp.w	r8,0
800095aa:	c0 f5       	brlt	800095c8 <_malloc_r+0x278>
800095ac:	ec 0a 00 0a 	add	r10,r6,r10
800095b0:	74 18       	ld.w	r8,r10[0x4]
800095b2:	a1 a8       	sbr	r8,0x0
800095b4:	0a 9c       	mov	r12,r5
800095b6:	95 18       	st.w	r10[0x4],r8
800095b8:	6c 28       	ld.w	r8,r6[0x8]
800095ba:	93 28       	st.w	r9[0x8],r8
800095bc:	91 39       	st.w	r8[0xc],r9
800095be:	fe b0 ec 57 	rcall	80006e6c <__malloc_unlock>
800095c2:	ec cc ff f8 	sub	r12,r6,-8
800095c6:	d8 32       	popm	r0-r7,pc
800095c8:	12 96       	mov	r6,r9
800095ca:	02 36       	cp.w	r6,r1
800095cc:	cd 21       	brne	80009570 <_malloc_r+0x220>
800095ce:	2f f2       	sub	r2,-1
800095d0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800095d4:	c0 30       	breq	800095da <_malloc_r+0x28a>
800095d6:	2f 81       	sub	r1,-8
800095d8:	cc ab       	rjmp	8000956c <_malloc_r+0x21c>
800095da:	1c 98       	mov	r8,lr
800095dc:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800095e0:	c0 81       	brne	800095f0 <_malloc_r+0x2a0>
800095e2:	68 19       	ld.w	r9,r4[0x4]
800095e4:	f6 08 11 ff 	rsub	r8,r11,-1
800095e8:	f3 e8 00 08 	and	r8,r9,r8
800095ec:	89 18       	st.w	r4[0x4],r8
800095ee:	c0 78       	rjmp	800095fc <_malloc_r+0x2ac>
800095f0:	f0 c9 00 08 	sub	r9,r8,8
800095f4:	20 13       	sub	r3,1
800095f6:	70 08       	ld.w	r8,r8[0x0]
800095f8:	12 38       	cp.w	r8,r9
800095fa:	cf 10       	breq	800095dc <_malloc_r+0x28c>
800095fc:	a1 7b       	lsl	r11,0x1
800095fe:	68 18       	ld.w	r8,r4[0x4]
80009600:	10 3b       	cp.w	r11,r8
80009602:	e0 8b 00 0d 	brhi	8000961c <_malloc_r+0x2cc>
80009606:	58 0b       	cp.w	r11,0
80009608:	c0 a0       	breq	8000961c <_malloc_r+0x2cc>
8000960a:	04 93       	mov	r3,r2
8000960c:	c0 38       	rjmp	80009612 <_malloc_r+0x2c2>
8000960e:	2f c3       	sub	r3,-4
80009610:	a1 7b       	lsl	r11,0x1
80009612:	f7 e8 00 09 	and	r9,r11,r8
80009616:	ca 71       	brne	80009564 <_malloc_r+0x214>
80009618:	cf bb       	rjmp	8000960e <_malloc_r+0x2be>
8000961a:	d7 03       	nop
8000961c:	68 23       	ld.w	r3,r4[0x8]
8000961e:	66 12       	ld.w	r2,r3[0x4]
80009620:	e0 12 ff fc 	andl	r2,0xfffc
80009624:	0e 32       	cp.w	r2,r7
80009626:	5f 39       	srlo	r9
80009628:	e4 07 01 08 	sub	r8,r2,r7
8000962c:	58 f8       	cp.w	r8,15
8000962e:	5f aa       	srle	r10
80009630:	f5 e9 10 09 	or	r9,r10,r9
80009634:	e0 80 00 9a 	breq	80009768 <_malloc_r+0x418>
80009638:	e0 68 0d 44 	mov	r8,3396
8000963c:	70 01       	ld.w	r1,r8[0x0]
8000963e:	e0 68 09 3c 	mov	r8,2364
80009642:	2f 01       	sub	r1,-16
80009644:	70 08       	ld.w	r8,r8[0x0]
80009646:	0e 01       	add	r1,r7
80009648:	5b f8       	cp.w	r8,-1
8000964a:	c0 40       	breq	80009652 <_malloc_r+0x302>
8000964c:	28 11       	sub	r1,-127
8000964e:	e0 11 ff 80 	andl	r1,0xff80
80009652:	02 9b       	mov	r11,r1
80009654:	0a 9c       	mov	r12,r5
80009656:	e0 a0 02 a5 	rcall	80009ba0 <_sbrk_r>
8000965a:	18 96       	mov	r6,r12
8000965c:	5b fc       	cp.w	r12,-1
8000965e:	c7 50       	breq	80009748 <_malloc_r+0x3f8>
80009660:	e6 02 00 08 	add	r8,r3,r2
80009664:	10 3c       	cp.w	r12,r8
80009666:	c0 32       	brcc	8000966c <_malloc_r+0x31c>
80009668:	08 33       	cp.w	r3,r4
8000966a:	c6 f1       	brne	80009748 <_malloc_r+0x3f8>
8000966c:	e0 6a 0d 48 	mov	r10,3400
80009670:	74 09       	ld.w	r9,r10[0x0]
80009672:	e2 09 00 09 	add	r9,r1,r9
80009676:	95 09       	st.w	r10[0x0],r9
80009678:	10 36       	cp.w	r6,r8
8000967a:	c0 a1       	brne	8000968e <_malloc_r+0x33e>
8000967c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80009680:	c0 71       	brne	8000968e <_malloc_r+0x33e>
80009682:	e2 02 00 02 	add	r2,r1,r2
80009686:	68 28       	ld.w	r8,r4[0x8]
80009688:	a1 a2       	sbr	r2,0x0
8000968a:	91 12       	st.w	r8[0x4],r2
8000968c:	c4 f8       	rjmp	8000972a <_malloc_r+0x3da>
8000968e:	e0 6a 09 3c 	mov	r10,2364
80009692:	74 0b       	ld.w	r11,r10[0x0]
80009694:	5b fb       	cp.w	r11,-1
80009696:	c0 31       	brne	8000969c <_malloc_r+0x34c>
80009698:	95 06       	st.w	r10[0x0],r6
8000969a:	c0 78       	rjmp	800096a8 <_malloc_r+0x358>
8000969c:	ec 09 00 09 	add	r9,r6,r9
800096a0:	e0 6a 0d 48 	mov	r10,3400
800096a4:	10 19       	sub	r9,r8
800096a6:	95 09       	st.w	r10[0x0],r9
800096a8:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800096ac:	f0 09 11 08 	rsub	r9,r8,8
800096b0:	58 08       	cp.w	r8,0
800096b2:	f2 08 17 10 	movne	r8,r9
800096b6:	ed d8 e1 06 	addne	r6,r6,r8
800096ba:	28 08       	sub	r8,-128
800096bc:	ec 01 00 01 	add	r1,r6,r1
800096c0:	0a 9c       	mov	r12,r5
800096c2:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800096c6:	f0 01 01 01 	sub	r1,r8,r1
800096ca:	02 9b       	mov	r11,r1
800096cc:	e0 a0 02 6a 	rcall	80009ba0 <_sbrk_r>
800096d0:	e0 68 0d 48 	mov	r8,3400
800096d4:	5b fc       	cp.w	r12,-1
800096d6:	ec 0c 17 00 	moveq	r12,r6
800096da:	f9 b1 00 00 	moveq	r1,0
800096de:	70 09       	ld.w	r9,r8[0x0]
800096e0:	0c 1c       	sub	r12,r6
800096e2:	89 26       	st.w	r4[0x8],r6
800096e4:	02 0c       	add	r12,r1
800096e6:	12 01       	add	r1,r9
800096e8:	a1 ac       	sbr	r12,0x0
800096ea:	91 01       	st.w	r8[0x0],r1
800096ec:	8d 1c       	st.w	r6[0x4],r12
800096ee:	08 33       	cp.w	r3,r4
800096f0:	c1 d0       	breq	8000972a <_malloc_r+0x3da>
800096f2:	58 f2       	cp.w	r2,15
800096f4:	e0 8b 00 05 	brhi	800096fe <_malloc_r+0x3ae>
800096f8:	30 18       	mov	r8,1
800096fa:	8d 18       	st.w	r6[0x4],r8
800096fc:	c2 68       	rjmp	80009748 <_malloc_r+0x3f8>
800096fe:	30 59       	mov	r9,5
80009700:	20 c2       	sub	r2,12
80009702:	e0 12 ff f8 	andl	r2,0xfff8
80009706:	e6 02 00 08 	add	r8,r3,r2
8000970a:	91 29       	st.w	r8[0x8],r9
8000970c:	91 19       	st.w	r8[0x4],r9
8000970e:	66 18       	ld.w	r8,r3[0x4]
80009710:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80009714:	e5 e8 10 08 	or	r8,r2,r8
80009718:	87 18       	st.w	r3[0x4],r8
8000971a:	58 f2       	cp.w	r2,15
8000971c:	e0 88 00 07 	brls	8000972a <_malloc_r+0x3da>
80009720:	e6 cb ff f8 	sub	r11,r3,-8
80009724:	0a 9c       	mov	r12,r5
80009726:	e0 a0 1c 77 	rcall	8000d014 <_free_r>
8000972a:	e0 69 0d 40 	mov	r9,3392
8000972e:	72 0a       	ld.w	r10,r9[0x0]
80009730:	e0 68 0d 48 	mov	r8,3400
80009734:	70 08       	ld.w	r8,r8[0x0]
80009736:	14 38       	cp.w	r8,r10
80009738:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000973c:	e0 69 0d 3c 	mov	r9,3388
80009740:	72 0a       	ld.w	r10,r9[0x0]
80009742:	14 38       	cp.w	r8,r10
80009744:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80009748:	68 28       	ld.w	r8,r4[0x8]
8000974a:	70 18       	ld.w	r8,r8[0x4]
8000974c:	e0 18 ff fc 	andl	r8,0xfffc
80009750:	0e 38       	cp.w	r8,r7
80009752:	5f 39       	srlo	r9
80009754:	0e 18       	sub	r8,r7
80009756:	58 f8       	cp.w	r8,15
80009758:	5f aa       	srle	r10
8000975a:	f5 e9 10 09 	or	r9,r10,r9
8000975e:	c0 50       	breq	80009768 <_malloc_r+0x418>
80009760:	0a 9c       	mov	r12,r5
80009762:	fe b0 eb 85 	rcall	80006e6c <__malloc_unlock>
80009766:	d8 3a       	popm	r0-r7,pc,r12=0
80009768:	68 26       	ld.w	r6,r4[0x8]
8000976a:	a1 a8       	sbr	r8,0x0
8000976c:	0e 99       	mov	r9,r7
8000976e:	a1 a9       	sbr	r9,0x0
80009770:	8d 19       	st.w	r6[0x4],r9
80009772:	ec 07 00 07 	add	r7,r6,r7
80009776:	0a 9c       	mov	r12,r5
80009778:	89 27       	st.w	r4[0x8],r7
8000977a:	8f 18       	st.w	r7[0x4],r8
8000977c:	fe b0 eb 78 	rcall	80006e6c <__malloc_unlock>
80009780:	ec cc ff f8 	sub	r12,r6,-8
80009784:	d8 32       	popm	r0-r7,pc
80009786:	d7 03       	nop

80009788 <memcpy>:
80009788:	58 8a       	cp.w	r10,8
8000978a:	c2 f5       	brlt	800097e8 <memcpy+0x60>
8000978c:	f9 eb 10 09 	or	r9,r12,r11
80009790:	e2 19 00 03 	andl	r9,0x3,COH
80009794:	e0 81 00 97 	brne	800098c2 <memcpy+0x13a>
80009798:	e0 4a 00 20 	cp.w	r10,32
8000979c:	c3 b4       	brge	80009812 <memcpy+0x8a>
8000979e:	f4 08 14 02 	asr	r8,r10,0x2
800097a2:	f0 09 11 08 	rsub	r9,r8,8
800097a6:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800097aa:	76 69       	ld.w	r9,r11[0x18]
800097ac:	99 69       	st.w	r12[0x18],r9
800097ae:	76 59       	ld.w	r9,r11[0x14]
800097b0:	99 59       	st.w	r12[0x14],r9
800097b2:	76 49       	ld.w	r9,r11[0x10]
800097b4:	99 49       	st.w	r12[0x10],r9
800097b6:	76 39       	ld.w	r9,r11[0xc]
800097b8:	99 39       	st.w	r12[0xc],r9
800097ba:	76 29       	ld.w	r9,r11[0x8]
800097bc:	99 29       	st.w	r12[0x8],r9
800097be:	76 19       	ld.w	r9,r11[0x4]
800097c0:	99 19       	st.w	r12[0x4],r9
800097c2:	76 09       	ld.w	r9,r11[0x0]
800097c4:	99 09       	st.w	r12[0x0],r9
800097c6:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800097ca:	f8 08 00 28 	add	r8,r12,r8<<0x2
800097ce:	e0 1a 00 03 	andl	r10,0x3
800097d2:	f4 0a 11 04 	rsub	r10,r10,4
800097d6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800097da:	17 a9       	ld.ub	r9,r11[0x2]
800097dc:	b0 a9       	st.b	r8[0x2],r9
800097de:	17 99       	ld.ub	r9,r11[0x1]
800097e0:	b0 99       	st.b	r8[0x1],r9
800097e2:	17 89       	ld.ub	r9,r11[0x0]
800097e4:	b0 89       	st.b	r8[0x0],r9
800097e6:	5e fc       	retal	r12
800097e8:	f4 0a 11 09 	rsub	r10,r10,9
800097ec:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800097f0:	17 f9       	ld.ub	r9,r11[0x7]
800097f2:	b8 f9       	st.b	r12[0x7],r9
800097f4:	17 e9       	ld.ub	r9,r11[0x6]
800097f6:	b8 e9       	st.b	r12[0x6],r9
800097f8:	17 d9       	ld.ub	r9,r11[0x5]
800097fa:	b8 d9       	st.b	r12[0x5],r9
800097fc:	17 c9       	ld.ub	r9,r11[0x4]
800097fe:	b8 c9       	st.b	r12[0x4],r9
80009800:	17 b9       	ld.ub	r9,r11[0x3]
80009802:	b8 b9       	st.b	r12[0x3],r9
80009804:	17 a9       	ld.ub	r9,r11[0x2]
80009806:	b8 a9       	st.b	r12[0x2],r9
80009808:	17 99       	ld.ub	r9,r11[0x1]
8000980a:	b8 99       	st.b	r12[0x1],r9
8000980c:	17 89       	ld.ub	r9,r11[0x0]
8000980e:	b8 89       	st.b	r12[0x0],r9
80009810:	5e fc       	retal	r12
80009812:	eb cd 40 c0 	pushm	r6-r7,lr
80009816:	18 99       	mov	r9,r12
80009818:	22 0a       	sub	r10,32
8000981a:	b7 07       	ld.d	r6,r11++
8000981c:	b3 26       	st.d	r9++,r6
8000981e:	b7 07       	ld.d	r6,r11++
80009820:	b3 26       	st.d	r9++,r6
80009822:	b7 07       	ld.d	r6,r11++
80009824:	b3 26       	st.d	r9++,r6
80009826:	b7 07       	ld.d	r6,r11++
80009828:	b3 26       	st.d	r9++,r6
8000982a:	22 0a       	sub	r10,32
8000982c:	cf 74       	brge	8000981a <memcpy+0x92>
8000982e:	2f 0a       	sub	r10,-16
80009830:	c0 65       	brlt	8000983c <memcpy+0xb4>
80009832:	b7 07       	ld.d	r6,r11++
80009834:	b3 26       	st.d	r9++,r6
80009836:	b7 07       	ld.d	r6,r11++
80009838:	b3 26       	st.d	r9++,r6
8000983a:	21 0a       	sub	r10,16
8000983c:	5c 3a       	neg	r10
8000983e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80009842:	d7 03       	nop
80009844:	d7 03       	nop
80009846:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000984a:	f3 66 00 0e 	st.b	r9[14],r6
8000984e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80009852:	f3 66 00 0d 	st.b	r9[13],r6
80009856:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000985a:	f3 66 00 0c 	st.b	r9[12],r6
8000985e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80009862:	f3 66 00 0b 	st.b	r9[11],r6
80009866:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000986a:	f3 66 00 0a 	st.b	r9[10],r6
8000986e:	f7 36 00 09 	ld.ub	r6,r11[9]
80009872:	f3 66 00 09 	st.b	r9[9],r6
80009876:	f7 36 00 08 	ld.ub	r6,r11[8]
8000987a:	f3 66 00 08 	st.b	r9[8],r6
8000987e:	f7 36 00 07 	ld.ub	r6,r11[7]
80009882:	f3 66 00 07 	st.b	r9[7],r6
80009886:	f7 36 00 06 	ld.ub	r6,r11[6]
8000988a:	f3 66 00 06 	st.b	r9[6],r6
8000988e:	f7 36 00 05 	ld.ub	r6,r11[5]
80009892:	f3 66 00 05 	st.b	r9[5],r6
80009896:	f7 36 00 04 	ld.ub	r6,r11[4]
8000989a:	f3 66 00 04 	st.b	r9[4],r6
8000989e:	f7 36 00 03 	ld.ub	r6,r11[3]
800098a2:	f3 66 00 03 	st.b	r9[3],r6
800098a6:	f7 36 00 02 	ld.ub	r6,r11[2]
800098aa:	f3 66 00 02 	st.b	r9[2],r6
800098ae:	f7 36 00 01 	ld.ub	r6,r11[1]
800098b2:	f3 66 00 01 	st.b	r9[1],r6
800098b6:	f7 36 00 00 	ld.ub	r6,r11[0]
800098ba:	f3 66 00 00 	st.b	r9[0],r6
800098be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800098c2:	20 1a       	sub	r10,1
800098c4:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800098c8:	f8 0a 0b 09 	st.b	r12[r10],r9
800098cc:	cf b1       	brne	800098c2 <memcpy+0x13a>
800098ce:	5e fc       	retal	r12

800098d0 <memset>:
800098d0:	18 98       	mov	r8,r12
800098d2:	c0 38       	rjmp	800098d8 <memset+0x8>
800098d4:	10 cb       	st.b	r8++,r11
800098d6:	20 1a       	sub	r10,1
800098d8:	58 0a       	cp.w	r10,0
800098da:	cf d1       	brne	800098d4 <memset+0x4>
800098dc:	5e fc       	retal	r12
800098de:	d7 03       	nop

800098e0 <_realloc_r>:
800098e0:	d4 31       	pushm	r0-r7,lr
800098e2:	20 1d       	sub	sp,4
800098e4:	16 94       	mov	r4,r11
800098e6:	18 92       	mov	r2,r12
800098e8:	14 9b       	mov	r11,r10
800098ea:	58 04       	cp.w	r4,0
800098ec:	c0 51       	brne	800098f6 <_realloc_r+0x16>
800098ee:	fe b0 fd 31 	rcall	80009350 <_malloc_r>
800098f2:	18 95       	mov	r5,r12
800098f4:	c5 39       	rjmp	80009b9a <_realloc_r+0x2ba>
800098f6:	50 0a       	stdsp	sp[0x0],r10
800098f8:	fe b0 ea ac 	rcall	80006e50 <__malloc_lock>
800098fc:	40 0b       	lddsp	r11,sp[0x0]
800098fe:	f6 c8 ff f5 	sub	r8,r11,-11
80009902:	e8 c1 00 08 	sub	r1,r4,8
80009906:	10 96       	mov	r6,r8
80009908:	62 1c       	ld.w	r12,r1[0x4]
8000990a:	e0 16 ff f8 	andl	r6,0xfff8
8000990e:	59 68       	cp.w	r8,22
80009910:	f9 b6 08 10 	movls	r6,16
80009914:	16 36       	cp.w	r6,r11
80009916:	5f 38       	srlo	r8
80009918:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000991c:	c0 50       	breq	80009926 <_realloc_r+0x46>
8000991e:	30 c8       	mov	r8,12
80009920:	30 05       	mov	r5,0
80009922:	85 38       	st.w	r2[0xc],r8
80009924:	c3 b9       	rjmp	80009b9a <_realloc_r+0x2ba>
80009926:	18 90       	mov	r0,r12
80009928:	e0 10 ff fc 	andl	r0,0xfffc
8000992c:	0c 30       	cp.w	r0,r6
8000992e:	e0 84 01 0b 	brge	80009b44 <_realloc_r+0x264>
80009932:	e0 68 05 30 	mov	r8,1328
80009936:	e2 00 00 09 	add	r9,r1,r0
8000993a:	70 25       	ld.w	r5,r8[0x8]
8000993c:	0a 39       	cp.w	r9,r5
8000993e:	c0 90       	breq	80009950 <_realloc_r+0x70>
80009940:	72 1a       	ld.w	r10,r9[0x4]
80009942:	a1 ca       	cbr	r10,0x0
80009944:	f2 0a 00 0a 	add	r10,r9,r10
80009948:	74 1a       	ld.w	r10,r10[0x4]
8000994a:	ed ba 00 00 	bld	r10,0x0
8000994e:	c2 20       	breq	80009992 <_realloc_r+0xb2>
80009950:	72 1a       	ld.w	r10,r9[0x4]
80009952:	e0 1a ff fc 	andl	r10,0xfffc
80009956:	f4 00 00 03 	add	r3,r10,r0
8000995a:	0a 39       	cp.w	r9,r5
8000995c:	c1 31       	brne	80009982 <_realloc_r+0xa2>
8000995e:	ec c7 ff f0 	sub	r7,r6,-16
80009962:	0e 33       	cp.w	r3,r7
80009964:	c1 95       	brlt	80009996 <_realloc_r+0xb6>
80009966:	e2 06 00 09 	add	r9,r1,r6
8000996a:	0c 13       	sub	r3,r6
8000996c:	a1 a3       	sbr	r3,0x0
8000996e:	93 13       	st.w	r9[0x4],r3
80009970:	91 29       	st.w	r8[0x8],r9
80009972:	04 9c       	mov	r12,r2
80009974:	62 18       	ld.w	r8,r1[0x4]
80009976:	08 95       	mov	r5,r4
80009978:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000997c:	10 46       	or	r6,r8
8000997e:	83 16       	st.w	r1[0x4],r6
80009980:	c0 b9       	rjmp	80009b96 <_realloc_r+0x2b6>
80009982:	0c 33       	cp.w	r3,r6
80009984:	c0 95       	brlt	80009996 <_realloc_r+0xb6>
80009986:	72 28       	ld.w	r8,r9[0x8]
80009988:	02 97       	mov	r7,r1
8000998a:	72 39       	ld.w	r9,r9[0xc]
8000998c:	93 28       	st.w	r9[0x8],r8
8000998e:	91 39       	st.w	r8[0xc],r9
80009990:	cd c8       	rjmp	80009b48 <_realloc_r+0x268>
80009992:	30 0a       	mov	r10,0
80009994:	14 99       	mov	r9,r10
80009996:	ed bc 00 00 	bld	r12,0x0
8000999a:	e0 80 00 95 	breq	80009ac4 <_realloc_r+0x1e4>
8000999e:	62 07       	ld.w	r7,r1[0x0]
800099a0:	e2 07 01 07 	sub	r7,r1,r7
800099a4:	6e 1c       	ld.w	r12,r7[0x4]
800099a6:	e0 1c ff fc 	andl	r12,0xfffc
800099aa:	58 09       	cp.w	r9,0
800099ac:	c5 60       	breq	80009a58 <_realloc_r+0x178>
800099ae:	f8 00 00 03 	add	r3,r12,r0
800099b2:	0a 39       	cp.w	r9,r5
800099b4:	c4 81       	brne	80009a44 <_realloc_r+0x164>
800099b6:	14 03       	add	r3,r10
800099b8:	ec c9 ff f0 	sub	r9,r6,-16
800099bc:	12 33       	cp.w	r3,r9
800099be:	c4 d5       	brlt	80009a58 <_realloc_r+0x178>
800099c0:	6e 3a       	ld.w	r10,r7[0xc]
800099c2:	6e 29       	ld.w	r9,r7[0x8]
800099c4:	95 29       	st.w	r10[0x8],r9
800099c6:	93 3a       	st.w	r9[0xc],r10
800099c8:	ee c5 ff f8 	sub	r5,r7,-8
800099cc:	e0 ca 00 04 	sub	r10,r0,4
800099d0:	e0 4a 00 24 	cp.w	r10,36
800099d4:	e0 8b 00 25 	brhi	80009a1e <_realloc_r+0x13e>
800099d8:	0a 99       	mov	r9,r5
800099da:	59 3a       	cp.w	r10,19
800099dc:	e0 88 00 1a 	brls	80009a10 <_realloc_r+0x130>
800099e0:	09 09       	ld.w	r9,r4++
800099e2:	8b 09       	st.w	r5[0x0],r9
800099e4:	09 09       	ld.w	r9,r4++
800099e6:	8f 39       	st.w	r7[0xc],r9
800099e8:	ee c9 ff f0 	sub	r9,r7,-16
800099ec:	59 ba       	cp.w	r10,27
800099ee:	e0 88 00 11 	brls	80009a10 <_realloc_r+0x130>
800099f2:	09 0b       	ld.w	r11,r4++
800099f4:	93 0b       	st.w	r9[0x0],r11
800099f6:	09 09       	ld.w	r9,r4++
800099f8:	8f 59       	st.w	r7[0x14],r9
800099fa:	ee c9 ff e8 	sub	r9,r7,-24
800099fe:	e0 4a 00 24 	cp.w	r10,36
80009a02:	c0 71       	brne	80009a10 <_realloc_r+0x130>
80009a04:	09 0a       	ld.w	r10,r4++
80009a06:	93 0a       	st.w	r9[0x0],r10
80009a08:	ee c9 ff e0 	sub	r9,r7,-32
80009a0c:	09 0a       	ld.w	r10,r4++
80009a0e:	8f 7a       	st.w	r7[0x1c],r10
80009a10:	09 0a       	ld.w	r10,r4++
80009a12:	12 aa       	st.w	r9++,r10
80009a14:	68 0a       	ld.w	r10,r4[0x0]
80009a16:	93 0a       	st.w	r9[0x0],r10
80009a18:	68 1a       	ld.w	r10,r4[0x4]
80009a1a:	93 1a       	st.w	r9[0x4],r10
80009a1c:	c0 78       	rjmp	80009a2a <_realloc_r+0x14a>
80009a1e:	50 08       	stdsp	sp[0x0],r8
80009a20:	08 9b       	mov	r11,r4
80009a22:	0a 9c       	mov	r12,r5
80009a24:	e0 a0 1d 9b 	rcall	8000d55a <memmove>
80009a28:	40 08       	lddsp	r8,sp[0x0]
80009a2a:	ee 06 00 09 	add	r9,r7,r6
80009a2e:	0c 13       	sub	r3,r6
80009a30:	a1 a3       	sbr	r3,0x0
80009a32:	93 13       	st.w	r9[0x4],r3
80009a34:	91 29       	st.w	r8[0x8],r9
80009a36:	04 9c       	mov	r12,r2
80009a38:	6e 18       	ld.w	r8,r7[0x4]
80009a3a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80009a3e:	10 46       	or	r6,r8
80009a40:	8f 16       	st.w	r7[0x4],r6
80009a42:	ca a8       	rjmp	80009b96 <_realloc_r+0x2b6>
80009a44:	14 03       	add	r3,r10
80009a46:	0c 33       	cp.w	r3,r6
80009a48:	c0 85       	brlt	80009a58 <_realloc_r+0x178>
80009a4a:	72 28       	ld.w	r8,r9[0x8]
80009a4c:	72 39       	ld.w	r9,r9[0xc]
80009a4e:	93 28       	st.w	r9[0x8],r8
80009a50:	91 39       	st.w	r8[0xc],r9
80009a52:	6e 28       	ld.w	r8,r7[0x8]
80009a54:	6e 39       	ld.w	r9,r7[0xc]
80009a56:	c0 78       	rjmp	80009a64 <_realloc_r+0x184>
80009a58:	f8 00 00 03 	add	r3,r12,r0
80009a5c:	0c 33       	cp.w	r3,r6
80009a5e:	c3 35       	brlt	80009ac4 <_realloc_r+0x1e4>
80009a60:	6e 39       	ld.w	r9,r7[0xc]
80009a62:	6e 28       	ld.w	r8,r7[0x8]
80009a64:	93 28       	st.w	r9[0x8],r8
80009a66:	91 39       	st.w	r8[0xc],r9
80009a68:	e0 ca 00 04 	sub	r10,r0,4
80009a6c:	ee cc ff f8 	sub	r12,r7,-8
80009a70:	e0 4a 00 24 	cp.w	r10,36
80009a74:	e0 8b 00 24 	brhi	80009abc <_realloc_r+0x1dc>
80009a78:	59 3a       	cp.w	r10,19
80009a7a:	e0 88 00 1a 	brls	80009aae <_realloc_r+0x1ce>
80009a7e:	09 08       	ld.w	r8,r4++
80009a80:	99 08       	st.w	r12[0x0],r8
80009a82:	09 08       	ld.w	r8,r4++
80009a84:	8f 38       	st.w	r7[0xc],r8
80009a86:	ee cc ff f0 	sub	r12,r7,-16
80009a8a:	59 ba       	cp.w	r10,27
80009a8c:	e0 88 00 11 	brls	80009aae <_realloc_r+0x1ce>
80009a90:	09 08       	ld.w	r8,r4++
80009a92:	99 08       	st.w	r12[0x0],r8
80009a94:	09 08       	ld.w	r8,r4++
80009a96:	8f 58       	st.w	r7[0x14],r8
80009a98:	ee cc ff e8 	sub	r12,r7,-24
80009a9c:	e0 4a 00 24 	cp.w	r10,36
80009aa0:	c0 71       	brne	80009aae <_realloc_r+0x1ce>
80009aa2:	09 08       	ld.w	r8,r4++
80009aa4:	99 08       	st.w	r12[0x0],r8
80009aa6:	ee cc ff e0 	sub	r12,r7,-32
80009aaa:	09 08       	ld.w	r8,r4++
80009aac:	8f 78       	st.w	r7[0x1c],r8
80009aae:	09 08       	ld.w	r8,r4++
80009ab0:	18 a8       	st.w	r12++,r8
80009ab2:	68 08       	ld.w	r8,r4[0x0]
80009ab4:	99 08       	st.w	r12[0x0],r8
80009ab6:	68 18       	ld.w	r8,r4[0x4]
80009ab8:	99 18       	st.w	r12[0x4],r8
80009aba:	c4 78       	rjmp	80009b48 <_realloc_r+0x268>
80009abc:	08 9b       	mov	r11,r4
80009abe:	e0 a0 1d 4e 	rcall	8000d55a <memmove>
80009ac2:	c4 38       	rjmp	80009b48 <_realloc_r+0x268>
80009ac4:	04 9c       	mov	r12,r2
80009ac6:	fe b0 fc 45 	rcall	80009350 <_malloc_r>
80009aca:	18 95       	mov	r5,r12
80009acc:	c3 a0       	breq	80009b40 <_realloc_r+0x260>
80009ace:	62 18       	ld.w	r8,r1[0x4]
80009ad0:	f8 c9 00 08 	sub	r9,r12,8
80009ad4:	a1 c8       	cbr	r8,0x0
80009ad6:	e2 08 00 08 	add	r8,r1,r8
80009ada:	10 39       	cp.w	r9,r8
80009adc:	c0 71       	brne	80009aea <_realloc_r+0x20a>
80009ade:	72 13       	ld.w	r3,r9[0x4]
80009ae0:	02 97       	mov	r7,r1
80009ae2:	e0 13 ff fc 	andl	r3,0xfffc
80009ae6:	00 03       	add	r3,r0
80009ae8:	c3 08       	rjmp	80009b48 <_realloc_r+0x268>
80009aea:	e0 ca 00 04 	sub	r10,r0,4
80009aee:	e0 4a 00 24 	cp.w	r10,36
80009af2:	e0 8b 00 20 	brhi	80009b32 <_realloc_r+0x252>
80009af6:	08 99       	mov	r9,r4
80009af8:	18 98       	mov	r8,r12
80009afa:	59 3a       	cp.w	r10,19
80009afc:	e0 88 00 14 	brls	80009b24 <_realloc_r+0x244>
80009b00:	13 0b       	ld.w	r11,r9++
80009b02:	10 ab       	st.w	r8++,r11
80009b04:	13 0b       	ld.w	r11,r9++
80009b06:	10 ab       	st.w	r8++,r11
80009b08:	59 ba       	cp.w	r10,27
80009b0a:	e0 88 00 0d 	brls	80009b24 <_realloc_r+0x244>
80009b0e:	13 0b       	ld.w	r11,r9++
80009b10:	10 ab       	st.w	r8++,r11
80009b12:	13 0b       	ld.w	r11,r9++
80009b14:	10 ab       	st.w	r8++,r11
80009b16:	e0 4a 00 24 	cp.w	r10,36
80009b1a:	c0 51       	brne	80009b24 <_realloc_r+0x244>
80009b1c:	13 0a       	ld.w	r10,r9++
80009b1e:	10 aa       	st.w	r8++,r10
80009b20:	13 0a       	ld.w	r10,r9++
80009b22:	10 aa       	st.w	r8++,r10
80009b24:	13 0a       	ld.w	r10,r9++
80009b26:	10 aa       	st.w	r8++,r10
80009b28:	72 0a       	ld.w	r10,r9[0x0]
80009b2a:	91 0a       	st.w	r8[0x0],r10
80009b2c:	72 19       	ld.w	r9,r9[0x4]
80009b2e:	91 19       	st.w	r8[0x4],r9
80009b30:	c0 48       	rjmp	80009b38 <_realloc_r+0x258>
80009b32:	08 9b       	mov	r11,r4
80009b34:	e0 a0 1d 13 	rcall	8000d55a <memmove>
80009b38:	08 9b       	mov	r11,r4
80009b3a:	04 9c       	mov	r12,r2
80009b3c:	e0 a0 1a 6c 	rcall	8000d014 <_free_r>
80009b40:	04 9c       	mov	r12,r2
80009b42:	c2 a8       	rjmp	80009b96 <_realloc_r+0x2b6>
80009b44:	00 93       	mov	r3,r0
80009b46:	02 97       	mov	r7,r1
80009b48:	e6 06 01 09 	sub	r9,r3,r6
80009b4c:	6e 18       	ld.w	r8,r7[0x4]
80009b4e:	58 f9       	cp.w	r9,15
80009b50:	e0 88 00 16 	brls	80009b7c <_realloc_r+0x29c>
80009b54:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80009b58:	ed e8 10 08 	or	r8,r6,r8
80009b5c:	8f 18       	st.w	r7[0x4],r8
80009b5e:	12 98       	mov	r8,r9
80009b60:	a1 a8       	sbr	r8,0x0
80009b62:	ee 06 00 0b 	add	r11,r7,r6
80009b66:	f6 09 00 09 	add	r9,r11,r9
80009b6a:	97 18       	st.w	r11[0x4],r8
80009b6c:	72 18       	ld.w	r8,r9[0x4]
80009b6e:	a1 a8       	sbr	r8,0x0
80009b70:	2f 8b       	sub	r11,-8
80009b72:	93 18       	st.w	r9[0x4],r8
80009b74:	04 9c       	mov	r12,r2
80009b76:	e0 a0 1a 4f 	rcall	8000d014 <_free_r>
80009b7a:	c0 b8       	rjmp	80009b90 <_realloc_r+0x2b0>
80009b7c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80009b80:	e7 e8 10 08 	or	r8,r3,r8
80009b84:	8f 18       	st.w	r7[0x4],r8
80009b86:	ee 03 00 03 	add	r3,r7,r3
80009b8a:	66 18       	ld.w	r8,r3[0x4]
80009b8c:	a1 a8       	sbr	r8,0x0
80009b8e:	87 18       	st.w	r3[0x4],r8
80009b90:	04 9c       	mov	r12,r2
80009b92:	ee c5 ff f8 	sub	r5,r7,-8
80009b96:	fe b0 e9 6b 	rcall	80006e6c <__malloc_unlock>
80009b9a:	0a 9c       	mov	r12,r5
80009b9c:	2f fd       	sub	sp,-4
80009b9e:	d8 32       	popm	r0-r7,pc

80009ba0 <_sbrk_r>:
80009ba0:	d4 21       	pushm	r4-r7,lr
80009ba2:	30 08       	mov	r8,0
80009ba4:	18 97       	mov	r7,r12
80009ba6:	e0 66 40 f4 	mov	r6,16628
80009baa:	16 9c       	mov	r12,r11
80009bac:	8d 08       	st.w	r6[0x0],r8
80009bae:	c9 1c       	rcall	80009cd0 <_sbrk>
80009bb0:	5b fc       	cp.w	r12,-1
80009bb2:	c0 51       	brne	80009bbc <_sbrk_r+0x1c>
80009bb4:	6c 08       	ld.w	r8,r6[0x0]
80009bb6:	58 08       	cp.w	r8,0
80009bb8:	ef f8 1a 03 	st.wne	r7[0xc],r8
80009bbc:	d8 22       	popm	r4-r7,pc
80009bbe:	d7 03       	nop

80009bc0 <sprintf>:
80009bc0:	d4 01       	pushm	lr
80009bc2:	21 7d       	sub	sp,92
80009bc4:	e0 68 ff ff 	mov	r8,65535
80009bc8:	ea 18 7f ff 	orh	r8,0x7fff
80009bcc:	50 58       	stdsp	sp[0x14],r8
80009bce:	50 28       	stdsp	sp[0x8],r8
80009bd0:	e0 68 02 08 	mov	r8,520
80009bd4:	ba 68       	st.h	sp[0xc],r8
80009bd6:	3f f8       	mov	r8,-1
80009bd8:	ba 78       	st.h	sp[0xe],r8
80009bda:	e0 68 0a 30 	mov	r8,2608
80009bde:	50 4c       	stdsp	sp[0x10],r12
80009be0:	16 9a       	mov	r10,r11
80009be2:	50 0c       	stdsp	sp[0x0],r12
80009be4:	fa c9 ff a0 	sub	r9,sp,-96
80009be8:	70 0c       	ld.w	r12,r8[0x0]
80009bea:	1a 9b       	mov	r11,sp
80009bec:	e0 a0 02 26 	rcall	8000a038 <_vfprintf_r>
80009bf0:	30 09       	mov	r9,0
80009bf2:	40 08       	lddsp	r8,sp[0x0]
80009bf4:	b0 89       	st.b	r8[0x0],r9
80009bf6:	2e 9d       	sub	sp,-92
80009bf8:	d8 02       	popm	pc
80009bfa:	d7 03       	nop

80009bfc <strlen>:
80009bfc:	30 09       	mov	r9,0
80009bfe:	18 98       	mov	r8,r12
80009c00:	c0 28       	rjmp	80009c04 <strlen+0x8>
80009c02:	2f f8       	sub	r8,-1
80009c04:	11 8a       	ld.ub	r10,r8[0x0]
80009c06:	f2 0a 18 00 	cp.b	r10,r9
80009c0a:	cf c1       	brne	80009c02 <strlen+0x6>
80009c0c:	f0 0c 01 0c 	sub	r12,r8,r12
80009c10:	5e fc       	retal	r12
80009c12:	d7 03       	nop

80009c14 <strncpy>:
80009c14:	30 08       	mov	r8,0
80009c16:	10 3a       	cp.w	r10,r8
80009c18:	5e 0c       	reteq	r12
80009c1a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80009c1e:	f8 08 0b 09 	st.b	r12[r8],r9
80009c22:	2f f8       	sub	r8,-1
80009c24:	58 09       	cp.w	r9,0
80009c26:	cf 81       	brne	80009c16 <strncpy+0x2>
80009c28:	10 3a       	cp.w	r10,r8
80009c2a:	5e 0c       	reteq	r12
80009c2c:	f8 08 0b 09 	st.b	r12[r8],r9
80009c30:	2f f8       	sub	r8,-1
80009c32:	cf bb       	rjmp	80009c28 <strncpy+0x14>

80009c34 <_close>:
80009c34:	30 28       	mov	r8,2
80009c36:	d6 73       	breakpoint
80009c38:	3f fc       	mov	r12,-1
80009c3a:	35 8b       	mov	r11,88
80009c3c:	58 0c       	cp.w	r12,0
80009c3e:	5e 4c       	retge	r12
80009c40:	e0 6a 40 f4 	mov	r10,16628
80009c44:	95 0b       	st.w	r10[0x0],r11
80009c46:	5e fc       	retal	r12

80009c48 <_lseek>:
80009c48:	30 58       	mov	r8,5
80009c4a:	d6 73       	breakpoint
80009c4c:	3f fc       	mov	r12,-1
80009c4e:	35 8b       	mov	r11,88
80009c50:	58 0c       	cp.w	r12,0
80009c52:	5e 4c       	retge	r12
80009c54:	e0 6a 40 f4 	mov	r10,16628
80009c58:	95 0b       	st.w	r10[0x0],r11
80009c5a:	5e fc       	retal	r12

80009c5c <isatty>:
80009c5c:	30 b8       	mov	r8,11
80009c5e:	d6 73       	breakpoint
80009c60:	3f fc       	mov	r12,-1
80009c62:	35 8b       	mov	r11,88
80009c64:	58 0c       	cp.w	r12,0
80009c66:	5e 4c       	retge	r12
80009c68:	e0 6a 40 f4 	mov	r10,16628
80009c6c:	95 0b       	st.w	r10[0x0],r11
80009c6e:	5e fc       	retal	r12

80009c70 <_fstat_host>:
80009c70:	30 98       	mov	r8,9
80009c72:	d6 73       	breakpoint
80009c74:	3f fc       	mov	r12,-1
80009c76:	35 8b       	mov	r11,88
80009c78:	58 0c       	cp.w	r12,0
80009c7a:	5e 4c       	retge	r12
80009c7c:	e0 6a 40 f4 	mov	r10,16628
80009c80:	95 0b       	st.w	r10[0x0],r11
80009c82:	5e fc       	retal	r12

80009c84 <_fstat>:
80009c84:	d4 21       	pushm	r4-r7,lr
80009c86:	21 0d       	sub	sp,64
80009c88:	16 97       	mov	r7,r11
80009c8a:	1a 9b       	mov	r11,sp
80009c8c:	cf 2f       	rcall	80009c70 <_fstat_host>
80009c8e:	c0 34       	brge	80009c94 <_fstat+0x10>
80009c90:	3f fc       	mov	r12,-1
80009c92:	c1 c8       	rjmp	80009cca <_fstat+0x46>
80009c94:	40 08       	lddsp	r8,sp[0x0]
80009c96:	ae 08       	st.h	r7[0x0],r8
80009c98:	40 18       	lddsp	r8,sp[0x4]
80009c9a:	ae 18       	st.h	r7[0x2],r8
80009c9c:	40 28       	lddsp	r8,sp[0x8]
80009c9e:	8f 18       	st.w	r7[0x4],r8
80009ca0:	40 38       	lddsp	r8,sp[0xc]
80009ca2:	ae 48       	st.h	r7[0x8],r8
80009ca4:	40 48       	lddsp	r8,sp[0x10]
80009ca6:	ae 58       	st.h	r7[0xa],r8
80009ca8:	40 58       	lddsp	r8,sp[0x14]
80009caa:	ae 68       	st.h	r7[0xc],r8
80009cac:	40 68       	lddsp	r8,sp[0x18]
80009cae:	ae 78       	st.h	r7[0xe],r8
80009cb0:	40 88       	lddsp	r8,sp[0x20]
80009cb2:	8f 48       	st.w	r7[0x10],r8
80009cb4:	40 a8       	lddsp	r8,sp[0x28]
80009cb6:	8f b8       	st.w	r7[0x2c],r8
80009cb8:	40 c8       	lddsp	r8,sp[0x30]
80009cba:	8f c8       	st.w	r7[0x30],r8
80009cbc:	40 d8       	lddsp	r8,sp[0x34]
80009cbe:	8f 58       	st.w	r7[0x14],r8
80009cc0:	40 e8       	lddsp	r8,sp[0x38]
80009cc2:	30 0c       	mov	r12,0
80009cc4:	8f 78       	st.w	r7[0x1c],r8
80009cc6:	40 f8       	lddsp	r8,sp[0x3c]
80009cc8:	8f 98       	st.w	r7[0x24],r8
80009cca:	2f 0d       	sub	sp,-64
80009ccc:	d8 22       	popm	r4-r7,pc
80009cce:	d7 03       	nop

80009cd0 <_sbrk>:
80009cd0:	d4 01       	pushm	lr
80009cd2:	e0 68 0d 70 	mov	r8,3440
80009cd6:	70 09       	ld.w	r9,r8[0x0]
80009cd8:	58 09       	cp.w	r9,0
80009cda:	c0 41       	brne	80009ce2 <_sbrk+0x12>
80009cdc:	e0 69 40 f8 	mov	r9,16632
80009ce0:	91 09       	st.w	r8[0x0],r9
80009ce2:	e0 69 0d 70 	mov	r9,3440
80009ce6:	e0 7a 70 00 	mov	r10,94208
80009cea:	72 08       	ld.w	r8,r9[0x0]
80009cec:	f0 0c 00 0c 	add	r12,r8,r12
80009cf0:	14 3c       	cp.w	r12,r10
80009cf2:	e0 8b 00 04 	brhi	80009cfa <_sbrk+0x2a>
80009cf6:	93 0c       	st.w	r9[0x0],r12
80009cf8:	c0 68       	rjmp	80009d04 <_sbrk+0x34>
80009cfa:	e0 a0 18 15 	rcall	8000cd24 <__errno>
80009cfe:	30 c8       	mov	r8,12
80009d00:	99 08       	st.w	r12[0x0],r8
80009d02:	3f f8       	mov	r8,-1
80009d04:	10 9c       	mov	r12,r8
80009d06:	d8 02       	popm	pc

80009d08 <get_arg>:
80009d08:	d4 31       	pushm	r0-r7,lr
80009d0a:	20 8d       	sub	sp,32
80009d0c:	fa c4 ff bc 	sub	r4,sp,-68
80009d10:	50 4b       	stdsp	sp[0x10],r11
80009d12:	68 2e       	ld.w	lr,r4[0x8]
80009d14:	50 58       	stdsp	sp[0x14],r8
80009d16:	12 96       	mov	r6,r9
80009d18:	7c 0b       	ld.w	r11,lr[0x0]
80009d1a:	70 05       	ld.w	r5,r8[0x0]
80009d1c:	50 6e       	stdsp	sp[0x18],lr
80009d1e:	58 0b       	cp.w	r11,0
80009d20:	f4 0b 17 00 	moveq	r11,r10
80009d24:	68 03       	ld.w	r3,r4[0x0]
80009d26:	68 11       	ld.w	r1,r4[0x4]
80009d28:	40 49       	lddsp	r9,sp[0x10]
80009d2a:	30 08       	mov	r8,0
80009d2c:	c2 89       	rjmp	80009f7c <get_arg+0x274>
80009d2e:	2f fb       	sub	r11,-1
80009d30:	32 5c       	mov	r12,37
80009d32:	17 8a       	ld.ub	r10,r11[0x0]
80009d34:	f8 0a 18 00 	cp.b	r10,r12
80009d38:	5f 1e       	srne	lr
80009d3a:	f0 0a 18 00 	cp.b	r10,r8
80009d3e:	5f 1c       	srne	r12
80009d40:	fd ec 00 0c 	and	r12,lr,r12
80009d44:	f0 0c 18 00 	cp.b	r12,r8
80009d48:	cf 31       	brne	80009d2e <get_arg+0x26>
80009d4a:	58 0a       	cp.w	r10,0
80009d4c:	e0 80 01 25 	breq	80009f96 <get_arg+0x28e>
80009d50:	30 0c       	mov	r12,0
80009d52:	3f fa       	mov	r10,-1
80009d54:	18 90       	mov	r0,r12
80009d56:	50 3a       	stdsp	sp[0xc],r10
80009d58:	18 94       	mov	r4,r12
80009d5a:	18 92       	mov	r2,r12
80009d5c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80009d60:	16 97       	mov	r7,r11
80009d62:	50 7c       	stdsp	sp[0x1c],r12
80009d64:	fe cc a6 cc 	sub	r12,pc,-22836
80009d68:	0f 3a       	ld.ub	r10,r7++
80009d6a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80009d6e:	40 7c       	lddsp	r12,sp[0x1c]
80009d70:	1c 0c       	add	r12,lr
80009d72:	fe ce a7 a2 	sub	lr,pc,-22622
80009d76:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80009d7a:	20 1e       	sub	lr,1
80009d7c:	50 0e       	stdsp	sp[0x0],lr
80009d7e:	fe ce a8 1a 	sub	lr,pc,-22502
80009d82:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80009d86:	50 7c       	stdsp	sp[0x1c],r12
80009d88:	40 0c       	lddsp	r12,sp[0x0]
80009d8a:	58 7c       	cp.w	r12,7
80009d8c:	e0 8b 00 f1 	brhi	80009f6e <get_arg+0x266>
80009d90:	fe ce a9 cc 	sub	lr,pc,-22068
80009d94:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80009d98:	36 8b       	mov	r11,104
80009d9a:	f6 0a 18 00 	cp.b	r10,r11
80009d9e:	e0 80 00 e8 	breq	80009f6e <get_arg+0x266>
80009da2:	37 1b       	mov	r11,113
80009da4:	f6 0a 18 00 	cp.b	r10,r11
80009da8:	c0 70       	breq	80009db6 <get_arg+0xae>
80009daa:	34 cb       	mov	r11,76
80009dac:	f6 0a 18 00 	cp.b	r10,r11
80009db0:	c0 51       	brne	80009dba <get_arg+0xb2>
80009db2:	a3 b4       	sbr	r4,0x3
80009db4:	cd d8       	rjmp	80009f6e <get_arg+0x266>
80009db6:	a5 b4       	sbr	r4,0x5
80009db8:	cd b8       	rjmp	80009f6e <get_arg+0x266>
80009dba:	08 9a       	mov	r10,r4
80009dbc:	0e 9b       	mov	r11,r7
80009dbe:	a5 aa       	sbr	r10,0x4
80009dc0:	17 3c       	ld.ub	r12,r11++
80009dc2:	a5 b4       	sbr	r4,0x5
80009dc4:	36 ce       	mov	lr,108
80009dc6:	fc 0c 18 00 	cp.b	r12,lr
80009dca:	e0 80 00 d3 	breq	80009f70 <get_arg+0x268>
80009dce:	14 94       	mov	r4,r10
80009dd0:	cc f8       	rjmp	80009f6e <get_arg+0x266>
80009dd2:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80009dd6:	36 7c       	mov	r12,103
80009dd8:	f8 0a 18 00 	cp.b	r10,r12
80009ddc:	e0 8b 00 27 	brhi	80009e2a <get_arg+0x122>
80009de0:	36 5b       	mov	r11,101
80009de2:	f6 0a 18 00 	cp.b	r10,r11
80009de6:	c4 82       	brcc	80009e76 <get_arg+0x16e>
80009de8:	34 fb       	mov	r11,79
80009dea:	f6 0a 18 00 	cp.b	r10,r11
80009dee:	c4 80       	breq	80009e7e <get_arg+0x176>
80009df0:	e0 8b 00 0c 	brhi	80009e08 <get_arg+0x100>
80009df4:	34 5b       	mov	r11,69
80009df6:	f6 0a 18 00 	cp.b	r10,r11
80009dfa:	c3 e0       	breq	80009e76 <get_arg+0x16e>
80009dfc:	34 7b       	mov	r11,71
80009dfe:	f6 0a 18 00 	cp.b	r10,r11
80009e02:	c3 a0       	breq	80009e76 <get_arg+0x16e>
80009e04:	34 4b       	mov	r11,68
80009e06:	c0 88       	rjmp	80009e16 <get_arg+0x10e>
80009e08:	35 8b       	mov	r11,88
80009e0a:	f6 0a 18 00 	cp.b	r10,r11
80009e0e:	c2 c0       	breq	80009e66 <get_arg+0x15e>
80009e10:	e0 8b 00 07 	brhi	80009e1e <get_arg+0x116>
80009e14:	35 5b       	mov	r11,85
80009e16:	f6 0a 18 00 	cp.b	r10,r11
80009e1a:	c3 51       	brne	80009e84 <get_arg+0x17c>
80009e1c:	c3 18       	rjmp	80009e7e <get_arg+0x176>
80009e1e:	36 3b       	mov	r11,99
80009e20:	f6 0a 18 00 	cp.b	r10,r11
80009e24:	c2 f0       	breq	80009e82 <get_arg+0x17a>
80009e26:	36 4b       	mov	r11,100
80009e28:	c0 e8       	rjmp	80009e44 <get_arg+0x13c>
80009e2a:	37 0b       	mov	r11,112
80009e2c:	f6 0a 18 00 	cp.b	r10,r11
80009e30:	c2 50       	breq	80009e7a <get_arg+0x172>
80009e32:	e0 8b 00 0d 	brhi	80009e4c <get_arg+0x144>
80009e36:	36 eb       	mov	r11,110
80009e38:	f6 0a 18 00 	cp.b	r10,r11
80009e3c:	c1 f0       	breq	80009e7a <get_arg+0x172>
80009e3e:	e0 8b 00 14 	brhi	80009e66 <get_arg+0x15e>
80009e42:	36 9b       	mov	r11,105
80009e44:	f6 0a 18 00 	cp.b	r10,r11
80009e48:	c1 e1       	brne	80009e84 <get_arg+0x17c>
80009e4a:	c0 e8       	rjmp	80009e66 <get_arg+0x15e>
80009e4c:	37 5b       	mov	r11,117
80009e4e:	f6 0a 18 00 	cp.b	r10,r11
80009e52:	c0 a0       	breq	80009e66 <get_arg+0x15e>
80009e54:	37 8b       	mov	r11,120
80009e56:	f6 0a 18 00 	cp.b	r10,r11
80009e5a:	c0 60       	breq	80009e66 <get_arg+0x15e>
80009e5c:	37 3b       	mov	r11,115
80009e5e:	f6 0a 18 00 	cp.b	r10,r11
80009e62:	c1 11       	brne	80009e84 <get_arg+0x17c>
80009e64:	c0 b8       	rjmp	80009e7a <get_arg+0x172>
80009e66:	ed b4 00 04 	bld	r4,0x4
80009e6a:	c0 a0       	breq	80009e7e <get_arg+0x176>
80009e6c:	ed b4 00 05 	bld	r4,0x5
80009e70:	c0 91       	brne	80009e82 <get_arg+0x17a>
80009e72:	30 20       	mov	r0,2
80009e74:	c0 88       	rjmp	80009e84 <get_arg+0x17c>
80009e76:	30 40       	mov	r0,4
80009e78:	c0 68       	rjmp	80009e84 <get_arg+0x17c>
80009e7a:	30 30       	mov	r0,3
80009e7c:	c0 48       	rjmp	80009e84 <get_arg+0x17c>
80009e7e:	30 10       	mov	r0,1
80009e80:	c0 28       	rjmp	80009e84 <get_arg+0x17c>
80009e82:	30 00       	mov	r0,0
80009e84:	40 3b       	lddsp	r11,sp[0xc]
80009e86:	5b fb       	cp.w	r11,-1
80009e88:	c0 40       	breq	80009e90 <get_arg+0x188>
80009e8a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80009e8e:	c7 08       	rjmp	80009f6e <get_arg+0x266>
80009e90:	58 60       	cp.w	r0,6
80009e92:	e0 8b 00 6e 	brhi	80009f6e <get_arg+0x266>
80009e96:	6c 0a       	ld.w	r10,r6[0x0]
80009e98:	ea cc ff ff 	sub	r12,r5,-1
80009e9c:	fe ce aa b8 	sub	lr,pc,-21832
80009ea0:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80009ea4:	f4 cb ff f8 	sub	r11,r10,-8
80009ea8:	8d 0b       	st.w	r6[0x0],r11
80009eaa:	f4 ea 00 00 	ld.d	r10,r10[0]
80009eae:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80009eb2:	c0 f8       	rjmp	80009ed0 <get_arg+0x1c8>
80009eb4:	f4 cb ff fc 	sub	r11,r10,-4
80009eb8:	8d 0b       	st.w	r6[0x0],r11
80009eba:	74 0a       	ld.w	r10,r10[0x0]
80009ebc:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80009ec0:	c0 88       	rjmp	80009ed0 <get_arg+0x1c8>
80009ec2:	f4 cb ff f8 	sub	r11,r10,-8
80009ec6:	8d 0b       	st.w	r6[0x0],r11
80009ec8:	f4 ea 00 00 	ld.d	r10,r10[0]
80009ecc:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80009ed0:	0e 9b       	mov	r11,r7
80009ed2:	18 95       	mov	r5,r12
80009ed4:	c4 e8       	rjmp	80009f70 <get_arg+0x268>
80009ed6:	62 0a       	ld.w	r10,r1[0x0]
80009ed8:	5b fa       	cp.w	r10,-1
80009eda:	c0 b1       	brne	80009ef0 <get_arg+0x1e8>
80009edc:	50 19       	stdsp	sp[0x4],r9
80009ede:	50 28       	stdsp	sp[0x8],r8
80009ee0:	e0 6a 00 80 	mov	r10,128
80009ee4:	30 0b       	mov	r11,0
80009ee6:	02 9c       	mov	r12,r1
80009ee8:	fe b0 fc f4 	rcall	800098d0 <memset>
80009eec:	40 28       	lddsp	r8,sp[0x8]
80009eee:	40 19       	lddsp	r9,sp[0x4]
80009ef0:	e4 cc 00 01 	sub	r12,r2,1
80009ef4:	0e 9b       	mov	r11,r7
80009ef6:	50 3c       	stdsp	sp[0xc],r12
80009ef8:	f2 0c 0c 49 	max	r9,r9,r12
80009efc:	c3 a8       	rjmp	80009f70 <get_arg+0x268>
80009efe:	62 0a       	ld.w	r10,r1[0x0]
80009f00:	5b fa       	cp.w	r10,-1
80009f02:	c0 b1       	brne	80009f18 <get_arg+0x210>
80009f04:	50 19       	stdsp	sp[0x4],r9
80009f06:	50 28       	stdsp	sp[0x8],r8
80009f08:	e0 6a 00 80 	mov	r10,128
80009f0c:	30 0b       	mov	r11,0
80009f0e:	02 9c       	mov	r12,r1
80009f10:	fe b0 fc e0 	rcall	800098d0 <memset>
80009f14:	40 28       	lddsp	r8,sp[0x8]
80009f16:	40 19       	lddsp	r9,sp[0x4]
80009f18:	20 12       	sub	r2,1
80009f1a:	30 0a       	mov	r10,0
80009f1c:	0e 9b       	mov	r11,r7
80009f1e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80009f22:	f2 02 0c 49 	max	r9,r9,r2
80009f26:	c2 58       	rjmp	80009f70 <get_arg+0x268>
80009f28:	16 97       	mov	r7,r11
80009f2a:	6c 0a       	ld.w	r10,r6[0x0]
80009f2c:	f4 cb ff fc 	sub	r11,r10,-4
80009f30:	8d 0b       	st.w	r6[0x0],r11
80009f32:	74 0a       	ld.w	r10,r10[0x0]
80009f34:	0e 9b       	mov	r11,r7
80009f36:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80009f3a:	2f f5       	sub	r5,-1
80009f3c:	c1 a8       	rjmp	80009f70 <get_arg+0x268>
80009f3e:	f4 c2 00 30 	sub	r2,r10,48
80009f42:	c0 68       	rjmp	80009f4e <get_arg+0x246>
80009f44:	e4 02 00 22 	add	r2,r2,r2<<0x2
80009f48:	2f f7       	sub	r7,-1
80009f4a:	f4 02 00 12 	add	r2,r10,r2<<0x1
80009f4e:	0f 8a       	ld.ub	r10,r7[0x0]
80009f50:	58 0a       	cp.w	r10,0
80009f52:	c0 e0       	breq	80009f6e <get_arg+0x266>
80009f54:	23 0a       	sub	r10,48
80009f56:	58 9a       	cp.w	r10,9
80009f58:	fe 98 ff f6 	brls	80009f44 <get_arg+0x23c>
80009f5c:	c0 98       	rjmp	80009f6e <get_arg+0x266>
80009f5e:	2f f7       	sub	r7,-1
80009f60:	0f 8a       	ld.ub	r10,r7[0x0]
80009f62:	58 0a       	cp.w	r10,0
80009f64:	c0 50       	breq	80009f6e <get_arg+0x266>
80009f66:	23 0a       	sub	r10,48
80009f68:	58 9a       	cp.w	r10,9
80009f6a:	fe 98 ff fa 	brls	80009f5e <get_arg+0x256>
80009f6e:	0e 9b       	mov	r11,r7
80009f70:	40 7c       	lddsp	r12,sp[0x1c]
80009f72:	30 ba       	mov	r10,11
80009f74:	f4 0c 18 00 	cp.b	r12,r10
80009f78:	fe 91 fe f2 	brne	80009d5c <get_arg+0x54>
80009f7c:	40 42       	lddsp	r2,sp[0x10]
80009f7e:	17 8c       	ld.ub	r12,r11[0x0]
80009f80:	0a 32       	cp.w	r2,r5
80009f82:	5f 4a       	srge	r10
80009f84:	f0 0c 18 00 	cp.b	r12,r8
80009f88:	5f 1c       	srne	r12
80009f8a:	f9 ea 00 0a 	and	r10,r12,r10
80009f8e:	f0 0a 18 00 	cp.b	r10,r8
80009f92:	fe 91 fe cf 	brne	80009d30 <get_arg+0x28>
80009f96:	30 08       	mov	r8,0
80009f98:	40 4e       	lddsp	lr,sp[0x10]
80009f9a:	17 8a       	ld.ub	r10,r11[0x0]
80009f9c:	e2 05 00 21 	add	r1,r1,r5<<0x2
80009fa0:	f0 0a 18 00 	cp.b	r10,r8
80009fa4:	fc 09 17 10 	movne	r9,lr
80009fa8:	e6 05 00 38 	add	r8,r3,r5<<0x3
80009fac:	06 9e       	mov	lr,r3
80009fae:	c2 a8       	rjmp	8000a002 <get_arg+0x2fa>
80009fb0:	62 0a       	ld.w	r10,r1[0x0]
80009fb2:	58 3a       	cp.w	r10,3
80009fb4:	c1 e0       	breq	80009ff0 <get_arg+0x2e8>
80009fb6:	e0 89 00 07 	brgt	80009fc4 <get_arg+0x2bc>
80009fba:	58 1a       	cp.w	r10,1
80009fbc:	c1 a0       	breq	80009ff0 <get_arg+0x2e8>
80009fbe:	58 2a       	cp.w	r10,2
80009fc0:	c1 81       	brne	80009ff0 <get_arg+0x2e8>
80009fc2:	c0 58       	rjmp	80009fcc <get_arg+0x2c4>
80009fc4:	58 5a       	cp.w	r10,5
80009fc6:	c0 c0       	breq	80009fde <get_arg+0x2d6>
80009fc8:	c0 b5       	brlt	80009fde <get_arg+0x2d6>
80009fca:	c1 38       	rjmp	80009ff0 <get_arg+0x2e8>
80009fcc:	6c 0a       	ld.w	r10,r6[0x0]
80009fce:	f4 cc ff f8 	sub	r12,r10,-8
80009fd2:	8d 0c       	st.w	r6[0x0],r12
80009fd4:	f4 e2 00 00 	ld.d	r2,r10[0]
80009fd8:	f0 e3 00 00 	st.d	r8[0],r2
80009fdc:	c1 08       	rjmp	80009ffc <get_arg+0x2f4>
80009fde:	6c 0a       	ld.w	r10,r6[0x0]
80009fe0:	f4 cc ff f8 	sub	r12,r10,-8
80009fe4:	8d 0c       	st.w	r6[0x0],r12
80009fe6:	f4 e2 00 00 	ld.d	r2,r10[0]
80009fea:	f0 e3 00 00 	st.d	r8[0],r2
80009fee:	c0 78       	rjmp	80009ffc <get_arg+0x2f4>
80009ff0:	6c 0a       	ld.w	r10,r6[0x0]
80009ff2:	f4 cc ff fc 	sub	r12,r10,-4
80009ff6:	8d 0c       	st.w	r6[0x0],r12
80009ff8:	74 0a       	ld.w	r10,r10[0x0]
80009ffa:	91 0a       	st.w	r8[0x0],r10
80009ffc:	2f f5       	sub	r5,-1
80009ffe:	2f 88       	sub	r8,-8
8000a000:	2f c1       	sub	r1,-4
8000a002:	12 35       	cp.w	r5,r9
8000a004:	fe 9a ff d6 	brle	80009fb0 <get_arg+0x2a8>
8000a008:	1c 93       	mov	r3,lr
8000a00a:	40 52       	lddsp	r2,sp[0x14]
8000a00c:	40 6e       	lddsp	lr,sp[0x18]
8000a00e:	85 05       	st.w	r2[0x0],r5
8000a010:	9d 0b       	st.w	lr[0x0],r11
8000a012:	40 4b       	lddsp	r11,sp[0x10]
8000a014:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000a018:	2f 8d       	sub	sp,-32
8000a01a:	d8 32       	popm	r0-r7,pc

8000a01c <__sprint_r>:
8000a01c:	d4 21       	pushm	r4-r7,lr
8000a01e:	14 97       	mov	r7,r10
8000a020:	74 28       	ld.w	r8,r10[0x8]
8000a022:	58 08       	cp.w	r8,0
8000a024:	c0 41       	brne	8000a02c <__sprint_r+0x10>
8000a026:	95 18       	st.w	r10[0x4],r8
8000a028:	10 9c       	mov	r12,r8
8000a02a:	d8 22       	popm	r4-r7,pc
8000a02c:	e0 a0 18 ba 	rcall	8000d1a0 <__sfvwrite_r>
8000a030:	30 08       	mov	r8,0
8000a032:	8f 18       	st.w	r7[0x4],r8
8000a034:	8f 28       	st.w	r7[0x8],r8
8000a036:	d8 22       	popm	r4-r7,pc

8000a038 <_vfprintf_r>:
8000a038:	d4 31       	pushm	r0-r7,lr
8000a03a:	fa cd 06 bc 	sub	sp,sp,1724
8000a03e:	51 09       	stdsp	sp[0x40],r9
8000a040:	16 91       	mov	r1,r11
8000a042:	14 97       	mov	r7,r10
8000a044:	18 95       	mov	r5,r12
8000a046:	e0 a0 1a 1d 	rcall	8000d480 <_localeconv_r>
8000a04a:	78 0c       	ld.w	r12,r12[0x0]
8000a04c:	50 cc       	stdsp	sp[0x30],r12
8000a04e:	58 05       	cp.w	r5,0
8000a050:	c0 70       	breq	8000a05e <_vfprintf_r+0x26>
8000a052:	6a 68       	ld.w	r8,r5[0x18]
8000a054:	58 08       	cp.w	r8,0
8000a056:	c0 41       	brne	8000a05e <_vfprintf_r+0x26>
8000a058:	0a 9c       	mov	r12,r5
8000a05a:	e0 a0 17 43 	rcall	8000cee0 <__sinit>
8000a05e:	fe c8 a8 b6 	sub	r8,pc,-22346
8000a062:	10 31       	cp.w	r1,r8
8000a064:	c0 31       	brne	8000a06a <_vfprintf_r+0x32>
8000a066:	6a 01       	ld.w	r1,r5[0x0]
8000a068:	c0 c8       	rjmp	8000a080 <_vfprintf_r+0x48>
8000a06a:	fe c8 a8 a2 	sub	r8,pc,-22366
8000a06e:	10 31       	cp.w	r1,r8
8000a070:	c0 31       	brne	8000a076 <_vfprintf_r+0x3e>
8000a072:	6a 11       	ld.w	r1,r5[0x4]
8000a074:	c0 68       	rjmp	8000a080 <_vfprintf_r+0x48>
8000a076:	fe c8 a8 8e 	sub	r8,pc,-22386
8000a07a:	10 31       	cp.w	r1,r8
8000a07c:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000a080:	82 68       	ld.sh	r8,r1[0xc]
8000a082:	ed b8 00 03 	bld	r8,0x3
8000a086:	c0 41       	brne	8000a08e <_vfprintf_r+0x56>
8000a088:	62 48       	ld.w	r8,r1[0x10]
8000a08a:	58 08       	cp.w	r8,0
8000a08c:	c0 71       	brne	8000a09a <_vfprintf_r+0x62>
8000a08e:	02 9b       	mov	r11,r1
8000a090:	0a 9c       	mov	r12,r5
8000a092:	e0 a0 0f 5d 	rcall	8000bf4c <__swsetup_r>
8000a096:	e0 81 0f 54 	brne	8000bf3e <_vfprintf_r+0x1f06>
8000a09a:	82 68       	ld.sh	r8,r1[0xc]
8000a09c:	10 99       	mov	r9,r8
8000a09e:	e2 19 00 1a 	andl	r9,0x1a,COH
8000a0a2:	58 a9       	cp.w	r9,10
8000a0a4:	c3 c1       	brne	8000a11c <_vfprintf_r+0xe4>
8000a0a6:	82 79       	ld.sh	r9,r1[0xe]
8000a0a8:	30 0a       	mov	r10,0
8000a0aa:	f4 09 19 00 	cp.h	r9,r10
8000a0ae:	c3 75       	brlt	8000a11c <_vfprintf_r+0xe4>
8000a0b0:	a1 d8       	cbr	r8,0x1
8000a0b2:	fb 58 05 d0 	st.h	sp[1488],r8
8000a0b6:	62 88       	ld.w	r8,r1[0x20]
8000a0b8:	fb 48 05 e4 	st.w	sp[1508],r8
8000a0bc:	62 a8       	ld.w	r8,r1[0x28]
8000a0be:	fb 48 05 ec 	st.w	sp[1516],r8
8000a0c2:	fa c8 ff bc 	sub	r8,sp,-68
8000a0c6:	fb 48 05 d4 	st.w	sp[1492],r8
8000a0ca:	fb 48 05 c4 	st.w	sp[1476],r8
8000a0ce:	e0 68 04 00 	mov	r8,1024
8000a0d2:	fb 48 05 d8 	st.w	sp[1496],r8
8000a0d6:	fb 48 05 cc 	st.w	sp[1484],r8
8000a0da:	30 08       	mov	r8,0
8000a0dc:	fb 59 05 d2 	st.h	sp[1490],r9
8000a0e0:	0e 9a       	mov	r10,r7
8000a0e2:	41 09       	lddsp	r9,sp[0x40]
8000a0e4:	fa c7 fa 3c 	sub	r7,sp,-1476
8000a0e8:	fb 48 05 dc 	st.w	sp[1500],r8
8000a0ec:	0a 9c       	mov	r12,r5
8000a0ee:	0e 9b       	mov	r11,r7
8000a0f0:	ca 4f       	rcall	8000a038 <_vfprintf_r>
8000a0f2:	50 bc       	stdsp	sp[0x2c],r12
8000a0f4:	c0 95       	brlt	8000a106 <_vfprintf_r+0xce>
8000a0f6:	0e 9b       	mov	r11,r7
8000a0f8:	0a 9c       	mov	r12,r5
8000a0fa:	e0 a0 16 1b 	rcall	8000cd30 <_fflush_r>
8000a0fe:	40 be       	lddsp	lr,sp[0x2c]
8000a100:	f9 be 01 ff 	movne	lr,-1
8000a104:	50 be       	stdsp	sp[0x2c],lr
8000a106:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000a10a:	ed b8 00 06 	bld	r8,0x6
8000a10e:	e0 81 0f 1a 	brne	8000bf42 <_vfprintf_r+0x1f0a>
8000a112:	82 68       	ld.sh	r8,r1[0xc]
8000a114:	a7 a8       	sbr	r8,0x6
8000a116:	a2 68       	st.h	r1[0xc],r8
8000a118:	e0 8f 0f 15 	bral	8000bf42 <_vfprintf_r+0x1f0a>
8000a11c:	30 08       	mov	r8,0
8000a11e:	fb 48 06 b4 	st.w	sp[1716],r8
8000a122:	fb 48 06 90 	st.w	sp[1680],r8
8000a126:	fb 48 06 8c 	st.w	sp[1676],r8
8000a12a:	fb 48 06 b0 	st.w	sp[1712],r8
8000a12e:	30 08       	mov	r8,0
8000a130:	30 09       	mov	r9,0
8000a132:	50 a7       	stdsp	sp[0x28],r7
8000a134:	50 78       	stdsp	sp[0x1c],r8
8000a136:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a13a:	3f f8       	mov	r8,-1
8000a13c:	50 59       	stdsp	sp[0x14],r9
8000a13e:	fb 43 06 88 	st.w	sp[1672],r3
8000a142:	fb 48 05 44 	st.w	sp[1348],r8
8000a146:	12 9c       	mov	r12,r9
8000a148:	50 69       	stdsp	sp[0x18],r9
8000a14a:	50 d9       	stdsp	sp[0x34],r9
8000a14c:	50 e9       	stdsp	sp[0x38],r9
8000a14e:	50 b9       	stdsp	sp[0x2c],r9
8000a150:	12 97       	mov	r7,r9
8000a152:	0a 94       	mov	r4,r5
8000a154:	40 a2       	lddsp	r2,sp[0x28]
8000a156:	32 5a       	mov	r10,37
8000a158:	30 08       	mov	r8,0
8000a15a:	c0 28       	rjmp	8000a15e <_vfprintf_r+0x126>
8000a15c:	2f f2       	sub	r2,-1
8000a15e:	05 89       	ld.ub	r9,r2[0x0]
8000a160:	f0 09 18 00 	cp.b	r9,r8
8000a164:	5f 1b       	srne	r11
8000a166:	f4 09 18 00 	cp.b	r9,r10
8000a16a:	5f 19       	srne	r9
8000a16c:	f3 eb 00 0b 	and	r11,r9,r11
8000a170:	f0 0b 18 00 	cp.b	r11,r8
8000a174:	cf 41       	brne	8000a15c <_vfprintf_r+0x124>
8000a176:	40 ab       	lddsp	r11,sp[0x28]
8000a178:	e4 0b 01 06 	sub	r6,r2,r11
8000a17c:	c1 e0       	breq	8000a1b8 <_vfprintf_r+0x180>
8000a17e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a182:	0c 08       	add	r8,r6
8000a184:	87 0b       	st.w	r3[0x0],r11
8000a186:	fb 48 06 90 	st.w	sp[1680],r8
8000a18a:	87 16       	st.w	r3[0x4],r6
8000a18c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a190:	2f f8       	sub	r8,-1
8000a192:	fb 48 06 8c 	st.w	sp[1676],r8
8000a196:	58 78       	cp.w	r8,7
8000a198:	e0 89 00 04 	brgt	8000a1a0 <_vfprintf_r+0x168>
8000a19c:	2f 83       	sub	r3,-8
8000a19e:	c0 a8       	rjmp	8000a1b2 <_vfprintf_r+0x17a>
8000a1a0:	fa ca f9 78 	sub	r10,sp,-1672
8000a1a4:	02 9b       	mov	r11,r1
8000a1a6:	08 9c       	mov	r12,r4
8000a1a8:	c3 af       	rcall	8000a01c <__sprint_r>
8000a1aa:	e0 81 0e c6 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000a1ae:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1b2:	40 ba       	lddsp	r10,sp[0x2c]
8000a1b4:	0c 0a       	add	r10,r6
8000a1b6:	50 ba       	stdsp	sp[0x2c],r10
8000a1b8:	05 89       	ld.ub	r9,r2[0x0]
8000a1ba:	30 08       	mov	r8,0
8000a1bc:	f0 09 18 00 	cp.b	r9,r8
8000a1c0:	e0 80 0e aa 	breq	8000bf14 <_vfprintf_r+0x1edc>
8000a1c4:	30 09       	mov	r9,0
8000a1c6:	fb 68 06 bb 	st.b	sp[1723],r8
8000a1ca:	0e 96       	mov	r6,r7
8000a1cc:	e4 c8 ff ff 	sub	r8,r2,-1
8000a1d0:	3f fe       	mov	lr,-1
8000a1d2:	50 93       	stdsp	sp[0x24],r3
8000a1d4:	50 41       	stdsp	sp[0x10],r1
8000a1d6:	0e 93       	mov	r3,r7
8000a1d8:	04 91       	mov	r1,r2
8000a1da:	50 89       	stdsp	sp[0x20],r9
8000a1dc:	50 a8       	stdsp	sp[0x28],r8
8000a1de:	50 2e       	stdsp	sp[0x8],lr
8000a1e0:	50 39       	stdsp	sp[0xc],r9
8000a1e2:	12 95       	mov	r5,r9
8000a1e4:	12 90       	mov	r0,r9
8000a1e6:	10 97       	mov	r7,r8
8000a1e8:	08 92       	mov	r2,r4
8000a1ea:	c0 78       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a1ec:	3f fc       	mov	r12,-1
8000a1ee:	08 97       	mov	r7,r4
8000a1f0:	50 2c       	stdsp	sp[0x8],r12
8000a1f2:	c0 38       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a1f4:	30 0b       	mov	r11,0
8000a1f6:	50 3b       	stdsp	sp[0xc],r11
8000a1f8:	0f 38       	ld.ub	r8,r7++
8000a1fa:	c0 28       	rjmp	8000a1fe <_vfprintf_r+0x1c6>
8000a1fc:	12 90       	mov	r0,r9
8000a1fe:	f0 c9 00 20 	sub	r9,r8,32
8000a202:	e0 49 00 58 	cp.w	r9,88
8000a206:	e0 8b 0a 30 	brhi	8000b666 <_vfprintf_r+0x162e>
8000a20a:	fe ca ae 0a 	sub	r10,pc,-20982
8000a20e:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000a212:	50 a7       	stdsp	sp[0x28],r7
8000a214:	50 80       	stdsp	sp[0x20],r0
8000a216:	0c 97       	mov	r7,r6
8000a218:	04 94       	mov	r4,r2
8000a21a:	06 96       	mov	r6,r3
8000a21c:	02 92       	mov	r2,r1
8000a21e:	fe c9 ab e2 	sub	r9,pc,-21534
8000a222:	40 93       	lddsp	r3,sp[0x24]
8000a224:	10 90       	mov	r0,r8
8000a226:	40 41       	lddsp	r1,sp[0x10]
8000a228:	50 d9       	stdsp	sp[0x34],r9
8000a22a:	e0 8f 08 8e 	bral	8000b346 <_vfprintf_r+0x130e>
8000a22e:	30 08       	mov	r8,0
8000a230:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000a234:	f0 09 18 00 	cp.b	r9,r8
8000a238:	ce 01       	brne	8000a1f8 <_vfprintf_r+0x1c0>
8000a23a:	32 08       	mov	r8,32
8000a23c:	c6 e8       	rjmp	8000a318 <_vfprintf_r+0x2e0>
8000a23e:	a1 a5       	sbr	r5,0x0
8000a240:	cd cb       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a242:	0f 89       	ld.ub	r9,r7[0x0]
8000a244:	f2 c8 00 30 	sub	r8,r9,48
8000a248:	58 98       	cp.w	r8,9
8000a24a:	e0 8b 00 1d 	brhi	8000a284 <_vfprintf_r+0x24c>
8000a24e:	ee c8 ff ff 	sub	r8,r7,-1
8000a252:	30 0b       	mov	r11,0
8000a254:	23 09       	sub	r9,48
8000a256:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000a25a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000a25e:	11 39       	ld.ub	r9,r8++
8000a260:	f2 ca 00 30 	sub	r10,r9,48
8000a264:	58 9a       	cp.w	r10,9
8000a266:	fe 98 ff f7 	brls	8000a254 <_vfprintf_r+0x21c>
8000a26a:	e0 49 00 24 	cp.w	r9,36
8000a26e:	cc 31       	brne	8000a1f4 <_vfprintf_r+0x1bc>
8000a270:	e0 4b 00 20 	cp.w	r11,32
8000a274:	e0 89 0e 60 	brgt	8000bf34 <_vfprintf_r+0x1efc>
8000a278:	20 1b       	sub	r11,1
8000a27a:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000a27e:	12 3b       	cp.w	r11,r9
8000a280:	c0 95       	brlt	8000a292 <_vfprintf_r+0x25a>
8000a282:	c1 08       	rjmp	8000a2a2 <_vfprintf_r+0x26a>
8000a284:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000a288:	ec ca ff ff 	sub	r10,r6,-1
8000a28c:	12 36       	cp.w	r6,r9
8000a28e:	c1 f5       	brlt	8000a2cc <_vfprintf_r+0x294>
8000a290:	c2 68       	rjmp	8000a2dc <_vfprintf_r+0x2a4>
8000a292:	fa ce f9 44 	sub	lr,sp,-1724
8000a296:	10 97       	mov	r7,r8
8000a298:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000a29c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000a2a0:	c3 58       	rjmp	8000a30a <_vfprintf_r+0x2d2>
8000a2a2:	10 97       	mov	r7,r8
8000a2a4:	fa c8 f9 50 	sub	r8,sp,-1712
8000a2a8:	1a d8       	st.w	--sp,r8
8000a2aa:	fa c8 fa b8 	sub	r8,sp,-1352
8000a2ae:	1a d8       	st.w	--sp,r8
8000a2b0:	fa c8 fb b4 	sub	r8,sp,-1100
8000a2b4:	02 9a       	mov	r10,r1
8000a2b6:	1a d8       	st.w	--sp,r8
8000a2b8:	04 9c       	mov	r12,r2
8000a2ba:	fa c8 f9 40 	sub	r8,sp,-1728
8000a2be:	fa c9 ff b4 	sub	r9,sp,-76
8000a2c2:	fe b0 fd 23 	rcall	80009d08 <get_arg>
8000a2c6:	2f dd       	sub	sp,-12
8000a2c8:	78 00       	ld.w	r0,r12[0x0]
8000a2ca:	c2 08       	rjmp	8000a30a <_vfprintf_r+0x2d2>
8000a2cc:	fa cc f9 44 	sub	r12,sp,-1724
8000a2d0:	14 96       	mov	r6,r10
8000a2d2:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000a2d6:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000a2da:	c1 88       	rjmp	8000a30a <_vfprintf_r+0x2d2>
8000a2dc:	41 08       	lddsp	r8,sp[0x40]
8000a2de:	59 f9       	cp.w	r9,31
8000a2e0:	e0 89 00 11 	brgt	8000a302 <_vfprintf_r+0x2ca>
8000a2e4:	f0 cb ff fc 	sub	r11,r8,-4
8000a2e8:	51 0b       	stdsp	sp[0x40],r11
8000a2ea:	70 00       	ld.w	r0,r8[0x0]
8000a2ec:	fa cb f9 44 	sub	r11,sp,-1724
8000a2f0:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000a2f4:	f1 40 fd 88 	st.w	r8[-632],r0
8000a2f8:	2f f9       	sub	r9,-1
8000a2fa:	14 96       	mov	r6,r10
8000a2fc:	fb 49 06 b4 	st.w	sp[1716],r9
8000a300:	c0 58       	rjmp	8000a30a <_vfprintf_r+0x2d2>
8000a302:	70 00       	ld.w	r0,r8[0x0]
8000a304:	14 96       	mov	r6,r10
8000a306:	2f c8       	sub	r8,-4
8000a308:	51 08       	stdsp	sp[0x40],r8
8000a30a:	58 00       	cp.w	r0,0
8000a30c:	fe 94 ff 76 	brge	8000a1f8 <_vfprintf_r+0x1c0>
8000a310:	5c 30       	neg	r0
8000a312:	a3 a5       	sbr	r5,0x2
8000a314:	c7 2b       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a316:	32 b8       	mov	r8,43
8000a318:	fb 68 06 bb 	st.b	sp[1723],r8
8000a31c:	c6 eb       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a31e:	0f 38       	ld.ub	r8,r7++
8000a320:	e0 48 00 2a 	cp.w	r8,42
8000a324:	c0 30       	breq	8000a32a <_vfprintf_r+0x2f2>
8000a326:	30 09       	mov	r9,0
8000a328:	c7 98       	rjmp	8000a41a <_vfprintf_r+0x3e2>
8000a32a:	0f 88       	ld.ub	r8,r7[0x0]
8000a32c:	f0 c9 00 30 	sub	r9,r8,48
8000a330:	58 99       	cp.w	r9,9
8000a332:	e0 8b 00 1f 	brhi	8000a370 <_vfprintf_r+0x338>
8000a336:	ee c4 ff ff 	sub	r4,r7,-1
8000a33a:	30 0b       	mov	r11,0
8000a33c:	23 08       	sub	r8,48
8000a33e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000a342:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000a346:	09 38       	ld.ub	r8,r4++
8000a348:	f0 c9 00 30 	sub	r9,r8,48
8000a34c:	58 99       	cp.w	r9,9
8000a34e:	fe 98 ff f7 	brls	8000a33c <_vfprintf_r+0x304>
8000a352:	e0 48 00 24 	cp.w	r8,36
8000a356:	fe 91 ff 4f 	brne	8000a1f4 <_vfprintf_r+0x1bc>
8000a35a:	e0 4b 00 20 	cp.w	r11,32
8000a35e:	e0 89 0d eb 	brgt	8000bf34 <_vfprintf_r+0x1efc>
8000a362:	20 1b       	sub	r11,1
8000a364:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a368:	10 3b       	cp.w	r11,r8
8000a36a:	c0 a5       	brlt	8000a37e <_vfprintf_r+0x346>
8000a36c:	c1 18       	rjmp	8000a38e <_vfprintf_r+0x356>
8000a36e:	d7 03       	nop
8000a370:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000a374:	ec c9 ff ff 	sub	r9,r6,-1
8000a378:	14 36       	cp.w	r6,r10
8000a37a:	c1 f5       	brlt	8000a3b8 <_vfprintf_r+0x380>
8000a37c:	c2 88       	rjmp	8000a3cc <_vfprintf_r+0x394>
8000a37e:	fa ca f9 44 	sub	r10,sp,-1724
8000a382:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000a386:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000a38a:	50 2b       	stdsp	sp[0x8],r11
8000a38c:	c3 c8       	rjmp	8000a404 <_vfprintf_r+0x3cc>
8000a38e:	fa c8 f9 50 	sub	r8,sp,-1712
8000a392:	1a d8       	st.w	--sp,r8
8000a394:	fa c8 fa b8 	sub	r8,sp,-1352
8000a398:	1a d8       	st.w	--sp,r8
8000a39a:	fa c8 fb b4 	sub	r8,sp,-1100
8000a39e:	02 9a       	mov	r10,r1
8000a3a0:	1a d8       	st.w	--sp,r8
8000a3a2:	04 9c       	mov	r12,r2
8000a3a4:	fa c8 f9 40 	sub	r8,sp,-1728
8000a3a8:	fa c9 ff b4 	sub	r9,sp,-76
8000a3ac:	fe b0 fc ae 	rcall	80009d08 <get_arg>
8000a3b0:	2f dd       	sub	sp,-12
8000a3b2:	78 0c       	ld.w	r12,r12[0x0]
8000a3b4:	50 2c       	stdsp	sp[0x8],r12
8000a3b6:	c2 78       	rjmp	8000a404 <_vfprintf_r+0x3cc>
8000a3b8:	12 96       	mov	r6,r9
8000a3ba:	0e 94       	mov	r4,r7
8000a3bc:	fa c9 f9 44 	sub	r9,sp,-1724
8000a3c0:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000a3c4:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000a3c8:	50 28       	stdsp	sp[0x8],r8
8000a3ca:	c1 d8       	rjmp	8000a404 <_vfprintf_r+0x3cc>
8000a3cc:	41 08       	lddsp	r8,sp[0x40]
8000a3ce:	59 fa       	cp.w	r10,31
8000a3d0:	e0 89 00 14 	brgt	8000a3f8 <_vfprintf_r+0x3c0>
8000a3d4:	f0 cb ff fc 	sub	r11,r8,-4
8000a3d8:	70 08       	ld.w	r8,r8[0x0]
8000a3da:	51 0b       	stdsp	sp[0x40],r11
8000a3dc:	50 28       	stdsp	sp[0x8],r8
8000a3de:	fa c6 f9 44 	sub	r6,sp,-1724
8000a3e2:	40 2e       	lddsp	lr,sp[0x8]
8000a3e4:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000a3e8:	f1 4e fd 88 	st.w	r8[-632],lr
8000a3ec:	2f fa       	sub	r10,-1
8000a3ee:	0e 94       	mov	r4,r7
8000a3f0:	fb 4a 06 b4 	st.w	sp[1716],r10
8000a3f4:	12 96       	mov	r6,r9
8000a3f6:	c0 78       	rjmp	8000a404 <_vfprintf_r+0x3cc>
8000a3f8:	70 0c       	ld.w	r12,r8[0x0]
8000a3fa:	0e 94       	mov	r4,r7
8000a3fc:	2f c8       	sub	r8,-4
8000a3fe:	50 2c       	stdsp	sp[0x8],r12
8000a400:	12 96       	mov	r6,r9
8000a402:	51 08       	stdsp	sp[0x40],r8
8000a404:	40 2b       	lddsp	r11,sp[0x8]
8000a406:	58 0b       	cp.w	r11,0
8000a408:	fe 95 fe f2 	brlt	8000a1ec <_vfprintf_r+0x1b4>
8000a40c:	08 97       	mov	r7,r4
8000a40e:	cf 5a       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a410:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000a414:	0f 38       	ld.ub	r8,r7++
8000a416:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000a41a:	f0 ca 00 30 	sub	r10,r8,48
8000a41e:	58 9a       	cp.w	r10,9
8000a420:	fe 98 ff f8 	brls	8000a410 <_vfprintf_r+0x3d8>
8000a424:	3f fa       	mov	r10,-1
8000a426:	f2 0a 0c 49 	max	r9,r9,r10
8000a42a:	50 29       	stdsp	sp[0x8],r9
8000a42c:	ce 9a       	rjmp	8000a1fe <_vfprintf_r+0x1c6>
8000a42e:	a7 b5       	sbr	r5,0x7
8000a430:	ce 4a       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a432:	30 09       	mov	r9,0
8000a434:	23 08       	sub	r8,48
8000a436:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000a43a:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000a43e:	0f 38       	ld.ub	r8,r7++
8000a440:	f0 ca 00 30 	sub	r10,r8,48
8000a444:	58 9a       	cp.w	r10,9
8000a446:	fe 98 ff f7 	brls	8000a434 <_vfprintf_r+0x3fc>
8000a44a:	e0 48 00 24 	cp.w	r8,36
8000a44e:	fe 91 fe d7 	brne	8000a1fc <_vfprintf_r+0x1c4>
8000a452:	e0 49 00 20 	cp.w	r9,32
8000a456:	e0 89 0d 6f 	brgt	8000bf34 <_vfprintf_r+0x1efc>
8000a45a:	f2 c3 00 01 	sub	r3,r9,1
8000a45e:	30 19       	mov	r9,1
8000a460:	50 39       	stdsp	sp[0xc],r9
8000a462:	cc ba       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a464:	a3 b5       	sbr	r5,0x3
8000a466:	cc 9a       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a468:	a7 a5       	sbr	r5,0x6
8000a46a:	cc 7a       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a46c:	0a 98       	mov	r8,r5
8000a46e:	a5 b5       	sbr	r5,0x5
8000a470:	a5 a8       	sbr	r8,0x4
8000a472:	0f 89       	ld.ub	r9,r7[0x0]
8000a474:	36 ce       	mov	lr,108
8000a476:	fc 09 18 00 	cp.b	r9,lr
8000a47a:	f7 b7 00 ff 	subeq	r7,-1
8000a47e:	f0 05 17 10 	movne	r5,r8
8000a482:	cb ba       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a484:	a5 b5       	sbr	r5,0x5
8000a486:	cb 9a       	rjmp	8000a1f8 <_vfprintf_r+0x1c0>
8000a488:	50 a7       	stdsp	sp[0x28],r7
8000a48a:	50 80       	stdsp	sp[0x20],r0
8000a48c:	0c 97       	mov	r7,r6
8000a48e:	10 90       	mov	r0,r8
8000a490:	06 96       	mov	r6,r3
8000a492:	04 94       	mov	r4,r2
8000a494:	40 93       	lddsp	r3,sp[0x24]
8000a496:	02 92       	mov	r2,r1
8000a498:	0e 99       	mov	r9,r7
8000a49a:	40 41       	lddsp	r1,sp[0x10]
8000a49c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a4a0:	40 3c       	lddsp	r12,sp[0xc]
8000a4a2:	58 0c       	cp.w	r12,0
8000a4a4:	c1 d0       	breq	8000a4de <_vfprintf_r+0x4a6>
8000a4a6:	10 36       	cp.w	r6,r8
8000a4a8:	c0 64       	brge	8000a4b4 <_vfprintf_r+0x47c>
8000a4aa:	fa cb f9 44 	sub	r11,sp,-1724
8000a4ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a4b2:	c1 d8       	rjmp	8000a4ec <_vfprintf_r+0x4b4>
8000a4b4:	fa c8 f9 50 	sub	r8,sp,-1712
8000a4b8:	1a d8       	st.w	--sp,r8
8000a4ba:	fa c8 fa b8 	sub	r8,sp,-1352
8000a4be:	1a d8       	st.w	--sp,r8
8000a4c0:	fa c8 fb b4 	sub	r8,sp,-1100
8000a4c4:	1a d8       	st.w	--sp,r8
8000a4c6:	fa c8 f9 40 	sub	r8,sp,-1728
8000a4ca:	fa c9 ff b4 	sub	r9,sp,-76
8000a4ce:	04 9a       	mov	r10,r2
8000a4d0:	0c 9b       	mov	r11,r6
8000a4d2:	08 9c       	mov	r12,r4
8000a4d4:	fe b0 fc 1a 	rcall	80009d08 <get_arg>
8000a4d8:	2f dd       	sub	sp,-12
8000a4da:	19 b8       	ld.ub	r8,r12[0x3]
8000a4dc:	c2 28       	rjmp	8000a520 <_vfprintf_r+0x4e8>
8000a4de:	2f f7       	sub	r7,-1
8000a4e0:	10 39       	cp.w	r9,r8
8000a4e2:	c0 84       	brge	8000a4f2 <_vfprintf_r+0x4ba>
8000a4e4:	fa ca f9 44 	sub	r10,sp,-1724
8000a4e8:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000a4ec:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000a4f0:	c1 88       	rjmp	8000a520 <_vfprintf_r+0x4e8>
8000a4f2:	41 09       	lddsp	r9,sp[0x40]
8000a4f4:	59 f8       	cp.w	r8,31
8000a4f6:	e0 89 00 12 	brgt	8000a51a <_vfprintf_r+0x4e2>
8000a4fa:	f2 ca ff fc 	sub	r10,r9,-4
8000a4fe:	51 0a       	stdsp	sp[0x40],r10
8000a500:	72 09       	ld.w	r9,r9[0x0]
8000a502:	fa c6 f9 44 	sub	r6,sp,-1724
8000a506:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000a50a:	2f f8       	sub	r8,-1
8000a50c:	f5 49 fd 88 	st.w	r10[-632],r9
8000a510:	fb 48 06 b4 	st.w	sp[1716],r8
8000a514:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000a518:	c0 48       	rjmp	8000a520 <_vfprintf_r+0x4e8>
8000a51a:	13 b8       	ld.ub	r8,r9[0x3]
8000a51c:	2f c9       	sub	r9,-4
8000a51e:	51 09       	stdsp	sp[0x40],r9
8000a520:	fb 68 06 60 	st.b	sp[1632],r8
8000a524:	30 0e       	mov	lr,0
8000a526:	30 08       	mov	r8,0
8000a528:	30 12       	mov	r2,1
8000a52a:	fb 68 06 bb 	st.b	sp[1723],r8
8000a52e:	50 2e       	stdsp	sp[0x8],lr
8000a530:	e0 8f 08 ad 	bral	8000b68a <_vfprintf_r+0x1652>
8000a534:	50 a7       	stdsp	sp[0x28],r7
8000a536:	50 80       	stdsp	sp[0x20],r0
8000a538:	0c 97       	mov	r7,r6
8000a53a:	04 94       	mov	r4,r2
8000a53c:	06 96       	mov	r6,r3
8000a53e:	02 92       	mov	r2,r1
8000a540:	40 93       	lddsp	r3,sp[0x24]
8000a542:	10 90       	mov	r0,r8
8000a544:	40 41       	lddsp	r1,sp[0x10]
8000a546:	a5 a5       	sbr	r5,0x4
8000a548:	c0 a8       	rjmp	8000a55c <_vfprintf_r+0x524>
8000a54a:	50 a7       	stdsp	sp[0x28],r7
8000a54c:	50 80       	stdsp	sp[0x20],r0
8000a54e:	0c 97       	mov	r7,r6
8000a550:	04 94       	mov	r4,r2
8000a552:	06 96       	mov	r6,r3
8000a554:	02 92       	mov	r2,r1
8000a556:	40 93       	lddsp	r3,sp[0x24]
8000a558:	10 90       	mov	r0,r8
8000a55a:	40 41       	lddsp	r1,sp[0x10]
8000a55c:	ed b5 00 05 	bld	r5,0x5
8000a560:	c5 11       	brne	8000a602 <_vfprintf_r+0x5ca>
8000a562:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a566:	40 3c       	lddsp	r12,sp[0xc]
8000a568:	58 0c       	cp.w	r12,0
8000a56a:	c1 e0       	breq	8000a5a6 <_vfprintf_r+0x56e>
8000a56c:	10 36       	cp.w	r6,r8
8000a56e:	c0 64       	brge	8000a57a <_vfprintf_r+0x542>
8000a570:	fa cb f9 44 	sub	r11,sp,-1724
8000a574:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a578:	c2 08       	rjmp	8000a5b8 <_vfprintf_r+0x580>
8000a57a:	fa c8 f9 50 	sub	r8,sp,-1712
8000a57e:	1a d8       	st.w	--sp,r8
8000a580:	fa c8 fa b8 	sub	r8,sp,-1352
8000a584:	0c 9b       	mov	r11,r6
8000a586:	1a d8       	st.w	--sp,r8
8000a588:	fa c8 fb b4 	sub	r8,sp,-1100
8000a58c:	1a d8       	st.w	--sp,r8
8000a58e:	fa c9 ff b4 	sub	r9,sp,-76
8000a592:	fa c8 f9 40 	sub	r8,sp,-1728
8000a596:	04 9a       	mov	r10,r2
8000a598:	08 9c       	mov	r12,r4
8000a59a:	fe b0 fb b7 	rcall	80009d08 <get_arg>
8000a59e:	2f dd       	sub	sp,-12
8000a5a0:	78 1b       	ld.w	r11,r12[0x4]
8000a5a2:	78 09       	ld.w	r9,r12[0x0]
8000a5a4:	c2 b8       	rjmp	8000a5fa <_vfprintf_r+0x5c2>
8000a5a6:	ee ca ff ff 	sub	r10,r7,-1
8000a5aa:	10 37       	cp.w	r7,r8
8000a5ac:	c0 b4       	brge	8000a5c2 <_vfprintf_r+0x58a>
8000a5ae:	fa c9 f9 44 	sub	r9,sp,-1724
8000a5b2:	14 97       	mov	r7,r10
8000a5b4:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a5b8:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000a5bc:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000a5c0:	c1 d8       	rjmp	8000a5fa <_vfprintf_r+0x5c2>
8000a5c2:	41 09       	lddsp	r9,sp[0x40]
8000a5c4:	59 f8       	cp.w	r8,31
8000a5c6:	e0 89 00 14 	brgt	8000a5ee <_vfprintf_r+0x5b6>
8000a5ca:	f2 cb ff f8 	sub	r11,r9,-8
8000a5ce:	51 0b       	stdsp	sp[0x40],r11
8000a5d0:	fa c6 f9 44 	sub	r6,sp,-1724
8000a5d4:	72 1b       	ld.w	r11,r9[0x4]
8000a5d6:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000a5da:	72 09       	ld.w	r9,r9[0x0]
8000a5dc:	f9 4b fd 8c 	st.w	r12[-628],r11
8000a5e0:	f9 49 fd 88 	st.w	r12[-632],r9
8000a5e4:	2f f8       	sub	r8,-1
8000a5e6:	14 97       	mov	r7,r10
8000a5e8:	fb 48 06 b4 	st.w	sp[1716],r8
8000a5ec:	c0 78       	rjmp	8000a5fa <_vfprintf_r+0x5c2>
8000a5ee:	f2 c8 ff f8 	sub	r8,r9,-8
8000a5f2:	72 1b       	ld.w	r11,r9[0x4]
8000a5f4:	14 97       	mov	r7,r10
8000a5f6:	51 08       	stdsp	sp[0x40],r8
8000a5f8:	72 09       	ld.w	r9,r9[0x0]
8000a5fa:	16 98       	mov	r8,r11
8000a5fc:	fa e9 00 00 	st.d	sp[0],r8
8000a600:	ca e8       	rjmp	8000a75c <_vfprintf_r+0x724>
8000a602:	ed b5 00 04 	bld	r5,0x4
8000a606:	c1 71       	brne	8000a634 <_vfprintf_r+0x5fc>
8000a608:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a60c:	40 3e       	lddsp	lr,sp[0xc]
8000a60e:	58 0e       	cp.w	lr,0
8000a610:	c0 80       	breq	8000a620 <_vfprintf_r+0x5e8>
8000a612:	10 36       	cp.w	r6,r8
8000a614:	c6 94       	brge	8000a6e6 <_vfprintf_r+0x6ae>
8000a616:	fa cc f9 44 	sub	r12,sp,-1724
8000a61a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a61e:	c8 28       	rjmp	8000a722 <_vfprintf_r+0x6ea>
8000a620:	ee ca ff ff 	sub	r10,r7,-1
8000a624:	10 37       	cp.w	r7,r8
8000a626:	e0 84 00 81 	brge	8000a728 <_vfprintf_r+0x6f0>
8000a62a:	fa cb f9 44 	sub	r11,sp,-1724
8000a62e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a632:	c7 78       	rjmp	8000a720 <_vfprintf_r+0x6e8>
8000a634:	ed b5 00 06 	bld	r5,0x6
8000a638:	c4 b1       	brne	8000a6ce <_vfprintf_r+0x696>
8000a63a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a63e:	40 3c       	lddsp	r12,sp[0xc]
8000a640:	58 0c       	cp.w	r12,0
8000a642:	c1 d0       	breq	8000a67c <_vfprintf_r+0x644>
8000a644:	10 36       	cp.w	r6,r8
8000a646:	c0 64       	brge	8000a652 <_vfprintf_r+0x61a>
8000a648:	fa cb f9 44 	sub	r11,sp,-1724
8000a64c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a650:	c1 f8       	rjmp	8000a68e <_vfprintf_r+0x656>
8000a652:	fa c8 f9 50 	sub	r8,sp,-1712
8000a656:	1a d8       	st.w	--sp,r8
8000a658:	fa c8 fa b8 	sub	r8,sp,-1352
8000a65c:	1a d8       	st.w	--sp,r8
8000a65e:	fa c8 fb b4 	sub	r8,sp,-1100
8000a662:	1a d8       	st.w	--sp,r8
8000a664:	fa c8 f9 40 	sub	r8,sp,-1728
8000a668:	fa c9 ff b4 	sub	r9,sp,-76
8000a66c:	04 9a       	mov	r10,r2
8000a66e:	0c 9b       	mov	r11,r6
8000a670:	08 9c       	mov	r12,r4
8000a672:	fe b0 fb 4b 	rcall	80009d08 <get_arg>
8000a676:	2f dd       	sub	sp,-12
8000a678:	98 18       	ld.sh	r8,r12[0x2]
8000a67a:	c2 68       	rjmp	8000a6c6 <_vfprintf_r+0x68e>
8000a67c:	ee ca ff ff 	sub	r10,r7,-1
8000a680:	10 37       	cp.w	r7,r8
8000a682:	c0 94       	brge	8000a694 <_vfprintf_r+0x65c>
8000a684:	fa c9 f9 44 	sub	r9,sp,-1724
8000a688:	14 97       	mov	r7,r10
8000a68a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a68e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000a692:	c1 a8       	rjmp	8000a6c6 <_vfprintf_r+0x68e>
8000a694:	41 09       	lddsp	r9,sp[0x40]
8000a696:	59 f8       	cp.w	r8,31
8000a698:	e0 89 00 13 	brgt	8000a6be <_vfprintf_r+0x686>
8000a69c:	f2 cb ff fc 	sub	r11,r9,-4
8000a6a0:	51 0b       	stdsp	sp[0x40],r11
8000a6a2:	72 09       	ld.w	r9,r9[0x0]
8000a6a4:	fa c6 f9 44 	sub	r6,sp,-1724
8000a6a8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000a6ac:	2f f8       	sub	r8,-1
8000a6ae:	f7 49 fd 88 	st.w	r11[-632],r9
8000a6b2:	fb 48 06 b4 	st.w	sp[1716],r8
8000a6b6:	14 97       	mov	r7,r10
8000a6b8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000a6bc:	c0 58       	rjmp	8000a6c6 <_vfprintf_r+0x68e>
8000a6be:	92 18       	ld.sh	r8,r9[0x2]
8000a6c0:	14 97       	mov	r7,r10
8000a6c2:	2f c9       	sub	r9,-4
8000a6c4:	51 09       	stdsp	sp[0x40],r9
8000a6c6:	50 18       	stdsp	sp[0x4],r8
8000a6c8:	bf 58       	asr	r8,0x1f
8000a6ca:	50 08       	stdsp	sp[0x0],r8
8000a6cc:	c4 88       	rjmp	8000a75c <_vfprintf_r+0x724>
8000a6ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a6d2:	40 3c       	lddsp	r12,sp[0xc]
8000a6d4:	58 0c       	cp.w	r12,0
8000a6d6:	c1 d0       	breq	8000a710 <_vfprintf_r+0x6d8>
8000a6d8:	10 36       	cp.w	r6,r8
8000a6da:	c0 64       	brge	8000a6e6 <_vfprintf_r+0x6ae>
8000a6dc:	fa cb f9 44 	sub	r11,sp,-1724
8000a6e0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000a6e4:	c1 f8       	rjmp	8000a722 <_vfprintf_r+0x6ea>
8000a6e6:	fa c8 f9 50 	sub	r8,sp,-1712
8000a6ea:	1a d8       	st.w	--sp,r8
8000a6ec:	fa c8 fa b8 	sub	r8,sp,-1352
8000a6f0:	0c 9b       	mov	r11,r6
8000a6f2:	1a d8       	st.w	--sp,r8
8000a6f4:	fa c8 fb b4 	sub	r8,sp,-1100
8000a6f8:	04 9a       	mov	r10,r2
8000a6fa:	1a d8       	st.w	--sp,r8
8000a6fc:	08 9c       	mov	r12,r4
8000a6fe:	fa c8 f9 40 	sub	r8,sp,-1728
8000a702:	fa c9 ff b4 	sub	r9,sp,-76
8000a706:	fe b0 fb 01 	rcall	80009d08 <get_arg>
8000a70a:	2f dd       	sub	sp,-12
8000a70c:	78 0b       	ld.w	r11,r12[0x0]
8000a70e:	c2 48       	rjmp	8000a756 <_vfprintf_r+0x71e>
8000a710:	ee ca ff ff 	sub	r10,r7,-1
8000a714:	10 37       	cp.w	r7,r8
8000a716:	c0 94       	brge	8000a728 <_vfprintf_r+0x6f0>
8000a718:	fa c9 f9 44 	sub	r9,sp,-1724
8000a71c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a720:	14 97       	mov	r7,r10
8000a722:	ec fb fd 88 	ld.w	r11,r6[-632]
8000a726:	c1 88       	rjmp	8000a756 <_vfprintf_r+0x71e>
8000a728:	41 09       	lddsp	r9,sp[0x40]
8000a72a:	59 f8       	cp.w	r8,31
8000a72c:	e0 89 00 11 	brgt	8000a74e <_vfprintf_r+0x716>
8000a730:	f2 cb ff fc 	sub	r11,r9,-4
8000a734:	51 0b       	stdsp	sp[0x40],r11
8000a736:	fa c6 f9 44 	sub	r6,sp,-1724
8000a73a:	72 0b       	ld.w	r11,r9[0x0]
8000a73c:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000a740:	f3 4b fd 88 	st.w	r9[-632],r11
8000a744:	2f f8       	sub	r8,-1
8000a746:	14 97       	mov	r7,r10
8000a748:	fb 48 06 b4 	st.w	sp[1716],r8
8000a74c:	c0 58       	rjmp	8000a756 <_vfprintf_r+0x71e>
8000a74e:	72 0b       	ld.w	r11,r9[0x0]
8000a750:	14 97       	mov	r7,r10
8000a752:	2f c9       	sub	r9,-4
8000a754:	51 09       	stdsp	sp[0x40],r9
8000a756:	50 1b       	stdsp	sp[0x4],r11
8000a758:	bf 5b       	asr	r11,0x1f
8000a75a:	50 0b       	stdsp	sp[0x0],r11
8000a75c:	fa ea 00 00 	ld.d	r10,sp[0]
8000a760:	58 0a       	cp.w	r10,0
8000a762:	5c 2b       	cpc	r11
8000a764:	c0 e4       	brge	8000a780 <_vfprintf_r+0x748>
8000a766:	30 08       	mov	r8,0
8000a768:	fa ea 00 00 	ld.d	r10,sp[0]
8000a76c:	30 09       	mov	r9,0
8000a76e:	f0 0a 01 0a 	sub	r10,r8,r10
8000a772:	f2 0b 01 4b 	sbc	r11,r9,r11
8000a776:	32 d8       	mov	r8,45
8000a778:	fa eb 00 00 	st.d	sp[0],r10
8000a77c:	fb 68 06 bb 	st.b	sp[1723],r8
8000a780:	30 18       	mov	r8,1
8000a782:	e0 8f 06 fa 	bral	8000b576 <_vfprintf_r+0x153e>
8000a786:	50 a7       	stdsp	sp[0x28],r7
8000a788:	50 80       	stdsp	sp[0x20],r0
8000a78a:	0c 97       	mov	r7,r6
8000a78c:	04 94       	mov	r4,r2
8000a78e:	06 96       	mov	r6,r3
8000a790:	02 92       	mov	r2,r1
8000a792:	40 93       	lddsp	r3,sp[0x24]
8000a794:	10 90       	mov	r0,r8
8000a796:	40 41       	lddsp	r1,sp[0x10]
8000a798:	0e 99       	mov	r9,r7
8000a79a:	ed b5 00 03 	bld	r5,0x3
8000a79e:	c4 11       	brne	8000a820 <_vfprintf_r+0x7e8>
8000a7a0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a7a4:	40 3a       	lddsp	r10,sp[0xc]
8000a7a6:	58 0a       	cp.w	r10,0
8000a7a8:	c1 90       	breq	8000a7da <_vfprintf_r+0x7a2>
8000a7aa:	10 36       	cp.w	r6,r8
8000a7ac:	c6 45       	brlt	8000a874 <_vfprintf_r+0x83c>
8000a7ae:	fa c8 f9 50 	sub	r8,sp,-1712
8000a7b2:	1a d8       	st.w	--sp,r8
8000a7b4:	fa c8 fa b8 	sub	r8,sp,-1352
8000a7b8:	1a d8       	st.w	--sp,r8
8000a7ba:	fa c8 fb b4 	sub	r8,sp,-1100
8000a7be:	0c 9b       	mov	r11,r6
8000a7c0:	1a d8       	st.w	--sp,r8
8000a7c2:	04 9a       	mov	r10,r2
8000a7c4:	fa c8 f9 40 	sub	r8,sp,-1728
8000a7c8:	fa c9 ff b4 	sub	r9,sp,-76
8000a7cc:	08 9c       	mov	r12,r4
8000a7ce:	fe b0 fa 9d 	rcall	80009d08 <get_arg>
8000a7d2:	2f dd       	sub	sp,-12
8000a7d4:	78 16       	ld.w	r6,r12[0x4]
8000a7d6:	50 76       	stdsp	sp[0x1c],r6
8000a7d8:	c4 88       	rjmp	8000a868 <_vfprintf_r+0x830>
8000a7da:	2f f7       	sub	r7,-1
8000a7dc:	10 39       	cp.w	r9,r8
8000a7de:	c0 c4       	brge	8000a7f6 <_vfprintf_r+0x7be>
8000a7e0:	fa ce f9 44 	sub	lr,sp,-1724
8000a7e4:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000a7e8:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000a7ec:	50 7c       	stdsp	sp[0x1c],r12
8000a7ee:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000a7f2:	50 56       	stdsp	sp[0x14],r6
8000a7f4:	c6 68       	rjmp	8000a8c0 <_vfprintf_r+0x888>
8000a7f6:	41 09       	lddsp	r9,sp[0x40]
8000a7f8:	59 f8       	cp.w	r8,31
8000a7fa:	e0 89 00 10 	brgt	8000a81a <_vfprintf_r+0x7e2>
8000a7fe:	f2 ca ff f8 	sub	r10,r9,-8
8000a802:	72 1b       	ld.w	r11,r9[0x4]
8000a804:	51 0a       	stdsp	sp[0x40],r10
8000a806:	72 09       	ld.w	r9,r9[0x0]
8000a808:	fa ca f9 44 	sub	r10,sp,-1724
8000a80c:	50 7b       	stdsp	sp[0x1c],r11
8000a80e:	50 59       	stdsp	sp[0x14],r9
8000a810:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a814:	40 5b       	lddsp	r11,sp[0x14]
8000a816:	40 7a       	lddsp	r10,sp[0x1c]
8000a818:	c4 78       	rjmp	8000a8a6 <_vfprintf_r+0x86e>
8000a81a:	72 18       	ld.w	r8,r9[0x4]
8000a81c:	50 78       	stdsp	sp[0x1c],r8
8000a81e:	c4 c8       	rjmp	8000a8b6 <_vfprintf_r+0x87e>
8000a820:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000a824:	40 3e       	lddsp	lr,sp[0xc]
8000a826:	58 0e       	cp.w	lr,0
8000a828:	c2 30       	breq	8000a86e <_vfprintf_r+0x836>
8000a82a:	10 36       	cp.w	r6,r8
8000a82c:	c0 94       	brge	8000a83e <_vfprintf_r+0x806>
8000a82e:	fa cc f9 44 	sub	r12,sp,-1724
8000a832:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000a836:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000a83a:	50 7b       	stdsp	sp[0x1c],r11
8000a83c:	cd 9b       	rjmp	8000a7ee <_vfprintf_r+0x7b6>
8000a83e:	fa c8 f9 50 	sub	r8,sp,-1712
8000a842:	1a d8       	st.w	--sp,r8
8000a844:	fa c8 fa b8 	sub	r8,sp,-1352
8000a848:	04 9a       	mov	r10,r2
8000a84a:	1a d8       	st.w	--sp,r8
8000a84c:	fa c8 fb b4 	sub	r8,sp,-1100
8000a850:	0c 9b       	mov	r11,r6
8000a852:	1a d8       	st.w	--sp,r8
8000a854:	08 9c       	mov	r12,r4
8000a856:	fa c8 f9 40 	sub	r8,sp,-1728
8000a85a:	fa c9 ff b4 	sub	r9,sp,-76
8000a85e:	fe b0 fa 55 	rcall	80009d08 <get_arg>
8000a862:	2f dd       	sub	sp,-12
8000a864:	78 1a       	ld.w	r10,r12[0x4]
8000a866:	50 7a       	stdsp	sp[0x1c],r10
8000a868:	78 0c       	ld.w	r12,r12[0x0]
8000a86a:	50 5c       	stdsp	sp[0x14],r12
8000a86c:	c2 a8       	rjmp	8000a8c0 <_vfprintf_r+0x888>
8000a86e:	2f f7       	sub	r7,-1
8000a870:	10 39       	cp.w	r9,r8
8000a872:	c0 94       	brge	8000a884 <_vfprintf_r+0x84c>
8000a874:	fa c9 f9 44 	sub	r9,sp,-1724
8000a878:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000a87c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000a880:	50 78       	stdsp	sp[0x1c],r8
8000a882:	cb 6b       	rjmp	8000a7ee <_vfprintf_r+0x7b6>
8000a884:	41 09       	lddsp	r9,sp[0x40]
8000a886:	59 f8       	cp.w	r8,31
8000a888:	e0 89 00 15 	brgt	8000a8b2 <_vfprintf_r+0x87a>
8000a88c:	f2 ca ff f8 	sub	r10,r9,-8
8000a890:	72 16       	ld.w	r6,r9[0x4]
8000a892:	72 09       	ld.w	r9,r9[0x0]
8000a894:	51 0a       	stdsp	sp[0x40],r10
8000a896:	50 59       	stdsp	sp[0x14],r9
8000a898:	fa ce f9 44 	sub	lr,sp,-1724
8000a89c:	50 76       	stdsp	sp[0x1c],r6
8000a89e:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000a8a2:	40 5b       	lddsp	r11,sp[0x14]
8000a8a4:	0c 9a       	mov	r10,r6
8000a8a6:	f2 eb fd 88 	st.d	r9[-632],r10
8000a8aa:	2f f8       	sub	r8,-1
8000a8ac:	fb 48 06 b4 	st.w	sp[1716],r8
8000a8b0:	c0 88       	rjmp	8000a8c0 <_vfprintf_r+0x888>
8000a8b2:	72 1c       	ld.w	r12,r9[0x4]
8000a8b4:	50 7c       	stdsp	sp[0x1c],r12
8000a8b6:	f2 c8 ff f8 	sub	r8,r9,-8
8000a8ba:	51 08       	stdsp	sp[0x40],r8
8000a8bc:	72 09       	ld.w	r9,r9[0x0]
8000a8be:	50 59       	stdsp	sp[0x14],r9
8000a8c0:	40 5b       	lddsp	r11,sp[0x14]
8000a8c2:	40 7a       	lddsp	r10,sp[0x1c]
8000a8c4:	e0 a0 19 54 	rcall	8000db6c <__isinfd>
8000a8c8:	18 96       	mov	r6,r12
8000a8ca:	c1 70       	breq	8000a8f8 <_vfprintf_r+0x8c0>
8000a8cc:	30 08       	mov	r8,0
8000a8ce:	30 09       	mov	r9,0
8000a8d0:	40 5b       	lddsp	r11,sp[0x14]
8000a8d2:	40 7a       	lddsp	r10,sp[0x1c]
8000a8d4:	e0 a0 1d a8 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000a8d8:	c0 40       	breq	8000a8e0 <_vfprintf_r+0x8a8>
8000a8da:	32 d8       	mov	r8,45
8000a8dc:	fb 68 06 bb 	st.b	sp[1723],r8
8000a8e0:	fe c8 b2 90 	sub	r8,pc,-19824
8000a8e4:	fe c6 b2 90 	sub	r6,pc,-19824
8000a8e8:	a7 d5       	cbr	r5,0x7
8000a8ea:	e0 40 00 47 	cp.w	r0,71
8000a8ee:	f0 06 17 a0 	movle	r6,r8
8000a8f2:	30 32       	mov	r2,3
8000a8f4:	e0 8f 06 ce 	bral	8000b690 <_vfprintf_r+0x1658>
8000a8f8:	40 5b       	lddsp	r11,sp[0x14]
8000a8fa:	40 7a       	lddsp	r10,sp[0x1c]
8000a8fc:	e0 a0 19 4d 	rcall	8000db96 <__isnand>
8000a900:	c0 e0       	breq	8000a91c <_vfprintf_r+0x8e4>
8000a902:	50 26       	stdsp	sp[0x8],r6
8000a904:	fe c8 b2 ac 	sub	r8,pc,-19796
8000a908:	fe c6 b2 ac 	sub	r6,pc,-19796
8000a90c:	a7 d5       	cbr	r5,0x7
8000a90e:	e0 40 00 47 	cp.w	r0,71
8000a912:	f0 06 17 a0 	movle	r6,r8
8000a916:	30 32       	mov	r2,3
8000a918:	e0 8f 06 c2 	bral	8000b69c <_vfprintf_r+0x1664>
8000a91c:	40 2a       	lddsp	r10,sp[0x8]
8000a91e:	5b fa       	cp.w	r10,-1
8000a920:	c0 41       	brne	8000a928 <_vfprintf_r+0x8f0>
8000a922:	30 69       	mov	r9,6
8000a924:	50 29       	stdsp	sp[0x8],r9
8000a926:	c1 18       	rjmp	8000a948 <_vfprintf_r+0x910>
8000a928:	e0 40 00 47 	cp.w	r0,71
8000a92c:	5f 09       	sreq	r9
8000a92e:	e0 40 00 67 	cp.w	r0,103
8000a932:	5f 08       	sreq	r8
8000a934:	f3 e8 10 08 	or	r8,r9,r8
8000a938:	f8 08 18 00 	cp.b	r8,r12
8000a93c:	c0 60       	breq	8000a948 <_vfprintf_r+0x910>
8000a93e:	40 28       	lddsp	r8,sp[0x8]
8000a940:	58 08       	cp.w	r8,0
8000a942:	f9 b8 00 01 	moveq	r8,1
8000a946:	50 28       	stdsp	sp[0x8],r8
8000a948:	40 78       	lddsp	r8,sp[0x1c]
8000a94a:	40 59       	lddsp	r9,sp[0x14]
8000a94c:	fa e9 06 94 	st.d	sp[1684],r8
8000a950:	a9 a5       	sbr	r5,0x8
8000a952:	fa f8 06 94 	ld.w	r8,sp[1684]
8000a956:	58 08       	cp.w	r8,0
8000a958:	c0 65       	brlt	8000a964 <_vfprintf_r+0x92c>
8000a95a:	40 5e       	lddsp	lr,sp[0x14]
8000a95c:	30 0c       	mov	r12,0
8000a95e:	50 6e       	stdsp	sp[0x18],lr
8000a960:	50 9c       	stdsp	sp[0x24],r12
8000a962:	c0 78       	rjmp	8000a970 <_vfprintf_r+0x938>
8000a964:	40 5b       	lddsp	r11,sp[0x14]
8000a966:	32 da       	mov	r10,45
8000a968:	ee 1b 80 00 	eorh	r11,0x8000
8000a96c:	50 9a       	stdsp	sp[0x24],r10
8000a96e:	50 6b       	stdsp	sp[0x18],r11
8000a970:	e0 40 00 46 	cp.w	r0,70
8000a974:	5f 09       	sreq	r9
8000a976:	e0 40 00 66 	cp.w	r0,102
8000a97a:	5f 08       	sreq	r8
8000a97c:	f3 e8 10 08 	or	r8,r9,r8
8000a980:	50 48       	stdsp	sp[0x10],r8
8000a982:	c0 40       	breq	8000a98a <_vfprintf_r+0x952>
8000a984:	40 22       	lddsp	r2,sp[0x8]
8000a986:	30 39       	mov	r9,3
8000a988:	c1 08       	rjmp	8000a9a8 <_vfprintf_r+0x970>
8000a98a:	e0 40 00 45 	cp.w	r0,69
8000a98e:	5f 09       	sreq	r9
8000a990:	e0 40 00 65 	cp.w	r0,101
8000a994:	5f 08       	sreq	r8
8000a996:	40 22       	lddsp	r2,sp[0x8]
8000a998:	10 49       	or	r9,r8
8000a99a:	2f f2       	sub	r2,-1
8000a99c:	40 46       	lddsp	r6,sp[0x10]
8000a99e:	ec 09 18 00 	cp.b	r9,r6
8000a9a2:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000a9a6:	30 29       	mov	r9,2
8000a9a8:	fa c8 f9 5c 	sub	r8,sp,-1700
8000a9ac:	1a d8       	st.w	--sp,r8
8000a9ae:	fa c8 f9 54 	sub	r8,sp,-1708
8000a9b2:	1a d8       	st.w	--sp,r8
8000a9b4:	fa c8 f9 4c 	sub	r8,sp,-1716
8000a9b8:	08 9c       	mov	r12,r4
8000a9ba:	1a d8       	st.w	--sp,r8
8000a9bc:	04 98       	mov	r8,r2
8000a9be:	40 9b       	lddsp	r11,sp[0x24]
8000a9c0:	40 aa       	lddsp	r10,sp[0x28]
8000a9c2:	e0 a0 0b c3 	rcall	8000c148 <_dtoa_r>
8000a9c6:	e0 40 00 47 	cp.w	r0,71
8000a9ca:	5f 19       	srne	r9
8000a9cc:	e0 40 00 67 	cp.w	r0,103
8000a9d0:	5f 18       	srne	r8
8000a9d2:	18 96       	mov	r6,r12
8000a9d4:	2f dd       	sub	sp,-12
8000a9d6:	f3 e8 00 08 	and	r8,r9,r8
8000a9da:	c0 41       	brne	8000a9e2 <_vfprintf_r+0x9aa>
8000a9dc:	ed b5 00 00 	bld	r5,0x0
8000a9e0:	c3 01       	brne	8000aa40 <_vfprintf_r+0xa08>
8000a9e2:	ec 02 00 0e 	add	lr,r6,r2
8000a9e6:	50 3e       	stdsp	sp[0xc],lr
8000a9e8:	40 4c       	lddsp	r12,sp[0x10]
8000a9ea:	58 0c       	cp.w	r12,0
8000a9ec:	c1 50       	breq	8000aa16 <_vfprintf_r+0x9de>
8000a9ee:	0d 89       	ld.ub	r9,r6[0x0]
8000a9f0:	33 08       	mov	r8,48
8000a9f2:	f0 09 18 00 	cp.b	r9,r8
8000a9f6:	c0 b1       	brne	8000aa0c <_vfprintf_r+0x9d4>
8000a9f8:	30 08       	mov	r8,0
8000a9fa:	30 09       	mov	r9,0
8000a9fc:	40 6b       	lddsp	r11,sp[0x18]
8000a9fe:	40 7a       	lddsp	r10,sp[0x1c]
8000aa00:	e0 a0 1c cb 	rcall	8000e396 <__avr32_f64_cmp_eq>
8000aa04:	fb b2 00 01 	rsubeq	r2,1
8000aa08:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000aa0c:	40 3b       	lddsp	r11,sp[0xc]
8000aa0e:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000aa12:	10 0b       	add	r11,r8
8000aa14:	50 3b       	stdsp	sp[0xc],r11
8000aa16:	40 6b       	lddsp	r11,sp[0x18]
8000aa18:	30 08       	mov	r8,0
8000aa1a:	30 09       	mov	r9,0
8000aa1c:	40 7a       	lddsp	r10,sp[0x1c]
8000aa1e:	e0 a0 1c bc 	rcall	8000e396 <__avr32_f64_cmp_eq>
8000aa22:	c0 90       	breq	8000aa34 <_vfprintf_r+0x9fc>
8000aa24:	40 3a       	lddsp	r10,sp[0xc]
8000aa26:	fb 4a 06 a4 	st.w	sp[1700],r10
8000aa2a:	c0 58       	rjmp	8000aa34 <_vfprintf_r+0x9fc>
8000aa2c:	10 c9       	st.b	r8++,r9
8000aa2e:	fb 48 06 a4 	st.w	sp[1700],r8
8000aa32:	c0 28       	rjmp	8000aa36 <_vfprintf_r+0x9fe>
8000aa34:	33 09       	mov	r9,48
8000aa36:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000aa3a:	40 3e       	lddsp	lr,sp[0xc]
8000aa3c:	1c 38       	cp.w	r8,lr
8000aa3e:	cf 73       	brcs	8000aa2c <_vfprintf_r+0x9f4>
8000aa40:	e0 40 00 47 	cp.w	r0,71
8000aa44:	5f 09       	sreq	r9
8000aa46:	e0 40 00 67 	cp.w	r0,103
8000aa4a:	5f 08       	sreq	r8
8000aa4c:	f3 e8 10 08 	or	r8,r9,r8
8000aa50:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000aa54:	0c 19       	sub	r9,r6
8000aa56:	50 69       	stdsp	sp[0x18],r9
8000aa58:	58 08       	cp.w	r8,0
8000aa5a:	c0 b0       	breq	8000aa70 <_vfprintf_r+0xa38>
8000aa5c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000aa60:	5b d8       	cp.w	r8,-3
8000aa62:	c0 55       	brlt	8000aa6c <_vfprintf_r+0xa34>
8000aa64:	40 2c       	lddsp	r12,sp[0x8]
8000aa66:	18 38       	cp.w	r8,r12
8000aa68:	e0 8a 00 6a 	brle	8000ab3c <_vfprintf_r+0xb04>
8000aa6c:	20 20       	sub	r0,2
8000aa6e:	c0 58       	rjmp	8000aa78 <_vfprintf_r+0xa40>
8000aa70:	e0 40 00 65 	cp.w	r0,101
8000aa74:	e0 89 00 46 	brgt	8000ab00 <_vfprintf_r+0xac8>
8000aa78:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000aa7c:	fb 60 06 9c 	st.b	sp[1692],r0
8000aa80:	20 1b       	sub	r11,1
8000aa82:	fb 4b 06 ac 	st.w	sp[1708],r11
8000aa86:	c0 47       	brpl	8000aa8e <_vfprintf_r+0xa56>
8000aa88:	5c 3b       	neg	r11
8000aa8a:	32 d8       	mov	r8,45
8000aa8c:	c0 28       	rjmp	8000aa90 <_vfprintf_r+0xa58>
8000aa8e:	32 b8       	mov	r8,43
8000aa90:	fb 68 06 9d 	st.b	sp[1693],r8
8000aa94:	58 9b       	cp.w	r11,9
8000aa96:	e0 8a 00 1d 	brle	8000aad0 <_vfprintf_r+0xa98>
8000aa9a:	fa c9 fa 35 	sub	r9,sp,-1483
8000aa9e:	30 aa       	mov	r10,10
8000aaa0:	12 98       	mov	r8,r9
8000aaa2:	0e 9c       	mov	r12,r7
8000aaa4:	0c 92       	mov	r2,r6
8000aaa6:	f6 0a 0c 06 	divs	r6,r11,r10
8000aaaa:	0e 9b       	mov	r11,r7
8000aaac:	2d 0b       	sub	r11,-48
8000aaae:	10 fb       	st.b	--r8,r11
8000aab0:	0c 9b       	mov	r11,r6
8000aab2:	58 96       	cp.w	r6,9
8000aab4:	fe 99 ff f9 	brgt	8000aaa6 <_vfprintf_r+0xa6e>
8000aab8:	2d 0b       	sub	r11,-48
8000aaba:	18 97       	mov	r7,r12
8000aabc:	04 96       	mov	r6,r2
8000aabe:	10 fb       	st.b	--r8,r11
8000aac0:	fa ca f9 62 	sub	r10,sp,-1694
8000aac4:	c0 38       	rjmp	8000aaca <_vfprintf_r+0xa92>
8000aac6:	11 3b       	ld.ub	r11,r8++
8000aac8:	14 cb       	st.b	r10++,r11
8000aaca:	12 38       	cp.w	r8,r9
8000aacc:	cf d3       	brcs	8000aac6 <_vfprintf_r+0xa8e>
8000aace:	c0 98       	rjmp	8000aae0 <_vfprintf_r+0xaa8>
8000aad0:	2d 0b       	sub	r11,-48
8000aad2:	33 08       	mov	r8,48
8000aad4:	fb 6b 06 9f 	st.b	sp[1695],r11
8000aad8:	fb 68 06 9e 	st.b	sp[1694],r8
8000aadc:	fa ca f9 60 	sub	r10,sp,-1696
8000aae0:	fa c8 f9 64 	sub	r8,sp,-1692
8000aae4:	f4 08 01 08 	sub	r8,r10,r8
8000aae8:	50 e8       	stdsp	sp[0x38],r8
8000aaea:	10 92       	mov	r2,r8
8000aaec:	40 6b       	lddsp	r11,sp[0x18]
8000aaee:	16 02       	add	r2,r11
8000aaf0:	58 1b       	cp.w	r11,1
8000aaf2:	e0 89 00 05 	brgt	8000aafc <_vfprintf_r+0xac4>
8000aaf6:	ed b5 00 00 	bld	r5,0x0
8000aafa:	c3 51       	brne	8000ab64 <_vfprintf_r+0xb2c>
8000aafc:	2f f2       	sub	r2,-1
8000aafe:	c3 38       	rjmp	8000ab64 <_vfprintf_r+0xb2c>
8000ab00:	e0 40 00 66 	cp.w	r0,102
8000ab04:	c1 c1       	brne	8000ab3c <_vfprintf_r+0xb04>
8000ab06:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ab0a:	58 02       	cp.w	r2,0
8000ab0c:	e0 8a 00 0c 	brle	8000ab24 <_vfprintf_r+0xaec>
8000ab10:	40 2a       	lddsp	r10,sp[0x8]
8000ab12:	58 0a       	cp.w	r10,0
8000ab14:	c0 41       	brne	8000ab1c <_vfprintf_r+0xae4>
8000ab16:	ed b5 00 00 	bld	r5,0x0
8000ab1a:	c2 51       	brne	8000ab64 <_vfprintf_r+0xb2c>
8000ab1c:	2f f2       	sub	r2,-1
8000ab1e:	40 29       	lddsp	r9,sp[0x8]
8000ab20:	12 02       	add	r2,r9
8000ab22:	c0 b8       	rjmp	8000ab38 <_vfprintf_r+0xb00>
8000ab24:	40 28       	lddsp	r8,sp[0x8]
8000ab26:	58 08       	cp.w	r8,0
8000ab28:	c0 61       	brne	8000ab34 <_vfprintf_r+0xafc>
8000ab2a:	ed b5 00 00 	bld	r5,0x0
8000ab2e:	c0 30       	breq	8000ab34 <_vfprintf_r+0xafc>
8000ab30:	30 12       	mov	r2,1
8000ab32:	c1 98       	rjmp	8000ab64 <_vfprintf_r+0xb2c>
8000ab34:	40 22       	lddsp	r2,sp[0x8]
8000ab36:	2f e2       	sub	r2,-2
8000ab38:	36 60       	mov	r0,102
8000ab3a:	c1 58       	rjmp	8000ab64 <_vfprintf_r+0xb2c>
8000ab3c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000ab40:	40 6e       	lddsp	lr,sp[0x18]
8000ab42:	1c 32       	cp.w	r2,lr
8000ab44:	c0 65       	brlt	8000ab50 <_vfprintf_r+0xb18>
8000ab46:	ed b5 00 00 	bld	r5,0x0
8000ab4a:	f7 b2 00 ff 	subeq	r2,-1
8000ab4e:	c0 a8       	rjmp	8000ab62 <_vfprintf_r+0xb2a>
8000ab50:	e4 08 11 02 	rsub	r8,r2,2
8000ab54:	40 6c       	lddsp	r12,sp[0x18]
8000ab56:	58 02       	cp.w	r2,0
8000ab58:	f0 02 17 a0 	movle	r2,r8
8000ab5c:	f9 b2 09 01 	movgt	r2,1
8000ab60:	18 02       	add	r2,r12
8000ab62:	36 70       	mov	r0,103
8000ab64:	40 9b       	lddsp	r11,sp[0x24]
8000ab66:	58 0b       	cp.w	r11,0
8000ab68:	e0 80 05 94 	breq	8000b690 <_vfprintf_r+0x1658>
8000ab6c:	32 d8       	mov	r8,45
8000ab6e:	fb 68 06 bb 	st.b	sp[1723],r8
8000ab72:	e0 8f 05 93 	bral	8000b698 <_vfprintf_r+0x1660>
8000ab76:	50 a7       	stdsp	sp[0x28],r7
8000ab78:	04 94       	mov	r4,r2
8000ab7a:	0c 97       	mov	r7,r6
8000ab7c:	02 92       	mov	r2,r1
8000ab7e:	06 96       	mov	r6,r3
8000ab80:	40 41       	lddsp	r1,sp[0x10]
8000ab82:	40 93       	lddsp	r3,sp[0x24]
8000ab84:	0e 99       	mov	r9,r7
8000ab86:	ed b5 00 05 	bld	r5,0x5
8000ab8a:	c4 81       	brne	8000ac1a <_vfprintf_r+0xbe2>
8000ab8c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ab90:	40 3e       	lddsp	lr,sp[0xc]
8000ab92:	58 0e       	cp.w	lr,0
8000ab94:	c1 d0       	breq	8000abce <_vfprintf_r+0xb96>
8000ab96:	10 36       	cp.w	r6,r8
8000ab98:	c0 64       	brge	8000aba4 <_vfprintf_r+0xb6c>
8000ab9a:	fa cc f9 44 	sub	r12,sp,-1724
8000ab9e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000aba2:	c1 d8       	rjmp	8000abdc <_vfprintf_r+0xba4>
8000aba4:	fa c8 f9 50 	sub	r8,sp,-1712
8000aba8:	1a d8       	st.w	--sp,r8
8000abaa:	fa c8 fa b8 	sub	r8,sp,-1352
8000abae:	04 9a       	mov	r10,r2
8000abb0:	1a d8       	st.w	--sp,r8
8000abb2:	fa c8 fb b4 	sub	r8,sp,-1100
8000abb6:	0c 9b       	mov	r11,r6
8000abb8:	1a d8       	st.w	--sp,r8
8000abba:	08 9c       	mov	r12,r4
8000abbc:	fa c8 f9 40 	sub	r8,sp,-1728
8000abc0:	fa c9 ff b4 	sub	r9,sp,-76
8000abc4:	fe b0 f8 a2 	rcall	80009d08 <get_arg>
8000abc8:	2f dd       	sub	sp,-12
8000abca:	78 0a       	ld.w	r10,r12[0x0]
8000abcc:	c2 08       	rjmp	8000ac0c <_vfprintf_r+0xbd4>
8000abce:	2f f7       	sub	r7,-1
8000abd0:	10 39       	cp.w	r9,r8
8000abd2:	c0 84       	brge	8000abe2 <_vfprintf_r+0xbaa>
8000abd4:	fa cb f9 44 	sub	r11,sp,-1724
8000abd8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000abdc:	ec fa fd 88 	ld.w	r10,r6[-632]
8000abe0:	c1 68       	rjmp	8000ac0c <_vfprintf_r+0xbd4>
8000abe2:	41 09       	lddsp	r9,sp[0x40]
8000abe4:	59 f8       	cp.w	r8,31
8000abe6:	e0 89 00 10 	brgt	8000ac06 <_vfprintf_r+0xbce>
8000abea:	f2 ca ff fc 	sub	r10,r9,-4
8000abee:	51 0a       	stdsp	sp[0x40],r10
8000abf0:	fa c6 f9 44 	sub	r6,sp,-1724
8000abf4:	72 0a       	ld.w	r10,r9[0x0]
8000abf6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000abfa:	f3 4a fd 88 	st.w	r9[-632],r10
8000abfe:	2f f8       	sub	r8,-1
8000ac00:	fb 48 06 b4 	st.w	sp[1716],r8
8000ac04:	c0 48       	rjmp	8000ac0c <_vfprintf_r+0xbd4>
8000ac06:	72 0a       	ld.w	r10,r9[0x0]
8000ac08:	2f c9       	sub	r9,-4
8000ac0a:	51 09       	stdsp	sp[0x40],r9
8000ac0c:	40 be       	lddsp	lr,sp[0x2c]
8000ac0e:	1c 98       	mov	r8,lr
8000ac10:	95 1e       	st.w	r10[0x4],lr
8000ac12:	bf 58       	asr	r8,0x1f
8000ac14:	95 08       	st.w	r10[0x0],r8
8000ac16:	fe 9f fa 9f 	bral	8000a154 <_vfprintf_r+0x11c>
8000ac1a:	ed b5 00 04 	bld	r5,0x4
8000ac1e:	c4 80       	breq	8000acae <_vfprintf_r+0xc76>
8000ac20:	e2 15 00 40 	andl	r5,0x40,COH
8000ac24:	c4 50       	breq	8000acae <_vfprintf_r+0xc76>
8000ac26:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ac2a:	40 3c       	lddsp	r12,sp[0xc]
8000ac2c:	58 0c       	cp.w	r12,0
8000ac2e:	c1 d0       	breq	8000ac68 <_vfprintf_r+0xc30>
8000ac30:	10 36       	cp.w	r6,r8
8000ac32:	c0 64       	brge	8000ac3e <_vfprintf_r+0xc06>
8000ac34:	fa cb f9 44 	sub	r11,sp,-1724
8000ac38:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ac3c:	c1 d8       	rjmp	8000ac76 <_vfprintf_r+0xc3e>
8000ac3e:	fa c8 f9 50 	sub	r8,sp,-1712
8000ac42:	1a d8       	st.w	--sp,r8
8000ac44:	fa c8 fa b8 	sub	r8,sp,-1352
8000ac48:	04 9a       	mov	r10,r2
8000ac4a:	1a d8       	st.w	--sp,r8
8000ac4c:	fa c8 fb b4 	sub	r8,sp,-1100
8000ac50:	0c 9b       	mov	r11,r6
8000ac52:	1a d8       	st.w	--sp,r8
8000ac54:	08 9c       	mov	r12,r4
8000ac56:	fa c8 f9 40 	sub	r8,sp,-1728
8000ac5a:	fa c9 ff b4 	sub	r9,sp,-76
8000ac5e:	fe b0 f8 55 	rcall	80009d08 <get_arg>
8000ac62:	2f dd       	sub	sp,-12
8000ac64:	78 0a       	ld.w	r10,r12[0x0]
8000ac66:	c2 08       	rjmp	8000aca6 <_vfprintf_r+0xc6e>
8000ac68:	2f f7       	sub	r7,-1
8000ac6a:	10 39       	cp.w	r9,r8
8000ac6c:	c0 84       	brge	8000ac7c <_vfprintf_r+0xc44>
8000ac6e:	fa ca f9 44 	sub	r10,sp,-1724
8000ac72:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000ac76:	ec fa fd 88 	ld.w	r10,r6[-632]
8000ac7a:	c1 68       	rjmp	8000aca6 <_vfprintf_r+0xc6e>
8000ac7c:	41 09       	lddsp	r9,sp[0x40]
8000ac7e:	59 f8       	cp.w	r8,31
8000ac80:	e0 89 00 10 	brgt	8000aca0 <_vfprintf_r+0xc68>
8000ac84:	f2 ca ff fc 	sub	r10,r9,-4
8000ac88:	51 0a       	stdsp	sp[0x40],r10
8000ac8a:	fa c6 f9 44 	sub	r6,sp,-1724
8000ac8e:	72 0a       	ld.w	r10,r9[0x0]
8000ac90:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ac94:	f3 4a fd 88 	st.w	r9[-632],r10
8000ac98:	2f f8       	sub	r8,-1
8000ac9a:	fb 48 06 b4 	st.w	sp[1716],r8
8000ac9e:	c0 48       	rjmp	8000aca6 <_vfprintf_r+0xc6e>
8000aca0:	72 0a       	ld.w	r10,r9[0x0]
8000aca2:	2f c9       	sub	r9,-4
8000aca4:	51 09       	stdsp	sp[0x40],r9
8000aca6:	40 be       	lddsp	lr,sp[0x2c]
8000aca8:	b4 0e       	st.h	r10[0x0],lr
8000acaa:	fe 9f fa 55 	bral	8000a154 <_vfprintf_r+0x11c>
8000acae:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000acb2:	40 3c       	lddsp	r12,sp[0xc]
8000acb4:	58 0c       	cp.w	r12,0
8000acb6:	c1 d0       	breq	8000acf0 <_vfprintf_r+0xcb8>
8000acb8:	10 36       	cp.w	r6,r8
8000acba:	c0 64       	brge	8000acc6 <_vfprintf_r+0xc8e>
8000acbc:	fa cb f9 44 	sub	r11,sp,-1724
8000acc0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000acc4:	c1 d8       	rjmp	8000acfe <_vfprintf_r+0xcc6>
8000acc6:	fa c8 f9 50 	sub	r8,sp,-1712
8000acca:	1a d8       	st.w	--sp,r8
8000accc:	fa c8 fa b8 	sub	r8,sp,-1352
8000acd0:	04 9a       	mov	r10,r2
8000acd2:	1a d8       	st.w	--sp,r8
8000acd4:	fa c8 fb b4 	sub	r8,sp,-1100
8000acd8:	0c 9b       	mov	r11,r6
8000acda:	1a d8       	st.w	--sp,r8
8000acdc:	08 9c       	mov	r12,r4
8000acde:	fa c8 f9 40 	sub	r8,sp,-1728
8000ace2:	fa c9 ff b4 	sub	r9,sp,-76
8000ace6:	fe b0 f8 11 	rcall	80009d08 <get_arg>
8000acea:	2f dd       	sub	sp,-12
8000acec:	78 0a       	ld.w	r10,r12[0x0]
8000acee:	c2 08       	rjmp	8000ad2e <_vfprintf_r+0xcf6>
8000acf0:	2f f7       	sub	r7,-1
8000acf2:	10 39       	cp.w	r9,r8
8000acf4:	c0 84       	brge	8000ad04 <_vfprintf_r+0xccc>
8000acf6:	fa ca f9 44 	sub	r10,sp,-1724
8000acfa:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000acfe:	ec fa fd 88 	ld.w	r10,r6[-632]
8000ad02:	c1 68       	rjmp	8000ad2e <_vfprintf_r+0xcf6>
8000ad04:	41 09       	lddsp	r9,sp[0x40]
8000ad06:	59 f8       	cp.w	r8,31
8000ad08:	e0 89 00 10 	brgt	8000ad28 <_vfprintf_r+0xcf0>
8000ad0c:	f2 ca ff fc 	sub	r10,r9,-4
8000ad10:	51 0a       	stdsp	sp[0x40],r10
8000ad12:	fa c6 f9 44 	sub	r6,sp,-1724
8000ad16:	72 0a       	ld.w	r10,r9[0x0]
8000ad18:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ad1c:	f3 4a fd 88 	st.w	r9[-632],r10
8000ad20:	2f f8       	sub	r8,-1
8000ad22:	fb 48 06 b4 	st.w	sp[1716],r8
8000ad26:	c0 48       	rjmp	8000ad2e <_vfprintf_r+0xcf6>
8000ad28:	72 0a       	ld.w	r10,r9[0x0]
8000ad2a:	2f c9       	sub	r9,-4
8000ad2c:	51 09       	stdsp	sp[0x40],r9
8000ad2e:	40 be       	lddsp	lr,sp[0x2c]
8000ad30:	95 0e       	st.w	r10[0x0],lr
8000ad32:	fe 9f fa 11 	bral	8000a154 <_vfprintf_r+0x11c>
8000ad36:	50 a7       	stdsp	sp[0x28],r7
8000ad38:	50 80       	stdsp	sp[0x20],r0
8000ad3a:	0c 97       	mov	r7,r6
8000ad3c:	04 94       	mov	r4,r2
8000ad3e:	06 96       	mov	r6,r3
8000ad40:	02 92       	mov	r2,r1
8000ad42:	40 93       	lddsp	r3,sp[0x24]
8000ad44:	10 90       	mov	r0,r8
8000ad46:	40 41       	lddsp	r1,sp[0x10]
8000ad48:	a5 a5       	sbr	r5,0x4
8000ad4a:	c0 a8       	rjmp	8000ad5e <_vfprintf_r+0xd26>
8000ad4c:	50 a7       	stdsp	sp[0x28],r7
8000ad4e:	50 80       	stdsp	sp[0x20],r0
8000ad50:	0c 97       	mov	r7,r6
8000ad52:	04 94       	mov	r4,r2
8000ad54:	06 96       	mov	r6,r3
8000ad56:	02 92       	mov	r2,r1
8000ad58:	40 93       	lddsp	r3,sp[0x24]
8000ad5a:	10 90       	mov	r0,r8
8000ad5c:	40 41       	lddsp	r1,sp[0x10]
8000ad5e:	ed b5 00 05 	bld	r5,0x5
8000ad62:	c5 d1       	brne	8000ae1c <_vfprintf_r+0xde4>
8000ad64:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ad68:	40 3c       	lddsp	r12,sp[0xc]
8000ad6a:	58 0c       	cp.w	r12,0
8000ad6c:	c2 60       	breq	8000adb8 <_vfprintf_r+0xd80>
8000ad6e:	10 36       	cp.w	r6,r8
8000ad70:	c0 a4       	brge	8000ad84 <_vfprintf_r+0xd4c>
8000ad72:	fa cb f9 44 	sub	r11,sp,-1724
8000ad76:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ad7a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000ad7e:	fa e9 00 00 	st.d	sp[0],r8
8000ad82:	c1 88       	rjmp	8000adb2 <_vfprintf_r+0xd7a>
8000ad84:	fa c8 f9 50 	sub	r8,sp,-1712
8000ad88:	1a d8       	st.w	--sp,r8
8000ad8a:	fa c8 fa b8 	sub	r8,sp,-1352
8000ad8e:	04 9a       	mov	r10,r2
8000ad90:	1a d8       	st.w	--sp,r8
8000ad92:	0c 9b       	mov	r11,r6
8000ad94:	fa c8 fb b4 	sub	r8,sp,-1100
8000ad98:	08 9c       	mov	r12,r4
8000ad9a:	1a d8       	st.w	--sp,r8
8000ad9c:	fa c8 f9 40 	sub	r8,sp,-1728
8000ada0:	fa c9 ff b4 	sub	r9,sp,-76
8000ada4:	fe b0 f7 b2 	rcall	80009d08 <get_arg>
8000ada8:	2f dd       	sub	sp,-12
8000adaa:	f8 ea 00 00 	ld.d	r10,r12[0]
8000adae:	fa eb 00 00 	st.d	sp[0],r10
8000adb2:	30 08       	mov	r8,0
8000adb4:	e0 8f 03 de 	bral	8000b570 <_vfprintf_r+0x1538>
8000adb8:	ee ca ff ff 	sub	r10,r7,-1
8000adbc:	10 37       	cp.w	r7,r8
8000adbe:	c0 b4       	brge	8000add4 <_vfprintf_r+0xd9c>
8000adc0:	fa c9 f9 44 	sub	r9,sp,-1724
8000adc4:	14 97       	mov	r7,r10
8000adc6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000adca:	ec ea fd 88 	ld.d	r10,r6[-632]
8000adce:	fa eb 00 00 	st.d	sp[0],r10
8000add2:	c1 88       	rjmp	8000ae02 <_vfprintf_r+0xdca>
8000add4:	41 09       	lddsp	r9,sp[0x40]
8000add6:	59 f8       	cp.w	r8,31
8000add8:	e0 89 00 18 	brgt	8000ae08 <_vfprintf_r+0xdd0>
8000addc:	f2 e6 00 00 	ld.d	r6,r9[0]
8000ade0:	f2 cb ff f8 	sub	r11,r9,-8
8000ade4:	fa e7 00 00 	st.d	sp[0],r6
8000ade8:	51 0b       	stdsp	sp[0x40],r11
8000adea:	fa c6 f9 44 	sub	r6,sp,-1724
8000adee:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000adf2:	fa e6 00 00 	ld.d	r6,sp[0]
8000adf6:	f2 e7 fd 88 	st.d	r9[-632],r6
8000adfa:	2f f8       	sub	r8,-1
8000adfc:	14 97       	mov	r7,r10
8000adfe:	fb 48 06 b4 	st.w	sp[1716],r8
8000ae02:	40 38       	lddsp	r8,sp[0xc]
8000ae04:	e0 8f 03 b6 	bral	8000b570 <_vfprintf_r+0x1538>
8000ae08:	f2 e6 00 00 	ld.d	r6,r9[0]
8000ae0c:	40 38       	lddsp	r8,sp[0xc]
8000ae0e:	fa e7 00 00 	st.d	sp[0],r6
8000ae12:	2f 89       	sub	r9,-8
8000ae14:	14 97       	mov	r7,r10
8000ae16:	51 09       	stdsp	sp[0x40],r9
8000ae18:	e0 8f 03 ac 	bral	8000b570 <_vfprintf_r+0x1538>
8000ae1c:	ed b5 00 04 	bld	r5,0x4
8000ae20:	c1 61       	brne	8000ae4c <_vfprintf_r+0xe14>
8000ae22:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ae26:	40 3e       	lddsp	lr,sp[0xc]
8000ae28:	58 0e       	cp.w	lr,0
8000ae2a:	c0 80       	breq	8000ae3a <_vfprintf_r+0xe02>
8000ae2c:	10 36       	cp.w	r6,r8
8000ae2e:	c6 74       	brge	8000aefc <_vfprintf_r+0xec4>
8000ae30:	fa cc f9 44 	sub	r12,sp,-1724
8000ae34:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000ae38:	c8 08       	rjmp	8000af38 <_vfprintf_r+0xf00>
8000ae3a:	ee ca ff ff 	sub	r10,r7,-1
8000ae3e:	10 37       	cp.w	r7,r8
8000ae40:	c7 f4       	brge	8000af3e <_vfprintf_r+0xf06>
8000ae42:	fa cb f9 44 	sub	r11,sp,-1724
8000ae46:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ae4a:	c7 68       	rjmp	8000af36 <_vfprintf_r+0xefe>
8000ae4c:	ed b5 00 06 	bld	r5,0x6
8000ae50:	c4 a1       	brne	8000aee4 <_vfprintf_r+0xeac>
8000ae52:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ae56:	40 3c       	lddsp	r12,sp[0xc]
8000ae58:	58 0c       	cp.w	r12,0
8000ae5a:	c1 d0       	breq	8000ae94 <_vfprintf_r+0xe5c>
8000ae5c:	10 36       	cp.w	r6,r8
8000ae5e:	c0 64       	brge	8000ae6a <_vfprintf_r+0xe32>
8000ae60:	fa cb f9 44 	sub	r11,sp,-1724
8000ae64:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ae68:	c1 f8       	rjmp	8000aea6 <_vfprintf_r+0xe6e>
8000ae6a:	fa c8 f9 50 	sub	r8,sp,-1712
8000ae6e:	1a d8       	st.w	--sp,r8
8000ae70:	fa c8 fa b8 	sub	r8,sp,-1352
8000ae74:	1a d8       	st.w	--sp,r8
8000ae76:	fa c8 fb b4 	sub	r8,sp,-1100
8000ae7a:	1a d8       	st.w	--sp,r8
8000ae7c:	fa c8 f9 40 	sub	r8,sp,-1728
8000ae80:	fa c9 ff b4 	sub	r9,sp,-76
8000ae84:	04 9a       	mov	r10,r2
8000ae86:	0c 9b       	mov	r11,r6
8000ae88:	08 9c       	mov	r12,r4
8000ae8a:	fe b0 f7 3f 	rcall	80009d08 <get_arg>
8000ae8e:	2f dd       	sub	sp,-12
8000ae90:	98 18       	ld.sh	r8,r12[0x2]
8000ae92:	c2 68       	rjmp	8000aede <_vfprintf_r+0xea6>
8000ae94:	ee ca ff ff 	sub	r10,r7,-1
8000ae98:	10 37       	cp.w	r7,r8
8000ae9a:	c0 94       	brge	8000aeac <_vfprintf_r+0xe74>
8000ae9c:	fa c9 f9 44 	sub	r9,sp,-1724
8000aea0:	14 97       	mov	r7,r10
8000aea2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000aea6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000aeaa:	c1 a8       	rjmp	8000aede <_vfprintf_r+0xea6>
8000aeac:	41 09       	lddsp	r9,sp[0x40]
8000aeae:	59 f8       	cp.w	r8,31
8000aeb0:	e0 89 00 13 	brgt	8000aed6 <_vfprintf_r+0xe9e>
8000aeb4:	f2 cb ff fc 	sub	r11,r9,-4
8000aeb8:	51 0b       	stdsp	sp[0x40],r11
8000aeba:	72 09       	ld.w	r9,r9[0x0]
8000aebc:	fa c6 f9 44 	sub	r6,sp,-1724
8000aec0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000aec4:	2f f8       	sub	r8,-1
8000aec6:	f7 49 fd 88 	st.w	r11[-632],r9
8000aeca:	fb 48 06 b4 	st.w	sp[1716],r8
8000aece:	14 97       	mov	r7,r10
8000aed0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000aed4:	c0 58       	rjmp	8000aede <_vfprintf_r+0xea6>
8000aed6:	92 18       	ld.sh	r8,r9[0x2]
8000aed8:	14 97       	mov	r7,r10
8000aeda:	2f c9       	sub	r9,-4
8000aedc:	51 09       	stdsp	sp[0x40],r9
8000aede:	5c 78       	castu.h	r8
8000aee0:	50 18       	stdsp	sp[0x4],r8
8000aee2:	c4 68       	rjmp	8000af6e <_vfprintf_r+0xf36>
8000aee4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000aee8:	40 3c       	lddsp	r12,sp[0xc]
8000aeea:	58 0c       	cp.w	r12,0
8000aeec:	c1 d0       	breq	8000af26 <_vfprintf_r+0xeee>
8000aeee:	10 36       	cp.w	r6,r8
8000aef0:	c0 64       	brge	8000aefc <_vfprintf_r+0xec4>
8000aef2:	fa cb f9 44 	sub	r11,sp,-1724
8000aef6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000aefa:	c1 f8       	rjmp	8000af38 <_vfprintf_r+0xf00>
8000aefc:	fa c8 f9 50 	sub	r8,sp,-1712
8000af00:	1a d8       	st.w	--sp,r8
8000af02:	fa c8 fa b8 	sub	r8,sp,-1352
8000af06:	0c 9b       	mov	r11,r6
8000af08:	1a d8       	st.w	--sp,r8
8000af0a:	fa c8 fb b4 	sub	r8,sp,-1100
8000af0e:	04 9a       	mov	r10,r2
8000af10:	1a d8       	st.w	--sp,r8
8000af12:	08 9c       	mov	r12,r4
8000af14:	fa c8 f9 40 	sub	r8,sp,-1728
8000af18:	fa c9 ff b4 	sub	r9,sp,-76
8000af1c:	fe b0 f6 f6 	rcall	80009d08 <get_arg>
8000af20:	2f dd       	sub	sp,-12
8000af22:	78 0b       	ld.w	r11,r12[0x0]
8000af24:	c2 48       	rjmp	8000af6c <_vfprintf_r+0xf34>
8000af26:	ee ca ff ff 	sub	r10,r7,-1
8000af2a:	10 37       	cp.w	r7,r8
8000af2c:	c0 94       	brge	8000af3e <_vfprintf_r+0xf06>
8000af2e:	fa c9 f9 44 	sub	r9,sp,-1724
8000af32:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000af36:	14 97       	mov	r7,r10
8000af38:	ec fb fd 88 	ld.w	r11,r6[-632]
8000af3c:	c1 88       	rjmp	8000af6c <_vfprintf_r+0xf34>
8000af3e:	41 09       	lddsp	r9,sp[0x40]
8000af40:	59 f8       	cp.w	r8,31
8000af42:	e0 89 00 11 	brgt	8000af64 <_vfprintf_r+0xf2c>
8000af46:	f2 cb ff fc 	sub	r11,r9,-4
8000af4a:	51 0b       	stdsp	sp[0x40],r11
8000af4c:	fa c6 f9 44 	sub	r6,sp,-1724
8000af50:	72 0b       	ld.w	r11,r9[0x0]
8000af52:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000af56:	f3 4b fd 88 	st.w	r9[-632],r11
8000af5a:	2f f8       	sub	r8,-1
8000af5c:	14 97       	mov	r7,r10
8000af5e:	fb 48 06 b4 	st.w	sp[1716],r8
8000af62:	c0 58       	rjmp	8000af6c <_vfprintf_r+0xf34>
8000af64:	72 0b       	ld.w	r11,r9[0x0]
8000af66:	14 97       	mov	r7,r10
8000af68:	2f c9       	sub	r9,-4
8000af6a:	51 09       	stdsp	sp[0x40],r9
8000af6c:	50 1b       	stdsp	sp[0x4],r11
8000af6e:	30 0e       	mov	lr,0
8000af70:	50 0e       	stdsp	sp[0x0],lr
8000af72:	1c 98       	mov	r8,lr
8000af74:	e0 8f 02 fe 	bral	8000b570 <_vfprintf_r+0x1538>
8000af78:	50 a7       	stdsp	sp[0x28],r7
8000af7a:	50 80       	stdsp	sp[0x20],r0
8000af7c:	0c 97       	mov	r7,r6
8000af7e:	04 94       	mov	r4,r2
8000af80:	06 96       	mov	r6,r3
8000af82:	02 92       	mov	r2,r1
8000af84:	40 93       	lddsp	r3,sp[0x24]
8000af86:	40 41       	lddsp	r1,sp[0x10]
8000af88:	0e 99       	mov	r9,r7
8000af8a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000af8e:	40 3c       	lddsp	r12,sp[0xc]
8000af90:	58 0c       	cp.w	r12,0
8000af92:	c1 d0       	breq	8000afcc <_vfprintf_r+0xf94>
8000af94:	10 36       	cp.w	r6,r8
8000af96:	c0 64       	brge	8000afa2 <_vfprintf_r+0xf6a>
8000af98:	fa cb f9 44 	sub	r11,sp,-1724
8000af9c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000afa0:	c1 d8       	rjmp	8000afda <_vfprintf_r+0xfa2>
8000afa2:	fa c8 f9 50 	sub	r8,sp,-1712
8000afa6:	1a d8       	st.w	--sp,r8
8000afa8:	fa c8 fa b8 	sub	r8,sp,-1352
8000afac:	1a d8       	st.w	--sp,r8
8000afae:	fa c8 fb b4 	sub	r8,sp,-1100
8000afb2:	1a d8       	st.w	--sp,r8
8000afb4:	fa c9 ff b4 	sub	r9,sp,-76
8000afb8:	fa c8 f9 40 	sub	r8,sp,-1728
8000afbc:	04 9a       	mov	r10,r2
8000afbe:	0c 9b       	mov	r11,r6
8000afc0:	08 9c       	mov	r12,r4
8000afc2:	fe b0 f6 a3 	rcall	80009d08 <get_arg>
8000afc6:	2f dd       	sub	sp,-12
8000afc8:	78 09       	ld.w	r9,r12[0x0]
8000afca:	c2 18       	rjmp	8000b00c <_vfprintf_r+0xfd4>
8000afcc:	2f f7       	sub	r7,-1
8000afce:	10 39       	cp.w	r9,r8
8000afd0:	c0 84       	brge	8000afe0 <_vfprintf_r+0xfa8>
8000afd2:	fa ca f9 44 	sub	r10,sp,-1724
8000afd6:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000afda:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000afde:	c1 78       	rjmp	8000b00c <_vfprintf_r+0xfd4>
8000afe0:	41 09       	lddsp	r9,sp[0x40]
8000afe2:	59 f8       	cp.w	r8,31
8000afe4:	e0 89 00 10 	brgt	8000b004 <_vfprintf_r+0xfcc>
8000afe8:	f2 ca ff fc 	sub	r10,r9,-4
8000afec:	51 0a       	stdsp	sp[0x40],r10
8000afee:	fa c6 f9 44 	sub	r6,sp,-1724
8000aff2:	72 09       	ld.w	r9,r9[0x0]
8000aff4:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000aff8:	f5 49 fd 88 	st.w	r10[-632],r9
8000affc:	2f f8       	sub	r8,-1
8000affe:	fb 48 06 b4 	st.w	sp[1716],r8
8000b002:	c0 58       	rjmp	8000b00c <_vfprintf_r+0xfd4>
8000b004:	f2 c8 ff fc 	sub	r8,r9,-4
8000b008:	51 08       	stdsp	sp[0x40],r8
8000b00a:	72 09       	ld.w	r9,r9[0x0]
8000b00c:	33 08       	mov	r8,48
8000b00e:	fb 68 06 b8 	st.b	sp[1720],r8
8000b012:	37 88       	mov	r8,120
8000b014:	30 0e       	mov	lr,0
8000b016:	fb 68 06 b9 	st.b	sp[1721],r8
8000b01a:	fe cc b9 ba 	sub	r12,pc,-17990
8000b01e:	50 19       	stdsp	sp[0x4],r9
8000b020:	a1 b5       	sbr	r5,0x1
8000b022:	50 0e       	stdsp	sp[0x0],lr
8000b024:	50 dc       	stdsp	sp[0x34],r12
8000b026:	30 28       	mov	r8,2
8000b028:	37 80       	mov	r0,120
8000b02a:	e0 8f 02 a3 	bral	8000b570 <_vfprintf_r+0x1538>
8000b02e:	50 a7       	stdsp	sp[0x28],r7
8000b030:	50 80       	stdsp	sp[0x20],r0
8000b032:	10 90       	mov	r0,r8
8000b034:	30 08       	mov	r8,0
8000b036:	fb 68 06 bb 	st.b	sp[1723],r8
8000b03a:	0c 97       	mov	r7,r6
8000b03c:	04 94       	mov	r4,r2
8000b03e:	06 96       	mov	r6,r3
8000b040:	02 92       	mov	r2,r1
8000b042:	40 93       	lddsp	r3,sp[0x24]
8000b044:	40 41       	lddsp	r1,sp[0x10]
8000b046:	0e 99       	mov	r9,r7
8000b048:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b04c:	40 3b       	lddsp	r11,sp[0xc]
8000b04e:	58 0b       	cp.w	r11,0
8000b050:	c1 d0       	breq	8000b08a <_vfprintf_r+0x1052>
8000b052:	10 36       	cp.w	r6,r8
8000b054:	c0 64       	brge	8000b060 <_vfprintf_r+0x1028>
8000b056:	fa ca f9 44 	sub	r10,sp,-1724
8000b05a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b05e:	c1 d8       	rjmp	8000b098 <_vfprintf_r+0x1060>
8000b060:	fa c8 f9 50 	sub	r8,sp,-1712
8000b064:	1a d8       	st.w	--sp,r8
8000b066:	fa c8 fa b8 	sub	r8,sp,-1352
8000b06a:	1a d8       	st.w	--sp,r8
8000b06c:	fa c8 fb b4 	sub	r8,sp,-1100
8000b070:	0c 9b       	mov	r11,r6
8000b072:	1a d8       	st.w	--sp,r8
8000b074:	04 9a       	mov	r10,r2
8000b076:	fa c8 f9 40 	sub	r8,sp,-1728
8000b07a:	fa c9 ff b4 	sub	r9,sp,-76
8000b07e:	08 9c       	mov	r12,r4
8000b080:	fe b0 f6 44 	rcall	80009d08 <get_arg>
8000b084:	2f dd       	sub	sp,-12
8000b086:	78 06       	ld.w	r6,r12[0x0]
8000b088:	c2 08       	rjmp	8000b0c8 <_vfprintf_r+0x1090>
8000b08a:	2f f7       	sub	r7,-1
8000b08c:	10 39       	cp.w	r9,r8
8000b08e:	c0 84       	brge	8000b09e <_vfprintf_r+0x1066>
8000b090:	fa c9 f9 44 	sub	r9,sp,-1724
8000b094:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b098:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000b09c:	c1 68       	rjmp	8000b0c8 <_vfprintf_r+0x1090>
8000b09e:	41 09       	lddsp	r9,sp[0x40]
8000b0a0:	59 f8       	cp.w	r8,31
8000b0a2:	e0 89 00 10 	brgt	8000b0c2 <_vfprintf_r+0x108a>
8000b0a6:	f2 ca ff fc 	sub	r10,r9,-4
8000b0aa:	51 0a       	stdsp	sp[0x40],r10
8000b0ac:	72 06       	ld.w	r6,r9[0x0]
8000b0ae:	fa ce f9 44 	sub	lr,sp,-1724
8000b0b2:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000b0b6:	f3 46 fd 88 	st.w	r9[-632],r6
8000b0ba:	2f f8       	sub	r8,-1
8000b0bc:	fb 48 06 b4 	st.w	sp[1716],r8
8000b0c0:	c0 48       	rjmp	8000b0c8 <_vfprintf_r+0x1090>
8000b0c2:	72 06       	ld.w	r6,r9[0x0]
8000b0c4:	2f c9       	sub	r9,-4
8000b0c6:	51 09       	stdsp	sp[0x40],r9
8000b0c8:	40 2c       	lddsp	r12,sp[0x8]
8000b0ca:	58 0c       	cp.w	r12,0
8000b0cc:	c1 05       	brlt	8000b0ec <_vfprintf_r+0x10b4>
8000b0ce:	18 9a       	mov	r10,r12
8000b0d0:	30 0b       	mov	r11,0
8000b0d2:	0c 9c       	mov	r12,r6
8000b0d4:	e0 a0 12 38 	rcall	8000d544 <memchr>
8000b0d8:	e0 80 02 df 	breq	8000b696 <_vfprintf_r+0x165e>
8000b0dc:	f8 06 01 02 	sub	r2,r12,r6
8000b0e0:	40 2b       	lddsp	r11,sp[0x8]
8000b0e2:	16 32       	cp.w	r2,r11
8000b0e4:	e0 89 02 d9 	brgt	8000b696 <_vfprintf_r+0x165e>
8000b0e8:	e0 8f 02 d4 	bral	8000b690 <_vfprintf_r+0x1658>
8000b0ec:	30 0a       	mov	r10,0
8000b0ee:	0c 9c       	mov	r12,r6
8000b0f0:	50 2a       	stdsp	sp[0x8],r10
8000b0f2:	fe b0 f5 85 	rcall	80009bfc <strlen>
8000b0f6:	18 92       	mov	r2,r12
8000b0f8:	e0 8f 02 d2 	bral	8000b69c <_vfprintf_r+0x1664>
8000b0fc:	50 a7       	stdsp	sp[0x28],r7
8000b0fe:	50 80       	stdsp	sp[0x20],r0
8000b100:	0c 97       	mov	r7,r6
8000b102:	04 94       	mov	r4,r2
8000b104:	06 96       	mov	r6,r3
8000b106:	02 92       	mov	r2,r1
8000b108:	40 93       	lddsp	r3,sp[0x24]
8000b10a:	10 90       	mov	r0,r8
8000b10c:	40 41       	lddsp	r1,sp[0x10]
8000b10e:	a5 a5       	sbr	r5,0x4
8000b110:	c0 a8       	rjmp	8000b124 <_vfprintf_r+0x10ec>
8000b112:	50 a7       	stdsp	sp[0x28],r7
8000b114:	50 80       	stdsp	sp[0x20],r0
8000b116:	0c 97       	mov	r7,r6
8000b118:	04 94       	mov	r4,r2
8000b11a:	06 96       	mov	r6,r3
8000b11c:	02 92       	mov	r2,r1
8000b11e:	40 93       	lddsp	r3,sp[0x24]
8000b120:	10 90       	mov	r0,r8
8000b122:	40 41       	lddsp	r1,sp[0x10]
8000b124:	ed b5 00 05 	bld	r5,0x5
8000b128:	c5 61       	brne	8000b1d4 <_vfprintf_r+0x119c>
8000b12a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b12e:	40 39       	lddsp	r9,sp[0xc]
8000b130:	58 09       	cp.w	r9,0
8000b132:	c2 10       	breq	8000b174 <_vfprintf_r+0x113c>
8000b134:	10 36       	cp.w	r6,r8
8000b136:	c0 74       	brge	8000b144 <_vfprintf_r+0x110c>
8000b138:	fa c8 f9 44 	sub	r8,sp,-1724
8000b13c:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000b140:	c2 38       	rjmp	8000b186 <_vfprintf_r+0x114e>
8000b142:	d7 03       	nop
8000b144:	fa c8 f9 50 	sub	r8,sp,-1712
8000b148:	1a d8       	st.w	--sp,r8
8000b14a:	fa c8 fa b8 	sub	r8,sp,-1352
8000b14e:	1a d8       	st.w	--sp,r8
8000b150:	fa c8 fb b4 	sub	r8,sp,-1100
8000b154:	1a d8       	st.w	--sp,r8
8000b156:	fa c8 f9 40 	sub	r8,sp,-1728
8000b15a:	fa c9 ff b4 	sub	r9,sp,-76
8000b15e:	04 9a       	mov	r10,r2
8000b160:	0c 9b       	mov	r11,r6
8000b162:	08 9c       	mov	r12,r4
8000b164:	fe b0 f5 d2 	rcall	80009d08 <get_arg>
8000b168:	2f dd       	sub	sp,-12
8000b16a:	f8 e8 00 00 	ld.d	r8,r12[0]
8000b16e:	fa e9 00 00 	st.d	sp[0],r8
8000b172:	c2 e8       	rjmp	8000b1ce <_vfprintf_r+0x1196>
8000b174:	ee ca ff ff 	sub	r10,r7,-1
8000b178:	10 37       	cp.w	r7,r8
8000b17a:	c0 b4       	brge	8000b190 <_vfprintf_r+0x1158>
8000b17c:	fa c8 f9 44 	sub	r8,sp,-1724
8000b180:	14 97       	mov	r7,r10
8000b182:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000b186:	ec ea fd 88 	ld.d	r10,r6[-632]
8000b18a:	fa eb 00 00 	st.d	sp[0],r10
8000b18e:	c2 08       	rjmp	8000b1ce <_vfprintf_r+0x1196>
8000b190:	41 09       	lddsp	r9,sp[0x40]
8000b192:	59 f8       	cp.w	r8,31
8000b194:	e0 89 00 16 	brgt	8000b1c0 <_vfprintf_r+0x1188>
8000b198:	f2 e6 00 00 	ld.d	r6,r9[0]
8000b19c:	f2 cb ff f8 	sub	r11,r9,-8
8000b1a0:	fa e7 00 00 	st.d	sp[0],r6
8000b1a4:	51 0b       	stdsp	sp[0x40],r11
8000b1a6:	fa c6 f9 44 	sub	r6,sp,-1724
8000b1aa:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b1ae:	fa e6 00 00 	ld.d	r6,sp[0]
8000b1b2:	f2 e7 fd 88 	st.d	r9[-632],r6
8000b1b6:	2f f8       	sub	r8,-1
8000b1b8:	14 97       	mov	r7,r10
8000b1ba:	fb 48 06 b4 	st.w	sp[1716],r8
8000b1be:	c0 88       	rjmp	8000b1ce <_vfprintf_r+0x1196>
8000b1c0:	f2 e6 00 00 	ld.d	r6,r9[0]
8000b1c4:	2f 89       	sub	r9,-8
8000b1c6:	fa e7 00 00 	st.d	sp[0],r6
8000b1ca:	51 09       	stdsp	sp[0x40],r9
8000b1cc:	14 97       	mov	r7,r10
8000b1ce:	30 18       	mov	r8,1
8000b1d0:	e0 8f 01 d0 	bral	8000b570 <_vfprintf_r+0x1538>
8000b1d4:	ed b5 00 04 	bld	r5,0x4
8000b1d8:	c1 61       	brne	8000b204 <_vfprintf_r+0x11cc>
8000b1da:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b1de:	40 3e       	lddsp	lr,sp[0xc]
8000b1e0:	58 0e       	cp.w	lr,0
8000b1e2:	c0 80       	breq	8000b1f2 <_vfprintf_r+0x11ba>
8000b1e4:	10 36       	cp.w	r6,r8
8000b1e6:	c6 74       	brge	8000b2b4 <_vfprintf_r+0x127c>
8000b1e8:	fa cc f9 44 	sub	r12,sp,-1724
8000b1ec:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b1f0:	c8 08       	rjmp	8000b2f0 <_vfprintf_r+0x12b8>
8000b1f2:	ee ca ff ff 	sub	r10,r7,-1
8000b1f6:	10 37       	cp.w	r7,r8
8000b1f8:	c7 f4       	brge	8000b2f6 <_vfprintf_r+0x12be>
8000b1fa:	fa cb f9 44 	sub	r11,sp,-1724
8000b1fe:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b202:	c7 68       	rjmp	8000b2ee <_vfprintf_r+0x12b6>
8000b204:	ed b5 00 06 	bld	r5,0x6
8000b208:	c4 a1       	brne	8000b29c <_vfprintf_r+0x1264>
8000b20a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b20e:	40 3c       	lddsp	r12,sp[0xc]
8000b210:	58 0c       	cp.w	r12,0
8000b212:	c1 d0       	breq	8000b24c <_vfprintf_r+0x1214>
8000b214:	10 36       	cp.w	r6,r8
8000b216:	c0 64       	brge	8000b222 <_vfprintf_r+0x11ea>
8000b218:	fa cb f9 44 	sub	r11,sp,-1724
8000b21c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b220:	c1 f8       	rjmp	8000b25e <_vfprintf_r+0x1226>
8000b222:	fa c8 f9 50 	sub	r8,sp,-1712
8000b226:	1a d8       	st.w	--sp,r8
8000b228:	fa c8 fa b8 	sub	r8,sp,-1352
8000b22c:	1a d8       	st.w	--sp,r8
8000b22e:	fa c8 fb b4 	sub	r8,sp,-1100
8000b232:	1a d8       	st.w	--sp,r8
8000b234:	fa c8 f9 40 	sub	r8,sp,-1728
8000b238:	fa c9 ff b4 	sub	r9,sp,-76
8000b23c:	04 9a       	mov	r10,r2
8000b23e:	0c 9b       	mov	r11,r6
8000b240:	08 9c       	mov	r12,r4
8000b242:	fe b0 f5 63 	rcall	80009d08 <get_arg>
8000b246:	2f dd       	sub	sp,-12
8000b248:	98 18       	ld.sh	r8,r12[0x2]
8000b24a:	c2 68       	rjmp	8000b296 <_vfprintf_r+0x125e>
8000b24c:	ee ca ff ff 	sub	r10,r7,-1
8000b250:	10 37       	cp.w	r7,r8
8000b252:	c0 94       	brge	8000b264 <_vfprintf_r+0x122c>
8000b254:	fa c9 f9 44 	sub	r9,sp,-1724
8000b258:	14 97       	mov	r7,r10
8000b25a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b25e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000b262:	c1 a8       	rjmp	8000b296 <_vfprintf_r+0x125e>
8000b264:	41 09       	lddsp	r9,sp[0x40]
8000b266:	59 f8       	cp.w	r8,31
8000b268:	e0 89 00 13 	brgt	8000b28e <_vfprintf_r+0x1256>
8000b26c:	f2 cb ff fc 	sub	r11,r9,-4
8000b270:	51 0b       	stdsp	sp[0x40],r11
8000b272:	72 09       	ld.w	r9,r9[0x0]
8000b274:	fa c6 f9 44 	sub	r6,sp,-1724
8000b278:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000b27c:	2f f8       	sub	r8,-1
8000b27e:	f7 49 fd 88 	st.w	r11[-632],r9
8000b282:	fb 48 06 b4 	st.w	sp[1716],r8
8000b286:	14 97       	mov	r7,r10
8000b288:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000b28c:	c0 58       	rjmp	8000b296 <_vfprintf_r+0x125e>
8000b28e:	92 18       	ld.sh	r8,r9[0x2]
8000b290:	14 97       	mov	r7,r10
8000b292:	2f c9       	sub	r9,-4
8000b294:	51 09       	stdsp	sp[0x40],r9
8000b296:	5c 78       	castu.h	r8
8000b298:	50 18       	stdsp	sp[0x4],r8
8000b29a:	c4 68       	rjmp	8000b326 <_vfprintf_r+0x12ee>
8000b29c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b2a0:	40 3c       	lddsp	r12,sp[0xc]
8000b2a2:	58 0c       	cp.w	r12,0
8000b2a4:	c1 d0       	breq	8000b2de <_vfprintf_r+0x12a6>
8000b2a6:	10 36       	cp.w	r6,r8
8000b2a8:	c0 64       	brge	8000b2b4 <_vfprintf_r+0x127c>
8000b2aa:	fa cb f9 44 	sub	r11,sp,-1724
8000b2ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b2b2:	c1 f8       	rjmp	8000b2f0 <_vfprintf_r+0x12b8>
8000b2b4:	fa c8 f9 50 	sub	r8,sp,-1712
8000b2b8:	1a d8       	st.w	--sp,r8
8000b2ba:	fa c8 fa b8 	sub	r8,sp,-1352
8000b2be:	0c 9b       	mov	r11,r6
8000b2c0:	1a d8       	st.w	--sp,r8
8000b2c2:	fa c8 fb b4 	sub	r8,sp,-1100
8000b2c6:	04 9a       	mov	r10,r2
8000b2c8:	1a d8       	st.w	--sp,r8
8000b2ca:	08 9c       	mov	r12,r4
8000b2cc:	fa c8 f9 40 	sub	r8,sp,-1728
8000b2d0:	fa c9 ff b4 	sub	r9,sp,-76
8000b2d4:	fe b0 f5 1a 	rcall	80009d08 <get_arg>
8000b2d8:	2f dd       	sub	sp,-12
8000b2da:	78 0b       	ld.w	r11,r12[0x0]
8000b2dc:	c2 48       	rjmp	8000b324 <_vfprintf_r+0x12ec>
8000b2de:	ee ca ff ff 	sub	r10,r7,-1
8000b2e2:	10 37       	cp.w	r7,r8
8000b2e4:	c0 94       	brge	8000b2f6 <_vfprintf_r+0x12be>
8000b2e6:	fa c9 f9 44 	sub	r9,sp,-1724
8000b2ea:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b2ee:	14 97       	mov	r7,r10
8000b2f0:	ec fb fd 88 	ld.w	r11,r6[-632]
8000b2f4:	c1 88       	rjmp	8000b324 <_vfprintf_r+0x12ec>
8000b2f6:	41 09       	lddsp	r9,sp[0x40]
8000b2f8:	59 f8       	cp.w	r8,31
8000b2fa:	e0 89 00 11 	brgt	8000b31c <_vfprintf_r+0x12e4>
8000b2fe:	f2 cb ff fc 	sub	r11,r9,-4
8000b302:	51 0b       	stdsp	sp[0x40],r11
8000b304:	fa c6 f9 44 	sub	r6,sp,-1724
8000b308:	72 0b       	ld.w	r11,r9[0x0]
8000b30a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b30e:	f3 4b fd 88 	st.w	r9[-632],r11
8000b312:	2f f8       	sub	r8,-1
8000b314:	14 97       	mov	r7,r10
8000b316:	fb 48 06 b4 	st.w	sp[1716],r8
8000b31a:	c0 58       	rjmp	8000b324 <_vfprintf_r+0x12ec>
8000b31c:	72 0b       	ld.w	r11,r9[0x0]
8000b31e:	14 97       	mov	r7,r10
8000b320:	2f c9       	sub	r9,-4
8000b322:	51 09       	stdsp	sp[0x40],r9
8000b324:	50 1b       	stdsp	sp[0x4],r11
8000b326:	30 0e       	mov	lr,0
8000b328:	30 18       	mov	r8,1
8000b32a:	50 0e       	stdsp	sp[0x0],lr
8000b32c:	c2 29       	rjmp	8000b570 <_vfprintf_r+0x1538>
8000b32e:	50 a7       	stdsp	sp[0x28],r7
8000b330:	50 80       	stdsp	sp[0x20],r0
8000b332:	0c 97       	mov	r7,r6
8000b334:	04 94       	mov	r4,r2
8000b336:	06 96       	mov	r6,r3
8000b338:	02 92       	mov	r2,r1
8000b33a:	fe cc bc da 	sub	r12,pc,-17190
8000b33e:	40 93       	lddsp	r3,sp[0x24]
8000b340:	10 90       	mov	r0,r8
8000b342:	40 41       	lddsp	r1,sp[0x10]
8000b344:	50 dc       	stdsp	sp[0x34],r12
8000b346:	ed b5 00 05 	bld	r5,0x5
8000b34a:	c5 51       	brne	8000b3f4 <_vfprintf_r+0x13bc>
8000b34c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b350:	40 3b       	lddsp	r11,sp[0xc]
8000b352:	58 0b       	cp.w	r11,0
8000b354:	c2 20       	breq	8000b398 <_vfprintf_r+0x1360>
8000b356:	10 36       	cp.w	r6,r8
8000b358:	c0 a4       	brge	8000b36c <_vfprintf_r+0x1334>
8000b35a:	fa ca f9 44 	sub	r10,sp,-1724
8000b35e:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b362:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000b366:	fa e9 00 00 	st.d	sp[0],r8
8000b36a:	cf 28       	rjmp	8000b54e <_vfprintf_r+0x1516>
8000b36c:	fa c8 f9 50 	sub	r8,sp,-1712
8000b370:	1a d8       	st.w	--sp,r8
8000b372:	fa c8 fa b8 	sub	r8,sp,-1352
8000b376:	04 9a       	mov	r10,r2
8000b378:	1a d8       	st.w	--sp,r8
8000b37a:	0c 9b       	mov	r11,r6
8000b37c:	fa c8 fb b4 	sub	r8,sp,-1100
8000b380:	08 9c       	mov	r12,r4
8000b382:	1a d8       	st.w	--sp,r8
8000b384:	fa c8 f9 40 	sub	r8,sp,-1728
8000b388:	fa c9 ff b4 	sub	r9,sp,-76
8000b38c:	fe b0 f4 be 	rcall	80009d08 <get_arg>
8000b390:	2f dd       	sub	sp,-12
8000b392:	f8 ea 00 00 	ld.d	r10,r12[0]
8000b396:	c0 c8       	rjmp	8000b3ae <_vfprintf_r+0x1376>
8000b398:	ee ca ff ff 	sub	r10,r7,-1
8000b39c:	10 37       	cp.w	r7,r8
8000b39e:	c0 b4       	brge	8000b3b4 <_vfprintf_r+0x137c>
8000b3a0:	fa c9 f9 44 	sub	r9,sp,-1724
8000b3a4:	14 97       	mov	r7,r10
8000b3a6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b3aa:	ec ea fd 88 	ld.d	r10,r6[-632]
8000b3ae:	fa eb 00 00 	st.d	sp[0],r10
8000b3b2:	cc e8       	rjmp	8000b54e <_vfprintf_r+0x1516>
8000b3b4:	41 09       	lddsp	r9,sp[0x40]
8000b3b6:	59 f8       	cp.w	r8,31
8000b3b8:	e0 89 00 16 	brgt	8000b3e4 <_vfprintf_r+0x13ac>
8000b3bc:	f2 e6 00 00 	ld.d	r6,r9[0]
8000b3c0:	f2 cb ff f8 	sub	r11,r9,-8
8000b3c4:	fa e7 00 00 	st.d	sp[0],r6
8000b3c8:	51 0b       	stdsp	sp[0x40],r11
8000b3ca:	fa c6 f9 44 	sub	r6,sp,-1724
8000b3ce:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b3d2:	fa e6 00 00 	ld.d	r6,sp[0]
8000b3d6:	f2 e7 fd 88 	st.d	r9[-632],r6
8000b3da:	2f f8       	sub	r8,-1
8000b3dc:	14 97       	mov	r7,r10
8000b3de:	fb 48 06 b4 	st.w	sp[1716],r8
8000b3e2:	cb 68       	rjmp	8000b54e <_vfprintf_r+0x1516>
8000b3e4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000b3e8:	2f 89       	sub	r9,-8
8000b3ea:	fa e7 00 00 	st.d	sp[0],r6
8000b3ee:	51 09       	stdsp	sp[0x40],r9
8000b3f0:	14 97       	mov	r7,r10
8000b3f2:	ca e8       	rjmp	8000b54e <_vfprintf_r+0x1516>
8000b3f4:	ed b5 00 04 	bld	r5,0x4
8000b3f8:	c1 71       	brne	8000b426 <_vfprintf_r+0x13ee>
8000b3fa:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b3fe:	40 3e       	lddsp	lr,sp[0xc]
8000b400:	58 0e       	cp.w	lr,0
8000b402:	c0 80       	breq	8000b412 <_vfprintf_r+0x13da>
8000b404:	10 36       	cp.w	r6,r8
8000b406:	c6 94       	brge	8000b4d8 <_vfprintf_r+0x14a0>
8000b408:	fa cc f9 44 	sub	r12,sp,-1724
8000b40c:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b410:	c8 28       	rjmp	8000b514 <_vfprintf_r+0x14dc>
8000b412:	ee ca ff ff 	sub	r10,r7,-1
8000b416:	10 37       	cp.w	r7,r8
8000b418:	e0 84 00 81 	brge	8000b51a <_vfprintf_r+0x14e2>
8000b41c:	fa cb f9 44 	sub	r11,sp,-1724
8000b420:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b424:	c7 78       	rjmp	8000b512 <_vfprintf_r+0x14da>
8000b426:	ed b5 00 06 	bld	r5,0x6
8000b42a:	c4 b1       	brne	8000b4c0 <_vfprintf_r+0x1488>
8000b42c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b430:	40 3c       	lddsp	r12,sp[0xc]
8000b432:	58 0c       	cp.w	r12,0
8000b434:	c1 d0       	breq	8000b46e <_vfprintf_r+0x1436>
8000b436:	10 36       	cp.w	r6,r8
8000b438:	c0 64       	brge	8000b444 <_vfprintf_r+0x140c>
8000b43a:	fa cb f9 44 	sub	r11,sp,-1724
8000b43e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b442:	c1 f8       	rjmp	8000b480 <_vfprintf_r+0x1448>
8000b444:	fa c8 f9 50 	sub	r8,sp,-1712
8000b448:	1a d8       	st.w	--sp,r8
8000b44a:	fa c8 fa b8 	sub	r8,sp,-1352
8000b44e:	1a d8       	st.w	--sp,r8
8000b450:	fa c8 fb b4 	sub	r8,sp,-1100
8000b454:	1a d8       	st.w	--sp,r8
8000b456:	fa c8 f9 40 	sub	r8,sp,-1728
8000b45a:	fa c9 ff b4 	sub	r9,sp,-76
8000b45e:	04 9a       	mov	r10,r2
8000b460:	0c 9b       	mov	r11,r6
8000b462:	08 9c       	mov	r12,r4
8000b464:	fe b0 f4 52 	rcall	80009d08 <get_arg>
8000b468:	2f dd       	sub	sp,-12
8000b46a:	98 18       	ld.sh	r8,r12[0x2]
8000b46c:	c2 78       	rjmp	8000b4ba <_vfprintf_r+0x1482>
8000b46e:	ee ca ff ff 	sub	r10,r7,-1
8000b472:	10 37       	cp.w	r7,r8
8000b474:	c0 a4       	brge	8000b488 <_vfprintf_r+0x1450>
8000b476:	fa c9 f9 44 	sub	r9,sp,-1724
8000b47a:	14 97       	mov	r7,r10
8000b47c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b480:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000b484:	c1 b8       	rjmp	8000b4ba <_vfprintf_r+0x1482>
8000b486:	d7 03       	nop
8000b488:	41 09       	lddsp	r9,sp[0x40]
8000b48a:	59 f8       	cp.w	r8,31
8000b48c:	e0 89 00 13 	brgt	8000b4b2 <_vfprintf_r+0x147a>
8000b490:	f2 cb ff fc 	sub	r11,r9,-4
8000b494:	51 0b       	stdsp	sp[0x40],r11
8000b496:	72 09       	ld.w	r9,r9[0x0]
8000b498:	fa c6 f9 44 	sub	r6,sp,-1724
8000b49c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000b4a0:	2f f8       	sub	r8,-1
8000b4a2:	f7 49 fd 88 	st.w	r11[-632],r9
8000b4a6:	fb 48 06 b4 	st.w	sp[1716],r8
8000b4aa:	14 97       	mov	r7,r10
8000b4ac:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000b4b0:	c0 58       	rjmp	8000b4ba <_vfprintf_r+0x1482>
8000b4b2:	92 18       	ld.sh	r8,r9[0x2]
8000b4b4:	14 97       	mov	r7,r10
8000b4b6:	2f c9       	sub	r9,-4
8000b4b8:	51 09       	stdsp	sp[0x40],r9
8000b4ba:	5c 78       	castu.h	r8
8000b4bc:	50 18       	stdsp	sp[0x4],r8
8000b4be:	c4 68       	rjmp	8000b54a <_vfprintf_r+0x1512>
8000b4c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b4c4:	40 3c       	lddsp	r12,sp[0xc]
8000b4c6:	58 0c       	cp.w	r12,0
8000b4c8:	c1 d0       	breq	8000b502 <_vfprintf_r+0x14ca>
8000b4ca:	10 36       	cp.w	r6,r8
8000b4cc:	c0 64       	brge	8000b4d8 <_vfprintf_r+0x14a0>
8000b4ce:	fa cb f9 44 	sub	r11,sp,-1724
8000b4d2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b4d6:	c1 f8       	rjmp	8000b514 <_vfprintf_r+0x14dc>
8000b4d8:	fa c8 f9 50 	sub	r8,sp,-1712
8000b4dc:	1a d8       	st.w	--sp,r8
8000b4de:	fa c8 fa b8 	sub	r8,sp,-1352
8000b4e2:	0c 9b       	mov	r11,r6
8000b4e4:	1a d8       	st.w	--sp,r8
8000b4e6:	fa c8 fb b4 	sub	r8,sp,-1100
8000b4ea:	04 9a       	mov	r10,r2
8000b4ec:	1a d8       	st.w	--sp,r8
8000b4ee:	08 9c       	mov	r12,r4
8000b4f0:	fa c8 f9 40 	sub	r8,sp,-1728
8000b4f4:	fa c9 ff b4 	sub	r9,sp,-76
8000b4f8:	fe b0 f4 08 	rcall	80009d08 <get_arg>
8000b4fc:	2f dd       	sub	sp,-12
8000b4fe:	78 0b       	ld.w	r11,r12[0x0]
8000b500:	c2 48       	rjmp	8000b548 <_vfprintf_r+0x1510>
8000b502:	ee ca ff ff 	sub	r10,r7,-1
8000b506:	10 37       	cp.w	r7,r8
8000b508:	c0 94       	brge	8000b51a <_vfprintf_r+0x14e2>
8000b50a:	fa c9 f9 44 	sub	r9,sp,-1724
8000b50e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b512:	14 97       	mov	r7,r10
8000b514:	ec fb fd 88 	ld.w	r11,r6[-632]
8000b518:	c1 88       	rjmp	8000b548 <_vfprintf_r+0x1510>
8000b51a:	41 09       	lddsp	r9,sp[0x40]
8000b51c:	59 f8       	cp.w	r8,31
8000b51e:	e0 89 00 11 	brgt	8000b540 <_vfprintf_r+0x1508>
8000b522:	f2 cb ff fc 	sub	r11,r9,-4
8000b526:	51 0b       	stdsp	sp[0x40],r11
8000b528:	fa c6 f9 44 	sub	r6,sp,-1724
8000b52c:	72 0b       	ld.w	r11,r9[0x0]
8000b52e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b532:	f3 4b fd 88 	st.w	r9[-632],r11
8000b536:	2f f8       	sub	r8,-1
8000b538:	14 97       	mov	r7,r10
8000b53a:	fb 48 06 b4 	st.w	sp[1716],r8
8000b53e:	c0 58       	rjmp	8000b548 <_vfprintf_r+0x1510>
8000b540:	72 0b       	ld.w	r11,r9[0x0]
8000b542:	14 97       	mov	r7,r10
8000b544:	2f c9       	sub	r9,-4
8000b546:	51 09       	stdsp	sp[0x40],r9
8000b548:	50 1b       	stdsp	sp[0x4],r11
8000b54a:	30 0e       	mov	lr,0
8000b54c:	50 0e       	stdsp	sp[0x0],lr
8000b54e:	40 08       	lddsp	r8,sp[0x0]
8000b550:	40 1c       	lddsp	r12,sp[0x4]
8000b552:	18 48       	or	r8,r12
8000b554:	5f 19       	srne	r9
8000b556:	0a 98       	mov	r8,r5
8000b558:	eb e9 00 09 	and	r9,r5,r9
8000b55c:	a1 b8       	sbr	r8,0x1
8000b55e:	58 09       	cp.w	r9,0
8000b560:	c0 70       	breq	8000b56e <_vfprintf_r+0x1536>
8000b562:	10 95       	mov	r5,r8
8000b564:	fb 60 06 b9 	st.b	sp[1721],r0
8000b568:	33 08       	mov	r8,48
8000b56a:	fb 68 06 b8 	st.b	sp[1720],r8
8000b56e:	30 28       	mov	r8,2
8000b570:	30 09       	mov	r9,0
8000b572:	fb 69 06 bb 	st.b	sp[1723],r9
8000b576:	0a 99       	mov	r9,r5
8000b578:	a7 d9       	cbr	r9,0x7
8000b57a:	40 2b       	lddsp	r11,sp[0x8]
8000b57c:	40 16       	lddsp	r6,sp[0x4]
8000b57e:	58 0b       	cp.w	r11,0
8000b580:	5f 1a       	srne	r10
8000b582:	f2 05 17 40 	movge	r5,r9
8000b586:	fa c2 f9 78 	sub	r2,sp,-1672
8000b58a:	40 09       	lddsp	r9,sp[0x0]
8000b58c:	0c 49       	or	r9,r6
8000b58e:	5f 19       	srne	r9
8000b590:	f5 e9 10 09 	or	r9,r10,r9
8000b594:	c5 c0       	breq	8000b64c <_vfprintf_r+0x1614>
8000b596:	30 19       	mov	r9,1
8000b598:	f2 08 18 00 	cp.b	r8,r9
8000b59c:	c0 60       	breq	8000b5a8 <_vfprintf_r+0x1570>
8000b59e:	30 29       	mov	r9,2
8000b5a0:	f2 08 18 00 	cp.b	r8,r9
8000b5a4:	c0 41       	brne	8000b5ac <_vfprintf_r+0x1574>
8000b5a6:	c3 c8       	rjmp	8000b61e <_vfprintf_r+0x15e6>
8000b5a8:	04 96       	mov	r6,r2
8000b5aa:	c3 08       	rjmp	8000b60a <_vfprintf_r+0x15d2>
8000b5ac:	04 96       	mov	r6,r2
8000b5ae:	fa e8 00 00 	ld.d	r8,sp[0]
8000b5b2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000b5b6:	2d 0a       	sub	r10,-48
8000b5b8:	0c fa       	st.b	--r6,r10
8000b5ba:	f0 0b 16 03 	lsr	r11,r8,0x3
8000b5be:	f2 0c 16 03 	lsr	r12,r9,0x3
8000b5c2:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000b5c6:	18 99       	mov	r9,r12
8000b5c8:	16 98       	mov	r8,r11
8000b5ca:	58 08       	cp.w	r8,0
8000b5cc:	5c 29       	cpc	r9
8000b5ce:	cf 21       	brne	8000b5b2 <_vfprintf_r+0x157a>
8000b5d0:	fa e9 00 00 	st.d	sp[0],r8
8000b5d4:	ed b5 00 00 	bld	r5,0x0
8000b5d8:	c4 51       	brne	8000b662 <_vfprintf_r+0x162a>
8000b5da:	33 09       	mov	r9,48
8000b5dc:	f2 0a 18 00 	cp.b	r10,r9
8000b5e0:	c4 10       	breq	8000b662 <_vfprintf_r+0x162a>
8000b5e2:	0c f9       	st.b	--r6,r9
8000b5e4:	c3 f8       	rjmp	8000b662 <_vfprintf_r+0x162a>
8000b5e6:	fa ea 00 00 	ld.d	r10,sp[0]
8000b5ea:	30 a8       	mov	r8,10
8000b5ec:	30 09       	mov	r9,0
8000b5ee:	e0 a0 1a 0d 	rcall	8000ea08 <__avr32_umod64>
8000b5f2:	30 a8       	mov	r8,10
8000b5f4:	2d 0a       	sub	r10,-48
8000b5f6:	30 09       	mov	r9,0
8000b5f8:	ac 8a       	st.b	r6[0x0],r10
8000b5fa:	fa ea 00 00 	ld.d	r10,sp[0]
8000b5fe:	e0 a0 18 d3 	rcall	8000e7a4 <__avr32_udiv64>
8000b602:	16 99       	mov	r9,r11
8000b604:	14 98       	mov	r8,r10
8000b606:	fa e9 00 00 	st.d	sp[0],r8
8000b60a:	20 16       	sub	r6,1
8000b60c:	fa ea 00 00 	ld.d	r10,sp[0]
8000b610:	58 9a       	cp.w	r10,9
8000b612:	5c 2b       	cpc	r11
8000b614:	fe 9b ff e9 	brhi	8000b5e6 <_vfprintf_r+0x15ae>
8000b618:	1b f8       	ld.ub	r8,sp[0x7]
8000b61a:	2d 08       	sub	r8,-48
8000b61c:	c2 08       	rjmp	8000b65c <_vfprintf_r+0x1624>
8000b61e:	04 96       	mov	r6,r2
8000b620:	fa e8 00 00 	ld.d	r8,sp[0]
8000b624:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000b628:	40 de       	lddsp	lr,sp[0x34]
8000b62a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000b62e:	0c fa       	st.b	--r6,r10
8000b630:	f2 0b 16 04 	lsr	r11,r9,0x4
8000b634:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b638:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000b63c:	16 99       	mov	r9,r11
8000b63e:	14 98       	mov	r8,r10
8000b640:	58 08       	cp.w	r8,0
8000b642:	5c 29       	cpc	r9
8000b644:	cf 01       	brne	8000b624 <_vfprintf_r+0x15ec>
8000b646:	fa e9 00 00 	st.d	sp[0],r8
8000b64a:	c0 c8       	rjmp	8000b662 <_vfprintf_r+0x162a>
8000b64c:	58 08       	cp.w	r8,0
8000b64e:	c0 91       	brne	8000b660 <_vfprintf_r+0x1628>
8000b650:	ed b5 00 00 	bld	r5,0x0
8000b654:	c0 61       	brne	8000b660 <_vfprintf_r+0x1628>
8000b656:	fa c6 f9 79 	sub	r6,sp,-1671
8000b65a:	33 08       	mov	r8,48
8000b65c:	ac 88       	st.b	r6[0x0],r8
8000b65e:	c0 28       	rjmp	8000b662 <_vfprintf_r+0x162a>
8000b660:	04 96       	mov	r6,r2
8000b662:	0c 12       	sub	r2,r6
8000b664:	c1 c8       	rjmp	8000b69c <_vfprintf_r+0x1664>
8000b666:	50 a7       	stdsp	sp[0x28],r7
8000b668:	50 80       	stdsp	sp[0x20],r0
8000b66a:	40 93       	lddsp	r3,sp[0x24]
8000b66c:	0c 97       	mov	r7,r6
8000b66e:	10 90       	mov	r0,r8
8000b670:	04 94       	mov	r4,r2
8000b672:	40 41       	lddsp	r1,sp[0x10]
8000b674:	58 08       	cp.w	r8,0
8000b676:	e0 80 04 4f 	breq	8000bf14 <_vfprintf_r+0x1edc>
8000b67a:	fb 68 06 60 	st.b	sp[1632],r8
8000b67e:	30 0c       	mov	r12,0
8000b680:	30 08       	mov	r8,0
8000b682:	30 12       	mov	r2,1
8000b684:	fb 68 06 bb 	st.b	sp[1723],r8
8000b688:	50 2c       	stdsp	sp[0x8],r12
8000b68a:	fa c6 f9 a0 	sub	r6,sp,-1632
8000b68e:	c0 78       	rjmp	8000b69c <_vfprintf_r+0x1664>
8000b690:	30 0b       	mov	r11,0
8000b692:	50 2b       	stdsp	sp[0x8],r11
8000b694:	c0 48       	rjmp	8000b69c <_vfprintf_r+0x1664>
8000b696:	40 22       	lddsp	r2,sp[0x8]
8000b698:	30 0a       	mov	r10,0
8000b69a:	50 2a       	stdsp	sp[0x8],r10
8000b69c:	40 29       	lddsp	r9,sp[0x8]
8000b69e:	e4 09 0c 49 	max	r9,r2,r9
8000b6a2:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000b6a6:	50 39       	stdsp	sp[0xc],r9
8000b6a8:	0a 9e       	mov	lr,r5
8000b6aa:	30 09       	mov	r9,0
8000b6ac:	e2 1e 00 02 	andl	lr,0x2,COH
8000b6b0:	f2 08 18 00 	cp.b	r8,r9
8000b6b4:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000b6b8:	f7 b8 01 ff 	subne	r8,-1
8000b6bc:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000b6c0:	0a 9b       	mov	r11,r5
8000b6c2:	58 0e       	cp.w	lr,0
8000b6c4:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000b6c8:	f7 bc 01 fe 	subne	r12,-2
8000b6cc:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000b6d0:	e2 1b 00 84 	andl	r11,0x84,COH
8000b6d4:	50 fe       	stdsp	sp[0x3c],lr
8000b6d6:	50 9b       	stdsp	sp[0x24],r11
8000b6d8:	c4 71       	brne	8000b766 <_vfprintf_r+0x172e>
8000b6da:	40 8a       	lddsp	r10,sp[0x20]
8000b6dc:	40 39       	lddsp	r9,sp[0xc]
8000b6de:	12 1a       	sub	r10,r9
8000b6e0:	50 4a       	stdsp	sp[0x10],r10
8000b6e2:	58 0a       	cp.w	r10,0
8000b6e4:	e0 89 00 20 	brgt	8000b724 <_vfprintf_r+0x16ec>
8000b6e8:	c3 f8       	rjmp	8000b766 <_vfprintf_r+0x172e>
8000b6ea:	2f 09       	sub	r9,-16
8000b6ec:	2f f8       	sub	r8,-1
8000b6ee:	fe ce c0 76 	sub	lr,pc,-16266
8000b6f2:	31 0c       	mov	r12,16
8000b6f4:	fb 49 06 90 	st.w	sp[1680],r9
8000b6f8:	87 0e       	st.w	r3[0x0],lr
8000b6fa:	87 1c       	st.w	r3[0x4],r12
8000b6fc:	fb 48 06 8c 	st.w	sp[1676],r8
8000b700:	58 78       	cp.w	r8,7
8000b702:	e0 89 00 04 	brgt	8000b70a <_vfprintf_r+0x16d2>
8000b706:	2f 83       	sub	r3,-8
8000b708:	c0 b8       	rjmp	8000b71e <_vfprintf_r+0x16e6>
8000b70a:	fa ca f9 78 	sub	r10,sp,-1672
8000b70e:	02 9b       	mov	r11,r1
8000b710:	08 9c       	mov	r12,r4
8000b712:	fe b0 f4 85 	rcall	8000a01c <__sprint_r>
8000b716:	e0 81 04 10 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000b71a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b71e:	40 4b       	lddsp	r11,sp[0x10]
8000b720:	21 0b       	sub	r11,16
8000b722:	50 4b       	stdsp	sp[0x10],r11
8000b724:	fa f9 06 90 	ld.w	r9,sp[1680]
8000b728:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b72c:	fe ca c0 b4 	sub	r10,pc,-16204
8000b730:	40 4e       	lddsp	lr,sp[0x10]
8000b732:	59 0e       	cp.w	lr,16
8000b734:	fe 99 ff db 	brgt	8000b6ea <_vfprintf_r+0x16b2>
8000b738:	1c 09       	add	r9,lr
8000b73a:	2f f8       	sub	r8,-1
8000b73c:	87 0a       	st.w	r3[0x0],r10
8000b73e:	fb 49 06 90 	st.w	sp[1680],r9
8000b742:	87 1e       	st.w	r3[0x4],lr
8000b744:	fb 48 06 8c 	st.w	sp[1676],r8
8000b748:	58 78       	cp.w	r8,7
8000b74a:	e0 89 00 04 	brgt	8000b752 <_vfprintf_r+0x171a>
8000b74e:	2f 83       	sub	r3,-8
8000b750:	c0 b8       	rjmp	8000b766 <_vfprintf_r+0x172e>
8000b752:	fa ca f9 78 	sub	r10,sp,-1672
8000b756:	02 9b       	mov	r11,r1
8000b758:	08 9c       	mov	r12,r4
8000b75a:	fe b0 f4 61 	rcall	8000a01c <__sprint_r>
8000b75e:	e0 81 03 ec 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000b762:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b766:	30 09       	mov	r9,0
8000b768:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000b76c:	f2 08 18 00 	cp.b	r8,r9
8000b770:	c1 f0       	breq	8000b7ae <_vfprintf_r+0x1776>
8000b772:	fa f8 06 90 	ld.w	r8,sp[1680]
8000b776:	fa c9 f9 45 	sub	r9,sp,-1723
8000b77a:	2f f8       	sub	r8,-1
8000b77c:	87 09       	st.w	r3[0x0],r9
8000b77e:	fb 48 06 90 	st.w	sp[1680],r8
8000b782:	30 19       	mov	r9,1
8000b784:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b788:	87 19       	st.w	r3[0x4],r9
8000b78a:	2f f8       	sub	r8,-1
8000b78c:	fb 48 06 8c 	st.w	sp[1676],r8
8000b790:	58 78       	cp.w	r8,7
8000b792:	e0 89 00 04 	brgt	8000b79a <_vfprintf_r+0x1762>
8000b796:	2f 83       	sub	r3,-8
8000b798:	c0 b8       	rjmp	8000b7ae <_vfprintf_r+0x1776>
8000b79a:	fa ca f9 78 	sub	r10,sp,-1672
8000b79e:	02 9b       	mov	r11,r1
8000b7a0:	08 9c       	mov	r12,r4
8000b7a2:	fe b0 f4 3d 	rcall	8000a01c <__sprint_r>
8000b7a6:	e0 81 03 c8 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000b7aa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b7ae:	40 fc       	lddsp	r12,sp[0x3c]
8000b7b0:	58 0c       	cp.w	r12,0
8000b7b2:	c1 f0       	breq	8000b7f0 <_vfprintf_r+0x17b8>
8000b7b4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000b7b8:	fa c9 f9 48 	sub	r9,sp,-1720
8000b7bc:	2f e8       	sub	r8,-2
8000b7be:	87 09       	st.w	r3[0x0],r9
8000b7c0:	fb 48 06 90 	st.w	sp[1680],r8
8000b7c4:	30 29       	mov	r9,2
8000b7c6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b7ca:	87 19       	st.w	r3[0x4],r9
8000b7cc:	2f f8       	sub	r8,-1
8000b7ce:	fb 48 06 8c 	st.w	sp[1676],r8
8000b7d2:	58 78       	cp.w	r8,7
8000b7d4:	e0 89 00 04 	brgt	8000b7dc <_vfprintf_r+0x17a4>
8000b7d8:	2f 83       	sub	r3,-8
8000b7da:	c0 b8       	rjmp	8000b7f0 <_vfprintf_r+0x17b8>
8000b7dc:	fa ca f9 78 	sub	r10,sp,-1672
8000b7e0:	02 9b       	mov	r11,r1
8000b7e2:	08 9c       	mov	r12,r4
8000b7e4:	fe b0 f4 1c 	rcall	8000a01c <__sprint_r>
8000b7e8:	e0 81 03 a7 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000b7ec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b7f0:	40 9b       	lddsp	r11,sp[0x24]
8000b7f2:	e0 4b 00 80 	cp.w	r11,128
8000b7f6:	c4 71       	brne	8000b884 <_vfprintf_r+0x184c>
8000b7f8:	40 8a       	lddsp	r10,sp[0x20]
8000b7fa:	40 39       	lddsp	r9,sp[0xc]
8000b7fc:	12 1a       	sub	r10,r9
8000b7fe:	50 4a       	stdsp	sp[0x10],r10
8000b800:	58 0a       	cp.w	r10,0
8000b802:	e0 89 00 20 	brgt	8000b842 <_vfprintf_r+0x180a>
8000b806:	c3 f8       	rjmp	8000b884 <_vfprintf_r+0x184c>
8000b808:	2f 09       	sub	r9,-16
8000b80a:	2f f8       	sub	r8,-1
8000b80c:	fe ce c1 84 	sub	lr,pc,-15996
8000b810:	31 0c       	mov	r12,16
8000b812:	fb 49 06 90 	st.w	sp[1680],r9
8000b816:	87 0e       	st.w	r3[0x0],lr
8000b818:	87 1c       	st.w	r3[0x4],r12
8000b81a:	fb 48 06 8c 	st.w	sp[1676],r8
8000b81e:	58 78       	cp.w	r8,7
8000b820:	e0 89 00 04 	brgt	8000b828 <_vfprintf_r+0x17f0>
8000b824:	2f 83       	sub	r3,-8
8000b826:	c0 b8       	rjmp	8000b83c <_vfprintf_r+0x1804>
8000b828:	fa ca f9 78 	sub	r10,sp,-1672
8000b82c:	02 9b       	mov	r11,r1
8000b82e:	08 9c       	mov	r12,r4
8000b830:	fe b0 f3 f6 	rcall	8000a01c <__sprint_r>
8000b834:	e0 81 03 81 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000b838:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b83c:	40 4b       	lddsp	r11,sp[0x10]
8000b83e:	21 0b       	sub	r11,16
8000b840:	50 4b       	stdsp	sp[0x10],r11
8000b842:	fa f9 06 90 	ld.w	r9,sp[1680]
8000b846:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b84a:	fe ca c1 c2 	sub	r10,pc,-15934
8000b84e:	40 4e       	lddsp	lr,sp[0x10]
8000b850:	59 0e       	cp.w	lr,16
8000b852:	fe 99 ff db 	brgt	8000b808 <_vfprintf_r+0x17d0>
8000b856:	1c 09       	add	r9,lr
8000b858:	2f f8       	sub	r8,-1
8000b85a:	87 0a       	st.w	r3[0x0],r10
8000b85c:	fb 49 06 90 	st.w	sp[1680],r9
8000b860:	87 1e       	st.w	r3[0x4],lr
8000b862:	fb 48 06 8c 	st.w	sp[1676],r8
8000b866:	58 78       	cp.w	r8,7
8000b868:	e0 89 00 04 	brgt	8000b870 <_vfprintf_r+0x1838>
8000b86c:	2f 83       	sub	r3,-8
8000b86e:	c0 b8       	rjmp	8000b884 <_vfprintf_r+0x184c>
8000b870:	fa ca f9 78 	sub	r10,sp,-1672
8000b874:	02 9b       	mov	r11,r1
8000b876:	08 9c       	mov	r12,r4
8000b878:	fe b0 f3 d2 	rcall	8000a01c <__sprint_r>
8000b87c:	e0 81 03 5d 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000b880:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b884:	40 2c       	lddsp	r12,sp[0x8]
8000b886:	04 1c       	sub	r12,r2
8000b888:	50 2c       	stdsp	sp[0x8],r12
8000b88a:	58 0c       	cp.w	r12,0
8000b88c:	e0 89 00 20 	brgt	8000b8cc <_vfprintf_r+0x1894>
8000b890:	c3 f8       	rjmp	8000b90e <_vfprintf_r+0x18d6>
8000b892:	2f 09       	sub	r9,-16
8000b894:	2f f8       	sub	r8,-1
8000b896:	fe cb c2 0e 	sub	r11,pc,-15858
8000b89a:	31 0a       	mov	r10,16
8000b89c:	fb 49 06 90 	st.w	sp[1680],r9
8000b8a0:	87 0b       	st.w	r3[0x0],r11
8000b8a2:	87 1a       	st.w	r3[0x4],r10
8000b8a4:	fb 48 06 8c 	st.w	sp[1676],r8
8000b8a8:	58 78       	cp.w	r8,7
8000b8aa:	e0 89 00 04 	brgt	8000b8b2 <_vfprintf_r+0x187a>
8000b8ae:	2f 83       	sub	r3,-8
8000b8b0:	c0 b8       	rjmp	8000b8c6 <_vfprintf_r+0x188e>
8000b8b2:	fa ca f9 78 	sub	r10,sp,-1672
8000b8b6:	02 9b       	mov	r11,r1
8000b8b8:	08 9c       	mov	r12,r4
8000b8ba:	fe b0 f3 b1 	rcall	8000a01c <__sprint_r>
8000b8be:	e0 81 03 3c 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000b8c2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b8c6:	40 29       	lddsp	r9,sp[0x8]
8000b8c8:	21 09       	sub	r9,16
8000b8ca:	50 29       	stdsp	sp[0x8],r9
8000b8cc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000b8d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b8d4:	fe ca c2 4c 	sub	r10,pc,-15796
8000b8d8:	40 2e       	lddsp	lr,sp[0x8]
8000b8da:	59 0e       	cp.w	lr,16
8000b8dc:	fe 99 ff db 	brgt	8000b892 <_vfprintf_r+0x185a>
8000b8e0:	1c 09       	add	r9,lr
8000b8e2:	2f f8       	sub	r8,-1
8000b8e4:	87 0a       	st.w	r3[0x0],r10
8000b8e6:	fb 49 06 90 	st.w	sp[1680],r9
8000b8ea:	87 1e       	st.w	r3[0x4],lr
8000b8ec:	fb 48 06 8c 	st.w	sp[1676],r8
8000b8f0:	58 78       	cp.w	r8,7
8000b8f2:	e0 89 00 04 	brgt	8000b8fa <_vfprintf_r+0x18c2>
8000b8f6:	2f 83       	sub	r3,-8
8000b8f8:	c0 b8       	rjmp	8000b90e <_vfprintf_r+0x18d6>
8000b8fa:	fa ca f9 78 	sub	r10,sp,-1672
8000b8fe:	02 9b       	mov	r11,r1
8000b900:	08 9c       	mov	r12,r4
8000b902:	fe b0 f3 8d 	rcall	8000a01c <__sprint_r>
8000b906:	e0 81 03 18 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000b90a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b90e:	ed b5 00 08 	bld	r5,0x8
8000b912:	c0 b0       	breq	8000b928 <_vfprintf_r+0x18f0>
8000b914:	fa f8 06 90 	ld.w	r8,sp[1680]
8000b918:	87 12       	st.w	r3[0x4],r2
8000b91a:	87 06       	st.w	r3[0x0],r6
8000b91c:	f0 02 00 02 	add	r2,r8,r2
8000b920:	fb 42 06 90 	st.w	sp[1680],r2
8000b924:	e0 8f 01 d4 	bral	8000bccc <_vfprintf_r+0x1c94>
8000b928:	e0 40 00 65 	cp.w	r0,101
8000b92c:	e0 8a 01 d6 	brle	8000bcd8 <_vfprintf_r+0x1ca0>
8000b930:	30 08       	mov	r8,0
8000b932:	30 09       	mov	r9,0
8000b934:	40 5b       	lddsp	r11,sp[0x14]
8000b936:	40 7a       	lddsp	r10,sp[0x1c]
8000b938:	e0 a0 15 2f 	rcall	8000e396 <__avr32_f64_cmp_eq>
8000b93c:	c7 90       	breq	8000ba2e <_vfprintf_r+0x19f6>
8000b93e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000b942:	fe c9 c2 ce 	sub	r9,pc,-15666
8000b946:	2f f8       	sub	r8,-1
8000b948:	87 09       	st.w	r3[0x0],r9
8000b94a:	fb 48 06 90 	st.w	sp[1680],r8
8000b94e:	30 19       	mov	r9,1
8000b950:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b954:	87 19       	st.w	r3[0x4],r9
8000b956:	2f f8       	sub	r8,-1
8000b958:	fb 48 06 8c 	st.w	sp[1676],r8
8000b95c:	58 78       	cp.w	r8,7
8000b95e:	e0 89 00 05 	brgt	8000b968 <_vfprintf_r+0x1930>
8000b962:	2f 83       	sub	r3,-8
8000b964:	c0 c8       	rjmp	8000b97c <_vfprintf_r+0x1944>
8000b966:	d7 03       	nop
8000b968:	fa ca f9 78 	sub	r10,sp,-1672
8000b96c:	02 9b       	mov	r11,r1
8000b96e:	08 9c       	mov	r12,r4
8000b970:	fe b0 f3 56 	rcall	8000a01c <__sprint_r>
8000b974:	e0 81 02 e1 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000b978:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b97c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000b980:	40 6c       	lddsp	r12,sp[0x18]
8000b982:	18 38       	cp.w	r8,r12
8000b984:	c0 55       	brlt	8000b98e <_vfprintf_r+0x1956>
8000b986:	ed b5 00 00 	bld	r5,0x0
8000b98a:	e0 81 02 6b 	brne	8000be60 <_vfprintf_r+0x1e28>
8000b98e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000b992:	2f f8       	sub	r8,-1
8000b994:	40 cb       	lddsp	r11,sp[0x30]
8000b996:	fb 48 06 90 	st.w	sp[1680],r8
8000b99a:	30 19       	mov	r9,1
8000b99c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b9a0:	87 0b       	st.w	r3[0x0],r11
8000b9a2:	2f f8       	sub	r8,-1
8000b9a4:	87 19       	st.w	r3[0x4],r9
8000b9a6:	fb 48 06 8c 	st.w	sp[1676],r8
8000b9aa:	58 78       	cp.w	r8,7
8000b9ac:	e0 89 00 04 	brgt	8000b9b4 <_vfprintf_r+0x197c>
8000b9b0:	2f 83       	sub	r3,-8
8000b9b2:	c0 b8       	rjmp	8000b9c8 <_vfprintf_r+0x1990>
8000b9b4:	fa ca f9 78 	sub	r10,sp,-1672
8000b9b8:	02 9b       	mov	r11,r1
8000b9ba:	08 9c       	mov	r12,r4
8000b9bc:	fe b0 f3 30 	rcall	8000a01c <__sprint_r>
8000b9c0:	e0 81 02 bb 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000b9c4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b9c8:	40 66       	lddsp	r6,sp[0x18]
8000b9ca:	20 16       	sub	r6,1
8000b9cc:	58 06       	cp.w	r6,0
8000b9ce:	e0 89 00 1d 	brgt	8000ba08 <_vfprintf_r+0x19d0>
8000b9d2:	e0 8f 02 47 	bral	8000be60 <_vfprintf_r+0x1e28>
8000b9d6:	2f 09       	sub	r9,-16
8000b9d8:	2f f8       	sub	r8,-1
8000b9da:	fb 49 06 90 	st.w	sp[1680],r9
8000b9de:	87 02       	st.w	r3[0x0],r2
8000b9e0:	87 10       	st.w	r3[0x4],r0
8000b9e2:	fb 48 06 8c 	st.w	sp[1676],r8
8000b9e6:	58 78       	cp.w	r8,7
8000b9e8:	e0 89 00 04 	brgt	8000b9f0 <_vfprintf_r+0x19b8>
8000b9ec:	2f 83       	sub	r3,-8
8000b9ee:	c0 b8       	rjmp	8000ba04 <_vfprintf_r+0x19cc>
8000b9f0:	fa ca f9 78 	sub	r10,sp,-1672
8000b9f4:	02 9b       	mov	r11,r1
8000b9f6:	08 9c       	mov	r12,r4
8000b9f8:	fe b0 f3 12 	rcall	8000a01c <__sprint_r>
8000b9fc:	e0 81 02 9d 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000ba00:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ba04:	21 06       	sub	r6,16
8000ba06:	c0 48       	rjmp	8000ba0e <_vfprintf_r+0x19d6>
8000ba08:	fe c2 c3 80 	sub	r2,pc,-15488
8000ba0c:	31 00       	mov	r0,16
8000ba0e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ba12:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ba16:	fe ca c3 8e 	sub	r10,pc,-15474
8000ba1a:	59 06       	cp.w	r6,16
8000ba1c:	fe 99 ff dd 	brgt	8000b9d6 <_vfprintf_r+0x199e>
8000ba20:	0c 09       	add	r9,r6
8000ba22:	87 0a       	st.w	r3[0x0],r10
8000ba24:	fb 49 06 90 	st.w	sp[1680],r9
8000ba28:	2f f8       	sub	r8,-1
8000ba2a:	87 16       	st.w	r3[0x4],r6
8000ba2c:	c5 39       	rjmp	8000bcd2 <_vfprintf_r+0x1c9a>
8000ba2e:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000ba32:	58 0a       	cp.w	r10,0
8000ba34:	e0 89 00 92 	brgt	8000bb58 <_vfprintf_r+0x1b20>
8000ba38:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ba3c:	fe c9 c3 c8 	sub	r9,pc,-15416
8000ba40:	2f f8       	sub	r8,-1
8000ba42:	87 09       	st.w	r3[0x0],r9
8000ba44:	fb 48 06 90 	st.w	sp[1680],r8
8000ba48:	30 19       	mov	r9,1
8000ba4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ba4e:	87 19       	st.w	r3[0x4],r9
8000ba50:	2f f8       	sub	r8,-1
8000ba52:	fb 48 06 8c 	st.w	sp[1676],r8
8000ba56:	58 78       	cp.w	r8,7
8000ba58:	e0 89 00 04 	brgt	8000ba60 <_vfprintf_r+0x1a28>
8000ba5c:	2f 83       	sub	r3,-8
8000ba5e:	c0 b8       	rjmp	8000ba74 <_vfprintf_r+0x1a3c>
8000ba60:	fa ca f9 78 	sub	r10,sp,-1672
8000ba64:	02 9b       	mov	r11,r1
8000ba66:	08 9c       	mov	r12,r4
8000ba68:	fe b0 f2 da 	rcall	8000a01c <__sprint_r>
8000ba6c:	e0 81 02 65 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000ba70:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ba74:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ba78:	58 08       	cp.w	r8,0
8000ba7a:	c0 81       	brne	8000ba8a <_vfprintf_r+0x1a52>
8000ba7c:	40 6a       	lddsp	r10,sp[0x18]
8000ba7e:	58 0a       	cp.w	r10,0
8000ba80:	c0 51       	brne	8000ba8a <_vfprintf_r+0x1a52>
8000ba82:	ed b5 00 00 	bld	r5,0x0
8000ba86:	e0 81 01 ed 	brne	8000be60 <_vfprintf_r+0x1e28>
8000ba8a:	40 c9       	lddsp	r9,sp[0x30]
8000ba8c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ba90:	2f f8       	sub	r8,-1
8000ba92:	87 09       	st.w	r3[0x0],r9
8000ba94:	fb 48 06 90 	st.w	sp[1680],r8
8000ba98:	30 19       	mov	r9,1
8000ba9a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ba9e:	87 19       	st.w	r3[0x4],r9
8000baa0:	2f f8       	sub	r8,-1
8000baa2:	fb 48 06 8c 	st.w	sp[1676],r8
8000baa6:	58 78       	cp.w	r8,7
8000baa8:	e0 89 00 04 	brgt	8000bab0 <_vfprintf_r+0x1a78>
8000baac:	2f 83       	sub	r3,-8
8000baae:	c0 b8       	rjmp	8000bac4 <_vfprintf_r+0x1a8c>
8000bab0:	fa ca f9 78 	sub	r10,sp,-1672
8000bab4:	02 9b       	mov	r11,r1
8000bab6:	08 9c       	mov	r12,r4
8000bab8:	fe b0 f2 b2 	rcall	8000a01c <__sprint_r>
8000babc:	e0 81 02 3d 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bac0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bac4:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000bac8:	5c 32       	neg	r2
8000baca:	58 02       	cp.w	r2,0
8000bacc:	e0 89 00 1d 	brgt	8000bb06 <_vfprintf_r+0x1ace>
8000bad0:	c3 d8       	rjmp	8000bb4a <_vfprintf_r+0x1b12>
8000bad2:	2f 09       	sub	r9,-16
8000bad4:	2f f8       	sub	r8,-1
8000bad6:	31 0e       	mov	lr,16
8000bad8:	fb 49 06 90 	st.w	sp[1680],r9
8000badc:	87 00       	st.w	r3[0x0],r0
8000bade:	87 1e       	st.w	r3[0x4],lr
8000bae0:	fb 48 06 8c 	st.w	sp[1676],r8
8000bae4:	58 78       	cp.w	r8,7
8000bae6:	e0 89 00 04 	brgt	8000baee <_vfprintf_r+0x1ab6>
8000baea:	2f 83       	sub	r3,-8
8000baec:	c0 b8       	rjmp	8000bb02 <_vfprintf_r+0x1aca>
8000baee:	fa ca f9 78 	sub	r10,sp,-1672
8000baf2:	02 9b       	mov	r11,r1
8000baf4:	08 9c       	mov	r12,r4
8000baf6:	fe b0 f2 93 	rcall	8000a01c <__sprint_r>
8000bafa:	e0 81 02 1e 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bafe:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bb02:	21 02       	sub	r2,16
8000bb04:	c0 38       	rjmp	8000bb0a <_vfprintf_r+0x1ad2>
8000bb06:	fe c0 c4 7e 	sub	r0,pc,-15234
8000bb0a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000bb0e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bb12:	fe ca c4 8a 	sub	r10,pc,-15222
8000bb16:	59 02       	cp.w	r2,16
8000bb18:	fe 99 ff dd 	brgt	8000bad2 <_vfprintf_r+0x1a9a>
8000bb1c:	04 09       	add	r9,r2
8000bb1e:	2f f8       	sub	r8,-1
8000bb20:	87 0a       	st.w	r3[0x0],r10
8000bb22:	fb 49 06 90 	st.w	sp[1680],r9
8000bb26:	87 12       	st.w	r3[0x4],r2
8000bb28:	fb 48 06 8c 	st.w	sp[1676],r8
8000bb2c:	58 78       	cp.w	r8,7
8000bb2e:	e0 89 00 04 	brgt	8000bb36 <_vfprintf_r+0x1afe>
8000bb32:	2f 83       	sub	r3,-8
8000bb34:	c0 b8       	rjmp	8000bb4a <_vfprintf_r+0x1b12>
8000bb36:	fa ca f9 78 	sub	r10,sp,-1672
8000bb3a:	02 9b       	mov	r11,r1
8000bb3c:	08 9c       	mov	r12,r4
8000bb3e:	fe b0 f2 6f 	rcall	8000a01c <__sprint_r>
8000bb42:	e0 81 01 fa 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bb46:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bb4a:	40 6c       	lddsp	r12,sp[0x18]
8000bb4c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000bb50:	87 06       	st.w	r3[0x0],r6
8000bb52:	87 1c       	st.w	r3[0x4],r12
8000bb54:	18 08       	add	r8,r12
8000bb56:	cb 98       	rjmp	8000bcc8 <_vfprintf_r+0x1c90>
8000bb58:	fa f9 06 90 	ld.w	r9,sp[1680]
8000bb5c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bb60:	40 6b       	lddsp	r11,sp[0x18]
8000bb62:	16 3a       	cp.w	r10,r11
8000bb64:	c6 f5       	brlt	8000bc42 <_vfprintf_r+0x1c0a>
8000bb66:	16 09       	add	r9,r11
8000bb68:	2f f8       	sub	r8,-1
8000bb6a:	87 06       	st.w	r3[0x0],r6
8000bb6c:	fb 49 06 90 	st.w	sp[1680],r9
8000bb70:	87 1b       	st.w	r3[0x4],r11
8000bb72:	fb 48 06 8c 	st.w	sp[1676],r8
8000bb76:	58 78       	cp.w	r8,7
8000bb78:	e0 89 00 04 	brgt	8000bb80 <_vfprintf_r+0x1b48>
8000bb7c:	2f 83       	sub	r3,-8
8000bb7e:	c0 b8       	rjmp	8000bb94 <_vfprintf_r+0x1b5c>
8000bb80:	fa ca f9 78 	sub	r10,sp,-1672
8000bb84:	02 9b       	mov	r11,r1
8000bb86:	08 9c       	mov	r12,r4
8000bb88:	fe b0 f2 4a 	rcall	8000a01c <__sprint_r>
8000bb8c:	e0 81 01 d5 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bb90:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bb94:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000bb98:	40 6a       	lddsp	r10,sp[0x18]
8000bb9a:	14 16       	sub	r6,r10
8000bb9c:	58 06       	cp.w	r6,0
8000bb9e:	e0 89 00 1c 	brgt	8000bbd6 <_vfprintf_r+0x1b9e>
8000bba2:	c3 d8       	rjmp	8000bc1c <_vfprintf_r+0x1be4>
8000bba4:	2f 09       	sub	r9,-16
8000bba6:	2f f8       	sub	r8,-1
8000bba8:	fb 49 06 90 	st.w	sp[1680],r9
8000bbac:	87 02       	st.w	r3[0x0],r2
8000bbae:	87 10       	st.w	r3[0x4],r0
8000bbb0:	fb 48 06 8c 	st.w	sp[1676],r8
8000bbb4:	58 78       	cp.w	r8,7
8000bbb6:	e0 89 00 04 	brgt	8000bbbe <_vfprintf_r+0x1b86>
8000bbba:	2f 83       	sub	r3,-8
8000bbbc:	c0 b8       	rjmp	8000bbd2 <_vfprintf_r+0x1b9a>
8000bbbe:	fa ca f9 78 	sub	r10,sp,-1672
8000bbc2:	02 9b       	mov	r11,r1
8000bbc4:	08 9c       	mov	r12,r4
8000bbc6:	fe b0 f2 2b 	rcall	8000a01c <__sprint_r>
8000bbca:	e0 81 01 b6 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bbce:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bbd2:	21 06       	sub	r6,16
8000bbd4:	c0 48       	rjmp	8000bbdc <_vfprintf_r+0x1ba4>
8000bbd6:	fe c2 c5 4e 	sub	r2,pc,-15026
8000bbda:	31 00       	mov	r0,16
8000bbdc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000bbe0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bbe4:	fe ca c5 5c 	sub	r10,pc,-15012
8000bbe8:	59 06       	cp.w	r6,16
8000bbea:	fe 99 ff dd 	brgt	8000bba4 <_vfprintf_r+0x1b6c>
8000bbee:	0c 09       	add	r9,r6
8000bbf0:	2f f8       	sub	r8,-1
8000bbf2:	87 0a       	st.w	r3[0x0],r10
8000bbf4:	fb 49 06 90 	st.w	sp[1680],r9
8000bbf8:	87 16       	st.w	r3[0x4],r6
8000bbfa:	fb 48 06 8c 	st.w	sp[1676],r8
8000bbfe:	58 78       	cp.w	r8,7
8000bc00:	e0 89 00 04 	brgt	8000bc08 <_vfprintf_r+0x1bd0>
8000bc04:	2f 83       	sub	r3,-8
8000bc06:	c0 b8       	rjmp	8000bc1c <_vfprintf_r+0x1be4>
8000bc08:	fa ca f9 78 	sub	r10,sp,-1672
8000bc0c:	02 9b       	mov	r11,r1
8000bc0e:	08 9c       	mov	r12,r4
8000bc10:	fe b0 f2 06 	rcall	8000a01c <__sprint_r>
8000bc14:	e0 81 01 91 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bc18:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bc1c:	ed b5 00 00 	bld	r5,0x0
8000bc20:	e0 81 01 20 	brne	8000be60 <_vfprintf_r+0x1e28>
8000bc24:	40 c9       	lddsp	r9,sp[0x30]
8000bc26:	fa f8 06 90 	ld.w	r8,sp[1680]
8000bc2a:	2f f8       	sub	r8,-1
8000bc2c:	87 09       	st.w	r3[0x0],r9
8000bc2e:	fb 48 06 90 	st.w	sp[1680],r8
8000bc32:	30 19       	mov	r9,1
8000bc34:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bc38:	87 19       	st.w	r3[0x4],r9
8000bc3a:	2f f8       	sub	r8,-1
8000bc3c:	fb 48 06 8c 	st.w	sp[1676],r8
8000bc40:	c0 29       	rjmp	8000be44 <_vfprintf_r+0x1e0c>
8000bc42:	14 09       	add	r9,r10
8000bc44:	2f f8       	sub	r8,-1
8000bc46:	fb 49 06 90 	st.w	sp[1680],r9
8000bc4a:	87 06       	st.w	r3[0x0],r6
8000bc4c:	87 1a       	st.w	r3[0x4],r10
8000bc4e:	fb 48 06 8c 	st.w	sp[1676],r8
8000bc52:	58 78       	cp.w	r8,7
8000bc54:	e0 89 00 04 	brgt	8000bc5c <_vfprintf_r+0x1c24>
8000bc58:	2f 83       	sub	r3,-8
8000bc5a:	c0 b8       	rjmp	8000bc70 <_vfprintf_r+0x1c38>
8000bc5c:	fa ca f9 78 	sub	r10,sp,-1672
8000bc60:	02 9b       	mov	r11,r1
8000bc62:	08 9c       	mov	r12,r4
8000bc64:	fe b0 f1 dc 	rcall	8000a01c <__sprint_r>
8000bc68:	e0 81 01 67 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bc6c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bc70:	40 c8       	lddsp	r8,sp[0x30]
8000bc72:	87 08       	st.w	r3[0x0],r8
8000bc74:	fa f8 06 90 	ld.w	r8,sp[1680]
8000bc78:	2f f8       	sub	r8,-1
8000bc7a:	30 19       	mov	r9,1
8000bc7c:	fb 48 06 90 	st.w	sp[1680],r8
8000bc80:	87 19       	st.w	r3[0x4],r9
8000bc82:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bc86:	2f f8       	sub	r8,-1
8000bc88:	fb 48 06 8c 	st.w	sp[1676],r8
8000bc8c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000bc90:	58 78       	cp.w	r8,7
8000bc92:	e0 89 00 04 	brgt	8000bc9a <_vfprintf_r+0x1c62>
8000bc96:	2f 83       	sub	r3,-8
8000bc98:	c0 b8       	rjmp	8000bcae <_vfprintf_r+0x1c76>
8000bc9a:	fa ca f9 78 	sub	r10,sp,-1672
8000bc9e:	02 9b       	mov	r11,r1
8000bca0:	08 9c       	mov	r12,r4
8000bca2:	fe b0 f1 bd 	rcall	8000a01c <__sprint_r>
8000bca6:	e0 81 01 48 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bcaa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bcae:	04 06       	add	r6,r2
8000bcb0:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000bcb4:	87 06       	st.w	r3[0x0],r6
8000bcb6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000bcba:	40 66       	lddsp	r6,sp[0x18]
8000bcbc:	40 6e       	lddsp	lr,sp[0x18]
8000bcbe:	10 16       	sub	r6,r8
8000bcc0:	f2 08 01 08 	sub	r8,r9,r8
8000bcc4:	87 16       	st.w	r3[0x4],r6
8000bcc6:	1c 08       	add	r8,lr
8000bcc8:	fb 48 06 90 	st.w	sp[1680],r8
8000bccc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bcd0:	2f f8       	sub	r8,-1
8000bcd2:	fb 48 06 8c 	st.w	sp[1676],r8
8000bcd6:	cb 78       	rjmp	8000be44 <_vfprintf_r+0x1e0c>
8000bcd8:	40 6c       	lddsp	r12,sp[0x18]
8000bcda:	58 1c       	cp.w	r12,1
8000bcdc:	e0 89 00 06 	brgt	8000bce8 <_vfprintf_r+0x1cb0>
8000bce0:	ed b5 00 00 	bld	r5,0x0
8000bce4:	e0 81 00 85 	brne	8000bdee <_vfprintf_r+0x1db6>
8000bce8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000bcec:	2f f8       	sub	r8,-1
8000bcee:	30 19       	mov	r9,1
8000bcf0:	fb 48 06 90 	st.w	sp[1680],r8
8000bcf4:	87 06       	st.w	r3[0x0],r6
8000bcf6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bcfa:	87 19       	st.w	r3[0x4],r9
8000bcfc:	2f f8       	sub	r8,-1
8000bcfe:	fb 48 06 8c 	st.w	sp[1676],r8
8000bd02:	58 78       	cp.w	r8,7
8000bd04:	e0 89 00 04 	brgt	8000bd0c <_vfprintf_r+0x1cd4>
8000bd08:	2f 83       	sub	r3,-8
8000bd0a:	c0 b8       	rjmp	8000bd20 <_vfprintf_r+0x1ce8>
8000bd0c:	fa ca f9 78 	sub	r10,sp,-1672
8000bd10:	02 9b       	mov	r11,r1
8000bd12:	08 9c       	mov	r12,r4
8000bd14:	fe b0 f1 84 	rcall	8000a01c <__sprint_r>
8000bd18:	e0 81 01 0f 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bd1c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bd20:	fa f8 06 90 	ld.w	r8,sp[1680]
8000bd24:	2f f8       	sub	r8,-1
8000bd26:	40 cb       	lddsp	r11,sp[0x30]
8000bd28:	fb 48 06 90 	st.w	sp[1680],r8
8000bd2c:	30 19       	mov	r9,1
8000bd2e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bd32:	87 0b       	st.w	r3[0x0],r11
8000bd34:	2f f8       	sub	r8,-1
8000bd36:	87 19       	st.w	r3[0x4],r9
8000bd38:	fb 48 06 8c 	st.w	sp[1676],r8
8000bd3c:	58 78       	cp.w	r8,7
8000bd3e:	e0 89 00 05 	brgt	8000bd48 <_vfprintf_r+0x1d10>
8000bd42:	2f 83       	sub	r3,-8
8000bd44:	c0 c8       	rjmp	8000bd5c <_vfprintf_r+0x1d24>
8000bd46:	d7 03       	nop
8000bd48:	fa ca f9 78 	sub	r10,sp,-1672
8000bd4c:	02 9b       	mov	r11,r1
8000bd4e:	08 9c       	mov	r12,r4
8000bd50:	fe b0 f1 66 	rcall	8000a01c <__sprint_r>
8000bd54:	e0 81 00 f1 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bd58:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bd5c:	30 08       	mov	r8,0
8000bd5e:	30 09       	mov	r9,0
8000bd60:	40 5b       	lddsp	r11,sp[0x14]
8000bd62:	40 7a       	lddsp	r10,sp[0x1c]
8000bd64:	e0 a0 13 19 	rcall	8000e396 <__avr32_f64_cmp_eq>
8000bd68:	40 68       	lddsp	r8,sp[0x18]
8000bd6a:	20 18       	sub	r8,1
8000bd6c:	58 0c       	cp.w	r12,0
8000bd6e:	c0 d1       	brne	8000bd88 <_vfprintf_r+0x1d50>
8000bd70:	2f f6       	sub	r6,-1
8000bd72:	87 18       	st.w	r3[0x4],r8
8000bd74:	87 06       	st.w	r3[0x0],r6
8000bd76:	fa f6 06 90 	ld.w	r6,sp[1680]
8000bd7a:	10 06       	add	r6,r8
8000bd7c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bd80:	fb 46 06 90 	st.w	sp[1680],r6
8000bd84:	2f f8       	sub	r8,-1
8000bd86:	c3 18       	rjmp	8000bde8 <_vfprintf_r+0x1db0>
8000bd88:	10 96       	mov	r6,r8
8000bd8a:	58 08       	cp.w	r8,0
8000bd8c:	e0 89 00 1c 	brgt	8000bdc4 <_vfprintf_r+0x1d8c>
8000bd90:	c4 b8       	rjmp	8000be26 <_vfprintf_r+0x1dee>
8000bd92:	2f 09       	sub	r9,-16
8000bd94:	2f f8       	sub	r8,-1
8000bd96:	fb 49 06 90 	st.w	sp[1680],r9
8000bd9a:	87 02       	st.w	r3[0x0],r2
8000bd9c:	87 10       	st.w	r3[0x4],r0
8000bd9e:	fb 48 06 8c 	st.w	sp[1676],r8
8000bda2:	58 78       	cp.w	r8,7
8000bda4:	e0 89 00 04 	brgt	8000bdac <_vfprintf_r+0x1d74>
8000bda8:	2f 83       	sub	r3,-8
8000bdaa:	c0 b8       	rjmp	8000bdc0 <_vfprintf_r+0x1d88>
8000bdac:	fa ca f9 78 	sub	r10,sp,-1672
8000bdb0:	02 9b       	mov	r11,r1
8000bdb2:	08 9c       	mov	r12,r4
8000bdb4:	fe b0 f1 34 	rcall	8000a01c <__sprint_r>
8000bdb8:	e0 81 00 bf 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bdbc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bdc0:	21 06       	sub	r6,16
8000bdc2:	c0 48       	rjmp	8000bdca <_vfprintf_r+0x1d92>
8000bdc4:	fe c2 c7 3c 	sub	r2,pc,-14532
8000bdc8:	31 00       	mov	r0,16
8000bdca:	fa f9 06 90 	ld.w	r9,sp[1680]
8000bdce:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000bdd2:	fe ca c7 4a 	sub	r10,pc,-14518
8000bdd6:	59 06       	cp.w	r6,16
8000bdd8:	fe 99 ff dd 	brgt	8000bd92 <_vfprintf_r+0x1d5a>
8000bddc:	0c 09       	add	r9,r6
8000bdde:	87 0a       	st.w	r3[0x0],r10
8000bde0:	fb 49 06 90 	st.w	sp[1680],r9
8000bde4:	2f f8       	sub	r8,-1
8000bde6:	87 16       	st.w	r3[0x4],r6
8000bde8:	fb 48 06 8c 	st.w	sp[1676],r8
8000bdec:	c0 e8       	rjmp	8000be08 <_vfprintf_r+0x1dd0>
8000bdee:	fa f8 06 90 	ld.w	r8,sp[1680]
8000bdf2:	2f f8       	sub	r8,-1
8000bdf4:	30 19       	mov	r9,1
8000bdf6:	fb 48 06 90 	st.w	sp[1680],r8
8000bdfa:	87 06       	st.w	r3[0x0],r6
8000bdfc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000be00:	87 19       	st.w	r3[0x4],r9
8000be02:	2f f8       	sub	r8,-1
8000be04:	fb 48 06 8c 	st.w	sp[1676],r8
8000be08:	58 78       	cp.w	r8,7
8000be0a:	e0 89 00 04 	brgt	8000be12 <_vfprintf_r+0x1dda>
8000be0e:	2f 83       	sub	r3,-8
8000be10:	c0 b8       	rjmp	8000be26 <_vfprintf_r+0x1dee>
8000be12:	fa ca f9 78 	sub	r10,sp,-1672
8000be16:	02 9b       	mov	r11,r1
8000be18:	08 9c       	mov	r12,r4
8000be1a:	fe b0 f1 01 	rcall	8000a01c <__sprint_r>
8000be1e:	e0 81 00 8c 	brne	8000bf36 <_vfprintf_r+0x1efe>
8000be22:	fa c3 f9 e0 	sub	r3,sp,-1568
8000be26:	40 ea       	lddsp	r10,sp[0x38]
8000be28:	fa f8 06 90 	ld.w	r8,sp[1680]
8000be2c:	14 08       	add	r8,r10
8000be2e:	fa c9 f9 64 	sub	r9,sp,-1692
8000be32:	fb 48 06 90 	st.w	sp[1680],r8
8000be36:	87 1a       	st.w	r3[0x4],r10
8000be38:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000be3c:	87 09       	st.w	r3[0x0],r9
8000be3e:	2f f8       	sub	r8,-1
8000be40:	fb 48 06 8c 	st.w	sp[1676],r8
8000be44:	58 78       	cp.w	r8,7
8000be46:	e0 89 00 04 	brgt	8000be4e <_vfprintf_r+0x1e16>
8000be4a:	2f 83       	sub	r3,-8
8000be4c:	c0 a8       	rjmp	8000be60 <_vfprintf_r+0x1e28>
8000be4e:	fa ca f9 78 	sub	r10,sp,-1672
8000be52:	02 9b       	mov	r11,r1
8000be54:	08 9c       	mov	r12,r4
8000be56:	fe b0 f0 e3 	rcall	8000a01c <__sprint_r>
8000be5a:	c6 e1       	brne	8000bf36 <_vfprintf_r+0x1efe>
8000be5c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000be60:	e2 15 00 04 	andl	r5,0x4,COH
8000be64:	c3 f0       	breq	8000bee2 <_vfprintf_r+0x1eaa>
8000be66:	40 86       	lddsp	r6,sp[0x20]
8000be68:	40 39       	lddsp	r9,sp[0xc]
8000be6a:	12 16       	sub	r6,r9
8000be6c:	58 06       	cp.w	r6,0
8000be6e:	e0 89 00 1a 	brgt	8000bea2 <_vfprintf_r+0x1e6a>
8000be72:	c3 88       	rjmp	8000bee2 <_vfprintf_r+0x1eaa>
8000be74:	2f 09       	sub	r9,-16
8000be76:	2f f8       	sub	r8,-1
8000be78:	fb 49 06 90 	st.w	sp[1680],r9
8000be7c:	87 05       	st.w	r3[0x0],r5
8000be7e:	87 12       	st.w	r3[0x4],r2
8000be80:	fb 48 06 8c 	st.w	sp[1676],r8
8000be84:	58 78       	cp.w	r8,7
8000be86:	e0 89 00 04 	brgt	8000be8e <_vfprintf_r+0x1e56>
8000be8a:	2f 83       	sub	r3,-8
8000be8c:	c0 98       	rjmp	8000be9e <_vfprintf_r+0x1e66>
8000be8e:	00 9a       	mov	r10,r0
8000be90:	02 9b       	mov	r11,r1
8000be92:	08 9c       	mov	r12,r4
8000be94:	fe b0 f0 c4 	rcall	8000a01c <__sprint_r>
8000be98:	c4 f1       	brne	8000bf36 <_vfprintf_r+0x1efe>
8000be9a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000be9e:	21 06       	sub	r6,16
8000bea0:	c0 68       	rjmp	8000beac <_vfprintf_r+0x1e74>
8000bea2:	fe c5 c8 2a 	sub	r5,pc,-14294
8000bea6:	31 02       	mov	r2,16
8000bea8:	fa c0 f9 78 	sub	r0,sp,-1672
8000beac:	fa f9 06 90 	ld.w	r9,sp[1680]
8000beb0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000beb4:	fe ca c8 3c 	sub	r10,pc,-14276
8000beb8:	59 06       	cp.w	r6,16
8000beba:	fe 99 ff dd 	brgt	8000be74 <_vfprintf_r+0x1e3c>
8000bebe:	0c 09       	add	r9,r6
8000bec0:	2f f8       	sub	r8,-1
8000bec2:	87 0a       	st.w	r3[0x0],r10
8000bec4:	87 16       	st.w	r3[0x4],r6
8000bec6:	fb 49 06 90 	st.w	sp[1680],r9
8000beca:	fb 48 06 8c 	st.w	sp[1676],r8
8000bece:	58 78       	cp.w	r8,7
8000bed0:	e0 8a 00 09 	brle	8000bee2 <_vfprintf_r+0x1eaa>
8000bed4:	fa ca f9 78 	sub	r10,sp,-1672
8000bed8:	02 9b       	mov	r11,r1
8000beda:	08 9c       	mov	r12,r4
8000bedc:	fe b0 f0 a0 	rcall	8000a01c <__sprint_r>
8000bee0:	c2 b1       	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bee2:	40 bc       	lddsp	r12,sp[0x2c]
8000bee4:	40 36       	lddsp	r6,sp[0xc]
8000bee6:	40 8e       	lddsp	lr,sp[0x20]
8000bee8:	ec 0e 0c 48 	max	r8,r6,lr
8000beec:	10 0c       	add	r12,r8
8000beee:	50 bc       	stdsp	sp[0x2c],r12
8000bef0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000bef4:	58 08       	cp.w	r8,0
8000bef6:	c0 80       	breq	8000bf06 <_vfprintf_r+0x1ece>
8000bef8:	fa ca f9 78 	sub	r10,sp,-1672
8000befc:	02 9b       	mov	r11,r1
8000befe:	08 9c       	mov	r12,r4
8000bf00:	fe b0 f0 8e 	rcall	8000a01c <__sprint_r>
8000bf04:	c1 91       	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bf06:	30 0b       	mov	r11,0
8000bf08:	fa c3 f9 e0 	sub	r3,sp,-1568
8000bf0c:	fb 4b 06 8c 	st.w	sp[1676],r11
8000bf10:	fe 9f f1 22 	bral	8000a154 <_vfprintf_r+0x11c>
8000bf14:	08 95       	mov	r5,r4
8000bf16:	fa f8 06 90 	ld.w	r8,sp[1680]
8000bf1a:	58 08       	cp.w	r8,0
8000bf1c:	c0 80       	breq	8000bf2c <_vfprintf_r+0x1ef4>
8000bf1e:	08 9c       	mov	r12,r4
8000bf20:	fa ca f9 78 	sub	r10,sp,-1672
8000bf24:	02 9b       	mov	r11,r1
8000bf26:	fe b0 f0 7b 	rcall	8000a01c <__sprint_r>
8000bf2a:	c0 61       	brne	8000bf36 <_vfprintf_r+0x1efe>
8000bf2c:	30 08       	mov	r8,0
8000bf2e:	fb 48 06 8c 	st.w	sp[1676],r8
8000bf32:	c0 28       	rjmp	8000bf36 <_vfprintf_r+0x1efe>
8000bf34:	40 41       	lddsp	r1,sp[0x10]
8000bf36:	82 68       	ld.sh	r8,r1[0xc]
8000bf38:	ed b8 00 06 	bld	r8,0x6
8000bf3c:	c0 31       	brne	8000bf42 <_vfprintf_r+0x1f0a>
8000bf3e:	3f fa       	mov	r10,-1
8000bf40:	50 ba       	stdsp	sp[0x2c],r10
8000bf42:	40 bc       	lddsp	r12,sp[0x2c]
8000bf44:	fe 3d f9 44 	sub	sp,-1724
8000bf48:	d8 32       	popm	r0-r7,pc
8000bf4a:	d7 03       	nop

8000bf4c <__swsetup_r>:
8000bf4c:	d4 21       	pushm	r4-r7,lr
8000bf4e:	e0 68 0a 30 	mov	r8,2608
8000bf52:	18 96       	mov	r6,r12
8000bf54:	16 97       	mov	r7,r11
8000bf56:	70 0c       	ld.w	r12,r8[0x0]
8000bf58:	58 0c       	cp.w	r12,0
8000bf5a:	c0 60       	breq	8000bf66 <__swsetup_r+0x1a>
8000bf5c:	78 68       	ld.w	r8,r12[0x18]
8000bf5e:	58 08       	cp.w	r8,0
8000bf60:	c0 31       	brne	8000bf66 <__swsetup_r+0x1a>
8000bf62:	e0 a0 07 bf 	rcall	8000cee0 <__sinit>
8000bf66:	fe c8 c7 be 	sub	r8,pc,-14402
8000bf6a:	10 37       	cp.w	r7,r8
8000bf6c:	c0 61       	brne	8000bf78 <__swsetup_r+0x2c>
8000bf6e:	e0 68 0a 30 	mov	r8,2608
8000bf72:	70 08       	ld.w	r8,r8[0x0]
8000bf74:	70 07       	ld.w	r7,r8[0x0]
8000bf76:	c1 28       	rjmp	8000bf9a <__swsetup_r+0x4e>
8000bf78:	fe c8 c7 b0 	sub	r8,pc,-14416
8000bf7c:	10 37       	cp.w	r7,r8
8000bf7e:	c0 61       	brne	8000bf8a <__swsetup_r+0x3e>
8000bf80:	e0 68 0a 30 	mov	r8,2608
8000bf84:	70 08       	ld.w	r8,r8[0x0]
8000bf86:	70 17       	ld.w	r7,r8[0x4]
8000bf88:	c0 98       	rjmp	8000bf9a <__swsetup_r+0x4e>
8000bf8a:	fe c8 c7 a2 	sub	r8,pc,-14430
8000bf8e:	10 37       	cp.w	r7,r8
8000bf90:	c0 51       	brne	8000bf9a <__swsetup_r+0x4e>
8000bf92:	e0 68 0a 30 	mov	r8,2608
8000bf96:	70 08       	ld.w	r8,r8[0x0]
8000bf98:	70 27       	ld.w	r7,r8[0x8]
8000bf9a:	8e 68       	ld.sh	r8,r7[0xc]
8000bf9c:	ed b8 00 03 	bld	r8,0x3
8000bfa0:	c1 e0       	breq	8000bfdc <__swsetup_r+0x90>
8000bfa2:	ed b8 00 04 	bld	r8,0x4
8000bfa6:	c3 e1       	brne	8000c022 <__swsetup_r+0xd6>
8000bfa8:	ed b8 00 02 	bld	r8,0x2
8000bfac:	c1 51       	brne	8000bfd6 <__swsetup_r+0x8a>
8000bfae:	6e db       	ld.w	r11,r7[0x34]
8000bfb0:	58 0b       	cp.w	r11,0
8000bfb2:	c0 a0       	breq	8000bfc6 <__swsetup_r+0x7a>
8000bfb4:	ee c8 ff bc 	sub	r8,r7,-68
8000bfb8:	10 3b       	cp.w	r11,r8
8000bfba:	c0 40       	breq	8000bfc2 <__swsetup_r+0x76>
8000bfbc:	0c 9c       	mov	r12,r6
8000bfbe:	e0 a0 08 2b 	rcall	8000d014 <_free_r>
8000bfc2:	30 08       	mov	r8,0
8000bfc4:	8f d8       	st.w	r7[0x34],r8
8000bfc6:	8e 68       	ld.sh	r8,r7[0xc]
8000bfc8:	e0 18 ff db 	andl	r8,0xffdb
8000bfcc:	ae 68       	st.h	r7[0xc],r8
8000bfce:	30 08       	mov	r8,0
8000bfd0:	8f 18       	st.w	r7[0x4],r8
8000bfd2:	6e 48       	ld.w	r8,r7[0x10]
8000bfd4:	8f 08       	st.w	r7[0x0],r8
8000bfd6:	8e 68       	ld.sh	r8,r7[0xc]
8000bfd8:	a3 b8       	sbr	r8,0x3
8000bfda:	ae 68       	st.h	r7[0xc],r8
8000bfdc:	6e 48       	ld.w	r8,r7[0x10]
8000bfde:	58 08       	cp.w	r8,0
8000bfe0:	c0 b1       	brne	8000bff6 <__swsetup_r+0xaa>
8000bfe2:	8e 68       	ld.sh	r8,r7[0xc]
8000bfe4:	e2 18 02 80 	andl	r8,0x280,COH
8000bfe8:	e0 48 02 00 	cp.w	r8,512
8000bfec:	c0 50       	breq	8000bff6 <__swsetup_r+0xaa>
8000bfee:	0c 9c       	mov	r12,r6
8000bff0:	0e 9b       	mov	r11,r7
8000bff2:	e0 a0 0a 4b 	rcall	8000d488 <__smakebuf_r>
8000bff6:	8e 69       	ld.sh	r9,r7[0xc]
8000bff8:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000bffc:	c0 70       	breq	8000c00a <__swsetup_r+0xbe>
8000bffe:	30 08       	mov	r8,0
8000c000:	8f 28       	st.w	r7[0x8],r8
8000c002:	6e 58       	ld.w	r8,r7[0x14]
8000c004:	5c 38       	neg	r8
8000c006:	8f 68       	st.w	r7[0x18],r8
8000c008:	c0 68       	rjmp	8000c014 <__swsetup_r+0xc8>
8000c00a:	ed b9 00 01 	bld	r9,0x1
8000c00e:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000c012:	8f 28       	st.w	r7[0x8],r8
8000c014:	6e 48       	ld.w	r8,r7[0x10]
8000c016:	58 08       	cp.w	r8,0
8000c018:	c0 61       	brne	8000c024 <__swsetup_r+0xd8>
8000c01a:	8e 68       	ld.sh	r8,r7[0xc]
8000c01c:	ed b8 00 07 	bld	r8,0x7
8000c020:	c0 21       	brne	8000c024 <__swsetup_r+0xd8>
8000c022:	dc 2a       	popm	r4-r7,pc,r12=-1
8000c024:	d8 2a       	popm	r4-r7,pc,r12=0
8000c026:	d7 03       	nop

8000c028 <quorem>:
8000c028:	d4 31       	pushm	r0-r7,lr
8000c02a:	20 2d       	sub	sp,8
8000c02c:	18 97       	mov	r7,r12
8000c02e:	78 48       	ld.w	r8,r12[0x10]
8000c030:	76 46       	ld.w	r6,r11[0x10]
8000c032:	0c 38       	cp.w	r8,r6
8000c034:	c0 34       	brge	8000c03a <quorem+0x12>
8000c036:	30 0c       	mov	r12,0
8000c038:	c8 58       	rjmp	8000c142 <quorem+0x11a>
8000c03a:	ec c2 ff fc 	sub	r2,r6,-4
8000c03e:	f6 c3 ff ec 	sub	r3,r11,-20
8000c042:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000c046:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000c04a:	2f f9       	sub	r9,-1
8000c04c:	20 16       	sub	r6,1
8000c04e:	f8 09 0d 08 	divu	r8,r12,r9
8000c052:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000c056:	ee c4 ff ec 	sub	r4,r7,-20
8000c05a:	10 95       	mov	r5,r8
8000c05c:	58 08       	cp.w	r8,0
8000c05e:	c4 10       	breq	8000c0e0 <quorem+0xb8>
8000c060:	30 09       	mov	r9,0
8000c062:	06 9a       	mov	r10,r3
8000c064:	08 98       	mov	r8,r4
8000c066:	12 91       	mov	r1,r9
8000c068:	50 0b       	stdsp	sp[0x0],r11
8000c06a:	70 0e       	ld.w	lr,r8[0x0]
8000c06c:	b1 8e       	lsr	lr,0x10
8000c06e:	50 1e       	stdsp	sp[0x4],lr
8000c070:	15 0e       	ld.w	lr,r10++
8000c072:	fc 00 16 10 	lsr	r0,lr,0x10
8000c076:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c07a:	ea 0e 03 41 	mac	r1,r5,lr
8000c07e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000c082:	b1 81       	lsr	r1,0x10
8000c084:	40 1b       	lddsp	r11,sp[0x4]
8000c086:	ea 00 02 40 	mul	r0,r5,r0
8000c08a:	e2 00 00 00 	add	r0,r1,r0
8000c08e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000c092:	02 1b       	sub	r11,r1
8000c094:	50 1b       	stdsp	sp[0x4],r11
8000c096:	70 0b       	ld.w	r11,r8[0x0]
8000c098:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000c09c:	02 09       	add	r9,r1
8000c09e:	f2 0e 01 0e 	sub	lr,r9,lr
8000c0a2:	b0 1e       	st.h	r8[0x2],lr
8000c0a4:	fc 09 14 10 	asr	r9,lr,0x10
8000c0a8:	40 1e       	lddsp	lr,sp[0x4]
8000c0aa:	fc 09 00 09 	add	r9,lr,r9
8000c0ae:	b0 09       	st.h	r8[0x0],r9
8000c0b0:	e0 01 16 10 	lsr	r1,r0,0x10
8000c0b4:	2f c8       	sub	r8,-4
8000c0b6:	b1 49       	asr	r9,0x10
8000c0b8:	04 3a       	cp.w	r10,r2
8000c0ba:	fe 98 ff d8 	brls	8000c06a <quorem+0x42>
8000c0be:	40 0b       	lddsp	r11,sp[0x0]
8000c0c0:	58 0c       	cp.w	r12,0
8000c0c2:	c0 f1       	brne	8000c0e0 <quorem+0xb8>
8000c0c4:	ec c8 ff fb 	sub	r8,r6,-5
8000c0c8:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000c0cc:	c0 28       	rjmp	8000c0d0 <quorem+0xa8>
8000c0ce:	20 16       	sub	r6,1
8000c0d0:	20 48       	sub	r8,4
8000c0d2:	08 38       	cp.w	r8,r4
8000c0d4:	e0 88 00 05 	brls	8000c0de <quorem+0xb6>
8000c0d8:	70 09       	ld.w	r9,r8[0x0]
8000c0da:	58 09       	cp.w	r9,0
8000c0dc:	cf 90       	breq	8000c0ce <quorem+0xa6>
8000c0de:	8f 46       	st.w	r7[0x10],r6
8000c0e0:	0e 9c       	mov	r12,r7
8000c0e2:	e0 a0 0a d2 	rcall	8000d686 <__mcmp>
8000c0e6:	c2 d5       	brlt	8000c140 <quorem+0x118>
8000c0e8:	2f f5       	sub	r5,-1
8000c0ea:	08 98       	mov	r8,r4
8000c0ec:	30 09       	mov	r9,0
8000c0ee:	07 0b       	ld.w	r11,r3++
8000c0f0:	f6 0a 16 10 	lsr	r10,r11,0x10
8000c0f4:	70 0c       	ld.w	r12,r8[0x0]
8000c0f6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000c0fa:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c0fe:	14 1e       	sub	lr,r10
8000c100:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c104:	16 1a       	sub	r10,r11
8000c106:	12 0a       	add	r10,r9
8000c108:	b0 1a       	st.h	r8[0x2],r10
8000c10a:	b1 4a       	asr	r10,0x10
8000c10c:	fc 0a 00 09 	add	r9,lr,r10
8000c110:	b0 09       	st.h	r8[0x0],r9
8000c112:	2f c8       	sub	r8,-4
8000c114:	b1 49       	asr	r9,0x10
8000c116:	04 33       	cp.w	r3,r2
8000c118:	fe 98 ff eb 	brls	8000c0ee <quorem+0xc6>
8000c11c:	ec c8 ff fb 	sub	r8,r6,-5
8000c120:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000c124:	58 09       	cp.w	r9,0
8000c126:	c0 d1       	brne	8000c140 <quorem+0x118>
8000c128:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000c12c:	c0 28       	rjmp	8000c130 <quorem+0x108>
8000c12e:	20 16       	sub	r6,1
8000c130:	20 48       	sub	r8,4
8000c132:	08 38       	cp.w	r8,r4
8000c134:	e0 88 00 05 	brls	8000c13e <quorem+0x116>
8000c138:	70 09       	ld.w	r9,r8[0x0]
8000c13a:	58 09       	cp.w	r9,0
8000c13c:	cf 90       	breq	8000c12e <quorem+0x106>
8000c13e:	8f 46       	st.w	r7[0x10],r6
8000c140:	0a 9c       	mov	r12,r5
8000c142:	2f ed       	sub	sp,-8
8000c144:	d8 32       	popm	r0-r7,pc
8000c146:	d7 03       	nop

8000c148 <_dtoa_r>:
8000c148:	d4 31       	pushm	r0-r7,lr
8000c14a:	21 ad       	sub	sp,104
8000c14c:	fa c4 ff 74 	sub	r4,sp,-140
8000c150:	18 97       	mov	r7,r12
8000c152:	16 95       	mov	r5,r11
8000c154:	68 2c       	ld.w	r12,r4[0x8]
8000c156:	50 c9       	stdsp	sp[0x30],r9
8000c158:	68 16       	ld.w	r6,r4[0x4]
8000c15a:	68 09       	ld.w	r9,r4[0x0]
8000c15c:	50 e8       	stdsp	sp[0x38],r8
8000c15e:	14 94       	mov	r4,r10
8000c160:	51 2c       	stdsp	sp[0x48],r12
8000c162:	fa e5 00 08 	st.d	sp[8],r4
8000c166:	51 59       	stdsp	sp[0x54],r9
8000c168:	6e 95       	ld.w	r5,r7[0x24]
8000c16a:	58 05       	cp.w	r5,0
8000c16c:	c0 91       	brne	8000c17e <_dtoa_r+0x36>
8000c16e:	31 0c       	mov	r12,16
8000c170:	fe b0 e8 e8 	rcall	80009340 <malloc>
8000c174:	99 35       	st.w	r12[0xc],r5
8000c176:	8f 9c       	st.w	r7[0x24],r12
8000c178:	99 15       	st.w	r12[0x4],r5
8000c17a:	99 25       	st.w	r12[0x8],r5
8000c17c:	99 05       	st.w	r12[0x0],r5
8000c17e:	6e 99       	ld.w	r9,r7[0x24]
8000c180:	72 08       	ld.w	r8,r9[0x0]
8000c182:	58 08       	cp.w	r8,0
8000c184:	c0 f0       	breq	8000c1a2 <_dtoa_r+0x5a>
8000c186:	72 1a       	ld.w	r10,r9[0x4]
8000c188:	91 1a       	st.w	r8[0x4],r10
8000c18a:	30 1a       	mov	r10,1
8000c18c:	72 19       	ld.w	r9,r9[0x4]
8000c18e:	f4 09 09 49 	lsl	r9,r10,r9
8000c192:	10 9b       	mov	r11,r8
8000c194:	91 29       	st.w	r8[0x8],r9
8000c196:	0e 9c       	mov	r12,r7
8000c198:	e0 a0 0a 90 	rcall	8000d6b8 <_Bfree>
8000c19c:	6e 98       	ld.w	r8,r7[0x24]
8000c19e:	30 09       	mov	r9,0
8000c1a0:	91 09       	st.w	r8[0x0],r9
8000c1a2:	40 28       	lddsp	r8,sp[0x8]
8000c1a4:	10 94       	mov	r4,r8
8000c1a6:	58 08       	cp.w	r8,0
8000c1a8:	c0 64       	brge	8000c1b4 <_dtoa_r+0x6c>
8000c1aa:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000c1ae:	50 28       	stdsp	sp[0x8],r8
8000c1b0:	30 18       	mov	r8,1
8000c1b2:	c0 28       	rjmp	8000c1b6 <_dtoa_r+0x6e>
8000c1b4:	30 08       	mov	r8,0
8000c1b6:	8d 08       	st.w	r6[0x0],r8
8000c1b8:	fc 1c 7f f0 	movh	r12,0x7ff0
8000c1bc:	40 26       	lddsp	r6,sp[0x8]
8000c1be:	0c 98       	mov	r8,r6
8000c1c0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000c1c4:	18 38       	cp.w	r8,r12
8000c1c6:	c2 01       	brne	8000c206 <_dtoa_r+0xbe>
8000c1c8:	e0 68 27 0f 	mov	r8,9999
8000c1cc:	41 5b       	lddsp	r11,sp[0x54]
8000c1ce:	97 08       	st.w	r11[0x0],r8
8000c1d0:	40 3a       	lddsp	r10,sp[0xc]
8000c1d2:	58 0a       	cp.w	r10,0
8000c1d4:	c0 71       	brne	8000c1e2 <_dtoa_r+0x9a>
8000c1d6:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000c1da:	c0 41       	brne	8000c1e2 <_dtoa_r+0x9a>
8000c1dc:	fe cc ca 44 	sub	r12,pc,-13756
8000c1e0:	c0 38       	rjmp	8000c1e6 <_dtoa_r+0x9e>
8000c1e2:	fe cc ca 3e 	sub	r12,pc,-13762
8000c1e6:	41 29       	lddsp	r9,sp[0x48]
8000c1e8:	58 09       	cp.w	r9,0
8000c1ea:	e0 80 05 9a 	breq	8000cd1e <_dtoa_r+0xbd6>
8000c1ee:	f8 c8 ff fd 	sub	r8,r12,-3
8000c1f2:	f8 c9 ff f8 	sub	r9,r12,-8
8000c1f6:	11 8b       	ld.ub	r11,r8[0x0]
8000c1f8:	30 0a       	mov	r10,0
8000c1fa:	41 25       	lddsp	r5,sp[0x48]
8000c1fc:	f4 0b 18 00 	cp.b	r11,r10
8000c200:	f2 08 17 10 	movne	r8,r9
8000c204:	c1 68       	rjmp	8000c230 <_dtoa_r+0xe8>
8000c206:	fa ea 00 08 	ld.d	r10,sp[8]
8000c20a:	30 08       	mov	r8,0
8000c20c:	fa eb 00 3c 	st.d	sp[60],r10
8000c210:	30 09       	mov	r9,0
8000c212:	e0 a0 10 c2 	rcall	8000e396 <__avr32_f64_cmp_eq>
8000c216:	c1 00       	breq	8000c236 <_dtoa_r+0xee>
8000c218:	30 18       	mov	r8,1
8000c21a:	41 5a       	lddsp	r10,sp[0x54]
8000c21c:	95 08       	st.w	r10[0x0],r8
8000c21e:	fe cc cb aa 	sub	r12,pc,-13398
8000c222:	41 29       	lddsp	r9,sp[0x48]
8000c224:	f8 08 00 08 	add	r8,r12,r8
8000c228:	58 09       	cp.w	r9,0
8000c22a:	e0 80 05 7a 	breq	8000cd1e <_dtoa_r+0xbd6>
8000c22e:	12 95       	mov	r5,r9
8000c230:	8b 08       	st.w	r5[0x0],r8
8000c232:	e0 8f 05 76 	bral	8000cd1e <_dtoa_r+0xbd6>
8000c236:	fa c8 ff 9c 	sub	r8,sp,-100
8000c23a:	fa c9 ff a0 	sub	r9,sp,-96
8000c23e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000c242:	0e 9c       	mov	r12,r7
8000c244:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000c248:	e0 a0 0a 8a 	rcall	8000d75c <__d2b>
8000c24c:	18 93       	mov	r3,r12
8000c24e:	58 05       	cp.w	r5,0
8000c250:	c0 d0       	breq	8000c26a <_dtoa_r+0x122>
8000c252:	fa ea 00 3c 	ld.d	r10,sp[60]
8000c256:	30 04       	mov	r4,0
8000c258:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000c25c:	ea c5 03 ff 	sub	r5,r5,1023
8000c260:	10 9b       	mov	r11,r8
8000c262:	51 74       	stdsp	sp[0x5c],r4
8000c264:	ea 1b 3f f0 	orh	r11,0x3ff0
8000c268:	c2 58       	rjmp	8000c2b2 <_dtoa_r+0x16a>
8000c26a:	41 88       	lddsp	r8,sp[0x60]
8000c26c:	41 9c       	lddsp	r12,sp[0x64]
8000c26e:	10 0c       	add	r12,r8
8000c270:	f8 c5 fb ce 	sub	r5,r12,-1074
8000c274:	e0 45 00 20 	cp.w	r5,32
8000c278:	e0 8a 00 0e 	brle	8000c294 <_dtoa_r+0x14c>
8000c27c:	f8 cc fb ee 	sub	r12,r12,-1042
8000c280:	40 3b       	lddsp	r11,sp[0xc]
8000c282:	ea 08 11 40 	rsub	r8,r5,64
8000c286:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000c28a:	ec 08 09 46 	lsl	r6,r6,r8
8000c28e:	0c 4c       	or	r12,r6
8000c290:	c0 78       	rjmp	8000c29e <_dtoa_r+0x156>
8000c292:	d7 03       	nop
8000c294:	ea 0c 11 20 	rsub	r12,r5,32
8000c298:	40 3a       	lddsp	r10,sp[0xc]
8000c29a:	f4 0c 09 4c 	lsl	r12,r10,r12
8000c29e:	e0 a0 10 08 	rcall	8000e2ae <__avr32_u32_to_f64>
8000c2a2:	fc 18 fe 10 	movh	r8,0xfe10
8000c2a6:	30 19       	mov	r9,1
8000c2a8:	ea c5 04 33 	sub	r5,r5,1075
8000c2ac:	f0 0b 00 0b 	add	r11,r8,r11
8000c2b0:	51 79       	stdsp	sp[0x5c],r9
8000c2b2:	30 08       	mov	r8,0
8000c2b4:	fc 19 3f f8 	movh	r9,0x3ff8
8000c2b8:	e0 a0 0e 90 	rcall	8000dfd8 <__avr32_f64_sub>
8000c2bc:	e0 68 43 61 	mov	r8,17249
8000c2c0:	ea 18 63 6f 	orh	r8,0x636f
8000c2c4:	e0 69 87 a7 	mov	r9,34727
8000c2c8:	ea 19 3f d2 	orh	r9,0x3fd2
8000c2cc:	e0 a0 0d 9a 	rcall	8000de00 <__avr32_f64_mul>
8000c2d0:	e0 68 c8 b3 	mov	r8,51379
8000c2d4:	ea 18 8b 60 	orh	r8,0x8b60
8000c2d8:	e0 69 8a 28 	mov	r9,35368
8000c2dc:	ea 19 3f c6 	orh	r9,0x3fc6
8000c2e0:	e0 a0 0f 4a 	rcall	8000e174 <__avr32_f64_add>
8000c2e4:	0a 9c       	mov	r12,r5
8000c2e6:	14 90       	mov	r0,r10
8000c2e8:	16 91       	mov	r1,r11
8000c2ea:	e0 a0 0f e6 	rcall	8000e2b6 <__avr32_s32_to_f64>
8000c2ee:	e0 68 79 fb 	mov	r8,31227
8000c2f2:	ea 18 50 9f 	orh	r8,0x509f
8000c2f6:	e0 69 44 13 	mov	r9,17427
8000c2fa:	ea 19 3f d3 	orh	r9,0x3fd3
8000c2fe:	e0 a0 0d 81 	rcall	8000de00 <__avr32_f64_mul>
8000c302:	14 98       	mov	r8,r10
8000c304:	16 99       	mov	r9,r11
8000c306:	00 9a       	mov	r10,r0
8000c308:	02 9b       	mov	r11,r1
8000c30a:	e0 a0 0f 35 	rcall	8000e174 <__avr32_f64_add>
8000c30e:	14 90       	mov	r0,r10
8000c310:	16 91       	mov	r1,r11
8000c312:	e0 a0 0f bb 	rcall	8000e288 <__avr32_f64_to_s32>
8000c316:	30 08       	mov	r8,0
8000c318:	18 96       	mov	r6,r12
8000c31a:	30 09       	mov	r9,0
8000c31c:	00 9a       	mov	r10,r0
8000c31e:	02 9b       	mov	r11,r1
8000c320:	e0 a0 10 82 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000c324:	c0 c0       	breq	8000c33c <_dtoa_r+0x1f4>
8000c326:	0c 9c       	mov	r12,r6
8000c328:	e0 a0 0f c7 	rcall	8000e2b6 <__avr32_s32_to_f64>
8000c32c:	14 98       	mov	r8,r10
8000c32e:	16 99       	mov	r9,r11
8000c330:	00 9a       	mov	r10,r0
8000c332:	02 9b       	mov	r11,r1
8000c334:	e0 a0 10 31 	rcall	8000e396 <__avr32_f64_cmp_eq>
8000c338:	f7 b6 00 01 	subeq	r6,1
8000c33c:	59 66       	cp.w	r6,22
8000c33e:	e0 88 00 05 	brls	8000c348 <_dtoa_r+0x200>
8000c342:	30 18       	mov	r8,1
8000c344:	51 48       	stdsp	sp[0x50],r8
8000c346:	c1 38       	rjmp	8000c36c <_dtoa_r+0x224>
8000c348:	fe c8 ca ec 	sub	r8,pc,-13588
8000c34c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000c350:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000c354:	e0 a0 10 68 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000c358:	f9 b4 00 00 	moveq	r4,0
8000c35c:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000c360:	f7 b6 01 01 	subne	r6,1
8000c364:	f9 bc 01 00 	movne	r12,0
8000c368:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000c36c:	41 90       	lddsp	r0,sp[0x64]
8000c36e:	20 10       	sub	r0,1
8000c370:	0a 10       	sub	r0,r5
8000c372:	c0 46       	brmi	8000c37a <_dtoa_r+0x232>
8000c374:	50 40       	stdsp	sp[0x10],r0
8000c376:	30 00       	mov	r0,0
8000c378:	c0 48       	rjmp	8000c380 <_dtoa_r+0x238>
8000c37a:	30 0b       	mov	r11,0
8000c37c:	5c 30       	neg	r0
8000c37e:	50 4b       	stdsp	sp[0x10],r11
8000c380:	ec 02 11 00 	rsub	r2,r6,0
8000c384:	58 06       	cp.w	r6,0
8000c386:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000c38a:	f5 d6 e4 0a 	addge	r10,r10,r6
8000c38e:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000c392:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000c396:	f9 b2 04 00 	movge	r2,0
8000c39a:	e1 d6 e5 10 	sublt	r0,r0,r6
8000c39e:	f9 b9 05 00 	movlt	r9,0
8000c3a2:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000c3a6:	40 c8       	lddsp	r8,sp[0x30]
8000c3a8:	58 98       	cp.w	r8,9
8000c3aa:	e0 8b 00 20 	brhi	8000c3ea <_dtoa_r+0x2a2>
8000c3ae:	58 58       	cp.w	r8,5
8000c3b0:	f9 b4 0a 01 	movle	r4,1
8000c3b4:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000c3b8:	f7 b5 09 04 	subgt	r5,4
8000c3bc:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000c3c0:	f9 b4 09 00 	movgt	r4,0
8000c3c4:	40 cc       	lddsp	r12,sp[0x30]
8000c3c6:	58 3c       	cp.w	r12,3
8000c3c8:	c2 d0       	breq	8000c422 <_dtoa_r+0x2da>
8000c3ca:	e0 89 00 05 	brgt	8000c3d4 <_dtoa_r+0x28c>
8000c3ce:	58 2c       	cp.w	r12,2
8000c3d0:	c1 01       	brne	8000c3f0 <_dtoa_r+0x2a8>
8000c3d2:	c1 88       	rjmp	8000c402 <_dtoa_r+0x2ba>
8000c3d4:	40 cb       	lddsp	r11,sp[0x30]
8000c3d6:	58 4b       	cp.w	r11,4
8000c3d8:	c0 60       	breq	8000c3e4 <_dtoa_r+0x29c>
8000c3da:	58 5b       	cp.w	r11,5
8000c3dc:	c0 a1       	brne	8000c3f0 <_dtoa_r+0x2a8>
8000c3de:	30 1a       	mov	r10,1
8000c3e0:	50 da       	stdsp	sp[0x34],r10
8000c3e2:	c2 28       	rjmp	8000c426 <_dtoa_r+0x2de>
8000c3e4:	30 19       	mov	r9,1
8000c3e6:	50 d9       	stdsp	sp[0x34],r9
8000c3e8:	c0 f8       	rjmp	8000c406 <_dtoa_r+0x2be>
8000c3ea:	30 08       	mov	r8,0
8000c3ec:	30 14       	mov	r4,1
8000c3ee:	50 c8       	stdsp	sp[0x30],r8
8000c3f0:	3f f5       	mov	r5,-1
8000c3f2:	30 1c       	mov	r12,1
8000c3f4:	30 0b       	mov	r11,0
8000c3f6:	50 95       	stdsp	sp[0x24],r5
8000c3f8:	50 dc       	stdsp	sp[0x34],r12
8000c3fa:	0a 91       	mov	r1,r5
8000c3fc:	31 28       	mov	r8,18
8000c3fe:	50 eb       	stdsp	sp[0x38],r11
8000c400:	c2 08       	rjmp	8000c440 <_dtoa_r+0x2f8>
8000c402:	30 0a       	mov	r10,0
8000c404:	50 da       	stdsp	sp[0x34],r10
8000c406:	40 e9       	lddsp	r9,sp[0x38]
8000c408:	58 09       	cp.w	r9,0
8000c40a:	e0 89 00 07 	brgt	8000c418 <_dtoa_r+0x2d0>
8000c40e:	30 18       	mov	r8,1
8000c410:	50 98       	stdsp	sp[0x24],r8
8000c412:	10 91       	mov	r1,r8
8000c414:	50 e8       	stdsp	sp[0x38],r8
8000c416:	c1 58       	rjmp	8000c440 <_dtoa_r+0x2f8>
8000c418:	40 e5       	lddsp	r5,sp[0x38]
8000c41a:	50 95       	stdsp	sp[0x24],r5
8000c41c:	0a 91       	mov	r1,r5
8000c41e:	0a 98       	mov	r8,r5
8000c420:	c1 08       	rjmp	8000c440 <_dtoa_r+0x2f8>
8000c422:	30 0c       	mov	r12,0
8000c424:	50 dc       	stdsp	sp[0x34],r12
8000c426:	40 eb       	lddsp	r11,sp[0x38]
8000c428:	ec 0b 00 0b 	add	r11,r6,r11
8000c42c:	50 9b       	stdsp	sp[0x24],r11
8000c42e:	16 98       	mov	r8,r11
8000c430:	2f f8       	sub	r8,-1
8000c432:	58 08       	cp.w	r8,0
8000c434:	e0 89 00 05 	brgt	8000c43e <_dtoa_r+0x2f6>
8000c438:	10 91       	mov	r1,r8
8000c43a:	30 18       	mov	r8,1
8000c43c:	c0 28       	rjmp	8000c440 <_dtoa_r+0x2f8>
8000c43e:	10 91       	mov	r1,r8
8000c440:	30 09       	mov	r9,0
8000c442:	6e 9a       	ld.w	r10,r7[0x24]
8000c444:	95 19       	st.w	r10[0x4],r9
8000c446:	30 49       	mov	r9,4
8000c448:	c0 68       	rjmp	8000c454 <_dtoa_r+0x30c>
8000c44a:	d7 03       	nop
8000c44c:	6a 1a       	ld.w	r10,r5[0x4]
8000c44e:	a1 79       	lsl	r9,0x1
8000c450:	2f fa       	sub	r10,-1
8000c452:	8b 1a       	st.w	r5[0x4],r10
8000c454:	6e 95       	ld.w	r5,r7[0x24]
8000c456:	f2 ca ff ec 	sub	r10,r9,-20
8000c45a:	10 3a       	cp.w	r10,r8
8000c45c:	fe 98 ff f8 	brls	8000c44c <_dtoa_r+0x304>
8000c460:	6a 1b       	ld.w	r11,r5[0x4]
8000c462:	0e 9c       	mov	r12,r7
8000c464:	e0 a0 09 44 	rcall	8000d6ec <_Balloc>
8000c468:	58 e1       	cp.w	r1,14
8000c46a:	5f 88       	srls	r8
8000c46c:	8b 0c       	st.w	r5[0x0],r12
8000c46e:	f1 e4 00 04 	and	r4,r8,r4
8000c472:	6e 98       	ld.w	r8,r7[0x24]
8000c474:	70 08       	ld.w	r8,r8[0x0]
8000c476:	50 88       	stdsp	sp[0x20],r8
8000c478:	e0 80 01 82 	breq	8000c77c <_dtoa_r+0x634>
8000c47c:	58 06       	cp.w	r6,0
8000c47e:	e0 8a 00 43 	brle	8000c504 <_dtoa_r+0x3bc>
8000c482:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000c486:	fe c8 cc 2a 	sub	r8,pc,-13270
8000c48a:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000c48e:	fa e5 00 18 	st.d	sp[24],r4
8000c492:	ec 04 14 04 	asr	r4,r6,0x4
8000c496:	ed b4 00 04 	bld	r4,0x4
8000c49a:	c0 30       	breq	8000c4a0 <_dtoa_r+0x358>
8000c49c:	30 25       	mov	r5,2
8000c49e:	c1 08       	rjmp	8000c4be <_dtoa_r+0x376>
8000c4a0:	fe c8 cb 7c 	sub	r8,pc,-13444
8000c4a4:	f0 e8 00 20 	ld.d	r8,r8[32]
8000c4a8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000c4ac:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000c4b0:	e0 a0 0f ee 	rcall	8000e48c <__avr32_f64_div>
8000c4b4:	30 35       	mov	r5,3
8000c4b6:	14 98       	mov	r8,r10
8000c4b8:	16 99       	mov	r9,r11
8000c4ba:	fa e9 00 08 	st.d	sp[8],r8
8000c4be:	fe cc cb 9a 	sub	r12,pc,-13414
8000c4c2:	50 a3       	stdsp	sp[0x28],r3
8000c4c4:	0c 93       	mov	r3,r6
8000c4c6:	18 96       	mov	r6,r12
8000c4c8:	c0 f8       	rjmp	8000c4e6 <_dtoa_r+0x39e>
8000c4ca:	fa ea 00 18 	ld.d	r10,sp[24]
8000c4ce:	ed b4 00 00 	bld	r4,0x0
8000c4d2:	c0 81       	brne	8000c4e2 <_dtoa_r+0x39a>
8000c4d4:	ec e8 00 00 	ld.d	r8,r6[0]
8000c4d8:	2f f5       	sub	r5,-1
8000c4da:	e0 a0 0c 93 	rcall	8000de00 <__avr32_f64_mul>
8000c4de:	fa eb 00 18 	st.d	sp[24],r10
8000c4e2:	a1 54       	asr	r4,0x1
8000c4e4:	2f 86       	sub	r6,-8
8000c4e6:	58 04       	cp.w	r4,0
8000c4e8:	cf 11       	brne	8000c4ca <_dtoa_r+0x382>
8000c4ea:	fa e8 00 18 	ld.d	r8,sp[24]
8000c4ee:	fa ea 00 08 	ld.d	r10,sp[8]
8000c4f2:	06 96       	mov	r6,r3
8000c4f4:	e0 a0 0f cc 	rcall	8000e48c <__avr32_f64_div>
8000c4f8:	40 a3       	lddsp	r3,sp[0x28]
8000c4fa:	14 98       	mov	r8,r10
8000c4fc:	16 99       	mov	r9,r11
8000c4fe:	fa e9 00 08 	st.d	sp[8],r8
8000c502:	c2 f8       	rjmp	8000c560 <_dtoa_r+0x418>
8000c504:	ec 08 11 00 	rsub	r8,r6,0
8000c508:	c0 31       	brne	8000c50e <_dtoa_r+0x3c6>
8000c50a:	30 25       	mov	r5,2
8000c50c:	c2 a8       	rjmp	8000c560 <_dtoa_r+0x418>
8000c50e:	fe cc cb ea 	sub	r12,pc,-13334
8000c512:	f0 04 14 04 	asr	r4,r8,0x4
8000c516:	50 1c       	stdsp	sp[0x4],r12
8000c518:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000c51c:	fe c9 cc c0 	sub	r9,pc,-13120
8000c520:	fa ea 00 3c 	ld.d	r10,sp[60]
8000c524:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000c528:	e0 a0 0c 6c 	rcall	8000de00 <__avr32_f64_mul>
8000c52c:	40 1c       	lddsp	r12,sp[0x4]
8000c52e:	50 63       	stdsp	sp[0x18],r3
8000c530:	30 25       	mov	r5,2
8000c532:	0c 93       	mov	r3,r6
8000c534:	fa eb 00 08 	st.d	sp[8],r10
8000c538:	18 96       	mov	r6,r12
8000c53a:	c0 f8       	rjmp	8000c558 <_dtoa_r+0x410>
8000c53c:	fa ea 00 08 	ld.d	r10,sp[8]
8000c540:	ed b4 00 00 	bld	r4,0x0
8000c544:	c0 81       	brne	8000c554 <_dtoa_r+0x40c>
8000c546:	ec e8 00 00 	ld.d	r8,r6[0]
8000c54a:	2f f5       	sub	r5,-1
8000c54c:	e0 a0 0c 5a 	rcall	8000de00 <__avr32_f64_mul>
8000c550:	fa eb 00 08 	st.d	sp[8],r10
8000c554:	a1 54       	asr	r4,0x1
8000c556:	2f 86       	sub	r6,-8
8000c558:	58 04       	cp.w	r4,0
8000c55a:	cf 11       	brne	8000c53c <_dtoa_r+0x3f4>
8000c55c:	06 96       	mov	r6,r3
8000c55e:	40 63       	lddsp	r3,sp[0x18]
8000c560:	41 4a       	lddsp	r10,sp[0x50]
8000c562:	58 0a       	cp.w	r10,0
8000c564:	c2 a0       	breq	8000c5b8 <_dtoa_r+0x470>
8000c566:	fa e8 00 08 	ld.d	r8,sp[8]
8000c56a:	58 01       	cp.w	r1,0
8000c56c:	5f 94       	srgt	r4
8000c56e:	fa e9 00 18 	st.d	sp[24],r8
8000c572:	30 08       	mov	r8,0
8000c574:	fc 19 3f f0 	movh	r9,0x3ff0
8000c578:	fa ea 00 18 	ld.d	r10,sp[24]
8000c57c:	e0 a0 0f 54 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000c580:	f9 bc 00 00 	moveq	r12,0
8000c584:	f9 bc 01 01 	movne	r12,1
8000c588:	e9 ec 00 0c 	and	r12,r4,r12
8000c58c:	c1 60       	breq	8000c5b8 <_dtoa_r+0x470>
8000c58e:	40 98       	lddsp	r8,sp[0x24]
8000c590:	58 08       	cp.w	r8,0
8000c592:	e0 8a 00 f1 	brle	8000c774 <_dtoa_r+0x62c>
8000c596:	30 08       	mov	r8,0
8000c598:	fc 19 40 24 	movh	r9,0x4024
8000c59c:	ec c4 00 01 	sub	r4,r6,1
8000c5a0:	fa ea 00 18 	ld.d	r10,sp[24]
8000c5a4:	2f f5       	sub	r5,-1
8000c5a6:	50 64       	stdsp	sp[0x18],r4
8000c5a8:	e0 a0 0c 2c 	rcall	8000de00 <__avr32_f64_mul>
8000c5ac:	40 94       	lddsp	r4,sp[0x24]
8000c5ae:	14 98       	mov	r8,r10
8000c5b0:	16 99       	mov	r9,r11
8000c5b2:	fa e9 00 08 	st.d	sp[8],r8
8000c5b6:	c0 38       	rjmp	8000c5bc <_dtoa_r+0x474>
8000c5b8:	50 66       	stdsp	sp[0x18],r6
8000c5ba:	02 94       	mov	r4,r1
8000c5bc:	0a 9c       	mov	r12,r5
8000c5be:	e0 a0 0e 7c 	rcall	8000e2b6 <__avr32_s32_to_f64>
8000c5c2:	fa e8 00 08 	ld.d	r8,sp[8]
8000c5c6:	e0 a0 0c 1d 	rcall	8000de00 <__avr32_f64_mul>
8000c5ca:	30 08       	mov	r8,0
8000c5cc:	fc 19 40 1c 	movh	r9,0x401c
8000c5d0:	e0 a0 0d d2 	rcall	8000e174 <__avr32_f64_add>
8000c5d4:	14 98       	mov	r8,r10
8000c5d6:	16 99       	mov	r9,r11
8000c5d8:	fa e9 00 28 	st.d	sp[40],r8
8000c5dc:	fc 18 fc c0 	movh	r8,0xfcc0
8000c5e0:	40 a5       	lddsp	r5,sp[0x28]
8000c5e2:	10 05       	add	r5,r8
8000c5e4:	50 a5       	stdsp	sp[0x28],r5
8000c5e6:	58 04       	cp.w	r4,0
8000c5e8:	c2 11       	brne	8000c62a <_dtoa_r+0x4e2>
8000c5ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000c5ee:	30 08       	mov	r8,0
8000c5f0:	fc 19 40 14 	movh	r9,0x4014
8000c5f4:	e0 a0 0c f2 	rcall	8000dfd8 <__avr32_f64_sub>
8000c5f8:	40 bc       	lddsp	r12,sp[0x2c]
8000c5fa:	fa eb 00 08 	st.d	sp[8],r10
8000c5fe:	14 98       	mov	r8,r10
8000c600:	16 99       	mov	r9,r11
8000c602:	18 9a       	mov	r10,r12
8000c604:	0a 9b       	mov	r11,r5
8000c606:	e0 a0 0f 0f 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000c60a:	e0 81 02 54 	brne	8000cab2 <_dtoa_r+0x96a>
8000c60e:	0a 98       	mov	r8,r5
8000c610:	40 b9       	lddsp	r9,sp[0x2c]
8000c612:	ee 18 80 00 	eorh	r8,0x8000
8000c616:	fa ea 00 08 	ld.d	r10,sp[8]
8000c61a:	10 95       	mov	r5,r8
8000c61c:	12 98       	mov	r8,r9
8000c61e:	0a 99       	mov	r9,r5
8000c620:	e0 a0 0f 02 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000c624:	e0 81 02 3e 	brne	8000caa0 <_dtoa_r+0x958>
8000c628:	ca 68       	rjmp	8000c774 <_dtoa_r+0x62c>
8000c62a:	fe c9 cd ce 	sub	r9,pc,-12850
8000c62e:	e8 c8 00 01 	sub	r8,r4,1
8000c632:	40 d5       	lddsp	r5,sp[0x34]
8000c634:	58 05       	cp.w	r5,0
8000c636:	c4 f0       	breq	8000c6d4 <_dtoa_r+0x58c>
8000c638:	30 0c       	mov	r12,0
8000c63a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000c63e:	51 3c       	stdsp	sp[0x4c],r12
8000c640:	30 0a       	mov	r10,0
8000c642:	fc 1b 3f e0 	movh	r11,0x3fe0
8000c646:	e0 a0 0f 23 	rcall	8000e48c <__avr32_f64_div>
8000c64a:	fa e8 00 28 	ld.d	r8,sp[40]
8000c64e:	40 85       	lddsp	r5,sp[0x20]
8000c650:	e0 a0 0c c4 	rcall	8000dfd8 <__avr32_f64_sub>
8000c654:	fa eb 00 28 	st.d	sp[40],r10
8000c658:	fa ea 00 08 	ld.d	r10,sp[8]
8000c65c:	e0 a0 0e 16 	rcall	8000e288 <__avr32_f64_to_s32>
8000c660:	51 6c       	stdsp	sp[0x58],r12
8000c662:	e0 a0 0e 2a 	rcall	8000e2b6 <__avr32_s32_to_f64>
8000c666:	14 98       	mov	r8,r10
8000c668:	16 99       	mov	r9,r11
8000c66a:	fa ea 00 08 	ld.d	r10,sp[8]
8000c66e:	e0 a0 0c b5 	rcall	8000dfd8 <__avr32_f64_sub>
8000c672:	fa eb 00 08 	st.d	sp[8],r10
8000c676:	41 68       	lddsp	r8,sp[0x58]
8000c678:	2d 08       	sub	r8,-48
8000c67a:	0a c8       	st.b	r5++,r8
8000c67c:	41 39       	lddsp	r9,sp[0x4c]
8000c67e:	2f f9       	sub	r9,-1
8000c680:	51 39       	stdsp	sp[0x4c],r9
8000c682:	fa e8 00 28 	ld.d	r8,sp[40]
8000c686:	e0 a0 0e cf 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000c68a:	e0 81 03 39 	brne	8000ccfc <_dtoa_r+0xbb4>
8000c68e:	fa e8 00 08 	ld.d	r8,sp[8]
8000c692:	30 0a       	mov	r10,0
8000c694:	fc 1b 3f f0 	movh	r11,0x3ff0
8000c698:	e0 a0 0c a0 	rcall	8000dfd8 <__avr32_f64_sub>
8000c69c:	fa e8 00 28 	ld.d	r8,sp[40]
8000c6a0:	e0 a0 0e c2 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000c6a4:	fa ea 00 28 	ld.d	r10,sp[40]
8000c6a8:	30 08       	mov	r8,0
8000c6aa:	fc 19 40 24 	movh	r9,0x4024
8000c6ae:	e0 81 00 da 	brne	8000c862 <_dtoa_r+0x71a>
8000c6b2:	41 3c       	lddsp	r12,sp[0x4c]
8000c6b4:	08 3c       	cp.w	r12,r4
8000c6b6:	c5 f4       	brge	8000c774 <_dtoa_r+0x62c>
8000c6b8:	e0 a0 0b a4 	rcall	8000de00 <__avr32_f64_mul>
8000c6bc:	30 08       	mov	r8,0
8000c6be:	fa eb 00 28 	st.d	sp[40],r10
8000c6c2:	fc 19 40 24 	movh	r9,0x4024
8000c6c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000c6ca:	e0 a0 0b 9b 	rcall	8000de00 <__avr32_f64_mul>
8000c6ce:	fa eb 00 08 	st.d	sp[8],r10
8000c6d2:	cc 3b       	rjmp	8000c658 <_dtoa_r+0x510>
8000c6d4:	40 85       	lddsp	r5,sp[0x20]
8000c6d6:	08 05       	add	r5,r4
8000c6d8:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000c6dc:	51 35       	stdsp	sp[0x4c],r5
8000c6de:	fa e8 00 28 	ld.d	r8,sp[40]
8000c6e2:	40 85       	lddsp	r5,sp[0x20]
8000c6e4:	e0 a0 0b 8e 	rcall	8000de00 <__avr32_f64_mul>
8000c6e8:	fa eb 00 28 	st.d	sp[40],r10
8000c6ec:	fa ea 00 08 	ld.d	r10,sp[8]
8000c6f0:	e0 a0 0d cc 	rcall	8000e288 <__avr32_f64_to_s32>
8000c6f4:	51 6c       	stdsp	sp[0x58],r12
8000c6f6:	e0 a0 0d e0 	rcall	8000e2b6 <__avr32_s32_to_f64>
8000c6fa:	14 98       	mov	r8,r10
8000c6fc:	16 99       	mov	r9,r11
8000c6fe:	fa ea 00 08 	ld.d	r10,sp[8]
8000c702:	e0 a0 0c 6b 	rcall	8000dfd8 <__avr32_f64_sub>
8000c706:	fa eb 00 08 	st.d	sp[8],r10
8000c70a:	41 68       	lddsp	r8,sp[0x58]
8000c70c:	2d 08       	sub	r8,-48
8000c70e:	0a c8       	st.b	r5++,r8
8000c710:	41 3c       	lddsp	r12,sp[0x4c]
8000c712:	18 35       	cp.w	r5,r12
8000c714:	c2 81       	brne	8000c764 <_dtoa_r+0x61c>
8000c716:	30 08       	mov	r8,0
8000c718:	fc 19 3f e0 	movh	r9,0x3fe0
8000c71c:	fa ea 00 28 	ld.d	r10,sp[40]
8000c720:	e0 a0 0d 2a 	rcall	8000e174 <__avr32_f64_add>
8000c724:	40 85       	lddsp	r5,sp[0x20]
8000c726:	fa e8 00 08 	ld.d	r8,sp[8]
8000c72a:	08 05       	add	r5,r4
8000c72c:	e0 a0 0e 7c 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000c730:	e0 81 00 99 	brne	8000c862 <_dtoa_r+0x71a>
8000c734:	fa e8 00 28 	ld.d	r8,sp[40]
8000c738:	30 0a       	mov	r10,0
8000c73a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000c73e:	e0 a0 0c 4d 	rcall	8000dfd8 <__avr32_f64_sub>
8000c742:	14 98       	mov	r8,r10
8000c744:	16 99       	mov	r9,r11
8000c746:	fa ea 00 08 	ld.d	r10,sp[8]
8000c74a:	e0 a0 0e 6d 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000c74e:	c1 30       	breq	8000c774 <_dtoa_r+0x62c>
8000c750:	33 09       	mov	r9,48
8000c752:	0a 98       	mov	r8,r5
8000c754:	11 7a       	ld.ub	r10,--r8
8000c756:	f2 0a 18 00 	cp.b	r10,r9
8000c75a:	e0 81 02 d1 	brne	8000ccfc <_dtoa_r+0xbb4>
8000c75e:	10 95       	mov	r5,r8
8000c760:	cf 9b       	rjmp	8000c752 <_dtoa_r+0x60a>
8000c762:	d7 03       	nop
8000c764:	30 08       	mov	r8,0
8000c766:	fc 19 40 24 	movh	r9,0x4024
8000c76a:	e0 a0 0b 4b 	rcall	8000de00 <__avr32_f64_mul>
8000c76e:	fa eb 00 08 	st.d	sp[8],r10
8000c772:	cb db       	rjmp	8000c6ec <_dtoa_r+0x5a4>
8000c774:	fa ea 00 3c 	ld.d	r10,sp[60]
8000c778:	fa eb 00 08 	st.d	sp[8],r10
8000c77c:	58 e6       	cp.w	r6,14
8000c77e:	5f ab       	srle	r11
8000c780:	41 8a       	lddsp	r10,sp[0x60]
8000c782:	30 08       	mov	r8,0
8000c784:	f4 09 11 ff 	rsub	r9,r10,-1
8000c788:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000c78c:	f0 09 18 00 	cp.b	r9,r8
8000c790:	e0 80 00 82 	breq	8000c894 <_dtoa_r+0x74c>
8000c794:	40 ea       	lddsp	r10,sp[0x38]
8000c796:	58 01       	cp.w	r1,0
8000c798:	5f a9       	srle	r9
8000c79a:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000c79e:	fe ca cf 42 	sub	r10,pc,-12478
8000c7a2:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000c7a6:	fa e5 00 10 	st.d	sp[16],r4
8000c7aa:	f0 09 18 00 	cp.b	r9,r8
8000c7ae:	c1 40       	breq	8000c7d6 <_dtoa_r+0x68e>
8000c7b0:	58 01       	cp.w	r1,0
8000c7b2:	e0 81 01 77 	brne	8000caa0 <_dtoa_r+0x958>
8000c7b6:	30 08       	mov	r8,0
8000c7b8:	fc 19 40 14 	movh	r9,0x4014
8000c7bc:	08 9a       	mov	r10,r4
8000c7be:	0a 9b       	mov	r11,r5
8000c7c0:	e0 a0 0b 20 	rcall	8000de00 <__avr32_f64_mul>
8000c7c4:	fa e8 00 08 	ld.d	r8,sp[8]
8000c7c8:	e0 a0 0d fa 	rcall	8000e3bc <__avr32_f64_cmp_ge>
8000c7cc:	e0 81 01 6a 	brne	8000caa0 <_dtoa_r+0x958>
8000c7d0:	02 92       	mov	r2,r1
8000c7d2:	e0 8f 01 72 	bral	8000cab6 <_dtoa_r+0x96e>
8000c7d6:	40 85       	lddsp	r5,sp[0x20]
8000c7d8:	30 14       	mov	r4,1
8000c7da:	fa e8 00 10 	ld.d	r8,sp[16]
8000c7de:	fa ea 00 08 	ld.d	r10,sp[8]
8000c7e2:	e0 a0 0e 55 	rcall	8000e48c <__avr32_f64_div>
8000c7e6:	e0 a0 0d 51 	rcall	8000e288 <__avr32_f64_to_s32>
8000c7ea:	18 92       	mov	r2,r12
8000c7ec:	e0 a0 0d 65 	rcall	8000e2b6 <__avr32_s32_to_f64>
8000c7f0:	fa e8 00 10 	ld.d	r8,sp[16]
8000c7f4:	e0 a0 0b 06 	rcall	8000de00 <__avr32_f64_mul>
8000c7f8:	14 98       	mov	r8,r10
8000c7fa:	16 99       	mov	r9,r11
8000c7fc:	fa ea 00 08 	ld.d	r10,sp[8]
8000c800:	e0 a0 0b ec 	rcall	8000dfd8 <__avr32_f64_sub>
8000c804:	fa eb 00 08 	st.d	sp[8],r10
8000c808:	e4 c8 ff d0 	sub	r8,r2,-48
8000c80c:	0a c8       	st.b	r5++,r8
8000c80e:	fc 19 40 24 	movh	r9,0x4024
8000c812:	30 08       	mov	r8,0
8000c814:	02 34       	cp.w	r4,r1
8000c816:	c3 31       	brne	8000c87c <_dtoa_r+0x734>
8000c818:	fa e8 00 08 	ld.d	r8,sp[8]
8000c81c:	e0 a0 0c ac 	rcall	8000e174 <__avr32_f64_add>
8000c820:	16 91       	mov	r1,r11
8000c822:	14 90       	mov	r0,r10
8000c824:	14 98       	mov	r8,r10
8000c826:	02 99       	mov	r9,r1
8000c828:	fa ea 00 10 	ld.d	r10,sp[16]
8000c82c:	e0 a0 0d fc 	rcall	8000e424 <__avr32_f64_cmp_lt>
8000c830:	c1 a1       	brne	8000c864 <_dtoa_r+0x71c>
8000c832:	fa e8 00 10 	ld.d	r8,sp[16]
8000c836:	00 9a       	mov	r10,r0
8000c838:	02 9b       	mov	r11,r1
8000c83a:	e0 a0 0d ae 	rcall	8000e396 <__avr32_f64_cmp_eq>
8000c83e:	e0 80 02 5e 	breq	8000ccfa <_dtoa_r+0xbb2>
8000c842:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000c846:	c0 f1       	brne	8000c864 <_dtoa_r+0x71c>
8000c848:	e0 8f 02 59 	bral	8000ccfa <_dtoa_r+0xbb2>
8000c84c:	40 8a       	lddsp	r10,sp[0x20]
8000c84e:	14 38       	cp.w	r8,r10
8000c850:	c0 30       	breq	8000c856 <_dtoa_r+0x70e>
8000c852:	10 95       	mov	r5,r8
8000c854:	c0 98       	rjmp	8000c866 <_dtoa_r+0x71e>
8000c856:	33 08       	mov	r8,48
8000c858:	40 89       	lddsp	r9,sp[0x20]
8000c85a:	2f f6       	sub	r6,-1
8000c85c:	b2 88       	st.b	r9[0x0],r8
8000c85e:	40 88       	lddsp	r8,sp[0x20]
8000c860:	c0 88       	rjmp	8000c870 <_dtoa_r+0x728>
8000c862:	40 66       	lddsp	r6,sp[0x18]
8000c864:	33 99       	mov	r9,57
8000c866:	0a 98       	mov	r8,r5
8000c868:	11 7a       	ld.ub	r10,--r8
8000c86a:	f2 0a 18 00 	cp.b	r10,r9
8000c86e:	ce f0       	breq	8000c84c <_dtoa_r+0x704>
8000c870:	50 66       	stdsp	sp[0x18],r6
8000c872:	11 89       	ld.ub	r9,r8[0x0]
8000c874:	2f f9       	sub	r9,-1
8000c876:	b0 89       	st.b	r8[0x0],r9
8000c878:	e0 8f 02 42 	bral	8000ccfc <_dtoa_r+0xbb4>
8000c87c:	e0 a0 0a c2 	rcall	8000de00 <__avr32_f64_mul>
8000c880:	2f f4       	sub	r4,-1
8000c882:	fa eb 00 08 	st.d	sp[8],r10
8000c886:	30 08       	mov	r8,0
8000c888:	30 09       	mov	r9,0
8000c88a:	e0 a0 0d 86 	rcall	8000e396 <__avr32_f64_cmp_eq>
8000c88e:	ca 60       	breq	8000c7da <_dtoa_r+0x692>
8000c890:	e0 8f 02 35 	bral	8000ccfa <_dtoa_r+0xbb2>
8000c894:	40 d8       	lddsp	r8,sp[0x34]
8000c896:	58 08       	cp.w	r8,0
8000c898:	c0 51       	brne	8000c8a2 <_dtoa_r+0x75a>
8000c89a:	04 98       	mov	r8,r2
8000c89c:	00 95       	mov	r5,r0
8000c89e:	40 d4       	lddsp	r4,sp[0x34]
8000c8a0:	c3 78       	rjmp	8000c90e <_dtoa_r+0x7c6>
8000c8a2:	40 c5       	lddsp	r5,sp[0x30]
8000c8a4:	58 15       	cp.w	r5,1
8000c8a6:	e0 89 00 0f 	brgt	8000c8c4 <_dtoa_r+0x77c>
8000c8aa:	41 74       	lddsp	r4,sp[0x5c]
8000c8ac:	58 04       	cp.w	r4,0
8000c8ae:	c0 40       	breq	8000c8b6 <_dtoa_r+0x76e>
8000c8b0:	f4 c9 fb cd 	sub	r9,r10,-1075
8000c8b4:	c0 48       	rjmp	8000c8bc <_dtoa_r+0x774>
8000c8b6:	41 99       	lddsp	r9,sp[0x64]
8000c8b8:	f2 09 11 36 	rsub	r9,r9,54
8000c8bc:	04 98       	mov	r8,r2
8000c8be:	00 95       	mov	r5,r0
8000c8c0:	c1 c8       	rjmp	8000c8f8 <_dtoa_r+0x7b0>
8000c8c2:	d7 03       	nop
8000c8c4:	e2 c8 00 01 	sub	r8,r1,1
8000c8c8:	58 01       	cp.w	r1,0
8000c8ca:	e0 05 17 40 	movge	r5,r0
8000c8ce:	e2 09 17 40 	movge	r9,r1
8000c8d2:	e1 d1 e5 15 	sublt	r5,r0,r1
8000c8d6:	f9 b9 05 00 	movlt	r9,0
8000c8da:	10 32       	cp.w	r2,r8
8000c8dc:	e5 d8 e4 18 	subge	r8,r2,r8
8000c8e0:	f1 d2 e5 18 	sublt	r8,r8,r2
8000c8e4:	e5 d8 e5 02 	addlt	r2,r2,r8
8000c8e8:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000c8ec:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000c8f0:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000c8f4:	f9 b8 05 00 	movlt	r8,0
8000c8f8:	40 4b       	lddsp	r11,sp[0x10]
8000c8fa:	12 0b       	add	r11,r9
8000c8fc:	50 08       	stdsp	sp[0x0],r8
8000c8fe:	50 4b       	stdsp	sp[0x10],r11
8000c900:	12 00       	add	r0,r9
8000c902:	30 1b       	mov	r11,1
8000c904:	0e 9c       	mov	r12,r7
8000c906:	e0 a0 08 a7 	rcall	8000da54 <__i2b>
8000c90a:	40 08       	lddsp	r8,sp[0x0]
8000c90c:	18 94       	mov	r4,r12
8000c90e:	40 4a       	lddsp	r10,sp[0x10]
8000c910:	58 05       	cp.w	r5,0
8000c912:	5f 99       	srgt	r9
8000c914:	58 0a       	cp.w	r10,0
8000c916:	5f 9a       	srgt	r10
8000c918:	f5 e9 00 09 	and	r9,r10,r9
8000c91c:	c0 80       	breq	8000c92c <_dtoa_r+0x7e4>
8000c91e:	40 4c       	lddsp	r12,sp[0x10]
8000c920:	f8 05 0d 49 	min	r9,r12,r5
8000c924:	12 1c       	sub	r12,r9
8000c926:	12 10       	sub	r0,r9
8000c928:	50 4c       	stdsp	sp[0x10],r12
8000c92a:	12 15       	sub	r5,r9
8000c92c:	58 02       	cp.w	r2,0
8000c92e:	e0 8a 00 27 	brle	8000c97c <_dtoa_r+0x834>
8000c932:	40 db       	lddsp	r11,sp[0x34]
8000c934:	58 0b       	cp.w	r11,0
8000c936:	c1 d0       	breq	8000c970 <_dtoa_r+0x828>
8000c938:	58 08       	cp.w	r8,0
8000c93a:	e0 8a 00 17 	brle	8000c968 <_dtoa_r+0x820>
8000c93e:	10 9a       	mov	r10,r8
8000c940:	50 08       	stdsp	sp[0x0],r8
8000c942:	08 9b       	mov	r11,r4
8000c944:	0e 9c       	mov	r12,r7
8000c946:	e0 a0 08 cd 	rcall	8000dae0 <__pow5mult>
8000c94a:	06 9a       	mov	r10,r3
8000c94c:	18 9b       	mov	r11,r12
8000c94e:	18 94       	mov	r4,r12
8000c950:	0e 9c       	mov	r12,r7
8000c952:	e0 a0 08 01 	rcall	8000d954 <__multiply>
8000c956:	18 99       	mov	r9,r12
8000c958:	06 9b       	mov	r11,r3
8000c95a:	50 19       	stdsp	sp[0x4],r9
8000c95c:	0e 9c       	mov	r12,r7
8000c95e:	e0 a0 06 ad 	rcall	8000d6b8 <_Bfree>
8000c962:	40 19       	lddsp	r9,sp[0x4]
8000c964:	40 08       	lddsp	r8,sp[0x0]
8000c966:	12 93       	mov	r3,r9
8000c968:	e4 08 01 0a 	sub	r10,r2,r8
8000c96c:	c0 80       	breq	8000c97c <_dtoa_r+0x834>
8000c96e:	c0 28       	rjmp	8000c972 <_dtoa_r+0x82a>
8000c970:	04 9a       	mov	r10,r2
8000c972:	06 9b       	mov	r11,r3
8000c974:	0e 9c       	mov	r12,r7
8000c976:	e0 a0 08 b5 	rcall	8000dae0 <__pow5mult>
8000c97a:	18 93       	mov	r3,r12
8000c97c:	30 1b       	mov	r11,1
8000c97e:	0e 9c       	mov	r12,r7
8000c980:	e0 a0 08 6a 	rcall	8000da54 <__i2b>
8000c984:	41 1a       	lddsp	r10,sp[0x44]
8000c986:	18 92       	mov	r2,r12
8000c988:	58 0a       	cp.w	r10,0
8000c98a:	e0 8a 00 07 	brle	8000c998 <_dtoa_r+0x850>
8000c98e:	18 9b       	mov	r11,r12
8000c990:	0e 9c       	mov	r12,r7
8000c992:	e0 a0 08 a7 	rcall	8000dae0 <__pow5mult>
8000c996:	18 92       	mov	r2,r12
8000c998:	40 c9       	lddsp	r9,sp[0x30]
8000c99a:	58 19       	cp.w	r9,1
8000c99c:	e0 89 00 14 	brgt	8000c9c4 <_dtoa_r+0x87c>
8000c9a0:	40 38       	lddsp	r8,sp[0xc]
8000c9a2:	58 08       	cp.w	r8,0
8000c9a4:	c1 01       	brne	8000c9c4 <_dtoa_r+0x87c>
8000c9a6:	40 29       	lddsp	r9,sp[0x8]
8000c9a8:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000c9ac:	c0 c1       	brne	8000c9c4 <_dtoa_r+0x87c>
8000c9ae:	12 98       	mov	r8,r9
8000c9b0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000c9b4:	c0 80       	breq	8000c9c4 <_dtoa_r+0x87c>
8000c9b6:	40 4c       	lddsp	r12,sp[0x10]
8000c9b8:	30 1b       	mov	r11,1
8000c9ba:	2f fc       	sub	r12,-1
8000c9bc:	2f f0       	sub	r0,-1
8000c9be:	50 4c       	stdsp	sp[0x10],r12
8000c9c0:	50 6b       	stdsp	sp[0x18],r11
8000c9c2:	c0 38       	rjmp	8000c9c8 <_dtoa_r+0x880>
8000c9c4:	30 0a       	mov	r10,0
8000c9c6:	50 6a       	stdsp	sp[0x18],r10
8000c9c8:	41 19       	lddsp	r9,sp[0x44]
8000c9ca:	58 09       	cp.w	r9,0
8000c9cc:	c0 31       	brne	8000c9d2 <_dtoa_r+0x88a>
8000c9ce:	30 1c       	mov	r12,1
8000c9d0:	c0 98       	rjmp	8000c9e2 <_dtoa_r+0x89a>
8000c9d2:	64 48       	ld.w	r8,r2[0x10]
8000c9d4:	2f c8       	sub	r8,-4
8000c9d6:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000c9da:	e0 a0 05 df 	rcall	8000d598 <__hi0bits>
8000c9de:	f8 0c 11 20 	rsub	r12,r12,32
8000c9e2:	40 4b       	lddsp	r11,sp[0x10]
8000c9e4:	f8 0b 00 08 	add	r8,r12,r11
8000c9e8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000c9ec:	c0 c0       	breq	8000ca04 <_dtoa_r+0x8bc>
8000c9ee:	f0 08 11 20 	rsub	r8,r8,32
8000c9f2:	58 48       	cp.w	r8,4
8000c9f4:	e0 8a 00 06 	brle	8000ca00 <_dtoa_r+0x8b8>
8000c9f8:	20 48       	sub	r8,4
8000c9fa:	10 0b       	add	r11,r8
8000c9fc:	50 4b       	stdsp	sp[0x10],r11
8000c9fe:	c0 78       	rjmp	8000ca0c <_dtoa_r+0x8c4>
8000ca00:	58 48       	cp.w	r8,4
8000ca02:	c0 70       	breq	8000ca10 <_dtoa_r+0x8c8>
8000ca04:	40 4a       	lddsp	r10,sp[0x10]
8000ca06:	2e 48       	sub	r8,-28
8000ca08:	10 0a       	add	r10,r8
8000ca0a:	50 4a       	stdsp	sp[0x10],r10
8000ca0c:	10 00       	add	r0,r8
8000ca0e:	10 05       	add	r5,r8
8000ca10:	58 00       	cp.w	r0,0
8000ca12:	e0 8a 00 08 	brle	8000ca22 <_dtoa_r+0x8da>
8000ca16:	06 9b       	mov	r11,r3
8000ca18:	00 9a       	mov	r10,r0
8000ca1a:	0e 9c       	mov	r12,r7
8000ca1c:	e0 a0 07 58 	rcall	8000d8cc <__lshift>
8000ca20:	18 93       	mov	r3,r12
8000ca22:	40 49       	lddsp	r9,sp[0x10]
8000ca24:	58 09       	cp.w	r9,0
8000ca26:	e0 8a 00 08 	brle	8000ca36 <_dtoa_r+0x8ee>
8000ca2a:	04 9b       	mov	r11,r2
8000ca2c:	12 9a       	mov	r10,r9
8000ca2e:	0e 9c       	mov	r12,r7
8000ca30:	e0 a0 07 4e 	rcall	8000d8cc <__lshift>
8000ca34:	18 92       	mov	r2,r12
8000ca36:	41 48       	lddsp	r8,sp[0x50]
8000ca38:	58 08       	cp.w	r8,0
8000ca3a:	c1 b0       	breq	8000ca70 <_dtoa_r+0x928>
8000ca3c:	04 9b       	mov	r11,r2
8000ca3e:	06 9c       	mov	r12,r3
8000ca40:	e0 a0 06 23 	rcall	8000d686 <__mcmp>
8000ca44:	c1 64       	brge	8000ca70 <_dtoa_r+0x928>
8000ca46:	06 9b       	mov	r11,r3
8000ca48:	30 09       	mov	r9,0
8000ca4a:	30 aa       	mov	r10,10
8000ca4c:	0e 9c       	mov	r12,r7
8000ca4e:	e0 a0 08 0b 	rcall	8000da64 <__multadd>
8000ca52:	20 16       	sub	r6,1
8000ca54:	18 93       	mov	r3,r12
8000ca56:	40 dc       	lddsp	r12,sp[0x34]
8000ca58:	58 0c       	cp.w	r12,0
8000ca5a:	c0 31       	brne	8000ca60 <_dtoa_r+0x918>
8000ca5c:	40 91       	lddsp	r1,sp[0x24]
8000ca5e:	c0 98       	rjmp	8000ca70 <_dtoa_r+0x928>
8000ca60:	08 9b       	mov	r11,r4
8000ca62:	40 91       	lddsp	r1,sp[0x24]
8000ca64:	30 09       	mov	r9,0
8000ca66:	30 aa       	mov	r10,10
8000ca68:	0e 9c       	mov	r12,r7
8000ca6a:	e0 a0 07 fd 	rcall	8000da64 <__multadd>
8000ca6e:	18 94       	mov	r4,r12
8000ca70:	58 01       	cp.w	r1,0
8000ca72:	5f a9       	srle	r9
8000ca74:	40 cb       	lddsp	r11,sp[0x30]
8000ca76:	58 2b       	cp.w	r11,2
8000ca78:	5f 98       	srgt	r8
8000ca7a:	f3 e8 00 08 	and	r8,r9,r8
8000ca7e:	c2 50       	breq	8000cac8 <_dtoa_r+0x980>
8000ca80:	58 01       	cp.w	r1,0
8000ca82:	c1 11       	brne	8000caa4 <_dtoa_r+0x95c>
8000ca84:	04 9b       	mov	r11,r2
8000ca86:	02 99       	mov	r9,r1
8000ca88:	30 5a       	mov	r10,5
8000ca8a:	0e 9c       	mov	r12,r7
8000ca8c:	e0 a0 07 ec 	rcall	8000da64 <__multadd>
8000ca90:	18 92       	mov	r2,r12
8000ca92:	18 9b       	mov	r11,r12
8000ca94:	06 9c       	mov	r12,r3
8000ca96:	e0 a0 05 f8 	rcall	8000d686 <__mcmp>
8000ca9a:	e0 89 00 0f 	brgt	8000cab8 <_dtoa_r+0x970>
8000ca9e:	c0 38       	rjmp	8000caa4 <_dtoa_r+0x95c>
8000caa0:	30 02       	mov	r2,0
8000caa2:	04 94       	mov	r4,r2
8000caa4:	40 ea       	lddsp	r10,sp[0x38]
8000caa6:	30 09       	mov	r9,0
8000caa8:	5c da       	com	r10
8000caaa:	40 85       	lddsp	r5,sp[0x20]
8000caac:	50 6a       	stdsp	sp[0x18],r10
8000caae:	50 49       	stdsp	sp[0x10],r9
8000cab0:	c0 f9       	rjmp	8000ccce <_dtoa_r+0xb86>
8000cab2:	08 92       	mov	r2,r4
8000cab4:	40 66       	lddsp	r6,sp[0x18]
8000cab6:	04 94       	mov	r4,r2
8000cab8:	2f f6       	sub	r6,-1
8000caba:	50 66       	stdsp	sp[0x18],r6
8000cabc:	33 18       	mov	r8,49
8000cabe:	40 85       	lddsp	r5,sp[0x20]
8000cac0:	0a c8       	st.b	r5++,r8
8000cac2:	30 08       	mov	r8,0
8000cac4:	50 48       	stdsp	sp[0x10],r8
8000cac6:	c0 49       	rjmp	8000ccce <_dtoa_r+0xb86>
8000cac8:	40 dc       	lddsp	r12,sp[0x34]
8000caca:	58 0c       	cp.w	r12,0
8000cacc:	e0 80 00 b5 	breq	8000cc36 <_dtoa_r+0xaee>
8000cad0:	58 05       	cp.w	r5,0
8000cad2:	e0 8a 00 08 	brle	8000cae2 <_dtoa_r+0x99a>
8000cad6:	08 9b       	mov	r11,r4
8000cad8:	0a 9a       	mov	r10,r5
8000cada:	0e 9c       	mov	r12,r7
8000cadc:	e0 a0 06 f8 	rcall	8000d8cc <__lshift>
8000cae0:	18 94       	mov	r4,r12
8000cae2:	40 6b       	lddsp	r11,sp[0x18]
8000cae4:	58 0b       	cp.w	r11,0
8000cae6:	c0 31       	brne	8000caec <_dtoa_r+0x9a4>
8000cae8:	08 9c       	mov	r12,r4
8000caea:	c1 38       	rjmp	8000cb10 <_dtoa_r+0x9c8>
8000caec:	68 1b       	ld.w	r11,r4[0x4]
8000caee:	0e 9c       	mov	r12,r7
8000caf0:	e0 a0 05 fe 	rcall	8000d6ec <_Balloc>
8000caf4:	68 4a       	ld.w	r10,r4[0x10]
8000caf6:	18 95       	mov	r5,r12
8000caf8:	e8 cb ff f4 	sub	r11,r4,-12
8000cafc:	2f ea       	sub	r10,-2
8000cafe:	2f 4c       	sub	r12,-12
8000cb00:	a3 6a       	lsl	r10,0x2
8000cb02:	fe b0 e6 43 	rcall	80009788 <memcpy>
8000cb06:	0a 9b       	mov	r11,r5
8000cb08:	30 1a       	mov	r10,1
8000cb0a:	0e 9c       	mov	r12,r7
8000cb0c:	e0 a0 06 e0 	rcall	8000d8cc <__lshift>
8000cb10:	50 44       	stdsp	sp[0x10],r4
8000cb12:	40 3a       	lddsp	r10,sp[0xc]
8000cb14:	30 19       	mov	r9,1
8000cb16:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000cb1a:	18 94       	mov	r4,r12
8000cb1c:	50 da       	stdsp	sp[0x34],r10
8000cb1e:	40 85       	lddsp	r5,sp[0x20]
8000cb20:	50 99       	stdsp	sp[0x24],r9
8000cb22:	50 26       	stdsp	sp[0x8],r6
8000cb24:	50 e1       	stdsp	sp[0x38],r1
8000cb26:	04 9b       	mov	r11,r2
8000cb28:	06 9c       	mov	r12,r3
8000cb2a:	fe b0 fa 7f 	rcall	8000c028 <quorem>
8000cb2e:	40 4b       	lddsp	r11,sp[0x10]
8000cb30:	f8 c0 ff d0 	sub	r0,r12,-48
8000cb34:	06 9c       	mov	r12,r3
8000cb36:	e0 a0 05 a8 	rcall	8000d686 <__mcmp>
8000cb3a:	08 9a       	mov	r10,r4
8000cb3c:	50 6c       	stdsp	sp[0x18],r12
8000cb3e:	04 9b       	mov	r11,r2
8000cb40:	0e 9c       	mov	r12,r7
8000cb42:	e0 a0 06 5d 	rcall	8000d7fc <__mdiff>
8000cb46:	18 91       	mov	r1,r12
8000cb48:	78 38       	ld.w	r8,r12[0xc]
8000cb4a:	58 08       	cp.w	r8,0
8000cb4c:	c0 30       	breq	8000cb52 <_dtoa_r+0xa0a>
8000cb4e:	30 16       	mov	r6,1
8000cb50:	c0 68       	rjmp	8000cb5c <_dtoa_r+0xa14>
8000cb52:	18 9b       	mov	r11,r12
8000cb54:	06 9c       	mov	r12,r3
8000cb56:	e0 a0 05 98 	rcall	8000d686 <__mcmp>
8000cb5a:	18 96       	mov	r6,r12
8000cb5c:	0e 9c       	mov	r12,r7
8000cb5e:	02 9b       	mov	r11,r1
8000cb60:	e0 a0 05 ac 	rcall	8000d6b8 <_Bfree>
8000cb64:	40 cc       	lddsp	r12,sp[0x30]
8000cb66:	ed ec 10 08 	or	r8,r6,r12
8000cb6a:	c0 d1       	brne	8000cb84 <_dtoa_r+0xa3c>
8000cb6c:	40 db       	lddsp	r11,sp[0x34]
8000cb6e:	58 0b       	cp.w	r11,0
8000cb70:	c0 a1       	brne	8000cb84 <_dtoa_r+0xa3c>
8000cb72:	40 26       	lddsp	r6,sp[0x8]
8000cb74:	e0 40 00 39 	cp.w	r0,57
8000cb78:	c3 00       	breq	8000cbd8 <_dtoa_r+0xa90>
8000cb7a:	40 6a       	lddsp	r10,sp[0x18]
8000cb7c:	58 0a       	cp.w	r10,0
8000cb7e:	e0 89 00 24 	brgt	8000cbc6 <_dtoa_r+0xa7e>
8000cb82:	c2 f8       	rjmp	8000cbe0 <_dtoa_r+0xa98>
8000cb84:	40 69       	lddsp	r9,sp[0x18]
8000cb86:	58 09       	cp.w	r9,0
8000cb88:	c0 85       	brlt	8000cb98 <_dtoa_r+0xa50>
8000cb8a:	12 98       	mov	r8,r9
8000cb8c:	40 cc       	lddsp	r12,sp[0x30]
8000cb8e:	18 48       	or	r8,r12
8000cb90:	c1 d1       	brne	8000cbca <_dtoa_r+0xa82>
8000cb92:	40 db       	lddsp	r11,sp[0x34]
8000cb94:	58 0b       	cp.w	r11,0
8000cb96:	c1 a1       	brne	8000cbca <_dtoa_r+0xa82>
8000cb98:	0c 99       	mov	r9,r6
8000cb9a:	40 26       	lddsp	r6,sp[0x8]
8000cb9c:	58 09       	cp.w	r9,0
8000cb9e:	e0 8a 00 21 	brle	8000cbe0 <_dtoa_r+0xa98>
8000cba2:	06 9b       	mov	r11,r3
8000cba4:	30 1a       	mov	r10,1
8000cba6:	0e 9c       	mov	r12,r7
8000cba8:	e0 a0 06 92 	rcall	8000d8cc <__lshift>
8000cbac:	04 9b       	mov	r11,r2
8000cbae:	18 93       	mov	r3,r12
8000cbb0:	e0 a0 05 6b 	rcall	8000d686 <__mcmp>
8000cbb4:	e0 89 00 06 	brgt	8000cbc0 <_dtoa_r+0xa78>
8000cbb8:	c1 41       	brne	8000cbe0 <_dtoa_r+0xa98>
8000cbba:	ed b0 00 00 	bld	r0,0x0
8000cbbe:	c1 11       	brne	8000cbe0 <_dtoa_r+0xa98>
8000cbc0:	e0 40 00 39 	cp.w	r0,57
8000cbc4:	c0 a0       	breq	8000cbd8 <_dtoa_r+0xa90>
8000cbc6:	2f f0       	sub	r0,-1
8000cbc8:	c0 c8       	rjmp	8000cbe0 <_dtoa_r+0xa98>
8000cbca:	58 06       	cp.w	r6,0
8000cbcc:	e0 8a 00 0c 	brle	8000cbe4 <_dtoa_r+0xa9c>
8000cbd0:	40 26       	lddsp	r6,sp[0x8]
8000cbd2:	e0 40 00 39 	cp.w	r0,57
8000cbd6:	c0 41       	brne	8000cbde <_dtoa_r+0xa96>
8000cbd8:	33 98       	mov	r8,57
8000cbda:	0a c8       	st.b	r5++,r8
8000cbdc:	c6 78       	rjmp	8000ccaa <_dtoa_r+0xb62>
8000cbde:	2f f0       	sub	r0,-1
8000cbe0:	0a c0       	st.b	r5++,r0
8000cbe2:	c7 58       	rjmp	8000cccc <_dtoa_r+0xb84>
8000cbe4:	0a c0       	st.b	r5++,r0
8000cbe6:	40 9a       	lddsp	r10,sp[0x24]
8000cbe8:	40 e9       	lddsp	r9,sp[0x38]
8000cbea:	12 3a       	cp.w	r10,r9
8000cbec:	c4 30       	breq	8000cc72 <_dtoa_r+0xb2a>
8000cbee:	06 9b       	mov	r11,r3
8000cbf0:	30 09       	mov	r9,0
8000cbf2:	30 aa       	mov	r10,10
8000cbf4:	0e 9c       	mov	r12,r7
8000cbf6:	e0 a0 07 37 	rcall	8000da64 <__multadd>
8000cbfa:	40 48       	lddsp	r8,sp[0x10]
8000cbfc:	18 93       	mov	r3,r12
8000cbfe:	08 38       	cp.w	r8,r4
8000cc00:	c0 91       	brne	8000cc12 <_dtoa_r+0xaca>
8000cc02:	10 9b       	mov	r11,r8
8000cc04:	30 09       	mov	r9,0
8000cc06:	30 aa       	mov	r10,10
8000cc08:	0e 9c       	mov	r12,r7
8000cc0a:	e0 a0 07 2d 	rcall	8000da64 <__multadd>
8000cc0e:	50 4c       	stdsp	sp[0x10],r12
8000cc10:	c0 e8       	rjmp	8000cc2c <_dtoa_r+0xae4>
8000cc12:	40 4b       	lddsp	r11,sp[0x10]
8000cc14:	30 09       	mov	r9,0
8000cc16:	30 aa       	mov	r10,10
8000cc18:	0e 9c       	mov	r12,r7
8000cc1a:	e0 a0 07 25 	rcall	8000da64 <__multadd>
8000cc1e:	08 9b       	mov	r11,r4
8000cc20:	50 4c       	stdsp	sp[0x10],r12
8000cc22:	30 09       	mov	r9,0
8000cc24:	30 aa       	mov	r10,10
8000cc26:	0e 9c       	mov	r12,r7
8000cc28:	e0 a0 07 1e 	rcall	8000da64 <__multadd>
8000cc2c:	18 94       	mov	r4,r12
8000cc2e:	40 9c       	lddsp	r12,sp[0x24]
8000cc30:	2f fc       	sub	r12,-1
8000cc32:	50 9c       	stdsp	sp[0x24],r12
8000cc34:	c7 9b       	rjmp	8000cb26 <_dtoa_r+0x9de>
8000cc36:	30 18       	mov	r8,1
8000cc38:	06 90       	mov	r0,r3
8000cc3a:	40 85       	lddsp	r5,sp[0x20]
8000cc3c:	08 93       	mov	r3,r4
8000cc3e:	0c 94       	mov	r4,r6
8000cc40:	10 96       	mov	r6,r8
8000cc42:	04 9b       	mov	r11,r2
8000cc44:	00 9c       	mov	r12,r0
8000cc46:	fe b0 f9 f1 	rcall	8000c028 <quorem>
8000cc4a:	2d 0c       	sub	r12,-48
8000cc4c:	0a cc       	st.b	r5++,r12
8000cc4e:	02 36       	cp.w	r6,r1
8000cc50:	c0 a4       	brge	8000cc64 <_dtoa_r+0xb1c>
8000cc52:	00 9b       	mov	r11,r0
8000cc54:	30 09       	mov	r9,0
8000cc56:	30 aa       	mov	r10,10
8000cc58:	0e 9c       	mov	r12,r7
8000cc5a:	2f f6       	sub	r6,-1
8000cc5c:	e0 a0 07 04 	rcall	8000da64 <__multadd>
8000cc60:	18 90       	mov	r0,r12
8000cc62:	cf 0b       	rjmp	8000cc42 <_dtoa_r+0xafa>
8000cc64:	08 96       	mov	r6,r4
8000cc66:	30 0b       	mov	r11,0
8000cc68:	06 94       	mov	r4,r3
8000cc6a:	50 4b       	stdsp	sp[0x10],r11
8000cc6c:	00 93       	mov	r3,r0
8000cc6e:	18 90       	mov	r0,r12
8000cc70:	c0 28       	rjmp	8000cc74 <_dtoa_r+0xb2c>
8000cc72:	40 26       	lddsp	r6,sp[0x8]
8000cc74:	06 9b       	mov	r11,r3
8000cc76:	30 1a       	mov	r10,1
8000cc78:	0e 9c       	mov	r12,r7
8000cc7a:	e0 a0 06 29 	rcall	8000d8cc <__lshift>
8000cc7e:	04 9b       	mov	r11,r2
8000cc80:	18 93       	mov	r3,r12
8000cc82:	e0 a0 05 02 	rcall	8000d686 <__mcmp>
8000cc86:	e0 89 00 12 	brgt	8000ccaa <_dtoa_r+0xb62>
8000cc8a:	c1 b1       	brne	8000ccc0 <_dtoa_r+0xb78>
8000cc8c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000cc90:	c0 d1       	brne	8000ccaa <_dtoa_r+0xb62>
8000cc92:	c1 78       	rjmp	8000ccc0 <_dtoa_r+0xb78>
8000cc94:	40 89       	lddsp	r9,sp[0x20]
8000cc96:	12 38       	cp.w	r8,r9
8000cc98:	c0 30       	breq	8000cc9e <_dtoa_r+0xb56>
8000cc9a:	10 95       	mov	r5,r8
8000cc9c:	c0 88       	rjmp	8000ccac <_dtoa_r+0xb64>
8000cc9e:	2f f6       	sub	r6,-1
8000cca0:	50 66       	stdsp	sp[0x18],r6
8000cca2:	33 18       	mov	r8,49
8000cca4:	40 8c       	lddsp	r12,sp[0x20]
8000cca6:	b8 88       	st.b	r12[0x0],r8
8000cca8:	c1 38       	rjmp	8000ccce <_dtoa_r+0xb86>
8000ccaa:	33 9a       	mov	r10,57
8000ccac:	0a 98       	mov	r8,r5
8000ccae:	11 79       	ld.ub	r9,--r8
8000ccb0:	f4 09 18 00 	cp.b	r9,r10
8000ccb4:	cf 00       	breq	8000cc94 <_dtoa_r+0xb4c>
8000ccb6:	2f f9       	sub	r9,-1
8000ccb8:	b0 89       	st.b	r8[0x0],r9
8000ccba:	c0 98       	rjmp	8000cccc <_dtoa_r+0xb84>
8000ccbc:	10 95       	mov	r5,r8
8000ccbe:	c0 28       	rjmp	8000ccc2 <_dtoa_r+0xb7a>
8000ccc0:	33 09       	mov	r9,48
8000ccc2:	0a 98       	mov	r8,r5
8000ccc4:	11 7a       	ld.ub	r10,--r8
8000ccc6:	f2 0a 18 00 	cp.b	r10,r9
8000ccca:	cf 90       	breq	8000ccbc <_dtoa_r+0xb74>
8000cccc:	50 66       	stdsp	sp[0x18],r6
8000ccce:	04 9b       	mov	r11,r2
8000ccd0:	0e 9c       	mov	r12,r7
8000ccd2:	e0 a0 04 f3 	rcall	8000d6b8 <_Bfree>
8000ccd6:	58 04       	cp.w	r4,0
8000ccd8:	c1 20       	breq	8000ccfc <_dtoa_r+0xbb4>
8000ccda:	40 4b       	lddsp	r11,sp[0x10]
8000ccdc:	08 3b       	cp.w	r11,r4
8000ccde:	5f 19       	srne	r9
8000cce0:	58 0b       	cp.w	r11,0
8000cce2:	5f 18       	srne	r8
8000cce4:	f3 e8 00 08 	and	r8,r9,r8
8000cce8:	c0 40       	breq	8000ccf0 <_dtoa_r+0xba8>
8000ccea:	0e 9c       	mov	r12,r7
8000ccec:	e0 a0 04 e6 	rcall	8000d6b8 <_Bfree>
8000ccf0:	08 9b       	mov	r11,r4
8000ccf2:	0e 9c       	mov	r12,r7
8000ccf4:	e0 a0 04 e2 	rcall	8000d6b8 <_Bfree>
8000ccf8:	c0 28       	rjmp	8000ccfc <_dtoa_r+0xbb4>
8000ccfa:	50 66       	stdsp	sp[0x18],r6
8000ccfc:	0e 9c       	mov	r12,r7
8000ccfe:	06 9b       	mov	r11,r3
8000cd00:	e0 a0 04 dc 	rcall	8000d6b8 <_Bfree>
8000cd04:	30 08       	mov	r8,0
8000cd06:	aa 88       	st.b	r5[0x0],r8
8000cd08:	40 68       	lddsp	r8,sp[0x18]
8000cd0a:	41 5a       	lddsp	r10,sp[0x54]
8000cd0c:	2f f8       	sub	r8,-1
8000cd0e:	41 29       	lddsp	r9,sp[0x48]
8000cd10:	95 08       	st.w	r10[0x0],r8
8000cd12:	40 8c       	lddsp	r12,sp[0x20]
8000cd14:	58 09       	cp.w	r9,0
8000cd16:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000cd1a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000cd1e:	2e 6d       	sub	sp,-104
8000cd20:	d8 32       	popm	r0-r7,pc
8000cd22:	d7 03       	nop

8000cd24 <__errno>:
8000cd24:	e0 68 0a 30 	mov	r8,2608
8000cd28:	70 0c       	ld.w	r12,r8[0x0]
8000cd2a:	2f 4c       	sub	r12,-12
8000cd2c:	5e fc       	retal	r12
8000cd2e:	d7 03       	nop

8000cd30 <_fflush_r>:
8000cd30:	d4 21       	pushm	r4-r7,lr
8000cd32:	16 97       	mov	r7,r11
8000cd34:	18 96       	mov	r6,r12
8000cd36:	76 48       	ld.w	r8,r11[0x10]
8000cd38:	58 08       	cp.w	r8,0
8000cd3a:	c7 f0       	breq	8000ce38 <_fflush_r+0x108>
8000cd3c:	58 0c       	cp.w	r12,0
8000cd3e:	c0 50       	breq	8000cd48 <_fflush_r+0x18>
8000cd40:	78 68       	ld.w	r8,r12[0x18]
8000cd42:	58 08       	cp.w	r8,0
8000cd44:	c0 21       	brne	8000cd48 <_fflush_r+0x18>
8000cd46:	cc dc       	rcall	8000cee0 <__sinit>
8000cd48:	fe c8 d5 a0 	sub	r8,pc,-10848
8000cd4c:	10 37       	cp.w	r7,r8
8000cd4e:	c0 31       	brne	8000cd54 <_fflush_r+0x24>
8000cd50:	6c 07       	ld.w	r7,r6[0x0]
8000cd52:	c0 c8       	rjmp	8000cd6a <_fflush_r+0x3a>
8000cd54:	fe c8 d5 8c 	sub	r8,pc,-10868
8000cd58:	10 37       	cp.w	r7,r8
8000cd5a:	c0 31       	brne	8000cd60 <_fflush_r+0x30>
8000cd5c:	6c 17       	ld.w	r7,r6[0x4]
8000cd5e:	c0 68       	rjmp	8000cd6a <_fflush_r+0x3a>
8000cd60:	fe c8 d5 78 	sub	r8,pc,-10888
8000cd64:	10 37       	cp.w	r7,r8
8000cd66:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000cd6a:	8e 6a       	ld.sh	r10,r7[0xc]
8000cd6c:	14 98       	mov	r8,r10
8000cd6e:	ed ba 00 03 	bld	r10,0x3
8000cd72:	c4 20       	breq	8000cdf6 <_fflush_r+0xc6>
8000cd74:	ab ba       	sbr	r10,0xb
8000cd76:	ae 6a       	st.h	r7[0xc],r10
8000cd78:	6e 18       	ld.w	r8,r7[0x4]
8000cd7a:	58 08       	cp.w	r8,0
8000cd7c:	e0 89 00 06 	brgt	8000cd88 <_fflush_r+0x58>
8000cd80:	6f 08       	ld.w	r8,r7[0x40]
8000cd82:	58 08       	cp.w	r8,0
8000cd84:	e0 8a 00 5a 	brle	8000ce38 <_fflush_r+0x108>
8000cd88:	6e b8       	ld.w	r8,r7[0x2c]
8000cd8a:	58 08       	cp.w	r8,0
8000cd8c:	c5 60       	breq	8000ce38 <_fflush_r+0x108>
8000cd8e:	e2 1a 10 00 	andl	r10,0x1000,COH
8000cd92:	c0 30       	breq	8000cd98 <_fflush_r+0x68>
8000cd94:	6f 55       	ld.w	r5,r7[0x54]
8000cd96:	c0 f8       	rjmp	8000cdb4 <_fflush_r+0x84>
8000cd98:	30 19       	mov	r9,1
8000cd9a:	6e 8b       	ld.w	r11,r7[0x20]
8000cd9c:	0c 9c       	mov	r12,r6
8000cd9e:	5d 18       	icall	r8
8000cda0:	18 95       	mov	r5,r12
8000cda2:	5b fc       	cp.w	r12,-1
8000cda4:	c0 81       	brne	8000cdb4 <_fflush_r+0x84>
8000cda6:	6c 38       	ld.w	r8,r6[0xc]
8000cda8:	59 d8       	cp.w	r8,29
8000cdaa:	c4 70       	breq	8000ce38 <_fflush_r+0x108>
8000cdac:	8e 68       	ld.sh	r8,r7[0xc]
8000cdae:	a7 a8       	sbr	r8,0x6
8000cdb0:	ae 68       	st.h	r7[0xc],r8
8000cdb2:	d8 22       	popm	r4-r7,pc
8000cdb4:	8e 68       	ld.sh	r8,r7[0xc]
8000cdb6:	ed b8 00 02 	bld	r8,0x2
8000cdba:	c0 91       	brne	8000cdcc <_fflush_r+0x9c>
8000cdbc:	6e 18       	ld.w	r8,r7[0x4]
8000cdbe:	10 15       	sub	r5,r8
8000cdc0:	6e d8       	ld.w	r8,r7[0x34]
8000cdc2:	58 08       	cp.w	r8,0
8000cdc4:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000cdc8:	eb d8 e1 15 	subne	r5,r5,r8
8000cdcc:	6e b8       	ld.w	r8,r7[0x2c]
8000cdce:	0c 9c       	mov	r12,r6
8000cdd0:	30 09       	mov	r9,0
8000cdd2:	0a 9a       	mov	r10,r5
8000cdd4:	6e 8b       	ld.w	r11,r7[0x20]
8000cdd6:	5d 18       	icall	r8
8000cdd8:	8e 68       	ld.sh	r8,r7[0xc]
8000cdda:	0a 3c       	cp.w	r12,r5
8000cddc:	c2 61       	brne	8000ce28 <_fflush_r+0xf8>
8000cdde:	ab d8       	cbr	r8,0xb
8000cde0:	30 0c       	mov	r12,0
8000cde2:	6e 49       	ld.w	r9,r7[0x10]
8000cde4:	ae 68       	st.h	r7[0xc],r8
8000cde6:	8f 1c       	st.w	r7[0x4],r12
8000cde8:	8f 09       	st.w	r7[0x0],r9
8000cdea:	ed b8 00 0c 	bld	r8,0xc
8000cdee:	c2 51       	brne	8000ce38 <_fflush_r+0x108>
8000cdf0:	ef 45 00 54 	st.w	r7[84],r5
8000cdf4:	d8 22       	popm	r4-r7,pc
8000cdf6:	6e 45       	ld.w	r5,r7[0x10]
8000cdf8:	58 05       	cp.w	r5,0
8000cdfa:	c1 f0       	breq	8000ce38 <_fflush_r+0x108>
8000cdfc:	6e 04       	ld.w	r4,r7[0x0]
8000cdfe:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000ce02:	8f 05       	st.w	r7[0x0],r5
8000ce04:	f9 b8 01 00 	movne	r8,0
8000ce08:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ce0c:	0a 14       	sub	r4,r5
8000ce0e:	8f 28       	st.w	r7[0x8],r8
8000ce10:	c1 18       	rjmp	8000ce32 <_fflush_r+0x102>
8000ce12:	08 99       	mov	r9,r4
8000ce14:	0a 9a       	mov	r10,r5
8000ce16:	6e a8       	ld.w	r8,r7[0x28]
8000ce18:	6e 8b       	ld.w	r11,r7[0x20]
8000ce1a:	0c 9c       	mov	r12,r6
8000ce1c:	5d 18       	icall	r8
8000ce1e:	18 14       	sub	r4,r12
8000ce20:	58 0c       	cp.w	r12,0
8000ce22:	e0 89 00 07 	brgt	8000ce30 <_fflush_r+0x100>
8000ce26:	8e 68       	ld.sh	r8,r7[0xc]
8000ce28:	a7 a8       	sbr	r8,0x6
8000ce2a:	3f fc       	mov	r12,-1
8000ce2c:	ae 68       	st.h	r7[0xc],r8
8000ce2e:	d8 22       	popm	r4-r7,pc
8000ce30:	18 05       	add	r5,r12
8000ce32:	58 04       	cp.w	r4,0
8000ce34:	fe 99 ff ef 	brgt	8000ce12 <_fflush_r+0xe2>
8000ce38:	d8 2a       	popm	r4-r7,pc,r12=0
8000ce3a:	d7 03       	nop

8000ce3c <__sfp_lock_acquire>:
8000ce3c:	5e fc       	retal	r12

8000ce3e <__sfp_lock_release>:
8000ce3e:	5e fc       	retal	r12

8000ce40 <_cleanup_r>:
8000ce40:	d4 01       	pushm	lr
8000ce42:	fe cb f0 c6 	sub	r11,pc,-3898
8000ce46:	e0 a0 02 f7 	rcall	8000d434 <_fwalk>
8000ce4a:	d8 02       	popm	pc

8000ce4c <__sfmoreglue>:
8000ce4c:	d4 21       	pushm	r4-r7,lr
8000ce4e:	16 95       	mov	r5,r11
8000ce50:	f6 06 10 5c 	mul	r6,r11,92
8000ce54:	ec cb ff f4 	sub	r11,r6,-12
8000ce58:	fe b0 e2 7c 	rcall	80009350 <_malloc_r>
8000ce5c:	18 97       	mov	r7,r12
8000ce5e:	c0 90       	breq	8000ce70 <__sfmoreglue+0x24>
8000ce60:	99 15       	st.w	r12[0x4],r5
8000ce62:	30 0b       	mov	r11,0
8000ce64:	2f 4c       	sub	r12,-12
8000ce66:	0c 9a       	mov	r10,r6
8000ce68:	8f 2c       	st.w	r7[0x8],r12
8000ce6a:	8f 0b       	st.w	r7[0x0],r11
8000ce6c:	fe b0 e5 32 	rcall	800098d0 <memset>
8000ce70:	0e 9c       	mov	r12,r7
8000ce72:	d8 22       	popm	r4-r7,pc

8000ce74 <__sfp>:
8000ce74:	d4 21       	pushm	r4-r7,lr
8000ce76:	fe c8 d6 6a 	sub	r8,pc,-10646
8000ce7a:	18 96       	mov	r6,r12
8000ce7c:	70 07       	ld.w	r7,r8[0x0]
8000ce7e:	6e 68       	ld.w	r8,r7[0x18]
8000ce80:	58 08       	cp.w	r8,0
8000ce82:	c0 31       	brne	8000ce88 <__sfp+0x14>
8000ce84:	0e 9c       	mov	r12,r7
8000ce86:	c2 dc       	rcall	8000cee0 <__sinit>
8000ce88:	ee c7 ff 28 	sub	r7,r7,-216
8000ce8c:	30 05       	mov	r5,0
8000ce8e:	6e 2c       	ld.w	r12,r7[0x8]
8000ce90:	6e 18       	ld.w	r8,r7[0x4]
8000ce92:	c0 68       	rjmp	8000ce9e <__sfp+0x2a>
8000ce94:	98 69       	ld.sh	r9,r12[0xc]
8000ce96:	ea 09 19 00 	cp.h	r9,r5
8000ce9a:	c1 10       	breq	8000cebc <__sfp+0x48>
8000ce9c:	2a 4c       	sub	r12,-92
8000ce9e:	20 18       	sub	r8,1
8000cea0:	cf a7       	brpl	8000ce94 <__sfp+0x20>
8000cea2:	6e 08       	ld.w	r8,r7[0x0]
8000cea4:	58 08       	cp.w	r8,0
8000cea6:	c0 61       	brne	8000ceb2 <__sfp+0x3e>
8000cea8:	30 4b       	mov	r11,4
8000ceaa:	0c 9c       	mov	r12,r6
8000ceac:	cd 0f       	rcall	8000ce4c <__sfmoreglue>
8000ceae:	8f 0c       	st.w	r7[0x0],r12
8000ceb0:	c0 30       	breq	8000ceb6 <__sfp+0x42>
8000ceb2:	6e 07       	ld.w	r7,r7[0x0]
8000ceb4:	ce db       	rjmp	8000ce8e <__sfp+0x1a>
8000ceb6:	30 c8       	mov	r8,12
8000ceb8:	8d 38       	st.w	r6[0xc],r8
8000ceba:	d8 22       	popm	r4-r7,pc
8000cebc:	30 08       	mov	r8,0
8000cebe:	f9 48 00 4c 	st.w	r12[76],r8
8000cec2:	99 08       	st.w	r12[0x0],r8
8000cec4:	99 28       	st.w	r12[0x8],r8
8000cec6:	99 18       	st.w	r12[0x4],r8
8000cec8:	99 48       	st.w	r12[0x10],r8
8000ceca:	99 58       	st.w	r12[0x14],r8
8000cecc:	99 68       	st.w	r12[0x18],r8
8000cece:	99 d8       	st.w	r12[0x34],r8
8000ced0:	99 e8       	st.w	r12[0x38],r8
8000ced2:	f9 48 00 48 	st.w	r12[72],r8
8000ced6:	3f f8       	mov	r8,-1
8000ced8:	b8 78       	st.h	r12[0xe],r8
8000ceda:	30 18       	mov	r8,1
8000cedc:	b8 68       	st.h	r12[0xc],r8
8000cede:	d8 22       	popm	r4-r7,pc

8000cee0 <__sinit>:
8000cee0:	d4 21       	pushm	r4-r7,lr
8000cee2:	18 96       	mov	r6,r12
8000cee4:	78 67       	ld.w	r7,r12[0x18]
8000cee6:	58 07       	cp.w	r7,0
8000cee8:	c4 91       	brne	8000cf7a <__sinit+0x9a>
8000ceea:	fe c8 00 aa 	sub	r8,pc,170
8000ceee:	30 15       	mov	r5,1
8000cef0:	99 a8       	st.w	r12[0x28],r8
8000cef2:	f9 47 00 d8 	st.w	r12[216],r7
8000cef6:	f9 47 00 dc 	st.w	r12[220],r7
8000cefa:	f9 47 00 e0 	st.w	r12[224],r7
8000cefe:	99 65       	st.w	r12[0x18],r5
8000cf00:	cb af       	rcall	8000ce74 <__sfp>
8000cf02:	8d 0c       	st.w	r6[0x0],r12
8000cf04:	0c 9c       	mov	r12,r6
8000cf06:	cb 7f       	rcall	8000ce74 <__sfp>
8000cf08:	8d 1c       	st.w	r6[0x4],r12
8000cf0a:	0c 9c       	mov	r12,r6
8000cf0c:	cb 4f       	rcall	8000ce74 <__sfp>
8000cf0e:	6c 09       	ld.w	r9,r6[0x0]
8000cf10:	30 48       	mov	r8,4
8000cf12:	93 07       	st.w	r9[0x0],r7
8000cf14:	b2 68       	st.h	r9[0xc],r8
8000cf16:	93 17       	st.w	r9[0x4],r7
8000cf18:	93 27       	st.w	r9[0x8],r7
8000cf1a:	6c 18       	ld.w	r8,r6[0x4]
8000cf1c:	b2 77       	st.h	r9[0xe],r7
8000cf1e:	93 47       	st.w	r9[0x10],r7
8000cf20:	93 57       	st.w	r9[0x14],r7
8000cf22:	93 67       	st.w	r9[0x18],r7
8000cf24:	93 89       	st.w	r9[0x20],r9
8000cf26:	91 07       	st.w	r8[0x0],r7
8000cf28:	91 17       	st.w	r8[0x4],r7
8000cf2a:	91 27       	st.w	r8[0x8],r7
8000cf2c:	fe ce f3 24 	sub	lr,pc,-3292
8000cf30:	fe cb f3 54 	sub	r11,pc,-3244
8000cf34:	93 9e       	st.w	r9[0x24],lr
8000cf36:	93 ab       	st.w	r9[0x28],r11
8000cf38:	fe ca f3 7c 	sub	r10,pc,-3204
8000cf3c:	fe c4 f3 88 	sub	r4,pc,-3192
8000cf40:	93 ba       	st.w	r9[0x2c],r10
8000cf42:	93 c4       	st.w	r9[0x30],r4
8000cf44:	30 99       	mov	r9,9
8000cf46:	b0 69       	st.h	r8[0xc],r9
8000cf48:	b0 75       	st.h	r8[0xe],r5
8000cf4a:	91 c4       	st.w	r8[0x30],r4
8000cf4c:	91 47       	st.w	r8[0x10],r7
8000cf4e:	91 57       	st.w	r8[0x14],r7
8000cf50:	91 67       	st.w	r8[0x18],r7
8000cf52:	91 88       	st.w	r8[0x20],r8
8000cf54:	91 9e       	st.w	r8[0x24],lr
8000cf56:	91 ab       	st.w	r8[0x28],r11
8000cf58:	91 ba       	st.w	r8[0x2c],r10
8000cf5a:	8d 2c       	st.w	r6[0x8],r12
8000cf5c:	31 28       	mov	r8,18
8000cf5e:	99 07       	st.w	r12[0x0],r7
8000cf60:	b8 68       	st.h	r12[0xc],r8
8000cf62:	99 17       	st.w	r12[0x4],r7
8000cf64:	99 27       	st.w	r12[0x8],r7
8000cf66:	30 28       	mov	r8,2
8000cf68:	b8 78       	st.h	r12[0xe],r8
8000cf6a:	99 c4       	st.w	r12[0x30],r4
8000cf6c:	99 67       	st.w	r12[0x18],r7
8000cf6e:	99 9e       	st.w	r12[0x24],lr
8000cf70:	99 ab       	st.w	r12[0x28],r11
8000cf72:	99 ba       	st.w	r12[0x2c],r10
8000cf74:	99 47       	st.w	r12[0x10],r7
8000cf76:	99 57       	st.w	r12[0x14],r7
8000cf78:	99 8c       	st.w	r12[0x20],r12
8000cf7a:	d8 22       	popm	r4-r7,pc

8000cf7c <_malloc_trim_r>:
8000cf7c:	d4 21       	pushm	r4-r7,lr
8000cf7e:	16 95       	mov	r5,r11
8000cf80:	18 97       	mov	r7,r12
8000cf82:	fe b0 cf 67 	rcall	80006e50 <__malloc_lock>
8000cf86:	e0 64 05 30 	mov	r4,1328
8000cf8a:	68 28       	ld.w	r8,r4[0x8]
8000cf8c:	70 16       	ld.w	r6,r8[0x4]
8000cf8e:	e0 16 ff fc 	andl	r6,0xfffc
8000cf92:	ec c8 ff 91 	sub	r8,r6,-111
8000cf96:	f0 05 01 05 	sub	r5,r8,r5
8000cf9a:	e0 15 ff 80 	andl	r5,0xff80
8000cf9e:	ea c5 00 80 	sub	r5,r5,128
8000cfa2:	e0 45 00 7f 	cp.w	r5,127
8000cfa6:	e0 8a 00 25 	brle	8000cff0 <_malloc_trim_r+0x74>
8000cfaa:	30 0b       	mov	r11,0
8000cfac:	0e 9c       	mov	r12,r7
8000cfae:	fe b0 e5 f9 	rcall	80009ba0 <_sbrk_r>
8000cfb2:	68 28       	ld.w	r8,r4[0x8]
8000cfb4:	0c 08       	add	r8,r6
8000cfb6:	10 3c       	cp.w	r12,r8
8000cfb8:	c1 c1       	brne	8000cff0 <_malloc_trim_r+0x74>
8000cfba:	ea 0b 11 00 	rsub	r11,r5,0
8000cfbe:	0e 9c       	mov	r12,r7
8000cfc0:	fe b0 e5 f0 	rcall	80009ba0 <_sbrk_r>
8000cfc4:	5b fc       	cp.w	r12,-1
8000cfc6:	c1 91       	brne	8000cff8 <_malloc_trim_r+0x7c>
8000cfc8:	30 0b       	mov	r11,0
8000cfca:	0e 9c       	mov	r12,r7
8000cfcc:	fe b0 e5 ea 	rcall	80009ba0 <_sbrk_r>
8000cfd0:	68 28       	ld.w	r8,r4[0x8]
8000cfd2:	f8 08 01 09 	sub	r9,r12,r8
8000cfd6:	58 f9       	cp.w	r9,15
8000cfd8:	e0 8a 00 0c 	brle	8000cff0 <_malloc_trim_r+0x74>
8000cfdc:	a1 a9       	sbr	r9,0x0
8000cfde:	91 19       	st.w	r8[0x4],r9
8000cfe0:	e0 68 09 3c 	mov	r8,2364
8000cfe4:	70 09       	ld.w	r9,r8[0x0]
8000cfe6:	e0 68 0d 48 	mov	r8,3400
8000cfea:	f8 09 01 09 	sub	r9,r12,r9
8000cfee:	91 09       	st.w	r8[0x0],r9
8000cff0:	0e 9c       	mov	r12,r7
8000cff2:	fe b0 cf 3d 	rcall	80006e6c <__malloc_unlock>
8000cff6:	d8 2a       	popm	r4-r7,pc,r12=0
8000cff8:	68 28       	ld.w	r8,r4[0x8]
8000cffa:	0a 16       	sub	r6,r5
8000cffc:	a1 a6       	sbr	r6,0x0
8000cffe:	91 16       	st.w	r8[0x4],r6
8000d000:	e0 68 0d 48 	mov	r8,3400
8000d004:	70 09       	ld.w	r9,r8[0x0]
8000d006:	0a 19       	sub	r9,r5
8000d008:	0e 9c       	mov	r12,r7
8000d00a:	91 09       	st.w	r8[0x0],r9
8000d00c:	fe b0 cf 30 	rcall	80006e6c <__malloc_unlock>
8000d010:	da 2a       	popm	r4-r7,pc,r12=1
8000d012:	d7 03       	nop

8000d014 <_free_r>:
8000d014:	d4 21       	pushm	r4-r7,lr
8000d016:	16 96       	mov	r6,r11
8000d018:	18 97       	mov	r7,r12
8000d01a:	58 0b       	cp.w	r11,0
8000d01c:	e0 80 00 c0 	breq	8000d19c <_free_r+0x188>
8000d020:	fe b0 cf 18 	rcall	80006e50 <__malloc_lock>
8000d024:	20 86       	sub	r6,8
8000d026:	e0 6a 05 30 	mov	r10,1328
8000d02a:	6c 18       	ld.w	r8,r6[0x4]
8000d02c:	74 2e       	ld.w	lr,r10[0x8]
8000d02e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000d032:	a1 c8       	cbr	r8,0x0
8000d034:	ec 08 00 09 	add	r9,r6,r8
8000d038:	72 1b       	ld.w	r11,r9[0x4]
8000d03a:	e0 1b ff fc 	andl	r11,0xfffc
8000d03e:	1c 39       	cp.w	r9,lr
8000d040:	c1 e1       	brne	8000d07c <_free_r+0x68>
8000d042:	f6 08 00 08 	add	r8,r11,r8
8000d046:	58 0c       	cp.w	r12,0
8000d048:	c0 81       	brne	8000d058 <_free_r+0x44>
8000d04a:	6c 09       	ld.w	r9,r6[0x0]
8000d04c:	12 16       	sub	r6,r9
8000d04e:	12 08       	add	r8,r9
8000d050:	6c 3b       	ld.w	r11,r6[0xc]
8000d052:	6c 29       	ld.w	r9,r6[0x8]
8000d054:	97 29       	st.w	r11[0x8],r9
8000d056:	93 3b       	st.w	r9[0xc],r11
8000d058:	10 99       	mov	r9,r8
8000d05a:	95 26       	st.w	r10[0x8],r6
8000d05c:	a1 a9       	sbr	r9,0x0
8000d05e:	8d 19       	st.w	r6[0x4],r9
8000d060:	e0 69 09 38 	mov	r9,2360
8000d064:	72 09       	ld.w	r9,r9[0x0]
8000d066:	12 38       	cp.w	r8,r9
8000d068:	c0 63       	brcs	8000d074 <_free_r+0x60>
8000d06a:	e0 68 0d 44 	mov	r8,3396
8000d06e:	0e 9c       	mov	r12,r7
8000d070:	70 0b       	ld.w	r11,r8[0x0]
8000d072:	c8 5f       	rcall	8000cf7c <_malloc_trim_r>
8000d074:	0e 9c       	mov	r12,r7
8000d076:	fe b0 ce fb 	rcall	80006e6c <__malloc_unlock>
8000d07a:	d8 22       	popm	r4-r7,pc
8000d07c:	93 1b       	st.w	r9[0x4],r11
8000d07e:	58 0c       	cp.w	r12,0
8000d080:	c0 30       	breq	8000d086 <_free_r+0x72>
8000d082:	30 0c       	mov	r12,0
8000d084:	c1 08       	rjmp	8000d0a4 <_free_r+0x90>
8000d086:	6c 0e       	ld.w	lr,r6[0x0]
8000d088:	f4 c5 ff f8 	sub	r5,r10,-8
8000d08c:	1c 16       	sub	r6,lr
8000d08e:	1c 08       	add	r8,lr
8000d090:	6c 2e       	ld.w	lr,r6[0x8]
8000d092:	0a 3e       	cp.w	lr,r5
8000d094:	f9 bc 00 01 	moveq	r12,1
8000d098:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000d09c:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000d0a0:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000d0a4:	f2 0b 00 0e 	add	lr,r9,r11
8000d0a8:	7c 1e       	ld.w	lr,lr[0x4]
8000d0aa:	ed be 00 00 	bld	lr,0x0
8000d0ae:	c1 40       	breq	8000d0d6 <_free_r+0xc2>
8000d0b0:	16 08       	add	r8,r11
8000d0b2:	58 0c       	cp.w	r12,0
8000d0b4:	c0 d1       	brne	8000d0ce <_free_r+0xba>
8000d0b6:	e0 6e 05 30 	mov	lr,1328
8000d0ba:	72 2b       	ld.w	r11,r9[0x8]
8000d0bc:	2f 8e       	sub	lr,-8
8000d0be:	1c 3b       	cp.w	r11,lr
8000d0c0:	c0 71       	brne	8000d0ce <_free_r+0xba>
8000d0c2:	97 36       	st.w	r11[0xc],r6
8000d0c4:	97 26       	st.w	r11[0x8],r6
8000d0c6:	8d 2b       	st.w	r6[0x8],r11
8000d0c8:	8d 3b       	st.w	r6[0xc],r11
8000d0ca:	30 1c       	mov	r12,1
8000d0cc:	c0 58       	rjmp	8000d0d6 <_free_r+0xc2>
8000d0ce:	72 2b       	ld.w	r11,r9[0x8]
8000d0d0:	72 39       	ld.w	r9,r9[0xc]
8000d0d2:	93 2b       	st.w	r9[0x8],r11
8000d0d4:	97 39       	st.w	r11[0xc],r9
8000d0d6:	10 99       	mov	r9,r8
8000d0d8:	ec 08 09 08 	st.w	r6[r8],r8
8000d0dc:	a1 a9       	sbr	r9,0x0
8000d0de:	8d 19       	st.w	r6[0x4],r9
8000d0e0:	58 0c       	cp.w	r12,0
8000d0e2:	c5 a1       	brne	8000d196 <_free_r+0x182>
8000d0e4:	e0 48 01 ff 	cp.w	r8,511
8000d0e8:	e0 8b 00 13 	brhi	8000d10e <_free_r+0xfa>
8000d0ec:	a3 98       	lsr	r8,0x3
8000d0ee:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000d0f2:	72 2b       	ld.w	r11,r9[0x8]
8000d0f4:	8d 39       	st.w	r6[0xc],r9
8000d0f6:	8d 2b       	st.w	r6[0x8],r11
8000d0f8:	97 36       	st.w	r11[0xc],r6
8000d0fa:	93 26       	st.w	r9[0x8],r6
8000d0fc:	a3 48       	asr	r8,0x2
8000d0fe:	74 19       	ld.w	r9,r10[0x4]
8000d100:	30 1b       	mov	r11,1
8000d102:	f6 08 09 48 	lsl	r8,r11,r8
8000d106:	f3 e8 10 08 	or	r8,r9,r8
8000d10a:	95 18       	st.w	r10[0x4],r8
8000d10c:	c4 58       	rjmp	8000d196 <_free_r+0x182>
8000d10e:	f0 0b 16 09 	lsr	r11,r8,0x9
8000d112:	58 4b       	cp.w	r11,4
8000d114:	e0 8b 00 06 	brhi	8000d120 <_free_r+0x10c>
8000d118:	f0 0b 16 06 	lsr	r11,r8,0x6
8000d11c:	2c 8b       	sub	r11,-56
8000d11e:	c2 08       	rjmp	8000d15e <_free_r+0x14a>
8000d120:	59 4b       	cp.w	r11,20
8000d122:	e0 8b 00 04 	brhi	8000d12a <_free_r+0x116>
8000d126:	2a 5b       	sub	r11,-91
8000d128:	c1 b8       	rjmp	8000d15e <_free_r+0x14a>
8000d12a:	e0 4b 00 54 	cp.w	r11,84
8000d12e:	e0 8b 00 06 	brhi	8000d13a <_free_r+0x126>
8000d132:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000d136:	29 2b       	sub	r11,-110
8000d138:	c1 38       	rjmp	8000d15e <_free_r+0x14a>
8000d13a:	e0 4b 01 54 	cp.w	r11,340
8000d13e:	e0 8b 00 06 	brhi	8000d14a <_free_r+0x136>
8000d142:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000d146:	28 9b       	sub	r11,-119
8000d148:	c0 b8       	rjmp	8000d15e <_free_r+0x14a>
8000d14a:	e0 4b 05 54 	cp.w	r11,1364
8000d14e:	e0 88 00 05 	brls	8000d158 <_free_r+0x144>
8000d152:	37 eb       	mov	r11,126
8000d154:	c0 58       	rjmp	8000d15e <_free_r+0x14a>
8000d156:	d7 03       	nop
8000d158:	f0 0b 16 12 	lsr	r11,r8,0x12
8000d15c:	28 4b       	sub	r11,-124
8000d15e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000d162:	78 29       	ld.w	r9,r12[0x8]
8000d164:	18 39       	cp.w	r9,r12
8000d166:	c0 e1       	brne	8000d182 <_free_r+0x16e>
8000d168:	74 18       	ld.w	r8,r10[0x4]
8000d16a:	a3 4b       	asr	r11,0x2
8000d16c:	30 1c       	mov	r12,1
8000d16e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000d172:	f1 eb 10 0b 	or	r11,r8,r11
8000d176:	12 98       	mov	r8,r9
8000d178:	95 1b       	st.w	r10[0x4],r11
8000d17a:	c0 a8       	rjmp	8000d18e <_free_r+0x17a>
8000d17c:	72 29       	ld.w	r9,r9[0x8]
8000d17e:	18 39       	cp.w	r9,r12
8000d180:	c0 60       	breq	8000d18c <_free_r+0x178>
8000d182:	72 1a       	ld.w	r10,r9[0x4]
8000d184:	e0 1a ff fc 	andl	r10,0xfffc
8000d188:	14 38       	cp.w	r8,r10
8000d18a:	cf 93       	brcs	8000d17c <_free_r+0x168>
8000d18c:	72 38       	ld.w	r8,r9[0xc]
8000d18e:	8d 38       	st.w	r6[0xc],r8
8000d190:	8d 29       	st.w	r6[0x8],r9
8000d192:	93 36       	st.w	r9[0xc],r6
8000d194:	91 26       	st.w	r8[0x8],r6
8000d196:	0e 9c       	mov	r12,r7
8000d198:	fe b0 ce 6a 	rcall	80006e6c <__malloc_unlock>
8000d19c:	d8 22       	popm	r4-r7,pc
8000d19e:	d7 03       	nop

8000d1a0 <__sfvwrite_r>:
8000d1a0:	d4 31       	pushm	r0-r7,lr
8000d1a2:	20 3d       	sub	sp,12
8000d1a4:	14 94       	mov	r4,r10
8000d1a6:	18 95       	mov	r5,r12
8000d1a8:	16 97       	mov	r7,r11
8000d1aa:	74 28       	ld.w	r8,r10[0x8]
8000d1ac:	58 08       	cp.w	r8,0
8000d1ae:	e0 80 01 40 	breq	8000d42e <__sfvwrite_r+0x28e>
8000d1b2:	96 68       	ld.sh	r8,r11[0xc]
8000d1b4:	ed b8 00 03 	bld	r8,0x3
8000d1b8:	c0 41       	brne	8000d1c0 <__sfvwrite_r+0x20>
8000d1ba:	76 48       	ld.w	r8,r11[0x10]
8000d1bc:	58 08       	cp.w	r8,0
8000d1be:	c0 c1       	brne	8000d1d6 <__sfvwrite_r+0x36>
8000d1c0:	0e 9b       	mov	r11,r7
8000d1c2:	0a 9c       	mov	r12,r5
8000d1c4:	fe b0 f6 c4 	rcall	8000bf4c <__swsetup_r>
8000d1c8:	c0 70       	breq	8000d1d6 <__sfvwrite_r+0x36>
8000d1ca:	8e 68       	ld.sh	r8,r7[0xc]
8000d1cc:	a7 a8       	sbr	r8,0x6
8000d1ce:	ae 68       	st.h	r7[0xc],r8
8000d1d0:	30 98       	mov	r8,9
8000d1d2:	8b 38       	st.w	r5[0xc],r8
8000d1d4:	c2 b9       	rjmp	8000d42a <__sfvwrite_r+0x28a>
8000d1d6:	8e 63       	ld.sh	r3,r7[0xc]
8000d1d8:	68 00       	ld.w	r0,r4[0x0]
8000d1da:	06 96       	mov	r6,r3
8000d1dc:	e2 16 00 02 	andl	r6,0x2,COH
8000d1e0:	c2 10       	breq	8000d222 <__sfvwrite_r+0x82>
8000d1e2:	30 03       	mov	r3,0
8000d1e4:	e0 62 04 00 	mov	r2,1024
8000d1e8:	06 96       	mov	r6,r3
8000d1ea:	c0 48       	rjmp	8000d1f2 <__sfvwrite_r+0x52>
8000d1ec:	60 03       	ld.w	r3,r0[0x0]
8000d1ee:	60 16       	ld.w	r6,r0[0x4]
8000d1f0:	2f 80       	sub	r0,-8
8000d1f2:	58 06       	cp.w	r6,0
8000d1f4:	cf c0       	breq	8000d1ec <__sfvwrite_r+0x4c>
8000d1f6:	e0 46 04 00 	cp.w	r6,1024
8000d1fa:	ec 09 17 80 	movls	r9,r6
8000d1fe:	e4 09 17 b0 	movhi	r9,r2
8000d202:	06 9a       	mov	r10,r3
8000d204:	6e a8       	ld.w	r8,r7[0x28]
8000d206:	6e 8b       	ld.w	r11,r7[0x20]
8000d208:	0a 9c       	mov	r12,r5
8000d20a:	5d 18       	icall	r8
8000d20c:	18 16       	sub	r6,r12
8000d20e:	58 0c       	cp.w	r12,0
8000d210:	e0 8a 01 0a 	brle	8000d424 <__sfvwrite_r+0x284>
8000d214:	68 28       	ld.w	r8,r4[0x8]
8000d216:	18 18       	sub	r8,r12
8000d218:	89 28       	st.w	r4[0x8],r8
8000d21a:	e0 80 01 0a 	breq	8000d42e <__sfvwrite_r+0x28e>
8000d21e:	18 03       	add	r3,r12
8000d220:	ce 9b       	rjmp	8000d1f2 <__sfvwrite_r+0x52>
8000d222:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000d226:	c0 70       	breq	8000d234 <__sfvwrite_r+0x94>
8000d228:	50 06       	stdsp	sp[0x0],r6
8000d22a:	0c 93       	mov	r3,r6
8000d22c:	0c 91       	mov	r1,r6
8000d22e:	50 15       	stdsp	sp[0x4],r5
8000d230:	08 92       	mov	r2,r4
8000d232:	c9 c8       	rjmp	8000d36a <__sfvwrite_r+0x1ca>
8000d234:	06 96       	mov	r6,r3
8000d236:	08 91       	mov	r1,r4
8000d238:	c0 48       	rjmp	8000d240 <__sfvwrite_r+0xa0>
8000d23a:	60 03       	ld.w	r3,r0[0x0]
8000d23c:	60 16       	ld.w	r6,r0[0x4]
8000d23e:	2f 80       	sub	r0,-8
8000d240:	58 06       	cp.w	r6,0
8000d242:	cf c0       	breq	8000d23a <__sfvwrite_r+0x9a>
8000d244:	8e 68       	ld.sh	r8,r7[0xc]
8000d246:	6e 24       	ld.w	r4,r7[0x8]
8000d248:	10 99       	mov	r9,r8
8000d24a:	e2 19 02 00 	andl	r9,0x200,COH
8000d24e:	c5 50       	breq	8000d2f8 <__sfvwrite_r+0x158>
8000d250:	08 36       	cp.w	r6,r4
8000d252:	c4 43       	brcs	8000d2da <__sfvwrite_r+0x13a>
8000d254:	10 99       	mov	r9,r8
8000d256:	e2 19 04 80 	andl	r9,0x480,COH
8000d25a:	c4 00       	breq	8000d2da <__sfvwrite_r+0x13a>
8000d25c:	6e 4b       	ld.w	r11,r7[0x10]
8000d25e:	6e 09       	ld.w	r9,r7[0x0]
8000d260:	16 19       	sub	r9,r11
8000d262:	50 09       	stdsp	sp[0x0],r9
8000d264:	6e 59       	ld.w	r9,r7[0x14]
8000d266:	10 9c       	mov	r12,r8
8000d268:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000d26c:	30 28       	mov	r8,2
8000d26e:	f4 08 0c 08 	divs	r8,r10,r8
8000d272:	fa e9 00 04 	st.d	sp[4],r8
8000d276:	10 94       	mov	r4,r8
8000d278:	40 09       	lddsp	r9,sp[0x0]
8000d27a:	e2 1c 04 00 	andl	r12,0x400,COH
8000d27e:	2f f9       	sub	r9,-1
8000d280:	0c 09       	add	r9,r6
8000d282:	12 38       	cp.w	r8,r9
8000d284:	f2 04 17 30 	movlo	r4,r9
8000d288:	58 0c       	cp.w	r12,0
8000d28a:	c1 10       	breq	8000d2ac <__sfvwrite_r+0x10c>
8000d28c:	08 9b       	mov	r11,r4
8000d28e:	0a 9c       	mov	r12,r5
8000d290:	fe b0 e0 60 	rcall	80009350 <_malloc_r>
8000d294:	18 92       	mov	r2,r12
8000d296:	c1 40       	breq	8000d2be <__sfvwrite_r+0x11e>
8000d298:	40 0a       	lddsp	r10,sp[0x0]
8000d29a:	6e 4b       	ld.w	r11,r7[0x10]
8000d29c:	fe b0 e2 76 	rcall	80009788 <memcpy>
8000d2a0:	8e 68       	ld.sh	r8,r7[0xc]
8000d2a2:	e0 18 fb 7f 	andl	r8,0xfb7f
8000d2a6:	a7 b8       	sbr	r8,0x7
8000d2a8:	ae 68       	st.h	r7[0xc],r8
8000d2aa:	c0 d8       	rjmp	8000d2c4 <__sfvwrite_r+0x124>
8000d2ac:	08 9a       	mov	r10,r4
8000d2ae:	0a 9c       	mov	r12,r5
8000d2b0:	fe b0 e3 18 	rcall	800098e0 <_realloc_r>
8000d2b4:	18 92       	mov	r2,r12
8000d2b6:	c0 71       	brne	8000d2c4 <__sfvwrite_r+0x124>
8000d2b8:	6e 4b       	ld.w	r11,r7[0x10]
8000d2ba:	0a 9c       	mov	r12,r5
8000d2bc:	ca ce       	rcall	8000d014 <_free_r>
8000d2be:	30 c8       	mov	r8,12
8000d2c0:	8b 38       	st.w	r5[0xc],r8
8000d2c2:	cb 18       	rjmp	8000d424 <__sfvwrite_r+0x284>
8000d2c4:	40 0a       	lddsp	r10,sp[0x0]
8000d2c6:	40 09       	lddsp	r9,sp[0x0]
8000d2c8:	e8 0a 01 0a 	sub	r10,r4,r10
8000d2cc:	e4 09 00 08 	add	r8,r2,r9
8000d2d0:	8f 54       	st.w	r7[0x14],r4
8000d2d2:	8f 2a       	st.w	r7[0x8],r10
8000d2d4:	8f 08       	st.w	r7[0x0],r8
8000d2d6:	8f 42       	st.w	r7[0x10],r2
8000d2d8:	0c 94       	mov	r4,r6
8000d2da:	08 36       	cp.w	r6,r4
8000d2dc:	ec 04 17 30 	movlo	r4,r6
8000d2e0:	06 9b       	mov	r11,r3
8000d2e2:	08 9a       	mov	r10,r4
8000d2e4:	6e 0c       	ld.w	r12,r7[0x0]
8000d2e6:	c3 ad       	rcall	8000d55a <memmove>
8000d2e8:	6e 08       	ld.w	r8,r7[0x0]
8000d2ea:	08 08       	add	r8,r4
8000d2ec:	8f 08       	st.w	r7[0x0],r8
8000d2ee:	6e 28       	ld.w	r8,r7[0x8]
8000d2f0:	08 18       	sub	r8,r4
8000d2f2:	0c 94       	mov	r4,r6
8000d2f4:	8f 28       	st.w	r7[0x8],r8
8000d2f6:	c2 e8       	rjmp	8000d352 <__sfvwrite_r+0x1b2>
8000d2f8:	08 36       	cp.w	r6,r4
8000d2fa:	5f ba       	srhi	r10
8000d2fc:	6e 0c       	ld.w	r12,r7[0x0]
8000d2fe:	6e 48       	ld.w	r8,r7[0x10]
8000d300:	10 3c       	cp.w	r12,r8
8000d302:	5f b8       	srhi	r8
8000d304:	f5 e8 00 08 	and	r8,r10,r8
8000d308:	f2 08 18 00 	cp.b	r8,r9
8000d30c:	c0 d0       	breq	8000d326 <__sfvwrite_r+0x186>
8000d30e:	06 9b       	mov	r11,r3
8000d310:	08 9a       	mov	r10,r4
8000d312:	c2 4d       	rcall	8000d55a <memmove>
8000d314:	6e 08       	ld.w	r8,r7[0x0]
8000d316:	08 08       	add	r8,r4
8000d318:	0e 9b       	mov	r11,r7
8000d31a:	8f 08       	st.w	r7[0x0],r8
8000d31c:	0a 9c       	mov	r12,r5
8000d31e:	fe b0 fd 09 	rcall	8000cd30 <_fflush_r>
8000d322:	c1 80       	breq	8000d352 <__sfvwrite_r+0x1b2>
8000d324:	c8 08       	rjmp	8000d424 <__sfvwrite_r+0x284>
8000d326:	6e 59       	ld.w	r9,r7[0x14]
8000d328:	12 36       	cp.w	r6,r9
8000d32a:	c0 a3       	brcs	8000d33e <__sfvwrite_r+0x19e>
8000d32c:	6e a8       	ld.w	r8,r7[0x28]
8000d32e:	06 9a       	mov	r10,r3
8000d330:	6e 8b       	ld.w	r11,r7[0x20]
8000d332:	0a 9c       	mov	r12,r5
8000d334:	5d 18       	icall	r8
8000d336:	18 94       	mov	r4,r12
8000d338:	e0 89 00 0d 	brgt	8000d352 <__sfvwrite_r+0x1b2>
8000d33c:	c7 48       	rjmp	8000d424 <__sfvwrite_r+0x284>
8000d33e:	0c 9a       	mov	r10,r6
8000d340:	06 9b       	mov	r11,r3
8000d342:	c0 cd       	rcall	8000d55a <memmove>
8000d344:	6e 08       	ld.w	r8,r7[0x0]
8000d346:	0c 08       	add	r8,r6
8000d348:	0c 94       	mov	r4,r6
8000d34a:	8f 08       	st.w	r7[0x0],r8
8000d34c:	6e 28       	ld.w	r8,r7[0x8]
8000d34e:	0c 18       	sub	r8,r6
8000d350:	8f 28       	st.w	r7[0x8],r8
8000d352:	62 28       	ld.w	r8,r1[0x8]
8000d354:	08 18       	sub	r8,r4
8000d356:	83 28       	st.w	r1[0x8],r8
8000d358:	c6 b0       	breq	8000d42e <__sfvwrite_r+0x28e>
8000d35a:	08 16       	sub	r6,r4
8000d35c:	08 03       	add	r3,r4
8000d35e:	c7 1b       	rjmp	8000d240 <__sfvwrite_r+0xa0>
8000d360:	60 03       	ld.w	r3,r0[0x0]
8000d362:	60 11       	ld.w	r1,r0[0x4]
8000d364:	30 08       	mov	r8,0
8000d366:	2f 80       	sub	r0,-8
8000d368:	50 08       	stdsp	sp[0x0],r8
8000d36a:	58 01       	cp.w	r1,0
8000d36c:	cf a0       	breq	8000d360 <__sfvwrite_r+0x1c0>
8000d36e:	40 0a       	lddsp	r10,sp[0x0]
8000d370:	58 0a       	cp.w	r10,0
8000d372:	c1 41       	brne	8000d39a <__sfvwrite_r+0x1fa>
8000d374:	e2 c6 ff ff 	sub	r6,r1,-1
8000d378:	02 9a       	mov	r10,r1
8000d37a:	30 ab       	mov	r11,10
8000d37c:	06 9c       	mov	r12,r3
8000d37e:	ce 3c       	rcall	8000d544 <memchr>
8000d380:	f8 c8 ff ff 	sub	r8,r12,-1
8000d384:	58 0c       	cp.w	r12,0
8000d386:	f1 d3 e1 16 	subne	r6,r8,r3
8000d38a:	f9 b9 01 01 	movne	r9,1
8000d38e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000d392:	f9 b8 00 01 	moveq	r8,1
8000d396:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000d39a:	02 36       	cp.w	r6,r1
8000d39c:	ec 04 17 80 	movls	r4,r6
8000d3a0:	e2 04 17 b0 	movhi	r4,r1
8000d3a4:	6e 59       	ld.w	r9,r7[0x14]
8000d3a6:	6e 25       	ld.w	r5,r7[0x8]
8000d3a8:	f2 05 00 05 	add	r5,r9,r5
8000d3ac:	0a 34       	cp.w	r4,r5
8000d3ae:	5f 9a       	srgt	r10
8000d3b0:	6e 0c       	ld.w	r12,r7[0x0]
8000d3b2:	6e 48       	ld.w	r8,r7[0x10]
8000d3b4:	10 3c       	cp.w	r12,r8
8000d3b6:	5f b8       	srhi	r8
8000d3b8:	f5 e8 00 08 	and	r8,r10,r8
8000d3bc:	30 0a       	mov	r10,0
8000d3be:	f4 08 18 00 	cp.b	r8,r10
8000d3c2:	c0 d0       	breq	8000d3dc <__sfvwrite_r+0x23c>
8000d3c4:	06 9b       	mov	r11,r3
8000d3c6:	0a 9a       	mov	r10,r5
8000d3c8:	cc 9c       	rcall	8000d55a <memmove>
8000d3ca:	6e 08       	ld.w	r8,r7[0x0]
8000d3cc:	0a 08       	add	r8,r5
8000d3ce:	0e 9b       	mov	r11,r7
8000d3d0:	8f 08       	st.w	r7[0x0],r8
8000d3d2:	40 1c       	lddsp	r12,sp[0x4]
8000d3d4:	fe b0 fc ae 	rcall	8000cd30 <_fflush_r>
8000d3d8:	c1 70       	breq	8000d406 <__sfvwrite_r+0x266>
8000d3da:	c2 58       	rjmp	8000d424 <__sfvwrite_r+0x284>
8000d3dc:	12 34       	cp.w	r4,r9
8000d3de:	c0 a5       	brlt	8000d3f2 <__sfvwrite_r+0x252>
8000d3e0:	6e a8       	ld.w	r8,r7[0x28]
8000d3e2:	06 9a       	mov	r10,r3
8000d3e4:	6e 8b       	ld.w	r11,r7[0x20]
8000d3e6:	40 1c       	lddsp	r12,sp[0x4]
8000d3e8:	5d 18       	icall	r8
8000d3ea:	18 95       	mov	r5,r12
8000d3ec:	e0 89 00 0d 	brgt	8000d406 <__sfvwrite_r+0x266>
8000d3f0:	c1 a8       	rjmp	8000d424 <__sfvwrite_r+0x284>
8000d3f2:	08 9a       	mov	r10,r4
8000d3f4:	06 9b       	mov	r11,r3
8000d3f6:	cb 2c       	rcall	8000d55a <memmove>
8000d3f8:	6e 08       	ld.w	r8,r7[0x0]
8000d3fa:	08 08       	add	r8,r4
8000d3fc:	08 95       	mov	r5,r4
8000d3fe:	8f 08       	st.w	r7[0x0],r8
8000d400:	6e 28       	ld.w	r8,r7[0x8]
8000d402:	08 18       	sub	r8,r4
8000d404:	8f 28       	st.w	r7[0x8],r8
8000d406:	0a 16       	sub	r6,r5
8000d408:	c0 71       	brne	8000d416 <__sfvwrite_r+0x276>
8000d40a:	0e 9b       	mov	r11,r7
8000d40c:	40 1c       	lddsp	r12,sp[0x4]
8000d40e:	fe b0 fc 91 	rcall	8000cd30 <_fflush_r>
8000d412:	c0 91       	brne	8000d424 <__sfvwrite_r+0x284>
8000d414:	50 06       	stdsp	sp[0x0],r6
8000d416:	64 28       	ld.w	r8,r2[0x8]
8000d418:	0a 18       	sub	r8,r5
8000d41a:	85 28       	st.w	r2[0x8],r8
8000d41c:	c0 90       	breq	8000d42e <__sfvwrite_r+0x28e>
8000d41e:	0a 11       	sub	r1,r5
8000d420:	0a 03       	add	r3,r5
8000d422:	ca 4b       	rjmp	8000d36a <__sfvwrite_r+0x1ca>
8000d424:	8e 68       	ld.sh	r8,r7[0xc]
8000d426:	a7 a8       	sbr	r8,0x6
8000d428:	ae 68       	st.h	r7[0xc],r8
8000d42a:	3f fc       	mov	r12,-1
8000d42c:	c0 28       	rjmp	8000d430 <__sfvwrite_r+0x290>
8000d42e:	30 0c       	mov	r12,0
8000d430:	2f dd       	sub	sp,-12
8000d432:	d8 32       	popm	r0-r7,pc

8000d434 <_fwalk>:
8000d434:	d4 31       	pushm	r0-r7,lr
8000d436:	30 05       	mov	r5,0
8000d438:	16 91       	mov	r1,r11
8000d43a:	f8 c7 ff 28 	sub	r7,r12,-216
8000d43e:	0a 92       	mov	r2,r5
8000d440:	fe b0 fc fe 	rcall	8000ce3c <__sfp_lock_acquire>
8000d444:	3f f3       	mov	r3,-1
8000d446:	c1 68       	rjmp	8000d472 <_fwalk+0x3e>
8000d448:	6e 26       	ld.w	r6,r7[0x8]
8000d44a:	6e 14       	ld.w	r4,r7[0x4]
8000d44c:	2f 46       	sub	r6,-12
8000d44e:	c0 c8       	rjmp	8000d466 <_fwalk+0x32>
8000d450:	8c 08       	ld.sh	r8,r6[0x0]
8000d452:	e4 08 19 00 	cp.h	r8,r2
8000d456:	c0 70       	breq	8000d464 <_fwalk+0x30>
8000d458:	8c 18       	ld.sh	r8,r6[0x2]
8000d45a:	e6 08 19 00 	cp.h	r8,r3
8000d45e:	c0 30       	breq	8000d464 <_fwalk+0x30>
8000d460:	5d 11       	icall	r1
8000d462:	18 45       	or	r5,r12
8000d464:	2a 46       	sub	r6,-92
8000d466:	20 14       	sub	r4,1
8000d468:	ec cc 00 0c 	sub	r12,r6,12
8000d46c:	58 04       	cp.w	r4,0
8000d46e:	cf 14       	brge	8000d450 <_fwalk+0x1c>
8000d470:	6e 07       	ld.w	r7,r7[0x0]
8000d472:	58 07       	cp.w	r7,0
8000d474:	ce a1       	brne	8000d448 <_fwalk+0x14>
8000d476:	fe b0 fc e4 	rcall	8000ce3e <__sfp_lock_release>
8000d47a:	0a 9c       	mov	r12,r5
8000d47c:	d8 32       	popm	r0-r7,pc
8000d47e:	d7 03       	nop

8000d480 <_localeconv_r>:
8000d480:	fe cc dc 70 	sub	r12,pc,-9104
8000d484:	5e fc       	retal	r12
8000d486:	d7 03       	nop

8000d488 <__smakebuf_r>:
8000d488:	d4 21       	pushm	r4-r7,lr
8000d48a:	20 fd       	sub	sp,60
8000d48c:	96 68       	ld.sh	r8,r11[0xc]
8000d48e:	16 97       	mov	r7,r11
8000d490:	18 96       	mov	r6,r12
8000d492:	e2 18 00 02 	andl	r8,0x2,COH
8000d496:	c3 d1       	brne	8000d510 <__smakebuf_r+0x88>
8000d498:	96 7b       	ld.sh	r11,r11[0xe]
8000d49a:	f0 0b 19 00 	cp.h	r11,r8
8000d49e:	c0 55       	brlt	8000d4a8 <__smakebuf_r+0x20>
8000d4a0:	1a 9a       	mov	r10,sp
8000d4a2:	e0 a0 04 75 	rcall	8000dd8c <_fstat_r>
8000d4a6:	c0 f4       	brge	8000d4c4 <__smakebuf_r+0x3c>
8000d4a8:	8e 65       	ld.sh	r5,r7[0xc]
8000d4aa:	0a 98       	mov	r8,r5
8000d4ac:	ab b8       	sbr	r8,0xb
8000d4ae:	e2 15 00 80 	andl	r5,0x80,COH
8000d4b2:	ae 68       	st.h	r7[0xc],r8
8000d4b4:	30 04       	mov	r4,0
8000d4b6:	e0 68 04 00 	mov	r8,1024
8000d4ba:	f9 b5 01 40 	movne	r5,64
8000d4be:	f0 05 17 00 	moveq	r5,r8
8000d4c2:	c1 c8       	rjmp	8000d4fa <__smakebuf_r+0x72>
8000d4c4:	40 18       	lddsp	r8,sp[0x4]
8000d4c6:	e2 18 f0 00 	andl	r8,0xf000,COH
8000d4ca:	e0 48 20 00 	cp.w	r8,8192
8000d4ce:	5f 04       	sreq	r4
8000d4d0:	e0 48 80 00 	cp.w	r8,32768
8000d4d4:	c0 e1       	brne	8000d4f0 <__smakebuf_r+0x68>
8000d4d6:	6e b9       	ld.w	r9,r7[0x2c]
8000d4d8:	fe c8 f9 1c 	sub	r8,pc,-1764
8000d4dc:	10 39       	cp.w	r9,r8
8000d4de:	c0 91       	brne	8000d4f0 <__smakebuf_r+0x68>
8000d4e0:	8e 68       	ld.sh	r8,r7[0xc]
8000d4e2:	e0 65 04 00 	mov	r5,1024
8000d4e6:	ab a8       	sbr	r8,0xa
8000d4e8:	ef 45 00 50 	st.w	r7[80],r5
8000d4ec:	ae 68       	st.h	r7[0xc],r8
8000d4ee:	c0 68       	rjmp	8000d4fa <__smakebuf_r+0x72>
8000d4f0:	8e 68       	ld.sh	r8,r7[0xc]
8000d4f2:	e0 65 04 00 	mov	r5,1024
8000d4f6:	ab b8       	sbr	r8,0xb
8000d4f8:	ae 68       	st.h	r7[0xc],r8
8000d4fa:	0a 9b       	mov	r11,r5
8000d4fc:	0c 9c       	mov	r12,r6
8000d4fe:	fe b0 df 29 	rcall	80009350 <_malloc_r>
8000d502:	8e 68       	ld.sh	r8,r7[0xc]
8000d504:	c0 d1       	brne	8000d51e <__smakebuf_r+0x96>
8000d506:	ed b8 00 09 	bld	r8,0x9
8000d50a:	c1 b0       	breq	8000d540 <__smakebuf_r+0xb8>
8000d50c:	a1 b8       	sbr	r8,0x1
8000d50e:	ae 68       	st.h	r7[0xc],r8
8000d510:	ee c8 ff b9 	sub	r8,r7,-71
8000d514:	8f 48       	st.w	r7[0x10],r8
8000d516:	8f 08       	st.w	r7[0x0],r8
8000d518:	30 18       	mov	r8,1
8000d51a:	8f 58       	st.w	r7[0x14],r8
8000d51c:	c1 28       	rjmp	8000d540 <__smakebuf_r+0xb8>
8000d51e:	a7 b8       	sbr	r8,0x7
8000d520:	8f 4c       	st.w	r7[0x10],r12
8000d522:	ae 68       	st.h	r7[0xc],r8
8000d524:	8f 55       	st.w	r7[0x14],r5
8000d526:	fe c8 06 e6 	sub	r8,pc,1766
8000d52a:	8f 0c       	st.w	r7[0x0],r12
8000d52c:	8d a8       	st.w	r6[0x28],r8
8000d52e:	58 04       	cp.w	r4,0
8000d530:	c0 80       	breq	8000d540 <__smakebuf_r+0xb8>
8000d532:	8e 7c       	ld.sh	r12,r7[0xe]
8000d534:	fe b0 e3 94 	rcall	80009c5c <isatty>
8000d538:	c0 40       	breq	8000d540 <__smakebuf_r+0xb8>
8000d53a:	8e 68       	ld.sh	r8,r7[0xc]
8000d53c:	a1 a8       	sbr	r8,0x0
8000d53e:	ae 68       	st.h	r7[0xc],r8
8000d540:	2f 1d       	sub	sp,-60
8000d542:	d8 22       	popm	r4-r7,pc

8000d544 <memchr>:
8000d544:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000d548:	c0 68       	rjmp	8000d554 <memchr+0x10>
8000d54a:	20 1a       	sub	r10,1
8000d54c:	19 88       	ld.ub	r8,r12[0x0]
8000d54e:	16 38       	cp.w	r8,r11
8000d550:	5e 0c       	reteq	r12
8000d552:	2f fc       	sub	r12,-1
8000d554:	58 0a       	cp.w	r10,0
8000d556:	cf a1       	brne	8000d54a <memchr+0x6>
8000d558:	5e fa       	retal	r10

8000d55a <memmove>:
8000d55a:	d4 01       	pushm	lr
8000d55c:	18 3b       	cp.w	r11,r12
8000d55e:	c1 92       	brcc	8000d590 <memmove+0x36>
8000d560:	f6 0a 00 09 	add	r9,r11,r10
8000d564:	12 3c       	cp.w	r12,r9
8000d566:	c1 52       	brcc	8000d590 <memmove+0x36>
8000d568:	f8 0a 00 0b 	add	r11,r12,r10
8000d56c:	30 08       	mov	r8,0
8000d56e:	c0 68       	rjmp	8000d57a <memmove+0x20>
8000d570:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000d574:	20 1a       	sub	r10,1
8000d576:	f6 08 0b 0e 	st.b	r11[r8],lr
8000d57a:	20 18       	sub	r8,1
8000d57c:	58 0a       	cp.w	r10,0
8000d57e:	cf 91       	brne	8000d570 <memmove+0x16>
8000d580:	d8 02       	popm	pc
8000d582:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000d586:	20 1a       	sub	r10,1
8000d588:	f8 08 0b 09 	st.b	r12[r8],r9
8000d58c:	2f f8       	sub	r8,-1
8000d58e:	c0 28       	rjmp	8000d592 <memmove+0x38>
8000d590:	30 08       	mov	r8,0
8000d592:	58 0a       	cp.w	r10,0
8000d594:	cf 71       	brne	8000d582 <memmove+0x28>
8000d596:	d8 02       	popm	pc

8000d598 <__hi0bits>:
8000d598:	18 98       	mov	r8,r12
8000d59a:	e0 1c 00 00 	andl	r12,0x0
8000d59e:	f0 09 15 10 	lsl	r9,r8,0x10
8000d5a2:	58 0c       	cp.w	r12,0
8000d5a4:	f2 08 17 00 	moveq	r8,r9
8000d5a8:	f9 bc 00 10 	moveq	r12,16
8000d5ac:	f9 bc 01 00 	movne	r12,0
8000d5b0:	10 9a       	mov	r10,r8
8000d5b2:	f0 09 15 08 	lsl	r9,r8,0x8
8000d5b6:	e6 1a ff 00 	andh	r10,0xff00,COH
8000d5ba:	f7 bc 00 f8 	subeq	r12,-8
8000d5be:	f2 08 17 00 	moveq	r8,r9
8000d5c2:	10 9a       	mov	r10,r8
8000d5c4:	f0 09 15 04 	lsl	r9,r8,0x4
8000d5c8:	e6 1a f0 00 	andh	r10,0xf000,COH
8000d5cc:	f7 bc 00 fc 	subeq	r12,-4
8000d5d0:	f2 08 17 00 	moveq	r8,r9
8000d5d4:	10 9a       	mov	r10,r8
8000d5d6:	f0 09 15 02 	lsl	r9,r8,0x2
8000d5da:	e6 1a c0 00 	andh	r10,0xc000,COH
8000d5de:	f7 bc 00 fe 	subeq	r12,-2
8000d5e2:	f2 08 17 00 	moveq	r8,r9
8000d5e6:	58 08       	cp.w	r8,0
8000d5e8:	5e 5c       	retlt	r12
8000d5ea:	ed b8 00 1e 	bld	r8,0x1e
8000d5ee:	f9 bc 01 20 	movne	r12,32
8000d5f2:	f7 bc 00 ff 	subeq	r12,-1
8000d5f6:	5e fc       	retal	r12

8000d5f8 <__lo0bits>:
8000d5f8:	18 99       	mov	r9,r12
8000d5fa:	78 08       	ld.w	r8,r12[0x0]
8000d5fc:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000d600:	c1 50       	breq	8000d62a <__lo0bits+0x32>
8000d602:	ed b8 00 00 	bld	r8,0x0
8000d606:	c0 21       	brne	8000d60a <__lo0bits+0x12>
8000d608:	5e fd       	retal	0
8000d60a:	10 9b       	mov	r11,r8
8000d60c:	f0 0a 16 01 	lsr	r10,r8,0x1
8000d610:	e2 1b 00 02 	andl	r11,0x2,COH
8000d614:	a3 88       	lsr	r8,0x2
8000d616:	58 0b       	cp.w	r11,0
8000d618:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000d61c:	f9 bc 01 01 	movne	r12,1
8000d620:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000d624:	f9 bc 00 02 	moveq	r12,2
8000d628:	5e fc       	retal	r12
8000d62a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000d62e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000d632:	58 0a       	cp.w	r10,0
8000d634:	f6 08 17 00 	moveq	r8,r11
8000d638:	f9 bc 00 10 	moveq	r12,16
8000d63c:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000d640:	f0 0a 16 08 	lsr	r10,r8,0x8
8000d644:	58 0b       	cp.w	r11,0
8000d646:	f7 bc 00 f8 	subeq	r12,-8
8000d64a:	f4 08 17 00 	moveq	r8,r10
8000d64e:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000d652:	f0 0a 16 04 	lsr	r10,r8,0x4
8000d656:	58 0b       	cp.w	r11,0
8000d658:	f7 bc 00 fc 	subeq	r12,-4
8000d65c:	f4 08 17 00 	moveq	r8,r10
8000d660:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000d664:	f0 0a 16 02 	lsr	r10,r8,0x2
8000d668:	58 0b       	cp.w	r11,0
8000d66a:	f7 bc 00 fe 	subeq	r12,-2
8000d66e:	f4 08 17 00 	moveq	r8,r10
8000d672:	ed b8 00 00 	bld	r8,0x0
8000d676:	c0 60       	breq	8000d682 <__lo0bits+0x8a>
8000d678:	a1 98       	lsr	r8,0x1
8000d67a:	c0 31       	brne	8000d680 <__lo0bits+0x88>
8000d67c:	32 0c       	mov	r12,32
8000d67e:	5e fc       	retal	r12
8000d680:	2f fc       	sub	r12,-1
8000d682:	93 08       	st.w	r9[0x0],r8
8000d684:	5e fc       	retal	r12

8000d686 <__mcmp>:
8000d686:	d4 01       	pushm	lr
8000d688:	18 98       	mov	r8,r12
8000d68a:	76 49       	ld.w	r9,r11[0x10]
8000d68c:	78 4c       	ld.w	r12,r12[0x10]
8000d68e:	12 1c       	sub	r12,r9
8000d690:	c1 31       	brne	8000d6b6 <__mcmp+0x30>
8000d692:	2f b9       	sub	r9,-5
8000d694:	a3 69       	lsl	r9,0x2
8000d696:	12 0b       	add	r11,r9
8000d698:	f0 09 00 09 	add	r9,r8,r9
8000d69c:	2e c8       	sub	r8,-20
8000d69e:	13 4e       	ld.w	lr,--r9
8000d6a0:	17 4a       	ld.w	r10,--r11
8000d6a2:	14 3e       	cp.w	lr,r10
8000d6a4:	c0 60       	breq	8000d6b0 <__mcmp+0x2a>
8000d6a6:	f9 bc 03 ff 	movlo	r12,-1
8000d6aa:	f9 bc 02 01 	movhs	r12,1
8000d6ae:	d8 02       	popm	pc
8000d6b0:	10 39       	cp.w	r9,r8
8000d6b2:	fe 9b ff f6 	brhi	8000d69e <__mcmp+0x18>
8000d6b6:	d8 02       	popm	pc

8000d6b8 <_Bfree>:
8000d6b8:	d4 21       	pushm	r4-r7,lr
8000d6ba:	18 97       	mov	r7,r12
8000d6bc:	16 95       	mov	r5,r11
8000d6be:	78 96       	ld.w	r6,r12[0x24]
8000d6c0:	58 06       	cp.w	r6,0
8000d6c2:	c0 91       	brne	8000d6d4 <_Bfree+0x1c>
8000d6c4:	31 0c       	mov	r12,16
8000d6c6:	fe b0 de 3d 	rcall	80009340 <malloc>
8000d6ca:	99 36       	st.w	r12[0xc],r6
8000d6cc:	8f 9c       	st.w	r7[0x24],r12
8000d6ce:	99 16       	st.w	r12[0x4],r6
8000d6d0:	99 26       	st.w	r12[0x8],r6
8000d6d2:	99 06       	st.w	r12[0x0],r6
8000d6d4:	58 05       	cp.w	r5,0
8000d6d6:	c0 90       	breq	8000d6e8 <_Bfree+0x30>
8000d6d8:	6a 19       	ld.w	r9,r5[0x4]
8000d6da:	6e 98       	ld.w	r8,r7[0x24]
8000d6dc:	70 38       	ld.w	r8,r8[0xc]
8000d6de:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000d6e2:	8b 0a       	st.w	r5[0x0],r10
8000d6e4:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000d6e8:	d8 22       	popm	r4-r7,pc
8000d6ea:	d7 03       	nop

8000d6ec <_Balloc>:
8000d6ec:	d4 21       	pushm	r4-r7,lr
8000d6ee:	18 97       	mov	r7,r12
8000d6f0:	16 96       	mov	r6,r11
8000d6f2:	78 95       	ld.w	r5,r12[0x24]
8000d6f4:	58 05       	cp.w	r5,0
8000d6f6:	c0 91       	brne	8000d708 <_Balloc+0x1c>
8000d6f8:	31 0c       	mov	r12,16
8000d6fa:	fe b0 de 23 	rcall	80009340 <malloc>
8000d6fe:	99 35       	st.w	r12[0xc],r5
8000d700:	8f 9c       	st.w	r7[0x24],r12
8000d702:	99 15       	st.w	r12[0x4],r5
8000d704:	99 25       	st.w	r12[0x8],r5
8000d706:	99 05       	st.w	r12[0x0],r5
8000d708:	6e 95       	ld.w	r5,r7[0x24]
8000d70a:	6a 38       	ld.w	r8,r5[0xc]
8000d70c:	58 08       	cp.w	r8,0
8000d70e:	c0 b1       	brne	8000d724 <_Balloc+0x38>
8000d710:	31 0a       	mov	r10,16
8000d712:	30 4b       	mov	r11,4
8000d714:	0e 9c       	mov	r12,r7
8000d716:	e0 a0 02 9b 	rcall	8000dc4c <_calloc_r>
8000d71a:	8b 3c       	st.w	r5[0xc],r12
8000d71c:	6e 98       	ld.w	r8,r7[0x24]
8000d71e:	70 3c       	ld.w	r12,r8[0xc]
8000d720:	58 0c       	cp.w	r12,0
8000d722:	c1 b0       	breq	8000d758 <_Balloc+0x6c>
8000d724:	6e 98       	ld.w	r8,r7[0x24]
8000d726:	70 38       	ld.w	r8,r8[0xc]
8000d728:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000d72c:	70 0c       	ld.w	r12,r8[0x0]
8000d72e:	58 0c       	cp.w	r12,0
8000d730:	c0 40       	breq	8000d738 <_Balloc+0x4c>
8000d732:	78 09       	ld.w	r9,r12[0x0]
8000d734:	91 09       	st.w	r8[0x0],r9
8000d736:	c0 e8       	rjmp	8000d752 <_Balloc+0x66>
8000d738:	0e 9c       	mov	r12,r7
8000d73a:	30 17       	mov	r7,1
8000d73c:	0e 9b       	mov	r11,r7
8000d73e:	ee 06 09 47 	lsl	r7,r7,r6
8000d742:	ee ca ff fb 	sub	r10,r7,-5
8000d746:	a3 6a       	lsl	r10,0x2
8000d748:	e0 a0 02 82 	rcall	8000dc4c <_calloc_r>
8000d74c:	c0 60       	breq	8000d758 <_Balloc+0x6c>
8000d74e:	99 16       	st.w	r12[0x4],r6
8000d750:	99 27       	st.w	r12[0x8],r7
8000d752:	30 08       	mov	r8,0
8000d754:	99 38       	st.w	r12[0xc],r8
8000d756:	99 48       	st.w	r12[0x10],r8
8000d758:	d8 22       	popm	r4-r7,pc
8000d75a:	d7 03       	nop

8000d75c <__d2b>:
8000d75c:	d4 31       	pushm	r0-r7,lr
8000d75e:	20 2d       	sub	sp,8
8000d760:	16 93       	mov	r3,r11
8000d762:	12 96       	mov	r6,r9
8000d764:	10 95       	mov	r5,r8
8000d766:	14 92       	mov	r2,r10
8000d768:	30 1b       	mov	r11,1
8000d76a:	cc 1f       	rcall	8000d6ec <_Balloc>
8000d76c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000d770:	50 09       	stdsp	sp[0x0],r9
8000d772:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000d776:	b5 a9       	sbr	r9,0x14
8000d778:	f0 01 16 14 	lsr	r1,r8,0x14
8000d77c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000d780:	18 94       	mov	r4,r12
8000d782:	58 02       	cp.w	r2,0
8000d784:	c1 d0       	breq	8000d7be <__d2b+0x62>
8000d786:	fa cc ff f8 	sub	r12,sp,-8
8000d78a:	18 d2       	st.w	--r12,r2
8000d78c:	c3 6f       	rcall	8000d5f8 <__lo0bits>
8000d78e:	40 18       	lddsp	r8,sp[0x4]
8000d790:	c0 d0       	breq	8000d7aa <__d2b+0x4e>
8000d792:	40 09       	lddsp	r9,sp[0x0]
8000d794:	f8 0a 11 20 	rsub	r10,r12,32
8000d798:	f2 0a 09 4a 	lsl	r10,r9,r10
8000d79c:	f5 e8 10 08 	or	r8,r10,r8
8000d7a0:	89 58       	st.w	r4[0x14],r8
8000d7a2:	f2 0c 0a 49 	lsr	r9,r9,r12
8000d7a6:	50 09       	stdsp	sp[0x0],r9
8000d7a8:	c0 28       	rjmp	8000d7ac <__d2b+0x50>
8000d7aa:	89 58       	st.w	r4[0x14],r8
8000d7ac:	40 08       	lddsp	r8,sp[0x0]
8000d7ae:	58 08       	cp.w	r8,0
8000d7b0:	f9 b3 01 02 	movne	r3,2
8000d7b4:	f9 b3 00 01 	moveq	r3,1
8000d7b8:	89 68       	st.w	r4[0x18],r8
8000d7ba:	89 43       	st.w	r4[0x10],r3
8000d7bc:	c0 88       	rjmp	8000d7cc <__d2b+0x70>
8000d7be:	1a 9c       	mov	r12,sp
8000d7c0:	c1 cf       	rcall	8000d5f8 <__lo0bits>
8000d7c2:	30 13       	mov	r3,1
8000d7c4:	40 08       	lddsp	r8,sp[0x0]
8000d7c6:	2e 0c       	sub	r12,-32
8000d7c8:	89 43       	st.w	r4[0x10],r3
8000d7ca:	89 58       	st.w	r4[0x14],r8
8000d7cc:	58 01       	cp.w	r1,0
8000d7ce:	c0 90       	breq	8000d7e0 <__d2b+0x84>
8000d7d0:	e2 c1 04 33 	sub	r1,r1,1075
8000d7d4:	18 01       	add	r1,r12
8000d7d6:	8d 01       	st.w	r6[0x0],r1
8000d7d8:	f8 0c 11 35 	rsub	r12,r12,53
8000d7dc:	8b 0c       	st.w	r5[0x0],r12
8000d7de:	c0 c8       	rjmp	8000d7f6 <__d2b+0x9a>
8000d7e0:	e6 c8 ff fc 	sub	r8,r3,-4
8000d7e4:	f8 cc 04 32 	sub	r12,r12,1074
8000d7e8:	a5 73       	lsl	r3,0x5
8000d7ea:	8d 0c       	st.w	r6[0x0],r12
8000d7ec:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000d7f0:	cd 4e       	rcall	8000d598 <__hi0bits>
8000d7f2:	18 13       	sub	r3,r12
8000d7f4:	8b 03       	st.w	r5[0x0],r3
8000d7f6:	08 9c       	mov	r12,r4
8000d7f8:	2f ed       	sub	sp,-8
8000d7fa:	d8 32       	popm	r0-r7,pc

8000d7fc <__mdiff>:
8000d7fc:	d4 31       	pushm	r0-r7,lr
8000d7fe:	74 48       	ld.w	r8,r10[0x10]
8000d800:	76 45       	ld.w	r5,r11[0x10]
8000d802:	16 97       	mov	r7,r11
8000d804:	14 96       	mov	r6,r10
8000d806:	10 15       	sub	r5,r8
8000d808:	c1 31       	brne	8000d82e <__mdiff+0x32>
8000d80a:	2f b8       	sub	r8,-5
8000d80c:	ee ce ff ec 	sub	lr,r7,-20
8000d810:	a3 68       	lsl	r8,0x2
8000d812:	f4 08 00 0b 	add	r11,r10,r8
8000d816:	ee 08 00 08 	add	r8,r7,r8
8000d81a:	11 4a       	ld.w	r10,--r8
8000d81c:	17 49       	ld.w	r9,--r11
8000d81e:	12 3a       	cp.w	r10,r9
8000d820:	c0 30       	breq	8000d826 <__mdiff+0x2a>
8000d822:	c0 e2       	brcc	8000d83e <__mdiff+0x42>
8000d824:	c0 78       	rjmp	8000d832 <__mdiff+0x36>
8000d826:	1c 38       	cp.w	r8,lr
8000d828:	fe 9b ff f9 	brhi	8000d81a <__mdiff+0x1e>
8000d82c:	c4 98       	rjmp	8000d8be <__mdiff+0xc2>
8000d82e:	58 05       	cp.w	r5,0
8000d830:	c0 64       	brge	8000d83c <__mdiff+0x40>
8000d832:	0e 98       	mov	r8,r7
8000d834:	30 15       	mov	r5,1
8000d836:	0c 97       	mov	r7,r6
8000d838:	10 96       	mov	r6,r8
8000d83a:	c0 28       	rjmp	8000d83e <__mdiff+0x42>
8000d83c:	30 05       	mov	r5,0
8000d83e:	6e 1b       	ld.w	r11,r7[0x4]
8000d840:	c5 6f       	rcall	8000d6ec <_Balloc>
8000d842:	6e 49       	ld.w	r9,r7[0x10]
8000d844:	6c 44       	ld.w	r4,r6[0x10]
8000d846:	99 35       	st.w	r12[0xc],r5
8000d848:	2f b4       	sub	r4,-5
8000d84a:	f2 c5 ff fb 	sub	r5,r9,-5
8000d84e:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000d852:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000d856:	2e c6       	sub	r6,-20
8000d858:	2e c7       	sub	r7,-20
8000d85a:	f8 c8 ff ec 	sub	r8,r12,-20
8000d85e:	30 0a       	mov	r10,0
8000d860:	0f 0e       	ld.w	lr,r7++
8000d862:	0d 0b       	ld.w	r11,r6++
8000d864:	fc 02 16 10 	lsr	r2,lr,0x10
8000d868:	f6 03 16 10 	lsr	r3,r11,0x10
8000d86c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d870:	e4 03 01 03 	sub	r3,r2,r3
8000d874:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000d878:	fc 0b 01 0b 	sub	r11,lr,r11
8000d87c:	f6 0a 00 0a 	add	r10,r11,r10
8000d880:	b0 1a       	st.h	r8[0x2],r10
8000d882:	b1 4a       	asr	r10,0x10
8000d884:	e6 0a 00 0a 	add	r10,r3,r10
8000d888:	b0 0a       	st.h	r8[0x0],r10
8000d88a:	2f c8       	sub	r8,-4
8000d88c:	b1 4a       	asr	r10,0x10
8000d88e:	08 36       	cp.w	r6,r4
8000d890:	ce 83       	brcs	8000d860 <__mdiff+0x64>
8000d892:	c0 d8       	rjmp	8000d8ac <__mdiff+0xb0>
8000d894:	0f 0b       	ld.w	r11,r7++
8000d896:	f6 0e 16 10 	lsr	lr,r11,0x10
8000d89a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000d89e:	16 0a       	add	r10,r11
8000d8a0:	b0 1a       	st.h	r8[0x2],r10
8000d8a2:	b1 4a       	asr	r10,0x10
8000d8a4:	1c 0a       	add	r10,lr
8000d8a6:	b0 0a       	st.h	r8[0x0],r10
8000d8a8:	2f c8       	sub	r8,-4
8000d8aa:	b1 4a       	asr	r10,0x10
8000d8ac:	0a 37       	cp.w	r7,r5
8000d8ae:	cf 33       	brcs	8000d894 <__mdiff+0x98>
8000d8b0:	c0 28       	rjmp	8000d8b4 <__mdiff+0xb8>
8000d8b2:	20 19       	sub	r9,1
8000d8b4:	11 4a       	ld.w	r10,--r8
8000d8b6:	58 0a       	cp.w	r10,0
8000d8b8:	cf d0       	breq	8000d8b2 <__mdiff+0xb6>
8000d8ba:	99 49       	st.w	r12[0x10],r9
8000d8bc:	d8 32       	popm	r0-r7,pc
8000d8be:	30 0b       	mov	r11,0
8000d8c0:	c1 6f       	rcall	8000d6ec <_Balloc>
8000d8c2:	30 18       	mov	r8,1
8000d8c4:	99 48       	st.w	r12[0x10],r8
8000d8c6:	30 08       	mov	r8,0
8000d8c8:	99 58       	st.w	r12[0x14],r8
8000d8ca:	d8 32       	popm	r0-r7,pc

8000d8cc <__lshift>:
8000d8cc:	d4 31       	pushm	r0-r7,lr
8000d8ce:	16 97       	mov	r7,r11
8000d8d0:	76 46       	ld.w	r6,r11[0x10]
8000d8d2:	f4 02 14 05 	asr	r2,r10,0x5
8000d8d6:	2f f6       	sub	r6,-1
8000d8d8:	14 93       	mov	r3,r10
8000d8da:	18 94       	mov	r4,r12
8000d8dc:	04 06       	add	r6,r2
8000d8de:	76 1b       	ld.w	r11,r11[0x4]
8000d8e0:	6e 28       	ld.w	r8,r7[0x8]
8000d8e2:	c0 38       	rjmp	8000d8e8 <__lshift+0x1c>
8000d8e4:	2f fb       	sub	r11,-1
8000d8e6:	a1 78       	lsl	r8,0x1
8000d8e8:	10 36       	cp.w	r6,r8
8000d8ea:	fe 99 ff fd 	brgt	8000d8e4 <__lshift+0x18>
8000d8ee:	08 9c       	mov	r12,r4
8000d8f0:	cf ee       	rcall	8000d6ec <_Balloc>
8000d8f2:	30 09       	mov	r9,0
8000d8f4:	18 95       	mov	r5,r12
8000d8f6:	f8 c8 ff ec 	sub	r8,r12,-20
8000d8fa:	12 9a       	mov	r10,r9
8000d8fc:	c0 38       	rjmp	8000d902 <__lshift+0x36>
8000d8fe:	10 aa       	st.w	r8++,r10
8000d900:	2f f9       	sub	r9,-1
8000d902:	04 39       	cp.w	r9,r2
8000d904:	cf d5       	brlt	8000d8fe <__lshift+0x32>
8000d906:	6e 4b       	ld.w	r11,r7[0x10]
8000d908:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000d90c:	2f bb       	sub	r11,-5
8000d90e:	ee c9 ff ec 	sub	r9,r7,-20
8000d912:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000d916:	58 03       	cp.w	r3,0
8000d918:	c1 30       	breq	8000d93e <__lshift+0x72>
8000d91a:	e6 0c 11 20 	rsub	r12,r3,32
8000d91e:	30 0a       	mov	r10,0
8000d920:	72 02       	ld.w	r2,r9[0x0]
8000d922:	e4 03 09 42 	lsl	r2,r2,r3
8000d926:	04 4a       	or	r10,r2
8000d928:	10 aa       	st.w	r8++,r10
8000d92a:	13 0a       	ld.w	r10,r9++
8000d92c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000d930:	16 39       	cp.w	r9,r11
8000d932:	cf 73       	brcs	8000d920 <__lshift+0x54>
8000d934:	91 0a       	st.w	r8[0x0],r10
8000d936:	58 0a       	cp.w	r10,0
8000d938:	c0 70       	breq	8000d946 <__lshift+0x7a>
8000d93a:	2f f6       	sub	r6,-1
8000d93c:	c0 58       	rjmp	8000d946 <__lshift+0x7a>
8000d93e:	13 0a       	ld.w	r10,r9++
8000d940:	10 aa       	st.w	r8++,r10
8000d942:	16 39       	cp.w	r9,r11
8000d944:	cf d3       	brcs	8000d93e <__lshift+0x72>
8000d946:	08 9c       	mov	r12,r4
8000d948:	20 16       	sub	r6,1
8000d94a:	0e 9b       	mov	r11,r7
8000d94c:	8b 46       	st.w	r5[0x10],r6
8000d94e:	cb 5e       	rcall	8000d6b8 <_Bfree>
8000d950:	0a 9c       	mov	r12,r5
8000d952:	d8 32       	popm	r0-r7,pc

8000d954 <__multiply>:
8000d954:	d4 31       	pushm	r0-r7,lr
8000d956:	20 2d       	sub	sp,8
8000d958:	76 49       	ld.w	r9,r11[0x10]
8000d95a:	74 48       	ld.w	r8,r10[0x10]
8000d95c:	16 96       	mov	r6,r11
8000d95e:	14 95       	mov	r5,r10
8000d960:	10 39       	cp.w	r9,r8
8000d962:	ec 08 17 50 	movlt	r8,r6
8000d966:	ea 06 17 50 	movlt	r6,r5
8000d96a:	f0 05 17 50 	movlt	r5,r8
8000d96e:	6c 28       	ld.w	r8,r6[0x8]
8000d970:	76 43       	ld.w	r3,r11[0x10]
8000d972:	74 42       	ld.w	r2,r10[0x10]
8000d974:	76 1b       	ld.w	r11,r11[0x4]
8000d976:	e4 03 00 07 	add	r7,r2,r3
8000d97a:	10 37       	cp.w	r7,r8
8000d97c:	f7 bb 09 ff 	subgt	r11,-1
8000d980:	cb 6e       	rcall	8000d6ec <_Balloc>
8000d982:	ee c4 ff fb 	sub	r4,r7,-5
8000d986:	f8 c9 ff ec 	sub	r9,r12,-20
8000d98a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000d98e:	30 0a       	mov	r10,0
8000d990:	12 98       	mov	r8,r9
8000d992:	c0 28       	rjmp	8000d996 <__multiply+0x42>
8000d994:	10 aa       	st.w	r8++,r10
8000d996:	08 38       	cp.w	r8,r4
8000d998:	cf e3       	brcs	8000d994 <__multiply+0x40>
8000d99a:	2f b3       	sub	r3,-5
8000d99c:	2f b2       	sub	r2,-5
8000d99e:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000d9a2:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000d9a6:	ec cb ff ec 	sub	r11,r6,-20
8000d9aa:	50 12       	stdsp	sp[0x4],r2
8000d9ac:	ea ca ff ec 	sub	r10,r5,-20
8000d9b0:	c4 48       	rjmp	8000da38 <__multiply+0xe4>
8000d9b2:	94 95       	ld.uh	r5,r10[0x2]
8000d9b4:	58 05       	cp.w	r5,0
8000d9b6:	c2 00       	breq	8000d9f6 <__multiply+0xa2>
8000d9b8:	12 98       	mov	r8,r9
8000d9ba:	16 96       	mov	r6,r11
8000d9bc:	30 0e       	mov	lr,0
8000d9be:	50 09       	stdsp	sp[0x0],r9
8000d9c0:	0d 02       	ld.w	r2,r6++
8000d9c2:	e4 00 16 10 	lsr	r0,r2,0x10
8000d9c6:	70 01       	ld.w	r1,r8[0x0]
8000d9c8:	70 09       	ld.w	r9,r8[0x0]
8000d9ca:	b1 81       	lsr	r1,0x10
8000d9cc:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000d9d0:	e0 05 03 41 	mac	r1,r0,r5
8000d9d4:	ab 32       	mul	r2,r5
8000d9d6:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000d9da:	00 02       	add	r2,r0
8000d9dc:	e4 0e 00 0e 	add	lr,r2,lr
8000d9e0:	b0 1e       	st.h	r8[0x2],lr
8000d9e2:	b1 8e       	lsr	lr,0x10
8000d9e4:	1c 01       	add	r1,lr
8000d9e6:	b0 01       	st.h	r8[0x0],r1
8000d9e8:	e2 0e 16 10 	lsr	lr,r1,0x10
8000d9ec:	2f c8       	sub	r8,-4
8000d9ee:	06 36       	cp.w	r6,r3
8000d9f0:	ce 83       	brcs	8000d9c0 <__multiply+0x6c>
8000d9f2:	40 09       	lddsp	r9,sp[0x0]
8000d9f4:	91 0e       	st.w	r8[0x0],lr
8000d9f6:	94 86       	ld.uh	r6,r10[0x0]
8000d9f8:	58 06       	cp.w	r6,0
8000d9fa:	c1 d0       	breq	8000da34 <__multiply+0xe0>
8000d9fc:	72 02       	ld.w	r2,r9[0x0]
8000d9fe:	12 98       	mov	r8,r9
8000da00:	16 9e       	mov	lr,r11
8000da02:	30 05       	mov	r5,0
8000da04:	b0 12       	st.h	r8[0x2],r2
8000da06:	1d 01       	ld.w	r1,lr++
8000da08:	90 82       	ld.uh	r2,r8[0x0]
8000da0a:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000da0e:	ad 30       	mul	r0,r6
8000da10:	e0 02 00 02 	add	r2,r0,r2
8000da14:	e4 05 00 05 	add	r5,r2,r5
8000da18:	b0 05       	st.h	r8[0x0],r5
8000da1a:	b1 85       	lsr	r5,0x10
8000da1c:	b1 81       	lsr	r1,0x10
8000da1e:	2f c8       	sub	r8,-4
8000da20:	ad 31       	mul	r1,r6
8000da22:	90 92       	ld.uh	r2,r8[0x2]
8000da24:	e2 02 00 02 	add	r2,r1,r2
8000da28:	0a 02       	add	r2,r5
8000da2a:	e4 05 16 10 	lsr	r5,r2,0x10
8000da2e:	06 3e       	cp.w	lr,r3
8000da30:	ce a3       	brcs	8000da04 <__multiply+0xb0>
8000da32:	91 02       	st.w	r8[0x0],r2
8000da34:	2f ca       	sub	r10,-4
8000da36:	2f c9       	sub	r9,-4
8000da38:	40 18       	lddsp	r8,sp[0x4]
8000da3a:	10 3a       	cp.w	r10,r8
8000da3c:	cb b3       	brcs	8000d9b2 <__multiply+0x5e>
8000da3e:	c0 28       	rjmp	8000da42 <__multiply+0xee>
8000da40:	20 17       	sub	r7,1
8000da42:	58 07       	cp.w	r7,0
8000da44:	e0 8a 00 05 	brle	8000da4e <__multiply+0xfa>
8000da48:	09 48       	ld.w	r8,--r4
8000da4a:	58 08       	cp.w	r8,0
8000da4c:	cf a0       	breq	8000da40 <__multiply+0xec>
8000da4e:	99 47       	st.w	r12[0x10],r7
8000da50:	2f ed       	sub	sp,-8
8000da52:	d8 32       	popm	r0-r7,pc

8000da54 <__i2b>:
8000da54:	d4 21       	pushm	r4-r7,lr
8000da56:	16 97       	mov	r7,r11
8000da58:	30 1b       	mov	r11,1
8000da5a:	c4 9e       	rcall	8000d6ec <_Balloc>
8000da5c:	30 19       	mov	r9,1
8000da5e:	99 57       	st.w	r12[0x14],r7
8000da60:	99 49       	st.w	r12[0x10],r9
8000da62:	d8 22       	popm	r4-r7,pc

8000da64 <__multadd>:
8000da64:	d4 31       	pushm	r0-r7,lr
8000da66:	30 08       	mov	r8,0
8000da68:	12 95       	mov	r5,r9
8000da6a:	16 97       	mov	r7,r11
8000da6c:	18 96       	mov	r6,r12
8000da6e:	76 44       	ld.w	r4,r11[0x10]
8000da70:	f6 c9 ff ec 	sub	r9,r11,-20
8000da74:	72 0b       	ld.w	r11,r9[0x0]
8000da76:	f6 0c 16 10 	lsr	r12,r11,0x10
8000da7a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000da7e:	f4 0c 02 4c 	mul	r12,r10,r12
8000da82:	f4 0b 03 45 	mac	r5,r10,r11
8000da86:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000da8a:	b1 85       	lsr	r5,0x10
8000da8c:	18 05       	add	r5,r12
8000da8e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000da92:	f8 0b 00 0b 	add	r11,r12,r11
8000da96:	12 ab       	st.w	r9++,r11
8000da98:	2f f8       	sub	r8,-1
8000da9a:	b1 85       	lsr	r5,0x10
8000da9c:	08 38       	cp.w	r8,r4
8000da9e:	ce b5       	brlt	8000da74 <__multadd+0x10>
8000daa0:	58 05       	cp.w	r5,0
8000daa2:	c1 c0       	breq	8000dada <__multadd+0x76>
8000daa4:	6e 28       	ld.w	r8,r7[0x8]
8000daa6:	10 34       	cp.w	r4,r8
8000daa8:	c1 35       	brlt	8000dace <__multadd+0x6a>
8000daaa:	6e 1b       	ld.w	r11,r7[0x4]
8000daac:	0c 9c       	mov	r12,r6
8000daae:	2f fb       	sub	r11,-1
8000dab0:	c1 ee       	rcall	8000d6ec <_Balloc>
8000dab2:	6e 4a       	ld.w	r10,r7[0x10]
8000dab4:	ee cb ff f4 	sub	r11,r7,-12
8000dab8:	18 93       	mov	r3,r12
8000daba:	2f ea       	sub	r10,-2
8000dabc:	2f 4c       	sub	r12,-12
8000dabe:	a3 6a       	lsl	r10,0x2
8000dac0:	fe b0 de 64 	rcall	80009788 <memcpy>
8000dac4:	0e 9b       	mov	r11,r7
8000dac6:	0c 9c       	mov	r12,r6
8000dac8:	fe b0 fd f8 	rcall	8000d6b8 <_Bfree>
8000dacc:	06 97       	mov	r7,r3
8000dace:	e8 c8 ff ff 	sub	r8,r4,-1
8000dad2:	2f b4       	sub	r4,-5
8000dad4:	8f 48       	st.w	r7[0x10],r8
8000dad6:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000dada:	0e 9c       	mov	r12,r7
8000dadc:	d8 32       	popm	r0-r7,pc
8000dade:	d7 03       	nop

8000dae0 <__pow5mult>:
8000dae0:	d4 31       	pushm	r0-r7,lr
8000dae2:	14 96       	mov	r6,r10
8000dae4:	18 97       	mov	r7,r12
8000dae6:	16 94       	mov	r4,r11
8000dae8:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000daec:	c0 90       	breq	8000dafe <__pow5mult+0x1e>
8000daee:	20 18       	sub	r8,1
8000daf0:	fe c9 e2 a0 	sub	r9,pc,-7520
8000daf4:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000daf8:	30 09       	mov	r9,0
8000dafa:	cb 5f       	rcall	8000da64 <__multadd>
8000dafc:	18 94       	mov	r4,r12
8000dafe:	a3 46       	asr	r6,0x2
8000db00:	c3 40       	breq	8000db68 <__pow5mult+0x88>
8000db02:	6e 95       	ld.w	r5,r7[0x24]
8000db04:	58 05       	cp.w	r5,0
8000db06:	c0 91       	brne	8000db18 <__pow5mult+0x38>
8000db08:	31 0c       	mov	r12,16
8000db0a:	fe b0 dc 1b 	rcall	80009340 <malloc>
8000db0e:	99 35       	st.w	r12[0xc],r5
8000db10:	8f 9c       	st.w	r7[0x24],r12
8000db12:	99 15       	st.w	r12[0x4],r5
8000db14:	99 25       	st.w	r12[0x8],r5
8000db16:	99 05       	st.w	r12[0x0],r5
8000db18:	6e 93       	ld.w	r3,r7[0x24]
8000db1a:	66 25       	ld.w	r5,r3[0x8]
8000db1c:	58 05       	cp.w	r5,0
8000db1e:	c0 c1       	brne	8000db36 <__pow5mult+0x56>
8000db20:	e0 6b 02 71 	mov	r11,625
8000db24:	0e 9c       	mov	r12,r7
8000db26:	c9 7f       	rcall	8000da54 <__i2b>
8000db28:	87 2c       	st.w	r3[0x8],r12
8000db2a:	30 08       	mov	r8,0
8000db2c:	18 95       	mov	r5,r12
8000db2e:	99 08       	st.w	r12[0x0],r8
8000db30:	c0 38       	rjmp	8000db36 <__pow5mult+0x56>
8000db32:	06 9c       	mov	r12,r3
8000db34:	18 95       	mov	r5,r12
8000db36:	ed b6 00 00 	bld	r6,0x0
8000db3a:	c0 b1       	brne	8000db50 <__pow5mult+0x70>
8000db3c:	08 9b       	mov	r11,r4
8000db3e:	0a 9a       	mov	r10,r5
8000db40:	0e 9c       	mov	r12,r7
8000db42:	c0 9f       	rcall	8000d954 <__multiply>
8000db44:	08 9b       	mov	r11,r4
8000db46:	18 93       	mov	r3,r12
8000db48:	0e 9c       	mov	r12,r7
8000db4a:	06 94       	mov	r4,r3
8000db4c:	fe b0 fd b6 	rcall	8000d6b8 <_Bfree>
8000db50:	a1 56       	asr	r6,0x1
8000db52:	c0 b0       	breq	8000db68 <__pow5mult+0x88>
8000db54:	6a 03       	ld.w	r3,r5[0x0]
8000db56:	58 03       	cp.w	r3,0
8000db58:	ce d1       	brne	8000db32 <__pow5mult+0x52>
8000db5a:	0a 9a       	mov	r10,r5
8000db5c:	0a 9b       	mov	r11,r5
8000db5e:	0e 9c       	mov	r12,r7
8000db60:	cf ae       	rcall	8000d954 <__multiply>
8000db62:	8b 0c       	st.w	r5[0x0],r12
8000db64:	99 03       	st.w	r12[0x0],r3
8000db66:	ce 7b       	rjmp	8000db34 <__pow5mult+0x54>
8000db68:	08 9c       	mov	r12,r4
8000db6a:	d8 32       	popm	r0-r7,pc

8000db6c <__isinfd>:
8000db6c:	14 98       	mov	r8,r10
8000db6e:	fc 19 7f f0 	movh	r9,0x7ff0
8000db72:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000db76:	f0 0b 11 00 	rsub	r11,r8,0
8000db7a:	f7 e8 10 08 	or	r8,r11,r8
8000db7e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000db82:	f2 08 01 08 	sub	r8,r9,r8
8000db86:	f0 0c 11 00 	rsub	r12,r8,0
8000db8a:	f9 e8 10 08 	or	r8,r12,r8
8000db8e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000db92:	2f fc       	sub	r12,-1
8000db94:	5e fc       	retal	r12

8000db96 <__isnand>:
8000db96:	14 98       	mov	r8,r10
8000db98:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000db9c:	f0 0c 11 00 	rsub	r12,r8,0
8000dba0:	10 4c       	or	r12,r8
8000dba2:	fc 18 7f f0 	movh	r8,0x7ff0
8000dba6:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000dbaa:	f0 0c 01 0c 	sub	r12,r8,r12
8000dbae:	bf 9c       	lsr	r12,0x1f
8000dbb0:	5e fc       	retal	r12
8000dbb2:	d7 03       	nop

8000dbb4 <__sclose>:
8000dbb4:	d4 01       	pushm	lr
8000dbb6:	96 7b       	ld.sh	r11,r11[0xe]
8000dbb8:	c7 6c       	rcall	8000dca4 <_close_r>
8000dbba:	d8 02       	popm	pc

8000dbbc <__sseek>:
8000dbbc:	d4 21       	pushm	r4-r7,lr
8000dbbe:	16 97       	mov	r7,r11
8000dbc0:	96 7b       	ld.sh	r11,r11[0xe]
8000dbc2:	cf 7c       	rcall	8000ddb0 <_lseek_r>
8000dbc4:	8e 68       	ld.sh	r8,r7[0xc]
8000dbc6:	10 99       	mov	r9,r8
8000dbc8:	ad c8       	cbr	r8,0xc
8000dbca:	ad a9       	sbr	r9,0xc
8000dbcc:	5b fc       	cp.w	r12,-1
8000dbce:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000dbd2:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000dbd6:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000dbda:	d8 22       	popm	r4-r7,pc

8000dbdc <__swrite>:
8000dbdc:	d4 21       	pushm	r4-r7,lr
8000dbde:	96 68       	ld.sh	r8,r11[0xc]
8000dbe0:	16 97       	mov	r7,r11
8000dbe2:	14 95       	mov	r5,r10
8000dbe4:	12 94       	mov	r4,r9
8000dbe6:	e2 18 01 00 	andl	r8,0x100,COH
8000dbea:	18 96       	mov	r6,r12
8000dbec:	c0 50       	breq	8000dbf6 <__swrite+0x1a>
8000dbee:	30 29       	mov	r9,2
8000dbf0:	30 0a       	mov	r10,0
8000dbf2:	96 7b       	ld.sh	r11,r11[0xe]
8000dbf4:	cd ec       	rcall	8000ddb0 <_lseek_r>
8000dbf6:	8e 68       	ld.sh	r8,r7[0xc]
8000dbf8:	ad c8       	cbr	r8,0xc
8000dbfa:	08 99       	mov	r9,r4
8000dbfc:	0a 9a       	mov	r10,r5
8000dbfe:	8e 7b       	ld.sh	r11,r7[0xe]
8000dc00:	0c 9c       	mov	r12,r6
8000dc02:	ae 68       	st.h	r7[0xc],r8
8000dc04:	c1 0c       	rcall	8000dc24 <_write_r>
8000dc06:	d8 22       	popm	r4-r7,pc

8000dc08 <__sread>:
8000dc08:	d4 21       	pushm	r4-r7,lr
8000dc0a:	16 97       	mov	r7,r11
8000dc0c:	96 7b       	ld.sh	r11,r11[0xe]
8000dc0e:	ce 5c       	rcall	8000ddd8 <_read_r>
8000dc10:	c0 65       	brlt	8000dc1c <__sread+0x14>
8000dc12:	6f 58       	ld.w	r8,r7[0x54]
8000dc14:	18 08       	add	r8,r12
8000dc16:	ef 48 00 54 	st.w	r7[84],r8
8000dc1a:	d8 22       	popm	r4-r7,pc
8000dc1c:	8e 68       	ld.sh	r8,r7[0xc]
8000dc1e:	ad c8       	cbr	r8,0xc
8000dc20:	ae 68       	st.h	r7[0xc],r8
8000dc22:	d8 22       	popm	r4-r7,pc

8000dc24 <_write_r>:
8000dc24:	d4 21       	pushm	r4-r7,lr
8000dc26:	16 98       	mov	r8,r11
8000dc28:	18 97       	mov	r7,r12
8000dc2a:	10 9c       	mov	r12,r8
8000dc2c:	30 08       	mov	r8,0
8000dc2e:	14 9b       	mov	r11,r10
8000dc30:	e0 66 40 f4 	mov	r6,16628
8000dc34:	12 9a       	mov	r10,r9
8000dc36:	8d 08       	st.w	r6[0x0],r8
8000dc38:	fe b0 cb 42 	rcall	800072bc <_write>
8000dc3c:	5b fc       	cp.w	r12,-1
8000dc3e:	c0 51       	brne	8000dc48 <_write_r+0x24>
8000dc40:	6c 08       	ld.w	r8,r6[0x0]
8000dc42:	58 08       	cp.w	r8,0
8000dc44:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000dc48:	d8 22       	popm	r4-r7,pc
8000dc4a:	d7 03       	nop

8000dc4c <_calloc_r>:
8000dc4c:	d4 21       	pushm	r4-r7,lr
8000dc4e:	f4 0b 02 4b 	mul	r11,r10,r11
8000dc52:	fe b0 db 7f 	rcall	80009350 <_malloc_r>
8000dc56:	18 97       	mov	r7,r12
8000dc58:	c2 30       	breq	8000dc9e <_calloc_r+0x52>
8000dc5a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000dc5e:	e0 1a ff fc 	andl	r10,0xfffc
8000dc62:	20 4a       	sub	r10,4
8000dc64:	e0 4a 00 24 	cp.w	r10,36
8000dc68:	e0 8b 00 18 	brhi	8000dc98 <_calloc_r+0x4c>
8000dc6c:	18 98       	mov	r8,r12
8000dc6e:	59 3a       	cp.w	r10,19
8000dc70:	e0 88 00 0f 	brls	8000dc8e <_calloc_r+0x42>
8000dc74:	30 09       	mov	r9,0
8000dc76:	10 a9       	st.w	r8++,r9
8000dc78:	10 a9       	st.w	r8++,r9
8000dc7a:	59 ba       	cp.w	r10,27
8000dc7c:	e0 88 00 09 	brls	8000dc8e <_calloc_r+0x42>
8000dc80:	10 a9       	st.w	r8++,r9
8000dc82:	10 a9       	st.w	r8++,r9
8000dc84:	e0 4a 00 24 	cp.w	r10,36
8000dc88:	c0 31       	brne	8000dc8e <_calloc_r+0x42>
8000dc8a:	10 a9       	st.w	r8++,r9
8000dc8c:	10 a9       	st.w	r8++,r9
8000dc8e:	30 09       	mov	r9,0
8000dc90:	10 a9       	st.w	r8++,r9
8000dc92:	91 19       	st.w	r8[0x4],r9
8000dc94:	91 09       	st.w	r8[0x0],r9
8000dc96:	c0 48       	rjmp	8000dc9e <_calloc_r+0x52>
8000dc98:	30 0b       	mov	r11,0
8000dc9a:	fe b0 de 1b 	rcall	800098d0 <memset>
8000dc9e:	0e 9c       	mov	r12,r7
8000dca0:	d8 22       	popm	r4-r7,pc
8000dca2:	d7 03       	nop

8000dca4 <_close_r>:
8000dca4:	d4 21       	pushm	r4-r7,lr
8000dca6:	30 08       	mov	r8,0
8000dca8:	18 97       	mov	r7,r12
8000dcaa:	e0 66 40 f4 	mov	r6,16628
8000dcae:	16 9c       	mov	r12,r11
8000dcb0:	8d 08       	st.w	r6[0x0],r8
8000dcb2:	fe b0 df c1 	rcall	80009c34 <_close>
8000dcb6:	5b fc       	cp.w	r12,-1
8000dcb8:	c0 51       	brne	8000dcc2 <_close_r+0x1e>
8000dcba:	6c 08       	ld.w	r8,r6[0x0]
8000dcbc:	58 08       	cp.w	r8,0
8000dcbe:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000dcc2:	d8 22       	popm	r4-r7,pc

8000dcc4 <_fclose_r>:
8000dcc4:	d4 21       	pushm	r4-r7,lr
8000dcc6:	18 96       	mov	r6,r12
8000dcc8:	16 97       	mov	r7,r11
8000dcca:	58 0b       	cp.w	r11,0
8000dccc:	c0 31       	brne	8000dcd2 <_fclose_r+0xe>
8000dcce:	16 95       	mov	r5,r11
8000dcd0:	c5 38       	rjmp	8000dd76 <_fclose_r+0xb2>
8000dcd2:	fe b0 f8 b5 	rcall	8000ce3c <__sfp_lock_acquire>
8000dcd6:	58 06       	cp.w	r6,0
8000dcd8:	c0 70       	breq	8000dce6 <_fclose_r+0x22>
8000dcda:	6c 68       	ld.w	r8,r6[0x18]
8000dcdc:	58 08       	cp.w	r8,0
8000dcde:	c0 41       	brne	8000dce6 <_fclose_r+0x22>
8000dce0:	0c 9c       	mov	r12,r6
8000dce2:	fe b0 f8 ff 	rcall	8000cee0 <__sinit>
8000dce6:	fe c8 e5 3e 	sub	r8,pc,-6850
8000dcea:	10 37       	cp.w	r7,r8
8000dcec:	c0 31       	brne	8000dcf2 <_fclose_r+0x2e>
8000dcee:	6c 07       	ld.w	r7,r6[0x0]
8000dcf0:	c0 c8       	rjmp	8000dd08 <_fclose_r+0x44>
8000dcf2:	fe c8 e5 2a 	sub	r8,pc,-6870
8000dcf6:	10 37       	cp.w	r7,r8
8000dcf8:	c0 31       	brne	8000dcfe <_fclose_r+0x3a>
8000dcfa:	6c 17       	ld.w	r7,r6[0x4]
8000dcfc:	c0 68       	rjmp	8000dd08 <_fclose_r+0x44>
8000dcfe:	fe c8 e5 16 	sub	r8,pc,-6890
8000dd02:	10 37       	cp.w	r7,r8
8000dd04:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000dd08:	8e 69       	ld.sh	r9,r7[0xc]
8000dd0a:	30 08       	mov	r8,0
8000dd0c:	f0 09 19 00 	cp.h	r9,r8
8000dd10:	c0 51       	brne	8000dd1a <_fclose_r+0x56>
8000dd12:	fe b0 f8 96 	rcall	8000ce3e <__sfp_lock_release>
8000dd16:	30 05       	mov	r5,0
8000dd18:	c2 f8       	rjmp	8000dd76 <_fclose_r+0xb2>
8000dd1a:	0e 9b       	mov	r11,r7
8000dd1c:	0c 9c       	mov	r12,r6
8000dd1e:	fe b0 f8 09 	rcall	8000cd30 <_fflush_r>
8000dd22:	6e c8       	ld.w	r8,r7[0x30]
8000dd24:	18 95       	mov	r5,r12
8000dd26:	58 08       	cp.w	r8,0
8000dd28:	c0 60       	breq	8000dd34 <_fclose_r+0x70>
8000dd2a:	6e 8b       	ld.w	r11,r7[0x20]
8000dd2c:	0c 9c       	mov	r12,r6
8000dd2e:	5d 18       	icall	r8
8000dd30:	f9 b5 05 ff 	movlt	r5,-1
8000dd34:	8e 68       	ld.sh	r8,r7[0xc]
8000dd36:	ed b8 00 07 	bld	r8,0x7
8000dd3a:	c0 51       	brne	8000dd44 <_fclose_r+0x80>
8000dd3c:	6e 4b       	ld.w	r11,r7[0x10]
8000dd3e:	0c 9c       	mov	r12,r6
8000dd40:	fe b0 f9 6a 	rcall	8000d014 <_free_r>
8000dd44:	6e db       	ld.w	r11,r7[0x34]
8000dd46:	58 0b       	cp.w	r11,0
8000dd48:	c0 a0       	breq	8000dd5c <_fclose_r+0x98>
8000dd4a:	ee c8 ff bc 	sub	r8,r7,-68
8000dd4e:	10 3b       	cp.w	r11,r8
8000dd50:	c0 40       	breq	8000dd58 <_fclose_r+0x94>
8000dd52:	0c 9c       	mov	r12,r6
8000dd54:	fe b0 f9 60 	rcall	8000d014 <_free_r>
8000dd58:	30 08       	mov	r8,0
8000dd5a:	8f d8       	st.w	r7[0x34],r8
8000dd5c:	6f 2b       	ld.w	r11,r7[0x48]
8000dd5e:	58 0b       	cp.w	r11,0
8000dd60:	c0 70       	breq	8000dd6e <_fclose_r+0xaa>
8000dd62:	0c 9c       	mov	r12,r6
8000dd64:	fe b0 f9 58 	rcall	8000d014 <_free_r>
8000dd68:	30 08       	mov	r8,0
8000dd6a:	ef 48 00 48 	st.w	r7[72],r8
8000dd6e:	30 08       	mov	r8,0
8000dd70:	ae 68       	st.h	r7[0xc],r8
8000dd72:	fe b0 f8 66 	rcall	8000ce3e <__sfp_lock_release>
8000dd76:	0a 9c       	mov	r12,r5
8000dd78:	d8 22       	popm	r4-r7,pc
8000dd7a:	d7 03       	nop

8000dd7c <fclose>:
8000dd7c:	d4 01       	pushm	lr
8000dd7e:	e0 68 0a 30 	mov	r8,2608
8000dd82:	18 9b       	mov	r11,r12
8000dd84:	70 0c       	ld.w	r12,r8[0x0]
8000dd86:	c9 ff       	rcall	8000dcc4 <_fclose_r>
8000dd88:	d8 02       	popm	pc
8000dd8a:	d7 03       	nop

8000dd8c <_fstat_r>:
8000dd8c:	d4 21       	pushm	r4-r7,lr
8000dd8e:	16 98       	mov	r8,r11
8000dd90:	18 97       	mov	r7,r12
8000dd92:	10 9c       	mov	r12,r8
8000dd94:	30 08       	mov	r8,0
8000dd96:	e0 66 40 f4 	mov	r6,16628
8000dd9a:	14 9b       	mov	r11,r10
8000dd9c:	8d 08       	st.w	r6[0x0],r8
8000dd9e:	fe b0 df 73 	rcall	80009c84 <_fstat>
8000dda2:	5b fc       	cp.w	r12,-1
8000dda4:	c0 51       	brne	8000ddae <_fstat_r+0x22>
8000dda6:	6c 08       	ld.w	r8,r6[0x0]
8000dda8:	58 08       	cp.w	r8,0
8000ddaa:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ddae:	d8 22       	popm	r4-r7,pc

8000ddb0 <_lseek_r>:
8000ddb0:	d4 21       	pushm	r4-r7,lr
8000ddb2:	16 98       	mov	r8,r11
8000ddb4:	18 97       	mov	r7,r12
8000ddb6:	10 9c       	mov	r12,r8
8000ddb8:	30 08       	mov	r8,0
8000ddba:	14 9b       	mov	r11,r10
8000ddbc:	e0 66 40 f4 	mov	r6,16628
8000ddc0:	12 9a       	mov	r10,r9
8000ddc2:	8d 08       	st.w	r6[0x0],r8
8000ddc4:	fe b0 df 42 	rcall	80009c48 <_lseek>
8000ddc8:	5b fc       	cp.w	r12,-1
8000ddca:	c0 51       	brne	8000ddd4 <_lseek_r+0x24>
8000ddcc:	6c 08       	ld.w	r8,r6[0x0]
8000ddce:	58 08       	cp.w	r8,0
8000ddd0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ddd4:	d8 22       	popm	r4-r7,pc
8000ddd6:	d7 03       	nop

8000ddd8 <_read_r>:
8000ddd8:	d4 21       	pushm	r4-r7,lr
8000ddda:	16 98       	mov	r8,r11
8000dddc:	18 97       	mov	r7,r12
8000ddde:	10 9c       	mov	r12,r8
8000dde0:	30 08       	mov	r8,0
8000dde2:	14 9b       	mov	r11,r10
8000dde4:	e0 66 40 f4 	mov	r6,16628
8000dde8:	12 9a       	mov	r10,r9
8000ddea:	8d 08       	st.w	r6[0x0],r8
8000ddec:	fe b0 ca 22 	rcall	80007230 <_read>
8000ddf0:	5b fc       	cp.w	r12,-1
8000ddf2:	c0 51       	brne	8000ddfc <_read_r+0x24>
8000ddf4:	6c 08       	ld.w	r8,r6[0x0]
8000ddf6:	58 08       	cp.w	r8,0
8000ddf8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ddfc:	d8 22       	popm	r4-r7,pc
8000ddfe:	d7 03       	nop

8000de00 <__avr32_f64_mul>:
8000de00:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000de04:	e0 80 00 dc 	breq	8000dfbc <__avr32_f64_mul_op1_zero>
8000de08:	d4 21       	pushm	r4-r7,lr
8000de0a:	f7 e9 20 0e 	eor	lr,r11,r9
8000de0e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000de12:	30 15       	mov	r5,1
8000de14:	c4 30       	breq	8000de9a <__avr32_f64_mul_op1_subnormal>
8000de16:	ab 6b       	lsl	r11,0xa
8000de18:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000de1c:	ab 6a       	lsl	r10,0xa
8000de1e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000de22:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000de26:	c5 c0       	breq	8000dede <__avr32_f64_mul_op2_subnormal>
8000de28:	a1 78       	lsl	r8,0x1
8000de2a:	5c f9       	rol	r9
8000de2c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000de30:	e0 47 07 ff 	cp.w	r7,2047
8000de34:	c7 70       	breq	8000df22 <__avr32_f64_mul_op_nan_or_inf>
8000de36:	e0 46 07 ff 	cp.w	r6,2047
8000de3a:	c7 40       	breq	8000df22 <__avr32_f64_mul_op_nan_or_inf>
8000de3c:	ee 06 00 0c 	add	r12,r7,r6
8000de40:	e0 2c 03 fe 	sub	r12,1022
8000de44:	f6 08 06 44 	mulu.d	r4,r11,r8
8000de48:	f4 09 07 44 	macu.d	r4,r10,r9
8000de4c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000de50:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000de54:	08 07       	add	r7,r4
8000de56:	f4 05 00 4a 	adc	r10,r10,r5
8000de5a:	5c 0b       	acr	r11
8000de5c:	ed bb 00 14 	bld	r11,0x14
8000de60:	c0 50       	breq	8000de6a <__avr32_f64_mul+0x6a>
8000de62:	a1 77       	lsl	r7,0x1
8000de64:	5c fa       	rol	r10
8000de66:	5c fb       	rol	r11
8000de68:	20 1c       	sub	r12,1
8000de6a:	58 0c       	cp.w	r12,0
8000de6c:	e0 8a 00 6f 	brle	8000df4a <__avr32_f64_mul_res_subnormal>
8000de70:	e0 4c 07 ff 	cp.w	r12,2047
8000de74:	e0 84 00 9c 	brge	8000dfac <__avr32_f64_mul_res_inf>
8000de78:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000de7c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000de80:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000de84:	ee 17 80 00 	eorh	r7,0x8000
8000de88:	f1 b7 04 20 	satu	r7,0x1
8000de8c:	0e 0a       	add	r10,r7
8000de8e:	5c 0b       	acr	r11
8000de90:	ed be 00 1f 	bld	lr,0x1f
8000de94:	ef bb 00 1f 	bst	r11,0x1f
8000de98:	d8 22       	popm	r4-r7,pc

8000de9a <__avr32_f64_mul_op1_subnormal>:
8000de9a:	e4 1b 00 0f 	andh	r11,0xf
8000de9e:	f4 0c 12 00 	clz	r12,r10
8000dea2:	f6 06 12 00 	clz	r6,r11
8000dea6:	f7 bc 03 e1 	sublo	r12,-31
8000deaa:	f8 06 17 30 	movlo	r6,r12
8000deae:	f7 b6 02 01 	subhs	r6,1
8000deb2:	e0 46 00 20 	cp.w	r6,32
8000deb6:	c0 d4       	brge	8000ded0 <__avr32_f64_mul_op1_subnormal+0x36>
8000deb8:	ec 0c 11 20 	rsub	r12,r6,32
8000debc:	f6 06 09 4b 	lsl	r11,r11,r6
8000dec0:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000dec4:	18 4b       	or	r11,r12
8000dec6:	f4 06 09 4a 	lsl	r10,r10,r6
8000deca:	20 b6       	sub	r6,11
8000decc:	0c 17       	sub	r7,r6
8000dece:	ca ab       	rjmp	8000de22 <__avr32_f64_mul+0x22>
8000ded0:	f4 06 09 4b 	lsl	r11,r10,r6
8000ded4:	c6 40       	breq	8000df9c <__avr32_f64_mul_res_zero>
8000ded6:	30 0a       	mov	r10,0
8000ded8:	20 b6       	sub	r6,11
8000deda:	0c 17       	sub	r7,r6
8000dedc:	ca 3b       	rjmp	8000de22 <__avr32_f64_mul+0x22>

8000dede <__avr32_f64_mul_op2_subnormal>:
8000dede:	e4 19 00 0f 	andh	r9,0xf
8000dee2:	f0 0c 12 00 	clz	r12,r8
8000dee6:	f2 05 12 00 	clz	r5,r9
8000deea:	f7 bc 03 ea 	sublo	r12,-22
8000deee:	f8 05 17 30 	movlo	r5,r12
8000def2:	f7 b5 02 0a 	subhs	r5,10
8000def6:	e0 45 00 20 	cp.w	r5,32
8000defa:	c0 d4       	brge	8000df14 <__avr32_f64_mul_op2_subnormal+0x36>
8000defc:	ea 0c 11 20 	rsub	r12,r5,32
8000df00:	f2 05 09 49 	lsl	r9,r9,r5
8000df04:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000df08:	18 49       	or	r9,r12
8000df0a:	f0 05 09 48 	lsl	r8,r8,r5
8000df0e:	20 25       	sub	r5,2
8000df10:	0a 16       	sub	r6,r5
8000df12:	c8 fb       	rjmp	8000de30 <__avr32_f64_mul+0x30>
8000df14:	f0 05 09 49 	lsl	r9,r8,r5
8000df18:	c4 20       	breq	8000df9c <__avr32_f64_mul_res_zero>
8000df1a:	30 08       	mov	r8,0
8000df1c:	20 25       	sub	r5,2
8000df1e:	0a 16       	sub	r6,r5
8000df20:	c8 8b       	rjmp	8000de30 <__avr32_f64_mul+0x30>

8000df22 <__avr32_f64_mul_op_nan_or_inf>:
8000df22:	e4 19 00 0f 	andh	r9,0xf
8000df26:	e4 1b 00 0f 	andh	r11,0xf
8000df2a:	14 4b       	or	r11,r10
8000df2c:	10 49       	or	r9,r8
8000df2e:	e0 47 07 ff 	cp.w	r7,2047
8000df32:	c0 91       	brne	8000df44 <__avr32_f64_mul_op1_not_naninf>
8000df34:	58 0b       	cp.w	r11,0
8000df36:	c3 81       	brne	8000dfa6 <__avr32_f64_mul_res_nan>
8000df38:	e0 46 07 ff 	cp.w	r6,2047
8000df3c:	c3 81       	brne	8000dfac <__avr32_f64_mul_res_inf>
8000df3e:	58 09       	cp.w	r9,0
8000df40:	c3 60       	breq	8000dfac <__avr32_f64_mul_res_inf>
8000df42:	c3 28       	rjmp	8000dfa6 <__avr32_f64_mul_res_nan>

8000df44 <__avr32_f64_mul_op1_not_naninf>:
8000df44:	58 09       	cp.w	r9,0
8000df46:	c3 30       	breq	8000dfac <__avr32_f64_mul_res_inf>
8000df48:	c2 f8       	rjmp	8000dfa6 <__avr32_f64_mul_res_nan>

8000df4a <__avr32_f64_mul_res_subnormal>:
8000df4a:	5c 3c       	neg	r12
8000df4c:	2f fc       	sub	r12,-1
8000df4e:	f1 bc 04 c0 	satu	r12,0x6
8000df52:	e0 4c 00 20 	cp.w	r12,32
8000df56:	c1 14       	brge	8000df78 <__avr32_f64_mul_res_subnormal+0x2e>
8000df58:	f8 08 11 20 	rsub	r8,r12,32
8000df5c:	0e 46       	or	r6,r7
8000df5e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000df62:	f4 08 09 49 	lsl	r9,r10,r8
8000df66:	12 47       	or	r7,r9
8000df68:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000df6c:	f6 08 09 49 	lsl	r9,r11,r8
8000df70:	12 4a       	or	r10,r9
8000df72:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000df76:	c8 3b       	rjmp	8000de7c <__avr32_f64_mul+0x7c>
8000df78:	f8 08 11 20 	rsub	r8,r12,32
8000df7c:	f9 b9 00 00 	moveq	r9,0
8000df80:	c0 30       	breq	8000df86 <__avr32_f64_mul_res_subnormal+0x3c>
8000df82:	f6 08 09 49 	lsl	r9,r11,r8
8000df86:	0e 46       	or	r6,r7
8000df88:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000df8c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000df90:	f3 ea 10 07 	or	r7,r9,r10
8000df94:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000df98:	30 0b       	mov	r11,0
8000df9a:	c7 1b       	rjmp	8000de7c <__avr32_f64_mul+0x7c>

8000df9c <__avr32_f64_mul_res_zero>:
8000df9c:	1c 9b       	mov	r11,lr
8000df9e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000dfa2:	30 0a       	mov	r10,0
8000dfa4:	d8 22       	popm	r4-r7,pc

8000dfa6 <__avr32_f64_mul_res_nan>:
8000dfa6:	3f fb       	mov	r11,-1
8000dfa8:	3f fa       	mov	r10,-1
8000dfaa:	d8 22       	popm	r4-r7,pc

8000dfac <__avr32_f64_mul_res_inf>:
8000dfac:	f0 6b 00 00 	mov	r11,-1048576
8000dfb0:	ed be 00 1f 	bld	lr,0x1f
8000dfb4:	ef bb 00 1f 	bst	r11,0x1f
8000dfb8:	30 0a       	mov	r10,0
8000dfba:	d8 22       	popm	r4-r7,pc

8000dfbc <__avr32_f64_mul_op1_zero>:
8000dfbc:	f7 e9 20 0b 	eor	r11,r11,r9
8000dfc0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000dfc4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000dfc8:	e0 4c 07 ff 	cp.w	r12,2047
8000dfcc:	5e 1c       	retne	r12
8000dfce:	3f fa       	mov	r10,-1
8000dfd0:	3f fb       	mov	r11,-1
8000dfd2:	5e fc       	retal	r12

8000dfd4 <__avr32_f64_sub_from_add>:
8000dfd4:	ee 19 80 00 	eorh	r9,0x8000

8000dfd8 <__avr32_f64_sub>:
8000dfd8:	f7 e9 20 0c 	eor	r12,r11,r9
8000dfdc:	e0 86 00 ca 	brmi	8000e170 <__avr32_f64_add_from_sub>
8000dfe0:	eb cd 40 e0 	pushm	r5-r7,lr
8000dfe4:	16 9c       	mov	r12,r11
8000dfe6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000dfea:	bf db       	cbr	r11,0x1f
8000dfec:	bf d9       	cbr	r9,0x1f
8000dfee:	10 3a       	cp.w	r10,r8
8000dff0:	f2 0b 13 00 	cpc	r11,r9
8000dff4:	c0 92       	brcc	8000e006 <__avr32_f64_sub+0x2e>
8000dff6:	16 97       	mov	r7,r11
8000dff8:	12 9b       	mov	r11,r9
8000dffa:	0e 99       	mov	r9,r7
8000dffc:	14 97       	mov	r7,r10
8000dffe:	10 9a       	mov	r10,r8
8000e000:	0e 98       	mov	r8,r7
8000e002:	ee 1c 80 00 	eorh	r12,0x8000
8000e006:	f6 07 16 14 	lsr	r7,r11,0x14
8000e00a:	ab 7b       	lsl	r11,0xb
8000e00c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000e010:	ab 7a       	lsl	r10,0xb
8000e012:	bf bb       	sbr	r11,0x1f
8000e014:	f2 06 16 14 	lsr	r6,r9,0x14
8000e018:	c4 40       	breq	8000e0a0 <__avr32_f64_sub_opL_subnormal>
8000e01a:	ab 79       	lsl	r9,0xb
8000e01c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000e020:	ab 78       	lsl	r8,0xb
8000e022:	bf b9       	sbr	r9,0x1f

8000e024 <__avr32_f64_sub_opL_subnormal_done>:
8000e024:	e0 47 07 ff 	cp.w	r7,2047
8000e028:	c4 f0       	breq	8000e0c6 <__avr32_f64_sub_opH_nan_or_inf>
8000e02a:	0e 26       	rsub	r6,r7
8000e02c:	c1 20       	breq	8000e050 <__avr32_f64_sub_shift_done>
8000e02e:	ec 05 11 20 	rsub	r5,r6,32
8000e032:	e0 46 00 20 	cp.w	r6,32
8000e036:	c7 c2       	brcc	8000e12e <__avr32_f64_sub_longshift>
8000e038:	f0 05 09 4e 	lsl	lr,r8,r5
8000e03c:	f2 05 09 45 	lsl	r5,r9,r5
8000e040:	f0 06 0a 48 	lsr	r8,r8,r6
8000e044:	f2 06 0a 49 	lsr	r9,r9,r6
8000e048:	0a 48       	or	r8,r5
8000e04a:	58 0e       	cp.w	lr,0
8000e04c:	5f 1e       	srne	lr
8000e04e:	1c 48       	or	r8,lr

8000e050 <__avr32_f64_sub_shift_done>:
8000e050:	10 1a       	sub	r10,r8
8000e052:	f6 09 01 4b 	sbc	r11,r11,r9
8000e056:	f6 06 12 00 	clz	r6,r11
8000e05a:	c0 e0       	breq	8000e076 <__avr32_f64_sub_longnormalize_done>
8000e05c:	c7 83       	brcs	8000e14c <__avr32_f64_sub_longnormalize>
8000e05e:	ec 0e 11 20 	rsub	lr,r6,32
8000e062:	f6 06 09 4b 	lsl	r11,r11,r6
8000e066:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000e06a:	1c 4b       	or	r11,lr
8000e06c:	f4 06 09 4a 	lsl	r10,r10,r6
8000e070:	0c 17       	sub	r7,r6
8000e072:	e0 8a 00 39 	brle	8000e0e4 <__avr32_f64_sub_subnormal_result>

8000e076 <__avr32_f64_sub_longnormalize_done>:
8000e076:	f4 09 15 15 	lsl	r9,r10,0x15
8000e07a:	ab 9a       	lsr	r10,0xb
8000e07c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000e080:	ab 9b       	lsr	r11,0xb
8000e082:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000e086:	18 4b       	or	r11,r12

8000e088 <__avr32_f64_sub_round>:
8000e088:	fc 17 80 00 	movh	r7,0x8000
8000e08c:	ed ba 00 00 	bld	r10,0x0
8000e090:	f7 b7 01 ff 	subne	r7,-1
8000e094:	0e 39       	cp.w	r9,r7
8000e096:	5f 29       	srhs	r9
8000e098:	12 0a       	add	r10,r9
8000e09a:	5c 0b       	acr	r11
8000e09c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000e0a0 <__avr32_f64_sub_opL_subnormal>:
8000e0a0:	ab 79       	lsl	r9,0xb
8000e0a2:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000e0a6:	ab 78       	lsl	r8,0xb
8000e0a8:	f3 e8 10 0e 	or	lr,r9,r8
8000e0ac:	f9 b6 01 01 	movne	r6,1
8000e0b0:	ee 0e 11 00 	rsub	lr,r7,0
8000e0b4:	f9 b7 00 01 	moveq	r7,1
8000e0b8:	ef bb 00 1f 	bst	r11,0x1f
8000e0bc:	f7 ea 10 0e 	or	lr,r11,r10
8000e0c0:	f9 b7 00 00 	moveq	r7,0
8000e0c4:	cb 0b       	rjmp	8000e024 <__avr32_f64_sub_opL_subnormal_done>

8000e0c6 <__avr32_f64_sub_opH_nan_or_inf>:
8000e0c6:	bf db       	cbr	r11,0x1f
8000e0c8:	f7 ea 10 0e 	or	lr,r11,r10
8000e0cc:	c0 81       	brne	8000e0dc <__avr32_f64_sub_return_nan>
8000e0ce:	e0 46 07 ff 	cp.w	r6,2047
8000e0d2:	c0 50       	breq	8000e0dc <__avr32_f64_sub_return_nan>
8000e0d4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000e0d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000e0dc <__avr32_f64_sub_return_nan>:
8000e0dc:	3f fa       	mov	r10,-1
8000e0de:	3f fb       	mov	r11,-1
8000e0e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000e0e4 <__avr32_f64_sub_subnormal_result>:
8000e0e4:	5c 37       	neg	r7
8000e0e6:	2f f7       	sub	r7,-1
8000e0e8:	f1 b7 04 c0 	satu	r7,0x6
8000e0ec:	e0 47 00 20 	cp.w	r7,32
8000e0f0:	c1 14       	brge	8000e112 <__avr32_f64_sub_subnormal_result+0x2e>
8000e0f2:	ee 08 11 20 	rsub	r8,r7,32
8000e0f6:	f4 08 09 49 	lsl	r9,r10,r8
8000e0fa:	5f 16       	srne	r6
8000e0fc:	f4 07 0a 4a 	lsr	r10,r10,r7
8000e100:	0c 4a       	or	r10,r6
8000e102:	f6 08 09 49 	lsl	r9,r11,r8
8000e106:	f5 e9 10 0a 	or	r10,r10,r9
8000e10a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000e10e:	30 07       	mov	r7,0
8000e110:	cb 3b       	rjmp	8000e076 <__avr32_f64_sub_longnormalize_done>
8000e112:	ee 08 11 40 	rsub	r8,r7,64
8000e116:	f6 08 09 49 	lsl	r9,r11,r8
8000e11a:	14 49       	or	r9,r10
8000e11c:	5f 16       	srne	r6
8000e11e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000e122:	0c 4a       	or	r10,r6
8000e124:	30 0b       	mov	r11,0
8000e126:	30 07       	mov	r7,0
8000e128:	ca 7b       	rjmp	8000e076 <__avr32_f64_sub_longnormalize_done>
8000e12a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000e12e <__avr32_f64_sub_longshift>:
8000e12e:	f1 b6 04 c0 	satu	r6,0x6
8000e132:	f0 0e 17 00 	moveq	lr,r8
8000e136:	c0 40       	breq	8000e13e <__avr32_f64_sub_longshift+0x10>
8000e138:	f2 05 09 4e 	lsl	lr,r9,r5
8000e13c:	10 4e       	or	lr,r8
8000e13e:	f2 06 0a 48 	lsr	r8,r9,r6
8000e142:	30 09       	mov	r9,0
8000e144:	58 0e       	cp.w	lr,0
8000e146:	5f 1e       	srne	lr
8000e148:	1c 48       	or	r8,lr
8000e14a:	c8 3b       	rjmp	8000e050 <__avr32_f64_sub_shift_done>

8000e14c <__avr32_f64_sub_longnormalize>:
8000e14c:	f4 06 12 00 	clz	r6,r10
8000e150:	f9 b7 03 00 	movlo	r7,0
8000e154:	f9 b6 03 00 	movlo	r6,0
8000e158:	f9 bc 03 00 	movlo	r12,0
8000e15c:	f7 b6 02 e0 	subhs	r6,-32
8000e160:	f4 06 09 4b 	lsl	r11,r10,r6
8000e164:	30 0a       	mov	r10,0
8000e166:	0c 17       	sub	r7,r6
8000e168:	fe 9a ff be 	brle	8000e0e4 <__avr32_f64_sub_subnormal_result>
8000e16c:	c8 5b       	rjmp	8000e076 <__avr32_f64_sub_longnormalize_done>
8000e16e:	d7 03       	nop

8000e170 <__avr32_f64_add_from_sub>:
8000e170:	ee 19 80 00 	eorh	r9,0x8000

8000e174 <__avr32_f64_add>:
8000e174:	f7 e9 20 0c 	eor	r12,r11,r9
8000e178:	fe 96 ff 2e 	brmi	8000dfd4 <__avr32_f64_sub_from_add>
8000e17c:	eb cd 40 e0 	pushm	r5-r7,lr
8000e180:	16 9c       	mov	r12,r11
8000e182:	e6 1c 80 00 	andh	r12,0x8000,COH
8000e186:	bf db       	cbr	r11,0x1f
8000e188:	bf d9       	cbr	r9,0x1f
8000e18a:	12 3b       	cp.w	r11,r9
8000e18c:	c0 72       	brcc	8000e19a <__avr32_f64_add+0x26>
8000e18e:	16 97       	mov	r7,r11
8000e190:	12 9b       	mov	r11,r9
8000e192:	0e 99       	mov	r9,r7
8000e194:	14 97       	mov	r7,r10
8000e196:	10 9a       	mov	r10,r8
8000e198:	0e 98       	mov	r8,r7
8000e19a:	30 0e       	mov	lr,0
8000e19c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000e1a0:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000e1a4:	b5 ab       	sbr	r11,0x14
8000e1a6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000e1aa:	c6 20       	breq	8000e26e <__avr32_f64_add_op2_subnormal>
8000e1ac:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000e1b0:	b5 a9       	sbr	r9,0x14
8000e1b2:	e0 47 07 ff 	cp.w	r7,2047
8000e1b6:	c2 80       	breq	8000e206 <__avr32_f64_add_opH_nan_or_inf>
8000e1b8:	0e 26       	rsub	r6,r7
8000e1ba:	c1 20       	breq	8000e1de <__avr32_f64_add_shift_done>
8000e1bc:	e0 46 00 36 	cp.w	r6,54
8000e1c0:	c1 52       	brcc	8000e1ea <__avr32_f64_add_res_of_done>
8000e1c2:	ec 05 11 20 	rsub	r5,r6,32
8000e1c6:	e0 46 00 20 	cp.w	r6,32
8000e1ca:	c3 52       	brcc	8000e234 <__avr32_f64_add_longshift>
8000e1cc:	f0 05 09 4e 	lsl	lr,r8,r5
8000e1d0:	f2 05 09 45 	lsl	r5,r9,r5
8000e1d4:	f0 06 0a 48 	lsr	r8,r8,r6
8000e1d8:	f2 06 0a 49 	lsr	r9,r9,r6
8000e1dc:	0a 48       	or	r8,r5

8000e1de <__avr32_f64_add_shift_done>:
8000e1de:	10 0a       	add	r10,r8
8000e1e0:	f6 09 00 4b 	adc	r11,r11,r9
8000e1e4:	ed bb 00 15 	bld	r11,0x15
8000e1e8:	c3 40       	breq	8000e250 <__avr32_f64_add_res_of>

8000e1ea <__avr32_f64_add_res_of_done>:
8000e1ea:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000e1ee:	18 4b       	or	r11,r12

8000e1f0 <__avr32_f64_add_round>:
8000e1f0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000e1f4:	18 4e       	or	lr,r12
8000e1f6:	ee 1e 80 00 	eorh	lr,0x8000
8000e1fa:	f1 be 04 20 	satu	lr,0x1
8000e1fe:	1c 0a       	add	r10,lr
8000e200:	5c 0b       	acr	r11
8000e202:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000e206 <__avr32_f64_add_opH_nan_or_inf>:
8000e206:	b5 cb       	cbr	r11,0x14
8000e208:	f7 ea 10 0e 	or	lr,r11,r10
8000e20c:	c1 01       	brne	8000e22c <__avr32_f64_add_return_nan>
8000e20e:	e0 46 07 ff 	cp.w	r6,2047
8000e212:	c0 30       	breq	8000e218 <__avr32_f64_add_opL_nan_or_inf>
8000e214:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000e218 <__avr32_f64_add_opL_nan_or_inf>:
8000e218:	b5 c9       	cbr	r9,0x14
8000e21a:	f3 e8 10 0e 	or	lr,r9,r8
8000e21e:	c0 71       	brne	8000e22c <__avr32_f64_add_return_nan>
8000e220:	30 0a       	mov	r10,0
8000e222:	fc 1b 7f f0 	movh	r11,0x7ff0
8000e226:	18 4b       	or	r11,r12
8000e228:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000e22c <__avr32_f64_add_return_nan>:
8000e22c:	3f fa       	mov	r10,-1
8000e22e:	3f fb       	mov	r11,-1
8000e230:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000e234 <__avr32_f64_add_longshift>:
8000e234:	f1 b6 04 c0 	satu	r6,0x6
8000e238:	f0 0e 17 00 	moveq	lr,r8
8000e23c:	c0 60       	breq	8000e248 <__avr32_f64_add_longshift+0x14>
8000e23e:	f2 05 09 4e 	lsl	lr,r9,r5
8000e242:	58 08       	cp.w	r8,0
8000e244:	5f 18       	srne	r8
8000e246:	10 4e       	or	lr,r8
8000e248:	f2 06 0a 48 	lsr	r8,r9,r6
8000e24c:	30 09       	mov	r9,0
8000e24e:	cc 8b       	rjmp	8000e1de <__avr32_f64_add_shift_done>

8000e250 <__avr32_f64_add_res_of>:
8000e250:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000e254:	a1 9b       	lsr	r11,0x1
8000e256:	5d 0a       	ror	r10
8000e258:	5d 0e       	ror	lr
8000e25a:	2f f7       	sub	r7,-1
8000e25c:	e0 47 07 ff 	cp.w	r7,2047
8000e260:	f9 ba 00 00 	moveq	r10,0
8000e264:	f9 bb 00 00 	moveq	r11,0
8000e268:	f9 be 00 00 	moveq	lr,0
8000e26c:	cb fb       	rjmp	8000e1ea <__avr32_f64_add_res_of_done>

8000e26e <__avr32_f64_add_op2_subnormal>:
8000e26e:	30 16       	mov	r6,1
8000e270:	58 07       	cp.w	r7,0
8000e272:	ca 01       	brne	8000e1b2 <__avr32_f64_add+0x3e>
8000e274:	b5 cb       	cbr	r11,0x14
8000e276:	10 0a       	add	r10,r8
8000e278:	f6 09 00 4b 	adc	r11,r11,r9
8000e27c:	18 4b       	or	r11,r12
8000e27e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000e282:	d7 03       	nop

8000e284 <__avr32_f64_to_u32>:
8000e284:	58 0b       	cp.w	r11,0
8000e286:	5e 6d       	retmi	0

8000e288 <__avr32_f64_to_s32>:
8000e288:	f6 0c 15 01 	lsl	r12,r11,0x1
8000e28c:	b5 9c       	lsr	r12,0x15
8000e28e:	e0 2c 03 ff 	sub	r12,1023
8000e292:	5e 3d       	retlo	0
8000e294:	f8 0c 11 1f 	rsub	r12,r12,31
8000e298:	16 99       	mov	r9,r11
8000e29a:	ab 7b       	lsl	r11,0xb
8000e29c:	bf bb       	sbr	r11,0x1f
8000e29e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000e2a2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000e2a6:	a1 79       	lsl	r9,0x1
8000e2a8:	5e 2b       	reths	r11
8000e2aa:	5c 3b       	neg	r11
8000e2ac:	5e fb       	retal	r11

8000e2ae <__avr32_u32_to_f64>:
8000e2ae:	f8 cb 00 00 	sub	r11,r12,0
8000e2b2:	30 0c       	mov	r12,0
8000e2b4:	c0 38       	rjmp	8000e2ba <__avr32_s32_to_f64+0x4>

8000e2b6 <__avr32_s32_to_f64>:
8000e2b6:	18 9b       	mov	r11,r12
8000e2b8:	5c 4b       	abs	r11
8000e2ba:	30 0a       	mov	r10,0
8000e2bc:	5e 0b       	reteq	r11
8000e2be:	d4 01       	pushm	lr
8000e2c0:	e0 69 04 1e 	mov	r9,1054
8000e2c4:	f6 08 12 00 	clz	r8,r11
8000e2c8:	c1 70       	breq	8000e2f6 <__avr32_s32_to_f64+0x40>
8000e2ca:	c0 c3       	brcs	8000e2e2 <__avr32_s32_to_f64+0x2c>
8000e2cc:	f0 0e 11 20 	rsub	lr,r8,32
8000e2d0:	f6 08 09 4b 	lsl	r11,r11,r8
8000e2d4:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000e2d8:	1c 4b       	or	r11,lr
8000e2da:	f4 08 09 4a 	lsl	r10,r10,r8
8000e2de:	10 19       	sub	r9,r8
8000e2e0:	c0 b8       	rjmp	8000e2f6 <__avr32_s32_to_f64+0x40>
8000e2e2:	f4 08 12 00 	clz	r8,r10
8000e2e6:	f9 b8 03 00 	movlo	r8,0
8000e2ea:	f7 b8 02 e0 	subhs	r8,-32
8000e2ee:	f4 08 09 4b 	lsl	r11,r10,r8
8000e2f2:	30 0a       	mov	r10,0
8000e2f4:	10 19       	sub	r9,r8
8000e2f6:	58 09       	cp.w	r9,0
8000e2f8:	e0 89 00 30 	brgt	8000e358 <__avr32_s32_to_f64+0xa2>
8000e2fc:	5c 39       	neg	r9
8000e2fe:	2f f9       	sub	r9,-1
8000e300:	e0 49 00 36 	cp.w	r9,54
8000e304:	c0 43       	brcs	8000e30c <__avr32_s32_to_f64+0x56>
8000e306:	30 0b       	mov	r11,0
8000e308:	30 0a       	mov	r10,0
8000e30a:	c2 68       	rjmp	8000e356 <__avr32_s32_to_f64+0xa0>
8000e30c:	2f 69       	sub	r9,-10
8000e30e:	f2 08 11 20 	rsub	r8,r9,32
8000e312:	e0 49 00 20 	cp.w	r9,32
8000e316:	c0 b2       	brcc	8000e32c <__avr32_s32_to_f64+0x76>
8000e318:	f4 08 09 4e 	lsl	lr,r10,r8
8000e31c:	f6 08 09 48 	lsl	r8,r11,r8
8000e320:	f4 09 0a 4a 	lsr	r10,r10,r9
8000e324:	f6 09 0a 4b 	lsr	r11,r11,r9
8000e328:	10 4b       	or	r11,r8
8000e32a:	c0 88       	rjmp	8000e33a <__avr32_s32_to_f64+0x84>
8000e32c:	f6 08 09 4e 	lsl	lr,r11,r8
8000e330:	14 4e       	or	lr,r10
8000e332:	16 9a       	mov	r10,r11
8000e334:	30 0b       	mov	r11,0
8000e336:	f4 09 0a 4a 	lsr	r10,r10,r9
8000e33a:	ed ba 00 00 	bld	r10,0x0
8000e33e:	c0 92       	brcc	8000e350 <__avr32_s32_to_f64+0x9a>
8000e340:	1c 7e       	tst	lr,lr
8000e342:	c0 41       	brne	8000e34a <__avr32_s32_to_f64+0x94>
8000e344:	ed ba 00 01 	bld	r10,0x1
8000e348:	c0 42       	brcc	8000e350 <__avr32_s32_to_f64+0x9a>
8000e34a:	2f fa       	sub	r10,-1
8000e34c:	f7 bb 02 ff 	subhs	r11,-1
8000e350:	5c fc       	rol	r12
8000e352:	5d 0b       	ror	r11
8000e354:	5d 0a       	ror	r10
8000e356:	d8 02       	popm	pc
8000e358:	e0 68 03 ff 	mov	r8,1023
8000e35c:	ed ba 00 0b 	bld	r10,0xb
8000e360:	f7 b8 00 ff 	subeq	r8,-1
8000e364:	10 0a       	add	r10,r8
8000e366:	5c 0b       	acr	r11
8000e368:	f7 b9 03 fe 	sublo	r9,-2
8000e36c:	e0 49 07 ff 	cp.w	r9,2047
8000e370:	c0 55       	brlt	8000e37a <__avr32_s32_to_f64+0xc4>
8000e372:	30 0a       	mov	r10,0
8000e374:	fc 1b ff e0 	movh	r11,0xffe0
8000e378:	c0 c8       	rjmp	8000e390 <__floatsidf_return_op1>
8000e37a:	ed bb 00 1f 	bld	r11,0x1f
8000e37e:	f7 b9 01 01 	subne	r9,1
8000e382:	ab 9a       	lsr	r10,0xb
8000e384:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000e388:	a1 7b       	lsl	r11,0x1
8000e38a:	ab 9b       	lsr	r11,0xb
8000e38c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000e390 <__floatsidf_return_op1>:
8000e390:	a1 7c       	lsl	r12,0x1
8000e392:	5d 0b       	ror	r11
8000e394:	d8 02       	popm	pc

8000e396 <__avr32_f64_cmp_eq>:
8000e396:	10 3a       	cp.w	r10,r8
8000e398:	f2 0b 13 00 	cpc	r11,r9
8000e39c:	c0 80       	breq	8000e3ac <__avr32_f64_cmp_eq+0x16>
8000e39e:	a1 7b       	lsl	r11,0x1
8000e3a0:	a1 79       	lsl	r9,0x1
8000e3a2:	14 4b       	or	r11,r10
8000e3a4:	12 4b       	or	r11,r9
8000e3a6:	10 4b       	or	r11,r8
8000e3a8:	5e 0f       	reteq	1
8000e3aa:	5e fd       	retal	0
8000e3ac:	a1 7b       	lsl	r11,0x1
8000e3ae:	fc 1c ff e0 	movh	r12,0xffe0
8000e3b2:	58 0a       	cp.w	r10,0
8000e3b4:	f8 0b 13 00 	cpc	r11,r12
8000e3b8:	5e 8f       	retls	1
8000e3ba:	5e fd       	retal	0

8000e3bc <__avr32_f64_cmp_ge>:
8000e3bc:	1a de       	st.w	--sp,lr
8000e3be:	1a d7       	st.w	--sp,r7
8000e3c0:	a1 7b       	lsl	r11,0x1
8000e3c2:	5f 3c       	srlo	r12
8000e3c4:	a1 79       	lsl	r9,0x1
8000e3c6:	5f 37       	srlo	r7
8000e3c8:	5c fc       	rol	r12
8000e3ca:	fc 1e ff e0 	movh	lr,0xffe0
8000e3ce:	58 0a       	cp.w	r10,0
8000e3d0:	fc 0b 13 00 	cpc	r11,lr
8000e3d4:	e0 8b 00 1d 	brhi	8000e40e <__avr32_f64_cmp_ge+0x52>
8000e3d8:	58 08       	cp.w	r8,0
8000e3da:	fc 09 13 00 	cpc	r9,lr
8000e3de:	e0 8b 00 18 	brhi	8000e40e <__avr32_f64_cmp_ge+0x52>
8000e3e2:	58 0b       	cp.w	r11,0
8000e3e4:	f5 ba 00 00 	subfeq	r10,0
8000e3e8:	c1 50       	breq	8000e412 <__avr32_f64_cmp_ge+0x56>
8000e3ea:	1b 07       	ld.w	r7,sp++
8000e3ec:	1b 0e       	ld.w	lr,sp++
8000e3ee:	58 3c       	cp.w	r12,3
8000e3f0:	c0 a0       	breq	8000e404 <__avr32_f64_cmp_ge+0x48>
8000e3f2:	58 1c       	cp.w	r12,1
8000e3f4:	c0 33       	brcs	8000e3fa <__avr32_f64_cmp_ge+0x3e>
8000e3f6:	5e 0f       	reteq	1
8000e3f8:	5e 1d       	retne	0
8000e3fa:	10 3a       	cp.w	r10,r8
8000e3fc:	f2 0b 13 00 	cpc	r11,r9
8000e400:	5e 2f       	reths	1
8000e402:	5e 3d       	retlo	0
8000e404:	14 38       	cp.w	r8,r10
8000e406:	f6 09 13 00 	cpc	r9,r11
8000e40a:	5e 2f       	reths	1
8000e40c:	5e 3d       	retlo	0
8000e40e:	1b 07       	ld.w	r7,sp++
8000e410:	d8 0a       	popm	pc,r12=0
8000e412:	58 17       	cp.w	r7,1
8000e414:	5f 0c       	sreq	r12
8000e416:	58 09       	cp.w	r9,0
8000e418:	f5 b8 00 00 	subfeq	r8,0
8000e41c:	1b 07       	ld.w	r7,sp++
8000e41e:	1b 0e       	ld.w	lr,sp++
8000e420:	5e 0f       	reteq	1
8000e422:	5e fc       	retal	r12

8000e424 <__avr32_f64_cmp_lt>:
8000e424:	1a de       	st.w	--sp,lr
8000e426:	1a d7       	st.w	--sp,r7
8000e428:	a1 7b       	lsl	r11,0x1
8000e42a:	5f 3c       	srlo	r12
8000e42c:	a1 79       	lsl	r9,0x1
8000e42e:	5f 37       	srlo	r7
8000e430:	5c fc       	rol	r12
8000e432:	fc 1e ff e0 	movh	lr,0xffe0
8000e436:	58 0a       	cp.w	r10,0
8000e438:	fc 0b 13 00 	cpc	r11,lr
8000e43c:	e0 8b 00 1d 	brhi	8000e476 <__avr32_f64_cmp_lt+0x52>
8000e440:	58 08       	cp.w	r8,0
8000e442:	fc 09 13 00 	cpc	r9,lr
8000e446:	e0 8b 00 18 	brhi	8000e476 <__avr32_f64_cmp_lt+0x52>
8000e44a:	58 0b       	cp.w	r11,0
8000e44c:	f5 ba 00 00 	subfeq	r10,0
8000e450:	c1 50       	breq	8000e47a <__avr32_f64_cmp_lt+0x56>
8000e452:	1b 07       	ld.w	r7,sp++
8000e454:	1b 0e       	ld.w	lr,sp++
8000e456:	58 3c       	cp.w	r12,3
8000e458:	c0 a0       	breq	8000e46c <__avr32_f64_cmp_lt+0x48>
8000e45a:	58 1c       	cp.w	r12,1
8000e45c:	c0 33       	brcs	8000e462 <__avr32_f64_cmp_lt+0x3e>
8000e45e:	5e 0d       	reteq	0
8000e460:	5e 1f       	retne	1
8000e462:	10 3a       	cp.w	r10,r8
8000e464:	f2 0b 13 00 	cpc	r11,r9
8000e468:	5e 2d       	reths	0
8000e46a:	5e 3f       	retlo	1
8000e46c:	14 38       	cp.w	r8,r10
8000e46e:	f6 09 13 00 	cpc	r9,r11
8000e472:	5e 2d       	reths	0
8000e474:	5e 3f       	retlo	1
8000e476:	1b 07       	ld.w	r7,sp++
8000e478:	d8 0a       	popm	pc,r12=0
8000e47a:	58 17       	cp.w	r7,1
8000e47c:	5f 1c       	srne	r12
8000e47e:	58 09       	cp.w	r9,0
8000e480:	f5 b8 00 00 	subfeq	r8,0
8000e484:	1b 07       	ld.w	r7,sp++
8000e486:	1b 0e       	ld.w	lr,sp++
8000e488:	5e 0d       	reteq	0
8000e48a:	5e fc       	retal	r12

8000e48c <__avr32_f64_div>:
8000e48c:	eb cd 40 ff 	pushm	r0-r7,lr
8000e490:	f7 e9 20 0e 	eor	lr,r11,r9
8000e494:	f6 07 16 14 	lsr	r7,r11,0x14
8000e498:	a9 7b       	lsl	r11,0x9
8000e49a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000e49e:	a9 7a       	lsl	r10,0x9
8000e4a0:	bd bb       	sbr	r11,0x1d
8000e4a2:	e4 1b 3f ff 	andh	r11,0x3fff
8000e4a6:	ab d7       	cbr	r7,0xb
8000e4a8:	e0 80 00 cc 	breq	8000e640 <__avr32_f64_div_round_subnormal+0x54>
8000e4ac:	e0 47 07 ff 	cp.w	r7,2047
8000e4b0:	e0 84 00 b5 	brge	8000e61a <__avr32_f64_div_round_subnormal+0x2e>
8000e4b4:	f2 06 16 14 	lsr	r6,r9,0x14
8000e4b8:	a9 79       	lsl	r9,0x9
8000e4ba:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000e4be:	a9 78       	lsl	r8,0x9
8000e4c0:	bd b9       	sbr	r9,0x1d
8000e4c2:	e4 19 3f ff 	andh	r9,0x3fff
8000e4c6:	ab d6       	cbr	r6,0xb
8000e4c8:	e0 80 00 e2 	breq	8000e68c <__avr32_f64_div_round_subnormal+0xa0>
8000e4cc:	e0 46 07 ff 	cp.w	r6,2047
8000e4d0:	e0 84 00 b2 	brge	8000e634 <__avr32_f64_div_round_subnormal+0x48>
8000e4d4:	0c 17       	sub	r7,r6
8000e4d6:	fe 37 fc 01 	sub	r7,-1023
8000e4da:	fc 1c 80 00 	movh	r12,0x8000
8000e4de:	f8 03 16 01 	lsr	r3,r12,0x1
8000e4e2:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000e4e6:	5c d4       	com	r4
8000e4e8:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000e4ec:	e6 09 06 44 	mulu.d	r4,r3,r9
8000e4f0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000e4f4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000e4f8:	ea 03 15 02 	lsl	r3,r5,0x2
8000e4fc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000e500:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000e504:	e6 05 06 44 	mulu.d	r4,r3,r5
8000e508:	ea 03 15 02 	lsl	r3,r5,0x2
8000e50c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000e510:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000e514:	e6 05 06 44 	mulu.d	r4,r3,r5
8000e518:	ea 03 15 02 	lsl	r3,r5,0x2
8000e51c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000e520:	e4 09 07 40 	macu.d	r0,r2,r9
8000e524:	e6 09 06 44 	mulu.d	r4,r3,r9
8000e528:	02 04       	add	r4,r1
8000e52a:	5c 05       	acr	r5
8000e52c:	a3 65       	lsl	r5,0x2
8000e52e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000e532:	a3 64       	lsl	r4,0x2
8000e534:	5c 34       	neg	r4
8000e536:	f8 05 01 45 	sbc	r5,r12,r5
8000e53a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000e53e:	e4 05 07 40 	macu.d	r0,r2,r5
8000e542:	e6 05 06 44 	mulu.d	r4,r3,r5
8000e546:	02 04       	add	r4,r1
8000e548:	5c 05       	acr	r5
8000e54a:	ea 03 15 02 	lsl	r3,r5,0x2
8000e54e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000e552:	e8 02 15 02 	lsl	r2,r4,0x2
8000e556:	e6 08 06 40 	mulu.d	r0,r3,r8
8000e55a:	e4 09 07 40 	macu.d	r0,r2,r9
8000e55e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000e562:	02 04       	add	r4,r1
8000e564:	5c 05       	acr	r5
8000e566:	a3 65       	lsl	r5,0x2
8000e568:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000e56c:	a3 64       	lsl	r4,0x2
8000e56e:	5c 34       	neg	r4
8000e570:	f8 05 01 45 	sbc	r5,r12,r5
8000e574:	e6 04 06 40 	mulu.d	r0,r3,r4
8000e578:	e4 05 07 40 	macu.d	r0,r2,r5
8000e57c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000e580:	02 04       	add	r4,r1
8000e582:	5c 05       	acr	r5
8000e584:	ea 03 15 02 	lsl	r3,r5,0x2
8000e588:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000e58c:	e8 02 15 02 	lsl	r2,r4,0x2
8000e590:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000e594:	e4 0b 07 40 	macu.d	r0,r2,r11
8000e598:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000e59c:	02 02       	add	r2,r1
8000e59e:	5c 03       	acr	r3
8000e5a0:	ed b3 00 1c 	bld	r3,0x1c
8000e5a4:	c0 90       	breq	8000e5b6 <__avr32_f64_div+0x12a>
8000e5a6:	a1 72       	lsl	r2,0x1
8000e5a8:	5c f3       	rol	r3
8000e5aa:	20 17       	sub	r7,1
8000e5ac:	a3 9a       	lsr	r10,0x3
8000e5ae:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000e5b2:	a3 9b       	lsr	r11,0x3
8000e5b4:	c0 58       	rjmp	8000e5be <__avr32_f64_div+0x132>
8000e5b6:	a5 8a       	lsr	r10,0x4
8000e5b8:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000e5bc:	a5 8b       	lsr	r11,0x4
8000e5be:	58 07       	cp.w	r7,0
8000e5c0:	e0 8a 00 8b 	brle	8000e6d6 <__avr32_f64_div_res_subnormal>
8000e5c4:	e0 12 ff 00 	andl	r2,0xff00
8000e5c8:	e8 12 00 80 	orl	r2,0x80
8000e5cc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000e5d0:	e4 09 07 40 	macu.d	r0,r2,r9
8000e5d4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000e5d8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000e5dc:	00 05       	add	r5,r0
8000e5de:	f0 01 00 48 	adc	r8,r8,r1
8000e5e2:	5c 09       	acr	r9
8000e5e4:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000e5e8:	58 04       	cp.w	r4,0
8000e5ea:	5c 25       	cpc	r5

8000e5ec <__avr32_f64_div_round_subnormal>:
8000e5ec:	f4 08 13 00 	cpc	r8,r10
8000e5f0:	f6 09 13 00 	cpc	r9,r11
8000e5f4:	5f 36       	srlo	r6
8000e5f6:	f8 06 17 00 	moveq	r6,r12
8000e5fa:	e4 0a 16 08 	lsr	r10,r2,0x8
8000e5fe:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000e602:	e6 0b 16 08 	lsr	r11,r3,0x8
8000e606:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000e60a:	ed be 00 1f 	bld	lr,0x1f
8000e60e:	ef bb 00 1f 	bst	r11,0x1f
8000e612:	0c 0a       	add	r10,r6
8000e614:	5c 0b       	acr	r11
8000e616:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000e61a:	e4 1b 00 0f 	andh	r11,0xf
8000e61e:	14 4b       	or	r11,r10
8000e620:	e0 81 00 a7 	brne	8000e76e <__avr32_f64_div_res_subnormal+0x98>
8000e624:	f2 06 16 14 	lsr	r6,r9,0x14
8000e628:	ab d6       	cbr	r6,0xb
8000e62a:	e0 46 07 ff 	cp.w	r6,2047
8000e62e:	e0 81 00 a4 	brne	8000e776 <__avr32_f64_div_res_subnormal+0xa0>
8000e632:	c9 e8       	rjmp	8000e76e <__avr32_f64_div_res_subnormal+0x98>
8000e634:	e4 19 00 0f 	andh	r9,0xf
8000e638:	10 49       	or	r9,r8
8000e63a:	e0 81 00 9a 	brne	8000e76e <__avr32_f64_div_res_subnormal+0x98>
8000e63e:	c9 28       	rjmp	8000e762 <__avr32_f64_div_res_subnormal+0x8c>
8000e640:	a3 7b       	lsl	r11,0x3
8000e642:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000e646:	a3 7a       	lsl	r10,0x3
8000e648:	f5 eb 10 04 	or	r4,r10,r11
8000e64c:	e0 80 00 a0 	breq	8000e78c <__avr32_f64_div_op1_zero>
8000e650:	f6 04 12 00 	clz	r4,r11
8000e654:	c1 70       	breq	8000e682 <__avr32_f64_div_round_subnormal+0x96>
8000e656:	c0 c3       	brcs	8000e66e <__avr32_f64_div_round_subnormal+0x82>
8000e658:	e8 05 11 20 	rsub	r5,r4,32
8000e65c:	f6 04 09 4b 	lsl	r11,r11,r4
8000e660:	f4 05 0a 45 	lsr	r5,r10,r5
8000e664:	0a 4b       	or	r11,r5
8000e666:	f4 04 09 4a 	lsl	r10,r10,r4
8000e66a:	08 17       	sub	r7,r4
8000e66c:	c0 b8       	rjmp	8000e682 <__avr32_f64_div_round_subnormal+0x96>
8000e66e:	f4 04 12 00 	clz	r4,r10
8000e672:	f9 b4 03 00 	movlo	r4,0
8000e676:	f7 b4 02 e0 	subhs	r4,-32
8000e67a:	f4 04 09 4b 	lsl	r11,r10,r4
8000e67e:	30 0a       	mov	r10,0
8000e680:	08 17       	sub	r7,r4
8000e682:	a3 8a       	lsr	r10,0x2
8000e684:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000e688:	a3 8b       	lsr	r11,0x2
8000e68a:	c1 1b       	rjmp	8000e4ac <__avr32_f64_div+0x20>
8000e68c:	a3 79       	lsl	r9,0x3
8000e68e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000e692:	a3 78       	lsl	r8,0x3
8000e694:	f3 e8 10 04 	or	r4,r9,r8
8000e698:	c6 f0       	breq	8000e776 <__avr32_f64_div_res_subnormal+0xa0>
8000e69a:	f2 04 12 00 	clz	r4,r9
8000e69e:	c1 70       	breq	8000e6cc <__avr32_f64_div_round_subnormal+0xe0>
8000e6a0:	c0 c3       	brcs	8000e6b8 <__avr32_f64_div_round_subnormal+0xcc>
8000e6a2:	e8 05 11 20 	rsub	r5,r4,32
8000e6a6:	f2 04 09 49 	lsl	r9,r9,r4
8000e6aa:	f0 05 0a 45 	lsr	r5,r8,r5
8000e6ae:	0a 49       	or	r9,r5
8000e6b0:	f0 04 09 48 	lsl	r8,r8,r4
8000e6b4:	08 16       	sub	r6,r4
8000e6b6:	c0 b8       	rjmp	8000e6cc <__avr32_f64_div_round_subnormal+0xe0>
8000e6b8:	f0 04 12 00 	clz	r4,r8
8000e6bc:	f9 b4 03 00 	movlo	r4,0
8000e6c0:	f7 b4 02 e0 	subhs	r4,-32
8000e6c4:	f0 04 09 49 	lsl	r9,r8,r4
8000e6c8:	30 08       	mov	r8,0
8000e6ca:	08 16       	sub	r6,r4
8000e6cc:	a3 88       	lsr	r8,0x2
8000e6ce:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000e6d2:	a3 89       	lsr	r9,0x2
8000e6d4:	cf ca       	rjmp	8000e4cc <__avr32_f64_div+0x40>

8000e6d6 <__avr32_f64_div_res_subnormal>:
8000e6d6:	5c 37       	neg	r7
8000e6d8:	2f f7       	sub	r7,-1
8000e6da:	f1 b7 04 c0 	satu	r7,0x6
8000e6de:	e0 47 00 20 	cp.w	r7,32
8000e6e2:	c1 54       	brge	8000e70c <__avr32_f64_div_res_subnormal+0x36>
8000e6e4:	ee 06 11 20 	rsub	r6,r7,32
8000e6e8:	e4 07 0a 42 	lsr	r2,r2,r7
8000e6ec:	e6 06 09 4c 	lsl	r12,r3,r6
8000e6f0:	18 42       	or	r2,r12
8000e6f2:	e6 07 0a 43 	lsr	r3,r3,r7
8000e6f6:	f4 06 09 41 	lsl	r1,r10,r6
8000e6fa:	f4 07 0a 4a 	lsr	r10,r10,r7
8000e6fe:	f6 06 09 4c 	lsl	r12,r11,r6
8000e702:	18 4a       	or	r10,r12
8000e704:	f6 07 0a 4b 	lsr	r11,r11,r7
8000e708:	30 00       	mov	r0,0
8000e70a:	c1 58       	rjmp	8000e734 <__avr32_f64_div_res_subnormal+0x5e>
8000e70c:	ee 06 11 20 	rsub	r6,r7,32
8000e710:	f9 b0 00 00 	moveq	r0,0
8000e714:	f9 bc 00 00 	moveq	r12,0
8000e718:	c0 50       	breq	8000e722 <__avr32_f64_div_res_subnormal+0x4c>
8000e71a:	f4 06 09 40 	lsl	r0,r10,r6
8000e71e:	f6 06 09 4c 	lsl	r12,r11,r6
8000e722:	e6 07 0a 42 	lsr	r2,r3,r7
8000e726:	30 03       	mov	r3,0
8000e728:	f4 07 0a 41 	lsr	r1,r10,r7
8000e72c:	18 41       	or	r1,r12
8000e72e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000e732:	30 0b       	mov	r11,0
8000e734:	e0 12 ff 00 	andl	r2,0xff00
8000e738:	e8 12 00 80 	orl	r2,0x80
8000e73c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000e740:	e4 09 07 46 	macu.d	r6,r2,r9
8000e744:	e4 08 06 44 	mulu.d	r4,r2,r8
8000e748:	e6 09 06 48 	mulu.d	r8,r3,r9
8000e74c:	0c 05       	add	r5,r6
8000e74e:	f0 07 00 48 	adc	r8,r8,r7
8000e752:	5c 09       	acr	r9
8000e754:	30 07       	mov	r7,0
8000e756:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000e75a:	00 34       	cp.w	r4,r0
8000e75c:	e2 05 13 00 	cpc	r5,r1
8000e760:	c4 6b       	rjmp	8000e5ec <__avr32_f64_div_round_subnormal>
8000e762:	1c 9b       	mov	r11,lr
8000e764:	e6 1b 80 00 	andh	r11,0x8000,COH
8000e768:	30 0a       	mov	r10,0
8000e76a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000e76e:	3f fb       	mov	r11,-1
8000e770:	30 0a       	mov	r10,0
8000e772:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000e776:	f5 eb 10 04 	or	r4,r10,r11
8000e77a:	c0 90       	breq	8000e78c <__avr32_f64_div_op1_zero>
8000e77c:	1c 9b       	mov	r11,lr
8000e77e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000e782:	ea 1b 7f f0 	orh	r11,0x7ff0
8000e786:	30 0a       	mov	r10,0
8000e788:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000e78c <__avr32_f64_div_op1_zero>:
8000e78c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000e790:	ce f0       	breq	8000e76e <__avr32_f64_div_res_subnormal+0x98>
8000e792:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000e796:	e0 44 07 ff 	cp.w	r4,2047
8000e79a:	ce 41       	brne	8000e762 <__avr32_f64_div_res_subnormal+0x8c>
8000e79c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000e7a0:	ce 10       	breq	8000e762 <__avr32_f64_div_res_subnormal+0x8c>
8000e7a2:	ce 6b       	rjmp	8000e76e <__avr32_f64_div_res_subnormal+0x98>

8000e7a4 <__avr32_udiv64>:
8000e7a4:	d4 31       	pushm	r0-r7,lr
8000e7a6:	1a 97       	mov	r7,sp
8000e7a8:	20 3d       	sub	sp,12
8000e7aa:	10 9c       	mov	r12,r8
8000e7ac:	12 9e       	mov	lr,r9
8000e7ae:	14 93       	mov	r3,r10
8000e7b0:	58 09       	cp.w	r9,0
8000e7b2:	e0 81 00 bd 	brne	8000e92c <__avr32_udiv64+0x188>
8000e7b6:	16 38       	cp.w	r8,r11
8000e7b8:	e0 88 00 40 	brls	8000e838 <__avr32_udiv64+0x94>
8000e7bc:	f0 08 12 00 	clz	r8,r8
8000e7c0:	c0 d0       	breq	8000e7da <__avr32_udiv64+0x36>
8000e7c2:	f6 08 09 4b 	lsl	r11,r11,r8
8000e7c6:	f0 09 11 20 	rsub	r9,r8,32
8000e7ca:	f8 08 09 4c 	lsl	r12,r12,r8
8000e7ce:	f4 09 0a 49 	lsr	r9,r10,r9
8000e7d2:	f4 08 09 43 	lsl	r3,r10,r8
8000e7d6:	f3 eb 10 0b 	or	r11,r9,r11
8000e7da:	f8 0e 16 10 	lsr	lr,r12,0x10
8000e7de:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000e7e2:	f6 0e 0d 00 	divu	r0,r11,lr
8000e7e6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000e7ea:	00 99       	mov	r9,r0
8000e7ec:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000e7f0:	e0 0a 02 48 	mul	r8,r0,r10
8000e7f4:	10 3b       	cp.w	r11,r8
8000e7f6:	c0 a2       	brcc	8000e80a <__avr32_udiv64+0x66>
8000e7f8:	20 19       	sub	r9,1
8000e7fa:	18 0b       	add	r11,r12
8000e7fc:	18 3b       	cp.w	r11,r12
8000e7fe:	c0 63       	brcs	8000e80a <__avr32_udiv64+0x66>
8000e800:	10 3b       	cp.w	r11,r8
8000e802:	f7 b9 03 01 	sublo	r9,1
8000e806:	f7 dc e3 0b 	addcs	r11,r11,r12
8000e80a:	f6 08 01 01 	sub	r1,r11,r8
8000e80e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000e812:	e2 0e 0d 00 	divu	r0,r1,lr
8000e816:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000e81a:	00 98       	mov	r8,r0
8000e81c:	e0 0a 02 4a 	mul	r10,r0,r10
8000e820:	14 33       	cp.w	r3,r10
8000e822:	c0 82       	brcc	8000e832 <__avr32_udiv64+0x8e>
8000e824:	20 18       	sub	r8,1
8000e826:	18 03       	add	r3,r12
8000e828:	18 33       	cp.w	r3,r12
8000e82a:	c0 43       	brcs	8000e832 <__avr32_udiv64+0x8e>
8000e82c:	14 33       	cp.w	r3,r10
8000e82e:	f7 b8 03 01 	sublo	r8,1
8000e832:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000e836:	cd f8       	rjmp	8000e9f4 <__avr32_udiv64+0x250>
8000e838:	58 08       	cp.w	r8,0
8000e83a:	c0 51       	brne	8000e844 <__avr32_udiv64+0xa0>
8000e83c:	30 19       	mov	r9,1
8000e83e:	f2 08 0d 08 	divu	r8,r9,r8
8000e842:	10 9c       	mov	r12,r8
8000e844:	f8 06 12 00 	clz	r6,r12
8000e848:	c0 41       	brne	8000e850 <__avr32_udiv64+0xac>
8000e84a:	18 1b       	sub	r11,r12
8000e84c:	30 19       	mov	r9,1
8000e84e:	c4 08       	rjmp	8000e8ce <__avr32_udiv64+0x12a>
8000e850:	ec 01 11 20 	rsub	r1,r6,32
8000e854:	f4 01 0a 49 	lsr	r9,r10,r1
8000e858:	f8 06 09 4c 	lsl	r12,r12,r6
8000e85c:	f6 06 09 48 	lsl	r8,r11,r6
8000e860:	f6 01 0a 41 	lsr	r1,r11,r1
8000e864:	f3 e8 10 08 	or	r8,r9,r8
8000e868:	f8 03 16 10 	lsr	r3,r12,0x10
8000e86c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000e870:	e2 03 0d 00 	divu	r0,r1,r3
8000e874:	f0 0b 16 10 	lsr	r11,r8,0x10
8000e878:	00 9e       	mov	lr,r0
8000e87a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000e87e:	e0 05 02 49 	mul	r9,r0,r5
8000e882:	12 3b       	cp.w	r11,r9
8000e884:	c0 a2       	brcc	8000e898 <__avr32_udiv64+0xf4>
8000e886:	20 1e       	sub	lr,1
8000e888:	18 0b       	add	r11,r12
8000e88a:	18 3b       	cp.w	r11,r12
8000e88c:	c0 63       	brcs	8000e898 <__avr32_udiv64+0xf4>
8000e88e:	12 3b       	cp.w	r11,r9
8000e890:	f7 be 03 01 	sublo	lr,1
8000e894:	f7 dc e3 0b 	addcs	r11,r11,r12
8000e898:	12 1b       	sub	r11,r9
8000e89a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000e89e:	f6 03 0d 02 	divu	r2,r11,r3
8000e8a2:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000e8a6:	04 99       	mov	r9,r2
8000e8a8:	e4 05 02 4b 	mul	r11,r2,r5
8000e8ac:	16 38       	cp.w	r8,r11
8000e8ae:	c0 a2       	brcc	8000e8c2 <__avr32_udiv64+0x11e>
8000e8b0:	20 19       	sub	r9,1
8000e8b2:	18 08       	add	r8,r12
8000e8b4:	18 38       	cp.w	r8,r12
8000e8b6:	c0 63       	brcs	8000e8c2 <__avr32_udiv64+0x11e>
8000e8b8:	16 38       	cp.w	r8,r11
8000e8ba:	f7 b9 03 01 	sublo	r9,1
8000e8be:	f1 dc e3 08 	addcs	r8,r8,r12
8000e8c2:	f4 06 09 43 	lsl	r3,r10,r6
8000e8c6:	f0 0b 01 0b 	sub	r11,r8,r11
8000e8ca:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000e8ce:	f8 06 16 10 	lsr	r6,r12,0x10
8000e8d2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000e8d6:	f6 06 0d 00 	divu	r0,r11,r6
8000e8da:	e6 0b 16 10 	lsr	r11,r3,0x10
8000e8de:	00 9a       	mov	r10,r0
8000e8e0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000e8e4:	e0 0e 02 48 	mul	r8,r0,lr
8000e8e8:	10 3b       	cp.w	r11,r8
8000e8ea:	c0 a2       	brcc	8000e8fe <__avr32_udiv64+0x15a>
8000e8ec:	20 1a       	sub	r10,1
8000e8ee:	18 0b       	add	r11,r12
8000e8f0:	18 3b       	cp.w	r11,r12
8000e8f2:	c0 63       	brcs	8000e8fe <__avr32_udiv64+0x15a>
8000e8f4:	10 3b       	cp.w	r11,r8
8000e8f6:	f7 ba 03 01 	sublo	r10,1
8000e8fa:	f7 dc e3 0b 	addcs	r11,r11,r12
8000e8fe:	f6 08 01 01 	sub	r1,r11,r8
8000e902:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000e906:	e2 06 0d 00 	divu	r0,r1,r6
8000e90a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000e90e:	00 98       	mov	r8,r0
8000e910:	e0 0e 02 4b 	mul	r11,r0,lr
8000e914:	16 33       	cp.w	r3,r11
8000e916:	c0 82       	brcc	8000e926 <__avr32_udiv64+0x182>
8000e918:	20 18       	sub	r8,1
8000e91a:	18 03       	add	r3,r12
8000e91c:	18 33       	cp.w	r3,r12
8000e91e:	c0 43       	brcs	8000e926 <__avr32_udiv64+0x182>
8000e920:	16 33       	cp.w	r3,r11
8000e922:	f7 b8 03 01 	sublo	r8,1
8000e926:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000e92a:	c6 98       	rjmp	8000e9fc <__avr32_udiv64+0x258>
8000e92c:	16 39       	cp.w	r9,r11
8000e92e:	e0 8b 00 65 	brhi	8000e9f8 <__avr32_udiv64+0x254>
8000e932:	f2 09 12 00 	clz	r9,r9
8000e936:	c0 b1       	brne	8000e94c <__avr32_udiv64+0x1a8>
8000e938:	10 3a       	cp.w	r10,r8
8000e93a:	5f 2a       	srhs	r10
8000e93c:	1c 3b       	cp.w	r11,lr
8000e93e:	5f b8       	srhi	r8
8000e940:	10 4a       	or	r10,r8
8000e942:	f2 0a 18 00 	cp.b	r10,r9
8000e946:	c5 90       	breq	8000e9f8 <__avr32_udiv64+0x254>
8000e948:	30 18       	mov	r8,1
8000e94a:	c5 98       	rjmp	8000e9fc <__avr32_udiv64+0x258>
8000e94c:	f0 09 09 46 	lsl	r6,r8,r9
8000e950:	f2 03 11 20 	rsub	r3,r9,32
8000e954:	fc 09 09 4e 	lsl	lr,lr,r9
8000e958:	f0 03 0a 48 	lsr	r8,r8,r3
8000e95c:	f6 09 09 4c 	lsl	r12,r11,r9
8000e960:	f4 03 0a 42 	lsr	r2,r10,r3
8000e964:	ef 46 ff f4 	st.w	r7[-12],r6
8000e968:	f6 03 0a 43 	lsr	r3,r11,r3
8000e96c:	18 42       	or	r2,r12
8000e96e:	f1 ee 10 0c 	or	r12,r8,lr
8000e972:	f8 01 16 10 	lsr	r1,r12,0x10
8000e976:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000e97a:	e6 01 0d 04 	divu	r4,r3,r1
8000e97e:	e4 03 16 10 	lsr	r3,r2,0x10
8000e982:	08 9e       	mov	lr,r4
8000e984:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000e988:	e8 06 02 48 	mul	r8,r4,r6
8000e98c:	10 33       	cp.w	r3,r8
8000e98e:	c0 a2       	brcc	8000e9a2 <__avr32_udiv64+0x1fe>
8000e990:	20 1e       	sub	lr,1
8000e992:	18 03       	add	r3,r12
8000e994:	18 33       	cp.w	r3,r12
8000e996:	c0 63       	brcs	8000e9a2 <__avr32_udiv64+0x1fe>
8000e998:	10 33       	cp.w	r3,r8
8000e99a:	f7 be 03 01 	sublo	lr,1
8000e99e:	e7 dc e3 03 	addcs	r3,r3,r12
8000e9a2:	10 13       	sub	r3,r8
8000e9a4:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000e9a8:	e6 01 0d 00 	divu	r0,r3,r1
8000e9ac:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000e9b0:	00 98       	mov	r8,r0
8000e9b2:	e0 06 02 46 	mul	r6,r0,r6
8000e9b6:	0c 3b       	cp.w	r11,r6
8000e9b8:	c0 a2       	brcc	8000e9cc <__avr32_udiv64+0x228>
8000e9ba:	20 18       	sub	r8,1
8000e9bc:	18 0b       	add	r11,r12
8000e9be:	18 3b       	cp.w	r11,r12
8000e9c0:	c0 63       	brcs	8000e9cc <__avr32_udiv64+0x228>
8000e9c2:	0c 3b       	cp.w	r11,r6
8000e9c4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000e9c8:	f7 b8 03 01 	sublo	r8,1
8000e9cc:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000e9d0:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000e9d4:	0c 1b       	sub	r11,r6
8000e9d6:	f0 04 06 42 	mulu.d	r2,r8,r4
8000e9da:	06 95       	mov	r5,r3
8000e9dc:	16 35       	cp.w	r5,r11
8000e9de:	e0 8b 00 0a 	brhi	8000e9f2 <__avr32_udiv64+0x24e>
8000e9e2:	5f 0b       	sreq	r11
8000e9e4:	f4 09 09 49 	lsl	r9,r10,r9
8000e9e8:	12 32       	cp.w	r2,r9
8000e9ea:	5f b9       	srhi	r9
8000e9ec:	f7 e9 00 09 	and	r9,r11,r9
8000e9f0:	c0 60       	breq	8000e9fc <__avr32_udiv64+0x258>
8000e9f2:	20 18       	sub	r8,1
8000e9f4:	30 09       	mov	r9,0
8000e9f6:	c0 38       	rjmp	8000e9fc <__avr32_udiv64+0x258>
8000e9f8:	30 09       	mov	r9,0
8000e9fa:	12 98       	mov	r8,r9
8000e9fc:	10 9a       	mov	r10,r8
8000e9fe:	12 93       	mov	r3,r9
8000ea00:	10 92       	mov	r2,r8
8000ea02:	12 9b       	mov	r11,r9
8000ea04:	2f dd       	sub	sp,-12
8000ea06:	d8 32       	popm	r0-r7,pc

8000ea08 <__avr32_umod64>:
8000ea08:	d4 31       	pushm	r0-r7,lr
8000ea0a:	1a 97       	mov	r7,sp
8000ea0c:	20 3d       	sub	sp,12
8000ea0e:	10 9c       	mov	r12,r8
8000ea10:	12 95       	mov	r5,r9
8000ea12:	14 9e       	mov	lr,r10
8000ea14:	16 91       	mov	r1,r11
8000ea16:	16 96       	mov	r6,r11
8000ea18:	58 09       	cp.w	r9,0
8000ea1a:	e0 81 00 81 	brne	8000eb1c <__avr32_umod64+0x114>
8000ea1e:	16 38       	cp.w	r8,r11
8000ea20:	e0 88 00 12 	brls	8000ea44 <__avr32_umod64+0x3c>
8000ea24:	f0 08 12 00 	clz	r8,r8
8000ea28:	c4 e0       	breq	8000eac4 <__avr32_umod64+0xbc>
8000ea2a:	f6 08 09 46 	lsl	r6,r11,r8
8000ea2e:	f8 08 09 4c 	lsl	r12,r12,r8
8000ea32:	f0 0b 11 20 	rsub	r11,r8,32
8000ea36:	f4 08 09 4e 	lsl	lr,r10,r8
8000ea3a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000ea3e:	f7 e6 10 06 	or	r6,r11,r6
8000ea42:	c4 18       	rjmp	8000eac4 <__avr32_umod64+0xbc>
8000ea44:	58 08       	cp.w	r8,0
8000ea46:	c0 51       	brne	8000ea50 <__avr32_umod64+0x48>
8000ea48:	30 19       	mov	r9,1
8000ea4a:	f2 08 0d 08 	divu	r8,r9,r8
8000ea4e:	10 9c       	mov	r12,r8
8000ea50:	f8 08 12 00 	clz	r8,r12
8000ea54:	c0 31       	brne	8000ea5a <__avr32_umod64+0x52>
8000ea56:	18 16       	sub	r6,r12
8000ea58:	c3 68       	rjmp	8000eac4 <__avr32_umod64+0xbc>
8000ea5a:	f0 03 11 20 	rsub	r3,r8,32
8000ea5e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000ea62:	f8 08 09 4c 	lsl	r12,r12,r8
8000ea66:	ec 08 09 49 	lsl	r9,r6,r8
8000ea6a:	ec 03 0a 43 	lsr	r3,r6,r3
8000ea6e:	f7 e9 10 09 	or	r9,r11,r9
8000ea72:	f8 05 16 10 	lsr	r5,r12,0x10
8000ea76:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ea7a:	e6 05 0d 02 	divu	r2,r3,r5
8000ea7e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000ea82:	ec 02 02 4b 	mul	r11,r6,r2
8000ea86:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000ea8a:	16 3e       	cp.w	lr,r11
8000ea8c:	c0 72       	brcc	8000ea9a <__avr32_umod64+0x92>
8000ea8e:	18 0e       	add	lr,r12
8000ea90:	18 3e       	cp.w	lr,r12
8000ea92:	c0 43       	brcs	8000ea9a <__avr32_umod64+0x92>
8000ea94:	16 3e       	cp.w	lr,r11
8000ea96:	fd dc e3 0e 	addcs	lr,lr,r12
8000ea9a:	fc 0b 01 03 	sub	r3,lr,r11
8000ea9e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000eaa2:	e6 05 0d 02 	divu	r2,r3,r5
8000eaa6:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000eaaa:	a5 36       	mul	r6,r2
8000eaac:	0c 39       	cp.w	r9,r6
8000eaae:	c0 72       	brcc	8000eabc <__avr32_umod64+0xb4>
8000eab0:	18 09       	add	r9,r12
8000eab2:	18 39       	cp.w	r9,r12
8000eab4:	c0 43       	brcs	8000eabc <__avr32_umod64+0xb4>
8000eab6:	0c 39       	cp.w	r9,r6
8000eab8:	f3 dc e3 09 	addcs	r9,r9,r12
8000eabc:	f2 06 01 06 	sub	r6,r9,r6
8000eac0:	f4 08 09 4e 	lsl	lr,r10,r8
8000eac4:	f8 0a 16 10 	lsr	r10,r12,0x10
8000eac8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000eacc:	ec 0a 0d 02 	divu	r2,r6,r10
8000ead0:	fc 09 16 10 	lsr	r9,lr,0x10
8000ead4:	ea 02 02 4b 	mul	r11,r5,r2
8000ead8:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000eadc:	16 39       	cp.w	r9,r11
8000eade:	c0 72       	brcc	8000eaec <__avr32_umod64+0xe4>
8000eae0:	18 09       	add	r9,r12
8000eae2:	18 39       	cp.w	r9,r12
8000eae4:	c0 43       	brcs	8000eaec <__avr32_umod64+0xe4>
8000eae6:	16 39       	cp.w	r9,r11
8000eae8:	f3 dc e3 09 	addcs	r9,r9,r12
8000eaec:	f2 0b 01 0b 	sub	r11,r9,r11
8000eaf0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000eaf4:	f6 0a 0d 0a 	divu	r10,r11,r10
8000eaf8:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000eafc:	ea 0a 02 4a 	mul	r10,r5,r10
8000eb00:	14 3e       	cp.w	lr,r10
8000eb02:	c0 72       	brcc	8000eb10 <__avr32_umod64+0x108>
8000eb04:	18 0e       	add	lr,r12
8000eb06:	18 3e       	cp.w	lr,r12
8000eb08:	c0 43       	brcs	8000eb10 <__avr32_umod64+0x108>
8000eb0a:	14 3e       	cp.w	lr,r10
8000eb0c:	fd dc e3 0e 	addcs	lr,lr,r12
8000eb10:	fc 0a 01 0a 	sub	r10,lr,r10
8000eb14:	30 0b       	mov	r11,0
8000eb16:	f4 08 0a 4a 	lsr	r10,r10,r8
8000eb1a:	c7 b8       	rjmp	8000ec10 <__avr32_umod64+0x208>
8000eb1c:	16 39       	cp.w	r9,r11
8000eb1e:	e0 8b 00 79 	brhi	8000ec10 <__avr32_umod64+0x208>
8000eb22:	f2 09 12 00 	clz	r9,r9
8000eb26:	c1 21       	brne	8000eb4a <__avr32_umod64+0x142>
8000eb28:	10 3a       	cp.w	r10,r8
8000eb2a:	5f 2b       	srhs	r11
8000eb2c:	0a 31       	cp.w	r1,r5
8000eb2e:	5f ba       	srhi	r10
8000eb30:	f7 ea 10 0a 	or	r10,r11,r10
8000eb34:	f2 0a 18 00 	cp.b	r10,r9
8000eb38:	c0 60       	breq	8000eb44 <__avr32_umod64+0x13c>
8000eb3a:	fc 08 01 0c 	sub	r12,lr,r8
8000eb3e:	e2 05 01 46 	sbc	r6,r1,r5
8000eb42:	18 9e       	mov	lr,r12
8000eb44:	0c 9b       	mov	r11,r6
8000eb46:	1c 9a       	mov	r10,lr
8000eb48:	c6 48       	rjmp	8000ec10 <__avr32_umod64+0x208>
8000eb4a:	ea 09 09 4c 	lsl	r12,r5,r9
8000eb4e:	f2 06 11 20 	rsub	r6,r9,32
8000eb52:	f6 09 09 4b 	lsl	r11,r11,r9
8000eb56:	f0 09 09 42 	lsl	r2,r8,r9
8000eb5a:	ef 46 ff f4 	st.w	r7[-12],r6
8000eb5e:	f0 06 0a 48 	lsr	r8,r8,r6
8000eb62:	18 48       	or	r8,r12
8000eb64:	e2 06 0a 4c 	lsr	r12,r1,r6
8000eb68:	f4 09 09 43 	lsl	r3,r10,r9
8000eb6c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000eb70:	f4 06 0a 4a 	lsr	r10,r10,r6
8000eb74:	16 4a       	or	r10,r11
8000eb76:	f0 0b 16 10 	lsr	r11,r8,0x10
8000eb7a:	f8 0b 0d 04 	divu	r4,r12,r11
8000eb7e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000eb82:	08 91       	mov	r1,r4
8000eb84:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000eb88:	e8 0e 02 46 	mul	r6,r4,lr
8000eb8c:	0c 3c       	cp.w	r12,r6
8000eb8e:	c0 a2       	brcc	8000eba2 <__avr32_umod64+0x19a>
8000eb90:	20 11       	sub	r1,1
8000eb92:	10 0c       	add	r12,r8
8000eb94:	10 3c       	cp.w	r12,r8
8000eb96:	c0 63       	brcs	8000eba2 <__avr32_umod64+0x19a>
8000eb98:	0c 3c       	cp.w	r12,r6
8000eb9a:	f7 b1 03 01 	sublo	r1,1
8000eb9e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000eba2:	0c 1c       	sub	r12,r6
8000eba4:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000eba8:	f8 0b 0d 04 	divu	r4,r12,r11
8000ebac:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000ebb0:	08 96       	mov	r6,r4
8000ebb2:	e8 0e 02 4e 	mul	lr,r4,lr
8000ebb6:	1c 3b       	cp.w	r11,lr
8000ebb8:	c0 a2       	brcc	8000ebcc <__avr32_umod64+0x1c4>
8000ebba:	20 16       	sub	r6,1
8000ebbc:	10 0b       	add	r11,r8
8000ebbe:	10 3b       	cp.w	r11,r8
8000ebc0:	c0 63       	brcs	8000ebcc <__avr32_umod64+0x1c4>
8000ebc2:	1c 3b       	cp.w	r11,lr
8000ebc4:	f7 b6 03 01 	sublo	r6,1
8000ebc8:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000ebcc:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000ebd0:	1c 1b       	sub	r11,lr
8000ebd2:	e2 02 06 40 	mulu.d	r0,r1,r2
8000ebd6:	00 9e       	mov	lr,r0
8000ebd8:	02 9c       	mov	r12,r1
8000ebda:	16 3c       	cp.w	r12,r11
8000ebdc:	e0 8b 00 08 	brhi	8000ebec <__avr32_umod64+0x1e4>
8000ebe0:	5f 06       	sreq	r6
8000ebe2:	06 30       	cp.w	r0,r3
8000ebe4:	5f ba       	srhi	r10
8000ebe6:	ed ea 00 0a 	and	r10,r6,r10
8000ebea:	c0 60       	breq	8000ebf6 <__avr32_umod64+0x1ee>
8000ebec:	fc 02 01 04 	sub	r4,lr,r2
8000ebf0:	f8 08 01 4c 	sbc	r12,r12,r8
8000ebf4:	08 9e       	mov	lr,r4
8000ebf6:	e6 0e 01 0a 	sub	r10,r3,lr
8000ebfa:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ebfe:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ec02:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ec06:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ec0a:	f8 01 09 4c 	lsl	r12,r12,r1
8000ec0e:	18 4a       	or	r10,r12
8000ec10:	2f dd       	sub	sp,-12
8000ec12:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ee00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ee00:	c0 08       	rjmp	8000ee00 <_evba>
	...

8000ee04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ee04:	c0 08       	rjmp	8000ee04 <_handle_TLB_Multiple_Hit>
	...

8000ee08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ee08:	c0 08       	rjmp	8000ee08 <_handle_Bus_Error_Data_Fetch>
	...

8000ee0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ee0c:	c0 08       	rjmp	8000ee0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ee10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ee10:	c0 08       	rjmp	8000ee10 <_handle_NMI>
	...

8000ee14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ee14:	c0 08       	rjmp	8000ee14 <_handle_Instruction_Address>
	...

8000ee18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ee18:	c0 08       	rjmp	8000ee18 <_handle_ITLB_Protection>
	...

8000ee1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ee1c:	c0 08       	rjmp	8000ee1c <_handle_Breakpoint>
	...

8000ee20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ee20:	c0 08       	rjmp	8000ee20 <_handle_Illegal_Opcode>
	...

8000ee24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ee24:	c0 08       	rjmp	8000ee24 <_handle_Unimplemented_Instruction>
	...

8000ee28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ee28:	c0 08       	rjmp	8000ee28 <_handle_Privilege_Violation>
	...

8000ee2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ee2c:	c0 08       	rjmp	8000ee2c <_handle_Floating_Point>
	...

8000ee30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ee30:	c0 08       	rjmp	8000ee30 <_handle_Coprocessor_Absent>
	...

8000ee34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ee34:	c0 08       	rjmp	8000ee34 <_handle_Data_Address_Read>
	...

8000ee38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ee38:	c0 08       	rjmp	8000ee38 <_handle_Data_Address_Write>
	...

8000ee3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ee3c:	c0 08       	rjmp	8000ee3c <_handle_DTLB_Protection_Read>
	...

8000ee40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ee40:	c0 08       	rjmp	8000ee40 <_handle_DTLB_Protection_Write>
	...

8000ee44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ee44:	c0 08       	rjmp	8000ee44 <_handle_DTLB_Modified>
	...

8000ee50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ee50:	c0 08       	rjmp	8000ee50 <_handle_ITLB_Miss>
	...

8000ee60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ee60:	c0 08       	rjmp	8000ee60 <_handle_DTLB_Miss_Read>
	...

8000ee70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ee70:	c0 08       	rjmp	8000ee70 <_handle_DTLB_Miss_Write>
	...

8000ef00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000ef00:	fe cf 7f f4 	sub	pc,pc,32756

8000ef04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000ef04:	30 0c       	mov	r12,0
8000ef06:	fe b0 ba ff 	rcall	80006504 <_get_interrupt_handler>
8000ef0a:	58 0c       	cp.w	r12,0
8000ef0c:	f8 0f 17 10 	movne	pc,r12
8000ef10:	d6 03       	rete

8000ef12 <_int1>:
8000ef12:	30 1c       	mov	r12,1
8000ef14:	fe b0 ba f8 	rcall	80006504 <_get_interrupt_handler>
8000ef18:	58 0c       	cp.w	r12,0
8000ef1a:	f8 0f 17 10 	movne	pc,r12
8000ef1e:	d6 03       	rete

8000ef20 <_int2>:
8000ef20:	30 2c       	mov	r12,2
8000ef22:	fe b0 ba f1 	rcall	80006504 <_get_interrupt_handler>
8000ef26:	58 0c       	cp.w	r12,0
8000ef28:	f8 0f 17 10 	movne	pc,r12
8000ef2c:	d6 03       	rete

8000ef2e <_int3>:
8000ef2e:	30 3c       	mov	r12,3
8000ef30:	fe b0 ba ea 	rcall	80006504 <_get_interrupt_handler>
8000ef34:	58 0c       	cp.w	r12,0
8000ef36:	f8 0f 17 10 	movne	pc,r12
8000ef3a:	d6 03       	rete

8000ef3c <ipr_val>:
8000ef3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000ef4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ef5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ef6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ef7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ef8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000ef9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000efac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000efbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000efcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000efdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000efec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000effc:	d7 03 d7 03                                         ....
