
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a4c4  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c600  8000c600  0000ca00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009ab8  8000c800  8000c800  0000cc00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a2c  00000008  800162b8  00016808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a34  80016ce4  00017234  2**0
                  ALLOC
  8 .bss          000036f8  00000a38  00000a38  00000000  2**2
                  ALLOC
  9 .heap         00012ed0  00004130  00004130  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00017234  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001140  00000000  00000000  00017268  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000024bb  00000000  00000000  000183a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00028304  00000000  00000000  0001a863  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00006837  00000000  00000000  00042b67  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c247  00000000  00000000  0004939e  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002cf0  00000000  00000000  000555e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006c97  00000000  00000000  000582d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000ca4f  00000000  00000000  0005ef6f  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001228  00000000  00000000  0006b9c0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 94 94 	sub	pc,pc,-27500

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b4 98 	sub	pc,pc,-19304

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d c0       	ld.ub	r0,r6[0x4]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 54       	eor	r4,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 08       	sub	r8,16
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	27 ec       	sub	r12,126
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 d4       	sub	r4,-115
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	43 3c       	lddsp	r12,sp[0xcc]
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c8 00       	breq	80001f86 <_trampoline+0x1f82>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	62 e0       	ld.w	r0,r1[0x38]
80002090:	00 00       	add	r0,r0
80002092:	0a 50       	eor	r0,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 17 	mcall	800020f0 <app_cfg+0x5c>
8000209a:	49 78       	lddpc	r8,800020f4 <app_cfg+0x60>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 76       	lddpc	r6,800020f8 <app_cfg+0x64>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 74       	lddpc	r4,800020fc <app_cfg+0x68>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 31       	mov	r1,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 22       	mov	r2,2
					//xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 0f a0 	mov	r5,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 71       	brne	800020e6 <app_cfg+0x52>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020ba:	68 08       	ld.w	r8,r4[0x0]
800020bc:	58 08       	cp.w	r8,0
800020be:	c0 51       	brne	800020c8 <app_cfg+0x34>
				{
					//xcmp_data_session();
					xcmp_audio_route_mic();
800020c0:	f0 1f 00 10 	mcall	80002100 <app_cfg+0x6c>
					//xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c4:	89 03       	st.w	r4[0x0],r3
800020c6:	c1 08       	rjmp	800020e6 <app_cfg+0x52>
				}
				else if(isAudioRouting == 1)
800020c8:	58 18       	cp.w	r8,1
800020ca:	c0 31       	brne	800020d0 <app_cfg+0x3c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020cc:	89 02       	st.w	r4[0x0],r2
800020ce:	c0 c8       	rjmp	800020e6 <app_cfg+0x52>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020d0:	58 28       	cp.w	r8,2
800020d2:	c0 31       	brne	800020d8 <app_cfg+0x44>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020d4:	89 01       	st.w	r4[0x0],r1
800020d6:	c0 88       	rjmp	800020e6 <app_cfg+0x52>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020d8:	58 38       	cp.w	r8,3
800020da:	e9 f0 0a 00 	st.weq	r4[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
800020de:	f7 b8 01 ff 	subne	r8,-1
800020e2:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020e6:	0a 9b       	mov	r11,r5
800020e8:	0e 9c       	mov	r12,r7
800020ea:	f0 1f 00 07 	mcall	80002104 <app_cfg+0x70>
	}
800020ee:	ce 1b       	rjmp	800020b0 <app_cfg+0x1c>
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	60 18       	ld.w	r8,r0[0x4]
800020f4:	00 00       	add	r0,r0
800020f6:	0a 48       	or	r8,r5
800020f8:	00 00       	add	r0,r0
800020fa:	0d c0       	ld.ub	r0,r6[0x4]
800020fc:	00 00       	add	r0,r0
800020fe:	0a 40       	or	r0,r5
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	43 90       	lddsp	r0,sp[0xe4]
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	61 80       	ld.w	r0,r0[0x60]

80002108 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002108:	d4 01       	pushm	lr
  log("R");
8000210a:	48 3c       	lddpc	r12,80002114 <app_payload_tx_proc+0xc>
8000210c:	f0 1f 00 03 	mcall	80002118 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002110:	d8 02       	popm	pc
80002112:	00 00       	add	r0,r0
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	c8 08       	rjmp	80002216 <SingleDetection_brdcst_func+0x3a>
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	66 a4       	ld.w	r4,r3[0x28]

8000211c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000211c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000211e:	48 3c       	lddpc	r12,80002128 <FD_brdcst_func+0xc>
80002120:	f0 1f 00 03 	mcall	8000212c <FD_brdcst_func+0x10>
	
}
80002124:	d8 02       	popm	pc
80002126:	00 00       	add	r0,r0
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	c8 0c       	rcall	8000222a <ButtonConfig_brdcst_func+0xe>
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	66 a4       	ld.w	r4,r3[0x28]

80002130 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002130:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002132:	48 3c       	lddpc	r12,8000213c <FD_reply_func+0xc>
80002134:	f0 1f 00 03 	mcall	80002140 <FD_reply_func+0x10>
	
	
}
80002138:	d8 02       	popm	pc
8000213a:	00 00       	add	r0,r0
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	c8 2c       	rcall	80002242 <ButtonConfig_brdcst_func+0x26>
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	66 a4       	ld.w	r4,r3[0x28]

80002144 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002144:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002146:	48 3c       	lddpc	r12,80002150 <FD_request_func+0xc>
80002148:	f0 1f 00 03 	mcall	80002154 <FD_request_func+0x10>
	
	
}
8000214c:	d8 02       	popm	pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	c8 48       	rjmp	8000225a <ButtonConfig_brdcst_func+0x3e>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	66 a4       	ld.w	r4,r3[0x28]

80002158 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002158:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000215a:	48 3c       	lddpc	r12,80002164 <EnOB_brdcst_func+0xc>
8000215c:	f0 1f 00 03 	mcall	80002168 <EnOB_brdcst_func+0x10>
}
80002160:	d8 02       	popm	pc
80002162:	00 00       	add	r0,r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	c8 64       	brge	80002072 <app_init+0x32>
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	66 a4       	ld.w	r4,r3[0x28]

8000216c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000216c:	eb cd 40 80 	pushm	r7,lr
80002170:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80002172:	19 a9       	ld.ub	r9,r12[0x2]
80002174:	30 08       	mov	r8,0
80002176:	f0 09 18 00 	cp.b	r9,r8
8000217a:	c1 91       	brne	800021ac <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
8000217c:	19 b8       	ld.ub	r8,r12[0x3]
8000217e:	30 19       	mov	r9,1
80002180:	f2 08 18 00 	cp.b	r8,r9
80002184:	c0 61       	brne	80002190 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002186:	49 0c       	lddpc	r12,800021c4 <EnOB_reply_func+0x58>
80002188:	f0 1f 00 10 	mcall	800021c8 <EnOB_reply_func+0x5c>
8000218c:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002190:	58 08       	cp.w	r8,0
80002192:	c0 61       	brne	8000219e <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002194:	48 ec       	lddpc	r12,800021cc <EnOB_reply_func+0x60>
80002196:	f0 1f 00 0d 	mcall	800021c8 <EnOB_reply_func+0x5c>
8000219a:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000219e:	1a d8       	st.w	--sp,r8
800021a0:	48 cc       	lddpc	r12,800021d0 <EnOB_reply_func+0x64>
800021a2:	f0 1f 00 0a 	mcall	800021c8 <EnOB_reply_func+0x5c>
800021a6:	2f fd       	sub	sp,-4
800021a8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021ac:	48 ac       	lddpc	r12,800021d4 <EnOB_reply_func+0x68>
800021ae:	f0 1f 00 07 	mcall	800021c8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021b2:	0f a8       	ld.ub	r8,r7[0x2]
800021b4:	1a d8       	st.w	--sp,r8
800021b6:	48 9c       	lddpc	r12,800021d8 <EnOB_reply_func+0x6c>
800021b8:	f0 1f 00 04 	mcall	800021c8 <EnOB_reply_func+0x5c>
800021bc:	2f fd       	sub	sp,-4
800021be:	e3 cd 80 80 	ldm	sp++,r7,pc
800021c2:	00 00       	add	r0,r0
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	c8 7c       	rcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	66 a4       	ld.w	r4,r3[0x28]
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	c8 94       	brge	800020e0 <app_cfg+0x4c>
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	c8 a8       	rjmp	800022e6 <ButtonConfig_brdcst_func+0xca>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	c8 c0       	breq	800020ee <app_cfg+0x5a>
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	c8 dc       	rcall	800022f4 <ButtonConfig_brdcst_func+0xd8>

800021dc <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021dc:	eb cd 40 80 	pushm	r7,lr
800021e0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
800021e2:	19 a9       	ld.ub	r9,r12[0x2]
800021e4:	31 18       	mov	r8,17
800021e6:	f0 09 18 00 	cp.b	r9,r8
800021ea:	c0 61       	brne	800021f6 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021ec:	48 8c       	lddpc	r12,8000220c <SingleDetection_brdcst_func+0x30>
800021ee:	f0 1f 00 09 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
800021f2:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
800021f6:	48 8c       	lddpc	r12,80002214 <SingleDetection_brdcst_func+0x38>
800021f8:	f0 1f 00 06 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
800021fc:	0f a8       	ld.ub	r8,r7[0x2]
800021fe:	1a d8       	st.w	--sp,r8
80002200:	48 6c       	lddpc	r12,80002218 <SingleDetection_brdcst_func+0x3c>
80002202:	f0 1f 00 04 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
80002206:	2f fd       	sub	sp,-4
80002208:	e3 cd 80 80 	ldm	sp++,r7,pc
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	c8 f4       	brge	8000212c <FD_brdcst_func+0x10>
80002210:	80 00       	ld.sh	r0,r0[0x0]
80002212:	66 a4       	ld.w	r4,r3[0x28]
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	c9 08       	rjmp	80002336 <Phyuserinput_brdcst_func+0x3e>
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	c9 18       	rjmp	8000233c <Phyuserinput_brdcst_func+0x44>

8000221c <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
8000221c:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000221e:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002222:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002224:	4a bc       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xb4>
80002226:	f0 1f 00 2c 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000222a:	0f 88       	ld.ub	r8,r7[0x0]
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	4a bc       	lddpc	r12,800022d8 <ButtonConfig_brdcst_func+0xbc>
80002230:	f0 1f 00 29 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002234:	1a d5       	st.w	--sp,r5
80002236:	4a ac       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xc0>
80002238:	f0 1f 00 27 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
8000223c:	0f a8       	ld.ub	r8,r7[0x2]
8000223e:	1a d8       	st.w	--sp,r8
80002240:	4a 8c       	lddpc	r12,800022e0 <ButtonConfig_brdcst_func+0xc4>
80002242:	f0 1f 00 25 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002246:	2f dd       	sub	sp,-12
80002248:	58 05       	cp.w	r5,0
8000224a:	c4 10       	breq	800022cc <ButtonConfig_brdcst_func+0xb0>
8000224c:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000224e:	4a 64       	lddpc	r4,800022e4 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002250:	4a 63       	lddpc	r3,800022e8 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002252:	4a 72       	lddpc	r2,800022ec <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002254:	4a 71       	lddpc	r1,800022f0 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002256:	4a 80       	lddpc	r0,800022f4 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002258:	0f b9       	ld.ub	r9,r7[0x3]
8000225a:	0f c8       	ld.ub	r8,r7[0x4]
8000225c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002260:	1a d8       	st.w	--sp,r8
80002262:	1a d6       	st.w	--sp,r6
80002264:	08 9c       	mov	r12,r4
80002266:	f0 1f 00 1c 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000226a:	0f d9       	ld.ub	r9,r7[0x5]
8000226c:	0f e8       	ld.ub	r8,r7[0x6]
8000226e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002272:	1a d8       	st.w	--sp,r8
80002274:	1a d6       	st.w	--sp,r6
80002276:	06 9c       	mov	r12,r3
80002278:	f0 1f 00 17 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000227c:	0f f9       	ld.ub	r9,r7[0x7]
8000227e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002282:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002286:	1a d8       	st.w	--sp,r8
80002288:	1a d6       	st.w	--sp,r6
8000228a:	04 9c       	mov	r12,r2
8000228c:	f0 1f 00 12 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002290:	ef 39 00 09 	ld.ub	r9,r7[9]
80002294:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002298:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000229c:	1a d8       	st.w	--sp,r8
8000229e:	1a d6       	st.w	--sp,r6
800022a0:	02 9c       	mov	r12,r1
800022a2:	f0 1f 00 0d 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022a6:	2f 8d       	sub	sp,-32
800022a8:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022ac:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022b0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022b4:	1a d8       	st.w	--sp,r8
800022b6:	1a d6       	st.w	--sp,r6
800022b8:	00 9c       	mov	r12,r0
800022ba:	f0 1f 00 07 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
800022be:	2f f6       	sub	r6,-1
800022c0:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022c2:	2f ed       	sub	sp,-8
800022c4:	ec 05 18 00 	cp.b	r5,r6
800022c8:	fe 9b ff c8 	brhi	80002258 <ButtonConfig_brdcst_func+0x3c>
800022cc:	d8 32       	popm	r0-r7,pc
800022ce:	00 00       	add	r0,r0
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c9 30       	breq	800021f8 <SingleDetection_brdcst_func+0x1c>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	66 a4       	ld.w	r4,r3[0x28]
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c9 50       	breq	80002204 <SingleDetection_brdcst_func+0x28>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c9 64       	brge	8000220a <SingleDetection_brdcst_func+0x2e>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c9 7c       	rcall	80002410 <DataSession_brdcst_func+0x5c>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c9 9c       	rcall	80002418 <DataSession_brdcst_func+0x64>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c9 c4       	brge	80002222 <ButtonConfig_brdcst_func+0x6>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	c9 ec       	rcall	8000242a <DataSession_brdcst_func+0x76>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	ca 10       	breq	80002234 <ButtonConfig_brdcst_func+0x18>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	ca 38       	rjmp	8000243c <DataSession_reply_func+0x4>

800022f8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022f8:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022fc:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022fe:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002300:	19 c7       	ld.ub	r7,r12[0x4]
80002302:	19 d8       	ld.ub	r8,r12[0x5]
80002304:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002308:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
8000230a:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
8000230c:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002310:	49 0c       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x58>
80002312:	f0 1f 00 11 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002316:	1a d6       	st.w	--sp,r6
80002318:	49 0c       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x60>
8000231a:	f0 1f 00 0f 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000231e:	1a d5       	st.w	--sp,r5
80002320:	48 fc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x64>
80002322:	f0 1f 00 0d 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
80002326:	5c 77       	castu.h	r7
80002328:	1a d7       	st.w	--sp,r7
8000232a:	48 ec       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x68>
8000232c:	f0 1f 00 0a 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002330:	1a d4       	st.w	--sp,r4
80002332:	48 dc       	lddpc	r12,80002364 <Phyuserinput_brdcst_func+0x6c>
80002334:	f0 1f 00 08 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002338:	1a d3       	st.w	--sp,r3
8000233a:	48 cc       	lddpc	r12,80002368 <Phyuserinput_brdcst_func+0x70>
8000233c:	f0 1f 00 06 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002340:	1a d2       	st.w	--sp,r2
80002342:	48 bc       	lddpc	r12,8000236c <Phyuserinput_brdcst_func+0x74>
80002344:	f0 1f 00 04 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
80002348:	2f ad       	sub	sp,-24
	
	
	
	
	
}
8000234a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000234e:	00 00       	add	r0,r0
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	ca 5c       	rcall	8000249c <TransmitControl_brdcst_func+0xc>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	66 a4       	ld.w	r4,r3[0x28]
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	ca 80       	breq	800022aa <ButtonConfig_brdcst_func+0x8e>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	ca 98       	rjmp	800024b0 <TransmitControl_brdcst_func+0x20>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	ca ac       	rcall	800024b6 <TransmitControl_brdcst_func+0x26>
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	ca c0       	breq	800022be <ButtonConfig_brdcst_func+0xa2>
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	ca d4       	brge	800022c4 <ButtonConfig_brdcst_func+0xa8>
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	ca f4       	brge	800022cc <ButtonConfig_brdcst_func+0xb0>

80002370 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002370:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002374:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002378:	0f 89       	ld.ub	r9,r7[0x0]
8000237a:	30 08       	mov	r8,0
8000237c:	f0 09 18 00 	cp.b	r9,r8
80002380:	c0 c1       	brne	80002398 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002382:	48 9c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x34>
80002384:	f0 1f 00 09 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 8c       	lddpc	r12,800023ac <ButtonConfig_reply_func+0x3c>
8000238e:	f0 1f 00 07 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
80002392:	2f fd       	sub	sp,-4
80002394:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002398:	48 6c       	lddpc	r12,800023b0 <ButtonConfig_reply_func+0x40>
8000239a:	f0 1f 00 04 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
8000239e:	e3 cd 80 80 	ldm	sp++,r7,pc
800023a2:	00 00       	add	r0,r0
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	cb 14       	brge	80002308 <Phyuserinput_brdcst_func+0x10>
800023a8:	80 00       	ld.sh	r0,r0[0x0]
800023aa:	66 a4       	ld.w	r4,r3[0x28]
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	c9 50       	breq	800022d8 <ButtonConfig_brdcst_func+0xbc>
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	cb 2c       	rcall	80002516 <TransmitControl_reply_func+0x3e>

800023b4 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023b4:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023b6:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023ba:	0d 88       	ld.ub	r8,r6[0x0]
800023bc:	32 49       	mov	r9,36
800023be:	f2 08 18 00 	cp.b	r8,r9
800023c2:	c2 91       	brne	80002414 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023c4:	49 7c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x6c>
800023c6:	f0 1f 00 18 	mcall	80002424 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023ca:	0d a5       	ld.ub	r5,r6[0x2]
800023cc:	0d b8       	ld.ub	r8,r6[0x3]
800023ce:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023d2:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023d4:	0d 98       	ld.ub	r8,r6[0x1]
800023d6:	1a d8       	st.w	--sp,r8
800023d8:	49 4c       	lddpc	r12,80002428 <DataSession_brdcst_func+0x74>
800023da:	f0 1f 00 13 	mcall	80002424 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023de:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	49 2c       	lddpc	r12,8000242c <DataSession_brdcst_func+0x78>
800023e6:	f0 1f 00 10 	mcall	80002424 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023ea:	2f ed       	sub	sp,-8
800023ec:	58 05       	cp.w	r5,0
800023ee:	c1 80       	breq	8000241e <DataSession_brdcst_func+0x6a>
800023f0:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023f2:	49 04       	lddpc	r4,80002430 <DataSession_brdcst_func+0x7c>
800023f4:	ec 07 00 08 	add	r8,r6,r7
800023f8:	11 c8       	ld.ub	r8,r8[0x4]
800023fa:	1a d8       	st.w	--sp,r8
800023fc:	1a d7       	st.w	--sp,r7
800023fe:	08 9c       	mov	r12,r4
80002400:	f0 1f 00 09 	mcall	80002424 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002404:	2f f7       	sub	r7,-1
80002406:	5c 57       	castu.b	r7
80002408:	2f ed       	sub	sp,-8
8000240a:	ee 05 19 00 	cp.h	r5,r7
8000240e:	fe 9b ff f3 	brhi	800023f4 <DataSession_brdcst_func+0x40>
80002412:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002414:	1a d8       	st.w	--sp,r8
80002416:	48 8c       	lddpc	r12,80002434 <DataSession_brdcst_func+0x80>
80002418:	f0 1f 00 03 	mcall	80002424 <DataSession_brdcst_func+0x70>
8000241c:	2f fd       	sub	sp,-4
8000241e:	d8 22       	popm	r4-r7,pc
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	cb 48       	rjmp	8000258a <Volume_reply_func+0x36>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	66 a4       	ld.w	r4,r3[0x28]
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	cb 5c       	rcall	80002594 <Volume_reply_func+0x40>
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	cb 74       	brge	8000239c <ButtonConfig_reply_func+0x2c>
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	cb 90       	breq	800023a4 <ButtonConfig_reply_func+0x34>
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	cb a8       	rjmp	800025aa <Volume_reply_func+0x56>

80002438 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002438:	eb cd 40 80 	pushm	r7,lr
8000243c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000243e:	19 a8       	ld.ub	r8,r12[0x2]
80002440:	58 08       	cp.w	r8,0
80002442:	c0 61       	brne	8000244e <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002444:	48 dc       	lddpc	r12,80002478 <DataSession_reply_func+0x40>
80002446:	f0 1f 00 0e 	mcall	8000247c <DataSession_reply_func+0x44>
8000244a:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
8000244e:	1a d8       	st.w	--sp,r8
80002450:	48 cc       	lddpc	r12,80002480 <DataSession_reply_func+0x48>
80002452:	f0 1f 00 0b 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
80002456:	48 cc       	lddpc	r12,80002484 <DataSession_reply_func+0x4c>
80002458:	f0 1f 00 09 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
8000245c:	0f b8       	ld.ub	r8,r7[0x3]
8000245e:	1a d8       	st.w	--sp,r8
80002460:	48 ac       	lddpc	r12,80002488 <DataSession_reply_func+0x50>
80002462:	f0 1f 00 07 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
80002466:	0f c8       	ld.ub	r8,r7[0x4]
80002468:	1a d8       	st.w	--sp,r8
8000246a:	48 9c       	lddpc	r12,8000248c <DataSession_reply_func+0x54>
8000246c:	f0 1f 00 04 	mcall	8000247c <DataSession_reply_func+0x44>
80002470:	2f dd       	sub	sp,-12
80002472:	e3 cd 80 80 	ldm	sp++,r7,pc
80002476:	00 00       	add	r0,r0
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	cb bc       	rcall	800025f0 <spk_brdcst_func+0x38>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	66 a4       	ld.w	r4,r3[0x28]
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	cb d0       	breq	800023fc <DataSession_brdcst_func+0x48>
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	cb e4       	brge	80002402 <DataSession_brdcst_func+0x4e>
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	cb f8       	rjmp	80002608 <spk_reply_func+0x10>
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	cc 08       	rjmp	8000260e <spk_reply_func+0x16>

80002490 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002490:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002494:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002498:	0f 99       	ld.ub	r9,r7[0x1]
8000249a:	30 08       	mov	r8,0
8000249c:	f0 09 18 00 	cp.b	r9,r8
800024a0:	c0 71       	brne	800024ae <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024a2:	48 ac       	lddpc	r12,800024c8 <TransmitControl_brdcst_func+0x38>
800024a4:	f0 1f 00 0a 	mcall	800024cc <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024a8:	30 09       	mov	r9,0
800024aa:	48 a8       	lddpc	r8,800024d0 <TransmitControl_brdcst_func+0x40>
800024ac:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024ae:	0f 99       	ld.ub	r9,r7[0x1]
800024b0:	30 18       	mov	r8,1
800024b2:	f0 09 18 00 	cp.b	r9,r8
800024b6:	c0 71       	brne	800024c4 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024b8:	48 7c       	lddpc	r12,800024d4 <TransmitControl_brdcst_func+0x44>
800024ba:	f0 1f 00 05 	mcall	800024cc <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024be:	30 19       	mov	r9,1
800024c0:	48 48       	lddpc	r8,800024d0 <TransmitControl_brdcst_func+0x40>
800024c2:	b0 89       	st.b	r8[0x0],r9
800024c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	cc 18       	rjmp	8000264c <mic_brdcst_func+0x14>
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	66 a4       	ld.w	r4,r3[0x28]
800024d0:	00 00       	add	r0,r0
800024d2:	0a 3c       	cp.w	r12,r5
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	cc 30       	breq	8000245c <DataSession_reply_func+0x24>

800024d8 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800024d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800024dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800024e0:	0f 89       	ld.ub	r9,r7[0x0]
800024e2:	30 08       	mov	r8,0
800024e4:	f0 09 18 00 	cp.b	r9,r8
800024e8:	c2 21       	brne	8000252c <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024ea:	49 4c       	lddpc	r12,80002538 <TransmitControl_reply_func+0x60>
800024ec:	f0 1f 00 14 	mcall	8000253c <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
800024f0:	0f 98       	ld.ub	r8,r7[0x1]
800024f2:	1a d8       	st.w	--sp,r8
800024f4:	49 3c       	lddpc	r12,80002540 <TransmitControl_reply_func+0x68>
800024f6:	f0 1f 00 12 	mcall	8000253c <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024fa:	0f a8       	ld.ub	r8,r7[0x2]
800024fc:	1a d8       	st.w	--sp,r8
800024fe:	49 2c       	lddpc	r12,80002544 <TransmitControl_reply_func+0x6c>
80002500:	f0 1f 00 0f 	mcall	8000253c <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
80002504:	0f b8       	ld.ub	r8,r7[0x3]
80002506:	1a d8       	st.w	--sp,r8
80002508:	49 0c       	lddpc	r12,80002548 <TransmitControl_reply_func+0x70>
8000250a:	f0 1f 00 0d 	mcall	8000253c <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
8000250e:	0f 98       	ld.ub	r8,r7[0x1]
80002510:	2f dd       	sub	sp,-12
80002512:	30 19       	mov	r9,1
80002514:	f2 08 18 00 	cp.b	r8,r9
80002518:	c0 d0       	breq	80002532 <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
8000251a:	30 29       	mov	r9,2
8000251c:	f2 08 18 00 	cp.b	r8,r9
80002520:	c0 91       	brne	80002532 <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
80002522:	30 09       	mov	r9,0
80002524:	48 a8       	lddpc	r8,8000254c <TransmitControl_reply_func+0x74>
80002526:	b0 89       	st.b	r8[0x0],r9
80002528:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
8000252c:	48 9c       	lddpc	r12,80002550 <TransmitControl_reply_func+0x78>
8000252e:	f0 1f 00 04 	mcall	8000253c <TransmitControl_reply_func+0x64>
80002532:	e3 cd 80 80 	ldm	sp++,r7,pc
80002536:	00 00       	add	r0,r0
80002538:	80 00       	ld.sh	r0,r0[0x0]
8000253a:	cc 44       	brge	800024c2 <TransmitControl_brdcst_func+0x32>
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	66 a4       	ld.w	r4,r3[0x28]
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	cc 60       	breq	800024ce <TransmitControl_brdcst_func+0x3e>
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	cc 74       	brge	800024d4 <TransmitControl_brdcst_func+0x44>
80002548:	80 00       	ld.sh	r0,r0[0x0]
8000254a:	cc 90       	breq	800024dc <TransmitControl_reply_func+0x4>
8000254c:	00 00       	add	r0,r0
8000254e:	0a 44       	or	r4,r5
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	cc a0       	breq	800024e6 <TransmitControl_reply_func+0xe>

80002554 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002554:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002558:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000255c:	0f 89       	ld.ub	r9,r7[0x0]
8000255e:	30 08       	mov	r8,0
80002560:	f0 09 18 00 	cp.b	r9,r8
80002564:	c1 b1       	brne	8000259a <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002566:	0f b8       	ld.ub	r8,r7[0x3]
80002568:	31 09       	mov	r9,16
8000256a:	f2 08 18 00 	cp.b	r8,r9
8000256e:	c0 f1       	brne	8000258c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002570:	48 dc       	lddpc	r12,800025a4 <Volume_reply_func+0x50>
80002572:	f0 1f 00 0e 	mcall	800025a8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002576:	0f 99       	ld.ub	r9,r7[0x1]
80002578:	0f a8       	ld.ub	r8,r7[0x2]
8000257a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000257e:	1a d8       	st.w	--sp,r8
80002580:	48 bc       	lddpc	r12,800025ac <Volume_reply_func+0x58>
80002582:	f0 1f 00 0a 	mcall	800025a8 <Volume_reply_func+0x54>
80002586:	2f fd       	sub	sp,-4
80002588:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000258c:	1a d8       	st.w	--sp,r8
8000258e:	48 9c       	lddpc	r12,800025b0 <Volume_reply_func+0x5c>
80002590:	f0 1f 00 06 	mcall	800025a8 <Volume_reply_func+0x54>
80002594:	2f fd       	sub	sp,-4
80002596:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000259a:	48 7c       	lddpc	r12,800025b4 <Volume_reply_func+0x60>
8000259c:	f0 1f 00 03 	mcall	800025a8 <Volume_reply_func+0x54>
800025a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	cc b8       	rjmp	8000273c <dcm_brdcst_func+0x28>
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	66 a4       	ld.w	r4,r3[0x28]
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	cc cc       	rcall	80002746 <dcm_brdcst_func+0x32>
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	cc e8       	rjmp	8000274e <dcm_brdcst_func+0x3a>
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	cd 00       	breq	80002556 <Volume_reply_func+0x2>

800025b8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025b8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025ba:	19 d9       	ld.ub	r9,r12[0x5]
800025bc:	30 08       	mov	r8,0
800025be:	f0 09 18 00 	cp.b	r9,r8
800025c2:	c0 91       	brne	800025d4 <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025c4:	48 89       	lddpc	r9,800025e4 <spk_brdcst_func+0x2c>
800025c6:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025c8:	48 89       	lddpc	r9,800025e8 <spk_brdcst_func+0x30>
800025ca:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025cc:	48 8c       	lddpc	r12,800025ec <spk_brdcst_func+0x34>
800025ce:	f0 1f 00 09 	mcall	800025f0 <spk_brdcst_func+0x38>
800025d2:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
800025d4:	30 19       	mov	r9,1
800025d6:	48 58       	lddpc	r8,800025e8 <spk_brdcst_func+0x30>
800025d8:	b0 89       	st.b	r8[0x0],r9
		//is_unmute = 1;
		log("spk_s_open ");
800025da:	48 7c       	lddpc	r12,800025f4 <spk_brdcst_func+0x3c>
800025dc:	f0 1f 00 05 	mcall	800025f0 <spk_brdcst_func+0x38>
800025e0:	d8 02       	popm	pc
800025e2:	00 00       	add	r0,r0
800025e4:	00 00       	add	r0,r0
800025e6:	0a 44       	or	r4,r5
800025e8:	00 00       	add	r0,r0
800025ea:	0a 4e       	or	lr,r5
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	cd 18       	rjmp	80002790 <dcm_reply_func+0x34>
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	66 a4       	ld.w	r4,r3[0x28]
800025f4:	80 00       	ld.sh	r0,r0[0x0]
800025f6:	cd 28       	rjmp	8000279a <dcm_reply_func+0x3e>

800025f8 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
800025f8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800025fa:	19 a9       	ld.ub	r9,r12[0x2]
800025fc:	30 08       	mov	r8,0
800025fe:	f0 09 18 00 	cp.b	r9,r8
80002602:	c0 f1       	brne	80002620 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002604:	19 e9       	ld.ub	r9,r12[0x6]
80002606:	f0 09 18 00 	cp.b	r9,r8
8000260a:	c0 40       	breq	80002612 <spk_reply_func+0x1a>
		{
			is_unmute = 1;
8000260c:	30 19       	mov	r9,1
8000260e:	48 78       	lddpc	r8,80002628 <spk_reply_func+0x30>
80002610:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002612:	19 e8       	ld.ub	r8,r12[0x6]
80002614:	1a d8       	st.w	--sp,r8
80002616:	48 6c       	lddpc	r12,8000262c <spk_reply_func+0x34>
80002618:	f0 1f 00 06 	mcall	80002630 <spk_reply_func+0x38>
8000261c:	2f fd       	sub	sp,-4
8000261e:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
80002620:	48 5c       	lddpc	r12,80002634 <spk_reply_func+0x3c>
80002622:	f0 1f 00 04 	mcall	80002630 <spk_reply_func+0x38>
80002626:	d8 02       	popm	pc
80002628:	00 00       	add	r0,r0
8000262a:	0a 44       	or	r4,r5
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	cd 34       	brge	800025d4 <spk_brdcst_func+0x1c>
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	66 a4       	ld.w	r4,r3[0x28]
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	cd 44       	brge	800025de <spk_brdcst_func+0x26>

80002638 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002638:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000263c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002640:	0f a9       	ld.ub	r9,r7[0x2]
80002642:	30 08       	mov	r8,0
80002644:	f0 09 18 00 	cp.b	r9,r8
80002648:	c0 71       	brne	80002656 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000264a:	48 ac       	lddpc	r12,80002670 <mic_brdcst_func+0x38>
8000264c:	f0 1f 00 0a 	mcall	80002674 <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 0;
80002650:	30 09       	mov	r9,0
80002652:	48 a8       	lddpc	r8,80002678 <mic_brdcst_func+0x40>
80002654:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002656:	0f a9       	ld.ub	r9,r7[0x2]
80002658:	31 18       	mov	r8,17
8000265a:	f0 09 18 00 	cp.b	r9,r8
8000265e:	c0 71       	brne	8000266c <mic_brdcst_func+0x34>
	{
		log("\n\r Mic_Enabled \n\r");	
80002660:	48 7c       	lddpc	r12,8000267c <mic_brdcst_func+0x44>
80002662:	f0 1f 00 05 	mcall	80002674 <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 1;
80002666:	30 19       	mov	r9,1
80002668:	48 48       	lddpc	r8,80002678 <mic_brdcst_func+0x40>
8000266a:	b0 89       	st.b	r8[0x0],r9
8000266c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002670:	80 00       	ld.sh	r0,r0[0x0]
80002672:	cd 50       	breq	8000261c <spk_reply_func+0x24>
80002674:	80 00       	ld.sh	r0,r0[0x0]
80002676:	66 a4       	ld.w	r4,r3[0x28]
80002678:	00 00       	add	r0,r0
8000267a:	0a 3b       	cp.w	r11,r5
8000267c:	80 00       	ld.sh	r0,r0[0x0]
8000267e:	cd 64       	brge	8000262a <spk_reply_func+0x32>

80002680 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002680:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002684:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002688:	49 ac       	lddpc	r12,800026f0 <mic_reply_func+0x70>
8000268a:	f0 1f 00 1b 	mcall	800026f4 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000268e:	0f 89       	ld.ub	r9,r7[0x0]
80002690:	30 08       	mov	r8,0
80002692:	f0 09 18 00 	cp.b	r9,r8
80002696:	c2 71       	brne	800026e4 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002698:	0f 98       	ld.ub	r8,r7[0x1]
8000269a:	30 29       	mov	r9,2
8000269c:	f2 08 18 00 	cp.b	r8,r9
800026a0:	c1 b1       	brne	800026d6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026a2:	49 6c       	lddpc	r12,800026f8 <mic_reply_func+0x78>
800026a4:	f0 1f 00 14 	mcall	800026f4 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026a8:	0f a8       	ld.ub	r8,r7[0x2]
800026aa:	1a d8       	st.w	--sp,r8
800026ac:	49 4c       	lddpc	r12,800026fc <mic_reply_func+0x7c>
800026ae:	f0 1f 00 12 	mcall	800026f4 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026b2:	0f b8       	ld.ub	r8,r7[0x3]
800026b4:	1a d8       	st.w	--sp,r8
800026b6:	49 3c       	lddpc	r12,80002700 <mic_reply_func+0x80>
800026b8:	f0 1f 00 0f 	mcall	800026f4 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026bc:	0f c8       	ld.ub	r8,r7[0x4]
800026be:	1a d8       	st.w	--sp,r8
800026c0:	49 1c       	lddpc	r12,80002704 <mic_reply_func+0x84>
800026c2:	f0 1f 00 0d 	mcall	800026f4 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026c6:	0f d8       	ld.ub	r8,r7[0x5]
800026c8:	1a d8       	st.w	--sp,r8
800026ca:	49 0c       	lddpc	r12,80002708 <mic_reply_func+0x88>
800026cc:	f0 1f 00 0a 	mcall	800026f4 <mic_reply_func+0x74>
800026d0:	2f cd       	sub	sp,-16
800026d2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026d6:	1a d8       	st.w	--sp,r8
800026d8:	48 dc       	lddpc	r12,8000270c <mic_reply_func+0x8c>
800026da:	f0 1f 00 07 	mcall	800026f4 <mic_reply_func+0x74>
800026de:	2f fd       	sub	sp,-4
800026e0:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026e4:	48 bc       	lddpc	r12,80002710 <mic_reply_func+0x90>
800026e6:	f0 1f 00 04 	mcall	800026f4 <mic_reply_func+0x74>
800026ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ee:	00 00       	add	r0,r0
800026f0:	80 00       	ld.sh	r0,r0[0x0]
800026f2:	cd 78       	rjmp	800028a0 <DeviceInitializationStatus_brdcst_func+0x20>
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	66 a4       	ld.w	r4,r3[0x28]
800026f8:	80 00       	ld.sh	r0,r0[0x0]
800026fa:	cd 88       	rjmp	800028aa <DeviceInitializationStatus_brdcst_func+0x2a>
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	cd 9c       	rcall	800028b0 <DeviceInitializationStatus_brdcst_func+0x30>
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	cd b0       	breq	800026b8 <mic_reply_func+0x38>
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	cd cc       	rcall	800028be <CalculateBurst+0x6>
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	cd e4       	brge	800026c6 <mic_reply_func+0x46>
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	cd fc       	rcall	800028cc <CalculateBurst+0x14>
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	ce 14       	brge	800026d4 <mic_reply_func+0x54>

80002714 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002714:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002718:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000271c:	48 bc       	lddpc	r12,80002748 <dcm_brdcst_func+0x34>
8000271e:	f0 1f 00 0c 	mcall	8000274c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002722:	0f 88       	ld.ub	r8,r7[0x0]
80002724:	1a d8       	st.w	--sp,r8
80002726:	48 bc       	lddpc	r12,80002750 <dcm_brdcst_func+0x3c>
80002728:	f0 1f 00 09 	mcall	8000274c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000272c:	0f a8       	ld.ub	r8,r7[0x2]
8000272e:	1a d8       	st.w	--sp,r8
80002730:	48 9c       	lddpc	r12,80002754 <dcm_brdcst_func+0x40>
80002732:	f0 1f 00 07 	mcall	8000274c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002736:	0f 98       	ld.ub	r8,r7[0x1]
80002738:	1a d8       	st.w	--sp,r8
8000273a:	48 8c       	lddpc	r12,80002758 <dcm_brdcst_func+0x44>
8000273c:	f0 1f 00 04 	mcall	8000274c <dcm_brdcst_func+0x38>
80002740:	2f dd       	sub	sp,-12
	
	
}
80002742:	e3 cd 80 80 	ldm	sp++,r7,pc
80002746:	00 00       	add	r0,r0
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	ce 24       	brge	8000270e <mic_reply_func+0x8e>
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	66 a4       	ld.w	r4,r3[0x28]
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	ce 38       	rjmp	80002918 <payload_rx_process+0xc>
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	ce 4c       	rcall	8000291e <payload_rx_process+0x12>
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	ce 64       	brge	80002726 <dcm_brdcst_func+0x12>

8000275c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000275c:	eb cd 40 80 	pushm	r7,lr
80002760:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002762:	19 a9       	ld.ub	r9,r12[0x2]
80002764:	30 08       	mov	r8,0
80002766:	f0 09 18 00 	cp.b	r9,r8
8000276a:	c1 b1       	brne	800027a0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000276c:	19 b8       	ld.ub	r8,r12[0x3]
8000276e:	30 19       	mov	r9,1
80002770:	f2 08 18 00 	cp.b	r8,r9
80002774:	c0 51       	brne	8000277e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002776:	48 ec       	lddpc	r12,800027ac <dcm_reply_func+0x50>
80002778:	f0 1f 00 0e 	mcall	800027b0 <dcm_reply_func+0x54>
8000277c:	c0 a8       	rjmp	80002790 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000277e:	58 08       	cp.w	r8,0
80002780:	c0 51       	brne	8000278a <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002782:	48 dc       	lddpc	r12,800027b4 <dcm_reply_func+0x58>
80002784:	f0 1f 00 0b 	mcall	800027b0 <dcm_reply_func+0x54>
80002788:	c0 48       	rjmp	80002790 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000278a:	48 cc       	lddpc	r12,800027b8 <dcm_reply_func+0x5c>
8000278c:	f0 1f 00 09 	mcall	800027b0 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002790:	0f d8       	ld.ub	r8,r7[0x5]
80002792:	1a d8       	st.w	--sp,r8
80002794:	48 ac       	lddpc	r12,800027bc <dcm_reply_func+0x60>
80002796:	f0 1f 00 07 	mcall	800027b0 <dcm_reply_func+0x54>
8000279a:	2f fd       	sub	sp,-4
8000279c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027a0:	48 8c       	lddpc	r12,800027c0 <dcm_reply_func+0x64>
800027a2:	f0 1f 00 04 	mcall	800027b0 <dcm_reply_func+0x54>
800027a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800027aa:	00 00       	add	r0,r0
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	ce 80       	breq	8000277e <dcm_reply_func+0x22>
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	66 a4       	ld.w	r4,r3[0x28]
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	ce 94       	brge	80002788 <dcm_reply_func+0x2c>
800027b8:	80 00       	ld.sh	r0,r0[0x0]
800027ba:	ce a8       	rjmp	8000298e <phy_rx+0x1a>
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	ce bc       	rcall	80002994 <phy_rx+0x20>
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	ce c8       	rjmp	8000299a <phy_rx+0x26>

800027c4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027c4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027c6:	19 a9       	ld.ub	r9,r12[0x2]
800027c8:	30 08       	mov	r8,0
800027ca:	f0 09 18 00 	cp.b	r9,r8
800027ce:	c0 51       	brne	800027d8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027d0:	48 4c       	lddpc	r12,800027e0 <ToneControl_reply_func+0x1c>
800027d2:	f0 1f 00 05 	mcall	800027e4 <ToneControl_reply_func+0x20>
800027d6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027d8:	48 4c       	lddpc	r12,800027e8 <ToneControl_reply_func+0x24>
800027da:	f0 1f 00 03 	mcall	800027e4 <ToneControl_reply_func+0x20>
800027de:	d8 02       	popm	pc
800027e0:	80 00       	ld.sh	r0,r0[0x0]
800027e2:	ce d4       	brge	800027bc <dcm_reply_func+0x60>
800027e4:	80 00       	ld.sh	r0,r0[0x0]
800027e6:	66 a4       	ld.w	r4,r3[0x28]
800027e8:	80 00       	ld.sh	r0,r0[0x0]
800027ea:	ce dc       	rcall	800029c4 <set_idle_store+0x18>

800027ec <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800027ec:	eb cd 40 80 	pushm	r7,lr
800027f0:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
800027f2:	48 b9       	lddpc	r9,8000281c <app_payload_rx_proc+0x30>
800027f4:	13 88       	ld.ub	r8,r9[0x0]
800027f6:	2f f8       	sub	r8,-1
800027f8:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 30)
800027fa:	31 e9       	mov	r9,30
800027fc:	f2 08 18 00 	cp.b	r8,r9
80002800:	c0 71       	brne	8000280e <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
80002802:	30 09       	mov	r9,0
80002804:	48 68       	lddpc	r8,8000281c <app_payload_rx_proc+0x30>
80002806:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002808:	48 6c       	lddpc	r12,80002820 <app_payload_rx_proc+0x34>
8000280a:	f0 1f 00 07 	mcall	80002824 <app_payload_rx_proc+0x38>
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000280e:	48 78       	lddpc	r8,80002828 <app_payload_rx_proc+0x3c>
80002810:	70 0c       	ld.w	r12,r8[0x0]
80002812:	0e 9b       	mov	r11,r7
80002814:	f0 1f 00 06 	mcall	8000282c <app_payload_rx_proc+0x40>

}
80002818:	e3 cd 80 80 	ldm	sp++,r7,pc
8000281c:	00 00       	add	r0,r0
8000281e:	0a 3a       	cp.w	r10,r5
80002820:	80 00       	ld.sh	r0,r0[0x0]
80002822:	ce e8       	rjmp	800029fe <phy_tx+0x32>
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	66 a4       	ld.w	r4,r3[0x28]
80002828:	00 00       	add	r0,r0
8000282a:	0a 70       	tst	r0,r5
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	29 ac       	sub	r12,-102

80002830 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002830:	eb cd 40 80 	pushm	r7,lr
80002834:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002836:	19 a9       	ld.ub	r9,r12[0x2]
80002838:	30 08       	mov	r8,0
8000283a:	f0 09 18 00 	cp.b	r9,r8
8000283e:	c0 c1       	brne	80002856 <AudioRoutingControl_reply_func+0x26>
	{
		log("AudioRouting OK");
80002840:	48 bc       	lddpc	r12,8000286c <AudioRoutingControl_reply_func+0x3c>
80002842:	f0 1f 00 0c 	mcall	80002870 <AudioRoutingControl_reply_func+0x40>
		xcmp_IdleTestTone();//提示通道配置成功
80002846:	f0 1f 00 0c 	mcall	80002874 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
8000284a:	f0 1f 00 0b 	mcall	80002874 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
8000284e:	f0 1f 00 0a 	mcall	80002874 <AudioRoutingControl_reply_func+0x44>
80002852:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002856:	48 9c       	lddpc	r12,80002878 <AudioRoutingControl_reply_func+0x48>
80002858:	f0 1f 00 06 	mcall	80002870 <AudioRoutingControl_reply_func+0x40>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
8000285c:	0f a8       	ld.ub	r8,r7[0x2]
8000285e:	1a d8       	st.w	--sp,r8
80002860:	48 7c       	lddpc	r12,8000287c <AudioRoutingControl_reply_func+0x4c>
80002862:	f0 1f 00 04 	mcall	80002870 <AudioRoutingControl_reply_func+0x40>
80002866:	2f fd       	sub	sp,-4
80002868:	e3 cd 80 80 	ldm	sp++,r7,pc
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	ce f4       	brge	8000284c <AudioRoutingControl_reply_func+0x1c>
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	66 a4       	ld.w	r4,r3[0x28]
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	44 78       	lddsp	r8,sp[0x11c]
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	cf 04       	brge	8000285a <AudioRoutingControl_reply_func+0x2a>
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	cf 18       	rjmp	80002a60 <phy_tx_func+0x10>

80002880 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002880:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002882:	19 e8       	ld.ub	r8,r12[0x6]
80002884:	30 19       	mov	r9,1
80002886:	f2 08 18 00 	cp.b	r8,r9
8000288a:	c0 61       	brne	80002896 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
8000288c:	48 98       	lddpc	r8,800028b0 <DeviceInitializationStatus_brdcst_func+0x30>
8000288e:	70 09       	ld.w	r9,r8[0x0]
80002890:	a1 a9       	sbr	r9,0x0
80002892:	91 09       	st.w	r8[0x0],r9
80002894:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002896:	30 29       	mov	r9,2
80002898:	f2 08 18 00 	cp.b	r8,r9
8000289c:	c0 80       	breq	800028ac <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
8000289e:	48 58       	lddpc	r8,800028b0 <DeviceInitializationStatus_brdcst_func+0x30>
800028a0:	70 09       	ld.w	r9,r8[0x0]
800028a2:	e0 19 ff fc 	andl	r9,0xfffc
800028a6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028a8:	f0 1f 00 03 	mcall	800028b4 <DeviceInitializationStatus_brdcst_func+0x34>
800028ac:	d8 02       	popm	pc
800028ae:	00 00       	add	r0,r0
800028b0:	00 00       	add	r0,r0
800028b2:	0d c0       	ld.ub	r0,r6[0x4]
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	43 cc       	lddsp	r12,sp[0xf0]

800028b8 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028b8:	20 1c       	sub	r12,1
800028ba:	5c 5c       	castu.b	r12
800028bc:	31 18       	mov	r8,17
800028be:	f0 0c 18 00 	cp.b	r12,r8
800028c2:	e0 88 00 03 	brls	800028c8 <CalculateBurst+0x10>
800028c6:	5e fd       	retal	0
800028c8:	48 28       	lddpc	r8,800028d0 <CalculateBurst+0x18>
800028ca:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028ce:	5e fc       	retal	r12
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	cf 38       	rjmp	80002ab8 <phy_tx_func+0x68>

800028d4 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028d4:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028d6:	48 98       	lddpc	r8,800028f8 <payload_init+0x24>
800028d8:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028da:	48 98       	lddpc	r8,800028fc <payload_init+0x28>
800028dc:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028de:	30 09       	mov	r9,0
800028e0:	1a d9       	st.w	--sp,r9
800028e2:	1a d9       	st.w	--sp,r9
800028e4:	1a d9       	st.w	--sp,r9
800028e6:	30 28       	mov	r8,2
800028e8:	e0 6a 04 00 	mov	r10,1024
800028ec:	48 5b       	lddpc	r11,80002900 <payload_init+0x2c>
800028ee:	48 6c       	lddpc	r12,80002904 <payload_init+0x30>
800028f0:	f0 1f 00 06 	mcall	80002908 <payload_init+0x34>
800028f4:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
800028f6:	d8 02       	popm	pc
800028f8:	00 00       	add	r0,r0
800028fa:	0a 58       	eor	r8,r5
800028fc:	00 00       	add	r0,r0
800028fe:	0a 5c       	eor	r12,r5
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	d5 30       	acall	0x53
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	29 0c       	sub	r12,-112
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	62 e0       	ld.w	r0,r1[0x38]

8000290c <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
8000290c:	eb cd 40 f8 	pushm	r3-r7,lr
80002910:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002912:	48 e8       	lddpc	r8,80002948 <payload_rx_process+0x3c>
80002914:	70 08       	ld.w	r8,r8[0x0]
80002916:	58 08       	cp.w	r8,0
80002918:	c0 71       	brne	80002926 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000291a:	30 4b       	mov	r11,4
8000291c:	30 5c       	mov	r12,5
8000291e:	f0 1f 00 0c 	mcall	8000294c <payload_rx_process+0x40>
80002922:	48 a8       	lddpc	r8,80002948 <payload_rx_process+0x3c>
80002924:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002926:	48 96       	lddpc	r6,80002948 <payload_rx_process+0x3c>
80002928:	30 05       	mov	r5,0
8000292a:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000292c:	48 93       	lddpc	r3,80002950 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000292e:	6c 0c       	ld.w	r12,r6[0x0]
80002930:	0a 99       	mov	r9,r5
80002932:	08 9a       	mov	r10,r4
80002934:	1a 9b       	mov	r11,sp
80002936:	f0 1f 00 08 	mcall	80002954 <payload_rx_process+0x48>
8000293a:	58 1c       	cp.w	r12,1
8000293c:	cf 91       	brne	8000292e <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000293e:	66 08       	ld.w	r8,r3[0x0]
80002940:	40 0c       	lddsp	r12,sp[0x0]
80002942:	5d 18       	icall	r8
80002944:	cf 5b       	rjmp	8000292e <payload_rx_process+0x22>
80002946:	00 00       	add	r0,r0
80002948:	00 00       	add	r0,r0
8000294a:	0a f4       	st.b	--r5,r4
8000294c:	80 00       	ld.sh	r0,r0[0x0]
8000294e:	5c 0c       	acr	r12
80002950:	00 00       	add	r0,r0
80002952:	0a 58       	eor	r8,r5
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	58 a8       	cp.w	r8,10

80002958 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002958:	d4 01       	pushm	lr
8000295a:	20 2d       	sub	sp,8
8000295c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000295e:	30 09       	mov	r9,0
80002960:	fa ca ff f8 	sub	r10,sp,-8
80002964:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002966:	1a 9b       	mov	r11,sp
80002968:	f0 1f 00 02 	mcall	80002970 <set_idle_store_isr+0x18>
}
8000296c:	2f ed       	sub	sp,-8
8000296e:	d8 02       	popm	pc
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	5a 64       	cp.w	r4,-26

80002974 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002974:	d4 01       	pushm	lr
80002976:	20 2d       	sub	sp,8
80002978:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000297a:	58 0c       	cp.w	r12,0
8000297c:	c1 10       	breq	8000299e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000297e:	30 08       	mov	r8,0
80002980:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002982:	98 88       	ld.uh	r8,r12[0x0]
80002984:	e2 18 f0 00 	andl	r8,0xf000,COH
80002988:	e0 48 40 00 	cp.w	r8,16384
8000298c:	c0 91       	brne	8000299e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
8000298e:	48 68       	lddpc	r8,800029a4 <phy_rx+0x30>
80002990:	70 0c       	ld.w	r12,r8[0x0]
80002992:	30 09       	mov	r9,0
80002994:	fa ca ff fc 	sub	r10,sp,-4
80002998:	1a 9b       	mov	r11,sp
8000299a:	f0 1f 00 04 	mcall	800029a8 <phy_rx+0x34>
		}	

    }
		
 
}
8000299e:	2f ed       	sub	sp,-8
800029a0:	d8 02       	popm	pc
800029a2:	00 00       	add	r0,r0
800029a4:	00 00       	add	r0,r0
800029a6:	0a d4       	st.w	--r5,r4
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	5a 64       	cp.w	r4,-26

800029ac <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029ac:	eb cd 40 80 	pushm	r7,lr
800029b0:	20 1d       	sub	sp,4
800029b2:	fa c7 ff fc 	sub	r7,sp,-4
800029b6:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029b8:	30 09       	mov	r9,0
800029ba:	12 9a       	mov	r10,r9
800029bc:	1a 9b       	mov	r11,sp
800029be:	f0 1f 00 03 	mcall	800029c8 <set_idle_store+0x1c>
}
800029c2:	2f fd       	sub	sp,-4
800029c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	5a b4       	cp.w	r4,-21

800029cc <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029cc:	d4 01       	pushm	lr
800029ce:	20 1d       	sub	sp,4
800029d0:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029d2:	98 88       	ld.uh	r8,r12[0x0]
800029d4:	e2 18 f0 00 	andl	r8,0xf000,COH
800029d8:	e0 48 40 00 	cp.w	r8,16384
800029dc:	c0 d1       	brne	800029f6 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029de:	49 08       	lddpc	r8,80002a1c <phy_tx+0x50>
800029e0:	70 08       	ld.w	r8,r8[0x0]
800029e2:	58 08       	cp.w	r8,0
800029e4:	c1 a0       	breq	80002a18 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800029e6:	48 e8       	lddpc	r8,80002a1c <phy_tx+0x50>
800029e8:	70 0c       	ld.w	r12,r8[0x0]
800029ea:	30 09       	mov	r9,0
800029ec:	12 9a       	mov	r10,r9
800029ee:	1a 9b       	mov	r11,sp
800029f0:	f0 1f 00 0c 	mcall	80002a20 <phy_tx+0x54>
800029f4:	c1 28       	rjmp	80002a18 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800029f6:	e0 48 10 00 	cp.w	r8,4096
800029fa:	5f 0a       	sreq	r10
800029fc:	e0 48 20 00 	cp.w	r8,8192
80002a00:	5f 09       	sreq	r9
80002a02:	f5 e9 10 09 	or	r9,r10,r9
80002a06:	c0 71       	brne	80002a14 <phy_tx+0x48>
80002a08:	e0 48 50 00 	cp.w	r8,20480
80002a0c:	c0 40       	breq	80002a14 <phy_tx+0x48>
80002a0e:	e0 48 60 00 	cp.w	r8,24576
80002a12:	c0 31       	brne	80002a18 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a14:	48 48       	lddpc	r8,80002a24 <phy_tx+0x58>
80002a16:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a18:	2f fd       	sub	sp,-4
80002a1a:	d8 02       	popm	pc
80002a1c:	00 00       	add	r0,r0
80002a1e:	0a ec       	st.h	--r5,r12
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	5a b4       	cp.w	r4,-21
80002a24:	00 00       	add	r0,r0
80002a26:	0a b8       	st.h	r5++,r8

80002a28 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a28:	d4 01       	pushm	lr
80002a2a:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a2c:	30 08       	mov	r8,0
80002a2e:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a30:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a32:	1a 9a       	mov	r10,sp
80002a34:	fa cb ff fc 	sub	r11,sp,-4
80002a38:	f0 1f 00 05 	mcall	80002a4c <get_idle_store_isr+0x24>
80002a3c:	58 1c       	cp.w	r12,1
80002a3e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a42:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a46:	2f ed       	sub	sp,-8
80002a48:	d8 02       	popm	pc
80002a4a:	00 00       	add	r0,r0
80002a4c:	80 00       	ld.sh	r0,r0[0x0]
80002a4e:	57 b8       	stdsp	sp[0x1ec],r8

80002a50 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a50:	eb cd 40 c0 	pushm	r6-r7,lr
80002a54:	20 1d       	sub	sp,4
80002a56:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a58:	fe f8 06 f8 	ld.w	r8,pc[1784]
80002a5c:	70 08       	ld.w	r8,r8[0x0]
80002a5e:	58 08       	cp.w	r8,0
80002a60:	c7 40       	breq	80002b48 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a62:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a64:	30 08       	mov	r8,0
80002a66:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a68:	fe f8 06 ec 	ld.w	r8,pc[1772]
80002a6c:	70 08       	ld.w	r8,r8[0x0]
80002a6e:	58 18       	cp.w	r8,1
80002a70:	c2 90       	breq	80002ac2 <phy_tx_func+0x72>
80002a72:	c0 43       	brcs	80002a7a <phy_tx_func+0x2a>
80002a74:	58 28       	cp.w	r8,2
80002a76:	c6 91       	brne	80002b48 <phy_tx_func+0xf8>
80002a78:	c6 18       	rjmp	80002b3a <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a7a:	fe f8 06 d6 	ld.w	r8,pc[1750]
80002a7e:	70 0c       	ld.w	r12,r8[0x0]
80002a80:	1a 9a       	mov	r10,sp
80002a82:	fe fb 06 d6 	ld.w	r11,pc[1750]
80002a86:	f0 1f 01 b6 	mcall	8000315c <phy_tx_func+0x70c>
80002a8a:	58 1c       	cp.w	r12,1
80002a8c:	c1 51       	brne	80002ab6 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002a8e:	fe f8 06 ca 	ld.w	r8,pc[1738]
80002a92:	70 08       	ld.w	r8,r8[0x0]
80002a94:	11 9a       	ld.ub	r10,r8[0x1]
80002a96:	fe f9 06 ca 	ld.w	r9,pc[1738]
80002a9a:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002a9c:	90 88       	ld.uh	r8,r8[0x0]
80002a9e:	ea 18 ab cd 	orh	r8,0xabcd
80002aa2:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002aa4:	30 19       	mov	r9,1
80002aa6:	fe f8 06 be 	ld.w	r8,pc[1726]
80002aaa:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002aac:	30 19       	mov	r9,1
80002aae:	fe f8 06 a6 	ld.w	r8,pc[1702]
80002ab2:	91 09       	st.w	r8[0x0],r9
80002ab4:	c4 a8       	rjmp	80002b48 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002ab6:	e0 68 5a 5a 	mov	r8,23130
80002aba:	ea 18 ab cd 	orh	r8,0xabcd
80002abe:	8f 18       	st.w	r7[0x4],r8
80002ac0:	c4 48       	rjmp	80002b48 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ac2:	fe f9 06 a2 	ld.w	r9,pc[1698]
80002ac6:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002ac8:	fe fa 06 90 	ld.w	r10,pc[1680]
80002acc:	74 0a       	ld.w	r10,r10[0x0]
80002ace:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002ad2:	b1 6a       	lsl	r10,0x10
80002ad4:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ad6:	2f f8       	sub	r8,-1
80002ad8:	5c 58       	castu.b	r8
80002ada:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002adc:	fe fa 06 84 	ld.w	r10,pc[1668]
80002ae0:	94 09       	ld.sh	r9,r10[0x0]
80002ae2:	20 29       	sub	r9,2
80002ae4:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002ae6:	30 0a       	mov	r10,0
80002ae8:	f4 09 19 00 	cp.h	r9,r10
80002aec:	e0 89 00 0b 	brgt	80002b02 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002af0:	78 18       	ld.w	r8,r12[0x4]
80002af2:	e8 18 00 ba 	orl	r8,0xba
80002af6:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002af8:	30 09       	mov	r9,0
80002afa:	fe f8 06 5a 	ld.w	r8,pc[1626]
80002afe:	91 09       	st.w	r8[0x0],r9
80002b00:	c2 48       	rjmp	80002b48 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b02:	fe f9 06 56 	ld.w	r9,pc[1622]
80002b06:	72 09       	ld.w	r9,r9[0x0]
80002b08:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b0c:	78 1a       	ld.w	r10,r12[0x4]
80002b0e:	f5 e9 10 09 	or	r9,r10,r9
80002b12:	99 19       	st.w	r12[0x4],r9
80002b14:	2f f8       	sub	r8,-1
80002b16:	fe f9 06 4e 	ld.w	r9,pc[1614]
80002b1a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b1c:	fe f9 06 44 	ld.w	r9,pc[1604]
80002b20:	92 08       	ld.sh	r8,r9[0x0]
80002b22:	20 28       	sub	r8,2
80002b24:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b26:	30 09       	mov	r9,0
80002b28:	f2 08 19 00 	cp.h	r8,r9
80002b2c:	e0 89 00 0e 	brgt	80002b48 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b30:	30 29       	mov	r9,2
80002b32:	fe f8 06 22 	ld.w	r8,pc[1570]
80002b36:	91 09       	st.w	r8[0x0],r9
80002b38:	c0 88       	rjmp	80002b48 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b3a:	fc 18 00 ba 	movh	r8,0xba
80002b3e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b40:	30 09       	mov	r9,0
80002b42:	fe f8 06 12 	ld.w	r8,pc[1554]
80002b46:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_tx_flag == TRUE) || (AMBE_rx_flag == TRUE))
80002b48:	fe f8 06 20 	ld.w	r8,pc[1568]
80002b4c:	11 89       	ld.ub	r9,r8[0x0]
80002b4e:	30 18       	mov	r8,1
80002b50:	f0 09 18 00 	cp.b	r9,r8
80002b54:	c0 90       	breq	80002b66 <phy_tx_func+0x116>
80002b56:	fe f8 06 16 	ld.w	r8,pc[1558]
80002b5a:	11 89       	ld.ub	r9,r8[0x0]
80002b5c:	30 18       	mov	r8,1
80002b5e:	f0 09 18 00 	cp.b	r9,r8
80002b62:	e0 81 01 65 	brne	80002e2c <phy_tx_func+0x3dc>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b66:	fe f8 06 0a 	ld.w	r8,pc[1546]
80002b6a:	70 08       	ld.w	r8,r8[0x0]
80002b6c:	e0 48 05 b0 	cp.w	r8,1456
80002b70:	f9 b8 02 00 	movhs	r8,0
80002b74:	fe f9 05 fc 	ld.w	r9,pc[1532]
80002b78:	93 08       	st.w	r9[0x0],r8

	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002b7a:	fe f9 05 fa 	ld.w	r9,pc[1530]
80002b7e:	72 09       	ld.w	r9,r9[0x0]
80002b80:	58 29       	cp.w	r9,2
80002b82:	e0 80 00 92 	breq	80002ca6 <phy_tx_func+0x256>
80002b86:	e0 8b 00 08 	brhi	80002b96 <phy_tx_func+0x146>
80002b8a:	58 09       	cp.w	r9,0
80002b8c:	c0 e0       	breq	80002ba8 <phy_tx_func+0x158>
80002b8e:	58 19       	cp.w	r9,1
80002b90:	e0 81 01 42 	brne	80002e14 <phy_tx_func+0x3c4>
80002b94:	c5 78       	rjmp	80002c42 <phy_tx_func+0x1f2>
80002b96:	58 49       	cp.w	r9,4
80002b98:	e0 80 00 c5 	breq	80002d22 <phy_tx_func+0x2d2>
80002b9c:	e0 83 00 9c 	brlo	80002cd4 <phy_tx_func+0x284>
80002ba0:	58 59       	cp.w	r9,5
80002ba2:	e0 81 01 39 	brne	80002e14 <phy_tx_func+0x3c4>
80002ba6:	c2 a9       	rjmp	80002dfa <phy_tx_func+0x3aa>
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002ba8:	fe f8 05 d0 	ld.w	r8,pc[1488]
80002bac:	70 08       	ld.w	r8,r8[0x0]
80002bae:	58 08       	cp.w	r8,0
80002bb0:	c0 b0       	breq	80002bc6 <phy_tx_func+0x176>
80002bb2:	fe f8 05 c6 	ld.w	r8,pc[1478]
80002bb6:	70 08       	ld.w	r8,r8[0x0]
80002bb8:	58 a8       	cp.w	r8,10
80002bba:	c0 60       	breq	80002bc6 <phy_tx_func+0x176>
80002bbc:	fe f8 05 bc 	ld.w	r8,pc[1468]
80002bc0:	70 08       	ld.w	r8,r8[0x0]
80002bc2:	58 18       	cp.w	r8,1
80002bc4:	c0 a1       	brne	80002bd8 <phy_tx_func+0x188>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bc6:	e0 68 5a 5a 	mov	r8,23130
80002bca:	ea 18 ab cd 	orh	r8,0xabcd
80002bce:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002bd0:	30 08       	mov	r8,0
80002bd2:	8f 38       	st.w	r7[0xc],r8
80002bd4:	e0 8f 02 ba 	bral	80003148 <phy_tx_func+0x6f8>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002bd8:	fe f8 05 a0 	ld.w	r8,pc[1440]
80002bdc:	70 08       	ld.w	r8,r8[0x0]
80002bde:	58 38       	cp.w	r8,3
80002be0:	c0 91       	brne	80002bf2 <phy_tx_func+0x1a2>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002be2:	fe f8 05 9a 	ld.w	r8,pc[1434]
80002be6:	70 09       	ld.w	r9,r8[0x0]
80002be8:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bea:	70 18       	ld.w	r8,r8[0x4]
80002bec:	8f 38       	st.w	r7[0xc],r8
80002bee:	e0 8f 02 ad 	bral	80003148 <phy_tx_func+0x6f8>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 3 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002bf2:	fe f8 05 86 	ld.w	r8,pc[1414]
80002bf6:	70 08       	ld.w	r8,r8[0x0]
80002bf8:	58 28       	cp.w	r8,2
80002bfa:	c1 31       	brne	80002c20 <phy_tx_func+0x1d0>
					{
						//0xABCDCO14
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//49bits
80002bfc:	e0 68 c0 14 	mov	r8,49172
80002c00:	ea 18 ab cd 	orh	r8,0xabcd
80002c04:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c06:	fe 78 84 7f 	mov	r8,-31617
80002c0a:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c0c:	fe f8 05 74 	ld.w	r8,pc[1396]
80002c10:	90 08       	ld.sh	r8,r8[0x0]
80002c12:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c14:	30 39       	mov	r9,3
80002c16:	fe f8 05 5e 	ld.w	r8,pc[1374]
80002c1a:	91 09       	st.w	r8[0x0],r9
80002c1c:	e0 8f 02 96 	bral	80003148 <phy_tx_func+0x6f8>
					
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c20:	e0 68 c0 0e 	mov	r8,49166
80002c24:	ea 18 ab cd 	orh	r8,0xabcd
80002c28:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c2a:	fe f8 05 5a 	ld.w	r8,pc[1370]
80002c2e:	90 09       	ld.sh	r9,r8[0x0]
80002c30:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c32:	90 18       	ld.sh	r8,r8[0x2]
80002c34:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c36:	30 19       	mov	r9,1
80002c38:	fe f8 05 3c 	ld.w	r8,pc[1340]
80002c3c:	91 09       	st.w	r8[0x0],r9
80002c3e:	e0 8f 02 85 	bral	80003148 <phy_tx_func+0x6f8>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c42:	fe 78 88 f2 	mov	r8,-30478
80002c46:	ae 48       	st.h	r7[0x8],r8
				
				payload_tx_channel->word[1] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002c48:	fe f8 05 28 	ld.w	r8,pc[1320]
80002c4c:	70 0a       	ld.w	r10,r8[0x0]
80002c4e:	fe f9 05 3a 	ld.w	r9,pc[1338]
80002c52:	f2 0a 00 0b 	add	r11,r9,r10
80002c56:	17 9b       	ld.ub	r11,r11[0x1]
80002c58:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002c5c:	a9 6a       	lsl	r10,0x8
80002c5e:	f6 0a 00 0a 	add	r10,r11,r10
80002c62:	ae 5a       	st.h	r7[0xa],r10
				A_index+=2;
80002c64:	70 0a       	ld.w	r10,r8[0x0]
80002c66:	2f ea       	sub	r10,-2
80002c68:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[2] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002c6a:	f2 0a 00 0b 	add	r11,r9,r10
80002c6e:	17 9b       	ld.ub	r11,r11[0x1]
80002c70:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002c74:	a9 6a       	lsl	r10,0x8
80002c76:	f6 0a 00 0a 	add	r10,r11,r10
80002c7a:	ae 6a       	st.h	r7[0xc],r10
				A_index+=2;
80002c7c:	70 0a       	ld.w	r10,r8[0x0]
80002c7e:	2f ea       	sub	r10,-2
80002c80:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[3] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002c82:	f2 0a 00 0b 	add	r11,r9,r10
80002c86:	17 9b       	ld.ub	r11,r11[0x1]
80002c88:	f2 0a 07 09 	ld.ub	r9,r9[r10]
80002c8c:	a9 69       	lsl	r9,0x8
80002c8e:	f6 09 00 09 	add	r9,r11,r9
80002c92:	ae 79       	st.h	r7[0xe],r9
				A_index+=2;
80002c94:	70 09       	ld.w	r9,r8[0x0]
80002c96:	2f e9       	sub	r9,-2
80002c98:	91 09       	st.w	r8[0x0],r9
				
				AMBEpayload_tx_state = AMBE_EN_LAST;
80002c9a:	30 29       	mov	r9,2
80002c9c:	fe f8 04 d8 	ld.w	r8,pc[1240]
80002ca0:	91 09       	st.w	r8[0x0],r9
80002ca2:	e0 8f 02 53 	bral	80003148 <phy_tx_func+0x6f8>
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
					
					}
					
					***/
					payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
80002ca6:	fe f9 04 e2 	ld.w	r9,pc[1250]
80002caa:	f2 08 07 08 	ld.ub	r8,r9[r8]
80002cae:	a9 68       	lsl	r8,0x8
80002cb0:	ae 48       	st.h	r7[0x8],r8
					A_index+=1;
80002cb2:	fe f8 04 be 	ld.w	r8,pc[1214]
80002cb6:	70 09       	ld.w	r9,r8[0x0]
80002cb8:	2f f9       	sub	r9,-1
80002cba:	91 09       	st.w	r8[0x0],r9
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002cbc:	e0 68 00 ba 	mov	r8,186
80002cc0:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002cc2:	30 08       	mov	r8,0
80002cc4:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002cc6:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002cc8:	30 09       	mov	r9,0
80002cca:	fe f8 04 aa 	ld.w	r8,pc[1194]
80002cce:	91 09       	st.w	r8[0x0],r9
80002cd0:	e0 8f 02 3c 	bral	80003148 <phy_tx_func+0x6f8>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002cd4:	fe f8 04 ac 	ld.w	r8,pc[1196]
80002cd8:	90 18       	ld.sh	r8,r8[0x2]
80002cda:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002cdc:	fe f8 04 a8 	ld.w	r8,pc[1192]
80002ce0:	90 08       	ld.sh	r8,r8[0x0]
80002ce2:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002ce4:	fe f8 04 94 	ld.w	r8,pc[1172]
80002ce8:	70 08       	ld.w	r8,r8[0x0]
80002cea:	58 48       	cp.w	r8,4
80002cec:	c0 e1       	brne	80002d08 <phy_tx_func+0x2b8>
80002cee:	fe f8 04 9e 	ld.w	r8,pc[1182]
80002cf2:	11 89       	ld.ub	r9,r8[0x0]
80002cf4:	30 18       	mov	r8,1
80002cf6:	f0 09 18 00 	cp.b	r9,r8
80002cfa:	c0 71       	brne	80002d08 <phy_tx_func+0x2b8>
					{
						// Vocoder Bits Stream Parameter("E" flag = 1)
						//0xF08x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0080));
80002cfc:	fe f8 04 88 	ld.w	r8,pc[1160]
80002d00:	90 18       	ld.sh	r8,r8[0x2]
80002d02:	a7 b8       	sbr	r8,0x7
80002d04:	ae 68       	st.h	r7[0xc],r8
80002d06:	c0 58       	rjmp	80002d10 <phy_tx_func+0x2c0>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d08:	fe f8 04 7c 	ld.w	r8,pc[1148]
80002d0c:	90 18       	ld.sh	r8,r8[0x2]
80002d0e:	ae 68       	st.h	r7[0xc],r8
					
					//0x88F3
					payload_tx_channel->word[3] = DECODER_PAYLOAD;
80002d10:	fe 78 88 f3 	mov	r8,-30477
80002d14:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d16:	30 49       	mov	r9,4
80002d18:	fe f8 04 5c 	ld.w	r8,pc[1116]
80002d1c:	91 09       	st.w	r8[0x0],r9
80002d1e:	e0 8f 02 15 	bral	80003148 <phy_tx_func+0x6f8>
					
				break;
			case AMBE_DE_SECOND:
					
				switch (m_RxBurstType)//在发送函数中去做解密处理
80002d22:	fe f8 04 56 	ld.w	r8,pc[1110]
80002d26:	70 08       	ld.w	r8,r8[0x0]
80002d28:	58 48       	cp.w	r8,4
80002d2a:	c0 60       	breq	80002d36 <phy_tx_func+0x2e6>
80002d2c:	c5 b3       	brcs	80002de2 <phy_tx_func+0x392>
80002d2e:	58 98       	cp.w	r8,9
80002d30:	e0 8b 00 59 	brhi	80002de2 <phy_tx_func+0x392>
80002d34:	c3 a8       	rjmp	80002da8 <phy_tx_func+0x358>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002d36:	fe f8 04 56 	ld.w	r8,pc[1110]
80002d3a:	11 89       	ld.ub	r9,r8[0x0]
80002d3c:	30 18       	mov	r8,1
80002d3e:	f0 09 18 00 	cp.b	r9,r8
80002d42:	c1 61       	brne	80002d6e <phy_tx_func+0x31e>
							{	
								//Pick up public key
								
								AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002d44:	fe f8 04 4c 	ld.w	r8,pc[1100]
80002d48:	90 0a       	ld.sh	r10,r8[0x0]
80002d4a:	fe f9 04 4a 	ld.w	r9,pc[1098]
80002d4e:	b2 0a       	st.h	r9[0x0],r10
								AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002d50:	90 1a       	ld.sh	r10,r8[0x2]
80002d52:	b2 1a       	st.h	r9[0x2],r10
								AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002d54:	90 2a       	ld.sh	r10,r8[0x4]
80002d56:	b2 2a       	st.h	r9[0x4],r10
								AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002d58:	90 3a       	ld.sh	r10,r8[0x6]
80002d5a:	b2 3a       	st.h	r9[0x6],r10
								
								//Post back data
								payload_tx_channel->word[0] = AMBEBurst_rawdata[0] ;
80002d5c:	90 09       	ld.sh	r9,r8[0x0]
80002d5e:	ae 49       	st.h	r7[0x8],r9
								payload_tx_channel->word[1] = AMBEBurst_rawdata[1] ;
80002d60:	90 19       	ld.sh	r9,r8[0x2]
80002d62:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = AMBEBurst_rawdata[2] ;
80002d64:	90 29       	ld.sh	r9,r8[0x4]
80002d66:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = AMBEBurst_rawdata[3] ;
80002d68:	90 38       	ld.sh	r8,r8[0x6]
80002d6a:	ae 78       	st.h	r7[0xe],r8
80002d6c:	c1 88       	rjmp	80002d9c <phy_tx_func+0x34c>
								
								
						
								//Decrypt AMBE data(XOR) 
								//Recover data
								payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002d6e:	fe f9 04 26 	ld.w	r9,pc[1062]
80002d72:	92 0a       	ld.sh	r10,r9[0x0]
80002d74:	fe f8 04 1c 	ld.w	r8,pc[1052]
80002d78:	90 0b       	ld.sh	r11,r8[0x0]
80002d7a:	f7 ea 20 0a 	eor	r10,r11,r10
80002d7e:	ae 4a       	st.h	r7[0x8],r10
								payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002d80:	92 1a       	ld.sh	r10,r9[0x2]
80002d82:	90 1b       	ld.sh	r11,r8[0x2]
80002d84:	f7 ea 20 0a 	eor	r10,r11,r10
80002d88:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002d8a:	92 2a       	ld.sh	r10,r9[0x4]
80002d8c:	90 2b       	ld.sh	r11,r8[0x4]
80002d8e:	f7 ea 20 0a 	eor	r10,r11,r10
80002d92:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002d94:	92 39       	ld.sh	r9,r9[0x6]
80002d96:	90 38       	ld.sh	r8,r8[0x6]
80002d98:	12 58       	eor	r8,r9
80002d9a:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002d9c:	30 59       	mov	r9,5
80002d9e:	fe f8 03 d6 	ld.w	r8,pc[982]
80002da2:	91 09       	st.w	r8[0x0],r9
80002da4:	e0 8f 01 d2 	bral	80003148 <phy_tx_func+0x6f8>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002da8:	fe f9 03 ec 	ld.w	r9,pc[1004]
80002dac:	92 0a       	ld.sh	r10,r9[0x0]
80002dae:	fe f8 03 e2 	ld.w	r8,pc[994]
80002db2:	90 0b       	ld.sh	r11,r8[0x0]
80002db4:	f7 ea 20 0a 	eor	r10,r11,r10
80002db8:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002dba:	92 1a       	ld.sh	r10,r9[0x2]
80002dbc:	90 1b       	ld.sh	r11,r8[0x2]
80002dbe:	f7 ea 20 0a 	eor	r10,r11,r10
80002dc2:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002dc4:	92 2a       	ld.sh	r10,r9[0x4]
80002dc6:	90 2b       	ld.sh	r11,r8[0x4]
80002dc8:	f7 ea 20 0a 	eor	r10,r11,r10
80002dcc:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002dce:	92 39       	ld.sh	r9,r9[0x6]
80002dd0:	90 38       	ld.sh	r8,r8[0x6]
80002dd2:	12 58       	eor	r8,r9
80002dd4:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002dd6:	30 59       	mov	r9,5
80002dd8:	fe f8 03 9c 	ld.w	r8,pc[924]
80002ddc:	91 09       	st.w	r8[0x0],r9
80002dde:	e0 8f 01 b5 	bral	80003148 <phy_tx_func+0x6f8>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002de2:	e0 68 5a 5a 	mov	r8,23130
80002de6:	ea 18 ab cd 	orh	r8,0xabcd
80002dea:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002dec:	30 08       	mov	r8,0
80002dee:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002df0:	fe f9 03 84 	ld.w	r9,pc[900]
80002df4:	93 08       	st.w	r9[0x0],r8
80002df6:	e0 8f 01 a9 	bral	80003148 <phy_tx_func+0x6f8>
		
				break;
				
			case AMBE_DE_LAST:
				
					payload_tx_channel->word[0]	= 0x00BA ;
80002dfa:	e0 68 00 ba 	mov	r8,186
80002dfe:	ae 48       	st.h	r7[0x8],r8
					payload_tx_channel->word[1]	= 0x0000 ;
80002e00:	30 08       	mov	r8,0
80002e02:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002e04:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002e06:	ae 78       	st.h	r7[0xe],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002e08:	30 09       	mov	r9,0
80002e0a:	fe f8 03 6a 	ld.w	r8,pc[874]
80002e0e:	91 09       	st.w	r8[0x0],r9
80002e10:	e0 8f 01 9c 	bral	80003148 <phy_tx_func+0x6f8>
				
				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e14:	e0 68 5a 5a 	mov	r8,23130
80002e18:	ea 18 ab cd 	orh	r8,0xabcd
80002e1c:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e1e:	30 08       	mov	r8,0
80002e20:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002e22:	fe f9 03 52 	ld.w	r9,pc[850]
80002e26:	93 08       	st.w	r9[0x0],r8
80002e28:	e0 8f 01 90 	bral	80003148 <phy_tx_func+0x6f8>
#if 1
	
	else//Send-PCM-data（注意测试回放时：数字信道码流为320bytes/20ms)
	{
		
		index = (index >=30240) ? 0 : index;
80002e2c:	fe f8 03 6c 	ld.w	r8,pc[876]
80002e30:	70 08       	ld.w	r8,r8[0x0]
80002e32:	e0 48 76 20 	cp.w	r8,30240
80002e36:	f9 b8 02 00 	movhs	r8,0
80002e3a:	fe f9 03 5e 	ld.w	r9,pc[862]
80002e3e:	93 08       	st.w	r9[0x0],r8
		
		if((Radio_Transmit_State == 1) && (Mic_is_Enabled == 1))counter++;
80002e40:	fe f8 03 5c 	ld.w	r8,pc[860]
80002e44:	11 89       	ld.ub	r9,r8[0x0]
80002e46:	30 18       	mov	r8,1
80002e48:	f0 09 18 00 	cp.b	r9,r8
80002e4c:	c0 d1       	brne	80002e66 <phy_tx_func+0x416>
80002e4e:	fe f8 03 52 	ld.w	r8,pc[850]
80002e52:	11 89       	ld.ub	r9,r8[0x0]
80002e54:	30 18       	mov	r8,1
80002e56:	f0 09 18 00 	cp.b	r9,r8
80002e5a:	c0 61       	brne	80002e66 <phy_tx_func+0x416>
80002e5c:	fe f8 03 48 	ld.w	r8,pc[840]
80002e60:	70 09       	ld.w	r9,r8[0x0]
80002e62:	2f f9       	sub	r9,-1
80002e64:	91 09       	st.w	r8[0x0],r9
		
		switch(payload_tx_state)
80002e66:	fe f8 03 42 	ld.w	r8,pc[834]
80002e6a:	11 88       	ld.ub	r8,r8[0x0]
80002e6c:	30 19       	mov	r9,1
80002e6e:	f2 08 18 00 	cp.b	r8,r9
80002e72:	c3 70       	breq	80002ee0 <phy_tx_func+0x490>
80002e74:	c0 73       	brcs	80002e82 <phy_tx_func+0x432>
80002e76:	30 29       	mov	r9,2
80002e78:	f2 08 18 00 	cp.b	r8,r9
80002e7c:	e0 81 01 63 	brne	80003142 <phy_tx_func+0x6f2>
80002e80:	ca 18       	rjmp	80002fc2 <phy_tx_func+0x572>
		{
			case 0:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e82:	e0 68 5a 5a 	mov	r8,23130
80002e86:	ea 18 ab cd 	orh	r8,0xabcd
80002e8a:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e8c:	30 08       	mov	r8,0
80002e8e:	8f 38       	st.w	r7[0xc],r8
	
					if((counter % 160== 0) && (counter != 0) &&(Radio_Transmit_State == 1))//160*125us = 20ms; 
80002e90:	fe f8 03 14 	ld.w	r8,pc[788]
80002e94:	70 08       	ld.w	r8,r8[0x0]
80002e96:	e0 6b cc cd 	mov	r11,52429
80002e9a:	ea 1b cc cc 	orh	r11,0xcccc
80002e9e:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80002ea2:	f6 09 16 07 	lsr	r9,r11,0x7
80002ea6:	f2 09 00 29 	add	r9,r9,r9<<0x2
80002eaa:	a5 79       	lsl	r9,0x5
80002eac:	f0 09 01 09 	sub	r9,r8,r9
80002eb0:	c1 21       	brne	80002ed4 <phy_tx_func+0x484>
80002eb2:	58 08       	cp.w	r8,0
80002eb4:	c1 00       	breq	80002ed4 <phy_tx_func+0x484>
80002eb6:	fe f8 02 e6 	ld.w	r8,pc[742]
80002eba:	11 89       	ld.ub	r9,r8[0x0]
80002ebc:	30 18       	mov	r8,1
80002ebe:	f0 09 18 00 	cp.b	r9,r8
80002ec2:	c0 91       	brne	80002ed4 <phy_tx_func+0x484>
					{
						payload_tx_state = 1;
80002ec4:	10 99       	mov	r9,r8
80002ec6:	fe f8 02 e2 	ld.w	r8,pc[738]
80002eca:	b0 89       	st.b	r8[0x0],r9
	
						frame_number = 0;
80002ecc:	30 09       	mov	r9,0
80002ece:	fe f8 02 de 	ld.w	r8,pc[734]
80002ed2:	b0 89       	st.b	r8[0x0],r9
						//logFromISR("\n\r payload_tx_state: %d \n\r", payload_tx_state);
					}
					
					send_num++;
80002ed4:	fe f8 02 dc 	ld.w	r8,pc[732]
80002ed8:	70 09       	ld.w	r9,r8[0x0]
80002eda:	2f f9       	sub	r9,-1
80002edc:	91 09       	st.w	r8[0x0],r9
80002ede:	c3 59       	rjmp	80003148 <phy_tx_func+0x6f8>
				break;
			
			case 1:
				
				//logFromISR("\n\r counter: %d \n\r", counter);
				payload_tx_channel->word[0] = 0xABCD; //254 bytes;
80002ee0:	fe 78 ab cd 	mov	r8,-21555
80002ee4:	ae 48       	st.h	r7[0x8],r8
	
				if(frame_number == 0)
80002ee6:	fe f8 02 c6 	ld.w	r8,pc[710]
80002eea:	11 88       	ld.ub	r8,r8[0x0]
80002eec:	58 08       	cp.w	r8,0
80002eee:	c0 e1       	brne	80002f0a <phy_tx_func+0x4ba>
				{
					//first frame
					expexted_length = 0xFE;
80002ef0:	e0 69 00 fe 	mov	r9,254
80002ef4:	fe f8 02 c0 	ld.w	r8,pc[704]
80002ef8:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x21FE;//0x11FE; //254 bytes;		mic_data?
80002efa:	e0 68 21 fe 	mov	r8,8702
80002efe:	ae 58       	st.h	r7[0xa],r8
					last_frame = FALSE;
80002f00:	30 09       	mov	r9,0
80002f02:	fe f8 02 b6 	ld.w	r8,pc[694]
80002f06:	b0 89       	st.b	r8[0x0],r9
80002f08:	c2 c8       	rjmp	80002f60 <phy_tx_func+0x510>
				}
				else if(frame_number + 1 >= 2) //2frame
80002f0a:	2f f8       	sub	r8,-1
80002f0c:	58 18       	cp.w	r8,1
80002f0e:	e0 8a 00 1d 	brle	80002f48 <phy_tx_func+0x4f8>
						//expexted_length = 0x46;//经测试发现，要获取正确的语音的（按320bytes/20ms纯语音码流），并且每一个样本都添加了一个Stream Terminator Indicator的话，那么总长度-描述符相关的字段=320bytes
							//payload_tx_channel->word[1] = 0x1346;
						//send_num = 0;//满320bytes则重新计数
					//}
					//else{
					if (Silent_flag == 1)
80002f12:	fe f8 02 aa 	ld.w	r8,pc[682]
80002f16:	11 89       	ld.ub	r9,r8[0x0]
80002f18:	30 18       	mov	r8,1
80002f1a:	f0 09 18 00 	cp.b	r9,r8
80002f1e:	c0 91       	brne	80002f30 <phy_tx_func+0x4e0>
					{
						//即是(254+70)324betes-4bytes= 320bytes
						expexted_length = 0x46;//One Descriptor Indicator
80002f20:	34 69       	mov	r9,70
80002f22:	fe f8 02 92 	ld.w	r8,pc[658]
80002f26:	b0 09       	st.h	r8[0x0],r9
						payload_tx_channel->word[1] = 0x2346;//70bytes
80002f28:	e0 68 23 46 	mov	r8,9030
80002f2c:	ae 58       	st.h	r7[0xa],r8
80002f2e:	c0 88       	rjmp	80002f3e <phy_tx_func+0x4ee>
					}
		
					else
					{
						///即是(254+68)322betes-2bytes(no Descriptor Indicator)= 320bytes
						expexted_length = 0x44;//no Descriptor Indicator
80002f30:	34 49       	mov	r9,68
80002f32:	fe f8 02 82 	ld.w	r8,pc[642]
80002f36:	b0 09       	st.h	r8[0x0],r9
						payload_tx_channel->word[1] = 0x2344;//0x1344;//0x2344;// 0x1344; //68bytes
80002f38:	e0 68 23 44 	mov	r8,9028
80002f3c:	ae 58       	st.h	r7[0xa],r8
					}
					//}
		
					last_frame = TRUE;
80002f3e:	30 19       	mov	r9,1
80002f40:	fe f8 02 78 	ld.w	r8,pc[632]
80002f44:	b0 89       	st.b	r8[0x0],r9
80002f46:	c0 d8       	rjmp	80002f60 <phy_tx_func+0x510>
					//logFromISR("\n\r time: %d \n\r", tc_tick);
				}
				else
				{
					//middle frame
					expexted_length = 0xFE;
80002f48:	e0 69 00 fe 	mov	r9,254
80002f4c:	fe f8 02 68 	ld.w	r8,pc[616]
80002f50:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x22FE;//0x22FE;//0x12FE;
80002f52:	e0 68 22 fe 	mov	r8,8958
80002f56:	ae 58       	st.h	r7[0xa],r8
					last_frame = FALSE;
80002f58:	30 09       	mov	r9,0
80002f5a:	fe f8 02 5e 	ld.w	r8,pc[606]
80002f5e:	b0 89       	st.b	r8[0x0],r9
				//
				//}
				//else//不执行
				{
		
					if (Silent_flag == 1)//发送静音指令
80002f60:	fe f8 02 5c 	ld.w	r8,pc[604]
80002f64:	11 89       	ld.ub	r9,r8[0x0]
80002f66:	30 18       	mov	r8,1
80002f68:	f0 09 18 00 	cp.b	r9,r8
80002f6c:	c0 61       	brne	80002f78 <phy_tx_func+0x528>
					{
					
						payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
80002f6e:	30 18       	mov	r8,1
80002f70:	ae 68       	st.h	r7[0xc],r8
						payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
80002f72:	30 48       	mov	r8,4
80002f74:	ae 78       	st.h	r7[0xe],r8
80002f76:	c1 48       	rjmp	80002f9e <phy_tx_func+0x54e>
					
			
					}
					else
					{
						payload_tx_channel->word[2] = 0x0000;
80002f78:	30 08       	mov	r8,0
80002f7a:	ae 68       	st.h	r7[0xc],r8
						payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002f7c:	fe f8 02 1c 	ld.w	r8,pc[540]
80002f80:	70 09       	ld.w	r9,r8[0x0]
80002f82:	fe fa 02 3e 	ld.w	r10,pc[574]
80002f86:	f4 09 00 0b 	add	r11,r10,r9
80002f8a:	17 9b       	ld.ub	r11,r11[0x1]
80002f8c:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002f90:	a9 69       	lsl	r9,0x8
80002f92:	f6 09 00 09 	add	r9,r11,r9
80002f96:	ae 79       	st.h	r7[0xe],r9
						index+=2;
80002f98:	70 09       	ld.w	r9,r8[0x0]
80002f9a:	2f e9       	sub	r9,-2
80002f9c:	91 09       	st.w	r8[0x0],r9
						
					}
					
					expexted_length -= 4;
80002f9e:	fe f8 02 16 	ld.w	r8,pc[534]
80002fa2:	90 09       	ld.sh	r9,r8[0x0]
80002fa4:	20 49       	sub	r9,4
80002fa6:	b0 09       	st.h	r8[0x0],r9
				}
	
				//index+=2;
				//expexted_length -= 4;
		
				frame_number++;
80002fa8:	fe f8 02 04 	ld.w	r8,pc[516]
80002fac:	11 89       	ld.ub	r9,r8[0x0]
80002fae:	2f f9       	sub	r9,-1
80002fb0:	b0 89       	st.b	r8[0x0],r9
				payload_tx_state = 2;
80002fb2:	30 29       	mov	r9,2
80002fb4:	4f d8       	lddpc	r8,800031a8 <phy_tx_func+0x758>
80002fb6:	b0 89       	st.b	r8[0x0],r9
	
				i = 0;
80002fb8:	30 09       	mov	r9,0
80002fba:	fe f8 02 0a 	ld.w	r8,pc[522]
80002fbe:	91 09       	st.w	r8[0x0],r9
80002fc0:	cc 48       	rjmp	80003148 <phy_tx_func+0x6f8>
	
				break;
			
			case 2:
		
				if(expexted_length <= 0)
80002fc2:	4f d8       	lddpc	r8,800031b4 <phy_tx_func+0x764>
80002fc4:	90 09       	ld.sh	r9,r8[0x0]
80002fc6:	30 08       	mov	r8,0
80002fc8:	f0 09 19 00 	cp.h	r9,r8
80002fcc:	e0 89 00 12 	brgt	80002ff0 <phy_tx_func+0x5a0>
				{
					//last word 0x00BA
					payload_tx_state = last_frame ? 0 : 1;
80002fd0:	4f a8       	lddpc	r8,800031b8 <phy_tx_func+0x768>
80002fd2:	11 89       	ld.ub	r9,r8[0x0]
80002fd4:	30 08       	mov	r8,0
80002fd6:	f0 09 18 00 	cp.b	r9,r8
80002fda:	5f 09       	sreq	r9
80002fdc:	4f 38       	lddpc	r8,800031a8 <phy_tx_func+0x758>
80002fde:	b0 89       	st.b	r8[0x0],r9
					payload_tx_channel->word[0] = 0x00BA;
80002fe0:	e0 68 00 ba 	mov	r8,186
80002fe4:	ae 48       	st.h	r7[0x8],r8
					payload_tx_channel->word[1] = 0x0000;
80002fe6:	30 08       	mov	r8,0
80002fe8:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2] = 0x0000;
80002fea:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3] = 0x0000;
80002fec:	ae 78       	st.h	r7[0xe],r8
80002fee:	ca d8       	rjmp	80003148 <phy_tx_func+0x6f8>
					break;
				}
	
				if(Silent_flag == 1)
80002ff0:	4f 38       	lddpc	r8,800031bc <phy_tx_func+0x76c>
80002ff2:	11 89       	ld.ub	r9,r8[0x0]
80002ff4:	30 18       	mov	r8,1
80002ff6:	f0 09 18 00 	cp.b	r9,r8
80002ffa:	c0 41       	brne	80003002 <phy_tx_func+0x5b2>
				{
					payload_tx_channel->word[0] =  0x0000;
80002ffc:	30 08       	mov	r8,0
80002ffe:	ae 48       	st.h	r7[0x8],r8
80003000:	c1 08       	rjmp	80003020 <phy_tx_func+0x5d0>
				}
				else
				{
					//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
					payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003002:	4e 68       	lddpc	r8,80003198 <phy_tx_func+0x748>
80003004:	70 09       	ld.w	r9,r8[0x0]
80003006:	4e fa       	lddpc	r10,800031c0 <phy_tx_func+0x770>
80003008:	f4 09 00 0b 	add	r11,r10,r9
8000300c:	17 9b       	ld.ub	r11,r11[0x1]
8000300e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003012:	a9 69       	lsl	r9,0x8
80003014:	f6 09 00 09 	add	r9,r11,r9
80003018:	ae 49       	st.h	r7[0x8],r9
					index+=2;
8000301a:	70 09       	ld.w	r9,r8[0x0]
8000301c:	2f e9       	sub	r9,-2
8000301e:	91 09       	st.w	r8[0x0],r9
		
				}

				expexted_length -= 2;
80003020:	4e 59       	lddpc	r9,800031b4 <phy_tx_func+0x764>
80003022:	92 08       	ld.sh	r8,r9[0x0]
80003024:	20 28       	sub	r8,2
80003026:	b2 08       	st.h	r9[0x0],r8
				if(expexted_length <= 0)
80003028:	30 09       	mov	r9,0
8000302a:	f2 08 19 00 	cp.h	r8,r9
8000302e:	e0 89 00 11 	brgt	80003050 <phy_tx_func+0x600>
				{
					//last word 0x00BA
					payload_tx_state = last_frame ? 0 : 1;
80003032:	4e 28       	lddpc	r8,800031b8 <phy_tx_func+0x768>
80003034:	11 89       	ld.ub	r9,r8[0x0]
80003036:	30 08       	mov	r8,0
80003038:	f0 09 18 00 	cp.b	r9,r8
8000303c:	5f 09       	sreq	r9
8000303e:	4d b8       	lddpc	r8,800031a8 <phy_tx_func+0x758>
80003040:	b0 89       	st.b	r8[0x0],r9
					payload_tx_channel->word[1] = 0x00BA;
80003042:	e0 68 00 ba 	mov	r8,186
80003046:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2] = 0x0000;
80003048:	30 08       	mov	r8,0
8000304a:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3] = 0x0000;
8000304c:	ae 78       	st.h	r7[0xe],r8
8000304e:	c7 d8       	rjmp	80003148 <phy_tx_func+0x6f8>
					break;
				}
	
				if(Silent_flag == 1)
80003050:	4d b8       	lddpc	r8,800031bc <phy_tx_func+0x76c>
80003052:	11 89       	ld.ub	r9,r8[0x0]
80003054:	30 18       	mov	r8,1
80003056:	f0 09 18 00 	cp.b	r9,r8
8000305a:	c0 41       	brne	80003062 <phy_tx_func+0x612>
				{
					payload_tx_channel->word[1] =  0x0000;
8000305c:	30 08       	mov	r8,0
8000305e:	ae 58       	st.h	r7[0xa],r8
80003060:	c1 08       	rjmp	80003080 <phy_tx_func+0x630>
				}	
				else
				{
		
					payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80003062:	4c e8       	lddpc	r8,80003198 <phy_tx_func+0x748>
80003064:	70 09       	ld.w	r9,r8[0x0]
80003066:	4d 7a       	lddpc	r10,800031c0 <phy_tx_func+0x770>
80003068:	f4 09 00 0b 	add	r11,r10,r9
8000306c:	17 9b       	ld.ub	r11,r11[0x1]
8000306e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80003072:	a9 69       	lsl	r9,0x8
80003074:	f6 09 00 09 	add	r9,r11,r9
80003078:	ae 59       	st.h	r7[0xa],r9
					index+=2;
8000307a:	70 09       	ld.w	r9,r8[0x0]
8000307c:	2f e9       	sub	r9,-2
8000307e:	91 09       	st.w	r8[0x0],r9
				}
				//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
	
				expexted_length -= 2;
80003080:	4c d9       	lddpc	r9,800031b4 <phy_tx_func+0x764>
80003082:	92 08       	ld.sh	r8,r9[0x0]
80003084:	20 28       	sub	r8,2
80003086:	b2 08       	st.h	r9[0x0],r8
				if(expexted_length <= 0)
80003088:	30 09       	mov	r9,0
8000308a:	f2 08 19 00 	cp.h	r8,r9
8000308e:	e0 89 00 10 	brgt	800030ae <phy_tx_func+0x65e>
				{
					//last word 0x00BA
					payload_tx_state = last_frame ? 0 : 1;
80003092:	4c a8       	lddpc	r8,800031b8 <phy_tx_func+0x768>
80003094:	11 89       	ld.ub	r9,r8[0x0]
80003096:	30 08       	mov	r8,0
80003098:	f0 09 18 00 	cp.b	r9,r8
8000309c:	5f 09       	sreq	r9
8000309e:	4c 38       	lddpc	r8,800031a8 <phy_tx_func+0x758>
800030a0:	b0 89       	st.b	r8[0x0],r9
					payload_tx_channel->word[2] = 0x00BA;
800030a2:	e0 68 00 ba 	mov	r8,186
800030a6:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3] = 0x0000;
800030a8:	30 08       	mov	r8,0
800030aa:	ae 78       	st.h	r7[0xe],r8
800030ac:	c4 e8       	rjmp	80003148 <phy_tx_func+0x6f8>
					break;
				}
	
				if(Silent_flag == 1)
800030ae:	4c 48       	lddpc	r8,800031bc <phy_tx_func+0x76c>
800030b0:	11 89       	ld.ub	r9,r8[0x0]
800030b2:	30 18       	mov	r8,1
800030b4:	f0 09 18 00 	cp.b	r9,r8
800030b8:	c0 41       	brne	800030c0 <phy_tx_func+0x670>
				{
					payload_tx_channel->word[2] =  0x0000;
800030ba:	30 08       	mov	r8,0
800030bc:	ae 68       	st.h	r7[0xc],r8
800030be:	c1 08       	rjmp	800030de <phy_tx_func+0x68e>
				}
				else
				{
		
					payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800030c0:	4b 68       	lddpc	r8,80003198 <phy_tx_func+0x748>
800030c2:	70 09       	ld.w	r9,r8[0x0]
800030c4:	4b fa       	lddpc	r10,800031c0 <phy_tx_func+0x770>
800030c6:	f4 09 00 0b 	add	r11,r10,r9
800030ca:	17 9b       	ld.ub	r11,r11[0x1]
800030cc:	f4 09 07 09 	ld.ub	r9,r10[r9]
800030d0:	a9 69       	lsl	r9,0x8
800030d2:	f6 09 00 09 	add	r9,r11,r9
800030d6:	ae 69       	st.h	r7[0xc],r9
					index+=2;
800030d8:	70 09       	ld.w	r9,r8[0x0]
800030da:	2f e9       	sub	r9,-2
800030dc:	91 09       	st.w	r8[0x0],r9
				}
				//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
	
				expexted_length -= 2;
800030de:	4b 69       	lddpc	r9,800031b4 <phy_tx_func+0x764>
800030e0:	92 08       	ld.sh	r8,r9[0x0]
800030e2:	20 28       	sub	r8,2
800030e4:	b2 08       	st.h	r9[0x0],r8
				if(expexted_length <= 0)
800030e6:	30 09       	mov	r9,0
800030e8:	f2 08 19 00 	cp.h	r8,r9
800030ec:	e0 89 00 0e 	brgt	80003108 <phy_tx_func+0x6b8>
				{
					//last word 0x00BA
					payload_tx_state = last_frame ? 0 : 1;
800030f0:	4b 28       	lddpc	r8,800031b8 <phy_tx_func+0x768>
800030f2:	11 89       	ld.ub	r9,r8[0x0]
800030f4:	30 08       	mov	r8,0
800030f6:	f0 09 18 00 	cp.b	r9,r8
800030fa:	5f 09       	sreq	r9
800030fc:	4a b8       	lddpc	r8,800031a8 <phy_tx_func+0x758>
800030fe:	b0 89       	st.b	r8[0x0],r9
					payload_tx_channel->word[3] = 0x00BA;
80003100:	e0 68 00 ba 	mov	r8,186
80003104:	ae 78       	st.h	r7[0xe],r8
80003106:	c2 18       	rjmp	80003148 <phy_tx_func+0x6f8>
					break;
				}
	
				if(Silent_flag == 1)
80003108:	4a d8       	lddpc	r8,800031bc <phy_tx_func+0x76c>
8000310a:	11 89       	ld.ub	r9,r8[0x0]
8000310c:	30 18       	mov	r8,1
8000310e:	f0 09 18 00 	cp.b	r9,r8
80003112:	c0 41       	brne	8000311a <phy_tx_func+0x6ca>
				{
					payload_tx_channel->word[3] =  0x0000;
80003114:	30 08       	mov	r8,0
80003116:	ae 78       	st.h	r7[0xe],r8
80003118:	c1 08       	rjmp	80003138 <phy_tx_func+0x6e8>
				}
				else
				{
		
					payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000311a:	4a 08       	lddpc	r8,80003198 <phy_tx_func+0x748>
8000311c:	70 09       	ld.w	r9,r8[0x0]
8000311e:	4a 9a       	lddpc	r10,800031c0 <phy_tx_func+0x770>
80003120:	f4 09 00 0b 	add	r11,r10,r9
80003124:	17 9b       	ld.ub	r11,r11[0x1]
80003126:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000312a:	a9 69       	lsl	r9,0x8
8000312c:	f6 09 00 09 	add	r9,r11,r9
80003130:	ae 79       	st.h	r7[0xe],r9
					index+=2;
80003132:	70 09       	ld.w	r9,r8[0x0]
80003134:	2f e9       	sub	r9,-2
80003136:	91 09       	st.w	r8[0x0],r9
				}
	
				//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
	
				expexted_length -= 2;
80003138:	49 f8       	lddpc	r8,800031b4 <phy_tx_func+0x764>
8000313a:	90 09       	ld.sh	r9,r8[0x0]
8000313c:	20 29       	sub	r9,2
8000313e:	b0 09       	st.h	r8[0x0],r9
80003140:	c0 48       	rjmp	80003148 <phy_tx_func+0x6f8>
		
				break;
		
			default:
				payload_tx_state = 0;
80003142:	30 09       	mov	r9,0
80003144:	49 98       	lddpc	r8,800031a8 <phy_tx_func+0x758>
80003146:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80003148:	2f fd       	sub	sp,-4
8000314a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000314e:	00 00       	add	r0,r0
80003150:	00 00       	add	r0,r0
80003152:	0a ec       	st.h	--r5,r12
80003154:	00 00       	add	r0,r0
80003156:	0a ac       	st.w	r5++,r12
80003158:	00 00       	add	r0,r0
8000315a:	0a 78       	tst	r8,r5
8000315c:	80 00       	ld.sh	r0,r0[0x0]
8000315e:	57 b8       	stdsp	sp[0x1ec],r8
80003160:	00 00       	add	r0,r0
80003162:	0a e0       	st.h	--r5,r0
80003164:	00 00       	add	r0,r0
80003166:	0a 8c       	andn	r12,r5
80003168:	00 00       	add	r0,r0
8000316a:	0a 4c       	or	r12,r5
8000316c:	00 00       	add	r0,r0
8000316e:	0a 38       	cp.w	r8,r5
80003170:	00 00       	add	r0,r0
80003172:	0a cc       	st.b	r5++,r12
80003174:	00 00       	add	r0,r0
80003176:	0a a8       	st.w	r5++,r8
80003178:	00 00       	add	r0,r0
8000317a:	0a 68       	and	r8,r5
8000317c:	00 00       	add	r0,r0
8000317e:	0a 90       	mov	r0,r5
80003180:	00 00       	add	r0,r0
80003182:	0d d4       	ld.ub	r4,r6[0x5]
80003184:	00 00       	add	r0,r0
80003186:	0e d0       	st.w	--r7,r0
80003188:	80 00       	ld.sh	r0,r0[0x0]
8000318a:	cf 80       	breq	8000317a <phy_tx_func+0x72a>
8000318c:	00 00       	add	r0,r0
8000318e:	0a 39       	cp.w	r9,r5
80003190:	00 00       	add	r0,r0
80003192:	0d cc       	ld.ub	r12,r6[0x4]
80003194:	00 00       	add	r0,r0
80003196:	0d d8       	ld.ub	r8,r6[0x5]
80003198:	00 00       	add	r0,r0
8000319a:	0a a4       	st.w	r5++,r4
8000319c:	00 00       	add	r0,r0
8000319e:	0a 3c       	cp.w	r12,r5
800031a0:	00 00       	add	r0,r0
800031a2:	0a 3b       	cp.w	r11,r5
800031a4:	00 00       	add	r0,r0
800031a6:	0a 6c       	and	r12,r5
800031a8:	00 00       	add	r0,r0
800031aa:	0a d8       	st.w	--r5,r8
800031ac:	00 00       	add	r0,r0
800031ae:	0a c8       	st.b	r5++,r8
800031b0:	00 00       	add	r0,r0
800031b2:	0a 80       	andn	r0,r5
800031b4:	00 00       	add	r0,r0
800031b6:	0a e8       	st.h	--r5,r8
800031b8:	00 00       	add	r0,r0
800031ba:	0a 8d       	andn	sp,r5
800031bc:	00 00       	add	r0,r0
800031be:	0a 4e       	or	lr,r5
800031c0:	80 00       	ld.sh	r0,r0[0x0]
800031c2:	d5 3c       	*unknown*
800031c4:	00 00       	add	r0,r0
800031c6:	0a 74       	tst	r4,r5

800031c8 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800031c8:	d4 01       	pushm	lr
800031ca:	20 1d       	sub	sp,4
	void * ptr = NULL;
800031cc:	30 0a       	mov	r10,0
800031ce:	fa cb ff fc 	sub	r11,sp,-4
800031d2:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800031d4:	14 99       	mov	r9,r10
800031d6:	1a 9b       	mov	r11,sp
800031d8:	f0 1f 00 05 	mcall	800031ec <get_idle_store+0x24>
800031dc:	58 1c       	cp.w	r12,1
800031de:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800031e2:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800031e6:	2f fd       	sub	sp,-4
800031e8:	d8 02       	popm	pc
800031ea:	00 00       	add	r0,r0
800031ec:	80 00       	ld.sh	r0,r0[0x0]
800031ee:	58 a8       	cp.w	r8,10

800031f0 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800031f0:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
800031f4:	f0 1f 00 21 	mcall	80003278 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800031f8:	4a 1b       	lddpc	r11,8000327c <phy_init+0x8c>
800031fa:	4a 2c       	lddpc	r12,80003280 <phy_init+0x90>
800031fc:	f0 1f 00 22 	mcall	80003284 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80003200:	30 4b       	mov	r11,4
80003202:	31 ec       	mov	r12,30
80003204:	f0 1f 00 21 	mcall	80003288 <phy_init+0x98>
80003208:	4a 18       	lddpc	r8,8000328c <phy_init+0x9c>
8000320a:	91 0c       	st.w	r8[0x0],r12
8000320c:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
8000320e:	10 96       	mov	r6,r8
80003210:	4a 05       	lddpc	r5,80003290 <phy_init+0xa0>
80003212:	6c 0c       	ld.w	r12,r6[0x0]
80003214:	ea 07 00 0b 	add	r11,r5,r7
80003218:	f0 1f 00 1f 	mcall	80003294 <phy_init+0xa4>
8000321c:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80003220:	e0 47 1e 00 	cp.w	r7,7680
80003224:	cf 71       	brne	80003212 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003226:	30 4b       	mov	r11,4
80003228:	31 4c       	mov	r12,20
8000322a:	f0 1f 00 18 	mcall	80003288 <phy_init+0x98>
8000322e:	49 b8       	lddpc	r8,80003298 <phy_init+0xa8>
80003230:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003232:	30 4b       	mov	r11,4
80003234:	30 ac       	mov	r12,10
80003236:	f0 1f 00 15 	mcall	80003288 <phy_init+0x98>
8000323a:	49 98       	lddpc	r8,8000329c <phy_init+0xac>
8000323c:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
8000323e:	30 4b       	mov	r11,4
80003240:	30 ac       	mov	r12,10
80003242:	f0 1f 00 12 	mcall	80003288 <phy_init+0x98>
80003246:	49 78       	lddpc	r8,800032a0 <phy_init+0xb0>
80003248:	91 0c       	st.w	r8[0x0],r12
8000324a:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000324c:	10 96       	mov	r6,r8
8000324e:	49 65       	lddpc	r5,800032a4 <phy_init+0xb4>
80003250:	6c 0c       	ld.w	r12,r6[0x0]
80003252:	ea 07 00 0b 	add	r11,r5,r7
80003256:	f0 1f 00 10 	mcall	80003294 <phy_init+0xa4>
8000325a:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000325e:	e0 47 14 00 	cp.w	r7,5120
80003262:	cf 71       	brne	80003250 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80003264:	e0 6b 01 00 	mov	r11,256
80003268:	30 5c       	mov	r12,5
8000326a:	f0 1f 00 08 	mcall	80003288 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
8000326e:	48 f8       	lddpc	r8,800032a8 <phy_init+0xb8>
80003270:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80003272:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003276:	00 00       	add	r0,r0
80003278:	80 00       	ld.sh	r0,r0[0x0]
8000327a:	42 d4       	lddsp	r4,sp[0xb4]
8000327c:	80 00       	ld.sh	r0,r0[0x0]
8000327e:	2a 50       	sub	r0,-91
80003280:	80 00       	ld.sh	r0,r0[0x0]
80003282:	33 0c       	mov	r12,48
80003284:	80 00       	ld.sh	r0,r0[0x0]
80003286:	42 c0       	lddsp	r0,sp[0xb0]
80003288:	80 00       	ld.sh	r0,r0[0x0]
8000328a:	5c 0c       	acr	r12
8000328c:	00 00       	add	r0,r0
8000328e:	0a 98       	mov	r8,r5
80003290:	00 00       	add	r0,r0
80003292:	22 d4       	sub	r4,45
80003294:	80 00       	ld.sh	r0,r0[0x0]
80003296:	29 ac       	sub	r12,-102
80003298:	00 00       	add	r0,r0
8000329a:	0a ec       	st.h	--r5,r12
8000329c:	00 00       	add	r0,r0
8000329e:	0a d4       	st.w	--r5,r4
800032a0:	00 00       	add	r0,r0
800032a2:	0a 70       	tst	r0,r5
800032a4:	00 00       	add	r0,r0
800032a6:	0e d4       	st.w	--r7,r4
800032a8:	00 00       	add	r0,r0
800032aa:	0a b8       	st.h	r5++,r8

800032ac <payload_rx>:




static void payload_rx(void * payload)
{
800032ac:	d4 01       	pushm	lr
800032ae:	20 2d       	sub	sp,8
800032b0:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800032b2:	30 08       	mov	r8,0
800032b4:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
800032b6:	48 f8       	lddpc	r8,800032f0 <payload_rx+0x44>
800032b8:	70 08       	ld.w	r8,r8[0x0]
800032ba:	58 08       	cp.w	r8,0
800032bc:	c0 71       	brne	800032ca <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
800032be:	30 4b       	mov	r11,4
800032c0:	30 5c       	mov	r12,5
800032c2:	f0 1f 00 0d 	mcall	800032f4 <payload_rx+0x48>
800032c6:	48 b8       	lddpc	r8,800032f0 <payload_rx+0x44>
800032c8:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
800032ca:	48 a8       	lddpc	r8,800032f0 <payload_rx+0x44>
800032cc:	70 0c       	ld.w	r12,r8[0x0]
800032ce:	30 09       	mov	r9,0
800032d0:	fa ca ff fc 	sub	r10,sp,-4
800032d4:	1a 9b       	mov	r11,sp
800032d6:	f0 1f 00 09 	mcall	800032f8 <payload_rx+0x4c>
800032da:	c0 91       	brne	800032ec <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
800032dc:	48 88       	lddpc	r8,800032fc <payload_rx+0x50>
800032de:	70 0c       	ld.w	r12,r8[0x0]
800032e0:	40 0b       	lddsp	r11,sp[0x0]
800032e2:	f0 1f 00 08 	mcall	80003300 <payload_rx+0x54>
		logFromISR("mm");
800032e6:	48 8c       	lddpc	r12,80003304 <payload_rx+0x58>
800032e8:	f0 1f 00 08 	mcall	80003308 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
800032ec:	2f ed       	sub	sp,-8
800032ee:	d8 02       	popm	pc
800032f0:	00 00       	add	r0,r0
800032f2:	0a f4       	st.b	--r5,r4
800032f4:	80 00       	ld.sh	r0,r0[0x0]
800032f6:	5c 0c       	acr	r12
800032f8:	80 00       	ld.sh	r0,r0[0x0]
800032fa:	5a 64       	cp.w	r4,-26
800032fc:	00 00       	add	r0,r0
800032fe:	0a 70       	tst	r0,r5
80003300:	80 00       	ld.sh	r0,r0[0x0]
80003302:	29 58       	sub	r8,-107
80003304:	80 01       	ld.sh	r1,r0[0x0]
80003306:	58 ec       	cp.w	r12,14
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	68 30       	ld.w	r0,r4[0xc]

8000330c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
8000330c:	eb cd 40 e0 	pushm	r5-r7,lr
80003310:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003312:	fe f8 0d ee 	ld.w	r8,pc[3566]
80003316:	70 08       	ld.w	r8,r8[0x0]
80003318:	58 08       	cp.w	r8,0
8000331a:	e0 80 01 05 	breq	80003524 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000331e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003320:	fe f8 0d e4 	ld.w	r8,pc[3556]
80003324:	70 09       	ld.w	r9,r8[0x0]
80003326:	2f f9       	sub	r9,-1
80003328:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000332a:	fe f8 0d de 	ld.w	r8,pc[3550]
8000332e:	70 08       	ld.w	r8,r8[0x0]
80003330:	58 18       	cp.w	r8,1
80003332:	e0 80 00 84 	breq	8000343a <phy_rx_func+0x12e>
80003336:	c0 73       	brcs	80003344 <phy_rx_func+0x38>
80003338:	58 28       	cp.w	r8,2
8000333a:	c5 b0       	breq	800033f0 <phy_rx_func+0xe4>
8000333c:	58 38       	cp.w	r8,3
8000333e:	e0 81 00 f3 	brne	80003524 <phy_rx_func+0x218>
80003342:	cd 38       	rjmp	800034e8 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003344:	e0 6a 5a 5a 	mov	r10,23130
80003348:	ea 1a ab cd 	orh	r10,0xabcd
8000334c:	14 36       	cp.w	r6,r10
8000334e:	e0 80 00 eb 	breq	80003524 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80003352:	ec 08 16 10 	lsr	r8,r6,0x10
80003356:	e0 48 ab cd 	cp.w	r8,43981
8000335a:	e0 81 00 e5 	brne	80003524 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000335e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80003362:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80003366:	20 28       	sub	r8,2
80003368:	fe f9 0d a4 	ld.w	r9,pc[3492]
8000336c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000336e:	30 09       	mov	r9,0
80003370:	f2 08 19 00 	cp.h	r8,r9
80003374:	e0 8a 00 d8 	brle	80003524 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80003378:	fe f8 0d 98 	ld.w	r8,pc[3480]
8000337c:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
8000337e:	fe f8 0d 96 	ld.w	r8,pc[3478]
80003382:	70 0c       	ld.w	r12,r8[0x0]
80003384:	f0 1f 03 65 	mcall	80004118 <phy_rx_func+0xe0c>
80003388:	fe f8 0d 94 	ld.w	r8,pc[3476]
8000338c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000338e:	58 0c       	cp.w	r12,0
80003390:	e0 80 00 ca 	breq	80003524 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003394:	fe f8 0d 7c 	ld.w	r8,pc[3452]
80003398:	90 09       	ld.sh	r9,r8[0x0]
8000339a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
8000339e:	2f f9       	sub	r9,-1
800033a0:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800033a2:	fe fa 0d 7a 	ld.w	r10,pc[3450]
800033a6:	74 0a       	ld.w	r10,r10[0x0]
800033a8:	fe fb 0d 5c 	ld.w	r11,pc[3420]
800033ac:	76 0b       	ld.w	r11,r11[0x0]
800033ae:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800033b2:	2f f9       	sub	r9,-1
800033b4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800033b6:	e2 16 0f 00 	andl	r6,0xf00,COH
800033ba:	e0 46 01 00 	cp.w	r6,256
800033be:	c0 c0       	breq	800033d6 <phy_rx_func+0xca>
800033c0:	e0 8b 00 05 	brhi	800033ca <phy_rx_func+0xbe>
800033c4:	58 06       	cp.w	r6,0
800033c6:	c0 80       	breq	800033d6 <phy_rx_func+0xca>
800033c8:	c0 c8       	rjmp	800033e0 <phy_rx_func+0xd4>
800033ca:	e0 46 02 00 	cp.w	r6,512
800033ce:	c0 40       	breq	800033d6 <phy_rx_func+0xca>
800033d0:	e0 46 03 00 	cp.w	r6,768
800033d4:	c0 61       	brne	800033e0 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800033d6:	30 29       	mov	r9,2
800033d8:	fe f8 0d 30 	ld.w	r8,pc[3376]
800033dc:	91 09       	st.w	r8[0x0],r9
800033de:	ca 38       	rjmp	80003524 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
800033e0:	fe f6 0d 3c 	ld.w	r6,pc[3388]
800033e4:	6c 0c       	ld.w	r12,r6[0x0]
800033e6:	f0 1f 03 4f 	mcall	80004120 <phy_rx_func+0xe14>
					phy_frame_ptr = NULL;					
800033ea:	30 08       	mov	r8,0
800033ec:	8d 08       	st.w	r6[0x0],r8
800033ee:	c9 b8       	rjmp	80003524 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800033f0:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800033f4:	b1 86       	lsr	r6,0x10
800033f6:	14 06       	add	r6,r10
800033f8:	fe f8 0d 2c 	ld.w	r8,pc[3372]
800033fc:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800033fe:	fe f8 0d 12 	ld.w	r8,pc[3346]
80003402:	90 09       	ld.sh	r9,r8[0x0]
80003404:	fe fb 0d 18 	ld.w	r11,pc[3352]
80003408:	76 0b       	ld.w	r11,r11[0x0]
8000340a:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000340e:	2f f9       	sub	r9,-1
80003410:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003412:	fe f9 0c fa 	ld.w	r9,pc[3322]
80003416:	92 08       	ld.sh	r8,r9[0x0]
80003418:	20 28       	sub	r8,2
8000341a:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000341c:	30 09       	mov	r9,0
8000341e:	f2 08 19 00 	cp.h	r8,r9
80003422:	e0 8a 00 07 	brle	80003430 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003426:	30 19       	mov	r9,1
80003428:	fe f8 0c e0 	ld.w	r8,pc[3296]
8000342c:	91 09       	st.w	r8[0x0],r9
8000342e:	c7 b8       	rjmp	80003524 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003430:	30 39       	mov	r9,3
80003432:	fe f8 0c d6 	ld.w	r8,pc[3286]
80003436:	91 09       	st.w	r8[0x0],r9
80003438:	c7 68       	rjmp	80003524 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000343a:	ec 0a 14 10 	asr	r10,r6,0x10
8000343e:	fe f8 0c e6 	ld.w	r8,pc[3302]
80003442:	90 09       	ld.sh	r9,r8[0x0]
80003444:	14 09       	add	r9,r10
80003446:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003448:	fe f9 0c c8 	ld.w	r9,pc[3272]
8000344c:	92 08       	ld.sh	r8,r9[0x0]
8000344e:	fe fb 0c ce 	ld.w	r11,pc[3278]
80003452:	76 0b       	ld.w	r11,r11[0x0]
80003454:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003458:	2f f8       	sub	r8,-1
8000345a:	5c 88       	casts.h	r8
8000345c:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
8000345e:	fe fa 0c ae 	ld.w	r10,pc[3246]
80003462:	94 09       	ld.sh	r9,r10[0x0]
80003464:	20 29       	sub	r9,2
80003466:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003468:	30 0a       	mov	r10,0
8000346a:	f4 09 19 00 	cp.h	r9,r10
8000346e:	e0 89 00 1f 	brgt	800034ac <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80003472:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003476:	e0 46 00 ba 	cp.w	r6,186
8000347a:	c0 d1       	brne	80003494 <phy_rx_func+0x188>
8000347c:	fe f8 0c a8 	ld.w	r8,pc[3240]
80003480:	90 09       	ld.sh	r9,r8[0x0]
80003482:	f4 09 19 00 	cp.h	r9,r10
80003486:	c0 71       	brne	80003494 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003488:	fe f8 0c 94 	ld.w	r8,pc[3220]
8000348c:	70 0c       	ld.w	r12,r8[0x0]
8000348e:	f0 1f 03 27 	mcall	80004128 <phy_rx_func+0xe1c>
80003492:	c0 88       	rjmp	800034a2 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003494:	fe f6 0c 88 	ld.w	r6,pc[3208]
80003498:	6c 0c       	ld.w	r12,r6[0x0]
8000349a:	f0 1f 03 22 	mcall	80004120 <phy_rx_func+0xe14>
					phy_frame_ptr = NULL;
8000349e:	30 08       	mov	r8,0
800034a0:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
800034a2:	30 09       	mov	r9,0
800034a4:	fe f8 0c 64 	ld.w	r8,pc[3172]
800034a8:	91 09       	st.w	r8[0x0],r9
800034aa:	c3 d8       	rjmp	80003524 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800034ac:	5c 86       	casts.h	r6
800034ae:	fe f9 0c 76 	ld.w	r9,pc[3190]
800034b2:	92 0a       	ld.sh	r10,r9[0x0]
800034b4:	0c 0a       	add	r10,r6
800034b6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800034b8:	fe f9 0c 64 	ld.w	r9,pc[3172]
800034bc:	72 09       	ld.w	r9,r9[0x0]
800034be:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800034c2:	2f f8       	sub	r8,-1
800034c4:	fe f9 0c 4c 	ld.w	r9,pc[3148]
800034c8:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800034ca:	fe f9 0c 42 	ld.w	r9,pc[3138]
800034ce:	92 08       	ld.sh	r8,r9[0x0]
800034d0:	20 28       	sub	r8,2
800034d2:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800034d4:	30 09       	mov	r9,0
800034d6:	f2 08 19 00 	cp.h	r8,r9
800034da:	e0 89 00 25 	brgt	80003524 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800034de:	30 39       	mov	r9,3
800034e0:	fe f8 0c 28 	ld.w	r8,pc[3112]
800034e4:	91 09       	st.w	r8[0x0],r9
800034e6:	c1 f8       	rjmp	80003524 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800034e8:	e6 16 00 ff 	andh	r6,0xff,COH
800034ec:	fc 19 00 ba 	movh	r9,0xba
800034f0:	12 36       	cp.w	r6,r9
800034f2:	c0 e1       	brne	8000350e <phy_rx_func+0x202>
800034f4:	fe f8 0c 30 	ld.w	r8,pc[3120]
800034f8:	90 09       	ld.sh	r9,r8[0x0]
800034fa:	30 08       	mov	r8,0
800034fc:	f0 09 19 00 	cp.h	r9,r8
80003500:	c0 71       	brne	8000350e <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003502:	fe f8 0c 1a 	ld.w	r8,pc[3098]
80003506:	70 0c       	ld.w	r12,r8[0x0]
80003508:	f0 1f 03 08 	mcall	80004128 <phy_rx_func+0xe1c>
8000350c:	c0 88       	rjmp	8000351c <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
8000350e:	fe f6 0c 0e 	ld.w	r6,pc[3086]
80003512:	6c 0c       	ld.w	r12,r6[0x0]
80003514:	f0 1f 03 03 	mcall	80004120 <phy_rx_func+0xe14>
				phy_frame_ptr = NULL;
80003518:	30 08       	mov	r8,0
8000351a:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000351c:	30 09       	mov	r9,0
8000351e:	fe f8 0b ea 	ld.w	r8,pc[3050]
80003522:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80003524:	fe f8 0c 08 	ld.w	r8,pc[3080]
80003528:	11 89       	ld.ub	r9,r8[0x0]
8000352a:	30 08       	mov	r8,0
8000352c:	f0 09 18 00 	cp.b	r9,r8
80003530:	c1 31       	brne	80003556 <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
80003532:	fe f6 0b fe 	ld.w	r6,pc[3070]
80003536:	6c 0c       	ld.w	r12,r6[0x0]
80003538:	f0 1f 02 f8 	mcall	80004118 <phy_rx_func+0xe0c>
8000353c:	fe f8 0b f8 	ld.w	r8,pc[3064]
80003540:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003542:	6c 0c       	ld.w	r12,r6[0x0]
80003544:	f0 1f 02 f5 	mcall	80004118 <phy_rx_func+0xe0c>
80003548:	fe f8 0b f0 	ld.w	r8,pc[3056]
8000354c:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000354e:	30 19       	mov	r9,1
80003550:	fe f8 0b dc 	ld.w	r8,pc[3036]
80003554:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003556:	fe f8 0b e6 	ld.w	r8,pc[3046]
8000355a:	70 08       	ld.w	r8,r8[0x0]
8000355c:	58 28       	cp.w	r8,2
8000355e:	e0 80 01 af 	breq	800038bc <phy_rx_func+0x5b0>
80003562:	e0 8b 00 06 	brhi	8000356e <phy_rx_func+0x262>
80003566:	58 08       	cp.w	r8,0
80003568:	c0 b0       	breq	8000357e <phy_rx_func+0x272>
8000356a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000356e:	58 38       	cp.w	r8,3
80003570:	e0 80 05 82 	breq	80004074 <phy_rx_func+0xd68>
80003574:	58 48       	cp.w	r8,4
80003576:	e0 81 05 c3 	brne	800040fc <phy_rx_func+0xdf0>
8000357a:	e0 8f 02 62 	bral	80003a3e <phy_rx_func+0x732>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000357e:	6e 28       	ld.w	r8,r7[0x8]
80003580:	e0 6a 5a 5a 	mov	r10,23130
80003584:	ea 1a ab cd 	orh	r10,0xabcd
80003588:	14 38       	cp.w	r8,r10
8000358a:	c0 71       	brne	80003598 <phy_rx_func+0x28c>
			{
				m_RxBurstType = VOICE_WATING;
8000358c:	30 09       	mov	r9,0
8000358e:	fe f8 0b b2 	ld.w	r8,pc[2994]
80003592:	91 09       	st.w	r8[0x0],r9
80003594:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003598:	10 99       	mov	r9,r8
8000359a:	e0 19 00 00 	andl	r9,0x0
8000359e:	fc 1a ab cd 	movh	r10,0xabcd
800035a2:	14 39       	cp.w	r9,r10
800035a4:	e0 81 05 ac 	brne	800040fc <phy_rx_func+0xdf0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800035a8:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800035ac:	fe f9 0b 98 	ld.w	r9,pc[2968]
800035b0:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800035b2:	fe f8 0b 82 	ld.w	r8,pc[2946]
800035b6:	70 08       	ld.w	r8,r8[0x0]
800035b8:	58 08       	cp.w	r8,0
800035ba:	c0 60       	breq	800035c6 <phy_rx_func+0x2ba>
800035bc:	fe f8 0b 7c 	ld.w	r8,pc[2940]
800035c0:	70 08       	ld.w	r8,r8[0x0]
800035c2:	58 08       	cp.w	r8,0
800035c4:	c1 a1       	brne	800035f8 <phy_rx_func+0x2ec>
			{
				payload_ptr = get_payload_idle_isr();
800035c6:	fe f6 0b 6a 	ld.w	r6,pc[2922]
800035ca:	6c 0c       	ld.w	r12,r6[0x0]
800035cc:	f0 1f 02 d3 	mcall	80004118 <phy_rx_func+0xe0c>
800035d0:	fe f5 0b 64 	ld.w	r5,pc[2916]
800035d4:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
800035d6:	6c 0c       	ld.w	r12,r6[0x0]
800035d8:	f0 1f 02 d0 	mcall	80004118 <phy_rx_func+0xe0c>
800035dc:	fe f8 0b 5c 	ld.w	r8,pc[2908]
800035e0:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800035e2:	6a 08       	ld.w	r8,r5[0x0]
800035e4:	58 08       	cp.w	r8,0
800035e6:	c0 30       	breq	800035ec <phy_rx_func+0x2e0>
800035e8:	58 0c       	cp.w	r12,0
800035ea:	c0 71       	brne	800035f8 <phy_rx_func+0x2ec>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800035ec:	fe fc 0b 5c 	ld.w	r12,pc[2908]
800035f0:	f0 1f 02 d7 	mcall	8000414c <phy_rx_func+0xe40>
800035f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800035f8:	6e 28       	ld.w	r8,r7[0x8]
800035fa:	e2 18 f0 00 	andl	r8,0xf000,COH
800035fe:	e0 48 c0 00 	cp.w	r8,49152
80003602:	e0 81 00 c7 	brne	80003790 <phy_rx_func+0x484>
			{
											
				Item_ID = payload_rx_channel->byte[5];
80003606:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000360a:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000360e:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003610:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003614:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80003618:	fe f9 0b 3c 	ld.w	r9,pc[2876]
8000361c:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
8000361e:	11 88       	ld.ub	r8,r8[0x0]
80003620:	37 f9       	mov	r9,127
80003622:	f2 08 18 00 	cp.b	r8,r9
80003626:	c6 b0       	breq	800036fc <phy_rx_func+0x3f0>
80003628:	e0 8b 00 0c 	brhi	80003640 <phy_rx_func+0x334>
8000362c:	31 29       	mov	r9,18
8000362e:	f2 08 18 00 	cp.b	r8,r9
80003632:	c4 20       	breq	800036b6 <phy_rx_func+0x3aa>
80003634:	31 39       	mov	r9,19
80003636:	f2 08 18 00 	cp.b	r8,r9
8000363a:	e0 81 00 8b 	brne	80003750 <phy_rx_func+0x444>
8000363e:	c5 98       	rjmp	800036f0 <phy_rx_func+0x3e4>
80003640:	2f 08       	sub	r8,-16
80003642:	30 19       	mov	r9,1
80003644:	f2 08 18 00 	cp.b	r8,r9
80003648:	e0 8b 00 84 	brhi	80003750 <phy_rx_func+0x444>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000364c:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003650:	e2 18 00 f0 	andl	r8,0xf0,COH
80003654:	59 08       	cp.w	r8,16
80003656:	c0 71       	brne	80003664 <phy_rx_func+0x358>
							{
								m_RxBurstType = VOICEHEADER;
80003658:	30 19       	mov	r9,1
8000365a:	fe f8 0a e6 	ld.w	r8,pc[2790]
8000365e:	91 09       	st.w	r8[0x0],r9
80003660:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003664:	e0 48 00 20 	cp.w	r8,32
80003668:	c2 11       	brne	800036aa <phy_rx_func+0x39e>
							{
								m_RxBurstType = VOICETERMINATOR;
8000366a:	30 a9       	mov	r9,10
8000366c:	fe f8 0a d4 	ld.w	r8,pc[2772]
80003670:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003672:	fe f6 0a e6 	ld.w	r6,pc[2790]
80003676:	6c 08       	ld.w	r8,r6[0x0]
80003678:	f0 0a 11 ff 	rsub	r10,r8,-1
8000367c:	fe f7 0a bc 	ld.w	r7,pc[2748]
80003680:	2f f8       	sub	r8,-1
80003682:	6e 0c       	ld.w	r12,r7[0x0]
80003684:	f4 ca fe 00 	sub	r10,r10,-512
80003688:	30 0b       	mov	r11,0
8000368a:	10 0c       	add	r12,r8
8000368c:	f0 1f 02 b4 	mcall	8000415c <phy_rx_func+0xe50>
								
								RxAMBE_IsFillingNext8 = 0;
80003690:	30 08       	mov	r8,0
80003692:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003694:	6e 0c       	ld.w	r12,r7[0x0]
80003696:	f0 1f 02 b3 	mcall	80004160 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
8000369a:	fe f8 0a 96 	ld.w	r8,pc[2710]
8000369e:	70 0c       	ld.w	r12,r8[0x0]
800036a0:	f0 1f 02 9e 	mcall	80004118 <phy_rx_func+0xe0c>
800036a4:	8f 0c       	st.w	r7[0x0],r12
800036a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800036aa:	30 09       	mov	r9,0
800036ac:	fe f8 0a 94 	ld.w	r8,pc[2708]
800036b0:	91 09       	st.w	r8[0x0],r9
800036b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800036b6:	fe f9 0a 8e 	ld.w	r9,pc[2702]
800036ba:	72 08       	ld.w	r8,r9[0x0]
800036bc:	20 48       	sub	r8,4
800036be:	93 08       	st.w	r9[0x0],r8
800036c0:	e0 80 05 1e 	breq	800040fc <phy_rx_func+0xdf0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
800036c4:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800036c8:	fe f8 0a 9c 	ld.w	r8,pc[2716]
800036cc:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800036ce:	8e 69       	ld.sh	r9,r7[0xc]
800036d0:	fe f8 0a 98 	ld.w	r8,pc[2712]
800036d4:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800036d6:	8e 79       	ld.sh	r9,r7[0xe]
800036d8:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800036da:	f0 1f 02 a5 	mcall	8000416c <phy_rx_func+0xe60>
800036de:	fe f8 0a 62 	ld.w	r8,pc[2658]
800036e2:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800036e4:	30 49       	mov	r9,4
800036e6:	fe f8 0a 56 	ld.w	r8,pc[2646]
800036ea:	91 09       	st.w	r8[0x0],r9
800036ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800036f0:	30 09       	mov	r9,0
800036f2:	fe f8 0a 4e 	ld.w	r8,pc[2638]
800036f6:	91 09       	st.w	r8[0x0],r9
800036f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
							
								
					case Radio_Internal_Parameter://0x7F
							
							logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
800036fc:	fe f8 0a 58 	ld.w	r8,pc[2648]
80003700:	70 08       	ld.w	r8,r8[0x0]
80003702:	1a d8       	st.w	--sp,r8
80003704:	fe fc 0a 6c 	ld.w	r12,pc[2668]
80003708:	f0 1f 02 91 	mcall	8000414c <phy_rx_func+0xe40>
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000370c:	fe f9 0a 38 	ld.w	r9,pc[2616]
80003710:	72 08       	ld.w	r8,r9[0x0]
80003712:	20 48       	sub	r8,4
80003714:	93 08       	st.w	r9[0x0],r8
80003716:	2f fd       	sub	sp,-4
80003718:	58 08       	cp.w	r8,0
8000371a:	e0 80 04 f1 	breq	800040fc <phy_rx_func+0xdf0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000371e:	fe f8 0a 56 	ld.w	r8,pc[2646]
80003722:	70 09       	ld.w	r9,r8[0x0]
80003724:	8e 7b       	ld.sh	r11,r7[0xe]
80003726:	fe fa 0a 52 	ld.w	r10,pc[2642]
8000372a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000372e:	2f f9       	sub	r9,-1
80003730:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003732:	fe f8 0a 22 	ld.w	r8,pc[2594]
80003736:	70 09       	ld.w	r9,r8[0x0]
80003738:	20 29       	sub	r9,2
8000373a:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000373c:	30 29       	mov	r9,2
8000373e:	fe f8 0a 02 	ld.w	r8,pc[2562]
80003742:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003744:	30 39       	mov	r9,3
80003746:	fe f8 09 f6 	ld.w	r8,pc[2550]
8000374a:	91 09       	st.w	r8[0x0],r9
8000374c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003750:	30 39       	mov	r9,3
80003752:	fe f8 09 ee 	ld.w	r8,pc[2542]
80003756:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003758:	6e 29       	ld.w	r9,r7[0x8]
8000375a:	fe f8 0a 22 	ld.w	r8,pc[2594]
8000375e:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003760:	6e 39       	ld.w	r9,r7[0xc]
80003762:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003764:	fe f8 09 e0 	ld.w	r8,pc[2528]
80003768:	70 08       	ld.w	r8,r8[0x0]
8000376a:	59 48       	cp.w	r8,20
8000376c:	c0 61       	brne	80003778 <phy_rx_func+0x46c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000376e:	31 89       	mov	r9,24
80003770:	fe f8 09 d4 	ld.w	r8,pc[2516]
80003774:	91 09       	st.w	r8[0x0],r9
80003776:	c0 78       	rjmp	80003784 <phy_rx_func+0x478>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003778:	59 08       	cp.w	r8,16
8000377a:	c0 51       	brne	80003784 <phy_rx_func+0x478>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000377c:	31 09       	mov	r9,16
8000377e:	fe f8 09 c6 	ld.w	r8,pc[2502]
80003782:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003784:	30 49       	mov	r9,4
80003786:	fe f8 09 b6 	ld.w	r8,pc[2486]
8000378a:	91 09       	st.w	r8[0x0],r9
8000378c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003790:	e0 48 10 00 	cp.w	r8,4096
80003794:	5f 19       	srne	r9
80003796:	e0 48 20 00 	cp.w	r8,8192
8000379a:	5f 18       	srne	r8
8000379c:	f3 e8 00 08 	and	r8,r9,r8
800037a0:	e0 81 04 ae 	brne	800040fc <phy_rx_func+0xdf0>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
800037a4:	fe f9 09 dc 	ld.w	r9,pc[2524]
800037a8:	b2 88       	st.b	r9[0x0],r8
				AMBE_rx_flag = 0;
800037aa:	fe f9 09 da 	ld.w	r9,pc[2522]
800037ae:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
800037b0:	fe f9 09 a0 	ld.w	r9,pc[2464]
800037b4:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800037b6:	6e 28       	ld.w	r8,r7[0x8]
800037b8:	e2 18 0f 00 	andl	r8,0xf00,COH
800037bc:	58 18       	cp.w	r8,1
800037be:	e0 8b 00 4d 	brhi	80003858 <phy_rx_func+0x54c>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800037c2:	fe f9 09 82 	ld.w	r9,pc[2434]
800037c6:	72 08       	ld.w	r8,r9[0x0]
800037c8:	20 48       	sub	r8,4
800037ca:	93 08       	st.w	r9[0x0],r8
800037cc:	e0 80 04 98 	breq	800040fc <phy_rx_func+0xdf0>
				ArrayDiscLength = payload_rx_channel->word[2];
800037d0:	8e 68       	ld.sh	r8,r7[0xc]
800037d2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800037d6:	fe f9 09 b2 	ld.w	r9,pc[2482]
800037da:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
800037dc:	30 09       	mov	r9,0
800037de:	f2 08 19 00 	cp.h	r8,r9
800037e2:	c0 70       	breq	800037f0 <phy_rx_func+0x4e4>
800037e4:	30 19       	mov	r9,1
800037e6:	f2 08 19 00 	cp.h	r8,r9
800037ea:	e0 81 04 89 	brne	800040fc <phy_rx_func+0xdf0>
800037ee:	c2 68       	rjmp	8000383a <phy_rx_func+0x52e>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800037f0:	fe f8 09 9c 	ld.w	r8,pc[2460]
800037f4:	70 0a       	ld.w	r10,r8[0x0]
800037f6:	fe f9 09 3e 	ld.w	r9,pc[2366]
800037fa:	72 09       	ld.w	r9,r9[0x0]
800037fc:	8e 7b       	ld.sh	r11,r7[0xe]
800037fe:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80003802:	70 09       	ld.w	r9,r8[0x0]
80003804:	2f f9       	sub	r9,-1
80003806:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003808:	e0 49 00 ff 	cp.w	r9,255
8000380c:	e0 88 00 11 	brls	8000382e <phy_rx_func+0x522>
						{
							RxMedia_IsFillingNext16 = 0;	
80003810:	30 09       	mov	r9,0
80003812:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
80003814:	fe f7 09 20 	ld.w	r7,pc[2336]
80003818:	6e 0c       	ld.w	r12,r7[0x0]
8000381a:	f0 1f 02 52 	mcall	80004160 <phy_rx_func+0xe54>
							payload_ptr = get_payload_idle_isr();
8000381e:	fe f8 09 12 	ld.w	r8,pc[2322]
80003822:	70 0c       	ld.w	r12,r8[0x0]
80003824:	f0 1f 02 3d 	mcall	80004118 <phy_rx_func+0xe0c>
80003828:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
8000382a:	e0 80 04 69 	breq	800040fc <phy_rx_func+0xdf0>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
8000382e:	30 29       	mov	r9,2
80003830:	fe f8 09 0c 	ld.w	r8,pc[2316]
80003834:	91 09       	st.w	r8[0x0],r9
80003836:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000383a:	8e 79       	ld.sh	r9,r7[0xe]
8000383c:	30 38       	mov	r8,3
8000383e:	f0 09 19 00 	cp.h	r9,r8
80003842:	c0 51       	brne	8000384c <phy_rx_func+0x540>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
80003844:	30 19       	mov	r9,1
80003846:	fe f8 09 4a 	ld.w	r8,pc[2378]
8000384a:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
8000384c:	30 29       	mov	r9,2
8000384e:	fe f8 08 ee 	ld.w	r8,pc[2286]
80003852:	91 09       	st.w	r8[0x0],r9
80003854:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003858:	fe f8 08 ec 	ld.w	r8,pc[2284]
8000385c:	70 08       	ld.w	r8,r8[0x0]
8000385e:	58 18       	cp.w	r8,1
80003860:	e0 88 04 4e 	brls	800040fc <phy_rx_func+0xdf0>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003864:	fe f8 09 28 	ld.w	r8,pc[2344]
80003868:	70 0a       	ld.w	r10,r8[0x0]
8000386a:	fe f9 08 ca 	ld.w	r9,pc[2250]
8000386e:	72 09       	ld.w	r9,r9[0x0]
80003870:	6e 3b       	ld.w	r11,r7[0xc]
80003872:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003876:	70 09       	ld.w	r9,r8[0x0]
80003878:	2f f9       	sub	r9,-1
8000387a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000387c:	e0 49 00 ff 	cp.w	r9,255
80003880:	e0 88 00 11 	brls	800038a2 <phy_rx_func+0x596>
				{
					RxMedia_IsFillingNext16 = 0;
80003884:	30 09       	mov	r9,0
80003886:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003888:	fe f7 08 ac 	ld.w	r7,pc[2220]
8000388c:	6e 0c       	ld.w	r12,r7[0x0]
8000388e:	f0 1f 02 35 	mcall	80004160 <phy_rx_func+0xe54>
								payload_ptr = get_payload_idle_isr();
80003892:	fe f8 08 9e 	ld.w	r8,pc[2206]
80003896:	70 0c       	ld.w	r12,r8[0x0]
80003898:	f0 1f 02 20 	mcall	80004118 <phy_rx_func+0xe0c>
8000389c:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
8000389e:	e0 80 04 2f 	breq	800040fc <phy_rx_func+0xdf0>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800038a2:	fe f9 08 a2 	ld.w	r9,pc[2210]
800038a6:	72 08       	ld.w	r8,r9[0x0]
800038a8:	20 28       	sub	r8,2
800038aa:	93 08       	st.w	r9[0x0],r8
800038ac:	e0 80 04 28 	breq	800040fc <phy_rx_func+0xdf0>
				RxMediaState = READINGMEDIA;
800038b0:	30 29       	mov	r9,2
800038b2:	fe f8 08 8a 	ld.w	r8,pc[2186]
800038b6:	91 09       	st.w	r8[0x0],r9
800038b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800038bc:	fe f8 08 d0 	ld.w	r8,pc[2256]
800038c0:	70 0a       	ld.w	r10,r8[0x0]
800038c2:	fe f9 08 72 	ld.w	r9,pc[2162]
800038c6:	72 09       	ld.w	r9,r9[0x0]
800038c8:	8e 4b       	ld.sh	r11,r7[0x8]
800038ca:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800038ce:	70 09       	ld.w	r9,r8[0x0]
800038d0:	2f f9       	sub	r9,-1
800038d2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800038d4:	e0 49 00 ff 	cp.w	r9,255
800038d8:	e0 88 00 16 	brls	80003904 <phy_rx_func+0x5f8>
					{
							RxMedia_IsFillingNext16 = 0;
800038dc:	30 09       	mov	r9,0
800038de:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
800038e0:	fe f6 08 54 	ld.w	r6,pc[2132]
800038e4:	6c 0c       	ld.w	r12,r6[0x0]
800038e6:	f0 1f 02 1f 	mcall	80004160 <phy_rx_func+0xe54>
							payload_ptr = get_payload_idle_isr();
800038ea:	fe f8 08 46 	ld.w	r8,pc[2118]
800038ee:	70 0c       	ld.w	r12,r8[0x0]
800038f0:	f0 1f 02 0a 	mcall	80004118 <phy_rx_func+0xe0c>
800038f4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
800038f6:	c0 71       	brne	80003904 <phy_rx_func+0x5f8>
							{
								RxMediaState = WAITINGABAB;
800038f8:	30 09       	mov	r9,0
800038fa:	fe f8 08 42 	ld.w	r8,pc[2114]
800038fe:	91 09       	st.w	r8[0x0],r9
80003900:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
80003904:	fe f9 08 40 	ld.w	r9,pc[2112]
80003908:	72 08       	ld.w	r8,r9[0x0]
8000390a:	20 28       	sub	r8,2
8000390c:	93 08       	st.w	r9[0x0],r8
8000390e:	c0 71       	brne	8000391c <phy_rx_func+0x610>
				{
					RxMediaState = WAITINGABAB;
80003910:	30 09       	mov	r9,0
80003912:	fe f8 08 2a 	ld.w	r8,pc[2090]
80003916:	91 09       	st.w	r8[0x0],r9
80003918:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
8000391c:	fe f8 08 70 	ld.w	r8,pc[2160]
80003920:	70 0a       	ld.w	r10,r8[0x0]
80003922:	fe f9 08 12 	ld.w	r9,pc[2066]
80003926:	72 09       	ld.w	r9,r9[0x0]
80003928:	8e 5b       	ld.sh	r11,r7[0xa]
8000392a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000392e:	70 09       	ld.w	r9,r8[0x0]
80003930:	2f f9       	sub	r9,-1
80003932:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003934:	e0 49 00 ff 	cp.w	r9,255
80003938:	e0 88 00 16 	brls	80003964 <phy_rx_func+0x658>
						{
							RxMedia_IsFillingNext16 = 0;
8000393c:	30 09       	mov	r9,0
8000393e:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003940:	fe f6 07 f4 	ld.w	r6,pc[2036]
80003944:	6c 0c       	ld.w	r12,r6[0x0]
80003946:	f0 1f 02 07 	mcall	80004160 <phy_rx_func+0xe54>
								payload_ptr = get_payload_idle_isr();
8000394a:	fe f8 07 e6 	ld.w	r8,pc[2022]
8000394e:	70 0c       	ld.w	r12,r8[0x0]
80003950:	f0 1f 01 f2 	mcall	80004118 <phy_rx_func+0xe0c>
80003954:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80003956:	c0 71       	brne	80003964 <phy_rx_func+0x658>
								{
									RxMediaState = WAITINGABAB;
80003958:	30 09       	mov	r9,0
8000395a:	fe f8 07 e2 	ld.w	r8,pc[2018]
8000395e:	91 09       	st.w	r8[0x0],r9
80003960:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003964:	fe f9 07 e0 	ld.w	r9,pc[2016]
80003968:	72 08       	ld.w	r8,r9[0x0]
8000396a:	20 28       	sub	r8,2
8000396c:	93 08       	st.w	r9[0x0],r8
8000396e:	c0 71       	brne	8000397c <phy_rx_func+0x670>
					RxMediaState = WAITINGABAB;
80003970:	30 09       	mov	r9,0
80003972:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003976:	91 09       	st.w	r8[0x0],r9
80003978:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000397c:	fe f8 08 10 	ld.w	r8,pc[2064]
80003980:	70 0a       	ld.w	r10,r8[0x0]
80003982:	fe f9 07 b2 	ld.w	r9,pc[1970]
80003986:	72 09       	ld.w	r9,r9[0x0]
80003988:	8e 6b       	ld.sh	r11,r7[0xc]
8000398a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000398e:	70 09       	ld.w	r9,r8[0x0]
80003990:	2f f9       	sub	r9,-1
80003992:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003994:	e0 49 00 ff 	cp.w	r9,255
80003998:	e0 88 00 16 	brls	800039c4 <phy_rx_func+0x6b8>
						{
							RxMedia_IsFillingNext16 = 0;
8000399c:	30 09       	mov	r9,0
8000399e:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800039a0:	fe f6 07 94 	ld.w	r6,pc[1940]
800039a4:	6c 0c       	ld.w	r12,r6[0x0]
800039a6:	f0 1f 01 ef 	mcall	80004160 <phy_rx_func+0xe54>
									payload_ptr = get_payload_idle_isr();
800039aa:	fe f8 07 86 	ld.w	r8,pc[1926]
800039ae:	70 0c       	ld.w	r12,r8[0x0]
800039b0:	f0 1f 01 da 	mcall	80004118 <phy_rx_func+0xe0c>
800039b4:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
800039b6:	c0 71       	brne	800039c4 <phy_rx_func+0x6b8>
									{
										RxMediaState = WAITINGABAB;
800039b8:	30 09       	mov	r9,0
800039ba:	fe f8 07 82 	ld.w	r8,pc[1922]
800039be:	91 09       	st.w	r8[0x0],r9
800039c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800039c4:	fe f9 07 80 	ld.w	r9,pc[1920]
800039c8:	72 08       	ld.w	r8,r9[0x0]
800039ca:	20 28       	sub	r8,2
800039cc:	93 08       	st.w	r9[0x0],r8
800039ce:	c0 71       	brne	800039dc <phy_rx_func+0x6d0>
					RxMediaState = WAITINGABAB;
800039d0:	30 09       	mov	r9,0
800039d2:	fe f8 07 6a 	ld.w	r8,pc[1898]
800039d6:	91 09       	st.w	r8[0x0],r9
800039d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800039dc:	fe f8 07 b0 	ld.w	r8,pc[1968]
800039e0:	70 0a       	ld.w	r10,r8[0x0]
800039e2:	fe f9 07 52 	ld.w	r9,pc[1874]
800039e6:	72 09       	ld.w	r9,r9[0x0]
800039e8:	8e 7b       	ld.sh	r11,r7[0xe]
800039ea:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800039ee:	70 09       	ld.w	r9,r8[0x0]
800039f0:	2f f9       	sub	r9,-1
800039f2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800039f4:	e0 49 00 ff 	cp.w	r9,255
800039f8:	e0 88 00 16 	brls	80003a24 <phy_rx_func+0x718>
						{
							RxMedia_IsFillingNext16 = 0;
800039fc:	30 09       	mov	r9,0
800039fe:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003a00:	fe f7 07 34 	ld.w	r7,pc[1844]
80003a04:	6e 0c       	ld.w	r12,r7[0x0]
80003a06:	f0 1f 01 d7 	mcall	80004160 <phy_rx_func+0xe54>
							payload_ptr = get_payload_idle_isr();
80003a0a:	fe f8 07 26 	ld.w	r8,pc[1830]
80003a0e:	70 0c       	ld.w	r12,r8[0x0]
80003a10:	f0 1f 01 c2 	mcall	80004118 <phy_rx_func+0xe0c>
80003a14:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80003a16:	c0 71       	brne	80003a24 <phy_rx_func+0x718>
							{
								RxMediaState = WAITINGABAB;
80003a18:	30 09       	mov	r9,0
80003a1a:	fe f8 07 22 	ld.w	r8,pc[1826]
80003a1e:	91 09       	st.w	r8[0x0],r9
80003a20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003a24:	fe f9 07 20 	ld.w	r9,pc[1824]
80003a28:	72 08       	ld.w	r8,r9[0x0]
80003a2a:	20 28       	sub	r8,2
80003a2c:	93 08       	st.w	r9[0x0],r8
80003a2e:	e0 81 03 67 	brne	800040fc <phy_rx_func+0xdf0>
					RxMediaState = WAITINGABAB;
80003a32:	30 09       	mov	r9,0
80003a34:	fe f8 07 08 	ld.w	r8,pc[1800]
80003a38:	91 09       	st.w	r8[0x0],r9
80003a3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003a3e:	fe f8 07 12 	ld.w	r8,pc[1810]
80003a42:	11 89       	ld.ub	r9,r8[0x0]
80003a44:	31 28       	mov	r8,18
80003a46:	f0 09 18 00 	cp.b	r9,r8
80003a4a:	e0 81 01 4c 	brne	80003ce2 <phy_rx_func+0x9d6>
					{
						Item_ID = payload_rx_channel->byte[1];
80003a4e:	ef 39 00 09 	ld.ub	r9,r7[9]
80003a52:	fe f8 06 fe 	ld.w	r8,pc[1790]
80003a56:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003a58:	11 89       	ld.ub	r9,r8[0x0]
80003a5a:	3f 28       	mov	r8,-14
80003a5c:	f0 09 18 00 	cp.b	r9,r8
80003a60:	e0 81 01 3b 	brne	80003cd6 <phy_rx_func+0x9ca>
						{
							AMBE_tx_flag = 1;
80003a64:	30 19       	mov	r9,1
80003a66:	fe f8 07 1a 	ld.w	r8,pc[1818]
80003a6a:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003a6c:	6e 29       	ld.w	r9,r7[0x8]
80003a6e:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003a72:	fe f8 06 d2 	ld.w	r8,pc[1746]
80003a76:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003a78:	8e 59       	ld.sh	r9,r7[0xa]
80003a7a:	fe f8 07 1a 	ld.w	r8,pc[1818]
80003a7e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003a80:	8e 69       	ld.sh	r9,r7[0xc]
80003a82:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003a84:	8e 79       	ld.sh	r9,r7[0xe]
80003a86:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003a88:	fe f8 06 d0 	ld.w	r8,pc[1744]
80003a8c:	fe f9 06 ac 	ld.w	r9,pc[1708]
80003a90:	72 0a       	ld.w	r10,r9[0x0]
80003a92:	70 09       	ld.w	r9,r8[0x0]
80003a94:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003a98:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a9c:	70 09       	ld.w	r9,r8[0x0]
80003a9e:	2f f9       	sub	r9,-1
80003aa0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003aa2:	e0 49 01 ff 	cp.w	r9,511
80003aa6:	e0 88 00 16 	brls	80003ad2 <phy_rx_func+0x7c6>
							{
								RxAMBE_IsFillingNext8 = 0;
80003aaa:	30 09       	mov	r9,0
80003aac:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003aae:	fe f6 06 8a 	ld.w	r6,pc[1674]
80003ab2:	6c 0c       	ld.w	r12,r6[0x0]
80003ab4:	f0 1f 01 ab 	mcall	80004160 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ab8:	fe f8 06 78 	ld.w	r8,pc[1656]
80003abc:	70 0c       	ld.w	r12,r8[0x0]
80003abe:	f0 1f 01 97 	mcall	80004118 <phy_rx_func+0xe0c>
80003ac2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003ac4:	c0 71       	brne	80003ad2 <phy_rx_func+0x7c6>
								{
									RxMediaState = WAITINGABAB;
80003ac6:	30 09       	mov	r9,0
80003ac8:	fe f8 06 74 	ld.w	r8,pc[1652]
80003acc:	91 09       	st.w	r8[0x0],r9
80003ace:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003ad2:	fe f9 06 72 	ld.w	r9,pc[1650]
80003ad6:	72 08       	ld.w	r8,r9[0x0]
80003ad8:	20 18       	sub	r8,1
80003ada:	93 08       	st.w	r9[0x0],r8
80003adc:	c0 71       	brne	80003aea <phy_rx_func+0x7de>
								RxMediaState = WAITINGABAB;
80003ade:	30 09       	mov	r9,0
80003ae0:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003ae4:	91 09       	st.w	r8[0x0],r9
80003ae6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003aea:	fe f8 06 6e 	ld.w	r8,pc[1646]
80003aee:	fe f9 06 4a 	ld.w	r9,pc[1610]
80003af2:	72 0a       	ld.w	r10,r9[0x0]
80003af4:	70 09       	ld.w	r9,r8[0x0]
80003af6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003afa:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003afe:	70 09       	ld.w	r9,r8[0x0]
80003b00:	2f f9       	sub	r9,-1
80003b02:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b04:	e0 49 01 ff 	cp.w	r9,511
80003b08:	e0 88 00 16 	brls	80003b34 <phy_rx_func+0x828>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b0c:	30 09       	mov	r9,0
80003b0e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b10:	fe f6 06 28 	ld.w	r6,pc[1576]
80003b14:	6c 0c       	ld.w	r12,r6[0x0]
80003b16:	f0 1f 01 93 	mcall	80004160 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b1a:	fe f8 06 16 	ld.w	r8,pc[1558]
80003b1e:	70 0c       	ld.w	r12,r8[0x0]
80003b20:	f0 1f 01 7e 	mcall	80004118 <phy_rx_func+0xe0c>
80003b24:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b26:	c0 71       	brne	80003b34 <phy_rx_func+0x828>
								{
									RxMediaState = WAITINGABAB;
80003b28:	30 09       	mov	r9,0
80003b2a:	fe f8 06 12 	ld.w	r8,pc[1554]
80003b2e:	91 09       	st.w	r8[0x0],r9
80003b30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b34:	fe f9 06 10 	ld.w	r9,pc[1552]
80003b38:	72 08       	ld.w	r8,r9[0x0]
80003b3a:	20 18       	sub	r8,1
80003b3c:	93 08       	st.w	r9[0x0],r8
80003b3e:	c0 71       	brne	80003b4c <phy_rx_func+0x840>
								RxMediaState = WAITINGABAB;
80003b40:	30 09       	mov	r9,0
80003b42:	fe f8 05 fa 	ld.w	r8,pc[1530]
80003b46:	91 09       	st.w	r8[0x0],r9
80003b48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003b4c:	fe f8 06 0c 	ld.w	r8,pc[1548]
80003b50:	fe f9 05 e8 	ld.w	r9,pc[1512]
80003b54:	72 0a       	ld.w	r10,r9[0x0]
80003b56:	70 09       	ld.w	r9,r8[0x0]
80003b58:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003b5c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003b60:	70 09       	ld.w	r9,r8[0x0]
80003b62:	2f f9       	sub	r9,-1
80003b64:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b66:	e0 49 01 ff 	cp.w	r9,511
80003b6a:	e0 88 00 16 	brls	80003b96 <phy_rx_func+0x88a>
							{
								RxAMBE_IsFillingNext8 = 0;
80003b6e:	30 09       	mov	r9,0
80003b70:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003b72:	fe f6 05 c6 	ld.w	r6,pc[1478]
80003b76:	6c 0c       	ld.w	r12,r6[0x0]
80003b78:	f0 1f 01 7a 	mcall	80004160 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003b7c:	fe f8 05 b4 	ld.w	r8,pc[1460]
80003b80:	70 0c       	ld.w	r12,r8[0x0]
80003b82:	f0 1f 01 66 	mcall	80004118 <phy_rx_func+0xe0c>
80003b86:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003b88:	c0 71       	brne	80003b96 <phy_rx_func+0x88a>
								{
									RxMediaState = WAITINGABAB;
80003b8a:	30 09       	mov	r9,0
80003b8c:	fe f8 05 b0 	ld.w	r8,pc[1456]
80003b90:	91 09       	st.w	r8[0x0],r9
80003b92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003b96:	fe f9 05 ae 	ld.w	r9,pc[1454]
80003b9a:	72 08       	ld.w	r8,r9[0x0]
80003b9c:	20 18       	sub	r8,1
80003b9e:	93 08       	st.w	r9[0x0],r8
80003ba0:	c0 71       	brne	80003bae <phy_rx_func+0x8a2>
								RxMediaState = WAITINGABAB;
80003ba2:	30 09       	mov	r9,0
80003ba4:	fe f8 05 98 	ld.w	r8,pc[1432]
80003ba8:	91 09       	st.w	r8[0x0],r9
80003baa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003bae:	fe f8 05 aa 	ld.w	r8,pc[1450]
80003bb2:	fe f9 05 86 	ld.w	r9,pc[1414]
80003bb6:	72 0a       	ld.w	r10,r9[0x0]
80003bb8:	70 09       	ld.w	r9,r8[0x0]
80003bba:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003bbe:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003bc2:	70 09       	ld.w	r9,r8[0x0]
80003bc4:	2f f9       	sub	r9,-1
80003bc6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bc8:	e0 49 01 ff 	cp.w	r9,511
80003bcc:	e0 88 00 16 	brls	80003bf8 <phy_rx_func+0x8ec>
							{
								RxAMBE_IsFillingNext8 = 0;
80003bd0:	30 09       	mov	r9,0
80003bd2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003bd4:	fe f6 05 64 	ld.w	r6,pc[1380]
80003bd8:	6c 0c       	ld.w	r12,r6[0x0]
80003bda:	f0 1f 01 62 	mcall	80004160 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003bde:	fe f8 05 52 	ld.w	r8,pc[1362]
80003be2:	70 0c       	ld.w	r12,r8[0x0]
80003be4:	f0 1f 01 4d 	mcall	80004118 <phy_rx_func+0xe0c>
80003be8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003bea:	c0 71       	brne	80003bf8 <phy_rx_func+0x8ec>
								{
									RxMediaState = WAITINGABAB;
80003bec:	30 09       	mov	r9,0
80003bee:	fe f8 05 4e 	ld.w	r8,pc[1358]
80003bf2:	91 09       	st.w	r8[0x0],r9
80003bf4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003bf8:	fe f9 05 4c 	ld.w	r9,pc[1356]
80003bfc:	72 08       	ld.w	r8,r9[0x0]
80003bfe:	20 18       	sub	r8,1
80003c00:	93 08       	st.w	r9[0x0],r8
80003c02:	c0 71       	brne	80003c10 <phy_rx_func+0x904>
								RxMediaState = WAITINGABAB;
80003c04:	30 09       	mov	r9,0
80003c06:	fe f8 05 36 	ld.w	r8,pc[1334]
80003c0a:	91 09       	st.w	r8[0x0],r9
80003c0c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80003c10:	fe f8 05 48 	ld.w	r8,pc[1352]
80003c14:	fe f9 05 24 	ld.w	r9,pc[1316]
80003c18:	72 0a       	ld.w	r10,r9[0x0]
80003c1a:	70 09       	ld.w	r9,r8[0x0]
80003c1c:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003c20:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c24:	70 09       	ld.w	r9,r8[0x0]
80003c26:	2f f9       	sub	r9,-1
80003c28:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c2a:	e0 49 01 ff 	cp.w	r9,511
80003c2e:	e0 88 00 16 	brls	80003c5a <phy_rx_func+0x94e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c32:	30 09       	mov	r9,0
80003c34:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c36:	fe f6 05 02 	ld.w	r6,pc[1282]
80003c3a:	6c 0c       	ld.w	r12,r6[0x0]
80003c3c:	f0 1f 01 49 	mcall	80004160 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003c40:	fe f8 04 f0 	ld.w	r8,pc[1264]
80003c44:	70 0c       	ld.w	r12,r8[0x0]
80003c46:	f0 1f 01 35 	mcall	80004118 <phy_rx_func+0xe0c>
80003c4a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003c4c:	c0 71       	brne	80003c5a <phy_rx_func+0x94e>
								{
									RxMediaState = WAITINGABAB;
80003c4e:	30 09       	mov	r9,0
80003c50:	fe f8 04 ec 	ld.w	r8,pc[1260]
80003c54:	91 09       	st.w	r8[0x0],r9
80003c56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003c5a:	fe f9 04 ea 	ld.w	r9,pc[1258]
80003c5e:	72 08       	ld.w	r8,r9[0x0]
80003c60:	20 18       	sub	r8,1
80003c62:	93 08       	st.w	r9[0x0],r8
80003c64:	c0 71       	brne	80003c72 <phy_rx_func+0x966>
								RxMediaState = WAITINGABAB;
80003c66:	30 09       	mov	r9,0
80003c68:	fe f8 04 d4 	ld.w	r8,pc[1236]
80003c6c:	91 09       	st.w	r8[0x0],r9
80003c6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003c72:	fe f8 04 e6 	ld.w	r8,pc[1254]
80003c76:	fe f9 04 c2 	ld.w	r9,pc[1218]
80003c7a:	72 0a       	ld.w	r10,r9[0x0]
80003c7c:	70 09       	ld.w	r9,r8[0x0]
80003c7e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003c82:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003c86:	70 09       	ld.w	r9,r8[0x0]
80003c88:	2f f9       	sub	r9,-1
80003c8a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c8c:	e0 49 01 ff 	cp.w	r9,511
80003c90:	e0 88 00 16 	brls	80003cbc <phy_rx_func+0x9b0>
							{
								RxAMBE_IsFillingNext8 = 0;
80003c94:	30 09       	mov	r9,0
80003c96:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003c98:	fe f7 04 a0 	ld.w	r7,pc[1184]
80003c9c:	6e 0c       	ld.w	r12,r7[0x0]
80003c9e:	f0 1f 01 31 	mcall	80004160 <phy_rx_func+0xe54>
								AMBE_payload_ptr = get_payload_idle_isr();
80003ca2:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003ca6:	70 0c       	ld.w	r12,r8[0x0]
80003ca8:	f0 1f 01 1c 	mcall	80004118 <phy_rx_func+0xe0c>
80003cac:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003cae:	c0 71       	brne	80003cbc <phy_rx_func+0x9b0>
								{
									RxMediaState = WAITINGABAB;
80003cb0:	30 09       	mov	r9,0
80003cb2:	fe f8 04 8a 	ld.w	r8,pc[1162]
80003cb6:	91 09       	st.w	r8[0x0],r9
80003cb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003cbc:	fe f9 04 88 	ld.w	r9,pc[1160]
80003cc0:	72 08       	ld.w	r8,r9[0x0]
80003cc2:	20 18       	sub	r8,1
80003cc4:	93 08       	st.w	r9[0x0],r8
80003cc6:	e0 81 02 1b 	brne	800040fc <phy_rx_func+0xdf0>
								RxMediaState = WAITINGABAB;
80003cca:	30 09       	mov	r9,0
80003ccc:	fe f8 04 70 	ld.w	r8,pc[1136]
80003cd0:	91 09       	st.w	r8[0x0],r9
80003cd2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003cd6:	30 09       	mov	r9,0
80003cd8:	fe f8 04 64 	ld.w	r8,pc[1124]
80003cdc:	91 09       	st.w	r8[0x0],r9
80003cde:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003ce2:	fe f8 04 6e 	ld.w	r8,pc[1134]
80003ce6:	11 89       	ld.ub	r9,r8[0x0]
80003ce8:	3f 28       	mov	r8,-14
80003cea:	f0 09 18 00 	cp.b	r9,r8
80003cee:	c4 31       	brne	80003d74 <phy_rx_func+0xa68>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003cf0:	8e 49       	ld.sh	r9,r7[0x8]
80003cf2:	fe f8 04 a2 	ld.w	r8,pc[1186]
80003cf6:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003cf8:	fe f8 04 60 	ld.w	r8,pc[1120]
80003cfc:	fe f9 04 3c 	ld.w	r9,pc[1084]
80003d00:	72 0a       	ld.w	r10,r9[0x0]
80003d02:	70 09       	ld.w	r9,r8[0x0]
80003d04:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003d08:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d0c:	70 09       	ld.w	r9,r8[0x0]
80003d0e:	2f f9       	sub	r9,-1
80003d10:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d12:	e0 49 01 ff 	cp.w	r9,511
80003d16:	e0 88 00 16 	brls	80003d42 <phy_rx_func+0xa36>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d1a:	30 09       	mov	r9,0
80003d1c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d1e:	fe f7 04 1a 	ld.w	r7,pc[1050]
80003d22:	6e 0c       	ld.w	r12,r7[0x0]
80003d24:	f0 1f 01 0f 	mcall	80004160 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d28:	fe f8 04 08 	ld.w	r8,pc[1032]
80003d2c:	70 0c       	ld.w	r12,r8[0x0]
80003d2e:	f0 1f 00 fb 	mcall	80004118 <phy_rx_func+0xe0c>
80003d32:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d34:	c0 71       	brne	80003d42 <phy_rx_func+0xa36>
							{
								RxMediaState = WAITINGABAB;
80003d36:	30 09       	mov	r9,0
80003d38:	fe f8 04 04 	ld.w	r8,pc[1028]
80003d3c:	91 09       	st.w	r8[0x0],r9
80003d3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d42:	fe f9 04 02 	ld.w	r9,pc[1026]
80003d46:	72 08       	ld.w	r8,r9[0x0]
80003d48:	20 18       	sub	r8,1
80003d4a:	93 08       	st.w	r9[0x0],r8
80003d4c:	c0 71       	brne	80003d5a <phy_rx_func+0xa4e>
							RxMediaState = WAITINGABAB;
80003d4e:	30 09       	mov	r9,0
80003d50:	fe f8 03 ec 	ld.w	r8,pc[1004]
80003d54:	91 09       	st.w	r8[0x0],r9
80003d56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003d5a:	20 18       	sub	r8,1
80003d5c:	fe f9 03 e8 	ld.w	r9,pc[1000]
80003d60:	93 08       	st.w	r9[0x0],r8
80003d62:	58 08       	cp.w	r8,0
80003d64:	e0 81 01 cc 	brne	800040fc <phy_rx_func+0xdf0>
							RxMediaState = WAITINGABAB;
80003d68:	30 09       	mov	r9,0
80003d6a:	fe f8 03 d2 	ld.w	r8,pc[978]
80003d6e:	91 09       	st.w	r8[0x0],r9
80003d70:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit0~bit63
80003d74:	fe f8 03 dc 	ld.w	r8,pc[988]
80003d78:	11 89       	ld.ub	r9,r8[0x0]
80003d7a:	3f 38       	mov	r8,-13
80003d7c:	f0 09 18 00 	cp.b	r9,r8
80003d80:	e0 81 01 5a 	brne	80004034 <phy_rx_func+0xd28>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[0] = payload_rx_channel->word[0];
80003d84:	8e 49       	ld.sh	r9,r7[0x8]
80003d86:	fe f8 04 0e 	ld.w	r8,pc[1038]
80003d8a:	b0 09       	st.h	r8[0x0],r9
						AMBEBurst_rawdata[1] = payload_rx_channel->word[1];
80003d8c:	8e 59       	ld.sh	r9,r7[0xa]
80003d8e:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[2];
80003d90:	8e 69       	ld.sh	r9,r7[0xc]
80003d92:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[3];
80003d94:	8e 79       	ld.sh	r9,r7[0xe]
80003d96:	b0 39       	st.h	r8[0x6],r9
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//1
80003d98:	fe f8 03 c0 	ld.w	r8,pc[960]
80003d9c:	fe f9 03 9c 	ld.w	r9,pc[924]
80003da0:	72 0a       	ld.w	r10,r9[0x0]
80003da2:	70 09       	ld.w	r9,r8[0x0]
80003da4:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003da8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003dac:	70 09       	ld.w	r9,r8[0x0]
80003dae:	2f f9       	sub	r9,-1
80003db0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003db2:	e0 49 01 ff 	cp.w	r9,511
80003db6:	e0 88 00 16 	brls	80003de2 <phy_rx_func+0xad6>
						{
							RxAMBE_IsFillingNext8 = 0;
80003dba:	30 09       	mov	r9,0
80003dbc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003dbe:	fe f6 03 7a 	ld.w	r6,pc[890]
80003dc2:	6c 0c       	ld.w	r12,r6[0x0]
80003dc4:	f0 1f 00 e7 	mcall	80004160 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003dc8:	fe f8 03 68 	ld.w	r8,pc[872]
80003dcc:	70 0c       	ld.w	r12,r8[0x0]
80003dce:	f0 1f 00 d3 	mcall	80004118 <phy_rx_func+0xe0c>
80003dd2:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003dd4:	c0 71       	brne	80003de2 <phy_rx_func+0xad6>
							{
								RxMediaState = WAITINGABAB;
80003dd6:	30 09       	mov	r9,0
80003dd8:	fe f8 03 64 	ld.w	r8,pc[868]
80003ddc:	91 09       	st.w	r8[0x0],r9
80003dde:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003de2:	fe f9 03 62 	ld.w	r9,pc[866]
80003de6:	72 08       	ld.w	r8,r9[0x0]
80003de8:	20 18       	sub	r8,1
80003dea:	93 08       	st.w	r9[0x0],r8
80003dec:	c0 71       	brne	80003dfa <phy_rx_func+0xaee>
							RxMediaState = WAITINGABAB;
80003dee:	30 09       	mov	r9,0
80003df0:	fe f8 03 4c 	ld.w	r8,pc[844]
80003df4:	91 09       	st.w	r8[0x0],r9
80003df6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//2
80003dfa:	fe f8 03 5e 	ld.w	r8,pc[862]
80003dfe:	fe f9 03 3a 	ld.w	r9,pc[826]
80003e02:	72 0a       	ld.w	r10,r9[0x0]
80003e04:	70 09       	ld.w	r9,r8[0x0]
80003e06:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003e0a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e0e:	70 09       	ld.w	r9,r8[0x0]
80003e10:	2f f9       	sub	r9,-1
80003e12:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e14:	e0 49 01 ff 	cp.w	r9,511
80003e18:	e0 88 00 16 	brls	80003e44 <phy_rx_func+0xb38>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e1c:	30 09       	mov	r9,0
80003e1e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e20:	fe f6 03 18 	ld.w	r6,pc[792]
80003e24:	6c 0c       	ld.w	r12,r6[0x0]
80003e26:	f0 1f 00 cf 	mcall	80004160 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e2a:	fe f8 03 06 	ld.w	r8,pc[774]
80003e2e:	70 0c       	ld.w	r12,r8[0x0]
80003e30:	f0 1f 00 ba 	mcall	80004118 <phy_rx_func+0xe0c>
80003e34:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e36:	c0 71       	brne	80003e44 <phy_rx_func+0xb38>
							{
								RxMediaState = WAITINGABAB;
80003e38:	30 09       	mov	r9,0
80003e3a:	fe f8 03 02 	ld.w	r8,pc[770]
80003e3e:	91 09       	st.w	r8[0x0],r9
80003e40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003e44:	fe f9 03 00 	ld.w	r9,pc[768]
80003e48:	72 08       	ld.w	r8,r9[0x0]
80003e4a:	20 18       	sub	r8,1
80003e4c:	93 08       	st.w	r9[0x0],r8
80003e4e:	c0 71       	brne	80003e5c <phy_rx_func+0xb50>
							RxMediaState = WAITINGABAB;
80003e50:	30 09       	mov	r9,0
80003e52:	fe f8 02 ea 	ld.w	r8,pc[746]
80003e56:	91 09       	st.w	r8[0x0],r9
80003e58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//3
80003e5c:	fe f8 02 fc 	ld.w	r8,pc[764]
80003e60:	fe f9 02 d8 	ld.w	r9,pc[728]
80003e64:	72 0a       	ld.w	r10,r9[0x0]
80003e66:	70 09       	ld.w	r9,r8[0x0]
80003e68:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003e6c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003e70:	70 09       	ld.w	r9,r8[0x0]
80003e72:	2f f9       	sub	r9,-1
80003e74:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e76:	e0 49 01 ff 	cp.w	r9,511
80003e7a:	e0 88 00 16 	brls	80003ea6 <phy_rx_func+0xb9a>
						{
							RxAMBE_IsFillingNext8 = 0;
80003e7e:	30 09       	mov	r9,0
80003e80:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003e82:	fe f6 02 b6 	ld.w	r6,pc[694]
80003e86:	6c 0c       	ld.w	r12,r6[0x0]
80003e88:	f0 1f 00 b6 	mcall	80004160 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003e8c:	fe f8 02 a4 	ld.w	r8,pc[676]
80003e90:	70 0c       	ld.w	r12,r8[0x0]
80003e92:	f0 1f 00 a2 	mcall	80004118 <phy_rx_func+0xe0c>
80003e96:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003e98:	c0 71       	brne	80003ea6 <phy_rx_func+0xb9a>
							{
								RxMediaState = WAITINGABAB;
80003e9a:	30 09       	mov	r9,0
80003e9c:	fe f8 02 a0 	ld.w	r8,pc[672]
80003ea0:	91 09       	st.w	r8[0x0],r9
80003ea2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ea6:	fe f9 02 9e 	ld.w	r9,pc[670]
80003eaa:	72 08       	ld.w	r8,r9[0x0]
80003eac:	20 18       	sub	r8,1
80003eae:	93 08       	st.w	r9[0x0],r8
80003eb0:	c0 71       	brne	80003ebe <phy_rx_func+0xbb2>
							RxMediaState = WAITINGABAB;
80003eb2:	30 09       	mov	r9,0
80003eb4:	fe f8 02 88 	ld.w	r8,pc[648]
80003eb8:	91 09       	st.w	r8[0x0],r9
80003eba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//4
80003ebe:	fe f8 02 9a 	ld.w	r8,pc[666]
80003ec2:	fe f9 02 76 	ld.w	r9,pc[630]
80003ec6:	72 0a       	ld.w	r10,r9[0x0]
80003ec8:	70 09       	ld.w	r9,r8[0x0]
80003eca:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003ece:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003ed2:	70 09       	ld.w	r9,r8[0x0]
80003ed4:	2f f9       	sub	r9,-1
80003ed6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ed8:	e0 49 01 ff 	cp.w	r9,511
80003edc:	e0 88 00 16 	brls	80003f08 <phy_rx_func+0xbfc>
						{
							RxAMBE_IsFillingNext8 = 0;
80003ee0:	30 09       	mov	r9,0
80003ee2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ee4:	fe f6 02 54 	ld.w	r6,pc[596]
80003ee8:	6c 0c       	ld.w	r12,r6[0x0]
80003eea:	f0 1f 00 9e 	mcall	80004160 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003eee:	fe f8 02 42 	ld.w	r8,pc[578]
80003ef2:	70 0c       	ld.w	r12,r8[0x0]
80003ef4:	f0 1f 00 89 	mcall	80004118 <phy_rx_func+0xe0c>
80003ef8:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003efa:	c0 71       	brne	80003f08 <phy_rx_func+0xbfc>
							{
								RxMediaState = WAITINGABAB;
80003efc:	30 09       	mov	r9,0
80003efe:	fe f8 02 3e 	ld.w	r8,pc[574]
80003f02:	91 09       	st.w	r8[0x0],r9
80003f04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f08:	fe f9 02 3c 	ld.w	r9,pc[572]
80003f0c:	72 08       	ld.w	r8,r9[0x0]
80003f0e:	20 18       	sub	r8,1
80003f10:	93 08       	st.w	r9[0x0],r8
80003f12:	c0 71       	brne	80003f20 <phy_rx_func+0xc14>
							RxMediaState = WAITINGABAB;
80003f14:	30 09       	mov	r9,0
80003f16:	fe f8 02 26 	ld.w	r8,pc[550]
80003f1a:	91 09       	st.w	r8[0x0],r9
80003f1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//5
80003f20:	fe f8 02 38 	ld.w	r8,pc[568]
80003f24:	fe f9 02 14 	ld.w	r9,pc[532]
80003f28:	72 0a       	ld.w	r10,r9[0x0]
80003f2a:	70 09       	ld.w	r9,r8[0x0]
80003f2c:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003f30:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f34:	70 09       	ld.w	r9,r8[0x0]
80003f36:	2f f9       	sub	r9,-1
80003f38:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f3a:	e0 49 01 ff 	cp.w	r9,511
80003f3e:	e0 88 00 13 	brls	80003f64 <phy_rx_func+0xc58>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f42:	30 09       	mov	r9,0
80003f44:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f46:	4f d6       	lddpc	r6,80004138 <phy_rx_func+0xe2c>
80003f48:	6c 0c       	ld.w	r12,r6[0x0]
80003f4a:	f0 1f 00 86 	mcall	80004160 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003f4e:	4f 98       	lddpc	r8,80004130 <phy_rx_func+0xe24>
80003f50:	70 0c       	ld.w	r12,r8[0x0]
80003f52:	f0 1f 00 72 	mcall	80004118 <phy_rx_func+0xe0c>
80003f56:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003f58:	c0 61       	brne	80003f64 <phy_rx_func+0xc58>
							{
								RxMediaState = WAITINGABAB;
80003f5a:	30 09       	mov	r9,0
80003f5c:	4f 88       	lddpc	r8,8000413c <phy_rx_func+0xe30>
80003f5e:	91 09       	st.w	r8[0x0],r9
80003f60:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003f64:	4f 89       	lddpc	r9,80004144 <phy_rx_func+0xe38>
80003f66:	72 08       	ld.w	r8,r9[0x0]
80003f68:	20 18       	sub	r8,1
80003f6a:	93 08       	st.w	r9[0x0],r8
80003f6c:	c0 61       	brne	80003f78 <phy_rx_func+0xc6c>
							RxMediaState = WAITINGABAB;
80003f6e:	30 09       	mov	r9,0
80003f70:	4f 38       	lddpc	r8,8000413c <phy_rx_func+0xe30>
80003f72:	91 09       	st.w	r8[0x0],r9
80003f74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//6
80003f78:	4f 88       	lddpc	r8,80004158 <phy_rx_func+0xe4c>
80003f7a:	4f 09       	lddpc	r9,80004138 <phy_rx_func+0xe2c>
80003f7c:	72 0a       	ld.w	r10,r9[0x0]
80003f7e:	70 09       	ld.w	r9,r8[0x0]
80003f80:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003f84:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003f88:	70 09       	ld.w	r9,r8[0x0]
80003f8a:	2f f9       	sub	r9,-1
80003f8c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003f8e:	e0 49 01 ff 	cp.w	r9,511
80003f92:	e0 88 00 13 	brls	80003fb8 <phy_rx_func+0xcac>
						{
							RxAMBE_IsFillingNext8 = 0;
80003f96:	30 09       	mov	r9,0
80003f98:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003f9a:	4e 86       	lddpc	r6,80004138 <phy_rx_func+0xe2c>
80003f9c:	6c 0c       	ld.w	r12,r6[0x0]
80003f9e:	f0 1f 00 71 	mcall	80004160 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003fa2:	4e 48       	lddpc	r8,80004130 <phy_rx_func+0xe24>
80003fa4:	70 0c       	ld.w	r12,r8[0x0]
80003fa6:	f0 1f 00 5d 	mcall	80004118 <phy_rx_func+0xe0c>
80003faa:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003fac:	c0 61       	brne	80003fb8 <phy_rx_func+0xcac>
							{
								RxMediaState = WAITINGABAB;
80003fae:	30 09       	mov	r9,0
80003fb0:	4e 38       	lddpc	r8,8000413c <phy_rx_func+0xe30>
80003fb2:	91 09       	st.w	r8[0x0],r9
80003fb4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003fb8:	4e 39       	lddpc	r9,80004144 <phy_rx_func+0xe38>
80003fba:	72 08       	ld.w	r8,r9[0x0]
80003fbc:	20 18       	sub	r8,1
80003fbe:	93 08       	st.w	r9[0x0],r8
80003fc0:	c0 61       	brne	80003fcc <phy_rx_func+0xcc0>
							RxMediaState = WAITINGABAB;
80003fc2:	30 09       	mov	r9,0
80003fc4:	4d e8       	lddpc	r8,8000413c <phy_rx_func+0xe30>
80003fc6:	91 09       	st.w	r8[0x0],r9
80003fc8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//7
80003fcc:	4e 38       	lddpc	r8,80004158 <phy_rx_func+0xe4c>
80003fce:	4d b9       	lddpc	r9,80004138 <phy_rx_func+0xe2c>
80003fd0:	72 0a       	ld.w	r10,r9[0x0]
80003fd2:	70 09       	ld.w	r9,r8[0x0]
80003fd4:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003fd8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003fdc:	70 09       	ld.w	r9,r8[0x0]
80003fde:	2f f9       	sub	r9,-1
80003fe0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003fe2:	e0 49 01 ff 	cp.w	r9,511
80003fe6:	e0 88 00 13 	brls	8000400c <phy_rx_func+0xd00>
						{
							RxAMBE_IsFillingNext8 = 0;
80003fea:	30 09       	mov	r9,0
80003fec:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003fee:	4d 37       	lddpc	r7,80004138 <phy_rx_func+0xe2c>
80003ff0:	6e 0c       	ld.w	r12,r7[0x0]
80003ff2:	f0 1f 00 5c 	mcall	80004160 <phy_rx_func+0xe54>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ff6:	4c f8       	lddpc	r8,80004130 <phy_rx_func+0xe24>
80003ff8:	70 0c       	ld.w	r12,r8[0x0]
80003ffa:	f0 1f 00 48 	mcall	80004118 <phy_rx_func+0xe0c>
80003ffe:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004000:	c0 61       	brne	8000400c <phy_rx_func+0xd00>
							{
								RxMediaState = WAITINGABAB;
80004002:	30 09       	mov	r9,0
80004004:	4c e8       	lddpc	r8,8000413c <phy_rx_func+0xe30>
80004006:	91 09       	st.w	r8[0x0],r9
80004008:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000400c:	4c e9       	lddpc	r9,80004144 <phy_rx_func+0xe38>
8000400e:	72 08       	ld.w	r8,r9[0x0]
80004010:	20 18       	sub	r8,1
80004012:	93 08       	st.w	r9[0x0],r8
80004014:	c0 61       	brne	80004020 <phy_rx_func+0xd14>
							RxMediaState = WAITINGABAB;
80004016:	30 09       	mov	r9,0
80004018:	4c 98       	lddpc	r8,8000413c <phy_rx_func+0xe30>
8000401a:	91 09       	st.w	r8[0x0],r9
8000401c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80004020:	20 18       	sub	r8,1
80004022:	4c 99       	lddpc	r9,80004144 <phy_rx_func+0xe38>
80004024:	93 08       	st.w	r9[0x0],r8
80004026:	58 08       	cp.w	r8,0
80004028:	c6 a1       	brne	800040fc <phy_rx_func+0xdf0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
8000402a:	30 09       	mov	r9,0
8000402c:	4c 48       	lddpc	r8,8000413c <phy_rx_func+0xe30>
8000402e:	91 09       	st.w	r8[0x0],r9
80004030:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004034:	4c 78       	lddpc	r8,80004150 <phy_rx_func+0xe44>
80004036:	11 89       	ld.ub	r9,r8[0x0]
80004038:	30 48       	mov	r8,4
8000403a:	f0 09 18 00 	cp.b	r9,r8
8000403e:	c0 70       	breq	8000404c <phy_rx_func+0xd40>
80004040:	4c 48       	lddpc	r8,80004150 <phy_rx_func+0xe44>
80004042:	11 89       	ld.ub	r9,r8[0x0]
80004044:	30 38       	mov	r8,3
80004046:	f0 09 18 00 	cp.b	r9,r8
8000404a:	c1 01       	brne	8000406a <phy_rx_func+0xd5e>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
8000404c:	6e 29       	ld.w	r9,r7[0x8]
8000404e:	4c c8       	lddpc	r8,8000417c <phy_rx_func+0xe70>
80004050:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004052:	6e 39       	ld.w	r9,r7[0xc]
80004054:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004056:	4b c9       	lddpc	r9,80004144 <phy_rx_func+0xe38>
80004058:	72 08       	ld.w	r8,r9[0x0]
8000405a:	20 88       	sub	r8,8
8000405c:	93 08       	st.w	r9[0x0],r8
8000405e:	c4 f1       	brne	800040fc <phy_rx_func+0xdf0>
						{
					
							RxBytesWaiting = 0;
80004060:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004062:	4b 79       	lddpc	r9,8000413c <phy_rx_func+0xe30>
80004064:	93 08       	st.w	r9[0x0],r8
80004066:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
8000406a:	30 09       	mov	r9,0
8000406c:	4b 48       	lddpc	r8,8000413c <phy_rx_func+0xe30>
8000406e:	91 09       	st.w	r8[0x0],r9
80004070:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80004074:	4c 08       	lddpc	r8,80004174 <phy_rx_func+0xe68>
80004076:	70 09       	ld.w	r9,r8[0x0]
80004078:	8e 4b       	ld.sh	r11,r7[0x8]
8000407a:	4c 0a       	lddpc	r10,80004178 <phy_rx_func+0xe6c>
8000407c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80004080:	2f f9       	sub	r9,-1
80004082:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80004084:	4b 48       	lddpc	r8,80004154 <phy_rx_func+0xe48>
80004086:	70 09       	ld.w	r9,r8[0x0]
80004088:	20 29       	sub	r9,2
8000408a:	91 09       	st.w	r8[0x0],r9
8000408c:	70 08       	ld.w	r8,r8[0x0]
8000408e:	58 08       	cp.w	r8,0
80004090:	c3 01       	brne	800040f0 <phy_rx_func+0xde4>
				{
					RxData_IsFillingNext16 = 0;
80004092:	30 09       	mov	r9,0
80004094:	4b 88       	lddpc	r8,80004174 <phy_rx_func+0xe68>
80004096:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004098:	8e 59       	ld.sh	r9,r7[0xa]
8000409a:	fe 78 82 12 	mov	r8,-32238
8000409e:	f0 09 19 00 	cp.h	r9,r8
800040a2:	c2 21       	brne	800040e6 <phy_rx_func+0xdda>
				
					if (payload_rx_channel->word[1] == 0x8212 )
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						VF_SN = payload_rx_channel->byte[5];//This parameter is very important to the loop back Radio, as a reference.
800040a4:	ef 3c 00 0d 	ld.ub	r12,r7[13]
800040a8:	4a f8       	lddpc	r8,80004164 <phy_rx_func+0xe58>
800040aa:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
800040ac:	8e 59       	ld.sh	r9,r7[0xa]
800040ae:	4a f8       	lddpc	r8,80004168 <phy_rx_func+0xe5c>
800040b0:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
800040b2:	8e 69       	ld.sh	r9,r7[0xc]
800040b4:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
800040b6:	f0 1f 00 2e 	mcall	8000416c <phy_rx_func+0xe60>
800040ba:	4a 28       	lddpc	r8,80004140 <phy_rx_func+0xe34>
800040bc:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800040be:	ef 39 00 0f 	ld.ub	r9,r7[15]
800040c2:	3f 38       	mov	r8,-13
800040c4:	f0 09 18 00 	cp.b	r9,r8
800040c8:	c0 a1       	brne	800040dc <phy_rx_func+0xdd0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Pre_Voice_Decoder_Data)//0xF3
						{
							Item_ID = Pre_Voice_Decoder_Data;
800040ca:	10 99       	mov	r9,r8
800040cc:	4a 18       	lddpc	r8,80004150 <phy_rx_func+0xe44>
800040ce:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 8
800040d0:	30 09       	mov	r9,0
800040d2:	49 d8       	lddpc	r8,80004144 <phy_rx_func+0xe38>
800040d4:	91 09       	st.w	r8[0x0],r9
							AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
800040d6:	30 19       	mov	r9,1
800040d8:	4a b8       	lddpc	r8,80004184 <phy_rx_func+0xe78>
800040da:	b0 89       	st.b	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
800040dc:	30 49       	mov	r9,4
800040de:	49 88       	lddpc	r8,8000413c <phy_rx_func+0xe30>
800040e0:	91 09       	st.w	r8[0x0],r9
800040e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
800040e6:	30 09       	mov	r9,0
800040e8:	49 58       	lddpc	r8,8000413c <phy_rx_func+0xe30>
800040ea:	91 09       	st.w	r8[0x0],r9
800040ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
800040f0:	4a ac       	lddpc	r12,80004198 <phy_rx_func+0xe8c>
800040f2:	f0 1f 00 17 	mcall	8000414c <phy_rx_func+0xe40>
					RxMediaState = WAITINGABAB;//Jump
800040f6:	30 09       	mov	r9,0
800040f8:	49 18       	lddpc	r8,8000413c <phy_rx_func+0xe30>
800040fa:	91 09       	st.w	r8[0x0],r9
800040fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004100:	00 00       	add	r0,r0
80004102:	0a d4       	st.w	--r5,r4
80004104:	00 00       	add	r0,r0
80004106:	0a c4       	st.b	r5++,r4
80004108:	00 00       	add	r0,r0
8000410a:	0a 64       	and	r4,r5
8000410c:	00 00       	add	r0,r0
8000410e:	0a 60       	and	r0,r5
80004110:	00 00       	add	r0,r0
80004112:	0a f8       	st.b	--r5,r8
80004114:	00 00       	add	r0,r0
80004116:	0a 98       	mov	r8,r5
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	2a 28       	sub	r8,-94
8000411c:	00 00       	add	r0,r0
8000411e:	0a bc       	st.h	r5++,r12
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	57 38       	stdsp	sp[0x1cc],r8
80004124:	00 00       	add	r0,r0
80004126:	0a f0       	st.b	--r5,r0
80004128:	80 00       	ld.sh	r0,r0[0x0]
8000412a:	29 74       	sub	r4,-105
8000412c:	00 00       	add	r0,r0
8000412e:	0a 7c       	tst	r12,r5
80004130:	00 00       	add	r0,r0
80004132:	0a 70       	tst	r0,r5
80004134:	00 00       	add	r0,r0
80004136:	0a b4       	st.h	r5++,r4
80004138:	00 00       	add	r0,r0
8000413a:	0a 84       	andn	r4,r5
8000413c:	00 00       	add	r0,r0
8000413e:	0a b0       	st.h	r5++,r0
80004140:	00 00       	add	r0,r0
80004142:	0a 68       	and	r8,r5
80004144:	00 00       	add	r0,r0
80004146:	0a dc       	st.w	--r5,r12
80004148:	80 01       	ld.sh	r1,r0[0x0]
8000414a:	58 f0       	cp.w	r0,15
8000414c:	80 00       	ld.sh	r0,r0[0x0]
8000414e:	68 30       	ld.w	r0,r4[0xc]
80004150:	00 00       	add	r0,r0
80004152:	0a d0       	st.w	--r5,r0
80004154:	00 00       	add	r0,r0
80004156:	0a 9c       	mov	r12,r5
80004158:	00 00       	add	r0,r0
8000415a:	0a a0       	st.w	r5++,r0
8000415c:	80 00       	ld.sh	r0,r0[0x0]
8000415e:	71 4c       	ld.w	r12,r8[0x50]
80004160:	80 00       	ld.sh	r0,r0[0x0]
80004162:	32 ac       	mov	r12,42
80004164:	00 00       	add	r0,r0
80004166:	0a 39       	cp.w	r9,r5
80004168:	00 00       	add	r0,r0
8000416a:	0e d0       	st.w	--r7,r0
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	28 b8       	sub	r8,-117
80004170:	80 01       	ld.sh	r1,r0[0x0]
80004172:	59 08       	cp.w	r8,16
80004174:	00 00       	add	r0,r0
80004176:	0a c0       	st.b	r5++,r0
80004178:	00 00       	add	r0,r0
8000417a:	0d d4       	ld.ub	r4,r6[0x5]
8000417c:	00 00       	add	r0,r0
8000417e:	0a 90       	mov	r0,r5
80004180:	00 00       	add	r0,r0
80004182:	0a 4c       	or	r12,r5
80004184:	00 00       	add	r0,r0
80004186:	0a 38       	cp.w	r8,r5
80004188:	00 00       	add	r0,r0
8000418a:	0a e4       	st.h	--r5,r4
8000418c:	00 00       	add	r0,r0
8000418e:	0a 88       	andn	r8,r5
80004190:	00 00       	add	r0,r0
80004192:	0a 4d       	or	sp,r5
80004194:	00 00       	add	r0,r0
80004196:	0d cc       	ld.ub	r12,r6[0x4]
80004198:	80 01       	ld.sh	r1,r0[0x0]
8000419a:	59 1c       	cp.w	r12,17

8000419c <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
8000419c:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000419e:	49 88       	lddpc	r8,800041fc <pdca_int_handler+0x60>
800041a0:	11 89       	ld.ub	r9,r8[0x0]
800041a2:	ec 19 00 01 	eorl	r9,0x1
800041a6:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
800041a8:	11 89       	ld.ub	r9,r8[0x0]
800041aa:	a5 69       	lsl	r9,0x4
800041ac:	2f c9       	sub	r9,-4
800041ae:	49 5a       	lddpc	r10,80004200 <pdca_int_handler+0x64>
800041b0:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
800041b2:	fe 7a 00 40 	mov	r10,-65472
800041b6:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800041b8:	30 39       	mov	r9,3
800041ba:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
800041bc:	11 8a       	ld.ub	r10,r8[0x0]
800041be:	a5 6a       	lsl	r10,0x4
800041c0:	2f ca       	sub	r10,-4
800041c2:	49 18       	lddpc	r8,80004204 <pdca_int_handler+0x68>
800041c4:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
800041c6:	fe 78 00 00 	mov	r8,-65536
800041ca:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800041cc:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
800041ce:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
800041d0:	48 e8       	lddpc	r8,80004208 <pdca_int_handler+0x6c>
800041d2:	70 08       	ld.w	r8,r8[0x0]
800041d4:	58 08       	cp.w	r8,0
800041d6:	c0 70       	breq	800041e4 <pdca_int_handler+0x48>
800041d8:	48 99       	lddpc	r9,800041fc <pdca_int_handler+0x60>
800041da:	13 89       	ld.ub	r9,r9[0x0]
800041dc:	a5 69       	lsl	r9,0x4
800041de:	48 ac       	lddpc	r12,80004204 <pdca_int_handler+0x68>
800041e0:	12 0c       	add	r12,r9
800041e2:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800041e4:	48 a8       	lddpc	r8,8000420c <pdca_int_handler+0x70>
800041e6:	70 08       	ld.w	r8,r8[0x0]
800041e8:	58 08       	cp.w	r8,0
800041ea:	c0 70       	breq	800041f8 <pdca_int_handler+0x5c>
800041ec:	48 49       	lddpc	r9,800041fc <pdca_int_handler+0x60>
800041ee:	13 89       	ld.ub	r9,r9[0x0]
800041f0:	a5 69       	lsl	r9,0x4
800041f2:	48 4c       	lddpc	r12,80004200 <pdca_int_handler+0x64>
800041f4:	12 0c       	add	r12,r9
800041f6:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800041f8:	d4 02       	popm	lr
800041fa:	d6 03       	rete
800041fc:	00 00       	add	r0,r0
800041fe:	40 d8       	lddsp	r8,sp[0x34]
80004200:	00 00       	add	r0,r0
80004202:	41 00       	lddsp	r0,sp[0x40]
80004204:	00 00       	add	r0,r0
80004206:	40 e0       	lddsp	r0,sp[0x38]
80004208:	00 00       	add	r0,r0
8000420a:	0a fc       	st.b	--r5,r12
8000420c:	00 00       	add	r0,r0
8000420e:	0b 00       	ld.w	r0,r5++

80004210 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004210:	fe 78 10 00 	mov	r8,-61440
80004214:	e0 69 0d c0 	mov	r9,3520
80004218:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
8000421c:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004220:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004224:	fe 78 34 00 	mov	r8,-52224
80004228:	e0 69 80 00 	mov	r9,32768
8000422c:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000422e:	30 09       	mov	r9,0
80004230:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004232:	e0 69 04 21 	mov	r9,1057
80004236:	ea 19 3f 20 	orh	r9,0x3f20
8000423a:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
8000423c:	e0 69 02 9f 	mov	r9,671
80004240:	ea 19 01 00 	orh	r9,0x100
80004244:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80004246:	e0 6a 04 02 	mov	r10,1026
8000424a:	ea 1a 3f 20 	orh	r10,0x3f20
8000424e:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004250:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004252:	5e fc       	retal	r12

80004254 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004254:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004256:	30 19       	mov	r9,1
80004258:	49 78       	lddpc	r8,800042b4 <local_start_PDC+0x60>
8000425a:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
8000425c:	fe 78 00 00 	mov	r8,-65536
80004260:	30 7b       	mov	r11,7
80004262:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004264:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80004266:	49 59       	lddpc	r9,800042b8 <local_start_PDC+0x64>
80004268:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
8000426c:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
8000426e:	30 3a       	mov	r10,3
80004270:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004272:	30 1c       	mov	r12,1
80004274:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004276:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004278:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000427a:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000427c:	30 2c       	mov	r12,2
8000427e:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004280:	48 f9       	lddpc	r9,800042bc <local_start_PDC+0x68>
80004282:	e0 68 5a 5a 	mov	r8,23130
80004286:	ea 18 ab cd 	orh	r8,0xabcd
8000428a:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
8000428c:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
8000428e:	30 0e       	mov	lr,0
80004290:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004292:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004294:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004296:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004298:	fe 78 00 40 	mov	r8,-65472
8000429c:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000429e:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
800042a0:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
800042a4:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
800042a6:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
800042a8:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
800042aa:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
800042ac:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
800042ae:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800042b0:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
800042b2:	d8 02       	popm	pc
800042b4:	00 00       	add	r0,r0
800042b6:	40 d8       	lddsp	r8,sp[0x34]
800042b8:	00 00       	add	r0,r0
800042ba:	40 e0       	lddsp	r0,sp[0x38]
800042bc:	00 00       	add	r0,r0
800042be:	41 00       	lddsp	r0,sp[0x40]

800042c0 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
800042c0:	48 38       	lddpc	r8,800042cc <register_rx_tx_func+0xc>
800042c2:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800042c4:	48 38       	lddpc	r8,800042d0 <register_rx_tx_func+0x10>
800042c6:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800042c8:	5e fc       	retal	r12
800042ca:	00 00       	add	r0,r0
800042cc:	00 00       	add	r0,r0
800042ce:	0a fc       	st.b	--r5,r12
800042d0:	00 00       	add	r0,r0
800042d2:	0b 00       	ld.w	r0,r5++

800042d4 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800042d4:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800042d6:	fe 78 10 00 	mov	r8,-61440
800042da:	30 29       	mov	r9,2
800042dc:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800042e0:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800042e4:	10 99       	mov	r9,r8
800042e6:	f2 f8 01 60 	ld.w	r8,r9[352]
800042ea:	e2 18 00 02 	andl	r8,0x2,COH
800042ee:	cf c0       	breq	800042e6 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800042f0:	fe 79 10 00 	mov	r9,-61440
800042f4:	f2 f8 01 60 	ld.w	r8,r9[352]
800042f8:	e2 18 00 02 	andl	r8,0x2,COH
800042fc:	cf c1       	brne	800042f4 <ssc_init+0x20>
				
    INTC_register_interrupt (
800042fe:	30 3a       	mov	r10,3
80004300:	36 0b       	mov	r11,96
80004302:	48 bc       	lddpc	r12,8000432c <ssc_init+0x58>
80004304:	f0 1f 00 0b 	mcall	80004330 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80004308:	f0 1f 00 0b 	mcall	80004334 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
8000430c:	f0 1f 00 0b 	mcall	80004338 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004310:	fe 79 00 00 	mov	r9,-65536
80004314:	30 18       	mov	r8,1
80004316:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004318:	fe 7a 00 40 	mov	r10,-65472
8000431c:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000431e:	e0 6b 01 01 	mov	r11,257
80004322:	fe 7a 34 00 	mov	r10,-52224
80004326:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004328:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
8000432a:	d8 02       	popm	pc
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	41 9c       	lddsp	r12,sp[0x64]
80004330:	80 00       	ld.sh	r0,r0[0x0]
80004332:	4d 70       	lddpc	r0,8000448c <xcmp_IdleTestTone+0x14>
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	42 10       	lddsp	r0,sp[0x84]
80004338:	80 00       	ld.sh	r0,r0[0x0]
8000433a:	42 54       	lddsp	r4,sp[0x94]

8000433c <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
8000433c:	48 28       	lddpc	r8,80004344 <xcmp_register_app_list+0x8>
8000433e:	91 0c       	st.w	r8[0x0],r12
}
80004340:	5e fc       	retal	r12
80004342:	00 00       	add	r0,r0
80004344:	00 00       	add	r0,r0
80004346:	41 20       	lddsp	r0,sp[0x48]

80004348 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004348:	eb cd 40 80 	pushm	r7,lr
8000434c:	fa cd 01 00 	sub	sp,sp,256
80004350:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004352:	16 98       	mov	r8,r11
80004354:	2f 08       	sub	r8,-16
80004356:	af a8       	sbr	r8,0xe
80004358:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
8000435a:	3f f8       	mov	r8,-1
8000435c:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000435e:	30 b9       	mov	r9,11
80004360:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004362:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004364:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004366:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004368:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
8000436a:	f6 ca ff fe 	sub	r10,r11,-2
8000436e:	18 9b       	mov	r11,r12
80004370:	fa cc ff f0 	sub	r12,sp,-16
80004374:	f0 1f 00 05 	mcall	80004388 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004378:	2f e7       	sub	r7,-2
8000437a:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
8000437c:	1a 9c       	mov	r12,sp
8000437e:	f0 1f 00 04 	mcall	8000438c <xcmp_tx+0x44>
}
80004382:	2c 0d       	sub	sp,-256
80004384:	e3 cd 80 80 	ldm	sp++,r7,pc
80004388:	80 00       	ld.sh	r0,r0[0x0]
8000438a:	70 04       	ld.w	r4,r8[0x0]
8000438c:	80 00       	ld.sh	r0,r0[0x0]
8000438e:	47 d4       	lddsp	r4,sp[0x1f4]

80004390 <xcmp_audio_route_mic>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_mic(void)
{
80004390:	d4 01       	pushm	lr
80004392:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80004396:	e0 68 04 14 	mov	r8,1044
8000439a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
8000439c:	fa c8 ff fc 	sub	r8,sp,-4
			
	ptr->Function = Routing_Func_Update_Source;
800043a0:	30 19       	mov	r9,1
800043a2:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
800043a4:	30 0a       	mov	r10,0
800043a6:	b0 9a       	st.b	r8[0x1],r10
	ptr->NumberofRoutings[1] = NumberofRoutings & 0xFF;
800043a8:	30 2a       	mov	r10,2
800043aa:	b0 aa       	st.b	r8[0x2],r10
	
	ptr->RoutingData[0].audioInput = IN_Microphone;
800043ac:	b0 b9       	st.b	r8[0x3],r9
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;
800043ae:	30 c9       	mov	r9,12
800043b0:	b0 c9       	st.b	r8[0x4],r9
	
	ptr->RoutingData[1].audioInput = IN_Option_Board;
800043b2:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;
800043b4:	30 d9       	mov	r9,13
800043b6:	b0 e9       	st.b	r8[0x6],r9
		//
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
800043b8:	30 7b       	mov	r11,7
800043ba:	fa cc ff fe 	sub	r12,sp,-2
800043be:	f0 1f 00 03 	mcall	800043c8 <xcmp_audio_route_mic+0x38>
}
800043c2:	2c dd       	sub	sp,-204
800043c4:	d8 02       	popm	pc
800043c6:	00 00       	add	r0,r0
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	43 48       	lddsp	r8,sp[0xd0]

800043cc <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800043cc:	d4 01       	pushm	lr
800043ce:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800043d2:	fe 78 b4 00 	mov	r8,-19456
800043d6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800043d8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800043dc:	30 89       	mov	r9,8
800043de:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800043e0:	30 19       	mov	r9,1
800043e2:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800043e4:	30 09       	mov	r9,0
800043e6:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800043e8:	30 5a       	mov	r10,5
800043ea:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800043ec:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800043ee:	30 7a       	mov	r10,7
800043f0:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800043f2:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800043f4:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800043f6:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800043fa:	30 9b       	mov	r11,9
800043fc:	fa cc ff fe 	sub	r12,sp,-2
80004400:	f0 1f 00 02 	mcall	80004408 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004404:	2c dd       	sub	sp,-204
80004406:	d8 02       	popm	pc
80004408:	80 00       	ld.sh	r0,r0[0x0]
8000440a:	43 48       	lddsp	r8,sp[0xd0]

8000440c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000440c:	d4 01       	pushm	lr
8000440e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004412:	fe 78 80 00 	mov	r8,-32768
80004416:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004418:	30 38       	mov	r8,3
8000441a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000441c:	30 1b       	mov	r11,1
8000441e:	fa cc ff fe 	sub	r12,sp,-2
80004422:	f0 1f 00 03 	mcall	8000442c <xcmp_opcode_not_supported+0x20>
}
80004426:	2c dd       	sub	sp,-204
80004428:	d8 02       	popm	pc
8000442a:	00 00       	add	r0,r0
8000442c:	80 00       	ld.sh	r0,r0[0x0]
8000442e:	43 48       	lddsp	r8,sp[0xd0]

80004430 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004430:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004432:	96 88       	ld.uh	r8,r11[0x0]
80004434:	e2 18 f0 00 	andl	r8,0xf000,COH
80004438:	e0 48 80 00 	cp.w	r8,32768
8000443c:	c0 f0       	breq	8000445a <xcmp_exec_func+0x2a>
8000443e:	e0 48 b0 00 	cp.w	r8,45056
80004442:	c1 20       	breq	80004466 <xcmp_exec_func+0x36>
80004444:	58 08       	cp.w	r8,0
80004446:	c1 51       	brne	80004470 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004448:	78 08       	ld.w	r8,r12[0x0]
8000444a:	58 08       	cp.w	r8,0
8000444c:	c0 40       	breq	80004454 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000444e:	16 9c       	mov	r12,r11
80004450:	5d 18       	icall	r8
80004452:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004454:	f0 1f 00 08 	mcall	80004474 <xcmp_exec_func+0x44>
80004458:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000445a:	78 18       	ld.w	r8,r12[0x4]
8000445c:	58 08       	cp.w	r8,0
8000445e:	c0 90       	breq	80004470 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004460:	16 9c       	mov	r12,r11
80004462:	5d 18       	icall	r8
80004464:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004466:	78 28       	ld.w	r8,r12[0x8]
80004468:	58 08       	cp.w	r8,0
8000446a:	c0 30       	breq	80004470 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000446c:	16 9c       	mov	r12,r11
8000446e:	5d 18       	icall	r8
80004470:	d8 02       	popm	pc
80004472:	00 00       	add	r0,r0
80004474:	80 00       	ld.sh	r0,r0[0x0]
80004476:	44 0c       	lddsp	r12,sp[0x100]

80004478 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004478:	d4 01       	pushm	lr
8000447a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000447e:	e0 68 04 09 	mov	r8,1033
80004482:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004484:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004488:	30 19       	mov	r9,1
8000448a:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
8000448c:	30 09       	mov	r9,0
8000448e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80004490:	30 ca       	mov	r10,12
80004492:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004494:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004496:	fb 69 00 08 	st.b	sp[8],r9
8000449a:	fa c8 ff f7 	sub	r8,sp,-9
8000449e:	b0 89       	st.b	r8[0x0],r9
800044a0:	fa c8 ff f6 	sub	r8,sp,-10
800044a4:	b0 89       	st.b	r8[0x0],r9
800044a6:	fa c8 ff f5 	sub	r8,sp,-11
800044aa:	b0 89       	st.b	r8[0x0],r9
800044ac:	fa c8 ff f4 	sub	r8,sp,-12
800044b0:	b0 89       	st.b	r8[0x0],r9
800044b2:	fa c8 ff f3 	sub	r8,sp,-13
800044b6:	b0 89       	st.b	r8[0x0],r9
800044b8:	fa c8 ff f2 	sub	r8,sp,-14
800044bc:	b0 89       	st.b	r8[0x0],r9
800044be:	fa c8 ff f1 	sub	r8,sp,-15
800044c2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800044c4:	30 cb       	mov	r11,12
800044c6:	fa cc ff fe 	sub	r12,sp,-2
800044ca:	f0 1f 00 03 	mcall	800044d4 <xcmp_IdleTestTone+0x5c>
}
800044ce:	2c dd       	sub	sp,-204
800044d0:	d8 02       	popm	pc
800044d2:	00 00       	add	r0,r0
800044d4:	80 00       	ld.sh	r0,r0[0x0]
800044d6:	43 48       	lddsp	r8,sp[0xd0]

800044d8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800044d8:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
800044da:	f0 1f 00 0d 	mcall	8000450c <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800044de:	48 dc       	lddpc	r12,80004510 <xcmp_init+0x38>
800044e0:	f0 1f 00 0d 	mcall	80004514 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800044e4:	30 4b       	mov	r11,4
800044e6:	31 4c       	mov	r12,20
800044e8:	f0 1f 00 0c 	mcall	80004518 <xcmp_init+0x40>
800044ec:	48 c8       	lddpc	r8,8000451c <xcmp_init+0x44>
800044ee:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800044f0:	30 09       	mov	r9,0
800044f2:	1a d9       	st.w	--sp,r9
800044f4:	1a d9       	st.w	--sp,r9
800044f6:	1a d9       	st.w	--sp,r9
800044f8:	30 38       	mov	r8,3
800044fa:	e0 6a 01 80 	mov	r10,384
800044fe:	48 9b       	lddpc	r11,80004520 <xcmp_init+0x48>
80004500:	48 9c       	lddpc	r12,80004524 <xcmp_init+0x4c>
80004502:	f0 1f 00 0a 	mcall	80004528 <xcmp_init+0x50>
80004506:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80004508:	d8 02       	popm	pc
8000450a:	00 00       	add	r0,r0
8000450c:	80 00       	ld.sh	r0,r0[0x0]
8000450e:	48 b8       	lddpc	r8,80004538 <xcmp_rx_process+0xc>
80004510:	80 00       	ld.sh	r0,r0[0x0]
80004512:	46 28       	lddsp	r8,sp[0x188]
80004514:	80 00       	ld.sh	r0,r0[0x0]
80004516:	46 74       	lddsp	r4,sp[0x19c]
80004518:	80 00       	ld.sh	r0,r0[0x0]
8000451a:	5c 0c       	acr	r12
8000451c:	00 00       	add	r0,r0
8000451e:	0b 10       	ld.sh	r0,r5++
80004520:	80 01       	ld.sh	r1,r0[0x0]
80004522:	59 48       	cp.w	r8,20
80004524:	80 00       	ld.sh	r0,r0[0x0]
80004526:	45 2c       	lddsp	r12,sp[0x148]
80004528:	80 00       	ld.sh	r0,r0[0x0]
8000452a:	62 e0       	ld.w	r0,r1[0x38]

8000452c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000452c:	d4 31       	pushm	r0-r7,lr
8000452e:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004530:	4b 16       	lddpc	r6,800045f4 <xcmp_rx_process+0xc8>
80004532:	30 05       	mov	r5,0
80004534:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004536:	4b 13       	lddpc	r3,800045f8 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004538:	4b 12       	lddpc	r2,800045fc <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000453a:	4b 21       	lddpc	r1,80004600 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000453c:	4b 20       	lddpc	r0,80004604 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000453e:	6c 0c       	ld.w	r12,r6[0x0]
80004540:	0a 99       	mov	r9,r5
80004542:	08 9a       	mov	r10,r4
80004544:	1a 9b       	mov	r11,sp
80004546:	f0 1f 00 31 	mcall	80004608 <xcmp_rx_process+0xdc>
8000454a:	58 1c       	cp.w	r12,1
8000454c:	cf 91       	brne	8000453e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000454e:	40 0b       	lddsp	r11,sp[0x0]
80004550:	58 0b       	cp.w	r11,0
80004552:	cf 60       	breq	8000453e <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004554:	96 0a       	ld.sh	r10,r11[0x0]
80004556:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000455a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000455e:	59 c8       	cp.w	r8,28
80004560:	c1 e0       	breq	8000459c <xcmp_rx_process+0x70>
80004562:	e0 89 00 07 	brgt	80004570 <xcmp_rx_process+0x44>
80004566:	58 e8       	cp.w	r8,14
80004568:	c0 e0       	breq	80004584 <xcmp_rx_process+0x58>
8000456a:	58 f8       	cp.w	r8,15
8000456c:	c2 41       	brne	800045b4 <xcmp_rx_process+0x88>
8000456e:	c0 f8       	rjmp	8000458c <xcmp_rx_process+0x60>
80004570:	e0 48 01 09 	cp.w	r8,265
80004574:	c1 80       	breq	800045a4 <xcmp_rx_process+0x78>
80004576:	e0 48 01 0a 	cp.w	r8,266
8000457a:	c1 90       	breq	800045ac <xcmp_rx_process+0x80>
8000457c:	e0 48 00 2c 	cp.w	r8,44
80004580:	c1 a1       	brne	800045b4 <xcmp_rx_process+0x88>
80004582:	c0 98       	rjmp	80004594 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004584:	4a 2c       	lddpc	r12,8000460c <xcmp_rx_process+0xe0>
80004586:	f0 1f 00 23 	mcall	80004610 <xcmp_rx_process+0xe4>
					break;
8000458a:	c2 f8       	rjmp	800045e8 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000458c:	4a 2c       	lddpc	r12,80004614 <xcmp_rx_process+0xe8>
8000458e:	f0 1f 00 21 	mcall	80004610 <xcmp_rx_process+0xe4>
					break;
80004592:	c2 b8       	rjmp	800045e8 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004594:	4a 1c       	lddpc	r12,80004618 <xcmp_rx_process+0xec>
80004596:	f0 1f 00 1f 	mcall	80004610 <xcmp_rx_process+0xe4>
					break;
8000459a:	c2 78       	rjmp	800045e8 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
8000459c:	04 9c       	mov	r12,r2
8000459e:	f0 1f 00 1d 	mcall	80004610 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800045a2:	c2 38       	rjmp	800045e8 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800045a4:	02 9c       	mov	r12,r1
800045a6:	f0 1f 00 1b 	mcall	80004610 <xcmp_rx_process+0xe4>
					break;
800045aa:	c1 f8       	rjmp	800045e8 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800045ac:	00 9c       	mov	r12,r0
800045ae:	f0 1f 00 19 	mcall	80004610 <xcmp_rx_process+0xe4>
					break;
800045b2:	c1 b8       	rjmp	800045e8 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800045b4:	12 98       	mov	r8,r9
800045b6:	e2 18 04 00 	andl	r8,0x400,COH
800045ba:	c0 70       	breq	800045c8 <xcmp_rx_process+0x9c>
800045bc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800045c0:	e0 48 00 68 	cp.w	r8,104
800045c4:	e0 8a 00 08 	brle	800045d4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800045c8:	e2 19 f0 00 	andl	r9,0xf000,COH
800045cc:	c0 e1       	brne	800045e8 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800045ce:	f0 1f 00 14 	mcall	8000461c <xcmp_rx_process+0xf0>
800045d2:	c0 b8       	rjmp	800045e8 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800045d4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800045d8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800045dc:	49 19       	lddpc	r9,80004620 <xcmp_rx_process+0xf4>
800045de:	72 08       	ld.w	r8,r9[0x0]
800045e0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800045e4:	f0 1f 00 0b 	mcall	80004610 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800045e8:	66 0c       	ld.w	r12,r3[0x0]
800045ea:	40 0b       	lddsp	r11,sp[0x0]
800045ec:	f0 1f 00 0e 	mcall	80004624 <xcmp_rx_process+0xf8>
800045f0:	ca 7b       	rjmp	8000453e <xcmp_rx_process+0x12>
800045f2:	00 00       	add	r0,r0
800045f4:	00 00       	add	r0,r0
800045f6:	0b 10       	ld.sh	r0,r5++
800045f8:	00 00       	add	r0,r0
800045fa:	0a 98       	mov	r8,r5
800045fc:	00 00       	add	r0,r0
800045fe:	0b 20       	ld.uh	r0,r5++
80004600:	00 00       	add	r0,r0
80004602:	0b 14       	ld.sh	r4,r5++
80004604:	00 00       	add	r0,r0
80004606:	0b 2c       	ld.uh	r12,r5++
80004608:	80 00       	ld.sh	r0,r0[0x0]
8000460a:	58 a8       	cp.w	r8,10
8000460c:	00 00       	add	r0,r0
8000460e:	0b 44       	ld.w	r4,--r5
80004610:	80 00       	ld.sh	r0,r0[0x0]
80004612:	44 30       	lddsp	r0,sp[0x10c]
80004614:	00 00       	add	r0,r0
80004616:	0b 04       	ld.w	r4,r5++
80004618:	00 00       	add	r0,r0
8000461a:	0b 38       	ld.ub	r8,r5++
8000461c:	80 00       	ld.sh	r0,r0[0x0]
8000461e:	44 0c       	lddsp	r12,sp[0x100]
80004620:	00 00       	add	r0,r0
80004622:	41 20       	lddsp	r0,sp[0x48]
80004624:	80 00       	ld.sh	r0,r0[0x0]
80004626:	29 ac       	sub	r12,-102

80004628 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004628:	eb cd 40 90 	pushm	r4,r7,lr
8000462c:	20 1d       	sub	sp,4
8000462e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004632:	48 c8       	lddpc	r8,80004660 <xcmp_rx+0x38>
80004634:	70 0c       	ld.w	r12,r8[0x0]
80004636:	f0 1f 00 0c 	mcall	80004664 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000463a:	c1 00       	breq	8000465a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000463c:	fa c7 ff fc 	sub	r7,sp,-4
80004640:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004642:	e0 6a 00 ca 	mov	r10,202
80004646:	08 9b       	mov	r11,r4
80004648:	f0 1f 00 08 	mcall	80004668 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000464c:	48 88       	lddpc	r8,8000466c <xcmp_rx+0x44>
8000464e:	70 0c       	ld.w	r12,r8[0x0]
80004650:	30 09       	mov	r9,0
80004652:	12 9a       	mov	r10,r9
80004654:	1a 9b       	mov	r11,sp
80004656:	f0 1f 00 07 	mcall	80004670 <xcmp_rx+0x48>
	}	
}
8000465a:	2f fd       	sub	sp,-4
8000465c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004660:	00 00       	add	r0,r0
80004662:	0a 98       	mov	r8,r5
80004664:	80 00       	ld.sh	r0,r0[0x0]
80004666:	31 c8       	mov	r8,28
80004668:	80 00       	ld.sh	r0,r0[0x0]
8000466a:	70 04       	ld.w	r4,r8[0x0]
8000466c:	00 00       	add	r0,r0
8000466e:	0b 10       	ld.sh	r0,r5++
80004670:	80 00       	ld.sh	r0,r0[0x0]
80004672:	5a b4       	cp.w	r4,-21

80004674 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004674:	48 28       	lddpc	r8,8000467c <xnl_register_xcmp_func+0x8>
80004676:	91 0c       	st.w	r8[0x0],r12
}
80004678:	5e fc       	retal	r12
8000467a:	00 00       	add	r0,r0
8000467c:	00 00       	add	r0,r0
8000467e:	0b 74       	ld.ub	r4,--r5

80004680 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004680:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004682:	48 88       	lddpc	r8,800046a0 <xnl_get_msg_ack_func+0x20>
80004684:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004686:	98 49       	ld.sh	r9,r12[0x8]
80004688:	f0 09 19 00 	cp.h	r9,r8
8000468c:	c0 81       	brne	8000469c <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000468e:	48 68       	lddpc	r8,800046a4 <xnl_get_msg_ack_func+0x24>
80004690:	70 0c       	ld.w	r12,r8[0x0]
80004692:	30 09       	mov	r9,0
80004694:	12 9a       	mov	r10,r9
80004696:	12 9b       	mov	r11,r9
80004698:	f0 1f 00 04 	mcall	800046a8 <xnl_get_msg_ack_func+0x28>
8000469c:	d8 02       	popm	pc
8000469e:	00 00       	add	r0,r0
800046a0:	00 00       	add	r0,r0
800046a2:	0b 54       	ld.sh	r4,--r5
800046a4:	00 00       	add	r0,r0
800046a6:	0b 50       	ld.sh	r0,--r5
800046a8:	80 00       	ld.sh	r0,r0[0x0]
800046aa:	5a b4       	cp.w	r4,-21

800046ac <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800046ac:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800046ae:	4a 86       	lddpc	r6,8000474c <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800046b0:	4a 82       	lddpc	r2,80004750 <xnl_tx_process+0xa4>
800046b2:	4a 94       	lddpc	r4,80004754 <xnl_tx_process+0xa8>
800046b4:	30 07       	mov	r7,0
800046b6:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800046b8:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800046ba:	4a 85       	lddpc	r5,80004758 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800046bc:	4a 83       	lddpc	r3,8000475c <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800046be:	6c 08       	ld.w	r8,r6[0x0]
800046c0:	58 08       	cp.w	r8,0
800046c2:	c0 40       	breq	800046ca <xnl_tx_process+0x1e>
800046c4:	58 18       	cp.w	r8,1
800046c6:	cf d1       	brne	800046c0 <xnl_tx_process+0x14>
800046c8:	c2 08       	rjmp	80004708 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800046ca:	64 0c       	ld.w	r12,r2[0x0]
800046cc:	0e 99       	mov	r9,r7
800046ce:	02 9a       	mov	r10,r1
800046d0:	08 9b       	mov	r11,r4
800046d2:	f0 1f 00 24 	mcall	80004760 <xnl_tx_process+0xb4>
800046d6:	58 1c       	cp.w	r12,1
800046d8:	cf 31       	brne	800046be <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800046da:	68 0c       	ld.w	r12,r4[0x0]
800046dc:	58 0c       	cp.w	r12,0
800046de:	cf 00       	breq	800046be <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800046e0:	98 28       	ld.sh	r8,r12[0x4]
800046e2:	e0 08 19 00 	cp.h	r8,r0
800046e6:	c0 41       	brne	800046ee <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800046e8:	f0 1f 00 1f 	mcall	80004764 <xnl_tx_process+0xb8>
						break;
800046ec:	ce 9b       	rjmp	800046be <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800046ee:	f0 1f 00 1f 	mcall	80004768 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800046f2:	30 18       	mov	r8,1
800046f4:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800046f6:	66 0c       	ld.w	r12,r3[0x0]
800046f8:	0e 99       	mov	r9,r7
800046fa:	0e 9a       	mov	r10,r7
800046fc:	0e 9b       	mov	r11,r7
800046fe:	f0 1f 00 19 	mcall	80004760 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
80004702:	30 18       	mov	r8,1
80004704:	8d 08       	st.w	r6[0x0],r8
80004706:	cd cb       	rjmp	800046be <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80004708:	66 0c       	ld.w	r12,r3[0x0]
8000470a:	0e 99       	mov	r9,r7
8000470c:	36 4a       	mov	r10,100
8000470e:	0e 9b       	mov	r11,r7
80004710:	f0 1f 00 14 	mcall	80004760 <xnl_tx_process+0xb4>
80004714:	58 1c       	cp.w	r12,1
80004716:	c0 81       	brne	80004726 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80004718:	49 58       	lddpc	r8,8000476c <xnl_tx_process+0xc0>
8000471a:	70 0c       	ld.w	r12,r8[0x0]
8000471c:	68 0b       	ld.w	r11,r4[0x0]
8000471e:	f0 1f 00 15 	mcall	80004770 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80004722:	8d 07       	st.w	r6[0x0],r7
80004724:	cc db       	rjmp	800046be <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004726:	6a 08       	ld.w	r8,r5[0x0]
80004728:	58 38       	cp.w	r8,3
8000472a:	e0 89 00 09 	brgt	8000473c <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000472e:	68 0c       	ld.w	r12,r4[0x0]
80004730:	f0 1f 00 0e 	mcall	80004768 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004734:	6a 08       	ld.w	r8,r5[0x0]
80004736:	2f f8       	sub	r8,-1
80004738:	8b 08       	st.w	r5[0x0],r8
8000473a:	cc 2b       	rjmp	800046be <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
8000473c:	48 c8       	lddpc	r8,8000476c <xnl_tx_process+0xc0>
8000473e:	70 0c       	ld.w	r12,r8[0x0]
80004740:	68 0b       	ld.w	r11,r4[0x0]
80004742:	f0 1f 00 0c 	mcall	80004770 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004746:	8d 07       	st.w	r6[0x0],r7
80004748:	cb bb       	rjmp	800046be <xnl_tx_process+0x12>
8000474a:	00 00       	add	r0,r0
8000474c:	00 00       	add	r0,r0
8000474e:	0b 70       	ld.ub	r0,--r5
80004750:	00 00       	add	r0,r0
80004752:	0b 64       	ld.uh	r4,--r5
80004754:	00 00       	add	r0,r0
80004756:	0b 68       	ld.uh	r8,--r5
80004758:	00 00       	add	r0,r0
8000475a:	0b 60       	ld.uh	r0,--r5
8000475c:	00 00       	add	r0,r0
8000475e:	0b 50       	ld.sh	r0,--r5
80004760:	80 00       	ld.sh	r0,r0[0x0]
80004762:	58 a8       	cp.w	r8,10
80004764:	80 00       	ld.sh	r0,r0[0x0]
80004766:	57 38       	stdsp	sp[0x1cc],r8
80004768:	80 00       	ld.sh	r0,r0[0x0]
8000476a:	29 cc       	sub	r12,-100
8000476c:	00 00       	add	r0,r0
8000476e:	0a 98       	mov	r8,r5
80004770:	80 00       	ld.sh	r0,r0[0x0]
80004772:	29 ac       	sub	r12,-102

80004774 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004774:	eb cd 40 fe 	pushm	r1-r7,lr
80004778:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000477a:	49 26       	lddpc	r6,800047c0 <xnl_rx_process+0x4c>
8000477c:	30 05       	mov	r5,0
8000477e:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004780:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004782:	49 11       	lddpc	r1,800047c4 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004784:	49 12       	lddpc	r2,800047c8 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004786:	6c 0c       	ld.w	r12,r6[0x0]
80004788:	0a 99       	mov	r9,r5
8000478a:	08 9a       	mov	r10,r4
8000478c:	1a 9b       	mov	r11,sp
8000478e:	f0 1f 00 10 	mcall	800047cc <xnl_rx_process+0x58>
80004792:	58 1c       	cp.w	r12,1
80004794:	cf 91       	brne	80004786 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004796:	40 0c       	lddsp	r12,sp[0x0]
80004798:	58 0c       	cp.w	r12,0
8000479a:	cf 60       	breq	80004786 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000479c:	98 28       	ld.sh	r8,r12[0x4]
8000479e:	e6 08 19 00 	cp.h	r8,r3
800047a2:	e0 8b 00 0a 	brhi	800047b6 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800047a6:	5c 78       	castu.h	r8
800047a8:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800047ac:	58 09       	cp.w	r9,0
800047ae:	c0 40       	breq	800047b6 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800047b0:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800047b4:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800047b6:	62 0c       	ld.w	r12,r1[0x0]
800047b8:	40 0b       	lddsp	r11,sp[0x0]
800047ba:	f0 1f 00 06 	mcall	800047d0 <xnl_rx_process+0x5c>
800047be:	ce 4b       	rjmp	80004786 <xnl_rx_process+0x12>
800047c0:	00 00       	add	r0,r0
800047c2:	0a d4       	st.w	--r5,r4
800047c4:	00 00       	add	r0,r0
800047c6:	0a 98       	mov	r8,r5
800047c8:	00 00       	add	r0,r0
800047ca:	04 f4       	st.b	--r2,r4
800047cc:	80 00       	ld.sh	r0,r0[0x0]
800047ce:	58 a8       	cp.w	r8,10
800047d0:	80 00       	ld.sh	r0,r0[0x0]
800047d2:	29 ac       	sub	r12,-102

800047d4 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800047d4:	eb cd 40 c0 	pushm	r6-r7,lr
800047d8:	20 1d       	sub	sp,4
800047da:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800047dc:	98 39       	ld.sh	r9,r12[0x6]
800047de:	3f f8       	mov	r8,-1
800047e0:	f0 09 19 00 	cp.h	r9,r8
800047e4:	c0 a1       	brne	800047f8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800047e6:	4a e9       	lddpc	r9,8000489c <xnl_tx+0xc8>
800047e8:	13 88       	ld.ub	r8,r9[0x0]
800047ea:	2f f8       	sub	r8,-1
800047ec:	5c 58       	castu.b	r8
800047ee:	b2 88       	st.b	r9[0x0],r8
800047f0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800047f4:	a9 a8       	sbr	r8,0x8
800047f6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800047f8:	8c 49       	ld.sh	r9,r6[0x8]
800047fa:	3f f8       	mov	r8,-1
800047fc:	f0 09 19 00 	cp.h	r9,r8
80004800:	c0 41       	brne	80004808 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004802:	4a 88       	lddpc	r8,800048a0 <xnl_tx+0xcc>
80004804:	90 18       	ld.sh	r8,r8[0x2]
80004806:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004808:	8c 59       	ld.sh	r9,r6[0xa]
8000480a:	3f f8       	mov	r8,-1
8000480c:	f0 09 19 00 	cp.h	r9,r8
80004810:	c0 41       	brne	80004818 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004812:	4a 48       	lddpc	r8,800048a0 <xnl_tx+0xcc>
80004814:	90 28       	ld.sh	r8,r8[0x4]
80004816:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004818:	8c 69       	ld.sh	r9,r6[0xc]
8000481a:	3f f8       	mov	r8,-1
8000481c:	f0 09 19 00 	cp.h	r9,r8
80004820:	c0 e1       	brne	8000483c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004822:	4a 08       	lddpc	r8,800048a0 <xnl_tx+0xcc>
80004824:	90 49       	ld.sh	r9,r8[0x8]
80004826:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004828:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000482a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000482c:	90 49       	ld.sh	r9,r8[0x8]
8000482e:	e0 19 ff 00 	andl	r9,0xff00
80004832:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004836:	f3 e8 10 08 	or	r8,r9,r8
8000483a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000483c:	0d 98       	ld.ub	r8,r6[0x1]
8000483e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004840:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004844:	10 0c       	add	r12,r8
80004846:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004848:	58 0c       	cp.w	r12,0
8000484a:	e0 89 00 04 	brgt	80004852 <xnl_tx+0x7e>
8000484e:	30 09       	mov	r9,0
80004850:	c0 d8       	rjmp	8000486a <xnl_tx+0x96>
80004852:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004856:	2f ec       	sub	r12,-2
80004858:	30 09       	mov	r9,0
8000485a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000485c:	15 1b       	ld.sh	r11,r10++
8000485e:	f6 09 00 09 	add	r9,r11,r9
80004862:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004864:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004866:	18 38       	cp.w	r8,r12
80004868:	cf a1       	brne	8000485c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000486a:	5c 39       	neg	r9
8000486c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000486e:	48 e8       	lddpc	r8,800048a4 <xnl_tx+0xd0>
80004870:	70 0c       	ld.w	r12,r8[0x0]
80004872:	f0 1f 00 0e 	mcall	800048a8 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004876:	c1 00       	breq	80004896 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004878:	fa c7 ff fc 	sub	r7,sp,-4
8000487c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000487e:	e0 6a 01 00 	mov	r10,256
80004882:	0c 9b       	mov	r11,r6
80004884:	f0 1f 00 0a 	mcall	800048ac <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004888:	48 a8       	lddpc	r8,800048b0 <xnl_tx+0xdc>
8000488a:	70 0c       	ld.w	r12,r8[0x0]
8000488c:	30 09       	mov	r9,0
8000488e:	12 9a       	mov	r10,r9
80004890:	1a 9b       	mov	r11,sp
80004892:	f0 1f 00 09 	mcall	800048b4 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004896:	2f fd       	sub	sp,-4
80004898:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000489c:	00 00       	add	r0,r0
8000489e:	0b 6c       	ld.uh	r12,--r5
800048a0:	00 00       	add	r0,r0
800048a2:	0b 54       	ld.sh	r4,--r5
800048a4:	00 00       	add	r0,r0
800048a6:	0a 98       	mov	r8,r5
800048a8:	80 00       	ld.sh	r0,r0[0x0]
800048aa:	31 c8       	mov	r8,28
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	70 04       	ld.w	r4,r8[0x0]
800048b0:	00 00       	add	r0,r0
800048b2:	0b 64       	ld.uh	r4,--r5
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	5a b4       	cp.w	r4,-21

800048b8 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800048b8:	eb cd 40 80 	pushm	r7,lr
800048bc:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
800048c0:	f0 1f 00 27 	mcall	8000495c <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
800048c4:	30 09       	mov	r9,0
800048c6:	4a 78       	lddpc	r8,80004960 <xnl_init+0xa8>
800048c8:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800048ca:	30 0b       	mov	r11,0
800048cc:	30 1c       	mov	r12,1
800048ce:	f0 1f 00 26 	mcall	80004964 <xnl_init+0xac>
800048d2:	4a 68       	lddpc	r8,80004968 <xnl_init+0xb0>
800048d4:	91 0c       	st.w	r8[0x0],r12
800048d6:	70 08       	ld.w	r8,r8[0x0]
800048d8:	58 08       	cp.w	r8,0
800048da:	c0 80       	breq	800048ea <xnl_init+0x32>
800048dc:	4a 38       	lddpc	r8,80004968 <xnl_init+0xb0>
800048de:	70 0c       	ld.w	r12,r8[0x0]
800048e0:	30 09       	mov	r9,0
800048e2:	12 9a       	mov	r10,r9
800048e4:	12 9b       	mov	r11,r9
800048e6:	f0 1f 00 22 	mcall	8000496c <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800048ea:	30 4b       	mov	r11,4
800048ec:	31 4c       	mov	r12,20
800048ee:	f0 1f 00 1e 	mcall	80004964 <xnl_init+0xac>
800048f2:	4a 08       	lddpc	r8,80004970 <xnl_init+0xb8>
800048f4:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800048f6:	30 07       	mov	r7,0
800048f8:	1a d7       	st.w	--sp,r7
800048fa:	1a d7       	st.w	--sp,r7
800048fc:	1a d7       	st.w	--sp,r7
800048fe:	30 38       	mov	r8,3
80004900:	0e 99       	mov	r9,r7
80004902:	e0 6a 02 00 	mov	r10,512
80004906:	49 cb       	lddpc	r11,80004974 <xnl_init+0xbc>
80004908:	49 cc       	lddpc	r12,80004978 <xnl_init+0xc0>
8000490a:	f0 1f 00 1d 	mcall	8000497c <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000490e:	1a d7       	st.w	--sp,r7
80004910:	1a d7       	st.w	--sp,r7
80004912:	1a d7       	st.w	--sp,r7
80004914:	30 38       	mov	r8,3
80004916:	0e 99       	mov	r9,r7
80004918:	e0 6a 03 20 	mov	r10,800
8000491c:	49 9b       	lddpc	r11,80004980 <xnl_init+0xc8>
8000491e:	49 ac       	lddpc	r12,80004984 <xnl_init+0xcc>
80004920:	f0 1f 00 17 	mcall	8000497c <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004924:	e0 68 40 0e 	mov	r8,16398
80004928:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000492c:	3f f8       	mov	r8,-1
8000492e:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004932:	30 38       	mov	r8,3
80004934:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004938:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000493c:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004940:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004944:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004948:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000494c:	fa cc ff e8 	sub	r12,sp,-24
80004950:	f0 1f 00 0e 	mcall	80004988 <xnl_init+0xd0>
80004954:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80004956:	2c 0d       	sub	sp,-256
80004958:	e3 cd 80 80 	ldm	sp++,r7,pc
8000495c:	80 00       	ld.sh	r0,r0[0x0]
8000495e:	31 f0       	mov	r0,31
80004960:	00 00       	add	r0,r0
80004962:	0b 54       	ld.sh	r4,--r5
80004964:	80 00       	ld.sh	r0,r0[0x0]
80004966:	5c 0c       	acr	r12
80004968:	00 00       	add	r0,r0
8000496a:	0b 50       	ld.sh	r0,--r5
8000496c:	80 00       	ld.sh	r0,r0[0x0]
8000496e:	5a b4       	cp.w	r4,-21
80004970:	00 00       	add	r0,r0
80004972:	0b 64       	ld.uh	r4,--r5
80004974:	80 01       	ld.sh	r1,r0[0x0]
80004976:	59 50       	cp.w	r0,21
80004978:	80 00       	ld.sh	r0,r0[0x0]
8000497a:	47 74       	lddsp	r4,sp[0x1dc]
8000497c:	80 00       	ld.sh	r0,r0[0x0]
8000497e:	62 e0       	ld.w	r0,r1[0x38]
80004980:	80 00       	ld.sh	r0,r0[0x0]
80004982:	c8 00       	breq	80004882 <xnl_tx+0xae>
80004984:	80 00       	ld.sh	r0,r0[0x0]
80004986:	46 ac       	lddsp	r12,sp[0x1a8]
80004988:	80 00       	ld.sh	r0,r0[0x0]
8000498a:	47 d4       	lddsp	r4,sp[0x1f4]

8000498c <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
8000498c:	eb cd 40 80 	pushm	r7,lr
80004990:	fa cd 01 00 	sub	sp,sp,256
80004994:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004996:	e0 68 40 0e 	mov	r8,16398
8000499a:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000499c:	3f f8       	mov	r8,-1
8000499e:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800049a0:	30 c8       	mov	r8,12
800049a2:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800049a4:	98 38       	ld.sh	r8,r12[0x6]
800049a6:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800049a8:	98 58       	ld.sh	r8,r12[0xa]
800049aa:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800049ac:	98 48       	ld.sh	r8,r12[0x8]
800049ae:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800049b0:	98 68       	ld.sh	r8,r12[0xc]
800049b2:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800049b4:	30 08       	mov	r8,0
800049b6:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800049b8:	1a 9c       	mov	r12,sp
800049ba:	f0 1f 00 0a 	mcall	800049e0 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800049be:	fa cd 00 cc 	sub	sp,sp,204
800049c2:	e0 6a 00 ca 	mov	r10,202
800049c6:	ee cb ff f0 	sub	r11,r7,-16
800049ca:	1a 9c       	mov	r12,sp
800049cc:	f0 1f 00 06 	mcall	800049e4 <xnl_data_msg_func+0x58>
800049d0:	48 68       	lddpc	r8,800049e8 <xnl_data_msg_func+0x5c>
800049d2:	70 08       	ld.w	r8,r8[0x0]
800049d4:	5d 18       	icall	r8
800049d6:	fa cd ff 34 	sub	sp,sp,-204
}
800049da:	2c 0d       	sub	sp,-256
800049dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800049e0:	80 00       	ld.sh	r0,r0[0x0]
800049e2:	47 d4       	lddsp	r4,sp[0x1f4]
800049e4:	80 00       	ld.sh	r0,r0[0x0]
800049e6:	70 04       	ld.w	r4,r8[0x0]
800049e8:	00 00       	add	r0,r0
800049ea:	0b 74       	ld.ub	r4,--r5

800049ec <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800049ec:	d4 21       	pushm	r4-r7,lr
800049ee:	fa cd 01 00 	sub	sp,sp,256
800049f2:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800049f4:	4c 28       	lddpc	r8,80004afc <xnl_device_auth_reply_func+0x110>
800049f6:	11 88       	ld.ub	r8,r8[0x0]
800049f8:	58 08       	cp.w	r8,0
800049fa:	e0 81 00 7f 	brne	80004af8 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800049fe:	4c 18       	lddpc	r8,80004b00 <xnl_device_auth_reply_func+0x114>
80004a00:	70 0c       	ld.w	r12,r8[0x0]
80004a02:	30 09       	mov	r9,0
80004a04:	12 9a       	mov	r10,r9
80004a06:	12 9b       	mov	r11,r9
80004a08:	f0 1f 00 3f 	mcall	80004b04 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004a0c:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80004a10:	4b b8       	lddpc	r8,80004afc <xnl_device_auth_reply_func+0x110>
80004a12:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004a14:	ef 39 00 12 	ld.ub	r9,r7[18]
80004a18:	ef 38 00 13 	ld.ub	r8,r7[19]
80004a1c:	b1 68       	lsl	r8,0x10
80004a1e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80004a22:	ef 38 00 15 	ld.ub	r8,r7[21]
80004a26:	f3 e8 10 08 	or	r8,r9,r8
80004a2a:	ef 39 00 14 	ld.ub	r9,r7[20]
80004a2e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80004a32:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004a36:	ef 38 00 17 	ld.ub	r8,r7[23]
80004a3a:	b1 68       	lsl	r8,0x10
80004a3c:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80004a40:	ef 38 00 19 	ld.ub	r8,r7[25]
80004a44:	f5 e8 10 08 	or	r8,r10,r8
80004a48:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004a4c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80004a50:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004a52:	e0 64 79 b9 	mov	r4,31161
80004a56:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004a5a:	e0 65 45 07 	mov	r5,17671
80004a5e:	ea 15 8a bd 	orh	r5,0x8abd
80004a62:	e0 66 f9 3d 	mov	r6,63805
80004a66:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004a6a:	e0 6e b8 cf 	mov	lr,47311
80004a6e:	ea 1e 36 83 	orh	lr,0x3683
80004a72:	e0 67 aa 1c 	mov	r7,43548
80004a76:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004a7a:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004a7c:	f4 08 00 0c 	add	r12,r10,r8
80004a80:	f0 0b 15 04 	lsl	r11,r8,0x4
80004a84:	0a 0b       	add	r11,r5
80004a86:	f9 eb 20 0b 	eor	r11,r12,r11
80004a8a:	f0 0c 16 05 	lsr	r12,r8,0x5
80004a8e:	0c 0c       	add	r12,r6
80004a90:	18 5b       	eor	r11,r12
80004a92:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004a94:	f2 0c 15 04 	lsl	r12,r9,0x4
80004a98:	1c 0c       	add	r12,lr
80004a9a:	f2 0b 16 05 	lsr	r11,r9,0x5
80004a9e:	0e 0b       	add	r11,r7
80004aa0:	f9 eb 20 0b 	eor	r11,r12,r11
80004aa4:	f2 0a 00 0c 	add	r12,r9,r10
80004aa8:	18 5b       	eor	r11,r12
80004aaa:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004aac:	e0 6b 37 20 	mov	r11,14112
80004ab0:	ea 1b c6 ef 	orh	r11,0xc6ef
80004ab4:	16 3a       	cp.w	r10,r11
80004ab6:	ce 21       	brne	80004a7a <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004ab8:	e0 6a 40 1a 	mov	r10,16410
80004abc:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004abe:	3f fa       	mov	r10,-1
80004ac0:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004ac2:	30 6b       	mov	r11,6
80004ac4:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004ac6:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004ac8:	48 db       	lddpc	r11,80004afc <xnl_device_auth_reply_func+0x110>
80004aca:	96 1c       	ld.sh	r12,r11[0x2]
80004acc:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004ace:	96 2b       	ld.sh	r11,r11[0x4]
80004ad0:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004ad2:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004ad4:	30 ca       	mov	r10,12
80004ad6:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004ad8:	30 0a       	mov	r10,0
80004ada:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004ade:	30 7a       	mov	r10,7
80004ae0:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004ae4:	30 2a       	mov	r10,2
80004ae6:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004aea:	fa ca ff ec 	sub	r10,sp,-20
80004aee:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004af0:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004af2:	1a 9c       	mov	r12,sp
80004af4:	f0 1f 00 05 	mcall	80004b08 <xnl_device_auth_reply_func+0x11c>
}
80004af8:	2c 0d       	sub	sp,-256
80004afa:	d8 22       	popm	r4-r7,pc
80004afc:	00 00       	add	r0,r0
80004afe:	0b 54       	ld.sh	r4,--r5
80004b00:	00 00       	add	r0,r0
80004b02:	0b 50       	ld.sh	r0,--r5
80004b04:	80 00       	ld.sh	r0,r0[0x0]
80004b06:	5a b4       	cp.w	r4,-21
80004b08:	80 00       	ld.sh	r0,r0[0x0]
80004b0a:	47 d4       	lddsp	r4,sp[0x1f4]

80004b0c <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004b0c:	eb cd 40 80 	pushm	r7,lr
80004b10:	fa cd 01 00 	sub	sp,sp,256
80004b14:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004b16:	49 28       	lddpc	r8,80004b5c <xnl_master_status_brdcst_func+0x50>
80004b18:	11 88       	ld.ub	r8,r8[0x0]
80004b1a:	58 08       	cp.w	r8,0
80004b1c:	c1 c1       	brne	80004b54 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004b1e:	49 18       	lddpc	r8,80004b60 <xnl_master_status_brdcst_func+0x54>
80004b20:	70 0c       	ld.w	r12,r8[0x0]
80004b22:	30 09       	mov	r9,0
80004b24:	12 9a       	mov	r10,r9
80004b26:	12 9b       	mov	r11,r9
80004b28:	f0 1f 00 0f 	mcall	80004b64 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004b2c:	8e 58       	ld.sh	r8,r7[0xa]
80004b2e:	48 c9       	lddpc	r9,80004b5c <xnl_master_status_brdcst_func+0x50>
80004b30:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b32:	e0 68 40 0e 	mov	r8,16398
80004b36:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b38:	3f f8       	mov	r8,-1
80004b3a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004b3c:	30 4a       	mov	r10,4
80004b3e:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004b40:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004b42:	92 19       	ld.sh	r9,r9[0x2]
80004b44:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004b46:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004b48:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004b4a:	30 08       	mov	r8,0
80004b4c:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004b4e:	1a 9c       	mov	r12,sp
80004b50:	f0 1f 00 06 	mcall	80004b68 <xnl_master_status_brdcst_func+0x5c>
}
80004b54:	2c 0d       	sub	sp,-256
80004b56:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b5a:	00 00       	add	r0,r0
80004b5c:	00 00       	add	r0,r0
80004b5e:	0b 54       	ld.sh	r4,--r5
80004b60:	00 00       	add	r0,r0
80004b62:	0b 50       	ld.sh	r0,--r5
80004b64:	80 00       	ld.sh	r0,r0[0x0]
80004b66:	5a b4       	cp.w	r4,-21
80004b68:	80 00       	ld.sh	r0,r0[0x0]
80004b6a:	47 d4       	lddsp	r4,sp[0x1f4]

80004b6c <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004b6c:	eb cd 40 80 	pushm	r7,lr
80004b70:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004b72:	49 38       	lddpc	r8,80004bbc <xnl_device_conn_reply_func+0x50>
80004b74:	70 0c       	ld.w	r12,r8[0x0]
80004b76:	30 09       	mov	r9,0
80004b78:	12 9a       	mov	r10,r9
80004b7a:	12 9b       	mov	r11,r9
80004b7c:	f0 1f 00 11 	mcall	80004bc0 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004b80:	ef 18 00 10 	ld.uh	r8,r7[16]
80004b84:	10 99       	mov	r9,r8
80004b86:	e2 19 ff 00 	andl	r9,0xff00,COH
80004b8a:	e0 49 01 00 	cp.w	r9,256
80004b8e:	c0 60       	breq	80004b9a <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004b90:	0e 9c       	mov	r12,r7
80004b92:	f0 1f 00 0d 	mcall	80004bc4 <xnl_device_conn_reply_func+0x58>
80004b96:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004b9a:	a9 68       	lsl	r8,0x8
80004b9c:	48 b9       	lddpc	r9,80004bc8 <xnl_device_conn_reply_func+0x5c>
80004b9e:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004ba0:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004ba4:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004ba6:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004baa:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004bac:	30 18       	mov	r8,1
80004bae:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80004bb0:	48 7c       	lddpc	r12,80004bcc <xnl_device_conn_reply_func+0x60>
80004bb2:	f0 1f 00 08 	mcall	80004bd0 <xnl_device_conn_reply_func+0x64>
80004bb6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bba:	00 00       	add	r0,r0
80004bbc:	00 00       	add	r0,r0
80004bbe:	0b 50       	ld.sh	r0,--r5
80004bc0:	80 00       	ld.sh	r0,r0[0x0]
80004bc2:	5a b4       	cp.w	r4,-21
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	4b 0c       	lddpc	r12,80004c84 <rtc_init+0x60>
80004bc8:	00 00       	add	r0,r0
80004bca:	0b 54       	ld.sh	r4,--r5
80004bcc:	80 01       	ld.sh	r1,r0[0x0]
80004bce:	59 58       	cp.w	r8,21
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	66 a4       	ld.w	r4,r3[0x28]

80004bd4 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004bd4:	fe 78 0c 00 	mov	r8,-62464
80004bd8:	e0 69 03 07 	mov	r9,775
80004bdc:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004bde:	30 49       	mov	r9,4
80004be0:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004be2:	71 59       	ld.w	r9,r8[0x54]
80004be4:	e2 19 00 80 	andl	r9,0x80,COH
80004be8:	cf d0       	breq	80004be2 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80004bea:	fe 78 0c 00 	mov	r8,-62464
80004bee:	30 59       	mov	r9,5
80004bf0:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004bf2:	e0 69 01 0d 	mov	r9,269
80004bf6:	ea 19 10 07 	orh	r9,0x1007
80004bfa:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80004bfc:	71 59       	ld.w	r9,r8[0x54]
80004bfe:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004c02:	cf d0       	breq	80004bfc <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80004c04:	fe 78 0c 00 	mov	r8,-62464
80004c08:	fc 19 00 80 	movh	r9,0x80
80004c0c:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80004c0e:	34 0a       	mov	r10,64
80004c10:	fe 69 14 00 	mov	r9,-125952
80004c14:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004c16:	30 69       	mov	r9,6
80004c18:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004c1a:	30 19       	mov	r9,1
80004c1c:	fe 68 10 00 	mov	r8,-126976
80004c20:	91 19       	st.w	r8[0x4],r9
}
80004c22:	5e fc       	retal	r12

80004c24 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80004c24:	eb cd 40 c0 	pushm	r6-r7,lr
80004c28:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80004c2a:	f0 1f 00 1a 	mcall	80004c90 <rtc_init+0x6c>
80004c2e:	49 a8       	lddpc	r8,80004c94 <rtc_init+0x70>
80004c30:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80004c32:	70 08       	ld.w	r8,r8[0x0]
80004c34:	58 08       	cp.w	r8,0
80004c36:	c0 31       	brne	80004c3c <rtc_init+0x18>
80004c38:	30 3c       	mov	r12,3
80004c3a:	c2 78       	rjmp	80004c88 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80004c3c:	49 66       	lddpc	r6,80004c94 <rtc_init+0x70>
80004c3e:	6c 0c       	ld.w	r12,r6[0x0]
80004c40:	30 09       	mov	r9,0
80004c42:	3f fa       	mov	r10,-1
80004c44:	12 9b       	mov	r11,r9
80004c46:	f0 1f 00 15 	mcall	80004c98 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80004c4a:	30 2b       	mov	r11,2
80004c4c:	49 4c       	lddpc	r12,80004c9c <rtc_init+0x78>
80004c4e:	f0 1f 00 15 	mcall	80004ca0 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80004c52:	e0 68 36 00 	mov	r8,13824
80004c56:	ea 18 01 6e 	orh	r8,0x16e
80004c5a:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80004c5c:	e2 78 0d 40 	mov	r8,200000
80004c60:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80004c62:	35 18       	mov	r8,81
80004c64:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80004c68:	1a 9b       	mov	r11,sp
80004c6a:	fe 7c 2c 00 	mov	r12,-54272
80004c6e:	f0 1f 00 0e 	mcall	80004ca4 <rtc_init+0x80>
80004c72:	48 e7       	lddpc	r7,80004ca8 <rtc_init+0x84>
80004c74:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80004c76:	6c 0c       	ld.w	r12,r6[0x0]
80004c78:	30 09       	mov	r9,0
80004c7a:	12 9a       	mov	r10,r9
80004c7c:	12 9b       	mov	r11,r9
80004c7e:	f0 1f 00 0c 	mcall	80004cac <rtc_init+0x88>
80004c82:	6e 08       	ld.w	r8,r7[0x0]
80004c84:	58 08       	cp.w	r8,0
80004c86:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80004c88:	2f dd       	sub	sp,-12
80004c8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c8e:	00 00       	add	r0,r0
80004c90:	80 00       	ld.sh	r0,r0[0x0]
80004c92:	5b b4       	cp.w	r4,-5
80004c94:	00 00       	add	r0,r0
80004c96:	0b 7c       	ld.ub	r12,--r5
80004c98:	80 00       	ld.sh	r0,r0[0x0]
80004c9a:	58 a8       	cp.w	r8,10
80004c9c:	80 01       	ld.sh	r1,r0[0x0]
80004c9e:	59 6c       	cp.w	r12,22
80004ca0:	80 00       	ld.sh	r0,r0[0x0]
80004ca2:	6b 3c       	ld.w	r12,r5[0x4c]
80004ca4:	80 00       	ld.sh	r0,r0[0x0]
80004ca6:	51 34       	stdsp	sp[0x4c],r4
80004ca8:	00 00       	add	r0,r0
80004caa:	0b 78       	ld.ub	r8,--r5
80004cac:	80 00       	ld.sh	r0,r0[0x0]
80004cae:	5a b4       	cp.w	r4,-21

80004cb0 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004cb0:	fe 78 10 00 	mov	r8,-61440
80004cb4:	fc 19 00 10 	movh	r9,0x10
80004cb8:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004cba:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004cbc:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004cbe:	30 39       	mov	r9,3
80004cc0:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004cc4:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004cc8:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004ccc:	fe 78 38 00 	mov	r8,-51200
80004cd0:	30 49       	mov	r9,4
80004cd2:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004cd6:	e0 69 91 0d 	mov	r9,37133
80004cda:	ea 19 00 52 	orh	r9,0x52
80004cde:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004ce0:	32 09       	mov	r9,32
80004ce2:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004ce4:	30 59       	mov	r9,5
80004ce6:	91 09       	st.w	r8[0x0],r9
}
80004ce8:	5e fc       	retal	r12
80004cea:	d7 03       	nop

80004cec <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004cec:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004cee:	30 2a       	mov	r10,2
80004cf0:	e0 6b 01 c1 	mov	r11,449
80004cf4:	48 ec       	lddpc	r12,80004d2c <tc_init+0x40>
80004cf6:	f0 1f 00 0f 	mcall	80004d30 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004cfa:	48 fb       	lddpc	r11,80004d34 <tc_init+0x48>
80004cfc:	fe 7c 38 00 	mov	r12,-51200
80004d00:	f0 1f 00 0e 	mcall	80004d38 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004d04:	e0 6a 75 30 	mov	r10,30000
80004d08:	30 1b       	mov	r11,1
80004d0a:	fe 7c 38 00 	mov	r12,-51200
80004d0e:	f0 1f 00 0c 	mcall	80004d3c <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004d12:	48 ca       	lddpc	r10,80004d40 <tc_init+0x54>
80004d14:	30 1b       	mov	r11,1
80004d16:	fe 7c 38 00 	mov	r12,-51200
80004d1a:	f0 1f 00 0b 	mcall	80004d44 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004d1e:	30 1b       	mov	r11,1
80004d20:	fe 7c 38 00 	mov	r12,-51200
80004d24:	f0 1f 00 09 	mcall	80004d48 <tc_init+0x5c>
80004d28:	d8 02       	popm	pc
80004d2a:	00 00       	add	r0,r0
80004d2c:	80 00       	ld.sh	r0,r0[0x0]
80004d2e:	4d 4c       	lddpc	r12,80004e7c <tc_init_waveform>
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	4d 70       	lddpc	r0,80004e8c <tc_init_waveform+0x10>
80004d34:	80 01       	ld.sh	r1,r0[0x0]
80004d36:	59 80       	cp.w	r0,24
80004d38:	80 00       	ld.sh	r0,r0[0x0]
80004d3a:	4e 7c       	lddpc	r12,80004ed4 <tc_init_waveform+0x58>
80004d3c:	80 00       	ld.sh	r0,r0[0x0]
80004d3e:	4f 3c       	lddpc	r12,80004f08 <tc_init_waveform+0x8c>
80004d40:	80 01       	ld.sh	r1,r0[0x0]
80004d42:	59 7c       	cp.w	r12,23
80004d44:	80 00       	ld.sh	r0,r0[0x0]
80004d46:	4f 70       	lddpc	r0,80004f20 <tc_start+0x8>
80004d48:	80 00       	ld.sh	r0,r0[0x0]
80004d4a:	4f 18       	lddpc	r8,80004f0c <tc_init_waveform+0x90>

80004d4c <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004d4c:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004d4e:	48 68       	lddpc	r8,80004d64 <_tc_interrupt+0x18>
80004d50:	70 09       	ld.w	r9,r8[0x0]
80004d52:	2f f9       	sub	r9,-1
80004d54:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004d56:	30 1b       	mov	r11,1
80004d58:	fe 7c 38 00 	mov	r12,-51200
80004d5c:	f0 1f 00 03 	mcall	80004d68 <_tc_interrupt+0x1c>
	
}
80004d60:	d4 02       	popm	lr
80004d62:	d6 03       	rete
80004d64:	00 00       	add	r0,r0
80004d66:	0b 80       	ld.ub	r0,r5[0x0]
80004d68:	80 00       	ld.sh	r0,r0[0x0]
80004d6a:	4f 2a       	lddpc	r10,80004f30 <tc_read_sr+0x6>

80004d6c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004d6c:	c0 08       	rjmp	80004d6c <_unhandled_interrupt>
80004d6e:	d7 03       	nop

80004d70 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004d70:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004d74:	49 99       	lddpc	r9,80004dd8 <INTC_register_interrupt+0x68>
80004d76:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004d7a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004d7e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004d80:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004d84:	58 0a       	cp.w	r10,0
80004d86:	c0 91       	brne	80004d98 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004d88:	49 59       	lddpc	r9,80004ddc <INTC_register_interrupt+0x6c>
80004d8a:	49 6a       	lddpc	r10,80004de0 <INTC_register_interrupt+0x70>
80004d8c:	12 1a       	sub	r10,r9
80004d8e:	fe 79 08 00 	mov	r9,-63488
80004d92:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004d96:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004d98:	58 1a       	cp.w	r10,1
80004d9a:	c0 a1       	brne	80004dae <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004d9c:	49 09       	lddpc	r9,80004ddc <INTC_register_interrupt+0x6c>
80004d9e:	49 2a       	lddpc	r10,80004de4 <INTC_register_interrupt+0x74>
80004da0:	12 1a       	sub	r10,r9
80004da2:	bf aa       	sbr	r10,0x1e
80004da4:	fe 79 08 00 	mov	r9,-63488
80004da8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004dac:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004dae:	58 2a       	cp.w	r10,2
80004db0:	c0 a1       	brne	80004dc4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004db2:	48 b9       	lddpc	r9,80004ddc <INTC_register_interrupt+0x6c>
80004db4:	48 da       	lddpc	r10,80004de8 <INTC_register_interrupt+0x78>
80004db6:	12 1a       	sub	r10,r9
80004db8:	bf ba       	sbr	r10,0x1f
80004dba:	fe 79 08 00 	mov	r9,-63488
80004dbe:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004dc2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004dc4:	48 69       	lddpc	r9,80004ddc <INTC_register_interrupt+0x6c>
80004dc6:	48 aa       	lddpc	r10,80004dec <INTC_register_interrupt+0x7c>
80004dc8:	12 1a       	sub	r10,r9
80004dca:	ea 1a c0 00 	orh	r10,0xc000
80004dce:	fe 79 08 00 	mov	r9,-63488
80004dd2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004dd6:	5e fc       	retal	r12
80004dd8:	80 01       	ld.sh	r1,r0[0x0]
80004dda:	59 88       	cp.w	r8,24
80004ddc:	80 00       	ld.sh	r0,r0[0x0]
80004dde:	c6 00       	breq	80004e9e <tc_init_waveform+0x22>
80004de0:	80 00       	ld.sh	r0,r0[0x0]
80004de2:	c7 04       	brge	80004ec2 <tc_init_waveform+0x46>
80004de4:	80 00       	ld.sh	r0,r0[0x0]
80004de6:	c7 12       	brcc	80004ec8 <tc_init_waveform+0x4c>
80004de8:	80 00       	ld.sh	r0,r0[0x0]
80004dea:	c7 20       	breq	80004ece <tc_init_waveform+0x52>
80004dec:	80 00       	ld.sh	r0,r0[0x0]
80004dee:	c7 2e       	rcall	80004ad2 <xnl_device_auth_reply_func+0xe6>

80004df0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004df0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004df2:	49 18       	lddpc	r8,80004e34 <INTC_init_interrupts+0x44>
80004df4:	e3 b8 00 01 	mtsr	0x4,r8
80004df8:	49 0e       	lddpc	lr,80004e38 <INTC_init_interrupts+0x48>
80004dfa:	30 07       	mov	r7,0
80004dfc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004dfe:	49 0c       	lddpc	r12,80004e3c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004e00:	49 05       	lddpc	r5,80004e40 <INTC_init_interrupts+0x50>
80004e02:	10 15       	sub	r5,r8
80004e04:	fe 76 08 00 	mov	r6,-63488
80004e08:	c1 08       	rjmp	80004e28 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004e0a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004e0c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004e0e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004e10:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004e14:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004e16:	10 3a       	cp.w	r10,r8
80004e18:	fe 9b ff fc 	brhi	80004e10 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004e1c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004e20:	2f f7       	sub	r7,-1
80004e22:	2f 8e       	sub	lr,-8
80004e24:	59 37       	cp.w	r7,19
80004e26:	c0 50       	breq	80004e30 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004e28:	7c 08       	ld.w	r8,lr[0x0]
80004e2a:	58 08       	cp.w	r8,0
80004e2c:	ce f1       	brne	80004e0a <INTC_init_interrupts+0x1a>
80004e2e:	cf 7b       	rjmp	80004e1c <INTC_init_interrupts+0x2c>
80004e30:	d8 22       	popm	r4-r7,pc
80004e32:	00 00       	add	r0,r0
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	c6 00       	breq	80004ef6 <tc_init_waveform+0x7a>
80004e38:	80 01       	ld.sh	r1,r0[0x0]
80004e3a:	59 88       	cp.w	r8,24
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	4d 6c       	lddpc	r12,80004f94 <tc_configure_interrupts+0x24>
80004e40:	80 00       	ld.sh	r0,r0[0x0]
80004e42:	c7 04       	brge	80004f22 <tc_start+0xa>

80004e44 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004e44:	fe 78 08 00 	mov	r8,-63488
80004e48:	e0 69 00 83 	mov	r9,131
80004e4c:	f2 0c 01 0c 	sub	r12,r9,r12
80004e50:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004e54:	f2 ca ff c0 	sub	r10,r9,-64
80004e58:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004e5c:	58 08       	cp.w	r8,0
80004e5e:	c0 21       	brne	80004e62 <_get_interrupt_handler+0x1e>
80004e60:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004e62:	f0 08 12 00 	clz	r8,r8
80004e66:	48 5a       	lddpc	r10,80004e78 <_get_interrupt_handler+0x34>
80004e68:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004e6c:	f0 08 11 1f 	rsub	r8,r8,31
80004e70:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004e72:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004e76:	5e fc       	retal	r12
80004e78:	80 01       	ld.sh	r1,r0[0x0]
80004e7a:	59 88       	cp.w	r8,24

80004e7c <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004e7c:	76 09       	ld.w	r9,r11[0x0]
80004e7e:	58 29       	cp.w	r9,2
80004e80:	e0 88 00 03 	brls	80004e86 <tc_init_waveform+0xa>
80004e84:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004e86:	76 18       	ld.w	r8,r11[0x4]
80004e88:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004e8c:	af ba       	sbr	r10,0xf
80004e8e:	10 9b       	mov	r11,r8
80004e90:	e6 1b c0 00 	andh	r11,0xc000,COH
80004e94:	16 4a       	or	r10,r11
80004e96:	10 9b       	mov	r11,r8
80004e98:	e6 1b 30 00 	andh	r11,0x3000,COH
80004e9c:	16 4a       	or	r10,r11
80004e9e:	10 9b       	mov	r11,r8
80004ea0:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004ea4:	16 4a       	or	r10,r11
80004ea6:	10 9b       	mov	r11,r8
80004ea8:	e6 1b 03 00 	andh	r11,0x300,COH
80004eac:	16 4a       	or	r10,r11
80004eae:	10 9b       	mov	r11,r8
80004eb0:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004eb4:	16 4a       	or	r10,r11
80004eb6:	10 9b       	mov	r11,r8
80004eb8:	e6 1b 00 30 	andh	r11,0x30,COH
80004ebc:	16 4a       	or	r10,r11
80004ebe:	10 9b       	mov	r11,r8
80004ec0:	e6 1b 00 0c 	andh	r11,0xc,COH
80004ec4:	16 4a       	or	r10,r11
80004ec6:	10 9b       	mov	r11,r8
80004ec8:	e6 1b 00 03 	andh	r11,0x3,COH
80004ecc:	16 4a       	or	r10,r11
80004ece:	10 9b       	mov	r11,r8
80004ed0:	e2 1b 60 00 	andl	r11,0x6000,COH
80004ed4:	16 4a       	or	r10,r11
80004ed6:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80004eda:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80004ede:	10 9b       	mov	r11,r8
80004ee0:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004ee4:	16 4a       	or	r10,r11
80004ee6:	10 9b       	mov	r11,r8
80004ee8:	e2 1b 03 00 	andl	r11,0x300,COH
80004eec:	16 4a       	or	r10,r11
80004eee:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004ef2:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80004ef6:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80004efa:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80004efe:	10 9b       	mov	r11,r8
80004f00:	e2 1b 00 30 	andl	r11,0x30,COH
80004f04:	16 4a       	or	r10,r11
80004f06:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004f0a:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80004f0e:	a5 69       	lsl	r9,0x4
80004f10:	2f f9       	sub	r9,-1
80004f12:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004f16:	5e fd       	retal	0

80004f18 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004f18:	58 2b       	cp.w	r11,2
80004f1a:	e0 88 00 03 	brls	80004f20 <tc_start+0x8>
80004f1e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004f20:	a7 6b       	lsl	r11,0x6
80004f22:	16 0c       	add	r12,r11
80004f24:	30 58       	mov	r8,5
80004f26:	99 08       	st.w	r12[0x0],r8
80004f28:	5e fd       	retal	0

80004f2a <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004f2a:	58 2b       	cp.w	r11,2
80004f2c:	e0 88 00 03 	brls	80004f32 <tc_read_sr+0x8>
80004f30:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004f32:	a7 6b       	lsl	r11,0x6
80004f34:	2e 0b       	sub	r11,-32
80004f36:	16 0c       	add	r12,r11
80004f38:	78 0c       	ld.w	r12,r12[0x0]
}
80004f3a:	5e fc       	retal	r12

80004f3c <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004f3c:	58 2b       	cp.w	r11,2
80004f3e:	e0 88 00 03 	brls	80004f44 <tc_write_rc+0x8>
80004f42:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004f44:	f6 08 15 04 	lsl	r8,r11,0x4
80004f48:	2f f8       	sub	r8,-1
80004f4a:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004f4e:	e2 18 80 00 	andl	r8,0x8000,COH
80004f52:	c0 c0       	breq	80004f6a <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004f54:	a7 6b       	lsl	r11,0x6
80004f56:	16 0c       	add	r12,r11
80004f58:	2e 4c       	sub	r12,-28
80004f5a:	78 08       	ld.w	r8,r12[0x0]
80004f5c:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004f60:	e0 18 00 00 	andl	r8,0x0
80004f64:	f3 e8 10 08 	or	r8,r9,r8
80004f68:	99 08       	st.w	r12[0x0],r8

  return value;
80004f6a:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004f6e:	5e fc       	retal	r12

80004f70 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004f70:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004f74:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004f78:	58 2b       	cp.w	r11,2
80004f7a:	e0 88 00 04 	brls	80004f82 <tc_configure_interrupts+0x12>
80004f7e:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004f82:	ee 19 00 01 	eorh	r9,0x1
80004f86:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004f8a:	74 08       	ld.w	r8,r10[0x0]
80004f8c:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004f90:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004f94:	a7 6e       	lsl	lr,0x6
80004f96:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004f9a:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004f9e:	0e 4e       	or	lr,r7
80004fa0:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004fa4:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004fa8:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004fac:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004fb0:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004fb4:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004fb8:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004fbc:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004fc0:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004fc4:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004fc8:	f6 0e 15 06 	lsl	lr,r11,0x6
80004fcc:	f8 0e 00 0e 	add	lr,r12,lr
80004fd0:	2d ce       	sub	lr,-36
80004fd2:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004fd4:	58 09       	cp.w	r9,0
80004fd6:	c0 20       	breq	80004fda <tc_configure_interrupts+0x6a>
80004fd8:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004fda:	74 08       	ld.w	r8,r10[0x0]
80004fdc:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004fe0:	e0 65 00 80 	mov	r5,128
80004fe4:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004fe8:	74 08       	ld.w	r8,r10[0x0]
80004fea:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004fee:	f9 b4 00 40 	moveq	r4,64
80004ff2:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004ff6:	74 08       	ld.w	r8,r10[0x0]
80004ff8:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004ffc:	f9 b3 00 20 	moveq	r3,32
80005000:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80005004:	74 08       	ld.w	r8,r10[0x0]
80005006:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
8000500a:	f9 b2 00 10 	moveq	r2,16
8000500e:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80005012:	74 08       	ld.w	r8,r10[0x0]
80005014:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005018:	f9 b6 00 08 	moveq	r6,8
8000501c:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80005020:	74 08       	ld.w	r8,r10[0x0]
80005022:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80005026:	f9 b7 00 04 	moveq	r7,4
8000502a:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
8000502e:	74 08       	ld.w	r8,r10[0x0]
80005030:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80005034:	f9 be 00 02 	moveq	lr,2
80005038:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
8000503c:	74 08       	ld.w	r8,r10[0x0]
8000503e:	ec 18 00 01 	eorl	r8,0x1
80005042:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005046:	eb e8 10 08 	or	r8,r5,r8
8000504a:	08 48       	or	r8,r4
8000504c:	06 48       	or	r8,r3
8000504e:	04 48       	or	r8,r2
80005050:	0c 48       	or	r8,r6
80005052:	0e 48       	or	r8,r7
80005054:	1c 48       	or	r8,lr
80005056:	f6 0a 15 06 	lsl	r10,r11,0x6
8000505a:	f8 0a 00 0a 	add	r10,r12,r10
8000505e:	2d 8a       	sub	r10,-40
80005060:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80005062:	a7 6b       	lsl	r11,0x6
80005064:	2e 0b       	sub	r11,-32
80005066:	16 0c       	add	r12,r11
80005068:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
8000506a:	58 09       	cp.w	r9,0
8000506c:	c0 31       	brne	80005072 <tc_configure_interrupts+0x102>
8000506e:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80005072:	d5 03       	csrf	0x10
80005074:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80005078 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80005078:	4a 78       	lddpc	r8,80005114 <twi_master_interrupt_handler+0x9c>
8000507a:	70 08       	ld.w	r8,r8[0x0]
8000507c:	70 89       	ld.w	r9,r8[0x20]
8000507e:	4a 7a       	lddpc	r10,80005118 <twi_master_interrupt_handler+0xa0>
80005080:	74 0a       	ld.w	r10,r10[0x0]
80005082:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80005086:	12 9a       	mov	r10,r9
80005088:	e2 1a 01 00 	andl	r10,0x100,COH
8000508c:	c3 91       	brne	800050fe <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
8000508e:	12 9a       	mov	r10,r9
80005090:	e2 1a 00 02 	andl	r10,0x2,COH
80005094:	c1 70       	breq	800050c2 <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80005096:	4a 29       	lddpc	r9,8000511c <twi_master_interrupt_handler+0xa4>
80005098:	72 0a       	ld.w	r10,r9[0x0]
8000509a:	70 cb       	ld.w	r11,r8[0x30]
8000509c:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
8000509e:	72 0a       	ld.w	r10,r9[0x0]
800050a0:	2f fa       	sub	r10,-1
800050a2:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
800050a4:	49 f9       	lddpc	r9,80005120 <twi_master_interrupt_handler+0xa8>
800050a6:	72 0a       	ld.w	r10,r9[0x0]
800050a8:	20 1a       	sub	r10,1
800050aa:	93 0a       	st.w	r9[0x0],r10
800050ac:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
800050ae:	58 19       	cp.w	r9,1
800050b0:	f9 b9 00 02 	moveq	r9,2
800050b4:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
800050b8:	49 a9       	lddpc	r9,80005120 <twi_master_interrupt_handler+0xa8>
800050ba:	72 09       	ld.w	r9,r9[0x0]
800050bc:	58 09       	cp.w	r9,0
800050be:	c2 30       	breq	80005104 <twi_master_interrupt_handler+0x8c>
800050c0:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
800050c2:	12 9a       	mov	r10,r9
800050c4:	e2 1a 00 04 	andl	r10,0x4,COH
800050c8:	c1 70       	breq	800050f6 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
800050ca:	49 79       	lddpc	r9,80005124 <twi_master_interrupt_handler+0xac>
800050cc:	72 0a       	ld.w	r10,r9[0x0]
800050ce:	20 1a       	sub	r10,1
800050d0:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
800050d2:	72 09       	ld.w	r9,r9[0x0]
800050d4:	58 09       	cp.w	r9,0
800050d6:	e0 89 00 0a 	brgt	800050ea <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
800050da:	49 09       	lddpc	r9,80005118 <twi_master_interrupt_handler+0xa0>
800050dc:	30 1a       	mov	r10,1
800050de:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
800050e0:	3f fa       	mov	r10,-1
800050e2:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
800050e4:	72 09       	ld.w	r9,r9[0x0]
800050e6:	91 99       	st.w	r8[0x24],r9
800050e8:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
800050ea:	49 0a       	lddpc	r10,80005128 <twi_master_interrupt_handler+0xb0>
800050ec:	74 09       	ld.w	r9,r10[0x0]
800050ee:	13 3b       	ld.ub	r11,r9++
800050f0:	91 db       	st.w	r8[0x34],r11
800050f2:	95 09       	st.w	r10[0x0],r9
800050f4:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
800050f6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800050fa:	c0 51       	brne	80005104 <twi_master_interrupt_handler+0x8c>
800050fc:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
800050fe:	30 1a       	mov	r10,1
80005100:	48 b9       	lddpc	r9,8000512c <twi_master_interrupt_handler+0xb4>
80005102:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80005104:	3f f9       	mov	r9,-1
80005106:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80005108:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
8000510a:	30 09       	mov	r9,0
8000510c:	48 98       	lddpc	r8,80005130 <twi_master_interrupt_handler+0xb8>
8000510e:	b0 89       	st.b	r8[0x0],r9
80005110:	d6 03       	rete
80005112:	00 00       	add	r0,r0
80005114:	00 00       	add	r0,r0
80005116:	0c 38       	cp.w	r8,r6
80005118:	00 00       	add	r0,r0
8000511a:	0c 34       	cp.w	r4,r6
8000511c:	00 00       	add	r0,r0
8000511e:	0c 44       	or	r4,r6
80005120:	00 00       	add	r0,r0
80005122:	0c 40       	or	r0,r6
80005124:	00 00       	add	r0,r0
80005126:	0c 30       	cp.w	r0,r6
80005128:	00 00       	add	r0,r0
8000512a:	0c 3c       	cp.w	r12,r6
8000512c:	00 00       	add	r0,r0
8000512e:	0c 2d       	rsub	sp,r6
80005130:	00 00       	add	r0,r0
80005132:	0c 2c       	rsub	r12,r6

80005134 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80005134:	eb cd 40 e0 	pushm	r5-r7,lr
80005138:	18 97       	mov	r7,r12
8000513a:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
8000513c:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80005140:	49 f9       	lddpc	r9,800051bc <twi_master_init+0x88>
80005142:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80005144:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80005146:	3f f9       	mov	r9,-1
80005148:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
8000514a:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
8000514c:	e0 69 00 80 	mov	r9,128
80005150:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80005152:	e6 18 00 01 	andh	r8,0x1,COH
80005156:	c0 21       	brne	8000515a <twi_master_init+0x26>
      cpu_irq_enable();
80005158:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
8000515a:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000515c:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80005160:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80005162:	30 3a       	mov	r10,3
80005164:	e0 6b 01 60 	mov	r11,352
80005168:	49 6c       	lddpc	r12,800051c0 <twi_master_init+0x8c>
8000516a:	f0 1f 00 17 	mcall	800051c4 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000516e:	e6 16 00 01 	andh	r6,0x1,COH
80005172:	c0 21       	brne	80005176 <twi_master_init+0x42>
      cpu_irq_enable();
80005174:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80005176:	6a 19       	ld.w	r9,r5[0x4]
80005178:	a1 79       	lsl	r9,0x1
8000517a:	6a 08       	ld.w	r8,r5[0x0]
8000517c:	f0 09 0d 08 	divu	r8,r8,r9
80005180:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80005182:	e0 48 00 ff 	cp.w	r8,255
80005186:	e0 8b 00 04 	brhi	8000518e <twi_master_init+0x5a>
8000518a:	30 09       	mov	r9,0
8000518c:	c0 f8       	rjmp	800051aa <twi_master_init+0x76>
8000518e:	30 09       	mov	r9,0
80005190:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80005192:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80005194:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80005196:	e0 48 00 ff 	cp.w	r8,255
8000519a:	5f bb       	srhi	r11
8000519c:	58 69       	cp.w	r9,6
8000519e:	5f 8a       	srls	r10
800051a0:	f7 ea 00 0a 	and	r10,r11,r10
800051a4:	f8 0a 18 00 	cp.b	r10,r12
800051a8:	cf 51       	brne	80005192 <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
800051aa:	b1 69       	lsl	r9,0x10
800051ac:	f3 e8 10 89 	or	r9,r9,r8<<0x8
800051b0:	f3 e8 10 08 	or	r8,r9,r8
800051b4:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
800051b6:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800051ba:	00 00       	add	r0,r0
800051bc:	00 00       	add	r0,r0
800051be:	0c 38       	cp.w	r8,r6
800051c0:	80 00       	ld.sh	r0,r0[0x0]
800051c2:	50 78       	stdsp	sp[0x1c],r8
800051c4:	80 00       	ld.sh	r0,r0[0x0]
800051c6:	4d 70       	lddpc	r0,80005320 <usart_init_rs232+0x1c>

800051c8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800051c8:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800051ca:	f6 08 15 04 	lsl	r8,r11,0x4
800051ce:	14 38       	cp.w	r8,r10
800051d0:	f9 b8 08 10 	movls	r8,16
800051d4:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800051d8:	f0 0b 02 4b 	mul	r11,r8,r11
800051dc:	f6 09 16 01 	lsr	r9,r11,0x1
800051e0:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800051e4:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800051e8:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800051ec:	f2 cb 00 01 	sub	r11,r9,1
800051f0:	e0 4b ff fe 	cp.w	r11,65534
800051f4:	e0 88 00 03 	brls	800051fa <usart_set_async_baudrate+0x32>
800051f8:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800051fa:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800051fc:	e8 6e 00 00 	mov	lr,524288
80005200:	59 08       	cp.w	r8,16
80005202:	fc 08 17 10 	movne	r8,lr
80005206:	f9 b8 00 00 	moveq	r8,0
8000520a:	e4 1b ff f7 	andh	r11,0xfff7
8000520e:	e0 1b fe cf 	andl	r11,0xfecf
80005212:	16 48       	or	r8,r11
80005214:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005216:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000521a:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000521e:	99 89       	st.w	r12[0x20],r9
80005220:	d8 0a       	popm	pc,r12=0

80005222 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005222:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005224:	e2 18 00 02 	andl	r8,0x2,COH
80005228:	c0 31       	brne	8000522e <usart_write_char+0xc>
8000522a:	30 2c       	mov	r12,2
8000522c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000522e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005232:	99 7b       	st.w	r12[0x1c],r11
80005234:	5e fd       	retal	0
80005236:	d7 03       	nop

80005238 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005238:	eb cd 40 e0 	pushm	r5-r7,lr
8000523c:	18 96       	mov	r6,r12
8000523e:	16 95       	mov	r5,r11
80005240:	e0 67 27 0f 	mov	r7,9999
80005244:	c0 68       	rjmp	80005250 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005246:	58 07       	cp.w	r7,0
80005248:	c0 31       	brne	8000524e <usart_putchar+0x16>
8000524a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000524e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005250:	0a 9b       	mov	r11,r5
80005252:	0c 9c       	mov	r12,r6
80005254:	f0 1f 00 03 	mcall	80005260 <usart_putchar+0x28>
80005258:	cf 71       	brne	80005246 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000525a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000525e:	00 00       	add	r0,r0
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	52 22       	stdsp	sp[0x88],r2

80005264 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005264:	78 58       	ld.w	r8,r12[0x14]
80005266:	e2 18 00 e0 	andl	r8,0xe0,COH
8000526a:	c0 30       	breq	80005270 <usart_read_char+0xc>
8000526c:	30 4c       	mov	r12,4
8000526e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005270:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005272:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005276:	c0 31       	brne	8000527c <usart_read_char+0x18>
80005278:	30 3c       	mov	r12,3
8000527a:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
8000527c:	78 68       	ld.w	r8,r12[0x18]
8000527e:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005282:	97 08       	st.w	r11[0x0],r8
80005284:	5e fd       	retal	0
80005286:	d7 03       	nop

80005288 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005288:	eb cd 40 c0 	pushm	r6-r7,lr
8000528c:	20 1d       	sub	sp,4
8000528e:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005290:	1a 97       	mov	r7,sp
80005292:	1a 9b       	mov	r11,sp
80005294:	0c 9c       	mov	r12,r6
80005296:	f0 1f 00 07 	mcall	800052b0 <usart_getchar+0x28>
8000529a:	58 3c       	cp.w	r12,3
8000529c:	cf b0       	breq	80005292 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000529e:	58 4c       	cp.w	r12,4
800052a0:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800052a4:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800052a8:	2f fd       	sub	sp,-4
800052aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800052ae:	00 00       	add	r0,r0
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	52 64       	stdsp	sp[0x98],r4

800052b4 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800052b4:	eb cd 40 c0 	pushm	r6-r7,lr
800052b8:	18 96       	mov	r6,r12
800052ba:	16 97       	mov	r7,r11
  while (*string != '\0')
800052bc:	17 8b       	ld.ub	r11,r11[0x0]
800052be:	58 0b       	cp.w	r11,0
800052c0:	c0 80       	breq	800052d0 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800052c2:	2f f7       	sub	r7,-1
800052c4:	0c 9c       	mov	r12,r6
800052c6:	f0 1f 00 04 	mcall	800052d4 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800052ca:	0f 8b       	ld.ub	r11,r7[0x0]
800052cc:	58 0b       	cp.w	r11,0
800052ce:	cf a1       	brne	800052c2 <usart_write_line+0xe>
800052d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800052d4:	80 00       	ld.sh	r0,r0[0x0]
800052d6:	52 38       	stdsp	sp[0x8c],r8

800052d8 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800052d8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800052dc:	e6 18 00 01 	andh	r8,0x1,COH
800052e0:	c0 71       	brne	800052ee <usart_reset+0x16>
800052e2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800052e4:	3f f8       	mov	r8,-1
800052e6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800052e8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800052ea:	d5 03       	csrf	0x10
800052ec:	c0 48       	rjmp	800052f4 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800052ee:	3f f8       	mov	r8,-1
800052f0:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800052f2:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800052f4:	30 08       	mov	r8,0
800052f6:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800052f8:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800052fa:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800052fc:	ea 68 61 0c 	mov	r8,680204
80005300:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005302:	5e fc       	retal	r12

80005304 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005304:	eb cd 40 e0 	pushm	r5-r7,lr
80005308:	18 96       	mov	r6,r12
8000530a:	16 97       	mov	r7,r11
8000530c:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
8000530e:	f0 1f 00 2f 	mcall	800053c8 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005312:	58 07       	cp.w	r7,0
80005314:	c5 80       	breq	800053c4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005316:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005318:	30 49       	mov	r9,4
8000531a:	f2 08 18 00 	cp.b	r8,r9
8000531e:	e0 88 00 53 	brls	800053c4 <usart_init_rs232+0xc0>
80005322:	30 99       	mov	r9,9
80005324:	f2 08 18 00 	cp.b	r8,r9
80005328:	e0 8b 00 4e 	brhi	800053c4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000532c:	0f d9       	ld.ub	r9,r7[0x5]
8000532e:	30 78       	mov	r8,7
80005330:	f0 09 18 00 	cp.b	r9,r8
80005334:	e0 8b 00 48 	brhi	800053c4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005338:	8e 39       	ld.sh	r9,r7[0x6]
8000533a:	e0 68 01 01 	mov	r8,257
8000533e:	f0 09 19 00 	cp.h	r9,r8
80005342:	e0 8b 00 41 	brhi	800053c4 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005346:	ef 39 00 08 	ld.ub	r9,r7[8]
8000534a:	30 38       	mov	r8,3
8000534c:	f0 09 18 00 	cp.b	r9,r8
80005350:	e0 8b 00 3a 	brhi	800053c4 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005354:	0a 9a       	mov	r10,r5
80005356:	6e 0b       	ld.w	r11,r7[0x0]
80005358:	0c 9c       	mov	r12,r6
8000535a:	f0 1f 00 1d 	mcall	800053cc <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000535e:	58 1c       	cp.w	r12,1
80005360:	c3 20       	breq	800053c4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005362:	0f c8       	ld.ub	r8,r7[0x4]
80005364:	30 99       	mov	r9,9
80005366:	f2 08 18 00 	cp.b	r8,r9
8000536a:	c0 51       	brne	80005374 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000536c:	6c 18       	ld.w	r8,r6[0x4]
8000536e:	b1 b8       	sbr	r8,0x11
80005370:	8d 18       	st.w	r6[0x4],r8
80005372:	c0 68       	rjmp	8000537e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005374:	6c 19       	ld.w	r9,r6[0x4]
80005376:	20 58       	sub	r8,5
80005378:	f3 e8 10 68 	or	r8,r9,r8<<0x6
8000537c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000537e:	6c 19       	ld.w	r9,r6[0x4]
80005380:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005384:	0f d8       	ld.ub	r8,r7[0x5]
80005386:	a9 78       	lsl	r8,0x9
80005388:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
8000538c:	12 48       	or	r8,r9
8000538e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005390:	8e 38       	ld.sh	r8,r7[0x6]
80005392:	30 29       	mov	r9,2
80005394:	f2 08 19 00 	cp.h	r8,r9
80005398:	e0 88 00 09 	brls	800053aa <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000539c:	6c 18       	ld.w	r8,r6[0x4]
8000539e:	ad b8       	sbr	r8,0xd
800053a0:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
800053a2:	8e b8       	ld.uh	r8,r7[0x6]
800053a4:	20 28       	sub	r8,2
800053a6:	8d a8       	st.w	r6[0x28],r8
800053a8:	c0 68       	rjmp	800053b4 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
800053aa:	6c 19       	ld.w	r9,r6[0x4]
800053ac:	5c 78       	castu.h	r8
800053ae:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
800053b2:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800053b4:	6c 18       	ld.w	r8,r6[0x4]
800053b6:	e0 18 ff f0 	andl	r8,0xfff0
800053ba:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800053bc:	35 08       	mov	r8,80
800053be:	8d 08       	st.w	r6[0x0],r8
800053c0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800053c4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	52 d8       	stdsp	sp[0xb4],r8
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	51 c8       	stdsp	sp[0x70],r8

800053d0 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800053d0:	f8 c8 ff f8 	sub	r8,r12,-8
800053d4:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800053d6:	3f f9       	mov	r9,-1
800053d8:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800053da:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800053dc:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800053de:	30 08       	mov	r8,0
800053e0:	99 08       	st.w	r12[0x0],r8
}
800053e2:	5e fc       	retal	r12

800053e4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800053e4:	30 08       	mov	r8,0
800053e6:	99 48       	st.w	r12[0x10],r8
}
800053e8:	5e fc       	retal	r12

800053ea <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800053ea:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800053ec:	70 19       	ld.w	r9,r8[0x4]
800053ee:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800053f0:	78 19       	ld.w	r9,r12[0x4]
800053f2:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800053f4:	70 19       	ld.w	r9,r8[0x4]
800053f6:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800053f8:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800053fa:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800053fc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800053fe:	78 08       	ld.w	r8,r12[0x0]
80005400:	2f f8       	sub	r8,-1
80005402:	99 08       	st.w	r12[0x0],r8
}
80005404:	5e fc       	retal	r12

80005406 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005406:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005408:	5b fa       	cp.w	r10,-1
8000540a:	c0 31       	brne	80005410 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
8000540c:	78 48       	ld.w	r8,r12[0x10]
8000540e:	c0 c8       	rjmp	80005426 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005410:	f8 c8 ff f8 	sub	r8,r12,-8
80005414:	70 19       	ld.w	r9,r8[0x4]
80005416:	72 09       	ld.w	r9,r9[0x0]
80005418:	12 3a       	cp.w	r10,r9
8000541a:	c0 63       	brcs	80005426 <vListInsert+0x20>
8000541c:	70 18       	ld.w	r8,r8[0x4]
8000541e:	70 19       	ld.w	r9,r8[0x4]
80005420:	72 09       	ld.w	r9,r9[0x0]
80005422:	12 3a       	cp.w	r10,r9
80005424:	cf c2       	brcc	8000541c <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005426:	70 19       	ld.w	r9,r8[0x4]
80005428:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000542a:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
8000542c:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000542e:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005430:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005432:	78 08       	ld.w	r8,r12[0x0]
80005434:	2f f8       	sub	r8,-1
80005436:	99 08       	st.w	r12[0x0],r8
}
80005438:	5e fc       	retal	r12

8000543a <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000543a:	78 18       	ld.w	r8,r12[0x4]
8000543c:	78 29       	ld.w	r9,r12[0x8]
8000543e:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005440:	78 28       	ld.w	r8,r12[0x8]
80005442:	78 19       	ld.w	r9,r12[0x4]
80005444:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005446:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005448:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000544a:	18 39       	cp.w	r9,r12
8000544c:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005450:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005454:	30 09       	mov	r9,0
80005456:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005458:	70 09       	ld.w	r9,r8[0x0]
8000545a:	20 19       	sub	r9,1
8000545c:	91 09       	st.w	r8[0x0],r9
}
8000545e:	5e fc       	retal	r12

80005460 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005460:	e0 68 08 08 	mov	r8,2056
80005464:	ea 18 08 08 	orh	r8,0x808
80005468:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000546a:	e0 68 09 09 	mov	r8,2313
8000546e:	ea 18 09 09 	orh	r8,0x909
80005472:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005474:	e0 68 0a 0a 	mov	r8,2570
80005478:	ea 18 0a 0a 	orh	r8,0xa0a
8000547c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000547e:	e0 68 0b 0b 	mov	r8,2827
80005482:	ea 18 0b 0b 	orh	r8,0xb0b
80005486:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005488:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000548a:	e0 68 be ef 	mov	r8,48879
8000548e:	ea 18 de ad 	orh	r8,0xdead
80005492:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005494:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005496:	fc 18 00 40 	movh	r8,0x40
8000549a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000549c:	e0 68 00 ff 	mov	r8,255
800054a0:	ea 18 ff 00 	orh	r8,0xff00
800054a4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800054a6:	e0 68 01 01 	mov	r8,257
800054aa:	ea 18 01 01 	orh	r8,0x101
800054ae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800054b0:	e0 68 02 02 	mov	r8,514
800054b4:	ea 18 02 02 	orh	r8,0x202
800054b8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800054ba:	e0 68 03 03 	mov	r8,771
800054be:	ea 18 03 03 	orh	r8,0x303
800054c2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800054c4:	e0 68 04 04 	mov	r8,1028
800054c8:	ea 18 04 04 	orh	r8,0x404
800054cc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800054ce:	e0 68 05 05 	mov	r8,1285
800054d2:	ea 18 05 05 	orh	r8,0x505
800054d6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800054d8:	e0 68 06 06 	mov	r8,1542
800054dc:	ea 18 06 06 	orh	r8,0x606
800054e0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800054e2:	e0 68 07 07 	mov	r8,1799
800054e6:	ea 18 07 07 	orh	r8,0x707
800054ea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800054ec:	30 08       	mov	r8,0
800054ee:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800054f0:	5e fc       	retal	r12
800054f2:	d7 03       	nop

800054f4 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800054f4:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800054f6:	48 38       	lddpc	r8,80005500 <vPortEnterCritical+0xc>
800054f8:	70 09       	ld.w	r9,r8[0x0]
800054fa:	2f f9       	sub	r9,-1
800054fc:	91 09       	st.w	r8[0x0],r9
}
800054fe:	5e fc       	retal	r12
80005500:	00 00       	add	r0,r0
80005502:	05 28       	ld.uh	r8,r2++

80005504 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005504:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005506:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005508:	30 0a       	mov	r10,0
8000550a:	14 9b       	mov	r11,r10
8000550c:	49 2c       	lddpc	r12,80005554 <xPortStartScheduler+0x50>
8000550e:	f0 1f 00 13 	mcall	80005558 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005512:	e0 68 5d c0 	mov	r8,24000
80005516:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000551a:	30 08       	mov	r8,0
8000551c:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005520:	e0 68 0d 18 	mov	r8,3352
80005524:	ea 18 00 00 	orh	r8,0x0
80005528:	70 00       	ld.w	r0,r8[0x0]
8000552a:	60 0d       	ld.w	sp,r0[0x0]
8000552c:	1b 00       	ld.w	r0,sp++
8000552e:	e0 68 05 28 	mov	r8,1320
80005532:	ea 18 00 00 	orh	r8,0x0
80005536:	91 00       	st.w	r8[0x0],r0
80005538:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000553c:	2f ed       	sub	sp,-8
8000553e:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005542:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005546:	e3 b0 00 00 	mtsr	0x0,r0
8000554a:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000554e:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005552:	d8 0a       	popm	pc,r12=0
80005554:	80 00       	ld.sh	r0,r0[0x0]
80005556:	56 20       	stdsp	sp[0x188],r0
80005558:	80 00       	ld.sh	r0,r0[0x0]
8000555a:	4d 70       	lddpc	r0,800056b4 <__malloc_unlock+0x4>

8000555c <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
8000555c:	20 6d       	sub	sp,24
8000555e:	eb cd 00 ff 	pushm	r0-r7
80005562:	fa c7 ff c0 	sub	r7,sp,-64
80005566:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000556a:	ef 40 ff e0 	st.w	r7[-32],r0
8000556e:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005572:	ef 40 ff e4 	st.w	r7[-28],r0
80005576:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000557a:	e0 68 05 28 	mov	r8,1320
8000557e:	ea 18 00 00 	orh	r8,0x0
80005582:	70 00       	ld.w	r0,r8[0x0]
80005584:	1a d0       	st.w	--sp,r0
80005586:	f0 1f 00 1a 	mcall	800055ec <LABEL_RET_SCALL_263+0x14>
8000558a:	e0 68 0d 18 	mov	r8,3352
8000558e:	ea 18 00 00 	orh	r8,0x0
80005592:	70 00       	ld.w	r0,r8[0x0]
80005594:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005596:	f0 1f 00 17 	mcall	800055f0 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
8000559a:	e0 68 0d 18 	mov	r8,3352
8000559e:	ea 18 00 00 	orh	r8,0x0
800055a2:	70 00       	ld.w	r0,r8[0x0]
800055a4:	60 0d       	ld.w	sp,r0[0x0]
800055a6:	1b 00       	ld.w	r0,sp++
800055a8:	e0 68 05 28 	mov	r8,1320
800055ac:	ea 18 00 00 	orh	r8,0x0
800055b0:	91 00       	st.w	r8[0x0],r0
800055b2:	fa c7 ff d8 	sub	r7,sp,-40
800055b6:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800055ba:	ee f0 ff e0 	ld.w	r0,r7[-32]
800055be:	e0 61 05 28 	mov	r1,1320
800055c2:	ea 11 00 00 	orh	r1,0x0
800055c6:	62 02       	ld.w	r2,r1[0x0]
800055c8:	58 02       	cp.w	r2,0
800055ca:	c0 70       	breq	800055d8 <LABEL_RET_SCALL_263>
800055cc:	e4 c2 00 01 	sub	r2,r2,1
800055d0:	83 02       	st.w	r1[0x0],r2
800055d2:	58 02       	cp.w	r2,0
800055d4:	c0 21       	brne	800055d8 <LABEL_RET_SCALL_263>
800055d6:	b1 c0       	cbr	r0,0x10

800055d8 <LABEL_RET_SCALL_263>:
800055d8:	ef 40 ff f8 	st.w	r7[-8],r0
800055dc:	ee f0 ff e4 	ld.w	r0,r7[-28]
800055e0:	ef 40 ff fc 	st.w	r7[-4],r0
800055e4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800055e8:	2f ad       	sub	sp,-24
800055ea:	d6 13       	rets
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	54 f4       	stdsp	sp[0x13c],r4
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	5c 90       	brev	r0

800055f4 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800055f4:	e1 b8 00 43 	mfsr	r8,0x10c
800055f8:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800055fc:	5e fc       	retal	r12
800055fe:	d7 03       	nop

80005600 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005600:	48 78       	lddpc	r8,8000561c <vPortExitCritical+0x1c>
80005602:	70 08       	ld.w	r8,r8[0x0]
80005604:	58 08       	cp.w	r8,0
80005606:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005608:	48 58       	lddpc	r8,8000561c <vPortExitCritical+0x1c>
8000560a:	70 09       	ld.w	r9,r8[0x0]
8000560c:	20 19       	sub	r9,1
8000560e:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005610:	70 08       	ld.w	r8,r8[0x0]
80005612:	58 08       	cp.w	r8,0
80005614:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005616:	d5 03       	csrf	0x10
80005618:	5e fc       	retal	r12
8000561a:	00 00       	add	r0,r0
8000561c:	00 00       	add	r0,r0
8000561e:	05 28       	ld.uh	r8,r2++

80005620 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005620:	eb cd 00 ff 	pushm	r0-r7
80005624:	e0 68 05 28 	mov	r8,1320
80005628:	ea 18 00 00 	orh	r8,0x0
8000562c:	70 00       	ld.w	r0,r8[0x0]
8000562e:	1a d0       	st.w	--sp,r0
80005630:	7a 90       	ld.w	r0,sp[0x24]
80005632:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005636:	58 10       	cp.w	r0,1
80005638:	e0 8b 00 08 	brhi	80005648 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
8000563c:	e0 68 0d 18 	mov	r8,3352
80005640:	ea 18 00 00 	orh	r8,0x0
80005644:	70 00       	ld.w	r0,r8[0x0]
80005646:	81 0d       	st.w	r0[0x0],sp

80005648 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005648:	f0 1f 00 12 	mcall	80005690 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
8000564c:	f0 1f 00 12 	mcall	80005694 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005650:	f0 1f 00 12 	mcall	80005698 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005654:	f0 1f 00 12 	mcall	8000569c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005658:	7a 90       	ld.w	r0,sp[0x24]
8000565a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000565e:	58 10       	cp.w	r0,1
80005660:	e0 8b 00 0e 	brhi	8000567c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005664:	f0 1f 00 0c 	mcall	80005694 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005668:	f0 1f 00 0e 	mcall	800056a0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
8000566c:	f0 1f 00 0c 	mcall	8000569c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005670:	e0 68 0d 18 	mov	r8,3352
80005674:	ea 18 00 00 	orh	r8,0x0
80005678:	70 00       	ld.w	r0,r8[0x0]
8000567a:	60 0d       	ld.w	sp,r0[0x0]

8000567c <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
8000567c:	1b 00       	ld.w	r0,sp++
8000567e:	e0 68 05 28 	mov	r8,1320
80005682:	ea 18 00 00 	orh	r8,0x0
80005686:	91 00       	st.w	r8[0x0],r0
80005688:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000568c:	d6 03       	rete
8000568e:	00 00       	add	r0,r0
80005690:	80 00       	ld.sh	r0,r0[0x0]
80005692:	55 f4       	stdsp	sp[0x17c],r4
80005694:	80 00       	ld.sh	r0,r0[0x0]
80005696:	54 f4       	stdsp	sp[0x13c],r4
80005698:	80 00       	ld.sh	r0,r0[0x0]
8000569a:	5e 94       	retgt	r4
8000569c:	80 00       	ld.sh	r0,r0[0x0]
8000569e:	56 00       	stdsp	sp[0x180],r0
800056a0:	80 00       	ld.sh	r0,r0[0x0]
800056a2:	5c 90       	brev	r0

800056a4 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800056a4:	d4 01       	pushm	lr
	vTaskSuspendAll();
800056a6:	f0 1f 00 02 	mcall	800056ac <__malloc_lock+0x8>
}
800056aa:	d8 02       	popm	pc
800056ac:	80 00       	ld.sh	r0,r0[0x0]
800056ae:	5c 80       	casts.h	r0

800056b0 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800056b0:	d4 01       	pushm	lr
	xTaskResumeAll();
800056b2:	f0 1f 00 02 	mcall	800056b8 <__malloc_unlock+0x8>
}
800056b6:	d8 02       	popm	pc
800056b8:	80 00       	ld.sh	r0,r0[0x0]
800056ba:	60 3c       	ld.w	r12,r0[0xc]

800056bc <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800056bc:	d4 21       	pushm	r4-r7,lr
800056be:	16 95       	mov	r5,r11
800056c0:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800056c2:	58 0c       	cp.w	r12,0
800056c4:	c0 30       	breq	800056ca <_read+0xe>
800056c6:	3f f7       	mov	r7,-1
800056c8:	c1 48       	rjmp	800056f0 <_read+0x34>
    return -1;

  for (; len > 0; --len)
800056ca:	58 0a       	cp.w	r10,0
800056cc:	e0 89 00 04 	brgt	800056d4 <_read+0x18>
800056d0:	30 07       	mov	r7,0
800056d2:	c0 f8       	rjmp	800056f0 <_read+0x34>
800056d4:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800056d6:	48 84       	lddpc	r4,800056f4 <_read+0x38>
800056d8:	68 0c       	ld.w	r12,r4[0x0]
800056da:	f0 1f 00 08 	mcall	800056f8 <_read+0x3c>
    if (c < 0)
800056de:	c0 95       	brlt	800056f0 <_read+0x34>
      break;

    *ptr++ = c;
800056e0:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800056e4:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800056e6:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800056ea:	58 08       	cp.w	r8,0
800056ec:	fe 99 ff f6 	brgt	800056d8 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800056f0:	0e 9c       	mov	r12,r7
800056f2:	d8 22       	popm	r4-r7,pc
800056f4:	00 00       	add	r0,r0
800056f6:	41 24       	lddsp	r4,sp[0x48]
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	52 88       	stdsp	sp[0xa0],r8

800056fc <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800056fc:	d4 21       	pushm	r4-r7,lr
800056fe:	16 95       	mov	r5,r11
80005700:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005702:	20 1c       	sub	r12,1
80005704:	58 2c       	cp.w	r12,2
80005706:	e0 8b 00 12 	brhi	8000572a <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000570a:	58 0a       	cp.w	r10,0
8000570c:	c0 31       	brne	80005712 <_write+0x16>
8000570e:	30 07       	mov	r7,0
80005710:	c0 e8       	rjmp	8000572c <_write+0x30>
80005712:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005714:	48 74       	lddpc	r4,80005730 <_write+0x34>
80005716:	68 0c       	ld.w	r12,r4[0x0]
80005718:	ea 07 07 0b 	ld.ub	r11,r5[r7]
8000571c:	f0 1f 00 06 	mcall	80005734 <_write+0x38>
80005720:	c0 55       	brlt	8000572a <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005722:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005724:	0e 36       	cp.w	r6,r7
80005726:	cf 81       	brne	80005716 <_write+0x1a>
80005728:	c0 28       	rjmp	8000572c <_write+0x30>
8000572a:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
8000572c:	0e 9c       	mov	r12,r7
8000572e:	d8 22       	popm	r4-r7,pc
80005730:	00 00       	add	r0,r0
80005732:	41 24       	lddsp	r4,sp[0x48]
80005734:	80 00       	ld.sh	r0,r0[0x0]
80005736:	52 38       	stdsp	sp[0x8c],r8

80005738 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005738:	eb cd 40 80 	pushm	r7,lr
8000573c:	18 97       	mov	r7,r12
	if( pv )
8000573e:	58 0c       	cp.w	r12,0
80005740:	c0 80       	breq	80005750 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005742:	f0 1f 00 05 	mcall	80005754 <vPortFree+0x1c>
		{
			free( pv );
80005746:	0e 9c       	mov	r12,r7
80005748:	f0 1f 00 04 	mcall	80005758 <vPortFree+0x20>
		}
		xTaskResumeAll();
8000574c:	f0 1f 00 04 	mcall	8000575c <vPortFree+0x24>
80005750:	e3 cd 80 80 	ldm	sp++,r7,pc
80005754:	80 00       	ld.sh	r0,r0[0x0]
80005756:	5c 80       	casts.h	r0
80005758:	80 00       	ld.sh	r0,r0[0x0]
8000575a:	6b ac       	ld.w	r12,r5[0x68]
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	60 3c       	ld.w	r12,r0[0xc]

80005760 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005760:	eb cd 40 80 	pushm	r7,lr
80005764:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005766:	f0 1f 00 06 	mcall	8000577c <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000576a:	0e 9c       	mov	r12,r7
8000576c:	f0 1f 00 05 	mcall	80005780 <pvPortMalloc+0x20>
80005770:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005772:	f0 1f 00 05 	mcall	80005784 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005776:	0e 9c       	mov	r12,r7
80005778:	e3 cd 80 80 	ldm	sp++,r7,pc
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	5c 80       	casts.h	r0
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	6b bc       	ld.w	r12,r5[0x6c]
80005784:	80 00       	ld.sh	r0,r0[0x0]
80005786:	60 3c       	ld.w	r12,r0[0xc]

80005788 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005788:	d4 01       	pushm	lr
8000578a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
8000578c:	78 09       	ld.w	r9,r12[0x0]
8000578e:	58 09       	cp.w	r9,0
80005790:	c1 10       	breq	800057b2 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005792:	78 3a       	ld.w	r10,r12[0xc]
80005794:	79 09       	ld.w	r9,r12[0x40]
80005796:	f4 09 00 09 	add	r9,r10,r9
8000579a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
8000579c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000579e:	14 39       	cp.w	r9,r10
800057a0:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
800057a4:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
800057a8:	79 0a       	ld.w	r10,r12[0x40]
800057aa:	78 3b       	ld.w	r11,r12[0xc]
800057ac:	10 9c       	mov	r12,r8
800057ae:	f0 1f 00 02 	mcall	800057b4 <prvCopyDataFromQueue+0x2c>
800057b2:	d8 02       	popm	pc
800057b4:	80 00       	ld.sh	r0,r0[0x0]
800057b6:	70 04       	ld.w	r4,r8[0x0]

800057b8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800057b8:	eb cd 40 c0 	pushm	r6-r7,lr
800057bc:	18 97       	mov	r7,r12
800057be:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800057c0:	78 e8       	ld.w	r8,r12[0x38]
800057c2:	58 08       	cp.w	r8,0
800057c4:	c0 31       	brne	800057ca <xQueueReceiveFromISR+0x12>
800057c6:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800057ca:	f0 1f 00 0e 	mcall	80005800 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800057ce:	6e e8       	ld.w	r8,r7[0x38]
800057d0:	20 18       	sub	r8,1
800057d2:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800057d4:	6f 18       	ld.w	r8,r7[0x44]
800057d6:	5b f8       	cp.w	r8,-1
800057d8:	c0 d1       	brne	800057f2 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800057da:	6e 48       	ld.w	r8,r7[0x10]
800057dc:	58 08       	cp.w	r8,0
800057de:	c0 f0       	breq	800057fc <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800057e0:	ee cc ff f0 	sub	r12,r7,-16
800057e4:	f0 1f 00 08 	mcall	80005804 <xQueueReceiveFromISR+0x4c>
800057e8:	c0 a0       	breq	800057fc <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800057ea:	30 1c       	mov	r12,1
800057ec:	8d 0c       	st.w	r6[0x0],r12
800057ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800057f2:	2f f8       	sub	r8,-1
800057f4:	ef 48 00 44 	st.w	r7[68],r8
800057f8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800057fc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	57 88       	stdsp	sp[0x1e0],r8
80005804:	80 00       	ld.sh	r0,r0[0x0]
80005806:	5e 18       	retne	r8

80005808 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005808:	eb cd 40 c0 	pushm	r6-r7,lr
8000580c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000580e:	f0 1f 00 23 	mcall	80005898 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005812:	6f 28       	ld.w	r8,r7[0x48]
80005814:	58 08       	cp.w	r8,0
80005816:	e0 8a 00 18 	brle	80005846 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000581a:	6e 98       	ld.w	r8,r7[0x24]
8000581c:	58 08       	cp.w	r8,0
8000581e:	c1 40       	breq	80005846 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005820:	ee c6 ff dc 	sub	r6,r7,-36
80005824:	c0 48       	rjmp	8000582c <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005826:	6e 98       	ld.w	r8,r7[0x24]
80005828:	58 08       	cp.w	r8,0
8000582a:	c0 e0       	breq	80005846 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000582c:	0c 9c       	mov	r12,r6
8000582e:	f0 1f 00 1c 	mcall	8000589c <prvUnlockQueue+0x94>
80005832:	c0 30       	breq	80005838 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005834:	f0 1f 00 1b 	mcall	800058a0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005838:	6f 28       	ld.w	r8,r7[0x48]
8000583a:	20 18       	sub	r8,1
8000583c:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005840:	58 08       	cp.w	r8,0
80005842:	fe 99 ff f2 	brgt	80005826 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005846:	3f f8       	mov	r8,-1
80005848:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
8000584c:	f0 1f 00 16 	mcall	800058a4 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005850:	f0 1f 00 12 	mcall	80005898 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005854:	6f 18       	ld.w	r8,r7[0x44]
80005856:	58 08       	cp.w	r8,0
80005858:	e0 8a 00 18 	brle	80005888 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000585c:	6e 48       	ld.w	r8,r7[0x10]
8000585e:	58 08       	cp.w	r8,0
80005860:	c1 40       	breq	80005888 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005862:	ee c6 ff f0 	sub	r6,r7,-16
80005866:	c0 48       	rjmp	8000586e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005868:	6e 48       	ld.w	r8,r7[0x10]
8000586a:	58 08       	cp.w	r8,0
8000586c:	c0 e0       	breq	80005888 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000586e:	0c 9c       	mov	r12,r6
80005870:	f0 1f 00 0b 	mcall	8000589c <prvUnlockQueue+0x94>
80005874:	c0 30       	breq	8000587a <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005876:	f0 1f 00 0b 	mcall	800058a0 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
8000587a:	6f 18       	ld.w	r8,r7[0x44]
8000587c:	20 18       	sub	r8,1
8000587e:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005882:	58 08       	cp.w	r8,0
80005884:	fe 99 ff f2 	brgt	80005868 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005888:	3f f8       	mov	r8,-1
8000588a:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000588e:	f0 1f 00 06 	mcall	800058a4 <prvUnlockQueue+0x9c>
}
80005892:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005896:	00 00       	add	r0,r0
80005898:	80 00       	ld.sh	r0,r0[0x0]
8000589a:	54 f4       	stdsp	sp[0x13c],r4
8000589c:	80 00       	ld.sh	r0,r0[0x0]
8000589e:	5e 18       	retne	r8
800058a0:	80 00       	ld.sh	r0,r0[0x0]
800058a2:	5d 24       	mustr	r4
800058a4:	80 00       	ld.sh	r0,r0[0x0]
800058a6:	56 00       	stdsp	sp[0x180],r0

800058a8 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800058a8:	d4 31       	pushm	r0-r7,lr
800058aa:	20 5d       	sub	sp,20
800058ac:	18 97       	mov	r7,r12
800058ae:	50 0b       	stdsp	sp[0x0],r11
800058b0:	50 2a       	stdsp	sp[0x8],r10
800058b2:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800058b4:	f8 c2 ff dc 	sub	r2,r12,-36
800058b8:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800058ba:	fa c4 ff f4 	sub	r4,sp,-12
800058be:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800058c0:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800058c2:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800058c6:	f0 1f 00 3e 	mcall	800059bc <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800058ca:	6e e8       	ld.w	r8,r7[0x38]
800058cc:	58 08       	cp.w	r8,0
800058ce:	c2 a0       	breq	80005922 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800058d0:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800058d2:	40 0b       	lddsp	r11,sp[0x0]
800058d4:	0e 9c       	mov	r12,r7
800058d6:	f0 1f 00 3b 	mcall	800059c0 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800058da:	40 18       	lddsp	r8,sp[0x4]
800058dc:	58 08       	cp.w	r8,0
800058de:	c1 51       	brne	80005908 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800058e0:	6e e8       	ld.w	r8,r7[0x38]
800058e2:	20 18       	sub	r8,1
800058e4:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800058e6:	6e 08       	ld.w	r8,r7[0x0]
800058e8:	58 08       	cp.w	r8,0
800058ea:	c0 41       	brne	800058f2 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800058ec:	f0 1f 00 36 	mcall	800059c4 <xQueueGenericReceive+0x11c>
800058f0:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800058f2:	6e 48       	ld.w	r8,r7[0x10]
800058f4:	58 08       	cp.w	r8,0
800058f6:	c1 20       	breq	8000591a <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800058f8:	ee cc ff f0 	sub	r12,r7,-16
800058fc:	f0 1f 00 33 	mcall	800059c8 <xQueueGenericReceive+0x120>
80005900:	58 1c       	cp.w	r12,1
80005902:	c0 c1       	brne	8000591a <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80005904:	d7 33       	scall
80005906:	c0 a8       	rjmp	8000591a <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80005908:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000590a:	6e 98       	ld.w	r8,r7[0x24]
8000590c:	58 08       	cp.w	r8,0
8000590e:	c0 60       	breq	8000591a <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005910:	04 9c       	mov	r12,r2
80005912:	f0 1f 00 2e 	mcall	800059c8 <xQueueGenericReceive+0x120>
80005916:	c0 20       	breq	8000591a <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005918:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000591a:	f0 1f 00 2d 	mcall	800059cc <xQueueGenericReceive+0x124>
8000591e:	30 1c       	mov	r12,1
				return pdPASS;
80005920:	c4 c8       	rjmp	800059b8 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005922:	40 28       	lddsp	r8,sp[0x8]
80005924:	58 08       	cp.w	r8,0
80005926:	c0 51       	brne	80005930 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005928:	f0 1f 00 29 	mcall	800059cc <xQueueGenericReceive+0x124>
8000592c:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000592e:	c4 58       	rjmp	800059b8 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80005930:	58 05       	cp.w	r5,0
80005932:	c0 51       	brne	8000593c <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005934:	08 9c       	mov	r12,r4
80005936:	f0 1f 00 27 	mcall	800059d0 <xQueueGenericReceive+0x128>
8000593a:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
8000593c:	f0 1f 00 24 	mcall	800059cc <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005940:	f0 1f 00 25 	mcall	800059d4 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005944:	f0 1f 00 1e 	mcall	800059bc <xQueueGenericReceive+0x114>
80005948:	6f 18       	ld.w	r8,r7[0x44]
8000594a:	5b f8       	cp.w	r8,-1
8000594c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005950:	6f 28       	ld.w	r8,r7[0x48]
80005952:	5b f8       	cp.w	r8,-1
80005954:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005958:	f0 1f 00 1d 	mcall	800059cc <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000595c:	06 9b       	mov	r11,r3
8000595e:	08 9c       	mov	r12,r4
80005960:	f0 1f 00 1e 	mcall	800059d8 <xQueueGenericReceive+0x130>
80005964:	c2 41       	brne	800059ac <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005966:	f0 1f 00 16 	mcall	800059bc <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000596a:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
8000596c:	f0 1f 00 18 	mcall	800059cc <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80005970:	58 06       	cp.w	r6,0
80005972:	c1 71       	brne	800059a0 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005974:	6e 08       	ld.w	r8,r7[0x0]
80005976:	58 08       	cp.w	r8,0
80005978:	c0 81       	brne	80005988 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000597a:	f0 1f 00 11 	mcall	800059bc <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000597e:	6e 1c       	ld.w	r12,r7[0x4]
80005980:	f0 1f 00 17 	mcall	800059dc <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005984:	f0 1f 00 12 	mcall	800059cc <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005988:	40 2b       	lddsp	r11,sp[0x8]
8000598a:	04 9c       	mov	r12,r2
8000598c:	f0 1f 00 15 	mcall	800059e0 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80005990:	0e 9c       	mov	r12,r7
80005992:	f0 1f 00 15 	mcall	800059e4 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005996:	f0 1f 00 15 	mcall	800059e8 <xQueueGenericReceive+0x140>
8000599a:	c9 61       	brne	800058c6 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
8000599c:	d7 33       	scall
8000599e:	c9 4b       	rjmp	800058c6 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800059a0:	0e 9c       	mov	r12,r7
800059a2:	f0 1f 00 11 	mcall	800059e4 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800059a6:	f0 1f 00 11 	mcall	800059e8 <xQueueGenericReceive+0x140>
800059aa:	c8 eb       	rjmp	800058c6 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800059ac:	0e 9c       	mov	r12,r7
800059ae:	f0 1f 00 0e 	mcall	800059e4 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800059b2:	f0 1f 00 0e 	mcall	800059e8 <xQueueGenericReceive+0x140>
800059b6:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800059b8:	2f bd       	sub	sp,-20
800059ba:	d8 32       	popm	r0-r7,pc
800059bc:	80 00       	ld.sh	r0,r0[0x0]
800059be:	54 f4       	stdsp	sp[0x13c],r4
800059c0:	80 00       	ld.sh	r0,r0[0x0]
800059c2:	57 88       	stdsp	sp[0x1e0],r8
800059c4:	80 00       	ld.sh	r0,r0[0x0]
800059c6:	5d 30       	musfr	r0
800059c8:	80 00       	ld.sh	r0,r0[0x0]
800059ca:	5e 18       	retne	r8
800059cc:	80 00       	ld.sh	r0,r0[0x0]
800059ce:	56 00       	stdsp	sp[0x180],r0
800059d0:	80 00       	ld.sh	r0,r0[0x0]
800059d2:	5d 0c       	ror	r12
800059d4:	80 00       	ld.sh	r0,r0[0x0]
800059d6:	5c 80       	casts.h	r0
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	5f a8       	srle	r8
800059dc:	80 00       	ld.sh	r0,r0[0x0]
800059de:	5d 94       	*unknown*
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	62 00       	ld.w	r0,r1[0x0]
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	58 08       	cp.w	r8,0
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	60 3c       	ld.w	r12,r0[0xc]

800059ec <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800059ec:	eb cd 40 80 	pushm	r7,lr
800059f0:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800059f2:	79 08       	ld.w	r8,r12[0x40]
800059f4:	58 08       	cp.w	r8,0
800059f6:	c0 a1       	brne	80005a0a <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800059f8:	78 08       	ld.w	r8,r12[0x0]
800059fa:	58 08       	cp.w	r8,0
800059fc:	c2 b1       	brne	80005a52 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800059fe:	78 1c       	ld.w	r12,r12[0x4]
80005a00:	f0 1f 00 17 	mcall	80005a5c <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80005a04:	30 08       	mov	r8,0
80005a06:	8f 18       	st.w	r7[0x4],r8
80005a08:	c2 58       	rjmp	80005a52 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005a0a:	58 0a       	cp.w	r10,0
80005a0c:	c1 01       	brne	80005a2c <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005a0e:	10 9a       	mov	r10,r8
80005a10:	78 2c       	ld.w	r12,r12[0x8]
80005a12:	f0 1f 00 14 	mcall	80005a60 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005a16:	6e 29       	ld.w	r9,r7[0x8]
80005a18:	6f 08       	ld.w	r8,r7[0x40]
80005a1a:	f2 08 00 08 	add	r8,r9,r8
80005a1e:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80005a20:	6e 19       	ld.w	r9,r7[0x4]
80005a22:	12 38       	cp.w	r8,r9
80005a24:	c1 73       	brcs	80005a52 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005a26:	6e 08       	ld.w	r8,r7[0x0]
80005a28:	8f 28       	st.w	r7[0x8],r8
80005a2a:	c1 48       	rjmp	80005a52 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005a2c:	10 9a       	mov	r10,r8
80005a2e:	78 3c       	ld.w	r12,r12[0xc]
80005a30:	f0 1f 00 0c 	mcall	80005a60 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005a34:	6f 08       	ld.w	r8,r7[0x40]
80005a36:	6e 39       	ld.w	r9,r7[0xc]
80005a38:	f2 08 01 08 	sub	r8,r9,r8
80005a3c:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80005a3e:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80005a40:	12 38       	cp.w	r8,r9
80005a42:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005a46:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005a4a:	f3 d8 e3 19 	subcs	r9,r9,r8
80005a4e:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80005a52:	6e e8       	ld.w	r8,r7[0x38]
80005a54:	2f f8       	sub	r8,-1
80005a56:	8f e8       	st.w	r7[0x38],r8
}
80005a58:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a5c:	80 00       	ld.sh	r0,r0[0x0]
80005a5e:	5d 3c       	musfr	r12
80005a60:	80 00       	ld.sh	r0,r0[0x0]
80005a62:	70 04       	ld.w	r4,r8[0x0]

80005a64 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005a64:	eb cd 40 c0 	pushm	r6-r7,lr
80005a68:	18 97       	mov	r7,r12
80005a6a:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005a6c:	78 ec       	ld.w	r12,r12[0x38]
80005a6e:	6e f8       	ld.w	r8,r7[0x3c]
80005a70:	10 3c       	cp.w	r12,r8
80005a72:	c0 33       	brcs	80005a78 <xQueueGenericSendFromISR+0x14>
80005a74:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005a78:	12 9a       	mov	r10,r9
80005a7a:	0e 9c       	mov	r12,r7
80005a7c:	f0 1f 00 0c 	mcall	80005aac <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80005a80:	6f 28       	ld.w	r8,r7[0x48]
80005a82:	5b f8       	cp.w	r8,-1
80005a84:	c0 d1       	brne	80005a9e <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005a86:	6e 98       	ld.w	r8,r7[0x24]
80005a88:	58 08       	cp.w	r8,0
80005a8a:	c0 f0       	breq	80005aa8 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005a8c:	ee cc ff dc 	sub	r12,r7,-36
80005a90:	f0 1f 00 08 	mcall	80005ab0 <xQueueGenericSendFromISR+0x4c>
80005a94:	c0 a0       	breq	80005aa8 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005a96:	30 1c       	mov	r12,1
80005a98:	8d 0c       	st.w	r6[0x0],r12
80005a9a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80005a9e:	2f f8       	sub	r8,-1
80005aa0:	ef 48 00 48 	st.w	r7[72],r8
80005aa4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005aa8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005aac:	80 00       	ld.sh	r0,r0[0x0]
80005aae:	59 ec       	cp.w	r12,30
80005ab0:	80 00       	ld.sh	r0,r0[0x0]
80005ab2:	5e 18       	retne	r8

80005ab4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005ab4:	d4 31       	pushm	r0-r7,lr
80005ab6:	20 5d       	sub	sp,20
80005ab8:	18 97       	mov	r7,r12
80005aba:	50 0b       	stdsp	sp[0x0],r11
80005abc:	50 2a       	stdsp	sp[0x8],r10
80005abe:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005ac0:	f8 c0 ff f0 	sub	r0,r12,-16
80005ac4:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005ac6:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005aca:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005acc:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80005ad0:	f0 1f 00 2f 	mcall	80005b8c <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005ad4:	6e e9       	ld.w	r9,r7[0x38]
80005ad6:	6e f8       	ld.w	r8,r7[0x3c]
80005ad8:	10 39       	cp.w	r9,r8
80005ada:	c1 42       	brcc	80005b02 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005adc:	40 1a       	lddsp	r10,sp[0x4]
80005ade:	40 0b       	lddsp	r11,sp[0x0]
80005ae0:	0e 9c       	mov	r12,r7
80005ae2:	f0 1f 00 2c 	mcall	80005b90 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005ae6:	6e 98       	ld.w	r8,r7[0x24]
80005ae8:	58 08       	cp.w	r8,0
80005aea:	c0 80       	breq	80005afa <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005aec:	ee cc ff dc 	sub	r12,r7,-36
80005af0:	f0 1f 00 29 	mcall	80005b94 <xQueueGenericSend+0xe0>
80005af4:	58 1c       	cp.w	r12,1
80005af6:	c0 21       	brne	80005afa <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005af8:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005afa:	f0 1f 00 28 	mcall	80005b98 <xQueueGenericSend+0xe4>
80005afe:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80005b00:	c4 38       	rjmp	80005b86 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80005b02:	40 28       	lddsp	r8,sp[0x8]
80005b04:	58 08       	cp.w	r8,0
80005b06:	c0 51       	brne	80005b10 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005b08:	f0 1f 00 24 	mcall	80005b98 <xQueueGenericSend+0xe4>
80005b0c:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80005b0e:	c3 c8       	rjmp	80005b86 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80005b10:	58 04       	cp.w	r4,0
80005b12:	c0 51       	brne	80005b1c <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005b14:	06 9c       	mov	r12,r3
80005b16:	f0 1f 00 22 	mcall	80005b9c <xQueueGenericSend+0xe8>
80005b1a:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005b1c:	f0 1f 00 1f 	mcall	80005b98 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80005b20:	f0 1f 00 20 	mcall	80005ba0 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005b24:	f0 1f 00 1a 	mcall	80005b8c <xQueueGenericSend+0xd8>
80005b28:	6f 18       	ld.w	r8,r7[0x44]
80005b2a:	5b f8       	cp.w	r8,-1
80005b2c:	ef f1 0a 11 	st.weq	r7[0x44],r1
80005b30:	6f 28       	ld.w	r8,r7[0x48]
80005b32:	5b f8       	cp.w	r8,-1
80005b34:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005b38:	f0 1f 00 18 	mcall	80005b98 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005b3c:	04 9b       	mov	r11,r2
80005b3e:	06 9c       	mov	r12,r3
80005b40:	f0 1f 00 19 	mcall	80005ba4 <xQueueGenericSend+0xf0>
80005b44:	c1 b1       	brne	80005b7a <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005b46:	f0 1f 00 12 	mcall	80005b8c <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005b4a:	6e e5       	ld.w	r5,r7[0x38]
80005b4c:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005b4e:	f0 1f 00 13 	mcall	80005b98 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80005b52:	0c 35       	cp.w	r5,r6
80005b54:	c0 d1       	brne	80005b6e <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005b56:	40 2b       	lddsp	r11,sp[0x8]
80005b58:	00 9c       	mov	r12,r0
80005b5a:	f0 1f 00 14 	mcall	80005ba8 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005b5e:	0e 9c       	mov	r12,r7
80005b60:	f0 1f 00 13 	mcall	80005bac <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005b64:	f0 1f 00 13 	mcall	80005bb0 <xQueueGenericSend+0xfc>
80005b68:	cb 41       	brne	80005ad0 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005b6a:	d7 33       	scall
80005b6c:	cb 2b       	rjmp	80005ad0 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005b6e:	0e 9c       	mov	r12,r7
80005b70:	f0 1f 00 0f 	mcall	80005bac <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005b74:	f0 1f 00 0f 	mcall	80005bb0 <xQueueGenericSend+0xfc>
80005b78:	ca cb       	rjmp	80005ad0 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005b7a:	0e 9c       	mov	r12,r7
80005b7c:	f0 1f 00 0c 	mcall	80005bac <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005b80:	f0 1f 00 0c 	mcall	80005bb0 <xQueueGenericSend+0xfc>
80005b84:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005b86:	2f bd       	sub	sp,-20
80005b88:	d8 32       	popm	r0-r7,pc
80005b8a:	00 00       	add	r0,r0
80005b8c:	80 00       	ld.sh	r0,r0[0x0]
80005b8e:	54 f4       	stdsp	sp[0x13c],r4
80005b90:	80 00       	ld.sh	r0,r0[0x0]
80005b92:	59 ec       	cp.w	r12,30
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	5e 18       	retne	r8
80005b98:	80 00       	ld.sh	r0,r0[0x0]
80005b9a:	56 00       	stdsp	sp[0x180],r0
80005b9c:	80 00       	ld.sh	r0,r0[0x0]
80005b9e:	5d 0c       	ror	r12
80005ba0:	80 00       	ld.sh	r0,r0[0x0]
80005ba2:	5c 80       	casts.h	r0
80005ba4:	80 00       	ld.sh	r0,r0[0x0]
80005ba6:	5f a8       	srle	r8
80005ba8:	80 00       	ld.sh	r0,r0[0x0]
80005baa:	62 00       	ld.w	r0,r1[0x0]
80005bac:	80 00       	ld.sh	r0,r0[0x0]
80005bae:	58 08       	cp.w	r8,0
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	60 3c       	ld.w	r12,r0[0xc]

80005bb4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005bb4:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005bb8:	34 cc       	mov	r12,76
80005bba:	f0 1f 00 12 	mcall	80005c00 <xQueueCreateMutex+0x4c>
80005bbe:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80005bc0:	c1 d0       	breq	80005bfa <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80005bc2:	30 06       	mov	r6,0
80005bc4:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005bc6:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005bc8:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80005bca:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005bcc:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80005bce:	30 18       	mov	r8,1
80005bd0:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80005bd2:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80005bd6:	3f f8       	mov	r8,-1
80005bd8:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80005bdc:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005be0:	2f 0c       	sub	r12,-16
80005be2:	f0 1f 00 09 	mcall	80005c04 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005be6:	ee cc ff dc 	sub	r12,r7,-36
80005bea:	f0 1f 00 07 	mcall	80005c04 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80005bee:	0c 99       	mov	r9,r6
80005bf0:	0c 9a       	mov	r10,r6
80005bf2:	0c 9b       	mov	r11,r6
80005bf4:	0e 9c       	mov	r12,r7
80005bf6:	f0 1f 00 05 	mcall	80005c08 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80005bfa:	0e 9c       	mov	r12,r7
80005bfc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	57 60       	stdsp	sp[0x1d8],r0
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	53 d0       	stdsp	sp[0xf4],r0
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	5a b4       	cp.w	r4,-21

80005c0c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005c0c:	d4 21       	pushm	r4-r7,lr
80005c0e:	18 97       	mov	r7,r12
80005c10:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80005c12:	58 0c       	cp.w	r12,0
80005c14:	c2 f0       	breq	80005c72 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005c16:	34 cc       	mov	r12,76
80005c18:	f0 1f 00 17 	mcall	80005c74 <xQueueCreate+0x68>
80005c1c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005c1e:	c2 a0       	breq	80005c72 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005c20:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005c24:	e8 cc ff ff 	sub	r12,r4,-1
80005c28:	f0 1f 00 13 	mcall	80005c74 <xQueueCreate+0x68>
80005c2c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005c2e:	c1 e0       	breq	80005c6a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005c30:	f8 04 00 04 	add	r4,r12,r4
80005c34:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005c36:	30 08       	mov	r8,0
80005c38:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005c3a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005c3c:	ee c8 00 01 	sub	r8,r7,1
80005c40:	ad 38       	mul	r8,r6
80005c42:	10 0c       	add	r12,r8
80005c44:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005c46:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005c48:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005c4c:	3f f8       	mov	r8,-1
80005c4e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005c52:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005c56:	ea cc ff f0 	sub	r12,r5,-16
80005c5a:	f0 1f 00 08 	mcall	80005c78 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005c5e:	ea cc ff dc 	sub	r12,r5,-36
80005c62:	f0 1f 00 06 	mcall	80005c78 <xQueueCreate+0x6c>
80005c66:	0a 9c       	mov	r12,r5
80005c68:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005c6a:	0a 9c       	mov	r12,r5
80005c6c:	f0 1f 00 04 	mcall	80005c7c <xQueueCreate+0x70>
80005c70:	d8 2a       	popm	r4-r7,pc,r12=0
80005c72:	d8 2a       	popm	r4-r7,pc,r12=0
80005c74:	80 00       	ld.sh	r0,r0[0x0]
80005c76:	57 60       	stdsp	sp[0x1d8],r0
80005c78:	80 00       	ld.sh	r0,r0[0x0]
80005c7a:	53 d0       	stdsp	sp[0xf4],r0
80005c7c:	80 00       	ld.sh	r0,r0[0x0]
80005c7e:	57 38       	stdsp	sp[0x1cc],r8

80005c80 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005c80:	48 38       	lddpc	r8,80005c8c <vTaskSuspendAll+0xc>
80005c82:	70 09       	ld.w	r9,r8[0x0]
80005c84:	2f f9       	sub	r9,-1
80005c86:	91 09       	st.w	r8[0x0],r9
}
80005c88:	5e fc       	retal	r12
80005c8a:	00 00       	add	r0,r0
80005c8c:	00 00       	add	r0,r0
80005c8e:	0d 48       	ld.w	r8,--r6

80005c90 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005c90:	49 a8       	lddpc	r8,80005cf8 <vTaskSwitchContext+0x68>
80005c92:	70 08       	ld.w	r8,r8[0x0]
80005c94:	58 08       	cp.w	r8,0
80005c96:	c0 b1       	brne	80005cac <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005c98:	49 98       	lddpc	r8,80005cfc <vTaskSwitchContext+0x6c>
80005c9a:	70 08       	ld.w	r8,r8[0x0]
80005c9c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005ca0:	49 89       	lddpc	r9,80005d00 <vTaskSwitchContext+0x70>
80005ca2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005ca6:	58 08       	cp.w	r8,0
80005ca8:	c0 60       	breq	80005cb4 <vTaskSwitchContext+0x24>
80005caa:	c1 18       	rjmp	80005ccc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005cac:	30 19       	mov	r9,1
80005cae:	49 68       	lddpc	r8,80005d04 <vTaskSwitchContext+0x74>
80005cb0:	91 09       	st.w	r8[0x0],r9
80005cb2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005cb4:	49 28       	lddpc	r8,80005cfc <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005cb6:	49 3a       	lddpc	r10,80005d00 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005cb8:	70 09       	ld.w	r9,r8[0x0]
80005cba:	20 19       	sub	r9,1
80005cbc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005cbe:	70 09       	ld.w	r9,r8[0x0]
80005cc0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005cc4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005cc8:	58 09       	cp.w	r9,0
80005cca:	cf 70       	breq	80005cb8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005ccc:	48 c8       	lddpc	r8,80005cfc <vTaskSwitchContext+0x6c>
80005cce:	70 08       	ld.w	r8,r8[0x0]
80005cd0:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005cd4:	48 b9       	lddpc	r9,80005d00 <vTaskSwitchContext+0x70>
80005cd6:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005cda:	70 19       	ld.w	r9,r8[0x4]
80005cdc:	72 19       	ld.w	r9,r9[0x4]
80005cde:	91 19       	st.w	r8[0x4],r9
80005ce0:	f0 ca ff f8 	sub	r10,r8,-8
80005ce4:	14 39       	cp.w	r9,r10
80005ce6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005cea:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005cee:	70 18       	ld.w	r8,r8[0x4]
80005cf0:	70 39       	ld.w	r9,r8[0xc]
80005cf2:	48 68       	lddpc	r8,80005d08 <vTaskSwitchContext+0x78>
80005cf4:	91 09       	st.w	r8[0x0],r9
80005cf6:	5e fc       	retal	r12
80005cf8:	00 00       	add	r0,r0
80005cfa:	0d 48       	ld.w	r8,--r6
80005cfc:	00 00       	add	r0,r0
80005cfe:	0d 80       	ld.ub	r0,r6[0x0]
80005d00:	00 00       	add	r0,r0
80005d02:	0c 64       	and	r4,r6
80005d04:	00 00       	add	r0,r0
80005d06:	0d 68       	ld.uh	r8,--r6
80005d08:	00 00       	add	r0,r0
80005d0a:	0d 18       	ld.sh	r8,r6++

80005d0c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005d0c:	48 48       	lddpc	r8,80005d1c <vTaskSetTimeOutState+0x10>
80005d0e:	70 08       	ld.w	r8,r8[0x0]
80005d10:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005d12:	48 48       	lddpc	r8,80005d20 <vTaskSetTimeOutState+0x14>
80005d14:	70 08       	ld.w	r8,r8[0x0]
80005d16:	99 18       	st.w	r12[0x4],r8
}
80005d18:	5e fc       	retal	r12
80005d1a:	00 00       	add	r0,r0
80005d1c:	00 00       	add	r0,r0
80005d1e:	0c 5c       	eor	r12,r6
80005d20:	00 00       	add	r0,r0
80005d22:	0d 44       	ld.w	r4,--r6

80005d24 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005d24:	30 19       	mov	r9,1
80005d26:	48 28       	lddpc	r8,80005d2c <vTaskMissedYield+0x8>
80005d28:	91 09       	st.w	r8[0x0],r9
}
80005d2a:	5e fc       	retal	r12
80005d2c:	00 00       	add	r0,r0
80005d2e:	0d 68       	ld.uh	r8,--r6

80005d30 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005d30:	48 28       	lddpc	r8,80005d38 <xTaskGetCurrentTaskHandle+0x8>
80005d32:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005d34:	5e fc       	retal	r12
80005d36:	00 00       	add	r0,r0
80005d38:	00 00       	add	r0,r0
80005d3a:	0d 18       	ld.sh	r8,r6++

80005d3c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005d3c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005d40:	58 0c       	cp.w	r12,0
80005d42:	c1 f0       	breq	80005d80 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005d44:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005d46:	78 b9       	ld.w	r9,r12[0x2c]
80005d48:	79 18       	ld.w	r8,r12[0x44]
80005d4a:	10 39       	cp.w	r9,r8
80005d4c:	c1 a0       	breq	80005d80 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005d4e:	f8 c6 ff fc 	sub	r6,r12,-4
80005d52:	0c 9c       	mov	r12,r6
80005d54:	f0 1f 00 0c 	mcall	80005d84 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005d58:	6f 1c       	ld.w	r12,r7[0x44]
80005d5a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005d5c:	f8 08 11 08 	rsub	r8,r12,8
80005d60:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005d62:	48 a8       	lddpc	r8,80005d88 <vTaskPriorityDisinherit+0x4c>
80005d64:	70 08       	ld.w	r8,r8[0x0]
80005d66:	10 3c       	cp.w	r12,r8
80005d68:	e0 88 00 04 	brls	80005d70 <vTaskPriorityDisinherit+0x34>
80005d6c:	48 78       	lddpc	r8,80005d88 <vTaskPriorityDisinherit+0x4c>
80005d6e:	91 0c       	st.w	r8[0x0],r12
80005d70:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005d74:	0c 9b       	mov	r11,r6
80005d76:	48 68       	lddpc	r8,80005d8c <vTaskPriorityDisinherit+0x50>
80005d78:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005d7c:	f0 1f 00 05 	mcall	80005d90 <vTaskPriorityDisinherit+0x54>
80005d80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d84:	80 00       	ld.sh	r0,r0[0x0]
80005d86:	54 3a       	stdsp	sp[0x10c],r10
80005d88:	00 00       	add	r0,r0
80005d8a:	0d 80       	ld.ub	r0,r6[0x0]
80005d8c:	00 00       	add	r0,r0
80005d8e:	0c 64       	and	r4,r6
80005d90:	80 00       	ld.sh	r0,r0[0x0]
80005d92:	53 ea       	stdsp	sp[0xf8],r10

80005d94 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005d94:	eb cd 40 c0 	pushm	r6-r7,lr
80005d98:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005d9a:	49 b8       	lddpc	r8,80005e04 <vTaskPriorityInherit+0x70>
80005d9c:	70 08       	ld.w	r8,r8[0x0]
80005d9e:	78 b9       	ld.w	r9,r12[0x2c]
80005da0:	70 b8       	ld.w	r8,r8[0x2c]
80005da2:	10 39       	cp.w	r9,r8
80005da4:	c2 d2       	brcc	80005dfe <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005da6:	49 88       	lddpc	r8,80005e04 <vTaskPriorityInherit+0x70>
80005da8:	70 08       	ld.w	r8,r8[0x0]
80005daa:	70 b8       	ld.w	r8,r8[0x2c]
80005dac:	f0 08 11 08 	rsub	r8,r8,8
80005db0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005db2:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005db6:	49 59       	lddpc	r9,80005e08 <vTaskPriorityInherit+0x74>
80005db8:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005dbc:	78 59       	ld.w	r9,r12[0x14]
80005dbe:	10 39       	cp.w	r9,r8
80005dc0:	c1 b1       	brne	80005df6 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005dc2:	f8 c6 ff fc 	sub	r6,r12,-4
80005dc6:	0c 9c       	mov	r12,r6
80005dc8:	f0 1f 00 11 	mcall	80005e0c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005dcc:	48 e8       	lddpc	r8,80005e04 <vTaskPriorityInherit+0x70>
80005dce:	70 08       	ld.w	r8,r8[0x0]
80005dd0:	70 bc       	ld.w	r12,r8[0x2c]
80005dd2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005dd4:	48 f8       	lddpc	r8,80005e10 <vTaskPriorityInherit+0x7c>
80005dd6:	70 08       	ld.w	r8,r8[0x0]
80005dd8:	10 3c       	cp.w	r12,r8
80005dda:	e0 88 00 04 	brls	80005de2 <vTaskPriorityInherit+0x4e>
80005dde:	48 d8       	lddpc	r8,80005e10 <vTaskPriorityInherit+0x7c>
80005de0:	91 0c       	st.w	r8[0x0],r12
80005de2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005de6:	0c 9b       	mov	r11,r6
80005de8:	48 88       	lddpc	r8,80005e08 <vTaskPriorityInherit+0x74>
80005dea:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005dee:	f0 1f 00 0a 	mcall	80005e14 <vTaskPriorityInherit+0x80>
80005df2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005df6:	48 48       	lddpc	r8,80005e04 <vTaskPriorityInherit+0x70>
80005df8:	70 08       	ld.w	r8,r8[0x0]
80005dfa:	70 b8       	ld.w	r8,r8[0x2c]
80005dfc:	99 b8       	st.w	r12[0x2c],r8
80005dfe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e02:	00 00       	add	r0,r0
80005e04:	00 00       	add	r0,r0
80005e06:	0d 18       	ld.sh	r8,r6++
80005e08:	00 00       	add	r0,r0
80005e0a:	0c 64       	and	r4,r6
80005e0c:	80 00       	ld.sh	r0,r0[0x0]
80005e0e:	54 3a       	stdsp	sp[0x10c],r10
80005e10:	00 00       	add	r0,r0
80005e12:	0d 80       	ld.ub	r0,r6[0x0]
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	53 ea       	stdsp	sp[0xf8],r10

80005e18 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005e18:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005e1c:	78 38       	ld.w	r8,r12[0xc]
80005e1e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005e20:	ee c6 ff e8 	sub	r6,r7,-24
80005e24:	0c 9c       	mov	r12,r6
80005e26:	f0 1f 00 15 	mcall	80005e78 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005e2a:	49 58       	lddpc	r8,80005e7c <xTaskRemoveFromEventList+0x64>
80005e2c:	70 08       	ld.w	r8,r8[0x0]
80005e2e:	58 08       	cp.w	r8,0
80005e30:	c1 71       	brne	80005e5e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005e32:	ee c6 ff fc 	sub	r6,r7,-4
80005e36:	0c 9c       	mov	r12,r6
80005e38:	f0 1f 00 10 	mcall	80005e78 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005e3c:	6e bc       	ld.w	r12,r7[0x2c]
80005e3e:	49 18       	lddpc	r8,80005e80 <xTaskRemoveFromEventList+0x68>
80005e40:	70 08       	ld.w	r8,r8[0x0]
80005e42:	10 3c       	cp.w	r12,r8
80005e44:	e0 88 00 04 	brls	80005e4c <xTaskRemoveFromEventList+0x34>
80005e48:	48 e8       	lddpc	r8,80005e80 <xTaskRemoveFromEventList+0x68>
80005e4a:	91 0c       	st.w	r8[0x0],r12
80005e4c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005e50:	0c 9b       	mov	r11,r6
80005e52:	48 d8       	lddpc	r8,80005e84 <xTaskRemoveFromEventList+0x6c>
80005e54:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005e58:	f0 1f 00 0c 	mcall	80005e88 <xTaskRemoveFromEventList+0x70>
80005e5c:	c0 58       	rjmp	80005e66 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005e5e:	0c 9b       	mov	r11,r6
80005e60:	48 bc       	lddpc	r12,80005e8c <xTaskRemoveFromEventList+0x74>
80005e62:	f0 1f 00 0a 	mcall	80005e88 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005e66:	48 b8       	lddpc	r8,80005e90 <xTaskRemoveFromEventList+0x78>
80005e68:	70 08       	ld.w	r8,r8[0x0]
80005e6a:	6e b9       	ld.w	r9,r7[0x2c]
80005e6c:	70 b8       	ld.w	r8,r8[0x2c]
80005e6e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005e70:	5f 2c       	srhs	r12
80005e72:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e76:	00 00       	add	r0,r0
80005e78:	80 00       	ld.sh	r0,r0[0x0]
80005e7a:	54 3a       	stdsp	sp[0x10c],r10
80005e7c:	00 00       	add	r0,r0
80005e7e:	0d 48       	ld.w	r8,--r6
80005e80:	00 00       	add	r0,r0
80005e82:	0d 80       	ld.ub	r0,r6[0x0]
80005e84:	00 00       	add	r0,r0
80005e86:	0c 64       	and	r4,r6
80005e88:	80 00       	ld.sh	r0,r0[0x0]
80005e8a:	53 ea       	stdsp	sp[0xf8],r10
80005e8c:	00 00       	add	r0,r0
80005e8e:	0d 1c       	ld.sh	r12,r6++
80005e90:	00 00       	add	r0,r0
80005e92:	0d 18       	ld.sh	r8,r6++

80005e94 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005e94:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005e98:	4b 98       	lddpc	r8,80005f7c <vTaskIncrementTick+0xe8>
80005e9a:	70 08       	ld.w	r8,r8[0x0]
80005e9c:	58 08       	cp.w	r8,0
80005e9e:	c6 91       	brne	80005f70 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005ea0:	4b 88       	lddpc	r8,80005f80 <vTaskIncrementTick+0xec>
80005ea2:	70 09       	ld.w	r9,r8[0x0]
80005ea4:	2f f9       	sub	r9,-1
80005ea6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005ea8:	70 08       	ld.w	r8,r8[0x0]
80005eaa:	58 08       	cp.w	r8,0
80005eac:	c1 a1       	brne	80005ee0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005eae:	4b 68       	lddpc	r8,80005f84 <vTaskIncrementTick+0xf0>
80005eb0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005eb2:	4b 69       	lddpc	r9,80005f88 <vTaskIncrementTick+0xf4>
80005eb4:	72 0b       	ld.w	r11,r9[0x0]
80005eb6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005eb8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005eba:	4b 59       	lddpc	r9,80005f8c <vTaskIncrementTick+0xf8>
80005ebc:	72 0a       	ld.w	r10,r9[0x0]
80005ebe:	2f fa       	sub	r10,-1
80005ec0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005ec2:	70 08       	ld.w	r8,r8[0x0]
80005ec4:	70 08       	ld.w	r8,r8[0x0]
80005ec6:	58 08       	cp.w	r8,0
80005ec8:	c0 51       	brne	80005ed2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005eca:	3f f9       	mov	r9,-1
80005ecc:	4b 18       	lddpc	r8,80005f90 <vTaskIncrementTick+0xfc>
80005ece:	91 09       	st.w	r8[0x0],r9
80005ed0:	c0 88       	rjmp	80005ee0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005ed2:	4a d8       	lddpc	r8,80005f84 <vTaskIncrementTick+0xf0>
80005ed4:	70 08       	ld.w	r8,r8[0x0]
80005ed6:	70 38       	ld.w	r8,r8[0xc]
80005ed8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005eda:	70 19       	ld.w	r9,r8[0x4]
80005edc:	4a d8       	lddpc	r8,80005f90 <vTaskIncrementTick+0xfc>
80005ede:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005ee0:	4a 88       	lddpc	r8,80005f80 <vTaskIncrementTick+0xec>
80005ee2:	70 09       	ld.w	r9,r8[0x0]
80005ee4:	4a b8       	lddpc	r8,80005f90 <vTaskIncrementTick+0xfc>
80005ee6:	70 08       	ld.w	r8,r8[0x0]
80005ee8:	10 39       	cp.w	r9,r8
80005eea:	c4 73       	brcs	80005f78 <vTaskIncrementTick+0xe4>
80005eec:	4a 68       	lddpc	r8,80005f84 <vTaskIncrementTick+0xf0>
80005eee:	70 08       	ld.w	r8,r8[0x0]
80005ef0:	70 08       	ld.w	r8,r8[0x0]
80005ef2:	58 08       	cp.w	r8,0
80005ef4:	c0 c0       	breq	80005f0c <vTaskIncrementTick+0x78>
80005ef6:	4a 48       	lddpc	r8,80005f84 <vTaskIncrementTick+0xf0>
80005ef8:	70 08       	ld.w	r8,r8[0x0]
80005efa:	70 38       	ld.w	r8,r8[0xc]
80005efc:	70 37       	ld.w	r7,r8[0xc]
80005efe:	6e 18       	ld.w	r8,r7[0x4]
80005f00:	4a 09       	lddpc	r9,80005f80 <vTaskIncrementTick+0xec>
80005f02:	72 09       	ld.w	r9,r9[0x0]
80005f04:	12 38       	cp.w	r8,r9
80005f06:	e0 88 00 14 	brls	80005f2e <vTaskIncrementTick+0x9a>
80005f0a:	c0 e8       	rjmp	80005f26 <vTaskIncrementTick+0x92>
80005f0c:	3f f9       	mov	r9,-1
80005f0e:	4a 18       	lddpc	r8,80005f90 <vTaskIncrementTick+0xfc>
80005f10:	91 09       	st.w	r8[0x0],r9
80005f12:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005f16:	6a 08       	ld.w	r8,r5[0x0]
80005f18:	70 38       	ld.w	r8,r8[0xc]
80005f1a:	70 37       	ld.w	r7,r8[0xc]
80005f1c:	6e 18       	ld.w	r8,r7[0x4]
80005f1e:	64 09       	ld.w	r9,r2[0x0]
80005f20:	12 38       	cp.w	r8,r9
80005f22:	e0 88 00 0a 	brls	80005f36 <vTaskIncrementTick+0xa2>
80005f26:	49 b9       	lddpc	r9,80005f90 <vTaskIncrementTick+0xfc>
80005f28:	93 08       	st.w	r9[0x0],r8
80005f2a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005f2e:	49 a4       	lddpc	r4,80005f94 <vTaskIncrementTick+0x100>
80005f30:	49 a3       	lddpc	r3,80005f98 <vTaskIncrementTick+0x104>
80005f32:	49 55       	lddpc	r5,80005f84 <vTaskIncrementTick+0xf0>
80005f34:	49 32       	lddpc	r2,80005f80 <vTaskIncrementTick+0xec>
80005f36:	ee c6 ff fc 	sub	r6,r7,-4
80005f3a:	0c 9c       	mov	r12,r6
80005f3c:	f0 1f 00 18 	mcall	80005f9c <vTaskIncrementTick+0x108>
80005f40:	6e a8       	ld.w	r8,r7[0x28]
80005f42:	58 08       	cp.w	r8,0
80005f44:	c0 50       	breq	80005f4e <vTaskIncrementTick+0xba>
80005f46:	ee cc ff e8 	sub	r12,r7,-24
80005f4a:	f0 1f 00 15 	mcall	80005f9c <vTaskIncrementTick+0x108>
80005f4e:	6e bc       	ld.w	r12,r7[0x2c]
80005f50:	68 08       	ld.w	r8,r4[0x0]
80005f52:	10 3c       	cp.w	r12,r8
80005f54:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005f58:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005f5c:	0c 9b       	mov	r11,r6
80005f5e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005f62:	f0 1f 00 10 	mcall	80005fa0 <vTaskIncrementTick+0x10c>
80005f66:	6a 08       	ld.w	r8,r5[0x0]
80005f68:	70 08       	ld.w	r8,r8[0x0]
80005f6a:	58 08       	cp.w	r8,0
80005f6c:	cd 51       	brne	80005f16 <vTaskIncrementTick+0x82>
80005f6e:	cc fb       	rjmp	80005f0c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005f70:	48 d8       	lddpc	r8,80005fa4 <vTaskIncrementTick+0x110>
80005f72:	70 09       	ld.w	r9,r8[0x0]
80005f74:	2f f9       	sub	r9,-1
80005f76:	91 09       	st.w	r8[0x0],r9
80005f78:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005f7c:	00 00       	add	r0,r0
80005f7e:	0d 48       	ld.w	r8,--r6
80005f80:	00 00       	add	r0,r0
80005f82:	0d 44       	ld.w	r4,--r6
80005f84:	00 00       	add	r0,r0
80005f86:	0c 50       	eor	r0,r6
80005f88:	00 00       	add	r0,r0
80005f8a:	0c 60       	and	r0,r6
80005f8c:	00 00       	add	r0,r0
80005f8e:	0c 5c       	eor	r12,r6
80005f90:	00 00       	add	r0,r0
80005f92:	05 2c       	ld.uh	r12,r2++
80005f94:	00 00       	add	r0,r0
80005f96:	0d 80       	ld.ub	r0,r6[0x0]
80005f98:	00 00       	add	r0,r0
80005f9a:	0c 64       	and	r4,r6
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	54 3a       	stdsp	sp[0x10c],r10
80005fa0:	80 00       	ld.sh	r0,r0[0x0]
80005fa2:	53 ea       	stdsp	sp[0xf8],r10
80005fa4:	00 00       	add	r0,r0
80005fa6:	0c 48       	or	r8,r6

80005fa8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005fa8:	eb cd 40 c0 	pushm	r6-r7,lr
80005fac:	18 97       	mov	r7,r12
80005fae:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005fb0:	f0 1f 00 15 	mcall	80006004 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005fb4:	6c 08       	ld.w	r8,r6[0x0]
80005fb6:	5b f8       	cp.w	r8,-1
80005fb8:	c0 31       	brne	80005fbe <xTaskCheckForTimeOut+0x16>
80005fba:	30 07       	mov	r7,0
80005fbc:	c1 f8       	rjmp	80005ffa <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005fbe:	49 39       	lddpc	r9,80006008 <xTaskCheckForTimeOut+0x60>
80005fc0:	72 09       	ld.w	r9,r9[0x0]
80005fc2:	6e 0a       	ld.w	r10,r7[0x0]
80005fc4:	12 3a       	cp.w	r10,r9
80005fc6:	c0 70       	breq	80005fd4 <xTaskCheckForTimeOut+0x2c>
80005fc8:	49 19       	lddpc	r9,8000600c <xTaskCheckForTimeOut+0x64>
80005fca:	72 09       	ld.w	r9,r9[0x0]
80005fcc:	6e 1a       	ld.w	r10,r7[0x4]
80005fce:	12 3a       	cp.w	r10,r9
80005fd0:	e0 88 00 14 	brls	80005ff8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005fd4:	48 e9       	lddpc	r9,8000600c <xTaskCheckForTimeOut+0x64>
80005fd6:	72 0a       	ld.w	r10,r9[0x0]
80005fd8:	6e 19       	ld.w	r9,r7[0x4]
80005fda:	12 1a       	sub	r10,r9
80005fdc:	14 38       	cp.w	r8,r10
80005fde:	e0 88 00 0d 	brls	80005ff8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005fe2:	48 ba       	lddpc	r10,8000600c <xTaskCheckForTimeOut+0x64>
80005fe4:	74 0a       	ld.w	r10,r10[0x0]
80005fe6:	14 19       	sub	r9,r10
80005fe8:	f2 08 00 08 	add	r8,r9,r8
80005fec:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005fee:	0e 9c       	mov	r12,r7
80005ff0:	f0 1f 00 08 	mcall	80006010 <xTaskCheckForTimeOut+0x68>
80005ff4:	30 07       	mov	r7,0
80005ff6:	c0 28       	rjmp	80005ffa <xTaskCheckForTimeOut+0x52>
80005ff8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005ffa:	f0 1f 00 07 	mcall	80006014 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005ffe:	0e 9c       	mov	r12,r7
80006000:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006004:	80 00       	ld.sh	r0,r0[0x0]
80006006:	54 f4       	stdsp	sp[0x13c],r4
80006008:	00 00       	add	r0,r0
8000600a:	0c 5c       	eor	r12,r6
8000600c:	00 00       	add	r0,r0
8000600e:	0d 44       	ld.w	r4,--r6
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	5d 0c       	ror	r12
80006014:	80 00       	ld.sh	r0,r0[0x0]
80006016:	56 00       	stdsp	sp[0x180],r0

80006018 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006018:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000601c:	f0 1f 00 05 	mcall	80006030 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006020:	48 58       	lddpc	r8,80006034 <xTaskGetTickCount+0x1c>
80006022:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006024:	f0 1f 00 05 	mcall	80006038 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006028:	0e 9c       	mov	r12,r7
8000602a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000602e:	00 00       	add	r0,r0
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	54 f4       	stdsp	sp[0x13c],r4
80006034:	00 00       	add	r0,r0
80006036:	0d 44       	ld.w	r4,--r6
80006038:	80 00       	ld.sh	r0,r0[0x0]
8000603a:	56 00       	stdsp	sp[0x180],r0

8000603c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000603c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006040:	f0 1f 00 2c 	mcall	800060f0 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006044:	4a c8       	lddpc	r8,800060f4 <xTaskResumeAll+0xb8>
80006046:	70 09       	ld.w	r9,r8[0x0]
80006048:	20 19       	sub	r9,1
8000604a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000604c:	70 08       	ld.w	r8,r8[0x0]
8000604e:	58 08       	cp.w	r8,0
80006050:	c4 91       	brne	800060e2 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006052:	4a a8       	lddpc	r8,800060f8 <xTaskResumeAll+0xbc>
80006054:	70 08       	ld.w	r8,r8[0x0]
80006056:	58 08       	cp.w	r8,0
80006058:	c4 50       	breq	800060e2 <xTaskResumeAll+0xa6>
8000605a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000605c:	4a 85       	lddpc	r5,800060fc <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000605e:	4a 93       	lddpc	r3,80006100 <xTaskResumeAll+0xc4>
80006060:	4a 92       	lddpc	r2,80006104 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006062:	4a a1       	lddpc	r1,80006108 <xTaskResumeAll+0xcc>
80006064:	c1 e8       	rjmp	800060a0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006066:	6a 38       	ld.w	r8,r5[0xc]
80006068:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000606a:	ee cc ff e8 	sub	r12,r7,-24
8000606e:	f0 1f 00 28 	mcall	8000610c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006072:	ee c6 ff fc 	sub	r6,r7,-4
80006076:	0c 9c       	mov	r12,r6
80006078:	f0 1f 00 25 	mcall	8000610c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000607c:	6e bc       	ld.w	r12,r7[0x2c]
8000607e:	66 08       	ld.w	r8,r3[0x0]
80006080:	10 3c       	cp.w	r12,r8
80006082:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006086:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000608a:	0c 9b       	mov	r11,r6
8000608c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006090:	f0 1f 00 20 	mcall	80006110 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006094:	62 08       	ld.w	r8,r1[0x0]
80006096:	6e b9       	ld.w	r9,r7[0x2c]
80006098:	70 b8       	ld.w	r8,r8[0x2c]
8000609a:	10 39       	cp.w	r9,r8
8000609c:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800060a0:	6a 08       	ld.w	r8,r5[0x0]
800060a2:	58 08       	cp.w	r8,0
800060a4:	ce 11       	brne	80006066 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800060a6:	49 c8       	lddpc	r8,80006114 <xTaskResumeAll+0xd8>
800060a8:	70 08       	ld.w	r8,r8[0x0]
800060aa:	58 08       	cp.w	r8,0
800060ac:	c0 f0       	breq	800060ca <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800060ae:	49 a8       	lddpc	r8,80006114 <xTaskResumeAll+0xd8>
800060b0:	70 08       	ld.w	r8,r8[0x0]
800060b2:	58 08       	cp.w	r8,0
800060b4:	c1 10       	breq	800060d6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800060b6:	49 87       	lddpc	r7,80006114 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800060b8:	f0 1f 00 18 	mcall	80006118 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800060bc:	6e 08       	ld.w	r8,r7[0x0]
800060be:	20 18       	sub	r8,1
800060c0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800060c2:	6e 08       	ld.w	r8,r7[0x0]
800060c4:	58 08       	cp.w	r8,0
800060c6:	cf 91       	brne	800060b8 <xTaskResumeAll+0x7c>
800060c8:	c0 78       	rjmp	800060d6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800060ca:	58 14       	cp.w	r4,1
800060cc:	c0 50       	breq	800060d6 <xTaskResumeAll+0x9a>
800060ce:	49 48       	lddpc	r8,8000611c <xTaskResumeAll+0xe0>
800060d0:	70 08       	ld.w	r8,r8[0x0]
800060d2:	58 18       	cp.w	r8,1
800060d4:	c0 71       	brne	800060e2 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800060d6:	30 09       	mov	r9,0
800060d8:	49 18       	lddpc	r8,8000611c <xTaskResumeAll+0xe0>
800060da:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800060dc:	d7 33       	scall
800060de:	30 17       	mov	r7,1
800060e0:	c0 28       	rjmp	800060e4 <xTaskResumeAll+0xa8>
800060e2:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800060e4:	f0 1f 00 0f 	mcall	80006120 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800060e8:	0e 9c       	mov	r12,r7
800060ea:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800060ee:	00 00       	add	r0,r0
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	54 f4       	stdsp	sp[0x13c],r4
800060f4:	00 00       	add	r0,r0
800060f6:	0d 48       	ld.w	r8,--r6
800060f8:	00 00       	add	r0,r0
800060fa:	0d 64       	ld.uh	r4,--r6
800060fc:	00 00       	add	r0,r0
800060fe:	0d 1c       	ld.sh	r12,r6++
80006100:	00 00       	add	r0,r0
80006102:	0d 80       	ld.ub	r0,r6[0x0]
80006104:	00 00       	add	r0,r0
80006106:	0c 64       	and	r4,r6
80006108:	00 00       	add	r0,r0
8000610a:	0d 18       	ld.sh	r8,r6++
8000610c:	80 00       	ld.sh	r0,r0[0x0]
8000610e:	54 3a       	stdsp	sp[0x10c],r10
80006110:	80 00       	ld.sh	r0,r0[0x0]
80006112:	53 ea       	stdsp	sp[0xf8],r10
80006114:	00 00       	add	r0,r0
80006116:	0c 48       	or	r8,r6
80006118:	80 00       	ld.sh	r0,r0[0x0]
8000611a:	5e 94       	retgt	r4
8000611c:	00 00       	add	r0,r0
8000611e:	0d 68       	ld.uh	r8,--r6
80006120:	80 00       	ld.sh	r0,r0[0x0]
80006122:	56 00       	stdsp	sp[0x180],r0

80006124 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006124:	eb cd 40 80 	pushm	r7,lr
80006128:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000612a:	49 08       	lddpc	r8,80006168 <prvAddCurrentTaskToDelayedList+0x44>
8000612c:	70 08       	ld.w	r8,r8[0x0]
8000612e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006130:	48 f8       	lddpc	r8,8000616c <prvAddCurrentTaskToDelayedList+0x48>
80006132:	70 08       	ld.w	r8,r8[0x0]
80006134:	10 3c       	cp.w	r12,r8
80006136:	c0 a2       	brcc	8000614a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006138:	48 c8       	lddpc	r8,80006168 <prvAddCurrentTaskToDelayedList+0x44>
8000613a:	70 0b       	ld.w	r11,r8[0x0]
8000613c:	48 d8       	lddpc	r8,80006170 <prvAddCurrentTaskToDelayedList+0x4c>
8000613e:	70 0c       	ld.w	r12,r8[0x0]
80006140:	2f cb       	sub	r11,-4
80006142:	f0 1f 00 0d 	mcall	80006174 <prvAddCurrentTaskToDelayedList+0x50>
80006146:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000614a:	48 88       	lddpc	r8,80006168 <prvAddCurrentTaskToDelayedList+0x44>
8000614c:	70 0b       	ld.w	r11,r8[0x0]
8000614e:	48 b8       	lddpc	r8,80006178 <prvAddCurrentTaskToDelayedList+0x54>
80006150:	70 0c       	ld.w	r12,r8[0x0]
80006152:	2f cb       	sub	r11,-4
80006154:	f0 1f 00 08 	mcall	80006174 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006158:	48 98       	lddpc	r8,8000617c <prvAddCurrentTaskToDelayedList+0x58>
8000615a:	70 08       	ld.w	r8,r8[0x0]
8000615c:	10 37       	cp.w	r7,r8
8000615e:	c0 32       	brcc	80006164 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006160:	48 78       	lddpc	r8,8000617c <prvAddCurrentTaskToDelayedList+0x58>
80006162:	91 07       	st.w	r8[0x0],r7
80006164:	e3 cd 80 80 	ldm	sp++,r7,pc
80006168:	00 00       	add	r0,r0
8000616a:	0d 18       	ld.sh	r8,r6++
8000616c:	00 00       	add	r0,r0
8000616e:	0d 44       	ld.w	r4,--r6
80006170:	00 00       	add	r0,r0
80006172:	0c 60       	and	r0,r6
80006174:	80 00       	ld.sh	r0,r0[0x0]
80006176:	54 06       	stdsp	sp[0x100],r6
80006178:	00 00       	add	r0,r0
8000617a:	0c 50       	eor	r0,r6
8000617c:	00 00       	add	r0,r0
8000617e:	05 2c       	ld.uh	r12,r2++

80006180 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006180:	eb cd 40 c0 	pushm	r6-r7,lr
80006184:	18 96       	mov	r6,r12
80006186:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006188:	f0 1f 00 18 	mcall	800061e8 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
8000618c:	6c 08       	ld.w	r8,r6[0x0]
8000618e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006190:	49 79       	lddpc	r9,800061ec <vTaskDelayUntil+0x6c>
80006192:	72 09       	ld.w	r9,r9[0x0]
80006194:	12 38       	cp.w	r8,r9
80006196:	e0 88 00 0c 	brls	800061ae <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000619a:	0e 38       	cp.w	r8,r7
8000619c:	e0 88 00 22 	brls	800061e0 <vTaskDelayUntil+0x60>
800061a0:	49 38       	lddpc	r8,800061ec <vTaskDelayUntil+0x6c>
800061a2:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800061a4:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800061a6:	10 37       	cp.w	r7,r8
800061a8:	e0 88 00 14 	brls	800061d0 <vTaskDelayUntil+0x50>
800061ac:	c0 a8       	rjmp	800061c0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800061ae:	0e 38       	cp.w	r8,r7
800061b0:	e0 8b 00 16 	brhi	800061dc <vTaskDelayUntil+0x5c>
800061b4:	48 e8       	lddpc	r8,800061ec <vTaskDelayUntil+0x6c>
800061b6:	70 08       	ld.w	r8,r8[0x0]
800061b8:	10 37       	cp.w	r7,r8
800061ba:	e0 8b 00 11 	brhi	800061dc <vTaskDelayUntil+0x5c>
800061be:	c1 18       	rjmp	800061e0 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800061c0:	48 c8       	lddpc	r8,800061f0 <vTaskDelayUntil+0x70>
800061c2:	70 0c       	ld.w	r12,r8[0x0]
800061c4:	2f cc       	sub	r12,-4
800061c6:	f0 1f 00 0c 	mcall	800061f4 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800061ca:	0e 9c       	mov	r12,r7
800061cc:	f0 1f 00 0b 	mcall	800061f8 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
800061d0:	f0 1f 00 0b 	mcall	800061fc <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800061d4:	c0 81       	brne	800061e4 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
800061d6:	d7 33       	scall
800061d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800061dc:	8d 07       	st.w	r6[0x0],r7
800061de:	cf 1b       	rjmp	800061c0 <vTaskDelayUntil+0x40>
800061e0:	8d 07       	st.w	r6[0x0],r7
800061e2:	cf 7b       	rjmp	800061d0 <vTaskDelayUntil+0x50>
800061e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800061e8:	80 00       	ld.sh	r0,r0[0x0]
800061ea:	5c 80       	casts.h	r0
800061ec:	00 00       	add	r0,r0
800061ee:	0d 44       	ld.w	r4,--r6
800061f0:	00 00       	add	r0,r0
800061f2:	0d 18       	ld.sh	r8,r6++
800061f4:	80 00       	ld.sh	r0,r0[0x0]
800061f6:	54 3a       	stdsp	sp[0x10c],r10
800061f8:	80 00       	ld.sh	r0,r0[0x0]
800061fa:	61 24       	ld.w	r4,r0[0x48]
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	60 3c       	ld.w	r12,r0[0xc]

80006200 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006200:	eb cd 40 c0 	pushm	r6-r7,lr
80006204:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006206:	48 e7       	lddpc	r7,8000623c <vTaskPlaceOnEventList+0x3c>
80006208:	6e 0b       	ld.w	r11,r7[0x0]
8000620a:	2e 8b       	sub	r11,-24
8000620c:	f0 1f 00 0d 	mcall	80006240 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006210:	6e 0c       	ld.w	r12,r7[0x0]
80006212:	2f cc       	sub	r12,-4
80006214:	f0 1f 00 0c 	mcall	80006244 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006218:	5b f6       	cp.w	r6,-1
8000621a:	c0 81       	brne	8000622a <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000621c:	6e 0b       	ld.w	r11,r7[0x0]
8000621e:	2f cb       	sub	r11,-4
80006220:	48 ac       	lddpc	r12,80006248 <vTaskPlaceOnEventList+0x48>
80006222:	f0 1f 00 0b 	mcall	8000624c <vTaskPlaceOnEventList+0x4c>
80006226:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
8000622a:	48 a8       	lddpc	r8,80006250 <vTaskPlaceOnEventList+0x50>
8000622c:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000622e:	ec 0c 00 0c 	add	r12,r6,r12
80006232:	f0 1f 00 09 	mcall	80006254 <vTaskPlaceOnEventList+0x54>
80006236:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000623a:	00 00       	add	r0,r0
8000623c:	00 00       	add	r0,r0
8000623e:	0d 18       	ld.sh	r8,r6++
80006240:	80 00       	ld.sh	r0,r0[0x0]
80006242:	54 06       	stdsp	sp[0x100],r6
80006244:	80 00       	ld.sh	r0,r0[0x0]
80006246:	54 3a       	stdsp	sp[0x10c],r10
80006248:	00 00       	add	r0,r0
8000624a:	0d 6c       	ld.uh	r12,--r6
8000624c:	80 00       	ld.sh	r0,r0[0x0]
8000624e:	53 ea       	stdsp	sp[0xf8],r10
80006250:	00 00       	add	r0,r0
80006252:	0d 44       	ld.w	r4,--r6
80006254:	80 00       	ld.sh	r0,r0[0x0]
80006256:	61 24       	ld.w	r4,r0[0x48]

80006258 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006258:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
8000625c:	49 67       	lddpc	r7,800062b4 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000625e:	49 74       	lddpc	r4,800062b8 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006260:	49 73       	lddpc	r3,800062bc <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006262:	49 85       	lddpc	r5,800062c0 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006264:	6e 08       	ld.w	r8,r7[0x0]
80006266:	58 08       	cp.w	r8,0
80006268:	c1 e0       	breq	800062a4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000626a:	f0 1f 00 17 	mcall	800062c4 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000626e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006270:	f0 1f 00 16 	mcall	800062c8 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006274:	58 06       	cp.w	r6,0
80006276:	c1 70       	breq	800062a4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006278:	f0 1f 00 15 	mcall	800062cc <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000627c:	68 38       	ld.w	r8,r4[0xc]
8000627e:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006280:	ec cc ff fc 	sub	r12,r6,-4
80006284:	f0 1f 00 13 	mcall	800062d0 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006288:	66 08       	ld.w	r8,r3[0x0]
8000628a:	20 18       	sub	r8,1
8000628c:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000628e:	6e 08       	ld.w	r8,r7[0x0]
80006290:	20 18       	sub	r8,1
80006292:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006294:	f0 1f 00 10 	mcall	800062d4 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006298:	6c cc       	ld.w	r12,r6[0x30]
8000629a:	f0 1f 00 10 	mcall	800062d8 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000629e:	0c 9c       	mov	r12,r6
800062a0:	f0 1f 00 0e 	mcall	800062d8 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800062a4:	6a 08       	ld.w	r8,r5[0x0]
800062a6:	58 18       	cp.w	r8,1
800062a8:	e0 88 00 03 	brls	800062ae <prvIdleTask+0x56>
			{
				taskYIELD();
800062ac:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
800062ae:	f0 1f 00 0c 	mcall	800062dc <prvIdleTask+0x84>
		}
		#endif
	}
800062b2:	cd 9b       	rjmp	80006264 <prvIdleTask+0xc>
800062b4:	00 00       	add	r0,r0
800062b6:	0c 58       	eor	r8,r6
800062b8:	00 00       	add	r0,r0
800062ba:	0d 04       	ld.w	r4,r6++
800062bc:	00 00       	add	r0,r0
800062be:	0d 64       	ld.uh	r4,--r6
800062c0:	00 00       	add	r0,r0
800062c2:	0c 64       	and	r4,r6
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	5c 80       	casts.h	r0
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	60 3c       	ld.w	r12,r0[0xc]
800062cc:	80 00       	ld.sh	r0,r0[0x0]
800062ce:	54 f4       	stdsp	sp[0x13c],r4
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	54 3a       	stdsp	sp[0x10c],r10
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	56 00       	stdsp	sp[0x180],r0
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	57 38       	stdsp	sp[0x1cc],r8
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	20 30       	sub	r0,3

800062e0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800062e0:	d4 31       	pushm	r0-r7,lr
800062e2:	20 1d       	sub	sp,4
800062e4:	fa c4 ff d8 	sub	r4,sp,-40
800062e8:	50 0c       	stdsp	sp[0x0],r12
800062ea:	16 91       	mov	r1,r11
800062ec:	14 97       	mov	r7,r10
800062ee:	12 90       	mov	r0,r9
800062f0:	10 93       	mov	r3,r8
800062f2:	68 02       	ld.w	r2,r4[0x0]
800062f4:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800062f6:	34 8c       	mov	r12,72
800062f8:	f0 1f 00 5c 	mcall	80006468 <xTaskGenericCreate+0x188>
800062fc:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800062fe:	c0 31       	brne	80006304 <xTaskGenericCreate+0x24>
80006300:	3f fc       	mov	r12,-1
80006302:	ca f8       	rjmp	80006460 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006304:	58 06       	cp.w	r6,0
80006306:	e0 81 00 af 	brne	80006464 <xTaskGenericCreate+0x184>
8000630a:	0e 9c       	mov	r12,r7
8000630c:	5c 7c       	castu.h	r12
8000630e:	a3 6c       	lsl	r12,0x2
80006310:	f0 1f 00 56 	mcall	80006468 <xTaskGenericCreate+0x188>
80006314:	18 96       	mov	r6,r12
80006316:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006318:	c0 61       	brne	80006324 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
8000631a:	0a 9c       	mov	r12,r5
8000631c:	f0 1f 00 54 	mcall	8000646c <xTaskGenericCreate+0x18c>
80006320:	3f fc       	mov	r12,-1
80006322:	c9 f8       	rjmp	80006460 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006324:	5c 77       	castu.h	r7
80006326:	ee 0a 15 02 	lsl	r10,r7,0x2
8000632a:	e0 6b 00 a5 	mov	r11,165
8000632e:	0c 9c       	mov	r12,r6
80006330:	f0 1f 00 50 	mcall	80006470 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006334:	ee c6 00 01 	sub	r6,r7,1
80006338:	6a c8       	ld.w	r8,r5[0x30]
8000633a:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000633e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006342:	31 0a       	mov	r10,16
80006344:	02 9b       	mov	r11,r1
80006346:	ea cc ff cc 	sub	r12,r5,-52
8000634a:	f0 1f 00 4b 	mcall	80006474 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000634e:	30 08       	mov	r8,0
80006350:	eb 68 00 43 	st.b	r5[67],r8
80006354:	58 73       	cp.w	r3,7
80006356:	e6 07 17 80 	movls	r7,r3
8000635a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000635e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006360:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006364:	ea c4 ff fc 	sub	r4,r5,-4
80006368:	08 9c       	mov	r12,r4
8000636a:	f0 1f 00 44 	mcall	80006478 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000636e:	ea cc ff e8 	sub	r12,r5,-24
80006372:	f0 1f 00 42 	mcall	80006478 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006376:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006378:	ee 07 11 08 	rsub	r7,r7,8
8000637c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000637e:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006380:	00 9a       	mov	r10,r0
80006382:	40 0b       	lddsp	r11,sp[0x0]
80006384:	0c 9c       	mov	r12,r6
80006386:	f0 1f 00 3e 	mcall	8000647c <xTaskGenericCreate+0x19c>
8000638a:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
8000638c:	58 02       	cp.w	r2,0
8000638e:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006392:	f0 1f 00 3c 	mcall	80006480 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006396:	4b c8       	lddpc	r8,80006484 <xTaskGenericCreate+0x1a4>
80006398:	70 09       	ld.w	r9,r8[0x0]
8000639a:	2f f9       	sub	r9,-1
8000639c:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000639e:	4b b8       	lddpc	r8,80006488 <xTaskGenericCreate+0x1a8>
800063a0:	70 08       	ld.w	r8,r8[0x0]
800063a2:	58 08       	cp.w	r8,0
800063a4:	c2 61       	brne	800063f0 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800063a6:	4b 98       	lddpc	r8,80006488 <xTaskGenericCreate+0x1a8>
800063a8:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800063aa:	4b 78       	lddpc	r8,80006484 <xTaskGenericCreate+0x1a4>
800063ac:	70 08       	ld.w	r8,r8[0x0]
800063ae:	58 18       	cp.w	r8,1
800063b0:	c2 b1       	brne	80006406 <xTaskGenericCreate+0x126>
800063b2:	4b 77       	lddpc	r7,8000648c <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800063b4:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800063b8:	0e 9c       	mov	r12,r7
800063ba:	f0 1f 00 36 	mcall	80006490 <xTaskGenericCreate+0x1b0>
800063be:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800063c0:	0c 37       	cp.w	r7,r6
800063c2:	cf b1       	brne	800063b8 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800063c4:	4b 47       	lddpc	r7,80006494 <xTaskGenericCreate+0x1b4>
800063c6:	0e 9c       	mov	r12,r7
800063c8:	f0 1f 00 32 	mcall	80006490 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800063cc:	4b 36       	lddpc	r6,80006498 <xTaskGenericCreate+0x1b8>
800063ce:	0c 9c       	mov	r12,r6
800063d0:	f0 1f 00 30 	mcall	80006490 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800063d4:	4b 2c       	lddpc	r12,8000649c <xTaskGenericCreate+0x1bc>
800063d6:	f0 1f 00 2f 	mcall	80006490 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800063da:	4b 2c       	lddpc	r12,800064a0 <xTaskGenericCreate+0x1c0>
800063dc:	f0 1f 00 2d 	mcall	80006490 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800063e0:	4b 1c       	lddpc	r12,800064a4 <xTaskGenericCreate+0x1c4>
800063e2:	f0 1f 00 2c 	mcall	80006490 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800063e6:	4b 18       	lddpc	r8,800064a8 <xTaskGenericCreate+0x1c8>
800063e8:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800063ea:	4b 18       	lddpc	r8,800064ac <xTaskGenericCreate+0x1cc>
800063ec:	91 06       	st.w	r8[0x0],r6
800063ee:	c0 c8       	rjmp	80006406 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800063f0:	4b 08       	lddpc	r8,800064b0 <xTaskGenericCreate+0x1d0>
800063f2:	70 08       	ld.w	r8,r8[0x0]
800063f4:	58 08       	cp.w	r8,0
800063f6:	c0 81       	brne	80006406 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800063f8:	4a 48       	lddpc	r8,80006488 <xTaskGenericCreate+0x1a8>
800063fa:	70 08       	ld.w	r8,r8[0x0]
800063fc:	70 b8       	ld.w	r8,r8[0x2c]
800063fe:	10 33       	cp.w	r3,r8
80006400:	c0 33       	brcs	80006406 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006402:	4a 28       	lddpc	r8,80006488 <xTaskGenericCreate+0x1a8>
80006404:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006406:	6a b8       	ld.w	r8,r5[0x2c]
80006408:	4a b9       	lddpc	r9,800064b4 <xTaskGenericCreate+0x1d4>
8000640a:	72 09       	ld.w	r9,r9[0x0]
8000640c:	12 38       	cp.w	r8,r9
8000640e:	e0 88 00 04 	brls	80006416 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006412:	4a 99       	lddpc	r9,800064b4 <xTaskGenericCreate+0x1d4>
80006414:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006416:	4a 98       	lddpc	r8,800064b8 <xTaskGenericCreate+0x1d8>
80006418:	70 09       	ld.w	r9,r8[0x0]
8000641a:	2f f9       	sub	r9,-1
8000641c:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000641e:	6a b8       	ld.w	r8,r5[0x2c]
80006420:	4a 79       	lddpc	r9,800064bc <xTaskGenericCreate+0x1dc>
80006422:	72 09       	ld.w	r9,r9[0x0]
80006424:	12 38       	cp.w	r8,r9
80006426:	e0 88 00 04 	brls	8000642e <xTaskGenericCreate+0x14e>
8000642a:	4a 59       	lddpc	r9,800064bc <xTaskGenericCreate+0x1dc>
8000642c:	93 08       	st.w	r9[0x0],r8
8000642e:	6a bc       	ld.w	r12,r5[0x2c]
80006430:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006434:	08 9b       	mov	r11,r4
80006436:	49 68       	lddpc	r8,8000648c <xTaskGenericCreate+0x1ac>
80006438:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000643c:	f0 1f 00 21 	mcall	800064c0 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006440:	f0 1f 00 21 	mcall	800064c4 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006444:	49 b8       	lddpc	r8,800064b0 <xTaskGenericCreate+0x1d0>
80006446:	70 08       	ld.w	r8,r8[0x0]
80006448:	58 08       	cp.w	r8,0
8000644a:	c0 a0       	breq	8000645e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
8000644c:	48 f8       	lddpc	r8,80006488 <xTaskGenericCreate+0x1a8>
8000644e:	70 08       	ld.w	r8,r8[0x0]
80006450:	70 b8       	ld.w	r8,r8[0x2c]
80006452:	10 33       	cp.w	r3,r8
80006454:	e0 88 00 05 	brls	8000645e <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006458:	d7 33       	scall
8000645a:	30 1c       	mov	r12,1
8000645c:	c0 28       	rjmp	80006460 <xTaskGenericCreate+0x180>
8000645e:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006460:	2f fd       	sub	sp,-4
80006462:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006464:	99 c6       	st.w	r12[0x30],r6
80006466:	c5 fb       	rjmp	80006324 <xTaskGenericCreate+0x44>
80006468:	80 00       	ld.sh	r0,r0[0x0]
8000646a:	57 60       	stdsp	sp[0x1d8],r0
8000646c:	80 00       	ld.sh	r0,r0[0x0]
8000646e:	57 38       	stdsp	sp[0x1cc],r8
80006470:	80 00       	ld.sh	r0,r0[0x0]
80006472:	71 4c       	ld.w	r12,r8[0x50]
80006474:	80 00       	ld.sh	r0,r0[0x0]
80006476:	74 90       	ld.w	r0,r10[0x24]
80006478:	80 00       	ld.sh	r0,r0[0x0]
8000647a:	53 e4       	stdsp	sp[0xf8],r4
8000647c:	80 00       	ld.sh	r0,r0[0x0]
8000647e:	54 60       	stdsp	sp[0x118],r0
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	54 f4       	stdsp	sp[0x13c],r4
80006484:	00 00       	add	r0,r0
80006486:	0d 64       	ld.uh	r4,--r6
80006488:	00 00       	add	r0,r0
8000648a:	0d 18       	ld.sh	r8,r6++
8000648c:	00 00       	add	r0,r0
8000648e:	0c 64       	and	r4,r6
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	53 d0       	stdsp	sp[0xf4],r0
80006494:	00 00       	add	r0,r0
80006496:	0d 30       	ld.ub	r0,r6++
80006498:	00 00       	add	r0,r0
8000649a:	0d 4c       	ld.w	r12,--r6
8000649c:	00 00       	add	r0,r0
8000649e:	0d 1c       	ld.sh	r12,r6++
800064a0:	00 00       	add	r0,r0
800064a2:	0d 04       	ld.w	r4,r6++
800064a4:	00 00       	add	r0,r0
800064a6:	0d 6c       	ld.uh	r12,--r6
800064a8:	00 00       	add	r0,r0
800064aa:	0c 50       	eor	r0,r6
800064ac:	00 00       	add	r0,r0
800064ae:	0c 60       	and	r0,r6
800064b0:	00 00       	add	r0,r0
800064b2:	0c 54       	eor	r4,r6
800064b4:	00 00       	add	r0,r0
800064b6:	0c 4c       	or	r12,r6
800064b8:	00 00       	add	r0,r0
800064ba:	0d 60       	ld.uh	r0,--r6
800064bc:	00 00       	add	r0,r0
800064be:	0d 80       	ld.ub	r0,r6[0x0]
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	53 ea       	stdsp	sp[0xf8],r10
800064c4:	80 00       	ld.sh	r0,r0[0x0]
800064c6:	56 00       	stdsp	sp[0x180],r0

800064c8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800064c8:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800064ca:	30 09       	mov	r9,0
800064cc:	1a d9       	st.w	--sp,r9
800064ce:	1a d9       	st.w	--sp,r9
800064d0:	1a d9       	st.w	--sp,r9
800064d2:	12 98       	mov	r8,r9
800064d4:	e0 6a 01 00 	mov	r10,256
800064d8:	48 9b       	lddpc	r11,800064fc <vTaskStartScheduler+0x34>
800064da:	48 ac       	lddpc	r12,80006500 <vTaskStartScheduler+0x38>
800064dc:	f0 1f 00 0a 	mcall	80006504 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800064e0:	2f dd       	sub	sp,-12
800064e2:	58 1c       	cp.w	r12,1
800064e4:	c0 a1       	brne	800064f8 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800064e6:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800064e8:	30 19       	mov	r9,1
800064ea:	48 88       	lddpc	r8,80006508 <vTaskStartScheduler+0x40>
800064ec:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800064ee:	30 09       	mov	r9,0
800064f0:	48 78       	lddpc	r8,8000650c <vTaskStartScheduler+0x44>
800064f2:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800064f4:	f0 1f 00 07 	mcall	80006510 <vTaskStartScheduler+0x48>
800064f8:	d8 02       	popm	pc
800064fa:	00 00       	add	r0,r0
800064fc:	80 01       	ld.sh	r1,r0[0x0]
800064fe:	5a 20       	cp.w	r0,-30
80006500:	80 00       	ld.sh	r0,r0[0x0]
80006502:	62 58       	ld.w	r8,r1[0x14]
80006504:	80 00       	ld.sh	r0,r0[0x0]
80006506:	62 e0       	ld.w	r0,r1[0x38]
80006508:	00 00       	add	r0,r0
8000650a:	0c 54       	eor	r4,r6
8000650c:	00 00       	add	r0,r0
8000650e:	0d 44       	ld.w	r4,--r6
80006510:	80 00       	ld.sh	r0,r0[0x0]
80006512:	55 04       	stdsp	sp[0x140],r4

80006514 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006514:	16 cc       	st.b	r11++,r12
	return str;
}
80006516:	5e fb       	retal	r11

80006518 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006518:	eb cd 40 c0 	pushm	r6-r7,lr
8000651c:	20 3d       	sub	sp,12
8000651e:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006520:	30 06       	mov	r6,0
80006522:	30 07       	mov	r7,0
80006524:	fa e7 00 00 	st.d	sp[0],r6
80006528:	30 0c       	mov	r12,0
8000652a:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
8000652c:	58 08       	cp.w	r8,0
8000652e:	c1 30       	breq	80006554 <PrintHex+0x3c>
80006530:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006532:	1a 9c       	mov	r12,sp
80006534:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006538:	58 9e       	cp.w	lr,9
8000653a:	e0 8a 00 04 	brle	80006542 <PrintHex+0x2a>
8000653e:	2c 9e       	sub	lr,-55
80006540:	c0 48       	rjmp	80006548 <PrintHex+0x30>
80006542:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006546:	2d 0e       	sub	lr,-48
80006548:	f8 09 0b 0e 	st.b	r12[r9],lr
8000654c:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000654e:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006550:	cf 21       	brne	80006534 <PrintHex+0x1c>
80006552:	c0 48       	rjmp	8000655a <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006554:	33 08       	mov	r8,48
80006556:	ba 88       	st.b	sp[0x0],r8
80006558:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
8000655a:	f6 09 01 08 	sub	r8,r11,r9
8000655e:	58 08       	cp.w	r8,0
80006560:	e0 8a 00 13 	brle	80006586 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006564:	12 1b       	sub	r11,r9
80006566:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
8000656a:	18 9e       	mov	lr,r12
8000656c:	58 0c       	cp.w	r12,0
8000656e:	e0 8a 00 0c 	brle	80006586 <PrintHex+0x6e>
80006572:	1a 9b       	mov	r11,sp
80006574:	12 0b       	add	r11,r9
80006576:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006578:	33 07       	mov	r7,48
8000657a:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000657c:	2f f8       	sub	r8,-1
8000657e:	1c 38       	cp.w	r8,lr
80006580:	cf d5       	brlt	8000657a <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006582:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006586:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
8000658a:	f0 cb ff ff 	sub	r11,r8,-1
8000658e:	58 0b       	cp.w	r11,0
80006590:	e0 8a 00 19 	brle	800065c2 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006594:	fa cb ff f4 	sub	r11,sp,-12
80006598:	f6 09 00 09 	add	r9,r11,r9
8000659c:	37 8b       	mov	r11,120
8000659e:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
800065a2:	fa c9 ff f4 	sub	r9,sp,-12
800065a6:	10 09       	add	r9,r8
800065a8:	33 0b       	mov	r11,48
800065aa:	f3 6b ff f4 	st.b	r9[-12],r11
800065ae:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
800065b2:	fa ce 00 01 	sub	lr,sp,1
800065b6:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800065b8:	11 8b       	ld.ub	r11,r8[0x0]
800065ba:	12 cb       	st.b	r9++,r11
800065bc:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800065be:	1c 38       	cp.w	r8,lr
800065c0:	cf c1       	brne	800065b8 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800065c2:	14 9c       	mov	r12,r10
800065c4:	2f dd       	sub	sp,-12
800065c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800065ca <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800065ca:	d4 21       	pushm	r4-r7,lr
800065cc:	20 3d       	sub	sp,12
800065ce:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800065d0:	30 06       	mov	r6,0
800065d2:	30 07       	mov	r7,0
800065d4:	fa e7 00 00 	st.d	sp[0],r6
800065d8:	30 0c       	mov	r12,0
800065da:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800065dc:	58 08       	cp.w	r8,0
800065de:	c0 35       	brlt	800065e4 <PrintDec+0x1a>
800065e0:	14 97       	mov	r7,r10
800065e2:	c0 58       	rjmp	800065ec <PrintDec+0x22>
	{
		*p++ = '-';
800065e4:	14 97       	mov	r7,r10
800065e6:	32 d9       	mov	r9,45
800065e8:	0e c9       	st.b	r7++,r9
		i = -i;
800065ea:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800065ec:	58 08       	cp.w	r8,0
800065ee:	c0 51       	brne	800065f8 <PrintDec+0x2e>
800065f0:	33 08       	mov	r8,48
800065f2:	ba 88       	st.b	sp[0x0],r8
800065f4:	30 1e       	mov	lr,1
800065f6:	c2 f8       	rjmp	80006654 <PrintDec+0x8a>
	
	int ten = i%10;
800065f8:	e0 65 66 67 	mov	r5,26215
800065fc:	ea 15 66 66 	orh	r5,0x6666
80006600:	f0 05 04 44 	muls.d	r4,r8,r5
80006604:	ea 0c 14 02 	asr	r12,r5,0x2
80006608:	f0 09 14 1f 	asr	r9,r8,0x1f
8000660c:	f8 09 01 09 	sub	r9,r12,r9
80006610:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006614:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006618:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
8000661a:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
8000661c:	e0 66 66 67 	mov	r6,26215
80006620:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006624:	2d 09       	sub	r9,-48
80006626:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
8000662a:	2f fe       	sub	lr,-1
		i /= 10;
8000662c:	f0 06 04 44 	muls.d	r4,r8,r6
80006630:	ea 09 14 02 	asr	r9,r5,0x2
80006634:	bf 58       	asr	r8,0x1f
80006636:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
8000663a:	f0 06 04 44 	muls.d	r4,r8,r6
8000663e:	ea 09 14 02 	asr	r9,r5,0x2
80006642:	f0 05 14 1f 	asr	r5,r8,0x1f
80006646:	0a 19       	sub	r9,r5
80006648:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000664c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006650:	58 08       	cp.w	r8,0
80006652:	ce 91       	brne	80006624 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006654:	f6 0e 01 08 	sub	r8,r11,lr
80006658:	58 08       	cp.w	r8,0
8000665a:	e0 89 00 06 	brgt	80006666 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000665e:	58 0e       	cp.w	lr,0
80006660:	e0 89 00 14 	brgt	80006688 <PrintDec+0xbe>
80006664:	c1 d8       	rjmp	8000669e <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006666:	1c 1b       	sub	r11,lr
80006668:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
8000666a:	16 9c       	mov	r12,r11
8000666c:	58 0b       	cp.w	r11,0
8000666e:	fe 9a ff f8 	brle	8000665e <PrintDec+0x94>
80006672:	1a 99       	mov	r9,sp
80006674:	1c 09       	add	r9,lr
80006676:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006678:	33 06       	mov	r6,48
8000667a:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000667c:	2f f8       	sub	r8,-1
8000667e:	18 38       	cp.w	r8,r12
80006680:	cf d5       	brlt	8000667a <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006682:	f6 0e 00 0e 	add	lr,r11,lr
80006686:	ce cb       	rjmp	8000665e <PrintDec+0x94>
80006688:	fa c8 ff f4 	sub	r8,sp,-12
8000668c:	1c 08       	add	r8,lr
8000668e:	20 d8       	sub	r8,13
80006690:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006694:	11 89       	ld.ub	r9,r8[0x0]
80006696:	0e c9       	st.b	r7++,r9
80006698:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000669a:	16 38       	cp.w	r8,r11
8000669c:	cf c1       	brne	80006694 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000669e:	14 9c       	mov	r12,r10
800066a0:	2f dd       	sub	sp,-12
800066a2:	d8 22       	popm	r4-r7,pc

800066a4 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
800066a4:	d4 31       	pushm	r0-r7,lr
800066a6:	fa cd 02 08 	sub	sp,sp,520
800066aa:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
800066ac:	e0 6a 01 00 	mov	r10,256
800066b0:	30 0b       	mov	r11,0
800066b2:	fa cc fe f8 	sub	r12,sp,-264
800066b6:	f0 1f 00 4e 	mcall	800067ec <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800066ba:	fa c4 fd d4 	sub	r4,sp,-556
800066be:	30 0a       	mov	r10,0
800066c0:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800066c2:	fa c3 ff fc 	sub	r3,sp,-4
800066c6:	e0 61 01 00 	mov	r1,256
800066ca:	14 90       	mov	r0,r10
			
					if(*str == '%')
800066cc:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800066ce:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800066d2:	02 9a       	mov	r10,r1
800066d4:	00 9b       	mov	r11,r0
800066d6:	06 9c       	mov	r12,r3
800066d8:	f0 1f 00 45 	mcall	800067ec <log+0x148>
			
					if(*str == '%')
800066dc:	0f 88       	ld.ub	r8,r7[0x0]
800066de:	e4 08 18 00 	cp.b	r8,r2
800066e2:	c5 71       	brne	80006790 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800066e4:	ee c8 ff ff 	sub	r8,r7,-1
800066e8:	11 89       	ld.ub	r9,r8[0x0]
800066ea:	4c 2a       	lddpc	r10,800067f0 <log+0x14c>
800066ec:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800066ee:	23 09       	sub	r9,48
800066f0:	30 9a       	mov	r10,9
800066f2:	f4 09 18 00 	cp.b	r9,r10
800066f6:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800066fa:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800066fe:	f7 b9 08 30 	subls	r9,48
80006702:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006706:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
8000670a:	0f 88       	ld.ub	r8,r7[0x0]
8000670c:	22 58       	sub	r8,37
8000670e:	e0 48 00 53 	cp.w	r8,83
80006712:	e0 8b 00 31 	brhi	80006774 <log+0xd0>
80006716:	4b 89       	lddpc	r9,800067f4 <log+0x150>
80006718:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000671c:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006720:	06 9a       	mov	r10,r3
80006722:	40 0b       	lddsp	r11,sp[0x0]
80006724:	5c 5b       	castu.b	r11
80006726:	68 0c       	ld.w	r12,r4[0x0]
80006728:	f0 1f 00 34 	mcall	800067f8 <log+0x154>
							break;
8000672c:	c2 98       	rjmp	8000677e <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000672e:	4b 4c       	lddpc	r12,800067fc <log+0x158>
80006730:	f0 1f 00 34 	mcall	80006800 <log+0x15c>
80006734:	08 95       	mov	r5,r4
80006736:	06 9c       	mov	r12,r3
							break;
80006738:	c2 38       	rjmp	8000677e <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000673a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000673e:	06 9a       	mov	r10,r3
80006740:	40 0b       	lddsp	r11,sp[0x0]
80006742:	5c 5b       	castu.b	r11
80006744:	68 0c       	ld.w	r12,r4[0x0]
80006746:	f0 1f 00 30 	mcall	80006804 <log+0x160>
8000674a:	06 9c       	mov	r12,r3
							break;
8000674c:	c1 98       	rjmp	8000677e <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000674e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006752:	06 9b       	mov	r11,r3
80006754:	09 bc       	ld.ub	r12,r4[0x3]
80006756:	f0 1f 00 2d 	mcall	80006808 <log+0x164>
8000675a:	06 9c       	mov	r12,r3
							break;
8000675c:	c1 18       	rjmp	8000677e <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000675e:	e8 c5 ff fc 	sub	r5,r4,-4
80006762:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006764:	c0 d8       	rjmp	8000677e <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006766:	06 9b       	mov	r11,r3
80006768:	32 5c       	mov	r12,37
8000676a:	f0 1f 00 28 	mcall	80006808 <log+0x164>
8000676e:	08 95       	mov	r5,r4
80006770:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006772:	c0 68       	rjmp	8000677e <log+0xda>
							
							default:
							log("I need relax.");
80006774:	4a 6c       	lddpc	r12,8000680c <log+0x168>
80006776:	f0 1f 00 23 	mcall	80006800 <log+0x15c>
8000677a:	08 95       	mov	r5,r4
8000677c:	06 9c       	mov	r12,r3
						}
						str++;
8000677e:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006780:	1a dc       	st.w	--sp,r12
80006782:	1a d6       	st.w	--sp,r6
80006784:	4a 3b       	lddpc	r11,80006810 <log+0x16c>
80006786:	0c 9c       	mov	r12,r6
80006788:	f0 1f 00 23 	mcall	80006814 <log+0x170>
8000678c:	2f ed       	sub	sp,-8
8000678e:	c0 a8       	rjmp	800067a2 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006790:	2f f7       	sub	r7,-1
80006792:	1a d8       	st.w	--sp,r8
80006794:	1a d6       	st.w	--sp,r6
80006796:	4a 1b       	lddpc	r11,80006818 <log+0x174>
80006798:	0c 9c       	mov	r12,r6
8000679a:	f0 1f 00 1f 	mcall	80006814 <log+0x170>
8000679e:	08 95       	mov	r5,r4
800067a0:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
800067a2:	0f 89       	ld.ub	r9,r7[0x0]
800067a4:	30 08       	mov	r8,0
800067a6:	f0 09 18 00 	cp.b	r9,r8
800067aa:	c0 30       	breq	800067b0 <log+0x10c>
800067ac:	0a 94       	mov	r4,r5
800067ae:	c9 2b       	rjmp	800066d2 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
800067b0:	fa c7 fe f8 	sub	r7,sp,-264
800067b4:	1a d7       	st.w	--sp,r7
800067b6:	49 ab       	lddpc	r11,8000681c <log+0x178>
800067b8:	0e 9c       	mov	r12,r7
800067ba:	f0 1f 00 17 	mcall	80006814 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800067be:	5c 5c       	castu.b	r12
800067c0:	f8 c6 ff ff 	sub	r6,r12,-1
800067c4:	0c 9c       	mov	r12,r6
800067c6:	f0 1f 00 17 	mcall	80006820 <log+0x17c>
800067ca:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800067cc:	0c 9a       	mov	r10,r6
800067ce:	0e 9b       	mov	r11,r7
800067d0:	f0 1f 00 15 	mcall	80006824 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
800067d4:	30 09       	mov	r9,0
800067d6:	30 5a       	mov	r10,5
800067d8:	fa cb fe f8 	sub	r11,sp,-264
800067dc:	49 38       	lddpc	r8,80006828 <log+0x184>
800067de:	70 0c       	ld.w	r12,r8[0x0]
800067e0:	f0 1f 00 13 	mcall	8000682c <log+0x188>
800067e4:	2f fd       	sub	sp,-4
}
800067e6:	fe 3d fd f8 	sub	sp,-520
800067ea:	d8 32       	popm	r0-r7,pc
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	71 4c       	ld.w	r12,r8[0x50]
800067f0:	00 00       	add	r0,r0
800067f2:	0d 84       	ld.ub	r4,r6[0x0]
800067f4:	80 01       	ld.sh	r1,r0[0x0]
800067f6:	5a 28       	cp.w	r8,-30
800067f8:	80 00       	ld.sh	r0,r0[0x0]
800067fa:	65 ca       	ld.w	r10,r2[0x70]
800067fc:	80 01       	ld.sh	r1,r0[0x0]
800067fe:	5c d4       	com	r4
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	66 a4       	ld.w	r4,r3[0x28]
80006804:	80 00       	ld.sh	r0,r0[0x0]
80006806:	65 18       	ld.w	r8,r2[0x44]
80006808:	80 00       	ld.sh	r0,r0[0x0]
8000680a:	65 14       	ld.w	r4,r2[0x44]
8000680c:	80 01       	ld.sh	r1,r0[0x0]
8000680e:	5c e4       	tnbz	r4
80006810:	80 01       	ld.sh	r1,r0[0x0]
80006812:	5c f4       	rol	r4
80006814:	80 00       	ld.sh	r0,r0[0x0]
80006816:	74 3c       	ld.w	r12,r10[0xc]
80006818:	80 01       	ld.sh	r1,r0[0x0]
8000681a:	5c fc       	rol	r12
8000681c:	80 01       	ld.sh	r1,r0[0x0]
8000681e:	5d 04       	ror	r4
80006820:	80 00       	ld.sh	r0,r0[0x0]
80006822:	57 60       	stdsp	sp[0x1d8],r0
80006824:	80 00       	ld.sh	r0,r0[0x0]
80006826:	70 04       	ld.w	r4,r8[0x0]
80006828:	00 00       	add	r0,r0
8000682a:	41 28       	lddsp	r8,sp[0x48]
8000682c:	80 00       	ld.sh	r0,r0[0x0]
8000682e:	5a b4       	cp.w	r4,-21

80006830 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006830:	d4 31       	pushm	r0-r7,lr
80006832:	fa cd 02 0c 	sub	sp,sp,524
80006836:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006838:	e0 6a 01 00 	mov	r10,256
8000683c:	30 0b       	mov	r11,0
8000683e:	fa cc fe f4 	sub	r12,sp,-268
80006842:	f0 1f 00 4c 	mcall	80006970 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80006846:	fa c4 fd d0 	sub	r4,sp,-560
8000684a:	30 0a       	mov	r10,0
8000684c:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000684e:	fa c3 ff fc 	sub	r3,sp,-4
80006852:	e0 61 01 00 	mov	r1,256
80006856:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006858:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000685a:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000685e:	02 9a       	mov	r10,r1
80006860:	00 9b       	mov	r11,r0
80006862:	06 9c       	mov	r12,r3
80006864:	f0 1f 00 43 	mcall	80006970 <logFromISR+0x140>
			
			if(*str == '%')
80006868:	0f 88       	ld.ub	r8,r7[0x0]
8000686a:	e4 08 18 00 	cp.b	r8,r2
8000686e:	c5 11       	brne	80006910 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006870:	ee c8 ff ff 	sub	r8,r7,-1
80006874:	11 89       	ld.ub	r9,r8[0x0]
80006876:	4c 0a       	lddpc	r10,80006974 <logFromISR+0x144>
80006878:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000687a:	23 09       	sub	r9,48
8000687c:	30 9a       	mov	r10,9
8000687e:	f4 09 18 00 	cp.b	r9,r10
80006882:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006886:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000688a:	f7 b9 08 30 	subls	r9,48
8000688e:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006892:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006896:	0f 88       	ld.ub	r8,r7[0x0]
80006898:	22 58       	sub	r8,37
8000689a:	e0 48 00 53 	cp.w	r8,83
8000689e:	e0 8b 00 2b 	brhi	800068f4 <logFromISR+0xc4>
800068a2:	4b 69       	lddpc	r9,80006978 <logFromISR+0x148>
800068a4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
800068a8:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
800068ac:	06 9a       	mov	r10,r3
800068ae:	40 0b       	lddsp	r11,sp[0x0]
800068b0:	5c 5b       	castu.b	r11
800068b2:	68 0c       	ld.w	r12,r4[0x0]
800068b4:	f0 1f 00 32 	mcall	8000697c <logFromISR+0x14c>
					break;
800068b8:	c2 38       	rjmp	800068fe <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800068ba:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800068be:	06 9a       	mov	r10,r3
800068c0:	40 0b       	lddsp	r11,sp[0x0]
800068c2:	5c 5b       	castu.b	r11
800068c4:	68 0c       	ld.w	r12,r4[0x0]
800068c6:	f0 1f 00 2f 	mcall	80006980 <logFromISR+0x150>
800068ca:	06 9c       	mov	r12,r3
					break;
800068cc:	c1 98       	rjmp	800068fe <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800068ce:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800068d2:	06 9b       	mov	r11,r3
800068d4:	09 bc       	ld.ub	r12,r4[0x3]
800068d6:	f0 1f 00 2c 	mcall	80006984 <logFromISR+0x154>
800068da:	06 9c       	mov	r12,r3
					break;
800068dc:	c1 18       	rjmp	800068fe <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800068de:	e8 c5 ff fc 	sub	r5,r4,-4
800068e2:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800068e4:	c0 d8       	rjmp	800068fe <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800068e6:	06 9b       	mov	r11,r3
800068e8:	32 5c       	mov	r12,37
800068ea:	f0 1f 00 27 	mcall	80006984 <logFromISR+0x154>
800068ee:	08 95       	mov	r5,r4
800068f0:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800068f2:	c0 68       	rjmp	800068fe <logFromISR+0xce>
					default:
					log("I need relax.");
800068f4:	4a 5c       	lddpc	r12,80006988 <logFromISR+0x158>
800068f6:	f0 1f 00 26 	mcall	8000698c <logFromISR+0x15c>
800068fa:	08 95       	mov	r5,r4
800068fc:	06 9c       	mov	r12,r3
				}
				str++;
800068fe:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006900:	1a dc       	st.w	--sp,r12
80006902:	1a d6       	st.w	--sp,r6
80006904:	4a 3b       	lddpc	r11,80006990 <logFromISR+0x160>
80006906:	0c 9c       	mov	r12,r6
80006908:	f0 1f 00 23 	mcall	80006994 <logFromISR+0x164>
8000690c:	2f ed       	sub	sp,-8
8000690e:	c0 a8       	rjmp	80006922 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006910:	2f f7       	sub	r7,-1
80006912:	1a d8       	st.w	--sp,r8
80006914:	1a d6       	st.w	--sp,r6
80006916:	4a 1b       	lddpc	r11,80006998 <logFromISR+0x168>
80006918:	0c 9c       	mov	r12,r6
8000691a:	f0 1f 00 1f 	mcall	80006994 <logFromISR+0x164>
8000691e:	08 95       	mov	r5,r4
80006920:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80006922:	0f 89       	ld.ub	r9,r7[0x0]
80006924:	30 08       	mov	r8,0
80006926:	f0 09 18 00 	cp.b	r9,r8
8000692a:	c0 30       	breq	80006930 <logFromISR+0x100>
8000692c:	0a 94       	mov	r4,r5
8000692e:	c9 8b       	rjmp	8000685e <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80006930:	fa c7 fe f4 	sub	r7,sp,-268
80006934:	1a d7       	st.w	--sp,r7
80006936:	49 ab       	lddpc	r11,8000699c <logFromISR+0x16c>
80006938:	0e 9c       	mov	r12,r7
8000693a:	f0 1f 00 17 	mcall	80006994 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000693e:	5c 5c       	castu.b	r12
80006940:	f8 c6 ff ff 	sub	r6,r12,-1
80006944:	0c 9c       	mov	r12,r6
80006946:	f0 1f 00 17 	mcall	800069a0 <logFromISR+0x170>
8000694a:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000694c:	0c 9a       	mov	r10,r6
8000694e:	0e 9b       	mov	r11,r7
80006950:	f0 1f 00 15 	mcall	800069a4 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006954:	30 09       	mov	r9,0
80006956:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006958:	fa ca fe f8 	sub	r10,sp,-264
8000695c:	fa cb fe f4 	sub	r11,sp,-268
80006960:	49 28       	lddpc	r8,800069a8 <logFromISR+0x178>
80006962:	70 0c       	ld.w	r12,r8[0x0]
80006964:	f0 1f 00 12 	mcall	800069ac <logFromISR+0x17c>
80006968:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000696a:	fe 3d fd f4 	sub	sp,-524
8000696e:	d8 32       	popm	r0-r7,pc
80006970:	80 00       	ld.sh	r0,r0[0x0]
80006972:	71 4c       	ld.w	r12,r8[0x50]
80006974:	00 00       	add	r0,r0
80006976:	0d 85       	ld.ub	r5,r6[0x0]
80006978:	80 01       	ld.sh	r1,r0[0x0]
8000697a:	5b 78       	cp.w	r8,-9
8000697c:	80 00       	ld.sh	r0,r0[0x0]
8000697e:	65 ca       	ld.w	r10,r2[0x70]
80006980:	80 00       	ld.sh	r0,r0[0x0]
80006982:	65 18       	ld.w	r8,r2[0x44]
80006984:	80 00       	ld.sh	r0,r0[0x0]
80006986:	65 14       	ld.w	r4,r2[0x44]
80006988:	80 01       	ld.sh	r1,r0[0x0]
8000698a:	5c e4       	tnbz	r4
8000698c:	80 00       	ld.sh	r0,r0[0x0]
8000698e:	66 a4       	ld.w	r4,r3[0x28]
80006990:	80 01       	ld.sh	r1,r0[0x0]
80006992:	5c f4       	rol	r4
80006994:	80 00       	ld.sh	r0,r0[0x0]
80006996:	74 3c       	ld.w	r12,r10[0xc]
80006998:	80 01       	ld.sh	r1,r0[0x0]
8000699a:	5c fc       	rol	r12
8000699c:	80 01       	ld.sh	r1,r0[0x0]
8000699e:	5d 04       	ror	r4
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	57 60       	stdsp	sp[0x1d8],r0
800069a4:	80 00       	ld.sh	r0,r0[0x0]
800069a6:	70 04       	ld.w	r4,r8[0x0]
800069a8:	00 00       	add	r0,r0
800069aa:	41 28       	lddsp	r8,sp[0x48]
800069ac:	80 00       	ld.sh	r0,r0[0x0]
800069ae:	5a 64       	cp.w	r4,-26

800069b0 <log_init>:
		
	return str;
}

void log_init(void)
{
800069b0:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
800069b2:	30 2b       	mov	r11,2
800069b4:	49 0c       	lddpc	r12,800069f4 <log_init+0x44>
800069b6:	f0 1f 00 11 	mcall	800069f8 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800069ba:	e0 6a 36 00 	mov	r10,13824
800069be:	ea 1a 01 6e 	orh	r10,0x16e
800069c2:	48 fb       	lddpc	r11,800069fc <log_init+0x4c>
800069c4:	fe 7c 18 00 	mov	r12,-59392
800069c8:	f0 1f 00 0e 	mcall	80006a00 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800069cc:	30 4b       	mov	r11,4
800069ce:	33 2c       	mov	r12,50
800069d0:	f0 1f 00 0d 	mcall	80006a04 <log_init+0x54>
800069d4:	48 d8       	lddpc	r8,80006a08 <log_init+0x58>
800069d6:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800069d8:	30 09       	mov	r9,0
800069da:	1a d9       	st.w	--sp,r9
800069dc:	1a d9       	st.w	--sp,r9
800069de:	1a d9       	st.w	--sp,r9
800069e0:	30 28       	mov	r8,2
800069e2:	e0 6a 01 80 	mov	r10,384
800069e6:	48 ab       	lddpc	r11,80006a0c <log_init+0x5c>
800069e8:	48 ac       	lddpc	r12,80006a10 <log_init+0x60>
800069ea:	f0 1f 00 0b 	mcall	80006a14 <log_init+0x64>
800069ee:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800069f0:	d8 02       	popm	pc
800069f2:	00 00       	add	r0,r0
800069f4:	80 01       	ld.sh	r1,r0[0x0]
800069f6:	5d 10       	icall	r0
800069f8:	80 00       	ld.sh	r0,r0[0x0]
800069fa:	6b 3c       	ld.w	r12,r5[0x4c]
800069fc:	80 01       	ld.sh	r1,r0[0x0]
800069fe:	5c c8       	swap.bh	r8
80006a00:	80 00       	ld.sh	r0,r0[0x0]
80006a02:	53 04       	stdsp	sp[0xc0],r4
80006a04:	80 00       	ld.sh	r0,r0[0x0]
80006a06:	5c 0c       	acr	r12
80006a08:	00 00       	add	r0,r0
80006a0a:	41 28       	lddsp	r8,sp[0x48]
80006a0c:	80 01       	ld.sh	r1,r0[0x0]
80006a0e:	5d 0c       	ror	r12
80006a10:	80 00       	ld.sh	r0,r0[0x0]
80006a12:	6a 18       	ld.w	r8,r5[0x4]
80006a14:	80 00       	ld.sh	r0,r0[0x0]
80006a16:	62 e0       	ld.w	r0,r1[0x38]

80006a18 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006a18:	eb cd 40 f8 	pushm	r3-r7,lr
80006a1c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006a1e:	48 c7       	lddpc	r7,80006a4c <task_log+0x34>
80006a20:	30 05       	mov	r5,0
80006a22:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006a24:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006a28:	0a 99       	mov	r9,r5
80006a2a:	08 9a       	mov	r10,r4
80006a2c:	1a 9b       	mov	r11,sp
80006a2e:	6e 0c       	ld.w	r12,r7[0x0]
80006a30:	f0 1f 00 08 	mcall	80006a50 <task_log+0x38>
80006a34:	58 1c       	cp.w	r12,1
80006a36:	cf 91       	brne	80006a28 <task_log+0x10>
		{
			if( NULL != str)
80006a38:	40 0b       	lddsp	r11,sp[0x0]
80006a3a:	58 0b       	cp.w	r11,0
80006a3c:	cf 60       	breq	80006a28 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80006a3e:	06 9c       	mov	r12,r3
80006a40:	f0 1f 00 05 	mcall	80006a54 <task_log+0x3c>
				vPortFree(str);
80006a44:	40 0c       	lddsp	r12,sp[0x0]
80006a46:	f0 1f 00 05 	mcall	80006a58 <task_log+0x40>
80006a4a:	ce fb       	rjmp	80006a28 <task_log+0x10>
80006a4c:	00 00       	add	r0,r0
80006a4e:	41 28       	lddsp	r8,sp[0x48]
80006a50:	80 00       	ld.sh	r0,r0[0x0]
80006a52:	58 a8       	cp.w	r8,10
80006a54:	80 00       	ld.sh	r0,r0[0x0]
80006a56:	52 b4       	stdsp	sp[0xac],r4
80006a58:	80 00       	ld.sh	r0,r0[0x0]
80006a5a:	57 38       	stdsp	sp[0x1cc],r8

80006a5c <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80006a5c:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80006a5e:	fe 78 10 00 	mov	r8,-61440
80006a62:	30 19       	mov	r9,1
80006a64:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006a68:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006a6c:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80006a70:	d3 03       	ssrf	0x10
	local_start_pll0();
80006a72:	f0 1f 00 13 	mcall	80006abc <main+0x60>
		
	INTC_init_interrupts();
80006a76:	f0 1f 00 13 	mcall	80006ac0 <main+0x64>
	
	log_init();		
80006a7a:	f0 1f 00 13 	mcall	80006ac4 <main+0x68>
	log("----start debug----");	
80006a7e:	49 3c       	lddpc	r12,80006ac8 <main+0x6c>
80006a80:	f0 1f 00 13 	mcall	80006acc <main+0x70>
		
	rtc_init();
80006a84:	f0 1f 00 13 	mcall	80006ad0 <main+0x74>
	
	//fs_init();//65795机器无法通过文件系统初始化

	tc_init();	
80006a88:	f0 1f 00 13 	mcall	80006ad4 <main+0x78>
			
	xcmp_init();
80006a8c:	f0 1f 00 13 	mcall	80006ad8 <main+0x7c>
	
	app_init();
80006a90:	f0 1f 00 13 	mcall	80006adc <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006a94:	fe 79 10 00 	mov	r9,-61440
80006a98:	f2 f8 01 60 	ld.w	r8,r9[352]
80006a9c:	e2 18 00 02 	andl	r8,0x2,COH
80006aa0:	cf c0       	breq	80006a98 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80006aa2:	fe 79 10 00 	mov	r9,-61440
80006aa6:	f2 f8 01 60 	ld.w	r8,r9[352]
80006aaa:	e2 18 00 02 	andl	r8,0x2,COH
80006aae:	cf c1       	brne	80006aa6 <main+0x4a>
	local_start_timer();
80006ab0:	f0 1f 00 0c 	mcall	80006ae0 <main+0x84>
	
	Enable_global_interrupt();
80006ab4:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80006ab6:	f0 1f 00 0c 	mcall	80006ae4 <main+0x88>
	return 0;
}
80006aba:	d8 0a       	popm	pc,r12=0
80006abc:	80 00       	ld.sh	r0,r0[0x0]
80006abe:	4b d4       	lddpc	r4,80006bb0 <free+0x4>
80006ac0:	80 00       	ld.sh	r0,r0[0x0]
80006ac2:	4d f0       	lddpc	r0,80006c3c <_malloc_r+0x70>
80006ac4:	80 00       	ld.sh	r0,r0[0x0]
80006ac6:	69 b0       	ld.w	r0,r4[0x6c]
80006ac8:	80 01       	ld.sh	r1,r0[0x0]
80006aca:	5d 20       	mustr	r0
80006acc:	80 00       	ld.sh	r0,r0[0x0]
80006ace:	66 a4       	ld.w	r4,r3[0x28]
80006ad0:	80 00       	ld.sh	r0,r0[0x0]
80006ad2:	4c 24       	lddpc	r4,80006bd8 <_malloc_r+0xc>
80006ad4:	80 00       	ld.sh	r0,r0[0x0]
80006ad6:	4c ec       	lddpc	r12,80006c0c <_malloc_r+0x40>
80006ad8:	80 00       	ld.sh	r0,r0[0x0]
80006ada:	44 d8       	lddsp	r8,sp[0x134]
80006adc:	80 00       	ld.sh	r0,r0[0x0]
80006ade:	20 40       	sub	r0,4
80006ae0:	80 00       	ld.sh	r0,r0[0x0]
80006ae2:	4c b0       	lddpc	r0,80006c0c <_malloc_r+0x40>
80006ae4:	80 00       	ld.sh	r0,r0[0x0]
80006ae6:	64 c8       	ld.w	r8,r2[0x30]

80006ae8 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006ae8:	f8 08 16 05 	lsr	r8,r12,0x5
80006aec:	a9 68       	lsl	r8,0x8
80006aee:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80006af2:	58 1b       	cp.w	r11,1
80006af4:	c0 d0       	breq	80006b0e <gpio_enable_module_pin+0x26>
80006af6:	c0 63       	brcs	80006b02 <gpio_enable_module_pin+0x1a>
80006af8:	58 2b       	cp.w	r11,2
80006afa:	c1 00       	breq	80006b1a <gpio_enable_module_pin+0x32>
80006afc:	58 3b       	cp.w	r11,3
80006afe:	c1 40       	breq	80006b26 <gpio_enable_module_pin+0x3e>
80006b00:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006b02:	30 19       	mov	r9,1
80006b04:	f2 0c 09 49 	lsl	r9,r9,r12
80006b08:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006b0a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006b0c:	c1 28       	rjmp	80006b30 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006b0e:	30 19       	mov	r9,1
80006b10:	f2 0c 09 49 	lsl	r9,r9,r12
80006b14:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006b16:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006b18:	c0 c8       	rjmp	80006b30 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006b1a:	30 19       	mov	r9,1
80006b1c:	f2 0c 09 49 	lsl	r9,r9,r12
80006b20:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006b22:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006b24:	c0 68       	rjmp	80006b30 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006b26:	30 19       	mov	r9,1
80006b28:	f2 0c 09 49 	lsl	r9,r9,r12
80006b2c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006b2e:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006b30:	30 19       	mov	r9,1
80006b32:	f2 0c 09 4c 	lsl	r12,r9,r12
80006b36:	91 2c       	st.w	r8[0x8],r12
80006b38:	5e fd       	retal	0
80006b3a:	d7 03       	nop

80006b3c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006b3c:	d4 21       	pushm	r4-r7,lr
80006b3e:	18 97       	mov	r7,r12
80006b40:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006b42:	58 0b       	cp.w	r11,0
80006b44:	c0 31       	brne	80006b4a <gpio_enable_module+0xe>
80006b46:	30 05       	mov	r5,0
80006b48:	c0 d8       	rjmp	80006b62 <gpio_enable_module+0x26>
80006b4a:	30 06       	mov	r6,0
80006b4c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80006b4e:	6e 1b       	ld.w	r11,r7[0x4]
80006b50:	6e 0c       	ld.w	r12,r7[0x0]
80006b52:	f0 1f 00 06 	mcall	80006b68 <gpio_enable_module+0x2c>
80006b56:	18 45       	or	r5,r12
		gpiomap++;
80006b58:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006b5a:	2f f6       	sub	r6,-1
80006b5c:	0c 34       	cp.w	r4,r6
80006b5e:	fe 9b ff f8 	brhi	80006b4e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006b62:	0a 9c       	mov	r12,r5
80006b64:	d8 22       	popm	r4-r7,pc
80006b66:	00 00       	add	r0,r0
80006b68:	80 00       	ld.sh	r0,r0[0x0]
80006b6a:	6a e8       	ld.w	r8,r5[0x38]

80006b6c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006b6c:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006b70:	fe c0 a5 70 	sub	r0,pc,-23184

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006b74:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006b78:	d5 53       	csrf	0x15
  cp      r0, r1
80006b7a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006b7c:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006b80:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006b82:	c0 62       	brcc	80006b8e <idata_load_loop_end>
  cp      r0, r1
80006b84:	48 92       	lddpc	r2,80006ba8 <udata_clear_loop_end+0x4>

80006b86 <idata_load_loop>:
  brlo    idata_load_loop
80006b86:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006b88:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80006b8a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80006b8c:	cf d3       	brcs	80006b86 <idata_load_loop>

80006b8e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80006b8e:	e0 60 0a 38 	mov	r0,2616
  mov     r2, 0
  mov     r3, 0
80006b92:	e0 61 41 30 	mov	r1,16688
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80006b96:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80006b98:	c0 62       	brcc	80006ba4 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006b9a:	30 02       	mov	r2,0
80006b9c:	30 03       	mov	r3,0

80006b9e <udata_clear_loop>:
80006b9e:	a1 22       	st.d	r0++,r2
80006ba0:	02 30       	cp.w	r0,r1
80006ba2:	cf e3       	brcs	80006b9e <udata_clear_loop>

80006ba4 <udata_clear_loop_end>:
80006ba4:	fe cf 01 48 	sub	pc,pc,328
80006ba8:	80 01       	ld.sh	r1,r0[0x0]
80006baa:	62 b8       	ld.w	r8,r1[0x2c]

80006bac <free>:
80006bac:	d4 01       	pushm	lr
80006bae:	e0 68 0a 30 	mov	r8,2608
80006bb2:	18 9b       	mov	r11,r12
80006bb4:	70 0c       	ld.w	r12,r8[0x0]
80006bb6:	e0 a0 1e 87 	rcall	8000a8c4 <_free_r>
80006bba:	d8 02       	popm	pc

80006bbc <malloc>:
80006bbc:	d4 01       	pushm	lr
80006bbe:	e0 68 0a 30 	mov	r8,2608
80006bc2:	18 9b       	mov	r11,r12
80006bc4:	70 0c       	ld.w	r12,r8[0x0]
80006bc6:	c0 3c       	rcall	80006bcc <_malloc_r>
80006bc8:	d8 02       	popm	pc
80006bca:	d7 03       	nop

80006bcc <_malloc_r>:
80006bcc:	d4 31       	pushm	r0-r7,lr
80006bce:	f6 c8 ff f5 	sub	r8,r11,-11
80006bd2:	18 95       	mov	r5,r12
80006bd4:	10 97       	mov	r7,r8
80006bd6:	e0 17 ff f8 	andl	r7,0xfff8
80006bda:	59 68       	cp.w	r8,22
80006bdc:	f9 b7 08 10 	movls	r7,16
80006be0:	16 37       	cp.w	r7,r11
80006be2:	5f 38       	srlo	r8
80006be4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006be8:	c0 50       	breq	80006bf2 <_malloc_r+0x26>
80006bea:	30 c8       	mov	r8,12
80006bec:	99 38       	st.w	r12[0xc],r8
80006bee:	e0 8f 01 fa 	bral	80006fe2 <_malloc_r+0x416>
80006bf2:	fe b0 f5 59 	rcall	800056a4 <__malloc_lock>
80006bf6:	e0 47 01 f7 	cp.w	r7,503
80006bfa:	e0 8b 00 1d 	brhi	80006c34 <_malloc_r+0x68>
80006bfe:	ee 03 16 03 	lsr	r3,r7,0x3
80006c02:	e0 68 05 30 	mov	r8,1328
80006c06:	f0 03 00 38 	add	r8,r8,r3<<0x3
80006c0a:	70 36       	ld.w	r6,r8[0xc]
80006c0c:	10 36       	cp.w	r6,r8
80006c0e:	c0 61       	brne	80006c1a <_malloc_r+0x4e>
80006c10:	ec c8 ff f8 	sub	r8,r6,-8
80006c14:	70 36       	ld.w	r6,r8[0xc]
80006c16:	10 36       	cp.w	r6,r8
80006c18:	c0 c0       	breq	80006c30 <_malloc_r+0x64>
80006c1a:	6c 18       	ld.w	r8,r6[0x4]
80006c1c:	e0 18 ff fc 	andl	r8,0xfffc
80006c20:	6c 3a       	ld.w	r10,r6[0xc]
80006c22:	ec 08 00 09 	add	r9,r6,r8
80006c26:	0a 9c       	mov	r12,r5
80006c28:	6c 28       	ld.w	r8,r6[0x8]
80006c2a:	95 28       	st.w	r10[0x8],r8
80006c2c:	91 3a       	st.w	r8[0xc],r10
80006c2e:	c4 78       	rjmp	80006cbc <_malloc_r+0xf0>
80006c30:	2f e3       	sub	r3,-2
80006c32:	c4 d8       	rjmp	80006ccc <_malloc_r+0x100>
80006c34:	ee 03 16 09 	lsr	r3,r7,0x9
80006c38:	c0 41       	brne	80006c40 <_malloc_r+0x74>
80006c3a:	ee 03 16 03 	lsr	r3,r7,0x3
80006c3e:	c2 68       	rjmp	80006c8a <_malloc_r+0xbe>
80006c40:	58 43       	cp.w	r3,4
80006c42:	e0 8b 00 06 	brhi	80006c4e <_malloc_r+0x82>
80006c46:	ee 03 16 06 	lsr	r3,r7,0x6
80006c4a:	2c 83       	sub	r3,-56
80006c4c:	c1 f8       	rjmp	80006c8a <_malloc_r+0xbe>
80006c4e:	59 43       	cp.w	r3,20
80006c50:	e0 8b 00 04 	brhi	80006c58 <_malloc_r+0x8c>
80006c54:	2a 53       	sub	r3,-91
80006c56:	c1 a8       	rjmp	80006c8a <_malloc_r+0xbe>
80006c58:	e0 43 00 54 	cp.w	r3,84
80006c5c:	e0 8b 00 06 	brhi	80006c68 <_malloc_r+0x9c>
80006c60:	ee 03 16 0c 	lsr	r3,r7,0xc
80006c64:	29 23       	sub	r3,-110
80006c66:	c1 28       	rjmp	80006c8a <_malloc_r+0xbe>
80006c68:	e0 43 01 54 	cp.w	r3,340
80006c6c:	e0 8b 00 06 	brhi	80006c78 <_malloc_r+0xac>
80006c70:	ee 03 16 0f 	lsr	r3,r7,0xf
80006c74:	28 93       	sub	r3,-119
80006c76:	c0 a8       	rjmp	80006c8a <_malloc_r+0xbe>
80006c78:	e0 43 05 54 	cp.w	r3,1364
80006c7c:	e0 88 00 04 	brls	80006c84 <_malloc_r+0xb8>
80006c80:	37 e3       	mov	r3,126
80006c82:	c0 48       	rjmp	80006c8a <_malloc_r+0xbe>
80006c84:	ee 03 16 12 	lsr	r3,r7,0x12
80006c88:	28 43       	sub	r3,-124
80006c8a:	e0 6a 05 30 	mov	r10,1328
80006c8e:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006c92:	74 36       	ld.w	r6,r10[0xc]
80006c94:	c1 98       	rjmp	80006cc6 <_malloc_r+0xfa>
80006c96:	6c 19       	ld.w	r9,r6[0x4]
80006c98:	e0 19 ff fc 	andl	r9,0xfffc
80006c9c:	f2 07 01 0b 	sub	r11,r9,r7
80006ca0:	58 fb       	cp.w	r11,15
80006ca2:	e0 8a 00 04 	brle	80006caa <_malloc_r+0xde>
80006ca6:	20 13       	sub	r3,1
80006ca8:	c1 18       	rjmp	80006cca <_malloc_r+0xfe>
80006caa:	6c 38       	ld.w	r8,r6[0xc]
80006cac:	58 0b       	cp.w	r11,0
80006cae:	c0 b5       	brlt	80006cc4 <_malloc_r+0xf8>
80006cb0:	6c 2a       	ld.w	r10,r6[0x8]
80006cb2:	ec 09 00 09 	add	r9,r6,r9
80006cb6:	0a 9c       	mov	r12,r5
80006cb8:	91 2a       	st.w	r8[0x8],r10
80006cba:	95 38       	st.w	r10[0xc],r8
80006cbc:	72 18       	ld.w	r8,r9[0x4]
80006cbe:	a1 a8       	sbr	r8,0x0
80006cc0:	93 18       	st.w	r9[0x4],r8
80006cc2:	cb c8       	rjmp	80006e3a <_malloc_r+0x26e>
80006cc4:	10 96       	mov	r6,r8
80006cc6:	14 36       	cp.w	r6,r10
80006cc8:	ce 71       	brne	80006c96 <_malloc_r+0xca>
80006cca:	2f f3       	sub	r3,-1
80006ccc:	e0 6a 05 30 	mov	r10,1328
80006cd0:	f4 cc ff f8 	sub	r12,r10,-8
80006cd4:	78 26       	ld.w	r6,r12[0x8]
80006cd6:	18 36       	cp.w	r6,r12
80006cd8:	c6 c0       	breq	80006db0 <_malloc_r+0x1e4>
80006cda:	6c 19       	ld.w	r9,r6[0x4]
80006cdc:	e0 19 ff fc 	andl	r9,0xfffc
80006ce0:	f2 07 01 08 	sub	r8,r9,r7
80006ce4:	58 f8       	cp.w	r8,15
80006ce6:	e0 89 00 8f 	brgt	80006e04 <_malloc_r+0x238>
80006cea:	99 3c       	st.w	r12[0xc],r12
80006cec:	99 2c       	st.w	r12[0x8],r12
80006cee:	58 08       	cp.w	r8,0
80006cf0:	c0 55       	brlt	80006cfa <_malloc_r+0x12e>
80006cf2:	ec 09 00 09 	add	r9,r6,r9
80006cf6:	0a 9c       	mov	r12,r5
80006cf8:	ce 2b       	rjmp	80006cbc <_malloc_r+0xf0>
80006cfa:	e0 49 01 ff 	cp.w	r9,511
80006cfe:	e0 8b 00 13 	brhi	80006d24 <_malloc_r+0x158>
80006d02:	a3 99       	lsr	r9,0x3
80006d04:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006d08:	70 2b       	ld.w	r11,r8[0x8]
80006d0a:	8d 38       	st.w	r6[0xc],r8
80006d0c:	8d 2b       	st.w	r6[0x8],r11
80006d0e:	97 36       	st.w	r11[0xc],r6
80006d10:	91 26       	st.w	r8[0x8],r6
80006d12:	a3 49       	asr	r9,0x2
80006d14:	74 18       	ld.w	r8,r10[0x4]
80006d16:	30 1b       	mov	r11,1
80006d18:	f6 09 09 49 	lsl	r9,r11,r9
80006d1c:	f1 e9 10 09 	or	r9,r8,r9
80006d20:	95 19       	st.w	r10[0x4],r9
80006d22:	c4 78       	rjmp	80006db0 <_malloc_r+0x1e4>
80006d24:	f2 0a 16 09 	lsr	r10,r9,0x9
80006d28:	58 4a       	cp.w	r10,4
80006d2a:	e0 8b 00 07 	brhi	80006d38 <_malloc_r+0x16c>
80006d2e:	f2 0a 16 06 	lsr	r10,r9,0x6
80006d32:	2c 8a       	sub	r10,-56
80006d34:	c2 08       	rjmp	80006d74 <_malloc_r+0x1a8>
80006d36:	d7 03       	nop
80006d38:	59 4a       	cp.w	r10,20
80006d3a:	e0 8b 00 04 	brhi	80006d42 <_malloc_r+0x176>
80006d3e:	2a 5a       	sub	r10,-91
80006d40:	c1 a8       	rjmp	80006d74 <_malloc_r+0x1a8>
80006d42:	e0 4a 00 54 	cp.w	r10,84
80006d46:	e0 8b 00 06 	brhi	80006d52 <_malloc_r+0x186>
80006d4a:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006d4e:	29 2a       	sub	r10,-110
80006d50:	c1 28       	rjmp	80006d74 <_malloc_r+0x1a8>
80006d52:	e0 4a 01 54 	cp.w	r10,340
80006d56:	e0 8b 00 06 	brhi	80006d62 <_malloc_r+0x196>
80006d5a:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006d5e:	28 9a       	sub	r10,-119
80006d60:	c0 a8       	rjmp	80006d74 <_malloc_r+0x1a8>
80006d62:	e0 4a 05 54 	cp.w	r10,1364
80006d66:	e0 88 00 04 	brls	80006d6e <_malloc_r+0x1a2>
80006d6a:	37 ea       	mov	r10,126
80006d6c:	c0 48       	rjmp	80006d74 <_malloc_r+0x1a8>
80006d6e:	f2 0a 16 12 	lsr	r10,r9,0x12
80006d72:	28 4a       	sub	r10,-124
80006d74:	e0 6b 05 30 	mov	r11,1328
80006d78:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006d7c:	68 28       	ld.w	r8,r4[0x8]
80006d7e:	08 38       	cp.w	r8,r4
80006d80:	c0 e1       	brne	80006d9c <_malloc_r+0x1d0>
80006d82:	76 19       	ld.w	r9,r11[0x4]
80006d84:	a3 4a       	asr	r10,0x2
80006d86:	30 1e       	mov	lr,1
80006d88:	fc 0a 09 4a 	lsl	r10,lr,r10
80006d8c:	f3 ea 10 0a 	or	r10,r9,r10
80006d90:	10 99       	mov	r9,r8
80006d92:	97 1a       	st.w	r11[0x4],r10
80006d94:	c0 a8       	rjmp	80006da8 <_malloc_r+0x1dc>
80006d96:	70 28       	ld.w	r8,r8[0x8]
80006d98:	08 38       	cp.w	r8,r4
80006d9a:	c0 60       	breq	80006da6 <_malloc_r+0x1da>
80006d9c:	70 1a       	ld.w	r10,r8[0x4]
80006d9e:	e0 1a ff fc 	andl	r10,0xfffc
80006da2:	14 39       	cp.w	r9,r10
80006da4:	cf 93       	brcs	80006d96 <_malloc_r+0x1ca>
80006da6:	70 39       	ld.w	r9,r8[0xc]
80006da8:	8d 39       	st.w	r6[0xc],r9
80006daa:	8d 28       	st.w	r6[0x8],r8
80006dac:	91 36       	st.w	r8[0xc],r6
80006dae:	93 26       	st.w	r9[0x8],r6
80006db0:	e6 08 14 02 	asr	r8,r3,0x2
80006db4:	30 1b       	mov	r11,1
80006db6:	e0 64 05 30 	mov	r4,1328
80006dba:	f6 08 09 4b 	lsl	r11,r11,r8
80006dbe:	68 18       	ld.w	r8,r4[0x4]
80006dc0:	10 3b       	cp.w	r11,r8
80006dc2:	e0 8b 00 6b 	brhi	80006e98 <_malloc_r+0x2cc>
80006dc6:	f7 e8 00 09 	and	r9,r11,r8
80006dca:	c0 b1       	brne	80006de0 <_malloc_r+0x214>
80006dcc:	e0 13 ff fc 	andl	r3,0xfffc
80006dd0:	a1 7b       	lsl	r11,0x1
80006dd2:	2f c3       	sub	r3,-4
80006dd4:	c0 38       	rjmp	80006dda <_malloc_r+0x20e>
80006dd6:	2f c3       	sub	r3,-4
80006dd8:	a1 7b       	lsl	r11,0x1
80006dda:	f7 e8 00 09 	and	r9,r11,r8
80006dde:	cf c0       	breq	80006dd6 <_malloc_r+0x20a>
80006de0:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006de4:	06 92       	mov	r2,r3
80006de6:	1c 91       	mov	r1,lr
80006de8:	62 36       	ld.w	r6,r1[0xc]
80006dea:	c2 e8       	rjmp	80006e46 <_malloc_r+0x27a>
80006dec:	6c 1a       	ld.w	r10,r6[0x4]
80006dee:	e0 1a ff fc 	andl	r10,0xfffc
80006df2:	f4 07 01 08 	sub	r8,r10,r7
80006df6:	58 f8       	cp.w	r8,15
80006df8:	e0 8a 00 15 	brle	80006e22 <_malloc_r+0x256>
80006dfc:	6c 3a       	ld.w	r10,r6[0xc]
80006dfe:	6c 29       	ld.w	r9,r6[0x8]
80006e00:	95 29       	st.w	r10[0x8],r9
80006e02:	93 3a       	st.w	r9[0xc],r10
80006e04:	0e 99       	mov	r9,r7
80006e06:	ec 07 00 07 	add	r7,r6,r7
80006e0a:	a1 a9       	sbr	r9,0x0
80006e0c:	99 37       	st.w	r12[0xc],r7
80006e0e:	99 27       	st.w	r12[0x8],r7
80006e10:	8d 19       	st.w	r6[0x4],r9
80006e12:	ee 08 09 08 	st.w	r7[r8],r8
80006e16:	8f 2c       	st.w	r7[0x8],r12
80006e18:	8f 3c       	st.w	r7[0xc],r12
80006e1a:	a1 a8       	sbr	r8,0x0
80006e1c:	0a 9c       	mov	r12,r5
80006e1e:	8f 18       	st.w	r7[0x4],r8
80006e20:	c0 d8       	rjmp	80006e3a <_malloc_r+0x26e>
80006e22:	6c 39       	ld.w	r9,r6[0xc]
80006e24:	58 08       	cp.w	r8,0
80006e26:	c0 f5       	brlt	80006e44 <_malloc_r+0x278>
80006e28:	ec 0a 00 0a 	add	r10,r6,r10
80006e2c:	74 18       	ld.w	r8,r10[0x4]
80006e2e:	a1 a8       	sbr	r8,0x0
80006e30:	0a 9c       	mov	r12,r5
80006e32:	95 18       	st.w	r10[0x4],r8
80006e34:	6c 28       	ld.w	r8,r6[0x8]
80006e36:	93 28       	st.w	r9[0x8],r8
80006e38:	91 39       	st.w	r8[0xc],r9
80006e3a:	fe b0 f4 3b 	rcall	800056b0 <__malloc_unlock>
80006e3e:	ec cc ff f8 	sub	r12,r6,-8
80006e42:	d8 32       	popm	r0-r7,pc
80006e44:	12 96       	mov	r6,r9
80006e46:	02 36       	cp.w	r6,r1
80006e48:	cd 21       	brne	80006dec <_malloc_r+0x220>
80006e4a:	2f f2       	sub	r2,-1
80006e4c:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006e50:	c0 30       	breq	80006e56 <_malloc_r+0x28a>
80006e52:	2f 81       	sub	r1,-8
80006e54:	cc ab       	rjmp	80006de8 <_malloc_r+0x21c>
80006e56:	1c 98       	mov	r8,lr
80006e58:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006e5c:	c0 81       	brne	80006e6c <_malloc_r+0x2a0>
80006e5e:	68 19       	ld.w	r9,r4[0x4]
80006e60:	f6 08 11 ff 	rsub	r8,r11,-1
80006e64:	f3 e8 00 08 	and	r8,r9,r8
80006e68:	89 18       	st.w	r4[0x4],r8
80006e6a:	c0 78       	rjmp	80006e78 <_malloc_r+0x2ac>
80006e6c:	f0 c9 00 08 	sub	r9,r8,8
80006e70:	20 13       	sub	r3,1
80006e72:	70 08       	ld.w	r8,r8[0x0]
80006e74:	12 38       	cp.w	r8,r9
80006e76:	cf 10       	breq	80006e58 <_malloc_r+0x28c>
80006e78:	a1 7b       	lsl	r11,0x1
80006e7a:	68 18       	ld.w	r8,r4[0x4]
80006e7c:	10 3b       	cp.w	r11,r8
80006e7e:	e0 8b 00 0d 	brhi	80006e98 <_malloc_r+0x2cc>
80006e82:	58 0b       	cp.w	r11,0
80006e84:	c0 a0       	breq	80006e98 <_malloc_r+0x2cc>
80006e86:	04 93       	mov	r3,r2
80006e88:	c0 38       	rjmp	80006e8e <_malloc_r+0x2c2>
80006e8a:	2f c3       	sub	r3,-4
80006e8c:	a1 7b       	lsl	r11,0x1
80006e8e:	f7 e8 00 09 	and	r9,r11,r8
80006e92:	ca 71       	brne	80006de0 <_malloc_r+0x214>
80006e94:	cf bb       	rjmp	80006e8a <_malloc_r+0x2be>
80006e96:	d7 03       	nop
80006e98:	68 23       	ld.w	r3,r4[0x8]
80006e9a:	66 12       	ld.w	r2,r3[0x4]
80006e9c:	e0 12 ff fc 	andl	r2,0xfffc
80006ea0:	0e 32       	cp.w	r2,r7
80006ea2:	5f 39       	srlo	r9
80006ea4:	e4 07 01 08 	sub	r8,r2,r7
80006ea8:	58 f8       	cp.w	r8,15
80006eaa:	5f aa       	srle	r10
80006eac:	f5 e9 10 09 	or	r9,r10,r9
80006eb0:	e0 80 00 9a 	breq	80006fe4 <_malloc_r+0x418>
80006eb4:	e0 68 0d 90 	mov	r8,3472
80006eb8:	70 01       	ld.w	r1,r8[0x0]
80006eba:	e0 68 09 3c 	mov	r8,2364
80006ebe:	2f 01       	sub	r1,-16
80006ec0:	70 08       	ld.w	r8,r8[0x0]
80006ec2:	0e 01       	add	r1,r7
80006ec4:	5b f8       	cp.w	r8,-1
80006ec6:	c0 40       	breq	80006ece <_malloc_r+0x302>
80006ec8:	28 11       	sub	r1,-127
80006eca:	e0 11 ff 80 	andl	r1,0xff80
80006ece:	02 9b       	mov	r11,r1
80006ed0:	0a 9c       	mov	r12,r5
80006ed2:	e0 a0 02 a5 	rcall	8000741c <_sbrk_r>
80006ed6:	18 96       	mov	r6,r12
80006ed8:	5b fc       	cp.w	r12,-1
80006eda:	c7 50       	breq	80006fc4 <_malloc_r+0x3f8>
80006edc:	e6 02 00 08 	add	r8,r3,r2
80006ee0:	10 3c       	cp.w	r12,r8
80006ee2:	c0 32       	brcc	80006ee8 <_malloc_r+0x31c>
80006ee4:	08 33       	cp.w	r3,r4
80006ee6:	c6 f1       	brne	80006fc4 <_malloc_r+0x3f8>
80006ee8:	e0 6a 0d 94 	mov	r10,3476
80006eec:	74 09       	ld.w	r9,r10[0x0]
80006eee:	e2 09 00 09 	add	r9,r1,r9
80006ef2:	95 09       	st.w	r10[0x0],r9
80006ef4:	10 36       	cp.w	r6,r8
80006ef6:	c0 a1       	brne	80006f0a <_malloc_r+0x33e>
80006ef8:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006efc:	c0 71       	brne	80006f0a <_malloc_r+0x33e>
80006efe:	e2 02 00 02 	add	r2,r1,r2
80006f02:	68 28       	ld.w	r8,r4[0x8]
80006f04:	a1 a2       	sbr	r2,0x0
80006f06:	91 12       	st.w	r8[0x4],r2
80006f08:	c4 f8       	rjmp	80006fa6 <_malloc_r+0x3da>
80006f0a:	e0 6a 09 3c 	mov	r10,2364
80006f0e:	74 0b       	ld.w	r11,r10[0x0]
80006f10:	5b fb       	cp.w	r11,-1
80006f12:	c0 31       	brne	80006f18 <_malloc_r+0x34c>
80006f14:	95 06       	st.w	r10[0x0],r6
80006f16:	c0 78       	rjmp	80006f24 <_malloc_r+0x358>
80006f18:	ec 09 00 09 	add	r9,r6,r9
80006f1c:	e0 6a 0d 94 	mov	r10,3476
80006f20:	10 19       	sub	r9,r8
80006f22:	95 09       	st.w	r10[0x0],r9
80006f24:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006f28:	f0 09 11 08 	rsub	r9,r8,8
80006f2c:	58 08       	cp.w	r8,0
80006f2e:	f2 08 17 10 	movne	r8,r9
80006f32:	ed d8 e1 06 	addne	r6,r6,r8
80006f36:	28 08       	sub	r8,-128
80006f38:	ec 01 00 01 	add	r1,r6,r1
80006f3c:	0a 9c       	mov	r12,r5
80006f3e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006f42:	f0 01 01 01 	sub	r1,r8,r1
80006f46:	02 9b       	mov	r11,r1
80006f48:	e0 a0 02 6a 	rcall	8000741c <_sbrk_r>
80006f4c:	e0 68 0d 94 	mov	r8,3476
80006f50:	5b fc       	cp.w	r12,-1
80006f52:	ec 0c 17 00 	moveq	r12,r6
80006f56:	f9 b1 00 00 	moveq	r1,0
80006f5a:	70 09       	ld.w	r9,r8[0x0]
80006f5c:	0c 1c       	sub	r12,r6
80006f5e:	89 26       	st.w	r4[0x8],r6
80006f60:	02 0c       	add	r12,r1
80006f62:	12 01       	add	r1,r9
80006f64:	a1 ac       	sbr	r12,0x0
80006f66:	91 01       	st.w	r8[0x0],r1
80006f68:	8d 1c       	st.w	r6[0x4],r12
80006f6a:	08 33       	cp.w	r3,r4
80006f6c:	c1 d0       	breq	80006fa6 <_malloc_r+0x3da>
80006f6e:	58 f2       	cp.w	r2,15
80006f70:	e0 8b 00 05 	brhi	80006f7a <_malloc_r+0x3ae>
80006f74:	30 18       	mov	r8,1
80006f76:	8d 18       	st.w	r6[0x4],r8
80006f78:	c2 68       	rjmp	80006fc4 <_malloc_r+0x3f8>
80006f7a:	30 59       	mov	r9,5
80006f7c:	20 c2       	sub	r2,12
80006f7e:	e0 12 ff f8 	andl	r2,0xfff8
80006f82:	e6 02 00 08 	add	r8,r3,r2
80006f86:	91 29       	st.w	r8[0x8],r9
80006f88:	91 19       	st.w	r8[0x4],r9
80006f8a:	66 18       	ld.w	r8,r3[0x4]
80006f8c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006f90:	e5 e8 10 08 	or	r8,r2,r8
80006f94:	87 18       	st.w	r3[0x4],r8
80006f96:	58 f2       	cp.w	r2,15
80006f98:	e0 88 00 07 	brls	80006fa6 <_malloc_r+0x3da>
80006f9c:	e6 cb ff f8 	sub	r11,r3,-8
80006fa0:	0a 9c       	mov	r12,r5
80006fa2:	e0 a0 1c 91 	rcall	8000a8c4 <_free_r>
80006fa6:	e0 69 0d 8c 	mov	r9,3468
80006faa:	72 0a       	ld.w	r10,r9[0x0]
80006fac:	e0 68 0d 94 	mov	r8,3476
80006fb0:	70 08       	ld.w	r8,r8[0x0]
80006fb2:	14 38       	cp.w	r8,r10
80006fb4:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006fb8:	e0 69 0d 88 	mov	r9,3464
80006fbc:	72 0a       	ld.w	r10,r9[0x0]
80006fbe:	14 38       	cp.w	r8,r10
80006fc0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006fc4:	68 28       	ld.w	r8,r4[0x8]
80006fc6:	70 18       	ld.w	r8,r8[0x4]
80006fc8:	e0 18 ff fc 	andl	r8,0xfffc
80006fcc:	0e 38       	cp.w	r8,r7
80006fce:	5f 39       	srlo	r9
80006fd0:	0e 18       	sub	r8,r7
80006fd2:	58 f8       	cp.w	r8,15
80006fd4:	5f aa       	srle	r10
80006fd6:	f5 e9 10 09 	or	r9,r10,r9
80006fda:	c0 50       	breq	80006fe4 <_malloc_r+0x418>
80006fdc:	0a 9c       	mov	r12,r5
80006fde:	fe b0 f3 69 	rcall	800056b0 <__malloc_unlock>
80006fe2:	d8 3a       	popm	r0-r7,pc,r12=0
80006fe4:	68 26       	ld.w	r6,r4[0x8]
80006fe6:	a1 a8       	sbr	r8,0x0
80006fe8:	0e 99       	mov	r9,r7
80006fea:	a1 a9       	sbr	r9,0x0
80006fec:	8d 19       	st.w	r6[0x4],r9
80006fee:	ec 07 00 07 	add	r7,r6,r7
80006ff2:	0a 9c       	mov	r12,r5
80006ff4:	89 27       	st.w	r4[0x8],r7
80006ff6:	8f 18       	st.w	r7[0x4],r8
80006ff8:	fe b0 f3 5c 	rcall	800056b0 <__malloc_unlock>
80006ffc:	ec cc ff f8 	sub	r12,r6,-8
80007000:	d8 32       	popm	r0-r7,pc
80007002:	d7 03       	nop

80007004 <memcpy>:
80007004:	58 8a       	cp.w	r10,8
80007006:	c2 f5       	brlt	80007064 <memcpy+0x60>
80007008:	f9 eb 10 09 	or	r9,r12,r11
8000700c:	e2 19 00 03 	andl	r9,0x3,COH
80007010:	e0 81 00 97 	brne	8000713e <memcpy+0x13a>
80007014:	e0 4a 00 20 	cp.w	r10,32
80007018:	c3 b4       	brge	8000708e <memcpy+0x8a>
8000701a:	f4 08 14 02 	asr	r8,r10,0x2
8000701e:	f0 09 11 08 	rsub	r9,r8,8
80007022:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007026:	76 69       	ld.w	r9,r11[0x18]
80007028:	99 69       	st.w	r12[0x18],r9
8000702a:	76 59       	ld.w	r9,r11[0x14]
8000702c:	99 59       	st.w	r12[0x14],r9
8000702e:	76 49       	ld.w	r9,r11[0x10]
80007030:	99 49       	st.w	r12[0x10],r9
80007032:	76 39       	ld.w	r9,r11[0xc]
80007034:	99 39       	st.w	r12[0xc],r9
80007036:	76 29       	ld.w	r9,r11[0x8]
80007038:	99 29       	st.w	r12[0x8],r9
8000703a:	76 19       	ld.w	r9,r11[0x4]
8000703c:	99 19       	st.w	r12[0x4],r9
8000703e:	76 09       	ld.w	r9,r11[0x0]
80007040:	99 09       	st.w	r12[0x0],r9
80007042:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007046:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000704a:	e0 1a 00 03 	andl	r10,0x3
8000704e:	f4 0a 11 04 	rsub	r10,r10,4
80007052:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007056:	17 a9       	ld.ub	r9,r11[0x2]
80007058:	b0 a9       	st.b	r8[0x2],r9
8000705a:	17 99       	ld.ub	r9,r11[0x1]
8000705c:	b0 99       	st.b	r8[0x1],r9
8000705e:	17 89       	ld.ub	r9,r11[0x0]
80007060:	b0 89       	st.b	r8[0x0],r9
80007062:	5e fc       	retal	r12
80007064:	f4 0a 11 09 	rsub	r10,r10,9
80007068:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000706c:	17 f9       	ld.ub	r9,r11[0x7]
8000706e:	b8 f9       	st.b	r12[0x7],r9
80007070:	17 e9       	ld.ub	r9,r11[0x6]
80007072:	b8 e9       	st.b	r12[0x6],r9
80007074:	17 d9       	ld.ub	r9,r11[0x5]
80007076:	b8 d9       	st.b	r12[0x5],r9
80007078:	17 c9       	ld.ub	r9,r11[0x4]
8000707a:	b8 c9       	st.b	r12[0x4],r9
8000707c:	17 b9       	ld.ub	r9,r11[0x3]
8000707e:	b8 b9       	st.b	r12[0x3],r9
80007080:	17 a9       	ld.ub	r9,r11[0x2]
80007082:	b8 a9       	st.b	r12[0x2],r9
80007084:	17 99       	ld.ub	r9,r11[0x1]
80007086:	b8 99       	st.b	r12[0x1],r9
80007088:	17 89       	ld.ub	r9,r11[0x0]
8000708a:	b8 89       	st.b	r12[0x0],r9
8000708c:	5e fc       	retal	r12
8000708e:	eb cd 40 c0 	pushm	r6-r7,lr
80007092:	18 99       	mov	r9,r12
80007094:	22 0a       	sub	r10,32
80007096:	b7 07       	ld.d	r6,r11++
80007098:	b3 26       	st.d	r9++,r6
8000709a:	b7 07       	ld.d	r6,r11++
8000709c:	b3 26       	st.d	r9++,r6
8000709e:	b7 07       	ld.d	r6,r11++
800070a0:	b3 26       	st.d	r9++,r6
800070a2:	b7 07       	ld.d	r6,r11++
800070a4:	b3 26       	st.d	r9++,r6
800070a6:	22 0a       	sub	r10,32
800070a8:	cf 74       	brge	80007096 <memcpy+0x92>
800070aa:	2f 0a       	sub	r10,-16
800070ac:	c0 65       	brlt	800070b8 <memcpy+0xb4>
800070ae:	b7 07       	ld.d	r6,r11++
800070b0:	b3 26       	st.d	r9++,r6
800070b2:	b7 07       	ld.d	r6,r11++
800070b4:	b3 26       	st.d	r9++,r6
800070b6:	21 0a       	sub	r10,16
800070b8:	5c 3a       	neg	r10
800070ba:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800070be:	d7 03       	nop
800070c0:	d7 03       	nop
800070c2:	f7 36 00 0e 	ld.ub	r6,r11[14]
800070c6:	f3 66 00 0e 	st.b	r9[14],r6
800070ca:	f7 36 00 0d 	ld.ub	r6,r11[13]
800070ce:	f3 66 00 0d 	st.b	r9[13],r6
800070d2:	f7 36 00 0c 	ld.ub	r6,r11[12]
800070d6:	f3 66 00 0c 	st.b	r9[12],r6
800070da:	f7 36 00 0b 	ld.ub	r6,r11[11]
800070de:	f3 66 00 0b 	st.b	r9[11],r6
800070e2:	f7 36 00 0a 	ld.ub	r6,r11[10]
800070e6:	f3 66 00 0a 	st.b	r9[10],r6
800070ea:	f7 36 00 09 	ld.ub	r6,r11[9]
800070ee:	f3 66 00 09 	st.b	r9[9],r6
800070f2:	f7 36 00 08 	ld.ub	r6,r11[8]
800070f6:	f3 66 00 08 	st.b	r9[8],r6
800070fa:	f7 36 00 07 	ld.ub	r6,r11[7]
800070fe:	f3 66 00 07 	st.b	r9[7],r6
80007102:	f7 36 00 06 	ld.ub	r6,r11[6]
80007106:	f3 66 00 06 	st.b	r9[6],r6
8000710a:	f7 36 00 05 	ld.ub	r6,r11[5]
8000710e:	f3 66 00 05 	st.b	r9[5],r6
80007112:	f7 36 00 04 	ld.ub	r6,r11[4]
80007116:	f3 66 00 04 	st.b	r9[4],r6
8000711a:	f7 36 00 03 	ld.ub	r6,r11[3]
8000711e:	f3 66 00 03 	st.b	r9[3],r6
80007122:	f7 36 00 02 	ld.ub	r6,r11[2]
80007126:	f3 66 00 02 	st.b	r9[2],r6
8000712a:	f7 36 00 01 	ld.ub	r6,r11[1]
8000712e:	f3 66 00 01 	st.b	r9[1],r6
80007132:	f7 36 00 00 	ld.ub	r6,r11[0]
80007136:	f3 66 00 00 	st.b	r9[0],r6
8000713a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000713e:	20 1a       	sub	r10,1
80007140:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007144:	f8 0a 0b 09 	st.b	r12[r10],r9
80007148:	cf b1       	brne	8000713e <memcpy+0x13a>
8000714a:	5e fc       	retal	r12

8000714c <memset>:
8000714c:	18 98       	mov	r8,r12
8000714e:	c0 38       	rjmp	80007154 <memset+0x8>
80007150:	10 cb       	st.b	r8++,r11
80007152:	20 1a       	sub	r10,1
80007154:	58 0a       	cp.w	r10,0
80007156:	cf d1       	brne	80007150 <memset+0x4>
80007158:	5e fc       	retal	r12
8000715a:	d7 03       	nop

8000715c <_realloc_r>:
8000715c:	d4 31       	pushm	r0-r7,lr
8000715e:	20 1d       	sub	sp,4
80007160:	16 94       	mov	r4,r11
80007162:	18 92       	mov	r2,r12
80007164:	14 9b       	mov	r11,r10
80007166:	58 04       	cp.w	r4,0
80007168:	c0 51       	brne	80007172 <_realloc_r+0x16>
8000716a:	fe b0 fd 31 	rcall	80006bcc <_malloc_r>
8000716e:	18 95       	mov	r5,r12
80007170:	c5 39       	rjmp	80007416 <_realloc_r+0x2ba>
80007172:	50 0a       	stdsp	sp[0x0],r10
80007174:	fe b0 f2 98 	rcall	800056a4 <__malloc_lock>
80007178:	40 0b       	lddsp	r11,sp[0x0]
8000717a:	f6 c8 ff f5 	sub	r8,r11,-11
8000717e:	e8 c1 00 08 	sub	r1,r4,8
80007182:	10 96       	mov	r6,r8
80007184:	62 1c       	ld.w	r12,r1[0x4]
80007186:	e0 16 ff f8 	andl	r6,0xfff8
8000718a:	59 68       	cp.w	r8,22
8000718c:	f9 b6 08 10 	movls	r6,16
80007190:	16 36       	cp.w	r6,r11
80007192:	5f 38       	srlo	r8
80007194:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007198:	c0 50       	breq	800071a2 <_realloc_r+0x46>
8000719a:	30 c8       	mov	r8,12
8000719c:	30 05       	mov	r5,0
8000719e:	85 38       	st.w	r2[0xc],r8
800071a0:	c3 b9       	rjmp	80007416 <_realloc_r+0x2ba>
800071a2:	18 90       	mov	r0,r12
800071a4:	e0 10 ff fc 	andl	r0,0xfffc
800071a8:	0c 30       	cp.w	r0,r6
800071aa:	e0 84 01 0b 	brge	800073c0 <_realloc_r+0x264>
800071ae:	e0 68 05 30 	mov	r8,1328
800071b2:	e2 00 00 09 	add	r9,r1,r0
800071b6:	70 25       	ld.w	r5,r8[0x8]
800071b8:	0a 39       	cp.w	r9,r5
800071ba:	c0 90       	breq	800071cc <_realloc_r+0x70>
800071bc:	72 1a       	ld.w	r10,r9[0x4]
800071be:	a1 ca       	cbr	r10,0x0
800071c0:	f2 0a 00 0a 	add	r10,r9,r10
800071c4:	74 1a       	ld.w	r10,r10[0x4]
800071c6:	ed ba 00 00 	bld	r10,0x0
800071ca:	c2 20       	breq	8000720e <_realloc_r+0xb2>
800071cc:	72 1a       	ld.w	r10,r9[0x4]
800071ce:	e0 1a ff fc 	andl	r10,0xfffc
800071d2:	f4 00 00 03 	add	r3,r10,r0
800071d6:	0a 39       	cp.w	r9,r5
800071d8:	c1 31       	brne	800071fe <_realloc_r+0xa2>
800071da:	ec c7 ff f0 	sub	r7,r6,-16
800071de:	0e 33       	cp.w	r3,r7
800071e0:	c1 95       	brlt	80007212 <_realloc_r+0xb6>
800071e2:	e2 06 00 09 	add	r9,r1,r6
800071e6:	0c 13       	sub	r3,r6
800071e8:	a1 a3       	sbr	r3,0x0
800071ea:	93 13       	st.w	r9[0x4],r3
800071ec:	91 29       	st.w	r8[0x8],r9
800071ee:	04 9c       	mov	r12,r2
800071f0:	62 18       	ld.w	r8,r1[0x4]
800071f2:	08 95       	mov	r5,r4
800071f4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800071f8:	10 46       	or	r6,r8
800071fa:	83 16       	st.w	r1[0x4],r6
800071fc:	c0 b9       	rjmp	80007412 <_realloc_r+0x2b6>
800071fe:	0c 33       	cp.w	r3,r6
80007200:	c0 95       	brlt	80007212 <_realloc_r+0xb6>
80007202:	72 28       	ld.w	r8,r9[0x8]
80007204:	02 97       	mov	r7,r1
80007206:	72 39       	ld.w	r9,r9[0xc]
80007208:	93 28       	st.w	r9[0x8],r8
8000720a:	91 39       	st.w	r8[0xc],r9
8000720c:	cd c8       	rjmp	800073c4 <_realloc_r+0x268>
8000720e:	30 0a       	mov	r10,0
80007210:	14 99       	mov	r9,r10
80007212:	ed bc 00 00 	bld	r12,0x0
80007216:	e0 80 00 95 	breq	80007340 <_realloc_r+0x1e4>
8000721a:	62 07       	ld.w	r7,r1[0x0]
8000721c:	e2 07 01 07 	sub	r7,r1,r7
80007220:	6e 1c       	ld.w	r12,r7[0x4]
80007222:	e0 1c ff fc 	andl	r12,0xfffc
80007226:	58 09       	cp.w	r9,0
80007228:	c5 60       	breq	800072d4 <_realloc_r+0x178>
8000722a:	f8 00 00 03 	add	r3,r12,r0
8000722e:	0a 39       	cp.w	r9,r5
80007230:	c4 81       	brne	800072c0 <_realloc_r+0x164>
80007232:	14 03       	add	r3,r10
80007234:	ec c9 ff f0 	sub	r9,r6,-16
80007238:	12 33       	cp.w	r3,r9
8000723a:	c4 d5       	brlt	800072d4 <_realloc_r+0x178>
8000723c:	6e 3a       	ld.w	r10,r7[0xc]
8000723e:	6e 29       	ld.w	r9,r7[0x8]
80007240:	95 29       	st.w	r10[0x8],r9
80007242:	93 3a       	st.w	r9[0xc],r10
80007244:	ee c5 ff f8 	sub	r5,r7,-8
80007248:	e0 ca 00 04 	sub	r10,r0,4
8000724c:	e0 4a 00 24 	cp.w	r10,36
80007250:	e0 8b 00 25 	brhi	8000729a <_realloc_r+0x13e>
80007254:	0a 99       	mov	r9,r5
80007256:	59 3a       	cp.w	r10,19
80007258:	e0 88 00 1a 	brls	8000728c <_realloc_r+0x130>
8000725c:	09 09       	ld.w	r9,r4++
8000725e:	8b 09       	st.w	r5[0x0],r9
80007260:	09 09       	ld.w	r9,r4++
80007262:	8f 39       	st.w	r7[0xc],r9
80007264:	ee c9 ff f0 	sub	r9,r7,-16
80007268:	59 ba       	cp.w	r10,27
8000726a:	e0 88 00 11 	brls	8000728c <_realloc_r+0x130>
8000726e:	09 0b       	ld.w	r11,r4++
80007270:	93 0b       	st.w	r9[0x0],r11
80007272:	09 09       	ld.w	r9,r4++
80007274:	8f 59       	st.w	r7[0x14],r9
80007276:	ee c9 ff e8 	sub	r9,r7,-24
8000727a:	e0 4a 00 24 	cp.w	r10,36
8000727e:	c0 71       	brne	8000728c <_realloc_r+0x130>
80007280:	09 0a       	ld.w	r10,r4++
80007282:	93 0a       	st.w	r9[0x0],r10
80007284:	ee c9 ff e0 	sub	r9,r7,-32
80007288:	09 0a       	ld.w	r10,r4++
8000728a:	8f 7a       	st.w	r7[0x1c],r10
8000728c:	09 0a       	ld.w	r10,r4++
8000728e:	12 aa       	st.w	r9++,r10
80007290:	68 0a       	ld.w	r10,r4[0x0]
80007292:	93 0a       	st.w	r9[0x0],r10
80007294:	68 1a       	ld.w	r10,r4[0x4]
80007296:	93 1a       	st.w	r9[0x4],r10
80007298:	c0 78       	rjmp	800072a6 <_realloc_r+0x14a>
8000729a:	50 08       	stdsp	sp[0x0],r8
8000729c:	08 9b       	mov	r11,r4
8000729e:	0a 9c       	mov	r12,r5
800072a0:	e0 a0 1d b5 	rcall	8000ae0a <memmove>
800072a4:	40 08       	lddsp	r8,sp[0x0]
800072a6:	ee 06 00 09 	add	r9,r7,r6
800072aa:	0c 13       	sub	r3,r6
800072ac:	a1 a3       	sbr	r3,0x0
800072ae:	93 13       	st.w	r9[0x4],r3
800072b0:	91 29       	st.w	r8[0x8],r9
800072b2:	04 9c       	mov	r12,r2
800072b4:	6e 18       	ld.w	r8,r7[0x4]
800072b6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800072ba:	10 46       	or	r6,r8
800072bc:	8f 16       	st.w	r7[0x4],r6
800072be:	ca a8       	rjmp	80007412 <_realloc_r+0x2b6>
800072c0:	14 03       	add	r3,r10
800072c2:	0c 33       	cp.w	r3,r6
800072c4:	c0 85       	brlt	800072d4 <_realloc_r+0x178>
800072c6:	72 28       	ld.w	r8,r9[0x8]
800072c8:	72 39       	ld.w	r9,r9[0xc]
800072ca:	93 28       	st.w	r9[0x8],r8
800072cc:	91 39       	st.w	r8[0xc],r9
800072ce:	6e 28       	ld.w	r8,r7[0x8]
800072d0:	6e 39       	ld.w	r9,r7[0xc]
800072d2:	c0 78       	rjmp	800072e0 <_realloc_r+0x184>
800072d4:	f8 00 00 03 	add	r3,r12,r0
800072d8:	0c 33       	cp.w	r3,r6
800072da:	c3 35       	brlt	80007340 <_realloc_r+0x1e4>
800072dc:	6e 39       	ld.w	r9,r7[0xc]
800072de:	6e 28       	ld.w	r8,r7[0x8]
800072e0:	93 28       	st.w	r9[0x8],r8
800072e2:	91 39       	st.w	r8[0xc],r9
800072e4:	e0 ca 00 04 	sub	r10,r0,4
800072e8:	ee cc ff f8 	sub	r12,r7,-8
800072ec:	e0 4a 00 24 	cp.w	r10,36
800072f0:	e0 8b 00 24 	brhi	80007338 <_realloc_r+0x1dc>
800072f4:	59 3a       	cp.w	r10,19
800072f6:	e0 88 00 1a 	brls	8000732a <_realloc_r+0x1ce>
800072fa:	09 08       	ld.w	r8,r4++
800072fc:	99 08       	st.w	r12[0x0],r8
800072fe:	09 08       	ld.w	r8,r4++
80007300:	8f 38       	st.w	r7[0xc],r8
80007302:	ee cc ff f0 	sub	r12,r7,-16
80007306:	59 ba       	cp.w	r10,27
80007308:	e0 88 00 11 	brls	8000732a <_realloc_r+0x1ce>
8000730c:	09 08       	ld.w	r8,r4++
8000730e:	99 08       	st.w	r12[0x0],r8
80007310:	09 08       	ld.w	r8,r4++
80007312:	8f 58       	st.w	r7[0x14],r8
80007314:	ee cc ff e8 	sub	r12,r7,-24
80007318:	e0 4a 00 24 	cp.w	r10,36
8000731c:	c0 71       	brne	8000732a <_realloc_r+0x1ce>
8000731e:	09 08       	ld.w	r8,r4++
80007320:	99 08       	st.w	r12[0x0],r8
80007322:	ee cc ff e0 	sub	r12,r7,-32
80007326:	09 08       	ld.w	r8,r4++
80007328:	8f 78       	st.w	r7[0x1c],r8
8000732a:	09 08       	ld.w	r8,r4++
8000732c:	18 a8       	st.w	r12++,r8
8000732e:	68 08       	ld.w	r8,r4[0x0]
80007330:	99 08       	st.w	r12[0x0],r8
80007332:	68 18       	ld.w	r8,r4[0x4]
80007334:	99 18       	st.w	r12[0x4],r8
80007336:	c4 78       	rjmp	800073c4 <_realloc_r+0x268>
80007338:	08 9b       	mov	r11,r4
8000733a:	e0 a0 1d 68 	rcall	8000ae0a <memmove>
8000733e:	c4 38       	rjmp	800073c4 <_realloc_r+0x268>
80007340:	04 9c       	mov	r12,r2
80007342:	fe b0 fc 45 	rcall	80006bcc <_malloc_r>
80007346:	18 95       	mov	r5,r12
80007348:	c3 a0       	breq	800073bc <_realloc_r+0x260>
8000734a:	62 18       	ld.w	r8,r1[0x4]
8000734c:	f8 c9 00 08 	sub	r9,r12,8
80007350:	a1 c8       	cbr	r8,0x0
80007352:	e2 08 00 08 	add	r8,r1,r8
80007356:	10 39       	cp.w	r9,r8
80007358:	c0 71       	brne	80007366 <_realloc_r+0x20a>
8000735a:	72 13       	ld.w	r3,r9[0x4]
8000735c:	02 97       	mov	r7,r1
8000735e:	e0 13 ff fc 	andl	r3,0xfffc
80007362:	00 03       	add	r3,r0
80007364:	c3 08       	rjmp	800073c4 <_realloc_r+0x268>
80007366:	e0 ca 00 04 	sub	r10,r0,4
8000736a:	e0 4a 00 24 	cp.w	r10,36
8000736e:	e0 8b 00 20 	brhi	800073ae <_realloc_r+0x252>
80007372:	08 99       	mov	r9,r4
80007374:	18 98       	mov	r8,r12
80007376:	59 3a       	cp.w	r10,19
80007378:	e0 88 00 14 	brls	800073a0 <_realloc_r+0x244>
8000737c:	13 0b       	ld.w	r11,r9++
8000737e:	10 ab       	st.w	r8++,r11
80007380:	13 0b       	ld.w	r11,r9++
80007382:	10 ab       	st.w	r8++,r11
80007384:	59 ba       	cp.w	r10,27
80007386:	e0 88 00 0d 	brls	800073a0 <_realloc_r+0x244>
8000738a:	13 0b       	ld.w	r11,r9++
8000738c:	10 ab       	st.w	r8++,r11
8000738e:	13 0b       	ld.w	r11,r9++
80007390:	10 ab       	st.w	r8++,r11
80007392:	e0 4a 00 24 	cp.w	r10,36
80007396:	c0 51       	brne	800073a0 <_realloc_r+0x244>
80007398:	13 0a       	ld.w	r10,r9++
8000739a:	10 aa       	st.w	r8++,r10
8000739c:	13 0a       	ld.w	r10,r9++
8000739e:	10 aa       	st.w	r8++,r10
800073a0:	13 0a       	ld.w	r10,r9++
800073a2:	10 aa       	st.w	r8++,r10
800073a4:	72 0a       	ld.w	r10,r9[0x0]
800073a6:	91 0a       	st.w	r8[0x0],r10
800073a8:	72 19       	ld.w	r9,r9[0x4]
800073aa:	91 19       	st.w	r8[0x4],r9
800073ac:	c0 48       	rjmp	800073b4 <_realloc_r+0x258>
800073ae:	08 9b       	mov	r11,r4
800073b0:	e0 a0 1d 2d 	rcall	8000ae0a <memmove>
800073b4:	08 9b       	mov	r11,r4
800073b6:	04 9c       	mov	r12,r2
800073b8:	e0 a0 1a 86 	rcall	8000a8c4 <_free_r>
800073bc:	04 9c       	mov	r12,r2
800073be:	c2 a8       	rjmp	80007412 <_realloc_r+0x2b6>
800073c0:	00 93       	mov	r3,r0
800073c2:	02 97       	mov	r7,r1
800073c4:	e6 06 01 09 	sub	r9,r3,r6
800073c8:	6e 18       	ld.w	r8,r7[0x4]
800073ca:	58 f9       	cp.w	r9,15
800073cc:	e0 88 00 16 	brls	800073f8 <_realloc_r+0x29c>
800073d0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800073d4:	ed e8 10 08 	or	r8,r6,r8
800073d8:	8f 18       	st.w	r7[0x4],r8
800073da:	12 98       	mov	r8,r9
800073dc:	a1 a8       	sbr	r8,0x0
800073de:	ee 06 00 0b 	add	r11,r7,r6
800073e2:	f6 09 00 09 	add	r9,r11,r9
800073e6:	97 18       	st.w	r11[0x4],r8
800073e8:	72 18       	ld.w	r8,r9[0x4]
800073ea:	a1 a8       	sbr	r8,0x0
800073ec:	2f 8b       	sub	r11,-8
800073ee:	93 18       	st.w	r9[0x4],r8
800073f0:	04 9c       	mov	r12,r2
800073f2:	e0 a0 1a 69 	rcall	8000a8c4 <_free_r>
800073f6:	c0 b8       	rjmp	8000740c <_realloc_r+0x2b0>
800073f8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800073fc:	e7 e8 10 08 	or	r8,r3,r8
80007400:	8f 18       	st.w	r7[0x4],r8
80007402:	ee 03 00 03 	add	r3,r7,r3
80007406:	66 18       	ld.w	r8,r3[0x4]
80007408:	a1 a8       	sbr	r8,0x0
8000740a:	87 18       	st.w	r3[0x4],r8
8000740c:	04 9c       	mov	r12,r2
8000740e:	ee c5 ff f8 	sub	r5,r7,-8
80007412:	fe b0 f1 4f 	rcall	800056b0 <__malloc_unlock>
80007416:	0a 9c       	mov	r12,r5
80007418:	2f fd       	sub	sp,-4
8000741a:	d8 32       	popm	r0-r7,pc

8000741c <_sbrk_r>:
8000741c:	d4 21       	pushm	r4-r7,lr
8000741e:	30 08       	mov	r8,0
80007420:	18 97       	mov	r7,r12
80007422:	e0 66 41 2c 	mov	r6,16684
80007426:	16 9c       	mov	r12,r11
80007428:	8d 08       	st.w	r6[0x0],r8
8000742a:	c9 1c       	rcall	8000754c <_sbrk>
8000742c:	5b fc       	cp.w	r12,-1
8000742e:	c0 51       	brne	80007438 <_sbrk_r+0x1c>
80007430:	6c 08       	ld.w	r8,r6[0x0]
80007432:	58 08       	cp.w	r8,0
80007434:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007438:	d8 22       	popm	r4-r7,pc
8000743a:	d7 03       	nop

8000743c <sprintf>:
8000743c:	d4 01       	pushm	lr
8000743e:	21 7d       	sub	sp,92
80007440:	e0 68 ff ff 	mov	r8,65535
80007444:	ea 18 7f ff 	orh	r8,0x7fff
80007448:	50 58       	stdsp	sp[0x14],r8
8000744a:	50 28       	stdsp	sp[0x8],r8
8000744c:	e0 68 02 08 	mov	r8,520
80007450:	ba 68       	st.h	sp[0xc],r8
80007452:	3f f8       	mov	r8,-1
80007454:	ba 78       	st.h	sp[0xe],r8
80007456:	e0 68 0a 30 	mov	r8,2608
8000745a:	50 4c       	stdsp	sp[0x10],r12
8000745c:	16 9a       	mov	r10,r11
8000745e:	50 0c       	stdsp	sp[0x0],r12
80007460:	fa c9 ff a0 	sub	r9,sp,-96
80007464:	70 0c       	ld.w	r12,r8[0x0]
80007466:	1a 9b       	mov	r11,sp
80007468:	e0 a0 02 2c 	rcall	800078c0 <_vfprintf_r>
8000746c:	30 09       	mov	r9,0
8000746e:	40 08       	lddsp	r8,sp[0x0]
80007470:	b0 89       	st.b	r8[0x0],r9
80007472:	2e 9d       	sub	sp,-92
80007474:	d8 02       	popm	pc
80007476:	d7 03       	nop

80007478 <strlen>:
80007478:	30 09       	mov	r9,0
8000747a:	18 98       	mov	r8,r12
8000747c:	c0 28       	rjmp	80007480 <strlen+0x8>
8000747e:	2f f8       	sub	r8,-1
80007480:	11 8a       	ld.ub	r10,r8[0x0]
80007482:	f2 0a 18 00 	cp.b	r10,r9
80007486:	cf c1       	brne	8000747e <strlen+0x6>
80007488:	f0 0c 01 0c 	sub	r12,r8,r12
8000748c:	5e fc       	retal	r12
8000748e:	d7 03       	nop

80007490 <strncpy>:
80007490:	30 08       	mov	r8,0
80007492:	10 3a       	cp.w	r10,r8
80007494:	5e 0c       	reteq	r12
80007496:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000749a:	f8 08 0b 09 	st.b	r12[r8],r9
8000749e:	2f f8       	sub	r8,-1
800074a0:	58 09       	cp.w	r9,0
800074a2:	cf 81       	brne	80007492 <strncpy+0x2>
800074a4:	10 3a       	cp.w	r10,r8
800074a6:	5e 0c       	reteq	r12
800074a8:	f8 08 0b 09 	st.b	r12[r8],r9
800074ac:	2f f8       	sub	r8,-1
800074ae:	cf bb       	rjmp	800074a4 <strncpy+0x14>

800074b0 <_close>:
800074b0:	30 28       	mov	r8,2
800074b2:	d6 73       	breakpoint
800074b4:	3f fc       	mov	r12,-1
800074b6:	35 8b       	mov	r11,88
800074b8:	58 0c       	cp.w	r12,0
800074ba:	5e 4c       	retge	r12
800074bc:	e0 6a 41 2c 	mov	r10,16684
800074c0:	95 0b       	st.w	r10[0x0],r11
800074c2:	5e fc       	retal	r12

800074c4 <_lseek>:
800074c4:	30 58       	mov	r8,5
800074c6:	d6 73       	breakpoint
800074c8:	3f fc       	mov	r12,-1
800074ca:	35 8b       	mov	r11,88
800074cc:	58 0c       	cp.w	r12,0
800074ce:	5e 4c       	retge	r12
800074d0:	e0 6a 41 2c 	mov	r10,16684
800074d4:	95 0b       	st.w	r10[0x0],r11
800074d6:	5e fc       	retal	r12

800074d8 <isatty>:
800074d8:	30 b8       	mov	r8,11
800074da:	d6 73       	breakpoint
800074dc:	3f fc       	mov	r12,-1
800074de:	35 8b       	mov	r11,88
800074e0:	58 0c       	cp.w	r12,0
800074e2:	5e 4c       	retge	r12
800074e4:	e0 6a 41 2c 	mov	r10,16684
800074e8:	95 0b       	st.w	r10[0x0],r11
800074ea:	5e fc       	retal	r12

800074ec <_fstat_host>:
800074ec:	30 98       	mov	r8,9
800074ee:	d6 73       	breakpoint
800074f0:	3f fc       	mov	r12,-1
800074f2:	35 8b       	mov	r11,88
800074f4:	58 0c       	cp.w	r12,0
800074f6:	5e 4c       	retge	r12
800074f8:	e0 6a 41 2c 	mov	r10,16684
800074fc:	95 0b       	st.w	r10[0x0],r11
800074fe:	5e fc       	retal	r12

80007500 <_fstat>:
80007500:	d4 21       	pushm	r4-r7,lr
80007502:	21 0d       	sub	sp,64
80007504:	16 97       	mov	r7,r11
80007506:	1a 9b       	mov	r11,sp
80007508:	cf 2f       	rcall	800074ec <_fstat_host>
8000750a:	c0 34       	brge	80007510 <_fstat+0x10>
8000750c:	3f fc       	mov	r12,-1
8000750e:	c1 c8       	rjmp	80007546 <_fstat+0x46>
80007510:	40 08       	lddsp	r8,sp[0x0]
80007512:	ae 08       	st.h	r7[0x0],r8
80007514:	40 18       	lddsp	r8,sp[0x4]
80007516:	ae 18       	st.h	r7[0x2],r8
80007518:	40 28       	lddsp	r8,sp[0x8]
8000751a:	8f 18       	st.w	r7[0x4],r8
8000751c:	40 38       	lddsp	r8,sp[0xc]
8000751e:	ae 48       	st.h	r7[0x8],r8
80007520:	40 48       	lddsp	r8,sp[0x10]
80007522:	ae 58       	st.h	r7[0xa],r8
80007524:	40 58       	lddsp	r8,sp[0x14]
80007526:	ae 68       	st.h	r7[0xc],r8
80007528:	40 68       	lddsp	r8,sp[0x18]
8000752a:	ae 78       	st.h	r7[0xe],r8
8000752c:	40 88       	lddsp	r8,sp[0x20]
8000752e:	8f 48       	st.w	r7[0x10],r8
80007530:	40 a8       	lddsp	r8,sp[0x28]
80007532:	8f b8       	st.w	r7[0x2c],r8
80007534:	40 c8       	lddsp	r8,sp[0x30]
80007536:	8f c8       	st.w	r7[0x30],r8
80007538:	40 d8       	lddsp	r8,sp[0x34]
8000753a:	8f 58       	st.w	r7[0x14],r8
8000753c:	40 e8       	lddsp	r8,sp[0x38]
8000753e:	30 0c       	mov	r12,0
80007540:	8f 78       	st.w	r7[0x1c],r8
80007542:	40 f8       	lddsp	r8,sp[0x3c]
80007544:	8f 98       	st.w	r7[0x24],r8
80007546:	2f 0d       	sub	sp,-64
80007548:	d8 22       	popm	r4-r7,pc
8000754a:	d7 03       	nop

8000754c <_sbrk>:
8000754c:	d4 01       	pushm	lr
8000754e:	e0 68 0d bc 	mov	r8,3516
80007552:	70 09       	ld.w	r9,r8[0x0]
80007554:	58 09       	cp.w	r9,0
80007556:	c0 41       	brne	8000755e <_sbrk+0x12>
80007558:	e0 69 41 30 	mov	r9,16688
8000755c:	91 09       	st.w	r8[0x0],r9
8000755e:	e0 69 0d bc 	mov	r9,3516
80007562:	e0 7a 70 00 	mov	r10,94208
80007566:	72 08       	ld.w	r8,r9[0x0]
80007568:	f0 0c 00 0c 	add	r12,r8,r12
8000756c:	14 3c       	cp.w	r12,r10
8000756e:	e0 8b 00 04 	brhi	80007576 <_sbrk+0x2a>
80007572:	93 0c       	st.w	r9[0x0],r12
80007574:	c0 68       	rjmp	80007580 <_sbrk+0x34>
80007576:	e0 a0 18 2b 	rcall	8000a5cc <__errno>
8000757a:	30 c8       	mov	r8,12
8000757c:	99 08       	st.w	r12[0x0],r8
8000757e:	3f f8       	mov	r8,-1
80007580:	10 9c       	mov	r12,r8
80007582:	d8 02       	popm	pc

80007584 <get_arg>:
80007584:	d4 31       	pushm	r0-r7,lr
80007586:	20 8d       	sub	sp,32
80007588:	fa c4 ff bc 	sub	r4,sp,-68
8000758c:	50 4b       	stdsp	sp[0x10],r11
8000758e:	68 2e       	ld.w	lr,r4[0x8]
80007590:	50 58       	stdsp	sp[0x14],r8
80007592:	12 96       	mov	r6,r9
80007594:	7c 0b       	ld.w	r11,lr[0x0]
80007596:	70 05       	ld.w	r5,r8[0x0]
80007598:	50 6e       	stdsp	sp[0x18],lr
8000759a:	58 0b       	cp.w	r11,0
8000759c:	f4 0b 17 00 	moveq	r11,r10
800075a0:	68 03       	ld.w	r3,r4[0x0]
800075a2:	68 11       	ld.w	r1,r4[0x4]
800075a4:	40 49       	lddsp	r9,sp[0x10]
800075a6:	30 08       	mov	r8,0
800075a8:	c2 e9       	rjmp	80007804 <get_arg+0x280>
800075aa:	2f fb       	sub	r11,-1
800075ac:	32 5c       	mov	r12,37
800075ae:	17 8a       	ld.ub	r10,r11[0x0]
800075b0:	f8 0a 18 00 	cp.b	r10,r12
800075b4:	5f 1e       	srne	lr
800075b6:	f0 0a 18 00 	cp.b	r10,r8
800075ba:	5f 1c       	srne	r12
800075bc:	fd ec 00 0c 	and	r12,lr,r12
800075c0:	f0 0c 18 00 	cp.b	r12,r8
800075c4:	cf 31       	brne	800075aa <get_arg+0x26>
800075c6:	58 0a       	cp.w	r10,0
800075c8:	e0 80 01 2b 	breq	8000781e <get_arg+0x29a>
800075cc:	30 0c       	mov	r12,0
800075ce:	3f fa       	mov	r10,-1
800075d0:	18 90       	mov	r0,r12
800075d2:	50 3a       	stdsp	sp[0xc],r10
800075d4:	18 94       	mov	r4,r12
800075d6:	18 92       	mov	r2,r12
800075d8:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800075dc:	16 97       	mov	r7,r11
800075de:	50 7c       	stdsp	sp[0x1c],r12
800075e0:	4c ec       	lddpc	r12,80007718 <get_arg+0x194>
800075e2:	0f 3a       	ld.ub	r10,r7++
800075e4:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800075e8:	40 7c       	lddsp	r12,sp[0x1c]
800075ea:	1c 0c       	add	r12,lr
800075ec:	4c ce       	lddpc	lr,8000771c <get_arg+0x198>
800075ee:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800075f2:	20 1e       	sub	lr,1
800075f4:	50 0e       	stdsp	sp[0x0],lr
800075f6:	4c be       	lddpc	lr,80007720 <get_arg+0x19c>
800075f8:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800075fc:	50 7c       	stdsp	sp[0x1c],r12
800075fe:	40 0c       	lddsp	r12,sp[0x0]
80007600:	58 7c       	cp.w	r12,7
80007602:	e0 8b 00 fa 	brhi	800077f6 <get_arg+0x272>
80007606:	4c 8e       	lddpc	lr,80007724 <get_arg+0x1a0>
80007608:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000760c:	36 8b       	mov	r11,104
8000760e:	f6 0a 18 00 	cp.b	r10,r11
80007612:	e0 80 00 f2 	breq	800077f6 <get_arg+0x272>
80007616:	37 1b       	mov	r11,113
80007618:	f6 0a 18 00 	cp.b	r10,r11
8000761c:	c0 70       	breq	8000762a <get_arg+0xa6>
8000761e:	34 cb       	mov	r11,76
80007620:	f6 0a 18 00 	cp.b	r10,r11
80007624:	c0 51       	brne	8000762e <get_arg+0xaa>
80007626:	a3 b4       	sbr	r4,0x3
80007628:	ce 78       	rjmp	800077f6 <get_arg+0x272>
8000762a:	a5 b4       	sbr	r4,0x5
8000762c:	ce 58       	rjmp	800077f6 <get_arg+0x272>
8000762e:	08 9a       	mov	r10,r4
80007630:	0e 9b       	mov	r11,r7
80007632:	a5 aa       	sbr	r10,0x4
80007634:	17 3c       	ld.ub	r12,r11++
80007636:	a5 b4       	sbr	r4,0x5
80007638:	36 ce       	mov	lr,108
8000763a:	fc 0c 18 00 	cp.b	r12,lr
8000763e:	e0 80 00 dd 	breq	800077f8 <get_arg+0x274>
80007642:	14 94       	mov	r4,r10
80007644:	cd 98       	rjmp	800077f6 <get_arg+0x272>
80007646:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000764a:	36 7c       	mov	r12,103
8000764c:	f8 0a 18 00 	cp.b	r10,r12
80007650:	e0 8b 00 27 	brhi	8000769e <get_arg+0x11a>
80007654:	36 5b       	mov	r11,101
80007656:	f6 0a 18 00 	cp.b	r10,r11
8000765a:	c4 82       	brcc	800076ea <get_arg+0x166>
8000765c:	34 fb       	mov	r11,79
8000765e:	f6 0a 18 00 	cp.b	r10,r11
80007662:	c4 80       	breq	800076f2 <get_arg+0x16e>
80007664:	e0 8b 00 0c 	brhi	8000767c <get_arg+0xf8>
80007668:	34 5b       	mov	r11,69
8000766a:	f6 0a 18 00 	cp.b	r10,r11
8000766e:	c3 e0       	breq	800076ea <get_arg+0x166>
80007670:	34 7b       	mov	r11,71
80007672:	f6 0a 18 00 	cp.b	r10,r11
80007676:	c3 a0       	breq	800076ea <get_arg+0x166>
80007678:	34 4b       	mov	r11,68
8000767a:	c0 88       	rjmp	8000768a <get_arg+0x106>
8000767c:	35 8b       	mov	r11,88
8000767e:	f6 0a 18 00 	cp.b	r10,r11
80007682:	c2 c0       	breq	800076da <get_arg+0x156>
80007684:	e0 8b 00 07 	brhi	80007692 <get_arg+0x10e>
80007688:	35 5b       	mov	r11,85
8000768a:	f6 0a 18 00 	cp.b	r10,r11
8000768e:	c3 51       	brne	800076f8 <get_arg+0x174>
80007690:	c3 18       	rjmp	800076f2 <get_arg+0x16e>
80007692:	36 3b       	mov	r11,99
80007694:	f6 0a 18 00 	cp.b	r10,r11
80007698:	c2 f0       	breq	800076f6 <get_arg+0x172>
8000769a:	36 4b       	mov	r11,100
8000769c:	c0 e8       	rjmp	800076b8 <get_arg+0x134>
8000769e:	37 0b       	mov	r11,112
800076a0:	f6 0a 18 00 	cp.b	r10,r11
800076a4:	c2 50       	breq	800076ee <get_arg+0x16a>
800076a6:	e0 8b 00 0d 	brhi	800076c0 <get_arg+0x13c>
800076aa:	36 eb       	mov	r11,110
800076ac:	f6 0a 18 00 	cp.b	r10,r11
800076b0:	c1 f0       	breq	800076ee <get_arg+0x16a>
800076b2:	e0 8b 00 14 	brhi	800076da <get_arg+0x156>
800076b6:	36 9b       	mov	r11,105
800076b8:	f6 0a 18 00 	cp.b	r10,r11
800076bc:	c1 e1       	brne	800076f8 <get_arg+0x174>
800076be:	c0 e8       	rjmp	800076da <get_arg+0x156>
800076c0:	37 5b       	mov	r11,117
800076c2:	f6 0a 18 00 	cp.b	r10,r11
800076c6:	c0 a0       	breq	800076da <get_arg+0x156>
800076c8:	37 8b       	mov	r11,120
800076ca:	f6 0a 18 00 	cp.b	r10,r11
800076ce:	c0 60       	breq	800076da <get_arg+0x156>
800076d0:	37 3b       	mov	r11,115
800076d2:	f6 0a 18 00 	cp.b	r10,r11
800076d6:	c1 11       	brne	800076f8 <get_arg+0x174>
800076d8:	c0 b8       	rjmp	800076ee <get_arg+0x16a>
800076da:	ed b4 00 04 	bld	r4,0x4
800076de:	c0 a0       	breq	800076f2 <get_arg+0x16e>
800076e0:	ed b4 00 05 	bld	r4,0x5
800076e4:	c0 91       	brne	800076f6 <get_arg+0x172>
800076e6:	30 20       	mov	r0,2
800076e8:	c0 88       	rjmp	800076f8 <get_arg+0x174>
800076ea:	30 40       	mov	r0,4
800076ec:	c0 68       	rjmp	800076f8 <get_arg+0x174>
800076ee:	30 30       	mov	r0,3
800076f0:	c0 48       	rjmp	800076f8 <get_arg+0x174>
800076f2:	30 10       	mov	r0,1
800076f4:	c0 28       	rjmp	800076f8 <get_arg+0x174>
800076f6:	30 00       	mov	r0,0
800076f8:	40 3b       	lddsp	r11,sp[0xc]
800076fa:	5b fb       	cp.w	r11,-1
800076fc:	c0 40       	breq	80007704 <get_arg+0x180>
800076fe:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007702:	c7 a8       	rjmp	800077f6 <get_arg+0x272>
80007704:	58 60       	cp.w	r0,6
80007706:	e0 8b 00 78 	brhi	800077f6 <get_arg+0x272>
8000770a:	6c 0a       	ld.w	r10,r6[0x0]
8000770c:	ea cc ff ff 	sub	r12,r5,-1
80007710:	48 6e       	lddpc	lr,80007728 <get_arg+0x1a4>
80007712:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007716:	d7 03       	nop
80007718:	80 01       	ld.sh	r1,r0[0x0]
8000771a:	60 08       	ld.w	r8,r0[0x0]
8000771c:	80 01       	ld.sh	r1,r0[0x0]
8000771e:	5f 40       	srge	r0
80007720:	80 01       	ld.sh	r1,r0[0x0]
80007722:	5e d4       	retvc	r4
80007724:	80 01       	ld.sh	r1,r0[0x0]
80007726:	5d 34       	musfr	r4
80007728:	80 01       	ld.sh	r1,r0[0x0]
8000772a:	5d 54       	*unknown*
8000772c:	f4 cb ff f8 	sub	r11,r10,-8
80007730:	8d 0b       	st.w	r6[0x0],r11
80007732:	f4 ea 00 00 	ld.d	r10,r10[0]
80007736:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000773a:	c0 f8       	rjmp	80007758 <get_arg+0x1d4>
8000773c:	f4 cb ff fc 	sub	r11,r10,-4
80007740:	8d 0b       	st.w	r6[0x0],r11
80007742:	74 0a       	ld.w	r10,r10[0x0]
80007744:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007748:	c0 88       	rjmp	80007758 <get_arg+0x1d4>
8000774a:	f4 cb ff f8 	sub	r11,r10,-8
8000774e:	8d 0b       	st.w	r6[0x0],r11
80007750:	f4 ea 00 00 	ld.d	r10,r10[0]
80007754:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007758:	0e 9b       	mov	r11,r7
8000775a:	18 95       	mov	r5,r12
8000775c:	c4 e8       	rjmp	800077f8 <get_arg+0x274>
8000775e:	62 0a       	ld.w	r10,r1[0x0]
80007760:	5b fa       	cp.w	r10,-1
80007762:	c0 b1       	brne	80007778 <get_arg+0x1f4>
80007764:	50 19       	stdsp	sp[0x4],r9
80007766:	50 28       	stdsp	sp[0x8],r8
80007768:	e0 6a 00 80 	mov	r10,128
8000776c:	30 0b       	mov	r11,0
8000776e:	02 9c       	mov	r12,r1
80007770:	fe b0 fc ee 	rcall	8000714c <memset>
80007774:	40 28       	lddsp	r8,sp[0x8]
80007776:	40 19       	lddsp	r9,sp[0x4]
80007778:	e4 cc 00 01 	sub	r12,r2,1
8000777c:	0e 9b       	mov	r11,r7
8000777e:	50 3c       	stdsp	sp[0xc],r12
80007780:	f2 0c 0c 49 	max	r9,r9,r12
80007784:	c3 a8       	rjmp	800077f8 <get_arg+0x274>
80007786:	62 0a       	ld.w	r10,r1[0x0]
80007788:	5b fa       	cp.w	r10,-1
8000778a:	c0 b1       	brne	800077a0 <get_arg+0x21c>
8000778c:	50 19       	stdsp	sp[0x4],r9
8000778e:	50 28       	stdsp	sp[0x8],r8
80007790:	e0 6a 00 80 	mov	r10,128
80007794:	30 0b       	mov	r11,0
80007796:	02 9c       	mov	r12,r1
80007798:	fe b0 fc da 	rcall	8000714c <memset>
8000779c:	40 28       	lddsp	r8,sp[0x8]
8000779e:	40 19       	lddsp	r9,sp[0x4]
800077a0:	20 12       	sub	r2,1
800077a2:	30 0a       	mov	r10,0
800077a4:	0e 9b       	mov	r11,r7
800077a6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800077aa:	f2 02 0c 49 	max	r9,r9,r2
800077ae:	c2 58       	rjmp	800077f8 <get_arg+0x274>
800077b0:	16 97       	mov	r7,r11
800077b2:	6c 0a       	ld.w	r10,r6[0x0]
800077b4:	f4 cb ff fc 	sub	r11,r10,-4
800077b8:	8d 0b       	st.w	r6[0x0],r11
800077ba:	74 0a       	ld.w	r10,r10[0x0]
800077bc:	0e 9b       	mov	r11,r7
800077be:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800077c2:	2f f5       	sub	r5,-1
800077c4:	c1 a8       	rjmp	800077f8 <get_arg+0x274>
800077c6:	f4 c2 00 30 	sub	r2,r10,48
800077ca:	c0 68       	rjmp	800077d6 <get_arg+0x252>
800077cc:	e4 02 00 22 	add	r2,r2,r2<<0x2
800077d0:	2f f7       	sub	r7,-1
800077d2:	f4 02 00 12 	add	r2,r10,r2<<0x1
800077d6:	0f 8a       	ld.ub	r10,r7[0x0]
800077d8:	58 0a       	cp.w	r10,0
800077da:	c0 e0       	breq	800077f6 <get_arg+0x272>
800077dc:	23 0a       	sub	r10,48
800077de:	58 9a       	cp.w	r10,9
800077e0:	fe 98 ff f6 	brls	800077cc <get_arg+0x248>
800077e4:	c0 98       	rjmp	800077f6 <get_arg+0x272>
800077e6:	2f f7       	sub	r7,-1
800077e8:	0f 8a       	ld.ub	r10,r7[0x0]
800077ea:	58 0a       	cp.w	r10,0
800077ec:	c0 50       	breq	800077f6 <get_arg+0x272>
800077ee:	23 0a       	sub	r10,48
800077f0:	58 9a       	cp.w	r10,9
800077f2:	fe 98 ff fa 	brls	800077e6 <get_arg+0x262>
800077f6:	0e 9b       	mov	r11,r7
800077f8:	40 7c       	lddsp	r12,sp[0x1c]
800077fa:	30 ba       	mov	r10,11
800077fc:	f4 0c 18 00 	cp.b	r12,r10
80007800:	fe 91 fe ec 	brne	800075d8 <get_arg+0x54>
80007804:	40 42       	lddsp	r2,sp[0x10]
80007806:	17 8c       	ld.ub	r12,r11[0x0]
80007808:	0a 32       	cp.w	r2,r5
8000780a:	5f 4a       	srge	r10
8000780c:	f0 0c 18 00 	cp.b	r12,r8
80007810:	5f 1c       	srne	r12
80007812:	f9 ea 00 0a 	and	r10,r12,r10
80007816:	f0 0a 18 00 	cp.b	r10,r8
8000781a:	fe 91 fe c9 	brne	800075ac <get_arg+0x28>
8000781e:	30 08       	mov	r8,0
80007820:	40 4e       	lddsp	lr,sp[0x10]
80007822:	17 8a       	ld.ub	r10,r11[0x0]
80007824:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007828:	f0 0a 18 00 	cp.b	r10,r8
8000782c:	fc 09 17 10 	movne	r9,lr
80007830:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007834:	06 9e       	mov	lr,r3
80007836:	c2 a8       	rjmp	8000788a <get_arg+0x306>
80007838:	62 0a       	ld.w	r10,r1[0x0]
8000783a:	58 3a       	cp.w	r10,3
8000783c:	c1 e0       	breq	80007878 <get_arg+0x2f4>
8000783e:	e0 89 00 07 	brgt	8000784c <get_arg+0x2c8>
80007842:	58 1a       	cp.w	r10,1
80007844:	c1 a0       	breq	80007878 <get_arg+0x2f4>
80007846:	58 2a       	cp.w	r10,2
80007848:	c1 81       	brne	80007878 <get_arg+0x2f4>
8000784a:	c0 58       	rjmp	80007854 <get_arg+0x2d0>
8000784c:	58 5a       	cp.w	r10,5
8000784e:	c0 c0       	breq	80007866 <get_arg+0x2e2>
80007850:	c0 b5       	brlt	80007866 <get_arg+0x2e2>
80007852:	c1 38       	rjmp	80007878 <get_arg+0x2f4>
80007854:	6c 0a       	ld.w	r10,r6[0x0]
80007856:	f4 cc ff f8 	sub	r12,r10,-8
8000785a:	8d 0c       	st.w	r6[0x0],r12
8000785c:	f4 e2 00 00 	ld.d	r2,r10[0]
80007860:	f0 e3 00 00 	st.d	r8[0],r2
80007864:	c1 08       	rjmp	80007884 <get_arg+0x300>
80007866:	6c 0a       	ld.w	r10,r6[0x0]
80007868:	f4 cc ff f8 	sub	r12,r10,-8
8000786c:	8d 0c       	st.w	r6[0x0],r12
8000786e:	f4 e2 00 00 	ld.d	r2,r10[0]
80007872:	f0 e3 00 00 	st.d	r8[0],r2
80007876:	c0 78       	rjmp	80007884 <get_arg+0x300>
80007878:	6c 0a       	ld.w	r10,r6[0x0]
8000787a:	f4 cc ff fc 	sub	r12,r10,-4
8000787e:	8d 0c       	st.w	r6[0x0],r12
80007880:	74 0a       	ld.w	r10,r10[0x0]
80007882:	91 0a       	st.w	r8[0x0],r10
80007884:	2f f5       	sub	r5,-1
80007886:	2f 88       	sub	r8,-8
80007888:	2f c1       	sub	r1,-4
8000788a:	12 35       	cp.w	r5,r9
8000788c:	fe 9a ff d6 	brle	80007838 <get_arg+0x2b4>
80007890:	1c 93       	mov	r3,lr
80007892:	40 52       	lddsp	r2,sp[0x14]
80007894:	40 6e       	lddsp	lr,sp[0x18]
80007896:	85 05       	st.w	r2[0x0],r5
80007898:	9d 0b       	st.w	lr[0x0],r11
8000789a:	40 4b       	lddsp	r11,sp[0x10]
8000789c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
800078a0:	2f 8d       	sub	sp,-32
800078a2:	d8 32       	popm	r0-r7,pc

800078a4 <__sprint_r>:
800078a4:	d4 21       	pushm	r4-r7,lr
800078a6:	14 97       	mov	r7,r10
800078a8:	74 28       	ld.w	r8,r10[0x8]
800078aa:	58 08       	cp.w	r8,0
800078ac:	c0 41       	brne	800078b4 <__sprint_r+0x10>
800078ae:	95 18       	st.w	r10[0x4],r8
800078b0:	10 9c       	mov	r12,r8
800078b2:	d8 22       	popm	r4-r7,pc
800078b4:	e0 a0 18 ce 	rcall	8000aa50 <__sfvwrite_r>
800078b8:	30 08       	mov	r8,0
800078ba:	8f 18       	st.w	r7[0x4],r8
800078bc:	8f 28       	st.w	r7[0x8],r8
800078be:	d8 22       	popm	r4-r7,pc

800078c0 <_vfprintf_r>:
800078c0:	d4 31       	pushm	r0-r7,lr
800078c2:	fa cd 06 bc 	sub	sp,sp,1724
800078c6:	51 09       	stdsp	sp[0x40],r9
800078c8:	16 91       	mov	r1,r11
800078ca:	14 97       	mov	r7,r10
800078cc:	18 95       	mov	r5,r12
800078ce:	e0 a0 1a 31 	rcall	8000ad30 <_localeconv_r>
800078d2:	78 0c       	ld.w	r12,r12[0x0]
800078d4:	50 cc       	stdsp	sp[0x30],r12
800078d6:	58 05       	cp.w	r5,0
800078d8:	c0 70       	breq	800078e6 <_vfprintf_r+0x26>
800078da:	6a 68       	ld.w	r8,r5[0x18]
800078dc:	58 08       	cp.w	r8,0
800078de:	c0 41       	brne	800078e6 <_vfprintf_r+0x26>
800078e0:	0a 9c       	mov	r12,r5
800078e2:	e0 a0 17 57 	rcall	8000a790 <__sinit>
800078e6:	4d 08       	lddpc	r8,80007a24 <_vfprintf_r+0x164>
800078e8:	10 31       	cp.w	r1,r8
800078ea:	c0 31       	brne	800078f0 <_vfprintf_r+0x30>
800078ec:	6a 01       	ld.w	r1,r5[0x0]
800078ee:	c0 a8       	rjmp	80007902 <_vfprintf_r+0x42>
800078f0:	4c e8       	lddpc	r8,80007a28 <_vfprintf_r+0x168>
800078f2:	10 31       	cp.w	r1,r8
800078f4:	c0 31       	brne	800078fa <_vfprintf_r+0x3a>
800078f6:	6a 11       	ld.w	r1,r5[0x4]
800078f8:	c0 58       	rjmp	80007902 <_vfprintf_r+0x42>
800078fa:	4c d8       	lddpc	r8,80007a2c <_vfprintf_r+0x16c>
800078fc:	10 31       	cp.w	r1,r8
800078fe:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007902:	82 68       	ld.sh	r8,r1[0xc]
80007904:	ed b8 00 03 	bld	r8,0x3
80007908:	c0 41       	brne	80007910 <_vfprintf_r+0x50>
8000790a:	62 48       	ld.w	r8,r1[0x10]
8000790c:	58 08       	cp.w	r8,0
8000790e:	c0 71       	brne	8000791c <_vfprintf_r+0x5c>
80007910:	02 9b       	mov	r11,r1
80007912:	0a 9c       	mov	r12,r5
80007914:	e0 a0 0f 6c 	rcall	800097ec <__swsetup_r>
80007918:	e0 81 0f 63 	brne	800097de <_vfprintf_r+0x1f1e>
8000791c:	82 68       	ld.sh	r8,r1[0xc]
8000791e:	10 99       	mov	r9,r8
80007920:	e2 19 00 1a 	andl	r9,0x1a,COH
80007924:	58 a9       	cp.w	r9,10
80007926:	c3 c1       	brne	8000799e <_vfprintf_r+0xde>
80007928:	82 79       	ld.sh	r9,r1[0xe]
8000792a:	30 0a       	mov	r10,0
8000792c:	f4 09 19 00 	cp.h	r9,r10
80007930:	c3 75       	brlt	8000799e <_vfprintf_r+0xde>
80007932:	a1 d8       	cbr	r8,0x1
80007934:	fb 58 05 d0 	st.h	sp[1488],r8
80007938:	62 88       	ld.w	r8,r1[0x20]
8000793a:	fb 48 05 e4 	st.w	sp[1508],r8
8000793e:	62 a8       	ld.w	r8,r1[0x28]
80007940:	fb 48 05 ec 	st.w	sp[1516],r8
80007944:	fa c8 ff bc 	sub	r8,sp,-68
80007948:	fb 48 05 d4 	st.w	sp[1492],r8
8000794c:	fb 48 05 c4 	st.w	sp[1476],r8
80007950:	e0 68 04 00 	mov	r8,1024
80007954:	fb 48 05 d8 	st.w	sp[1496],r8
80007958:	fb 48 05 cc 	st.w	sp[1484],r8
8000795c:	30 08       	mov	r8,0
8000795e:	fb 59 05 d2 	st.h	sp[1490],r9
80007962:	0e 9a       	mov	r10,r7
80007964:	41 09       	lddsp	r9,sp[0x40]
80007966:	fa c7 fa 3c 	sub	r7,sp,-1476
8000796a:	fb 48 05 dc 	st.w	sp[1500],r8
8000796e:	0a 9c       	mov	r12,r5
80007970:	0e 9b       	mov	r11,r7
80007972:	ca 7f       	rcall	800078c0 <_vfprintf_r>
80007974:	50 bc       	stdsp	sp[0x2c],r12
80007976:	c0 95       	brlt	80007988 <_vfprintf_r+0xc8>
80007978:	0e 9b       	mov	r11,r7
8000797a:	0a 9c       	mov	r12,r5
8000797c:	e0 a0 16 2e 	rcall	8000a5d8 <_fflush_r>
80007980:	40 be       	lddsp	lr,sp[0x2c]
80007982:	f9 be 01 ff 	movne	lr,-1
80007986:	50 be       	stdsp	sp[0x2c],lr
80007988:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000798c:	ed b8 00 06 	bld	r8,0x6
80007990:	e0 81 0f 29 	brne	800097e2 <_vfprintf_r+0x1f22>
80007994:	82 68       	ld.sh	r8,r1[0xc]
80007996:	a7 a8       	sbr	r8,0x6
80007998:	a2 68       	st.h	r1[0xc],r8
8000799a:	e0 8f 0f 24 	bral	800097e2 <_vfprintf_r+0x1f22>
8000799e:	30 08       	mov	r8,0
800079a0:	fb 48 06 b4 	st.w	sp[1716],r8
800079a4:	fb 48 06 90 	st.w	sp[1680],r8
800079a8:	fb 48 06 8c 	st.w	sp[1676],r8
800079ac:	fb 48 06 b0 	st.w	sp[1712],r8
800079b0:	30 08       	mov	r8,0
800079b2:	30 09       	mov	r9,0
800079b4:	50 a7       	stdsp	sp[0x28],r7
800079b6:	50 78       	stdsp	sp[0x1c],r8
800079b8:	fa c3 f9 e0 	sub	r3,sp,-1568
800079bc:	3f f8       	mov	r8,-1
800079be:	50 59       	stdsp	sp[0x14],r9
800079c0:	fb 43 06 88 	st.w	sp[1672],r3
800079c4:	fb 48 05 44 	st.w	sp[1348],r8
800079c8:	12 9c       	mov	r12,r9
800079ca:	50 69       	stdsp	sp[0x18],r9
800079cc:	50 d9       	stdsp	sp[0x34],r9
800079ce:	50 e9       	stdsp	sp[0x38],r9
800079d0:	50 b9       	stdsp	sp[0x2c],r9
800079d2:	12 97       	mov	r7,r9
800079d4:	0a 94       	mov	r4,r5
800079d6:	40 a2       	lddsp	r2,sp[0x28]
800079d8:	32 5a       	mov	r10,37
800079da:	30 08       	mov	r8,0
800079dc:	c0 28       	rjmp	800079e0 <_vfprintf_r+0x120>
800079de:	2f f2       	sub	r2,-1
800079e0:	05 89       	ld.ub	r9,r2[0x0]
800079e2:	f0 09 18 00 	cp.b	r9,r8
800079e6:	5f 1b       	srne	r11
800079e8:	f4 09 18 00 	cp.b	r9,r10
800079ec:	5f 19       	srne	r9
800079ee:	f3 eb 00 0b 	and	r11,r9,r11
800079f2:	f0 0b 18 00 	cp.b	r11,r8
800079f6:	cf 41       	brne	800079de <_vfprintf_r+0x11e>
800079f8:	40 ab       	lddsp	r11,sp[0x28]
800079fa:	e4 0b 01 06 	sub	r6,r2,r11
800079fe:	c2 50       	breq	80007a48 <_vfprintf_r+0x188>
80007a00:	fa f8 06 90 	ld.w	r8,sp[1680]
80007a04:	0c 08       	add	r8,r6
80007a06:	87 0b       	st.w	r3[0x0],r11
80007a08:	fb 48 06 90 	st.w	sp[1680],r8
80007a0c:	87 16       	st.w	r3[0x4],r6
80007a0e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80007a12:	2f f8       	sub	r8,-1
80007a14:	fb 48 06 8c 	st.w	sp[1676],r8
80007a18:	58 78       	cp.w	r8,7
80007a1a:	e0 89 00 0b 	brgt	80007a30 <_vfprintf_r+0x170>
80007a1e:	2f 83       	sub	r3,-8
80007a20:	c1 18       	rjmp	80007a42 <_vfprintf_r+0x182>
80007a22:	d7 03       	nop
80007a24:	80 01       	ld.sh	r1,r0[0x0]
80007a26:	61 18       	ld.w	r8,r0[0x44]
80007a28:	80 01       	ld.sh	r1,r0[0x0]
80007a2a:	61 38       	ld.w	r8,r0[0x4c]
80007a2c:	80 01       	ld.sh	r1,r0[0x0]
80007a2e:	61 58       	ld.w	r8,r0[0x54]
80007a30:	fa ca f9 78 	sub	r10,sp,-1672
80007a34:	02 9b       	mov	r11,r1
80007a36:	08 9c       	mov	r12,r4
80007a38:	c3 6f       	rcall	800078a4 <__sprint_r>
80007a3a:	e0 81 0e ce 	brne	800097d6 <_vfprintf_r+0x1f16>
80007a3e:	fa c3 f9 e0 	sub	r3,sp,-1568
80007a42:	40 ba       	lddsp	r10,sp[0x2c]
80007a44:	0c 0a       	add	r10,r6
80007a46:	50 ba       	stdsp	sp[0x2c],r10
80007a48:	05 89       	ld.ub	r9,r2[0x0]
80007a4a:	30 08       	mov	r8,0
80007a4c:	f0 09 18 00 	cp.b	r9,r8
80007a50:	e0 80 0e b2 	breq	800097b4 <_vfprintf_r+0x1ef4>
80007a54:	30 09       	mov	r9,0
80007a56:	fb 68 06 bb 	st.b	sp[1723],r8
80007a5a:	0e 96       	mov	r6,r7
80007a5c:	e4 c8 ff ff 	sub	r8,r2,-1
80007a60:	3f fe       	mov	lr,-1
80007a62:	50 93       	stdsp	sp[0x24],r3
80007a64:	50 41       	stdsp	sp[0x10],r1
80007a66:	0e 93       	mov	r3,r7
80007a68:	04 91       	mov	r1,r2
80007a6a:	50 89       	stdsp	sp[0x20],r9
80007a6c:	50 a8       	stdsp	sp[0x28],r8
80007a6e:	50 2e       	stdsp	sp[0x8],lr
80007a70:	50 39       	stdsp	sp[0xc],r9
80007a72:	12 95       	mov	r5,r9
80007a74:	12 90       	mov	r0,r9
80007a76:	10 97       	mov	r7,r8
80007a78:	08 92       	mov	r2,r4
80007a7a:	c0 78       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007a7c:	3f fc       	mov	r12,-1
80007a7e:	08 97       	mov	r7,r4
80007a80:	50 2c       	stdsp	sp[0x8],r12
80007a82:	c0 38       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007a84:	30 0b       	mov	r11,0
80007a86:	50 3b       	stdsp	sp[0xc],r11
80007a88:	0f 38       	ld.ub	r8,r7++
80007a8a:	c0 28       	rjmp	80007a8e <_vfprintf_r+0x1ce>
80007a8c:	12 90       	mov	r0,r9
80007a8e:	f0 c9 00 20 	sub	r9,r8,32
80007a92:	e0 49 00 58 	cp.w	r9,88
80007a96:	e0 8b 0a 36 	brhi	80008f02 <_vfprintf_r+0x1642>
80007a9a:	4d 9a       	lddpc	r10,80007bfc <_vfprintf_r+0x33c>
80007a9c:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80007aa0:	50 a7       	stdsp	sp[0x28],r7
80007aa2:	50 80       	stdsp	sp[0x20],r0
80007aa4:	0c 97       	mov	r7,r6
80007aa6:	04 94       	mov	r4,r2
80007aa8:	06 96       	mov	r6,r3
80007aaa:	02 92       	mov	r2,r1
80007aac:	4d 59       	lddpc	r9,80007c00 <_vfprintf_r+0x340>
80007aae:	40 93       	lddsp	r3,sp[0x24]
80007ab0:	10 90       	mov	r0,r8
80007ab2:	40 41       	lddsp	r1,sp[0x10]
80007ab4:	50 d9       	stdsp	sp[0x34],r9
80007ab6:	e0 8f 08 95 	bral	80008be0 <_vfprintf_r+0x1320>
80007aba:	30 08       	mov	r8,0
80007abc:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80007ac0:	f0 09 18 00 	cp.b	r9,r8
80007ac4:	ce 21       	brne	80007a88 <_vfprintf_r+0x1c8>
80007ac6:	32 08       	mov	r8,32
80007ac8:	c6 e8       	rjmp	80007ba4 <_vfprintf_r+0x2e4>
80007aca:	a1 a5       	sbr	r5,0x0
80007acc:	cd eb       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007ace:	0f 89       	ld.ub	r9,r7[0x0]
80007ad0:	f2 c8 00 30 	sub	r8,r9,48
80007ad4:	58 98       	cp.w	r8,9
80007ad6:	e0 8b 00 1d 	brhi	80007b10 <_vfprintf_r+0x250>
80007ada:	ee c8 ff ff 	sub	r8,r7,-1
80007ade:	30 0b       	mov	r11,0
80007ae0:	23 09       	sub	r9,48
80007ae2:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007ae6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80007aea:	11 39       	ld.ub	r9,r8++
80007aec:	f2 ca 00 30 	sub	r10,r9,48
80007af0:	58 9a       	cp.w	r10,9
80007af2:	fe 98 ff f7 	brls	80007ae0 <_vfprintf_r+0x220>
80007af6:	e0 49 00 24 	cp.w	r9,36
80007afa:	cc 51       	brne	80007a84 <_vfprintf_r+0x1c4>
80007afc:	e0 4b 00 20 	cp.w	r11,32
80007b00:	e0 89 0e 6a 	brgt	800097d4 <_vfprintf_r+0x1f14>
80007b04:	20 1b       	sub	r11,1
80007b06:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007b0a:	12 3b       	cp.w	r11,r9
80007b0c:	c0 95       	brlt	80007b1e <_vfprintf_r+0x25e>
80007b0e:	c1 08       	rjmp	80007b2e <_vfprintf_r+0x26e>
80007b10:	fa f9 06 b4 	ld.w	r9,sp[1716]
80007b14:	ec ca ff ff 	sub	r10,r6,-1
80007b18:	12 36       	cp.w	r6,r9
80007b1a:	c1 f5       	brlt	80007b58 <_vfprintf_r+0x298>
80007b1c:	c2 68       	rjmp	80007b68 <_vfprintf_r+0x2a8>
80007b1e:	fa ce f9 44 	sub	lr,sp,-1724
80007b22:	10 97       	mov	r7,r8
80007b24:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007b28:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007b2c:	c3 58       	rjmp	80007b96 <_vfprintf_r+0x2d6>
80007b2e:	10 97       	mov	r7,r8
80007b30:	fa c8 f9 50 	sub	r8,sp,-1712
80007b34:	1a d8       	st.w	--sp,r8
80007b36:	fa c8 fa b8 	sub	r8,sp,-1352
80007b3a:	1a d8       	st.w	--sp,r8
80007b3c:	fa c8 fb b4 	sub	r8,sp,-1100
80007b40:	02 9a       	mov	r10,r1
80007b42:	1a d8       	st.w	--sp,r8
80007b44:	04 9c       	mov	r12,r2
80007b46:	fa c8 f9 40 	sub	r8,sp,-1728
80007b4a:	fa c9 ff b4 	sub	r9,sp,-76
80007b4e:	fe b0 fd 1b 	rcall	80007584 <get_arg>
80007b52:	2f dd       	sub	sp,-12
80007b54:	78 00       	ld.w	r0,r12[0x0]
80007b56:	c2 08       	rjmp	80007b96 <_vfprintf_r+0x2d6>
80007b58:	fa cc f9 44 	sub	r12,sp,-1724
80007b5c:	14 96       	mov	r6,r10
80007b5e:	f8 03 00 38 	add	r8,r12,r3<<0x3
80007b62:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007b66:	c1 88       	rjmp	80007b96 <_vfprintf_r+0x2d6>
80007b68:	41 08       	lddsp	r8,sp[0x40]
80007b6a:	59 f9       	cp.w	r9,31
80007b6c:	e0 89 00 11 	brgt	80007b8e <_vfprintf_r+0x2ce>
80007b70:	f0 cb ff fc 	sub	r11,r8,-4
80007b74:	51 0b       	stdsp	sp[0x40],r11
80007b76:	70 00       	ld.w	r0,r8[0x0]
80007b78:	fa cb f9 44 	sub	r11,sp,-1724
80007b7c:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007b80:	f1 40 fd 88 	st.w	r8[-632],r0
80007b84:	2f f9       	sub	r9,-1
80007b86:	14 96       	mov	r6,r10
80007b88:	fb 49 06 b4 	st.w	sp[1716],r9
80007b8c:	c0 58       	rjmp	80007b96 <_vfprintf_r+0x2d6>
80007b8e:	70 00       	ld.w	r0,r8[0x0]
80007b90:	14 96       	mov	r6,r10
80007b92:	2f c8       	sub	r8,-4
80007b94:	51 08       	stdsp	sp[0x40],r8
80007b96:	58 00       	cp.w	r0,0
80007b98:	fe 94 ff 78 	brge	80007a88 <_vfprintf_r+0x1c8>
80007b9c:	5c 30       	neg	r0
80007b9e:	a3 a5       	sbr	r5,0x2
80007ba0:	c7 4b       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007ba2:	32 b8       	mov	r8,43
80007ba4:	fb 68 06 bb 	st.b	sp[1723],r8
80007ba8:	c7 0b       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007baa:	0f 38       	ld.ub	r8,r7++
80007bac:	e0 48 00 2a 	cp.w	r8,42
80007bb0:	c0 30       	breq	80007bb6 <_vfprintf_r+0x2f6>
80007bb2:	30 09       	mov	r9,0
80007bb4:	c7 d8       	rjmp	80007cae <_vfprintf_r+0x3ee>
80007bb6:	0f 88       	ld.ub	r8,r7[0x0]
80007bb8:	f0 c9 00 30 	sub	r9,r8,48
80007bbc:	58 99       	cp.w	r9,9
80007bbe:	e0 8b 00 23 	brhi	80007c04 <_vfprintf_r+0x344>
80007bc2:	ee c4 ff ff 	sub	r4,r7,-1
80007bc6:	30 0b       	mov	r11,0
80007bc8:	23 08       	sub	r8,48
80007bca:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007bce:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007bd2:	09 38       	ld.ub	r8,r4++
80007bd4:	f0 c9 00 30 	sub	r9,r8,48
80007bd8:	58 99       	cp.w	r9,9
80007bda:	fe 98 ff f7 	brls	80007bc8 <_vfprintf_r+0x308>
80007bde:	e0 48 00 24 	cp.w	r8,36
80007be2:	fe 91 ff 51 	brne	80007a84 <_vfprintf_r+0x1c4>
80007be6:	e0 4b 00 20 	cp.w	r11,32
80007bea:	e0 89 0d f5 	brgt	800097d4 <_vfprintf_r+0x1f14>
80007bee:	20 1b       	sub	r11,1
80007bf0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bf4:	10 3b       	cp.w	r11,r8
80007bf6:	c0 e5       	brlt	80007c12 <_vfprintf_r+0x352>
80007bf8:	c1 58       	rjmp	80007c22 <_vfprintf_r+0x362>
80007bfa:	d7 03       	nop
80007bfc:	80 01       	ld.sh	r1,r0[0x0]
80007bfe:	5d 70       	*unknown*
80007c00:	80 01       	ld.sh	r1,r0[0x0]
80007c02:	5f ac       	srle	r12
80007c04:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007c08:	ec c9 ff ff 	sub	r9,r6,-1
80007c0c:	14 36       	cp.w	r6,r10
80007c0e:	c1 f5       	brlt	80007c4c <_vfprintf_r+0x38c>
80007c10:	c2 88       	rjmp	80007c60 <_vfprintf_r+0x3a0>
80007c12:	fa ca f9 44 	sub	r10,sp,-1724
80007c16:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80007c1a:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007c1e:	50 2b       	stdsp	sp[0x8],r11
80007c20:	c3 c8       	rjmp	80007c98 <_vfprintf_r+0x3d8>
80007c22:	fa c8 f9 50 	sub	r8,sp,-1712
80007c26:	1a d8       	st.w	--sp,r8
80007c28:	fa c8 fa b8 	sub	r8,sp,-1352
80007c2c:	1a d8       	st.w	--sp,r8
80007c2e:	fa c8 fb b4 	sub	r8,sp,-1100
80007c32:	02 9a       	mov	r10,r1
80007c34:	1a d8       	st.w	--sp,r8
80007c36:	04 9c       	mov	r12,r2
80007c38:	fa c8 f9 40 	sub	r8,sp,-1728
80007c3c:	fa c9 ff b4 	sub	r9,sp,-76
80007c40:	fe b0 fc a2 	rcall	80007584 <get_arg>
80007c44:	2f dd       	sub	sp,-12
80007c46:	78 0c       	ld.w	r12,r12[0x0]
80007c48:	50 2c       	stdsp	sp[0x8],r12
80007c4a:	c2 78       	rjmp	80007c98 <_vfprintf_r+0x3d8>
80007c4c:	12 96       	mov	r6,r9
80007c4e:	0e 94       	mov	r4,r7
80007c50:	fa c9 f9 44 	sub	r9,sp,-1724
80007c54:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007c58:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007c5c:	50 28       	stdsp	sp[0x8],r8
80007c5e:	c1 d8       	rjmp	80007c98 <_vfprintf_r+0x3d8>
80007c60:	41 08       	lddsp	r8,sp[0x40]
80007c62:	59 fa       	cp.w	r10,31
80007c64:	e0 89 00 14 	brgt	80007c8c <_vfprintf_r+0x3cc>
80007c68:	f0 cb ff fc 	sub	r11,r8,-4
80007c6c:	70 08       	ld.w	r8,r8[0x0]
80007c6e:	51 0b       	stdsp	sp[0x40],r11
80007c70:	50 28       	stdsp	sp[0x8],r8
80007c72:	fa c6 f9 44 	sub	r6,sp,-1724
80007c76:	40 2e       	lddsp	lr,sp[0x8]
80007c78:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007c7c:	f1 4e fd 88 	st.w	r8[-632],lr
80007c80:	2f fa       	sub	r10,-1
80007c82:	0e 94       	mov	r4,r7
80007c84:	fb 4a 06 b4 	st.w	sp[1716],r10
80007c88:	12 96       	mov	r6,r9
80007c8a:	c0 78       	rjmp	80007c98 <_vfprintf_r+0x3d8>
80007c8c:	70 0c       	ld.w	r12,r8[0x0]
80007c8e:	0e 94       	mov	r4,r7
80007c90:	2f c8       	sub	r8,-4
80007c92:	50 2c       	stdsp	sp[0x8],r12
80007c94:	12 96       	mov	r6,r9
80007c96:	51 08       	stdsp	sp[0x40],r8
80007c98:	40 2b       	lddsp	r11,sp[0x8]
80007c9a:	58 0b       	cp.w	r11,0
80007c9c:	fe 95 fe f0 	brlt	80007a7c <_vfprintf_r+0x1bc>
80007ca0:	08 97       	mov	r7,r4
80007ca2:	cf 3a       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007ca4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007ca8:	0f 38       	ld.ub	r8,r7++
80007caa:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007cae:	f0 ca 00 30 	sub	r10,r8,48
80007cb2:	58 9a       	cp.w	r10,9
80007cb4:	fe 98 ff f8 	brls	80007ca4 <_vfprintf_r+0x3e4>
80007cb8:	3f fa       	mov	r10,-1
80007cba:	f2 0a 0c 49 	max	r9,r9,r10
80007cbe:	50 29       	stdsp	sp[0x8],r9
80007cc0:	ce 7a       	rjmp	80007a8e <_vfprintf_r+0x1ce>
80007cc2:	a7 b5       	sbr	r5,0x7
80007cc4:	ce 2a       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007cc6:	30 09       	mov	r9,0
80007cc8:	23 08       	sub	r8,48
80007cca:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007cce:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007cd2:	0f 38       	ld.ub	r8,r7++
80007cd4:	f0 ca 00 30 	sub	r10,r8,48
80007cd8:	58 9a       	cp.w	r10,9
80007cda:	fe 98 ff f7 	brls	80007cc8 <_vfprintf_r+0x408>
80007cde:	e0 48 00 24 	cp.w	r8,36
80007ce2:	fe 91 fe d5 	brne	80007a8c <_vfprintf_r+0x1cc>
80007ce6:	e0 49 00 20 	cp.w	r9,32
80007cea:	e0 89 0d 75 	brgt	800097d4 <_vfprintf_r+0x1f14>
80007cee:	f2 c3 00 01 	sub	r3,r9,1
80007cf2:	30 19       	mov	r9,1
80007cf4:	50 39       	stdsp	sp[0xc],r9
80007cf6:	cc 9a       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007cf8:	a3 b5       	sbr	r5,0x3
80007cfa:	cc 7a       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007cfc:	a7 a5       	sbr	r5,0x6
80007cfe:	cc 5a       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007d00:	0a 98       	mov	r8,r5
80007d02:	a5 b5       	sbr	r5,0x5
80007d04:	a5 a8       	sbr	r8,0x4
80007d06:	0f 89       	ld.ub	r9,r7[0x0]
80007d08:	36 ce       	mov	lr,108
80007d0a:	fc 09 18 00 	cp.b	r9,lr
80007d0e:	f7 b7 00 ff 	subeq	r7,-1
80007d12:	f0 05 17 10 	movne	r5,r8
80007d16:	cb 9a       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007d18:	a5 b5       	sbr	r5,0x5
80007d1a:	cb 7a       	rjmp	80007a88 <_vfprintf_r+0x1c8>
80007d1c:	50 a7       	stdsp	sp[0x28],r7
80007d1e:	50 80       	stdsp	sp[0x20],r0
80007d20:	0c 97       	mov	r7,r6
80007d22:	10 90       	mov	r0,r8
80007d24:	06 96       	mov	r6,r3
80007d26:	04 94       	mov	r4,r2
80007d28:	40 93       	lddsp	r3,sp[0x24]
80007d2a:	02 92       	mov	r2,r1
80007d2c:	0e 99       	mov	r9,r7
80007d2e:	40 41       	lddsp	r1,sp[0x10]
80007d30:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d34:	40 3c       	lddsp	r12,sp[0xc]
80007d36:	58 0c       	cp.w	r12,0
80007d38:	c1 d0       	breq	80007d72 <_vfprintf_r+0x4b2>
80007d3a:	10 36       	cp.w	r6,r8
80007d3c:	c0 64       	brge	80007d48 <_vfprintf_r+0x488>
80007d3e:	fa cb f9 44 	sub	r11,sp,-1724
80007d42:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d46:	c1 d8       	rjmp	80007d80 <_vfprintf_r+0x4c0>
80007d48:	fa c8 f9 50 	sub	r8,sp,-1712
80007d4c:	1a d8       	st.w	--sp,r8
80007d4e:	fa c8 fa b8 	sub	r8,sp,-1352
80007d52:	1a d8       	st.w	--sp,r8
80007d54:	fa c8 fb b4 	sub	r8,sp,-1100
80007d58:	1a d8       	st.w	--sp,r8
80007d5a:	fa c8 f9 40 	sub	r8,sp,-1728
80007d5e:	fa c9 ff b4 	sub	r9,sp,-76
80007d62:	04 9a       	mov	r10,r2
80007d64:	0c 9b       	mov	r11,r6
80007d66:	08 9c       	mov	r12,r4
80007d68:	fe b0 fc 0e 	rcall	80007584 <get_arg>
80007d6c:	2f dd       	sub	sp,-12
80007d6e:	19 b8       	ld.ub	r8,r12[0x3]
80007d70:	c2 28       	rjmp	80007db4 <_vfprintf_r+0x4f4>
80007d72:	2f f7       	sub	r7,-1
80007d74:	10 39       	cp.w	r9,r8
80007d76:	c0 84       	brge	80007d86 <_vfprintf_r+0x4c6>
80007d78:	fa ca f9 44 	sub	r10,sp,-1724
80007d7c:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007d80:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007d84:	c1 88       	rjmp	80007db4 <_vfprintf_r+0x4f4>
80007d86:	41 09       	lddsp	r9,sp[0x40]
80007d88:	59 f8       	cp.w	r8,31
80007d8a:	e0 89 00 12 	brgt	80007dae <_vfprintf_r+0x4ee>
80007d8e:	f2 ca ff fc 	sub	r10,r9,-4
80007d92:	51 0a       	stdsp	sp[0x40],r10
80007d94:	72 09       	ld.w	r9,r9[0x0]
80007d96:	fa c6 f9 44 	sub	r6,sp,-1724
80007d9a:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007d9e:	2f f8       	sub	r8,-1
80007da0:	f5 49 fd 88 	st.w	r10[-632],r9
80007da4:	fb 48 06 b4 	st.w	sp[1716],r8
80007da8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007dac:	c0 48       	rjmp	80007db4 <_vfprintf_r+0x4f4>
80007dae:	13 b8       	ld.ub	r8,r9[0x3]
80007db0:	2f c9       	sub	r9,-4
80007db2:	51 09       	stdsp	sp[0x40],r9
80007db4:	fb 68 06 60 	st.b	sp[1632],r8
80007db8:	30 0e       	mov	lr,0
80007dba:	30 08       	mov	r8,0
80007dbc:	30 12       	mov	r2,1
80007dbe:	fb 68 06 bb 	st.b	sp[1723],r8
80007dc2:	50 2e       	stdsp	sp[0x8],lr
80007dc4:	e0 8f 08 b1 	bral	80008f26 <_vfprintf_r+0x1666>
80007dc8:	50 a7       	stdsp	sp[0x28],r7
80007dca:	50 80       	stdsp	sp[0x20],r0
80007dcc:	0c 97       	mov	r7,r6
80007dce:	04 94       	mov	r4,r2
80007dd0:	06 96       	mov	r6,r3
80007dd2:	02 92       	mov	r2,r1
80007dd4:	40 93       	lddsp	r3,sp[0x24]
80007dd6:	10 90       	mov	r0,r8
80007dd8:	40 41       	lddsp	r1,sp[0x10]
80007dda:	a5 a5       	sbr	r5,0x4
80007ddc:	c0 a8       	rjmp	80007df0 <_vfprintf_r+0x530>
80007dde:	50 a7       	stdsp	sp[0x28],r7
80007de0:	50 80       	stdsp	sp[0x20],r0
80007de2:	0c 97       	mov	r7,r6
80007de4:	04 94       	mov	r4,r2
80007de6:	06 96       	mov	r6,r3
80007de8:	02 92       	mov	r2,r1
80007dea:	40 93       	lddsp	r3,sp[0x24]
80007dec:	10 90       	mov	r0,r8
80007dee:	40 41       	lddsp	r1,sp[0x10]
80007df0:	ed b5 00 05 	bld	r5,0x5
80007df4:	c5 11       	brne	80007e96 <_vfprintf_r+0x5d6>
80007df6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007dfa:	40 3c       	lddsp	r12,sp[0xc]
80007dfc:	58 0c       	cp.w	r12,0
80007dfe:	c1 e0       	breq	80007e3a <_vfprintf_r+0x57a>
80007e00:	10 36       	cp.w	r6,r8
80007e02:	c0 64       	brge	80007e0e <_vfprintf_r+0x54e>
80007e04:	fa cb f9 44 	sub	r11,sp,-1724
80007e08:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007e0c:	c2 08       	rjmp	80007e4c <_vfprintf_r+0x58c>
80007e0e:	fa c8 f9 50 	sub	r8,sp,-1712
80007e12:	1a d8       	st.w	--sp,r8
80007e14:	fa c8 fa b8 	sub	r8,sp,-1352
80007e18:	0c 9b       	mov	r11,r6
80007e1a:	1a d8       	st.w	--sp,r8
80007e1c:	fa c8 fb b4 	sub	r8,sp,-1100
80007e20:	1a d8       	st.w	--sp,r8
80007e22:	fa c9 ff b4 	sub	r9,sp,-76
80007e26:	fa c8 f9 40 	sub	r8,sp,-1728
80007e2a:	04 9a       	mov	r10,r2
80007e2c:	08 9c       	mov	r12,r4
80007e2e:	fe b0 fb ab 	rcall	80007584 <get_arg>
80007e32:	2f dd       	sub	sp,-12
80007e34:	78 1b       	ld.w	r11,r12[0x4]
80007e36:	78 09       	ld.w	r9,r12[0x0]
80007e38:	c2 b8       	rjmp	80007e8e <_vfprintf_r+0x5ce>
80007e3a:	ee ca ff ff 	sub	r10,r7,-1
80007e3e:	10 37       	cp.w	r7,r8
80007e40:	c0 b4       	brge	80007e56 <_vfprintf_r+0x596>
80007e42:	fa c9 f9 44 	sub	r9,sp,-1724
80007e46:	14 97       	mov	r7,r10
80007e48:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007e4c:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007e50:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007e54:	c1 d8       	rjmp	80007e8e <_vfprintf_r+0x5ce>
80007e56:	41 09       	lddsp	r9,sp[0x40]
80007e58:	59 f8       	cp.w	r8,31
80007e5a:	e0 89 00 14 	brgt	80007e82 <_vfprintf_r+0x5c2>
80007e5e:	f2 cb ff f8 	sub	r11,r9,-8
80007e62:	51 0b       	stdsp	sp[0x40],r11
80007e64:	fa c6 f9 44 	sub	r6,sp,-1724
80007e68:	72 1b       	ld.w	r11,r9[0x4]
80007e6a:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007e6e:	72 09       	ld.w	r9,r9[0x0]
80007e70:	f9 4b fd 8c 	st.w	r12[-628],r11
80007e74:	f9 49 fd 88 	st.w	r12[-632],r9
80007e78:	2f f8       	sub	r8,-1
80007e7a:	14 97       	mov	r7,r10
80007e7c:	fb 48 06 b4 	st.w	sp[1716],r8
80007e80:	c0 78       	rjmp	80007e8e <_vfprintf_r+0x5ce>
80007e82:	f2 c8 ff f8 	sub	r8,r9,-8
80007e86:	72 1b       	ld.w	r11,r9[0x4]
80007e88:	14 97       	mov	r7,r10
80007e8a:	51 08       	stdsp	sp[0x40],r8
80007e8c:	72 09       	ld.w	r9,r9[0x0]
80007e8e:	16 98       	mov	r8,r11
80007e90:	fa e9 00 00 	st.d	sp[0],r8
80007e94:	ca e8       	rjmp	80007ff0 <_vfprintf_r+0x730>
80007e96:	ed b5 00 04 	bld	r5,0x4
80007e9a:	c1 71       	brne	80007ec8 <_vfprintf_r+0x608>
80007e9c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ea0:	40 3e       	lddsp	lr,sp[0xc]
80007ea2:	58 0e       	cp.w	lr,0
80007ea4:	c0 80       	breq	80007eb4 <_vfprintf_r+0x5f4>
80007ea6:	10 36       	cp.w	r6,r8
80007ea8:	c6 94       	brge	80007f7a <_vfprintf_r+0x6ba>
80007eaa:	fa cc f9 44 	sub	r12,sp,-1724
80007eae:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007eb2:	c8 28       	rjmp	80007fb6 <_vfprintf_r+0x6f6>
80007eb4:	ee ca ff ff 	sub	r10,r7,-1
80007eb8:	10 37       	cp.w	r7,r8
80007eba:	e0 84 00 81 	brge	80007fbc <_vfprintf_r+0x6fc>
80007ebe:	fa cb f9 44 	sub	r11,sp,-1724
80007ec2:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ec6:	c7 78       	rjmp	80007fb4 <_vfprintf_r+0x6f4>
80007ec8:	ed b5 00 06 	bld	r5,0x6
80007ecc:	c4 b1       	brne	80007f62 <_vfprintf_r+0x6a2>
80007ece:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ed2:	40 3c       	lddsp	r12,sp[0xc]
80007ed4:	58 0c       	cp.w	r12,0
80007ed6:	c1 d0       	breq	80007f10 <_vfprintf_r+0x650>
80007ed8:	10 36       	cp.w	r6,r8
80007eda:	c0 64       	brge	80007ee6 <_vfprintf_r+0x626>
80007edc:	fa cb f9 44 	sub	r11,sp,-1724
80007ee0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ee4:	c1 f8       	rjmp	80007f22 <_vfprintf_r+0x662>
80007ee6:	fa c8 f9 50 	sub	r8,sp,-1712
80007eea:	1a d8       	st.w	--sp,r8
80007eec:	fa c8 fa b8 	sub	r8,sp,-1352
80007ef0:	1a d8       	st.w	--sp,r8
80007ef2:	fa c8 fb b4 	sub	r8,sp,-1100
80007ef6:	1a d8       	st.w	--sp,r8
80007ef8:	fa c8 f9 40 	sub	r8,sp,-1728
80007efc:	fa c9 ff b4 	sub	r9,sp,-76
80007f00:	04 9a       	mov	r10,r2
80007f02:	0c 9b       	mov	r11,r6
80007f04:	08 9c       	mov	r12,r4
80007f06:	fe b0 fb 3f 	rcall	80007584 <get_arg>
80007f0a:	2f dd       	sub	sp,-12
80007f0c:	98 18       	ld.sh	r8,r12[0x2]
80007f0e:	c2 68       	rjmp	80007f5a <_vfprintf_r+0x69a>
80007f10:	ee ca ff ff 	sub	r10,r7,-1
80007f14:	10 37       	cp.w	r7,r8
80007f16:	c0 94       	brge	80007f28 <_vfprintf_r+0x668>
80007f18:	fa c9 f9 44 	sub	r9,sp,-1724
80007f1c:	14 97       	mov	r7,r10
80007f1e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f22:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007f26:	c1 a8       	rjmp	80007f5a <_vfprintf_r+0x69a>
80007f28:	41 09       	lddsp	r9,sp[0x40]
80007f2a:	59 f8       	cp.w	r8,31
80007f2c:	e0 89 00 13 	brgt	80007f52 <_vfprintf_r+0x692>
80007f30:	f2 cb ff fc 	sub	r11,r9,-4
80007f34:	51 0b       	stdsp	sp[0x40],r11
80007f36:	72 09       	ld.w	r9,r9[0x0]
80007f38:	fa c6 f9 44 	sub	r6,sp,-1724
80007f3c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007f40:	2f f8       	sub	r8,-1
80007f42:	f7 49 fd 88 	st.w	r11[-632],r9
80007f46:	fb 48 06 b4 	st.w	sp[1716],r8
80007f4a:	14 97       	mov	r7,r10
80007f4c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007f50:	c0 58       	rjmp	80007f5a <_vfprintf_r+0x69a>
80007f52:	92 18       	ld.sh	r8,r9[0x2]
80007f54:	14 97       	mov	r7,r10
80007f56:	2f c9       	sub	r9,-4
80007f58:	51 09       	stdsp	sp[0x40],r9
80007f5a:	50 18       	stdsp	sp[0x4],r8
80007f5c:	bf 58       	asr	r8,0x1f
80007f5e:	50 08       	stdsp	sp[0x0],r8
80007f60:	c4 88       	rjmp	80007ff0 <_vfprintf_r+0x730>
80007f62:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f66:	40 3c       	lddsp	r12,sp[0xc]
80007f68:	58 0c       	cp.w	r12,0
80007f6a:	c1 d0       	breq	80007fa4 <_vfprintf_r+0x6e4>
80007f6c:	10 36       	cp.w	r6,r8
80007f6e:	c0 64       	brge	80007f7a <_vfprintf_r+0x6ba>
80007f70:	fa cb f9 44 	sub	r11,sp,-1724
80007f74:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f78:	c1 f8       	rjmp	80007fb6 <_vfprintf_r+0x6f6>
80007f7a:	fa c8 f9 50 	sub	r8,sp,-1712
80007f7e:	1a d8       	st.w	--sp,r8
80007f80:	fa c8 fa b8 	sub	r8,sp,-1352
80007f84:	0c 9b       	mov	r11,r6
80007f86:	1a d8       	st.w	--sp,r8
80007f88:	fa c8 fb b4 	sub	r8,sp,-1100
80007f8c:	04 9a       	mov	r10,r2
80007f8e:	1a d8       	st.w	--sp,r8
80007f90:	08 9c       	mov	r12,r4
80007f92:	fa c8 f9 40 	sub	r8,sp,-1728
80007f96:	fa c9 ff b4 	sub	r9,sp,-76
80007f9a:	fe b0 fa f5 	rcall	80007584 <get_arg>
80007f9e:	2f dd       	sub	sp,-12
80007fa0:	78 0b       	ld.w	r11,r12[0x0]
80007fa2:	c2 48       	rjmp	80007fea <_vfprintf_r+0x72a>
80007fa4:	ee ca ff ff 	sub	r10,r7,-1
80007fa8:	10 37       	cp.w	r7,r8
80007faa:	c0 94       	brge	80007fbc <_vfprintf_r+0x6fc>
80007fac:	fa c9 f9 44 	sub	r9,sp,-1724
80007fb0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007fb4:	14 97       	mov	r7,r10
80007fb6:	ec fb fd 88 	ld.w	r11,r6[-632]
80007fba:	c1 88       	rjmp	80007fea <_vfprintf_r+0x72a>
80007fbc:	41 09       	lddsp	r9,sp[0x40]
80007fbe:	59 f8       	cp.w	r8,31
80007fc0:	e0 89 00 11 	brgt	80007fe2 <_vfprintf_r+0x722>
80007fc4:	f2 cb ff fc 	sub	r11,r9,-4
80007fc8:	51 0b       	stdsp	sp[0x40],r11
80007fca:	fa c6 f9 44 	sub	r6,sp,-1724
80007fce:	72 0b       	ld.w	r11,r9[0x0]
80007fd0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007fd4:	f3 4b fd 88 	st.w	r9[-632],r11
80007fd8:	2f f8       	sub	r8,-1
80007fda:	14 97       	mov	r7,r10
80007fdc:	fb 48 06 b4 	st.w	sp[1716],r8
80007fe0:	c0 58       	rjmp	80007fea <_vfprintf_r+0x72a>
80007fe2:	72 0b       	ld.w	r11,r9[0x0]
80007fe4:	14 97       	mov	r7,r10
80007fe6:	2f c9       	sub	r9,-4
80007fe8:	51 09       	stdsp	sp[0x40],r9
80007fea:	50 1b       	stdsp	sp[0x4],r11
80007fec:	bf 5b       	asr	r11,0x1f
80007fee:	50 0b       	stdsp	sp[0x0],r11
80007ff0:	fa ea 00 00 	ld.d	r10,sp[0]
80007ff4:	58 0a       	cp.w	r10,0
80007ff6:	5c 2b       	cpc	r11
80007ff8:	c0 e4       	brge	80008014 <_vfprintf_r+0x754>
80007ffa:	30 08       	mov	r8,0
80007ffc:	fa ea 00 00 	ld.d	r10,sp[0]
80008000:	30 09       	mov	r9,0
80008002:	f0 0a 01 0a 	sub	r10,r8,r10
80008006:	f2 0b 01 4b 	sbc	r11,r9,r11
8000800a:	32 d8       	mov	r8,45
8000800c:	fa eb 00 00 	st.d	sp[0],r10
80008010:	fb 68 06 bb 	st.b	sp[1723],r8
80008014:	30 18       	mov	r8,1
80008016:	e0 8f 06 fe 	bral	80008e12 <_vfprintf_r+0x1552>
8000801a:	50 a7       	stdsp	sp[0x28],r7
8000801c:	50 80       	stdsp	sp[0x20],r0
8000801e:	0c 97       	mov	r7,r6
80008020:	04 94       	mov	r4,r2
80008022:	06 96       	mov	r6,r3
80008024:	02 92       	mov	r2,r1
80008026:	40 93       	lddsp	r3,sp[0x24]
80008028:	10 90       	mov	r0,r8
8000802a:	40 41       	lddsp	r1,sp[0x10]
8000802c:	0e 99       	mov	r9,r7
8000802e:	ed b5 00 03 	bld	r5,0x3
80008032:	c4 11       	brne	800080b4 <_vfprintf_r+0x7f4>
80008034:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008038:	40 3a       	lddsp	r10,sp[0xc]
8000803a:	58 0a       	cp.w	r10,0
8000803c:	c1 90       	breq	8000806e <_vfprintf_r+0x7ae>
8000803e:	10 36       	cp.w	r6,r8
80008040:	c6 45       	brlt	80008108 <_vfprintf_r+0x848>
80008042:	fa c8 f9 50 	sub	r8,sp,-1712
80008046:	1a d8       	st.w	--sp,r8
80008048:	fa c8 fa b8 	sub	r8,sp,-1352
8000804c:	1a d8       	st.w	--sp,r8
8000804e:	fa c8 fb b4 	sub	r8,sp,-1100
80008052:	0c 9b       	mov	r11,r6
80008054:	1a d8       	st.w	--sp,r8
80008056:	04 9a       	mov	r10,r2
80008058:	fa c8 f9 40 	sub	r8,sp,-1728
8000805c:	fa c9 ff b4 	sub	r9,sp,-76
80008060:	08 9c       	mov	r12,r4
80008062:	fe b0 fa 91 	rcall	80007584 <get_arg>
80008066:	2f dd       	sub	sp,-12
80008068:	78 16       	ld.w	r6,r12[0x4]
8000806a:	50 76       	stdsp	sp[0x1c],r6
8000806c:	c4 88       	rjmp	800080fc <_vfprintf_r+0x83c>
8000806e:	2f f7       	sub	r7,-1
80008070:	10 39       	cp.w	r9,r8
80008072:	c0 c4       	brge	8000808a <_vfprintf_r+0x7ca>
80008074:	fa ce f9 44 	sub	lr,sp,-1724
80008078:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000807c:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008080:	50 7c       	stdsp	sp[0x1c],r12
80008082:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008086:	50 56       	stdsp	sp[0x14],r6
80008088:	c6 68       	rjmp	80008154 <_vfprintf_r+0x894>
8000808a:	41 09       	lddsp	r9,sp[0x40]
8000808c:	59 f8       	cp.w	r8,31
8000808e:	e0 89 00 10 	brgt	800080ae <_vfprintf_r+0x7ee>
80008092:	f2 ca ff f8 	sub	r10,r9,-8
80008096:	72 1b       	ld.w	r11,r9[0x4]
80008098:	51 0a       	stdsp	sp[0x40],r10
8000809a:	72 09       	ld.w	r9,r9[0x0]
8000809c:	fa ca f9 44 	sub	r10,sp,-1724
800080a0:	50 7b       	stdsp	sp[0x1c],r11
800080a2:	50 59       	stdsp	sp[0x14],r9
800080a4:	f4 08 00 39 	add	r9,r10,r8<<0x3
800080a8:	40 5b       	lddsp	r11,sp[0x14]
800080aa:	40 7a       	lddsp	r10,sp[0x1c]
800080ac:	c4 78       	rjmp	8000813a <_vfprintf_r+0x87a>
800080ae:	72 18       	ld.w	r8,r9[0x4]
800080b0:	50 78       	stdsp	sp[0x1c],r8
800080b2:	c4 c8       	rjmp	8000814a <_vfprintf_r+0x88a>
800080b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080b8:	40 3e       	lddsp	lr,sp[0xc]
800080ba:	58 0e       	cp.w	lr,0
800080bc:	c2 30       	breq	80008102 <_vfprintf_r+0x842>
800080be:	10 36       	cp.w	r6,r8
800080c0:	c0 94       	brge	800080d2 <_vfprintf_r+0x812>
800080c2:	fa cc f9 44 	sub	r12,sp,-1724
800080c6:	f8 06 00 36 	add	r6,r12,r6<<0x3
800080ca:	ec fb fd 8c 	ld.w	r11,r6[-628]
800080ce:	50 7b       	stdsp	sp[0x1c],r11
800080d0:	cd 9b       	rjmp	80008082 <_vfprintf_r+0x7c2>
800080d2:	fa c8 f9 50 	sub	r8,sp,-1712
800080d6:	1a d8       	st.w	--sp,r8
800080d8:	fa c8 fa b8 	sub	r8,sp,-1352
800080dc:	04 9a       	mov	r10,r2
800080de:	1a d8       	st.w	--sp,r8
800080e0:	fa c8 fb b4 	sub	r8,sp,-1100
800080e4:	0c 9b       	mov	r11,r6
800080e6:	1a d8       	st.w	--sp,r8
800080e8:	08 9c       	mov	r12,r4
800080ea:	fa c8 f9 40 	sub	r8,sp,-1728
800080ee:	fa c9 ff b4 	sub	r9,sp,-76
800080f2:	fe b0 fa 49 	rcall	80007584 <get_arg>
800080f6:	2f dd       	sub	sp,-12
800080f8:	78 1a       	ld.w	r10,r12[0x4]
800080fa:	50 7a       	stdsp	sp[0x1c],r10
800080fc:	78 0c       	ld.w	r12,r12[0x0]
800080fe:	50 5c       	stdsp	sp[0x14],r12
80008100:	c2 a8       	rjmp	80008154 <_vfprintf_r+0x894>
80008102:	2f f7       	sub	r7,-1
80008104:	10 39       	cp.w	r9,r8
80008106:	c0 94       	brge	80008118 <_vfprintf_r+0x858>
80008108:	fa c9 f9 44 	sub	r9,sp,-1724
8000810c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008110:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008114:	50 78       	stdsp	sp[0x1c],r8
80008116:	cb 6b       	rjmp	80008082 <_vfprintf_r+0x7c2>
80008118:	41 09       	lddsp	r9,sp[0x40]
8000811a:	59 f8       	cp.w	r8,31
8000811c:	e0 89 00 15 	brgt	80008146 <_vfprintf_r+0x886>
80008120:	f2 ca ff f8 	sub	r10,r9,-8
80008124:	72 16       	ld.w	r6,r9[0x4]
80008126:	72 09       	ld.w	r9,r9[0x0]
80008128:	51 0a       	stdsp	sp[0x40],r10
8000812a:	50 59       	stdsp	sp[0x14],r9
8000812c:	fa ce f9 44 	sub	lr,sp,-1724
80008130:	50 76       	stdsp	sp[0x1c],r6
80008132:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008136:	40 5b       	lddsp	r11,sp[0x14]
80008138:	0c 9a       	mov	r10,r6
8000813a:	f2 eb fd 88 	st.d	r9[-632],r10
8000813e:	2f f8       	sub	r8,-1
80008140:	fb 48 06 b4 	st.w	sp[1716],r8
80008144:	c0 88       	rjmp	80008154 <_vfprintf_r+0x894>
80008146:	72 1c       	ld.w	r12,r9[0x4]
80008148:	50 7c       	stdsp	sp[0x1c],r12
8000814a:	f2 c8 ff f8 	sub	r8,r9,-8
8000814e:	51 08       	stdsp	sp[0x40],r8
80008150:	72 09       	ld.w	r9,r9[0x0]
80008152:	50 59       	stdsp	sp[0x14],r9
80008154:	40 5b       	lddsp	r11,sp[0x14]
80008156:	40 7a       	lddsp	r10,sp[0x1c]
80008158:	e0 a0 19 64 	rcall	8000b420 <__isinfd>
8000815c:	18 96       	mov	r6,r12
8000815e:	c1 50       	breq	80008188 <_vfprintf_r+0x8c8>
80008160:	30 08       	mov	r8,0
80008162:	30 09       	mov	r9,0
80008164:	40 5b       	lddsp	r11,sp[0x14]
80008166:	40 7a       	lddsp	r10,sp[0x1c]
80008168:	e0 a0 1d ba 	rcall	8000bcdc <__avr32_f64_cmp_lt>
8000816c:	c0 40       	breq	80008174 <_vfprintf_r+0x8b4>
8000816e:	32 d8       	mov	r8,45
80008170:	fb 68 06 bb 	st.b	sp[1723],r8
80008174:	4d 18       	lddpc	r8,800082b8 <_vfprintf_r+0x9f8>
80008176:	4d 26       	lddpc	r6,800082bc <_vfprintf_r+0x9fc>
80008178:	a7 d5       	cbr	r5,0x7
8000817a:	e0 40 00 47 	cp.w	r0,71
8000817e:	f0 06 17 a0 	movle	r6,r8
80008182:	30 32       	mov	r2,3
80008184:	e0 8f 06 d4 	bral	80008f2c <_vfprintf_r+0x166c>
80008188:	40 5b       	lddsp	r11,sp[0x14]
8000818a:	40 7a       	lddsp	r10,sp[0x1c]
8000818c:	e0 a0 19 5f 	rcall	8000b44a <__isnand>
80008190:	c0 c0       	breq	800081a8 <_vfprintf_r+0x8e8>
80008192:	50 26       	stdsp	sp[0x8],r6
80008194:	4c b8       	lddpc	r8,800082c0 <_vfprintf_r+0xa00>
80008196:	4c c6       	lddpc	r6,800082c4 <_vfprintf_r+0xa04>
80008198:	a7 d5       	cbr	r5,0x7
8000819a:	e0 40 00 47 	cp.w	r0,71
8000819e:	f0 06 17 a0 	movle	r6,r8
800081a2:	30 32       	mov	r2,3
800081a4:	e0 8f 06 ca 	bral	80008f38 <_vfprintf_r+0x1678>
800081a8:	40 2a       	lddsp	r10,sp[0x8]
800081aa:	5b fa       	cp.w	r10,-1
800081ac:	c0 41       	brne	800081b4 <_vfprintf_r+0x8f4>
800081ae:	30 69       	mov	r9,6
800081b0:	50 29       	stdsp	sp[0x8],r9
800081b2:	c1 18       	rjmp	800081d4 <_vfprintf_r+0x914>
800081b4:	e0 40 00 47 	cp.w	r0,71
800081b8:	5f 09       	sreq	r9
800081ba:	e0 40 00 67 	cp.w	r0,103
800081be:	5f 08       	sreq	r8
800081c0:	f3 e8 10 08 	or	r8,r9,r8
800081c4:	f8 08 18 00 	cp.b	r8,r12
800081c8:	c0 60       	breq	800081d4 <_vfprintf_r+0x914>
800081ca:	40 28       	lddsp	r8,sp[0x8]
800081cc:	58 08       	cp.w	r8,0
800081ce:	f9 b8 00 01 	moveq	r8,1
800081d2:	50 28       	stdsp	sp[0x8],r8
800081d4:	40 78       	lddsp	r8,sp[0x1c]
800081d6:	40 59       	lddsp	r9,sp[0x14]
800081d8:	fa e9 06 94 	st.d	sp[1684],r8
800081dc:	a9 a5       	sbr	r5,0x8
800081de:	fa f8 06 94 	ld.w	r8,sp[1684]
800081e2:	58 08       	cp.w	r8,0
800081e4:	c0 65       	brlt	800081f0 <_vfprintf_r+0x930>
800081e6:	40 5e       	lddsp	lr,sp[0x14]
800081e8:	30 0c       	mov	r12,0
800081ea:	50 6e       	stdsp	sp[0x18],lr
800081ec:	50 9c       	stdsp	sp[0x24],r12
800081ee:	c0 78       	rjmp	800081fc <_vfprintf_r+0x93c>
800081f0:	40 5b       	lddsp	r11,sp[0x14]
800081f2:	32 da       	mov	r10,45
800081f4:	ee 1b 80 00 	eorh	r11,0x8000
800081f8:	50 9a       	stdsp	sp[0x24],r10
800081fa:	50 6b       	stdsp	sp[0x18],r11
800081fc:	e0 40 00 46 	cp.w	r0,70
80008200:	5f 09       	sreq	r9
80008202:	e0 40 00 66 	cp.w	r0,102
80008206:	5f 08       	sreq	r8
80008208:	f3 e8 10 08 	or	r8,r9,r8
8000820c:	50 48       	stdsp	sp[0x10],r8
8000820e:	c0 40       	breq	80008216 <_vfprintf_r+0x956>
80008210:	40 22       	lddsp	r2,sp[0x8]
80008212:	30 39       	mov	r9,3
80008214:	c1 08       	rjmp	80008234 <_vfprintf_r+0x974>
80008216:	e0 40 00 45 	cp.w	r0,69
8000821a:	5f 09       	sreq	r9
8000821c:	e0 40 00 65 	cp.w	r0,101
80008220:	5f 08       	sreq	r8
80008222:	40 22       	lddsp	r2,sp[0x8]
80008224:	10 49       	or	r9,r8
80008226:	2f f2       	sub	r2,-1
80008228:	40 46       	lddsp	r6,sp[0x10]
8000822a:	ec 09 18 00 	cp.b	r9,r6
8000822e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008232:	30 29       	mov	r9,2
80008234:	fa c8 f9 5c 	sub	r8,sp,-1700
80008238:	1a d8       	st.w	--sp,r8
8000823a:	fa c8 f9 54 	sub	r8,sp,-1708
8000823e:	1a d8       	st.w	--sp,r8
80008240:	fa c8 f9 4c 	sub	r8,sp,-1716
80008244:	08 9c       	mov	r12,r4
80008246:	1a d8       	st.w	--sp,r8
80008248:	04 98       	mov	r8,r2
8000824a:	40 9b       	lddsp	r11,sp[0x24]
8000824c:	40 aa       	lddsp	r10,sp[0x28]
8000824e:	e0 a0 0b cf 	rcall	800099ec <_dtoa_r>
80008252:	e0 40 00 47 	cp.w	r0,71
80008256:	5f 19       	srne	r9
80008258:	e0 40 00 67 	cp.w	r0,103
8000825c:	5f 18       	srne	r8
8000825e:	18 96       	mov	r6,r12
80008260:	2f dd       	sub	sp,-12
80008262:	f3 e8 00 08 	and	r8,r9,r8
80008266:	c0 41       	brne	8000826e <_vfprintf_r+0x9ae>
80008268:	ed b5 00 00 	bld	r5,0x0
8000826c:	c3 81       	brne	800082dc <_vfprintf_r+0xa1c>
8000826e:	ec 02 00 0e 	add	lr,r6,r2
80008272:	50 3e       	stdsp	sp[0xc],lr
80008274:	40 4c       	lddsp	r12,sp[0x10]
80008276:	58 0c       	cp.w	r12,0
80008278:	c1 50       	breq	800082a2 <_vfprintf_r+0x9e2>
8000827a:	0d 89       	ld.ub	r9,r6[0x0]
8000827c:	33 08       	mov	r8,48
8000827e:	f0 09 18 00 	cp.b	r9,r8
80008282:	c0 b1       	brne	80008298 <_vfprintf_r+0x9d8>
80008284:	30 08       	mov	r8,0
80008286:	30 09       	mov	r9,0
80008288:	40 6b       	lddsp	r11,sp[0x18]
8000828a:	40 7a       	lddsp	r10,sp[0x1c]
8000828c:	e0 a0 1c e1 	rcall	8000bc4e <__avr32_f64_cmp_eq>
80008290:	fb b2 00 01 	rsubeq	r2,1
80008294:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008298:	40 3b       	lddsp	r11,sp[0xc]
8000829a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000829e:	10 0b       	add	r11,r8
800082a0:	50 3b       	stdsp	sp[0xc],r11
800082a2:	40 6b       	lddsp	r11,sp[0x18]
800082a4:	30 08       	mov	r8,0
800082a6:	30 09       	mov	r9,0
800082a8:	40 7a       	lddsp	r10,sp[0x1c]
800082aa:	e0 a0 1c d2 	rcall	8000bc4e <__avr32_f64_cmp_eq>
800082ae:	c1 10       	breq	800082d0 <_vfprintf_r+0xa10>
800082b0:	40 3a       	lddsp	r10,sp[0xc]
800082b2:	fb 4a 06 a4 	st.w	sp[1700],r10
800082b6:	c0 d8       	rjmp	800082d0 <_vfprintf_r+0xa10>
800082b8:	80 01       	ld.sh	r1,r0[0x0]
800082ba:	5f c0       	srvs	r0
800082bc:	80 01       	ld.sh	r1,r0[0x0]
800082be:	5f c4       	srvs	r4
800082c0:	80 01       	ld.sh	r1,r0[0x0]
800082c2:	5f c8       	srvs	r8
800082c4:	80 01       	ld.sh	r1,r0[0x0]
800082c6:	5f cc       	srvs	r12
800082c8:	10 c9       	st.b	r8++,r9
800082ca:	fb 48 06 a4 	st.w	sp[1700],r8
800082ce:	c0 28       	rjmp	800082d2 <_vfprintf_r+0xa12>
800082d0:	33 09       	mov	r9,48
800082d2:	fa f8 06 a4 	ld.w	r8,sp[1700]
800082d6:	40 3e       	lddsp	lr,sp[0xc]
800082d8:	1c 38       	cp.w	r8,lr
800082da:	cf 73       	brcs	800082c8 <_vfprintf_r+0xa08>
800082dc:	e0 40 00 47 	cp.w	r0,71
800082e0:	5f 09       	sreq	r9
800082e2:	e0 40 00 67 	cp.w	r0,103
800082e6:	5f 08       	sreq	r8
800082e8:	f3 e8 10 08 	or	r8,r9,r8
800082ec:	fa f9 06 a4 	ld.w	r9,sp[1700]
800082f0:	0c 19       	sub	r9,r6
800082f2:	50 69       	stdsp	sp[0x18],r9
800082f4:	58 08       	cp.w	r8,0
800082f6:	c0 b0       	breq	8000830c <_vfprintf_r+0xa4c>
800082f8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800082fc:	5b d8       	cp.w	r8,-3
800082fe:	c0 55       	brlt	80008308 <_vfprintf_r+0xa48>
80008300:	40 2c       	lddsp	r12,sp[0x8]
80008302:	18 38       	cp.w	r8,r12
80008304:	e0 8a 00 6a 	brle	800083d8 <_vfprintf_r+0xb18>
80008308:	20 20       	sub	r0,2
8000830a:	c0 58       	rjmp	80008314 <_vfprintf_r+0xa54>
8000830c:	e0 40 00 65 	cp.w	r0,101
80008310:	e0 89 00 46 	brgt	8000839c <_vfprintf_r+0xadc>
80008314:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008318:	fb 60 06 9c 	st.b	sp[1692],r0
8000831c:	20 1b       	sub	r11,1
8000831e:	fb 4b 06 ac 	st.w	sp[1708],r11
80008322:	c0 47       	brpl	8000832a <_vfprintf_r+0xa6a>
80008324:	5c 3b       	neg	r11
80008326:	32 d8       	mov	r8,45
80008328:	c0 28       	rjmp	8000832c <_vfprintf_r+0xa6c>
8000832a:	32 b8       	mov	r8,43
8000832c:	fb 68 06 9d 	st.b	sp[1693],r8
80008330:	58 9b       	cp.w	r11,9
80008332:	e0 8a 00 1d 	brle	8000836c <_vfprintf_r+0xaac>
80008336:	fa c9 fa 35 	sub	r9,sp,-1483
8000833a:	30 aa       	mov	r10,10
8000833c:	12 98       	mov	r8,r9
8000833e:	0e 9c       	mov	r12,r7
80008340:	0c 92       	mov	r2,r6
80008342:	f6 0a 0c 06 	divs	r6,r11,r10
80008346:	0e 9b       	mov	r11,r7
80008348:	2d 0b       	sub	r11,-48
8000834a:	10 fb       	st.b	--r8,r11
8000834c:	0c 9b       	mov	r11,r6
8000834e:	58 96       	cp.w	r6,9
80008350:	fe 99 ff f9 	brgt	80008342 <_vfprintf_r+0xa82>
80008354:	2d 0b       	sub	r11,-48
80008356:	18 97       	mov	r7,r12
80008358:	04 96       	mov	r6,r2
8000835a:	10 fb       	st.b	--r8,r11
8000835c:	fa ca f9 62 	sub	r10,sp,-1694
80008360:	c0 38       	rjmp	80008366 <_vfprintf_r+0xaa6>
80008362:	11 3b       	ld.ub	r11,r8++
80008364:	14 cb       	st.b	r10++,r11
80008366:	12 38       	cp.w	r8,r9
80008368:	cf d3       	brcs	80008362 <_vfprintf_r+0xaa2>
8000836a:	c0 98       	rjmp	8000837c <_vfprintf_r+0xabc>
8000836c:	2d 0b       	sub	r11,-48
8000836e:	33 08       	mov	r8,48
80008370:	fb 6b 06 9f 	st.b	sp[1695],r11
80008374:	fb 68 06 9e 	st.b	sp[1694],r8
80008378:	fa ca f9 60 	sub	r10,sp,-1696
8000837c:	fa c8 f9 64 	sub	r8,sp,-1692
80008380:	f4 08 01 08 	sub	r8,r10,r8
80008384:	50 e8       	stdsp	sp[0x38],r8
80008386:	10 92       	mov	r2,r8
80008388:	40 6b       	lddsp	r11,sp[0x18]
8000838a:	16 02       	add	r2,r11
8000838c:	58 1b       	cp.w	r11,1
8000838e:	e0 89 00 05 	brgt	80008398 <_vfprintf_r+0xad8>
80008392:	ed b5 00 00 	bld	r5,0x0
80008396:	c3 51       	brne	80008400 <_vfprintf_r+0xb40>
80008398:	2f f2       	sub	r2,-1
8000839a:	c3 38       	rjmp	80008400 <_vfprintf_r+0xb40>
8000839c:	e0 40 00 66 	cp.w	r0,102
800083a0:	c1 c1       	brne	800083d8 <_vfprintf_r+0xb18>
800083a2:	fa f2 06 ac 	ld.w	r2,sp[1708]
800083a6:	58 02       	cp.w	r2,0
800083a8:	e0 8a 00 0c 	brle	800083c0 <_vfprintf_r+0xb00>
800083ac:	40 2a       	lddsp	r10,sp[0x8]
800083ae:	58 0a       	cp.w	r10,0
800083b0:	c0 41       	brne	800083b8 <_vfprintf_r+0xaf8>
800083b2:	ed b5 00 00 	bld	r5,0x0
800083b6:	c2 51       	brne	80008400 <_vfprintf_r+0xb40>
800083b8:	2f f2       	sub	r2,-1
800083ba:	40 29       	lddsp	r9,sp[0x8]
800083bc:	12 02       	add	r2,r9
800083be:	c0 b8       	rjmp	800083d4 <_vfprintf_r+0xb14>
800083c0:	40 28       	lddsp	r8,sp[0x8]
800083c2:	58 08       	cp.w	r8,0
800083c4:	c0 61       	brne	800083d0 <_vfprintf_r+0xb10>
800083c6:	ed b5 00 00 	bld	r5,0x0
800083ca:	c0 30       	breq	800083d0 <_vfprintf_r+0xb10>
800083cc:	30 12       	mov	r2,1
800083ce:	c1 98       	rjmp	80008400 <_vfprintf_r+0xb40>
800083d0:	40 22       	lddsp	r2,sp[0x8]
800083d2:	2f e2       	sub	r2,-2
800083d4:	36 60       	mov	r0,102
800083d6:	c1 58       	rjmp	80008400 <_vfprintf_r+0xb40>
800083d8:	fa f2 06 ac 	ld.w	r2,sp[1708]
800083dc:	40 6e       	lddsp	lr,sp[0x18]
800083de:	1c 32       	cp.w	r2,lr
800083e0:	c0 65       	brlt	800083ec <_vfprintf_r+0xb2c>
800083e2:	ed b5 00 00 	bld	r5,0x0
800083e6:	f7 b2 00 ff 	subeq	r2,-1
800083ea:	c0 a8       	rjmp	800083fe <_vfprintf_r+0xb3e>
800083ec:	e4 08 11 02 	rsub	r8,r2,2
800083f0:	40 6c       	lddsp	r12,sp[0x18]
800083f2:	58 02       	cp.w	r2,0
800083f4:	f0 02 17 a0 	movle	r2,r8
800083f8:	f9 b2 09 01 	movgt	r2,1
800083fc:	18 02       	add	r2,r12
800083fe:	36 70       	mov	r0,103
80008400:	40 9b       	lddsp	r11,sp[0x24]
80008402:	58 0b       	cp.w	r11,0
80008404:	e0 80 05 94 	breq	80008f2c <_vfprintf_r+0x166c>
80008408:	32 d8       	mov	r8,45
8000840a:	fb 68 06 bb 	st.b	sp[1723],r8
8000840e:	e0 8f 05 93 	bral	80008f34 <_vfprintf_r+0x1674>
80008412:	50 a7       	stdsp	sp[0x28],r7
80008414:	04 94       	mov	r4,r2
80008416:	0c 97       	mov	r7,r6
80008418:	02 92       	mov	r2,r1
8000841a:	06 96       	mov	r6,r3
8000841c:	40 41       	lddsp	r1,sp[0x10]
8000841e:	40 93       	lddsp	r3,sp[0x24]
80008420:	0e 99       	mov	r9,r7
80008422:	ed b5 00 05 	bld	r5,0x5
80008426:	c4 81       	brne	800084b6 <_vfprintf_r+0xbf6>
80008428:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000842c:	40 3e       	lddsp	lr,sp[0xc]
8000842e:	58 0e       	cp.w	lr,0
80008430:	c1 d0       	breq	8000846a <_vfprintf_r+0xbaa>
80008432:	10 36       	cp.w	r6,r8
80008434:	c0 64       	brge	80008440 <_vfprintf_r+0xb80>
80008436:	fa cc f9 44 	sub	r12,sp,-1724
8000843a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000843e:	c1 d8       	rjmp	80008478 <_vfprintf_r+0xbb8>
80008440:	fa c8 f9 50 	sub	r8,sp,-1712
80008444:	1a d8       	st.w	--sp,r8
80008446:	fa c8 fa b8 	sub	r8,sp,-1352
8000844a:	04 9a       	mov	r10,r2
8000844c:	1a d8       	st.w	--sp,r8
8000844e:	fa c8 fb b4 	sub	r8,sp,-1100
80008452:	0c 9b       	mov	r11,r6
80008454:	1a d8       	st.w	--sp,r8
80008456:	08 9c       	mov	r12,r4
80008458:	fa c8 f9 40 	sub	r8,sp,-1728
8000845c:	fa c9 ff b4 	sub	r9,sp,-76
80008460:	fe b0 f8 92 	rcall	80007584 <get_arg>
80008464:	2f dd       	sub	sp,-12
80008466:	78 0a       	ld.w	r10,r12[0x0]
80008468:	c2 08       	rjmp	800084a8 <_vfprintf_r+0xbe8>
8000846a:	2f f7       	sub	r7,-1
8000846c:	10 39       	cp.w	r9,r8
8000846e:	c0 84       	brge	8000847e <_vfprintf_r+0xbbe>
80008470:	fa cb f9 44 	sub	r11,sp,-1724
80008474:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008478:	ec fa fd 88 	ld.w	r10,r6[-632]
8000847c:	c1 68       	rjmp	800084a8 <_vfprintf_r+0xbe8>
8000847e:	41 09       	lddsp	r9,sp[0x40]
80008480:	59 f8       	cp.w	r8,31
80008482:	e0 89 00 10 	brgt	800084a2 <_vfprintf_r+0xbe2>
80008486:	f2 ca ff fc 	sub	r10,r9,-4
8000848a:	51 0a       	stdsp	sp[0x40],r10
8000848c:	fa c6 f9 44 	sub	r6,sp,-1724
80008490:	72 0a       	ld.w	r10,r9[0x0]
80008492:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008496:	f3 4a fd 88 	st.w	r9[-632],r10
8000849a:	2f f8       	sub	r8,-1
8000849c:	fb 48 06 b4 	st.w	sp[1716],r8
800084a0:	c0 48       	rjmp	800084a8 <_vfprintf_r+0xbe8>
800084a2:	72 0a       	ld.w	r10,r9[0x0]
800084a4:	2f c9       	sub	r9,-4
800084a6:	51 09       	stdsp	sp[0x40],r9
800084a8:	40 be       	lddsp	lr,sp[0x2c]
800084aa:	1c 98       	mov	r8,lr
800084ac:	95 1e       	st.w	r10[0x4],lr
800084ae:	bf 58       	asr	r8,0x1f
800084b0:	95 08       	st.w	r10[0x0],r8
800084b2:	fe 9f fa 92 	bral	800079d6 <_vfprintf_r+0x116>
800084b6:	ed b5 00 04 	bld	r5,0x4
800084ba:	c4 80       	breq	8000854a <_vfprintf_r+0xc8a>
800084bc:	e2 15 00 40 	andl	r5,0x40,COH
800084c0:	c4 50       	breq	8000854a <_vfprintf_r+0xc8a>
800084c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084c6:	40 3c       	lddsp	r12,sp[0xc]
800084c8:	58 0c       	cp.w	r12,0
800084ca:	c1 d0       	breq	80008504 <_vfprintf_r+0xc44>
800084cc:	10 36       	cp.w	r6,r8
800084ce:	c0 64       	brge	800084da <_vfprintf_r+0xc1a>
800084d0:	fa cb f9 44 	sub	r11,sp,-1724
800084d4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084d8:	c1 d8       	rjmp	80008512 <_vfprintf_r+0xc52>
800084da:	fa c8 f9 50 	sub	r8,sp,-1712
800084de:	1a d8       	st.w	--sp,r8
800084e0:	fa c8 fa b8 	sub	r8,sp,-1352
800084e4:	04 9a       	mov	r10,r2
800084e6:	1a d8       	st.w	--sp,r8
800084e8:	fa c8 fb b4 	sub	r8,sp,-1100
800084ec:	0c 9b       	mov	r11,r6
800084ee:	1a d8       	st.w	--sp,r8
800084f0:	08 9c       	mov	r12,r4
800084f2:	fa c8 f9 40 	sub	r8,sp,-1728
800084f6:	fa c9 ff b4 	sub	r9,sp,-76
800084fa:	fe b0 f8 45 	rcall	80007584 <get_arg>
800084fe:	2f dd       	sub	sp,-12
80008500:	78 0a       	ld.w	r10,r12[0x0]
80008502:	c2 08       	rjmp	80008542 <_vfprintf_r+0xc82>
80008504:	2f f7       	sub	r7,-1
80008506:	10 39       	cp.w	r9,r8
80008508:	c0 84       	brge	80008518 <_vfprintf_r+0xc58>
8000850a:	fa ca f9 44 	sub	r10,sp,-1724
8000850e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008512:	ec fa fd 88 	ld.w	r10,r6[-632]
80008516:	c1 68       	rjmp	80008542 <_vfprintf_r+0xc82>
80008518:	41 09       	lddsp	r9,sp[0x40]
8000851a:	59 f8       	cp.w	r8,31
8000851c:	e0 89 00 10 	brgt	8000853c <_vfprintf_r+0xc7c>
80008520:	f2 ca ff fc 	sub	r10,r9,-4
80008524:	51 0a       	stdsp	sp[0x40],r10
80008526:	fa c6 f9 44 	sub	r6,sp,-1724
8000852a:	72 0a       	ld.w	r10,r9[0x0]
8000852c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008530:	f3 4a fd 88 	st.w	r9[-632],r10
80008534:	2f f8       	sub	r8,-1
80008536:	fb 48 06 b4 	st.w	sp[1716],r8
8000853a:	c0 48       	rjmp	80008542 <_vfprintf_r+0xc82>
8000853c:	72 0a       	ld.w	r10,r9[0x0]
8000853e:	2f c9       	sub	r9,-4
80008540:	51 09       	stdsp	sp[0x40],r9
80008542:	40 be       	lddsp	lr,sp[0x2c]
80008544:	b4 0e       	st.h	r10[0x0],lr
80008546:	fe 9f fa 48 	bral	800079d6 <_vfprintf_r+0x116>
8000854a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000854e:	40 3c       	lddsp	r12,sp[0xc]
80008550:	58 0c       	cp.w	r12,0
80008552:	c1 d0       	breq	8000858c <_vfprintf_r+0xccc>
80008554:	10 36       	cp.w	r6,r8
80008556:	c0 64       	brge	80008562 <_vfprintf_r+0xca2>
80008558:	fa cb f9 44 	sub	r11,sp,-1724
8000855c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008560:	c1 d8       	rjmp	8000859a <_vfprintf_r+0xcda>
80008562:	fa c8 f9 50 	sub	r8,sp,-1712
80008566:	1a d8       	st.w	--sp,r8
80008568:	fa c8 fa b8 	sub	r8,sp,-1352
8000856c:	04 9a       	mov	r10,r2
8000856e:	1a d8       	st.w	--sp,r8
80008570:	fa c8 fb b4 	sub	r8,sp,-1100
80008574:	0c 9b       	mov	r11,r6
80008576:	1a d8       	st.w	--sp,r8
80008578:	08 9c       	mov	r12,r4
8000857a:	fa c8 f9 40 	sub	r8,sp,-1728
8000857e:	fa c9 ff b4 	sub	r9,sp,-76
80008582:	fe b0 f8 01 	rcall	80007584 <get_arg>
80008586:	2f dd       	sub	sp,-12
80008588:	78 0a       	ld.w	r10,r12[0x0]
8000858a:	c2 08       	rjmp	800085ca <_vfprintf_r+0xd0a>
8000858c:	2f f7       	sub	r7,-1
8000858e:	10 39       	cp.w	r9,r8
80008590:	c0 84       	brge	800085a0 <_vfprintf_r+0xce0>
80008592:	fa ca f9 44 	sub	r10,sp,-1724
80008596:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000859a:	ec fa fd 88 	ld.w	r10,r6[-632]
8000859e:	c1 68       	rjmp	800085ca <_vfprintf_r+0xd0a>
800085a0:	41 09       	lddsp	r9,sp[0x40]
800085a2:	59 f8       	cp.w	r8,31
800085a4:	e0 89 00 10 	brgt	800085c4 <_vfprintf_r+0xd04>
800085a8:	f2 ca ff fc 	sub	r10,r9,-4
800085ac:	51 0a       	stdsp	sp[0x40],r10
800085ae:	fa c6 f9 44 	sub	r6,sp,-1724
800085b2:	72 0a       	ld.w	r10,r9[0x0]
800085b4:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085b8:	f3 4a fd 88 	st.w	r9[-632],r10
800085bc:	2f f8       	sub	r8,-1
800085be:	fb 48 06 b4 	st.w	sp[1716],r8
800085c2:	c0 48       	rjmp	800085ca <_vfprintf_r+0xd0a>
800085c4:	72 0a       	ld.w	r10,r9[0x0]
800085c6:	2f c9       	sub	r9,-4
800085c8:	51 09       	stdsp	sp[0x40],r9
800085ca:	40 be       	lddsp	lr,sp[0x2c]
800085cc:	95 0e       	st.w	r10[0x0],lr
800085ce:	fe 9f fa 04 	bral	800079d6 <_vfprintf_r+0x116>
800085d2:	50 a7       	stdsp	sp[0x28],r7
800085d4:	50 80       	stdsp	sp[0x20],r0
800085d6:	0c 97       	mov	r7,r6
800085d8:	04 94       	mov	r4,r2
800085da:	06 96       	mov	r6,r3
800085dc:	02 92       	mov	r2,r1
800085de:	40 93       	lddsp	r3,sp[0x24]
800085e0:	10 90       	mov	r0,r8
800085e2:	40 41       	lddsp	r1,sp[0x10]
800085e4:	a5 a5       	sbr	r5,0x4
800085e6:	c0 a8       	rjmp	800085fa <_vfprintf_r+0xd3a>
800085e8:	50 a7       	stdsp	sp[0x28],r7
800085ea:	50 80       	stdsp	sp[0x20],r0
800085ec:	0c 97       	mov	r7,r6
800085ee:	04 94       	mov	r4,r2
800085f0:	06 96       	mov	r6,r3
800085f2:	02 92       	mov	r2,r1
800085f4:	40 93       	lddsp	r3,sp[0x24]
800085f6:	10 90       	mov	r0,r8
800085f8:	40 41       	lddsp	r1,sp[0x10]
800085fa:	ed b5 00 05 	bld	r5,0x5
800085fe:	c5 d1       	brne	800086b8 <_vfprintf_r+0xdf8>
80008600:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008604:	40 3c       	lddsp	r12,sp[0xc]
80008606:	58 0c       	cp.w	r12,0
80008608:	c2 60       	breq	80008654 <_vfprintf_r+0xd94>
8000860a:	10 36       	cp.w	r6,r8
8000860c:	c0 a4       	brge	80008620 <_vfprintf_r+0xd60>
8000860e:	fa cb f9 44 	sub	r11,sp,-1724
80008612:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008616:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000861a:	fa e9 00 00 	st.d	sp[0],r8
8000861e:	c1 88       	rjmp	8000864e <_vfprintf_r+0xd8e>
80008620:	fa c8 f9 50 	sub	r8,sp,-1712
80008624:	1a d8       	st.w	--sp,r8
80008626:	fa c8 fa b8 	sub	r8,sp,-1352
8000862a:	04 9a       	mov	r10,r2
8000862c:	1a d8       	st.w	--sp,r8
8000862e:	0c 9b       	mov	r11,r6
80008630:	fa c8 fb b4 	sub	r8,sp,-1100
80008634:	08 9c       	mov	r12,r4
80008636:	1a d8       	st.w	--sp,r8
80008638:	fa c8 f9 40 	sub	r8,sp,-1728
8000863c:	fa c9 ff b4 	sub	r9,sp,-76
80008640:	fe b0 f7 a2 	rcall	80007584 <get_arg>
80008644:	2f dd       	sub	sp,-12
80008646:	f8 ea 00 00 	ld.d	r10,r12[0]
8000864a:	fa eb 00 00 	st.d	sp[0],r10
8000864e:	30 08       	mov	r8,0
80008650:	e0 8f 03 de 	bral	80008e0c <_vfprintf_r+0x154c>
80008654:	ee ca ff ff 	sub	r10,r7,-1
80008658:	10 37       	cp.w	r7,r8
8000865a:	c0 b4       	brge	80008670 <_vfprintf_r+0xdb0>
8000865c:	fa c9 f9 44 	sub	r9,sp,-1724
80008660:	14 97       	mov	r7,r10
80008662:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008666:	ec ea fd 88 	ld.d	r10,r6[-632]
8000866a:	fa eb 00 00 	st.d	sp[0],r10
8000866e:	c1 88       	rjmp	8000869e <_vfprintf_r+0xdde>
80008670:	41 09       	lddsp	r9,sp[0x40]
80008672:	59 f8       	cp.w	r8,31
80008674:	e0 89 00 18 	brgt	800086a4 <_vfprintf_r+0xde4>
80008678:	f2 e6 00 00 	ld.d	r6,r9[0]
8000867c:	f2 cb ff f8 	sub	r11,r9,-8
80008680:	fa e7 00 00 	st.d	sp[0],r6
80008684:	51 0b       	stdsp	sp[0x40],r11
80008686:	fa c6 f9 44 	sub	r6,sp,-1724
8000868a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000868e:	fa e6 00 00 	ld.d	r6,sp[0]
80008692:	f2 e7 fd 88 	st.d	r9[-632],r6
80008696:	2f f8       	sub	r8,-1
80008698:	14 97       	mov	r7,r10
8000869a:	fb 48 06 b4 	st.w	sp[1716],r8
8000869e:	40 38       	lddsp	r8,sp[0xc]
800086a0:	e0 8f 03 b6 	bral	80008e0c <_vfprintf_r+0x154c>
800086a4:	f2 e6 00 00 	ld.d	r6,r9[0]
800086a8:	40 38       	lddsp	r8,sp[0xc]
800086aa:	fa e7 00 00 	st.d	sp[0],r6
800086ae:	2f 89       	sub	r9,-8
800086b0:	14 97       	mov	r7,r10
800086b2:	51 09       	stdsp	sp[0x40],r9
800086b4:	e0 8f 03 ac 	bral	80008e0c <_vfprintf_r+0x154c>
800086b8:	ed b5 00 04 	bld	r5,0x4
800086bc:	c1 61       	brne	800086e8 <_vfprintf_r+0xe28>
800086be:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086c2:	40 3e       	lddsp	lr,sp[0xc]
800086c4:	58 0e       	cp.w	lr,0
800086c6:	c0 80       	breq	800086d6 <_vfprintf_r+0xe16>
800086c8:	10 36       	cp.w	r6,r8
800086ca:	c6 74       	brge	80008798 <_vfprintf_r+0xed8>
800086cc:	fa cc f9 44 	sub	r12,sp,-1724
800086d0:	f8 06 00 36 	add	r6,r12,r6<<0x3
800086d4:	c8 08       	rjmp	800087d4 <_vfprintf_r+0xf14>
800086d6:	ee ca ff ff 	sub	r10,r7,-1
800086da:	10 37       	cp.w	r7,r8
800086dc:	c7 f4       	brge	800087da <_vfprintf_r+0xf1a>
800086de:	fa cb f9 44 	sub	r11,sp,-1724
800086e2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086e6:	c7 68       	rjmp	800087d2 <_vfprintf_r+0xf12>
800086e8:	ed b5 00 06 	bld	r5,0x6
800086ec:	c4 a1       	brne	80008780 <_vfprintf_r+0xec0>
800086ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086f2:	40 3c       	lddsp	r12,sp[0xc]
800086f4:	58 0c       	cp.w	r12,0
800086f6:	c1 d0       	breq	80008730 <_vfprintf_r+0xe70>
800086f8:	10 36       	cp.w	r6,r8
800086fa:	c0 64       	brge	80008706 <_vfprintf_r+0xe46>
800086fc:	fa cb f9 44 	sub	r11,sp,-1724
80008700:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008704:	c1 f8       	rjmp	80008742 <_vfprintf_r+0xe82>
80008706:	fa c8 f9 50 	sub	r8,sp,-1712
8000870a:	1a d8       	st.w	--sp,r8
8000870c:	fa c8 fa b8 	sub	r8,sp,-1352
80008710:	1a d8       	st.w	--sp,r8
80008712:	fa c8 fb b4 	sub	r8,sp,-1100
80008716:	1a d8       	st.w	--sp,r8
80008718:	fa c8 f9 40 	sub	r8,sp,-1728
8000871c:	fa c9 ff b4 	sub	r9,sp,-76
80008720:	04 9a       	mov	r10,r2
80008722:	0c 9b       	mov	r11,r6
80008724:	08 9c       	mov	r12,r4
80008726:	fe b0 f7 2f 	rcall	80007584 <get_arg>
8000872a:	2f dd       	sub	sp,-12
8000872c:	98 18       	ld.sh	r8,r12[0x2]
8000872e:	c2 68       	rjmp	8000877a <_vfprintf_r+0xeba>
80008730:	ee ca ff ff 	sub	r10,r7,-1
80008734:	10 37       	cp.w	r7,r8
80008736:	c0 94       	brge	80008748 <_vfprintf_r+0xe88>
80008738:	fa c9 f9 44 	sub	r9,sp,-1724
8000873c:	14 97       	mov	r7,r10
8000873e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008742:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008746:	c1 a8       	rjmp	8000877a <_vfprintf_r+0xeba>
80008748:	41 09       	lddsp	r9,sp[0x40]
8000874a:	59 f8       	cp.w	r8,31
8000874c:	e0 89 00 13 	brgt	80008772 <_vfprintf_r+0xeb2>
80008750:	f2 cb ff fc 	sub	r11,r9,-4
80008754:	51 0b       	stdsp	sp[0x40],r11
80008756:	72 09       	ld.w	r9,r9[0x0]
80008758:	fa c6 f9 44 	sub	r6,sp,-1724
8000875c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008760:	2f f8       	sub	r8,-1
80008762:	f7 49 fd 88 	st.w	r11[-632],r9
80008766:	fb 48 06 b4 	st.w	sp[1716],r8
8000876a:	14 97       	mov	r7,r10
8000876c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008770:	c0 58       	rjmp	8000877a <_vfprintf_r+0xeba>
80008772:	92 18       	ld.sh	r8,r9[0x2]
80008774:	14 97       	mov	r7,r10
80008776:	2f c9       	sub	r9,-4
80008778:	51 09       	stdsp	sp[0x40],r9
8000877a:	5c 78       	castu.h	r8
8000877c:	50 18       	stdsp	sp[0x4],r8
8000877e:	c4 68       	rjmp	8000880a <_vfprintf_r+0xf4a>
80008780:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008784:	40 3c       	lddsp	r12,sp[0xc]
80008786:	58 0c       	cp.w	r12,0
80008788:	c1 d0       	breq	800087c2 <_vfprintf_r+0xf02>
8000878a:	10 36       	cp.w	r6,r8
8000878c:	c0 64       	brge	80008798 <_vfprintf_r+0xed8>
8000878e:	fa cb f9 44 	sub	r11,sp,-1724
80008792:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008796:	c1 f8       	rjmp	800087d4 <_vfprintf_r+0xf14>
80008798:	fa c8 f9 50 	sub	r8,sp,-1712
8000879c:	1a d8       	st.w	--sp,r8
8000879e:	fa c8 fa b8 	sub	r8,sp,-1352
800087a2:	0c 9b       	mov	r11,r6
800087a4:	1a d8       	st.w	--sp,r8
800087a6:	fa c8 fb b4 	sub	r8,sp,-1100
800087aa:	04 9a       	mov	r10,r2
800087ac:	1a d8       	st.w	--sp,r8
800087ae:	08 9c       	mov	r12,r4
800087b0:	fa c8 f9 40 	sub	r8,sp,-1728
800087b4:	fa c9 ff b4 	sub	r9,sp,-76
800087b8:	fe b0 f6 e6 	rcall	80007584 <get_arg>
800087bc:	2f dd       	sub	sp,-12
800087be:	78 0b       	ld.w	r11,r12[0x0]
800087c0:	c2 48       	rjmp	80008808 <_vfprintf_r+0xf48>
800087c2:	ee ca ff ff 	sub	r10,r7,-1
800087c6:	10 37       	cp.w	r7,r8
800087c8:	c0 94       	brge	800087da <_vfprintf_r+0xf1a>
800087ca:	fa c9 f9 44 	sub	r9,sp,-1724
800087ce:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087d2:	14 97       	mov	r7,r10
800087d4:	ec fb fd 88 	ld.w	r11,r6[-632]
800087d8:	c1 88       	rjmp	80008808 <_vfprintf_r+0xf48>
800087da:	41 09       	lddsp	r9,sp[0x40]
800087dc:	59 f8       	cp.w	r8,31
800087de:	e0 89 00 11 	brgt	80008800 <_vfprintf_r+0xf40>
800087e2:	f2 cb ff fc 	sub	r11,r9,-4
800087e6:	51 0b       	stdsp	sp[0x40],r11
800087e8:	fa c6 f9 44 	sub	r6,sp,-1724
800087ec:	72 0b       	ld.w	r11,r9[0x0]
800087ee:	ec 08 00 39 	add	r9,r6,r8<<0x3
800087f2:	f3 4b fd 88 	st.w	r9[-632],r11
800087f6:	2f f8       	sub	r8,-1
800087f8:	14 97       	mov	r7,r10
800087fa:	fb 48 06 b4 	st.w	sp[1716],r8
800087fe:	c0 58       	rjmp	80008808 <_vfprintf_r+0xf48>
80008800:	72 0b       	ld.w	r11,r9[0x0]
80008802:	14 97       	mov	r7,r10
80008804:	2f c9       	sub	r9,-4
80008806:	51 09       	stdsp	sp[0x40],r9
80008808:	50 1b       	stdsp	sp[0x4],r11
8000880a:	30 0e       	mov	lr,0
8000880c:	50 0e       	stdsp	sp[0x0],lr
8000880e:	1c 98       	mov	r8,lr
80008810:	e0 8f 02 fe 	bral	80008e0c <_vfprintf_r+0x154c>
80008814:	50 a7       	stdsp	sp[0x28],r7
80008816:	50 80       	stdsp	sp[0x20],r0
80008818:	0c 97       	mov	r7,r6
8000881a:	04 94       	mov	r4,r2
8000881c:	06 96       	mov	r6,r3
8000881e:	02 92       	mov	r2,r1
80008820:	40 93       	lddsp	r3,sp[0x24]
80008822:	40 41       	lddsp	r1,sp[0x10]
80008824:	0e 99       	mov	r9,r7
80008826:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000882a:	40 3c       	lddsp	r12,sp[0xc]
8000882c:	58 0c       	cp.w	r12,0
8000882e:	c1 d0       	breq	80008868 <_vfprintf_r+0xfa8>
80008830:	10 36       	cp.w	r6,r8
80008832:	c0 64       	brge	8000883e <_vfprintf_r+0xf7e>
80008834:	fa cb f9 44 	sub	r11,sp,-1724
80008838:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000883c:	c1 d8       	rjmp	80008876 <_vfprintf_r+0xfb6>
8000883e:	fa c8 f9 50 	sub	r8,sp,-1712
80008842:	1a d8       	st.w	--sp,r8
80008844:	fa c8 fa b8 	sub	r8,sp,-1352
80008848:	1a d8       	st.w	--sp,r8
8000884a:	fa c8 fb b4 	sub	r8,sp,-1100
8000884e:	1a d8       	st.w	--sp,r8
80008850:	fa c9 ff b4 	sub	r9,sp,-76
80008854:	fa c8 f9 40 	sub	r8,sp,-1728
80008858:	04 9a       	mov	r10,r2
8000885a:	0c 9b       	mov	r11,r6
8000885c:	08 9c       	mov	r12,r4
8000885e:	fe b0 f6 93 	rcall	80007584 <get_arg>
80008862:	2f dd       	sub	sp,-12
80008864:	78 09       	ld.w	r9,r12[0x0]
80008866:	c2 18       	rjmp	800088a8 <_vfprintf_r+0xfe8>
80008868:	2f f7       	sub	r7,-1
8000886a:	10 39       	cp.w	r9,r8
8000886c:	c0 84       	brge	8000887c <_vfprintf_r+0xfbc>
8000886e:	fa ca f9 44 	sub	r10,sp,-1724
80008872:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008876:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000887a:	c1 78       	rjmp	800088a8 <_vfprintf_r+0xfe8>
8000887c:	41 09       	lddsp	r9,sp[0x40]
8000887e:	59 f8       	cp.w	r8,31
80008880:	e0 89 00 10 	brgt	800088a0 <_vfprintf_r+0xfe0>
80008884:	f2 ca ff fc 	sub	r10,r9,-4
80008888:	51 0a       	stdsp	sp[0x40],r10
8000888a:	fa c6 f9 44 	sub	r6,sp,-1724
8000888e:	72 09       	ld.w	r9,r9[0x0]
80008890:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008894:	f5 49 fd 88 	st.w	r10[-632],r9
80008898:	2f f8       	sub	r8,-1
8000889a:	fb 48 06 b4 	st.w	sp[1716],r8
8000889e:	c0 58       	rjmp	800088a8 <_vfprintf_r+0xfe8>
800088a0:	f2 c8 ff fc 	sub	r8,r9,-4
800088a4:	51 08       	stdsp	sp[0x40],r8
800088a6:	72 09       	ld.w	r9,r9[0x0]
800088a8:	33 08       	mov	r8,48
800088aa:	fb 68 06 b8 	st.b	sp[1720],r8
800088ae:	37 88       	mov	r8,120
800088b0:	30 0e       	mov	lr,0
800088b2:	fb 68 06 b9 	st.b	sp[1721],r8
800088b6:	4c ac       	lddpc	r12,800089dc <_vfprintf_r+0x111c>
800088b8:	50 19       	stdsp	sp[0x4],r9
800088ba:	a1 b5       	sbr	r5,0x1
800088bc:	50 0e       	stdsp	sp[0x0],lr
800088be:	50 dc       	stdsp	sp[0x34],r12
800088c0:	30 28       	mov	r8,2
800088c2:	37 80       	mov	r0,120
800088c4:	e0 8f 02 a4 	bral	80008e0c <_vfprintf_r+0x154c>
800088c8:	50 a7       	stdsp	sp[0x28],r7
800088ca:	50 80       	stdsp	sp[0x20],r0
800088cc:	10 90       	mov	r0,r8
800088ce:	30 08       	mov	r8,0
800088d0:	fb 68 06 bb 	st.b	sp[1723],r8
800088d4:	0c 97       	mov	r7,r6
800088d6:	04 94       	mov	r4,r2
800088d8:	06 96       	mov	r6,r3
800088da:	02 92       	mov	r2,r1
800088dc:	40 93       	lddsp	r3,sp[0x24]
800088de:	40 41       	lddsp	r1,sp[0x10]
800088e0:	0e 99       	mov	r9,r7
800088e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088e6:	40 3b       	lddsp	r11,sp[0xc]
800088e8:	58 0b       	cp.w	r11,0
800088ea:	c1 d0       	breq	80008924 <_vfprintf_r+0x1064>
800088ec:	10 36       	cp.w	r6,r8
800088ee:	c0 64       	brge	800088fa <_vfprintf_r+0x103a>
800088f0:	fa ca f9 44 	sub	r10,sp,-1724
800088f4:	f4 06 00 36 	add	r6,r10,r6<<0x3
800088f8:	c1 d8       	rjmp	80008932 <_vfprintf_r+0x1072>
800088fa:	fa c8 f9 50 	sub	r8,sp,-1712
800088fe:	1a d8       	st.w	--sp,r8
80008900:	fa c8 fa b8 	sub	r8,sp,-1352
80008904:	1a d8       	st.w	--sp,r8
80008906:	fa c8 fb b4 	sub	r8,sp,-1100
8000890a:	0c 9b       	mov	r11,r6
8000890c:	1a d8       	st.w	--sp,r8
8000890e:	04 9a       	mov	r10,r2
80008910:	fa c8 f9 40 	sub	r8,sp,-1728
80008914:	fa c9 ff b4 	sub	r9,sp,-76
80008918:	08 9c       	mov	r12,r4
8000891a:	fe b0 f6 35 	rcall	80007584 <get_arg>
8000891e:	2f dd       	sub	sp,-12
80008920:	78 06       	ld.w	r6,r12[0x0]
80008922:	c2 08       	rjmp	80008962 <_vfprintf_r+0x10a2>
80008924:	2f f7       	sub	r7,-1
80008926:	10 39       	cp.w	r9,r8
80008928:	c0 84       	brge	80008938 <_vfprintf_r+0x1078>
8000892a:	fa c9 f9 44 	sub	r9,sp,-1724
8000892e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008932:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008936:	c1 68       	rjmp	80008962 <_vfprintf_r+0x10a2>
80008938:	41 09       	lddsp	r9,sp[0x40]
8000893a:	59 f8       	cp.w	r8,31
8000893c:	e0 89 00 10 	brgt	8000895c <_vfprintf_r+0x109c>
80008940:	f2 ca ff fc 	sub	r10,r9,-4
80008944:	51 0a       	stdsp	sp[0x40],r10
80008946:	72 06       	ld.w	r6,r9[0x0]
80008948:	fa ce f9 44 	sub	lr,sp,-1724
8000894c:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008950:	f3 46 fd 88 	st.w	r9[-632],r6
80008954:	2f f8       	sub	r8,-1
80008956:	fb 48 06 b4 	st.w	sp[1716],r8
8000895a:	c0 48       	rjmp	80008962 <_vfprintf_r+0x10a2>
8000895c:	72 06       	ld.w	r6,r9[0x0]
8000895e:	2f c9       	sub	r9,-4
80008960:	51 09       	stdsp	sp[0x40],r9
80008962:	40 2c       	lddsp	r12,sp[0x8]
80008964:	58 0c       	cp.w	r12,0
80008966:	c1 05       	brlt	80008986 <_vfprintf_r+0x10c6>
80008968:	18 9a       	mov	r10,r12
8000896a:	30 0b       	mov	r11,0
8000896c:	0c 9c       	mov	r12,r6
8000896e:	e0 a0 12 43 	rcall	8000adf4 <memchr>
80008972:	e0 80 02 e0 	breq	80008f32 <_vfprintf_r+0x1672>
80008976:	f8 06 01 02 	sub	r2,r12,r6
8000897a:	40 2b       	lddsp	r11,sp[0x8]
8000897c:	16 32       	cp.w	r2,r11
8000897e:	e0 89 02 da 	brgt	80008f32 <_vfprintf_r+0x1672>
80008982:	e0 8f 02 d5 	bral	80008f2c <_vfprintf_r+0x166c>
80008986:	30 0a       	mov	r10,0
80008988:	0c 9c       	mov	r12,r6
8000898a:	50 2a       	stdsp	sp[0x8],r10
8000898c:	fe b0 f5 76 	rcall	80007478 <strlen>
80008990:	18 92       	mov	r2,r12
80008992:	e0 8f 02 d3 	bral	80008f38 <_vfprintf_r+0x1678>
80008996:	50 a7       	stdsp	sp[0x28],r7
80008998:	50 80       	stdsp	sp[0x20],r0
8000899a:	0c 97       	mov	r7,r6
8000899c:	04 94       	mov	r4,r2
8000899e:	06 96       	mov	r6,r3
800089a0:	02 92       	mov	r2,r1
800089a2:	40 93       	lddsp	r3,sp[0x24]
800089a4:	10 90       	mov	r0,r8
800089a6:	40 41       	lddsp	r1,sp[0x10]
800089a8:	a5 a5       	sbr	r5,0x4
800089aa:	c0 a8       	rjmp	800089be <_vfprintf_r+0x10fe>
800089ac:	50 a7       	stdsp	sp[0x28],r7
800089ae:	50 80       	stdsp	sp[0x20],r0
800089b0:	0c 97       	mov	r7,r6
800089b2:	04 94       	mov	r4,r2
800089b4:	06 96       	mov	r6,r3
800089b6:	02 92       	mov	r2,r1
800089b8:	40 93       	lddsp	r3,sp[0x24]
800089ba:	10 90       	mov	r0,r8
800089bc:	40 41       	lddsp	r1,sp[0x10]
800089be:	ed b5 00 05 	bld	r5,0x5
800089c2:	c5 71       	brne	80008a70 <_vfprintf_r+0x11b0>
800089c4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089c8:	40 39       	lddsp	r9,sp[0xc]
800089ca:	58 09       	cp.w	r9,0
800089cc:	c2 20       	breq	80008a10 <_vfprintf_r+0x1150>
800089ce:	10 36       	cp.w	r6,r8
800089d0:	c0 84       	brge	800089e0 <_vfprintf_r+0x1120>
800089d2:	fa c8 f9 44 	sub	r8,sp,-1724
800089d6:	f0 06 00 36 	add	r6,r8,r6<<0x3
800089da:	c2 48       	rjmp	80008a22 <_vfprintf_r+0x1162>
800089dc:	80 01       	ld.sh	r1,r0[0x0]
800089de:	5f d0       	srvc	r0
800089e0:	fa c8 f9 50 	sub	r8,sp,-1712
800089e4:	1a d8       	st.w	--sp,r8
800089e6:	fa c8 fa b8 	sub	r8,sp,-1352
800089ea:	1a d8       	st.w	--sp,r8
800089ec:	fa c8 fb b4 	sub	r8,sp,-1100
800089f0:	1a d8       	st.w	--sp,r8
800089f2:	fa c8 f9 40 	sub	r8,sp,-1728
800089f6:	fa c9 ff b4 	sub	r9,sp,-76
800089fa:	04 9a       	mov	r10,r2
800089fc:	0c 9b       	mov	r11,r6
800089fe:	08 9c       	mov	r12,r4
80008a00:	fe b0 f5 c2 	rcall	80007584 <get_arg>
80008a04:	2f dd       	sub	sp,-12
80008a06:	f8 e8 00 00 	ld.d	r8,r12[0]
80008a0a:	fa e9 00 00 	st.d	sp[0],r8
80008a0e:	c2 e8       	rjmp	80008a6a <_vfprintf_r+0x11aa>
80008a10:	ee ca ff ff 	sub	r10,r7,-1
80008a14:	10 37       	cp.w	r7,r8
80008a16:	c0 b4       	brge	80008a2c <_vfprintf_r+0x116c>
80008a18:	fa c8 f9 44 	sub	r8,sp,-1724
80008a1c:	14 97       	mov	r7,r10
80008a1e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008a22:	ec ea fd 88 	ld.d	r10,r6[-632]
80008a26:	fa eb 00 00 	st.d	sp[0],r10
80008a2a:	c2 08       	rjmp	80008a6a <_vfprintf_r+0x11aa>
80008a2c:	41 09       	lddsp	r9,sp[0x40]
80008a2e:	59 f8       	cp.w	r8,31
80008a30:	e0 89 00 16 	brgt	80008a5c <_vfprintf_r+0x119c>
80008a34:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a38:	f2 cb ff f8 	sub	r11,r9,-8
80008a3c:	fa e7 00 00 	st.d	sp[0],r6
80008a40:	51 0b       	stdsp	sp[0x40],r11
80008a42:	fa c6 f9 44 	sub	r6,sp,-1724
80008a46:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a4a:	fa e6 00 00 	ld.d	r6,sp[0]
80008a4e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008a52:	2f f8       	sub	r8,-1
80008a54:	14 97       	mov	r7,r10
80008a56:	fb 48 06 b4 	st.w	sp[1716],r8
80008a5a:	c0 88       	rjmp	80008a6a <_vfprintf_r+0x11aa>
80008a5c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a60:	2f 89       	sub	r9,-8
80008a62:	fa e7 00 00 	st.d	sp[0],r6
80008a66:	51 09       	stdsp	sp[0x40],r9
80008a68:	14 97       	mov	r7,r10
80008a6a:	30 18       	mov	r8,1
80008a6c:	e0 8f 01 d0 	bral	80008e0c <_vfprintf_r+0x154c>
80008a70:	ed b5 00 04 	bld	r5,0x4
80008a74:	c1 61       	brne	80008aa0 <_vfprintf_r+0x11e0>
80008a76:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a7a:	40 3e       	lddsp	lr,sp[0xc]
80008a7c:	58 0e       	cp.w	lr,0
80008a7e:	c0 80       	breq	80008a8e <_vfprintf_r+0x11ce>
80008a80:	10 36       	cp.w	r6,r8
80008a82:	c6 74       	brge	80008b50 <_vfprintf_r+0x1290>
80008a84:	fa cc f9 44 	sub	r12,sp,-1724
80008a88:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a8c:	c8 08       	rjmp	80008b8c <_vfprintf_r+0x12cc>
80008a8e:	ee ca ff ff 	sub	r10,r7,-1
80008a92:	10 37       	cp.w	r7,r8
80008a94:	c7 f4       	brge	80008b92 <_vfprintf_r+0x12d2>
80008a96:	fa cb f9 44 	sub	r11,sp,-1724
80008a9a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a9e:	c7 68       	rjmp	80008b8a <_vfprintf_r+0x12ca>
80008aa0:	ed b5 00 06 	bld	r5,0x6
80008aa4:	c4 a1       	brne	80008b38 <_vfprintf_r+0x1278>
80008aa6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008aaa:	40 3c       	lddsp	r12,sp[0xc]
80008aac:	58 0c       	cp.w	r12,0
80008aae:	c1 d0       	breq	80008ae8 <_vfprintf_r+0x1228>
80008ab0:	10 36       	cp.w	r6,r8
80008ab2:	c0 64       	brge	80008abe <_vfprintf_r+0x11fe>
80008ab4:	fa cb f9 44 	sub	r11,sp,-1724
80008ab8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008abc:	c1 f8       	rjmp	80008afa <_vfprintf_r+0x123a>
80008abe:	fa c8 f9 50 	sub	r8,sp,-1712
80008ac2:	1a d8       	st.w	--sp,r8
80008ac4:	fa c8 fa b8 	sub	r8,sp,-1352
80008ac8:	1a d8       	st.w	--sp,r8
80008aca:	fa c8 fb b4 	sub	r8,sp,-1100
80008ace:	1a d8       	st.w	--sp,r8
80008ad0:	fa c8 f9 40 	sub	r8,sp,-1728
80008ad4:	fa c9 ff b4 	sub	r9,sp,-76
80008ad8:	04 9a       	mov	r10,r2
80008ada:	0c 9b       	mov	r11,r6
80008adc:	08 9c       	mov	r12,r4
80008ade:	fe b0 f5 53 	rcall	80007584 <get_arg>
80008ae2:	2f dd       	sub	sp,-12
80008ae4:	98 18       	ld.sh	r8,r12[0x2]
80008ae6:	c2 68       	rjmp	80008b32 <_vfprintf_r+0x1272>
80008ae8:	ee ca ff ff 	sub	r10,r7,-1
80008aec:	10 37       	cp.w	r7,r8
80008aee:	c0 94       	brge	80008b00 <_vfprintf_r+0x1240>
80008af0:	fa c9 f9 44 	sub	r9,sp,-1724
80008af4:	14 97       	mov	r7,r10
80008af6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008afa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008afe:	c1 a8       	rjmp	80008b32 <_vfprintf_r+0x1272>
80008b00:	41 09       	lddsp	r9,sp[0x40]
80008b02:	59 f8       	cp.w	r8,31
80008b04:	e0 89 00 13 	brgt	80008b2a <_vfprintf_r+0x126a>
80008b08:	f2 cb ff fc 	sub	r11,r9,-4
80008b0c:	51 0b       	stdsp	sp[0x40],r11
80008b0e:	72 09       	ld.w	r9,r9[0x0]
80008b10:	fa c6 f9 44 	sub	r6,sp,-1724
80008b14:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008b18:	2f f8       	sub	r8,-1
80008b1a:	f7 49 fd 88 	st.w	r11[-632],r9
80008b1e:	fb 48 06 b4 	st.w	sp[1716],r8
80008b22:	14 97       	mov	r7,r10
80008b24:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008b28:	c0 58       	rjmp	80008b32 <_vfprintf_r+0x1272>
80008b2a:	92 18       	ld.sh	r8,r9[0x2]
80008b2c:	14 97       	mov	r7,r10
80008b2e:	2f c9       	sub	r9,-4
80008b30:	51 09       	stdsp	sp[0x40],r9
80008b32:	5c 78       	castu.h	r8
80008b34:	50 18       	stdsp	sp[0x4],r8
80008b36:	c4 68       	rjmp	80008bc2 <_vfprintf_r+0x1302>
80008b38:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b3c:	40 3c       	lddsp	r12,sp[0xc]
80008b3e:	58 0c       	cp.w	r12,0
80008b40:	c1 d0       	breq	80008b7a <_vfprintf_r+0x12ba>
80008b42:	10 36       	cp.w	r6,r8
80008b44:	c0 64       	brge	80008b50 <_vfprintf_r+0x1290>
80008b46:	fa cb f9 44 	sub	r11,sp,-1724
80008b4a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b4e:	c1 f8       	rjmp	80008b8c <_vfprintf_r+0x12cc>
80008b50:	fa c8 f9 50 	sub	r8,sp,-1712
80008b54:	1a d8       	st.w	--sp,r8
80008b56:	fa c8 fa b8 	sub	r8,sp,-1352
80008b5a:	0c 9b       	mov	r11,r6
80008b5c:	1a d8       	st.w	--sp,r8
80008b5e:	fa c8 fb b4 	sub	r8,sp,-1100
80008b62:	04 9a       	mov	r10,r2
80008b64:	1a d8       	st.w	--sp,r8
80008b66:	08 9c       	mov	r12,r4
80008b68:	fa c8 f9 40 	sub	r8,sp,-1728
80008b6c:	fa c9 ff b4 	sub	r9,sp,-76
80008b70:	fe b0 f5 0a 	rcall	80007584 <get_arg>
80008b74:	2f dd       	sub	sp,-12
80008b76:	78 0b       	ld.w	r11,r12[0x0]
80008b78:	c2 48       	rjmp	80008bc0 <_vfprintf_r+0x1300>
80008b7a:	ee ca ff ff 	sub	r10,r7,-1
80008b7e:	10 37       	cp.w	r7,r8
80008b80:	c0 94       	brge	80008b92 <_vfprintf_r+0x12d2>
80008b82:	fa c9 f9 44 	sub	r9,sp,-1724
80008b86:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b8a:	14 97       	mov	r7,r10
80008b8c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008b90:	c1 88       	rjmp	80008bc0 <_vfprintf_r+0x1300>
80008b92:	41 09       	lddsp	r9,sp[0x40]
80008b94:	59 f8       	cp.w	r8,31
80008b96:	e0 89 00 11 	brgt	80008bb8 <_vfprintf_r+0x12f8>
80008b9a:	f2 cb ff fc 	sub	r11,r9,-4
80008b9e:	51 0b       	stdsp	sp[0x40],r11
80008ba0:	fa c6 f9 44 	sub	r6,sp,-1724
80008ba4:	72 0b       	ld.w	r11,r9[0x0]
80008ba6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008baa:	f3 4b fd 88 	st.w	r9[-632],r11
80008bae:	2f f8       	sub	r8,-1
80008bb0:	14 97       	mov	r7,r10
80008bb2:	fb 48 06 b4 	st.w	sp[1716],r8
80008bb6:	c0 58       	rjmp	80008bc0 <_vfprintf_r+0x1300>
80008bb8:	72 0b       	ld.w	r11,r9[0x0]
80008bba:	14 97       	mov	r7,r10
80008bbc:	2f c9       	sub	r9,-4
80008bbe:	51 09       	stdsp	sp[0x40],r9
80008bc0:	50 1b       	stdsp	sp[0x4],r11
80008bc2:	30 0e       	mov	lr,0
80008bc4:	30 18       	mov	r8,1
80008bc6:	50 0e       	stdsp	sp[0x0],lr
80008bc8:	c2 29       	rjmp	80008e0c <_vfprintf_r+0x154c>
80008bca:	50 a7       	stdsp	sp[0x28],r7
80008bcc:	50 80       	stdsp	sp[0x20],r0
80008bce:	0c 97       	mov	r7,r6
80008bd0:	04 94       	mov	r4,r2
80008bd2:	06 96       	mov	r6,r3
80008bd4:	02 92       	mov	r2,r1
80008bd6:	4d 3c       	lddpc	r12,80008d20 <_vfprintf_r+0x1460>
80008bd8:	40 93       	lddsp	r3,sp[0x24]
80008bda:	10 90       	mov	r0,r8
80008bdc:	40 41       	lddsp	r1,sp[0x10]
80008bde:	50 dc       	stdsp	sp[0x34],r12
80008be0:	ed b5 00 05 	bld	r5,0x5
80008be4:	c5 51       	brne	80008c8e <_vfprintf_r+0x13ce>
80008be6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008bea:	40 3b       	lddsp	r11,sp[0xc]
80008bec:	58 0b       	cp.w	r11,0
80008bee:	c2 20       	breq	80008c32 <_vfprintf_r+0x1372>
80008bf0:	10 36       	cp.w	r6,r8
80008bf2:	c0 a4       	brge	80008c06 <_vfprintf_r+0x1346>
80008bf4:	fa ca f9 44 	sub	r10,sp,-1724
80008bf8:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008bfc:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008c00:	fa e9 00 00 	st.d	sp[0],r8
80008c04:	cf 38       	rjmp	80008dea <_vfprintf_r+0x152a>
80008c06:	fa c8 f9 50 	sub	r8,sp,-1712
80008c0a:	1a d8       	st.w	--sp,r8
80008c0c:	fa c8 fa b8 	sub	r8,sp,-1352
80008c10:	04 9a       	mov	r10,r2
80008c12:	1a d8       	st.w	--sp,r8
80008c14:	0c 9b       	mov	r11,r6
80008c16:	fa c8 fb b4 	sub	r8,sp,-1100
80008c1a:	08 9c       	mov	r12,r4
80008c1c:	1a d8       	st.w	--sp,r8
80008c1e:	fa c8 f9 40 	sub	r8,sp,-1728
80008c22:	fa c9 ff b4 	sub	r9,sp,-76
80008c26:	fe b0 f4 af 	rcall	80007584 <get_arg>
80008c2a:	2f dd       	sub	sp,-12
80008c2c:	f8 ea 00 00 	ld.d	r10,r12[0]
80008c30:	c0 c8       	rjmp	80008c48 <_vfprintf_r+0x1388>
80008c32:	ee ca ff ff 	sub	r10,r7,-1
80008c36:	10 37       	cp.w	r7,r8
80008c38:	c0 b4       	brge	80008c4e <_vfprintf_r+0x138e>
80008c3a:	fa c9 f9 44 	sub	r9,sp,-1724
80008c3e:	14 97       	mov	r7,r10
80008c40:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008c44:	ec ea fd 88 	ld.d	r10,r6[-632]
80008c48:	fa eb 00 00 	st.d	sp[0],r10
80008c4c:	cc f8       	rjmp	80008dea <_vfprintf_r+0x152a>
80008c4e:	41 09       	lddsp	r9,sp[0x40]
80008c50:	59 f8       	cp.w	r8,31
80008c52:	e0 89 00 16 	brgt	80008c7e <_vfprintf_r+0x13be>
80008c56:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c5a:	f2 cb ff f8 	sub	r11,r9,-8
80008c5e:	fa e7 00 00 	st.d	sp[0],r6
80008c62:	51 0b       	stdsp	sp[0x40],r11
80008c64:	fa c6 f9 44 	sub	r6,sp,-1724
80008c68:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008c6c:	fa e6 00 00 	ld.d	r6,sp[0]
80008c70:	f2 e7 fd 88 	st.d	r9[-632],r6
80008c74:	2f f8       	sub	r8,-1
80008c76:	14 97       	mov	r7,r10
80008c78:	fb 48 06 b4 	st.w	sp[1716],r8
80008c7c:	cb 78       	rjmp	80008dea <_vfprintf_r+0x152a>
80008c7e:	f2 e6 00 00 	ld.d	r6,r9[0]
80008c82:	2f 89       	sub	r9,-8
80008c84:	fa e7 00 00 	st.d	sp[0],r6
80008c88:	51 09       	stdsp	sp[0x40],r9
80008c8a:	14 97       	mov	r7,r10
80008c8c:	ca f8       	rjmp	80008dea <_vfprintf_r+0x152a>
80008c8e:	ed b5 00 04 	bld	r5,0x4
80008c92:	c1 71       	brne	80008cc0 <_vfprintf_r+0x1400>
80008c94:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c98:	40 3e       	lddsp	lr,sp[0xc]
80008c9a:	58 0e       	cp.w	lr,0
80008c9c:	c0 80       	breq	80008cac <_vfprintf_r+0x13ec>
80008c9e:	10 36       	cp.w	r6,r8
80008ca0:	c6 a4       	brge	80008d74 <_vfprintf_r+0x14b4>
80008ca2:	fa cc f9 44 	sub	r12,sp,-1724
80008ca6:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008caa:	c8 38       	rjmp	80008db0 <_vfprintf_r+0x14f0>
80008cac:	ee ca ff ff 	sub	r10,r7,-1
80008cb0:	10 37       	cp.w	r7,r8
80008cb2:	e0 84 00 82 	brge	80008db6 <_vfprintf_r+0x14f6>
80008cb6:	fa cb f9 44 	sub	r11,sp,-1724
80008cba:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cbe:	c7 88       	rjmp	80008dae <_vfprintf_r+0x14ee>
80008cc0:	ed b5 00 06 	bld	r5,0x6
80008cc4:	c4 c1       	brne	80008d5c <_vfprintf_r+0x149c>
80008cc6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cca:	40 3c       	lddsp	r12,sp[0xc]
80008ccc:	58 0c       	cp.w	r12,0
80008cce:	c1 d0       	breq	80008d08 <_vfprintf_r+0x1448>
80008cd0:	10 36       	cp.w	r6,r8
80008cd2:	c0 64       	brge	80008cde <_vfprintf_r+0x141e>
80008cd4:	fa cb f9 44 	sub	r11,sp,-1724
80008cd8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008cdc:	c1 f8       	rjmp	80008d1a <_vfprintf_r+0x145a>
80008cde:	fa c8 f9 50 	sub	r8,sp,-1712
80008ce2:	1a d8       	st.w	--sp,r8
80008ce4:	fa c8 fa b8 	sub	r8,sp,-1352
80008ce8:	1a d8       	st.w	--sp,r8
80008cea:	fa c8 fb b4 	sub	r8,sp,-1100
80008cee:	1a d8       	st.w	--sp,r8
80008cf0:	fa c8 f9 40 	sub	r8,sp,-1728
80008cf4:	fa c9 ff b4 	sub	r9,sp,-76
80008cf8:	04 9a       	mov	r10,r2
80008cfa:	0c 9b       	mov	r11,r6
80008cfc:	08 9c       	mov	r12,r4
80008cfe:	fe b0 f4 43 	rcall	80007584 <get_arg>
80008d02:	2f dd       	sub	sp,-12
80008d04:	98 18       	ld.sh	r8,r12[0x2]
80008d06:	c2 88       	rjmp	80008d56 <_vfprintf_r+0x1496>
80008d08:	ee ca ff ff 	sub	r10,r7,-1
80008d0c:	10 37       	cp.w	r7,r8
80008d0e:	c0 b4       	brge	80008d24 <_vfprintf_r+0x1464>
80008d10:	fa c9 f9 44 	sub	r9,sp,-1724
80008d14:	14 97       	mov	r7,r10
80008d16:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d1a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008d1e:	c1 c8       	rjmp	80008d56 <_vfprintf_r+0x1496>
80008d20:	80 01       	ld.sh	r1,r0[0x0]
80008d22:	5f d0       	srvc	r0
80008d24:	41 09       	lddsp	r9,sp[0x40]
80008d26:	59 f8       	cp.w	r8,31
80008d28:	e0 89 00 13 	brgt	80008d4e <_vfprintf_r+0x148e>
80008d2c:	f2 cb ff fc 	sub	r11,r9,-4
80008d30:	51 0b       	stdsp	sp[0x40],r11
80008d32:	72 09       	ld.w	r9,r9[0x0]
80008d34:	fa c6 f9 44 	sub	r6,sp,-1724
80008d38:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d3c:	2f f8       	sub	r8,-1
80008d3e:	f7 49 fd 88 	st.w	r11[-632],r9
80008d42:	fb 48 06 b4 	st.w	sp[1716],r8
80008d46:	14 97       	mov	r7,r10
80008d48:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008d4c:	c0 58       	rjmp	80008d56 <_vfprintf_r+0x1496>
80008d4e:	92 18       	ld.sh	r8,r9[0x2]
80008d50:	14 97       	mov	r7,r10
80008d52:	2f c9       	sub	r9,-4
80008d54:	51 09       	stdsp	sp[0x40],r9
80008d56:	5c 78       	castu.h	r8
80008d58:	50 18       	stdsp	sp[0x4],r8
80008d5a:	c4 68       	rjmp	80008de6 <_vfprintf_r+0x1526>
80008d5c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d60:	40 3c       	lddsp	r12,sp[0xc]
80008d62:	58 0c       	cp.w	r12,0
80008d64:	c1 d0       	breq	80008d9e <_vfprintf_r+0x14de>
80008d66:	10 36       	cp.w	r6,r8
80008d68:	c0 64       	brge	80008d74 <_vfprintf_r+0x14b4>
80008d6a:	fa cb f9 44 	sub	r11,sp,-1724
80008d6e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d72:	c1 f8       	rjmp	80008db0 <_vfprintf_r+0x14f0>
80008d74:	fa c8 f9 50 	sub	r8,sp,-1712
80008d78:	1a d8       	st.w	--sp,r8
80008d7a:	fa c8 fa b8 	sub	r8,sp,-1352
80008d7e:	0c 9b       	mov	r11,r6
80008d80:	1a d8       	st.w	--sp,r8
80008d82:	fa c8 fb b4 	sub	r8,sp,-1100
80008d86:	04 9a       	mov	r10,r2
80008d88:	1a d8       	st.w	--sp,r8
80008d8a:	08 9c       	mov	r12,r4
80008d8c:	fa c8 f9 40 	sub	r8,sp,-1728
80008d90:	fa c9 ff b4 	sub	r9,sp,-76
80008d94:	fe b0 f3 f8 	rcall	80007584 <get_arg>
80008d98:	2f dd       	sub	sp,-12
80008d9a:	78 0b       	ld.w	r11,r12[0x0]
80008d9c:	c2 48       	rjmp	80008de4 <_vfprintf_r+0x1524>
80008d9e:	ee ca ff ff 	sub	r10,r7,-1
80008da2:	10 37       	cp.w	r7,r8
80008da4:	c0 94       	brge	80008db6 <_vfprintf_r+0x14f6>
80008da6:	fa c9 f9 44 	sub	r9,sp,-1724
80008daa:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008dae:	14 97       	mov	r7,r10
80008db0:	ec fb fd 88 	ld.w	r11,r6[-632]
80008db4:	c1 88       	rjmp	80008de4 <_vfprintf_r+0x1524>
80008db6:	41 09       	lddsp	r9,sp[0x40]
80008db8:	59 f8       	cp.w	r8,31
80008dba:	e0 89 00 11 	brgt	80008ddc <_vfprintf_r+0x151c>
80008dbe:	f2 cb ff fc 	sub	r11,r9,-4
80008dc2:	51 0b       	stdsp	sp[0x40],r11
80008dc4:	fa c6 f9 44 	sub	r6,sp,-1724
80008dc8:	72 0b       	ld.w	r11,r9[0x0]
80008dca:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008dce:	f3 4b fd 88 	st.w	r9[-632],r11
80008dd2:	2f f8       	sub	r8,-1
80008dd4:	14 97       	mov	r7,r10
80008dd6:	fb 48 06 b4 	st.w	sp[1716],r8
80008dda:	c0 58       	rjmp	80008de4 <_vfprintf_r+0x1524>
80008ddc:	72 0b       	ld.w	r11,r9[0x0]
80008dde:	14 97       	mov	r7,r10
80008de0:	2f c9       	sub	r9,-4
80008de2:	51 09       	stdsp	sp[0x40],r9
80008de4:	50 1b       	stdsp	sp[0x4],r11
80008de6:	30 0e       	mov	lr,0
80008de8:	50 0e       	stdsp	sp[0x0],lr
80008dea:	40 08       	lddsp	r8,sp[0x0]
80008dec:	40 1c       	lddsp	r12,sp[0x4]
80008dee:	18 48       	or	r8,r12
80008df0:	5f 19       	srne	r9
80008df2:	0a 98       	mov	r8,r5
80008df4:	eb e9 00 09 	and	r9,r5,r9
80008df8:	a1 b8       	sbr	r8,0x1
80008dfa:	58 09       	cp.w	r9,0
80008dfc:	c0 70       	breq	80008e0a <_vfprintf_r+0x154a>
80008dfe:	10 95       	mov	r5,r8
80008e00:	fb 60 06 b9 	st.b	sp[1721],r0
80008e04:	33 08       	mov	r8,48
80008e06:	fb 68 06 b8 	st.b	sp[1720],r8
80008e0a:	30 28       	mov	r8,2
80008e0c:	30 09       	mov	r9,0
80008e0e:	fb 69 06 bb 	st.b	sp[1723],r9
80008e12:	0a 99       	mov	r9,r5
80008e14:	a7 d9       	cbr	r9,0x7
80008e16:	40 2b       	lddsp	r11,sp[0x8]
80008e18:	40 16       	lddsp	r6,sp[0x4]
80008e1a:	58 0b       	cp.w	r11,0
80008e1c:	5f 1a       	srne	r10
80008e1e:	f2 05 17 40 	movge	r5,r9
80008e22:	fa c2 f9 78 	sub	r2,sp,-1672
80008e26:	40 09       	lddsp	r9,sp[0x0]
80008e28:	0c 49       	or	r9,r6
80008e2a:	5f 19       	srne	r9
80008e2c:	f5 e9 10 09 	or	r9,r10,r9
80008e30:	c5 c0       	breq	80008ee8 <_vfprintf_r+0x1628>
80008e32:	30 19       	mov	r9,1
80008e34:	f2 08 18 00 	cp.b	r8,r9
80008e38:	c0 60       	breq	80008e44 <_vfprintf_r+0x1584>
80008e3a:	30 29       	mov	r9,2
80008e3c:	f2 08 18 00 	cp.b	r8,r9
80008e40:	c0 41       	brne	80008e48 <_vfprintf_r+0x1588>
80008e42:	c3 c8       	rjmp	80008eba <_vfprintf_r+0x15fa>
80008e44:	04 96       	mov	r6,r2
80008e46:	c3 08       	rjmp	80008ea6 <_vfprintf_r+0x15e6>
80008e48:	04 96       	mov	r6,r2
80008e4a:	fa e8 00 00 	ld.d	r8,sp[0]
80008e4e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008e52:	2d 0a       	sub	r10,-48
80008e54:	0c fa       	st.b	--r6,r10
80008e56:	f0 0b 16 03 	lsr	r11,r8,0x3
80008e5a:	f2 0c 16 03 	lsr	r12,r9,0x3
80008e5e:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008e62:	18 99       	mov	r9,r12
80008e64:	16 98       	mov	r8,r11
80008e66:	58 08       	cp.w	r8,0
80008e68:	5c 29       	cpc	r9
80008e6a:	cf 21       	brne	80008e4e <_vfprintf_r+0x158e>
80008e6c:	fa e9 00 00 	st.d	sp[0],r8
80008e70:	ed b5 00 00 	bld	r5,0x0
80008e74:	c4 51       	brne	80008efe <_vfprintf_r+0x163e>
80008e76:	33 09       	mov	r9,48
80008e78:	f2 0a 18 00 	cp.b	r10,r9
80008e7c:	c4 10       	breq	80008efe <_vfprintf_r+0x163e>
80008e7e:	0c f9       	st.b	--r6,r9
80008e80:	c3 f8       	rjmp	80008efe <_vfprintf_r+0x163e>
80008e82:	fa ea 00 00 	ld.d	r10,sp[0]
80008e86:	30 a8       	mov	r8,10
80008e88:	30 09       	mov	r9,0
80008e8a:	e0 a0 1a 1b 	rcall	8000c2c0 <__avr32_umod64>
80008e8e:	30 a8       	mov	r8,10
80008e90:	2d 0a       	sub	r10,-48
80008e92:	30 09       	mov	r9,0
80008e94:	ac 8a       	st.b	r6[0x0],r10
80008e96:	fa ea 00 00 	ld.d	r10,sp[0]
80008e9a:	e0 a0 18 e1 	rcall	8000c05c <__avr32_udiv64>
80008e9e:	16 99       	mov	r9,r11
80008ea0:	14 98       	mov	r8,r10
80008ea2:	fa e9 00 00 	st.d	sp[0],r8
80008ea6:	20 16       	sub	r6,1
80008ea8:	fa ea 00 00 	ld.d	r10,sp[0]
80008eac:	58 9a       	cp.w	r10,9
80008eae:	5c 2b       	cpc	r11
80008eb0:	fe 9b ff e9 	brhi	80008e82 <_vfprintf_r+0x15c2>
80008eb4:	1b f8       	ld.ub	r8,sp[0x7]
80008eb6:	2d 08       	sub	r8,-48
80008eb8:	c2 08       	rjmp	80008ef8 <_vfprintf_r+0x1638>
80008eba:	04 96       	mov	r6,r2
80008ebc:	fa e8 00 00 	ld.d	r8,sp[0]
80008ec0:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008ec4:	40 de       	lddsp	lr,sp[0x34]
80008ec6:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008eca:	0c fa       	st.b	--r6,r10
80008ecc:	f2 0b 16 04 	lsr	r11,r9,0x4
80008ed0:	f0 0a 16 04 	lsr	r10,r8,0x4
80008ed4:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008ed8:	16 99       	mov	r9,r11
80008eda:	14 98       	mov	r8,r10
80008edc:	58 08       	cp.w	r8,0
80008ede:	5c 29       	cpc	r9
80008ee0:	cf 01       	brne	80008ec0 <_vfprintf_r+0x1600>
80008ee2:	fa e9 00 00 	st.d	sp[0],r8
80008ee6:	c0 c8       	rjmp	80008efe <_vfprintf_r+0x163e>
80008ee8:	58 08       	cp.w	r8,0
80008eea:	c0 91       	brne	80008efc <_vfprintf_r+0x163c>
80008eec:	ed b5 00 00 	bld	r5,0x0
80008ef0:	c0 61       	brne	80008efc <_vfprintf_r+0x163c>
80008ef2:	fa c6 f9 79 	sub	r6,sp,-1671
80008ef6:	33 08       	mov	r8,48
80008ef8:	ac 88       	st.b	r6[0x0],r8
80008efa:	c0 28       	rjmp	80008efe <_vfprintf_r+0x163e>
80008efc:	04 96       	mov	r6,r2
80008efe:	0c 12       	sub	r2,r6
80008f00:	c1 c8       	rjmp	80008f38 <_vfprintf_r+0x1678>
80008f02:	50 a7       	stdsp	sp[0x28],r7
80008f04:	50 80       	stdsp	sp[0x20],r0
80008f06:	40 93       	lddsp	r3,sp[0x24]
80008f08:	0c 97       	mov	r7,r6
80008f0a:	10 90       	mov	r0,r8
80008f0c:	04 94       	mov	r4,r2
80008f0e:	40 41       	lddsp	r1,sp[0x10]
80008f10:	58 08       	cp.w	r8,0
80008f12:	e0 80 04 51 	breq	800097b4 <_vfprintf_r+0x1ef4>
80008f16:	fb 68 06 60 	st.b	sp[1632],r8
80008f1a:	30 0c       	mov	r12,0
80008f1c:	30 08       	mov	r8,0
80008f1e:	30 12       	mov	r2,1
80008f20:	fb 68 06 bb 	st.b	sp[1723],r8
80008f24:	50 2c       	stdsp	sp[0x8],r12
80008f26:	fa c6 f9 a0 	sub	r6,sp,-1632
80008f2a:	c0 78       	rjmp	80008f38 <_vfprintf_r+0x1678>
80008f2c:	30 0b       	mov	r11,0
80008f2e:	50 2b       	stdsp	sp[0x8],r11
80008f30:	c0 48       	rjmp	80008f38 <_vfprintf_r+0x1678>
80008f32:	40 22       	lddsp	r2,sp[0x8]
80008f34:	30 0a       	mov	r10,0
80008f36:	50 2a       	stdsp	sp[0x8],r10
80008f38:	40 29       	lddsp	r9,sp[0x8]
80008f3a:	e4 09 0c 49 	max	r9,r2,r9
80008f3e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008f42:	50 39       	stdsp	sp[0xc],r9
80008f44:	0a 9e       	mov	lr,r5
80008f46:	30 09       	mov	r9,0
80008f48:	e2 1e 00 02 	andl	lr,0x2,COH
80008f4c:	f2 08 18 00 	cp.b	r8,r9
80008f50:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008f54:	f7 b8 01 ff 	subne	r8,-1
80008f58:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008f5c:	0a 9b       	mov	r11,r5
80008f5e:	58 0e       	cp.w	lr,0
80008f60:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008f64:	f7 bc 01 fe 	subne	r12,-2
80008f68:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008f6c:	e2 1b 00 84 	andl	r11,0x84,COH
80008f70:	50 fe       	stdsp	sp[0x3c],lr
80008f72:	50 9b       	stdsp	sp[0x24],r11
80008f74:	c4 51       	brne	80008ffe <_vfprintf_r+0x173e>
80008f76:	40 8a       	lddsp	r10,sp[0x20]
80008f78:	40 39       	lddsp	r9,sp[0xc]
80008f7a:	12 1a       	sub	r10,r9
80008f7c:	50 4a       	stdsp	sp[0x10],r10
80008f7e:	58 0a       	cp.w	r10,0
80008f80:	e0 89 00 1f 	brgt	80008fbe <_vfprintf_r+0x16fe>
80008f84:	c3 d8       	rjmp	80008ffe <_vfprintf_r+0x173e>
80008f86:	2f 09       	sub	r9,-16
80008f88:	2f f8       	sub	r8,-1
80008f8a:	4c ee       	lddpc	lr,800090c0 <_vfprintf_r+0x1800>
80008f8c:	31 0c       	mov	r12,16
80008f8e:	fb 49 06 90 	st.w	sp[1680],r9
80008f92:	87 0e       	st.w	r3[0x0],lr
80008f94:	87 1c       	st.w	r3[0x4],r12
80008f96:	fb 48 06 8c 	st.w	sp[1676],r8
80008f9a:	58 78       	cp.w	r8,7
80008f9c:	e0 89 00 04 	brgt	80008fa4 <_vfprintf_r+0x16e4>
80008fa0:	2f 83       	sub	r3,-8
80008fa2:	c0 b8       	rjmp	80008fb8 <_vfprintf_r+0x16f8>
80008fa4:	fa ca f9 78 	sub	r10,sp,-1672
80008fa8:	02 9b       	mov	r11,r1
80008faa:	08 9c       	mov	r12,r4
80008fac:	fe b0 f4 7c 	rcall	800078a4 <__sprint_r>
80008fb0:	e0 81 04 13 	brne	800097d6 <_vfprintf_r+0x1f16>
80008fb4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fb8:	40 4b       	lddsp	r11,sp[0x10]
80008fba:	21 0b       	sub	r11,16
80008fbc:	50 4b       	stdsp	sp[0x10],r11
80008fbe:	fa f9 06 90 	ld.w	r9,sp[1680]
80008fc2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fc6:	4b fa       	lddpc	r10,800090c0 <_vfprintf_r+0x1800>
80008fc8:	40 4e       	lddsp	lr,sp[0x10]
80008fca:	59 0e       	cp.w	lr,16
80008fcc:	fe 99 ff dd 	brgt	80008f86 <_vfprintf_r+0x16c6>
80008fd0:	1c 09       	add	r9,lr
80008fd2:	2f f8       	sub	r8,-1
80008fd4:	87 0a       	st.w	r3[0x0],r10
80008fd6:	fb 49 06 90 	st.w	sp[1680],r9
80008fda:	87 1e       	st.w	r3[0x4],lr
80008fdc:	fb 48 06 8c 	st.w	sp[1676],r8
80008fe0:	58 78       	cp.w	r8,7
80008fe2:	e0 89 00 04 	brgt	80008fea <_vfprintf_r+0x172a>
80008fe6:	2f 83       	sub	r3,-8
80008fe8:	c0 b8       	rjmp	80008ffe <_vfprintf_r+0x173e>
80008fea:	fa ca f9 78 	sub	r10,sp,-1672
80008fee:	02 9b       	mov	r11,r1
80008ff0:	08 9c       	mov	r12,r4
80008ff2:	fe b0 f4 59 	rcall	800078a4 <__sprint_r>
80008ff6:	e0 81 03 f0 	brne	800097d6 <_vfprintf_r+0x1f16>
80008ffa:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ffe:	30 09       	mov	r9,0
80009000:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009004:	f2 08 18 00 	cp.b	r8,r9
80009008:	c1 f0       	breq	80009046 <_vfprintf_r+0x1786>
8000900a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000900e:	fa c9 f9 45 	sub	r9,sp,-1723
80009012:	2f f8       	sub	r8,-1
80009014:	87 09       	st.w	r3[0x0],r9
80009016:	fb 48 06 90 	st.w	sp[1680],r8
8000901a:	30 19       	mov	r9,1
8000901c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009020:	87 19       	st.w	r3[0x4],r9
80009022:	2f f8       	sub	r8,-1
80009024:	fb 48 06 8c 	st.w	sp[1676],r8
80009028:	58 78       	cp.w	r8,7
8000902a:	e0 89 00 04 	brgt	80009032 <_vfprintf_r+0x1772>
8000902e:	2f 83       	sub	r3,-8
80009030:	c0 b8       	rjmp	80009046 <_vfprintf_r+0x1786>
80009032:	fa ca f9 78 	sub	r10,sp,-1672
80009036:	02 9b       	mov	r11,r1
80009038:	08 9c       	mov	r12,r4
8000903a:	fe b0 f4 35 	rcall	800078a4 <__sprint_r>
8000903e:	e0 81 03 cc 	brne	800097d6 <_vfprintf_r+0x1f16>
80009042:	fa c3 f9 e0 	sub	r3,sp,-1568
80009046:	40 fc       	lddsp	r12,sp[0x3c]
80009048:	58 0c       	cp.w	r12,0
8000904a:	c1 f0       	breq	80009088 <_vfprintf_r+0x17c8>
8000904c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009050:	fa c9 f9 48 	sub	r9,sp,-1720
80009054:	2f e8       	sub	r8,-2
80009056:	87 09       	st.w	r3[0x0],r9
80009058:	fb 48 06 90 	st.w	sp[1680],r8
8000905c:	30 29       	mov	r9,2
8000905e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009062:	87 19       	st.w	r3[0x4],r9
80009064:	2f f8       	sub	r8,-1
80009066:	fb 48 06 8c 	st.w	sp[1676],r8
8000906a:	58 78       	cp.w	r8,7
8000906c:	e0 89 00 04 	brgt	80009074 <_vfprintf_r+0x17b4>
80009070:	2f 83       	sub	r3,-8
80009072:	c0 b8       	rjmp	80009088 <_vfprintf_r+0x17c8>
80009074:	fa ca f9 78 	sub	r10,sp,-1672
80009078:	02 9b       	mov	r11,r1
8000907a:	08 9c       	mov	r12,r4
8000907c:	fe b0 f4 14 	rcall	800078a4 <__sprint_r>
80009080:	e0 81 03 ab 	brne	800097d6 <_vfprintf_r+0x1f16>
80009084:	fa c3 f9 e0 	sub	r3,sp,-1568
80009088:	40 9b       	lddsp	r11,sp[0x24]
8000908a:	e0 4b 00 80 	cp.w	r11,128
8000908e:	c4 a1       	brne	80009122 <_vfprintf_r+0x1862>
80009090:	40 8a       	lddsp	r10,sp[0x20]
80009092:	40 39       	lddsp	r9,sp[0xc]
80009094:	12 1a       	sub	r10,r9
80009096:	50 4a       	stdsp	sp[0x10],r10
80009098:	58 0a       	cp.w	r10,0
8000909a:	e0 89 00 24 	brgt	800090e2 <_vfprintf_r+0x1822>
8000909e:	c4 28       	rjmp	80009122 <_vfprintf_r+0x1862>
800090a0:	2f 09       	sub	r9,-16
800090a2:	2f f8       	sub	r8,-1
800090a4:	48 8e       	lddpc	lr,800090c4 <_vfprintf_r+0x1804>
800090a6:	31 0c       	mov	r12,16
800090a8:	fb 49 06 90 	st.w	sp[1680],r9
800090ac:	87 0e       	st.w	r3[0x0],lr
800090ae:	87 1c       	st.w	r3[0x4],r12
800090b0:	fb 48 06 8c 	st.w	sp[1676],r8
800090b4:	58 78       	cp.w	r8,7
800090b6:	e0 89 00 09 	brgt	800090c8 <_vfprintf_r+0x1808>
800090ba:	2f 83       	sub	r3,-8
800090bc:	c1 08       	rjmp	800090dc <_vfprintf_r+0x181c>
800090be:	d7 03       	nop
800090c0:	80 01       	ld.sh	r1,r0[0x0]
800090c2:	5f e8       	srqs	r8
800090c4:	80 01       	ld.sh	r1,r0[0x0]
800090c6:	5f f8       	sral	r8
800090c8:	fa ca f9 78 	sub	r10,sp,-1672
800090cc:	02 9b       	mov	r11,r1
800090ce:	08 9c       	mov	r12,r4
800090d0:	fe b0 f3 ea 	rcall	800078a4 <__sprint_r>
800090d4:	e0 81 03 81 	brne	800097d6 <_vfprintf_r+0x1f16>
800090d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800090dc:	40 4b       	lddsp	r11,sp[0x10]
800090de:	21 0b       	sub	r11,16
800090e0:	50 4b       	stdsp	sp[0x10],r11
800090e2:	fa f9 06 90 	ld.w	r9,sp[1680]
800090e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090ea:	4c 6a       	lddpc	r10,80009200 <_vfprintf_r+0x1940>
800090ec:	40 4e       	lddsp	lr,sp[0x10]
800090ee:	59 0e       	cp.w	lr,16
800090f0:	fe 99 ff d8 	brgt	800090a0 <_vfprintf_r+0x17e0>
800090f4:	1c 09       	add	r9,lr
800090f6:	2f f8       	sub	r8,-1
800090f8:	87 0a       	st.w	r3[0x0],r10
800090fa:	fb 49 06 90 	st.w	sp[1680],r9
800090fe:	87 1e       	st.w	r3[0x4],lr
80009100:	fb 48 06 8c 	st.w	sp[1676],r8
80009104:	58 78       	cp.w	r8,7
80009106:	e0 89 00 04 	brgt	8000910e <_vfprintf_r+0x184e>
8000910a:	2f 83       	sub	r3,-8
8000910c:	c0 b8       	rjmp	80009122 <_vfprintf_r+0x1862>
8000910e:	fa ca f9 78 	sub	r10,sp,-1672
80009112:	02 9b       	mov	r11,r1
80009114:	08 9c       	mov	r12,r4
80009116:	fe b0 f3 c7 	rcall	800078a4 <__sprint_r>
8000911a:	e0 81 03 5e 	brne	800097d6 <_vfprintf_r+0x1f16>
8000911e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009122:	40 2c       	lddsp	r12,sp[0x8]
80009124:	04 1c       	sub	r12,r2
80009126:	50 2c       	stdsp	sp[0x8],r12
80009128:	58 0c       	cp.w	r12,0
8000912a:	e0 89 00 1f 	brgt	80009168 <_vfprintf_r+0x18a8>
8000912e:	c3 d8       	rjmp	800091a8 <_vfprintf_r+0x18e8>
80009130:	2f 09       	sub	r9,-16
80009132:	2f f8       	sub	r8,-1
80009134:	4b 3b       	lddpc	r11,80009200 <_vfprintf_r+0x1940>
80009136:	31 0a       	mov	r10,16
80009138:	fb 49 06 90 	st.w	sp[1680],r9
8000913c:	87 0b       	st.w	r3[0x0],r11
8000913e:	87 1a       	st.w	r3[0x4],r10
80009140:	fb 48 06 8c 	st.w	sp[1676],r8
80009144:	58 78       	cp.w	r8,7
80009146:	e0 89 00 04 	brgt	8000914e <_vfprintf_r+0x188e>
8000914a:	2f 83       	sub	r3,-8
8000914c:	c0 b8       	rjmp	80009162 <_vfprintf_r+0x18a2>
8000914e:	fa ca f9 78 	sub	r10,sp,-1672
80009152:	02 9b       	mov	r11,r1
80009154:	08 9c       	mov	r12,r4
80009156:	fe b0 f3 a7 	rcall	800078a4 <__sprint_r>
8000915a:	e0 81 03 3e 	brne	800097d6 <_vfprintf_r+0x1f16>
8000915e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009162:	40 29       	lddsp	r9,sp[0x8]
80009164:	21 09       	sub	r9,16
80009166:	50 29       	stdsp	sp[0x8],r9
80009168:	fa f9 06 90 	ld.w	r9,sp[1680]
8000916c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009170:	4a 4a       	lddpc	r10,80009200 <_vfprintf_r+0x1940>
80009172:	40 2e       	lddsp	lr,sp[0x8]
80009174:	59 0e       	cp.w	lr,16
80009176:	fe 99 ff dd 	brgt	80009130 <_vfprintf_r+0x1870>
8000917a:	1c 09       	add	r9,lr
8000917c:	2f f8       	sub	r8,-1
8000917e:	87 0a       	st.w	r3[0x0],r10
80009180:	fb 49 06 90 	st.w	sp[1680],r9
80009184:	87 1e       	st.w	r3[0x4],lr
80009186:	fb 48 06 8c 	st.w	sp[1676],r8
8000918a:	58 78       	cp.w	r8,7
8000918c:	e0 89 00 04 	brgt	80009194 <_vfprintf_r+0x18d4>
80009190:	2f 83       	sub	r3,-8
80009192:	c0 b8       	rjmp	800091a8 <_vfprintf_r+0x18e8>
80009194:	fa ca f9 78 	sub	r10,sp,-1672
80009198:	02 9b       	mov	r11,r1
8000919a:	08 9c       	mov	r12,r4
8000919c:	fe b0 f3 84 	rcall	800078a4 <__sprint_r>
800091a0:	e0 81 03 1b 	brne	800097d6 <_vfprintf_r+0x1f16>
800091a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800091a8:	ed b5 00 08 	bld	r5,0x8
800091ac:	c0 b0       	breq	800091c2 <_vfprintf_r+0x1902>
800091ae:	fa f8 06 90 	ld.w	r8,sp[1680]
800091b2:	87 12       	st.w	r3[0x4],r2
800091b4:	87 06       	st.w	r3[0x0],r6
800091b6:	f0 02 00 02 	add	r2,r8,r2
800091ba:	fb 42 06 90 	st.w	sp[1680],r2
800091be:	e0 8f 01 d5 	bral	80009568 <_vfprintf_r+0x1ca8>
800091c2:	e0 40 00 65 	cp.w	r0,101
800091c6:	e0 8a 01 d7 	brle	80009574 <_vfprintf_r+0x1cb4>
800091ca:	30 08       	mov	r8,0
800091cc:	30 09       	mov	r9,0
800091ce:	40 5b       	lddsp	r11,sp[0x14]
800091d0:	40 7a       	lddsp	r10,sp[0x1c]
800091d2:	e0 a0 15 3e 	rcall	8000bc4e <__avr32_f64_cmp_eq>
800091d6:	c7 a0       	breq	800092ca <_vfprintf_r+0x1a0a>
800091d8:	fa f8 06 90 	ld.w	r8,sp[1680]
800091dc:	48 a9       	lddpc	r9,80009204 <_vfprintf_r+0x1944>
800091de:	2f f8       	sub	r8,-1
800091e0:	87 09       	st.w	r3[0x0],r9
800091e2:	fb 48 06 90 	st.w	sp[1680],r8
800091e6:	30 19       	mov	r9,1
800091e8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091ec:	87 19       	st.w	r3[0x4],r9
800091ee:	2f f8       	sub	r8,-1
800091f0:	fb 48 06 8c 	st.w	sp[1676],r8
800091f4:	58 78       	cp.w	r8,7
800091f6:	e0 89 00 09 	brgt	80009208 <_vfprintf_r+0x1948>
800091fa:	2f 83       	sub	r3,-8
800091fc:	c1 08       	rjmp	8000921c <_vfprintf_r+0x195c>
800091fe:	d7 03       	nop
80009200:	80 01       	ld.sh	r1,r0[0x0]
80009202:	5f f8       	sral	r8
80009204:	80 01       	ld.sh	r1,r0[0x0]
80009206:	5f e4       	srqs	r4
80009208:	fa ca f9 78 	sub	r10,sp,-1672
8000920c:	02 9b       	mov	r11,r1
8000920e:	08 9c       	mov	r12,r4
80009210:	fe b0 f3 4a 	rcall	800078a4 <__sprint_r>
80009214:	e0 81 02 e1 	brne	800097d6 <_vfprintf_r+0x1f16>
80009218:	fa c3 f9 e0 	sub	r3,sp,-1568
8000921c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009220:	40 6c       	lddsp	r12,sp[0x18]
80009222:	18 38       	cp.w	r8,r12
80009224:	c0 55       	brlt	8000922e <_vfprintf_r+0x196e>
80009226:	ed b5 00 00 	bld	r5,0x0
8000922a:	e0 81 02 69 	brne	800096fc <_vfprintf_r+0x1e3c>
8000922e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009232:	2f f8       	sub	r8,-1
80009234:	40 cb       	lddsp	r11,sp[0x30]
80009236:	fb 48 06 90 	st.w	sp[1680],r8
8000923a:	30 19       	mov	r9,1
8000923c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009240:	87 0b       	st.w	r3[0x0],r11
80009242:	2f f8       	sub	r8,-1
80009244:	87 19       	st.w	r3[0x4],r9
80009246:	fb 48 06 8c 	st.w	sp[1676],r8
8000924a:	58 78       	cp.w	r8,7
8000924c:	e0 89 00 04 	brgt	80009254 <_vfprintf_r+0x1994>
80009250:	2f 83       	sub	r3,-8
80009252:	c0 b8       	rjmp	80009268 <_vfprintf_r+0x19a8>
80009254:	fa ca f9 78 	sub	r10,sp,-1672
80009258:	02 9b       	mov	r11,r1
8000925a:	08 9c       	mov	r12,r4
8000925c:	fe b0 f3 24 	rcall	800078a4 <__sprint_r>
80009260:	e0 81 02 bb 	brne	800097d6 <_vfprintf_r+0x1f16>
80009264:	fa c3 f9 e0 	sub	r3,sp,-1568
80009268:	40 66       	lddsp	r6,sp[0x18]
8000926a:	20 16       	sub	r6,1
8000926c:	58 06       	cp.w	r6,0
8000926e:	e0 89 00 1d 	brgt	800092a8 <_vfprintf_r+0x19e8>
80009272:	e0 8f 02 45 	bral	800096fc <_vfprintf_r+0x1e3c>
80009276:	2f 09       	sub	r9,-16
80009278:	2f f8       	sub	r8,-1
8000927a:	fb 49 06 90 	st.w	sp[1680],r9
8000927e:	87 02       	st.w	r3[0x0],r2
80009280:	87 10       	st.w	r3[0x4],r0
80009282:	fb 48 06 8c 	st.w	sp[1676],r8
80009286:	58 78       	cp.w	r8,7
80009288:	e0 89 00 04 	brgt	80009290 <_vfprintf_r+0x19d0>
8000928c:	2f 83       	sub	r3,-8
8000928e:	c0 b8       	rjmp	800092a4 <_vfprintf_r+0x19e4>
80009290:	fa ca f9 78 	sub	r10,sp,-1672
80009294:	02 9b       	mov	r11,r1
80009296:	08 9c       	mov	r12,r4
80009298:	fe b0 f3 06 	rcall	800078a4 <__sprint_r>
8000929c:	e0 81 02 9d 	brne	800097d6 <_vfprintf_r+0x1f16>
800092a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800092a4:	21 06       	sub	r6,16
800092a6:	c0 38       	rjmp	800092ac <_vfprintf_r+0x19ec>
800092a8:	4d 22       	lddpc	r2,800093f0 <_vfprintf_r+0x1b30>
800092aa:	31 00       	mov	r0,16
800092ac:	fa f9 06 90 	ld.w	r9,sp[1680]
800092b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092b4:	4c fa       	lddpc	r10,800093f0 <_vfprintf_r+0x1b30>
800092b6:	59 06       	cp.w	r6,16
800092b8:	fe 99 ff df 	brgt	80009276 <_vfprintf_r+0x19b6>
800092bc:	0c 09       	add	r9,r6
800092be:	87 0a       	st.w	r3[0x0],r10
800092c0:	fb 49 06 90 	st.w	sp[1680],r9
800092c4:	2f f8       	sub	r8,-1
800092c6:	87 16       	st.w	r3[0x4],r6
800092c8:	c5 39       	rjmp	8000956e <_vfprintf_r+0x1cae>
800092ca:	fa fa 06 ac 	ld.w	r10,sp[1708]
800092ce:	58 0a       	cp.w	r10,0
800092d0:	e0 89 00 94 	brgt	800093f8 <_vfprintf_r+0x1b38>
800092d4:	fa f8 06 90 	ld.w	r8,sp[1680]
800092d8:	4c 79       	lddpc	r9,800093f4 <_vfprintf_r+0x1b34>
800092da:	2f f8       	sub	r8,-1
800092dc:	87 09       	st.w	r3[0x0],r9
800092de:	fb 48 06 90 	st.w	sp[1680],r8
800092e2:	30 19       	mov	r9,1
800092e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092e8:	87 19       	st.w	r3[0x4],r9
800092ea:	2f f8       	sub	r8,-1
800092ec:	fb 48 06 8c 	st.w	sp[1676],r8
800092f0:	58 78       	cp.w	r8,7
800092f2:	e0 89 00 04 	brgt	800092fa <_vfprintf_r+0x1a3a>
800092f6:	2f 83       	sub	r3,-8
800092f8:	c0 b8       	rjmp	8000930e <_vfprintf_r+0x1a4e>
800092fa:	fa ca f9 78 	sub	r10,sp,-1672
800092fe:	02 9b       	mov	r11,r1
80009300:	08 9c       	mov	r12,r4
80009302:	fe b0 f2 d1 	rcall	800078a4 <__sprint_r>
80009306:	e0 81 02 68 	brne	800097d6 <_vfprintf_r+0x1f16>
8000930a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000930e:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009312:	58 08       	cp.w	r8,0
80009314:	c0 81       	brne	80009324 <_vfprintf_r+0x1a64>
80009316:	40 6a       	lddsp	r10,sp[0x18]
80009318:	58 0a       	cp.w	r10,0
8000931a:	c0 51       	brne	80009324 <_vfprintf_r+0x1a64>
8000931c:	ed b5 00 00 	bld	r5,0x0
80009320:	e0 81 01 ee 	brne	800096fc <_vfprintf_r+0x1e3c>
80009324:	40 c9       	lddsp	r9,sp[0x30]
80009326:	fa f8 06 90 	ld.w	r8,sp[1680]
8000932a:	2f f8       	sub	r8,-1
8000932c:	87 09       	st.w	r3[0x0],r9
8000932e:	fb 48 06 90 	st.w	sp[1680],r8
80009332:	30 19       	mov	r9,1
80009334:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009338:	87 19       	st.w	r3[0x4],r9
8000933a:	2f f8       	sub	r8,-1
8000933c:	fb 48 06 8c 	st.w	sp[1676],r8
80009340:	58 78       	cp.w	r8,7
80009342:	e0 89 00 04 	brgt	8000934a <_vfprintf_r+0x1a8a>
80009346:	2f 83       	sub	r3,-8
80009348:	c0 b8       	rjmp	8000935e <_vfprintf_r+0x1a9e>
8000934a:	fa ca f9 78 	sub	r10,sp,-1672
8000934e:	02 9b       	mov	r11,r1
80009350:	08 9c       	mov	r12,r4
80009352:	fe b0 f2 a9 	rcall	800078a4 <__sprint_r>
80009356:	e0 81 02 40 	brne	800097d6 <_vfprintf_r+0x1f16>
8000935a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000935e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009362:	5c 32       	neg	r2
80009364:	58 02       	cp.w	r2,0
80009366:	e0 89 00 1d 	brgt	800093a0 <_vfprintf_r+0x1ae0>
8000936a:	c3 b8       	rjmp	800093e0 <_vfprintf_r+0x1b20>
8000936c:	2f 09       	sub	r9,-16
8000936e:	2f f8       	sub	r8,-1
80009370:	31 0e       	mov	lr,16
80009372:	fb 49 06 90 	st.w	sp[1680],r9
80009376:	87 00       	st.w	r3[0x0],r0
80009378:	87 1e       	st.w	r3[0x4],lr
8000937a:	fb 48 06 8c 	st.w	sp[1676],r8
8000937e:	58 78       	cp.w	r8,7
80009380:	e0 89 00 04 	brgt	80009388 <_vfprintf_r+0x1ac8>
80009384:	2f 83       	sub	r3,-8
80009386:	c0 b8       	rjmp	8000939c <_vfprintf_r+0x1adc>
80009388:	fa ca f9 78 	sub	r10,sp,-1672
8000938c:	02 9b       	mov	r11,r1
8000938e:	08 9c       	mov	r12,r4
80009390:	fe b0 f2 8a 	rcall	800078a4 <__sprint_r>
80009394:	e0 81 02 21 	brne	800097d6 <_vfprintf_r+0x1f16>
80009398:	fa c3 f9 e0 	sub	r3,sp,-1568
8000939c:	21 02       	sub	r2,16
8000939e:	c0 28       	rjmp	800093a2 <_vfprintf_r+0x1ae2>
800093a0:	49 40       	lddpc	r0,800093f0 <_vfprintf_r+0x1b30>
800093a2:	fa f9 06 90 	ld.w	r9,sp[1680]
800093a6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093aa:	49 2a       	lddpc	r10,800093f0 <_vfprintf_r+0x1b30>
800093ac:	59 02       	cp.w	r2,16
800093ae:	fe 99 ff df 	brgt	8000936c <_vfprintf_r+0x1aac>
800093b2:	04 09       	add	r9,r2
800093b4:	2f f8       	sub	r8,-1
800093b6:	87 0a       	st.w	r3[0x0],r10
800093b8:	fb 49 06 90 	st.w	sp[1680],r9
800093bc:	87 12       	st.w	r3[0x4],r2
800093be:	fb 48 06 8c 	st.w	sp[1676],r8
800093c2:	58 78       	cp.w	r8,7
800093c4:	e0 89 00 04 	brgt	800093cc <_vfprintf_r+0x1b0c>
800093c8:	2f 83       	sub	r3,-8
800093ca:	c0 b8       	rjmp	800093e0 <_vfprintf_r+0x1b20>
800093cc:	fa ca f9 78 	sub	r10,sp,-1672
800093d0:	02 9b       	mov	r11,r1
800093d2:	08 9c       	mov	r12,r4
800093d4:	fe b0 f2 68 	rcall	800078a4 <__sprint_r>
800093d8:	e0 81 01 ff 	brne	800097d6 <_vfprintf_r+0x1f16>
800093dc:	fa c3 f9 e0 	sub	r3,sp,-1568
800093e0:	40 6c       	lddsp	r12,sp[0x18]
800093e2:	fa f8 06 90 	ld.w	r8,sp[1680]
800093e6:	87 06       	st.w	r3[0x0],r6
800093e8:	87 1c       	st.w	r3[0x4],r12
800093ea:	18 08       	add	r8,r12
800093ec:	cb c8       	rjmp	80009564 <_vfprintf_r+0x1ca4>
800093ee:	d7 03       	nop
800093f0:	80 01       	ld.sh	r1,r0[0x0]
800093f2:	5f f8       	sral	r8
800093f4:	80 01       	ld.sh	r1,r0[0x0]
800093f6:	5f e4       	srqs	r4
800093f8:	fa f9 06 90 	ld.w	r9,sp[1680]
800093fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009400:	40 6b       	lddsp	r11,sp[0x18]
80009402:	16 3a       	cp.w	r10,r11
80009404:	c6 d5       	brlt	800094de <_vfprintf_r+0x1c1e>
80009406:	16 09       	add	r9,r11
80009408:	2f f8       	sub	r8,-1
8000940a:	87 06       	st.w	r3[0x0],r6
8000940c:	fb 49 06 90 	st.w	sp[1680],r9
80009410:	87 1b       	st.w	r3[0x4],r11
80009412:	fb 48 06 8c 	st.w	sp[1676],r8
80009416:	58 78       	cp.w	r8,7
80009418:	e0 89 00 04 	brgt	80009420 <_vfprintf_r+0x1b60>
8000941c:	2f 83       	sub	r3,-8
8000941e:	c0 b8       	rjmp	80009434 <_vfprintf_r+0x1b74>
80009420:	fa ca f9 78 	sub	r10,sp,-1672
80009424:	02 9b       	mov	r11,r1
80009426:	08 9c       	mov	r12,r4
80009428:	fe b0 f2 3e 	rcall	800078a4 <__sprint_r>
8000942c:	e0 81 01 d5 	brne	800097d6 <_vfprintf_r+0x1f16>
80009430:	fa c3 f9 e0 	sub	r3,sp,-1568
80009434:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009438:	40 6a       	lddsp	r10,sp[0x18]
8000943a:	14 16       	sub	r6,r10
8000943c:	58 06       	cp.w	r6,0
8000943e:	e0 89 00 1c 	brgt	80009476 <_vfprintf_r+0x1bb6>
80009442:	c3 b8       	rjmp	800094b8 <_vfprintf_r+0x1bf8>
80009444:	2f 09       	sub	r9,-16
80009446:	2f f8       	sub	r8,-1
80009448:	fb 49 06 90 	st.w	sp[1680],r9
8000944c:	87 02       	st.w	r3[0x0],r2
8000944e:	87 10       	st.w	r3[0x4],r0
80009450:	fb 48 06 8c 	st.w	sp[1676],r8
80009454:	58 78       	cp.w	r8,7
80009456:	e0 89 00 04 	brgt	8000945e <_vfprintf_r+0x1b9e>
8000945a:	2f 83       	sub	r3,-8
8000945c:	c0 b8       	rjmp	80009472 <_vfprintf_r+0x1bb2>
8000945e:	fa ca f9 78 	sub	r10,sp,-1672
80009462:	02 9b       	mov	r11,r1
80009464:	08 9c       	mov	r12,r4
80009466:	fe b0 f2 1f 	rcall	800078a4 <__sprint_r>
8000946a:	e0 81 01 b6 	brne	800097d6 <_vfprintf_r+0x1f16>
8000946e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009472:	21 06       	sub	r6,16
80009474:	c0 38       	rjmp	8000947a <_vfprintf_r+0x1bba>
80009476:	4d c2       	lddpc	r2,800095e4 <_vfprintf_r+0x1d24>
80009478:	31 00       	mov	r0,16
8000947a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000947e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009482:	4d 9a       	lddpc	r10,800095e4 <_vfprintf_r+0x1d24>
80009484:	59 06       	cp.w	r6,16
80009486:	fe 99 ff df 	brgt	80009444 <_vfprintf_r+0x1b84>
8000948a:	0c 09       	add	r9,r6
8000948c:	2f f8       	sub	r8,-1
8000948e:	87 0a       	st.w	r3[0x0],r10
80009490:	fb 49 06 90 	st.w	sp[1680],r9
80009494:	87 16       	st.w	r3[0x4],r6
80009496:	fb 48 06 8c 	st.w	sp[1676],r8
8000949a:	58 78       	cp.w	r8,7
8000949c:	e0 89 00 04 	brgt	800094a4 <_vfprintf_r+0x1be4>
800094a0:	2f 83       	sub	r3,-8
800094a2:	c0 b8       	rjmp	800094b8 <_vfprintf_r+0x1bf8>
800094a4:	fa ca f9 78 	sub	r10,sp,-1672
800094a8:	02 9b       	mov	r11,r1
800094aa:	08 9c       	mov	r12,r4
800094ac:	fe b0 f1 fc 	rcall	800078a4 <__sprint_r>
800094b0:	e0 81 01 93 	brne	800097d6 <_vfprintf_r+0x1f16>
800094b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800094b8:	ed b5 00 00 	bld	r5,0x0
800094bc:	e0 81 01 20 	brne	800096fc <_vfprintf_r+0x1e3c>
800094c0:	40 c9       	lddsp	r9,sp[0x30]
800094c2:	fa f8 06 90 	ld.w	r8,sp[1680]
800094c6:	2f f8       	sub	r8,-1
800094c8:	87 09       	st.w	r3[0x0],r9
800094ca:	fb 48 06 90 	st.w	sp[1680],r8
800094ce:	30 19       	mov	r9,1
800094d0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094d4:	87 19       	st.w	r3[0x4],r9
800094d6:	2f f8       	sub	r8,-1
800094d8:	fb 48 06 8c 	st.w	sp[1676],r8
800094dc:	c0 29       	rjmp	800096e0 <_vfprintf_r+0x1e20>
800094de:	14 09       	add	r9,r10
800094e0:	2f f8       	sub	r8,-1
800094e2:	fb 49 06 90 	st.w	sp[1680],r9
800094e6:	87 06       	st.w	r3[0x0],r6
800094e8:	87 1a       	st.w	r3[0x4],r10
800094ea:	fb 48 06 8c 	st.w	sp[1676],r8
800094ee:	58 78       	cp.w	r8,7
800094f0:	e0 89 00 04 	brgt	800094f8 <_vfprintf_r+0x1c38>
800094f4:	2f 83       	sub	r3,-8
800094f6:	c0 b8       	rjmp	8000950c <_vfprintf_r+0x1c4c>
800094f8:	fa ca f9 78 	sub	r10,sp,-1672
800094fc:	02 9b       	mov	r11,r1
800094fe:	08 9c       	mov	r12,r4
80009500:	fe b0 f1 d2 	rcall	800078a4 <__sprint_r>
80009504:	e0 81 01 69 	brne	800097d6 <_vfprintf_r+0x1f16>
80009508:	fa c3 f9 e0 	sub	r3,sp,-1568
8000950c:	40 c8       	lddsp	r8,sp[0x30]
8000950e:	87 08       	st.w	r3[0x0],r8
80009510:	fa f8 06 90 	ld.w	r8,sp[1680]
80009514:	2f f8       	sub	r8,-1
80009516:	30 19       	mov	r9,1
80009518:	fb 48 06 90 	st.w	sp[1680],r8
8000951c:	87 19       	st.w	r3[0x4],r9
8000951e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009522:	2f f8       	sub	r8,-1
80009524:	fb 48 06 8c 	st.w	sp[1676],r8
80009528:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000952c:	58 78       	cp.w	r8,7
8000952e:	e0 89 00 04 	brgt	80009536 <_vfprintf_r+0x1c76>
80009532:	2f 83       	sub	r3,-8
80009534:	c0 b8       	rjmp	8000954a <_vfprintf_r+0x1c8a>
80009536:	fa ca f9 78 	sub	r10,sp,-1672
8000953a:	02 9b       	mov	r11,r1
8000953c:	08 9c       	mov	r12,r4
8000953e:	fe b0 f1 b3 	rcall	800078a4 <__sprint_r>
80009542:	e0 81 01 4a 	brne	800097d6 <_vfprintf_r+0x1f16>
80009546:	fa c3 f9 e0 	sub	r3,sp,-1568
8000954a:	04 06       	add	r6,r2
8000954c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009550:	87 06       	st.w	r3[0x0],r6
80009552:	fa f9 06 90 	ld.w	r9,sp[1680]
80009556:	40 66       	lddsp	r6,sp[0x18]
80009558:	40 6e       	lddsp	lr,sp[0x18]
8000955a:	10 16       	sub	r6,r8
8000955c:	f2 08 01 08 	sub	r8,r9,r8
80009560:	87 16       	st.w	r3[0x4],r6
80009562:	1c 08       	add	r8,lr
80009564:	fb 48 06 90 	st.w	sp[1680],r8
80009568:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000956c:	2f f8       	sub	r8,-1
8000956e:	fb 48 06 8c 	st.w	sp[1676],r8
80009572:	cb 78       	rjmp	800096e0 <_vfprintf_r+0x1e20>
80009574:	40 6c       	lddsp	r12,sp[0x18]
80009576:	58 1c       	cp.w	r12,1
80009578:	e0 89 00 06 	brgt	80009584 <_vfprintf_r+0x1cc4>
8000957c:	ed b5 00 00 	bld	r5,0x0
80009580:	e0 81 00 85 	brne	8000968a <_vfprintf_r+0x1dca>
80009584:	fa f8 06 90 	ld.w	r8,sp[1680]
80009588:	2f f8       	sub	r8,-1
8000958a:	30 19       	mov	r9,1
8000958c:	fb 48 06 90 	st.w	sp[1680],r8
80009590:	87 06       	st.w	r3[0x0],r6
80009592:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009596:	87 19       	st.w	r3[0x4],r9
80009598:	2f f8       	sub	r8,-1
8000959a:	fb 48 06 8c 	st.w	sp[1676],r8
8000959e:	58 78       	cp.w	r8,7
800095a0:	e0 89 00 04 	brgt	800095a8 <_vfprintf_r+0x1ce8>
800095a4:	2f 83       	sub	r3,-8
800095a6:	c0 b8       	rjmp	800095bc <_vfprintf_r+0x1cfc>
800095a8:	fa ca f9 78 	sub	r10,sp,-1672
800095ac:	02 9b       	mov	r11,r1
800095ae:	08 9c       	mov	r12,r4
800095b0:	fe b0 f1 7a 	rcall	800078a4 <__sprint_r>
800095b4:	e0 81 01 11 	brne	800097d6 <_vfprintf_r+0x1f16>
800095b8:	fa c3 f9 e0 	sub	r3,sp,-1568
800095bc:	fa f8 06 90 	ld.w	r8,sp[1680]
800095c0:	2f f8       	sub	r8,-1
800095c2:	40 cb       	lddsp	r11,sp[0x30]
800095c4:	fb 48 06 90 	st.w	sp[1680],r8
800095c8:	30 19       	mov	r9,1
800095ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
800095ce:	87 0b       	st.w	r3[0x0],r11
800095d0:	2f f8       	sub	r8,-1
800095d2:	87 19       	st.w	r3[0x4],r9
800095d4:	fb 48 06 8c 	st.w	sp[1676],r8
800095d8:	58 78       	cp.w	r8,7
800095da:	e0 89 00 07 	brgt	800095e8 <_vfprintf_r+0x1d28>
800095de:	2f 83       	sub	r3,-8
800095e0:	c0 e8       	rjmp	800095fc <_vfprintf_r+0x1d3c>
800095e2:	d7 03       	nop
800095e4:	80 01       	ld.sh	r1,r0[0x0]
800095e6:	5f f8       	sral	r8
800095e8:	fa ca f9 78 	sub	r10,sp,-1672
800095ec:	02 9b       	mov	r11,r1
800095ee:	08 9c       	mov	r12,r4
800095f0:	fe b0 f1 5a 	rcall	800078a4 <__sprint_r>
800095f4:	e0 81 00 f1 	brne	800097d6 <_vfprintf_r+0x1f16>
800095f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800095fc:	30 08       	mov	r8,0
800095fe:	30 09       	mov	r9,0
80009600:	40 5b       	lddsp	r11,sp[0x14]
80009602:	40 7a       	lddsp	r10,sp[0x1c]
80009604:	e0 a0 13 25 	rcall	8000bc4e <__avr32_f64_cmp_eq>
80009608:	40 68       	lddsp	r8,sp[0x18]
8000960a:	20 18       	sub	r8,1
8000960c:	58 0c       	cp.w	r12,0
8000960e:	c0 d1       	brne	80009628 <_vfprintf_r+0x1d68>
80009610:	2f f6       	sub	r6,-1
80009612:	87 18       	st.w	r3[0x4],r8
80009614:	87 06       	st.w	r3[0x0],r6
80009616:	fa f6 06 90 	ld.w	r6,sp[1680]
8000961a:	10 06       	add	r6,r8
8000961c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009620:	fb 46 06 90 	st.w	sp[1680],r6
80009624:	2f f8       	sub	r8,-1
80009626:	c2 f8       	rjmp	80009684 <_vfprintf_r+0x1dc4>
80009628:	10 96       	mov	r6,r8
8000962a:	58 08       	cp.w	r8,0
8000962c:	e0 89 00 1c 	brgt	80009664 <_vfprintf_r+0x1da4>
80009630:	c4 98       	rjmp	800096c2 <_vfprintf_r+0x1e02>
80009632:	2f 09       	sub	r9,-16
80009634:	2f f8       	sub	r8,-1
80009636:	fb 49 06 90 	st.w	sp[1680],r9
8000963a:	87 02       	st.w	r3[0x0],r2
8000963c:	87 10       	st.w	r3[0x4],r0
8000963e:	fb 48 06 8c 	st.w	sp[1676],r8
80009642:	58 78       	cp.w	r8,7
80009644:	e0 89 00 04 	brgt	8000964c <_vfprintf_r+0x1d8c>
80009648:	2f 83       	sub	r3,-8
8000964a:	c0 b8       	rjmp	80009660 <_vfprintf_r+0x1da0>
8000964c:	fa ca f9 78 	sub	r10,sp,-1672
80009650:	02 9b       	mov	r11,r1
80009652:	08 9c       	mov	r12,r4
80009654:	fe b0 f1 28 	rcall	800078a4 <__sprint_r>
80009658:	e0 81 00 bf 	brne	800097d6 <_vfprintf_r+0x1f16>
8000965c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009660:	21 06       	sub	r6,16
80009662:	c0 38       	rjmp	80009668 <_vfprintf_r+0x1da8>
80009664:	4d 22       	lddpc	r2,800097ac <_vfprintf_r+0x1eec>
80009666:	31 00       	mov	r0,16
80009668:	fa f9 06 90 	ld.w	r9,sp[1680]
8000966c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009670:	4c fa       	lddpc	r10,800097ac <_vfprintf_r+0x1eec>
80009672:	59 06       	cp.w	r6,16
80009674:	fe 99 ff df 	brgt	80009632 <_vfprintf_r+0x1d72>
80009678:	0c 09       	add	r9,r6
8000967a:	87 0a       	st.w	r3[0x0],r10
8000967c:	fb 49 06 90 	st.w	sp[1680],r9
80009680:	2f f8       	sub	r8,-1
80009682:	87 16       	st.w	r3[0x4],r6
80009684:	fb 48 06 8c 	st.w	sp[1676],r8
80009688:	c0 e8       	rjmp	800096a4 <_vfprintf_r+0x1de4>
8000968a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000968e:	2f f8       	sub	r8,-1
80009690:	30 19       	mov	r9,1
80009692:	fb 48 06 90 	st.w	sp[1680],r8
80009696:	87 06       	st.w	r3[0x0],r6
80009698:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000969c:	87 19       	st.w	r3[0x4],r9
8000969e:	2f f8       	sub	r8,-1
800096a0:	fb 48 06 8c 	st.w	sp[1676],r8
800096a4:	58 78       	cp.w	r8,7
800096a6:	e0 89 00 04 	brgt	800096ae <_vfprintf_r+0x1dee>
800096aa:	2f 83       	sub	r3,-8
800096ac:	c0 b8       	rjmp	800096c2 <_vfprintf_r+0x1e02>
800096ae:	fa ca f9 78 	sub	r10,sp,-1672
800096b2:	02 9b       	mov	r11,r1
800096b4:	08 9c       	mov	r12,r4
800096b6:	fe b0 f0 f7 	rcall	800078a4 <__sprint_r>
800096ba:	e0 81 00 8e 	brne	800097d6 <_vfprintf_r+0x1f16>
800096be:	fa c3 f9 e0 	sub	r3,sp,-1568
800096c2:	40 ea       	lddsp	r10,sp[0x38]
800096c4:	fa f8 06 90 	ld.w	r8,sp[1680]
800096c8:	14 08       	add	r8,r10
800096ca:	fa c9 f9 64 	sub	r9,sp,-1692
800096ce:	fb 48 06 90 	st.w	sp[1680],r8
800096d2:	87 1a       	st.w	r3[0x4],r10
800096d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096d8:	87 09       	st.w	r3[0x0],r9
800096da:	2f f8       	sub	r8,-1
800096dc:	fb 48 06 8c 	st.w	sp[1676],r8
800096e0:	58 78       	cp.w	r8,7
800096e2:	e0 89 00 04 	brgt	800096ea <_vfprintf_r+0x1e2a>
800096e6:	2f 83       	sub	r3,-8
800096e8:	c0 a8       	rjmp	800096fc <_vfprintf_r+0x1e3c>
800096ea:	fa ca f9 78 	sub	r10,sp,-1672
800096ee:	02 9b       	mov	r11,r1
800096f0:	08 9c       	mov	r12,r4
800096f2:	fe b0 f0 d9 	rcall	800078a4 <__sprint_r>
800096f6:	c7 01       	brne	800097d6 <_vfprintf_r+0x1f16>
800096f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800096fc:	e2 15 00 04 	andl	r5,0x4,COH
80009700:	c3 d0       	breq	8000977a <_vfprintf_r+0x1eba>
80009702:	40 86       	lddsp	r6,sp[0x20]
80009704:	40 39       	lddsp	r9,sp[0xc]
80009706:	12 16       	sub	r6,r9
80009708:	58 06       	cp.w	r6,0
8000970a:	e0 89 00 1a 	brgt	8000973e <_vfprintf_r+0x1e7e>
8000970e:	c3 68       	rjmp	8000977a <_vfprintf_r+0x1eba>
80009710:	2f 09       	sub	r9,-16
80009712:	2f f8       	sub	r8,-1
80009714:	fb 49 06 90 	st.w	sp[1680],r9
80009718:	87 05       	st.w	r3[0x0],r5
8000971a:	87 12       	st.w	r3[0x4],r2
8000971c:	fb 48 06 8c 	st.w	sp[1676],r8
80009720:	58 78       	cp.w	r8,7
80009722:	e0 89 00 04 	brgt	8000972a <_vfprintf_r+0x1e6a>
80009726:	2f 83       	sub	r3,-8
80009728:	c0 98       	rjmp	8000973a <_vfprintf_r+0x1e7a>
8000972a:	00 9a       	mov	r10,r0
8000972c:	02 9b       	mov	r11,r1
8000972e:	08 9c       	mov	r12,r4
80009730:	fe b0 f0 ba 	rcall	800078a4 <__sprint_r>
80009734:	c5 11       	brne	800097d6 <_vfprintf_r+0x1f16>
80009736:	fa c3 f9 e0 	sub	r3,sp,-1568
8000973a:	21 06       	sub	r6,16
8000973c:	c0 58       	rjmp	80009746 <_vfprintf_r+0x1e86>
8000973e:	49 d5       	lddpc	r5,800097b0 <_vfprintf_r+0x1ef0>
80009740:	31 02       	mov	r2,16
80009742:	fa c0 f9 78 	sub	r0,sp,-1672
80009746:	fa f9 06 90 	ld.w	r9,sp[1680]
8000974a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000974e:	49 9a       	lddpc	r10,800097b0 <_vfprintf_r+0x1ef0>
80009750:	59 06       	cp.w	r6,16
80009752:	fe 99 ff df 	brgt	80009710 <_vfprintf_r+0x1e50>
80009756:	0c 09       	add	r9,r6
80009758:	2f f8       	sub	r8,-1
8000975a:	87 0a       	st.w	r3[0x0],r10
8000975c:	87 16       	st.w	r3[0x4],r6
8000975e:	fb 49 06 90 	st.w	sp[1680],r9
80009762:	fb 48 06 8c 	st.w	sp[1676],r8
80009766:	58 78       	cp.w	r8,7
80009768:	e0 8a 00 09 	brle	8000977a <_vfprintf_r+0x1eba>
8000976c:	fa ca f9 78 	sub	r10,sp,-1672
80009770:	02 9b       	mov	r11,r1
80009772:	08 9c       	mov	r12,r4
80009774:	fe b0 f0 98 	rcall	800078a4 <__sprint_r>
80009778:	c2 f1       	brne	800097d6 <_vfprintf_r+0x1f16>
8000977a:	40 bc       	lddsp	r12,sp[0x2c]
8000977c:	40 36       	lddsp	r6,sp[0xc]
8000977e:	40 8e       	lddsp	lr,sp[0x20]
80009780:	ec 0e 0c 48 	max	r8,r6,lr
80009784:	10 0c       	add	r12,r8
80009786:	50 bc       	stdsp	sp[0x2c],r12
80009788:	fa f8 06 90 	ld.w	r8,sp[1680]
8000978c:	58 08       	cp.w	r8,0
8000978e:	c0 80       	breq	8000979e <_vfprintf_r+0x1ede>
80009790:	fa ca f9 78 	sub	r10,sp,-1672
80009794:	02 9b       	mov	r11,r1
80009796:	08 9c       	mov	r12,r4
80009798:	fe b0 f0 86 	rcall	800078a4 <__sprint_r>
8000979c:	c1 d1       	brne	800097d6 <_vfprintf_r+0x1f16>
8000979e:	30 0b       	mov	r11,0
800097a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800097a4:	fb 4b 06 8c 	st.w	sp[1676],r11
800097a8:	fe 9f f1 17 	bral	800079d6 <_vfprintf_r+0x116>
800097ac:	80 01       	ld.sh	r1,r0[0x0]
800097ae:	5f f8       	sral	r8
800097b0:	80 01       	ld.sh	r1,r0[0x0]
800097b2:	5f e8       	srqs	r8
800097b4:	08 95       	mov	r5,r4
800097b6:	fa f8 06 90 	ld.w	r8,sp[1680]
800097ba:	58 08       	cp.w	r8,0
800097bc:	c0 80       	breq	800097cc <_vfprintf_r+0x1f0c>
800097be:	08 9c       	mov	r12,r4
800097c0:	fa ca f9 78 	sub	r10,sp,-1672
800097c4:	02 9b       	mov	r11,r1
800097c6:	fe b0 f0 6f 	rcall	800078a4 <__sprint_r>
800097ca:	c0 61       	brne	800097d6 <_vfprintf_r+0x1f16>
800097cc:	30 08       	mov	r8,0
800097ce:	fb 48 06 8c 	st.w	sp[1676],r8
800097d2:	c0 28       	rjmp	800097d6 <_vfprintf_r+0x1f16>
800097d4:	40 41       	lddsp	r1,sp[0x10]
800097d6:	82 68       	ld.sh	r8,r1[0xc]
800097d8:	ed b8 00 06 	bld	r8,0x6
800097dc:	c0 31       	brne	800097e2 <_vfprintf_r+0x1f22>
800097de:	3f fa       	mov	r10,-1
800097e0:	50 ba       	stdsp	sp[0x2c],r10
800097e2:	40 bc       	lddsp	r12,sp[0x2c]
800097e4:	fe 3d f9 44 	sub	sp,-1724
800097e8:	d8 32       	popm	r0-r7,pc
800097ea:	d7 03       	nop

800097ec <__swsetup_r>:
800097ec:	d4 21       	pushm	r4-r7,lr
800097ee:	e0 68 0a 30 	mov	r8,2608
800097f2:	18 96       	mov	r6,r12
800097f4:	16 97       	mov	r7,r11
800097f6:	70 0c       	ld.w	r12,r8[0x0]
800097f8:	58 0c       	cp.w	r12,0
800097fa:	c0 60       	breq	80009806 <__swsetup_r+0x1a>
800097fc:	78 68       	ld.w	r8,r12[0x18]
800097fe:	58 08       	cp.w	r8,0
80009800:	c0 31       	brne	80009806 <__swsetup_r+0x1a>
80009802:	e0 a0 07 c7 	rcall	8000a790 <__sinit>
80009806:	4a f8       	lddpc	r8,800098c0 <__swsetup_r+0xd4>
80009808:	10 37       	cp.w	r7,r8
8000980a:	c0 61       	brne	80009816 <__swsetup_r+0x2a>
8000980c:	e0 68 0a 30 	mov	r8,2608
80009810:	70 08       	ld.w	r8,r8[0x0]
80009812:	70 07       	ld.w	r7,r8[0x0]
80009814:	c1 08       	rjmp	80009834 <__swsetup_r+0x48>
80009816:	4a c8       	lddpc	r8,800098c4 <__swsetup_r+0xd8>
80009818:	10 37       	cp.w	r7,r8
8000981a:	c0 61       	brne	80009826 <__swsetup_r+0x3a>
8000981c:	e0 68 0a 30 	mov	r8,2608
80009820:	70 08       	ld.w	r8,r8[0x0]
80009822:	70 17       	ld.w	r7,r8[0x4]
80009824:	c0 88       	rjmp	80009834 <__swsetup_r+0x48>
80009826:	4a 98       	lddpc	r8,800098c8 <__swsetup_r+0xdc>
80009828:	10 37       	cp.w	r7,r8
8000982a:	c0 51       	brne	80009834 <__swsetup_r+0x48>
8000982c:	e0 68 0a 30 	mov	r8,2608
80009830:	70 08       	ld.w	r8,r8[0x0]
80009832:	70 27       	ld.w	r7,r8[0x8]
80009834:	8e 68       	ld.sh	r8,r7[0xc]
80009836:	ed b8 00 03 	bld	r8,0x3
8000983a:	c1 e0       	breq	80009876 <__swsetup_r+0x8a>
8000983c:	ed b8 00 04 	bld	r8,0x4
80009840:	c3 e1       	brne	800098bc <__swsetup_r+0xd0>
80009842:	ed b8 00 02 	bld	r8,0x2
80009846:	c1 51       	brne	80009870 <__swsetup_r+0x84>
80009848:	6e db       	ld.w	r11,r7[0x34]
8000984a:	58 0b       	cp.w	r11,0
8000984c:	c0 a0       	breq	80009860 <__swsetup_r+0x74>
8000984e:	ee c8 ff bc 	sub	r8,r7,-68
80009852:	10 3b       	cp.w	r11,r8
80009854:	c0 40       	breq	8000985c <__swsetup_r+0x70>
80009856:	0c 9c       	mov	r12,r6
80009858:	e0 a0 08 36 	rcall	8000a8c4 <_free_r>
8000985c:	30 08       	mov	r8,0
8000985e:	8f d8       	st.w	r7[0x34],r8
80009860:	8e 68       	ld.sh	r8,r7[0xc]
80009862:	e0 18 ff db 	andl	r8,0xffdb
80009866:	ae 68       	st.h	r7[0xc],r8
80009868:	30 08       	mov	r8,0
8000986a:	8f 18       	st.w	r7[0x4],r8
8000986c:	6e 48       	ld.w	r8,r7[0x10]
8000986e:	8f 08       	st.w	r7[0x0],r8
80009870:	8e 68       	ld.sh	r8,r7[0xc]
80009872:	a3 b8       	sbr	r8,0x3
80009874:	ae 68       	st.h	r7[0xc],r8
80009876:	6e 48       	ld.w	r8,r7[0x10]
80009878:	58 08       	cp.w	r8,0
8000987a:	c0 b1       	brne	80009890 <__swsetup_r+0xa4>
8000987c:	8e 68       	ld.sh	r8,r7[0xc]
8000987e:	e2 18 02 80 	andl	r8,0x280,COH
80009882:	e0 48 02 00 	cp.w	r8,512
80009886:	c0 50       	breq	80009890 <__swsetup_r+0xa4>
80009888:	0c 9c       	mov	r12,r6
8000988a:	0e 9b       	mov	r11,r7
8000988c:	e0 a0 0a 56 	rcall	8000ad38 <__smakebuf_r>
80009890:	8e 69       	ld.sh	r9,r7[0xc]
80009892:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009896:	c0 70       	breq	800098a4 <__swsetup_r+0xb8>
80009898:	30 08       	mov	r8,0
8000989a:	8f 28       	st.w	r7[0x8],r8
8000989c:	6e 58       	ld.w	r8,r7[0x14]
8000989e:	5c 38       	neg	r8
800098a0:	8f 68       	st.w	r7[0x18],r8
800098a2:	c0 68       	rjmp	800098ae <__swsetup_r+0xc2>
800098a4:	ed b9 00 01 	bld	r9,0x1
800098a8:	ef f8 10 05 	ld.wne	r8,r7[0x14]
800098ac:	8f 28       	st.w	r7[0x8],r8
800098ae:	6e 48       	ld.w	r8,r7[0x10]
800098b0:	58 08       	cp.w	r8,0
800098b2:	c0 61       	brne	800098be <__swsetup_r+0xd2>
800098b4:	8e 68       	ld.sh	r8,r7[0xc]
800098b6:	ed b8 00 07 	bld	r8,0x7
800098ba:	c0 21       	brne	800098be <__swsetup_r+0xd2>
800098bc:	dc 2a       	popm	r4-r7,pc,r12=-1
800098be:	d8 2a       	popm	r4-r7,pc,r12=0
800098c0:	80 01       	ld.sh	r1,r0[0x0]
800098c2:	61 18       	ld.w	r8,r0[0x44]
800098c4:	80 01       	ld.sh	r1,r0[0x0]
800098c6:	61 38       	ld.w	r8,r0[0x4c]
800098c8:	80 01       	ld.sh	r1,r0[0x0]
800098ca:	61 58       	ld.w	r8,r0[0x54]

800098cc <quorem>:
800098cc:	d4 31       	pushm	r0-r7,lr
800098ce:	20 2d       	sub	sp,8
800098d0:	18 97       	mov	r7,r12
800098d2:	78 48       	ld.w	r8,r12[0x10]
800098d4:	76 46       	ld.w	r6,r11[0x10]
800098d6:	0c 38       	cp.w	r8,r6
800098d8:	c0 34       	brge	800098de <quorem+0x12>
800098da:	30 0c       	mov	r12,0
800098dc:	c8 58       	rjmp	800099e6 <quorem+0x11a>
800098de:	ec c2 ff fc 	sub	r2,r6,-4
800098e2:	f6 c3 ff ec 	sub	r3,r11,-20
800098e6:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800098ea:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800098ee:	2f f9       	sub	r9,-1
800098f0:	20 16       	sub	r6,1
800098f2:	f8 09 0d 08 	divu	r8,r12,r9
800098f6:	f6 02 00 22 	add	r2,r11,r2<<0x2
800098fa:	ee c4 ff ec 	sub	r4,r7,-20
800098fe:	10 95       	mov	r5,r8
80009900:	58 08       	cp.w	r8,0
80009902:	c4 10       	breq	80009984 <quorem+0xb8>
80009904:	30 09       	mov	r9,0
80009906:	06 9a       	mov	r10,r3
80009908:	08 98       	mov	r8,r4
8000990a:	12 91       	mov	r1,r9
8000990c:	50 0b       	stdsp	sp[0x0],r11
8000990e:	70 0e       	ld.w	lr,r8[0x0]
80009910:	b1 8e       	lsr	lr,0x10
80009912:	50 1e       	stdsp	sp[0x4],lr
80009914:	15 0e       	ld.w	lr,r10++
80009916:	fc 00 16 10 	lsr	r0,lr,0x10
8000991a:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000991e:	ea 0e 03 41 	mac	r1,r5,lr
80009922:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009926:	b1 81       	lsr	r1,0x10
80009928:	40 1b       	lddsp	r11,sp[0x4]
8000992a:	ea 00 02 40 	mul	r0,r5,r0
8000992e:	e2 00 00 00 	add	r0,r1,r0
80009932:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009936:	02 1b       	sub	r11,r1
80009938:	50 1b       	stdsp	sp[0x4],r11
8000993a:	70 0b       	ld.w	r11,r8[0x0]
8000993c:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009940:	02 09       	add	r9,r1
80009942:	f2 0e 01 0e 	sub	lr,r9,lr
80009946:	b0 1e       	st.h	r8[0x2],lr
80009948:	fc 09 14 10 	asr	r9,lr,0x10
8000994c:	40 1e       	lddsp	lr,sp[0x4]
8000994e:	fc 09 00 09 	add	r9,lr,r9
80009952:	b0 09       	st.h	r8[0x0],r9
80009954:	e0 01 16 10 	lsr	r1,r0,0x10
80009958:	2f c8       	sub	r8,-4
8000995a:	b1 49       	asr	r9,0x10
8000995c:	04 3a       	cp.w	r10,r2
8000995e:	fe 98 ff d8 	brls	8000990e <quorem+0x42>
80009962:	40 0b       	lddsp	r11,sp[0x0]
80009964:	58 0c       	cp.w	r12,0
80009966:	c0 f1       	brne	80009984 <quorem+0xb8>
80009968:	ec c8 ff fb 	sub	r8,r6,-5
8000996c:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009970:	c0 28       	rjmp	80009974 <quorem+0xa8>
80009972:	20 16       	sub	r6,1
80009974:	20 48       	sub	r8,4
80009976:	08 38       	cp.w	r8,r4
80009978:	e0 88 00 05 	brls	80009982 <quorem+0xb6>
8000997c:	70 09       	ld.w	r9,r8[0x0]
8000997e:	58 09       	cp.w	r9,0
80009980:	cf 90       	breq	80009972 <quorem+0xa6>
80009982:	8f 46       	st.w	r7[0x10],r6
80009984:	0e 9c       	mov	r12,r7
80009986:	e0 a0 0a d8 	rcall	8000af36 <__mcmp>
8000998a:	c2 d5       	brlt	800099e4 <quorem+0x118>
8000998c:	2f f5       	sub	r5,-1
8000998e:	08 98       	mov	r8,r4
80009990:	30 09       	mov	r9,0
80009992:	07 0b       	ld.w	r11,r3++
80009994:	f6 0a 16 10 	lsr	r10,r11,0x10
80009998:	70 0c       	ld.w	r12,r8[0x0]
8000999a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000999e:	f8 0e 16 10 	lsr	lr,r12,0x10
800099a2:	14 1e       	sub	lr,r10
800099a4:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800099a8:	16 1a       	sub	r10,r11
800099aa:	12 0a       	add	r10,r9
800099ac:	b0 1a       	st.h	r8[0x2],r10
800099ae:	b1 4a       	asr	r10,0x10
800099b0:	fc 0a 00 09 	add	r9,lr,r10
800099b4:	b0 09       	st.h	r8[0x0],r9
800099b6:	2f c8       	sub	r8,-4
800099b8:	b1 49       	asr	r9,0x10
800099ba:	04 33       	cp.w	r3,r2
800099bc:	fe 98 ff eb 	brls	80009992 <quorem+0xc6>
800099c0:	ec c8 ff fb 	sub	r8,r6,-5
800099c4:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800099c8:	58 09       	cp.w	r9,0
800099ca:	c0 d1       	brne	800099e4 <quorem+0x118>
800099cc:	ee 08 00 28 	add	r8,r7,r8<<0x2
800099d0:	c0 28       	rjmp	800099d4 <quorem+0x108>
800099d2:	20 16       	sub	r6,1
800099d4:	20 48       	sub	r8,4
800099d6:	08 38       	cp.w	r8,r4
800099d8:	e0 88 00 05 	brls	800099e2 <quorem+0x116>
800099dc:	70 09       	ld.w	r9,r8[0x0]
800099de:	58 09       	cp.w	r9,0
800099e0:	cf 90       	breq	800099d2 <quorem+0x106>
800099e2:	8f 46       	st.w	r7[0x10],r6
800099e4:	0a 9c       	mov	r12,r5
800099e6:	2f ed       	sub	sp,-8
800099e8:	d8 32       	popm	r0-r7,pc
800099ea:	d7 03       	nop

800099ec <_dtoa_r>:
800099ec:	d4 31       	pushm	r0-r7,lr
800099ee:	21 ad       	sub	sp,104
800099f0:	fa c4 ff 74 	sub	r4,sp,-140
800099f4:	18 97       	mov	r7,r12
800099f6:	16 95       	mov	r5,r11
800099f8:	68 2c       	ld.w	r12,r4[0x8]
800099fa:	50 c9       	stdsp	sp[0x30],r9
800099fc:	68 16       	ld.w	r6,r4[0x4]
800099fe:	68 09       	ld.w	r9,r4[0x0]
80009a00:	50 e8       	stdsp	sp[0x38],r8
80009a02:	14 94       	mov	r4,r10
80009a04:	51 2c       	stdsp	sp[0x48],r12
80009a06:	fa e5 00 08 	st.d	sp[8],r4
80009a0a:	51 59       	stdsp	sp[0x54],r9
80009a0c:	6e 95       	ld.w	r5,r7[0x24]
80009a0e:	58 05       	cp.w	r5,0
80009a10:	c0 91       	brne	80009a22 <_dtoa_r+0x36>
80009a12:	31 0c       	mov	r12,16
80009a14:	fe b0 e8 d4 	rcall	80006bbc <malloc>
80009a18:	99 35       	st.w	r12[0xc],r5
80009a1a:	8f 9c       	st.w	r7[0x24],r12
80009a1c:	99 15       	st.w	r12[0x4],r5
80009a1e:	99 25       	st.w	r12[0x8],r5
80009a20:	99 05       	st.w	r12[0x0],r5
80009a22:	6e 99       	ld.w	r9,r7[0x24]
80009a24:	72 08       	ld.w	r8,r9[0x0]
80009a26:	58 08       	cp.w	r8,0
80009a28:	c0 f0       	breq	80009a46 <_dtoa_r+0x5a>
80009a2a:	72 1a       	ld.w	r10,r9[0x4]
80009a2c:	91 1a       	st.w	r8[0x4],r10
80009a2e:	30 1a       	mov	r10,1
80009a30:	72 19       	ld.w	r9,r9[0x4]
80009a32:	f4 09 09 49 	lsl	r9,r10,r9
80009a36:	10 9b       	mov	r11,r8
80009a38:	91 29       	st.w	r8[0x8],r9
80009a3a:	0e 9c       	mov	r12,r7
80009a3c:	e0 a0 0a 96 	rcall	8000af68 <_Bfree>
80009a40:	6e 98       	ld.w	r8,r7[0x24]
80009a42:	30 09       	mov	r9,0
80009a44:	91 09       	st.w	r8[0x0],r9
80009a46:	40 28       	lddsp	r8,sp[0x8]
80009a48:	10 94       	mov	r4,r8
80009a4a:	58 08       	cp.w	r8,0
80009a4c:	c0 64       	brge	80009a58 <_dtoa_r+0x6c>
80009a4e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009a52:	50 28       	stdsp	sp[0x8],r8
80009a54:	30 18       	mov	r8,1
80009a56:	c0 28       	rjmp	80009a5a <_dtoa_r+0x6e>
80009a58:	30 08       	mov	r8,0
80009a5a:	8d 08       	st.w	r6[0x0],r8
80009a5c:	fc 1c 7f f0 	movh	r12,0x7ff0
80009a60:	40 26       	lddsp	r6,sp[0x8]
80009a62:	0c 98       	mov	r8,r6
80009a64:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009a68:	18 38       	cp.w	r8,r12
80009a6a:	c1 e1       	brne	80009aa6 <_dtoa_r+0xba>
80009a6c:	e0 68 27 0f 	mov	r8,9999
80009a70:	41 5b       	lddsp	r11,sp[0x54]
80009a72:	97 08       	st.w	r11[0x0],r8
80009a74:	40 3a       	lddsp	r10,sp[0xc]
80009a76:	58 0a       	cp.w	r10,0
80009a78:	c0 61       	brne	80009a84 <_dtoa_r+0x98>
80009a7a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009a7e:	c0 31       	brne	80009a84 <_dtoa_r+0x98>
80009a80:	4a cc       	lddpc	r12,80009b30 <_dtoa_r+0x144>
80009a82:	c0 28       	rjmp	80009a86 <_dtoa_r+0x9a>
80009a84:	4a cc       	lddpc	r12,80009b34 <_dtoa_r+0x148>
80009a86:	41 29       	lddsp	r9,sp[0x48]
80009a88:	58 09       	cp.w	r9,0
80009a8a:	e0 80 05 9e 	breq	8000a5c6 <_dtoa_r+0xbda>
80009a8e:	f8 c8 ff fd 	sub	r8,r12,-3
80009a92:	f8 c9 ff f8 	sub	r9,r12,-8
80009a96:	11 8b       	ld.ub	r11,r8[0x0]
80009a98:	30 0a       	mov	r10,0
80009a9a:	41 25       	lddsp	r5,sp[0x48]
80009a9c:	f4 0b 18 00 	cp.b	r11,r10
80009aa0:	f2 08 17 10 	movne	r8,r9
80009aa4:	c1 58       	rjmp	80009ace <_dtoa_r+0xe2>
80009aa6:	fa ea 00 08 	ld.d	r10,sp[8]
80009aaa:	30 08       	mov	r8,0
80009aac:	fa eb 00 3c 	st.d	sp[60],r10
80009ab0:	30 09       	mov	r9,0
80009ab2:	e0 a0 10 ce 	rcall	8000bc4e <__avr32_f64_cmp_eq>
80009ab6:	c0 f0       	breq	80009ad4 <_dtoa_r+0xe8>
80009ab8:	30 18       	mov	r8,1
80009aba:	41 5a       	lddsp	r10,sp[0x54]
80009abc:	95 08       	st.w	r10[0x0],r8
80009abe:	49 fc       	lddpc	r12,80009b38 <_dtoa_r+0x14c>
80009ac0:	41 29       	lddsp	r9,sp[0x48]
80009ac2:	f8 08 00 08 	add	r8,r12,r8
80009ac6:	58 09       	cp.w	r9,0
80009ac8:	e0 80 05 7f 	breq	8000a5c6 <_dtoa_r+0xbda>
80009acc:	12 95       	mov	r5,r9
80009ace:	8b 08       	st.w	r5[0x0],r8
80009ad0:	e0 8f 05 7b 	bral	8000a5c6 <_dtoa_r+0xbda>
80009ad4:	fa c8 ff 9c 	sub	r8,sp,-100
80009ad8:	fa c9 ff a0 	sub	r9,sp,-96
80009adc:	fa ea 00 3c 	ld.d	r10,sp[60]
80009ae0:	0e 9c       	mov	r12,r7
80009ae2:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009ae6:	e0 a0 0a 93 	rcall	8000b00c <__d2b>
80009aea:	18 93       	mov	r3,r12
80009aec:	58 05       	cp.w	r5,0
80009aee:	c0 d0       	breq	80009b08 <_dtoa_r+0x11c>
80009af0:	fa ea 00 3c 	ld.d	r10,sp[60]
80009af4:	30 04       	mov	r4,0
80009af6:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80009afa:	ea c5 03 ff 	sub	r5,r5,1023
80009afe:	10 9b       	mov	r11,r8
80009b00:	51 74       	stdsp	sp[0x5c],r4
80009b02:	ea 1b 3f f0 	orh	r11,0x3ff0
80009b06:	c2 a8       	rjmp	80009b5a <_dtoa_r+0x16e>
80009b08:	41 88       	lddsp	r8,sp[0x60]
80009b0a:	41 9c       	lddsp	r12,sp[0x64]
80009b0c:	10 0c       	add	r12,r8
80009b0e:	f8 c5 fb ce 	sub	r5,r12,-1074
80009b12:	e0 45 00 20 	cp.w	r5,32
80009b16:	e0 8a 00 13 	brle	80009b3c <_dtoa_r+0x150>
80009b1a:	f8 cc fb ee 	sub	r12,r12,-1042
80009b1e:	40 3b       	lddsp	r11,sp[0xc]
80009b20:	ea 08 11 40 	rsub	r8,r5,64
80009b24:	f6 0c 0a 4c 	lsr	r12,r11,r12
80009b28:	ec 08 09 46 	lsl	r6,r6,r8
80009b2c:	0c 4c       	or	r12,r6
80009b2e:	c0 c8       	rjmp	80009b46 <_dtoa_r+0x15a>
80009b30:	80 01       	ld.sh	r1,r0[0x0]
80009b32:	61 08       	ld.w	r8,r0[0x40]
80009b34:	80 01       	ld.sh	r1,r0[0x0]
80009b36:	61 14       	ld.w	r4,r0[0x44]
80009b38:	80 01       	ld.sh	r1,r0[0x0]
80009b3a:	5f e4       	srqs	r4
80009b3c:	ea 0c 11 20 	rsub	r12,r5,32
80009b40:	40 3a       	lddsp	r10,sp[0xc]
80009b42:	f4 0c 09 4c 	lsl	r12,r10,r12
80009b46:	e0 a0 10 10 	rcall	8000bb66 <__avr32_u32_to_f64>
80009b4a:	fc 18 fe 10 	movh	r8,0xfe10
80009b4e:	30 19       	mov	r9,1
80009b50:	ea c5 04 33 	sub	r5,r5,1075
80009b54:	f0 0b 00 0b 	add	r11,r8,r11
80009b58:	51 79       	stdsp	sp[0x5c],r9
80009b5a:	30 08       	mov	r8,0
80009b5c:	fc 19 3f f8 	movh	r9,0x3ff8
80009b60:	e0 a0 0e 98 	rcall	8000b890 <__avr32_f64_sub>
80009b64:	e0 68 43 61 	mov	r8,17249
80009b68:	ea 18 63 6f 	orh	r8,0x636f
80009b6c:	e0 69 87 a7 	mov	r9,34727
80009b70:	ea 19 3f d2 	orh	r9,0x3fd2
80009b74:	e0 a0 0d a2 	rcall	8000b6b8 <__avr32_f64_mul>
80009b78:	e0 68 c8 b3 	mov	r8,51379
80009b7c:	ea 18 8b 60 	orh	r8,0x8b60
80009b80:	e0 69 8a 28 	mov	r9,35368
80009b84:	ea 19 3f c6 	orh	r9,0x3fc6
80009b88:	e0 a0 0f 52 	rcall	8000ba2c <__avr32_f64_add>
80009b8c:	0a 9c       	mov	r12,r5
80009b8e:	14 90       	mov	r0,r10
80009b90:	16 91       	mov	r1,r11
80009b92:	e0 a0 0f ee 	rcall	8000bb6e <__avr32_s32_to_f64>
80009b96:	e0 68 79 fb 	mov	r8,31227
80009b9a:	ea 18 50 9f 	orh	r8,0x509f
80009b9e:	e0 69 44 13 	mov	r9,17427
80009ba2:	ea 19 3f d3 	orh	r9,0x3fd3
80009ba6:	e0 a0 0d 89 	rcall	8000b6b8 <__avr32_f64_mul>
80009baa:	14 98       	mov	r8,r10
80009bac:	16 99       	mov	r9,r11
80009bae:	00 9a       	mov	r10,r0
80009bb0:	02 9b       	mov	r11,r1
80009bb2:	e0 a0 0f 3d 	rcall	8000ba2c <__avr32_f64_add>
80009bb6:	14 90       	mov	r0,r10
80009bb8:	16 91       	mov	r1,r11
80009bba:	e0 a0 0f c3 	rcall	8000bb40 <__avr32_f64_to_s32>
80009bbe:	30 08       	mov	r8,0
80009bc0:	18 96       	mov	r6,r12
80009bc2:	30 09       	mov	r9,0
80009bc4:	00 9a       	mov	r10,r0
80009bc6:	02 9b       	mov	r11,r1
80009bc8:	e0 a0 10 8a 	rcall	8000bcdc <__avr32_f64_cmp_lt>
80009bcc:	c0 c0       	breq	80009be4 <_dtoa_r+0x1f8>
80009bce:	0c 9c       	mov	r12,r6
80009bd0:	e0 a0 0f cf 	rcall	8000bb6e <__avr32_s32_to_f64>
80009bd4:	14 98       	mov	r8,r10
80009bd6:	16 99       	mov	r9,r11
80009bd8:	00 9a       	mov	r10,r0
80009bda:	02 9b       	mov	r11,r1
80009bdc:	e0 a0 10 39 	rcall	8000bc4e <__avr32_f64_cmp_eq>
80009be0:	f7 b6 00 01 	subeq	r6,1
80009be4:	59 66       	cp.w	r6,22
80009be6:	e0 88 00 05 	brls	80009bf0 <_dtoa_r+0x204>
80009bea:	30 18       	mov	r8,1
80009bec:	51 48       	stdsp	sp[0x50],r8
80009bee:	c1 28       	rjmp	80009c12 <_dtoa_r+0x226>
80009bf0:	4c 08       	lddpc	r8,80009cf0 <_dtoa_r+0x304>
80009bf2:	fa ea 00 3c 	ld.d	r10,sp[60]
80009bf6:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009bfa:	e0 a0 10 71 	rcall	8000bcdc <__avr32_f64_cmp_lt>
80009bfe:	f9 b4 00 00 	moveq	r4,0
80009c02:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009c06:	f7 b6 01 01 	subne	r6,1
80009c0a:	f9 bc 01 00 	movne	r12,0
80009c0e:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009c12:	41 90       	lddsp	r0,sp[0x64]
80009c14:	20 10       	sub	r0,1
80009c16:	0a 10       	sub	r0,r5
80009c18:	c0 46       	brmi	80009c20 <_dtoa_r+0x234>
80009c1a:	50 40       	stdsp	sp[0x10],r0
80009c1c:	30 00       	mov	r0,0
80009c1e:	c0 48       	rjmp	80009c26 <_dtoa_r+0x23a>
80009c20:	30 0b       	mov	r11,0
80009c22:	5c 30       	neg	r0
80009c24:	50 4b       	stdsp	sp[0x10],r11
80009c26:	ec 02 11 00 	rsub	r2,r6,0
80009c2a:	58 06       	cp.w	r6,0
80009c2c:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009c30:	f5 d6 e4 0a 	addge	r10,r10,r6
80009c34:	fb fa 4a 04 	st.wge	sp[0x10],r10
80009c38:	fb f6 4a 11 	st.wge	sp[0x44],r6
80009c3c:	f9 b2 04 00 	movge	r2,0
80009c40:	e1 d6 e5 10 	sublt	r0,r0,r6
80009c44:	f9 b9 05 00 	movlt	r9,0
80009c48:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009c4c:	40 c8       	lddsp	r8,sp[0x30]
80009c4e:	58 98       	cp.w	r8,9
80009c50:	e0 8b 00 20 	brhi	80009c90 <_dtoa_r+0x2a4>
80009c54:	58 58       	cp.w	r8,5
80009c56:	f9 b4 0a 01 	movle	r4,1
80009c5a:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009c5e:	f7 b5 09 04 	subgt	r5,4
80009c62:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009c66:	f9 b4 09 00 	movgt	r4,0
80009c6a:	40 cc       	lddsp	r12,sp[0x30]
80009c6c:	58 3c       	cp.w	r12,3
80009c6e:	c2 d0       	breq	80009cc8 <_dtoa_r+0x2dc>
80009c70:	e0 89 00 05 	brgt	80009c7a <_dtoa_r+0x28e>
80009c74:	58 2c       	cp.w	r12,2
80009c76:	c1 01       	brne	80009c96 <_dtoa_r+0x2aa>
80009c78:	c1 88       	rjmp	80009ca8 <_dtoa_r+0x2bc>
80009c7a:	40 cb       	lddsp	r11,sp[0x30]
80009c7c:	58 4b       	cp.w	r11,4
80009c7e:	c0 60       	breq	80009c8a <_dtoa_r+0x29e>
80009c80:	58 5b       	cp.w	r11,5
80009c82:	c0 a1       	brne	80009c96 <_dtoa_r+0x2aa>
80009c84:	30 1a       	mov	r10,1
80009c86:	50 da       	stdsp	sp[0x34],r10
80009c88:	c2 28       	rjmp	80009ccc <_dtoa_r+0x2e0>
80009c8a:	30 19       	mov	r9,1
80009c8c:	50 d9       	stdsp	sp[0x34],r9
80009c8e:	c0 f8       	rjmp	80009cac <_dtoa_r+0x2c0>
80009c90:	30 08       	mov	r8,0
80009c92:	30 14       	mov	r4,1
80009c94:	50 c8       	stdsp	sp[0x30],r8
80009c96:	3f f5       	mov	r5,-1
80009c98:	30 1c       	mov	r12,1
80009c9a:	30 0b       	mov	r11,0
80009c9c:	50 95       	stdsp	sp[0x24],r5
80009c9e:	50 dc       	stdsp	sp[0x34],r12
80009ca0:	0a 91       	mov	r1,r5
80009ca2:	31 28       	mov	r8,18
80009ca4:	50 eb       	stdsp	sp[0x38],r11
80009ca6:	c2 08       	rjmp	80009ce6 <_dtoa_r+0x2fa>
80009ca8:	30 0a       	mov	r10,0
80009caa:	50 da       	stdsp	sp[0x34],r10
80009cac:	40 e9       	lddsp	r9,sp[0x38]
80009cae:	58 09       	cp.w	r9,0
80009cb0:	e0 89 00 07 	brgt	80009cbe <_dtoa_r+0x2d2>
80009cb4:	30 18       	mov	r8,1
80009cb6:	50 98       	stdsp	sp[0x24],r8
80009cb8:	10 91       	mov	r1,r8
80009cba:	50 e8       	stdsp	sp[0x38],r8
80009cbc:	c1 58       	rjmp	80009ce6 <_dtoa_r+0x2fa>
80009cbe:	40 e5       	lddsp	r5,sp[0x38]
80009cc0:	50 95       	stdsp	sp[0x24],r5
80009cc2:	0a 91       	mov	r1,r5
80009cc4:	0a 98       	mov	r8,r5
80009cc6:	c1 08       	rjmp	80009ce6 <_dtoa_r+0x2fa>
80009cc8:	30 0c       	mov	r12,0
80009cca:	50 dc       	stdsp	sp[0x34],r12
80009ccc:	40 eb       	lddsp	r11,sp[0x38]
80009cce:	ec 0b 00 0b 	add	r11,r6,r11
80009cd2:	50 9b       	stdsp	sp[0x24],r11
80009cd4:	16 98       	mov	r8,r11
80009cd6:	2f f8       	sub	r8,-1
80009cd8:	58 08       	cp.w	r8,0
80009cda:	e0 89 00 05 	brgt	80009ce4 <_dtoa_r+0x2f8>
80009cde:	10 91       	mov	r1,r8
80009ce0:	30 18       	mov	r8,1
80009ce2:	c0 28       	rjmp	80009ce6 <_dtoa_r+0x2fa>
80009ce4:	10 91       	mov	r1,r8
80009ce6:	30 09       	mov	r9,0
80009ce8:	6e 9a       	ld.w	r10,r7[0x24]
80009cea:	95 19       	st.w	r10[0x4],r9
80009cec:	30 49       	mov	r9,4
80009cee:	c0 78       	rjmp	80009cfc <_dtoa_r+0x310>
80009cf0:	80 01       	ld.sh	r1,r0[0x0]
80009cf2:	61 c8       	ld.w	r8,r0[0x70]
80009cf4:	6a 1a       	ld.w	r10,r5[0x4]
80009cf6:	a1 79       	lsl	r9,0x1
80009cf8:	2f fa       	sub	r10,-1
80009cfa:	8b 1a       	st.w	r5[0x4],r10
80009cfc:	6e 95       	ld.w	r5,r7[0x24]
80009cfe:	f2 ca ff ec 	sub	r10,r9,-20
80009d02:	10 3a       	cp.w	r10,r8
80009d04:	fe 98 ff f8 	brls	80009cf4 <_dtoa_r+0x308>
80009d08:	6a 1b       	ld.w	r11,r5[0x4]
80009d0a:	0e 9c       	mov	r12,r7
80009d0c:	e0 a0 09 48 	rcall	8000af9c <_Balloc>
80009d10:	58 e1       	cp.w	r1,14
80009d12:	5f 88       	srls	r8
80009d14:	8b 0c       	st.w	r5[0x0],r12
80009d16:	f1 e4 00 04 	and	r4,r8,r4
80009d1a:	6e 98       	ld.w	r8,r7[0x24]
80009d1c:	70 08       	ld.w	r8,r8[0x0]
80009d1e:	50 88       	stdsp	sp[0x20],r8
80009d20:	e0 80 01 82 	breq	8000a024 <_dtoa_r+0x638>
80009d24:	58 06       	cp.w	r6,0
80009d26:	e0 8a 00 40 	brle	80009da6 <_dtoa_r+0x3ba>
80009d2a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009d2e:	4c b8       	lddpc	r8,80009e58 <_dtoa_r+0x46c>
80009d30:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009d34:	fa e5 00 18 	st.d	sp[24],r4
80009d38:	ec 04 14 04 	asr	r4,r6,0x4
80009d3c:	ed b4 00 04 	bld	r4,0x4
80009d40:	c0 30       	breq	80009d46 <_dtoa_r+0x35a>
80009d42:	30 25       	mov	r5,2
80009d44:	c0 f8       	rjmp	80009d62 <_dtoa_r+0x376>
80009d46:	4c 68       	lddpc	r8,80009e5c <_dtoa_r+0x470>
80009d48:	f0 e8 00 20 	ld.d	r8,r8[32]
80009d4c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009d50:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009d54:	e0 a0 0f f8 	rcall	8000bd44 <__avr32_f64_div>
80009d58:	30 35       	mov	r5,3
80009d5a:	14 98       	mov	r8,r10
80009d5c:	16 99       	mov	r9,r11
80009d5e:	fa e9 00 08 	st.d	sp[8],r8
80009d62:	4b fc       	lddpc	r12,80009e5c <_dtoa_r+0x470>
80009d64:	50 a3       	stdsp	sp[0x28],r3
80009d66:	0c 93       	mov	r3,r6
80009d68:	18 96       	mov	r6,r12
80009d6a:	c0 f8       	rjmp	80009d88 <_dtoa_r+0x39c>
80009d6c:	fa ea 00 18 	ld.d	r10,sp[24]
80009d70:	ed b4 00 00 	bld	r4,0x0
80009d74:	c0 81       	brne	80009d84 <_dtoa_r+0x398>
80009d76:	ec e8 00 00 	ld.d	r8,r6[0]
80009d7a:	2f f5       	sub	r5,-1
80009d7c:	e0 a0 0c 9e 	rcall	8000b6b8 <__avr32_f64_mul>
80009d80:	fa eb 00 18 	st.d	sp[24],r10
80009d84:	a1 54       	asr	r4,0x1
80009d86:	2f 86       	sub	r6,-8
80009d88:	58 04       	cp.w	r4,0
80009d8a:	cf 11       	brne	80009d6c <_dtoa_r+0x380>
80009d8c:	fa e8 00 18 	ld.d	r8,sp[24]
80009d90:	fa ea 00 08 	ld.d	r10,sp[8]
80009d94:	06 96       	mov	r6,r3
80009d96:	e0 a0 0f d7 	rcall	8000bd44 <__avr32_f64_div>
80009d9a:	40 a3       	lddsp	r3,sp[0x28]
80009d9c:	14 98       	mov	r8,r10
80009d9e:	16 99       	mov	r9,r11
80009da0:	fa e9 00 08 	st.d	sp[8],r8
80009da4:	c2 d8       	rjmp	80009dfe <_dtoa_r+0x412>
80009da6:	ec 08 11 00 	rsub	r8,r6,0
80009daa:	c0 31       	brne	80009db0 <_dtoa_r+0x3c4>
80009dac:	30 25       	mov	r5,2
80009dae:	c2 88       	rjmp	80009dfe <_dtoa_r+0x412>
80009db0:	4a bc       	lddpc	r12,80009e5c <_dtoa_r+0x470>
80009db2:	f0 04 14 04 	asr	r4,r8,0x4
80009db6:	50 1c       	stdsp	sp[0x4],r12
80009db8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009dbc:	4a 79       	lddpc	r9,80009e58 <_dtoa_r+0x46c>
80009dbe:	fa ea 00 3c 	ld.d	r10,sp[60]
80009dc2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009dc6:	e0 a0 0c 79 	rcall	8000b6b8 <__avr32_f64_mul>
80009dca:	40 1c       	lddsp	r12,sp[0x4]
80009dcc:	50 63       	stdsp	sp[0x18],r3
80009dce:	30 25       	mov	r5,2
80009dd0:	0c 93       	mov	r3,r6
80009dd2:	fa eb 00 08 	st.d	sp[8],r10
80009dd6:	18 96       	mov	r6,r12
80009dd8:	c0 f8       	rjmp	80009df6 <_dtoa_r+0x40a>
80009dda:	fa ea 00 08 	ld.d	r10,sp[8]
80009dde:	ed b4 00 00 	bld	r4,0x0
80009de2:	c0 81       	brne	80009df2 <_dtoa_r+0x406>
80009de4:	ec e8 00 00 	ld.d	r8,r6[0]
80009de8:	2f f5       	sub	r5,-1
80009dea:	e0 a0 0c 67 	rcall	8000b6b8 <__avr32_f64_mul>
80009dee:	fa eb 00 08 	st.d	sp[8],r10
80009df2:	a1 54       	asr	r4,0x1
80009df4:	2f 86       	sub	r6,-8
80009df6:	58 04       	cp.w	r4,0
80009df8:	cf 11       	brne	80009dda <_dtoa_r+0x3ee>
80009dfa:	06 96       	mov	r6,r3
80009dfc:	40 63       	lddsp	r3,sp[0x18]
80009dfe:	41 4a       	lddsp	r10,sp[0x50]
80009e00:	58 0a       	cp.w	r10,0
80009e02:	c2 f0       	breq	80009e60 <_dtoa_r+0x474>
80009e04:	fa e8 00 08 	ld.d	r8,sp[8]
80009e08:	58 01       	cp.w	r1,0
80009e0a:	5f 94       	srgt	r4
80009e0c:	fa e9 00 18 	st.d	sp[24],r8
80009e10:	30 08       	mov	r8,0
80009e12:	fc 19 3f f0 	movh	r9,0x3ff0
80009e16:	fa ea 00 18 	ld.d	r10,sp[24]
80009e1a:	e0 a0 0f 61 	rcall	8000bcdc <__avr32_f64_cmp_lt>
80009e1e:	f9 bc 00 00 	moveq	r12,0
80009e22:	f9 bc 01 01 	movne	r12,1
80009e26:	e9 ec 00 0c 	and	r12,r4,r12
80009e2a:	c1 b0       	breq	80009e60 <_dtoa_r+0x474>
80009e2c:	40 98       	lddsp	r8,sp[0x24]
80009e2e:	58 08       	cp.w	r8,0
80009e30:	e0 8a 00 f6 	brle	8000a01c <_dtoa_r+0x630>
80009e34:	30 08       	mov	r8,0
80009e36:	fc 19 40 24 	movh	r9,0x4024
80009e3a:	ec c4 00 01 	sub	r4,r6,1
80009e3e:	fa ea 00 18 	ld.d	r10,sp[24]
80009e42:	2f f5       	sub	r5,-1
80009e44:	50 64       	stdsp	sp[0x18],r4
80009e46:	e0 a0 0c 39 	rcall	8000b6b8 <__avr32_f64_mul>
80009e4a:	40 94       	lddsp	r4,sp[0x24]
80009e4c:	14 98       	mov	r8,r10
80009e4e:	16 99       	mov	r9,r11
80009e50:	fa e9 00 08 	st.d	sp[8],r8
80009e54:	c0 88       	rjmp	80009e64 <_dtoa_r+0x478>
80009e56:	d7 03       	nop
80009e58:	80 01       	ld.sh	r1,r0[0x0]
80009e5a:	61 c8       	ld.w	r8,r0[0x70]
80009e5c:	80 01       	ld.sh	r1,r0[0x0]
80009e5e:	62 90       	ld.w	r0,r1[0x24]
80009e60:	50 66       	stdsp	sp[0x18],r6
80009e62:	02 94       	mov	r4,r1
80009e64:	0a 9c       	mov	r12,r5
80009e66:	e0 a0 0e 84 	rcall	8000bb6e <__avr32_s32_to_f64>
80009e6a:	fa e8 00 08 	ld.d	r8,sp[8]
80009e6e:	e0 a0 0c 25 	rcall	8000b6b8 <__avr32_f64_mul>
80009e72:	30 08       	mov	r8,0
80009e74:	fc 19 40 1c 	movh	r9,0x401c
80009e78:	e0 a0 0d da 	rcall	8000ba2c <__avr32_f64_add>
80009e7c:	14 98       	mov	r8,r10
80009e7e:	16 99       	mov	r9,r11
80009e80:	fa e9 00 28 	st.d	sp[40],r8
80009e84:	fc 18 fc c0 	movh	r8,0xfcc0
80009e88:	40 a5       	lddsp	r5,sp[0x28]
80009e8a:	10 05       	add	r5,r8
80009e8c:	50 a5       	stdsp	sp[0x28],r5
80009e8e:	58 04       	cp.w	r4,0
80009e90:	c2 11       	brne	80009ed2 <_dtoa_r+0x4e6>
80009e92:	fa ea 00 08 	ld.d	r10,sp[8]
80009e96:	30 08       	mov	r8,0
80009e98:	fc 19 40 14 	movh	r9,0x4014
80009e9c:	e0 a0 0c fa 	rcall	8000b890 <__avr32_f64_sub>
80009ea0:	40 bc       	lddsp	r12,sp[0x2c]
80009ea2:	fa eb 00 08 	st.d	sp[8],r10
80009ea6:	14 98       	mov	r8,r10
80009ea8:	16 99       	mov	r9,r11
80009eaa:	18 9a       	mov	r10,r12
80009eac:	0a 9b       	mov	r11,r5
80009eae:	e0 a0 0f 17 	rcall	8000bcdc <__avr32_f64_cmp_lt>
80009eb2:	e0 81 02 54 	brne	8000a35a <_dtoa_r+0x96e>
80009eb6:	0a 98       	mov	r8,r5
80009eb8:	40 b9       	lddsp	r9,sp[0x2c]
80009eba:	ee 18 80 00 	eorh	r8,0x8000
80009ebe:	fa ea 00 08 	ld.d	r10,sp[8]
80009ec2:	10 95       	mov	r5,r8
80009ec4:	12 98       	mov	r8,r9
80009ec6:	0a 99       	mov	r9,r5
80009ec8:	e0 a0 0f 0a 	rcall	8000bcdc <__avr32_f64_cmp_lt>
80009ecc:	e0 81 02 3e 	brne	8000a348 <_dtoa_r+0x95c>
80009ed0:	ca 68       	rjmp	8000a01c <_dtoa_r+0x630>
80009ed2:	4c e9       	lddpc	r9,8000a008 <_dtoa_r+0x61c>
80009ed4:	e8 c8 00 01 	sub	r8,r4,1
80009ed8:	40 d5       	lddsp	r5,sp[0x34]
80009eda:	58 05       	cp.w	r5,0
80009edc:	c4 f0       	breq	80009f7a <_dtoa_r+0x58e>
80009ede:	30 0c       	mov	r12,0
80009ee0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009ee4:	51 3c       	stdsp	sp[0x4c],r12
80009ee6:	30 0a       	mov	r10,0
80009ee8:	fc 1b 3f e0 	movh	r11,0x3fe0
80009eec:	e0 a0 0f 2c 	rcall	8000bd44 <__avr32_f64_div>
80009ef0:	fa e8 00 28 	ld.d	r8,sp[40]
80009ef4:	40 85       	lddsp	r5,sp[0x20]
80009ef6:	e0 a0 0c cd 	rcall	8000b890 <__avr32_f64_sub>
80009efa:	fa eb 00 28 	st.d	sp[40],r10
80009efe:	fa ea 00 08 	ld.d	r10,sp[8]
80009f02:	e0 a0 0e 1f 	rcall	8000bb40 <__avr32_f64_to_s32>
80009f06:	51 6c       	stdsp	sp[0x58],r12
80009f08:	e0 a0 0e 33 	rcall	8000bb6e <__avr32_s32_to_f64>
80009f0c:	14 98       	mov	r8,r10
80009f0e:	16 99       	mov	r9,r11
80009f10:	fa ea 00 08 	ld.d	r10,sp[8]
80009f14:	e0 a0 0c be 	rcall	8000b890 <__avr32_f64_sub>
80009f18:	fa eb 00 08 	st.d	sp[8],r10
80009f1c:	41 68       	lddsp	r8,sp[0x58]
80009f1e:	2d 08       	sub	r8,-48
80009f20:	0a c8       	st.b	r5++,r8
80009f22:	41 39       	lddsp	r9,sp[0x4c]
80009f24:	2f f9       	sub	r9,-1
80009f26:	51 39       	stdsp	sp[0x4c],r9
80009f28:	fa e8 00 28 	ld.d	r8,sp[40]
80009f2c:	e0 a0 0e d8 	rcall	8000bcdc <__avr32_f64_cmp_lt>
80009f30:	e0 81 03 3a 	brne	8000a5a4 <_dtoa_r+0xbb8>
80009f34:	fa e8 00 08 	ld.d	r8,sp[8]
80009f38:	30 0a       	mov	r10,0
80009f3a:	fc 1b 3f f0 	movh	r11,0x3ff0
80009f3e:	e0 a0 0c a9 	rcall	8000b890 <__avr32_f64_sub>
80009f42:	fa e8 00 28 	ld.d	r8,sp[40]
80009f46:	e0 a0 0e cb 	rcall	8000bcdc <__avr32_f64_cmp_lt>
80009f4a:	fa ea 00 28 	ld.d	r10,sp[40]
80009f4e:	30 08       	mov	r8,0
80009f50:	fc 19 40 24 	movh	r9,0x4024
80009f54:	e0 81 00 da 	brne	8000a108 <_dtoa_r+0x71c>
80009f58:	41 3c       	lddsp	r12,sp[0x4c]
80009f5a:	08 3c       	cp.w	r12,r4
80009f5c:	c6 04       	brge	8000a01c <_dtoa_r+0x630>
80009f5e:	e0 a0 0b ad 	rcall	8000b6b8 <__avr32_f64_mul>
80009f62:	30 08       	mov	r8,0
80009f64:	fa eb 00 28 	st.d	sp[40],r10
80009f68:	fc 19 40 24 	movh	r9,0x4024
80009f6c:	fa ea 00 08 	ld.d	r10,sp[8]
80009f70:	e0 a0 0b a4 	rcall	8000b6b8 <__avr32_f64_mul>
80009f74:	fa eb 00 08 	st.d	sp[8],r10
80009f78:	cc 3b       	rjmp	80009efe <_dtoa_r+0x512>
80009f7a:	40 85       	lddsp	r5,sp[0x20]
80009f7c:	08 05       	add	r5,r4
80009f7e:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009f82:	51 35       	stdsp	sp[0x4c],r5
80009f84:	fa e8 00 28 	ld.d	r8,sp[40]
80009f88:	40 85       	lddsp	r5,sp[0x20]
80009f8a:	e0 a0 0b 97 	rcall	8000b6b8 <__avr32_f64_mul>
80009f8e:	fa eb 00 28 	st.d	sp[40],r10
80009f92:	fa ea 00 08 	ld.d	r10,sp[8]
80009f96:	e0 a0 0d d5 	rcall	8000bb40 <__avr32_f64_to_s32>
80009f9a:	51 6c       	stdsp	sp[0x58],r12
80009f9c:	e0 a0 0d e9 	rcall	8000bb6e <__avr32_s32_to_f64>
80009fa0:	14 98       	mov	r8,r10
80009fa2:	16 99       	mov	r9,r11
80009fa4:	fa ea 00 08 	ld.d	r10,sp[8]
80009fa8:	e0 a0 0c 74 	rcall	8000b890 <__avr32_f64_sub>
80009fac:	fa eb 00 08 	st.d	sp[8],r10
80009fb0:	41 68       	lddsp	r8,sp[0x58]
80009fb2:	2d 08       	sub	r8,-48
80009fb4:	0a c8       	st.b	r5++,r8
80009fb6:	41 3c       	lddsp	r12,sp[0x4c]
80009fb8:	18 35       	cp.w	r5,r12
80009fba:	c2 91       	brne	8000a00c <_dtoa_r+0x620>
80009fbc:	30 08       	mov	r8,0
80009fbe:	fc 19 3f e0 	movh	r9,0x3fe0
80009fc2:	fa ea 00 28 	ld.d	r10,sp[40]
80009fc6:	e0 a0 0d 33 	rcall	8000ba2c <__avr32_f64_add>
80009fca:	40 85       	lddsp	r5,sp[0x20]
80009fcc:	fa e8 00 08 	ld.d	r8,sp[8]
80009fd0:	08 05       	add	r5,r4
80009fd2:	e0 a0 0e 85 	rcall	8000bcdc <__avr32_f64_cmp_lt>
80009fd6:	e0 81 00 99 	brne	8000a108 <_dtoa_r+0x71c>
80009fda:	fa e8 00 28 	ld.d	r8,sp[40]
80009fde:	30 0a       	mov	r10,0
80009fe0:	fc 1b 3f e0 	movh	r11,0x3fe0
80009fe4:	e0 a0 0c 56 	rcall	8000b890 <__avr32_f64_sub>
80009fe8:	14 98       	mov	r8,r10
80009fea:	16 99       	mov	r9,r11
80009fec:	fa ea 00 08 	ld.d	r10,sp[8]
80009ff0:	e0 a0 0e 76 	rcall	8000bcdc <__avr32_f64_cmp_lt>
80009ff4:	c1 40       	breq	8000a01c <_dtoa_r+0x630>
80009ff6:	33 09       	mov	r9,48
80009ff8:	0a 98       	mov	r8,r5
80009ffa:	11 7a       	ld.ub	r10,--r8
80009ffc:	f2 0a 18 00 	cp.b	r10,r9
8000a000:	e0 81 02 d2 	brne	8000a5a4 <_dtoa_r+0xbb8>
8000a004:	10 95       	mov	r5,r8
8000a006:	cf 9b       	rjmp	80009ff8 <_dtoa_r+0x60c>
8000a008:	80 01       	ld.sh	r1,r0[0x0]
8000a00a:	61 c8       	ld.w	r8,r0[0x70]
8000a00c:	30 08       	mov	r8,0
8000a00e:	fc 19 40 24 	movh	r9,0x4024
8000a012:	e0 a0 0b 53 	rcall	8000b6b8 <__avr32_f64_mul>
8000a016:	fa eb 00 08 	st.d	sp[8],r10
8000a01a:	cb cb       	rjmp	80009f92 <_dtoa_r+0x5a6>
8000a01c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a020:	fa eb 00 08 	st.d	sp[8],r10
8000a024:	58 e6       	cp.w	r6,14
8000a026:	5f ab       	srle	r11
8000a028:	41 8a       	lddsp	r10,sp[0x60]
8000a02a:	30 08       	mov	r8,0
8000a02c:	f4 09 11 ff 	rsub	r9,r10,-1
8000a030:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a034:	f0 09 18 00 	cp.b	r9,r8
8000a038:	e0 80 00 81 	breq	8000a13a <_dtoa_r+0x74e>
8000a03c:	40 ea       	lddsp	r10,sp[0x38]
8000a03e:	58 01       	cp.w	r1,0
8000a040:	5f a9       	srle	r9
8000a042:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a046:	4c 9a       	lddpc	r10,8000a168 <_dtoa_r+0x77c>
8000a048:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a04c:	fa e5 00 10 	st.d	sp[16],r4
8000a050:	f0 09 18 00 	cp.b	r9,r8
8000a054:	c1 40       	breq	8000a07c <_dtoa_r+0x690>
8000a056:	58 01       	cp.w	r1,0
8000a058:	e0 81 01 78 	brne	8000a348 <_dtoa_r+0x95c>
8000a05c:	30 08       	mov	r8,0
8000a05e:	fc 19 40 14 	movh	r9,0x4014
8000a062:	08 9a       	mov	r10,r4
8000a064:	0a 9b       	mov	r11,r5
8000a066:	e0 a0 0b 29 	rcall	8000b6b8 <__avr32_f64_mul>
8000a06a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a06e:	e0 a0 0e 03 	rcall	8000bc74 <__avr32_f64_cmp_ge>
8000a072:	e0 81 01 6b 	brne	8000a348 <_dtoa_r+0x95c>
8000a076:	02 92       	mov	r2,r1
8000a078:	e0 8f 01 73 	bral	8000a35e <_dtoa_r+0x972>
8000a07c:	40 85       	lddsp	r5,sp[0x20]
8000a07e:	30 14       	mov	r4,1
8000a080:	fa e8 00 10 	ld.d	r8,sp[16]
8000a084:	fa ea 00 08 	ld.d	r10,sp[8]
8000a088:	e0 a0 0e 5e 	rcall	8000bd44 <__avr32_f64_div>
8000a08c:	e0 a0 0d 5a 	rcall	8000bb40 <__avr32_f64_to_s32>
8000a090:	18 92       	mov	r2,r12
8000a092:	e0 a0 0d 6e 	rcall	8000bb6e <__avr32_s32_to_f64>
8000a096:	fa e8 00 10 	ld.d	r8,sp[16]
8000a09a:	e0 a0 0b 0f 	rcall	8000b6b8 <__avr32_f64_mul>
8000a09e:	14 98       	mov	r8,r10
8000a0a0:	16 99       	mov	r9,r11
8000a0a2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0a6:	e0 a0 0b f5 	rcall	8000b890 <__avr32_f64_sub>
8000a0aa:	fa eb 00 08 	st.d	sp[8],r10
8000a0ae:	e4 c8 ff d0 	sub	r8,r2,-48
8000a0b2:	0a c8       	st.b	r5++,r8
8000a0b4:	fc 19 40 24 	movh	r9,0x4024
8000a0b8:	30 08       	mov	r8,0
8000a0ba:	02 34       	cp.w	r4,r1
8000a0bc:	c3 31       	brne	8000a122 <_dtoa_r+0x736>
8000a0be:	fa e8 00 08 	ld.d	r8,sp[8]
8000a0c2:	e0 a0 0c b5 	rcall	8000ba2c <__avr32_f64_add>
8000a0c6:	16 91       	mov	r1,r11
8000a0c8:	14 90       	mov	r0,r10
8000a0ca:	14 98       	mov	r8,r10
8000a0cc:	02 99       	mov	r9,r1
8000a0ce:	fa ea 00 10 	ld.d	r10,sp[16]
8000a0d2:	e0 a0 0e 05 	rcall	8000bcdc <__avr32_f64_cmp_lt>
8000a0d6:	c1 a1       	brne	8000a10a <_dtoa_r+0x71e>
8000a0d8:	fa e8 00 10 	ld.d	r8,sp[16]
8000a0dc:	00 9a       	mov	r10,r0
8000a0de:	02 9b       	mov	r11,r1
8000a0e0:	e0 a0 0d b7 	rcall	8000bc4e <__avr32_f64_cmp_eq>
8000a0e4:	e0 80 02 5f 	breq	8000a5a2 <_dtoa_r+0xbb6>
8000a0e8:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a0ec:	c0 f1       	brne	8000a10a <_dtoa_r+0x71e>
8000a0ee:	e0 8f 02 5a 	bral	8000a5a2 <_dtoa_r+0xbb6>
8000a0f2:	40 8a       	lddsp	r10,sp[0x20]
8000a0f4:	14 38       	cp.w	r8,r10
8000a0f6:	c0 30       	breq	8000a0fc <_dtoa_r+0x710>
8000a0f8:	10 95       	mov	r5,r8
8000a0fa:	c0 98       	rjmp	8000a10c <_dtoa_r+0x720>
8000a0fc:	33 08       	mov	r8,48
8000a0fe:	40 89       	lddsp	r9,sp[0x20]
8000a100:	2f f6       	sub	r6,-1
8000a102:	b2 88       	st.b	r9[0x0],r8
8000a104:	40 88       	lddsp	r8,sp[0x20]
8000a106:	c0 88       	rjmp	8000a116 <_dtoa_r+0x72a>
8000a108:	40 66       	lddsp	r6,sp[0x18]
8000a10a:	33 99       	mov	r9,57
8000a10c:	0a 98       	mov	r8,r5
8000a10e:	11 7a       	ld.ub	r10,--r8
8000a110:	f2 0a 18 00 	cp.b	r10,r9
8000a114:	ce f0       	breq	8000a0f2 <_dtoa_r+0x706>
8000a116:	50 66       	stdsp	sp[0x18],r6
8000a118:	11 89       	ld.ub	r9,r8[0x0]
8000a11a:	2f f9       	sub	r9,-1
8000a11c:	b0 89       	st.b	r8[0x0],r9
8000a11e:	e0 8f 02 43 	bral	8000a5a4 <_dtoa_r+0xbb8>
8000a122:	e0 a0 0a cb 	rcall	8000b6b8 <__avr32_f64_mul>
8000a126:	2f f4       	sub	r4,-1
8000a128:	fa eb 00 08 	st.d	sp[8],r10
8000a12c:	30 08       	mov	r8,0
8000a12e:	30 09       	mov	r9,0
8000a130:	e0 a0 0d 8f 	rcall	8000bc4e <__avr32_f64_cmp_eq>
8000a134:	ca 60       	breq	8000a080 <_dtoa_r+0x694>
8000a136:	e0 8f 02 36 	bral	8000a5a2 <_dtoa_r+0xbb6>
8000a13a:	40 d8       	lddsp	r8,sp[0x34]
8000a13c:	58 08       	cp.w	r8,0
8000a13e:	c0 51       	brne	8000a148 <_dtoa_r+0x75c>
8000a140:	04 98       	mov	r8,r2
8000a142:	00 95       	mov	r5,r0
8000a144:	40 d4       	lddsp	r4,sp[0x34]
8000a146:	c3 88       	rjmp	8000a1b6 <_dtoa_r+0x7ca>
8000a148:	40 c5       	lddsp	r5,sp[0x30]
8000a14a:	58 15       	cp.w	r5,1
8000a14c:	e0 89 00 10 	brgt	8000a16c <_dtoa_r+0x780>
8000a150:	41 74       	lddsp	r4,sp[0x5c]
8000a152:	58 04       	cp.w	r4,0
8000a154:	c0 40       	breq	8000a15c <_dtoa_r+0x770>
8000a156:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a15a:	c0 48       	rjmp	8000a162 <_dtoa_r+0x776>
8000a15c:	41 99       	lddsp	r9,sp[0x64]
8000a15e:	f2 09 11 36 	rsub	r9,r9,54
8000a162:	04 98       	mov	r8,r2
8000a164:	00 95       	mov	r5,r0
8000a166:	c1 d8       	rjmp	8000a1a0 <_dtoa_r+0x7b4>
8000a168:	80 01       	ld.sh	r1,r0[0x0]
8000a16a:	61 c8       	ld.w	r8,r0[0x70]
8000a16c:	e2 c8 00 01 	sub	r8,r1,1
8000a170:	58 01       	cp.w	r1,0
8000a172:	e0 05 17 40 	movge	r5,r0
8000a176:	e2 09 17 40 	movge	r9,r1
8000a17a:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a17e:	f9 b9 05 00 	movlt	r9,0
8000a182:	10 32       	cp.w	r2,r8
8000a184:	e5 d8 e4 18 	subge	r8,r2,r8
8000a188:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a18c:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a190:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a194:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a198:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a19c:	f9 b8 05 00 	movlt	r8,0
8000a1a0:	40 4b       	lddsp	r11,sp[0x10]
8000a1a2:	12 0b       	add	r11,r9
8000a1a4:	50 08       	stdsp	sp[0x0],r8
8000a1a6:	50 4b       	stdsp	sp[0x10],r11
8000a1a8:	12 00       	add	r0,r9
8000a1aa:	30 1b       	mov	r11,1
8000a1ac:	0e 9c       	mov	r12,r7
8000a1ae:	e0 a0 08 ab 	rcall	8000b304 <__i2b>
8000a1b2:	40 08       	lddsp	r8,sp[0x0]
8000a1b4:	18 94       	mov	r4,r12
8000a1b6:	40 4a       	lddsp	r10,sp[0x10]
8000a1b8:	58 05       	cp.w	r5,0
8000a1ba:	5f 99       	srgt	r9
8000a1bc:	58 0a       	cp.w	r10,0
8000a1be:	5f 9a       	srgt	r10
8000a1c0:	f5 e9 00 09 	and	r9,r10,r9
8000a1c4:	c0 80       	breq	8000a1d4 <_dtoa_r+0x7e8>
8000a1c6:	40 4c       	lddsp	r12,sp[0x10]
8000a1c8:	f8 05 0d 49 	min	r9,r12,r5
8000a1cc:	12 1c       	sub	r12,r9
8000a1ce:	12 10       	sub	r0,r9
8000a1d0:	50 4c       	stdsp	sp[0x10],r12
8000a1d2:	12 15       	sub	r5,r9
8000a1d4:	58 02       	cp.w	r2,0
8000a1d6:	e0 8a 00 27 	brle	8000a224 <_dtoa_r+0x838>
8000a1da:	40 db       	lddsp	r11,sp[0x34]
8000a1dc:	58 0b       	cp.w	r11,0
8000a1de:	c1 d0       	breq	8000a218 <_dtoa_r+0x82c>
8000a1e0:	58 08       	cp.w	r8,0
8000a1e2:	e0 8a 00 17 	brle	8000a210 <_dtoa_r+0x824>
8000a1e6:	10 9a       	mov	r10,r8
8000a1e8:	50 08       	stdsp	sp[0x0],r8
8000a1ea:	08 9b       	mov	r11,r4
8000a1ec:	0e 9c       	mov	r12,r7
8000a1ee:	e0 a0 08 d1 	rcall	8000b390 <__pow5mult>
8000a1f2:	06 9a       	mov	r10,r3
8000a1f4:	18 9b       	mov	r11,r12
8000a1f6:	18 94       	mov	r4,r12
8000a1f8:	0e 9c       	mov	r12,r7
8000a1fa:	e0 a0 08 05 	rcall	8000b204 <__multiply>
8000a1fe:	18 99       	mov	r9,r12
8000a200:	06 9b       	mov	r11,r3
8000a202:	50 19       	stdsp	sp[0x4],r9
8000a204:	0e 9c       	mov	r12,r7
8000a206:	e0 a0 06 b1 	rcall	8000af68 <_Bfree>
8000a20a:	40 19       	lddsp	r9,sp[0x4]
8000a20c:	40 08       	lddsp	r8,sp[0x0]
8000a20e:	12 93       	mov	r3,r9
8000a210:	e4 08 01 0a 	sub	r10,r2,r8
8000a214:	c0 80       	breq	8000a224 <_dtoa_r+0x838>
8000a216:	c0 28       	rjmp	8000a21a <_dtoa_r+0x82e>
8000a218:	04 9a       	mov	r10,r2
8000a21a:	06 9b       	mov	r11,r3
8000a21c:	0e 9c       	mov	r12,r7
8000a21e:	e0 a0 08 b9 	rcall	8000b390 <__pow5mult>
8000a222:	18 93       	mov	r3,r12
8000a224:	30 1b       	mov	r11,1
8000a226:	0e 9c       	mov	r12,r7
8000a228:	e0 a0 08 6e 	rcall	8000b304 <__i2b>
8000a22c:	41 1a       	lddsp	r10,sp[0x44]
8000a22e:	18 92       	mov	r2,r12
8000a230:	58 0a       	cp.w	r10,0
8000a232:	e0 8a 00 07 	brle	8000a240 <_dtoa_r+0x854>
8000a236:	18 9b       	mov	r11,r12
8000a238:	0e 9c       	mov	r12,r7
8000a23a:	e0 a0 08 ab 	rcall	8000b390 <__pow5mult>
8000a23e:	18 92       	mov	r2,r12
8000a240:	40 c9       	lddsp	r9,sp[0x30]
8000a242:	58 19       	cp.w	r9,1
8000a244:	e0 89 00 14 	brgt	8000a26c <_dtoa_r+0x880>
8000a248:	40 38       	lddsp	r8,sp[0xc]
8000a24a:	58 08       	cp.w	r8,0
8000a24c:	c1 01       	brne	8000a26c <_dtoa_r+0x880>
8000a24e:	40 29       	lddsp	r9,sp[0x8]
8000a250:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a254:	c0 c1       	brne	8000a26c <_dtoa_r+0x880>
8000a256:	12 98       	mov	r8,r9
8000a258:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a25c:	c0 80       	breq	8000a26c <_dtoa_r+0x880>
8000a25e:	40 4c       	lddsp	r12,sp[0x10]
8000a260:	30 1b       	mov	r11,1
8000a262:	2f fc       	sub	r12,-1
8000a264:	2f f0       	sub	r0,-1
8000a266:	50 4c       	stdsp	sp[0x10],r12
8000a268:	50 6b       	stdsp	sp[0x18],r11
8000a26a:	c0 38       	rjmp	8000a270 <_dtoa_r+0x884>
8000a26c:	30 0a       	mov	r10,0
8000a26e:	50 6a       	stdsp	sp[0x18],r10
8000a270:	41 19       	lddsp	r9,sp[0x44]
8000a272:	58 09       	cp.w	r9,0
8000a274:	c0 31       	brne	8000a27a <_dtoa_r+0x88e>
8000a276:	30 1c       	mov	r12,1
8000a278:	c0 98       	rjmp	8000a28a <_dtoa_r+0x89e>
8000a27a:	64 48       	ld.w	r8,r2[0x10]
8000a27c:	2f c8       	sub	r8,-4
8000a27e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a282:	e0 a0 05 e3 	rcall	8000ae48 <__hi0bits>
8000a286:	f8 0c 11 20 	rsub	r12,r12,32
8000a28a:	40 4b       	lddsp	r11,sp[0x10]
8000a28c:	f8 0b 00 08 	add	r8,r12,r11
8000a290:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a294:	c0 c0       	breq	8000a2ac <_dtoa_r+0x8c0>
8000a296:	f0 08 11 20 	rsub	r8,r8,32
8000a29a:	58 48       	cp.w	r8,4
8000a29c:	e0 8a 00 06 	brle	8000a2a8 <_dtoa_r+0x8bc>
8000a2a0:	20 48       	sub	r8,4
8000a2a2:	10 0b       	add	r11,r8
8000a2a4:	50 4b       	stdsp	sp[0x10],r11
8000a2a6:	c0 78       	rjmp	8000a2b4 <_dtoa_r+0x8c8>
8000a2a8:	58 48       	cp.w	r8,4
8000a2aa:	c0 70       	breq	8000a2b8 <_dtoa_r+0x8cc>
8000a2ac:	40 4a       	lddsp	r10,sp[0x10]
8000a2ae:	2e 48       	sub	r8,-28
8000a2b0:	10 0a       	add	r10,r8
8000a2b2:	50 4a       	stdsp	sp[0x10],r10
8000a2b4:	10 00       	add	r0,r8
8000a2b6:	10 05       	add	r5,r8
8000a2b8:	58 00       	cp.w	r0,0
8000a2ba:	e0 8a 00 08 	brle	8000a2ca <_dtoa_r+0x8de>
8000a2be:	06 9b       	mov	r11,r3
8000a2c0:	00 9a       	mov	r10,r0
8000a2c2:	0e 9c       	mov	r12,r7
8000a2c4:	e0 a0 07 5c 	rcall	8000b17c <__lshift>
8000a2c8:	18 93       	mov	r3,r12
8000a2ca:	40 49       	lddsp	r9,sp[0x10]
8000a2cc:	58 09       	cp.w	r9,0
8000a2ce:	e0 8a 00 08 	brle	8000a2de <_dtoa_r+0x8f2>
8000a2d2:	04 9b       	mov	r11,r2
8000a2d4:	12 9a       	mov	r10,r9
8000a2d6:	0e 9c       	mov	r12,r7
8000a2d8:	e0 a0 07 52 	rcall	8000b17c <__lshift>
8000a2dc:	18 92       	mov	r2,r12
8000a2de:	41 48       	lddsp	r8,sp[0x50]
8000a2e0:	58 08       	cp.w	r8,0
8000a2e2:	c1 b0       	breq	8000a318 <_dtoa_r+0x92c>
8000a2e4:	04 9b       	mov	r11,r2
8000a2e6:	06 9c       	mov	r12,r3
8000a2e8:	e0 a0 06 27 	rcall	8000af36 <__mcmp>
8000a2ec:	c1 64       	brge	8000a318 <_dtoa_r+0x92c>
8000a2ee:	06 9b       	mov	r11,r3
8000a2f0:	30 09       	mov	r9,0
8000a2f2:	30 aa       	mov	r10,10
8000a2f4:	0e 9c       	mov	r12,r7
8000a2f6:	e0 a0 08 0f 	rcall	8000b314 <__multadd>
8000a2fa:	20 16       	sub	r6,1
8000a2fc:	18 93       	mov	r3,r12
8000a2fe:	40 dc       	lddsp	r12,sp[0x34]
8000a300:	58 0c       	cp.w	r12,0
8000a302:	c0 31       	brne	8000a308 <_dtoa_r+0x91c>
8000a304:	40 91       	lddsp	r1,sp[0x24]
8000a306:	c0 98       	rjmp	8000a318 <_dtoa_r+0x92c>
8000a308:	08 9b       	mov	r11,r4
8000a30a:	40 91       	lddsp	r1,sp[0x24]
8000a30c:	30 09       	mov	r9,0
8000a30e:	30 aa       	mov	r10,10
8000a310:	0e 9c       	mov	r12,r7
8000a312:	e0 a0 08 01 	rcall	8000b314 <__multadd>
8000a316:	18 94       	mov	r4,r12
8000a318:	58 01       	cp.w	r1,0
8000a31a:	5f a9       	srle	r9
8000a31c:	40 cb       	lddsp	r11,sp[0x30]
8000a31e:	58 2b       	cp.w	r11,2
8000a320:	5f 98       	srgt	r8
8000a322:	f3 e8 00 08 	and	r8,r9,r8
8000a326:	c2 50       	breq	8000a370 <_dtoa_r+0x984>
8000a328:	58 01       	cp.w	r1,0
8000a32a:	c1 11       	brne	8000a34c <_dtoa_r+0x960>
8000a32c:	04 9b       	mov	r11,r2
8000a32e:	02 99       	mov	r9,r1
8000a330:	30 5a       	mov	r10,5
8000a332:	0e 9c       	mov	r12,r7
8000a334:	e0 a0 07 f0 	rcall	8000b314 <__multadd>
8000a338:	18 92       	mov	r2,r12
8000a33a:	18 9b       	mov	r11,r12
8000a33c:	06 9c       	mov	r12,r3
8000a33e:	e0 a0 05 fc 	rcall	8000af36 <__mcmp>
8000a342:	e0 89 00 0f 	brgt	8000a360 <_dtoa_r+0x974>
8000a346:	c0 38       	rjmp	8000a34c <_dtoa_r+0x960>
8000a348:	30 02       	mov	r2,0
8000a34a:	04 94       	mov	r4,r2
8000a34c:	40 ea       	lddsp	r10,sp[0x38]
8000a34e:	30 09       	mov	r9,0
8000a350:	5c da       	com	r10
8000a352:	40 85       	lddsp	r5,sp[0x20]
8000a354:	50 6a       	stdsp	sp[0x18],r10
8000a356:	50 49       	stdsp	sp[0x10],r9
8000a358:	c0 f9       	rjmp	8000a576 <_dtoa_r+0xb8a>
8000a35a:	08 92       	mov	r2,r4
8000a35c:	40 66       	lddsp	r6,sp[0x18]
8000a35e:	04 94       	mov	r4,r2
8000a360:	2f f6       	sub	r6,-1
8000a362:	50 66       	stdsp	sp[0x18],r6
8000a364:	33 18       	mov	r8,49
8000a366:	40 85       	lddsp	r5,sp[0x20]
8000a368:	0a c8       	st.b	r5++,r8
8000a36a:	30 08       	mov	r8,0
8000a36c:	50 48       	stdsp	sp[0x10],r8
8000a36e:	c0 49       	rjmp	8000a576 <_dtoa_r+0xb8a>
8000a370:	40 dc       	lddsp	r12,sp[0x34]
8000a372:	58 0c       	cp.w	r12,0
8000a374:	e0 80 00 b5 	breq	8000a4de <_dtoa_r+0xaf2>
8000a378:	58 05       	cp.w	r5,0
8000a37a:	e0 8a 00 08 	brle	8000a38a <_dtoa_r+0x99e>
8000a37e:	08 9b       	mov	r11,r4
8000a380:	0a 9a       	mov	r10,r5
8000a382:	0e 9c       	mov	r12,r7
8000a384:	e0 a0 06 fc 	rcall	8000b17c <__lshift>
8000a388:	18 94       	mov	r4,r12
8000a38a:	40 6b       	lddsp	r11,sp[0x18]
8000a38c:	58 0b       	cp.w	r11,0
8000a38e:	c0 31       	brne	8000a394 <_dtoa_r+0x9a8>
8000a390:	08 9c       	mov	r12,r4
8000a392:	c1 38       	rjmp	8000a3b8 <_dtoa_r+0x9cc>
8000a394:	68 1b       	ld.w	r11,r4[0x4]
8000a396:	0e 9c       	mov	r12,r7
8000a398:	e0 a0 06 02 	rcall	8000af9c <_Balloc>
8000a39c:	68 4a       	ld.w	r10,r4[0x10]
8000a39e:	18 95       	mov	r5,r12
8000a3a0:	e8 cb ff f4 	sub	r11,r4,-12
8000a3a4:	2f ea       	sub	r10,-2
8000a3a6:	2f 4c       	sub	r12,-12
8000a3a8:	a3 6a       	lsl	r10,0x2
8000a3aa:	fe b0 e6 2d 	rcall	80007004 <memcpy>
8000a3ae:	0a 9b       	mov	r11,r5
8000a3b0:	30 1a       	mov	r10,1
8000a3b2:	0e 9c       	mov	r12,r7
8000a3b4:	e0 a0 06 e4 	rcall	8000b17c <__lshift>
8000a3b8:	50 44       	stdsp	sp[0x10],r4
8000a3ba:	40 3a       	lddsp	r10,sp[0xc]
8000a3bc:	30 19       	mov	r9,1
8000a3be:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a3c2:	18 94       	mov	r4,r12
8000a3c4:	50 da       	stdsp	sp[0x34],r10
8000a3c6:	40 85       	lddsp	r5,sp[0x20]
8000a3c8:	50 99       	stdsp	sp[0x24],r9
8000a3ca:	50 26       	stdsp	sp[0x8],r6
8000a3cc:	50 e1       	stdsp	sp[0x38],r1
8000a3ce:	04 9b       	mov	r11,r2
8000a3d0:	06 9c       	mov	r12,r3
8000a3d2:	fe b0 fa 7d 	rcall	800098cc <quorem>
8000a3d6:	40 4b       	lddsp	r11,sp[0x10]
8000a3d8:	f8 c0 ff d0 	sub	r0,r12,-48
8000a3dc:	06 9c       	mov	r12,r3
8000a3de:	e0 a0 05 ac 	rcall	8000af36 <__mcmp>
8000a3e2:	08 9a       	mov	r10,r4
8000a3e4:	50 6c       	stdsp	sp[0x18],r12
8000a3e6:	04 9b       	mov	r11,r2
8000a3e8:	0e 9c       	mov	r12,r7
8000a3ea:	e0 a0 06 61 	rcall	8000b0ac <__mdiff>
8000a3ee:	18 91       	mov	r1,r12
8000a3f0:	78 38       	ld.w	r8,r12[0xc]
8000a3f2:	58 08       	cp.w	r8,0
8000a3f4:	c0 30       	breq	8000a3fa <_dtoa_r+0xa0e>
8000a3f6:	30 16       	mov	r6,1
8000a3f8:	c0 68       	rjmp	8000a404 <_dtoa_r+0xa18>
8000a3fa:	18 9b       	mov	r11,r12
8000a3fc:	06 9c       	mov	r12,r3
8000a3fe:	e0 a0 05 9c 	rcall	8000af36 <__mcmp>
8000a402:	18 96       	mov	r6,r12
8000a404:	0e 9c       	mov	r12,r7
8000a406:	02 9b       	mov	r11,r1
8000a408:	e0 a0 05 b0 	rcall	8000af68 <_Bfree>
8000a40c:	40 cc       	lddsp	r12,sp[0x30]
8000a40e:	ed ec 10 08 	or	r8,r6,r12
8000a412:	c0 d1       	brne	8000a42c <_dtoa_r+0xa40>
8000a414:	40 db       	lddsp	r11,sp[0x34]
8000a416:	58 0b       	cp.w	r11,0
8000a418:	c0 a1       	brne	8000a42c <_dtoa_r+0xa40>
8000a41a:	40 26       	lddsp	r6,sp[0x8]
8000a41c:	e0 40 00 39 	cp.w	r0,57
8000a420:	c3 00       	breq	8000a480 <_dtoa_r+0xa94>
8000a422:	40 6a       	lddsp	r10,sp[0x18]
8000a424:	58 0a       	cp.w	r10,0
8000a426:	e0 89 00 24 	brgt	8000a46e <_dtoa_r+0xa82>
8000a42a:	c2 f8       	rjmp	8000a488 <_dtoa_r+0xa9c>
8000a42c:	40 69       	lddsp	r9,sp[0x18]
8000a42e:	58 09       	cp.w	r9,0
8000a430:	c0 85       	brlt	8000a440 <_dtoa_r+0xa54>
8000a432:	12 98       	mov	r8,r9
8000a434:	40 cc       	lddsp	r12,sp[0x30]
8000a436:	18 48       	or	r8,r12
8000a438:	c1 d1       	brne	8000a472 <_dtoa_r+0xa86>
8000a43a:	40 db       	lddsp	r11,sp[0x34]
8000a43c:	58 0b       	cp.w	r11,0
8000a43e:	c1 a1       	brne	8000a472 <_dtoa_r+0xa86>
8000a440:	0c 99       	mov	r9,r6
8000a442:	40 26       	lddsp	r6,sp[0x8]
8000a444:	58 09       	cp.w	r9,0
8000a446:	e0 8a 00 21 	brle	8000a488 <_dtoa_r+0xa9c>
8000a44a:	06 9b       	mov	r11,r3
8000a44c:	30 1a       	mov	r10,1
8000a44e:	0e 9c       	mov	r12,r7
8000a450:	e0 a0 06 96 	rcall	8000b17c <__lshift>
8000a454:	04 9b       	mov	r11,r2
8000a456:	18 93       	mov	r3,r12
8000a458:	e0 a0 05 6f 	rcall	8000af36 <__mcmp>
8000a45c:	e0 89 00 06 	brgt	8000a468 <_dtoa_r+0xa7c>
8000a460:	c1 41       	brne	8000a488 <_dtoa_r+0xa9c>
8000a462:	ed b0 00 00 	bld	r0,0x0
8000a466:	c1 11       	brne	8000a488 <_dtoa_r+0xa9c>
8000a468:	e0 40 00 39 	cp.w	r0,57
8000a46c:	c0 a0       	breq	8000a480 <_dtoa_r+0xa94>
8000a46e:	2f f0       	sub	r0,-1
8000a470:	c0 c8       	rjmp	8000a488 <_dtoa_r+0xa9c>
8000a472:	58 06       	cp.w	r6,0
8000a474:	e0 8a 00 0c 	brle	8000a48c <_dtoa_r+0xaa0>
8000a478:	40 26       	lddsp	r6,sp[0x8]
8000a47a:	e0 40 00 39 	cp.w	r0,57
8000a47e:	c0 41       	brne	8000a486 <_dtoa_r+0xa9a>
8000a480:	33 98       	mov	r8,57
8000a482:	0a c8       	st.b	r5++,r8
8000a484:	c6 78       	rjmp	8000a552 <_dtoa_r+0xb66>
8000a486:	2f f0       	sub	r0,-1
8000a488:	0a c0       	st.b	r5++,r0
8000a48a:	c7 58       	rjmp	8000a574 <_dtoa_r+0xb88>
8000a48c:	0a c0       	st.b	r5++,r0
8000a48e:	40 9a       	lddsp	r10,sp[0x24]
8000a490:	40 e9       	lddsp	r9,sp[0x38]
8000a492:	12 3a       	cp.w	r10,r9
8000a494:	c4 30       	breq	8000a51a <_dtoa_r+0xb2e>
8000a496:	06 9b       	mov	r11,r3
8000a498:	30 09       	mov	r9,0
8000a49a:	30 aa       	mov	r10,10
8000a49c:	0e 9c       	mov	r12,r7
8000a49e:	e0 a0 07 3b 	rcall	8000b314 <__multadd>
8000a4a2:	40 48       	lddsp	r8,sp[0x10]
8000a4a4:	18 93       	mov	r3,r12
8000a4a6:	08 38       	cp.w	r8,r4
8000a4a8:	c0 91       	brne	8000a4ba <_dtoa_r+0xace>
8000a4aa:	10 9b       	mov	r11,r8
8000a4ac:	30 09       	mov	r9,0
8000a4ae:	30 aa       	mov	r10,10
8000a4b0:	0e 9c       	mov	r12,r7
8000a4b2:	e0 a0 07 31 	rcall	8000b314 <__multadd>
8000a4b6:	50 4c       	stdsp	sp[0x10],r12
8000a4b8:	c0 e8       	rjmp	8000a4d4 <_dtoa_r+0xae8>
8000a4ba:	40 4b       	lddsp	r11,sp[0x10]
8000a4bc:	30 09       	mov	r9,0
8000a4be:	30 aa       	mov	r10,10
8000a4c0:	0e 9c       	mov	r12,r7
8000a4c2:	e0 a0 07 29 	rcall	8000b314 <__multadd>
8000a4c6:	08 9b       	mov	r11,r4
8000a4c8:	50 4c       	stdsp	sp[0x10],r12
8000a4ca:	30 09       	mov	r9,0
8000a4cc:	30 aa       	mov	r10,10
8000a4ce:	0e 9c       	mov	r12,r7
8000a4d0:	e0 a0 07 22 	rcall	8000b314 <__multadd>
8000a4d4:	18 94       	mov	r4,r12
8000a4d6:	40 9c       	lddsp	r12,sp[0x24]
8000a4d8:	2f fc       	sub	r12,-1
8000a4da:	50 9c       	stdsp	sp[0x24],r12
8000a4dc:	c7 9b       	rjmp	8000a3ce <_dtoa_r+0x9e2>
8000a4de:	30 18       	mov	r8,1
8000a4e0:	06 90       	mov	r0,r3
8000a4e2:	40 85       	lddsp	r5,sp[0x20]
8000a4e4:	08 93       	mov	r3,r4
8000a4e6:	0c 94       	mov	r4,r6
8000a4e8:	10 96       	mov	r6,r8
8000a4ea:	04 9b       	mov	r11,r2
8000a4ec:	00 9c       	mov	r12,r0
8000a4ee:	fe b0 f9 ef 	rcall	800098cc <quorem>
8000a4f2:	2d 0c       	sub	r12,-48
8000a4f4:	0a cc       	st.b	r5++,r12
8000a4f6:	02 36       	cp.w	r6,r1
8000a4f8:	c0 a4       	brge	8000a50c <_dtoa_r+0xb20>
8000a4fa:	00 9b       	mov	r11,r0
8000a4fc:	30 09       	mov	r9,0
8000a4fe:	30 aa       	mov	r10,10
8000a500:	0e 9c       	mov	r12,r7
8000a502:	2f f6       	sub	r6,-1
8000a504:	e0 a0 07 08 	rcall	8000b314 <__multadd>
8000a508:	18 90       	mov	r0,r12
8000a50a:	cf 0b       	rjmp	8000a4ea <_dtoa_r+0xafe>
8000a50c:	08 96       	mov	r6,r4
8000a50e:	30 0b       	mov	r11,0
8000a510:	06 94       	mov	r4,r3
8000a512:	50 4b       	stdsp	sp[0x10],r11
8000a514:	00 93       	mov	r3,r0
8000a516:	18 90       	mov	r0,r12
8000a518:	c0 28       	rjmp	8000a51c <_dtoa_r+0xb30>
8000a51a:	40 26       	lddsp	r6,sp[0x8]
8000a51c:	06 9b       	mov	r11,r3
8000a51e:	30 1a       	mov	r10,1
8000a520:	0e 9c       	mov	r12,r7
8000a522:	e0 a0 06 2d 	rcall	8000b17c <__lshift>
8000a526:	04 9b       	mov	r11,r2
8000a528:	18 93       	mov	r3,r12
8000a52a:	e0 a0 05 06 	rcall	8000af36 <__mcmp>
8000a52e:	e0 89 00 12 	brgt	8000a552 <_dtoa_r+0xb66>
8000a532:	c1 b1       	brne	8000a568 <_dtoa_r+0xb7c>
8000a534:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a538:	c0 d1       	brne	8000a552 <_dtoa_r+0xb66>
8000a53a:	c1 78       	rjmp	8000a568 <_dtoa_r+0xb7c>
8000a53c:	40 89       	lddsp	r9,sp[0x20]
8000a53e:	12 38       	cp.w	r8,r9
8000a540:	c0 30       	breq	8000a546 <_dtoa_r+0xb5a>
8000a542:	10 95       	mov	r5,r8
8000a544:	c0 88       	rjmp	8000a554 <_dtoa_r+0xb68>
8000a546:	2f f6       	sub	r6,-1
8000a548:	50 66       	stdsp	sp[0x18],r6
8000a54a:	33 18       	mov	r8,49
8000a54c:	40 8c       	lddsp	r12,sp[0x20]
8000a54e:	b8 88       	st.b	r12[0x0],r8
8000a550:	c1 38       	rjmp	8000a576 <_dtoa_r+0xb8a>
8000a552:	33 9a       	mov	r10,57
8000a554:	0a 98       	mov	r8,r5
8000a556:	11 79       	ld.ub	r9,--r8
8000a558:	f4 09 18 00 	cp.b	r9,r10
8000a55c:	cf 00       	breq	8000a53c <_dtoa_r+0xb50>
8000a55e:	2f f9       	sub	r9,-1
8000a560:	b0 89       	st.b	r8[0x0],r9
8000a562:	c0 98       	rjmp	8000a574 <_dtoa_r+0xb88>
8000a564:	10 95       	mov	r5,r8
8000a566:	c0 28       	rjmp	8000a56a <_dtoa_r+0xb7e>
8000a568:	33 09       	mov	r9,48
8000a56a:	0a 98       	mov	r8,r5
8000a56c:	11 7a       	ld.ub	r10,--r8
8000a56e:	f2 0a 18 00 	cp.b	r10,r9
8000a572:	cf 90       	breq	8000a564 <_dtoa_r+0xb78>
8000a574:	50 66       	stdsp	sp[0x18],r6
8000a576:	04 9b       	mov	r11,r2
8000a578:	0e 9c       	mov	r12,r7
8000a57a:	e0 a0 04 f7 	rcall	8000af68 <_Bfree>
8000a57e:	58 04       	cp.w	r4,0
8000a580:	c1 20       	breq	8000a5a4 <_dtoa_r+0xbb8>
8000a582:	40 4b       	lddsp	r11,sp[0x10]
8000a584:	08 3b       	cp.w	r11,r4
8000a586:	5f 19       	srne	r9
8000a588:	58 0b       	cp.w	r11,0
8000a58a:	5f 18       	srne	r8
8000a58c:	f3 e8 00 08 	and	r8,r9,r8
8000a590:	c0 40       	breq	8000a598 <_dtoa_r+0xbac>
8000a592:	0e 9c       	mov	r12,r7
8000a594:	e0 a0 04 ea 	rcall	8000af68 <_Bfree>
8000a598:	08 9b       	mov	r11,r4
8000a59a:	0e 9c       	mov	r12,r7
8000a59c:	e0 a0 04 e6 	rcall	8000af68 <_Bfree>
8000a5a0:	c0 28       	rjmp	8000a5a4 <_dtoa_r+0xbb8>
8000a5a2:	50 66       	stdsp	sp[0x18],r6
8000a5a4:	0e 9c       	mov	r12,r7
8000a5a6:	06 9b       	mov	r11,r3
8000a5a8:	e0 a0 04 e0 	rcall	8000af68 <_Bfree>
8000a5ac:	30 08       	mov	r8,0
8000a5ae:	aa 88       	st.b	r5[0x0],r8
8000a5b0:	40 68       	lddsp	r8,sp[0x18]
8000a5b2:	41 5a       	lddsp	r10,sp[0x54]
8000a5b4:	2f f8       	sub	r8,-1
8000a5b6:	41 29       	lddsp	r9,sp[0x48]
8000a5b8:	95 08       	st.w	r10[0x0],r8
8000a5ba:	40 8c       	lddsp	r12,sp[0x20]
8000a5bc:	58 09       	cp.w	r9,0
8000a5be:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a5c2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a5c6:	2e 6d       	sub	sp,-104
8000a5c8:	d8 32       	popm	r0-r7,pc
8000a5ca:	d7 03       	nop

8000a5cc <__errno>:
8000a5cc:	e0 68 0a 30 	mov	r8,2608
8000a5d0:	70 0c       	ld.w	r12,r8[0x0]
8000a5d2:	2f 4c       	sub	r12,-12
8000a5d4:	5e fc       	retal	r12
8000a5d6:	d7 03       	nop

8000a5d8 <_fflush_r>:
8000a5d8:	d4 21       	pushm	r4-r7,lr
8000a5da:	16 97       	mov	r7,r11
8000a5dc:	18 96       	mov	r6,r12
8000a5de:	76 48       	ld.w	r8,r11[0x10]
8000a5e0:	58 08       	cp.w	r8,0
8000a5e2:	c7 c0       	breq	8000a6da <_fflush_r+0x102>
8000a5e4:	58 0c       	cp.w	r12,0
8000a5e6:	c0 50       	breq	8000a5f0 <_fflush_r+0x18>
8000a5e8:	78 68       	ld.w	r8,r12[0x18]
8000a5ea:	58 08       	cp.w	r8,0
8000a5ec:	c0 21       	brne	8000a5f0 <_fflush_r+0x18>
8000a5ee:	cd 1c       	rcall	8000a790 <__sinit>
8000a5f0:	4b b8       	lddpc	r8,8000a6dc <_fflush_r+0x104>
8000a5f2:	10 37       	cp.w	r7,r8
8000a5f4:	c0 31       	brne	8000a5fa <_fflush_r+0x22>
8000a5f6:	6c 07       	ld.w	r7,r6[0x0]
8000a5f8:	c0 a8       	rjmp	8000a60c <_fflush_r+0x34>
8000a5fa:	4b a8       	lddpc	r8,8000a6e0 <_fflush_r+0x108>
8000a5fc:	10 37       	cp.w	r7,r8
8000a5fe:	c0 31       	brne	8000a604 <_fflush_r+0x2c>
8000a600:	6c 17       	ld.w	r7,r6[0x4]
8000a602:	c0 58       	rjmp	8000a60c <_fflush_r+0x34>
8000a604:	4b 88       	lddpc	r8,8000a6e4 <_fflush_r+0x10c>
8000a606:	10 37       	cp.w	r7,r8
8000a608:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a60c:	8e 6a       	ld.sh	r10,r7[0xc]
8000a60e:	14 98       	mov	r8,r10
8000a610:	ed ba 00 03 	bld	r10,0x3
8000a614:	c4 20       	breq	8000a698 <_fflush_r+0xc0>
8000a616:	ab ba       	sbr	r10,0xb
8000a618:	ae 6a       	st.h	r7[0xc],r10
8000a61a:	6e 18       	ld.w	r8,r7[0x4]
8000a61c:	58 08       	cp.w	r8,0
8000a61e:	e0 89 00 06 	brgt	8000a62a <_fflush_r+0x52>
8000a622:	6f 08       	ld.w	r8,r7[0x40]
8000a624:	58 08       	cp.w	r8,0
8000a626:	e0 8a 00 5a 	brle	8000a6da <_fflush_r+0x102>
8000a62a:	6e b8       	ld.w	r8,r7[0x2c]
8000a62c:	58 08       	cp.w	r8,0
8000a62e:	c5 60       	breq	8000a6da <_fflush_r+0x102>
8000a630:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a634:	c0 30       	breq	8000a63a <_fflush_r+0x62>
8000a636:	6f 55       	ld.w	r5,r7[0x54]
8000a638:	c0 f8       	rjmp	8000a656 <_fflush_r+0x7e>
8000a63a:	30 19       	mov	r9,1
8000a63c:	6e 8b       	ld.w	r11,r7[0x20]
8000a63e:	0c 9c       	mov	r12,r6
8000a640:	5d 18       	icall	r8
8000a642:	18 95       	mov	r5,r12
8000a644:	5b fc       	cp.w	r12,-1
8000a646:	c0 81       	brne	8000a656 <_fflush_r+0x7e>
8000a648:	6c 38       	ld.w	r8,r6[0xc]
8000a64a:	59 d8       	cp.w	r8,29
8000a64c:	c4 70       	breq	8000a6da <_fflush_r+0x102>
8000a64e:	8e 68       	ld.sh	r8,r7[0xc]
8000a650:	a7 a8       	sbr	r8,0x6
8000a652:	ae 68       	st.h	r7[0xc],r8
8000a654:	d8 22       	popm	r4-r7,pc
8000a656:	8e 68       	ld.sh	r8,r7[0xc]
8000a658:	ed b8 00 02 	bld	r8,0x2
8000a65c:	c0 91       	brne	8000a66e <_fflush_r+0x96>
8000a65e:	6e 18       	ld.w	r8,r7[0x4]
8000a660:	10 15       	sub	r5,r8
8000a662:	6e d8       	ld.w	r8,r7[0x34]
8000a664:	58 08       	cp.w	r8,0
8000a666:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a66a:	eb d8 e1 15 	subne	r5,r5,r8
8000a66e:	6e b8       	ld.w	r8,r7[0x2c]
8000a670:	0c 9c       	mov	r12,r6
8000a672:	30 09       	mov	r9,0
8000a674:	0a 9a       	mov	r10,r5
8000a676:	6e 8b       	ld.w	r11,r7[0x20]
8000a678:	5d 18       	icall	r8
8000a67a:	8e 68       	ld.sh	r8,r7[0xc]
8000a67c:	0a 3c       	cp.w	r12,r5
8000a67e:	c2 61       	brne	8000a6ca <_fflush_r+0xf2>
8000a680:	ab d8       	cbr	r8,0xb
8000a682:	30 0c       	mov	r12,0
8000a684:	6e 49       	ld.w	r9,r7[0x10]
8000a686:	ae 68       	st.h	r7[0xc],r8
8000a688:	8f 1c       	st.w	r7[0x4],r12
8000a68a:	8f 09       	st.w	r7[0x0],r9
8000a68c:	ed b8 00 0c 	bld	r8,0xc
8000a690:	c2 51       	brne	8000a6da <_fflush_r+0x102>
8000a692:	ef 45 00 54 	st.w	r7[84],r5
8000a696:	d8 22       	popm	r4-r7,pc
8000a698:	6e 45       	ld.w	r5,r7[0x10]
8000a69a:	58 05       	cp.w	r5,0
8000a69c:	c1 f0       	breq	8000a6da <_fflush_r+0x102>
8000a69e:	6e 04       	ld.w	r4,r7[0x0]
8000a6a0:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a6a4:	8f 05       	st.w	r7[0x0],r5
8000a6a6:	f9 b8 01 00 	movne	r8,0
8000a6aa:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a6ae:	0a 14       	sub	r4,r5
8000a6b0:	8f 28       	st.w	r7[0x8],r8
8000a6b2:	c1 18       	rjmp	8000a6d4 <_fflush_r+0xfc>
8000a6b4:	08 99       	mov	r9,r4
8000a6b6:	0a 9a       	mov	r10,r5
8000a6b8:	6e a8       	ld.w	r8,r7[0x28]
8000a6ba:	6e 8b       	ld.w	r11,r7[0x20]
8000a6bc:	0c 9c       	mov	r12,r6
8000a6be:	5d 18       	icall	r8
8000a6c0:	18 14       	sub	r4,r12
8000a6c2:	58 0c       	cp.w	r12,0
8000a6c4:	e0 89 00 07 	brgt	8000a6d2 <_fflush_r+0xfa>
8000a6c8:	8e 68       	ld.sh	r8,r7[0xc]
8000a6ca:	a7 a8       	sbr	r8,0x6
8000a6cc:	3f fc       	mov	r12,-1
8000a6ce:	ae 68       	st.h	r7[0xc],r8
8000a6d0:	d8 22       	popm	r4-r7,pc
8000a6d2:	18 05       	add	r5,r12
8000a6d4:	58 04       	cp.w	r4,0
8000a6d6:	fe 99 ff ef 	brgt	8000a6b4 <_fflush_r+0xdc>
8000a6da:	d8 2a       	popm	r4-r7,pc,r12=0
8000a6dc:	80 01       	ld.sh	r1,r0[0x0]
8000a6de:	61 18       	ld.w	r8,r0[0x44]
8000a6e0:	80 01       	ld.sh	r1,r0[0x0]
8000a6e2:	61 38       	ld.w	r8,r0[0x4c]
8000a6e4:	80 01       	ld.sh	r1,r0[0x0]
8000a6e6:	61 58       	ld.w	r8,r0[0x54]

8000a6e8 <__sfp_lock_acquire>:
8000a6e8:	5e fc       	retal	r12

8000a6ea <__sfp_lock_release>:
8000a6ea:	5e fc       	retal	r12

8000a6ec <_cleanup_r>:
8000a6ec:	d4 01       	pushm	lr
8000a6ee:	fe cb f0 ba 	sub	r11,pc,-3910
8000a6f2:	e0 a0 02 f9 	rcall	8000ace4 <_fwalk>
8000a6f6:	d8 02       	popm	pc

8000a6f8 <__sfmoreglue>:
8000a6f8:	d4 21       	pushm	r4-r7,lr
8000a6fa:	16 95       	mov	r5,r11
8000a6fc:	f6 06 10 5c 	mul	r6,r11,92
8000a700:	ec cb ff f4 	sub	r11,r6,-12
8000a704:	fe b0 e2 64 	rcall	80006bcc <_malloc_r>
8000a708:	18 97       	mov	r7,r12
8000a70a:	c0 90       	breq	8000a71c <__sfmoreglue+0x24>
8000a70c:	99 15       	st.w	r12[0x4],r5
8000a70e:	30 0b       	mov	r11,0
8000a710:	2f 4c       	sub	r12,-12
8000a712:	0c 9a       	mov	r10,r6
8000a714:	8f 2c       	st.w	r7[0x8],r12
8000a716:	8f 0b       	st.w	r7[0x0],r11
8000a718:	fe b0 e5 1a 	rcall	8000714c <memset>
8000a71c:	0e 9c       	mov	r12,r7
8000a71e:	d8 22       	popm	r4-r7,pc

8000a720 <__sfp>:
8000a720:	d4 21       	pushm	r4-r7,lr
8000a722:	49 b8       	lddpc	r8,8000a78c <__sfp+0x6c>
8000a724:	18 96       	mov	r6,r12
8000a726:	70 07       	ld.w	r7,r8[0x0]
8000a728:	6e 68       	ld.w	r8,r7[0x18]
8000a72a:	58 08       	cp.w	r8,0
8000a72c:	c0 31       	brne	8000a732 <__sfp+0x12>
8000a72e:	0e 9c       	mov	r12,r7
8000a730:	c3 0c       	rcall	8000a790 <__sinit>
8000a732:	ee c7 ff 28 	sub	r7,r7,-216
8000a736:	30 05       	mov	r5,0
8000a738:	6e 2c       	ld.w	r12,r7[0x8]
8000a73a:	6e 18       	ld.w	r8,r7[0x4]
8000a73c:	c0 68       	rjmp	8000a748 <__sfp+0x28>
8000a73e:	98 69       	ld.sh	r9,r12[0xc]
8000a740:	ea 09 19 00 	cp.h	r9,r5
8000a744:	c1 10       	breq	8000a766 <__sfp+0x46>
8000a746:	2a 4c       	sub	r12,-92
8000a748:	20 18       	sub	r8,1
8000a74a:	cf a7       	brpl	8000a73e <__sfp+0x1e>
8000a74c:	6e 08       	ld.w	r8,r7[0x0]
8000a74e:	58 08       	cp.w	r8,0
8000a750:	c0 61       	brne	8000a75c <__sfp+0x3c>
8000a752:	30 4b       	mov	r11,4
8000a754:	0c 9c       	mov	r12,r6
8000a756:	cd 1f       	rcall	8000a6f8 <__sfmoreglue>
8000a758:	8f 0c       	st.w	r7[0x0],r12
8000a75a:	c0 30       	breq	8000a760 <__sfp+0x40>
8000a75c:	6e 07       	ld.w	r7,r7[0x0]
8000a75e:	ce db       	rjmp	8000a738 <__sfp+0x18>
8000a760:	30 c8       	mov	r8,12
8000a762:	8d 38       	st.w	r6[0xc],r8
8000a764:	d8 22       	popm	r4-r7,pc
8000a766:	30 08       	mov	r8,0
8000a768:	f9 48 00 4c 	st.w	r12[76],r8
8000a76c:	99 08       	st.w	r12[0x0],r8
8000a76e:	99 28       	st.w	r12[0x8],r8
8000a770:	99 18       	st.w	r12[0x4],r8
8000a772:	99 48       	st.w	r12[0x10],r8
8000a774:	99 58       	st.w	r12[0x14],r8
8000a776:	99 68       	st.w	r12[0x18],r8
8000a778:	99 d8       	st.w	r12[0x34],r8
8000a77a:	99 e8       	st.w	r12[0x38],r8
8000a77c:	f9 48 00 48 	st.w	r12[72],r8
8000a780:	3f f8       	mov	r8,-1
8000a782:	b8 78       	st.h	r12[0xe],r8
8000a784:	30 18       	mov	r8,1
8000a786:	b8 68       	st.h	r12[0xc],r8
8000a788:	d8 22       	popm	r4-r7,pc
8000a78a:	d7 03       	nop
8000a78c:	80 01       	ld.sh	r1,r0[0x0]
8000a78e:	61 7c       	ld.w	r12,r0[0x5c]

8000a790 <__sinit>:
8000a790:	d4 21       	pushm	r4-r7,lr
8000a792:	18 96       	mov	r6,r12
8000a794:	78 67       	ld.w	r7,r12[0x18]
8000a796:	58 07       	cp.w	r7,0
8000a798:	c4 91       	brne	8000a82a <__sinit+0x9a>
8000a79a:	fe c8 00 ae 	sub	r8,pc,174
8000a79e:	30 15       	mov	r5,1
8000a7a0:	99 a8       	st.w	r12[0x28],r8
8000a7a2:	f9 47 00 d8 	st.w	r12[216],r7
8000a7a6:	f9 47 00 dc 	st.w	r12[220],r7
8000a7aa:	f9 47 00 e0 	st.w	r12[224],r7
8000a7ae:	99 65       	st.w	r12[0x18],r5
8000a7b0:	cb 8f       	rcall	8000a720 <__sfp>
8000a7b2:	8d 0c       	st.w	r6[0x0],r12
8000a7b4:	0c 9c       	mov	r12,r6
8000a7b6:	cb 5f       	rcall	8000a720 <__sfp>
8000a7b8:	8d 1c       	st.w	r6[0x4],r12
8000a7ba:	0c 9c       	mov	r12,r6
8000a7bc:	cb 2f       	rcall	8000a720 <__sfp>
8000a7be:	6c 09       	ld.w	r9,r6[0x0]
8000a7c0:	30 48       	mov	r8,4
8000a7c2:	93 07       	st.w	r9[0x0],r7
8000a7c4:	b2 68       	st.h	r9[0xc],r8
8000a7c6:	93 17       	st.w	r9[0x4],r7
8000a7c8:	93 27       	st.w	r9[0x8],r7
8000a7ca:	6c 18       	ld.w	r8,r6[0x4]
8000a7cc:	b2 77       	st.h	r9[0xe],r7
8000a7ce:	93 47       	st.w	r9[0x10],r7
8000a7d0:	93 57       	st.w	r9[0x14],r7
8000a7d2:	93 67       	st.w	r9[0x18],r7
8000a7d4:	93 89       	st.w	r9[0x20],r9
8000a7d6:	91 07       	st.w	r8[0x0],r7
8000a7d8:	91 17       	st.w	r8[0x4],r7
8000a7da:	91 27       	st.w	r8[0x8],r7
8000a7dc:	fe ce f3 20 	sub	lr,pc,-3296
8000a7e0:	fe cb f3 50 	sub	r11,pc,-3248
8000a7e4:	93 9e       	st.w	r9[0x24],lr
8000a7e6:	93 ab       	st.w	r9[0x28],r11
8000a7e8:	fe ca f3 78 	sub	r10,pc,-3208
8000a7ec:	fe c4 f3 84 	sub	r4,pc,-3196
8000a7f0:	93 ba       	st.w	r9[0x2c],r10
8000a7f2:	93 c4       	st.w	r9[0x30],r4
8000a7f4:	30 99       	mov	r9,9
8000a7f6:	b0 69       	st.h	r8[0xc],r9
8000a7f8:	b0 75       	st.h	r8[0xe],r5
8000a7fa:	91 c4       	st.w	r8[0x30],r4
8000a7fc:	91 47       	st.w	r8[0x10],r7
8000a7fe:	91 57       	st.w	r8[0x14],r7
8000a800:	91 67       	st.w	r8[0x18],r7
8000a802:	91 88       	st.w	r8[0x20],r8
8000a804:	91 9e       	st.w	r8[0x24],lr
8000a806:	91 ab       	st.w	r8[0x28],r11
8000a808:	91 ba       	st.w	r8[0x2c],r10
8000a80a:	8d 2c       	st.w	r6[0x8],r12
8000a80c:	31 28       	mov	r8,18
8000a80e:	99 07       	st.w	r12[0x0],r7
8000a810:	b8 68       	st.h	r12[0xc],r8
8000a812:	99 17       	st.w	r12[0x4],r7
8000a814:	99 27       	st.w	r12[0x8],r7
8000a816:	30 28       	mov	r8,2
8000a818:	b8 78       	st.h	r12[0xe],r8
8000a81a:	99 c4       	st.w	r12[0x30],r4
8000a81c:	99 67       	st.w	r12[0x18],r7
8000a81e:	99 9e       	st.w	r12[0x24],lr
8000a820:	99 ab       	st.w	r12[0x28],r11
8000a822:	99 ba       	st.w	r12[0x2c],r10
8000a824:	99 47       	st.w	r12[0x10],r7
8000a826:	99 57       	st.w	r12[0x14],r7
8000a828:	99 8c       	st.w	r12[0x20],r12
8000a82a:	d8 22       	popm	r4-r7,pc

8000a82c <_malloc_trim_r>:
8000a82c:	d4 21       	pushm	r4-r7,lr
8000a82e:	16 95       	mov	r5,r11
8000a830:	18 97       	mov	r7,r12
8000a832:	fe b0 d7 39 	rcall	800056a4 <__malloc_lock>
8000a836:	e0 64 05 30 	mov	r4,1328
8000a83a:	68 28       	ld.w	r8,r4[0x8]
8000a83c:	70 16       	ld.w	r6,r8[0x4]
8000a83e:	e0 16 ff fc 	andl	r6,0xfffc
8000a842:	ec c8 ff 91 	sub	r8,r6,-111
8000a846:	f0 05 01 05 	sub	r5,r8,r5
8000a84a:	e0 15 ff 80 	andl	r5,0xff80
8000a84e:	ea c5 00 80 	sub	r5,r5,128
8000a852:	e0 45 00 7f 	cp.w	r5,127
8000a856:	e0 8a 00 25 	brle	8000a8a0 <_malloc_trim_r+0x74>
8000a85a:	30 0b       	mov	r11,0
8000a85c:	0e 9c       	mov	r12,r7
8000a85e:	fe b0 e5 df 	rcall	8000741c <_sbrk_r>
8000a862:	68 28       	ld.w	r8,r4[0x8]
8000a864:	0c 08       	add	r8,r6
8000a866:	10 3c       	cp.w	r12,r8
8000a868:	c1 c1       	brne	8000a8a0 <_malloc_trim_r+0x74>
8000a86a:	ea 0b 11 00 	rsub	r11,r5,0
8000a86e:	0e 9c       	mov	r12,r7
8000a870:	fe b0 e5 d6 	rcall	8000741c <_sbrk_r>
8000a874:	5b fc       	cp.w	r12,-1
8000a876:	c1 91       	brne	8000a8a8 <_malloc_trim_r+0x7c>
8000a878:	30 0b       	mov	r11,0
8000a87a:	0e 9c       	mov	r12,r7
8000a87c:	fe b0 e5 d0 	rcall	8000741c <_sbrk_r>
8000a880:	68 28       	ld.w	r8,r4[0x8]
8000a882:	f8 08 01 09 	sub	r9,r12,r8
8000a886:	58 f9       	cp.w	r9,15
8000a888:	e0 8a 00 0c 	brle	8000a8a0 <_malloc_trim_r+0x74>
8000a88c:	a1 a9       	sbr	r9,0x0
8000a88e:	91 19       	st.w	r8[0x4],r9
8000a890:	e0 68 09 3c 	mov	r8,2364
8000a894:	70 09       	ld.w	r9,r8[0x0]
8000a896:	e0 68 0d 94 	mov	r8,3476
8000a89a:	f8 09 01 09 	sub	r9,r12,r9
8000a89e:	91 09       	st.w	r8[0x0],r9
8000a8a0:	0e 9c       	mov	r12,r7
8000a8a2:	fe b0 d7 07 	rcall	800056b0 <__malloc_unlock>
8000a8a6:	d8 2a       	popm	r4-r7,pc,r12=0
8000a8a8:	68 28       	ld.w	r8,r4[0x8]
8000a8aa:	0a 16       	sub	r6,r5
8000a8ac:	a1 a6       	sbr	r6,0x0
8000a8ae:	91 16       	st.w	r8[0x4],r6
8000a8b0:	e0 68 0d 94 	mov	r8,3476
8000a8b4:	70 09       	ld.w	r9,r8[0x0]
8000a8b6:	0a 19       	sub	r9,r5
8000a8b8:	0e 9c       	mov	r12,r7
8000a8ba:	91 09       	st.w	r8[0x0],r9
8000a8bc:	fe b0 d6 fa 	rcall	800056b0 <__malloc_unlock>
8000a8c0:	da 2a       	popm	r4-r7,pc,r12=1
8000a8c2:	d7 03       	nop

8000a8c4 <_free_r>:
8000a8c4:	d4 21       	pushm	r4-r7,lr
8000a8c6:	16 96       	mov	r6,r11
8000a8c8:	18 97       	mov	r7,r12
8000a8ca:	58 0b       	cp.w	r11,0
8000a8cc:	e0 80 00 c0 	breq	8000aa4c <_free_r+0x188>
8000a8d0:	fe b0 d6 ea 	rcall	800056a4 <__malloc_lock>
8000a8d4:	20 86       	sub	r6,8
8000a8d6:	e0 6a 05 30 	mov	r10,1328
8000a8da:	6c 18       	ld.w	r8,r6[0x4]
8000a8dc:	74 2e       	ld.w	lr,r10[0x8]
8000a8de:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a8e2:	a1 c8       	cbr	r8,0x0
8000a8e4:	ec 08 00 09 	add	r9,r6,r8
8000a8e8:	72 1b       	ld.w	r11,r9[0x4]
8000a8ea:	e0 1b ff fc 	andl	r11,0xfffc
8000a8ee:	1c 39       	cp.w	r9,lr
8000a8f0:	c1 e1       	brne	8000a92c <_free_r+0x68>
8000a8f2:	f6 08 00 08 	add	r8,r11,r8
8000a8f6:	58 0c       	cp.w	r12,0
8000a8f8:	c0 81       	brne	8000a908 <_free_r+0x44>
8000a8fa:	6c 09       	ld.w	r9,r6[0x0]
8000a8fc:	12 16       	sub	r6,r9
8000a8fe:	12 08       	add	r8,r9
8000a900:	6c 3b       	ld.w	r11,r6[0xc]
8000a902:	6c 29       	ld.w	r9,r6[0x8]
8000a904:	97 29       	st.w	r11[0x8],r9
8000a906:	93 3b       	st.w	r9[0xc],r11
8000a908:	10 99       	mov	r9,r8
8000a90a:	95 26       	st.w	r10[0x8],r6
8000a90c:	a1 a9       	sbr	r9,0x0
8000a90e:	8d 19       	st.w	r6[0x4],r9
8000a910:	e0 69 09 38 	mov	r9,2360
8000a914:	72 09       	ld.w	r9,r9[0x0]
8000a916:	12 38       	cp.w	r8,r9
8000a918:	c0 63       	brcs	8000a924 <_free_r+0x60>
8000a91a:	e0 68 0d 90 	mov	r8,3472
8000a91e:	0e 9c       	mov	r12,r7
8000a920:	70 0b       	ld.w	r11,r8[0x0]
8000a922:	c8 5f       	rcall	8000a82c <_malloc_trim_r>
8000a924:	0e 9c       	mov	r12,r7
8000a926:	fe b0 d6 c5 	rcall	800056b0 <__malloc_unlock>
8000a92a:	d8 22       	popm	r4-r7,pc
8000a92c:	93 1b       	st.w	r9[0x4],r11
8000a92e:	58 0c       	cp.w	r12,0
8000a930:	c0 30       	breq	8000a936 <_free_r+0x72>
8000a932:	30 0c       	mov	r12,0
8000a934:	c1 08       	rjmp	8000a954 <_free_r+0x90>
8000a936:	6c 0e       	ld.w	lr,r6[0x0]
8000a938:	f4 c5 ff f8 	sub	r5,r10,-8
8000a93c:	1c 16       	sub	r6,lr
8000a93e:	1c 08       	add	r8,lr
8000a940:	6c 2e       	ld.w	lr,r6[0x8]
8000a942:	0a 3e       	cp.w	lr,r5
8000a944:	f9 bc 00 01 	moveq	r12,1
8000a948:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a94c:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a950:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a954:	f2 0b 00 0e 	add	lr,r9,r11
8000a958:	7c 1e       	ld.w	lr,lr[0x4]
8000a95a:	ed be 00 00 	bld	lr,0x0
8000a95e:	c1 40       	breq	8000a986 <_free_r+0xc2>
8000a960:	16 08       	add	r8,r11
8000a962:	58 0c       	cp.w	r12,0
8000a964:	c0 d1       	brne	8000a97e <_free_r+0xba>
8000a966:	e0 6e 05 30 	mov	lr,1328
8000a96a:	72 2b       	ld.w	r11,r9[0x8]
8000a96c:	2f 8e       	sub	lr,-8
8000a96e:	1c 3b       	cp.w	r11,lr
8000a970:	c0 71       	brne	8000a97e <_free_r+0xba>
8000a972:	97 36       	st.w	r11[0xc],r6
8000a974:	97 26       	st.w	r11[0x8],r6
8000a976:	8d 2b       	st.w	r6[0x8],r11
8000a978:	8d 3b       	st.w	r6[0xc],r11
8000a97a:	30 1c       	mov	r12,1
8000a97c:	c0 58       	rjmp	8000a986 <_free_r+0xc2>
8000a97e:	72 2b       	ld.w	r11,r9[0x8]
8000a980:	72 39       	ld.w	r9,r9[0xc]
8000a982:	93 2b       	st.w	r9[0x8],r11
8000a984:	97 39       	st.w	r11[0xc],r9
8000a986:	10 99       	mov	r9,r8
8000a988:	ec 08 09 08 	st.w	r6[r8],r8
8000a98c:	a1 a9       	sbr	r9,0x0
8000a98e:	8d 19       	st.w	r6[0x4],r9
8000a990:	58 0c       	cp.w	r12,0
8000a992:	c5 a1       	brne	8000aa46 <_free_r+0x182>
8000a994:	e0 48 01 ff 	cp.w	r8,511
8000a998:	e0 8b 00 13 	brhi	8000a9be <_free_r+0xfa>
8000a99c:	a3 98       	lsr	r8,0x3
8000a99e:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a9a2:	72 2b       	ld.w	r11,r9[0x8]
8000a9a4:	8d 39       	st.w	r6[0xc],r9
8000a9a6:	8d 2b       	st.w	r6[0x8],r11
8000a9a8:	97 36       	st.w	r11[0xc],r6
8000a9aa:	93 26       	st.w	r9[0x8],r6
8000a9ac:	a3 48       	asr	r8,0x2
8000a9ae:	74 19       	ld.w	r9,r10[0x4]
8000a9b0:	30 1b       	mov	r11,1
8000a9b2:	f6 08 09 48 	lsl	r8,r11,r8
8000a9b6:	f3 e8 10 08 	or	r8,r9,r8
8000a9ba:	95 18       	st.w	r10[0x4],r8
8000a9bc:	c4 58       	rjmp	8000aa46 <_free_r+0x182>
8000a9be:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a9c2:	58 4b       	cp.w	r11,4
8000a9c4:	e0 8b 00 06 	brhi	8000a9d0 <_free_r+0x10c>
8000a9c8:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a9cc:	2c 8b       	sub	r11,-56
8000a9ce:	c2 08       	rjmp	8000aa0e <_free_r+0x14a>
8000a9d0:	59 4b       	cp.w	r11,20
8000a9d2:	e0 8b 00 04 	brhi	8000a9da <_free_r+0x116>
8000a9d6:	2a 5b       	sub	r11,-91
8000a9d8:	c1 b8       	rjmp	8000aa0e <_free_r+0x14a>
8000a9da:	e0 4b 00 54 	cp.w	r11,84
8000a9de:	e0 8b 00 06 	brhi	8000a9ea <_free_r+0x126>
8000a9e2:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a9e6:	29 2b       	sub	r11,-110
8000a9e8:	c1 38       	rjmp	8000aa0e <_free_r+0x14a>
8000a9ea:	e0 4b 01 54 	cp.w	r11,340
8000a9ee:	e0 8b 00 06 	brhi	8000a9fa <_free_r+0x136>
8000a9f2:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a9f6:	28 9b       	sub	r11,-119
8000a9f8:	c0 b8       	rjmp	8000aa0e <_free_r+0x14a>
8000a9fa:	e0 4b 05 54 	cp.w	r11,1364
8000a9fe:	e0 88 00 05 	brls	8000aa08 <_free_r+0x144>
8000aa02:	37 eb       	mov	r11,126
8000aa04:	c0 58       	rjmp	8000aa0e <_free_r+0x14a>
8000aa06:	d7 03       	nop
8000aa08:	f0 0b 16 12 	lsr	r11,r8,0x12
8000aa0c:	28 4b       	sub	r11,-124
8000aa0e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000aa12:	78 29       	ld.w	r9,r12[0x8]
8000aa14:	18 39       	cp.w	r9,r12
8000aa16:	c0 e1       	brne	8000aa32 <_free_r+0x16e>
8000aa18:	74 18       	ld.w	r8,r10[0x4]
8000aa1a:	a3 4b       	asr	r11,0x2
8000aa1c:	30 1c       	mov	r12,1
8000aa1e:	f8 0b 09 4b 	lsl	r11,r12,r11
8000aa22:	f1 eb 10 0b 	or	r11,r8,r11
8000aa26:	12 98       	mov	r8,r9
8000aa28:	95 1b       	st.w	r10[0x4],r11
8000aa2a:	c0 a8       	rjmp	8000aa3e <_free_r+0x17a>
8000aa2c:	72 29       	ld.w	r9,r9[0x8]
8000aa2e:	18 39       	cp.w	r9,r12
8000aa30:	c0 60       	breq	8000aa3c <_free_r+0x178>
8000aa32:	72 1a       	ld.w	r10,r9[0x4]
8000aa34:	e0 1a ff fc 	andl	r10,0xfffc
8000aa38:	14 38       	cp.w	r8,r10
8000aa3a:	cf 93       	brcs	8000aa2c <_free_r+0x168>
8000aa3c:	72 38       	ld.w	r8,r9[0xc]
8000aa3e:	8d 38       	st.w	r6[0xc],r8
8000aa40:	8d 29       	st.w	r6[0x8],r9
8000aa42:	93 36       	st.w	r9[0xc],r6
8000aa44:	91 26       	st.w	r8[0x8],r6
8000aa46:	0e 9c       	mov	r12,r7
8000aa48:	fe b0 d6 34 	rcall	800056b0 <__malloc_unlock>
8000aa4c:	d8 22       	popm	r4-r7,pc
8000aa4e:	d7 03       	nop

8000aa50 <__sfvwrite_r>:
8000aa50:	d4 31       	pushm	r0-r7,lr
8000aa52:	20 3d       	sub	sp,12
8000aa54:	14 94       	mov	r4,r10
8000aa56:	18 95       	mov	r5,r12
8000aa58:	16 97       	mov	r7,r11
8000aa5a:	74 28       	ld.w	r8,r10[0x8]
8000aa5c:	58 08       	cp.w	r8,0
8000aa5e:	e0 80 01 40 	breq	8000acde <__sfvwrite_r+0x28e>
8000aa62:	96 68       	ld.sh	r8,r11[0xc]
8000aa64:	ed b8 00 03 	bld	r8,0x3
8000aa68:	c0 41       	brne	8000aa70 <__sfvwrite_r+0x20>
8000aa6a:	76 48       	ld.w	r8,r11[0x10]
8000aa6c:	58 08       	cp.w	r8,0
8000aa6e:	c0 c1       	brne	8000aa86 <__sfvwrite_r+0x36>
8000aa70:	0e 9b       	mov	r11,r7
8000aa72:	0a 9c       	mov	r12,r5
8000aa74:	fe b0 f6 bc 	rcall	800097ec <__swsetup_r>
8000aa78:	c0 70       	breq	8000aa86 <__sfvwrite_r+0x36>
8000aa7a:	8e 68       	ld.sh	r8,r7[0xc]
8000aa7c:	a7 a8       	sbr	r8,0x6
8000aa7e:	ae 68       	st.h	r7[0xc],r8
8000aa80:	30 98       	mov	r8,9
8000aa82:	8b 38       	st.w	r5[0xc],r8
8000aa84:	c2 b9       	rjmp	8000acda <__sfvwrite_r+0x28a>
8000aa86:	8e 63       	ld.sh	r3,r7[0xc]
8000aa88:	68 00       	ld.w	r0,r4[0x0]
8000aa8a:	06 96       	mov	r6,r3
8000aa8c:	e2 16 00 02 	andl	r6,0x2,COH
8000aa90:	c2 10       	breq	8000aad2 <__sfvwrite_r+0x82>
8000aa92:	30 03       	mov	r3,0
8000aa94:	e0 62 04 00 	mov	r2,1024
8000aa98:	06 96       	mov	r6,r3
8000aa9a:	c0 48       	rjmp	8000aaa2 <__sfvwrite_r+0x52>
8000aa9c:	60 03       	ld.w	r3,r0[0x0]
8000aa9e:	60 16       	ld.w	r6,r0[0x4]
8000aaa0:	2f 80       	sub	r0,-8
8000aaa2:	58 06       	cp.w	r6,0
8000aaa4:	cf c0       	breq	8000aa9c <__sfvwrite_r+0x4c>
8000aaa6:	e0 46 04 00 	cp.w	r6,1024
8000aaaa:	ec 09 17 80 	movls	r9,r6
8000aaae:	e4 09 17 b0 	movhi	r9,r2
8000aab2:	06 9a       	mov	r10,r3
8000aab4:	6e a8       	ld.w	r8,r7[0x28]
8000aab6:	6e 8b       	ld.w	r11,r7[0x20]
8000aab8:	0a 9c       	mov	r12,r5
8000aaba:	5d 18       	icall	r8
8000aabc:	18 16       	sub	r6,r12
8000aabe:	58 0c       	cp.w	r12,0
8000aac0:	e0 8a 01 0a 	brle	8000acd4 <__sfvwrite_r+0x284>
8000aac4:	68 28       	ld.w	r8,r4[0x8]
8000aac6:	18 18       	sub	r8,r12
8000aac8:	89 28       	st.w	r4[0x8],r8
8000aaca:	e0 80 01 0a 	breq	8000acde <__sfvwrite_r+0x28e>
8000aace:	18 03       	add	r3,r12
8000aad0:	ce 9b       	rjmp	8000aaa2 <__sfvwrite_r+0x52>
8000aad2:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000aad6:	c0 70       	breq	8000aae4 <__sfvwrite_r+0x94>
8000aad8:	50 06       	stdsp	sp[0x0],r6
8000aada:	0c 93       	mov	r3,r6
8000aadc:	0c 91       	mov	r1,r6
8000aade:	50 15       	stdsp	sp[0x4],r5
8000aae0:	08 92       	mov	r2,r4
8000aae2:	c9 c8       	rjmp	8000ac1a <__sfvwrite_r+0x1ca>
8000aae4:	06 96       	mov	r6,r3
8000aae6:	08 91       	mov	r1,r4
8000aae8:	c0 48       	rjmp	8000aaf0 <__sfvwrite_r+0xa0>
8000aaea:	60 03       	ld.w	r3,r0[0x0]
8000aaec:	60 16       	ld.w	r6,r0[0x4]
8000aaee:	2f 80       	sub	r0,-8
8000aaf0:	58 06       	cp.w	r6,0
8000aaf2:	cf c0       	breq	8000aaea <__sfvwrite_r+0x9a>
8000aaf4:	8e 68       	ld.sh	r8,r7[0xc]
8000aaf6:	6e 24       	ld.w	r4,r7[0x8]
8000aaf8:	10 99       	mov	r9,r8
8000aafa:	e2 19 02 00 	andl	r9,0x200,COH
8000aafe:	c5 50       	breq	8000aba8 <__sfvwrite_r+0x158>
8000ab00:	08 36       	cp.w	r6,r4
8000ab02:	c4 43       	brcs	8000ab8a <__sfvwrite_r+0x13a>
8000ab04:	10 99       	mov	r9,r8
8000ab06:	e2 19 04 80 	andl	r9,0x480,COH
8000ab0a:	c4 00       	breq	8000ab8a <__sfvwrite_r+0x13a>
8000ab0c:	6e 4b       	ld.w	r11,r7[0x10]
8000ab0e:	6e 09       	ld.w	r9,r7[0x0]
8000ab10:	16 19       	sub	r9,r11
8000ab12:	50 09       	stdsp	sp[0x0],r9
8000ab14:	6e 59       	ld.w	r9,r7[0x14]
8000ab16:	10 9c       	mov	r12,r8
8000ab18:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000ab1c:	30 28       	mov	r8,2
8000ab1e:	f4 08 0c 08 	divs	r8,r10,r8
8000ab22:	fa e9 00 04 	st.d	sp[4],r8
8000ab26:	10 94       	mov	r4,r8
8000ab28:	40 09       	lddsp	r9,sp[0x0]
8000ab2a:	e2 1c 04 00 	andl	r12,0x400,COH
8000ab2e:	2f f9       	sub	r9,-1
8000ab30:	0c 09       	add	r9,r6
8000ab32:	12 38       	cp.w	r8,r9
8000ab34:	f2 04 17 30 	movlo	r4,r9
8000ab38:	58 0c       	cp.w	r12,0
8000ab3a:	c1 10       	breq	8000ab5c <__sfvwrite_r+0x10c>
8000ab3c:	08 9b       	mov	r11,r4
8000ab3e:	0a 9c       	mov	r12,r5
8000ab40:	fe b0 e0 46 	rcall	80006bcc <_malloc_r>
8000ab44:	18 92       	mov	r2,r12
8000ab46:	c1 40       	breq	8000ab6e <__sfvwrite_r+0x11e>
8000ab48:	40 0a       	lddsp	r10,sp[0x0]
8000ab4a:	6e 4b       	ld.w	r11,r7[0x10]
8000ab4c:	fe b0 e2 5c 	rcall	80007004 <memcpy>
8000ab50:	8e 68       	ld.sh	r8,r7[0xc]
8000ab52:	e0 18 fb 7f 	andl	r8,0xfb7f
8000ab56:	a7 b8       	sbr	r8,0x7
8000ab58:	ae 68       	st.h	r7[0xc],r8
8000ab5a:	c0 d8       	rjmp	8000ab74 <__sfvwrite_r+0x124>
8000ab5c:	08 9a       	mov	r10,r4
8000ab5e:	0a 9c       	mov	r12,r5
8000ab60:	fe b0 e2 fe 	rcall	8000715c <_realloc_r>
8000ab64:	18 92       	mov	r2,r12
8000ab66:	c0 71       	brne	8000ab74 <__sfvwrite_r+0x124>
8000ab68:	6e 4b       	ld.w	r11,r7[0x10]
8000ab6a:	0a 9c       	mov	r12,r5
8000ab6c:	ca ce       	rcall	8000a8c4 <_free_r>
8000ab6e:	30 c8       	mov	r8,12
8000ab70:	8b 38       	st.w	r5[0xc],r8
8000ab72:	cb 18       	rjmp	8000acd4 <__sfvwrite_r+0x284>
8000ab74:	40 0a       	lddsp	r10,sp[0x0]
8000ab76:	40 09       	lddsp	r9,sp[0x0]
8000ab78:	e8 0a 01 0a 	sub	r10,r4,r10
8000ab7c:	e4 09 00 08 	add	r8,r2,r9
8000ab80:	8f 54       	st.w	r7[0x14],r4
8000ab82:	8f 2a       	st.w	r7[0x8],r10
8000ab84:	8f 08       	st.w	r7[0x0],r8
8000ab86:	8f 42       	st.w	r7[0x10],r2
8000ab88:	0c 94       	mov	r4,r6
8000ab8a:	08 36       	cp.w	r6,r4
8000ab8c:	ec 04 17 30 	movlo	r4,r6
8000ab90:	06 9b       	mov	r11,r3
8000ab92:	08 9a       	mov	r10,r4
8000ab94:	6e 0c       	ld.w	r12,r7[0x0]
8000ab96:	c3 ad       	rcall	8000ae0a <memmove>
8000ab98:	6e 08       	ld.w	r8,r7[0x0]
8000ab9a:	08 08       	add	r8,r4
8000ab9c:	8f 08       	st.w	r7[0x0],r8
8000ab9e:	6e 28       	ld.w	r8,r7[0x8]
8000aba0:	08 18       	sub	r8,r4
8000aba2:	0c 94       	mov	r4,r6
8000aba4:	8f 28       	st.w	r7[0x8],r8
8000aba6:	c2 e8       	rjmp	8000ac02 <__sfvwrite_r+0x1b2>
8000aba8:	08 36       	cp.w	r6,r4
8000abaa:	5f ba       	srhi	r10
8000abac:	6e 0c       	ld.w	r12,r7[0x0]
8000abae:	6e 48       	ld.w	r8,r7[0x10]
8000abb0:	10 3c       	cp.w	r12,r8
8000abb2:	5f b8       	srhi	r8
8000abb4:	f5 e8 00 08 	and	r8,r10,r8
8000abb8:	f2 08 18 00 	cp.b	r8,r9
8000abbc:	c0 d0       	breq	8000abd6 <__sfvwrite_r+0x186>
8000abbe:	06 9b       	mov	r11,r3
8000abc0:	08 9a       	mov	r10,r4
8000abc2:	c2 4d       	rcall	8000ae0a <memmove>
8000abc4:	6e 08       	ld.w	r8,r7[0x0]
8000abc6:	08 08       	add	r8,r4
8000abc8:	0e 9b       	mov	r11,r7
8000abca:	8f 08       	st.w	r7[0x0],r8
8000abcc:	0a 9c       	mov	r12,r5
8000abce:	fe b0 fd 05 	rcall	8000a5d8 <_fflush_r>
8000abd2:	c1 80       	breq	8000ac02 <__sfvwrite_r+0x1b2>
8000abd4:	c8 08       	rjmp	8000acd4 <__sfvwrite_r+0x284>
8000abd6:	6e 59       	ld.w	r9,r7[0x14]
8000abd8:	12 36       	cp.w	r6,r9
8000abda:	c0 a3       	brcs	8000abee <__sfvwrite_r+0x19e>
8000abdc:	6e a8       	ld.w	r8,r7[0x28]
8000abde:	06 9a       	mov	r10,r3
8000abe0:	6e 8b       	ld.w	r11,r7[0x20]
8000abe2:	0a 9c       	mov	r12,r5
8000abe4:	5d 18       	icall	r8
8000abe6:	18 94       	mov	r4,r12
8000abe8:	e0 89 00 0d 	brgt	8000ac02 <__sfvwrite_r+0x1b2>
8000abec:	c7 48       	rjmp	8000acd4 <__sfvwrite_r+0x284>
8000abee:	0c 9a       	mov	r10,r6
8000abf0:	06 9b       	mov	r11,r3
8000abf2:	c0 cd       	rcall	8000ae0a <memmove>
8000abf4:	6e 08       	ld.w	r8,r7[0x0]
8000abf6:	0c 08       	add	r8,r6
8000abf8:	0c 94       	mov	r4,r6
8000abfa:	8f 08       	st.w	r7[0x0],r8
8000abfc:	6e 28       	ld.w	r8,r7[0x8]
8000abfe:	0c 18       	sub	r8,r6
8000ac00:	8f 28       	st.w	r7[0x8],r8
8000ac02:	62 28       	ld.w	r8,r1[0x8]
8000ac04:	08 18       	sub	r8,r4
8000ac06:	83 28       	st.w	r1[0x8],r8
8000ac08:	c6 b0       	breq	8000acde <__sfvwrite_r+0x28e>
8000ac0a:	08 16       	sub	r6,r4
8000ac0c:	08 03       	add	r3,r4
8000ac0e:	c7 1b       	rjmp	8000aaf0 <__sfvwrite_r+0xa0>
8000ac10:	60 03       	ld.w	r3,r0[0x0]
8000ac12:	60 11       	ld.w	r1,r0[0x4]
8000ac14:	30 08       	mov	r8,0
8000ac16:	2f 80       	sub	r0,-8
8000ac18:	50 08       	stdsp	sp[0x0],r8
8000ac1a:	58 01       	cp.w	r1,0
8000ac1c:	cf a0       	breq	8000ac10 <__sfvwrite_r+0x1c0>
8000ac1e:	40 0a       	lddsp	r10,sp[0x0]
8000ac20:	58 0a       	cp.w	r10,0
8000ac22:	c1 41       	brne	8000ac4a <__sfvwrite_r+0x1fa>
8000ac24:	e2 c6 ff ff 	sub	r6,r1,-1
8000ac28:	02 9a       	mov	r10,r1
8000ac2a:	30 ab       	mov	r11,10
8000ac2c:	06 9c       	mov	r12,r3
8000ac2e:	ce 3c       	rcall	8000adf4 <memchr>
8000ac30:	f8 c8 ff ff 	sub	r8,r12,-1
8000ac34:	58 0c       	cp.w	r12,0
8000ac36:	f1 d3 e1 16 	subne	r6,r8,r3
8000ac3a:	f9 b9 01 01 	movne	r9,1
8000ac3e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ac42:	f9 b8 00 01 	moveq	r8,1
8000ac46:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ac4a:	02 36       	cp.w	r6,r1
8000ac4c:	ec 04 17 80 	movls	r4,r6
8000ac50:	e2 04 17 b0 	movhi	r4,r1
8000ac54:	6e 59       	ld.w	r9,r7[0x14]
8000ac56:	6e 25       	ld.w	r5,r7[0x8]
8000ac58:	f2 05 00 05 	add	r5,r9,r5
8000ac5c:	0a 34       	cp.w	r4,r5
8000ac5e:	5f 9a       	srgt	r10
8000ac60:	6e 0c       	ld.w	r12,r7[0x0]
8000ac62:	6e 48       	ld.w	r8,r7[0x10]
8000ac64:	10 3c       	cp.w	r12,r8
8000ac66:	5f b8       	srhi	r8
8000ac68:	f5 e8 00 08 	and	r8,r10,r8
8000ac6c:	30 0a       	mov	r10,0
8000ac6e:	f4 08 18 00 	cp.b	r8,r10
8000ac72:	c0 d0       	breq	8000ac8c <__sfvwrite_r+0x23c>
8000ac74:	06 9b       	mov	r11,r3
8000ac76:	0a 9a       	mov	r10,r5
8000ac78:	cc 9c       	rcall	8000ae0a <memmove>
8000ac7a:	6e 08       	ld.w	r8,r7[0x0]
8000ac7c:	0a 08       	add	r8,r5
8000ac7e:	0e 9b       	mov	r11,r7
8000ac80:	8f 08       	st.w	r7[0x0],r8
8000ac82:	40 1c       	lddsp	r12,sp[0x4]
8000ac84:	fe b0 fc aa 	rcall	8000a5d8 <_fflush_r>
8000ac88:	c1 70       	breq	8000acb6 <__sfvwrite_r+0x266>
8000ac8a:	c2 58       	rjmp	8000acd4 <__sfvwrite_r+0x284>
8000ac8c:	12 34       	cp.w	r4,r9
8000ac8e:	c0 a5       	brlt	8000aca2 <__sfvwrite_r+0x252>
8000ac90:	6e a8       	ld.w	r8,r7[0x28]
8000ac92:	06 9a       	mov	r10,r3
8000ac94:	6e 8b       	ld.w	r11,r7[0x20]
8000ac96:	40 1c       	lddsp	r12,sp[0x4]
8000ac98:	5d 18       	icall	r8
8000ac9a:	18 95       	mov	r5,r12
8000ac9c:	e0 89 00 0d 	brgt	8000acb6 <__sfvwrite_r+0x266>
8000aca0:	c1 a8       	rjmp	8000acd4 <__sfvwrite_r+0x284>
8000aca2:	08 9a       	mov	r10,r4
8000aca4:	06 9b       	mov	r11,r3
8000aca6:	cb 2c       	rcall	8000ae0a <memmove>
8000aca8:	6e 08       	ld.w	r8,r7[0x0]
8000acaa:	08 08       	add	r8,r4
8000acac:	08 95       	mov	r5,r4
8000acae:	8f 08       	st.w	r7[0x0],r8
8000acb0:	6e 28       	ld.w	r8,r7[0x8]
8000acb2:	08 18       	sub	r8,r4
8000acb4:	8f 28       	st.w	r7[0x8],r8
8000acb6:	0a 16       	sub	r6,r5
8000acb8:	c0 71       	brne	8000acc6 <__sfvwrite_r+0x276>
8000acba:	0e 9b       	mov	r11,r7
8000acbc:	40 1c       	lddsp	r12,sp[0x4]
8000acbe:	fe b0 fc 8d 	rcall	8000a5d8 <_fflush_r>
8000acc2:	c0 91       	brne	8000acd4 <__sfvwrite_r+0x284>
8000acc4:	50 06       	stdsp	sp[0x0],r6
8000acc6:	64 28       	ld.w	r8,r2[0x8]
8000acc8:	0a 18       	sub	r8,r5
8000acca:	85 28       	st.w	r2[0x8],r8
8000accc:	c0 90       	breq	8000acde <__sfvwrite_r+0x28e>
8000acce:	0a 11       	sub	r1,r5
8000acd0:	0a 03       	add	r3,r5
8000acd2:	ca 4b       	rjmp	8000ac1a <__sfvwrite_r+0x1ca>
8000acd4:	8e 68       	ld.sh	r8,r7[0xc]
8000acd6:	a7 a8       	sbr	r8,0x6
8000acd8:	ae 68       	st.h	r7[0xc],r8
8000acda:	3f fc       	mov	r12,-1
8000acdc:	c0 28       	rjmp	8000ace0 <__sfvwrite_r+0x290>
8000acde:	30 0c       	mov	r12,0
8000ace0:	2f dd       	sub	sp,-12
8000ace2:	d8 32       	popm	r0-r7,pc

8000ace4 <_fwalk>:
8000ace4:	d4 31       	pushm	r0-r7,lr
8000ace6:	30 05       	mov	r5,0
8000ace8:	16 91       	mov	r1,r11
8000acea:	f8 c7 ff 28 	sub	r7,r12,-216
8000acee:	0a 92       	mov	r2,r5
8000acf0:	fe b0 fc fc 	rcall	8000a6e8 <__sfp_lock_acquire>
8000acf4:	3f f3       	mov	r3,-1
8000acf6:	c1 68       	rjmp	8000ad22 <_fwalk+0x3e>
8000acf8:	6e 26       	ld.w	r6,r7[0x8]
8000acfa:	6e 14       	ld.w	r4,r7[0x4]
8000acfc:	2f 46       	sub	r6,-12
8000acfe:	c0 c8       	rjmp	8000ad16 <_fwalk+0x32>
8000ad00:	8c 08       	ld.sh	r8,r6[0x0]
8000ad02:	e4 08 19 00 	cp.h	r8,r2
8000ad06:	c0 70       	breq	8000ad14 <_fwalk+0x30>
8000ad08:	8c 18       	ld.sh	r8,r6[0x2]
8000ad0a:	e6 08 19 00 	cp.h	r8,r3
8000ad0e:	c0 30       	breq	8000ad14 <_fwalk+0x30>
8000ad10:	5d 11       	icall	r1
8000ad12:	18 45       	or	r5,r12
8000ad14:	2a 46       	sub	r6,-92
8000ad16:	20 14       	sub	r4,1
8000ad18:	ec cc 00 0c 	sub	r12,r6,12
8000ad1c:	58 04       	cp.w	r4,0
8000ad1e:	cf 14       	brge	8000ad00 <_fwalk+0x1c>
8000ad20:	6e 07       	ld.w	r7,r7[0x0]
8000ad22:	58 07       	cp.w	r7,0
8000ad24:	ce a1       	brne	8000acf8 <_fwalk+0x14>
8000ad26:	fe b0 fc e2 	rcall	8000a6ea <__sfp_lock_release>
8000ad2a:	0a 9c       	mov	r12,r5
8000ad2c:	d8 32       	popm	r0-r7,pc
8000ad2e:	d7 03       	nop

8000ad30 <_localeconv_r>:
8000ad30:	48 1c       	lddpc	r12,8000ad34 <_localeconv_r+0x4>
8000ad32:	5e fc       	retal	r12
8000ad34:	80 01       	ld.sh	r1,r0[0x0]
8000ad36:	61 80       	ld.w	r0,r0[0x60]

8000ad38 <__smakebuf_r>:
8000ad38:	d4 21       	pushm	r4-r7,lr
8000ad3a:	20 fd       	sub	sp,60
8000ad3c:	96 68       	ld.sh	r8,r11[0xc]
8000ad3e:	16 97       	mov	r7,r11
8000ad40:	18 96       	mov	r6,r12
8000ad42:	e2 18 00 02 	andl	r8,0x2,COH
8000ad46:	c3 d1       	brne	8000adc0 <__smakebuf_r+0x88>
8000ad48:	96 7b       	ld.sh	r11,r11[0xe]
8000ad4a:	f0 0b 19 00 	cp.h	r11,r8
8000ad4e:	c0 55       	brlt	8000ad58 <__smakebuf_r+0x20>
8000ad50:	1a 9a       	mov	r10,sp
8000ad52:	e0 a0 04 79 	rcall	8000b644 <_fstat_r>
8000ad56:	c0 f4       	brge	8000ad74 <__smakebuf_r+0x3c>
8000ad58:	8e 65       	ld.sh	r5,r7[0xc]
8000ad5a:	0a 98       	mov	r8,r5
8000ad5c:	ab b8       	sbr	r8,0xb
8000ad5e:	e2 15 00 80 	andl	r5,0x80,COH
8000ad62:	ae 68       	st.h	r7[0xc],r8
8000ad64:	30 04       	mov	r4,0
8000ad66:	e0 68 04 00 	mov	r8,1024
8000ad6a:	f9 b5 01 40 	movne	r5,64
8000ad6e:	f0 05 17 00 	moveq	r5,r8
8000ad72:	c1 c8       	rjmp	8000adaa <__smakebuf_r+0x72>
8000ad74:	40 18       	lddsp	r8,sp[0x4]
8000ad76:	e2 18 f0 00 	andl	r8,0xf000,COH
8000ad7a:	e0 48 20 00 	cp.w	r8,8192
8000ad7e:	5f 04       	sreq	r4
8000ad80:	e0 48 80 00 	cp.w	r8,32768
8000ad84:	c0 e1       	brne	8000ada0 <__smakebuf_r+0x68>
8000ad86:	6e b9       	ld.w	r9,r7[0x2c]
8000ad88:	fe c8 f9 18 	sub	r8,pc,-1768
8000ad8c:	10 39       	cp.w	r9,r8
8000ad8e:	c0 91       	brne	8000ada0 <__smakebuf_r+0x68>
8000ad90:	8e 68       	ld.sh	r8,r7[0xc]
8000ad92:	e0 65 04 00 	mov	r5,1024
8000ad96:	ab a8       	sbr	r8,0xa
8000ad98:	ef 45 00 50 	st.w	r7[80],r5
8000ad9c:	ae 68       	st.h	r7[0xc],r8
8000ad9e:	c0 68       	rjmp	8000adaa <__smakebuf_r+0x72>
8000ada0:	8e 68       	ld.sh	r8,r7[0xc]
8000ada2:	e0 65 04 00 	mov	r5,1024
8000ada6:	ab b8       	sbr	r8,0xb
8000ada8:	ae 68       	st.h	r7[0xc],r8
8000adaa:	0a 9b       	mov	r11,r5
8000adac:	0c 9c       	mov	r12,r6
8000adae:	fe b0 df 0f 	rcall	80006bcc <_malloc_r>
8000adb2:	8e 68       	ld.sh	r8,r7[0xc]
8000adb4:	c0 d1       	brne	8000adce <__smakebuf_r+0x96>
8000adb6:	ed b8 00 09 	bld	r8,0x9
8000adba:	c1 b0       	breq	8000adf0 <__smakebuf_r+0xb8>
8000adbc:	a1 b8       	sbr	r8,0x1
8000adbe:	ae 68       	st.h	r7[0xc],r8
8000adc0:	ee c8 ff b9 	sub	r8,r7,-71
8000adc4:	8f 48       	st.w	r7[0x10],r8
8000adc6:	8f 08       	st.w	r7[0x0],r8
8000adc8:	30 18       	mov	r8,1
8000adca:	8f 58       	st.w	r7[0x14],r8
8000adcc:	c1 28       	rjmp	8000adf0 <__smakebuf_r+0xb8>
8000adce:	a7 b8       	sbr	r8,0x7
8000add0:	8f 4c       	st.w	r7[0x10],r12
8000add2:	ae 68       	st.h	r7[0xc],r8
8000add4:	8f 55       	st.w	r7[0x14],r5
8000add6:	fe c8 06 ea 	sub	r8,pc,1770
8000adda:	8f 0c       	st.w	r7[0x0],r12
8000addc:	8d a8       	st.w	r6[0x28],r8
8000adde:	58 04       	cp.w	r4,0
8000ade0:	c0 80       	breq	8000adf0 <__smakebuf_r+0xb8>
8000ade2:	8e 7c       	ld.sh	r12,r7[0xe]
8000ade4:	fe b0 e3 7a 	rcall	800074d8 <isatty>
8000ade8:	c0 40       	breq	8000adf0 <__smakebuf_r+0xb8>
8000adea:	8e 68       	ld.sh	r8,r7[0xc]
8000adec:	a1 a8       	sbr	r8,0x0
8000adee:	ae 68       	st.h	r7[0xc],r8
8000adf0:	2f 1d       	sub	sp,-60
8000adf2:	d8 22       	popm	r4-r7,pc

8000adf4 <memchr>:
8000adf4:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000adf8:	c0 68       	rjmp	8000ae04 <memchr+0x10>
8000adfa:	20 1a       	sub	r10,1
8000adfc:	19 88       	ld.ub	r8,r12[0x0]
8000adfe:	16 38       	cp.w	r8,r11
8000ae00:	5e 0c       	reteq	r12
8000ae02:	2f fc       	sub	r12,-1
8000ae04:	58 0a       	cp.w	r10,0
8000ae06:	cf a1       	brne	8000adfa <memchr+0x6>
8000ae08:	5e fa       	retal	r10

8000ae0a <memmove>:
8000ae0a:	d4 01       	pushm	lr
8000ae0c:	18 3b       	cp.w	r11,r12
8000ae0e:	c1 92       	brcc	8000ae40 <memmove+0x36>
8000ae10:	f6 0a 00 09 	add	r9,r11,r10
8000ae14:	12 3c       	cp.w	r12,r9
8000ae16:	c1 52       	brcc	8000ae40 <memmove+0x36>
8000ae18:	f8 0a 00 0b 	add	r11,r12,r10
8000ae1c:	30 08       	mov	r8,0
8000ae1e:	c0 68       	rjmp	8000ae2a <memmove+0x20>
8000ae20:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000ae24:	20 1a       	sub	r10,1
8000ae26:	f6 08 0b 0e 	st.b	r11[r8],lr
8000ae2a:	20 18       	sub	r8,1
8000ae2c:	58 0a       	cp.w	r10,0
8000ae2e:	cf 91       	brne	8000ae20 <memmove+0x16>
8000ae30:	d8 02       	popm	pc
8000ae32:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ae36:	20 1a       	sub	r10,1
8000ae38:	f8 08 0b 09 	st.b	r12[r8],r9
8000ae3c:	2f f8       	sub	r8,-1
8000ae3e:	c0 28       	rjmp	8000ae42 <memmove+0x38>
8000ae40:	30 08       	mov	r8,0
8000ae42:	58 0a       	cp.w	r10,0
8000ae44:	cf 71       	brne	8000ae32 <memmove+0x28>
8000ae46:	d8 02       	popm	pc

8000ae48 <__hi0bits>:
8000ae48:	18 98       	mov	r8,r12
8000ae4a:	e0 1c 00 00 	andl	r12,0x0
8000ae4e:	f0 09 15 10 	lsl	r9,r8,0x10
8000ae52:	58 0c       	cp.w	r12,0
8000ae54:	f2 08 17 00 	moveq	r8,r9
8000ae58:	f9 bc 00 10 	moveq	r12,16
8000ae5c:	f9 bc 01 00 	movne	r12,0
8000ae60:	10 9a       	mov	r10,r8
8000ae62:	f0 09 15 08 	lsl	r9,r8,0x8
8000ae66:	e6 1a ff 00 	andh	r10,0xff00,COH
8000ae6a:	f7 bc 00 f8 	subeq	r12,-8
8000ae6e:	f2 08 17 00 	moveq	r8,r9
8000ae72:	10 9a       	mov	r10,r8
8000ae74:	f0 09 15 04 	lsl	r9,r8,0x4
8000ae78:	e6 1a f0 00 	andh	r10,0xf000,COH
8000ae7c:	f7 bc 00 fc 	subeq	r12,-4
8000ae80:	f2 08 17 00 	moveq	r8,r9
8000ae84:	10 9a       	mov	r10,r8
8000ae86:	f0 09 15 02 	lsl	r9,r8,0x2
8000ae8a:	e6 1a c0 00 	andh	r10,0xc000,COH
8000ae8e:	f7 bc 00 fe 	subeq	r12,-2
8000ae92:	f2 08 17 00 	moveq	r8,r9
8000ae96:	58 08       	cp.w	r8,0
8000ae98:	5e 5c       	retlt	r12
8000ae9a:	ed b8 00 1e 	bld	r8,0x1e
8000ae9e:	f9 bc 01 20 	movne	r12,32
8000aea2:	f7 bc 00 ff 	subeq	r12,-1
8000aea6:	5e fc       	retal	r12

8000aea8 <__lo0bits>:
8000aea8:	18 99       	mov	r9,r12
8000aeaa:	78 08       	ld.w	r8,r12[0x0]
8000aeac:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000aeb0:	c1 50       	breq	8000aeda <__lo0bits+0x32>
8000aeb2:	ed b8 00 00 	bld	r8,0x0
8000aeb6:	c0 21       	brne	8000aeba <__lo0bits+0x12>
8000aeb8:	5e fd       	retal	0
8000aeba:	10 9b       	mov	r11,r8
8000aebc:	f0 0a 16 01 	lsr	r10,r8,0x1
8000aec0:	e2 1b 00 02 	andl	r11,0x2,COH
8000aec4:	a3 88       	lsr	r8,0x2
8000aec6:	58 0b       	cp.w	r11,0
8000aec8:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000aecc:	f9 bc 01 01 	movne	r12,1
8000aed0:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000aed4:	f9 bc 00 02 	moveq	r12,2
8000aed8:	5e fc       	retal	r12
8000aeda:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000aede:	f0 0b 16 10 	lsr	r11,r8,0x10
8000aee2:	58 0a       	cp.w	r10,0
8000aee4:	f6 08 17 00 	moveq	r8,r11
8000aee8:	f9 bc 00 10 	moveq	r12,16
8000aeec:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000aef0:	f0 0a 16 08 	lsr	r10,r8,0x8
8000aef4:	58 0b       	cp.w	r11,0
8000aef6:	f7 bc 00 f8 	subeq	r12,-8
8000aefa:	f4 08 17 00 	moveq	r8,r10
8000aefe:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000af02:	f0 0a 16 04 	lsr	r10,r8,0x4
8000af06:	58 0b       	cp.w	r11,0
8000af08:	f7 bc 00 fc 	subeq	r12,-4
8000af0c:	f4 08 17 00 	moveq	r8,r10
8000af10:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000af14:	f0 0a 16 02 	lsr	r10,r8,0x2
8000af18:	58 0b       	cp.w	r11,0
8000af1a:	f7 bc 00 fe 	subeq	r12,-2
8000af1e:	f4 08 17 00 	moveq	r8,r10
8000af22:	ed b8 00 00 	bld	r8,0x0
8000af26:	c0 60       	breq	8000af32 <__lo0bits+0x8a>
8000af28:	a1 98       	lsr	r8,0x1
8000af2a:	c0 31       	brne	8000af30 <__lo0bits+0x88>
8000af2c:	32 0c       	mov	r12,32
8000af2e:	5e fc       	retal	r12
8000af30:	2f fc       	sub	r12,-1
8000af32:	93 08       	st.w	r9[0x0],r8
8000af34:	5e fc       	retal	r12

8000af36 <__mcmp>:
8000af36:	d4 01       	pushm	lr
8000af38:	18 98       	mov	r8,r12
8000af3a:	76 49       	ld.w	r9,r11[0x10]
8000af3c:	78 4c       	ld.w	r12,r12[0x10]
8000af3e:	12 1c       	sub	r12,r9
8000af40:	c1 31       	brne	8000af66 <__mcmp+0x30>
8000af42:	2f b9       	sub	r9,-5
8000af44:	a3 69       	lsl	r9,0x2
8000af46:	12 0b       	add	r11,r9
8000af48:	f0 09 00 09 	add	r9,r8,r9
8000af4c:	2e c8       	sub	r8,-20
8000af4e:	13 4e       	ld.w	lr,--r9
8000af50:	17 4a       	ld.w	r10,--r11
8000af52:	14 3e       	cp.w	lr,r10
8000af54:	c0 60       	breq	8000af60 <__mcmp+0x2a>
8000af56:	f9 bc 03 ff 	movlo	r12,-1
8000af5a:	f9 bc 02 01 	movhs	r12,1
8000af5e:	d8 02       	popm	pc
8000af60:	10 39       	cp.w	r9,r8
8000af62:	fe 9b ff f6 	brhi	8000af4e <__mcmp+0x18>
8000af66:	d8 02       	popm	pc

8000af68 <_Bfree>:
8000af68:	d4 21       	pushm	r4-r7,lr
8000af6a:	18 97       	mov	r7,r12
8000af6c:	16 95       	mov	r5,r11
8000af6e:	78 96       	ld.w	r6,r12[0x24]
8000af70:	58 06       	cp.w	r6,0
8000af72:	c0 91       	brne	8000af84 <_Bfree+0x1c>
8000af74:	31 0c       	mov	r12,16
8000af76:	fe b0 de 23 	rcall	80006bbc <malloc>
8000af7a:	99 36       	st.w	r12[0xc],r6
8000af7c:	8f 9c       	st.w	r7[0x24],r12
8000af7e:	99 16       	st.w	r12[0x4],r6
8000af80:	99 26       	st.w	r12[0x8],r6
8000af82:	99 06       	st.w	r12[0x0],r6
8000af84:	58 05       	cp.w	r5,0
8000af86:	c0 90       	breq	8000af98 <_Bfree+0x30>
8000af88:	6a 19       	ld.w	r9,r5[0x4]
8000af8a:	6e 98       	ld.w	r8,r7[0x24]
8000af8c:	70 38       	ld.w	r8,r8[0xc]
8000af8e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000af92:	8b 0a       	st.w	r5[0x0],r10
8000af94:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000af98:	d8 22       	popm	r4-r7,pc
8000af9a:	d7 03       	nop

8000af9c <_Balloc>:
8000af9c:	d4 21       	pushm	r4-r7,lr
8000af9e:	18 97       	mov	r7,r12
8000afa0:	16 96       	mov	r6,r11
8000afa2:	78 95       	ld.w	r5,r12[0x24]
8000afa4:	58 05       	cp.w	r5,0
8000afa6:	c0 91       	brne	8000afb8 <_Balloc+0x1c>
8000afa8:	31 0c       	mov	r12,16
8000afaa:	fe b0 de 09 	rcall	80006bbc <malloc>
8000afae:	99 35       	st.w	r12[0xc],r5
8000afb0:	8f 9c       	st.w	r7[0x24],r12
8000afb2:	99 15       	st.w	r12[0x4],r5
8000afb4:	99 25       	st.w	r12[0x8],r5
8000afb6:	99 05       	st.w	r12[0x0],r5
8000afb8:	6e 95       	ld.w	r5,r7[0x24]
8000afba:	6a 38       	ld.w	r8,r5[0xc]
8000afbc:	58 08       	cp.w	r8,0
8000afbe:	c0 b1       	brne	8000afd4 <_Balloc+0x38>
8000afc0:	31 0a       	mov	r10,16
8000afc2:	30 4b       	mov	r11,4
8000afc4:	0e 9c       	mov	r12,r7
8000afc6:	e0 a0 02 9d 	rcall	8000b500 <_calloc_r>
8000afca:	8b 3c       	st.w	r5[0xc],r12
8000afcc:	6e 98       	ld.w	r8,r7[0x24]
8000afce:	70 3c       	ld.w	r12,r8[0xc]
8000afd0:	58 0c       	cp.w	r12,0
8000afd2:	c1 b0       	breq	8000b008 <_Balloc+0x6c>
8000afd4:	6e 98       	ld.w	r8,r7[0x24]
8000afd6:	70 38       	ld.w	r8,r8[0xc]
8000afd8:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000afdc:	70 0c       	ld.w	r12,r8[0x0]
8000afde:	58 0c       	cp.w	r12,0
8000afe0:	c0 40       	breq	8000afe8 <_Balloc+0x4c>
8000afe2:	78 09       	ld.w	r9,r12[0x0]
8000afe4:	91 09       	st.w	r8[0x0],r9
8000afe6:	c0 e8       	rjmp	8000b002 <_Balloc+0x66>
8000afe8:	0e 9c       	mov	r12,r7
8000afea:	30 17       	mov	r7,1
8000afec:	0e 9b       	mov	r11,r7
8000afee:	ee 06 09 47 	lsl	r7,r7,r6
8000aff2:	ee ca ff fb 	sub	r10,r7,-5
8000aff6:	a3 6a       	lsl	r10,0x2
8000aff8:	e0 a0 02 84 	rcall	8000b500 <_calloc_r>
8000affc:	c0 60       	breq	8000b008 <_Balloc+0x6c>
8000affe:	99 16       	st.w	r12[0x4],r6
8000b000:	99 27       	st.w	r12[0x8],r7
8000b002:	30 08       	mov	r8,0
8000b004:	99 38       	st.w	r12[0xc],r8
8000b006:	99 48       	st.w	r12[0x10],r8
8000b008:	d8 22       	popm	r4-r7,pc
8000b00a:	d7 03       	nop

8000b00c <__d2b>:
8000b00c:	d4 31       	pushm	r0-r7,lr
8000b00e:	20 2d       	sub	sp,8
8000b010:	16 93       	mov	r3,r11
8000b012:	12 96       	mov	r6,r9
8000b014:	10 95       	mov	r5,r8
8000b016:	14 92       	mov	r2,r10
8000b018:	30 1b       	mov	r11,1
8000b01a:	cc 1f       	rcall	8000af9c <_Balloc>
8000b01c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b020:	50 09       	stdsp	sp[0x0],r9
8000b022:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b026:	b5 a9       	sbr	r9,0x14
8000b028:	f0 01 16 14 	lsr	r1,r8,0x14
8000b02c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b030:	18 94       	mov	r4,r12
8000b032:	58 02       	cp.w	r2,0
8000b034:	c1 d0       	breq	8000b06e <__d2b+0x62>
8000b036:	fa cc ff f8 	sub	r12,sp,-8
8000b03a:	18 d2       	st.w	--r12,r2
8000b03c:	c3 6f       	rcall	8000aea8 <__lo0bits>
8000b03e:	40 18       	lddsp	r8,sp[0x4]
8000b040:	c0 d0       	breq	8000b05a <__d2b+0x4e>
8000b042:	40 09       	lddsp	r9,sp[0x0]
8000b044:	f8 0a 11 20 	rsub	r10,r12,32
8000b048:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b04c:	f5 e8 10 08 	or	r8,r10,r8
8000b050:	89 58       	st.w	r4[0x14],r8
8000b052:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b056:	50 09       	stdsp	sp[0x0],r9
8000b058:	c0 28       	rjmp	8000b05c <__d2b+0x50>
8000b05a:	89 58       	st.w	r4[0x14],r8
8000b05c:	40 08       	lddsp	r8,sp[0x0]
8000b05e:	58 08       	cp.w	r8,0
8000b060:	f9 b3 01 02 	movne	r3,2
8000b064:	f9 b3 00 01 	moveq	r3,1
8000b068:	89 68       	st.w	r4[0x18],r8
8000b06a:	89 43       	st.w	r4[0x10],r3
8000b06c:	c0 88       	rjmp	8000b07c <__d2b+0x70>
8000b06e:	1a 9c       	mov	r12,sp
8000b070:	c1 cf       	rcall	8000aea8 <__lo0bits>
8000b072:	30 13       	mov	r3,1
8000b074:	40 08       	lddsp	r8,sp[0x0]
8000b076:	2e 0c       	sub	r12,-32
8000b078:	89 43       	st.w	r4[0x10],r3
8000b07a:	89 58       	st.w	r4[0x14],r8
8000b07c:	58 01       	cp.w	r1,0
8000b07e:	c0 90       	breq	8000b090 <__d2b+0x84>
8000b080:	e2 c1 04 33 	sub	r1,r1,1075
8000b084:	18 01       	add	r1,r12
8000b086:	8d 01       	st.w	r6[0x0],r1
8000b088:	f8 0c 11 35 	rsub	r12,r12,53
8000b08c:	8b 0c       	st.w	r5[0x0],r12
8000b08e:	c0 c8       	rjmp	8000b0a6 <__d2b+0x9a>
8000b090:	e6 c8 ff fc 	sub	r8,r3,-4
8000b094:	f8 cc 04 32 	sub	r12,r12,1074
8000b098:	a5 73       	lsl	r3,0x5
8000b09a:	8d 0c       	st.w	r6[0x0],r12
8000b09c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b0a0:	cd 4e       	rcall	8000ae48 <__hi0bits>
8000b0a2:	18 13       	sub	r3,r12
8000b0a4:	8b 03       	st.w	r5[0x0],r3
8000b0a6:	08 9c       	mov	r12,r4
8000b0a8:	2f ed       	sub	sp,-8
8000b0aa:	d8 32       	popm	r0-r7,pc

8000b0ac <__mdiff>:
8000b0ac:	d4 31       	pushm	r0-r7,lr
8000b0ae:	74 48       	ld.w	r8,r10[0x10]
8000b0b0:	76 45       	ld.w	r5,r11[0x10]
8000b0b2:	16 97       	mov	r7,r11
8000b0b4:	14 96       	mov	r6,r10
8000b0b6:	10 15       	sub	r5,r8
8000b0b8:	c1 31       	brne	8000b0de <__mdiff+0x32>
8000b0ba:	2f b8       	sub	r8,-5
8000b0bc:	ee ce ff ec 	sub	lr,r7,-20
8000b0c0:	a3 68       	lsl	r8,0x2
8000b0c2:	f4 08 00 0b 	add	r11,r10,r8
8000b0c6:	ee 08 00 08 	add	r8,r7,r8
8000b0ca:	11 4a       	ld.w	r10,--r8
8000b0cc:	17 49       	ld.w	r9,--r11
8000b0ce:	12 3a       	cp.w	r10,r9
8000b0d0:	c0 30       	breq	8000b0d6 <__mdiff+0x2a>
8000b0d2:	c0 e2       	brcc	8000b0ee <__mdiff+0x42>
8000b0d4:	c0 78       	rjmp	8000b0e2 <__mdiff+0x36>
8000b0d6:	1c 38       	cp.w	r8,lr
8000b0d8:	fe 9b ff f9 	brhi	8000b0ca <__mdiff+0x1e>
8000b0dc:	c4 98       	rjmp	8000b16e <__mdiff+0xc2>
8000b0de:	58 05       	cp.w	r5,0
8000b0e0:	c0 64       	brge	8000b0ec <__mdiff+0x40>
8000b0e2:	0e 98       	mov	r8,r7
8000b0e4:	30 15       	mov	r5,1
8000b0e6:	0c 97       	mov	r7,r6
8000b0e8:	10 96       	mov	r6,r8
8000b0ea:	c0 28       	rjmp	8000b0ee <__mdiff+0x42>
8000b0ec:	30 05       	mov	r5,0
8000b0ee:	6e 1b       	ld.w	r11,r7[0x4]
8000b0f0:	c5 6f       	rcall	8000af9c <_Balloc>
8000b0f2:	6e 49       	ld.w	r9,r7[0x10]
8000b0f4:	6c 44       	ld.w	r4,r6[0x10]
8000b0f6:	99 35       	st.w	r12[0xc],r5
8000b0f8:	2f b4       	sub	r4,-5
8000b0fa:	f2 c5 ff fb 	sub	r5,r9,-5
8000b0fe:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b102:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b106:	2e c6       	sub	r6,-20
8000b108:	2e c7       	sub	r7,-20
8000b10a:	f8 c8 ff ec 	sub	r8,r12,-20
8000b10e:	30 0a       	mov	r10,0
8000b110:	0f 0e       	ld.w	lr,r7++
8000b112:	0d 0b       	ld.w	r11,r6++
8000b114:	fc 02 16 10 	lsr	r2,lr,0x10
8000b118:	f6 03 16 10 	lsr	r3,r11,0x10
8000b11c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b120:	e4 03 01 03 	sub	r3,r2,r3
8000b124:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b128:	fc 0b 01 0b 	sub	r11,lr,r11
8000b12c:	f6 0a 00 0a 	add	r10,r11,r10
8000b130:	b0 1a       	st.h	r8[0x2],r10
8000b132:	b1 4a       	asr	r10,0x10
8000b134:	e6 0a 00 0a 	add	r10,r3,r10
8000b138:	b0 0a       	st.h	r8[0x0],r10
8000b13a:	2f c8       	sub	r8,-4
8000b13c:	b1 4a       	asr	r10,0x10
8000b13e:	08 36       	cp.w	r6,r4
8000b140:	ce 83       	brcs	8000b110 <__mdiff+0x64>
8000b142:	c0 d8       	rjmp	8000b15c <__mdiff+0xb0>
8000b144:	0f 0b       	ld.w	r11,r7++
8000b146:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b14a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b14e:	16 0a       	add	r10,r11
8000b150:	b0 1a       	st.h	r8[0x2],r10
8000b152:	b1 4a       	asr	r10,0x10
8000b154:	1c 0a       	add	r10,lr
8000b156:	b0 0a       	st.h	r8[0x0],r10
8000b158:	2f c8       	sub	r8,-4
8000b15a:	b1 4a       	asr	r10,0x10
8000b15c:	0a 37       	cp.w	r7,r5
8000b15e:	cf 33       	brcs	8000b144 <__mdiff+0x98>
8000b160:	c0 28       	rjmp	8000b164 <__mdiff+0xb8>
8000b162:	20 19       	sub	r9,1
8000b164:	11 4a       	ld.w	r10,--r8
8000b166:	58 0a       	cp.w	r10,0
8000b168:	cf d0       	breq	8000b162 <__mdiff+0xb6>
8000b16a:	99 49       	st.w	r12[0x10],r9
8000b16c:	d8 32       	popm	r0-r7,pc
8000b16e:	30 0b       	mov	r11,0
8000b170:	c1 6f       	rcall	8000af9c <_Balloc>
8000b172:	30 18       	mov	r8,1
8000b174:	99 48       	st.w	r12[0x10],r8
8000b176:	30 08       	mov	r8,0
8000b178:	99 58       	st.w	r12[0x14],r8
8000b17a:	d8 32       	popm	r0-r7,pc

8000b17c <__lshift>:
8000b17c:	d4 31       	pushm	r0-r7,lr
8000b17e:	16 97       	mov	r7,r11
8000b180:	76 46       	ld.w	r6,r11[0x10]
8000b182:	f4 02 14 05 	asr	r2,r10,0x5
8000b186:	2f f6       	sub	r6,-1
8000b188:	14 93       	mov	r3,r10
8000b18a:	18 94       	mov	r4,r12
8000b18c:	04 06       	add	r6,r2
8000b18e:	76 1b       	ld.w	r11,r11[0x4]
8000b190:	6e 28       	ld.w	r8,r7[0x8]
8000b192:	c0 38       	rjmp	8000b198 <__lshift+0x1c>
8000b194:	2f fb       	sub	r11,-1
8000b196:	a1 78       	lsl	r8,0x1
8000b198:	10 36       	cp.w	r6,r8
8000b19a:	fe 99 ff fd 	brgt	8000b194 <__lshift+0x18>
8000b19e:	08 9c       	mov	r12,r4
8000b1a0:	cf ee       	rcall	8000af9c <_Balloc>
8000b1a2:	30 09       	mov	r9,0
8000b1a4:	18 95       	mov	r5,r12
8000b1a6:	f8 c8 ff ec 	sub	r8,r12,-20
8000b1aa:	12 9a       	mov	r10,r9
8000b1ac:	c0 38       	rjmp	8000b1b2 <__lshift+0x36>
8000b1ae:	10 aa       	st.w	r8++,r10
8000b1b0:	2f f9       	sub	r9,-1
8000b1b2:	04 39       	cp.w	r9,r2
8000b1b4:	cf d5       	brlt	8000b1ae <__lshift+0x32>
8000b1b6:	6e 4b       	ld.w	r11,r7[0x10]
8000b1b8:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b1bc:	2f bb       	sub	r11,-5
8000b1be:	ee c9 ff ec 	sub	r9,r7,-20
8000b1c2:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b1c6:	58 03       	cp.w	r3,0
8000b1c8:	c1 30       	breq	8000b1ee <__lshift+0x72>
8000b1ca:	e6 0c 11 20 	rsub	r12,r3,32
8000b1ce:	30 0a       	mov	r10,0
8000b1d0:	72 02       	ld.w	r2,r9[0x0]
8000b1d2:	e4 03 09 42 	lsl	r2,r2,r3
8000b1d6:	04 4a       	or	r10,r2
8000b1d8:	10 aa       	st.w	r8++,r10
8000b1da:	13 0a       	ld.w	r10,r9++
8000b1dc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b1e0:	16 39       	cp.w	r9,r11
8000b1e2:	cf 73       	brcs	8000b1d0 <__lshift+0x54>
8000b1e4:	91 0a       	st.w	r8[0x0],r10
8000b1e6:	58 0a       	cp.w	r10,0
8000b1e8:	c0 70       	breq	8000b1f6 <__lshift+0x7a>
8000b1ea:	2f f6       	sub	r6,-1
8000b1ec:	c0 58       	rjmp	8000b1f6 <__lshift+0x7a>
8000b1ee:	13 0a       	ld.w	r10,r9++
8000b1f0:	10 aa       	st.w	r8++,r10
8000b1f2:	16 39       	cp.w	r9,r11
8000b1f4:	cf d3       	brcs	8000b1ee <__lshift+0x72>
8000b1f6:	08 9c       	mov	r12,r4
8000b1f8:	20 16       	sub	r6,1
8000b1fa:	0e 9b       	mov	r11,r7
8000b1fc:	8b 46       	st.w	r5[0x10],r6
8000b1fe:	cb 5e       	rcall	8000af68 <_Bfree>
8000b200:	0a 9c       	mov	r12,r5
8000b202:	d8 32       	popm	r0-r7,pc

8000b204 <__multiply>:
8000b204:	d4 31       	pushm	r0-r7,lr
8000b206:	20 2d       	sub	sp,8
8000b208:	76 49       	ld.w	r9,r11[0x10]
8000b20a:	74 48       	ld.w	r8,r10[0x10]
8000b20c:	16 96       	mov	r6,r11
8000b20e:	14 95       	mov	r5,r10
8000b210:	10 39       	cp.w	r9,r8
8000b212:	ec 08 17 50 	movlt	r8,r6
8000b216:	ea 06 17 50 	movlt	r6,r5
8000b21a:	f0 05 17 50 	movlt	r5,r8
8000b21e:	6c 28       	ld.w	r8,r6[0x8]
8000b220:	76 43       	ld.w	r3,r11[0x10]
8000b222:	74 42       	ld.w	r2,r10[0x10]
8000b224:	76 1b       	ld.w	r11,r11[0x4]
8000b226:	e4 03 00 07 	add	r7,r2,r3
8000b22a:	10 37       	cp.w	r7,r8
8000b22c:	f7 bb 09 ff 	subgt	r11,-1
8000b230:	cb 6e       	rcall	8000af9c <_Balloc>
8000b232:	ee c4 ff fb 	sub	r4,r7,-5
8000b236:	f8 c9 ff ec 	sub	r9,r12,-20
8000b23a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b23e:	30 0a       	mov	r10,0
8000b240:	12 98       	mov	r8,r9
8000b242:	c0 28       	rjmp	8000b246 <__multiply+0x42>
8000b244:	10 aa       	st.w	r8++,r10
8000b246:	08 38       	cp.w	r8,r4
8000b248:	cf e3       	brcs	8000b244 <__multiply+0x40>
8000b24a:	2f b3       	sub	r3,-5
8000b24c:	2f b2       	sub	r2,-5
8000b24e:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b252:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b256:	ec cb ff ec 	sub	r11,r6,-20
8000b25a:	50 12       	stdsp	sp[0x4],r2
8000b25c:	ea ca ff ec 	sub	r10,r5,-20
8000b260:	c4 48       	rjmp	8000b2e8 <__multiply+0xe4>
8000b262:	94 95       	ld.uh	r5,r10[0x2]
8000b264:	58 05       	cp.w	r5,0
8000b266:	c2 00       	breq	8000b2a6 <__multiply+0xa2>
8000b268:	12 98       	mov	r8,r9
8000b26a:	16 96       	mov	r6,r11
8000b26c:	30 0e       	mov	lr,0
8000b26e:	50 09       	stdsp	sp[0x0],r9
8000b270:	0d 02       	ld.w	r2,r6++
8000b272:	e4 00 16 10 	lsr	r0,r2,0x10
8000b276:	70 01       	ld.w	r1,r8[0x0]
8000b278:	70 09       	ld.w	r9,r8[0x0]
8000b27a:	b1 81       	lsr	r1,0x10
8000b27c:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b280:	e0 05 03 41 	mac	r1,r0,r5
8000b284:	ab 32       	mul	r2,r5
8000b286:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b28a:	00 02       	add	r2,r0
8000b28c:	e4 0e 00 0e 	add	lr,r2,lr
8000b290:	b0 1e       	st.h	r8[0x2],lr
8000b292:	b1 8e       	lsr	lr,0x10
8000b294:	1c 01       	add	r1,lr
8000b296:	b0 01       	st.h	r8[0x0],r1
8000b298:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b29c:	2f c8       	sub	r8,-4
8000b29e:	06 36       	cp.w	r6,r3
8000b2a0:	ce 83       	brcs	8000b270 <__multiply+0x6c>
8000b2a2:	40 09       	lddsp	r9,sp[0x0]
8000b2a4:	91 0e       	st.w	r8[0x0],lr
8000b2a6:	94 86       	ld.uh	r6,r10[0x0]
8000b2a8:	58 06       	cp.w	r6,0
8000b2aa:	c1 d0       	breq	8000b2e4 <__multiply+0xe0>
8000b2ac:	72 02       	ld.w	r2,r9[0x0]
8000b2ae:	12 98       	mov	r8,r9
8000b2b0:	16 9e       	mov	lr,r11
8000b2b2:	30 05       	mov	r5,0
8000b2b4:	b0 12       	st.h	r8[0x2],r2
8000b2b6:	1d 01       	ld.w	r1,lr++
8000b2b8:	90 82       	ld.uh	r2,r8[0x0]
8000b2ba:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b2be:	ad 30       	mul	r0,r6
8000b2c0:	e0 02 00 02 	add	r2,r0,r2
8000b2c4:	e4 05 00 05 	add	r5,r2,r5
8000b2c8:	b0 05       	st.h	r8[0x0],r5
8000b2ca:	b1 85       	lsr	r5,0x10
8000b2cc:	b1 81       	lsr	r1,0x10
8000b2ce:	2f c8       	sub	r8,-4
8000b2d0:	ad 31       	mul	r1,r6
8000b2d2:	90 92       	ld.uh	r2,r8[0x2]
8000b2d4:	e2 02 00 02 	add	r2,r1,r2
8000b2d8:	0a 02       	add	r2,r5
8000b2da:	e4 05 16 10 	lsr	r5,r2,0x10
8000b2de:	06 3e       	cp.w	lr,r3
8000b2e0:	ce a3       	brcs	8000b2b4 <__multiply+0xb0>
8000b2e2:	91 02       	st.w	r8[0x0],r2
8000b2e4:	2f ca       	sub	r10,-4
8000b2e6:	2f c9       	sub	r9,-4
8000b2e8:	40 18       	lddsp	r8,sp[0x4]
8000b2ea:	10 3a       	cp.w	r10,r8
8000b2ec:	cb b3       	brcs	8000b262 <__multiply+0x5e>
8000b2ee:	c0 28       	rjmp	8000b2f2 <__multiply+0xee>
8000b2f0:	20 17       	sub	r7,1
8000b2f2:	58 07       	cp.w	r7,0
8000b2f4:	e0 8a 00 05 	brle	8000b2fe <__multiply+0xfa>
8000b2f8:	09 48       	ld.w	r8,--r4
8000b2fa:	58 08       	cp.w	r8,0
8000b2fc:	cf a0       	breq	8000b2f0 <__multiply+0xec>
8000b2fe:	99 47       	st.w	r12[0x10],r7
8000b300:	2f ed       	sub	sp,-8
8000b302:	d8 32       	popm	r0-r7,pc

8000b304 <__i2b>:
8000b304:	d4 21       	pushm	r4-r7,lr
8000b306:	16 97       	mov	r7,r11
8000b308:	30 1b       	mov	r11,1
8000b30a:	c4 9e       	rcall	8000af9c <_Balloc>
8000b30c:	30 19       	mov	r9,1
8000b30e:	99 57       	st.w	r12[0x14],r7
8000b310:	99 49       	st.w	r12[0x10],r9
8000b312:	d8 22       	popm	r4-r7,pc

8000b314 <__multadd>:
8000b314:	d4 31       	pushm	r0-r7,lr
8000b316:	30 08       	mov	r8,0
8000b318:	12 95       	mov	r5,r9
8000b31a:	16 97       	mov	r7,r11
8000b31c:	18 96       	mov	r6,r12
8000b31e:	76 44       	ld.w	r4,r11[0x10]
8000b320:	f6 c9 ff ec 	sub	r9,r11,-20
8000b324:	72 0b       	ld.w	r11,r9[0x0]
8000b326:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b32a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b32e:	f4 0c 02 4c 	mul	r12,r10,r12
8000b332:	f4 0b 03 45 	mac	r5,r10,r11
8000b336:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b33a:	b1 85       	lsr	r5,0x10
8000b33c:	18 05       	add	r5,r12
8000b33e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b342:	f8 0b 00 0b 	add	r11,r12,r11
8000b346:	12 ab       	st.w	r9++,r11
8000b348:	2f f8       	sub	r8,-1
8000b34a:	b1 85       	lsr	r5,0x10
8000b34c:	08 38       	cp.w	r8,r4
8000b34e:	ce b5       	brlt	8000b324 <__multadd+0x10>
8000b350:	58 05       	cp.w	r5,0
8000b352:	c1 c0       	breq	8000b38a <__multadd+0x76>
8000b354:	6e 28       	ld.w	r8,r7[0x8]
8000b356:	10 34       	cp.w	r4,r8
8000b358:	c1 35       	brlt	8000b37e <__multadd+0x6a>
8000b35a:	6e 1b       	ld.w	r11,r7[0x4]
8000b35c:	0c 9c       	mov	r12,r6
8000b35e:	2f fb       	sub	r11,-1
8000b360:	c1 ee       	rcall	8000af9c <_Balloc>
8000b362:	6e 4a       	ld.w	r10,r7[0x10]
8000b364:	ee cb ff f4 	sub	r11,r7,-12
8000b368:	18 93       	mov	r3,r12
8000b36a:	2f ea       	sub	r10,-2
8000b36c:	2f 4c       	sub	r12,-12
8000b36e:	a3 6a       	lsl	r10,0x2
8000b370:	fe b0 de 4a 	rcall	80007004 <memcpy>
8000b374:	0e 9b       	mov	r11,r7
8000b376:	0c 9c       	mov	r12,r6
8000b378:	fe b0 fd f8 	rcall	8000af68 <_Bfree>
8000b37c:	06 97       	mov	r7,r3
8000b37e:	e8 c8 ff ff 	sub	r8,r4,-1
8000b382:	2f b4       	sub	r4,-5
8000b384:	8f 48       	st.w	r7[0x10],r8
8000b386:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b38a:	0e 9c       	mov	r12,r7
8000b38c:	d8 32       	popm	r0-r7,pc
8000b38e:	d7 03       	nop

8000b390 <__pow5mult>:
8000b390:	d4 31       	pushm	r0-r7,lr
8000b392:	14 96       	mov	r6,r10
8000b394:	18 97       	mov	r7,r12
8000b396:	16 94       	mov	r4,r11
8000b398:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b39c:	c0 80       	breq	8000b3ac <__pow5mult+0x1c>
8000b39e:	20 18       	sub	r8,1
8000b3a0:	49 f9       	lddpc	r9,8000b41c <__pow5mult+0x8c>
8000b3a2:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b3a6:	30 09       	mov	r9,0
8000b3a8:	cb 6f       	rcall	8000b314 <__multadd>
8000b3aa:	18 94       	mov	r4,r12
8000b3ac:	a3 46       	asr	r6,0x2
8000b3ae:	c3 40       	breq	8000b416 <__pow5mult+0x86>
8000b3b0:	6e 95       	ld.w	r5,r7[0x24]
8000b3b2:	58 05       	cp.w	r5,0
8000b3b4:	c0 91       	brne	8000b3c6 <__pow5mult+0x36>
8000b3b6:	31 0c       	mov	r12,16
8000b3b8:	fe b0 dc 02 	rcall	80006bbc <malloc>
8000b3bc:	99 35       	st.w	r12[0xc],r5
8000b3be:	8f 9c       	st.w	r7[0x24],r12
8000b3c0:	99 15       	st.w	r12[0x4],r5
8000b3c2:	99 25       	st.w	r12[0x8],r5
8000b3c4:	99 05       	st.w	r12[0x0],r5
8000b3c6:	6e 93       	ld.w	r3,r7[0x24]
8000b3c8:	66 25       	ld.w	r5,r3[0x8]
8000b3ca:	58 05       	cp.w	r5,0
8000b3cc:	c0 c1       	brne	8000b3e4 <__pow5mult+0x54>
8000b3ce:	e0 6b 02 71 	mov	r11,625
8000b3d2:	0e 9c       	mov	r12,r7
8000b3d4:	c9 8f       	rcall	8000b304 <__i2b>
8000b3d6:	87 2c       	st.w	r3[0x8],r12
8000b3d8:	30 08       	mov	r8,0
8000b3da:	18 95       	mov	r5,r12
8000b3dc:	99 08       	st.w	r12[0x0],r8
8000b3de:	c0 38       	rjmp	8000b3e4 <__pow5mult+0x54>
8000b3e0:	06 9c       	mov	r12,r3
8000b3e2:	18 95       	mov	r5,r12
8000b3e4:	ed b6 00 00 	bld	r6,0x0
8000b3e8:	c0 b1       	brne	8000b3fe <__pow5mult+0x6e>
8000b3ea:	08 9b       	mov	r11,r4
8000b3ec:	0a 9a       	mov	r10,r5
8000b3ee:	0e 9c       	mov	r12,r7
8000b3f0:	c0 af       	rcall	8000b204 <__multiply>
8000b3f2:	08 9b       	mov	r11,r4
8000b3f4:	18 93       	mov	r3,r12
8000b3f6:	0e 9c       	mov	r12,r7
8000b3f8:	06 94       	mov	r4,r3
8000b3fa:	fe b0 fd b7 	rcall	8000af68 <_Bfree>
8000b3fe:	a1 56       	asr	r6,0x1
8000b400:	c0 b0       	breq	8000b416 <__pow5mult+0x86>
8000b402:	6a 03       	ld.w	r3,r5[0x0]
8000b404:	58 03       	cp.w	r3,0
8000b406:	ce d1       	brne	8000b3e0 <__pow5mult+0x50>
8000b408:	0a 9a       	mov	r10,r5
8000b40a:	0a 9b       	mov	r11,r5
8000b40c:	0e 9c       	mov	r12,r7
8000b40e:	cf be       	rcall	8000b204 <__multiply>
8000b410:	8b 0c       	st.w	r5[0x0],r12
8000b412:	99 03       	st.w	r12[0x0],r3
8000b414:	ce 7b       	rjmp	8000b3e2 <__pow5mult+0x52>
8000b416:	08 9c       	mov	r12,r4
8000b418:	d8 32       	popm	r0-r7,pc
8000b41a:	d7 03       	nop
8000b41c:	80 01       	ld.sh	r1,r0[0x0]
8000b41e:	61 bc       	ld.w	r12,r0[0x6c]

8000b420 <__isinfd>:
8000b420:	14 98       	mov	r8,r10
8000b422:	fc 19 7f f0 	movh	r9,0x7ff0
8000b426:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b42a:	f0 0b 11 00 	rsub	r11,r8,0
8000b42e:	f7 e8 10 08 	or	r8,r11,r8
8000b432:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b436:	f2 08 01 08 	sub	r8,r9,r8
8000b43a:	f0 0c 11 00 	rsub	r12,r8,0
8000b43e:	f9 e8 10 08 	or	r8,r12,r8
8000b442:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b446:	2f fc       	sub	r12,-1
8000b448:	5e fc       	retal	r12

8000b44a <__isnand>:
8000b44a:	14 98       	mov	r8,r10
8000b44c:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b450:	f0 0c 11 00 	rsub	r12,r8,0
8000b454:	10 4c       	or	r12,r8
8000b456:	fc 18 7f f0 	movh	r8,0x7ff0
8000b45a:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b45e:	f0 0c 01 0c 	sub	r12,r8,r12
8000b462:	bf 9c       	lsr	r12,0x1f
8000b464:	5e fc       	retal	r12
8000b466:	d7 03       	nop

8000b468 <__sclose>:
8000b468:	d4 01       	pushm	lr
8000b46a:	96 7b       	ld.sh	r11,r11[0xe]
8000b46c:	c7 6c       	rcall	8000b558 <_close_r>
8000b46e:	d8 02       	popm	pc

8000b470 <__sseek>:
8000b470:	d4 21       	pushm	r4-r7,lr
8000b472:	16 97       	mov	r7,r11
8000b474:	96 7b       	ld.sh	r11,r11[0xe]
8000b476:	cf 9c       	rcall	8000b668 <_lseek_r>
8000b478:	8e 68       	ld.sh	r8,r7[0xc]
8000b47a:	10 99       	mov	r9,r8
8000b47c:	ad c8       	cbr	r8,0xc
8000b47e:	ad a9       	sbr	r9,0xc
8000b480:	5b fc       	cp.w	r12,-1
8000b482:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b486:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b48a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b48e:	d8 22       	popm	r4-r7,pc

8000b490 <__swrite>:
8000b490:	d4 21       	pushm	r4-r7,lr
8000b492:	96 68       	ld.sh	r8,r11[0xc]
8000b494:	16 97       	mov	r7,r11
8000b496:	14 95       	mov	r5,r10
8000b498:	12 94       	mov	r4,r9
8000b49a:	e2 18 01 00 	andl	r8,0x100,COH
8000b49e:	18 96       	mov	r6,r12
8000b4a0:	c0 50       	breq	8000b4aa <__swrite+0x1a>
8000b4a2:	30 29       	mov	r9,2
8000b4a4:	30 0a       	mov	r10,0
8000b4a6:	96 7b       	ld.sh	r11,r11[0xe]
8000b4a8:	ce 0c       	rcall	8000b668 <_lseek_r>
8000b4aa:	8e 68       	ld.sh	r8,r7[0xc]
8000b4ac:	ad c8       	cbr	r8,0xc
8000b4ae:	08 99       	mov	r9,r4
8000b4b0:	0a 9a       	mov	r10,r5
8000b4b2:	8e 7b       	ld.sh	r11,r7[0xe]
8000b4b4:	0c 9c       	mov	r12,r6
8000b4b6:	ae 68       	st.h	r7[0xc],r8
8000b4b8:	c1 0c       	rcall	8000b4d8 <_write_r>
8000b4ba:	d8 22       	popm	r4-r7,pc

8000b4bc <__sread>:
8000b4bc:	d4 21       	pushm	r4-r7,lr
8000b4be:	16 97       	mov	r7,r11
8000b4c0:	96 7b       	ld.sh	r11,r11[0xe]
8000b4c2:	ce 7c       	rcall	8000b690 <_read_r>
8000b4c4:	c0 65       	brlt	8000b4d0 <__sread+0x14>
8000b4c6:	6f 58       	ld.w	r8,r7[0x54]
8000b4c8:	18 08       	add	r8,r12
8000b4ca:	ef 48 00 54 	st.w	r7[84],r8
8000b4ce:	d8 22       	popm	r4-r7,pc
8000b4d0:	8e 68       	ld.sh	r8,r7[0xc]
8000b4d2:	ad c8       	cbr	r8,0xc
8000b4d4:	ae 68       	st.h	r7[0xc],r8
8000b4d6:	d8 22       	popm	r4-r7,pc

8000b4d8 <_write_r>:
8000b4d8:	d4 21       	pushm	r4-r7,lr
8000b4da:	16 98       	mov	r8,r11
8000b4dc:	18 97       	mov	r7,r12
8000b4de:	10 9c       	mov	r12,r8
8000b4e0:	30 08       	mov	r8,0
8000b4e2:	14 9b       	mov	r11,r10
8000b4e4:	e0 66 41 2c 	mov	r6,16684
8000b4e8:	12 9a       	mov	r10,r9
8000b4ea:	8d 08       	st.w	r6[0x0],r8
8000b4ec:	fe b0 d1 08 	rcall	800056fc <_write>
8000b4f0:	5b fc       	cp.w	r12,-1
8000b4f2:	c0 51       	brne	8000b4fc <_write_r+0x24>
8000b4f4:	6c 08       	ld.w	r8,r6[0x0]
8000b4f6:	58 08       	cp.w	r8,0
8000b4f8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b4fc:	d8 22       	popm	r4-r7,pc
8000b4fe:	d7 03       	nop

8000b500 <_calloc_r>:
8000b500:	d4 21       	pushm	r4-r7,lr
8000b502:	f4 0b 02 4b 	mul	r11,r10,r11
8000b506:	fe b0 db 63 	rcall	80006bcc <_malloc_r>
8000b50a:	18 97       	mov	r7,r12
8000b50c:	c2 30       	breq	8000b552 <_calloc_r+0x52>
8000b50e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b512:	e0 1a ff fc 	andl	r10,0xfffc
8000b516:	20 4a       	sub	r10,4
8000b518:	e0 4a 00 24 	cp.w	r10,36
8000b51c:	e0 8b 00 18 	brhi	8000b54c <_calloc_r+0x4c>
8000b520:	18 98       	mov	r8,r12
8000b522:	59 3a       	cp.w	r10,19
8000b524:	e0 88 00 0f 	brls	8000b542 <_calloc_r+0x42>
8000b528:	30 09       	mov	r9,0
8000b52a:	10 a9       	st.w	r8++,r9
8000b52c:	10 a9       	st.w	r8++,r9
8000b52e:	59 ba       	cp.w	r10,27
8000b530:	e0 88 00 09 	brls	8000b542 <_calloc_r+0x42>
8000b534:	10 a9       	st.w	r8++,r9
8000b536:	10 a9       	st.w	r8++,r9
8000b538:	e0 4a 00 24 	cp.w	r10,36
8000b53c:	c0 31       	brne	8000b542 <_calloc_r+0x42>
8000b53e:	10 a9       	st.w	r8++,r9
8000b540:	10 a9       	st.w	r8++,r9
8000b542:	30 09       	mov	r9,0
8000b544:	10 a9       	st.w	r8++,r9
8000b546:	91 19       	st.w	r8[0x4],r9
8000b548:	91 09       	st.w	r8[0x0],r9
8000b54a:	c0 48       	rjmp	8000b552 <_calloc_r+0x52>
8000b54c:	30 0b       	mov	r11,0
8000b54e:	fe b0 dd ff 	rcall	8000714c <memset>
8000b552:	0e 9c       	mov	r12,r7
8000b554:	d8 22       	popm	r4-r7,pc
8000b556:	d7 03       	nop

8000b558 <_close_r>:
8000b558:	d4 21       	pushm	r4-r7,lr
8000b55a:	30 08       	mov	r8,0
8000b55c:	18 97       	mov	r7,r12
8000b55e:	e0 66 41 2c 	mov	r6,16684
8000b562:	16 9c       	mov	r12,r11
8000b564:	8d 08       	st.w	r6[0x0],r8
8000b566:	fe b0 df a5 	rcall	800074b0 <_close>
8000b56a:	5b fc       	cp.w	r12,-1
8000b56c:	c0 51       	brne	8000b576 <_close_r+0x1e>
8000b56e:	6c 08       	ld.w	r8,r6[0x0]
8000b570:	58 08       	cp.w	r8,0
8000b572:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b576:	d8 22       	popm	r4-r7,pc

8000b578 <_fclose_r>:
8000b578:	d4 21       	pushm	r4-r7,lr
8000b57a:	18 96       	mov	r6,r12
8000b57c:	16 97       	mov	r7,r11
8000b57e:	58 0b       	cp.w	r11,0
8000b580:	c0 31       	brne	8000b586 <_fclose_r+0xe>
8000b582:	16 95       	mov	r5,r11
8000b584:	c5 08       	rjmp	8000b624 <_fclose_r+0xac>
8000b586:	fe b0 f8 b1 	rcall	8000a6e8 <__sfp_lock_acquire>
8000b58a:	58 06       	cp.w	r6,0
8000b58c:	c0 70       	breq	8000b59a <_fclose_r+0x22>
8000b58e:	6c 68       	ld.w	r8,r6[0x18]
8000b590:	58 08       	cp.w	r8,0
8000b592:	c0 41       	brne	8000b59a <_fclose_r+0x22>
8000b594:	0c 9c       	mov	r12,r6
8000b596:	fe b0 f8 fd 	rcall	8000a790 <__sinit>
8000b59a:	4a 48       	lddpc	r8,8000b628 <_fclose_r+0xb0>
8000b59c:	10 37       	cp.w	r7,r8
8000b59e:	c0 31       	brne	8000b5a4 <_fclose_r+0x2c>
8000b5a0:	6c 07       	ld.w	r7,r6[0x0]
8000b5a2:	c0 a8       	rjmp	8000b5b6 <_fclose_r+0x3e>
8000b5a4:	4a 28       	lddpc	r8,8000b62c <_fclose_r+0xb4>
8000b5a6:	10 37       	cp.w	r7,r8
8000b5a8:	c0 31       	brne	8000b5ae <_fclose_r+0x36>
8000b5aa:	6c 17       	ld.w	r7,r6[0x4]
8000b5ac:	c0 58       	rjmp	8000b5b6 <_fclose_r+0x3e>
8000b5ae:	4a 18       	lddpc	r8,8000b630 <_fclose_r+0xb8>
8000b5b0:	10 37       	cp.w	r7,r8
8000b5b2:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b5b6:	8e 69       	ld.sh	r9,r7[0xc]
8000b5b8:	30 08       	mov	r8,0
8000b5ba:	f0 09 19 00 	cp.h	r9,r8
8000b5be:	c0 51       	brne	8000b5c8 <_fclose_r+0x50>
8000b5c0:	fe b0 f8 95 	rcall	8000a6ea <__sfp_lock_release>
8000b5c4:	30 05       	mov	r5,0
8000b5c6:	c2 f8       	rjmp	8000b624 <_fclose_r+0xac>
8000b5c8:	0e 9b       	mov	r11,r7
8000b5ca:	0c 9c       	mov	r12,r6
8000b5cc:	fe b0 f8 06 	rcall	8000a5d8 <_fflush_r>
8000b5d0:	6e c8       	ld.w	r8,r7[0x30]
8000b5d2:	18 95       	mov	r5,r12
8000b5d4:	58 08       	cp.w	r8,0
8000b5d6:	c0 60       	breq	8000b5e2 <_fclose_r+0x6a>
8000b5d8:	6e 8b       	ld.w	r11,r7[0x20]
8000b5da:	0c 9c       	mov	r12,r6
8000b5dc:	5d 18       	icall	r8
8000b5de:	f9 b5 05 ff 	movlt	r5,-1
8000b5e2:	8e 68       	ld.sh	r8,r7[0xc]
8000b5e4:	ed b8 00 07 	bld	r8,0x7
8000b5e8:	c0 51       	brne	8000b5f2 <_fclose_r+0x7a>
8000b5ea:	6e 4b       	ld.w	r11,r7[0x10]
8000b5ec:	0c 9c       	mov	r12,r6
8000b5ee:	fe b0 f9 6b 	rcall	8000a8c4 <_free_r>
8000b5f2:	6e db       	ld.w	r11,r7[0x34]
8000b5f4:	58 0b       	cp.w	r11,0
8000b5f6:	c0 a0       	breq	8000b60a <_fclose_r+0x92>
8000b5f8:	ee c8 ff bc 	sub	r8,r7,-68
8000b5fc:	10 3b       	cp.w	r11,r8
8000b5fe:	c0 40       	breq	8000b606 <_fclose_r+0x8e>
8000b600:	0c 9c       	mov	r12,r6
8000b602:	fe b0 f9 61 	rcall	8000a8c4 <_free_r>
8000b606:	30 08       	mov	r8,0
8000b608:	8f d8       	st.w	r7[0x34],r8
8000b60a:	6f 2b       	ld.w	r11,r7[0x48]
8000b60c:	58 0b       	cp.w	r11,0
8000b60e:	c0 70       	breq	8000b61c <_fclose_r+0xa4>
8000b610:	0c 9c       	mov	r12,r6
8000b612:	fe b0 f9 59 	rcall	8000a8c4 <_free_r>
8000b616:	30 08       	mov	r8,0
8000b618:	ef 48 00 48 	st.w	r7[72],r8
8000b61c:	30 08       	mov	r8,0
8000b61e:	ae 68       	st.h	r7[0xc],r8
8000b620:	fe b0 f8 65 	rcall	8000a6ea <__sfp_lock_release>
8000b624:	0a 9c       	mov	r12,r5
8000b626:	d8 22       	popm	r4-r7,pc
8000b628:	80 01       	ld.sh	r1,r0[0x0]
8000b62a:	61 18       	ld.w	r8,r0[0x44]
8000b62c:	80 01       	ld.sh	r1,r0[0x0]
8000b62e:	61 38       	ld.w	r8,r0[0x4c]
8000b630:	80 01       	ld.sh	r1,r0[0x0]
8000b632:	61 58       	ld.w	r8,r0[0x54]

8000b634 <fclose>:
8000b634:	d4 01       	pushm	lr
8000b636:	e0 68 0a 30 	mov	r8,2608
8000b63a:	18 9b       	mov	r11,r12
8000b63c:	70 0c       	ld.w	r12,r8[0x0]
8000b63e:	c9 df       	rcall	8000b578 <_fclose_r>
8000b640:	d8 02       	popm	pc
8000b642:	d7 03       	nop

8000b644 <_fstat_r>:
8000b644:	d4 21       	pushm	r4-r7,lr
8000b646:	16 98       	mov	r8,r11
8000b648:	18 97       	mov	r7,r12
8000b64a:	10 9c       	mov	r12,r8
8000b64c:	30 08       	mov	r8,0
8000b64e:	e0 66 41 2c 	mov	r6,16684
8000b652:	14 9b       	mov	r11,r10
8000b654:	8d 08       	st.w	r6[0x0],r8
8000b656:	fe b0 df 55 	rcall	80007500 <_fstat>
8000b65a:	5b fc       	cp.w	r12,-1
8000b65c:	c0 51       	brne	8000b666 <_fstat_r+0x22>
8000b65e:	6c 08       	ld.w	r8,r6[0x0]
8000b660:	58 08       	cp.w	r8,0
8000b662:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b666:	d8 22       	popm	r4-r7,pc

8000b668 <_lseek_r>:
8000b668:	d4 21       	pushm	r4-r7,lr
8000b66a:	16 98       	mov	r8,r11
8000b66c:	18 97       	mov	r7,r12
8000b66e:	10 9c       	mov	r12,r8
8000b670:	30 08       	mov	r8,0
8000b672:	14 9b       	mov	r11,r10
8000b674:	e0 66 41 2c 	mov	r6,16684
8000b678:	12 9a       	mov	r10,r9
8000b67a:	8d 08       	st.w	r6[0x0],r8
8000b67c:	fe b0 df 24 	rcall	800074c4 <_lseek>
8000b680:	5b fc       	cp.w	r12,-1
8000b682:	c0 51       	brne	8000b68c <_lseek_r+0x24>
8000b684:	6c 08       	ld.w	r8,r6[0x0]
8000b686:	58 08       	cp.w	r8,0
8000b688:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b68c:	d8 22       	popm	r4-r7,pc
8000b68e:	d7 03       	nop

8000b690 <_read_r>:
8000b690:	d4 21       	pushm	r4-r7,lr
8000b692:	16 98       	mov	r8,r11
8000b694:	18 97       	mov	r7,r12
8000b696:	10 9c       	mov	r12,r8
8000b698:	30 08       	mov	r8,0
8000b69a:	14 9b       	mov	r11,r10
8000b69c:	e0 66 41 2c 	mov	r6,16684
8000b6a0:	12 9a       	mov	r10,r9
8000b6a2:	8d 08       	st.w	r6[0x0],r8
8000b6a4:	fe b0 d0 0c 	rcall	800056bc <_read>
8000b6a8:	5b fc       	cp.w	r12,-1
8000b6aa:	c0 51       	brne	8000b6b4 <_read_r+0x24>
8000b6ac:	6c 08       	ld.w	r8,r6[0x0]
8000b6ae:	58 08       	cp.w	r8,0
8000b6b0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b6b4:	d8 22       	popm	r4-r7,pc
8000b6b6:	d7 03       	nop

8000b6b8 <__avr32_f64_mul>:
8000b6b8:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b6bc:	e0 80 00 dc 	breq	8000b874 <__avr32_f64_mul_op1_zero>
8000b6c0:	d4 21       	pushm	r4-r7,lr
8000b6c2:	f7 e9 20 0e 	eor	lr,r11,r9
8000b6c6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b6ca:	30 15       	mov	r5,1
8000b6cc:	c4 30       	breq	8000b752 <__avr32_f64_mul_op1_subnormal>
8000b6ce:	ab 6b       	lsl	r11,0xa
8000b6d0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b6d4:	ab 6a       	lsl	r10,0xa
8000b6d6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b6da:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b6de:	c5 c0       	breq	8000b796 <__avr32_f64_mul_op2_subnormal>
8000b6e0:	a1 78       	lsl	r8,0x1
8000b6e2:	5c f9       	rol	r9
8000b6e4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b6e8:	e0 47 07 ff 	cp.w	r7,2047
8000b6ec:	c7 70       	breq	8000b7da <__avr32_f64_mul_op_nan_or_inf>
8000b6ee:	e0 46 07 ff 	cp.w	r6,2047
8000b6f2:	c7 40       	breq	8000b7da <__avr32_f64_mul_op_nan_or_inf>
8000b6f4:	ee 06 00 0c 	add	r12,r7,r6
8000b6f8:	e0 2c 03 fe 	sub	r12,1022
8000b6fc:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b700:	f4 09 07 44 	macu.d	r4,r10,r9
8000b704:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b708:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b70c:	08 07       	add	r7,r4
8000b70e:	f4 05 00 4a 	adc	r10,r10,r5
8000b712:	5c 0b       	acr	r11
8000b714:	ed bb 00 14 	bld	r11,0x14
8000b718:	c0 50       	breq	8000b722 <__avr32_f64_mul+0x6a>
8000b71a:	a1 77       	lsl	r7,0x1
8000b71c:	5c fa       	rol	r10
8000b71e:	5c fb       	rol	r11
8000b720:	20 1c       	sub	r12,1
8000b722:	58 0c       	cp.w	r12,0
8000b724:	e0 8a 00 6f 	brle	8000b802 <__avr32_f64_mul_res_subnormal>
8000b728:	e0 4c 07 ff 	cp.w	r12,2047
8000b72c:	e0 84 00 9c 	brge	8000b864 <__avr32_f64_mul_res_inf>
8000b730:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b734:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b738:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b73c:	ee 17 80 00 	eorh	r7,0x8000
8000b740:	f1 b7 04 20 	satu	r7,0x1
8000b744:	0e 0a       	add	r10,r7
8000b746:	5c 0b       	acr	r11
8000b748:	ed be 00 1f 	bld	lr,0x1f
8000b74c:	ef bb 00 1f 	bst	r11,0x1f
8000b750:	d8 22       	popm	r4-r7,pc

8000b752 <__avr32_f64_mul_op1_subnormal>:
8000b752:	e4 1b 00 0f 	andh	r11,0xf
8000b756:	f4 0c 12 00 	clz	r12,r10
8000b75a:	f6 06 12 00 	clz	r6,r11
8000b75e:	f7 bc 03 e1 	sublo	r12,-31
8000b762:	f8 06 17 30 	movlo	r6,r12
8000b766:	f7 b6 02 01 	subhs	r6,1
8000b76a:	e0 46 00 20 	cp.w	r6,32
8000b76e:	c0 d4       	brge	8000b788 <__avr32_f64_mul_op1_subnormal+0x36>
8000b770:	ec 0c 11 20 	rsub	r12,r6,32
8000b774:	f6 06 09 4b 	lsl	r11,r11,r6
8000b778:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b77c:	18 4b       	or	r11,r12
8000b77e:	f4 06 09 4a 	lsl	r10,r10,r6
8000b782:	20 b6       	sub	r6,11
8000b784:	0c 17       	sub	r7,r6
8000b786:	ca ab       	rjmp	8000b6da <__avr32_f64_mul+0x22>
8000b788:	f4 06 09 4b 	lsl	r11,r10,r6
8000b78c:	c6 40       	breq	8000b854 <__avr32_f64_mul_res_zero>
8000b78e:	30 0a       	mov	r10,0
8000b790:	20 b6       	sub	r6,11
8000b792:	0c 17       	sub	r7,r6
8000b794:	ca 3b       	rjmp	8000b6da <__avr32_f64_mul+0x22>

8000b796 <__avr32_f64_mul_op2_subnormal>:
8000b796:	e4 19 00 0f 	andh	r9,0xf
8000b79a:	f0 0c 12 00 	clz	r12,r8
8000b79e:	f2 05 12 00 	clz	r5,r9
8000b7a2:	f7 bc 03 ea 	sublo	r12,-22
8000b7a6:	f8 05 17 30 	movlo	r5,r12
8000b7aa:	f7 b5 02 0a 	subhs	r5,10
8000b7ae:	e0 45 00 20 	cp.w	r5,32
8000b7b2:	c0 d4       	brge	8000b7cc <__avr32_f64_mul_op2_subnormal+0x36>
8000b7b4:	ea 0c 11 20 	rsub	r12,r5,32
8000b7b8:	f2 05 09 49 	lsl	r9,r9,r5
8000b7bc:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b7c0:	18 49       	or	r9,r12
8000b7c2:	f0 05 09 48 	lsl	r8,r8,r5
8000b7c6:	20 25       	sub	r5,2
8000b7c8:	0a 16       	sub	r6,r5
8000b7ca:	c8 fb       	rjmp	8000b6e8 <__avr32_f64_mul+0x30>
8000b7cc:	f0 05 09 49 	lsl	r9,r8,r5
8000b7d0:	c4 20       	breq	8000b854 <__avr32_f64_mul_res_zero>
8000b7d2:	30 08       	mov	r8,0
8000b7d4:	20 25       	sub	r5,2
8000b7d6:	0a 16       	sub	r6,r5
8000b7d8:	c8 8b       	rjmp	8000b6e8 <__avr32_f64_mul+0x30>

8000b7da <__avr32_f64_mul_op_nan_or_inf>:
8000b7da:	e4 19 00 0f 	andh	r9,0xf
8000b7de:	e4 1b 00 0f 	andh	r11,0xf
8000b7e2:	14 4b       	or	r11,r10
8000b7e4:	10 49       	or	r9,r8
8000b7e6:	e0 47 07 ff 	cp.w	r7,2047
8000b7ea:	c0 91       	brne	8000b7fc <__avr32_f64_mul_op1_not_naninf>
8000b7ec:	58 0b       	cp.w	r11,0
8000b7ee:	c3 81       	brne	8000b85e <__avr32_f64_mul_res_nan>
8000b7f0:	e0 46 07 ff 	cp.w	r6,2047
8000b7f4:	c3 81       	brne	8000b864 <__avr32_f64_mul_res_inf>
8000b7f6:	58 09       	cp.w	r9,0
8000b7f8:	c3 60       	breq	8000b864 <__avr32_f64_mul_res_inf>
8000b7fa:	c3 28       	rjmp	8000b85e <__avr32_f64_mul_res_nan>

8000b7fc <__avr32_f64_mul_op1_not_naninf>:
8000b7fc:	58 09       	cp.w	r9,0
8000b7fe:	c3 30       	breq	8000b864 <__avr32_f64_mul_res_inf>
8000b800:	c2 f8       	rjmp	8000b85e <__avr32_f64_mul_res_nan>

8000b802 <__avr32_f64_mul_res_subnormal>:
8000b802:	5c 3c       	neg	r12
8000b804:	2f fc       	sub	r12,-1
8000b806:	f1 bc 04 c0 	satu	r12,0x6
8000b80a:	e0 4c 00 20 	cp.w	r12,32
8000b80e:	c1 14       	brge	8000b830 <__avr32_f64_mul_res_subnormal+0x2e>
8000b810:	f8 08 11 20 	rsub	r8,r12,32
8000b814:	0e 46       	or	r6,r7
8000b816:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b81a:	f4 08 09 49 	lsl	r9,r10,r8
8000b81e:	12 47       	or	r7,r9
8000b820:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b824:	f6 08 09 49 	lsl	r9,r11,r8
8000b828:	12 4a       	or	r10,r9
8000b82a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b82e:	c8 3b       	rjmp	8000b734 <__avr32_f64_mul+0x7c>
8000b830:	f8 08 11 20 	rsub	r8,r12,32
8000b834:	f9 b9 00 00 	moveq	r9,0
8000b838:	c0 30       	breq	8000b83e <__avr32_f64_mul_res_subnormal+0x3c>
8000b83a:	f6 08 09 49 	lsl	r9,r11,r8
8000b83e:	0e 46       	or	r6,r7
8000b840:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b844:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b848:	f3 ea 10 07 	or	r7,r9,r10
8000b84c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b850:	30 0b       	mov	r11,0
8000b852:	c7 1b       	rjmp	8000b734 <__avr32_f64_mul+0x7c>

8000b854 <__avr32_f64_mul_res_zero>:
8000b854:	1c 9b       	mov	r11,lr
8000b856:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b85a:	30 0a       	mov	r10,0
8000b85c:	d8 22       	popm	r4-r7,pc

8000b85e <__avr32_f64_mul_res_nan>:
8000b85e:	3f fb       	mov	r11,-1
8000b860:	3f fa       	mov	r10,-1
8000b862:	d8 22       	popm	r4-r7,pc

8000b864 <__avr32_f64_mul_res_inf>:
8000b864:	f0 6b 00 00 	mov	r11,-1048576
8000b868:	ed be 00 1f 	bld	lr,0x1f
8000b86c:	ef bb 00 1f 	bst	r11,0x1f
8000b870:	30 0a       	mov	r10,0
8000b872:	d8 22       	popm	r4-r7,pc

8000b874 <__avr32_f64_mul_op1_zero>:
8000b874:	f7 e9 20 0b 	eor	r11,r11,r9
8000b878:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b87c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b880:	e0 4c 07 ff 	cp.w	r12,2047
8000b884:	5e 1c       	retne	r12
8000b886:	3f fa       	mov	r10,-1
8000b888:	3f fb       	mov	r11,-1
8000b88a:	5e fc       	retal	r12

8000b88c <__avr32_f64_sub_from_add>:
8000b88c:	ee 19 80 00 	eorh	r9,0x8000

8000b890 <__avr32_f64_sub>:
8000b890:	f7 e9 20 0c 	eor	r12,r11,r9
8000b894:	e0 86 00 ca 	brmi	8000ba28 <__avr32_f64_add_from_sub>
8000b898:	eb cd 40 e0 	pushm	r5-r7,lr
8000b89c:	16 9c       	mov	r12,r11
8000b89e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b8a2:	bf db       	cbr	r11,0x1f
8000b8a4:	bf d9       	cbr	r9,0x1f
8000b8a6:	10 3a       	cp.w	r10,r8
8000b8a8:	f2 0b 13 00 	cpc	r11,r9
8000b8ac:	c0 92       	brcc	8000b8be <__avr32_f64_sub+0x2e>
8000b8ae:	16 97       	mov	r7,r11
8000b8b0:	12 9b       	mov	r11,r9
8000b8b2:	0e 99       	mov	r9,r7
8000b8b4:	14 97       	mov	r7,r10
8000b8b6:	10 9a       	mov	r10,r8
8000b8b8:	0e 98       	mov	r8,r7
8000b8ba:	ee 1c 80 00 	eorh	r12,0x8000
8000b8be:	f6 07 16 14 	lsr	r7,r11,0x14
8000b8c2:	ab 7b       	lsl	r11,0xb
8000b8c4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b8c8:	ab 7a       	lsl	r10,0xb
8000b8ca:	bf bb       	sbr	r11,0x1f
8000b8cc:	f2 06 16 14 	lsr	r6,r9,0x14
8000b8d0:	c4 40       	breq	8000b958 <__avr32_f64_sub_opL_subnormal>
8000b8d2:	ab 79       	lsl	r9,0xb
8000b8d4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b8d8:	ab 78       	lsl	r8,0xb
8000b8da:	bf b9       	sbr	r9,0x1f

8000b8dc <__avr32_f64_sub_opL_subnormal_done>:
8000b8dc:	e0 47 07 ff 	cp.w	r7,2047
8000b8e0:	c4 f0       	breq	8000b97e <__avr32_f64_sub_opH_nan_or_inf>
8000b8e2:	0e 26       	rsub	r6,r7
8000b8e4:	c1 20       	breq	8000b908 <__avr32_f64_sub_shift_done>
8000b8e6:	ec 05 11 20 	rsub	r5,r6,32
8000b8ea:	e0 46 00 20 	cp.w	r6,32
8000b8ee:	c7 c2       	brcc	8000b9e6 <__avr32_f64_sub_longshift>
8000b8f0:	f0 05 09 4e 	lsl	lr,r8,r5
8000b8f4:	f2 05 09 45 	lsl	r5,r9,r5
8000b8f8:	f0 06 0a 48 	lsr	r8,r8,r6
8000b8fc:	f2 06 0a 49 	lsr	r9,r9,r6
8000b900:	0a 48       	or	r8,r5
8000b902:	58 0e       	cp.w	lr,0
8000b904:	5f 1e       	srne	lr
8000b906:	1c 48       	or	r8,lr

8000b908 <__avr32_f64_sub_shift_done>:
8000b908:	10 1a       	sub	r10,r8
8000b90a:	f6 09 01 4b 	sbc	r11,r11,r9
8000b90e:	f6 06 12 00 	clz	r6,r11
8000b912:	c0 e0       	breq	8000b92e <__avr32_f64_sub_longnormalize_done>
8000b914:	c7 83       	brcs	8000ba04 <__avr32_f64_sub_longnormalize>
8000b916:	ec 0e 11 20 	rsub	lr,r6,32
8000b91a:	f6 06 09 4b 	lsl	r11,r11,r6
8000b91e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b922:	1c 4b       	or	r11,lr
8000b924:	f4 06 09 4a 	lsl	r10,r10,r6
8000b928:	0c 17       	sub	r7,r6
8000b92a:	e0 8a 00 39 	brle	8000b99c <__avr32_f64_sub_subnormal_result>

8000b92e <__avr32_f64_sub_longnormalize_done>:
8000b92e:	f4 09 15 15 	lsl	r9,r10,0x15
8000b932:	ab 9a       	lsr	r10,0xb
8000b934:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b938:	ab 9b       	lsr	r11,0xb
8000b93a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b93e:	18 4b       	or	r11,r12

8000b940 <__avr32_f64_sub_round>:
8000b940:	fc 17 80 00 	movh	r7,0x8000
8000b944:	ed ba 00 00 	bld	r10,0x0
8000b948:	f7 b7 01 ff 	subne	r7,-1
8000b94c:	0e 39       	cp.w	r9,r7
8000b94e:	5f 29       	srhs	r9
8000b950:	12 0a       	add	r10,r9
8000b952:	5c 0b       	acr	r11
8000b954:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b958 <__avr32_f64_sub_opL_subnormal>:
8000b958:	ab 79       	lsl	r9,0xb
8000b95a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b95e:	ab 78       	lsl	r8,0xb
8000b960:	f3 e8 10 0e 	or	lr,r9,r8
8000b964:	f9 b6 01 01 	movne	r6,1
8000b968:	ee 0e 11 00 	rsub	lr,r7,0
8000b96c:	f9 b7 00 01 	moveq	r7,1
8000b970:	ef bb 00 1f 	bst	r11,0x1f
8000b974:	f7 ea 10 0e 	or	lr,r11,r10
8000b978:	f9 b7 00 00 	moveq	r7,0
8000b97c:	cb 0b       	rjmp	8000b8dc <__avr32_f64_sub_opL_subnormal_done>

8000b97e <__avr32_f64_sub_opH_nan_or_inf>:
8000b97e:	bf db       	cbr	r11,0x1f
8000b980:	f7 ea 10 0e 	or	lr,r11,r10
8000b984:	c0 81       	brne	8000b994 <__avr32_f64_sub_return_nan>
8000b986:	e0 46 07 ff 	cp.w	r6,2047
8000b98a:	c0 50       	breq	8000b994 <__avr32_f64_sub_return_nan>
8000b98c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b990:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b994 <__avr32_f64_sub_return_nan>:
8000b994:	3f fa       	mov	r10,-1
8000b996:	3f fb       	mov	r11,-1
8000b998:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b99c <__avr32_f64_sub_subnormal_result>:
8000b99c:	5c 37       	neg	r7
8000b99e:	2f f7       	sub	r7,-1
8000b9a0:	f1 b7 04 c0 	satu	r7,0x6
8000b9a4:	e0 47 00 20 	cp.w	r7,32
8000b9a8:	c1 14       	brge	8000b9ca <__avr32_f64_sub_subnormal_result+0x2e>
8000b9aa:	ee 08 11 20 	rsub	r8,r7,32
8000b9ae:	f4 08 09 49 	lsl	r9,r10,r8
8000b9b2:	5f 16       	srne	r6
8000b9b4:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b9b8:	0c 4a       	or	r10,r6
8000b9ba:	f6 08 09 49 	lsl	r9,r11,r8
8000b9be:	f5 e9 10 0a 	or	r10,r10,r9
8000b9c2:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b9c6:	30 07       	mov	r7,0
8000b9c8:	cb 3b       	rjmp	8000b92e <__avr32_f64_sub_longnormalize_done>
8000b9ca:	ee 08 11 40 	rsub	r8,r7,64
8000b9ce:	f6 08 09 49 	lsl	r9,r11,r8
8000b9d2:	14 49       	or	r9,r10
8000b9d4:	5f 16       	srne	r6
8000b9d6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b9da:	0c 4a       	or	r10,r6
8000b9dc:	30 0b       	mov	r11,0
8000b9de:	30 07       	mov	r7,0
8000b9e0:	ca 7b       	rjmp	8000b92e <__avr32_f64_sub_longnormalize_done>
8000b9e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b9e6 <__avr32_f64_sub_longshift>:
8000b9e6:	f1 b6 04 c0 	satu	r6,0x6
8000b9ea:	f0 0e 17 00 	moveq	lr,r8
8000b9ee:	c0 40       	breq	8000b9f6 <__avr32_f64_sub_longshift+0x10>
8000b9f0:	f2 05 09 4e 	lsl	lr,r9,r5
8000b9f4:	10 4e       	or	lr,r8
8000b9f6:	f2 06 0a 48 	lsr	r8,r9,r6
8000b9fa:	30 09       	mov	r9,0
8000b9fc:	58 0e       	cp.w	lr,0
8000b9fe:	5f 1e       	srne	lr
8000ba00:	1c 48       	or	r8,lr
8000ba02:	c8 3b       	rjmp	8000b908 <__avr32_f64_sub_shift_done>

8000ba04 <__avr32_f64_sub_longnormalize>:
8000ba04:	f4 06 12 00 	clz	r6,r10
8000ba08:	f9 b7 03 00 	movlo	r7,0
8000ba0c:	f9 b6 03 00 	movlo	r6,0
8000ba10:	f9 bc 03 00 	movlo	r12,0
8000ba14:	f7 b6 02 e0 	subhs	r6,-32
8000ba18:	f4 06 09 4b 	lsl	r11,r10,r6
8000ba1c:	30 0a       	mov	r10,0
8000ba1e:	0c 17       	sub	r7,r6
8000ba20:	fe 9a ff be 	brle	8000b99c <__avr32_f64_sub_subnormal_result>
8000ba24:	c8 5b       	rjmp	8000b92e <__avr32_f64_sub_longnormalize_done>
8000ba26:	d7 03       	nop

8000ba28 <__avr32_f64_add_from_sub>:
8000ba28:	ee 19 80 00 	eorh	r9,0x8000

8000ba2c <__avr32_f64_add>:
8000ba2c:	f7 e9 20 0c 	eor	r12,r11,r9
8000ba30:	fe 96 ff 2e 	brmi	8000b88c <__avr32_f64_sub_from_add>
8000ba34:	eb cd 40 e0 	pushm	r5-r7,lr
8000ba38:	16 9c       	mov	r12,r11
8000ba3a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ba3e:	bf db       	cbr	r11,0x1f
8000ba40:	bf d9       	cbr	r9,0x1f
8000ba42:	12 3b       	cp.w	r11,r9
8000ba44:	c0 72       	brcc	8000ba52 <__avr32_f64_add+0x26>
8000ba46:	16 97       	mov	r7,r11
8000ba48:	12 9b       	mov	r11,r9
8000ba4a:	0e 99       	mov	r9,r7
8000ba4c:	14 97       	mov	r7,r10
8000ba4e:	10 9a       	mov	r10,r8
8000ba50:	0e 98       	mov	r8,r7
8000ba52:	30 0e       	mov	lr,0
8000ba54:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ba58:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000ba5c:	b5 ab       	sbr	r11,0x14
8000ba5e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ba62:	c6 20       	breq	8000bb26 <__avr32_f64_add_op2_subnormal>
8000ba64:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000ba68:	b5 a9       	sbr	r9,0x14
8000ba6a:	e0 47 07 ff 	cp.w	r7,2047
8000ba6e:	c2 80       	breq	8000babe <__avr32_f64_add_opH_nan_or_inf>
8000ba70:	0e 26       	rsub	r6,r7
8000ba72:	c1 20       	breq	8000ba96 <__avr32_f64_add_shift_done>
8000ba74:	e0 46 00 36 	cp.w	r6,54
8000ba78:	c1 52       	brcc	8000baa2 <__avr32_f64_add_res_of_done>
8000ba7a:	ec 05 11 20 	rsub	r5,r6,32
8000ba7e:	e0 46 00 20 	cp.w	r6,32
8000ba82:	c3 52       	brcc	8000baec <__avr32_f64_add_longshift>
8000ba84:	f0 05 09 4e 	lsl	lr,r8,r5
8000ba88:	f2 05 09 45 	lsl	r5,r9,r5
8000ba8c:	f0 06 0a 48 	lsr	r8,r8,r6
8000ba90:	f2 06 0a 49 	lsr	r9,r9,r6
8000ba94:	0a 48       	or	r8,r5

8000ba96 <__avr32_f64_add_shift_done>:
8000ba96:	10 0a       	add	r10,r8
8000ba98:	f6 09 00 4b 	adc	r11,r11,r9
8000ba9c:	ed bb 00 15 	bld	r11,0x15
8000baa0:	c3 40       	breq	8000bb08 <__avr32_f64_add_res_of>

8000baa2 <__avr32_f64_add_res_of_done>:
8000baa2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000baa6:	18 4b       	or	r11,r12

8000baa8 <__avr32_f64_add_round>:
8000baa8:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000baac:	18 4e       	or	lr,r12
8000baae:	ee 1e 80 00 	eorh	lr,0x8000
8000bab2:	f1 be 04 20 	satu	lr,0x1
8000bab6:	1c 0a       	add	r10,lr
8000bab8:	5c 0b       	acr	r11
8000baba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000babe <__avr32_f64_add_opH_nan_or_inf>:
8000babe:	b5 cb       	cbr	r11,0x14
8000bac0:	f7 ea 10 0e 	or	lr,r11,r10
8000bac4:	c1 01       	brne	8000bae4 <__avr32_f64_add_return_nan>
8000bac6:	e0 46 07 ff 	cp.w	r6,2047
8000baca:	c0 30       	breq	8000bad0 <__avr32_f64_add_opL_nan_or_inf>
8000bacc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bad0 <__avr32_f64_add_opL_nan_or_inf>:
8000bad0:	b5 c9       	cbr	r9,0x14
8000bad2:	f3 e8 10 0e 	or	lr,r9,r8
8000bad6:	c0 71       	brne	8000bae4 <__avr32_f64_add_return_nan>
8000bad8:	30 0a       	mov	r10,0
8000bada:	fc 1b 7f f0 	movh	r11,0x7ff0
8000bade:	18 4b       	or	r11,r12
8000bae0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bae4 <__avr32_f64_add_return_nan>:
8000bae4:	3f fa       	mov	r10,-1
8000bae6:	3f fb       	mov	r11,-1
8000bae8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000baec <__avr32_f64_add_longshift>:
8000baec:	f1 b6 04 c0 	satu	r6,0x6
8000baf0:	f0 0e 17 00 	moveq	lr,r8
8000baf4:	c0 60       	breq	8000bb00 <__avr32_f64_add_longshift+0x14>
8000baf6:	f2 05 09 4e 	lsl	lr,r9,r5
8000bafa:	58 08       	cp.w	r8,0
8000bafc:	5f 18       	srne	r8
8000bafe:	10 4e       	or	lr,r8
8000bb00:	f2 06 0a 48 	lsr	r8,r9,r6
8000bb04:	30 09       	mov	r9,0
8000bb06:	cc 8b       	rjmp	8000ba96 <__avr32_f64_add_shift_done>

8000bb08 <__avr32_f64_add_res_of>:
8000bb08:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000bb0c:	a1 9b       	lsr	r11,0x1
8000bb0e:	5d 0a       	ror	r10
8000bb10:	5d 0e       	ror	lr
8000bb12:	2f f7       	sub	r7,-1
8000bb14:	e0 47 07 ff 	cp.w	r7,2047
8000bb18:	f9 ba 00 00 	moveq	r10,0
8000bb1c:	f9 bb 00 00 	moveq	r11,0
8000bb20:	f9 be 00 00 	moveq	lr,0
8000bb24:	cb fb       	rjmp	8000baa2 <__avr32_f64_add_res_of_done>

8000bb26 <__avr32_f64_add_op2_subnormal>:
8000bb26:	30 16       	mov	r6,1
8000bb28:	58 07       	cp.w	r7,0
8000bb2a:	ca 01       	brne	8000ba6a <__avr32_f64_add+0x3e>
8000bb2c:	b5 cb       	cbr	r11,0x14
8000bb2e:	10 0a       	add	r10,r8
8000bb30:	f6 09 00 4b 	adc	r11,r11,r9
8000bb34:	18 4b       	or	r11,r12
8000bb36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000bb3a:	d7 03       	nop

8000bb3c <__avr32_f64_to_u32>:
8000bb3c:	58 0b       	cp.w	r11,0
8000bb3e:	5e 6d       	retmi	0

8000bb40 <__avr32_f64_to_s32>:
8000bb40:	f6 0c 15 01 	lsl	r12,r11,0x1
8000bb44:	b5 9c       	lsr	r12,0x15
8000bb46:	e0 2c 03 ff 	sub	r12,1023
8000bb4a:	5e 3d       	retlo	0
8000bb4c:	f8 0c 11 1f 	rsub	r12,r12,31
8000bb50:	16 99       	mov	r9,r11
8000bb52:	ab 7b       	lsl	r11,0xb
8000bb54:	bf bb       	sbr	r11,0x1f
8000bb56:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bb5a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000bb5e:	a1 79       	lsl	r9,0x1
8000bb60:	5e 2b       	reths	r11
8000bb62:	5c 3b       	neg	r11
8000bb64:	5e fb       	retal	r11

8000bb66 <__avr32_u32_to_f64>:
8000bb66:	f8 cb 00 00 	sub	r11,r12,0
8000bb6a:	30 0c       	mov	r12,0
8000bb6c:	c0 38       	rjmp	8000bb72 <__avr32_s32_to_f64+0x4>

8000bb6e <__avr32_s32_to_f64>:
8000bb6e:	18 9b       	mov	r11,r12
8000bb70:	5c 4b       	abs	r11
8000bb72:	30 0a       	mov	r10,0
8000bb74:	5e 0b       	reteq	r11
8000bb76:	d4 01       	pushm	lr
8000bb78:	e0 69 04 1e 	mov	r9,1054
8000bb7c:	f6 08 12 00 	clz	r8,r11
8000bb80:	c1 70       	breq	8000bbae <__avr32_s32_to_f64+0x40>
8000bb82:	c0 c3       	brcs	8000bb9a <__avr32_s32_to_f64+0x2c>
8000bb84:	f0 0e 11 20 	rsub	lr,r8,32
8000bb88:	f6 08 09 4b 	lsl	r11,r11,r8
8000bb8c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bb90:	1c 4b       	or	r11,lr
8000bb92:	f4 08 09 4a 	lsl	r10,r10,r8
8000bb96:	10 19       	sub	r9,r8
8000bb98:	c0 b8       	rjmp	8000bbae <__avr32_s32_to_f64+0x40>
8000bb9a:	f4 08 12 00 	clz	r8,r10
8000bb9e:	f9 b8 03 00 	movlo	r8,0
8000bba2:	f7 b8 02 e0 	subhs	r8,-32
8000bba6:	f4 08 09 4b 	lsl	r11,r10,r8
8000bbaa:	30 0a       	mov	r10,0
8000bbac:	10 19       	sub	r9,r8
8000bbae:	58 09       	cp.w	r9,0
8000bbb0:	e0 89 00 30 	brgt	8000bc10 <__avr32_s32_to_f64+0xa2>
8000bbb4:	5c 39       	neg	r9
8000bbb6:	2f f9       	sub	r9,-1
8000bbb8:	e0 49 00 36 	cp.w	r9,54
8000bbbc:	c0 43       	brcs	8000bbc4 <__avr32_s32_to_f64+0x56>
8000bbbe:	30 0b       	mov	r11,0
8000bbc0:	30 0a       	mov	r10,0
8000bbc2:	c2 68       	rjmp	8000bc0e <__avr32_s32_to_f64+0xa0>
8000bbc4:	2f 69       	sub	r9,-10
8000bbc6:	f2 08 11 20 	rsub	r8,r9,32
8000bbca:	e0 49 00 20 	cp.w	r9,32
8000bbce:	c0 b2       	brcc	8000bbe4 <__avr32_s32_to_f64+0x76>
8000bbd0:	f4 08 09 4e 	lsl	lr,r10,r8
8000bbd4:	f6 08 09 48 	lsl	r8,r11,r8
8000bbd8:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bbdc:	f6 09 0a 4b 	lsr	r11,r11,r9
8000bbe0:	10 4b       	or	r11,r8
8000bbe2:	c0 88       	rjmp	8000bbf2 <__avr32_s32_to_f64+0x84>
8000bbe4:	f6 08 09 4e 	lsl	lr,r11,r8
8000bbe8:	14 4e       	or	lr,r10
8000bbea:	16 9a       	mov	r10,r11
8000bbec:	30 0b       	mov	r11,0
8000bbee:	f4 09 0a 4a 	lsr	r10,r10,r9
8000bbf2:	ed ba 00 00 	bld	r10,0x0
8000bbf6:	c0 92       	brcc	8000bc08 <__avr32_s32_to_f64+0x9a>
8000bbf8:	1c 7e       	tst	lr,lr
8000bbfa:	c0 41       	brne	8000bc02 <__avr32_s32_to_f64+0x94>
8000bbfc:	ed ba 00 01 	bld	r10,0x1
8000bc00:	c0 42       	brcc	8000bc08 <__avr32_s32_to_f64+0x9a>
8000bc02:	2f fa       	sub	r10,-1
8000bc04:	f7 bb 02 ff 	subhs	r11,-1
8000bc08:	5c fc       	rol	r12
8000bc0a:	5d 0b       	ror	r11
8000bc0c:	5d 0a       	ror	r10
8000bc0e:	d8 02       	popm	pc
8000bc10:	e0 68 03 ff 	mov	r8,1023
8000bc14:	ed ba 00 0b 	bld	r10,0xb
8000bc18:	f7 b8 00 ff 	subeq	r8,-1
8000bc1c:	10 0a       	add	r10,r8
8000bc1e:	5c 0b       	acr	r11
8000bc20:	f7 b9 03 fe 	sublo	r9,-2
8000bc24:	e0 49 07 ff 	cp.w	r9,2047
8000bc28:	c0 55       	brlt	8000bc32 <__avr32_s32_to_f64+0xc4>
8000bc2a:	30 0a       	mov	r10,0
8000bc2c:	fc 1b ff e0 	movh	r11,0xffe0
8000bc30:	c0 c8       	rjmp	8000bc48 <__floatsidf_return_op1>
8000bc32:	ed bb 00 1f 	bld	r11,0x1f
8000bc36:	f7 b9 01 01 	subne	r9,1
8000bc3a:	ab 9a       	lsr	r10,0xb
8000bc3c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bc40:	a1 7b       	lsl	r11,0x1
8000bc42:	ab 9b       	lsr	r11,0xb
8000bc44:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000bc48 <__floatsidf_return_op1>:
8000bc48:	a1 7c       	lsl	r12,0x1
8000bc4a:	5d 0b       	ror	r11
8000bc4c:	d8 02       	popm	pc

8000bc4e <__avr32_f64_cmp_eq>:
8000bc4e:	10 3a       	cp.w	r10,r8
8000bc50:	f2 0b 13 00 	cpc	r11,r9
8000bc54:	c0 80       	breq	8000bc64 <__avr32_f64_cmp_eq+0x16>
8000bc56:	a1 7b       	lsl	r11,0x1
8000bc58:	a1 79       	lsl	r9,0x1
8000bc5a:	14 4b       	or	r11,r10
8000bc5c:	12 4b       	or	r11,r9
8000bc5e:	10 4b       	or	r11,r8
8000bc60:	5e 0f       	reteq	1
8000bc62:	5e fd       	retal	0
8000bc64:	a1 7b       	lsl	r11,0x1
8000bc66:	fc 1c ff e0 	movh	r12,0xffe0
8000bc6a:	58 0a       	cp.w	r10,0
8000bc6c:	f8 0b 13 00 	cpc	r11,r12
8000bc70:	5e 8f       	retls	1
8000bc72:	5e fd       	retal	0

8000bc74 <__avr32_f64_cmp_ge>:
8000bc74:	1a de       	st.w	--sp,lr
8000bc76:	1a d7       	st.w	--sp,r7
8000bc78:	a1 7b       	lsl	r11,0x1
8000bc7a:	5f 3c       	srlo	r12
8000bc7c:	a1 79       	lsl	r9,0x1
8000bc7e:	5f 37       	srlo	r7
8000bc80:	5c fc       	rol	r12
8000bc82:	fc 1e ff e0 	movh	lr,0xffe0
8000bc86:	58 0a       	cp.w	r10,0
8000bc88:	fc 0b 13 00 	cpc	r11,lr
8000bc8c:	e0 8b 00 1d 	brhi	8000bcc6 <__avr32_f64_cmp_ge+0x52>
8000bc90:	58 08       	cp.w	r8,0
8000bc92:	fc 09 13 00 	cpc	r9,lr
8000bc96:	e0 8b 00 18 	brhi	8000bcc6 <__avr32_f64_cmp_ge+0x52>
8000bc9a:	58 0b       	cp.w	r11,0
8000bc9c:	f5 ba 00 00 	subfeq	r10,0
8000bca0:	c1 50       	breq	8000bcca <__avr32_f64_cmp_ge+0x56>
8000bca2:	1b 07       	ld.w	r7,sp++
8000bca4:	1b 0e       	ld.w	lr,sp++
8000bca6:	58 3c       	cp.w	r12,3
8000bca8:	c0 a0       	breq	8000bcbc <__avr32_f64_cmp_ge+0x48>
8000bcaa:	58 1c       	cp.w	r12,1
8000bcac:	c0 33       	brcs	8000bcb2 <__avr32_f64_cmp_ge+0x3e>
8000bcae:	5e 0f       	reteq	1
8000bcb0:	5e 1d       	retne	0
8000bcb2:	10 3a       	cp.w	r10,r8
8000bcb4:	f2 0b 13 00 	cpc	r11,r9
8000bcb8:	5e 2f       	reths	1
8000bcba:	5e 3d       	retlo	0
8000bcbc:	14 38       	cp.w	r8,r10
8000bcbe:	f6 09 13 00 	cpc	r9,r11
8000bcc2:	5e 2f       	reths	1
8000bcc4:	5e 3d       	retlo	0
8000bcc6:	1b 07       	ld.w	r7,sp++
8000bcc8:	d8 0a       	popm	pc,r12=0
8000bcca:	58 17       	cp.w	r7,1
8000bccc:	5f 0c       	sreq	r12
8000bcce:	58 09       	cp.w	r9,0
8000bcd0:	f5 b8 00 00 	subfeq	r8,0
8000bcd4:	1b 07       	ld.w	r7,sp++
8000bcd6:	1b 0e       	ld.w	lr,sp++
8000bcd8:	5e 0f       	reteq	1
8000bcda:	5e fc       	retal	r12

8000bcdc <__avr32_f64_cmp_lt>:
8000bcdc:	1a de       	st.w	--sp,lr
8000bcde:	1a d7       	st.w	--sp,r7
8000bce0:	a1 7b       	lsl	r11,0x1
8000bce2:	5f 3c       	srlo	r12
8000bce4:	a1 79       	lsl	r9,0x1
8000bce6:	5f 37       	srlo	r7
8000bce8:	5c fc       	rol	r12
8000bcea:	fc 1e ff e0 	movh	lr,0xffe0
8000bcee:	58 0a       	cp.w	r10,0
8000bcf0:	fc 0b 13 00 	cpc	r11,lr
8000bcf4:	e0 8b 00 1d 	brhi	8000bd2e <__avr32_f64_cmp_lt+0x52>
8000bcf8:	58 08       	cp.w	r8,0
8000bcfa:	fc 09 13 00 	cpc	r9,lr
8000bcfe:	e0 8b 00 18 	brhi	8000bd2e <__avr32_f64_cmp_lt+0x52>
8000bd02:	58 0b       	cp.w	r11,0
8000bd04:	f5 ba 00 00 	subfeq	r10,0
8000bd08:	c1 50       	breq	8000bd32 <__avr32_f64_cmp_lt+0x56>
8000bd0a:	1b 07       	ld.w	r7,sp++
8000bd0c:	1b 0e       	ld.w	lr,sp++
8000bd0e:	58 3c       	cp.w	r12,3
8000bd10:	c0 a0       	breq	8000bd24 <__avr32_f64_cmp_lt+0x48>
8000bd12:	58 1c       	cp.w	r12,1
8000bd14:	c0 33       	brcs	8000bd1a <__avr32_f64_cmp_lt+0x3e>
8000bd16:	5e 0d       	reteq	0
8000bd18:	5e 1f       	retne	1
8000bd1a:	10 3a       	cp.w	r10,r8
8000bd1c:	f2 0b 13 00 	cpc	r11,r9
8000bd20:	5e 2d       	reths	0
8000bd22:	5e 3f       	retlo	1
8000bd24:	14 38       	cp.w	r8,r10
8000bd26:	f6 09 13 00 	cpc	r9,r11
8000bd2a:	5e 2d       	reths	0
8000bd2c:	5e 3f       	retlo	1
8000bd2e:	1b 07       	ld.w	r7,sp++
8000bd30:	d8 0a       	popm	pc,r12=0
8000bd32:	58 17       	cp.w	r7,1
8000bd34:	5f 1c       	srne	r12
8000bd36:	58 09       	cp.w	r9,0
8000bd38:	f5 b8 00 00 	subfeq	r8,0
8000bd3c:	1b 07       	ld.w	r7,sp++
8000bd3e:	1b 0e       	ld.w	lr,sp++
8000bd40:	5e 0d       	reteq	0
8000bd42:	5e fc       	retal	r12

8000bd44 <__avr32_f64_div>:
8000bd44:	eb cd 40 ff 	pushm	r0-r7,lr
8000bd48:	f7 e9 20 0e 	eor	lr,r11,r9
8000bd4c:	f6 07 16 14 	lsr	r7,r11,0x14
8000bd50:	a9 7b       	lsl	r11,0x9
8000bd52:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bd56:	a9 7a       	lsl	r10,0x9
8000bd58:	bd bb       	sbr	r11,0x1d
8000bd5a:	e4 1b 3f ff 	andh	r11,0x3fff
8000bd5e:	ab d7       	cbr	r7,0xb
8000bd60:	e0 80 00 cc 	breq	8000bef8 <__avr32_f64_div_round_subnormal+0x54>
8000bd64:	e0 47 07 ff 	cp.w	r7,2047
8000bd68:	e0 84 00 b5 	brge	8000bed2 <__avr32_f64_div_round_subnormal+0x2e>
8000bd6c:	f2 06 16 14 	lsr	r6,r9,0x14
8000bd70:	a9 79       	lsl	r9,0x9
8000bd72:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bd76:	a9 78       	lsl	r8,0x9
8000bd78:	bd b9       	sbr	r9,0x1d
8000bd7a:	e4 19 3f ff 	andh	r9,0x3fff
8000bd7e:	ab d6       	cbr	r6,0xb
8000bd80:	e0 80 00 e2 	breq	8000bf44 <__avr32_f64_div_round_subnormal+0xa0>
8000bd84:	e0 46 07 ff 	cp.w	r6,2047
8000bd88:	e0 84 00 b2 	brge	8000beec <__avr32_f64_div_round_subnormal+0x48>
8000bd8c:	0c 17       	sub	r7,r6
8000bd8e:	fe 37 fc 01 	sub	r7,-1023
8000bd92:	fc 1c 80 00 	movh	r12,0x8000
8000bd96:	f8 03 16 01 	lsr	r3,r12,0x1
8000bd9a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bd9e:	5c d4       	com	r4
8000bda0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bda4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bda8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bdac:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bdb0:	ea 03 15 02 	lsl	r3,r5,0x2
8000bdb4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bdb8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bdbc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bdc0:	ea 03 15 02 	lsl	r3,r5,0x2
8000bdc4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bdc8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bdcc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bdd0:	ea 03 15 02 	lsl	r3,r5,0x2
8000bdd4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bdd8:	e4 09 07 40 	macu.d	r0,r2,r9
8000bddc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bde0:	02 04       	add	r4,r1
8000bde2:	5c 05       	acr	r5
8000bde4:	a3 65       	lsl	r5,0x2
8000bde6:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bdea:	a3 64       	lsl	r4,0x2
8000bdec:	5c 34       	neg	r4
8000bdee:	f8 05 01 45 	sbc	r5,r12,r5
8000bdf2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bdf6:	e4 05 07 40 	macu.d	r0,r2,r5
8000bdfa:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bdfe:	02 04       	add	r4,r1
8000be00:	5c 05       	acr	r5
8000be02:	ea 03 15 02 	lsl	r3,r5,0x2
8000be06:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000be0a:	e8 02 15 02 	lsl	r2,r4,0x2
8000be0e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000be12:	e4 09 07 40 	macu.d	r0,r2,r9
8000be16:	e6 09 06 44 	mulu.d	r4,r3,r9
8000be1a:	02 04       	add	r4,r1
8000be1c:	5c 05       	acr	r5
8000be1e:	a3 65       	lsl	r5,0x2
8000be20:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000be24:	a3 64       	lsl	r4,0x2
8000be26:	5c 34       	neg	r4
8000be28:	f8 05 01 45 	sbc	r5,r12,r5
8000be2c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000be30:	e4 05 07 40 	macu.d	r0,r2,r5
8000be34:	e6 05 06 44 	mulu.d	r4,r3,r5
8000be38:	02 04       	add	r4,r1
8000be3a:	5c 05       	acr	r5
8000be3c:	ea 03 15 02 	lsl	r3,r5,0x2
8000be40:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000be44:	e8 02 15 02 	lsl	r2,r4,0x2
8000be48:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000be4c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000be50:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000be54:	02 02       	add	r2,r1
8000be56:	5c 03       	acr	r3
8000be58:	ed b3 00 1c 	bld	r3,0x1c
8000be5c:	c0 90       	breq	8000be6e <__avr32_f64_div+0x12a>
8000be5e:	a1 72       	lsl	r2,0x1
8000be60:	5c f3       	rol	r3
8000be62:	20 17       	sub	r7,1
8000be64:	a3 9a       	lsr	r10,0x3
8000be66:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000be6a:	a3 9b       	lsr	r11,0x3
8000be6c:	c0 58       	rjmp	8000be76 <__avr32_f64_div+0x132>
8000be6e:	a5 8a       	lsr	r10,0x4
8000be70:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000be74:	a5 8b       	lsr	r11,0x4
8000be76:	58 07       	cp.w	r7,0
8000be78:	e0 8a 00 8b 	brle	8000bf8e <__avr32_f64_div_res_subnormal>
8000be7c:	e0 12 ff 00 	andl	r2,0xff00
8000be80:	e8 12 00 80 	orl	r2,0x80
8000be84:	e6 08 06 40 	mulu.d	r0,r3,r8
8000be88:	e4 09 07 40 	macu.d	r0,r2,r9
8000be8c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000be90:	e6 09 06 48 	mulu.d	r8,r3,r9
8000be94:	00 05       	add	r5,r0
8000be96:	f0 01 00 48 	adc	r8,r8,r1
8000be9a:	5c 09       	acr	r9
8000be9c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bea0:	58 04       	cp.w	r4,0
8000bea2:	5c 25       	cpc	r5

8000bea4 <__avr32_f64_div_round_subnormal>:
8000bea4:	f4 08 13 00 	cpc	r8,r10
8000bea8:	f6 09 13 00 	cpc	r9,r11
8000beac:	5f 36       	srlo	r6
8000beae:	f8 06 17 00 	moveq	r6,r12
8000beb2:	e4 0a 16 08 	lsr	r10,r2,0x8
8000beb6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000beba:	e6 0b 16 08 	lsr	r11,r3,0x8
8000bebe:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bec2:	ed be 00 1f 	bld	lr,0x1f
8000bec6:	ef bb 00 1f 	bst	r11,0x1f
8000beca:	0c 0a       	add	r10,r6
8000becc:	5c 0b       	acr	r11
8000bece:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bed2:	e4 1b 00 0f 	andh	r11,0xf
8000bed6:	14 4b       	or	r11,r10
8000bed8:	e0 81 00 a7 	brne	8000c026 <__avr32_f64_div_res_subnormal+0x98>
8000bedc:	f2 06 16 14 	lsr	r6,r9,0x14
8000bee0:	ab d6       	cbr	r6,0xb
8000bee2:	e0 46 07 ff 	cp.w	r6,2047
8000bee6:	e0 81 00 a4 	brne	8000c02e <__avr32_f64_div_res_subnormal+0xa0>
8000beea:	c9 e8       	rjmp	8000c026 <__avr32_f64_div_res_subnormal+0x98>
8000beec:	e4 19 00 0f 	andh	r9,0xf
8000bef0:	10 49       	or	r9,r8
8000bef2:	e0 81 00 9a 	brne	8000c026 <__avr32_f64_div_res_subnormal+0x98>
8000bef6:	c9 28       	rjmp	8000c01a <__avr32_f64_div_res_subnormal+0x8c>
8000bef8:	a3 7b       	lsl	r11,0x3
8000befa:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000befe:	a3 7a       	lsl	r10,0x3
8000bf00:	f5 eb 10 04 	or	r4,r10,r11
8000bf04:	e0 80 00 a0 	breq	8000c044 <__avr32_f64_div_op1_zero>
8000bf08:	f6 04 12 00 	clz	r4,r11
8000bf0c:	c1 70       	breq	8000bf3a <__avr32_f64_div_round_subnormal+0x96>
8000bf0e:	c0 c3       	brcs	8000bf26 <__avr32_f64_div_round_subnormal+0x82>
8000bf10:	e8 05 11 20 	rsub	r5,r4,32
8000bf14:	f6 04 09 4b 	lsl	r11,r11,r4
8000bf18:	f4 05 0a 45 	lsr	r5,r10,r5
8000bf1c:	0a 4b       	or	r11,r5
8000bf1e:	f4 04 09 4a 	lsl	r10,r10,r4
8000bf22:	08 17       	sub	r7,r4
8000bf24:	c0 b8       	rjmp	8000bf3a <__avr32_f64_div_round_subnormal+0x96>
8000bf26:	f4 04 12 00 	clz	r4,r10
8000bf2a:	f9 b4 03 00 	movlo	r4,0
8000bf2e:	f7 b4 02 e0 	subhs	r4,-32
8000bf32:	f4 04 09 4b 	lsl	r11,r10,r4
8000bf36:	30 0a       	mov	r10,0
8000bf38:	08 17       	sub	r7,r4
8000bf3a:	a3 8a       	lsr	r10,0x2
8000bf3c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000bf40:	a3 8b       	lsr	r11,0x2
8000bf42:	c1 1b       	rjmp	8000bd64 <__avr32_f64_div+0x20>
8000bf44:	a3 79       	lsl	r9,0x3
8000bf46:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bf4a:	a3 78       	lsl	r8,0x3
8000bf4c:	f3 e8 10 04 	or	r4,r9,r8
8000bf50:	c6 f0       	breq	8000c02e <__avr32_f64_div_res_subnormal+0xa0>
8000bf52:	f2 04 12 00 	clz	r4,r9
8000bf56:	c1 70       	breq	8000bf84 <__avr32_f64_div_round_subnormal+0xe0>
8000bf58:	c0 c3       	brcs	8000bf70 <__avr32_f64_div_round_subnormal+0xcc>
8000bf5a:	e8 05 11 20 	rsub	r5,r4,32
8000bf5e:	f2 04 09 49 	lsl	r9,r9,r4
8000bf62:	f0 05 0a 45 	lsr	r5,r8,r5
8000bf66:	0a 49       	or	r9,r5
8000bf68:	f0 04 09 48 	lsl	r8,r8,r4
8000bf6c:	08 16       	sub	r6,r4
8000bf6e:	c0 b8       	rjmp	8000bf84 <__avr32_f64_div_round_subnormal+0xe0>
8000bf70:	f0 04 12 00 	clz	r4,r8
8000bf74:	f9 b4 03 00 	movlo	r4,0
8000bf78:	f7 b4 02 e0 	subhs	r4,-32
8000bf7c:	f0 04 09 49 	lsl	r9,r8,r4
8000bf80:	30 08       	mov	r8,0
8000bf82:	08 16       	sub	r6,r4
8000bf84:	a3 88       	lsr	r8,0x2
8000bf86:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000bf8a:	a3 89       	lsr	r9,0x2
8000bf8c:	cf ca       	rjmp	8000bd84 <__avr32_f64_div+0x40>

8000bf8e <__avr32_f64_div_res_subnormal>:
8000bf8e:	5c 37       	neg	r7
8000bf90:	2f f7       	sub	r7,-1
8000bf92:	f1 b7 04 c0 	satu	r7,0x6
8000bf96:	e0 47 00 20 	cp.w	r7,32
8000bf9a:	c1 54       	brge	8000bfc4 <__avr32_f64_div_res_subnormal+0x36>
8000bf9c:	ee 06 11 20 	rsub	r6,r7,32
8000bfa0:	e4 07 0a 42 	lsr	r2,r2,r7
8000bfa4:	e6 06 09 4c 	lsl	r12,r3,r6
8000bfa8:	18 42       	or	r2,r12
8000bfaa:	e6 07 0a 43 	lsr	r3,r3,r7
8000bfae:	f4 06 09 41 	lsl	r1,r10,r6
8000bfb2:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bfb6:	f6 06 09 4c 	lsl	r12,r11,r6
8000bfba:	18 4a       	or	r10,r12
8000bfbc:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bfc0:	30 00       	mov	r0,0
8000bfc2:	c1 58       	rjmp	8000bfec <__avr32_f64_div_res_subnormal+0x5e>
8000bfc4:	ee 06 11 20 	rsub	r6,r7,32
8000bfc8:	f9 b0 00 00 	moveq	r0,0
8000bfcc:	f9 bc 00 00 	moveq	r12,0
8000bfd0:	c0 50       	breq	8000bfda <__avr32_f64_div_res_subnormal+0x4c>
8000bfd2:	f4 06 09 40 	lsl	r0,r10,r6
8000bfd6:	f6 06 09 4c 	lsl	r12,r11,r6
8000bfda:	e6 07 0a 42 	lsr	r2,r3,r7
8000bfde:	30 03       	mov	r3,0
8000bfe0:	f4 07 0a 41 	lsr	r1,r10,r7
8000bfe4:	18 41       	or	r1,r12
8000bfe6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bfea:	30 0b       	mov	r11,0
8000bfec:	e0 12 ff 00 	andl	r2,0xff00
8000bff0:	e8 12 00 80 	orl	r2,0x80
8000bff4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bff8:	e4 09 07 46 	macu.d	r6,r2,r9
8000bffc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c000:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c004:	0c 05       	add	r5,r6
8000c006:	f0 07 00 48 	adc	r8,r8,r7
8000c00a:	5c 09       	acr	r9
8000c00c:	30 07       	mov	r7,0
8000c00e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c012:	00 34       	cp.w	r4,r0
8000c014:	e2 05 13 00 	cpc	r5,r1
8000c018:	c4 6b       	rjmp	8000bea4 <__avr32_f64_div_round_subnormal>
8000c01a:	1c 9b       	mov	r11,lr
8000c01c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c020:	30 0a       	mov	r10,0
8000c022:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c026:	3f fb       	mov	r11,-1
8000c028:	30 0a       	mov	r10,0
8000c02a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c02e:	f5 eb 10 04 	or	r4,r10,r11
8000c032:	c0 90       	breq	8000c044 <__avr32_f64_div_op1_zero>
8000c034:	1c 9b       	mov	r11,lr
8000c036:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c03a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c03e:	30 0a       	mov	r10,0
8000c040:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c044 <__avr32_f64_div_op1_zero>:
8000c044:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c048:	ce f0       	breq	8000c026 <__avr32_f64_div_res_subnormal+0x98>
8000c04a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c04e:	e0 44 07 ff 	cp.w	r4,2047
8000c052:	ce 41       	brne	8000c01a <__avr32_f64_div_res_subnormal+0x8c>
8000c054:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c058:	ce 10       	breq	8000c01a <__avr32_f64_div_res_subnormal+0x8c>
8000c05a:	ce 6b       	rjmp	8000c026 <__avr32_f64_div_res_subnormal+0x98>

8000c05c <__avr32_udiv64>:
8000c05c:	d4 31       	pushm	r0-r7,lr
8000c05e:	1a 97       	mov	r7,sp
8000c060:	20 3d       	sub	sp,12
8000c062:	10 9c       	mov	r12,r8
8000c064:	12 9e       	mov	lr,r9
8000c066:	14 93       	mov	r3,r10
8000c068:	58 09       	cp.w	r9,0
8000c06a:	e0 81 00 bd 	brne	8000c1e4 <__avr32_udiv64+0x188>
8000c06e:	16 38       	cp.w	r8,r11
8000c070:	e0 88 00 40 	brls	8000c0f0 <__avr32_udiv64+0x94>
8000c074:	f0 08 12 00 	clz	r8,r8
8000c078:	c0 d0       	breq	8000c092 <__avr32_udiv64+0x36>
8000c07a:	f6 08 09 4b 	lsl	r11,r11,r8
8000c07e:	f0 09 11 20 	rsub	r9,r8,32
8000c082:	f8 08 09 4c 	lsl	r12,r12,r8
8000c086:	f4 09 0a 49 	lsr	r9,r10,r9
8000c08a:	f4 08 09 43 	lsl	r3,r10,r8
8000c08e:	f3 eb 10 0b 	or	r11,r9,r11
8000c092:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c096:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c09a:	f6 0e 0d 00 	divu	r0,r11,lr
8000c09e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c0a2:	00 99       	mov	r9,r0
8000c0a4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c0a8:	e0 0a 02 48 	mul	r8,r0,r10
8000c0ac:	10 3b       	cp.w	r11,r8
8000c0ae:	c0 a2       	brcc	8000c0c2 <__avr32_udiv64+0x66>
8000c0b0:	20 19       	sub	r9,1
8000c0b2:	18 0b       	add	r11,r12
8000c0b4:	18 3b       	cp.w	r11,r12
8000c0b6:	c0 63       	brcs	8000c0c2 <__avr32_udiv64+0x66>
8000c0b8:	10 3b       	cp.w	r11,r8
8000c0ba:	f7 b9 03 01 	sublo	r9,1
8000c0be:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c0c2:	f6 08 01 01 	sub	r1,r11,r8
8000c0c6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c0ca:	e2 0e 0d 00 	divu	r0,r1,lr
8000c0ce:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c0d2:	00 98       	mov	r8,r0
8000c0d4:	e0 0a 02 4a 	mul	r10,r0,r10
8000c0d8:	14 33       	cp.w	r3,r10
8000c0da:	c0 82       	brcc	8000c0ea <__avr32_udiv64+0x8e>
8000c0dc:	20 18       	sub	r8,1
8000c0de:	18 03       	add	r3,r12
8000c0e0:	18 33       	cp.w	r3,r12
8000c0e2:	c0 43       	brcs	8000c0ea <__avr32_udiv64+0x8e>
8000c0e4:	14 33       	cp.w	r3,r10
8000c0e6:	f7 b8 03 01 	sublo	r8,1
8000c0ea:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c0ee:	cd f8       	rjmp	8000c2ac <__avr32_udiv64+0x250>
8000c0f0:	58 08       	cp.w	r8,0
8000c0f2:	c0 51       	brne	8000c0fc <__avr32_udiv64+0xa0>
8000c0f4:	30 19       	mov	r9,1
8000c0f6:	f2 08 0d 08 	divu	r8,r9,r8
8000c0fa:	10 9c       	mov	r12,r8
8000c0fc:	f8 06 12 00 	clz	r6,r12
8000c100:	c0 41       	brne	8000c108 <__avr32_udiv64+0xac>
8000c102:	18 1b       	sub	r11,r12
8000c104:	30 19       	mov	r9,1
8000c106:	c4 08       	rjmp	8000c186 <__avr32_udiv64+0x12a>
8000c108:	ec 01 11 20 	rsub	r1,r6,32
8000c10c:	f4 01 0a 49 	lsr	r9,r10,r1
8000c110:	f8 06 09 4c 	lsl	r12,r12,r6
8000c114:	f6 06 09 48 	lsl	r8,r11,r6
8000c118:	f6 01 0a 41 	lsr	r1,r11,r1
8000c11c:	f3 e8 10 08 	or	r8,r9,r8
8000c120:	f8 03 16 10 	lsr	r3,r12,0x10
8000c124:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c128:	e2 03 0d 00 	divu	r0,r1,r3
8000c12c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c130:	00 9e       	mov	lr,r0
8000c132:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c136:	e0 05 02 49 	mul	r9,r0,r5
8000c13a:	12 3b       	cp.w	r11,r9
8000c13c:	c0 a2       	brcc	8000c150 <__avr32_udiv64+0xf4>
8000c13e:	20 1e       	sub	lr,1
8000c140:	18 0b       	add	r11,r12
8000c142:	18 3b       	cp.w	r11,r12
8000c144:	c0 63       	brcs	8000c150 <__avr32_udiv64+0xf4>
8000c146:	12 3b       	cp.w	r11,r9
8000c148:	f7 be 03 01 	sublo	lr,1
8000c14c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c150:	12 1b       	sub	r11,r9
8000c152:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c156:	f6 03 0d 02 	divu	r2,r11,r3
8000c15a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c15e:	04 99       	mov	r9,r2
8000c160:	e4 05 02 4b 	mul	r11,r2,r5
8000c164:	16 38       	cp.w	r8,r11
8000c166:	c0 a2       	brcc	8000c17a <__avr32_udiv64+0x11e>
8000c168:	20 19       	sub	r9,1
8000c16a:	18 08       	add	r8,r12
8000c16c:	18 38       	cp.w	r8,r12
8000c16e:	c0 63       	brcs	8000c17a <__avr32_udiv64+0x11e>
8000c170:	16 38       	cp.w	r8,r11
8000c172:	f7 b9 03 01 	sublo	r9,1
8000c176:	f1 dc e3 08 	addcs	r8,r8,r12
8000c17a:	f4 06 09 43 	lsl	r3,r10,r6
8000c17e:	f0 0b 01 0b 	sub	r11,r8,r11
8000c182:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c186:	f8 06 16 10 	lsr	r6,r12,0x10
8000c18a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c18e:	f6 06 0d 00 	divu	r0,r11,r6
8000c192:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c196:	00 9a       	mov	r10,r0
8000c198:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c19c:	e0 0e 02 48 	mul	r8,r0,lr
8000c1a0:	10 3b       	cp.w	r11,r8
8000c1a2:	c0 a2       	brcc	8000c1b6 <__avr32_udiv64+0x15a>
8000c1a4:	20 1a       	sub	r10,1
8000c1a6:	18 0b       	add	r11,r12
8000c1a8:	18 3b       	cp.w	r11,r12
8000c1aa:	c0 63       	brcs	8000c1b6 <__avr32_udiv64+0x15a>
8000c1ac:	10 3b       	cp.w	r11,r8
8000c1ae:	f7 ba 03 01 	sublo	r10,1
8000c1b2:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c1b6:	f6 08 01 01 	sub	r1,r11,r8
8000c1ba:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c1be:	e2 06 0d 00 	divu	r0,r1,r6
8000c1c2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c1c6:	00 98       	mov	r8,r0
8000c1c8:	e0 0e 02 4b 	mul	r11,r0,lr
8000c1cc:	16 33       	cp.w	r3,r11
8000c1ce:	c0 82       	brcc	8000c1de <__avr32_udiv64+0x182>
8000c1d0:	20 18       	sub	r8,1
8000c1d2:	18 03       	add	r3,r12
8000c1d4:	18 33       	cp.w	r3,r12
8000c1d6:	c0 43       	brcs	8000c1de <__avr32_udiv64+0x182>
8000c1d8:	16 33       	cp.w	r3,r11
8000c1da:	f7 b8 03 01 	sublo	r8,1
8000c1de:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c1e2:	c6 98       	rjmp	8000c2b4 <__avr32_udiv64+0x258>
8000c1e4:	16 39       	cp.w	r9,r11
8000c1e6:	e0 8b 00 65 	brhi	8000c2b0 <__avr32_udiv64+0x254>
8000c1ea:	f2 09 12 00 	clz	r9,r9
8000c1ee:	c0 b1       	brne	8000c204 <__avr32_udiv64+0x1a8>
8000c1f0:	10 3a       	cp.w	r10,r8
8000c1f2:	5f 2a       	srhs	r10
8000c1f4:	1c 3b       	cp.w	r11,lr
8000c1f6:	5f b8       	srhi	r8
8000c1f8:	10 4a       	or	r10,r8
8000c1fa:	f2 0a 18 00 	cp.b	r10,r9
8000c1fe:	c5 90       	breq	8000c2b0 <__avr32_udiv64+0x254>
8000c200:	30 18       	mov	r8,1
8000c202:	c5 98       	rjmp	8000c2b4 <__avr32_udiv64+0x258>
8000c204:	f0 09 09 46 	lsl	r6,r8,r9
8000c208:	f2 03 11 20 	rsub	r3,r9,32
8000c20c:	fc 09 09 4e 	lsl	lr,lr,r9
8000c210:	f0 03 0a 48 	lsr	r8,r8,r3
8000c214:	f6 09 09 4c 	lsl	r12,r11,r9
8000c218:	f4 03 0a 42 	lsr	r2,r10,r3
8000c21c:	ef 46 ff f4 	st.w	r7[-12],r6
8000c220:	f6 03 0a 43 	lsr	r3,r11,r3
8000c224:	18 42       	or	r2,r12
8000c226:	f1 ee 10 0c 	or	r12,r8,lr
8000c22a:	f8 01 16 10 	lsr	r1,r12,0x10
8000c22e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c232:	e6 01 0d 04 	divu	r4,r3,r1
8000c236:	e4 03 16 10 	lsr	r3,r2,0x10
8000c23a:	08 9e       	mov	lr,r4
8000c23c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c240:	e8 06 02 48 	mul	r8,r4,r6
8000c244:	10 33       	cp.w	r3,r8
8000c246:	c0 a2       	brcc	8000c25a <__avr32_udiv64+0x1fe>
8000c248:	20 1e       	sub	lr,1
8000c24a:	18 03       	add	r3,r12
8000c24c:	18 33       	cp.w	r3,r12
8000c24e:	c0 63       	brcs	8000c25a <__avr32_udiv64+0x1fe>
8000c250:	10 33       	cp.w	r3,r8
8000c252:	f7 be 03 01 	sublo	lr,1
8000c256:	e7 dc e3 03 	addcs	r3,r3,r12
8000c25a:	10 13       	sub	r3,r8
8000c25c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c260:	e6 01 0d 00 	divu	r0,r3,r1
8000c264:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c268:	00 98       	mov	r8,r0
8000c26a:	e0 06 02 46 	mul	r6,r0,r6
8000c26e:	0c 3b       	cp.w	r11,r6
8000c270:	c0 a2       	brcc	8000c284 <__avr32_udiv64+0x228>
8000c272:	20 18       	sub	r8,1
8000c274:	18 0b       	add	r11,r12
8000c276:	18 3b       	cp.w	r11,r12
8000c278:	c0 63       	brcs	8000c284 <__avr32_udiv64+0x228>
8000c27a:	0c 3b       	cp.w	r11,r6
8000c27c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c280:	f7 b8 03 01 	sublo	r8,1
8000c284:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c288:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c28c:	0c 1b       	sub	r11,r6
8000c28e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c292:	06 95       	mov	r5,r3
8000c294:	16 35       	cp.w	r5,r11
8000c296:	e0 8b 00 0a 	brhi	8000c2aa <__avr32_udiv64+0x24e>
8000c29a:	5f 0b       	sreq	r11
8000c29c:	f4 09 09 49 	lsl	r9,r10,r9
8000c2a0:	12 32       	cp.w	r2,r9
8000c2a2:	5f b9       	srhi	r9
8000c2a4:	f7 e9 00 09 	and	r9,r11,r9
8000c2a8:	c0 60       	breq	8000c2b4 <__avr32_udiv64+0x258>
8000c2aa:	20 18       	sub	r8,1
8000c2ac:	30 09       	mov	r9,0
8000c2ae:	c0 38       	rjmp	8000c2b4 <__avr32_udiv64+0x258>
8000c2b0:	30 09       	mov	r9,0
8000c2b2:	12 98       	mov	r8,r9
8000c2b4:	10 9a       	mov	r10,r8
8000c2b6:	12 93       	mov	r3,r9
8000c2b8:	10 92       	mov	r2,r8
8000c2ba:	12 9b       	mov	r11,r9
8000c2bc:	2f dd       	sub	sp,-12
8000c2be:	d8 32       	popm	r0-r7,pc

8000c2c0 <__avr32_umod64>:
8000c2c0:	d4 31       	pushm	r0-r7,lr
8000c2c2:	1a 97       	mov	r7,sp
8000c2c4:	20 3d       	sub	sp,12
8000c2c6:	10 9c       	mov	r12,r8
8000c2c8:	12 95       	mov	r5,r9
8000c2ca:	14 9e       	mov	lr,r10
8000c2cc:	16 91       	mov	r1,r11
8000c2ce:	16 96       	mov	r6,r11
8000c2d0:	58 09       	cp.w	r9,0
8000c2d2:	e0 81 00 81 	brne	8000c3d4 <__avr32_umod64+0x114>
8000c2d6:	16 38       	cp.w	r8,r11
8000c2d8:	e0 88 00 12 	brls	8000c2fc <__avr32_umod64+0x3c>
8000c2dc:	f0 08 12 00 	clz	r8,r8
8000c2e0:	c4 e0       	breq	8000c37c <__avr32_umod64+0xbc>
8000c2e2:	f6 08 09 46 	lsl	r6,r11,r8
8000c2e6:	f8 08 09 4c 	lsl	r12,r12,r8
8000c2ea:	f0 0b 11 20 	rsub	r11,r8,32
8000c2ee:	f4 08 09 4e 	lsl	lr,r10,r8
8000c2f2:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c2f6:	f7 e6 10 06 	or	r6,r11,r6
8000c2fa:	c4 18       	rjmp	8000c37c <__avr32_umod64+0xbc>
8000c2fc:	58 08       	cp.w	r8,0
8000c2fe:	c0 51       	brne	8000c308 <__avr32_umod64+0x48>
8000c300:	30 19       	mov	r9,1
8000c302:	f2 08 0d 08 	divu	r8,r9,r8
8000c306:	10 9c       	mov	r12,r8
8000c308:	f8 08 12 00 	clz	r8,r12
8000c30c:	c0 31       	brne	8000c312 <__avr32_umod64+0x52>
8000c30e:	18 16       	sub	r6,r12
8000c310:	c3 68       	rjmp	8000c37c <__avr32_umod64+0xbc>
8000c312:	f0 03 11 20 	rsub	r3,r8,32
8000c316:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c31a:	f8 08 09 4c 	lsl	r12,r12,r8
8000c31e:	ec 08 09 49 	lsl	r9,r6,r8
8000c322:	ec 03 0a 43 	lsr	r3,r6,r3
8000c326:	f7 e9 10 09 	or	r9,r11,r9
8000c32a:	f8 05 16 10 	lsr	r5,r12,0x10
8000c32e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c332:	e6 05 0d 02 	divu	r2,r3,r5
8000c336:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c33a:	ec 02 02 4b 	mul	r11,r6,r2
8000c33e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c342:	16 3e       	cp.w	lr,r11
8000c344:	c0 72       	brcc	8000c352 <__avr32_umod64+0x92>
8000c346:	18 0e       	add	lr,r12
8000c348:	18 3e       	cp.w	lr,r12
8000c34a:	c0 43       	brcs	8000c352 <__avr32_umod64+0x92>
8000c34c:	16 3e       	cp.w	lr,r11
8000c34e:	fd dc e3 0e 	addcs	lr,lr,r12
8000c352:	fc 0b 01 03 	sub	r3,lr,r11
8000c356:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c35a:	e6 05 0d 02 	divu	r2,r3,r5
8000c35e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c362:	a5 36       	mul	r6,r2
8000c364:	0c 39       	cp.w	r9,r6
8000c366:	c0 72       	brcc	8000c374 <__avr32_umod64+0xb4>
8000c368:	18 09       	add	r9,r12
8000c36a:	18 39       	cp.w	r9,r12
8000c36c:	c0 43       	brcs	8000c374 <__avr32_umod64+0xb4>
8000c36e:	0c 39       	cp.w	r9,r6
8000c370:	f3 dc e3 09 	addcs	r9,r9,r12
8000c374:	f2 06 01 06 	sub	r6,r9,r6
8000c378:	f4 08 09 4e 	lsl	lr,r10,r8
8000c37c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c380:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c384:	ec 0a 0d 02 	divu	r2,r6,r10
8000c388:	fc 09 16 10 	lsr	r9,lr,0x10
8000c38c:	ea 02 02 4b 	mul	r11,r5,r2
8000c390:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c394:	16 39       	cp.w	r9,r11
8000c396:	c0 72       	brcc	8000c3a4 <__avr32_umod64+0xe4>
8000c398:	18 09       	add	r9,r12
8000c39a:	18 39       	cp.w	r9,r12
8000c39c:	c0 43       	brcs	8000c3a4 <__avr32_umod64+0xe4>
8000c39e:	16 39       	cp.w	r9,r11
8000c3a0:	f3 dc e3 09 	addcs	r9,r9,r12
8000c3a4:	f2 0b 01 0b 	sub	r11,r9,r11
8000c3a8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c3ac:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c3b0:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c3b4:	ea 0a 02 4a 	mul	r10,r5,r10
8000c3b8:	14 3e       	cp.w	lr,r10
8000c3ba:	c0 72       	brcc	8000c3c8 <__avr32_umod64+0x108>
8000c3bc:	18 0e       	add	lr,r12
8000c3be:	18 3e       	cp.w	lr,r12
8000c3c0:	c0 43       	brcs	8000c3c8 <__avr32_umod64+0x108>
8000c3c2:	14 3e       	cp.w	lr,r10
8000c3c4:	fd dc e3 0e 	addcs	lr,lr,r12
8000c3c8:	fc 0a 01 0a 	sub	r10,lr,r10
8000c3cc:	30 0b       	mov	r11,0
8000c3ce:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c3d2:	c7 b8       	rjmp	8000c4c8 <__avr32_umod64+0x208>
8000c3d4:	16 39       	cp.w	r9,r11
8000c3d6:	e0 8b 00 79 	brhi	8000c4c8 <__avr32_umod64+0x208>
8000c3da:	f2 09 12 00 	clz	r9,r9
8000c3de:	c1 21       	brne	8000c402 <__avr32_umod64+0x142>
8000c3e0:	10 3a       	cp.w	r10,r8
8000c3e2:	5f 2b       	srhs	r11
8000c3e4:	0a 31       	cp.w	r1,r5
8000c3e6:	5f ba       	srhi	r10
8000c3e8:	f7 ea 10 0a 	or	r10,r11,r10
8000c3ec:	f2 0a 18 00 	cp.b	r10,r9
8000c3f0:	c0 60       	breq	8000c3fc <__avr32_umod64+0x13c>
8000c3f2:	fc 08 01 0c 	sub	r12,lr,r8
8000c3f6:	e2 05 01 46 	sbc	r6,r1,r5
8000c3fa:	18 9e       	mov	lr,r12
8000c3fc:	0c 9b       	mov	r11,r6
8000c3fe:	1c 9a       	mov	r10,lr
8000c400:	c6 48       	rjmp	8000c4c8 <__avr32_umod64+0x208>
8000c402:	ea 09 09 4c 	lsl	r12,r5,r9
8000c406:	f2 06 11 20 	rsub	r6,r9,32
8000c40a:	f6 09 09 4b 	lsl	r11,r11,r9
8000c40e:	f0 09 09 42 	lsl	r2,r8,r9
8000c412:	ef 46 ff f4 	st.w	r7[-12],r6
8000c416:	f0 06 0a 48 	lsr	r8,r8,r6
8000c41a:	18 48       	or	r8,r12
8000c41c:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c420:	f4 09 09 43 	lsl	r3,r10,r9
8000c424:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c428:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c42c:	16 4a       	or	r10,r11
8000c42e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c432:	f8 0b 0d 04 	divu	r4,r12,r11
8000c436:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c43a:	08 91       	mov	r1,r4
8000c43c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c440:	e8 0e 02 46 	mul	r6,r4,lr
8000c444:	0c 3c       	cp.w	r12,r6
8000c446:	c0 a2       	brcc	8000c45a <__avr32_umod64+0x19a>
8000c448:	20 11       	sub	r1,1
8000c44a:	10 0c       	add	r12,r8
8000c44c:	10 3c       	cp.w	r12,r8
8000c44e:	c0 63       	brcs	8000c45a <__avr32_umod64+0x19a>
8000c450:	0c 3c       	cp.w	r12,r6
8000c452:	f7 b1 03 01 	sublo	r1,1
8000c456:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c45a:	0c 1c       	sub	r12,r6
8000c45c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c460:	f8 0b 0d 04 	divu	r4,r12,r11
8000c464:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c468:	08 96       	mov	r6,r4
8000c46a:	e8 0e 02 4e 	mul	lr,r4,lr
8000c46e:	1c 3b       	cp.w	r11,lr
8000c470:	c0 a2       	brcc	8000c484 <__avr32_umod64+0x1c4>
8000c472:	20 16       	sub	r6,1
8000c474:	10 0b       	add	r11,r8
8000c476:	10 3b       	cp.w	r11,r8
8000c478:	c0 63       	brcs	8000c484 <__avr32_umod64+0x1c4>
8000c47a:	1c 3b       	cp.w	r11,lr
8000c47c:	f7 b6 03 01 	sublo	r6,1
8000c480:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c484:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c488:	1c 1b       	sub	r11,lr
8000c48a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c48e:	00 9e       	mov	lr,r0
8000c490:	02 9c       	mov	r12,r1
8000c492:	16 3c       	cp.w	r12,r11
8000c494:	e0 8b 00 08 	brhi	8000c4a4 <__avr32_umod64+0x1e4>
8000c498:	5f 06       	sreq	r6
8000c49a:	06 30       	cp.w	r0,r3
8000c49c:	5f ba       	srhi	r10
8000c49e:	ed ea 00 0a 	and	r10,r6,r10
8000c4a2:	c0 60       	breq	8000c4ae <__avr32_umod64+0x1ee>
8000c4a4:	fc 02 01 04 	sub	r4,lr,r2
8000c4a8:	f8 08 01 4c 	sbc	r12,r12,r8
8000c4ac:	08 9e       	mov	lr,r4
8000c4ae:	e6 0e 01 0a 	sub	r10,r3,lr
8000c4b2:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c4b6:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c4ba:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c4be:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c4c2:	f8 01 09 4c 	lsl	r12,r12,r1
8000c4c6:	18 4a       	or	r10,r12
8000c4c8:	2f dd       	sub	sp,-12
8000c4ca:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c600 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c600:	c0 08       	rjmp	8000c600 <_evba>
	...

8000c604 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c604:	c0 08       	rjmp	8000c604 <_handle_TLB_Multiple_Hit>
	...

8000c608 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c608:	c0 08       	rjmp	8000c608 <_handle_Bus_Error_Data_Fetch>
	...

8000c60c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c60c:	c0 08       	rjmp	8000c60c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c610 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c610:	c0 08       	rjmp	8000c610 <_handle_NMI>
	...

8000c614 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c614:	c0 08       	rjmp	8000c614 <_handle_Instruction_Address>
	...

8000c618 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c618:	c0 08       	rjmp	8000c618 <_handle_ITLB_Protection>
	...

8000c61c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c61c:	c0 08       	rjmp	8000c61c <_handle_Breakpoint>
	...

8000c620 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c620:	c0 08       	rjmp	8000c620 <_handle_Illegal_Opcode>
	...

8000c624 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c624:	c0 08       	rjmp	8000c624 <_handle_Unimplemented_Instruction>
	...

8000c628 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c628:	c0 08       	rjmp	8000c628 <_handle_Privilege_Violation>
	...

8000c62c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c62c:	c0 08       	rjmp	8000c62c <_handle_Floating_Point>
	...

8000c630 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c630:	c0 08       	rjmp	8000c630 <_handle_Coprocessor_Absent>
	...

8000c634 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c634:	c0 08       	rjmp	8000c634 <_handle_Data_Address_Read>
	...

8000c638 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c638:	c0 08       	rjmp	8000c638 <_handle_Data_Address_Write>
	...

8000c63c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c63c:	c0 08       	rjmp	8000c63c <_handle_DTLB_Protection_Read>
	...

8000c640 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c640:	c0 08       	rjmp	8000c640 <_handle_DTLB_Protection_Write>
	...

8000c644 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c644:	c0 08       	rjmp	8000c644 <_handle_DTLB_Modified>
	...

8000c650 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c650:	c0 08       	rjmp	8000c650 <_handle_ITLB_Miss>
	...

8000c660 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c660:	c0 08       	rjmp	8000c660 <_handle_DTLB_Miss_Read>
	...

8000c670 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c670:	c0 08       	rjmp	8000c670 <_handle_DTLB_Miss_Write>
	...

8000c700 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c700:	fe cf 71 a4 	sub	pc,pc,29092

8000c704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c704:	30 0c       	mov	r12,0
8000c706:	fe b0 c3 9f 	rcall	80004e44 <_get_interrupt_handler>
8000c70a:	58 0c       	cp.w	r12,0
8000c70c:	f8 0f 17 10 	movne	pc,r12
8000c710:	d6 03       	rete

8000c712 <_int1>:
8000c712:	30 1c       	mov	r12,1
8000c714:	fe b0 c3 98 	rcall	80004e44 <_get_interrupt_handler>
8000c718:	58 0c       	cp.w	r12,0
8000c71a:	f8 0f 17 10 	movne	pc,r12
8000c71e:	d6 03       	rete

8000c720 <_int2>:
8000c720:	30 2c       	mov	r12,2
8000c722:	fe b0 c3 91 	rcall	80004e44 <_get_interrupt_handler>
8000c726:	58 0c       	cp.w	r12,0
8000c728:	f8 0f 17 10 	movne	pc,r12
8000c72c:	d6 03       	rete

8000c72e <_int3>:
8000c72e:	30 3c       	mov	r12,3
8000c730:	fe b0 c3 8a 	rcall	80004e44 <_get_interrupt_handler>
8000c734:	58 0c       	cp.w	r12,0
8000c736:	f8 0f 17 10 	movne	pc,r12
8000c73a:	d6 03       	rete

8000c73c <ipr_val>:
8000c73c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c74c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c75c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c76c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c77c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c78c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c79c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c7fc:	d7 03 d7 03                                         ....
