
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002010  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000df08  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80010000  80010000  00010400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009c58  80010200  80010200  00010600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  80019e58  0001a408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8001a88c  0001ae3c  2**0
                  ALLOC
  8 .bss          00003c78  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         00012948  000046b8  000046b8  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0001ae3c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001640  00000000  00000000  0001ae70  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002b2f  00000000  00000000  0001c4b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002ecbb  00000000  00000000  0001efdf  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000078a5  00000000  00000000  0004dc9a  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000e066  00000000  00000000  0005553f  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003db0  00000000  00000000  000635a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00008087  00000000  00000000  00067358  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    000123e5  00000000  00000000  0006f3df  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001738  00000000  00000000  000817c8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	a4 94       	st.b	r2[0x1],r4

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe ff 00 04 	ld.w	pc,pc[4]
8000200c:	80 00       	ld.sh	r0,r0[0x0]
8000200e:	a4 94       	st.b	r2[0x1],r4

Disassembly of section .text:

80002010 <DeviceManagement_brdcst_func>:
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002010:	19 a9       	ld.ub	r9,r12[0x2]
80002012:	30 18       	mov	r8,1
80002014:	f0 09 18 00 	cp.b	r9,r8
80002018:	c0 61       	brne	80002024 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000201a:	48 68       	lddpc	r8,80002030 <DeviceManagement_brdcst_func+0x20>
8000201c:	70 09       	ld.w	r9,r8[0x0]
8000201e:	a1 b9       	sbr	r9,0x1
80002020:	91 09       	st.w	r8[0x0],r9
80002022:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002024:	48 38       	lddpc	r8,80002030 <DeviceManagement_brdcst_func+0x20>
80002026:	70 09       	ld.w	r9,r8[0x0]
80002028:	a1 d9       	cbr	r9,0x1
8000202a:	91 09       	st.w	r8[0x0],r9
8000202c:	5e fc       	retal	r12
8000202e:	00 00       	add	r0,r0
80002030:	00 00       	add	r0,r0
80002032:	13 58       	ld.sh	r8,--r9

80002034 <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002034:	5e fc       	retal	r12

80002036 <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002036:	5e fc       	retal	r12

80002038 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002038:	48 38       	lddpc	r8,80002044 <vApplicationIdleHook+0xc>
8000203a:	70 09       	ld.w	r9,r8[0x0]
8000203c:	2f f9       	sub	r9,-1
8000203e:	91 09       	st.w	r8[0x0],r9
	
}
80002040:	5e fc       	retal	r12
80002042:	00 00       	add	r0,r0
80002044:	00 00       	add	r0,r0
80002046:	0a 5c       	eor	r12,r5

80002048 <app_init>:
														
		
};

void app_init(void)
{	
80002048:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
8000204a:	48 cb       	lddpc	r11,80002078 <app_init+0x30>
8000204c:	48 cc       	lddpc	r12,8000207c <app_init+0x34>
8000204e:	f0 1f 00 0d 	mcall	80002080 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
80002052:	48 dc       	lddpc	r12,80002084 <app_init+0x3c>
80002054:	f0 1f 00 0d 	mcall	80002088 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002058:	30 09       	mov	r9,0
8000205a:	1a d9       	st.w	--sp,r9
8000205c:	1a d9       	st.w	--sp,r9
8000205e:	1a d9       	st.w	--sp,r9
80002060:	30 18       	mov	r8,1
80002062:	e0 6a 01 80 	mov	r10,384
80002066:	48 ab       	lddpc	r11,8000208c <app_init+0x44>
80002068:	48 ac       	lddpc	r12,80002090 <app_init+0x48>
8000206a:	f0 1f 00 0b 	mcall	80002094 <app_init+0x4c>
8000206e:	48 b8       	lddpc	r8,80002098 <app_init+0x50>
80002070:	91 0c       	st.w	r8[0x0],r12
80002072:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
80002074:	d8 02       	popm	pc
80002076:	00 00       	add	r0,r0
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	29 04       	sub	r4,-112
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	29 44       	sub	r4,-108
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3c 34       	mov	r4,-61
80002084:	00 00       	add	r0,r0
80002086:	00 08       	add	r8,r0
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	51 28       	stdsp	sp[0x48],r8
8000208c:	80 01       	ld.sh	r1,r0[0x0]
8000208e:	02 00       	add	r0,r1
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	27 d0       	sub	r0,125
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	9b c8       	st.w	sp[0x30],r8
80002098:	00 00       	add	r0,r0
8000209a:	0a 40       	or	r0,r5

8000209c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000209c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000209e:	48 3c       	lddpc	r12,800020a8 <FD_brdcst_func+0xc>
800020a0:	f0 1f 00 03 	mcall	800020ac <FD_brdcst_func+0x10>
	
}
800020a4:	d8 02       	popm	pc
800020a6:	00 00       	add	r0,r0
800020a8:	80 01       	ld.sh	r1,r0[0x0]
800020aa:	02 08       	add	r8,r1
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	9f 8c       	st.w	pc[0x20],r12

800020b0 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b2:	48 3c       	lddpc	r12,800020bc <FD_reply_func+0xc>
800020b4:	f0 1f 00 03 	mcall	800020c0 <FD_reply_func+0x10>
	
	
}
800020b8:	d8 02       	popm	pc
800020ba:	00 00       	add	r0,r0
800020bc:	80 01       	ld.sh	r1,r0[0x0]
800020be:	02 28       	rsub	r8,r1
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	9f 8c       	st.w	pc[0x20],r12

800020c4 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020c6:	48 3c       	lddpc	r12,800020d0 <FD_request_func+0xc>
800020c8:	f0 1f 00 03 	mcall	800020d4 <FD_request_func+0x10>
	
	
}
800020cc:	d8 02       	popm	pc
800020ce:	00 00       	add	r0,r0
800020d0:	80 01       	ld.sh	r1,r0[0x0]
800020d2:	02 44       	or	r4,r1
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	9f 8c       	st.w	pc[0x20],r12

800020d8 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <EnOB_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <EnOB_brdcst_func+0x10>
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 01       	ld.sh	r1,r0[0x0]
800020e6:	02 60       	and	r0,r1
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	9f 8c       	st.w	pc[0x20],r12

800020ec <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	eb cd 40 80 	pushm	r7,lr
800020f0:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f2:	19 a9       	ld.ub	r9,r12[0x2]
800020f4:	30 08       	mov	r8,0
800020f6:	f0 09 18 00 	cp.b	r9,r8
800020fa:	c1 91       	brne	8000212c <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020fc:	19 b8       	ld.ub	r8,r12[0x3]
800020fe:	30 19       	mov	r9,1
80002100:	f2 08 18 00 	cp.b	r8,r9
80002104:	c0 61       	brne	80002110 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002106:	49 0c       	lddpc	r12,80002144 <EnOB_reply_func+0x58>
80002108:	f0 1f 00 10 	mcall	80002148 <EnOB_reply_func+0x5c>
8000210c:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002110:	58 08       	cp.w	r8,0
80002112:	c0 61       	brne	8000211e <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002114:	48 ec       	lddpc	r12,8000214c <EnOB_reply_func+0x60>
80002116:	f0 1f 00 0d 	mcall	80002148 <EnOB_reply_func+0x5c>
8000211a:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000211e:	1a d8       	st.w	--sp,r8
80002120:	48 cc       	lddpc	r12,80002150 <EnOB_reply_func+0x64>
80002122:	f0 1f 00 0a 	mcall	80002148 <EnOB_reply_func+0x5c>
80002126:	2f fd       	sub	sp,-4
80002128:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
8000212c:	48 ac       	lddpc	r12,80002154 <EnOB_reply_func+0x68>
8000212e:	f0 1f 00 07 	mcall	80002148 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002132:	0f a8       	ld.ub	r8,r7[0x2]
80002134:	1a d8       	st.w	--sp,r8
80002136:	48 9c       	lddpc	r12,80002158 <EnOB_reply_func+0x6c>
80002138:	f0 1f 00 04 	mcall	80002148 <EnOB_reply_func+0x5c>
8000213c:	2f fd       	sub	sp,-4
8000213e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002142:	00 00       	add	r0,r0
80002144:	80 01       	ld.sh	r1,r0[0x0]
80002146:	02 78       	tst	r8,r1
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	9f 8c       	st.w	pc[0x20],r12
8000214c:	80 01       	ld.sh	r1,r0[0x0]
8000214e:	02 90       	mov	r0,r1
80002150:	80 01       	ld.sh	r1,r0[0x0]
80002152:	02 a4       	st.w	r1++,r4
80002154:	80 01       	ld.sh	r1,r0[0x0]
80002156:	02 bc       	st.h	r1++,r12
80002158:	80 01       	ld.sh	r1,r0[0x0]
8000215a:	02 d8       	st.w	--r1,r8

8000215c <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
8000215c:	eb cd 40 80 	pushm	r7,lr
80002160:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002162:	19 a9       	ld.ub	r9,r12[0x2]
80002164:	31 18       	mov	r8,17
80002166:	f0 09 18 00 	cp.b	r9,r8
8000216a:	c0 61       	brne	80002176 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
8000216c:	48 8c       	lddpc	r12,8000218c <SingleDetection_brdcst_func+0x30>
8000216e:	f0 1f 00 09 	mcall	80002190 <SingleDetection_brdcst_func+0x34>
80002172:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002176:	48 8c       	lddpc	r12,80002194 <SingleDetection_brdcst_func+0x38>
80002178:	f0 1f 00 06 	mcall	80002190 <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
8000217c:	0f a8       	ld.ub	r8,r7[0x2]
8000217e:	1a d8       	st.w	--sp,r8
80002180:	48 6c       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x3c>
80002182:	f0 1f 00 04 	mcall	80002190 <SingleDetection_brdcst_func+0x34>
80002186:	2f fd       	sub	sp,-4
80002188:	e3 cd 80 80 	ldm	sp++,r7,pc
8000218c:	80 01       	ld.sh	r1,r0[0x0]
8000218e:	02 f0       	st.b	--r1,r0
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	9f 8c       	st.w	pc[0x20],r12
80002194:	80 01       	ld.sh	r1,r0[0x0]
80002196:	03 04       	ld.w	r4,r1++
80002198:	80 01       	ld.sh	r1,r0[0x0]
8000219a:	03 14       	ld.sh	r4,r1++

8000219c <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
8000219c:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000219e:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021a2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021a4:	4a bc       	lddpc	r12,80002250 <ButtonConfig_brdcst_func+0xb4>
800021a6:	f0 1f 00 2c 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021aa:	0f 88       	ld.ub	r8,r7[0x0]
800021ac:	1a d8       	st.w	--sp,r8
800021ae:	4a bc       	lddpc	r12,80002258 <ButtonConfig_brdcst_func+0xbc>
800021b0:	f0 1f 00 29 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021b4:	1a d5       	st.w	--sp,r5
800021b6:	4a ac       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xc0>
800021b8:	f0 1f 00 27 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021bc:	0f a8       	ld.ub	r8,r7[0x2]
800021be:	1a d8       	st.w	--sp,r8
800021c0:	4a 8c       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xc4>
800021c2:	f0 1f 00 25 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021c6:	2f dd       	sub	sp,-12
800021c8:	58 05       	cp.w	r5,0
800021ca:	c4 10       	breq	8000224c <ButtonConfig_brdcst_func+0xb0>
800021cc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021ce:	4a 64       	lddpc	r4,80002264 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021d0:	4a 63       	lddpc	r3,80002268 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021d2:	4a 72       	lddpc	r2,8000226c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021d4:	4a 71       	lddpc	r1,80002270 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021d6:	4a 80       	lddpc	r0,80002274 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021d8:	0f b9       	ld.ub	r9,r7[0x3]
800021da:	0f c8       	ld.ub	r8,r7[0x4]
800021dc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021e0:	1a d8       	st.w	--sp,r8
800021e2:	1a d6       	st.w	--sp,r6
800021e4:	08 9c       	mov	r12,r4
800021e6:	f0 1f 00 1c 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021ea:	0f d9       	ld.ub	r9,r7[0x5]
800021ec:	0f e8       	ld.ub	r8,r7[0x6]
800021ee:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f2:	1a d8       	st.w	--sp,r8
800021f4:	1a d6       	st.w	--sp,r6
800021f6:	06 9c       	mov	r12,r3
800021f8:	f0 1f 00 17 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021fc:	0f f9       	ld.ub	r9,r7[0x7]
800021fe:	ef 38 00 08 	ld.ub	r8,r7[8]
80002202:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002206:	1a d8       	st.w	--sp,r8
80002208:	1a d6       	st.w	--sp,r6
8000220a:	04 9c       	mov	r12,r2
8000220c:	f0 1f 00 12 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002210:	ef 39 00 09 	ld.ub	r9,r7[9]
80002214:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002218:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221c:	1a d8       	st.w	--sp,r8
8000221e:	1a d6       	st.w	--sp,r6
80002220:	02 9c       	mov	r12,r1
80002222:	f0 1f 00 0d 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002226:	2f 8d       	sub	sp,-32
80002228:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000222c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002230:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002234:	1a d8       	st.w	--sp,r8
80002236:	1a d6       	st.w	--sp,r6
80002238:	00 9c       	mov	r12,r0
8000223a:	f0 1f 00 07 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
8000223e:	2f f6       	sub	r6,-1
80002240:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002242:	2f ed       	sub	sp,-8
80002244:	ec 05 18 00 	cp.b	r5,r6
80002248:	fe 9b ff c8 	brhi	800021d8 <ButtonConfig_brdcst_func+0x3c>
8000224c:	d8 32       	popm	r0-r7,pc
8000224e:	00 00       	add	r0,r0
80002250:	80 01       	ld.sh	r1,r0[0x0]
80002252:	03 2c       	ld.uh	r12,r1++
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	9f 8c       	st.w	pc[0x20],r12
80002258:	80 01       	ld.sh	r1,r0[0x0]
8000225a:	03 4c       	ld.w	r12,--r1
8000225c:	80 01       	ld.sh	r1,r0[0x0]
8000225e:	03 60       	ld.uh	r0,--r1
80002260:	80 01       	ld.sh	r1,r0[0x0]
80002262:	03 78       	ld.ub	r8,--r1
80002264:	80 01       	ld.sh	r1,r0[0x0]
80002266:	03 98       	ld.ub	r8,r1[0x1]
80002268:	80 01       	ld.sh	r1,r0[0x0]
8000226a:	03 c0       	ld.ub	r0,r1[0x4]
8000226c:	80 01       	ld.sh	r1,r0[0x0]
8000226e:	03 e8       	ld.ub	r8,r1[0x6]
80002270:	80 01       	ld.sh	r1,r0[0x0]
80002272:	04 0c       	add	r12,r2
80002274:	80 01       	ld.sh	r1,r0[0x0]
80002276:	04 34       	cp.w	r4,r2

80002278 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002278:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
8000227c:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000227e:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002280:	19 c7       	ld.ub	r7,r12[0x4]
80002282:	19 d8       	ld.ub	r8,r12[0x5]
80002284:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002288:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
8000228a:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
8000228c:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002290:	49 0c       	lddpc	r12,800022d0 <Phyuserinput_brdcst_func+0x58>
80002292:	f0 1f 00 11 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002296:	1a d6       	st.w	--sp,r6
80002298:	49 0c       	lddpc	r12,800022d8 <Phyuserinput_brdcst_func+0x60>
8000229a:	f0 1f 00 0f 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000229e:	1a d5       	st.w	--sp,r5
800022a0:	48 fc       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x64>
800022a2:	f0 1f 00 0d 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022a6:	5c 77       	castu.h	r7
800022a8:	1a d7       	st.w	--sp,r7
800022aa:	48 ec       	lddpc	r12,800022e0 <Phyuserinput_brdcst_func+0x68>
800022ac:	f0 1f 00 0a 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022b0:	1a d4       	st.w	--sp,r4
800022b2:	48 dc       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x6c>
800022b4:	f0 1f 00 08 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022b8:	1a d3       	st.w	--sp,r3
800022ba:	48 cc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x70>
800022bc:	f0 1f 00 06 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022c0:	1a d2       	st.w	--sp,r2
800022c2:	48 bc       	lddpc	r12,800022ec <Phyuserinput_brdcst_func+0x74>
800022c4:	f0 1f 00 04 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
800022c8:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022ca:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022ce:	00 00       	add	r0,r0
800022d0:	80 01       	ld.sh	r1,r0[0x0]
800022d2:	04 58       	eor	r8,r2
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	9f 8c       	st.w	pc[0x20],r12
800022d8:	80 01       	ld.sh	r1,r0[0x0]
800022da:	04 7c       	tst	r12,r2
800022dc:	80 01       	ld.sh	r1,r0[0x0]
800022de:	04 94       	mov	r4,r2
800022e0:	80 01       	ld.sh	r1,r0[0x0]
800022e2:	04 a8       	st.w	r2++,r8
800022e4:	80 01       	ld.sh	r1,r0[0x0]
800022e6:	04 bc       	st.h	r2++,r12
800022e8:	80 01       	ld.sh	r1,r0[0x0]
800022ea:	04 d0       	st.w	--r2,r0
800022ec:	80 01       	ld.sh	r1,r0[0x0]
800022ee:	04 f0       	st.b	--r2,r0

800022f0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022f0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022f4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022f8:	0f 89       	ld.ub	r9,r7[0x0]
800022fa:	30 08       	mov	r8,0
800022fc:	f0 09 18 00 	cp.b	r9,r8
80002300:	c0 c1       	brne	80002318 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002302:	48 9c       	lddpc	r12,80002324 <ButtonConfig_reply_func+0x34>
80002304:	f0 1f 00 09 	mcall	80002328 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002308:	0f 98       	ld.ub	r8,r7[0x1]
8000230a:	1a d8       	st.w	--sp,r8
8000230c:	48 8c       	lddpc	r12,8000232c <ButtonConfig_reply_func+0x3c>
8000230e:	f0 1f 00 07 	mcall	80002328 <ButtonConfig_reply_func+0x38>
80002312:	2f fd       	sub	sp,-4
80002314:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002318:	48 6c       	lddpc	r12,80002330 <ButtonConfig_reply_func+0x40>
8000231a:	f0 1f 00 04 	mcall	80002328 <ButtonConfig_reply_func+0x38>
8000231e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002322:	00 00       	add	r0,r0
80002324:	80 01       	ld.sh	r1,r0[0x0]
80002326:	05 10       	ld.sh	r0,r2++
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	9f 8c       	st.w	pc[0x20],r12
8000232c:	80 01       	ld.sh	r1,r0[0x0]
8000232e:	03 4c       	ld.w	r12,--r1
80002330:	80 01       	ld.sh	r1,r0[0x0]
80002332:	05 28       	ld.uh	r8,r2++

80002334 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002334:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002336:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000233a:	0d 88       	ld.ub	r8,r6[0x0]
8000233c:	32 49       	mov	r9,36
8000233e:	f2 08 18 00 	cp.b	r8,r9
80002342:	c2 91       	brne	80002394 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002344:	49 7c       	lddpc	r12,800023a0 <DataSession_brdcst_func+0x6c>
80002346:	f0 1f 00 18 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000234a:	0d a5       	ld.ub	r5,r6[0x2]
8000234c:	0d b8       	ld.ub	r8,r6[0x3]
8000234e:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002352:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002354:	0d 98       	ld.ub	r8,r6[0x1]
80002356:	1a d8       	st.w	--sp,r8
80002358:	49 4c       	lddpc	r12,800023a8 <DataSession_brdcst_func+0x74>
8000235a:	f0 1f 00 13 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000235e:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002362:	1a d8       	st.w	--sp,r8
80002364:	49 2c       	lddpc	r12,800023ac <DataSession_brdcst_func+0x78>
80002366:	f0 1f 00 10 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
8000236a:	2f ed       	sub	sp,-8
8000236c:	58 05       	cp.w	r5,0
8000236e:	c1 80       	breq	8000239e <DataSession_brdcst_func+0x6a>
80002370:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002372:	49 04       	lddpc	r4,800023b0 <DataSession_brdcst_func+0x7c>
80002374:	ec 07 00 08 	add	r8,r6,r7
80002378:	11 c8       	ld.ub	r8,r8[0x4]
8000237a:	1a d8       	st.w	--sp,r8
8000237c:	1a d7       	st.w	--sp,r7
8000237e:	08 9c       	mov	r12,r4
80002380:	f0 1f 00 09 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002384:	2f f7       	sub	r7,-1
80002386:	5c 57       	castu.b	r7
80002388:	2f ed       	sub	sp,-8
8000238a:	ee 05 19 00 	cp.h	r5,r7
8000238e:	fe 9b ff f3 	brhi	80002374 <DataSession_brdcst_func+0x40>
80002392:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002394:	1a d8       	st.w	--sp,r8
80002396:	48 8c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0x80>
80002398:	f0 1f 00 03 	mcall	800023a4 <DataSession_brdcst_func+0x70>
8000239c:	2f fd       	sub	sp,-4
8000239e:	d8 22       	popm	r4-r7,pc
800023a0:	80 01       	ld.sh	r1,r0[0x0]
800023a2:	05 44       	ld.w	r4,--r2
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	9f 8c       	st.w	pc[0x20],r12
800023a8:	80 01       	ld.sh	r1,r0[0x0]
800023aa:	05 58       	ld.sh	r8,--r2
800023ac:	80 01       	ld.sh	r1,r0[0x0]
800023ae:	05 70       	ld.ub	r0,--r2
800023b0:	80 01       	ld.sh	r1,r0[0x0]
800023b2:	05 8c       	ld.ub	r12,r2[0x0]
800023b4:	80 01       	ld.sh	r1,r0[0x0]
800023b6:	05 a4       	ld.ub	r4,r2[0x2]

800023b8 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023b8:	eb cd 40 80 	pushm	r7,lr
800023bc:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023be:	19 a8       	ld.ub	r8,r12[0x2]
800023c0:	58 08       	cp.w	r8,0
800023c2:	c0 61       	brne	800023ce <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023c4:	48 dc       	lddpc	r12,800023f8 <DataSession_reply_func+0x40>
800023c6:	f0 1f 00 0e 	mcall	800023fc <DataSession_reply_func+0x44>
800023ca:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x48>
800023d2:	f0 1f 00 0b 	mcall	800023fc <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023d6:	48 cc       	lddpc	r12,80002404 <DataSession_reply_func+0x4c>
800023d8:	f0 1f 00 09 	mcall	800023fc <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023dc:	0f b8       	ld.ub	r8,r7[0x3]
800023de:	1a d8       	st.w	--sp,r8
800023e0:	48 ac       	lddpc	r12,80002408 <DataSession_reply_func+0x50>
800023e2:	f0 1f 00 07 	mcall	800023fc <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023e6:	0f c8       	ld.ub	r8,r7[0x4]
800023e8:	1a d8       	st.w	--sp,r8
800023ea:	48 9c       	lddpc	r12,8000240c <DataSession_reply_func+0x54>
800023ec:	f0 1f 00 04 	mcall	800023fc <DataSession_reply_func+0x44>
800023f0:	2f dd       	sub	sp,-12
800023f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f6:	00 00       	add	r0,r0
800023f8:	80 01       	ld.sh	r1,r0[0x0]
800023fa:	05 b8       	ld.ub	r8,r2[0x3]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	9f 8c       	st.w	pc[0x20],r12
80002400:	80 01       	ld.sh	r1,r0[0x0]
80002402:	05 cc       	ld.ub	r12,r2[0x4]
80002404:	80 01       	ld.sh	r1,r0[0x0]
80002406:	05 e0       	ld.ub	r0,r2[0x6]
80002408:	80 01       	ld.sh	r1,r0[0x0]
8000240a:	05 f4       	ld.ub	r4,r2[0x7]
8000240c:	80 01       	ld.sh	r1,r0[0x0]
8000240e:	06 04       	add	r4,r3

80002410 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002410:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002414:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002418:	0f 89       	ld.ub	r9,r7[0x0]
8000241a:	30 08       	mov	r8,0
8000241c:	f0 09 18 00 	cp.b	r9,r8
80002420:	c2 21       	brne	80002464 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002422:	49 4c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x60>
80002424:	f0 1f 00 14 	mcall	80002474 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
80002428:	0f 98       	ld.ub	r8,r7[0x1]
8000242a:	1a d8       	st.w	--sp,r8
8000242c:	49 3c       	lddpc	r12,80002478 <TransmitControl_reply_func+0x68>
8000242e:	f0 1f 00 12 	mcall	80002474 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002432:	0f a8       	ld.ub	r8,r7[0x2]
80002434:	1a d8       	st.w	--sp,r8
80002436:	49 2c       	lddpc	r12,8000247c <TransmitControl_reply_func+0x6c>
80002438:	f0 1f 00 0f 	mcall	80002474 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
8000243c:	0f b8       	ld.ub	r8,r7[0x3]
8000243e:	1a d8       	st.w	--sp,r8
80002440:	49 0c       	lddpc	r12,80002480 <TransmitControl_reply_func+0x70>
80002442:	f0 1f 00 0d 	mcall	80002474 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
80002446:	0f 98       	ld.ub	r8,r7[0x1]
80002448:	2f dd       	sub	sp,-12
8000244a:	30 19       	mov	r9,1
8000244c:	f2 08 18 00 	cp.b	r8,r9
80002450:	c0 d0       	breq	8000246a <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
80002452:	30 29       	mov	r9,2
80002454:	f2 08 18 00 	cp.b	r8,r9
80002458:	c0 91       	brne	8000246a <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
8000245a:	30 09       	mov	r9,0
8000245c:	48 a8       	lddpc	r8,80002484 <TransmitControl_reply_func+0x74>
8000245e:	b0 89       	st.b	r8[0x0],r9
80002460:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002464:	48 9c       	lddpc	r12,80002488 <TransmitControl_reply_func+0x78>
80002466:	f0 1f 00 04 	mcall	80002474 <TransmitControl_reply_func+0x64>
8000246a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246e:	00 00       	add	r0,r0
80002470:	80 01       	ld.sh	r1,r0[0x0]
80002472:	06 14       	sub	r4,r3
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	9f 8c       	st.w	pc[0x20],r12
80002478:	80 01       	ld.sh	r1,r0[0x0]
8000247a:	06 30       	cp.w	r0,r3
8000247c:	80 01       	ld.sh	r1,r0[0x0]
8000247e:	06 44       	or	r4,r3
80002480:	80 01       	ld.sh	r1,r0[0x0]
80002482:	06 60       	and	r0,r3
80002484:	00 00       	add	r0,r0
80002486:	0a 4d       	or	sp,r5
80002488:	80 01       	ld.sh	r1,r0[0x0]
8000248a:	06 70       	tst	r0,r3

8000248c <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000248c:	eb cd 40 f8 	pushm	r3-r7,lr
80002490:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
80002492:	19 a5       	ld.ub	r5,r12[0x2]
80002494:	19 b8       	ld.ub	r8,r12[0x3]
80002496:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000249a:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
8000249c:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800024a0:	1a d8       	st.w	--sp,r8
800024a2:	49 6c       	lddpc	r12,800024f8 <AudioRoutingControl_brdcst_func+0x6c>
800024a4:	f0 1f 00 16 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024a8:	2f fd       	sub	sp,-4
800024aa:	58 05       	cp.w	r5,0
800024ac:	c0 31       	brne	800024b2 <AudioRoutingControl_brdcst_func+0x26>
800024ae:	30 07       	mov	r7,0
800024b0:	c1 98       	rjmp	800024e2 <AudioRoutingControl_brdcst_func+0x56>
800024b2:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b4:	49 34       	lddpc	r4,80002500 <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024b6:	49 43       	lddpc	r3,80002504 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b8:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024bc:	11 c8       	ld.ub	r8,r8[0x4]
800024be:	1a d8       	st.w	--sp,r8
800024c0:	08 9c       	mov	r12,r4
800024c2:	f0 1f 00 0f 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024c6:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024ca:	11 d8       	ld.ub	r8,r8[0x5]
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	06 9c       	mov	r12,r3
800024d0:	f0 1f 00 0b 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800024d4:	2f f7       	sub	r7,-1
800024d6:	5c 57       	castu.b	r7
800024d8:	2f ed       	sub	sp,-8
800024da:	ee 05 19 00 	cp.h	r5,r7
800024de:	fe 9b ff ed 	brhi	800024b8 <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
800024e2:	ec 07 00 17 	add	r7,r6,r7<<0x1
800024e6:	0f c8       	ld.ub	r8,r7[0x4]
800024e8:	1a d8       	st.w	--sp,r8
800024ea:	48 8c       	lddpc	r12,80002508 <AudioRoutingControl_brdcst_func+0x7c>
800024ec:	f0 1f 00 04 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
800024f0:	2f fd       	sub	sp,-4
	
	
	
}
800024f2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800024f6:	00 00       	add	r0,r0
800024f8:	80 01       	ld.sh	r1,r0[0x0]
800024fa:	06 88       	andn	r8,r3
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	9f 8c       	st.w	pc[0x20],r12
80002500:	80 01       	ld.sh	r1,r0[0x0]
80002502:	06 a0       	st.w	r3++,r0
80002504:	80 01       	ld.sh	r1,r0[0x0]
80002506:	06 b8       	st.h	r3++,r8
80002508:	80 01       	ld.sh	r1,r0[0x0]
8000250a:	06 d0       	st.w	--r3,r0

8000250c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000250c:	eb cd 40 80 	pushm	r7,lr
80002510:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002512:	19 a9       	ld.ub	r9,r12[0x2]
80002514:	30 08       	mov	r8,0
80002516:	f0 09 18 00 	cp.b	r9,r8
8000251a:	c0 61       	brne	80002526 <AudioRoutingControl_reply_func+0x1a>
	{
		log("AudioRouting OK");
8000251c:	48 8c       	lddpc	r12,8000253c <AudioRoutingControl_reply_func+0x30>
8000251e:	f0 1f 00 09 	mcall	80002540 <AudioRoutingControl_reply_func+0x34>
80002522:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002526:	48 8c       	lddpc	r12,80002544 <AudioRoutingControl_reply_func+0x38>
80002528:	f0 1f 00 06 	mcall	80002540 <AudioRoutingControl_reply_func+0x34>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
8000252c:	0f a8       	ld.ub	r8,r7[0x2]
8000252e:	1a d8       	st.w	--sp,r8
80002530:	48 6c       	lddpc	r12,80002548 <AudioRoutingControl_reply_func+0x3c>
80002532:	f0 1f 00 04 	mcall	80002540 <AudioRoutingControl_reply_func+0x34>
80002536:	2f fd       	sub	sp,-4
80002538:	e3 cd 80 80 	ldm	sp++,r7,pc
8000253c:	80 01       	ld.sh	r1,r0[0x0]
8000253e:	06 ec       	st.h	--r3,r12
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	9f 8c       	st.w	pc[0x20],r12
80002544:	80 01       	ld.sh	r1,r0[0x0]
80002546:	06 fc       	st.b	--r3,r12
80002548:	80 01       	ld.sh	r1,r0[0x0]
8000254a:	07 10       	ld.sh	r0,r3++

8000254c <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
8000254c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
80002550:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002554:	0f 89       	ld.ub	r9,r7[0x0]
80002556:	0f 98       	ld.ub	r8,r7[0x1]
80002558:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000255c:	1a d8       	st.w	--sp,r8
8000255e:	48 6c       	lddpc	r12,80002574 <Volume_brdcst_func+0x28>
80002560:	f0 1f 00 06 	mcall	80002578 <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
80002564:	0f b8       	ld.ub	r8,r7[0x3]
80002566:	1a d8       	st.w	--sp,r8
80002568:	48 5c       	lddpc	r12,8000257c <Volume_brdcst_func+0x30>
8000256a:	f0 1f 00 04 	mcall	80002578 <Volume_brdcst_func+0x2c>
8000256e:	2f ed       	sub	sp,-8
	
	
}
80002570:	e3 cd 80 80 	ldm	sp++,r7,pc
80002574:	80 01       	ld.sh	r1,r0[0x0]
80002576:	07 30       	ld.ub	r0,r3++
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	9f 8c       	st.w	pc[0x20],r12
8000257c:	80 01       	ld.sh	r1,r0[0x0]
8000257e:	07 4c       	ld.w	r12,--r3

80002580 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002588:	0f 89       	ld.ub	r9,r7[0x0]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c1 b1       	brne	800025c6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002592:	0f b8       	ld.ub	r8,r7[0x3]
80002594:	31 09       	mov	r9,16
80002596:	f2 08 18 00 	cp.b	r8,r9
8000259a:	c0 f1       	brne	800025b8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000259c:	48 dc       	lddpc	r12,800025d0 <Volume_reply_func+0x50>
8000259e:	f0 1f 00 0e 	mcall	800025d4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025a2:	0f 99       	ld.ub	r9,r7[0x1]
800025a4:	0f a8       	ld.ub	r8,r7[0x2]
800025a6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025aa:	1a d8       	st.w	--sp,r8
800025ac:	48 bc       	lddpc	r12,800025d8 <Volume_reply_func+0x58>
800025ae:	f0 1f 00 0a 	mcall	800025d4 <Volume_reply_func+0x54>
800025b2:	2f fd       	sub	sp,-4
800025b4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025b8:	1a d8       	st.w	--sp,r8
800025ba:	48 9c       	lddpc	r12,800025dc <Volume_reply_func+0x5c>
800025bc:	f0 1f 00 06 	mcall	800025d4 <Volume_reply_func+0x54>
800025c0:	2f fd       	sub	sp,-4
800025c2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025c6:	48 7c       	lddpc	r12,800025e0 <Volume_reply_func+0x60>
800025c8:	f0 1f 00 03 	mcall	800025d4 <Volume_reply_func+0x54>
800025cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800025d0:	80 01       	ld.sh	r1,r0[0x0]
800025d2:	07 68       	ld.uh	r8,--r3
800025d4:	80 00       	ld.sh	r0,r0[0x0]
800025d6:	9f 8c       	st.w	pc[0x20],r12
800025d8:	80 01       	ld.sh	r1,r0[0x0]
800025da:	07 30       	ld.ub	r0,r3++
800025dc:	80 01       	ld.sh	r1,r0[0x0]
800025de:	07 7c       	ld.ub	r12,--r3
800025e0:	80 01       	ld.sh	r1,r0[0x0]
800025e2:	07 94       	ld.ub	r4,r3[0x1]

800025e4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025e6:	19 d9       	ld.ub	r9,r12[0x5]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c0 91       	brne	80002600 <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025f0:	48 89       	lddpc	r9,80002610 <spk_brdcst_func+0x2c>
800025f2:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025f4:	48 89       	lddpc	r9,80002614 <spk_brdcst_func+0x30>
800025f6:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025f8:	48 8c       	lddpc	r12,80002618 <spk_brdcst_func+0x34>
800025fa:	f0 1f 00 09 	mcall	8000261c <spk_brdcst_func+0x38>
800025fe:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
80002600:	30 19       	mov	r9,1
80002602:	48 58       	lddpc	r8,80002614 <spk_brdcst_func+0x30>
80002604:	b0 89       	st.b	r8[0x0],r9
		//is_unmute = 1;
		log("spk_s_open ");
80002606:	48 7c       	lddpc	r12,80002620 <spk_brdcst_func+0x3c>
80002608:	f0 1f 00 05 	mcall	8000261c <spk_brdcst_func+0x38>
8000260c:	d8 02       	popm	pc
8000260e:	00 00       	add	r0,r0
80002610:	00 00       	add	r0,r0
80002612:	0a 4d       	or	sp,r5
80002614:	00 00       	add	r0,r0
80002616:	0a 58       	eor	r8,r5
80002618:	80 01       	ld.sh	r1,r0[0x0]
8000261a:	07 ac       	ld.ub	r12,r3[0x2]
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	9f 8c       	st.w	pc[0x20],r12
80002620:	80 01       	ld.sh	r1,r0[0x0]
80002622:	07 bc       	ld.ub	r12,r3[0x3]

80002624 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002624:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002626:	19 a9       	ld.ub	r9,r12[0x2]
80002628:	30 08       	mov	r8,0
8000262a:	f0 09 18 00 	cp.b	r9,r8
8000262e:	c0 f1       	brne	8000264c <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002630:	19 e9       	ld.ub	r9,r12[0x6]
80002632:	f0 09 18 00 	cp.b	r9,r8
80002636:	c0 40       	breq	8000263e <spk_reply_func+0x1a>
		{
			is_unmute = 1;
80002638:	30 19       	mov	r9,1
8000263a:	48 78       	lddpc	r8,80002654 <spk_reply_func+0x30>
8000263c:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000263e:	19 e8       	ld.ub	r8,r12[0x6]
80002640:	1a d8       	st.w	--sp,r8
80002642:	48 6c       	lddpc	r12,80002658 <spk_reply_func+0x34>
80002644:	f0 1f 00 06 	mcall	8000265c <spk_reply_func+0x38>
80002648:	2f fd       	sub	sp,-4
8000264a:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
8000264c:	48 5c       	lddpc	r12,80002660 <spk_reply_func+0x3c>
8000264e:	f0 1f 00 04 	mcall	8000265c <spk_reply_func+0x38>
80002652:	d8 02       	popm	pc
80002654:	00 00       	add	r0,r0
80002656:	0a 4d       	or	sp,r5
80002658:	80 01       	ld.sh	r1,r0[0x0]
8000265a:	07 c8       	ld.ub	r8,r3[0x4]
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	9f 8c       	st.w	pc[0x20],r12
80002660:	80 01       	ld.sh	r1,r0[0x0]
80002662:	07 d8       	ld.ub	r8,r3[0x5]

80002664 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
8000266c:	49 ac       	lddpc	r12,800026d4 <mic_reply_func+0x70>
8000266e:	f0 1f 00 1b 	mcall	800026d8 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002672:	0f 89       	ld.ub	r9,r7[0x0]
80002674:	30 08       	mov	r8,0
80002676:	f0 09 18 00 	cp.b	r9,r8
8000267a:	c2 71       	brne	800026c8 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
8000267c:	0f 98       	ld.ub	r8,r7[0x1]
8000267e:	30 29       	mov	r9,2
80002680:	f2 08 18 00 	cp.b	r8,r9
80002684:	c1 b1       	brne	800026ba <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002686:	49 6c       	lddpc	r12,800026dc <mic_reply_func+0x78>
80002688:	f0 1f 00 14 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
8000268c:	0f a8       	ld.ub	r8,r7[0x2]
8000268e:	1a d8       	st.w	--sp,r8
80002690:	49 4c       	lddpc	r12,800026e0 <mic_reply_func+0x7c>
80002692:	f0 1f 00 12 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002696:	0f b8       	ld.ub	r8,r7[0x3]
80002698:	1a d8       	st.w	--sp,r8
8000269a:	49 3c       	lddpc	r12,800026e4 <mic_reply_func+0x80>
8000269c:	f0 1f 00 0f 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026a0:	0f c8       	ld.ub	r8,r7[0x4]
800026a2:	1a d8       	st.w	--sp,r8
800026a4:	49 1c       	lddpc	r12,800026e8 <mic_reply_func+0x84>
800026a6:	f0 1f 00 0d 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026aa:	0f d8       	ld.ub	r8,r7[0x5]
800026ac:	1a d8       	st.w	--sp,r8
800026ae:	49 0c       	lddpc	r12,800026ec <mic_reply_func+0x88>
800026b0:	f0 1f 00 0a 	mcall	800026d8 <mic_reply_func+0x74>
800026b4:	2f cd       	sub	sp,-16
800026b6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026ba:	1a d8       	st.w	--sp,r8
800026bc:	48 dc       	lddpc	r12,800026f0 <mic_reply_func+0x8c>
800026be:	f0 1f 00 07 	mcall	800026d8 <mic_reply_func+0x74>
800026c2:	2f fd       	sub	sp,-4
800026c4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026c8:	48 bc       	lddpc	r12,800026f4 <mic_reply_func+0x90>
800026ca:	f0 1f 00 04 	mcall	800026d8 <mic_reply_func+0x74>
800026ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800026d2:	00 00       	add	r0,r0
800026d4:	80 01       	ld.sh	r1,r0[0x0]
800026d6:	07 e4       	ld.ub	r4,r3[0x6]
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	9f 8c       	st.w	pc[0x20],r12
800026dc:	80 01       	ld.sh	r1,r0[0x0]
800026de:	07 f4       	ld.ub	r4,r3[0x7]
800026e0:	80 01       	ld.sh	r1,r0[0x0]
800026e2:	08 08       	add	r8,r4
800026e4:	80 01       	ld.sh	r1,r0[0x0]
800026e6:	08 1c       	sub	r12,r4
800026e8:	80 01       	ld.sh	r1,r0[0x0]
800026ea:	08 38       	cp.w	r8,r4
800026ec:	80 01       	ld.sh	r1,r0[0x0]
800026ee:	08 50       	eor	r0,r4
800026f0:	80 01       	ld.sh	r1,r0[0x0]
800026f2:	08 68       	and	r8,r4
800026f4:	80 01       	ld.sh	r1,r0[0x0]
800026f6:	08 80       	andn	r0,r4

800026f8 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026f8:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026fc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002700:	48 bc       	lddpc	r12,8000272c <dcm_brdcst_func+0x34>
80002702:	f0 1f 00 0c 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002706:	0f 88       	ld.ub	r8,r7[0x0]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	48 bc       	lddpc	r12,80002734 <dcm_brdcst_func+0x3c>
8000270c:	f0 1f 00 09 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002710:	0f a8       	ld.ub	r8,r7[0x2]
80002712:	1a d8       	st.w	--sp,r8
80002714:	48 9c       	lddpc	r12,80002738 <dcm_brdcst_func+0x40>
80002716:	f0 1f 00 07 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000271a:	0f 98       	ld.ub	r8,r7[0x1]
8000271c:	1a d8       	st.w	--sp,r8
8000271e:	48 8c       	lddpc	r12,8000273c <dcm_brdcst_func+0x44>
80002720:	f0 1f 00 04 	mcall	80002730 <dcm_brdcst_func+0x38>
80002724:	2f dd       	sub	sp,-12
	
	
}
80002726:	e3 cd 80 80 	ldm	sp++,r7,pc
8000272a:	00 00       	add	r0,r0
8000272c:	80 01       	ld.sh	r1,r0[0x0]
8000272e:	08 90       	mov	r0,r4
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	9f 8c       	st.w	pc[0x20],r12
80002734:	80 01       	ld.sh	r1,r0[0x0]
80002736:	08 a4       	st.w	r4++,r4
80002738:	80 01       	ld.sh	r1,r0[0x0]
8000273a:	08 b8       	st.h	r4++,r8
8000273c:	80 01       	ld.sh	r1,r0[0x0]
8000273e:	08 d0       	st.w	--r4,r0

80002740 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002740:	eb cd 40 80 	pushm	r7,lr
80002744:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002746:	19 a9       	ld.ub	r9,r12[0x2]
80002748:	30 08       	mov	r8,0
8000274a:	f0 09 18 00 	cp.b	r9,r8
8000274e:	c1 b1       	brne	80002784 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002750:	19 b8       	ld.ub	r8,r12[0x3]
80002752:	30 19       	mov	r9,1
80002754:	f2 08 18 00 	cp.b	r8,r9
80002758:	c0 51       	brne	80002762 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000275a:	48 ec       	lddpc	r12,80002790 <dcm_reply_func+0x50>
8000275c:	f0 1f 00 0e 	mcall	80002794 <dcm_reply_func+0x54>
80002760:	c0 a8       	rjmp	80002774 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002762:	58 08       	cp.w	r8,0
80002764:	c0 51       	brne	8000276e <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002766:	48 dc       	lddpc	r12,80002798 <dcm_reply_func+0x58>
80002768:	f0 1f 00 0b 	mcall	80002794 <dcm_reply_func+0x54>
8000276c:	c0 48       	rjmp	80002774 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000276e:	48 cc       	lddpc	r12,8000279c <dcm_reply_func+0x5c>
80002770:	f0 1f 00 09 	mcall	80002794 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002774:	0f d8       	ld.ub	r8,r7[0x5]
80002776:	1a d8       	st.w	--sp,r8
80002778:	48 ac       	lddpc	r12,800027a0 <dcm_reply_func+0x60>
8000277a:	f0 1f 00 07 	mcall	80002794 <dcm_reply_func+0x54>
8000277e:	2f fd       	sub	sp,-4
80002780:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002784:	48 8c       	lddpc	r12,800027a4 <dcm_reply_func+0x64>
80002786:	f0 1f 00 04 	mcall	80002794 <dcm_reply_func+0x54>
8000278a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000278e:	00 00       	add	r0,r0
80002790:	80 01       	ld.sh	r1,r0[0x0]
80002792:	08 ec       	st.h	--r4,r12
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	9f 8c       	st.w	pc[0x20],r12
80002798:	80 01       	ld.sh	r1,r0[0x0]
8000279a:	09 00       	ld.w	r0,r4++
8000279c:	80 01       	ld.sh	r1,r0[0x0]
8000279e:	09 14       	ld.sh	r4,r4++
800027a0:	80 01       	ld.sh	r1,r0[0x0]
800027a2:	09 28       	ld.uh	r8,r4++
800027a4:	80 01       	ld.sh	r1,r0[0x0]
800027a6:	09 34       	ld.ub	r4,r4++

800027a8 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027a8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027aa:	19 a9       	ld.ub	r9,r12[0x2]
800027ac:	30 08       	mov	r8,0
800027ae:	f0 09 18 00 	cp.b	r9,r8
800027b2:	c0 51       	brne	800027bc <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027b4:	48 4c       	lddpc	r12,800027c4 <ToneControl_reply_func+0x1c>
800027b6:	f0 1f 00 05 	mcall	800027c8 <ToneControl_reply_func+0x20>
800027ba:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027bc:	48 4c       	lddpc	r12,800027cc <ToneControl_reply_func+0x24>
800027be:	f0 1f 00 03 	mcall	800027c8 <ToneControl_reply_func+0x20>
800027c2:	d8 02       	popm	pc
800027c4:	80 01       	ld.sh	r1,r0[0x0]
800027c6:	09 40       	ld.w	r0,--r4
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	9f 8c       	st.w	pc[0x20],r12
800027cc:	80 01       	ld.sh	r1,r0[0x0]
800027ce:	09 48       	ld.w	r8,--r4

800027d0 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027d0:	d4 31       	pushm	r0-r7,lr
	
	static U8 * AMBE_payload_ptr = NULL;
	
	static U8 is_first = FALSE;
	
	 xLastWakeTime = xTaskGetTickCount();
800027d2:	f0 1f 00 39 	mcall	800028b4 <app_cfg+0xe4>
800027d6:	4b 98       	lddpc	r8,800028b8 <app_cfg+0xe8>
800027d8:	91 0c       	st.w	r8[0x0],r12
	 AMBE_payload_ptr = get_payload_idle_isr();
800027da:	4b 98       	lddpc	r8,800028bc <app_cfg+0xec>
800027dc:	70 0c       	ld.w	r12,r8[0x0]
800027de:	f0 1f 00 39 	mcall	800028c0 <app_cfg+0xf0>
800027e2:	4b 98       	lddpc	r8,800028c4 <app_cfg+0xf4>
800027e4:	91 0c       	st.w	r8[0x0],r12
800027e6:	30 04       	mov	r4,0
		
	for(;;)
	{
		
		if((NULL== AMBE_payload_ptr))
800027e8:	10 97       	mov	r7,r8
		}
	 //AMBE_payload_ptr = get_payload_idle_isr();//
		
		
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027ea:	4b 86       	lddpc	r6,800028c8 <app_cfg+0xf8>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027ec:	4b 85       	lddpc	r5,800028cc <app_cfg+0xfc>
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
800027ee:	4b 92       	lddpc	r2,800028d0 <app_cfg+0x100>
800027f0:	4b 91       	lddpc	r1,800028d4 <app_cfg+0x104>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
800027f2:	4b a0       	lddpc	r0,800028d8 <app_cfg+0x108>
					
				}
				
				if (isAudioRouting > 6)
				{
					 if (is_first == FALSE)
800027f4:	4b a3       	lddpc	r3,800028dc <app_cfg+0x10c>
	 AMBE_payload_ptr = get_payload_idle_isr();
		
	for(;;)
	{
		
		if((NULL== AMBE_payload_ptr))
800027f6:	6e 08       	ld.w	r8,r7[0x0]
800027f8:	58 08       	cp.w	r8,0
800027fa:	c0 71       	brne	80002808 <app_cfg+0x38>
		{
			
			AMBE_payload_ptr = get_payload_idle_isr();
800027fc:	4b 09       	lddpc	r9,800028bc <app_cfg+0xec>
800027fe:	72 0c       	ld.w	r12,r9[0x0]
80002800:	f0 1f 00 30 	mcall	800028c0 <app_cfg+0xf0>
80002804:	8f 0c       	st.w	r7[0x0],r12
			
			if((NULL== AMBE_payload_ptr))
80002806:	c5 50       	breq	800028b0 <app_cfg+0xe0>
		}
	 //AMBE_payload_ptr = get_payload_idle_isr();//
		
		
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
80002808:	6c 08       	ld.w	r8,r6[0x0]
8000280a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000280e:	58 38       	cp.w	r8,3
80002810:	c4 a1       	brne	800028a4 <app_cfg+0xd4>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
80002812:	6a 08       	ld.w	r8,r5[0x0]
80002814:	58 08       	cp.w	r8,0
80002816:	c0 61       	brne	80002822 <app_cfg+0x52>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//3
80002818:	f0 1f 00 32 	mcall	800028e0 <app_cfg+0x110>
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
8000281c:	30 18       	mov	r8,1
8000281e:	8b 08       	st.w	r5[0x0],r8
80002820:	c1 88       	rjmp	80002850 <app_cfg+0x80>
				}
				else if(isAudioRouting == 1)
80002822:	58 18       	cp.w	r8,1
80002824:	c0 61       	brne	80002830 <app_cfg+0x60>
				{
					//xcmp_function_mic();
					//xcmp_data_session();
				   // xcmp_transmit_control();
					//xcmp_volume_control();
					xcmp_enter_enhanced_OB_mode();
80002826:	f0 1f 00 30 	mcall	800028e4 <app_cfg+0x114>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
8000282a:	30 28       	mov	r8,2
8000282c:	8b 08       	st.w	r5[0x0],r8
8000282e:	c1 18       	rjmp	80002850 <app_cfg+0x80>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
80002830:	58 28       	cp.w	r8,2
80002832:	c0 61       	brne	8000283e <app_cfg+0x6e>
				{
					
					//xcmp_volume_control();
					//xcmp_data_session();
					xcmp_audio_route_AMBE();
80002834:	f0 1f 00 2d 	mcall	800028e8 <app_cfg+0x118>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002838:	30 38       	mov	r8,3
8000283a:	8b 08       	st.w	r5[0x0],r8
8000283c:	c0 a8       	rjmp	80002850 <app_cfg+0x80>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000283e:	58 38       	cp.w	r8,3
80002840:	f9 b8 00 04 	moveq	r8,4
80002844:	eb f8 0a 00 	st.weq	r5[0x0],r8
					
				}
				else
				{
					isAudioRouting++;
80002848:	f7 b8 01 ff 	subne	r8,-1
8000284c:	eb f8 1a 00 	st.wne	r5[0x0],r8
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
80002850:	03 88       	ld.ub	r8,r1[0x0]
80002852:	1a d8       	st.w	--sp,r8
80002854:	04 9c       	mov	r12,r2
80002856:	f0 1f 00 26 	mcall	800028ec <app_cfg+0x11c>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
8000285a:	4a 69       	lddpc	r9,800028f0 <app_cfg+0x120>
8000285c:	13 88       	ld.ub	r8,r9[0x0]
8000285e:	1a d8       	st.w	--sp,r8
80002860:	00 9c       	mov	r12,r0
80002862:	f0 1f 00 23 	mcall	800028ec <app_cfg+0x11c>
				//log("\n\r VF_SN: %x \n\r",  VF_SN);
				//log("\n\r time: %d \n\r", tc_tick);
				
				if(isAudioRouting  == 6)
80002866:	2f ed       	sub	sp,-8
80002868:	6a 08       	ld.w	r8,r5[0x0]
8000286a:	58 68       	cp.w	r8,6
8000286c:	c0 31       	brne	80002872 <app_cfg+0xa2>
					
					//xcmp_audio_route_speaker();
					//xcmp_enter_device_control_mode();//3
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					xcmp_exit_device_control_mode();
8000286e:	f0 1f 00 22 	mcall	800028f4 <app_cfg+0x124>
					//log("\n\r time: %d \n\r", tc_tick); 
			
					
				}
				
				if (isAudioRouting > 6)
80002872:	6a 08       	ld.w	r8,r5[0x0]
80002874:	58 68       	cp.w	r8,6
80002876:	e0 88 00 17 	brls	800028a4 <app_cfg+0xd4>
				{
					 if (is_first == FALSE)
8000287a:	07 89       	ld.ub	r9,r3[0x0]
8000287c:	30 08       	mov	r8,0
8000287e:	f0 09 18 00 	cp.b	r9,r8
80002882:	c0 61       	brne	8000288e <app_cfg+0xbe>
					 {
						 
						 payload_tx(AMBE_payload_ptr);//
80002884:	6e 0c       	ld.w	r12,r7[0x0]
80002886:	f0 1f 00 1d 	mcall	800028f8 <app_cfg+0x128>
						 is_first = TRUE;
8000288a:	30 18       	mov	r8,1
8000288c:	a6 88       	st.b	r3[0x0],r8
					 }
					 if (i>512)
					 {
						 i = 0;		 
					 }
					 log("\n\r AMBE_payload_ptr[%d] = %x", i, AMBE_payload_ptr[i]);
8000288e:	6e 08       	ld.w	r8,r7[0x0]
80002890:	f0 04 07 08 	ld.ub	r8,r8[r4]
80002894:	1a d8       	st.w	--sp,r8
80002896:	1a d4       	st.w	--sp,r4
80002898:	49 9c       	lddpc	r12,800028fc <app_cfg+0x12c>
8000289a:	f0 1f 00 15 	mcall	800028ec <app_cfg+0x11c>
					 i++;
8000289e:	2f f4       	sub	r4,-1
800028a0:	5c 54       	castu.b	r4
800028a2:	2f ed       	sub	sp,-8
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
800028a4:	e0 6b 0f a0 	mov	r11,4000
800028a8:	48 4c       	lddpc	r12,800028b8 <app_cfg+0xe8>
800028aa:	f0 1f 00 16 	mcall	80002900 <app_cfg+0x130>
	}
800028ae:	ca 4b       	rjmp	800027f6 <app_cfg+0x26>
800028b0:	d8 32       	popm	r0-r7,pc
800028b2:	00 00       	add	r0,r0
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	99 00       	st.w	r12[0x0],r0
800028b8:	00 00       	add	r0,r0
800028ba:	0a 54       	eor	r4,r5
800028bc:	00 00       	add	r0,r0
800028be:	10 1c       	sub	r12,r8
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	3d d0       	mov	r0,-35
800028c4:	00 00       	add	r0,r0
800028c6:	0a 48       	or	r8,r5
800028c8:	00 00       	add	r0,r0
800028ca:	13 58       	ld.sh	r8,--r9
800028cc:	00 00       	add	r0,r0
800028ce:	0a 50       	eor	r0,r5
800028d0:	80 01       	ld.sh	r1,r0[0x0]
800028d2:	09 54       	ld.sh	r4,--r4
800028d4:	00 00       	add	r0,r0
800028d6:	0a 4d       	or	sp,r5
800028d8:	80 01       	ld.sh	r1,r0[0x0]
800028da:	09 64       	ld.uh	r4,--r4
800028dc:	00 00       	add	r0,r0
800028de:	0a 59       	eor	r9,r5
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	51 ac       	stdsp	sp[0x68],r12
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	52 24       	stdsp	sp[0x88],r4
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	51 d8       	stdsp	sp[0x74],r8
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	9f 8c       	st.w	pc[0x20],r12
800028f0:	00 00       	add	r0,r0
800028f2:	0a 45       	or	r5,r5
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	51 7c       	stdsp	sp[0x5c],r12
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	43 94       	lddsp	r4,sp[0xe4]
800028fc:	80 01       	ld.sh	r1,r0[0x0]
800028fe:	09 78       	ld.ub	r8,--r4
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	9a 68       	ld.sh	r8,sp[0xc]

80002904 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002904:	eb cd 40 80 	pushm	r7,lr
80002908:	18 97       	mov	r7,r12
  log("R");
8000290a:	48 9c       	lddpc	r12,8000292c <app_payload_tx_proc+0x28>
8000290c:	f0 1f 00 09 	mcall	80002930 <app_payload_tx_proc+0x2c>
  
  //if (AMBE_flag)
  {
	  fl_read("AMBEvo.bit", FILE_BEGIN, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
80002910:	e0 69 02 00 	mov	r9,512
80002914:	0e 9a       	mov	r10,r7
80002916:	30 0b       	mov	r11,0
80002918:	48 7c       	lddpc	r12,80002934 <app_payload_tx_proc+0x30>
8000291a:	f0 1f 00 08 	mcall	80002938 <app_payload_tx_proc+0x34>
  //{
	  //fl_read("PCMvo.pcm", FILE_BEGIN, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
  //}
  
  
  set_payload_idle(payload);
8000291e:	48 88       	lddpc	r8,8000293c <app_payload_tx_proc+0x38>
80002920:	70 0c       	ld.w	r12,r8[0x0]
80002922:	0e 9b       	mov	r11,r7
80002924:	f0 1f 00 07 	mcall	80002940 <app_payload_tx_proc+0x3c>


}
80002928:	e3 cd 80 80 	ldm	sp++,r7,pc
8000292c:	80 01       	ld.sh	r1,r0[0x0]
8000292e:	09 98       	ld.ub	r8,r4[0x1]
80002930:	80 00       	ld.sh	r0,r0[0x0]
80002932:	9f 8c       	st.w	pc[0x20],r12
80002934:	80 01       	ld.sh	r1,r0[0x0]
80002936:	09 9c       	ld.ub	r12,r4[0x1]
80002938:	80 00       	ld.sh	r0,r0[0x0]
8000293a:	35 c4       	mov	r4,92
8000293c:	00 00       	add	r0,r0
8000293e:	10 1c       	sub	r12,r8
80002940:	80 00       	ld.sh	r0,r0[0x0]
80002942:	3d 7c       	mov	r12,-41

80002944 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002944:	eb cd 40 80 	pushm	r7,lr
80002948:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
8000294a:	49 0c       	lddpc	r12,80002988 <app_payload_rx_proc+0x44>
8000294c:	f0 1f 00 10 	mcall	8000298c <app_payload_rx_proc+0x48>
	if (AMBE_flag)
80002950:	49 08       	lddpc	r8,80002990 <app_payload_rx_proc+0x4c>
80002952:	11 89       	ld.ub	r9,r8[0x0]
80002954:	30 08       	mov	r8,0
80002956:	f0 09 18 00 	cp.b	r9,r8
8000295a:	c0 90       	breq	8000296c <app_payload_rx_proc+0x28>
	{
		fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
8000295c:	e0 69 02 00 	mov	r9,512
80002960:	0e 9a       	mov	r10,r7
80002962:	3f fb       	mov	r11,-1
80002964:	48 cc       	lddpc	r12,80002994 <app_payload_rx_proc+0x50>
80002966:	f0 1f 00 0d 	mcall	80002998 <app_payload_rx_proc+0x54>
8000296a:	c0 88       	rjmp	8000297a <app_payload_rx_proc+0x36>
	}
	else
	{
		fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
8000296c:	e0 69 02 00 	mov	r9,512
80002970:	0e 9a       	mov	r10,r7
80002972:	3f fb       	mov	r11,-1
80002974:	48 ac       	lddpc	r12,8000299c <app_payload_rx_proc+0x58>
80002976:	f0 1f 00 09 	mcall	80002998 <app_payload_rx_proc+0x54>
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000297a:	48 a8       	lddpc	r8,800029a0 <app_payload_rx_proc+0x5c>
8000297c:	70 0c       	ld.w	r12,r8[0x0]
8000297e:	0e 9b       	mov	r11,r7
80002980:	f0 1f 00 09 	mcall	800029a4 <app_payload_rx_proc+0x60>

}
80002984:	e3 cd 80 80 	ldm	sp++,r7,pc
80002988:	80 01       	ld.sh	r1,r0[0x0]
8000298a:	09 a8       	ld.ub	r8,r4[0x2]
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	9f 8c       	st.w	pc[0x20],r12
80002990:	00 00       	add	r0,r0
80002992:	0a 45       	or	r5,r5
80002994:	80 01       	ld.sh	r1,r0[0x0]
80002996:	09 9c       	ld.ub	r12,r4[0x1]
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	36 4c       	mov	r12,100
8000299c:	80 01       	ld.sh	r1,r0[0x0]
8000299e:	09 b4       	ld.ub	r4,r4[0x3]
800029a0:	00 00       	add	r0,r0
800029a2:	10 1c       	sub	r12,r8
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	3d 7c       	mov	r12,-41

800029a8 <DeviceInitializationStatus_brdcst_func>:
extern void payload_tx(void * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029a8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800029aa:	19 e8       	ld.ub	r8,r12[0x6]
800029ac:	30 19       	mov	r9,1
800029ae:	f2 08 18 00 	cp.b	r8,r9
800029b2:	c0 61       	brne	800029be <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029b4:	48 98       	lddpc	r8,800029d8 <DeviceInitializationStatus_brdcst_func+0x30>
800029b6:	70 09       	ld.w	r9,r8[0x0]
800029b8:	a1 a9       	sbr	r9,0x0
800029ba:	91 09       	st.w	r8[0x0],r9
800029bc:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029be:	30 29       	mov	r9,2
800029c0:	f2 08 18 00 	cp.b	r8,r9
800029c4:	c0 80       	breq	800029d4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029c6:	48 58       	lddpc	r8,800029d8 <DeviceInitializationStatus_brdcst_func+0x30>
800029c8:	70 09       	ld.w	r9,r8[0x0]
800029ca:	e0 19 ff fc 	andl	r9,0xfffc
800029ce:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029d0:	f0 1f 00 03 	mcall	800029dc <DeviceInitializationStatus_brdcst_func+0x34>
800029d4:	d8 02       	popm	pc
800029d6:	00 00       	add	r0,r0
800029d8:	00 00       	add	r0,r0
800029da:	13 58       	ld.sh	r8,--r9
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	52 48       	stdsp	sp[0x90],r8

800029e0 <SD_SPI_SetSpeed>:
	
}


void SD_SPI_SetSpeed(uint16_t SPI_BaudRatePrescaler)
{
800029e0:	d4 01       	pushm	lr
 

	spi->csr0 = (spi->csr0 & (uint16_t)0x00FF) |SPI_BaudRatePrescaler;
800029e2:	48 78       	lddpc	r8,800029fc <SD_SPI_SetSpeed+0x1c>
800029e4:	70 09       	ld.w	r9,r8[0x0]
800029e6:	72 ca       	ld.w	r10,r9[0x30]
800029e8:	5c 7c       	castu.h	r12
800029ea:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800029ee:	f9 ea 10 0a 	or	r10,r12,r10
800029f2:	93 ca       	st.w	r9[0x30],r10


 
    spi_enable(spi); /*!< SD_SPI enable */
800029f4:	70 0c       	ld.w	r12,r8[0x0]
800029f6:	f0 1f 00 03 	mcall	80002a00 <SD_SPI_SetSpeed+0x20>
	
 
}
800029fa:	d8 02       	popm	pc
800029fc:	00 00       	add	r0,r0
800029fe:	13 5c       	ld.sh	r12,--r9
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	5f ac       	srle	r12

80002a04 <SD_SPI_SetSpeedHi>:

	
}

void SD_SPI_SetSpeedHi(void)
{
80002a04:	d4 01       	pushm	lr

	SD_SPI_SetSpeed(0x0100);//baudDiv=1
80002a06:	e0 6c 01 00 	mov	r12,256
80002a0a:	f0 1f 00 02 	mcall	80002a10 <SD_SPI_SetSpeedHi+0xc>

}
80002a0e:	d8 02       	popm	pc
80002a10:	80 00       	ld.sh	r0,r0[0x0]
80002a12:	29 e0       	sub	r0,-98

80002a14 <SD_SPI_SetSpeedLow>:
	
 
}

void SD_SPI_SetSpeedLow(void)
{
80002a14:	d4 01       	pushm	lr


	SD_SPI_SetSpeed(0xFF00);//baudDiv=255
80002a16:	e0 6c ff 00 	mov	r12,65280
80002a1a:	f0 1f 00 02 	mcall	80002a20 <SD_SPI_SetSpeedLow+0xc>


	
}
80002a1e:	d8 02       	popm	pc
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	29 e0       	sub	r0,-98

80002a24 <SD_LowLevel_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
void SD_LowLevel_Init(void)
{
80002a24:	eb cd 40 c0 	pushm	r6-r7,lr
80002a28:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80002a2a:	49 58       	lddpc	r8,80002a7c <SD_LowLevel_Init+0x58>
80002a2c:	1a 96       	mov	r6,sp
80002a2e:	f0 ea 00 00 	ld.d	r10,r8[0]
80002a32:	fa eb 00 00 	st.d	sp[0],r10
80002a36:	f0 e8 00 08 	ld.d	r8,r8[8]
80002a3a:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_SPI_GPIO_MAP, sizeof(SD_SPI_GPIO_MAP) / sizeof(SD_SPI_GPIO_MAP[0]));
80002a3e:	30 4b       	mov	r11,4
80002a40:	49 0c       	lddpc	r12,80002a80 <SD_LowLevel_Init+0x5c>
80002a42:	f0 1f 00 11 	mcall	80002a84 <SD_LowLevel_Init+0x60>

	spi = &AVR32_SPI;
80002a46:	49 17       	lddpc	r7,80002a88 <SD_LowLevel_Init+0x64>
80002a48:	fe 7c 24 00 	mov	r12,-56320
80002a4c:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002a4e:	1a 9b       	mov	r11,sp
80002a50:	f0 1f 00 0f 	mcall	80002a8c <SD_LowLevel_Init+0x68>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002a54:	30 09       	mov	r9,0
80002a56:	12 9a       	mov	r10,r9
80002a58:	12 9b       	mov	r11,r9
80002a5a:	6e 0c       	ld.w	r12,r7[0x0]
80002a5c:	f0 1f 00 0d 	mcall	80002a90 <SD_LowLevel_Init+0x6c>

	// Enable SPI.
	spi_enable(spi);
80002a60:	6e 0c       	ld.w	r12,r7[0x0]
80002a62:	f0 1f 00 0d 	mcall	80002a94 <SD_LowLevel_Init+0x70>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, SPI_Clock_PBA) != SPI_OK)
80002a66:	e0 6a 36 00 	mov	r10,13824
80002a6a:	ea 1a 01 6e 	orh	r10,0x16e
80002a6e:	1a 9b       	mov	r11,sp
80002a70:	6e 0c       	ld.w	r12,r7[0x0]
80002a72:	f0 1f 00 0a 	mcall	80002a98 <SD_LowLevel_Init+0x74>
	return;
	}


	
}
80002a76:	2f cd       	sub	sp,-16
80002a78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a7c:	80 01       	ld.sh	r1,r0[0x0]
80002a7e:	09 d4       	ld.ub	r4,r4[0x5]
80002a80:	80 01       	ld.sh	r1,r0[0x0]
80002a82:	09 e4       	ld.ub	r4,r4[0x6]
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	a4 2c       	st.h	r2[0x4],r12
80002a88:	00 00       	add	r0,r0
80002a8a:	13 5c       	ld.sh	r12,--r9
80002a8c:	80 00       	ld.sh	r0,r0[0x0]
80002a8e:	5e 14       	retne	r4
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	5e 4c       	retge	r12
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	5f ac       	srle	r12
80002a98:	80 00       	ld.sh	r0,r0[0x0]
80002a9a:	5e ea       	retqs	r10

80002a9c <SD_ReadByte>:
  * @   SD
  * @    
  * @  The received byte
***------------------------------------------------------*/  
uint8_t SD_ReadByte(void)
{
80002a9c:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned short *Data ;

  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002aa0:	48 b7       	lddpc	r7,80002acc <SD_ReadByte+0x30>
80002aa2:	30 0b       	mov	r11,0
80002aa4:	6e 0c       	ld.w	r12,r7[0x0]
80002aa6:	f0 1f 00 0b 	mcall	80002ad0 <SD_ReadByte+0x34>
  
  /*!< Send the byte */

  spi_write(spi,  SD_DUMMY_BYTE);
80002aaa:	e0 6b 00 ff 	mov	r11,255
80002aae:	6e 0c       	ld.w	r12,r7[0x0]
80002ab0:	f0 1f 00 09 	mcall	80002ad4 <SD_ReadByte+0x38>
  
  /*!< Return the byte read from the SPI bus */ 

   spi_read(spi, Data);
80002ab4:	30 06       	mov	r6,0
80002ab6:	0c 9b       	mov	r11,r6
80002ab8:	6e 0c       	ld.w	r12,r7[0x0]
80002aba:	f0 1f 00 08 	mcall	80002ad8 <SD_ReadByte+0x3c>

  /*!< Return the shifted data */
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002abe:	0c 9b       	mov	r11,r6
80002ac0:	6e 0c       	ld.w	r12,r7[0x0]
80002ac2:	f0 1f 00 07 	mcall	80002adc <SD_ReadByte+0x40>
  
  return (uint8_t)(*Data);//
}
80002ac6:	0d 9c       	ld.ub	r12,r6[0x1]
80002ac8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002acc:	00 00       	add	r0,r0
80002ace:	13 5c       	ld.sh	r12,--r9
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	5e 78       	retpl	r8
80002ad4:	80 00       	ld.sh	r0,r0[0x0]
80002ad6:	5f b2       	srhi	r2
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	5f ce       	srvs	lr
80002adc:	80 00       	ld.sh	r0,r0[0x0]
80002ade:	5e c4       	retvs	r4

80002ae0 <SD_GetResponse>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetResponse(uint8_t Response)
{
80002ae0:	eb cd 40 c0 	pushm	r6-r7,lr
80002ae4:	18 96       	mov	r6,r12
80002ae6:	e0 67 8f ff 	mov	r7,36863
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002aea:	c0 28       	rjmp	80002aee <SD_GetResponse+0xe>
  {
    Count--;
80002aec:	20 17       	sub	r7,1
SD_Error SD_GetResponse(uint8_t Response)
{
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002aee:	f0 1f 00 09 	mcall	80002b10 <SD_GetResponse+0x30>
80002af2:	ec 0c 18 00 	cp.b	r12,r6
80002af6:	c0 40       	breq	80002afe <SD_GetResponse+0x1e>
80002af8:	58 07       	cp.w	r7,0
80002afa:	cf 91       	brne	80002aec <SD_GetResponse+0xc>
80002afc:	c0 58       	rjmp	80002b06 <SD_GetResponse+0x26>
  {
    Count--;
  }
  if (Count == 0)
80002afe:	58 07       	cp.w	r7,0
80002b00:	c0 30       	breq	80002b06 <SD_GetResponse+0x26>
80002b02:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80002b06:	e0 6c 00 ff 	mov	r12,255
  else
  {
    /*!< Right response got */
    return SD_RESPONSE_NO_ERROR;
  }
}
80002b0a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b0e:	00 00       	add	r0,r0
80002b10:	80 00       	ld.sh	r0,r0[0x0]
80002b12:	2a 9c       	sub	r12,-87

80002b14 <SD_GetDataResponse>:
  *         - status 101: Data rejected due to a crc error
  *         - status 110: Data rejected due to a Write error.
  *         - status 111: Data rejected due to other error.
  */
uint8_t SD_GetDataResponse(void)
{
80002b14:	eb cd 40 f8 	pushm	r3-r7,lr
80002b18:	30 06       	mov	r6,0
  {
    /*!< Read resonse */
    response = SD_ReadByte();
    /*!< Mask unused bits */
    response &= 0x1F;
    switch (response)
80002b1a:	30 b5       	mov	r5,11
80002b1c:	30 d4       	mov	r4,13
80002b1e:	30 53       	mov	r3,5
  uint8_t response, rvalue;

  while (i <= 64)
  {
    /*!< Read resonse */
    response = SD_ReadByte();
80002b20:	f0 1f 00 0c 	mcall	80002b50 <SD_GetDataResponse+0x3c>
    /*!< Mask unused bits */
    response &= 0x1F;
80002b24:	ef dc c0 05 	bfextu	r7,r12,0x0,0x5
    switch (response)
80002b28:	ea 07 18 00 	cp.b	r7,r5
80002b2c:	c0 e0       	breq	80002b48 <SD_GetDataResponse+0x34>
80002b2e:	e8 07 18 00 	cp.b	r7,r4
80002b32:	c0 b0       	breq	80002b48 <SD_GetDataResponse+0x34>
80002b34:	e6 07 18 00 	cp.b	r7,r3
80002b38:	c0 50       	breq	80002b42 <SD_GetDataResponse+0x2e>
    }
    /*!< Exit loop in case of data ok */
    if (rvalue == SD_DATA_OK)
      break;
    /*!< Increment loop counter */
    i++;
80002b3a:	2f f6       	sub	r6,-1
uint8_t SD_GetDataResponse(void)
{
  uint32_t i = 0;
  uint8_t response, rvalue;

  while (i <= 64)
80002b3c:	e0 46 00 41 	cp.w	r6,65
80002b40:	cf 01       	brne	80002b20 <SD_GetDataResponse+0xc>
    /*!< Increment loop counter */
    i++;
  }

  /*!< Wait null data */
  while (SD_ReadByte() == 0);
80002b42:	f0 1f 00 04 	mcall	80002b50 <SD_GetDataResponse+0x3c>
80002b46:	cf e0       	breq	80002b42 <SD_GetDataResponse+0x2e>

  /*!< Return response */
  return response;
}
80002b48:	0e 9c       	mov	r12,r7
80002b4a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002b4e:	00 00       	add	r0,r0
80002b50:	80 00       	ld.sh	r0,r0[0x0]
80002b52:	2a 9c       	sub	r12,-87

80002b54 <SD_WriteByte>:
  * @brief  Write a byte on the SD.
  * @param  Data: byte to send.
  * @retval None
  */
uint8_t SD_WriteByte(uint8_t Data)
{
80002b54:	eb cd 40 c0 	pushm	r6-r7,lr
80002b58:	20 1d       	sub	sp,4
80002b5a:	ba 8c       	st.b	sp[0x0],r12
  uint8_t temp;
  
  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002b5c:	48 c7       	lddpc	r7,80002b8c <SD_WriteByte+0x38>
80002b5e:	30 0b       	mov	r11,0
80002b60:	6e 0c       	ld.w	r12,r7[0x0]
80002b62:	f0 1f 00 0c 	mcall	80002b90 <SD_WriteByte+0x3c>
  
  /*!< Send the byte */
  spi_write(spi,  (U16)Data);
80002b66:	1b 8b       	ld.ub	r11,sp[0x0]
80002b68:	6e 0c       	ld.w	r12,r7[0x0]
80002b6a:	f0 1f 00 0b 	mcall	80002b94 <SD_WriteByte+0x40>
  

  /*!< Wait to receive a byte*/

  temp = spi_read(spi, (U16*)&Data);
80002b6e:	1a 9b       	mov	r11,sp
80002b70:	6e 0c       	ld.w	r12,r7[0x0]
80002b72:	f0 1f 00 0a 	mcall	80002b98 <SD_WriteByte+0x44>
80002b76:	18 96       	mov	r6,r12
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002b78:	30 0b       	mov	r11,0
80002b7a:	6e 0c       	ld.w	r12,r7[0x0]
80002b7c:	f0 1f 00 08 	mcall	80002b9c <SD_WriteByte+0x48>
  
  /*!< Return the byte read from the SPI bus */ 
  return  temp;
    
}
80002b80:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80002b84:	2f fd       	sub	sp,-4
80002b86:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b8a:	00 00       	add	r0,r0
80002b8c:	00 00       	add	r0,r0
80002b8e:	13 5c       	ld.sh	r12,--r9
80002b90:	80 00       	ld.sh	r0,r0[0x0]
80002b92:	5e 78       	retpl	r8
80002b94:	80 00       	ld.sh	r0,r0[0x0]
80002b96:	5f b2       	srhi	r2
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	5f ce       	srvs	lr
80002b9c:	80 00       	ld.sh	r0,r0[0x0]
80002b9e:	5e c4       	retvs	r4

80002ba0 <SD_SendCmd>:
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
{
80002ba0:	eb cd 40 c0 	pushm	r6-r7,lr
80002ba4:	20 2d       	sub	sp,8
  uint32_t i = 0x00;
  
  uint8_t Frame[6];

  Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
80002ba6:	a7 ac       	sbr	r12,0x6
80002ba8:	ba 8c       	st.b	sp[0x0],r12
  
  Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
80002baa:	f6 08 16 18 	lsr	r8,r11,0x18
80002bae:	ba 98       	st.b	sp[0x1],r8
  
  Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
80002bb0:	f6 08 16 10 	lsr	r8,r11,0x10
80002bb4:	ba a8       	st.b	sp[0x2],r8
  
  Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
80002bb6:	f6 08 16 08 	lsr	r8,r11,0x8
80002bba:	ba b8       	st.b	sp[0x3],r8
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
80002bbc:	ba cb       	st.b	sp[0x4],r11
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
80002bbe:	ba da       	st.b	sp[0x5],r10
80002bc0:	1a 97       	mov	r7,sp
  * @param  Cmd: .
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
80002bc2:	fa c6 ff fa 	sub	r6,sp,-6
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
80002bc6:	0f 3c       	ld.ub	r12,r7++
80002bc8:	f0 1f 00 04 	mcall	80002bd8 <SD_SendCmd+0x38>
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
80002bcc:	0c 37       	cp.w	r7,r6
80002bce:	cf c1       	brne	80002bc6 <SD_SendCmd+0x26>
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */

  }
}
80002bd0:	2f ed       	sub	sp,-8
80002bd2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002bd6:	00 00       	add	r0,r0
80002bd8:	80 00       	ld.sh	r0,r0[0x0]
80002bda:	2b 54       	sub	r4,-75

80002bdc <SD_GoIdleState>:
  * @   SD
  * @    
  * @  
***------------------------------------------------------*/
SD_Error SD_GoIdleState(void)
{
80002bdc:	d4 31       	pushm	r0-r7,lr
  uint8_t r1;
  SD_Error Status = SD_RESPONSE_NO_ERROR;
  uint16_t n2,n;

  /* CS */
  SD_CS_LOW();
80002bde:	31 8c       	mov	r12,24
80002be0:	f0 1f 00 6a 	mcall	80002d88 <SD_GoIdleState+0x1ac>
  
  /* CM0SDSPI */
  SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
80002be4:	e0 6a 00 95 	mov	r10,149
80002be8:	30 0b       	mov	r11,0
80002bea:	16 9c       	mov	r12,r11
80002bec:	f0 1f 00 68 	mcall	80002d8c <SD_GoIdleState+0x1b0>
  
  /* 0x01 */
  if (SD_GetResponse  (SD_IN_IDLE_STATE))
80002bf0:	30 1c       	mov	r12,1
80002bf2:	f0 1f 00 68 	mcall	80002d90 <SD_GoIdleState+0x1b4>
80002bf6:	e0 81 00 a8 	brne	80002d46 <SD_GoIdleState+0x16a>
    return SD_RESPONSE_FAILURE;
  }

  
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);
80002bfa:	e0 6a 00 87 	mov	r10,135
80002bfe:	e0 6b 01 aa 	mov	r11,426
80002c02:	30 8c       	mov	r12,8
80002c04:	f0 1f 00 62 	mcall	80002d8c <SD_GoIdleState+0x1b0>
80002c08:	e0 67 00 c8 	mov	r7,200

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002c0c:	3f f6       	mov	r6,-1
80002c0e:	c0 38       	rjmp	80002c14 <SD_GoIdleState+0x38>
  {
    TimeOut--;
80002c10:	20 17       	sub	r7,1
80002c12:	5c 87       	casts.h	r7
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002c14:	f0 1f 00 60 	mcall	80002d94 <SD_GoIdleState+0x1b8>
80002c18:	ec 0c 18 00 	cp.b	r12,r6
80002c1c:	c0 41       	brne	80002c24 <SD_GoIdleState+0x48>
80002c1e:	58 07       	cp.w	r7,0
80002c20:	cf 81       	brne	80002c10 <SD_GoIdleState+0x34>
80002c22:	c2 68       	rjmp	80002c6e <SD_GoIdleState+0x92>
  {
    TimeOut--;
  }

  if(r1 == 0x05) 
80002c24:	30 58       	mov	r8,5
80002c26:	f0 0c 18 00 	cp.b	r12,r8
80002c2a:	c2 21       	brne	80002c6e <SD_GoIdleState+0x92>
80002c2c:	c9 48       	rjmp	80002d54 <SD_GoIdleState+0x178>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002c2e:	08 9c       	mov	r12,r4
80002c30:	f0 1f 00 5a 	mcall	80002d98 <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002c34:	06 9c       	mov	r12,r3
80002c36:	f0 1f 00 5a 	mcall	80002d9c <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002c3a:	08 9c       	mov	r12,r4
80002c3c:	f0 1f 00 53 	mcall	80002d88 <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002c40:	06 9a       	mov	r10,r3
80002c42:	0a 9b       	mov	r11,r5
80002c44:	02 9c       	mov	r12,r1
80002c46:	f0 1f 00 52 	mcall	80002d8c <SD_GoIdleState+0x1b0>
      /* error Response0x00 */
      TimeOut++;
80002c4a:	2f f6       	sub	r6,-1
80002c4c:	5c 86       	casts.h	r6
    
      if(TimeOut == 0x00F0)
80002c4e:	e4 06 19 00 	cp.h	r6,r2
80002c52:	c0 60       	breq	80002c5e <SD_GoIdleState+0x82>
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002c54:	0a 9c       	mov	r12,r5
80002c56:	f0 1f 00 4f 	mcall	80002d90 <SD_GoIdleState+0x1b4>
80002c5a:	18 97       	mov	r7,r12
    }
    while (Status);
80002c5c:	ce 91       	brne	80002c2e <SD_GoIdleState+0x52>
    
    /* CS */
    SD_CS_HIGH();
80002c5e:	31 8c       	mov	r12,24
80002c60:	f0 1f 00 4e 	mcall	80002d98 <SD_GoIdleState+0x1bc>
    
    /*dummy byte 0xFF */
    SD_WriteByte(SD_DUMMY_BYTE);    
80002c64:	e0 6c 00 ff 	mov	r12,255
80002c68:	f0 1f 00 4d 	mcall	80002d9c <SD_GoIdleState+0x1c0>
80002c6c:	c6 f8       	rjmp	80002d4a <SD_GoIdleState+0x16e>
    r1 = 1;

    /* SD5 */
    for(n=0; n<5; n++)
    {
      SD_ReadByte();
80002c6e:	f0 1f 00 4a 	mcall	80002d94 <SD_GoIdleState+0x1b8>
80002c72:	f0 1f 00 49 	mcall	80002d94 <SD_GoIdleState+0x1b8>
80002c76:	f0 1f 00 48 	mcall	80002d94 <SD_GoIdleState+0x1b8>
80002c7a:	f0 1f 00 47 	mcall	80002d94 <SD_GoIdleState+0x1b8>
80002c7e:	f0 1f 00 46 	mcall	80002d94 <SD_GoIdleState+0x1b8>
    }
  
    /* CS */
    SD_CS_HIGH();
80002c82:	31 8c       	mov	r12,24
80002c84:	f0 1f 00 45 	mcall	80002d98 <SD_GoIdleState+0x1bc>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c88:	e0 6c 00 ff 	mov	r12,255
80002c8c:	f0 1f 00 44 	mcall	80002d9c <SD_GoIdleState+0x1c0>
    /* CS */
    SD_CS_LOW();
80002c90:	31 8c       	mov	r12,24
80002c92:	f0 1f 00 3e 	mcall	80002d88 <SD_GoIdleState+0x1ac>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c96:	e0 6c 00 ff 	mov	r12,255
80002c9a:	f0 1f 00 41 	mcall	80002d9c <SD_GoIdleState+0x1c0>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c9e:	e0 6c 00 ff 	mov	r12,255
80002ca2:	f0 1f 00 3f 	mcall	80002d9c <SD_GoIdleState+0x1c0>
80002ca6:	e0 64 00 ff 	mov	r4,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002caa:	08 91       	mov	r1,r4
80002cac:	30 02       	mov	r2,0
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
       if(r1 !=1)
80002cae:	30 15       	mov	r5,1
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002cb0:	30 83       	mov	r3,8

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002cb2:	e0 66 00 ff 	mov	r6,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002cb6:	02 9a       	mov	r10,r1
80002cb8:	04 9b       	mov	r11,r2
80002cba:	33 7c       	mov	r12,55
80002cbc:	f0 1f 00 34 	mcall	80002d8c <SD_GoIdleState+0x1b0>
80002cc0:	04 97       	mov	r7,r2
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
80002cc2:	f0 1f 00 35 	mcall	80002d94 <SD_GoIdleState+0x1b8>
       if(r1 !=1)
80002cc6:	f8 05 18 00 	cp.b	r5,r12
80002cca:	f9 b4 01 00 	movne	r4,0
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002cce:	2f f7       	sub	r7,-1
80002cd0:	5c 87       	casts.h	r7
80002cd2:	e6 07 19 00 	cp.h	r7,r3
80002cd6:	cf 61       	brne	80002cc2 <SD_GoIdleState+0xe6>
80002cd8:	08 90       	mov	r0,r4
80002cda:	5c 80       	casts.h	r0
		   n=0;
	   }

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
80002cdc:	04 9a       	mov	r10,r2
80002cde:	fc 1b 40 00 	movh	r11,0x4000
80002ce2:	32 9c       	mov	r12,41
80002ce4:	f0 1f 00 2a 	mcall	80002d8c <SD_GoIdleState+0x1b0>
80002ce8:	04 97       	mov	r7,r2
  
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
80002cea:	f0 1f 00 2b 	mcall	80002d94 <SD_GoIdleState+0x1b8>
       if(r1 ==0)break;
80002cee:	c3 00       	breq	80002d4e <SD_GoIdleState+0x172>

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002cf0:	2f f7       	sub	r7,-1
80002cf2:	5c 87       	casts.h	r7
80002cf4:	ec 07 19 00 	cp.h	r7,r6
80002cf8:	cf 91       	brne	80002cea <SD_GoIdleState+0x10e>
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002cfa:	e0 c4 00 01 	sub	r4,r0,1
80002cfe:	5c 84       	casts.h	r4
    }while((r1!=0)&&(n>0));
80002d00:	30 08       	mov	r8,0
80002d02:	f0 0c 18 00 	cp.b	r12,r8
80002d06:	5f 1a       	srne	r10
80002d08:	30 09       	mov	r9,0
80002d0a:	f2 04 19 00 	cp.h	r4,r9
80002d0e:	5f 19       	srne	r9
80002d10:	f5 e9 00 09 	and	r9,r10,r9
80002d14:	f0 09 18 00 	cp.b	r9,r8
80002d18:	cc f1       	brne	80002cb6 <SD_GoIdleState+0xda>

    if(n==0)
80002d1a:	58 04       	cp.w	r4,0
80002d1c:	c1 50       	breq	80002d46 <SD_GoIdleState+0x16a>
      //printf("\r\n SDHC\n");
    }
    else
    {
	  /* CMD58 */
      SD_SendCmd(58, 0, 0);
80002d1e:	30 0a       	mov	r10,0
80002d20:	14 9b       	mov	r11,r10
80002d22:	33 ac       	mov	r12,58
80002d24:	f0 1f 00 1a 	mcall	80002d8c <SD_GoIdleState+0x1b0>
      for(n=0;n<5;n++)
      {
      r1 = SD_ReadByte();
80002d28:	f0 1f 00 1b 	mcall	80002d94 <SD_GoIdleState+0x1b8>
80002d2c:	f0 1f 00 1a 	mcall	80002d94 <SD_GoIdleState+0x1b8>
80002d30:	f0 1f 00 19 	mcall	80002d94 <SD_GoIdleState+0x1b8>
80002d34:	f0 1f 00 18 	mcall	80002d94 <SD_GoIdleState+0x1b8>
80002d38:	f0 1f 00 17 	mcall	80002d94 <SD_GoIdleState+0x1b8>
      }
	  flag_SDHC = 1;
80002d3c:	30 19       	mov	r9,1
80002d3e:	49 98       	lddpc	r8,80002da0 <SD_GoIdleState+0x1c4>
80002d40:	b0 89       	st.b	r8[0x0],r9
80002d42:	30 07       	mov	r7,0
80002d44:	c0 38       	rjmp	80002d4a <SD_GoIdleState+0x16e>
80002d46:	e0 67 00 ff 	mov	r7,255
    //printf("\n\r SD cards inint Done.");
  }  
  */
    
  return Status;
}
80002d4a:	0e 9c       	mov	r12,r7
80002d4c:	d8 32       	popm	r0-r7,pc
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002d4e:	20 14       	sub	r4,1
80002d50:	5c 84       	casts.h	r4
80002d52:	ce 4b       	rjmp	80002d1a <SD_GoIdleState+0x13e>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002d54:	31 8c       	mov	r12,24
80002d56:	f0 1f 00 11 	mcall	80002d98 <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002d5a:	e0 6c 00 ff 	mov	r12,255
80002d5e:	f0 1f 00 10 	mcall	80002d9c <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002d62:	31 8c       	mov	r12,24
80002d64:	f0 1f 00 09 	mcall	80002d88 <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002d68:	e0 6a 00 ff 	mov	r10,255
80002d6c:	30 0b       	mov	r11,0
80002d6e:	30 1c       	mov	r12,1
80002d70:	f0 1f 00 07 	mcall	80002d8c <SD_GoIdleState+0x1b0>
80002d74:	30 16       	mov	r6,1
      if(TimeOut == 0x00F0)
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002d76:	30 05       	mov	r5,0
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002d78:	31 84       	mov	r4,24
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002d7a:	e0 63 00 ff 	mov	r3,255
      
      /* CS */
      SD_CS_LOW();
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002d7e:	0c 91       	mov	r1,r6
      /* error Response0x00 */
      TimeOut++;
    
      if(TimeOut == 0x00F0)
80002d80:	e0 62 00 f0 	mov	r2,240
80002d84:	c6 8b       	rjmp	80002c54 <SD_GoIdleState+0x78>
80002d86:	00 00       	add	r0,r0
80002d88:	80 00       	ld.sh	r0,r0[0x0]
80002d8a:	a4 78       	st.h	r2[0xe],r8
80002d8c:	80 00       	ld.sh	r0,r0[0x0]
80002d8e:	2b a0       	sub	r0,-70
80002d90:	80 00       	ld.sh	r0,r0[0x0]
80002d92:	2a e0       	sub	r0,-82
80002d94:	80 00       	ld.sh	r0,r0[0x0]
80002d96:	2a 9c       	sub	r12,-87
80002d98:	80 00       	ld.sh	r0,r0[0x0]
80002d9a:	a4 5c       	st.h	r2[0xa],r12
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	2b 54       	sub	r4,-75
80002da0:	00 00       	add	r0,r0
80002da2:	0a 6c       	and	r12,r5

80002da4 <SD_GetCIDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
{
80002da4:	eb cd 40 e0 	pushm	r5-r7,lr
80002da8:	20 4d       	sub	sp,16
80002daa:	18 97       	mov	r7,r12
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  uint8_t CID_Tab[16];
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002dac:	31 8c       	mov	r12,24
80002dae:	f0 1f 00 44 	mcall	80002ebc <SD_GetCIDRegister+0x118>
  
  /*!< Send CMD10 (CID register) */
  SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
80002db2:	e0 6a 00 ff 	mov	r10,255
80002db6:	30 0b       	mov	r11,0
80002db8:	30 ac       	mov	r12,10
80002dba:	f0 1f 00 42 	mcall	80002ec0 <SD_GetCIDRegister+0x11c>
  
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002dbe:	30 0c       	mov	r12,0
80002dc0:	f0 1f 00 41 	mcall	80002ec4 <SD_GetCIDRegister+0x120>
80002dc4:	c0 40       	breq	80002dcc <SD_GetCIDRegister+0x28>
80002dc6:	e0 66 00 ff 	mov	r6,255
80002dca:	c1 78       	rjmp	80002df8 <SD_GetCIDRegister+0x54>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80002dcc:	e0 6c 00 fe 	mov	r12,254
80002dd0:	f0 1f 00 3d 	mcall	80002ec4 <SD_GetCIDRegister+0x120>
80002dd4:	c0 91       	brne	80002de6 <SD_GetCIDRegister+0x42>
80002dd6:	1a 96       	mov	r6,sp
  * @param  SD_cid: pointer on an CID register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
80002dd8:	fa c5 ff f0 	sub	r5,sp,-16
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
      {
        CID_Tab[i] = SD_ReadByte();
80002ddc:	f0 1f 00 3b 	mcall	80002ec8 <SD_GetCIDRegister+0x124>
80002de0:	0c cc       	st.b	r6++,r12
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
80002de2:	0a 36       	cp.w	r6,r5
80002de4:	cf c1       	brne	80002ddc <SD_GetCIDRegister+0x38>
      {
        CID_Tab[i] = SD_ReadByte();
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
80002de6:	e0 6c 00 ff 	mov	r12,255
80002dea:	f0 1f 00 39 	mcall	80002ecc <SD_GetCIDRegister+0x128>
    SD_WriteByte(SD_DUMMY_BYTE);
80002dee:	e0 6c 00 ff 	mov	r12,255
80002df2:	f0 1f 00 37 	mcall	80002ecc <SD_GetCIDRegister+0x128>
80002df6:	30 06       	mov	r6,0
    /*!< Set response value to success */
    rvalue = SD_RESPONSE_NO_ERROR;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002df8:	31 8c       	mov	r12,24
80002dfa:	f0 1f 00 36 	mcall	80002ed0 <SD_GetCIDRegister+0x12c>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002dfe:	e0 6c 00 ff 	mov	r12,255
80002e02:	f0 1f 00 33 	mcall	80002ecc <SD_GetCIDRegister+0x128>

  /*!< Byte 0 */
  SD_cid->ManufacturerID = CID_Tab[0];
80002e06:	1b 88       	ld.ub	r8,sp[0x0]
80002e08:	ae 88       	st.b	r7[0x0],r8

  /*!< Byte 1 */
  SD_cid->OEM_AppliID = CID_Tab[1] << 8;
80002e0a:	fb 28 00 01 	ld.sb	r8,sp[1]
80002e0e:	a9 68       	lsl	r8,0x8
80002e10:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 2 */
  SD_cid->OEM_AppliID |= CID_Tab[2];
80002e12:	8e 19       	ld.sh	r9,r7[0x2]
80002e14:	1b a8       	ld.ub	r8,sp[0x2]
80002e16:	f3 e8 10 08 	or	r8,r9,r8
80002e1a:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 3 */
  SD_cid->ProdName1 = CID_Tab[3] << 24;
80002e1c:	1b b8       	ld.ub	r8,sp[0x3]
80002e1e:	b9 68       	lsl	r8,0x18
80002e20:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 4 */
  SD_cid->ProdName1 |= CID_Tab[4] << 16;
80002e22:	6e 18       	ld.w	r8,r7[0x4]
80002e24:	1b c9       	ld.ub	r9,sp[0x4]
80002e26:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002e2a:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 5 */
  SD_cid->ProdName1 |= CID_Tab[5] << 8;
80002e2c:	6e 18       	ld.w	r8,r7[0x4]
80002e2e:	1b d9       	ld.ub	r9,sp[0x5]
80002e30:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002e34:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 6 */
  SD_cid->ProdName1 |= CID_Tab[6];
80002e36:	6e 18       	ld.w	r8,r7[0x4]
80002e38:	1b e9       	ld.ub	r9,sp[0x6]
80002e3a:	f3 e8 10 08 	or	r8,r9,r8
80002e3e:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 7 */
  SD_cid->ProdName2 = CID_Tab[7];
80002e40:	1b f8       	ld.ub	r8,sp[0x7]
80002e42:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 8 */
  SD_cid->ProdRev = CID_Tab[8];
80002e46:	fb 38 00 08 	ld.ub	r8,sp[8]
80002e4a:	ef 68 00 09 	st.b	r7[9],r8

  /*!< Byte 9 */
  SD_cid->ProdSN = CID_Tab[9] << 24;
80002e4e:	fb 38 00 09 	ld.ub	r8,sp[9]
80002e52:	b9 68       	lsl	r8,0x18
80002e54:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 10 */
  SD_cid->ProdSN |= CID_Tab[10] << 16;
80002e56:	6e 38       	ld.w	r8,r7[0xc]
80002e58:	fb 39 00 0a 	ld.ub	r9,sp[10]
80002e5c:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002e60:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 11 */
  SD_cid->ProdSN |= CID_Tab[11] << 8;
80002e62:	6e 38       	ld.w	r8,r7[0xc]
80002e64:	fb 39 00 0b 	ld.ub	r9,sp[11]
80002e68:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002e6c:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 12 */
  SD_cid->ProdSN |= CID_Tab[12];
80002e6e:	6e 38       	ld.w	r8,r7[0xc]
80002e70:	fb 39 00 0c 	ld.ub	r9,sp[12]
80002e74:	f3 e8 10 08 	or	r8,r9,r8
80002e78:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 13 */
  SD_cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
80002e7a:	ef 39 00 10 	ld.ub	r9,r7[16]
80002e7e:	fb 38 00 0d 	ld.ub	r8,sp[13]
80002e82:	f3 e8 12 49 	or	r9,r9,r8>>0x4
80002e86:	ef 69 00 10 	st.b	r7[16],r9
  SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
80002e8a:	a9 68       	lsl	r8,0x8
80002e8c:	e2 18 0f 00 	andl	r8,0xf00,COH
80002e90:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 14 */
  SD_cid->ManufactDate |= CID_Tab[14];
80002e94:	ef 09 00 12 	ld.sh	r9,r7[18]
80002e98:	fb 38 00 0e 	ld.ub	r8,sp[14]
80002e9c:	f3 e8 10 08 	or	r8,r9,r8
80002ea0:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 15 */
  SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
80002ea4:	fb 38 00 0f 	ld.ub	r8,sp[15]
80002ea8:	a1 98       	lsr	r8,0x1
80002eaa:	ef 68 00 14 	st.b	r7[20],r8
  SD_cid->Reserved2 = 1;
80002eae:	30 18       	mov	r8,1
80002eb0:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Return the reponse */
  return rvalue;
}
80002eb4:	0c 9c       	mov	r12,r6
80002eb6:	2f cd       	sub	sp,-16
80002eb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002ebc:	80 00       	ld.sh	r0,r0[0x0]
80002ebe:	a4 78       	st.h	r2[0xe],r8
80002ec0:	80 00       	ld.sh	r0,r0[0x0]
80002ec2:	2b a0       	sub	r0,-70
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	2a e0       	sub	r0,-82
80002ec8:	80 00       	ld.sh	r0,r0[0x0]
80002eca:	2a 9c       	sub	r12,-87
80002ecc:	80 00       	ld.sh	r0,r0[0x0]
80002ece:	2b 54       	sub	r4,-75
80002ed0:	80 00       	ld.sh	r0,r0[0x0]
80002ed2:	a4 5c       	st.h	r2[0xa],r12

80002ed4 <SD_WriteMultiBlocks>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteMultiBlocks(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002ed4:	d4 31       	pushm	r0-r7,lr
80002ed6:	18 95       	mov	r5,r12
80002ed8:	16 93       	mov	r3,r11
80002eda:	14 96       	mov	r6,r10
80002edc:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002ede:	31 8c       	mov	r12,24
80002ee0:	f0 1f 00 27 	mcall	80002f7c <SD_WriteMultiBlocks+0xa8>
80002ee4:	e0 67 00 ff 	mov	r7,255
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002ee8:	4a 60       	lddpc	r0,80002f80 <SD_WriteMultiBlocks+0xac>
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002eea:	0e 92       	mov	r2,r7
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002eec:	5c 76       	castu.h	r6
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
    SD_ReadByte();
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002eee:	30 51       	mov	r1,5
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002ef0:	c3 a8       	rjmp	80002f64 <SD_WriteMultiBlocks+0x90>
  {
    if(flag_SDHC == 1)
80002ef2:	01 88       	ld.ub	r8,r0[0x0]
80002ef4:	30 19       	mov	r9,1
80002ef6:	f2 08 18 00 	cp.b	r8,r9
80002efa:	c0 81       	brne	80002f0a <SD_WriteMultiBlocks+0x36>
    {
        /* Send CMD24 (MSD_WRITE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
80002efc:	04 9a       	mov	r10,r2
80002efe:	e6 0b 16 09 	lsr	r11,r3,0x9
80002f02:	31 8c       	mov	r12,24
80002f04:	f0 1f 00 20 	mcall	80002f84 <SD_WriteMultiBlocks+0xb0>
80002f08:	c0 68       	rjmp	80002f14 <SD_WriteMultiBlocks+0x40>
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002f0a:	04 9a       	mov	r10,r2
80002f0c:	06 9b       	mov	r11,r3
80002f0e:	31 8c       	mov	r12,24
80002f10:	f0 1f 00 1d 	mcall	80002f84 <SD_WriteMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002f14:	30 0c       	mov	r12,0
80002f16:	f0 1f 00 1d 	mcall	80002f88 <SD_WriteMultiBlocks+0xb4>
80002f1a:	c0 40       	breq	80002f22 <SD_WriteMultiBlocks+0x4e>
80002f1c:	e0 67 00 ff 	mov	r7,255
80002f20:	c2 b8       	rjmp	80002f76 <SD_WriteMultiBlocks+0xa2>
    {
      return SD_RESPONSE_FAILURE;
    }
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002f22:	04 9c       	mov	r12,r2
80002f24:	f0 1f 00 1a 	mcall	80002f8c <SD_WriteMultiBlocks+0xb8>
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
80002f28:	e0 6c 00 fe 	mov	r12,254
80002f2c:	f0 1f 00 18 	mcall	80002f8c <SD_WriteMultiBlocks+0xb8>
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f30:	58 06       	cp.w	r6,0
80002f32:	c0 a0       	breq	80002f46 <SD_WriteMultiBlocks+0x72>
80002f34:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002f36:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002f3a:	f0 1f 00 15 	mcall	80002f8c <SD_WriteMultiBlocks+0xb8>
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f3e:	2f f7       	sub	r7,-1
80002f40:	0c 37       	cp.w	r7,r6
80002f42:	cf a3       	brcs	80002f36 <SD_WriteMultiBlocks+0x62>
80002f44:	0c 05       	add	r5,r6
      pBuffer++;
    }
    /*!< Set next write address */
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002f46:	f0 1f 00 13 	mcall	80002f90 <SD_WriteMultiBlocks+0xbc>
    SD_ReadByte();
80002f4a:	f0 1f 00 12 	mcall	80002f90 <SD_WriteMultiBlocks+0xbc>
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002f4e:	f0 1f 00 12 	mcall	80002f94 <SD_WriteMultiBlocks+0xc0>
80002f52:	f8 01 18 00 	cp.b	r1,r12
80002f56:	f9 b7 00 00 	moveq	r7,0
80002f5a:	e4 07 17 10 	movne	r7,r2
80002f5e:	20 14       	sub	r4,1
80002f60:	e6 c3 fe 00 	sub	r3,r3,-512
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002f64:	58 04       	cp.w	r4,0
80002f66:	cc 61       	brne	80002ef2 <SD_WriteMultiBlocks+0x1e>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002f68:	31 8c       	mov	r12,24
80002f6a:	f0 1f 00 0c 	mcall	80002f98 <SD_WriteMultiBlocks+0xc4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002f6e:	e0 6c 00 ff 	mov	r12,255
80002f72:	f0 1f 00 07 	mcall	80002f8c <SD_WriteMultiBlocks+0xb8>
  /*!< Returns the reponse */
  return rvalue;
}
80002f76:	0e 9c       	mov	r12,r7
80002f78:	d8 32       	popm	r0-r7,pc
80002f7a:	00 00       	add	r0,r0
80002f7c:	80 00       	ld.sh	r0,r0[0x0]
80002f7e:	a4 78       	st.h	r2[0xe],r8
80002f80:	00 00       	add	r0,r0
80002f82:	0a 6c       	and	r12,r5
80002f84:	80 00       	ld.sh	r0,r0[0x0]
80002f86:	2b a0       	sub	r0,-70
80002f88:	80 00       	ld.sh	r0,r0[0x0]
80002f8a:	2a e0       	sub	r0,-82
80002f8c:	80 00       	ld.sh	r0,r0[0x0]
80002f8e:	2b 54       	sub	r4,-75
80002f90:	80 00       	ld.sh	r0,r0[0x0]
80002f92:	2a 9c       	sub	r12,-87
80002f94:	80 00       	ld.sh	r0,r0[0x0]
80002f96:	2b 14       	sub	r4,-79
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	a4 5c       	st.h	r2[0xa],r12

80002f9c <SD_WriteBlock>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
{
80002f9c:	eb cd 40 e0 	pushm	r5-r7,lr
80002fa0:	18 95       	mov	r5,r12
80002fa2:	16 97       	mov	r7,r11
80002fa4:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002fa6:	31 8c       	mov	r12,24
80002fa8:	f0 1f 00 1f 	mcall	80003024 <SD_WriteBlock+0x88>

  if(flag_SDHC == 1)
80002fac:	49 f8       	lddpc	r8,80003028 <SD_WriteBlock+0x8c>
80002fae:	11 89       	ld.ub	r9,r8[0x0]
80002fb0:	30 18       	mov	r8,1
80002fb2:	f0 09 18 00 	cp.b	r9,r8
80002fb6:	c0 21       	brne	80002fba <SD_WriteBlock+0x1e>
  {
  	WriteAddr = WriteAddr/512;
80002fb8:	a9 97       	lsr	r7,0x9
  }
  /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
  SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
80002fba:	e0 6a 00 ff 	mov	r10,255
80002fbe:	0e 9b       	mov	r11,r7
80002fc0:	31 8c       	mov	r12,24
80002fc2:	f0 1f 00 1b 	mcall	8000302c <SD_WriteBlock+0x90>
  
  /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002fc6:	30 0c       	mov	r12,0
80002fc8:	f0 1f 00 1a 	mcall	80003030 <SD_WriteBlock+0x94>
80002fcc:	c1 f1       	brne	8000300a <SD_WriteBlock+0x6e>
  {
    /*!< Send a dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002fce:	e0 6c 00 ff 	mov	r12,255
80002fd2:	f0 1f 00 19 	mcall	80003034 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);
80002fd6:	e0 6c 00 fe 	mov	r12,254
80002fda:	f0 1f 00 17 	mcall	80003034 <SD_WriteBlock+0x98>

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002fde:	5c 76       	castu.h	r6
80002fe0:	c0 90       	breq	80002ff2 <SD_WriteBlock+0x56>
80002fe2:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002fe4:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002fe8:	f0 1f 00 13 	mcall	80003034 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002fec:	2f f7       	sub	r7,-1
80002fee:	0c 37       	cp.w	r7,r6
80002ff0:	cf a3       	brcs	80002fe4 <SD_WriteBlock+0x48>
      SD_WriteByte(*pBuffer);
      /*!< Point to the next location where the byte read will be saved */
      pBuffer++;
    }
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002ff2:	f0 1f 00 12 	mcall	80003038 <SD_WriteBlock+0x9c>
    SD_ReadByte();
80002ff6:	f0 1f 00 11 	mcall	80003038 <SD_WriteBlock+0x9c>

    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002ffa:	f0 1f 00 11 	mcall	8000303c <SD_WriteBlock+0xa0>
80002ffe:	30 58       	mov	r8,5
80003000:	f0 0c 18 00 	cp.b	r12,r8
80003004:	c0 31       	brne	8000300a <SD_WriteBlock+0x6e>
80003006:	30 07       	mov	r7,0
80003008:	c0 38       	rjmp	8000300e <SD_WriteBlock+0x72>
8000300a:	e0 67 00 ff 	mov	r7,255
    {
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
8000300e:	31 8c       	mov	r12,24
80003010:	f0 1f 00 0c 	mcall	80003040 <SD_WriteBlock+0xa4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003014:	e0 6c 00 ff 	mov	r12,255
80003018:	f0 1f 00 07 	mcall	80003034 <SD_WriteBlock+0x98>

  /*!< Returns the reponse */
  return rvalue;
}
8000301c:	0e 9c       	mov	r12,r7
8000301e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003022:	00 00       	add	r0,r0
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	a4 78       	st.h	r2[0xe],r8
80003028:	00 00       	add	r0,r0
8000302a:	0a 6c       	and	r12,r5
8000302c:	80 00       	ld.sh	r0,r0[0x0]
8000302e:	2b a0       	sub	r0,-70
80003030:	80 00       	ld.sh	r0,r0[0x0]
80003032:	2a e0       	sub	r0,-82
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	2b 54       	sub	r4,-75
80003038:	80 00       	ld.sh	r0,r0[0x0]
8000303a:	2a 9c       	sub	r12,-87
8000303c:	80 00       	ld.sh	r0,r0[0x0]
8000303e:	2b 14       	sub	r4,-79
80003040:	80 00       	ld.sh	r0,r0[0x0]
80003042:	a4 5c       	st.h	r2[0xa],r12

80003044 <SD_ReadMultiBlocks>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadMultiBlocks(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80003044:	d4 31       	pushm	r0-r7,lr
80003046:	20 1d       	sub	sp,4
80003048:	18 95       	mov	r5,r12
8000304a:	50 0b       	stdsp	sp[0x0],r11
8000304c:	14 96       	mov	r6,r10
8000304e:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
80003050:	31 8c       	mov	r12,24
80003052:	f0 1f 00 27 	mcall	800030ec <SD_ReadMultiBlocks+0xa8>
80003056:	e0 67 00 ff 	mov	r7,255
8000305a:	30 02       	mov	r2,0
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
8000305c:	4a 53       	lddpc	r3,800030f0 <SD_ReadMultiBlocks+0xac>
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
8000305e:	0e 90       	mov	r0,r7
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003060:	04 91       	mov	r1,r2
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003062:	5c 76       	castu.h	r6
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80003064:	c3 78       	rjmp	800030d2 <SD_ReadMultiBlocks+0x8e>
  {
    if(flag_SDHC == 1)
80003066:	07 88       	ld.ub	r8,r3[0x0]
80003068:	30 19       	mov	r9,1
8000306a:	f2 08 18 00 	cp.b	r8,r9
8000306e:	c0 a1       	brne	80003082 <SD_ReadMultiBlocks+0x3e>
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
80003070:	40 08       	lddsp	r8,sp[0x0]
80003072:	e4 08 00 0b 	add	r11,r2,r8
80003076:	00 9a       	mov	r10,r0
80003078:	a9 9b       	lsr	r11,0x9
8000307a:	31 1c       	mov	r12,17
8000307c:	f0 1f 00 1e 	mcall	800030f4 <SD_ReadMultiBlocks+0xb0>
80003080:	c0 88       	rjmp	80003090 <SD_ReadMultiBlocks+0x4c>
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80003082:	00 9a       	mov	r10,r0
80003084:	40 09       	lddsp	r9,sp[0x0]
80003086:	e4 09 00 0b 	add	r11,r2,r9
8000308a:	31 1c       	mov	r12,17
8000308c:	f0 1f 00 1a 	mcall	800030f4 <SD_ReadMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003090:	02 9c       	mov	r12,r1
80003092:	f0 1f 00 1a 	mcall	800030f8 <SD_ReadMultiBlocks+0xb4>
80003096:	c0 40       	breq	8000309e <SD_ReadMultiBlocks+0x5a>
80003098:	e0 67 00 ff 	mov	r7,255
8000309c:	c2 48       	rjmp	800030e4 <SD_ReadMultiBlocks+0xa0>
    {
      return  SD_RESPONSE_FAILURE;
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
8000309e:	e0 6c 00 fe 	mov	r12,254
800030a2:	f0 1f 00 16 	mcall	800030f8 <SD_ReadMultiBlocks+0xb4>
800030a6:	c0 30       	breq	800030ac <SD_ReadMultiBlocks+0x68>
800030a8:	00 97       	mov	r7,r0
800030aa:	c1 38       	rjmp	800030d0 <SD_ReadMultiBlocks+0x8c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
800030ac:	58 06       	cp.w	r6,0
800030ae:	c0 a0       	breq	800030c2 <SD_ReadMultiBlocks+0x7e>
800030b0:	02 97       	mov	r7,r1
      {
        /*!< Read the pointed data */
        *pBuffer = SD_ReadByte();
800030b2:	f0 1f 00 13 	mcall	800030fc <SD_ReadMultiBlocks+0xb8>
800030b6:	ea 07 0b 0c 	st.b	r5[r7],r12
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
800030ba:	2f f7       	sub	r7,-1
800030bc:	0c 37       	cp.w	r7,r6
800030be:	cf a3       	brcs	800030b2 <SD_ReadMultiBlocks+0x6e>
800030c0:	0c 05       	add	r5,r6
        *pBuffer = SD_ReadByte();
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Set next read address*/
      Offset += 512;
800030c2:	e4 c2 fe 00 	sub	r2,r2,-512
      /*!< get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
800030c6:	f0 1f 00 0e 	mcall	800030fc <SD_ReadMultiBlocks+0xb8>
      SD_ReadByte();
800030ca:	f0 1f 00 0d 	mcall	800030fc <SD_ReadMultiBlocks+0xb8>
800030ce:	02 97       	mov	r7,r1
800030d0:	20 14       	sub	r4,1
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
800030d2:	58 04       	cp.w	r4,0
800030d4:	cc 91       	brne	80003066 <SD_ReadMultiBlocks+0x22>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
800030d6:	31 8c       	mov	r12,24
800030d8:	f0 1f 00 0a 	mcall	80003100 <SD_ReadMultiBlocks+0xbc>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
800030dc:	e0 6c 00 ff 	mov	r12,255
800030e0:	f0 1f 00 09 	mcall	80003104 <SD_ReadMultiBlocks+0xc0>
  /*!< Returns the reponse */
  return rvalue;
}
800030e4:	0e 9c       	mov	r12,r7
800030e6:	2f fd       	sub	sp,-4
800030e8:	d8 32       	popm	r0-r7,pc
800030ea:	00 00       	add	r0,r0
800030ec:	80 00       	ld.sh	r0,r0[0x0]
800030ee:	a4 78       	st.h	r2[0xe],r8
800030f0:	00 00       	add	r0,r0
800030f2:	0a 6c       	and	r12,r5
800030f4:	80 00       	ld.sh	r0,r0[0x0]
800030f6:	2b a0       	sub	r0,-70
800030f8:	80 00       	ld.sh	r0,r0[0x0]
800030fa:	2a e0       	sub	r0,-82
800030fc:	80 00       	ld.sh	r0,r0[0x0]
800030fe:	2a 9c       	sub	r12,-87
80003100:	80 00       	ld.sh	r0,r0[0x0]
80003102:	a4 5c       	st.h	r2[0xa],r12
80003104:	80 00       	ld.sh	r0,r0[0x0]
80003106:	2b 54       	sub	r4,-75

80003108 <SD_ReadBlock>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
{
80003108:	eb cd 40 e0 	pushm	r5-r7,lr
8000310c:	18 95       	mov	r5,r12
8000310e:	16 97       	mov	r7,r11
80003110:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80003112:	31 8c       	mov	r12,24
80003114:	f0 1f 00 1a 	mcall	8000317c <SD_ReadBlock+0x74>
  
if(flag_SDHC == 1)
80003118:	49 a8       	lddpc	r8,80003180 <SD_ReadBlock+0x78>
8000311a:	11 89       	ld.ub	r9,r8[0x0]
8000311c:	30 18       	mov	r8,1
8000311e:	f0 09 18 00 	cp.b	r9,r8
80003122:	c0 21       	brne	80003126 <SD_ReadBlock+0x1e>
{
	ReadAddr = ReadAddr/512;
80003124:	a9 97       	lsr	r7,0x9
}
  /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
  SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
80003126:	e0 6a 00 ff 	mov	r10,255
8000312a:	0e 9b       	mov	r11,r7
8000312c:	31 1c       	mov	r12,17
8000312e:	f0 1f 00 16 	mcall	80003184 <SD_ReadBlock+0x7c>
  
  /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003132:	30 0c       	mov	r12,0
80003134:	f0 1f 00 15 	mcall	80003188 <SD_ReadBlock+0x80>
80003138:	c1 61       	brne	80003164 <SD_ReadBlock+0x5c>
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
8000313a:	e0 6c 00 fe 	mov	r12,254
8000313e:	f0 1f 00 13 	mcall	80003188 <SD_ReadBlock+0x80>
80003142:	c1 11       	brne	80003164 <SD_ReadBlock+0x5c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003144:	5c 76       	castu.h	r6
80003146:	c0 90       	breq	80003158 <SD_ReadBlock+0x50>
80003148:	30 07       	mov	r7,0
      {
        /*!< Save the received data */
        *pBuffer = SD_ReadByte();
8000314a:	f0 1f 00 11 	mcall	8000318c <SD_ReadBlock+0x84>
8000314e:	ea 07 0b 0c 	st.b	r5[r7],r12
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003152:	2f f7       	sub	r7,-1
80003154:	0c 37       	cp.w	r7,r6
80003156:	cf a3       	brcs	8000314a <SD_ReadBlock+0x42>
       
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
80003158:	f0 1f 00 0d 	mcall	8000318c <SD_ReadBlock+0x84>
      SD_ReadByte();
8000315c:	f0 1f 00 0c 	mcall	8000318c <SD_ReadBlock+0x84>
80003160:	30 07       	mov	r7,0
80003162:	c0 38       	rjmp	80003168 <SD_ReadBlock+0x60>
80003164:	e0 67 00 ff 	mov	r7,255
      /*!< Set response value to success */
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80003168:	31 8c       	mov	r12,24
8000316a:	f0 1f 00 0a 	mcall	80003190 <SD_ReadBlock+0x88>
  
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
8000316e:	e0 6c 00 ff 	mov	r12,255
80003172:	f0 1f 00 09 	mcall	80003194 <SD_ReadBlock+0x8c>
  
  /*!< Returns the reponse */
  return rvalue;
}
80003176:	0e 9c       	mov	r12,r7
80003178:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000317c:	80 00       	ld.sh	r0,r0[0x0]
8000317e:	a4 78       	st.h	r2[0xe],r8
80003180:	00 00       	add	r0,r0
80003182:	0a 6c       	and	r12,r5
80003184:	80 00       	ld.sh	r0,r0[0x0]
80003186:	2b a0       	sub	r0,-70
80003188:	80 00       	ld.sh	r0,r0[0x0]
8000318a:	2a e0       	sub	r0,-82
8000318c:	80 00       	ld.sh	r0,r0[0x0]
8000318e:	2a 9c       	sub	r12,-87
80003190:	80 00       	ld.sh	r0,r0[0x0]
80003192:	a4 5c       	st.h	r2[0xa],r12
80003194:	80 00       	ld.sh	r0,r0[0x0]
80003196:	2b 54       	sub	r4,-75

80003198 <SD_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_Init(void)
{
80003198:	eb cd 40 f8 	pushm	r3-r7,lr
  uint32_t TimeOut, i = 0;
  SD_Error Status = SD_RESPONSE_NO_ERROR;

  /* SD_SPI,SPI */
  SD_LowLevel_Init(); 
8000319c:	f0 1f 00 11 	mcall	800031e0 <SD_Init+0x48>

  /*SD_SPI*/
  SD_SPI_SetSpeedLow();
800031a0:	f0 1f 00 11 	mcall	800031e4 <SD_Init+0x4c>
800031a4:	30 05       	mov	r5,0
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
800031a6:	31 84       	mov	r4,24
800031a8:	0a 93       	mov	r3,r5

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
800031aa:	e0 66 00 ff 	mov	r6,255
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
800031ae:	08 9c       	mov	r12,r4
800031b0:	f0 1f 00 0e 	mcall	800031e8 <SD_Init+0x50>
800031b4:	06 97       	mov	r7,r3

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
800031b6:	0c 9c       	mov	r12,r6
800031b8:	f0 1f 00 0d 	mcall	800031ec <SD_Init+0x54>
    /* SDCS*/
    SD_CS_HIGH();

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
800031bc:	2f f7       	sub	r7,-1
800031be:	58 a7       	cp.w	r7,10
800031c0:	cf b1       	brne	800031b6 <SD_Init+0x1e>
    {
      SD_WriteByte(SD_DUMMY_BYTE);
    }    
    
	Status = SD_GoIdleState();
800031c2:	f0 1f 00 0c 	mcall	800031f0 <SD_Init+0x58>
800031c6:	18 97       	mov	r7,r12

    if(TimeOut > 6)
800031c8:	58 75       	cp.w	r5,7
800031ca:	c0 50       	breq	800031d4 <SD_Init+0x3c>
    {
      break;
    }
    TimeOut++;
  }while(Status);
800031cc:	58 0c       	cp.w	r12,0
800031ce:	c0 30       	breq	800031d4 <SD_Init+0x3c>

    if(TimeOut > 6)
    {
      break;
    }
    TimeOut++;
800031d0:	2f f5       	sub	r5,-1
800031d2:	ce eb       	rjmp	800031ae <SD_Init+0x16>
  }while(Status);


   /*SD_SPI*/
  SD_SPI_SetSpeedHi();
800031d4:	f0 1f 00 08 	mcall	800031f4 <SD_Init+0x5c>
  return (Status);
}
800031d8:	0e 9c       	mov	r12,r7
800031da:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800031de:	00 00       	add	r0,r0
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	2a 24       	sub	r4,-94
800031e4:	80 00       	ld.sh	r0,r0[0x0]
800031e6:	2a 14       	sub	r4,-95
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	a4 5c       	st.h	r2[0xa],r12
800031ec:	80 00       	ld.sh	r0,r0[0x0]
800031ee:	2b 54       	sub	r4,-75
800031f0:	80 00       	ld.sh	r0,r0[0x0]
800031f2:	2b dc       	sub	r12,-67
800031f4:	80 00       	ld.sh	r0,r0[0x0]
800031f6:	2a 04       	sub	r4,-96

800031f8 <SD_GetCSDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
{
800031f8:	eb cd 40 e0 	pushm	r5-r7,lr
800031fc:	20 9d       	sub	sp,36
800031fe:	18 97       	mov	r7,r12
  uint8_t CSD_Tab[16];
  uint32_t CardCapacity;
  static uint32_t times = 0;

  /*!< SD chip select low */
  SD_CS_LOW();
80003200:	31 8c       	mov	r12,24
80003202:	f0 1f 00 a6 	mcall	80003498 <SD_GetCSDRegister+0x2a0>
  /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
  SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
80003206:	e0 6a 00 ff 	mov	r10,255
8000320a:	30 0b       	mov	r11,0
8000320c:	30 9c       	mov	r12,9
8000320e:	f0 1f 00 a4 	mcall	8000349c <SD_GetCSDRegister+0x2a4>
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003212:	30 0c       	mov	r12,0
80003214:	f0 1f 00 a3 	mcall	800034a0 <SD_GetCSDRegister+0x2a8>
80003218:	c0 40       	breq	80003220 <SD_GetCSDRegister+0x28>
8000321a:	e0 6c 00 ff 	mov	r12,255
8000321e:	c3 99       	rjmp	80003490 <SD_GetCSDRegister+0x298>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80003220:	e0 6c 00 fe 	mov	r12,254
80003224:	f0 1f 00 9f 	mcall	800034a0 <SD_GetCSDRegister+0x2a8>
80003228:	c0 a1       	brne	8000323c <SD_GetCSDRegister+0x44>
8000322a:	fa c6 ff ec 	sub	r6,sp,-20
  * @param  SD_csd: pointer on an SCD register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
8000322e:	fa c5 ff dc 	sub	r5,sp,-36
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
      {
        /*!< Store CSD register value on CSD_Tab */
        CSD_Tab[i] = SD_ReadByte();
80003232:	f0 1f 00 9d 	mcall	800034a4 <SD_GetCSDRegister+0x2ac>
80003236:	0c cc       	st.b	r6++,r12
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
80003238:	0a 36       	cp.w	r6,r5
8000323a:	cf c1       	brne	80003232 <SD_GetCSDRegister+0x3a>
          //printf("\n\r CSD_Tab[%d] 0x%X", i, CSD_Tab[i]);
        }
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
8000323c:	e0 6c 00 ff 	mov	r12,255
80003240:	f0 1f 00 9a 	mcall	800034a8 <SD_GetCSDRegister+0x2b0>
    SD_WriteByte(SD_DUMMY_BYTE);
80003244:	e0 6c 00 ff 	mov	r12,255
80003248:	f0 1f 00 98 	mcall	800034a8 <SD_GetCSDRegister+0x2b0>
  else
  {
     return rvalue;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
8000324c:	31 8c       	mov	r12,24
8000324e:	f0 1f 00 98 	mcall	800034ac <SD_GetCSDRegister+0x2b4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003252:	e0 6c 00 ff 	mov	r12,255
80003256:	f0 1f 00 95 	mcall	800034a8 <SD_GetCSDRegister+0x2b0>

  /*!< Byte 0 */
  SD_csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
8000325a:	fb 38 00 14 	ld.ub	r8,sp[20]
8000325e:	f0 09 16 06 	lsr	r9,r8,0x6
80003262:	ae 89       	st.b	r7[0x0],r9
  SD_csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
80003264:	f3 d8 c0 44 	bfextu	r9,r8,0x2,0x4
80003268:	ae 99       	st.b	r7[0x1],r9
  SD_csd->Reserved1 = CSD_Tab[0] & 0x03;
8000326a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000326e:	ae a8       	st.b	r7[0x2],r8

  if(0 == times)
80003270:	fe f8 02 40 	ld.w	r8,pc[576]
80003274:	70 08       	ld.w	r8,r8[0x0]
80003276:	58 08       	cp.w	r8,0
80003278:	c0 f1       	brne	80003296 <SD_GetCSDRegister+0x9e>
  {
    if(SD_csd->CSDStruct == 1)
8000327a:	0f 89       	ld.ub	r9,r7[0x0]
8000327c:	30 18       	mov	r8,1
8000327e:	f0 09 18 00 	cp.b	r9,r8
80003282:	c0 61       	brne	8000328e <SD_GetCSDRegister+0x96>
    {
      //printf("\n\r SDHC CSD Version 2.0 Acess AS SD High Capacity.");
      flag_SDHC = 1;
80003284:	10 99       	mov	r9,r8
80003286:	fe f8 02 2e 	ld.w	r8,pc[558]
8000328a:	b0 89       	st.b	r8[0x0],r9
8000328c:	c0 58       	rjmp	80003296 <SD_GetCSDRegister+0x9e>
    }
	else
	{
      //printf("\n\r SDSC CSD Version 1.0 Acess AS SD Standard Capacity.");	
      flag_SDHC = 0;
8000328e:	30 09       	mov	r9,0
80003290:	fe f8 02 24 	ld.w	r8,pc[548]
80003294:	b0 89       	st.b	r8[0x0],r9
	}
  }

  /*!< Byte 1 */
  SD_csd->TAAC = CSD_Tab[1];
80003296:	fb 38 00 15 	ld.ub	r8,sp[21]
8000329a:	ae b8       	st.b	r7[0x3],r8

  /*!< Byte 2 */
  SD_csd->NSAC = CSD_Tab[2];
8000329c:	fb 38 00 16 	ld.ub	r8,sp[22]
800032a0:	ae c8       	st.b	r7[0x4],r8

  /*!< Byte 3 */
  SD_csd->MaxBusClkFrec = CSD_Tab[3];
800032a2:	fb 38 00 17 	ld.ub	r8,sp[23]
800032a6:	ae d8       	st.b	r7[0x5],r8

  /*!< Byte 4 */
  SD_csd->CardComdClasses = CSD_Tab[4] << 4;
800032a8:	fb 38 00 18 	ld.ub	r8,sp[24]
800032ac:	a5 68       	lsl	r8,0x4
800032ae:	ae 38       	st.h	r7[0x6],r8

  /*!< Byte 5 */
  SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
800032b0:	8e 39       	ld.sh	r9,r7[0x6]
800032b2:	fb 38 00 19 	ld.ub	r8,sp[25]
800032b6:	f3 e8 12 49 	or	r9,r9,r8>>0x4
800032ba:	ae 39       	st.h	r7[0x6],r9
  SD_csd->RdBlockLen = CSD_Tab[5] & 0x0F;
800032bc:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800032c0:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 6 */
  SD_csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
800032c4:	fb 38 00 1a 	ld.ub	r8,sp[26]
800032c8:	f0 09 16 07 	lsr	r9,r8,0x7
800032cc:	ef 69 00 09 	st.b	r7[9],r9
  SD_csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
800032d0:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
800032d4:	ef 69 00 0a 	st.b	r7[10],r9
  SD_csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
800032d8:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
800032dc:	ef 69 00 0b 	st.b	r7[11],r9
  SD_csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
800032e0:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
800032e4:	ef 69 00 0c 	st.b	r7[12],r9
  SD_csd->Reserved2 = 0; /*!< Reserved */
800032e8:	30 09       	mov	r9,0
800032ea:	ef 69 00 0d 	st.b	r7[13],r9

  if(flag_SDHC == 0)
800032ee:	4f 2a       	lddpc	r10,800034b4 <SD_GetCSDRegister+0x2bc>
800032f0:	15 8a       	ld.ub	r10,r10[0x0]
800032f2:	f2 0a 18 00 	cp.b	r10,r9
800032f6:	c1 21       	brne	8000331a <SD_GetCSDRegister+0x122>
  {
    SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
800032f8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800032fc:	ab 68       	lsl	r8,0xa
800032fe:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 7 */
    SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
80003300:	6e 48       	ld.w	r8,r7[0x10]
80003302:	fb 39 00 1b 	ld.ub	r9,sp[27]
80003306:	f1 e9 10 28 	or	r8,r8,r9<<0x2
8000330a:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 8 */
    SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
8000330c:	6e 48       	ld.w	r8,r7[0x10]
8000330e:	fb 39 00 1c 	ld.ub	r9,sp[28]
80003312:	f1 e9 12 68 	or	r8,r8,r9>>0x6
80003316:	8f 48       	st.w	r7[0x10],r8
80003318:	c1 38       	rjmp	8000333e <SD_GetCSDRegister+0x146>
  }
  else
  {
    SD_csd->DeviceSize = (CSD_Tab[7] & 0x3F) << 16;
8000331a:	fb 38 00 1b 	ld.ub	r8,sp[27]
8000331e:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80003322:	b1 68       	lsl	r8,0x10
80003324:	8f 48       	st.w	r7[0x10],r8
    /* Byte 7 */
    SD_csd->DeviceSize += (CSD_Tab[8]) << 8;
80003326:	6e 49       	ld.w	r9,r7[0x10]
80003328:	fb 38 00 1c 	ld.ub	r8,sp[28]
8000332c:	a9 68       	lsl	r8,0x8
8000332e:	12 08       	add	r8,r9
80003330:	8f 48       	st.w	r7[0x10],r8
    /* Byte 8 */
    SD_csd->DeviceSize += CSD_Tab[9] ;
80003332:	6e 48       	ld.w	r8,r7[0x10]
80003334:	fb 39 00 1d 	ld.ub	r9,sp[29]
80003338:	f2 08 00 08 	add	r8,r9,r8
8000333c:	8f 48       	st.w	r7[0x10],r8
  }    

  SD_csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
8000333e:	fb 38 00 1c 	ld.ub	r8,sp[28]
80003342:	f3 d8 c0 63 	bfextu	r9,r8,0x3,0x3
80003346:	ef 69 00 14 	st.b	r7[20],r9
  SD_csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
8000334a:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000334e:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Byte 9 */
  SD_csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
80003352:	fb 38 00 1d 	ld.ub	r8,sp[29]
80003356:	f0 09 16 05 	lsr	r9,r8,0x5
8000335a:	ef 69 00 16 	st.b	r7[22],r9
  SD_csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
8000335e:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
80003362:	ef 69 00 17 	st.b	r7[23],r9
  SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
80003366:	a1 78       	lsl	r8,0x1
80003368:	e2 18 00 06 	andl	r8,0x6,COH
8000336c:	ef 68 00 18 	st.b	r7[24],r8
  /*!< Byte 10 */
  SD_csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
80003370:	ef 39 00 18 	ld.ub	r9,r7[24]
80003374:	fb 38 00 1e 	ld.ub	r8,sp[30]
80003378:	f3 e8 12 79 	or	r9,r9,r8>>0x7
8000337c:	ef 69 00 18 	st.b	r7[24],r9
    
  SD_csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
80003380:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
80003384:	ef 69 00 19 	st.b	r7[25],r9
  SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
80003388:	a1 78       	lsl	r8,0x1
8000338a:	e2 18 00 7e 	andl	r8,0x7e,COH
8000338e:	ef 68 00 1a 	st.b	r7[26],r8

  /*!< Byte 11 */
  SD_csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
80003392:	ef 39 00 1a 	ld.ub	r9,r7[26]
80003396:	fb 38 00 1f 	ld.ub	r8,sp[31]
8000339a:	f3 e8 12 79 	or	r9,r9,r8>>0x7
8000339e:	ef 69 00 1a 	st.b	r7[26],r9
  SD_csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
800033a2:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
800033a6:	ef 68 00 1b 	st.b	r7[27],r8

  /*!< Byte 12 */
  SD_csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
800033aa:	fb 38 00 20 	ld.ub	r8,sp[32]
800033ae:	f0 09 16 07 	lsr	r9,r8,0x7
800033b2:	ef 69 00 1c 	st.b	r7[28],r9
  SD_csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
800033b6:	f3 d8 c0 a2 	bfextu	r9,r8,0x5,0x2
800033ba:	ef 69 00 1d 	st.b	r7[29],r9
  SD_csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
800033be:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
800033c2:	ef 69 00 1e 	st.b	r7[30],r9
  SD_csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
800033c6:	a3 68       	lsl	r8,0x2
800033c8:	e2 18 00 0c 	andl	r8,0xc,COH
800033cc:	ef 68 00 1f 	st.b	r7[31],r8

  /*!< Byte 13 */
  SD_csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
800033d0:	ef 39 00 1f 	ld.ub	r9,r7[31]
800033d4:	fb 38 00 21 	ld.ub	r8,sp[33]
800033d8:	f3 e8 12 69 	or	r9,r9,r8>>0x6
800033dc:	ef 69 00 1f 	st.b	r7[31],r9
  SD_csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
800033e0:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
800033e4:	ef 69 00 20 	st.b	r7[32],r9
  SD_csd->Reserved3 = 0;
800033e8:	30 09       	mov	r9,0
800033ea:	ef 69 00 21 	st.b	r7[33],r9
  SD_csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
800033ee:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800033f2:	ef 68 00 22 	st.b	r7[34],r8

  /*!< Byte 14 */
  SD_csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
800033f6:	fb 38 00 22 	ld.ub	r8,sp[34]
800033fa:	f0 09 16 07 	lsr	r9,r8,0x7
800033fe:	ef 69 00 23 	st.b	r7[35],r9
  SD_csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
80003402:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
80003406:	ef 69 00 24 	st.b	r7[36],r9
  SD_csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
8000340a:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
8000340e:	ef 69 00 25 	st.b	r7[37],r9
  SD_csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
80003412:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80003416:	ef 69 00 26 	st.b	r7[38],r9
  SD_csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
8000341a:	f3 d8 c0 42 	bfextu	r9,r8,0x2,0x2
8000341e:	ef 69 00 27 	st.b	r7[39],r9
  SD_csd->ECC = (CSD_Tab[14] & 0x03);
80003422:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003426:	ef 68 00 28 	st.b	r7[40],r8

  /*!< Byte 15 */
  SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
8000342a:	fb 38 00 23 	ld.ub	r8,sp[35]
8000342e:	a1 98       	lsr	r8,0x1
80003430:	ef 68 00 29 	st.b	r7[41],r8
  SD_csd->Reserved4 = 1;
80003434:	30 18       	mov	r8,1
80003436:	ef 68 00 2a 	st.b	r7[42],r8

  if(times < 3)
8000343a:	49 e8       	lddpc	r8,800034b0 <SD_GetCSDRegister+0x2b8>
8000343c:	70 08       	ld.w	r8,r8[0x0]
8000343e:	58 28       	cp.w	r8,2
80003440:	e0 88 00 04 	brls	80003448 <SD_GetCSDRegister+0x250>
80003444:	30 0c       	mov	r12,0
80003446:	c2 58       	rjmp	80003490 <SD_GetCSDRegister+0x298>
  {
    if(flag_SDHC ==1)
80003448:	49 b9       	lddpc	r9,800034b4 <SD_GetCSDRegister+0x2bc>
8000344a:	13 8a       	ld.ub	r10,r9[0x0]
8000344c:	30 19       	mov	r9,1
8000344e:	f2 0a 18 00 	cp.b	r10,r9
80003452:	c0 51       	brne	8000345c <SD_GetCSDRegister+0x264>
    {
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
      //SD_csd->DeviceSizeMul = 8 ;
      
      CardCapacity = (SD_csd->DeviceSize + 1)*512;
80003454:	6e 49       	ld.w	r9,r7[0x10]
80003456:	2f f9       	sub	r9,-1
80003458:	a9 79       	lsl	r9,0x9
8000345a:	c0 c8       	rjmp	80003472 <SD_GetCSDRegister+0x27a>
      
    }

    else
    {
      CardCapacity = (SD_csd->DeviceSize + 1);
8000345c:	6e 4a       	ld.w	r10,r7[0x10]
8000345e:	2f fa       	sub	r10,-1
      CardCapacity *= (1 << (SD_csd->DeviceSizeMul + 2));
80003460:	ef 39 00 18 	ld.ub	r9,r7[24]
80003464:	2f e9       	sub	r9,-2
80003466:	f4 09 09 4a 	lsl	r10,r10,r9
      CardCapacity *= (1<<SD_csd->RdBlockLen);
8000346a:	ef 39 00 08 	ld.ub	r9,r7[8]
8000346e:	f4 09 09 49 	lsl	r9,r10,r9
      //printf("\n\r SD CardBlockSize %d CardCapacity %d M.", (1<<SD_csd->RdBlockLen), 
            //CardCapacity / 1024 / 1024);
    }
    
  if(times == 0)
80003472:	58 08       	cp.w	r8,0
80003474:	c0 91       	brne	80003486 <SD_GetCSDRegister+0x28e>
    {
	    uint8_t str[20];
        sprintf((char *)&str[0], " SD Card Size %dM. ", CardCapacity / 1024 / 1024);
80003476:	b5 89       	lsr	r9,0x14
80003478:	1a d9       	st.w	--sp,r9
8000347a:	49 0b       	lddpc	r11,800034b8 <SD_GetCSDRegister+0x2c0>
8000347c:	fa cc ff fc 	sub	r12,sp,-4
80003480:	f0 1f 00 0f 	mcall	800034bc <SD_GetCSDRegister+0x2c4>
80003484:	2f fd       	sub	sp,-4
//	    LCD_DisplayStringLine(LCD_LINE_0, str);
    }
	times++;
80003486:	48 b8       	lddpc	r8,800034b0 <SD_GetCSDRegister+0x2b8>
80003488:	70 09       	ld.w	r9,r8[0x0]
8000348a:	2f f9       	sub	r9,-1
8000348c:	91 09       	st.w	r8[0x0],r9
8000348e:	30 0c       	mov	r12,0
  }
  /*!< Return the reponse */
  return rvalue;
}
80003490:	2f 7d       	sub	sp,-36
80003492:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003496:	00 00       	add	r0,r0
80003498:	80 00       	ld.sh	r0,r0[0x0]
8000349a:	a4 78       	st.h	r2[0xe],r8
8000349c:	80 00       	ld.sh	r0,r0[0x0]
8000349e:	2b a0       	sub	r0,-70
800034a0:	80 00       	ld.sh	r0,r0[0x0]
800034a2:	2a e0       	sub	r0,-82
800034a4:	80 00       	ld.sh	r0,r0[0x0]
800034a6:	2a 9c       	sub	r12,-87
800034a8:	80 00       	ld.sh	r0,r0[0x0]
800034aa:	2b 54       	sub	r4,-75
800034ac:	80 00       	ld.sh	r0,r0[0x0]
800034ae:	a4 5c       	st.h	r2[0xa],r12
800034b0:	00 00       	add	r0,r0
800034b2:	0a 68       	and	r8,r5
800034b4:	00 00       	add	r0,r0
800034b6:	0a 6c       	and	r12,r5
800034b8:	80 01       	ld.sh	r1,r0[0x0]
800034ba:	09 c0       	ld.ub	r0,r4[0x4]
800034bc:	80 00       	ld.sh	r0,r0[0x0]
800034be:	ad 88       	lsr	r8,0xc

800034c0 <SD_GetCardInfo>:
  * @   
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
{
800034c0:	eb cd 40 c0 	pushm	r6-r7,lr
800034c4:	18 97       	mov	r7,r12
  static uint32_t i = 0;
  SD_Error status = SD_RESPONSE_FAILURE;

  status = SD_GetCSDRegister(&(cardinfo->SD_csd));
800034c6:	18 96       	mov	r6,r12
800034c8:	f0 1f 00 12 	mcall	80003510 <SD_GetCardInfo+0x50>
  if(SD_RESPONSE_FAILURE == status)
800034cc:	e0 4c 00 ff 	cp.w	r12,255
800034d0:	c0 41       	brne	800034d8 <SD_GetCardInfo+0x18>
  {
    status = SD_GetCSDRegister(&(cardinfo->SD_csd));
800034d2:	0e 9c       	mov	r12,r7
800034d4:	f0 1f 00 0f 	mcall	80003510 <SD_GetCardInfo+0x50>
  }
  status = SD_GetCIDRegister(&(cardinfo->SD_cid));
800034d8:	ee cc ff d4 	sub	r12,r7,-44
800034dc:	f0 1f 00 0e 	mcall	80003514 <SD_GetCardInfo+0x54>
  
  if (flag_SDHC = 1)
800034e0:	30 19       	mov	r9,1
800034e2:	48 e8       	lddpc	r8,80003518 <SD_GetCardInfo+0x58>
800034e4:	b0 89       	st.b	r8[0x0],r9
  {
	  
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
	  
	  cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ; 
800034e6:	6e 48       	ld.w	r8,r7[0x10]
800034e8:	2f f8       	sub	r8,-1
800034ea:	ef 48 00 44 	st.w	r7[68],r8
	  cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
800034ee:	ef 39 00 08 	ld.ub	r9,r7[8]
800034f2:	30 1a       	mov	r10,1
800034f4:	f4 09 09 49 	lsl	r9,r10,r9
800034f8:	ef 49 00 48 	st.w	r7[72],r9
	  cardinfo->CardCapacity *= cardinfo->CardBlockSize; 
800034fc:	f2 08 02 48 	mul	r8,r9,r8
80003500:	ef 48 00 44 	st.w	r7[68],r8
  {
  
    //printf("\n\r SD CardBlockSize %d CardCapacity %d M", cardinfo->CardBlockSize, 
            //cardinfo->CardCapacity / 1024 / 1024);
  }
  i++; 
80003504:	48 68       	lddpc	r8,8000351c <SD_GetCardInfo+0x5c>
80003506:	70 09       	ld.w	r9,r8[0x0]
80003508:	14 09       	add	r9,r10
8000350a:	91 09       	st.w	r8[0x0],r9
  
  /*!< Returns the reponse */
  return status;
}
8000350c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003510:	80 00       	ld.sh	r0,r0[0x0]
80003512:	31 f8       	mov	r8,31
80003514:	80 00       	ld.sh	r0,r0[0x0]
80003516:	2d a4       	sub	r4,-38
80003518:	00 00       	add	r0,r0
8000351a:	0a 6c       	and	r12,r5
8000351c:	00 00       	add	r0,r0
8000351e:	0a 64       	and	r4,r5

80003520 <SD_GetSectorCount>:
	}while(t<0XFFFFFF);//
	return SD_RESPONSE_FAILURE ;
}

uint32_t SD_GetSectorCount(void)
{
80003520:	d4 01       	pushm	lr
80003522:	21 3d       	sub	sp,76
	
	
	uint32_t  static temp;
	
	
	SD_GetCardInfo(&sdinfo);
80003524:	1a 9c       	mov	r12,sp
80003526:	f0 1f 00 05 	mcall	80003538 <SD_GetSectorCount+0x18>
	
	temp = sdinfo.CardCapacity;
	
	temp = temp*(1024/512);//:1sector=512byte
8000352a:	41 1c       	lddsp	r12,sp[0x44]
8000352c:	a1 7c       	lsl	r12,0x1
8000352e:	48 48       	lddpc	r8,8000353c <SD_GetSectorCount+0x1c>
80003530:	91 0c       	st.w	r8[0x0],r12
	
	return (temp);
	
	

}
80003532:	2e dd       	sub	sp,-76
80003534:	d8 02       	popm	pc
80003536:	00 00       	add	r0,r0
80003538:	80 00       	ld.sh	r0,r0[0x0]
8000353a:	34 c0       	mov	r0,76
8000353c:	00 00       	add	r0,r0
8000353e:	0a 60       	and	r0,r5

80003540 <MAL_WriteDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_WriteDisk(void *writebuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
80003540:	d4 01       	pushm	lr
	
	
	if(count == 1)
80003542:	30 18       	mov	r8,1
80003544:	f0 09 18 00 	cp.b	r9,r8
80003548:	c0 71       	brne	80003556 <MAL_WriteDisk+0x16>
	{
		
		if(SD_WriteBlock(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
8000354a:	5c 7a       	castu.h	r10
8000354c:	a9 7b       	lsl	r11,0x9
8000354e:	f0 1f 00 07 	mcall	80003568 <MAL_WriteDisk+0x28>
80003552:	c0 91       	brne	80003564 <MAL_WriteDisk+0x24>
80003554:	c0 68       	rjmp	80003560 <MAL_WriteDisk+0x20>
		
	}
	else
	{
		
		if(SD_WriteMultiBlocks(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
80003556:	5c 7a       	castu.h	r10
80003558:	a9 7b       	lsl	r11,0x9
8000355a:	f0 1f 00 05 	mcall	8000356c <MAL_WriteDisk+0x2c>
8000355e:	c0 31       	brne	80003564 <MAL_WriteDisk+0x24>
80003560:	30 4c       	mov	r12,4
80003562:	d8 02       	popm	pc
80003564:	30 3c       	mov	r12,3
	
	return WRITE_DATA_ERR;
	
	
	
}
80003566:	d8 02       	popm	pc
80003568:	80 00       	ld.sh	r0,r0[0x0]
8000356a:	2f 9c       	sub	r12,-7
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	2e d4       	sub	r4,-19

80003570 <MAL_ReadDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_ReadDisk(void *readbuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
80003570:	d4 01       	pushm	lr
	
	
	if(count == 1)
80003572:	30 18       	mov	r8,1
80003574:	f0 09 18 00 	cp.b	r9,r8
80003578:	c0 71       	brne	80003586 <MAL_ReadDisk+0x16>
	{
		
		if(SD_ReadBlock(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
8000357a:	5c 7a       	castu.h	r10
8000357c:	a9 7b       	lsl	r11,0x9
8000357e:	f0 1f 00 07 	mcall	80003598 <MAL_ReadDisk+0x28>
80003582:	c0 91       	brne	80003594 <MAL_ReadDisk+0x24>
80003584:	c0 68       	rjmp	80003590 <MAL_ReadDisk+0x20>
		
	}
	else
	{
		
		if(SD_ReadMultiBlocks(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
80003586:	5c 7a       	castu.h	r10
80003588:	a9 7b       	lsl	r11,0x9
8000358a:	f0 1f 00 05 	mcall	8000359c <MAL_ReadDisk+0x2c>
8000358e:	c0 31       	brne	80003594 <MAL_ReadDisk+0x24>
80003590:	30 8c       	mov	r12,8
80003592:	d8 02       	popm	pc
80003594:	30 7c       	mov	r12,7
	
	return READ_DATA_ERR;
	
		
	
}
80003596:	d8 02       	popm	pc
80003598:	80 00       	ld.sh	r0,r0[0x0]
8000359a:	31 08       	mov	r8,16
8000359c:	80 00       	ld.sh	r0,r0[0x0]
8000359e:	30 44       	mov	r4,4

800035a0 <MAL_InitConfig>:
* Output         : None
* Return         : SDConfigStatus:SD Card initiation code
*******************************************************************************/

uint16_t MAL_InitConfig(void)
{
800035a0:	d4 01       	pushm	lr
800035a2:	21 3d       	sub	sp,76
	uint16_t status = SDConfig_OK;
        
    SD_CardInfo cardinfo;

      if(!(SD_Init()))
800035a4:	f0 1f 00 06 	mcall	800035bc <MAL_InitConfig+0x1c>
800035a8:	c0 30       	breq	800035ae <MAL_InitConfig+0xe>
800035aa:	30 1c       	mov	r12,1
800035ac:	c0 58       	rjmp	800035b6 <MAL_InitConfig+0x16>
      {
        
			if(SD_GetCardInfo(&cardinfo)==0) /*SD */
800035ae:	1a 9c       	mov	r12,sp
800035b0:	f0 1f 00 04 	mcall	800035c0 <MAL_InitConfig+0x20>
800035b4:	5f 1c       	srne	r12
			return status;//
      
      }    

        return SDConfig_FALL;
}
800035b6:	2e dd       	sub	sp,-76
800035b8:	d8 02       	popm	pc
800035ba:	00 00       	add	r0,r0
800035bc:	80 00       	ld.sh	r0,r0[0x0]
800035be:	31 98       	mov	r8,25
800035c0:	80 00       	ld.sh	r0,r0[0x0]
800035c2:	34 c0       	mov	r0,76

800035c4 <fl_read>:
	}
	
}

void fl_read(void * path, S32 offset, void * buffer, U32 length)
{
800035c4:	eb cd 40 f8 	pushm	r3-r7,lr
800035c8:	20 2d       	sub	sp,8
800035ca:	18 95       	mov	r5,r12
800035cc:	16 94       	mov	r4,r11
800035ce:	14 93       	mov	r3,r10
800035d0:	12 96       	mov	r6,r9
	
	fl_read_t * fl_read_ptr = pvPortMalloc(sizeof(fl_read_t));
800035d2:	34 cc       	mov	r12,76
800035d4:	f0 1f 00 16 	mcall	8000362c <fl_read+0x68>
800035d8:	18 97       	mov	r7,r12
	
	sprintf(fl_read_ptr->path, "%s", path);
800035da:	0a 9b       	mov	r11,r5
800035dc:	f0 1f 00 15 	mcall	80003630 <fl_read+0x6c>
	fl_read_ptr->offset = offset;
800035e0:	ef 44 00 40 	st.w	r7[64],r4
	fl_read_ptr->length = length;
800035e4:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_read_ptr->buffer = pvPortMalloc(length);
800035e8:	0c 9c       	mov	r12,r6
800035ea:	f0 1f 00 11 	mcall	8000362c <fl_read+0x68>
800035ee:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_read_ptr->buffer, buffer, length);
800035f2:	0c 9a       	mov	r10,r6
800035f4:	06 9b       	mov	r11,r3
800035f6:	f0 1f 00 10 	mcall	80003634 <fl_read+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_READ;
800035fa:	e0 68 40 01 	mov	r8,16385
800035fe:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_read_ptr;
80003600:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
80003602:	48 e8       	lddpc	r8,80003638 <fl_read+0x74>
80003604:	70 0c       	ld.w	r12,r8[0x0]
80003606:	30 09       	mov	r9,0
80003608:	12 9a       	mov	r10,r9
8000360a:	1a 9b       	mov	r11,sp
8000360c:	f0 1f 00 0c 	mcall	8000363c <fl_read+0x78>
80003610:	58 1c       	cp.w	r12,1
80003612:	c0 a0       	breq	80003626 <fl_read+0x62>
	{
		vPortFree(fl_read_ptr->buffer);
80003614:	6f 2c       	ld.w	r12,r7[0x48]
80003616:	f0 1f 00 0b 	mcall	80003640 <fl_read+0x7c>
		vPortFree(fl_read_ptr);
8000361a:	0e 9c       	mov	r12,r7
8000361c:	f0 1f 00 09 	mcall	80003640 <fl_read+0x7c>
		log("\n\r Rmm \n\r");//man...SPI_PBA
80003620:	48 9c       	lddpc	r12,80003644 <fl_read+0x80>
80003622:	f0 1f 00 0a 	mcall	80003648 <fl_read+0x84>
	}
	
}
80003626:	2f ed       	sub	sp,-8
80003628:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000362c:	80 00       	ld.sh	r0,r0[0x0]
8000362e:	90 48       	ld.sh	r8,r8[0x8]
80003630:	80 00       	ld.sh	r0,r0[0x0]
80003632:	ad c4       	cbr	r4,0xc
80003634:	80 00       	ld.sh	r0,r0[0x0]
80003636:	a9 52       	asr	r2,0x9
80003638:	00 00       	add	r0,r0
8000363a:	0d 44       	ld.w	r4,--r6
8000363c:	80 00       	ld.sh	r0,r0[0x0]
8000363e:	93 9c       	st.w	r9[0x24],r12
80003640:	80 00       	ld.sh	r0,r0[0x0]
80003642:	90 20       	ld.sh	r0,r8[0x4]
80003644:	80 01       	ld.sh	r1,r0[0x0]
80003646:	0a 08       	add	r8,r5
80003648:	80 00       	ld.sh	r0,r0[0x0]
8000364a:	9f 8c       	st.w	pc[0x20],r12

8000364c <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
8000364c:	eb cd 40 f8 	pushm	r3-r7,lr
80003650:	20 2d       	sub	sp,8
80003652:	18 95       	mov	r5,r12
80003654:	16 94       	mov	r4,r11
80003656:	14 93       	mov	r3,r10
80003658:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
8000365a:	34 cc       	mov	r12,76
8000365c:	f0 1f 00 16 	mcall	800036b4 <fl_write+0x68>
80003660:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
80003662:	0a 9b       	mov	r11,r5
80003664:	f0 1f 00 15 	mcall	800036b8 <fl_write+0x6c>
	fl_write_ptr->offset = offset;
80003668:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
8000366c:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
80003670:	0c 9c       	mov	r12,r6
80003672:	f0 1f 00 11 	mcall	800036b4 <fl_write+0x68>
80003676:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
8000367a:	0c 9a       	mov	r10,r6
8000367c:	06 9b       	mov	r11,r3
8000367e:	f0 1f 00 10 	mcall	800036bc <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
80003682:	e0 68 40 00 	mov	r8,16384
80003686:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
80003688:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
8000368a:	48 e8       	lddpc	r8,800036c0 <fl_write+0x74>
8000368c:	70 0c       	ld.w	r12,r8[0x0]
8000368e:	30 09       	mov	r9,0
80003690:	12 9a       	mov	r10,r9
80003692:	1a 9b       	mov	r11,sp
80003694:	f0 1f 00 0c 	mcall	800036c4 <fl_write+0x78>
80003698:	58 1c       	cp.w	r12,1
8000369a:	c0 a0       	breq	800036ae <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
8000369c:	6f 2c       	ld.w	r12,r7[0x48]
8000369e:	f0 1f 00 0b 	mcall	800036c8 <fl_write+0x7c>
		vPortFree(fl_write_ptr);
800036a2:	0e 9c       	mov	r12,r7
800036a4:	f0 1f 00 09 	mcall	800036c8 <fl_write+0x7c>
		log("\n\r Wmm \n\r");//man...SPI_PBA
800036a8:	48 9c       	lddpc	r12,800036cc <fl_write+0x80>
800036aa:	f0 1f 00 0a 	mcall	800036d0 <fl_write+0x84>
	}
	
}
800036ae:	2f ed       	sub	sp,-8
800036b0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800036b4:	80 00       	ld.sh	r0,r0[0x0]
800036b6:	90 48       	ld.sh	r8,r8[0x8]
800036b8:	80 00       	ld.sh	r0,r0[0x0]
800036ba:	ad c4       	cbr	r4,0xc
800036bc:	80 00       	ld.sh	r0,r0[0x0]
800036be:	a9 52       	asr	r2,0x9
800036c0:	00 00       	add	r0,r0
800036c2:	0d 44       	ld.w	r4,--r6
800036c4:	80 00       	ld.sh	r0,r0[0x0]
800036c6:	93 9c       	st.w	r9[0x24],r12
800036c8:	80 00       	ld.sh	r0,r0[0x0]
800036ca:	90 20       	ld.sh	r0,r8[0x4]
800036cc:	80 01       	ld.sh	r1,r0[0x0]
800036ce:	0a 14       	sub	r4,r5
800036d0:	80 00       	ld.sh	r0,r0[0x0]
800036d2:	9f 8c       	st.w	pc[0x20],r12

800036d4 <fl_write_func>:
	f_mount(NULL, "/", 1);		
	return fs_ok;
}

fs_err_t fl_write_func(void * path, S32 offset, void * buffer, U32 length)
{	
800036d4:	d4 31       	pushm	r0-r7,lr
800036d6:	20 1d       	sub	sp,4
800036d8:	18 97       	mov	r7,r12
800036da:	16 96       	mov	r6,r11
800036dc:	14 94       	mov	r4,r10
800036de:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
800036e0:	30 1a       	mov	r10,1
800036e2:	4c 7b       	lddpc	r11,800037fc <fl_write_func+0x128>
800036e4:	4c 7c       	lddpc	r12,80003800 <fl_write_func+0x12c>
800036e6:	f0 1f 00 48 	mcall	80003804 <fl_write_func+0x130>
800036ea:	e0 81 00 86 	brne	800037f6 <fl_write_func+0x122>
	{
		return amount_err;
	}
	
	FRESULT res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
800036ee:	0e 91       	mov	r1,r7
800036f0:	31 2a       	mov	r10,18
800036f2:	0e 9b       	mov	r11,r7
800036f4:	4c 5c       	lddpc	r12,80003808 <fl_write_func+0x134>
800036f6:	f0 1f 00 46 	mcall	8000380c <fl_write_func+0x138>
	if(FR_NO_PATH == res)
800036fa:	58 5c       	cp.w	r12,5
800036fc:	c5 91       	brne	800037ae <fl_write_func+0xda>
	{
		if ( f_opendir(&dirs, "/") != FR_OK)
800036fe:	4c 0b       	lddpc	r11,800037fc <fl_write_func+0x128>
80003700:	4c 4c       	lddpc	r12,80003810 <fl_write_func+0x13c>
80003702:	f0 1f 00 45 	mcall	80003814 <fl_write_func+0x140>
80003706:	c0 80       	breq	80003716 <fl_write_func+0x42>
		{
			f_mount(NULL, "/", 1);
80003708:	30 1a       	mov	r10,1
8000370a:	4b db       	lddpc	r11,800037fc <fl_write_func+0x128>
8000370c:	30 0c       	mov	r12,0
8000370e:	f0 1f 00 3e 	mcall	80003804 <fl_write_func+0x130>
80003712:	30 6c       	mov	r12,6
			return fs_err;
80003714:	c7 28       	rjmp	800037f8 <fl_write_func+0x124>
		}
		
		static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
		memcpy(path_bk, path, strlen(path));
80003716:	0e 9c       	mov	r12,r7
80003718:	f0 1f 00 40 	mcall	80003818 <fl_write_func+0x144>
8000371c:	4c 03       	lddpc	r3,8000381c <fl_write_func+0x148>
8000371e:	18 9a       	mov	r10,r12
80003720:	0e 9b       	mov	r11,r7
80003722:	06 9c       	mov	r12,r3
80003724:	f0 1f 00 3f 	mcall	80003820 <fl_write_func+0x14c>
				
		char * dir = strtok(path_bk,"/");
80003728:	4b 57       	lddpc	r7,800037fc <fl_write_func+0x128>
8000372a:	0e 9b       	mov	r11,r7
8000372c:	06 9c       	mov	r12,r3
8000372e:	f0 1f 00 3e 	mcall	80003824 <fl_write_func+0x150>
		sprintf(filename,"//%s", dir);		
80003732:	1a dc       	st.w	--sp,r12
80003734:	4b db       	lddpc	r11,80003828 <fl_write_func+0x154>
80003736:	4b ec       	lddpc	r12,8000382c <fl_write_func+0x158>
80003738:	f0 1f 00 3e 	mcall	80003830 <fl_write_func+0x15c>
		dir = strtok(NULL,"/");
8000373c:	0e 9b       	mov	r11,r7
8000373e:	30 0c       	mov	r12,0
80003740:	f0 1f 00 39 	mcall	80003824 <fl_write_func+0x150>
80003744:	18 97       	mov	r7,r12
		while(TRUE)
		{
			if(NULL != dir)
80003746:	2f fd       	sub	sp,-4
80003748:	58 0c       	cp.w	r12,0
8000374a:	c2 50       	breq	80003794 <fl_write_func+0xc0>
			{				
				res = f_mkdir(filename);
8000374c:	4b 83       	lddpc	r3,8000382c <fl_write_func+0x158>
				if((res == FR_OK) || (res == FR_EXIST))
8000374e:	30 02       	mov	r2,0
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003750:	4b 90       	lddpc	r0,80003834 <fl_write_func+0x160>
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
			{				
				res = f_mkdir(filename);
80003752:	06 9c       	mov	r12,r3
80003754:	f0 1f 00 39 	mcall	80003838 <fl_write_func+0x164>
				if((res == FR_OK) || (res == FR_EXIST))
80003758:	5f 09       	sreq	r9
8000375a:	58 8c       	cp.w	r12,8
8000375c:	5f 08       	sreq	r8
8000375e:	f3 e8 10 08 	or	r8,r9,r8
80003762:	e4 08 18 00 	cp.b	r8,r2
80003766:	c1 00       	breq	80003786 <fl_write_func+0xb2>
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003768:	1a d7       	st.w	--sp,r7
8000376a:	1a d3       	st.w	--sp,r3
8000376c:	00 9b       	mov	r11,r0
8000376e:	06 9c       	mov	r12,r3
80003770:	f0 1f 00 30 	mcall	80003830 <fl_write_func+0x15c>
					dir = strtok(NULL,"/");					
80003774:	4a 2b       	lddpc	r11,800037fc <fl_write_func+0x128>
80003776:	30 0c       	mov	r12,0
80003778:	f0 1f 00 2b 	mcall	80003824 <fl_write_func+0x150>
8000377c:	18 97       	mov	r7,r12
		char * dir = strtok(path_bk,"/");
		sprintf(filename,"//%s", dir);		
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
8000377e:	2f ed       	sub	sp,-8
80003780:	58 0c       	cp.w	r12,0
80003782:	ce 81       	brne	80003752 <fl_write_func+0x7e>
80003784:	c0 88       	rjmp	80003794 <fl_write_func+0xc0>
					sprintf(filename,"%s//%s", filename, dir);
					dir = strtok(NULL,"/");					
				}
				else
				{
					f_mount(NULL, "/", 1);	
80003786:	30 1a       	mov	r10,1
80003788:	49 db       	lddpc	r11,800037fc <fl_write_func+0x128>
8000378a:	30 0c       	mov	r12,0
8000378c:	f0 1f 00 1e 	mcall	80003804 <fl_write_func+0x130>
80003790:	30 4c       	mov	r12,4
					return new_dir_err;
80003792:	c3 38       	rjmp	800037f8 <fl_write_func+0x124>
				}
				
			}
			else
			{
				res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
80003794:	31 2a       	mov	r10,18
80003796:	02 9b       	mov	r11,r1
80003798:	49 cc       	lddpc	r12,80003808 <fl_write_func+0x134>
8000379a:	f0 1f 00 1d 	mcall	8000380c <fl_write_func+0x138>
				if(res != FR_OK)
8000379e:	c1 10       	breq	800037c0 <fl_write_func+0xec>
				{					
					f_mount(NULL, "/", 1);	
800037a0:	30 1a       	mov	r10,1
800037a2:	49 7b       	lddpc	r11,800037fc <fl_write_func+0x128>
800037a4:	30 0c       	mov	r12,0
800037a6:	f0 1f 00 18 	mcall	80003804 <fl_write_func+0x130>
800037aa:	30 3c       	mov	r12,3
					return open_fl_err;
800037ac:	c2 68       	rjmp	800037f8 <fl_write_func+0x124>
				}
				break;
			}
		}
	}
	else if(res != FR_OK)
800037ae:	58 0c       	cp.w	r12,0
800037b0:	c0 80       	breq	800037c0 <fl_write_func+0xec>
	{
		f_mount(NULL, "/", 1);
800037b2:	30 1a       	mov	r10,1
800037b4:	49 2b       	lddpc	r11,800037fc <fl_write_func+0x128>
800037b6:	30 0c       	mov	r12,0
800037b8:	f0 1f 00 13 	mcall	80003804 <fl_write_func+0x130>
800037bc:	30 3c       	mov	r12,3
		return open_fl_err;
800037be:	c1 d8       	rjmp	800037f8 <fl_write_func+0x124>
	}
	
	if(offset == FILE_END)
800037c0:	5b f6       	cp.w	r6,-1
800037c2:	c0 61       	brne	800037ce <fl_write_func+0xfa>
	{
		f_lseek(&fl, fl.fsize);
800037c4:	49 1c       	lddpc	r12,80003808 <fl_write_func+0x134>
800037c6:	78 3b       	ld.w	r11,r12[0xc]
800037c8:	f0 1f 00 1d 	mcall	8000383c <fl_write_func+0x168>
800037cc:	c0 58       	rjmp	800037d6 <fl_write_func+0x102>
	}
	else
	{
		f_lseek(&fl, offset);
800037ce:	0c 9b       	mov	r11,r6
800037d0:	48 ec       	lddpc	r12,80003808 <fl_write_func+0x134>
800037d2:	f0 1f 00 1b 	mcall	8000383c <fl_write_func+0x168>
	}
	
	UINT w;
	f_write (&fl, buffer, length, &w );
800037d6:	48 d7       	lddpc	r7,80003808 <fl_write_func+0x134>
800037d8:	1a 99       	mov	r9,sp
800037da:	0a 9a       	mov	r10,r5
800037dc:	08 9b       	mov	r11,r4
800037de:	0e 9c       	mov	r12,r7
800037e0:	f0 1f 00 18 	mcall	80003840 <fl_write_func+0x16c>

	f_close (&fl);
800037e4:	0e 9c       	mov	r12,r7
800037e6:	f0 1f 00 18 	mcall	80003844 <fl_write_func+0x170>
		
	f_mount(NULL, "/", 1);	
800037ea:	30 1a       	mov	r10,1
800037ec:	48 4b       	lddpc	r11,800037fc <fl_write_func+0x128>
800037ee:	30 0c       	mov	r12,0
800037f0:	f0 1f 00 05 	mcall	80003804 <fl_write_func+0x130>
800037f4:	c0 28       	rjmp	800037f8 <fl_write_func+0x124>
}
800037f6:	30 2c       	mov	r12,2
800037f8:	2f fd       	sub	sp,-4
800037fa:	d8 32       	popm	r0-r7,pc
800037fc:	80 01       	ld.sh	r1,r0[0x0]
800037fe:	0a 04       	add	r4,r5
80003800:	00 00       	add	r0,r0
80003802:	0a b4       	st.h	r5++,r4
80003804:	80 00       	ld.sh	r0,r0[0x0]
80003806:	74 14       	ld.w	r4,r10[0x4]
80003808:	00 00       	add	r0,r0
8000380a:	0d cc       	ld.ub	r12,r6[0x4]
8000380c:	80 00       	ld.sh	r0,r0[0x0]
8000380e:	83 e0       	st.w	r1[0x38],r0
80003810:	00 00       	add	r0,r0
80003812:	0c e4       	st.h	--r6,r4
80003814:	80 00       	ld.sh	r0,r0[0x0]
80003816:	81 a4       	st.w	r0[0x28],r4
80003818:	80 00       	ld.sh	r0,r0[0x0]
8000381a:	ad d6       	cbr	r6,0xd
8000381c:	00 00       	add	r0,r0
8000381e:	0d 48       	ld.w	r8,--r6
80003820:	80 00       	ld.sh	r0,r0[0x0]
80003822:	a9 52       	asr	r2,0x9
80003824:	80 00       	ld.sh	r0,r0[0x0]
80003826:	ae 0c       	st.h	r7[0x0],r12
80003828:	80 01       	ld.sh	r1,r0[0x0]
8000382a:	0a 20       	rsub	r0,r5
8000382c:	00 00       	add	r0,r0
8000382e:	0d 8c       	ld.ub	r12,r6[0x0]
80003830:	80 00       	ld.sh	r0,r0[0x0]
80003832:	ad 88       	lsr	r8,0xc
80003834:	80 01       	ld.sh	r1,r0[0x0]
80003836:	0a 28       	rsub	r8,r5
80003838:	80 00       	ld.sh	r0,r0[0x0]
8000383a:	82 28       	ld.sh	r8,r1[0x4]
8000383c:	80 00       	ld.sh	r0,r0[0x0]
8000383e:	86 80       	ld.uh	r0,r3[0x0]
80003840:	80 00       	ld.sh	r0,r0[0x0]
80003842:	89 34       	st.w	r4[0xc],r4
80003844:	80 00       	ld.sh	r0,r0[0x0]
80003846:	75 60       	ld.w	r0,r10[0x58]

80003848 <fl_read_func>:



fs_err_t fl_read_func(void * path, S32 offset, void * buffer, U32 length)
{
80003848:	d4 31       	pushm	r0-r7,lr
8000384a:	20 1d       	sub	sp,4
8000384c:	18 97       	mov	r7,r12
8000384e:	16 96       	mov	r6,r11
80003850:	14 94       	mov	r4,r10
80003852:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
80003854:	30 1a       	mov	r10,1
80003856:	4c 7b       	lddpc	r11,80003970 <fl_read_func+0x128>
80003858:	4c 7c       	lddpc	r12,80003974 <fl_read_func+0x12c>
8000385a:	f0 1f 00 48 	mcall	80003978 <fl_read_func+0x130>
8000385e:	e0 81 00 86 	brne	8000396a <fl_read_func+0x122>
		{
			return amount_err;
		}
	
		FRESULT res	= f_open (&fl, path, FA_READ | FA_OPEN_EXISTING);
80003862:	0e 91       	mov	r1,r7
80003864:	30 1a       	mov	r10,1
80003866:	0e 9b       	mov	r11,r7
80003868:	4c 5c       	lddpc	r12,8000397c <fl_read_func+0x134>
8000386a:	f0 1f 00 46 	mcall	80003980 <fl_read_func+0x138>
		if(FR_NO_PATH == res)
8000386e:	58 5c       	cp.w	r12,5
80003870:	c5 91       	brne	80003922 <fl_read_func+0xda>
		{
			if ( f_opendir(&dirs, "/") != FR_OK)
80003872:	4c 0b       	lddpc	r11,80003970 <fl_read_func+0x128>
80003874:	4c 4c       	lddpc	r12,80003984 <fl_read_func+0x13c>
80003876:	f0 1f 00 45 	mcall	80003988 <fl_read_func+0x140>
8000387a:	c0 80       	breq	8000388a <fl_read_func+0x42>
			{
				f_mount(NULL, "/", 1);
8000387c:	30 1a       	mov	r10,1
8000387e:	4b db       	lddpc	r11,80003970 <fl_read_func+0x128>
80003880:	30 0c       	mov	r12,0
80003882:	f0 1f 00 3e 	mcall	80003978 <fl_read_func+0x130>
80003886:	30 6c       	mov	r12,6
				return fs_err;
80003888:	c7 28       	rjmp	8000396c <fl_read_func+0x124>
			}
		
			static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
			memcpy(path_bk, path, strlen(path));
8000388a:	0e 9c       	mov	r12,r7
8000388c:	f0 1f 00 40 	mcall	8000398c <fl_read_func+0x144>
80003890:	4c 03       	lddpc	r3,80003990 <fl_read_func+0x148>
80003892:	18 9a       	mov	r10,r12
80003894:	0e 9b       	mov	r11,r7
80003896:	06 9c       	mov	r12,r3
80003898:	f0 1f 00 3f 	mcall	80003994 <fl_read_func+0x14c>
				
			char * dir = strtok(path_bk,"/");
8000389c:	4b 57       	lddpc	r7,80003970 <fl_read_func+0x128>
8000389e:	0e 9b       	mov	r11,r7
800038a0:	06 9c       	mov	r12,r3
800038a2:	f0 1f 00 3e 	mcall	80003998 <fl_read_func+0x150>
			sprintf(filename,"//%s", dir);		
800038a6:	1a dc       	st.w	--sp,r12
800038a8:	4b db       	lddpc	r11,8000399c <fl_read_func+0x154>
800038aa:	4b ec       	lddpc	r12,800039a0 <fl_read_func+0x158>
800038ac:	f0 1f 00 3e 	mcall	800039a4 <fl_read_func+0x15c>
			dir = strtok(NULL,"/");
800038b0:	0e 9b       	mov	r11,r7
800038b2:	30 0c       	mov	r12,0
800038b4:	f0 1f 00 39 	mcall	80003998 <fl_read_func+0x150>
800038b8:	18 97       	mov	r7,r12
			while(TRUE)
			{
				if(NULL != dir)
800038ba:	2f fd       	sub	sp,-4
800038bc:	58 0c       	cp.w	r12,0
800038be:	c2 50       	breq	80003908 <fl_read_func+0xc0>
				{				
					res = f_mkdir(filename);
800038c0:	4b 83       	lddpc	r3,800039a0 <fl_read_func+0x158>
					if((res == FR_OK) || (res == FR_EXIST))
800038c2:	30 02       	mov	r2,0
					{					
						sprintf(filename,"%s//%s", filename, dir);
800038c4:	4b 90       	lddpc	r0,800039a8 <fl_read_func+0x160>
			dir = strtok(NULL,"/");
			while(TRUE)
			{
				if(NULL != dir)
				{				
					res = f_mkdir(filename);
800038c6:	06 9c       	mov	r12,r3
800038c8:	f0 1f 00 39 	mcall	800039ac <fl_read_func+0x164>
					if((res == FR_OK) || (res == FR_EXIST))
800038cc:	5f 09       	sreq	r9
800038ce:	58 8c       	cp.w	r12,8
800038d0:	5f 08       	sreq	r8
800038d2:	f3 e8 10 08 	or	r8,r9,r8
800038d6:	e4 08 18 00 	cp.b	r8,r2
800038da:	c1 00       	breq	800038fa <fl_read_func+0xb2>
					{					
						sprintf(filename,"%s//%s", filename, dir);
800038dc:	1a d7       	st.w	--sp,r7
800038de:	1a d3       	st.w	--sp,r3
800038e0:	00 9b       	mov	r11,r0
800038e2:	06 9c       	mov	r12,r3
800038e4:	f0 1f 00 30 	mcall	800039a4 <fl_read_func+0x15c>
						dir = strtok(NULL,"/");					
800038e8:	4a 2b       	lddpc	r11,80003970 <fl_read_func+0x128>
800038ea:	30 0c       	mov	r12,0
800038ec:	f0 1f 00 2b 	mcall	80003998 <fl_read_func+0x150>
800038f0:	18 97       	mov	r7,r12
			char * dir = strtok(path_bk,"/");
			sprintf(filename,"//%s", dir);		
			dir = strtok(NULL,"/");
			while(TRUE)
			{
				if(NULL != dir)
800038f2:	2f ed       	sub	sp,-8
800038f4:	58 0c       	cp.w	r12,0
800038f6:	ce 81       	brne	800038c6 <fl_read_func+0x7e>
800038f8:	c0 88       	rjmp	80003908 <fl_read_func+0xc0>
						sprintf(filename,"%s//%s", filename, dir);
						dir = strtok(NULL,"/");					
					}
					else
					{
						f_mount(NULL, "/", 1);	
800038fa:	30 1a       	mov	r10,1
800038fc:	49 db       	lddpc	r11,80003970 <fl_read_func+0x128>
800038fe:	30 0c       	mov	r12,0
80003900:	f0 1f 00 1e 	mcall	80003978 <fl_read_func+0x130>
80003904:	30 4c       	mov	r12,4
						return new_dir_err;
80003906:	c3 38       	rjmp	8000396c <fl_read_func+0x124>
					}
				
				}
				else
				{
					res	= f_open (&fl, path, FA_READ | FA_OPEN_EXISTING);
80003908:	30 1a       	mov	r10,1
8000390a:	02 9b       	mov	r11,r1
8000390c:	49 cc       	lddpc	r12,8000397c <fl_read_func+0x134>
8000390e:	f0 1f 00 1d 	mcall	80003980 <fl_read_func+0x138>
					if(res != FR_OK)
80003912:	c1 10       	breq	80003934 <fl_read_func+0xec>
					{					
						f_mount(NULL, "/", 1);	
80003914:	30 1a       	mov	r10,1
80003916:	49 7b       	lddpc	r11,80003970 <fl_read_func+0x128>
80003918:	30 0c       	mov	r12,0
8000391a:	f0 1f 00 18 	mcall	80003978 <fl_read_func+0x130>
8000391e:	30 3c       	mov	r12,3
						return open_fl_err;
80003920:	c2 68       	rjmp	8000396c <fl_read_func+0x124>
					}
					break;
				}
			}
		}
		else if(res != FR_OK)
80003922:	58 0c       	cp.w	r12,0
80003924:	c0 80       	breq	80003934 <fl_read_func+0xec>
		{
			f_mount(NULL, "/", 1);
80003926:	30 1a       	mov	r10,1
80003928:	49 2b       	lddpc	r11,80003970 <fl_read_func+0x128>
8000392a:	30 0c       	mov	r12,0
8000392c:	f0 1f 00 13 	mcall	80003978 <fl_read_func+0x130>
80003930:	30 3c       	mov	r12,3
			return open_fl_err;
80003932:	c1 d8       	rjmp	8000396c <fl_read_func+0x124>
		}
	
		if(offset == FILE_END)
80003934:	5b f6       	cp.w	r6,-1
80003936:	c0 61       	brne	80003942 <fl_read_func+0xfa>
		{
			f_lseek(&fl, fl.fsize);
80003938:	49 1c       	lddpc	r12,8000397c <fl_read_func+0x134>
8000393a:	78 3b       	ld.w	r11,r12[0xc]
8000393c:	f0 1f 00 1d 	mcall	800039b0 <fl_read_func+0x168>
80003940:	c0 58       	rjmp	8000394a <fl_read_func+0x102>
		}
		else
		{
			f_lseek(&fl, offset);
80003942:	0c 9b       	mov	r11,r6
80003944:	48 ec       	lddpc	r12,8000397c <fl_read_func+0x134>
80003946:	f0 1f 00 1b 	mcall	800039b0 <fl_read_func+0x168>
		}
	
		UINT w;
		f_read (&fl, buffer, length, &w );
8000394a:	48 d7       	lddpc	r7,8000397c <fl_read_func+0x134>
8000394c:	1a 99       	mov	r9,sp
8000394e:	0a 9a       	mov	r10,r5
80003950:	08 9b       	mov	r11,r4
80003952:	0e 9c       	mov	r12,r7
80003954:	f0 1f 00 18 	mcall	800039b4 <fl_read_func+0x16c>

		f_close (&fl);
80003958:	0e 9c       	mov	r12,r7
8000395a:	f0 1f 00 18 	mcall	800039b8 <fl_read_func+0x170>
		
		f_mount(NULL, "/", 1);		
8000395e:	30 1a       	mov	r10,1
80003960:	48 4b       	lddpc	r11,80003970 <fl_read_func+0x128>
80003962:	30 0c       	mov	r12,0
80003964:	f0 1f 00 05 	mcall	80003978 <fl_read_func+0x130>
80003968:	c0 28       	rjmp	8000396c <fl_read_func+0x124>
	
	
	
	
	
}
8000396a:	30 2c       	mov	r12,2
8000396c:	2f fd       	sub	sp,-4
8000396e:	d8 32       	popm	r0-r7,pc
80003970:	80 01       	ld.sh	r1,r0[0x0]
80003972:	0a 04       	add	r4,r5
80003974:	00 00       	add	r0,r0
80003976:	0a b4       	st.h	r5++,r4
80003978:	80 00       	ld.sh	r0,r0[0x0]
8000397a:	74 14       	ld.w	r4,r10[0x4]
8000397c:	00 00       	add	r0,r0
8000397e:	0d cc       	ld.ub	r12,r6[0x4]
80003980:	80 00       	ld.sh	r0,r0[0x0]
80003982:	83 e0       	st.w	r1[0x38],r0
80003984:	00 00       	add	r0,r0
80003986:	0c e4       	st.h	--r6,r4
80003988:	80 00       	ld.sh	r0,r0[0x0]
8000398a:	81 a4       	st.w	r0[0x28],r4
8000398c:	80 00       	ld.sh	r0,r0[0x0]
8000398e:	ad d6       	cbr	r6,0xd
80003990:	00 00       	add	r0,r0
80003992:	0a 70       	tst	r0,r5
80003994:	80 00       	ld.sh	r0,r0[0x0]
80003996:	a9 52       	asr	r2,0x9
80003998:	80 00       	ld.sh	r0,r0[0x0]
8000399a:	ae 0c       	st.h	r7[0x0],r12
8000399c:	80 01       	ld.sh	r1,r0[0x0]
8000399e:	0a 20       	rsub	r0,r5
800039a0:	00 00       	add	r0,r0
800039a2:	0d 04       	ld.w	r4,r6++
800039a4:	80 00       	ld.sh	r0,r0[0x0]
800039a6:	ad 88       	lsr	r8,0xc
800039a8:	80 01       	ld.sh	r1,r0[0x0]
800039aa:	0a 28       	rsub	r8,r5
800039ac:	80 00       	ld.sh	r0,r0[0x0]
800039ae:	82 28       	ld.sh	r8,r1[0x4]
800039b0:	80 00       	ld.sh	r0,r0[0x0]
800039b2:	86 80       	ld.uh	r0,r3[0x0]
800039b4:	80 00       	ld.sh	r0,r0[0x0]
800039b6:	8b 14       	st.w	r5[0x4],r4
800039b8:	80 00       	ld.sh	r0,r0[0x0]
800039ba:	75 60       	ld.w	r0,r10[0x58]

800039bc <fl_oper_process>:



static void fl_oper_process(void * pvParameters)
{
800039bc:	eb cd 40 fc 	pushm	r2-r7,lr
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
800039c0:	30 8c       	mov	r12,8
800039c2:	f0 1f 00 23 	mcall	80003a4c <fl_oper_process+0x90>
800039c6:	18 97       	mov	r7,r12
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
800039c8:	4a 26       	lddpc	r6,80003a50 <fl_oper_process+0x94>
800039ca:	30 05       	mov	r5,0
800039cc:	3f f4       	mov	r4,-1
		{  
			switch(fl_oper->opcode)
800039ce:	e0 63 40 00 	mov	r3,16384
800039d2:	e0 62 40 01 	mov	r2,16385
static void fl_oper_process(void * pvParameters)
{
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
800039d6:	6c 0c       	ld.w	r12,r6[0x0]
800039d8:	0a 99       	mov	r9,r5
800039da:	08 9a       	mov	r10,r4
800039dc:	0e 9b       	mov	r11,r7
800039de:	f0 1f 00 1e 	mcall	80003a54 <fl_oper_process+0x98>
800039e2:	58 1c       	cp.w	r12,1
800039e4:	cf 91       	brne	800039d6 <fl_oper_process+0x1a>
		{  
			switch(fl_oper->opcode)
800039e6:	8e 08       	ld.sh	r8,r7[0x0]
800039e8:	e6 08 19 00 	cp.h	r8,r3
800039ec:	c0 50       	breq	800039f6 <fl_oper_process+0x3a>
800039ee:	e4 08 19 00 	cp.h	r8,r2
800039f2:	c2 61       	brne	80003a3e <fl_oper_process+0x82>
800039f4:	c1 38       	rjmp	80003a1a <fl_oper_process+0x5e>
			{
			case FL_WRITE:
			
				if(NULL != fl_oper->payload)
800039f6:	6e 1c       	ld.w	r12,r7[0x4]
800039f8:	58 0c       	cp.w	r12,0
800039fa:	ce e0       	breq	800039d6 <fl_oper_process+0x1a>
				{
					if(NULL != ((fl_write_t *)(fl_oper->payload))->buffer)
800039fc:	79 2a       	ld.w	r10,r12[0x48]
800039fe:	58 0a       	cp.w	r10,0
80003a00:	c0 90       	breq	80003a12 <fl_oper_process+0x56>
					{
						fl_write_func(((fl_write_t *)(fl_oper->payload))->path
80003a02:	79 19       	ld.w	r9,r12[0x44]
80003a04:	79 0b       	ld.w	r11,r12[0x40]
80003a06:	f0 1f 00 15 	mcall	80003a58 <fl_oper_process+0x9c>
							, ((fl_write_t *)(fl_oper->payload))->offset
							, ((fl_write_t *)(fl_oper->payload))->buffer
							, ((fl_write_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_write_t *)(fl_oper->payload))->buffer);
80003a0a:	6e 18       	ld.w	r8,r7[0x4]
80003a0c:	71 2c       	ld.w	r12,r8[0x48]
80003a0e:	f0 1f 00 14 	mcall	80003a5c <fl_oper_process+0xa0>
					}
					vPortFree(fl_oper->payload);					
80003a12:	6e 1c       	ld.w	r12,r7[0x4]
80003a14:	f0 1f 00 12 	mcall	80003a5c <fl_oper_process+0xa0>
80003a18:	cd fb       	rjmp	800039d6 <fl_oper_process+0x1a>
				}
				break;
				
			case FL_READ:
			
				if(NULL != fl_oper->payload)
80003a1a:	6e 1c       	ld.w	r12,r7[0x4]
80003a1c:	58 0c       	cp.w	r12,0
80003a1e:	cd c0       	breq	800039d6 <fl_oper_process+0x1a>
				{
					if(NULL != ((fl_read_t *)(fl_oper->payload))->buffer)
80003a20:	79 2a       	ld.w	r10,r12[0x48]
80003a22:	58 0a       	cp.w	r10,0
80003a24:	c0 90       	breq	80003a36 <fl_oper_process+0x7a>
					{
						fl_read_func(((fl_read_t *)(fl_oper->payload))->path
80003a26:	79 19       	ld.w	r9,r12[0x44]
80003a28:	79 0b       	ld.w	r11,r12[0x40]
80003a2a:	f0 1f 00 0e 	mcall	80003a60 <fl_oper_process+0xa4>
						, ((fl_read_t *)(fl_oper->payload))->offset
						, ((fl_read_t *)(fl_oper->payload))->buffer
						, ((fl_read_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_read_t *)(fl_oper->payload))->buffer);
80003a2e:	6e 18       	ld.w	r8,r7[0x4]
80003a30:	71 2c       	ld.w	r12,r8[0x48]
80003a32:	f0 1f 00 0b 	mcall	80003a5c <fl_oper_process+0xa0>
					}
					vPortFree(fl_oper->payload);
80003a36:	6e 1c       	ld.w	r12,r7[0x4]
80003a38:	f0 1f 00 09 	mcall	80003a5c <fl_oper_process+0xa0>
80003a3c:	cc db       	rjmp	800039d6 <fl_oper_process+0x1a>
				break;
			
			   
								
			default:
				if(NULL != fl_oper->payload)
80003a3e:	6e 1c       	ld.w	r12,r7[0x4]
80003a40:	58 0c       	cp.w	r12,0
80003a42:	cc a0       	breq	800039d6 <fl_oper_process+0x1a>
				{
					vPortFree(fl_oper->payload);
80003a44:	f0 1f 00 06 	mcall	80003a5c <fl_oper_process+0xa0>
80003a48:	cc 7b       	rjmp	800039d6 <fl_oper_process+0x1a>
80003a4a:	00 00       	add	r0,r0
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	90 48       	ld.sh	r8,r8[0x8]
80003a50:	00 00       	add	r0,r0
80003a52:	0d 44       	ld.w	r4,--r6
80003a54:	80 00       	ld.sh	r0,r0[0x0]
80003a56:	91 90       	st.w	r8[0x24],r0
80003a58:	80 00       	ld.sh	r0,r0[0x0]
80003a5a:	36 d4       	mov	r4,109
80003a5c:	80 00       	ld.sh	r0,r0[0x0]
80003a5e:	90 20       	ld.sh	r0,r8[0x4]
80003a60:	80 00       	ld.sh	r0,r0[0x0]
80003a62:	38 48       	mov	r8,-124

80003a64 <disk_init>:
APP_RES_OKDISK_OPERATION_ERRORSDFILE_OPERATION_ERROR
*/
//

fs_err_t disk_init(void)
{
80003a64:	d4 01       	pushm	lr
80003a66:	20 3d       	sub	sp,12
	char str[MAX_DISK_LABEL_SIZE];
	
	/*initialize disk*/
	if(MAL_InitConfig())
80003a68:	f0 1f 00 41 	mcall	80003b6c <disk_init+0x108>
80003a6c:	5c 8c       	casts.h	r12
80003a6e:	c0 30       	breq	80003a74 <disk_init+0x10>
80003a70:	30 1c       	mov	r12,1
80003a72:	c7 a8       	rjmp	80003b66 <disk_init+0x102>
	{
		return disk_err;
	}	
		
	if(f_mount(&fs, "/", 1) != FR_OK)
80003a74:	30 1a       	mov	r10,1
80003a76:	4b fb       	lddpc	r11,80003b70 <disk_init+0x10c>
80003a78:	4b fc       	lddpc	r12,80003b74 <disk_init+0x110>
80003a7a:	f0 1f 00 40 	mcall	80003b78 <disk_init+0x114>
80003a7e:	c0 30       	breq	80003a84 <disk_init+0x20>
80003a80:	30 2c       	mov	r12,2
80003a82:	c7 28       	rjmp	80003b66 <disk_init+0x102>
	{
		return amount_err;
	}
	
	FRESULT res = f_getfree("/", &clust, &pfs);
80003a84:	4b ea       	lddpc	r10,80003b7c <disk_init+0x118>
80003a86:	4b fb       	lddpc	r11,80003b80 <disk_init+0x11c>
80003a88:	4b ac       	lddpc	r12,80003b70 <disk_init+0x10c>
80003a8a:	f0 1f 00 3f 	mcall	80003b84 <disk_init+0x120>
	if(res == FR_NO_FILESYSTEM) 
80003a8e:	58 dc       	cp.w	r12,13
80003a90:	c1 41       	brne	80003ab8 <disk_init+0x54>
	{
		/* Create a file system on the drive */
		res = f_mkfs (0, 0, 4096);
80003a92:	e0 6a 10 00 	mov	r10,4096
80003a96:	30 0b       	mov	r11,0
80003a98:	16 9c       	mov	r12,r11
80003a9a:	f0 1f 00 3c 	mcall	80003b88 <disk_init+0x124>
		if( f_getfree("/", &clust, &pfs) != FR_OK)
80003a9e:	4b 8a       	lddpc	r10,80003b7c <disk_init+0x118>
80003aa0:	4b 8b       	lddpc	r11,80003b80 <disk_init+0x11c>
80003aa2:	4b 4c       	lddpc	r12,80003b70 <disk_init+0x10c>
80003aa4:	f0 1f 00 38 	mcall	80003b84 <disk_init+0x120>
80003aa8:	c1 10       	breq	80003aca <disk_init+0x66>
		{
			f_mount(NULL, "/", 1);	
80003aaa:	30 1a       	mov	r10,1
80003aac:	4b 1b       	lddpc	r11,80003b70 <disk_init+0x10c>
80003aae:	30 0c       	mov	r12,0
80003ab0:	f0 1f 00 32 	mcall	80003b78 <disk_init+0x114>
80003ab4:	30 5c       	mov	r12,5
			return no_fs;
80003ab6:	c5 88       	rjmp	80003b66 <disk_init+0x102>
		}
	}
	else if(res != FR_OK)
80003ab8:	58 0c       	cp.w	r12,0
80003aba:	c0 80       	breq	80003aca <disk_init+0x66>
	{
		f_mount(NULL, "/", 1);
80003abc:	30 1a       	mov	r10,1
80003abe:	4a db       	lddpc	r11,80003b70 <disk_init+0x10c>
80003ac0:	30 0c       	mov	r12,0
80003ac2:	f0 1f 00 2e 	mcall	80003b78 <disk_init+0x114>
80003ac6:	30 6c       	mov	r12,6
		return fs_err;
80003ac8:	c4 f8       	rjmp	80003b66 <disk_init+0x102>
	}
	
	
	//pdisk->freecap = ((clust*(pfs->csize)/1024/1024)*512);
	
	memset(str,0,MAX_DISK_LABEL_SIZE);
80003aca:	1a 9b       	mov	r11,sp
80003acc:	30 08       	mov	r8,0
80003ace:	30 09       	mov	r9,0
80003ad0:	fa e9 00 00 	st.d	sp[0],r8
80003ad4:	30 0a       	mov	r10,0
80003ad6:	50 2a       	stdsp	sp[0x8],r10
	if(f_getlabel("/", str, 0) != FR_OK)
80003ad8:	4a 6c       	lddpc	r12,80003b70 <disk_init+0x10c>
80003ada:	f0 1f 00 2d 	mcall	80003b8c <disk_init+0x128>
80003ade:	c0 80       	breq	80003aee <disk_init+0x8a>
	{
		f_mount(NULL, "/", 1);
80003ae0:	30 1a       	mov	r10,1
80003ae2:	4a 4b       	lddpc	r11,80003b70 <disk_init+0x10c>
80003ae4:	30 0c       	mov	r12,0
80003ae6:	f0 1f 00 25 	mcall	80003b78 <disk_init+0x114>
80003aea:	30 6c       	mov	r12,6
		return fs_err;
80003aec:	c3 d8       	rjmp	80003b66 <disk_init+0x102>
	}
		
	if(memcmp(DiskLabel, str, sizeof(DiskLabel) - 1) != 0)
80003aee:	30 7a       	mov	r10,7
80003af0:	1a 9b       	mov	r11,sp
80003af2:	4a 8c       	lddpc	r12,80003b90 <disk_init+0x12c>
80003af4:	f0 1f 00 28 	mcall	80003b94 <disk_init+0x130>
80003af8:	c0 c0       	breq	80003b10 <disk_init+0xac>
	{
		if(f_setlabel("MOTOREC") != FR_OK)
80003afa:	4a 8c       	lddpc	r12,80003b98 <disk_init+0x134>
80003afc:	f0 1f 00 28 	mcall	80003b9c <disk_init+0x138>
80003b00:	c0 80       	breq	80003b10 <disk_init+0xac>
		{
			f_mount(NULL, "/", 1);
80003b02:	30 1a       	mov	r10,1
80003b04:	49 bb       	lddpc	r11,80003b70 <disk_init+0x10c>
80003b06:	30 0c       	mov	r12,0
80003b08:	f0 1f 00 1c 	mcall	80003b78 <disk_init+0x114>
80003b0c:	30 6c       	mov	r12,6
			return fs_err;
80003b0e:	c2 c8       	rjmp	80003b66 <disk_init+0x102>
		}
	}
			
	if ( f_opendir(&dirs, "/") == FR_OK)
80003b10:	49 8b       	lddpc	r11,80003b70 <disk_init+0x10c>
80003b12:	4a 4c       	lddpc	r12,80003ba0 <disk_init+0x13c>
80003b14:	f0 1f 00 24 	mcall	80003ba4 <disk_init+0x140>
80003b18:	c2 11       	brne	80003b5a <disk_init+0xf6>
	{
		if(f_open(&fl, "sys.ini", FA_CREATE_ALWAYS | FA_WRITE) == FR_OK )
80003b1a:	30 aa       	mov	r10,10
80003b1c:	4a 3b       	lddpc	r11,80003ba8 <disk_init+0x144>
80003b1e:	4a 4c       	lddpc	r12,80003bac <disk_init+0x148>
80003b20:	f0 1f 00 24 	mcall	80003bb0 <disk_init+0x14c>
80003b24:	c1 41       	brne	80003b4c <disk_init+0xe8>
		{
			f_close(&fl);
80003b26:	4a 2c       	lddpc	r12,80003bac <disk_init+0x148>
80003b28:	f0 1f 00 23 	mcall	80003bb4 <disk_init+0x150>
		{
			f_mount(NULL, "/", 1);
			return fs_err;
		}
				
		f_mkdir("/REC");			
80003b2c:	4a 3c       	lddpc	r12,80003bb8 <disk_init+0x154>
80003b2e:	f0 1f 00 24 	mcall	80003bbc <disk_init+0x158>
		f_mkdir("/REC/ZONE01");			
80003b32:	4a 4c       	lddpc	r12,80003bc0 <disk_init+0x15c>
80003b34:	f0 1f 00 22 	mcall	80003bbc <disk_init+0x158>
		f_mkdir("/REC/ZONE01/CH01");		
80003b38:	4a 3c       	lddpc	r12,80003bc4 <disk_init+0x160>
80003b3a:	f0 1f 00 21 	mcall	80003bbc <disk_init+0x158>
	{
		f_mount(NULL, "/", 1);
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
80003b3e:	30 1a       	mov	r10,1
80003b40:	48 cb       	lddpc	r11,80003b70 <disk_init+0x10c>
80003b42:	30 0c       	mov	r12,0
80003b44:	f0 1f 00 0d 	mcall	80003b78 <disk_init+0x114>
80003b48:	30 0c       	mov	r12,0
	return fs_ok;
80003b4a:	c0 e8       	rjmp	80003b66 <disk_init+0x102>
		{
			f_close(&fl);
		}
		else 
		{
			f_mount(NULL, "/", 1);
80003b4c:	30 1a       	mov	r10,1
80003b4e:	48 9b       	lddpc	r11,80003b70 <disk_init+0x10c>
80003b50:	30 0c       	mov	r12,0
80003b52:	f0 1f 00 0a 	mcall	80003b78 <disk_init+0x114>
80003b56:	30 6c       	mov	r12,6
			return fs_err;
80003b58:	c0 78       	rjmp	80003b66 <disk_init+0x102>
		f_mkdir("/REC/ZONE01");			
		f_mkdir("/REC/ZONE01/CH01");		
	}
	else 
	{
		f_mount(NULL, "/", 1);
80003b5a:	30 1a       	mov	r10,1
80003b5c:	48 5b       	lddpc	r11,80003b70 <disk_init+0x10c>
80003b5e:	30 0c       	mov	r12,0
80003b60:	f0 1f 00 06 	mcall	80003b78 <disk_init+0x114>
80003b64:	30 6c       	mov	r12,6
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
	return fs_ok;
}
80003b66:	2f dd       	sub	sp,-12
80003b68:	d8 02       	popm	pc
80003b6a:	00 00       	add	r0,r0
80003b6c:	80 00       	ld.sh	r0,r0[0x0]
80003b6e:	35 a0       	mov	r0,90
80003b70:	80 01       	ld.sh	r1,r0[0x0]
80003b72:	0a 04       	add	r4,r5
80003b74:	00 00       	add	r0,r0
80003b76:	0a b4       	st.h	r5++,r4
80003b78:	80 00       	ld.sh	r0,r0[0x0]
80003b7a:	74 14       	ld.w	r4,r10[0x4]
80003b7c:	00 00       	add	r0,r0
80003b7e:	0d 88       	ld.ub	r8,r6[0x0]
80003b80:	00 00       	add	r0,r0
80003b82:	0a b0       	st.h	r5++,r0
80003b84:	80 00       	ld.sh	r0,r0[0x0]
80003b86:	85 94       	st.w	r2[0x24],r4
80003b88:	80 00       	ld.sh	r0,r0[0x0]
80003b8a:	68 d8       	ld.w	r8,r4[0x34]
80003b8c:	80 00       	ld.sh	r0,r0[0x0]
80003b8e:	7b 10       	ld.w	r0,sp[0x44]
80003b90:	00 00       	add	r0,r0
80003b92:	04 f4       	st.b	--r2,r4
80003b94:	80 00       	ld.sh	r0,r0[0x0]
80003b96:	a9 2c       	st.d	r4++,r12
80003b98:	80 01       	ld.sh	r1,r0[0x0]
80003b9a:	0a 30       	cp.w	r0,r5
80003b9c:	80 00       	ld.sh	r0,r0[0x0]
80003b9e:	7c 5c       	ld.w	r12,lr[0x14]
80003ba0:	00 00       	add	r0,r0
80003ba2:	0c e4       	st.h	--r6,r4
80003ba4:	80 00       	ld.sh	r0,r0[0x0]
80003ba6:	81 a4       	st.w	r0[0x28],r4
80003ba8:	80 01       	ld.sh	r1,r0[0x0]
80003baa:	0a 38       	cp.w	r8,r5
80003bac:	00 00       	add	r0,r0
80003bae:	0d cc       	ld.ub	r12,r6[0x4]
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	83 e0       	st.w	r1[0x38],r0
80003bb4:	80 00       	ld.sh	r0,r0[0x0]
80003bb6:	75 60       	ld.w	r0,r10[0x58]
80003bb8:	80 01       	ld.sh	r1,r0[0x0]
80003bba:	0a 40       	or	r0,r5
80003bbc:	80 00       	ld.sh	r0,r0[0x0]
80003bbe:	82 28       	ld.sh	r8,r1[0x4]
80003bc0:	80 01       	ld.sh	r1,r0[0x0]
80003bc2:	0a 48       	or	r8,r5
80003bc4:	80 01       	ld.sh	r1,r0[0x0]
80003bc6:	0a 54       	eor	r4,r5

80003bc8 <fs_init>:
}



fs_err_t fs_init(void)
{
80003bc8:	eb cd 40 80 	pushm	r7,lr
	fs_err_t res = disk_init();
80003bcc:	f0 1f 00 0d 	mcall	80003c00 <fs_init+0x38>
80003bd0:	18 97       	mov	r7,r12
	if( fs_ok ==  res)
80003bd2:	c1 31       	brne	80003bf8 <fs_init+0x30>
	{
		fl_oper_queue = xQueueCreate(20, sizeof(fl_oper_t)); //20*512bytes = 10k
80003bd4:	30 8b       	mov	r11,8
80003bd6:	31 4c       	mov	r12,20
80003bd8:	f0 1f 00 0b 	mcall	80003c04 <fs_init+0x3c>
80003bdc:	48 b8       	lddpc	r8,80003c08 <fs_init+0x40>
80003bde:	91 0c       	st.w	r8[0x0],r12
		
		/*create a task for files operation*/
		xTaskCreate(
80003be0:	30 09       	mov	r9,0
80003be2:	1a d9       	st.w	--sp,r9
80003be4:	1a d9       	st.w	--sp,r9
80003be6:	1a d9       	st.w	--sp,r9
80003be8:	30 28       	mov	r8,2
80003bea:	e0 6a 02 00 	mov	r10,512
80003bee:	48 8b       	lddpc	r11,80003c0c <fs_init+0x44>
80003bf0:	48 8c       	lddpc	r12,80003c10 <fs_init+0x48>
80003bf2:	f0 1f 00 09 	mcall	80003c14 <fs_init+0x4c>
		,  NULL
		,  2//1
		,  NULL
		);		
		
		return fs_ok;		
80003bf6:	2f dd       	sub	sp,-12
	}
	else
	{
		return res;
	}
}
80003bf8:	0e 9c       	mov	r12,r7
80003bfa:	e3 cd 80 80 	ldm	sp++,r7,pc
80003bfe:	00 00       	add	r0,r0
80003c00:	80 00       	ld.sh	r0,r0[0x0]
80003c02:	3a 64       	mov	r4,-90
80003c04:	80 00       	ld.sh	r0,r0[0x0]
80003c06:	94 f4       	ld.uh	r4,r10[0xe]
80003c08:	00 00       	add	r0,r0
80003c0a:	0d 44       	ld.w	r4,--r6
80003c0c:	80 01       	ld.sh	r1,r0[0x0]
80003c0e:	0a 68       	and	r8,r5
80003c10:	80 00       	ld.sh	r0,r0[0x0]
80003c12:	39 bc       	mov	r12,-101
80003c14:	80 00       	ld.sh	r0,r0[0x0]
80003c16:	9b c8       	st.w	sp[0x30],r8

80003c18 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80003c18:	20 1c       	sub	r12,1
80003c1a:	5c 5c       	castu.b	r12
80003c1c:	31 18       	mov	r8,17
80003c1e:	f0 0c 18 00 	cp.b	r12,r8
80003c22:	e0 88 00 03 	brls	80003c28 <CalculateBurst+0x10>
80003c26:	5e fd       	retal	0
80003c28:	48 28       	lddpc	r8,80003c30 <CalculateBurst+0x18>
80003c2a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003c2e:	5e fc       	retal	r12
80003c30:	80 01       	ld.sh	r1,r0[0x0]
80003c32:	0a 78       	tst	r8,r5

80003c34 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80003c34:	eb cd 40 80 	pushm	r7,lr
	payload_rx_exec = payload_rx_func;
80003c38:	48 f8       	lddpc	r8,80003c74 <payload_init+0x40>
80003c3a:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80003c3c:	48 f8       	lddpc	r8,80003c78 <payload_init+0x44>
80003c3e:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003c40:	30 07       	mov	r7,0
80003c42:	1a d7       	st.w	--sp,r7
80003c44:	1a d7       	st.w	--sp,r7
80003c46:	1a d7       	st.w	--sp,r7
80003c48:	30 28       	mov	r8,2
80003c4a:	0e 99       	mov	r9,r7
80003c4c:	e0 6a 04 00 	mov	r10,1024
80003c50:	48 bb       	lddpc	r11,80003c7c <payload_init+0x48>
80003c52:	48 cc       	lddpc	r12,80003c80 <payload_init+0x4c>
80003c54:	f0 1f 00 0c 	mcall	80003c84 <payload_init+0x50>
	,  2
	,  NULL
	);
	
	/*this task is used to transmit  payload message*/
	xTaskCreate(
80003c58:	1a d7       	st.w	--sp,r7
80003c5a:	1a d7       	st.w	--sp,r7
80003c5c:	1a d7       	st.w	--sp,r7
80003c5e:	30 28       	mov	r8,2
80003c60:	0e 99       	mov	r9,r7
80003c62:	e0 6a 04 00 	mov	r10,1024
80003c66:	48 9b       	lddpc	r11,80003c88 <payload_init+0x54>
80003c68:	48 9c       	lddpc	r12,80003c8c <payload_init+0x58>
80003c6a:	f0 1f 00 07 	mcall	80003c84 <payload_init+0x50>
80003c6e:	2f ad       	sub	sp,-24
	,  2
	,  NULL
	);
	
	
}
80003c70:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c74:	00 00       	add	r0,r0
80003c76:	0f f4       	ld.ub	r4,r7[0x7]
80003c78:	00 00       	add	r0,r0
80003c7a:	0f f8       	ld.ub	r8,r7[0x7]
80003c7c:	80 01       	ld.sh	r1,r0[0x0]
80003c7e:	10 70       	tst	r0,r8
80003c80:	80 00       	ld.sh	r0,r0[0x0]
80003c82:	3c dc       	mov	r12,-51
80003c84:	80 00       	ld.sh	r0,r0[0x0]
80003c86:	9b c8       	st.w	sp[0x30],r8
80003c88:	80 01       	ld.sh	r1,r0[0x0]
80003c8a:	10 7c       	tst	r12,r8
80003c8c:	80 00       	ld.sh	r0,r0[0x0]
80003c8e:	3c 90       	mov	r0,-55

80003c90 <payload_tx_process>:
Description: Transmit the payload
Calls:
Called By:task
*/
static void payload_tx_process(void * pvParameters)
{
80003c90:	eb cd 40 f8 	pushm	r3-r7,lr
80003c94:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
	
	if(NULL == phy_payload_frame_tx)
80003c96:	48 e8       	lddpc	r8,80003ccc <payload_tx_process+0x3c>
80003c98:	70 08       	ld.w	r8,r8[0x0]
80003c9a:	58 08       	cp.w	r8,0
80003c9c:	c0 71       	brne	80003caa <payload_tx_process+0x1a>
	{
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003c9e:	30 4b       	mov	r11,4
80003ca0:	30 5c       	mov	r12,5
80003ca2:	f0 1f 00 0c 	mcall	80003cd0 <payload_tx_process+0x40>
80003ca6:	48 a8       	lddpc	r8,80003ccc <payload_tx_process+0x3c>
80003ca8:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_tx, &payload_ptr,portMAX_DELAY ))
80003caa:	48 96       	lddpc	r6,80003ccc <payload_tx_process+0x3c>
80003cac:	30 05       	mov	r5,0
80003cae:	3f f4       	mov	r4,-1
		{
			payload_tx_exec(payload_ptr);//app_payload_tx_proc();
80003cb0:	48 93       	lddpc	r3,80003cd4 <payload_tx_process+0x44>
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_tx, &payload_ptr,portMAX_DELAY ))
80003cb2:	6c 0c       	ld.w	r12,r6[0x0]
80003cb4:	0a 99       	mov	r9,r5
80003cb6:	08 9a       	mov	r10,r4
80003cb8:	1a 9b       	mov	r11,sp
80003cba:	f0 1f 00 08 	mcall	80003cd8 <payload_tx_process+0x48>
80003cbe:	58 1c       	cp.w	r12,1
80003cc0:	cf 91       	brne	80003cb2 <payload_tx_process+0x22>
		{
			payload_tx_exec(payload_ptr);//app_payload_tx_proc();
80003cc2:	66 08       	ld.w	r8,r3[0x0]
80003cc4:	40 0c       	lddsp	r12,sp[0x0]
80003cc6:	5d 18       	icall	r8
80003cc8:	cf 5b       	rjmp	80003cb2 <payload_tx_process+0x22>
80003cca:	00 00       	add	r0,r0
80003ccc:	00 00       	add	r0,r0
80003cce:	10 40       	or	r0,r8
80003cd0:	80 00       	ld.sh	r0,r0[0x0]
80003cd2:	94 f4       	ld.uh	r4,r10[0xe]
80003cd4:	00 00       	add	r0,r0
80003cd6:	0f f8       	ld.ub	r8,r7[0x7]
80003cd8:	80 00       	ld.sh	r0,r0[0x0]
80003cda:	91 90       	st.w	r8[0x24],r0

80003cdc <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80003cdc:	eb cd 40 f8 	pushm	r3-r7,lr
80003ce0:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80003ce2:	48 e8       	lddpc	r8,80003d18 <payload_rx_process+0x3c>
80003ce4:	70 08       	ld.w	r8,r8[0x0]
80003ce6:	58 08       	cp.w	r8,0
80003ce8:	c0 71       	brne	80003cf6 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003cea:	30 4b       	mov	r11,4
80003cec:	30 5c       	mov	r12,5
80003cee:	f0 1f 00 0c 	mcall	80003d1c <payload_rx_process+0x40>
80003cf2:	48 a8       	lddpc	r8,80003d18 <payload_rx_process+0x3c>
80003cf4:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003cf6:	48 96       	lddpc	r6,80003d18 <payload_rx_process+0x3c>
80003cf8:	30 05       	mov	r5,0
80003cfa:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003cfc:	48 93       	lddpc	r3,80003d20 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003cfe:	6c 0c       	ld.w	r12,r6[0x0]
80003d00:	0a 99       	mov	r9,r5
80003d02:	08 9a       	mov	r10,r4
80003d04:	1a 9b       	mov	r11,sp
80003d06:	f0 1f 00 08 	mcall	80003d24 <payload_rx_process+0x48>
80003d0a:	58 1c       	cp.w	r12,1
80003d0c:	cf 91       	brne	80003cfe <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003d0e:	66 08       	ld.w	r8,r3[0x0]
80003d10:	40 0c       	lddsp	r12,sp[0x0]
80003d12:	5d 18       	icall	r8
80003d14:	cf 5b       	rjmp	80003cfe <payload_rx_process+0x22>
80003d16:	00 00       	add	r0,r0
80003d18:	00 00       	add	r0,r0
80003d1a:	10 10       	sub	r0,r8
80003d1c:	80 00       	ld.sh	r0,r0[0x0]
80003d1e:	94 f4       	ld.uh	r4,r10[0xe]
80003d20:	00 00       	add	r0,r0
80003d22:	0f f4       	ld.ub	r4,r7[0x7]
80003d24:	80 00       	ld.sh	r0,r0[0x0]
80003d26:	91 90       	st.w	r8[0x24],r0

80003d28 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80003d28:	d4 01       	pushm	lr
80003d2a:	20 2d       	sub	sp,8
80003d2c:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003d2e:	30 09       	mov	r9,0
80003d30:	fa ca ff f8 	sub	r10,sp,-8
80003d34:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80003d36:	1a 9b       	mov	r11,sp
80003d38:	f0 1f 00 02 	mcall	80003d40 <set_idle_store_isr+0x18>
}
80003d3c:	2f ed       	sub	sp,-8
80003d3e:	d8 02       	popm	pc
80003d40:	80 00       	ld.sh	r0,r0[0x0]
80003d42:	93 4c       	st.w	r9[0x10],r12

80003d44 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003d44:	d4 01       	pushm	lr
80003d46:	20 2d       	sub	sp,8
80003d48:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003d4a:	58 0c       	cp.w	r12,0
80003d4c:	c1 10       	breq	80003d6e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003d4e:	30 08       	mov	r8,0
80003d50:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003d52:	98 88       	ld.uh	r8,r12[0x0]
80003d54:	e2 18 f0 00 	andl	r8,0xf000,COH
80003d58:	e0 48 40 00 	cp.w	r8,16384
80003d5c:	c0 91       	brne	80003d6e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003d5e:	48 68       	lddpc	r8,80003d74 <phy_rx+0x30>
80003d60:	70 0c       	ld.w	r12,r8[0x0]
80003d62:	30 09       	mov	r9,0
80003d64:	fa ca ff fc 	sub	r10,sp,-4
80003d68:	1a 9b       	mov	r11,sp
80003d6a:	f0 1f 00 04 	mcall	80003d78 <phy_rx+0x34>
		}	

    }
		
 
}
80003d6e:	2f ed       	sub	sp,-8
80003d70:	d8 02       	popm	pc
80003d72:	00 00       	add	r0,r0
80003d74:	00 00       	add	r0,r0
80003d76:	10 5c       	eor	r12,r8
80003d78:	80 00       	ld.sh	r0,r0[0x0]
80003d7a:	93 4c       	st.w	r9[0x10],r12

80003d7c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003d7c:	eb cd 40 80 	pushm	r7,lr
80003d80:	20 1d       	sub	sp,4
80003d82:	fa c7 ff fc 	sub	r7,sp,-4
80003d86:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003d88:	30 09       	mov	r9,0
80003d8a:	12 9a       	mov	r10,r9
80003d8c:	1a 9b       	mov	r11,sp
80003d8e:	f0 1f 00 03 	mcall	80003d98 <set_idle_store+0x1c>
}
80003d92:	2f fd       	sub	sp,-4
80003d94:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	93 9c       	st.w	r9[0x24],r12

80003d9c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003d9c:	d4 01       	pushm	lr
80003d9e:	20 1d       	sub	sp,4
80003da0:	50 0c       	stdsp	sp[0x0],r12
    Bool res = FALSE;
	
	U16 phy_ctrl = phy->xnl_fragment.phy_header.phy_control;
80003da2:	98 88       	ld.uh	r8,r12[0x0]
80003da4:	e2 18 f0 00 	andl	r8,0xf000,COH
80003da8:	e0 48 40 00 	cp.w	r8,16384
80003dac:	c0 c1       	brne	80003dc4 <phy_tx+0x28>
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003dae:	48 78       	lddpc	r8,80003dc8 <phy_tx+0x2c>
80003db0:	70 08       	ld.w	r8,r8[0x0]
80003db2:	58 08       	cp.w	r8,0
80003db4:	c0 80       	breq	80003dc4 <phy_tx+0x28>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003db6:	48 58       	lddpc	r8,80003dc8 <phy_tx+0x2c>
80003db8:	70 0c       	ld.w	r12,r8[0x0]
80003dba:	30 09       	mov	r9,0
80003dbc:	12 9a       	mov	r10,r9
80003dbe:	1a 9b       	mov	r11,sp
80003dc0:	f0 1f 00 03 	mcall	80003dcc <phy_tx+0x30>
	//
	//if(res != TRUE)
	//{
		////vPortFree(phy_ptr);
	//}
}
80003dc4:	2f fd       	sub	sp,-4
80003dc6:	d8 02       	popm	pc
80003dc8:	00 00       	add	r0,r0
80003dca:	10 70       	tst	r0,r8
80003dcc:	80 00       	ld.sh	r0,r0[0x0]
80003dce:	93 9c       	st.w	r9[0x24],r12

80003dd0 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003dd0:	d4 01       	pushm	lr
80003dd2:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003dd4:	30 08       	mov	r8,0
80003dd6:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003dd8:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003dda:	1a 9a       	mov	r10,sp
80003ddc:	fa cb ff fc 	sub	r11,sp,-4
80003de0:	f0 1f 00 05 	mcall	80003df4 <get_idle_store_isr+0x24>
80003de4:	58 1c       	cp.w	r12,1
80003de6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003dea:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003dee:	2f ed       	sub	sp,-8
80003df0:	d8 02       	popm	pc
80003df2:	00 00       	add	r0,r0
80003df4:	80 00       	ld.sh	r0,r0[0x0]
80003df6:	90 a0       	ld.uh	r0,r8[0x4]

80003df8 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003df8:	eb cd 40 c0 	pushm	r6-r7,lr
80003dfc:	20 1d       	sub	sp,4
80003dfe:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003e00:	fe f8 05 10 	ld.w	r8,pc[1296]
80003e04:	70 08       	ld.w	r8,r8[0x0]
80003e06:	58 08       	cp.w	r8,0
80003e08:	c7 40       	breq	80003ef0 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003e0a:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003e0c:	30 08       	mov	r8,0
80003e0e:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003e10:	fe f8 05 04 	ld.w	r8,pc[1284]
80003e14:	70 08       	ld.w	r8,r8[0x0]
80003e16:	58 18       	cp.w	r8,1
80003e18:	c2 90       	breq	80003e6a <phy_tx_func+0x72>
80003e1a:	c0 43       	brcs	80003e22 <phy_tx_func+0x2a>
80003e1c:	58 28       	cp.w	r8,2
80003e1e:	c6 91       	brne	80003ef0 <phy_tx_func+0xf8>
80003e20:	c6 18       	rjmp	80003ee2 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003e22:	fe f8 04 ee 	ld.w	r8,pc[1262]
80003e26:	70 0c       	ld.w	r12,r8[0x0]
80003e28:	1a 9a       	mov	r10,sp
80003e2a:	fe fb 04 ee 	ld.w	r11,pc[1262]
80003e2e:	f0 1f 01 3c 	mcall	8000431c <phy_tx_func+0x524>
80003e32:	58 1c       	cp.w	r12,1
80003e34:	c1 51       	brne	80003e5e <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003e36:	fe f8 04 e2 	ld.w	r8,pc[1250]
80003e3a:	70 08       	ld.w	r8,r8[0x0]
80003e3c:	11 9a       	ld.ub	r10,r8[0x1]
80003e3e:	fe f9 04 e2 	ld.w	r9,pc[1250]
80003e42:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003e44:	90 88       	ld.uh	r8,r8[0x0]
80003e46:	ea 18 ab cd 	orh	r8,0xabcd
80003e4a:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003e4c:	30 19       	mov	r9,1
80003e4e:	fe f8 04 d6 	ld.w	r8,pc[1238]
80003e52:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003e54:	30 19       	mov	r9,1
80003e56:	fe f8 04 be 	ld.w	r8,pc[1214]
80003e5a:	91 09       	st.w	r8[0x0],r9
80003e5c:	c4 a8       	rjmp	80003ef0 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003e5e:	e0 68 5a 5a 	mov	r8,23130
80003e62:	ea 18 ab cd 	orh	r8,0xabcd
80003e66:	8f 18       	st.w	r7[0x4],r8
80003e68:	c4 48       	rjmp	80003ef0 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003e6a:	fe f9 04 ba 	ld.w	r9,pc[1210]
80003e6e:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003e70:	fe fa 04 a8 	ld.w	r10,pc[1192]
80003e74:	74 0a       	ld.w	r10,r10[0x0]
80003e76:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003e7a:	b1 6a       	lsl	r10,0x10
80003e7c:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003e7e:	2f f8       	sub	r8,-1
80003e80:	5c 58       	castu.b	r8
80003e82:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003e84:	fe fa 04 9c 	ld.w	r10,pc[1180]
80003e88:	94 09       	ld.sh	r9,r10[0x0]
80003e8a:	20 29       	sub	r9,2
80003e8c:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003e8e:	30 0a       	mov	r10,0
80003e90:	f4 09 19 00 	cp.h	r9,r10
80003e94:	e0 89 00 0b 	brgt	80003eaa <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003e98:	78 18       	ld.w	r8,r12[0x4]
80003e9a:	e8 18 00 ba 	orl	r8,0xba
80003e9e:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003ea0:	30 09       	mov	r9,0
80003ea2:	fe f8 04 72 	ld.w	r8,pc[1138]
80003ea6:	91 09       	st.w	r8[0x0],r9
80003ea8:	c2 48       	rjmp	80003ef0 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003eaa:	fe f9 04 6e 	ld.w	r9,pc[1134]
80003eae:	72 09       	ld.w	r9,r9[0x0]
80003eb0:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003eb4:	78 1a       	ld.w	r10,r12[0x4]
80003eb6:	f5 e9 10 09 	or	r9,r10,r9
80003eba:	99 19       	st.w	r12[0x4],r9
80003ebc:	2f f8       	sub	r8,-1
80003ebe:	fe f9 04 66 	ld.w	r9,pc[1126]
80003ec2:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003ec4:	fe f9 04 5c 	ld.w	r9,pc[1116]
80003ec8:	92 08       	ld.sh	r8,r9[0x0]
80003eca:	20 28       	sub	r8,2
80003ecc:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003ece:	30 09       	mov	r9,0
80003ed0:	f2 08 19 00 	cp.h	r8,r9
80003ed4:	e0 89 00 0e 	brgt	80003ef0 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003ed8:	30 29       	mov	r9,2
80003eda:	fe f8 04 3a 	ld.w	r8,pc[1082]
80003ede:	91 09       	st.w	r8[0x0],r9
80003ee0:	c0 88       	rjmp	80003ef0 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003ee2:	fc 18 00 ba 	movh	r8,0xba
80003ee6:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003ee8:	30 09       	mov	r9,0
80003eea:	fe f8 04 2a 	ld.w	r8,pc[1066]
80003eee:	91 09       	st.w	r8[0x0],r9
	static U32 i = 0;
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if (AMBE_flag)
80003ef0:	fe f8 04 38 	ld.w	r8,pc[1080]
80003ef4:	11 89       	ld.ub	r9,r8[0x0]
80003ef6:	30 08       	mov	r8,0
80003ef8:	f0 09 18 00 	cp.b	r9,r8
80003efc:	e0 80 00 a4 	breq	80004044 <phy_tx_func+0x24c>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80003f00:	fe f8 04 2c 	ld.w	r8,pc[1068]
80003f04:	70 08       	ld.w	r8,r8[0x0]
80003f06:	e0 48 05 b0 	cp.w	r8,1456
80003f0a:	f9 b8 02 00 	movhs	r8,0
80003f0e:	fe f9 04 1e 	ld.w	r9,pc[1054]
80003f12:	93 08       	st.w	r9[0x0],r8

	  //AMBE_flag
		switch(payload_tx_state)
80003f14:	fe f9 04 1c 	ld.w	r9,pc[1052]
80003f18:	13 89       	ld.ub	r9,r9[0x0]
80003f1a:	30 1a       	mov	r10,1
80003f1c:	f4 09 18 00 	cp.b	r9,r10
80003f20:	c3 e0       	breq	80003f9c <phy_tx_func+0x1a4>
80003f22:	c0 73       	brcs	80003f30 <phy_tx_func+0x138>
80003f24:	30 2a       	mov	r10,2
80003f26:	f4 09 18 00 	cp.b	r9,r10
80003f2a:	e0 81 00 81 	brne	8000402c <phy_tx_func+0x234>
80003f2e:	c6 98       	rjmp	80004000 <phy_tx_func+0x208>
		{
			case 0:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003f30:	fe f8 04 04 	ld.w	r8,pc[1028]
80003f34:	70 08       	ld.w	r8,r8[0x0]
80003f36:	58 08       	cp.w	r8,0
80003f38:	c0 b0       	breq	80003f4e <phy_tx_func+0x156>
80003f3a:	fe f8 03 fa 	ld.w	r8,pc[1018]
80003f3e:	70 08       	ld.w	r8,r8[0x0]
80003f40:	58 98       	cp.w	r8,9
80003f42:	c0 60       	breq	80003f4e <phy_tx_func+0x156>
80003f44:	fe f8 03 f0 	ld.w	r8,pc[1008]
80003f48:	70 08       	ld.w	r8,r8[0x0]
80003f4a:	58 18       	cp.w	r8,1
80003f4c:	c0 a1       	brne	80003f60 <phy_tx_func+0x168>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003f4e:	e0 68 5a 5a 	mov	r8,23130
80003f52:	ea 18 ab cd 	orh	r8,0xabcd
80003f56:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003f58:	30 08       	mov	r8,0
80003f5a:	8f 38       	st.w	r7[0xc],r8
80003f5c:	e0 8f 01 d6 	bral	80004308 <phy_tx_func+0x510>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003f60:	fe f8 03 d4 	ld.w	r8,pc[980]
80003f64:	70 08       	ld.w	r8,r8[0x0]
80003f66:	58 28       	cp.w	r8,2
80003f68:	c0 91       	brne	80003f7a <phy_tx_func+0x182>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80003f6a:	fe f8 03 ce 	ld.w	r8,pc[974]
80003f6e:	70 09       	ld.w	r9,r8[0x0]
80003f70:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003f72:	70 18       	ld.w	r8,r8[0x4]
80003f74:	8f 38       	st.w	r7[0xc],r8
80003f76:	e0 8f 01 c9 	bral	80004308 <phy_tx_func+0x510>
				}
				else
				{
					payload_tx_state = 1;
80003f7a:	30 19       	mov	r9,1
80003f7c:	fe f8 03 b4 	ld.w	r8,pc[948]
80003f80:	b0 89       	st.b	r8[0x0],r9
					
					//0xABCDCOOE
					payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003f82:	e0 68 c0 0e 	mov	r8,49166
80003f86:	ea 18 ab cd 	orh	r8,0xabcd
80003f8a:	8f 28       	st.w	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[2] = VBSP_data[0];
80003f8c:	fe f8 03 b0 	ld.w	r8,pc[944]
80003f90:	90 09       	ld.sh	r9,r8[0x0]
80003f92:	ae 69       	st.h	r7[0xc],r9
					//0xF00x
					payload_tx_channel->word[3] = VBSP_data[1];
80003f94:	90 18       	ld.sh	r8,r8[0x2]
80003f96:	ae 78       	st.h	r7[0xe],r8
80003f98:	e0 8f 01 b8 	bral	80004308 <phy_tx_func+0x510>
				break;
			
			case 1:
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003f9c:	fe 78 88 f2 	mov	r8,-30478
80003fa0:	ae 48       	st.h	r7[0x8],r8
				
				payload_tx_channel->word[1] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80003fa2:	fe f8 03 8a 	ld.w	r8,pc[906]
80003fa6:	70 0a       	ld.w	r10,r8[0x0]
80003fa8:	fe f9 03 98 	ld.w	r9,pc[920]
80003fac:	f2 0a 00 0b 	add	r11,r9,r10
80003fb0:	17 9b       	ld.ub	r11,r11[0x1]
80003fb2:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80003fb6:	a9 6a       	lsl	r10,0x8
80003fb8:	f6 0a 00 0a 	add	r10,r11,r10
80003fbc:	ae 5a       	st.h	r7[0xa],r10
				A_index+=2;
80003fbe:	70 0a       	ld.w	r10,r8[0x0]
80003fc0:	2f ea       	sub	r10,-2
80003fc2:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[2] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80003fc4:	f2 0a 00 0b 	add	r11,r9,r10
80003fc8:	17 9b       	ld.ub	r11,r11[0x1]
80003fca:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80003fce:	a9 6a       	lsl	r10,0x8
80003fd0:	f6 0a 00 0a 	add	r10,r11,r10
80003fd4:	ae 6a       	st.h	r7[0xc],r10
				A_index+=2;
80003fd6:	70 0a       	ld.w	r10,r8[0x0]
80003fd8:	2f ea       	sub	r10,-2
80003fda:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[3] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80003fdc:	f2 0a 00 0b 	add	r11,r9,r10
80003fe0:	17 9b       	ld.ub	r11,r11[0x1]
80003fe2:	f2 0a 07 09 	ld.ub	r9,r9[r10]
80003fe6:	a9 69       	lsl	r9,0x8
80003fe8:	f6 09 00 09 	add	r9,r11,r9
80003fec:	ae 79       	st.h	r7[0xe],r9
				A_index+=2;
80003fee:	70 09       	ld.w	r9,r8[0x0]
80003ff0:	2f e9       	sub	r9,-2
80003ff2:	91 09       	st.w	r8[0x0],r9
				
				payload_tx_state = 2;
80003ff4:	30 29       	mov	r9,2
80003ff6:	fe f8 03 3a 	ld.w	r8,pc[826]
80003ffa:	b0 89       	st.b	r8[0x0],r9
80003ffc:	e0 8f 01 86 	bral	80004308 <phy_tx_func+0x510>
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
					
					}
					
					***/
					payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//Pad_bits
80004000:	fe f9 03 40 	ld.w	r9,pc[832]
80004004:	f2 08 07 08 	ld.ub	r8,r9[r8]
80004008:	a9 68       	lsl	r8,0x8
8000400a:	ae 48       	st.h	r7[0x8],r8
					A_index+=1;
8000400c:	fe f8 03 20 	ld.w	r8,pc[800]
80004010:	70 09       	ld.w	r9,r8[0x0]
80004012:	2f f9       	sub	r9,-1
80004014:	91 09       	st.w	r8[0x0],r9
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80004016:	e0 68 00 ba 	mov	r8,186
8000401a:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
8000401c:	30 08       	mov	r8,0
8000401e:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80004020:	ae 78       	st.h	r7[0xe],r8
				
					payload_tx_state = 0;
80004022:	fe f9 03 0e 	ld.w	r9,pc[782]
80004026:	b2 88       	st.b	r9[0x0],r8
80004028:	e0 8f 01 70 	bral	80004308 <phy_tx_func+0x510>
				
				break;
				
			default:
			
				payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000402c:	e0 68 5a 5a 	mov	r8,23130
80004030:	ea 18 ab cd 	orh	r8,0xabcd
80004034:	8f 28       	st.w	r7[0x8],r8
				payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004036:	30 08       	mov	r8,0
80004038:	8f 38       	st.w	r7[0xc],r8
				
				payload_tx_state = 0;
8000403a:	fe f9 02 f6 	ld.w	r9,pc[758]
8000403e:	b2 88       	st.b	r9[0x0],r8
80004040:	e0 8f 01 64 	bral	80004308 <phy_tx_func+0x510>

#if 1
else//Send-PCM-data40bytes/2.5ms.
{
	
	index = (index >=30240) ? 0 : index;
80004044:	fe f8 03 00 	ld.w	r8,pc[768]
80004048:	70 08       	ld.w	r8,r8[0x0]
8000404a:	e0 48 76 20 	cp.w	r8,30240
8000404e:	f9 b8 02 00 	movhs	r8,0
80004052:	fe f9 02 f2 	ld.w	r9,pc[754]
80004056:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80004058:	fe f8 02 f0 	ld.w	r8,pc[752]
8000405c:	11 89       	ld.ub	r9,r8[0x0]
8000405e:	30 18       	mov	r8,1
80004060:	f0 09 18 00 	cp.b	r9,r8
80004064:	c0 61       	brne	80004070 <phy_tx_func+0x278>
80004066:	fe f8 02 e6 	ld.w	r8,pc[742]
8000406a:	70 09       	ld.w	r9,r8[0x0]
8000406c:	2f f9       	sub	r9,-1
8000406e:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
80004070:	fe f8 02 c0 	ld.w	r8,pc[704]
80004074:	11 88       	ld.ub	r8,r8[0x0]
80004076:	30 19       	mov	r9,1
80004078:	f2 08 18 00 	cp.b	r8,r9
8000407c:	c3 60       	breq	800040e8 <phy_tx_func+0x2f0>
8000407e:	c0 73       	brcs	8000408c <phy_tx_func+0x294>
80004080:	30 29       	mov	r9,2
80004082:	f2 08 18 00 	cp.b	r8,r9
80004086:	e0 81 01 3e 	brne	80004302 <phy_tx_func+0x50a>
8000408a:	c7 c8       	rjmp	80004182 <phy_tx_func+0x38a>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
8000408c:	e0 68 5a 5a 	mov	r8,23130
80004090:	ea 18 ab cd 	orh	r8,0xabcd
80004094:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004096:	30 08       	mov	r8,0
80004098:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
8000409a:	fe f8 02 b2 	ld.w	r8,pc[690]
8000409e:	70 08       	ld.w	r8,r8[0x0]
800040a0:	e0 6b cc cd 	mov	r11,52429
800040a4:	ea 1b cc cc 	orh	r11,0xcccc
800040a8:	f0 0b 06 4a 	mulu.d	r10,r8,r11
800040ac:	f6 09 16 04 	lsr	r9,r11,0x4
800040b0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800040b4:	f0 09 01 29 	sub	r9,r8,r9<<0x2
800040b8:	c1 21       	brne	800040dc <phy_tx_func+0x2e4>
800040ba:	58 08       	cp.w	r8,0
800040bc:	c1 00       	breq	800040dc <phy_tx_func+0x2e4>
800040be:	fe f8 02 8a 	ld.w	r8,pc[650]
800040c2:	11 89       	ld.ub	r9,r8[0x0]
800040c4:	30 18       	mov	r8,1
800040c6:	f0 09 18 00 	cp.b	r9,r8
800040ca:	c0 91       	brne	800040dc <phy_tx_func+0x2e4>
			{
				payload_tx_state = 1;
800040cc:	10 99       	mov	r9,r8
800040ce:	fe f8 02 62 	ld.w	r8,pc[610]
800040d2:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
800040d4:	30 09       	mov	r9,0
800040d6:	fe f8 02 7a 	ld.w	r8,pc[634]
800040da:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
800040dc:	fe f8 02 78 	ld.w	r8,pc[632]
800040e0:	70 09       	ld.w	r9,r8[0x0]
800040e2:	2f f9       	sub	r9,-1
800040e4:	91 09       	st.w	r8[0x0],r9
800040e6:	c1 19       	rjmp	80004308 <phy_tx_func+0x510>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
800040e8:	fe 78 ab cd 	mov	r8,-21555
800040ec:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
800040ee:	fe f8 02 62 	ld.w	r8,pc[610]
800040f2:	11 89       	ld.ub	r9,r8[0x0]
800040f4:	30 08       	mov	r8,0
800040f6:	f0 09 18 00 	cp.b	r9,r8
800040fa:	c1 b1       	brne	80004130 <phy_tx_func+0x338>
			{
				if (Silent_flag == 1)
800040fc:	fe f8 02 5c 	ld.w	r8,pc[604]
80004100:	11 89       	ld.ub	r9,r8[0x0]
80004102:	30 18       	mov	r8,1
80004104:	f0 09 18 00 	cp.b	r9,r8
80004108:	c0 91       	brne	8000411a <phy_tx_func+0x322>
				{
					//44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
8000410a:	32 c9       	mov	r9,44
8000410c:	fe f8 02 50 	ld.w	r8,pc[592]
80004110:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
80004112:	e0 68 10 2c 	mov	r8,4140
80004116:	ae 58       	st.h	r7[0xa],r8
80004118:	c0 88       	rjmp	80004128 <phy_tx_func+0x330>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
8000411a:	32 a9       	mov	r9,42
8000411c:	fe f8 02 40 	ld.w	r8,pc[576]
80004120:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
80004122:	e0 68 10 2a 	mov	r8,4138
80004126:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
80004128:	30 19       	mov	r9,1
8000412a:	fe f8 02 36 	ld.w	r8,pc[566]
8000412e:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//
			
			if (Silent_flag == 1)//
80004130:	fe f8 02 28 	ld.w	r8,pc[552]
80004134:	11 89       	ld.ub	r9,r8[0x0]
80004136:	30 18       	mov	r8,1
80004138:	f0 09 18 00 	cp.b	r9,r8
8000413c:	c0 61       	brne	80004148 <phy_tx_func+0x350>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
8000413e:	30 18       	mov	r8,1
80004140:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
80004142:	30 48       	mov	r8,4
80004144:	ae 78       	st.h	r7[0xe],r8
80004146:	c1 38       	rjmp	8000416c <phy_tx_func+0x374>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
80004148:	30 08       	mov	r8,0
8000414a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000414c:	4f e8       	lddpc	r8,80004344 <phy_tx_func+0x54c>
8000414e:	70 09       	ld.w	r9,r8[0x0]
80004150:	fe fa 02 14 	ld.w	r10,pc[532]
80004154:	f4 09 00 0b 	add	r11,r10,r9
80004158:	17 9b       	ld.ub	r11,r11[0x1]
8000415a:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000415e:	a9 69       	lsl	r9,0x8
80004160:	f6 09 00 09 	add	r9,r11,r9
80004164:	ae 79       	st.h	r7[0xe],r9
				index+=2;
80004166:	70 09       	ld.w	r9,r8[0x0]
80004168:	2f e9       	sub	r9,-2
8000416a:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
8000416c:	4f c8       	lddpc	r8,8000435c <phy_tx_func+0x564>
8000416e:	90 09       	ld.sh	r9,r8[0x0]
80004170:	20 49       	sub	r9,4
80004172:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
80004174:	30 29       	mov	r9,2
80004176:	4e f8       	lddpc	r8,80004330 <phy_tx_func+0x538>
80004178:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
8000417a:	30 09       	mov	r9,0
8000417c:	4f b8       	lddpc	r8,80004368 <phy_tx_func+0x570>
8000417e:	91 09       	st.w	r8[0x0],r9
80004180:	cc 48       	rjmp	80004308 <phy_tx_func+0x510>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
80004182:	4f 78       	lddpc	r8,8000435c <phy_tx_func+0x564>
80004184:	90 09       	ld.sh	r9,r8[0x0]
80004186:	30 08       	mov	r8,0
80004188:	f0 09 19 00 	cp.h	r9,r8
8000418c:	e0 89 00 12 	brgt	800041b0 <phy_tx_func+0x3b8>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80004190:	4f 48       	lddpc	r8,80004360 <phy_tx_func+0x568>
80004192:	11 89       	ld.ub	r9,r8[0x0]
80004194:	30 08       	mov	r8,0
80004196:	f0 09 18 00 	cp.b	r9,r8
8000419a:	5f 09       	sreq	r9
8000419c:	4e 58       	lddpc	r8,80004330 <phy_tx_func+0x538>
8000419e:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
800041a0:	e0 68 00 ba 	mov	r8,186
800041a4:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
800041a6:	30 08       	mov	r8,0
800041a8:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
800041aa:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
800041ac:	ae 78       	st.h	r7[0xe],r8
800041ae:	ca d8       	rjmp	80004308 <phy_tx_func+0x510>
				break;
			}
		
			if(Silent_flag == 1)
800041b0:	4e a8       	lddpc	r8,80004358 <phy_tx_func+0x560>
800041b2:	11 89       	ld.ub	r9,r8[0x0]
800041b4:	30 18       	mov	r8,1
800041b6:	f0 09 18 00 	cp.b	r9,r8
800041ba:	c0 41       	brne	800041c2 <phy_tx_func+0x3ca>
			{
				payload_tx_channel->word[0] =  0x0000;
800041bc:	30 08       	mov	r8,0
800041be:	ae 48       	st.h	r7[0x8],r8
800041c0:	c1 08       	rjmp	800041e0 <phy_tx_func+0x3e8>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800041c2:	4e 18       	lddpc	r8,80004344 <phy_tx_func+0x54c>
800041c4:	70 09       	ld.w	r9,r8[0x0]
800041c6:	4e 8a       	lddpc	r10,80004364 <phy_tx_func+0x56c>
800041c8:	f4 09 00 0b 	add	r11,r10,r9
800041cc:	17 9b       	ld.ub	r11,r11[0x1]
800041ce:	f4 09 07 09 	ld.ub	r9,r10[r9]
800041d2:	a9 69       	lsl	r9,0x8
800041d4:	f6 09 00 09 	add	r9,r11,r9
800041d8:	ae 49       	st.h	r7[0x8],r9
				index+=2;
800041da:	70 09       	ld.w	r9,r8[0x0]
800041dc:	2f e9       	sub	r9,-2
800041de:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
800041e0:	4d f9       	lddpc	r9,8000435c <phy_tx_func+0x564>
800041e2:	92 08       	ld.sh	r8,r9[0x0]
800041e4:	20 28       	sub	r8,2
800041e6:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
800041e8:	30 09       	mov	r9,0
800041ea:	f2 08 19 00 	cp.h	r8,r9
800041ee:	e0 89 00 11 	brgt	80004210 <phy_tx_func+0x418>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
800041f2:	4d c8       	lddpc	r8,80004360 <phy_tx_func+0x568>
800041f4:	11 89       	ld.ub	r9,r8[0x0]
800041f6:	30 08       	mov	r8,0
800041f8:	f0 09 18 00 	cp.b	r9,r8
800041fc:	5f 09       	sreq	r9
800041fe:	4c d8       	lddpc	r8,80004330 <phy_tx_func+0x538>
80004200:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
80004202:	e0 68 00 ba 	mov	r8,186
80004206:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80004208:	30 08       	mov	r8,0
8000420a:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
8000420c:	ae 78       	st.h	r7[0xe],r8
8000420e:	c7 d8       	rjmp	80004308 <phy_tx_func+0x510>
				break;
			}
		
			if(Silent_flag == 1)
80004210:	4d 28       	lddpc	r8,80004358 <phy_tx_func+0x560>
80004212:	11 89       	ld.ub	r9,r8[0x0]
80004214:	30 18       	mov	r8,1
80004216:	f0 09 18 00 	cp.b	r9,r8
8000421a:	c0 41       	brne	80004222 <phy_tx_func+0x42a>
			{
				payload_tx_channel->word[1] =  0x0000;
8000421c:	30 08       	mov	r8,0
8000421e:	ae 58       	st.h	r7[0xa],r8
80004220:	c1 08       	rjmp	80004240 <phy_tx_func+0x448>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80004222:	4c 98       	lddpc	r8,80004344 <phy_tx_func+0x54c>
80004224:	70 09       	ld.w	r9,r8[0x0]
80004226:	4d 0a       	lddpc	r10,80004364 <phy_tx_func+0x56c>
80004228:	f4 09 00 0b 	add	r11,r10,r9
8000422c:	17 9b       	ld.ub	r11,r11[0x1]
8000422e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80004232:	a9 69       	lsl	r9,0x8
80004234:	f6 09 00 09 	add	r9,r11,r9
80004238:	ae 59       	st.h	r7[0xa],r9
				index+=2;
8000423a:	70 09       	ld.w	r9,r8[0x0]
8000423c:	2f e9       	sub	r9,-2
8000423e:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80004240:	4c 79       	lddpc	r9,8000435c <phy_tx_func+0x564>
80004242:	92 08       	ld.sh	r8,r9[0x0]
80004244:	20 28       	sub	r8,2
80004246:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80004248:	30 09       	mov	r9,0
8000424a:	f2 08 19 00 	cp.h	r8,r9
8000424e:	e0 89 00 10 	brgt	8000426e <phy_tx_func+0x476>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80004252:	4c 48       	lddpc	r8,80004360 <phy_tx_func+0x568>
80004254:	11 89       	ld.ub	r9,r8[0x0]
80004256:	30 08       	mov	r8,0
80004258:	f0 09 18 00 	cp.b	r9,r8
8000425c:	5f 09       	sreq	r9
8000425e:	4b 58       	lddpc	r8,80004330 <phy_tx_func+0x538>
80004260:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
80004262:	e0 68 00 ba 	mov	r8,186
80004266:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80004268:	30 08       	mov	r8,0
8000426a:	ae 78       	st.h	r7[0xe],r8
8000426c:	c4 e8       	rjmp	80004308 <phy_tx_func+0x510>
				break;
			}
		
			if(Silent_flag == 1)
8000426e:	4b b8       	lddpc	r8,80004358 <phy_tx_func+0x560>
80004270:	11 89       	ld.ub	r9,r8[0x0]
80004272:	30 18       	mov	r8,1
80004274:	f0 09 18 00 	cp.b	r9,r8
80004278:	c0 41       	brne	80004280 <phy_tx_func+0x488>
			{
				payload_tx_channel->word[2] =  0x0000;
8000427a:	30 08       	mov	r8,0
8000427c:	ae 68       	st.h	r7[0xc],r8
8000427e:	c1 08       	rjmp	8000429e <phy_tx_func+0x4a6>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80004280:	4b 18       	lddpc	r8,80004344 <phy_tx_func+0x54c>
80004282:	70 09       	ld.w	r9,r8[0x0]
80004284:	4b 8a       	lddpc	r10,80004364 <phy_tx_func+0x56c>
80004286:	f4 09 00 0b 	add	r11,r10,r9
8000428a:	17 9b       	ld.ub	r11,r11[0x1]
8000428c:	f4 09 07 09 	ld.ub	r9,r10[r9]
80004290:	a9 69       	lsl	r9,0x8
80004292:	f6 09 00 09 	add	r9,r11,r9
80004296:	ae 69       	st.h	r7[0xc],r9
				index+=2;
80004298:	70 09       	ld.w	r9,r8[0x0]
8000429a:	2f e9       	sub	r9,-2
8000429c:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
8000429e:	4b 09       	lddpc	r9,8000435c <phy_tx_func+0x564>
800042a0:	92 08       	ld.sh	r8,r9[0x0]
800042a2:	20 28       	sub	r8,2
800042a4:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
800042a6:	30 09       	mov	r9,0
800042a8:	f2 08 19 00 	cp.h	r8,r9
800042ac:	e0 89 00 0e 	brgt	800042c8 <phy_tx_func+0x4d0>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
800042b0:	4a c8       	lddpc	r8,80004360 <phy_tx_func+0x568>
800042b2:	11 89       	ld.ub	r9,r8[0x0]
800042b4:	30 08       	mov	r8,0
800042b6:	f0 09 18 00 	cp.b	r9,r8
800042ba:	5f 09       	sreq	r9
800042bc:	49 d8       	lddpc	r8,80004330 <phy_tx_func+0x538>
800042be:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
800042c0:	e0 68 00 ba 	mov	r8,186
800042c4:	ae 78       	st.h	r7[0xe],r8
800042c6:	c2 18       	rjmp	80004308 <phy_tx_func+0x510>
				break;
			}
		
			if(Silent_flag == 1)
800042c8:	4a 48       	lddpc	r8,80004358 <phy_tx_func+0x560>
800042ca:	11 89       	ld.ub	r9,r8[0x0]
800042cc:	30 18       	mov	r8,1
800042ce:	f0 09 18 00 	cp.b	r9,r8
800042d2:	c0 41       	brne	800042da <phy_tx_func+0x4e2>
			{
				payload_tx_channel->word[3] =  0x0000;
800042d4:	30 08       	mov	r8,0
800042d6:	ae 78       	st.h	r7[0xe],r8
800042d8:	c1 08       	rjmp	800042f8 <phy_tx_func+0x500>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800042da:	49 b8       	lddpc	r8,80004344 <phy_tx_func+0x54c>
800042dc:	70 09       	ld.w	r9,r8[0x0]
800042de:	4a 2a       	lddpc	r10,80004364 <phy_tx_func+0x56c>
800042e0:	f4 09 00 0b 	add	r11,r10,r9
800042e4:	17 9b       	ld.ub	r11,r11[0x1]
800042e6:	f4 09 07 09 	ld.ub	r9,r10[r9]
800042ea:	a9 69       	lsl	r9,0x8
800042ec:	f6 09 00 09 	add	r9,r11,r9
800042f0:	ae 79       	st.h	r7[0xe],r9
				index+=2;
800042f2:	70 09       	ld.w	r9,r8[0x0]
800042f4:	2f e9       	sub	r9,-2
800042f6:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
800042f8:	49 98       	lddpc	r8,8000435c <phy_tx_func+0x564>
800042fa:	90 09       	ld.sh	r9,r8[0x0]
800042fc:	20 29       	sub	r9,2
800042fe:	b0 09       	st.h	r8[0x0],r9
80004300:	c0 48       	rjmp	80004308 <phy_tx_func+0x510>
		
			break;
		
		default:
			payload_tx_state = 0;
80004302:	30 09       	mov	r9,0
80004304:	48 b8       	lddpc	r8,80004330 <phy_tx_func+0x538>
80004306:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80004308:	2f fd       	sub	sp,-4
8000430a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000430e:	00 00       	add	r0,r0
80004310:	00 00       	add	r0,r0
80004312:	10 70       	tst	r0,r8
80004314:	00 00       	add	r0,r0
80004316:	10 18       	sub	r8,r8
80004318:	00 00       	add	r0,r0
8000431a:	10 78       	tst	r8,r8
8000431c:	80 00       	ld.sh	r0,r0[0x0]
8000431e:	90 a0       	ld.uh	r0,r8[0x4]
80004320:	00 00       	add	r0,r0
80004322:	10 48       	or	r8,r8
80004324:	00 00       	add	r0,r0
80004326:	10 80       	andn	r0,r8
80004328:	00 00       	add	r0,r0
8000432a:	0a 45       	or	r5,r5
8000432c:	00 00       	add	r0,r0
8000432e:	10 68       	and	r8,r8
80004330:	00 00       	add	r0,r0
80004332:	10 3c       	cp.w	r12,r8
80004334:	00 00       	add	r0,r0
80004336:	10 08       	add	r8,r8
80004338:	00 00       	add	r0,r0
8000433a:	10 24       	rsub	r4,r8
8000433c:	00 00       	add	r0,r0
8000433e:	14 58       	eor	r8,r10
80004340:	80 01       	ld.sh	r1,r0[0x0]
80004342:	0a c0       	st.b	r5++,r0
80004344:	00 00       	add	r0,r0
80004346:	10 0c       	add	r12,r8
80004348:	00 00       	add	r0,r0
8000434a:	0a 4d       	or	sp,r5
8000434c:	00 00       	add	r0,r0
8000434e:	10 64       	and	r4,r8
80004350:	00 00       	add	r0,r0
80004352:	10 20       	rsub	r0,r8
80004354:	00 00       	add	r0,r0
80004356:	10 44       	or	r4,r8
80004358:	00 00       	add	r0,r0
8000435a:	0a 58       	eor	r8,r5
8000435c:	00 00       	add	r0,r0
8000435e:	10 58       	eor	r8,r8
80004360:	00 00       	add	r0,r0
80004362:	10 81       	andn	r1,r8
80004364:	80 01       	ld.sh	r1,r0[0x0]
80004366:	10 88       	andn	r8,r8
80004368:	00 00       	add	r0,r0
8000436a:	0f fc       	ld.ub	r12,r7[0x7]

8000436c <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
8000436c:	d4 01       	pushm	lr
8000436e:	20 1d       	sub	sp,4
	void * ptr = NULL;
80004370:	30 0a       	mov	r10,0
80004372:	fa cb ff fc 	sub	r11,sp,-4
80004376:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80004378:	14 99       	mov	r9,r10
8000437a:	1a 9b       	mov	r11,sp
8000437c:	f0 1f 00 05 	mcall	80004390 <get_idle_store+0x24>
80004380:	58 1c       	cp.w	r12,1
80004382:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80004386:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
8000438a:	2f fd       	sub	sp,-4
8000438c:	d8 02       	popm	pc
8000438e:	00 00       	add	r0,r0
80004390:	80 00       	ld.sh	r0,r0[0x0]
80004392:	91 90       	st.w	r8[0x24],r0

80004394 <payload_tx>:
}



 void payload_tx(void * payload)
{
80004394:	d4 01       	pushm	lr
80004396:	20 2d       	sub	sp,8
80004398:	50 0c       	stdsp	sp[0x0],r12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000439a:	30 08       	mov	r8,0
8000439c:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_tx)
8000439e:	48 f8       	lddpc	r8,800043d8 <payload_tx+0x44>
800043a0:	70 08       	ld.w	r8,r8[0x0]
800043a2:	58 08       	cp.w	r8,0
800043a4:	c0 71       	brne	800043b2 <payload_tx+0x1e>
	{
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043a6:	30 4b       	mov	r11,4
800043a8:	30 5c       	mov	r12,5
800043aa:	f0 1f 00 0d 	mcall	800043dc <payload_tx+0x48>
800043ae:	48 b8       	lddpc	r8,800043d8 <payload_tx+0x44>
800043b0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_tx, &payload, &xHigherPriorityTaskWoken))//SD
800043b2:	48 a8       	lddpc	r8,800043d8 <payload_tx+0x44>
800043b4:	70 0c       	ld.w	r12,r8[0x0]
800043b6:	30 09       	mov	r9,0
800043b8:	fa ca ff fc 	sub	r10,sp,-4
800043bc:	1a 9b       	mov	r11,sp
800043be:	f0 1f 00 09 	mcall	800043e0 <payload_tx+0x4c>
800043c2:	c0 91       	brne	800043d4 <payload_tx+0x40>
	{	//To payload_Tx_process();
		
		set_payload_idle_isr(payload);
800043c4:	48 88       	lddpc	r8,800043e4 <payload_tx+0x50>
800043c6:	70 0c       	ld.w	r12,r8[0x0]
800043c8:	40 0b       	lddsp	r11,sp[0x0]
800043ca:	f0 1f 00 08 	mcall	800043e8 <payload_tx+0x54>
		logFromISR("txmm");
800043ce:	48 8c       	lddpc	r12,800043ec <payload_tx+0x58>
800043d0:	f0 1f 00 08 	mcall	800043f0 <payload_tx+0x5c>
			//taskYIELD();
			
		}

	}
}
800043d4:	2f ed       	sub	sp,-8
800043d6:	d8 02       	popm	pc
800043d8:	00 00       	add	r0,r0
800043da:	10 40       	or	r0,r8
800043dc:	80 00       	ld.sh	r0,r0[0x0]
800043de:	94 f4       	ld.uh	r4,r10[0xe]
800043e0:	80 00       	ld.sh	r0,r0[0x0]
800043e2:	93 4c       	st.w	r9[0x10],r12
800043e4:	00 00       	add	r0,r0
800043e6:	10 1c       	sub	r12,r8
800043e8:	80 00       	ld.sh	r0,r0[0x0]
800043ea:	3d 28       	mov	r8,-46
800043ec:	80 01       	ld.sh	r1,r0[0x0]
800043ee:	94 38       	ld.sh	r8,r10[0x6]
800043f0:	80 00       	ld.sh	r0,r0[0x0]
800043f2:	a1 18       	ld.d	r8,--r0

800043f4 <payload_rx>:




void payload_rx(void * payload)
{
800043f4:	d4 01       	pushm	lr
800043f6:	20 2d       	sub	sp,8
800043f8:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800043fa:	30 08       	mov	r8,0
800043fc:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
800043fe:	48 f8       	lddpc	r8,80004438 <payload_rx+0x44>
80004400:	70 08       	ld.w	r8,r8[0x0]
80004402:	58 08       	cp.w	r8,0
80004404:	c0 71       	brne	80004412 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80004406:	30 4b       	mov	r11,4
80004408:	30 5c       	mov	r12,5
8000440a:	f0 1f 00 0d 	mcall	8000443c <payload_rx+0x48>
8000440e:	48 b8       	lddpc	r8,80004438 <payload_rx+0x44>
80004410:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))//
80004412:	48 a8       	lddpc	r8,80004438 <payload_rx+0x44>
80004414:	70 0c       	ld.w	r12,r8[0x0]
80004416:	30 09       	mov	r9,0
80004418:	fa ca ff fc 	sub	r10,sp,-4
8000441c:	1a 9b       	mov	r11,sp
8000441e:	f0 1f 00 09 	mcall	80004440 <payload_rx+0x4c>
80004422:	c0 91       	brne	80004434 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80004424:	48 88       	lddpc	r8,80004444 <payload_rx+0x50>
80004426:	70 0c       	ld.w	r12,r8[0x0]
80004428:	40 0b       	lddsp	r11,sp[0x0]
8000442a:	f0 1f 00 08 	mcall	80004448 <payload_rx+0x54>
		logFromISR("mm");
8000442e:	48 8c       	lddpc	r12,8000444c <payload_rx+0x58>
80004430:	f0 1f 00 08 	mcall	80004450 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80004434:	2f ed       	sub	sp,-8
80004436:	d8 02       	popm	pc
80004438:	00 00       	add	r0,r0
8000443a:	10 10       	sub	r0,r8
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	94 f4       	ld.uh	r4,r10[0xe]
80004440:	80 00       	ld.sh	r0,r0[0x0]
80004442:	93 4c       	st.w	r9[0x10],r12
80004444:	00 00       	add	r0,r0
80004446:	10 1c       	sub	r12,r8
80004448:	80 00       	ld.sh	r0,r0[0x0]
8000444a:	3d 28       	mov	r8,-46
8000444c:	80 01       	ld.sh	r1,r0[0x0]
8000444e:	94 40       	ld.sh	r0,r10[0x8]
80004450:	80 00       	ld.sh	r0,r0[0x0]
80004452:	a1 18       	ld.d	r8,--r0

80004454 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80004454:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80004458:	f0 1f 00 23 	mcall	800044e4 <phy_init+0x90>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
8000445c:	4a 3b       	lddpc	r11,800044e8 <phy_init+0x94>
8000445e:	4a 4c       	lddpc	r12,800044ec <phy_init+0x98>
80004460:	f0 1f 00 24 	mcall	800044f0 <phy_init+0x9c>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004464:	30 4b       	mov	r11,4
80004466:	31 ec       	mov	r12,30
80004468:	f0 1f 00 23 	mcall	800044f4 <phy_init+0xa0>
8000446c:	4a 38       	lddpc	r8,800044f8 <phy_init+0xa4>
8000446e:	91 0c       	st.w	r8[0x0],r12
80004470:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004472:	10 96       	mov	r6,r8
80004474:	4a 25       	lddpc	r5,800044fc <phy_init+0xa8>
80004476:	6c 0c       	ld.w	r12,r6[0x0]
80004478:	ea 07 00 0b 	add	r11,r5,r7
8000447c:	f0 1f 00 21 	mcall	80004500 <phy_init+0xac>
80004480:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004484:	e0 47 1e 00 	cp.w	r7,7680
80004488:	cf 71       	brne	80004476 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000448a:	30 4b       	mov	r11,4
8000448c:	31 4c       	mov	r12,20
8000448e:	f0 1f 00 1a 	mcall	800044f4 <phy_init+0xa0>
80004492:	49 d8       	lddpc	r8,80004504 <phy_init+0xb0>
80004494:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004496:	30 4b       	mov	r11,4
80004498:	30 ac       	mov	r12,10
8000449a:	f0 1f 00 17 	mcall	800044f4 <phy_init+0xa0>
8000449e:	49 b8       	lddpc	r8,80004508 <phy_init+0xb4>
800044a0:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800044a2:	30 4b       	mov	r11,4
800044a4:	30 ac       	mov	r12,10
800044a6:	f0 1f 00 14 	mcall	800044f4 <phy_init+0xa0>
800044aa:	49 98       	lddpc	r8,8000450c <phy_init+0xb8>
800044ac:	91 0c       	st.w	r8[0x0],r12
800044ae:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800044b0:	10 96       	mov	r6,r8
800044b2:	49 85       	lddpc	r5,80004510 <phy_init+0xbc>
800044b4:	6c 0c       	ld.w	r12,r6[0x0]
800044b6:	ea 07 00 0b 	add	r11,r5,r7
800044ba:	f0 1f 00 12 	mcall	80004500 <phy_init+0xac>
800044be:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800044c2:	e0 47 14 00 	cp.w	r7,5120
800044c6:	cf 71       	brne	800044b4 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t * ));
800044c8:	30 4b       	mov	r11,4
800044ca:	30 5c       	mov	r12,5
800044cc:	f0 1f 00 0a 	mcall	800044f4 <phy_init+0xa0>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
800044d0:	49 18       	lddpc	r8,80004514 <phy_init+0xc0>
800044d2:	91 0c       	st.w	r8[0x0],r12
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t * ));
		
	phy_payload_frame_rx =
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
800044d4:	30 4b       	mov	r11,4
800044d6:	30 5c       	mov	r12,5
800044d8:	f0 1f 00 07 	mcall	800044f4 <phy_init+0xa0>
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t * ));
		
	phy_payload_frame_rx =
800044dc:	48 f8       	lddpc	r8,80004518 <phy_init+0xc4>
800044de:	91 0c       	st.w	r8[0x0],r12
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
800044e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800044e4:	80 00       	ld.sh	r0,r0[0x0]
800044e6:	50 c0       	stdsp	sp[0x30],r0
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	3d f8       	mov	r8,-33
800044ec:	80 00       	ld.sh	r0,r0[0x0]
800044ee:	45 1c       	lddsp	r12,sp[0x144]
800044f0:	80 00       	ld.sh	r0,r0[0x0]
800044f2:	50 ac       	stdsp	sp[0x28],r12
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	94 f4       	ld.uh	r4,r10[0xe]
800044f8:	00 00       	add	r0,r0
800044fa:	10 2c       	rsub	r12,r8
800044fc:	00 00       	add	r0,r0
800044fe:	28 5c       	sub	r12,-123
80004500:	80 00       	ld.sh	r0,r0[0x0]
80004502:	3d 7c       	mov	r12,-41
80004504:	00 00       	add	r0,r0
80004506:	10 70       	tst	r0,r8
80004508:	00 00       	add	r0,r0
8000450a:	10 5c       	eor	r12,r8
8000450c:	00 00       	add	r0,r0
8000450e:	10 1c       	sub	r12,r8
80004510:	00 00       	add	r0,r0
80004512:	14 5c       	eor	r12,r10
80004514:	00 00       	add	r0,r0
80004516:	10 40       	or	r0,r8
80004518:	00 00       	add	r0,r0
8000451a:	10 10       	sub	r0,r8

8000451c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
8000451c:	eb cd 40 e0 	pushm	r5-r7,lr
80004520:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80004522:	fe f8 09 de 	ld.w	r8,pc[2526]
80004526:	70 08       	ld.w	r8,r8[0x0]
80004528:	58 08       	cp.w	r8,0
8000452a:	e0 80 01 05 	breq	80004734 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000452e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80004530:	fe f8 09 d4 	ld.w	r8,pc[2516]
80004534:	70 09       	ld.w	r9,r8[0x0]
80004536:	2f f9       	sub	r9,-1
80004538:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000453a:	fe f8 09 ce 	ld.w	r8,pc[2510]
8000453e:	70 08       	ld.w	r8,r8[0x0]
80004540:	58 18       	cp.w	r8,1
80004542:	e0 80 00 84 	breq	8000464a <phy_rx_func+0x12e>
80004546:	c0 73       	brcs	80004554 <phy_rx_func+0x38>
80004548:	58 28       	cp.w	r8,2
8000454a:	c5 b0       	breq	80004600 <phy_rx_func+0xe4>
8000454c:	58 38       	cp.w	r8,3
8000454e:	e0 81 00 f3 	brne	80004734 <phy_rx_func+0x218>
80004552:	cd 38       	rjmp	800046f8 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80004554:	e0 6a 5a 5a 	mov	r10,23130
80004558:	ea 1a ab cd 	orh	r10,0xabcd
8000455c:	14 36       	cp.w	r6,r10
8000455e:	e0 80 00 eb 	breq	80004734 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80004562:	ec 08 16 10 	lsr	r8,r6,0x10
80004566:	e0 48 ab cd 	cp.w	r8,43981
8000456a:	e0 81 00 e5 	brne	80004734 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000456e:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80004572:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80004576:	20 28       	sub	r8,2
80004578:	fe f9 09 94 	ld.w	r9,pc[2452]
8000457c:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000457e:	30 09       	mov	r9,0
80004580:	f2 08 19 00 	cp.h	r8,r9
80004584:	e0 8a 00 d8 	brle	80004734 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80004588:	fe f8 09 88 	ld.w	r8,pc[2440]
8000458c:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
8000458e:	fe f8 09 86 	ld.w	r8,pc[2438]
80004592:	70 0c       	ld.w	r12,r8[0x0]
80004594:	f0 1f 02 61 	mcall	80004f18 <phy_rx_func+0x9fc>
80004598:	fe f8 09 84 	ld.w	r8,pc[2436]
8000459c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000459e:	58 0c       	cp.w	r12,0
800045a0:	e0 80 00 ca 	breq	80004734 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800045a4:	fe f8 09 6c 	ld.w	r8,pc[2412]
800045a8:	90 09       	ld.sh	r9,r8[0x0]
800045aa:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800045ae:	2f f9       	sub	r9,-1
800045b0:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800045b2:	fe fa 09 6a 	ld.w	r10,pc[2410]
800045b6:	74 0a       	ld.w	r10,r10[0x0]
800045b8:	fe fb 09 4c 	ld.w	r11,pc[2380]
800045bc:	76 0b       	ld.w	r11,r11[0x0]
800045be:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800045c2:	2f f9       	sub	r9,-1
800045c4:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800045c6:	e2 16 0f 00 	andl	r6,0xf00,COH
800045ca:	e0 46 01 00 	cp.w	r6,256
800045ce:	c0 c0       	breq	800045e6 <phy_rx_func+0xca>
800045d0:	e0 8b 00 05 	brhi	800045da <phy_rx_func+0xbe>
800045d4:	58 06       	cp.w	r6,0
800045d6:	c0 80       	breq	800045e6 <phy_rx_func+0xca>
800045d8:	c0 c8       	rjmp	800045f0 <phy_rx_func+0xd4>
800045da:	e0 46 02 00 	cp.w	r6,512
800045de:	c0 40       	breq	800045e6 <phy_rx_func+0xca>
800045e0:	e0 46 03 00 	cp.w	r6,768
800045e4:	c0 61       	brne	800045f0 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800045e6:	30 29       	mov	r9,2
800045e8:	fe f8 09 20 	ld.w	r8,pc[2336]
800045ec:	91 09       	st.w	r8[0x0],r9
800045ee:	ca 38       	rjmp	80004734 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
800045f0:	fe f6 09 2c 	ld.w	r6,pc[2348]
800045f4:	6c 0c       	ld.w	r12,r6[0x0]
800045f6:	f0 1f 02 4b 	mcall	80004f20 <phy_rx_func+0xa04>
					phy_frame_ptr = NULL;					
800045fa:	30 08       	mov	r8,0
800045fc:	8d 08       	st.w	r6[0x0],r8
800045fe:	c9 b8       	rjmp	80004734 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80004600:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80004604:	b1 86       	lsr	r6,0x10
80004606:	14 06       	add	r6,r10
80004608:	fe f8 09 1c 	ld.w	r8,pc[2332]
8000460c:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000460e:	fe f8 09 02 	ld.w	r8,pc[2306]
80004612:	90 09       	ld.sh	r9,r8[0x0]
80004614:	fe fb 09 08 	ld.w	r11,pc[2312]
80004618:	76 0b       	ld.w	r11,r11[0x0]
8000461a:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000461e:	2f f9       	sub	r9,-1
80004620:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80004622:	fe f9 08 ea 	ld.w	r9,pc[2282]
80004626:	92 08       	ld.sh	r8,r9[0x0]
80004628:	20 28       	sub	r8,2
8000462a:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000462c:	30 09       	mov	r9,0
8000462e:	f2 08 19 00 	cp.h	r8,r9
80004632:	e0 8a 00 07 	brle	80004640 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
80004636:	30 19       	mov	r9,1
80004638:	fe f8 08 d0 	ld.w	r8,pc[2256]
8000463c:	91 09       	st.w	r8[0x0],r9
8000463e:	c7 b8       	rjmp	80004734 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80004640:	30 39       	mov	r9,3
80004642:	fe f8 08 c6 	ld.w	r8,pc[2246]
80004646:	91 09       	st.w	r8[0x0],r9
80004648:	c7 68       	rjmp	80004734 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000464a:	ec 0a 14 10 	asr	r10,r6,0x10
8000464e:	fe f8 08 d6 	ld.w	r8,pc[2262]
80004652:	90 09       	ld.sh	r9,r8[0x0]
80004654:	14 09       	add	r9,r10
80004656:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80004658:	fe f9 08 b8 	ld.w	r9,pc[2232]
8000465c:	92 08       	ld.sh	r8,r9[0x0]
8000465e:	fe fb 08 be 	ld.w	r11,pc[2238]
80004662:	76 0b       	ld.w	r11,r11[0x0]
80004664:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80004668:	2f f8       	sub	r8,-1
8000466a:	5c 88       	casts.h	r8
8000466c:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
8000466e:	fe fa 08 9e 	ld.w	r10,pc[2206]
80004672:	94 09       	ld.sh	r9,r10[0x0]
80004674:	20 29       	sub	r9,2
80004676:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80004678:	30 0a       	mov	r10,0
8000467a:	f4 09 19 00 	cp.h	r9,r10
8000467e:	e0 89 00 1f 	brgt	800046bc <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80004682:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80004686:	e0 46 00 ba 	cp.w	r6,186
8000468a:	c0 d1       	brne	800046a4 <phy_rx_func+0x188>
8000468c:	fe f8 08 98 	ld.w	r8,pc[2200]
80004690:	90 09       	ld.sh	r9,r8[0x0]
80004692:	f4 09 19 00 	cp.h	r9,r10
80004696:	c0 71       	brne	800046a4 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80004698:	fe f8 08 84 	ld.w	r8,pc[2180]
8000469c:	70 0c       	ld.w	r12,r8[0x0]
8000469e:	f0 1f 02 23 	mcall	80004f28 <phy_rx_func+0xa0c>
800046a2:	c0 88       	rjmp	800046b2 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800046a4:	fe f6 08 78 	ld.w	r6,pc[2168]
800046a8:	6c 0c       	ld.w	r12,r6[0x0]
800046aa:	f0 1f 02 1e 	mcall	80004f20 <phy_rx_func+0xa04>
					phy_frame_ptr = NULL;
800046ae:	30 08       	mov	r8,0
800046b0:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
800046b2:	30 09       	mov	r9,0
800046b4:	fe f8 08 54 	ld.w	r8,pc[2132]
800046b8:	91 09       	st.w	r8[0x0],r9
800046ba:	c3 d8       	rjmp	80004734 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800046bc:	5c 86       	casts.h	r6
800046be:	fe f9 08 66 	ld.w	r9,pc[2150]
800046c2:	92 0a       	ld.sh	r10,r9[0x0]
800046c4:	0c 0a       	add	r10,r6
800046c6:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800046c8:	fe f9 08 54 	ld.w	r9,pc[2132]
800046cc:	72 09       	ld.w	r9,r9[0x0]
800046ce:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800046d2:	2f f8       	sub	r8,-1
800046d4:	fe f9 08 3c 	ld.w	r9,pc[2108]
800046d8:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800046da:	fe f9 08 32 	ld.w	r9,pc[2098]
800046de:	92 08       	ld.sh	r8,r9[0x0]
800046e0:	20 28       	sub	r8,2
800046e2:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800046e4:	30 09       	mov	r9,0
800046e6:	f2 08 19 00 	cp.h	r8,r9
800046ea:	e0 89 00 25 	brgt	80004734 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800046ee:	30 39       	mov	r9,3
800046f0:	fe f8 08 18 	ld.w	r8,pc[2072]
800046f4:	91 09       	st.w	r8[0x0],r9
800046f6:	c1 f8       	rjmp	80004734 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800046f8:	e6 16 00 ff 	andh	r6,0xff,COH
800046fc:	fc 19 00 ba 	movh	r9,0xba
80004700:	12 36       	cp.w	r6,r9
80004702:	c0 e1       	brne	8000471e <phy_rx_func+0x202>
80004704:	fe f8 08 20 	ld.w	r8,pc[2080]
80004708:	90 09       	ld.sh	r9,r8[0x0]
8000470a:	30 08       	mov	r8,0
8000470c:	f0 09 19 00 	cp.h	r9,r8
80004710:	c0 71       	brne	8000471e <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80004712:	fe f8 08 0a 	ld.w	r8,pc[2058]
80004716:	70 0c       	ld.w	r12,r8[0x0]
80004718:	f0 1f 02 04 	mcall	80004f28 <phy_rx_func+0xa0c>
8000471c:	c0 88       	rjmp	8000472c <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
8000471e:	fe f6 07 fe 	ld.w	r6,pc[2046]
80004722:	6c 0c       	ld.w	r12,r6[0x0]
80004724:	f0 1f 01 ff 	mcall	80004f20 <phy_rx_func+0xa04>
				phy_frame_ptr = NULL;
80004728:	30 08       	mov	r8,0
8000472a:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000472c:	30 09       	mov	r9,0
8000472e:	fe f8 07 da 	ld.w	r8,pc[2010]
80004732:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80004734:	fe f8 07 f8 	ld.w	r8,pc[2040]
80004738:	11 89       	ld.ub	r9,r8[0x0]
8000473a:	30 08       	mov	r8,0
8000473c:	f0 09 18 00 	cp.b	r9,r8
80004740:	c1 31       	brne	80004766 <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
80004742:	fe f6 07 ee 	ld.w	r6,pc[2030]
80004746:	6c 0c       	ld.w	r12,r6[0x0]
80004748:	f0 1f 01 f4 	mcall	80004f18 <phy_rx_func+0x9fc>
8000474c:	fe f8 07 e8 	ld.w	r8,pc[2024]
80004750:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80004752:	6c 0c       	ld.w	r12,r6[0x0]
80004754:	f0 1f 01 f1 	mcall	80004f18 <phy_rx_func+0x9fc>
80004758:	fe f8 07 e0 	ld.w	r8,pc[2016]
8000475c:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000475e:	30 19       	mov	r9,1
80004760:	fe f8 07 cc 	ld.w	r8,pc[1996]
80004764:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80004766:	fe f8 07 d6 	ld.w	r8,pc[2006]
8000476a:	70 08       	ld.w	r8,r8[0x0]
8000476c:	58 28       	cp.w	r8,2
8000476e:	e0 80 01 72 	breq	80004a52 <phy_rx_func+0x536>
80004772:	58 38       	cp.w	r8,3
80004774:	e0 80 02 30 	breq	80004bd4 <phy_rx_func+0x6b8>
80004778:	58 08       	cp.w	r8,0
8000477a:	e0 81 03 c0 	brne	80004efa <phy_rx_func+0x9de>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000477e:	6e 28       	ld.w	r8,r7[0x8]
80004780:	e0 6a 5a 5a 	mov	r10,23130
80004784:	ea 1a ab cd 	orh	r10,0xabcd
80004788:	14 38       	cp.w	r8,r10
8000478a:	c0 71       	brne	80004798 <phy_rx_func+0x27c>
			{
				m_RxBurstType = VOICE_WATING;
8000478c:	30 09       	mov	r9,0
8000478e:	fe f8 07 b2 	ld.w	r8,pc[1970]
80004792:	91 09       	st.w	r8[0x0],r9
80004794:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80004798:	10 99       	mov	r9,r8
8000479a:	e0 19 00 00 	andl	r9,0x0
8000479e:	fc 1a ab cd 	movh	r10,0xabcd
800047a2:	14 39       	cp.w	r9,r10
800047a4:	e0 81 03 ab 	brne	80004efa <phy_rx_func+0x9de>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800047a8:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800047ac:	fe f9 07 98 	ld.w	r9,pc[1944]
800047b0:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800047b2:	fe f8 07 82 	ld.w	r8,pc[1922]
800047b6:	70 08       	ld.w	r8,r8[0x0]
800047b8:	58 08       	cp.w	r8,0
800047ba:	c0 60       	breq	800047c6 <phy_rx_func+0x2aa>
800047bc:	fe f8 07 7c 	ld.w	r8,pc[1916]
800047c0:	70 08       	ld.w	r8,r8[0x0]
800047c2:	58 08       	cp.w	r8,0
800047c4:	c1 61       	brne	800047f0 <phy_rx_func+0x2d4>
			{
				payload_ptr = get_payload_idle_isr();
800047c6:	fe f6 07 6a 	ld.w	r6,pc[1898]
800047ca:	6c 0c       	ld.w	r12,r6[0x0]
800047cc:	f0 1f 01 d3 	mcall	80004f18 <phy_rx_func+0x9fc>
800047d0:	fe f5 07 64 	ld.w	r5,pc[1892]
800047d4:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
800047d6:	6c 0c       	ld.w	r12,r6[0x0]
800047d8:	f0 1f 01 d0 	mcall	80004f18 <phy_rx_func+0x9fc>
800047dc:	fe f8 07 5c 	ld.w	r8,pc[1884]
800047e0:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800047e2:	6a 08       	ld.w	r8,r5[0x0]
800047e4:	58 08       	cp.w	r8,0
800047e6:	e0 80 03 8a 	breq	80004efa <phy_rx_func+0x9de>
800047ea:	58 0c       	cp.w	r12,0
800047ec:	e0 80 03 87 	breq	80004efa <phy_rx_func+0x9de>
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800047f0:	6e 28       	ld.w	r8,r7[0x8]
800047f2:	e2 18 f0 00 	andl	r8,0xf000,COH
800047f6:	e0 48 c0 00 	cp.w	r8,49152
800047fa:	e0 81 00 99 	brne	8000492c <phy_rx_func+0x410>
			{
				AMBE_flag = 1;
800047fe:	30 19       	mov	r9,1
80004800:	fe f8 07 48 	ld.w	r8,pc[1864]
80004804:	b0 89       	st.b	r8[0x0],r9
								
				Item_ID = payload_rx_channel->byte[5];
80004806:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000480a:	fe f8 07 42 	ld.w	r8,pc[1858]
8000480e:	b0 89       	st.b	r8[0x0],r9
				
				VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
80004810:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80004814:	fe f9 07 3c 	ld.w	r9,pc[1852]
80004818:	b2 8c       	st.b	r9[0x0],r12
					
				//The OB know the Call begin and discard the Voice Header
				//The OB know the Call end and discard the Voice  Terminator			
				if (Item_ID == Raw_Tx_Data_HT)
8000481a:	11 89       	ld.ub	r9,r8[0x0]
8000481c:	3f 08       	mov	r8,-16
8000481e:	f0 09 18 00 	cp.b	r9,r8
80004822:	c3 61       	brne	8000488e <phy_rx_func+0x372>
				{
					//HT_index = 0;
					//AMBE_HT[0] = payload_rx_channel->dword[0];
					//AMBE_HT[1] = payload_rx_channel->dword[1];
					//
					if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80004824:	ef 38 00 0e 	ld.ub	r8,r7[14]
80004828:	e2 18 00 f0 	andl	r8,0xf0,COH
8000482c:	59 08       	cp.w	r8,16
8000482e:	c0 71       	brne	8000483c <phy_rx_func+0x320>
					{
						m_RxBurstType = VOICEHEADER;		
80004830:	30 19       	mov	r9,1
80004832:	fe f8 07 0e 	ld.w	r8,pc[1806]
80004836:	91 09       	st.w	r8[0x0],r9
80004838:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

					}
					else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000483c:	e0 48 00 20 	cp.w	r8,32
80004840:	c2 11       	brne	80004882 <phy_rx_func+0x366>
					{
						m_RxBurstType = VOICETERMINATOR;
80004842:	30 99       	mov	r9,9
80004844:	fe f8 06 fc 	ld.w	r8,pc[1788]
80004848:	91 09       	st.w	r8[0x0],r9
						//AMBE-data and PCM-data is not the same. AMBE is compressed data,
						//if there was a missing portion, a clear voice is difficult to extract the data. 
						//It must ensure that all the data received AMBE.
						
						//0
						memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
8000484a:	fe f6 07 0a 	ld.w	r6,pc[1802]
8000484e:	6c 08       	ld.w	r8,r6[0x0]
80004850:	f0 0a 11 ff 	rsub	r10,r8,-1
80004854:	fe f7 06 e4 	ld.w	r7,pc[1764]
80004858:	2f f8       	sub	r8,-1
8000485a:	6e 0c       	ld.w	r12,r7[0x0]
8000485c:	f4 ca fe 00 	sub	r10,r10,-512
80004860:	30 0b       	mov	r11,0
80004862:	10 0c       	add	r12,r8
80004864:	f0 1f 01 bd 	mcall	80004f58 <phy_rx_func+0xa3c>
						
						RxAMBE_IsFillingNext8 = 0;
80004868:	30 08       	mov	r8,0
8000486a:	8d 08       	st.w	r6[0x0],r8
						payload_rx(AMBE_payload_ptr);
8000486c:	6e 0c       	ld.w	r12,r7[0x0]
8000486e:	f0 1f 01 bc 	mcall	80004f5c <phy_rx_func+0xa40>
						AMBE_payload_ptr = get_payload_idle_isr();
80004872:	fe f8 06 be 	ld.w	r8,pc[1726]
80004876:	70 0c       	ld.w	r12,r8[0x0]
80004878:	f0 1f 01 a8 	mcall	80004f18 <phy_rx_func+0x9fc>
8000487c:	8f 0c       	st.w	r7[0x0],r12
8000487e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						//logFromISR("\n\r QQ1 \n\r");
						
					}
					else//error voice
					{
						m_RxBurstType = VOICE_WATING;
80004882:	30 09       	mov	r9,0
80004884:	fe f8 06 bc 	ld.w	r8,pc[1724]
80004888:	91 09       	st.w	r8[0x0],r9
8000488a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
					break;//WAITINGABAB.
		
						
				}
				else if (Item_ID == Vocoder_Bit_Stream_Parameter)//Vocoder Bits Stream Parameter
8000488e:	fe f8 06 be 	ld.w	r8,pc[1726]
80004892:	11 89       	ld.ub	r9,r8[0x0]
80004894:	31 28       	mov	r8,18
80004896:	f0 09 18 00 	cp.b	r9,r8
8000489a:	c0 d1       	brne	800048b4 <phy_rx_func+0x398>
				{	
						
						VBSP_data[0] = payload_rx_channel->word[2];
8000489c:	8e 69       	ld.sh	r9,r7[0xc]
8000489e:	fe f8 06 c2 	ld.w	r8,pc[1730]
800048a2:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[3];
800048a4:	8e 79       	ld.sh	r9,r7[0xe]
800048a6:	b0 19       	st.h	r8[0x2],r9
						m_RxBurstType = CalculateBurst(VF_SN);
800048a8:	f0 1f 01 af 	mcall	80004f64 <phy_rx_func+0xa48>
800048ac:	fe f8 06 94 	ld.w	r8,pc[1684]
800048b0:	91 0c       	st.w	r8[0x0],r12
800048b2:	c3 78       	rjmp	80004920 <phy_rx_func+0x404>

				}
				else if ((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
800048b4:	fe f8 06 98 	ld.w	r8,pc[1688]
800048b8:	11 89       	ld.ub	r9,r8[0x0]
800048ba:	30 48       	mov	r8,4
800048bc:	f0 09 18 00 	cp.b	r9,r8
800048c0:	c0 80       	breq	800048d0 <phy_rx_func+0x3b4>
800048c2:	fe f8 06 8a 	ld.w	r8,pc[1674]
800048c6:	11 89       	ld.ub	r9,r8[0x0]
800048c8:	30 38       	mov	r8,3
800048ca:	f0 09 18 00 	cp.b	r9,r8
800048ce:	c1 c1       	brne	80004906 <phy_rx_func+0x3ea>
				{
					//break;
					m_RxBurstType = UNSUREDATA;
800048d0:	30 29       	mov	r9,2
800048d2:	fe f8 06 6e 	ld.w	r8,pc[1646]
800048d6:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[0] = payload_rx_channel->dword[0];
800048d8:	6e 29       	ld.w	r9,r7[0x8]
800048da:	fe f8 06 8e 	ld.w	r8,pc[1678]
800048de:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[1] = payload_rx_channel->dword[1];
800048e0:	6e 39       	ld.w	r9,r7[0xc]
800048e2:	91 19       	st.w	r8[0x4],r9
					
					if (RxBytesWaiting == 0x00000014)
800048e4:	fe f8 06 60 	ld.w	r8,pc[1632]
800048e8:	70 08       	ld.w	r8,r8[0x0]
800048ea:	59 48       	cp.w	r8,20
800048ec:	c0 61       	brne	800048f8 <phy_rx_func+0x3dc>
					{
						RxBytesWaiting = 0x18;//24 Reassigned
800048ee:	31 89       	mov	r9,24
800048f0:	fe f8 06 54 	ld.w	r8,pc[1620]
800048f4:	91 09       	st.w	r8[0x0],r9
800048f6:	c1 58       	rjmp	80004920 <phy_rx_func+0x404>
						//_flag =0;
							
					}
					if (RxBytesWaiting == 0x00000010)
800048f8:	59 08       	cp.w	r8,16
800048fa:	c1 31       	brne	80004920 <phy_rx_func+0x404>
					{
						RxBytesWaiting = 0x10;//16 Reassigned
800048fc:	31 09       	mov	r9,16
800048fe:	fe f8 06 46 	ld.w	r8,pc[1606]
80004902:	91 09       	st.w	r8[0x0],r9
80004904:	c0 e8       	rjmp	80004920 <phy_rx_func+0x404>
					
				}
				else
				{
					
					logFromISR("\n\r Item_ID:%x \n\r", payload_rx_channel->word[2]);
80004906:	8e e8       	ld.uh	r8,r7[0xc]
80004908:	1a d8       	st.w	--sp,r8
8000490a:	fe fc 06 62 	ld.w	r12,pc[1634]
8000490e:	f0 1f 01 99 	mcall	80004f70 <phy_rx_func+0xa54>
					logFromISR("\n\r Axiba \n\r");
80004912:	fe fc 06 62 	ld.w	r12,pc[1634]
80004916:	f0 1f 01 97 	mcall	80004f70 <phy_rx_func+0xa54>
8000491a:	2f fd       	sub	sp,-4
8000491c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//Radio Internal Parameter(0x7F):
					//The OB should use the route back this item to radio without change content.
					break;
				}
				
				RxMediaState = READING_AMBE_MEDIA;//Jump
80004920:	30 39       	mov	r9,3
80004922:	fe f8 06 1a 	ld.w	r8,pc[1562]
80004926:	91 09       	st.w	r8[0x0],r9
80004928:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
8000492c:	e0 48 10 00 	cp.w	r8,4096
80004930:	5f 19       	srne	r9
80004932:	e0 48 20 00 	cp.w	r8,8192
80004936:	5f 18       	srne	r8
80004938:	f3 e8 00 08 	and	r8,r9,r8
8000493c:	e0 81 02 df 	brne	80004efa <phy_rx_func+0x9de>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_flag = 0;
80004940:	fe f9 06 08 	ld.w	r9,pc[1544]
80004944:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
80004946:	fe f9 06 06 	ld.w	r9,pc[1542]
8000494a:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000494c:	6e 28       	ld.w	r8,r7[0x8]
8000494e:	e2 18 0f 00 	andl	r8,0xf00,COH
80004952:	58 18       	cp.w	r8,1
80004954:	e0 8b 00 4d 	brhi	800049ee <phy_rx_func+0x4d2>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80004958:	fe f9 05 ec 	ld.w	r9,pc[1516]
8000495c:	72 08       	ld.w	r8,r9[0x0]
8000495e:	20 48       	sub	r8,4
80004960:	93 08       	st.w	r9[0x0],r8
80004962:	e0 80 02 cc 	breq	80004efa <phy_rx_func+0x9de>
				ArrayDiscLength = payload_rx_channel->word[2];
80004966:	8e 68       	ld.sh	r8,r7[0xc]
80004968:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000496c:	fe f9 06 0c 	ld.w	r9,pc[1548]
80004970:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
80004972:	30 09       	mov	r9,0
80004974:	f2 08 19 00 	cp.h	r8,r9
80004978:	c0 70       	breq	80004986 <phy_rx_func+0x46a>
8000497a:	30 19       	mov	r9,1
8000497c:	f2 08 19 00 	cp.h	r8,r9
80004980:	e0 81 02 bd 	brne	80004efa <phy_rx_func+0x9de>
80004984:	c2 68       	rjmp	800049d0 <phy_rx_func+0x4b4>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004986:	fe f8 05 f6 	ld.w	r8,pc[1526]
8000498a:	70 0a       	ld.w	r10,r8[0x0]
8000498c:	fe f9 05 a8 	ld.w	r9,pc[1448]
80004990:	72 09       	ld.w	r9,r9[0x0]
80004992:	8e 7b       	ld.sh	r11,r7[0xe]
80004994:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80004998:	70 09       	ld.w	r9,r8[0x0]
8000499a:	2f f9       	sub	r9,-1
8000499c:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000499e:	e0 49 00 ff 	cp.w	r9,255
800049a2:	e0 88 00 11 	brls	800049c4 <phy_rx_func+0x4a8>
						{
							RxMedia_IsFillingNext16 = 0;	
800049a6:	30 09       	mov	r9,0
800049a8:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
800049aa:	fe f7 05 8a 	ld.w	r7,pc[1418]
800049ae:	6e 0c       	ld.w	r12,r7[0x0]
800049b0:	f0 1f 01 6b 	mcall	80004f5c <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
800049b4:	fe f8 05 7c 	ld.w	r8,pc[1404]
800049b8:	70 0c       	ld.w	r12,r8[0x0]
800049ba:	f0 1f 01 58 	mcall	80004f18 <phy_rx_func+0x9fc>
800049be:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
800049c0:	e0 80 02 9d 	breq	80004efa <phy_rx_func+0x9de>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
800049c4:	30 29       	mov	r9,2
800049c6:	fe f8 05 76 	ld.w	r8,pc[1398]
800049ca:	91 09       	st.w	r8[0x0],r9
800049cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800049d0:	8e 79       	ld.sh	r9,r7[0xe]
800049d2:	30 38       	mov	r8,3
800049d4:	f0 09 19 00 	cp.h	r9,r8
800049d8:	c0 51       	brne	800049e2 <phy_rx_func+0x4c6>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
800049da:	30 19       	mov	r9,1
800049dc:	fe f8 05 a4 	ld.w	r8,pc[1444]
800049e0:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
800049e2:	30 29       	mov	r9,2
800049e4:	fe f8 05 58 	ld.w	r8,pc[1368]
800049e8:	91 09       	st.w	r8[0x0],r9
800049ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
800049ee:	fe f8 05 56 	ld.w	r8,pc[1366]
800049f2:	70 08       	ld.w	r8,r8[0x0]
800049f4:	58 18       	cp.w	r8,1
800049f6:	e0 88 02 82 	brls	80004efa <phy_rx_func+0x9de>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
800049fa:	fe f8 05 82 	ld.w	r8,pc[1410]
800049fe:	70 0a       	ld.w	r10,r8[0x0]
80004a00:	fe f9 05 34 	ld.w	r9,pc[1332]
80004a04:	72 09       	ld.w	r9,r9[0x0]
80004a06:	6e 3b       	ld.w	r11,r7[0xc]
80004a08:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004a0c:	70 09       	ld.w	r9,r8[0x0]
80004a0e:	2f f9       	sub	r9,-1
80004a10:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a12:	e0 49 00 ff 	cp.w	r9,255
80004a16:	e0 88 00 11 	brls	80004a38 <phy_rx_func+0x51c>
				{
					RxMedia_IsFillingNext16 = 0;
80004a1a:	30 09       	mov	r9,0
80004a1c:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004a1e:	fe f7 05 16 	ld.w	r7,pc[1302]
80004a22:	6e 0c       	ld.w	r12,r7[0x0]
80004a24:	f0 1f 01 4e 	mcall	80004f5c <phy_rx_func+0xa40>
								payload_ptr = get_payload_idle_isr();
80004a28:	fe f8 05 08 	ld.w	r8,pc[1288]
80004a2c:	70 0c       	ld.w	r12,r8[0x0]
80004a2e:	f0 1f 01 3b 	mcall	80004f18 <phy_rx_func+0x9fc>
80004a32:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
80004a34:	e0 80 02 63 	breq	80004efa <phy_rx_func+0x9de>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80004a38:	fe f9 05 0c 	ld.w	r9,pc[1292]
80004a3c:	72 08       	ld.w	r8,r9[0x0]
80004a3e:	20 28       	sub	r8,2
80004a40:	93 08       	st.w	r9[0x0],r8
80004a42:	e0 80 02 5c 	breq	80004efa <phy_rx_func+0x9de>
				RxMediaState = READINGMEDIA;
80004a46:	30 29       	mov	r9,2
80004a48:	fe f8 04 f4 	ld.w	r8,pc[1268]
80004a4c:	91 09       	st.w	r8[0x0],r9
80004a4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80004a52:	fe f8 05 2a 	ld.w	r8,pc[1322]
80004a56:	70 0a       	ld.w	r10,r8[0x0]
80004a58:	fe f9 04 dc 	ld.w	r9,pc[1244]
80004a5c:	72 09       	ld.w	r9,r9[0x0]
80004a5e:	8e 4b       	ld.sh	r11,r7[0x8]
80004a60:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80004a64:	70 09       	ld.w	r9,r8[0x0]
80004a66:	2f f9       	sub	r9,-1
80004a68:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a6a:	e0 49 00 ff 	cp.w	r9,255
80004a6e:	e0 88 00 16 	brls	80004a9a <phy_rx_func+0x57e>
					{
							RxMedia_IsFillingNext16 = 0;
80004a72:	30 09       	mov	r9,0
80004a74:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004a76:	fe f6 04 be 	ld.w	r6,pc[1214]
80004a7a:	6c 0c       	ld.w	r12,r6[0x0]
80004a7c:	f0 1f 01 38 	mcall	80004f5c <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
80004a80:	fe f8 04 b0 	ld.w	r8,pc[1200]
80004a84:	70 0c       	ld.w	r12,r8[0x0]
80004a86:	f0 1f 01 25 	mcall	80004f18 <phy_rx_func+0x9fc>
80004a8a:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
80004a8c:	c0 71       	brne	80004a9a <phy_rx_func+0x57e>
							{
								RxMediaState = WAITINGABAB;
80004a8e:	30 09       	mov	r9,0
80004a90:	fe f8 04 ac 	ld.w	r8,pc[1196]
80004a94:	91 09       	st.w	r8[0x0],r9
80004a96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
80004a9a:	fe f9 04 aa 	ld.w	r9,pc[1194]
80004a9e:	72 08       	ld.w	r8,r9[0x0]
80004aa0:	20 28       	sub	r8,2
80004aa2:	93 08       	st.w	r9[0x0],r8
80004aa4:	c0 71       	brne	80004ab2 <phy_rx_func+0x596>
				{
					RxMediaState = WAITINGABAB;
80004aa6:	30 09       	mov	r9,0
80004aa8:	fe f8 04 94 	ld.w	r8,pc[1172]
80004aac:	91 09       	st.w	r8[0x0],r9
80004aae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80004ab2:	fe f8 04 ca 	ld.w	r8,pc[1226]
80004ab6:	70 0a       	ld.w	r10,r8[0x0]
80004ab8:	fe f9 04 7c 	ld.w	r9,pc[1148]
80004abc:	72 09       	ld.w	r9,r9[0x0]
80004abe:	8e 5b       	ld.sh	r11,r7[0xa]
80004ac0:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004ac4:	70 09       	ld.w	r9,r8[0x0]
80004ac6:	2f f9       	sub	r9,-1
80004ac8:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004aca:	e0 49 00 ff 	cp.w	r9,255
80004ace:	e0 88 00 16 	brls	80004afa <phy_rx_func+0x5de>
						{
							RxMedia_IsFillingNext16 = 0;
80004ad2:	30 09       	mov	r9,0
80004ad4:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004ad6:	fe f6 04 5e 	ld.w	r6,pc[1118]
80004ada:	6c 0c       	ld.w	r12,r6[0x0]
80004adc:	f0 1f 01 20 	mcall	80004f5c <phy_rx_func+0xa40>
								payload_ptr = get_payload_idle_isr();
80004ae0:	fe f8 04 50 	ld.w	r8,pc[1104]
80004ae4:	70 0c       	ld.w	r12,r8[0x0]
80004ae6:	f0 1f 01 0d 	mcall	80004f18 <phy_rx_func+0x9fc>
80004aea:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80004aec:	c0 71       	brne	80004afa <phy_rx_func+0x5de>
								{
									RxMediaState = WAITINGABAB;
80004aee:	30 09       	mov	r9,0
80004af0:	fe f8 04 4c 	ld.w	r8,pc[1100]
80004af4:	91 09       	st.w	r8[0x0],r9
80004af6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004afa:	fe f9 04 4a 	ld.w	r9,pc[1098]
80004afe:	72 08       	ld.w	r8,r9[0x0]
80004b00:	20 28       	sub	r8,2
80004b02:	93 08       	st.w	r9[0x0],r8
80004b04:	c0 71       	brne	80004b12 <phy_rx_func+0x5f6>
					RxMediaState = WAITINGABAB;
80004b06:	30 09       	mov	r9,0
80004b08:	fe f8 04 34 	ld.w	r8,pc[1076]
80004b0c:	91 09       	st.w	r8[0x0],r9
80004b0e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80004b12:	fe f8 04 6a 	ld.w	r8,pc[1130]
80004b16:	70 0a       	ld.w	r10,r8[0x0]
80004b18:	fe f9 04 1c 	ld.w	r9,pc[1052]
80004b1c:	72 09       	ld.w	r9,r9[0x0]
80004b1e:	8e 6b       	ld.sh	r11,r7[0xc]
80004b20:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004b24:	70 09       	ld.w	r9,r8[0x0]
80004b26:	2f f9       	sub	r9,-1
80004b28:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004b2a:	e0 49 00 ff 	cp.w	r9,255
80004b2e:	e0 88 00 16 	brls	80004b5a <phy_rx_func+0x63e>
						{
							RxMedia_IsFillingNext16 = 0;
80004b32:	30 09       	mov	r9,0
80004b34:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004b36:	fe f6 03 fe 	ld.w	r6,pc[1022]
80004b3a:	6c 0c       	ld.w	r12,r6[0x0]
80004b3c:	f0 1f 01 08 	mcall	80004f5c <phy_rx_func+0xa40>
									payload_ptr = get_payload_idle_isr();
80004b40:	fe f8 03 f0 	ld.w	r8,pc[1008]
80004b44:	70 0c       	ld.w	r12,r8[0x0]
80004b46:	f0 1f 00 f5 	mcall	80004f18 <phy_rx_func+0x9fc>
80004b4a:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
80004b4c:	c0 71       	brne	80004b5a <phy_rx_func+0x63e>
									{
										RxMediaState = WAITINGABAB;
80004b4e:	30 09       	mov	r9,0
80004b50:	fe f8 03 ec 	ld.w	r8,pc[1004]
80004b54:	91 09       	st.w	r8[0x0],r9
80004b56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004b5a:	fe f9 03 ea 	ld.w	r9,pc[1002]
80004b5e:	72 08       	ld.w	r8,r9[0x0]
80004b60:	20 28       	sub	r8,2
80004b62:	93 08       	st.w	r9[0x0],r8
80004b64:	c0 71       	brne	80004b72 <phy_rx_func+0x656>
					RxMediaState = WAITINGABAB;
80004b66:	30 09       	mov	r9,0
80004b68:	fe f8 03 d4 	ld.w	r8,pc[980]
80004b6c:	91 09       	st.w	r8[0x0],r9
80004b6e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004b72:	fe f8 04 0a 	ld.w	r8,pc[1034]
80004b76:	70 0a       	ld.w	r10,r8[0x0]
80004b78:	fe f9 03 bc 	ld.w	r9,pc[956]
80004b7c:	72 09       	ld.w	r9,r9[0x0]
80004b7e:	8e 7b       	ld.sh	r11,r7[0xe]
80004b80:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004b84:	70 09       	ld.w	r9,r8[0x0]
80004b86:	2f f9       	sub	r9,-1
80004b88:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004b8a:	e0 49 00 ff 	cp.w	r9,255
80004b8e:	e0 88 00 16 	brls	80004bba <phy_rx_func+0x69e>
						{
							RxMedia_IsFillingNext16 = 0;
80004b92:	30 09       	mov	r9,0
80004b94:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004b96:	fe f7 03 9e 	ld.w	r7,pc[926]
80004b9a:	6e 0c       	ld.w	r12,r7[0x0]
80004b9c:	f0 1f 00 f0 	mcall	80004f5c <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
80004ba0:	fe f8 03 90 	ld.w	r8,pc[912]
80004ba4:	70 0c       	ld.w	r12,r8[0x0]
80004ba6:	f0 1f 00 dd 	mcall	80004f18 <phy_rx_func+0x9fc>
80004baa:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004bac:	c0 71       	brne	80004bba <phy_rx_func+0x69e>
							{
								RxMediaState = WAITINGABAB;
80004bae:	30 09       	mov	r9,0
80004bb0:	fe f8 03 8c 	ld.w	r8,pc[908]
80004bb4:	91 09       	st.w	r8[0x0],r9
80004bb6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004bba:	fe f9 03 8a 	ld.w	r9,pc[906]
80004bbe:	72 08       	ld.w	r8,r9[0x0]
80004bc0:	20 28       	sub	r8,2
80004bc2:	93 08       	st.w	r9[0x0],r8
80004bc4:	e0 81 01 9b 	brne	80004efa <phy_rx_func+0x9de>
					RxMediaState = WAITINGABAB;
80004bc8:	30 09       	mov	r9,0
80004bca:	fe f8 03 72 	ld.w	r8,pc[882]
80004bce:	91 09       	st.w	r8[0x0],r9
80004bd0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			break; //End of READINGMEDIA.

		case READING_AMBE_MEDIA:
			
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80004bd4:	fe f8 03 78 	ld.w	r8,pc[888]
80004bd8:	11 89       	ld.ub	r9,r8[0x0]
80004bda:	31 28       	mov	r8,18
80004bdc:	f0 09 18 00 	cp.b	r9,r8
80004be0:	e0 81 01 32 	brne	80004e44 <phy_rx_func+0x928>
					{
						Item_ID = payload_rx_channel->byte[1];
80004be4:	ef 39 00 09 	ld.ub	r9,r7[9]
80004be8:	fe f8 03 64 	ld.w	r8,pc[868]
80004bec:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)
80004bee:	11 89       	ld.ub	r9,r8[0x0]
80004bf0:	3f 28       	mov	r8,-14
80004bf2:	f0 09 18 00 	cp.b	r9,r8
80004bf6:	e0 81 01 22 	brne	80004e3a <phy_rx_func+0x91e>
						{
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80004bfa:	6e 29       	ld.w	r9,r7[0x8]
80004bfc:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80004c00:	fe f8 03 44 	ld.w	r8,pc[836]
80004c04:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80004c06:	8e 59       	ld.sh	r9,r7[0xa]
80004c08:	fe f8 03 7c 	ld.w	r8,pc[892]
80004c0c:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80004c0e:	8e 69       	ld.sh	r9,r7[0xc]
80004c10:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80004c12:	8e 79       	ld.sh	r9,r7[0xe]
80004c14:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80004c16:	fe f8 03 3e 	ld.w	r8,pc[830]
80004c1a:	fe f9 03 1e 	ld.w	r9,pc[798]
80004c1e:	72 0a       	ld.w	r10,r9[0x0]
80004c20:	70 09       	ld.w	r9,r8[0x0]
80004c22:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80004c26:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004c2a:	70 09       	ld.w	r9,r8[0x0]
80004c2c:	2f f9       	sub	r9,-1
80004c2e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004c30:	e0 49 01 ff 	cp.w	r9,511
80004c34:	e0 88 00 16 	brls	80004c60 <phy_rx_func+0x744>
							{
								RxAMBE_IsFillingNext8 = 0;
80004c38:	30 09       	mov	r9,0
80004c3a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004c3c:	fe f6 02 fc 	ld.w	r6,pc[764]
80004c40:	6c 0c       	ld.w	r12,r6[0x0]
80004c42:	f0 1f 00 c7 	mcall	80004f5c <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004c46:	fe f8 02 ea 	ld.w	r8,pc[746]
80004c4a:	70 0c       	ld.w	r12,r8[0x0]
80004c4c:	f0 1f 00 b3 	mcall	80004f18 <phy_rx_func+0x9fc>
80004c50:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004c52:	c0 71       	brne	80004c60 <phy_rx_func+0x744>
								{
									RxMediaState = WAITINGABAB;
80004c54:	30 09       	mov	r9,0
80004c56:	fe f8 02 e6 	ld.w	r8,pc[742]
80004c5a:	91 09       	st.w	r8[0x0],r9
80004c5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004c60:	fe f9 02 e4 	ld.w	r9,pc[740]
80004c64:	72 08       	ld.w	r8,r9[0x0]
80004c66:	20 18       	sub	r8,1
80004c68:	93 08       	st.w	r9[0x0],r8
80004c6a:	c0 71       	brne	80004c78 <phy_rx_func+0x75c>
								RxMediaState = WAITINGABAB;
80004c6c:	30 09       	mov	r9,0
80004c6e:	fe f8 02 ce 	ld.w	r8,pc[718]
80004c72:	91 09       	st.w	r8[0x0],r9
80004c74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80004c78:	fe f8 02 dc 	ld.w	r8,pc[732]
80004c7c:	fe f9 02 bc 	ld.w	r9,pc[700]
80004c80:	72 0a       	ld.w	r10,r9[0x0]
80004c82:	70 09       	ld.w	r9,r8[0x0]
80004c84:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80004c88:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004c8c:	70 09       	ld.w	r9,r8[0x0]
80004c8e:	2f f9       	sub	r9,-1
80004c90:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004c92:	e0 49 01 ff 	cp.w	r9,511
80004c96:	e0 88 00 16 	brls	80004cc2 <phy_rx_func+0x7a6>
							{
								RxAMBE_IsFillingNext8 = 0;
80004c9a:	30 09       	mov	r9,0
80004c9c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004c9e:	fe f6 02 9a 	ld.w	r6,pc[666]
80004ca2:	6c 0c       	ld.w	r12,r6[0x0]
80004ca4:	f0 1f 00 ae 	mcall	80004f5c <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004ca8:	fe f8 02 88 	ld.w	r8,pc[648]
80004cac:	70 0c       	ld.w	r12,r8[0x0]
80004cae:	f0 1f 00 9b 	mcall	80004f18 <phy_rx_func+0x9fc>
80004cb2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004cb4:	c0 71       	brne	80004cc2 <phy_rx_func+0x7a6>
								{
									RxMediaState = WAITINGABAB;
80004cb6:	30 09       	mov	r9,0
80004cb8:	fe f8 02 84 	ld.w	r8,pc[644]
80004cbc:	91 09       	st.w	r8[0x0],r9
80004cbe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004cc2:	fe f9 02 82 	ld.w	r9,pc[642]
80004cc6:	72 08       	ld.w	r8,r9[0x0]
80004cc8:	20 18       	sub	r8,1
80004cca:	93 08       	st.w	r9[0x0],r8
80004ccc:	c0 71       	brne	80004cda <phy_rx_func+0x7be>
								RxMediaState = WAITINGABAB;
80004cce:	30 09       	mov	r9,0
80004cd0:	fe f8 02 6c 	ld.w	r8,pc[620]
80004cd4:	91 09       	st.w	r8[0x0],r9
80004cd6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80004cda:	fe f8 02 7a 	ld.w	r8,pc[634]
80004cde:	fe f9 02 5a 	ld.w	r9,pc[602]
80004ce2:	72 0a       	ld.w	r10,r9[0x0]
80004ce4:	70 09       	ld.w	r9,r8[0x0]
80004ce6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80004cea:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004cee:	70 09       	ld.w	r9,r8[0x0]
80004cf0:	2f f9       	sub	r9,-1
80004cf2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004cf4:	e0 49 01 ff 	cp.w	r9,511
80004cf8:	e0 88 00 16 	brls	80004d24 <phy_rx_func+0x808>
							{
								RxAMBE_IsFillingNext8 = 0;
80004cfc:	30 09       	mov	r9,0
80004cfe:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004d00:	fe f6 02 38 	ld.w	r6,pc[568]
80004d04:	6c 0c       	ld.w	r12,r6[0x0]
80004d06:	f0 1f 00 96 	mcall	80004f5c <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004d0a:	fe f8 02 26 	ld.w	r8,pc[550]
80004d0e:	70 0c       	ld.w	r12,r8[0x0]
80004d10:	f0 1f 00 82 	mcall	80004f18 <phy_rx_func+0x9fc>
80004d14:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004d16:	c0 71       	brne	80004d24 <phy_rx_func+0x808>
								{
									RxMediaState = WAITINGABAB;
80004d18:	30 09       	mov	r9,0
80004d1a:	fe f8 02 22 	ld.w	r8,pc[546]
80004d1e:	91 09       	st.w	r8[0x0],r9
80004d20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004d24:	fe f9 02 20 	ld.w	r9,pc[544]
80004d28:	72 08       	ld.w	r8,r9[0x0]
80004d2a:	20 18       	sub	r8,1
80004d2c:	93 08       	st.w	r9[0x0],r8
80004d2e:	c0 71       	brne	80004d3c <phy_rx_func+0x820>
								RxMediaState = WAITINGABAB;
80004d30:	30 09       	mov	r9,0
80004d32:	fe f8 02 0a 	ld.w	r8,pc[522]
80004d36:	91 09       	st.w	r8[0x0],r9
80004d38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80004d3c:	fe f8 02 18 	ld.w	r8,pc[536]
80004d40:	4f e9       	lddpc	r9,80004f38 <phy_rx_func+0xa1c>
80004d42:	72 0a       	ld.w	r10,r9[0x0]
80004d44:	70 09       	ld.w	r9,r8[0x0]
80004d46:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80004d4a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004d4e:	70 09       	ld.w	r9,r8[0x0]
80004d50:	2f f9       	sub	r9,-1
80004d52:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004d54:	e0 49 01 ff 	cp.w	r9,511
80004d58:	e0 88 00 13 	brls	80004d7e <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80004d5c:	30 09       	mov	r9,0
80004d5e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004d60:	4f 66       	lddpc	r6,80004f38 <phy_rx_func+0xa1c>
80004d62:	6c 0c       	ld.w	r12,r6[0x0]
80004d64:	f0 1f 00 7e 	mcall	80004f5c <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004d68:	4f 28       	lddpc	r8,80004f30 <phy_rx_func+0xa14>
80004d6a:	70 0c       	ld.w	r12,r8[0x0]
80004d6c:	f0 1f 00 6b 	mcall	80004f18 <phy_rx_func+0x9fc>
80004d70:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004d72:	c0 61       	brne	80004d7e <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80004d74:	30 09       	mov	r9,0
80004d76:	4f 28       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004d78:	91 09       	st.w	r8[0x0],r9
80004d7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004d7e:	4f 29       	lddpc	r9,80004f44 <phy_rx_func+0xa28>
80004d80:	72 08       	ld.w	r8,r9[0x0]
80004d82:	20 18       	sub	r8,1
80004d84:	93 08       	st.w	r9[0x0],r8
80004d86:	c0 61       	brne	80004d92 <phy_rx_func+0x876>
								RxMediaState = WAITINGABAB;
80004d88:	30 09       	mov	r9,0
80004d8a:	4e d8       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004d8c:	91 09       	st.w	r8[0x0],r9
80004d8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80004d92:	4f 18       	lddpc	r8,80004f54 <phy_rx_func+0xa38>
80004d94:	4e 99       	lddpc	r9,80004f38 <phy_rx_func+0xa1c>
80004d96:	72 0a       	ld.w	r10,r9[0x0]
80004d98:	70 09       	ld.w	r9,r8[0x0]
80004d9a:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004d9e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004da2:	70 09       	ld.w	r9,r8[0x0]
80004da4:	2f f9       	sub	r9,-1
80004da6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004da8:	e0 49 01 ff 	cp.w	r9,511
80004dac:	e0 88 00 13 	brls	80004dd2 <phy_rx_func+0x8b6>
							{
								RxAMBE_IsFillingNext8 = 0;
80004db0:	30 09       	mov	r9,0
80004db2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004db4:	4e 16       	lddpc	r6,80004f38 <phy_rx_func+0xa1c>
80004db6:	6c 0c       	ld.w	r12,r6[0x0]
80004db8:	f0 1f 00 69 	mcall	80004f5c <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004dbc:	4d d8       	lddpc	r8,80004f30 <phy_rx_func+0xa14>
80004dbe:	70 0c       	ld.w	r12,r8[0x0]
80004dc0:	f0 1f 00 56 	mcall	80004f18 <phy_rx_func+0x9fc>
80004dc4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004dc6:	c0 61       	brne	80004dd2 <phy_rx_func+0x8b6>
								{
									RxMediaState = WAITINGABAB;
80004dc8:	30 09       	mov	r9,0
80004dca:	4d d8       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004dcc:	91 09       	st.w	r8[0x0],r9
80004dce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004dd2:	4d d9       	lddpc	r9,80004f44 <phy_rx_func+0xa28>
80004dd4:	72 08       	ld.w	r8,r9[0x0]
80004dd6:	20 18       	sub	r8,1
80004dd8:	93 08       	st.w	r9[0x0],r8
80004dda:	c0 61       	brne	80004de6 <phy_rx_func+0x8ca>
								RxMediaState = WAITINGABAB;
80004ddc:	30 09       	mov	r9,0
80004dde:	4d 88       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004de0:	91 09       	st.w	r8[0x0],r9
80004de2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80004de6:	4d c8       	lddpc	r8,80004f54 <phy_rx_func+0xa38>
80004de8:	4d 49       	lddpc	r9,80004f38 <phy_rx_func+0xa1c>
80004dea:	72 0a       	ld.w	r10,r9[0x0]
80004dec:	70 09       	ld.w	r9,r8[0x0]
80004dee:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004df2:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004df6:	70 09       	ld.w	r9,r8[0x0]
80004df8:	2f f9       	sub	r9,-1
80004dfa:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004dfc:	e0 49 01 ff 	cp.w	r9,511
80004e00:	e0 88 00 13 	brls	80004e26 <phy_rx_func+0x90a>
							{
								RxAMBE_IsFillingNext8 = 0;
80004e04:	30 09       	mov	r9,0
80004e06:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004e08:	4c c7       	lddpc	r7,80004f38 <phy_rx_func+0xa1c>
80004e0a:	6e 0c       	ld.w	r12,r7[0x0]
80004e0c:	f0 1f 00 54 	mcall	80004f5c <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004e10:	4c 88       	lddpc	r8,80004f30 <phy_rx_func+0xa14>
80004e12:	70 0c       	ld.w	r12,r8[0x0]
80004e14:	f0 1f 00 41 	mcall	80004f18 <phy_rx_func+0x9fc>
80004e18:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004e1a:	c0 61       	brne	80004e26 <phy_rx_func+0x90a>
								{
									RxMediaState = WAITINGABAB;
80004e1c:	30 09       	mov	r9,0
80004e1e:	4c 88       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004e20:	91 09       	st.w	r8[0x0],r9
80004e22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004e26:	4c 89       	lddpc	r9,80004f44 <phy_rx_func+0xa28>
80004e28:	72 08       	ld.w	r8,r9[0x0]
80004e2a:	20 18       	sub	r8,1
80004e2c:	93 08       	st.w	r9[0x0],r8
80004e2e:	c6 61       	brne	80004efa <phy_rx_func+0x9de>
								RxMediaState = WAITINGABAB;
80004e30:	30 09       	mov	r9,0
80004e32:	4c 38       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004e34:	91 09       	st.w	r8[0x0],r9
80004e36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80004e3a:	30 09       	mov	r9,0
80004e3c:	4c 08       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004e3e:	91 09       	st.w	r8[0x0],r9
80004e40:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004e44:	4c 28       	lddpc	r8,80004f4c <phy_rx_func+0xa30>
80004e46:	11 89       	ld.ub	r9,r8[0x0]
80004e48:	3f 28       	mov	r8,-14
80004e4a:	f0 09 18 00 	cp.b	r9,r8
80004e4e:	c3 81       	brne	80004ebe <phy_rx_func+0x9a2>
					{
						
						
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004e50:	8e 49       	ld.sh	r9,r7[0x8]
80004e52:	4c d8       	lddpc	r8,80004f84 <phy_rx_func+0xa68>
80004e54:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80004e56:	4c 08       	lddpc	r8,80004f54 <phy_rx_func+0xa38>
80004e58:	4b 89       	lddpc	r9,80004f38 <phy_rx_func+0xa1c>
80004e5a:	72 0a       	ld.w	r10,r9[0x0]
80004e5c:	70 09       	ld.w	r9,r8[0x0]
80004e5e:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004e62:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004e66:	70 09       	ld.w	r9,r8[0x0]
80004e68:	2f f9       	sub	r9,-1
80004e6a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004e6c:	e0 49 01 ff 	cp.w	r9,511
80004e70:	e0 88 00 13 	brls	80004e96 <phy_rx_func+0x97a>
						{
							RxAMBE_IsFillingNext8 = 0;
80004e74:	30 09       	mov	r9,0
80004e76:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004e78:	4b 07       	lddpc	r7,80004f38 <phy_rx_func+0xa1c>
80004e7a:	6e 0c       	ld.w	r12,r7[0x0]
80004e7c:	f0 1f 00 38 	mcall	80004f5c <phy_rx_func+0xa40>
							AMBE_payload_ptr = get_payload_idle_isr();
80004e80:	4a c8       	lddpc	r8,80004f30 <phy_rx_func+0xa14>
80004e82:	70 0c       	ld.w	r12,r8[0x0]
80004e84:	f0 1f 00 25 	mcall	80004f18 <phy_rx_func+0x9fc>
80004e88:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004e8a:	c0 61       	brne	80004e96 <phy_rx_func+0x97a>
							{
								RxMediaState = WAITINGABAB;
80004e8c:	30 09       	mov	r9,0
80004e8e:	4a c8       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004e90:	91 09       	st.w	r8[0x0],r9
80004e92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004e96:	4a c9       	lddpc	r9,80004f44 <phy_rx_func+0xa28>
80004e98:	72 08       	ld.w	r8,r9[0x0]
80004e9a:	20 18       	sub	r8,1
80004e9c:	93 08       	st.w	r9[0x0],r8
80004e9e:	c0 61       	brne	80004eaa <phy_rx_func+0x98e>
							RxMediaState = WAITINGABAB;
80004ea0:	30 09       	mov	r9,0
80004ea2:	4a 78       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004ea4:	91 09       	st.w	r8[0x0],r9
80004ea6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
80004eaa:	20 18       	sub	r8,1
80004eac:	4a 69       	lddpc	r9,80004f44 <phy_rx_func+0xa28>
80004eae:	93 08       	st.w	r9[0x0],r8
80004eb0:	58 08       	cp.w	r8,0
80004eb2:	c2 41       	brne	80004efa <phy_rx_func+0x9de>
							RxMediaState = WAITINGABAB;
80004eb4:	30 09       	mov	r9,0
80004eb6:	4a 28       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004eb8:	91 09       	st.w	r8[0x0],r9
80004eba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						*******************/
						
								
					}
					
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004ebe:	4a 48       	lddpc	r8,80004f4c <phy_rx_func+0xa30>
80004ec0:	11 89       	ld.ub	r9,r8[0x0]
80004ec2:	30 48       	mov	r8,4
80004ec4:	f0 09 18 00 	cp.b	r9,r8
80004ec8:	c0 70       	breq	80004ed6 <phy_rx_func+0x9ba>
80004eca:	4a 18       	lddpc	r8,80004f4c <phy_rx_func+0xa30>
80004ecc:	11 89       	ld.ub	r9,r8[0x0]
80004ece:	30 38       	mov	r8,3
80004ed0:	f0 09 18 00 	cp.b	r9,r8
80004ed4:	c1 01       	brne	80004ef4 <phy_rx_func+0x9d8>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004ed6:	6e 29       	ld.w	r9,r7[0x8]
80004ed8:	4a 48       	lddpc	r8,80004f68 <phy_rx_func+0xa4c>
80004eda:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004edc:	6e 39       	ld.w	r9,r7[0xc]
80004ede:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004ee0:	49 99       	lddpc	r9,80004f44 <phy_rx_func+0xa28>
80004ee2:	72 08       	ld.w	r8,r9[0x0]
80004ee4:	20 88       	sub	r8,8
80004ee6:	93 08       	st.w	r9[0x0],r8
80004ee8:	c0 91       	brne	80004efa <phy_rx_func+0x9de>
						{
					
							RxBytesWaiting = 0;
80004eea:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004eec:	49 49       	lddpc	r9,80004f3c <phy_rx_func+0xa20>
80004eee:	93 08       	st.w	r9[0x0],r8
80004ef0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004ef4:	30 09       	mov	r9,0
80004ef6:	49 28       	lddpc	r8,80004f3c <phy_rx_func+0xa20>
80004ef8:	91 09       	st.w	r8[0x0],r9
80004efa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004efe:	00 00       	add	r0,r0
80004f00:	00 00       	add	r0,r0
80004f02:	10 5c       	eor	r12,r8
80004f04:	00 00       	add	r0,r0
80004f06:	10 34       	cp.w	r4,r8
80004f08:	00 00       	add	r0,r0
80004f0a:	10 38       	cp.w	r8,r8
80004f0c:	00 00       	add	r0,r0
80004f0e:	10 14       	sub	r4,r8
80004f10:	00 00       	add	r0,r0
80004f12:	10 04       	add	r4,r8
80004f14:	00 00       	add	r0,r0
80004f16:	10 2c       	rsub	r12,r8
80004f18:	80 00       	ld.sh	r0,r0[0x0]
80004f1a:	3d d0       	mov	r0,-35
80004f1c:	00 00       	add	r0,r0
80004f1e:	10 4c       	or	r12,r8
80004f20:	80 00       	ld.sh	r0,r0[0x0]
80004f22:	90 20       	ld.sh	r0,r8[0x4]
80004f24:	00 00       	add	r0,r0
80004f26:	10 3e       	cp.w	lr,r8
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	3d 44       	mov	r4,-44
80004f2c:	00 00       	add	r0,r0
80004f2e:	10 75       	tst	r5,r8
80004f30:	00 00       	add	r0,r0
80004f32:	10 1c       	sub	r12,r8
80004f34:	00 00       	add	r0,r0
80004f36:	10 30       	cp.w	r0,r8
80004f38:	00 00       	add	r0,r0
80004f3a:	10 7c       	tst	r12,r8
80004f3c:	00 00       	add	r0,r0
80004f3e:	10 50       	eor	r0,r8
80004f40:	00 00       	add	r0,r0
80004f42:	10 08       	add	r8,r8
80004f44:	00 00       	add	r0,r0
80004f46:	10 60       	and	r0,r8
80004f48:	00 00       	add	r0,r0
80004f4a:	0a 45       	or	r5,r5
80004f4c:	00 00       	add	r0,r0
80004f4e:	10 74       	tst	r4,r8
80004f50:	00 00       	add	r0,r0
80004f52:	0a 4c       	or	r12,r5
80004f54:	00 00       	add	r0,r0
80004f56:	10 6c       	and	r12,r8
80004f58:	80 00       	ld.sh	r0,r0[0x0]
80004f5a:	aa 9a       	st.b	r5[0x1],r10
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	43 f4       	lddsp	r4,sp[0xfc]
80004f60:	00 00       	add	r0,r0
80004f62:	14 58       	eor	r8,r10
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	3c 18       	mov	r8,-63
80004f68:	00 00       	add	r0,r0
80004f6a:	10 24       	rsub	r4,r8
80004f6c:	80 01       	ld.sh	r1,r0[0x0]
80004f6e:	94 44       	ld.sh	r4,r10[0x8]
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	a1 18       	ld.d	r8,--r0
80004f74:	80 01       	ld.sh	r1,r0[0x0]
80004f76:	94 58       	ld.sh	r8,r10[0xa]
80004f78:	00 00       	add	r0,r0
80004f7a:	10 54       	eor	r4,r8
80004f7c:	00 00       	add	r0,r0
80004f7e:	10 00       	add	r0,r8
80004f80:	00 00       	add	r0,r0
80004f82:	0a 44       	or	r4,r5
80004f84:	00 00       	add	r0,r0
80004f86:	13 60       	ld.uh	r0,--r9

80004f88 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004f88:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004f8a:	49 88       	lddpc	r8,80004fe8 <pdca_int_handler+0x60>
80004f8c:	11 89       	ld.ub	r9,r8[0x0]
80004f8e:	ec 19 00 01 	eorl	r9,0x1
80004f92:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004f94:	11 89       	ld.ub	r9,r8[0x0]
80004f96:	a5 69       	lsl	r9,0x4
80004f98:	2f c9       	sub	r9,-4
80004f9a:	49 5a       	lddpc	r10,80004fec <pdca_int_handler+0x64>
80004f9c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004f9e:	fe 7a 00 40 	mov	r10,-65472
80004fa2:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004fa4:	30 39       	mov	r9,3
80004fa6:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004fa8:	11 8a       	ld.ub	r10,r8[0x0]
80004faa:	a5 6a       	lsl	r10,0x4
80004fac:	2f ca       	sub	r10,-4
80004fae:	49 18       	lddpc	r8,80004ff0 <pdca_int_handler+0x68>
80004fb0:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004fb2:	fe 78 00 00 	mov	r8,-65536
80004fb6:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004fb8:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004fba:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004fbc:	48 e8       	lddpc	r8,80004ff4 <pdca_int_handler+0x6c>
80004fbe:	70 08       	ld.w	r8,r8[0x0]
80004fc0:	58 08       	cp.w	r8,0
80004fc2:	c0 70       	breq	80004fd0 <pdca_int_handler+0x48>
80004fc4:	48 99       	lddpc	r9,80004fe8 <pdca_int_handler+0x60>
80004fc6:	13 89       	ld.ub	r9,r9[0x0]
80004fc8:	a5 69       	lsl	r9,0x4
80004fca:	48 ac       	lddpc	r12,80004ff0 <pdca_int_handler+0x68>
80004fcc:	12 0c       	add	r12,r9
80004fce:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004fd0:	48 a8       	lddpc	r8,80004ff8 <pdca_int_handler+0x70>
80004fd2:	70 08       	ld.w	r8,r8[0x0]
80004fd4:	58 08       	cp.w	r8,0
80004fd6:	c0 70       	breq	80004fe4 <pdca_int_handler+0x5c>
80004fd8:	48 49       	lddpc	r9,80004fe8 <pdca_int_handler+0x60>
80004fda:	13 89       	ld.ub	r9,r9[0x0]
80004fdc:	a5 69       	lsl	r9,0x4
80004fde:	48 4c       	lddpc	r12,80004fec <pdca_int_handler+0x64>
80004fe0:	12 0c       	add	r12,r9
80004fe2:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004fe4:	d4 02       	popm	lr
80004fe6:	d6 03       	rete
80004fe8:	00 00       	add	r0,r0
80004fea:	46 60       	lddsp	r0,sp[0x198]
80004fec:	00 00       	add	r0,r0
80004fee:	46 88       	lddsp	r8,sp[0x1a0]
80004ff0:	00 00       	add	r0,r0
80004ff2:	46 68       	lddsp	r8,sp[0x198]
80004ff4:	00 00       	add	r0,r0
80004ff6:	10 84       	andn	r4,r8
80004ff8:	00 00       	add	r0,r0
80004ffa:	10 88       	andn	r8,r8

80004ffc <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004ffc:	fe 78 10 00 	mov	r8,-61440
80005000:	e0 69 0d c0 	mov	r9,3520
80005004:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80005008:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
8000500c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80005010:	fe 78 34 00 	mov	r8,-52224
80005014:	e0 69 80 00 	mov	r9,32768
80005018:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000501a:	30 09       	mov	r9,0
8000501c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000501e:	e0 69 04 21 	mov	r9,1057
80005022:	ea 19 3f 20 	orh	r9,0x3f20
80005026:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80005028:	e0 69 02 9f 	mov	r9,671
8000502c:	ea 19 01 00 	orh	r9,0x100
80005030:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80005032:	e0 6a 04 02 	mov	r10,1026
80005036:	ea 1a 3f 20 	orh	r10,0x3f20
8000503a:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
8000503c:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
8000503e:	5e fc       	retal	r12

80005040 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80005040:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80005042:	30 19       	mov	r9,1
80005044:	49 78       	lddpc	r8,800050a0 <local_start_PDC+0x60>
80005046:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80005048:	fe 78 00 00 	mov	r8,-65536
8000504c:	30 7b       	mov	r11,7
8000504e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80005050:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80005052:	49 59       	lddpc	r9,800050a4 <local_start_PDC+0x64>
80005054:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80005058:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
8000505a:	30 3a       	mov	r10,3
8000505c:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
8000505e:	30 1c       	mov	r12,1
80005060:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80005062:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80005064:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80005066:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80005068:	30 2c       	mov	r12,2
8000506a:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
8000506c:	48 f9       	lddpc	r9,800050a8 <local_start_PDC+0x68>
8000506e:	e0 68 5a 5a 	mov	r8,23130
80005072:	ea 18 ab cd 	orh	r8,0xabcd
80005076:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80005078:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
8000507a:	30 0e       	mov	lr,0
8000507c:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
8000507e:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80005080:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80005082:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80005084:	fe 78 00 40 	mov	r8,-65472
80005088:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000508a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
8000508c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80005090:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80005092:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80005094:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80005096:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80005098:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000509a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000509c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000509e:	d8 02       	popm	pc
800050a0:	00 00       	add	r0,r0
800050a2:	46 60       	lddsp	r0,sp[0x198]
800050a4:	00 00       	add	r0,r0
800050a6:	46 68       	lddsp	r8,sp[0x198]
800050a8:	00 00       	add	r0,r0
800050aa:	46 88       	lddsp	r8,sp[0x1a0]

800050ac <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
800050ac:	48 38       	lddpc	r8,800050b8 <register_rx_tx_func+0xc>
800050ae:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800050b0:	48 38       	lddpc	r8,800050bc <register_rx_tx_func+0x10>
800050b2:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800050b4:	5e fc       	retal	r12
800050b6:	00 00       	add	r0,r0
800050b8:	00 00       	add	r0,r0
800050ba:	10 84       	andn	r4,r8
800050bc:	00 00       	add	r0,r0
800050be:	10 88       	andn	r8,r8

800050c0 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800050c0:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800050c2:	fe 78 10 00 	mov	r8,-61440
800050c6:	30 29       	mov	r9,2
800050c8:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800050cc:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800050d0:	10 99       	mov	r9,r8
800050d2:	f2 f8 01 60 	ld.w	r8,r9[352]
800050d6:	e2 18 00 02 	andl	r8,0x2,COH
800050da:	cf c0       	breq	800050d2 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800050dc:	fe 79 10 00 	mov	r9,-61440
800050e0:	f2 f8 01 60 	ld.w	r8,r9[352]
800050e4:	e2 18 00 02 	andl	r8,0x2,COH
800050e8:	cf c1       	brne	800050e0 <ssc_init+0x20>
				
    INTC_register_interrupt (
800050ea:	30 3a       	mov	r10,3
800050ec:	36 0b       	mov	r11,96
800050ee:	48 bc       	lddpc	r12,80005118 <ssc_init+0x58>
800050f0:	f0 1f 00 0b 	mcall	8000511c <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
800050f4:	f0 1f 00 0b 	mcall	80005120 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
800050f8:	f0 1f 00 0b 	mcall	80005124 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800050fc:	fe 79 00 00 	mov	r9,-65536
80005100:	30 18       	mov	r8,1
80005102:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80005104:	fe 7a 00 40 	mov	r10,-65472
80005108:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000510a:	e0 6b 01 01 	mov	r11,257
8000510e:	fe 7a 34 00 	mov	r10,-52224
80005112:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80005114:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80005116:	d8 02       	popm	pc
80005118:	80 00       	ld.sh	r0,r0[0x0]
8000511a:	4f 88       	lddpc	r8,800052f8 <xcmp_init+0x4>
8000511c:	80 00       	ld.sh	r0,r0[0x0]
8000511e:	5d 08       	ror	r8
80005120:	80 00       	ld.sh	r0,r0[0x0]
80005122:	4f fc       	lddpc	r12,8000531c <xcmp_init+0x28>
80005124:	80 00       	ld.sh	r0,r0[0x0]
80005126:	50 40       	stdsp	sp[0x10],r0

80005128 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80005128:	48 28       	lddpc	r8,80005130 <xcmp_register_app_list+0x8>
8000512a:	91 0c       	st.w	r8[0x0],r12
}
8000512c:	5e fc       	retal	r12
8000512e:	00 00       	add	r0,r0
80005130:	00 00       	add	r0,r0
80005132:	46 a8       	lddsp	r8,sp[0x1a8]

80005134 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80005134:	eb cd 40 80 	pushm	r7,lr
80005138:	fa cd 01 00 	sub	sp,sp,256
8000513c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000513e:	16 98       	mov	r8,r11
80005140:	2f 08       	sub	r8,-16
80005142:	af a8       	sbr	r8,0xe
80005144:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80005146:	3f f8       	mov	r8,-1
80005148:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000514a:	30 b9       	mov	r9,11
8000514c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000514e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80005150:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80005152:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005154:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80005156:	f6 ca ff fe 	sub	r10,r11,-2
8000515a:	18 9b       	mov	r11,r12
8000515c:	fa cc ff f0 	sub	r12,sp,-16
80005160:	f0 1f 00 05 	mcall	80005174 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80005164:	2f e7       	sub	r7,-2
80005166:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80005168:	1a 9c       	mov	r12,sp
8000516a:	f0 1f 00 04 	mcall	80005178 <xcmp_tx+0x44>
}
8000516e:	2c 0d       	sub	sp,-256
80005170:	e3 cd 80 80 	ldm	sp++,r7,pc
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	a9 52       	asr	r2,0x9
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	55 f0       	stdsp	sp[0x17c],r0

8000517c <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
8000517c:	d4 01       	pushm	lr
8000517e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80005182:	e0 68 04 21 	mov	r8,1057
80005186:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80005188:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
8000518c:	30 09       	mov	r9,0
8000518e:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80005190:	30 19       	mov	r9,1
80005192:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
80005194:	30 39       	mov	r9,3
80005196:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80005198:	30 3b       	mov	r11,3
8000519a:	fa cc ff fe 	sub	r12,sp,-2
8000519e:	f0 1f 00 03 	mcall	800051a8 <xcmp_exit_device_control_mode+0x2c>
}
800051a2:	2c dd       	sub	sp,-204
800051a4:	d8 02       	popm	pc
800051a6:	00 00       	add	r0,r0
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	51 34       	stdsp	sp[0x4c],r4

800051ac <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
800051ac:	d4 01       	pushm	lr
800051ae:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
800051b2:	e0 68 04 21 	mov	r8,1057
800051b6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
800051b8:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
800051bc:	30 19       	mov	r9,1
800051be:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
800051c0:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
800051c2:	30 39       	mov	r9,3
800051c4:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
800051c6:	30 3b       	mov	r11,3
800051c8:	fa cc ff fe 	sub	r12,sp,-2
800051cc:	f0 1f 00 02 	mcall	800051d4 <xcmp_enter_device_control_mode+0x28>
}
800051d0:	2c dd       	sub	sp,-204
800051d2:	d8 02       	popm	pc
800051d4:	80 00       	ld.sh	r0,r0[0x0]
800051d6:	51 34       	stdsp	sp[0x4c],r4

800051d8 <xcmp_audio_route_AMBE>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_AMBE(void)
{
800051d8:	d4 01       	pushm	lr
800051da:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
800051de:	e0 68 04 14 	mov	r8,1044
800051e2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
800051e4:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
800051e8:	30 19       	mov	r9,1
800051ea:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
800051ec:	30 09       	mov	r9,0
800051ee:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
800051f0:	30 49       	mov	r9,4
800051f2:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//
	//
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
800051f4:	30 fa       	mov	r10,15
800051f6:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
800051f8:	30 c9       	mov	r9,12
800051fa:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
800051fc:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
800051fe:	b0 ea       	st.b	r8[0x6],r10

	
	ptr->RoutingData[2].audioInput = Tx_Voice_Header;//IN_Option_Board;
80005200:	31 1a       	mov	r10,17
80005202:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80005204:	f1 69 00 08 	st.b	r8[8],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[3].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80005208:	31 3a       	mov	r10,19
8000520a:	f1 6a 00 09 	st.b	r8[9],r10
	ptr->RoutingData[3].audioOutput = OUT_Option_Board;// OUT_Speaker;
8000520e:	f1 69 00 0a 	st.b	r8[10],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80005212:	30 bb       	mov	r11,11
80005214:	fa cc ff fe 	sub	r12,sp,-2
80005218:	f0 1f 00 02 	mcall	80005220 <xcmp_audio_route_AMBE+0x48>
}
8000521c:	2c dd       	sub	sp,-204
8000521e:	d8 02       	popm	pc
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	51 34       	stdsp	sp[0x4c],r4

80005224 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80005224:	d4 01       	pushm	lr
80005226:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
8000522a:	e0 68 04 65 	mov	r8,1125
8000522e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80005230:	fa cc ff fe 	sub	r12,sp,-2
80005234:	30 18       	mov	r8,1
80005236:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80005238:	30 1b       	mov	r11,1
8000523a:	f0 1f 00 03 	mcall	80005244 <xcmp_enter_enhanced_OB_mode+0x20>
}
8000523e:	2c dd       	sub	sp,-204
80005240:	d8 02       	popm	pc
80005242:	00 00       	add	r0,r0
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	51 34       	stdsp	sp[0x4c],r4

80005248 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80005248:	d4 01       	pushm	lr
8000524a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000524e:	fe 78 b4 00 	mov	r8,-19456
80005252:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80005254:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
80005258:	30 89       	mov	r9,8
8000525a:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
8000525c:	30 19       	mov	r9,1
8000525e:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80005260:	30 09       	mov	r9,0
80005262:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80005264:	30 5a       	mov	r10,5
80005266:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80005268:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
8000526a:	30 7a       	mov	r10,7
8000526c:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000526e:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80005270:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80005272:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80005276:	30 9b       	mov	r11,9
80005278:	fa cc ff fe 	sub	r12,sp,-2
8000527c:	f0 1f 00 02 	mcall	80005284 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80005280:	2c dd       	sub	sp,-204
80005282:	d8 02       	popm	pc
80005284:	80 00       	ld.sh	r0,r0[0x0]
80005286:	51 34       	stdsp	sp[0x4c],r4

80005288 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80005288:	d4 01       	pushm	lr
8000528a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
8000528e:	fe 78 80 00 	mov	r8,-32768
80005292:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80005294:	30 38       	mov	r8,3
80005296:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80005298:	30 1b       	mov	r11,1
8000529a:	fa cc ff fe 	sub	r12,sp,-2
8000529e:	f0 1f 00 03 	mcall	800052a8 <xcmp_opcode_not_supported+0x20>
}
800052a2:	2c dd       	sub	sp,-204
800052a4:	d8 02       	popm	pc
800052a6:	00 00       	add	r0,r0
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	51 34       	stdsp	sp[0x4c],r4

800052ac <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800052ac:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800052ae:	96 88       	ld.uh	r8,r11[0x0]
800052b0:	e2 18 f0 00 	andl	r8,0xf000,COH
800052b4:	e0 48 80 00 	cp.w	r8,32768
800052b8:	c0 f0       	breq	800052d6 <xcmp_exec_func+0x2a>
800052ba:	e0 48 b0 00 	cp.w	r8,45056
800052be:	c1 20       	breq	800052e2 <xcmp_exec_func+0x36>
800052c0:	58 08       	cp.w	r8,0
800052c2:	c1 51       	brne	800052ec <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800052c4:	78 08       	ld.w	r8,r12[0x0]
800052c6:	58 08       	cp.w	r8,0
800052c8:	c0 40       	breq	800052d0 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800052ca:	16 9c       	mov	r12,r11
800052cc:	5d 18       	icall	r8
800052ce:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800052d0:	f0 1f 00 08 	mcall	800052f0 <xcmp_exec_func+0x44>
800052d4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800052d6:	78 18       	ld.w	r8,r12[0x4]
800052d8:	58 08       	cp.w	r8,0
800052da:	c0 90       	breq	800052ec <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
800052dc:	16 9c       	mov	r12,r11
800052de:	5d 18       	icall	r8
800052e0:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
800052e2:	78 28       	ld.w	r8,r12[0x8]
800052e4:	58 08       	cp.w	r8,0
800052e6:	c0 30       	breq	800052ec <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
800052e8:	16 9c       	mov	r12,r11
800052ea:	5d 18       	icall	r8
800052ec:	d8 02       	popm	pc
800052ee:	00 00       	add	r0,r0
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	52 88       	stdsp	sp[0xa0],r8

800052f4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800052f4:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
800052f6:	f0 1f 00 0d 	mcall	80005328 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800052fa:	48 dc       	lddpc	r12,8000532c <xcmp_init+0x38>
800052fc:	f0 1f 00 0d 	mcall	80005330 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80005300:	30 4b       	mov	r11,4
80005302:	31 4c       	mov	r12,20
80005304:	f0 1f 00 0c 	mcall	80005334 <xcmp_init+0x40>
80005308:	48 c8       	lddpc	r8,80005338 <xcmp_init+0x44>
8000530a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
8000530c:	30 09       	mov	r9,0
8000530e:	1a d9       	st.w	--sp,r9
80005310:	1a d9       	st.w	--sp,r9
80005312:	1a d9       	st.w	--sp,r9
80005314:	30 38       	mov	r8,3
80005316:	e0 6a 01 80 	mov	r10,384
8000531a:	48 9b       	lddpc	r11,8000533c <xcmp_init+0x48>
8000531c:	48 9c       	lddpc	r12,80005340 <xcmp_init+0x4c>
8000531e:	f0 1f 00 0a 	mcall	80005344 <xcmp_init+0x50>
80005322:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80005324:	d8 02       	popm	pc
80005326:	00 00       	add	r0,r0
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	56 d4       	stdsp	sp[0x1b4],r4
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	54 44       	stdsp	sp[0x110],r4
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	54 90       	stdsp	sp[0x124],r0
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	94 f4       	ld.uh	r4,r10[0xe]
80005338:	00 00       	add	r0,r0
8000533a:	10 98       	mov	r8,r8
8000533c:	80 01       	ld.sh	r1,r0[0x0]
8000533e:	94 64       	ld.sh	r4,r10[0xc]
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	53 48       	stdsp	sp[0xd0],r8
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	9b c8       	st.w	sp[0x30],r8

80005348 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80005348:	d4 31       	pushm	r0-r7,lr
8000534a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
8000534c:	4b 16       	lddpc	r6,80005410 <xcmp_rx_process+0xc8>
8000534e:	30 05       	mov	r5,0
80005350:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80005352:	4b 13       	lddpc	r3,80005414 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80005354:	4b 12       	lddpc	r2,80005418 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80005356:	4b 21       	lddpc	r1,8000541c <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80005358:	4b 20       	lddpc	r0,80005420 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
8000535a:	6c 0c       	ld.w	r12,r6[0x0]
8000535c:	0a 99       	mov	r9,r5
8000535e:	08 9a       	mov	r10,r4
80005360:	1a 9b       	mov	r11,sp
80005362:	f0 1f 00 31 	mcall	80005424 <xcmp_rx_process+0xdc>
80005366:	58 1c       	cp.w	r12,1
80005368:	cf 91       	brne	8000535a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000536a:	40 0b       	lddsp	r11,sp[0x0]
8000536c:	58 0b       	cp.w	r11,0
8000536e:	cf 60       	breq	8000535a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80005370:	96 0a       	ld.sh	r10,r11[0x0]
80005372:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80005376:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000537a:	59 c8       	cp.w	r8,28
8000537c:	c1 e0       	breq	800053b8 <xcmp_rx_process+0x70>
8000537e:	e0 89 00 07 	brgt	8000538c <xcmp_rx_process+0x44>
80005382:	58 e8       	cp.w	r8,14
80005384:	c0 e0       	breq	800053a0 <xcmp_rx_process+0x58>
80005386:	58 f8       	cp.w	r8,15
80005388:	c2 41       	brne	800053d0 <xcmp_rx_process+0x88>
8000538a:	c0 f8       	rjmp	800053a8 <xcmp_rx_process+0x60>
8000538c:	e0 48 01 09 	cp.w	r8,265
80005390:	c1 80       	breq	800053c0 <xcmp_rx_process+0x78>
80005392:	e0 48 01 0a 	cp.w	r8,266
80005396:	c1 90       	breq	800053c8 <xcmp_rx_process+0x80>
80005398:	e0 48 00 2c 	cp.w	r8,44
8000539c:	c1 a1       	brne	800053d0 <xcmp_rx_process+0x88>
8000539e:	c0 98       	rjmp	800053b0 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800053a0:	4a 2c       	lddpc	r12,80005428 <xcmp_rx_process+0xe0>
800053a2:	f0 1f 00 23 	mcall	8000542c <xcmp_rx_process+0xe4>
					break;
800053a6:	c2 f8       	rjmp	80005404 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800053a8:	4a 2c       	lddpc	r12,80005430 <xcmp_rx_process+0xe8>
800053aa:	f0 1f 00 21 	mcall	8000542c <xcmp_rx_process+0xe4>
					break;
800053ae:	c2 b8       	rjmp	80005404 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800053b0:	4a 1c       	lddpc	r12,80005434 <xcmp_rx_process+0xec>
800053b2:	f0 1f 00 1f 	mcall	8000542c <xcmp_rx_process+0xe4>
					break;
800053b6:	c2 78       	rjmp	80005404 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800053b8:	04 9c       	mov	r12,r2
800053ba:	f0 1f 00 1d 	mcall	8000542c <xcmp_rx_process+0xe4>
						, ptr);
					break;
800053be:	c2 38       	rjmp	80005404 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800053c0:	02 9c       	mov	r12,r1
800053c2:	f0 1f 00 1b 	mcall	8000542c <xcmp_rx_process+0xe4>
					break;
800053c6:	c1 f8       	rjmp	80005404 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800053c8:	00 9c       	mov	r12,r0
800053ca:	f0 1f 00 19 	mcall	8000542c <xcmp_rx_process+0xe4>
					break;
800053ce:	c1 b8       	rjmp	80005404 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800053d0:	12 98       	mov	r8,r9
800053d2:	e2 18 04 00 	andl	r8,0x400,COH
800053d6:	c0 70       	breq	800053e4 <xcmp_rx_process+0x9c>
800053d8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800053dc:	e0 48 00 68 	cp.w	r8,104
800053e0:	e0 8a 00 08 	brle	800053f0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800053e4:	e2 19 f0 00 	andl	r9,0xf000,COH
800053e8:	c0 e1       	brne	80005404 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800053ea:	f0 1f 00 14 	mcall	80005438 <xcmp_rx_process+0xf0>
800053ee:	c0 b8       	rjmp	80005404 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800053f0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800053f4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800053f8:	49 19       	lddpc	r9,8000543c <xcmp_rx_process+0xf4>
800053fa:	72 08       	ld.w	r8,r9[0x0]
800053fc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005400:	f0 1f 00 0b 	mcall	8000542c <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80005404:	66 0c       	ld.w	r12,r3[0x0]
80005406:	40 0b       	lddsp	r11,sp[0x0]
80005408:	f0 1f 00 0e 	mcall	80005440 <xcmp_rx_process+0xf8>
8000540c:	ca 7b       	rjmp	8000535a <xcmp_rx_process+0x12>
8000540e:	00 00       	add	r0,r0
80005410:	00 00       	add	r0,r0
80005412:	10 98       	mov	r8,r8
80005414:	00 00       	add	r0,r0
80005416:	10 2c       	rsub	r12,r8
80005418:	00 00       	add	r0,r0
8000541a:	10 a8       	st.w	r8++,r8
8000541c:	00 00       	add	r0,r0
8000541e:	10 9c       	mov	r12,r8
80005420:	00 00       	add	r0,r0
80005422:	10 b4       	st.h	r8++,r4
80005424:	80 00       	ld.sh	r0,r0[0x0]
80005426:	91 90       	st.w	r8[0x24],r0
80005428:	00 00       	add	r0,r0
8000542a:	10 cc       	st.b	r8++,r12
8000542c:	80 00       	ld.sh	r0,r0[0x0]
8000542e:	52 ac       	stdsp	sp[0xa8],r12
80005430:	00 00       	add	r0,r0
80005432:	10 8c       	andn	r12,r8
80005434:	00 00       	add	r0,r0
80005436:	10 c0       	st.b	r8++,r0
80005438:	80 00       	ld.sh	r0,r0[0x0]
8000543a:	52 88       	stdsp	sp[0xa0],r8
8000543c:	00 00       	add	r0,r0
8000543e:	46 a8       	lddsp	r8,sp[0x1a8]
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	3d 7c       	mov	r12,-41

80005444 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80005444:	eb cd 40 90 	pushm	r4,r7,lr
80005448:	20 1d       	sub	sp,4
8000544a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000544e:	48 c8       	lddpc	r8,8000547c <xcmp_rx+0x38>
80005450:	70 0c       	ld.w	r12,r8[0x0]
80005452:	f0 1f 00 0c 	mcall	80005480 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80005456:	c1 00       	breq	80005476 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80005458:	fa c7 ff fc 	sub	r7,sp,-4
8000545c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000545e:	e0 6a 00 ca 	mov	r10,202
80005462:	08 9b       	mov	r11,r4
80005464:	f0 1f 00 08 	mcall	80005484 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80005468:	48 88       	lddpc	r8,80005488 <xcmp_rx+0x44>
8000546a:	70 0c       	ld.w	r12,r8[0x0]
8000546c:	30 09       	mov	r9,0
8000546e:	12 9a       	mov	r10,r9
80005470:	1a 9b       	mov	r11,sp
80005472:	f0 1f 00 07 	mcall	8000548c <xcmp_rx+0x48>
	}	
}
80005476:	2f fd       	sub	sp,-4
80005478:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000547c:	00 00       	add	r0,r0
8000547e:	10 2c       	rsub	r12,r8
80005480:	80 00       	ld.sh	r0,r0[0x0]
80005482:	43 6c       	lddsp	r12,sp[0xd8]
80005484:	80 00       	ld.sh	r0,r0[0x0]
80005486:	a9 52       	asr	r2,0x9
80005488:	00 00       	add	r0,r0
8000548a:	10 98       	mov	r8,r8
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	93 9c       	st.w	r9[0x24],r12

80005490 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80005490:	48 28       	lddpc	r8,80005498 <xnl_register_xcmp_func+0x8>
80005492:	91 0c       	st.w	r8[0x0],r12
}
80005494:	5e fc       	retal	r12
80005496:	00 00       	add	r0,r0
80005498:	00 00       	add	r0,r0
8000549a:	10 fc       	st.b	--r8,r12

8000549c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000549c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000549e:	48 88       	lddpc	r8,800054bc <xnl_get_msg_ack_func+0x20>
800054a0:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800054a2:	98 49       	ld.sh	r9,r12[0x8]
800054a4:	f0 09 19 00 	cp.h	r9,r8
800054a8:	c0 81       	brne	800054b8 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800054aa:	48 68       	lddpc	r8,800054c0 <xnl_get_msg_ack_func+0x24>
800054ac:	70 0c       	ld.w	r12,r8[0x0]
800054ae:	30 09       	mov	r9,0
800054b0:	12 9a       	mov	r10,r9
800054b2:	12 9b       	mov	r11,r9
800054b4:	f0 1f 00 04 	mcall	800054c4 <xnl_get_msg_ack_func+0x28>
800054b8:	d8 02       	popm	pc
800054ba:	00 00       	add	r0,r0
800054bc:	00 00       	add	r0,r0
800054be:	10 dc       	st.w	--r8,r12
800054c0:	00 00       	add	r0,r0
800054c2:	10 d8       	st.w	--r8,r8
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	93 9c       	st.w	r9[0x24],r12

800054c8 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
800054c8:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800054ca:	4a 86       	lddpc	r6,80005568 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800054cc:	4a 82       	lddpc	r2,8000556c <xnl_tx_process+0xa4>
800054ce:	4a 94       	lddpc	r4,80005570 <xnl_tx_process+0xa8>
800054d0:	30 07       	mov	r7,0
800054d2:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800054d4:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800054d6:	4a 85       	lddpc	r5,80005574 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800054d8:	4a 83       	lddpc	r3,80005578 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800054da:	6c 08       	ld.w	r8,r6[0x0]
800054dc:	58 08       	cp.w	r8,0
800054de:	c0 40       	breq	800054e6 <xnl_tx_process+0x1e>
800054e0:	58 18       	cp.w	r8,1
800054e2:	cf d1       	brne	800054dc <xnl_tx_process+0x14>
800054e4:	c2 08       	rjmp	80005524 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800054e6:	64 0c       	ld.w	r12,r2[0x0]
800054e8:	0e 99       	mov	r9,r7
800054ea:	02 9a       	mov	r10,r1
800054ec:	08 9b       	mov	r11,r4
800054ee:	f0 1f 00 24 	mcall	8000557c <xnl_tx_process+0xb4>
800054f2:	58 1c       	cp.w	r12,1
800054f4:	cf 31       	brne	800054da <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800054f6:	68 0c       	ld.w	r12,r4[0x0]
800054f8:	58 0c       	cp.w	r12,0
800054fa:	cf 00       	breq	800054da <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800054fc:	98 28       	ld.sh	r8,r12[0x4]
800054fe:	e0 08 19 00 	cp.h	r8,r0
80005502:	c0 41       	brne	8000550a <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80005504:	f0 1f 00 1f 	mcall	80005580 <xnl_tx_process+0xb8>
						break;
80005508:	ce 9b       	rjmp	800054da <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
8000550a:	f0 1f 00 1f 	mcall	80005584 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000550e:	30 18       	mov	r8,1
80005510:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80005512:	66 0c       	ld.w	r12,r3[0x0]
80005514:	0e 99       	mov	r9,r7
80005516:	0e 9a       	mov	r10,r7
80005518:	0e 9b       	mov	r11,r7
8000551a:	f0 1f 00 19 	mcall	8000557c <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
8000551e:	30 18       	mov	r8,1
80005520:	8d 08       	st.w	r6[0x0],r8
80005522:	cd cb       	rjmp	800054da <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80005524:	66 0c       	ld.w	r12,r3[0x0]
80005526:	0e 99       	mov	r9,r7
80005528:	36 4a       	mov	r10,100
8000552a:	0e 9b       	mov	r11,r7
8000552c:	f0 1f 00 14 	mcall	8000557c <xnl_tx_process+0xb4>
80005530:	58 1c       	cp.w	r12,1
80005532:	c0 81       	brne	80005542 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80005534:	49 58       	lddpc	r8,80005588 <xnl_tx_process+0xc0>
80005536:	70 0c       	ld.w	r12,r8[0x0]
80005538:	68 0b       	ld.w	r11,r4[0x0]
8000553a:	f0 1f 00 15 	mcall	8000558c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000553e:	8d 07       	st.w	r6[0x0],r7
80005540:	cc db       	rjmp	800054da <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80005542:	6a 08       	ld.w	r8,r5[0x0]
80005544:	58 38       	cp.w	r8,3
80005546:	e0 89 00 09 	brgt	80005558 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000554a:	68 0c       	ld.w	r12,r4[0x0]
8000554c:	f0 1f 00 0e 	mcall	80005584 <xnl_tx_process+0xbc>
						xnl_send_times++;
80005550:	6a 08       	ld.w	r8,r5[0x0]
80005552:	2f f8       	sub	r8,-1
80005554:	8b 08       	st.w	r5[0x0],r8
80005556:	cc 2b       	rjmp	800054da <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80005558:	48 c8       	lddpc	r8,80005588 <xnl_tx_process+0xc0>
8000555a:	70 0c       	ld.w	r12,r8[0x0]
8000555c:	68 0b       	ld.w	r11,r4[0x0]
8000555e:	f0 1f 00 0c 	mcall	8000558c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80005562:	8d 07       	st.w	r6[0x0],r7
80005564:	cb bb       	rjmp	800054da <xnl_tx_process+0x12>
80005566:	00 00       	add	r0,r0
80005568:	00 00       	add	r0,r0
8000556a:	10 f0       	st.b	--r8,r0
8000556c:	00 00       	add	r0,r0
8000556e:	10 ec       	st.h	--r8,r12
80005570:	00 00       	add	r0,r0
80005572:	10 e8       	st.h	--r8,r8
80005574:	00 00       	add	r0,r0
80005576:	10 f4       	st.b	--r8,r4
80005578:	00 00       	add	r0,r0
8000557a:	10 d8       	st.w	--r8,r8
8000557c:	80 00       	ld.sh	r0,r0[0x0]
8000557e:	91 90       	st.w	r8[0x24],r0
80005580:	80 00       	ld.sh	r0,r0[0x0]
80005582:	90 20       	ld.sh	r0,r8[0x4]
80005584:	80 00       	ld.sh	r0,r0[0x0]
80005586:	3d 9c       	mov	r12,-39
80005588:	00 00       	add	r0,r0
8000558a:	10 2c       	rsub	r12,r8
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	3d 7c       	mov	r12,-41

80005590 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80005590:	eb cd 40 fe 	pushm	r1-r7,lr
80005594:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80005596:	49 26       	lddpc	r6,800055dc <xnl_rx_process+0x4c>
80005598:	30 05       	mov	r5,0
8000559a:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000559c:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000559e:	49 11       	lddpc	r1,800055e0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800055a0:	49 12       	lddpc	r2,800055e4 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800055a2:	6c 0c       	ld.w	r12,r6[0x0]
800055a4:	0a 99       	mov	r9,r5
800055a6:	08 9a       	mov	r10,r4
800055a8:	1a 9b       	mov	r11,sp
800055aa:	f0 1f 00 10 	mcall	800055e8 <xnl_rx_process+0x58>
800055ae:	58 1c       	cp.w	r12,1
800055b0:	cf 91       	brne	800055a2 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
800055b2:	40 0c       	lddsp	r12,sp[0x0]
800055b4:	58 0c       	cp.w	r12,0
800055b6:	cf 60       	breq	800055a2 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800055b8:	98 28       	ld.sh	r8,r12[0x4]
800055ba:	e6 08 19 00 	cp.h	r8,r3
800055be:	e0 8b 00 0a 	brhi	800055d2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800055c2:	5c 78       	castu.h	r8
800055c4:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
800055c8:	58 09       	cp.w	r9,0
800055ca:	c0 40       	breq	800055d2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
800055cc:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800055d0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800055d2:	62 0c       	ld.w	r12,r1[0x0]
800055d4:	40 0b       	lddsp	r11,sp[0x0]
800055d6:	f0 1f 00 06 	mcall	800055ec <xnl_rx_process+0x5c>
800055da:	ce 4b       	rjmp	800055a2 <xnl_rx_process+0x12>
800055dc:	00 00       	add	r0,r0
800055de:	10 5c       	eor	r12,r8
800055e0:	00 00       	add	r0,r0
800055e2:	10 2c       	rsub	r12,r8
800055e4:	00 00       	add	r0,r0
800055e6:	04 fc       	st.b	--r2,r12
800055e8:	80 00       	ld.sh	r0,r0[0x0]
800055ea:	91 90       	st.w	r8[0x24],r0
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	3d 7c       	mov	r12,-41

800055f0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800055f0:	eb cd 40 c0 	pushm	r6-r7,lr
800055f4:	20 1d       	sub	sp,4
800055f6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800055f8:	98 39       	ld.sh	r9,r12[0x6]
800055fa:	3f f8       	mov	r8,-1
800055fc:	f0 09 19 00 	cp.h	r9,r8
80005600:	c0 a1       	brne	80005614 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80005602:	4a e9       	lddpc	r9,800056b8 <xnl_tx+0xc8>
80005604:	13 88       	ld.ub	r8,r9[0x0]
80005606:	2f f8       	sub	r8,-1
80005608:	5c 58       	castu.b	r8
8000560a:	b2 88       	st.b	r9[0x0],r8
8000560c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80005610:	a9 a8       	sbr	r8,0x8
80005612:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80005614:	8c 49       	ld.sh	r9,r6[0x8]
80005616:	3f f8       	mov	r8,-1
80005618:	f0 09 19 00 	cp.h	r9,r8
8000561c:	c0 41       	brne	80005624 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000561e:	4a 88       	lddpc	r8,800056bc <xnl_tx+0xcc>
80005620:	90 18       	ld.sh	r8,r8[0x2]
80005622:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80005624:	8c 59       	ld.sh	r9,r6[0xa]
80005626:	3f f8       	mov	r8,-1
80005628:	f0 09 19 00 	cp.h	r9,r8
8000562c:	c0 41       	brne	80005634 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000562e:	4a 48       	lddpc	r8,800056bc <xnl_tx+0xcc>
80005630:	90 28       	ld.sh	r8,r8[0x4]
80005632:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80005634:	8c 69       	ld.sh	r9,r6[0xc]
80005636:	3f f8       	mov	r8,-1
80005638:	f0 09 19 00 	cp.h	r9,r8
8000563c:	c0 e1       	brne	80005658 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000563e:	4a 08       	lddpc	r8,800056bc <xnl_tx+0xcc>
80005640:	90 49       	ld.sh	r9,r8[0x8]
80005642:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80005644:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80005646:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80005648:	90 49       	ld.sh	r9,r8[0x8]
8000564a:	e0 19 ff 00 	andl	r9,0xff00
8000564e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80005652:	f3 e8 10 08 	or	r8,r9,r8
80005656:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80005658:	0d 98       	ld.ub	r8,r6[0x1]
8000565a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000565c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80005660:	10 0c       	add	r12,r8
80005662:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80005664:	58 0c       	cp.w	r12,0
80005666:	e0 89 00 04 	brgt	8000566e <xnl_tx+0x7e>
8000566a:	30 09       	mov	r9,0
8000566c:	c0 d8       	rjmp	80005686 <xnl_tx+0x96>
8000566e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80005672:	2f ec       	sub	r12,-2
80005674:	30 09       	mov	r9,0
80005676:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80005678:	15 1b       	ld.sh	r11,r10++
8000567a:	f6 09 00 09 	add	r9,r11,r9
8000567e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80005680:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80005682:	18 38       	cp.w	r8,r12
80005684:	cf a1       	brne	80005678 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80005686:	5c 39       	neg	r9
80005688:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000568a:	48 e8       	lddpc	r8,800056c0 <xnl_tx+0xd0>
8000568c:	70 0c       	ld.w	r12,r8[0x0]
8000568e:	f0 1f 00 0e 	mcall	800056c4 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80005692:	c1 00       	breq	800056b2 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005694:	fa c7 ff fc 	sub	r7,sp,-4
80005698:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000569a:	e0 6a 01 00 	mov	r10,256
8000569e:	0c 9b       	mov	r11,r6
800056a0:	f0 1f 00 0a 	mcall	800056c8 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800056a4:	48 a8       	lddpc	r8,800056cc <xnl_tx+0xdc>
800056a6:	70 0c       	ld.w	r12,r8[0x0]
800056a8:	30 09       	mov	r9,0
800056aa:	12 9a       	mov	r10,r9
800056ac:	1a 9b       	mov	r11,sp
800056ae:	f0 1f 00 09 	mcall	800056d0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800056b2:	2f fd       	sub	sp,-4
800056b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056b8:	00 00       	add	r0,r0
800056ba:	10 f8       	st.b	--r8,r8
800056bc:	00 00       	add	r0,r0
800056be:	10 dc       	st.w	--r8,r12
800056c0:	00 00       	add	r0,r0
800056c2:	10 2c       	rsub	r12,r8
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	43 6c       	lddsp	r12,sp[0xd8]
800056c8:	80 00       	ld.sh	r0,r0[0x0]
800056ca:	a9 52       	asr	r2,0x9
800056cc:	00 00       	add	r0,r0
800056ce:	10 ec       	st.h	--r8,r12
800056d0:	80 00       	ld.sh	r0,r0[0x0]
800056d2:	93 9c       	st.w	r9[0x24],r12

800056d4 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800056d4:	eb cd 40 80 	pushm	r7,lr
800056d8:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
800056dc:	f0 1f 00 27 	mcall	80005778 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
800056e0:	30 09       	mov	r9,0
800056e2:	4a 78       	lddpc	r8,8000577c <xnl_init+0xa8>
800056e4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800056e6:	30 0b       	mov	r11,0
800056e8:	30 1c       	mov	r12,1
800056ea:	f0 1f 00 26 	mcall	80005780 <xnl_init+0xac>
800056ee:	4a 68       	lddpc	r8,80005784 <xnl_init+0xb0>
800056f0:	91 0c       	st.w	r8[0x0],r12
800056f2:	70 08       	ld.w	r8,r8[0x0]
800056f4:	58 08       	cp.w	r8,0
800056f6:	c0 80       	breq	80005706 <xnl_init+0x32>
800056f8:	4a 38       	lddpc	r8,80005784 <xnl_init+0xb0>
800056fa:	70 0c       	ld.w	r12,r8[0x0]
800056fc:	30 09       	mov	r9,0
800056fe:	12 9a       	mov	r10,r9
80005700:	12 9b       	mov	r11,r9
80005702:	f0 1f 00 22 	mcall	80005788 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
80005706:	30 4b       	mov	r11,4
80005708:	31 4c       	mov	r12,20
8000570a:	f0 1f 00 1e 	mcall	80005780 <xnl_init+0xac>
8000570e:	4a 08       	lddpc	r8,8000578c <xnl_init+0xb8>
80005710:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80005712:	30 07       	mov	r7,0
80005714:	1a d7       	st.w	--sp,r7
80005716:	1a d7       	st.w	--sp,r7
80005718:	1a d7       	st.w	--sp,r7
8000571a:	30 38       	mov	r8,3
8000571c:	0e 99       	mov	r9,r7
8000571e:	e0 6a 02 00 	mov	r10,512
80005722:	49 cb       	lddpc	r11,80005790 <xnl_init+0xbc>
80005724:	49 cc       	lddpc	r12,80005794 <xnl_init+0xc0>
80005726:	f0 1f 00 1d 	mcall	80005798 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000572a:	1a d7       	st.w	--sp,r7
8000572c:	1a d7       	st.w	--sp,r7
8000572e:	1a d7       	st.w	--sp,r7
80005730:	30 38       	mov	r8,3
80005732:	0e 99       	mov	r9,r7
80005734:	e0 6a 03 20 	mov	r10,800
80005738:	49 9b       	lddpc	r11,8000579c <xnl_init+0xc8>
8000573a:	49 ac       	lddpc	r12,800057a0 <xnl_init+0xcc>
8000573c:	f0 1f 00 17 	mcall	80005798 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80005740:	e0 68 40 0e 	mov	r8,16398
80005744:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005748:	3f f8       	mov	r8,-1
8000574a:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000574e:	30 38       	mov	r8,3
80005750:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80005754:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80005758:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000575c:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80005760:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80005764:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005768:	fa cc ff e8 	sub	r12,sp,-24
8000576c:	f0 1f 00 0e 	mcall	800057a4 <xnl_init+0xd0>
80005770:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80005772:	2c 0d       	sub	sp,-256
80005774:	e3 cd 80 80 	ldm	sp++,r7,pc
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	44 54       	lddsp	r4,sp[0x114]
8000577c:	00 00       	add	r0,r0
8000577e:	10 dc       	st.w	--r8,r12
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	94 f4       	ld.uh	r4,r10[0xe]
80005784:	00 00       	add	r0,r0
80005786:	10 d8       	st.w	--r8,r8
80005788:	80 00       	ld.sh	r0,r0[0x0]
8000578a:	93 9c       	st.w	r9[0x24],r12
8000578c:	00 00       	add	r0,r0
8000578e:	10 ec       	st.h	--r8,r12
80005790:	80 01       	ld.sh	r1,r0[0x0]
80005792:	94 6c       	ld.sh	r12,r10[0xc]
80005794:	80 00       	ld.sh	r0,r0[0x0]
80005796:	55 90       	stdsp	sp[0x164],r0
80005798:	80 00       	ld.sh	r0,r0[0x0]
8000579a:	9b c8       	st.w	sp[0x30],r8
8000579c:	80 01       	ld.sh	r1,r0[0x0]
8000579e:	02 00       	add	r0,r1
800057a0:	80 00       	ld.sh	r0,r0[0x0]
800057a2:	54 c8       	stdsp	sp[0x130],r8
800057a4:	80 00       	ld.sh	r0,r0[0x0]
800057a6:	55 f0       	stdsp	sp[0x17c],r0

800057a8 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800057a8:	eb cd 40 80 	pushm	r7,lr
800057ac:	fa cd 01 00 	sub	sp,sp,256
800057b0:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800057b2:	e0 68 40 0e 	mov	r8,16398
800057b6:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800057b8:	3f f8       	mov	r8,-1
800057ba:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
800057bc:	30 c8       	mov	r8,12
800057be:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
800057c0:	98 38       	ld.sh	r8,r12[0x6]
800057c2:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
800057c4:	98 58       	ld.sh	r8,r12[0xa]
800057c6:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
800057c8:	98 48       	ld.sh	r8,r12[0x8]
800057ca:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
800057cc:	98 68       	ld.sh	r8,r12[0xc]
800057ce:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800057d0:	30 08       	mov	r8,0
800057d2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800057d4:	1a 9c       	mov	r12,sp
800057d6:	f0 1f 00 0a 	mcall	800057fc <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800057da:	fa cd 00 cc 	sub	sp,sp,204
800057de:	e0 6a 00 ca 	mov	r10,202
800057e2:	ee cb ff f0 	sub	r11,r7,-16
800057e6:	1a 9c       	mov	r12,sp
800057e8:	f0 1f 00 06 	mcall	80005800 <xnl_data_msg_func+0x58>
800057ec:	48 68       	lddpc	r8,80005804 <xnl_data_msg_func+0x5c>
800057ee:	70 08       	ld.w	r8,r8[0x0]
800057f0:	5d 18       	icall	r8
800057f2:	fa cd ff 34 	sub	sp,sp,-204
}
800057f6:	2c 0d       	sub	sp,-256
800057f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800057fc:	80 00       	ld.sh	r0,r0[0x0]
800057fe:	55 f0       	stdsp	sp[0x17c],r0
80005800:	80 00       	ld.sh	r0,r0[0x0]
80005802:	a9 52       	asr	r2,0x9
80005804:	00 00       	add	r0,r0
80005806:	10 fc       	st.b	--r8,r12

80005808 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80005808:	d4 21       	pushm	r4-r7,lr
8000580a:	fa cd 01 00 	sub	sp,sp,256
8000580e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80005810:	4c 28       	lddpc	r8,80005918 <xnl_device_auth_reply_func+0x110>
80005812:	11 88       	ld.ub	r8,r8[0x0]
80005814:	58 08       	cp.w	r8,0
80005816:	c7 e1       	brne	80005912 <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80005818:	4c 18       	lddpc	r8,8000591c <xnl_device_auth_reply_func+0x114>
8000581a:	70 0c       	ld.w	r12,r8[0x0]
8000581c:	30 09       	mov	r9,0
8000581e:	12 9a       	mov	r10,r9
80005820:	12 9b       	mov	r11,r9
80005822:	f0 1f 00 40 	mcall	80005920 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80005826:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000582a:	4b c8       	lddpc	r8,80005918 <xnl_device_auth_reply_func+0x110>
8000582c:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000582e:	ef 39 00 12 	ld.ub	r9,r7[18]
80005832:	ef 38 00 13 	ld.ub	r8,r7[19]
80005836:	b1 68       	lsl	r8,0x10
80005838:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000583c:	ef 38 00 15 	ld.ub	r8,r7[21]
80005840:	f3 e8 10 08 	or	r8,r9,r8
80005844:	ef 39 00 14 	ld.ub	r9,r7[20]
80005848:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000584c:	ef 3a 00 16 	ld.ub	r10,r7[22]
80005850:	ef 38 00 17 	ld.ub	r8,r7[23]
80005854:	b1 68       	lsl	r8,0x10
80005856:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000585a:	ef 38 00 19 	ld.ub	r8,r7[25]
8000585e:	f5 e8 10 08 	or	r8,r10,r8
80005862:	ef 3a 00 18 	ld.ub	r10,r7[24]
80005866:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000586a:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000586c:	e0 64 79 b9 	mov	r4,31161
80005870:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005874:	e0 65 45 07 	mov	r5,17671
80005878:	ea 15 8a bd 	orh	r5,0x8abd
8000587c:	e0 66 f9 3d 	mov	r6,63805
80005880:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80005884:	e0 6e b8 cf 	mov	lr,47311
80005888:	ea 1e 36 83 	orh	lr,0x3683
8000588c:	e0 67 aa 1c 	mov	r7,43548
80005890:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005894:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005896:	f4 08 00 0c 	add	r12,r10,r8
8000589a:	f0 0b 15 04 	lsl	r11,r8,0x4
8000589e:	0a 0b       	add	r11,r5
800058a0:	f9 eb 20 0b 	eor	r11,r12,r11
800058a4:	f0 0c 16 05 	lsr	r12,r8,0x5
800058a8:	0c 0c       	add	r12,r6
800058aa:	18 5b       	eor	r11,r12
800058ac:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800058ae:	f2 0c 15 04 	lsl	r12,r9,0x4
800058b2:	1c 0c       	add	r12,lr
800058b4:	f2 0b 16 05 	lsr	r11,r9,0x5
800058b8:	0e 0b       	add	r11,r7
800058ba:	f9 eb 20 0b 	eor	r11,r12,r11
800058be:	f2 0a 00 0c 	add	r12,r9,r10
800058c2:	18 5b       	eor	r11,r12
800058c4:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800058c6:	e0 6b 37 20 	mov	r11,14112
800058ca:	ea 1b c6 ef 	orh	r11,0xc6ef
800058ce:	16 3a       	cp.w	r10,r11
800058d0:	ce 21       	brne	80005894 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800058d2:	e0 6a 40 1a 	mov	r10,16410
800058d6:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800058d8:	3f fa       	mov	r10,-1
800058da:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800058dc:	30 6b       	mov	r11,6
800058de:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800058e0:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800058e2:	48 eb       	lddpc	r11,80005918 <xnl_device_auth_reply_func+0x110>
800058e4:	96 1c       	ld.sh	r12,r11[0x2]
800058e6:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800058e8:	96 2b       	ld.sh	r11,r11[0x4]
800058ea:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800058ec:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800058ee:	30 ca       	mov	r10,12
800058f0:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800058f2:	30 0a       	mov	r10,0
800058f4:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800058f8:	30 7a       	mov	r10,7
800058fa:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800058fe:	30 2a       	mov	r10,2
80005900:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005904:	fa ca ff ec 	sub	r10,sp,-20
80005908:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000590a:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000590c:	1a 9c       	mov	r12,sp
8000590e:	f0 1f 00 06 	mcall	80005924 <xnl_device_auth_reply_func+0x11c>
}
80005912:	2c 0d       	sub	sp,-256
80005914:	d8 22       	popm	r4-r7,pc
80005916:	00 00       	add	r0,r0
80005918:	00 00       	add	r0,r0
8000591a:	10 dc       	st.w	--r8,r12
8000591c:	00 00       	add	r0,r0
8000591e:	10 d8       	st.w	--r8,r8
80005920:	80 00       	ld.sh	r0,r0[0x0]
80005922:	93 9c       	st.w	r9[0x24],r12
80005924:	80 00       	ld.sh	r0,r0[0x0]
80005926:	55 f0       	stdsp	sp[0x17c],r0

80005928 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80005928:	eb cd 40 80 	pushm	r7,lr
8000592c:	fa cd 01 00 	sub	sp,sp,256
80005930:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80005932:	49 28       	lddpc	r8,80005978 <xnl_master_status_brdcst_func+0x50>
80005934:	11 88       	ld.ub	r8,r8[0x0]
80005936:	58 08       	cp.w	r8,0
80005938:	c1 c1       	brne	80005970 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000593a:	49 18       	lddpc	r8,8000597c <xnl_master_status_brdcst_func+0x54>
8000593c:	70 0c       	ld.w	r12,r8[0x0]
8000593e:	30 09       	mov	r9,0
80005940:	12 9a       	mov	r10,r9
80005942:	12 9b       	mov	r11,r9
80005944:	f0 1f 00 0f 	mcall	80005980 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80005948:	8e 58       	ld.sh	r8,r7[0xa]
8000594a:	48 c9       	lddpc	r9,80005978 <xnl_master_status_brdcst_func+0x50>
8000594c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000594e:	e0 68 40 0e 	mov	r8,16398
80005952:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005954:	3f f8       	mov	r8,-1
80005956:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80005958:	30 4a       	mov	r10,4
8000595a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000595c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000595e:	92 19       	ld.sh	r9,r9[0x2]
80005960:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80005962:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005964:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80005966:	30 08       	mov	r8,0
80005968:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000596a:	1a 9c       	mov	r12,sp
8000596c:	f0 1f 00 06 	mcall	80005984 <xnl_master_status_brdcst_func+0x5c>
}
80005970:	2c 0d       	sub	sp,-256
80005972:	e3 cd 80 80 	ldm	sp++,r7,pc
80005976:	00 00       	add	r0,r0
80005978:	00 00       	add	r0,r0
8000597a:	10 dc       	st.w	--r8,r12
8000597c:	00 00       	add	r0,r0
8000597e:	10 d8       	st.w	--r8,r8
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	93 9c       	st.w	r9[0x24],r12
80005984:	80 00       	ld.sh	r0,r0[0x0]
80005986:	55 f0       	stdsp	sp[0x17c],r0

80005988 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80005988:	eb cd 40 80 	pushm	r7,lr
8000598c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000598e:	49 38       	lddpc	r8,800059d8 <xnl_device_conn_reply_func+0x50>
80005990:	70 0c       	ld.w	r12,r8[0x0]
80005992:	30 09       	mov	r9,0
80005994:	12 9a       	mov	r10,r9
80005996:	12 9b       	mov	r11,r9
80005998:	f0 1f 00 11 	mcall	800059dc <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000599c:	ef 18 00 10 	ld.uh	r8,r7[16]
800059a0:	10 99       	mov	r9,r8
800059a2:	e2 19 ff 00 	andl	r9,0xff00,COH
800059a6:	e0 49 01 00 	cp.w	r9,256
800059aa:	c0 60       	breq	800059b6 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800059ac:	0e 9c       	mov	r12,r7
800059ae:	f0 1f 00 0d 	mcall	800059e0 <xnl_device_conn_reply_func+0x58>
800059b2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
800059b6:	a9 68       	lsl	r8,0x8
800059b8:	48 b9       	lddpc	r9,800059e4 <xnl_device_conn_reply_func+0x5c>
800059ba:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
800059bc:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
800059c0:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
800059c2:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
800059c6:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
800059c8:	30 18       	mov	r8,1
800059ca:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
800059cc:	48 7c       	lddpc	r12,800059e8 <xnl_device_conn_reply_func+0x60>
800059ce:	f0 1f 00 08 	mcall	800059ec <xnl_device_conn_reply_func+0x64>
800059d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800059d6:	00 00       	add	r0,r0
800059d8:	00 00       	add	r0,r0
800059da:	10 d8       	st.w	--r8,r8
800059dc:	80 00       	ld.sh	r0,r0[0x0]
800059de:	93 9c       	st.w	r9[0x24],r12
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	59 28       	cp.w	r8,18
800059e4:	00 00       	add	r0,r0
800059e6:	10 dc       	st.w	--r8,r12
800059e8:	80 01       	ld.sh	r1,r0[0x0]
800059ea:	94 74       	ld.sh	r4,r10[0xe]
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	9f 8c       	st.w	pc[0x20],r12

800059f0 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800059f0:	fe 78 0c 00 	mov	r8,-62464
800059f4:	e0 69 03 07 	mov	r9,775
800059f8:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800059fa:	30 49       	mov	r9,4
800059fc:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800059fe:	71 59       	ld.w	r9,r8[0x54]
80005a00:	e2 19 00 80 	andl	r9,0x80,COH
80005a04:	cf d0       	breq	800059fe <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80005a06:	fe 78 0c 00 	mov	r8,-62464
80005a0a:	30 59       	mov	r9,5
80005a0c:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80005a0e:	e0 69 01 0d 	mov	r9,269
80005a12:	ea 19 10 07 	orh	r9,0x1007
80005a16:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005a18:	71 59       	ld.w	r9,r8[0x54]
80005a1a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005a1e:	cf d0       	breq	80005a18 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80005a20:	fe 78 0c 00 	mov	r8,-62464
80005a24:	fc 19 00 80 	movh	r9,0x80
80005a28:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005a2a:	34 0a       	mov	r10,64
80005a2c:	fe 69 14 00 	mov	r9,-125952
80005a30:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80005a32:	30 69       	mov	r9,6
80005a34:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80005a36:	30 19       	mov	r9,1
80005a38:	fe 68 10 00 	mov	r8,-126976
80005a3c:	91 19       	st.w	r8[0x4],r9
}
80005a3e:	5e fc       	retal	r12

80005a40 <read_a_byte>:
*/
U32 read_a_byte(U32 subaddress, S8 *datareceived)
{
	U32 TWI_Status = 0;

	AVR32_TWI.cr   =  AVR32_TWI_CR_MSEN_MASK | AVR32_TWI_CR_SVDIS_MASK;
80005a40:	fe 78 2c 00 	mov	r8,-54272
80005a44:	32 49       	mov	r9,36
80005a46:	91 09       	st.w	r8[0x0],r9
	AVR32_TWI.mmr  =  PCF8563_ADDRESS        << AVR32_TWI_MMR_DADR_OFFSET   |
80005a48:	e0 69 11 00 	mov	r9,4352
80005a4c:	ea 19 00 51 	orh	r9,0x51
80005a50:	91 19       	st.w	r8[0x4],r9
	PCF8563_ADDR_LGT		<< AVR32_TWI_MMR_IADRSZ_OFFSET |
	1					<< AVR32_TWI_MMR_MREAD_OFFSET;
	AVR32_TWI.iadr =  subaddress;
80005a52:	91 3c       	st.w	r8[0xc],r12

	AVR32_TWI.cr   =  AVR32_TWI_START_MASK | AVR32_TWI_STOP_MASK;
80005a54:	30 39       	mov	r9,3
80005a56:	91 09       	st.w	r8[0x0],r9

	do
	{
		TWI_Status =  AVR32_TWI.sr & 0x00000102;
80005a58:	70 8c       	ld.w	r12,r8[0x20]
80005a5a:	e2 1c 01 02 	andl	r12,0x102,COH
	}
	while (TWI_Status == 0);
80005a5e:	cf d0       	breq	80005a58 <read_a_byte+0x18>

	if (!(TWI_Status & 0x00000100))
80005a60:	18 98       	mov	r8,r12
80005a62:	e2 18 01 00 	andl	r8,0x100,COH
80005a66:	c0 51       	brne	80005a70 <read_a_byte+0x30>
	{
		*datareceived = AVR32_TWI.rhr;
80005a68:	fe 78 2c 00 	mov	r8,-54272
80005a6c:	70 c8       	ld.w	r8,r8[0x30]
80005a6e:	b6 88       	st.b	r11[0x0],r8
	}
	while ((AVR32_TWI.sr & 0x00000001) == 0x00000000); //Wait for complete.
80005a70:	fe 78 2c 00 	mov	r8,-54272
80005a74:	70 89       	ld.w	r9,r8[0x20]
80005a76:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005a7a:	cf d0       	breq	80005a74 <read_a_byte+0x34>
	return (TWI_Status);
}
80005a7c:	5e fc       	retal	r12
80005a7e:	d7 03       	nop

80005a80 <rtc_read_time>:
Calls: 
    my_writeabyte
Return:rtc_err_t
*/
rtc_err_t rtc_read_time(date_time_t * t)
{	
80005a80:	eb cd 40 e0 	pushm	r5-r7,lr
80005a84:	20 2d       	sub	sp,8
80005a86:	18 97       	mov	r7,r12
	if(NULL != rtc_mutex)
80005a88:	4c 28       	lddpc	r8,80005b90 <rtc_read_time+0x110>
80005a8a:	70 08       	ld.w	r8,r8[0x0]
80005a8c:	58 08       	cp.w	r8,0
80005a8e:	c0 31       	brne	80005a94 <rtc_read_time+0x14>
80005a90:	30 3c       	mov	r12,3
80005a92:	c7 b8       	rjmp	80005b88 <rtc_read_time+0x108>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005a94:	4b f6       	lddpc	r6,80005b90 <rtc_read_time+0x110>
80005a96:	6c 0c       	ld.w	r12,r6[0x0]
80005a98:	30 09       	mov	r9,0
80005a9a:	3f fa       	mov	r10,-1
80005a9c:	12 9b       	mov	r11,r9
80005a9e:	f0 1f 00 3e 	mcall	80005b94 <rtc_read_time+0x114>
	int RTC_Status;
	
	unsigned char time[8];
	
	/*read second*/
	res = read_a_byte(0x02, &time[0]);	
80005aa2:	1a 9b       	mov	r11,sp
80005aa4:	30 2c       	mov	r12,2
80005aa6:	f0 1f 00 3d 	mcall	80005b98 <rtc_read_time+0x118>
	t->second = ((time[0] & 0x7F) >> 4) * 10 + (time[0] & 0x0F);
80005aaa:	1b 88       	ld.ub	r8,sp[0x0]
80005aac:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
80005ab0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005ab4:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005ab8:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005abc:	ae f9       	st.b	r7[0x7],r9
	
	/*read minute*/
	res = read_a_byte(0x03, &time[1]);
80005abe:	fa cb ff ff 	sub	r11,sp,-1
80005ac2:	30 3c       	mov	r12,3
80005ac4:	f0 1f 00 35 	mcall	80005b98 <rtc_read_time+0x118>
	t->minute = ((time[1] & 0x7F) >> 4) * 10 + (time[1] & 0x0F);
80005ac8:	1b 98       	ld.ub	r8,sp[0x1]
80005aca:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
80005ace:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005ad2:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005ad6:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005ada:	ae e9       	st.b	r7[0x6],r9
	
	/*read hour*/
	res = read_a_byte(0x04, &time[2]);
80005adc:	fa cb ff fe 	sub	r11,sp,-2
80005ae0:	30 4c       	mov	r12,4
80005ae2:	f0 1f 00 2e 	mcall	80005b98 <rtc_read_time+0x118>
	t->hour = ((time[2] & 0x3F) >> 4) * 10 + (time[2] & 0x0F);
80005ae6:	1b a8       	ld.ub	r8,sp[0x2]
80005ae8:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005aec:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005af0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005af4:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005af8:	ae d9       	st.b	r7[0x5],r9
	
	/*read day*/
	res = read_a_byte(0x05, &time[3]);
80005afa:	fa cb ff fd 	sub	r11,sp,-3
80005afe:	30 5c       	mov	r12,5
80005b00:	f0 1f 00 26 	mcall	80005b98 <rtc_read_time+0x118>
	t->day = ((time[3] & 0x3F) >> 4) * 10 + (time[3] & 0x0F);
80005b04:	1b b8       	ld.ub	r8,sp[0x3]
80005b06:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005b0a:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005b0e:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005b12:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005b16:	ae b9       	st.b	r7[0x3],r9
	
	/*read week*/
	res = read_a_byte(0x06, &time[4]);
80005b18:	fa cb ff fc 	sub	r11,sp,-4
80005b1c:	30 6c       	mov	r12,6
80005b1e:	f0 1f 00 1f 	mcall	80005b98 <rtc_read_time+0x118>
	t->week = (time[4] & 0x0F);
80005b22:	1b c8       	ld.ub	r8,sp[0x4]
80005b24:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005b28:	ae c8       	st.b	r7[0x4],r8
	
	/*read month*/
	res = read_a_byte(0x07, &time[5]);
80005b2a:	fa cb ff fb 	sub	r11,sp,-5
80005b2e:	30 7c       	mov	r12,7
80005b30:	f0 1f 00 1a 	mcall	80005b98 <rtc_read_time+0x118>
	t->month = ((time[5] & 0x1F) >> 4) * 10 + (time[5] & 0x0F);
80005b34:	1b d8       	ld.ub	r8,sp[0x5]
80005b36:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80005b3a:	f2 0a 15 02 	lsl	r10,r9,0x2
80005b3e:	14 09       	add	r9,r10
80005b40:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005b44:	f0 09 00 18 	add	r8,r8,r9<<0x1
80005b48:	ae a8       	st.b	r7[0x2],r8
	
	/*read year*/
	res = read_a_byte(0x08, &time[6]);
80005b4a:	fa cb ff fa 	sub	r11,sp,-6
80005b4e:	30 8c       	mov	r12,8
80005b50:	f0 1f 00 12 	mcall	80005b98 <rtc_read_time+0x118>
80005b54:	18 95       	mov	r5,r12
	t->year = ((time[6] & 0xFF) >> 4) * 10 + (time[6] & 0x0F) + 2000;
80005b56:	1b e9       	ld.ub	r9,sp[0x6]
80005b58:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
80005b5c:	f0 c8 f8 30 	sub	r8,r8,-2000
80005b60:	a5 89       	lsr	r9,0x4
80005b62:	f2 09 10 0a 	mul	r9,r9,10
80005b66:	12 08       	add	r8,r9
80005b68:	5c 78       	castu.h	r8
80005b6a:	30 0b       	mov	r11,0
80005b6c:	f0 09 16 08 	lsr	r9,r8,0x8
80005b70:	ae 89       	st.b	r7[0x0],r9
80005b72:	ae 98       	st.b	r7[0x1],r8
	
	/*finished accessing the shared resource.Release the semaphore.*/	
	xSemaphoreGive(rtc_mutex);	
80005b74:	6c 0c       	ld.w	r12,r6[0x0]
80005b76:	16 99       	mov	r9,r11
80005b78:	16 9a       	mov	r10,r11
80005b7a:	f0 1f 00 09 	mcall	80005b9c <rtc_read_time+0x11c>
		
	if(res)
80005b7e:	58 05       	cp.w	r5,0
80005b80:	f9 bc 01 00 	movne	r12,0
80005b84:	f9 bc 00 02 	moveq	r12,2
	{
		return rtc_success;
	}

	return rtc_write_err;
}
80005b88:	2f ed       	sub	sp,-8
80005b8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005b8e:	00 00       	add	r0,r0
80005b90:	00 00       	add	r0,r0
80005b92:	11 0c       	ld.w	r12,r8++
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	91 90       	st.w	r8[0x24],r0
80005b98:	80 00       	ld.sh	r0,r0[0x0]
80005b9a:	5a 40       	cp.w	r0,-28
80005b9c:	80 00       	ld.sh	r0,r0[0x0]
80005b9e:	93 9c       	st.w	r9[0x24],r12

80005ba0 <getTime>:
Description: define now
Calls:
Return:date_time_t *
*/
date_time_t * getTime(void)
{
80005ba0:	eb cd 40 80 	pushm	r7,lr
	rtc_read_time(&date_time);
80005ba4:	48 47       	lddpc	r7,80005bb4 <getTime+0x14>
80005ba6:	0e 9c       	mov	r12,r7
80005ba8:	f0 1f 00 04 	mcall	80005bb8 <getTime+0x18>
	return &date_time;
80005bac:	0e 9c       	mov	r12,r7
80005bae:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bb2:	00 00       	add	r0,r0
80005bb4:	00 00       	add	r0,r0
80005bb6:	11 04       	ld.w	r4,r8++
80005bb8:	80 00       	ld.sh	r0,r0[0x0]
80005bba:	5a 80       	cp.w	r0,-24

80005bbc <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80005bbc:	eb cd 40 c0 	pushm	r6-r7,lr
80005bc0:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80005bc2:	f0 1f 00 1a 	mcall	80005c28 <rtc_init+0x6c>
80005bc6:	49 a8       	lddpc	r8,80005c2c <rtc_init+0x70>
80005bc8:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80005bca:	70 08       	ld.w	r8,r8[0x0]
80005bcc:	58 08       	cp.w	r8,0
80005bce:	c0 31       	brne	80005bd4 <rtc_init+0x18>
80005bd0:	30 3c       	mov	r12,3
80005bd2:	c2 78       	rjmp	80005c20 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005bd4:	49 66       	lddpc	r6,80005c2c <rtc_init+0x70>
80005bd6:	6c 0c       	ld.w	r12,r6[0x0]
80005bd8:	30 09       	mov	r9,0
80005bda:	3f fa       	mov	r10,-1
80005bdc:	12 9b       	mov	r11,r9
80005bde:	f0 1f 00 15 	mcall	80005c30 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80005be2:	30 2b       	mov	r11,2
80005be4:	49 4c       	lddpc	r12,80005c34 <rtc_init+0x78>
80005be6:	f0 1f 00 15 	mcall	80005c38 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80005bea:	e0 68 36 00 	mov	r8,13824
80005bee:	ea 18 01 6e 	orh	r8,0x16e
80005bf2:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80005bf4:	e2 78 0d 40 	mov	r8,200000
80005bf8:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80005bfa:	35 18       	mov	r8,81
80005bfc:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80005c00:	1a 9b       	mov	r11,sp
80005c02:	fe 7c 2c 00 	mov	r12,-54272
80005c06:	f0 1f 00 0e 	mcall	80005c3c <rtc_init+0x80>
80005c0a:	48 e7       	lddpc	r7,80005c40 <rtc_init+0x84>
80005c0c:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80005c0e:	6c 0c       	ld.w	r12,r6[0x0]
80005c10:	30 09       	mov	r9,0
80005c12:	12 9a       	mov	r10,r9
80005c14:	12 9b       	mov	r11,r9
80005c16:	f0 1f 00 0c 	mcall	80005c44 <rtc_init+0x88>
80005c1a:	6e 08       	ld.w	r8,r7[0x0]
80005c1c:	58 08       	cp.w	r8,0
80005c1e:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80005c20:	2f dd       	sub	sp,-12
80005c22:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c26:	00 00       	add	r0,r0
80005c28:	80 00       	ld.sh	r0,r0[0x0]
80005c2a:	94 9c       	ld.uh	r12,r10[0x2]
80005c2c:	00 00       	add	r0,r0
80005c2e:	11 0c       	ld.w	r12,r8++
80005c30:	80 00       	ld.sh	r0,r0[0x0]
80005c32:	91 90       	st.w	r8[0x24],r0
80005c34:	80 01       	ld.sh	r1,r0[0x0]
80005c36:	94 88       	ld.uh	r8,r10[0x0]
80005c38:	80 00       	ld.sh	r0,r0[0x0]
80005c3a:	a4 2c       	st.h	r2[0x4],r12
80005c3c:	80 00       	ld.sh	r0,r0[0x0]
80005c3e:	62 a8       	ld.w	r8,r1[0x28]
80005c40:	00 00       	add	r0,r0
80005c42:	11 00       	ld.w	r0,r8++
80005c44:	80 00       	ld.sh	r0,r0[0x0]
80005c46:	93 9c       	st.w	r9[0x24],r12

80005c48 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80005c48:	fe 78 10 00 	mov	r8,-61440
80005c4c:	fc 19 00 10 	movh	r9,0x10
80005c50:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80005c52:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80005c54:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80005c56:	30 39       	mov	r9,3
80005c58:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80005c5c:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80005c60:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80005c64:	fe 78 38 00 	mov	r8,-51200
80005c68:	30 49       	mov	r9,4
80005c6a:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80005c6e:	e0 69 91 0d 	mov	r9,37133
80005c72:	ea 19 00 52 	orh	r9,0x52
80005c76:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005c78:	32 09       	mov	r9,32
80005c7a:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005c7c:	30 59       	mov	r9,5
80005c7e:	91 09       	st.w	r8[0x0],r9
}
80005c80:	5e fc       	retal	r12
80005c82:	d7 03       	nop

80005c84 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80005c84:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80005c86:	30 2a       	mov	r10,2
80005c88:	e0 6b 01 c1 	mov	r11,449
80005c8c:	48 ec       	lddpc	r12,80005cc4 <tc_init+0x40>
80005c8e:	f0 1f 00 0f 	mcall	80005cc8 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80005c92:	48 fb       	lddpc	r11,80005ccc <tc_init+0x48>
80005c94:	fe 7c 38 00 	mov	r12,-51200
80005c98:	f0 1f 00 0e 	mcall	80005cd0 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80005c9c:	e0 6a 75 30 	mov	r10,30000
80005ca0:	30 1b       	mov	r11,1
80005ca2:	fe 7c 38 00 	mov	r12,-51200
80005ca6:	f0 1f 00 0c 	mcall	80005cd4 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80005caa:	48 ca       	lddpc	r10,80005cd8 <tc_init+0x54>
80005cac:	30 1b       	mov	r11,1
80005cae:	fe 7c 38 00 	mov	r12,-51200
80005cb2:	f0 1f 00 0b 	mcall	80005cdc <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80005cb6:	30 1b       	mov	r11,1
80005cb8:	fe 7c 38 00 	mov	r12,-51200
80005cbc:	f0 1f 00 09 	mcall	80005ce0 <tc_init+0x5c>
80005cc0:	d8 02       	popm	pc
80005cc2:	00 00       	add	r0,r0
80005cc4:	80 00       	ld.sh	r0,r0[0x0]
80005cc6:	5c e4       	tnbz	r4
80005cc8:	80 00       	ld.sh	r0,r0[0x0]
80005cca:	5d 08       	ror	r8
80005ccc:	80 01       	ld.sh	r1,r0[0x0]
80005cce:	94 9c       	ld.uh	r12,r10[0x2]
80005cd0:	80 00       	ld.sh	r0,r0[0x0]
80005cd2:	5f ee       	srqs	lr
80005cd4:	80 00       	ld.sh	r0,r0[0x0]
80005cd6:	60 ae       	ld.w	lr,r0[0x28]
80005cd8:	80 01       	ld.sh	r1,r0[0x0]
80005cda:	94 98       	ld.uh	r8,r10[0x2]
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	60 e2       	ld.w	r2,r0[0x38]
80005ce0:	80 00       	ld.sh	r0,r0[0x0]
80005ce2:	60 8a       	ld.w	r10,r0[0x20]

80005ce4 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80005ce4:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80005ce6:	48 68       	lddpc	r8,80005cfc <_tc_interrupt+0x18>
80005ce8:	70 09       	ld.w	r9,r8[0x0]
80005cea:	2f f9       	sub	r9,-1
80005cec:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80005cee:	30 1b       	mov	r11,1
80005cf0:	fe 7c 38 00 	mov	r12,-51200
80005cf4:	f0 1f 00 03 	mcall	80005d00 <_tc_interrupt+0x1c>
	
}
80005cf8:	d4 02       	popm	lr
80005cfa:	d6 03       	rete
80005cfc:	00 00       	add	r0,r0
80005cfe:	11 10       	ld.sh	r0,r8++
80005d00:	80 00       	ld.sh	r0,r0[0x0]
80005d02:	60 9c       	ld.w	r12,r0[0x24]

80005d04 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005d04:	c0 08       	rjmp	80005d04 <_unhandled_interrupt>
80005d06:	d7 03       	nop

80005d08 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005d08:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005d0c:	49 99       	lddpc	r9,80005d70 <INTC_register_interrupt+0x68>
80005d0e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005d12:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005d16:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005d18:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005d1c:	58 0a       	cp.w	r10,0
80005d1e:	c0 91       	brne	80005d30 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d20:	49 59       	lddpc	r9,80005d74 <INTC_register_interrupt+0x6c>
80005d22:	49 6a       	lddpc	r10,80005d78 <INTC_register_interrupt+0x70>
80005d24:	12 1a       	sub	r10,r9
80005d26:	fe 79 08 00 	mov	r9,-63488
80005d2a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d2e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005d30:	58 1a       	cp.w	r10,1
80005d32:	c0 a1       	brne	80005d46 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005d34:	49 09       	lddpc	r9,80005d74 <INTC_register_interrupt+0x6c>
80005d36:	49 2a       	lddpc	r10,80005d7c <INTC_register_interrupt+0x74>
80005d38:	12 1a       	sub	r10,r9
80005d3a:	bf aa       	sbr	r10,0x1e
80005d3c:	fe 79 08 00 	mov	r9,-63488
80005d40:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d44:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005d46:	58 2a       	cp.w	r10,2
80005d48:	c0 a1       	brne	80005d5c <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005d4a:	48 b9       	lddpc	r9,80005d74 <INTC_register_interrupt+0x6c>
80005d4c:	48 da       	lddpc	r10,80005d80 <INTC_register_interrupt+0x78>
80005d4e:	12 1a       	sub	r10,r9
80005d50:	bf ba       	sbr	r10,0x1f
80005d52:	fe 79 08 00 	mov	r9,-63488
80005d56:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d5a:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005d5c:	48 69       	lddpc	r9,80005d74 <INTC_register_interrupt+0x6c>
80005d5e:	48 aa       	lddpc	r10,80005d84 <INTC_register_interrupt+0x7c>
80005d60:	12 1a       	sub	r10,r9
80005d62:	ea 1a c0 00 	orh	r10,0xc000
80005d66:	fe 79 08 00 	mov	r9,-63488
80005d6a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005d6e:	5e fc       	retal	r12
80005d70:	80 01       	ld.sh	r1,r0[0x0]
80005d72:	94 a4       	ld.uh	r4,r10[0x4]
80005d74:	80 01       	ld.sh	r1,r0[0x0]
80005d76:	00 00       	add	r0,r0
80005d78:	80 01       	ld.sh	r1,r0[0x0]
80005d7a:	01 04       	ld.w	r4,r0++
80005d7c:	80 01       	ld.sh	r1,r0[0x0]
80005d7e:	01 12       	ld.sh	r2,r0++
80005d80:	80 01       	ld.sh	r1,r0[0x0]
80005d82:	01 20       	ld.uh	r0,r0++
80005d84:	80 01       	ld.sh	r1,r0[0x0]
80005d86:	01 2e       	ld.uh	lr,r0++

80005d88 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005d88:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005d8a:	49 18       	lddpc	r8,80005dcc <INTC_init_interrupts+0x44>
80005d8c:	e3 b8 00 01 	mtsr	0x4,r8
80005d90:	49 0e       	lddpc	lr,80005dd0 <INTC_init_interrupts+0x48>
80005d92:	30 07       	mov	r7,0
80005d94:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005d96:	49 0c       	lddpc	r12,80005dd4 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d98:	49 05       	lddpc	r5,80005dd8 <INTC_init_interrupts+0x50>
80005d9a:	10 15       	sub	r5,r8
80005d9c:	fe 76 08 00 	mov	r6,-63488
80005da0:	c1 08       	rjmp	80005dc0 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005da2:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005da4:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005da6:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005da8:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005dac:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005dae:	10 3a       	cp.w	r10,r8
80005db0:	fe 9b ff fc 	brhi	80005da8 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005db4:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005db8:	2f f7       	sub	r7,-1
80005dba:	2f 8e       	sub	lr,-8
80005dbc:	59 37       	cp.w	r7,19
80005dbe:	c0 50       	breq	80005dc8 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005dc0:	7c 08       	ld.w	r8,lr[0x0]
80005dc2:	58 08       	cp.w	r8,0
80005dc4:	ce f1       	brne	80005da2 <INTC_init_interrupts+0x1a>
80005dc6:	cf 7b       	rjmp	80005db4 <INTC_init_interrupts+0x2c>
80005dc8:	d8 22       	popm	r4-r7,pc
80005dca:	00 00       	add	r0,r0
80005dcc:	80 01       	ld.sh	r1,r0[0x0]
80005dce:	00 00       	add	r0,r0
80005dd0:	80 01       	ld.sh	r1,r0[0x0]
80005dd2:	94 a4       	ld.uh	r4,r10[0x4]
80005dd4:	80 00       	ld.sh	r0,r0[0x0]
80005dd6:	5d 04       	ror	r4
80005dd8:	80 01       	ld.sh	r1,r0[0x0]
80005dda:	01 04       	ld.w	r4,r0++

80005ddc <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005ddc:	fe 78 08 00 	mov	r8,-63488
80005de0:	e0 69 00 83 	mov	r9,131
80005de4:	f2 0c 01 0c 	sub	r12,r9,r12
80005de8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005dec:	f2 ca ff c0 	sub	r10,r9,-64
80005df0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005df4:	58 08       	cp.w	r8,0
80005df6:	c0 21       	brne	80005dfa <_get_interrupt_handler+0x1e>
80005df8:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005dfa:	f0 08 12 00 	clz	r8,r8
80005dfe:	48 5a       	lddpc	r10,80005e10 <_get_interrupt_handler+0x34>
80005e00:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005e04:	f0 08 11 1f 	rsub	r8,r8,31
80005e08:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005e0a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005e0e:	5e fc       	retal	r12
80005e10:	80 01       	ld.sh	r1,r0[0x0]
80005e12:	94 a4       	ld.uh	r4,r10[0x4]

80005e14 <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
80005e14:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005e18:	30 18       	mov	r8,1
80005e1a:	f0 09 18 00 	cp.b	r9,r8
80005e1e:	e0 88 00 04 	brls	80005e26 <spi_initMaster+0x12>
80005e22:	30 2c       	mov	r12,2
80005e24:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005e26:	e0 68 00 80 	mov	r8,128
80005e2a:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80005e2c:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80005e2e:	30 19       	mov	r9,1
80005e30:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005e34:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005e38:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80005e3c:	30 09       	mov	r9,0
80005e3e:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005e42:	30 fa       	mov	r10,15
80005e44:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80005e48:	99 18       	st.w	r12[0x4],r8
80005e4a:	5e f9       	retal	r9

80005e4c <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80005e4c:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80005e4e:	30 18       	mov	r8,1
80005e50:	f0 0b 18 00 	cp.b	r11,r8
80005e54:	5f be       	srhi	lr
80005e56:	f0 0a 18 00 	cp.b	r10,r8
80005e5a:	5f b8       	srhi	r8
80005e5c:	fd e8 10 08 	or	r8,lr,r8
80005e60:	c0 30       	breq	80005e66 <spi_selectionMode+0x1a>
80005e62:	30 2c       	mov	r12,2
80005e64:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
80005e66:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
80005e68:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005e6c:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80005e70:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80005e74:	99 18       	st.w	r12[0x4],r8
80005e76:	d8 0a       	popm	pc,r12=0

80005e78 <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005e78:	78 18       	ld.w	r8,r12[0x4]
80005e7a:	ea 18 00 0f 	orh	r8,0xf
80005e7e:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005e80:	78 18       	ld.w	r8,r12[0x4]
80005e82:	e2 18 00 04 	andl	r8,0x4,COH
80005e86:	c0 f0       	breq	80005ea4 <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80005e88:	30 e8       	mov	r8,14
80005e8a:	f0 0b 18 00 	cp.b	r11,r8
80005e8e:	e0 8b 00 19 	brhi	80005ec0 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80005e92:	78 18       	ld.w	r8,r12[0x4]
80005e94:	b1 6b       	lsl	r11,0x10
80005e96:	ea 1b ff f0 	orh	r11,0xfff0
80005e9a:	e8 1b ff ff 	orl	r11,0xffff
80005e9e:	10 6b       	and	r11,r8
80005ea0:	99 1b       	st.w	r12[0x4],r11
80005ea2:	5e fd       	retal	0
  } else {
    if (chip > 3) {
80005ea4:	30 38       	mov	r8,3
80005ea6:	f0 0b 18 00 	cp.b	r11,r8
80005eaa:	e0 8b 00 0b 	brhi	80005ec0 <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005eae:	78 18       	ld.w	r8,r12[0x4]
80005eb0:	2f 0b       	sub	r11,-16
80005eb2:	30 19       	mov	r9,1
80005eb4:	f2 0b 09 4b 	lsl	r11,r9,r11
80005eb8:	5c db       	com	r11
80005eba:	10 6b       	and	r11,r8
80005ebc:	99 1b       	st.w	r12[0x4],r11
80005ebe:	5e fd       	retal	0
80005ec0:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
80005ec2:	5e fc       	retal	r12

80005ec4 <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80005ec4:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005ec8:	c0 58       	rjmp	80005ed2 <spi_unselectChip+0xe>
    if (!timeout--) {
80005eca:	58 08       	cp.w	r8,0
80005ecc:	c0 21       	brne	80005ed0 <spi_unselectChip+0xc>
80005ece:	5e ff       	retal	1
80005ed0:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005ed2:	78 49       	ld.w	r9,r12[0x10]
80005ed4:	e2 19 02 00 	andl	r9,0x200,COH
80005ed8:	cf 90       	breq	80005eca <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005eda:	78 18       	ld.w	r8,r12[0x4]
80005edc:	ea 18 00 0f 	orh	r8,0xf
80005ee0:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005ee2:	fc 18 01 00 	movh	r8,0x100
80005ee6:	99 08       	st.w	r12[0x0],r8
80005ee8:	5e fd       	retal	0

80005eea <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80005eea:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005eee:	f7 38 00 0c 	ld.ub	r8,r11[12]
80005ef2:	30 39       	mov	r9,3
80005ef4:	f2 08 18 00 	cp.b	r8,r9
80005ef8:	e0 8b 00 57 	brhi	80005fa6 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005efc:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005f00:	30 1e       	mov	lr,1
80005f02:	fc 09 18 00 	cp.b	r9,lr
80005f06:	e0 8b 00 50 	brhi	80005fa6 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80005f0a:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005f0e:	30 77       	mov	r7,7
80005f10:	ee 0e 18 00 	cp.b	lr,r7
80005f14:	e0 88 00 49 	brls	80005fa6 <spi_setupChipReg+0xbc>
80005f18:	31 07       	mov	r7,16
80005f1a:	ee 0e 18 00 	cp.b	lr,r7
80005f1e:	e0 8b 00 44 	brhi	80005fa6 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005f22:	76 17       	ld.w	r7,r11[0x4]
80005f24:	ee 06 16 01 	lsr	r6,r7,0x1
80005f28:	0c 0a       	add	r10,r6
80005f2a:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005f2e:	ec c7 00 01 	sub	r7,r6,1
80005f32:	e0 47 00 fe 	cp.w	r7,254
80005f36:	e0 8b 00 38 	brhi	80005fa6 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005f3a:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80005f3c:	58 06       	cp.w	r6,0
80005f3e:	c3 45       	brlt	80005fa6 <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80005f40:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80005f42:	f0 06 16 01 	lsr	r6,r8,0x1
80005f46:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80005f4a:	ec 18 00 01 	eorl	r8,0x1
80005f4e:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80005f52:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
80005f56:	20 8e       	sub	lr,8
80005f58:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80005f5c:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80005f60:	f7 38 00 09 	ld.ub	r8,r11[9]
80005f64:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005f68:	f7 38 00 0a 	ld.ub	r8,r11[10]
80005f6c:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80005f70:	17 88       	ld.ub	r8,r11[0x0]
80005f72:	30 19       	mov	r9,1
80005f74:	f2 08 18 00 	cp.b	r8,r9
80005f78:	c0 e0       	breq	80005f94 <spi_setupChipReg+0xaa>
80005f7a:	c0 a3       	brcs	80005f8e <spi_setupChipReg+0xa4>
80005f7c:	30 29       	mov	r9,2
80005f7e:	f2 08 18 00 	cp.b	r8,r9
80005f82:	c0 c0       	breq	80005f9a <spi_setupChipReg+0xb0>
80005f84:	30 39       	mov	r9,3
80005f86:	f2 08 18 00 	cp.b	r8,r9
80005f8a:	c0 e1       	brne	80005fa6 <spi_setupChipReg+0xbc>
80005f8c:	c0 a8       	rjmp	80005fa0 <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80005f8e:	99 ca       	st.w	r12[0x30],r10
80005f90:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80005f94:	99 da       	st.w	r12[0x34],r10
80005f96:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80005f9a:	99 ea       	st.w	r12[0x38],r10
80005f9c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80005fa0:	99 fa       	st.w	r12[0x3c],r10
80005fa2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
80005fa6:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
80005fa8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005fac <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005fac:	30 18       	mov	r8,1
80005fae:	99 08       	st.w	r12[0x0],r8
}
80005fb0:	5e fc       	retal	r12

80005fb2 <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80005fb2:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005fb6:	c0 58       	rjmp	80005fc0 <spi_write+0xe>
    if (!timeout--) {
80005fb8:	58 08       	cp.w	r8,0
80005fba:	c0 21       	brne	80005fbe <spi_write+0xc>
80005fbc:	5e ff       	retal	1
80005fbe:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005fc0:	78 49       	ld.w	r9,r12[0x10]
80005fc2:	e2 19 00 02 	andl	r9,0x2,COH
80005fc6:	cf 90       	breq	80005fb8 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005fc8:	5c 7b       	castu.h	r11
80005fca:	99 3b       	st.w	r12[0xc],r11
80005fcc:	5e fd       	retal	0

80005fce <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80005fce:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005fd2:	c0 58       	rjmp	80005fdc <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80005fd4:	58 08       	cp.w	r8,0
80005fd6:	c0 21       	brne	80005fda <spi_read+0xc>
80005fd8:	5e ff       	retal	1
80005fda:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005fdc:	78 49       	ld.w	r9,r12[0x10]
80005fde:	e2 19 02 01 	andl	r9,0x201,COH
80005fe2:	e0 49 02 01 	cp.w	r9,513
80005fe6:	cf 71       	brne	80005fd4 <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005fe8:	78 28       	ld.w	r8,r12[0x8]
80005fea:	b6 08       	st.h	r11[0x0],r8
80005fec:	5e fd       	retal	0

80005fee <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005fee:	76 09       	ld.w	r9,r11[0x0]
80005ff0:	58 29       	cp.w	r9,2
80005ff2:	e0 88 00 03 	brls	80005ff8 <tc_init_waveform+0xa>
80005ff6:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005ff8:	76 18       	ld.w	r8,r11[0x4]
80005ffa:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005ffe:	af ba       	sbr	r10,0xf
80006000:	10 9b       	mov	r11,r8
80006002:	e6 1b c0 00 	andh	r11,0xc000,COH
80006006:	16 4a       	or	r10,r11
80006008:	10 9b       	mov	r11,r8
8000600a:	e6 1b 30 00 	andh	r11,0x3000,COH
8000600e:	16 4a       	or	r10,r11
80006010:	10 9b       	mov	r11,r8
80006012:	e6 1b 0c 00 	andh	r11,0xc00,COH
80006016:	16 4a       	or	r10,r11
80006018:	10 9b       	mov	r11,r8
8000601a:	e6 1b 03 00 	andh	r11,0x300,COH
8000601e:	16 4a       	or	r10,r11
80006020:	10 9b       	mov	r11,r8
80006022:	e6 1b 00 c0 	andh	r11,0xc0,COH
80006026:	16 4a       	or	r10,r11
80006028:	10 9b       	mov	r11,r8
8000602a:	e6 1b 00 30 	andh	r11,0x30,COH
8000602e:	16 4a       	or	r10,r11
80006030:	10 9b       	mov	r11,r8
80006032:	e6 1b 00 0c 	andh	r11,0xc,COH
80006036:	16 4a       	or	r10,r11
80006038:	10 9b       	mov	r11,r8
8000603a:	e6 1b 00 03 	andh	r11,0x3,COH
8000603e:	16 4a       	or	r10,r11
80006040:	10 9b       	mov	r11,r8
80006042:	e2 1b 60 00 	andl	r11,0x6000,COH
80006046:	16 4a       	or	r10,r11
80006048:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
8000604c:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80006050:	10 9b       	mov	r11,r8
80006052:	e2 1b 0c 00 	andl	r11,0xc00,COH
80006056:	16 4a       	or	r10,r11
80006058:	10 9b       	mov	r11,r8
8000605a:	e2 1b 03 00 	andl	r11,0x300,COH
8000605e:	16 4a       	or	r10,r11
80006060:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80006064:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80006068:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
8000606c:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80006070:	10 9b       	mov	r11,r8
80006072:	e2 1b 00 30 	andl	r11,0x30,COH
80006076:	16 4a       	or	r10,r11
80006078:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
8000607c:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80006080:	a5 69       	lsl	r9,0x4
80006082:	2f f9       	sub	r9,-1
80006084:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80006088:	5e fd       	retal	0

8000608a <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000608a:	58 2b       	cp.w	r11,2
8000608c:	e0 88 00 03 	brls	80006092 <tc_start+0x8>
80006090:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80006092:	a7 6b       	lsl	r11,0x6
80006094:	16 0c       	add	r12,r11
80006096:	30 58       	mov	r8,5
80006098:	99 08       	st.w	r12[0x0],r8
8000609a:	5e fd       	retal	0

8000609c <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000609c:	58 2b       	cp.w	r11,2
8000609e:	e0 88 00 03 	brls	800060a4 <tc_read_sr+0x8>
800060a2:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
800060a4:	a7 6b       	lsl	r11,0x6
800060a6:	2e 0b       	sub	r11,-32
800060a8:	16 0c       	add	r12,r11
800060aa:	78 0c       	ld.w	r12,r12[0x0]
}
800060ac:	5e fc       	retal	r12

800060ae <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800060ae:	58 2b       	cp.w	r11,2
800060b0:	e0 88 00 03 	brls	800060b6 <tc_write_rc+0x8>
800060b4:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
800060b6:	f6 08 15 04 	lsl	r8,r11,0x4
800060ba:	2f f8       	sub	r8,-1
800060bc:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
800060c0:	e2 18 80 00 	andl	r8,0x8000,COH
800060c4:	c0 c0       	breq	800060dc <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
800060c6:	a7 6b       	lsl	r11,0x6
800060c8:	16 0c       	add	r12,r11
800060ca:	2e 4c       	sub	r12,-28
800060cc:	78 08       	ld.w	r8,r12[0x0]
800060ce:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800060d2:	e0 18 00 00 	andl	r8,0x0
800060d6:	f3 e8 10 08 	or	r8,r9,r8
800060da:	99 08       	st.w	r12[0x0],r8

  return value;
800060dc:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
800060e0:	5e fc       	retal	r12

800060e2 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
800060e2:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
800060e6:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800060ea:	58 2b       	cp.w	r11,2
800060ec:	e0 88 00 04 	brls	800060f4 <tc_configure_interrupts+0x12>
800060f0:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
800060f4:	ee 19 00 01 	eorh	r9,0x1
800060f8:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
800060fc:	74 08       	ld.w	r8,r10[0x0]
800060fe:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80006102:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80006106:	a7 6e       	lsl	lr,0x6
80006108:	fd e7 10 7e 	or	lr,lr,r7<<0x7
8000610c:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80006110:	0e 4e       	or	lr,r7
80006112:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80006116:	fd e7 10 5e 	or	lr,lr,r7<<0x5
8000611a:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
8000611e:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80006122:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80006126:	fd e7 10 3e 	or	lr,lr,r7<<0x3
8000612a:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
8000612e:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80006132:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80006136:	fd e8 10 18 	or	r8,lr,r8<<0x1
8000613a:	f6 0e 15 06 	lsl	lr,r11,0x6
8000613e:	f8 0e 00 0e 	add	lr,r12,lr
80006142:	2d ce       	sub	lr,-36
80006144:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80006146:	58 09       	cp.w	r9,0
80006148:	c0 20       	breq	8000614c <tc_configure_interrupts+0x6a>
8000614a:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
8000614c:	74 08       	ld.w	r8,r10[0x0]
8000614e:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80006152:	e0 65 00 80 	mov	r5,128
80006156:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
8000615a:	74 08       	ld.w	r8,r10[0x0]
8000615c:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80006160:	f9 b4 00 40 	moveq	r4,64
80006164:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80006168:	74 08       	ld.w	r8,r10[0x0]
8000616a:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
8000616e:	f9 b3 00 20 	moveq	r3,32
80006172:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80006176:	74 08       	ld.w	r8,r10[0x0]
80006178:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
8000617c:	f9 b2 00 10 	moveq	r2,16
80006180:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80006184:	74 08       	ld.w	r8,r10[0x0]
80006186:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
8000618a:	f9 b6 00 08 	moveq	r6,8
8000618e:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80006192:	74 08       	ld.w	r8,r10[0x0]
80006194:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80006198:	f9 b7 00 04 	moveq	r7,4
8000619c:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800061a0:	74 08       	ld.w	r8,r10[0x0]
800061a2:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800061a6:	f9 be 00 02 	moveq	lr,2
800061aa:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800061ae:	74 08       	ld.w	r8,r10[0x0]
800061b0:	ec 18 00 01 	eorl	r8,0x1
800061b4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800061b8:	eb e8 10 08 	or	r8,r5,r8
800061bc:	08 48       	or	r8,r4
800061be:	06 48       	or	r8,r3
800061c0:	04 48       	or	r8,r2
800061c2:	0c 48       	or	r8,r6
800061c4:	0e 48       	or	r8,r7
800061c6:	1c 48       	or	r8,lr
800061c8:	f6 0a 15 06 	lsl	r10,r11,0x6
800061cc:	f8 0a 00 0a 	add	r10,r12,r10
800061d0:	2d 8a       	sub	r10,-40
800061d2:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
800061d4:	a7 6b       	lsl	r11,0x6
800061d6:	2e 0b       	sub	r11,-32
800061d8:	16 0c       	add	r12,r11
800061da:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
800061dc:	58 09       	cp.w	r9,0
800061de:	c0 31       	brne	800061e4 <tc_configure_interrupts+0x102>
800061e0:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
800061e4:	d5 03       	csrf	0x10
800061e6:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
800061ea:	d7 03       	nop

800061ec <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
800061ec:	4a 78       	lddpc	r8,80006288 <twi_master_interrupt_handler+0x9c>
800061ee:	70 08       	ld.w	r8,r8[0x0]
800061f0:	70 89       	ld.w	r9,r8[0x20]
800061f2:	4a 7a       	lddpc	r10,8000628c <twi_master_interrupt_handler+0xa0>
800061f4:	74 0a       	ld.w	r10,r10[0x0]
800061f6:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
800061fa:	12 9a       	mov	r10,r9
800061fc:	e2 1a 01 00 	andl	r10,0x100,COH
80006200:	c3 91       	brne	80006272 <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80006202:	12 9a       	mov	r10,r9
80006204:	e2 1a 00 02 	andl	r10,0x2,COH
80006208:	c1 70       	breq	80006236 <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
8000620a:	4a 29       	lddpc	r9,80006290 <twi_master_interrupt_handler+0xa4>
8000620c:	72 0a       	ld.w	r10,r9[0x0]
8000620e:	70 cb       	ld.w	r11,r8[0x30]
80006210:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80006212:	72 0a       	ld.w	r10,r9[0x0]
80006214:	2f fa       	sub	r10,-1
80006216:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80006218:	49 f9       	lddpc	r9,80006294 <twi_master_interrupt_handler+0xa8>
8000621a:	72 0a       	ld.w	r10,r9[0x0]
8000621c:	20 1a       	sub	r10,1
8000621e:	93 0a       	st.w	r9[0x0],r10
80006220:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80006222:	58 19       	cp.w	r9,1
80006224:	f9 b9 00 02 	moveq	r9,2
80006228:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
8000622c:	49 a9       	lddpc	r9,80006294 <twi_master_interrupt_handler+0xa8>
8000622e:	72 09       	ld.w	r9,r9[0x0]
80006230:	58 09       	cp.w	r9,0
80006232:	c2 30       	breq	80006278 <twi_master_interrupt_handler+0x8c>
80006234:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80006236:	12 9a       	mov	r10,r9
80006238:	e2 1a 00 04 	andl	r10,0x4,COH
8000623c:	c1 70       	breq	8000626a <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
8000623e:	49 79       	lddpc	r9,80006298 <twi_master_interrupt_handler+0xac>
80006240:	72 0a       	ld.w	r10,r9[0x0]
80006242:	20 1a       	sub	r10,1
80006244:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80006246:	72 09       	ld.w	r9,r9[0x0]
80006248:	58 09       	cp.w	r9,0
8000624a:	e0 89 00 0a 	brgt	8000625e <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
8000624e:	49 09       	lddpc	r9,8000628c <twi_master_interrupt_handler+0xa0>
80006250:	30 1a       	mov	r10,1
80006252:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80006254:	3f fa       	mov	r10,-1
80006256:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80006258:	72 09       	ld.w	r9,r9[0x0]
8000625a:	91 99       	st.w	r8[0x24],r9
8000625c:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
8000625e:	49 0a       	lddpc	r10,8000629c <twi_master_interrupt_handler+0xb0>
80006260:	74 09       	ld.w	r9,r10[0x0]
80006262:	13 3b       	ld.ub	r11,r9++
80006264:	91 db       	st.w	r8[0x34],r11
80006266:	95 09       	st.w	r10[0x0],r9
80006268:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
8000626a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000626e:	c0 51       	brne	80006278 <twi_master_interrupt_handler+0x8c>
80006270:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80006272:	30 1a       	mov	r10,1
80006274:	48 b9       	lddpc	r9,800062a0 <twi_master_interrupt_handler+0xb4>
80006276:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80006278:	3f f9       	mov	r9,-1
8000627a:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
8000627c:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
8000627e:	30 09       	mov	r9,0
80006280:	48 98       	lddpc	r8,800062a4 <twi_master_interrupt_handler+0xb8>
80006282:	b0 89       	st.b	r8[0x0],r9
80006284:	d6 03       	rete
80006286:	00 00       	add	r0,r0
80006288:	00 00       	add	r0,r0
8000628a:	11 c8       	ld.ub	r8,r8[0x4]
8000628c:	00 00       	add	r0,r0
8000628e:	11 c4       	ld.ub	r4,r8[0x4]
80006290:	00 00       	add	r0,r0
80006292:	11 d4       	ld.ub	r4,r8[0x5]
80006294:	00 00       	add	r0,r0
80006296:	11 d0       	ld.ub	r0,r8[0x5]
80006298:	00 00       	add	r0,r0
8000629a:	11 c0       	ld.ub	r0,r8[0x4]
8000629c:	00 00       	add	r0,r0
8000629e:	11 cc       	ld.ub	r12,r8[0x4]
800062a0:	00 00       	add	r0,r0
800062a2:	11 bd       	ld.ub	sp,r8[0x3]
800062a4:	00 00       	add	r0,r0
800062a6:	11 bc       	ld.ub	r12,r8[0x3]

800062a8 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
800062a8:	eb cd 40 e0 	pushm	r5-r7,lr
800062ac:	18 97       	mov	r7,r12
800062ae:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
800062b0:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
800062b4:	49 f9       	lddpc	r9,80006330 <twi_master_init+0x88>
800062b6:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
800062b8:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
800062ba:	3f f9       	mov	r9,-1
800062bc:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
800062be:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
800062c0:	e0 69 00 80 	mov	r9,128
800062c4:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800062c6:	e6 18 00 01 	andh	r8,0x1,COH
800062ca:	c0 21       	brne	800062ce <twi_master_init+0x26>
      cpu_irq_enable();
800062cc:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
800062ce:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800062d0:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
800062d4:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
800062d6:	30 3a       	mov	r10,3
800062d8:	e0 6b 01 60 	mov	r11,352
800062dc:	49 6c       	lddpc	r12,80006334 <twi_master_init+0x8c>
800062de:	f0 1f 00 17 	mcall	80006338 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800062e2:	e6 16 00 01 	andh	r6,0x1,COH
800062e6:	c0 21       	brne	800062ea <twi_master_init+0x42>
      cpu_irq_enable();
800062e8:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
800062ea:	6a 19       	ld.w	r9,r5[0x4]
800062ec:	a1 79       	lsl	r9,0x1
800062ee:	6a 08       	ld.w	r8,r5[0x0]
800062f0:	f0 09 0d 08 	divu	r8,r8,r9
800062f4:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
800062f6:	e0 48 00 ff 	cp.w	r8,255
800062fa:	e0 8b 00 04 	brhi	80006302 <twi_master_init+0x5a>
800062fe:	30 09       	mov	r9,0
80006300:	c0 f8       	rjmp	8000631e <twi_master_init+0x76>
80006302:	30 09       	mov	r9,0
80006304:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80006306:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80006308:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
8000630a:	e0 48 00 ff 	cp.w	r8,255
8000630e:	5f bb       	srhi	r11
80006310:	58 69       	cp.w	r9,6
80006312:	5f 8a       	srls	r10
80006314:	f7 ea 00 0a 	and	r10,r11,r10
80006318:	f8 0a 18 00 	cp.b	r10,r12
8000631c:	cf 51       	brne	80006306 <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
8000631e:	b1 69       	lsl	r9,0x10
80006320:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80006324:	f3 e8 10 08 	or	r8,r9,r8
80006328:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
8000632a:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000632e:	00 00       	add	r0,r0
80006330:	00 00       	add	r0,r0
80006332:	11 c8       	ld.ub	r8,r8[0x4]
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	61 ec       	ld.w	r12,r0[0x78]
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	5d 08       	ror	r8

8000633c <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000633c:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000633e:	f6 08 15 04 	lsl	r8,r11,0x4
80006342:	14 38       	cp.w	r8,r10
80006344:	f9 b8 08 10 	movls	r8,16
80006348:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000634c:	f0 0b 02 4b 	mul	r11,r8,r11
80006350:	f6 09 16 01 	lsr	r9,r11,0x1
80006354:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80006358:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000635c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80006360:	f2 cb 00 01 	sub	r11,r9,1
80006364:	e0 4b ff fe 	cp.w	r11,65534
80006368:	e0 88 00 03 	brls	8000636e <usart_set_async_baudrate+0x32>
8000636c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000636e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80006370:	e8 6e 00 00 	mov	lr,524288
80006374:	59 08       	cp.w	r8,16
80006376:	fc 08 17 10 	movne	r8,lr
8000637a:	f9 b8 00 00 	moveq	r8,0
8000637e:	e4 1b ff f7 	andh	r11,0xfff7
80006382:	e0 1b fe cf 	andl	r11,0xfecf
80006386:	16 48       	or	r8,r11
80006388:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000638a:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
8000638e:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80006392:	99 89       	st.w	r12[0x20],r9
80006394:	d8 0a       	popm	pc,r12=0

80006396 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006396:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006398:	e2 18 00 02 	andl	r8,0x2,COH
8000639c:	c0 31       	brne	800063a2 <usart_write_char+0xc>
8000639e:	30 2c       	mov	r12,2
800063a0:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800063a2:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800063a6:	99 7b       	st.w	r12[0x1c],r11
800063a8:	5e fd       	retal	0
800063aa:	d7 03       	nop

800063ac <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800063ac:	eb cd 40 e0 	pushm	r5-r7,lr
800063b0:	18 96       	mov	r6,r12
800063b2:	16 95       	mov	r5,r11
800063b4:	e0 67 27 0f 	mov	r7,9999
800063b8:	c0 68       	rjmp	800063c4 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800063ba:	58 07       	cp.w	r7,0
800063bc:	c0 31       	brne	800063c2 <usart_putchar+0x16>
800063be:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800063c2:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800063c4:	0a 9b       	mov	r11,r5
800063c6:	0c 9c       	mov	r12,r6
800063c8:	f0 1f 00 03 	mcall	800063d4 <usart_putchar+0x28>
800063cc:	cf 71       	brne	800063ba <usart_putchar+0xe>

  return USART_SUCCESS;
}
800063ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800063d2:	00 00       	add	r0,r0
800063d4:	80 00       	ld.sh	r0,r0[0x0]
800063d6:	63 96       	ld.w	r6,r1[0x64]

800063d8 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
800063d8:	78 58       	ld.w	r8,r12[0x14]
800063da:	e2 18 00 e0 	andl	r8,0xe0,COH
800063de:	c0 30       	breq	800063e4 <usart_read_char+0xc>
800063e0:	30 4c       	mov	r12,4
800063e2:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
800063e4:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
800063e6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800063ea:	c0 31       	brne	800063f0 <usart_read_char+0x18>
800063ec:	30 3c       	mov	r12,3
800063ee:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800063f0:	78 68       	ld.w	r8,r12[0x18]
800063f2:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800063f6:	97 08       	st.w	r11[0x0],r8
800063f8:	5e fd       	retal	0
800063fa:	d7 03       	nop

800063fc <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800063fc:	eb cd 40 c0 	pushm	r6-r7,lr
80006400:	20 1d       	sub	sp,4
80006402:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006404:	1a 97       	mov	r7,sp
80006406:	1a 9b       	mov	r11,sp
80006408:	0c 9c       	mov	r12,r6
8000640a:	f0 1f 00 07 	mcall	80006424 <usart_getchar+0x28>
8000640e:	58 3c       	cp.w	r12,3
80006410:	cf b0       	breq	80006406 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80006412:	58 4c       	cp.w	r12,4
80006414:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006418:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
8000641c:	2f fd       	sub	sp,-4
8000641e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006422:	00 00       	add	r0,r0
80006424:	80 00       	ld.sh	r0,r0[0x0]
80006426:	63 d8       	ld.w	r8,r1[0x74]

80006428 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006428:	eb cd 40 c0 	pushm	r6-r7,lr
8000642c:	18 96       	mov	r6,r12
8000642e:	16 97       	mov	r7,r11
  while (*string != '\0')
80006430:	17 8b       	ld.ub	r11,r11[0x0]
80006432:	58 0b       	cp.w	r11,0
80006434:	c0 80       	breq	80006444 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80006436:	2f f7       	sub	r7,-1
80006438:	0c 9c       	mov	r12,r6
8000643a:	f0 1f 00 04 	mcall	80006448 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000643e:	0f 8b       	ld.ub	r11,r7[0x0]
80006440:	58 0b       	cp.w	r11,0
80006442:	cf a1       	brne	80006436 <usart_write_line+0xe>
80006444:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006448:	80 00       	ld.sh	r0,r0[0x0]
8000644a:	63 ac       	ld.w	r12,r1[0x68]

8000644c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000644c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80006450:	e6 18 00 01 	andh	r8,0x1,COH
80006454:	c0 71       	brne	80006462 <usart_reset+0x16>
80006456:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80006458:	3f f8       	mov	r8,-1
8000645a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000645c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000645e:	d5 03       	csrf	0x10
80006460:	c0 48       	rjmp	80006468 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80006462:	3f f8       	mov	r8,-1
80006464:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80006466:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80006468:	30 08       	mov	r8,0
8000646a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
8000646c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000646e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80006470:	ea 68 61 0c 	mov	r8,680204
80006474:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80006476:	5e fc       	retal	r12

80006478 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80006478:	eb cd 40 e0 	pushm	r5-r7,lr
8000647c:	18 96       	mov	r6,r12
8000647e:	16 97       	mov	r7,r11
80006480:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80006482:	f0 1f 00 2f 	mcall	8000653c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80006486:	58 07       	cp.w	r7,0
80006488:	c5 80       	breq	80006538 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
8000648a:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000648c:	30 49       	mov	r9,4
8000648e:	f2 08 18 00 	cp.b	r8,r9
80006492:	e0 88 00 53 	brls	80006538 <usart_init_rs232+0xc0>
80006496:	30 99       	mov	r9,9
80006498:	f2 08 18 00 	cp.b	r8,r9
8000649c:	e0 8b 00 4e 	brhi	80006538 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800064a0:	0f d9       	ld.ub	r9,r7[0x5]
800064a2:	30 78       	mov	r8,7
800064a4:	f0 09 18 00 	cp.b	r9,r8
800064a8:	e0 8b 00 48 	brhi	80006538 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800064ac:	8e 39       	ld.sh	r9,r7[0x6]
800064ae:	e0 68 01 01 	mov	r8,257
800064b2:	f0 09 19 00 	cp.h	r9,r8
800064b6:	e0 8b 00 41 	brhi	80006538 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800064ba:	ef 39 00 08 	ld.ub	r9,r7[8]
800064be:	30 38       	mov	r8,3
800064c0:	f0 09 18 00 	cp.b	r9,r8
800064c4:	e0 8b 00 3a 	brhi	80006538 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800064c8:	0a 9a       	mov	r10,r5
800064ca:	6e 0b       	ld.w	r11,r7[0x0]
800064cc:	0c 9c       	mov	r12,r6
800064ce:	f0 1f 00 1d 	mcall	80006540 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800064d2:	58 1c       	cp.w	r12,1
800064d4:	c3 20       	breq	80006538 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
800064d6:	0f c8       	ld.ub	r8,r7[0x4]
800064d8:	30 99       	mov	r9,9
800064da:	f2 08 18 00 	cp.b	r8,r9
800064de:	c0 51       	brne	800064e8 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
800064e0:	6c 18       	ld.w	r8,r6[0x4]
800064e2:	b1 b8       	sbr	r8,0x11
800064e4:	8d 18       	st.w	r6[0x4],r8
800064e6:	c0 68       	rjmp	800064f2 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
800064e8:	6c 19       	ld.w	r9,r6[0x4]
800064ea:	20 58       	sub	r8,5
800064ec:	f3 e8 10 68 	or	r8,r9,r8<<0x6
800064f0:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
800064f2:	6c 19       	ld.w	r9,r6[0x4]
800064f4:	ef 3a 00 08 	ld.ub	r10,r7[8]
800064f8:	0f d8       	ld.ub	r8,r7[0x5]
800064fa:	a9 78       	lsl	r8,0x9
800064fc:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80006500:	12 48       	or	r8,r9
80006502:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006504:	8e 38       	ld.sh	r8,r7[0x6]
80006506:	30 29       	mov	r9,2
80006508:	f2 08 19 00 	cp.h	r8,r9
8000650c:	e0 88 00 09 	brls	8000651e <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80006510:	6c 18       	ld.w	r8,r6[0x4]
80006512:	ad b8       	sbr	r8,0xd
80006514:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006516:	8e b8       	ld.uh	r8,r7[0x6]
80006518:	20 28       	sub	r8,2
8000651a:	8d a8       	st.w	r6[0x28],r8
8000651c:	c0 68       	rjmp	80006528 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000651e:	6c 19       	ld.w	r9,r6[0x4]
80006520:	5c 78       	castu.h	r8
80006522:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006526:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006528:	6c 18       	ld.w	r8,r6[0x4]
8000652a:	e0 18 ff f0 	andl	r8,0xfff0
8000652e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80006530:	35 08       	mov	r8,80
80006532:	8d 08       	st.w	r6[0x0],r8
80006534:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80006538:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	64 4c       	ld.w	r12,r2[0x10]
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	63 3c       	ld.w	r12,r1[0x4c]

80006544 <disk_status>:


	return RES_OK;

	
}
80006544:	5e fd       	retal	0

80006546 <disk_initialize>:
	//}
	//return STA_NOINIT;

	return stat;
	
}
80006546:	5e fd       	retal	0

80006548 <get_fattime>:
	
}
#endif

DWORD get_fattime(void)
{
80006548:	d4 01       	pushm	lr
	DWORD current_time = 0;
	date_time_t *t = now();
8000654a:	f0 1f 00 0e 	mcall	80006580 <get_fattime+0x38>

	current_time = (t->year - 1980) << 25;
8000654e:	19 89       	ld.ub	r9,r12[0x0]
80006550:	19 98       	ld.ub	r8,r12[0x1]
80006552:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006556:	f0 c8 07 bc 	sub	r8,r8,1980
8000655a:	b9 78       	lsl	r8,0x19
	current_time += t->month << 21;
8000655c:	19 aa       	ld.ub	r10,r12[0x2]
8000655e:	b5 7a       	lsl	r10,0x15
80006560:	19 b9       	ld.ub	r9,r12[0x3]
80006562:	b1 69       	lsl	r9,0x10
80006564:	12 0a       	add	r10,r9
	current_time += t->day << 16;
80006566:	19 f9       	ld.ub	r9,r12[0x7]
80006568:	a1 99       	lsr	r9,0x1
8000656a:	12 0a       	add	r10,r9
	current_time += t->hour << 11;
8000656c:	19 d9       	ld.ub	r9,r12[0x5]
8000656e:	ab 79       	lsl	r9,0xb
80006570:	12 0a       	add	r10,r9
	current_time += t->minute << 5;
80006572:	19 e9       	ld.ub	r9,r12[0x6]
80006574:	a5 79       	lsl	r9,0x5
80006576:	f4 09 00 0c 	add	r12,r10,r9
	current_time += t->second / 2;
	
	return current_time;
8000657a:	10 0c       	add	r12,r8
8000657c:	d8 02       	popm	pc
8000657e:	00 00       	add	r0,r0
80006580:	80 00       	ld.sh	r0,r0[0x0]
80006582:	5b a0       	cp.w	r0,-6

80006584 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
80006584:	eb cd 40 80 	pushm	r7,lr
80006588:	14 97       	mov	r7,r10
	
	DRESULT res = RES_OK ;
	
	switch (cmd)
8000658a:	30 18       	mov	r8,1
8000658c:	f0 0b 18 00 	cp.b	r11,r8
80006590:	c1 a0       	breq	800065c4 <disk_ioctl+0x40>
80006592:	58 0b       	cp.w	r11,0
80006594:	c0 c0       	breq	800065ac <disk_ioctl+0x28>
80006596:	30 28       	mov	r8,2
80006598:	f0 0b 18 00 	cp.b	r11,r8
8000659c:	c0 a0       	breq	800065b0 <disk_ioctl+0x2c>
8000659e:	30 38       	mov	r8,3
800065a0:	f0 0b 18 00 	cp.b	r11,r8
800065a4:	c0 b0       	breq	800065ba <disk_ioctl+0x36>
800065a6:	30 4c       	mov	r12,4
800065a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800065ac:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	  
			break;
	  
		case GET_SECTOR_SIZE:
		
			*(WORD*)buff = 512;
800065b0:	e0 68 02 00 	mov	r8,512
800065b4:	b4 08       	st.h	r10[0x0],r8
800065b6:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;	
		
		case GET_BLOCK_SIZE:
		
			*(WORD*)buff = 512;
800065ba:	e0 68 02 00 	mov	r8,512
800065be:	b4 08       	st.h	r10[0x0],r8
800065c0:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;
		
		case GET_SECTOR_COUNT:
		
			*(DWORD*)buff = SD_GetSectorCount();
800065c4:	f0 1f 00 03 	mcall	800065d0 <disk_ioctl+0x4c>
800065c8:	8f 0c       	st.w	r7[0x0],r12
800065ca:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
800065ce:	00 00       	add	r0,r0
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	35 20       	mov	r0,82

800065d4 <disk_write>:
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count			/* Number of sectors to write */
)
{
800065d4:	d4 01       	pushm	lr
800065d6:	16 9c       	mov	r12,r11
800065d8:	14 9b       	mov	r11,r10


	*******************************/

	
	 if(MAL_WriteDisk(buff, sector, BLOCK_BYTE_SIZE, count)==WRITE_DATA_SUCCESS)
800065da:	5c 59       	castu.b	r9
800065dc:	e0 6a 02 00 	mov	r10,512
800065e0:	f0 1f 00 03 	mcall	800065ec <disk_write+0x18>
800065e4:	58 4c       	cp.w	r12,4
	 return RES_ERROR;
	



}
800065e6:	5f 1c       	srne	r12
800065e8:	d8 02       	popm	pc
800065ea:	00 00       	add	r0,r0
800065ec:	80 00       	ld.sh	r0,r0[0x0]
800065ee:	35 40       	mov	r0,84

800065f0 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
800065f0:	d4 01       	pushm	lr
800065f2:	16 9c       	mov	r12,r11
800065f4:	14 9b       	mov	r11,r10

	***********************************/

	

	if(MAL_ReadDisk(buff, sector, BLOCK_BYTE_SIZE, count)==READ_DATA_SUCCESS)
800065f6:	5c 59       	castu.b	r9
800065f8:	e0 6a 02 00 	mov	r10,512
800065fc:	f0 1f 00 03 	mcall	80006608 <disk_read+0x18>
80006600:	58 8c       	cp.w	r12,8
   		return RES_ERROR;




}
80006602:	5f 1c       	srne	r12
80006604:	d8 02       	popm	pc
80006606:	00 00       	add	r0,r0
80006608:	80 00       	ld.sh	r0,r0[0x0]
8000660a:	35 70       	mov	r0,87

8000660c <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
8000660c:	58 0a       	cp.w	r10,0
8000660e:	5e 0c       	reteq	r12
80006610:	30 08       	mov	r8,0
		*d++ = *s++;
80006612:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006616:	f8 08 0b 09 	st.b	r12[r8],r9
8000661a:	2f f8       	sub	r8,-1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
8000661c:	14 38       	cp.w	r8,r10
8000661e:	cf a1       	brne	80006612 <mem_cpy+0x6>
80006620:	5e fc       	retal	r12

80006622 <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
80006622:	58 0a       	cp.w	r10,0
80006624:	5e 0c       	reteq	r12
		*d++ = (BYTE)val;
80006626:	18 cb       	st.b	r12++,r11
80006628:	20 1a       	sub	r10,1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
8000662a:	cf e1       	brne	80006626 <mem_set+0x4>
8000662c:	5e fc       	retal	r12

8000662e <chk_chr>:
	return r;
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
8000662e:	18 98       	mov	r8,r12
	while (*str && *str != chr) str++;
80006630:	19 8c       	ld.ub	r12,r12[0x0]
80006632:	58 0c       	cp.w	r12,0
80006634:	5e 0c       	reteq	r12
80006636:	16 3c       	cp.w	r12,r11
80006638:	5e 0c       	reteq	r12
8000663a:	2f f8       	sub	r8,-1
8000663c:	11 8c       	ld.ub	r12,r8[0x0]
8000663e:	58 0c       	cp.w	r12,0
80006640:	5e 0c       	reteq	r12
80006642:	16 3c       	cp.w	r12,r11
80006644:	cf b1       	brne	8000663a <chk_chr+0xc>
	return *str;
}
80006646:	5e fc       	retal	r12

80006648 <clust2sect>:
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
80006648:	20 2b       	sub	r11,2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
8000664a:	78 58       	ld.w	r8,r12[0x14]
8000664c:	20 28       	sub	r8,2
8000664e:	10 3b       	cp.w	r11,r8
80006650:	c0 23       	brcs	80006654 <clust2sect+0xc>
80006652:	5e fd       	retal	0
	return clst * fs->csize + fs->database;
80006654:	19 a8       	ld.ub	r8,r12[0x2]
80006656:	b1 3b       	mul	r11,r8
80006658:	78 a8       	ld.w	r8,r12[0x28]
8000665a:	f6 08 00 0c 	add	r12,r11,r8
}
8000665e:	5e fc       	retal	r12

80006660 <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
80006660:	78 9a       	ld.w	r10,r12[0x24]
80006662:	2f ca       	sub	r10,-4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
80006664:	78 08       	ld.w	r8,r12[0x0]
80006666:	11 a8       	ld.ub	r8,r8[0x2]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006668:	74 0c       	ld.w	r12,r10[0x0]
		if (!ncl) return 0;		/* End of table? (error) */
8000666a:	58 0c       	cp.w	r12,0
8000666c:	c1 80       	breq	8000669c <clmt_clust+0x3c>
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
8000666e:	f6 09 16 09 	lsr	r9,r11,0x9
80006672:	f2 08 0d 08 	divu	r8,r9,r8
80006676:	10 99       	mov	r9,r8
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
80006678:	2f ca       	sub	r10,-4
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
8000667a:	18 38       	cp.w	r8,r12
8000667c:	c0 82       	brcc	8000668c <clmt_clust+0x2c>
8000667e:	c0 b8       	rjmp	80006694 <clmt_clust+0x34>
		cl -= ncl; tbl++;		/* Next fragment */
80006680:	18 19       	sub	r9,r12
/* FAT handling - Convert offset into cluster with link map table        */
/*-----------------------------------------------------------------------*/

#if _USE_FASTSEEK
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
80006682:	2f 8a       	sub	r10,-8
	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
80006684:	12 38       	cp.w	r8,r9
80006686:	e0 8b 00 07 	brhi	80006694 <clmt_clust+0x34>
8000668a:	10 9c       	mov	r12,r8


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
8000668c:	74 18       	ld.w	r8,r10[0x4]
		if (!ncl) return 0;		/* End of table? (error) */
8000668e:	58 08       	cp.w	r8,0
80006690:	cf 81       	brne	80006680 <clmt_clust+0x20>
80006692:	c0 58       	rjmp	8000669c <clmt_clust+0x3c>
		if (cl < ncl) break;	/* In this fragment? */
		cl -= ncl; tbl++;		/* Next fragment */
	}
	return cl + *tbl;	/* Return the cluster number */
80006694:	74 0c       	ld.w	r12,r10[0x0]
80006696:	f2 0c 00 0c 	add	r12,r9,r12
8000669a:	5e fc       	retal	r12
8000669c:	5e fd       	retal	0

8000669e <ld_clust>:
	const BYTE* dir	/* Pointer to the SFN entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
8000669e:	f7 39 00 1b 	ld.ub	r9,r11[27]
800066a2:	f7 38 00 1a 	ld.ub	r8,r11[26]
800066a6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (fs->fs_type == FS_FAT32)
800066aa:	19 8a       	ld.ub	r10,r12[0x0]
800066ac:	30 39       	mov	r9,3
800066ae:	f2 0a 18 00 	cp.b	r10,r9
800066b2:	c0 91       	brne	800066c4 <ld_clust+0x26>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
800066b4:	f7 3a 00 15 	ld.ub	r10,r11[21]
800066b8:	f7 39 00 14 	ld.ub	r9,r11[20]
800066bc:	f3 ea 10 89 	or	r9,r9,r10<<0x8
800066c0:	f1 e9 11 08 	or	r8,r8,r9<<0x10

	return cl;
}
800066c4:	5e f8       	retal	r8

800066c6 <st_clust>:
void st_clust (
	BYTE* dir,	/* Pointer to the SFN entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
800066c6:	f9 6b 00 1a 	st.b	r12[26],r11
800066ca:	f1 db c1 08 	bfextu	r8,r11,0x8,0x8
800066ce:	f9 68 00 1b 	st.b	r12[27],r8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
800066d2:	b1 8b       	lsr	r11,0x10
800066d4:	f9 6b 00 14 	st.b	r12[20],r11
800066d8:	a9 8b       	lsr	r11,0x8
800066da:	f9 6b 00 15 	st.b	r12[21],r11
}
800066de:	5e fc       	retal	r12

800066e0 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
800066e0:	d4 21       	pushm	r4-r7,lr
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
800066e2:	78 05       	ld.w	r5,r12[0x0]
800066e4:	58 05       	cp.w	r5,0
800066e6:	c5 50       	breq	80006790 <get_ldnumber+0xb0>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
800066e8:	0b 84       	ld.ub	r4,r5[0x0]
800066ea:	32 08       	mov	r8,32
800066ec:	f0 04 18 00 	cp.b	r4,r8
800066f0:	5f b9       	srhi	r9
800066f2:	33 a8       	mov	r8,58
800066f4:	f0 04 18 00 	cp.b	r4,r8
800066f8:	5f 18       	srne	r8
800066fa:	f3 e8 00 08 	and	r8,r9,r8
800066fe:	c0 41       	brne	80006706 <get_ldnumber+0x26>
80006700:	08 99       	mov	r9,r4
80006702:	0a 98       	mov	r8,r5
80006704:	c1 28       	rjmp	80006728 <get_ldnumber+0x48>
80006706:	0a 98       	mov	r8,r5
80006708:	32 06       	mov	r6,32
8000670a:	33 a7       	mov	r7,58
8000670c:	30 0e       	mov	lr,0
8000670e:	2f f8       	sub	r8,-1
80006710:	11 89       	ld.ub	r9,r8[0x0]
80006712:	ec 09 18 00 	cp.b	r9,r6
80006716:	5f bb       	srhi	r11
80006718:	ee 09 18 00 	cp.b	r9,r7
8000671c:	5f 1a       	srne	r10
8000671e:	f7 ea 00 0a 	and	r10,r11,r10
80006722:	fc 0a 18 00 	cp.b	r10,lr
80006726:	cf 41       	brne	8000670e <get_ldnumber+0x2e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
80006728:	33 aa       	mov	r10,58
8000672a:	f4 09 18 00 	cp.b	r9,r10
8000672e:	c0 30       	breq	80006734 <get_ldnumber+0x54>
80006730:	30 04       	mov	r4,0
80006732:	c3 08       	rjmp	80006792 <get_ldnumber+0xb2>
			tp = *path;
			i = *tp++ - '0'; 
80006734:	23 04       	sub	r4,48
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
80006736:	58 94       	cp.w	r4,9
80006738:	5f 8a       	srls	r10
8000673a:	ea c9 ff ff 	sub	r9,r5,-1
8000673e:	12 38       	cp.w	r8,r9
80006740:	5f 09       	sreq	r9
80006742:	f5 e9 00 09 	and	r9,r10,r9
80006746:	c0 60       	breq	80006752 <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
80006748:	58 04       	cp.w	r4,0
8000674a:	c2 31       	brne	80006790 <get_ldnumber+0xb0>
					vol = (int)i;
					*path = ++tt;
8000674c:	2f f8       	sub	r8,-1
8000674e:	99 08       	st.w	r12[0x0],r8
80006750:	c2 18       	rjmp	80006792 <get_ldnumber+0xb2>
				}
			}
#if _STR_VOLUME_ID
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
80006752:	2f f8       	sub	r8,-1
				do {
					sp = str[i]; tp = *path;
80006754:	49 17       	lddpc	r7,80006798 <get_ldnumber+0xb8>
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
						if (IsLower(tc)) tc -= 0x20;
80006756:	31 96       	mov	r6,25
					} while (c && (TCHAR)c == tc);
80006758:	30 0e       	mov	lr,0
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
				do {
					sp = str[i]; tp = *path;
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
8000675a:	0f 3a       	ld.ub	r10,r7++
8000675c:	0b 39       	ld.ub	r9,r5++
						if (IsLower(tc)) tc -= 0x20;
8000675e:	f2 cb 00 61 	sub	r11,r9,97
80006762:	ec 0b 18 00 	cp.b	r11,r6
80006766:	e0 8b 00 03 	brhi	8000676c <get_ldnumber+0x8c>
8000676a:	22 09       	sub	r9,32
					} while (c && (TCHAR)c == tc);
8000676c:	fc 0a 18 00 	cp.b	r10,lr
80006770:	5f 1b       	srne	r11
80006772:	f2 0a 18 00 	cp.b	r10,r9
80006776:	5f 09       	sreq	r9
80006778:	f7 e9 00 09 	and	r9,r11,r9
8000677c:	fc 09 18 00 	cp.b	r9,lr
80006780:	ce d1       	brne	8000675a <get_ldnumber+0x7a>
				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
80006782:	10 35       	cp.w	r5,r8
80006784:	5f 19       	srne	r9
80006786:	12 4b       	or	r11,r9
80006788:	c0 41       	brne	80006790 <get_ldnumber+0xb0>
					vol = (int)i;
					*path = tt;
8000678a:	99 08       	st.w	r12[0x0],r8
8000678c:	30 04       	mov	r4,0
8000678e:	c0 28       	rjmp	80006792 <get_ldnumber+0xb2>
80006790:	3f f4       	mov	r4,-1
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
80006792:	08 9c       	mov	r12,r4
80006794:	d8 22       	popm	r4-r7,pc
80006796:	00 00       	add	r0,r0
80006798:	80 01       	ld.sh	r1,r0[0x0]
8000679a:	95 68       	st.w	r10[0x18],r8

8000679c <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
8000679c:	eb cd 40 f8 	pushm	r3-r7,lr
800067a0:	18 97       	mov	r7,r12
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
800067a2:	19 c9       	ld.ub	r9,r12[0x4]
800067a4:	30 08       	mov	r8,0
800067a6:	f0 09 18 00 	cp.b	r9,r8
800067aa:	c2 60       	breq	800067f6 <sync_window+0x5a>
		wsect = fs->winsect;	/* Current sector number */
800067ac:	78 b6       	ld.w	r6,r12[0x2c]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
800067ae:	f8 c4 ff d0 	sub	r4,r12,-48
800067b2:	30 19       	mov	r9,1
800067b4:	0c 9a       	mov	r10,r6
800067b6:	08 9b       	mov	r11,r4
800067b8:	19 9c       	ld.ub	r12,r12[0x1]
800067ba:	f0 1f 00 11 	mcall	800067fc <sync_window+0x60>
800067be:	c0 30       	breq	800067c4 <sync_window+0x28>
800067c0:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
800067c4:	30 08       	mov	r8,0
800067c6:	ae c8       	st.b	r7[0x4],r8
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
800067c8:	6e 89       	ld.w	r9,r7[0x20]
800067ca:	ec 09 01 09 	sub	r9,r6,r9
800067ce:	6e 68       	ld.w	r8,r7[0x18]
800067d0:	10 39       	cp.w	r9,r8
800067d2:	c1 22       	brcc	800067f6 <sync_window+0x5a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
800067d4:	0f b5       	ld.ub	r5,r7[0x3]
800067d6:	58 15       	cp.w	r5,1
800067d8:	e0 88 00 0f 	brls	800067f6 <sync_window+0x5a>
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
800067dc:	30 13       	mov	r3,1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
800067de:	6e 68       	ld.w	r8,r7[0x18]
800067e0:	10 06       	add	r6,r8
					disk_write(fs->drv, fs->win, wsect, 1);
800067e2:	06 99       	mov	r9,r3
800067e4:	0c 9a       	mov	r10,r6
800067e6:	08 9b       	mov	r11,r4
800067e8:	0f 9c       	ld.ub	r12,r7[0x1]
800067ea:	f0 1f 00 05 	mcall	800067fc <sync_window+0x60>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
800067ee:	20 15       	sub	r5,1
800067f0:	58 15       	cp.w	r5,1
800067f2:	fe 9b ff f6 	brhi	800067de <sync_window+0x42>
800067f6:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800067fa:	00 00       	add	r0,r0
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	65 d4       	ld.w	r4,r2[0x74]

80006800 <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
80006800:	eb cd 40 e0 	pushm	r5-r7,lr
80006804:	18 96       	mov	r6,r12
	FRESULT res;


	res = sync_window(fs);
80006806:	f0 1f 00 31 	mcall	800068c8 <sync_fs+0xc8>
8000680a:	18 97       	mov	r7,r12
	if (res == FR_OK) {
8000680c:	c5 a1       	brne	800068c0 <sync_fs+0xc0>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
8000680e:	0d 89       	ld.ub	r9,r6[0x0]
80006810:	30 38       	mov	r8,3
80006812:	f0 09 18 00 	cp.b	r9,r8
80006816:	c4 e1       	brne	800068b2 <sync_fs+0xb2>
80006818:	0d d9       	ld.ub	r9,r6[0x5]
8000681a:	30 18       	mov	r8,1
8000681c:	f0 09 18 00 	cp.b	r9,r8
80006820:	c4 91       	brne	800068b2 <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
80006822:	ec c5 ff d0 	sub	r5,r6,-48
80006826:	e0 6a 02 00 	mov	r10,512
8000682a:	30 0b       	mov	r11,0
8000682c:	0a 9c       	mov	r12,r5
8000682e:	f0 1f 00 28 	mcall	800068cc <sync_fs+0xcc>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
80006832:	35 58       	mov	r8,85
80006834:	ed 68 02 2e 	st.b	r6[558],r8
80006838:	3a a8       	mov	r8,-86
8000683a:	ed 68 02 2f 	st.b	r6[559],r8
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
8000683e:	35 28       	mov	r8,82
80006840:	ed 68 00 30 	st.b	r6[48],r8
80006844:	ed 68 00 31 	st.b	r6[49],r8
80006848:	36 18       	mov	r8,97
8000684a:	ed 68 00 32 	st.b	r6[50],r8
8000684e:	34 19       	mov	r9,65
80006850:	ed 69 00 33 	st.b	r6[51],r9
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
80006854:	37 2a       	mov	r10,114
80006856:	ed 6a 02 14 	st.b	r6[532],r10
8000685a:	ed 6a 02 15 	st.b	r6[533],r10
8000685e:	ed 69 02 16 	st.b	r6[534],r9
80006862:	ed 68 02 17 	st.b	r6[535],r8
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
80006866:	6c 48       	ld.w	r8,r6[0x10]
80006868:	ed 68 02 18 	st.b	r6[536],r8
8000686c:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80006870:	ed 69 02 19 	st.b	r6[537],r9
80006874:	f0 09 16 10 	lsr	r9,r8,0x10
80006878:	ed 69 02 1a 	st.b	r6[538],r9
8000687c:	b9 88       	lsr	r8,0x18
8000687e:	ed 68 02 1b 	st.b	r6[539],r8
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
80006882:	6c 38       	ld.w	r8,r6[0xc]
80006884:	ed 68 02 1c 	st.b	r6[540],r8
80006888:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
8000688c:	ed 69 02 1d 	st.b	r6[541],r9
80006890:	f0 09 16 10 	lsr	r9,r8,0x10
80006894:	ed 69 02 1e 	st.b	r6[542],r9
80006898:	b9 88       	lsr	r8,0x18
8000689a:	ed 68 02 1f 	st.b	r6[543],r8
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
8000689e:	6c 7a       	ld.w	r10,r6[0x1c]
800068a0:	2f fa       	sub	r10,-1
800068a2:	8d ba       	st.w	r6[0x2c],r10
			disk_write(fs->drv, fs->win, fs->winsect, 1);
800068a4:	30 19       	mov	r9,1
800068a6:	0a 9b       	mov	r11,r5
800068a8:	0d 9c       	ld.ub	r12,r6[0x1]
800068aa:	f0 1f 00 0a 	mcall	800068d0 <sync_fs+0xd0>
			fs->fsi_flag = 0;
800068ae:	30 08       	mov	r8,0
800068b0:	ac d8       	st.b	r6[0x5],r8
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
800068b2:	30 0a       	mov	r10,0
800068b4:	14 9b       	mov	r11,r10
800068b6:	0d 9c       	ld.ub	r12,r6[0x1]
800068b8:	f0 1f 00 07 	mcall	800068d4 <sync_fs+0xd4>
800068bc:	f9 b7 01 01 	movne	r7,1
			res = FR_DISK_ERR;
	}

	return res;
}
800068c0:	0e 9c       	mov	r12,r7
800068c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800068c6:	00 00       	add	r0,r0
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	67 9c       	ld.w	r12,r3[0x64]
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	66 22       	ld.w	r2,r3[0x8]
800068d0:	80 00       	ld.sh	r0,r0[0x0]
800068d2:	65 d4       	ld.w	r4,r2[0x74]
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	65 84       	ld.w	r4,r2[0x60]

800068d8 <f_mkfs>:
FRESULT f_mkfs (
	const TCHAR* path,	/* Logical drive number */
	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
	UINT au				/* Size of allocation unit in unit of byte or sector */
)
{
800068d8:	d4 31       	pushm	r0-r7,lr
800068da:	20 ad       	sub	sp,40
800068dc:	50 7c       	stdsp	sp[0x1c],r12
800068de:	16 97       	mov	r7,r11
800068e0:	14 96       	mov	r6,r10
	DWORD eb[2];
#endif


	/* Check mounted drive and clear work area */
	if (sfd > 1) return FR_INVALID_PARAMETER;
800068e2:	30 18       	mov	r8,1
800068e4:	f0 0b 18 00 	cp.b	r11,r8
800068e8:	e0 88 00 05 	brls	800068f2 <f_mkfs+0x1a>
800068ec:	31 3c       	mov	r12,19
800068ee:	e0 8f 03 16 	bral	80006f1a <f_mkfs+0x642>
	vol = get_ldnumber(&path);
800068f2:	fa cc ff e4 	sub	r12,sp,-28
800068f6:	f0 1f 01 8e 	mcall	80006f2c <f_mkfs+0x654>
	if (vol < 0) return FR_INVALID_DRIVE;
800068fa:	c0 44       	brge	80006902 <f_mkfs+0x2a>
800068fc:	30 bc       	mov	r12,11
800068fe:	e0 8f 03 0e 	bral	80006f1a <f_mkfs+0x642>
	fs = FatFs[vol];
80006902:	fe f8 06 2e 	ld.w	r8,pc[1582]
80006906:	f0 0c 03 25 	ld.w	r5,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;
8000690a:	58 05       	cp.w	r5,0
8000690c:	c0 41       	brne	80006914 <f_mkfs+0x3c>
8000690e:	30 cc       	mov	r12,12
80006910:	e0 8f 03 05 	bral	80006f1a <f_mkfs+0x642>
	fs->fs_type = 0;
80006914:	30 08       	mov	r8,0
80006916:	aa 88       	st.b	r5[0x0],r8
	pdrv = LD2PD(vol);	/* Physical drive */
	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/

	/* Get disk statics */
	stat = disk_initialize(pdrv);
80006918:	e9 dc c0 08 	bfextu	r4,r12,0x0,0x8
8000691c:	08 9c       	mov	r12,r4
8000691e:	f0 1f 01 86 	mcall	80006f34 <f_mkfs+0x65c>
	if (stat & STA_NOINIT) return FR_NOT_READY;
80006922:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006926:	c0 40       	breq	8000692e <f_mkfs+0x56>
80006928:	30 3c       	mov	r12,3
8000692a:	e0 8f 02 f8 	bral	80006f1a <f_mkfs+0x642>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
8000692e:	e2 1c 00 04 	andl	r12,0x4,COH
80006932:	c0 40       	breq	8000693a <f_mkfs+0x62>
80006934:	30 ac       	mov	r12,10
80006936:	e0 8f 02 f2 	bral	80006f1a <f_mkfs+0x642>
		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
	} else {
		/* Create a partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
8000693a:	fa ca ff e0 	sub	r10,sp,-32
8000693e:	30 1b       	mov	r11,1
80006940:	08 9c       	mov	r12,r4
80006942:	f0 1f 01 7e 	mcall	80006f38 <f_mkfs+0x660>
80006946:	e0 81 02 e7 	brne	80006f14 <f_mkfs+0x63c>
8000694a:	40 89       	lddsp	r9,sp[0x20]
8000694c:	e0 49 00 7f 	cp.w	r9,127
80006950:	e0 88 02 e2 	brls	80006f14 <f_mkfs+0x63c>
			return FR_DISK_ERR;
		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
80006954:	58 07       	cp.w	r7,0
80006956:	f9 b1 01 00 	movne	r1,0
8000695a:	f9 b1 00 3f 	moveq	r1,63
		n_vol -= b_vol;				/* Volume size */
8000695e:	02 19       	sub	r9,r1
80006960:	50 89       	stdsp	sp[0x20],r9
	}

	if (au & (au - 1)) au = 0;
80006962:	ec c8 00 01 	sub	r8,r6,1
80006966:	0c 68       	and	r8,r6
80006968:	c0 31       	brne	8000696e <f_mkfs+0x96>
	if (!au) {						/* AU auto selection */
8000696a:	58 06       	cp.w	r6,0
8000696c:	c1 a1       	brne	800069a0 <f_mkfs+0xc8>
		vs = n_vol / (2000 / (SS(fs) / 512));
8000696e:	e0 6b 4d d3 	mov	r11,19923
80006972:	ea 1b 10 62 	orh	r11,0x1062
80006976:	f2 0b 06 4a 	mulu.d	r10,r9,r11
8000697a:	f6 0c 16 07 	lsr	r12,r11,0x7
		for (i = 0; vs < vst[i]; i++) ;
8000697e:	e0 4c 04 00 	cp.w	r12,1024
80006982:	c0 33       	brcs	80006988 <f_mkfs+0xb0>
80006984:	30 08       	mov	r8,0
80006986:	c0 98       	rjmp	80006998 <f_mkfs+0xc0>
80006988:	fe fa 05 b4 	ld.w	r10,pc[1460]
8000698c:	2f ea       	sub	r10,-2
8000698e:	30 08       	mov	r8,0
80006990:	2f f8       	sub	r8,-1
80006992:	15 2b       	ld.uh	r11,r10++
80006994:	16 3c       	cp.w	r12,r11
80006996:	cf d3       	brcs	80006990 <f_mkfs+0xb8>
		au = cst[i];
80006998:	fe fa 05 a8 	ld.w	r10,pc[1448]
8000699c:	f4 08 05 16 	ld.uh	r6,r10[r8<<0x1]
	}
	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
800069a0:	e0 46 01 ff 	cp.w	r6,511
800069a4:	e0 88 00 03 	brls	800069aa <f_mkfs+0xd2>
800069a8:	a9 96       	lsr	r6,0x9
	if (!au) au = 1;
800069aa:	58 06       	cp.w	r6,0
800069ac:	f9 b6 00 01 	moveq	r6,1
800069b0:	e0 60 00 80 	mov	r0,128
800069b4:	00 36       	cp.w	r6,r0
800069b6:	ec 00 17 80 	movls	r0,r6
	if (au > 128) au = 128;

	/* Pre-compute number of clusters and FAT sub-type */
	n_clst = n_vol / au;
800069ba:	f2 00 0d 0a 	divu	r10,r9,r0
800069be:	14 98       	mov	r8,r10
	fmt = FS_FAT12;
	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
800069c0:	e0 4a 0f f6 	cp.w	r10,4086
800069c4:	f9 b3 03 01 	movlo	r3,1
800069c8:	f9 b3 02 02 	movhs	r3,2
	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
800069cc:	e0 4a ff f5 	cp.w	r10,65525
800069d0:	e0 88 00 04 	brls	800069d8 <f_mkfs+0x100>
800069d4:	30 33       	mov	r3,3
800069d6:	c0 58       	rjmp	800069e0 <f_mkfs+0x108>

	/* Determine offset and size of FAT structure */
	if (fmt == FS_FAT32) {
800069d8:	30 3a       	mov	r10,3
800069da:	f4 03 18 00 	cp.b	r3,r10
800069de:	c0 a1       	brne	800069f2 <f_mkfs+0x11a>
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
800069e0:	a3 68       	lsl	r8,0x2
800069e2:	f0 c2 fd f9 	sub	r2,r8,-519
800069e6:	a9 92       	lsr	r2,0x9
800069e8:	30 0b       	mov	r11,0
800069ea:	50 2b       	stdsp	sp[0x8],r11
800069ec:	32 0a       	mov	r10,32
800069ee:	50 0a       	stdsp	sp[0x0],r10
800069f0:	c1 68       	rjmp	80006a1c <f_mkfs+0x144>
		n_rsv = 32;
		n_dir = 0;
	} else {
		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
800069f2:	30 1a       	mov	r10,1
800069f4:	f4 03 18 00 	cp.b	r3,r10
800069f8:	c0 81       	brne	80006a08 <f_mkfs+0x130>
800069fa:	f0 08 00 18 	add	r8,r8,r8<<0x1
800069fe:	f0 c2 ff ff 	sub	r2,r8,-1
80006a02:	a1 92       	lsr	r2,0x1
80006a04:	2f d2       	sub	r2,-3
80006a06:	c0 48       	rjmp	80006a0e <f_mkfs+0x136>
80006a08:	2f e8       	sub	r8,-2
80006a0a:	f0 02 15 01 	lsl	r2,r8,0x1
		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
80006a0e:	e4 c2 fe 01 	sub	r2,r2,-511
80006a12:	a9 92       	lsr	r2,0x9
80006a14:	32 08       	mov	r8,32
80006a16:	50 28       	stdsp	sp[0x8],r8
80006a18:	30 1c       	mov	r12,1
80006a1a:	50 0c       	stdsp	sp[0x0],r12
		n_rsv = 1;
		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
	}
	b_fat = b_vol + n_rsv;				/* FAT area start sector */
80006a1c:	40 0b       	lddsp	r11,sp[0x0]
80006a1e:	02 0b       	add	r11,r1
80006a20:	50 1b       	stdsp	sp[0x4],r11
	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
	b_data = b_dir + n_dir;				/* Data area start sector */
80006a22:	40 26       	lddsp	r6,sp[0x8]
80006a24:	04 06       	add	r6,r2
80006a26:	16 06       	add	r6,r11
	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
80006a28:	e0 01 01 08 	sub	r8,r0,r1
80006a2c:	0c 08       	add	r8,r6
80006a2e:	10 39       	cp.w	r9,r8
80006a30:	e0 83 02 74 	brlo	80006f18 <f_mkfs+0x640>

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
80006a34:	fa ca ff dc 	sub	r10,sp,-36
80006a38:	30 3b       	mov	r11,3
80006a3a:	08 9c       	mov	r12,r4
80006a3c:	f0 1f 01 3f 	mcall	80006f38 <f_mkfs+0x660>
80006a40:	c0 81       	brne	80006a50 <f_mkfs+0x178>
80006a42:	40 98       	lddsp	r8,sp[0x24]
80006a44:	58 08       	cp.w	r8,0
80006a46:	c0 50       	breq	80006a50 <f_mkfs+0x178>
80006a48:	e0 48 80 00 	cp.w	r8,32768
80006a4c:	e0 88 00 04 	brls	80006a54 <f_mkfs+0x17c>
80006a50:	30 18       	mov	r8,1
80006a52:	50 98       	stdsp	sp[0x24],r8
	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
80006a54:	40 98       	lddsp	r8,sp[0x24]
	n = (n - b_data) / N_FATS;
80006a56:	f0 c9 00 01 	sub	r9,r8,1
80006a5a:	0c 09       	add	r9,r6
80006a5c:	5c 38       	neg	r8
80006a5e:	f3 e8 00 08 	and	r8,r9,r8
80006a62:	f0 06 01 06 	sub	r6,r8,r6
80006a66:	50 96       	stdsp	sp[0x24],r6
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
80006a68:	30 38       	mov	r8,3
80006a6a:	f0 03 18 00 	cp.b	r3,r8
80006a6e:	c1 d1       	brne	80006aa8 <f_mkfs+0x1d0>
		n_rsv += n;
80006a70:	40 0a       	lddsp	r10,sp[0x0]
80006a72:	0c 0a       	add	r10,r6
80006a74:	50 0a       	stdsp	sp[0x0],r10
		b_fat += n;
80006a76:	40 19       	lddsp	r9,sp[0x4]
80006a78:	0c 09       	add	r9,r6
80006a7a:	50 19       	stdsp	sp[0x4],r9
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006a7c:	40 88       	lddsp	r8,sp[0x20]
80006a7e:	f0 0a 01 0b 	sub	r11,r8,r10
80006a82:	04 1b       	sub	r11,r2
80006a84:	40 2c       	lddsp	r12,sp[0x8]
80006a86:	18 1b       	sub	r11,r12
80006a88:	f6 00 0d 0a 	divu	r10,r11,r0
80006a8c:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006a8e:	30 39       	mov	r9,3
80006a90:	f2 03 18 00 	cp.b	r3,r9
80006a94:	5f 0b       	sreq	r11
80006a96:	50 3b       	stdsp	sp[0xc],r11
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006a98:	e0 4a ff f5 	cp.w	r10,65525
80006a9c:	5f 89       	srls	r9
80006a9e:	f7 e9 00 09 	and	r9,r11,r9
80006aa2:	e0 81 02 3b 	brne	80006f18 <f_mkfs+0x640>
80006aa6:	c1 a8       	rjmp	80006ada <f_mkfs+0x202>
	n = (n - b_data) / N_FATS;
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
		n_rsv += n;
		b_fat += n;
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
80006aa8:	0c 02       	add	r2,r6
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006aaa:	40 88       	lddsp	r8,sp[0x20]
80006aac:	40 0a       	lddsp	r10,sp[0x0]
80006aae:	f0 0a 01 0b 	sub	r11,r8,r10
80006ab2:	04 1b       	sub	r11,r2
80006ab4:	40 29       	lddsp	r9,sp[0x8]
80006ab6:	12 1b       	sub	r11,r9
80006ab8:	f6 00 0d 0a 	divu	r10,r11,r0
80006abc:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006abe:	30 29       	mov	r9,2
80006ac0:	f2 03 18 00 	cp.b	r3,r9
80006ac4:	5f 0a       	sreq	r10
80006ac6:	40 4c       	lddsp	r12,sp[0x10]
80006ac8:	e0 4c 0f f5 	cp.w	r12,4085
80006acc:	5f 89       	srls	r9
80006ace:	f5 e9 00 09 	and	r9,r10,r9
80006ad2:	e0 80 02 26 	breq	80006f1e <f_mkfs+0x646>
80006ad6:	e0 8f 02 21 	bral	80006f18 <f_mkfs+0x640>
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
		return FR_MKFS_ABORTED;

	/* Determine system ID in the partition table */
	if (fmt == FS_FAT32) {
80006ada:	40 3b       	lddsp	r11,sp[0xc]
80006adc:	58 0b       	cp.w	r11,0
80006ade:	c0 30       	breq	80006ae4 <f_mkfs+0x20c>
80006ae0:	30 c6       	mov	r6,12
80006ae2:	c1 28       	rjmp	80006b06 <f_mkfs+0x22e>
		sys = 0x0C;		/* FAT32X */
	} else {
		if (fmt == FS_FAT12 && n_vol < 0x10000) {
80006ae4:	30 19       	mov	r9,1
80006ae6:	f2 03 18 00 	cp.b	r3,r9
80006aea:	c0 71       	brne	80006af8 <f_mkfs+0x220>
80006aec:	e0 48 ff ff 	cp.w	r8,65535
80006af0:	e0 8b 00 0a 	brhi	80006b04 <f_mkfs+0x22c>
80006af4:	30 16       	mov	r6,1
80006af6:	c0 88       	rjmp	80006b06 <f_mkfs+0x22e>
			sys = 0x01;	/* FAT12(<65536) */
		} else {
			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
80006af8:	e0 48 ff ff 	cp.w	r8,65535
80006afc:	e0 8b 00 04 	brhi	80006b04 <f_mkfs+0x22c>
80006b00:	30 46       	mov	r6,4
80006b02:	c0 28       	rjmp	80006b06 <f_mkfs+0x22e>
80006b04:	30 66       	mov	r6,6
		tbl[4] = sys;
		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
			return FR_DISK_ERR;
		md = 0xF8;
	} else {
		if (sfd) {	/* No partition table (SFD) */
80006b06:	58 07       	cp.w	r7,0
80006b08:	c0 40       	breq	80006b10 <f_mkfs+0x238>
80006b0a:	e0 67 00 f0 	mov	r7,240
80006b0e:	c5 68       	rjmp	80006bba <f_mkfs+0x2e2>
			md = 0xF0;
		} else {	/* Create partition table (FDISK) */
			mem_set(fs->win, 0, SS(fs));
80006b10:	ea ca ff d0 	sub	r10,r5,-48
80006b14:	50 5a       	stdsp	sp[0x14],r10
80006b16:	e0 6a 02 00 	mov	r10,512
80006b1a:	30 0b       	mov	r11,0
80006b1c:	40 5c       	lddsp	r12,sp[0x14]
80006b1e:	f0 1f 01 0a 	mcall	80006f44 <f_mkfs+0x66c>
			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
80006b22:	ea c8 fe 12 	sub	r8,r5,-494
			tbl[1] = 1;						/* Partition start head */
80006b26:	30 19       	mov	r9,1
80006b28:	b0 99       	st.b	r8[0x1],r9
			tbl[2] = 1;						/* Partition start sector */
80006b2a:	b0 a9       	st.b	r8[0x2],r9
			tbl[3] = 0;						/* Partition start cylinder */
80006b2c:	30 09       	mov	r9,0
80006b2e:	b0 b9       	st.b	r8[0x3],r9
			tbl[4] = sys;					/* System type */
80006b30:	b0 c6       	st.b	r8[0x4],r6
			tbl[5] = 254;					/* Partition end head */
80006b32:	3f ea       	mov	r10,-2
80006b34:	b0 da       	st.b	r8[0x5],r10
			n = (b_vol + n_vol) / 63 / 255;
80006b36:	40 8b       	lddsp	r11,sp[0x20]
80006b38:	e2 0b 00 0b 	add	r11,r1,r11
80006b3c:	e0 6a 56 5b 	mov	r10,22107
80006b40:	ea 1a 05 15 	orh	r10,0x515
80006b44:	f6 0a 06 46 	mulu.d	r6,r11,r10
80006b48:	0e 9c       	mov	r12,r7
80006b4a:	f6 0c 01 0a 	sub	r10,r11,r12
80006b4e:	a1 9a       	lsr	r10,0x1
80006b50:	f4 0c 00 07 	add	r7,r10,r12
80006b54:	ee 0a 16 0d 	lsr	r10,r7,0xd
80006b58:	50 9a       	stdsp	sp[0x24],r10
			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
80006b5a:	ee 0b 16 0f 	lsr	r11,r7,0xf
80006b5e:	16 97       	mov	r7,r11
80006b60:	e8 17 00 3f 	orl	r7,0x3f
80006b64:	b0 e7       	st.b	r8[0x6],r7
			tbl[7] = (BYTE)n;				/* End cylinder */
80006b66:	40 9a       	lddsp	r10,sp[0x24]
80006b68:	b0 fa       	st.b	r8[0x7],r10
			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
80006b6a:	33 fa       	mov	r10,63
80006b6c:	f1 6a 00 08 	st.b	r8[8],r10
80006b70:	f1 69 00 09 	st.b	r8[9],r9
80006b74:	f1 69 00 0a 	st.b	r8[10],r9
80006b78:	f1 69 00 0b 	st.b	r8[11],r9
			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
80006b7c:	40 89       	lddsp	r9,sp[0x20]
80006b7e:	f1 69 00 0c 	st.b	r8[12],r9
80006b82:	fb 39 00 22 	ld.ub	r9,sp[34]
80006b86:	f1 69 00 0d 	st.b	r8[13],r9
80006b8a:	fb 19 00 20 	ld.uh	r9,sp[32]
80006b8e:	f1 69 00 0e 	st.b	r8[14],r9
80006b92:	fb 39 00 20 	ld.ub	r9,sp[32]
80006b96:	f1 69 00 0f 	st.b	r8[15],r9
			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
80006b9a:	35 58       	mov	r8,85
80006b9c:	eb 68 02 2e 	st.b	r5[558],r8
80006ba0:	3a a8       	mov	r8,-86
80006ba2:	eb 68 02 2f 	st.b	r5[559],r8
			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
80006ba6:	30 19       	mov	r9,1
80006ba8:	30 0a       	mov	r10,0
80006baa:	40 5b       	lddsp	r11,sp[0x14]
80006bac:	08 9c       	mov	r12,r4
80006bae:	f0 1f 00 e7 	mcall	80006f48 <f_mkfs+0x670>
80006bb2:	e0 81 01 b1 	brne	80006f14 <f_mkfs+0x63c>
80006bb6:	e0 67 00 f8 	mov	r7,248
			md = 0xF8;
		}
	}

	/* Create BPB in the VBR */
	tbl = fs->win;							/* Clear sector */
80006bba:	ea c6 ff d0 	sub	r6,r5,-48
	mem_set(tbl, 0, SS(fs));
80006bbe:	e0 6a 02 00 	mov	r10,512
80006bc2:	30 0b       	mov	r11,0
80006bc4:	0c 9c       	mov	r12,r6
80006bc6:	f0 1f 00 e0 	mcall	80006f44 <f_mkfs+0x66c>
	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
80006bca:	30 ba       	mov	r10,11
80006bcc:	fe fb 03 80 	ld.w	r11,pc[896]
80006bd0:	0c 9c       	mov	r12,r6
80006bd2:	f0 1f 00 e0 	mcall	80006f50 <f_mkfs+0x678>
	i = SS(fs);								/* Sector size */
	ST_WORD(tbl + BPB_BytsPerSec, i);
80006bd6:	ea ca ff c5 	sub	r10,r5,-59
80006bda:	50 5a       	stdsp	sp[0x14],r10
80006bdc:	30 08       	mov	r8,0
80006bde:	b4 88       	st.b	r10[0x0],r8
80006be0:	30 28       	mov	r8,2
80006be2:	ed 68 00 0c 	st.b	r6[12],r8
	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
80006be6:	ed 60 00 0d 	st.b	r6[13],r0
	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
80006bea:	40 09       	lddsp	r9,sp[0x0]
80006bec:	ed 69 00 0e 	st.b	r6[14],r9
80006bf0:	f1 d9 c1 08 	bfextu	r8,r9,0x8,0x8
80006bf4:	ed 68 00 0f 	st.b	r6[15],r8
	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
80006bf8:	30 18       	mov	r8,1
80006bfa:	ed 68 00 10 	st.b	r6[16],r8
	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
80006bfe:	e0 68 02 00 	mov	r8,512
80006c02:	40 3c       	lddsp	r12,sp[0xc]
80006c04:	58 0c       	cp.w	r12,0
80006c06:	f9 b8 01 00 	movne	r8,0
	ST_WORD(tbl + BPB_RootEntCnt, i);
80006c0a:	ed 68 00 11 	st.b	r6[17],r8
80006c0e:	58 08       	cp.w	r8,0
80006c10:	f9 b8 01 02 	movne	r8,2
80006c14:	f9 b8 00 00 	moveq	r8,0
80006c18:	ed 68 00 12 	st.b	r6[18],r8
	if (n_vol < 0x10000) {					/* Number of total sectors */
80006c1c:	40 88       	lddsp	r8,sp[0x20]
80006c1e:	e0 48 ff ff 	cp.w	r8,65535
80006c22:	e0 8b 00 09 	brhi	80006c34 <f_mkfs+0x35c>
		ST_WORD(tbl + BPB_TotSec16, n_vol);
80006c26:	ed 68 00 13 	st.b	r6[19],r8
80006c2a:	fb 38 00 22 	ld.ub	r8,sp[34]
80006c2e:	ed 68 00 14 	st.b	r6[20],r8
80006c32:	c0 f8       	rjmp	80006c50 <f_mkfs+0x378>
	} else {
		ST_DWORD(tbl + BPB_TotSec32, n_vol);
80006c34:	ed 68 00 20 	st.b	r6[32],r8
80006c38:	fb 38 00 22 	ld.ub	r8,sp[34]
80006c3c:	ed 68 00 21 	st.b	r6[33],r8
80006c40:	fb 18 00 20 	ld.uh	r8,sp[32]
80006c44:	ed 68 00 22 	st.b	r6[34],r8
80006c48:	fb 38 00 20 	ld.ub	r8,sp[32]
80006c4c:	ed 68 00 23 	st.b	r6[35],r8
	}
	tbl[BPB_Media] = md;					/* Media descriptor */
80006c50:	ed 67 00 15 	st.b	r6[21],r7
	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
80006c54:	33 f8       	mov	r8,63
80006c56:	ed 68 00 18 	st.b	r6[24],r8
80006c5a:	30 08       	mov	r8,0
80006c5c:	ed 68 00 19 	st.b	r6[25],r8
	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
80006c60:	3f f9       	mov	r9,-1
80006c62:	ed 69 00 1a 	st.b	r6[26],r9
80006c66:	ed 68 00 1b 	st.b	r6[27],r8
	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
80006c6a:	ed 61 00 1c 	st.b	r6[28],r1
80006c6e:	30 08       	mov	r8,0
80006c70:	ed 68 00 1d 	st.b	r6[29],r8
80006c74:	e2 08 16 10 	lsr	r8,r1,0x10
80006c78:	ed 68 00 1e 	st.b	r6[30],r8
80006c7c:	e2 08 16 18 	lsr	r8,r1,0x18
80006c80:	ed 68 00 1f 	st.b	r6[31],r8
	n = GET_FATTIME();						/* Use current time as VSN */
80006c84:	f0 1f 00 b4 	mcall	80006f54 <f_mkfs+0x67c>
80006c88:	50 9c       	stdsp	sp[0x24],r12
	if (fmt == FS_FAT32) {
80006c8a:	40 3a       	lddsp	r10,sp[0xc]
80006c8c:	58 0a       	cp.w	r10,0
80006c8e:	c3 f0       	breq	80006d0c <f_mkfs+0x434>
		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
80006c90:	ed 6c 00 43 	st.b	r6[67],r12
80006c94:	fb 38 00 26 	ld.ub	r8,sp[38]
80006c98:	ed 68 00 44 	st.b	r6[68],r8
80006c9c:	fb 18 00 24 	ld.uh	r8,sp[36]
80006ca0:	ed 68 00 45 	st.b	r6[69],r8
80006ca4:	fb 38 00 24 	ld.ub	r8,sp[36]
80006ca8:	ed 68 00 46 	st.b	r6[70],r8
		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
80006cac:	ed 62 00 24 	st.b	r6[36],r2
80006cb0:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80006cb4:	ed 68 00 25 	st.b	r6[37],r8
80006cb8:	e4 08 16 10 	lsr	r8,r2,0x10
80006cbc:	ed 68 00 26 	st.b	r6[38],r8
80006cc0:	e4 08 16 18 	lsr	r8,r2,0x18
80006cc4:	ed 68 00 27 	st.b	r6[39],r8
		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
80006cc8:	30 28       	mov	r8,2
80006cca:	ed 68 00 2c 	st.b	r6[44],r8
80006cce:	30 08       	mov	r8,0
80006cd0:	ed 68 00 2d 	st.b	r6[45],r8
80006cd4:	ed 68 00 2e 	st.b	r6[46],r8
80006cd8:	ed 68 00 2f 	st.b	r6[47],r8
		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
80006cdc:	30 19       	mov	r9,1
80006cde:	ed 69 00 30 	st.b	r6[48],r9
80006ce2:	ed 68 00 31 	st.b	r6[49],r8
		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
80006ce6:	30 69       	mov	r9,6
80006ce8:	ed 69 00 32 	st.b	r6[50],r9
80006cec:	ed 68 00 33 	st.b	r6[51],r8
		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
80006cf0:	38 08       	mov	r8,-128
80006cf2:	ed 68 00 40 	st.b	r6[64],r8
		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
80006cf6:	32 98       	mov	r8,41
80006cf8:	ed 68 00 42 	st.b	r6[66],r8
		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
80006cfc:	31 3a       	mov	r10,19
80006cfe:	fe fb 02 5a 	ld.w	r11,pc[602]
80006d02:	ec cc ff b9 	sub	r12,r6,-71
80006d06:	f0 1f 00 93 	mcall	80006f50 <f_mkfs+0x678>
80006d0a:	c2 28       	rjmp	80006d4e <f_mkfs+0x476>
	} else {
		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
80006d0c:	ed 6c 00 27 	st.b	r6[39],r12
80006d10:	fb 38 00 26 	ld.ub	r8,sp[38]
80006d14:	ed 68 00 28 	st.b	r6[40],r8
80006d18:	fb 18 00 24 	ld.uh	r8,sp[36]
80006d1c:	ed 68 00 29 	st.b	r6[41],r8
80006d20:	fb 38 00 24 	ld.ub	r8,sp[36]
80006d24:	ed 68 00 2a 	st.b	r6[42],r8
		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
80006d28:	ed 62 00 16 	st.b	r6[22],r2
80006d2c:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80006d30:	ed 68 00 17 	st.b	r6[23],r8
		tbl[BS_DrvNum] = 0x80;				/* Drive number */
80006d34:	38 08       	mov	r8,-128
80006d36:	ed 68 00 24 	st.b	r6[36],r8
		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
80006d3a:	32 98       	mov	r8,41
80006d3c:	ed 68 00 26 	st.b	r6[38],r8
		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
80006d40:	31 3a       	mov	r10,19
80006d42:	fe fb 02 1a 	ld.w	r11,pc[538]
80006d46:	ec cc ff d5 	sub	r12,r6,-43
80006d4a:	f0 1f 00 82 	mcall	80006f50 <f_mkfs+0x678>
	}
	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
80006d4e:	ec c9 fe 02 	sub	r9,r6,-510
80006d52:	50 69       	stdsp	sp[0x18],r9
80006d54:	35 58       	mov	r8,85
80006d56:	b2 88       	st.b	r9[0x0],r8
80006d58:	ec c8 fe 01 	sub	r8,r6,-511
80006d5c:	50 08       	stdsp	sp[0x0],r8
80006d5e:	3a a8       	mov	r8,-86
80006d60:	40 0c       	lddsp	r12,sp[0x0]
80006d62:	b8 88       	st.b	r12[0x0],r8
	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
80006d64:	30 19       	mov	r9,1
80006d66:	02 9a       	mov	r10,r1
80006d68:	0c 9b       	mov	r11,r6
80006d6a:	08 9c       	mov	r12,r4
80006d6c:	f0 1f 00 77 	mcall	80006f48 <f_mkfs+0x670>
80006d70:	e0 81 00 d2 	brne	80006f14 <f_mkfs+0x63c>
		return FR_DISK_ERR;
	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
80006d74:	40 3b       	lddsp	r11,sp[0xc]
80006d76:	58 0b       	cp.w	r11,0
80006d78:	c0 80       	breq	80006d88 <f_mkfs+0x4b0>
		disk_write(pdrv, tbl, b_vol + 6, 1);
80006d7a:	30 19       	mov	r9,1
80006d7c:	e2 ca ff fa 	sub	r10,r1,-6
80006d80:	0c 9b       	mov	r11,r6
80006d82:	08 9c       	mov	r12,r4
80006d84:	f0 1f 00 71 	mcall	80006f48 <f_mkfs+0x670>

	/* Initialize FAT area */
	wsect = b_fat;
	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
80006d88:	e0 6a 02 00 	mov	r10,512
80006d8c:	30 0b       	mov	r11,0
80006d8e:	0c 9c       	mov	r12,r6
80006d90:	f0 1f 00 6d 	mcall	80006f44 <f_mkfs+0x66c>
		n = md;								/* Media descriptor byte */
		if (fmt != FS_FAT32) {
80006d94:	30 38       	mov	r8,3
80006d96:	f0 03 18 00 	cp.b	r3,r8
80006d9a:	c1 d0       	breq	80006dd4 <f_mkfs+0x4fc>
			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
80006d9c:	30 18       	mov	r8,1
80006d9e:	fe 7a ff 00 	mov	r10,-256
80006da2:	e0 69 ff 00 	mov	r9,65280
80006da6:	ea 19 00 ff 	orh	r9,0xff
80006daa:	e6 08 18 00 	cp.b	r8,r3
80006dae:	f2 08 17 00 	moveq	r8,r9
80006db2:	f4 08 17 10 	movne	r8,r10
80006db6:	f1 e7 10 07 	or	r7,r8,r7
80006dba:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
80006dbc:	eb 67 00 30 	st.b	r5[48],r7
80006dc0:	fb 38 00 26 	ld.ub	r8,sp[38]
80006dc4:	ac 98       	st.b	r6[0x1],r8
80006dc6:	fb 18 00 24 	ld.uh	r8,sp[36]
80006dca:	ac a8       	st.b	r6[0x2],r8
80006dcc:	fb 38 00 24 	ld.ub	r8,sp[36]
80006dd0:	ac b8       	st.b	r6[0x3],r8
80006dd2:	c1 f8       	rjmp	80006e10 <f_mkfs+0x538>
		} else {
			n |= 0xFFFFFF00;
80006dd4:	ea 17 ff ff 	orh	r7,0xffff
80006dd8:	e8 17 ff 00 	orl	r7,0xff00
80006ddc:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
80006dde:	eb 67 00 30 	st.b	r5[48],r7
80006de2:	fb 38 00 26 	ld.ub	r8,sp[38]
80006de6:	ac 98       	st.b	r6[0x1],r8
80006de8:	fb 18 00 24 	ld.uh	r8,sp[36]
80006dec:	ac a8       	st.b	r6[0x2],r8
80006dee:	fb 38 00 24 	ld.ub	r8,sp[36]
80006df2:	ac b8       	st.b	r6[0x3],r8
			ST_DWORD(tbl + 4, 0xFFFFFFFF);
80006df4:	3f f8       	mov	r8,-1
80006df6:	ac c8       	st.b	r6[0x4],r8
80006df8:	ac d8       	st.b	r6[0x5],r8
80006dfa:	ac e8       	st.b	r6[0x6],r8
80006dfc:	ac f8       	st.b	r6[0x7],r8
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
80006dfe:	ed 68 00 08 	st.b	r6[8],r8
80006e02:	ed 68 00 09 	st.b	r6[9],r8
80006e06:	ed 68 00 0a 	st.b	r6[10],r8
80006e0a:	30 f8       	mov	r8,15
80006e0c:	40 5a       	lddsp	r10,sp[0x14]
80006e0e:	b4 88       	st.b	r10[0x0],r8
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006e10:	30 19       	mov	r9,1
80006e12:	40 1a       	lddsp	r10,sp[0x4]
80006e14:	0c 9b       	mov	r11,r6
80006e16:	08 9c       	mov	r12,r4
80006e18:	f0 1f 00 4c 	mcall	80006f48 <f_mkfs+0x670>
80006e1c:	c7 c1       	brne	80006f14 <f_mkfs+0x63c>
80006e1e:	40 13       	lddsp	r3,sp[0x4]
80006e20:	2f f3       	sub	r3,-1
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
80006e22:	e0 6a 02 00 	mov	r10,512
80006e26:	30 0b       	mov	r11,0
80006e28:	0c 9c       	mov	r12,r6
80006e2a:	f0 1f 00 47 	mcall	80006f44 <f_mkfs+0x66c>
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006e2e:	30 18       	mov	r8,1
80006e30:	50 98       	stdsp	sp[0x24],r8
80006e32:	10 32       	cp.w	r2,r8
80006e34:	e0 88 00 11 	brls	80006e56 <f_mkfs+0x57e>
			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006e38:	10 97       	mov	r7,r8
80006e3a:	0e 99       	mov	r9,r7
80006e3c:	06 9a       	mov	r10,r3
80006e3e:	0c 9b       	mov	r11,r6
80006e40:	08 9c       	mov	r12,r4
80006e42:	f0 1f 00 42 	mcall	80006f48 <f_mkfs+0x670>
80006e46:	c6 71       	brne	80006f14 <f_mkfs+0x63c>
80006e48:	2f f3       	sub	r3,-1
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006e4a:	40 98       	lddsp	r8,sp[0x24]
80006e4c:	2f f8       	sub	r8,-1
80006e4e:	50 98       	stdsp	sp[0x24],r8
80006e50:	10 32       	cp.w	r2,r8
80006e52:	fe 9b ff f4 	brhi	80006e3a <f_mkfs+0x562>
				return FR_DISK_ERR;
		}
	}

	/* Initialize root directory */
	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
80006e56:	40 29       	lddsp	r9,sp[0x8]
80006e58:	40 38       	lddsp	r8,sp[0xc]
80006e5a:	58 08       	cp.w	r8,0
80006e5c:	f2 00 17 00 	moveq	r0,r9
	do {
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006e60:	30 12       	mov	r2,1
80006e62:	06 9a       	mov	r10,r3
80006e64:	f4 c7 ff ff 	sub	r7,r10,-1
80006e68:	04 99       	mov	r9,r2
80006e6a:	0c 9b       	mov	r11,r6
80006e6c:	08 9c       	mov	r12,r4
80006e6e:	f0 1f 00 37 	mcall	80006f48 <f_mkfs+0x670>
80006e72:	c5 11       	brne	80006f14 <f_mkfs+0x63c>
			return FR_DISK_ERR;
	} while (--i);
80006e74:	20 10       	sub	r0,1
80006e76:	c0 30       	breq	80006e7c <f_mkfs+0x5a4>
80006e78:	0e 9a       	mov	r10,r7
80006e7a:	cf 5b       	rjmp	80006e64 <f_mkfs+0x58c>
		disk_ioctl(pdrv, CTRL_TRIM, eb);
	}
#endif

	/* Create FSINFO if needed */
	if (fmt == FS_FAT32) {
80006e7c:	40 3c       	lddsp	r12,sp[0xc]
80006e7e:	58 0c       	cp.w	r12,0
80006e80:	c4 30       	breq	80006f06 <f_mkfs+0x62e>
		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
80006e82:	35 28       	mov	r8,82
80006e84:	eb 68 00 30 	st.b	r5[48],r8
80006e88:	ac 98       	st.b	r6[0x1],r8
80006e8a:	36 18       	mov	r8,97
80006e8c:	ac a8       	st.b	r6[0x2],r8
80006e8e:	34 19       	mov	r9,65
80006e90:	ac b9       	st.b	r6[0x3],r9
		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
80006e92:	37 2a       	mov	r10,114
80006e94:	ed 6a 01 e4 	st.b	r6[484],r10
80006e98:	ed 6a 01 e5 	st.b	r6[485],r10
80006e9c:	ed 69 01 e6 	st.b	r6[486],r9
80006ea0:	ed 68 01 e7 	st.b	r6[487],r8
		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
80006ea4:	40 48       	lddsp	r8,sp[0x10]
80006ea6:	20 18       	sub	r8,1
80006ea8:	ed 68 01 e8 	st.b	r6[488],r8
80006eac:	40 48       	lddsp	r8,sp[0x10]
80006eae:	20 18       	sub	r8,1
80006eb0:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
80006eb4:	ed 68 01 e9 	st.b	r6[489],r8
80006eb8:	40 48       	lddsp	r8,sp[0x10]
80006eba:	20 18       	sub	r8,1
80006ebc:	f0 09 16 10 	lsr	r9,r8,0x10
80006ec0:	ed 69 01 ea 	st.b	r6[490],r9
80006ec4:	b9 88       	lsr	r8,0x18
80006ec6:	ed 68 01 eb 	st.b	r6[491],r8
		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
80006eca:	30 28       	mov	r8,2
80006ecc:	ed 68 01 ec 	st.b	r6[492],r8
80006ed0:	30 08       	mov	r8,0
80006ed2:	ed 68 01 ed 	st.b	r6[493],r8
80006ed6:	ed 68 01 ee 	st.b	r6[494],r8
80006eda:	ed 68 01 ef 	st.b	r6[495],r8
		ST_WORD(tbl + BS_55AA, 0xAA55);
80006ede:	35 58       	mov	r8,85
80006ee0:	40 6b       	lddsp	r11,sp[0x18]
80006ee2:	b6 88       	st.b	r11[0x0],r8
80006ee4:	3a a8       	mov	r8,-86
80006ee6:	40 0a       	lddsp	r10,sp[0x0]
80006ee8:	b4 88       	st.b	r10[0x0],r8
		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
80006eea:	30 19       	mov	r9,1
80006eec:	e2 09 00 0a 	add	r10,r1,r9
80006ef0:	0c 9b       	mov	r11,r6
80006ef2:	08 9c       	mov	r12,r4
80006ef4:	f0 1f 00 15 	mcall	80006f48 <f_mkfs+0x670>
		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
80006ef8:	30 19       	mov	r9,1
80006efa:	e2 ca ff f9 	sub	r10,r1,-7
80006efe:	0c 9b       	mov	r11,r6
80006f00:	08 9c       	mov	r12,r4
80006f02:	f0 1f 00 12 	mcall	80006f48 <f_mkfs+0x670>
	}

	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
80006f06:	30 0a       	mov	r10,0
80006f08:	14 9b       	mov	r11,r10
80006f0a:	08 9c       	mov	r12,r4
80006f0c:	f0 1f 00 0b 	mcall	80006f38 <f_mkfs+0x660>
80006f10:	5f 1c       	srne	r12
80006f12:	c0 48       	rjmp	80006f1a <f_mkfs+0x642>
80006f14:	30 1c       	mov	r12,1
80006f16:	c0 28       	rjmp	80006f1a <f_mkfs+0x642>
80006f18:	30 ec       	mov	r12,14
}
80006f1a:	2f 6d       	sub	sp,-40
80006f1c:	d8 32       	popm	r0-r7,pc
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006f1e:	30 39       	mov	r9,3
80006f20:	f2 03 18 00 	cp.b	r3,r9
80006f24:	5f 09       	sreq	r9
80006f26:	50 39       	stdsp	sp[0xc],r9
80006f28:	fe 9f fd d9 	bral	80006ada <f_mkfs+0x202>
80006f2c:	80 00       	ld.sh	r0,r0[0x0]
80006f2e:	66 e0       	ld.w	r0,r3[0x38]
80006f30:	00 00       	add	r0,r0
80006f32:	11 dc       	ld.ub	r12,r8[0x5]
80006f34:	80 00       	ld.sh	r0,r0[0x0]
80006f36:	65 46       	ld.w	r6,r2[0x50]
80006f38:	80 00       	ld.sh	r0,r0[0x0]
80006f3a:	65 84       	ld.w	r4,r2[0x60]
80006f3c:	80 01       	ld.sh	r1,r0[0x0]
80006f3e:	95 52       	st.w	r10[0x14],r2
80006f40:	80 01       	ld.sh	r1,r0[0x0]
80006f42:	95 3c       	st.w	r10[0xc],r12
80006f44:	80 00       	ld.sh	r0,r0[0x0]
80006f46:	66 22       	ld.w	r2,r3[0x8]
80006f48:	80 00       	ld.sh	r0,r0[0x0]
80006f4a:	65 d4       	ld.w	r4,r2[0x74]
80006f4c:	80 01       	ld.sh	r1,r0[0x0]
80006f4e:	95 6c       	st.w	r10[0x18],r12
80006f50:	80 00       	ld.sh	r0,r0[0x0]
80006f52:	66 0c       	ld.w	r12,r3[0x0]
80006f54:	80 00       	ld.sh	r0,r0[0x0]
80006f56:	65 48       	ld.w	r8,r2[0x50]
80006f58:	80 01       	ld.sh	r1,r0[0x0]
80006f5a:	95 78       	st.w	r10[0x1c],r8
80006f5c:	80 01       	ld.sh	r1,r0[0x0]
80006f5e:	95 8c       	st.w	r10[0x20],r12

80006f60 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
80006f60:	d4 01       	pushm	lr
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
80006f62:	58 0c       	cp.w	r12,0
80006f64:	c1 40       	breq	80006f8c <validate+0x2c>
80006f66:	78 08       	ld.w	r8,r12[0x0]
80006f68:	58 08       	cp.w	r8,0
80006f6a:	c1 10       	breq	80006f8c <validate+0x2c>
80006f6c:	11 8a       	ld.ub	r10,r8[0x0]
80006f6e:	30 09       	mov	r9,0
80006f70:	f2 0a 18 00 	cp.b	r10,r9
80006f74:	c0 c0       	breq	80006f8c <validate+0x2c>
80006f76:	90 3a       	ld.sh	r10,r8[0x6]
80006f78:	98 29       	ld.sh	r9,r12[0x4]
80006f7a:	f2 0a 19 00 	cp.h	r10,r9
80006f7e:	c0 71       	brne	80006f8c <validate+0x2c>
80006f80:	11 9c       	ld.ub	r12,r8[0x1]
80006f82:	f0 1f 00 04 	mcall	80006f90 <validate+0x30>
80006f86:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80006f8a:	c0 20       	breq	80006f8e <validate+0x2e>
80006f8c:	30 9c       	mov	r12,9
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
80006f8e:	d8 02       	popm	pc
80006f90:	80 00       	ld.sh	r0,r0[0x0]
80006f92:	65 44       	ld.w	r4,r2[0x50]

80006f94 <move_window>:
static
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
80006f94:	eb cd 40 e0 	pushm	r5-r7,lr
80006f98:	18 97       	mov	r7,r12
80006f9a:	16 95       	mov	r5,r11
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
80006f9c:	78 b8       	ld.w	r8,r12[0x2c]
80006f9e:	16 38       	cp.w	r8,r11
80006fa0:	c0 31       	brne	80006fa6 <move_window+0x12>
80006fa2:	30 06       	mov	r6,0
80006fa4:	c1 18       	rjmp	80006fc6 <move_window+0x32>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
80006fa6:	f0 1f 00 0a 	mcall	80006fcc <move_window+0x38>
80006faa:	18 96       	mov	r6,r12
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
80006fac:	c0 d1       	brne	80006fc6 <move_window+0x32>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
80006fae:	30 19       	mov	r9,1
80006fb0:	0a 9a       	mov	r10,r5
80006fb2:	ee cb ff d0 	sub	r11,r7,-48
80006fb6:	0f 9c       	ld.ub	r12,r7[0x1]
80006fb8:	f0 1f 00 06 	mcall	80006fd0 <move_window+0x3c>
80006fbc:	f9 b6 01 01 	movne	r6,1
80006fc0:	f9 b5 01 ff 	movne	r5,-1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
			}
			fs->winsect = sector;
80006fc4:	8f b5       	st.w	r7[0x2c],r5
		}
	}
	return res;
}
80006fc6:	0c 9c       	mov	r12,r6
80006fc8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006fcc:	80 00       	ld.sh	r0,r0[0x0]
80006fce:	67 9c       	ld.w	r12,r3[0x64]
80006fd0:	80 00       	ld.sh	r0,r0[0x0]
80006fd2:	65 f0       	ld.w	r0,r2[0x7c]

80006fd4 <check_fs>:
static
BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
80006fd4:	eb cd 40 80 	pushm	r7,lr
80006fd8:	18 97       	mov	r7,r12
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
80006fda:	30 08       	mov	r8,0
80006fdc:	b8 c8       	st.b	r12[0x4],r8
80006fde:	3f f8       	mov	r8,-1
80006fe0:	99 b8       	st.w	r12[0x2c],r8
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
80006fe2:	f0 1f 00 23 	mcall	8000706c <check_fs+0x98>
80006fe6:	c0 40       	breq	80006fee <check_fs+0x1a>
80006fe8:	30 3c       	mov	r12,3
80006fea:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
80006fee:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006ff2:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006ff6:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006ffa:	fe 78 aa 55 	mov	r8,-21931
80006ffe:	f0 09 19 00 	cp.h	r9,r8
80007002:	c0 40       	breq	8000700a <check_fs+0x36>
80007004:	30 2c       	mov	r12,2
80007006:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
8000700a:	ef 39 00 69 	ld.ub	r9,r7[105]
8000700e:	ef 38 00 68 	ld.ub	r8,r7[104]
80007012:	b1 68       	lsl	r8,0x10
80007014:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80007018:	ef 39 00 66 	ld.ub	r9,r7[102]
8000701c:	12 48       	or	r8,r9
8000701e:	ef 39 00 67 	ld.ub	r9,r7[103]
80007022:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007026:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
8000702a:	e0 69 41 46 	mov	r9,16710
8000702e:	ea 19 00 54 	orh	r9,0x54
80007032:	12 38       	cp.w	r8,r9
80007034:	c0 31       	brne	8000703a <check_fs+0x66>
80007036:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000703a:	ef 39 00 85 	ld.ub	r9,r7[133]
8000703e:	ef 38 00 84 	ld.ub	r8,r7[132]
80007042:	b1 68       	lsl	r8,0x10
80007044:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80007048:	ef 39 00 82 	ld.ub	r9,r7[130]
8000704c:	12 48       	or	r8,r9
8000704e:	ef 39 00 83 	ld.ub	r9,r7[131]
80007052:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007056:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
8000705a:	e0 69 41 46 	mov	r9,16710
8000705e:	ea 19 00 54 	orh	r9,0x54
80007062:	12 38       	cp.w	r8,r9
80007064:	5f 1c       	srne	r12
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
80007066:	e3 cd 80 80 	ldm	sp++,r7,pc
8000706a:	00 00       	add	r0,r0
8000706c:	80 00       	ld.sh	r0,r0[0x0]
8000706e:	6f 94       	ld.w	r4,r7[0x64]

80007070 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
80007070:	eb cd 40 fb 	pushm	r0-r1,r3-r7,lr
80007074:	20 4d       	sub	sp,16
80007076:	18 95       	mov	r5,r12
80007078:	14 94       	mov	r4,r10
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
8000707a:	30 08       	mov	r8,0
8000707c:	99 08       	st.w	r12[0x0],r8
	vol = get_ldnumber(path);
8000707e:	16 9c       	mov	r12,r11
80007080:	f0 1f 00 de 	mcall	800073f8 <find_volume+0x388>
80007084:	18 96       	mov	r6,r12
	if (vol < 0) return FR_INVALID_DRIVE;
80007086:	c0 34       	brge	8000708c <find_volume+0x1c>
80007088:	30 bc       	mov	r12,11
8000708a:	ca a9       	rjmp	800073de <find_volume+0x36e>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
8000708c:	fe f8 03 70 	ld.w	r8,pc[880]
80007090:	f0 0c 03 27 	ld.w	r7,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
80007094:	58 07       	cp.w	r7,0
80007096:	c0 31       	brne	8000709c <find_volume+0x2c>
80007098:	30 cc       	mov	r12,12
8000709a:	ca 29       	rjmp	800073de <find_volume+0x36e>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
8000709c:	8b 07       	st.w	r5[0x0],r7

	if (fs->fs_type) {					/* If the volume has been mounted */
8000709e:	0f 89       	ld.ub	r9,r7[0x0]
800070a0:	30 08       	mov	r8,0
800070a2:	f0 09 18 00 	cp.b	r9,r8
800070a6:	c0 f0       	breq	800070c4 <find_volume+0x54>
		stat = disk_status(fs->drv);
800070a8:	0f 9c       	ld.ub	r12,r7[0x1]
800070aa:	f0 1f 00 d6 	mcall	80007400 <find_volume+0x390>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
800070ae:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
800070b2:	c0 91       	brne	800070c4 <find_volume+0x54>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
800070b4:	58 04       	cp.w	r4,0
800070b6:	e0 80 01 91 	breq	800073d8 <find_volume+0x368>
800070ba:	e2 1c 00 04 	andl	r12,0x4,COH
800070be:	e0 81 01 8b 	brne	800073d4 <find_volume+0x364>
800070c2:	c8 b9       	rjmp	800073d8 <find_volume+0x368>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
800070c4:	30 08       	mov	r8,0
800070c6:	ae 88       	st.b	r7[0x0],r8
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
800070c8:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
800070cc:	ae 9c       	st.b	r7[0x1],r12
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
800070ce:	f0 1f 00 ce 	mcall	80007404 <find_volume+0x394>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
800070d2:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
800070d6:	c0 30       	breq	800070dc <find_volume+0x6c>
800070d8:	30 3c       	mov	r12,3
800070da:	c8 29       	rjmp	800073de <find_volume+0x36e>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
800070dc:	58 04       	cp.w	r4,0
800070de:	c0 50       	breq	800070e8 <find_volume+0x78>
800070e0:	e2 1c 00 04 	andl	r12,0x4,COH
800070e4:	e0 81 01 78 	brne	800073d4 <find_volume+0x364>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
800070e8:	30 0b       	mov	r11,0
800070ea:	0e 9c       	mov	r12,r7
800070ec:	f0 1f 00 c7 	mcall	80007408 <find_volume+0x398>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
800070f0:	30 18       	mov	r8,1
800070f2:	f0 0c 18 00 	cp.b	r12,r8
800070f6:	c0 30       	breq	800070fc <find_volume+0x8c>
800070f8:	30 05       	mov	r5,0
800070fa:	c3 48       	rjmp	80007162 <find_volume+0xf2>
800070fc:	1a 96       	mov	r6,sp
800070fe:	1a 9a       	mov	r10,sp
80007100:	e0 68 01 be 	mov	r8,446
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80007104:	30 0c       	mov	r12,0
80007106:	30 04       	mov	r4,0
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
80007108:	f0 c9 ff d0 	sub	r9,r8,-48
8000710c:	ee 09 00 09 	add	r9,r7,r9
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80007110:	13 cb       	ld.ub	r11,r9[0x4]
80007112:	f8 0b 18 00 	cp.b	r11,r12
80007116:	c0 31       	brne	8000711c <find_volume+0xac>
80007118:	08 99       	mov	r9,r4
8000711a:	c0 f8       	rjmp	80007138 <find_volume+0xc8>
8000711c:	f3 35 00 0b 	ld.ub	r5,r9[11]
80007120:	f3 3b 00 0a 	ld.ub	r11,r9[10]
80007124:	b1 6b       	lsl	r11,0x10
80007126:	f7 e5 11 8b 	or	r11,r11,r5<<0x18
8000712a:	f3 35 00 08 	ld.ub	r5,r9[8]
8000712e:	0a 4b       	or	r11,r5
80007130:	f3 39 00 09 	ld.ub	r9,r9[9]
80007134:	f7 e9 10 89 	or	r9,r11,r9<<0x8
80007138:	14 a9       	st.w	r10++,r9
8000713a:	2f 08       	sub	r8,-16
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
8000713c:	e0 48 01 fe 	cp.w	r8,510
80007140:	ce 41       	brne	80007108 <find_volume+0x98>
/*-----------------------------------------------------------------------*/
/* Find logical drive and check if the volume is mounted                 */
/*-----------------------------------------------------------------------*/

static
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
80007142:	fa c4 ff f0 	sub	r4,sp,-16
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
80007146:	30 23       	mov	r3,2
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
80007148:	6c 05       	ld.w	r5,r6[0x0]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
8000714a:	58 05       	cp.w	r5,0
8000714c:	c0 31       	brne	80007152 <find_volume+0xe2>
8000714e:	06 9c       	mov	r12,r3
80007150:	c0 68       	rjmp	8000715c <find_volume+0xec>
80007152:	0a 9b       	mov	r11,r5
80007154:	0e 9c       	mov	r12,r7
80007156:	f0 1f 00 ad 	mcall	80007408 <find_volume+0x398>
		} while (!LD2PT(vol) && fmt && ++i < 4);
8000715a:	c0 d0       	breq	80007174 <find_volume+0x104>
8000715c:	2f c6       	sub	r6,-4
8000715e:	08 36       	cp.w	r6,r4
80007160:	cf 41       	brne	80007148 <find_volume+0xd8>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
80007162:	30 38       	mov	r8,3
80007164:	f0 0c 18 00 	cp.b	r12,r8
80007168:	c0 31       	brne	8000716e <find_volume+0xfe>
8000716a:	30 1c       	mov	r12,1
8000716c:	c3 99       	rjmp	800073de <find_volume+0x36e>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
8000716e:	58 0c       	cp.w	r12,0
80007170:	e0 81 01 36 	brne	800073dc <find_volume+0x36c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
80007174:	ef 39 00 3c 	ld.ub	r9,r7[60]
80007178:	ef 38 00 3b 	ld.ub	r8,r7[59]
8000717c:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80007180:	e0 68 02 00 	mov	r8,512
80007184:	f0 09 19 00 	cp.h	r9,r8
80007188:	e0 81 01 2a 	brne	800073dc <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
8000718c:	ef 39 00 47 	ld.ub	r9,r7[71]
80007190:	ef 38 00 46 	ld.ub	r8,r7[70]
80007194:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
80007198:	c1 01       	brne	800071b8 <find_volume+0x148>
8000719a:	ef 39 00 57 	ld.ub	r9,r7[87]
8000719e:	ef 38 00 56 	ld.ub	r8,r7[86]
800071a2:	b1 68       	lsl	r8,0x10
800071a4:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800071a8:	ef 38 00 54 	ld.ub	r8,r7[84]
800071ac:	f3 e8 10 08 	or	r8,r9,r8
800071b0:	ef 39 00 55 	ld.ub	r9,r7[85]
800071b4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	fs->fsize = fasize;
800071b8:	8f 68       	st.w	r7[0x18],r8

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
800071ba:	ef 39 00 40 	ld.ub	r9,r7[64]
800071be:	ae b9       	st.b	r7[0x3],r9
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
800071c0:	f2 cb 00 01 	sub	r11,r9,1
800071c4:	30 1a       	mov	r10,1
800071c6:	f4 0b 18 00 	cp.b	r11,r10
800071ca:	e0 8b 01 09 	brhi	800073dc <find_volume+0x36c>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
800071ce:	ef 3a 00 3d 	ld.ub	r10,r7[61]
800071d2:	ae aa       	st.b	r7[0x2],r10
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
800071d4:	58 0a       	cp.w	r10,0
800071d6:	e0 80 01 03 	breq	800073dc <find_volume+0x36c>
800071da:	f4 cb 00 01 	sub	r11,r10,1
800071de:	14 6b       	and	r11,r10
800071e0:	e0 81 00 fe 	brne	800073dc <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
800071e4:	ef 3c 00 42 	ld.ub	r12,r7[66]
800071e8:	ef 3b 00 41 	ld.ub	r11,r7[65]
800071ec:	f7 ec 10 8b 	or	r11,r11,r12<<0x8
800071f0:	5c 8b       	casts.h	r11
800071f2:	ae 4b       	st.h	r7[0x8],r11
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
800071f4:	f9 db c0 04 	bfextu	r12,r11,0x0,0x4
800071f8:	e0 81 00 f2 	brne	800073dc <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
800071fc:	ef 36 00 44 	ld.ub	r6,r7[68]
80007200:	ef 3c 00 43 	ld.ub	r12,r7[67]
80007204:	f9 e6 10 8c 	or	r12,r12,r6<<0x8
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
80007208:	c1 01       	brne	80007228 <find_volume+0x1b8>
8000720a:	ef 36 00 53 	ld.ub	r6,r7[83]
8000720e:	ef 3c 00 52 	ld.ub	r12,r7[82]
80007212:	b1 6c       	lsl	r12,0x10
80007214:	f9 e6 11 86 	or	r6,r12,r6<<0x18
80007218:	ef 3c 00 50 	ld.ub	r12,r7[80]
8000721c:	ed ec 10 0c 	or	r12,r6,r12
80007220:	ef 36 00 51 	ld.ub	r6,r7[81]
80007224:	f9 e6 10 8c 	or	r12,r12,r6<<0x8

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
80007228:	ef 34 00 3f 	ld.ub	r4,r7[63]
8000722c:	ef 36 00 3e 	ld.ub	r6,r7[62]
80007230:	ed e4 10 86 	or	r6,r6,r4<<0x8
80007234:	5c 86       	casts.h	r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
80007236:	e0 80 00 d3 	breq	800073dc <find_volume+0x36c>
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
8000723a:	b3 38       	mul	r8,r9

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
8000723c:	e7 d6 c0 10 	bfextu	r3,r6,0x0,0x10
80007240:	e9 db c0 8c 	bfextu	r4,r11,0x4,0xc
80007244:	06 04       	add	r4,r3
80007246:	10 04       	add	r4,r8
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
80007248:	08 3c       	cp.w	r12,r4
8000724a:	e0 83 00 c9 	brlo	800073dc <find_volume+0x36c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
8000724e:	f8 04 01 01 	sub	r1,r12,r4
80007252:	e2 0a 0d 00 	divu	r0,r1,r10
80007256:	00 99       	mov	r9,r0
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
80007258:	58 00       	cp.w	r0,0
8000725a:	e0 80 00 c1 	breq	800073dc <find_volume+0x36c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
8000725e:	e0 40 0f f6 	cp.w	r0,4086
80007262:	f9 b6 03 01 	movlo	r6,1
80007266:	f9 b6 02 02 	movhs	r6,2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
8000726a:	e0 40 ff f5 	cp.w	r0,65525
8000726e:	e0 8b 00 bb 	brhi	800073e4 <find_volume+0x374>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80007272:	2f e9       	sub	r9,-2
80007274:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
80007276:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
80007278:	ea 03 00 03 	add	r3,r5,r3
8000727c:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
8000727e:	0a 04       	add	r4,r5
80007280:	8f a4       	st.w	r7[0x28],r4
	if (fmt == FS_FAT32) {
80007282:	30 3a       	mov	r10,3
80007284:	f4 06 18 00 	cp.b	r6,r10
80007288:	c1 61       	brne	800072b4 <find_volume+0x244>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
8000728a:	58 0b       	cp.w	r11,0
8000728c:	e0 81 00 a8 	brne	800073dc <find_volume+0x36c>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
80007290:	ef 3a 00 5f 	ld.ub	r10,r7[95]
80007294:	ef 38 00 5e 	ld.ub	r8,r7[94]
80007298:	b1 68       	lsl	r8,0x10
8000729a:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000729e:	ef 38 00 5c 	ld.ub	r8,r7[92]
800072a2:	f5 e8 10 08 	or	r8,r10,r8
800072a6:	ef 3a 00 5d 	ld.ub	r10,r7[93]
800072aa:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800072ae:	8f 98       	st.w	r7[0x24],r8
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
800072b0:	a3 69       	lsl	r9,0x2
800072b2:	c1 38       	rjmp	800072d8 <find_volume+0x268>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
800072b4:	58 0b       	cp.w	r11,0
800072b6:	e0 80 00 93 	breq	800073dc <find_volume+0x36c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
800072ba:	06 08       	add	r8,r3
800072bc:	8f 98       	st.w	r7[0x24],r8
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
800072be:	30 28       	mov	r8,2
800072c0:	f0 06 18 00 	cp.b	r6,r8
800072c4:	c0 31       	brne	800072ca <find_volume+0x25a>
800072c6:	a1 79       	lsl	r9,0x1
800072c8:	c0 88       	rjmp	800072d8 <find_volume+0x268>
800072ca:	f2 09 00 18 	add	r8,r9,r9<<0x1
800072ce:	a1 98       	lsr	r8,0x1
800072d0:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800072d4:	f0 09 00 09 	add	r9,r8,r9
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
800072d8:	f2 c8 fe 01 	sub	r8,r9,-511
800072dc:	a9 98       	lsr	r8,0x9
800072de:	6e 69       	ld.w	r9,r7[0x18]
800072e0:	10 39       	cp.w	r9,r8
800072e2:	c7 d3       	brcs	800073dc <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
800072e4:	3f f8       	mov	r8,-1
800072e6:	8f 48       	st.w	r7[0x10],r8
800072e8:	8f 38       	st.w	r7[0xc],r8

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
800072ea:	38 08       	mov	r8,-128
800072ec:	ae d8       	st.b	r7[0x5],r8
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
800072ee:	30 38       	mov	r8,3
800072f0:	f0 06 18 00 	cp.b	r6,r8
800072f4:	c6 81       	brne	800073c4 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
800072f6:	ef 39 00 61 	ld.ub	r9,r7[97]
800072fa:	ef 38 00 60 	ld.ub	r8,r7[96]
800072fe:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80007302:	30 18       	mov	r8,1
80007304:	f0 09 19 00 	cp.h	r9,r8
80007308:	c5 e1       	brne	800073c4 <find_volume+0x354>
		&& move_window(fs, bsect + 1) == FR_OK)
8000730a:	ea cb ff ff 	sub	r11,r5,-1
8000730e:	0e 9c       	mov	r12,r7
80007310:	f0 1f 00 3f 	mcall	8000740c <find_volume+0x39c>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
80007314:	c5 81       	brne	800073c4 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
80007316:	30 08       	mov	r8,0
80007318:	ae d8       	st.b	r7[0x5],r8
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
8000731a:	ef 39 02 2f 	ld.ub	r9,r7[559]
8000731e:	ef 38 02 2e 	ld.ub	r8,r7[558]
80007322:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80007326:	fe 78 aa 55 	mov	r8,-21931
8000732a:	f0 09 19 00 	cp.h	r9,r8
8000732e:	c4 b1       	brne	800073c4 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
80007330:	ef 39 00 33 	ld.ub	r9,r7[51]
80007334:	ef 38 00 32 	ld.ub	r8,r7[50]
80007338:	b1 68       	lsl	r8,0x10
8000733a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000733e:	ef 38 00 30 	ld.ub	r8,r7[48]
80007342:	f3 e8 10 08 	or	r8,r9,r8
80007346:	ef 39 00 31 	ld.ub	r9,r7[49]
8000734a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000734e:	e0 69 52 52 	mov	r9,21074
80007352:	ea 19 41 61 	orh	r9,0x4161
80007356:	12 38       	cp.w	r8,r9
80007358:	c3 61       	brne	800073c4 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
8000735a:	ef 39 02 17 	ld.ub	r9,r7[535]
8000735e:	ef 38 02 16 	ld.ub	r8,r7[534]
80007362:	b1 68       	lsl	r8,0x10
80007364:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80007368:	ef 38 02 14 	ld.ub	r8,r7[532]
8000736c:	f3 e8 10 08 	or	r8,r9,r8
80007370:	ef 39 02 15 	ld.ub	r9,r7[533]
80007374:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007378:	e0 69 72 72 	mov	r9,29298
8000737c:	ea 19 61 41 	orh	r9,0x6141
80007380:	12 38       	cp.w	r8,r9
80007382:	c2 11       	brne	800073c4 <find_volume+0x354>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
80007384:	ef 39 02 1b 	ld.ub	r9,r7[539]
80007388:	ef 38 02 1a 	ld.ub	r8,r7[538]
8000738c:	b1 68       	lsl	r8,0x10
8000738e:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80007392:	ef 38 02 18 	ld.ub	r8,r7[536]
80007396:	f3 e8 10 08 	or	r8,r9,r8
8000739a:	ef 39 02 19 	ld.ub	r9,r7[537]
8000739e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800073a2:	8f 48       	st.w	r7[0x10],r8
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
800073a4:	ef 39 02 1f 	ld.ub	r9,r7[543]
800073a8:	ef 38 02 1e 	ld.ub	r8,r7[542]
800073ac:	b1 68       	lsl	r8,0x10
800073ae:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800073b2:	ef 38 02 1c 	ld.ub	r8,r7[540]
800073b6:	f3 e8 10 08 	or	r8,r9,r8
800073ba:	ef 39 02 1d 	ld.ub	r9,r7[541]
800073be:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800073c2:	8f 38       	st.w	r7[0xc],r8
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
800073c4:	ae 86       	st.b	r7[0x0],r6
	fs->id = ++Fsid;	/* File system mount ID */
800073c6:	49 39       	lddpc	r9,80007410 <find_volume+0x3a0>
800073c8:	92 08       	ld.sh	r8,r9[0x0]
800073ca:	2f f8       	sub	r8,-1
800073cc:	b2 08       	st.h	r9[0x0],r8
800073ce:	ae 38       	st.h	r7[0x6],r8
800073d0:	30 0c       	mov	r12,0
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
800073d2:	c0 68       	rjmp	800073de <find_volume+0x36e>
800073d4:	30 ac       	mov	r12,10
800073d6:	c0 48       	rjmp	800073de <find_volume+0x36e>
800073d8:	30 0c       	mov	r12,0
800073da:	c0 28       	rjmp	800073de <find_volume+0x36e>
800073dc:	30 dc       	mov	r12,13
}
800073de:	2f cd       	sub	sp,-16
800073e0:	e3 cd 80 fb 	ldm	sp++,r0-r1,r3-r7,pc
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
800073e4:	2f e9       	sub	r9,-2
800073e6:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
800073e8:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
800073ea:	ea 03 00 03 	add	r3,r5,r3
800073ee:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
800073f0:	0a 04       	add	r4,r5
800073f2:	8f a4       	st.w	r7[0x28],r4
800073f4:	30 36       	mov	r6,3
800073f6:	c4 ab       	rjmp	8000728a <find_volume+0x21a>
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	66 e0       	ld.w	r0,r3[0x38]
800073fc:	00 00       	add	r0,r0
800073fe:	11 dc       	ld.ub	r12,r8[0x5]
80007400:	80 00       	ld.sh	r0,r0[0x0]
80007402:	65 44       	ld.w	r4,r2[0x50]
80007404:	80 00       	ld.sh	r0,r0[0x0]
80007406:	65 46       	ld.w	r6,r2[0x50]
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	6f d4       	ld.w	r4,r7[0x74]
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	6f 94       	ld.w	r4,r7[0x64]
80007410:	00 00       	add	r0,r0
80007412:	11 d8       	ld.ub	r8,r8[0x5]

80007414 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
80007414:	eb cd 40 40 	pushm	r6,lr
80007418:	20 3d       	sub	sp,12
8000741a:	50 1c       	stdsp	sp[0x4],r12
8000741c:	50 0b       	stdsp	sp[0x0],r11
8000741e:	14 96       	mov	r6,r10
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
80007420:	fa cc ff f4 	sub	r12,sp,-12
80007424:	18 db       	st.w	--r12,r11


	vol = get_ldnumber(&rp);
80007426:	f0 1f 00 1a 	mcall	8000748c <f_mount+0x78>
	if (vol < 0) return FR_INVALID_DRIVE;
8000742a:	c0 34       	brge	80007430 <f_mount+0x1c>
8000742c:	30 bc       	mov	r12,11
8000742e:	c2 58       	rjmp	80007478 <f_mount+0x64>
	cfs = FatFs[vol];					/* Pointer to fs object */
80007430:	49 88       	lddpc	r8,80007490 <f_mount+0x7c>
80007432:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
80007436:	58 08       	cp.w	r8,0
80007438:	f9 b9 01 00 	movne	r9,0
8000743c:	f1 f9 1e 00 	st.bne	r8[0x0],r9
	}

	if (fs) {
80007440:	40 18       	lddsp	r8,sp[0x4]
80007442:	58 08       	cp.w	r8,0
80007444:	c1 d0       	breq	8000747e <f_mount+0x6a>
		fs->fs_type = 0;				/* Clear new fs object */
80007446:	30 09       	mov	r9,0
80007448:	b0 89       	st.b	r8[0x0],r9
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
8000744a:	40 18       	lddsp	r8,sp[0x4]
8000744c:	49 1a       	lddpc	r10,80007490 <f_mount+0x7c>
8000744e:	f4 0c 09 28 	st.w	r10[r12<<0x2],r8

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
80007452:	58 08       	cp.w	r8,0
80007454:	5f 0a       	sreq	r10
80007456:	30 18       	mov	r8,1
80007458:	f0 06 18 00 	cp.b	r6,r8
8000745c:	5f 18       	srne	r8
8000745e:	f5 e8 10 08 	or	r8,r10,r8
80007462:	f2 08 18 00 	cp.b	r8,r9
80007466:	c0 30       	breq	8000746c <f_mount+0x58>
80007468:	30 0c       	mov	r12,0
8000746a:	c0 78       	rjmp	80007478 <f_mount+0x64>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
8000746c:	30 0a       	mov	r10,0
8000746e:	1a 9b       	mov	r11,sp
80007470:	fa cc ff fc 	sub	r12,sp,-4
80007474:	f0 1f 00 08 	mcall	80007494 <f_mount+0x80>
	LEAVE_FF(fs, res);
}
80007478:	2f dd       	sub	sp,-12
8000747a:	e3 cd 80 40 	ldm	sp++,r6,pc
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
8000747e:	30 08       	mov	r8,0
80007480:	48 49       	lddpc	r9,80007490 <f_mount+0x7c>
80007482:	f2 0c 09 28 	st.w	r9[r12<<0x2],r8
80007486:	10 9c       	mov	r12,r8
80007488:	cf 8b       	rjmp	80007478 <f_mount+0x64>
8000748a:	00 00       	add	r0,r0
8000748c:	80 00       	ld.sh	r0,r0[0x0]
8000748e:	66 e0       	ld.w	r0,r3[0x38]
80007490:	00 00       	add	r0,r0
80007492:	11 dc       	ld.ub	r12,r8[0x5]
80007494:	80 00       	ld.sh	r0,r0[0x0]
80007496:	70 70       	ld.w	r0,r8[0x1c]

80007498 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
80007498:	eb cd 40 c0 	pushm	r6-r7,lr
8000749c:	18 97       	mov	r7,r12
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
8000749e:	f0 1f 00 2b 	mcall	80007548 <f_sync+0xb0>
	if (res == FR_OK) {
800074a2:	c5 11       	brne	80007544 <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
800074a4:	0f e8       	ld.ub	r8,r7[0x6]
800074a6:	10 99       	mov	r9,r8
800074a8:	e2 19 00 20 	andl	r9,0x20,COH
800074ac:	c4 c0       	breq	80007544 <f_sync+0xac>
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
800074ae:	e2 18 00 40 	andl	r8,0x40,COH
800074b2:	c0 f0       	breq	800074d0 <f_sync+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800074b4:	6e 08       	ld.w	r8,r7[0x0]
800074b6:	30 19       	mov	r9,1
800074b8:	6e 6a       	ld.w	r10,r7[0x18]
800074ba:	ee cb ff d8 	sub	r11,r7,-40
800074be:	11 9c       	ld.ub	r12,r8[0x1]
800074c0:	f0 1f 00 23 	mcall	8000754c <f_sync+0xb4>
800074c4:	c0 30       	breq	800074ca <f_sync+0x32>
800074c6:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
800074ca:	0f e8       	ld.ub	r8,r7[0x6]
800074cc:	a7 c8       	cbr	r8,0x6
800074ce:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
800074d0:	6e 7b       	ld.w	r11,r7[0x1c]
800074d2:	6e 0c       	ld.w	r12,r7[0x0]
800074d4:	f0 1f 00 1f 	mcall	80007550 <f_sync+0xb8>
			if (res == FR_OK) {
800074d8:	c3 61       	brne	80007544 <f_sync+0xac>
				dir = fp->dir_ptr;
800074da:	6e 86       	ld.w	r6,r7[0x20]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
800074dc:	ec c8 ff f5 	sub	r8,r6,-11
800074e0:	11 89       	ld.ub	r9,r8[0x0]
800074e2:	a5 b9       	sbr	r9,0x5
800074e4:	b0 89       	st.b	r8[0x0],r9
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
800074e6:	6e 38       	ld.w	r8,r7[0xc]
800074e8:	ed 68 00 1c 	st.b	r6[28],r8
800074ec:	ef 38 00 0e 	ld.ub	r8,r7[14]
800074f0:	ed 68 00 1d 	st.b	r6[29],r8
800074f4:	8e e8       	ld.uh	r8,r7[0xc]
800074f6:	ed 68 00 1e 	st.b	r6[30],r8
800074fa:	ef 38 00 0c 	ld.ub	r8,r7[12]
800074fe:	ed 68 00 1f 	st.b	r6[31],r8
				st_clust(dir, fp->sclust);					/* Update start cluster */
80007502:	6e 4b       	ld.w	r11,r7[0x10]
80007504:	0c 9c       	mov	r12,r6
80007506:	f0 1f 00 14 	mcall	80007554 <f_sync+0xbc>
				tm = GET_FATTIME();							/* Update modified time */
8000750a:	f0 1f 00 14 	mcall	80007558 <f_sync+0xc0>
				ST_DWORD(dir + DIR_WrtTime, tm);
8000750e:	ed 6c 00 16 	st.b	r6[22],r12
80007512:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
80007516:	ed 68 00 17 	st.b	r6[23],r8
8000751a:	f8 08 16 10 	lsr	r8,r12,0x10
8000751e:	ed 68 00 18 	st.b	r6[24],r8
80007522:	b9 8c       	lsr	r12,0x18
80007524:	ed 6c 00 19 	st.b	r6[25],r12
				ST_WORD(dir + DIR_LstAccDate, 0);
80007528:	30 08       	mov	r8,0
8000752a:	ed 68 00 12 	st.b	r6[18],r8
8000752e:	ed 68 00 13 	st.b	r6[19],r8
				fp->flag &= ~FA__WRITTEN;
80007532:	0f e8       	ld.ub	r8,r7[0x6]
80007534:	a5 d8       	cbr	r8,0x5
80007536:	ae e8       	st.b	r7[0x6],r8
				fp->fs->wflag = 1;
80007538:	6e 08       	ld.w	r8,r7[0x0]
8000753a:	30 19       	mov	r9,1
8000753c:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(fp->fs);
8000753e:	6e 0c       	ld.w	r12,r7[0x0]
80007540:	f0 1f 00 07 	mcall	8000755c <f_sync+0xc4>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
80007544:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007548:	80 00       	ld.sh	r0,r0[0x0]
8000754a:	6f 60       	ld.w	r0,r7[0x58]
8000754c:	80 00       	ld.sh	r0,r0[0x0]
8000754e:	65 d4       	ld.w	r4,r2[0x74]
80007550:	80 00       	ld.sh	r0,r0[0x0]
80007552:	6f 94       	ld.w	r4,r7[0x64]
80007554:	80 00       	ld.sh	r0,r0[0x0]
80007556:	66 c6       	ld.w	r6,r3[0x30]
80007558:	80 00       	ld.sh	r0,r0[0x0]
8000755a:	65 48       	ld.w	r8,r2[0x50]
8000755c:	80 00       	ld.sh	r0,r0[0x0]
8000755e:	68 00       	ld.w	r0,r4[0x0]

80007560 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
80007560:	eb cd 40 80 	pushm	r7,lr
80007564:	18 97       	mov	r7,r12
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
80007566:	f0 1f 00 07 	mcall	80007580 <f_close+0x20>
	if (res == FR_OK)
8000756a:	c0 81       	brne	8000757a <f_close+0x1a>
#endif
	{
		res = validate(fp);				/* Lock volume */
8000756c:	0e 9c       	mov	r12,r7
8000756e:	f0 1f 00 06 	mcall	80007584 <f_close+0x24>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
80007572:	f9 b8 00 00 	moveq	r8,0
80007576:	ef f8 0a 00 	st.weq	r7[0x0],r8
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
8000757a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000757e:	00 00       	add	r0,r0
80007580:	80 00       	ld.sh	r0,r0[0x0]
80007582:	74 98       	ld.w	r8,r10[0x24]
80007584:	80 00       	ld.sh	r0,r0[0x0]
80007586:	6f 60       	ld.w	r0,r7[0x58]

80007588 <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
80007588:	d4 21       	pushm	r4-r7,lr
8000758a:	18 97       	mov	r7,r12
8000758c:	16 96       	mov	r6,r11
8000758e:	14 95       	mov	r5,r10
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
80007590:	58 1b       	cp.w	r11,1
80007592:	e0 88 00 90 	brls	800076b2 <put_fat+0x12a>
80007596:	78 58       	ld.w	r8,r12[0x14]
80007598:	10 3b       	cp.w	r11,r8
8000759a:	e0 82 00 8c 	brhs	800076b2 <put_fat+0x12a>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
8000759e:	19 88       	ld.ub	r8,r12[0x0]
800075a0:	30 29       	mov	r9,2
800075a2:	f2 08 18 00 	cp.b	r8,r9
800075a6:	c4 d0       	breq	80007640 <put_fat+0xb8>
800075a8:	30 39       	mov	r9,3
800075aa:	f2 08 18 00 	cp.b	r8,r9
800075ae:	c5 e0       	breq	8000766a <put_fat+0xe2>
800075b0:	30 19       	mov	r9,1
800075b2:	f2 08 18 00 	cp.b	r8,r9
800075b6:	c7 e1       	brne	800076b2 <put_fat+0x12a>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
800075b8:	f6 04 16 01 	lsr	r4,r11,0x1
800075bc:	16 04       	add	r4,r11
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
800075be:	e8 0b 16 09 	lsr	r11,r4,0x9
800075c2:	78 88       	ld.w	r8,r12[0x20]
800075c4:	10 0b       	add	r11,r8
800075c6:	f0 1f 00 3d 	mcall	800076b8 <put_fat+0x130>
			if (res != FR_OK) break;
800075ca:	c7 51       	brne	800076b4 <put_fat+0x12c>
			p = &fs->win[bc++ % SS(fs)];
800075cc:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
800075d0:	2f f4       	sub	r4,-1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
800075d2:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
800075d6:	c0 d0       	breq	800075f0 <put_fat+0x68>
800075d8:	ee 08 00 09 	add	r9,r7,r8
800075dc:	f3 39 00 30 	ld.ub	r9,r9[48]
800075e0:	f5 d5 c0 08 	bfextu	r10,r5,0x0,0x8
800075e4:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
800075e8:	f3 ea 10 49 	or	r9,r9,r10<<0x4
800075ec:	5c 59       	castu.b	r9
800075ee:	c0 38       	rjmp	800075f4 <put_fat+0x6c>
800075f0:	f3 d5 c0 08 	bfextu	r9,r5,0x0,0x8
800075f4:	ee 08 00 08 	add	r8,r7,r8
800075f8:	f1 69 00 30 	st.b	r8[48],r9
			fs->wflag = 1;
800075fc:	30 18       	mov	r8,1
800075fe:	ae c8       	st.b	r7[0x4],r8
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
80007600:	e8 0b 16 09 	lsr	r11,r4,0x9
80007604:	6e 88       	ld.w	r8,r7[0x20]
80007606:	10 0b       	add	r11,r8
80007608:	0e 9c       	mov	r12,r7
8000760a:	f0 1f 00 2c 	mcall	800076b8 <put_fat+0x130>
			if (res != FR_OK) break;
8000760e:	c5 31       	brne	800076b4 <put_fat+0x12c>
			p = &fs->win[bc % SS(fs)];
80007610:	e9 d4 c0 09 	bfextu	r4,r4,0x0,0x9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
80007614:	58 06       	cp.w	r6,0
80007616:	c0 40       	breq	8000761e <put_fat+0x96>
80007618:	eb d5 c0 88 	bfextu	r5,r5,0x4,0x8
8000761c:	c0 b8       	rjmp	80007632 <put_fat+0xaa>
8000761e:	ee 04 00 08 	add	r8,r7,r4
80007622:	f1 38 00 30 	ld.ub	r8,r8[48]
80007626:	eb d5 c1 04 	bfextu	r5,r5,0x8,0x4
8000762a:	e2 18 00 f0 	andl	r8,0xf0,COH
8000762e:	f1 e5 10 05 	or	r5,r8,r5
80007632:	ee 04 00 04 	add	r4,r7,r4
80007636:	e9 65 00 30 	st.b	r4[48],r5
			fs->wflag = 1;
8000763a:	30 18       	mov	r8,1
8000763c:	ae c8       	st.b	r7[0x4],r8
			break;
8000763e:	d8 22       	popm	r4-r7,pc

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
80007640:	a9 8b       	lsr	r11,0x8
80007642:	78 88       	ld.w	r8,r12[0x20]
80007644:	10 0b       	add	r11,r8
80007646:	f0 1f 00 1d 	mcall	800076b8 <put_fat+0x130>
			if (res != FR_OK) break;
8000764a:	c3 51       	brne	800076b4 <put_fat+0x12c>
			p = &fs->win[clst * 2 % SS(fs)];
8000764c:	a1 76       	lsl	r6,0x1
8000764e:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			ST_WORD(p, (WORD)val);
80007652:	ee 06 00 08 	add	r8,r7,r6
80007656:	f1 65 00 30 	st.b	r8[48],r5
8000765a:	10 96       	mov	r6,r8
8000765c:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
80007660:	f1 65 00 31 	st.b	r8[49],r5
			fs->wflag = 1;
80007664:	30 18       	mov	r8,1
80007666:	ae c8       	st.b	r7[0x4],r8
			break;
80007668:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
8000766a:	a7 9b       	lsr	r11,0x7
8000766c:	78 88       	ld.w	r8,r12[0x20]
8000766e:	10 0b       	add	r11,r8
80007670:	f0 1f 00 12 	mcall	800076b8 <put_fat+0x130>
			if (res != FR_OK) break;
80007674:	c2 01       	brne	800076b4 <put_fat+0x12c>
			p = &fs->win[clst * 4 % SS(fs)];
80007676:	a3 66       	lsl	r6,0x2
80007678:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
8000767c:	ec c8 ff d0 	sub	r8,r6,-48
80007680:	ee 08 00 08 	add	r8,r7,r8
			val |= LD_DWORD(p) & 0xF0000000;
80007684:	f0 c9 ff fd 	sub	r9,r8,-3
80007688:	13 8a       	ld.ub	r10,r9[0x0]
8000768a:	b9 6a       	lsl	r10,0x18
8000768c:	ee 06 00 06 	add	r6,r7,r6
80007690:	e6 1a f0 00 	andh	r10,0xf000,COH
80007694:	f5 e5 10 05 	or	r5,r10,r5
			ST_DWORD(p, val);
80007698:	ed 65 00 30 	st.b	r6[48],r5
8000769c:	f5 d5 c1 08 	bfextu	r10,r5,0x8,0x8
800076a0:	b0 9a       	st.b	r8[0x1],r10
800076a2:	ea 0a 16 10 	lsr	r10,r5,0x10
800076a6:	b0 aa       	st.b	r8[0x2],r10
800076a8:	b9 85       	lsr	r5,0x18
800076aa:	b2 85       	st.b	r9[0x0],r5
			fs->wflag = 1;
800076ac:	30 18       	mov	r8,1
800076ae:	ae c8       	st.b	r7[0x4],r8
			break;
800076b0:	d8 22       	popm	r4-r7,pc
800076b2:	30 2c       	mov	r12,2
			res = FR_INT_ERR;
		}
	}

	return res;
}
800076b4:	d8 22       	popm	r4-r7,pc
800076b6:	00 00       	add	r0,r0
800076b8:	80 00       	ld.sh	r0,r0[0x0]
800076ba:	6f 94       	ld.w	r4,r7[0x64]

800076bc <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
800076bc:	d4 21       	pushm	r4-r7,lr
800076be:	18 97       	mov	r7,r12
800076c0:	16 96       	mov	r6,r11
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
800076c2:	58 1b       	cp.w	r11,1
800076c4:	e0 88 00 69 	brls	80007796 <get_fat+0xda>
800076c8:	78 58       	ld.w	r8,r12[0x14]
800076ca:	10 3b       	cp.w	r11,r8
800076cc:	c6 52       	brcc	80007796 <get_fat+0xda>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
800076ce:	19 88       	ld.ub	r8,r12[0x0]
800076d0:	30 29       	mov	r9,2
800076d2:	f2 08 18 00 	cp.b	r8,r9
800076d6:	c3 10       	breq	80007738 <get_fat+0x7c>
800076d8:	30 39       	mov	r9,3
800076da:	f2 08 18 00 	cp.b	r8,r9
800076de:	c4 00       	breq	8000775e <get_fat+0xa2>
800076e0:	30 19       	mov	r9,1
800076e2:	f2 08 18 00 	cp.b	r8,r9
800076e6:	c5 81       	brne	80007796 <get_fat+0xda>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
800076e8:	f6 05 16 01 	lsr	r5,r11,0x1
800076ec:	16 05       	add	r5,r11
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
800076ee:	ea 0b 16 09 	lsr	r11,r5,0x9
800076f2:	78 88       	ld.w	r8,r12[0x20]
800076f4:	10 0b       	add	r11,r8
800076f6:	f0 1f 00 2a 	mcall	8000779c <get_fat+0xe0>
800076fa:	c4 f1       	brne	80007798 <get_fat+0xdc>
			wc = fs->win[bc++ % SS(fs)];
800076fc:	f1 d5 c0 09 	bfextu	r8,r5,0x0,0x9
80007700:	ee 08 00 08 	add	r8,r7,r8
80007704:	f1 34 00 30 	ld.ub	r4,r8[48]
80007708:	2f f5       	sub	r5,-1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
8000770a:	ea 0b 16 09 	lsr	r11,r5,0x9
8000770e:	6e 88       	ld.w	r8,r7[0x20]
80007710:	10 0b       	add	r11,r8
80007712:	0e 9c       	mov	r12,r7
80007714:	f0 1f 00 22 	mcall	8000779c <get_fat+0xe0>
80007718:	c4 01       	brne	80007798 <get_fat+0xdc>
			wc |= fs->win[bc % SS(fs)] << 8;
8000771a:	eb d5 c0 09 	bfextu	r5,r5,0x0,0x9
8000771e:	0a 07       	add	r7,r5
80007720:	ef 3c 00 30 	ld.ub	r12,r7[48]
80007724:	e9 ec 10 8c 	or	r12,r4,r12<<0x8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
80007728:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
8000772c:	c0 30       	breq	80007732 <get_fat+0x76>
8000772e:	a5 8c       	lsr	r12,0x4
80007730:	d8 22       	popm	r4-r7,pc
80007732:	f9 dc c0 0c 	bfextu	r12,r12,0x0,0xc
80007736:	d8 22       	popm	r4-r7,pc
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
80007738:	a9 8b       	lsr	r11,0x8
8000773a:	78 88       	ld.w	r8,r12[0x20]
8000773c:	10 0b       	add	r11,r8
8000773e:	f0 1f 00 18 	mcall	8000779c <get_fat+0xe0>
80007742:	c2 b1       	brne	80007798 <get_fat+0xdc>
			p = &fs->win[clst * 2 % SS(fs)];
80007744:	a1 76       	lsl	r6,0x1
80007746:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			val = LD_WORD(p);
8000774a:	ee 06 00 08 	add	r8,r7,r6
8000774e:	10 97       	mov	r7,r8
80007750:	f1 3c 00 31 	ld.ub	r12,r8[49]
80007754:	f1 38 00 30 	ld.ub	r8,r8[48]
80007758:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
			break;
8000775c:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
8000775e:	a7 9b       	lsr	r11,0x7
80007760:	78 88       	ld.w	r8,r12[0x20]
80007762:	10 0b       	add	r11,r8
80007764:	f0 1f 00 0e 	mcall	8000779c <get_fat+0xe0>
80007768:	c1 81       	brne	80007798 <get_fat+0xdc>
			p = &fs->win[clst * 4 % SS(fs)];
8000776a:	a3 66       	lsl	r6,0x2
8000776c:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
80007770:	ec c8 ff d0 	sub	r8,r6,-48
80007774:	ee 08 00 08 	add	r8,r7,r8
			val = LD_DWORD(p) & 0x0FFFFFFF;
80007778:	11 a9       	ld.ub	r9,r8[0x2]
8000777a:	11 bc       	ld.ub	r12,r8[0x3]
8000777c:	b9 6c       	lsl	r12,0x18
8000777e:	f9 e9 11 0c 	or	r12,r12,r9<<0x10
80007782:	11 98       	ld.ub	r8,r8[0x1]
80007784:	f9 e8 10 8c 	or	r12,r12,r8<<0x8
80007788:	0c 07       	add	r7,r6
8000778a:	ef 38 00 30 	ld.ub	r8,r7[48]
8000778e:	10 4c       	or	r12,r8
80007790:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c
			break;
80007794:	d8 22       	popm	r4-r7,pc
80007796:	da 2a       	popm	r4-r7,pc,r12=1
80007798:	dc 2a       	popm	r4-r7,pc,r12=-1
8000779a:	00 00       	add	r0,r0
8000779c:	80 00       	ld.sh	r0,r0[0x0]
8000779e:	6f 94       	ld.w	r4,r7[0x64]

800077a0 <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
800077a0:	eb cd 40 f8 	pushm	r3-r7,lr
800077a4:	18 96       	mov	r6,r12
800077a6:	16 95       	mov	r5,r11
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
800077a8:	ac 3b       	st.h	r6[0x6],r11
	clst = dp->sclust;		/* Table start cluster (0:root) */
800077aa:	78 28       	ld.w	r8,r12[0x8]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
800077ac:	58 18       	cp.w	r8,1
800077ae:	c4 c0       	breq	80007846 <dir_sdi+0xa6>
800077b0:	78 09       	ld.w	r9,r12[0x0]
800077b2:	72 5a       	ld.w	r10,r9[0x14]
800077b4:	14 38       	cp.w	r8,r10
800077b6:	c4 82       	brcc	80007846 <dir_sdi+0xa6>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
800077b8:	58 08       	cp.w	r8,0
800077ba:	c0 f1       	brne	800077d8 <dir_sdi+0x38>
800077bc:	13 8b       	ld.ub	r11,r9[0x0]
800077be:	30 3a       	mov	r10,3
800077c0:	f4 0b 18 00 	cp.b	r11,r10
800077c4:	c0 41       	brne	800077cc <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
800077c6:	72 97       	ld.w	r7,r9[0x24]

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
800077c8:	58 07       	cp.w	r7,0
800077ca:	c0 81       	brne	800077da <dir_sdi+0x3a>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
800077cc:	92 ca       	ld.uh	r10,r9[0x8]
800077ce:	14 35       	cp.w	r5,r10
800077d0:	c3 b2       	brcc	80007846 <dir_sdi+0xa6>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
800077d2:	72 9c       	ld.w	r12,r9[0x24]
800077d4:	10 97       	mov	r7,r8
800077d6:	c2 68       	rjmp	80007822 <dir_sdi+0x82>
800077d8:	10 97       	mov	r7,r8
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
800077da:	13 a4       	ld.ub	r4,r9[0x2]
800077dc:	a5 64       	lsl	r4,0x4
		while (idx >= ic) {	/* Follow cluster chain */
800077de:	08 35       	cp.w	r5,r4
800077e0:	c1 d3       	brcs	8000781a <dir_sdi+0x7a>
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
800077e2:	e8 03 11 00 	rsub	r3,r4,0
800077e6:	08 15       	sub	r5,r4
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
800077e8:	0e 9b       	mov	r11,r7
800077ea:	6c 0c       	ld.w	r12,r6[0x0]
800077ec:	f0 1f 00 18 	mcall	8000784c <dir_sdi+0xac>
800077f0:	18 97       	mov	r7,r12
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
800077f2:	5b fc       	cp.w	r12,-1
800077f4:	c0 31       	brne	800077fa <dir_sdi+0x5a>
800077f6:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
800077fa:	58 1c       	cp.w	r12,1
800077fc:	e0 88 00 25 	brls	80007846 <dir_sdi+0xa6>
80007800:	6c 08       	ld.w	r8,r6[0x0]
80007802:	70 58       	ld.w	r8,r8[0x14]
80007804:	10 3c       	cp.w	r12,r8
80007806:	c2 02       	brcc	80007846 <dir_sdi+0xa6>
80007808:	ea 03 00 08 	add	r8,r5,r3
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
8000780c:	f0 04 00 09 	add	r9,r8,r4
80007810:	12 34       	cp.w	r4,r9
80007812:	e0 8b 00 04 	brhi	8000781a <dir_sdi+0x7a>
80007816:	10 95       	mov	r5,r8
80007818:	ce 8b       	rjmp	800077e8 <dir_sdi+0x48>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
8000781a:	0e 9b       	mov	r11,r7
8000781c:	6c 0c       	ld.w	r12,r6[0x0]
8000781e:	f0 1f 00 0d 	mcall	80007850 <dir_sdi+0xb0>
	}
	dp->clust = clst;	/* Current cluster# */
80007822:	8d 37       	st.w	r6[0xc],r7
	if (!sect) return FR_INT_ERR;
80007824:	58 0c       	cp.w	r12,0
80007826:	c1 00       	breq	80007846 <dir_sdi+0xa6>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
80007828:	ea 08 16 04 	lsr	r8,r5,0x4
8000782c:	f0 0c 00 0c 	add	r12,r8,r12
80007830:	8d 4c       	st.w	r6[0x10],r12
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
80007832:	6c 08       	ld.w	r8,r6[0x0]
80007834:	2d 08       	sub	r8,-48
80007836:	eb d5 c0 04 	bfextu	r5,r5,0x0,0x4
8000783a:	a5 75       	lsl	r5,0x5
8000783c:	f0 05 00 05 	add	r5,r8,r5
80007840:	8d 55       	st.w	r6[0x14],r5
80007842:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0

	return FR_OK;
80007846:	30 2c       	mov	r12,2
}
80007848:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000784c:	80 00       	ld.sh	r0,r0[0x0]
8000784e:	76 bc       	ld.w	r12,r11[0x2c]
80007850:	80 00       	ld.sh	r0,r0[0x0]
80007852:	66 48       	ld.w	r8,r3[0x10]

80007854 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
80007854:	eb cd 40 fc 	pushm	r2-r7,lr
80007858:	18 96       	mov	r6,r12
8000785a:	16 92       	mov	r2,r11
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
8000785c:	58 0b       	cp.w	r11,0
8000785e:	c0 81       	brne	8000786e <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
80007860:	78 35       	ld.w	r5,r12[0xc]
		if (!scl || scl >= fs->n_fatent) scl = 1;
80007862:	58 05       	cp.w	r5,0
80007864:	c1 10       	breq	80007886 <create_chain+0x32>
80007866:	78 58       	ld.w	r8,r12[0x14]
80007868:	10 35       	cp.w	r5,r8
8000786a:	c0 e2       	brcc	80007886 <create_chain+0x32>
8000786c:	c0 e8       	rjmp	80007888 <create_chain+0x34>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
8000786e:	f0 1f 00 2c 	mcall	8000791c <create_chain+0xc8>
		if (cs < 2) return 1;			/* Invalid value */
80007872:	58 1c       	cp.w	r12,1
80007874:	e0 88 00 4f 	brls	80007912 <create_chain+0xbe>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
80007878:	5b fc       	cp.w	r12,-1
8000787a:	c4 f0       	breq	80007918 <create_chain+0xc4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
8000787c:	6c 58       	ld.w	r8,r6[0x14]
8000787e:	10 3c       	cp.w	r12,r8
80007880:	c4 c3       	brcs	80007918 <create_chain+0xc4>
80007882:	04 95       	mov	r5,r2
80007884:	c0 28       	rjmp	80007888 <create_chain+0x34>
80007886:	30 15       	mov	r5,1
80007888:	0a 97       	mov	r7,r5
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
8000788a:	30 23       	mov	r3,2
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
8000788c:	30 04       	mov	r4,0
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
8000788e:	2f f7       	sub	r7,-1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
80007890:	6c 58       	ld.w	r8,r6[0x14]
80007892:	10 37       	cp.w	r7,r8
80007894:	c0 53       	brcs	8000789e <create_chain+0x4a>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
80007896:	58 15       	cp.w	r5,1
80007898:	e0 88 00 3f 	brls	80007916 <create_chain+0xc2>
8000789c:	06 97       	mov	r7,r3
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
8000789e:	0e 9b       	mov	r11,r7
800078a0:	0c 9c       	mov	r12,r6
800078a2:	f0 1f 00 1f 	mcall	8000791c <create_chain+0xc8>
		if (cs == 0) break;				/* Found a free cluster */
800078a6:	c0 d0       	breq	800078c0 <create_chain+0x6c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
800078a8:	5b fc       	cp.w	r12,-1
800078aa:	5f 09       	sreq	r9
800078ac:	58 1c       	cp.w	r12,1
800078ae:	5f 08       	sreq	r8
800078b0:	f3 e8 10 08 	or	r8,r9,r8
800078b4:	e8 08 18 00 	cp.b	r8,r4
800078b8:	c3 01       	brne	80007918 <create_chain+0xc4>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
800078ba:	0a 37       	cp.w	r7,r5
800078bc:	ce 91       	brne	8000788e <create_chain+0x3a>
800078be:	c2 c8       	rjmp	80007916 <create_chain+0xc2>
800078c0:	0e 95       	mov	r5,r7
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
800078c2:	e0 6a ff ff 	mov	r10,65535
800078c6:	ea 1a 0f ff 	orh	r10,0xfff
800078ca:	0e 9b       	mov	r11,r7
800078cc:	0c 9c       	mov	r12,r6
800078ce:	f0 1f 00 15 	mcall	80007920 <create_chain+0xcc>
	if (res == FR_OK && clst != 0) {
800078d2:	5f 09       	sreq	r9
800078d4:	58 02       	cp.w	r2,0
800078d6:	5f 18       	srne	r8
800078d8:	f3 e8 00 08 	and	r8,r9,r8
800078dc:	c0 60       	breq	800078e8 <create_chain+0x94>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
800078de:	0e 9a       	mov	r10,r7
800078e0:	04 9b       	mov	r11,r2
800078e2:	0c 9c       	mov	r12,r6
800078e4:	f0 1f 00 0f 	mcall	80007920 <create_chain+0xcc>
	}
	if (res == FR_OK) {
800078e8:	58 0c       	cp.w	r12,0
800078ea:	c1 01       	brne	8000790a <create_chain+0xb6>
		fs->last_clust = ncl;			/* Update FSINFO */
800078ec:	8d 35       	st.w	r6[0xc],r5
		if (fs->free_clust != 0xFFFFFFFF) {
800078ee:	6c 48       	ld.w	r8,r6[0x10]
800078f0:	5b f8       	cp.w	r8,-1
800078f2:	c0 41       	brne	800078fa <create_chain+0xa6>
800078f4:	0e 9c       	mov	r12,r7
800078f6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fs->free_clust--;
800078fa:	20 18       	sub	r8,1
800078fc:	8d 48       	st.w	r6[0x10],r8
			fs->fsi_flag |= 1;
800078fe:	0d d8       	ld.ub	r8,r6[0x5]
80007900:	a1 a8       	sbr	r8,0x0
80007902:	ac d8       	st.b	r6[0x5],r8
80007904:	0e 9c       	mov	r12,r7
80007906:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
8000790a:	58 1c       	cp.w	r12,1
8000790c:	c0 31       	brne	80007912 <create_chain+0xbe>
8000790e:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
80007912:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80007916:	30 0c       	mov	r12,0
	}

	return ncl;		/* Return new cluster number or error code */
}
80007918:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000791c:	80 00       	ld.sh	r0,r0[0x0]
8000791e:	76 bc       	ld.w	r12,r11[0x2c]
80007920:	80 00       	ld.sh	r0,r0[0x0]
80007922:	75 88       	ld.w	r8,r10[0x60]

80007924 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
80007924:	eb cd 40 fc 	pushm	r2-r7,lr
80007928:	18 97       	mov	r7,r12
8000792a:	16 96       	mov	r6,r11
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
8000792c:	98 b5       	ld.uh	r5,r12[0x6]
8000792e:	2f f5       	sub	r5,-1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
80007930:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80007934:	c6 d0       	breq	80007a0e <dir_next+0xea>
80007936:	78 48       	ld.w	r8,r12[0x10]
80007938:	58 08       	cp.w	r8,0
8000793a:	c6 a0       	breq	80007a0e <dir_next+0xea>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
8000793c:	e9 d5 c0 04 	bfextu	r4,r5,0x0,0x4
80007940:	c5 e1       	brne	800079fc <dir_next+0xd8>
		dp->sect++;					/* Next sector */
80007942:	2f f8       	sub	r8,-1
80007944:	99 48       	st.w	r12[0x10],r8

		if (!dp->clust) {		/* Static table */
80007946:	78 3b       	ld.w	r11,r12[0xc]
80007948:	58 0b       	cp.w	r11,0
8000794a:	c0 61       	brne	80007956 <dir_next+0x32>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
8000794c:	78 08       	ld.w	r8,r12[0x0]
8000794e:	90 c8       	ld.uh	r8,r8[0x8]
80007950:	10 35       	cp.w	r5,r8
80007952:	c5 53       	brcs	800079fc <dir_next+0xd8>
80007954:	c5 d8       	rjmp	80007a0e <dir_next+0xea>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
80007956:	78 0c       	ld.w	r12,r12[0x0]
80007958:	19 a8       	ld.ub	r8,r12[0x2]
8000795a:	20 18       	sub	r8,1
8000795c:	f1 e5 02 48 	and	r8,r8,r5>>0x4
80007960:	c4 e1       	brne	800079fc <dir_next+0xd8>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
80007962:	f0 1f 00 30 	mcall	80007a20 <dir_next+0xfc>
80007966:	18 93       	mov	r3,r12
				if (clst <= 1) return FR_INT_ERR;
80007968:	58 1c       	cp.w	r12,1
8000796a:	e0 88 00 55 	brls	80007a14 <dir_next+0xf0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
8000796e:	5b fc       	cp.w	r12,-1
80007970:	c5 50       	breq	80007a1a <dir_next+0xf6>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
80007972:	6e 0c       	ld.w	r12,r7[0x0]
80007974:	78 58       	ld.w	r8,r12[0x14]
80007976:	10 33       	cp.w	r3,r8
80007978:	c3 c3       	brcs	800079f0 <dir_next+0xcc>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
8000797a:	58 06       	cp.w	r6,0
8000797c:	c4 90       	breq	80007a0e <dir_next+0xea>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
8000797e:	6e 3b       	ld.w	r11,r7[0xc]
80007980:	f0 1f 00 29 	mcall	80007a24 <dir_next+0x100>
80007984:	18 93       	mov	r3,r12
					if (clst == 0) return FR_DENIED;			/* No free cluster */
80007986:	c0 41       	brne	8000798e <dir_next+0x6a>
80007988:	30 7c       	mov	r12,7
8000798a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
					if (clst == 1) return FR_INT_ERR;
8000798e:	58 1c       	cp.w	r12,1
80007990:	c4 20       	breq	80007a14 <dir_next+0xf0>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
80007992:	5b fc       	cp.w	r12,-1
80007994:	c4 30       	breq	80007a1a <dir_next+0xf6>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
80007996:	6e 0c       	ld.w	r12,r7[0x0]
80007998:	f0 1f 00 24 	mcall	80007a28 <dir_next+0x104>
8000799c:	c3 f1       	brne	80007a1a <dir_next+0xf6>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
8000799e:	6e 0c       	ld.w	r12,r7[0x0]
800079a0:	e0 6a 02 00 	mov	r10,512
800079a4:	30 0b       	mov	r11,0
800079a6:	2d 0c       	sub	r12,-48
800079a8:	f0 1f 00 21 	mcall	80007a2c <dir_next+0x108>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
800079ac:	6e 06       	ld.w	r6,r7[0x0]
800079ae:	06 9b       	mov	r11,r3
800079b0:	0c 9c       	mov	r12,r6
800079b2:	f0 1f 00 20 	mcall	80007a30 <dir_next+0x10c>
800079b6:	8d bc       	st.w	r6[0x2c],r12
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
800079b8:	6e 08       	ld.w	r8,r7[0x0]
800079ba:	11 aa       	ld.ub	r10,r8[0x2]
800079bc:	30 09       	mov	r9,0
800079be:	f2 0a 18 00 	cp.b	r10,r9
800079c2:	c0 31       	brne	800079c8 <dir_next+0xa4>
800079c4:	30 06       	mov	r6,0
800079c6:	c1 28       	rjmp	800079ea <dir_next+0xc6>
800079c8:	30 06       	mov	r6,0
						dp->fs->wflag = 1;
800079ca:	30 12       	mov	r2,1
800079cc:	b0 c2       	st.b	r8[0x4],r2
						if (sync_window(dp->fs)) return FR_DISK_ERR;
800079ce:	6e 0c       	ld.w	r12,r7[0x0]
800079d0:	f0 1f 00 16 	mcall	80007a28 <dir_next+0x104>
800079d4:	c2 31       	brne	80007a1a <dir_next+0xf6>
						dp->fs->winsect++;
800079d6:	6e 08       	ld.w	r8,r7[0x0]
800079d8:	70 b9       	ld.w	r9,r8[0x2c]
800079da:	2f f9       	sub	r9,-1
800079dc:	91 b9       	st.w	r8[0x2c],r9
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
800079de:	2f f6       	sub	r6,-1
800079e0:	6e 08       	ld.w	r8,r7[0x0]
800079e2:	11 a9       	ld.ub	r9,r8[0x2]
800079e4:	0c 39       	cp.w	r9,r6
800079e6:	fe 9b ff f3 	brhi	800079cc <dir_next+0xa8>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
800079ea:	70 b9       	ld.w	r9,r8[0x2c]
800079ec:	0c 19       	sub	r9,r6
800079ee:	91 b9       	st.w	r8[0x2c],r9
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
800079f0:	8f 33       	st.w	r7[0xc],r3
				dp->sect = clust2sect(dp->fs, clst);
800079f2:	06 9b       	mov	r11,r3
800079f4:	6e 0c       	ld.w	r12,r7[0x0]
800079f6:	f0 1f 00 0f 	mcall	80007a30 <dir_next+0x10c>
800079fa:	8f 4c       	st.w	r7[0x10],r12
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
800079fc:	ae 35       	st.h	r7[0x6],r5
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
800079fe:	6e 08       	ld.w	r8,r7[0x0]
80007a00:	2d 08       	sub	r8,-48
80007a02:	a5 74       	lsl	r4,0x5
80007a04:	f0 04 00 04 	add	r4,r8,r4
80007a08:	8f 54       	st.w	r7[0x14],r4
80007a0a:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

	return FR_OK;
80007a0e:	30 4c       	mov	r12,4
80007a10:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007a14:	30 2c       	mov	r12,2
80007a16:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007a1a:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80007a1e:	00 00       	add	r0,r0
80007a20:	80 00       	ld.sh	r0,r0[0x0]
80007a22:	76 bc       	ld.w	r12,r11[0x2c]
80007a24:	80 00       	ld.sh	r0,r0[0x0]
80007a26:	78 54       	ld.w	r4,r12[0x14]
80007a28:	80 00       	ld.sh	r0,r0[0x0]
80007a2a:	67 9c       	ld.w	r12,r3[0x64]
80007a2c:	80 00       	ld.sh	r0,r0[0x0]
80007a2e:	66 22       	ld.w	r2,r3[0x8]
80007a30:	80 00       	ld.sh	r0,r0[0x0]
80007a32:	66 48       	ld.w	r8,r3[0x10]

80007a34 <remove_chain>:
static
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
80007a34:	d4 21       	pushm	r4-r7,lr
80007a36:	18 97       	mov	r7,r12
80007a38:	16 95       	mov	r5,r11
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
80007a3a:	58 1b       	cp.w	r11,1
80007a3c:	e0 88 00 26 	brls	80007a88 <remove_chain+0x54>
80007a40:	78 58       	ld.w	r8,r12[0x14]
80007a42:	10 3b       	cp.w	r11,r8
80007a44:	c2 22       	brcc	80007a88 <remove_chain+0x54>
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
80007a46:	30 04       	mov	r4,0
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
80007a48:	0a 9b       	mov	r11,r5
80007a4a:	0e 9c       	mov	r12,r7
80007a4c:	f0 1f 00 10 	mcall	80007a8c <remove_chain+0x58>
80007a50:	18 96       	mov	r6,r12
			if (nxt == 0) break;				/* Empty cluster? */
80007a52:	c0 21       	brne	80007a56 <remove_chain+0x22>
80007a54:	d8 2a       	popm	r4-r7,pc,r12=0
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
80007a56:	58 1c       	cp.w	r12,1
80007a58:	c1 80       	breq	80007a88 <remove_chain+0x54>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
80007a5a:	5b fc       	cp.w	r12,-1
80007a5c:	c0 21       	brne	80007a60 <remove_chain+0x2c>
80007a5e:	da 2a       	popm	r4-r7,pc,r12=1
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
80007a60:	08 9a       	mov	r10,r4
80007a62:	0a 9b       	mov	r11,r5
80007a64:	0e 9c       	mov	r12,r7
80007a66:	f0 1f 00 0b 	mcall	80007a90 <remove_chain+0x5c>
			if (res != FR_OK) break;
80007a6a:	c1 01       	brne	80007a8a <remove_chain+0x56>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
80007a6c:	6e 48       	ld.w	r8,r7[0x10]
80007a6e:	5b f8       	cp.w	r8,-1
80007a70:	c0 60       	breq	80007a7c <remove_chain+0x48>
				fs->free_clust++;
80007a72:	2f f8       	sub	r8,-1
80007a74:	8f 48       	st.w	r7[0x10],r8
				fs->fsi_flag |= 1;
80007a76:	0f d8       	ld.ub	r8,r7[0x5]
80007a78:	a1 a8       	sbr	r8,0x0
80007a7a:	ae d8       	st.b	r7[0x5],r8
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
80007a7c:	6e 58       	ld.w	r8,r7[0x14]
80007a7e:	0c 38       	cp.w	r8,r6
80007a80:	e0 88 00 05 	brls	80007a8a <remove_chain+0x56>
80007a84:	0c 95       	mov	r5,r6
80007a86:	ce 1b       	rjmp	80007a48 <remove_chain+0x14>
80007a88:	30 2c       	mov	r12,2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
80007a8a:	d8 22       	popm	r4-r7,pc
80007a8c:	80 00       	ld.sh	r0,r0[0x0]
80007a8e:	76 bc       	ld.w	r12,r11[0x2c]
80007a90:	80 00       	ld.sh	r0,r0[0x0]
80007a92:	75 88       	ld.w	r8,r10[0x60]

80007a94 <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
80007a94:	eb cd 40 fe 	pushm	r1-r7,lr
80007a98:	18 97       	mov	r7,r12
80007a9a:	16 91       	mov	r1,r11
80007a9c:	30 4c       	mov	r12,4
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007a9e:	3e 56       	mov	r6,-27
80007aa0:	32 e5       	mov	r5,46
80007aa2:	30 04       	mov	r4,0
80007aa4:	30 f2       	mov	r2,15
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007aa6:	30 03       	mov	r3,0
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007aa8:	c2 58       	rjmp	80007af2 <dir_read+0x5e>
		res = move_window(dp->fs, dp->sect);
80007aaa:	6e 0c       	ld.w	r12,r7[0x0]
80007aac:	f0 1f 00 17 	mcall	80007b08 <dir_read+0x74>
		if (res != FR_OK) break;
80007ab0:	c2 61       	brne	80007afc <dir_read+0x68>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
80007ab2:	6e 59       	ld.w	r9,r7[0x14]
		c = dir[DIR_Name];
80007ab4:	13 88       	ld.ub	r8,r9[0x0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007ab6:	58 08       	cp.w	r8,0
80007ab8:	c2 60       	breq	80007b04 <dir_read+0x70>
		a = dir[DIR_Attr] & AM_MASK;
80007aba:	f3 3a 00 0b 	ld.ub	r10,r9[11]
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007abe:	ec 08 18 00 	cp.b	r8,r6
80007ac2:	5f 19       	srne	r9
80007ac4:	ea 08 18 00 	cp.b	r8,r5
80007ac8:	5f 18       	srne	r8
80007aca:	f3 e8 00 08 	and	r8,r9,r8
80007ace:	e8 08 18 00 	cp.b	r8,r4
80007ad2:	c0 b0       	breq	80007ae8 <dir_read+0x54>
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		a = dir[DIR_Attr] & AM_MASK;
80007ad4:	f1 da c0 06 	bfextu	r8,r10,0x0,0x6
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007ad8:	e4 08 18 00 	cp.b	r8,r2
80007adc:	c0 60       	breq	80007ae8 <dir_read+0x54>
80007ade:	a5 d8       	cbr	r8,0x5
80007ae0:	58 88       	cp.w	r8,8
80007ae2:	5f 08       	sreq	r8
80007ae4:	02 38       	cp.w	r8,r1
80007ae6:	c0 d0       	breq	80007b00 <dir_read+0x6c>
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007ae8:	06 9b       	mov	r11,r3
80007aea:	0e 9c       	mov	r12,r7
80007aec:	f0 1f 00 08 	mcall	80007b0c <dir_read+0x78>
		if (res != FR_OK) break;
80007af0:	c0 61       	brne	80007afc <dir_read+0x68>
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007af2:	6e 4b       	ld.w	r11,r7[0x10]
80007af4:	58 0b       	cp.w	r11,0
80007af6:	cd a1       	brne	80007aaa <dir_read+0x16>
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007af8:	58 0c       	cp.w	r12,0
80007afa:	c0 30       	breq	80007b00 <dir_read+0x6c>
80007afc:	30 08       	mov	r8,0
80007afe:	8f 48       	st.w	r7[0x10],r8

	return res;
}
80007b00:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007b04:	30 4c       	mov	r12,4
80007b06:	cf bb       	rjmp	80007afc <dir_read+0x68>
80007b08:	80 00       	ld.sh	r0,r0[0x0]
80007b0a:	6f 94       	ld.w	r4,r7[0x64]
80007b0c:	80 00       	ld.sh	r0,r0[0x0]
80007b0e:	79 24       	ld.w	r4,r12[0x48]

80007b10 <f_getlabel>:
FRESULT f_getlabel (
	const TCHAR* path,	/* Path name of the logical drive number */
	TCHAR* label,		/* Pointer to a buffer to return the volume label */
	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
)
{
80007b10:	d4 21       	pushm	r4-r7,lr
80007b12:	20 9d       	sub	sp,36
80007b14:	50 0c       	stdsp	sp[0x0],r12
80007b16:	16 96       	mov	r6,r11
80007b18:	14 95       	mov	r5,r10
	WCHAR w;
#endif


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
80007b1a:	30 0a       	mov	r10,0
80007b1c:	1a 9b       	mov	r11,sp
80007b1e:	fa cc ff fc 	sub	r12,sp,-4
80007b22:	f0 1f 00 30 	mcall	80007be0 <f_getlabel+0xd0>
80007b26:	18 97       	mov	r7,r12

	/* Get volume label */
	if (res == FR_OK && label) {
80007b28:	5f 09       	sreq	r9
80007b2a:	58 06       	cp.w	r6,0
80007b2c:	5f 18       	srne	r8
80007b2e:	f3 e8 00 08 	and	r8,r9,r8
80007b32:	c2 d0       	breq	80007b8c <f_getlabel+0x7c>
		dj.sclust = 0;					/* Open root directory */
80007b34:	30 0b       	mov	r11,0
80007b36:	50 3b       	stdsp	sp[0xc],r11
		res = dir_sdi(&dj, 0);
80007b38:	fa cc ff fc 	sub	r12,sp,-4
80007b3c:	f0 1f 00 2a 	mcall	80007be4 <f_getlabel+0xd4>
80007b40:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007b42:	c4 c1       	brne	80007bda <f_getlabel+0xca>
			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007b44:	30 1b       	mov	r11,1
80007b46:	fa cc ff fc 	sub	r12,sp,-4
80007b4a:	f0 1f 00 28 	mcall	80007be8 <f_getlabel+0xd8>
80007b4e:	18 94       	mov	r4,r12
			if (res == FR_OK) {			/* A volume label is exist */
80007b50:	c1 81       	brne	80007b80 <f_getlabel+0x70>
					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
						w = w << 8 | dj.dir[i++];
					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
				} while (j < 11);
#else
				mem_cpy(label, dj.dir, 11);
80007b52:	30 ba       	mov	r10,11
80007b54:	40 6b       	lddsp	r11,sp[0x18]
80007b56:	0c 9c       	mov	r12,r6
80007b58:	f0 1f 00 25 	mcall	80007bec <f_getlabel+0xdc>
#endif
				j = 11;
				do {
					label[j] = 0;
80007b5c:	30 08       	mov	r8,0
80007b5e:	ed 68 00 0b 	st.b	r6[11],r8
80007b62:	2f 66       	sub	r6,-10
80007b64:	30 b8       	mov	r8,11
					if (!j) break;
				} while (label[--j] == ' ');
80007b66:	32 0a       	mov	r10,32
#else
				mem_cpy(label, dj.dir, 11);
#endif
				j = 11;
				do {
					label[j] = 0;
80007b68:	30 0b       	mov	r11,0
80007b6a:	c0 58       	rjmp	80007b74 <f_getlabel+0x64>
80007b6c:	ac 8b       	st.b	r6[0x0],r11
80007b6e:	20 16       	sub	r6,1
					if (!j) break;
80007b70:	58 08       	cp.w	r8,0
80007b72:	c0 c0       	breq	80007b8a <f_getlabel+0x7a>
				} while (label[--j] == ' ');
80007b74:	20 18       	sub	r8,1
80007b76:	0d 89       	ld.ub	r9,r6[0x0]
80007b78:	f4 09 18 00 	cp.b	r9,r10
80007b7c:	cf 80       	breq	80007b6c <f_getlabel+0x5c>
80007b7e:	c0 68       	rjmp	80007b8a <f_getlabel+0x7a>
			}
			if (res == FR_NO_FILE) {	/* No label, return nul string */
80007b80:	58 4c       	cp.w	r12,4
80007b82:	c0 41       	brne	80007b8a <f_getlabel+0x7a>
				label[0] = 0;
80007b84:	30 08       	mov	r8,0
80007b86:	ac 88       	st.b	r6[0x0],r8
80007b88:	c0 28       	rjmp	80007b8c <f_getlabel+0x7c>
80007b8a:	08 97       	mov	r7,r4
			}
		}
	}

	/* Get volume serial number */
	if (res == FR_OK && vsn) {
80007b8c:	58 07       	cp.w	r7,0
80007b8e:	5f 09       	sreq	r9
80007b90:	58 05       	cp.w	r5,0
80007b92:	5f 18       	srne	r8
80007b94:	f3 e8 00 08 	and	r8,r9,r8
80007b98:	c2 10       	breq	80007bda <f_getlabel+0xca>
		res = move_window(dj.fs, dj.fs->volbase);
80007b9a:	40 1c       	lddsp	r12,sp[0x4]
80007b9c:	78 7b       	ld.w	r11,r12[0x1c]
80007b9e:	f0 1f 00 15 	mcall	80007bf0 <f_getlabel+0xe0>
80007ba2:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007ba4:	c1 b1       	brne	80007bda <f_getlabel+0xca>
			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
80007ba6:	40 19       	lddsp	r9,sp[0x4]
80007ba8:	13 8a       	ld.ub	r10,r9[0x0]
80007baa:	30 38       	mov	r8,3
80007bac:	f0 0a 18 00 	cp.b	r10,r8
80007bb0:	f9 b8 00 43 	moveq	r8,67
80007bb4:	f9 b8 01 27 	movne	r8,39
			*vsn = LD_DWORD(&dj.fs->win[i]);
80007bb8:	f2 08 00 08 	add	r8,r9,r8
80007bbc:	f1 3a 00 33 	ld.ub	r10,r8[51]
80007bc0:	f1 39 00 32 	ld.ub	r9,r8[50]
80007bc4:	b1 69       	lsl	r9,0x10
80007bc6:	f3 ea 11 89 	or	r9,r9,r10<<0x18
80007bca:	f1 3a 00 30 	ld.ub	r10,r8[48]
80007bce:	14 49       	or	r9,r10
80007bd0:	f1 38 00 31 	ld.ub	r8,r8[49]
80007bd4:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80007bd8:	8b 08       	st.w	r5[0x0],r8
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007bda:	0e 9c       	mov	r12,r7
80007bdc:	2f 7d       	sub	sp,-36
80007bde:	d8 22       	popm	r4-r7,pc
80007be0:	80 00       	ld.sh	r0,r0[0x0]
80007be2:	70 70       	ld.w	r0,r8[0x1c]
80007be4:	80 00       	ld.sh	r0,r0[0x0]
80007be6:	77 a0       	ld.w	r0,r11[0x68]
80007be8:	80 00       	ld.sh	r0,r0[0x0]
80007bea:	7a 94       	ld.w	r4,sp[0x24]
80007bec:	80 00       	ld.sh	r0,r0[0x0]
80007bee:	66 0c       	ld.w	r12,r3[0x0]
80007bf0:	80 00       	ld.sh	r0,r0[0x0]
80007bf2:	6f 94       	ld.w	r4,r7[0x64]

80007bf4 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate (1-21) */
)
{
80007bf4:	eb cd 40 fe 	pushm	r1-r7,lr
80007bf8:	18 97       	mov	r7,r12
80007bfa:	16 92       	mov	r2,r11
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
80007bfc:	30 0b       	mov	r11,0
80007bfe:	f0 1f 00 15 	mcall	80007c50 <dir_alloc+0x5c>
	if (res == FR_OK) {
80007c02:	c2 21       	brne	80007c46 <dir_alloc+0x52>
80007c04:	30 05       	mov	r5,0
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007c06:	3e 54       	mov	r4,-27
80007c08:	30 06       	mov	r6,0
80007c0a:	0a 91       	mov	r1,r5
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007c0c:	30 13       	mov	r3,1

	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
80007c0e:	6e 4b       	ld.w	r11,r7[0x10]
80007c10:	6e 0c       	ld.w	r12,r7[0x0]
80007c12:	f0 1f 00 11 	mcall	80007c54 <dir_alloc+0x60>
			if (res != FR_OK) break;
80007c16:	c1 81       	brne	80007c46 <dir_alloc+0x52>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007c18:	6e 58       	ld.w	r8,r7[0x14]
80007c1a:	11 88       	ld.ub	r8,r8[0x0]
80007c1c:	e8 08 18 00 	cp.b	r8,r4
80007c20:	5f 09       	sreq	r9
80007c22:	ec 08 18 00 	cp.b	r8,r6
80007c26:	5f 08       	sreq	r8
80007c28:	f3 e8 10 08 	or	r8,r9,r8
80007c2c:	ec 08 18 00 	cp.b	r8,r6
80007c30:	c0 31       	brne	80007c36 <dir_alloc+0x42>
80007c32:	02 95       	mov	r5,r1
80007c34:	c0 48       	rjmp	80007c3c <dir_alloc+0x48>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
80007c36:	2f f5       	sub	r5,-1
80007c38:	04 35       	cp.w	r5,r2
80007c3a:	c0 90       	breq	80007c4c <dir_alloc+0x58>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007c3c:	06 9b       	mov	r11,r3
80007c3e:	0e 9c       	mov	r12,r7
80007c40:	f0 1f 00 06 	mcall	80007c58 <dir_alloc+0x64>
		} while (res == FR_OK);
80007c44:	ce 50       	breq	80007c0e <dir_alloc+0x1a>
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
80007c46:	58 4c       	cp.w	r12,4
80007c48:	f9 bc 00 07 	moveq	r12,7
	return res;
}
80007c4c:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80007c50:	80 00       	ld.sh	r0,r0[0x0]
80007c52:	77 a0       	ld.w	r0,r11[0x68]
80007c54:	80 00       	ld.sh	r0,r0[0x0]
80007c56:	6f 94       	ld.w	r4,r7[0x64]
80007c58:	80 00       	ld.sh	r0,r0[0x0]
80007c5a:	79 24       	ld.w	r4,r12[0x48]

80007c5c <f_setlabel>:
/*-----------------------------------------------------------------------*/

FRESULT f_setlabel (
	const TCHAR* label	/* Pointer to the volume label to set */
)
{
80007c5c:	d4 31       	pushm	r0-r7,lr
80007c5e:	20 cd       	sub	sp,48
80007c60:	50 0c       	stdsp	sp[0x0],r12
	WCHAR w;
	DWORD tm;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &label, 1);
80007c62:	30 1a       	mov	r10,1
80007c64:	1a 9b       	mov	r11,sp
80007c66:	fa cc ff f0 	sub	r12,sp,-16
80007c6a:	f0 1f 00 8b 	mcall	80007e94 <f_setlabel+0x238>
	if (res) LEAVE_FF(dj.fs, res);
80007c6e:	e0 81 01 08 	brne	80007e7e <f_setlabel+0x222>

	/* Create a volume label in directory form */
	vn[0] = 0;
80007c72:	30 08       	mov	r8,0
80007c74:	ba c8       	st.b	sp[0x4],r8
	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
80007c76:	40 0a       	lddsp	r10,sp[0x0]
80007c78:	15 89       	ld.ub	r9,r10[0x0]
80007c7a:	f0 09 18 00 	cp.b	r9,r8
80007c7e:	e0 80 00 90 	breq	80007d9e <f_setlabel+0x142>
80007c82:	30 07       	mov	r7,0
80007c84:	2f f7       	sub	r7,-1
80007c86:	f4 07 07 09 	ld.ub	r9,r10[r7]
80007c8a:	f0 09 18 00 	cp.b	r9,r8
80007c8e:	cf b1       	brne	80007c84 <f_setlabel+0x28>
80007c90:	0e 98       	mov	r8,r7
	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
80007c92:	58 07       	cp.w	r7,0
80007c94:	e0 80 00 85 	breq	80007d9e <f_setlabel+0x142>
80007c98:	f4 07 00 09 	add	r9,r10,r7
80007c9c:	f3 3b ff ff 	ld.ub	r11,r9[-1]
80007ca0:	32 09       	mov	r9,32
80007ca2:	f2 0b 18 00 	cp.b	r11,r9
80007ca6:	e0 81 00 ee 	brne	80007e82 <f_setlabel+0x226>
80007caa:	20 28       	sub	r8,2
80007cac:	f4 08 00 08 	add	r8,r10,r8
80007cb0:	12 9a       	mov	r10,r9
80007cb2:	20 17       	sub	r7,1
80007cb4:	c7 50       	breq	80007d9e <f_setlabel+0x142>
80007cb6:	11 89       	ld.ub	r9,r8[0x0]
80007cb8:	20 18       	sub	r8,1
80007cba:	f4 09 18 00 	cp.b	r9,r10
80007cbe:	cf a0       	breq	80007cb2 <f_setlabel+0x56>
80007cc0:	ce 18       	rjmp	80007e82 <f_setlabel+0x226>
		i = j = 0;
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
80007cc2:	40 08       	lddsp	r8,sp[0x0]
80007cc4:	f0 04 07 06 	ld.ub	r6,r8[r4]
80007cc8:	2f f4       	sub	r4,-1
			if (IsDBCS1(w))
80007cca:	ec c9 ff 81 	sub	r9,r6,-127
80007cce:	e4 09 18 00 	cp.b	r9,r2
80007cd2:	e0 8b 00 24 	brhi	80007d1a <f_setlabel+0xbe>
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007cd6:	58 95       	cp.w	r5,9
80007cd8:	5f 8a       	srls	r10
80007cda:	0e 34       	cp.w	r4,r7
80007cdc:	5f 39       	srlo	r9
80007cde:	f5 e9 00 09 	and	r9,r10,r9
80007ce2:	e2 09 18 00 	cp.b	r9,r1
80007ce6:	e0 80 00 c9 	breq	80007e78 <f_setlabel+0x21c>
80007cea:	f0 04 07 08 	ld.ub	r8,r8[r4]
80007cee:	f0 c9 00 40 	sub	r9,r8,64
80007cf2:	33 eb       	mov	r11,62
80007cf4:	f6 09 18 00 	cp.b	r9,r11
80007cf8:	5f 8a       	srls	r10
80007cfa:	f0 c9 00 80 	sub	r9,r8,128
80007cfe:	37 eb       	mov	r11,126
80007d00:	f6 09 18 00 	cp.b	r9,r11
80007d04:	5f 89       	srls	r9
80007d06:	f5 e9 10 09 	or	r9,r10,r9
80007d0a:	e2 09 18 00 	cp.b	r9,r1
80007d0e:	e0 80 00 b5 	breq	80007e78 <f_setlabel+0x21c>
80007d12:	f1 e6 10 86 	or	r6,r8,r6<<0x8
80007d16:	5c 86       	casts.h	r6
80007d18:	2f f4       	sub	r4,-1
#if _USE_LFN
			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
#else
			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
80007d1a:	ec c8 00 61 	sub	r8,r6,97
80007d1e:	31 9a       	mov	r10,25
80007d20:	f4 08 19 00 	cp.h	r8,r10
80007d24:	e0 8b 00 04 	brhi	80007d2c <f_setlabel+0xd0>
80007d28:	22 06       	sub	r6,32
80007d2a:	5c 86       	casts.h	r6
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007d2c:	58 06       	cp.w	r6,0
80007d2e:	e0 80 00 a5 	breq	80007e78 <f_setlabel+0x21c>
80007d32:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007d36:	00 9c       	mov	r12,r0
80007d38:	f0 1f 00 58 	mcall	80007e98 <f_setlabel+0x23c>
80007d3c:	e0 81 00 9e 	brne	80007e78 <f_setlabel+0x21c>
80007d40:	ec 03 19 00 	cp.h	r3,r6
80007d44:	f9 b8 03 0a 	movlo	r8,10
80007d48:	f9 b8 02 0b 	movhs	r8,11
80007d4c:	10 35       	cp.w	r5,r8
80007d4e:	e0 82 00 95 	brhs	80007e78 <f_setlabel+0x21c>
				LEAVE_FF(dj.fs, FR_INVALID_NAME);
			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
80007d52:	e6 06 19 00 	cp.h	r6,r3
80007d56:	e0 88 00 0a 	brls	80007d6a <f_setlabel+0x10e>
80007d5a:	fa c8 ff d0 	sub	r8,sp,-48
80007d5e:	0a 08       	add	r8,r5
80007d60:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
80007d64:	f1 69 ff d4 	st.b	r8[-44],r9
80007d68:	2f f5       	sub	r5,-1
			vn[j++] = (BYTE)w;
80007d6a:	fa c8 ff d0 	sub	r8,sp,-48
80007d6e:	0a 08       	add	r8,r5
80007d70:	f1 66 ff d4 	st.b	r8[-44],r6
80007d74:	2f f5       	sub	r5,-1
		} while (i < sl);
80007d76:	0e 34       	cp.w	r4,r7
80007d78:	ca 53       	brcs	80007cc2 <f_setlabel+0x66>
		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
80007d7a:	58 a5       	cp.w	r5,10
80007d7c:	e0 8b 00 0c 	brhi	80007d94 <f_setlabel+0x138>
80007d80:	fa c9 ff fc 	sub	r9,sp,-4
80007d84:	f2 05 00 08 	add	r8,r9,r5
80007d88:	32 09       	mov	r9,32
80007d8a:	10 c9       	st.b	r8++,r9
80007d8c:	2f f5       	sub	r5,-1
80007d8e:	58 a5       	cp.w	r5,10
80007d90:	fe 98 ff fd 	brls	80007d8a <f_setlabel+0x12e>
		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
80007d94:	3e 58       	mov	r8,-27
80007d96:	1b c9       	ld.ub	r9,sp[0x4]
80007d98:	f0 09 18 00 	cp.b	r9,r8
80007d9c:	c6 e0       	breq	80007e78 <f_setlabel+0x21c>
	}

	/* Set volume label */
	dj.sclust = 0;					/* Open root directory */
80007d9e:	30 0b       	mov	r11,0
80007da0:	50 6b       	stdsp	sp[0x18],r11
	res = dir_sdi(&dj, 0);
80007da2:	fa cc ff f0 	sub	r12,sp,-16
80007da6:	f0 1f 00 3e 	mcall	80007e9c <f_setlabel+0x240>
80007daa:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007dac:	c6 81       	brne	80007e7c <f_setlabel+0x220>
		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007dae:	30 1b       	mov	r11,1
80007db0:	fa cc ff f0 	sub	r12,sp,-16
80007db4:	f0 1f 00 3b 	mcall	80007ea0 <f_setlabel+0x244>
		if (res == FR_OK) {			/* A volume label is found */
80007db8:	c2 a1       	brne	80007e0c <f_setlabel+0x1b0>
			if (vn[0]) {
80007dba:	30 08       	mov	r8,0
80007dbc:	1b c9       	ld.ub	r9,sp[0x4]
80007dbe:	f0 09 18 00 	cp.b	r9,r8
80007dc2:	c1 b0       	breq	80007df8 <f_setlabel+0x19c>
				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
80007dc4:	30 ba       	mov	r10,11
80007dc6:	fa cb ff fc 	sub	r11,sp,-4
80007dca:	40 9c       	lddsp	r12,sp[0x24]
80007dcc:	f0 1f 00 36 	mcall	80007ea4 <f_setlabel+0x248>
				tm = GET_FATTIME();
80007dd0:	f0 1f 00 36 	mcall	80007ea8 <f_setlabel+0x24c>
				ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007dd4:	40 98       	lddsp	r8,sp[0x24]
80007dd6:	f1 6c 00 16 	st.b	r8[22],r12
80007dda:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007dde:	40 98       	lddsp	r8,sp[0x24]
80007de0:	f1 69 00 17 	st.b	r8[23],r9
80007de4:	f8 09 16 10 	lsr	r9,r12,0x10
80007de8:	40 98       	lddsp	r8,sp[0x24]
80007dea:	f1 69 00 18 	st.b	r8[24],r9
80007dee:	b9 8c       	lsr	r12,0x18
80007df0:	40 98       	lddsp	r8,sp[0x24]
80007df2:	f1 6c 00 19 	st.b	r8[25],r12
80007df6:	c0 48       	rjmp	80007dfe <f_setlabel+0x1a2>
			} else {
				dj.dir[0] = DDEM;			/* Remove the volume label */
80007df8:	3e 59       	mov	r9,-27
80007dfa:	40 98       	lddsp	r8,sp[0x24]
80007dfc:	b0 89       	st.b	r8[0x0],r9
			}
			dj.fs->wflag = 1;
80007dfe:	30 19       	mov	r9,1
80007e00:	40 48       	lddsp	r8,sp[0x10]
80007e02:	b0 c9       	st.b	r8[0x4],r9
			res = sync_fs(dj.fs);
80007e04:	40 4c       	lddsp	r12,sp[0x10]
80007e06:	f0 1f 00 2a 	mcall	80007eac <f_setlabel+0x250>
80007e0a:	c3 a8       	rjmp	80007e7e <f_setlabel+0x222>
		} else {					/* No volume label is found or error */
			if (res == FR_NO_FILE) {
80007e0c:	58 4c       	cp.w	r12,4
80007e0e:	c3 81       	brne	80007e7e <f_setlabel+0x222>
				res = FR_OK;
				if (vn[0]) {				/* Create volume label as new */
80007e10:	30 08       	mov	r8,0
80007e12:	1b c9       	ld.ub	r9,sp[0x4]
80007e14:	f0 09 18 00 	cp.b	r9,r8
80007e18:	c3 20       	breq	80007e7c <f_setlabel+0x220>
					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
80007e1a:	30 1b       	mov	r11,1
80007e1c:	fa cc ff f0 	sub	r12,sp,-16
80007e20:	f0 1f 00 24 	mcall	80007eb0 <f_setlabel+0x254>
					if (res == FR_OK) {
80007e24:	c2 d1       	brne	80007e7e <f_setlabel+0x222>
						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
80007e26:	32 0a       	mov	r10,32
80007e28:	30 0b       	mov	r11,0
80007e2a:	40 9c       	lddsp	r12,sp[0x24]
80007e2c:	f0 1f 00 22 	mcall	80007eb4 <f_setlabel+0x258>
						mem_cpy(dj.dir, vn, 11);
80007e30:	30 ba       	mov	r10,11
80007e32:	fa cb ff fc 	sub	r11,sp,-4
80007e36:	40 9c       	lddsp	r12,sp[0x24]
80007e38:	f0 1f 00 1b 	mcall	80007ea4 <f_setlabel+0x248>
						dj.dir[DIR_Attr] = AM_VOL;
80007e3c:	30 89       	mov	r9,8
80007e3e:	40 98       	lddsp	r8,sp[0x24]
80007e40:	f1 69 00 0b 	st.b	r8[11],r9
						tm = GET_FATTIME();
80007e44:	f0 1f 00 19 	mcall	80007ea8 <f_setlabel+0x24c>
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007e48:	40 98       	lddsp	r8,sp[0x24]
80007e4a:	f1 6c 00 16 	st.b	r8[22],r12
80007e4e:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007e52:	40 98       	lddsp	r8,sp[0x24]
80007e54:	f1 69 00 17 	st.b	r8[23],r9
80007e58:	f8 09 16 10 	lsr	r9,r12,0x10
80007e5c:	40 98       	lddsp	r8,sp[0x24]
80007e5e:	f1 69 00 18 	st.b	r8[24],r9
80007e62:	b9 8c       	lsr	r12,0x18
80007e64:	40 98       	lddsp	r8,sp[0x24]
80007e66:	f1 6c 00 19 	st.b	r8[25],r12
						dj.fs->wflag = 1;
80007e6a:	30 19       	mov	r9,1
80007e6c:	40 48       	lddsp	r8,sp[0x10]
80007e6e:	b0 c9       	st.b	r8[0x4],r9
						res = sync_fs(dj.fs);
80007e70:	40 4c       	lddsp	r12,sp[0x10]
80007e72:	f0 1f 00 0f 	mcall	80007eac <f_setlabel+0x250>
80007e76:	c0 48       	rjmp	80007e7e <f_setlabel+0x222>
80007e78:	30 6c       	mov	r12,6
80007e7a:	c0 28       	rjmp	80007e7e <f_setlabel+0x222>
80007e7c:	0e 9c       	mov	r12,r7
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007e7e:	2f 4d       	sub	sp,-48
80007e80:	d8 32       	popm	r0-r7,pc
						mem_cpy(dj.dir, vn, 11);
						dj.dir[DIR_Attr] = AM_VOL;
						tm = GET_FATTIME();
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
						dj.fs->wflag = 1;
						res = sync_fs(dj.fs);
80007e82:	30 05       	mov	r5,0
80007e84:	0a 94       	mov	r4,r5
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
			if (IsDBCS1(w))
80007e86:	37 d2       	mov	r2,125
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007e88:	30 01       	mov	r1,0
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007e8a:	48 c0       	lddpc	r0,80007eb8 <f_setlabel+0x25c>
80007e8c:	e0 63 00 ff 	mov	r3,255
80007e90:	c1 9b       	rjmp	80007cc2 <f_setlabel+0x66>
80007e92:	00 00       	add	r0,r0
80007e94:	80 00       	ld.sh	r0,r0[0x0]
80007e96:	70 70       	ld.w	r0,r8[0x1c]
80007e98:	80 00       	ld.sh	r0,r0[0x0]
80007e9a:	66 2e       	ld.w	lr,r3[0x8]
80007e9c:	80 00       	ld.sh	r0,r0[0x0]
80007e9e:	77 a0       	ld.w	r0,r11[0x68]
80007ea0:	80 00       	ld.sh	r0,r0[0x0]
80007ea2:	7a 94       	ld.w	r4,sp[0x24]
80007ea4:	80 00       	ld.sh	r0,r0[0x0]
80007ea6:	66 0c       	ld.w	r12,r3[0x0]
80007ea8:	80 00       	ld.sh	r0,r0[0x0]
80007eaa:	65 48       	ld.w	r8,r2[0x50]
80007eac:	80 00       	ld.sh	r0,r0[0x0]
80007eae:	68 00       	ld.w	r0,r4[0x0]
80007eb0:	80 00       	ld.sh	r0,r0[0x0]
80007eb2:	7b f4       	ld.w	r4,sp[0x7c]
80007eb4:	80 00       	ld.sh	r0,r0[0x0]
80007eb6:	66 22       	ld.w	r2,r3[0x8]
80007eb8:	80 01       	ld.sh	r1,r0[0x0]
80007eba:	95 a0       	st.w	r10[0x28],r0

80007ebc <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
80007ebc:	eb cd 40 c0 	pushm	r6-r7,lr
80007ec0:	18 96       	mov	r6,r12
				res = dir_next(dp, 0);	/* Next entry */
			} while (res == FR_OK && --nent);
		}
	}
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
80007ec2:	30 1b       	mov	r11,1
80007ec4:	f0 1f 00 0d 	mcall	80007ef8 <dir_register+0x3c>
80007ec8:	18 97       	mov	r7,r12
#endif

	if (res == FR_OK) {				/* Set SFN entry */
80007eca:	c1 41       	brne	80007ef2 <dir_register+0x36>
		res = move_window(dp->fs, dp->sect);
80007ecc:	6c 4b       	ld.w	r11,r6[0x10]
80007ece:	6c 0c       	ld.w	r12,r6[0x0]
80007ed0:	f0 1f 00 0b 	mcall	80007efc <dir_register+0x40>
80007ed4:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007ed6:	c0 e1       	brne	80007ef2 <dir_register+0x36>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
80007ed8:	32 0a       	mov	r10,32
80007eda:	30 0b       	mov	r11,0
80007edc:	6c 5c       	ld.w	r12,r6[0x14]
80007ede:	f0 1f 00 09 	mcall	80007f00 <dir_register+0x44>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
80007ee2:	30 ba       	mov	r10,11
80007ee4:	6c 6b       	ld.w	r11,r6[0x18]
80007ee6:	6c 5c       	ld.w	r12,r6[0x14]
80007ee8:	f0 1f 00 07 	mcall	80007f04 <dir_register+0x48>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dp->fs->wflag = 1;
80007eec:	6c 08       	ld.w	r8,r6[0x0]
80007eee:	30 19       	mov	r9,1
80007ef0:	b0 c9       	st.b	r8[0x4],r9
		}
	}

	return res;
}
80007ef2:	0e 9c       	mov	r12,r7
80007ef4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007ef8:	80 00       	ld.sh	r0,r0[0x0]
80007efa:	7b f4       	ld.w	r4,sp[0x7c]
80007efc:	80 00       	ld.sh	r0,r0[0x0]
80007efe:	6f 94       	ld.w	r4,r7[0x64]
80007f00:	80 00       	ld.sh	r0,r0[0x0]
80007f02:	66 22       	ld.w	r2,r3[0x8]
80007f04:	80 00       	ld.sh	r0,r0[0x0]
80007f06:	66 0c       	ld.w	r12,r3[0x0]

80007f08 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
80007f08:	d4 31       	pushm	r0-r7,lr
80007f0a:	20 3d       	sub	sp,12
80007f0c:	18 92       	mov	r2,r12
80007f0e:	16 97       	mov	r7,r11
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
80007f10:	17 88       	ld.ub	r8,r11[0x0]
80007f12:	32 f9       	mov	r9,47
80007f14:	f2 08 18 00 	cp.b	r8,r9
80007f18:	5f 09       	sreq	r9
80007f1a:	35 ca       	mov	r10,92
80007f1c:	f4 08 18 00 	cp.b	r8,r10
80007f20:	5f 08       	sreq	r8
80007f22:	f3 e8 10 08 	or	r8,r9,r8
		path++;
80007f26:	f7 b7 01 ff 	subne	r7,-1
	dp->sclust = 0;							/* Always start from the root directory */
80007f2a:	30 08       	mov	r8,0
80007f2c:	99 28       	st.w	r12[0x8],r8
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
80007f2e:	0f 89       	ld.ub	r9,r7[0x0]
80007f30:	31 f8       	mov	r8,31
80007f32:	f0 09 18 00 	cp.b	r9,r8
80007f36:	e0 8b 00 08 	brhi	80007f46 <follow_path+0x3e>
		res = dir_sdi(dp, 0);
80007f3a:	30 0b       	mov	r11,0
80007f3c:	f0 1f 00 93 	mcall	80008188 <follow_path+0x280>
		dp->dir = 0;
80007f40:	30 08       	mov	r8,0
80007f42:	85 58       	st.w	r2[0x14],r8
80007f44:	c1 49       	rjmp	8000816c <follow_path+0x264>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
80007f46:	32 f4       	mov	r4,47
80007f48:	35 c3       	mov	r3,92
80007f4a:	30 06       	mov	r6,0
80007f4c:	0f 88       	ld.ub	r8,r7[0x0]
80007f4e:	e8 08 18 00 	cp.b	r8,r4
80007f52:	5f 09       	sreq	r9
80007f54:	e6 08 18 00 	cp.b	r8,r3
80007f58:	5f 08       	sreq	r8
80007f5a:	f3 e8 10 08 	or	r8,r9,r8
80007f5e:	ec 08 18 00 	cp.b	r8,r6
80007f62:	c0 e0       	breq	80007f7e <follow_path+0x76>
80007f64:	2f f7       	sub	r7,-1
80007f66:	0f 88       	ld.ub	r8,r7[0x0]
80007f68:	e8 08 18 00 	cp.b	r8,r4
80007f6c:	5f 09       	sreq	r9
80007f6e:	e6 08 18 00 	cp.b	r8,r3
80007f72:	5f 08       	sreq	r8
80007f74:	f3 e8 10 08 	or	r8,r9,r8
80007f78:	ec 08 18 00 	cp.b	r8,r6
80007f7c:	cf 41       	brne	80007f64 <follow_path+0x5c>
	sfn = dp->fn;
80007f7e:	64 6a       	ld.w	r10,r2[0x18]
80007f80:	50 2a       	stdsp	sp[0x8],r10
	mem_set(sfn, ' ', 11);
80007f82:	30 ba       	mov	r10,11
80007f84:	32 0b       	mov	r11,32
80007f86:	40 2c       	lddsp	r12,sp[0x8]
80007f88:	f0 1f 00 81 	mcall	8000818c <follow_path+0x284>
80007f8c:	30 89       	mov	r9,8
80007f8e:	50 09       	stdsp	sp[0x0],r9
80007f90:	30 08       	mov	r8,0
80007f92:	50 18       	stdsp	sp[0x4],r8
80007f94:	10 90       	mov	r0,r8
80007f96:	10 91       	mov	r1,r8
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007f98:	0e 95       	mov	r5,r7
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
80007f9a:	ea 01 07 07 	ld.ub	r7,r5[r1]
80007f9e:	2f f1       	sub	r1,-1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
80007fa0:	32 09       	mov	r9,32
80007fa2:	f2 07 18 00 	cp.b	r7,r9
80007fa6:	5f 88       	srls	r8
80007fa8:	e8 07 18 00 	cp.b	r7,r4
80007fac:	5f 09       	sreq	r9
80007fae:	f1 e9 10 09 	or	r9,r8,r9
80007fb2:	ec 09 18 00 	cp.b	r9,r6
80007fb6:	c7 51       	brne	800080a0 <follow_path+0x198>
80007fb8:	e6 07 18 00 	cp.b	r7,r3
80007fbc:	c7 20       	breq	800080a0 <follow_path+0x198>
		if (c == '.' || i >= ni) {
80007fbe:	32 e8       	mov	r8,46
80007fc0:	f0 07 18 00 	cp.b	r7,r8
80007fc4:	5f 09       	sreq	r9
80007fc6:	40 0a       	lddsp	r10,sp[0x0]
80007fc8:	14 30       	cp.w	r0,r10
80007fca:	5f 28       	srhs	r8
80007fcc:	f3 e8 10 08 	or	r8,r9,r8
80007fd0:	ec 08 18 00 	cp.b	r8,r6
80007fd4:	c1 50       	breq	80007ffe <follow_path+0xf6>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
80007fd6:	58 8a       	cp.w	r10,8
80007fd8:	5f 19       	srne	r9
80007fda:	32 e8       	mov	r8,46
80007fdc:	f0 07 18 00 	cp.b	r7,r8
80007fe0:	5f 18       	srne	r8
80007fe2:	f3 e8 10 08 	or	r8,r9,r8
80007fe6:	ec 08 18 00 	cp.b	r8,r6
80007fea:	e0 81 00 be 	brne	80008166 <follow_path+0x25e>
			i = 8; ni = 11;
			b <<= 2; continue;
80007fee:	40 18       	lddsp	r8,sp[0x4]
80007ff0:	a3 68       	lsl	r8,0x2
80007ff2:	5c 58       	castu.b	r8
80007ff4:	50 18       	stdsp	sp[0x4],r8
80007ff6:	30 ba       	mov	r10,11
80007ff8:	50 0a       	stdsp	sp[0x0],r10
80007ffa:	30 80       	mov	r0,8
80007ffc:	cc fb       	rjmp	80007f9a <follow_path+0x92>
		}
		if (c >= 0x80) {				/* Extended character? */
80007ffe:	ec 07 18 00 	cp.b	r7,r6
80008002:	c0 54       	brge	8000800c <follow_path+0x104>
			b |= 3;						/* Eliminate NT flag */
80008004:	40 18       	lddsp	r8,sp[0x4]
80008006:	e8 18 00 03 	orl	r8,0x3
8000800a:	50 18       	stdsp	sp[0x4],r8
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
8000800c:	0e 98       	mov	r8,r7
8000800e:	28 18       	sub	r8,-127
80008010:	37 da       	mov	r10,125
80008012:	f4 08 18 00 	cp.b	r8,r10
80008016:	e0 8b 00 23 	brhi	8000805c <follow_path+0x154>
			d = (BYTE)p[si++];			/* Get 2nd byte */
8000801a:	ea 01 07 08 	ld.ub	r8,r5[r1]
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
8000801e:	f0 c9 00 40 	sub	r9,r8,64
80008022:	33 ea       	mov	r10,62
80008024:	f4 09 18 00 	cp.b	r9,r10
80008028:	5f b9       	srhi	r9
8000802a:	f0 cb 00 80 	sub	r11,r8,128
8000802e:	37 ea       	mov	r10,126
80008030:	f4 0b 18 00 	cp.b	r11,r10
80008034:	5f ba       	srhi	r10
80008036:	14 69       	and	r9,r10
80008038:	ec 09 18 00 	cp.b	r9,r6
8000803c:	e0 81 00 95 	brne	80008166 <follow_path+0x25e>
80008040:	40 09       	lddsp	r9,sp[0x0]
80008042:	20 19       	sub	r9,1
80008044:	12 30       	cp.w	r0,r9
80008046:	e0 82 00 90 	brhs	80008166 <follow_path+0x25e>
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
8000804a:	2f f1       	sub	r1,-1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
8000804c:	40 29       	lddsp	r9,sp[0x8]
8000804e:	f2 00 0b 07 	st.b	r9[r0],r7
80008052:	2f f0       	sub	r0,-1
			sfn[i++] = d;
80008054:	f2 00 0b 08 	st.b	r9[r0],r8
80008058:	2f f0       	sub	r0,-1
8000805a:	ca 0b       	rjmp	80007f9a <follow_path+0x92>
		} else {						/* SBC */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
8000805c:	0e 9b       	mov	r11,r7
8000805e:	4c dc       	lddpc	r12,80008190 <follow_path+0x288>
80008060:	f0 1f 00 4d 	mcall	80008194 <follow_path+0x28c>
80008064:	e0 81 00 81 	brne	80008166 <follow_path+0x25e>
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
80008068:	0e 98       	mov	r8,r7
8000806a:	24 18       	sub	r8,65
8000806c:	31 99       	mov	r9,25
8000806e:	f2 08 18 00 	cp.b	r8,r9
80008072:	e0 8b 00 06 	brhi	8000807e <follow_path+0x176>
				b |= 2;
80008076:	40 18       	lddsp	r8,sp[0x4]
80008078:	a1 b8       	sbr	r8,0x1
8000807a:	50 18       	stdsp	sp[0x4],r8
8000807c:	c0 d8       	rjmp	80008096 <follow_path+0x18e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
8000807e:	0e 98       	mov	r8,r7
80008080:	26 18       	sub	r8,97
80008082:	31 9a       	mov	r10,25
80008084:	f4 08 18 00 	cp.b	r8,r10
80008088:	e0 8b 00 07 	brhi	80008096 <follow_path+0x18e>
					b |= 1; c -= 0x20;
8000808c:	40 19       	lddsp	r9,sp[0x4]
8000808e:	a1 a9       	sbr	r9,0x0
80008090:	50 19       	stdsp	sp[0x4],r9
80008092:	22 07       	sub	r7,32
80008094:	5c 57       	castu.b	r7
				}
			}
			sfn[i++] = c;
80008096:	40 28       	lddsp	r8,sp[0x8]
80008098:	f0 00 0b 07 	st.b	r8[r0],r7
8000809c:	2f f0       	sub	r0,-1
8000809e:	c7 eb       	rjmp	80007f9a <follow_path+0x92>
800080a0:	0a 97       	mov	r7,r5
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
800080a2:	58 08       	cp.w	r8,0
800080a4:	f9 b8 01 04 	movne	r8,4
800080a8:	f9 b8 00 00 	moveq	r8,0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
800080ac:	58 00       	cp.w	r0,0
800080ae:	c5 c0       	breq	80008166 <follow_path+0x25e>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
800080b0:	40 29       	lddsp	r9,sp[0x8]
800080b2:	13 8a       	ld.ub	r10,r9[0x0]
800080b4:	3e 59       	mov	r9,-27
800080b6:	f2 0a 18 00 	cp.b	r10,r9
800080ba:	f9 b9 00 05 	moveq	r9,5
800080be:	fb fa 00 02 	ld.weq	r10,sp[0x8]
800080c2:	f5 f9 0e 00 	st.beq	r10[0x0],r9

	if (ni == 8) b <<= 2;
800080c6:	40 09       	lddsp	r9,sp[0x0]
800080c8:	58 89       	cp.w	r9,8
800080ca:	c0 51       	brne	800080d4 <follow_path+0x1cc>
800080cc:	40 19       	lddsp	r9,sp[0x4]
800080ce:	a3 69       	lsl	r9,0x2
800080d0:	5c 59       	castu.b	r9
800080d2:	50 19       	stdsp	sp[0x4],r9
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
800080d4:	40 19       	lddsp	r9,sp[0x4]
800080d6:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
800080da:	58 1a       	cp.w	r10,1
800080dc:	c0 21       	brne	800080e0 <follow_path+0x1d8>
800080de:	a5 a8       	sbr	r8,0x4
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
800080e0:	e2 19 00 0c 	andl	r9,0xc,COH
800080e4:	58 49       	cp.w	r9,4
800080e6:	c0 21       	brne	800080ea <follow_path+0x1e2>
800080e8:	a3 b8       	sbr	r8,0x3

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
800080ea:	40 2a       	lddsp	r10,sp[0x8]
800080ec:	f5 68 00 0b 	st.b	r10[11],r8
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
800080f0:	30 0b       	mov	r11,0
800080f2:	04 9c       	mov	r12,r2
800080f4:	f0 1f 00 25 	mcall	80008188 <follow_path+0x280>
	if (res != FR_OK) return res;
800080f8:	c2 11       	brne	8000813a <follow_path+0x232>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
800080fa:	64 4b       	ld.w	r11,r2[0x10]
800080fc:	64 0c       	ld.w	r12,r2[0x0]
800080fe:	f0 1f 00 27 	mcall	80008198 <follow_path+0x290>
		if (res != FR_OK) break;
80008102:	c1 c1       	brne	8000813a <follow_path+0x232>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
80008104:	64 59       	ld.w	r9,r2[0x14]
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80008106:	13 88       	ld.ub	r8,r9[0x0]
80008108:	ec 08 18 00 	cp.b	r8,r6
8000810c:	c3 90       	breq	8000817e <follow_path+0x276>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
8000810e:	f3 38 00 0b 	ld.ub	r8,r9[11]
80008112:	e2 18 00 08 	andl	r8,0x8,COH
80008116:	c0 d1       	brne	80008130 <follow_path+0x228>
80008118:	64 65       	ld.w	r5,r2[0x18]
8000811a:	c0 48       	rjmp	80008122 <follow_path+0x21a>
8000811c:	2f f8       	sub	r8,-1
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
8000811e:	58 b8       	cp.w	r8,11
80008120:	c2 80       	breq	80008170 <follow_path+0x268>
80008122:	f2 08 07 0b 	ld.ub	r11,r9[r8]
80008126:	ea 08 07 0a 	ld.ub	r10,r5[r8]
8000812a:	f4 0b 18 00 	cp.b	r11,r10
8000812e:	cf 70       	breq	8000811c <follow_path+0x214>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
80008130:	30 0b       	mov	r11,0
80008132:	04 9c       	mov	r12,r2
80008134:	f0 1f 00 1a 	mcall	8000819c <follow_path+0x294>
	} while (res == FR_OK);
80008138:	ce 10       	breq	800080fa <follow_path+0x1f2>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
8000813a:	64 68       	ld.w	r8,r2[0x18]
8000813c:	f1 38 00 0b 	ld.ub	r8,r8[11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
80008140:	58 4c       	cp.w	r12,4
80008142:	c1 51       	brne	8000816c <follow_path+0x264>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
80008144:	e2 18 00 04 	andl	r8,0x4,COH
80008148:	c1 10       	breq	8000816a <follow_path+0x262>
8000814a:	30 4c       	mov	r12,4
8000814c:	c1 08       	rjmp	8000816c <follow_path+0x264>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
8000814e:	64 5b       	ld.w	r11,r2[0x14]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
80008150:	f7 38 00 0b 	ld.ub	r8,r11[11]
80008154:	e2 18 00 10 	andl	r8,0x10,COH
80008158:	c0 90       	breq	8000816a <follow_path+0x262>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
8000815a:	02 07       	add	r7,r1
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
8000815c:	64 0c       	ld.w	r12,r2[0x0]
8000815e:	f0 1f 00 11 	mcall	800081a0 <follow_path+0x298>
80008162:	85 2c       	st.w	r2[0x8],r12
		}
80008164:	cf 4a       	rjmp	80007f4c <follow_path+0x44>
80008166:	30 6c       	mov	r12,6
80008168:	c0 28       	rjmp	8000816c <follow_path+0x264>
8000816a:	30 5c       	mov	r12,5
	}

	return res;
}
8000816c:	2f dd       	sub	sp,-12
8000816e:	d8 32       	popm	r0-r7,pc
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
80008170:	64 68       	ld.w	r8,r2[0x18]
80008172:	f1 38 00 0b 	ld.ub	r8,r8[11]
80008176:	e2 18 00 04 	andl	r8,0x4,COH
8000817a:	ce a0       	breq	8000814e <follow_path+0x246>
8000817c:	cf 8b       	rjmp	8000816c <follow_path+0x264>
8000817e:	64 68       	ld.w	r8,r2[0x18]
80008180:	f1 38 00 0b 	ld.ub	r8,r8[11]
80008184:	ce 0b       	rjmp	80008144 <follow_path+0x23c>
80008186:	00 00       	add	r0,r0
80008188:	80 00       	ld.sh	r0,r0[0x0]
8000818a:	77 a0       	ld.w	r0,r11[0x68]
8000818c:	80 00       	ld.sh	r0,r0[0x0]
8000818e:	66 22       	ld.w	r2,r3[0x8]
80008190:	80 01       	ld.sh	r1,r0[0x0]
80008192:	95 b0       	st.w	r10[0x2c],r0
80008194:	80 00       	ld.sh	r0,r0[0x0]
80008196:	66 2e       	ld.w	lr,r3[0x8]
80008198:	80 00       	ld.sh	r0,r0[0x0]
8000819a:	6f 94       	ld.w	r4,r7[0x64]
8000819c:	80 00       	ld.sh	r0,r0[0x0]
8000819e:	79 24       	ld.w	r4,r12[0x48]
800081a0:	80 00       	ld.sh	r0,r0[0x0]
800081a2:	66 9e       	ld.w	lr,r3[0x24]

800081a4 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
800081a4:	eb cd 40 80 	pushm	r7,lr
800081a8:	20 5d       	sub	sp,20
800081aa:	18 97       	mov	r7,r12
800081ac:	50 0b       	stdsp	sp[0x0],r11
	FRESULT res;
	FATFS* fs;
	DEFINE_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
800081ae:	58 0c       	cp.w	r12,0
800081b0:	c0 31       	brne	800081b6 <f_opendir+0x12>
800081b2:	30 9c       	mov	r12,9
800081b4:	c2 d8       	rjmp	8000820e <f_opendir+0x6a>

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
800081b6:	30 0a       	mov	r10,0
800081b8:	1a 9b       	mov	r11,sp
800081ba:	fa cc ff f0 	sub	r12,sp,-16
800081be:	f0 1f 00 17 	mcall	80008218 <f_opendir+0x74>
	if (res == FR_OK) {
800081c2:	c2 41       	brne	8000820a <f_opendir+0x66>
		dp->fs = fs;
800081c4:	40 48       	lddsp	r8,sp[0x10]
800081c6:	8f 08       	st.w	r7[0x0],r8
		INIT_BUF(*dp);
800081c8:	fa c8 ff fc 	sub	r8,sp,-4
800081cc:	8f 68       	st.w	r7[0x18],r8
		res = follow_path(dp, path);			/* Follow the path to the directory */
800081ce:	40 0b       	lddsp	r11,sp[0x0]
800081d0:	0e 9c       	mov	r12,r7
800081d2:	f0 1f 00 13 	mcall	8000821c <f_opendir+0x78>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
800081d6:	c1 61       	brne	80008202 <f_opendir+0x5e>
			if (dp->dir) {						/* It is not the origin directory itself */
800081d8:	6e 5b       	ld.w	r11,r7[0x14]
800081da:	58 0b       	cp.w	r11,0
800081dc:	c0 c0       	breq	800081f4 <f_opendir+0x50>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
800081de:	f7 38 00 0b 	ld.ub	r8,r11[11]
800081e2:	e2 18 00 10 	andl	r8,0x10,COH
800081e6:	c0 31       	brne	800081ec <f_opendir+0x48>
800081e8:	30 5c       	mov	r12,5
800081ea:	c0 e8       	rjmp	80008206 <f_opendir+0x62>
					dp->sclust = ld_clust(fs, dp->dir);
800081ec:	40 4c       	lddsp	r12,sp[0x10]
800081ee:	f0 1f 00 0d 	mcall	80008220 <f_opendir+0x7c>
800081f2:	8f 2c       	st.w	r7[0x8],r12
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
800081f4:	40 48       	lddsp	r8,sp[0x10]
800081f6:	90 38       	ld.sh	r8,r8[0x6]
800081f8:	ae 28       	st.h	r7[0x4],r8
				res = dir_sdi(dp, 0);			/* Rewind directory */
800081fa:	30 0b       	mov	r11,0
800081fc:	0e 9c       	mov	r12,r7
800081fe:	f0 1f 00 0a 	mcall	80008224 <f_opendir+0x80>
					}
				}
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
80008202:	58 4c       	cp.w	r12,4
80008204:	c0 80       	breq	80008214 <f_opendir+0x70>
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80008206:	58 0c       	cp.w	r12,0
80008208:	c0 30       	breq	8000820e <f_opendir+0x6a>
8000820a:	30 08       	mov	r8,0
8000820c:	8f 08       	st.w	r7[0x0],r8

	LEAVE_FF(fs, res);
}
8000820e:	2f bd       	sub	sp,-20
80008210:	e3 cd 80 80 	ldm	sp++,r7,pc
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80008214:	30 5c       	mov	r12,5
80008216:	cf ab       	rjmp	8000820a <f_opendir+0x66>
80008218:	80 00       	ld.sh	r0,r0[0x0]
8000821a:	70 70       	ld.w	r0,r8[0x1c]
8000821c:	80 00       	ld.sh	r0,r0[0x0]
8000821e:	7f 08       	ld.w	r8,pc[0x40]
80008220:	80 00       	ld.sh	r0,r0[0x0]
80008222:	66 9e       	ld.w	lr,r3[0x24]
80008224:	80 00       	ld.sh	r0,r0[0x0]
80008226:	77 a0       	ld.w	r0,r11[0x68]

80008228 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
80008228:	d4 31       	pushm	r0-r7,lr
8000822a:	21 0d       	sub	sp,64
8000822c:	50 4c       	stdsp	sp[0x10],r12
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
8000822e:	f0 1f 00 61 	mcall	800083b0 <f_mkdir+0x188>
80008232:	18 95       	mov	r5,r12
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
80008234:	30 1a       	mov	r10,1
80008236:	fa cb ff f0 	sub	r11,sp,-16
8000823a:	fa cc ff e0 	sub	r12,sp,-32
8000823e:	f0 1f 00 5e 	mcall	800083b4 <f_mkdir+0x18c>
80008242:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80008244:	c0 30       	breq	8000824a <f_mkdir+0x22>
80008246:	18 96       	mov	r6,r12
80008248:	ca 78       	rjmp	80008396 <f_mkdir+0x16e>
		INIT_BUF(dj);
8000824a:	fa c8 ff ec 	sub	r8,sp,-20
8000824e:	50 e8       	stdsp	sp[0x38],r8
		res = follow_path(&dj, path);			/* Follow the file path */
80008250:	40 4b       	lddsp	r11,sp[0x10]
80008252:	fa cc ff e0 	sub	r12,sp,-32
80008256:	f0 1f 00 59 	mcall	800083b8 <f_mkdir+0x190>
8000825a:	18 96       	mov	r6,r12
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
8000825c:	c0 31       	brne	80008262 <f_mkdir+0x3a>
8000825e:	30 86       	mov	r6,8
80008260:	c9 b8       	rjmp	80008396 <f_mkdir+0x16e>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
80008262:	58 4c       	cp.w	r12,4
80008264:	e0 81 00 99 	brne	80008396 <f_mkdir+0x16e>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
80008268:	30 0b       	mov	r11,0
8000826a:	40 8c       	lddsp	r12,sp[0x20]
8000826c:	f0 1f 00 54 	mcall	800083bc <f_mkdir+0x194>
80008270:	18 92       	mov	r2,r12
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
80008272:	c0 31       	brne	80008278 <f_mkdir+0x50>
80008274:	30 77       	mov	r7,7
80008276:	c0 88       	rjmp	80008286 <f_mkdir+0x5e>
			if (dcl == 1) res = FR_INT_ERR;
80008278:	58 1c       	cp.w	r12,1
8000827a:	c0 31       	brne	80008280 <f_mkdir+0x58>
8000827c:	30 27       	mov	r7,2
8000827e:	c6 c8       	rjmp	80008356 <f_mkdir+0x12e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
80008280:	5b fc       	cp.w	r12,-1
80008282:	e0 80 00 8d 	breq	8000839c <f_mkdir+0x174>
			if (res == FR_OK)					/* Flush FAT */
80008286:	58 07       	cp.w	r7,0
80008288:	c6 71       	brne	80008356 <f_mkdir+0x12e>
				res = sync_window(dj.fs);
8000828a:	40 8c       	lddsp	r12,sp[0x20]
8000828c:	f0 1f 00 4d 	mcall	800083c0 <f_mkdir+0x198>
80008290:	18 97       	mov	r7,r12
			if (res == FR_OK) {					/* Initialize the new directory table */
80008292:	c6 21       	brne	80008356 <f_mkdir+0x12e>
				dsc = clust2sect(dj.fs, dcl);
80008294:	40 87       	lddsp	r7,sp[0x20]
80008296:	04 9b       	mov	r11,r2
80008298:	0e 9c       	mov	r12,r7
8000829a:	f0 1f 00 4b 	mcall	800083c4 <f_mkdir+0x19c>
8000829e:	18 94       	mov	r4,r12
				dir = dj.fs->win;
800082a0:	ee c3 ff d0 	sub	r3,r7,-48
				mem_set(dir, 0, SS(dj.fs));
800082a4:	e0 6a 02 00 	mov	r10,512
800082a8:	30 0b       	mov	r11,0
800082aa:	06 9c       	mov	r12,r3
800082ac:	f0 1f 00 47 	mcall	800083c8 <f_mkdir+0x1a0>
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
800082b0:	30 ba       	mov	r10,11
800082b2:	32 0b       	mov	r11,32
800082b4:	06 9c       	mov	r12,r3
800082b6:	f0 1f 00 45 	mcall	800083c8 <f_mkdir+0x1a0>
				dir[DIR_Name] = '.';
800082ba:	32 e6       	mov	r6,46
800082bc:	ef 66 00 30 	st.b	r7[48],r6
				dir[DIR_Attr] = AM_DIR;
800082c0:	31 08       	mov	r8,16
800082c2:	e7 68 00 0b 	st.b	r3[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);
800082c6:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800082ca:	50 38       	stdsp	sp[0xc],r8
800082cc:	e7 68 00 16 	st.b	r3[22],r8
800082d0:	f1 d5 c1 08 	bfextu	r8,r5,0x8,0x8
800082d4:	50 28       	stdsp	sp[0x8],r8
800082d6:	e7 68 00 17 	st.b	r3[23],r8
800082da:	f1 d5 c2 08 	bfextu	r8,r5,0x10,0x8
800082de:	50 18       	stdsp	sp[0x4],r8
800082e0:	e7 68 00 18 	st.b	r3[24],r8
800082e4:	b9 85       	lsr	r5,0x18
800082e6:	50 05       	stdsp	sp[0x0],r5
800082e8:	e7 65 00 19 	st.b	r3[25],r5
				st_clust(dir, dcl);
800082ec:	04 9b       	mov	r11,r2
800082ee:	06 9c       	mov	r12,r3
800082f0:	f0 1f 00 37 	mcall	800083cc <f_mkdir+0x1a4>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
800082f4:	2b 07       	sub	r7,-80
800082f6:	32 0a       	mov	r10,32
800082f8:	06 9b       	mov	r11,r3
800082fa:	0e 9c       	mov	r12,r7
800082fc:	f0 1f 00 35 	mcall	800083d0 <f_mkdir+0x1a8>
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
80008300:	e7 66 00 21 	st.b	r3[33],r6
80008304:	40 ab       	lddsp	r11,sp[0x28]
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
80008306:	40 88       	lddsp	r8,sp[0x20]
80008308:	11 8a       	ld.ub	r10,r8[0x0]
8000830a:	30 39       	mov	r9,3
8000830c:	f2 0a 18 00 	cp.b	r10,r9
80008310:	c0 51       	brne	8000831a <f_mkdir+0xf2>
80008312:	70 98       	ld.w	r8,r8[0x24]
80008314:	16 38       	cp.w	r8,r11
80008316:	f9 bb 00 00 	moveq	r11,0
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
8000831a:	0e 9c       	mov	r12,r7
8000831c:	f0 1f 00 2c 	mcall	800083cc <f_mkdir+0x1a4>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
80008320:	40 88       	lddsp	r8,sp[0x20]
80008322:	11 a6       	ld.ub	r6,r8[0x2]
80008324:	58 06       	cp.w	r6,0
80008326:	c3 d0       	breq	800083a0 <f_mkdir+0x178>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
80008328:	30 15       	mov	r5,1
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
8000832a:	e0 61 02 00 	mov	r1,512
8000832e:	30 00       	mov	r0,0
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
80008330:	40 88       	lddsp	r8,sp[0x20]
80008332:	91 b4       	st.w	r8[0x2c],r4
80008334:	2f f4       	sub	r4,-1
					dj.fs->wflag = 1;
80008336:	40 88       	lddsp	r8,sp[0x20]
80008338:	b0 c5       	st.b	r8[0x4],r5
					res = sync_window(dj.fs);
8000833a:	40 8c       	lddsp	r12,sp[0x20]
8000833c:	f0 1f 00 21 	mcall	800083c0 <f_mkdir+0x198>
					if (res != FR_OK) break;
80008340:	c0 a1       	brne	80008354 <f_mkdir+0x12c>
					mem_set(dir, 0, SS(dj.fs));
80008342:	02 9a       	mov	r10,r1
80008344:	00 9b       	mov	r11,r0
80008346:	06 9c       	mov	r12,r3
80008348:	f0 1f 00 20 	mcall	800083c8 <f_mkdir+0x1a0>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
8000834c:	20 16       	sub	r6,1
8000834e:	5c 56       	castu.b	r6
80008350:	cf 01       	brne	80008330 <f_mkdir+0x108>
80008352:	c2 78       	rjmp	800083a0 <f_mkdir+0x178>
80008354:	18 97       	mov	r7,r12
80008356:	0e 96       	mov	r6,r7
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
80008358:	04 9b       	mov	r11,r2
8000835a:	40 8c       	lddsp	r12,sp[0x20]
8000835c:	f0 1f 00 1e 	mcall	800083d4 <f_mkdir+0x1ac>
80008360:	c1 b8       	rjmp	80008396 <f_mkdir+0x16e>
			} else {
				dir = dj.dir;
80008362:	40 dc       	lddsp	r12,sp[0x34]
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
80008364:	31 08       	mov	r8,16
80008366:	f9 68 00 0b 	st.b	r12[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
8000836a:	40 38       	lddsp	r8,sp[0xc]
8000836c:	f9 68 00 16 	st.b	r12[22],r8
80008370:	40 28       	lddsp	r8,sp[0x8]
80008372:	f9 68 00 17 	st.b	r12[23],r8
80008376:	40 18       	lddsp	r8,sp[0x4]
80008378:	f9 68 00 18 	st.b	r12[24],r8
8000837c:	40 08       	lddsp	r8,sp[0x0]
8000837e:	f9 68 00 19 	st.b	r12[25],r8
				st_clust(dir, dcl);					/* Table start cluster */
80008382:	04 9b       	mov	r11,r2
80008384:	f0 1f 00 12 	mcall	800083cc <f_mkdir+0x1a4>
				dj.fs->wflag = 1;
80008388:	30 19       	mov	r9,1
8000838a:	40 88       	lddsp	r8,sp[0x20]
8000838c:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(dj.fs);
8000838e:	40 8c       	lddsp	r12,sp[0x20]
80008390:	f0 1f 00 12 	mcall	800083d8 <f_mkdir+0x1b0>
80008394:	18 96       	mov	r6,r12
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
80008396:	0c 9c       	mov	r12,r6
80008398:	2f 0d       	sub	sp,-64
8000839a:	d8 32       	popm	r0-r7,pc
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
				res = sync_fs(dj.fs);
8000839c:	30 17       	mov	r7,1
8000839e:	cd cb       	rjmp	80008356 <f_mkdir+0x12e>
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
800083a0:	fa cc ff e0 	sub	r12,sp,-32
800083a4:	f0 1f 00 0e 	mcall	800083dc <f_mkdir+0x1b4>
800083a8:	18 96       	mov	r6,r12
			if (res != FR_OK) {
800083aa:	cd c0       	breq	80008362 <f_mkdir+0x13a>
800083ac:	cd 6b       	rjmp	80008358 <f_mkdir+0x130>
800083ae:	00 00       	add	r0,r0
800083b0:	80 00       	ld.sh	r0,r0[0x0]
800083b2:	65 48       	ld.w	r8,r2[0x50]
800083b4:	80 00       	ld.sh	r0,r0[0x0]
800083b6:	70 70       	ld.w	r0,r8[0x1c]
800083b8:	80 00       	ld.sh	r0,r0[0x0]
800083ba:	7f 08       	ld.w	r8,pc[0x40]
800083bc:	80 00       	ld.sh	r0,r0[0x0]
800083be:	78 54       	ld.w	r4,r12[0x14]
800083c0:	80 00       	ld.sh	r0,r0[0x0]
800083c2:	67 9c       	ld.w	r12,r3[0x64]
800083c4:	80 00       	ld.sh	r0,r0[0x0]
800083c6:	66 48       	ld.w	r8,r3[0x10]
800083c8:	80 00       	ld.sh	r0,r0[0x0]
800083ca:	66 22       	ld.w	r2,r3[0x8]
800083cc:	80 00       	ld.sh	r0,r0[0x0]
800083ce:	66 c6       	ld.w	r6,r3[0x30]
800083d0:	80 00       	ld.sh	r0,r0[0x0]
800083d2:	66 0c       	ld.w	r12,r3[0x0]
800083d4:	80 00       	ld.sh	r0,r0[0x0]
800083d6:	7a 34       	ld.w	r4,sp[0xc]
800083d8:	80 00       	ld.sh	r0,r0[0x0]
800083da:	68 00       	ld.w	r0,r4[0x0]
800083dc:	80 00       	ld.sh	r0,r0[0x0]
800083de:	7e bc       	ld.w	r12,pc[0x2c]

800083e0 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
800083e0:	eb cd 40 fc 	pushm	r2-r7,lr
800083e4:	20 cd       	sub	sp,48
800083e6:	18 97       	mov	r7,r12
800083e8:	50 0b       	stdsp	sp[0x0],r11
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
800083ea:	58 0c       	cp.w	r12,0
800083ec:	c0 31       	brne	800083f2 <f_open+0x12>
800083ee:	30 96       	mov	r6,9
800083f0:	cb 68       	rjmp	8000855c <f_open+0x17c>
	fp->fs = 0;			/* Clear file object */
800083f2:	30 08       	mov	r8,0
800083f4:	99 08       	st.w	r12[0x0],r8

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
800083f6:	eb da c0 05 	bfextu	r5,r10,0x0,0x5
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
800083fa:	0a 93       	mov	r3,r5
800083fc:	e2 1a 00 1e 	andl	r10,0x1e,COH
80008400:	1a 9b       	mov	r11,sp
80008402:	fa cc ff f0 	sub	r12,sp,-16
80008406:	f0 1f 00 5c 	mcall	80008574 <f_open+0x194>
8000840a:	18 96       	mov	r6,r12
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
8000840c:	e0 81 00 a8 	brne	8000855c <f_open+0x17c>
		INIT_BUF(dj);
80008410:	fa c8 ff fc 	sub	r8,sp,-4
80008414:	50 a8       	stdsp	sp[0x28],r8
		res = follow_path(&dj, path);	/* Follow the file path */
80008416:	40 0b       	lddsp	r11,sp[0x0]
80008418:	fa cc ff f0 	sub	r12,sp,-16
8000841c:	f0 1f 00 57 	mcall	80008578 <f_open+0x198>
		dir = dj.dir;
80008420:	40 94       	lddsp	r4,sp[0x24]
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
80008422:	c0 41       	brne	8000842a <f_open+0x4a>
			if (!dir)	/* Default directory itself */
80008424:	58 04       	cp.w	r4,0
80008426:	f9 bc 00 06 	moveq	r12,6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
8000842a:	06 98       	mov	r8,r3
8000842c:	e2 18 00 1c 	andl	r8,0x1c,COH
80008430:	c5 f0       	breq	800084ee <f_open+0x10e>
			if (res != FR_OK) {					/* No file, create new */
80008432:	58 0c       	cp.w	r12,0
80008434:	c0 d0       	breq	8000844e <f_open+0x6e>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
80008436:	58 4c       	cp.w	r12,4
80008438:	e0 81 00 91 	brne	8000855a <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
8000843c:	fa cc ff f0 	sub	r12,sp,-16
80008440:	f0 1f 00 4f 	mcall	8000857c <f_open+0x19c>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
80008444:	40 94       	lddsp	r4,sp[0x24]
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
80008446:	e0 81 00 8a 	brne	8000855a <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
8000844a:	a3 b5       	sbr	r5,0x3
8000844c:	c0 c8       	rjmp	80008464 <f_open+0x84>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
8000844e:	e9 38 00 0b 	ld.ub	r8,r4[11]
80008452:	e2 18 00 11 	andl	r8,0x11,COH
80008456:	c0 30       	breq	8000845c <f_open+0x7c>
80008458:	30 7c       	mov	r12,7
8000845a:	c8 08       	rjmp	8000855a <f_open+0x17a>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
8000845c:	e2 13 00 04 	andl	r3,0x4,COH
80008460:	e0 81 00 82 	brne	80008564 <f_open+0x184>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
80008464:	0a 98       	mov	r8,r5
80008466:	e2 18 00 08 	andl	r8,0x8,COH
8000846a:	c7 f0       	breq	80008568 <f_open+0x188>
				dw = GET_FATTIME();
8000846c:	f0 1f 00 45 	mcall	80008580 <f_open+0x1a0>
				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
80008470:	f5 dc c0 08 	bfextu	r10,r12,0x0,0x8
80008474:	e9 6a 00 0e 	st.b	r4[14],r10
80008478:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
8000847c:	e9 69 00 0f 	st.b	r4[15],r9
80008480:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
80008484:	e9 68 00 10 	st.b	r4[16],r8
80008488:	b9 8c       	lsr	r12,0x18
8000848a:	e9 6c 00 11 	st.b	r4[17],r12
				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
8000848e:	e9 6a 00 16 	st.b	r4[22],r10
80008492:	e9 69 00 17 	st.b	r4[23],r9
80008496:	e9 68 00 18 	st.b	r4[24],r8
8000849a:	e9 6c 00 19 	st.b	r4[25],r12
				dir[DIR_Attr] = 0;				/* Reset attribute */
8000849e:	30 08       	mov	r8,0
800084a0:	e9 68 00 0b 	st.b	r4[11],r8
				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
800084a4:	e9 68 00 1c 	st.b	r4[28],r8
800084a8:	e9 68 00 1d 	st.b	r4[29],r8
800084ac:	e9 68 00 1e 	st.b	r4[30],r8
800084b0:	e9 68 00 1f 	st.b	r4[31],r8
				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
800084b4:	08 9b       	mov	r11,r4
800084b6:	40 4c       	lddsp	r12,sp[0x10]
800084b8:	f0 1f 00 33 	mcall	80008584 <f_open+0x1a4>
800084bc:	18 93       	mov	r3,r12
				st_clust(dir, 0);				/* Reset cluster */
800084be:	30 0b       	mov	r11,0
800084c0:	08 9c       	mov	r12,r4
800084c2:	f0 1f 00 32 	mcall	80008588 <f_open+0x1a8>
				dj.fs->wflag = 1;
800084c6:	30 19       	mov	r9,1
800084c8:	40 48       	lddsp	r8,sp[0x10]
800084ca:	b0 c9       	st.b	r8[0x4],r9
				if (cl) {						/* Remove the cluster chain if exist */
800084cc:	58 03       	cp.w	r3,0
800084ce:	c4 d0       	breq	80008568 <f_open+0x188>
					dw = dj.fs->winsect;
800084d0:	40 4c       	lddsp	r12,sp[0x10]
800084d2:	78 b2       	ld.w	r2,r12[0x2c]
					res = remove_chain(dj.fs, cl);
800084d4:	06 9b       	mov	r11,r3
800084d6:	f0 1f 00 2e 	mcall	8000858c <f_open+0x1ac>
					if (res == FR_OK) {
800084da:	c4 01       	brne	8000855a <f_open+0x17a>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
800084dc:	20 13       	sub	r3,1
800084de:	40 48       	lddsp	r8,sp[0x10]
800084e0:	91 33       	st.w	r8[0xc],r3
						res = move_window(dj.fs, dw);
800084e2:	04 9b       	mov	r11,r2
800084e4:	40 4c       	lddsp	r12,sp[0x10]
800084e6:	f0 1f 00 2b 	mcall	80008590 <f_open+0x1b0>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
800084ea:	c1 40       	breq	80008512 <f_open+0x132>
800084ec:	c3 78       	rjmp	8000855a <f_open+0x17a>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
800084ee:	58 0c       	cp.w	r12,0
800084f0:	c3 51       	brne	8000855a <f_open+0x17a>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
800084f2:	e9 38 00 0b 	ld.ub	r8,r4[11]
800084f6:	10 99       	mov	r9,r8
800084f8:	e2 19 00 10 	andl	r9,0x10,COH
800084fc:	c0 30       	breq	80008502 <f_open+0x122>
800084fe:	30 4c       	mov	r12,4
80008500:	c2 d8       	rjmp	8000855a <f_open+0x17a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
80008502:	e2 13 00 02 	andl	r3,0x2,COH
80008506:	c3 10       	breq	80008568 <f_open+0x188>
80008508:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000850c:	c2 e0       	breq	80008568 <f_open+0x188>
8000850e:	30 7c       	mov	r12,7
80008510:	c2 58       	rjmp	8000855a <f_open+0x17a>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
80008512:	a5 b5       	sbr	r5,0x5
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
80008514:	40 43       	lddsp	r3,sp[0x10]
80008516:	66 b8       	ld.w	r8,r3[0x2c]
80008518:	8f 78       	st.w	r7[0x1c],r8
			fp->dir_ptr = dir;
8000851a:	8f 84       	st.w	r7[0x20],r4
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
8000851c:	ae e5       	st.b	r7[0x6],r5
			fp->err = 0;						/* Clear error flag */
8000851e:	30 08       	mov	r8,0
80008520:	ae f8       	st.b	r7[0x7],r8
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
80008522:	08 9b       	mov	r11,r4
80008524:	06 9c       	mov	r12,r3
80008526:	f0 1f 00 18 	mcall	80008584 <f_open+0x1a4>
8000852a:	8f 4c       	st.w	r7[0x10],r12
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
8000852c:	e9 39 00 1f 	ld.ub	r9,r4[31]
80008530:	e9 38 00 1e 	ld.ub	r8,r4[30]
80008534:	b1 68       	lsl	r8,0x10
80008536:	f1 e9 11 88 	or	r8,r8,r9<<0x18
8000853a:	e9 39 00 1c 	ld.ub	r9,r4[28]
8000853e:	12 48       	or	r8,r9
80008540:	e9 39 00 1d 	ld.ub	r9,r4[29]
80008544:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80008548:	8f 38       	st.w	r7[0xc],r8
			fp->fptr = 0;						/* File pointer */
8000854a:	30 08       	mov	r8,0
8000854c:	8f 28       	st.w	r7[0x8],r8
			fp->dsect = 0;
8000854e:	8f 68       	st.w	r7[0x18],r8
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
80008550:	8f 98       	st.w	r7[0x24],r8
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
80008552:	8f 03       	st.w	r7[0x0],r3
			fp->id = fp->fs->id;
80008554:	86 38       	ld.sh	r8,r3[0x6]
80008556:	ae 28       	st.h	r7[0x4],r8
80008558:	c0 28       	rjmp	8000855c <f_open+0x17c>
8000855a:	18 96       	mov	r6,r12
		}
	}

	LEAVE_FF(dj.fs, res);
}
8000855c:	0c 9c       	mov	r12,r6
8000855e:	2f 4d       	sub	sp,-48
80008560:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
80008564:	30 8c       	mov	r12,8
80008566:	cf ab       	rjmp	8000855a <f_open+0x17a>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
80008568:	0a 98       	mov	r8,r5
8000856a:	e2 18 00 08 	andl	r8,0x8,COH
8000856e:	cd 30       	breq	80008514 <f_open+0x134>
80008570:	cd 1b       	rjmp	80008512 <f_open+0x132>
80008572:	00 00       	add	r0,r0
80008574:	80 00       	ld.sh	r0,r0[0x0]
80008576:	70 70       	ld.w	r0,r8[0x1c]
80008578:	80 00       	ld.sh	r0,r0[0x0]
8000857a:	7f 08       	ld.w	r8,pc[0x40]
8000857c:	80 00       	ld.sh	r0,r0[0x0]
8000857e:	7e bc       	ld.w	r12,pc[0x2c]
80008580:	80 00       	ld.sh	r0,r0[0x0]
80008582:	65 48       	ld.w	r8,r2[0x50]
80008584:	80 00       	ld.sh	r0,r0[0x0]
80008586:	66 9e       	ld.w	lr,r3[0x24]
80008588:	80 00       	ld.sh	r0,r0[0x0]
8000858a:	66 c6       	ld.w	r6,r3[0x30]
8000858c:	80 00       	ld.sh	r0,r0[0x0]
8000858e:	7a 34       	ld.w	r4,sp[0xc]
80008590:	80 00       	ld.sh	r0,r0[0x0]
80008592:	6f 94       	ld.w	r4,r7[0x64]

80008594 <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
80008594:	d4 31       	pushm	r0-r7,lr
80008596:	20 2d       	sub	sp,8
80008598:	fa c7 ff f8 	sub	r7,sp,-8
8000859c:	0e dc       	st.w	--r7,r12
8000859e:	16 90       	mov	r0,r11
800085a0:	14 96       	mov	r6,r10
	UINT i;
	BYTE fat, *p;


	/* Get logical drive number */
	res = find_volume(fatfs, &path, 0);
800085a2:	30 0a       	mov	r10,0
800085a4:	0e 9b       	mov	r11,r7
800085a6:	0c 9c       	mov	r12,r6
800085a8:	f0 1f 00 33 	mcall	80008674 <f_getfree+0xe0>
800085ac:	18 93       	mov	r3,r12
	fs = *fatfs;
800085ae:	6c 06       	ld.w	r6,r6[0x0]
	if (res == FR_OK) {
800085b0:	c5 f1       	brne	8000866e <f_getfree+0xda>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
800085b2:	6c 48       	ld.w	r8,r6[0x10]
800085b4:	6c 57       	ld.w	r7,r6[0x14]
800085b6:	ee c9 00 02 	sub	r9,r7,2
800085ba:	12 38       	cp.w	r8,r9
800085bc:	e0 8b 00 04 	brhi	800085c4 <f_getfree+0x30>
			*nclst = fs->free_clust;
800085c0:	81 08       	st.w	r0[0x0],r8
800085c2:	c5 68       	rjmp	8000866e <f_getfree+0xda>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
800085c4:	0d 84       	ld.ub	r4,r6[0x0]
			nfree = 0;
			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
800085c6:	30 18       	mov	r8,1
800085c8:	f0 04 18 00 	cp.b	r4,r8
800085cc:	c1 71       	brne	800085fa <f_getfree+0x66>
800085ce:	30 27       	mov	r7,2
800085d0:	30 05       	mov	r5,0
				clst = 2;
				do {
					stat = get_fat(fs, clst);
800085d2:	0e 9b       	mov	r11,r7
800085d4:	0c 9c       	mov	r12,r6
800085d6:	f0 1f 00 29 	mcall	80008678 <f_getfree+0xe4>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
800085da:	5b fc       	cp.w	r12,-1
800085dc:	c0 31       	brne	800085e2 <f_getfree+0x4e>
800085de:	30 1c       	mov	r12,1
800085e0:	c4 28       	rjmp	80008664 <f_getfree+0xd0>
					if (stat == 1) { res = FR_INT_ERR; break; }
800085e2:	58 1c       	cp.w	r12,1
800085e4:	c0 31       	brne	800085ea <f_getfree+0x56>
800085e6:	30 2c       	mov	r12,2
800085e8:	c3 e8       	rjmp	80008664 <f_getfree+0xd0>
					if (stat == 0) nfree++;
800085ea:	58 0c       	cp.w	r12,0
800085ec:	f7 b5 00 ff 	subeq	r5,-1
				} while (++clst < fs->n_fatent);
800085f0:	2f f7       	sub	r7,-1
800085f2:	6c 58       	ld.w	r8,r6[0x14]
800085f4:	10 37       	cp.w	r7,r8
800085f6:	ce e3       	brcs	800085d2 <f_getfree+0x3e>
800085f8:	c3 58       	rjmp	80008662 <f_getfree+0xce>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
800085fa:	6c 81       	ld.w	r1,r6[0x20]
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
800085fc:	30 08       	mov	r8,0
800085fe:	10 99       	mov	r9,r8
80008600:	10 95       	mov	r5,r8
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
80008602:	ec ca ff d0 	sub	r10,r6,-48
80008606:	50 0a       	stdsp	sp[0x0],r10
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
80008608:	30 22       	mov	r2,2
				} while (++clst < fs->n_fatent);
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
8000860a:	58 09       	cp.w	r9,0
8000860c:	c0 a1       	brne	80008620 <f_getfree+0x8c>
						res = move_window(fs, sect++);
8000860e:	02 9b       	mov	r11,r1
80008610:	0c 9c       	mov	r12,r6
80008612:	f0 1f 00 1b 	mcall	8000867c <f_getfree+0xe8>
						if (res != FR_OK) break;
80008616:	c2 71       	brne	80008664 <f_getfree+0xd0>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
80008618:	2f f1       	sub	r1,-1
8000861a:	40 08       	lddsp	r8,sp[0x0]
8000861c:	e0 69 02 00 	mov	r9,512
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
80008620:	e4 04 18 00 	cp.b	r4,r2
80008624:	c0 d1       	brne	8000863e <f_getfree+0xaa>
						if (LD_WORD(p) == 0) nfree++;
80008626:	11 9b       	ld.ub	r11,r8[0x1]
80008628:	11 8a       	ld.ub	r10,r8[0x0]
8000862a:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
8000862e:	30 0b       	mov	r11,0
80008630:	f6 0a 19 00 	cp.h	r10,r11
80008634:	f7 b5 00 ff 	subeq	r5,-1
						p += 2; i -= 2;
80008638:	2f e8       	sub	r8,-2
8000863a:	20 29       	sub	r9,2
8000863c:	c1 18       	rjmp	8000865e <f_getfree+0xca>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
8000863e:	11 bb       	ld.ub	r11,r8[0x3]
80008640:	11 aa       	ld.ub	r10,r8[0x2]
80008642:	b1 6a       	lsl	r10,0x10
80008644:	f5 eb 11 8a 	or	r10,r10,r11<<0x18
80008648:	11 8b       	ld.ub	r11,r8[0x0]
8000864a:	16 4a       	or	r10,r11
8000864c:	11 9b       	ld.ub	r11,r8[0x1]
8000864e:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80008652:	f5 da c0 1c 	bfextu	r10,r10,0x0,0x1c
80008656:	f7 b5 00 ff 	subeq	r5,-1
						p += 4; i -= 4;
8000865a:	2f c8       	sub	r8,-4
8000865c:	20 49       	sub	r9,4
					}
				} while (--clst);
8000865e:	20 17       	sub	r7,1
80008660:	cd 51       	brne	8000860a <f_getfree+0x76>
80008662:	06 9c       	mov	r12,r3
			}
			fs->free_clust = nfree;	/* free_clust is valid */
80008664:	8d 45       	st.w	r6[0x10],r5
			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
80008666:	0d d8       	ld.ub	r8,r6[0x5]
80008668:	a1 a8       	sbr	r8,0x0
8000866a:	ac d8       	st.b	r6[0x5],r8
			*nclst = nfree;			/* Return the free clusters */
8000866c:	81 05       	st.w	r0[0x0],r5
		}
	}
	LEAVE_FF(fs, res);
}
8000866e:	2f ed       	sub	sp,-8
80008670:	d8 32       	popm	r0-r7,pc
80008672:	00 00       	add	r0,r0
80008674:	80 00       	ld.sh	r0,r0[0x0]
80008676:	70 70       	ld.w	r0,r8[0x1c]
80008678:	80 00       	ld.sh	r0,r0[0x0]
8000867a:	76 bc       	ld.w	r12,r11[0x2c]
8000867c:	80 00       	ld.sh	r0,r0[0x0]
8000867e:	6f 94       	ld.w	r4,r7[0x64]

80008680 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
80008680:	d4 31       	pushm	r0-r7,lr
80008682:	18 97       	mov	r7,r12
80008684:	16 95       	mov	r5,r11
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif


	res = validate(fp);					/* Check validity of the object */
80008686:	f0 1f 00 a5 	mcall	80008918 <f_lseek+0x298>
8000868a:	18 96       	mov	r6,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
8000868c:	e0 81 01 44 	brne	80008914 <f_lseek+0x294>
	if (fp->err)						/* Check error */
80008690:	0f f8       	ld.ub	r8,r7[0x7]
80008692:	58 08       	cp.w	r8,0
80008694:	c0 30       	breq	8000869a <f_lseek+0x1a>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008696:	10 96       	mov	r6,r8
80008698:	c3 e9       	rjmp	80008914 <f_lseek+0x294>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
8000869a:	6e 93       	ld.w	r3,r7[0x24]
8000869c:	58 03       	cp.w	r3,0
8000869e:	e0 80 00 85 	breq	800087a8 <f_lseek+0x128>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
800086a2:	5b f5       	cp.w	r5,-1
800086a4:	c3 71       	brne	80008712 <f_lseek+0x92>
			tbl = fp->cltbl;
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
800086a6:	07 00       	ld.w	r0,r3++
			cl = fp->sclust;			/* Top of the chain */
800086a8:	6e 41       	ld.w	r1,r7[0x10]
			if (cl) {
800086aa:	58 01       	cp.w	r1,0
800086ac:	c2 80       	breq	800086fc <f_lseek+0x7c>
800086ae:	30 22       	mov	r2,2
800086b0:	02 95       	mov	r5,r1
800086b2:	30 04       	mov	r4,0
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
800086b4:	0a 9b       	mov	r11,r5
800086b6:	6e 0c       	ld.w	r12,r7[0x0]
800086b8:	f0 1f 00 99 	mcall	8000891c <f_lseek+0x29c>
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
800086bc:	58 1c       	cp.w	r12,1
800086be:	e0 8b 00 06 	brhi	800086ca <f_lseek+0x4a>
800086c2:	30 28       	mov	r8,2
800086c4:	ae f8       	st.b	r7[0x7],r8
800086c6:	30 26       	mov	r6,2
800086c8:	c2 69       	rjmp	80008914 <f_lseek+0x294>
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800086ca:	5b fc       	cp.w	r12,-1
800086cc:	c0 51       	brne	800086d6 <f_lseek+0x56>
800086ce:	30 18       	mov	r8,1
800086d0:	ae f8       	st.b	r7[0x7],r8
800086d2:	30 16       	mov	r6,1
800086d4:	c2 09       	rjmp	80008914 <f_lseek+0x294>
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
800086d6:	2f f4       	sub	r4,-1
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
800086d8:	2f f5       	sub	r5,-1
800086da:	0a 3c       	cp.w	r12,r5
800086dc:	c0 31       	brne	800086e2 <f_lseek+0x62>
800086de:	18 95       	mov	r5,r12
800086e0:	ce ab       	rjmp	800086b4 <f_lseek+0x34>
800086e2:	18 98       	mov	r8,r12
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
			cl = fp->sclust;			/* Top of the chain */
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
800086e4:	2f e2       	sub	r2,-2
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
800086e6:	04 30       	cp.w	r0,r2
800086e8:	c0 33       	brcs	800086ee <f_lseek+0x6e>
						*tbl++ = ncl; *tbl++ = tcl;
800086ea:	06 a4       	st.w	r3++,r4
800086ec:	06 a1       	st.w	r3++,r1
					}
				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
800086ee:	6e 09       	ld.w	r9,r7[0x0]
800086f0:	72 59       	ld.w	r9,r9[0x14]
800086f2:	10 39       	cp.w	r9,r8
800086f4:	e0 88 00 05 	brls	800086fe <f_lseek+0x7e>
800086f8:	18 91       	mov	r1,r12
800086fa:	cd bb       	rjmp	800086b0 <f_lseek+0x30>
800086fc:	30 22       	mov	r2,2
			}
			*fp->cltbl = ulen;	/* Number of items used */
800086fe:	6e 98       	ld.w	r8,r7[0x24]
80008700:	91 02       	st.w	r8[0x0],r2
			if (ulen <= tlen)
80008702:	00 32       	cp.w	r2,r0
80008704:	f9 b6 0b 11 	movhi	r6,17
				*tbl = 0;		/* Terminate table */
80008708:	f9 b8 08 00 	movls	r8,0
8000870c:	e7 f8 8a 00 	st.wls	r3[0x0],r8
80008710:	c0 29       	rjmp	80008914 <f_lseek+0x294>
80008712:	6e 34       	ld.w	r4,r7[0xc]
80008714:	08 35       	cp.w	r5,r4
80008716:	e8 05 17 b0 	movhi	r5,r4
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */

		} else {						/* Fast seek */
			if (ofs > fp->fsize)		/* Clip offset at the file size */
				ofs = fp->fsize;
			fp->fptr = ofs;				/* Set file pointer */
8000871a:	8f 25       	st.w	r7[0x8],r5
			if (ofs) {
8000871c:	58 05       	cp.w	r5,0
8000871e:	e0 80 00 fb 	breq	80008914 <f_lseek+0x294>
				fp->clust = clmt_clust(fp, ofs - 1);
80008722:	ea c4 00 01 	sub	r4,r5,1
80008726:	08 9b       	mov	r11,r4
80008728:	0e 9c       	mov	r12,r7
8000872a:	f0 1f 00 7e 	mcall	80008920 <f_lseek+0x2a0>
8000872e:	18 9b       	mov	r11,r12
80008730:	8f 5c       	st.w	r7[0x14],r12
				dsc = clust2sect(fp->fs, fp->clust);
80008732:	6e 05       	ld.w	r5,r7[0x0]
80008734:	0a 9c       	mov	r12,r5
80008736:	f0 1f 00 7c 	mcall	80008924 <f_lseek+0x2a4>
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
8000873a:	c0 51       	brne	80008744 <f_lseek+0xc4>
8000873c:	30 28       	mov	r8,2
8000873e:	ae f8       	st.b	r7[0x7],r8
80008740:	30 26       	mov	r6,2
80008742:	ce 98       	rjmp	80008914 <f_lseek+0x294>
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
80008744:	0b a9       	ld.ub	r9,r5[0x2]
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
80008746:	6e 28       	ld.w	r8,r7[0x8]
80008748:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000874c:	e0 80 00 e4 	breq	80008914 <f_lseek+0x294>
			fp->fptr = ofs;				/* Set file pointer */
			if (ofs) {
				fp->clust = clmt_clust(fp, ofs - 1);
				dsc = clust2sect(fp->fs, fp->clust);
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
80008750:	20 19       	sub	r9,1
80008752:	f3 e4 02 94 	and	r4,r9,r4>>0x9
80008756:	f8 04 00 04 	add	r4,r12,r4
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
8000875a:	6e 6a       	ld.w	r10,r7[0x18]
8000875c:	08 3a       	cp.w	r10,r4
8000875e:	e0 80 00 db 	breq	80008914 <f_lseek+0x294>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
80008762:	0f e8       	ld.ub	r8,r7[0x6]
80008764:	e2 18 00 40 	andl	r8,0x40,COH
80008768:	c0 f0       	breq	80008786 <f_lseek+0x106>
						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
8000876a:	30 19       	mov	r9,1
8000876c:	ee cb ff d8 	sub	r11,r7,-40
80008770:	0b 9c       	ld.ub	r12,r5[0x1]
80008772:	f0 1f 00 6e 	mcall	80008928 <f_lseek+0x2a8>
80008776:	c0 50       	breq	80008780 <f_lseek+0x100>
							ABORT(fp->fs, FR_DISK_ERR);
80008778:	30 18       	mov	r8,1
8000877a:	ae f8       	st.b	r7[0x7],r8
8000877c:	30 16       	mov	r6,1
8000877e:	cc b8       	rjmp	80008914 <f_lseek+0x294>
						fp->flag &= ~FA__DIRTY;
80008780:	0f e8       	ld.ub	r8,r7[0x6]
80008782:	a7 c8       	cbr	r8,0x6
80008784:	ae e8       	st.b	r7[0x6],r8
					}
#endif
					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
80008786:	6e 08       	ld.w	r8,r7[0x0]
80008788:	30 19       	mov	r9,1
8000878a:	08 9a       	mov	r10,r4
8000878c:	ee cb ff d8 	sub	r11,r7,-40
80008790:	11 9c       	ld.ub	r12,r8[0x1]
80008792:	f0 1f 00 67 	mcall	8000892c <f_lseek+0x2ac>
						ABORT(fp->fs, FR_DISK_ERR);
80008796:	f9 b8 01 01 	movne	r8,1
8000879a:	ef f8 1e 07 	st.bne	r7[0x7],r8
8000879e:	f9 b6 01 01 	movne	r6,1
#endif
					fp->dsect = dsc;
800087a2:	ef f4 0a 06 	st.weq	r7[0x18],r4
800087a6:	cb 78       	rjmp	80008914 <f_lseek+0x294>

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
800087a8:	6e 34       	ld.w	r4,r7[0xc]
	} else
#endif

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
800087aa:	08 35       	cp.w	r5,r4
800087ac:	e0 88 00 06 	brls	800087b8 <f_lseek+0x138>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
800087b0:	0f e8       	ld.ub	r8,r7[0x6]
800087b2:	e2 18 00 02 	andl	r8,0x2,COH
800087b6:	c0 20       	breq	800087ba <f_lseek+0x13a>
800087b8:	0a 94       	mov	r4,r5
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
800087ba:	6e 29       	ld.w	r9,r7[0x8]
		fp->fptr = nsect = 0;
800087bc:	30 08       	mov	r8,0
800087be:	8f 28       	st.w	r7[0x8],r8
		if (ofs) {
800087c0:	58 04       	cp.w	r4,0
800087c2:	e0 80 00 a9 	breq	80008914 <f_lseek+0x294>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
800087c6:	6e 08       	ld.w	r8,r7[0x0]
800087c8:	11 a5       	ld.ub	r5,r8[0x2]
800087ca:	a9 75       	lsl	r5,0x9
			if (ifptr > 0 &&
800087cc:	58 09       	cp.w	r9,0
800087ce:	c1 30       	breq	800087f4 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
800087d0:	20 19       	sub	r9,1

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
800087d2:	e8 cb 00 01 	sub	r11,r4,1
800087d6:	f6 05 0d 0a 	divu	r10,r11,r5
800087da:	14 9b       	mov	r11,r10
800087dc:	f2 05 0d 02 	divu	r2,r9,r5
800087e0:	04 3b       	cp.w	r11,r2
800087e2:	c0 93       	brcs	800087f4 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
800087e4:	ea 08 11 00 	rsub	r8,r5,0
800087e8:	f1 e9 00 09 	and	r9,r8,r9
800087ec:	8f 29       	st.w	r7[0x8],r9
				ofs -= fp->fptr;
800087ee:	12 14       	sub	r4,r9
				clst = fp->clust;
800087f0:	6e 5c       	ld.w	r12,r7[0x14]

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
800087f2:	c1 68       	rjmp	8000881e <f_lseek+0x19e>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
800087f4:	6e 4c       	ld.w	r12,r7[0x10]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
800087f6:	58 0c       	cp.w	r12,0
800087f8:	c1 21       	brne	8000881c <f_lseek+0x19c>
					clst = create_chain(fp->fs, 0);
800087fa:	30 0b       	mov	r11,0
800087fc:	10 9c       	mov	r12,r8
800087fe:	f0 1f 00 4d 	mcall	80008930 <f_lseek+0x2b0>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
80008802:	58 1c       	cp.w	r12,1
80008804:	c0 51       	brne	8000880e <f_lseek+0x18e>
80008806:	30 28       	mov	r8,2
80008808:	ae f8       	st.b	r7[0x7],r8
8000880a:	30 26       	mov	r6,2
8000880c:	c8 48       	rjmp	80008914 <f_lseek+0x294>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
8000880e:	5b fc       	cp.w	r12,-1
80008810:	c0 51       	brne	8000881a <f_lseek+0x19a>
80008812:	30 18       	mov	r8,1
80008814:	ae f8       	st.b	r7[0x7],r8
80008816:	30 16       	mov	r6,1
80008818:	c7 e8       	rjmp	80008914 <f_lseek+0x294>
					fp->sclust = clst;
8000881a:	8f 4c       	st.w	r7[0x10],r12
				}
#endif
				fp->clust = clst;
8000881c:	8f 5c       	st.w	r7[0x14],r12
			}
			if (clst != 0) {
8000881e:	58 0c       	cp.w	r12,0
80008820:	c4 80       	breq	800088b0 <f_lseek+0x230>
				while (ofs > bcs) {						/* Cluster following loop */
80008822:	0a 34       	cp.w	r4,r5
80008824:	e0 88 00 32 	brls	80008888 <f_lseek+0x208>
#if _FS_MINIMIZE <= 2
/*-----------------------------------------------------------------------*/
/* Seek File R/W Pointer                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_lseek (
80008828:	ea 03 11 00 	rsub	r3,r5,0
8000882c:	0a 14       	sub	r4,r5
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
8000882e:	0f e8       	ld.ub	r8,r7[0x6]
80008830:	e2 18 00 02 	andl	r8,0x2,COH
80008834:	c0 70       	breq	80008842 <f_lseek+0x1c2>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
80008836:	18 9b       	mov	r11,r12
80008838:	6e 0c       	ld.w	r12,r7[0x0]
8000883a:	f0 1f 00 3e 	mcall	80008930 <f_lseek+0x2b0>
						if (clst == 0) {				/* When disk gets full, clip file size */
8000883e:	c0 61       	brne	8000884a <f_lseek+0x1ca>
80008840:	c2 38       	rjmp	80008886 <f_lseek+0x206>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
80008842:	18 9b       	mov	r11,r12
80008844:	6e 0c       	ld.w	r12,r7[0x0]
80008846:	f0 1f 00 36 	mcall	8000891c <f_lseek+0x29c>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
8000884a:	5b fc       	cp.w	r12,-1
8000884c:	c0 51       	brne	80008856 <f_lseek+0x1d6>
8000884e:	30 18       	mov	r8,1
80008850:	ae f8       	st.b	r7[0x7],r8
80008852:	30 16       	mov	r6,1
80008854:	c6 08       	rjmp	80008914 <f_lseek+0x294>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
80008856:	58 1c       	cp.w	r12,1
80008858:	e0 88 00 06 	brls	80008864 <f_lseek+0x1e4>
8000885c:	6e 08       	ld.w	r8,r7[0x0]
8000885e:	70 58       	ld.w	r8,r8[0x14]
80008860:	10 3c       	cp.w	r12,r8
80008862:	c0 53       	brcs	8000886c <f_lseek+0x1ec>
80008864:	30 28       	mov	r8,2
80008866:	ae f8       	st.b	r7[0x7],r8
80008868:	30 26       	mov	r6,2
8000886a:	c5 58       	rjmp	80008914 <f_lseek+0x294>
					fp->clust = clst;
8000886c:	8f 5c       	st.w	r7[0x14],r12
					fp->fptr += bcs;
8000886e:	6e 28       	ld.w	r8,r7[0x8]
80008870:	0a 08       	add	r8,r5
80008872:	8f 28       	st.w	r7[0x8],r8
80008874:	e8 03 00 08 	add	r8,r4,r3
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
80008878:	f0 05 00 09 	add	r9,r8,r5
8000887c:	0a 39       	cp.w	r9,r5
8000887e:	e0 88 00 05 	brls	80008888 <f_lseek+0x208>
80008882:	10 94       	mov	r4,r8
80008884:	cd 5b       	rjmp	8000882e <f_lseek+0x1ae>
80008886:	0a 94       	mov	r4,r5
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
80008888:	6e 28       	ld.w	r8,r7[0x8]
8000888a:	08 08       	add	r8,r4
8000888c:	8f 28       	st.w	r7[0x8],r8
				if (ofs % SS(fp->fs)) {
8000888e:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
80008892:	c0 f0       	breq	800088b0 <f_lseek+0x230>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
80008894:	18 9b       	mov	r11,r12
80008896:	6e 0c       	ld.w	r12,r7[0x0]
80008898:	f0 1f 00 23 	mcall	80008924 <f_lseek+0x2a4>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
8000889c:	c0 51       	brne	800088a6 <f_lseek+0x226>
8000889e:	30 28       	mov	r8,2
800088a0:	ae f8       	st.b	r7[0x7],r8
800088a2:	30 26       	mov	r6,2
800088a4:	c3 88       	rjmp	80008914 <f_lseek+0x294>
					nsect += ofs / SS(fp->fs);
800088a6:	e8 05 16 09 	lsr	r5,r4,0x9
800088aa:	f8 05 00 05 	add	r5,r12,r5
800088ae:	c0 28       	rjmp	800088b2 <f_lseek+0x232>
800088b0:	30 05       	mov	r5,0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
800088b2:	6e 28       	ld.w	r8,r7[0x8]
800088b4:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800088b8:	c2 50       	breq	80008902 <f_lseek+0x282>
800088ba:	6e 6a       	ld.w	r10,r7[0x18]
800088bc:	0a 3a       	cp.w	r10,r5
800088be:	c2 20       	breq	80008902 <f_lseek+0x282>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
800088c0:	0f e8       	ld.ub	r8,r7[0x6]
800088c2:	e2 18 00 40 	andl	r8,0x40,COH
800088c6:	c1 00       	breq	800088e6 <f_lseek+0x266>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800088c8:	6e 08       	ld.w	r8,r7[0x0]
800088ca:	30 19       	mov	r9,1
800088cc:	ee cb ff d8 	sub	r11,r7,-40
800088d0:	11 9c       	ld.ub	r12,r8[0x1]
800088d2:	f0 1f 00 16 	mcall	80008928 <f_lseek+0x2a8>
800088d6:	c0 50       	breq	800088e0 <f_lseek+0x260>
					ABORT(fp->fs, FR_DISK_ERR);
800088d8:	30 18       	mov	r8,1
800088da:	ae f8       	st.b	r7[0x7],r8
800088dc:	30 16       	mov	r6,1
800088de:	c1 b8       	rjmp	80008914 <f_lseek+0x294>
				fp->flag &= ~FA__DIRTY;
800088e0:	0f e8       	ld.ub	r8,r7[0x6]
800088e2:	a7 c8       	cbr	r8,0x6
800088e4:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
800088e6:	6e 08       	ld.w	r8,r7[0x0]
800088e8:	30 19       	mov	r9,1
800088ea:	0a 9a       	mov	r10,r5
800088ec:	ee cb ff d8 	sub	r11,r7,-40
800088f0:	11 9c       	ld.ub	r12,r8[0x1]
800088f2:	f0 1f 00 0f 	mcall	8000892c <f_lseek+0x2ac>
800088f6:	c0 50       	breq	80008900 <f_lseek+0x280>
				ABORT(fp->fs, FR_DISK_ERR);
800088f8:	30 18       	mov	r8,1
800088fa:	ae f8       	st.b	r7[0x7],r8
800088fc:	30 16       	mov	r6,1
800088fe:	c0 b8       	rjmp	80008914 <f_lseek+0x294>
#endif
			fp->dsect = nsect;
80008900:	8f 65       	st.w	r7[0x18],r5
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
80008902:	6e 28       	ld.w	r8,r7[0x8]
80008904:	6e 39       	ld.w	r9,r7[0xc]
80008906:	12 38       	cp.w	r8,r9
80008908:	e0 88 00 06 	brls	80008914 <f_lseek+0x294>
			fp->fsize = fp->fptr;
8000890c:	8f 38       	st.w	r7[0xc],r8
			fp->flag |= FA__WRITTEN;
8000890e:	0f e8       	ld.ub	r8,r7[0x6]
80008910:	a5 b8       	sbr	r8,0x5
80008912:	ae e8       	st.b	r7[0x6],r8
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
80008914:	0c 9c       	mov	r12,r6
80008916:	d8 32       	popm	r0-r7,pc
80008918:	80 00       	ld.sh	r0,r0[0x0]
8000891a:	6f 60       	ld.w	r0,r7[0x58]
8000891c:	80 00       	ld.sh	r0,r0[0x0]
8000891e:	76 bc       	ld.w	r12,r11[0x2c]
80008920:	80 00       	ld.sh	r0,r0[0x0]
80008922:	66 60       	ld.w	r0,r3[0x18]
80008924:	80 00       	ld.sh	r0,r0[0x0]
80008926:	66 48       	ld.w	r8,r3[0x10]
80008928:	80 00       	ld.sh	r0,r0[0x0]
8000892a:	65 d4       	ld.w	r4,r2[0x74]
8000892c:	80 00       	ld.sh	r0,r0[0x0]
8000892e:	65 f0       	ld.w	r0,r2[0x7c]
80008930:	80 00       	ld.sh	r0,r0[0x0]
80008932:	78 54       	ld.w	r4,r12[0x14]

80008934 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
80008934:	d4 31       	pushm	r0-r7,lr
80008936:	20 3d       	sub	sp,12
80008938:	18 97       	mov	r7,r12
8000893a:	16 93       	mov	r3,r11
8000893c:	14 96       	mov	r6,r10
8000893e:	12 94       	mov	r4,r9
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
80008940:	30 08       	mov	r8,0
80008942:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);						/* Check validity */
80008944:	f0 1f 00 6d 	mcall	80008af8 <f_write+0x1c4>
80008948:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
8000894a:	e0 81 00 d3 	brne	80008af0 <f_write+0x1bc>
	if (fp->err)							/* Check error */
8000894e:	0f f8       	ld.ub	r8,r7[0x7]
80008950:	58 08       	cp.w	r8,0
80008952:	c0 30       	breq	80008958 <f_write+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008954:	10 92       	mov	r2,r8
80008956:	cc d8       	rjmp	80008af0 <f_write+0x1bc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
80008958:	0f e8       	ld.ub	r8,r7[0x6]
8000895a:	e2 18 00 02 	andl	r8,0x2,COH
8000895e:	c0 31       	brne	80008964 <f_write+0x30>
80008960:	30 72       	mov	r2,7
80008962:	cc 78       	rjmp	80008af0 <f_write+0x1bc>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
80008964:	6e 28       	ld.w	r8,r7[0x8]
80008966:	ec 08 00 09 	add	r9,r6,r8
8000896a:	12 38       	cp.w	r8,r9
8000896c:	e0 8b 00 ba 	brhi	80008ae0 <f_write+0x1ac>

	for ( ;  btw;							/* Repeat until all data written */
80008970:	58 06       	cp.w	r6,0
80008972:	e0 80 00 b7 	breq	80008ae0 <f_write+0x1ac>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008976:	ee c8 ff d8 	sub	r8,r7,-40
8000897a:	50 18       	stdsp	sp[0x4],r8
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
8000897c:	50 08       	stdsp	sp[0x0],r8
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
8000897e:	50 2c       	stdsp	sp[0x8],r12
80008980:	0c 95       	mov	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
80008982:	6e 2b       	ld.w	r11,r7[0x8]
80008984:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
80008988:	e0 81 00 8c 	brne	80008aa0 <f_write+0x16c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
8000898c:	6e 08       	ld.w	r8,r7[0x0]
8000898e:	11 a6       	ld.ub	r6,r8[0x2]
80008990:	20 16       	sub	r6,1
80008992:	ed eb 02 96 	and	r6,r6,r11>>0x9
80008996:	5c 56       	castu.b	r6
			if (!csect) {					/* On the cluster boundary? */
80008998:	c2 91       	brne	800089ea <f_write+0xb6>
				if (fp->fptr == 0) {		/* On the top of the file? */
8000899a:	58 0b       	cp.w	r11,0
8000899c:	c0 81       	brne	800089ac <f_write+0x78>
					clst = fp->sclust;		/* Follow from the origin */
8000899e:	6e 4c       	ld.w	r12,r7[0x10]
					if (clst == 0)			/* When no cluster is allocated, */
800089a0:	58 0c       	cp.w	r12,0
800089a2:	c1 31       	brne	800089c8 <f_write+0x94>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
800089a4:	10 9c       	mov	r12,r8
800089a6:	f0 1f 00 56 	mcall	80008afc <f_write+0x1c8>
800089aa:	c0 c8       	rjmp	800089c2 <f_write+0x8e>
				} else {					/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
800089ac:	6e 99       	ld.w	r9,r7[0x24]
800089ae:	58 09       	cp.w	r9,0
800089b0:	c0 50       	breq	800089ba <f_write+0x86>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
800089b2:	0e 9c       	mov	r12,r7
800089b4:	f0 1f 00 53 	mcall	80008b00 <f_write+0x1cc>
800089b8:	c0 58       	rjmp	800089c2 <f_write+0x8e>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
800089ba:	6e 5b       	ld.w	r11,r7[0x14]
800089bc:	10 9c       	mov	r12,r8
800089be:	f0 1f 00 50 	mcall	80008afc <f_write+0x1c8>
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
800089c2:	58 0c       	cp.w	r12,0
800089c4:	e0 80 00 8b 	breq	80008ada <f_write+0x1a6>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
800089c8:	58 1c       	cp.w	r12,1
800089ca:	c0 51       	brne	800089d4 <f_write+0xa0>
800089cc:	30 28       	mov	r8,2
800089ce:	ae f8       	st.b	r7[0x7],r8
800089d0:	30 22       	mov	r2,2
800089d2:	c8 f8       	rjmp	80008af0 <f_write+0x1bc>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800089d4:	5b fc       	cp.w	r12,-1
800089d6:	c0 51       	brne	800089e0 <f_write+0xac>
800089d8:	30 18       	mov	r8,1
800089da:	ae f8       	st.b	r7[0x7],r8
800089dc:	30 12       	mov	r2,1
800089de:	c8 98       	rjmp	80008af0 <f_write+0x1bc>
				fp->clust = clst;			/* Update current cluster */
800089e0:	8f 5c       	st.w	r7[0x14],r12
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
800089e2:	6e 48       	ld.w	r8,r7[0x10]
800089e4:	58 08       	cp.w	r8,0
800089e6:	ef fc 0a 04 	st.weq	r7[0x10],r12
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
800089ea:	0f e8       	ld.ub	r8,r7[0x6]
800089ec:	e2 18 00 40 	andl	r8,0x40,COH
800089f0:	c1 00       	breq	80008a10 <f_write+0xdc>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800089f2:	6e 08       	ld.w	r8,r7[0x0]
800089f4:	30 19       	mov	r9,1
800089f6:	6e 6a       	ld.w	r10,r7[0x18]
800089f8:	40 1b       	lddsp	r11,sp[0x4]
800089fa:	11 9c       	ld.ub	r12,r8[0x1]
800089fc:	f0 1f 00 42 	mcall	80008b04 <f_write+0x1d0>
80008a00:	c0 50       	breq	80008a0a <f_write+0xd6>
					ABORT(fp->fs, FR_DISK_ERR);
80008a02:	30 18       	mov	r8,1
80008a04:	ae f8       	st.b	r7[0x7],r8
80008a06:	30 12       	mov	r2,1
80008a08:	c7 48       	rjmp	80008af0 <f_write+0x1bc>
				fp->flag &= ~FA__DIRTY;
80008a0a:	0f e8       	ld.ub	r8,r7[0x6]
80008a0c:	a7 c8       	cbr	r8,0x6
80008a0e:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
80008a10:	6e 01       	ld.w	r1,r7[0x0]
80008a12:	6e 5b       	ld.w	r11,r7[0x14]
80008a14:	02 9c       	mov	r12,r1
80008a16:	f0 1f 00 3d 	mcall	80008b08 <f_write+0x1d4>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
80008a1a:	c0 51       	brne	80008a24 <f_write+0xf0>
80008a1c:	30 28       	mov	r8,2
80008a1e:	ae f8       	st.b	r7[0x7],r8
80008a20:	30 22       	mov	r2,2
80008a22:	c6 78       	rjmp	80008af0 <f_write+0x1bc>
			sect += csect;
80008a24:	f8 06 00 00 	add	r0,r12,r6
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
80008a28:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {						/* Write maximum contiguous sectors directly */
80008a2c:	c2 70       	breq	80008a7a <f_write+0x146>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
80008a2e:	03 a9       	ld.ub	r9,r1[0x2]
80008a30:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
80008a34:	12 38       	cp.w	r8,r9
80008a36:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
80008a3a:	04 99       	mov	r9,r2
80008a3c:	00 9a       	mov	r10,r0
80008a3e:	06 9b       	mov	r11,r3
80008a40:	03 9c       	ld.ub	r12,r1[0x1]
80008a42:	f0 1f 00 31 	mcall	80008b04 <f_write+0x1d0>
80008a46:	c0 50       	breq	80008a50 <f_write+0x11c>
					ABORT(fp->fs, FR_DISK_ERR);
80008a48:	30 18       	mov	r8,1
80008a4a:	ae f8       	st.b	r7[0x7],r8
80008a4c:	30 12       	mov	r2,1
80008a4e:	c5 18       	rjmp	80008af0 <f_write+0x1bc>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
80008a50:	6e 6b       	ld.w	r11,r7[0x18]
80008a52:	f6 00 01 00 	sub	r0,r11,r0
80008a56:	00 32       	cp.w	r2,r0
80008a58:	e0 88 00 0e 	brls	80008a74 <f_write+0x140>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
80008a5c:	e0 0b 15 09 	lsl	r11,r0,0x9
80008a60:	e0 6a 02 00 	mov	r10,512
80008a64:	e6 0b 00 0b 	add	r11,r3,r11
80008a68:	40 0c       	lddsp	r12,sp[0x0]
80008a6a:	f0 1f 00 29 	mcall	80008b0c <f_write+0x1d8>
					fp->flag &= ~FA__DIRTY;
80008a6e:	0f e8       	ld.ub	r8,r7[0x6]
80008a70:	a7 c8       	cbr	r8,0x6
80008a72:	ae e8       	st.b	r7[0x6],r8
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
80008a74:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
80008a78:	c2 78       	rjmp	80008ac6 <f_write+0x192>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
80008a7a:	6e 68       	ld.w	r8,r7[0x18]
80008a7c:	00 38       	cp.w	r8,r0
80008a7e:	c1 00       	breq	80008a9e <f_write+0x16a>
				if (fp->fptr < fp->fsize &&
80008a80:	6e 29       	ld.w	r9,r7[0x8]
80008a82:	6e 38       	ld.w	r8,r7[0xc]
80008a84:	10 39       	cp.w	r9,r8
80008a86:	c0 c2       	brcc	80008a9e <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
80008a88:	30 19       	mov	r9,1
80008a8a:	00 9a       	mov	r10,r0
80008a8c:	40 1b       	lddsp	r11,sp[0x4]
80008a8e:	03 9c       	ld.ub	r12,r1[0x1]
80008a90:	f0 1f 00 20 	mcall	80008b10 <f_write+0x1dc>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
80008a94:	c0 50       	breq	80008a9e <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
80008a96:	30 18       	mov	r8,1
80008a98:	ae f8       	st.b	r7[0x7],r8
80008a9a:	30 12       	mov	r2,1
80008a9c:	c2 a8       	rjmp	80008af0 <f_write+0x1bc>
			}
#endif
			fp->dsect = sect;
80008a9e:	8f 60       	st.w	r7[0x18],r0
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
80008aa0:	6e 2c       	ld.w	r12,r7[0x8]
80008aa2:	f9 dc c0 09 	bfextu	r12,r12,0x0,0x9
80008aa6:	e0 66 02 00 	mov	r6,512
80008aaa:	18 16       	sub	r6,r12
80008aac:	0c 35       	cp.w	r5,r6
80008aae:	ea 06 17 80 	movls	r6,r5
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
80008ab2:	0c 9a       	mov	r10,r6
80008ab4:	06 9b       	mov	r11,r3
80008ab6:	40 08       	lddsp	r8,sp[0x0]
80008ab8:	f0 0c 00 0c 	add	r12,r8,r12
80008abc:	f0 1f 00 14 	mcall	80008b0c <f_write+0x1d8>
		fp->flag |= FA__DIRTY;
80008ac0:	0f e8       	ld.ub	r8,r7[0x6]
80008ac2:	a7 a8       	sbr	r8,0x6
80008ac4:	ae e8       	st.b	r7[0x6],r8
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008ac6:	6e 28       	ld.w	r8,r7[0x8]
80008ac8:	0c 08       	add	r8,r6
80008aca:	8f 28       	st.w	r7[0x8],r8
80008acc:	68 08       	ld.w	r8,r4[0x0]
80008ace:	0c 08       	add	r8,r6
80008ad0:	89 08       	st.w	r4[0x0],r8
80008ad2:	0c 15       	sub	r5,r6
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
80008ad4:	c0 50       	breq	80008ade <f_write+0x1aa>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008ad6:	0c 03       	add	r3,r6
80008ad8:	c5 5b       	rjmp	80008982 <f_write+0x4e>
80008ada:	40 22       	lddsp	r2,sp[0x8]
80008adc:	c0 28       	rjmp	80008ae0 <f_write+0x1ac>
80008ade:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
80008ae0:	6e 28       	ld.w	r8,r7[0x8]
80008ae2:	6e 39       	ld.w	r9,r7[0xc]
80008ae4:	12 38       	cp.w	r8,r9
80008ae6:	ef f8 ba 03 	st.whi	r7[0xc],r8
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
80008aea:	0f e8       	ld.ub	r8,r7[0x6]
80008aec:	a5 b8       	sbr	r8,0x5
80008aee:	ae e8       	st.b	r7[0x6],r8

	LEAVE_FF(fp->fs, FR_OK);
}
80008af0:	04 9c       	mov	r12,r2
80008af2:	2f dd       	sub	sp,-12
80008af4:	d8 32       	popm	r0-r7,pc
80008af6:	00 00       	add	r0,r0
80008af8:	80 00       	ld.sh	r0,r0[0x0]
80008afa:	6f 60       	ld.w	r0,r7[0x58]
80008afc:	80 00       	ld.sh	r0,r0[0x0]
80008afe:	78 54       	ld.w	r4,r12[0x14]
80008b00:	80 00       	ld.sh	r0,r0[0x0]
80008b02:	66 60       	ld.w	r0,r3[0x18]
80008b04:	80 00       	ld.sh	r0,r0[0x0]
80008b06:	65 d4       	ld.w	r4,r2[0x74]
80008b08:	80 00       	ld.sh	r0,r0[0x0]
80008b0a:	66 48       	ld.w	r8,r3[0x10]
80008b0c:	80 00       	ld.sh	r0,r0[0x0]
80008b0e:	66 0c       	ld.w	r12,r3[0x0]
80008b10:	80 00       	ld.sh	r0,r0[0x0]
80008b12:	65 f0       	ld.w	r0,r2[0x7c]

80008b14 <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
80008b14:	d4 31       	pushm	r0-r7,lr
80008b16:	20 3d       	sub	sp,12
80008b18:	18 97       	mov	r7,r12
80008b1a:	16 93       	mov	r3,r11
80008b1c:	14 96       	mov	r6,r10
80008b1e:	12 94       	mov	r4,r9
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
80008b20:	30 08       	mov	r8,0
80008b22:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);							/* Check validity */
80008b24:	f0 1f 00 5e 	mcall	80008c9c <f_read+0x188>
80008b28:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008b2a:	e0 81 00 b5 	brne	80008c94 <f_read+0x180>
	if (fp->err)								/* Check error */
80008b2e:	0f f8       	ld.ub	r8,r7[0x7]
80008b30:	58 08       	cp.w	r8,0
80008b32:	c0 30       	breq	80008b38 <f_read+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008b34:	10 92       	mov	r2,r8
80008b36:	ca f8       	rjmp	80008c94 <f_read+0x180>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
80008b38:	0f e8       	ld.ub	r8,r7[0x6]
80008b3a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008b3e:	e0 80 00 a8 	breq	80008c8e <f_read+0x17a>
80008b42:	6e 35       	ld.w	r5,r7[0xc]
80008b44:	6e 28       	ld.w	r8,r7[0x8]
80008b46:	10 15       	sub	r5,r8
80008b48:	0a 36       	cp.w	r6,r5
80008b4a:	ec 05 17 80 	movls	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
80008b4e:	58 05       	cp.w	r5,0
80008b50:	e0 80 00 a2 	breq	80008c94 <f_read+0x180>
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008b54:	ee c8 ff d8 	sub	r8,r7,-40
80008b58:	50 08       	stdsp	sp[0x0],r8
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008b5a:	50 18       	stdsp	sp[0x4],r8
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008b5c:	50 2c       	stdsp	sp[0x8],r12
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
80008b5e:	6e 2b       	ld.w	r11,r7[0x8]
80008b60:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
80008b64:	c7 b1       	brne	80008c5a <f_read+0x146>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
80008b66:	6e 0c       	ld.w	r12,r7[0x0]
80008b68:	19 a6       	ld.ub	r6,r12[0x2]
80008b6a:	20 16       	sub	r6,1
80008b6c:	ed eb 02 96 	and	r6,r6,r11>>0x9
80008b70:	5c 56       	castu.b	r6
			if (!csect) {						/* On the cluster boundary? */
80008b72:	c1 d1       	brne	80008bac <f_read+0x98>
				if (fp->fptr == 0) {			/* On the top of the file? */
80008b74:	58 0b       	cp.w	r11,0
80008b76:	c0 31       	brne	80008b7c <f_read+0x68>
					clst = fp->sclust;			/* Follow from the origin */
80008b78:	6e 4c       	ld.w	r12,r7[0x10]
80008b7a:	c0 b8       	rjmp	80008b90 <f_read+0x7c>
				} else {						/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008b7c:	6e 98       	ld.w	r8,r7[0x24]
80008b7e:	58 08       	cp.w	r8,0
80008b80:	c0 50       	breq	80008b8a <f_read+0x76>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
80008b82:	0e 9c       	mov	r12,r7
80008b84:	f0 1f 00 47 	mcall	80008ca0 <f_read+0x18c>
80008b88:	c0 48       	rjmp	80008b90 <f_read+0x7c>
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
80008b8a:	6e 5b       	ld.w	r11,r7[0x14]
80008b8c:	f0 1f 00 46 	mcall	80008ca4 <f_read+0x190>
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
80008b90:	58 1c       	cp.w	r12,1
80008b92:	e0 8b 00 06 	brhi	80008b9e <f_read+0x8a>
80008b96:	30 28       	mov	r8,2
80008b98:	ae f8       	st.b	r7[0x7],r8
80008b9a:	30 22       	mov	r2,2
80008b9c:	c7 c8       	rjmp	80008c94 <f_read+0x180>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008b9e:	5b fc       	cp.w	r12,-1
80008ba0:	c0 51       	brne	80008baa <f_read+0x96>
80008ba2:	30 18       	mov	r8,1
80008ba4:	ae f8       	st.b	r7[0x7],r8
80008ba6:	30 12       	mov	r2,1
80008ba8:	c7 68       	rjmp	80008c94 <f_read+0x180>
				fp->clust = clst;				/* Update current cluster */
80008baa:	8f 5c       	st.w	r7[0x14],r12
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
80008bac:	6e 01       	ld.w	r1,r7[0x0]
80008bae:	6e 5b       	ld.w	r11,r7[0x14]
80008bb0:	02 9c       	mov	r12,r1
80008bb2:	f0 1f 00 3e 	mcall	80008ca8 <f_read+0x194>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
80008bb6:	c0 51       	brne	80008bc0 <f_read+0xac>
80008bb8:	30 28       	mov	r8,2
80008bba:	ae f8       	st.b	r7[0x7],r8
80008bbc:	30 22       	mov	r2,2
80008bbe:	c6 b8       	rjmp	80008c94 <f_read+0x180>
			sect += csect;
80008bc0:	f8 06 00 00 	add	r0,r12,r6
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
80008bc4:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {							/* Read maximum contiguous sectors directly */
80008bc8:	c2 80       	breq	80008c18 <f_read+0x104>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
80008bca:	03 a9       	ld.ub	r9,r1[0x2]
80008bcc:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
80008bd0:	12 38       	cp.w	r8,r9
80008bd2:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
80008bd6:	04 99       	mov	r9,r2
80008bd8:	00 9a       	mov	r10,r0
80008bda:	06 9b       	mov	r11,r3
80008bdc:	03 9c       	ld.ub	r12,r1[0x1]
80008bde:	f0 1f 00 34 	mcall	80008cac <f_read+0x198>
80008be2:	c0 50       	breq	80008bec <f_read+0xd8>
					ABORT(fp->fs, FR_DISK_ERR);
80008be4:	30 18       	mov	r8,1
80008be6:	ae f8       	st.b	r7[0x7],r8
80008be8:	30 12       	mov	r2,1
80008bea:	c5 58       	rjmp	80008c94 <f_read+0x180>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
80008bec:	0f e8       	ld.ub	r8,r7[0x6]
80008bee:	e2 18 00 40 	andl	r8,0x40,COH
80008bf2:	c1 00       	breq	80008c12 <f_read+0xfe>
80008bf4:	6e 6c       	ld.w	r12,r7[0x18]
80008bf6:	f8 00 01 00 	sub	r0,r12,r0
80008bfa:	00 32       	cp.w	r2,r0
80008bfc:	e0 88 00 0b 	brls	80008c12 <f_read+0xfe>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008c00:	e0 0c 15 09 	lsl	r12,r0,0x9
80008c04:	e0 6a 02 00 	mov	r10,512
80008c08:	40 0b       	lddsp	r11,sp[0x0]
80008c0a:	e6 0c 00 0c 	add	r12,r3,r12
80008c0e:	f0 1f 00 29 	mcall	80008cb0 <f_read+0x19c>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
80008c12:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
80008c16:	c3 28       	rjmp	80008c7a <f_read+0x166>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
80008c18:	6e 6a       	ld.w	r10,r7[0x18]
80008c1a:	00 3a       	cp.w	r10,r0
80008c1c:	c1 e0       	breq	80008c58 <f_read+0x144>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
80008c1e:	0f e8       	ld.ub	r8,r7[0x6]
80008c20:	e2 18 00 40 	andl	r8,0x40,COH
80008c24:	c0 e0       	breq	80008c40 <f_read+0x12c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008c26:	30 19       	mov	r9,1
80008c28:	40 1b       	lddsp	r11,sp[0x4]
80008c2a:	03 9c       	ld.ub	r12,r1[0x1]
80008c2c:	f0 1f 00 22 	mcall	80008cb4 <f_read+0x1a0>
80008c30:	c0 50       	breq	80008c3a <f_read+0x126>
						ABORT(fp->fs, FR_DISK_ERR);
80008c32:	30 18       	mov	r8,1
80008c34:	ae f8       	st.b	r7[0x7],r8
80008c36:	30 12       	mov	r2,1
80008c38:	c2 e8       	rjmp	80008c94 <f_read+0x180>
					fp->flag &= ~FA__DIRTY;
80008c3a:	0f e8       	ld.ub	r8,r7[0x6]
80008c3c:	a7 c8       	cbr	r8,0x6
80008c3e:	ae e8       	st.b	r7[0x6],r8
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
80008c40:	6e 08       	ld.w	r8,r7[0x0]
80008c42:	30 19       	mov	r9,1
80008c44:	00 9a       	mov	r10,r0
80008c46:	40 1b       	lddsp	r11,sp[0x4]
80008c48:	11 9c       	ld.ub	r12,r8[0x1]
80008c4a:	f0 1f 00 19 	mcall	80008cac <f_read+0x198>
80008c4e:	c0 50       	breq	80008c58 <f_read+0x144>
					ABORT(fp->fs, FR_DISK_ERR);
80008c50:	30 18       	mov	r8,1
80008c52:	ae f8       	st.b	r7[0x7],r8
80008c54:	30 12       	mov	r2,1
80008c56:	c1 f8       	rjmp	80008c94 <f_read+0x180>
			}
#endif
			fp->dsect = sect;
80008c58:	8f 60       	st.w	r7[0x18],r0
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
80008c5a:	6e 2b       	ld.w	r11,r7[0x8]
80008c5c:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80008c60:	e0 66 02 00 	mov	r6,512
80008c64:	16 16       	sub	r6,r11
80008c66:	0c 35       	cp.w	r5,r6
80008c68:	ea 06 17 80 	movls	r6,r5
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
80008c6c:	0c 9a       	mov	r10,r6
80008c6e:	40 08       	lddsp	r8,sp[0x0]
80008c70:	f0 0b 00 0b 	add	r11,r8,r11
80008c74:	06 9c       	mov	r12,r3
80008c76:	f0 1f 00 0f 	mcall	80008cb0 <f_read+0x19c>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
80008c7a:	6e 28       	ld.w	r8,r7[0x8]
80008c7c:	0c 08       	add	r8,r6
80008c7e:	8f 28       	st.w	r7[0x8],r8
80008c80:	68 08       	ld.w	r8,r4[0x0]
80008c82:	0c 08       	add	r8,r6
80008c84:	89 08       	st.w	r4[0x0],r8
80008c86:	0c 15       	sub	r5,r6
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
80008c88:	c0 50       	breq	80008c92 <f_read+0x17e>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
80008c8a:	0c 03       	add	r3,r6
80008c8c:	c6 9b       	rjmp	80008b5e <f_read+0x4a>
80008c8e:	30 72       	mov	r2,7
80008c90:	c0 28       	rjmp	80008c94 <f_read+0x180>
80008c92:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
80008c94:	04 9c       	mov	r12,r2
80008c96:	2f dd       	sub	sp,-12
80008c98:	d8 32       	popm	r0-r7,pc
80008c9a:	00 00       	add	r0,r0
80008c9c:	80 00       	ld.sh	r0,r0[0x0]
80008c9e:	6f 60       	ld.w	r0,r7[0x58]
80008ca0:	80 00       	ld.sh	r0,r0[0x0]
80008ca2:	66 60       	ld.w	r0,r3[0x18]
80008ca4:	80 00       	ld.sh	r0,r0[0x0]
80008ca6:	76 bc       	ld.w	r12,r11[0x2c]
80008ca8:	80 00       	ld.sh	r0,r0[0x0]
80008caa:	66 48       	ld.w	r8,r3[0x10]
80008cac:	80 00       	ld.sh	r0,r0[0x0]
80008cae:	65 f0       	ld.w	r0,r2[0x7c]
80008cb0:	80 00       	ld.sh	r0,r0[0x0]
80008cb2:	66 0c       	ld.w	r12,r3[0x0]
80008cb4:	80 00       	ld.sh	r0,r0[0x0]
80008cb6:	65 d4       	ld.w	r4,r2[0x74]

80008cb8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80008cb8:	f8 c8 ff f8 	sub	r8,r12,-8
80008cbc:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80008cbe:	3f f9       	mov	r9,-1
80008cc0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80008cc2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80008cc4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80008cc6:	30 08       	mov	r8,0
80008cc8:	99 08       	st.w	r12[0x0],r8
}
80008cca:	5e fc       	retal	r12

80008ccc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80008ccc:	30 08       	mov	r8,0
80008cce:	99 48       	st.w	r12[0x10],r8
}
80008cd0:	5e fc       	retal	r12

80008cd2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80008cd2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80008cd4:	70 19       	ld.w	r9,r8[0x4]
80008cd6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80008cd8:	78 19       	ld.w	r9,r12[0x4]
80008cda:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008cdc:	70 19       	ld.w	r9,r8[0x4]
80008cde:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80008ce0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80008ce2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008ce4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80008ce6:	78 08       	ld.w	r8,r12[0x0]
80008ce8:	2f f8       	sub	r8,-1
80008cea:	99 08       	st.w	r12[0x0],r8
}
80008cec:	5e fc       	retal	r12

80008cee <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80008cee:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80008cf0:	5b fa       	cp.w	r10,-1
80008cf2:	c0 31       	brne	80008cf8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80008cf4:	78 48       	ld.w	r8,r12[0x10]
80008cf6:	c0 c8       	rjmp	80008d0e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80008cf8:	f8 c8 ff f8 	sub	r8,r12,-8
80008cfc:	70 19       	ld.w	r9,r8[0x4]
80008cfe:	72 09       	ld.w	r9,r9[0x0]
80008d00:	12 3a       	cp.w	r10,r9
80008d02:	c0 63       	brcs	80008d0e <vListInsert+0x20>
80008d04:	70 18       	ld.w	r8,r8[0x4]
80008d06:	70 19       	ld.w	r9,r8[0x4]
80008d08:	72 09       	ld.w	r9,r9[0x0]
80008d0a:	12 3a       	cp.w	r10,r9
80008d0c:	cf c2       	brcc	80008d04 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80008d0e:	70 19       	ld.w	r9,r8[0x4]
80008d10:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008d12:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80008d14:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80008d16:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008d18:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80008d1a:	78 08       	ld.w	r8,r12[0x0]
80008d1c:	2f f8       	sub	r8,-1
80008d1e:	99 08       	st.w	r12[0x0],r8
}
80008d20:	5e fc       	retal	r12

80008d22 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80008d22:	78 18       	ld.w	r8,r12[0x4]
80008d24:	78 29       	ld.w	r9,r12[0x8]
80008d26:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80008d28:	78 28       	ld.w	r8,r12[0x8]
80008d2a:	78 19       	ld.w	r9,r12[0x4]
80008d2c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80008d2e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80008d30:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80008d32:	18 39       	cp.w	r9,r12
80008d34:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80008d38:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80008d3c:	30 09       	mov	r9,0
80008d3e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80008d40:	70 09       	ld.w	r9,r8[0x0]
80008d42:	20 19       	sub	r9,1
80008d44:	91 09       	st.w	r8[0x0],r9
}
80008d46:	5e fc       	retal	r12

80008d48 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80008d48:	e0 68 08 08 	mov	r8,2056
80008d4c:	ea 18 08 08 	orh	r8,0x808
80008d50:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80008d52:	e0 68 09 09 	mov	r8,2313
80008d56:	ea 18 09 09 	orh	r8,0x909
80008d5a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80008d5c:	e0 68 0a 0a 	mov	r8,2570
80008d60:	ea 18 0a 0a 	orh	r8,0xa0a
80008d64:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80008d66:	e0 68 0b 0b 	mov	r8,2827
80008d6a:	ea 18 0b 0b 	orh	r8,0xb0b
80008d6e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80008d70:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80008d72:	e0 68 be ef 	mov	r8,48879
80008d76:	ea 18 de ad 	orh	r8,0xdead
80008d7a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80008d7c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80008d7e:	fc 18 00 40 	movh	r8,0x40
80008d82:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80008d84:	e0 68 00 ff 	mov	r8,255
80008d88:	ea 18 ff 00 	orh	r8,0xff00
80008d8c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80008d8e:	e0 68 01 01 	mov	r8,257
80008d92:	ea 18 01 01 	orh	r8,0x101
80008d96:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80008d98:	e0 68 02 02 	mov	r8,514
80008d9c:	ea 18 02 02 	orh	r8,0x202
80008da0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80008da2:	e0 68 03 03 	mov	r8,771
80008da6:	ea 18 03 03 	orh	r8,0x303
80008daa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80008dac:	e0 68 04 04 	mov	r8,1028
80008db0:	ea 18 04 04 	orh	r8,0x404
80008db4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80008db6:	e0 68 05 05 	mov	r8,1285
80008dba:	ea 18 05 05 	orh	r8,0x505
80008dbe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80008dc0:	e0 68 06 06 	mov	r8,1542
80008dc4:	ea 18 06 06 	orh	r8,0x606
80008dc8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80008dca:	e0 68 07 07 	mov	r8,1799
80008dce:	ea 18 07 07 	orh	r8,0x707
80008dd2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80008dd4:	30 08       	mov	r8,0
80008dd6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80008dd8:	5e fc       	retal	r12
80008dda:	d7 03       	nop

80008ddc <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80008ddc:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80008dde:	48 38       	lddpc	r8,80008de8 <vPortEnterCritical+0xc>
80008de0:	70 09       	ld.w	r9,r8[0x0]
80008de2:	2f f9       	sub	r9,-1
80008de4:	91 09       	st.w	r8[0x0],r9
}
80008de6:	5e fc       	retal	r12
80008de8:	00 00       	add	r0,r0
80008dea:	05 30       	ld.ub	r0,r2++

80008dec <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80008dec:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80008dee:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80008df0:	30 0a       	mov	r10,0
80008df2:	14 9b       	mov	r11,r10
80008df4:	49 2c       	lddpc	r12,80008e3c <xPortStartScheduler+0x50>
80008df6:	f0 1f 00 13 	mcall	80008e40 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80008dfa:	e0 68 5d c0 	mov	r8,24000
80008dfe:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80008e02:	30 08       	mov	r8,0
80008e04:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80008e08:	e0 68 12 b0 	mov	r8,4784
80008e0c:	ea 18 00 00 	orh	r8,0x0
80008e10:	70 00       	ld.w	r0,r8[0x0]
80008e12:	60 0d       	ld.w	sp,r0[0x0]
80008e14:	1b 00       	ld.w	r0,sp++
80008e16:	e0 68 05 30 	mov	r8,1328
80008e1a:	ea 18 00 00 	orh	r8,0x0
80008e1e:	91 00       	st.w	r8[0x0],r0
80008e20:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008e24:	2f ed       	sub	sp,-8
80008e26:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80008e2a:	fa f0 ff e0 	ld.w	r0,sp[-32]
80008e2e:	e3 b0 00 00 	mtsr	0x0,r0
80008e32:	fa f0 ff dc 	ld.w	r0,sp[-36]
80008e36:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80008e3a:	d8 0a       	popm	pc,r12=0
80008e3c:	80 00       	ld.sh	r0,r0[0x0]
80008e3e:	8f 08       	st.w	r7[0x0],r8
80008e40:	80 00       	ld.sh	r0,r0[0x0]
80008e42:	5d 08       	ror	r8

80008e44 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80008e44:	20 6d       	sub	sp,24
80008e46:	eb cd 00 ff 	pushm	r0-r7
80008e4a:	fa c7 ff c0 	sub	r7,sp,-64
80008e4e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80008e52:	ef 40 ff e0 	st.w	r7[-32],r0
80008e56:	ee f0 ff fc 	ld.w	r0,r7[-4]
80008e5a:	ef 40 ff e4 	st.w	r7[-28],r0
80008e5e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80008e62:	e0 68 05 30 	mov	r8,1328
80008e66:	ea 18 00 00 	orh	r8,0x0
80008e6a:	70 00       	ld.w	r0,r8[0x0]
80008e6c:	1a d0       	st.w	--sp,r0
80008e6e:	f0 1f 00 1a 	mcall	80008ed4 <LABEL_RET_SCALL_263+0x14>
80008e72:	e0 68 12 b0 	mov	r8,4784
80008e76:	ea 18 00 00 	orh	r8,0x0
80008e7a:	70 00       	ld.w	r0,r8[0x0]
80008e7c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80008e7e:	f0 1f 00 17 	mcall	80008ed8 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80008e82:	e0 68 12 b0 	mov	r8,4784
80008e86:	ea 18 00 00 	orh	r8,0x0
80008e8a:	70 00       	ld.w	r0,r8[0x0]
80008e8c:	60 0d       	ld.w	sp,r0[0x0]
80008e8e:	1b 00       	ld.w	r0,sp++
80008e90:	e0 68 05 30 	mov	r8,1328
80008e94:	ea 18 00 00 	orh	r8,0x0
80008e98:	91 00       	st.w	r8[0x0],r0
80008e9a:	fa c7 ff d8 	sub	r7,sp,-40
80008e9e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80008ea2:	ee f0 ff e0 	ld.w	r0,r7[-32]
80008ea6:	e0 61 05 30 	mov	r1,1328
80008eaa:	ea 11 00 00 	orh	r1,0x0
80008eae:	62 02       	ld.w	r2,r1[0x0]
80008eb0:	58 02       	cp.w	r2,0
80008eb2:	c0 70       	breq	80008ec0 <LABEL_RET_SCALL_263>
80008eb4:	e4 c2 00 01 	sub	r2,r2,1
80008eb8:	83 02       	st.w	r1[0x0],r2
80008eba:	58 02       	cp.w	r2,0
80008ebc:	c0 21       	brne	80008ec0 <LABEL_RET_SCALL_263>
80008ebe:	b1 c0       	cbr	r0,0x10

80008ec0 <LABEL_RET_SCALL_263>:
80008ec0:	ef 40 ff f8 	st.w	r7[-8],r0
80008ec4:	ee f0 ff e4 	ld.w	r0,r7[-28]
80008ec8:	ef 40 ff fc 	st.w	r7[-4],r0
80008ecc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008ed0:	2f ad       	sub	sp,-24
80008ed2:	d6 13       	rets
80008ed4:	80 00       	ld.sh	r0,r0[0x0]
80008ed6:	8d dc       	st.w	r6[0x34],r12
80008ed8:	80 00       	ld.sh	r0,r0[0x0]
80008eda:	95 78       	st.w	r10[0x1c],r8

80008edc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80008edc:	e1 b8 00 43 	mfsr	r8,0x10c
80008ee0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80008ee4:	5e fc       	retal	r12
80008ee6:	d7 03       	nop

80008ee8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80008ee8:	48 78       	lddpc	r8,80008f04 <vPortExitCritical+0x1c>
80008eea:	70 08       	ld.w	r8,r8[0x0]
80008eec:	58 08       	cp.w	r8,0
80008eee:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80008ef0:	48 58       	lddpc	r8,80008f04 <vPortExitCritical+0x1c>
80008ef2:	70 09       	ld.w	r9,r8[0x0]
80008ef4:	20 19       	sub	r9,1
80008ef6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80008ef8:	70 08       	ld.w	r8,r8[0x0]
80008efa:	58 08       	cp.w	r8,0
80008efc:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80008efe:	d5 03       	csrf	0x10
80008f00:	5e fc       	retal	r12
80008f02:	00 00       	add	r0,r0
80008f04:	00 00       	add	r0,r0
80008f06:	05 30       	ld.ub	r0,r2++

80008f08 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80008f08:	eb cd 00 ff 	pushm	r0-r7
80008f0c:	e0 68 05 30 	mov	r8,1328
80008f10:	ea 18 00 00 	orh	r8,0x0
80008f14:	70 00       	ld.w	r0,r8[0x0]
80008f16:	1a d0       	st.w	--sp,r0
80008f18:	7a 90       	ld.w	r0,sp[0x24]
80008f1a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008f1e:	58 10       	cp.w	r0,1
80008f20:	e0 8b 00 08 	brhi	80008f30 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80008f24:	e0 68 12 b0 	mov	r8,4784
80008f28:	ea 18 00 00 	orh	r8,0x0
80008f2c:	70 00       	ld.w	r0,r8[0x0]
80008f2e:	81 0d       	st.w	r0[0x0],sp

80008f30 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80008f30:	f0 1f 00 12 	mcall	80008f78 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80008f34:	f0 1f 00 12 	mcall	80008f7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80008f38:	f0 1f 00 12 	mcall	80008f80 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80008f3c:	f0 1f 00 12 	mcall	80008f84 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80008f40:	7a 90       	ld.w	r0,sp[0x24]
80008f42:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008f46:	58 10       	cp.w	r0,1
80008f48:	e0 8b 00 0e 	brhi	80008f64 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80008f4c:	f0 1f 00 0c 	mcall	80008f7c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80008f50:	f0 1f 00 0e 	mcall	80008f88 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80008f54:	f0 1f 00 0c 	mcall	80008f84 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80008f58:	e0 68 12 b0 	mov	r8,4784
80008f5c:	ea 18 00 00 	orh	r8,0x0
80008f60:	70 00       	ld.w	r0,r8[0x0]
80008f62:	60 0d       	ld.w	sp,r0[0x0]

80008f64 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80008f64:	1b 00       	ld.w	r0,sp++
80008f66:	e0 68 05 30 	mov	r8,1328
80008f6a:	ea 18 00 00 	orh	r8,0x0
80008f6e:	91 00       	st.w	r8[0x0],r0
80008f70:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008f74:	d6 03       	rete
80008f76:	00 00       	add	r0,r0
80008f78:	80 00       	ld.sh	r0,r0[0x0]
80008f7a:	8e dc       	ld.uh	r12,r7[0xa]
80008f7c:	80 00       	ld.sh	r0,r0[0x0]
80008f7e:	8d dc       	st.w	r6[0x34],r12
80008f80:	80 00       	ld.sh	r0,r0[0x0]
80008f82:	97 7c       	st.w	r11[0x1c],r12
80008f84:	80 00       	ld.sh	r0,r0[0x0]
80008f86:	8e e8       	ld.uh	r8,r7[0xc]
80008f88:	80 00       	ld.sh	r0,r0[0x0]
80008f8a:	95 78       	st.w	r10[0x1c],r8

80008f8c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80008f8c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80008f8e:	f0 1f 00 02 	mcall	80008f94 <__malloc_lock+0x8>
}
80008f92:	d8 02       	popm	pc
80008f94:	80 00       	ld.sh	r0,r0[0x0]
80008f96:	95 68       	st.w	r10[0x18],r8

80008f98 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80008f98:	d4 01       	pushm	lr
	xTaskResumeAll();
80008f9a:	f0 1f 00 02 	mcall	80008fa0 <__malloc_unlock+0x8>
}
80008f9e:	d8 02       	popm	pc
80008fa0:	80 00       	ld.sh	r0,r0[0x0]
80008fa2:	99 24       	st.w	r12[0x8],r4

80008fa4 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80008fa4:	d4 21       	pushm	r4-r7,lr
80008fa6:	16 95       	mov	r5,r11
80008fa8:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80008faa:	58 0c       	cp.w	r12,0
80008fac:	c0 30       	breq	80008fb2 <_read+0xe>
80008fae:	3f f7       	mov	r7,-1
80008fb0:	c1 48       	rjmp	80008fd8 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80008fb2:	58 0a       	cp.w	r10,0
80008fb4:	e0 89 00 04 	brgt	80008fbc <_read+0x18>
80008fb8:	30 07       	mov	r7,0
80008fba:	c0 f8       	rjmp	80008fd8 <_read+0x34>
80008fbc:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80008fbe:	48 84       	lddpc	r4,80008fdc <_read+0x38>
80008fc0:	68 0c       	ld.w	r12,r4[0x0]
80008fc2:	f0 1f 00 08 	mcall	80008fe0 <_read+0x3c>
    if (c < 0)
80008fc6:	c0 95       	brlt	80008fd8 <_read+0x34>
      break;

    *ptr++ = c;
80008fc8:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80008fcc:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80008fce:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80008fd2:	58 08       	cp.w	r8,0
80008fd4:	fe 99 ff f6 	brgt	80008fc0 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80008fd8:	0e 9c       	mov	r12,r7
80008fda:	d8 22       	popm	r4-r7,pc
80008fdc:	00 00       	add	r0,r0
80008fde:	46 ac       	lddsp	r12,sp[0x1a8]
80008fe0:	80 00       	ld.sh	r0,r0[0x0]
80008fe2:	63 fc       	ld.w	r12,r1[0x7c]

80008fe4 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80008fe4:	d4 21       	pushm	r4-r7,lr
80008fe6:	16 95       	mov	r5,r11
80008fe8:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80008fea:	20 1c       	sub	r12,1
80008fec:	58 2c       	cp.w	r12,2
80008fee:	e0 8b 00 12 	brhi	80009012 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008ff2:	58 0a       	cp.w	r10,0
80008ff4:	c0 31       	brne	80008ffa <_write+0x16>
80008ff6:	30 07       	mov	r7,0
80008ff8:	c0 e8       	rjmp	80009014 <_write+0x30>
80008ffa:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80008ffc:	48 74       	lddpc	r4,80009018 <_write+0x34>
80008ffe:	68 0c       	ld.w	r12,r4[0x0]
80009000:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80009004:	f0 1f 00 06 	mcall	8000901c <_write+0x38>
80009008:	c0 55       	brlt	80009012 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000900a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000900c:	0e 36       	cp.w	r6,r7
8000900e:	cf 81       	brne	80008ffe <_write+0x1a>
80009010:	c0 28       	rjmp	80009014 <_write+0x30>
80009012:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80009014:	0e 9c       	mov	r12,r7
80009016:	d8 22       	popm	r4-r7,pc
80009018:	00 00       	add	r0,r0
8000901a:	46 ac       	lddsp	r12,sp[0x1a8]
8000901c:	80 00       	ld.sh	r0,r0[0x0]
8000901e:	63 ac       	ld.w	r12,r1[0x68]

80009020 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80009020:	eb cd 40 80 	pushm	r7,lr
80009024:	18 97       	mov	r7,r12
	if( pv )
80009026:	58 0c       	cp.w	r12,0
80009028:	c0 80       	breq	80009038 <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000902a:	f0 1f 00 05 	mcall	8000903c <vPortFree+0x1c>
		{
			free( pv );
8000902e:	0e 9c       	mov	r12,r7
80009030:	f0 1f 00 04 	mcall	80009040 <vPortFree+0x20>
		}
		xTaskResumeAll();
80009034:	f0 1f 00 04 	mcall	80009044 <vPortFree+0x24>
80009038:	e3 cd 80 80 	ldm	sp++,r7,pc
8000903c:	80 00       	ld.sh	r0,r0[0x0]
8000903e:	95 68       	st.w	r10[0x18],r8
80009040:	80 00       	ld.sh	r0,r0[0x0]
80009042:	a4 d4       	st.b	r2[0x5],r4
80009044:	80 00       	ld.sh	r0,r0[0x0]
80009046:	99 24       	st.w	r12[0x8],r4

80009048 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80009048:	eb cd 40 80 	pushm	r7,lr
8000904c:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000904e:	f0 1f 00 06 	mcall	80009064 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80009052:	0e 9c       	mov	r12,r7
80009054:	f0 1f 00 05 	mcall	80009068 <pvPortMalloc+0x20>
80009058:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000905a:	f0 1f 00 05 	mcall	8000906c <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000905e:	0e 9c       	mov	r12,r7
80009060:	e3 cd 80 80 	ldm	sp++,r7,pc
80009064:	80 00       	ld.sh	r0,r0[0x0]
80009066:	95 68       	st.w	r10[0x18],r8
80009068:	80 00       	ld.sh	r0,r0[0x0]
8000906a:	a4 e4       	st.b	r2[0x6],r4
8000906c:	80 00       	ld.sh	r0,r0[0x0]
8000906e:	99 24       	st.w	r12[0x8],r4

80009070 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80009070:	d4 01       	pushm	lr
80009072:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80009074:	78 09       	ld.w	r9,r12[0x0]
80009076:	58 09       	cp.w	r9,0
80009078:	c1 10       	breq	8000909a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000907a:	78 3a       	ld.w	r10,r12[0xc]
8000907c:	79 09       	ld.w	r9,r12[0x40]
8000907e:	f4 09 00 09 	add	r9,r10,r9
80009082:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80009084:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80009086:	14 39       	cp.w	r9,r10
80009088:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
8000908c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80009090:	79 0a       	ld.w	r10,r12[0x40]
80009092:	78 3b       	ld.w	r11,r12[0xc]
80009094:	10 9c       	mov	r12,r8
80009096:	f0 1f 00 02 	mcall	8000909c <prvCopyDataFromQueue+0x2c>
8000909a:	d8 02       	popm	pc
8000909c:	80 00       	ld.sh	r0,r0[0x0]
8000909e:	a9 52       	asr	r2,0x9

800090a0 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800090a0:	eb cd 40 c0 	pushm	r6-r7,lr
800090a4:	18 97       	mov	r7,r12
800090a6:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800090a8:	78 e8       	ld.w	r8,r12[0x38]
800090aa:	58 08       	cp.w	r8,0
800090ac:	c0 31       	brne	800090b2 <xQueueReceiveFromISR+0x12>
800090ae:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800090b2:	f0 1f 00 0e 	mcall	800090e8 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800090b6:	6e e8       	ld.w	r8,r7[0x38]
800090b8:	20 18       	sub	r8,1
800090ba:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800090bc:	6f 18       	ld.w	r8,r7[0x44]
800090be:	5b f8       	cp.w	r8,-1
800090c0:	c0 d1       	brne	800090da <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800090c2:	6e 48       	ld.w	r8,r7[0x10]
800090c4:	58 08       	cp.w	r8,0
800090c6:	c0 f0       	breq	800090e4 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800090c8:	ee cc ff f0 	sub	r12,r7,-16
800090cc:	f0 1f 00 08 	mcall	800090ec <xQueueReceiveFromISR+0x4c>
800090d0:	c0 a0       	breq	800090e4 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800090d2:	30 1c       	mov	r12,1
800090d4:	8d 0c       	st.w	r6[0x0],r12
800090d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800090da:	2f f8       	sub	r8,-1
800090dc:	ef 48 00 44 	st.w	r7[68],r8
800090e0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800090e4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800090e8:	80 00       	ld.sh	r0,r0[0x0]
800090ea:	90 70       	ld.sh	r0,r8[0xe]
800090ec:	80 00       	ld.sh	r0,r0[0x0]
800090ee:	97 00       	st.w	r11[0x0],r0

800090f0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800090f0:	eb cd 40 c0 	pushm	r6-r7,lr
800090f4:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800090f6:	f0 1f 00 23 	mcall	80009180 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800090fa:	6f 28       	ld.w	r8,r7[0x48]
800090fc:	58 08       	cp.w	r8,0
800090fe:	e0 8a 00 18 	brle	8000912e <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80009102:	6e 98       	ld.w	r8,r7[0x24]
80009104:	58 08       	cp.w	r8,0
80009106:	c1 40       	breq	8000912e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80009108:	ee c6 ff dc 	sub	r6,r7,-36
8000910c:	c0 48       	rjmp	80009114 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000910e:	6e 98       	ld.w	r8,r7[0x24]
80009110:	58 08       	cp.w	r8,0
80009112:	c0 e0       	breq	8000912e <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80009114:	0c 9c       	mov	r12,r6
80009116:	f0 1f 00 1c 	mcall	80009184 <prvUnlockQueue+0x94>
8000911a:	c0 30       	breq	80009120 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000911c:	f0 1f 00 1b 	mcall	80009188 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80009120:	6f 28       	ld.w	r8,r7[0x48]
80009122:	20 18       	sub	r8,1
80009124:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80009128:	58 08       	cp.w	r8,0
8000912a:	fe 99 ff f2 	brgt	8000910e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000912e:	3f f8       	mov	r8,-1
80009130:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80009134:	f0 1f 00 16 	mcall	8000918c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80009138:	f0 1f 00 12 	mcall	80009180 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000913c:	6f 18       	ld.w	r8,r7[0x44]
8000913e:	58 08       	cp.w	r8,0
80009140:	e0 8a 00 18 	brle	80009170 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80009144:	6e 48       	ld.w	r8,r7[0x10]
80009146:	58 08       	cp.w	r8,0
80009148:	c1 40       	breq	80009170 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000914a:	ee c6 ff f0 	sub	r6,r7,-16
8000914e:	c0 48       	rjmp	80009156 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80009150:	6e 48       	ld.w	r8,r7[0x10]
80009152:	58 08       	cp.w	r8,0
80009154:	c0 e0       	breq	80009170 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80009156:	0c 9c       	mov	r12,r6
80009158:	f0 1f 00 0b 	mcall	80009184 <prvUnlockQueue+0x94>
8000915c:	c0 30       	breq	80009162 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000915e:	f0 1f 00 0b 	mcall	80009188 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80009162:	6f 18       	ld.w	r8,r7[0x44]
80009164:	20 18       	sub	r8,1
80009166:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000916a:	58 08       	cp.w	r8,0
8000916c:	fe 99 ff f2 	brgt	80009150 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80009170:	3f f8       	mov	r8,-1
80009172:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80009176:	f0 1f 00 06 	mcall	8000918c <prvUnlockQueue+0x9c>
}
8000917a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000917e:	00 00       	add	r0,r0
80009180:	80 00       	ld.sh	r0,r0[0x0]
80009182:	8d dc       	st.w	r6[0x34],r12
80009184:	80 00       	ld.sh	r0,r0[0x0]
80009186:	97 00       	st.w	r11[0x0],r0
80009188:	80 00       	ld.sh	r0,r0[0x0]
8000918a:	96 0c       	ld.sh	r12,r11[0x0]
8000918c:	80 00       	ld.sh	r0,r0[0x0]
8000918e:	8e e8       	ld.uh	r8,r7[0xc]

80009190 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80009190:	d4 31       	pushm	r0-r7,lr
80009192:	20 5d       	sub	sp,20
80009194:	18 97       	mov	r7,r12
80009196:	50 0b       	stdsp	sp[0x0],r11
80009198:	50 2a       	stdsp	sp[0x8],r10
8000919a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000919c:	f8 c2 ff dc 	sub	r2,r12,-36
800091a0:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800091a2:	fa c4 ff f4 	sub	r4,sp,-12
800091a6:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800091a8:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800091aa:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800091ae:	f0 1f 00 3e 	mcall	800092a4 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800091b2:	6e e8       	ld.w	r8,r7[0x38]
800091b4:	58 08       	cp.w	r8,0
800091b6:	c2 a0       	breq	8000920a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800091b8:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800091ba:	40 0b       	lddsp	r11,sp[0x0]
800091bc:	0e 9c       	mov	r12,r7
800091be:	f0 1f 00 3b 	mcall	800092a8 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800091c2:	40 18       	lddsp	r8,sp[0x4]
800091c4:	58 08       	cp.w	r8,0
800091c6:	c1 51       	brne	800091f0 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800091c8:	6e e8       	ld.w	r8,r7[0x38]
800091ca:	20 18       	sub	r8,1
800091cc:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800091ce:	6e 08       	ld.w	r8,r7[0x0]
800091d0:	58 08       	cp.w	r8,0
800091d2:	c0 41       	brne	800091da <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800091d4:	f0 1f 00 36 	mcall	800092ac <xQueueGenericReceive+0x11c>
800091d8:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800091da:	6e 48       	ld.w	r8,r7[0x10]
800091dc:	58 08       	cp.w	r8,0
800091de:	c1 20       	breq	80009202 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800091e0:	ee cc ff f0 	sub	r12,r7,-16
800091e4:	f0 1f 00 33 	mcall	800092b0 <xQueueGenericReceive+0x120>
800091e8:	58 1c       	cp.w	r12,1
800091ea:	c0 c1       	brne	80009202 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800091ec:	d7 33       	scall
800091ee:	c0 a8       	rjmp	80009202 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800091f0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800091f2:	6e 98       	ld.w	r8,r7[0x24]
800091f4:	58 08       	cp.w	r8,0
800091f6:	c0 60       	breq	80009202 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800091f8:	04 9c       	mov	r12,r2
800091fa:	f0 1f 00 2e 	mcall	800092b0 <xQueueGenericReceive+0x120>
800091fe:	c0 20       	breq	80009202 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80009200:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80009202:	f0 1f 00 2d 	mcall	800092b4 <xQueueGenericReceive+0x124>
80009206:	30 1c       	mov	r12,1
				return pdPASS;
80009208:	c4 c8       	rjmp	800092a0 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000920a:	40 28       	lddsp	r8,sp[0x8]
8000920c:	58 08       	cp.w	r8,0
8000920e:	c0 51       	brne	80009218 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80009210:	f0 1f 00 29 	mcall	800092b4 <xQueueGenericReceive+0x124>
80009214:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80009216:	c4 58       	rjmp	800092a0 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80009218:	58 05       	cp.w	r5,0
8000921a:	c0 51       	brne	80009224 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000921c:	08 9c       	mov	r12,r4
8000921e:	f0 1f 00 27 	mcall	800092b8 <xQueueGenericReceive+0x128>
80009222:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80009224:	f0 1f 00 24 	mcall	800092b4 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80009228:	f0 1f 00 25 	mcall	800092bc <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
8000922c:	f0 1f 00 1e 	mcall	800092a4 <xQueueGenericReceive+0x114>
80009230:	6f 18       	ld.w	r8,r7[0x44]
80009232:	5b f8       	cp.w	r8,-1
80009234:	ef f1 0a 11 	st.weq	r7[0x44],r1
80009238:	6f 28       	ld.w	r8,r7[0x48]
8000923a:	5b f8       	cp.w	r8,-1
8000923c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80009240:	f0 1f 00 1d 	mcall	800092b4 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80009244:	06 9b       	mov	r11,r3
80009246:	08 9c       	mov	r12,r4
80009248:	f0 1f 00 1e 	mcall	800092c0 <xQueueGenericReceive+0x130>
8000924c:	c2 41       	brne	80009294 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000924e:	f0 1f 00 16 	mcall	800092a4 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80009252:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80009254:	f0 1f 00 18 	mcall	800092b4 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80009258:	58 06       	cp.w	r6,0
8000925a:	c1 71       	brne	80009288 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000925c:	6e 08       	ld.w	r8,r7[0x0]
8000925e:	58 08       	cp.w	r8,0
80009260:	c0 81       	brne	80009270 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80009262:	f0 1f 00 11 	mcall	800092a4 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80009266:	6e 1c       	ld.w	r12,r7[0x4]
80009268:	f0 1f 00 17 	mcall	800092c4 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
8000926c:	f0 1f 00 12 	mcall	800092b4 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80009270:	40 2b       	lddsp	r11,sp[0x8]
80009272:	04 9c       	mov	r12,r2
80009274:	f0 1f 00 15 	mcall	800092c8 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80009278:	0e 9c       	mov	r12,r7
8000927a:	f0 1f 00 15 	mcall	800092cc <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
8000927e:	f0 1f 00 15 	mcall	800092d0 <xQueueGenericReceive+0x140>
80009282:	c9 61       	brne	800091ae <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80009284:	d7 33       	scall
80009286:	c9 4b       	rjmp	800091ae <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80009288:	0e 9c       	mov	r12,r7
8000928a:	f0 1f 00 11 	mcall	800092cc <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000928e:	f0 1f 00 11 	mcall	800092d0 <xQueueGenericReceive+0x140>
80009292:	c8 eb       	rjmp	800091ae <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80009294:	0e 9c       	mov	r12,r7
80009296:	f0 1f 00 0e 	mcall	800092cc <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000929a:	f0 1f 00 0e 	mcall	800092d0 <xQueueGenericReceive+0x140>
8000929e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800092a0:	2f bd       	sub	sp,-20
800092a2:	d8 32       	popm	r0-r7,pc
800092a4:	80 00       	ld.sh	r0,r0[0x0]
800092a6:	8d dc       	st.w	r6[0x34],r12
800092a8:	80 00       	ld.sh	r0,r0[0x0]
800092aa:	90 70       	ld.sh	r0,r8[0xe]
800092ac:	80 00       	ld.sh	r0,r0[0x0]
800092ae:	96 18       	ld.sh	r8,r11[0x2]
800092b0:	80 00       	ld.sh	r0,r0[0x0]
800092b2:	97 00       	st.w	r11[0x0],r0
800092b4:	80 00       	ld.sh	r0,r0[0x0]
800092b6:	8e e8       	ld.uh	r8,r7[0xc]
800092b8:	80 00       	ld.sh	r0,r0[0x0]
800092ba:	95 f4       	st.w	r10[0x3c],r4
800092bc:	80 00       	ld.sh	r0,r0[0x0]
800092be:	95 68       	st.w	r10[0x18],r8
800092c0:	80 00       	ld.sh	r0,r0[0x0]
800092c2:	98 90       	ld.uh	r0,r12[0x2]
800092c4:	80 00       	ld.sh	r0,r0[0x0]
800092c6:	96 7c       	ld.sh	r12,r11[0xe]
800092c8:	80 00       	ld.sh	r0,r0[0x0]
800092ca:	9a e8       	ld.uh	r8,sp[0xc]
800092cc:	80 00       	ld.sh	r0,r0[0x0]
800092ce:	90 f0       	ld.uh	r0,r8[0xe]
800092d0:	80 00       	ld.sh	r0,r0[0x0]
800092d2:	99 24       	st.w	r12[0x8],r4

800092d4 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800092d4:	eb cd 40 80 	pushm	r7,lr
800092d8:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800092da:	79 08       	ld.w	r8,r12[0x40]
800092dc:	58 08       	cp.w	r8,0
800092de:	c0 a1       	brne	800092f2 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800092e0:	78 08       	ld.w	r8,r12[0x0]
800092e2:	58 08       	cp.w	r8,0
800092e4:	c2 b1       	brne	8000933a <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800092e6:	78 1c       	ld.w	r12,r12[0x4]
800092e8:	f0 1f 00 17 	mcall	80009344 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800092ec:	30 08       	mov	r8,0
800092ee:	8f 18       	st.w	r7[0x4],r8
800092f0:	c2 58       	rjmp	8000933a <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800092f2:	58 0a       	cp.w	r10,0
800092f4:	c1 01       	brne	80009314 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800092f6:	10 9a       	mov	r10,r8
800092f8:	78 2c       	ld.w	r12,r12[0x8]
800092fa:	f0 1f 00 14 	mcall	80009348 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800092fe:	6e 29       	ld.w	r9,r7[0x8]
80009300:	6f 08       	ld.w	r8,r7[0x40]
80009302:	f2 08 00 08 	add	r8,r9,r8
80009306:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80009308:	6e 19       	ld.w	r9,r7[0x4]
8000930a:	12 38       	cp.w	r8,r9
8000930c:	c1 73       	brcs	8000933a <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000930e:	6e 08       	ld.w	r8,r7[0x0]
80009310:	8f 28       	st.w	r7[0x8],r8
80009312:	c1 48       	rjmp	8000933a <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80009314:	10 9a       	mov	r10,r8
80009316:	78 3c       	ld.w	r12,r12[0xc]
80009318:	f0 1f 00 0c 	mcall	80009348 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000931c:	6f 08       	ld.w	r8,r7[0x40]
8000931e:	6e 39       	ld.w	r9,r7[0xc]
80009320:	f2 08 01 08 	sub	r8,r9,r8
80009324:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80009326:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80009328:	12 38       	cp.w	r8,r9
8000932a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000932e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80009332:	f3 d8 e3 19 	subcs	r9,r9,r8
80009336:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000933a:	6e e8       	ld.w	r8,r7[0x38]
8000933c:	2f f8       	sub	r8,-1
8000933e:	8f e8       	st.w	r7[0x38],r8
}
80009340:	e3 cd 80 80 	ldm	sp++,r7,pc
80009344:	80 00       	ld.sh	r0,r0[0x0]
80009346:	96 24       	ld.sh	r4,r11[0x4]
80009348:	80 00       	ld.sh	r0,r0[0x0]
8000934a:	a9 52       	asr	r2,0x9

8000934c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
8000934c:	eb cd 40 c0 	pushm	r6-r7,lr
80009350:	18 97       	mov	r7,r12
80009352:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80009354:	78 ec       	ld.w	r12,r12[0x38]
80009356:	6e f8       	ld.w	r8,r7[0x3c]
80009358:	10 3c       	cp.w	r12,r8
8000935a:	c0 33       	brcs	80009360 <xQueueGenericSendFromISR+0x14>
8000935c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80009360:	12 9a       	mov	r10,r9
80009362:	0e 9c       	mov	r12,r7
80009364:	f0 1f 00 0c 	mcall	80009394 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80009368:	6f 28       	ld.w	r8,r7[0x48]
8000936a:	5b f8       	cp.w	r8,-1
8000936c:	c0 d1       	brne	80009386 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000936e:	6e 98       	ld.w	r8,r7[0x24]
80009370:	58 08       	cp.w	r8,0
80009372:	c0 f0       	breq	80009390 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80009374:	ee cc ff dc 	sub	r12,r7,-36
80009378:	f0 1f 00 08 	mcall	80009398 <xQueueGenericSendFromISR+0x4c>
8000937c:	c0 a0       	breq	80009390 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
8000937e:	30 1c       	mov	r12,1
80009380:	8d 0c       	st.w	r6[0x0],r12
80009382:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80009386:	2f f8       	sub	r8,-1
80009388:	ef 48 00 48 	st.w	r7[72],r8
8000938c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009390:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009394:	80 00       	ld.sh	r0,r0[0x0]
80009396:	92 d4       	ld.uh	r4,r9[0xa]
80009398:	80 00       	ld.sh	r0,r0[0x0]
8000939a:	97 00       	st.w	r11[0x0],r0

8000939c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000939c:	d4 31       	pushm	r0-r7,lr
8000939e:	20 5d       	sub	sp,20
800093a0:	18 97       	mov	r7,r12
800093a2:	50 0b       	stdsp	sp[0x0],r11
800093a4:	50 2a       	stdsp	sp[0x8],r10
800093a6:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800093a8:	f8 c0 ff f0 	sub	r0,r12,-16
800093ac:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800093ae:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800093b2:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800093b4:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800093b8:	f0 1f 00 2f 	mcall	80009474 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800093bc:	6e e9       	ld.w	r9,r7[0x38]
800093be:	6e f8       	ld.w	r8,r7[0x3c]
800093c0:	10 39       	cp.w	r9,r8
800093c2:	c1 42       	brcc	800093ea <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800093c4:	40 1a       	lddsp	r10,sp[0x4]
800093c6:	40 0b       	lddsp	r11,sp[0x0]
800093c8:	0e 9c       	mov	r12,r7
800093ca:	f0 1f 00 2c 	mcall	80009478 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800093ce:	6e 98       	ld.w	r8,r7[0x24]
800093d0:	58 08       	cp.w	r8,0
800093d2:	c0 80       	breq	800093e2 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800093d4:	ee cc ff dc 	sub	r12,r7,-36
800093d8:	f0 1f 00 29 	mcall	8000947c <xQueueGenericSend+0xe0>
800093dc:	58 1c       	cp.w	r12,1
800093de:	c0 21       	brne	800093e2 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800093e0:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800093e2:	f0 1f 00 28 	mcall	80009480 <xQueueGenericSend+0xe4>
800093e6:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800093e8:	c4 38       	rjmp	8000946e <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800093ea:	40 28       	lddsp	r8,sp[0x8]
800093ec:	58 08       	cp.w	r8,0
800093ee:	c0 51       	brne	800093f8 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800093f0:	f0 1f 00 24 	mcall	80009480 <xQueueGenericSend+0xe4>
800093f4:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800093f6:	c3 c8       	rjmp	8000946e <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800093f8:	58 04       	cp.w	r4,0
800093fa:	c0 51       	brne	80009404 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800093fc:	06 9c       	mov	r12,r3
800093fe:	f0 1f 00 22 	mcall	80009484 <xQueueGenericSend+0xe8>
80009402:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80009404:	f0 1f 00 1f 	mcall	80009480 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80009408:	f0 1f 00 20 	mcall	80009488 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000940c:	f0 1f 00 1a 	mcall	80009474 <xQueueGenericSend+0xd8>
80009410:	6f 18       	ld.w	r8,r7[0x44]
80009412:	5b f8       	cp.w	r8,-1
80009414:	ef f1 0a 11 	st.weq	r7[0x44],r1
80009418:	6f 28       	ld.w	r8,r7[0x48]
8000941a:	5b f8       	cp.w	r8,-1
8000941c:	ef f1 0a 12 	st.weq	r7[0x48],r1
80009420:	f0 1f 00 18 	mcall	80009480 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80009424:	04 9b       	mov	r11,r2
80009426:	06 9c       	mov	r12,r3
80009428:	f0 1f 00 19 	mcall	8000948c <xQueueGenericSend+0xf0>
8000942c:	c1 b1       	brne	80009462 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000942e:	f0 1f 00 12 	mcall	80009474 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80009432:	6e e5       	ld.w	r5,r7[0x38]
80009434:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80009436:	f0 1f 00 13 	mcall	80009480 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000943a:	0c 35       	cp.w	r5,r6
8000943c:	c0 d1       	brne	80009456 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000943e:	40 2b       	lddsp	r11,sp[0x8]
80009440:	00 9c       	mov	r12,r0
80009442:	f0 1f 00 14 	mcall	80009490 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80009446:	0e 9c       	mov	r12,r7
80009448:	f0 1f 00 13 	mcall	80009494 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
8000944c:	f0 1f 00 13 	mcall	80009498 <xQueueGenericSend+0xfc>
80009450:	cb 41       	brne	800093b8 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80009452:	d7 33       	scall
80009454:	cb 2b       	rjmp	800093b8 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80009456:	0e 9c       	mov	r12,r7
80009458:	f0 1f 00 0f 	mcall	80009494 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
8000945c:	f0 1f 00 0f 	mcall	80009498 <xQueueGenericSend+0xfc>
80009460:	ca cb       	rjmp	800093b8 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80009462:	0e 9c       	mov	r12,r7
80009464:	f0 1f 00 0c 	mcall	80009494 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80009468:	f0 1f 00 0c 	mcall	80009498 <xQueueGenericSend+0xfc>
8000946c:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000946e:	2f bd       	sub	sp,-20
80009470:	d8 32       	popm	r0-r7,pc
80009472:	00 00       	add	r0,r0
80009474:	80 00       	ld.sh	r0,r0[0x0]
80009476:	8d dc       	st.w	r6[0x34],r12
80009478:	80 00       	ld.sh	r0,r0[0x0]
8000947a:	92 d4       	ld.uh	r4,r9[0xa]
8000947c:	80 00       	ld.sh	r0,r0[0x0]
8000947e:	97 00       	st.w	r11[0x0],r0
80009480:	80 00       	ld.sh	r0,r0[0x0]
80009482:	8e e8       	ld.uh	r8,r7[0xc]
80009484:	80 00       	ld.sh	r0,r0[0x0]
80009486:	95 f4       	st.w	r10[0x3c],r4
80009488:	80 00       	ld.sh	r0,r0[0x0]
8000948a:	95 68       	st.w	r10[0x18],r8
8000948c:	80 00       	ld.sh	r0,r0[0x0]
8000948e:	98 90       	ld.uh	r0,r12[0x2]
80009490:	80 00       	ld.sh	r0,r0[0x0]
80009492:	9a e8       	ld.uh	r8,sp[0xc]
80009494:	80 00       	ld.sh	r0,r0[0x0]
80009496:	90 f0       	ld.uh	r0,r8[0xe]
80009498:	80 00       	ld.sh	r0,r0[0x0]
8000949a:	99 24       	st.w	r12[0x8],r4

8000949c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
8000949c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800094a0:	34 cc       	mov	r12,76
800094a2:	f0 1f 00 12 	mcall	800094e8 <xQueueCreateMutex+0x4c>
800094a6:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800094a8:	c1 d0       	breq	800094e2 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800094aa:	30 06       	mov	r6,0
800094ac:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800094ae:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800094b0:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800094b2:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800094b4:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800094b6:	30 18       	mov	r8,1
800094b8:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800094ba:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800094be:	3f f8       	mov	r8,-1
800094c0:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800094c4:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800094c8:	2f 0c       	sub	r12,-16
800094ca:	f0 1f 00 09 	mcall	800094ec <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800094ce:	ee cc ff dc 	sub	r12,r7,-36
800094d2:	f0 1f 00 07 	mcall	800094ec <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800094d6:	0c 99       	mov	r9,r6
800094d8:	0c 9a       	mov	r10,r6
800094da:	0c 9b       	mov	r11,r6
800094dc:	0e 9c       	mov	r12,r7
800094de:	f0 1f 00 05 	mcall	800094f0 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800094e2:	0e 9c       	mov	r12,r7
800094e4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800094e8:	80 00       	ld.sh	r0,r0[0x0]
800094ea:	90 48       	ld.sh	r8,r8[0x8]
800094ec:	80 00       	ld.sh	r0,r0[0x0]
800094ee:	8c b8       	ld.uh	r8,r6[0x6]
800094f0:	80 00       	ld.sh	r0,r0[0x0]
800094f2:	93 9c       	st.w	r9[0x24],r12

800094f4 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800094f4:	d4 21       	pushm	r4-r7,lr
800094f6:	18 97       	mov	r7,r12
800094f8:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800094fa:	58 0c       	cp.w	r12,0
800094fc:	c2 f0       	breq	8000955a <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800094fe:	34 cc       	mov	r12,76
80009500:	f0 1f 00 17 	mcall	8000955c <xQueueCreate+0x68>
80009504:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80009506:	c2 a0       	breq	8000955a <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80009508:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000950c:	e8 cc ff ff 	sub	r12,r4,-1
80009510:	f0 1f 00 13 	mcall	8000955c <xQueueCreate+0x68>
80009514:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80009516:	c1 e0       	breq	80009552 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80009518:	f8 04 00 04 	add	r4,r12,r4
8000951c:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000951e:	30 08       	mov	r8,0
80009520:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80009522:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80009524:	ee c8 00 01 	sub	r8,r7,1
80009528:	ad 38       	mul	r8,r6
8000952a:	10 0c       	add	r12,r8
8000952c:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000952e:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80009530:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80009534:	3f f8       	mov	r8,-1
80009536:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000953a:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000953e:	ea cc ff f0 	sub	r12,r5,-16
80009542:	f0 1f 00 08 	mcall	80009560 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80009546:	ea cc ff dc 	sub	r12,r5,-36
8000954a:	f0 1f 00 06 	mcall	80009560 <xQueueCreate+0x6c>
8000954e:	0a 9c       	mov	r12,r5
80009550:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80009552:	0a 9c       	mov	r12,r5
80009554:	f0 1f 00 04 	mcall	80009564 <xQueueCreate+0x70>
80009558:	d8 2a       	popm	r4-r7,pc,r12=0
8000955a:	d8 2a       	popm	r4-r7,pc,r12=0
8000955c:	80 00       	ld.sh	r0,r0[0x0]
8000955e:	90 48       	ld.sh	r8,r8[0x8]
80009560:	80 00       	ld.sh	r0,r0[0x0]
80009562:	8c b8       	ld.uh	r8,r6[0x6]
80009564:	80 00       	ld.sh	r0,r0[0x0]
80009566:	90 20       	ld.sh	r0,r8[0x4]

80009568 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80009568:	48 38       	lddpc	r8,80009574 <vTaskSuspendAll+0xc>
8000956a:	70 09       	ld.w	r9,r8[0x0]
8000956c:	2f f9       	sub	r9,-1
8000956e:	91 09       	st.w	r8[0x0],r9
}
80009570:	5e fc       	retal	r12
80009572:	00 00       	add	r0,r0
80009574:	00 00       	add	r0,r0
80009576:	12 e0       	st.h	--r9,r0

80009578 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80009578:	49 a8       	lddpc	r8,800095e0 <vTaskSwitchContext+0x68>
8000957a:	70 08       	ld.w	r8,r8[0x0]
8000957c:	58 08       	cp.w	r8,0
8000957e:	c0 b1       	brne	80009594 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80009580:	49 98       	lddpc	r8,800095e4 <vTaskSwitchContext+0x6c>
80009582:	70 08       	ld.w	r8,r8[0x0]
80009584:	f0 08 00 28 	add	r8,r8,r8<<0x2
80009588:	49 89       	lddpc	r9,800095e8 <vTaskSwitchContext+0x70>
8000958a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000958e:	58 08       	cp.w	r8,0
80009590:	c0 60       	breq	8000959c <vTaskSwitchContext+0x24>
80009592:	c1 18       	rjmp	800095b4 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80009594:	30 19       	mov	r9,1
80009596:	49 68       	lddpc	r8,800095ec <vTaskSwitchContext+0x74>
80009598:	91 09       	st.w	r8[0x0],r9
8000959a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000959c:	49 28       	lddpc	r8,800095e4 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000959e:	49 3a       	lddpc	r10,800095e8 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800095a0:	70 09       	ld.w	r9,r8[0x0]
800095a2:	20 19       	sub	r9,1
800095a4:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800095a6:	70 09       	ld.w	r9,r8[0x0]
800095a8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800095ac:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800095b0:	58 09       	cp.w	r9,0
800095b2:	cf 70       	breq	800095a0 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800095b4:	48 c8       	lddpc	r8,800095e4 <vTaskSwitchContext+0x6c>
800095b6:	70 08       	ld.w	r8,r8[0x0]
800095b8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800095bc:	48 b9       	lddpc	r9,800095e8 <vTaskSwitchContext+0x70>
800095be:	f2 08 00 28 	add	r8,r9,r8<<0x2
800095c2:	70 19       	ld.w	r9,r8[0x4]
800095c4:	72 19       	ld.w	r9,r9[0x4]
800095c6:	91 19       	st.w	r8[0x4],r9
800095c8:	f0 ca ff f8 	sub	r10,r8,-8
800095cc:	14 39       	cp.w	r9,r10
800095ce:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800095d2:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800095d6:	70 18       	ld.w	r8,r8[0x4]
800095d8:	70 39       	ld.w	r9,r8[0xc]
800095da:	48 68       	lddpc	r8,800095f0 <vTaskSwitchContext+0x78>
800095dc:	91 09       	st.w	r8[0x0],r9
800095de:	5e fc       	retal	r12
800095e0:	00 00       	add	r0,r0
800095e2:	12 e0       	st.h	--r9,r0
800095e4:	00 00       	add	r0,r0
800095e6:	13 18       	ld.sh	r8,r9++
800095e8:	00 00       	add	r0,r0
800095ea:	11 fc       	ld.ub	r12,r8[0x7]
800095ec:	00 00       	add	r0,r0
800095ee:	13 00       	ld.w	r0,r9++
800095f0:	00 00       	add	r0,r0
800095f2:	12 b0       	st.h	r9++,r0

800095f4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800095f4:	48 48       	lddpc	r8,80009604 <vTaskSetTimeOutState+0x10>
800095f6:	70 08       	ld.w	r8,r8[0x0]
800095f8:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800095fa:	48 48       	lddpc	r8,80009608 <vTaskSetTimeOutState+0x14>
800095fc:	70 08       	ld.w	r8,r8[0x0]
800095fe:	99 18       	st.w	r12[0x4],r8
}
80009600:	5e fc       	retal	r12
80009602:	00 00       	add	r0,r0
80009604:	00 00       	add	r0,r0
80009606:	11 f4       	ld.ub	r4,r8[0x7]
80009608:	00 00       	add	r0,r0
8000960a:	12 dc       	st.w	--r9,r12

8000960c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
8000960c:	30 19       	mov	r9,1
8000960e:	48 28       	lddpc	r8,80009614 <vTaskMissedYield+0x8>
80009610:	91 09       	st.w	r8[0x0],r9
}
80009612:	5e fc       	retal	r12
80009614:	00 00       	add	r0,r0
80009616:	13 00       	ld.w	r0,r9++

80009618 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80009618:	48 28       	lddpc	r8,80009620 <xTaskGetCurrentTaskHandle+0x8>
8000961a:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
8000961c:	5e fc       	retal	r12
8000961e:	00 00       	add	r0,r0
80009620:	00 00       	add	r0,r0
80009622:	12 b0       	st.h	r9++,r0

80009624 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80009624:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80009628:	58 0c       	cp.w	r12,0
8000962a:	c1 f0       	breq	80009668 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
8000962c:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000962e:	78 b9       	ld.w	r9,r12[0x2c]
80009630:	79 18       	ld.w	r8,r12[0x44]
80009632:	10 39       	cp.w	r9,r8
80009634:	c1 a0       	breq	80009668 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80009636:	f8 c6 ff fc 	sub	r6,r12,-4
8000963a:	0c 9c       	mov	r12,r6
8000963c:	f0 1f 00 0c 	mcall	8000966c <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80009640:	6f 1c       	ld.w	r12,r7[0x44]
80009642:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80009644:	f8 08 11 08 	rsub	r8,r12,8
80009648:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000964a:	48 a8       	lddpc	r8,80009670 <vTaskPriorityDisinherit+0x4c>
8000964c:	70 08       	ld.w	r8,r8[0x0]
8000964e:	10 3c       	cp.w	r12,r8
80009650:	e0 88 00 04 	brls	80009658 <vTaskPriorityDisinherit+0x34>
80009654:	48 78       	lddpc	r8,80009670 <vTaskPriorityDisinherit+0x4c>
80009656:	91 0c       	st.w	r8[0x0],r12
80009658:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000965c:	0c 9b       	mov	r11,r6
8000965e:	48 68       	lddpc	r8,80009674 <vTaskPriorityDisinherit+0x50>
80009660:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009664:	f0 1f 00 05 	mcall	80009678 <vTaskPriorityDisinherit+0x54>
80009668:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000966c:	80 00       	ld.sh	r0,r0[0x0]
8000966e:	8d 22       	st.w	r6[0x8],r2
80009670:	00 00       	add	r0,r0
80009672:	13 18       	ld.sh	r8,r9++
80009674:	00 00       	add	r0,r0
80009676:	11 fc       	ld.ub	r12,r8[0x7]
80009678:	80 00       	ld.sh	r0,r0[0x0]
8000967a:	8c d2       	ld.uh	r2,r6[0xa]

8000967c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
8000967c:	eb cd 40 c0 	pushm	r6-r7,lr
80009680:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80009682:	49 b8       	lddpc	r8,800096ec <vTaskPriorityInherit+0x70>
80009684:	70 08       	ld.w	r8,r8[0x0]
80009686:	78 b9       	ld.w	r9,r12[0x2c]
80009688:	70 b8       	ld.w	r8,r8[0x2c]
8000968a:	10 39       	cp.w	r9,r8
8000968c:	c2 d2       	brcc	800096e6 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000968e:	49 88       	lddpc	r8,800096ec <vTaskPriorityInherit+0x70>
80009690:	70 08       	ld.w	r8,r8[0x0]
80009692:	70 b8       	ld.w	r8,r8[0x2c]
80009694:	f0 08 11 08 	rsub	r8,r8,8
80009698:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000969a:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000969e:	49 59       	lddpc	r9,800096f0 <vTaskPriorityInherit+0x74>
800096a0:	f2 08 00 28 	add	r8,r9,r8<<0x2
800096a4:	78 59       	ld.w	r9,r12[0x14]
800096a6:	10 39       	cp.w	r9,r8
800096a8:	c1 b1       	brne	800096de <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800096aa:	f8 c6 ff fc 	sub	r6,r12,-4
800096ae:	0c 9c       	mov	r12,r6
800096b0:	f0 1f 00 11 	mcall	800096f4 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800096b4:	48 e8       	lddpc	r8,800096ec <vTaskPriorityInherit+0x70>
800096b6:	70 08       	ld.w	r8,r8[0x0]
800096b8:	70 bc       	ld.w	r12,r8[0x2c]
800096ba:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800096bc:	48 f8       	lddpc	r8,800096f8 <vTaskPriorityInherit+0x7c>
800096be:	70 08       	ld.w	r8,r8[0x0]
800096c0:	10 3c       	cp.w	r12,r8
800096c2:	e0 88 00 04 	brls	800096ca <vTaskPriorityInherit+0x4e>
800096c6:	48 d8       	lddpc	r8,800096f8 <vTaskPriorityInherit+0x7c>
800096c8:	91 0c       	st.w	r8[0x0],r12
800096ca:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800096ce:	0c 9b       	mov	r11,r6
800096d0:	48 88       	lddpc	r8,800096f0 <vTaskPriorityInherit+0x74>
800096d2:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800096d6:	f0 1f 00 0a 	mcall	800096fc <vTaskPriorityInherit+0x80>
800096da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800096de:	48 48       	lddpc	r8,800096ec <vTaskPriorityInherit+0x70>
800096e0:	70 08       	ld.w	r8,r8[0x0]
800096e2:	70 b8       	ld.w	r8,r8[0x2c]
800096e4:	99 b8       	st.w	r12[0x2c],r8
800096e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800096ea:	00 00       	add	r0,r0
800096ec:	00 00       	add	r0,r0
800096ee:	12 b0       	st.h	r9++,r0
800096f0:	00 00       	add	r0,r0
800096f2:	11 fc       	ld.ub	r12,r8[0x7]
800096f4:	80 00       	ld.sh	r0,r0[0x0]
800096f6:	8d 22       	st.w	r6[0x8],r2
800096f8:	00 00       	add	r0,r0
800096fa:	13 18       	ld.sh	r8,r9++
800096fc:	80 00       	ld.sh	r0,r0[0x0]
800096fe:	8c d2       	ld.uh	r2,r6[0xa]

80009700 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80009700:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80009704:	78 38       	ld.w	r8,r12[0xc]
80009706:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80009708:	ee c6 ff e8 	sub	r6,r7,-24
8000970c:	0c 9c       	mov	r12,r6
8000970e:	f0 1f 00 15 	mcall	80009760 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009712:	49 58       	lddpc	r8,80009764 <xTaskRemoveFromEventList+0x64>
80009714:	70 08       	ld.w	r8,r8[0x0]
80009716:	58 08       	cp.w	r8,0
80009718:	c1 71       	brne	80009746 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
8000971a:	ee c6 ff fc 	sub	r6,r7,-4
8000971e:	0c 9c       	mov	r12,r6
80009720:	f0 1f 00 10 	mcall	80009760 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80009724:	6e bc       	ld.w	r12,r7[0x2c]
80009726:	49 18       	lddpc	r8,80009768 <xTaskRemoveFromEventList+0x68>
80009728:	70 08       	ld.w	r8,r8[0x0]
8000972a:	10 3c       	cp.w	r12,r8
8000972c:	e0 88 00 04 	brls	80009734 <xTaskRemoveFromEventList+0x34>
80009730:	48 e8       	lddpc	r8,80009768 <xTaskRemoveFromEventList+0x68>
80009732:	91 0c       	st.w	r8[0x0],r12
80009734:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009738:	0c 9b       	mov	r11,r6
8000973a:	48 d8       	lddpc	r8,8000976c <xTaskRemoveFromEventList+0x6c>
8000973c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009740:	f0 1f 00 0c 	mcall	80009770 <xTaskRemoveFromEventList+0x70>
80009744:	c0 58       	rjmp	8000974e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80009746:	0c 9b       	mov	r11,r6
80009748:	48 bc       	lddpc	r12,80009774 <xTaskRemoveFromEventList+0x74>
8000974a:	f0 1f 00 0a 	mcall	80009770 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000974e:	48 b8       	lddpc	r8,80009778 <xTaskRemoveFromEventList+0x78>
80009750:	70 08       	ld.w	r8,r8[0x0]
80009752:	6e b9       	ld.w	r9,r7[0x2c]
80009754:	70 b8       	ld.w	r8,r8[0x2c]
80009756:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80009758:	5f 2c       	srhs	r12
8000975a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000975e:	00 00       	add	r0,r0
80009760:	80 00       	ld.sh	r0,r0[0x0]
80009762:	8d 22       	st.w	r6[0x8],r2
80009764:	00 00       	add	r0,r0
80009766:	12 e0       	st.h	--r9,r0
80009768:	00 00       	add	r0,r0
8000976a:	13 18       	ld.sh	r8,r9++
8000976c:	00 00       	add	r0,r0
8000976e:	11 fc       	ld.ub	r12,r8[0x7]
80009770:	80 00       	ld.sh	r0,r0[0x0]
80009772:	8c d2       	ld.uh	r2,r6[0xa]
80009774:	00 00       	add	r0,r0
80009776:	12 b4       	st.h	r9++,r4
80009778:	00 00       	add	r0,r0
8000977a:	12 b0       	st.h	r9++,r0

8000977c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000977c:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009780:	4b 98       	lddpc	r8,80009864 <vTaskIncrementTick+0xe8>
80009782:	70 08       	ld.w	r8,r8[0x0]
80009784:	58 08       	cp.w	r8,0
80009786:	c6 91       	brne	80009858 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80009788:	4b 88       	lddpc	r8,80009868 <vTaskIncrementTick+0xec>
8000978a:	70 09       	ld.w	r9,r8[0x0]
8000978c:	2f f9       	sub	r9,-1
8000978e:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80009790:	70 08       	ld.w	r8,r8[0x0]
80009792:	58 08       	cp.w	r8,0
80009794:	c1 a1       	brne	800097c8 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80009796:	4b 68       	lddpc	r8,8000986c <vTaskIncrementTick+0xf0>
80009798:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000979a:	4b 69       	lddpc	r9,80009870 <vTaskIncrementTick+0xf4>
8000979c:	72 0b       	ld.w	r11,r9[0x0]
8000979e:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800097a0:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800097a2:	4b 59       	lddpc	r9,80009874 <vTaskIncrementTick+0xf8>
800097a4:	72 0a       	ld.w	r10,r9[0x0]
800097a6:	2f fa       	sub	r10,-1
800097a8:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800097aa:	70 08       	ld.w	r8,r8[0x0]
800097ac:	70 08       	ld.w	r8,r8[0x0]
800097ae:	58 08       	cp.w	r8,0
800097b0:	c0 51       	brne	800097ba <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800097b2:	3f f9       	mov	r9,-1
800097b4:	4b 18       	lddpc	r8,80009878 <vTaskIncrementTick+0xfc>
800097b6:	91 09       	st.w	r8[0x0],r9
800097b8:	c0 88       	rjmp	800097c8 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800097ba:	4a d8       	lddpc	r8,8000986c <vTaskIncrementTick+0xf0>
800097bc:	70 08       	ld.w	r8,r8[0x0]
800097be:	70 38       	ld.w	r8,r8[0xc]
800097c0:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800097c2:	70 19       	ld.w	r9,r8[0x4]
800097c4:	4a d8       	lddpc	r8,80009878 <vTaskIncrementTick+0xfc>
800097c6:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800097c8:	4a 88       	lddpc	r8,80009868 <vTaskIncrementTick+0xec>
800097ca:	70 09       	ld.w	r9,r8[0x0]
800097cc:	4a b8       	lddpc	r8,80009878 <vTaskIncrementTick+0xfc>
800097ce:	70 08       	ld.w	r8,r8[0x0]
800097d0:	10 39       	cp.w	r9,r8
800097d2:	c4 73       	brcs	80009860 <vTaskIncrementTick+0xe4>
800097d4:	4a 68       	lddpc	r8,8000986c <vTaskIncrementTick+0xf0>
800097d6:	70 08       	ld.w	r8,r8[0x0]
800097d8:	70 08       	ld.w	r8,r8[0x0]
800097da:	58 08       	cp.w	r8,0
800097dc:	c0 c0       	breq	800097f4 <vTaskIncrementTick+0x78>
800097de:	4a 48       	lddpc	r8,8000986c <vTaskIncrementTick+0xf0>
800097e0:	70 08       	ld.w	r8,r8[0x0]
800097e2:	70 38       	ld.w	r8,r8[0xc]
800097e4:	70 37       	ld.w	r7,r8[0xc]
800097e6:	6e 18       	ld.w	r8,r7[0x4]
800097e8:	4a 09       	lddpc	r9,80009868 <vTaskIncrementTick+0xec>
800097ea:	72 09       	ld.w	r9,r9[0x0]
800097ec:	12 38       	cp.w	r8,r9
800097ee:	e0 88 00 14 	brls	80009816 <vTaskIncrementTick+0x9a>
800097f2:	c0 e8       	rjmp	8000980e <vTaskIncrementTick+0x92>
800097f4:	3f f9       	mov	r9,-1
800097f6:	4a 18       	lddpc	r8,80009878 <vTaskIncrementTick+0xfc>
800097f8:	91 09       	st.w	r8[0x0],r9
800097fa:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800097fe:	6a 08       	ld.w	r8,r5[0x0]
80009800:	70 38       	ld.w	r8,r8[0xc]
80009802:	70 37       	ld.w	r7,r8[0xc]
80009804:	6e 18       	ld.w	r8,r7[0x4]
80009806:	64 09       	ld.w	r9,r2[0x0]
80009808:	12 38       	cp.w	r8,r9
8000980a:	e0 88 00 0a 	brls	8000981e <vTaskIncrementTick+0xa2>
8000980e:	49 b9       	lddpc	r9,80009878 <vTaskIncrementTick+0xfc>
80009810:	93 08       	st.w	r9[0x0],r8
80009812:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009816:	49 a4       	lddpc	r4,8000987c <vTaskIncrementTick+0x100>
80009818:	49 a3       	lddpc	r3,80009880 <vTaskIncrementTick+0x104>
8000981a:	49 55       	lddpc	r5,8000986c <vTaskIncrementTick+0xf0>
8000981c:	49 32       	lddpc	r2,80009868 <vTaskIncrementTick+0xec>
8000981e:	ee c6 ff fc 	sub	r6,r7,-4
80009822:	0c 9c       	mov	r12,r6
80009824:	f0 1f 00 18 	mcall	80009884 <vTaskIncrementTick+0x108>
80009828:	6e a8       	ld.w	r8,r7[0x28]
8000982a:	58 08       	cp.w	r8,0
8000982c:	c0 50       	breq	80009836 <vTaskIncrementTick+0xba>
8000982e:	ee cc ff e8 	sub	r12,r7,-24
80009832:	f0 1f 00 15 	mcall	80009884 <vTaskIncrementTick+0x108>
80009836:	6e bc       	ld.w	r12,r7[0x2c]
80009838:	68 08       	ld.w	r8,r4[0x0]
8000983a:	10 3c       	cp.w	r12,r8
8000983c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80009840:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009844:	0c 9b       	mov	r11,r6
80009846:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
8000984a:	f0 1f 00 10 	mcall	80009888 <vTaskIncrementTick+0x10c>
8000984e:	6a 08       	ld.w	r8,r5[0x0]
80009850:	70 08       	ld.w	r8,r8[0x0]
80009852:	58 08       	cp.w	r8,0
80009854:	cd 51       	brne	800097fe <vTaskIncrementTick+0x82>
80009856:	cc fb       	rjmp	800097f4 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80009858:	48 d8       	lddpc	r8,8000988c <vTaskIncrementTick+0x110>
8000985a:	70 09       	ld.w	r9,r8[0x0]
8000985c:	2f f9       	sub	r9,-1
8000985e:	91 09       	st.w	r8[0x0],r9
80009860:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009864:	00 00       	add	r0,r0
80009866:	12 e0       	st.h	--r9,r0
80009868:	00 00       	add	r0,r0
8000986a:	12 dc       	st.w	--r9,r12
8000986c:	00 00       	add	r0,r0
8000986e:	11 e8       	ld.ub	r8,r8[0x6]
80009870:	00 00       	add	r0,r0
80009872:	11 f8       	ld.ub	r8,r8[0x7]
80009874:	00 00       	add	r0,r0
80009876:	11 f4       	ld.ub	r4,r8[0x7]
80009878:	00 00       	add	r0,r0
8000987a:	05 34       	ld.ub	r4,r2++
8000987c:	00 00       	add	r0,r0
8000987e:	13 18       	ld.sh	r8,r9++
80009880:	00 00       	add	r0,r0
80009882:	11 fc       	ld.ub	r12,r8[0x7]
80009884:	80 00       	ld.sh	r0,r0[0x0]
80009886:	8d 22       	st.w	r6[0x8],r2
80009888:	80 00       	ld.sh	r0,r0[0x0]
8000988a:	8c d2       	ld.uh	r2,r6[0xa]
8000988c:	00 00       	add	r0,r0
8000988e:	11 e0       	ld.ub	r0,r8[0x6]

80009890 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80009890:	eb cd 40 c0 	pushm	r6-r7,lr
80009894:	18 97       	mov	r7,r12
80009896:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80009898:	f0 1f 00 15 	mcall	800098ec <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
8000989c:	6c 08       	ld.w	r8,r6[0x0]
8000989e:	5b f8       	cp.w	r8,-1
800098a0:	c0 31       	brne	800098a6 <xTaskCheckForTimeOut+0x16>
800098a2:	30 07       	mov	r7,0
800098a4:	c1 f8       	rjmp	800098e2 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800098a6:	49 39       	lddpc	r9,800098f0 <xTaskCheckForTimeOut+0x60>
800098a8:	72 09       	ld.w	r9,r9[0x0]
800098aa:	6e 0a       	ld.w	r10,r7[0x0]
800098ac:	12 3a       	cp.w	r10,r9
800098ae:	c0 70       	breq	800098bc <xTaskCheckForTimeOut+0x2c>
800098b0:	49 19       	lddpc	r9,800098f4 <xTaskCheckForTimeOut+0x64>
800098b2:	72 09       	ld.w	r9,r9[0x0]
800098b4:	6e 1a       	ld.w	r10,r7[0x4]
800098b6:	12 3a       	cp.w	r10,r9
800098b8:	e0 88 00 14 	brls	800098e0 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800098bc:	48 e9       	lddpc	r9,800098f4 <xTaskCheckForTimeOut+0x64>
800098be:	72 0a       	ld.w	r10,r9[0x0]
800098c0:	6e 19       	ld.w	r9,r7[0x4]
800098c2:	12 1a       	sub	r10,r9
800098c4:	14 38       	cp.w	r8,r10
800098c6:	e0 88 00 0d 	brls	800098e0 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800098ca:	48 ba       	lddpc	r10,800098f4 <xTaskCheckForTimeOut+0x64>
800098cc:	74 0a       	ld.w	r10,r10[0x0]
800098ce:	14 19       	sub	r9,r10
800098d0:	f2 08 00 08 	add	r8,r9,r8
800098d4:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800098d6:	0e 9c       	mov	r12,r7
800098d8:	f0 1f 00 08 	mcall	800098f8 <xTaskCheckForTimeOut+0x68>
800098dc:	30 07       	mov	r7,0
800098de:	c0 28       	rjmp	800098e2 <xTaskCheckForTimeOut+0x52>
800098e0:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
800098e2:	f0 1f 00 07 	mcall	800098fc <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800098e6:	0e 9c       	mov	r12,r7
800098e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800098ec:	80 00       	ld.sh	r0,r0[0x0]
800098ee:	8d dc       	st.w	r6[0x34],r12
800098f0:	00 00       	add	r0,r0
800098f2:	11 f4       	ld.ub	r4,r8[0x7]
800098f4:	00 00       	add	r0,r0
800098f6:	12 dc       	st.w	--r9,r12
800098f8:	80 00       	ld.sh	r0,r0[0x0]
800098fa:	95 f4       	st.w	r10[0x3c],r4
800098fc:	80 00       	ld.sh	r0,r0[0x0]
800098fe:	8e e8       	ld.uh	r8,r7[0xc]

80009900 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80009900:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80009904:	f0 1f 00 05 	mcall	80009918 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80009908:	48 58       	lddpc	r8,8000991c <xTaskGetTickCount+0x1c>
8000990a:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
8000990c:	f0 1f 00 05 	mcall	80009920 <xTaskGetTickCount+0x20>

	return xTicks;
}
80009910:	0e 9c       	mov	r12,r7
80009912:	e3 cd 80 80 	ldm	sp++,r7,pc
80009916:	00 00       	add	r0,r0
80009918:	80 00       	ld.sh	r0,r0[0x0]
8000991a:	8d dc       	st.w	r6[0x34],r12
8000991c:	00 00       	add	r0,r0
8000991e:	12 dc       	st.w	--r9,r12
80009920:	80 00       	ld.sh	r0,r0[0x0]
80009922:	8e e8       	ld.uh	r8,r7[0xc]

80009924 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80009924:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80009928:	f0 1f 00 2c 	mcall	800099d8 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
8000992c:	4a c8       	lddpc	r8,800099dc <xTaskResumeAll+0xb8>
8000992e:	70 09       	ld.w	r9,r8[0x0]
80009930:	20 19       	sub	r9,1
80009932:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009934:	70 08       	ld.w	r8,r8[0x0]
80009936:	58 08       	cp.w	r8,0
80009938:	c4 91       	brne	800099ca <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
8000993a:	4a a8       	lddpc	r8,800099e0 <xTaskResumeAll+0xbc>
8000993c:	70 08       	ld.w	r8,r8[0x0]
8000993e:	58 08       	cp.w	r8,0
80009940:	c4 50       	breq	800099ca <xTaskResumeAll+0xa6>
80009942:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80009944:	4a 85       	lddpc	r5,800099e4 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80009946:	4a 93       	lddpc	r3,800099e8 <xTaskResumeAll+0xc4>
80009948:	4a 92       	lddpc	r2,800099ec <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000994a:	4a a1       	lddpc	r1,800099f0 <xTaskResumeAll+0xcc>
8000994c:	c1 e8       	rjmp	80009988 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000994e:	6a 38       	ld.w	r8,r5[0xc]
80009950:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80009952:	ee cc ff e8 	sub	r12,r7,-24
80009956:	f0 1f 00 28 	mcall	800099f4 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000995a:	ee c6 ff fc 	sub	r6,r7,-4
8000995e:	0c 9c       	mov	r12,r6
80009960:	f0 1f 00 25 	mcall	800099f4 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80009964:	6e bc       	ld.w	r12,r7[0x2c]
80009966:	66 08       	ld.w	r8,r3[0x0]
80009968:	10 3c       	cp.w	r12,r8
8000996a:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000996e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009972:	0c 9b       	mov	r11,r6
80009974:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80009978:	f0 1f 00 20 	mcall	800099f8 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000997c:	62 08       	ld.w	r8,r1[0x0]
8000997e:	6e b9       	ld.w	r9,r7[0x2c]
80009980:	70 b8       	ld.w	r8,r8[0x2c]
80009982:	10 39       	cp.w	r9,r8
80009984:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80009988:	6a 08       	ld.w	r8,r5[0x0]
8000998a:	58 08       	cp.w	r8,0
8000998c:	ce 11       	brne	8000994e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000998e:	49 c8       	lddpc	r8,800099fc <xTaskResumeAll+0xd8>
80009990:	70 08       	ld.w	r8,r8[0x0]
80009992:	58 08       	cp.w	r8,0
80009994:	c0 f0       	breq	800099b2 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009996:	49 a8       	lddpc	r8,800099fc <xTaskResumeAll+0xd8>
80009998:	70 08       	ld.w	r8,r8[0x0]
8000999a:	58 08       	cp.w	r8,0
8000999c:	c1 10       	breq	800099be <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000999e:	49 87       	lddpc	r7,800099fc <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800099a0:	f0 1f 00 18 	mcall	80009a00 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800099a4:	6e 08       	ld.w	r8,r7[0x0]
800099a6:	20 18       	sub	r8,1
800099a8:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800099aa:	6e 08       	ld.w	r8,r7[0x0]
800099ac:	58 08       	cp.w	r8,0
800099ae:	cf 91       	brne	800099a0 <xTaskResumeAll+0x7c>
800099b0:	c0 78       	rjmp	800099be <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800099b2:	58 14       	cp.w	r4,1
800099b4:	c0 50       	breq	800099be <xTaskResumeAll+0x9a>
800099b6:	49 48       	lddpc	r8,80009a04 <xTaskResumeAll+0xe0>
800099b8:	70 08       	ld.w	r8,r8[0x0]
800099ba:	58 18       	cp.w	r8,1
800099bc:	c0 71       	brne	800099ca <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800099be:	30 09       	mov	r9,0
800099c0:	49 18       	lddpc	r8,80009a04 <xTaskResumeAll+0xe0>
800099c2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800099c4:	d7 33       	scall
800099c6:	30 17       	mov	r7,1
800099c8:	c0 28       	rjmp	800099cc <xTaskResumeAll+0xa8>
800099ca:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800099cc:	f0 1f 00 0f 	mcall	80009a08 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800099d0:	0e 9c       	mov	r12,r7
800099d2:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800099d6:	00 00       	add	r0,r0
800099d8:	80 00       	ld.sh	r0,r0[0x0]
800099da:	8d dc       	st.w	r6[0x34],r12
800099dc:	00 00       	add	r0,r0
800099de:	12 e0       	st.h	--r9,r0
800099e0:	00 00       	add	r0,r0
800099e2:	12 fc       	st.b	--r9,r12
800099e4:	00 00       	add	r0,r0
800099e6:	12 b4       	st.h	r9++,r4
800099e8:	00 00       	add	r0,r0
800099ea:	13 18       	ld.sh	r8,r9++
800099ec:	00 00       	add	r0,r0
800099ee:	11 fc       	ld.ub	r12,r8[0x7]
800099f0:	00 00       	add	r0,r0
800099f2:	12 b0       	st.h	r9++,r0
800099f4:	80 00       	ld.sh	r0,r0[0x0]
800099f6:	8d 22       	st.w	r6[0x8],r2
800099f8:	80 00       	ld.sh	r0,r0[0x0]
800099fa:	8c d2       	ld.uh	r2,r6[0xa]
800099fc:	00 00       	add	r0,r0
800099fe:	11 e0       	ld.ub	r0,r8[0x6]
80009a00:	80 00       	ld.sh	r0,r0[0x0]
80009a02:	97 7c       	st.w	r11[0x1c],r12
80009a04:	00 00       	add	r0,r0
80009a06:	13 00       	ld.w	r0,r9++
80009a08:	80 00       	ld.sh	r0,r0[0x0]
80009a0a:	8e e8       	ld.uh	r8,r7[0xc]

80009a0c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80009a0c:	eb cd 40 80 	pushm	r7,lr
80009a10:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80009a12:	49 08       	lddpc	r8,80009a50 <prvAddCurrentTaskToDelayedList+0x44>
80009a14:	70 08       	ld.w	r8,r8[0x0]
80009a16:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80009a18:	48 f8       	lddpc	r8,80009a54 <prvAddCurrentTaskToDelayedList+0x48>
80009a1a:	70 08       	ld.w	r8,r8[0x0]
80009a1c:	10 3c       	cp.w	r12,r8
80009a1e:	c0 a2       	brcc	80009a32 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009a20:	48 c8       	lddpc	r8,80009a50 <prvAddCurrentTaskToDelayedList+0x44>
80009a22:	70 0b       	ld.w	r11,r8[0x0]
80009a24:	48 d8       	lddpc	r8,80009a58 <prvAddCurrentTaskToDelayedList+0x4c>
80009a26:	70 0c       	ld.w	r12,r8[0x0]
80009a28:	2f cb       	sub	r11,-4
80009a2a:	f0 1f 00 0d 	mcall	80009a5c <prvAddCurrentTaskToDelayedList+0x50>
80009a2e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009a32:	48 88       	lddpc	r8,80009a50 <prvAddCurrentTaskToDelayedList+0x44>
80009a34:	70 0b       	ld.w	r11,r8[0x0]
80009a36:	48 b8       	lddpc	r8,80009a60 <prvAddCurrentTaskToDelayedList+0x54>
80009a38:	70 0c       	ld.w	r12,r8[0x0]
80009a3a:	2f cb       	sub	r11,-4
80009a3c:	f0 1f 00 08 	mcall	80009a5c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80009a40:	48 98       	lddpc	r8,80009a64 <prvAddCurrentTaskToDelayedList+0x58>
80009a42:	70 08       	ld.w	r8,r8[0x0]
80009a44:	10 37       	cp.w	r7,r8
80009a46:	c0 32       	brcc	80009a4c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80009a48:	48 78       	lddpc	r8,80009a64 <prvAddCurrentTaskToDelayedList+0x58>
80009a4a:	91 07       	st.w	r8[0x0],r7
80009a4c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009a50:	00 00       	add	r0,r0
80009a52:	12 b0       	st.h	r9++,r0
80009a54:	00 00       	add	r0,r0
80009a56:	12 dc       	st.w	--r9,r12
80009a58:	00 00       	add	r0,r0
80009a5a:	11 f8       	ld.ub	r8,r8[0x7]
80009a5c:	80 00       	ld.sh	r0,r0[0x0]
80009a5e:	8c ee       	ld.uh	lr,r6[0xc]
80009a60:	00 00       	add	r0,r0
80009a62:	11 e8       	ld.ub	r8,r8[0x6]
80009a64:	00 00       	add	r0,r0
80009a66:	05 34       	ld.ub	r4,r2++

80009a68 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80009a68:	eb cd 40 c0 	pushm	r6-r7,lr
80009a6c:	18 96       	mov	r6,r12
80009a6e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80009a70:	f0 1f 00 18 	mcall	80009ad0 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80009a74:	6c 08       	ld.w	r8,r6[0x0]
80009a76:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80009a78:	49 79       	lddpc	r9,80009ad4 <vTaskDelayUntil+0x6c>
80009a7a:	72 09       	ld.w	r9,r9[0x0]
80009a7c:	12 38       	cp.w	r8,r9
80009a7e:	e0 88 00 0c 	brls	80009a96 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80009a82:	0e 38       	cp.w	r8,r7
80009a84:	e0 88 00 22 	brls	80009ac8 <vTaskDelayUntil+0x60>
80009a88:	49 38       	lddpc	r8,80009ad4 <vTaskDelayUntil+0x6c>
80009a8a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80009a8c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80009a8e:	10 37       	cp.w	r7,r8
80009a90:	e0 88 00 14 	brls	80009ab8 <vTaskDelayUntil+0x50>
80009a94:	c0 a8       	rjmp	80009aa8 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80009a96:	0e 38       	cp.w	r8,r7
80009a98:	e0 8b 00 16 	brhi	80009ac4 <vTaskDelayUntil+0x5c>
80009a9c:	48 e8       	lddpc	r8,80009ad4 <vTaskDelayUntil+0x6c>
80009a9e:	70 08       	ld.w	r8,r8[0x0]
80009aa0:	10 37       	cp.w	r7,r8
80009aa2:	e0 8b 00 11 	brhi	80009ac4 <vTaskDelayUntil+0x5c>
80009aa6:	c1 18       	rjmp	80009ac8 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009aa8:	48 c8       	lddpc	r8,80009ad8 <vTaskDelayUntil+0x70>
80009aaa:	70 0c       	ld.w	r12,r8[0x0]
80009aac:	2f cc       	sub	r12,-4
80009aae:	f0 1f 00 0c 	mcall	80009adc <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80009ab2:	0e 9c       	mov	r12,r7
80009ab4:	f0 1f 00 0b 	mcall	80009ae0 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80009ab8:	f0 1f 00 0b 	mcall	80009ae4 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80009abc:	c0 81       	brne	80009acc <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80009abe:	d7 33       	scall
80009ac0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80009ac4:	8d 07       	st.w	r6[0x0],r7
80009ac6:	cf 1b       	rjmp	80009aa8 <vTaskDelayUntil+0x40>
80009ac8:	8d 07       	st.w	r6[0x0],r7
80009aca:	cf 7b       	rjmp	80009ab8 <vTaskDelayUntil+0x50>
80009acc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009ad0:	80 00       	ld.sh	r0,r0[0x0]
80009ad2:	95 68       	st.w	r10[0x18],r8
80009ad4:	00 00       	add	r0,r0
80009ad6:	12 dc       	st.w	--r9,r12
80009ad8:	00 00       	add	r0,r0
80009ada:	12 b0       	st.h	r9++,r0
80009adc:	80 00       	ld.sh	r0,r0[0x0]
80009ade:	8d 22       	st.w	r6[0x8],r2
80009ae0:	80 00       	ld.sh	r0,r0[0x0]
80009ae2:	9a 0c       	ld.sh	r12,sp[0x0]
80009ae4:	80 00       	ld.sh	r0,r0[0x0]
80009ae6:	99 24       	st.w	r12[0x8],r4

80009ae8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80009ae8:	eb cd 40 c0 	pushm	r6-r7,lr
80009aec:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80009aee:	48 e7       	lddpc	r7,80009b24 <vTaskPlaceOnEventList+0x3c>
80009af0:	6e 0b       	ld.w	r11,r7[0x0]
80009af2:	2e 8b       	sub	r11,-24
80009af4:	f0 1f 00 0d 	mcall	80009b28 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009af8:	6e 0c       	ld.w	r12,r7[0x0]
80009afa:	2f cc       	sub	r12,-4
80009afc:	f0 1f 00 0c 	mcall	80009b2c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80009b00:	5b f6       	cp.w	r6,-1
80009b02:	c0 81       	brne	80009b12 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009b04:	6e 0b       	ld.w	r11,r7[0x0]
80009b06:	2f cb       	sub	r11,-4
80009b08:	48 ac       	lddpc	r12,80009b30 <vTaskPlaceOnEventList+0x48>
80009b0a:	f0 1f 00 0b 	mcall	80009b34 <vTaskPlaceOnEventList+0x4c>
80009b0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80009b12:	48 a8       	lddpc	r8,80009b38 <vTaskPlaceOnEventList+0x50>
80009b14:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80009b16:	ec 0c 00 0c 	add	r12,r6,r12
80009b1a:	f0 1f 00 09 	mcall	80009b3c <vTaskPlaceOnEventList+0x54>
80009b1e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009b22:	00 00       	add	r0,r0
80009b24:	00 00       	add	r0,r0
80009b26:	12 b0       	st.h	r9++,r0
80009b28:	80 00       	ld.sh	r0,r0[0x0]
80009b2a:	8c ee       	ld.uh	lr,r6[0xc]
80009b2c:	80 00       	ld.sh	r0,r0[0x0]
80009b2e:	8d 22       	st.w	r6[0x8],r2
80009b30:	00 00       	add	r0,r0
80009b32:	13 04       	ld.w	r4,r9++
80009b34:	80 00       	ld.sh	r0,r0[0x0]
80009b36:	8c d2       	ld.uh	r2,r6[0xa]
80009b38:	00 00       	add	r0,r0
80009b3a:	12 dc       	st.w	--r9,r12
80009b3c:	80 00       	ld.sh	r0,r0[0x0]
80009b3e:	9a 0c       	ld.sh	r12,sp[0x0]

80009b40 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80009b40:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009b44:	49 67       	lddpc	r7,80009b9c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80009b46:	49 74       	lddpc	r4,80009ba0 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80009b48:	49 73       	lddpc	r3,80009ba4 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009b4a:	49 85       	lddpc	r5,80009ba8 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009b4c:	6e 08       	ld.w	r8,r7[0x0]
80009b4e:	58 08       	cp.w	r8,0
80009b50:	c1 e0       	breq	80009b8c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80009b52:	f0 1f 00 17 	mcall	80009bac <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80009b56:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80009b58:	f0 1f 00 16 	mcall	80009bb0 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80009b5c:	58 06       	cp.w	r6,0
80009b5e:	c1 70       	breq	80009b8c <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80009b60:	f0 1f 00 15 	mcall	80009bb4 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80009b64:	68 38       	ld.w	r8,r4[0xc]
80009b66:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80009b68:	ec cc ff fc 	sub	r12,r6,-4
80009b6c:	f0 1f 00 13 	mcall	80009bb8 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80009b70:	66 08       	ld.w	r8,r3[0x0]
80009b72:	20 18       	sub	r8,1
80009b74:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80009b76:	6e 08       	ld.w	r8,r7[0x0]
80009b78:	20 18       	sub	r8,1
80009b7a:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80009b7c:	f0 1f 00 10 	mcall	80009bbc <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80009b80:	6c cc       	ld.w	r12,r6[0x30]
80009b82:	f0 1f 00 10 	mcall	80009bc0 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80009b86:	0c 9c       	mov	r12,r6
80009b88:	f0 1f 00 0e 	mcall	80009bc0 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009b8c:	6a 08       	ld.w	r8,r5[0x0]
80009b8e:	58 18       	cp.w	r8,1
80009b90:	e0 88 00 03 	brls	80009b96 <prvIdleTask+0x56>
			{
				taskYIELD();
80009b94:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80009b96:	f0 1f 00 0c 	mcall	80009bc4 <prvIdleTask+0x84>
		}
		#endif
	}
80009b9a:	cd 9b       	rjmp	80009b4c <prvIdleTask+0xc>
80009b9c:	00 00       	add	r0,r0
80009b9e:	11 f0       	ld.ub	r0,r8[0x7]
80009ba0:	00 00       	add	r0,r0
80009ba2:	12 9c       	mov	r12,r9
80009ba4:	00 00       	add	r0,r0
80009ba6:	12 fc       	st.b	--r9,r12
80009ba8:	00 00       	add	r0,r0
80009baa:	11 fc       	ld.ub	r12,r8[0x7]
80009bac:	80 00       	ld.sh	r0,r0[0x0]
80009bae:	95 68       	st.w	r10[0x18],r8
80009bb0:	80 00       	ld.sh	r0,r0[0x0]
80009bb2:	99 24       	st.w	r12[0x8],r4
80009bb4:	80 00       	ld.sh	r0,r0[0x0]
80009bb6:	8d dc       	st.w	r6[0x34],r12
80009bb8:	80 00       	ld.sh	r0,r0[0x0]
80009bba:	8d 22       	st.w	r6[0x8],r2
80009bbc:	80 00       	ld.sh	r0,r0[0x0]
80009bbe:	8e e8       	ld.uh	r8,r7[0xc]
80009bc0:	80 00       	ld.sh	r0,r0[0x0]
80009bc2:	90 20       	ld.sh	r0,r8[0x4]
80009bc4:	80 00       	ld.sh	r0,r0[0x0]
80009bc6:	20 38       	sub	r8,3

80009bc8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80009bc8:	d4 31       	pushm	r0-r7,lr
80009bca:	20 1d       	sub	sp,4
80009bcc:	fa c4 ff d8 	sub	r4,sp,-40
80009bd0:	50 0c       	stdsp	sp[0x0],r12
80009bd2:	16 91       	mov	r1,r11
80009bd4:	14 97       	mov	r7,r10
80009bd6:	12 90       	mov	r0,r9
80009bd8:	10 93       	mov	r3,r8
80009bda:	68 02       	ld.w	r2,r4[0x0]
80009bdc:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80009bde:	34 8c       	mov	r12,72
80009be0:	f0 1f 00 5c 	mcall	80009d50 <xTaskGenericCreate+0x188>
80009be4:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80009be6:	c0 31       	brne	80009bec <xTaskGenericCreate+0x24>
80009be8:	3f fc       	mov	r12,-1
80009bea:	ca f8       	rjmp	80009d48 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009bec:	58 06       	cp.w	r6,0
80009bee:	e0 81 00 af 	brne	80009d4c <xTaskGenericCreate+0x184>
80009bf2:	0e 9c       	mov	r12,r7
80009bf4:	5c 7c       	castu.h	r12
80009bf6:	a3 6c       	lsl	r12,0x2
80009bf8:	f0 1f 00 56 	mcall	80009d50 <xTaskGenericCreate+0x188>
80009bfc:	18 96       	mov	r6,r12
80009bfe:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80009c00:	c0 61       	brne	80009c0c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80009c02:	0a 9c       	mov	r12,r5
80009c04:	f0 1f 00 54 	mcall	80009d54 <xTaskGenericCreate+0x18c>
80009c08:	3f fc       	mov	r12,-1
80009c0a:	c9 f8       	rjmp	80009d48 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80009c0c:	5c 77       	castu.h	r7
80009c0e:	ee 0a 15 02 	lsl	r10,r7,0x2
80009c12:	e0 6b 00 a5 	mov	r11,165
80009c16:	0c 9c       	mov	r12,r6
80009c18:	f0 1f 00 50 	mcall	80009d58 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80009c1c:	ee c6 00 01 	sub	r6,r7,1
80009c20:	6a c8       	ld.w	r8,r5[0x30]
80009c22:	f0 06 00 26 	add	r6,r8,r6<<0x2
80009c26:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80009c2a:	31 0a       	mov	r10,16
80009c2c:	02 9b       	mov	r11,r1
80009c2e:	ea cc ff cc 	sub	r12,r5,-52
80009c32:	f0 1f 00 4b 	mcall	80009d5c <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80009c36:	30 08       	mov	r8,0
80009c38:	eb 68 00 43 	st.b	r5[67],r8
80009c3c:	58 73       	cp.w	r3,7
80009c3e:	e6 07 17 80 	movls	r7,r3
80009c42:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80009c46:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80009c48:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80009c4c:	ea c4 ff fc 	sub	r4,r5,-4
80009c50:	08 9c       	mov	r12,r4
80009c52:	f0 1f 00 44 	mcall	80009d60 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80009c56:	ea cc ff e8 	sub	r12,r5,-24
80009c5a:	f0 1f 00 42 	mcall	80009d60 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80009c5e:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80009c60:	ee 07 11 08 	rsub	r7,r7,8
80009c64:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80009c66:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80009c68:	00 9a       	mov	r10,r0
80009c6a:	40 0b       	lddsp	r11,sp[0x0]
80009c6c:	0c 9c       	mov	r12,r6
80009c6e:	f0 1f 00 3e 	mcall	80009d64 <xTaskGenericCreate+0x19c>
80009c72:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80009c74:	58 02       	cp.w	r2,0
80009c76:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80009c7a:	f0 1f 00 3c 	mcall	80009d68 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80009c7e:	4b c8       	lddpc	r8,80009d6c <xTaskGenericCreate+0x1a4>
80009c80:	70 09       	ld.w	r9,r8[0x0]
80009c82:	2f f9       	sub	r9,-1
80009c84:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80009c86:	4b b8       	lddpc	r8,80009d70 <xTaskGenericCreate+0x1a8>
80009c88:	70 08       	ld.w	r8,r8[0x0]
80009c8a:	58 08       	cp.w	r8,0
80009c8c:	c2 61       	brne	80009cd8 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80009c8e:	4b 98       	lddpc	r8,80009d70 <xTaskGenericCreate+0x1a8>
80009c90:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80009c92:	4b 78       	lddpc	r8,80009d6c <xTaskGenericCreate+0x1a4>
80009c94:	70 08       	ld.w	r8,r8[0x0]
80009c96:	58 18       	cp.w	r8,1
80009c98:	c2 b1       	brne	80009cee <xTaskGenericCreate+0x126>
80009c9a:	4b 77       	lddpc	r7,80009d74 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80009c9c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80009ca0:	0e 9c       	mov	r12,r7
80009ca2:	f0 1f 00 36 	mcall	80009d78 <xTaskGenericCreate+0x1b0>
80009ca6:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80009ca8:	0c 37       	cp.w	r7,r6
80009caa:	cf b1       	brne	80009ca0 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80009cac:	4b 47       	lddpc	r7,80009d7c <xTaskGenericCreate+0x1b4>
80009cae:	0e 9c       	mov	r12,r7
80009cb0:	f0 1f 00 32 	mcall	80009d78 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80009cb4:	4b 36       	lddpc	r6,80009d80 <xTaskGenericCreate+0x1b8>
80009cb6:	0c 9c       	mov	r12,r6
80009cb8:	f0 1f 00 30 	mcall	80009d78 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80009cbc:	4b 2c       	lddpc	r12,80009d84 <xTaskGenericCreate+0x1bc>
80009cbe:	f0 1f 00 2f 	mcall	80009d78 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80009cc2:	4b 2c       	lddpc	r12,80009d88 <xTaskGenericCreate+0x1c0>
80009cc4:	f0 1f 00 2d 	mcall	80009d78 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80009cc8:	4b 1c       	lddpc	r12,80009d8c <xTaskGenericCreate+0x1c4>
80009cca:	f0 1f 00 2c 	mcall	80009d78 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80009cce:	4b 18       	lddpc	r8,80009d90 <xTaskGenericCreate+0x1c8>
80009cd0:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80009cd2:	4b 18       	lddpc	r8,80009d94 <xTaskGenericCreate+0x1cc>
80009cd4:	91 06       	st.w	r8[0x0],r6
80009cd6:	c0 c8       	rjmp	80009cee <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80009cd8:	4b 08       	lddpc	r8,80009d98 <xTaskGenericCreate+0x1d0>
80009cda:	70 08       	ld.w	r8,r8[0x0]
80009cdc:	58 08       	cp.w	r8,0
80009cde:	c0 81       	brne	80009cee <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80009ce0:	4a 48       	lddpc	r8,80009d70 <xTaskGenericCreate+0x1a8>
80009ce2:	70 08       	ld.w	r8,r8[0x0]
80009ce4:	70 b8       	ld.w	r8,r8[0x2c]
80009ce6:	10 33       	cp.w	r3,r8
80009ce8:	c0 33       	brcs	80009cee <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80009cea:	4a 28       	lddpc	r8,80009d70 <xTaskGenericCreate+0x1a8>
80009cec:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80009cee:	6a b8       	ld.w	r8,r5[0x2c]
80009cf0:	4a b9       	lddpc	r9,80009d9c <xTaskGenericCreate+0x1d4>
80009cf2:	72 09       	ld.w	r9,r9[0x0]
80009cf4:	12 38       	cp.w	r8,r9
80009cf6:	e0 88 00 04 	brls	80009cfe <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80009cfa:	4a 99       	lddpc	r9,80009d9c <xTaskGenericCreate+0x1d4>
80009cfc:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80009cfe:	4a 98       	lddpc	r8,80009da0 <xTaskGenericCreate+0x1d8>
80009d00:	70 09       	ld.w	r9,r8[0x0]
80009d02:	2f f9       	sub	r9,-1
80009d04:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80009d06:	6a b8       	ld.w	r8,r5[0x2c]
80009d08:	4a 79       	lddpc	r9,80009da4 <xTaskGenericCreate+0x1dc>
80009d0a:	72 09       	ld.w	r9,r9[0x0]
80009d0c:	12 38       	cp.w	r8,r9
80009d0e:	e0 88 00 04 	brls	80009d16 <xTaskGenericCreate+0x14e>
80009d12:	4a 59       	lddpc	r9,80009da4 <xTaskGenericCreate+0x1dc>
80009d14:	93 08       	st.w	r9[0x0],r8
80009d16:	6a bc       	ld.w	r12,r5[0x2c]
80009d18:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009d1c:	08 9b       	mov	r11,r4
80009d1e:	49 68       	lddpc	r8,80009d74 <xTaskGenericCreate+0x1ac>
80009d20:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009d24:	f0 1f 00 21 	mcall	80009da8 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80009d28:	f0 1f 00 21 	mcall	80009dac <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80009d2c:	49 b8       	lddpc	r8,80009d98 <xTaskGenericCreate+0x1d0>
80009d2e:	70 08       	ld.w	r8,r8[0x0]
80009d30:	58 08       	cp.w	r8,0
80009d32:	c0 a0       	breq	80009d46 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80009d34:	48 f8       	lddpc	r8,80009d70 <xTaskGenericCreate+0x1a8>
80009d36:	70 08       	ld.w	r8,r8[0x0]
80009d38:	70 b8       	ld.w	r8,r8[0x2c]
80009d3a:	10 33       	cp.w	r3,r8
80009d3c:	e0 88 00 05 	brls	80009d46 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80009d40:	d7 33       	scall
80009d42:	30 1c       	mov	r12,1
80009d44:	c0 28       	rjmp	80009d48 <xTaskGenericCreate+0x180>
80009d46:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80009d48:	2f fd       	sub	sp,-4
80009d4a:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009d4c:	99 c6       	st.w	r12[0x30],r6
80009d4e:	c5 fb       	rjmp	80009c0c <xTaskGenericCreate+0x44>
80009d50:	80 00       	ld.sh	r0,r0[0x0]
80009d52:	90 48       	ld.sh	r8,r8[0x8]
80009d54:	80 00       	ld.sh	r0,r0[0x0]
80009d56:	90 20       	ld.sh	r0,r8[0x4]
80009d58:	80 00       	ld.sh	r0,r0[0x0]
80009d5a:	aa 9a       	st.b	r5[0x1],r10
80009d5c:	80 00       	ld.sh	r0,r0[0x0]
80009d5e:	ad ec       	*unknown*
80009d60:	80 00       	ld.sh	r0,r0[0x0]
80009d62:	8c cc       	ld.uh	r12,r6[0x8]
80009d64:	80 00       	ld.sh	r0,r0[0x0]
80009d66:	8d 48       	st.w	r6[0x10],r8
80009d68:	80 00       	ld.sh	r0,r0[0x0]
80009d6a:	8d dc       	st.w	r6[0x34],r12
80009d6c:	00 00       	add	r0,r0
80009d6e:	12 fc       	st.b	--r9,r12
80009d70:	00 00       	add	r0,r0
80009d72:	12 b0       	st.h	r9++,r0
80009d74:	00 00       	add	r0,r0
80009d76:	11 fc       	ld.ub	r12,r8[0x7]
80009d78:	80 00       	ld.sh	r0,r0[0x0]
80009d7a:	8c b8       	ld.uh	r8,r6[0x6]
80009d7c:	00 00       	add	r0,r0
80009d7e:	12 c8       	st.b	r9++,r8
80009d80:	00 00       	add	r0,r0
80009d82:	12 e4       	st.h	--r9,r4
80009d84:	00 00       	add	r0,r0
80009d86:	12 b4       	st.h	r9++,r4
80009d88:	00 00       	add	r0,r0
80009d8a:	12 9c       	mov	r12,r9
80009d8c:	00 00       	add	r0,r0
80009d8e:	13 04       	ld.w	r4,r9++
80009d90:	00 00       	add	r0,r0
80009d92:	11 e8       	ld.ub	r8,r8[0x6]
80009d94:	00 00       	add	r0,r0
80009d96:	11 f8       	ld.ub	r8,r8[0x7]
80009d98:	00 00       	add	r0,r0
80009d9a:	11 ec       	ld.ub	r12,r8[0x6]
80009d9c:	00 00       	add	r0,r0
80009d9e:	11 e4       	ld.ub	r4,r8[0x6]
80009da0:	00 00       	add	r0,r0
80009da2:	12 f8       	st.b	--r9,r8
80009da4:	00 00       	add	r0,r0
80009da6:	13 18       	ld.sh	r8,r9++
80009da8:	80 00       	ld.sh	r0,r0[0x0]
80009daa:	8c d2       	ld.uh	r2,r6[0xa]
80009dac:	80 00       	ld.sh	r0,r0[0x0]
80009dae:	8e e8       	ld.uh	r8,r7[0xc]

80009db0 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80009db0:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80009db2:	30 09       	mov	r9,0
80009db4:	1a d9       	st.w	--sp,r9
80009db6:	1a d9       	st.w	--sp,r9
80009db8:	1a d9       	st.w	--sp,r9
80009dba:	12 98       	mov	r8,r9
80009dbc:	e0 6a 01 00 	mov	r10,256
80009dc0:	48 9b       	lddpc	r11,80009de4 <vTaskStartScheduler+0x34>
80009dc2:	48 ac       	lddpc	r12,80009de8 <vTaskStartScheduler+0x38>
80009dc4:	f0 1f 00 0a 	mcall	80009dec <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80009dc8:	2f dd       	sub	sp,-12
80009dca:	58 1c       	cp.w	r12,1
80009dcc:	c0 a1       	brne	80009de0 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80009dce:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80009dd0:	30 19       	mov	r9,1
80009dd2:	48 88       	lddpc	r8,80009df0 <vTaskStartScheduler+0x40>
80009dd4:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80009dd6:	30 09       	mov	r9,0
80009dd8:	48 78       	lddpc	r8,80009df4 <vTaskStartScheduler+0x44>
80009dda:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80009ddc:	f0 1f 00 07 	mcall	80009df8 <vTaskStartScheduler+0x48>
80009de0:	d8 02       	popm	pc
80009de2:	00 00       	add	r0,r0
80009de4:	80 01       	ld.sh	r1,r0[0x0]
80009de6:	95 c0       	st.w	r10[0x30],r0
80009de8:	80 00       	ld.sh	r0,r0[0x0]
80009dea:	9b 40       	st.w	sp[0x10],r0
80009dec:	80 00       	ld.sh	r0,r0[0x0]
80009dee:	9b c8       	st.w	sp[0x30],r8
80009df0:	00 00       	add	r0,r0
80009df2:	11 ec       	ld.ub	r12,r8[0x6]
80009df4:	00 00       	add	r0,r0
80009df6:	12 dc       	st.w	--r9,r12
80009df8:	80 00       	ld.sh	r0,r0[0x0]
80009dfa:	8d ec       	st.w	r6[0x38],r12

80009dfc <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80009dfc:	16 cc       	st.b	r11++,r12
	return str;
}
80009dfe:	5e fb       	retal	r11

80009e00 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80009e00:	eb cd 40 c0 	pushm	r6-r7,lr
80009e04:	20 3d       	sub	sp,12
80009e06:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80009e08:	30 06       	mov	r6,0
80009e0a:	30 07       	mov	r7,0
80009e0c:	fa e7 00 00 	st.d	sp[0],r6
80009e10:	30 0c       	mov	r12,0
80009e12:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80009e14:	58 08       	cp.w	r8,0
80009e16:	c1 30       	breq	80009e3c <PrintHex+0x3c>
80009e18:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80009e1a:	1a 9c       	mov	r12,sp
80009e1c:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009e20:	58 9e       	cp.w	lr,9
80009e22:	e0 8a 00 04 	brle	80009e2a <PrintHex+0x2a>
80009e26:	2c 9e       	sub	lr,-55
80009e28:	c0 48       	rjmp	80009e30 <PrintHex+0x30>
80009e2a:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009e2e:	2d 0e       	sub	lr,-48
80009e30:	f8 09 0b 0e 	st.b	r12[r9],lr
80009e34:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80009e36:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80009e38:	cf 21       	brne	80009e1c <PrintHex+0x1c>
80009e3a:	c0 48       	rjmp	80009e42 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80009e3c:	33 08       	mov	r8,48
80009e3e:	ba 88       	st.b	sp[0x0],r8
80009e40:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80009e42:	f6 09 01 08 	sub	r8,r11,r9
80009e46:	58 08       	cp.w	r8,0
80009e48:	e0 8a 00 13 	brle	80009e6e <PrintHex+0x6e>
	{
		char num = len - cnt;
80009e4c:	12 1b       	sub	r11,r9
80009e4e:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80009e52:	18 9e       	mov	lr,r12
80009e54:	58 0c       	cp.w	r12,0
80009e56:	e0 8a 00 0c 	brle	80009e6e <PrintHex+0x6e>
80009e5a:	1a 9b       	mov	r11,sp
80009e5c:	12 0b       	add	r11,r9
80009e5e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009e60:	33 07       	mov	r7,48
80009e62:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009e64:	2f f8       	sub	r8,-1
80009e66:	1c 38       	cp.w	r8,lr
80009e68:	cf d5       	brlt	80009e62 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009e6a:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009e6e:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80009e72:	f0 cb ff ff 	sub	r11,r8,-1
80009e76:	58 0b       	cp.w	r11,0
80009e78:	e0 8a 00 19 	brle	80009eaa <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009e7c:	fa cb ff f4 	sub	r11,sp,-12
80009e80:	f6 09 00 09 	add	r9,r11,r9
80009e84:	37 8b       	mov	r11,120
80009e86:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80009e8a:	fa c9 ff f4 	sub	r9,sp,-12
80009e8e:	10 09       	add	r9,r8
80009e90:	33 0b       	mov	r11,48
80009e92:	f3 6b ff f4 	st.b	r9[-12],r11
80009e96:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009e9a:	fa ce 00 01 	sub	lr,sp,1
80009e9e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80009ea0:	11 8b       	ld.ub	r11,r8[0x0]
80009ea2:	12 cb       	st.b	r9++,r11
80009ea4:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80009ea6:	1c 38       	cp.w	r8,lr
80009ea8:	cf c1       	brne	80009ea0 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80009eaa:	14 9c       	mov	r12,r10
80009eac:	2f dd       	sub	sp,-12
80009eae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80009eb2 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80009eb2:	d4 21       	pushm	r4-r7,lr
80009eb4:	20 3d       	sub	sp,12
80009eb6:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80009eb8:	30 06       	mov	r6,0
80009eba:	30 07       	mov	r7,0
80009ebc:	fa e7 00 00 	st.d	sp[0],r6
80009ec0:	30 0c       	mov	r12,0
80009ec2:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80009ec4:	58 08       	cp.w	r8,0
80009ec6:	c0 35       	brlt	80009ecc <PrintDec+0x1a>
80009ec8:	14 97       	mov	r7,r10
80009eca:	c0 58       	rjmp	80009ed4 <PrintDec+0x22>
	{
		*p++ = '-';
80009ecc:	14 97       	mov	r7,r10
80009ece:	32 d9       	mov	r9,45
80009ed0:	0e c9       	st.b	r7++,r9
		i = -i;
80009ed2:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80009ed4:	58 08       	cp.w	r8,0
80009ed6:	c0 51       	brne	80009ee0 <PrintDec+0x2e>
80009ed8:	33 08       	mov	r8,48
80009eda:	ba 88       	st.b	sp[0x0],r8
80009edc:	30 1e       	mov	lr,1
80009ede:	c2 f8       	rjmp	80009f3c <PrintDec+0x8a>
	
	int ten = i%10;
80009ee0:	e0 65 66 67 	mov	r5,26215
80009ee4:	ea 15 66 66 	orh	r5,0x6666
80009ee8:	f0 05 04 44 	muls.d	r4,r8,r5
80009eec:	ea 0c 14 02 	asr	r12,r5,0x2
80009ef0:	f0 09 14 1f 	asr	r9,r8,0x1f
80009ef4:	f8 09 01 09 	sub	r9,r12,r9
80009ef8:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009efc:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80009f00:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80009f02:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80009f04:	e0 66 66 67 	mov	r6,26215
80009f08:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80009f0c:	2d 09       	sub	r9,-48
80009f0e:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80009f12:	2f fe       	sub	lr,-1
		i /= 10;
80009f14:	f0 06 04 44 	muls.d	r4,r8,r6
80009f18:	ea 09 14 02 	asr	r9,r5,0x2
80009f1c:	bf 58       	asr	r8,0x1f
80009f1e:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80009f22:	f0 06 04 44 	muls.d	r4,r8,r6
80009f26:	ea 09 14 02 	asr	r9,r5,0x2
80009f2a:	f0 05 14 1f 	asr	r5,r8,0x1f
80009f2e:	0a 19       	sub	r9,r5
80009f30:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009f34:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80009f38:	58 08       	cp.w	r8,0
80009f3a:	ce 91       	brne	80009f0c <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80009f3c:	f6 0e 01 08 	sub	r8,r11,lr
80009f40:	58 08       	cp.w	r8,0
80009f42:	e0 89 00 06 	brgt	80009f4e <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009f46:	58 0e       	cp.w	lr,0
80009f48:	e0 89 00 14 	brgt	80009f70 <PrintDec+0xbe>
80009f4c:	c1 d8       	rjmp	80009f86 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80009f4e:	1c 1b       	sub	r11,lr
80009f50:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80009f52:	16 9c       	mov	r12,r11
80009f54:	58 0b       	cp.w	r11,0
80009f56:	fe 9a ff f8 	brle	80009f46 <PrintDec+0x94>
80009f5a:	1a 99       	mov	r9,sp
80009f5c:	1c 09       	add	r9,lr
80009f5e:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009f60:	33 06       	mov	r6,48
80009f62:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009f64:	2f f8       	sub	r8,-1
80009f66:	18 38       	cp.w	r8,r12
80009f68:	cf d5       	brlt	80009f62 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80009f6a:	f6 0e 00 0e 	add	lr,r11,lr
80009f6e:	ce cb       	rjmp	80009f46 <PrintDec+0x94>
80009f70:	fa c8 ff f4 	sub	r8,sp,-12
80009f74:	1c 08       	add	r8,lr
80009f76:	20 d8       	sub	r8,13
80009f78:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80009f7c:	11 89       	ld.ub	r9,r8[0x0]
80009f7e:	0e c9       	st.b	r7++,r9
80009f80:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009f82:	16 38       	cp.w	r8,r11
80009f84:	cf c1       	brne	80009f7c <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80009f86:	14 9c       	mov	r12,r10
80009f88:	2f dd       	sub	sp,-12
80009f8a:	d8 22       	popm	r4-r7,pc

80009f8c <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80009f8c:	d4 31       	pushm	r0-r7,lr
80009f8e:	fa cd 02 08 	sub	sp,sp,520
80009f92:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80009f94:	e0 6a 01 00 	mov	r10,256
80009f98:	30 0b       	mov	r11,0
80009f9a:	fa cc fe f8 	sub	r12,sp,-264
80009f9e:	f0 1f 00 4e 	mcall	8000a0d4 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80009fa2:	fa c4 fd d4 	sub	r4,sp,-556
80009fa6:	30 0a       	mov	r10,0
80009fa8:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009faa:	fa c3 ff fc 	sub	r3,sp,-4
80009fae:	e0 61 01 00 	mov	r1,256
80009fb2:	14 90       	mov	r0,r10
			
					if(*str == '%')
80009fb4:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009fb6:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009fba:	02 9a       	mov	r10,r1
80009fbc:	00 9b       	mov	r11,r0
80009fbe:	06 9c       	mov	r12,r3
80009fc0:	f0 1f 00 45 	mcall	8000a0d4 <log+0x148>
			
					if(*str == '%')
80009fc4:	0f 88       	ld.ub	r8,r7[0x0]
80009fc6:	e4 08 18 00 	cp.b	r8,r2
80009fca:	c5 71       	brne	8000a078 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80009fcc:	ee c8 ff ff 	sub	r8,r7,-1
80009fd0:	11 89       	ld.ub	r9,r8[0x0]
80009fd2:	4c 2a       	lddpc	r10,8000a0d8 <log+0x14c>
80009fd4:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80009fd6:	23 09       	sub	r9,48
80009fd8:	30 9a       	mov	r10,9
80009fda:	f4 09 18 00 	cp.b	r9,r10
80009fde:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80009fe2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80009fe6:	f7 b9 08 30 	subls	r9,48
80009fea:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80009fee:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80009ff2:	0f 88       	ld.ub	r8,r7[0x0]
80009ff4:	22 58       	sub	r8,37
80009ff6:	e0 48 00 53 	cp.w	r8,83
80009ffa:	e0 8b 00 31 	brhi	8000a05c <log+0xd0>
80009ffe:	4b 89       	lddpc	r9,8000a0dc <log+0x150>
8000a000:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000a004:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
8000a008:	06 9a       	mov	r10,r3
8000a00a:	40 0b       	lddsp	r11,sp[0x0]
8000a00c:	5c 5b       	castu.b	r11
8000a00e:	68 0c       	ld.w	r12,r4[0x0]
8000a010:	f0 1f 00 34 	mcall	8000a0e0 <log+0x154>
							break;
8000a014:	c2 98       	rjmp	8000a066 <log+0xda>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000a016:	4b 4c       	lddpc	r12,8000a0e4 <log+0x158>
8000a018:	f0 1f 00 34 	mcall	8000a0e8 <log+0x15c>
8000a01c:	08 95       	mov	r5,r4
8000a01e:	06 9c       	mov	r12,r3
							break;
8000a020:	c2 38       	rjmp	8000a066 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000a022:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000a026:	06 9a       	mov	r10,r3
8000a028:	40 0b       	lddsp	r11,sp[0x0]
8000a02a:	5c 5b       	castu.b	r11
8000a02c:	68 0c       	ld.w	r12,r4[0x0]
8000a02e:	f0 1f 00 30 	mcall	8000a0ec <log+0x160>
8000a032:	06 9c       	mov	r12,r3
							break;
8000a034:	c1 98       	rjmp	8000a066 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000a036:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000a03a:	06 9b       	mov	r11,r3
8000a03c:	09 bc       	ld.ub	r12,r4[0x3]
8000a03e:	f0 1f 00 2d 	mcall	8000a0f0 <log+0x164>
8000a042:	06 9c       	mov	r12,r3
							break;
8000a044:	c1 18       	rjmp	8000a066 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000a046:	e8 c5 ff fc 	sub	r5,r4,-4
8000a04a:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
8000a04c:	c0 d8       	rjmp	8000a066 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
8000a04e:	06 9b       	mov	r11,r3
8000a050:	32 5c       	mov	r12,37
8000a052:	f0 1f 00 28 	mcall	8000a0f0 <log+0x164>
8000a056:	08 95       	mov	r5,r4
8000a058:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000a05a:	c0 68       	rjmp	8000a066 <log+0xda>
							
							default:
							log("I need relax.");
8000a05c:	4a 6c       	lddpc	r12,8000a0f4 <log+0x168>
8000a05e:	f0 1f 00 23 	mcall	8000a0e8 <log+0x15c>
8000a062:	08 95       	mov	r5,r4
8000a064:	06 9c       	mov	r12,r3
						}
						str++;
8000a066:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a068:	1a dc       	st.w	--sp,r12
8000a06a:	1a d6       	st.w	--sp,r6
8000a06c:	4a 3b       	lddpc	r11,8000a0f8 <log+0x16c>
8000a06e:	0c 9c       	mov	r12,r6
8000a070:	f0 1f 00 23 	mcall	8000a0fc <log+0x170>
8000a074:	2f ed       	sub	sp,-8
8000a076:	c0 a8       	rjmp	8000a08a <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a078:	2f f7       	sub	r7,-1
8000a07a:	1a d8       	st.w	--sp,r8
8000a07c:	1a d6       	st.w	--sp,r6
8000a07e:	4a 1b       	lddpc	r11,8000a100 <log+0x174>
8000a080:	0c 9c       	mov	r12,r6
8000a082:	f0 1f 00 1f 	mcall	8000a0fc <log+0x170>
8000a086:	08 95       	mov	r5,r4
8000a088:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000a08a:	0f 89       	ld.ub	r9,r7[0x0]
8000a08c:	30 08       	mov	r8,0
8000a08e:	f0 09 18 00 	cp.b	r9,r8
8000a092:	c0 30       	breq	8000a098 <log+0x10c>
8000a094:	0a 94       	mov	r4,r5
8000a096:	c9 2b       	rjmp	80009fba <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000a098:	fa c7 fe f8 	sub	r7,sp,-264
8000a09c:	1a d7       	st.w	--sp,r7
8000a09e:	49 ab       	lddpc	r11,8000a104 <log+0x178>
8000a0a0:	0e 9c       	mov	r12,r7
8000a0a2:	f0 1f 00 17 	mcall	8000a0fc <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000a0a6:	5c 5c       	castu.b	r12
8000a0a8:	f8 c6 ff ff 	sub	r6,r12,-1
8000a0ac:	0c 9c       	mov	r12,r6
8000a0ae:	f0 1f 00 17 	mcall	8000a108 <log+0x17c>
8000a0b2:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000a0b4:	0c 9a       	mov	r10,r6
8000a0b6:	0e 9b       	mov	r11,r7
8000a0b8:	f0 1f 00 15 	mcall	8000a10c <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
8000a0bc:	30 09       	mov	r9,0
8000a0be:	30 5a       	mov	r10,5
8000a0c0:	fa cb fe f8 	sub	r11,sp,-264
8000a0c4:	49 38       	lddpc	r8,8000a110 <log+0x184>
8000a0c6:	70 0c       	ld.w	r12,r8[0x0]
8000a0c8:	f0 1f 00 13 	mcall	8000a114 <log+0x188>
8000a0cc:	2f fd       	sub	sp,-4
}
8000a0ce:	fe 3d fd f8 	sub	sp,-520
8000a0d2:	d8 32       	popm	r0-r7,pc
8000a0d4:	80 00       	ld.sh	r0,r0[0x0]
8000a0d6:	aa 9a       	st.b	r5[0x1],r10
8000a0d8:	00 00       	add	r0,r0
8000a0da:	13 1c       	ld.sh	r12,r9++
8000a0dc:	80 01       	ld.sh	r1,r0[0x0]
8000a0de:	95 c8       	st.w	r10[0x30],r8
8000a0e0:	80 00       	ld.sh	r0,r0[0x0]
8000a0e2:	9e b2       	ld.uh	r2,pc[0x6]
8000a0e4:	80 01       	ld.sh	r1,r0[0x0]
8000a0e6:	98 74       	ld.sh	r4,r12[0xe]
8000a0e8:	80 00       	ld.sh	r0,r0[0x0]
8000a0ea:	9f 8c       	st.w	pc[0x20],r12
8000a0ec:	80 00       	ld.sh	r0,r0[0x0]
8000a0ee:	9e 00       	ld.sh	r0,pc[0x0]
8000a0f0:	80 00       	ld.sh	r0,r0[0x0]
8000a0f2:	9d fc       	st.w	lr[0x3c],r12
8000a0f4:	80 01       	ld.sh	r1,r0[0x0]
8000a0f6:	98 84       	ld.uh	r4,r12[0x0]
8000a0f8:	80 01       	ld.sh	r1,r0[0x0]
8000a0fa:	98 94       	ld.uh	r4,r12[0x2]
8000a0fc:	80 00       	ld.sh	r0,r0[0x0]
8000a0fe:	ad 88       	lsr	r8,0xc
8000a100:	80 01       	ld.sh	r1,r0[0x0]
8000a102:	98 9c       	ld.uh	r12,r12[0x2]
8000a104:	80 01       	ld.sh	r1,r0[0x0]
8000a106:	98 a4       	ld.uh	r4,r12[0x4]
8000a108:	80 00       	ld.sh	r0,r0[0x0]
8000a10a:	90 48       	ld.sh	r8,r8[0x8]
8000a10c:	80 00       	ld.sh	r0,r0[0x0]
8000a10e:	a9 52       	asr	r2,0x9
8000a110:	00 00       	add	r0,r0
8000a112:	46 b0       	lddsp	r0,sp[0x1ac]
8000a114:	80 00       	ld.sh	r0,r0[0x0]
8000a116:	93 9c       	st.w	r9[0x24],r12

8000a118 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000a118:	d4 31       	pushm	r0-r7,lr
8000a11a:	fa cd 02 0c 	sub	sp,sp,524
8000a11e:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000a120:	e0 6a 01 00 	mov	r10,256
8000a124:	30 0b       	mov	r11,0
8000a126:	fa cc fe f4 	sub	r12,sp,-268
8000a12a:	f0 1f 00 4c 	mcall	8000a258 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
8000a12e:	fa c4 fd d0 	sub	r4,sp,-560
8000a132:	30 0a       	mov	r10,0
8000a134:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a136:	fa c3 ff fc 	sub	r3,sp,-4
8000a13a:	e0 61 01 00 	mov	r1,256
8000a13e:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000a140:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a142:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a146:	02 9a       	mov	r10,r1
8000a148:	00 9b       	mov	r11,r0
8000a14a:	06 9c       	mov	r12,r3
8000a14c:	f0 1f 00 43 	mcall	8000a258 <logFromISR+0x140>
			
			if(*str == '%')
8000a150:	0f 88       	ld.ub	r8,r7[0x0]
8000a152:	e4 08 18 00 	cp.b	r8,r2
8000a156:	c5 11       	brne	8000a1f8 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000a158:	ee c8 ff ff 	sub	r8,r7,-1
8000a15c:	11 89       	ld.ub	r9,r8[0x0]
8000a15e:	4c 0a       	lddpc	r10,8000a25c <logFromISR+0x144>
8000a160:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000a162:	23 09       	sub	r9,48
8000a164:	30 9a       	mov	r10,9
8000a166:	f4 09 18 00 	cp.b	r9,r10
8000a16a:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000a16e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000a172:	f7 b9 08 30 	subls	r9,48
8000a176:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000a17a:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000a17e:	0f 88       	ld.ub	r8,r7[0x0]
8000a180:	22 58       	sub	r8,37
8000a182:	e0 48 00 53 	cp.w	r8,83
8000a186:	e0 8b 00 2b 	brhi	8000a1dc <logFromISR+0xc4>
8000a18a:	4b 69       	lddpc	r9,8000a260 <logFromISR+0x148>
8000a18c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000a190:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
8000a194:	06 9a       	mov	r10,r3
8000a196:	40 0b       	lddsp	r11,sp[0x0]
8000a198:	5c 5b       	castu.b	r11
8000a19a:	68 0c       	ld.w	r12,r4[0x0]
8000a19c:	f0 1f 00 32 	mcall	8000a264 <logFromISR+0x14c>
					break;
8000a1a0:	c2 38       	rjmp	8000a1e6 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000a1a2:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000a1a6:	06 9a       	mov	r10,r3
8000a1a8:	40 0b       	lddsp	r11,sp[0x0]
8000a1aa:	5c 5b       	castu.b	r11
8000a1ac:	68 0c       	ld.w	r12,r4[0x0]
8000a1ae:	f0 1f 00 2f 	mcall	8000a268 <logFromISR+0x150>
8000a1b2:	06 9c       	mov	r12,r3
					break;
8000a1b4:	c1 98       	rjmp	8000a1e6 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000a1b6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000a1ba:	06 9b       	mov	r11,r3
8000a1bc:	09 bc       	ld.ub	r12,r4[0x3]
8000a1be:	f0 1f 00 2c 	mcall	8000a26c <logFromISR+0x154>
8000a1c2:	06 9c       	mov	r12,r3
					break;
8000a1c4:	c1 18       	rjmp	8000a1e6 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000a1c6:	e8 c5 ff fc 	sub	r5,r4,-4
8000a1ca:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000a1cc:	c0 d8       	rjmp	8000a1e6 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000a1ce:	06 9b       	mov	r11,r3
8000a1d0:	32 5c       	mov	r12,37
8000a1d2:	f0 1f 00 27 	mcall	8000a26c <logFromISR+0x154>
8000a1d6:	08 95       	mov	r5,r4
8000a1d8:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000a1da:	c0 68       	rjmp	8000a1e6 <logFromISR+0xce>
					default:
					log("I need relax.");
8000a1dc:	4a 5c       	lddpc	r12,8000a270 <logFromISR+0x158>
8000a1de:	f0 1f 00 26 	mcall	8000a274 <logFromISR+0x15c>
8000a1e2:	08 95       	mov	r5,r4
8000a1e4:	06 9c       	mov	r12,r3
				}
				str++;
8000a1e6:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a1e8:	1a dc       	st.w	--sp,r12
8000a1ea:	1a d6       	st.w	--sp,r6
8000a1ec:	4a 3b       	lddpc	r11,8000a278 <logFromISR+0x160>
8000a1ee:	0c 9c       	mov	r12,r6
8000a1f0:	f0 1f 00 23 	mcall	8000a27c <logFromISR+0x164>
8000a1f4:	2f ed       	sub	sp,-8
8000a1f6:	c0 a8       	rjmp	8000a20a <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a1f8:	2f f7       	sub	r7,-1
8000a1fa:	1a d8       	st.w	--sp,r8
8000a1fc:	1a d6       	st.w	--sp,r6
8000a1fe:	4a 1b       	lddpc	r11,8000a280 <logFromISR+0x168>
8000a200:	0c 9c       	mov	r12,r6
8000a202:	f0 1f 00 1f 	mcall	8000a27c <logFromISR+0x164>
8000a206:	08 95       	mov	r5,r4
8000a208:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000a20a:	0f 89       	ld.ub	r9,r7[0x0]
8000a20c:	30 08       	mov	r8,0
8000a20e:	f0 09 18 00 	cp.b	r9,r8
8000a212:	c0 30       	breq	8000a218 <logFromISR+0x100>
8000a214:	0a 94       	mov	r4,r5
8000a216:	c9 8b       	rjmp	8000a146 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000a218:	fa c7 fe f4 	sub	r7,sp,-268
8000a21c:	1a d7       	st.w	--sp,r7
8000a21e:	49 ab       	lddpc	r11,8000a284 <logFromISR+0x16c>
8000a220:	0e 9c       	mov	r12,r7
8000a222:	f0 1f 00 17 	mcall	8000a27c <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000a226:	5c 5c       	castu.b	r12
8000a228:	f8 c6 ff ff 	sub	r6,r12,-1
8000a22c:	0c 9c       	mov	r12,r6
8000a22e:	f0 1f 00 17 	mcall	8000a288 <logFromISR+0x170>
8000a232:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000a234:	0c 9a       	mov	r10,r6
8000a236:	0e 9b       	mov	r11,r7
8000a238:	f0 1f 00 15 	mcall	8000a28c <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000a23c:	30 09       	mov	r9,0
8000a23e:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000a240:	fa ca fe f8 	sub	r10,sp,-264
8000a244:	fa cb fe f4 	sub	r11,sp,-268
8000a248:	49 28       	lddpc	r8,8000a290 <logFromISR+0x178>
8000a24a:	70 0c       	ld.w	r12,r8[0x0]
8000a24c:	f0 1f 00 12 	mcall	8000a294 <logFromISR+0x17c>
8000a250:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000a252:	fe 3d fd f4 	sub	sp,-524
8000a256:	d8 32       	popm	r0-r7,pc
8000a258:	80 00       	ld.sh	r0,r0[0x0]
8000a25a:	aa 9a       	st.b	r5[0x1],r10
8000a25c:	00 00       	add	r0,r0
8000a25e:	13 1d       	ld.sh	sp,r9++
8000a260:	80 01       	ld.sh	r1,r0[0x0]
8000a262:	97 18       	st.w	r11[0x4],r8
8000a264:	80 00       	ld.sh	r0,r0[0x0]
8000a266:	9e b2       	ld.uh	r2,pc[0x6]
8000a268:	80 00       	ld.sh	r0,r0[0x0]
8000a26a:	9e 00       	ld.sh	r0,pc[0x0]
8000a26c:	80 00       	ld.sh	r0,r0[0x0]
8000a26e:	9d fc       	st.w	lr[0x3c],r12
8000a270:	80 01       	ld.sh	r1,r0[0x0]
8000a272:	98 84       	ld.uh	r4,r12[0x0]
8000a274:	80 00       	ld.sh	r0,r0[0x0]
8000a276:	9f 8c       	st.w	pc[0x20],r12
8000a278:	80 01       	ld.sh	r1,r0[0x0]
8000a27a:	98 94       	ld.uh	r4,r12[0x2]
8000a27c:	80 00       	ld.sh	r0,r0[0x0]
8000a27e:	ad 88       	lsr	r8,0xc
8000a280:	80 01       	ld.sh	r1,r0[0x0]
8000a282:	98 9c       	ld.uh	r12,r12[0x2]
8000a284:	80 01       	ld.sh	r1,r0[0x0]
8000a286:	98 a4       	ld.uh	r4,r12[0x4]
8000a288:	80 00       	ld.sh	r0,r0[0x0]
8000a28a:	90 48       	ld.sh	r8,r8[0x8]
8000a28c:	80 00       	ld.sh	r0,r0[0x0]
8000a28e:	a9 52       	asr	r2,0x9
8000a290:	00 00       	add	r0,r0
8000a292:	46 b0       	lddsp	r0,sp[0x1ac]
8000a294:	80 00       	ld.sh	r0,r0[0x0]
8000a296:	93 4c       	st.w	r9[0x10],r12

8000a298 <log_init>:
		
	return str;
}

void log_init(void)
{
8000a298:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000a29a:	30 2b       	mov	r11,2
8000a29c:	49 0c       	lddpc	r12,8000a2dc <log_init+0x44>
8000a29e:	f0 1f 00 11 	mcall	8000a2e0 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000a2a2:	e0 6a 36 00 	mov	r10,13824
8000a2a6:	ea 1a 01 6e 	orh	r10,0x16e
8000a2aa:	48 fb       	lddpc	r11,8000a2e4 <log_init+0x4c>
8000a2ac:	fe 7c 18 00 	mov	r12,-59392
8000a2b0:	f0 1f 00 0e 	mcall	8000a2e8 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000a2b4:	30 4b       	mov	r11,4
8000a2b6:	33 2c       	mov	r12,50
8000a2b8:	f0 1f 00 0d 	mcall	8000a2ec <log_init+0x54>
8000a2bc:	48 d8       	lddpc	r8,8000a2f0 <log_init+0x58>
8000a2be:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000a2c0:	30 09       	mov	r9,0
8000a2c2:	1a d9       	st.w	--sp,r9
8000a2c4:	1a d9       	st.w	--sp,r9
8000a2c6:	1a d9       	st.w	--sp,r9
8000a2c8:	30 28       	mov	r8,2
8000a2ca:	e0 6a 01 80 	mov	r10,384
8000a2ce:	48 ab       	lddpc	r11,8000a2f4 <log_init+0x5c>
8000a2d0:	48 ac       	lddpc	r12,8000a2f8 <log_init+0x60>
8000a2d2:	f0 1f 00 0b 	mcall	8000a2fc <log_init+0x64>
8000a2d6:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000a2d8:	d8 02       	popm	pc
8000a2da:	00 00       	add	r0,r0
8000a2dc:	80 01       	ld.sh	r1,r0[0x0]
8000a2de:	98 b0       	ld.uh	r0,r12[0x6]
8000a2e0:	80 00       	ld.sh	r0,r0[0x0]
8000a2e2:	a4 2c       	st.h	r2[0x4],r12
8000a2e4:	80 01       	ld.sh	r1,r0[0x0]
8000a2e6:	98 68       	ld.sh	r8,r12[0xc]
8000a2e8:	80 00       	ld.sh	r0,r0[0x0]
8000a2ea:	64 78       	ld.w	r8,r2[0x1c]
8000a2ec:	80 00       	ld.sh	r0,r0[0x0]
8000a2ee:	94 f4       	ld.uh	r4,r10[0xe]
8000a2f0:	00 00       	add	r0,r0
8000a2f2:	46 b0       	lddsp	r0,sp[0x1ac]
8000a2f4:	80 01       	ld.sh	r1,r0[0x0]
8000a2f6:	98 ac       	ld.uh	r12,r12[0x4]
8000a2f8:	80 00       	ld.sh	r0,r0[0x0]
8000a2fa:	a3 00       	ld.d	r0,r1
8000a2fc:	80 00       	ld.sh	r0,r0[0x0]
8000a2fe:	9b c8       	st.w	sp[0x30],r8

8000a300 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
8000a300:	eb cd 40 f8 	pushm	r3-r7,lr
8000a304:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000a306:	48 c7       	lddpc	r7,8000a334 <task_log+0x34>
8000a308:	30 05       	mov	r5,0
8000a30a:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
8000a30c:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000a310:	0a 99       	mov	r9,r5
8000a312:	08 9a       	mov	r10,r4
8000a314:	1a 9b       	mov	r11,sp
8000a316:	6e 0c       	ld.w	r12,r7[0x0]
8000a318:	f0 1f 00 08 	mcall	8000a338 <task_log+0x38>
8000a31c:	58 1c       	cp.w	r12,1
8000a31e:	cf 91       	brne	8000a310 <task_log+0x10>
		{
			if( NULL != str)
8000a320:	40 0b       	lddsp	r11,sp[0x0]
8000a322:	58 0b       	cp.w	r11,0
8000a324:	cf 60       	breq	8000a310 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000a326:	06 9c       	mov	r12,r3
8000a328:	f0 1f 00 05 	mcall	8000a33c <task_log+0x3c>
				vPortFree(str);
8000a32c:	40 0c       	lddsp	r12,sp[0x0]
8000a32e:	f0 1f 00 05 	mcall	8000a340 <task_log+0x40>
8000a332:	ce fb       	rjmp	8000a310 <task_log+0x10>
8000a334:	00 00       	add	r0,r0
8000a336:	46 b0       	lddsp	r0,sp[0x1ac]
8000a338:	80 00       	ld.sh	r0,r0[0x0]
8000a33a:	91 90       	st.w	r8[0x24],r0
8000a33c:	80 00       	ld.sh	r0,r0[0x0]
8000a33e:	64 28       	ld.w	r8,r2[0x8]
8000a340:	80 00       	ld.sh	r0,r0[0x0]
8000a342:	90 20       	ld.sh	r0,r8[0x4]

8000a344 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
8000a344:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000a346:	fe 78 10 00 	mov	r8,-61440
8000a34a:	30 19       	mov	r9,1
8000a34c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000a350:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000a354:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000a358:	d3 03       	ssrf	0x10
	local_start_pll0();
8000a35a:	f0 1f 00 14 	mcall	8000a3a8 <main+0x64>
		
	INTC_init_interrupts();
8000a35e:	f0 1f 00 14 	mcall	8000a3ac <main+0x68>
	
	log_init();		
8000a362:	f0 1f 00 14 	mcall	8000a3b0 <main+0x6c>
	log("----start debug----");	
8000a366:	49 4c       	lddpc	r12,8000a3b4 <main+0x70>
8000a368:	f0 1f 00 14 	mcall	8000a3b8 <main+0x74>
		
	rtc_init();
8000a36c:	f0 1f 00 14 	mcall	8000a3bc <main+0x78>
	
	fs_init();//65795
8000a370:	f0 1f 00 14 	mcall	8000a3c0 <main+0x7c>

	tc_init();	
8000a374:	f0 1f 00 14 	mcall	8000a3c4 <main+0x80>
			
	xcmp_init();
8000a378:	f0 1f 00 14 	mcall	8000a3c8 <main+0x84>
	
	app_init();
8000a37c:	f0 1f 00 14 	mcall	8000a3cc <main+0x88>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000a380:	fe 79 10 00 	mov	r9,-61440
8000a384:	f2 f8 01 60 	ld.w	r8,r9[352]
8000a388:	e2 18 00 02 	andl	r8,0x2,COH
8000a38c:	cf c0       	breq	8000a384 <main+0x40>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000a38e:	fe 79 10 00 	mov	r9,-61440
8000a392:	f2 f8 01 60 	ld.w	r8,r9[352]
8000a396:	e2 18 00 02 	andl	r8,0x2,COH
8000a39a:	cf c1       	brne	8000a392 <main+0x4e>
	local_start_timer();
8000a39c:	f0 1f 00 0d 	mcall	8000a3d0 <main+0x8c>
	
	Enable_global_interrupt();
8000a3a0:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
8000a3a2:	f0 1f 00 0d 	mcall	8000a3d4 <main+0x90>
	return 0;
}
8000a3a6:	d8 0a       	popm	pc,r12=0
8000a3a8:	80 00       	ld.sh	r0,r0[0x0]
8000a3aa:	59 f0       	cp.w	r0,31
8000a3ac:	80 00       	ld.sh	r0,r0[0x0]
8000a3ae:	5d 88       	*unknown*
8000a3b0:	80 00       	ld.sh	r0,r0[0x0]
8000a3b2:	a2 98       	st.b	r1[0x1],r8
8000a3b4:	80 01       	ld.sh	r1,r0[0x0]
8000a3b6:	98 c0       	ld.uh	r0,r12[0x8]
8000a3b8:	80 00       	ld.sh	r0,r0[0x0]
8000a3ba:	9f 8c       	st.w	pc[0x20],r12
8000a3bc:	80 00       	ld.sh	r0,r0[0x0]
8000a3be:	5b bc       	cp.w	r12,-5
8000a3c0:	80 00       	ld.sh	r0,r0[0x0]
8000a3c2:	3b c8       	mov	r8,-68
8000a3c4:	80 00       	ld.sh	r0,r0[0x0]
8000a3c6:	5c 84       	casts.h	r4
8000a3c8:	80 00       	ld.sh	r0,r0[0x0]
8000a3ca:	52 f4       	stdsp	sp[0xbc],r4
8000a3cc:	80 00       	ld.sh	r0,r0[0x0]
8000a3ce:	20 48       	sub	r8,4
8000a3d0:	80 00       	ld.sh	r0,r0[0x0]
8000a3d2:	5c 48       	abs	r8
8000a3d4:	80 00       	ld.sh	r0,r0[0x0]
8000a3d6:	9d b0       	st.w	lr[0x2c],r0

8000a3d8 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a3d8:	f8 08 16 05 	lsr	r8,r12,0x5
8000a3dc:	a9 68       	lsl	r8,0x8
8000a3de:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000a3e2:	58 1b       	cp.w	r11,1
8000a3e4:	c0 d0       	breq	8000a3fe <gpio_enable_module_pin+0x26>
8000a3e6:	c0 63       	brcs	8000a3f2 <gpio_enable_module_pin+0x1a>
8000a3e8:	58 2b       	cp.w	r11,2
8000a3ea:	c1 00       	breq	8000a40a <gpio_enable_module_pin+0x32>
8000a3ec:	58 3b       	cp.w	r11,3
8000a3ee:	c1 40       	breq	8000a416 <gpio_enable_module_pin+0x3e>
8000a3f0:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000a3f2:	30 19       	mov	r9,1
8000a3f4:	f2 0c 09 49 	lsl	r9,r9,r12
8000a3f8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000a3fa:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a3fc:	c1 28       	rjmp	8000a420 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000a3fe:	30 19       	mov	r9,1
8000a400:	f2 0c 09 49 	lsl	r9,r9,r12
8000a404:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000a406:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a408:	c0 c8       	rjmp	8000a420 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000a40a:	30 19       	mov	r9,1
8000a40c:	f2 0c 09 49 	lsl	r9,r9,r12
8000a410:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000a412:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a414:	c0 68       	rjmp	8000a420 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000a416:	30 19       	mov	r9,1
8000a418:	f2 0c 09 49 	lsl	r9,r9,r12
8000a41c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000a41e:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000a420:	30 19       	mov	r9,1
8000a422:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a426:	91 2c       	st.w	r8[0x8],r12
8000a428:	5e fd       	retal	0
8000a42a:	d7 03       	nop

8000a42c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000a42c:	d4 21       	pushm	r4-r7,lr
8000a42e:	18 97       	mov	r7,r12
8000a430:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a432:	58 0b       	cp.w	r11,0
8000a434:	c0 31       	brne	8000a43a <gpio_enable_module+0xe>
8000a436:	30 05       	mov	r5,0
8000a438:	c0 d8       	rjmp	8000a452 <gpio_enable_module+0x26>
8000a43a:	30 06       	mov	r6,0
8000a43c:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000a43e:	6e 1b       	ld.w	r11,r7[0x4]
8000a440:	6e 0c       	ld.w	r12,r7[0x0]
8000a442:	f0 1f 00 06 	mcall	8000a458 <gpio_enable_module+0x2c>
8000a446:	18 45       	or	r5,r12
		gpiomap++;
8000a448:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a44a:	2f f6       	sub	r6,-1
8000a44c:	0c 34       	cp.w	r4,r6
8000a44e:	fe 9b ff f8 	brhi	8000a43e <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000a452:	0a 9c       	mov	r12,r5
8000a454:	d8 22       	popm	r4-r7,pc
8000a456:	00 00       	add	r0,r0
8000a458:	80 00       	ld.sh	r0,r0[0x0]
8000a45a:	a3 d8       	cbr	r8,0x3

8000a45c <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a45c:	f8 08 16 05 	lsr	r8,r12,0x5
8000a460:	a9 68       	lsl	r8,0x8
8000a462:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
8000a466:	30 19       	mov	r9,1
8000a468:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a46c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000a470:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000a474:	91 1c       	st.w	r8[0x4],r12
}
8000a476:	5e fc       	retal	r12

8000a478 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a478:	f8 08 16 05 	lsr	r8,r12,0x5
8000a47c:	a9 68       	lsl	r8,0x8
8000a47e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000a482:	30 19       	mov	r9,1
8000a484:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a488:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000a48c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000a490:	91 1c       	st.w	r8[0x4],r12
}
8000a492:	5e fc       	retal	r12

8000a494 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000a494:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000a498:	fe c0 a4 98 	sub	r0,pc,-23400

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000a49c:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000a4a0:	d5 53       	csrf	0x15
  cp      r0, r1
8000a4a2:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000a4a4:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000a4a8:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000a4aa:	c0 62       	brcc	8000a4b6 <idata_load_loop_end>
  cp      r0, r1
8000a4ac:	48 92       	lddpc	r2,8000a4d0 <udata_clear_loop_end+0x4>

8000a4ae <idata_load_loop>:
  brlo    idata_load_loop
8000a4ae:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000a4b0:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000a4b2:	02 30       	cp.w	r0,r1
  cp      r0, r1
8000a4b4:	cf d3       	brcs	8000a4ae <idata_load_loop>

8000a4b6 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000a4b6:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
8000a4ba:	e0 61 46 b8 	mov	r1,18104
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000a4be:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
8000a4c0:	c0 62       	brcc	8000a4cc <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000a4c2:	30 02       	mov	r2,0
8000a4c4:	30 03       	mov	r3,0

8000a4c6 <udata_clear_loop>:
8000a4c6:	a1 22       	st.d	r0++,r2
8000a4c8:	02 30       	cp.w	r0,r1
8000a4ca:	cf e3       	brcs	8000a4c6 <udata_clear_loop>

8000a4cc <udata_clear_loop_end>:
8000a4cc:	fe cf 01 88 	sub	pc,pc,392
8000a4d0:	80 01       	ld.sh	r1,r0[0x0]
8000a4d2:	9e 58       	ld.sh	r8,pc[0xa]

8000a4d4 <free>:
8000a4d4:	d4 01       	pushm	lr
8000a4d6:	e0 68 0a 38 	mov	r8,2616
8000a4da:	18 9b       	mov	r11,r12
8000a4dc:	70 0c       	ld.w	r12,r8[0x0]
8000a4de:	e0 a0 1f 19 	rcall	8000e310 <_free_r>
8000a4e2:	d8 02       	popm	pc

8000a4e4 <malloc>:
8000a4e4:	d4 01       	pushm	lr
8000a4e6:	e0 68 0a 38 	mov	r8,2616
8000a4ea:	18 9b       	mov	r11,r12
8000a4ec:	70 0c       	ld.w	r12,r8[0x0]
8000a4ee:	c0 3c       	rcall	8000a4f4 <_malloc_r>
8000a4f0:	d8 02       	popm	pc
8000a4f2:	d7 03       	nop

8000a4f4 <_malloc_r>:
8000a4f4:	d4 31       	pushm	r0-r7,lr
8000a4f6:	f6 c8 ff f5 	sub	r8,r11,-11
8000a4fa:	18 95       	mov	r5,r12
8000a4fc:	10 97       	mov	r7,r8
8000a4fe:	e0 17 ff f8 	andl	r7,0xfff8
8000a502:	59 68       	cp.w	r8,22
8000a504:	f9 b7 08 10 	movls	r7,16
8000a508:	16 37       	cp.w	r7,r11
8000a50a:	5f 38       	srlo	r8
8000a50c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000a510:	c0 50       	breq	8000a51a <_malloc_r+0x26>
8000a512:	30 c8       	mov	r8,12
8000a514:	99 38       	st.w	r12[0xc],r8
8000a516:	e0 8f 01 fa 	bral	8000a90a <_malloc_r+0x416>
8000a51a:	fe b0 f5 39 	rcall	80008f8c <__malloc_lock>
8000a51e:	e0 47 01 f7 	cp.w	r7,503
8000a522:	e0 8b 00 1d 	brhi	8000a55c <_malloc_r+0x68>
8000a526:	ee 03 16 03 	lsr	r3,r7,0x3
8000a52a:	e0 68 05 38 	mov	r8,1336
8000a52e:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000a532:	70 36       	ld.w	r6,r8[0xc]
8000a534:	10 36       	cp.w	r6,r8
8000a536:	c0 61       	brne	8000a542 <_malloc_r+0x4e>
8000a538:	ec c8 ff f8 	sub	r8,r6,-8
8000a53c:	70 36       	ld.w	r6,r8[0xc]
8000a53e:	10 36       	cp.w	r6,r8
8000a540:	c0 c0       	breq	8000a558 <_malloc_r+0x64>
8000a542:	6c 18       	ld.w	r8,r6[0x4]
8000a544:	e0 18 ff fc 	andl	r8,0xfffc
8000a548:	6c 3a       	ld.w	r10,r6[0xc]
8000a54a:	ec 08 00 09 	add	r9,r6,r8
8000a54e:	0a 9c       	mov	r12,r5
8000a550:	6c 28       	ld.w	r8,r6[0x8]
8000a552:	95 28       	st.w	r10[0x8],r8
8000a554:	91 3a       	st.w	r8[0xc],r10
8000a556:	c4 78       	rjmp	8000a5e4 <_malloc_r+0xf0>
8000a558:	2f e3       	sub	r3,-2
8000a55a:	c4 d8       	rjmp	8000a5f4 <_malloc_r+0x100>
8000a55c:	ee 03 16 09 	lsr	r3,r7,0x9
8000a560:	c0 41       	brne	8000a568 <_malloc_r+0x74>
8000a562:	ee 03 16 03 	lsr	r3,r7,0x3
8000a566:	c2 68       	rjmp	8000a5b2 <_malloc_r+0xbe>
8000a568:	58 43       	cp.w	r3,4
8000a56a:	e0 8b 00 06 	brhi	8000a576 <_malloc_r+0x82>
8000a56e:	ee 03 16 06 	lsr	r3,r7,0x6
8000a572:	2c 83       	sub	r3,-56
8000a574:	c1 f8       	rjmp	8000a5b2 <_malloc_r+0xbe>
8000a576:	59 43       	cp.w	r3,20
8000a578:	e0 8b 00 04 	brhi	8000a580 <_malloc_r+0x8c>
8000a57c:	2a 53       	sub	r3,-91
8000a57e:	c1 a8       	rjmp	8000a5b2 <_malloc_r+0xbe>
8000a580:	e0 43 00 54 	cp.w	r3,84
8000a584:	e0 8b 00 06 	brhi	8000a590 <_malloc_r+0x9c>
8000a588:	ee 03 16 0c 	lsr	r3,r7,0xc
8000a58c:	29 23       	sub	r3,-110
8000a58e:	c1 28       	rjmp	8000a5b2 <_malloc_r+0xbe>
8000a590:	e0 43 01 54 	cp.w	r3,340
8000a594:	e0 8b 00 06 	brhi	8000a5a0 <_malloc_r+0xac>
8000a598:	ee 03 16 0f 	lsr	r3,r7,0xf
8000a59c:	28 93       	sub	r3,-119
8000a59e:	c0 a8       	rjmp	8000a5b2 <_malloc_r+0xbe>
8000a5a0:	e0 43 05 54 	cp.w	r3,1364
8000a5a4:	e0 88 00 04 	brls	8000a5ac <_malloc_r+0xb8>
8000a5a8:	37 e3       	mov	r3,126
8000a5aa:	c0 48       	rjmp	8000a5b2 <_malloc_r+0xbe>
8000a5ac:	ee 03 16 12 	lsr	r3,r7,0x12
8000a5b0:	28 43       	sub	r3,-124
8000a5b2:	e0 6a 05 38 	mov	r10,1336
8000a5b6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000a5ba:	74 36       	ld.w	r6,r10[0xc]
8000a5bc:	c1 98       	rjmp	8000a5ee <_malloc_r+0xfa>
8000a5be:	6c 19       	ld.w	r9,r6[0x4]
8000a5c0:	e0 19 ff fc 	andl	r9,0xfffc
8000a5c4:	f2 07 01 0b 	sub	r11,r9,r7
8000a5c8:	58 fb       	cp.w	r11,15
8000a5ca:	e0 8a 00 04 	brle	8000a5d2 <_malloc_r+0xde>
8000a5ce:	20 13       	sub	r3,1
8000a5d0:	c1 18       	rjmp	8000a5f2 <_malloc_r+0xfe>
8000a5d2:	6c 38       	ld.w	r8,r6[0xc]
8000a5d4:	58 0b       	cp.w	r11,0
8000a5d6:	c0 b5       	brlt	8000a5ec <_malloc_r+0xf8>
8000a5d8:	6c 2a       	ld.w	r10,r6[0x8]
8000a5da:	ec 09 00 09 	add	r9,r6,r9
8000a5de:	0a 9c       	mov	r12,r5
8000a5e0:	91 2a       	st.w	r8[0x8],r10
8000a5e2:	95 38       	st.w	r10[0xc],r8
8000a5e4:	72 18       	ld.w	r8,r9[0x4]
8000a5e6:	a1 a8       	sbr	r8,0x0
8000a5e8:	93 18       	st.w	r9[0x4],r8
8000a5ea:	cb c8       	rjmp	8000a762 <_malloc_r+0x26e>
8000a5ec:	10 96       	mov	r6,r8
8000a5ee:	14 36       	cp.w	r6,r10
8000a5f0:	ce 71       	brne	8000a5be <_malloc_r+0xca>
8000a5f2:	2f f3       	sub	r3,-1
8000a5f4:	e0 6a 05 38 	mov	r10,1336
8000a5f8:	f4 cc ff f8 	sub	r12,r10,-8
8000a5fc:	78 26       	ld.w	r6,r12[0x8]
8000a5fe:	18 36       	cp.w	r6,r12
8000a600:	c6 c0       	breq	8000a6d8 <_malloc_r+0x1e4>
8000a602:	6c 19       	ld.w	r9,r6[0x4]
8000a604:	e0 19 ff fc 	andl	r9,0xfffc
8000a608:	f2 07 01 08 	sub	r8,r9,r7
8000a60c:	58 f8       	cp.w	r8,15
8000a60e:	e0 89 00 8f 	brgt	8000a72c <_malloc_r+0x238>
8000a612:	99 3c       	st.w	r12[0xc],r12
8000a614:	99 2c       	st.w	r12[0x8],r12
8000a616:	58 08       	cp.w	r8,0
8000a618:	c0 55       	brlt	8000a622 <_malloc_r+0x12e>
8000a61a:	ec 09 00 09 	add	r9,r6,r9
8000a61e:	0a 9c       	mov	r12,r5
8000a620:	ce 2b       	rjmp	8000a5e4 <_malloc_r+0xf0>
8000a622:	e0 49 01 ff 	cp.w	r9,511
8000a626:	e0 8b 00 13 	brhi	8000a64c <_malloc_r+0x158>
8000a62a:	a3 99       	lsr	r9,0x3
8000a62c:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a630:	70 2b       	ld.w	r11,r8[0x8]
8000a632:	8d 38       	st.w	r6[0xc],r8
8000a634:	8d 2b       	st.w	r6[0x8],r11
8000a636:	97 36       	st.w	r11[0xc],r6
8000a638:	91 26       	st.w	r8[0x8],r6
8000a63a:	a3 49       	asr	r9,0x2
8000a63c:	74 18       	ld.w	r8,r10[0x4]
8000a63e:	30 1b       	mov	r11,1
8000a640:	f6 09 09 49 	lsl	r9,r11,r9
8000a644:	f1 e9 10 09 	or	r9,r8,r9
8000a648:	95 19       	st.w	r10[0x4],r9
8000a64a:	c4 78       	rjmp	8000a6d8 <_malloc_r+0x1e4>
8000a64c:	f2 0a 16 09 	lsr	r10,r9,0x9
8000a650:	58 4a       	cp.w	r10,4
8000a652:	e0 8b 00 07 	brhi	8000a660 <_malloc_r+0x16c>
8000a656:	f2 0a 16 06 	lsr	r10,r9,0x6
8000a65a:	2c 8a       	sub	r10,-56
8000a65c:	c2 08       	rjmp	8000a69c <_malloc_r+0x1a8>
8000a65e:	d7 03       	nop
8000a660:	59 4a       	cp.w	r10,20
8000a662:	e0 8b 00 04 	brhi	8000a66a <_malloc_r+0x176>
8000a666:	2a 5a       	sub	r10,-91
8000a668:	c1 a8       	rjmp	8000a69c <_malloc_r+0x1a8>
8000a66a:	e0 4a 00 54 	cp.w	r10,84
8000a66e:	e0 8b 00 06 	brhi	8000a67a <_malloc_r+0x186>
8000a672:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000a676:	29 2a       	sub	r10,-110
8000a678:	c1 28       	rjmp	8000a69c <_malloc_r+0x1a8>
8000a67a:	e0 4a 01 54 	cp.w	r10,340
8000a67e:	e0 8b 00 06 	brhi	8000a68a <_malloc_r+0x196>
8000a682:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000a686:	28 9a       	sub	r10,-119
8000a688:	c0 a8       	rjmp	8000a69c <_malloc_r+0x1a8>
8000a68a:	e0 4a 05 54 	cp.w	r10,1364
8000a68e:	e0 88 00 04 	brls	8000a696 <_malloc_r+0x1a2>
8000a692:	37 ea       	mov	r10,126
8000a694:	c0 48       	rjmp	8000a69c <_malloc_r+0x1a8>
8000a696:	f2 0a 16 12 	lsr	r10,r9,0x12
8000a69a:	28 4a       	sub	r10,-124
8000a69c:	e0 6b 05 38 	mov	r11,1336
8000a6a0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000a6a4:	68 28       	ld.w	r8,r4[0x8]
8000a6a6:	08 38       	cp.w	r8,r4
8000a6a8:	c0 e1       	brne	8000a6c4 <_malloc_r+0x1d0>
8000a6aa:	76 19       	ld.w	r9,r11[0x4]
8000a6ac:	a3 4a       	asr	r10,0x2
8000a6ae:	30 1e       	mov	lr,1
8000a6b0:	fc 0a 09 4a 	lsl	r10,lr,r10
8000a6b4:	f3 ea 10 0a 	or	r10,r9,r10
8000a6b8:	10 99       	mov	r9,r8
8000a6ba:	97 1a       	st.w	r11[0x4],r10
8000a6bc:	c0 a8       	rjmp	8000a6d0 <_malloc_r+0x1dc>
8000a6be:	70 28       	ld.w	r8,r8[0x8]
8000a6c0:	08 38       	cp.w	r8,r4
8000a6c2:	c0 60       	breq	8000a6ce <_malloc_r+0x1da>
8000a6c4:	70 1a       	ld.w	r10,r8[0x4]
8000a6c6:	e0 1a ff fc 	andl	r10,0xfffc
8000a6ca:	14 39       	cp.w	r9,r10
8000a6cc:	cf 93       	brcs	8000a6be <_malloc_r+0x1ca>
8000a6ce:	70 39       	ld.w	r9,r8[0xc]
8000a6d0:	8d 39       	st.w	r6[0xc],r9
8000a6d2:	8d 28       	st.w	r6[0x8],r8
8000a6d4:	91 36       	st.w	r8[0xc],r6
8000a6d6:	93 26       	st.w	r9[0x8],r6
8000a6d8:	e6 08 14 02 	asr	r8,r3,0x2
8000a6dc:	30 1b       	mov	r11,1
8000a6de:	e0 64 05 38 	mov	r4,1336
8000a6e2:	f6 08 09 4b 	lsl	r11,r11,r8
8000a6e6:	68 18       	ld.w	r8,r4[0x4]
8000a6e8:	10 3b       	cp.w	r11,r8
8000a6ea:	e0 8b 00 6b 	brhi	8000a7c0 <_malloc_r+0x2cc>
8000a6ee:	f7 e8 00 09 	and	r9,r11,r8
8000a6f2:	c0 b1       	brne	8000a708 <_malloc_r+0x214>
8000a6f4:	e0 13 ff fc 	andl	r3,0xfffc
8000a6f8:	a1 7b       	lsl	r11,0x1
8000a6fa:	2f c3       	sub	r3,-4
8000a6fc:	c0 38       	rjmp	8000a702 <_malloc_r+0x20e>
8000a6fe:	2f c3       	sub	r3,-4
8000a700:	a1 7b       	lsl	r11,0x1
8000a702:	f7 e8 00 09 	and	r9,r11,r8
8000a706:	cf c0       	breq	8000a6fe <_malloc_r+0x20a>
8000a708:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000a70c:	06 92       	mov	r2,r3
8000a70e:	1c 91       	mov	r1,lr
8000a710:	62 36       	ld.w	r6,r1[0xc]
8000a712:	c2 e8       	rjmp	8000a76e <_malloc_r+0x27a>
8000a714:	6c 1a       	ld.w	r10,r6[0x4]
8000a716:	e0 1a ff fc 	andl	r10,0xfffc
8000a71a:	f4 07 01 08 	sub	r8,r10,r7
8000a71e:	58 f8       	cp.w	r8,15
8000a720:	e0 8a 00 15 	brle	8000a74a <_malloc_r+0x256>
8000a724:	6c 3a       	ld.w	r10,r6[0xc]
8000a726:	6c 29       	ld.w	r9,r6[0x8]
8000a728:	95 29       	st.w	r10[0x8],r9
8000a72a:	93 3a       	st.w	r9[0xc],r10
8000a72c:	0e 99       	mov	r9,r7
8000a72e:	ec 07 00 07 	add	r7,r6,r7
8000a732:	a1 a9       	sbr	r9,0x0
8000a734:	99 37       	st.w	r12[0xc],r7
8000a736:	99 27       	st.w	r12[0x8],r7
8000a738:	8d 19       	st.w	r6[0x4],r9
8000a73a:	ee 08 09 08 	st.w	r7[r8],r8
8000a73e:	8f 2c       	st.w	r7[0x8],r12
8000a740:	8f 3c       	st.w	r7[0xc],r12
8000a742:	a1 a8       	sbr	r8,0x0
8000a744:	0a 9c       	mov	r12,r5
8000a746:	8f 18       	st.w	r7[0x4],r8
8000a748:	c0 d8       	rjmp	8000a762 <_malloc_r+0x26e>
8000a74a:	6c 39       	ld.w	r9,r6[0xc]
8000a74c:	58 08       	cp.w	r8,0
8000a74e:	c0 f5       	brlt	8000a76c <_malloc_r+0x278>
8000a750:	ec 0a 00 0a 	add	r10,r6,r10
8000a754:	74 18       	ld.w	r8,r10[0x4]
8000a756:	a1 a8       	sbr	r8,0x0
8000a758:	0a 9c       	mov	r12,r5
8000a75a:	95 18       	st.w	r10[0x4],r8
8000a75c:	6c 28       	ld.w	r8,r6[0x8]
8000a75e:	93 28       	st.w	r9[0x8],r8
8000a760:	91 39       	st.w	r8[0xc],r9
8000a762:	fe b0 f4 1b 	rcall	80008f98 <__malloc_unlock>
8000a766:	ec cc ff f8 	sub	r12,r6,-8
8000a76a:	d8 32       	popm	r0-r7,pc
8000a76c:	12 96       	mov	r6,r9
8000a76e:	02 36       	cp.w	r6,r1
8000a770:	cd 21       	brne	8000a714 <_malloc_r+0x220>
8000a772:	2f f2       	sub	r2,-1
8000a774:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000a778:	c0 30       	breq	8000a77e <_malloc_r+0x28a>
8000a77a:	2f 81       	sub	r1,-8
8000a77c:	cc ab       	rjmp	8000a710 <_malloc_r+0x21c>
8000a77e:	1c 98       	mov	r8,lr
8000a780:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000a784:	c0 81       	brne	8000a794 <_malloc_r+0x2a0>
8000a786:	68 19       	ld.w	r9,r4[0x4]
8000a788:	f6 08 11 ff 	rsub	r8,r11,-1
8000a78c:	f3 e8 00 08 	and	r8,r9,r8
8000a790:	89 18       	st.w	r4[0x4],r8
8000a792:	c0 78       	rjmp	8000a7a0 <_malloc_r+0x2ac>
8000a794:	f0 c9 00 08 	sub	r9,r8,8
8000a798:	20 13       	sub	r3,1
8000a79a:	70 08       	ld.w	r8,r8[0x0]
8000a79c:	12 38       	cp.w	r8,r9
8000a79e:	cf 10       	breq	8000a780 <_malloc_r+0x28c>
8000a7a0:	a1 7b       	lsl	r11,0x1
8000a7a2:	68 18       	ld.w	r8,r4[0x4]
8000a7a4:	10 3b       	cp.w	r11,r8
8000a7a6:	e0 8b 00 0d 	brhi	8000a7c0 <_malloc_r+0x2cc>
8000a7aa:	58 0b       	cp.w	r11,0
8000a7ac:	c0 a0       	breq	8000a7c0 <_malloc_r+0x2cc>
8000a7ae:	04 93       	mov	r3,r2
8000a7b0:	c0 38       	rjmp	8000a7b6 <_malloc_r+0x2c2>
8000a7b2:	2f c3       	sub	r3,-4
8000a7b4:	a1 7b       	lsl	r11,0x1
8000a7b6:	f7 e8 00 09 	and	r9,r11,r8
8000a7ba:	ca 71       	brne	8000a708 <_malloc_r+0x214>
8000a7bc:	cf bb       	rjmp	8000a7b2 <_malloc_r+0x2be>
8000a7be:	d7 03       	nop
8000a7c0:	68 23       	ld.w	r3,r4[0x8]
8000a7c2:	66 12       	ld.w	r2,r3[0x4]
8000a7c4:	e0 12 ff fc 	andl	r2,0xfffc
8000a7c8:	0e 32       	cp.w	r2,r7
8000a7ca:	5f 39       	srlo	r9
8000a7cc:	e4 07 01 08 	sub	r8,r2,r7
8000a7d0:	58 f8       	cp.w	r8,15
8000a7d2:	5f aa       	srle	r10
8000a7d4:	f5 e9 10 09 	or	r9,r10,r9
8000a7d8:	e0 80 00 9a 	breq	8000a90c <_malloc_r+0x418>
8000a7dc:	e0 68 13 28 	mov	r8,4904
8000a7e0:	70 01       	ld.w	r1,r8[0x0]
8000a7e2:	e0 68 09 44 	mov	r8,2372
8000a7e6:	2f 01       	sub	r1,-16
8000a7e8:	70 08       	ld.w	r8,r8[0x0]
8000a7ea:	0e 01       	add	r1,r7
8000a7ec:	5b f8       	cp.w	r8,-1
8000a7ee:	c0 40       	breq	8000a7f6 <_malloc_r+0x302>
8000a7f0:	28 11       	sub	r1,-127
8000a7f2:	e0 11 ff 80 	andl	r1,0xff80
8000a7f6:	02 9b       	mov	r11,r1
8000a7f8:	0a 9c       	mov	r12,r5
8000a7fa:	e0 a0 02 b7 	rcall	8000ad68 <_sbrk_r>
8000a7fe:	18 96       	mov	r6,r12
8000a800:	5b fc       	cp.w	r12,-1
8000a802:	c7 50       	breq	8000a8ec <_malloc_r+0x3f8>
8000a804:	e6 02 00 08 	add	r8,r3,r2
8000a808:	10 3c       	cp.w	r12,r8
8000a80a:	c0 32       	brcc	8000a810 <_malloc_r+0x31c>
8000a80c:	08 33       	cp.w	r3,r4
8000a80e:	c6 f1       	brne	8000a8ec <_malloc_r+0x3f8>
8000a810:	e0 6a 13 2c 	mov	r10,4908
8000a814:	74 09       	ld.w	r9,r10[0x0]
8000a816:	e2 09 00 09 	add	r9,r1,r9
8000a81a:	95 09       	st.w	r10[0x0],r9
8000a81c:	10 36       	cp.w	r6,r8
8000a81e:	c0 a1       	brne	8000a832 <_malloc_r+0x33e>
8000a820:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000a824:	c0 71       	brne	8000a832 <_malloc_r+0x33e>
8000a826:	e2 02 00 02 	add	r2,r1,r2
8000a82a:	68 28       	ld.w	r8,r4[0x8]
8000a82c:	a1 a2       	sbr	r2,0x0
8000a82e:	91 12       	st.w	r8[0x4],r2
8000a830:	c4 f8       	rjmp	8000a8ce <_malloc_r+0x3da>
8000a832:	e0 6a 09 44 	mov	r10,2372
8000a836:	74 0b       	ld.w	r11,r10[0x0]
8000a838:	5b fb       	cp.w	r11,-1
8000a83a:	c0 31       	brne	8000a840 <_malloc_r+0x34c>
8000a83c:	95 06       	st.w	r10[0x0],r6
8000a83e:	c0 78       	rjmp	8000a84c <_malloc_r+0x358>
8000a840:	ec 09 00 09 	add	r9,r6,r9
8000a844:	e0 6a 13 2c 	mov	r10,4908
8000a848:	10 19       	sub	r9,r8
8000a84a:	95 09       	st.w	r10[0x0],r9
8000a84c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000a850:	f0 09 11 08 	rsub	r9,r8,8
8000a854:	58 08       	cp.w	r8,0
8000a856:	f2 08 17 10 	movne	r8,r9
8000a85a:	ed d8 e1 06 	addne	r6,r6,r8
8000a85e:	28 08       	sub	r8,-128
8000a860:	ec 01 00 01 	add	r1,r6,r1
8000a864:	0a 9c       	mov	r12,r5
8000a866:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000a86a:	f0 01 01 01 	sub	r1,r8,r1
8000a86e:	02 9b       	mov	r11,r1
8000a870:	e0 a0 02 7c 	rcall	8000ad68 <_sbrk_r>
8000a874:	e0 68 13 2c 	mov	r8,4908
8000a878:	5b fc       	cp.w	r12,-1
8000a87a:	ec 0c 17 00 	moveq	r12,r6
8000a87e:	f9 b1 00 00 	moveq	r1,0
8000a882:	70 09       	ld.w	r9,r8[0x0]
8000a884:	0c 1c       	sub	r12,r6
8000a886:	89 26       	st.w	r4[0x8],r6
8000a888:	02 0c       	add	r12,r1
8000a88a:	12 01       	add	r1,r9
8000a88c:	a1 ac       	sbr	r12,0x0
8000a88e:	91 01       	st.w	r8[0x0],r1
8000a890:	8d 1c       	st.w	r6[0x4],r12
8000a892:	08 33       	cp.w	r3,r4
8000a894:	c1 d0       	breq	8000a8ce <_malloc_r+0x3da>
8000a896:	58 f2       	cp.w	r2,15
8000a898:	e0 8b 00 05 	brhi	8000a8a2 <_malloc_r+0x3ae>
8000a89c:	30 18       	mov	r8,1
8000a89e:	8d 18       	st.w	r6[0x4],r8
8000a8a0:	c2 68       	rjmp	8000a8ec <_malloc_r+0x3f8>
8000a8a2:	30 59       	mov	r9,5
8000a8a4:	20 c2       	sub	r2,12
8000a8a6:	e0 12 ff f8 	andl	r2,0xfff8
8000a8aa:	e6 02 00 08 	add	r8,r3,r2
8000a8ae:	91 29       	st.w	r8[0x8],r9
8000a8b0:	91 19       	st.w	r8[0x4],r9
8000a8b2:	66 18       	ld.w	r8,r3[0x4]
8000a8b4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a8b8:	e5 e8 10 08 	or	r8,r2,r8
8000a8bc:	87 18       	st.w	r3[0x4],r8
8000a8be:	58 f2       	cp.w	r2,15
8000a8c0:	e0 88 00 07 	brls	8000a8ce <_malloc_r+0x3da>
8000a8c4:	e6 cb ff f8 	sub	r11,r3,-8
8000a8c8:	0a 9c       	mov	r12,r5
8000a8ca:	e0 a0 1d 23 	rcall	8000e310 <_free_r>
8000a8ce:	e0 69 13 24 	mov	r9,4900
8000a8d2:	72 0a       	ld.w	r10,r9[0x0]
8000a8d4:	e0 68 13 2c 	mov	r8,4908
8000a8d8:	70 08       	ld.w	r8,r8[0x0]
8000a8da:	14 38       	cp.w	r8,r10
8000a8dc:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a8e0:	e0 69 13 20 	mov	r9,4896
8000a8e4:	72 0a       	ld.w	r10,r9[0x0]
8000a8e6:	14 38       	cp.w	r8,r10
8000a8e8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a8ec:	68 28       	ld.w	r8,r4[0x8]
8000a8ee:	70 18       	ld.w	r8,r8[0x4]
8000a8f0:	e0 18 ff fc 	andl	r8,0xfffc
8000a8f4:	0e 38       	cp.w	r8,r7
8000a8f6:	5f 39       	srlo	r9
8000a8f8:	0e 18       	sub	r8,r7
8000a8fa:	58 f8       	cp.w	r8,15
8000a8fc:	5f aa       	srle	r10
8000a8fe:	f5 e9 10 09 	or	r9,r10,r9
8000a902:	c0 50       	breq	8000a90c <_malloc_r+0x418>
8000a904:	0a 9c       	mov	r12,r5
8000a906:	fe b0 f3 49 	rcall	80008f98 <__malloc_unlock>
8000a90a:	d8 3a       	popm	r0-r7,pc,r12=0
8000a90c:	68 26       	ld.w	r6,r4[0x8]
8000a90e:	a1 a8       	sbr	r8,0x0
8000a910:	0e 99       	mov	r9,r7
8000a912:	a1 a9       	sbr	r9,0x0
8000a914:	8d 19       	st.w	r6[0x4],r9
8000a916:	ec 07 00 07 	add	r7,r6,r7
8000a91a:	0a 9c       	mov	r12,r5
8000a91c:	89 27       	st.w	r4[0x8],r7
8000a91e:	8f 18       	st.w	r7[0x4],r8
8000a920:	fe b0 f3 3c 	rcall	80008f98 <__malloc_unlock>
8000a924:	ec cc ff f8 	sub	r12,r6,-8
8000a928:	d8 32       	popm	r0-r7,pc
8000a92a:	d7 03       	nop

8000a92c <memcmp>:
8000a92c:	d4 01       	pushm	lr
8000a92e:	30 08       	mov	r8,0
8000a930:	c0 d8       	rjmp	8000a94a <memcmp+0x1e>
8000a932:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000a936:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a93a:	20 1a       	sub	r10,1
8000a93c:	2f f8       	sub	r8,-1
8000a93e:	f2 0e 18 00 	cp.b	lr,r9
8000a942:	c0 40       	breq	8000a94a <memcmp+0x1e>
8000a944:	fc 09 01 0c 	sub	r12,lr,r9
8000a948:	d8 02       	popm	pc
8000a94a:	58 0a       	cp.w	r10,0
8000a94c:	cf 31       	brne	8000a932 <memcmp+0x6>
8000a94e:	14 9c       	mov	r12,r10
8000a950:	d8 02       	popm	pc

8000a952 <memcpy>:
8000a952:	58 8a       	cp.w	r10,8
8000a954:	c2 f5       	brlt	8000a9b2 <memcpy+0x60>
8000a956:	f9 eb 10 09 	or	r9,r12,r11
8000a95a:	e2 19 00 03 	andl	r9,0x3,COH
8000a95e:	e0 81 00 97 	brne	8000aa8c <memcpy+0x13a>
8000a962:	e0 4a 00 20 	cp.w	r10,32
8000a966:	c3 b4       	brge	8000a9dc <memcpy+0x8a>
8000a968:	f4 08 14 02 	asr	r8,r10,0x2
8000a96c:	f0 09 11 08 	rsub	r9,r8,8
8000a970:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000a974:	76 69       	ld.w	r9,r11[0x18]
8000a976:	99 69       	st.w	r12[0x18],r9
8000a978:	76 59       	ld.w	r9,r11[0x14]
8000a97a:	99 59       	st.w	r12[0x14],r9
8000a97c:	76 49       	ld.w	r9,r11[0x10]
8000a97e:	99 49       	st.w	r12[0x10],r9
8000a980:	76 39       	ld.w	r9,r11[0xc]
8000a982:	99 39       	st.w	r12[0xc],r9
8000a984:	76 29       	ld.w	r9,r11[0x8]
8000a986:	99 29       	st.w	r12[0x8],r9
8000a988:	76 19       	ld.w	r9,r11[0x4]
8000a98a:	99 19       	st.w	r12[0x4],r9
8000a98c:	76 09       	ld.w	r9,r11[0x0]
8000a98e:	99 09       	st.w	r12[0x0],r9
8000a990:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000a994:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000a998:	e0 1a 00 03 	andl	r10,0x3
8000a99c:	f4 0a 11 04 	rsub	r10,r10,4
8000a9a0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a9a4:	17 a9       	ld.ub	r9,r11[0x2]
8000a9a6:	b0 a9       	st.b	r8[0x2],r9
8000a9a8:	17 99       	ld.ub	r9,r11[0x1]
8000a9aa:	b0 99       	st.b	r8[0x1],r9
8000a9ac:	17 89       	ld.ub	r9,r11[0x0]
8000a9ae:	b0 89       	st.b	r8[0x0],r9
8000a9b0:	5e fc       	retal	r12
8000a9b2:	f4 0a 11 09 	rsub	r10,r10,9
8000a9b6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a9ba:	17 f9       	ld.ub	r9,r11[0x7]
8000a9bc:	b8 f9       	st.b	r12[0x7],r9
8000a9be:	17 e9       	ld.ub	r9,r11[0x6]
8000a9c0:	b8 e9       	st.b	r12[0x6],r9
8000a9c2:	17 d9       	ld.ub	r9,r11[0x5]
8000a9c4:	b8 d9       	st.b	r12[0x5],r9
8000a9c6:	17 c9       	ld.ub	r9,r11[0x4]
8000a9c8:	b8 c9       	st.b	r12[0x4],r9
8000a9ca:	17 b9       	ld.ub	r9,r11[0x3]
8000a9cc:	b8 b9       	st.b	r12[0x3],r9
8000a9ce:	17 a9       	ld.ub	r9,r11[0x2]
8000a9d0:	b8 a9       	st.b	r12[0x2],r9
8000a9d2:	17 99       	ld.ub	r9,r11[0x1]
8000a9d4:	b8 99       	st.b	r12[0x1],r9
8000a9d6:	17 89       	ld.ub	r9,r11[0x0]
8000a9d8:	b8 89       	st.b	r12[0x0],r9
8000a9da:	5e fc       	retal	r12
8000a9dc:	eb cd 40 c0 	pushm	r6-r7,lr
8000a9e0:	18 99       	mov	r9,r12
8000a9e2:	22 0a       	sub	r10,32
8000a9e4:	b7 07       	ld.d	r6,r11++
8000a9e6:	b3 26       	st.d	r9++,r6
8000a9e8:	b7 07       	ld.d	r6,r11++
8000a9ea:	b3 26       	st.d	r9++,r6
8000a9ec:	b7 07       	ld.d	r6,r11++
8000a9ee:	b3 26       	st.d	r9++,r6
8000a9f0:	b7 07       	ld.d	r6,r11++
8000a9f2:	b3 26       	st.d	r9++,r6
8000a9f4:	22 0a       	sub	r10,32
8000a9f6:	cf 74       	brge	8000a9e4 <memcpy+0x92>
8000a9f8:	2f 0a       	sub	r10,-16
8000a9fa:	c0 65       	brlt	8000aa06 <memcpy+0xb4>
8000a9fc:	b7 07       	ld.d	r6,r11++
8000a9fe:	b3 26       	st.d	r9++,r6
8000aa00:	b7 07       	ld.d	r6,r11++
8000aa02:	b3 26       	st.d	r9++,r6
8000aa04:	21 0a       	sub	r10,16
8000aa06:	5c 3a       	neg	r10
8000aa08:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000aa0c:	d7 03       	nop
8000aa0e:	d7 03       	nop
8000aa10:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000aa14:	f3 66 00 0e 	st.b	r9[14],r6
8000aa18:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000aa1c:	f3 66 00 0d 	st.b	r9[13],r6
8000aa20:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000aa24:	f3 66 00 0c 	st.b	r9[12],r6
8000aa28:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000aa2c:	f3 66 00 0b 	st.b	r9[11],r6
8000aa30:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000aa34:	f3 66 00 0a 	st.b	r9[10],r6
8000aa38:	f7 36 00 09 	ld.ub	r6,r11[9]
8000aa3c:	f3 66 00 09 	st.b	r9[9],r6
8000aa40:	f7 36 00 08 	ld.ub	r6,r11[8]
8000aa44:	f3 66 00 08 	st.b	r9[8],r6
8000aa48:	f7 36 00 07 	ld.ub	r6,r11[7]
8000aa4c:	f3 66 00 07 	st.b	r9[7],r6
8000aa50:	f7 36 00 06 	ld.ub	r6,r11[6]
8000aa54:	f3 66 00 06 	st.b	r9[6],r6
8000aa58:	f7 36 00 05 	ld.ub	r6,r11[5]
8000aa5c:	f3 66 00 05 	st.b	r9[5],r6
8000aa60:	f7 36 00 04 	ld.ub	r6,r11[4]
8000aa64:	f3 66 00 04 	st.b	r9[4],r6
8000aa68:	f7 36 00 03 	ld.ub	r6,r11[3]
8000aa6c:	f3 66 00 03 	st.b	r9[3],r6
8000aa70:	f7 36 00 02 	ld.ub	r6,r11[2]
8000aa74:	f3 66 00 02 	st.b	r9[2],r6
8000aa78:	f7 36 00 01 	ld.ub	r6,r11[1]
8000aa7c:	f3 66 00 01 	st.b	r9[1],r6
8000aa80:	f7 36 00 00 	ld.ub	r6,r11[0]
8000aa84:	f3 66 00 00 	st.b	r9[0],r6
8000aa88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000aa8c:	20 1a       	sub	r10,1
8000aa8e:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000aa92:	f8 0a 0b 09 	st.b	r12[r10],r9
8000aa96:	cf b1       	brne	8000aa8c <memcpy+0x13a>
8000aa98:	5e fc       	retal	r12

8000aa9a <memset>:
8000aa9a:	18 98       	mov	r8,r12
8000aa9c:	c0 38       	rjmp	8000aaa2 <memset+0x8>
8000aa9e:	10 cb       	st.b	r8++,r11
8000aaa0:	20 1a       	sub	r10,1
8000aaa2:	58 0a       	cp.w	r10,0
8000aaa4:	cf d1       	brne	8000aa9e <memset+0x4>
8000aaa6:	5e fc       	retal	r12

8000aaa8 <_realloc_r>:
8000aaa8:	d4 31       	pushm	r0-r7,lr
8000aaaa:	20 1d       	sub	sp,4
8000aaac:	16 94       	mov	r4,r11
8000aaae:	18 92       	mov	r2,r12
8000aab0:	14 9b       	mov	r11,r10
8000aab2:	58 04       	cp.w	r4,0
8000aab4:	c0 51       	brne	8000aabe <_realloc_r+0x16>
8000aab6:	fe b0 fd 1f 	rcall	8000a4f4 <_malloc_r>
8000aaba:	18 95       	mov	r5,r12
8000aabc:	c5 39       	rjmp	8000ad62 <_realloc_r+0x2ba>
8000aabe:	50 0a       	stdsp	sp[0x0],r10
8000aac0:	fe b0 f2 66 	rcall	80008f8c <__malloc_lock>
8000aac4:	40 0b       	lddsp	r11,sp[0x0]
8000aac6:	f6 c8 ff f5 	sub	r8,r11,-11
8000aaca:	e8 c1 00 08 	sub	r1,r4,8
8000aace:	10 96       	mov	r6,r8
8000aad0:	62 1c       	ld.w	r12,r1[0x4]
8000aad2:	e0 16 ff f8 	andl	r6,0xfff8
8000aad6:	59 68       	cp.w	r8,22
8000aad8:	f9 b6 08 10 	movls	r6,16
8000aadc:	16 36       	cp.w	r6,r11
8000aade:	5f 38       	srlo	r8
8000aae0:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000aae4:	c0 50       	breq	8000aaee <_realloc_r+0x46>
8000aae6:	30 c8       	mov	r8,12
8000aae8:	30 05       	mov	r5,0
8000aaea:	85 38       	st.w	r2[0xc],r8
8000aaec:	c3 b9       	rjmp	8000ad62 <_realloc_r+0x2ba>
8000aaee:	18 90       	mov	r0,r12
8000aaf0:	e0 10 ff fc 	andl	r0,0xfffc
8000aaf4:	0c 30       	cp.w	r0,r6
8000aaf6:	e0 84 01 0b 	brge	8000ad0c <_realloc_r+0x264>
8000aafa:	e0 68 05 38 	mov	r8,1336
8000aafe:	e2 00 00 09 	add	r9,r1,r0
8000ab02:	70 25       	ld.w	r5,r8[0x8]
8000ab04:	0a 39       	cp.w	r9,r5
8000ab06:	c0 90       	breq	8000ab18 <_realloc_r+0x70>
8000ab08:	72 1a       	ld.w	r10,r9[0x4]
8000ab0a:	a1 ca       	cbr	r10,0x0
8000ab0c:	f2 0a 00 0a 	add	r10,r9,r10
8000ab10:	74 1a       	ld.w	r10,r10[0x4]
8000ab12:	ed ba 00 00 	bld	r10,0x0
8000ab16:	c2 20       	breq	8000ab5a <_realloc_r+0xb2>
8000ab18:	72 1a       	ld.w	r10,r9[0x4]
8000ab1a:	e0 1a ff fc 	andl	r10,0xfffc
8000ab1e:	f4 00 00 03 	add	r3,r10,r0
8000ab22:	0a 39       	cp.w	r9,r5
8000ab24:	c1 31       	brne	8000ab4a <_realloc_r+0xa2>
8000ab26:	ec c7 ff f0 	sub	r7,r6,-16
8000ab2a:	0e 33       	cp.w	r3,r7
8000ab2c:	c1 95       	brlt	8000ab5e <_realloc_r+0xb6>
8000ab2e:	e2 06 00 09 	add	r9,r1,r6
8000ab32:	0c 13       	sub	r3,r6
8000ab34:	a1 a3       	sbr	r3,0x0
8000ab36:	93 13       	st.w	r9[0x4],r3
8000ab38:	91 29       	st.w	r8[0x8],r9
8000ab3a:	04 9c       	mov	r12,r2
8000ab3c:	62 18       	ld.w	r8,r1[0x4]
8000ab3e:	08 95       	mov	r5,r4
8000ab40:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000ab44:	10 46       	or	r6,r8
8000ab46:	83 16       	st.w	r1[0x4],r6
8000ab48:	c0 b9       	rjmp	8000ad5e <_realloc_r+0x2b6>
8000ab4a:	0c 33       	cp.w	r3,r6
8000ab4c:	c0 95       	brlt	8000ab5e <_realloc_r+0xb6>
8000ab4e:	72 28       	ld.w	r8,r9[0x8]
8000ab50:	02 97       	mov	r7,r1
8000ab52:	72 39       	ld.w	r9,r9[0xc]
8000ab54:	93 28       	st.w	r9[0x8],r8
8000ab56:	91 39       	st.w	r8[0xc],r9
8000ab58:	cd c8       	rjmp	8000ad10 <_realloc_r+0x268>
8000ab5a:	30 0a       	mov	r10,0
8000ab5c:	14 99       	mov	r9,r10
8000ab5e:	ed bc 00 00 	bld	r12,0x0
8000ab62:	e0 80 00 95 	breq	8000ac8c <_realloc_r+0x1e4>
8000ab66:	62 07       	ld.w	r7,r1[0x0]
8000ab68:	e2 07 01 07 	sub	r7,r1,r7
8000ab6c:	6e 1c       	ld.w	r12,r7[0x4]
8000ab6e:	e0 1c ff fc 	andl	r12,0xfffc
8000ab72:	58 09       	cp.w	r9,0
8000ab74:	c5 60       	breq	8000ac20 <_realloc_r+0x178>
8000ab76:	f8 00 00 03 	add	r3,r12,r0
8000ab7a:	0a 39       	cp.w	r9,r5
8000ab7c:	c4 81       	brne	8000ac0c <_realloc_r+0x164>
8000ab7e:	14 03       	add	r3,r10
8000ab80:	ec c9 ff f0 	sub	r9,r6,-16
8000ab84:	12 33       	cp.w	r3,r9
8000ab86:	c4 d5       	brlt	8000ac20 <_realloc_r+0x178>
8000ab88:	6e 3a       	ld.w	r10,r7[0xc]
8000ab8a:	6e 29       	ld.w	r9,r7[0x8]
8000ab8c:	95 29       	st.w	r10[0x8],r9
8000ab8e:	93 3a       	st.w	r9[0xc],r10
8000ab90:	ee c5 ff f8 	sub	r5,r7,-8
8000ab94:	e0 ca 00 04 	sub	r10,r0,4
8000ab98:	e0 4a 00 24 	cp.w	r10,36
8000ab9c:	e0 8b 00 25 	brhi	8000abe6 <_realloc_r+0x13e>
8000aba0:	0a 99       	mov	r9,r5
8000aba2:	59 3a       	cp.w	r10,19
8000aba4:	e0 88 00 1a 	brls	8000abd8 <_realloc_r+0x130>
8000aba8:	09 09       	ld.w	r9,r4++
8000abaa:	8b 09       	st.w	r5[0x0],r9
8000abac:	09 09       	ld.w	r9,r4++
8000abae:	8f 39       	st.w	r7[0xc],r9
8000abb0:	ee c9 ff f0 	sub	r9,r7,-16
8000abb4:	59 ba       	cp.w	r10,27
8000abb6:	e0 88 00 11 	brls	8000abd8 <_realloc_r+0x130>
8000abba:	09 0b       	ld.w	r11,r4++
8000abbc:	93 0b       	st.w	r9[0x0],r11
8000abbe:	09 09       	ld.w	r9,r4++
8000abc0:	8f 59       	st.w	r7[0x14],r9
8000abc2:	ee c9 ff e8 	sub	r9,r7,-24
8000abc6:	e0 4a 00 24 	cp.w	r10,36
8000abca:	c0 71       	brne	8000abd8 <_realloc_r+0x130>
8000abcc:	09 0a       	ld.w	r10,r4++
8000abce:	93 0a       	st.w	r9[0x0],r10
8000abd0:	ee c9 ff e0 	sub	r9,r7,-32
8000abd4:	09 0a       	ld.w	r10,r4++
8000abd6:	8f 7a       	st.w	r7[0x1c],r10
8000abd8:	09 0a       	ld.w	r10,r4++
8000abda:	12 aa       	st.w	r9++,r10
8000abdc:	68 0a       	ld.w	r10,r4[0x0]
8000abde:	93 0a       	st.w	r9[0x0],r10
8000abe0:	68 1a       	ld.w	r10,r4[0x4]
8000abe2:	93 1a       	st.w	r9[0x4],r10
8000abe4:	c0 78       	rjmp	8000abf2 <_realloc_r+0x14a>
8000abe6:	50 08       	stdsp	sp[0x0],r8
8000abe8:	08 9b       	mov	r11,r4
8000abea:	0a 9c       	mov	r12,r5
8000abec:	e0 a0 1e 35 	rcall	8000e856 <memmove>
8000abf0:	40 08       	lddsp	r8,sp[0x0]
8000abf2:	ee 06 00 09 	add	r9,r7,r6
8000abf6:	0c 13       	sub	r3,r6
8000abf8:	a1 a3       	sbr	r3,0x0
8000abfa:	93 13       	st.w	r9[0x4],r3
8000abfc:	91 29       	st.w	r8[0x8],r9
8000abfe:	04 9c       	mov	r12,r2
8000ac00:	6e 18       	ld.w	r8,r7[0x4]
8000ac02:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000ac06:	10 46       	or	r6,r8
8000ac08:	8f 16       	st.w	r7[0x4],r6
8000ac0a:	ca a8       	rjmp	8000ad5e <_realloc_r+0x2b6>
8000ac0c:	14 03       	add	r3,r10
8000ac0e:	0c 33       	cp.w	r3,r6
8000ac10:	c0 85       	brlt	8000ac20 <_realloc_r+0x178>
8000ac12:	72 28       	ld.w	r8,r9[0x8]
8000ac14:	72 39       	ld.w	r9,r9[0xc]
8000ac16:	93 28       	st.w	r9[0x8],r8
8000ac18:	91 39       	st.w	r8[0xc],r9
8000ac1a:	6e 28       	ld.w	r8,r7[0x8]
8000ac1c:	6e 39       	ld.w	r9,r7[0xc]
8000ac1e:	c0 78       	rjmp	8000ac2c <_realloc_r+0x184>
8000ac20:	f8 00 00 03 	add	r3,r12,r0
8000ac24:	0c 33       	cp.w	r3,r6
8000ac26:	c3 35       	brlt	8000ac8c <_realloc_r+0x1e4>
8000ac28:	6e 39       	ld.w	r9,r7[0xc]
8000ac2a:	6e 28       	ld.w	r8,r7[0x8]
8000ac2c:	93 28       	st.w	r9[0x8],r8
8000ac2e:	91 39       	st.w	r8[0xc],r9
8000ac30:	e0 ca 00 04 	sub	r10,r0,4
8000ac34:	ee cc ff f8 	sub	r12,r7,-8
8000ac38:	e0 4a 00 24 	cp.w	r10,36
8000ac3c:	e0 8b 00 24 	brhi	8000ac84 <_realloc_r+0x1dc>
8000ac40:	59 3a       	cp.w	r10,19
8000ac42:	e0 88 00 1a 	brls	8000ac76 <_realloc_r+0x1ce>
8000ac46:	09 08       	ld.w	r8,r4++
8000ac48:	99 08       	st.w	r12[0x0],r8
8000ac4a:	09 08       	ld.w	r8,r4++
8000ac4c:	8f 38       	st.w	r7[0xc],r8
8000ac4e:	ee cc ff f0 	sub	r12,r7,-16
8000ac52:	59 ba       	cp.w	r10,27
8000ac54:	e0 88 00 11 	brls	8000ac76 <_realloc_r+0x1ce>
8000ac58:	09 08       	ld.w	r8,r4++
8000ac5a:	99 08       	st.w	r12[0x0],r8
8000ac5c:	09 08       	ld.w	r8,r4++
8000ac5e:	8f 58       	st.w	r7[0x14],r8
8000ac60:	ee cc ff e8 	sub	r12,r7,-24
8000ac64:	e0 4a 00 24 	cp.w	r10,36
8000ac68:	c0 71       	brne	8000ac76 <_realloc_r+0x1ce>
8000ac6a:	09 08       	ld.w	r8,r4++
8000ac6c:	99 08       	st.w	r12[0x0],r8
8000ac6e:	ee cc ff e0 	sub	r12,r7,-32
8000ac72:	09 08       	ld.w	r8,r4++
8000ac74:	8f 78       	st.w	r7[0x1c],r8
8000ac76:	09 08       	ld.w	r8,r4++
8000ac78:	18 a8       	st.w	r12++,r8
8000ac7a:	68 08       	ld.w	r8,r4[0x0]
8000ac7c:	99 08       	st.w	r12[0x0],r8
8000ac7e:	68 18       	ld.w	r8,r4[0x4]
8000ac80:	99 18       	st.w	r12[0x4],r8
8000ac82:	c4 78       	rjmp	8000ad10 <_realloc_r+0x268>
8000ac84:	08 9b       	mov	r11,r4
8000ac86:	e0 a0 1d e8 	rcall	8000e856 <memmove>
8000ac8a:	c4 38       	rjmp	8000ad10 <_realloc_r+0x268>
8000ac8c:	04 9c       	mov	r12,r2
8000ac8e:	fe b0 fc 33 	rcall	8000a4f4 <_malloc_r>
8000ac92:	18 95       	mov	r5,r12
8000ac94:	c3 a0       	breq	8000ad08 <_realloc_r+0x260>
8000ac96:	62 18       	ld.w	r8,r1[0x4]
8000ac98:	f8 c9 00 08 	sub	r9,r12,8
8000ac9c:	a1 c8       	cbr	r8,0x0
8000ac9e:	e2 08 00 08 	add	r8,r1,r8
8000aca2:	10 39       	cp.w	r9,r8
8000aca4:	c0 71       	brne	8000acb2 <_realloc_r+0x20a>
8000aca6:	72 13       	ld.w	r3,r9[0x4]
8000aca8:	02 97       	mov	r7,r1
8000acaa:	e0 13 ff fc 	andl	r3,0xfffc
8000acae:	00 03       	add	r3,r0
8000acb0:	c3 08       	rjmp	8000ad10 <_realloc_r+0x268>
8000acb2:	e0 ca 00 04 	sub	r10,r0,4
8000acb6:	e0 4a 00 24 	cp.w	r10,36
8000acba:	e0 8b 00 20 	brhi	8000acfa <_realloc_r+0x252>
8000acbe:	08 99       	mov	r9,r4
8000acc0:	18 98       	mov	r8,r12
8000acc2:	59 3a       	cp.w	r10,19
8000acc4:	e0 88 00 14 	brls	8000acec <_realloc_r+0x244>
8000acc8:	13 0b       	ld.w	r11,r9++
8000acca:	10 ab       	st.w	r8++,r11
8000accc:	13 0b       	ld.w	r11,r9++
8000acce:	10 ab       	st.w	r8++,r11
8000acd0:	59 ba       	cp.w	r10,27
8000acd2:	e0 88 00 0d 	brls	8000acec <_realloc_r+0x244>
8000acd6:	13 0b       	ld.w	r11,r9++
8000acd8:	10 ab       	st.w	r8++,r11
8000acda:	13 0b       	ld.w	r11,r9++
8000acdc:	10 ab       	st.w	r8++,r11
8000acde:	e0 4a 00 24 	cp.w	r10,36
8000ace2:	c0 51       	brne	8000acec <_realloc_r+0x244>
8000ace4:	13 0a       	ld.w	r10,r9++
8000ace6:	10 aa       	st.w	r8++,r10
8000ace8:	13 0a       	ld.w	r10,r9++
8000acea:	10 aa       	st.w	r8++,r10
8000acec:	13 0a       	ld.w	r10,r9++
8000acee:	10 aa       	st.w	r8++,r10
8000acf0:	72 0a       	ld.w	r10,r9[0x0]
8000acf2:	91 0a       	st.w	r8[0x0],r10
8000acf4:	72 19       	ld.w	r9,r9[0x4]
8000acf6:	91 19       	st.w	r8[0x4],r9
8000acf8:	c0 48       	rjmp	8000ad00 <_realloc_r+0x258>
8000acfa:	08 9b       	mov	r11,r4
8000acfc:	e0 a0 1d ad 	rcall	8000e856 <memmove>
8000ad00:	08 9b       	mov	r11,r4
8000ad02:	04 9c       	mov	r12,r2
8000ad04:	e0 a0 1b 06 	rcall	8000e310 <_free_r>
8000ad08:	04 9c       	mov	r12,r2
8000ad0a:	c2 a8       	rjmp	8000ad5e <_realloc_r+0x2b6>
8000ad0c:	00 93       	mov	r3,r0
8000ad0e:	02 97       	mov	r7,r1
8000ad10:	e6 06 01 09 	sub	r9,r3,r6
8000ad14:	6e 18       	ld.w	r8,r7[0x4]
8000ad16:	58 f9       	cp.w	r9,15
8000ad18:	e0 88 00 16 	brls	8000ad44 <_realloc_r+0x29c>
8000ad1c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000ad20:	ed e8 10 08 	or	r8,r6,r8
8000ad24:	8f 18       	st.w	r7[0x4],r8
8000ad26:	12 98       	mov	r8,r9
8000ad28:	a1 a8       	sbr	r8,0x0
8000ad2a:	ee 06 00 0b 	add	r11,r7,r6
8000ad2e:	f6 09 00 09 	add	r9,r11,r9
8000ad32:	97 18       	st.w	r11[0x4],r8
8000ad34:	72 18       	ld.w	r8,r9[0x4]
8000ad36:	a1 a8       	sbr	r8,0x0
8000ad38:	2f 8b       	sub	r11,-8
8000ad3a:	93 18       	st.w	r9[0x4],r8
8000ad3c:	04 9c       	mov	r12,r2
8000ad3e:	e0 a0 1a e9 	rcall	8000e310 <_free_r>
8000ad42:	c0 b8       	rjmp	8000ad58 <_realloc_r+0x2b0>
8000ad44:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000ad48:	e7 e8 10 08 	or	r8,r3,r8
8000ad4c:	8f 18       	st.w	r7[0x4],r8
8000ad4e:	ee 03 00 03 	add	r3,r7,r3
8000ad52:	66 18       	ld.w	r8,r3[0x4]
8000ad54:	a1 a8       	sbr	r8,0x0
8000ad56:	87 18       	st.w	r3[0x4],r8
8000ad58:	04 9c       	mov	r12,r2
8000ad5a:	ee c5 ff f8 	sub	r5,r7,-8
8000ad5e:	fe b0 f1 1d 	rcall	80008f98 <__malloc_unlock>
8000ad62:	0a 9c       	mov	r12,r5
8000ad64:	2f fd       	sub	sp,-4
8000ad66:	d8 32       	popm	r0-r7,pc

8000ad68 <_sbrk_r>:
8000ad68:	d4 21       	pushm	r4-r7,lr
8000ad6a:	30 08       	mov	r8,0
8000ad6c:	18 97       	mov	r7,r12
8000ad6e:	e0 66 46 b4 	mov	r6,18100
8000ad72:	16 9c       	mov	r12,r11
8000ad74:	8d 08       	st.w	r6[0x0],r8
8000ad76:	c1 1d       	rcall	8000af98 <_sbrk>
8000ad78:	5b fc       	cp.w	r12,-1
8000ad7a:	c0 51       	brne	8000ad84 <_sbrk_r+0x1c>
8000ad7c:	6c 08       	ld.w	r8,r6[0x0]
8000ad7e:	58 08       	cp.w	r8,0
8000ad80:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ad84:	d8 22       	popm	r4-r7,pc
8000ad86:	d7 03       	nop

8000ad88 <sprintf>:
8000ad88:	d4 01       	pushm	lr
8000ad8a:	21 7d       	sub	sp,92
8000ad8c:	e0 68 ff ff 	mov	r8,65535
8000ad90:	ea 18 7f ff 	orh	r8,0x7fff
8000ad94:	50 58       	stdsp	sp[0x14],r8
8000ad96:	50 28       	stdsp	sp[0x8],r8
8000ad98:	e0 68 02 08 	mov	r8,520
8000ad9c:	ba 68       	st.h	sp[0xc],r8
8000ad9e:	3f f8       	mov	r8,-1
8000ada0:	ba 78       	st.h	sp[0xe],r8
8000ada2:	e0 68 0a 38 	mov	r8,2616
8000ada6:	50 4c       	stdsp	sp[0x10],r12
8000ada8:	16 9a       	mov	r10,r11
8000adaa:	50 0c       	stdsp	sp[0x0],r12
8000adac:	fa c9 ff a0 	sub	r9,sp,-96
8000adb0:	70 0c       	ld.w	r12,r8[0x0]
8000adb2:	1a 9b       	mov	r11,sp
8000adb4:	e0 a0 02 ac 	rcall	8000b30c <_vfprintf_r>
8000adb8:	30 09       	mov	r9,0
8000adba:	40 08       	lddsp	r8,sp[0x0]
8000adbc:	b0 89       	st.b	r8[0x0],r9
8000adbe:	2e 9d       	sub	sp,-92
8000adc0:	d8 02       	popm	pc
8000adc2:	d7 03       	nop

8000adc4 <strcpy>:
8000adc4:	30 08       	mov	r8,0
8000adc6:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000adca:	f8 08 0b 09 	st.b	r12[r8],r9
8000adce:	2f f8       	sub	r8,-1
8000add0:	58 09       	cp.w	r9,0
8000add2:	cf a1       	brne	8000adc6 <strcpy+0x2>
8000add4:	5e fc       	retal	r12

8000add6 <strlen>:
8000add6:	30 09       	mov	r9,0
8000add8:	18 98       	mov	r8,r12
8000adda:	c0 28       	rjmp	8000adde <strlen+0x8>
8000addc:	2f f8       	sub	r8,-1
8000adde:	11 8a       	ld.ub	r10,r8[0x0]
8000ade0:	f2 0a 18 00 	cp.b	r10,r9
8000ade4:	cf c1       	brne	8000addc <strlen+0x6>
8000ade6:	f0 0c 01 0c 	sub	r12,r8,r12
8000adea:	5e fc       	retal	r12

8000adec <strncpy>:
8000adec:	30 08       	mov	r8,0
8000adee:	10 3a       	cp.w	r10,r8
8000adf0:	5e 0c       	reteq	r12
8000adf2:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000adf6:	f8 08 0b 09 	st.b	r12[r8],r9
8000adfa:	2f f8       	sub	r8,-1
8000adfc:	58 09       	cp.w	r9,0
8000adfe:	cf 81       	brne	8000adee <strncpy+0x2>
8000ae00:	10 3a       	cp.w	r10,r8
8000ae02:	5e 0c       	reteq	r12
8000ae04:	f8 08 0b 09 	st.b	r12[r8],r9
8000ae08:	2f f8       	sub	r8,-1
8000ae0a:	cf bb       	rjmp	8000ae00 <strncpy+0x14>

8000ae0c <strtok>:
8000ae0c:	d4 21       	pushm	r4-r7,lr
8000ae0e:	20 1d       	sub	sp,4
8000ae10:	e0 65 0a 38 	mov	r5,2616
8000ae14:	18 97       	mov	r7,r12
8000ae16:	6a 04       	ld.w	r4,r5[0x0]
8000ae18:	e8 f6 00 e8 	ld.w	r6,r4[232]
8000ae1c:	58 06       	cp.w	r6,0
8000ae1e:	c3 51       	brne	8000ae88 <strtok+0x7c>
8000ae20:	50 0b       	stdsp	sp[0x0],r11
8000ae22:	35 0c       	mov	r12,80
8000ae24:	fe b0 fb 60 	rcall	8000a4e4 <malloc>
8000ae28:	6a 08       	ld.w	r8,r5[0x0]
8000ae2a:	e9 4c 00 e8 	st.w	r4[232],r12
8000ae2e:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae32:	93 26       	st.w	r9[0x8],r6
8000ae34:	93 06       	st.w	r9[0x0],r6
8000ae36:	93 16       	st.w	r9[0x4],r6
8000ae38:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae3c:	93 46       	st.w	r9[0x10],r6
8000ae3e:	93 36       	st.w	r9[0xc],r6
8000ae40:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae44:	93 66       	st.w	r9[0x18],r6
8000ae46:	93 56       	st.w	r9[0x14],r6
8000ae48:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae4c:	93 b6       	st.w	r9[0x2c],r6
8000ae4e:	93 a6       	st.w	r9[0x28],r6
8000ae50:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae54:	93 d6       	st.w	r9[0x34],r6
8000ae56:	93 c6       	st.w	r9[0x30],r6
8000ae58:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae5c:	93 f6       	st.w	r9[0x3c],r6
8000ae5e:	93 e6       	st.w	r9[0x38],r6
8000ae60:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae64:	f3 46 00 44 	st.w	r9[68],r6
8000ae68:	f3 46 00 40 	st.w	r9[64],r6
8000ae6c:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae70:	f3 46 00 4c 	st.w	r9[76],r6
8000ae74:	f3 46 00 48 	st.w	r9[72],r6
8000ae78:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ae7c:	f3 66 00 1c 	st.b	r9[28],r6
8000ae80:	f0 f8 00 e8 	ld.w	r8,r8[232]
8000ae84:	40 0b       	lddsp	r11,sp[0x0]
8000ae86:	91 96       	st.w	r8[0x24],r6
8000ae88:	e0 68 0a 38 	mov	r8,2616
8000ae8c:	70 08       	ld.w	r8,r8[0x0]
8000ae8e:	0e 9c       	mov	r12,r7
8000ae90:	f0 fa 00 e8 	ld.w	r10,r8[232]
8000ae94:	30 19       	mov	r9,1
8000ae96:	c0 3c       	rcall	8000ae9c <__strtok_r>
8000ae98:	2f fd       	sub	sp,-4
8000ae9a:	d8 22       	popm	r4-r7,pc

8000ae9c <__strtok_r>:
8000ae9c:	d4 21       	pushm	r4-r7,lr
8000ae9e:	58 0c       	cp.w	r12,0
8000aea0:	c0 41       	brne	8000aea8 <__strtok_r+0xc>
8000aea2:	74 0c       	ld.w	r12,r10[0x0]
8000aea4:	58 0c       	cp.w	r12,0
8000aea6:	c2 90       	breq	8000aef8 <__strtok_r+0x5c>
8000aea8:	18 98       	mov	r8,r12
8000aeaa:	16 97       	mov	r7,r11
8000aeac:	11 3e       	ld.ub	lr,r8++
8000aeae:	c0 a8       	rjmp	8000aec2 <__strtok_r+0x26>
8000aeb0:	0c 3e       	cp.w	lr,r6
8000aeb2:	c0 81       	brne	8000aec2 <__strtok_r+0x26>
8000aeb4:	58 09       	cp.w	r9,0
8000aeb6:	c0 30       	breq	8000aebc <__strtok_r+0x20>
8000aeb8:	10 9c       	mov	r12,r8
8000aeba:	cf 7b       	rjmp	8000aea8 <__strtok_r+0xc>
8000aebc:	95 08       	st.w	r10[0x0],r8
8000aebe:	b8 89       	st.b	r12[0x0],r9
8000aec0:	d8 22       	popm	r4-r7,pc
8000aec2:	0f 36       	ld.ub	r6,r7++
8000aec4:	58 06       	cp.w	r6,0
8000aec6:	cf 51       	brne	8000aeb0 <__strtok_r+0x14>
8000aec8:	58 0e       	cp.w	lr,0
8000aeca:	c0 51       	brne	8000aed4 <__strtok_r+0x38>
8000aecc:	95 0e       	st.w	r10[0x0],lr
8000aece:	1c 9c       	mov	r12,lr
8000aed0:	d8 22       	popm	r4-r7,pc
8000aed2:	12 98       	mov	r8,r9
8000aed4:	10 99       	mov	r9,r8
8000aed6:	16 97       	mov	r7,r11
8000aed8:	13 3e       	ld.ub	lr,r9++
8000aeda:	0f 36       	ld.ub	r6,r7++
8000aedc:	1c 36       	cp.w	r6,lr
8000aede:	c0 a1       	brne	8000aef2 <__strtok_r+0x56>
8000aee0:	58 0e       	cp.w	lr,0
8000aee2:	fc 09 17 00 	moveq	r9,lr
8000aee6:	f9 bb 01 00 	movne	r11,0
8000aeea:	f1 fb 1e 00 	st.bne	r8[0x0],r11
8000aeee:	95 09       	st.w	r10[0x0],r9
8000aef0:	d8 22       	popm	r4-r7,pc
8000aef2:	58 06       	cp.w	r6,0
8000aef4:	cf 31       	brne	8000aeda <__strtok_r+0x3e>
8000aef6:	ce eb       	rjmp	8000aed2 <__strtok_r+0x36>
8000aef8:	d8 22       	popm	r4-r7,pc
8000aefa:	d7 03       	nop

8000aefc <_close>:
8000aefc:	30 28       	mov	r8,2
8000aefe:	d6 73       	breakpoint
8000af00:	3f fc       	mov	r12,-1
8000af02:	35 8b       	mov	r11,88
8000af04:	58 0c       	cp.w	r12,0
8000af06:	5e 4c       	retge	r12
8000af08:	e0 6a 46 b4 	mov	r10,18100
8000af0c:	95 0b       	st.w	r10[0x0],r11
8000af0e:	5e fc       	retal	r12

8000af10 <_lseek>:
8000af10:	30 58       	mov	r8,5
8000af12:	d6 73       	breakpoint
8000af14:	3f fc       	mov	r12,-1
8000af16:	35 8b       	mov	r11,88
8000af18:	58 0c       	cp.w	r12,0
8000af1a:	5e 4c       	retge	r12
8000af1c:	e0 6a 46 b4 	mov	r10,18100
8000af20:	95 0b       	st.w	r10[0x0],r11
8000af22:	5e fc       	retal	r12

8000af24 <isatty>:
8000af24:	30 b8       	mov	r8,11
8000af26:	d6 73       	breakpoint
8000af28:	3f fc       	mov	r12,-1
8000af2a:	35 8b       	mov	r11,88
8000af2c:	58 0c       	cp.w	r12,0
8000af2e:	5e 4c       	retge	r12
8000af30:	e0 6a 46 b4 	mov	r10,18100
8000af34:	95 0b       	st.w	r10[0x0],r11
8000af36:	5e fc       	retal	r12

8000af38 <_fstat_host>:
8000af38:	30 98       	mov	r8,9
8000af3a:	d6 73       	breakpoint
8000af3c:	3f fc       	mov	r12,-1
8000af3e:	35 8b       	mov	r11,88
8000af40:	58 0c       	cp.w	r12,0
8000af42:	5e 4c       	retge	r12
8000af44:	e0 6a 46 b4 	mov	r10,18100
8000af48:	95 0b       	st.w	r10[0x0],r11
8000af4a:	5e fc       	retal	r12

8000af4c <_fstat>:
8000af4c:	d4 21       	pushm	r4-r7,lr
8000af4e:	21 0d       	sub	sp,64
8000af50:	16 97       	mov	r7,r11
8000af52:	1a 9b       	mov	r11,sp
8000af54:	cf 2f       	rcall	8000af38 <_fstat_host>
8000af56:	c0 34       	brge	8000af5c <_fstat+0x10>
8000af58:	3f fc       	mov	r12,-1
8000af5a:	c1 c8       	rjmp	8000af92 <_fstat+0x46>
8000af5c:	40 08       	lddsp	r8,sp[0x0]
8000af5e:	ae 08       	st.h	r7[0x0],r8
8000af60:	40 18       	lddsp	r8,sp[0x4]
8000af62:	ae 18       	st.h	r7[0x2],r8
8000af64:	40 28       	lddsp	r8,sp[0x8]
8000af66:	8f 18       	st.w	r7[0x4],r8
8000af68:	40 38       	lddsp	r8,sp[0xc]
8000af6a:	ae 48       	st.h	r7[0x8],r8
8000af6c:	40 48       	lddsp	r8,sp[0x10]
8000af6e:	ae 58       	st.h	r7[0xa],r8
8000af70:	40 58       	lddsp	r8,sp[0x14]
8000af72:	ae 68       	st.h	r7[0xc],r8
8000af74:	40 68       	lddsp	r8,sp[0x18]
8000af76:	ae 78       	st.h	r7[0xe],r8
8000af78:	40 88       	lddsp	r8,sp[0x20]
8000af7a:	8f 48       	st.w	r7[0x10],r8
8000af7c:	40 a8       	lddsp	r8,sp[0x28]
8000af7e:	8f b8       	st.w	r7[0x2c],r8
8000af80:	40 c8       	lddsp	r8,sp[0x30]
8000af82:	8f c8       	st.w	r7[0x30],r8
8000af84:	40 d8       	lddsp	r8,sp[0x34]
8000af86:	8f 58       	st.w	r7[0x14],r8
8000af88:	40 e8       	lddsp	r8,sp[0x38]
8000af8a:	30 0c       	mov	r12,0
8000af8c:	8f 78       	st.w	r7[0x1c],r8
8000af8e:	40 f8       	lddsp	r8,sp[0x3c]
8000af90:	8f 98       	st.w	r7[0x24],r8
8000af92:	2f 0d       	sub	sp,-64
8000af94:	d8 22       	popm	r4-r7,pc
8000af96:	d7 03       	nop

8000af98 <_sbrk>:
8000af98:	d4 01       	pushm	lr
8000af9a:	e0 68 13 54 	mov	r8,4948
8000af9e:	70 09       	ld.w	r9,r8[0x0]
8000afa0:	58 09       	cp.w	r9,0
8000afa2:	c0 41       	brne	8000afaa <_sbrk+0x12>
8000afa4:	e0 69 46 b8 	mov	r9,18104
8000afa8:	91 09       	st.w	r8[0x0],r9
8000afaa:	e0 69 13 54 	mov	r9,4948
8000afae:	e0 7a 70 00 	mov	r10,94208
8000afb2:	72 08       	ld.w	r8,r9[0x0]
8000afb4:	f0 0c 00 0c 	add	r12,r8,r12
8000afb8:	14 3c       	cp.w	r12,r10
8000afba:	e0 8b 00 04 	brhi	8000afc2 <_sbrk+0x2a>
8000afbe:	93 0c       	st.w	r9[0x0],r12
8000afc0:	c0 68       	rjmp	8000afcc <_sbrk+0x34>
8000afc2:	e0 a0 18 2b 	rcall	8000e018 <__errno>
8000afc6:	30 c8       	mov	r8,12
8000afc8:	99 08       	st.w	r12[0x0],r8
8000afca:	3f f8       	mov	r8,-1
8000afcc:	10 9c       	mov	r12,r8
8000afce:	d8 02       	popm	pc

8000afd0 <get_arg>:
8000afd0:	d4 31       	pushm	r0-r7,lr
8000afd2:	20 8d       	sub	sp,32
8000afd4:	fa c4 ff bc 	sub	r4,sp,-68
8000afd8:	50 4b       	stdsp	sp[0x10],r11
8000afda:	68 2e       	ld.w	lr,r4[0x8]
8000afdc:	50 58       	stdsp	sp[0x14],r8
8000afde:	12 96       	mov	r6,r9
8000afe0:	7c 0b       	ld.w	r11,lr[0x0]
8000afe2:	70 05       	ld.w	r5,r8[0x0]
8000afe4:	50 6e       	stdsp	sp[0x18],lr
8000afe6:	58 0b       	cp.w	r11,0
8000afe8:	f4 0b 17 00 	moveq	r11,r10
8000afec:	68 03       	ld.w	r3,r4[0x0]
8000afee:	68 11       	ld.w	r1,r4[0x4]
8000aff0:	40 49       	lddsp	r9,sp[0x10]
8000aff2:	30 08       	mov	r8,0
8000aff4:	c2 e9       	rjmp	8000b250 <get_arg+0x280>
8000aff6:	2f fb       	sub	r11,-1
8000aff8:	32 5c       	mov	r12,37
8000affa:	17 8a       	ld.ub	r10,r11[0x0]
8000affc:	f8 0a 18 00 	cp.b	r10,r12
8000b000:	5f 1e       	srne	lr
8000b002:	f0 0a 18 00 	cp.b	r10,r8
8000b006:	5f 1c       	srne	r12
8000b008:	fd ec 00 0c 	and	r12,lr,r12
8000b00c:	f0 0c 18 00 	cp.b	r12,r8
8000b010:	cf 31       	brne	8000aff6 <get_arg+0x26>
8000b012:	58 0a       	cp.w	r10,0
8000b014:	e0 80 01 2b 	breq	8000b26a <get_arg+0x29a>
8000b018:	30 0c       	mov	r12,0
8000b01a:	3f fa       	mov	r10,-1
8000b01c:	18 90       	mov	r0,r12
8000b01e:	50 3a       	stdsp	sp[0xc],r10
8000b020:	18 94       	mov	r4,r12
8000b022:	18 92       	mov	r2,r12
8000b024:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000b028:	16 97       	mov	r7,r11
8000b02a:	50 7c       	stdsp	sp[0x1c],r12
8000b02c:	4c ec       	lddpc	r12,8000b164 <get_arg+0x194>
8000b02e:	0f 3a       	ld.ub	r10,r7++
8000b030:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000b034:	40 7c       	lddsp	r12,sp[0x1c]
8000b036:	1c 0c       	add	r12,lr
8000b038:	4c ce       	lddpc	lr,8000b168 <get_arg+0x198>
8000b03a:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000b03e:	20 1e       	sub	lr,1
8000b040:	50 0e       	stdsp	sp[0x0],lr
8000b042:	4c be       	lddpc	lr,8000b16c <get_arg+0x19c>
8000b044:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000b048:	50 7c       	stdsp	sp[0x1c],r12
8000b04a:	40 0c       	lddsp	r12,sp[0x0]
8000b04c:	58 7c       	cp.w	r12,7
8000b04e:	e0 8b 00 fa 	brhi	8000b242 <get_arg+0x272>
8000b052:	4c 8e       	lddpc	lr,8000b170 <get_arg+0x1a0>
8000b054:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000b058:	36 8b       	mov	r11,104
8000b05a:	f6 0a 18 00 	cp.b	r10,r11
8000b05e:	e0 80 00 f2 	breq	8000b242 <get_arg+0x272>
8000b062:	37 1b       	mov	r11,113
8000b064:	f6 0a 18 00 	cp.b	r10,r11
8000b068:	c0 70       	breq	8000b076 <get_arg+0xa6>
8000b06a:	34 cb       	mov	r11,76
8000b06c:	f6 0a 18 00 	cp.b	r10,r11
8000b070:	c0 51       	brne	8000b07a <get_arg+0xaa>
8000b072:	a3 b4       	sbr	r4,0x3
8000b074:	ce 78       	rjmp	8000b242 <get_arg+0x272>
8000b076:	a5 b4       	sbr	r4,0x5
8000b078:	ce 58       	rjmp	8000b242 <get_arg+0x272>
8000b07a:	08 9a       	mov	r10,r4
8000b07c:	0e 9b       	mov	r11,r7
8000b07e:	a5 aa       	sbr	r10,0x4
8000b080:	17 3c       	ld.ub	r12,r11++
8000b082:	a5 b4       	sbr	r4,0x5
8000b084:	36 ce       	mov	lr,108
8000b086:	fc 0c 18 00 	cp.b	r12,lr
8000b08a:	e0 80 00 dd 	breq	8000b244 <get_arg+0x274>
8000b08e:	14 94       	mov	r4,r10
8000b090:	cd 98       	rjmp	8000b242 <get_arg+0x272>
8000b092:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000b096:	36 7c       	mov	r12,103
8000b098:	f8 0a 18 00 	cp.b	r10,r12
8000b09c:	e0 8b 00 27 	brhi	8000b0ea <get_arg+0x11a>
8000b0a0:	36 5b       	mov	r11,101
8000b0a2:	f6 0a 18 00 	cp.b	r10,r11
8000b0a6:	c4 82       	brcc	8000b136 <get_arg+0x166>
8000b0a8:	34 fb       	mov	r11,79
8000b0aa:	f6 0a 18 00 	cp.b	r10,r11
8000b0ae:	c4 80       	breq	8000b13e <get_arg+0x16e>
8000b0b0:	e0 8b 00 0c 	brhi	8000b0c8 <get_arg+0xf8>
8000b0b4:	34 5b       	mov	r11,69
8000b0b6:	f6 0a 18 00 	cp.b	r10,r11
8000b0ba:	c3 e0       	breq	8000b136 <get_arg+0x166>
8000b0bc:	34 7b       	mov	r11,71
8000b0be:	f6 0a 18 00 	cp.b	r10,r11
8000b0c2:	c3 a0       	breq	8000b136 <get_arg+0x166>
8000b0c4:	34 4b       	mov	r11,68
8000b0c6:	c0 88       	rjmp	8000b0d6 <get_arg+0x106>
8000b0c8:	35 8b       	mov	r11,88
8000b0ca:	f6 0a 18 00 	cp.b	r10,r11
8000b0ce:	c2 c0       	breq	8000b126 <get_arg+0x156>
8000b0d0:	e0 8b 00 07 	brhi	8000b0de <get_arg+0x10e>
8000b0d4:	35 5b       	mov	r11,85
8000b0d6:	f6 0a 18 00 	cp.b	r10,r11
8000b0da:	c3 51       	brne	8000b144 <get_arg+0x174>
8000b0dc:	c3 18       	rjmp	8000b13e <get_arg+0x16e>
8000b0de:	36 3b       	mov	r11,99
8000b0e0:	f6 0a 18 00 	cp.b	r10,r11
8000b0e4:	c2 f0       	breq	8000b142 <get_arg+0x172>
8000b0e6:	36 4b       	mov	r11,100
8000b0e8:	c0 e8       	rjmp	8000b104 <get_arg+0x134>
8000b0ea:	37 0b       	mov	r11,112
8000b0ec:	f6 0a 18 00 	cp.b	r10,r11
8000b0f0:	c2 50       	breq	8000b13a <get_arg+0x16a>
8000b0f2:	e0 8b 00 0d 	brhi	8000b10c <get_arg+0x13c>
8000b0f6:	36 eb       	mov	r11,110
8000b0f8:	f6 0a 18 00 	cp.b	r10,r11
8000b0fc:	c1 f0       	breq	8000b13a <get_arg+0x16a>
8000b0fe:	e0 8b 00 14 	brhi	8000b126 <get_arg+0x156>
8000b102:	36 9b       	mov	r11,105
8000b104:	f6 0a 18 00 	cp.b	r10,r11
8000b108:	c1 e1       	brne	8000b144 <get_arg+0x174>
8000b10a:	c0 e8       	rjmp	8000b126 <get_arg+0x156>
8000b10c:	37 5b       	mov	r11,117
8000b10e:	f6 0a 18 00 	cp.b	r10,r11
8000b112:	c0 a0       	breq	8000b126 <get_arg+0x156>
8000b114:	37 8b       	mov	r11,120
8000b116:	f6 0a 18 00 	cp.b	r10,r11
8000b11a:	c0 60       	breq	8000b126 <get_arg+0x156>
8000b11c:	37 3b       	mov	r11,115
8000b11e:	f6 0a 18 00 	cp.b	r10,r11
8000b122:	c1 11       	brne	8000b144 <get_arg+0x174>
8000b124:	c0 b8       	rjmp	8000b13a <get_arg+0x16a>
8000b126:	ed b4 00 04 	bld	r4,0x4
8000b12a:	c0 a0       	breq	8000b13e <get_arg+0x16e>
8000b12c:	ed b4 00 05 	bld	r4,0x5
8000b130:	c0 91       	brne	8000b142 <get_arg+0x172>
8000b132:	30 20       	mov	r0,2
8000b134:	c0 88       	rjmp	8000b144 <get_arg+0x174>
8000b136:	30 40       	mov	r0,4
8000b138:	c0 68       	rjmp	8000b144 <get_arg+0x174>
8000b13a:	30 30       	mov	r0,3
8000b13c:	c0 48       	rjmp	8000b144 <get_arg+0x174>
8000b13e:	30 10       	mov	r0,1
8000b140:	c0 28       	rjmp	8000b144 <get_arg+0x174>
8000b142:	30 00       	mov	r0,0
8000b144:	40 3b       	lddsp	r11,sp[0xc]
8000b146:	5b fb       	cp.w	r11,-1
8000b148:	c0 40       	breq	8000b150 <get_arg+0x180>
8000b14a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000b14e:	c7 a8       	rjmp	8000b242 <get_arg+0x272>
8000b150:	58 60       	cp.w	r0,6
8000b152:	e0 8b 00 78 	brhi	8000b242 <get_arg+0x272>
8000b156:	6c 0a       	ld.w	r10,r6[0x0]
8000b158:	ea cc ff ff 	sub	r12,r5,-1
8000b15c:	48 6e       	lddpc	lr,8000b174 <get_arg+0x1a4>
8000b15e:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000b162:	d7 03       	nop
8000b164:	80 01       	ld.sh	r1,r0[0x0]
8000b166:	9b a8       	st.w	sp[0x28],r8
8000b168:	80 01       	ld.sh	r1,r0[0x0]
8000b16a:	9a e0       	ld.uh	r0,sp[0xc]
8000b16c:	80 01       	ld.sh	r1,r0[0x0]
8000b16e:	9a 74       	ld.sh	r4,sp[0xe]
8000b170:	80 01       	ld.sh	r1,r0[0x0]
8000b172:	98 d4       	ld.uh	r4,r12[0xa]
8000b174:	80 01       	ld.sh	r1,r0[0x0]
8000b176:	98 f4       	ld.uh	r4,r12[0xe]
8000b178:	f4 cb ff f8 	sub	r11,r10,-8
8000b17c:	8d 0b       	st.w	r6[0x0],r11
8000b17e:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b182:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b186:	c0 f8       	rjmp	8000b1a4 <get_arg+0x1d4>
8000b188:	f4 cb ff fc 	sub	r11,r10,-4
8000b18c:	8d 0b       	st.w	r6[0x0],r11
8000b18e:	74 0a       	ld.w	r10,r10[0x0]
8000b190:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b194:	c0 88       	rjmp	8000b1a4 <get_arg+0x1d4>
8000b196:	f4 cb ff f8 	sub	r11,r10,-8
8000b19a:	8d 0b       	st.w	r6[0x0],r11
8000b19c:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b1a0:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b1a4:	0e 9b       	mov	r11,r7
8000b1a6:	18 95       	mov	r5,r12
8000b1a8:	c4 e8       	rjmp	8000b244 <get_arg+0x274>
8000b1aa:	62 0a       	ld.w	r10,r1[0x0]
8000b1ac:	5b fa       	cp.w	r10,-1
8000b1ae:	c0 b1       	brne	8000b1c4 <get_arg+0x1f4>
8000b1b0:	50 19       	stdsp	sp[0x4],r9
8000b1b2:	50 28       	stdsp	sp[0x8],r8
8000b1b4:	e0 6a 00 80 	mov	r10,128
8000b1b8:	30 0b       	mov	r11,0
8000b1ba:	02 9c       	mov	r12,r1
8000b1bc:	fe b0 fc 6f 	rcall	8000aa9a <memset>
8000b1c0:	40 28       	lddsp	r8,sp[0x8]
8000b1c2:	40 19       	lddsp	r9,sp[0x4]
8000b1c4:	e4 cc 00 01 	sub	r12,r2,1
8000b1c8:	0e 9b       	mov	r11,r7
8000b1ca:	50 3c       	stdsp	sp[0xc],r12
8000b1cc:	f2 0c 0c 49 	max	r9,r9,r12
8000b1d0:	c3 a8       	rjmp	8000b244 <get_arg+0x274>
8000b1d2:	62 0a       	ld.w	r10,r1[0x0]
8000b1d4:	5b fa       	cp.w	r10,-1
8000b1d6:	c0 b1       	brne	8000b1ec <get_arg+0x21c>
8000b1d8:	50 19       	stdsp	sp[0x4],r9
8000b1da:	50 28       	stdsp	sp[0x8],r8
8000b1dc:	e0 6a 00 80 	mov	r10,128
8000b1e0:	30 0b       	mov	r11,0
8000b1e2:	02 9c       	mov	r12,r1
8000b1e4:	fe b0 fc 5b 	rcall	8000aa9a <memset>
8000b1e8:	40 28       	lddsp	r8,sp[0x8]
8000b1ea:	40 19       	lddsp	r9,sp[0x4]
8000b1ec:	20 12       	sub	r2,1
8000b1ee:	30 0a       	mov	r10,0
8000b1f0:	0e 9b       	mov	r11,r7
8000b1f2:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000b1f6:	f2 02 0c 49 	max	r9,r9,r2
8000b1fa:	c2 58       	rjmp	8000b244 <get_arg+0x274>
8000b1fc:	16 97       	mov	r7,r11
8000b1fe:	6c 0a       	ld.w	r10,r6[0x0]
8000b200:	f4 cb ff fc 	sub	r11,r10,-4
8000b204:	8d 0b       	st.w	r6[0x0],r11
8000b206:	74 0a       	ld.w	r10,r10[0x0]
8000b208:	0e 9b       	mov	r11,r7
8000b20a:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b20e:	2f f5       	sub	r5,-1
8000b210:	c1 a8       	rjmp	8000b244 <get_arg+0x274>
8000b212:	f4 c2 00 30 	sub	r2,r10,48
8000b216:	c0 68       	rjmp	8000b222 <get_arg+0x252>
8000b218:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000b21c:	2f f7       	sub	r7,-1
8000b21e:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000b222:	0f 8a       	ld.ub	r10,r7[0x0]
8000b224:	58 0a       	cp.w	r10,0
8000b226:	c0 e0       	breq	8000b242 <get_arg+0x272>
8000b228:	23 0a       	sub	r10,48
8000b22a:	58 9a       	cp.w	r10,9
8000b22c:	fe 98 ff f6 	brls	8000b218 <get_arg+0x248>
8000b230:	c0 98       	rjmp	8000b242 <get_arg+0x272>
8000b232:	2f f7       	sub	r7,-1
8000b234:	0f 8a       	ld.ub	r10,r7[0x0]
8000b236:	58 0a       	cp.w	r10,0
8000b238:	c0 50       	breq	8000b242 <get_arg+0x272>
8000b23a:	23 0a       	sub	r10,48
8000b23c:	58 9a       	cp.w	r10,9
8000b23e:	fe 98 ff fa 	brls	8000b232 <get_arg+0x262>
8000b242:	0e 9b       	mov	r11,r7
8000b244:	40 7c       	lddsp	r12,sp[0x1c]
8000b246:	30 ba       	mov	r10,11
8000b248:	f4 0c 18 00 	cp.b	r12,r10
8000b24c:	fe 91 fe ec 	brne	8000b024 <get_arg+0x54>
8000b250:	40 42       	lddsp	r2,sp[0x10]
8000b252:	17 8c       	ld.ub	r12,r11[0x0]
8000b254:	0a 32       	cp.w	r2,r5
8000b256:	5f 4a       	srge	r10
8000b258:	f0 0c 18 00 	cp.b	r12,r8
8000b25c:	5f 1c       	srne	r12
8000b25e:	f9 ea 00 0a 	and	r10,r12,r10
8000b262:	f0 0a 18 00 	cp.b	r10,r8
8000b266:	fe 91 fe c9 	brne	8000aff8 <get_arg+0x28>
8000b26a:	30 08       	mov	r8,0
8000b26c:	40 4e       	lddsp	lr,sp[0x10]
8000b26e:	17 8a       	ld.ub	r10,r11[0x0]
8000b270:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000b274:	f0 0a 18 00 	cp.b	r10,r8
8000b278:	fc 09 17 10 	movne	r9,lr
8000b27c:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000b280:	06 9e       	mov	lr,r3
8000b282:	c2 a8       	rjmp	8000b2d6 <get_arg+0x306>
8000b284:	62 0a       	ld.w	r10,r1[0x0]
8000b286:	58 3a       	cp.w	r10,3
8000b288:	c1 e0       	breq	8000b2c4 <get_arg+0x2f4>
8000b28a:	e0 89 00 07 	brgt	8000b298 <get_arg+0x2c8>
8000b28e:	58 1a       	cp.w	r10,1
8000b290:	c1 a0       	breq	8000b2c4 <get_arg+0x2f4>
8000b292:	58 2a       	cp.w	r10,2
8000b294:	c1 81       	brne	8000b2c4 <get_arg+0x2f4>
8000b296:	c0 58       	rjmp	8000b2a0 <get_arg+0x2d0>
8000b298:	58 5a       	cp.w	r10,5
8000b29a:	c0 c0       	breq	8000b2b2 <get_arg+0x2e2>
8000b29c:	c0 b5       	brlt	8000b2b2 <get_arg+0x2e2>
8000b29e:	c1 38       	rjmp	8000b2c4 <get_arg+0x2f4>
8000b2a0:	6c 0a       	ld.w	r10,r6[0x0]
8000b2a2:	f4 cc ff f8 	sub	r12,r10,-8
8000b2a6:	8d 0c       	st.w	r6[0x0],r12
8000b2a8:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b2ac:	f0 e3 00 00 	st.d	r8[0],r2
8000b2b0:	c1 08       	rjmp	8000b2d0 <get_arg+0x300>
8000b2b2:	6c 0a       	ld.w	r10,r6[0x0]
8000b2b4:	f4 cc ff f8 	sub	r12,r10,-8
8000b2b8:	8d 0c       	st.w	r6[0x0],r12
8000b2ba:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b2be:	f0 e3 00 00 	st.d	r8[0],r2
8000b2c2:	c0 78       	rjmp	8000b2d0 <get_arg+0x300>
8000b2c4:	6c 0a       	ld.w	r10,r6[0x0]
8000b2c6:	f4 cc ff fc 	sub	r12,r10,-4
8000b2ca:	8d 0c       	st.w	r6[0x0],r12
8000b2cc:	74 0a       	ld.w	r10,r10[0x0]
8000b2ce:	91 0a       	st.w	r8[0x0],r10
8000b2d0:	2f f5       	sub	r5,-1
8000b2d2:	2f 88       	sub	r8,-8
8000b2d4:	2f c1       	sub	r1,-4
8000b2d6:	12 35       	cp.w	r5,r9
8000b2d8:	fe 9a ff d6 	brle	8000b284 <get_arg+0x2b4>
8000b2dc:	1c 93       	mov	r3,lr
8000b2de:	40 52       	lddsp	r2,sp[0x14]
8000b2e0:	40 6e       	lddsp	lr,sp[0x18]
8000b2e2:	85 05       	st.w	r2[0x0],r5
8000b2e4:	9d 0b       	st.w	lr[0x0],r11
8000b2e6:	40 4b       	lddsp	r11,sp[0x10]
8000b2e8:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000b2ec:	2f 8d       	sub	sp,-32
8000b2ee:	d8 32       	popm	r0-r7,pc

8000b2f0 <__sprint_r>:
8000b2f0:	d4 21       	pushm	r4-r7,lr
8000b2f2:	14 97       	mov	r7,r10
8000b2f4:	74 28       	ld.w	r8,r10[0x8]
8000b2f6:	58 08       	cp.w	r8,0
8000b2f8:	c0 41       	brne	8000b300 <__sprint_r+0x10>
8000b2fa:	95 18       	st.w	r10[0x4],r8
8000b2fc:	10 9c       	mov	r12,r8
8000b2fe:	d8 22       	popm	r4-r7,pc
8000b300:	e0 a0 18 ce 	rcall	8000e49c <__sfvwrite_r>
8000b304:	30 08       	mov	r8,0
8000b306:	8f 18       	st.w	r7[0x4],r8
8000b308:	8f 28       	st.w	r7[0x8],r8
8000b30a:	d8 22       	popm	r4-r7,pc

8000b30c <_vfprintf_r>:
8000b30c:	d4 31       	pushm	r0-r7,lr
8000b30e:	fa cd 06 bc 	sub	sp,sp,1724
8000b312:	51 09       	stdsp	sp[0x40],r9
8000b314:	16 91       	mov	r1,r11
8000b316:	14 97       	mov	r7,r10
8000b318:	18 95       	mov	r5,r12
8000b31a:	e0 a0 1a 31 	rcall	8000e77c <_localeconv_r>
8000b31e:	78 0c       	ld.w	r12,r12[0x0]
8000b320:	50 cc       	stdsp	sp[0x30],r12
8000b322:	58 05       	cp.w	r5,0
8000b324:	c0 70       	breq	8000b332 <_vfprintf_r+0x26>
8000b326:	6a 68       	ld.w	r8,r5[0x18]
8000b328:	58 08       	cp.w	r8,0
8000b32a:	c0 41       	brne	8000b332 <_vfprintf_r+0x26>
8000b32c:	0a 9c       	mov	r12,r5
8000b32e:	e0 a0 17 57 	rcall	8000e1dc <__sinit>
8000b332:	4d 08       	lddpc	r8,8000b470 <_vfprintf_r+0x164>
8000b334:	10 31       	cp.w	r1,r8
8000b336:	c0 31       	brne	8000b33c <_vfprintf_r+0x30>
8000b338:	6a 01       	ld.w	r1,r5[0x0]
8000b33a:	c0 a8       	rjmp	8000b34e <_vfprintf_r+0x42>
8000b33c:	4c e8       	lddpc	r8,8000b474 <_vfprintf_r+0x168>
8000b33e:	10 31       	cp.w	r1,r8
8000b340:	c0 31       	brne	8000b346 <_vfprintf_r+0x3a>
8000b342:	6a 11       	ld.w	r1,r5[0x4]
8000b344:	c0 58       	rjmp	8000b34e <_vfprintf_r+0x42>
8000b346:	4c d8       	lddpc	r8,8000b478 <_vfprintf_r+0x16c>
8000b348:	10 31       	cp.w	r1,r8
8000b34a:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000b34e:	82 68       	ld.sh	r8,r1[0xc]
8000b350:	ed b8 00 03 	bld	r8,0x3
8000b354:	c0 41       	brne	8000b35c <_vfprintf_r+0x50>
8000b356:	62 48       	ld.w	r8,r1[0x10]
8000b358:	58 08       	cp.w	r8,0
8000b35a:	c0 71       	brne	8000b368 <_vfprintf_r+0x5c>
8000b35c:	02 9b       	mov	r11,r1
8000b35e:	0a 9c       	mov	r12,r5
8000b360:	e0 a0 0f 6c 	rcall	8000d238 <__swsetup_r>
8000b364:	e0 81 0f 63 	brne	8000d22a <_vfprintf_r+0x1f1e>
8000b368:	82 68       	ld.sh	r8,r1[0xc]
8000b36a:	10 99       	mov	r9,r8
8000b36c:	e2 19 00 1a 	andl	r9,0x1a,COH
8000b370:	58 a9       	cp.w	r9,10
8000b372:	c3 c1       	brne	8000b3ea <_vfprintf_r+0xde>
8000b374:	82 79       	ld.sh	r9,r1[0xe]
8000b376:	30 0a       	mov	r10,0
8000b378:	f4 09 19 00 	cp.h	r9,r10
8000b37c:	c3 75       	brlt	8000b3ea <_vfprintf_r+0xde>
8000b37e:	a1 d8       	cbr	r8,0x1
8000b380:	fb 58 05 d0 	st.h	sp[1488],r8
8000b384:	62 88       	ld.w	r8,r1[0x20]
8000b386:	fb 48 05 e4 	st.w	sp[1508],r8
8000b38a:	62 a8       	ld.w	r8,r1[0x28]
8000b38c:	fb 48 05 ec 	st.w	sp[1516],r8
8000b390:	fa c8 ff bc 	sub	r8,sp,-68
8000b394:	fb 48 05 d4 	st.w	sp[1492],r8
8000b398:	fb 48 05 c4 	st.w	sp[1476],r8
8000b39c:	e0 68 04 00 	mov	r8,1024
8000b3a0:	fb 48 05 d8 	st.w	sp[1496],r8
8000b3a4:	fb 48 05 cc 	st.w	sp[1484],r8
8000b3a8:	30 08       	mov	r8,0
8000b3aa:	fb 59 05 d2 	st.h	sp[1490],r9
8000b3ae:	0e 9a       	mov	r10,r7
8000b3b0:	41 09       	lddsp	r9,sp[0x40]
8000b3b2:	fa c7 fa 3c 	sub	r7,sp,-1476
8000b3b6:	fb 48 05 dc 	st.w	sp[1500],r8
8000b3ba:	0a 9c       	mov	r12,r5
8000b3bc:	0e 9b       	mov	r11,r7
8000b3be:	ca 7f       	rcall	8000b30c <_vfprintf_r>
8000b3c0:	50 bc       	stdsp	sp[0x2c],r12
8000b3c2:	c0 95       	brlt	8000b3d4 <_vfprintf_r+0xc8>
8000b3c4:	0e 9b       	mov	r11,r7
8000b3c6:	0a 9c       	mov	r12,r5
8000b3c8:	e0 a0 16 2e 	rcall	8000e024 <_fflush_r>
8000b3cc:	40 be       	lddsp	lr,sp[0x2c]
8000b3ce:	f9 be 01 ff 	movne	lr,-1
8000b3d2:	50 be       	stdsp	sp[0x2c],lr
8000b3d4:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000b3d8:	ed b8 00 06 	bld	r8,0x6
8000b3dc:	e0 81 0f 29 	brne	8000d22e <_vfprintf_r+0x1f22>
8000b3e0:	82 68       	ld.sh	r8,r1[0xc]
8000b3e2:	a7 a8       	sbr	r8,0x6
8000b3e4:	a2 68       	st.h	r1[0xc],r8
8000b3e6:	e0 8f 0f 24 	bral	8000d22e <_vfprintf_r+0x1f22>
8000b3ea:	30 08       	mov	r8,0
8000b3ec:	fb 48 06 b4 	st.w	sp[1716],r8
8000b3f0:	fb 48 06 90 	st.w	sp[1680],r8
8000b3f4:	fb 48 06 8c 	st.w	sp[1676],r8
8000b3f8:	fb 48 06 b0 	st.w	sp[1712],r8
8000b3fc:	30 08       	mov	r8,0
8000b3fe:	30 09       	mov	r9,0
8000b400:	50 a7       	stdsp	sp[0x28],r7
8000b402:	50 78       	stdsp	sp[0x1c],r8
8000b404:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b408:	3f f8       	mov	r8,-1
8000b40a:	50 59       	stdsp	sp[0x14],r9
8000b40c:	fb 43 06 88 	st.w	sp[1672],r3
8000b410:	fb 48 05 44 	st.w	sp[1348],r8
8000b414:	12 9c       	mov	r12,r9
8000b416:	50 69       	stdsp	sp[0x18],r9
8000b418:	50 d9       	stdsp	sp[0x34],r9
8000b41a:	50 e9       	stdsp	sp[0x38],r9
8000b41c:	50 b9       	stdsp	sp[0x2c],r9
8000b41e:	12 97       	mov	r7,r9
8000b420:	0a 94       	mov	r4,r5
8000b422:	40 a2       	lddsp	r2,sp[0x28]
8000b424:	32 5a       	mov	r10,37
8000b426:	30 08       	mov	r8,0
8000b428:	c0 28       	rjmp	8000b42c <_vfprintf_r+0x120>
8000b42a:	2f f2       	sub	r2,-1
8000b42c:	05 89       	ld.ub	r9,r2[0x0]
8000b42e:	f0 09 18 00 	cp.b	r9,r8
8000b432:	5f 1b       	srne	r11
8000b434:	f4 09 18 00 	cp.b	r9,r10
8000b438:	5f 19       	srne	r9
8000b43a:	f3 eb 00 0b 	and	r11,r9,r11
8000b43e:	f0 0b 18 00 	cp.b	r11,r8
8000b442:	cf 41       	brne	8000b42a <_vfprintf_r+0x11e>
8000b444:	40 ab       	lddsp	r11,sp[0x28]
8000b446:	e4 0b 01 06 	sub	r6,r2,r11
8000b44a:	c2 50       	breq	8000b494 <_vfprintf_r+0x188>
8000b44c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000b450:	0c 08       	add	r8,r6
8000b452:	87 0b       	st.w	r3[0x0],r11
8000b454:	fb 48 06 90 	st.w	sp[1680],r8
8000b458:	87 16       	st.w	r3[0x4],r6
8000b45a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b45e:	2f f8       	sub	r8,-1
8000b460:	fb 48 06 8c 	st.w	sp[1676],r8
8000b464:	58 78       	cp.w	r8,7
8000b466:	e0 89 00 0b 	brgt	8000b47c <_vfprintf_r+0x170>
8000b46a:	2f 83       	sub	r3,-8
8000b46c:	c1 18       	rjmp	8000b48e <_vfprintf_r+0x182>
8000b46e:	d7 03       	nop
8000b470:	80 01       	ld.sh	r1,r0[0x0]
8000b472:	9c b8       	ld.uh	r8,lr[0x6]
8000b474:	80 01       	ld.sh	r1,r0[0x0]
8000b476:	9c d8       	ld.uh	r8,lr[0xa]
8000b478:	80 01       	ld.sh	r1,r0[0x0]
8000b47a:	9c f8       	ld.uh	r8,lr[0xe]
8000b47c:	fa ca f9 78 	sub	r10,sp,-1672
8000b480:	02 9b       	mov	r11,r1
8000b482:	08 9c       	mov	r12,r4
8000b484:	c3 6f       	rcall	8000b2f0 <__sprint_r>
8000b486:	e0 81 0e ce 	brne	8000d222 <_vfprintf_r+0x1f16>
8000b48a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b48e:	40 ba       	lddsp	r10,sp[0x2c]
8000b490:	0c 0a       	add	r10,r6
8000b492:	50 ba       	stdsp	sp[0x2c],r10
8000b494:	05 89       	ld.ub	r9,r2[0x0]
8000b496:	30 08       	mov	r8,0
8000b498:	f0 09 18 00 	cp.b	r9,r8
8000b49c:	e0 80 0e b2 	breq	8000d200 <_vfprintf_r+0x1ef4>
8000b4a0:	30 09       	mov	r9,0
8000b4a2:	fb 68 06 bb 	st.b	sp[1723],r8
8000b4a6:	0e 96       	mov	r6,r7
8000b4a8:	e4 c8 ff ff 	sub	r8,r2,-1
8000b4ac:	3f fe       	mov	lr,-1
8000b4ae:	50 93       	stdsp	sp[0x24],r3
8000b4b0:	50 41       	stdsp	sp[0x10],r1
8000b4b2:	0e 93       	mov	r3,r7
8000b4b4:	04 91       	mov	r1,r2
8000b4b6:	50 89       	stdsp	sp[0x20],r9
8000b4b8:	50 a8       	stdsp	sp[0x28],r8
8000b4ba:	50 2e       	stdsp	sp[0x8],lr
8000b4bc:	50 39       	stdsp	sp[0xc],r9
8000b4be:	12 95       	mov	r5,r9
8000b4c0:	12 90       	mov	r0,r9
8000b4c2:	10 97       	mov	r7,r8
8000b4c4:	08 92       	mov	r2,r4
8000b4c6:	c0 78       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b4c8:	3f fc       	mov	r12,-1
8000b4ca:	08 97       	mov	r7,r4
8000b4cc:	50 2c       	stdsp	sp[0x8],r12
8000b4ce:	c0 38       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b4d0:	30 0b       	mov	r11,0
8000b4d2:	50 3b       	stdsp	sp[0xc],r11
8000b4d4:	0f 38       	ld.ub	r8,r7++
8000b4d6:	c0 28       	rjmp	8000b4da <_vfprintf_r+0x1ce>
8000b4d8:	12 90       	mov	r0,r9
8000b4da:	f0 c9 00 20 	sub	r9,r8,32
8000b4de:	e0 49 00 58 	cp.w	r9,88
8000b4e2:	e0 8b 0a 36 	brhi	8000c94e <_vfprintf_r+0x1642>
8000b4e6:	4d 9a       	lddpc	r10,8000b648 <_vfprintf_r+0x33c>
8000b4e8:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000b4ec:	50 a7       	stdsp	sp[0x28],r7
8000b4ee:	50 80       	stdsp	sp[0x20],r0
8000b4f0:	0c 97       	mov	r7,r6
8000b4f2:	04 94       	mov	r4,r2
8000b4f4:	06 96       	mov	r6,r3
8000b4f6:	02 92       	mov	r2,r1
8000b4f8:	4d 59       	lddpc	r9,8000b64c <_vfprintf_r+0x340>
8000b4fa:	40 93       	lddsp	r3,sp[0x24]
8000b4fc:	10 90       	mov	r0,r8
8000b4fe:	40 41       	lddsp	r1,sp[0x10]
8000b500:	50 d9       	stdsp	sp[0x34],r9
8000b502:	e0 8f 08 95 	bral	8000c62c <_vfprintf_r+0x1320>
8000b506:	30 08       	mov	r8,0
8000b508:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000b50c:	f0 09 18 00 	cp.b	r9,r8
8000b510:	ce 21       	brne	8000b4d4 <_vfprintf_r+0x1c8>
8000b512:	32 08       	mov	r8,32
8000b514:	c6 e8       	rjmp	8000b5f0 <_vfprintf_r+0x2e4>
8000b516:	a1 a5       	sbr	r5,0x0
8000b518:	cd eb       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b51a:	0f 89       	ld.ub	r9,r7[0x0]
8000b51c:	f2 c8 00 30 	sub	r8,r9,48
8000b520:	58 98       	cp.w	r8,9
8000b522:	e0 8b 00 1d 	brhi	8000b55c <_vfprintf_r+0x250>
8000b526:	ee c8 ff ff 	sub	r8,r7,-1
8000b52a:	30 0b       	mov	r11,0
8000b52c:	23 09       	sub	r9,48
8000b52e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b532:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000b536:	11 39       	ld.ub	r9,r8++
8000b538:	f2 ca 00 30 	sub	r10,r9,48
8000b53c:	58 9a       	cp.w	r10,9
8000b53e:	fe 98 ff f7 	brls	8000b52c <_vfprintf_r+0x220>
8000b542:	e0 49 00 24 	cp.w	r9,36
8000b546:	cc 51       	brne	8000b4d0 <_vfprintf_r+0x1c4>
8000b548:	e0 4b 00 20 	cp.w	r11,32
8000b54c:	e0 89 0e 6a 	brgt	8000d220 <_vfprintf_r+0x1f14>
8000b550:	20 1b       	sub	r11,1
8000b552:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b556:	12 3b       	cp.w	r11,r9
8000b558:	c0 95       	brlt	8000b56a <_vfprintf_r+0x25e>
8000b55a:	c1 08       	rjmp	8000b57a <_vfprintf_r+0x26e>
8000b55c:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b560:	ec ca ff ff 	sub	r10,r6,-1
8000b564:	12 36       	cp.w	r6,r9
8000b566:	c1 f5       	brlt	8000b5a4 <_vfprintf_r+0x298>
8000b568:	c2 68       	rjmp	8000b5b4 <_vfprintf_r+0x2a8>
8000b56a:	fa ce f9 44 	sub	lr,sp,-1724
8000b56e:	10 97       	mov	r7,r8
8000b570:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000b574:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000b578:	c3 58       	rjmp	8000b5e2 <_vfprintf_r+0x2d6>
8000b57a:	10 97       	mov	r7,r8
8000b57c:	fa c8 f9 50 	sub	r8,sp,-1712
8000b580:	1a d8       	st.w	--sp,r8
8000b582:	fa c8 fa b8 	sub	r8,sp,-1352
8000b586:	1a d8       	st.w	--sp,r8
8000b588:	fa c8 fb b4 	sub	r8,sp,-1100
8000b58c:	02 9a       	mov	r10,r1
8000b58e:	1a d8       	st.w	--sp,r8
8000b590:	04 9c       	mov	r12,r2
8000b592:	fa c8 f9 40 	sub	r8,sp,-1728
8000b596:	fa c9 ff b4 	sub	r9,sp,-76
8000b59a:	fe b0 fd 1b 	rcall	8000afd0 <get_arg>
8000b59e:	2f dd       	sub	sp,-12
8000b5a0:	78 00       	ld.w	r0,r12[0x0]
8000b5a2:	c2 08       	rjmp	8000b5e2 <_vfprintf_r+0x2d6>
8000b5a4:	fa cc f9 44 	sub	r12,sp,-1724
8000b5a8:	14 96       	mov	r6,r10
8000b5aa:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000b5ae:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000b5b2:	c1 88       	rjmp	8000b5e2 <_vfprintf_r+0x2d6>
8000b5b4:	41 08       	lddsp	r8,sp[0x40]
8000b5b6:	59 f9       	cp.w	r9,31
8000b5b8:	e0 89 00 11 	brgt	8000b5da <_vfprintf_r+0x2ce>
8000b5bc:	f0 cb ff fc 	sub	r11,r8,-4
8000b5c0:	51 0b       	stdsp	sp[0x40],r11
8000b5c2:	70 00       	ld.w	r0,r8[0x0]
8000b5c4:	fa cb f9 44 	sub	r11,sp,-1724
8000b5c8:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000b5cc:	f1 40 fd 88 	st.w	r8[-632],r0
8000b5d0:	2f f9       	sub	r9,-1
8000b5d2:	14 96       	mov	r6,r10
8000b5d4:	fb 49 06 b4 	st.w	sp[1716],r9
8000b5d8:	c0 58       	rjmp	8000b5e2 <_vfprintf_r+0x2d6>
8000b5da:	70 00       	ld.w	r0,r8[0x0]
8000b5dc:	14 96       	mov	r6,r10
8000b5de:	2f c8       	sub	r8,-4
8000b5e0:	51 08       	stdsp	sp[0x40],r8
8000b5e2:	58 00       	cp.w	r0,0
8000b5e4:	fe 94 ff 78 	brge	8000b4d4 <_vfprintf_r+0x1c8>
8000b5e8:	5c 30       	neg	r0
8000b5ea:	a3 a5       	sbr	r5,0x2
8000b5ec:	c7 4b       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b5ee:	32 b8       	mov	r8,43
8000b5f0:	fb 68 06 bb 	st.b	sp[1723],r8
8000b5f4:	c7 0b       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b5f6:	0f 38       	ld.ub	r8,r7++
8000b5f8:	e0 48 00 2a 	cp.w	r8,42
8000b5fc:	c0 30       	breq	8000b602 <_vfprintf_r+0x2f6>
8000b5fe:	30 09       	mov	r9,0
8000b600:	c7 d8       	rjmp	8000b6fa <_vfprintf_r+0x3ee>
8000b602:	0f 88       	ld.ub	r8,r7[0x0]
8000b604:	f0 c9 00 30 	sub	r9,r8,48
8000b608:	58 99       	cp.w	r9,9
8000b60a:	e0 8b 00 23 	brhi	8000b650 <_vfprintf_r+0x344>
8000b60e:	ee c4 ff ff 	sub	r4,r7,-1
8000b612:	30 0b       	mov	r11,0
8000b614:	23 08       	sub	r8,48
8000b616:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b61a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000b61e:	09 38       	ld.ub	r8,r4++
8000b620:	f0 c9 00 30 	sub	r9,r8,48
8000b624:	58 99       	cp.w	r9,9
8000b626:	fe 98 ff f7 	brls	8000b614 <_vfprintf_r+0x308>
8000b62a:	e0 48 00 24 	cp.w	r8,36
8000b62e:	fe 91 ff 51 	brne	8000b4d0 <_vfprintf_r+0x1c4>
8000b632:	e0 4b 00 20 	cp.w	r11,32
8000b636:	e0 89 0d f5 	brgt	8000d220 <_vfprintf_r+0x1f14>
8000b63a:	20 1b       	sub	r11,1
8000b63c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b640:	10 3b       	cp.w	r11,r8
8000b642:	c0 e5       	brlt	8000b65e <_vfprintf_r+0x352>
8000b644:	c1 58       	rjmp	8000b66e <_vfprintf_r+0x362>
8000b646:	d7 03       	nop
8000b648:	80 01       	ld.sh	r1,r0[0x0]
8000b64a:	99 10       	st.w	r12[0x4],r0
8000b64c:	80 01       	ld.sh	r1,r0[0x0]
8000b64e:	9b 4c       	st.w	sp[0x10],r12
8000b650:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000b654:	ec c9 ff ff 	sub	r9,r6,-1
8000b658:	14 36       	cp.w	r6,r10
8000b65a:	c1 f5       	brlt	8000b698 <_vfprintf_r+0x38c>
8000b65c:	c2 88       	rjmp	8000b6ac <_vfprintf_r+0x3a0>
8000b65e:	fa ca f9 44 	sub	r10,sp,-1724
8000b662:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000b666:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000b66a:	50 2b       	stdsp	sp[0x8],r11
8000b66c:	c3 c8       	rjmp	8000b6e4 <_vfprintf_r+0x3d8>
8000b66e:	fa c8 f9 50 	sub	r8,sp,-1712
8000b672:	1a d8       	st.w	--sp,r8
8000b674:	fa c8 fa b8 	sub	r8,sp,-1352
8000b678:	1a d8       	st.w	--sp,r8
8000b67a:	fa c8 fb b4 	sub	r8,sp,-1100
8000b67e:	02 9a       	mov	r10,r1
8000b680:	1a d8       	st.w	--sp,r8
8000b682:	04 9c       	mov	r12,r2
8000b684:	fa c8 f9 40 	sub	r8,sp,-1728
8000b688:	fa c9 ff b4 	sub	r9,sp,-76
8000b68c:	fe b0 fc a2 	rcall	8000afd0 <get_arg>
8000b690:	2f dd       	sub	sp,-12
8000b692:	78 0c       	ld.w	r12,r12[0x0]
8000b694:	50 2c       	stdsp	sp[0x8],r12
8000b696:	c2 78       	rjmp	8000b6e4 <_vfprintf_r+0x3d8>
8000b698:	12 96       	mov	r6,r9
8000b69a:	0e 94       	mov	r4,r7
8000b69c:	fa c9 f9 44 	sub	r9,sp,-1724
8000b6a0:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000b6a4:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000b6a8:	50 28       	stdsp	sp[0x8],r8
8000b6aa:	c1 d8       	rjmp	8000b6e4 <_vfprintf_r+0x3d8>
8000b6ac:	41 08       	lddsp	r8,sp[0x40]
8000b6ae:	59 fa       	cp.w	r10,31
8000b6b0:	e0 89 00 14 	brgt	8000b6d8 <_vfprintf_r+0x3cc>
8000b6b4:	f0 cb ff fc 	sub	r11,r8,-4
8000b6b8:	70 08       	ld.w	r8,r8[0x0]
8000b6ba:	51 0b       	stdsp	sp[0x40],r11
8000b6bc:	50 28       	stdsp	sp[0x8],r8
8000b6be:	fa c6 f9 44 	sub	r6,sp,-1724
8000b6c2:	40 2e       	lddsp	lr,sp[0x8]
8000b6c4:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000b6c8:	f1 4e fd 88 	st.w	r8[-632],lr
8000b6cc:	2f fa       	sub	r10,-1
8000b6ce:	0e 94       	mov	r4,r7
8000b6d0:	fb 4a 06 b4 	st.w	sp[1716],r10
8000b6d4:	12 96       	mov	r6,r9
8000b6d6:	c0 78       	rjmp	8000b6e4 <_vfprintf_r+0x3d8>
8000b6d8:	70 0c       	ld.w	r12,r8[0x0]
8000b6da:	0e 94       	mov	r4,r7
8000b6dc:	2f c8       	sub	r8,-4
8000b6de:	50 2c       	stdsp	sp[0x8],r12
8000b6e0:	12 96       	mov	r6,r9
8000b6e2:	51 08       	stdsp	sp[0x40],r8
8000b6e4:	40 2b       	lddsp	r11,sp[0x8]
8000b6e6:	58 0b       	cp.w	r11,0
8000b6e8:	fe 95 fe f0 	brlt	8000b4c8 <_vfprintf_r+0x1bc>
8000b6ec:	08 97       	mov	r7,r4
8000b6ee:	cf 3a       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b6f0:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b6f4:	0f 38       	ld.ub	r8,r7++
8000b6f6:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000b6fa:	f0 ca 00 30 	sub	r10,r8,48
8000b6fe:	58 9a       	cp.w	r10,9
8000b700:	fe 98 ff f8 	brls	8000b6f0 <_vfprintf_r+0x3e4>
8000b704:	3f fa       	mov	r10,-1
8000b706:	f2 0a 0c 49 	max	r9,r9,r10
8000b70a:	50 29       	stdsp	sp[0x8],r9
8000b70c:	ce 7a       	rjmp	8000b4da <_vfprintf_r+0x1ce>
8000b70e:	a7 b5       	sbr	r5,0x7
8000b710:	ce 2a       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b712:	30 09       	mov	r9,0
8000b714:	23 08       	sub	r8,48
8000b716:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b71a:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000b71e:	0f 38       	ld.ub	r8,r7++
8000b720:	f0 ca 00 30 	sub	r10,r8,48
8000b724:	58 9a       	cp.w	r10,9
8000b726:	fe 98 ff f7 	brls	8000b714 <_vfprintf_r+0x408>
8000b72a:	e0 48 00 24 	cp.w	r8,36
8000b72e:	fe 91 fe d5 	brne	8000b4d8 <_vfprintf_r+0x1cc>
8000b732:	e0 49 00 20 	cp.w	r9,32
8000b736:	e0 89 0d 75 	brgt	8000d220 <_vfprintf_r+0x1f14>
8000b73a:	f2 c3 00 01 	sub	r3,r9,1
8000b73e:	30 19       	mov	r9,1
8000b740:	50 39       	stdsp	sp[0xc],r9
8000b742:	cc 9a       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b744:	a3 b5       	sbr	r5,0x3
8000b746:	cc 7a       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b748:	a7 a5       	sbr	r5,0x6
8000b74a:	cc 5a       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b74c:	0a 98       	mov	r8,r5
8000b74e:	a5 b5       	sbr	r5,0x5
8000b750:	a5 a8       	sbr	r8,0x4
8000b752:	0f 89       	ld.ub	r9,r7[0x0]
8000b754:	36 ce       	mov	lr,108
8000b756:	fc 09 18 00 	cp.b	r9,lr
8000b75a:	f7 b7 00 ff 	subeq	r7,-1
8000b75e:	f0 05 17 10 	movne	r5,r8
8000b762:	cb 9a       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b764:	a5 b5       	sbr	r5,0x5
8000b766:	cb 7a       	rjmp	8000b4d4 <_vfprintf_r+0x1c8>
8000b768:	50 a7       	stdsp	sp[0x28],r7
8000b76a:	50 80       	stdsp	sp[0x20],r0
8000b76c:	0c 97       	mov	r7,r6
8000b76e:	10 90       	mov	r0,r8
8000b770:	06 96       	mov	r6,r3
8000b772:	04 94       	mov	r4,r2
8000b774:	40 93       	lddsp	r3,sp[0x24]
8000b776:	02 92       	mov	r2,r1
8000b778:	0e 99       	mov	r9,r7
8000b77a:	40 41       	lddsp	r1,sp[0x10]
8000b77c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b780:	40 3c       	lddsp	r12,sp[0xc]
8000b782:	58 0c       	cp.w	r12,0
8000b784:	c1 d0       	breq	8000b7be <_vfprintf_r+0x4b2>
8000b786:	10 36       	cp.w	r6,r8
8000b788:	c0 64       	brge	8000b794 <_vfprintf_r+0x488>
8000b78a:	fa cb f9 44 	sub	r11,sp,-1724
8000b78e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b792:	c1 d8       	rjmp	8000b7cc <_vfprintf_r+0x4c0>
8000b794:	fa c8 f9 50 	sub	r8,sp,-1712
8000b798:	1a d8       	st.w	--sp,r8
8000b79a:	fa c8 fa b8 	sub	r8,sp,-1352
8000b79e:	1a d8       	st.w	--sp,r8
8000b7a0:	fa c8 fb b4 	sub	r8,sp,-1100
8000b7a4:	1a d8       	st.w	--sp,r8
8000b7a6:	fa c8 f9 40 	sub	r8,sp,-1728
8000b7aa:	fa c9 ff b4 	sub	r9,sp,-76
8000b7ae:	04 9a       	mov	r10,r2
8000b7b0:	0c 9b       	mov	r11,r6
8000b7b2:	08 9c       	mov	r12,r4
8000b7b4:	fe b0 fc 0e 	rcall	8000afd0 <get_arg>
8000b7b8:	2f dd       	sub	sp,-12
8000b7ba:	19 b8       	ld.ub	r8,r12[0x3]
8000b7bc:	c2 28       	rjmp	8000b800 <_vfprintf_r+0x4f4>
8000b7be:	2f f7       	sub	r7,-1
8000b7c0:	10 39       	cp.w	r9,r8
8000b7c2:	c0 84       	brge	8000b7d2 <_vfprintf_r+0x4c6>
8000b7c4:	fa ca f9 44 	sub	r10,sp,-1724
8000b7c8:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b7cc:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000b7d0:	c1 88       	rjmp	8000b800 <_vfprintf_r+0x4f4>
8000b7d2:	41 09       	lddsp	r9,sp[0x40]
8000b7d4:	59 f8       	cp.w	r8,31
8000b7d6:	e0 89 00 12 	brgt	8000b7fa <_vfprintf_r+0x4ee>
8000b7da:	f2 ca ff fc 	sub	r10,r9,-4
8000b7de:	51 0a       	stdsp	sp[0x40],r10
8000b7e0:	72 09       	ld.w	r9,r9[0x0]
8000b7e2:	fa c6 f9 44 	sub	r6,sp,-1724
8000b7e6:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000b7ea:	2f f8       	sub	r8,-1
8000b7ec:	f5 49 fd 88 	st.w	r10[-632],r9
8000b7f0:	fb 48 06 b4 	st.w	sp[1716],r8
8000b7f4:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000b7f8:	c0 48       	rjmp	8000b800 <_vfprintf_r+0x4f4>
8000b7fa:	13 b8       	ld.ub	r8,r9[0x3]
8000b7fc:	2f c9       	sub	r9,-4
8000b7fe:	51 09       	stdsp	sp[0x40],r9
8000b800:	fb 68 06 60 	st.b	sp[1632],r8
8000b804:	30 0e       	mov	lr,0
8000b806:	30 08       	mov	r8,0
8000b808:	30 12       	mov	r2,1
8000b80a:	fb 68 06 bb 	st.b	sp[1723],r8
8000b80e:	50 2e       	stdsp	sp[0x8],lr
8000b810:	e0 8f 08 b1 	bral	8000c972 <_vfprintf_r+0x1666>
8000b814:	50 a7       	stdsp	sp[0x28],r7
8000b816:	50 80       	stdsp	sp[0x20],r0
8000b818:	0c 97       	mov	r7,r6
8000b81a:	04 94       	mov	r4,r2
8000b81c:	06 96       	mov	r6,r3
8000b81e:	02 92       	mov	r2,r1
8000b820:	40 93       	lddsp	r3,sp[0x24]
8000b822:	10 90       	mov	r0,r8
8000b824:	40 41       	lddsp	r1,sp[0x10]
8000b826:	a5 a5       	sbr	r5,0x4
8000b828:	c0 a8       	rjmp	8000b83c <_vfprintf_r+0x530>
8000b82a:	50 a7       	stdsp	sp[0x28],r7
8000b82c:	50 80       	stdsp	sp[0x20],r0
8000b82e:	0c 97       	mov	r7,r6
8000b830:	04 94       	mov	r4,r2
8000b832:	06 96       	mov	r6,r3
8000b834:	02 92       	mov	r2,r1
8000b836:	40 93       	lddsp	r3,sp[0x24]
8000b838:	10 90       	mov	r0,r8
8000b83a:	40 41       	lddsp	r1,sp[0x10]
8000b83c:	ed b5 00 05 	bld	r5,0x5
8000b840:	c5 11       	brne	8000b8e2 <_vfprintf_r+0x5d6>
8000b842:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b846:	40 3c       	lddsp	r12,sp[0xc]
8000b848:	58 0c       	cp.w	r12,0
8000b84a:	c1 e0       	breq	8000b886 <_vfprintf_r+0x57a>
8000b84c:	10 36       	cp.w	r6,r8
8000b84e:	c0 64       	brge	8000b85a <_vfprintf_r+0x54e>
8000b850:	fa cb f9 44 	sub	r11,sp,-1724
8000b854:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b858:	c2 08       	rjmp	8000b898 <_vfprintf_r+0x58c>
8000b85a:	fa c8 f9 50 	sub	r8,sp,-1712
8000b85e:	1a d8       	st.w	--sp,r8
8000b860:	fa c8 fa b8 	sub	r8,sp,-1352
8000b864:	0c 9b       	mov	r11,r6
8000b866:	1a d8       	st.w	--sp,r8
8000b868:	fa c8 fb b4 	sub	r8,sp,-1100
8000b86c:	1a d8       	st.w	--sp,r8
8000b86e:	fa c9 ff b4 	sub	r9,sp,-76
8000b872:	fa c8 f9 40 	sub	r8,sp,-1728
8000b876:	04 9a       	mov	r10,r2
8000b878:	08 9c       	mov	r12,r4
8000b87a:	fe b0 fb ab 	rcall	8000afd0 <get_arg>
8000b87e:	2f dd       	sub	sp,-12
8000b880:	78 1b       	ld.w	r11,r12[0x4]
8000b882:	78 09       	ld.w	r9,r12[0x0]
8000b884:	c2 b8       	rjmp	8000b8da <_vfprintf_r+0x5ce>
8000b886:	ee ca ff ff 	sub	r10,r7,-1
8000b88a:	10 37       	cp.w	r7,r8
8000b88c:	c0 b4       	brge	8000b8a2 <_vfprintf_r+0x596>
8000b88e:	fa c9 f9 44 	sub	r9,sp,-1724
8000b892:	14 97       	mov	r7,r10
8000b894:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b898:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b89c:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000b8a0:	c1 d8       	rjmp	8000b8da <_vfprintf_r+0x5ce>
8000b8a2:	41 09       	lddsp	r9,sp[0x40]
8000b8a4:	59 f8       	cp.w	r8,31
8000b8a6:	e0 89 00 14 	brgt	8000b8ce <_vfprintf_r+0x5c2>
8000b8aa:	f2 cb ff f8 	sub	r11,r9,-8
8000b8ae:	51 0b       	stdsp	sp[0x40],r11
8000b8b0:	fa c6 f9 44 	sub	r6,sp,-1724
8000b8b4:	72 1b       	ld.w	r11,r9[0x4]
8000b8b6:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000b8ba:	72 09       	ld.w	r9,r9[0x0]
8000b8bc:	f9 4b fd 8c 	st.w	r12[-628],r11
8000b8c0:	f9 49 fd 88 	st.w	r12[-632],r9
8000b8c4:	2f f8       	sub	r8,-1
8000b8c6:	14 97       	mov	r7,r10
8000b8c8:	fb 48 06 b4 	st.w	sp[1716],r8
8000b8cc:	c0 78       	rjmp	8000b8da <_vfprintf_r+0x5ce>
8000b8ce:	f2 c8 ff f8 	sub	r8,r9,-8
8000b8d2:	72 1b       	ld.w	r11,r9[0x4]
8000b8d4:	14 97       	mov	r7,r10
8000b8d6:	51 08       	stdsp	sp[0x40],r8
8000b8d8:	72 09       	ld.w	r9,r9[0x0]
8000b8da:	16 98       	mov	r8,r11
8000b8dc:	fa e9 00 00 	st.d	sp[0],r8
8000b8e0:	ca e8       	rjmp	8000ba3c <_vfprintf_r+0x730>
8000b8e2:	ed b5 00 04 	bld	r5,0x4
8000b8e6:	c1 71       	brne	8000b914 <_vfprintf_r+0x608>
8000b8e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b8ec:	40 3e       	lddsp	lr,sp[0xc]
8000b8ee:	58 0e       	cp.w	lr,0
8000b8f0:	c0 80       	breq	8000b900 <_vfprintf_r+0x5f4>
8000b8f2:	10 36       	cp.w	r6,r8
8000b8f4:	c6 94       	brge	8000b9c6 <_vfprintf_r+0x6ba>
8000b8f6:	fa cc f9 44 	sub	r12,sp,-1724
8000b8fa:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b8fe:	c8 28       	rjmp	8000ba02 <_vfprintf_r+0x6f6>
8000b900:	ee ca ff ff 	sub	r10,r7,-1
8000b904:	10 37       	cp.w	r7,r8
8000b906:	e0 84 00 81 	brge	8000ba08 <_vfprintf_r+0x6fc>
8000b90a:	fa cb f9 44 	sub	r11,sp,-1724
8000b90e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b912:	c7 78       	rjmp	8000ba00 <_vfprintf_r+0x6f4>
8000b914:	ed b5 00 06 	bld	r5,0x6
8000b918:	c4 b1       	brne	8000b9ae <_vfprintf_r+0x6a2>
8000b91a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b91e:	40 3c       	lddsp	r12,sp[0xc]
8000b920:	58 0c       	cp.w	r12,0
8000b922:	c1 d0       	breq	8000b95c <_vfprintf_r+0x650>
8000b924:	10 36       	cp.w	r6,r8
8000b926:	c0 64       	brge	8000b932 <_vfprintf_r+0x626>
8000b928:	fa cb f9 44 	sub	r11,sp,-1724
8000b92c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b930:	c1 f8       	rjmp	8000b96e <_vfprintf_r+0x662>
8000b932:	fa c8 f9 50 	sub	r8,sp,-1712
8000b936:	1a d8       	st.w	--sp,r8
8000b938:	fa c8 fa b8 	sub	r8,sp,-1352
8000b93c:	1a d8       	st.w	--sp,r8
8000b93e:	fa c8 fb b4 	sub	r8,sp,-1100
8000b942:	1a d8       	st.w	--sp,r8
8000b944:	fa c8 f9 40 	sub	r8,sp,-1728
8000b948:	fa c9 ff b4 	sub	r9,sp,-76
8000b94c:	04 9a       	mov	r10,r2
8000b94e:	0c 9b       	mov	r11,r6
8000b950:	08 9c       	mov	r12,r4
8000b952:	fe b0 fb 3f 	rcall	8000afd0 <get_arg>
8000b956:	2f dd       	sub	sp,-12
8000b958:	98 18       	ld.sh	r8,r12[0x2]
8000b95a:	c2 68       	rjmp	8000b9a6 <_vfprintf_r+0x69a>
8000b95c:	ee ca ff ff 	sub	r10,r7,-1
8000b960:	10 37       	cp.w	r7,r8
8000b962:	c0 94       	brge	8000b974 <_vfprintf_r+0x668>
8000b964:	fa c9 f9 44 	sub	r9,sp,-1724
8000b968:	14 97       	mov	r7,r10
8000b96a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b96e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000b972:	c1 a8       	rjmp	8000b9a6 <_vfprintf_r+0x69a>
8000b974:	41 09       	lddsp	r9,sp[0x40]
8000b976:	59 f8       	cp.w	r8,31
8000b978:	e0 89 00 13 	brgt	8000b99e <_vfprintf_r+0x692>
8000b97c:	f2 cb ff fc 	sub	r11,r9,-4
8000b980:	51 0b       	stdsp	sp[0x40],r11
8000b982:	72 09       	ld.w	r9,r9[0x0]
8000b984:	fa c6 f9 44 	sub	r6,sp,-1724
8000b988:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000b98c:	2f f8       	sub	r8,-1
8000b98e:	f7 49 fd 88 	st.w	r11[-632],r9
8000b992:	fb 48 06 b4 	st.w	sp[1716],r8
8000b996:	14 97       	mov	r7,r10
8000b998:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000b99c:	c0 58       	rjmp	8000b9a6 <_vfprintf_r+0x69a>
8000b99e:	92 18       	ld.sh	r8,r9[0x2]
8000b9a0:	14 97       	mov	r7,r10
8000b9a2:	2f c9       	sub	r9,-4
8000b9a4:	51 09       	stdsp	sp[0x40],r9
8000b9a6:	50 18       	stdsp	sp[0x4],r8
8000b9a8:	bf 58       	asr	r8,0x1f
8000b9aa:	50 08       	stdsp	sp[0x0],r8
8000b9ac:	c4 88       	rjmp	8000ba3c <_vfprintf_r+0x730>
8000b9ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b9b2:	40 3c       	lddsp	r12,sp[0xc]
8000b9b4:	58 0c       	cp.w	r12,0
8000b9b6:	c1 d0       	breq	8000b9f0 <_vfprintf_r+0x6e4>
8000b9b8:	10 36       	cp.w	r6,r8
8000b9ba:	c0 64       	brge	8000b9c6 <_vfprintf_r+0x6ba>
8000b9bc:	fa cb f9 44 	sub	r11,sp,-1724
8000b9c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b9c4:	c1 f8       	rjmp	8000ba02 <_vfprintf_r+0x6f6>
8000b9c6:	fa c8 f9 50 	sub	r8,sp,-1712
8000b9ca:	1a d8       	st.w	--sp,r8
8000b9cc:	fa c8 fa b8 	sub	r8,sp,-1352
8000b9d0:	0c 9b       	mov	r11,r6
8000b9d2:	1a d8       	st.w	--sp,r8
8000b9d4:	fa c8 fb b4 	sub	r8,sp,-1100
8000b9d8:	04 9a       	mov	r10,r2
8000b9da:	1a d8       	st.w	--sp,r8
8000b9dc:	08 9c       	mov	r12,r4
8000b9de:	fa c8 f9 40 	sub	r8,sp,-1728
8000b9e2:	fa c9 ff b4 	sub	r9,sp,-76
8000b9e6:	fe b0 fa f5 	rcall	8000afd0 <get_arg>
8000b9ea:	2f dd       	sub	sp,-12
8000b9ec:	78 0b       	ld.w	r11,r12[0x0]
8000b9ee:	c2 48       	rjmp	8000ba36 <_vfprintf_r+0x72a>
8000b9f0:	ee ca ff ff 	sub	r10,r7,-1
8000b9f4:	10 37       	cp.w	r7,r8
8000b9f6:	c0 94       	brge	8000ba08 <_vfprintf_r+0x6fc>
8000b9f8:	fa c9 f9 44 	sub	r9,sp,-1724
8000b9fc:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000ba00:	14 97       	mov	r7,r10
8000ba02:	ec fb fd 88 	ld.w	r11,r6[-632]
8000ba06:	c1 88       	rjmp	8000ba36 <_vfprintf_r+0x72a>
8000ba08:	41 09       	lddsp	r9,sp[0x40]
8000ba0a:	59 f8       	cp.w	r8,31
8000ba0c:	e0 89 00 11 	brgt	8000ba2e <_vfprintf_r+0x722>
8000ba10:	f2 cb ff fc 	sub	r11,r9,-4
8000ba14:	51 0b       	stdsp	sp[0x40],r11
8000ba16:	fa c6 f9 44 	sub	r6,sp,-1724
8000ba1a:	72 0b       	ld.w	r11,r9[0x0]
8000ba1c:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ba20:	f3 4b fd 88 	st.w	r9[-632],r11
8000ba24:	2f f8       	sub	r8,-1
8000ba26:	14 97       	mov	r7,r10
8000ba28:	fb 48 06 b4 	st.w	sp[1716],r8
8000ba2c:	c0 58       	rjmp	8000ba36 <_vfprintf_r+0x72a>
8000ba2e:	72 0b       	ld.w	r11,r9[0x0]
8000ba30:	14 97       	mov	r7,r10
8000ba32:	2f c9       	sub	r9,-4
8000ba34:	51 09       	stdsp	sp[0x40],r9
8000ba36:	50 1b       	stdsp	sp[0x4],r11
8000ba38:	bf 5b       	asr	r11,0x1f
8000ba3a:	50 0b       	stdsp	sp[0x0],r11
8000ba3c:	fa ea 00 00 	ld.d	r10,sp[0]
8000ba40:	58 0a       	cp.w	r10,0
8000ba42:	5c 2b       	cpc	r11
8000ba44:	c0 e4       	brge	8000ba60 <_vfprintf_r+0x754>
8000ba46:	30 08       	mov	r8,0
8000ba48:	fa ea 00 00 	ld.d	r10,sp[0]
8000ba4c:	30 09       	mov	r9,0
8000ba4e:	f0 0a 01 0a 	sub	r10,r8,r10
8000ba52:	f2 0b 01 4b 	sbc	r11,r9,r11
8000ba56:	32 d8       	mov	r8,45
8000ba58:	fa eb 00 00 	st.d	sp[0],r10
8000ba5c:	fb 68 06 bb 	st.b	sp[1723],r8
8000ba60:	30 18       	mov	r8,1
8000ba62:	e0 8f 06 fe 	bral	8000c85e <_vfprintf_r+0x1552>
8000ba66:	50 a7       	stdsp	sp[0x28],r7
8000ba68:	50 80       	stdsp	sp[0x20],r0
8000ba6a:	0c 97       	mov	r7,r6
8000ba6c:	04 94       	mov	r4,r2
8000ba6e:	06 96       	mov	r6,r3
8000ba70:	02 92       	mov	r2,r1
8000ba72:	40 93       	lddsp	r3,sp[0x24]
8000ba74:	10 90       	mov	r0,r8
8000ba76:	40 41       	lddsp	r1,sp[0x10]
8000ba78:	0e 99       	mov	r9,r7
8000ba7a:	ed b5 00 03 	bld	r5,0x3
8000ba7e:	c4 11       	brne	8000bb00 <_vfprintf_r+0x7f4>
8000ba80:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ba84:	40 3a       	lddsp	r10,sp[0xc]
8000ba86:	58 0a       	cp.w	r10,0
8000ba88:	c1 90       	breq	8000baba <_vfprintf_r+0x7ae>
8000ba8a:	10 36       	cp.w	r6,r8
8000ba8c:	c6 45       	brlt	8000bb54 <_vfprintf_r+0x848>
8000ba8e:	fa c8 f9 50 	sub	r8,sp,-1712
8000ba92:	1a d8       	st.w	--sp,r8
8000ba94:	fa c8 fa b8 	sub	r8,sp,-1352
8000ba98:	1a d8       	st.w	--sp,r8
8000ba9a:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba9e:	0c 9b       	mov	r11,r6
8000baa0:	1a d8       	st.w	--sp,r8
8000baa2:	04 9a       	mov	r10,r2
8000baa4:	fa c8 f9 40 	sub	r8,sp,-1728
8000baa8:	fa c9 ff b4 	sub	r9,sp,-76
8000baac:	08 9c       	mov	r12,r4
8000baae:	fe b0 fa 91 	rcall	8000afd0 <get_arg>
8000bab2:	2f dd       	sub	sp,-12
8000bab4:	78 16       	ld.w	r6,r12[0x4]
8000bab6:	50 76       	stdsp	sp[0x1c],r6
8000bab8:	c4 88       	rjmp	8000bb48 <_vfprintf_r+0x83c>
8000baba:	2f f7       	sub	r7,-1
8000babc:	10 39       	cp.w	r9,r8
8000babe:	c0 c4       	brge	8000bad6 <_vfprintf_r+0x7ca>
8000bac0:	fa ce f9 44 	sub	lr,sp,-1724
8000bac4:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000bac8:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000bacc:	50 7c       	stdsp	sp[0x1c],r12
8000bace:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000bad2:	50 56       	stdsp	sp[0x14],r6
8000bad4:	c6 68       	rjmp	8000bba0 <_vfprintf_r+0x894>
8000bad6:	41 09       	lddsp	r9,sp[0x40]
8000bad8:	59 f8       	cp.w	r8,31
8000bada:	e0 89 00 10 	brgt	8000bafa <_vfprintf_r+0x7ee>
8000bade:	f2 ca ff f8 	sub	r10,r9,-8
8000bae2:	72 1b       	ld.w	r11,r9[0x4]
8000bae4:	51 0a       	stdsp	sp[0x40],r10
8000bae6:	72 09       	ld.w	r9,r9[0x0]
8000bae8:	fa ca f9 44 	sub	r10,sp,-1724
8000baec:	50 7b       	stdsp	sp[0x1c],r11
8000baee:	50 59       	stdsp	sp[0x14],r9
8000baf0:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000baf4:	40 5b       	lddsp	r11,sp[0x14]
8000baf6:	40 7a       	lddsp	r10,sp[0x1c]
8000baf8:	c4 78       	rjmp	8000bb86 <_vfprintf_r+0x87a>
8000bafa:	72 18       	ld.w	r8,r9[0x4]
8000bafc:	50 78       	stdsp	sp[0x1c],r8
8000bafe:	c4 c8       	rjmp	8000bb96 <_vfprintf_r+0x88a>
8000bb00:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bb04:	40 3e       	lddsp	lr,sp[0xc]
8000bb06:	58 0e       	cp.w	lr,0
8000bb08:	c2 30       	breq	8000bb4e <_vfprintf_r+0x842>
8000bb0a:	10 36       	cp.w	r6,r8
8000bb0c:	c0 94       	brge	8000bb1e <_vfprintf_r+0x812>
8000bb0e:	fa cc f9 44 	sub	r12,sp,-1724
8000bb12:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bb16:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000bb1a:	50 7b       	stdsp	sp[0x1c],r11
8000bb1c:	cd 9b       	rjmp	8000bace <_vfprintf_r+0x7c2>
8000bb1e:	fa c8 f9 50 	sub	r8,sp,-1712
8000bb22:	1a d8       	st.w	--sp,r8
8000bb24:	fa c8 fa b8 	sub	r8,sp,-1352
8000bb28:	04 9a       	mov	r10,r2
8000bb2a:	1a d8       	st.w	--sp,r8
8000bb2c:	fa c8 fb b4 	sub	r8,sp,-1100
8000bb30:	0c 9b       	mov	r11,r6
8000bb32:	1a d8       	st.w	--sp,r8
8000bb34:	08 9c       	mov	r12,r4
8000bb36:	fa c8 f9 40 	sub	r8,sp,-1728
8000bb3a:	fa c9 ff b4 	sub	r9,sp,-76
8000bb3e:	fe b0 fa 49 	rcall	8000afd0 <get_arg>
8000bb42:	2f dd       	sub	sp,-12
8000bb44:	78 1a       	ld.w	r10,r12[0x4]
8000bb46:	50 7a       	stdsp	sp[0x1c],r10
8000bb48:	78 0c       	ld.w	r12,r12[0x0]
8000bb4a:	50 5c       	stdsp	sp[0x14],r12
8000bb4c:	c2 a8       	rjmp	8000bba0 <_vfprintf_r+0x894>
8000bb4e:	2f f7       	sub	r7,-1
8000bb50:	10 39       	cp.w	r9,r8
8000bb52:	c0 94       	brge	8000bb64 <_vfprintf_r+0x858>
8000bb54:	fa c9 f9 44 	sub	r9,sp,-1724
8000bb58:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bb5c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000bb60:	50 78       	stdsp	sp[0x1c],r8
8000bb62:	cb 6b       	rjmp	8000bace <_vfprintf_r+0x7c2>
8000bb64:	41 09       	lddsp	r9,sp[0x40]
8000bb66:	59 f8       	cp.w	r8,31
8000bb68:	e0 89 00 15 	brgt	8000bb92 <_vfprintf_r+0x886>
8000bb6c:	f2 ca ff f8 	sub	r10,r9,-8
8000bb70:	72 16       	ld.w	r6,r9[0x4]
8000bb72:	72 09       	ld.w	r9,r9[0x0]
8000bb74:	51 0a       	stdsp	sp[0x40],r10
8000bb76:	50 59       	stdsp	sp[0x14],r9
8000bb78:	fa ce f9 44 	sub	lr,sp,-1724
8000bb7c:	50 76       	stdsp	sp[0x1c],r6
8000bb7e:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000bb82:	40 5b       	lddsp	r11,sp[0x14]
8000bb84:	0c 9a       	mov	r10,r6
8000bb86:	f2 eb fd 88 	st.d	r9[-632],r10
8000bb8a:	2f f8       	sub	r8,-1
8000bb8c:	fb 48 06 b4 	st.w	sp[1716],r8
8000bb90:	c0 88       	rjmp	8000bba0 <_vfprintf_r+0x894>
8000bb92:	72 1c       	ld.w	r12,r9[0x4]
8000bb94:	50 7c       	stdsp	sp[0x1c],r12
8000bb96:	f2 c8 ff f8 	sub	r8,r9,-8
8000bb9a:	51 08       	stdsp	sp[0x40],r8
8000bb9c:	72 09       	ld.w	r9,r9[0x0]
8000bb9e:	50 59       	stdsp	sp[0x14],r9
8000bba0:	40 5b       	lddsp	r11,sp[0x14]
8000bba2:	40 7a       	lddsp	r10,sp[0x1c]
8000bba4:	e0 a0 19 64 	rcall	8000ee6c <__isinfd>
8000bba8:	18 96       	mov	r6,r12
8000bbaa:	c1 50       	breq	8000bbd4 <_vfprintf_r+0x8c8>
8000bbac:	30 08       	mov	r8,0
8000bbae:	30 09       	mov	r9,0
8000bbb0:	40 5b       	lddsp	r11,sp[0x14]
8000bbb2:	40 7a       	lddsp	r10,sp[0x1c]
8000bbb4:	e0 a0 1d ba 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000bbb8:	c0 40       	breq	8000bbc0 <_vfprintf_r+0x8b4>
8000bbba:	32 d8       	mov	r8,45
8000bbbc:	fb 68 06 bb 	st.b	sp[1723],r8
8000bbc0:	4d 18       	lddpc	r8,8000bd04 <_vfprintf_r+0x9f8>
8000bbc2:	4d 26       	lddpc	r6,8000bd08 <_vfprintf_r+0x9fc>
8000bbc4:	a7 d5       	cbr	r5,0x7
8000bbc6:	e0 40 00 47 	cp.w	r0,71
8000bbca:	f0 06 17 a0 	movle	r6,r8
8000bbce:	30 32       	mov	r2,3
8000bbd0:	e0 8f 06 d4 	bral	8000c978 <_vfprintf_r+0x166c>
8000bbd4:	40 5b       	lddsp	r11,sp[0x14]
8000bbd6:	40 7a       	lddsp	r10,sp[0x1c]
8000bbd8:	e0 a0 19 5f 	rcall	8000ee96 <__isnand>
8000bbdc:	c0 c0       	breq	8000bbf4 <_vfprintf_r+0x8e8>
8000bbde:	50 26       	stdsp	sp[0x8],r6
8000bbe0:	4c b8       	lddpc	r8,8000bd0c <_vfprintf_r+0xa00>
8000bbe2:	4c c6       	lddpc	r6,8000bd10 <_vfprintf_r+0xa04>
8000bbe4:	a7 d5       	cbr	r5,0x7
8000bbe6:	e0 40 00 47 	cp.w	r0,71
8000bbea:	f0 06 17 a0 	movle	r6,r8
8000bbee:	30 32       	mov	r2,3
8000bbf0:	e0 8f 06 ca 	bral	8000c984 <_vfprintf_r+0x1678>
8000bbf4:	40 2a       	lddsp	r10,sp[0x8]
8000bbf6:	5b fa       	cp.w	r10,-1
8000bbf8:	c0 41       	brne	8000bc00 <_vfprintf_r+0x8f4>
8000bbfa:	30 69       	mov	r9,6
8000bbfc:	50 29       	stdsp	sp[0x8],r9
8000bbfe:	c1 18       	rjmp	8000bc20 <_vfprintf_r+0x914>
8000bc00:	e0 40 00 47 	cp.w	r0,71
8000bc04:	5f 09       	sreq	r9
8000bc06:	e0 40 00 67 	cp.w	r0,103
8000bc0a:	5f 08       	sreq	r8
8000bc0c:	f3 e8 10 08 	or	r8,r9,r8
8000bc10:	f8 08 18 00 	cp.b	r8,r12
8000bc14:	c0 60       	breq	8000bc20 <_vfprintf_r+0x914>
8000bc16:	40 28       	lddsp	r8,sp[0x8]
8000bc18:	58 08       	cp.w	r8,0
8000bc1a:	f9 b8 00 01 	moveq	r8,1
8000bc1e:	50 28       	stdsp	sp[0x8],r8
8000bc20:	40 78       	lddsp	r8,sp[0x1c]
8000bc22:	40 59       	lddsp	r9,sp[0x14]
8000bc24:	fa e9 06 94 	st.d	sp[1684],r8
8000bc28:	a9 a5       	sbr	r5,0x8
8000bc2a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000bc2e:	58 08       	cp.w	r8,0
8000bc30:	c0 65       	brlt	8000bc3c <_vfprintf_r+0x930>
8000bc32:	40 5e       	lddsp	lr,sp[0x14]
8000bc34:	30 0c       	mov	r12,0
8000bc36:	50 6e       	stdsp	sp[0x18],lr
8000bc38:	50 9c       	stdsp	sp[0x24],r12
8000bc3a:	c0 78       	rjmp	8000bc48 <_vfprintf_r+0x93c>
8000bc3c:	40 5b       	lddsp	r11,sp[0x14]
8000bc3e:	32 da       	mov	r10,45
8000bc40:	ee 1b 80 00 	eorh	r11,0x8000
8000bc44:	50 9a       	stdsp	sp[0x24],r10
8000bc46:	50 6b       	stdsp	sp[0x18],r11
8000bc48:	e0 40 00 46 	cp.w	r0,70
8000bc4c:	5f 09       	sreq	r9
8000bc4e:	e0 40 00 66 	cp.w	r0,102
8000bc52:	5f 08       	sreq	r8
8000bc54:	f3 e8 10 08 	or	r8,r9,r8
8000bc58:	50 48       	stdsp	sp[0x10],r8
8000bc5a:	c0 40       	breq	8000bc62 <_vfprintf_r+0x956>
8000bc5c:	40 22       	lddsp	r2,sp[0x8]
8000bc5e:	30 39       	mov	r9,3
8000bc60:	c1 08       	rjmp	8000bc80 <_vfprintf_r+0x974>
8000bc62:	e0 40 00 45 	cp.w	r0,69
8000bc66:	5f 09       	sreq	r9
8000bc68:	e0 40 00 65 	cp.w	r0,101
8000bc6c:	5f 08       	sreq	r8
8000bc6e:	40 22       	lddsp	r2,sp[0x8]
8000bc70:	10 49       	or	r9,r8
8000bc72:	2f f2       	sub	r2,-1
8000bc74:	40 46       	lddsp	r6,sp[0x10]
8000bc76:	ec 09 18 00 	cp.b	r9,r6
8000bc7a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000bc7e:	30 29       	mov	r9,2
8000bc80:	fa c8 f9 5c 	sub	r8,sp,-1700
8000bc84:	1a d8       	st.w	--sp,r8
8000bc86:	fa c8 f9 54 	sub	r8,sp,-1708
8000bc8a:	1a d8       	st.w	--sp,r8
8000bc8c:	fa c8 f9 4c 	sub	r8,sp,-1716
8000bc90:	08 9c       	mov	r12,r4
8000bc92:	1a d8       	st.w	--sp,r8
8000bc94:	04 98       	mov	r8,r2
8000bc96:	40 9b       	lddsp	r11,sp[0x24]
8000bc98:	40 aa       	lddsp	r10,sp[0x28]
8000bc9a:	e0 a0 0b cf 	rcall	8000d438 <_dtoa_r>
8000bc9e:	e0 40 00 47 	cp.w	r0,71
8000bca2:	5f 19       	srne	r9
8000bca4:	e0 40 00 67 	cp.w	r0,103
8000bca8:	5f 18       	srne	r8
8000bcaa:	18 96       	mov	r6,r12
8000bcac:	2f dd       	sub	sp,-12
8000bcae:	f3 e8 00 08 	and	r8,r9,r8
8000bcb2:	c0 41       	brne	8000bcba <_vfprintf_r+0x9ae>
8000bcb4:	ed b5 00 00 	bld	r5,0x0
8000bcb8:	c3 81       	brne	8000bd28 <_vfprintf_r+0xa1c>
8000bcba:	ec 02 00 0e 	add	lr,r6,r2
8000bcbe:	50 3e       	stdsp	sp[0xc],lr
8000bcc0:	40 4c       	lddsp	r12,sp[0x10]
8000bcc2:	58 0c       	cp.w	r12,0
8000bcc4:	c1 50       	breq	8000bcee <_vfprintf_r+0x9e2>
8000bcc6:	0d 89       	ld.ub	r9,r6[0x0]
8000bcc8:	33 08       	mov	r8,48
8000bcca:	f0 09 18 00 	cp.b	r9,r8
8000bcce:	c0 b1       	brne	8000bce4 <_vfprintf_r+0x9d8>
8000bcd0:	30 08       	mov	r8,0
8000bcd2:	30 09       	mov	r9,0
8000bcd4:	40 6b       	lddsp	r11,sp[0x18]
8000bcd6:	40 7a       	lddsp	r10,sp[0x1c]
8000bcd8:	e0 a0 1c e1 	rcall	8000f69a <__avr32_f64_cmp_eq>
8000bcdc:	fb b2 00 01 	rsubeq	r2,1
8000bce0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000bce4:	40 3b       	lddsp	r11,sp[0xc]
8000bce6:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000bcea:	10 0b       	add	r11,r8
8000bcec:	50 3b       	stdsp	sp[0xc],r11
8000bcee:	40 6b       	lddsp	r11,sp[0x18]
8000bcf0:	30 08       	mov	r8,0
8000bcf2:	30 09       	mov	r9,0
8000bcf4:	40 7a       	lddsp	r10,sp[0x1c]
8000bcf6:	e0 a0 1c d2 	rcall	8000f69a <__avr32_f64_cmp_eq>
8000bcfa:	c1 10       	breq	8000bd1c <_vfprintf_r+0xa10>
8000bcfc:	40 3a       	lddsp	r10,sp[0xc]
8000bcfe:	fb 4a 06 a4 	st.w	sp[1700],r10
8000bd02:	c0 d8       	rjmp	8000bd1c <_vfprintf_r+0xa10>
8000bd04:	80 01       	ld.sh	r1,r0[0x0]
8000bd06:	9b 60       	st.w	sp[0x18],r0
8000bd08:	80 01       	ld.sh	r1,r0[0x0]
8000bd0a:	9b 64       	st.w	sp[0x18],r4
8000bd0c:	80 01       	ld.sh	r1,r0[0x0]
8000bd0e:	9b 68       	st.w	sp[0x18],r8
8000bd10:	80 01       	ld.sh	r1,r0[0x0]
8000bd12:	9b 6c       	st.w	sp[0x18],r12
8000bd14:	10 c9       	st.b	r8++,r9
8000bd16:	fb 48 06 a4 	st.w	sp[1700],r8
8000bd1a:	c0 28       	rjmp	8000bd1e <_vfprintf_r+0xa12>
8000bd1c:	33 09       	mov	r9,48
8000bd1e:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000bd22:	40 3e       	lddsp	lr,sp[0xc]
8000bd24:	1c 38       	cp.w	r8,lr
8000bd26:	cf 73       	brcs	8000bd14 <_vfprintf_r+0xa08>
8000bd28:	e0 40 00 47 	cp.w	r0,71
8000bd2c:	5f 09       	sreq	r9
8000bd2e:	e0 40 00 67 	cp.w	r0,103
8000bd32:	5f 08       	sreq	r8
8000bd34:	f3 e8 10 08 	or	r8,r9,r8
8000bd38:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000bd3c:	0c 19       	sub	r9,r6
8000bd3e:	50 69       	stdsp	sp[0x18],r9
8000bd40:	58 08       	cp.w	r8,0
8000bd42:	c0 b0       	breq	8000bd58 <_vfprintf_r+0xa4c>
8000bd44:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000bd48:	5b d8       	cp.w	r8,-3
8000bd4a:	c0 55       	brlt	8000bd54 <_vfprintf_r+0xa48>
8000bd4c:	40 2c       	lddsp	r12,sp[0x8]
8000bd4e:	18 38       	cp.w	r8,r12
8000bd50:	e0 8a 00 6a 	brle	8000be24 <_vfprintf_r+0xb18>
8000bd54:	20 20       	sub	r0,2
8000bd56:	c0 58       	rjmp	8000bd60 <_vfprintf_r+0xa54>
8000bd58:	e0 40 00 65 	cp.w	r0,101
8000bd5c:	e0 89 00 46 	brgt	8000bde8 <_vfprintf_r+0xadc>
8000bd60:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000bd64:	fb 60 06 9c 	st.b	sp[1692],r0
8000bd68:	20 1b       	sub	r11,1
8000bd6a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000bd6e:	c0 47       	brpl	8000bd76 <_vfprintf_r+0xa6a>
8000bd70:	5c 3b       	neg	r11
8000bd72:	32 d8       	mov	r8,45
8000bd74:	c0 28       	rjmp	8000bd78 <_vfprintf_r+0xa6c>
8000bd76:	32 b8       	mov	r8,43
8000bd78:	fb 68 06 9d 	st.b	sp[1693],r8
8000bd7c:	58 9b       	cp.w	r11,9
8000bd7e:	e0 8a 00 1d 	brle	8000bdb8 <_vfprintf_r+0xaac>
8000bd82:	fa c9 fa 35 	sub	r9,sp,-1483
8000bd86:	30 aa       	mov	r10,10
8000bd88:	12 98       	mov	r8,r9
8000bd8a:	0e 9c       	mov	r12,r7
8000bd8c:	0c 92       	mov	r2,r6
8000bd8e:	f6 0a 0c 06 	divs	r6,r11,r10
8000bd92:	0e 9b       	mov	r11,r7
8000bd94:	2d 0b       	sub	r11,-48
8000bd96:	10 fb       	st.b	--r8,r11
8000bd98:	0c 9b       	mov	r11,r6
8000bd9a:	58 96       	cp.w	r6,9
8000bd9c:	fe 99 ff f9 	brgt	8000bd8e <_vfprintf_r+0xa82>
8000bda0:	2d 0b       	sub	r11,-48
8000bda2:	18 97       	mov	r7,r12
8000bda4:	04 96       	mov	r6,r2
8000bda6:	10 fb       	st.b	--r8,r11
8000bda8:	fa ca f9 62 	sub	r10,sp,-1694
8000bdac:	c0 38       	rjmp	8000bdb2 <_vfprintf_r+0xaa6>
8000bdae:	11 3b       	ld.ub	r11,r8++
8000bdb0:	14 cb       	st.b	r10++,r11
8000bdb2:	12 38       	cp.w	r8,r9
8000bdb4:	cf d3       	brcs	8000bdae <_vfprintf_r+0xaa2>
8000bdb6:	c0 98       	rjmp	8000bdc8 <_vfprintf_r+0xabc>
8000bdb8:	2d 0b       	sub	r11,-48
8000bdba:	33 08       	mov	r8,48
8000bdbc:	fb 6b 06 9f 	st.b	sp[1695],r11
8000bdc0:	fb 68 06 9e 	st.b	sp[1694],r8
8000bdc4:	fa ca f9 60 	sub	r10,sp,-1696
8000bdc8:	fa c8 f9 64 	sub	r8,sp,-1692
8000bdcc:	f4 08 01 08 	sub	r8,r10,r8
8000bdd0:	50 e8       	stdsp	sp[0x38],r8
8000bdd2:	10 92       	mov	r2,r8
8000bdd4:	40 6b       	lddsp	r11,sp[0x18]
8000bdd6:	16 02       	add	r2,r11
8000bdd8:	58 1b       	cp.w	r11,1
8000bdda:	e0 89 00 05 	brgt	8000bde4 <_vfprintf_r+0xad8>
8000bdde:	ed b5 00 00 	bld	r5,0x0
8000bde2:	c3 51       	brne	8000be4c <_vfprintf_r+0xb40>
8000bde4:	2f f2       	sub	r2,-1
8000bde6:	c3 38       	rjmp	8000be4c <_vfprintf_r+0xb40>
8000bde8:	e0 40 00 66 	cp.w	r0,102
8000bdec:	c1 c1       	brne	8000be24 <_vfprintf_r+0xb18>
8000bdee:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000bdf2:	58 02       	cp.w	r2,0
8000bdf4:	e0 8a 00 0c 	brle	8000be0c <_vfprintf_r+0xb00>
8000bdf8:	40 2a       	lddsp	r10,sp[0x8]
8000bdfa:	58 0a       	cp.w	r10,0
8000bdfc:	c0 41       	brne	8000be04 <_vfprintf_r+0xaf8>
8000bdfe:	ed b5 00 00 	bld	r5,0x0
8000be02:	c2 51       	brne	8000be4c <_vfprintf_r+0xb40>
8000be04:	2f f2       	sub	r2,-1
8000be06:	40 29       	lddsp	r9,sp[0x8]
8000be08:	12 02       	add	r2,r9
8000be0a:	c0 b8       	rjmp	8000be20 <_vfprintf_r+0xb14>
8000be0c:	40 28       	lddsp	r8,sp[0x8]
8000be0e:	58 08       	cp.w	r8,0
8000be10:	c0 61       	brne	8000be1c <_vfprintf_r+0xb10>
8000be12:	ed b5 00 00 	bld	r5,0x0
8000be16:	c0 30       	breq	8000be1c <_vfprintf_r+0xb10>
8000be18:	30 12       	mov	r2,1
8000be1a:	c1 98       	rjmp	8000be4c <_vfprintf_r+0xb40>
8000be1c:	40 22       	lddsp	r2,sp[0x8]
8000be1e:	2f e2       	sub	r2,-2
8000be20:	36 60       	mov	r0,102
8000be22:	c1 58       	rjmp	8000be4c <_vfprintf_r+0xb40>
8000be24:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000be28:	40 6e       	lddsp	lr,sp[0x18]
8000be2a:	1c 32       	cp.w	r2,lr
8000be2c:	c0 65       	brlt	8000be38 <_vfprintf_r+0xb2c>
8000be2e:	ed b5 00 00 	bld	r5,0x0
8000be32:	f7 b2 00 ff 	subeq	r2,-1
8000be36:	c0 a8       	rjmp	8000be4a <_vfprintf_r+0xb3e>
8000be38:	e4 08 11 02 	rsub	r8,r2,2
8000be3c:	40 6c       	lddsp	r12,sp[0x18]
8000be3e:	58 02       	cp.w	r2,0
8000be40:	f0 02 17 a0 	movle	r2,r8
8000be44:	f9 b2 09 01 	movgt	r2,1
8000be48:	18 02       	add	r2,r12
8000be4a:	36 70       	mov	r0,103
8000be4c:	40 9b       	lddsp	r11,sp[0x24]
8000be4e:	58 0b       	cp.w	r11,0
8000be50:	e0 80 05 94 	breq	8000c978 <_vfprintf_r+0x166c>
8000be54:	32 d8       	mov	r8,45
8000be56:	fb 68 06 bb 	st.b	sp[1723],r8
8000be5a:	e0 8f 05 93 	bral	8000c980 <_vfprintf_r+0x1674>
8000be5e:	50 a7       	stdsp	sp[0x28],r7
8000be60:	04 94       	mov	r4,r2
8000be62:	0c 97       	mov	r7,r6
8000be64:	02 92       	mov	r2,r1
8000be66:	06 96       	mov	r6,r3
8000be68:	40 41       	lddsp	r1,sp[0x10]
8000be6a:	40 93       	lddsp	r3,sp[0x24]
8000be6c:	0e 99       	mov	r9,r7
8000be6e:	ed b5 00 05 	bld	r5,0x5
8000be72:	c4 81       	brne	8000bf02 <_vfprintf_r+0xbf6>
8000be74:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000be78:	40 3e       	lddsp	lr,sp[0xc]
8000be7a:	58 0e       	cp.w	lr,0
8000be7c:	c1 d0       	breq	8000beb6 <_vfprintf_r+0xbaa>
8000be7e:	10 36       	cp.w	r6,r8
8000be80:	c0 64       	brge	8000be8c <_vfprintf_r+0xb80>
8000be82:	fa cc f9 44 	sub	r12,sp,-1724
8000be86:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000be8a:	c1 d8       	rjmp	8000bec4 <_vfprintf_r+0xbb8>
8000be8c:	fa c8 f9 50 	sub	r8,sp,-1712
8000be90:	1a d8       	st.w	--sp,r8
8000be92:	fa c8 fa b8 	sub	r8,sp,-1352
8000be96:	04 9a       	mov	r10,r2
8000be98:	1a d8       	st.w	--sp,r8
8000be9a:	fa c8 fb b4 	sub	r8,sp,-1100
8000be9e:	0c 9b       	mov	r11,r6
8000bea0:	1a d8       	st.w	--sp,r8
8000bea2:	08 9c       	mov	r12,r4
8000bea4:	fa c8 f9 40 	sub	r8,sp,-1728
8000bea8:	fa c9 ff b4 	sub	r9,sp,-76
8000beac:	fe b0 f8 92 	rcall	8000afd0 <get_arg>
8000beb0:	2f dd       	sub	sp,-12
8000beb2:	78 0a       	ld.w	r10,r12[0x0]
8000beb4:	c2 08       	rjmp	8000bef4 <_vfprintf_r+0xbe8>
8000beb6:	2f f7       	sub	r7,-1
8000beb8:	10 39       	cp.w	r9,r8
8000beba:	c0 84       	brge	8000beca <_vfprintf_r+0xbbe>
8000bebc:	fa cb f9 44 	sub	r11,sp,-1724
8000bec0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bec4:	ec fa fd 88 	ld.w	r10,r6[-632]
8000bec8:	c1 68       	rjmp	8000bef4 <_vfprintf_r+0xbe8>
8000beca:	41 09       	lddsp	r9,sp[0x40]
8000becc:	59 f8       	cp.w	r8,31
8000bece:	e0 89 00 10 	brgt	8000beee <_vfprintf_r+0xbe2>
8000bed2:	f2 ca ff fc 	sub	r10,r9,-4
8000bed6:	51 0a       	stdsp	sp[0x40],r10
8000bed8:	fa c6 f9 44 	sub	r6,sp,-1724
8000bedc:	72 0a       	ld.w	r10,r9[0x0]
8000bede:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bee2:	f3 4a fd 88 	st.w	r9[-632],r10
8000bee6:	2f f8       	sub	r8,-1
8000bee8:	fb 48 06 b4 	st.w	sp[1716],r8
8000beec:	c0 48       	rjmp	8000bef4 <_vfprintf_r+0xbe8>
8000beee:	72 0a       	ld.w	r10,r9[0x0]
8000bef0:	2f c9       	sub	r9,-4
8000bef2:	51 09       	stdsp	sp[0x40],r9
8000bef4:	40 be       	lddsp	lr,sp[0x2c]
8000bef6:	1c 98       	mov	r8,lr
8000bef8:	95 1e       	st.w	r10[0x4],lr
8000befa:	bf 58       	asr	r8,0x1f
8000befc:	95 08       	st.w	r10[0x0],r8
8000befe:	fe 9f fa 92 	bral	8000b422 <_vfprintf_r+0x116>
8000bf02:	ed b5 00 04 	bld	r5,0x4
8000bf06:	c4 80       	breq	8000bf96 <_vfprintf_r+0xc8a>
8000bf08:	e2 15 00 40 	andl	r5,0x40,COH
8000bf0c:	c4 50       	breq	8000bf96 <_vfprintf_r+0xc8a>
8000bf0e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bf12:	40 3c       	lddsp	r12,sp[0xc]
8000bf14:	58 0c       	cp.w	r12,0
8000bf16:	c1 d0       	breq	8000bf50 <_vfprintf_r+0xc44>
8000bf18:	10 36       	cp.w	r6,r8
8000bf1a:	c0 64       	brge	8000bf26 <_vfprintf_r+0xc1a>
8000bf1c:	fa cb f9 44 	sub	r11,sp,-1724
8000bf20:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bf24:	c1 d8       	rjmp	8000bf5e <_vfprintf_r+0xc52>
8000bf26:	fa c8 f9 50 	sub	r8,sp,-1712
8000bf2a:	1a d8       	st.w	--sp,r8
8000bf2c:	fa c8 fa b8 	sub	r8,sp,-1352
8000bf30:	04 9a       	mov	r10,r2
8000bf32:	1a d8       	st.w	--sp,r8
8000bf34:	fa c8 fb b4 	sub	r8,sp,-1100
8000bf38:	0c 9b       	mov	r11,r6
8000bf3a:	1a d8       	st.w	--sp,r8
8000bf3c:	08 9c       	mov	r12,r4
8000bf3e:	fa c8 f9 40 	sub	r8,sp,-1728
8000bf42:	fa c9 ff b4 	sub	r9,sp,-76
8000bf46:	fe b0 f8 45 	rcall	8000afd0 <get_arg>
8000bf4a:	2f dd       	sub	sp,-12
8000bf4c:	78 0a       	ld.w	r10,r12[0x0]
8000bf4e:	c2 08       	rjmp	8000bf8e <_vfprintf_r+0xc82>
8000bf50:	2f f7       	sub	r7,-1
8000bf52:	10 39       	cp.w	r9,r8
8000bf54:	c0 84       	brge	8000bf64 <_vfprintf_r+0xc58>
8000bf56:	fa ca f9 44 	sub	r10,sp,-1724
8000bf5a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bf5e:	ec fa fd 88 	ld.w	r10,r6[-632]
8000bf62:	c1 68       	rjmp	8000bf8e <_vfprintf_r+0xc82>
8000bf64:	41 09       	lddsp	r9,sp[0x40]
8000bf66:	59 f8       	cp.w	r8,31
8000bf68:	e0 89 00 10 	brgt	8000bf88 <_vfprintf_r+0xc7c>
8000bf6c:	f2 ca ff fc 	sub	r10,r9,-4
8000bf70:	51 0a       	stdsp	sp[0x40],r10
8000bf72:	fa c6 f9 44 	sub	r6,sp,-1724
8000bf76:	72 0a       	ld.w	r10,r9[0x0]
8000bf78:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bf7c:	f3 4a fd 88 	st.w	r9[-632],r10
8000bf80:	2f f8       	sub	r8,-1
8000bf82:	fb 48 06 b4 	st.w	sp[1716],r8
8000bf86:	c0 48       	rjmp	8000bf8e <_vfprintf_r+0xc82>
8000bf88:	72 0a       	ld.w	r10,r9[0x0]
8000bf8a:	2f c9       	sub	r9,-4
8000bf8c:	51 09       	stdsp	sp[0x40],r9
8000bf8e:	40 be       	lddsp	lr,sp[0x2c]
8000bf90:	b4 0e       	st.h	r10[0x0],lr
8000bf92:	fe 9f fa 48 	bral	8000b422 <_vfprintf_r+0x116>
8000bf96:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bf9a:	40 3c       	lddsp	r12,sp[0xc]
8000bf9c:	58 0c       	cp.w	r12,0
8000bf9e:	c1 d0       	breq	8000bfd8 <_vfprintf_r+0xccc>
8000bfa0:	10 36       	cp.w	r6,r8
8000bfa2:	c0 64       	brge	8000bfae <_vfprintf_r+0xca2>
8000bfa4:	fa cb f9 44 	sub	r11,sp,-1724
8000bfa8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bfac:	c1 d8       	rjmp	8000bfe6 <_vfprintf_r+0xcda>
8000bfae:	fa c8 f9 50 	sub	r8,sp,-1712
8000bfb2:	1a d8       	st.w	--sp,r8
8000bfb4:	fa c8 fa b8 	sub	r8,sp,-1352
8000bfb8:	04 9a       	mov	r10,r2
8000bfba:	1a d8       	st.w	--sp,r8
8000bfbc:	fa c8 fb b4 	sub	r8,sp,-1100
8000bfc0:	0c 9b       	mov	r11,r6
8000bfc2:	1a d8       	st.w	--sp,r8
8000bfc4:	08 9c       	mov	r12,r4
8000bfc6:	fa c8 f9 40 	sub	r8,sp,-1728
8000bfca:	fa c9 ff b4 	sub	r9,sp,-76
8000bfce:	fe b0 f8 01 	rcall	8000afd0 <get_arg>
8000bfd2:	2f dd       	sub	sp,-12
8000bfd4:	78 0a       	ld.w	r10,r12[0x0]
8000bfd6:	c2 08       	rjmp	8000c016 <_vfprintf_r+0xd0a>
8000bfd8:	2f f7       	sub	r7,-1
8000bfda:	10 39       	cp.w	r9,r8
8000bfdc:	c0 84       	brge	8000bfec <_vfprintf_r+0xce0>
8000bfde:	fa ca f9 44 	sub	r10,sp,-1724
8000bfe2:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bfe6:	ec fa fd 88 	ld.w	r10,r6[-632]
8000bfea:	c1 68       	rjmp	8000c016 <_vfprintf_r+0xd0a>
8000bfec:	41 09       	lddsp	r9,sp[0x40]
8000bfee:	59 f8       	cp.w	r8,31
8000bff0:	e0 89 00 10 	brgt	8000c010 <_vfprintf_r+0xd04>
8000bff4:	f2 ca ff fc 	sub	r10,r9,-4
8000bff8:	51 0a       	stdsp	sp[0x40],r10
8000bffa:	fa c6 f9 44 	sub	r6,sp,-1724
8000bffe:	72 0a       	ld.w	r10,r9[0x0]
8000c000:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c004:	f3 4a fd 88 	st.w	r9[-632],r10
8000c008:	2f f8       	sub	r8,-1
8000c00a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c00e:	c0 48       	rjmp	8000c016 <_vfprintf_r+0xd0a>
8000c010:	72 0a       	ld.w	r10,r9[0x0]
8000c012:	2f c9       	sub	r9,-4
8000c014:	51 09       	stdsp	sp[0x40],r9
8000c016:	40 be       	lddsp	lr,sp[0x2c]
8000c018:	95 0e       	st.w	r10[0x0],lr
8000c01a:	fe 9f fa 04 	bral	8000b422 <_vfprintf_r+0x116>
8000c01e:	50 a7       	stdsp	sp[0x28],r7
8000c020:	50 80       	stdsp	sp[0x20],r0
8000c022:	0c 97       	mov	r7,r6
8000c024:	04 94       	mov	r4,r2
8000c026:	06 96       	mov	r6,r3
8000c028:	02 92       	mov	r2,r1
8000c02a:	40 93       	lddsp	r3,sp[0x24]
8000c02c:	10 90       	mov	r0,r8
8000c02e:	40 41       	lddsp	r1,sp[0x10]
8000c030:	a5 a5       	sbr	r5,0x4
8000c032:	c0 a8       	rjmp	8000c046 <_vfprintf_r+0xd3a>
8000c034:	50 a7       	stdsp	sp[0x28],r7
8000c036:	50 80       	stdsp	sp[0x20],r0
8000c038:	0c 97       	mov	r7,r6
8000c03a:	04 94       	mov	r4,r2
8000c03c:	06 96       	mov	r6,r3
8000c03e:	02 92       	mov	r2,r1
8000c040:	40 93       	lddsp	r3,sp[0x24]
8000c042:	10 90       	mov	r0,r8
8000c044:	40 41       	lddsp	r1,sp[0x10]
8000c046:	ed b5 00 05 	bld	r5,0x5
8000c04a:	c5 d1       	brne	8000c104 <_vfprintf_r+0xdf8>
8000c04c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c050:	40 3c       	lddsp	r12,sp[0xc]
8000c052:	58 0c       	cp.w	r12,0
8000c054:	c2 60       	breq	8000c0a0 <_vfprintf_r+0xd94>
8000c056:	10 36       	cp.w	r6,r8
8000c058:	c0 a4       	brge	8000c06c <_vfprintf_r+0xd60>
8000c05a:	fa cb f9 44 	sub	r11,sp,-1724
8000c05e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c062:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c066:	fa e9 00 00 	st.d	sp[0],r8
8000c06a:	c1 88       	rjmp	8000c09a <_vfprintf_r+0xd8e>
8000c06c:	fa c8 f9 50 	sub	r8,sp,-1712
8000c070:	1a d8       	st.w	--sp,r8
8000c072:	fa c8 fa b8 	sub	r8,sp,-1352
8000c076:	04 9a       	mov	r10,r2
8000c078:	1a d8       	st.w	--sp,r8
8000c07a:	0c 9b       	mov	r11,r6
8000c07c:	fa c8 fb b4 	sub	r8,sp,-1100
8000c080:	08 9c       	mov	r12,r4
8000c082:	1a d8       	st.w	--sp,r8
8000c084:	fa c8 f9 40 	sub	r8,sp,-1728
8000c088:	fa c9 ff b4 	sub	r9,sp,-76
8000c08c:	fe b0 f7 a2 	rcall	8000afd0 <get_arg>
8000c090:	2f dd       	sub	sp,-12
8000c092:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c096:	fa eb 00 00 	st.d	sp[0],r10
8000c09a:	30 08       	mov	r8,0
8000c09c:	e0 8f 03 de 	bral	8000c858 <_vfprintf_r+0x154c>
8000c0a0:	ee ca ff ff 	sub	r10,r7,-1
8000c0a4:	10 37       	cp.w	r7,r8
8000c0a6:	c0 b4       	brge	8000c0bc <_vfprintf_r+0xdb0>
8000c0a8:	fa c9 f9 44 	sub	r9,sp,-1724
8000c0ac:	14 97       	mov	r7,r10
8000c0ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c0b2:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c0b6:	fa eb 00 00 	st.d	sp[0],r10
8000c0ba:	c1 88       	rjmp	8000c0ea <_vfprintf_r+0xdde>
8000c0bc:	41 09       	lddsp	r9,sp[0x40]
8000c0be:	59 f8       	cp.w	r8,31
8000c0c0:	e0 89 00 18 	brgt	8000c0f0 <_vfprintf_r+0xde4>
8000c0c4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c0c8:	f2 cb ff f8 	sub	r11,r9,-8
8000c0cc:	fa e7 00 00 	st.d	sp[0],r6
8000c0d0:	51 0b       	stdsp	sp[0x40],r11
8000c0d2:	fa c6 f9 44 	sub	r6,sp,-1724
8000c0d6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c0da:	fa e6 00 00 	ld.d	r6,sp[0]
8000c0de:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c0e2:	2f f8       	sub	r8,-1
8000c0e4:	14 97       	mov	r7,r10
8000c0e6:	fb 48 06 b4 	st.w	sp[1716],r8
8000c0ea:	40 38       	lddsp	r8,sp[0xc]
8000c0ec:	e0 8f 03 b6 	bral	8000c858 <_vfprintf_r+0x154c>
8000c0f0:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c0f4:	40 38       	lddsp	r8,sp[0xc]
8000c0f6:	fa e7 00 00 	st.d	sp[0],r6
8000c0fa:	2f 89       	sub	r9,-8
8000c0fc:	14 97       	mov	r7,r10
8000c0fe:	51 09       	stdsp	sp[0x40],r9
8000c100:	e0 8f 03 ac 	bral	8000c858 <_vfprintf_r+0x154c>
8000c104:	ed b5 00 04 	bld	r5,0x4
8000c108:	c1 61       	brne	8000c134 <_vfprintf_r+0xe28>
8000c10a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c10e:	40 3e       	lddsp	lr,sp[0xc]
8000c110:	58 0e       	cp.w	lr,0
8000c112:	c0 80       	breq	8000c122 <_vfprintf_r+0xe16>
8000c114:	10 36       	cp.w	r6,r8
8000c116:	c6 74       	brge	8000c1e4 <_vfprintf_r+0xed8>
8000c118:	fa cc f9 44 	sub	r12,sp,-1724
8000c11c:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c120:	c8 08       	rjmp	8000c220 <_vfprintf_r+0xf14>
8000c122:	ee ca ff ff 	sub	r10,r7,-1
8000c126:	10 37       	cp.w	r7,r8
8000c128:	c7 f4       	brge	8000c226 <_vfprintf_r+0xf1a>
8000c12a:	fa cb f9 44 	sub	r11,sp,-1724
8000c12e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c132:	c7 68       	rjmp	8000c21e <_vfprintf_r+0xf12>
8000c134:	ed b5 00 06 	bld	r5,0x6
8000c138:	c4 a1       	brne	8000c1cc <_vfprintf_r+0xec0>
8000c13a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c13e:	40 3c       	lddsp	r12,sp[0xc]
8000c140:	58 0c       	cp.w	r12,0
8000c142:	c1 d0       	breq	8000c17c <_vfprintf_r+0xe70>
8000c144:	10 36       	cp.w	r6,r8
8000c146:	c0 64       	brge	8000c152 <_vfprintf_r+0xe46>
8000c148:	fa cb f9 44 	sub	r11,sp,-1724
8000c14c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c150:	c1 f8       	rjmp	8000c18e <_vfprintf_r+0xe82>
8000c152:	fa c8 f9 50 	sub	r8,sp,-1712
8000c156:	1a d8       	st.w	--sp,r8
8000c158:	fa c8 fa b8 	sub	r8,sp,-1352
8000c15c:	1a d8       	st.w	--sp,r8
8000c15e:	fa c8 fb b4 	sub	r8,sp,-1100
8000c162:	1a d8       	st.w	--sp,r8
8000c164:	fa c8 f9 40 	sub	r8,sp,-1728
8000c168:	fa c9 ff b4 	sub	r9,sp,-76
8000c16c:	04 9a       	mov	r10,r2
8000c16e:	0c 9b       	mov	r11,r6
8000c170:	08 9c       	mov	r12,r4
8000c172:	fe b0 f7 2f 	rcall	8000afd0 <get_arg>
8000c176:	2f dd       	sub	sp,-12
8000c178:	98 18       	ld.sh	r8,r12[0x2]
8000c17a:	c2 68       	rjmp	8000c1c6 <_vfprintf_r+0xeba>
8000c17c:	ee ca ff ff 	sub	r10,r7,-1
8000c180:	10 37       	cp.w	r7,r8
8000c182:	c0 94       	brge	8000c194 <_vfprintf_r+0xe88>
8000c184:	fa c9 f9 44 	sub	r9,sp,-1724
8000c188:	14 97       	mov	r7,r10
8000c18a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c18e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c192:	c1 a8       	rjmp	8000c1c6 <_vfprintf_r+0xeba>
8000c194:	41 09       	lddsp	r9,sp[0x40]
8000c196:	59 f8       	cp.w	r8,31
8000c198:	e0 89 00 13 	brgt	8000c1be <_vfprintf_r+0xeb2>
8000c19c:	f2 cb ff fc 	sub	r11,r9,-4
8000c1a0:	51 0b       	stdsp	sp[0x40],r11
8000c1a2:	72 09       	ld.w	r9,r9[0x0]
8000c1a4:	fa c6 f9 44 	sub	r6,sp,-1724
8000c1a8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c1ac:	2f f8       	sub	r8,-1
8000c1ae:	f7 49 fd 88 	st.w	r11[-632],r9
8000c1b2:	fb 48 06 b4 	st.w	sp[1716],r8
8000c1b6:	14 97       	mov	r7,r10
8000c1b8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c1bc:	c0 58       	rjmp	8000c1c6 <_vfprintf_r+0xeba>
8000c1be:	92 18       	ld.sh	r8,r9[0x2]
8000c1c0:	14 97       	mov	r7,r10
8000c1c2:	2f c9       	sub	r9,-4
8000c1c4:	51 09       	stdsp	sp[0x40],r9
8000c1c6:	5c 78       	castu.h	r8
8000c1c8:	50 18       	stdsp	sp[0x4],r8
8000c1ca:	c4 68       	rjmp	8000c256 <_vfprintf_r+0xf4a>
8000c1cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c1d0:	40 3c       	lddsp	r12,sp[0xc]
8000c1d2:	58 0c       	cp.w	r12,0
8000c1d4:	c1 d0       	breq	8000c20e <_vfprintf_r+0xf02>
8000c1d6:	10 36       	cp.w	r6,r8
8000c1d8:	c0 64       	brge	8000c1e4 <_vfprintf_r+0xed8>
8000c1da:	fa cb f9 44 	sub	r11,sp,-1724
8000c1de:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c1e2:	c1 f8       	rjmp	8000c220 <_vfprintf_r+0xf14>
8000c1e4:	fa c8 f9 50 	sub	r8,sp,-1712
8000c1e8:	1a d8       	st.w	--sp,r8
8000c1ea:	fa c8 fa b8 	sub	r8,sp,-1352
8000c1ee:	0c 9b       	mov	r11,r6
8000c1f0:	1a d8       	st.w	--sp,r8
8000c1f2:	fa c8 fb b4 	sub	r8,sp,-1100
8000c1f6:	04 9a       	mov	r10,r2
8000c1f8:	1a d8       	st.w	--sp,r8
8000c1fa:	08 9c       	mov	r12,r4
8000c1fc:	fa c8 f9 40 	sub	r8,sp,-1728
8000c200:	fa c9 ff b4 	sub	r9,sp,-76
8000c204:	fe b0 f6 e6 	rcall	8000afd0 <get_arg>
8000c208:	2f dd       	sub	sp,-12
8000c20a:	78 0b       	ld.w	r11,r12[0x0]
8000c20c:	c2 48       	rjmp	8000c254 <_vfprintf_r+0xf48>
8000c20e:	ee ca ff ff 	sub	r10,r7,-1
8000c212:	10 37       	cp.w	r7,r8
8000c214:	c0 94       	brge	8000c226 <_vfprintf_r+0xf1a>
8000c216:	fa c9 f9 44 	sub	r9,sp,-1724
8000c21a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c21e:	14 97       	mov	r7,r10
8000c220:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c224:	c1 88       	rjmp	8000c254 <_vfprintf_r+0xf48>
8000c226:	41 09       	lddsp	r9,sp[0x40]
8000c228:	59 f8       	cp.w	r8,31
8000c22a:	e0 89 00 11 	brgt	8000c24c <_vfprintf_r+0xf40>
8000c22e:	f2 cb ff fc 	sub	r11,r9,-4
8000c232:	51 0b       	stdsp	sp[0x40],r11
8000c234:	fa c6 f9 44 	sub	r6,sp,-1724
8000c238:	72 0b       	ld.w	r11,r9[0x0]
8000c23a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c23e:	f3 4b fd 88 	st.w	r9[-632],r11
8000c242:	2f f8       	sub	r8,-1
8000c244:	14 97       	mov	r7,r10
8000c246:	fb 48 06 b4 	st.w	sp[1716],r8
8000c24a:	c0 58       	rjmp	8000c254 <_vfprintf_r+0xf48>
8000c24c:	72 0b       	ld.w	r11,r9[0x0]
8000c24e:	14 97       	mov	r7,r10
8000c250:	2f c9       	sub	r9,-4
8000c252:	51 09       	stdsp	sp[0x40],r9
8000c254:	50 1b       	stdsp	sp[0x4],r11
8000c256:	30 0e       	mov	lr,0
8000c258:	50 0e       	stdsp	sp[0x0],lr
8000c25a:	1c 98       	mov	r8,lr
8000c25c:	e0 8f 02 fe 	bral	8000c858 <_vfprintf_r+0x154c>
8000c260:	50 a7       	stdsp	sp[0x28],r7
8000c262:	50 80       	stdsp	sp[0x20],r0
8000c264:	0c 97       	mov	r7,r6
8000c266:	04 94       	mov	r4,r2
8000c268:	06 96       	mov	r6,r3
8000c26a:	02 92       	mov	r2,r1
8000c26c:	40 93       	lddsp	r3,sp[0x24]
8000c26e:	40 41       	lddsp	r1,sp[0x10]
8000c270:	0e 99       	mov	r9,r7
8000c272:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c276:	40 3c       	lddsp	r12,sp[0xc]
8000c278:	58 0c       	cp.w	r12,0
8000c27a:	c1 d0       	breq	8000c2b4 <_vfprintf_r+0xfa8>
8000c27c:	10 36       	cp.w	r6,r8
8000c27e:	c0 64       	brge	8000c28a <_vfprintf_r+0xf7e>
8000c280:	fa cb f9 44 	sub	r11,sp,-1724
8000c284:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c288:	c1 d8       	rjmp	8000c2c2 <_vfprintf_r+0xfb6>
8000c28a:	fa c8 f9 50 	sub	r8,sp,-1712
8000c28e:	1a d8       	st.w	--sp,r8
8000c290:	fa c8 fa b8 	sub	r8,sp,-1352
8000c294:	1a d8       	st.w	--sp,r8
8000c296:	fa c8 fb b4 	sub	r8,sp,-1100
8000c29a:	1a d8       	st.w	--sp,r8
8000c29c:	fa c9 ff b4 	sub	r9,sp,-76
8000c2a0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c2a4:	04 9a       	mov	r10,r2
8000c2a6:	0c 9b       	mov	r11,r6
8000c2a8:	08 9c       	mov	r12,r4
8000c2aa:	fe b0 f6 93 	rcall	8000afd0 <get_arg>
8000c2ae:	2f dd       	sub	sp,-12
8000c2b0:	78 09       	ld.w	r9,r12[0x0]
8000c2b2:	c2 18       	rjmp	8000c2f4 <_vfprintf_r+0xfe8>
8000c2b4:	2f f7       	sub	r7,-1
8000c2b6:	10 39       	cp.w	r9,r8
8000c2b8:	c0 84       	brge	8000c2c8 <_vfprintf_r+0xfbc>
8000c2ba:	fa ca f9 44 	sub	r10,sp,-1724
8000c2be:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c2c2:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000c2c6:	c1 78       	rjmp	8000c2f4 <_vfprintf_r+0xfe8>
8000c2c8:	41 09       	lddsp	r9,sp[0x40]
8000c2ca:	59 f8       	cp.w	r8,31
8000c2cc:	e0 89 00 10 	brgt	8000c2ec <_vfprintf_r+0xfe0>
8000c2d0:	f2 ca ff fc 	sub	r10,r9,-4
8000c2d4:	51 0a       	stdsp	sp[0x40],r10
8000c2d6:	fa c6 f9 44 	sub	r6,sp,-1724
8000c2da:	72 09       	ld.w	r9,r9[0x0]
8000c2dc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000c2e0:	f5 49 fd 88 	st.w	r10[-632],r9
8000c2e4:	2f f8       	sub	r8,-1
8000c2e6:	fb 48 06 b4 	st.w	sp[1716],r8
8000c2ea:	c0 58       	rjmp	8000c2f4 <_vfprintf_r+0xfe8>
8000c2ec:	f2 c8 ff fc 	sub	r8,r9,-4
8000c2f0:	51 08       	stdsp	sp[0x40],r8
8000c2f2:	72 09       	ld.w	r9,r9[0x0]
8000c2f4:	33 08       	mov	r8,48
8000c2f6:	fb 68 06 b8 	st.b	sp[1720],r8
8000c2fa:	37 88       	mov	r8,120
8000c2fc:	30 0e       	mov	lr,0
8000c2fe:	fb 68 06 b9 	st.b	sp[1721],r8
8000c302:	4c ac       	lddpc	r12,8000c428 <_vfprintf_r+0x111c>
8000c304:	50 19       	stdsp	sp[0x4],r9
8000c306:	a1 b5       	sbr	r5,0x1
8000c308:	50 0e       	stdsp	sp[0x0],lr
8000c30a:	50 dc       	stdsp	sp[0x34],r12
8000c30c:	30 28       	mov	r8,2
8000c30e:	37 80       	mov	r0,120
8000c310:	e0 8f 02 a4 	bral	8000c858 <_vfprintf_r+0x154c>
8000c314:	50 a7       	stdsp	sp[0x28],r7
8000c316:	50 80       	stdsp	sp[0x20],r0
8000c318:	10 90       	mov	r0,r8
8000c31a:	30 08       	mov	r8,0
8000c31c:	fb 68 06 bb 	st.b	sp[1723],r8
8000c320:	0c 97       	mov	r7,r6
8000c322:	04 94       	mov	r4,r2
8000c324:	06 96       	mov	r6,r3
8000c326:	02 92       	mov	r2,r1
8000c328:	40 93       	lddsp	r3,sp[0x24]
8000c32a:	40 41       	lddsp	r1,sp[0x10]
8000c32c:	0e 99       	mov	r9,r7
8000c32e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c332:	40 3b       	lddsp	r11,sp[0xc]
8000c334:	58 0b       	cp.w	r11,0
8000c336:	c1 d0       	breq	8000c370 <_vfprintf_r+0x1064>
8000c338:	10 36       	cp.w	r6,r8
8000c33a:	c0 64       	brge	8000c346 <_vfprintf_r+0x103a>
8000c33c:	fa ca f9 44 	sub	r10,sp,-1724
8000c340:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c344:	c1 d8       	rjmp	8000c37e <_vfprintf_r+0x1072>
8000c346:	fa c8 f9 50 	sub	r8,sp,-1712
8000c34a:	1a d8       	st.w	--sp,r8
8000c34c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c350:	1a d8       	st.w	--sp,r8
8000c352:	fa c8 fb b4 	sub	r8,sp,-1100
8000c356:	0c 9b       	mov	r11,r6
8000c358:	1a d8       	st.w	--sp,r8
8000c35a:	04 9a       	mov	r10,r2
8000c35c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c360:	fa c9 ff b4 	sub	r9,sp,-76
8000c364:	08 9c       	mov	r12,r4
8000c366:	fe b0 f6 35 	rcall	8000afd0 <get_arg>
8000c36a:	2f dd       	sub	sp,-12
8000c36c:	78 06       	ld.w	r6,r12[0x0]
8000c36e:	c2 08       	rjmp	8000c3ae <_vfprintf_r+0x10a2>
8000c370:	2f f7       	sub	r7,-1
8000c372:	10 39       	cp.w	r9,r8
8000c374:	c0 84       	brge	8000c384 <_vfprintf_r+0x1078>
8000c376:	fa c9 f9 44 	sub	r9,sp,-1724
8000c37a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c37e:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000c382:	c1 68       	rjmp	8000c3ae <_vfprintf_r+0x10a2>
8000c384:	41 09       	lddsp	r9,sp[0x40]
8000c386:	59 f8       	cp.w	r8,31
8000c388:	e0 89 00 10 	brgt	8000c3a8 <_vfprintf_r+0x109c>
8000c38c:	f2 ca ff fc 	sub	r10,r9,-4
8000c390:	51 0a       	stdsp	sp[0x40],r10
8000c392:	72 06       	ld.w	r6,r9[0x0]
8000c394:	fa ce f9 44 	sub	lr,sp,-1724
8000c398:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000c39c:	f3 46 fd 88 	st.w	r9[-632],r6
8000c3a0:	2f f8       	sub	r8,-1
8000c3a2:	fb 48 06 b4 	st.w	sp[1716],r8
8000c3a6:	c0 48       	rjmp	8000c3ae <_vfprintf_r+0x10a2>
8000c3a8:	72 06       	ld.w	r6,r9[0x0]
8000c3aa:	2f c9       	sub	r9,-4
8000c3ac:	51 09       	stdsp	sp[0x40],r9
8000c3ae:	40 2c       	lddsp	r12,sp[0x8]
8000c3b0:	58 0c       	cp.w	r12,0
8000c3b2:	c1 05       	brlt	8000c3d2 <_vfprintf_r+0x10c6>
8000c3b4:	18 9a       	mov	r10,r12
8000c3b6:	30 0b       	mov	r11,0
8000c3b8:	0c 9c       	mov	r12,r6
8000c3ba:	e0 a0 12 43 	rcall	8000e840 <memchr>
8000c3be:	e0 80 02 e0 	breq	8000c97e <_vfprintf_r+0x1672>
8000c3c2:	f8 06 01 02 	sub	r2,r12,r6
8000c3c6:	40 2b       	lddsp	r11,sp[0x8]
8000c3c8:	16 32       	cp.w	r2,r11
8000c3ca:	e0 89 02 da 	brgt	8000c97e <_vfprintf_r+0x1672>
8000c3ce:	e0 8f 02 d5 	bral	8000c978 <_vfprintf_r+0x166c>
8000c3d2:	30 0a       	mov	r10,0
8000c3d4:	0c 9c       	mov	r12,r6
8000c3d6:	50 2a       	stdsp	sp[0x8],r10
8000c3d8:	fe b0 f4 ff 	rcall	8000add6 <strlen>
8000c3dc:	18 92       	mov	r2,r12
8000c3de:	e0 8f 02 d3 	bral	8000c984 <_vfprintf_r+0x1678>
8000c3e2:	50 a7       	stdsp	sp[0x28],r7
8000c3e4:	50 80       	stdsp	sp[0x20],r0
8000c3e6:	0c 97       	mov	r7,r6
8000c3e8:	04 94       	mov	r4,r2
8000c3ea:	06 96       	mov	r6,r3
8000c3ec:	02 92       	mov	r2,r1
8000c3ee:	40 93       	lddsp	r3,sp[0x24]
8000c3f0:	10 90       	mov	r0,r8
8000c3f2:	40 41       	lddsp	r1,sp[0x10]
8000c3f4:	a5 a5       	sbr	r5,0x4
8000c3f6:	c0 a8       	rjmp	8000c40a <_vfprintf_r+0x10fe>
8000c3f8:	50 a7       	stdsp	sp[0x28],r7
8000c3fa:	50 80       	stdsp	sp[0x20],r0
8000c3fc:	0c 97       	mov	r7,r6
8000c3fe:	04 94       	mov	r4,r2
8000c400:	06 96       	mov	r6,r3
8000c402:	02 92       	mov	r2,r1
8000c404:	40 93       	lddsp	r3,sp[0x24]
8000c406:	10 90       	mov	r0,r8
8000c408:	40 41       	lddsp	r1,sp[0x10]
8000c40a:	ed b5 00 05 	bld	r5,0x5
8000c40e:	c5 71       	brne	8000c4bc <_vfprintf_r+0x11b0>
8000c410:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c414:	40 39       	lddsp	r9,sp[0xc]
8000c416:	58 09       	cp.w	r9,0
8000c418:	c2 20       	breq	8000c45c <_vfprintf_r+0x1150>
8000c41a:	10 36       	cp.w	r6,r8
8000c41c:	c0 84       	brge	8000c42c <_vfprintf_r+0x1120>
8000c41e:	fa c8 f9 44 	sub	r8,sp,-1724
8000c422:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000c426:	c2 48       	rjmp	8000c46e <_vfprintf_r+0x1162>
8000c428:	80 01       	ld.sh	r1,r0[0x0]
8000c42a:	9b 70       	st.w	sp[0x1c],r0
8000c42c:	fa c8 f9 50 	sub	r8,sp,-1712
8000c430:	1a d8       	st.w	--sp,r8
8000c432:	fa c8 fa b8 	sub	r8,sp,-1352
8000c436:	1a d8       	st.w	--sp,r8
8000c438:	fa c8 fb b4 	sub	r8,sp,-1100
8000c43c:	1a d8       	st.w	--sp,r8
8000c43e:	fa c8 f9 40 	sub	r8,sp,-1728
8000c442:	fa c9 ff b4 	sub	r9,sp,-76
8000c446:	04 9a       	mov	r10,r2
8000c448:	0c 9b       	mov	r11,r6
8000c44a:	08 9c       	mov	r12,r4
8000c44c:	fe b0 f5 c2 	rcall	8000afd0 <get_arg>
8000c450:	2f dd       	sub	sp,-12
8000c452:	f8 e8 00 00 	ld.d	r8,r12[0]
8000c456:	fa e9 00 00 	st.d	sp[0],r8
8000c45a:	c2 e8       	rjmp	8000c4b6 <_vfprintf_r+0x11aa>
8000c45c:	ee ca ff ff 	sub	r10,r7,-1
8000c460:	10 37       	cp.w	r7,r8
8000c462:	c0 b4       	brge	8000c478 <_vfprintf_r+0x116c>
8000c464:	fa c8 f9 44 	sub	r8,sp,-1724
8000c468:	14 97       	mov	r7,r10
8000c46a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000c46e:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c472:	fa eb 00 00 	st.d	sp[0],r10
8000c476:	c2 08       	rjmp	8000c4b6 <_vfprintf_r+0x11aa>
8000c478:	41 09       	lddsp	r9,sp[0x40]
8000c47a:	59 f8       	cp.w	r8,31
8000c47c:	e0 89 00 16 	brgt	8000c4a8 <_vfprintf_r+0x119c>
8000c480:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c484:	f2 cb ff f8 	sub	r11,r9,-8
8000c488:	fa e7 00 00 	st.d	sp[0],r6
8000c48c:	51 0b       	stdsp	sp[0x40],r11
8000c48e:	fa c6 f9 44 	sub	r6,sp,-1724
8000c492:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c496:	fa e6 00 00 	ld.d	r6,sp[0]
8000c49a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c49e:	2f f8       	sub	r8,-1
8000c4a0:	14 97       	mov	r7,r10
8000c4a2:	fb 48 06 b4 	st.w	sp[1716],r8
8000c4a6:	c0 88       	rjmp	8000c4b6 <_vfprintf_r+0x11aa>
8000c4a8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c4ac:	2f 89       	sub	r9,-8
8000c4ae:	fa e7 00 00 	st.d	sp[0],r6
8000c4b2:	51 09       	stdsp	sp[0x40],r9
8000c4b4:	14 97       	mov	r7,r10
8000c4b6:	30 18       	mov	r8,1
8000c4b8:	e0 8f 01 d0 	bral	8000c858 <_vfprintf_r+0x154c>
8000c4bc:	ed b5 00 04 	bld	r5,0x4
8000c4c0:	c1 61       	brne	8000c4ec <_vfprintf_r+0x11e0>
8000c4c2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c4c6:	40 3e       	lddsp	lr,sp[0xc]
8000c4c8:	58 0e       	cp.w	lr,0
8000c4ca:	c0 80       	breq	8000c4da <_vfprintf_r+0x11ce>
8000c4cc:	10 36       	cp.w	r6,r8
8000c4ce:	c6 74       	brge	8000c59c <_vfprintf_r+0x1290>
8000c4d0:	fa cc f9 44 	sub	r12,sp,-1724
8000c4d4:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c4d8:	c8 08       	rjmp	8000c5d8 <_vfprintf_r+0x12cc>
8000c4da:	ee ca ff ff 	sub	r10,r7,-1
8000c4de:	10 37       	cp.w	r7,r8
8000c4e0:	c7 f4       	brge	8000c5de <_vfprintf_r+0x12d2>
8000c4e2:	fa cb f9 44 	sub	r11,sp,-1724
8000c4e6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c4ea:	c7 68       	rjmp	8000c5d6 <_vfprintf_r+0x12ca>
8000c4ec:	ed b5 00 06 	bld	r5,0x6
8000c4f0:	c4 a1       	brne	8000c584 <_vfprintf_r+0x1278>
8000c4f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c4f6:	40 3c       	lddsp	r12,sp[0xc]
8000c4f8:	58 0c       	cp.w	r12,0
8000c4fa:	c1 d0       	breq	8000c534 <_vfprintf_r+0x1228>
8000c4fc:	10 36       	cp.w	r6,r8
8000c4fe:	c0 64       	brge	8000c50a <_vfprintf_r+0x11fe>
8000c500:	fa cb f9 44 	sub	r11,sp,-1724
8000c504:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c508:	c1 f8       	rjmp	8000c546 <_vfprintf_r+0x123a>
8000c50a:	fa c8 f9 50 	sub	r8,sp,-1712
8000c50e:	1a d8       	st.w	--sp,r8
8000c510:	fa c8 fa b8 	sub	r8,sp,-1352
8000c514:	1a d8       	st.w	--sp,r8
8000c516:	fa c8 fb b4 	sub	r8,sp,-1100
8000c51a:	1a d8       	st.w	--sp,r8
8000c51c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c520:	fa c9 ff b4 	sub	r9,sp,-76
8000c524:	04 9a       	mov	r10,r2
8000c526:	0c 9b       	mov	r11,r6
8000c528:	08 9c       	mov	r12,r4
8000c52a:	fe b0 f5 53 	rcall	8000afd0 <get_arg>
8000c52e:	2f dd       	sub	sp,-12
8000c530:	98 18       	ld.sh	r8,r12[0x2]
8000c532:	c2 68       	rjmp	8000c57e <_vfprintf_r+0x1272>
8000c534:	ee ca ff ff 	sub	r10,r7,-1
8000c538:	10 37       	cp.w	r7,r8
8000c53a:	c0 94       	brge	8000c54c <_vfprintf_r+0x1240>
8000c53c:	fa c9 f9 44 	sub	r9,sp,-1724
8000c540:	14 97       	mov	r7,r10
8000c542:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c546:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c54a:	c1 a8       	rjmp	8000c57e <_vfprintf_r+0x1272>
8000c54c:	41 09       	lddsp	r9,sp[0x40]
8000c54e:	59 f8       	cp.w	r8,31
8000c550:	e0 89 00 13 	brgt	8000c576 <_vfprintf_r+0x126a>
8000c554:	f2 cb ff fc 	sub	r11,r9,-4
8000c558:	51 0b       	stdsp	sp[0x40],r11
8000c55a:	72 09       	ld.w	r9,r9[0x0]
8000c55c:	fa c6 f9 44 	sub	r6,sp,-1724
8000c560:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c564:	2f f8       	sub	r8,-1
8000c566:	f7 49 fd 88 	st.w	r11[-632],r9
8000c56a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c56e:	14 97       	mov	r7,r10
8000c570:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c574:	c0 58       	rjmp	8000c57e <_vfprintf_r+0x1272>
8000c576:	92 18       	ld.sh	r8,r9[0x2]
8000c578:	14 97       	mov	r7,r10
8000c57a:	2f c9       	sub	r9,-4
8000c57c:	51 09       	stdsp	sp[0x40],r9
8000c57e:	5c 78       	castu.h	r8
8000c580:	50 18       	stdsp	sp[0x4],r8
8000c582:	c4 68       	rjmp	8000c60e <_vfprintf_r+0x1302>
8000c584:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c588:	40 3c       	lddsp	r12,sp[0xc]
8000c58a:	58 0c       	cp.w	r12,0
8000c58c:	c1 d0       	breq	8000c5c6 <_vfprintf_r+0x12ba>
8000c58e:	10 36       	cp.w	r6,r8
8000c590:	c0 64       	brge	8000c59c <_vfprintf_r+0x1290>
8000c592:	fa cb f9 44 	sub	r11,sp,-1724
8000c596:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c59a:	c1 f8       	rjmp	8000c5d8 <_vfprintf_r+0x12cc>
8000c59c:	fa c8 f9 50 	sub	r8,sp,-1712
8000c5a0:	1a d8       	st.w	--sp,r8
8000c5a2:	fa c8 fa b8 	sub	r8,sp,-1352
8000c5a6:	0c 9b       	mov	r11,r6
8000c5a8:	1a d8       	st.w	--sp,r8
8000c5aa:	fa c8 fb b4 	sub	r8,sp,-1100
8000c5ae:	04 9a       	mov	r10,r2
8000c5b0:	1a d8       	st.w	--sp,r8
8000c5b2:	08 9c       	mov	r12,r4
8000c5b4:	fa c8 f9 40 	sub	r8,sp,-1728
8000c5b8:	fa c9 ff b4 	sub	r9,sp,-76
8000c5bc:	fe b0 f5 0a 	rcall	8000afd0 <get_arg>
8000c5c0:	2f dd       	sub	sp,-12
8000c5c2:	78 0b       	ld.w	r11,r12[0x0]
8000c5c4:	c2 48       	rjmp	8000c60c <_vfprintf_r+0x1300>
8000c5c6:	ee ca ff ff 	sub	r10,r7,-1
8000c5ca:	10 37       	cp.w	r7,r8
8000c5cc:	c0 94       	brge	8000c5de <_vfprintf_r+0x12d2>
8000c5ce:	fa c9 f9 44 	sub	r9,sp,-1724
8000c5d2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c5d6:	14 97       	mov	r7,r10
8000c5d8:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c5dc:	c1 88       	rjmp	8000c60c <_vfprintf_r+0x1300>
8000c5de:	41 09       	lddsp	r9,sp[0x40]
8000c5e0:	59 f8       	cp.w	r8,31
8000c5e2:	e0 89 00 11 	brgt	8000c604 <_vfprintf_r+0x12f8>
8000c5e6:	f2 cb ff fc 	sub	r11,r9,-4
8000c5ea:	51 0b       	stdsp	sp[0x40],r11
8000c5ec:	fa c6 f9 44 	sub	r6,sp,-1724
8000c5f0:	72 0b       	ld.w	r11,r9[0x0]
8000c5f2:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c5f6:	f3 4b fd 88 	st.w	r9[-632],r11
8000c5fa:	2f f8       	sub	r8,-1
8000c5fc:	14 97       	mov	r7,r10
8000c5fe:	fb 48 06 b4 	st.w	sp[1716],r8
8000c602:	c0 58       	rjmp	8000c60c <_vfprintf_r+0x1300>
8000c604:	72 0b       	ld.w	r11,r9[0x0]
8000c606:	14 97       	mov	r7,r10
8000c608:	2f c9       	sub	r9,-4
8000c60a:	51 09       	stdsp	sp[0x40],r9
8000c60c:	50 1b       	stdsp	sp[0x4],r11
8000c60e:	30 0e       	mov	lr,0
8000c610:	30 18       	mov	r8,1
8000c612:	50 0e       	stdsp	sp[0x0],lr
8000c614:	c2 29       	rjmp	8000c858 <_vfprintf_r+0x154c>
8000c616:	50 a7       	stdsp	sp[0x28],r7
8000c618:	50 80       	stdsp	sp[0x20],r0
8000c61a:	0c 97       	mov	r7,r6
8000c61c:	04 94       	mov	r4,r2
8000c61e:	06 96       	mov	r6,r3
8000c620:	02 92       	mov	r2,r1
8000c622:	4d 3c       	lddpc	r12,8000c76c <_vfprintf_r+0x1460>
8000c624:	40 93       	lddsp	r3,sp[0x24]
8000c626:	10 90       	mov	r0,r8
8000c628:	40 41       	lddsp	r1,sp[0x10]
8000c62a:	50 dc       	stdsp	sp[0x34],r12
8000c62c:	ed b5 00 05 	bld	r5,0x5
8000c630:	c5 51       	brne	8000c6da <_vfprintf_r+0x13ce>
8000c632:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c636:	40 3b       	lddsp	r11,sp[0xc]
8000c638:	58 0b       	cp.w	r11,0
8000c63a:	c2 20       	breq	8000c67e <_vfprintf_r+0x1372>
8000c63c:	10 36       	cp.w	r6,r8
8000c63e:	c0 a4       	brge	8000c652 <_vfprintf_r+0x1346>
8000c640:	fa ca f9 44 	sub	r10,sp,-1724
8000c644:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c648:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c64c:	fa e9 00 00 	st.d	sp[0],r8
8000c650:	cf 38       	rjmp	8000c836 <_vfprintf_r+0x152a>
8000c652:	fa c8 f9 50 	sub	r8,sp,-1712
8000c656:	1a d8       	st.w	--sp,r8
8000c658:	fa c8 fa b8 	sub	r8,sp,-1352
8000c65c:	04 9a       	mov	r10,r2
8000c65e:	1a d8       	st.w	--sp,r8
8000c660:	0c 9b       	mov	r11,r6
8000c662:	fa c8 fb b4 	sub	r8,sp,-1100
8000c666:	08 9c       	mov	r12,r4
8000c668:	1a d8       	st.w	--sp,r8
8000c66a:	fa c8 f9 40 	sub	r8,sp,-1728
8000c66e:	fa c9 ff b4 	sub	r9,sp,-76
8000c672:	fe b0 f4 af 	rcall	8000afd0 <get_arg>
8000c676:	2f dd       	sub	sp,-12
8000c678:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c67c:	c0 c8       	rjmp	8000c694 <_vfprintf_r+0x1388>
8000c67e:	ee ca ff ff 	sub	r10,r7,-1
8000c682:	10 37       	cp.w	r7,r8
8000c684:	c0 b4       	brge	8000c69a <_vfprintf_r+0x138e>
8000c686:	fa c9 f9 44 	sub	r9,sp,-1724
8000c68a:	14 97       	mov	r7,r10
8000c68c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c690:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c694:	fa eb 00 00 	st.d	sp[0],r10
8000c698:	cc f8       	rjmp	8000c836 <_vfprintf_r+0x152a>
8000c69a:	41 09       	lddsp	r9,sp[0x40]
8000c69c:	59 f8       	cp.w	r8,31
8000c69e:	e0 89 00 16 	brgt	8000c6ca <_vfprintf_r+0x13be>
8000c6a2:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c6a6:	f2 cb ff f8 	sub	r11,r9,-8
8000c6aa:	fa e7 00 00 	st.d	sp[0],r6
8000c6ae:	51 0b       	stdsp	sp[0x40],r11
8000c6b0:	fa c6 f9 44 	sub	r6,sp,-1724
8000c6b4:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c6b8:	fa e6 00 00 	ld.d	r6,sp[0]
8000c6bc:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c6c0:	2f f8       	sub	r8,-1
8000c6c2:	14 97       	mov	r7,r10
8000c6c4:	fb 48 06 b4 	st.w	sp[1716],r8
8000c6c8:	cb 78       	rjmp	8000c836 <_vfprintf_r+0x152a>
8000c6ca:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c6ce:	2f 89       	sub	r9,-8
8000c6d0:	fa e7 00 00 	st.d	sp[0],r6
8000c6d4:	51 09       	stdsp	sp[0x40],r9
8000c6d6:	14 97       	mov	r7,r10
8000c6d8:	ca f8       	rjmp	8000c836 <_vfprintf_r+0x152a>
8000c6da:	ed b5 00 04 	bld	r5,0x4
8000c6de:	c1 71       	brne	8000c70c <_vfprintf_r+0x1400>
8000c6e0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c6e4:	40 3e       	lddsp	lr,sp[0xc]
8000c6e6:	58 0e       	cp.w	lr,0
8000c6e8:	c0 80       	breq	8000c6f8 <_vfprintf_r+0x13ec>
8000c6ea:	10 36       	cp.w	r6,r8
8000c6ec:	c6 a4       	brge	8000c7c0 <_vfprintf_r+0x14b4>
8000c6ee:	fa cc f9 44 	sub	r12,sp,-1724
8000c6f2:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c6f6:	c8 38       	rjmp	8000c7fc <_vfprintf_r+0x14f0>
8000c6f8:	ee ca ff ff 	sub	r10,r7,-1
8000c6fc:	10 37       	cp.w	r7,r8
8000c6fe:	e0 84 00 82 	brge	8000c802 <_vfprintf_r+0x14f6>
8000c702:	fa cb f9 44 	sub	r11,sp,-1724
8000c706:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c70a:	c7 88       	rjmp	8000c7fa <_vfprintf_r+0x14ee>
8000c70c:	ed b5 00 06 	bld	r5,0x6
8000c710:	c4 c1       	brne	8000c7a8 <_vfprintf_r+0x149c>
8000c712:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c716:	40 3c       	lddsp	r12,sp[0xc]
8000c718:	58 0c       	cp.w	r12,0
8000c71a:	c1 d0       	breq	8000c754 <_vfprintf_r+0x1448>
8000c71c:	10 36       	cp.w	r6,r8
8000c71e:	c0 64       	brge	8000c72a <_vfprintf_r+0x141e>
8000c720:	fa cb f9 44 	sub	r11,sp,-1724
8000c724:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c728:	c1 f8       	rjmp	8000c766 <_vfprintf_r+0x145a>
8000c72a:	fa c8 f9 50 	sub	r8,sp,-1712
8000c72e:	1a d8       	st.w	--sp,r8
8000c730:	fa c8 fa b8 	sub	r8,sp,-1352
8000c734:	1a d8       	st.w	--sp,r8
8000c736:	fa c8 fb b4 	sub	r8,sp,-1100
8000c73a:	1a d8       	st.w	--sp,r8
8000c73c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c740:	fa c9 ff b4 	sub	r9,sp,-76
8000c744:	04 9a       	mov	r10,r2
8000c746:	0c 9b       	mov	r11,r6
8000c748:	08 9c       	mov	r12,r4
8000c74a:	fe b0 f4 43 	rcall	8000afd0 <get_arg>
8000c74e:	2f dd       	sub	sp,-12
8000c750:	98 18       	ld.sh	r8,r12[0x2]
8000c752:	c2 88       	rjmp	8000c7a2 <_vfprintf_r+0x1496>
8000c754:	ee ca ff ff 	sub	r10,r7,-1
8000c758:	10 37       	cp.w	r7,r8
8000c75a:	c0 b4       	brge	8000c770 <_vfprintf_r+0x1464>
8000c75c:	fa c9 f9 44 	sub	r9,sp,-1724
8000c760:	14 97       	mov	r7,r10
8000c762:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c766:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c76a:	c1 c8       	rjmp	8000c7a2 <_vfprintf_r+0x1496>
8000c76c:	80 01       	ld.sh	r1,r0[0x0]
8000c76e:	9b 70       	st.w	sp[0x1c],r0
8000c770:	41 09       	lddsp	r9,sp[0x40]
8000c772:	59 f8       	cp.w	r8,31
8000c774:	e0 89 00 13 	brgt	8000c79a <_vfprintf_r+0x148e>
8000c778:	f2 cb ff fc 	sub	r11,r9,-4
8000c77c:	51 0b       	stdsp	sp[0x40],r11
8000c77e:	72 09       	ld.w	r9,r9[0x0]
8000c780:	fa c6 f9 44 	sub	r6,sp,-1724
8000c784:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c788:	2f f8       	sub	r8,-1
8000c78a:	f7 49 fd 88 	st.w	r11[-632],r9
8000c78e:	fb 48 06 b4 	st.w	sp[1716],r8
8000c792:	14 97       	mov	r7,r10
8000c794:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c798:	c0 58       	rjmp	8000c7a2 <_vfprintf_r+0x1496>
8000c79a:	92 18       	ld.sh	r8,r9[0x2]
8000c79c:	14 97       	mov	r7,r10
8000c79e:	2f c9       	sub	r9,-4
8000c7a0:	51 09       	stdsp	sp[0x40],r9
8000c7a2:	5c 78       	castu.h	r8
8000c7a4:	50 18       	stdsp	sp[0x4],r8
8000c7a6:	c4 68       	rjmp	8000c832 <_vfprintf_r+0x1526>
8000c7a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c7ac:	40 3c       	lddsp	r12,sp[0xc]
8000c7ae:	58 0c       	cp.w	r12,0
8000c7b0:	c1 d0       	breq	8000c7ea <_vfprintf_r+0x14de>
8000c7b2:	10 36       	cp.w	r6,r8
8000c7b4:	c0 64       	brge	8000c7c0 <_vfprintf_r+0x14b4>
8000c7b6:	fa cb f9 44 	sub	r11,sp,-1724
8000c7ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c7be:	c1 f8       	rjmp	8000c7fc <_vfprintf_r+0x14f0>
8000c7c0:	fa c8 f9 50 	sub	r8,sp,-1712
8000c7c4:	1a d8       	st.w	--sp,r8
8000c7c6:	fa c8 fa b8 	sub	r8,sp,-1352
8000c7ca:	0c 9b       	mov	r11,r6
8000c7cc:	1a d8       	st.w	--sp,r8
8000c7ce:	fa c8 fb b4 	sub	r8,sp,-1100
8000c7d2:	04 9a       	mov	r10,r2
8000c7d4:	1a d8       	st.w	--sp,r8
8000c7d6:	08 9c       	mov	r12,r4
8000c7d8:	fa c8 f9 40 	sub	r8,sp,-1728
8000c7dc:	fa c9 ff b4 	sub	r9,sp,-76
8000c7e0:	fe b0 f3 f8 	rcall	8000afd0 <get_arg>
8000c7e4:	2f dd       	sub	sp,-12
8000c7e6:	78 0b       	ld.w	r11,r12[0x0]
8000c7e8:	c2 48       	rjmp	8000c830 <_vfprintf_r+0x1524>
8000c7ea:	ee ca ff ff 	sub	r10,r7,-1
8000c7ee:	10 37       	cp.w	r7,r8
8000c7f0:	c0 94       	brge	8000c802 <_vfprintf_r+0x14f6>
8000c7f2:	fa c9 f9 44 	sub	r9,sp,-1724
8000c7f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c7fa:	14 97       	mov	r7,r10
8000c7fc:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c800:	c1 88       	rjmp	8000c830 <_vfprintf_r+0x1524>
8000c802:	41 09       	lddsp	r9,sp[0x40]
8000c804:	59 f8       	cp.w	r8,31
8000c806:	e0 89 00 11 	brgt	8000c828 <_vfprintf_r+0x151c>
8000c80a:	f2 cb ff fc 	sub	r11,r9,-4
8000c80e:	51 0b       	stdsp	sp[0x40],r11
8000c810:	fa c6 f9 44 	sub	r6,sp,-1724
8000c814:	72 0b       	ld.w	r11,r9[0x0]
8000c816:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c81a:	f3 4b fd 88 	st.w	r9[-632],r11
8000c81e:	2f f8       	sub	r8,-1
8000c820:	14 97       	mov	r7,r10
8000c822:	fb 48 06 b4 	st.w	sp[1716],r8
8000c826:	c0 58       	rjmp	8000c830 <_vfprintf_r+0x1524>
8000c828:	72 0b       	ld.w	r11,r9[0x0]
8000c82a:	14 97       	mov	r7,r10
8000c82c:	2f c9       	sub	r9,-4
8000c82e:	51 09       	stdsp	sp[0x40],r9
8000c830:	50 1b       	stdsp	sp[0x4],r11
8000c832:	30 0e       	mov	lr,0
8000c834:	50 0e       	stdsp	sp[0x0],lr
8000c836:	40 08       	lddsp	r8,sp[0x0]
8000c838:	40 1c       	lddsp	r12,sp[0x4]
8000c83a:	18 48       	or	r8,r12
8000c83c:	5f 19       	srne	r9
8000c83e:	0a 98       	mov	r8,r5
8000c840:	eb e9 00 09 	and	r9,r5,r9
8000c844:	a1 b8       	sbr	r8,0x1
8000c846:	58 09       	cp.w	r9,0
8000c848:	c0 70       	breq	8000c856 <_vfprintf_r+0x154a>
8000c84a:	10 95       	mov	r5,r8
8000c84c:	fb 60 06 b9 	st.b	sp[1721],r0
8000c850:	33 08       	mov	r8,48
8000c852:	fb 68 06 b8 	st.b	sp[1720],r8
8000c856:	30 28       	mov	r8,2
8000c858:	30 09       	mov	r9,0
8000c85a:	fb 69 06 bb 	st.b	sp[1723],r9
8000c85e:	0a 99       	mov	r9,r5
8000c860:	a7 d9       	cbr	r9,0x7
8000c862:	40 2b       	lddsp	r11,sp[0x8]
8000c864:	40 16       	lddsp	r6,sp[0x4]
8000c866:	58 0b       	cp.w	r11,0
8000c868:	5f 1a       	srne	r10
8000c86a:	f2 05 17 40 	movge	r5,r9
8000c86e:	fa c2 f9 78 	sub	r2,sp,-1672
8000c872:	40 09       	lddsp	r9,sp[0x0]
8000c874:	0c 49       	or	r9,r6
8000c876:	5f 19       	srne	r9
8000c878:	f5 e9 10 09 	or	r9,r10,r9
8000c87c:	c5 c0       	breq	8000c934 <_vfprintf_r+0x1628>
8000c87e:	30 19       	mov	r9,1
8000c880:	f2 08 18 00 	cp.b	r8,r9
8000c884:	c0 60       	breq	8000c890 <_vfprintf_r+0x1584>
8000c886:	30 29       	mov	r9,2
8000c888:	f2 08 18 00 	cp.b	r8,r9
8000c88c:	c0 41       	brne	8000c894 <_vfprintf_r+0x1588>
8000c88e:	c3 c8       	rjmp	8000c906 <_vfprintf_r+0x15fa>
8000c890:	04 96       	mov	r6,r2
8000c892:	c3 08       	rjmp	8000c8f2 <_vfprintf_r+0x15e6>
8000c894:	04 96       	mov	r6,r2
8000c896:	fa e8 00 00 	ld.d	r8,sp[0]
8000c89a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000c89e:	2d 0a       	sub	r10,-48
8000c8a0:	0c fa       	st.b	--r6,r10
8000c8a2:	f0 0b 16 03 	lsr	r11,r8,0x3
8000c8a6:	f2 0c 16 03 	lsr	r12,r9,0x3
8000c8aa:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000c8ae:	18 99       	mov	r9,r12
8000c8b0:	16 98       	mov	r8,r11
8000c8b2:	58 08       	cp.w	r8,0
8000c8b4:	5c 29       	cpc	r9
8000c8b6:	cf 21       	brne	8000c89a <_vfprintf_r+0x158e>
8000c8b8:	fa e9 00 00 	st.d	sp[0],r8
8000c8bc:	ed b5 00 00 	bld	r5,0x0
8000c8c0:	c4 51       	brne	8000c94a <_vfprintf_r+0x163e>
8000c8c2:	33 09       	mov	r9,48
8000c8c4:	f2 0a 18 00 	cp.b	r10,r9
8000c8c8:	c4 10       	breq	8000c94a <_vfprintf_r+0x163e>
8000c8ca:	0c f9       	st.b	--r6,r9
8000c8cc:	c3 f8       	rjmp	8000c94a <_vfprintf_r+0x163e>
8000c8ce:	fa ea 00 00 	ld.d	r10,sp[0]
8000c8d2:	30 a8       	mov	r8,10
8000c8d4:	30 09       	mov	r9,0
8000c8d6:	e0 a0 1a 1b 	rcall	8000fd0c <__avr32_umod64>
8000c8da:	30 a8       	mov	r8,10
8000c8dc:	2d 0a       	sub	r10,-48
8000c8de:	30 09       	mov	r9,0
8000c8e0:	ac 8a       	st.b	r6[0x0],r10
8000c8e2:	fa ea 00 00 	ld.d	r10,sp[0]
8000c8e6:	e0 a0 18 e1 	rcall	8000faa8 <__avr32_udiv64>
8000c8ea:	16 99       	mov	r9,r11
8000c8ec:	14 98       	mov	r8,r10
8000c8ee:	fa e9 00 00 	st.d	sp[0],r8
8000c8f2:	20 16       	sub	r6,1
8000c8f4:	fa ea 00 00 	ld.d	r10,sp[0]
8000c8f8:	58 9a       	cp.w	r10,9
8000c8fa:	5c 2b       	cpc	r11
8000c8fc:	fe 9b ff e9 	brhi	8000c8ce <_vfprintf_r+0x15c2>
8000c900:	1b f8       	ld.ub	r8,sp[0x7]
8000c902:	2d 08       	sub	r8,-48
8000c904:	c2 08       	rjmp	8000c944 <_vfprintf_r+0x1638>
8000c906:	04 96       	mov	r6,r2
8000c908:	fa e8 00 00 	ld.d	r8,sp[0]
8000c90c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000c910:	40 de       	lddsp	lr,sp[0x34]
8000c912:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000c916:	0c fa       	st.b	--r6,r10
8000c918:	f2 0b 16 04 	lsr	r11,r9,0x4
8000c91c:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c920:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000c924:	16 99       	mov	r9,r11
8000c926:	14 98       	mov	r8,r10
8000c928:	58 08       	cp.w	r8,0
8000c92a:	5c 29       	cpc	r9
8000c92c:	cf 01       	brne	8000c90c <_vfprintf_r+0x1600>
8000c92e:	fa e9 00 00 	st.d	sp[0],r8
8000c932:	c0 c8       	rjmp	8000c94a <_vfprintf_r+0x163e>
8000c934:	58 08       	cp.w	r8,0
8000c936:	c0 91       	brne	8000c948 <_vfprintf_r+0x163c>
8000c938:	ed b5 00 00 	bld	r5,0x0
8000c93c:	c0 61       	brne	8000c948 <_vfprintf_r+0x163c>
8000c93e:	fa c6 f9 79 	sub	r6,sp,-1671
8000c942:	33 08       	mov	r8,48
8000c944:	ac 88       	st.b	r6[0x0],r8
8000c946:	c0 28       	rjmp	8000c94a <_vfprintf_r+0x163e>
8000c948:	04 96       	mov	r6,r2
8000c94a:	0c 12       	sub	r2,r6
8000c94c:	c1 c8       	rjmp	8000c984 <_vfprintf_r+0x1678>
8000c94e:	50 a7       	stdsp	sp[0x28],r7
8000c950:	50 80       	stdsp	sp[0x20],r0
8000c952:	40 93       	lddsp	r3,sp[0x24]
8000c954:	0c 97       	mov	r7,r6
8000c956:	10 90       	mov	r0,r8
8000c958:	04 94       	mov	r4,r2
8000c95a:	40 41       	lddsp	r1,sp[0x10]
8000c95c:	58 08       	cp.w	r8,0
8000c95e:	e0 80 04 51 	breq	8000d200 <_vfprintf_r+0x1ef4>
8000c962:	fb 68 06 60 	st.b	sp[1632],r8
8000c966:	30 0c       	mov	r12,0
8000c968:	30 08       	mov	r8,0
8000c96a:	30 12       	mov	r2,1
8000c96c:	fb 68 06 bb 	st.b	sp[1723],r8
8000c970:	50 2c       	stdsp	sp[0x8],r12
8000c972:	fa c6 f9 a0 	sub	r6,sp,-1632
8000c976:	c0 78       	rjmp	8000c984 <_vfprintf_r+0x1678>
8000c978:	30 0b       	mov	r11,0
8000c97a:	50 2b       	stdsp	sp[0x8],r11
8000c97c:	c0 48       	rjmp	8000c984 <_vfprintf_r+0x1678>
8000c97e:	40 22       	lddsp	r2,sp[0x8]
8000c980:	30 0a       	mov	r10,0
8000c982:	50 2a       	stdsp	sp[0x8],r10
8000c984:	40 29       	lddsp	r9,sp[0x8]
8000c986:	e4 09 0c 49 	max	r9,r2,r9
8000c98a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c98e:	50 39       	stdsp	sp[0xc],r9
8000c990:	0a 9e       	mov	lr,r5
8000c992:	30 09       	mov	r9,0
8000c994:	e2 1e 00 02 	andl	lr,0x2,COH
8000c998:	f2 08 18 00 	cp.b	r8,r9
8000c99c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000c9a0:	f7 b8 01 ff 	subne	r8,-1
8000c9a4:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000c9a8:	0a 9b       	mov	r11,r5
8000c9aa:	58 0e       	cp.w	lr,0
8000c9ac:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000c9b0:	f7 bc 01 fe 	subne	r12,-2
8000c9b4:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000c9b8:	e2 1b 00 84 	andl	r11,0x84,COH
8000c9bc:	50 fe       	stdsp	sp[0x3c],lr
8000c9be:	50 9b       	stdsp	sp[0x24],r11
8000c9c0:	c4 51       	brne	8000ca4a <_vfprintf_r+0x173e>
8000c9c2:	40 8a       	lddsp	r10,sp[0x20]
8000c9c4:	40 39       	lddsp	r9,sp[0xc]
8000c9c6:	12 1a       	sub	r10,r9
8000c9c8:	50 4a       	stdsp	sp[0x10],r10
8000c9ca:	58 0a       	cp.w	r10,0
8000c9cc:	e0 89 00 1f 	brgt	8000ca0a <_vfprintf_r+0x16fe>
8000c9d0:	c3 d8       	rjmp	8000ca4a <_vfprintf_r+0x173e>
8000c9d2:	2f 09       	sub	r9,-16
8000c9d4:	2f f8       	sub	r8,-1
8000c9d6:	4c ee       	lddpc	lr,8000cb0c <_vfprintf_r+0x1800>
8000c9d8:	31 0c       	mov	r12,16
8000c9da:	fb 49 06 90 	st.w	sp[1680],r9
8000c9de:	87 0e       	st.w	r3[0x0],lr
8000c9e0:	87 1c       	st.w	r3[0x4],r12
8000c9e2:	fb 48 06 8c 	st.w	sp[1676],r8
8000c9e6:	58 78       	cp.w	r8,7
8000c9e8:	e0 89 00 04 	brgt	8000c9f0 <_vfprintf_r+0x16e4>
8000c9ec:	2f 83       	sub	r3,-8
8000c9ee:	c0 b8       	rjmp	8000ca04 <_vfprintf_r+0x16f8>
8000c9f0:	fa ca f9 78 	sub	r10,sp,-1672
8000c9f4:	02 9b       	mov	r11,r1
8000c9f6:	08 9c       	mov	r12,r4
8000c9f8:	fe b0 f4 7c 	rcall	8000b2f0 <__sprint_r>
8000c9fc:	e0 81 04 13 	brne	8000d222 <_vfprintf_r+0x1f16>
8000ca00:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca04:	40 4b       	lddsp	r11,sp[0x10]
8000ca06:	21 0b       	sub	r11,16
8000ca08:	50 4b       	stdsp	sp[0x10],r11
8000ca0a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ca0e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca12:	4b fa       	lddpc	r10,8000cb0c <_vfprintf_r+0x1800>
8000ca14:	40 4e       	lddsp	lr,sp[0x10]
8000ca16:	59 0e       	cp.w	lr,16
8000ca18:	fe 99 ff dd 	brgt	8000c9d2 <_vfprintf_r+0x16c6>
8000ca1c:	1c 09       	add	r9,lr
8000ca1e:	2f f8       	sub	r8,-1
8000ca20:	87 0a       	st.w	r3[0x0],r10
8000ca22:	fb 49 06 90 	st.w	sp[1680],r9
8000ca26:	87 1e       	st.w	r3[0x4],lr
8000ca28:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca2c:	58 78       	cp.w	r8,7
8000ca2e:	e0 89 00 04 	brgt	8000ca36 <_vfprintf_r+0x172a>
8000ca32:	2f 83       	sub	r3,-8
8000ca34:	c0 b8       	rjmp	8000ca4a <_vfprintf_r+0x173e>
8000ca36:	fa ca f9 78 	sub	r10,sp,-1672
8000ca3a:	02 9b       	mov	r11,r1
8000ca3c:	08 9c       	mov	r12,r4
8000ca3e:	fe b0 f4 59 	rcall	8000b2f0 <__sprint_r>
8000ca42:	e0 81 03 f0 	brne	8000d222 <_vfprintf_r+0x1f16>
8000ca46:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca4a:	30 09       	mov	r9,0
8000ca4c:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000ca50:	f2 08 18 00 	cp.b	r8,r9
8000ca54:	c1 f0       	breq	8000ca92 <_vfprintf_r+0x1786>
8000ca56:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca5a:	fa c9 f9 45 	sub	r9,sp,-1723
8000ca5e:	2f f8       	sub	r8,-1
8000ca60:	87 09       	st.w	r3[0x0],r9
8000ca62:	fb 48 06 90 	st.w	sp[1680],r8
8000ca66:	30 19       	mov	r9,1
8000ca68:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca6c:	87 19       	st.w	r3[0x4],r9
8000ca6e:	2f f8       	sub	r8,-1
8000ca70:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca74:	58 78       	cp.w	r8,7
8000ca76:	e0 89 00 04 	brgt	8000ca7e <_vfprintf_r+0x1772>
8000ca7a:	2f 83       	sub	r3,-8
8000ca7c:	c0 b8       	rjmp	8000ca92 <_vfprintf_r+0x1786>
8000ca7e:	fa ca f9 78 	sub	r10,sp,-1672
8000ca82:	02 9b       	mov	r11,r1
8000ca84:	08 9c       	mov	r12,r4
8000ca86:	fe b0 f4 35 	rcall	8000b2f0 <__sprint_r>
8000ca8a:	e0 81 03 cc 	brne	8000d222 <_vfprintf_r+0x1f16>
8000ca8e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca92:	40 fc       	lddsp	r12,sp[0x3c]
8000ca94:	58 0c       	cp.w	r12,0
8000ca96:	c1 f0       	breq	8000cad4 <_vfprintf_r+0x17c8>
8000ca98:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca9c:	fa c9 f9 48 	sub	r9,sp,-1720
8000caa0:	2f e8       	sub	r8,-2
8000caa2:	87 09       	st.w	r3[0x0],r9
8000caa4:	fb 48 06 90 	st.w	sp[1680],r8
8000caa8:	30 29       	mov	r9,2
8000caaa:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000caae:	87 19       	st.w	r3[0x4],r9
8000cab0:	2f f8       	sub	r8,-1
8000cab2:	fb 48 06 8c 	st.w	sp[1676],r8
8000cab6:	58 78       	cp.w	r8,7
8000cab8:	e0 89 00 04 	brgt	8000cac0 <_vfprintf_r+0x17b4>
8000cabc:	2f 83       	sub	r3,-8
8000cabe:	c0 b8       	rjmp	8000cad4 <_vfprintf_r+0x17c8>
8000cac0:	fa ca f9 78 	sub	r10,sp,-1672
8000cac4:	02 9b       	mov	r11,r1
8000cac6:	08 9c       	mov	r12,r4
8000cac8:	fe b0 f4 14 	rcall	8000b2f0 <__sprint_r>
8000cacc:	e0 81 03 ab 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cad0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cad4:	40 9b       	lddsp	r11,sp[0x24]
8000cad6:	e0 4b 00 80 	cp.w	r11,128
8000cada:	c4 a1       	brne	8000cb6e <_vfprintf_r+0x1862>
8000cadc:	40 8a       	lddsp	r10,sp[0x20]
8000cade:	40 39       	lddsp	r9,sp[0xc]
8000cae0:	12 1a       	sub	r10,r9
8000cae2:	50 4a       	stdsp	sp[0x10],r10
8000cae4:	58 0a       	cp.w	r10,0
8000cae6:	e0 89 00 24 	brgt	8000cb2e <_vfprintf_r+0x1822>
8000caea:	c4 28       	rjmp	8000cb6e <_vfprintf_r+0x1862>
8000caec:	2f 09       	sub	r9,-16
8000caee:	2f f8       	sub	r8,-1
8000caf0:	48 8e       	lddpc	lr,8000cb10 <_vfprintf_r+0x1804>
8000caf2:	31 0c       	mov	r12,16
8000caf4:	fb 49 06 90 	st.w	sp[1680],r9
8000caf8:	87 0e       	st.w	r3[0x0],lr
8000cafa:	87 1c       	st.w	r3[0x4],r12
8000cafc:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb00:	58 78       	cp.w	r8,7
8000cb02:	e0 89 00 09 	brgt	8000cb14 <_vfprintf_r+0x1808>
8000cb06:	2f 83       	sub	r3,-8
8000cb08:	c1 08       	rjmp	8000cb28 <_vfprintf_r+0x181c>
8000cb0a:	d7 03       	nop
8000cb0c:	80 01       	ld.sh	r1,r0[0x0]
8000cb0e:	9b 88       	st.w	sp[0x20],r8
8000cb10:	80 01       	ld.sh	r1,r0[0x0]
8000cb12:	9b 98       	st.w	sp[0x24],r8
8000cb14:	fa ca f9 78 	sub	r10,sp,-1672
8000cb18:	02 9b       	mov	r11,r1
8000cb1a:	08 9c       	mov	r12,r4
8000cb1c:	fe b0 f3 ea 	rcall	8000b2f0 <__sprint_r>
8000cb20:	e0 81 03 81 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cb24:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb28:	40 4b       	lddsp	r11,sp[0x10]
8000cb2a:	21 0b       	sub	r11,16
8000cb2c:	50 4b       	stdsp	sp[0x10],r11
8000cb2e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cb32:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb36:	4c 6a       	lddpc	r10,8000cc4c <_vfprintf_r+0x1940>
8000cb38:	40 4e       	lddsp	lr,sp[0x10]
8000cb3a:	59 0e       	cp.w	lr,16
8000cb3c:	fe 99 ff d8 	brgt	8000caec <_vfprintf_r+0x17e0>
8000cb40:	1c 09       	add	r9,lr
8000cb42:	2f f8       	sub	r8,-1
8000cb44:	87 0a       	st.w	r3[0x0],r10
8000cb46:	fb 49 06 90 	st.w	sp[1680],r9
8000cb4a:	87 1e       	st.w	r3[0x4],lr
8000cb4c:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb50:	58 78       	cp.w	r8,7
8000cb52:	e0 89 00 04 	brgt	8000cb5a <_vfprintf_r+0x184e>
8000cb56:	2f 83       	sub	r3,-8
8000cb58:	c0 b8       	rjmp	8000cb6e <_vfprintf_r+0x1862>
8000cb5a:	fa ca f9 78 	sub	r10,sp,-1672
8000cb5e:	02 9b       	mov	r11,r1
8000cb60:	08 9c       	mov	r12,r4
8000cb62:	fe b0 f3 c7 	rcall	8000b2f0 <__sprint_r>
8000cb66:	e0 81 03 5e 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cb6a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb6e:	40 2c       	lddsp	r12,sp[0x8]
8000cb70:	04 1c       	sub	r12,r2
8000cb72:	50 2c       	stdsp	sp[0x8],r12
8000cb74:	58 0c       	cp.w	r12,0
8000cb76:	e0 89 00 1f 	brgt	8000cbb4 <_vfprintf_r+0x18a8>
8000cb7a:	c3 d8       	rjmp	8000cbf4 <_vfprintf_r+0x18e8>
8000cb7c:	2f 09       	sub	r9,-16
8000cb7e:	2f f8       	sub	r8,-1
8000cb80:	4b 3b       	lddpc	r11,8000cc4c <_vfprintf_r+0x1940>
8000cb82:	31 0a       	mov	r10,16
8000cb84:	fb 49 06 90 	st.w	sp[1680],r9
8000cb88:	87 0b       	st.w	r3[0x0],r11
8000cb8a:	87 1a       	st.w	r3[0x4],r10
8000cb8c:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb90:	58 78       	cp.w	r8,7
8000cb92:	e0 89 00 04 	brgt	8000cb9a <_vfprintf_r+0x188e>
8000cb96:	2f 83       	sub	r3,-8
8000cb98:	c0 b8       	rjmp	8000cbae <_vfprintf_r+0x18a2>
8000cb9a:	fa ca f9 78 	sub	r10,sp,-1672
8000cb9e:	02 9b       	mov	r11,r1
8000cba0:	08 9c       	mov	r12,r4
8000cba2:	fe b0 f3 a7 	rcall	8000b2f0 <__sprint_r>
8000cba6:	e0 81 03 3e 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cbaa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cbae:	40 29       	lddsp	r9,sp[0x8]
8000cbb0:	21 09       	sub	r9,16
8000cbb2:	50 29       	stdsp	sp[0x8],r9
8000cbb4:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cbb8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cbbc:	4a 4a       	lddpc	r10,8000cc4c <_vfprintf_r+0x1940>
8000cbbe:	40 2e       	lddsp	lr,sp[0x8]
8000cbc0:	59 0e       	cp.w	lr,16
8000cbc2:	fe 99 ff dd 	brgt	8000cb7c <_vfprintf_r+0x1870>
8000cbc6:	1c 09       	add	r9,lr
8000cbc8:	2f f8       	sub	r8,-1
8000cbca:	87 0a       	st.w	r3[0x0],r10
8000cbcc:	fb 49 06 90 	st.w	sp[1680],r9
8000cbd0:	87 1e       	st.w	r3[0x4],lr
8000cbd2:	fb 48 06 8c 	st.w	sp[1676],r8
8000cbd6:	58 78       	cp.w	r8,7
8000cbd8:	e0 89 00 04 	brgt	8000cbe0 <_vfprintf_r+0x18d4>
8000cbdc:	2f 83       	sub	r3,-8
8000cbde:	c0 b8       	rjmp	8000cbf4 <_vfprintf_r+0x18e8>
8000cbe0:	fa ca f9 78 	sub	r10,sp,-1672
8000cbe4:	02 9b       	mov	r11,r1
8000cbe6:	08 9c       	mov	r12,r4
8000cbe8:	fe b0 f3 84 	rcall	8000b2f0 <__sprint_r>
8000cbec:	e0 81 03 1b 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cbf0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cbf4:	ed b5 00 08 	bld	r5,0x8
8000cbf8:	c0 b0       	breq	8000cc0e <_vfprintf_r+0x1902>
8000cbfa:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cbfe:	87 12       	st.w	r3[0x4],r2
8000cc00:	87 06       	st.w	r3[0x0],r6
8000cc02:	f0 02 00 02 	add	r2,r8,r2
8000cc06:	fb 42 06 90 	st.w	sp[1680],r2
8000cc0a:	e0 8f 01 d5 	bral	8000cfb4 <_vfprintf_r+0x1ca8>
8000cc0e:	e0 40 00 65 	cp.w	r0,101
8000cc12:	e0 8a 01 d7 	brle	8000cfc0 <_vfprintf_r+0x1cb4>
8000cc16:	30 08       	mov	r8,0
8000cc18:	30 09       	mov	r9,0
8000cc1a:	40 5b       	lddsp	r11,sp[0x14]
8000cc1c:	40 7a       	lddsp	r10,sp[0x1c]
8000cc1e:	e0 a0 15 3e 	rcall	8000f69a <__avr32_f64_cmp_eq>
8000cc22:	c7 a0       	breq	8000cd16 <_vfprintf_r+0x1a0a>
8000cc24:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cc28:	48 a9       	lddpc	r9,8000cc50 <_vfprintf_r+0x1944>
8000cc2a:	2f f8       	sub	r8,-1
8000cc2c:	87 09       	st.w	r3[0x0],r9
8000cc2e:	fb 48 06 90 	st.w	sp[1680],r8
8000cc32:	30 19       	mov	r9,1
8000cc34:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc38:	87 19       	st.w	r3[0x4],r9
8000cc3a:	2f f8       	sub	r8,-1
8000cc3c:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc40:	58 78       	cp.w	r8,7
8000cc42:	e0 89 00 09 	brgt	8000cc54 <_vfprintf_r+0x1948>
8000cc46:	2f 83       	sub	r3,-8
8000cc48:	c1 08       	rjmp	8000cc68 <_vfprintf_r+0x195c>
8000cc4a:	d7 03       	nop
8000cc4c:	80 01       	ld.sh	r1,r0[0x0]
8000cc4e:	9b 98       	st.w	sp[0x24],r8
8000cc50:	80 01       	ld.sh	r1,r0[0x0]
8000cc52:	9b 84       	st.w	sp[0x20],r4
8000cc54:	fa ca f9 78 	sub	r10,sp,-1672
8000cc58:	02 9b       	mov	r11,r1
8000cc5a:	08 9c       	mov	r12,r4
8000cc5c:	fe b0 f3 4a 	rcall	8000b2f0 <__sprint_r>
8000cc60:	e0 81 02 e1 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cc64:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc68:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cc6c:	40 6c       	lddsp	r12,sp[0x18]
8000cc6e:	18 38       	cp.w	r8,r12
8000cc70:	c0 55       	brlt	8000cc7a <_vfprintf_r+0x196e>
8000cc72:	ed b5 00 00 	bld	r5,0x0
8000cc76:	e0 81 02 69 	brne	8000d148 <_vfprintf_r+0x1e3c>
8000cc7a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cc7e:	2f f8       	sub	r8,-1
8000cc80:	40 cb       	lddsp	r11,sp[0x30]
8000cc82:	fb 48 06 90 	st.w	sp[1680],r8
8000cc86:	30 19       	mov	r9,1
8000cc88:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc8c:	87 0b       	st.w	r3[0x0],r11
8000cc8e:	2f f8       	sub	r8,-1
8000cc90:	87 19       	st.w	r3[0x4],r9
8000cc92:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc96:	58 78       	cp.w	r8,7
8000cc98:	e0 89 00 04 	brgt	8000cca0 <_vfprintf_r+0x1994>
8000cc9c:	2f 83       	sub	r3,-8
8000cc9e:	c0 b8       	rjmp	8000ccb4 <_vfprintf_r+0x19a8>
8000cca0:	fa ca f9 78 	sub	r10,sp,-1672
8000cca4:	02 9b       	mov	r11,r1
8000cca6:	08 9c       	mov	r12,r4
8000cca8:	fe b0 f3 24 	rcall	8000b2f0 <__sprint_r>
8000ccac:	e0 81 02 bb 	brne	8000d222 <_vfprintf_r+0x1f16>
8000ccb0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ccb4:	40 66       	lddsp	r6,sp[0x18]
8000ccb6:	20 16       	sub	r6,1
8000ccb8:	58 06       	cp.w	r6,0
8000ccba:	e0 89 00 1d 	brgt	8000ccf4 <_vfprintf_r+0x19e8>
8000ccbe:	e0 8f 02 45 	bral	8000d148 <_vfprintf_r+0x1e3c>
8000ccc2:	2f 09       	sub	r9,-16
8000ccc4:	2f f8       	sub	r8,-1
8000ccc6:	fb 49 06 90 	st.w	sp[1680],r9
8000ccca:	87 02       	st.w	r3[0x0],r2
8000cccc:	87 10       	st.w	r3[0x4],r0
8000ccce:	fb 48 06 8c 	st.w	sp[1676],r8
8000ccd2:	58 78       	cp.w	r8,7
8000ccd4:	e0 89 00 04 	brgt	8000ccdc <_vfprintf_r+0x19d0>
8000ccd8:	2f 83       	sub	r3,-8
8000ccda:	c0 b8       	rjmp	8000ccf0 <_vfprintf_r+0x19e4>
8000ccdc:	fa ca f9 78 	sub	r10,sp,-1672
8000cce0:	02 9b       	mov	r11,r1
8000cce2:	08 9c       	mov	r12,r4
8000cce4:	fe b0 f3 06 	rcall	8000b2f0 <__sprint_r>
8000cce8:	e0 81 02 9d 	brne	8000d222 <_vfprintf_r+0x1f16>
8000ccec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ccf0:	21 06       	sub	r6,16
8000ccf2:	c0 38       	rjmp	8000ccf8 <_vfprintf_r+0x19ec>
8000ccf4:	4d 22       	lddpc	r2,8000ce3c <_vfprintf_r+0x1b30>
8000ccf6:	31 00       	mov	r0,16
8000ccf8:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ccfc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cd00:	4c fa       	lddpc	r10,8000ce3c <_vfprintf_r+0x1b30>
8000cd02:	59 06       	cp.w	r6,16
8000cd04:	fe 99 ff df 	brgt	8000ccc2 <_vfprintf_r+0x19b6>
8000cd08:	0c 09       	add	r9,r6
8000cd0a:	87 0a       	st.w	r3[0x0],r10
8000cd0c:	fb 49 06 90 	st.w	sp[1680],r9
8000cd10:	2f f8       	sub	r8,-1
8000cd12:	87 16       	st.w	r3[0x4],r6
8000cd14:	c5 39       	rjmp	8000cfba <_vfprintf_r+0x1cae>
8000cd16:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000cd1a:	58 0a       	cp.w	r10,0
8000cd1c:	e0 89 00 94 	brgt	8000ce44 <_vfprintf_r+0x1b38>
8000cd20:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cd24:	4c 79       	lddpc	r9,8000ce40 <_vfprintf_r+0x1b34>
8000cd26:	2f f8       	sub	r8,-1
8000cd28:	87 09       	st.w	r3[0x0],r9
8000cd2a:	fb 48 06 90 	st.w	sp[1680],r8
8000cd2e:	30 19       	mov	r9,1
8000cd30:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cd34:	87 19       	st.w	r3[0x4],r9
8000cd36:	2f f8       	sub	r8,-1
8000cd38:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd3c:	58 78       	cp.w	r8,7
8000cd3e:	e0 89 00 04 	brgt	8000cd46 <_vfprintf_r+0x1a3a>
8000cd42:	2f 83       	sub	r3,-8
8000cd44:	c0 b8       	rjmp	8000cd5a <_vfprintf_r+0x1a4e>
8000cd46:	fa ca f9 78 	sub	r10,sp,-1672
8000cd4a:	02 9b       	mov	r11,r1
8000cd4c:	08 9c       	mov	r12,r4
8000cd4e:	fe b0 f2 d1 	rcall	8000b2f0 <__sprint_r>
8000cd52:	e0 81 02 68 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cd56:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd5a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cd5e:	58 08       	cp.w	r8,0
8000cd60:	c0 81       	brne	8000cd70 <_vfprintf_r+0x1a64>
8000cd62:	40 6a       	lddsp	r10,sp[0x18]
8000cd64:	58 0a       	cp.w	r10,0
8000cd66:	c0 51       	brne	8000cd70 <_vfprintf_r+0x1a64>
8000cd68:	ed b5 00 00 	bld	r5,0x0
8000cd6c:	e0 81 01 ee 	brne	8000d148 <_vfprintf_r+0x1e3c>
8000cd70:	40 c9       	lddsp	r9,sp[0x30]
8000cd72:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cd76:	2f f8       	sub	r8,-1
8000cd78:	87 09       	st.w	r3[0x0],r9
8000cd7a:	fb 48 06 90 	st.w	sp[1680],r8
8000cd7e:	30 19       	mov	r9,1
8000cd80:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cd84:	87 19       	st.w	r3[0x4],r9
8000cd86:	2f f8       	sub	r8,-1
8000cd88:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd8c:	58 78       	cp.w	r8,7
8000cd8e:	e0 89 00 04 	brgt	8000cd96 <_vfprintf_r+0x1a8a>
8000cd92:	2f 83       	sub	r3,-8
8000cd94:	c0 b8       	rjmp	8000cdaa <_vfprintf_r+0x1a9e>
8000cd96:	fa ca f9 78 	sub	r10,sp,-1672
8000cd9a:	02 9b       	mov	r11,r1
8000cd9c:	08 9c       	mov	r12,r4
8000cd9e:	fe b0 f2 a9 	rcall	8000b2f0 <__sprint_r>
8000cda2:	e0 81 02 40 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cda6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cdaa:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000cdae:	5c 32       	neg	r2
8000cdb0:	58 02       	cp.w	r2,0
8000cdb2:	e0 89 00 1d 	brgt	8000cdec <_vfprintf_r+0x1ae0>
8000cdb6:	c3 b8       	rjmp	8000ce2c <_vfprintf_r+0x1b20>
8000cdb8:	2f 09       	sub	r9,-16
8000cdba:	2f f8       	sub	r8,-1
8000cdbc:	31 0e       	mov	lr,16
8000cdbe:	fb 49 06 90 	st.w	sp[1680],r9
8000cdc2:	87 00       	st.w	r3[0x0],r0
8000cdc4:	87 1e       	st.w	r3[0x4],lr
8000cdc6:	fb 48 06 8c 	st.w	sp[1676],r8
8000cdca:	58 78       	cp.w	r8,7
8000cdcc:	e0 89 00 04 	brgt	8000cdd4 <_vfprintf_r+0x1ac8>
8000cdd0:	2f 83       	sub	r3,-8
8000cdd2:	c0 b8       	rjmp	8000cde8 <_vfprintf_r+0x1adc>
8000cdd4:	fa ca f9 78 	sub	r10,sp,-1672
8000cdd8:	02 9b       	mov	r11,r1
8000cdda:	08 9c       	mov	r12,r4
8000cddc:	fe b0 f2 8a 	rcall	8000b2f0 <__sprint_r>
8000cde0:	e0 81 02 21 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cde4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cde8:	21 02       	sub	r2,16
8000cdea:	c0 28       	rjmp	8000cdee <_vfprintf_r+0x1ae2>
8000cdec:	49 40       	lddpc	r0,8000ce3c <_vfprintf_r+0x1b30>
8000cdee:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cdf2:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cdf6:	49 2a       	lddpc	r10,8000ce3c <_vfprintf_r+0x1b30>
8000cdf8:	59 02       	cp.w	r2,16
8000cdfa:	fe 99 ff df 	brgt	8000cdb8 <_vfprintf_r+0x1aac>
8000cdfe:	04 09       	add	r9,r2
8000ce00:	2f f8       	sub	r8,-1
8000ce02:	87 0a       	st.w	r3[0x0],r10
8000ce04:	fb 49 06 90 	st.w	sp[1680],r9
8000ce08:	87 12       	st.w	r3[0x4],r2
8000ce0a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce0e:	58 78       	cp.w	r8,7
8000ce10:	e0 89 00 04 	brgt	8000ce18 <_vfprintf_r+0x1b0c>
8000ce14:	2f 83       	sub	r3,-8
8000ce16:	c0 b8       	rjmp	8000ce2c <_vfprintf_r+0x1b20>
8000ce18:	fa ca f9 78 	sub	r10,sp,-1672
8000ce1c:	02 9b       	mov	r11,r1
8000ce1e:	08 9c       	mov	r12,r4
8000ce20:	fe b0 f2 68 	rcall	8000b2f0 <__sprint_r>
8000ce24:	e0 81 01 ff 	brne	8000d222 <_vfprintf_r+0x1f16>
8000ce28:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ce2c:	40 6c       	lddsp	r12,sp[0x18]
8000ce2e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ce32:	87 06       	st.w	r3[0x0],r6
8000ce34:	87 1c       	st.w	r3[0x4],r12
8000ce36:	18 08       	add	r8,r12
8000ce38:	cb c8       	rjmp	8000cfb0 <_vfprintf_r+0x1ca4>
8000ce3a:	d7 03       	nop
8000ce3c:	80 01       	ld.sh	r1,r0[0x0]
8000ce3e:	9b 98       	st.w	sp[0x24],r8
8000ce40:	80 01       	ld.sh	r1,r0[0x0]
8000ce42:	9b 84       	st.w	sp[0x20],r4
8000ce44:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ce48:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ce4c:	40 6b       	lddsp	r11,sp[0x18]
8000ce4e:	16 3a       	cp.w	r10,r11
8000ce50:	c6 d5       	brlt	8000cf2a <_vfprintf_r+0x1c1e>
8000ce52:	16 09       	add	r9,r11
8000ce54:	2f f8       	sub	r8,-1
8000ce56:	87 06       	st.w	r3[0x0],r6
8000ce58:	fb 49 06 90 	st.w	sp[1680],r9
8000ce5c:	87 1b       	st.w	r3[0x4],r11
8000ce5e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce62:	58 78       	cp.w	r8,7
8000ce64:	e0 89 00 04 	brgt	8000ce6c <_vfprintf_r+0x1b60>
8000ce68:	2f 83       	sub	r3,-8
8000ce6a:	c0 b8       	rjmp	8000ce80 <_vfprintf_r+0x1b74>
8000ce6c:	fa ca f9 78 	sub	r10,sp,-1672
8000ce70:	02 9b       	mov	r11,r1
8000ce72:	08 9c       	mov	r12,r4
8000ce74:	fe b0 f2 3e 	rcall	8000b2f0 <__sprint_r>
8000ce78:	e0 81 01 d5 	brne	8000d222 <_vfprintf_r+0x1f16>
8000ce7c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ce80:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000ce84:	40 6a       	lddsp	r10,sp[0x18]
8000ce86:	14 16       	sub	r6,r10
8000ce88:	58 06       	cp.w	r6,0
8000ce8a:	e0 89 00 1c 	brgt	8000cec2 <_vfprintf_r+0x1bb6>
8000ce8e:	c3 b8       	rjmp	8000cf04 <_vfprintf_r+0x1bf8>
8000ce90:	2f 09       	sub	r9,-16
8000ce92:	2f f8       	sub	r8,-1
8000ce94:	fb 49 06 90 	st.w	sp[1680],r9
8000ce98:	87 02       	st.w	r3[0x0],r2
8000ce9a:	87 10       	st.w	r3[0x4],r0
8000ce9c:	fb 48 06 8c 	st.w	sp[1676],r8
8000cea0:	58 78       	cp.w	r8,7
8000cea2:	e0 89 00 04 	brgt	8000ceaa <_vfprintf_r+0x1b9e>
8000cea6:	2f 83       	sub	r3,-8
8000cea8:	c0 b8       	rjmp	8000cebe <_vfprintf_r+0x1bb2>
8000ceaa:	fa ca f9 78 	sub	r10,sp,-1672
8000ceae:	02 9b       	mov	r11,r1
8000ceb0:	08 9c       	mov	r12,r4
8000ceb2:	fe b0 f2 1f 	rcall	8000b2f0 <__sprint_r>
8000ceb6:	e0 81 01 b6 	brne	8000d222 <_vfprintf_r+0x1f16>
8000ceba:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cebe:	21 06       	sub	r6,16
8000cec0:	c0 38       	rjmp	8000cec6 <_vfprintf_r+0x1bba>
8000cec2:	4d c2       	lddpc	r2,8000d030 <_vfprintf_r+0x1d24>
8000cec4:	31 00       	mov	r0,16
8000cec6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ceca:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cece:	4d 9a       	lddpc	r10,8000d030 <_vfprintf_r+0x1d24>
8000ced0:	59 06       	cp.w	r6,16
8000ced2:	fe 99 ff df 	brgt	8000ce90 <_vfprintf_r+0x1b84>
8000ced6:	0c 09       	add	r9,r6
8000ced8:	2f f8       	sub	r8,-1
8000ceda:	87 0a       	st.w	r3[0x0],r10
8000cedc:	fb 49 06 90 	st.w	sp[1680],r9
8000cee0:	87 16       	st.w	r3[0x4],r6
8000cee2:	fb 48 06 8c 	st.w	sp[1676],r8
8000cee6:	58 78       	cp.w	r8,7
8000cee8:	e0 89 00 04 	brgt	8000cef0 <_vfprintf_r+0x1be4>
8000ceec:	2f 83       	sub	r3,-8
8000ceee:	c0 b8       	rjmp	8000cf04 <_vfprintf_r+0x1bf8>
8000cef0:	fa ca f9 78 	sub	r10,sp,-1672
8000cef4:	02 9b       	mov	r11,r1
8000cef6:	08 9c       	mov	r12,r4
8000cef8:	fe b0 f1 fc 	rcall	8000b2f0 <__sprint_r>
8000cefc:	e0 81 01 93 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cf00:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cf04:	ed b5 00 00 	bld	r5,0x0
8000cf08:	e0 81 01 20 	brne	8000d148 <_vfprintf_r+0x1e3c>
8000cf0c:	40 c9       	lddsp	r9,sp[0x30]
8000cf0e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cf12:	2f f8       	sub	r8,-1
8000cf14:	87 09       	st.w	r3[0x0],r9
8000cf16:	fb 48 06 90 	st.w	sp[1680],r8
8000cf1a:	30 19       	mov	r9,1
8000cf1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf20:	87 19       	st.w	r3[0x4],r9
8000cf22:	2f f8       	sub	r8,-1
8000cf24:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf28:	c0 29       	rjmp	8000d12c <_vfprintf_r+0x1e20>
8000cf2a:	14 09       	add	r9,r10
8000cf2c:	2f f8       	sub	r8,-1
8000cf2e:	fb 49 06 90 	st.w	sp[1680],r9
8000cf32:	87 06       	st.w	r3[0x0],r6
8000cf34:	87 1a       	st.w	r3[0x4],r10
8000cf36:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf3a:	58 78       	cp.w	r8,7
8000cf3c:	e0 89 00 04 	brgt	8000cf44 <_vfprintf_r+0x1c38>
8000cf40:	2f 83       	sub	r3,-8
8000cf42:	c0 b8       	rjmp	8000cf58 <_vfprintf_r+0x1c4c>
8000cf44:	fa ca f9 78 	sub	r10,sp,-1672
8000cf48:	02 9b       	mov	r11,r1
8000cf4a:	08 9c       	mov	r12,r4
8000cf4c:	fe b0 f1 d2 	rcall	8000b2f0 <__sprint_r>
8000cf50:	e0 81 01 69 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cf54:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cf58:	40 c8       	lddsp	r8,sp[0x30]
8000cf5a:	87 08       	st.w	r3[0x0],r8
8000cf5c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cf60:	2f f8       	sub	r8,-1
8000cf62:	30 19       	mov	r9,1
8000cf64:	fb 48 06 90 	st.w	sp[1680],r8
8000cf68:	87 19       	st.w	r3[0x4],r9
8000cf6a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf6e:	2f f8       	sub	r8,-1
8000cf70:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf74:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000cf78:	58 78       	cp.w	r8,7
8000cf7a:	e0 89 00 04 	brgt	8000cf82 <_vfprintf_r+0x1c76>
8000cf7e:	2f 83       	sub	r3,-8
8000cf80:	c0 b8       	rjmp	8000cf96 <_vfprintf_r+0x1c8a>
8000cf82:	fa ca f9 78 	sub	r10,sp,-1672
8000cf86:	02 9b       	mov	r11,r1
8000cf88:	08 9c       	mov	r12,r4
8000cf8a:	fe b0 f1 b3 	rcall	8000b2f0 <__sprint_r>
8000cf8e:	e0 81 01 4a 	brne	8000d222 <_vfprintf_r+0x1f16>
8000cf92:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cf96:	04 06       	add	r6,r2
8000cf98:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cf9c:	87 06       	st.w	r3[0x0],r6
8000cf9e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cfa2:	40 66       	lddsp	r6,sp[0x18]
8000cfa4:	40 6e       	lddsp	lr,sp[0x18]
8000cfa6:	10 16       	sub	r6,r8
8000cfa8:	f2 08 01 08 	sub	r8,r9,r8
8000cfac:	87 16       	st.w	r3[0x4],r6
8000cfae:	1c 08       	add	r8,lr
8000cfb0:	fb 48 06 90 	st.w	sp[1680],r8
8000cfb4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cfb8:	2f f8       	sub	r8,-1
8000cfba:	fb 48 06 8c 	st.w	sp[1676],r8
8000cfbe:	cb 78       	rjmp	8000d12c <_vfprintf_r+0x1e20>
8000cfc0:	40 6c       	lddsp	r12,sp[0x18]
8000cfc2:	58 1c       	cp.w	r12,1
8000cfc4:	e0 89 00 06 	brgt	8000cfd0 <_vfprintf_r+0x1cc4>
8000cfc8:	ed b5 00 00 	bld	r5,0x0
8000cfcc:	e0 81 00 85 	brne	8000d0d6 <_vfprintf_r+0x1dca>
8000cfd0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cfd4:	2f f8       	sub	r8,-1
8000cfd6:	30 19       	mov	r9,1
8000cfd8:	fb 48 06 90 	st.w	sp[1680],r8
8000cfdc:	87 06       	st.w	r3[0x0],r6
8000cfde:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cfe2:	87 19       	st.w	r3[0x4],r9
8000cfe4:	2f f8       	sub	r8,-1
8000cfe6:	fb 48 06 8c 	st.w	sp[1676],r8
8000cfea:	58 78       	cp.w	r8,7
8000cfec:	e0 89 00 04 	brgt	8000cff4 <_vfprintf_r+0x1ce8>
8000cff0:	2f 83       	sub	r3,-8
8000cff2:	c0 b8       	rjmp	8000d008 <_vfprintf_r+0x1cfc>
8000cff4:	fa ca f9 78 	sub	r10,sp,-1672
8000cff8:	02 9b       	mov	r11,r1
8000cffa:	08 9c       	mov	r12,r4
8000cffc:	fe b0 f1 7a 	rcall	8000b2f0 <__sprint_r>
8000d000:	e0 81 01 11 	brne	8000d222 <_vfprintf_r+0x1f16>
8000d004:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d008:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d00c:	2f f8       	sub	r8,-1
8000d00e:	40 cb       	lddsp	r11,sp[0x30]
8000d010:	fb 48 06 90 	st.w	sp[1680],r8
8000d014:	30 19       	mov	r9,1
8000d016:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d01a:	87 0b       	st.w	r3[0x0],r11
8000d01c:	2f f8       	sub	r8,-1
8000d01e:	87 19       	st.w	r3[0x4],r9
8000d020:	fb 48 06 8c 	st.w	sp[1676],r8
8000d024:	58 78       	cp.w	r8,7
8000d026:	e0 89 00 07 	brgt	8000d034 <_vfprintf_r+0x1d28>
8000d02a:	2f 83       	sub	r3,-8
8000d02c:	c0 e8       	rjmp	8000d048 <_vfprintf_r+0x1d3c>
8000d02e:	d7 03       	nop
8000d030:	80 01       	ld.sh	r1,r0[0x0]
8000d032:	9b 98       	st.w	sp[0x24],r8
8000d034:	fa ca f9 78 	sub	r10,sp,-1672
8000d038:	02 9b       	mov	r11,r1
8000d03a:	08 9c       	mov	r12,r4
8000d03c:	fe b0 f1 5a 	rcall	8000b2f0 <__sprint_r>
8000d040:	e0 81 00 f1 	brne	8000d222 <_vfprintf_r+0x1f16>
8000d044:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d048:	30 08       	mov	r8,0
8000d04a:	30 09       	mov	r9,0
8000d04c:	40 5b       	lddsp	r11,sp[0x14]
8000d04e:	40 7a       	lddsp	r10,sp[0x1c]
8000d050:	e0 a0 13 25 	rcall	8000f69a <__avr32_f64_cmp_eq>
8000d054:	40 68       	lddsp	r8,sp[0x18]
8000d056:	20 18       	sub	r8,1
8000d058:	58 0c       	cp.w	r12,0
8000d05a:	c0 d1       	brne	8000d074 <_vfprintf_r+0x1d68>
8000d05c:	2f f6       	sub	r6,-1
8000d05e:	87 18       	st.w	r3[0x4],r8
8000d060:	87 06       	st.w	r3[0x0],r6
8000d062:	fa f6 06 90 	ld.w	r6,sp[1680]
8000d066:	10 06       	add	r6,r8
8000d068:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d06c:	fb 46 06 90 	st.w	sp[1680],r6
8000d070:	2f f8       	sub	r8,-1
8000d072:	c2 f8       	rjmp	8000d0d0 <_vfprintf_r+0x1dc4>
8000d074:	10 96       	mov	r6,r8
8000d076:	58 08       	cp.w	r8,0
8000d078:	e0 89 00 1c 	brgt	8000d0b0 <_vfprintf_r+0x1da4>
8000d07c:	c4 98       	rjmp	8000d10e <_vfprintf_r+0x1e02>
8000d07e:	2f 09       	sub	r9,-16
8000d080:	2f f8       	sub	r8,-1
8000d082:	fb 49 06 90 	st.w	sp[1680],r9
8000d086:	87 02       	st.w	r3[0x0],r2
8000d088:	87 10       	st.w	r3[0x4],r0
8000d08a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d08e:	58 78       	cp.w	r8,7
8000d090:	e0 89 00 04 	brgt	8000d098 <_vfprintf_r+0x1d8c>
8000d094:	2f 83       	sub	r3,-8
8000d096:	c0 b8       	rjmp	8000d0ac <_vfprintf_r+0x1da0>
8000d098:	fa ca f9 78 	sub	r10,sp,-1672
8000d09c:	02 9b       	mov	r11,r1
8000d09e:	08 9c       	mov	r12,r4
8000d0a0:	fe b0 f1 28 	rcall	8000b2f0 <__sprint_r>
8000d0a4:	e0 81 00 bf 	brne	8000d222 <_vfprintf_r+0x1f16>
8000d0a8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d0ac:	21 06       	sub	r6,16
8000d0ae:	c0 38       	rjmp	8000d0b4 <_vfprintf_r+0x1da8>
8000d0b0:	4d 22       	lddpc	r2,8000d1f8 <_vfprintf_r+0x1eec>
8000d0b2:	31 00       	mov	r0,16
8000d0b4:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d0b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d0bc:	4c fa       	lddpc	r10,8000d1f8 <_vfprintf_r+0x1eec>
8000d0be:	59 06       	cp.w	r6,16
8000d0c0:	fe 99 ff df 	brgt	8000d07e <_vfprintf_r+0x1d72>
8000d0c4:	0c 09       	add	r9,r6
8000d0c6:	87 0a       	st.w	r3[0x0],r10
8000d0c8:	fb 49 06 90 	st.w	sp[1680],r9
8000d0cc:	2f f8       	sub	r8,-1
8000d0ce:	87 16       	st.w	r3[0x4],r6
8000d0d0:	fb 48 06 8c 	st.w	sp[1676],r8
8000d0d4:	c0 e8       	rjmp	8000d0f0 <_vfprintf_r+0x1de4>
8000d0d6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d0da:	2f f8       	sub	r8,-1
8000d0dc:	30 19       	mov	r9,1
8000d0de:	fb 48 06 90 	st.w	sp[1680],r8
8000d0e2:	87 06       	st.w	r3[0x0],r6
8000d0e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d0e8:	87 19       	st.w	r3[0x4],r9
8000d0ea:	2f f8       	sub	r8,-1
8000d0ec:	fb 48 06 8c 	st.w	sp[1676],r8
8000d0f0:	58 78       	cp.w	r8,7
8000d0f2:	e0 89 00 04 	brgt	8000d0fa <_vfprintf_r+0x1dee>
8000d0f6:	2f 83       	sub	r3,-8
8000d0f8:	c0 b8       	rjmp	8000d10e <_vfprintf_r+0x1e02>
8000d0fa:	fa ca f9 78 	sub	r10,sp,-1672
8000d0fe:	02 9b       	mov	r11,r1
8000d100:	08 9c       	mov	r12,r4
8000d102:	fe b0 f0 f7 	rcall	8000b2f0 <__sprint_r>
8000d106:	e0 81 00 8e 	brne	8000d222 <_vfprintf_r+0x1f16>
8000d10a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d10e:	40 ea       	lddsp	r10,sp[0x38]
8000d110:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d114:	14 08       	add	r8,r10
8000d116:	fa c9 f9 64 	sub	r9,sp,-1692
8000d11a:	fb 48 06 90 	st.w	sp[1680],r8
8000d11e:	87 1a       	st.w	r3[0x4],r10
8000d120:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d124:	87 09       	st.w	r3[0x0],r9
8000d126:	2f f8       	sub	r8,-1
8000d128:	fb 48 06 8c 	st.w	sp[1676],r8
8000d12c:	58 78       	cp.w	r8,7
8000d12e:	e0 89 00 04 	brgt	8000d136 <_vfprintf_r+0x1e2a>
8000d132:	2f 83       	sub	r3,-8
8000d134:	c0 a8       	rjmp	8000d148 <_vfprintf_r+0x1e3c>
8000d136:	fa ca f9 78 	sub	r10,sp,-1672
8000d13a:	02 9b       	mov	r11,r1
8000d13c:	08 9c       	mov	r12,r4
8000d13e:	fe b0 f0 d9 	rcall	8000b2f0 <__sprint_r>
8000d142:	c7 01       	brne	8000d222 <_vfprintf_r+0x1f16>
8000d144:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d148:	e2 15 00 04 	andl	r5,0x4,COH
8000d14c:	c3 d0       	breq	8000d1c6 <_vfprintf_r+0x1eba>
8000d14e:	40 86       	lddsp	r6,sp[0x20]
8000d150:	40 39       	lddsp	r9,sp[0xc]
8000d152:	12 16       	sub	r6,r9
8000d154:	58 06       	cp.w	r6,0
8000d156:	e0 89 00 1a 	brgt	8000d18a <_vfprintf_r+0x1e7e>
8000d15a:	c3 68       	rjmp	8000d1c6 <_vfprintf_r+0x1eba>
8000d15c:	2f 09       	sub	r9,-16
8000d15e:	2f f8       	sub	r8,-1
8000d160:	fb 49 06 90 	st.w	sp[1680],r9
8000d164:	87 05       	st.w	r3[0x0],r5
8000d166:	87 12       	st.w	r3[0x4],r2
8000d168:	fb 48 06 8c 	st.w	sp[1676],r8
8000d16c:	58 78       	cp.w	r8,7
8000d16e:	e0 89 00 04 	brgt	8000d176 <_vfprintf_r+0x1e6a>
8000d172:	2f 83       	sub	r3,-8
8000d174:	c0 98       	rjmp	8000d186 <_vfprintf_r+0x1e7a>
8000d176:	00 9a       	mov	r10,r0
8000d178:	02 9b       	mov	r11,r1
8000d17a:	08 9c       	mov	r12,r4
8000d17c:	fe b0 f0 ba 	rcall	8000b2f0 <__sprint_r>
8000d180:	c5 11       	brne	8000d222 <_vfprintf_r+0x1f16>
8000d182:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d186:	21 06       	sub	r6,16
8000d188:	c0 58       	rjmp	8000d192 <_vfprintf_r+0x1e86>
8000d18a:	49 d5       	lddpc	r5,8000d1fc <_vfprintf_r+0x1ef0>
8000d18c:	31 02       	mov	r2,16
8000d18e:	fa c0 f9 78 	sub	r0,sp,-1672
8000d192:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d196:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d19a:	49 9a       	lddpc	r10,8000d1fc <_vfprintf_r+0x1ef0>
8000d19c:	59 06       	cp.w	r6,16
8000d19e:	fe 99 ff df 	brgt	8000d15c <_vfprintf_r+0x1e50>
8000d1a2:	0c 09       	add	r9,r6
8000d1a4:	2f f8       	sub	r8,-1
8000d1a6:	87 0a       	st.w	r3[0x0],r10
8000d1a8:	87 16       	st.w	r3[0x4],r6
8000d1aa:	fb 49 06 90 	st.w	sp[1680],r9
8000d1ae:	fb 48 06 8c 	st.w	sp[1676],r8
8000d1b2:	58 78       	cp.w	r8,7
8000d1b4:	e0 8a 00 09 	brle	8000d1c6 <_vfprintf_r+0x1eba>
8000d1b8:	fa ca f9 78 	sub	r10,sp,-1672
8000d1bc:	02 9b       	mov	r11,r1
8000d1be:	08 9c       	mov	r12,r4
8000d1c0:	fe b0 f0 98 	rcall	8000b2f0 <__sprint_r>
8000d1c4:	c2 f1       	brne	8000d222 <_vfprintf_r+0x1f16>
8000d1c6:	40 bc       	lddsp	r12,sp[0x2c]
8000d1c8:	40 36       	lddsp	r6,sp[0xc]
8000d1ca:	40 8e       	lddsp	lr,sp[0x20]
8000d1cc:	ec 0e 0c 48 	max	r8,r6,lr
8000d1d0:	10 0c       	add	r12,r8
8000d1d2:	50 bc       	stdsp	sp[0x2c],r12
8000d1d4:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d1d8:	58 08       	cp.w	r8,0
8000d1da:	c0 80       	breq	8000d1ea <_vfprintf_r+0x1ede>
8000d1dc:	fa ca f9 78 	sub	r10,sp,-1672
8000d1e0:	02 9b       	mov	r11,r1
8000d1e2:	08 9c       	mov	r12,r4
8000d1e4:	fe b0 f0 86 	rcall	8000b2f0 <__sprint_r>
8000d1e8:	c1 d1       	brne	8000d222 <_vfprintf_r+0x1f16>
8000d1ea:	30 0b       	mov	r11,0
8000d1ec:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d1f0:	fb 4b 06 8c 	st.w	sp[1676],r11
8000d1f4:	fe 9f f1 17 	bral	8000b422 <_vfprintf_r+0x116>
8000d1f8:	80 01       	ld.sh	r1,r0[0x0]
8000d1fa:	9b 98       	st.w	sp[0x24],r8
8000d1fc:	80 01       	ld.sh	r1,r0[0x0]
8000d1fe:	9b 88       	st.w	sp[0x20],r8
8000d200:	08 95       	mov	r5,r4
8000d202:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d206:	58 08       	cp.w	r8,0
8000d208:	c0 80       	breq	8000d218 <_vfprintf_r+0x1f0c>
8000d20a:	08 9c       	mov	r12,r4
8000d20c:	fa ca f9 78 	sub	r10,sp,-1672
8000d210:	02 9b       	mov	r11,r1
8000d212:	fe b0 f0 6f 	rcall	8000b2f0 <__sprint_r>
8000d216:	c0 61       	brne	8000d222 <_vfprintf_r+0x1f16>
8000d218:	30 08       	mov	r8,0
8000d21a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d21e:	c0 28       	rjmp	8000d222 <_vfprintf_r+0x1f16>
8000d220:	40 41       	lddsp	r1,sp[0x10]
8000d222:	82 68       	ld.sh	r8,r1[0xc]
8000d224:	ed b8 00 06 	bld	r8,0x6
8000d228:	c0 31       	brne	8000d22e <_vfprintf_r+0x1f22>
8000d22a:	3f fa       	mov	r10,-1
8000d22c:	50 ba       	stdsp	sp[0x2c],r10
8000d22e:	40 bc       	lddsp	r12,sp[0x2c]
8000d230:	fe 3d f9 44 	sub	sp,-1724
8000d234:	d8 32       	popm	r0-r7,pc
8000d236:	d7 03       	nop

8000d238 <__swsetup_r>:
8000d238:	d4 21       	pushm	r4-r7,lr
8000d23a:	e0 68 0a 38 	mov	r8,2616
8000d23e:	18 96       	mov	r6,r12
8000d240:	16 97       	mov	r7,r11
8000d242:	70 0c       	ld.w	r12,r8[0x0]
8000d244:	58 0c       	cp.w	r12,0
8000d246:	c0 60       	breq	8000d252 <__swsetup_r+0x1a>
8000d248:	78 68       	ld.w	r8,r12[0x18]
8000d24a:	58 08       	cp.w	r8,0
8000d24c:	c0 31       	brne	8000d252 <__swsetup_r+0x1a>
8000d24e:	e0 a0 07 c7 	rcall	8000e1dc <__sinit>
8000d252:	4a f8       	lddpc	r8,8000d30c <__swsetup_r+0xd4>
8000d254:	10 37       	cp.w	r7,r8
8000d256:	c0 61       	brne	8000d262 <__swsetup_r+0x2a>
8000d258:	e0 68 0a 38 	mov	r8,2616
8000d25c:	70 08       	ld.w	r8,r8[0x0]
8000d25e:	70 07       	ld.w	r7,r8[0x0]
8000d260:	c1 08       	rjmp	8000d280 <__swsetup_r+0x48>
8000d262:	4a c8       	lddpc	r8,8000d310 <__swsetup_r+0xd8>
8000d264:	10 37       	cp.w	r7,r8
8000d266:	c0 61       	brne	8000d272 <__swsetup_r+0x3a>
8000d268:	e0 68 0a 38 	mov	r8,2616
8000d26c:	70 08       	ld.w	r8,r8[0x0]
8000d26e:	70 17       	ld.w	r7,r8[0x4]
8000d270:	c0 88       	rjmp	8000d280 <__swsetup_r+0x48>
8000d272:	4a 98       	lddpc	r8,8000d314 <__swsetup_r+0xdc>
8000d274:	10 37       	cp.w	r7,r8
8000d276:	c0 51       	brne	8000d280 <__swsetup_r+0x48>
8000d278:	e0 68 0a 38 	mov	r8,2616
8000d27c:	70 08       	ld.w	r8,r8[0x0]
8000d27e:	70 27       	ld.w	r7,r8[0x8]
8000d280:	8e 68       	ld.sh	r8,r7[0xc]
8000d282:	ed b8 00 03 	bld	r8,0x3
8000d286:	c1 e0       	breq	8000d2c2 <__swsetup_r+0x8a>
8000d288:	ed b8 00 04 	bld	r8,0x4
8000d28c:	c3 e1       	brne	8000d308 <__swsetup_r+0xd0>
8000d28e:	ed b8 00 02 	bld	r8,0x2
8000d292:	c1 51       	brne	8000d2bc <__swsetup_r+0x84>
8000d294:	6e db       	ld.w	r11,r7[0x34]
8000d296:	58 0b       	cp.w	r11,0
8000d298:	c0 a0       	breq	8000d2ac <__swsetup_r+0x74>
8000d29a:	ee c8 ff bc 	sub	r8,r7,-68
8000d29e:	10 3b       	cp.w	r11,r8
8000d2a0:	c0 40       	breq	8000d2a8 <__swsetup_r+0x70>
8000d2a2:	0c 9c       	mov	r12,r6
8000d2a4:	e0 a0 08 36 	rcall	8000e310 <_free_r>
8000d2a8:	30 08       	mov	r8,0
8000d2aa:	8f d8       	st.w	r7[0x34],r8
8000d2ac:	8e 68       	ld.sh	r8,r7[0xc]
8000d2ae:	e0 18 ff db 	andl	r8,0xffdb
8000d2b2:	ae 68       	st.h	r7[0xc],r8
8000d2b4:	30 08       	mov	r8,0
8000d2b6:	8f 18       	st.w	r7[0x4],r8
8000d2b8:	6e 48       	ld.w	r8,r7[0x10]
8000d2ba:	8f 08       	st.w	r7[0x0],r8
8000d2bc:	8e 68       	ld.sh	r8,r7[0xc]
8000d2be:	a3 b8       	sbr	r8,0x3
8000d2c0:	ae 68       	st.h	r7[0xc],r8
8000d2c2:	6e 48       	ld.w	r8,r7[0x10]
8000d2c4:	58 08       	cp.w	r8,0
8000d2c6:	c0 b1       	brne	8000d2dc <__swsetup_r+0xa4>
8000d2c8:	8e 68       	ld.sh	r8,r7[0xc]
8000d2ca:	e2 18 02 80 	andl	r8,0x280,COH
8000d2ce:	e0 48 02 00 	cp.w	r8,512
8000d2d2:	c0 50       	breq	8000d2dc <__swsetup_r+0xa4>
8000d2d4:	0c 9c       	mov	r12,r6
8000d2d6:	0e 9b       	mov	r11,r7
8000d2d8:	e0 a0 0a 56 	rcall	8000e784 <__smakebuf_r>
8000d2dc:	8e 69       	ld.sh	r9,r7[0xc]
8000d2de:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000d2e2:	c0 70       	breq	8000d2f0 <__swsetup_r+0xb8>
8000d2e4:	30 08       	mov	r8,0
8000d2e6:	8f 28       	st.w	r7[0x8],r8
8000d2e8:	6e 58       	ld.w	r8,r7[0x14]
8000d2ea:	5c 38       	neg	r8
8000d2ec:	8f 68       	st.w	r7[0x18],r8
8000d2ee:	c0 68       	rjmp	8000d2fa <__swsetup_r+0xc2>
8000d2f0:	ed b9 00 01 	bld	r9,0x1
8000d2f4:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000d2f8:	8f 28       	st.w	r7[0x8],r8
8000d2fa:	6e 48       	ld.w	r8,r7[0x10]
8000d2fc:	58 08       	cp.w	r8,0
8000d2fe:	c0 61       	brne	8000d30a <__swsetup_r+0xd2>
8000d300:	8e 68       	ld.sh	r8,r7[0xc]
8000d302:	ed b8 00 07 	bld	r8,0x7
8000d306:	c0 21       	brne	8000d30a <__swsetup_r+0xd2>
8000d308:	dc 2a       	popm	r4-r7,pc,r12=-1
8000d30a:	d8 2a       	popm	r4-r7,pc,r12=0
8000d30c:	80 01       	ld.sh	r1,r0[0x0]
8000d30e:	9c b8       	ld.uh	r8,lr[0x6]
8000d310:	80 01       	ld.sh	r1,r0[0x0]
8000d312:	9c d8       	ld.uh	r8,lr[0xa]
8000d314:	80 01       	ld.sh	r1,r0[0x0]
8000d316:	9c f8       	ld.uh	r8,lr[0xe]

8000d318 <quorem>:
8000d318:	d4 31       	pushm	r0-r7,lr
8000d31a:	20 2d       	sub	sp,8
8000d31c:	18 97       	mov	r7,r12
8000d31e:	78 48       	ld.w	r8,r12[0x10]
8000d320:	76 46       	ld.w	r6,r11[0x10]
8000d322:	0c 38       	cp.w	r8,r6
8000d324:	c0 34       	brge	8000d32a <quorem+0x12>
8000d326:	30 0c       	mov	r12,0
8000d328:	c8 58       	rjmp	8000d432 <quorem+0x11a>
8000d32a:	ec c2 ff fc 	sub	r2,r6,-4
8000d32e:	f6 c3 ff ec 	sub	r3,r11,-20
8000d332:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000d336:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000d33a:	2f f9       	sub	r9,-1
8000d33c:	20 16       	sub	r6,1
8000d33e:	f8 09 0d 08 	divu	r8,r12,r9
8000d342:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000d346:	ee c4 ff ec 	sub	r4,r7,-20
8000d34a:	10 95       	mov	r5,r8
8000d34c:	58 08       	cp.w	r8,0
8000d34e:	c4 10       	breq	8000d3d0 <quorem+0xb8>
8000d350:	30 09       	mov	r9,0
8000d352:	06 9a       	mov	r10,r3
8000d354:	08 98       	mov	r8,r4
8000d356:	12 91       	mov	r1,r9
8000d358:	50 0b       	stdsp	sp[0x0],r11
8000d35a:	70 0e       	ld.w	lr,r8[0x0]
8000d35c:	b1 8e       	lsr	lr,0x10
8000d35e:	50 1e       	stdsp	sp[0x4],lr
8000d360:	15 0e       	ld.w	lr,r10++
8000d362:	fc 00 16 10 	lsr	r0,lr,0x10
8000d366:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d36a:	ea 0e 03 41 	mac	r1,r5,lr
8000d36e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000d372:	b1 81       	lsr	r1,0x10
8000d374:	40 1b       	lddsp	r11,sp[0x4]
8000d376:	ea 00 02 40 	mul	r0,r5,r0
8000d37a:	e2 00 00 00 	add	r0,r1,r0
8000d37e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000d382:	02 1b       	sub	r11,r1
8000d384:	50 1b       	stdsp	sp[0x4],r11
8000d386:	70 0b       	ld.w	r11,r8[0x0]
8000d388:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000d38c:	02 09       	add	r9,r1
8000d38e:	f2 0e 01 0e 	sub	lr,r9,lr
8000d392:	b0 1e       	st.h	r8[0x2],lr
8000d394:	fc 09 14 10 	asr	r9,lr,0x10
8000d398:	40 1e       	lddsp	lr,sp[0x4]
8000d39a:	fc 09 00 09 	add	r9,lr,r9
8000d39e:	b0 09       	st.h	r8[0x0],r9
8000d3a0:	e0 01 16 10 	lsr	r1,r0,0x10
8000d3a4:	2f c8       	sub	r8,-4
8000d3a6:	b1 49       	asr	r9,0x10
8000d3a8:	04 3a       	cp.w	r10,r2
8000d3aa:	fe 98 ff d8 	brls	8000d35a <quorem+0x42>
8000d3ae:	40 0b       	lddsp	r11,sp[0x0]
8000d3b0:	58 0c       	cp.w	r12,0
8000d3b2:	c0 f1       	brne	8000d3d0 <quorem+0xb8>
8000d3b4:	ec c8 ff fb 	sub	r8,r6,-5
8000d3b8:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d3bc:	c0 28       	rjmp	8000d3c0 <quorem+0xa8>
8000d3be:	20 16       	sub	r6,1
8000d3c0:	20 48       	sub	r8,4
8000d3c2:	08 38       	cp.w	r8,r4
8000d3c4:	e0 88 00 05 	brls	8000d3ce <quorem+0xb6>
8000d3c8:	70 09       	ld.w	r9,r8[0x0]
8000d3ca:	58 09       	cp.w	r9,0
8000d3cc:	cf 90       	breq	8000d3be <quorem+0xa6>
8000d3ce:	8f 46       	st.w	r7[0x10],r6
8000d3d0:	0e 9c       	mov	r12,r7
8000d3d2:	e0 a0 0a d8 	rcall	8000e982 <__mcmp>
8000d3d6:	c2 d5       	brlt	8000d430 <quorem+0x118>
8000d3d8:	2f f5       	sub	r5,-1
8000d3da:	08 98       	mov	r8,r4
8000d3dc:	30 09       	mov	r9,0
8000d3de:	07 0b       	ld.w	r11,r3++
8000d3e0:	f6 0a 16 10 	lsr	r10,r11,0x10
8000d3e4:	70 0c       	ld.w	r12,r8[0x0]
8000d3e6:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000d3ea:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d3ee:	14 1e       	sub	lr,r10
8000d3f0:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d3f4:	16 1a       	sub	r10,r11
8000d3f6:	12 0a       	add	r10,r9
8000d3f8:	b0 1a       	st.h	r8[0x2],r10
8000d3fa:	b1 4a       	asr	r10,0x10
8000d3fc:	fc 0a 00 09 	add	r9,lr,r10
8000d400:	b0 09       	st.h	r8[0x0],r9
8000d402:	2f c8       	sub	r8,-4
8000d404:	b1 49       	asr	r9,0x10
8000d406:	04 33       	cp.w	r3,r2
8000d408:	fe 98 ff eb 	brls	8000d3de <quorem+0xc6>
8000d40c:	ec c8 ff fb 	sub	r8,r6,-5
8000d410:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000d414:	58 09       	cp.w	r9,0
8000d416:	c0 d1       	brne	8000d430 <quorem+0x118>
8000d418:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d41c:	c0 28       	rjmp	8000d420 <quorem+0x108>
8000d41e:	20 16       	sub	r6,1
8000d420:	20 48       	sub	r8,4
8000d422:	08 38       	cp.w	r8,r4
8000d424:	e0 88 00 05 	brls	8000d42e <quorem+0x116>
8000d428:	70 09       	ld.w	r9,r8[0x0]
8000d42a:	58 09       	cp.w	r9,0
8000d42c:	cf 90       	breq	8000d41e <quorem+0x106>
8000d42e:	8f 46       	st.w	r7[0x10],r6
8000d430:	0a 9c       	mov	r12,r5
8000d432:	2f ed       	sub	sp,-8
8000d434:	d8 32       	popm	r0-r7,pc
8000d436:	d7 03       	nop

8000d438 <_dtoa_r>:
8000d438:	d4 31       	pushm	r0-r7,lr
8000d43a:	21 ad       	sub	sp,104
8000d43c:	fa c4 ff 74 	sub	r4,sp,-140
8000d440:	18 97       	mov	r7,r12
8000d442:	16 95       	mov	r5,r11
8000d444:	68 2c       	ld.w	r12,r4[0x8]
8000d446:	50 c9       	stdsp	sp[0x30],r9
8000d448:	68 16       	ld.w	r6,r4[0x4]
8000d44a:	68 09       	ld.w	r9,r4[0x0]
8000d44c:	50 e8       	stdsp	sp[0x38],r8
8000d44e:	14 94       	mov	r4,r10
8000d450:	51 2c       	stdsp	sp[0x48],r12
8000d452:	fa e5 00 08 	st.d	sp[8],r4
8000d456:	51 59       	stdsp	sp[0x54],r9
8000d458:	6e 95       	ld.w	r5,r7[0x24]
8000d45a:	58 05       	cp.w	r5,0
8000d45c:	c0 91       	brne	8000d46e <_dtoa_r+0x36>
8000d45e:	31 0c       	mov	r12,16
8000d460:	fe b0 e8 42 	rcall	8000a4e4 <malloc>
8000d464:	99 35       	st.w	r12[0xc],r5
8000d466:	8f 9c       	st.w	r7[0x24],r12
8000d468:	99 15       	st.w	r12[0x4],r5
8000d46a:	99 25       	st.w	r12[0x8],r5
8000d46c:	99 05       	st.w	r12[0x0],r5
8000d46e:	6e 99       	ld.w	r9,r7[0x24]
8000d470:	72 08       	ld.w	r8,r9[0x0]
8000d472:	58 08       	cp.w	r8,0
8000d474:	c0 f0       	breq	8000d492 <_dtoa_r+0x5a>
8000d476:	72 1a       	ld.w	r10,r9[0x4]
8000d478:	91 1a       	st.w	r8[0x4],r10
8000d47a:	30 1a       	mov	r10,1
8000d47c:	72 19       	ld.w	r9,r9[0x4]
8000d47e:	f4 09 09 49 	lsl	r9,r10,r9
8000d482:	10 9b       	mov	r11,r8
8000d484:	91 29       	st.w	r8[0x8],r9
8000d486:	0e 9c       	mov	r12,r7
8000d488:	e0 a0 0a 96 	rcall	8000e9b4 <_Bfree>
8000d48c:	6e 98       	ld.w	r8,r7[0x24]
8000d48e:	30 09       	mov	r9,0
8000d490:	91 09       	st.w	r8[0x0],r9
8000d492:	40 28       	lddsp	r8,sp[0x8]
8000d494:	10 94       	mov	r4,r8
8000d496:	58 08       	cp.w	r8,0
8000d498:	c0 64       	brge	8000d4a4 <_dtoa_r+0x6c>
8000d49a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000d49e:	50 28       	stdsp	sp[0x8],r8
8000d4a0:	30 18       	mov	r8,1
8000d4a2:	c0 28       	rjmp	8000d4a6 <_dtoa_r+0x6e>
8000d4a4:	30 08       	mov	r8,0
8000d4a6:	8d 08       	st.w	r6[0x0],r8
8000d4a8:	fc 1c 7f f0 	movh	r12,0x7ff0
8000d4ac:	40 26       	lddsp	r6,sp[0x8]
8000d4ae:	0c 98       	mov	r8,r6
8000d4b0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000d4b4:	18 38       	cp.w	r8,r12
8000d4b6:	c1 e1       	brne	8000d4f2 <_dtoa_r+0xba>
8000d4b8:	e0 68 27 0f 	mov	r8,9999
8000d4bc:	41 5b       	lddsp	r11,sp[0x54]
8000d4be:	97 08       	st.w	r11[0x0],r8
8000d4c0:	40 3a       	lddsp	r10,sp[0xc]
8000d4c2:	58 0a       	cp.w	r10,0
8000d4c4:	c0 61       	brne	8000d4d0 <_dtoa_r+0x98>
8000d4c6:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000d4ca:	c0 31       	brne	8000d4d0 <_dtoa_r+0x98>
8000d4cc:	4a cc       	lddpc	r12,8000d57c <_dtoa_r+0x144>
8000d4ce:	c0 28       	rjmp	8000d4d2 <_dtoa_r+0x9a>
8000d4d0:	4a cc       	lddpc	r12,8000d580 <_dtoa_r+0x148>
8000d4d2:	41 29       	lddsp	r9,sp[0x48]
8000d4d4:	58 09       	cp.w	r9,0
8000d4d6:	e0 80 05 9e 	breq	8000e012 <_dtoa_r+0xbda>
8000d4da:	f8 c8 ff fd 	sub	r8,r12,-3
8000d4de:	f8 c9 ff f8 	sub	r9,r12,-8
8000d4e2:	11 8b       	ld.ub	r11,r8[0x0]
8000d4e4:	30 0a       	mov	r10,0
8000d4e6:	41 25       	lddsp	r5,sp[0x48]
8000d4e8:	f4 0b 18 00 	cp.b	r11,r10
8000d4ec:	f2 08 17 10 	movne	r8,r9
8000d4f0:	c1 58       	rjmp	8000d51a <_dtoa_r+0xe2>
8000d4f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000d4f6:	30 08       	mov	r8,0
8000d4f8:	fa eb 00 3c 	st.d	sp[60],r10
8000d4fc:	30 09       	mov	r9,0
8000d4fe:	e0 a0 10 ce 	rcall	8000f69a <__avr32_f64_cmp_eq>
8000d502:	c0 f0       	breq	8000d520 <_dtoa_r+0xe8>
8000d504:	30 18       	mov	r8,1
8000d506:	41 5a       	lddsp	r10,sp[0x54]
8000d508:	95 08       	st.w	r10[0x0],r8
8000d50a:	49 fc       	lddpc	r12,8000d584 <_dtoa_r+0x14c>
8000d50c:	41 29       	lddsp	r9,sp[0x48]
8000d50e:	f8 08 00 08 	add	r8,r12,r8
8000d512:	58 09       	cp.w	r9,0
8000d514:	e0 80 05 7f 	breq	8000e012 <_dtoa_r+0xbda>
8000d518:	12 95       	mov	r5,r9
8000d51a:	8b 08       	st.w	r5[0x0],r8
8000d51c:	e0 8f 05 7b 	bral	8000e012 <_dtoa_r+0xbda>
8000d520:	fa c8 ff 9c 	sub	r8,sp,-100
8000d524:	fa c9 ff a0 	sub	r9,sp,-96
8000d528:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d52c:	0e 9c       	mov	r12,r7
8000d52e:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000d532:	e0 a0 0a 93 	rcall	8000ea58 <__d2b>
8000d536:	18 93       	mov	r3,r12
8000d538:	58 05       	cp.w	r5,0
8000d53a:	c0 d0       	breq	8000d554 <_dtoa_r+0x11c>
8000d53c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d540:	30 04       	mov	r4,0
8000d542:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000d546:	ea c5 03 ff 	sub	r5,r5,1023
8000d54a:	10 9b       	mov	r11,r8
8000d54c:	51 74       	stdsp	sp[0x5c],r4
8000d54e:	ea 1b 3f f0 	orh	r11,0x3ff0
8000d552:	c2 a8       	rjmp	8000d5a6 <_dtoa_r+0x16e>
8000d554:	41 88       	lddsp	r8,sp[0x60]
8000d556:	41 9c       	lddsp	r12,sp[0x64]
8000d558:	10 0c       	add	r12,r8
8000d55a:	f8 c5 fb ce 	sub	r5,r12,-1074
8000d55e:	e0 45 00 20 	cp.w	r5,32
8000d562:	e0 8a 00 13 	brle	8000d588 <_dtoa_r+0x150>
8000d566:	f8 cc fb ee 	sub	r12,r12,-1042
8000d56a:	40 3b       	lddsp	r11,sp[0xc]
8000d56c:	ea 08 11 40 	rsub	r8,r5,64
8000d570:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000d574:	ec 08 09 46 	lsl	r6,r6,r8
8000d578:	0c 4c       	or	r12,r6
8000d57a:	c0 c8       	rjmp	8000d592 <_dtoa_r+0x15a>
8000d57c:	80 01       	ld.sh	r1,r0[0x0]
8000d57e:	9c a8       	ld.uh	r8,lr[0x4]
8000d580:	80 01       	ld.sh	r1,r0[0x0]
8000d582:	9c b4       	ld.uh	r4,lr[0x6]
8000d584:	80 01       	ld.sh	r1,r0[0x0]
8000d586:	9b 84       	st.w	sp[0x20],r4
8000d588:	ea 0c 11 20 	rsub	r12,r5,32
8000d58c:	40 3a       	lddsp	r10,sp[0xc]
8000d58e:	f4 0c 09 4c 	lsl	r12,r10,r12
8000d592:	e0 a0 10 10 	rcall	8000f5b2 <__avr32_u32_to_f64>
8000d596:	fc 18 fe 10 	movh	r8,0xfe10
8000d59a:	30 19       	mov	r9,1
8000d59c:	ea c5 04 33 	sub	r5,r5,1075
8000d5a0:	f0 0b 00 0b 	add	r11,r8,r11
8000d5a4:	51 79       	stdsp	sp[0x5c],r9
8000d5a6:	30 08       	mov	r8,0
8000d5a8:	fc 19 3f f8 	movh	r9,0x3ff8
8000d5ac:	e0 a0 0e 98 	rcall	8000f2dc <__avr32_f64_sub>
8000d5b0:	e0 68 43 61 	mov	r8,17249
8000d5b4:	ea 18 63 6f 	orh	r8,0x636f
8000d5b8:	e0 69 87 a7 	mov	r9,34727
8000d5bc:	ea 19 3f d2 	orh	r9,0x3fd2
8000d5c0:	e0 a0 0d a2 	rcall	8000f104 <__avr32_f64_mul>
8000d5c4:	e0 68 c8 b3 	mov	r8,51379
8000d5c8:	ea 18 8b 60 	orh	r8,0x8b60
8000d5cc:	e0 69 8a 28 	mov	r9,35368
8000d5d0:	ea 19 3f c6 	orh	r9,0x3fc6
8000d5d4:	e0 a0 0f 52 	rcall	8000f478 <__avr32_f64_add>
8000d5d8:	0a 9c       	mov	r12,r5
8000d5da:	14 90       	mov	r0,r10
8000d5dc:	16 91       	mov	r1,r11
8000d5de:	e0 a0 0f ee 	rcall	8000f5ba <__avr32_s32_to_f64>
8000d5e2:	e0 68 79 fb 	mov	r8,31227
8000d5e6:	ea 18 50 9f 	orh	r8,0x509f
8000d5ea:	e0 69 44 13 	mov	r9,17427
8000d5ee:	ea 19 3f d3 	orh	r9,0x3fd3
8000d5f2:	e0 a0 0d 89 	rcall	8000f104 <__avr32_f64_mul>
8000d5f6:	14 98       	mov	r8,r10
8000d5f8:	16 99       	mov	r9,r11
8000d5fa:	00 9a       	mov	r10,r0
8000d5fc:	02 9b       	mov	r11,r1
8000d5fe:	e0 a0 0f 3d 	rcall	8000f478 <__avr32_f64_add>
8000d602:	14 90       	mov	r0,r10
8000d604:	16 91       	mov	r1,r11
8000d606:	e0 a0 0f c3 	rcall	8000f58c <__avr32_f64_to_s32>
8000d60a:	30 08       	mov	r8,0
8000d60c:	18 96       	mov	r6,r12
8000d60e:	30 09       	mov	r9,0
8000d610:	00 9a       	mov	r10,r0
8000d612:	02 9b       	mov	r11,r1
8000d614:	e0 a0 10 8a 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000d618:	c0 c0       	breq	8000d630 <_dtoa_r+0x1f8>
8000d61a:	0c 9c       	mov	r12,r6
8000d61c:	e0 a0 0f cf 	rcall	8000f5ba <__avr32_s32_to_f64>
8000d620:	14 98       	mov	r8,r10
8000d622:	16 99       	mov	r9,r11
8000d624:	00 9a       	mov	r10,r0
8000d626:	02 9b       	mov	r11,r1
8000d628:	e0 a0 10 39 	rcall	8000f69a <__avr32_f64_cmp_eq>
8000d62c:	f7 b6 00 01 	subeq	r6,1
8000d630:	59 66       	cp.w	r6,22
8000d632:	e0 88 00 05 	brls	8000d63c <_dtoa_r+0x204>
8000d636:	30 18       	mov	r8,1
8000d638:	51 48       	stdsp	sp[0x50],r8
8000d63a:	c1 28       	rjmp	8000d65e <_dtoa_r+0x226>
8000d63c:	4c 08       	lddpc	r8,8000d73c <_dtoa_r+0x304>
8000d63e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d642:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000d646:	e0 a0 10 71 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000d64a:	f9 b4 00 00 	moveq	r4,0
8000d64e:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000d652:	f7 b6 01 01 	subne	r6,1
8000d656:	f9 bc 01 00 	movne	r12,0
8000d65a:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000d65e:	41 90       	lddsp	r0,sp[0x64]
8000d660:	20 10       	sub	r0,1
8000d662:	0a 10       	sub	r0,r5
8000d664:	c0 46       	brmi	8000d66c <_dtoa_r+0x234>
8000d666:	50 40       	stdsp	sp[0x10],r0
8000d668:	30 00       	mov	r0,0
8000d66a:	c0 48       	rjmp	8000d672 <_dtoa_r+0x23a>
8000d66c:	30 0b       	mov	r11,0
8000d66e:	5c 30       	neg	r0
8000d670:	50 4b       	stdsp	sp[0x10],r11
8000d672:	ec 02 11 00 	rsub	r2,r6,0
8000d676:	58 06       	cp.w	r6,0
8000d678:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000d67c:	f5 d6 e4 0a 	addge	r10,r10,r6
8000d680:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000d684:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000d688:	f9 b2 04 00 	movge	r2,0
8000d68c:	e1 d6 e5 10 	sublt	r0,r0,r6
8000d690:	f9 b9 05 00 	movlt	r9,0
8000d694:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000d698:	40 c8       	lddsp	r8,sp[0x30]
8000d69a:	58 98       	cp.w	r8,9
8000d69c:	e0 8b 00 20 	brhi	8000d6dc <_dtoa_r+0x2a4>
8000d6a0:	58 58       	cp.w	r8,5
8000d6a2:	f9 b4 0a 01 	movle	r4,1
8000d6a6:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000d6aa:	f7 b5 09 04 	subgt	r5,4
8000d6ae:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000d6b2:	f9 b4 09 00 	movgt	r4,0
8000d6b6:	40 cc       	lddsp	r12,sp[0x30]
8000d6b8:	58 3c       	cp.w	r12,3
8000d6ba:	c2 d0       	breq	8000d714 <_dtoa_r+0x2dc>
8000d6bc:	e0 89 00 05 	brgt	8000d6c6 <_dtoa_r+0x28e>
8000d6c0:	58 2c       	cp.w	r12,2
8000d6c2:	c1 01       	brne	8000d6e2 <_dtoa_r+0x2aa>
8000d6c4:	c1 88       	rjmp	8000d6f4 <_dtoa_r+0x2bc>
8000d6c6:	40 cb       	lddsp	r11,sp[0x30]
8000d6c8:	58 4b       	cp.w	r11,4
8000d6ca:	c0 60       	breq	8000d6d6 <_dtoa_r+0x29e>
8000d6cc:	58 5b       	cp.w	r11,5
8000d6ce:	c0 a1       	brne	8000d6e2 <_dtoa_r+0x2aa>
8000d6d0:	30 1a       	mov	r10,1
8000d6d2:	50 da       	stdsp	sp[0x34],r10
8000d6d4:	c2 28       	rjmp	8000d718 <_dtoa_r+0x2e0>
8000d6d6:	30 19       	mov	r9,1
8000d6d8:	50 d9       	stdsp	sp[0x34],r9
8000d6da:	c0 f8       	rjmp	8000d6f8 <_dtoa_r+0x2c0>
8000d6dc:	30 08       	mov	r8,0
8000d6de:	30 14       	mov	r4,1
8000d6e0:	50 c8       	stdsp	sp[0x30],r8
8000d6e2:	3f f5       	mov	r5,-1
8000d6e4:	30 1c       	mov	r12,1
8000d6e6:	30 0b       	mov	r11,0
8000d6e8:	50 95       	stdsp	sp[0x24],r5
8000d6ea:	50 dc       	stdsp	sp[0x34],r12
8000d6ec:	0a 91       	mov	r1,r5
8000d6ee:	31 28       	mov	r8,18
8000d6f0:	50 eb       	stdsp	sp[0x38],r11
8000d6f2:	c2 08       	rjmp	8000d732 <_dtoa_r+0x2fa>
8000d6f4:	30 0a       	mov	r10,0
8000d6f6:	50 da       	stdsp	sp[0x34],r10
8000d6f8:	40 e9       	lddsp	r9,sp[0x38]
8000d6fa:	58 09       	cp.w	r9,0
8000d6fc:	e0 89 00 07 	brgt	8000d70a <_dtoa_r+0x2d2>
8000d700:	30 18       	mov	r8,1
8000d702:	50 98       	stdsp	sp[0x24],r8
8000d704:	10 91       	mov	r1,r8
8000d706:	50 e8       	stdsp	sp[0x38],r8
8000d708:	c1 58       	rjmp	8000d732 <_dtoa_r+0x2fa>
8000d70a:	40 e5       	lddsp	r5,sp[0x38]
8000d70c:	50 95       	stdsp	sp[0x24],r5
8000d70e:	0a 91       	mov	r1,r5
8000d710:	0a 98       	mov	r8,r5
8000d712:	c1 08       	rjmp	8000d732 <_dtoa_r+0x2fa>
8000d714:	30 0c       	mov	r12,0
8000d716:	50 dc       	stdsp	sp[0x34],r12
8000d718:	40 eb       	lddsp	r11,sp[0x38]
8000d71a:	ec 0b 00 0b 	add	r11,r6,r11
8000d71e:	50 9b       	stdsp	sp[0x24],r11
8000d720:	16 98       	mov	r8,r11
8000d722:	2f f8       	sub	r8,-1
8000d724:	58 08       	cp.w	r8,0
8000d726:	e0 89 00 05 	brgt	8000d730 <_dtoa_r+0x2f8>
8000d72a:	10 91       	mov	r1,r8
8000d72c:	30 18       	mov	r8,1
8000d72e:	c0 28       	rjmp	8000d732 <_dtoa_r+0x2fa>
8000d730:	10 91       	mov	r1,r8
8000d732:	30 09       	mov	r9,0
8000d734:	6e 9a       	ld.w	r10,r7[0x24]
8000d736:	95 19       	st.w	r10[0x4],r9
8000d738:	30 49       	mov	r9,4
8000d73a:	c0 78       	rjmp	8000d748 <_dtoa_r+0x310>
8000d73c:	80 01       	ld.sh	r1,r0[0x0]
8000d73e:	9d 68       	st.w	lr[0x18],r8
8000d740:	6a 1a       	ld.w	r10,r5[0x4]
8000d742:	a1 79       	lsl	r9,0x1
8000d744:	2f fa       	sub	r10,-1
8000d746:	8b 1a       	st.w	r5[0x4],r10
8000d748:	6e 95       	ld.w	r5,r7[0x24]
8000d74a:	f2 ca ff ec 	sub	r10,r9,-20
8000d74e:	10 3a       	cp.w	r10,r8
8000d750:	fe 98 ff f8 	brls	8000d740 <_dtoa_r+0x308>
8000d754:	6a 1b       	ld.w	r11,r5[0x4]
8000d756:	0e 9c       	mov	r12,r7
8000d758:	e0 a0 09 48 	rcall	8000e9e8 <_Balloc>
8000d75c:	58 e1       	cp.w	r1,14
8000d75e:	5f 88       	srls	r8
8000d760:	8b 0c       	st.w	r5[0x0],r12
8000d762:	f1 e4 00 04 	and	r4,r8,r4
8000d766:	6e 98       	ld.w	r8,r7[0x24]
8000d768:	70 08       	ld.w	r8,r8[0x0]
8000d76a:	50 88       	stdsp	sp[0x20],r8
8000d76c:	e0 80 01 82 	breq	8000da70 <_dtoa_r+0x638>
8000d770:	58 06       	cp.w	r6,0
8000d772:	e0 8a 00 40 	brle	8000d7f2 <_dtoa_r+0x3ba>
8000d776:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000d77a:	4c b8       	lddpc	r8,8000d8a4 <_dtoa_r+0x46c>
8000d77c:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000d780:	fa e5 00 18 	st.d	sp[24],r4
8000d784:	ec 04 14 04 	asr	r4,r6,0x4
8000d788:	ed b4 00 04 	bld	r4,0x4
8000d78c:	c0 30       	breq	8000d792 <_dtoa_r+0x35a>
8000d78e:	30 25       	mov	r5,2
8000d790:	c0 f8       	rjmp	8000d7ae <_dtoa_r+0x376>
8000d792:	4c 68       	lddpc	r8,8000d8a8 <_dtoa_r+0x470>
8000d794:	f0 e8 00 20 	ld.d	r8,r8[32]
8000d798:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d79c:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000d7a0:	e0 a0 0f f8 	rcall	8000f790 <__avr32_f64_div>
8000d7a4:	30 35       	mov	r5,3
8000d7a6:	14 98       	mov	r8,r10
8000d7a8:	16 99       	mov	r9,r11
8000d7aa:	fa e9 00 08 	st.d	sp[8],r8
8000d7ae:	4b fc       	lddpc	r12,8000d8a8 <_dtoa_r+0x470>
8000d7b0:	50 a3       	stdsp	sp[0x28],r3
8000d7b2:	0c 93       	mov	r3,r6
8000d7b4:	18 96       	mov	r6,r12
8000d7b6:	c0 f8       	rjmp	8000d7d4 <_dtoa_r+0x39c>
8000d7b8:	fa ea 00 18 	ld.d	r10,sp[24]
8000d7bc:	ed b4 00 00 	bld	r4,0x0
8000d7c0:	c0 81       	brne	8000d7d0 <_dtoa_r+0x398>
8000d7c2:	ec e8 00 00 	ld.d	r8,r6[0]
8000d7c6:	2f f5       	sub	r5,-1
8000d7c8:	e0 a0 0c 9e 	rcall	8000f104 <__avr32_f64_mul>
8000d7cc:	fa eb 00 18 	st.d	sp[24],r10
8000d7d0:	a1 54       	asr	r4,0x1
8000d7d2:	2f 86       	sub	r6,-8
8000d7d4:	58 04       	cp.w	r4,0
8000d7d6:	cf 11       	brne	8000d7b8 <_dtoa_r+0x380>
8000d7d8:	fa e8 00 18 	ld.d	r8,sp[24]
8000d7dc:	fa ea 00 08 	ld.d	r10,sp[8]
8000d7e0:	06 96       	mov	r6,r3
8000d7e2:	e0 a0 0f d7 	rcall	8000f790 <__avr32_f64_div>
8000d7e6:	40 a3       	lddsp	r3,sp[0x28]
8000d7e8:	14 98       	mov	r8,r10
8000d7ea:	16 99       	mov	r9,r11
8000d7ec:	fa e9 00 08 	st.d	sp[8],r8
8000d7f0:	c2 d8       	rjmp	8000d84a <_dtoa_r+0x412>
8000d7f2:	ec 08 11 00 	rsub	r8,r6,0
8000d7f6:	c0 31       	brne	8000d7fc <_dtoa_r+0x3c4>
8000d7f8:	30 25       	mov	r5,2
8000d7fa:	c2 88       	rjmp	8000d84a <_dtoa_r+0x412>
8000d7fc:	4a bc       	lddpc	r12,8000d8a8 <_dtoa_r+0x470>
8000d7fe:	f0 04 14 04 	asr	r4,r8,0x4
8000d802:	50 1c       	stdsp	sp[0x4],r12
8000d804:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000d808:	4a 79       	lddpc	r9,8000d8a4 <_dtoa_r+0x46c>
8000d80a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d80e:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d812:	e0 a0 0c 79 	rcall	8000f104 <__avr32_f64_mul>
8000d816:	40 1c       	lddsp	r12,sp[0x4]
8000d818:	50 63       	stdsp	sp[0x18],r3
8000d81a:	30 25       	mov	r5,2
8000d81c:	0c 93       	mov	r3,r6
8000d81e:	fa eb 00 08 	st.d	sp[8],r10
8000d822:	18 96       	mov	r6,r12
8000d824:	c0 f8       	rjmp	8000d842 <_dtoa_r+0x40a>
8000d826:	fa ea 00 08 	ld.d	r10,sp[8]
8000d82a:	ed b4 00 00 	bld	r4,0x0
8000d82e:	c0 81       	brne	8000d83e <_dtoa_r+0x406>
8000d830:	ec e8 00 00 	ld.d	r8,r6[0]
8000d834:	2f f5       	sub	r5,-1
8000d836:	e0 a0 0c 67 	rcall	8000f104 <__avr32_f64_mul>
8000d83a:	fa eb 00 08 	st.d	sp[8],r10
8000d83e:	a1 54       	asr	r4,0x1
8000d840:	2f 86       	sub	r6,-8
8000d842:	58 04       	cp.w	r4,0
8000d844:	cf 11       	brne	8000d826 <_dtoa_r+0x3ee>
8000d846:	06 96       	mov	r6,r3
8000d848:	40 63       	lddsp	r3,sp[0x18]
8000d84a:	41 4a       	lddsp	r10,sp[0x50]
8000d84c:	58 0a       	cp.w	r10,0
8000d84e:	c2 f0       	breq	8000d8ac <_dtoa_r+0x474>
8000d850:	fa e8 00 08 	ld.d	r8,sp[8]
8000d854:	58 01       	cp.w	r1,0
8000d856:	5f 94       	srgt	r4
8000d858:	fa e9 00 18 	st.d	sp[24],r8
8000d85c:	30 08       	mov	r8,0
8000d85e:	fc 19 3f f0 	movh	r9,0x3ff0
8000d862:	fa ea 00 18 	ld.d	r10,sp[24]
8000d866:	e0 a0 0f 61 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000d86a:	f9 bc 00 00 	moveq	r12,0
8000d86e:	f9 bc 01 01 	movne	r12,1
8000d872:	e9 ec 00 0c 	and	r12,r4,r12
8000d876:	c1 b0       	breq	8000d8ac <_dtoa_r+0x474>
8000d878:	40 98       	lddsp	r8,sp[0x24]
8000d87a:	58 08       	cp.w	r8,0
8000d87c:	e0 8a 00 f6 	brle	8000da68 <_dtoa_r+0x630>
8000d880:	30 08       	mov	r8,0
8000d882:	fc 19 40 24 	movh	r9,0x4024
8000d886:	ec c4 00 01 	sub	r4,r6,1
8000d88a:	fa ea 00 18 	ld.d	r10,sp[24]
8000d88e:	2f f5       	sub	r5,-1
8000d890:	50 64       	stdsp	sp[0x18],r4
8000d892:	e0 a0 0c 39 	rcall	8000f104 <__avr32_f64_mul>
8000d896:	40 94       	lddsp	r4,sp[0x24]
8000d898:	14 98       	mov	r8,r10
8000d89a:	16 99       	mov	r9,r11
8000d89c:	fa e9 00 08 	st.d	sp[8],r8
8000d8a0:	c0 88       	rjmp	8000d8b0 <_dtoa_r+0x478>
8000d8a2:	d7 03       	nop
8000d8a4:	80 01       	ld.sh	r1,r0[0x0]
8000d8a6:	9d 68       	st.w	lr[0x18],r8
8000d8a8:	80 01       	ld.sh	r1,r0[0x0]
8000d8aa:	9e 30       	ld.sh	r0,pc[0x6]
8000d8ac:	50 66       	stdsp	sp[0x18],r6
8000d8ae:	02 94       	mov	r4,r1
8000d8b0:	0a 9c       	mov	r12,r5
8000d8b2:	e0 a0 0e 84 	rcall	8000f5ba <__avr32_s32_to_f64>
8000d8b6:	fa e8 00 08 	ld.d	r8,sp[8]
8000d8ba:	e0 a0 0c 25 	rcall	8000f104 <__avr32_f64_mul>
8000d8be:	30 08       	mov	r8,0
8000d8c0:	fc 19 40 1c 	movh	r9,0x401c
8000d8c4:	e0 a0 0d da 	rcall	8000f478 <__avr32_f64_add>
8000d8c8:	14 98       	mov	r8,r10
8000d8ca:	16 99       	mov	r9,r11
8000d8cc:	fa e9 00 28 	st.d	sp[40],r8
8000d8d0:	fc 18 fc c0 	movh	r8,0xfcc0
8000d8d4:	40 a5       	lddsp	r5,sp[0x28]
8000d8d6:	10 05       	add	r5,r8
8000d8d8:	50 a5       	stdsp	sp[0x28],r5
8000d8da:	58 04       	cp.w	r4,0
8000d8dc:	c2 11       	brne	8000d91e <_dtoa_r+0x4e6>
8000d8de:	fa ea 00 08 	ld.d	r10,sp[8]
8000d8e2:	30 08       	mov	r8,0
8000d8e4:	fc 19 40 14 	movh	r9,0x4014
8000d8e8:	e0 a0 0c fa 	rcall	8000f2dc <__avr32_f64_sub>
8000d8ec:	40 bc       	lddsp	r12,sp[0x2c]
8000d8ee:	fa eb 00 08 	st.d	sp[8],r10
8000d8f2:	14 98       	mov	r8,r10
8000d8f4:	16 99       	mov	r9,r11
8000d8f6:	18 9a       	mov	r10,r12
8000d8f8:	0a 9b       	mov	r11,r5
8000d8fa:	e0 a0 0f 17 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000d8fe:	e0 81 02 54 	brne	8000dda6 <_dtoa_r+0x96e>
8000d902:	0a 98       	mov	r8,r5
8000d904:	40 b9       	lddsp	r9,sp[0x2c]
8000d906:	ee 18 80 00 	eorh	r8,0x8000
8000d90a:	fa ea 00 08 	ld.d	r10,sp[8]
8000d90e:	10 95       	mov	r5,r8
8000d910:	12 98       	mov	r8,r9
8000d912:	0a 99       	mov	r9,r5
8000d914:	e0 a0 0f 0a 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000d918:	e0 81 02 3e 	brne	8000dd94 <_dtoa_r+0x95c>
8000d91c:	ca 68       	rjmp	8000da68 <_dtoa_r+0x630>
8000d91e:	4c e9       	lddpc	r9,8000da54 <_dtoa_r+0x61c>
8000d920:	e8 c8 00 01 	sub	r8,r4,1
8000d924:	40 d5       	lddsp	r5,sp[0x34]
8000d926:	58 05       	cp.w	r5,0
8000d928:	c4 f0       	breq	8000d9c6 <_dtoa_r+0x58e>
8000d92a:	30 0c       	mov	r12,0
8000d92c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d930:	51 3c       	stdsp	sp[0x4c],r12
8000d932:	30 0a       	mov	r10,0
8000d934:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d938:	e0 a0 0f 2c 	rcall	8000f790 <__avr32_f64_div>
8000d93c:	fa e8 00 28 	ld.d	r8,sp[40]
8000d940:	40 85       	lddsp	r5,sp[0x20]
8000d942:	e0 a0 0c cd 	rcall	8000f2dc <__avr32_f64_sub>
8000d946:	fa eb 00 28 	st.d	sp[40],r10
8000d94a:	fa ea 00 08 	ld.d	r10,sp[8]
8000d94e:	e0 a0 0e 1f 	rcall	8000f58c <__avr32_f64_to_s32>
8000d952:	51 6c       	stdsp	sp[0x58],r12
8000d954:	e0 a0 0e 33 	rcall	8000f5ba <__avr32_s32_to_f64>
8000d958:	14 98       	mov	r8,r10
8000d95a:	16 99       	mov	r9,r11
8000d95c:	fa ea 00 08 	ld.d	r10,sp[8]
8000d960:	e0 a0 0c be 	rcall	8000f2dc <__avr32_f64_sub>
8000d964:	fa eb 00 08 	st.d	sp[8],r10
8000d968:	41 68       	lddsp	r8,sp[0x58]
8000d96a:	2d 08       	sub	r8,-48
8000d96c:	0a c8       	st.b	r5++,r8
8000d96e:	41 39       	lddsp	r9,sp[0x4c]
8000d970:	2f f9       	sub	r9,-1
8000d972:	51 39       	stdsp	sp[0x4c],r9
8000d974:	fa e8 00 28 	ld.d	r8,sp[40]
8000d978:	e0 a0 0e d8 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000d97c:	e0 81 03 3a 	brne	8000dff0 <_dtoa_r+0xbb8>
8000d980:	fa e8 00 08 	ld.d	r8,sp[8]
8000d984:	30 0a       	mov	r10,0
8000d986:	fc 1b 3f f0 	movh	r11,0x3ff0
8000d98a:	e0 a0 0c a9 	rcall	8000f2dc <__avr32_f64_sub>
8000d98e:	fa e8 00 28 	ld.d	r8,sp[40]
8000d992:	e0 a0 0e cb 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000d996:	fa ea 00 28 	ld.d	r10,sp[40]
8000d99a:	30 08       	mov	r8,0
8000d99c:	fc 19 40 24 	movh	r9,0x4024
8000d9a0:	e0 81 00 da 	brne	8000db54 <_dtoa_r+0x71c>
8000d9a4:	41 3c       	lddsp	r12,sp[0x4c]
8000d9a6:	08 3c       	cp.w	r12,r4
8000d9a8:	c6 04       	brge	8000da68 <_dtoa_r+0x630>
8000d9aa:	e0 a0 0b ad 	rcall	8000f104 <__avr32_f64_mul>
8000d9ae:	30 08       	mov	r8,0
8000d9b0:	fa eb 00 28 	st.d	sp[40],r10
8000d9b4:	fc 19 40 24 	movh	r9,0x4024
8000d9b8:	fa ea 00 08 	ld.d	r10,sp[8]
8000d9bc:	e0 a0 0b a4 	rcall	8000f104 <__avr32_f64_mul>
8000d9c0:	fa eb 00 08 	st.d	sp[8],r10
8000d9c4:	cc 3b       	rjmp	8000d94a <_dtoa_r+0x512>
8000d9c6:	40 85       	lddsp	r5,sp[0x20]
8000d9c8:	08 05       	add	r5,r4
8000d9ca:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000d9ce:	51 35       	stdsp	sp[0x4c],r5
8000d9d0:	fa e8 00 28 	ld.d	r8,sp[40]
8000d9d4:	40 85       	lddsp	r5,sp[0x20]
8000d9d6:	e0 a0 0b 97 	rcall	8000f104 <__avr32_f64_mul>
8000d9da:	fa eb 00 28 	st.d	sp[40],r10
8000d9de:	fa ea 00 08 	ld.d	r10,sp[8]
8000d9e2:	e0 a0 0d d5 	rcall	8000f58c <__avr32_f64_to_s32>
8000d9e6:	51 6c       	stdsp	sp[0x58],r12
8000d9e8:	e0 a0 0d e9 	rcall	8000f5ba <__avr32_s32_to_f64>
8000d9ec:	14 98       	mov	r8,r10
8000d9ee:	16 99       	mov	r9,r11
8000d9f0:	fa ea 00 08 	ld.d	r10,sp[8]
8000d9f4:	e0 a0 0c 74 	rcall	8000f2dc <__avr32_f64_sub>
8000d9f8:	fa eb 00 08 	st.d	sp[8],r10
8000d9fc:	41 68       	lddsp	r8,sp[0x58]
8000d9fe:	2d 08       	sub	r8,-48
8000da00:	0a c8       	st.b	r5++,r8
8000da02:	41 3c       	lddsp	r12,sp[0x4c]
8000da04:	18 35       	cp.w	r5,r12
8000da06:	c2 91       	brne	8000da58 <_dtoa_r+0x620>
8000da08:	30 08       	mov	r8,0
8000da0a:	fc 19 3f e0 	movh	r9,0x3fe0
8000da0e:	fa ea 00 28 	ld.d	r10,sp[40]
8000da12:	e0 a0 0d 33 	rcall	8000f478 <__avr32_f64_add>
8000da16:	40 85       	lddsp	r5,sp[0x20]
8000da18:	fa e8 00 08 	ld.d	r8,sp[8]
8000da1c:	08 05       	add	r5,r4
8000da1e:	e0 a0 0e 85 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000da22:	e0 81 00 99 	brne	8000db54 <_dtoa_r+0x71c>
8000da26:	fa e8 00 28 	ld.d	r8,sp[40]
8000da2a:	30 0a       	mov	r10,0
8000da2c:	fc 1b 3f e0 	movh	r11,0x3fe0
8000da30:	e0 a0 0c 56 	rcall	8000f2dc <__avr32_f64_sub>
8000da34:	14 98       	mov	r8,r10
8000da36:	16 99       	mov	r9,r11
8000da38:	fa ea 00 08 	ld.d	r10,sp[8]
8000da3c:	e0 a0 0e 76 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000da40:	c1 40       	breq	8000da68 <_dtoa_r+0x630>
8000da42:	33 09       	mov	r9,48
8000da44:	0a 98       	mov	r8,r5
8000da46:	11 7a       	ld.ub	r10,--r8
8000da48:	f2 0a 18 00 	cp.b	r10,r9
8000da4c:	e0 81 02 d2 	brne	8000dff0 <_dtoa_r+0xbb8>
8000da50:	10 95       	mov	r5,r8
8000da52:	cf 9b       	rjmp	8000da44 <_dtoa_r+0x60c>
8000da54:	80 01       	ld.sh	r1,r0[0x0]
8000da56:	9d 68       	st.w	lr[0x18],r8
8000da58:	30 08       	mov	r8,0
8000da5a:	fc 19 40 24 	movh	r9,0x4024
8000da5e:	e0 a0 0b 53 	rcall	8000f104 <__avr32_f64_mul>
8000da62:	fa eb 00 08 	st.d	sp[8],r10
8000da66:	cb cb       	rjmp	8000d9de <_dtoa_r+0x5a6>
8000da68:	fa ea 00 3c 	ld.d	r10,sp[60]
8000da6c:	fa eb 00 08 	st.d	sp[8],r10
8000da70:	58 e6       	cp.w	r6,14
8000da72:	5f ab       	srle	r11
8000da74:	41 8a       	lddsp	r10,sp[0x60]
8000da76:	30 08       	mov	r8,0
8000da78:	f4 09 11 ff 	rsub	r9,r10,-1
8000da7c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000da80:	f0 09 18 00 	cp.b	r9,r8
8000da84:	e0 80 00 81 	breq	8000db86 <_dtoa_r+0x74e>
8000da88:	40 ea       	lddsp	r10,sp[0x38]
8000da8a:	58 01       	cp.w	r1,0
8000da8c:	5f a9       	srle	r9
8000da8e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000da92:	4c 9a       	lddpc	r10,8000dbb4 <_dtoa_r+0x77c>
8000da94:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000da98:	fa e5 00 10 	st.d	sp[16],r4
8000da9c:	f0 09 18 00 	cp.b	r9,r8
8000daa0:	c1 40       	breq	8000dac8 <_dtoa_r+0x690>
8000daa2:	58 01       	cp.w	r1,0
8000daa4:	e0 81 01 78 	brne	8000dd94 <_dtoa_r+0x95c>
8000daa8:	30 08       	mov	r8,0
8000daaa:	fc 19 40 14 	movh	r9,0x4014
8000daae:	08 9a       	mov	r10,r4
8000dab0:	0a 9b       	mov	r11,r5
8000dab2:	e0 a0 0b 29 	rcall	8000f104 <__avr32_f64_mul>
8000dab6:	fa e8 00 08 	ld.d	r8,sp[8]
8000daba:	e0 a0 0e 03 	rcall	8000f6c0 <__avr32_f64_cmp_ge>
8000dabe:	e0 81 01 6b 	brne	8000dd94 <_dtoa_r+0x95c>
8000dac2:	02 92       	mov	r2,r1
8000dac4:	e0 8f 01 73 	bral	8000ddaa <_dtoa_r+0x972>
8000dac8:	40 85       	lddsp	r5,sp[0x20]
8000daca:	30 14       	mov	r4,1
8000dacc:	fa e8 00 10 	ld.d	r8,sp[16]
8000dad0:	fa ea 00 08 	ld.d	r10,sp[8]
8000dad4:	e0 a0 0e 5e 	rcall	8000f790 <__avr32_f64_div>
8000dad8:	e0 a0 0d 5a 	rcall	8000f58c <__avr32_f64_to_s32>
8000dadc:	18 92       	mov	r2,r12
8000dade:	e0 a0 0d 6e 	rcall	8000f5ba <__avr32_s32_to_f64>
8000dae2:	fa e8 00 10 	ld.d	r8,sp[16]
8000dae6:	e0 a0 0b 0f 	rcall	8000f104 <__avr32_f64_mul>
8000daea:	14 98       	mov	r8,r10
8000daec:	16 99       	mov	r9,r11
8000daee:	fa ea 00 08 	ld.d	r10,sp[8]
8000daf2:	e0 a0 0b f5 	rcall	8000f2dc <__avr32_f64_sub>
8000daf6:	fa eb 00 08 	st.d	sp[8],r10
8000dafa:	e4 c8 ff d0 	sub	r8,r2,-48
8000dafe:	0a c8       	st.b	r5++,r8
8000db00:	fc 19 40 24 	movh	r9,0x4024
8000db04:	30 08       	mov	r8,0
8000db06:	02 34       	cp.w	r4,r1
8000db08:	c3 31       	brne	8000db6e <_dtoa_r+0x736>
8000db0a:	fa e8 00 08 	ld.d	r8,sp[8]
8000db0e:	e0 a0 0c b5 	rcall	8000f478 <__avr32_f64_add>
8000db12:	16 91       	mov	r1,r11
8000db14:	14 90       	mov	r0,r10
8000db16:	14 98       	mov	r8,r10
8000db18:	02 99       	mov	r9,r1
8000db1a:	fa ea 00 10 	ld.d	r10,sp[16]
8000db1e:	e0 a0 0e 05 	rcall	8000f728 <__avr32_f64_cmp_lt>
8000db22:	c1 a1       	brne	8000db56 <_dtoa_r+0x71e>
8000db24:	fa e8 00 10 	ld.d	r8,sp[16]
8000db28:	00 9a       	mov	r10,r0
8000db2a:	02 9b       	mov	r11,r1
8000db2c:	e0 a0 0d b7 	rcall	8000f69a <__avr32_f64_cmp_eq>
8000db30:	e0 80 02 5f 	breq	8000dfee <_dtoa_r+0xbb6>
8000db34:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000db38:	c0 f1       	brne	8000db56 <_dtoa_r+0x71e>
8000db3a:	e0 8f 02 5a 	bral	8000dfee <_dtoa_r+0xbb6>
8000db3e:	40 8a       	lddsp	r10,sp[0x20]
8000db40:	14 38       	cp.w	r8,r10
8000db42:	c0 30       	breq	8000db48 <_dtoa_r+0x710>
8000db44:	10 95       	mov	r5,r8
8000db46:	c0 98       	rjmp	8000db58 <_dtoa_r+0x720>
8000db48:	33 08       	mov	r8,48
8000db4a:	40 89       	lddsp	r9,sp[0x20]
8000db4c:	2f f6       	sub	r6,-1
8000db4e:	b2 88       	st.b	r9[0x0],r8
8000db50:	40 88       	lddsp	r8,sp[0x20]
8000db52:	c0 88       	rjmp	8000db62 <_dtoa_r+0x72a>
8000db54:	40 66       	lddsp	r6,sp[0x18]
8000db56:	33 99       	mov	r9,57
8000db58:	0a 98       	mov	r8,r5
8000db5a:	11 7a       	ld.ub	r10,--r8
8000db5c:	f2 0a 18 00 	cp.b	r10,r9
8000db60:	ce f0       	breq	8000db3e <_dtoa_r+0x706>
8000db62:	50 66       	stdsp	sp[0x18],r6
8000db64:	11 89       	ld.ub	r9,r8[0x0]
8000db66:	2f f9       	sub	r9,-1
8000db68:	b0 89       	st.b	r8[0x0],r9
8000db6a:	e0 8f 02 43 	bral	8000dff0 <_dtoa_r+0xbb8>
8000db6e:	e0 a0 0a cb 	rcall	8000f104 <__avr32_f64_mul>
8000db72:	2f f4       	sub	r4,-1
8000db74:	fa eb 00 08 	st.d	sp[8],r10
8000db78:	30 08       	mov	r8,0
8000db7a:	30 09       	mov	r9,0
8000db7c:	e0 a0 0d 8f 	rcall	8000f69a <__avr32_f64_cmp_eq>
8000db80:	ca 60       	breq	8000dacc <_dtoa_r+0x694>
8000db82:	e0 8f 02 36 	bral	8000dfee <_dtoa_r+0xbb6>
8000db86:	40 d8       	lddsp	r8,sp[0x34]
8000db88:	58 08       	cp.w	r8,0
8000db8a:	c0 51       	brne	8000db94 <_dtoa_r+0x75c>
8000db8c:	04 98       	mov	r8,r2
8000db8e:	00 95       	mov	r5,r0
8000db90:	40 d4       	lddsp	r4,sp[0x34]
8000db92:	c3 88       	rjmp	8000dc02 <_dtoa_r+0x7ca>
8000db94:	40 c5       	lddsp	r5,sp[0x30]
8000db96:	58 15       	cp.w	r5,1
8000db98:	e0 89 00 10 	brgt	8000dbb8 <_dtoa_r+0x780>
8000db9c:	41 74       	lddsp	r4,sp[0x5c]
8000db9e:	58 04       	cp.w	r4,0
8000dba0:	c0 40       	breq	8000dba8 <_dtoa_r+0x770>
8000dba2:	f4 c9 fb cd 	sub	r9,r10,-1075
8000dba6:	c0 48       	rjmp	8000dbae <_dtoa_r+0x776>
8000dba8:	41 99       	lddsp	r9,sp[0x64]
8000dbaa:	f2 09 11 36 	rsub	r9,r9,54
8000dbae:	04 98       	mov	r8,r2
8000dbb0:	00 95       	mov	r5,r0
8000dbb2:	c1 d8       	rjmp	8000dbec <_dtoa_r+0x7b4>
8000dbb4:	80 01       	ld.sh	r1,r0[0x0]
8000dbb6:	9d 68       	st.w	lr[0x18],r8
8000dbb8:	e2 c8 00 01 	sub	r8,r1,1
8000dbbc:	58 01       	cp.w	r1,0
8000dbbe:	e0 05 17 40 	movge	r5,r0
8000dbc2:	e2 09 17 40 	movge	r9,r1
8000dbc6:	e1 d1 e5 15 	sublt	r5,r0,r1
8000dbca:	f9 b9 05 00 	movlt	r9,0
8000dbce:	10 32       	cp.w	r2,r8
8000dbd0:	e5 d8 e4 18 	subge	r8,r2,r8
8000dbd4:	f1 d2 e5 18 	sublt	r8,r8,r2
8000dbd8:	e5 d8 e5 02 	addlt	r2,r2,r8
8000dbdc:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000dbe0:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000dbe4:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000dbe8:	f9 b8 05 00 	movlt	r8,0
8000dbec:	40 4b       	lddsp	r11,sp[0x10]
8000dbee:	12 0b       	add	r11,r9
8000dbf0:	50 08       	stdsp	sp[0x0],r8
8000dbf2:	50 4b       	stdsp	sp[0x10],r11
8000dbf4:	12 00       	add	r0,r9
8000dbf6:	30 1b       	mov	r11,1
8000dbf8:	0e 9c       	mov	r12,r7
8000dbfa:	e0 a0 08 ab 	rcall	8000ed50 <__i2b>
8000dbfe:	40 08       	lddsp	r8,sp[0x0]
8000dc00:	18 94       	mov	r4,r12
8000dc02:	40 4a       	lddsp	r10,sp[0x10]
8000dc04:	58 05       	cp.w	r5,0
8000dc06:	5f 99       	srgt	r9
8000dc08:	58 0a       	cp.w	r10,0
8000dc0a:	5f 9a       	srgt	r10
8000dc0c:	f5 e9 00 09 	and	r9,r10,r9
8000dc10:	c0 80       	breq	8000dc20 <_dtoa_r+0x7e8>
8000dc12:	40 4c       	lddsp	r12,sp[0x10]
8000dc14:	f8 05 0d 49 	min	r9,r12,r5
8000dc18:	12 1c       	sub	r12,r9
8000dc1a:	12 10       	sub	r0,r9
8000dc1c:	50 4c       	stdsp	sp[0x10],r12
8000dc1e:	12 15       	sub	r5,r9
8000dc20:	58 02       	cp.w	r2,0
8000dc22:	e0 8a 00 27 	brle	8000dc70 <_dtoa_r+0x838>
8000dc26:	40 db       	lddsp	r11,sp[0x34]
8000dc28:	58 0b       	cp.w	r11,0
8000dc2a:	c1 d0       	breq	8000dc64 <_dtoa_r+0x82c>
8000dc2c:	58 08       	cp.w	r8,0
8000dc2e:	e0 8a 00 17 	brle	8000dc5c <_dtoa_r+0x824>
8000dc32:	10 9a       	mov	r10,r8
8000dc34:	50 08       	stdsp	sp[0x0],r8
8000dc36:	08 9b       	mov	r11,r4
8000dc38:	0e 9c       	mov	r12,r7
8000dc3a:	e0 a0 08 d1 	rcall	8000eddc <__pow5mult>
8000dc3e:	06 9a       	mov	r10,r3
8000dc40:	18 9b       	mov	r11,r12
8000dc42:	18 94       	mov	r4,r12
8000dc44:	0e 9c       	mov	r12,r7
8000dc46:	e0 a0 08 05 	rcall	8000ec50 <__multiply>
8000dc4a:	18 99       	mov	r9,r12
8000dc4c:	06 9b       	mov	r11,r3
8000dc4e:	50 19       	stdsp	sp[0x4],r9
8000dc50:	0e 9c       	mov	r12,r7
8000dc52:	e0 a0 06 b1 	rcall	8000e9b4 <_Bfree>
8000dc56:	40 19       	lddsp	r9,sp[0x4]
8000dc58:	40 08       	lddsp	r8,sp[0x0]
8000dc5a:	12 93       	mov	r3,r9
8000dc5c:	e4 08 01 0a 	sub	r10,r2,r8
8000dc60:	c0 80       	breq	8000dc70 <_dtoa_r+0x838>
8000dc62:	c0 28       	rjmp	8000dc66 <_dtoa_r+0x82e>
8000dc64:	04 9a       	mov	r10,r2
8000dc66:	06 9b       	mov	r11,r3
8000dc68:	0e 9c       	mov	r12,r7
8000dc6a:	e0 a0 08 b9 	rcall	8000eddc <__pow5mult>
8000dc6e:	18 93       	mov	r3,r12
8000dc70:	30 1b       	mov	r11,1
8000dc72:	0e 9c       	mov	r12,r7
8000dc74:	e0 a0 08 6e 	rcall	8000ed50 <__i2b>
8000dc78:	41 1a       	lddsp	r10,sp[0x44]
8000dc7a:	18 92       	mov	r2,r12
8000dc7c:	58 0a       	cp.w	r10,0
8000dc7e:	e0 8a 00 07 	brle	8000dc8c <_dtoa_r+0x854>
8000dc82:	18 9b       	mov	r11,r12
8000dc84:	0e 9c       	mov	r12,r7
8000dc86:	e0 a0 08 ab 	rcall	8000eddc <__pow5mult>
8000dc8a:	18 92       	mov	r2,r12
8000dc8c:	40 c9       	lddsp	r9,sp[0x30]
8000dc8e:	58 19       	cp.w	r9,1
8000dc90:	e0 89 00 14 	brgt	8000dcb8 <_dtoa_r+0x880>
8000dc94:	40 38       	lddsp	r8,sp[0xc]
8000dc96:	58 08       	cp.w	r8,0
8000dc98:	c1 01       	brne	8000dcb8 <_dtoa_r+0x880>
8000dc9a:	40 29       	lddsp	r9,sp[0x8]
8000dc9c:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000dca0:	c0 c1       	brne	8000dcb8 <_dtoa_r+0x880>
8000dca2:	12 98       	mov	r8,r9
8000dca4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000dca8:	c0 80       	breq	8000dcb8 <_dtoa_r+0x880>
8000dcaa:	40 4c       	lddsp	r12,sp[0x10]
8000dcac:	30 1b       	mov	r11,1
8000dcae:	2f fc       	sub	r12,-1
8000dcb0:	2f f0       	sub	r0,-1
8000dcb2:	50 4c       	stdsp	sp[0x10],r12
8000dcb4:	50 6b       	stdsp	sp[0x18],r11
8000dcb6:	c0 38       	rjmp	8000dcbc <_dtoa_r+0x884>
8000dcb8:	30 0a       	mov	r10,0
8000dcba:	50 6a       	stdsp	sp[0x18],r10
8000dcbc:	41 19       	lddsp	r9,sp[0x44]
8000dcbe:	58 09       	cp.w	r9,0
8000dcc0:	c0 31       	brne	8000dcc6 <_dtoa_r+0x88e>
8000dcc2:	30 1c       	mov	r12,1
8000dcc4:	c0 98       	rjmp	8000dcd6 <_dtoa_r+0x89e>
8000dcc6:	64 48       	ld.w	r8,r2[0x10]
8000dcc8:	2f c8       	sub	r8,-4
8000dcca:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000dcce:	e0 a0 05 e3 	rcall	8000e894 <__hi0bits>
8000dcd2:	f8 0c 11 20 	rsub	r12,r12,32
8000dcd6:	40 4b       	lddsp	r11,sp[0x10]
8000dcd8:	f8 0b 00 08 	add	r8,r12,r11
8000dcdc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000dce0:	c0 c0       	breq	8000dcf8 <_dtoa_r+0x8c0>
8000dce2:	f0 08 11 20 	rsub	r8,r8,32
8000dce6:	58 48       	cp.w	r8,4
8000dce8:	e0 8a 00 06 	brle	8000dcf4 <_dtoa_r+0x8bc>
8000dcec:	20 48       	sub	r8,4
8000dcee:	10 0b       	add	r11,r8
8000dcf0:	50 4b       	stdsp	sp[0x10],r11
8000dcf2:	c0 78       	rjmp	8000dd00 <_dtoa_r+0x8c8>
8000dcf4:	58 48       	cp.w	r8,4
8000dcf6:	c0 70       	breq	8000dd04 <_dtoa_r+0x8cc>
8000dcf8:	40 4a       	lddsp	r10,sp[0x10]
8000dcfa:	2e 48       	sub	r8,-28
8000dcfc:	10 0a       	add	r10,r8
8000dcfe:	50 4a       	stdsp	sp[0x10],r10
8000dd00:	10 00       	add	r0,r8
8000dd02:	10 05       	add	r5,r8
8000dd04:	58 00       	cp.w	r0,0
8000dd06:	e0 8a 00 08 	brle	8000dd16 <_dtoa_r+0x8de>
8000dd0a:	06 9b       	mov	r11,r3
8000dd0c:	00 9a       	mov	r10,r0
8000dd0e:	0e 9c       	mov	r12,r7
8000dd10:	e0 a0 07 5c 	rcall	8000ebc8 <__lshift>
8000dd14:	18 93       	mov	r3,r12
8000dd16:	40 49       	lddsp	r9,sp[0x10]
8000dd18:	58 09       	cp.w	r9,0
8000dd1a:	e0 8a 00 08 	brle	8000dd2a <_dtoa_r+0x8f2>
8000dd1e:	04 9b       	mov	r11,r2
8000dd20:	12 9a       	mov	r10,r9
8000dd22:	0e 9c       	mov	r12,r7
8000dd24:	e0 a0 07 52 	rcall	8000ebc8 <__lshift>
8000dd28:	18 92       	mov	r2,r12
8000dd2a:	41 48       	lddsp	r8,sp[0x50]
8000dd2c:	58 08       	cp.w	r8,0
8000dd2e:	c1 b0       	breq	8000dd64 <_dtoa_r+0x92c>
8000dd30:	04 9b       	mov	r11,r2
8000dd32:	06 9c       	mov	r12,r3
8000dd34:	e0 a0 06 27 	rcall	8000e982 <__mcmp>
8000dd38:	c1 64       	brge	8000dd64 <_dtoa_r+0x92c>
8000dd3a:	06 9b       	mov	r11,r3
8000dd3c:	30 09       	mov	r9,0
8000dd3e:	30 aa       	mov	r10,10
8000dd40:	0e 9c       	mov	r12,r7
8000dd42:	e0 a0 08 0f 	rcall	8000ed60 <__multadd>
8000dd46:	20 16       	sub	r6,1
8000dd48:	18 93       	mov	r3,r12
8000dd4a:	40 dc       	lddsp	r12,sp[0x34]
8000dd4c:	58 0c       	cp.w	r12,0
8000dd4e:	c0 31       	brne	8000dd54 <_dtoa_r+0x91c>
8000dd50:	40 91       	lddsp	r1,sp[0x24]
8000dd52:	c0 98       	rjmp	8000dd64 <_dtoa_r+0x92c>
8000dd54:	08 9b       	mov	r11,r4
8000dd56:	40 91       	lddsp	r1,sp[0x24]
8000dd58:	30 09       	mov	r9,0
8000dd5a:	30 aa       	mov	r10,10
8000dd5c:	0e 9c       	mov	r12,r7
8000dd5e:	e0 a0 08 01 	rcall	8000ed60 <__multadd>
8000dd62:	18 94       	mov	r4,r12
8000dd64:	58 01       	cp.w	r1,0
8000dd66:	5f a9       	srle	r9
8000dd68:	40 cb       	lddsp	r11,sp[0x30]
8000dd6a:	58 2b       	cp.w	r11,2
8000dd6c:	5f 98       	srgt	r8
8000dd6e:	f3 e8 00 08 	and	r8,r9,r8
8000dd72:	c2 50       	breq	8000ddbc <_dtoa_r+0x984>
8000dd74:	58 01       	cp.w	r1,0
8000dd76:	c1 11       	brne	8000dd98 <_dtoa_r+0x960>
8000dd78:	04 9b       	mov	r11,r2
8000dd7a:	02 99       	mov	r9,r1
8000dd7c:	30 5a       	mov	r10,5
8000dd7e:	0e 9c       	mov	r12,r7
8000dd80:	e0 a0 07 f0 	rcall	8000ed60 <__multadd>
8000dd84:	18 92       	mov	r2,r12
8000dd86:	18 9b       	mov	r11,r12
8000dd88:	06 9c       	mov	r12,r3
8000dd8a:	e0 a0 05 fc 	rcall	8000e982 <__mcmp>
8000dd8e:	e0 89 00 0f 	brgt	8000ddac <_dtoa_r+0x974>
8000dd92:	c0 38       	rjmp	8000dd98 <_dtoa_r+0x960>
8000dd94:	30 02       	mov	r2,0
8000dd96:	04 94       	mov	r4,r2
8000dd98:	40 ea       	lddsp	r10,sp[0x38]
8000dd9a:	30 09       	mov	r9,0
8000dd9c:	5c da       	com	r10
8000dd9e:	40 85       	lddsp	r5,sp[0x20]
8000dda0:	50 6a       	stdsp	sp[0x18],r10
8000dda2:	50 49       	stdsp	sp[0x10],r9
8000dda4:	c0 f9       	rjmp	8000dfc2 <_dtoa_r+0xb8a>
8000dda6:	08 92       	mov	r2,r4
8000dda8:	40 66       	lddsp	r6,sp[0x18]
8000ddaa:	04 94       	mov	r4,r2
8000ddac:	2f f6       	sub	r6,-1
8000ddae:	50 66       	stdsp	sp[0x18],r6
8000ddb0:	33 18       	mov	r8,49
8000ddb2:	40 85       	lddsp	r5,sp[0x20]
8000ddb4:	0a c8       	st.b	r5++,r8
8000ddb6:	30 08       	mov	r8,0
8000ddb8:	50 48       	stdsp	sp[0x10],r8
8000ddba:	c0 49       	rjmp	8000dfc2 <_dtoa_r+0xb8a>
8000ddbc:	40 dc       	lddsp	r12,sp[0x34]
8000ddbe:	58 0c       	cp.w	r12,0
8000ddc0:	e0 80 00 b5 	breq	8000df2a <_dtoa_r+0xaf2>
8000ddc4:	58 05       	cp.w	r5,0
8000ddc6:	e0 8a 00 08 	brle	8000ddd6 <_dtoa_r+0x99e>
8000ddca:	08 9b       	mov	r11,r4
8000ddcc:	0a 9a       	mov	r10,r5
8000ddce:	0e 9c       	mov	r12,r7
8000ddd0:	e0 a0 06 fc 	rcall	8000ebc8 <__lshift>
8000ddd4:	18 94       	mov	r4,r12
8000ddd6:	40 6b       	lddsp	r11,sp[0x18]
8000ddd8:	58 0b       	cp.w	r11,0
8000ddda:	c0 31       	brne	8000dde0 <_dtoa_r+0x9a8>
8000dddc:	08 9c       	mov	r12,r4
8000ddde:	c1 38       	rjmp	8000de04 <_dtoa_r+0x9cc>
8000dde0:	68 1b       	ld.w	r11,r4[0x4]
8000dde2:	0e 9c       	mov	r12,r7
8000dde4:	e0 a0 06 02 	rcall	8000e9e8 <_Balloc>
8000dde8:	68 4a       	ld.w	r10,r4[0x10]
8000ddea:	18 95       	mov	r5,r12
8000ddec:	e8 cb ff f4 	sub	r11,r4,-12
8000ddf0:	2f ea       	sub	r10,-2
8000ddf2:	2f 4c       	sub	r12,-12
8000ddf4:	a3 6a       	lsl	r10,0x2
8000ddf6:	fe b0 e5 ae 	rcall	8000a952 <memcpy>
8000ddfa:	0a 9b       	mov	r11,r5
8000ddfc:	30 1a       	mov	r10,1
8000ddfe:	0e 9c       	mov	r12,r7
8000de00:	e0 a0 06 e4 	rcall	8000ebc8 <__lshift>
8000de04:	50 44       	stdsp	sp[0x10],r4
8000de06:	40 3a       	lddsp	r10,sp[0xc]
8000de08:	30 19       	mov	r9,1
8000de0a:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000de0e:	18 94       	mov	r4,r12
8000de10:	50 da       	stdsp	sp[0x34],r10
8000de12:	40 85       	lddsp	r5,sp[0x20]
8000de14:	50 99       	stdsp	sp[0x24],r9
8000de16:	50 26       	stdsp	sp[0x8],r6
8000de18:	50 e1       	stdsp	sp[0x38],r1
8000de1a:	04 9b       	mov	r11,r2
8000de1c:	06 9c       	mov	r12,r3
8000de1e:	fe b0 fa 7d 	rcall	8000d318 <quorem>
8000de22:	40 4b       	lddsp	r11,sp[0x10]
8000de24:	f8 c0 ff d0 	sub	r0,r12,-48
8000de28:	06 9c       	mov	r12,r3
8000de2a:	e0 a0 05 ac 	rcall	8000e982 <__mcmp>
8000de2e:	08 9a       	mov	r10,r4
8000de30:	50 6c       	stdsp	sp[0x18],r12
8000de32:	04 9b       	mov	r11,r2
8000de34:	0e 9c       	mov	r12,r7
8000de36:	e0 a0 06 61 	rcall	8000eaf8 <__mdiff>
8000de3a:	18 91       	mov	r1,r12
8000de3c:	78 38       	ld.w	r8,r12[0xc]
8000de3e:	58 08       	cp.w	r8,0
8000de40:	c0 30       	breq	8000de46 <_dtoa_r+0xa0e>
8000de42:	30 16       	mov	r6,1
8000de44:	c0 68       	rjmp	8000de50 <_dtoa_r+0xa18>
8000de46:	18 9b       	mov	r11,r12
8000de48:	06 9c       	mov	r12,r3
8000de4a:	e0 a0 05 9c 	rcall	8000e982 <__mcmp>
8000de4e:	18 96       	mov	r6,r12
8000de50:	0e 9c       	mov	r12,r7
8000de52:	02 9b       	mov	r11,r1
8000de54:	e0 a0 05 b0 	rcall	8000e9b4 <_Bfree>
8000de58:	40 cc       	lddsp	r12,sp[0x30]
8000de5a:	ed ec 10 08 	or	r8,r6,r12
8000de5e:	c0 d1       	brne	8000de78 <_dtoa_r+0xa40>
8000de60:	40 db       	lddsp	r11,sp[0x34]
8000de62:	58 0b       	cp.w	r11,0
8000de64:	c0 a1       	brne	8000de78 <_dtoa_r+0xa40>
8000de66:	40 26       	lddsp	r6,sp[0x8]
8000de68:	e0 40 00 39 	cp.w	r0,57
8000de6c:	c3 00       	breq	8000decc <_dtoa_r+0xa94>
8000de6e:	40 6a       	lddsp	r10,sp[0x18]
8000de70:	58 0a       	cp.w	r10,0
8000de72:	e0 89 00 24 	brgt	8000deba <_dtoa_r+0xa82>
8000de76:	c2 f8       	rjmp	8000ded4 <_dtoa_r+0xa9c>
8000de78:	40 69       	lddsp	r9,sp[0x18]
8000de7a:	58 09       	cp.w	r9,0
8000de7c:	c0 85       	brlt	8000de8c <_dtoa_r+0xa54>
8000de7e:	12 98       	mov	r8,r9
8000de80:	40 cc       	lddsp	r12,sp[0x30]
8000de82:	18 48       	or	r8,r12
8000de84:	c1 d1       	brne	8000debe <_dtoa_r+0xa86>
8000de86:	40 db       	lddsp	r11,sp[0x34]
8000de88:	58 0b       	cp.w	r11,0
8000de8a:	c1 a1       	brne	8000debe <_dtoa_r+0xa86>
8000de8c:	0c 99       	mov	r9,r6
8000de8e:	40 26       	lddsp	r6,sp[0x8]
8000de90:	58 09       	cp.w	r9,0
8000de92:	e0 8a 00 21 	brle	8000ded4 <_dtoa_r+0xa9c>
8000de96:	06 9b       	mov	r11,r3
8000de98:	30 1a       	mov	r10,1
8000de9a:	0e 9c       	mov	r12,r7
8000de9c:	e0 a0 06 96 	rcall	8000ebc8 <__lshift>
8000dea0:	04 9b       	mov	r11,r2
8000dea2:	18 93       	mov	r3,r12
8000dea4:	e0 a0 05 6f 	rcall	8000e982 <__mcmp>
8000dea8:	e0 89 00 06 	brgt	8000deb4 <_dtoa_r+0xa7c>
8000deac:	c1 41       	brne	8000ded4 <_dtoa_r+0xa9c>
8000deae:	ed b0 00 00 	bld	r0,0x0
8000deb2:	c1 11       	brne	8000ded4 <_dtoa_r+0xa9c>
8000deb4:	e0 40 00 39 	cp.w	r0,57
8000deb8:	c0 a0       	breq	8000decc <_dtoa_r+0xa94>
8000deba:	2f f0       	sub	r0,-1
8000debc:	c0 c8       	rjmp	8000ded4 <_dtoa_r+0xa9c>
8000debe:	58 06       	cp.w	r6,0
8000dec0:	e0 8a 00 0c 	brle	8000ded8 <_dtoa_r+0xaa0>
8000dec4:	40 26       	lddsp	r6,sp[0x8]
8000dec6:	e0 40 00 39 	cp.w	r0,57
8000deca:	c0 41       	brne	8000ded2 <_dtoa_r+0xa9a>
8000decc:	33 98       	mov	r8,57
8000dece:	0a c8       	st.b	r5++,r8
8000ded0:	c6 78       	rjmp	8000df9e <_dtoa_r+0xb66>
8000ded2:	2f f0       	sub	r0,-1
8000ded4:	0a c0       	st.b	r5++,r0
8000ded6:	c7 58       	rjmp	8000dfc0 <_dtoa_r+0xb88>
8000ded8:	0a c0       	st.b	r5++,r0
8000deda:	40 9a       	lddsp	r10,sp[0x24]
8000dedc:	40 e9       	lddsp	r9,sp[0x38]
8000dede:	12 3a       	cp.w	r10,r9
8000dee0:	c4 30       	breq	8000df66 <_dtoa_r+0xb2e>
8000dee2:	06 9b       	mov	r11,r3
8000dee4:	30 09       	mov	r9,0
8000dee6:	30 aa       	mov	r10,10
8000dee8:	0e 9c       	mov	r12,r7
8000deea:	e0 a0 07 3b 	rcall	8000ed60 <__multadd>
8000deee:	40 48       	lddsp	r8,sp[0x10]
8000def0:	18 93       	mov	r3,r12
8000def2:	08 38       	cp.w	r8,r4
8000def4:	c0 91       	brne	8000df06 <_dtoa_r+0xace>
8000def6:	10 9b       	mov	r11,r8
8000def8:	30 09       	mov	r9,0
8000defa:	30 aa       	mov	r10,10
8000defc:	0e 9c       	mov	r12,r7
8000defe:	e0 a0 07 31 	rcall	8000ed60 <__multadd>
8000df02:	50 4c       	stdsp	sp[0x10],r12
8000df04:	c0 e8       	rjmp	8000df20 <_dtoa_r+0xae8>
8000df06:	40 4b       	lddsp	r11,sp[0x10]
8000df08:	30 09       	mov	r9,0
8000df0a:	30 aa       	mov	r10,10
8000df0c:	0e 9c       	mov	r12,r7
8000df0e:	e0 a0 07 29 	rcall	8000ed60 <__multadd>
8000df12:	08 9b       	mov	r11,r4
8000df14:	50 4c       	stdsp	sp[0x10],r12
8000df16:	30 09       	mov	r9,0
8000df18:	30 aa       	mov	r10,10
8000df1a:	0e 9c       	mov	r12,r7
8000df1c:	e0 a0 07 22 	rcall	8000ed60 <__multadd>
8000df20:	18 94       	mov	r4,r12
8000df22:	40 9c       	lddsp	r12,sp[0x24]
8000df24:	2f fc       	sub	r12,-1
8000df26:	50 9c       	stdsp	sp[0x24],r12
8000df28:	c7 9b       	rjmp	8000de1a <_dtoa_r+0x9e2>
8000df2a:	30 18       	mov	r8,1
8000df2c:	06 90       	mov	r0,r3
8000df2e:	40 85       	lddsp	r5,sp[0x20]
8000df30:	08 93       	mov	r3,r4
8000df32:	0c 94       	mov	r4,r6
8000df34:	10 96       	mov	r6,r8
8000df36:	04 9b       	mov	r11,r2
8000df38:	00 9c       	mov	r12,r0
8000df3a:	fe b0 f9 ef 	rcall	8000d318 <quorem>
8000df3e:	2d 0c       	sub	r12,-48
8000df40:	0a cc       	st.b	r5++,r12
8000df42:	02 36       	cp.w	r6,r1
8000df44:	c0 a4       	brge	8000df58 <_dtoa_r+0xb20>
8000df46:	00 9b       	mov	r11,r0
8000df48:	30 09       	mov	r9,0
8000df4a:	30 aa       	mov	r10,10
8000df4c:	0e 9c       	mov	r12,r7
8000df4e:	2f f6       	sub	r6,-1
8000df50:	e0 a0 07 08 	rcall	8000ed60 <__multadd>
8000df54:	18 90       	mov	r0,r12
8000df56:	cf 0b       	rjmp	8000df36 <_dtoa_r+0xafe>
8000df58:	08 96       	mov	r6,r4
8000df5a:	30 0b       	mov	r11,0
8000df5c:	06 94       	mov	r4,r3
8000df5e:	50 4b       	stdsp	sp[0x10],r11
8000df60:	00 93       	mov	r3,r0
8000df62:	18 90       	mov	r0,r12
8000df64:	c0 28       	rjmp	8000df68 <_dtoa_r+0xb30>
8000df66:	40 26       	lddsp	r6,sp[0x8]
8000df68:	06 9b       	mov	r11,r3
8000df6a:	30 1a       	mov	r10,1
8000df6c:	0e 9c       	mov	r12,r7
8000df6e:	e0 a0 06 2d 	rcall	8000ebc8 <__lshift>
8000df72:	04 9b       	mov	r11,r2
8000df74:	18 93       	mov	r3,r12
8000df76:	e0 a0 05 06 	rcall	8000e982 <__mcmp>
8000df7a:	e0 89 00 12 	brgt	8000df9e <_dtoa_r+0xb66>
8000df7e:	c1 b1       	brne	8000dfb4 <_dtoa_r+0xb7c>
8000df80:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000df84:	c0 d1       	brne	8000df9e <_dtoa_r+0xb66>
8000df86:	c1 78       	rjmp	8000dfb4 <_dtoa_r+0xb7c>
8000df88:	40 89       	lddsp	r9,sp[0x20]
8000df8a:	12 38       	cp.w	r8,r9
8000df8c:	c0 30       	breq	8000df92 <_dtoa_r+0xb5a>
8000df8e:	10 95       	mov	r5,r8
8000df90:	c0 88       	rjmp	8000dfa0 <_dtoa_r+0xb68>
8000df92:	2f f6       	sub	r6,-1
8000df94:	50 66       	stdsp	sp[0x18],r6
8000df96:	33 18       	mov	r8,49
8000df98:	40 8c       	lddsp	r12,sp[0x20]
8000df9a:	b8 88       	st.b	r12[0x0],r8
8000df9c:	c1 38       	rjmp	8000dfc2 <_dtoa_r+0xb8a>
8000df9e:	33 9a       	mov	r10,57
8000dfa0:	0a 98       	mov	r8,r5
8000dfa2:	11 79       	ld.ub	r9,--r8
8000dfa4:	f4 09 18 00 	cp.b	r9,r10
8000dfa8:	cf 00       	breq	8000df88 <_dtoa_r+0xb50>
8000dfaa:	2f f9       	sub	r9,-1
8000dfac:	b0 89       	st.b	r8[0x0],r9
8000dfae:	c0 98       	rjmp	8000dfc0 <_dtoa_r+0xb88>
8000dfb0:	10 95       	mov	r5,r8
8000dfb2:	c0 28       	rjmp	8000dfb6 <_dtoa_r+0xb7e>
8000dfb4:	33 09       	mov	r9,48
8000dfb6:	0a 98       	mov	r8,r5
8000dfb8:	11 7a       	ld.ub	r10,--r8
8000dfba:	f2 0a 18 00 	cp.b	r10,r9
8000dfbe:	cf 90       	breq	8000dfb0 <_dtoa_r+0xb78>
8000dfc0:	50 66       	stdsp	sp[0x18],r6
8000dfc2:	04 9b       	mov	r11,r2
8000dfc4:	0e 9c       	mov	r12,r7
8000dfc6:	e0 a0 04 f7 	rcall	8000e9b4 <_Bfree>
8000dfca:	58 04       	cp.w	r4,0
8000dfcc:	c1 20       	breq	8000dff0 <_dtoa_r+0xbb8>
8000dfce:	40 4b       	lddsp	r11,sp[0x10]
8000dfd0:	08 3b       	cp.w	r11,r4
8000dfd2:	5f 19       	srne	r9
8000dfd4:	58 0b       	cp.w	r11,0
8000dfd6:	5f 18       	srne	r8
8000dfd8:	f3 e8 00 08 	and	r8,r9,r8
8000dfdc:	c0 40       	breq	8000dfe4 <_dtoa_r+0xbac>
8000dfde:	0e 9c       	mov	r12,r7
8000dfe0:	e0 a0 04 ea 	rcall	8000e9b4 <_Bfree>
8000dfe4:	08 9b       	mov	r11,r4
8000dfe6:	0e 9c       	mov	r12,r7
8000dfe8:	e0 a0 04 e6 	rcall	8000e9b4 <_Bfree>
8000dfec:	c0 28       	rjmp	8000dff0 <_dtoa_r+0xbb8>
8000dfee:	50 66       	stdsp	sp[0x18],r6
8000dff0:	0e 9c       	mov	r12,r7
8000dff2:	06 9b       	mov	r11,r3
8000dff4:	e0 a0 04 e0 	rcall	8000e9b4 <_Bfree>
8000dff8:	30 08       	mov	r8,0
8000dffa:	aa 88       	st.b	r5[0x0],r8
8000dffc:	40 68       	lddsp	r8,sp[0x18]
8000dffe:	41 5a       	lddsp	r10,sp[0x54]
8000e000:	2f f8       	sub	r8,-1
8000e002:	41 29       	lddsp	r9,sp[0x48]
8000e004:	95 08       	st.w	r10[0x0],r8
8000e006:	40 8c       	lddsp	r12,sp[0x20]
8000e008:	58 09       	cp.w	r9,0
8000e00a:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000e00e:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000e012:	2e 6d       	sub	sp,-104
8000e014:	d8 32       	popm	r0-r7,pc
8000e016:	d7 03       	nop

8000e018 <__errno>:
8000e018:	e0 68 0a 38 	mov	r8,2616
8000e01c:	70 0c       	ld.w	r12,r8[0x0]
8000e01e:	2f 4c       	sub	r12,-12
8000e020:	5e fc       	retal	r12
8000e022:	d7 03       	nop

8000e024 <_fflush_r>:
8000e024:	d4 21       	pushm	r4-r7,lr
8000e026:	16 97       	mov	r7,r11
8000e028:	18 96       	mov	r6,r12
8000e02a:	76 48       	ld.w	r8,r11[0x10]
8000e02c:	58 08       	cp.w	r8,0
8000e02e:	c7 c0       	breq	8000e126 <_fflush_r+0x102>
8000e030:	58 0c       	cp.w	r12,0
8000e032:	c0 50       	breq	8000e03c <_fflush_r+0x18>
8000e034:	78 68       	ld.w	r8,r12[0x18]
8000e036:	58 08       	cp.w	r8,0
8000e038:	c0 21       	brne	8000e03c <_fflush_r+0x18>
8000e03a:	cd 1c       	rcall	8000e1dc <__sinit>
8000e03c:	4b b8       	lddpc	r8,8000e128 <_fflush_r+0x104>
8000e03e:	10 37       	cp.w	r7,r8
8000e040:	c0 31       	brne	8000e046 <_fflush_r+0x22>
8000e042:	6c 07       	ld.w	r7,r6[0x0]
8000e044:	c0 a8       	rjmp	8000e058 <_fflush_r+0x34>
8000e046:	4b a8       	lddpc	r8,8000e12c <_fflush_r+0x108>
8000e048:	10 37       	cp.w	r7,r8
8000e04a:	c0 31       	brne	8000e050 <_fflush_r+0x2c>
8000e04c:	6c 17       	ld.w	r7,r6[0x4]
8000e04e:	c0 58       	rjmp	8000e058 <_fflush_r+0x34>
8000e050:	4b 88       	lddpc	r8,8000e130 <_fflush_r+0x10c>
8000e052:	10 37       	cp.w	r7,r8
8000e054:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000e058:	8e 6a       	ld.sh	r10,r7[0xc]
8000e05a:	14 98       	mov	r8,r10
8000e05c:	ed ba 00 03 	bld	r10,0x3
8000e060:	c4 20       	breq	8000e0e4 <_fflush_r+0xc0>
8000e062:	ab ba       	sbr	r10,0xb
8000e064:	ae 6a       	st.h	r7[0xc],r10
8000e066:	6e 18       	ld.w	r8,r7[0x4]
8000e068:	58 08       	cp.w	r8,0
8000e06a:	e0 89 00 06 	brgt	8000e076 <_fflush_r+0x52>
8000e06e:	6f 08       	ld.w	r8,r7[0x40]
8000e070:	58 08       	cp.w	r8,0
8000e072:	e0 8a 00 5a 	brle	8000e126 <_fflush_r+0x102>
8000e076:	6e b8       	ld.w	r8,r7[0x2c]
8000e078:	58 08       	cp.w	r8,0
8000e07a:	c5 60       	breq	8000e126 <_fflush_r+0x102>
8000e07c:	e2 1a 10 00 	andl	r10,0x1000,COH
8000e080:	c0 30       	breq	8000e086 <_fflush_r+0x62>
8000e082:	6f 55       	ld.w	r5,r7[0x54]
8000e084:	c0 f8       	rjmp	8000e0a2 <_fflush_r+0x7e>
8000e086:	30 19       	mov	r9,1
8000e088:	6e 8b       	ld.w	r11,r7[0x20]
8000e08a:	0c 9c       	mov	r12,r6
8000e08c:	5d 18       	icall	r8
8000e08e:	18 95       	mov	r5,r12
8000e090:	5b fc       	cp.w	r12,-1
8000e092:	c0 81       	brne	8000e0a2 <_fflush_r+0x7e>
8000e094:	6c 38       	ld.w	r8,r6[0xc]
8000e096:	59 d8       	cp.w	r8,29
8000e098:	c4 70       	breq	8000e126 <_fflush_r+0x102>
8000e09a:	8e 68       	ld.sh	r8,r7[0xc]
8000e09c:	a7 a8       	sbr	r8,0x6
8000e09e:	ae 68       	st.h	r7[0xc],r8
8000e0a0:	d8 22       	popm	r4-r7,pc
8000e0a2:	8e 68       	ld.sh	r8,r7[0xc]
8000e0a4:	ed b8 00 02 	bld	r8,0x2
8000e0a8:	c0 91       	brne	8000e0ba <_fflush_r+0x96>
8000e0aa:	6e 18       	ld.w	r8,r7[0x4]
8000e0ac:	10 15       	sub	r5,r8
8000e0ae:	6e d8       	ld.w	r8,r7[0x34]
8000e0b0:	58 08       	cp.w	r8,0
8000e0b2:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000e0b6:	eb d8 e1 15 	subne	r5,r5,r8
8000e0ba:	6e b8       	ld.w	r8,r7[0x2c]
8000e0bc:	0c 9c       	mov	r12,r6
8000e0be:	30 09       	mov	r9,0
8000e0c0:	0a 9a       	mov	r10,r5
8000e0c2:	6e 8b       	ld.w	r11,r7[0x20]
8000e0c4:	5d 18       	icall	r8
8000e0c6:	8e 68       	ld.sh	r8,r7[0xc]
8000e0c8:	0a 3c       	cp.w	r12,r5
8000e0ca:	c2 61       	brne	8000e116 <_fflush_r+0xf2>
8000e0cc:	ab d8       	cbr	r8,0xb
8000e0ce:	30 0c       	mov	r12,0
8000e0d0:	6e 49       	ld.w	r9,r7[0x10]
8000e0d2:	ae 68       	st.h	r7[0xc],r8
8000e0d4:	8f 1c       	st.w	r7[0x4],r12
8000e0d6:	8f 09       	st.w	r7[0x0],r9
8000e0d8:	ed b8 00 0c 	bld	r8,0xc
8000e0dc:	c2 51       	brne	8000e126 <_fflush_r+0x102>
8000e0de:	ef 45 00 54 	st.w	r7[84],r5
8000e0e2:	d8 22       	popm	r4-r7,pc
8000e0e4:	6e 45       	ld.w	r5,r7[0x10]
8000e0e6:	58 05       	cp.w	r5,0
8000e0e8:	c1 f0       	breq	8000e126 <_fflush_r+0x102>
8000e0ea:	6e 04       	ld.w	r4,r7[0x0]
8000e0ec:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000e0f0:	8f 05       	st.w	r7[0x0],r5
8000e0f2:	f9 b8 01 00 	movne	r8,0
8000e0f6:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000e0fa:	0a 14       	sub	r4,r5
8000e0fc:	8f 28       	st.w	r7[0x8],r8
8000e0fe:	c1 18       	rjmp	8000e120 <_fflush_r+0xfc>
8000e100:	08 99       	mov	r9,r4
8000e102:	0a 9a       	mov	r10,r5
8000e104:	6e a8       	ld.w	r8,r7[0x28]
8000e106:	6e 8b       	ld.w	r11,r7[0x20]
8000e108:	0c 9c       	mov	r12,r6
8000e10a:	5d 18       	icall	r8
8000e10c:	18 14       	sub	r4,r12
8000e10e:	58 0c       	cp.w	r12,0
8000e110:	e0 89 00 07 	brgt	8000e11e <_fflush_r+0xfa>
8000e114:	8e 68       	ld.sh	r8,r7[0xc]
8000e116:	a7 a8       	sbr	r8,0x6
8000e118:	3f fc       	mov	r12,-1
8000e11a:	ae 68       	st.h	r7[0xc],r8
8000e11c:	d8 22       	popm	r4-r7,pc
8000e11e:	18 05       	add	r5,r12
8000e120:	58 04       	cp.w	r4,0
8000e122:	fe 99 ff ef 	brgt	8000e100 <_fflush_r+0xdc>
8000e126:	d8 2a       	popm	r4-r7,pc,r12=0
8000e128:	80 01       	ld.sh	r1,r0[0x0]
8000e12a:	9c b8       	ld.uh	r8,lr[0x6]
8000e12c:	80 01       	ld.sh	r1,r0[0x0]
8000e12e:	9c d8       	ld.uh	r8,lr[0xa]
8000e130:	80 01       	ld.sh	r1,r0[0x0]
8000e132:	9c f8       	ld.uh	r8,lr[0xe]

8000e134 <__sfp_lock_acquire>:
8000e134:	5e fc       	retal	r12

8000e136 <__sfp_lock_release>:
8000e136:	5e fc       	retal	r12

8000e138 <_cleanup_r>:
8000e138:	d4 01       	pushm	lr
8000e13a:	fe cb f0 ba 	sub	r11,pc,-3910
8000e13e:	e0 a0 02 f9 	rcall	8000e730 <_fwalk>
8000e142:	d8 02       	popm	pc

8000e144 <__sfmoreglue>:
8000e144:	d4 21       	pushm	r4-r7,lr
8000e146:	16 95       	mov	r5,r11
8000e148:	f6 06 10 5c 	mul	r6,r11,92
8000e14c:	ec cb ff f4 	sub	r11,r6,-12
8000e150:	fe b0 e1 d2 	rcall	8000a4f4 <_malloc_r>
8000e154:	18 97       	mov	r7,r12
8000e156:	c0 90       	breq	8000e168 <__sfmoreglue+0x24>
8000e158:	99 15       	st.w	r12[0x4],r5
8000e15a:	30 0b       	mov	r11,0
8000e15c:	2f 4c       	sub	r12,-12
8000e15e:	0c 9a       	mov	r10,r6
8000e160:	8f 2c       	st.w	r7[0x8],r12
8000e162:	8f 0b       	st.w	r7[0x0],r11
8000e164:	fe b0 e4 9b 	rcall	8000aa9a <memset>
8000e168:	0e 9c       	mov	r12,r7
8000e16a:	d8 22       	popm	r4-r7,pc

8000e16c <__sfp>:
8000e16c:	d4 21       	pushm	r4-r7,lr
8000e16e:	49 b8       	lddpc	r8,8000e1d8 <__sfp+0x6c>
8000e170:	18 96       	mov	r6,r12
8000e172:	70 07       	ld.w	r7,r8[0x0]
8000e174:	6e 68       	ld.w	r8,r7[0x18]
8000e176:	58 08       	cp.w	r8,0
8000e178:	c0 31       	brne	8000e17e <__sfp+0x12>
8000e17a:	0e 9c       	mov	r12,r7
8000e17c:	c3 0c       	rcall	8000e1dc <__sinit>
8000e17e:	ee c7 ff 28 	sub	r7,r7,-216
8000e182:	30 05       	mov	r5,0
8000e184:	6e 2c       	ld.w	r12,r7[0x8]
8000e186:	6e 18       	ld.w	r8,r7[0x4]
8000e188:	c0 68       	rjmp	8000e194 <__sfp+0x28>
8000e18a:	98 69       	ld.sh	r9,r12[0xc]
8000e18c:	ea 09 19 00 	cp.h	r9,r5
8000e190:	c1 10       	breq	8000e1b2 <__sfp+0x46>
8000e192:	2a 4c       	sub	r12,-92
8000e194:	20 18       	sub	r8,1
8000e196:	cf a7       	brpl	8000e18a <__sfp+0x1e>
8000e198:	6e 08       	ld.w	r8,r7[0x0]
8000e19a:	58 08       	cp.w	r8,0
8000e19c:	c0 61       	brne	8000e1a8 <__sfp+0x3c>
8000e19e:	30 4b       	mov	r11,4
8000e1a0:	0c 9c       	mov	r12,r6
8000e1a2:	cd 1f       	rcall	8000e144 <__sfmoreglue>
8000e1a4:	8f 0c       	st.w	r7[0x0],r12
8000e1a6:	c0 30       	breq	8000e1ac <__sfp+0x40>
8000e1a8:	6e 07       	ld.w	r7,r7[0x0]
8000e1aa:	ce db       	rjmp	8000e184 <__sfp+0x18>
8000e1ac:	30 c8       	mov	r8,12
8000e1ae:	8d 38       	st.w	r6[0xc],r8
8000e1b0:	d8 22       	popm	r4-r7,pc
8000e1b2:	30 08       	mov	r8,0
8000e1b4:	f9 48 00 4c 	st.w	r12[76],r8
8000e1b8:	99 08       	st.w	r12[0x0],r8
8000e1ba:	99 28       	st.w	r12[0x8],r8
8000e1bc:	99 18       	st.w	r12[0x4],r8
8000e1be:	99 48       	st.w	r12[0x10],r8
8000e1c0:	99 58       	st.w	r12[0x14],r8
8000e1c2:	99 68       	st.w	r12[0x18],r8
8000e1c4:	99 d8       	st.w	r12[0x34],r8
8000e1c6:	99 e8       	st.w	r12[0x38],r8
8000e1c8:	f9 48 00 48 	st.w	r12[72],r8
8000e1cc:	3f f8       	mov	r8,-1
8000e1ce:	b8 78       	st.h	r12[0xe],r8
8000e1d0:	30 18       	mov	r8,1
8000e1d2:	b8 68       	st.h	r12[0xc],r8
8000e1d4:	d8 22       	popm	r4-r7,pc
8000e1d6:	d7 03       	nop
8000e1d8:	80 01       	ld.sh	r1,r0[0x0]
8000e1da:	9d 1c       	st.w	lr[0x4],r12

8000e1dc <__sinit>:
8000e1dc:	d4 21       	pushm	r4-r7,lr
8000e1de:	18 96       	mov	r6,r12
8000e1e0:	78 67       	ld.w	r7,r12[0x18]
8000e1e2:	58 07       	cp.w	r7,0
8000e1e4:	c4 91       	brne	8000e276 <__sinit+0x9a>
8000e1e6:	fe c8 00 ae 	sub	r8,pc,174
8000e1ea:	30 15       	mov	r5,1
8000e1ec:	99 a8       	st.w	r12[0x28],r8
8000e1ee:	f9 47 00 d8 	st.w	r12[216],r7
8000e1f2:	f9 47 00 dc 	st.w	r12[220],r7
8000e1f6:	f9 47 00 e0 	st.w	r12[224],r7
8000e1fa:	99 65       	st.w	r12[0x18],r5
8000e1fc:	cb 8f       	rcall	8000e16c <__sfp>
8000e1fe:	8d 0c       	st.w	r6[0x0],r12
8000e200:	0c 9c       	mov	r12,r6
8000e202:	cb 5f       	rcall	8000e16c <__sfp>
8000e204:	8d 1c       	st.w	r6[0x4],r12
8000e206:	0c 9c       	mov	r12,r6
8000e208:	cb 2f       	rcall	8000e16c <__sfp>
8000e20a:	6c 09       	ld.w	r9,r6[0x0]
8000e20c:	30 48       	mov	r8,4
8000e20e:	93 07       	st.w	r9[0x0],r7
8000e210:	b2 68       	st.h	r9[0xc],r8
8000e212:	93 17       	st.w	r9[0x4],r7
8000e214:	93 27       	st.w	r9[0x8],r7
8000e216:	6c 18       	ld.w	r8,r6[0x4]
8000e218:	b2 77       	st.h	r9[0xe],r7
8000e21a:	93 47       	st.w	r9[0x10],r7
8000e21c:	93 57       	st.w	r9[0x14],r7
8000e21e:	93 67       	st.w	r9[0x18],r7
8000e220:	93 89       	st.w	r9[0x20],r9
8000e222:	91 07       	st.w	r8[0x0],r7
8000e224:	91 17       	st.w	r8[0x4],r7
8000e226:	91 27       	st.w	r8[0x8],r7
8000e228:	fe ce f3 20 	sub	lr,pc,-3296
8000e22c:	fe cb f3 50 	sub	r11,pc,-3248
8000e230:	93 9e       	st.w	r9[0x24],lr
8000e232:	93 ab       	st.w	r9[0x28],r11
8000e234:	fe ca f3 78 	sub	r10,pc,-3208
8000e238:	fe c4 f3 84 	sub	r4,pc,-3196
8000e23c:	93 ba       	st.w	r9[0x2c],r10
8000e23e:	93 c4       	st.w	r9[0x30],r4
8000e240:	30 99       	mov	r9,9
8000e242:	b0 69       	st.h	r8[0xc],r9
8000e244:	b0 75       	st.h	r8[0xe],r5
8000e246:	91 c4       	st.w	r8[0x30],r4
8000e248:	91 47       	st.w	r8[0x10],r7
8000e24a:	91 57       	st.w	r8[0x14],r7
8000e24c:	91 67       	st.w	r8[0x18],r7
8000e24e:	91 88       	st.w	r8[0x20],r8
8000e250:	91 9e       	st.w	r8[0x24],lr
8000e252:	91 ab       	st.w	r8[0x28],r11
8000e254:	91 ba       	st.w	r8[0x2c],r10
8000e256:	8d 2c       	st.w	r6[0x8],r12
8000e258:	31 28       	mov	r8,18
8000e25a:	99 07       	st.w	r12[0x0],r7
8000e25c:	b8 68       	st.h	r12[0xc],r8
8000e25e:	99 17       	st.w	r12[0x4],r7
8000e260:	99 27       	st.w	r12[0x8],r7
8000e262:	30 28       	mov	r8,2
8000e264:	b8 78       	st.h	r12[0xe],r8
8000e266:	99 c4       	st.w	r12[0x30],r4
8000e268:	99 67       	st.w	r12[0x18],r7
8000e26a:	99 9e       	st.w	r12[0x24],lr
8000e26c:	99 ab       	st.w	r12[0x28],r11
8000e26e:	99 ba       	st.w	r12[0x2c],r10
8000e270:	99 47       	st.w	r12[0x10],r7
8000e272:	99 57       	st.w	r12[0x14],r7
8000e274:	99 8c       	st.w	r12[0x20],r12
8000e276:	d8 22       	popm	r4-r7,pc

8000e278 <_malloc_trim_r>:
8000e278:	d4 21       	pushm	r4-r7,lr
8000e27a:	16 95       	mov	r5,r11
8000e27c:	18 97       	mov	r7,r12
8000e27e:	fe b0 d6 87 	rcall	80008f8c <__malloc_lock>
8000e282:	e0 64 05 38 	mov	r4,1336
8000e286:	68 28       	ld.w	r8,r4[0x8]
8000e288:	70 16       	ld.w	r6,r8[0x4]
8000e28a:	e0 16 ff fc 	andl	r6,0xfffc
8000e28e:	ec c8 ff 91 	sub	r8,r6,-111
8000e292:	f0 05 01 05 	sub	r5,r8,r5
8000e296:	e0 15 ff 80 	andl	r5,0xff80
8000e29a:	ea c5 00 80 	sub	r5,r5,128
8000e29e:	e0 45 00 7f 	cp.w	r5,127
8000e2a2:	e0 8a 00 25 	brle	8000e2ec <_malloc_trim_r+0x74>
8000e2a6:	30 0b       	mov	r11,0
8000e2a8:	0e 9c       	mov	r12,r7
8000e2aa:	fe b0 e5 5f 	rcall	8000ad68 <_sbrk_r>
8000e2ae:	68 28       	ld.w	r8,r4[0x8]
8000e2b0:	0c 08       	add	r8,r6
8000e2b2:	10 3c       	cp.w	r12,r8
8000e2b4:	c1 c1       	brne	8000e2ec <_malloc_trim_r+0x74>
8000e2b6:	ea 0b 11 00 	rsub	r11,r5,0
8000e2ba:	0e 9c       	mov	r12,r7
8000e2bc:	fe b0 e5 56 	rcall	8000ad68 <_sbrk_r>
8000e2c0:	5b fc       	cp.w	r12,-1
8000e2c2:	c1 91       	brne	8000e2f4 <_malloc_trim_r+0x7c>
8000e2c4:	30 0b       	mov	r11,0
8000e2c6:	0e 9c       	mov	r12,r7
8000e2c8:	fe b0 e5 50 	rcall	8000ad68 <_sbrk_r>
8000e2cc:	68 28       	ld.w	r8,r4[0x8]
8000e2ce:	f8 08 01 09 	sub	r9,r12,r8
8000e2d2:	58 f9       	cp.w	r9,15
8000e2d4:	e0 8a 00 0c 	brle	8000e2ec <_malloc_trim_r+0x74>
8000e2d8:	a1 a9       	sbr	r9,0x0
8000e2da:	91 19       	st.w	r8[0x4],r9
8000e2dc:	e0 68 09 44 	mov	r8,2372
8000e2e0:	70 09       	ld.w	r9,r8[0x0]
8000e2e2:	e0 68 13 2c 	mov	r8,4908
8000e2e6:	f8 09 01 09 	sub	r9,r12,r9
8000e2ea:	91 09       	st.w	r8[0x0],r9
8000e2ec:	0e 9c       	mov	r12,r7
8000e2ee:	fe b0 d6 55 	rcall	80008f98 <__malloc_unlock>
8000e2f2:	d8 2a       	popm	r4-r7,pc,r12=0
8000e2f4:	68 28       	ld.w	r8,r4[0x8]
8000e2f6:	0a 16       	sub	r6,r5
8000e2f8:	a1 a6       	sbr	r6,0x0
8000e2fa:	91 16       	st.w	r8[0x4],r6
8000e2fc:	e0 68 13 2c 	mov	r8,4908
8000e300:	70 09       	ld.w	r9,r8[0x0]
8000e302:	0a 19       	sub	r9,r5
8000e304:	0e 9c       	mov	r12,r7
8000e306:	91 09       	st.w	r8[0x0],r9
8000e308:	fe b0 d6 48 	rcall	80008f98 <__malloc_unlock>
8000e30c:	da 2a       	popm	r4-r7,pc,r12=1
8000e30e:	d7 03       	nop

8000e310 <_free_r>:
8000e310:	d4 21       	pushm	r4-r7,lr
8000e312:	16 96       	mov	r6,r11
8000e314:	18 97       	mov	r7,r12
8000e316:	58 0b       	cp.w	r11,0
8000e318:	e0 80 00 c0 	breq	8000e498 <_free_r+0x188>
8000e31c:	fe b0 d6 38 	rcall	80008f8c <__malloc_lock>
8000e320:	20 86       	sub	r6,8
8000e322:	e0 6a 05 38 	mov	r10,1336
8000e326:	6c 18       	ld.w	r8,r6[0x4]
8000e328:	74 2e       	ld.w	lr,r10[0x8]
8000e32a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000e32e:	a1 c8       	cbr	r8,0x0
8000e330:	ec 08 00 09 	add	r9,r6,r8
8000e334:	72 1b       	ld.w	r11,r9[0x4]
8000e336:	e0 1b ff fc 	andl	r11,0xfffc
8000e33a:	1c 39       	cp.w	r9,lr
8000e33c:	c1 e1       	brne	8000e378 <_free_r+0x68>
8000e33e:	f6 08 00 08 	add	r8,r11,r8
8000e342:	58 0c       	cp.w	r12,0
8000e344:	c0 81       	brne	8000e354 <_free_r+0x44>
8000e346:	6c 09       	ld.w	r9,r6[0x0]
8000e348:	12 16       	sub	r6,r9
8000e34a:	12 08       	add	r8,r9
8000e34c:	6c 3b       	ld.w	r11,r6[0xc]
8000e34e:	6c 29       	ld.w	r9,r6[0x8]
8000e350:	97 29       	st.w	r11[0x8],r9
8000e352:	93 3b       	st.w	r9[0xc],r11
8000e354:	10 99       	mov	r9,r8
8000e356:	95 26       	st.w	r10[0x8],r6
8000e358:	a1 a9       	sbr	r9,0x0
8000e35a:	8d 19       	st.w	r6[0x4],r9
8000e35c:	e0 69 09 40 	mov	r9,2368
8000e360:	72 09       	ld.w	r9,r9[0x0]
8000e362:	12 38       	cp.w	r8,r9
8000e364:	c0 63       	brcs	8000e370 <_free_r+0x60>
8000e366:	e0 68 13 28 	mov	r8,4904
8000e36a:	0e 9c       	mov	r12,r7
8000e36c:	70 0b       	ld.w	r11,r8[0x0]
8000e36e:	c8 5f       	rcall	8000e278 <_malloc_trim_r>
8000e370:	0e 9c       	mov	r12,r7
8000e372:	fe b0 d6 13 	rcall	80008f98 <__malloc_unlock>
8000e376:	d8 22       	popm	r4-r7,pc
8000e378:	93 1b       	st.w	r9[0x4],r11
8000e37a:	58 0c       	cp.w	r12,0
8000e37c:	c0 30       	breq	8000e382 <_free_r+0x72>
8000e37e:	30 0c       	mov	r12,0
8000e380:	c1 08       	rjmp	8000e3a0 <_free_r+0x90>
8000e382:	6c 0e       	ld.w	lr,r6[0x0]
8000e384:	f4 c5 ff f8 	sub	r5,r10,-8
8000e388:	1c 16       	sub	r6,lr
8000e38a:	1c 08       	add	r8,lr
8000e38c:	6c 2e       	ld.w	lr,r6[0x8]
8000e38e:	0a 3e       	cp.w	lr,r5
8000e390:	f9 bc 00 01 	moveq	r12,1
8000e394:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000e398:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000e39c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000e3a0:	f2 0b 00 0e 	add	lr,r9,r11
8000e3a4:	7c 1e       	ld.w	lr,lr[0x4]
8000e3a6:	ed be 00 00 	bld	lr,0x0
8000e3aa:	c1 40       	breq	8000e3d2 <_free_r+0xc2>
8000e3ac:	16 08       	add	r8,r11
8000e3ae:	58 0c       	cp.w	r12,0
8000e3b0:	c0 d1       	brne	8000e3ca <_free_r+0xba>
8000e3b2:	e0 6e 05 38 	mov	lr,1336
8000e3b6:	72 2b       	ld.w	r11,r9[0x8]
8000e3b8:	2f 8e       	sub	lr,-8
8000e3ba:	1c 3b       	cp.w	r11,lr
8000e3bc:	c0 71       	brne	8000e3ca <_free_r+0xba>
8000e3be:	97 36       	st.w	r11[0xc],r6
8000e3c0:	97 26       	st.w	r11[0x8],r6
8000e3c2:	8d 2b       	st.w	r6[0x8],r11
8000e3c4:	8d 3b       	st.w	r6[0xc],r11
8000e3c6:	30 1c       	mov	r12,1
8000e3c8:	c0 58       	rjmp	8000e3d2 <_free_r+0xc2>
8000e3ca:	72 2b       	ld.w	r11,r9[0x8]
8000e3cc:	72 39       	ld.w	r9,r9[0xc]
8000e3ce:	93 2b       	st.w	r9[0x8],r11
8000e3d0:	97 39       	st.w	r11[0xc],r9
8000e3d2:	10 99       	mov	r9,r8
8000e3d4:	ec 08 09 08 	st.w	r6[r8],r8
8000e3d8:	a1 a9       	sbr	r9,0x0
8000e3da:	8d 19       	st.w	r6[0x4],r9
8000e3dc:	58 0c       	cp.w	r12,0
8000e3de:	c5 a1       	brne	8000e492 <_free_r+0x182>
8000e3e0:	e0 48 01 ff 	cp.w	r8,511
8000e3e4:	e0 8b 00 13 	brhi	8000e40a <_free_r+0xfa>
8000e3e8:	a3 98       	lsr	r8,0x3
8000e3ea:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000e3ee:	72 2b       	ld.w	r11,r9[0x8]
8000e3f0:	8d 39       	st.w	r6[0xc],r9
8000e3f2:	8d 2b       	st.w	r6[0x8],r11
8000e3f4:	97 36       	st.w	r11[0xc],r6
8000e3f6:	93 26       	st.w	r9[0x8],r6
8000e3f8:	a3 48       	asr	r8,0x2
8000e3fa:	74 19       	ld.w	r9,r10[0x4]
8000e3fc:	30 1b       	mov	r11,1
8000e3fe:	f6 08 09 48 	lsl	r8,r11,r8
8000e402:	f3 e8 10 08 	or	r8,r9,r8
8000e406:	95 18       	st.w	r10[0x4],r8
8000e408:	c4 58       	rjmp	8000e492 <_free_r+0x182>
8000e40a:	f0 0b 16 09 	lsr	r11,r8,0x9
8000e40e:	58 4b       	cp.w	r11,4
8000e410:	e0 8b 00 06 	brhi	8000e41c <_free_r+0x10c>
8000e414:	f0 0b 16 06 	lsr	r11,r8,0x6
8000e418:	2c 8b       	sub	r11,-56
8000e41a:	c2 08       	rjmp	8000e45a <_free_r+0x14a>
8000e41c:	59 4b       	cp.w	r11,20
8000e41e:	e0 8b 00 04 	brhi	8000e426 <_free_r+0x116>
8000e422:	2a 5b       	sub	r11,-91
8000e424:	c1 b8       	rjmp	8000e45a <_free_r+0x14a>
8000e426:	e0 4b 00 54 	cp.w	r11,84
8000e42a:	e0 8b 00 06 	brhi	8000e436 <_free_r+0x126>
8000e42e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000e432:	29 2b       	sub	r11,-110
8000e434:	c1 38       	rjmp	8000e45a <_free_r+0x14a>
8000e436:	e0 4b 01 54 	cp.w	r11,340
8000e43a:	e0 8b 00 06 	brhi	8000e446 <_free_r+0x136>
8000e43e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000e442:	28 9b       	sub	r11,-119
8000e444:	c0 b8       	rjmp	8000e45a <_free_r+0x14a>
8000e446:	e0 4b 05 54 	cp.w	r11,1364
8000e44a:	e0 88 00 05 	brls	8000e454 <_free_r+0x144>
8000e44e:	37 eb       	mov	r11,126
8000e450:	c0 58       	rjmp	8000e45a <_free_r+0x14a>
8000e452:	d7 03       	nop
8000e454:	f0 0b 16 12 	lsr	r11,r8,0x12
8000e458:	28 4b       	sub	r11,-124
8000e45a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000e45e:	78 29       	ld.w	r9,r12[0x8]
8000e460:	18 39       	cp.w	r9,r12
8000e462:	c0 e1       	brne	8000e47e <_free_r+0x16e>
8000e464:	74 18       	ld.w	r8,r10[0x4]
8000e466:	a3 4b       	asr	r11,0x2
8000e468:	30 1c       	mov	r12,1
8000e46a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000e46e:	f1 eb 10 0b 	or	r11,r8,r11
8000e472:	12 98       	mov	r8,r9
8000e474:	95 1b       	st.w	r10[0x4],r11
8000e476:	c0 a8       	rjmp	8000e48a <_free_r+0x17a>
8000e478:	72 29       	ld.w	r9,r9[0x8]
8000e47a:	18 39       	cp.w	r9,r12
8000e47c:	c0 60       	breq	8000e488 <_free_r+0x178>
8000e47e:	72 1a       	ld.w	r10,r9[0x4]
8000e480:	e0 1a ff fc 	andl	r10,0xfffc
8000e484:	14 38       	cp.w	r8,r10
8000e486:	cf 93       	brcs	8000e478 <_free_r+0x168>
8000e488:	72 38       	ld.w	r8,r9[0xc]
8000e48a:	8d 38       	st.w	r6[0xc],r8
8000e48c:	8d 29       	st.w	r6[0x8],r9
8000e48e:	93 36       	st.w	r9[0xc],r6
8000e490:	91 26       	st.w	r8[0x8],r6
8000e492:	0e 9c       	mov	r12,r7
8000e494:	fe b0 d5 82 	rcall	80008f98 <__malloc_unlock>
8000e498:	d8 22       	popm	r4-r7,pc
8000e49a:	d7 03       	nop

8000e49c <__sfvwrite_r>:
8000e49c:	d4 31       	pushm	r0-r7,lr
8000e49e:	20 3d       	sub	sp,12
8000e4a0:	14 94       	mov	r4,r10
8000e4a2:	18 95       	mov	r5,r12
8000e4a4:	16 97       	mov	r7,r11
8000e4a6:	74 28       	ld.w	r8,r10[0x8]
8000e4a8:	58 08       	cp.w	r8,0
8000e4aa:	e0 80 01 40 	breq	8000e72a <__sfvwrite_r+0x28e>
8000e4ae:	96 68       	ld.sh	r8,r11[0xc]
8000e4b0:	ed b8 00 03 	bld	r8,0x3
8000e4b4:	c0 41       	brne	8000e4bc <__sfvwrite_r+0x20>
8000e4b6:	76 48       	ld.w	r8,r11[0x10]
8000e4b8:	58 08       	cp.w	r8,0
8000e4ba:	c0 c1       	brne	8000e4d2 <__sfvwrite_r+0x36>
8000e4bc:	0e 9b       	mov	r11,r7
8000e4be:	0a 9c       	mov	r12,r5
8000e4c0:	fe b0 f6 bc 	rcall	8000d238 <__swsetup_r>
8000e4c4:	c0 70       	breq	8000e4d2 <__sfvwrite_r+0x36>
8000e4c6:	8e 68       	ld.sh	r8,r7[0xc]
8000e4c8:	a7 a8       	sbr	r8,0x6
8000e4ca:	ae 68       	st.h	r7[0xc],r8
8000e4cc:	30 98       	mov	r8,9
8000e4ce:	8b 38       	st.w	r5[0xc],r8
8000e4d0:	c2 b9       	rjmp	8000e726 <__sfvwrite_r+0x28a>
8000e4d2:	8e 63       	ld.sh	r3,r7[0xc]
8000e4d4:	68 00       	ld.w	r0,r4[0x0]
8000e4d6:	06 96       	mov	r6,r3
8000e4d8:	e2 16 00 02 	andl	r6,0x2,COH
8000e4dc:	c2 10       	breq	8000e51e <__sfvwrite_r+0x82>
8000e4de:	30 03       	mov	r3,0
8000e4e0:	e0 62 04 00 	mov	r2,1024
8000e4e4:	06 96       	mov	r6,r3
8000e4e6:	c0 48       	rjmp	8000e4ee <__sfvwrite_r+0x52>
8000e4e8:	60 03       	ld.w	r3,r0[0x0]
8000e4ea:	60 16       	ld.w	r6,r0[0x4]
8000e4ec:	2f 80       	sub	r0,-8
8000e4ee:	58 06       	cp.w	r6,0
8000e4f0:	cf c0       	breq	8000e4e8 <__sfvwrite_r+0x4c>
8000e4f2:	e0 46 04 00 	cp.w	r6,1024
8000e4f6:	ec 09 17 80 	movls	r9,r6
8000e4fa:	e4 09 17 b0 	movhi	r9,r2
8000e4fe:	06 9a       	mov	r10,r3
8000e500:	6e a8       	ld.w	r8,r7[0x28]
8000e502:	6e 8b       	ld.w	r11,r7[0x20]
8000e504:	0a 9c       	mov	r12,r5
8000e506:	5d 18       	icall	r8
8000e508:	18 16       	sub	r6,r12
8000e50a:	58 0c       	cp.w	r12,0
8000e50c:	e0 8a 01 0a 	brle	8000e720 <__sfvwrite_r+0x284>
8000e510:	68 28       	ld.w	r8,r4[0x8]
8000e512:	18 18       	sub	r8,r12
8000e514:	89 28       	st.w	r4[0x8],r8
8000e516:	e0 80 01 0a 	breq	8000e72a <__sfvwrite_r+0x28e>
8000e51a:	18 03       	add	r3,r12
8000e51c:	ce 9b       	rjmp	8000e4ee <__sfvwrite_r+0x52>
8000e51e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000e522:	c0 70       	breq	8000e530 <__sfvwrite_r+0x94>
8000e524:	50 06       	stdsp	sp[0x0],r6
8000e526:	0c 93       	mov	r3,r6
8000e528:	0c 91       	mov	r1,r6
8000e52a:	50 15       	stdsp	sp[0x4],r5
8000e52c:	08 92       	mov	r2,r4
8000e52e:	c9 c8       	rjmp	8000e666 <__sfvwrite_r+0x1ca>
8000e530:	06 96       	mov	r6,r3
8000e532:	08 91       	mov	r1,r4
8000e534:	c0 48       	rjmp	8000e53c <__sfvwrite_r+0xa0>
8000e536:	60 03       	ld.w	r3,r0[0x0]
8000e538:	60 16       	ld.w	r6,r0[0x4]
8000e53a:	2f 80       	sub	r0,-8
8000e53c:	58 06       	cp.w	r6,0
8000e53e:	cf c0       	breq	8000e536 <__sfvwrite_r+0x9a>
8000e540:	8e 68       	ld.sh	r8,r7[0xc]
8000e542:	6e 24       	ld.w	r4,r7[0x8]
8000e544:	10 99       	mov	r9,r8
8000e546:	e2 19 02 00 	andl	r9,0x200,COH
8000e54a:	c5 50       	breq	8000e5f4 <__sfvwrite_r+0x158>
8000e54c:	08 36       	cp.w	r6,r4
8000e54e:	c4 43       	brcs	8000e5d6 <__sfvwrite_r+0x13a>
8000e550:	10 99       	mov	r9,r8
8000e552:	e2 19 04 80 	andl	r9,0x480,COH
8000e556:	c4 00       	breq	8000e5d6 <__sfvwrite_r+0x13a>
8000e558:	6e 4b       	ld.w	r11,r7[0x10]
8000e55a:	6e 09       	ld.w	r9,r7[0x0]
8000e55c:	16 19       	sub	r9,r11
8000e55e:	50 09       	stdsp	sp[0x0],r9
8000e560:	6e 59       	ld.w	r9,r7[0x14]
8000e562:	10 9c       	mov	r12,r8
8000e564:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000e568:	30 28       	mov	r8,2
8000e56a:	f4 08 0c 08 	divs	r8,r10,r8
8000e56e:	fa e9 00 04 	st.d	sp[4],r8
8000e572:	10 94       	mov	r4,r8
8000e574:	40 09       	lddsp	r9,sp[0x0]
8000e576:	e2 1c 04 00 	andl	r12,0x400,COH
8000e57a:	2f f9       	sub	r9,-1
8000e57c:	0c 09       	add	r9,r6
8000e57e:	12 38       	cp.w	r8,r9
8000e580:	f2 04 17 30 	movlo	r4,r9
8000e584:	58 0c       	cp.w	r12,0
8000e586:	c1 10       	breq	8000e5a8 <__sfvwrite_r+0x10c>
8000e588:	08 9b       	mov	r11,r4
8000e58a:	0a 9c       	mov	r12,r5
8000e58c:	fe b0 df b4 	rcall	8000a4f4 <_malloc_r>
8000e590:	18 92       	mov	r2,r12
8000e592:	c1 40       	breq	8000e5ba <__sfvwrite_r+0x11e>
8000e594:	40 0a       	lddsp	r10,sp[0x0]
8000e596:	6e 4b       	ld.w	r11,r7[0x10]
8000e598:	fe b0 e1 dd 	rcall	8000a952 <memcpy>
8000e59c:	8e 68       	ld.sh	r8,r7[0xc]
8000e59e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000e5a2:	a7 b8       	sbr	r8,0x7
8000e5a4:	ae 68       	st.h	r7[0xc],r8
8000e5a6:	c0 d8       	rjmp	8000e5c0 <__sfvwrite_r+0x124>
8000e5a8:	08 9a       	mov	r10,r4
8000e5aa:	0a 9c       	mov	r12,r5
8000e5ac:	fe b0 e2 7e 	rcall	8000aaa8 <_realloc_r>
8000e5b0:	18 92       	mov	r2,r12
8000e5b2:	c0 71       	brne	8000e5c0 <__sfvwrite_r+0x124>
8000e5b4:	6e 4b       	ld.w	r11,r7[0x10]
8000e5b6:	0a 9c       	mov	r12,r5
8000e5b8:	ca ce       	rcall	8000e310 <_free_r>
8000e5ba:	30 c8       	mov	r8,12
8000e5bc:	8b 38       	st.w	r5[0xc],r8
8000e5be:	cb 18       	rjmp	8000e720 <__sfvwrite_r+0x284>
8000e5c0:	40 0a       	lddsp	r10,sp[0x0]
8000e5c2:	40 09       	lddsp	r9,sp[0x0]
8000e5c4:	e8 0a 01 0a 	sub	r10,r4,r10
8000e5c8:	e4 09 00 08 	add	r8,r2,r9
8000e5cc:	8f 54       	st.w	r7[0x14],r4
8000e5ce:	8f 2a       	st.w	r7[0x8],r10
8000e5d0:	8f 08       	st.w	r7[0x0],r8
8000e5d2:	8f 42       	st.w	r7[0x10],r2
8000e5d4:	0c 94       	mov	r4,r6
8000e5d6:	08 36       	cp.w	r6,r4
8000e5d8:	ec 04 17 30 	movlo	r4,r6
8000e5dc:	06 9b       	mov	r11,r3
8000e5de:	08 9a       	mov	r10,r4
8000e5e0:	6e 0c       	ld.w	r12,r7[0x0]
8000e5e2:	c3 ad       	rcall	8000e856 <memmove>
8000e5e4:	6e 08       	ld.w	r8,r7[0x0]
8000e5e6:	08 08       	add	r8,r4
8000e5e8:	8f 08       	st.w	r7[0x0],r8
8000e5ea:	6e 28       	ld.w	r8,r7[0x8]
8000e5ec:	08 18       	sub	r8,r4
8000e5ee:	0c 94       	mov	r4,r6
8000e5f0:	8f 28       	st.w	r7[0x8],r8
8000e5f2:	c2 e8       	rjmp	8000e64e <__sfvwrite_r+0x1b2>
8000e5f4:	08 36       	cp.w	r6,r4
8000e5f6:	5f ba       	srhi	r10
8000e5f8:	6e 0c       	ld.w	r12,r7[0x0]
8000e5fa:	6e 48       	ld.w	r8,r7[0x10]
8000e5fc:	10 3c       	cp.w	r12,r8
8000e5fe:	5f b8       	srhi	r8
8000e600:	f5 e8 00 08 	and	r8,r10,r8
8000e604:	f2 08 18 00 	cp.b	r8,r9
8000e608:	c0 d0       	breq	8000e622 <__sfvwrite_r+0x186>
8000e60a:	06 9b       	mov	r11,r3
8000e60c:	08 9a       	mov	r10,r4
8000e60e:	c2 4d       	rcall	8000e856 <memmove>
8000e610:	6e 08       	ld.w	r8,r7[0x0]
8000e612:	08 08       	add	r8,r4
8000e614:	0e 9b       	mov	r11,r7
8000e616:	8f 08       	st.w	r7[0x0],r8
8000e618:	0a 9c       	mov	r12,r5
8000e61a:	fe b0 fd 05 	rcall	8000e024 <_fflush_r>
8000e61e:	c1 80       	breq	8000e64e <__sfvwrite_r+0x1b2>
8000e620:	c8 08       	rjmp	8000e720 <__sfvwrite_r+0x284>
8000e622:	6e 59       	ld.w	r9,r7[0x14]
8000e624:	12 36       	cp.w	r6,r9
8000e626:	c0 a3       	brcs	8000e63a <__sfvwrite_r+0x19e>
8000e628:	6e a8       	ld.w	r8,r7[0x28]
8000e62a:	06 9a       	mov	r10,r3
8000e62c:	6e 8b       	ld.w	r11,r7[0x20]
8000e62e:	0a 9c       	mov	r12,r5
8000e630:	5d 18       	icall	r8
8000e632:	18 94       	mov	r4,r12
8000e634:	e0 89 00 0d 	brgt	8000e64e <__sfvwrite_r+0x1b2>
8000e638:	c7 48       	rjmp	8000e720 <__sfvwrite_r+0x284>
8000e63a:	0c 9a       	mov	r10,r6
8000e63c:	06 9b       	mov	r11,r3
8000e63e:	c0 cd       	rcall	8000e856 <memmove>
8000e640:	6e 08       	ld.w	r8,r7[0x0]
8000e642:	0c 08       	add	r8,r6
8000e644:	0c 94       	mov	r4,r6
8000e646:	8f 08       	st.w	r7[0x0],r8
8000e648:	6e 28       	ld.w	r8,r7[0x8]
8000e64a:	0c 18       	sub	r8,r6
8000e64c:	8f 28       	st.w	r7[0x8],r8
8000e64e:	62 28       	ld.w	r8,r1[0x8]
8000e650:	08 18       	sub	r8,r4
8000e652:	83 28       	st.w	r1[0x8],r8
8000e654:	c6 b0       	breq	8000e72a <__sfvwrite_r+0x28e>
8000e656:	08 16       	sub	r6,r4
8000e658:	08 03       	add	r3,r4
8000e65a:	c7 1b       	rjmp	8000e53c <__sfvwrite_r+0xa0>
8000e65c:	60 03       	ld.w	r3,r0[0x0]
8000e65e:	60 11       	ld.w	r1,r0[0x4]
8000e660:	30 08       	mov	r8,0
8000e662:	2f 80       	sub	r0,-8
8000e664:	50 08       	stdsp	sp[0x0],r8
8000e666:	58 01       	cp.w	r1,0
8000e668:	cf a0       	breq	8000e65c <__sfvwrite_r+0x1c0>
8000e66a:	40 0a       	lddsp	r10,sp[0x0]
8000e66c:	58 0a       	cp.w	r10,0
8000e66e:	c1 41       	brne	8000e696 <__sfvwrite_r+0x1fa>
8000e670:	e2 c6 ff ff 	sub	r6,r1,-1
8000e674:	02 9a       	mov	r10,r1
8000e676:	30 ab       	mov	r11,10
8000e678:	06 9c       	mov	r12,r3
8000e67a:	ce 3c       	rcall	8000e840 <memchr>
8000e67c:	f8 c8 ff ff 	sub	r8,r12,-1
8000e680:	58 0c       	cp.w	r12,0
8000e682:	f1 d3 e1 16 	subne	r6,r8,r3
8000e686:	f9 b9 01 01 	movne	r9,1
8000e68a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e68e:	f9 b8 00 01 	moveq	r8,1
8000e692:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000e696:	02 36       	cp.w	r6,r1
8000e698:	ec 04 17 80 	movls	r4,r6
8000e69c:	e2 04 17 b0 	movhi	r4,r1
8000e6a0:	6e 59       	ld.w	r9,r7[0x14]
8000e6a2:	6e 25       	ld.w	r5,r7[0x8]
8000e6a4:	f2 05 00 05 	add	r5,r9,r5
8000e6a8:	0a 34       	cp.w	r4,r5
8000e6aa:	5f 9a       	srgt	r10
8000e6ac:	6e 0c       	ld.w	r12,r7[0x0]
8000e6ae:	6e 48       	ld.w	r8,r7[0x10]
8000e6b0:	10 3c       	cp.w	r12,r8
8000e6b2:	5f b8       	srhi	r8
8000e6b4:	f5 e8 00 08 	and	r8,r10,r8
8000e6b8:	30 0a       	mov	r10,0
8000e6ba:	f4 08 18 00 	cp.b	r8,r10
8000e6be:	c0 d0       	breq	8000e6d8 <__sfvwrite_r+0x23c>
8000e6c0:	06 9b       	mov	r11,r3
8000e6c2:	0a 9a       	mov	r10,r5
8000e6c4:	cc 9c       	rcall	8000e856 <memmove>
8000e6c6:	6e 08       	ld.w	r8,r7[0x0]
8000e6c8:	0a 08       	add	r8,r5
8000e6ca:	0e 9b       	mov	r11,r7
8000e6cc:	8f 08       	st.w	r7[0x0],r8
8000e6ce:	40 1c       	lddsp	r12,sp[0x4]
8000e6d0:	fe b0 fc aa 	rcall	8000e024 <_fflush_r>
8000e6d4:	c1 70       	breq	8000e702 <__sfvwrite_r+0x266>
8000e6d6:	c2 58       	rjmp	8000e720 <__sfvwrite_r+0x284>
8000e6d8:	12 34       	cp.w	r4,r9
8000e6da:	c0 a5       	brlt	8000e6ee <__sfvwrite_r+0x252>
8000e6dc:	6e a8       	ld.w	r8,r7[0x28]
8000e6de:	06 9a       	mov	r10,r3
8000e6e0:	6e 8b       	ld.w	r11,r7[0x20]
8000e6e2:	40 1c       	lddsp	r12,sp[0x4]
8000e6e4:	5d 18       	icall	r8
8000e6e6:	18 95       	mov	r5,r12
8000e6e8:	e0 89 00 0d 	brgt	8000e702 <__sfvwrite_r+0x266>
8000e6ec:	c1 a8       	rjmp	8000e720 <__sfvwrite_r+0x284>
8000e6ee:	08 9a       	mov	r10,r4
8000e6f0:	06 9b       	mov	r11,r3
8000e6f2:	cb 2c       	rcall	8000e856 <memmove>
8000e6f4:	6e 08       	ld.w	r8,r7[0x0]
8000e6f6:	08 08       	add	r8,r4
8000e6f8:	08 95       	mov	r5,r4
8000e6fa:	8f 08       	st.w	r7[0x0],r8
8000e6fc:	6e 28       	ld.w	r8,r7[0x8]
8000e6fe:	08 18       	sub	r8,r4
8000e700:	8f 28       	st.w	r7[0x8],r8
8000e702:	0a 16       	sub	r6,r5
8000e704:	c0 71       	brne	8000e712 <__sfvwrite_r+0x276>
8000e706:	0e 9b       	mov	r11,r7
8000e708:	40 1c       	lddsp	r12,sp[0x4]
8000e70a:	fe b0 fc 8d 	rcall	8000e024 <_fflush_r>
8000e70e:	c0 91       	brne	8000e720 <__sfvwrite_r+0x284>
8000e710:	50 06       	stdsp	sp[0x0],r6
8000e712:	64 28       	ld.w	r8,r2[0x8]
8000e714:	0a 18       	sub	r8,r5
8000e716:	85 28       	st.w	r2[0x8],r8
8000e718:	c0 90       	breq	8000e72a <__sfvwrite_r+0x28e>
8000e71a:	0a 11       	sub	r1,r5
8000e71c:	0a 03       	add	r3,r5
8000e71e:	ca 4b       	rjmp	8000e666 <__sfvwrite_r+0x1ca>
8000e720:	8e 68       	ld.sh	r8,r7[0xc]
8000e722:	a7 a8       	sbr	r8,0x6
8000e724:	ae 68       	st.h	r7[0xc],r8
8000e726:	3f fc       	mov	r12,-1
8000e728:	c0 28       	rjmp	8000e72c <__sfvwrite_r+0x290>
8000e72a:	30 0c       	mov	r12,0
8000e72c:	2f dd       	sub	sp,-12
8000e72e:	d8 32       	popm	r0-r7,pc

8000e730 <_fwalk>:
8000e730:	d4 31       	pushm	r0-r7,lr
8000e732:	30 05       	mov	r5,0
8000e734:	16 91       	mov	r1,r11
8000e736:	f8 c7 ff 28 	sub	r7,r12,-216
8000e73a:	0a 92       	mov	r2,r5
8000e73c:	fe b0 fc fc 	rcall	8000e134 <__sfp_lock_acquire>
8000e740:	3f f3       	mov	r3,-1
8000e742:	c1 68       	rjmp	8000e76e <_fwalk+0x3e>
8000e744:	6e 26       	ld.w	r6,r7[0x8]
8000e746:	6e 14       	ld.w	r4,r7[0x4]
8000e748:	2f 46       	sub	r6,-12
8000e74a:	c0 c8       	rjmp	8000e762 <_fwalk+0x32>
8000e74c:	8c 08       	ld.sh	r8,r6[0x0]
8000e74e:	e4 08 19 00 	cp.h	r8,r2
8000e752:	c0 70       	breq	8000e760 <_fwalk+0x30>
8000e754:	8c 18       	ld.sh	r8,r6[0x2]
8000e756:	e6 08 19 00 	cp.h	r8,r3
8000e75a:	c0 30       	breq	8000e760 <_fwalk+0x30>
8000e75c:	5d 11       	icall	r1
8000e75e:	18 45       	or	r5,r12
8000e760:	2a 46       	sub	r6,-92
8000e762:	20 14       	sub	r4,1
8000e764:	ec cc 00 0c 	sub	r12,r6,12
8000e768:	58 04       	cp.w	r4,0
8000e76a:	cf 14       	brge	8000e74c <_fwalk+0x1c>
8000e76c:	6e 07       	ld.w	r7,r7[0x0]
8000e76e:	58 07       	cp.w	r7,0
8000e770:	ce a1       	brne	8000e744 <_fwalk+0x14>
8000e772:	fe b0 fc e2 	rcall	8000e136 <__sfp_lock_release>
8000e776:	0a 9c       	mov	r12,r5
8000e778:	d8 32       	popm	r0-r7,pc
8000e77a:	d7 03       	nop

8000e77c <_localeconv_r>:
8000e77c:	48 1c       	lddpc	r12,8000e780 <_localeconv_r+0x4>
8000e77e:	5e fc       	retal	r12
8000e780:	80 01       	ld.sh	r1,r0[0x0]
8000e782:	9d 20       	st.w	lr[0x8],r0

8000e784 <__smakebuf_r>:
8000e784:	d4 21       	pushm	r4-r7,lr
8000e786:	20 fd       	sub	sp,60
8000e788:	96 68       	ld.sh	r8,r11[0xc]
8000e78a:	16 97       	mov	r7,r11
8000e78c:	18 96       	mov	r6,r12
8000e78e:	e2 18 00 02 	andl	r8,0x2,COH
8000e792:	c3 d1       	brne	8000e80c <__smakebuf_r+0x88>
8000e794:	96 7b       	ld.sh	r11,r11[0xe]
8000e796:	f0 0b 19 00 	cp.h	r11,r8
8000e79a:	c0 55       	brlt	8000e7a4 <__smakebuf_r+0x20>
8000e79c:	1a 9a       	mov	r10,sp
8000e79e:	e0 a0 04 79 	rcall	8000f090 <_fstat_r>
8000e7a2:	c0 f4       	brge	8000e7c0 <__smakebuf_r+0x3c>
8000e7a4:	8e 65       	ld.sh	r5,r7[0xc]
8000e7a6:	0a 98       	mov	r8,r5
8000e7a8:	ab b8       	sbr	r8,0xb
8000e7aa:	e2 15 00 80 	andl	r5,0x80,COH
8000e7ae:	ae 68       	st.h	r7[0xc],r8
8000e7b0:	30 04       	mov	r4,0
8000e7b2:	e0 68 04 00 	mov	r8,1024
8000e7b6:	f9 b5 01 40 	movne	r5,64
8000e7ba:	f0 05 17 00 	moveq	r5,r8
8000e7be:	c1 c8       	rjmp	8000e7f6 <__smakebuf_r+0x72>
8000e7c0:	40 18       	lddsp	r8,sp[0x4]
8000e7c2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000e7c6:	e0 48 20 00 	cp.w	r8,8192
8000e7ca:	5f 04       	sreq	r4
8000e7cc:	e0 48 80 00 	cp.w	r8,32768
8000e7d0:	c0 e1       	brne	8000e7ec <__smakebuf_r+0x68>
8000e7d2:	6e b9       	ld.w	r9,r7[0x2c]
8000e7d4:	fe c8 f9 18 	sub	r8,pc,-1768
8000e7d8:	10 39       	cp.w	r9,r8
8000e7da:	c0 91       	brne	8000e7ec <__smakebuf_r+0x68>
8000e7dc:	8e 68       	ld.sh	r8,r7[0xc]
8000e7de:	e0 65 04 00 	mov	r5,1024
8000e7e2:	ab a8       	sbr	r8,0xa
8000e7e4:	ef 45 00 50 	st.w	r7[80],r5
8000e7e8:	ae 68       	st.h	r7[0xc],r8
8000e7ea:	c0 68       	rjmp	8000e7f6 <__smakebuf_r+0x72>
8000e7ec:	8e 68       	ld.sh	r8,r7[0xc]
8000e7ee:	e0 65 04 00 	mov	r5,1024
8000e7f2:	ab b8       	sbr	r8,0xb
8000e7f4:	ae 68       	st.h	r7[0xc],r8
8000e7f6:	0a 9b       	mov	r11,r5
8000e7f8:	0c 9c       	mov	r12,r6
8000e7fa:	fe b0 de 7d 	rcall	8000a4f4 <_malloc_r>
8000e7fe:	8e 68       	ld.sh	r8,r7[0xc]
8000e800:	c0 d1       	brne	8000e81a <__smakebuf_r+0x96>
8000e802:	ed b8 00 09 	bld	r8,0x9
8000e806:	c1 b0       	breq	8000e83c <__smakebuf_r+0xb8>
8000e808:	a1 b8       	sbr	r8,0x1
8000e80a:	ae 68       	st.h	r7[0xc],r8
8000e80c:	ee c8 ff b9 	sub	r8,r7,-71
8000e810:	8f 48       	st.w	r7[0x10],r8
8000e812:	8f 08       	st.w	r7[0x0],r8
8000e814:	30 18       	mov	r8,1
8000e816:	8f 58       	st.w	r7[0x14],r8
8000e818:	c1 28       	rjmp	8000e83c <__smakebuf_r+0xb8>
8000e81a:	a7 b8       	sbr	r8,0x7
8000e81c:	8f 4c       	st.w	r7[0x10],r12
8000e81e:	ae 68       	st.h	r7[0xc],r8
8000e820:	8f 55       	st.w	r7[0x14],r5
8000e822:	fe c8 06 ea 	sub	r8,pc,1770
8000e826:	8f 0c       	st.w	r7[0x0],r12
8000e828:	8d a8       	st.w	r6[0x28],r8
8000e82a:	58 04       	cp.w	r4,0
8000e82c:	c0 80       	breq	8000e83c <__smakebuf_r+0xb8>
8000e82e:	8e 7c       	ld.sh	r12,r7[0xe]
8000e830:	fe b0 e3 7a 	rcall	8000af24 <isatty>
8000e834:	c0 40       	breq	8000e83c <__smakebuf_r+0xb8>
8000e836:	8e 68       	ld.sh	r8,r7[0xc]
8000e838:	a1 a8       	sbr	r8,0x0
8000e83a:	ae 68       	st.h	r7[0xc],r8
8000e83c:	2f 1d       	sub	sp,-60
8000e83e:	d8 22       	popm	r4-r7,pc

8000e840 <memchr>:
8000e840:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000e844:	c0 68       	rjmp	8000e850 <memchr+0x10>
8000e846:	20 1a       	sub	r10,1
8000e848:	19 88       	ld.ub	r8,r12[0x0]
8000e84a:	16 38       	cp.w	r8,r11
8000e84c:	5e 0c       	reteq	r12
8000e84e:	2f fc       	sub	r12,-1
8000e850:	58 0a       	cp.w	r10,0
8000e852:	cf a1       	brne	8000e846 <memchr+0x6>
8000e854:	5e fa       	retal	r10

8000e856 <memmove>:
8000e856:	d4 01       	pushm	lr
8000e858:	18 3b       	cp.w	r11,r12
8000e85a:	c1 92       	brcc	8000e88c <memmove+0x36>
8000e85c:	f6 0a 00 09 	add	r9,r11,r10
8000e860:	12 3c       	cp.w	r12,r9
8000e862:	c1 52       	brcc	8000e88c <memmove+0x36>
8000e864:	f8 0a 00 0b 	add	r11,r12,r10
8000e868:	30 08       	mov	r8,0
8000e86a:	c0 68       	rjmp	8000e876 <memmove+0x20>
8000e86c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000e870:	20 1a       	sub	r10,1
8000e872:	f6 08 0b 0e 	st.b	r11[r8],lr
8000e876:	20 18       	sub	r8,1
8000e878:	58 0a       	cp.w	r10,0
8000e87a:	cf 91       	brne	8000e86c <memmove+0x16>
8000e87c:	d8 02       	popm	pc
8000e87e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000e882:	20 1a       	sub	r10,1
8000e884:	f8 08 0b 09 	st.b	r12[r8],r9
8000e888:	2f f8       	sub	r8,-1
8000e88a:	c0 28       	rjmp	8000e88e <memmove+0x38>
8000e88c:	30 08       	mov	r8,0
8000e88e:	58 0a       	cp.w	r10,0
8000e890:	cf 71       	brne	8000e87e <memmove+0x28>
8000e892:	d8 02       	popm	pc

8000e894 <__hi0bits>:
8000e894:	18 98       	mov	r8,r12
8000e896:	e0 1c 00 00 	andl	r12,0x0
8000e89a:	f0 09 15 10 	lsl	r9,r8,0x10
8000e89e:	58 0c       	cp.w	r12,0
8000e8a0:	f2 08 17 00 	moveq	r8,r9
8000e8a4:	f9 bc 00 10 	moveq	r12,16
8000e8a8:	f9 bc 01 00 	movne	r12,0
8000e8ac:	10 9a       	mov	r10,r8
8000e8ae:	f0 09 15 08 	lsl	r9,r8,0x8
8000e8b2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000e8b6:	f7 bc 00 f8 	subeq	r12,-8
8000e8ba:	f2 08 17 00 	moveq	r8,r9
8000e8be:	10 9a       	mov	r10,r8
8000e8c0:	f0 09 15 04 	lsl	r9,r8,0x4
8000e8c4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000e8c8:	f7 bc 00 fc 	subeq	r12,-4
8000e8cc:	f2 08 17 00 	moveq	r8,r9
8000e8d0:	10 9a       	mov	r10,r8
8000e8d2:	f0 09 15 02 	lsl	r9,r8,0x2
8000e8d6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000e8da:	f7 bc 00 fe 	subeq	r12,-2
8000e8de:	f2 08 17 00 	moveq	r8,r9
8000e8e2:	58 08       	cp.w	r8,0
8000e8e4:	5e 5c       	retlt	r12
8000e8e6:	ed b8 00 1e 	bld	r8,0x1e
8000e8ea:	f9 bc 01 20 	movne	r12,32
8000e8ee:	f7 bc 00 ff 	subeq	r12,-1
8000e8f2:	5e fc       	retal	r12

8000e8f4 <__lo0bits>:
8000e8f4:	18 99       	mov	r9,r12
8000e8f6:	78 08       	ld.w	r8,r12[0x0]
8000e8f8:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000e8fc:	c1 50       	breq	8000e926 <__lo0bits+0x32>
8000e8fe:	ed b8 00 00 	bld	r8,0x0
8000e902:	c0 21       	brne	8000e906 <__lo0bits+0x12>
8000e904:	5e fd       	retal	0
8000e906:	10 9b       	mov	r11,r8
8000e908:	f0 0a 16 01 	lsr	r10,r8,0x1
8000e90c:	e2 1b 00 02 	andl	r11,0x2,COH
8000e910:	a3 88       	lsr	r8,0x2
8000e912:	58 0b       	cp.w	r11,0
8000e914:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000e918:	f9 bc 01 01 	movne	r12,1
8000e91c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000e920:	f9 bc 00 02 	moveq	r12,2
8000e924:	5e fc       	retal	r12
8000e926:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000e92a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000e92e:	58 0a       	cp.w	r10,0
8000e930:	f6 08 17 00 	moveq	r8,r11
8000e934:	f9 bc 00 10 	moveq	r12,16
8000e938:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000e93c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000e940:	58 0b       	cp.w	r11,0
8000e942:	f7 bc 00 f8 	subeq	r12,-8
8000e946:	f4 08 17 00 	moveq	r8,r10
8000e94a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000e94e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000e952:	58 0b       	cp.w	r11,0
8000e954:	f7 bc 00 fc 	subeq	r12,-4
8000e958:	f4 08 17 00 	moveq	r8,r10
8000e95c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000e960:	f0 0a 16 02 	lsr	r10,r8,0x2
8000e964:	58 0b       	cp.w	r11,0
8000e966:	f7 bc 00 fe 	subeq	r12,-2
8000e96a:	f4 08 17 00 	moveq	r8,r10
8000e96e:	ed b8 00 00 	bld	r8,0x0
8000e972:	c0 60       	breq	8000e97e <__lo0bits+0x8a>
8000e974:	a1 98       	lsr	r8,0x1
8000e976:	c0 31       	brne	8000e97c <__lo0bits+0x88>
8000e978:	32 0c       	mov	r12,32
8000e97a:	5e fc       	retal	r12
8000e97c:	2f fc       	sub	r12,-1
8000e97e:	93 08       	st.w	r9[0x0],r8
8000e980:	5e fc       	retal	r12

8000e982 <__mcmp>:
8000e982:	d4 01       	pushm	lr
8000e984:	18 98       	mov	r8,r12
8000e986:	76 49       	ld.w	r9,r11[0x10]
8000e988:	78 4c       	ld.w	r12,r12[0x10]
8000e98a:	12 1c       	sub	r12,r9
8000e98c:	c1 31       	brne	8000e9b2 <__mcmp+0x30>
8000e98e:	2f b9       	sub	r9,-5
8000e990:	a3 69       	lsl	r9,0x2
8000e992:	12 0b       	add	r11,r9
8000e994:	f0 09 00 09 	add	r9,r8,r9
8000e998:	2e c8       	sub	r8,-20
8000e99a:	13 4e       	ld.w	lr,--r9
8000e99c:	17 4a       	ld.w	r10,--r11
8000e99e:	14 3e       	cp.w	lr,r10
8000e9a0:	c0 60       	breq	8000e9ac <__mcmp+0x2a>
8000e9a2:	f9 bc 03 ff 	movlo	r12,-1
8000e9a6:	f9 bc 02 01 	movhs	r12,1
8000e9aa:	d8 02       	popm	pc
8000e9ac:	10 39       	cp.w	r9,r8
8000e9ae:	fe 9b ff f6 	brhi	8000e99a <__mcmp+0x18>
8000e9b2:	d8 02       	popm	pc

8000e9b4 <_Bfree>:
8000e9b4:	d4 21       	pushm	r4-r7,lr
8000e9b6:	18 97       	mov	r7,r12
8000e9b8:	16 95       	mov	r5,r11
8000e9ba:	78 96       	ld.w	r6,r12[0x24]
8000e9bc:	58 06       	cp.w	r6,0
8000e9be:	c0 91       	brne	8000e9d0 <_Bfree+0x1c>
8000e9c0:	31 0c       	mov	r12,16
8000e9c2:	fe b0 dd 91 	rcall	8000a4e4 <malloc>
8000e9c6:	99 36       	st.w	r12[0xc],r6
8000e9c8:	8f 9c       	st.w	r7[0x24],r12
8000e9ca:	99 16       	st.w	r12[0x4],r6
8000e9cc:	99 26       	st.w	r12[0x8],r6
8000e9ce:	99 06       	st.w	r12[0x0],r6
8000e9d0:	58 05       	cp.w	r5,0
8000e9d2:	c0 90       	breq	8000e9e4 <_Bfree+0x30>
8000e9d4:	6a 19       	ld.w	r9,r5[0x4]
8000e9d6:	6e 98       	ld.w	r8,r7[0x24]
8000e9d8:	70 38       	ld.w	r8,r8[0xc]
8000e9da:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000e9de:	8b 0a       	st.w	r5[0x0],r10
8000e9e0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000e9e4:	d8 22       	popm	r4-r7,pc
8000e9e6:	d7 03       	nop

8000e9e8 <_Balloc>:
8000e9e8:	d4 21       	pushm	r4-r7,lr
8000e9ea:	18 97       	mov	r7,r12
8000e9ec:	16 96       	mov	r6,r11
8000e9ee:	78 95       	ld.w	r5,r12[0x24]
8000e9f0:	58 05       	cp.w	r5,0
8000e9f2:	c0 91       	brne	8000ea04 <_Balloc+0x1c>
8000e9f4:	31 0c       	mov	r12,16
8000e9f6:	fe b0 dd 77 	rcall	8000a4e4 <malloc>
8000e9fa:	99 35       	st.w	r12[0xc],r5
8000e9fc:	8f 9c       	st.w	r7[0x24],r12
8000e9fe:	99 15       	st.w	r12[0x4],r5
8000ea00:	99 25       	st.w	r12[0x8],r5
8000ea02:	99 05       	st.w	r12[0x0],r5
8000ea04:	6e 95       	ld.w	r5,r7[0x24]
8000ea06:	6a 38       	ld.w	r8,r5[0xc]
8000ea08:	58 08       	cp.w	r8,0
8000ea0a:	c0 b1       	brne	8000ea20 <_Balloc+0x38>
8000ea0c:	31 0a       	mov	r10,16
8000ea0e:	30 4b       	mov	r11,4
8000ea10:	0e 9c       	mov	r12,r7
8000ea12:	e0 a0 02 9d 	rcall	8000ef4c <_calloc_r>
8000ea16:	8b 3c       	st.w	r5[0xc],r12
8000ea18:	6e 98       	ld.w	r8,r7[0x24]
8000ea1a:	70 3c       	ld.w	r12,r8[0xc]
8000ea1c:	58 0c       	cp.w	r12,0
8000ea1e:	c1 b0       	breq	8000ea54 <_Balloc+0x6c>
8000ea20:	6e 98       	ld.w	r8,r7[0x24]
8000ea22:	70 38       	ld.w	r8,r8[0xc]
8000ea24:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000ea28:	70 0c       	ld.w	r12,r8[0x0]
8000ea2a:	58 0c       	cp.w	r12,0
8000ea2c:	c0 40       	breq	8000ea34 <_Balloc+0x4c>
8000ea2e:	78 09       	ld.w	r9,r12[0x0]
8000ea30:	91 09       	st.w	r8[0x0],r9
8000ea32:	c0 e8       	rjmp	8000ea4e <_Balloc+0x66>
8000ea34:	0e 9c       	mov	r12,r7
8000ea36:	30 17       	mov	r7,1
8000ea38:	0e 9b       	mov	r11,r7
8000ea3a:	ee 06 09 47 	lsl	r7,r7,r6
8000ea3e:	ee ca ff fb 	sub	r10,r7,-5
8000ea42:	a3 6a       	lsl	r10,0x2
8000ea44:	e0 a0 02 84 	rcall	8000ef4c <_calloc_r>
8000ea48:	c0 60       	breq	8000ea54 <_Balloc+0x6c>
8000ea4a:	99 16       	st.w	r12[0x4],r6
8000ea4c:	99 27       	st.w	r12[0x8],r7
8000ea4e:	30 08       	mov	r8,0
8000ea50:	99 38       	st.w	r12[0xc],r8
8000ea52:	99 48       	st.w	r12[0x10],r8
8000ea54:	d8 22       	popm	r4-r7,pc
8000ea56:	d7 03       	nop

8000ea58 <__d2b>:
8000ea58:	d4 31       	pushm	r0-r7,lr
8000ea5a:	20 2d       	sub	sp,8
8000ea5c:	16 93       	mov	r3,r11
8000ea5e:	12 96       	mov	r6,r9
8000ea60:	10 95       	mov	r5,r8
8000ea62:	14 92       	mov	r2,r10
8000ea64:	30 1b       	mov	r11,1
8000ea66:	cc 1f       	rcall	8000e9e8 <_Balloc>
8000ea68:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000ea6c:	50 09       	stdsp	sp[0x0],r9
8000ea6e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000ea72:	b5 a9       	sbr	r9,0x14
8000ea74:	f0 01 16 14 	lsr	r1,r8,0x14
8000ea78:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ea7c:	18 94       	mov	r4,r12
8000ea7e:	58 02       	cp.w	r2,0
8000ea80:	c1 d0       	breq	8000eaba <__d2b+0x62>
8000ea82:	fa cc ff f8 	sub	r12,sp,-8
8000ea86:	18 d2       	st.w	--r12,r2
8000ea88:	c3 6f       	rcall	8000e8f4 <__lo0bits>
8000ea8a:	40 18       	lddsp	r8,sp[0x4]
8000ea8c:	c0 d0       	breq	8000eaa6 <__d2b+0x4e>
8000ea8e:	40 09       	lddsp	r9,sp[0x0]
8000ea90:	f8 0a 11 20 	rsub	r10,r12,32
8000ea94:	f2 0a 09 4a 	lsl	r10,r9,r10
8000ea98:	f5 e8 10 08 	or	r8,r10,r8
8000ea9c:	89 58       	st.w	r4[0x14],r8
8000ea9e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000eaa2:	50 09       	stdsp	sp[0x0],r9
8000eaa4:	c0 28       	rjmp	8000eaa8 <__d2b+0x50>
8000eaa6:	89 58       	st.w	r4[0x14],r8
8000eaa8:	40 08       	lddsp	r8,sp[0x0]
8000eaaa:	58 08       	cp.w	r8,0
8000eaac:	f9 b3 01 02 	movne	r3,2
8000eab0:	f9 b3 00 01 	moveq	r3,1
8000eab4:	89 68       	st.w	r4[0x18],r8
8000eab6:	89 43       	st.w	r4[0x10],r3
8000eab8:	c0 88       	rjmp	8000eac8 <__d2b+0x70>
8000eaba:	1a 9c       	mov	r12,sp
8000eabc:	c1 cf       	rcall	8000e8f4 <__lo0bits>
8000eabe:	30 13       	mov	r3,1
8000eac0:	40 08       	lddsp	r8,sp[0x0]
8000eac2:	2e 0c       	sub	r12,-32
8000eac4:	89 43       	st.w	r4[0x10],r3
8000eac6:	89 58       	st.w	r4[0x14],r8
8000eac8:	58 01       	cp.w	r1,0
8000eaca:	c0 90       	breq	8000eadc <__d2b+0x84>
8000eacc:	e2 c1 04 33 	sub	r1,r1,1075
8000ead0:	18 01       	add	r1,r12
8000ead2:	8d 01       	st.w	r6[0x0],r1
8000ead4:	f8 0c 11 35 	rsub	r12,r12,53
8000ead8:	8b 0c       	st.w	r5[0x0],r12
8000eada:	c0 c8       	rjmp	8000eaf2 <__d2b+0x9a>
8000eadc:	e6 c8 ff fc 	sub	r8,r3,-4
8000eae0:	f8 cc 04 32 	sub	r12,r12,1074
8000eae4:	a5 73       	lsl	r3,0x5
8000eae6:	8d 0c       	st.w	r6[0x0],r12
8000eae8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000eaec:	cd 4e       	rcall	8000e894 <__hi0bits>
8000eaee:	18 13       	sub	r3,r12
8000eaf0:	8b 03       	st.w	r5[0x0],r3
8000eaf2:	08 9c       	mov	r12,r4
8000eaf4:	2f ed       	sub	sp,-8
8000eaf6:	d8 32       	popm	r0-r7,pc

8000eaf8 <__mdiff>:
8000eaf8:	d4 31       	pushm	r0-r7,lr
8000eafa:	74 48       	ld.w	r8,r10[0x10]
8000eafc:	76 45       	ld.w	r5,r11[0x10]
8000eafe:	16 97       	mov	r7,r11
8000eb00:	14 96       	mov	r6,r10
8000eb02:	10 15       	sub	r5,r8
8000eb04:	c1 31       	brne	8000eb2a <__mdiff+0x32>
8000eb06:	2f b8       	sub	r8,-5
8000eb08:	ee ce ff ec 	sub	lr,r7,-20
8000eb0c:	a3 68       	lsl	r8,0x2
8000eb0e:	f4 08 00 0b 	add	r11,r10,r8
8000eb12:	ee 08 00 08 	add	r8,r7,r8
8000eb16:	11 4a       	ld.w	r10,--r8
8000eb18:	17 49       	ld.w	r9,--r11
8000eb1a:	12 3a       	cp.w	r10,r9
8000eb1c:	c0 30       	breq	8000eb22 <__mdiff+0x2a>
8000eb1e:	c0 e2       	brcc	8000eb3a <__mdiff+0x42>
8000eb20:	c0 78       	rjmp	8000eb2e <__mdiff+0x36>
8000eb22:	1c 38       	cp.w	r8,lr
8000eb24:	fe 9b ff f9 	brhi	8000eb16 <__mdiff+0x1e>
8000eb28:	c4 98       	rjmp	8000ebba <__mdiff+0xc2>
8000eb2a:	58 05       	cp.w	r5,0
8000eb2c:	c0 64       	brge	8000eb38 <__mdiff+0x40>
8000eb2e:	0e 98       	mov	r8,r7
8000eb30:	30 15       	mov	r5,1
8000eb32:	0c 97       	mov	r7,r6
8000eb34:	10 96       	mov	r6,r8
8000eb36:	c0 28       	rjmp	8000eb3a <__mdiff+0x42>
8000eb38:	30 05       	mov	r5,0
8000eb3a:	6e 1b       	ld.w	r11,r7[0x4]
8000eb3c:	c5 6f       	rcall	8000e9e8 <_Balloc>
8000eb3e:	6e 49       	ld.w	r9,r7[0x10]
8000eb40:	6c 44       	ld.w	r4,r6[0x10]
8000eb42:	99 35       	st.w	r12[0xc],r5
8000eb44:	2f b4       	sub	r4,-5
8000eb46:	f2 c5 ff fb 	sub	r5,r9,-5
8000eb4a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000eb4e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000eb52:	2e c6       	sub	r6,-20
8000eb54:	2e c7       	sub	r7,-20
8000eb56:	f8 c8 ff ec 	sub	r8,r12,-20
8000eb5a:	30 0a       	mov	r10,0
8000eb5c:	0f 0e       	ld.w	lr,r7++
8000eb5e:	0d 0b       	ld.w	r11,r6++
8000eb60:	fc 02 16 10 	lsr	r2,lr,0x10
8000eb64:	f6 03 16 10 	lsr	r3,r11,0x10
8000eb68:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000eb6c:	e4 03 01 03 	sub	r3,r2,r3
8000eb70:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000eb74:	fc 0b 01 0b 	sub	r11,lr,r11
8000eb78:	f6 0a 00 0a 	add	r10,r11,r10
8000eb7c:	b0 1a       	st.h	r8[0x2],r10
8000eb7e:	b1 4a       	asr	r10,0x10
8000eb80:	e6 0a 00 0a 	add	r10,r3,r10
8000eb84:	b0 0a       	st.h	r8[0x0],r10
8000eb86:	2f c8       	sub	r8,-4
8000eb88:	b1 4a       	asr	r10,0x10
8000eb8a:	08 36       	cp.w	r6,r4
8000eb8c:	ce 83       	brcs	8000eb5c <__mdiff+0x64>
8000eb8e:	c0 d8       	rjmp	8000eba8 <__mdiff+0xb0>
8000eb90:	0f 0b       	ld.w	r11,r7++
8000eb92:	f6 0e 16 10 	lsr	lr,r11,0x10
8000eb96:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000eb9a:	16 0a       	add	r10,r11
8000eb9c:	b0 1a       	st.h	r8[0x2],r10
8000eb9e:	b1 4a       	asr	r10,0x10
8000eba0:	1c 0a       	add	r10,lr
8000eba2:	b0 0a       	st.h	r8[0x0],r10
8000eba4:	2f c8       	sub	r8,-4
8000eba6:	b1 4a       	asr	r10,0x10
8000eba8:	0a 37       	cp.w	r7,r5
8000ebaa:	cf 33       	brcs	8000eb90 <__mdiff+0x98>
8000ebac:	c0 28       	rjmp	8000ebb0 <__mdiff+0xb8>
8000ebae:	20 19       	sub	r9,1
8000ebb0:	11 4a       	ld.w	r10,--r8
8000ebb2:	58 0a       	cp.w	r10,0
8000ebb4:	cf d0       	breq	8000ebae <__mdiff+0xb6>
8000ebb6:	99 49       	st.w	r12[0x10],r9
8000ebb8:	d8 32       	popm	r0-r7,pc
8000ebba:	30 0b       	mov	r11,0
8000ebbc:	c1 6f       	rcall	8000e9e8 <_Balloc>
8000ebbe:	30 18       	mov	r8,1
8000ebc0:	99 48       	st.w	r12[0x10],r8
8000ebc2:	30 08       	mov	r8,0
8000ebc4:	99 58       	st.w	r12[0x14],r8
8000ebc6:	d8 32       	popm	r0-r7,pc

8000ebc8 <__lshift>:
8000ebc8:	d4 31       	pushm	r0-r7,lr
8000ebca:	16 97       	mov	r7,r11
8000ebcc:	76 46       	ld.w	r6,r11[0x10]
8000ebce:	f4 02 14 05 	asr	r2,r10,0x5
8000ebd2:	2f f6       	sub	r6,-1
8000ebd4:	14 93       	mov	r3,r10
8000ebd6:	18 94       	mov	r4,r12
8000ebd8:	04 06       	add	r6,r2
8000ebda:	76 1b       	ld.w	r11,r11[0x4]
8000ebdc:	6e 28       	ld.w	r8,r7[0x8]
8000ebde:	c0 38       	rjmp	8000ebe4 <__lshift+0x1c>
8000ebe0:	2f fb       	sub	r11,-1
8000ebe2:	a1 78       	lsl	r8,0x1
8000ebe4:	10 36       	cp.w	r6,r8
8000ebe6:	fe 99 ff fd 	brgt	8000ebe0 <__lshift+0x18>
8000ebea:	08 9c       	mov	r12,r4
8000ebec:	cf ee       	rcall	8000e9e8 <_Balloc>
8000ebee:	30 09       	mov	r9,0
8000ebf0:	18 95       	mov	r5,r12
8000ebf2:	f8 c8 ff ec 	sub	r8,r12,-20
8000ebf6:	12 9a       	mov	r10,r9
8000ebf8:	c0 38       	rjmp	8000ebfe <__lshift+0x36>
8000ebfa:	10 aa       	st.w	r8++,r10
8000ebfc:	2f f9       	sub	r9,-1
8000ebfe:	04 39       	cp.w	r9,r2
8000ec00:	cf d5       	brlt	8000ebfa <__lshift+0x32>
8000ec02:	6e 4b       	ld.w	r11,r7[0x10]
8000ec04:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ec08:	2f bb       	sub	r11,-5
8000ec0a:	ee c9 ff ec 	sub	r9,r7,-20
8000ec0e:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ec12:	58 03       	cp.w	r3,0
8000ec14:	c1 30       	breq	8000ec3a <__lshift+0x72>
8000ec16:	e6 0c 11 20 	rsub	r12,r3,32
8000ec1a:	30 0a       	mov	r10,0
8000ec1c:	72 02       	ld.w	r2,r9[0x0]
8000ec1e:	e4 03 09 42 	lsl	r2,r2,r3
8000ec22:	04 4a       	or	r10,r2
8000ec24:	10 aa       	st.w	r8++,r10
8000ec26:	13 0a       	ld.w	r10,r9++
8000ec28:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ec2c:	16 39       	cp.w	r9,r11
8000ec2e:	cf 73       	brcs	8000ec1c <__lshift+0x54>
8000ec30:	91 0a       	st.w	r8[0x0],r10
8000ec32:	58 0a       	cp.w	r10,0
8000ec34:	c0 70       	breq	8000ec42 <__lshift+0x7a>
8000ec36:	2f f6       	sub	r6,-1
8000ec38:	c0 58       	rjmp	8000ec42 <__lshift+0x7a>
8000ec3a:	13 0a       	ld.w	r10,r9++
8000ec3c:	10 aa       	st.w	r8++,r10
8000ec3e:	16 39       	cp.w	r9,r11
8000ec40:	cf d3       	brcs	8000ec3a <__lshift+0x72>
8000ec42:	08 9c       	mov	r12,r4
8000ec44:	20 16       	sub	r6,1
8000ec46:	0e 9b       	mov	r11,r7
8000ec48:	8b 46       	st.w	r5[0x10],r6
8000ec4a:	cb 5e       	rcall	8000e9b4 <_Bfree>
8000ec4c:	0a 9c       	mov	r12,r5
8000ec4e:	d8 32       	popm	r0-r7,pc

8000ec50 <__multiply>:
8000ec50:	d4 31       	pushm	r0-r7,lr
8000ec52:	20 2d       	sub	sp,8
8000ec54:	76 49       	ld.w	r9,r11[0x10]
8000ec56:	74 48       	ld.w	r8,r10[0x10]
8000ec58:	16 96       	mov	r6,r11
8000ec5a:	14 95       	mov	r5,r10
8000ec5c:	10 39       	cp.w	r9,r8
8000ec5e:	ec 08 17 50 	movlt	r8,r6
8000ec62:	ea 06 17 50 	movlt	r6,r5
8000ec66:	f0 05 17 50 	movlt	r5,r8
8000ec6a:	6c 28       	ld.w	r8,r6[0x8]
8000ec6c:	76 43       	ld.w	r3,r11[0x10]
8000ec6e:	74 42       	ld.w	r2,r10[0x10]
8000ec70:	76 1b       	ld.w	r11,r11[0x4]
8000ec72:	e4 03 00 07 	add	r7,r2,r3
8000ec76:	10 37       	cp.w	r7,r8
8000ec78:	f7 bb 09 ff 	subgt	r11,-1
8000ec7c:	cb 6e       	rcall	8000e9e8 <_Balloc>
8000ec7e:	ee c4 ff fb 	sub	r4,r7,-5
8000ec82:	f8 c9 ff ec 	sub	r9,r12,-20
8000ec86:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ec8a:	30 0a       	mov	r10,0
8000ec8c:	12 98       	mov	r8,r9
8000ec8e:	c0 28       	rjmp	8000ec92 <__multiply+0x42>
8000ec90:	10 aa       	st.w	r8++,r10
8000ec92:	08 38       	cp.w	r8,r4
8000ec94:	cf e3       	brcs	8000ec90 <__multiply+0x40>
8000ec96:	2f b3       	sub	r3,-5
8000ec98:	2f b2       	sub	r2,-5
8000ec9a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ec9e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000eca2:	ec cb ff ec 	sub	r11,r6,-20
8000eca6:	50 12       	stdsp	sp[0x4],r2
8000eca8:	ea ca ff ec 	sub	r10,r5,-20
8000ecac:	c4 48       	rjmp	8000ed34 <__multiply+0xe4>
8000ecae:	94 95       	ld.uh	r5,r10[0x2]
8000ecb0:	58 05       	cp.w	r5,0
8000ecb2:	c2 00       	breq	8000ecf2 <__multiply+0xa2>
8000ecb4:	12 98       	mov	r8,r9
8000ecb6:	16 96       	mov	r6,r11
8000ecb8:	30 0e       	mov	lr,0
8000ecba:	50 09       	stdsp	sp[0x0],r9
8000ecbc:	0d 02       	ld.w	r2,r6++
8000ecbe:	e4 00 16 10 	lsr	r0,r2,0x10
8000ecc2:	70 01       	ld.w	r1,r8[0x0]
8000ecc4:	70 09       	ld.w	r9,r8[0x0]
8000ecc6:	b1 81       	lsr	r1,0x10
8000ecc8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000eccc:	e0 05 03 41 	mac	r1,r0,r5
8000ecd0:	ab 32       	mul	r2,r5
8000ecd2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ecd6:	00 02       	add	r2,r0
8000ecd8:	e4 0e 00 0e 	add	lr,r2,lr
8000ecdc:	b0 1e       	st.h	r8[0x2],lr
8000ecde:	b1 8e       	lsr	lr,0x10
8000ece0:	1c 01       	add	r1,lr
8000ece2:	b0 01       	st.h	r8[0x0],r1
8000ece4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ece8:	2f c8       	sub	r8,-4
8000ecea:	06 36       	cp.w	r6,r3
8000ecec:	ce 83       	brcs	8000ecbc <__multiply+0x6c>
8000ecee:	40 09       	lddsp	r9,sp[0x0]
8000ecf0:	91 0e       	st.w	r8[0x0],lr
8000ecf2:	94 86       	ld.uh	r6,r10[0x0]
8000ecf4:	58 06       	cp.w	r6,0
8000ecf6:	c1 d0       	breq	8000ed30 <__multiply+0xe0>
8000ecf8:	72 02       	ld.w	r2,r9[0x0]
8000ecfa:	12 98       	mov	r8,r9
8000ecfc:	16 9e       	mov	lr,r11
8000ecfe:	30 05       	mov	r5,0
8000ed00:	b0 12       	st.h	r8[0x2],r2
8000ed02:	1d 01       	ld.w	r1,lr++
8000ed04:	90 82       	ld.uh	r2,r8[0x0]
8000ed06:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ed0a:	ad 30       	mul	r0,r6
8000ed0c:	e0 02 00 02 	add	r2,r0,r2
8000ed10:	e4 05 00 05 	add	r5,r2,r5
8000ed14:	b0 05       	st.h	r8[0x0],r5
8000ed16:	b1 85       	lsr	r5,0x10
8000ed18:	b1 81       	lsr	r1,0x10
8000ed1a:	2f c8       	sub	r8,-4
8000ed1c:	ad 31       	mul	r1,r6
8000ed1e:	90 92       	ld.uh	r2,r8[0x2]
8000ed20:	e2 02 00 02 	add	r2,r1,r2
8000ed24:	0a 02       	add	r2,r5
8000ed26:	e4 05 16 10 	lsr	r5,r2,0x10
8000ed2a:	06 3e       	cp.w	lr,r3
8000ed2c:	ce a3       	brcs	8000ed00 <__multiply+0xb0>
8000ed2e:	91 02       	st.w	r8[0x0],r2
8000ed30:	2f ca       	sub	r10,-4
8000ed32:	2f c9       	sub	r9,-4
8000ed34:	40 18       	lddsp	r8,sp[0x4]
8000ed36:	10 3a       	cp.w	r10,r8
8000ed38:	cb b3       	brcs	8000ecae <__multiply+0x5e>
8000ed3a:	c0 28       	rjmp	8000ed3e <__multiply+0xee>
8000ed3c:	20 17       	sub	r7,1
8000ed3e:	58 07       	cp.w	r7,0
8000ed40:	e0 8a 00 05 	brle	8000ed4a <__multiply+0xfa>
8000ed44:	09 48       	ld.w	r8,--r4
8000ed46:	58 08       	cp.w	r8,0
8000ed48:	cf a0       	breq	8000ed3c <__multiply+0xec>
8000ed4a:	99 47       	st.w	r12[0x10],r7
8000ed4c:	2f ed       	sub	sp,-8
8000ed4e:	d8 32       	popm	r0-r7,pc

8000ed50 <__i2b>:
8000ed50:	d4 21       	pushm	r4-r7,lr
8000ed52:	16 97       	mov	r7,r11
8000ed54:	30 1b       	mov	r11,1
8000ed56:	c4 9e       	rcall	8000e9e8 <_Balloc>
8000ed58:	30 19       	mov	r9,1
8000ed5a:	99 57       	st.w	r12[0x14],r7
8000ed5c:	99 49       	st.w	r12[0x10],r9
8000ed5e:	d8 22       	popm	r4-r7,pc

8000ed60 <__multadd>:
8000ed60:	d4 31       	pushm	r0-r7,lr
8000ed62:	30 08       	mov	r8,0
8000ed64:	12 95       	mov	r5,r9
8000ed66:	16 97       	mov	r7,r11
8000ed68:	18 96       	mov	r6,r12
8000ed6a:	76 44       	ld.w	r4,r11[0x10]
8000ed6c:	f6 c9 ff ec 	sub	r9,r11,-20
8000ed70:	72 0b       	ld.w	r11,r9[0x0]
8000ed72:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ed76:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ed7a:	f4 0c 02 4c 	mul	r12,r10,r12
8000ed7e:	f4 0b 03 45 	mac	r5,r10,r11
8000ed82:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ed86:	b1 85       	lsr	r5,0x10
8000ed88:	18 05       	add	r5,r12
8000ed8a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ed8e:	f8 0b 00 0b 	add	r11,r12,r11
8000ed92:	12 ab       	st.w	r9++,r11
8000ed94:	2f f8       	sub	r8,-1
8000ed96:	b1 85       	lsr	r5,0x10
8000ed98:	08 38       	cp.w	r8,r4
8000ed9a:	ce b5       	brlt	8000ed70 <__multadd+0x10>
8000ed9c:	58 05       	cp.w	r5,0
8000ed9e:	c1 c0       	breq	8000edd6 <__multadd+0x76>
8000eda0:	6e 28       	ld.w	r8,r7[0x8]
8000eda2:	10 34       	cp.w	r4,r8
8000eda4:	c1 35       	brlt	8000edca <__multadd+0x6a>
8000eda6:	6e 1b       	ld.w	r11,r7[0x4]
8000eda8:	0c 9c       	mov	r12,r6
8000edaa:	2f fb       	sub	r11,-1
8000edac:	c1 ee       	rcall	8000e9e8 <_Balloc>
8000edae:	6e 4a       	ld.w	r10,r7[0x10]
8000edb0:	ee cb ff f4 	sub	r11,r7,-12
8000edb4:	18 93       	mov	r3,r12
8000edb6:	2f ea       	sub	r10,-2
8000edb8:	2f 4c       	sub	r12,-12
8000edba:	a3 6a       	lsl	r10,0x2
8000edbc:	fe b0 dd cb 	rcall	8000a952 <memcpy>
8000edc0:	0e 9b       	mov	r11,r7
8000edc2:	0c 9c       	mov	r12,r6
8000edc4:	fe b0 fd f8 	rcall	8000e9b4 <_Bfree>
8000edc8:	06 97       	mov	r7,r3
8000edca:	e8 c8 ff ff 	sub	r8,r4,-1
8000edce:	2f b4       	sub	r4,-5
8000edd0:	8f 48       	st.w	r7[0x10],r8
8000edd2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000edd6:	0e 9c       	mov	r12,r7
8000edd8:	d8 32       	popm	r0-r7,pc
8000edda:	d7 03       	nop

8000eddc <__pow5mult>:
8000eddc:	d4 31       	pushm	r0-r7,lr
8000edde:	14 96       	mov	r6,r10
8000ede0:	18 97       	mov	r7,r12
8000ede2:	16 94       	mov	r4,r11
8000ede4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ede8:	c0 80       	breq	8000edf8 <__pow5mult+0x1c>
8000edea:	20 18       	sub	r8,1
8000edec:	49 f9       	lddpc	r9,8000ee68 <__pow5mult+0x8c>
8000edee:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000edf2:	30 09       	mov	r9,0
8000edf4:	cb 6f       	rcall	8000ed60 <__multadd>
8000edf6:	18 94       	mov	r4,r12
8000edf8:	a3 46       	asr	r6,0x2
8000edfa:	c3 40       	breq	8000ee62 <__pow5mult+0x86>
8000edfc:	6e 95       	ld.w	r5,r7[0x24]
8000edfe:	58 05       	cp.w	r5,0
8000ee00:	c0 91       	brne	8000ee12 <__pow5mult+0x36>
8000ee02:	31 0c       	mov	r12,16
8000ee04:	fe b0 db 70 	rcall	8000a4e4 <malloc>
8000ee08:	99 35       	st.w	r12[0xc],r5
8000ee0a:	8f 9c       	st.w	r7[0x24],r12
8000ee0c:	99 15       	st.w	r12[0x4],r5
8000ee0e:	99 25       	st.w	r12[0x8],r5
8000ee10:	99 05       	st.w	r12[0x0],r5
8000ee12:	6e 93       	ld.w	r3,r7[0x24]
8000ee14:	66 25       	ld.w	r5,r3[0x8]
8000ee16:	58 05       	cp.w	r5,0
8000ee18:	c0 c1       	brne	8000ee30 <__pow5mult+0x54>
8000ee1a:	e0 6b 02 71 	mov	r11,625
8000ee1e:	0e 9c       	mov	r12,r7
8000ee20:	c9 8f       	rcall	8000ed50 <__i2b>
8000ee22:	87 2c       	st.w	r3[0x8],r12
8000ee24:	30 08       	mov	r8,0
8000ee26:	18 95       	mov	r5,r12
8000ee28:	99 08       	st.w	r12[0x0],r8
8000ee2a:	c0 38       	rjmp	8000ee30 <__pow5mult+0x54>
8000ee2c:	06 9c       	mov	r12,r3
8000ee2e:	18 95       	mov	r5,r12
8000ee30:	ed b6 00 00 	bld	r6,0x0
8000ee34:	c0 b1       	brne	8000ee4a <__pow5mult+0x6e>
8000ee36:	08 9b       	mov	r11,r4
8000ee38:	0a 9a       	mov	r10,r5
8000ee3a:	0e 9c       	mov	r12,r7
8000ee3c:	c0 af       	rcall	8000ec50 <__multiply>
8000ee3e:	08 9b       	mov	r11,r4
8000ee40:	18 93       	mov	r3,r12
8000ee42:	0e 9c       	mov	r12,r7
8000ee44:	06 94       	mov	r4,r3
8000ee46:	fe b0 fd b7 	rcall	8000e9b4 <_Bfree>
8000ee4a:	a1 56       	asr	r6,0x1
8000ee4c:	c0 b0       	breq	8000ee62 <__pow5mult+0x86>
8000ee4e:	6a 03       	ld.w	r3,r5[0x0]
8000ee50:	58 03       	cp.w	r3,0
8000ee52:	ce d1       	brne	8000ee2c <__pow5mult+0x50>
8000ee54:	0a 9a       	mov	r10,r5
8000ee56:	0a 9b       	mov	r11,r5
8000ee58:	0e 9c       	mov	r12,r7
8000ee5a:	cf be       	rcall	8000ec50 <__multiply>
8000ee5c:	8b 0c       	st.w	r5[0x0],r12
8000ee5e:	99 03       	st.w	r12[0x0],r3
8000ee60:	ce 7b       	rjmp	8000ee2e <__pow5mult+0x52>
8000ee62:	08 9c       	mov	r12,r4
8000ee64:	d8 32       	popm	r0-r7,pc
8000ee66:	d7 03       	nop
8000ee68:	80 01       	ld.sh	r1,r0[0x0]
8000ee6a:	9d 5c       	st.w	lr[0x14],r12

8000ee6c <__isinfd>:
8000ee6c:	14 98       	mov	r8,r10
8000ee6e:	fc 19 7f f0 	movh	r9,0x7ff0
8000ee72:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ee76:	f0 0b 11 00 	rsub	r11,r8,0
8000ee7a:	f7 e8 10 08 	or	r8,r11,r8
8000ee7e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ee82:	f2 08 01 08 	sub	r8,r9,r8
8000ee86:	f0 0c 11 00 	rsub	r12,r8,0
8000ee8a:	f9 e8 10 08 	or	r8,r12,r8
8000ee8e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ee92:	2f fc       	sub	r12,-1
8000ee94:	5e fc       	retal	r12

8000ee96 <__isnand>:
8000ee96:	14 98       	mov	r8,r10
8000ee98:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ee9c:	f0 0c 11 00 	rsub	r12,r8,0
8000eea0:	10 4c       	or	r12,r8
8000eea2:	fc 18 7f f0 	movh	r8,0x7ff0
8000eea6:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000eeaa:	f0 0c 01 0c 	sub	r12,r8,r12
8000eeae:	bf 9c       	lsr	r12,0x1f
8000eeb0:	5e fc       	retal	r12
8000eeb2:	d7 03       	nop

8000eeb4 <__sclose>:
8000eeb4:	d4 01       	pushm	lr
8000eeb6:	96 7b       	ld.sh	r11,r11[0xe]
8000eeb8:	c7 6c       	rcall	8000efa4 <_close_r>
8000eeba:	d8 02       	popm	pc

8000eebc <__sseek>:
8000eebc:	d4 21       	pushm	r4-r7,lr
8000eebe:	16 97       	mov	r7,r11
8000eec0:	96 7b       	ld.sh	r11,r11[0xe]
8000eec2:	cf 9c       	rcall	8000f0b4 <_lseek_r>
8000eec4:	8e 68       	ld.sh	r8,r7[0xc]
8000eec6:	10 99       	mov	r9,r8
8000eec8:	ad c8       	cbr	r8,0xc
8000eeca:	ad a9       	sbr	r9,0xc
8000eecc:	5b fc       	cp.w	r12,-1
8000eece:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000eed2:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000eed6:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000eeda:	d8 22       	popm	r4-r7,pc

8000eedc <__swrite>:
8000eedc:	d4 21       	pushm	r4-r7,lr
8000eede:	96 68       	ld.sh	r8,r11[0xc]
8000eee0:	16 97       	mov	r7,r11
8000eee2:	14 95       	mov	r5,r10
8000eee4:	12 94       	mov	r4,r9
8000eee6:	e2 18 01 00 	andl	r8,0x100,COH
8000eeea:	18 96       	mov	r6,r12
8000eeec:	c0 50       	breq	8000eef6 <__swrite+0x1a>
8000eeee:	30 29       	mov	r9,2
8000eef0:	30 0a       	mov	r10,0
8000eef2:	96 7b       	ld.sh	r11,r11[0xe]
8000eef4:	ce 0c       	rcall	8000f0b4 <_lseek_r>
8000eef6:	8e 68       	ld.sh	r8,r7[0xc]
8000eef8:	ad c8       	cbr	r8,0xc
8000eefa:	08 99       	mov	r9,r4
8000eefc:	0a 9a       	mov	r10,r5
8000eefe:	8e 7b       	ld.sh	r11,r7[0xe]
8000ef00:	0c 9c       	mov	r12,r6
8000ef02:	ae 68       	st.h	r7[0xc],r8
8000ef04:	c1 0c       	rcall	8000ef24 <_write_r>
8000ef06:	d8 22       	popm	r4-r7,pc

8000ef08 <__sread>:
8000ef08:	d4 21       	pushm	r4-r7,lr
8000ef0a:	16 97       	mov	r7,r11
8000ef0c:	96 7b       	ld.sh	r11,r11[0xe]
8000ef0e:	ce 7c       	rcall	8000f0dc <_read_r>
8000ef10:	c0 65       	brlt	8000ef1c <__sread+0x14>
8000ef12:	6f 58       	ld.w	r8,r7[0x54]
8000ef14:	18 08       	add	r8,r12
8000ef16:	ef 48 00 54 	st.w	r7[84],r8
8000ef1a:	d8 22       	popm	r4-r7,pc
8000ef1c:	8e 68       	ld.sh	r8,r7[0xc]
8000ef1e:	ad c8       	cbr	r8,0xc
8000ef20:	ae 68       	st.h	r7[0xc],r8
8000ef22:	d8 22       	popm	r4-r7,pc

8000ef24 <_write_r>:
8000ef24:	d4 21       	pushm	r4-r7,lr
8000ef26:	16 98       	mov	r8,r11
8000ef28:	18 97       	mov	r7,r12
8000ef2a:	10 9c       	mov	r12,r8
8000ef2c:	30 08       	mov	r8,0
8000ef2e:	14 9b       	mov	r11,r10
8000ef30:	e0 66 46 b4 	mov	r6,18100
8000ef34:	12 9a       	mov	r10,r9
8000ef36:	8d 08       	st.w	r6[0x0],r8
8000ef38:	fe b0 d0 56 	rcall	80008fe4 <_write>
8000ef3c:	5b fc       	cp.w	r12,-1
8000ef3e:	c0 51       	brne	8000ef48 <_write_r+0x24>
8000ef40:	6c 08       	ld.w	r8,r6[0x0]
8000ef42:	58 08       	cp.w	r8,0
8000ef44:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ef48:	d8 22       	popm	r4-r7,pc
8000ef4a:	d7 03       	nop

8000ef4c <_calloc_r>:
8000ef4c:	d4 21       	pushm	r4-r7,lr
8000ef4e:	f4 0b 02 4b 	mul	r11,r10,r11
8000ef52:	fe b0 da d1 	rcall	8000a4f4 <_malloc_r>
8000ef56:	18 97       	mov	r7,r12
8000ef58:	c2 30       	breq	8000ef9e <_calloc_r+0x52>
8000ef5a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000ef5e:	e0 1a ff fc 	andl	r10,0xfffc
8000ef62:	20 4a       	sub	r10,4
8000ef64:	e0 4a 00 24 	cp.w	r10,36
8000ef68:	e0 8b 00 18 	brhi	8000ef98 <_calloc_r+0x4c>
8000ef6c:	18 98       	mov	r8,r12
8000ef6e:	59 3a       	cp.w	r10,19
8000ef70:	e0 88 00 0f 	brls	8000ef8e <_calloc_r+0x42>
8000ef74:	30 09       	mov	r9,0
8000ef76:	10 a9       	st.w	r8++,r9
8000ef78:	10 a9       	st.w	r8++,r9
8000ef7a:	59 ba       	cp.w	r10,27
8000ef7c:	e0 88 00 09 	brls	8000ef8e <_calloc_r+0x42>
8000ef80:	10 a9       	st.w	r8++,r9
8000ef82:	10 a9       	st.w	r8++,r9
8000ef84:	e0 4a 00 24 	cp.w	r10,36
8000ef88:	c0 31       	brne	8000ef8e <_calloc_r+0x42>
8000ef8a:	10 a9       	st.w	r8++,r9
8000ef8c:	10 a9       	st.w	r8++,r9
8000ef8e:	30 09       	mov	r9,0
8000ef90:	10 a9       	st.w	r8++,r9
8000ef92:	91 19       	st.w	r8[0x4],r9
8000ef94:	91 09       	st.w	r8[0x0],r9
8000ef96:	c0 48       	rjmp	8000ef9e <_calloc_r+0x52>
8000ef98:	30 0b       	mov	r11,0
8000ef9a:	fe b0 dd 80 	rcall	8000aa9a <memset>
8000ef9e:	0e 9c       	mov	r12,r7
8000efa0:	d8 22       	popm	r4-r7,pc
8000efa2:	d7 03       	nop

8000efa4 <_close_r>:
8000efa4:	d4 21       	pushm	r4-r7,lr
8000efa6:	30 08       	mov	r8,0
8000efa8:	18 97       	mov	r7,r12
8000efaa:	e0 66 46 b4 	mov	r6,18100
8000efae:	16 9c       	mov	r12,r11
8000efb0:	8d 08       	st.w	r6[0x0],r8
8000efb2:	fe b0 df a5 	rcall	8000aefc <_close>
8000efb6:	5b fc       	cp.w	r12,-1
8000efb8:	c0 51       	brne	8000efc2 <_close_r+0x1e>
8000efba:	6c 08       	ld.w	r8,r6[0x0]
8000efbc:	58 08       	cp.w	r8,0
8000efbe:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000efc2:	d8 22       	popm	r4-r7,pc

8000efc4 <_fclose_r>:
8000efc4:	d4 21       	pushm	r4-r7,lr
8000efc6:	18 96       	mov	r6,r12
8000efc8:	16 97       	mov	r7,r11
8000efca:	58 0b       	cp.w	r11,0
8000efcc:	c0 31       	brne	8000efd2 <_fclose_r+0xe>
8000efce:	16 95       	mov	r5,r11
8000efd0:	c5 08       	rjmp	8000f070 <_fclose_r+0xac>
8000efd2:	fe b0 f8 b1 	rcall	8000e134 <__sfp_lock_acquire>
8000efd6:	58 06       	cp.w	r6,0
8000efd8:	c0 70       	breq	8000efe6 <_fclose_r+0x22>
8000efda:	6c 68       	ld.w	r8,r6[0x18]
8000efdc:	58 08       	cp.w	r8,0
8000efde:	c0 41       	brne	8000efe6 <_fclose_r+0x22>
8000efe0:	0c 9c       	mov	r12,r6
8000efe2:	fe b0 f8 fd 	rcall	8000e1dc <__sinit>
8000efe6:	4a 48       	lddpc	r8,8000f074 <_fclose_r+0xb0>
8000efe8:	10 37       	cp.w	r7,r8
8000efea:	c0 31       	brne	8000eff0 <_fclose_r+0x2c>
8000efec:	6c 07       	ld.w	r7,r6[0x0]
8000efee:	c0 a8       	rjmp	8000f002 <_fclose_r+0x3e>
8000eff0:	4a 28       	lddpc	r8,8000f078 <_fclose_r+0xb4>
8000eff2:	10 37       	cp.w	r7,r8
8000eff4:	c0 31       	brne	8000effa <_fclose_r+0x36>
8000eff6:	6c 17       	ld.w	r7,r6[0x4]
8000eff8:	c0 58       	rjmp	8000f002 <_fclose_r+0x3e>
8000effa:	4a 18       	lddpc	r8,8000f07c <_fclose_r+0xb8>
8000effc:	10 37       	cp.w	r7,r8
8000effe:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000f002:	8e 69       	ld.sh	r9,r7[0xc]
8000f004:	30 08       	mov	r8,0
8000f006:	f0 09 19 00 	cp.h	r9,r8
8000f00a:	c0 51       	brne	8000f014 <_fclose_r+0x50>
8000f00c:	fe b0 f8 95 	rcall	8000e136 <__sfp_lock_release>
8000f010:	30 05       	mov	r5,0
8000f012:	c2 f8       	rjmp	8000f070 <_fclose_r+0xac>
8000f014:	0e 9b       	mov	r11,r7
8000f016:	0c 9c       	mov	r12,r6
8000f018:	fe b0 f8 06 	rcall	8000e024 <_fflush_r>
8000f01c:	6e c8       	ld.w	r8,r7[0x30]
8000f01e:	18 95       	mov	r5,r12
8000f020:	58 08       	cp.w	r8,0
8000f022:	c0 60       	breq	8000f02e <_fclose_r+0x6a>
8000f024:	6e 8b       	ld.w	r11,r7[0x20]
8000f026:	0c 9c       	mov	r12,r6
8000f028:	5d 18       	icall	r8
8000f02a:	f9 b5 05 ff 	movlt	r5,-1
8000f02e:	8e 68       	ld.sh	r8,r7[0xc]
8000f030:	ed b8 00 07 	bld	r8,0x7
8000f034:	c0 51       	brne	8000f03e <_fclose_r+0x7a>
8000f036:	6e 4b       	ld.w	r11,r7[0x10]
8000f038:	0c 9c       	mov	r12,r6
8000f03a:	fe b0 f9 6b 	rcall	8000e310 <_free_r>
8000f03e:	6e db       	ld.w	r11,r7[0x34]
8000f040:	58 0b       	cp.w	r11,0
8000f042:	c0 a0       	breq	8000f056 <_fclose_r+0x92>
8000f044:	ee c8 ff bc 	sub	r8,r7,-68
8000f048:	10 3b       	cp.w	r11,r8
8000f04a:	c0 40       	breq	8000f052 <_fclose_r+0x8e>
8000f04c:	0c 9c       	mov	r12,r6
8000f04e:	fe b0 f9 61 	rcall	8000e310 <_free_r>
8000f052:	30 08       	mov	r8,0
8000f054:	8f d8       	st.w	r7[0x34],r8
8000f056:	6f 2b       	ld.w	r11,r7[0x48]
8000f058:	58 0b       	cp.w	r11,0
8000f05a:	c0 70       	breq	8000f068 <_fclose_r+0xa4>
8000f05c:	0c 9c       	mov	r12,r6
8000f05e:	fe b0 f9 59 	rcall	8000e310 <_free_r>
8000f062:	30 08       	mov	r8,0
8000f064:	ef 48 00 48 	st.w	r7[72],r8
8000f068:	30 08       	mov	r8,0
8000f06a:	ae 68       	st.h	r7[0xc],r8
8000f06c:	fe b0 f8 65 	rcall	8000e136 <__sfp_lock_release>
8000f070:	0a 9c       	mov	r12,r5
8000f072:	d8 22       	popm	r4-r7,pc
8000f074:	80 01       	ld.sh	r1,r0[0x0]
8000f076:	9c b8       	ld.uh	r8,lr[0x6]
8000f078:	80 01       	ld.sh	r1,r0[0x0]
8000f07a:	9c d8       	ld.uh	r8,lr[0xa]
8000f07c:	80 01       	ld.sh	r1,r0[0x0]
8000f07e:	9c f8       	ld.uh	r8,lr[0xe]

8000f080 <fclose>:
8000f080:	d4 01       	pushm	lr
8000f082:	e0 68 0a 38 	mov	r8,2616
8000f086:	18 9b       	mov	r11,r12
8000f088:	70 0c       	ld.w	r12,r8[0x0]
8000f08a:	c9 df       	rcall	8000efc4 <_fclose_r>
8000f08c:	d8 02       	popm	pc
8000f08e:	d7 03       	nop

8000f090 <_fstat_r>:
8000f090:	d4 21       	pushm	r4-r7,lr
8000f092:	16 98       	mov	r8,r11
8000f094:	18 97       	mov	r7,r12
8000f096:	10 9c       	mov	r12,r8
8000f098:	30 08       	mov	r8,0
8000f09a:	e0 66 46 b4 	mov	r6,18100
8000f09e:	14 9b       	mov	r11,r10
8000f0a0:	8d 08       	st.w	r6[0x0],r8
8000f0a2:	fe b0 df 55 	rcall	8000af4c <_fstat>
8000f0a6:	5b fc       	cp.w	r12,-1
8000f0a8:	c0 51       	brne	8000f0b2 <_fstat_r+0x22>
8000f0aa:	6c 08       	ld.w	r8,r6[0x0]
8000f0ac:	58 08       	cp.w	r8,0
8000f0ae:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f0b2:	d8 22       	popm	r4-r7,pc

8000f0b4 <_lseek_r>:
8000f0b4:	d4 21       	pushm	r4-r7,lr
8000f0b6:	16 98       	mov	r8,r11
8000f0b8:	18 97       	mov	r7,r12
8000f0ba:	10 9c       	mov	r12,r8
8000f0bc:	30 08       	mov	r8,0
8000f0be:	14 9b       	mov	r11,r10
8000f0c0:	e0 66 46 b4 	mov	r6,18100
8000f0c4:	12 9a       	mov	r10,r9
8000f0c6:	8d 08       	st.w	r6[0x0],r8
8000f0c8:	fe b0 df 24 	rcall	8000af10 <_lseek>
8000f0cc:	5b fc       	cp.w	r12,-1
8000f0ce:	c0 51       	brne	8000f0d8 <_lseek_r+0x24>
8000f0d0:	6c 08       	ld.w	r8,r6[0x0]
8000f0d2:	58 08       	cp.w	r8,0
8000f0d4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f0d8:	d8 22       	popm	r4-r7,pc
8000f0da:	d7 03       	nop

8000f0dc <_read_r>:
8000f0dc:	d4 21       	pushm	r4-r7,lr
8000f0de:	16 98       	mov	r8,r11
8000f0e0:	18 97       	mov	r7,r12
8000f0e2:	10 9c       	mov	r12,r8
8000f0e4:	30 08       	mov	r8,0
8000f0e6:	14 9b       	mov	r11,r10
8000f0e8:	e0 66 46 b4 	mov	r6,18100
8000f0ec:	12 9a       	mov	r10,r9
8000f0ee:	8d 08       	st.w	r6[0x0],r8
8000f0f0:	fe b0 cf 5a 	rcall	80008fa4 <_read>
8000f0f4:	5b fc       	cp.w	r12,-1
8000f0f6:	c0 51       	brne	8000f100 <_read_r+0x24>
8000f0f8:	6c 08       	ld.w	r8,r6[0x0]
8000f0fa:	58 08       	cp.w	r8,0
8000f0fc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f100:	d8 22       	popm	r4-r7,pc
8000f102:	d7 03       	nop

8000f104 <__avr32_f64_mul>:
8000f104:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000f108:	e0 80 00 dc 	breq	8000f2c0 <__avr32_f64_mul_op1_zero>
8000f10c:	d4 21       	pushm	r4-r7,lr
8000f10e:	f7 e9 20 0e 	eor	lr,r11,r9
8000f112:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f116:	30 15       	mov	r5,1
8000f118:	c4 30       	breq	8000f19e <__avr32_f64_mul_op1_subnormal>
8000f11a:	ab 6b       	lsl	r11,0xa
8000f11c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000f120:	ab 6a       	lsl	r10,0xa
8000f122:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000f126:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f12a:	c5 c0       	breq	8000f1e2 <__avr32_f64_mul_op2_subnormal>
8000f12c:	a1 78       	lsl	r8,0x1
8000f12e:	5c f9       	rol	r9
8000f130:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000f134:	e0 47 07 ff 	cp.w	r7,2047
8000f138:	c7 70       	breq	8000f226 <__avr32_f64_mul_op_nan_or_inf>
8000f13a:	e0 46 07 ff 	cp.w	r6,2047
8000f13e:	c7 40       	breq	8000f226 <__avr32_f64_mul_op_nan_or_inf>
8000f140:	ee 06 00 0c 	add	r12,r7,r6
8000f144:	e0 2c 03 fe 	sub	r12,1022
8000f148:	f6 08 06 44 	mulu.d	r4,r11,r8
8000f14c:	f4 09 07 44 	macu.d	r4,r10,r9
8000f150:	f4 08 06 46 	mulu.d	r6,r10,r8
8000f154:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000f158:	08 07       	add	r7,r4
8000f15a:	f4 05 00 4a 	adc	r10,r10,r5
8000f15e:	5c 0b       	acr	r11
8000f160:	ed bb 00 14 	bld	r11,0x14
8000f164:	c0 50       	breq	8000f16e <__avr32_f64_mul+0x6a>
8000f166:	a1 77       	lsl	r7,0x1
8000f168:	5c fa       	rol	r10
8000f16a:	5c fb       	rol	r11
8000f16c:	20 1c       	sub	r12,1
8000f16e:	58 0c       	cp.w	r12,0
8000f170:	e0 8a 00 6f 	brle	8000f24e <__avr32_f64_mul_res_subnormal>
8000f174:	e0 4c 07 ff 	cp.w	r12,2047
8000f178:	e0 84 00 9c 	brge	8000f2b0 <__avr32_f64_mul_res_inf>
8000f17c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000f180:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000f184:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000f188:	ee 17 80 00 	eorh	r7,0x8000
8000f18c:	f1 b7 04 20 	satu	r7,0x1
8000f190:	0e 0a       	add	r10,r7
8000f192:	5c 0b       	acr	r11
8000f194:	ed be 00 1f 	bld	lr,0x1f
8000f198:	ef bb 00 1f 	bst	r11,0x1f
8000f19c:	d8 22       	popm	r4-r7,pc

8000f19e <__avr32_f64_mul_op1_subnormal>:
8000f19e:	e4 1b 00 0f 	andh	r11,0xf
8000f1a2:	f4 0c 12 00 	clz	r12,r10
8000f1a6:	f6 06 12 00 	clz	r6,r11
8000f1aa:	f7 bc 03 e1 	sublo	r12,-31
8000f1ae:	f8 06 17 30 	movlo	r6,r12
8000f1b2:	f7 b6 02 01 	subhs	r6,1
8000f1b6:	e0 46 00 20 	cp.w	r6,32
8000f1ba:	c0 d4       	brge	8000f1d4 <__avr32_f64_mul_op1_subnormal+0x36>
8000f1bc:	ec 0c 11 20 	rsub	r12,r6,32
8000f1c0:	f6 06 09 4b 	lsl	r11,r11,r6
8000f1c4:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000f1c8:	18 4b       	or	r11,r12
8000f1ca:	f4 06 09 4a 	lsl	r10,r10,r6
8000f1ce:	20 b6       	sub	r6,11
8000f1d0:	0c 17       	sub	r7,r6
8000f1d2:	ca ab       	rjmp	8000f126 <__avr32_f64_mul+0x22>
8000f1d4:	f4 06 09 4b 	lsl	r11,r10,r6
8000f1d8:	c6 40       	breq	8000f2a0 <__avr32_f64_mul_res_zero>
8000f1da:	30 0a       	mov	r10,0
8000f1dc:	20 b6       	sub	r6,11
8000f1de:	0c 17       	sub	r7,r6
8000f1e0:	ca 3b       	rjmp	8000f126 <__avr32_f64_mul+0x22>

8000f1e2 <__avr32_f64_mul_op2_subnormal>:
8000f1e2:	e4 19 00 0f 	andh	r9,0xf
8000f1e6:	f0 0c 12 00 	clz	r12,r8
8000f1ea:	f2 05 12 00 	clz	r5,r9
8000f1ee:	f7 bc 03 ea 	sublo	r12,-22
8000f1f2:	f8 05 17 30 	movlo	r5,r12
8000f1f6:	f7 b5 02 0a 	subhs	r5,10
8000f1fa:	e0 45 00 20 	cp.w	r5,32
8000f1fe:	c0 d4       	brge	8000f218 <__avr32_f64_mul_op2_subnormal+0x36>
8000f200:	ea 0c 11 20 	rsub	r12,r5,32
8000f204:	f2 05 09 49 	lsl	r9,r9,r5
8000f208:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000f20c:	18 49       	or	r9,r12
8000f20e:	f0 05 09 48 	lsl	r8,r8,r5
8000f212:	20 25       	sub	r5,2
8000f214:	0a 16       	sub	r6,r5
8000f216:	c8 fb       	rjmp	8000f134 <__avr32_f64_mul+0x30>
8000f218:	f0 05 09 49 	lsl	r9,r8,r5
8000f21c:	c4 20       	breq	8000f2a0 <__avr32_f64_mul_res_zero>
8000f21e:	30 08       	mov	r8,0
8000f220:	20 25       	sub	r5,2
8000f222:	0a 16       	sub	r6,r5
8000f224:	c8 8b       	rjmp	8000f134 <__avr32_f64_mul+0x30>

8000f226 <__avr32_f64_mul_op_nan_or_inf>:
8000f226:	e4 19 00 0f 	andh	r9,0xf
8000f22a:	e4 1b 00 0f 	andh	r11,0xf
8000f22e:	14 4b       	or	r11,r10
8000f230:	10 49       	or	r9,r8
8000f232:	e0 47 07 ff 	cp.w	r7,2047
8000f236:	c0 91       	brne	8000f248 <__avr32_f64_mul_op1_not_naninf>
8000f238:	58 0b       	cp.w	r11,0
8000f23a:	c3 81       	brne	8000f2aa <__avr32_f64_mul_res_nan>
8000f23c:	e0 46 07 ff 	cp.w	r6,2047
8000f240:	c3 81       	brne	8000f2b0 <__avr32_f64_mul_res_inf>
8000f242:	58 09       	cp.w	r9,0
8000f244:	c3 60       	breq	8000f2b0 <__avr32_f64_mul_res_inf>
8000f246:	c3 28       	rjmp	8000f2aa <__avr32_f64_mul_res_nan>

8000f248 <__avr32_f64_mul_op1_not_naninf>:
8000f248:	58 09       	cp.w	r9,0
8000f24a:	c3 30       	breq	8000f2b0 <__avr32_f64_mul_res_inf>
8000f24c:	c2 f8       	rjmp	8000f2aa <__avr32_f64_mul_res_nan>

8000f24e <__avr32_f64_mul_res_subnormal>:
8000f24e:	5c 3c       	neg	r12
8000f250:	2f fc       	sub	r12,-1
8000f252:	f1 bc 04 c0 	satu	r12,0x6
8000f256:	e0 4c 00 20 	cp.w	r12,32
8000f25a:	c1 14       	brge	8000f27c <__avr32_f64_mul_res_subnormal+0x2e>
8000f25c:	f8 08 11 20 	rsub	r8,r12,32
8000f260:	0e 46       	or	r6,r7
8000f262:	ee 0c 0a 47 	lsr	r7,r7,r12
8000f266:	f4 08 09 49 	lsl	r9,r10,r8
8000f26a:	12 47       	or	r7,r9
8000f26c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f270:	f6 08 09 49 	lsl	r9,r11,r8
8000f274:	12 4a       	or	r10,r9
8000f276:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f27a:	c8 3b       	rjmp	8000f180 <__avr32_f64_mul+0x7c>
8000f27c:	f8 08 11 20 	rsub	r8,r12,32
8000f280:	f9 b9 00 00 	moveq	r9,0
8000f284:	c0 30       	breq	8000f28a <__avr32_f64_mul_res_subnormal+0x3c>
8000f286:	f6 08 09 49 	lsl	r9,r11,r8
8000f28a:	0e 46       	or	r6,r7
8000f28c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000f290:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f294:	f3 ea 10 07 	or	r7,r9,r10
8000f298:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000f29c:	30 0b       	mov	r11,0
8000f29e:	c7 1b       	rjmp	8000f180 <__avr32_f64_mul+0x7c>

8000f2a0 <__avr32_f64_mul_res_zero>:
8000f2a0:	1c 9b       	mov	r11,lr
8000f2a2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f2a6:	30 0a       	mov	r10,0
8000f2a8:	d8 22       	popm	r4-r7,pc

8000f2aa <__avr32_f64_mul_res_nan>:
8000f2aa:	3f fb       	mov	r11,-1
8000f2ac:	3f fa       	mov	r10,-1
8000f2ae:	d8 22       	popm	r4-r7,pc

8000f2b0 <__avr32_f64_mul_res_inf>:
8000f2b0:	f0 6b 00 00 	mov	r11,-1048576
8000f2b4:	ed be 00 1f 	bld	lr,0x1f
8000f2b8:	ef bb 00 1f 	bst	r11,0x1f
8000f2bc:	30 0a       	mov	r10,0
8000f2be:	d8 22       	popm	r4-r7,pc

8000f2c0 <__avr32_f64_mul_op1_zero>:
8000f2c0:	f7 e9 20 0b 	eor	r11,r11,r9
8000f2c4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f2c8:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000f2cc:	e0 4c 07 ff 	cp.w	r12,2047
8000f2d0:	5e 1c       	retne	r12
8000f2d2:	3f fa       	mov	r10,-1
8000f2d4:	3f fb       	mov	r11,-1
8000f2d6:	5e fc       	retal	r12

8000f2d8 <__avr32_f64_sub_from_add>:
8000f2d8:	ee 19 80 00 	eorh	r9,0x8000

8000f2dc <__avr32_f64_sub>:
8000f2dc:	f7 e9 20 0c 	eor	r12,r11,r9
8000f2e0:	e0 86 00 ca 	brmi	8000f474 <__avr32_f64_add_from_sub>
8000f2e4:	eb cd 40 e0 	pushm	r5-r7,lr
8000f2e8:	16 9c       	mov	r12,r11
8000f2ea:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f2ee:	bf db       	cbr	r11,0x1f
8000f2f0:	bf d9       	cbr	r9,0x1f
8000f2f2:	10 3a       	cp.w	r10,r8
8000f2f4:	f2 0b 13 00 	cpc	r11,r9
8000f2f8:	c0 92       	brcc	8000f30a <__avr32_f64_sub+0x2e>
8000f2fa:	16 97       	mov	r7,r11
8000f2fc:	12 9b       	mov	r11,r9
8000f2fe:	0e 99       	mov	r9,r7
8000f300:	14 97       	mov	r7,r10
8000f302:	10 9a       	mov	r10,r8
8000f304:	0e 98       	mov	r8,r7
8000f306:	ee 1c 80 00 	eorh	r12,0x8000
8000f30a:	f6 07 16 14 	lsr	r7,r11,0x14
8000f30e:	ab 7b       	lsl	r11,0xb
8000f310:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f314:	ab 7a       	lsl	r10,0xb
8000f316:	bf bb       	sbr	r11,0x1f
8000f318:	f2 06 16 14 	lsr	r6,r9,0x14
8000f31c:	c4 40       	breq	8000f3a4 <__avr32_f64_sub_opL_subnormal>
8000f31e:	ab 79       	lsl	r9,0xb
8000f320:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f324:	ab 78       	lsl	r8,0xb
8000f326:	bf b9       	sbr	r9,0x1f

8000f328 <__avr32_f64_sub_opL_subnormal_done>:
8000f328:	e0 47 07 ff 	cp.w	r7,2047
8000f32c:	c4 f0       	breq	8000f3ca <__avr32_f64_sub_opH_nan_or_inf>
8000f32e:	0e 26       	rsub	r6,r7
8000f330:	c1 20       	breq	8000f354 <__avr32_f64_sub_shift_done>
8000f332:	ec 05 11 20 	rsub	r5,r6,32
8000f336:	e0 46 00 20 	cp.w	r6,32
8000f33a:	c7 c2       	brcc	8000f432 <__avr32_f64_sub_longshift>
8000f33c:	f0 05 09 4e 	lsl	lr,r8,r5
8000f340:	f2 05 09 45 	lsl	r5,r9,r5
8000f344:	f0 06 0a 48 	lsr	r8,r8,r6
8000f348:	f2 06 0a 49 	lsr	r9,r9,r6
8000f34c:	0a 48       	or	r8,r5
8000f34e:	58 0e       	cp.w	lr,0
8000f350:	5f 1e       	srne	lr
8000f352:	1c 48       	or	r8,lr

8000f354 <__avr32_f64_sub_shift_done>:
8000f354:	10 1a       	sub	r10,r8
8000f356:	f6 09 01 4b 	sbc	r11,r11,r9
8000f35a:	f6 06 12 00 	clz	r6,r11
8000f35e:	c0 e0       	breq	8000f37a <__avr32_f64_sub_longnormalize_done>
8000f360:	c7 83       	brcs	8000f450 <__avr32_f64_sub_longnormalize>
8000f362:	ec 0e 11 20 	rsub	lr,r6,32
8000f366:	f6 06 09 4b 	lsl	r11,r11,r6
8000f36a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f36e:	1c 4b       	or	r11,lr
8000f370:	f4 06 09 4a 	lsl	r10,r10,r6
8000f374:	0c 17       	sub	r7,r6
8000f376:	e0 8a 00 39 	brle	8000f3e8 <__avr32_f64_sub_subnormal_result>

8000f37a <__avr32_f64_sub_longnormalize_done>:
8000f37a:	f4 09 15 15 	lsl	r9,r10,0x15
8000f37e:	ab 9a       	lsr	r10,0xb
8000f380:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f384:	ab 9b       	lsr	r11,0xb
8000f386:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f38a:	18 4b       	or	r11,r12

8000f38c <__avr32_f64_sub_round>:
8000f38c:	fc 17 80 00 	movh	r7,0x8000
8000f390:	ed ba 00 00 	bld	r10,0x0
8000f394:	f7 b7 01 ff 	subne	r7,-1
8000f398:	0e 39       	cp.w	r9,r7
8000f39a:	5f 29       	srhs	r9
8000f39c:	12 0a       	add	r10,r9
8000f39e:	5c 0b       	acr	r11
8000f3a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f3a4 <__avr32_f64_sub_opL_subnormal>:
8000f3a4:	ab 79       	lsl	r9,0xb
8000f3a6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f3aa:	ab 78       	lsl	r8,0xb
8000f3ac:	f3 e8 10 0e 	or	lr,r9,r8
8000f3b0:	f9 b6 01 01 	movne	r6,1
8000f3b4:	ee 0e 11 00 	rsub	lr,r7,0
8000f3b8:	f9 b7 00 01 	moveq	r7,1
8000f3bc:	ef bb 00 1f 	bst	r11,0x1f
8000f3c0:	f7 ea 10 0e 	or	lr,r11,r10
8000f3c4:	f9 b7 00 00 	moveq	r7,0
8000f3c8:	cb 0b       	rjmp	8000f328 <__avr32_f64_sub_opL_subnormal_done>

8000f3ca <__avr32_f64_sub_opH_nan_or_inf>:
8000f3ca:	bf db       	cbr	r11,0x1f
8000f3cc:	f7 ea 10 0e 	or	lr,r11,r10
8000f3d0:	c0 81       	brne	8000f3e0 <__avr32_f64_sub_return_nan>
8000f3d2:	e0 46 07 ff 	cp.w	r6,2047
8000f3d6:	c0 50       	breq	8000f3e0 <__avr32_f64_sub_return_nan>
8000f3d8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000f3dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f3e0 <__avr32_f64_sub_return_nan>:
8000f3e0:	3f fa       	mov	r10,-1
8000f3e2:	3f fb       	mov	r11,-1
8000f3e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f3e8 <__avr32_f64_sub_subnormal_result>:
8000f3e8:	5c 37       	neg	r7
8000f3ea:	2f f7       	sub	r7,-1
8000f3ec:	f1 b7 04 c0 	satu	r7,0x6
8000f3f0:	e0 47 00 20 	cp.w	r7,32
8000f3f4:	c1 14       	brge	8000f416 <__avr32_f64_sub_subnormal_result+0x2e>
8000f3f6:	ee 08 11 20 	rsub	r8,r7,32
8000f3fa:	f4 08 09 49 	lsl	r9,r10,r8
8000f3fe:	5f 16       	srne	r6
8000f400:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f404:	0c 4a       	or	r10,r6
8000f406:	f6 08 09 49 	lsl	r9,r11,r8
8000f40a:	f5 e9 10 0a 	or	r10,r10,r9
8000f40e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000f412:	30 07       	mov	r7,0
8000f414:	cb 3b       	rjmp	8000f37a <__avr32_f64_sub_longnormalize_done>
8000f416:	ee 08 11 40 	rsub	r8,r7,64
8000f41a:	f6 08 09 49 	lsl	r9,r11,r8
8000f41e:	14 49       	or	r9,r10
8000f420:	5f 16       	srne	r6
8000f422:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f426:	0c 4a       	or	r10,r6
8000f428:	30 0b       	mov	r11,0
8000f42a:	30 07       	mov	r7,0
8000f42c:	ca 7b       	rjmp	8000f37a <__avr32_f64_sub_longnormalize_done>
8000f42e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f432 <__avr32_f64_sub_longshift>:
8000f432:	f1 b6 04 c0 	satu	r6,0x6
8000f436:	f0 0e 17 00 	moveq	lr,r8
8000f43a:	c0 40       	breq	8000f442 <__avr32_f64_sub_longshift+0x10>
8000f43c:	f2 05 09 4e 	lsl	lr,r9,r5
8000f440:	10 4e       	or	lr,r8
8000f442:	f2 06 0a 48 	lsr	r8,r9,r6
8000f446:	30 09       	mov	r9,0
8000f448:	58 0e       	cp.w	lr,0
8000f44a:	5f 1e       	srne	lr
8000f44c:	1c 48       	or	r8,lr
8000f44e:	c8 3b       	rjmp	8000f354 <__avr32_f64_sub_shift_done>

8000f450 <__avr32_f64_sub_longnormalize>:
8000f450:	f4 06 12 00 	clz	r6,r10
8000f454:	f9 b7 03 00 	movlo	r7,0
8000f458:	f9 b6 03 00 	movlo	r6,0
8000f45c:	f9 bc 03 00 	movlo	r12,0
8000f460:	f7 b6 02 e0 	subhs	r6,-32
8000f464:	f4 06 09 4b 	lsl	r11,r10,r6
8000f468:	30 0a       	mov	r10,0
8000f46a:	0c 17       	sub	r7,r6
8000f46c:	fe 9a ff be 	brle	8000f3e8 <__avr32_f64_sub_subnormal_result>
8000f470:	c8 5b       	rjmp	8000f37a <__avr32_f64_sub_longnormalize_done>
8000f472:	d7 03       	nop

8000f474 <__avr32_f64_add_from_sub>:
8000f474:	ee 19 80 00 	eorh	r9,0x8000

8000f478 <__avr32_f64_add>:
8000f478:	f7 e9 20 0c 	eor	r12,r11,r9
8000f47c:	fe 96 ff 2e 	brmi	8000f2d8 <__avr32_f64_sub_from_add>
8000f480:	eb cd 40 e0 	pushm	r5-r7,lr
8000f484:	16 9c       	mov	r12,r11
8000f486:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f48a:	bf db       	cbr	r11,0x1f
8000f48c:	bf d9       	cbr	r9,0x1f
8000f48e:	12 3b       	cp.w	r11,r9
8000f490:	c0 72       	brcc	8000f49e <__avr32_f64_add+0x26>
8000f492:	16 97       	mov	r7,r11
8000f494:	12 9b       	mov	r11,r9
8000f496:	0e 99       	mov	r9,r7
8000f498:	14 97       	mov	r7,r10
8000f49a:	10 9a       	mov	r10,r8
8000f49c:	0e 98       	mov	r8,r7
8000f49e:	30 0e       	mov	lr,0
8000f4a0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f4a4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000f4a8:	b5 ab       	sbr	r11,0x14
8000f4aa:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f4ae:	c6 20       	breq	8000f572 <__avr32_f64_add_op2_subnormal>
8000f4b0:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000f4b4:	b5 a9       	sbr	r9,0x14
8000f4b6:	e0 47 07 ff 	cp.w	r7,2047
8000f4ba:	c2 80       	breq	8000f50a <__avr32_f64_add_opH_nan_or_inf>
8000f4bc:	0e 26       	rsub	r6,r7
8000f4be:	c1 20       	breq	8000f4e2 <__avr32_f64_add_shift_done>
8000f4c0:	e0 46 00 36 	cp.w	r6,54
8000f4c4:	c1 52       	brcc	8000f4ee <__avr32_f64_add_res_of_done>
8000f4c6:	ec 05 11 20 	rsub	r5,r6,32
8000f4ca:	e0 46 00 20 	cp.w	r6,32
8000f4ce:	c3 52       	brcc	8000f538 <__avr32_f64_add_longshift>
8000f4d0:	f0 05 09 4e 	lsl	lr,r8,r5
8000f4d4:	f2 05 09 45 	lsl	r5,r9,r5
8000f4d8:	f0 06 0a 48 	lsr	r8,r8,r6
8000f4dc:	f2 06 0a 49 	lsr	r9,r9,r6
8000f4e0:	0a 48       	or	r8,r5

8000f4e2 <__avr32_f64_add_shift_done>:
8000f4e2:	10 0a       	add	r10,r8
8000f4e4:	f6 09 00 4b 	adc	r11,r11,r9
8000f4e8:	ed bb 00 15 	bld	r11,0x15
8000f4ec:	c3 40       	breq	8000f554 <__avr32_f64_add_res_of>

8000f4ee <__avr32_f64_add_res_of_done>:
8000f4ee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f4f2:	18 4b       	or	r11,r12

8000f4f4 <__avr32_f64_add_round>:
8000f4f4:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000f4f8:	18 4e       	or	lr,r12
8000f4fa:	ee 1e 80 00 	eorh	lr,0x8000
8000f4fe:	f1 be 04 20 	satu	lr,0x1
8000f502:	1c 0a       	add	r10,lr
8000f504:	5c 0b       	acr	r11
8000f506:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f50a <__avr32_f64_add_opH_nan_or_inf>:
8000f50a:	b5 cb       	cbr	r11,0x14
8000f50c:	f7 ea 10 0e 	or	lr,r11,r10
8000f510:	c1 01       	brne	8000f530 <__avr32_f64_add_return_nan>
8000f512:	e0 46 07 ff 	cp.w	r6,2047
8000f516:	c0 30       	breq	8000f51c <__avr32_f64_add_opL_nan_or_inf>
8000f518:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f51c <__avr32_f64_add_opL_nan_or_inf>:
8000f51c:	b5 c9       	cbr	r9,0x14
8000f51e:	f3 e8 10 0e 	or	lr,r9,r8
8000f522:	c0 71       	brne	8000f530 <__avr32_f64_add_return_nan>
8000f524:	30 0a       	mov	r10,0
8000f526:	fc 1b 7f f0 	movh	r11,0x7ff0
8000f52a:	18 4b       	or	r11,r12
8000f52c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f530 <__avr32_f64_add_return_nan>:
8000f530:	3f fa       	mov	r10,-1
8000f532:	3f fb       	mov	r11,-1
8000f534:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f538 <__avr32_f64_add_longshift>:
8000f538:	f1 b6 04 c0 	satu	r6,0x6
8000f53c:	f0 0e 17 00 	moveq	lr,r8
8000f540:	c0 60       	breq	8000f54c <__avr32_f64_add_longshift+0x14>
8000f542:	f2 05 09 4e 	lsl	lr,r9,r5
8000f546:	58 08       	cp.w	r8,0
8000f548:	5f 18       	srne	r8
8000f54a:	10 4e       	or	lr,r8
8000f54c:	f2 06 0a 48 	lsr	r8,r9,r6
8000f550:	30 09       	mov	r9,0
8000f552:	cc 8b       	rjmp	8000f4e2 <__avr32_f64_add_shift_done>

8000f554 <__avr32_f64_add_res_of>:
8000f554:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000f558:	a1 9b       	lsr	r11,0x1
8000f55a:	5d 0a       	ror	r10
8000f55c:	5d 0e       	ror	lr
8000f55e:	2f f7       	sub	r7,-1
8000f560:	e0 47 07 ff 	cp.w	r7,2047
8000f564:	f9 ba 00 00 	moveq	r10,0
8000f568:	f9 bb 00 00 	moveq	r11,0
8000f56c:	f9 be 00 00 	moveq	lr,0
8000f570:	cb fb       	rjmp	8000f4ee <__avr32_f64_add_res_of_done>

8000f572 <__avr32_f64_add_op2_subnormal>:
8000f572:	30 16       	mov	r6,1
8000f574:	58 07       	cp.w	r7,0
8000f576:	ca 01       	brne	8000f4b6 <__avr32_f64_add+0x3e>
8000f578:	b5 cb       	cbr	r11,0x14
8000f57a:	10 0a       	add	r10,r8
8000f57c:	f6 09 00 4b 	adc	r11,r11,r9
8000f580:	18 4b       	or	r11,r12
8000f582:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000f586:	d7 03       	nop

8000f588 <__avr32_f64_to_u32>:
8000f588:	58 0b       	cp.w	r11,0
8000f58a:	5e 6d       	retmi	0

8000f58c <__avr32_f64_to_s32>:
8000f58c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000f590:	b5 9c       	lsr	r12,0x15
8000f592:	e0 2c 03 ff 	sub	r12,1023
8000f596:	5e 3d       	retlo	0
8000f598:	f8 0c 11 1f 	rsub	r12,r12,31
8000f59c:	16 99       	mov	r9,r11
8000f59e:	ab 7b       	lsl	r11,0xb
8000f5a0:	bf bb       	sbr	r11,0x1f
8000f5a2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f5a6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f5aa:	a1 79       	lsl	r9,0x1
8000f5ac:	5e 2b       	reths	r11
8000f5ae:	5c 3b       	neg	r11
8000f5b0:	5e fb       	retal	r11

8000f5b2 <__avr32_u32_to_f64>:
8000f5b2:	f8 cb 00 00 	sub	r11,r12,0
8000f5b6:	30 0c       	mov	r12,0
8000f5b8:	c0 38       	rjmp	8000f5be <__avr32_s32_to_f64+0x4>

8000f5ba <__avr32_s32_to_f64>:
8000f5ba:	18 9b       	mov	r11,r12
8000f5bc:	5c 4b       	abs	r11
8000f5be:	30 0a       	mov	r10,0
8000f5c0:	5e 0b       	reteq	r11
8000f5c2:	d4 01       	pushm	lr
8000f5c4:	e0 69 04 1e 	mov	r9,1054
8000f5c8:	f6 08 12 00 	clz	r8,r11
8000f5cc:	c1 70       	breq	8000f5fa <__avr32_s32_to_f64+0x40>
8000f5ce:	c0 c3       	brcs	8000f5e6 <__avr32_s32_to_f64+0x2c>
8000f5d0:	f0 0e 11 20 	rsub	lr,r8,32
8000f5d4:	f6 08 09 4b 	lsl	r11,r11,r8
8000f5d8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f5dc:	1c 4b       	or	r11,lr
8000f5de:	f4 08 09 4a 	lsl	r10,r10,r8
8000f5e2:	10 19       	sub	r9,r8
8000f5e4:	c0 b8       	rjmp	8000f5fa <__avr32_s32_to_f64+0x40>
8000f5e6:	f4 08 12 00 	clz	r8,r10
8000f5ea:	f9 b8 03 00 	movlo	r8,0
8000f5ee:	f7 b8 02 e0 	subhs	r8,-32
8000f5f2:	f4 08 09 4b 	lsl	r11,r10,r8
8000f5f6:	30 0a       	mov	r10,0
8000f5f8:	10 19       	sub	r9,r8
8000f5fa:	58 09       	cp.w	r9,0
8000f5fc:	e0 89 00 30 	brgt	8000f65c <__avr32_s32_to_f64+0xa2>
8000f600:	5c 39       	neg	r9
8000f602:	2f f9       	sub	r9,-1
8000f604:	e0 49 00 36 	cp.w	r9,54
8000f608:	c0 43       	brcs	8000f610 <__avr32_s32_to_f64+0x56>
8000f60a:	30 0b       	mov	r11,0
8000f60c:	30 0a       	mov	r10,0
8000f60e:	c2 68       	rjmp	8000f65a <__avr32_s32_to_f64+0xa0>
8000f610:	2f 69       	sub	r9,-10
8000f612:	f2 08 11 20 	rsub	r8,r9,32
8000f616:	e0 49 00 20 	cp.w	r9,32
8000f61a:	c0 b2       	brcc	8000f630 <__avr32_s32_to_f64+0x76>
8000f61c:	f4 08 09 4e 	lsl	lr,r10,r8
8000f620:	f6 08 09 48 	lsl	r8,r11,r8
8000f624:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f628:	f6 09 0a 4b 	lsr	r11,r11,r9
8000f62c:	10 4b       	or	r11,r8
8000f62e:	c0 88       	rjmp	8000f63e <__avr32_s32_to_f64+0x84>
8000f630:	f6 08 09 4e 	lsl	lr,r11,r8
8000f634:	14 4e       	or	lr,r10
8000f636:	16 9a       	mov	r10,r11
8000f638:	30 0b       	mov	r11,0
8000f63a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f63e:	ed ba 00 00 	bld	r10,0x0
8000f642:	c0 92       	brcc	8000f654 <__avr32_s32_to_f64+0x9a>
8000f644:	1c 7e       	tst	lr,lr
8000f646:	c0 41       	brne	8000f64e <__avr32_s32_to_f64+0x94>
8000f648:	ed ba 00 01 	bld	r10,0x1
8000f64c:	c0 42       	brcc	8000f654 <__avr32_s32_to_f64+0x9a>
8000f64e:	2f fa       	sub	r10,-1
8000f650:	f7 bb 02 ff 	subhs	r11,-1
8000f654:	5c fc       	rol	r12
8000f656:	5d 0b       	ror	r11
8000f658:	5d 0a       	ror	r10
8000f65a:	d8 02       	popm	pc
8000f65c:	e0 68 03 ff 	mov	r8,1023
8000f660:	ed ba 00 0b 	bld	r10,0xb
8000f664:	f7 b8 00 ff 	subeq	r8,-1
8000f668:	10 0a       	add	r10,r8
8000f66a:	5c 0b       	acr	r11
8000f66c:	f7 b9 03 fe 	sublo	r9,-2
8000f670:	e0 49 07 ff 	cp.w	r9,2047
8000f674:	c0 55       	brlt	8000f67e <__avr32_s32_to_f64+0xc4>
8000f676:	30 0a       	mov	r10,0
8000f678:	fc 1b ff e0 	movh	r11,0xffe0
8000f67c:	c0 c8       	rjmp	8000f694 <__floatsidf_return_op1>
8000f67e:	ed bb 00 1f 	bld	r11,0x1f
8000f682:	f7 b9 01 01 	subne	r9,1
8000f686:	ab 9a       	lsr	r10,0xb
8000f688:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f68c:	a1 7b       	lsl	r11,0x1
8000f68e:	ab 9b       	lsr	r11,0xb
8000f690:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000f694 <__floatsidf_return_op1>:
8000f694:	a1 7c       	lsl	r12,0x1
8000f696:	5d 0b       	ror	r11
8000f698:	d8 02       	popm	pc

8000f69a <__avr32_f64_cmp_eq>:
8000f69a:	10 3a       	cp.w	r10,r8
8000f69c:	f2 0b 13 00 	cpc	r11,r9
8000f6a0:	c0 80       	breq	8000f6b0 <__avr32_f64_cmp_eq+0x16>
8000f6a2:	a1 7b       	lsl	r11,0x1
8000f6a4:	a1 79       	lsl	r9,0x1
8000f6a6:	14 4b       	or	r11,r10
8000f6a8:	12 4b       	or	r11,r9
8000f6aa:	10 4b       	or	r11,r8
8000f6ac:	5e 0f       	reteq	1
8000f6ae:	5e fd       	retal	0
8000f6b0:	a1 7b       	lsl	r11,0x1
8000f6b2:	fc 1c ff e0 	movh	r12,0xffe0
8000f6b6:	58 0a       	cp.w	r10,0
8000f6b8:	f8 0b 13 00 	cpc	r11,r12
8000f6bc:	5e 8f       	retls	1
8000f6be:	5e fd       	retal	0

8000f6c0 <__avr32_f64_cmp_ge>:
8000f6c0:	1a de       	st.w	--sp,lr
8000f6c2:	1a d7       	st.w	--sp,r7
8000f6c4:	a1 7b       	lsl	r11,0x1
8000f6c6:	5f 3c       	srlo	r12
8000f6c8:	a1 79       	lsl	r9,0x1
8000f6ca:	5f 37       	srlo	r7
8000f6cc:	5c fc       	rol	r12
8000f6ce:	fc 1e ff e0 	movh	lr,0xffe0
8000f6d2:	58 0a       	cp.w	r10,0
8000f6d4:	fc 0b 13 00 	cpc	r11,lr
8000f6d8:	e0 8b 00 1d 	brhi	8000f712 <__avr32_f64_cmp_ge+0x52>
8000f6dc:	58 08       	cp.w	r8,0
8000f6de:	fc 09 13 00 	cpc	r9,lr
8000f6e2:	e0 8b 00 18 	brhi	8000f712 <__avr32_f64_cmp_ge+0x52>
8000f6e6:	58 0b       	cp.w	r11,0
8000f6e8:	f5 ba 00 00 	subfeq	r10,0
8000f6ec:	c1 50       	breq	8000f716 <__avr32_f64_cmp_ge+0x56>
8000f6ee:	1b 07       	ld.w	r7,sp++
8000f6f0:	1b 0e       	ld.w	lr,sp++
8000f6f2:	58 3c       	cp.w	r12,3
8000f6f4:	c0 a0       	breq	8000f708 <__avr32_f64_cmp_ge+0x48>
8000f6f6:	58 1c       	cp.w	r12,1
8000f6f8:	c0 33       	brcs	8000f6fe <__avr32_f64_cmp_ge+0x3e>
8000f6fa:	5e 0f       	reteq	1
8000f6fc:	5e 1d       	retne	0
8000f6fe:	10 3a       	cp.w	r10,r8
8000f700:	f2 0b 13 00 	cpc	r11,r9
8000f704:	5e 2f       	reths	1
8000f706:	5e 3d       	retlo	0
8000f708:	14 38       	cp.w	r8,r10
8000f70a:	f6 09 13 00 	cpc	r9,r11
8000f70e:	5e 2f       	reths	1
8000f710:	5e 3d       	retlo	0
8000f712:	1b 07       	ld.w	r7,sp++
8000f714:	d8 0a       	popm	pc,r12=0
8000f716:	58 17       	cp.w	r7,1
8000f718:	5f 0c       	sreq	r12
8000f71a:	58 09       	cp.w	r9,0
8000f71c:	f5 b8 00 00 	subfeq	r8,0
8000f720:	1b 07       	ld.w	r7,sp++
8000f722:	1b 0e       	ld.w	lr,sp++
8000f724:	5e 0f       	reteq	1
8000f726:	5e fc       	retal	r12

8000f728 <__avr32_f64_cmp_lt>:
8000f728:	1a de       	st.w	--sp,lr
8000f72a:	1a d7       	st.w	--sp,r7
8000f72c:	a1 7b       	lsl	r11,0x1
8000f72e:	5f 3c       	srlo	r12
8000f730:	a1 79       	lsl	r9,0x1
8000f732:	5f 37       	srlo	r7
8000f734:	5c fc       	rol	r12
8000f736:	fc 1e ff e0 	movh	lr,0xffe0
8000f73a:	58 0a       	cp.w	r10,0
8000f73c:	fc 0b 13 00 	cpc	r11,lr
8000f740:	e0 8b 00 1d 	brhi	8000f77a <__avr32_f64_cmp_lt+0x52>
8000f744:	58 08       	cp.w	r8,0
8000f746:	fc 09 13 00 	cpc	r9,lr
8000f74a:	e0 8b 00 18 	brhi	8000f77a <__avr32_f64_cmp_lt+0x52>
8000f74e:	58 0b       	cp.w	r11,0
8000f750:	f5 ba 00 00 	subfeq	r10,0
8000f754:	c1 50       	breq	8000f77e <__avr32_f64_cmp_lt+0x56>
8000f756:	1b 07       	ld.w	r7,sp++
8000f758:	1b 0e       	ld.w	lr,sp++
8000f75a:	58 3c       	cp.w	r12,3
8000f75c:	c0 a0       	breq	8000f770 <__avr32_f64_cmp_lt+0x48>
8000f75e:	58 1c       	cp.w	r12,1
8000f760:	c0 33       	brcs	8000f766 <__avr32_f64_cmp_lt+0x3e>
8000f762:	5e 0d       	reteq	0
8000f764:	5e 1f       	retne	1
8000f766:	10 3a       	cp.w	r10,r8
8000f768:	f2 0b 13 00 	cpc	r11,r9
8000f76c:	5e 2d       	reths	0
8000f76e:	5e 3f       	retlo	1
8000f770:	14 38       	cp.w	r8,r10
8000f772:	f6 09 13 00 	cpc	r9,r11
8000f776:	5e 2d       	reths	0
8000f778:	5e 3f       	retlo	1
8000f77a:	1b 07       	ld.w	r7,sp++
8000f77c:	d8 0a       	popm	pc,r12=0
8000f77e:	58 17       	cp.w	r7,1
8000f780:	5f 1c       	srne	r12
8000f782:	58 09       	cp.w	r9,0
8000f784:	f5 b8 00 00 	subfeq	r8,0
8000f788:	1b 07       	ld.w	r7,sp++
8000f78a:	1b 0e       	ld.w	lr,sp++
8000f78c:	5e 0d       	reteq	0
8000f78e:	5e fc       	retal	r12

8000f790 <__avr32_f64_div>:
8000f790:	eb cd 40 ff 	pushm	r0-r7,lr
8000f794:	f7 e9 20 0e 	eor	lr,r11,r9
8000f798:	f6 07 16 14 	lsr	r7,r11,0x14
8000f79c:	a9 7b       	lsl	r11,0x9
8000f79e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000f7a2:	a9 7a       	lsl	r10,0x9
8000f7a4:	bd bb       	sbr	r11,0x1d
8000f7a6:	e4 1b 3f ff 	andh	r11,0x3fff
8000f7aa:	ab d7       	cbr	r7,0xb
8000f7ac:	e0 80 00 cc 	breq	8000f944 <__avr32_f64_div_round_subnormal+0x54>
8000f7b0:	e0 47 07 ff 	cp.w	r7,2047
8000f7b4:	e0 84 00 b5 	brge	8000f91e <__avr32_f64_div_round_subnormal+0x2e>
8000f7b8:	f2 06 16 14 	lsr	r6,r9,0x14
8000f7bc:	a9 79       	lsl	r9,0x9
8000f7be:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000f7c2:	a9 78       	lsl	r8,0x9
8000f7c4:	bd b9       	sbr	r9,0x1d
8000f7c6:	e4 19 3f ff 	andh	r9,0x3fff
8000f7ca:	ab d6       	cbr	r6,0xb
8000f7cc:	e0 80 00 e2 	breq	8000f990 <__avr32_f64_div_round_subnormal+0xa0>
8000f7d0:	e0 46 07 ff 	cp.w	r6,2047
8000f7d4:	e0 84 00 b2 	brge	8000f938 <__avr32_f64_div_round_subnormal+0x48>
8000f7d8:	0c 17       	sub	r7,r6
8000f7da:	fe 37 fc 01 	sub	r7,-1023
8000f7de:	fc 1c 80 00 	movh	r12,0x8000
8000f7e2:	f8 03 16 01 	lsr	r3,r12,0x1
8000f7e6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000f7ea:	5c d4       	com	r4
8000f7ec:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000f7f0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f7f4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f7f8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f7fc:	ea 03 15 02 	lsl	r3,r5,0x2
8000f800:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f804:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f808:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f80c:	ea 03 15 02 	lsl	r3,r5,0x2
8000f810:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f814:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f818:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f81c:	ea 03 15 02 	lsl	r3,r5,0x2
8000f820:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f824:	e4 09 07 40 	macu.d	r0,r2,r9
8000f828:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f82c:	02 04       	add	r4,r1
8000f82e:	5c 05       	acr	r5
8000f830:	a3 65       	lsl	r5,0x2
8000f832:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f836:	a3 64       	lsl	r4,0x2
8000f838:	5c 34       	neg	r4
8000f83a:	f8 05 01 45 	sbc	r5,r12,r5
8000f83e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f842:	e4 05 07 40 	macu.d	r0,r2,r5
8000f846:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f84a:	02 04       	add	r4,r1
8000f84c:	5c 05       	acr	r5
8000f84e:	ea 03 15 02 	lsl	r3,r5,0x2
8000f852:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f856:	e8 02 15 02 	lsl	r2,r4,0x2
8000f85a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f85e:	e4 09 07 40 	macu.d	r0,r2,r9
8000f862:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f866:	02 04       	add	r4,r1
8000f868:	5c 05       	acr	r5
8000f86a:	a3 65       	lsl	r5,0x2
8000f86c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f870:	a3 64       	lsl	r4,0x2
8000f872:	5c 34       	neg	r4
8000f874:	f8 05 01 45 	sbc	r5,r12,r5
8000f878:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f87c:	e4 05 07 40 	macu.d	r0,r2,r5
8000f880:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f884:	02 04       	add	r4,r1
8000f886:	5c 05       	acr	r5
8000f888:	ea 03 15 02 	lsl	r3,r5,0x2
8000f88c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f890:	e8 02 15 02 	lsl	r2,r4,0x2
8000f894:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000f898:	e4 0b 07 40 	macu.d	r0,r2,r11
8000f89c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000f8a0:	02 02       	add	r2,r1
8000f8a2:	5c 03       	acr	r3
8000f8a4:	ed b3 00 1c 	bld	r3,0x1c
8000f8a8:	c0 90       	breq	8000f8ba <__avr32_f64_div+0x12a>
8000f8aa:	a1 72       	lsl	r2,0x1
8000f8ac:	5c f3       	rol	r3
8000f8ae:	20 17       	sub	r7,1
8000f8b0:	a3 9a       	lsr	r10,0x3
8000f8b2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000f8b6:	a3 9b       	lsr	r11,0x3
8000f8b8:	c0 58       	rjmp	8000f8c2 <__avr32_f64_div+0x132>
8000f8ba:	a5 8a       	lsr	r10,0x4
8000f8bc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000f8c0:	a5 8b       	lsr	r11,0x4
8000f8c2:	58 07       	cp.w	r7,0
8000f8c4:	e0 8a 00 8b 	brle	8000f9da <__avr32_f64_div_res_subnormal>
8000f8c8:	e0 12 ff 00 	andl	r2,0xff00
8000f8cc:	e8 12 00 80 	orl	r2,0x80
8000f8d0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f8d4:	e4 09 07 40 	macu.d	r0,r2,r9
8000f8d8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f8dc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f8e0:	00 05       	add	r5,r0
8000f8e2:	f0 01 00 48 	adc	r8,r8,r1
8000f8e6:	5c 09       	acr	r9
8000f8e8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f8ec:	58 04       	cp.w	r4,0
8000f8ee:	5c 25       	cpc	r5

8000f8f0 <__avr32_f64_div_round_subnormal>:
8000f8f0:	f4 08 13 00 	cpc	r8,r10
8000f8f4:	f6 09 13 00 	cpc	r9,r11
8000f8f8:	5f 36       	srlo	r6
8000f8fa:	f8 06 17 00 	moveq	r6,r12
8000f8fe:	e4 0a 16 08 	lsr	r10,r2,0x8
8000f902:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000f906:	e6 0b 16 08 	lsr	r11,r3,0x8
8000f90a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f90e:	ed be 00 1f 	bld	lr,0x1f
8000f912:	ef bb 00 1f 	bst	r11,0x1f
8000f916:	0c 0a       	add	r10,r6
8000f918:	5c 0b       	acr	r11
8000f91a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f91e:	e4 1b 00 0f 	andh	r11,0xf
8000f922:	14 4b       	or	r11,r10
8000f924:	e0 81 00 a7 	brne	8000fa72 <__avr32_f64_div_res_subnormal+0x98>
8000f928:	f2 06 16 14 	lsr	r6,r9,0x14
8000f92c:	ab d6       	cbr	r6,0xb
8000f92e:	e0 46 07 ff 	cp.w	r6,2047
8000f932:	e0 81 00 a4 	brne	8000fa7a <__avr32_f64_div_res_subnormal+0xa0>
8000f936:	c9 e8       	rjmp	8000fa72 <__avr32_f64_div_res_subnormal+0x98>
8000f938:	e4 19 00 0f 	andh	r9,0xf
8000f93c:	10 49       	or	r9,r8
8000f93e:	e0 81 00 9a 	brne	8000fa72 <__avr32_f64_div_res_subnormal+0x98>
8000f942:	c9 28       	rjmp	8000fa66 <__avr32_f64_div_res_subnormal+0x8c>
8000f944:	a3 7b       	lsl	r11,0x3
8000f946:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000f94a:	a3 7a       	lsl	r10,0x3
8000f94c:	f5 eb 10 04 	or	r4,r10,r11
8000f950:	e0 80 00 a0 	breq	8000fa90 <__avr32_f64_div_op1_zero>
8000f954:	f6 04 12 00 	clz	r4,r11
8000f958:	c1 70       	breq	8000f986 <__avr32_f64_div_round_subnormal+0x96>
8000f95a:	c0 c3       	brcs	8000f972 <__avr32_f64_div_round_subnormal+0x82>
8000f95c:	e8 05 11 20 	rsub	r5,r4,32
8000f960:	f6 04 09 4b 	lsl	r11,r11,r4
8000f964:	f4 05 0a 45 	lsr	r5,r10,r5
8000f968:	0a 4b       	or	r11,r5
8000f96a:	f4 04 09 4a 	lsl	r10,r10,r4
8000f96e:	08 17       	sub	r7,r4
8000f970:	c0 b8       	rjmp	8000f986 <__avr32_f64_div_round_subnormal+0x96>
8000f972:	f4 04 12 00 	clz	r4,r10
8000f976:	f9 b4 03 00 	movlo	r4,0
8000f97a:	f7 b4 02 e0 	subhs	r4,-32
8000f97e:	f4 04 09 4b 	lsl	r11,r10,r4
8000f982:	30 0a       	mov	r10,0
8000f984:	08 17       	sub	r7,r4
8000f986:	a3 8a       	lsr	r10,0x2
8000f988:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000f98c:	a3 8b       	lsr	r11,0x2
8000f98e:	c1 1b       	rjmp	8000f7b0 <__avr32_f64_div+0x20>
8000f990:	a3 79       	lsl	r9,0x3
8000f992:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000f996:	a3 78       	lsl	r8,0x3
8000f998:	f3 e8 10 04 	or	r4,r9,r8
8000f99c:	c6 f0       	breq	8000fa7a <__avr32_f64_div_res_subnormal+0xa0>
8000f99e:	f2 04 12 00 	clz	r4,r9
8000f9a2:	c1 70       	breq	8000f9d0 <__avr32_f64_div_round_subnormal+0xe0>
8000f9a4:	c0 c3       	brcs	8000f9bc <__avr32_f64_div_round_subnormal+0xcc>
8000f9a6:	e8 05 11 20 	rsub	r5,r4,32
8000f9aa:	f2 04 09 49 	lsl	r9,r9,r4
8000f9ae:	f0 05 0a 45 	lsr	r5,r8,r5
8000f9b2:	0a 49       	or	r9,r5
8000f9b4:	f0 04 09 48 	lsl	r8,r8,r4
8000f9b8:	08 16       	sub	r6,r4
8000f9ba:	c0 b8       	rjmp	8000f9d0 <__avr32_f64_div_round_subnormal+0xe0>
8000f9bc:	f0 04 12 00 	clz	r4,r8
8000f9c0:	f9 b4 03 00 	movlo	r4,0
8000f9c4:	f7 b4 02 e0 	subhs	r4,-32
8000f9c8:	f0 04 09 49 	lsl	r9,r8,r4
8000f9cc:	30 08       	mov	r8,0
8000f9ce:	08 16       	sub	r6,r4
8000f9d0:	a3 88       	lsr	r8,0x2
8000f9d2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000f9d6:	a3 89       	lsr	r9,0x2
8000f9d8:	cf ca       	rjmp	8000f7d0 <__avr32_f64_div+0x40>

8000f9da <__avr32_f64_div_res_subnormal>:
8000f9da:	5c 37       	neg	r7
8000f9dc:	2f f7       	sub	r7,-1
8000f9de:	f1 b7 04 c0 	satu	r7,0x6
8000f9e2:	e0 47 00 20 	cp.w	r7,32
8000f9e6:	c1 54       	brge	8000fa10 <__avr32_f64_div_res_subnormal+0x36>
8000f9e8:	ee 06 11 20 	rsub	r6,r7,32
8000f9ec:	e4 07 0a 42 	lsr	r2,r2,r7
8000f9f0:	e6 06 09 4c 	lsl	r12,r3,r6
8000f9f4:	18 42       	or	r2,r12
8000f9f6:	e6 07 0a 43 	lsr	r3,r3,r7
8000f9fa:	f4 06 09 41 	lsl	r1,r10,r6
8000f9fe:	f4 07 0a 4a 	lsr	r10,r10,r7
8000fa02:	f6 06 09 4c 	lsl	r12,r11,r6
8000fa06:	18 4a       	or	r10,r12
8000fa08:	f6 07 0a 4b 	lsr	r11,r11,r7
8000fa0c:	30 00       	mov	r0,0
8000fa0e:	c1 58       	rjmp	8000fa38 <__avr32_f64_div_res_subnormal+0x5e>
8000fa10:	ee 06 11 20 	rsub	r6,r7,32
8000fa14:	f9 b0 00 00 	moveq	r0,0
8000fa18:	f9 bc 00 00 	moveq	r12,0
8000fa1c:	c0 50       	breq	8000fa26 <__avr32_f64_div_res_subnormal+0x4c>
8000fa1e:	f4 06 09 40 	lsl	r0,r10,r6
8000fa22:	f6 06 09 4c 	lsl	r12,r11,r6
8000fa26:	e6 07 0a 42 	lsr	r2,r3,r7
8000fa2a:	30 03       	mov	r3,0
8000fa2c:	f4 07 0a 41 	lsr	r1,r10,r7
8000fa30:	18 41       	or	r1,r12
8000fa32:	f6 07 0a 4a 	lsr	r10,r11,r7
8000fa36:	30 0b       	mov	r11,0
8000fa38:	e0 12 ff 00 	andl	r2,0xff00
8000fa3c:	e8 12 00 80 	orl	r2,0x80
8000fa40:	e6 08 06 46 	mulu.d	r6,r3,r8
8000fa44:	e4 09 07 46 	macu.d	r6,r2,r9
8000fa48:	e4 08 06 44 	mulu.d	r4,r2,r8
8000fa4c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000fa50:	0c 05       	add	r5,r6
8000fa52:	f0 07 00 48 	adc	r8,r8,r7
8000fa56:	5c 09       	acr	r9
8000fa58:	30 07       	mov	r7,0
8000fa5a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000fa5e:	00 34       	cp.w	r4,r0
8000fa60:	e2 05 13 00 	cpc	r5,r1
8000fa64:	c4 6b       	rjmp	8000f8f0 <__avr32_f64_div_round_subnormal>
8000fa66:	1c 9b       	mov	r11,lr
8000fa68:	e6 1b 80 00 	andh	r11,0x8000,COH
8000fa6c:	30 0a       	mov	r10,0
8000fa6e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000fa72:	3f fb       	mov	r11,-1
8000fa74:	30 0a       	mov	r10,0
8000fa76:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000fa7a:	f5 eb 10 04 	or	r4,r10,r11
8000fa7e:	c0 90       	breq	8000fa90 <__avr32_f64_div_op1_zero>
8000fa80:	1c 9b       	mov	r11,lr
8000fa82:	e6 1b 80 00 	andh	r11,0x8000,COH
8000fa86:	ea 1b 7f f0 	orh	r11,0x7ff0
8000fa8a:	30 0a       	mov	r10,0
8000fa8c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000fa90 <__avr32_f64_div_op1_zero>:
8000fa90:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000fa94:	ce f0       	breq	8000fa72 <__avr32_f64_div_res_subnormal+0x98>
8000fa96:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000fa9a:	e0 44 07 ff 	cp.w	r4,2047
8000fa9e:	ce 41       	brne	8000fa66 <__avr32_f64_div_res_subnormal+0x8c>
8000faa0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000faa4:	ce 10       	breq	8000fa66 <__avr32_f64_div_res_subnormal+0x8c>
8000faa6:	ce 6b       	rjmp	8000fa72 <__avr32_f64_div_res_subnormal+0x98>

8000faa8 <__avr32_udiv64>:
8000faa8:	d4 31       	pushm	r0-r7,lr
8000faaa:	1a 97       	mov	r7,sp
8000faac:	20 3d       	sub	sp,12
8000faae:	10 9c       	mov	r12,r8
8000fab0:	12 9e       	mov	lr,r9
8000fab2:	14 93       	mov	r3,r10
8000fab4:	58 09       	cp.w	r9,0
8000fab6:	e0 81 00 bd 	brne	8000fc30 <__avr32_udiv64+0x188>
8000faba:	16 38       	cp.w	r8,r11
8000fabc:	e0 88 00 40 	brls	8000fb3c <__avr32_udiv64+0x94>
8000fac0:	f0 08 12 00 	clz	r8,r8
8000fac4:	c0 d0       	breq	8000fade <__avr32_udiv64+0x36>
8000fac6:	f6 08 09 4b 	lsl	r11,r11,r8
8000faca:	f0 09 11 20 	rsub	r9,r8,32
8000face:	f8 08 09 4c 	lsl	r12,r12,r8
8000fad2:	f4 09 0a 49 	lsr	r9,r10,r9
8000fad6:	f4 08 09 43 	lsl	r3,r10,r8
8000fada:	f3 eb 10 0b 	or	r11,r9,r11
8000fade:	f8 0e 16 10 	lsr	lr,r12,0x10
8000fae2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000fae6:	f6 0e 0d 00 	divu	r0,r11,lr
8000faea:	e6 0b 16 10 	lsr	r11,r3,0x10
8000faee:	00 99       	mov	r9,r0
8000faf0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000faf4:	e0 0a 02 48 	mul	r8,r0,r10
8000faf8:	10 3b       	cp.w	r11,r8
8000fafa:	c0 a2       	brcc	8000fb0e <__avr32_udiv64+0x66>
8000fafc:	20 19       	sub	r9,1
8000fafe:	18 0b       	add	r11,r12
8000fb00:	18 3b       	cp.w	r11,r12
8000fb02:	c0 63       	brcs	8000fb0e <__avr32_udiv64+0x66>
8000fb04:	10 3b       	cp.w	r11,r8
8000fb06:	f7 b9 03 01 	sublo	r9,1
8000fb0a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fb0e:	f6 08 01 01 	sub	r1,r11,r8
8000fb12:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000fb16:	e2 0e 0d 00 	divu	r0,r1,lr
8000fb1a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fb1e:	00 98       	mov	r8,r0
8000fb20:	e0 0a 02 4a 	mul	r10,r0,r10
8000fb24:	14 33       	cp.w	r3,r10
8000fb26:	c0 82       	brcc	8000fb36 <__avr32_udiv64+0x8e>
8000fb28:	20 18       	sub	r8,1
8000fb2a:	18 03       	add	r3,r12
8000fb2c:	18 33       	cp.w	r3,r12
8000fb2e:	c0 43       	brcs	8000fb36 <__avr32_udiv64+0x8e>
8000fb30:	14 33       	cp.w	r3,r10
8000fb32:	f7 b8 03 01 	sublo	r8,1
8000fb36:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000fb3a:	cd f8       	rjmp	8000fcf8 <__avr32_udiv64+0x250>
8000fb3c:	58 08       	cp.w	r8,0
8000fb3e:	c0 51       	brne	8000fb48 <__avr32_udiv64+0xa0>
8000fb40:	30 19       	mov	r9,1
8000fb42:	f2 08 0d 08 	divu	r8,r9,r8
8000fb46:	10 9c       	mov	r12,r8
8000fb48:	f8 06 12 00 	clz	r6,r12
8000fb4c:	c0 41       	brne	8000fb54 <__avr32_udiv64+0xac>
8000fb4e:	18 1b       	sub	r11,r12
8000fb50:	30 19       	mov	r9,1
8000fb52:	c4 08       	rjmp	8000fbd2 <__avr32_udiv64+0x12a>
8000fb54:	ec 01 11 20 	rsub	r1,r6,32
8000fb58:	f4 01 0a 49 	lsr	r9,r10,r1
8000fb5c:	f8 06 09 4c 	lsl	r12,r12,r6
8000fb60:	f6 06 09 48 	lsl	r8,r11,r6
8000fb64:	f6 01 0a 41 	lsr	r1,r11,r1
8000fb68:	f3 e8 10 08 	or	r8,r9,r8
8000fb6c:	f8 03 16 10 	lsr	r3,r12,0x10
8000fb70:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000fb74:	e2 03 0d 00 	divu	r0,r1,r3
8000fb78:	f0 0b 16 10 	lsr	r11,r8,0x10
8000fb7c:	00 9e       	mov	lr,r0
8000fb7e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fb82:	e0 05 02 49 	mul	r9,r0,r5
8000fb86:	12 3b       	cp.w	r11,r9
8000fb88:	c0 a2       	brcc	8000fb9c <__avr32_udiv64+0xf4>
8000fb8a:	20 1e       	sub	lr,1
8000fb8c:	18 0b       	add	r11,r12
8000fb8e:	18 3b       	cp.w	r11,r12
8000fb90:	c0 63       	brcs	8000fb9c <__avr32_udiv64+0xf4>
8000fb92:	12 3b       	cp.w	r11,r9
8000fb94:	f7 be 03 01 	sublo	lr,1
8000fb98:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fb9c:	12 1b       	sub	r11,r9
8000fb9e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000fba2:	f6 03 0d 02 	divu	r2,r11,r3
8000fba6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000fbaa:	04 99       	mov	r9,r2
8000fbac:	e4 05 02 4b 	mul	r11,r2,r5
8000fbb0:	16 38       	cp.w	r8,r11
8000fbb2:	c0 a2       	brcc	8000fbc6 <__avr32_udiv64+0x11e>
8000fbb4:	20 19       	sub	r9,1
8000fbb6:	18 08       	add	r8,r12
8000fbb8:	18 38       	cp.w	r8,r12
8000fbba:	c0 63       	brcs	8000fbc6 <__avr32_udiv64+0x11e>
8000fbbc:	16 38       	cp.w	r8,r11
8000fbbe:	f7 b9 03 01 	sublo	r9,1
8000fbc2:	f1 dc e3 08 	addcs	r8,r8,r12
8000fbc6:	f4 06 09 43 	lsl	r3,r10,r6
8000fbca:	f0 0b 01 0b 	sub	r11,r8,r11
8000fbce:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000fbd2:	f8 06 16 10 	lsr	r6,r12,0x10
8000fbd6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000fbda:	f6 06 0d 00 	divu	r0,r11,r6
8000fbde:	e6 0b 16 10 	lsr	r11,r3,0x10
8000fbe2:	00 9a       	mov	r10,r0
8000fbe4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fbe8:	e0 0e 02 48 	mul	r8,r0,lr
8000fbec:	10 3b       	cp.w	r11,r8
8000fbee:	c0 a2       	brcc	8000fc02 <__avr32_udiv64+0x15a>
8000fbf0:	20 1a       	sub	r10,1
8000fbf2:	18 0b       	add	r11,r12
8000fbf4:	18 3b       	cp.w	r11,r12
8000fbf6:	c0 63       	brcs	8000fc02 <__avr32_udiv64+0x15a>
8000fbf8:	10 3b       	cp.w	r11,r8
8000fbfa:	f7 ba 03 01 	sublo	r10,1
8000fbfe:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fc02:	f6 08 01 01 	sub	r1,r11,r8
8000fc06:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000fc0a:	e2 06 0d 00 	divu	r0,r1,r6
8000fc0e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fc12:	00 98       	mov	r8,r0
8000fc14:	e0 0e 02 4b 	mul	r11,r0,lr
8000fc18:	16 33       	cp.w	r3,r11
8000fc1a:	c0 82       	brcc	8000fc2a <__avr32_udiv64+0x182>
8000fc1c:	20 18       	sub	r8,1
8000fc1e:	18 03       	add	r3,r12
8000fc20:	18 33       	cp.w	r3,r12
8000fc22:	c0 43       	brcs	8000fc2a <__avr32_udiv64+0x182>
8000fc24:	16 33       	cp.w	r3,r11
8000fc26:	f7 b8 03 01 	sublo	r8,1
8000fc2a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000fc2e:	c6 98       	rjmp	8000fd00 <__avr32_udiv64+0x258>
8000fc30:	16 39       	cp.w	r9,r11
8000fc32:	e0 8b 00 65 	brhi	8000fcfc <__avr32_udiv64+0x254>
8000fc36:	f2 09 12 00 	clz	r9,r9
8000fc3a:	c0 b1       	brne	8000fc50 <__avr32_udiv64+0x1a8>
8000fc3c:	10 3a       	cp.w	r10,r8
8000fc3e:	5f 2a       	srhs	r10
8000fc40:	1c 3b       	cp.w	r11,lr
8000fc42:	5f b8       	srhi	r8
8000fc44:	10 4a       	or	r10,r8
8000fc46:	f2 0a 18 00 	cp.b	r10,r9
8000fc4a:	c5 90       	breq	8000fcfc <__avr32_udiv64+0x254>
8000fc4c:	30 18       	mov	r8,1
8000fc4e:	c5 98       	rjmp	8000fd00 <__avr32_udiv64+0x258>
8000fc50:	f0 09 09 46 	lsl	r6,r8,r9
8000fc54:	f2 03 11 20 	rsub	r3,r9,32
8000fc58:	fc 09 09 4e 	lsl	lr,lr,r9
8000fc5c:	f0 03 0a 48 	lsr	r8,r8,r3
8000fc60:	f6 09 09 4c 	lsl	r12,r11,r9
8000fc64:	f4 03 0a 42 	lsr	r2,r10,r3
8000fc68:	ef 46 ff f4 	st.w	r7[-12],r6
8000fc6c:	f6 03 0a 43 	lsr	r3,r11,r3
8000fc70:	18 42       	or	r2,r12
8000fc72:	f1 ee 10 0c 	or	r12,r8,lr
8000fc76:	f8 01 16 10 	lsr	r1,r12,0x10
8000fc7a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000fc7e:	e6 01 0d 04 	divu	r4,r3,r1
8000fc82:	e4 03 16 10 	lsr	r3,r2,0x10
8000fc86:	08 9e       	mov	lr,r4
8000fc88:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000fc8c:	e8 06 02 48 	mul	r8,r4,r6
8000fc90:	10 33       	cp.w	r3,r8
8000fc92:	c0 a2       	brcc	8000fca6 <__avr32_udiv64+0x1fe>
8000fc94:	20 1e       	sub	lr,1
8000fc96:	18 03       	add	r3,r12
8000fc98:	18 33       	cp.w	r3,r12
8000fc9a:	c0 63       	brcs	8000fca6 <__avr32_udiv64+0x1fe>
8000fc9c:	10 33       	cp.w	r3,r8
8000fc9e:	f7 be 03 01 	sublo	lr,1
8000fca2:	e7 dc e3 03 	addcs	r3,r3,r12
8000fca6:	10 13       	sub	r3,r8
8000fca8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000fcac:	e6 01 0d 00 	divu	r0,r3,r1
8000fcb0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fcb4:	00 98       	mov	r8,r0
8000fcb6:	e0 06 02 46 	mul	r6,r0,r6
8000fcba:	0c 3b       	cp.w	r11,r6
8000fcbc:	c0 a2       	brcc	8000fcd0 <__avr32_udiv64+0x228>
8000fcbe:	20 18       	sub	r8,1
8000fcc0:	18 0b       	add	r11,r12
8000fcc2:	18 3b       	cp.w	r11,r12
8000fcc4:	c0 63       	brcs	8000fcd0 <__avr32_udiv64+0x228>
8000fcc6:	0c 3b       	cp.w	r11,r6
8000fcc8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fccc:	f7 b8 03 01 	sublo	r8,1
8000fcd0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000fcd4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000fcd8:	0c 1b       	sub	r11,r6
8000fcda:	f0 04 06 42 	mulu.d	r2,r8,r4
8000fcde:	06 95       	mov	r5,r3
8000fce0:	16 35       	cp.w	r5,r11
8000fce2:	e0 8b 00 0a 	brhi	8000fcf6 <__avr32_udiv64+0x24e>
8000fce6:	5f 0b       	sreq	r11
8000fce8:	f4 09 09 49 	lsl	r9,r10,r9
8000fcec:	12 32       	cp.w	r2,r9
8000fcee:	5f b9       	srhi	r9
8000fcf0:	f7 e9 00 09 	and	r9,r11,r9
8000fcf4:	c0 60       	breq	8000fd00 <__avr32_udiv64+0x258>
8000fcf6:	20 18       	sub	r8,1
8000fcf8:	30 09       	mov	r9,0
8000fcfa:	c0 38       	rjmp	8000fd00 <__avr32_udiv64+0x258>
8000fcfc:	30 09       	mov	r9,0
8000fcfe:	12 98       	mov	r8,r9
8000fd00:	10 9a       	mov	r10,r8
8000fd02:	12 93       	mov	r3,r9
8000fd04:	10 92       	mov	r2,r8
8000fd06:	12 9b       	mov	r11,r9
8000fd08:	2f dd       	sub	sp,-12
8000fd0a:	d8 32       	popm	r0-r7,pc

8000fd0c <__avr32_umod64>:
8000fd0c:	d4 31       	pushm	r0-r7,lr
8000fd0e:	1a 97       	mov	r7,sp
8000fd10:	20 3d       	sub	sp,12
8000fd12:	10 9c       	mov	r12,r8
8000fd14:	12 95       	mov	r5,r9
8000fd16:	14 9e       	mov	lr,r10
8000fd18:	16 91       	mov	r1,r11
8000fd1a:	16 96       	mov	r6,r11
8000fd1c:	58 09       	cp.w	r9,0
8000fd1e:	e0 81 00 81 	brne	8000fe20 <__avr32_umod64+0x114>
8000fd22:	16 38       	cp.w	r8,r11
8000fd24:	e0 88 00 12 	brls	8000fd48 <__avr32_umod64+0x3c>
8000fd28:	f0 08 12 00 	clz	r8,r8
8000fd2c:	c4 e0       	breq	8000fdc8 <__avr32_umod64+0xbc>
8000fd2e:	f6 08 09 46 	lsl	r6,r11,r8
8000fd32:	f8 08 09 4c 	lsl	r12,r12,r8
8000fd36:	f0 0b 11 20 	rsub	r11,r8,32
8000fd3a:	f4 08 09 4e 	lsl	lr,r10,r8
8000fd3e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000fd42:	f7 e6 10 06 	or	r6,r11,r6
8000fd46:	c4 18       	rjmp	8000fdc8 <__avr32_umod64+0xbc>
8000fd48:	58 08       	cp.w	r8,0
8000fd4a:	c0 51       	brne	8000fd54 <__avr32_umod64+0x48>
8000fd4c:	30 19       	mov	r9,1
8000fd4e:	f2 08 0d 08 	divu	r8,r9,r8
8000fd52:	10 9c       	mov	r12,r8
8000fd54:	f8 08 12 00 	clz	r8,r12
8000fd58:	c0 31       	brne	8000fd5e <__avr32_umod64+0x52>
8000fd5a:	18 16       	sub	r6,r12
8000fd5c:	c3 68       	rjmp	8000fdc8 <__avr32_umod64+0xbc>
8000fd5e:	f0 03 11 20 	rsub	r3,r8,32
8000fd62:	f4 03 0a 4b 	lsr	r11,r10,r3
8000fd66:	f8 08 09 4c 	lsl	r12,r12,r8
8000fd6a:	ec 08 09 49 	lsl	r9,r6,r8
8000fd6e:	ec 03 0a 43 	lsr	r3,r6,r3
8000fd72:	f7 e9 10 09 	or	r9,r11,r9
8000fd76:	f8 05 16 10 	lsr	r5,r12,0x10
8000fd7a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000fd7e:	e6 05 0d 02 	divu	r2,r3,r5
8000fd82:	f2 0e 16 10 	lsr	lr,r9,0x10
8000fd86:	ec 02 02 4b 	mul	r11,r6,r2
8000fd8a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000fd8e:	16 3e       	cp.w	lr,r11
8000fd90:	c0 72       	brcc	8000fd9e <__avr32_umod64+0x92>
8000fd92:	18 0e       	add	lr,r12
8000fd94:	18 3e       	cp.w	lr,r12
8000fd96:	c0 43       	brcs	8000fd9e <__avr32_umod64+0x92>
8000fd98:	16 3e       	cp.w	lr,r11
8000fd9a:	fd dc e3 0e 	addcs	lr,lr,r12
8000fd9e:	fc 0b 01 03 	sub	r3,lr,r11
8000fda2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000fda6:	e6 05 0d 02 	divu	r2,r3,r5
8000fdaa:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000fdae:	a5 36       	mul	r6,r2
8000fdb0:	0c 39       	cp.w	r9,r6
8000fdb2:	c0 72       	brcc	8000fdc0 <__avr32_umod64+0xb4>
8000fdb4:	18 09       	add	r9,r12
8000fdb6:	18 39       	cp.w	r9,r12
8000fdb8:	c0 43       	brcs	8000fdc0 <__avr32_umod64+0xb4>
8000fdba:	0c 39       	cp.w	r9,r6
8000fdbc:	f3 dc e3 09 	addcs	r9,r9,r12
8000fdc0:	f2 06 01 06 	sub	r6,r9,r6
8000fdc4:	f4 08 09 4e 	lsl	lr,r10,r8
8000fdc8:	f8 0a 16 10 	lsr	r10,r12,0x10
8000fdcc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000fdd0:	ec 0a 0d 02 	divu	r2,r6,r10
8000fdd4:	fc 09 16 10 	lsr	r9,lr,0x10
8000fdd8:	ea 02 02 4b 	mul	r11,r5,r2
8000fddc:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000fde0:	16 39       	cp.w	r9,r11
8000fde2:	c0 72       	brcc	8000fdf0 <__avr32_umod64+0xe4>
8000fde4:	18 09       	add	r9,r12
8000fde6:	18 39       	cp.w	r9,r12
8000fde8:	c0 43       	brcs	8000fdf0 <__avr32_umod64+0xe4>
8000fdea:	16 39       	cp.w	r9,r11
8000fdec:	f3 dc e3 09 	addcs	r9,r9,r12
8000fdf0:	f2 0b 01 0b 	sub	r11,r9,r11
8000fdf4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000fdf8:	f6 0a 0d 0a 	divu	r10,r11,r10
8000fdfc:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000fe00:	ea 0a 02 4a 	mul	r10,r5,r10
8000fe04:	14 3e       	cp.w	lr,r10
8000fe06:	c0 72       	brcc	8000fe14 <__avr32_umod64+0x108>
8000fe08:	18 0e       	add	lr,r12
8000fe0a:	18 3e       	cp.w	lr,r12
8000fe0c:	c0 43       	brcs	8000fe14 <__avr32_umod64+0x108>
8000fe0e:	14 3e       	cp.w	lr,r10
8000fe10:	fd dc e3 0e 	addcs	lr,lr,r12
8000fe14:	fc 0a 01 0a 	sub	r10,lr,r10
8000fe18:	30 0b       	mov	r11,0
8000fe1a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000fe1e:	c7 b8       	rjmp	8000ff14 <__avr32_umod64+0x208>
8000fe20:	16 39       	cp.w	r9,r11
8000fe22:	e0 8b 00 79 	brhi	8000ff14 <__avr32_umod64+0x208>
8000fe26:	f2 09 12 00 	clz	r9,r9
8000fe2a:	c1 21       	brne	8000fe4e <__avr32_umod64+0x142>
8000fe2c:	10 3a       	cp.w	r10,r8
8000fe2e:	5f 2b       	srhs	r11
8000fe30:	0a 31       	cp.w	r1,r5
8000fe32:	5f ba       	srhi	r10
8000fe34:	f7 ea 10 0a 	or	r10,r11,r10
8000fe38:	f2 0a 18 00 	cp.b	r10,r9
8000fe3c:	c0 60       	breq	8000fe48 <__avr32_umod64+0x13c>
8000fe3e:	fc 08 01 0c 	sub	r12,lr,r8
8000fe42:	e2 05 01 46 	sbc	r6,r1,r5
8000fe46:	18 9e       	mov	lr,r12
8000fe48:	0c 9b       	mov	r11,r6
8000fe4a:	1c 9a       	mov	r10,lr
8000fe4c:	c6 48       	rjmp	8000ff14 <__avr32_umod64+0x208>
8000fe4e:	ea 09 09 4c 	lsl	r12,r5,r9
8000fe52:	f2 06 11 20 	rsub	r6,r9,32
8000fe56:	f6 09 09 4b 	lsl	r11,r11,r9
8000fe5a:	f0 09 09 42 	lsl	r2,r8,r9
8000fe5e:	ef 46 ff f4 	st.w	r7[-12],r6
8000fe62:	f0 06 0a 48 	lsr	r8,r8,r6
8000fe66:	18 48       	or	r8,r12
8000fe68:	e2 06 0a 4c 	lsr	r12,r1,r6
8000fe6c:	f4 09 09 43 	lsl	r3,r10,r9
8000fe70:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000fe74:	f4 06 0a 4a 	lsr	r10,r10,r6
8000fe78:	16 4a       	or	r10,r11
8000fe7a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000fe7e:	f8 0b 0d 04 	divu	r4,r12,r11
8000fe82:	f4 0c 16 10 	lsr	r12,r10,0x10
8000fe86:	08 91       	mov	r1,r4
8000fe88:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000fe8c:	e8 0e 02 46 	mul	r6,r4,lr
8000fe90:	0c 3c       	cp.w	r12,r6
8000fe92:	c0 a2       	brcc	8000fea6 <__avr32_umod64+0x19a>
8000fe94:	20 11       	sub	r1,1
8000fe96:	10 0c       	add	r12,r8
8000fe98:	10 3c       	cp.w	r12,r8
8000fe9a:	c0 63       	brcs	8000fea6 <__avr32_umod64+0x19a>
8000fe9c:	0c 3c       	cp.w	r12,r6
8000fe9e:	f7 b1 03 01 	sublo	r1,1
8000fea2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000fea6:	0c 1c       	sub	r12,r6
8000fea8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000feac:	f8 0b 0d 04 	divu	r4,r12,r11
8000feb0:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000feb4:	08 96       	mov	r6,r4
8000feb6:	e8 0e 02 4e 	mul	lr,r4,lr
8000feba:	1c 3b       	cp.w	r11,lr
8000febc:	c0 a2       	brcc	8000fed0 <__avr32_umod64+0x1c4>
8000febe:	20 16       	sub	r6,1
8000fec0:	10 0b       	add	r11,r8
8000fec2:	10 3b       	cp.w	r11,r8
8000fec4:	c0 63       	brcs	8000fed0 <__avr32_umod64+0x1c4>
8000fec6:	1c 3b       	cp.w	r11,lr
8000fec8:	f7 b6 03 01 	sublo	r6,1
8000fecc:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000fed0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000fed4:	1c 1b       	sub	r11,lr
8000fed6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000feda:	00 9e       	mov	lr,r0
8000fedc:	02 9c       	mov	r12,r1
8000fede:	16 3c       	cp.w	r12,r11
8000fee0:	e0 8b 00 08 	brhi	8000fef0 <__avr32_umod64+0x1e4>
8000fee4:	5f 06       	sreq	r6
8000fee6:	06 30       	cp.w	r0,r3
8000fee8:	5f ba       	srhi	r10
8000feea:	ed ea 00 0a 	and	r10,r6,r10
8000feee:	c0 60       	breq	8000fefa <__avr32_umod64+0x1ee>
8000fef0:	fc 02 01 04 	sub	r4,lr,r2
8000fef4:	f8 08 01 4c 	sbc	r12,r12,r8
8000fef8:	08 9e       	mov	lr,r4
8000fefa:	e6 0e 01 0a 	sub	r10,r3,lr
8000fefe:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ff02:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ff06:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ff0a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ff0e:	f8 01 09 4c 	lsl	r12,r12,r1
8000ff12:	18 4a       	or	r10,r12
8000ff14:	2f dd       	sub	sp,-12
8000ff16:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80010000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
80010000:	c0 08       	rjmp	80010000 <_evba>
	...

80010004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
80010004:	c0 08       	rjmp	80010004 <_handle_TLB_Multiple_Hit>
	...

80010008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
80010008:	c0 08       	rjmp	80010008 <_handle_Bus_Error_Data_Fetch>
	...

8001000c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8001000c:	c0 08       	rjmp	8001000c <_handle_Bus_Error_Instruction_Fetch>
	...

80010010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
80010010:	c0 08       	rjmp	80010010 <_handle_NMI>
	...

80010014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
80010014:	c0 08       	rjmp	80010014 <_handle_Instruction_Address>
	...

80010018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
80010018:	c0 08       	rjmp	80010018 <_handle_ITLB_Protection>
	...

8001001c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8001001c:	c0 08       	rjmp	8001001c <_handle_Breakpoint>
	...

80010020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
80010020:	c0 08       	rjmp	80010020 <_handle_Illegal_Opcode>
	...

80010024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
80010024:	c0 08       	rjmp	80010024 <_handle_Unimplemented_Instruction>
	...

80010028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
80010028:	c0 08       	rjmp	80010028 <_handle_Privilege_Violation>
	...

8001002c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8001002c:	c0 08       	rjmp	8001002c <_handle_Floating_Point>
	...

80010030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
80010030:	c0 08       	rjmp	80010030 <_handle_Coprocessor_Absent>
	...

80010034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
80010034:	c0 08       	rjmp	80010034 <_handle_Data_Address_Read>
	...

80010038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
80010038:	c0 08       	rjmp	80010038 <_handle_Data_Address_Write>
	...

8001003c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8001003c:	c0 08       	rjmp	8001003c <_handle_DTLB_Protection_Read>
	...

80010040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
80010040:	c0 08       	rjmp	80010040 <_handle_DTLB_Protection_Write>
	...

80010044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
80010044:	c0 08       	rjmp	80010044 <_handle_DTLB_Modified>
	...

80010050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
80010050:	c0 08       	rjmp	80010050 <_handle_ITLB_Miss>
	...

80010060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
80010060:	c0 08       	rjmp	80010060 <_handle_DTLB_Miss_Read>
	...

80010070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
80010070:	c0 08       	rjmp	80010070 <_handle_DTLB_Miss_Write>
	...

80010100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80010100:	fe cf 72 bc 	sub	pc,pc,29372

80010104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80010104:	30 0c       	mov	r12,0
80010106:	fe b0 ae 6b 	rcall	80005ddc <_get_interrupt_handler>
8001010a:	58 0c       	cp.w	r12,0
8001010c:	f8 0f 17 10 	movne	pc,r12
80010110:	d6 03       	rete

80010112 <_int1>:
80010112:	30 1c       	mov	r12,1
80010114:	fe b0 ae 64 	rcall	80005ddc <_get_interrupt_handler>
80010118:	58 0c       	cp.w	r12,0
8001011a:	f8 0f 17 10 	movne	pc,r12
8001011e:	d6 03       	rete

80010120 <_int2>:
80010120:	30 2c       	mov	r12,2
80010122:	fe b0 ae 5d 	rcall	80005ddc <_get_interrupt_handler>
80010126:	58 0c       	cp.w	r12,0
80010128:	f8 0f 17 10 	movne	pc,r12
8001012c:	d6 03       	rete

8001012e <_int3>:
8001012e:	30 3c       	mov	r12,3
80010130:	fe b0 ae 56 	rcall	80005ddc <_get_interrupt_handler>
80010134:	58 0c       	cp.w	r12,0
80010136:	f8 0f 17 10 	movne	pc,r12
8001013a:	d6 03       	rete

8001013c <ipr_val>:
8001013c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8001014c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001015c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001016c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001017c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001018c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001019c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101fc:	d7 03 d7 03                                         ....
