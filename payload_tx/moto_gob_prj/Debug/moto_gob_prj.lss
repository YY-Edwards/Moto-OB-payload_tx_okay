
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002010  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000de74  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80010000  80010000  00010400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00009c30  80010200  80010200  00010600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  80019e30  0001a408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8001a864  0001ae3c  2**0
                  ALLOC
  8 .bss          00003c78  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         00012948  000046b8  000046b8  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0001ae3c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001638  00000000  00000000  0001ae70  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002b20  00000000  00000000  0001c4a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002ec49  00000000  00000000  0001efc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000078a5  00000000  00000000  0004dc11  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000e043  00000000  00000000  000554b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00003d88  00000000  00000000  000634fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00008087  00000000  00000000  00067284  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00012370  00000000  00000000  0006f30b  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001730  00000000  00000000  00081680  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	a4 00       	st.h	r2[0x0],r0

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe ff 00 04 	ld.w	pc,pc[4]
8000200c:	80 00       	ld.sh	r0,r0[0x0]
8000200e:	a4 00       	st.h	r2[0x0],r0

Disassembly of section .text:

80002010 <DeviceManagement_brdcst_func>:
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002010:	19 a9       	ld.ub	r9,r12[0x2]
80002012:	30 18       	mov	r8,1
80002014:	f0 09 18 00 	cp.b	r9,r8
80002018:	c0 61       	brne	80002024 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000201a:	48 68       	lddpc	r8,80002030 <DeviceManagement_brdcst_func+0x20>
8000201c:	70 09       	ld.w	r9,r8[0x0]
8000201e:	a1 b9       	sbr	r9,0x1
80002020:	91 09       	st.w	r8[0x0],r9
80002022:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002024:	48 38       	lddpc	r8,80002030 <DeviceManagement_brdcst_func+0x20>
80002026:	70 09       	ld.w	r9,r8[0x0]
80002028:	a1 d9       	cbr	r9,0x1
8000202a:	91 09       	st.w	r8[0x0],r9
8000202c:	5e fc       	retal	r12
8000202e:	00 00       	add	r0,r0
80002030:	00 00       	add	r0,r0
80002032:	13 54       	ld.sh	r4,--r9

80002034 <mic_brdcst_func>:
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002034:	5e fc       	retal	r12

80002036 <TransmitControl_brdcst_func>:
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002036:	5e fc       	retal	r12

80002038 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002038:	48 38       	lddpc	r8,80002044 <vApplicationIdleHook+0xc>
8000203a:	70 09       	ld.w	r9,r8[0x0]
8000203c:	2f f9       	sub	r9,-1
8000203e:	91 09       	st.w	r8[0x0],r9
	
}
80002040:	5e fc       	retal	r12
80002042:	00 00       	add	r0,r0
80002044:	00 00       	add	r0,r0
80002046:	0a 58       	eor	r8,r5

80002048 <app_init>:
														
		
};

void app_init(void)
{	
80002048:	d4 01       	pushm	lr
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
8000204a:	48 cb       	lddpc	r11,80002078 <app_init+0x30>
8000204c:	48 cc       	lddpc	r12,8000207c <app_init+0x34>
8000204e:	f0 1f 00 0d 	mcall	80002080 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
80002052:	48 dc       	lddpc	r12,80002084 <app_init+0x3c>
80002054:	f0 1f 00 0d 	mcall	80002088 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002058:	30 09       	mov	r9,0
8000205a:	1a d9       	st.w	--sp,r9
8000205c:	1a d9       	st.w	--sp,r9
8000205e:	1a d9       	st.w	--sp,r9
80002060:	30 18       	mov	r8,1
80002062:	e0 6a 01 80 	mov	r10,384
80002066:	48 ab       	lddpc	r11,8000208c <app_init+0x44>
80002068:	48 ac       	lddpc	r12,80002090 <app_init+0x48>
8000206a:	f0 1f 00 0b 	mcall	80002094 <app_init+0x4c>
8000206e:	48 b8       	lddpc	r8,80002098 <app_init+0x50>
80002070:	91 0c       	st.w	r8[0x0],r12
80002072:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
80002074:	d8 02       	popm	pc
80002076:	00 00       	add	r0,r0
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 90       	sub	r0,-119
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	28 f4       	sub	r4,-113
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3b e4       	mov	r4,-66
80002084:	00 00       	add	r0,r0
80002086:	00 08       	add	r8,r0
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	50 94       	stdsp	sp[0x24],r4
8000208c:	80 01       	ld.sh	r1,r0[0x0]
8000208e:	02 00       	add	r0,r1
80002090:	80 00       	ld.sh	r0,r0[0x0]
80002092:	27 d0       	sub	r0,125
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	9b 34       	st.w	sp[0xc],r4
80002098:	00 00       	add	r0,r0
8000209a:	0a 54       	eor	r4,r5

8000209c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000209c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000209e:	48 3c       	lddpc	r12,800020a8 <FD_brdcst_func+0xc>
800020a0:	f0 1f 00 03 	mcall	800020ac <FD_brdcst_func+0x10>
	
}
800020a4:	d8 02       	popm	pc
800020a6:	00 00       	add	r0,r0
800020a8:	80 01       	ld.sh	r1,r0[0x0]
800020aa:	02 08       	add	r8,r1
800020ac:	80 00       	ld.sh	r0,r0[0x0]
800020ae:	9e f8       	ld.uh	r8,pc[0xe]

800020b0 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020b0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020b2:	48 3c       	lddpc	r12,800020bc <FD_reply_func+0xc>
800020b4:	f0 1f 00 03 	mcall	800020c0 <FD_reply_func+0x10>
	
	
}
800020b8:	d8 02       	popm	pc
800020ba:	00 00       	add	r0,r0
800020bc:	80 01       	ld.sh	r1,r0[0x0]
800020be:	02 28       	rsub	r8,r1
800020c0:	80 00       	ld.sh	r0,r0[0x0]
800020c2:	9e f8       	ld.uh	r8,pc[0xe]

800020c4 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020c4:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020c6:	48 3c       	lddpc	r12,800020d0 <FD_request_func+0xc>
800020c8:	f0 1f 00 03 	mcall	800020d4 <FD_request_func+0x10>
	
	
}
800020cc:	d8 02       	popm	pc
800020ce:	00 00       	add	r0,r0
800020d0:	80 01       	ld.sh	r1,r0[0x0]
800020d2:	02 44       	or	r4,r1
800020d4:	80 00       	ld.sh	r0,r0[0x0]
800020d6:	9e f8       	ld.uh	r8,pc[0xe]

800020d8 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <EnOB_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <EnOB_brdcst_func+0x10>
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 01       	ld.sh	r1,r0[0x0]
800020e6:	02 60       	and	r0,r1
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	9e f8       	ld.uh	r8,pc[0xe]

800020ec <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	eb cd 40 80 	pushm	r7,lr
800020f0:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020f2:	19 a9       	ld.ub	r9,r12[0x2]
800020f4:	30 08       	mov	r8,0
800020f6:	f0 09 18 00 	cp.b	r9,r8
800020fa:	c1 91       	brne	8000212c <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
800020fc:	19 b8       	ld.ub	r8,r12[0x3]
800020fe:	30 19       	mov	r9,1
80002100:	f2 08 18 00 	cp.b	r8,r9
80002104:	c0 61       	brne	80002110 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002106:	49 0c       	lddpc	r12,80002144 <EnOB_reply_func+0x58>
80002108:	f0 1f 00 10 	mcall	80002148 <EnOB_reply_func+0x5c>
8000210c:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002110:	58 08       	cp.w	r8,0
80002112:	c0 61       	brne	8000211e <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002114:	48 ec       	lddpc	r12,8000214c <EnOB_reply_func+0x60>
80002116:	f0 1f 00 0d 	mcall	80002148 <EnOB_reply_func+0x5c>
8000211a:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000211e:	1a d8       	st.w	--sp,r8
80002120:	48 cc       	lddpc	r12,80002150 <EnOB_reply_func+0x64>
80002122:	f0 1f 00 0a 	mcall	80002148 <EnOB_reply_func+0x5c>
80002126:	2f fd       	sub	sp,-4
80002128:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
8000212c:	48 ac       	lddpc	r12,80002154 <EnOB_reply_func+0x68>
8000212e:	f0 1f 00 07 	mcall	80002148 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
80002132:	0f a8       	ld.ub	r8,r7[0x2]
80002134:	1a d8       	st.w	--sp,r8
80002136:	48 9c       	lddpc	r12,80002158 <EnOB_reply_func+0x6c>
80002138:	f0 1f 00 04 	mcall	80002148 <EnOB_reply_func+0x5c>
8000213c:	2f fd       	sub	sp,-4
8000213e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002142:	00 00       	add	r0,r0
80002144:	80 01       	ld.sh	r1,r0[0x0]
80002146:	02 78       	tst	r8,r1
80002148:	80 00       	ld.sh	r0,r0[0x0]
8000214a:	9e f8       	ld.uh	r8,pc[0xe]
8000214c:	80 01       	ld.sh	r1,r0[0x0]
8000214e:	02 90       	mov	r0,r1
80002150:	80 01       	ld.sh	r1,r0[0x0]
80002152:	02 a4       	st.w	r1++,r4
80002154:	80 01       	ld.sh	r1,r0[0x0]
80002156:	02 bc       	st.h	r1++,r12
80002158:	80 01       	ld.sh	r1,r0[0x0]
8000215a:	02 d8       	st.w	--r1,r8

8000215c <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
8000215c:	eb cd 40 80 	pushm	r7,lr
80002160:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
80002162:	19 a9       	ld.ub	r9,r12[0x2]
80002164:	31 18       	mov	r8,17
80002166:	f0 09 18 00 	cp.b	r9,r8
8000216a:	c0 61       	brne	80002176 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
8000216c:	48 8c       	lddpc	r12,8000218c <SingleDetection_brdcst_func+0x30>
8000216e:	f0 1f 00 09 	mcall	80002190 <SingleDetection_brdcst_func+0x34>
80002172:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002176:	48 8c       	lddpc	r12,80002194 <SingleDetection_brdcst_func+0x38>
80002178:	f0 1f 00 06 	mcall	80002190 <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
8000217c:	0f a8       	ld.ub	r8,r7[0x2]
8000217e:	1a d8       	st.w	--sp,r8
80002180:	48 6c       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x3c>
80002182:	f0 1f 00 04 	mcall	80002190 <SingleDetection_brdcst_func+0x34>
80002186:	2f fd       	sub	sp,-4
80002188:	e3 cd 80 80 	ldm	sp++,r7,pc
8000218c:	80 01       	ld.sh	r1,r0[0x0]
8000218e:	02 f0       	st.b	--r1,r0
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	9e f8       	ld.uh	r8,pc[0xe]
80002194:	80 01       	ld.sh	r1,r0[0x0]
80002196:	03 04       	ld.w	r4,r1++
80002198:	80 01       	ld.sh	r1,r0[0x0]
8000219a:	03 14       	ld.sh	r4,r1++

8000219c <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
8000219c:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000219e:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021a2:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021a4:	4a bc       	lddpc	r12,80002250 <ButtonConfig_brdcst_func+0xb4>
800021a6:	f0 1f 00 2c 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021aa:	0f 88       	ld.ub	r8,r7[0x0]
800021ac:	1a d8       	st.w	--sp,r8
800021ae:	4a bc       	lddpc	r12,80002258 <ButtonConfig_brdcst_func+0xbc>
800021b0:	f0 1f 00 29 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021b4:	1a d5       	st.w	--sp,r5
800021b6:	4a ac       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xc0>
800021b8:	f0 1f 00 27 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021bc:	0f a8       	ld.ub	r8,r7[0x2]
800021be:	1a d8       	st.w	--sp,r8
800021c0:	4a 8c       	lddpc	r12,80002260 <ButtonConfig_brdcst_func+0xc4>
800021c2:	f0 1f 00 25 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021c6:	2f dd       	sub	sp,-12
800021c8:	58 05       	cp.w	r5,0
800021ca:	c4 10       	breq	8000224c <ButtonConfig_brdcst_func+0xb0>
800021cc:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021ce:	4a 64       	lddpc	r4,80002264 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021d0:	4a 63       	lddpc	r3,80002268 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021d2:	4a 72       	lddpc	r2,8000226c <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021d4:	4a 71       	lddpc	r1,80002270 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021d6:	4a 80       	lddpc	r0,80002274 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021d8:	0f b9       	ld.ub	r9,r7[0x3]
800021da:	0f c8       	ld.ub	r8,r7[0x4]
800021dc:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021e0:	1a d8       	st.w	--sp,r8
800021e2:	1a d6       	st.w	--sp,r6
800021e4:	08 9c       	mov	r12,r4
800021e6:	f0 1f 00 1c 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021ea:	0f d9       	ld.ub	r9,r7[0x5]
800021ec:	0f e8       	ld.ub	r8,r7[0x6]
800021ee:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f2:	1a d8       	st.w	--sp,r8
800021f4:	1a d6       	st.w	--sp,r6
800021f6:	06 9c       	mov	r12,r3
800021f8:	f0 1f 00 17 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021fc:	0f f9       	ld.ub	r9,r7[0x7]
800021fe:	ef 38 00 08 	ld.ub	r8,r7[8]
80002202:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002206:	1a d8       	st.w	--sp,r8
80002208:	1a d6       	st.w	--sp,r6
8000220a:	04 9c       	mov	r12,r2
8000220c:	f0 1f 00 12 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002210:	ef 39 00 09 	ld.ub	r9,r7[9]
80002214:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002218:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221c:	1a d8       	st.w	--sp,r8
8000221e:	1a d6       	st.w	--sp,r6
80002220:	02 9c       	mov	r12,r1
80002222:	f0 1f 00 0d 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002226:	2f 8d       	sub	sp,-32
80002228:	ef 39 00 0b 	ld.ub	r9,r7[11]
8000222c:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002230:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002234:	1a d8       	st.w	--sp,r8
80002236:	1a d6       	st.w	--sp,r6
80002238:	00 9c       	mov	r12,r0
8000223a:	f0 1f 00 07 	mcall	80002254 <ButtonConfig_brdcst_func+0xb8>
8000223e:	2f f6       	sub	r6,-1
80002240:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
80002242:	2f ed       	sub	sp,-8
80002244:	ec 05 18 00 	cp.b	r5,r6
80002248:	fe 9b ff c8 	brhi	800021d8 <ButtonConfig_brdcst_func+0x3c>
8000224c:	d8 32       	popm	r0-r7,pc
8000224e:	00 00       	add	r0,r0
80002250:	80 01       	ld.sh	r1,r0[0x0]
80002252:	03 2c       	ld.uh	r12,r1++
80002254:	80 00       	ld.sh	r0,r0[0x0]
80002256:	9e f8       	ld.uh	r8,pc[0xe]
80002258:	80 01       	ld.sh	r1,r0[0x0]
8000225a:	03 4c       	ld.w	r12,--r1
8000225c:	80 01       	ld.sh	r1,r0[0x0]
8000225e:	03 60       	ld.uh	r0,--r1
80002260:	80 01       	ld.sh	r1,r0[0x0]
80002262:	03 78       	ld.ub	r8,--r1
80002264:	80 01       	ld.sh	r1,r0[0x0]
80002266:	03 98       	ld.ub	r8,r1[0x1]
80002268:	80 01       	ld.sh	r1,r0[0x0]
8000226a:	03 c0       	ld.ub	r0,r1[0x4]
8000226c:	80 01       	ld.sh	r1,r0[0x0]
8000226e:	03 e8       	ld.ub	r8,r1[0x6]
80002270:	80 01       	ld.sh	r1,r0[0x0]
80002272:	04 0c       	add	r12,r2
80002274:	80 01       	ld.sh	r1,r0[0x0]
80002276:	04 34       	cp.w	r4,r2

80002278 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002278:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
8000227c:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000227e:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002280:	19 c7       	ld.ub	r7,r12[0x4]
80002282:	19 d8       	ld.ub	r8,r12[0x5]
80002284:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002288:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
8000228a:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
8000228c:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002290:	49 0c       	lddpc	r12,800022d0 <Phyuserinput_brdcst_func+0x58>
80002292:	f0 1f 00 11 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002296:	1a d6       	st.w	--sp,r6
80002298:	49 0c       	lddpc	r12,800022d8 <Phyuserinput_brdcst_func+0x60>
8000229a:	f0 1f 00 0f 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000229e:	1a d5       	st.w	--sp,r5
800022a0:	48 fc       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x64>
800022a2:	f0 1f 00 0d 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022a6:	5c 77       	castu.h	r7
800022a8:	1a d7       	st.w	--sp,r7
800022aa:	48 ec       	lddpc	r12,800022e0 <Phyuserinput_brdcst_func+0x68>
800022ac:	f0 1f 00 0a 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022b0:	1a d4       	st.w	--sp,r4
800022b2:	48 dc       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x6c>
800022b4:	f0 1f 00 08 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022b8:	1a d3       	st.w	--sp,r3
800022ba:	48 cc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x70>
800022bc:	f0 1f 00 06 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022c0:	1a d2       	st.w	--sp,r2
800022c2:	48 bc       	lddpc	r12,800022ec <Phyuserinput_brdcst_func+0x74>
800022c4:	f0 1f 00 04 	mcall	800022d4 <Phyuserinput_brdcst_func+0x5c>
800022c8:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022ca:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022ce:	00 00       	add	r0,r0
800022d0:	80 01       	ld.sh	r1,r0[0x0]
800022d2:	04 58       	eor	r8,r2
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	9e f8       	ld.uh	r8,pc[0xe]
800022d8:	80 01       	ld.sh	r1,r0[0x0]
800022da:	04 7c       	tst	r12,r2
800022dc:	80 01       	ld.sh	r1,r0[0x0]
800022de:	04 94       	mov	r4,r2
800022e0:	80 01       	ld.sh	r1,r0[0x0]
800022e2:	04 a8       	st.w	r2++,r8
800022e4:	80 01       	ld.sh	r1,r0[0x0]
800022e6:	04 bc       	st.h	r2++,r12
800022e8:	80 01       	ld.sh	r1,r0[0x0]
800022ea:	04 d0       	st.w	--r2,r0
800022ec:	80 01       	ld.sh	r1,r0[0x0]
800022ee:	04 f0       	st.b	--r2,r0

800022f0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022f0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022f4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022f8:	0f 89       	ld.ub	r9,r7[0x0]
800022fa:	30 08       	mov	r8,0
800022fc:	f0 09 18 00 	cp.b	r9,r8
80002300:	c0 c1       	brne	80002318 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002302:	48 9c       	lddpc	r12,80002324 <ButtonConfig_reply_func+0x34>
80002304:	f0 1f 00 09 	mcall	80002328 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002308:	0f 98       	ld.ub	r8,r7[0x1]
8000230a:	1a d8       	st.w	--sp,r8
8000230c:	48 8c       	lddpc	r12,8000232c <ButtonConfig_reply_func+0x3c>
8000230e:	f0 1f 00 07 	mcall	80002328 <ButtonConfig_reply_func+0x38>
80002312:	2f fd       	sub	sp,-4
80002314:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002318:	48 6c       	lddpc	r12,80002330 <ButtonConfig_reply_func+0x40>
8000231a:	f0 1f 00 04 	mcall	80002328 <ButtonConfig_reply_func+0x38>
8000231e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002322:	00 00       	add	r0,r0
80002324:	80 01       	ld.sh	r1,r0[0x0]
80002326:	05 10       	ld.sh	r0,r2++
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	9e f8       	ld.uh	r8,pc[0xe]
8000232c:	80 01       	ld.sh	r1,r0[0x0]
8000232e:	03 4c       	ld.w	r12,--r1
80002330:	80 01       	ld.sh	r1,r0[0x0]
80002332:	05 28       	ld.uh	r8,r2++

80002334 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002334:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002336:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
8000233a:	0d 88       	ld.ub	r8,r6[0x0]
8000233c:	32 49       	mov	r9,36
8000233e:	f2 08 18 00 	cp.b	r8,r9
80002342:	c2 91       	brne	80002394 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002344:	49 7c       	lddpc	r12,800023a0 <DataSession_brdcst_func+0x6c>
80002346:	f0 1f 00 18 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
8000234a:	0d a5       	ld.ub	r5,r6[0x2]
8000234c:	0d b8       	ld.ub	r8,r6[0x3]
8000234e:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002352:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002354:	0d 98       	ld.ub	r8,r6[0x1]
80002356:	1a d8       	st.w	--sp,r8
80002358:	49 4c       	lddpc	r12,800023a8 <DataSession_brdcst_func+0x74>
8000235a:	f0 1f 00 13 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000235e:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002362:	1a d8       	st.w	--sp,r8
80002364:	49 2c       	lddpc	r12,800023ac <DataSession_brdcst_func+0x78>
80002366:	f0 1f 00 10 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
8000236a:	2f ed       	sub	sp,-8
8000236c:	58 05       	cp.w	r5,0
8000236e:	c1 80       	breq	8000239e <DataSession_brdcst_func+0x6a>
80002370:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002372:	49 04       	lddpc	r4,800023b0 <DataSession_brdcst_func+0x7c>
80002374:	ec 07 00 08 	add	r8,r6,r7
80002378:	11 c8       	ld.ub	r8,r8[0x4]
8000237a:	1a d8       	st.w	--sp,r8
8000237c:	1a d7       	st.w	--sp,r7
8000237e:	08 9c       	mov	r12,r4
80002380:	f0 1f 00 09 	mcall	800023a4 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002384:	2f f7       	sub	r7,-1
80002386:	5c 57       	castu.b	r7
80002388:	2f ed       	sub	sp,-8
8000238a:	ee 05 19 00 	cp.h	r5,r7
8000238e:	fe 9b ff f3 	brhi	80002374 <DataSession_brdcst_func+0x40>
80002392:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002394:	1a d8       	st.w	--sp,r8
80002396:	48 8c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0x80>
80002398:	f0 1f 00 03 	mcall	800023a4 <DataSession_brdcst_func+0x70>
8000239c:	2f fd       	sub	sp,-4
8000239e:	d8 22       	popm	r4-r7,pc
800023a0:	80 01       	ld.sh	r1,r0[0x0]
800023a2:	05 44       	ld.w	r4,--r2
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	9e f8       	ld.uh	r8,pc[0xe]
800023a8:	80 01       	ld.sh	r1,r0[0x0]
800023aa:	05 58       	ld.sh	r8,--r2
800023ac:	80 01       	ld.sh	r1,r0[0x0]
800023ae:	05 70       	ld.ub	r0,--r2
800023b0:	80 01       	ld.sh	r1,r0[0x0]
800023b2:	05 8c       	ld.ub	r12,r2[0x0]
800023b4:	80 01       	ld.sh	r1,r0[0x0]
800023b6:	05 a4       	ld.ub	r4,r2[0x2]

800023b8 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023b8:	eb cd 40 80 	pushm	r7,lr
800023bc:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023be:	19 a8       	ld.ub	r8,r12[0x2]
800023c0:	58 08       	cp.w	r8,0
800023c2:	c0 61       	brne	800023ce <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023c4:	48 dc       	lddpc	r12,800023f8 <DataSession_reply_func+0x40>
800023c6:	f0 1f 00 0e 	mcall	800023fc <DataSession_reply_func+0x44>
800023ca:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023ce:	1a d8       	st.w	--sp,r8
800023d0:	48 cc       	lddpc	r12,80002400 <DataSession_reply_func+0x48>
800023d2:	f0 1f 00 0b 	mcall	800023fc <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023d6:	48 cc       	lddpc	r12,80002404 <DataSession_reply_func+0x4c>
800023d8:	f0 1f 00 09 	mcall	800023fc <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023dc:	0f b8       	ld.ub	r8,r7[0x3]
800023de:	1a d8       	st.w	--sp,r8
800023e0:	48 ac       	lddpc	r12,80002408 <DataSession_reply_func+0x50>
800023e2:	f0 1f 00 07 	mcall	800023fc <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023e6:	0f c8       	ld.ub	r8,r7[0x4]
800023e8:	1a d8       	st.w	--sp,r8
800023ea:	48 9c       	lddpc	r12,8000240c <DataSession_reply_func+0x54>
800023ec:	f0 1f 00 04 	mcall	800023fc <DataSession_reply_func+0x44>
800023f0:	2f dd       	sub	sp,-12
800023f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800023f6:	00 00       	add	r0,r0
800023f8:	80 01       	ld.sh	r1,r0[0x0]
800023fa:	05 b8       	ld.ub	r8,r2[0x3]
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	9e f8       	ld.uh	r8,pc[0xe]
80002400:	80 01       	ld.sh	r1,r0[0x0]
80002402:	05 cc       	ld.ub	r12,r2[0x4]
80002404:	80 01       	ld.sh	r1,r0[0x0]
80002406:	05 e0       	ld.ub	r0,r2[0x6]
80002408:	80 01       	ld.sh	r1,r0[0x0]
8000240a:	05 f4       	ld.ub	r4,r2[0x7]
8000240c:	80 01       	ld.sh	r1,r0[0x0]
8000240e:	06 04       	add	r4,r3

80002410 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002410:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002414:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002418:	0f 89       	ld.ub	r9,r7[0x0]
8000241a:	30 08       	mov	r8,0
8000241c:	f0 09 18 00 	cp.b	r9,r8
80002420:	c2 21       	brne	80002464 <TransmitControl_reply_func+0x54>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002422:	49 4c       	lddpc	r12,80002470 <TransmitControl_reply_func+0x60>
80002424:	f0 1f 00 14 	mcall	80002474 <TransmitControl_reply_func+0x64>
		log("\n\r Function: %x \n\r", ptr->Function);
80002428:	0f 98       	ld.ub	r8,r7[0x1]
8000242a:	1a d8       	st.w	--sp,r8
8000242c:	49 3c       	lddpc	r12,80002478 <TransmitControl_reply_func+0x68>
8000242e:	f0 1f 00 12 	mcall	80002474 <TransmitControl_reply_func+0x64>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002432:	0f a8       	ld.ub	r8,r7[0x2]
80002434:	1a d8       	st.w	--sp,r8
80002436:	49 2c       	lddpc	r12,8000247c <TransmitControl_reply_func+0x6c>
80002438:	f0 1f 00 0f 	mcall	80002474 <TransmitControl_reply_func+0x64>
		log("\n\r State: %x \n\r", ptr->State);
8000243c:	0f b8       	ld.ub	r8,r7[0x3]
8000243e:	1a d8       	st.w	--sp,r8
80002440:	49 0c       	lddpc	r12,80002480 <TransmitControl_reply_func+0x70>
80002442:	f0 1f 00 0d 	mcall	80002474 <TransmitControl_reply_func+0x64>
		
		if (ptr->Function == KEY_UP)
80002446:	0f 98       	ld.ub	r8,r7[0x1]
80002448:	2f dd       	sub	sp,-12
8000244a:	30 19       	mov	r9,1
8000244c:	f2 08 18 00 	cp.b	r8,r9
80002450:	c0 d0       	breq	8000246a <TransmitControl_reply_func+0x5a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
80002452:	30 29       	mov	r9,2
80002454:	f2 08 18 00 	cp.b	r8,r9
80002458:	c0 91       	brne	8000246a <TransmitControl_reply_func+0x5a>
		{
			is_unmute = 0;
8000245a:	30 09       	mov	r9,0
8000245c:	48 a8       	lddpc	r8,80002484 <TransmitControl_reply_func+0x74>
8000245e:	b0 89       	st.b	r8[0x0],r9
80002460:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002464:	48 9c       	lddpc	r12,80002488 <TransmitControl_reply_func+0x78>
80002466:	f0 1f 00 04 	mcall	80002474 <TransmitControl_reply_func+0x64>
8000246a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246e:	00 00       	add	r0,r0
80002470:	80 01       	ld.sh	r1,r0[0x0]
80002472:	06 14       	sub	r4,r3
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	9e f8       	ld.uh	r8,pc[0xe]
80002478:	80 01       	ld.sh	r1,r0[0x0]
8000247a:	06 30       	cp.w	r0,r3
8000247c:	80 01       	ld.sh	r1,r0[0x0]
8000247e:	06 44       	or	r4,r3
80002480:	80 01       	ld.sh	r1,r0[0x0]
80002482:	06 60       	and	r0,r3
80002484:	00 00       	add	r0,r0
80002486:	0a 48       	or	r8,r5
80002488:	80 01       	ld.sh	r1,r0[0x0]
8000248a:	06 70       	tst	r0,r3

8000248c <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000248c:	eb cd 40 f8 	pushm	r3-r7,lr
80002490:	18 96       	mov	r6,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
80002492:	19 a5       	ld.ub	r5,r12[0x2]
80002494:	19 b8       	ld.ub	r8,r12[0x3]
80002496:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000249a:	5c 85       	casts.h	r5
	log("\n\r num_routings: %d \n\r", num_routings);
8000249c:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800024a0:	1a d8       	st.w	--sp,r8
800024a2:	49 6c       	lddpc	r12,800024f8 <AudioRoutingControl_brdcst_func+0x6c>
800024a4:	f0 1f 00 16 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
	
	for(j = 0; j< num_routings ; j++ )
800024a8:	2f fd       	sub	sp,-4
800024aa:	58 05       	cp.w	r5,0
800024ac:	c0 31       	brne	800024b2 <AudioRoutingControl_brdcst_func+0x26>
800024ae:	30 07       	mov	r7,0
800024b0:	c1 98       	rjmp	800024e2 <AudioRoutingControl_brdcst_func+0x56>
800024b2:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b4:	49 34       	lddpc	r4,80002500 <AudioRoutingControl_brdcst_func+0x74>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024b6:	49 43       	lddpc	r3,80002504 <AudioRoutingControl_brdcst_func+0x78>
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
800024b8:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024bc:	11 c8       	ld.ub	r8,r8[0x4]
800024be:	1a d8       	st.w	--sp,r8
800024c0:	08 9c       	mov	r12,r4
800024c2:	f0 1f 00 0f 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
800024c6:	ec 07 00 18 	add	r8,r6,r7<<0x1
800024ca:	11 d8       	ld.ub	r8,r8[0x5]
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	06 9c       	mov	r12,r3
800024d0:	f0 1f 00 0b 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800024d4:	2f f7       	sub	r7,-1
800024d6:	5c 57       	castu.b	r7
800024d8:	2f ed       	sub	sp,-8
800024da:	ee 05 19 00 	cp.h	r5,r7
800024de:	fe 9b ff ed 	brhi	800024b8 <AudioRoutingControl_brdcst_func+0x2c>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
		
		
	}
	
	log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
800024e2:	ec 07 00 17 	add	r7,r6,r7<<0x1
800024e6:	0f c8       	ld.ub	r8,r7[0x4]
800024e8:	1a d8       	st.w	--sp,r8
800024ea:	48 8c       	lddpc	r12,80002508 <AudioRoutingControl_brdcst_func+0x7c>
800024ec:	f0 1f 00 04 	mcall	800024fc <AudioRoutingControl_brdcst_func+0x70>
800024f0:	2f fd       	sub	sp,-4
	
	
	
}
800024f2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800024f6:	00 00       	add	r0,r0
800024f8:	80 01       	ld.sh	r1,r0[0x0]
800024fa:	06 88       	andn	r8,r3
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	9e f8       	ld.uh	r8,pc[0xe]
80002500:	80 01       	ld.sh	r1,r0[0x0]
80002502:	06 a0       	st.w	r3++,r0
80002504:	80 01       	ld.sh	r1,r0[0x0]
80002506:	06 b8       	st.h	r3++,r8
80002508:	80 01       	ld.sh	r1,r0[0x0]
8000250a:	06 d0       	st.w	--r3,r0

8000250c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000250c:	eb cd 40 80 	pushm	r7,lr
80002510:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002512:	19 a9       	ld.ub	r9,r12[0x2]
80002514:	30 08       	mov	r8,0
80002516:	f0 09 18 00 	cp.b	r9,r8
8000251a:	c0 61       	brne	80002526 <AudioRoutingControl_reply_func+0x1a>
	{
		log("AudioRouting OK");
8000251c:	48 8c       	lddpc	r12,8000253c <AudioRoutingControl_reply_func+0x30>
8000251e:	f0 1f 00 09 	mcall	80002540 <AudioRoutingControl_reply_func+0x34>
80002522:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002526:	48 8c       	lddpc	r12,80002544 <AudioRoutingControl_reply_func+0x38>
80002528:	f0 1f 00 06 	mcall	80002540 <AudioRoutingControl_reply_func+0x34>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
8000252c:	0f a8       	ld.ub	r8,r7[0x2]
8000252e:	1a d8       	st.w	--sp,r8
80002530:	48 6c       	lddpc	r12,80002548 <AudioRoutingControl_reply_func+0x3c>
80002532:	f0 1f 00 04 	mcall	80002540 <AudioRoutingControl_reply_func+0x34>
80002536:	2f fd       	sub	sp,-4
80002538:	e3 cd 80 80 	ldm	sp++,r7,pc
8000253c:	80 01       	ld.sh	r1,r0[0x0]
8000253e:	06 ec       	st.h	--r3,r12
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	9e f8       	ld.uh	r8,pc[0xe]
80002544:	80 01       	ld.sh	r1,r0[0x0]
80002546:	06 fc       	st.b	--r3,r12
80002548:	80 01       	ld.sh	r1,r0[0x0]
8000254a:	07 10       	ld.sh	r0,r3++

8000254c <Volume_brdcst_func>:
	
	
}

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
8000254c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
80002550:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002554:	0f 89       	ld.ub	r9,r7[0x0]
80002556:	0f 98       	ld.ub	r8,r7[0x1]
80002558:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000255c:	1a d8       	st.w	--sp,r8
8000255e:	48 6c       	lddpc	r12,80002574 <Volume_brdcst_func+0x28>
80002560:	f0 1f 00 06 	mcall	80002578 <Volume_brdcst_func+0x2c>
	
	log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
80002564:	0f b8       	ld.ub	r8,r7[0x3]
80002566:	1a d8       	st.w	--sp,r8
80002568:	48 5c       	lddpc	r12,8000257c <Volume_brdcst_func+0x30>
8000256a:	f0 1f 00 04 	mcall	80002578 <Volume_brdcst_func+0x2c>
8000256e:	2f ed       	sub	sp,-8
	
	
}
80002570:	e3 cd 80 80 	ldm	sp++,r7,pc
80002574:	80 01       	ld.sh	r1,r0[0x0]
80002576:	07 30       	ld.ub	r0,r3++
80002578:	80 00       	ld.sh	r0,r0[0x0]
8000257a:	9e f8       	ld.uh	r8,pc[0xe]
8000257c:	80 01       	ld.sh	r1,r0[0x0]
8000257e:	07 4c       	ld.w	r12,--r3

80002580 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002580:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002584:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002588:	0f 89       	ld.ub	r9,r7[0x0]
8000258a:	30 08       	mov	r8,0
8000258c:	f0 09 18 00 	cp.b	r9,r8
80002590:	c1 b1       	brne	800025c6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002592:	0f b8       	ld.ub	r8,r7[0x3]
80002594:	31 09       	mov	r9,16
80002596:	f2 08 18 00 	cp.b	r8,r9
8000259a:	c0 f1       	brne	800025b8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000259c:	48 dc       	lddpc	r12,800025d0 <Volume_reply_func+0x50>
8000259e:	f0 1f 00 0e 	mcall	800025d4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025a2:	0f 99       	ld.ub	r9,r7[0x1]
800025a4:	0f a8       	ld.ub	r8,r7[0x2]
800025a6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025aa:	1a d8       	st.w	--sp,r8
800025ac:	48 bc       	lddpc	r12,800025d8 <Volume_reply_func+0x58>
800025ae:	f0 1f 00 0a 	mcall	800025d4 <Volume_reply_func+0x54>
800025b2:	2f fd       	sub	sp,-4
800025b4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025b8:	1a d8       	st.w	--sp,r8
800025ba:	48 9c       	lddpc	r12,800025dc <Volume_reply_func+0x5c>
800025bc:	f0 1f 00 06 	mcall	800025d4 <Volume_reply_func+0x54>
800025c0:	2f fd       	sub	sp,-4
800025c2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025c6:	48 7c       	lddpc	r12,800025e0 <Volume_reply_func+0x60>
800025c8:	f0 1f 00 03 	mcall	800025d4 <Volume_reply_func+0x54>
800025cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800025d0:	80 01       	ld.sh	r1,r0[0x0]
800025d2:	07 68       	ld.uh	r8,--r3
800025d4:	80 00       	ld.sh	r0,r0[0x0]
800025d6:	9e f8       	ld.uh	r8,pc[0xe]
800025d8:	80 01       	ld.sh	r1,r0[0x0]
800025da:	07 30       	ld.ub	r0,r3++
800025dc:	80 01       	ld.sh	r1,r0[0x0]
800025de:	07 7c       	ld.ub	r12,--r3
800025e0:	80 01       	ld.sh	r1,r0[0x0]
800025e2:	07 94       	ld.ub	r4,r3[0x1]

800025e4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025e6:	19 d9       	ld.ub	r9,r12[0x5]
800025e8:	30 08       	mov	r8,0
800025ea:	f0 09 18 00 	cp.b	r9,r8
800025ee:	c0 91       	brne	80002600 <spk_brdcst_func+0x1c>
	{
		is_unmute =0;
800025f0:	48 89       	lddpc	r9,80002610 <spk_brdcst_func+0x2c>
800025f2:	b2 88       	st.b	r9[0x0],r8
		Silent_flag = 0;
800025f4:	48 89       	lddpc	r9,80002614 <spk_brdcst_func+0x30>
800025f6:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_close ");
800025f8:	48 8c       	lddpc	r12,80002618 <spk_brdcst_func+0x34>
800025fa:	f0 1f 00 09 	mcall	8000261c <spk_brdcst_func+0x38>
800025fe:	d8 02       	popm	pc
		
		
	}
	else
	{
		Silent_flag = 1;
80002600:	30 19       	mov	r9,1
80002602:	48 58       	lddpc	r8,80002614 <spk_brdcst_func+0x30>
80002604:	b0 89       	st.b	r8[0x0],r9
		//is_unmute = 1;
		log("spk_s_open ");
80002606:	48 7c       	lddpc	r12,80002620 <spk_brdcst_func+0x3c>
80002608:	f0 1f 00 05 	mcall	8000261c <spk_brdcst_func+0x38>
8000260c:	d8 02       	popm	pc
8000260e:	00 00       	add	r0,r0
80002610:	00 00       	add	r0,r0
80002612:	0a 48       	or	r8,r5
80002614:	00 00       	add	r0,r0
80002616:	0a 50       	eor	r0,r5
80002618:	80 01       	ld.sh	r1,r0[0x0]
8000261a:	07 ac       	ld.ub	r12,r3[0x2]
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	9e f8       	ld.uh	r8,pc[0xe]
80002620:	80 01       	ld.sh	r1,r0[0x0]
80002622:	07 bc       	ld.ub	r12,r3[0x3]

80002624 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002624:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002626:	19 a9       	ld.ub	r9,r12[0x2]
80002628:	30 08       	mov	r8,0
8000262a:	f0 09 18 00 	cp.b	r9,r8
8000262e:	c0 f1       	brne	8000264c <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002630:	19 e9       	ld.ub	r9,r12[0x6]
80002632:	f0 09 18 00 	cp.b	r9,r8
80002636:	c0 40       	breq	8000263e <spk_reply_func+0x1a>
		{
			is_unmute = 1;
80002638:	30 19       	mov	r9,1
8000263a:	48 78       	lddpc	r8,80002654 <spk_reply_func+0x30>
8000263c:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000263e:	19 e8       	ld.ub	r8,r12[0x6]
80002640:	1a d8       	st.w	--sp,r8
80002642:	48 6c       	lddpc	r12,80002658 <spk_reply_func+0x34>
80002644:	f0 1f 00 06 	mcall	8000265c <spk_reply_func+0x38>
80002648:	2f fd       	sub	sp,-4
8000264a:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
8000264c:	48 5c       	lddpc	r12,80002660 <spk_reply_func+0x3c>
8000264e:	f0 1f 00 04 	mcall	8000265c <spk_reply_func+0x38>
80002652:	d8 02       	popm	pc
80002654:	00 00       	add	r0,r0
80002656:	0a 48       	or	r8,r5
80002658:	80 01       	ld.sh	r1,r0[0x0]
8000265a:	07 c8       	ld.ub	r8,r3[0x4]
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	9e f8       	ld.uh	r8,pc[0xe]
80002660:	80 01       	ld.sh	r1,r0[0x0]
80002662:	07 d8       	ld.ub	r8,r3[0x5]

80002664 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
8000266c:	49 ac       	lddpc	r12,800026d4 <mic_reply_func+0x70>
8000266e:	f0 1f 00 1b 	mcall	800026d8 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
80002672:	0f 89       	ld.ub	r9,r7[0x0]
80002674:	30 08       	mov	r8,0
80002676:	f0 09 18 00 	cp.b	r9,r8
8000267a:	c2 71       	brne	800026c8 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
8000267c:	0f 98       	ld.ub	r8,r7[0x1]
8000267e:	30 29       	mov	r9,2
80002680:	f2 08 18 00 	cp.b	r8,r9
80002684:	c1 b1       	brne	800026ba <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002686:	49 6c       	lddpc	r12,800026dc <mic_reply_func+0x78>
80002688:	f0 1f 00 14 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
8000268c:	0f a8       	ld.ub	r8,r7[0x2]
8000268e:	1a d8       	st.w	--sp,r8
80002690:	49 4c       	lddpc	r12,800026e0 <mic_reply_func+0x7c>
80002692:	f0 1f 00 12 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002696:	0f b8       	ld.ub	r8,r7[0x3]
80002698:	1a d8       	st.w	--sp,r8
8000269a:	49 3c       	lddpc	r12,800026e4 <mic_reply_func+0x80>
8000269c:	f0 1f 00 0f 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026a0:	0f c8       	ld.ub	r8,r7[0x4]
800026a2:	1a d8       	st.w	--sp,r8
800026a4:	49 1c       	lddpc	r12,800026e8 <mic_reply_func+0x84>
800026a6:	f0 1f 00 0d 	mcall	800026d8 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026aa:	0f d8       	ld.ub	r8,r7[0x5]
800026ac:	1a d8       	st.w	--sp,r8
800026ae:	49 0c       	lddpc	r12,800026ec <mic_reply_func+0x88>
800026b0:	f0 1f 00 0a 	mcall	800026d8 <mic_reply_func+0x74>
800026b4:	2f cd       	sub	sp,-16
800026b6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800026ba:	1a d8       	st.w	--sp,r8
800026bc:	48 dc       	lddpc	r12,800026f0 <mic_reply_func+0x8c>
800026be:	f0 1f 00 07 	mcall	800026d8 <mic_reply_func+0x74>
800026c2:	2f fd       	sub	sp,-4
800026c4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026c8:	48 bc       	lddpc	r12,800026f4 <mic_reply_func+0x90>
800026ca:	f0 1f 00 04 	mcall	800026d8 <mic_reply_func+0x74>
800026ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800026d2:	00 00       	add	r0,r0
800026d4:	80 01       	ld.sh	r1,r0[0x0]
800026d6:	07 e4       	ld.ub	r4,r3[0x6]
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	9e f8       	ld.uh	r8,pc[0xe]
800026dc:	80 01       	ld.sh	r1,r0[0x0]
800026de:	07 f4       	ld.ub	r4,r3[0x7]
800026e0:	80 01       	ld.sh	r1,r0[0x0]
800026e2:	08 08       	add	r8,r4
800026e4:	80 01       	ld.sh	r1,r0[0x0]
800026e6:	08 1c       	sub	r12,r4
800026e8:	80 01       	ld.sh	r1,r0[0x0]
800026ea:	08 38       	cp.w	r8,r4
800026ec:	80 01       	ld.sh	r1,r0[0x0]
800026ee:	08 50       	eor	r0,r4
800026f0:	80 01       	ld.sh	r1,r0[0x0]
800026f2:	08 68       	and	r8,r4
800026f4:	80 01       	ld.sh	r1,r0[0x0]
800026f6:	08 80       	andn	r0,r4

800026f8 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026f8:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026fc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002700:	48 bc       	lddpc	r12,8000272c <dcm_brdcst_func+0x34>
80002702:	f0 1f 00 0c 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002706:	0f 88       	ld.ub	r8,r7[0x0]
80002708:	1a d8       	st.w	--sp,r8
8000270a:	48 bc       	lddpc	r12,80002734 <dcm_brdcst_func+0x3c>
8000270c:	f0 1f 00 09 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002710:	0f a8       	ld.ub	r8,r7[0x2]
80002712:	1a d8       	st.w	--sp,r8
80002714:	48 9c       	lddpc	r12,80002738 <dcm_brdcst_func+0x40>
80002716:	f0 1f 00 07 	mcall	80002730 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000271a:	0f 98       	ld.ub	r8,r7[0x1]
8000271c:	1a d8       	st.w	--sp,r8
8000271e:	48 8c       	lddpc	r12,8000273c <dcm_brdcst_func+0x44>
80002720:	f0 1f 00 04 	mcall	80002730 <dcm_brdcst_func+0x38>
80002724:	2f dd       	sub	sp,-12
	
	
}
80002726:	e3 cd 80 80 	ldm	sp++,r7,pc
8000272a:	00 00       	add	r0,r0
8000272c:	80 01       	ld.sh	r1,r0[0x0]
8000272e:	08 90       	mov	r0,r4
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	9e f8       	ld.uh	r8,pc[0xe]
80002734:	80 01       	ld.sh	r1,r0[0x0]
80002736:	08 a4       	st.w	r4++,r4
80002738:	80 01       	ld.sh	r1,r0[0x0]
8000273a:	08 b8       	st.h	r4++,r8
8000273c:	80 01       	ld.sh	r1,r0[0x0]
8000273e:	08 d0       	st.w	--r4,r0

80002740 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002740:	eb cd 40 80 	pushm	r7,lr
80002744:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002746:	19 a9       	ld.ub	r9,r12[0x2]
80002748:	30 08       	mov	r8,0
8000274a:	f0 09 18 00 	cp.b	r9,r8
8000274e:	c1 b1       	brne	80002784 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002750:	19 b8       	ld.ub	r8,r12[0x3]
80002752:	30 19       	mov	r9,1
80002754:	f2 08 18 00 	cp.b	r8,r9
80002758:	c0 51       	brne	80002762 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000275a:	48 ec       	lddpc	r12,80002790 <dcm_reply_func+0x50>
8000275c:	f0 1f 00 0e 	mcall	80002794 <dcm_reply_func+0x54>
80002760:	c0 a8       	rjmp	80002774 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002762:	58 08       	cp.w	r8,0
80002764:	c0 51       	brne	8000276e <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
80002766:	48 dc       	lddpc	r12,80002798 <dcm_reply_func+0x58>
80002768:	f0 1f 00 0b 	mcall	80002794 <dcm_reply_func+0x54>
8000276c:	c0 48       	rjmp	80002774 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
8000276e:	48 cc       	lddpc	r12,8000279c <dcm_reply_func+0x5c>
80002770:	f0 1f 00 09 	mcall	80002794 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
80002774:	0f d8       	ld.ub	r8,r7[0x5]
80002776:	1a d8       	st.w	--sp,r8
80002778:	48 ac       	lddpc	r12,800027a0 <dcm_reply_func+0x60>
8000277a:	f0 1f 00 07 	mcall	80002794 <dcm_reply_func+0x54>
8000277e:	2f fd       	sub	sp,-4
80002780:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
80002784:	48 8c       	lddpc	r12,800027a4 <dcm_reply_func+0x64>
80002786:	f0 1f 00 04 	mcall	80002794 <dcm_reply_func+0x54>
8000278a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000278e:	00 00       	add	r0,r0
80002790:	80 01       	ld.sh	r1,r0[0x0]
80002792:	08 ec       	st.h	--r4,r12
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	9e f8       	ld.uh	r8,pc[0xe]
80002798:	80 01       	ld.sh	r1,r0[0x0]
8000279a:	09 00       	ld.w	r0,r4++
8000279c:	80 01       	ld.sh	r1,r0[0x0]
8000279e:	09 14       	ld.sh	r4,r4++
800027a0:	80 01       	ld.sh	r1,r0[0x0]
800027a2:	09 28       	ld.uh	r8,r4++
800027a4:	80 01       	ld.sh	r1,r0[0x0]
800027a6:	09 34       	ld.ub	r4,r4++

800027a8 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027a8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027aa:	19 a9       	ld.ub	r9,r12[0x2]
800027ac:	30 08       	mov	r8,0
800027ae:	f0 09 18 00 	cp.b	r9,r8
800027b2:	c0 51       	brne	800027bc <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027b4:	48 4c       	lddpc	r12,800027c4 <ToneControl_reply_func+0x1c>
800027b6:	f0 1f 00 05 	mcall	800027c8 <ToneControl_reply_func+0x20>
800027ba:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027bc:	48 4c       	lddpc	r12,800027cc <ToneControl_reply_func+0x24>
800027be:	f0 1f 00 03 	mcall	800027c8 <ToneControl_reply_func+0x20>
800027c2:	d8 02       	popm	pc
800027c4:	80 01       	ld.sh	r1,r0[0x0]
800027c6:	09 40       	ld.w	r0,--r4
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	9e f8       	ld.uh	r8,pc[0xe]
800027cc:	80 01       	ld.sh	r1,r0[0x0]
800027ce:	09 48       	ld.w	r8,--r4

800027d0 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
800027d0:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
800027d2:	f0 1f 00 22 	mcall	80002858 <app_cfg+0x88>
800027d6:	4a 28       	lddpc	r8,8000285c <app_cfg+0x8c>
800027d8:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027da:	4a 27       	lddpc	r7,80002860 <app_cfg+0x90>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027dc:	4a 26       	lddpc	r6,80002864 <app_cfg+0x94>
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
800027de:	4a 35       	lddpc	r5,80002868 <app_cfg+0x98>
800027e0:	4a 34       	lddpc	r4,8000286c <app_cfg+0x9c>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
800027e2:	4a 43       	lddpc	r3,80002870 <app_cfg+0xa0>
800027e4:	4a 42       	lddpc	r2,80002874 <app_cfg+0xa4>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800027e6:	30 41       	mov	r1,4
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800027e8:	30 20       	mov	r0,2
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		//if((++coun) % 200 ==0)
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800027ea:	6e 08       	ld.w	r8,r7[0x0]
800027ec:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f0:	58 38       	cp.w	r8,3
800027f2:	c2 d1       	brne	8000284c <app_cfg+0x7c>
				{
					//xcmp_transmit_dekeycontrol();
					
				}
				
				if(isAudioRouting == 0)
800027f4:	6c 08       	ld.w	r8,r6[0x0]
800027f6:	58 08       	cp.w	r8,0
800027f8:	c0 61       	brne	80002804 <app_cfg+0x34>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//3
800027fa:	f0 1f 00 20 	mcall	80002878 <app_cfg+0xa8>
					//xcmp_unmute_speaker();
					
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800027fe:	30 18       	mov	r8,1
80002800:	8d 08       	st.w	r6[0x0],r8
80002802:	c1 58       	rjmp	8000282c <app_cfg+0x5c>
				}
				else if(isAudioRouting == 1)
80002804:	58 18       	cp.w	r8,1
80002806:	c0 51       	brne	80002810 <app_cfg+0x40>
				{
					//xcmp_function_mic();
					//xcmp_data_session();
				   // xcmp_transmit_control();
					//xcmp_volume_control();
					xcmp_enter_enhanced_OB_mode();
80002808:	f0 1f 00 1d 	mcall	8000287c <app_cfg+0xac>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
8000280c:	8d 00       	st.w	r6[0x0],r0
8000280e:	c0 f8       	rjmp	8000282c <app_cfg+0x5c>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
80002810:	58 28       	cp.w	r8,2
80002812:	c0 61       	brne	8000281e <app_cfg+0x4e>
				{
					
					//xcmp_volume_control();
					//xcmp_data_session();
					xcmp_audio_route_AMBE();
80002814:	f0 1f 00 1b 	mcall	80002880 <app_cfg+0xb0>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002818:	30 38       	mov	r8,3
8000281a:	8d 08       	st.w	r6[0x0],r8
8000281c:	c0 88       	rjmp	8000282c <app_cfg+0x5c>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000281e:	58 38       	cp.w	r8,3
80002820:	ed f1 0a 00 	st.weq	r6[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
80002824:	f7 b8 01 ff 	subne	r8,-1
80002828:	ed f8 1a 00 	st.wne	r6[0x0],r8
						//
						//
					//}
				//
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				log("\n\r un: %d \n\r", is_unmute);
8000282c:	09 88       	ld.ub	r8,r4[0x0]
8000282e:	1a d8       	st.w	--sp,r8
80002830:	0a 9c       	mov	r12,r5
80002832:	f0 1f 00 15 	mcall	80002884 <app_cfg+0xb4>
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
			
				log("\n\r AMBE_flag: %d \n\r", AMBE_flag);
80002836:	05 88       	ld.ub	r8,r2[0x0]
80002838:	1a d8       	st.w	--sp,r8
8000283a:	06 9c       	mov	r12,r3
8000283c:	f0 1f 00 12 	mcall	80002884 <app_cfg+0xb4>
				//log("\n\r VF_SN: %x \n\r",  VF_SN);
				//log("\n\r time: %d \n\r", tc_tick);
				
				if(isAudioRouting  == 6)
80002840:	2f ed       	sub	sp,-8
80002842:	6c 08       	ld.w	r8,r6[0x0]
80002844:	58 68       	cp.w	r8,6
80002846:	c0 31       	brne	8000284c <app_cfg+0x7c>
					
					//xcmp_audio_route_speaker();
					//xcmp_enter_device_control_mode();//3
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					xcmp_exit_device_control_mode();
80002848:	f0 1f 00 10 	mcall	80002888 <app_cfg+0xb8>
			//log("testtime:%d", now->second);
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//2000ms
8000284c:	e0 6b 0f a0 	mov	r11,4000
80002850:	48 3c       	lddpc	r12,8000285c <app_cfg+0x8c>
80002852:	f0 1f 00 0f 	mcall	8000288c <app_cfg+0xbc>
	}
80002856:	cc ab       	rjmp	800027ea <app_cfg+0x1a>
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	98 6c       	ld.sh	r12,r12[0xc]
8000285c:	00 00       	add	r0,r0
8000285e:	0a 4c       	or	r12,r5
80002860:	00 00       	add	r0,r0
80002862:	13 54       	ld.sh	r4,--r9
80002864:	00 00       	add	r0,r0
80002866:	0a 44       	or	r4,r5
80002868:	80 01       	ld.sh	r1,r0[0x0]
8000286a:	09 54       	ld.sh	r4,--r4
8000286c:	00 00       	add	r0,r0
8000286e:	0a 48       	or	r8,r5
80002870:	80 01       	ld.sh	r1,r0[0x0]
80002872:	09 64       	ld.uh	r4,--r4
80002874:	00 00       	add	r0,r0
80002876:	0a 42       	or	r2,r5
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	51 18       	stdsp	sp[0x44],r8
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	51 90       	stdsp	sp[0x64],r0
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	51 44       	stdsp	sp[0x50],r4
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	9e f8       	ld.uh	r8,pc[0xe]
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	50 e8       	stdsp	sp[0x38],r8
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	99 d4       	st.w	r12[0x34],r4

80002890 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002890:	eb cd 40 80 	pushm	r7,lr
80002894:	18 97       	mov	r7,r12
  log("R");
80002896:	49 0c       	lddpc	r12,800028d4 <app_payload_tx_proc+0x44>
80002898:	f0 1f 00 10 	mcall	800028d8 <app_payload_tx_proc+0x48>
  
  if (AMBE_flag)
8000289c:	49 08       	lddpc	r8,800028dc <app_payload_tx_proc+0x4c>
8000289e:	11 89       	ld.ub	r9,r8[0x0]
800028a0:	30 08       	mov	r8,0
800028a2:	f0 09 18 00 	cp.b	r9,r8
800028a6:	c0 90       	breq	800028b8 <app_payload_tx_proc+0x28>
  {
	  fl_read("AMBEvo.bit", FILE_BEGIN, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
800028a8:	e0 69 02 00 	mov	r9,512
800028ac:	0e 9a       	mov	r10,r7
800028ae:	30 0b       	mov	r11,0
800028b0:	48 cc       	lddpc	r12,800028e0 <app_payload_tx_proc+0x50>
800028b2:	f0 1f 00 0d 	mcall	800028e4 <app_payload_tx_proc+0x54>
800028b6:	c0 88       	rjmp	800028c6 <app_payload_tx_proc+0x36>
  }
  else
  {
	  fl_read("PCMvo.pcm", FILE_BEGIN, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
800028b8:	e0 69 02 00 	mov	r9,512
800028bc:	0e 9a       	mov	r10,r7
800028be:	30 0b       	mov	r11,0
800028c0:	48 ac       	lddpc	r12,800028e8 <app_payload_tx_proc+0x58>
800028c2:	f0 1f 00 09 	mcall	800028e4 <app_payload_tx_proc+0x54>
  }
  
  
  set_payload_idle(payload);
800028c6:	48 a8       	lddpc	r8,800028ec <app_payload_tx_proc+0x5c>
800028c8:	70 0c       	ld.w	r12,r8[0x0]
800028ca:	0e 9b       	mov	r11,r7
800028cc:	f0 1f 00 09 	mcall	800028f0 <app_payload_tx_proc+0x60>


}
800028d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800028d4:	80 01       	ld.sh	r1,r0[0x0]
800028d6:	09 78       	ld.ub	r8,--r4
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	9e f8       	ld.uh	r8,pc[0xe]
800028dc:	00 00       	add	r0,r0
800028de:	0a 42       	or	r2,r5
800028e0:	80 01       	ld.sh	r1,r0[0x0]
800028e2:	09 7c       	ld.ub	r12,--r4
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	35 74       	mov	r4,87
800028e8:	80 01       	ld.sh	r1,r0[0x0]
800028ea:	09 88       	ld.ub	r8,r4[0x0]
800028ec:	00 00       	add	r0,r0
800028ee:	10 04       	add	r4,r8
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	3d 2c       	mov	r12,-46

800028f4 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800028f4:	eb cd 40 80 	pushm	r7,lr
800028f8:	18 97       	mov	r7,r12
	log("\n\r w: \n\r");
800028fa:	49 0c       	lddpc	r12,80002938 <app_payload_rx_proc+0x44>
800028fc:	f0 1f 00 10 	mcall	8000293c <app_payload_rx_proc+0x48>
	if (AMBE_flag)
80002900:	49 08       	lddpc	r8,80002940 <app_payload_rx_proc+0x4c>
80002902:	11 89       	ld.ub	r9,r8[0x0]
80002904:	30 08       	mov	r8,0
80002906:	f0 09 18 00 	cp.b	r9,r8
8000290a:	c0 90       	breq	8000291c <app_payload_rx_proc+0x28>
	{
		fl_write("AMBEvo.bit", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
8000290c:	e0 69 02 00 	mov	r9,512
80002910:	0e 9a       	mov	r10,r7
80002912:	3f fb       	mov	r11,-1
80002914:	48 cc       	lddpc	r12,80002944 <app_payload_rx_proc+0x50>
80002916:	f0 1f 00 0d 	mcall	80002948 <app_payload_rx_proc+0x54>
8000291a:	c0 88       	rjmp	8000292a <app_payload_rx_proc+0x36>
	}
	else
	{
		fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
8000291c:	e0 69 02 00 	mov	r9,512
80002920:	0e 9a       	mov	r10,r7
80002922:	3f fb       	mov	r11,-1
80002924:	48 ac       	lddpc	r12,8000294c <app_payload_rx_proc+0x58>
80002926:	f0 1f 00 09 	mcall	80002948 <app_payload_rx_proc+0x54>
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000292a:	48 a8       	lddpc	r8,80002950 <app_payload_rx_proc+0x5c>
8000292c:	70 0c       	ld.w	r12,r8[0x0]
8000292e:	0e 9b       	mov	r11,r7
80002930:	f0 1f 00 09 	mcall	80002954 <app_payload_rx_proc+0x60>

}
80002934:	e3 cd 80 80 	ldm	sp++,r7,pc
80002938:	80 01       	ld.sh	r1,r0[0x0]
8000293a:	09 94       	ld.ub	r4,r4[0x1]
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	9e f8       	ld.uh	r8,pc[0xe]
80002940:	00 00       	add	r0,r0
80002942:	0a 42       	or	r2,r5
80002944:	80 01       	ld.sh	r1,r0[0x0]
80002946:	09 7c       	ld.ub	r12,--r4
80002948:	80 00       	ld.sh	r0,r0[0x0]
8000294a:	35 fc       	mov	r12,95
8000294c:	80 01       	ld.sh	r1,r0[0x0]
8000294e:	09 88       	ld.ub	r8,r4[0x0]
80002950:	00 00       	add	r0,r0
80002952:	10 04       	add	r4,r8
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	3d 2c       	mov	r12,-46

80002958 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002958:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
8000295a:	19 e8       	ld.ub	r8,r12[0x6]
8000295c:	30 19       	mov	r9,1
8000295e:	f2 08 18 00 	cp.b	r8,r9
80002962:	c0 61       	brne	8000296e <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002964:	48 98       	lddpc	r8,80002988 <DeviceInitializationStatus_brdcst_func+0x30>
80002966:	70 09       	ld.w	r9,r8[0x0]
80002968:	a1 a9       	sbr	r9,0x0
8000296a:	91 09       	st.w	r8[0x0],r9
8000296c:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
8000296e:	30 29       	mov	r9,2
80002970:	f2 08 18 00 	cp.b	r8,r9
80002974:	c0 80       	breq	80002984 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002976:	48 58       	lddpc	r8,80002988 <DeviceInitializationStatus_brdcst_func+0x30>
80002978:	70 09       	ld.w	r9,r8[0x0]
8000297a:	e0 19 ff fc 	andl	r9,0xfffc
8000297e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002980:	f0 1f 00 03 	mcall	8000298c <DeviceInitializationStatus_brdcst_func+0x34>
80002984:	d8 02       	popm	pc
80002986:	00 00       	add	r0,r0
80002988:	00 00       	add	r0,r0
8000298a:	13 54       	ld.sh	r4,--r9
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	51 b4       	stdsp	sp[0x6c],r4

80002990 <SD_SPI_SetSpeed>:
	
}


void SD_SPI_SetSpeed(uint16_t SPI_BaudRatePrescaler)
{
80002990:	d4 01       	pushm	lr
 

	spi->csr0 = (spi->csr0 & (uint16_t)0x00FF) |SPI_BaudRatePrescaler;
80002992:	48 78       	lddpc	r8,800029ac <SD_SPI_SetSpeed+0x1c>
80002994:	70 09       	ld.w	r9,r8[0x0]
80002996:	72 ca       	ld.w	r10,r9[0x30]
80002998:	5c 7c       	castu.h	r12
8000299a:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
8000299e:	f9 ea 10 0a 	or	r10,r12,r10
800029a2:	93 ca       	st.w	r9[0x30],r10


 
    spi_enable(spi); /*!< SD_SPI enable */
800029a4:	70 0c       	ld.w	r12,r8[0x0]
800029a6:	f0 1f 00 03 	mcall	800029b0 <SD_SPI_SetSpeed+0x20>
	
 
}
800029aa:	d8 02       	popm	pc
800029ac:	00 00       	add	r0,r0
800029ae:	13 58       	ld.sh	r8,--r9
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	5f 18       	srne	r8

800029b4 <SD_SPI_SetSpeedHi>:

	
}

void SD_SPI_SetSpeedHi(void)
{
800029b4:	d4 01       	pushm	lr

	SD_SPI_SetSpeed(0x0100);//baudDiv=1
800029b6:	e0 6c 01 00 	mov	r12,256
800029ba:	f0 1f 00 02 	mcall	800029c0 <SD_SPI_SetSpeedHi+0xc>

}
800029be:	d8 02       	popm	pc
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	29 90       	sub	r0,-103

800029c4 <SD_SPI_SetSpeedLow>:
	
 
}

void SD_SPI_SetSpeedLow(void)
{
800029c4:	d4 01       	pushm	lr


	SD_SPI_SetSpeed(0xFF00);//baudDiv=255
800029c6:	e0 6c ff 00 	mov	r12,65280
800029ca:	f0 1f 00 02 	mcall	800029d0 <SD_SPI_SetSpeedLow+0xc>


	
}
800029ce:	d8 02       	popm	pc
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	29 90       	sub	r0,-103

800029d4 <SD_LowLevel_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
void SD_LowLevel_Init(void)
{
800029d4:	eb cd 40 c0 	pushm	r6-r7,lr
800029d8:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
800029da:	49 58       	lddpc	r8,80002a2c <SD_LowLevel_Init+0x58>
800029dc:	1a 96       	mov	r6,sp
800029de:	f0 ea 00 00 	ld.d	r10,r8[0]
800029e2:	fa eb 00 00 	st.d	sp[0],r10
800029e6:	f0 e8 00 08 	ld.d	r8,r8[8]
800029ea:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_SPI_GPIO_MAP, sizeof(SD_SPI_GPIO_MAP) / sizeof(SD_SPI_GPIO_MAP[0]));
800029ee:	30 4b       	mov	r11,4
800029f0:	49 0c       	lddpc	r12,80002a30 <SD_LowLevel_Init+0x5c>
800029f2:	f0 1f 00 11 	mcall	80002a34 <SD_LowLevel_Init+0x60>

	spi = &AVR32_SPI;
800029f6:	49 17       	lddpc	r7,80002a38 <SD_LowLevel_Init+0x64>
800029f8:	fe 7c 24 00 	mov	r12,-56320
800029fc:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
800029fe:	1a 9b       	mov	r11,sp
80002a00:	f0 1f 00 0f 	mcall	80002a3c <SD_LowLevel_Init+0x68>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002a04:	30 09       	mov	r9,0
80002a06:	12 9a       	mov	r10,r9
80002a08:	12 9b       	mov	r11,r9
80002a0a:	6e 0c       	ld.w	r12,r7[0x0]
80002a0c:	f0 1f 00 0d 	mcall	80002a40 <SD_LowLevel_Init+0x6c>

	// Enable SPI.
	spi_enable(spi);
80002a10:	6e 0c       	ld.w	r12,r7[0x0]
80002a12:	f0 1f 00 0d 	mcall	80002a44 <SD_LowLevel_Init+0x70>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, SPI_Clock_PBA) != SPI_OK)
80002a16:	e0 6a 36 00 	mov	r10,13824
80002a1a:	ea 1a 01 6e 	orh	r10,0x16e
80002a1e:	1a 9b       	mov	r11,sp
80002a20:	6e 0c       	ld.w	r12,r7[0x0]
80002a22:	f0 1f 00 0a 	mcall	80002a48 <SD_LowLevel_Init+0x74>
	return;
	}


	
}
80002a26:	2f cd       	sub	sp,-16
80002a28:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a2c:	80 01       	ld.sh	r1,r0[0x0]
80002a2e:	09 b4       	ld.ub	r4,r4[0x3]
80002a30:	80 01       	ld.sh	r1,r0[0x0]
80002a32:	09 c4       	ld.ub	r4,r4[0x4]
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	a3 98       	lsr	r8,0x3
80002a38:	00 00       	add	r0,r0
80002a3a:	13 58       	ld.sh	r8,--r9
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	5d 80       	*unknown*
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	5d b8       	*unknown*
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	5f 18       	srne	r8
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	5e 56       	retlt	r6

80002a4c <SD_ReadByte>:
  * @   SD
  * @    
  * @  The received byte
***------------------------------------------------------*/  
uint8_t SD_ReadByte(void)
{
80002a4c:	eb cd 40 c0 	pushm	r6-r7,lr
  unsigned short *Data ;

  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002a50:	48 b7       	lddpc	r7,80002a7c <SD_ReadByte+0x30>
80002a52:	30 0b       	mov	r11,0
80002a54:	6e 0c       	ld.w	r12,r7[0x0]
80002a56:	f0 1f 00 0b 	mcall	80002a80 <SD_ReadByte+0x34>
  
  /*!< Send the byte */

  spi_write(spi,  SD_DUMMY_BYTE);
80002a5a:	e0 6b 00 ff 	mov	r11,255
80002a5e:	6e 0c       	ld.w	r12,r7[0x0]
80002a60:	f0 1f 00 09 	mcall	80002a84 <SD_ReadByte+0x38>
  
  /*!< Return the byte read from the SPI bus */ 

   spi_read(spi, Data);
80002a64:	30 06       	mov	r6,0
80002a66:	0c 9b       	mov	r11,r6
80002a68:	6e 0c       	ld.w	r12,r7[0x0]
80002a6a:	f0 1f 00 08 	mcall	80002a88 <SD_ReadByte+0x3c>

  /*!< Return the shifted data */
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002a6e:	0c 9b       	mov	r11,r6
80002a70:	6e 0c       	ld.w	r12,r7[0x0]
80002a72:	f0 1f 00 07 	mcall	80002a8c <SD_ReadByte+0x40>
  
  return (uint8_t)(*Data);//
}
80002a76:	0d 9c       	ld.ub	r12,r6[0x1]
80002a78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a7c:	00 00       	add	r0,r0
80002a7e:	13 58       	ld.sh	r8,--r9
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	5d e4       	*unknown*
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	5f 1e       	srne	lr
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	5f 3a       	srlo	r10
80002a8c:	80 00       	ld.sh	r0,r0[0x0]
80002a8e:	5e 30       	retlo	r0

80002a90 <SD_GetResponse>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetResponse(uint8_t Response)
{
80002a90:	eb cd 40 c0 	pushm	r6-r7,lr
80002a94:	18 96       	mov	r6,r12
80002a96:	e0 67 8f ff 	mov	r7,36863
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a9a:	c0 28       	rjmp	80002a9e <SD_GetResponse+0xe>
  {
    Count--;
80002a9c:	20 17       	sub	r7,1
SD_Error SD_GetResponse(uint8_t Response)
{
  uint32_t Count = 0x8FFF;

  /*!< Check if response is got or a timeout is happen */
  while ((SD_ReadByte() != Response) && Count)
80002a9e:	f0 1f 00 09 	mcall	80002ac0 <SD_GetResponse+0x30>
80002aa2:	ec 0c 18 00 	cp.b	r12,r6
80002aa6:	c0 40       	breq	80002aae <SD_GetResponse+0x1e>
80002aa8:	58 07       	cp.w	r7,0
80002aaa:	cf 91       	brne	80002a9c <SD_GetResponse+0xc>
80002aac:	c0 58       	rjmp	80002ab6 <SD_GetResponse+0x26>
  {
    Count--;
  }
  if (Count == 0)
80002aae:	58 07       	cp.w	r7,0
80002ab0:	c0 30       	breq	80002ab6 <SD_GetResponse+0x26>
80002ab2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80002ab6:	e0 6c 00 ff 	mov	r12,255
  else
  {
    /*!< Right response got */
    return SD_RESPONSE_NO_ERROR;
  }
}
80002aba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002abe:	00 00       	add	r0,r0
80002ac0:	80 00       	ld.sh	r0,r0[0x0]
80002ac2:	2a 4c       	sub	r12,-92

80002ac4 <SD_GetDataResponse>:
  *         - status 101: Data rejected due to a crc error
  *         - status 110: Data rejected due to a Write error.
  *         - status 111: Data rejected due to other error.
  */
uint8_t SD_GetDataResponse(void)
{
80002ac4:	eb cd 40 f8 	pushm	r3-r7,lr
80002ac8:	30 06       	mov	r6,0
  {
    /*!< Read resonse */
    response = SD_ReadByte();
    /*!< Mask unused bits */
    response &= 0x1F;
    switch (response)
80002aca:	30 b5       	mov	r5,11
80002acc:	30 d4       	mov	r4,13
80002ace:	30 53       	mov	r3,5
  uint8_t response, rvalue;

  while (i <= 64)
  {
    /*!< Read resonse */
    response = SD_ReadByte();
80002ad0:	f0 1f 00 0c 	mcall	80002b00 <SD_GetDataResponse+0x3c>
    /*!< Mask unused bits */
    response &= 0x1F;
80002ad4:	ef dc c0 05 	bfextu	r7,r12,0x0,0x5
    switch (response)
80002ad8:	ea 07 18 00 	cp.b	r7,r5
80002adc:	c0 e0       	breq	80002af8 <SD_GetDataResponse+0x34>
80002ade:	e8 07 18 00 	cp.b	r7,r4
80002ae2:	c0 b0       	breq	80002af8 <SD_GetDataResponse+0x34>
80002ae4:	e6 07 18 00 	cp.b	r7,r3
80002ae8:	c0 50       	breq	80002af2 <SD_GetDataResponse+0x2e>
    }
    /*!< Exit loop in case of data ok */
    if (rvalue == SD_DATA_OK)
      break;
    /*!< Increment loop counter */
    i++;
80002aea:	2f f6       	sub	r6,-1
uint8_t SD_GetDataResponse(void)
{
  uint32_t i = 0;
  uint8_t response, rvalue;

  while (i <= 64)
80002aec:	e0 46 00 41 	cp.w	r6,65
80002af0:	cf 01       	brne	80002ad0 <SD_GetDataResponse+0xc>
    /*!< Increment loop counter */
    i++;
  }

  /*!< Wait null data */
  while (SD_ReadByte() == 0);
80002af2:	f0 1f 00 04 	mcall	80002b00 <SD_GetDataResponse+0x3c>
80002af6:	cf e0       	breq	80002af2 <SD_GetDataResponse+0x2e>

  /*!< Return response */
  return response;
}
80002af8:	0e 9c       	mov	r12,r7
80002afa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002afe:	00 00       	add	r0,r0
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	2a 4c       	sub	r12,-92

80002b04 <SD_WriteByte>:
  * @brief  Write a byte on the SD.
  * @param  Data: byte to send.
  * @retval None
  */
uint8_t SD_WriteByte(uint8_t Data)
{
80002b04:	eb cd 40 c0 	pushm	r6-r7,lr
80002b08:	20 1d       	sub	sp,4
80002b0a:	ba 8c       	st.b	sp[0x0],r12
  uint8_t temp;
  
  //
  spi_selectChip(spi, SD_SPI_PCS_0);
80002b0c:	48 c7       	lddpc	r7,80002b3c <SD_WriteByte+0x38>
80002b0e:	30 0b       	mov	r11,0
80002b10:	6e 0c       	ld.w	r12,r7[0x0]
80002b12:	f0 1f 00 0c 	mcall	80002b40 <SD_WriteByte+0x3c>
  
  /*!< Send the byte */
  spi_write(spi,  (U16)Data);
80002b16:	1b 8b       	ld.ub	r11,sp[0x0]
80002b18:	6e 0c       	ld.w	r12,r7[0x0]
80002b1a:	f0 1f 00 0b 	mcall	80002b44 <SD_WriteByte+0x40>
  

  /*!< Wait to receive a byte*/

  temp = spi_read(spi, (U16*)&Data);
80002b1e:	1a 9b       	mov	r11,sp
80002b20:	6e 0c       	ld.w	r12,r7[0x0]
80002b22:	f0 1f 00 0a 	mcall	80002b48 <SD_WriteByte+0x44>
80002b26:	18 96       	mov	r6,r12
  
  spi_unselectChip(spi, SD_SPI_PCS_0);
80002b28:	30 0b       	mov	r11,0
80002b2a:	6e 0c       	ld.w	r12,r7[0x0]
80002b2c:	f0 1f 00 08 	mcall	80002b4c <SD_WriteByte+0x48>
  
  /*!< Return the byte read from the SPI bus */ 
  return  temp;
    
}
80002b30:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80002b34:	2f fd       	sub	sp,-4
80002b36:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b3a:	00 00       	add	r0,r0
80002b3c:	00 00       	add	r0,r0
80002b3e:	13 58       	ld.sh	r8,--r9
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	5d e4       	*unknown*
80002b44:	80 00       	ld.sh	r0,r0[0x0]
80002b46:	5f 1e       	srne	lr
80002b48:	80 00       	ld.sh	r0,r0[0x0]
80002b4a:	5f 3a       	srlo	r10
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	5e 30       	retlo	r0

80002b50 <SD_SendCmd>:
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
{
80002b50:	eb cd 40 c0 	pushm	r6-r7,lr
80002b54:	20 2d       	sub	sp,8
  uint32_t i = 0x00;
  
  uint8_t Frame[6];

  Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
80002b56:	a7 ac       	sbr	r12,0x6
80002b58:	ba 8c       	st.b	sp[0x0],r12
  
  Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
80002b5a:	f6 08 16 18 	lsr	r8,r11,0x18
80002b5e:	ba 98       	st.b	sp[0x1],r8
  
  Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
80002b60:	f6 08 16 10 	lsr	r8,r11,0x10
80002b64:	ba a8       	st.b	sp[0x2],r8
  
  Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
80002b66:	f6 08 16 08 	lsr	r8,r11,0x8
80002b6a:	ba b8       	st.b	sp[0x3],r8
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
80002b6c:	ba cb       	st.b	sp[0x4],r11
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
80002b6e:	ba da       	st.b	sp[0x5],r10
80002b70:	1a 97       	mov	r7,sp
  * @param  Cmd: .
  * @param  Arg: 
  * @param  Crc: CRC
  * @retval None
  */
void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
80002b72:	fa c6 ff fa 	sub	r6,sp,-6
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
80002b76:	0f 3c       	ld.ub	r12,r7++
80002b78:	f0 1f 00 04 	mcall	80002b88 <SD_SendCmd+0x38>
  
  Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
  
  Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
  
  for (i = 0; i < 6; i++)
80002b7c:	0c 37       	cp.w	r7,r6
80002b7e:	cf c1       	brne	80002b76 <SD_SendCmd+0x26>
  {

	SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */

  }
}
80002b80:	2f ed       	sub	sp,-8
80002b82:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b86:	00 00       	add	r0,r0
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	2b 04       	sub	r4,-80

80002b8c <SD_GoIdleState>:
  * @   SD
  * @    
  * @  
***------------------------------------------------------*/
SD_Error SD_GoIdleState(void)
{
80002b8c:	d4 31       	pushm	r0-r7,lr
  uint8_t r1;
  SD_Error Status = SD_RESPONSE_NO_ERROR;
  uint16_t n2,n;

  /* CS */
  SD_CS_LOW();
80002b8e:	31 8c       	mov	r12,24
80002b90:	f0 1f 00 6a 	mcall	80002d38 <SD_GoIdleState+0x1ac>
  
  /* CM0SDSPI */
  SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
80002b94:	e0 6a 00 95 	mov	r10,149
80002b98:	30 0b       	mov	r11,0
80002b9a:	16 9c       	mov	r12,r11
80002b9c:	f0 1f 00 68 	mcall	80002d3c <SD_GoIdleState+0x1b0>
  
  /* 0x01 */
  if (SD_GetResponse  (SD_IN_IDLE_STATE))
80002ba0:	30 1c       	mov	r12,1
80002ba2:	f0 1f 00 68 	mcall	80002d40 <SD_GoIdleState+0x1b4>
80002ba6:	e0 81 00 a8 	brne	80002cf6 <SD_GoIdleState+0x16a>
    return SD_RESPONSE_FAILURE;
  }

  
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);
80002baa:	e0 6a 00 87 	mov	r10,135
80002bae:	e0 6b 01 aa 	mov	r11,426
80002bb2:	30 8c       	mov	r12,8
80002bb4:	f0 1f 00 62 	mcall	80002d3c <SD_GoIdleState+0x1b0>
80002bb8:	e0 67 00 c8 	mov	r7,200

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002bbc:	3f f6       	mov	r6,-1
80002bbe:	c0 38       	rjmp	80002bc4 <SD_GoIdleState+0x38>
  {
    TimeOut--;
80002bc0:	20 17       	sub	r7,1
80002bc2:	5c 87       	casts.h	r7
  /*CMD8*/
  SD_SendCmd(8, 0x1AA, 0x87);

  /*  */
  TimeOut = 200;
  while (((r1 = SD_ReadByte()) == 0xFF) && TimeOut)
80002bc4:	f0 1f 00 60 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002bc8:	ec 0c 18 00 	cp.b	r12,r6
80002bcc:	c0 41       	brne	80002bd4 <SD_GoIdleState+0x48>
80002bce:	58 07       	cp.w	r7,0
80002bd0:	cf 81       	brne	80002bc0 <SD_GoIdleState+0x34>
80002bd2:	c2 68       	rjmp	80002c1e <SD_GoIdleState+0x92>
  {
    TimeOut--;
  }

  if(r1 == 0x05) 
80002bd4:	30 58       	mov	r8,5
80002bd6:	f0 0c 18 00 	cp.b	r12,r8
80002bda:	c2 21       	brne	80002c1e <SD_GoIdleState+0x92>
80002bdc:	c9 48       	rjmp	80002d04 <SD_GoIdleState+0x178>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002bde:	08 9c       	mov	r12,r4
80002be0:	f0 1f 00 5a 	mcall	80002d48 <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002be4:	06 9c       	mov	r12,r3
80002be6:	f0 1f 00 5a 	mcall	80002d4c <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002bea:	08 9c       	mov	r12,r4
80002bec:	f0 1f 00 53 	mcall	80002d38 <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002bf0:	06 9a       	mov	r10,r3
80002bf2:	0a 9b       	mov	r11,r5
80002bf4:	02 9c       	mov	r12,r1
80002bf6:	f0 1f 00 52 	mcall	80002d3c <SD_GoIdleState+0x1b0>
      /* error Response0x00 */
      TimeOut++;
80002bfa:	2f f6       	sub	r6,-1
80002bfc:	5c 86       	casts.h	r6
    
      if(TimeOut == 0x00F0)
80002bfe:	e4 06 19 00 	cp.h	r6,r2
80002c02:	c0 60       	breq	80002c0e <SD_GoIdleState+0x82>
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002c04:	0a 9c       	mov	r12,r5
80002c06:	f0 1f 00 4f 	mcall	80002d40 <SD_GoIdleState+0x1b4>
80002c0a:	18 97       	mov	r7,r12
    }
    while (Status);
80002c0c:	ce 91       	brne	80002bde <SD_GoIdleState+0x52>
    
    /* CS */
    SD_CS_HIGH();
80002c0e:	31 8c       	mov	r12,24
80002c10:	f0 1f 00 4e 	mcall	80002d48 <SD_GoIdleState+0x1bc>
    
    /*dummy byte 0xFF */
    SD_WriteByte(SD_DUMMY_BYTE);    
80002c14:	e0 6c 00 ff 	mov	r12,255
80002c18:	f0 1f 00 4d 	mcall	80002d4c <SD_GoIdleState+0x1c0>
80002c1c:	c6 f8       	rjmp	80002cfa <SD_GoIdleState+0x16e>
    r1 = 1;

    /* SD5 */
    for(n=0; n<5; n++)
    {
      SD_ReadByte();
80002c1e:	f0 1f 00 4a 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002c22:	f0 1f 00 49 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002c26:	f0 1f 00 48 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002c2a:	f0 1f 00 47 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002c2e:	f0 1f 00 46 	mcall	80002d44 <SD_GoIdleState+0x1b8>
    }
  
    /* CS */
    SD_CS_HIGH();
80002c32:	31 8c       	mov	r12,24
80002c34:	f0 1f 00 45 	mcall	80002d48 <SD_GoIdleState+0x1bc>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c38:	e0 6c 00 ff 	mov	r12,255
80002c3c:	f0 1f 00 44 	mcall	80002d4c <SD_GoIdleState+0x1c0>
    /* CS */
    SD_CS_LOW();
80002c40:	31 8c       	mov	r12,24
80002c42:	f0 1f 00 3e 	mcall	80002d38 <SD_GoIdleState+0x1ac>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c46:	e0 6c 00 ff 	mov	r12,255
80002c4a:	f0 1f 00 41 	mcall	80002d4c <SD_GoIdleState+0x1c0>
    SD_WriteByte(SD_DUMMY_BYTE);
80002c4e:	e0 6c 00 ff 	mov	r12,255
80002c52:	f0 1f 00 3f 	mcall	80002d4c <SD_GoIdleState+0x1c0>
80002c56:	e0 64 00 ff 	mov	r4,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002c5a:	08 91       	mov	r1,r4
80002c5c:	30 02       	mov	r2,0
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
       if(r1 !=1)
80002c5e:	30 15       	mov	r5,1
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c60:	30 83       	mov	r3,8

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002c62:	e0 66 00 ff 	mov	r6,255
    n=0xff;
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
80002c66:	02 9a       	mov	r10,r1
80002c68:	04 9b       	mov	r11,r2
80002c6a:	33 7c       	mov	r12,55
80002c6c:	f0 1f 00 34 	mcall	80002d3c <SD_GoIdleState+0x1b0>
80002c70:	04 97       	mov	r7,r2
      for(n2=0; n2<0x08;n2++)
      {
       r1= SD_ReadByte();
80002c72:	f0 1f 00 35 	mcall	80002d44 <SD_GoIdleState+0x1b8>
       if(r1 !=1)
80002c76:	f8 05 18 00 	cp.b	r5,r12
80002c7a:	f9 b4 01 00 	movne	r4,0
  
    do
    {
	  /* CMD55 */
      SD_SendCmd(55, 0, 0xFF);
      for(n2=0; n2<0x08;n2++)
80002c7e:	2f f7       	sub	r7,-1
80002c80:	5c 87       	casts.h	r7
80002c82:	e6 07 19 00 	cp.h	r7,r3
80002c86:	cf 61       	brne	80002c72 <SD_GoIdleState+0xe6>
80002c88:	08 90       	mov	r0,r4
80002c8a:	5c 80       	casts.h	r0
		   n=0;
	   }

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
80002c8c:	04 9a       	mov	r10,r2
80002c8e:	fc 1b 40 00 	movh	r11,0x4000
80002c92:	32 9c       	mov	r12,41
80002c94:	f0 1f 00 2a 	mcall	80002d3c <SD_GoIdleState+0x1b0>
80002c98:	04 97       	mov	r7,r2
  
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
80002c9a:	f0 1f 00 2b 	mcall	80002d44 <SD_GoIdleState+0x1b8>
       if(r1 ==0)break;
80002c9e:	c3 00       	breq	80002cfe <SD_GoIdleState+0x172>

      }
	   /* CMD41 */
      SD_SendCmd(41, 0x40000000, 0);
  
      for(n2=0; n2<0xff;n2++)
80002ca0:	2f f7       	sub	r7,-1
80002ca2:	5c 87       	casts.h	r7
80002ca4:	ec 07 19 00 	cp.h	r7,r6
80002ca8:	cf 91       	brne	80002c9a <SD_GoIdleState+0x10e>
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002caa:	e0 c4 00 01 	sub	r4,r0,1
80002cae:	5c 84       	casts.h	r4
    }while((r1!=0)&&(n>0));
80002cb0:	30 08       	mov	r8,0
80002cb2:	f0 0c 18 00 	cp.b	r12,r8
80002cb6:	5f 1a       	srne	r10
80002cb8:	30 09       	mov	r9,0
80002cba:	f2 04 19 00 	cp.h	r4,r9
80002cbe:	5f 19       	srne	r9
80002cc0:	f5 e9 00 09 	and	r9,r10,r9
80002cc4:	f0 09 18 00 	cp.b	r9,r8
80002cc8:	cc f1       	brne	80002c66 <SD_GoIdleState+0xda>

    if(n==0)
80002cca:	58 04       	cp.w	r4,0
80002ccc:	c1 50       	breq	80002cf6 <SD_GoIdleState+0x16a>
      //printf("\r\n SDHC\n");
    }
    else
    {
	  /* CMD58 */
      SD_SendCmd(58, 0, 0);
80002cce:	30 0a       	mov	r10,0
80002cd0:	14 9b       	mov	r11,r10
80002cd2:	33 ac       	mov	r12,58
80002cd4:	f0 1f 00 1a 	mcall	80002d3c <SD_GoIdleState+0x1b0>
      for(n=0;n<5;n++)
      {
      r1 = SD_ReadByte();
80002cd8:	f0 1f 00 1b 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002cdc:	f0 1f 00 1a 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002ce0:	f0 1f 00 19 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002ce4:	f0 1f 00 18 	mcall	80002d44 <SD_GoIdleState+0x1b8>
80002ce8:	f0 1f 00 17 	mcall	80002d44 <SD_GoIdleState+0x1b8>
      }
	  flag_SDHC = 1;
80002cec:	30 19       	mov	r9,1
80002cee:	49 98       	lddpc	r8,80002d50 <SD_GoIdleState+0x1c4>
80002cf0:	b0 89       	st.b	r8[0x0],r9
80002cf2:	30 07       	mov	r7,0
80002cf4:	c0 38       	rjmp	80002cfa <SD_GoIdleState+0x16e>
80002cf6:	e0 67 00 ff 	mov	r7,255
    //printf("\n\r SD cards inint Done.");
  }  
  */
    
  return Status;
}
80002cfa:	0e 9c       	mov	r12,r7
80002cfc:	d8 32       	popm	r0-r7,pc
      for(n2=0; n2<0xff;n2++)
      {
       r1= SD_ReadByte();
       if(r1 ==0)break;
      }
      n--;
80002cfe:	20 14       	sub	r4,1
80002d00:	5c 84       	casts.h	r4
80002d02:	ce 4b       	rjmp	80002cca <SD_GoIdleState+0x13e>
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002d04:	31 8c       	mov	r12,24
80002d06:	f0 1f 00 11 	mcall	80002d48 <SD_GoIdleState+0x1bc>
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002d0a:	e0 6c 00 ff 	mov	r12,255
80002d0e:	f0 1f 00 10 	mcall	80002d4c <SD_GoIdleState+0x1c0>
      
      /* CS */
      SD_CS_LOW();
80002d12:	31 8c       	mov	r12,24
80002d14:	f0 1f 00 09 	mcall	80002d38 <SD_GoIdleState+0x1ac>
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002d18:	e0 6a 00 ff 	mov	r10,255
80002d1c:	30 0b       	mov	r11,0
80002d1e:	30 1c       	mov	r12,1
80002d20:	f0 1f 00 07 	mcall	80002d3c <SD_GoIdleState+0x1b0>
80002d24:	30 16       	mov	r6,1
      if(TimeOut == 0x00F0)
      {
        break;
      }
  	
  	Status = SD_GetResponse(SD_RESPONSE_NO_ERROR);	
80002d26:	30 05       	mov	r5,0
    TimeOut = 0;
    /*----------SD-----------*/
    do
    {
      /* CS*/
      SD_CS_HIGH();
80002d28:	31 84       	mov	r4,24
      
      /* 0xFF */
      SD_WriteByte(SD_DUMMY_BYTE);
80002d2a:	e0 63 00 ff 	mov	r3,255
      
      /* CS */
      SD_CS_LOW();
      
      /* CMD10x00*/
      SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
80002d2e:	0c 91       	mov	r1,r6
      /* error Response0x00 */
      TimeOut++;
    
      if(TimeOut == 0x00F0)
80002d30:	e0 62 00 f0 	mov	r2,240
80002d34:	c6 8b       	rjmp	80002c04 <SD_GoIdleState+0x78>
80002d36:	00 00       	add	r0,r0
80002d38:	80 00       	ld.sh	r0,r0[0x0]
80002d3a:	a3 e4       	*unknown*
80002d3c:	80 00       	ld.sh	r0,r0[0x0]
80002d3e:	2b 50       	sub	r0,-75
80002d40:	80 00       	ld.sh	r0,r0[0x0]
80002d42:	2a 90       	sub	r0,-87
80002d44:	80 00       	ld.sh	r0,r0[0x0]
80002d46:	2a 4c       	sub	r12,-92
80002d48:	80 00       	ld.sh	r0,r0[0x0]
80002d4a:	a3 c8       	cbr	r8,0x2
80002d4c:	80 00       	ld.sh	r0,r0[0x0]
80002d4e:	2b 04       	sub	r4,-80
80002d50:	00 00       	add	r0,r0
80002d52:	0a 68       	and	r8,r5

80002d54 <SD_GetCIDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
{
80002d54:	eb cd 40 e0 	pushm	r5-r7,lr
80002d58:	20 4d       	sub	sp,16
80002d5a:	18 97       	mov	r7,r12
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  uint8_t CID_Tab[16];
  
  /*!< SD chip select low */
  SD_CS_LOW();
80002d5c:	31 8c       	mov	r12,24
80002d5e:	f0 1f 00 44 	mcall	80002e6c <SD_GetCIDRegister+0x118>
  
  /*!< Send CMD10 (CID register) */
  SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
80002d62:	e0 6a 00 ff 	mov	r10,255
80002d66:	30 0b       	mov	r11,0
80002d68:	30 ac       	mov	r12,10
80002d6a:	f0 1f 00 42 	mcall	80002e70 <SD_GetCIDRegister+0x11c>
  
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002d6e:	30 0c       	mov	r12,0
80002d70:	f0 1f 00 41 	mcall	80002e74 <SD_GetCIDRegister+0x120>
80002d74:	c0 40       	breq	80002d7c <SD_GetCIDRegister+0x28>
80002d76:	e0 66 00 ff 	mov	r6,255
80002d7a:	c1 78       	rjmp	80002da8 <SD_GetCIDRegister+0x54>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
80002d7c:	e0 6c 00 fe 	mov	r12,254
80002d80:	f0 1f 00 3d 	mcall	80002e74 <SD_GetCIDRegister+0x120>
80002d84:	c0 91       	brne	80002d96 <SD_GetCIDRegister+0x42>
80002d86:	1a 96       	mov	r6,sp
  * @param  SD_cid: pointer on an CID register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
80002d88:	fa c5 ff f0 	sub	r5,sp,-16
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
      {
        CID_Tab[i] = SD_ReadByte();
80002d8c:	f0 1f 00 3b 	mcall	80002e78 <SD_GetCIDRegister+0x124>
80002d90:	0c cc       	st.b	r6++,r12
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Store CID register value on CID_Tab */
      for (i = 0; i < 16; i++)
80002d92:	0a 36       	cp.w	r6,r5
80002d94:	cf c1       	brne	80002d8c <SD_GetCIDRegister+0x38>
      {
        CID_Tab[i] = SD_ReadByte();
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
80002d96:	e0 6c 00 ff 	mov	r12,255
80002d9a:	f0 1f 00 39 	mcall	80002e7c <SD_GetCIDRegister+0x128>
    SD_WriteByte(SD_DUMMY_BYTE);
80002d9e:	e0 6c 00 ff 	mov	r12,255
80002da2:	f0 1f 00 37 	mcall	80002e7c <SD_GetCIDRegister+0x128>
80002da6:	30 06       	mov	r6,0
    /*!< Set response value to success */
    rvalue = SD_RESPONSE_NO_ERROR;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002da8:	31 8c       	mov	r12,24
80002daa:	f0 1f 00 36 	mcall	80002e80 <SD_GetCIDRegister+0x12c>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002dae:	e0 6c 00 ff 	mov	r12,255
80002db2:	f0 1f 00 33 	mcall	80002e7c <SD_GetCIDRegister+0x128>

  /*!< Byte 0 */
  SD_cid->ManufacturerID = CID_Tab[0];
80002db6:	1b 88       	ld.ub	r8,sp[0x0]
80002db8:	ae 88       	st.b	r7[0x0],r8

  /*!< Byte 1 */
  SD_cid->OEM_AppliID = CID_Tab[1] << 8;
80002dba:	fb 28 00 01 	ld.sb	r8,sp[1]
80002dbe:	a9 68       	lsl	r8,0x8
80002dc0:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 2 */
  SD_cid->OEM_AppliID |= CID_Tab[2];
80002dc2:	8e 19       	ld.sh	r9,r7[0x2]
80002dc4:	1b a8       	ld.ub	r8,sp[0x2]
80002dc6:	f3 e8 10 08 	or	r8,r9,r8
80002dca:	ae 18       	st.h	r7[0x2],r8

  /*!< Byte 3 */
  SD_cid->ProdName1 = CID_Tab[3] << 24;
80002dcc:	1b b8       	ld.ub	r8,sp[0x3]
80002dce:	b9 68       	lsl	r8,0x18
80002dd0:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 4 */
  SD_cid->ProdName1 |= CID_Tab[4] << 16;
80002dd2:	6e 18       	ld.w	r8,r7[0x4]
80002dd4:	1b c9       	ld.ub	r9,sp[0x4]
80002dd6:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002dda:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 5 */
  SD_cid->ProdName1 |= CID_Tab[5] << 8;
80002ddc:	6e 18       	ld.w	r8,r7[0x4]
80002dde:	1b d9       	ld.ub	r9,sp[0x5]
80002de0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002de4:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 6 */
  SD_cid->ProdName1 |= CID_Tab[6];
80002de6:	6e 18       	ld.w	r8,r7[0x4]
80002de8:	1b e9       	ld.ub	r9,sp[0x6]
80002dea:	f3 e8 10 08 	or	r8,r9,r8
80002dee:	8f 18       	st.w	r7[0x4],r8

  /*!< Byte 7 */
  SD_cid->ProdName2 = CID_Tab[7];
80002df0:	1b f8       	ld.ub	r8,sp[0x7]
80002df2:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 8 */
  SD_cid->ProdRev = CID_Tab[8];
80002df6:	fb 38 00 08 	ld.ub	r8,sp[8]
80002dfa:	ef 68 00 09 	st.b	r7[9],r8

  /*!< Byte 9 */
  SD_cid->ProdSN = CID_Tab[9] << 24;
80002dfe:	fb 38 00 09 	ld.ub	r8,sp[9]
80002e02:	b9 68       	lsl	r8,0x18
80002e04:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 10 */
  SD_cid->ProdSN |= CID_Tab[10] << 16;
80002e06:	6e 38       	ld.w	r8,r7[0xc]
80002e08:	fb 39 00 0a 	ld.ub	r9,sp[10]
80002e0c:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80002e10:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 11 */
  SD_cid->ProdSN |= CID_Tab[11] << 8;
80002e12:	6e 38       	ld.w	r8,r7[0xc]
80002e14:	fb 39 00 0b 	ld.ub	r9,sp[11]
80002e18:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002e1c:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 12 */
  SD_cid->ProdSN |= CID_Tab[12];
80002e1e:	6e 38       	ld.w	r8,r7[0xc]
80002e20:	fb 39 00 0c 	ld.ub	r9,sp[12]
80002e24:	f3 e8 10 08 	or	r8,r9,r8
80002e28:	8f 38       	st.w	r7[0xc],r8

  /*!< Byte 13 */
  SD_cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
80002e2a:	ef 39 00 10 	ld.ub	r9,r7[16]
80002e2e:	fb 38 00 0d 	ld.ub	r8,sp[13]
80002e32:	f3 e8 12 49 	or	r9,r9,r8>>0x4
80002e36:	ef 69 00 10 	st.b	r7[16],r9
  SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
80002e3a:	a9 68       	lsl	r8,0x8
80002e3c:	e2 18 0f 00 	andl	r8,0xf00,COH
80002e40:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 14 */
  SD_cid->ManufactDate |= CID_Tab[14];
80002e44:	ef 09 00 12 	ld.sh	r9,r7[18]
80002e48:	fb 38 00 0e 	ld.ub	r8,sp[14]
80002e4c:	f3 e8 10 08 	or	r8,r9,r8
80002e50:	ef 58 00 12 	st.h	r7[18],r8

  /*!< Byte 15 */
  SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
80002e54:	fb 38 00 0f 	ld.ub	r8,sp[15]
80002e58:	a1 98       	lsr	r8,0x1
80002e5a:	ef 68 00 14 	st.b	r7[20],r8
  SD_cid->Reserved2 = 1;
80002e5e:	30 18       	mov	r8,1
80002e60:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Return the reponse */
  return rvalue;
}
80002e64:	0c 9c       	mov	r12,r6
80002e66:	2f cd       	sub	sp,-16
80002e68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002e6c:	80 00       	ld.sh	r0,r0[0x0]
80002e6e:	a3 e4       	*unknown*
80002e70:	80 00       	ld.sh	r0,r0[0x0]
80002e72:	2b 50       	sub	r0,-75
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	2a 90       	sub	r0,-87
80002e78:	80 00       	ld.sh	r0,r0[0x0]
80002e7a:	2a 4c       	sub	r12,-92
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	2b 04       	sub	r4,-80
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	a3 c8       	cbr	r8,0x2

80002e84 <SD_WriteMultiBlocks>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteMultiBlocks(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002e84:	d4 31       	pushm	r0-r7,lr
80002e86:	18 95       	mov	r5,r12
80002e88:	16 93       	mov	r3,r11
80002e8a:	14 96       	mov	r6,r10
80002e8c:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002e8e:	31 8c       	mov	r12,24
80002e90:	f0 1f 00 27 	mcall	80002f2c <SD_WriteMultiBlocks+0xa8>
80002e94:	e0 67 00 ff 	mov	r7,255
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
80002e98:	4a 60       	lddpc	r0,80002f30 <SD_WriteMultiBlocks+0xac>
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002e9a:	0e 92       	mov	r2,r7
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002e9c:	5c 76       	castu.h	r6
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
    SD_ReadByte();
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002e9e:	30 51       	mov	r1,5
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002ea0:	c3 a8       	rjmp	80002f14 <SD_WriteMultiBlocks+0x90>
  {
    if(flag_SDHC == 1)
80002ea2:	01 88       	ld.ub	r8,r0[0x0]
80002ea4:	30 19       	mov	r9,1
80002ea6:	f2 08 18 00 	cp.b	r8,r9
80002eaa:	c0 81       	brne	80002eba <SD_WriteMultiBlocks+0x36>
    {
        /* Send CMD24 (MSD_WRITE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, (WriteAddr + Offset)/512, 0xFF);
80002eac:	04 9a       	mov	r10,r2
80002eae:	e6 0b 16 09 	lsr	r11,r3,0x9
80002eb2:	31 8c       	mov	r12,24
80002eb4:	f0 1f 00 20 	mcall	80002f34 <SD_WriteMultiBlocks+0xb0>
80002eb8:	c0 68       	rjmp	80002ec4 <SD_WriteMultiBlocks+0x40>
    }
    else
    {
        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
80002eba:	04 9a       	mov	r10,r2
80002ebc:	06 9b       	mov	r11,r3
80002ebe:	31 8c       	mov	r12,24
80002ec0:	f0 1f 00 1d 	mcall	80002f34 <SD_WriteMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002ec4:	30 0c       	mov	r12,0
80002ec6:	f0 1f 00 1d 	mcall	80002f38 <SD_WriteMultiBlocks+0xb4>
80002eca:	c0 40       	breq	80002ed2 <SD_WriteMultiBlocks+0x4e>
80002ecc:	e0 67 00 ff 	mov	r7,255
80002ed0:	c2 b8       	rjmp	80002f26 <SD_WriteMultiBlocks+0xa2>
    {
      return SD_RESPONSE_FAILURE;
    }
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002ed2:	04 9c       	mov	r12,r2
80002ed4:	f0 1f 00 1a 	mcall	80002f3c <SD_WriteMultiBlocks+0xb8>
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
80002ed8:	e0 6c 00 fe 	mov	r12,254
80002edc:	f0 1f 00 18 	mcall	80002f3c <SD_WriteMultiBlocks+0xb8>
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002ee0:	58 06       	cp.w	r6,0
80002ee2:	c0 a0       	breq	80002ef6 <SD_WriteMultiBlocks+0x72>
80002ee4:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002ee6:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002eea:	f0 1f 00 15 	mcall	80002f3c <SD_WriteMultiBlocks+0xb8>
    /*!< Send dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002eee:	2f f7       	sub	r7,-1
80002ef0:	0c 37       	cp.w	r7,r6
80002ef2:	cf a3       	brcs	80002ee6 <SD_WriteMultiBlocks+0x62>
80002ef4:	0c 05       	add	r5,r6
      pBuffer++;
    }
    /*!< Set next write address */
    Offset += 512;
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002ef6:	f0 1f 00 13 	mcall	80002f40 <SD_WriteMultiBlocks+0xbc>
    SD_ReadByte();
80002efa:	f0 1f 00 12 	mcall	80002f40 <SD_WriteMultiBlocks+0xbc>
    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002efe:	f0 1f 00 12 	mcall	80002f44 <SD_WriteMultiBlocks+0xc0>
80002f02:	f8 01 18 00 	cp.b	r1,r12
80002f06:	f9 b7 00 00 	moveq	r7,0
80002f0a:	e4 07 17 10 	movne	r7,r2
80002f0e:	20 14       	sub	r4,1
80002f10:	e6 c3 fe 00 	sub	r3,r3,-512
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80002f14:	58 04       	cp.w	r4,0
80002f16:	cc 61       	brne	80002ea2 <SD_WriteMultiBlocks+0x1e>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002f18:	31 8c       	mov	r12,24
80002f1a:	f0 1f 00 0c 	mcall	80002f48 <SD_WriteMultiBlocks+0xc4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002f1e:	e0 6c 00 ff 	mov	r12,255
80002f22:	f0 1f 00 07 	mcall	80002f3c <SD_WriteMultiBlocks+0xb8>
  /*!< Returns the reponse */
  return rvalue;
}
80002f26:	0e 9c       	mov	r12,r7
80002f28:	d8 32       	popm	r0-r7,pc
80002f2a:	00 00       	add	r0,r0
80002f2c:	80 00       	ld.sh	r0,r0[0x0]
80002f2e:	a3 e4       	*unknown*
80002f30:	00 00       	add	r0,r0
80002f32:	0a 68       	and	r8,r5
80002f34:	80 00       	ld.sh	r0,r0[0x0]
80002f36:	2b 50       	sub	r0,-75
80002f38:	80 00       	ld.sh	r0,r0[0x0]
80002f3a:	2a 90       	sub	r0,-87
80002f3c:	80 00       	ld.sh	r0,r0[0x0]
80002f3e:	2b 04       	sub	r4,-80
80002f40:	80 00       	ld.sh	r0,r0[0x0]
80002f42:	2a 4c       	sub	r12,-92
80002f44:	80 00       	ld.sh	r0,r0[0x0]
80002f46:	2a c4       	sub	r4,-84
80002f48:	80 00       	ld.sh	r0,r0[0x0]
80002f4a:	a3 c8       	cbr	r8,0x2

80002f4c <SD_WriteBlock>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
{
80002f4c:	eb cd 40 e0 	pushm	r5-r7,lr
80002f50:	18 95       	mov	r5,r12
80002f52:	16 97       	mov	r7,r11
80002f54:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
80002f56:	31 8c       	mov	r12,24
80002f58:	f0 1f 00 1f 	mcall	80002fd4 <SD_WriteBlock+0x88>

  if(flag_SDHC == 1)
80002f5c:	49 f8       	lddpc	r8,80002fd8 <SD_WriteBlock+0x8c>
80002f5e:	11 89       	ld.ub	r9,r8[0x0]
80002f60:	30 18       	mov	r8,1
80002f62:	f0 09 18 00 	cp.b	r9,r8
80002f66:	c0 21       	brne	80002f6a <SD_WriteBlock+0x1e>
  {
  	WriteAddr = WriteAddr/512;
80002f68:	a9 97       	lsr	r7,0x9
  }
  /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
  SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
80002f6a:	e0 6a 00 ff 	mov	r10,255
80002f6e:	0e 9b       	mov	r11,r7
80002f70:	31 8c       	mov	r12,24
80002f72:	f0 1f 00 1b 	mcall	80002fdc <SD_WriteBlock+0x90>
  
  /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
80002f76:	30 0c       	mov	r12,0
80002f78:	f0 1f 00 1a 	mcall	80002fe0 <SD_WriteBlock+0x94>
80002f7c:	c1 f1       	brne	80002fba <SD_WriteBlock+0x6e>
  {
    /*!< Send a dummy byte */
    SD_WriteByte(SD_DUMMY_BYTE);
80002f7e:	e0 6c 00 ff 	mov	r12,255
80002f82:	f0 1f 00 19 	mcall	80002fe4 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);
80002f86:	e0 6c 00 fe 	mov	r12,254
80002f8a:	f0 1f 00 17 	mcall	80002fe4 <SD_WriteBlock+0x98>

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f8e:	5c 76       	castu.h	r6
80002f90:	c0 90       	breq	80002fa2 <SD_WriteBlock+0x56>
80002f92:	30 07       	mov	r7,0
    {
      /*!< Send the pointed byte */
      SD_WriteByte(*pBuffer);
80002f94:	ea 07 07 0c 	ld.ub	r12,r5[r7]
80002f98:	f0 1f 00 13 	mcall	80002fe4 <SD_WriteBlock+0x98>

    /*!< Send the data token to signify the start of the data */
    SD_WriteByte(0xFE);

    /*!< Write the block data to SD : write count data by block */
    for (i = 0; i < BlockSize; i++)
80002f9c:	2f f7       	sub	r7,-1
80002f9e:	0c 37       	cp.w	r7,r6
80002fa0:	cf a3       	brcs	80002f94 <SD_WriteBlock+0x48>
      SD_WriteByte(*pBuffer);
      /*!< Point to the next location where the byte read will be saved */
      pBuffer++;
    }
    /*!< Put CRC bytes (not really needed by us, but required by SD) */
    SD_ReadByte();
80002fa2:	f0 1f 00 12 	mcall	80002fe8 <SD_WriteBlock+0x9c>
    SD_ReadByte();
80002fa6:	f0 1f 00 11 	mcall	80002fe8 <SD_WriteBlock+0x9c>

    /*!< Read data response */
    if (SD_GetDataResponse() == SD_DATA_OK)
80002faa:	f0 1f 00 11 	mcall	80002fec <SD_WriteBlock+0xa0>
80002fae:	30 58       	mov	r8,5
80002fb0:	f0 0c 18 00 	cp.b	r12,r8
80002fb4:	c0 31       	brne	80002fba <SD_WriteBlock+0x6e>
80002fb6:	30 07       	mov	r7,0
80002fb8:	c0 38       	rjmp	80002fbe <SD_WriteBlock+0x72>
80002fba:	e0 67 00 ff 	mov	r7,255
    {
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80002fbe:	31 8c       	mov	r12,24
80002fc0:	f0 1f 00 0c 	mcall	80002ff0 <SD_WriteBlock+0xa4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80002fc4:	e0 6c 00 ff 	mov	r12,255
80002fc8:	f0 1f 00 07 	mcall	80002fe4 <SD_WriteBlock+0x98>

  /*!< Returns the reponse */
  return rvalue;
}
80002fcc:	0e 9c       	mov	r12,r7
80002fce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002fd2:	00 00       	add	r0,r0
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	a3 e4       	*unknown*
80002fd8:	00 00       	add	r0,r0
80002fda:	0a 68       	and	r8,r5
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	2b 50       	sub	r0,-75
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	2a 90       	sub	r0,-87
80002fe4:	80 00       	ld.sh	r0,r0[0x0]
80002fe6:	2b 04       	sub	r4,-80
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	2a 4c       	sub	r12,-92
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	2a c4       	sub	r4,-84
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	a3 c8       	cbr	r8,0x2

80002ff4 <SD_ReadMultiBlocks>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadMultiBlocks(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
{
80002ff4:	d4 31       	pushm	r0-r7,lr
80002ff6:	20 1d       	sub	sp,4
80002ff8:	18 95       	mov	r5,r12
80002ffa:	50 0b       	stdsp	sp[0x0],r11
80002ffc:	14 96       	mov	r6,r10
80002ffe:	12 94       	mov	r4,r9
  uint32_t i = 0, Offset = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
80003000:	31 8c       	mov	r12,24
80003002:	f0 1f 00 27 	mcall	8000309c <SD_ReadMultiBlocks+0xa8>
80003006:	e0 67 00 ff 	mov	r7,255
8000300a:	30 02       	mov	r2,0
  /*!< Data transfer */
  while (NumberOfBlocks--)
  {
    if(flag_SDHC == 1)
8000300c:	4a 53       	lddpc	r3,800030a0 <SD_ReadMultiBlocks+0xac>
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
8000300e:	0e 90       	mov	r0,r7
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003010:	04 91       	mov	r1,r2
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003012:	5c 76       	castu.h	r6
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80003014:	c3 78       	rjmp	80003082 <SD_ReadMultiBlocks+0x8e>
  {
    if(flag_SDHC == 1)
80003016:	07 88       	ld.ub	r8,r3[0x0]
80003018:	30 19       	mov	r9,1
8000301a:	f2 08 18 00 	cp.b	r8,r9
8000301e:	c0 a1       	brne	80003032 <SD_ReadMultiBlocks+0x3e>
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK,(ReadAddr + Offset)/512, 0xFF);
80003020:	40 08       	lddsp	r8,sp[0x0]
80003022:	e4 08 00 0b 	add	r11,r2,r8
80003026:	00 9a       	mov	r10,r0
80003028:	a9 9b       	lsr	r11,0x9
8000302a:	31 1c       	mov	r12,17
8000302c:	f0 1f 00 1e 	mcall	800030a4 <SD_ReadMultiBlocks+0xb0>
80003030:	c0 88       	rjmp	80003040 <SD_ReadMultiBlocks+0x4c>
    }
    else
    {
        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
80003032:	00 9a       	mov	r10,r0
80003034:	40 09       	lddsp	r9,sp[0x0]
80003036:	e4 09 00 0b 	add	r11,r2,r9
8000303a:	31 1c       	mov	r12,17
8000303c:	f0 1f 00 1a 	mcall	800030a4 <SD_ReadMultiBlocks+0xb0>
    }
    /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
    if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
80003040:	02 9c       	mov	r12,r1
80003042:	f0 1f 00 1a 	mcall	800030a8 <SD_ReadMultiBlocks+0xb4>
80003046:	c0 40       	breq	8000304e <SD_ReadMultiBlocks+0x5a>
80003048:	e0 67 00 ff 	mov	r7,255
8000304c:	c2 48       	rjmp	80003094 <SD_ReadMultiBlocks+0xa0>
    {
      return  SD_RESPONSE_FAILURE;
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
8000304e:	e0 6c 00 fe 	mov	r12,254
80003052:	f0 1f 00 16 	mcall	800030a8 <SD_ReadMultiBlocks+0xb4>
80003056:	c0 30       	breq	8000305c <SD_ReadMultiBlocks+0x68>
80003058:	00 97       	mov	r7,r0
8000305a:	c1 38       	rjmp	80003080 <SD_ReadMultiBlocks+0x8c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
8000305c:	58 06       	cp.w	r6,0
8000305e:	c0 a0       	breq	80003072 <SD_ReadMultiBlocks+0x7e>
80003060:	02 97       	mov	r7,r1
      {
        /*!< Read the pointed data */
        *pBuffer = SD_ReadByte();
80003062:	f0 1f 00 13 	mcall	800030ac <SD_ReadMultiBlocks+0xb8>
80003066:	ea 07 0b 0c 	st.b	r5[r7],r12
    }
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
8000306a:	2f f7       	sub	r7,-1
8000306c:	0c 37       	cp.w	r7,r6
8000306e:	cf a3       	brcs	80003062 <SD_ReadMultiBlocks+0x6e>
80003070:	0c 05       	add	r5,r6
        *pBuffer = SD_ReadByte();
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Set next read address*/
      Offset += 512;
80003072:	e4 c2 fe 00 	sub	r2,r2,-512
      /*!< get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
80003076:	f0 1f 00 0e 	mcall	800030ac <SD_ReadMultiBlocks+0xb8>
      SD_ReadByte();
8000307a:	f0 1f 00 0d 	mcall	800030ac <SD_ReadMultiBlocks+0xb8>
8000307e:	02 97       	mov	r7,r1
80003080:	20 14       	sub	r4,1
  SD_Error rvalue = SD_RESPONSE_FAILURE;
  
  /*!< SD chip select low */
  SD_CS_LOW();
  /*!< Data transfer */
  while (NumberOfBlocks--)
80003082:	58 04       	cp.w	r4,0
80003084:	cc 91       	brne	80003016 <SD_ReadMultiBlocks+0x22>
      /*!< Set response value to failure */
      rvalue = SD_RESPONSE_FAILURE;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80003086:	31 8c       	mov	r12,24
80003088:	f0 1f 00 0a 	mcall	800030b0 <SD_ReadMultiBlocks+0xbc>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
8000308c:	e0 6c 00 ff 	mov	r12,255
80003090:	f0 1f 00 09 	mcall	800030b4 <SD_ReadMultiBlocks+0xc0>
  /*!< Returns the reponse */
  return rvalue;
}
80003094:	0e 9c       	mov	r12,r7
80003096:	2f fd       	sub	sp,-4
80003098:	d8 32       	popm	r0-r7,pc
8000309a:	00 00       	add	r0,r0
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	a3 e4       	*unknown*
800030a0:	00 00       	add	r0,r0
800030a2:	0a 68       	and	r8,r5
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	2b 50       	sub	r0,-75
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	2a 90       	sub	r0,-87
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	2a 4c       	sub	r12,-92
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	a3 c8       	cbr	r8,0x2
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	2b 04       	sub	r4,-80

800030b8 <SD_ReadBlock>:
  * @retval The SD Response:
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
{
800030b8:	eb cd 40 e0 	pushm	r5-r7,lr
800030bc:	18 95       	mov	r5,r12
800030be:	16 97       	mov	r7,r11
800030c0:	14 96       	mov	r6,r10
  uint32_t i = 0;
  SD_Error rvalue = SD_RESPONSE_FAILURE;

  /*!< SD chip select low */
  SD_CS_LOW();
800030c2:	31 8c       	mov	r12,24
800030c4:	f0 1f 00 1a 	mcall	8000312c <SD_ReadBlock+0x74>
  
if(flag_SDHC == 1)
800030c8:	49 a8       	lddpc	r8,80003130 <SD_ReadBlock+0x78>
800030ca:	11 89       	ld.ub	r9,r8[0x0]
800030cc:	30 18       	mov	r8,1
800030ce:	f0 09 18 00 	cp.b	r9,r8
800030d2:	c0 21       	brne	800030d6 <SD_ReadBlock+0x1e>
{
	ReadAddr = ReadAddr/512;
800030d4:	a9 97       	lsr	r7,0x9
}
  /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
  SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
800030d6:	e0 6a 00 ff 	mov	r10,255
800030da:	0e 9b       	mov	r11,r7
800030dc:	31 1c       	mov	r12,17
800030de:	f0 1f 00 16 	mcall	80003134 <SD_ReadBlock+0x7c>
  
  /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
800030e2:	30 0c       	mov	r12,0
800030e4:	f0 1f 00 15 	mcall	80003138 <SD_ReadBlock+0x80>
800030e8:	c1 61       	brne	80003114 <SD_ReadBlock+0x5c>
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
800030ea:	e0 6c 00 fe 	mov	r12,254
800030ee:	f0 1f 00 13 	mcall	80003138 <SD_ReadBlock+0x80>
800030f2:	c1 11       	brne	80003114 <SD_ReadBlock+0x5c>
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
800030f4:	5c 76       	castu.h	r6
800030f6:	c0 90       	breq	80003108 <SD_ReadBlock+0x50>
800030f8:	30 07       	mov	r7,0
      {
        /*!< Save the received data */
        *pBuffer = SD_ReadByte();
800030fa:	f0 1f 00 11 	mcall	8000313c <SD_ReadBlock+0x84>
800030fe:	ea 07 0b 0c 	st.b	r5[r7],r12
  {
    /*!< Now look for the data token to signify the start of the data */
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      /*!< Read the SD block data : read NumByteToRead data */
      for (i = 0; i < BlockSize; i++)
80003102:	2f f7       	sub	r7,-1
80003104:	0c 37       	cp.w	r7,r6
80003106:	cf a3       	brcs	800030fa <SD_ReadBlock+0x42>
       
        /*!< Point to the next location where the byte read will be saved */
        pBuffer++;
      }
      /*!< Get CRC bytes (not really needed by us, but required by SD) */
      SD_ReadByte();
80003108:	f0 1f 00 0d 	mcall	8000313c <SD_ReadBlock+0x84>
      SD_ReadByte();
8000310c:	f0 1f 00 0c 	mcall	8000313c <SD_ReadBlock+0x84>
80003110:	30 07       	mov	r7,0
80003112:	c0 38       	rjmp	80003118 <SD_ReadBlock+0x60>
80003114:	e0 67 00 ff 	mov	r7,255
      /*!< Set response value to success */
      rvalue = SD_RESPONSE_NO_ERROR;
    }
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
80003118:	31 8c       	mov	r12,24
8000311a:	f0 1f 00 0a 	mcall	80003140 <SD_ReadBlock+0x88>
  
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
8000311e:	e0 6c 00 ff 	mov	r12,255
80003122:	f0 1f 00 09 	mcall	80003144 <SD_ReadBlock+0x8c>
  
  /*!< Returns the reponse */
  return rvalue;
}
80003126:	0e 9c       	mov	r12,r7
80003128:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000312c:	80 00       	ld.sh	r0,r0[0x0]
8000312e:	a3 e4       	*unknown*
80003130:	00 00       	add	r0,r0
80003132:	0a 68       	and	r8,r5
80003134:	80 00       	ld.sh	r0,r0[0x0]
80003136:	2b 50       	sub	r0,-75
80003138:	80 00       	ld.sh	r0,r0[0x0]
8000313a:	2a 90       	sub	r0,-87
8000313c:	80 00       	ld.sh	r0,r0[0x0]
8000313e:	2a 4c       	sub	r12,-92
80003140:	80 00       	ld.sh	r0,r0[0x0]
80003142:	a3 c8       	cbr	r8,0x2
80003144:	80 00       	ld.sh	r0,r0[0x0]
80003146:	2b 04       	sub	r4,-80

80003148 <SD_Init>:
  * @   SD
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_Init(void)
{
80003148:	eb cd 40 f8 	pushm	r3-r7,lr
  uint32_t TimeOut, i = 0;
  SD_Error Status = SD_RESPONSE_NO_ERROR;

  /* SD_SPI,SPI */
  SD_LowLevel_Init(); 
8000314c:	f0 1f 00 11 	mcall	80003190 <SD_Init+0x48>

  /*SD_SPI*/
  SD_SPI_SetSpeedLow();
80003150:	f0 1f 00 11 	mcall	80003194 <SD_Init+0x4c>
80003154:	30 05       	mov	r5,0
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
80003156:	31 84       	mov	r4,24
80003158:	0a 93       	mov	r3,r5

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
8000315a:	e0 66 00 ff 	mov	r6,255
  TimeOut = 0;
  do
  {
	  
    /* SDCS*/
    SD_CS_HIGH();
8000315e:	08 9c       	mov	r12,r4
80003160:	f0 1f 00 0e 	mcall	80003198 <SD_Init+0x50>
80003164:	06 97       	mov	r7,r3

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
    {
      SD_WriteByte(SD_DUMMY_BYTE);
80003166:	0c 9c       	mov	r12,r6
80003168:	f0 1f 00 0d 	mcall	8000319c <SD_Init+0x54>
    /* SDCS*/
    SD_CS_HIGH();

    /*!< Rise CS and MOSI for 80 clocks cycles */
	/* CS100xFF,80*/
    for (i = 0; i <= 9; i++)
8000316c:	2f f7       	sub	r7,-1
8000316e:	58 a7       	cp.w	r7,10
80003170:	cf b1       	brne	80003166 <SD_Init+0x1e>
    {
      SD_WriteByte(SD_DUMMY_BYTE);
    }    
    
	Status = SD_GoIdleState();
80003172:	f0 1f 00 0c 	mcall	800031a0 <SD_Init+0x58>
80003176:	18 97       	mov	r7,r12

    if(TimeOut > 6)
80003178:	58 75       	cp.w	r5,7
8000317a:	c0 50       	breq	80003184 <SD_Init+0x3c>
    {
      break;
    }
    TimeOut++;
  }while(Status);
8000317c:	58 0c       	cp.w	r12,0
8000317e:	c0 30       	breq	80003184 <SD_Init+0x3c>

    if(TimeOut > 6)
    {
      break;
    }
    TimeOut++;
80003180:	2f f5       	sub	r5,-1
80003182:	ce eb       	rjmp	8000315e <SD_Init+0x16>
  }while(Status);


   /*SD_SPI*/
  SD_SPI_SetSpeedHi();
80003184:	f0 1f 00 08 	mcall	800031a4 <SD_Init+0x5c>
  return (Status);
}
80003188:	0e 9c       	mov	r12,r7
8000318a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000318e:	00 00       	add	r0,r0
80003190:	80 00       	ld.sh	r0,r0[0x0]
80003192:	29 d4       	sub	r4,-99
80003194:	80 00       	ld.sh	r0,r0[0x0]
80003196:	29 c4       	sub	r4,-100
80003198:	80 00       	ld.sh	r0,r0[0x0]
8000319a:	a3 c8       	cbr	r8,0x2
8000319c:	80 00       	ld.sh	r0,r0[0x0]
8000319e:	2b 04       	sub	r4,-80
800031a0:	80 00       	ld.sh	r0,r0[0x0]
800031a2:	2b 8c       	sub	r12,-72
800031a4:	80 00       	ld.sh	r0,r0[0x0]
800031a6:	29 b4       	sub	r4,-101

800031a8 <SD_GetCSDRegister>:
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
{
800031a8:	eb cd 40 e0 	pushm	r5-r7,lr
800031ac:	20 9d       	sub	sp,36
800031ae:	18 97       	mov	r7,r12
  uint8_t CSD_Tab[16];
  uint32_t CardCapacity;
  static uint32_t times = 0;

  /*!< SD chip select low */
  SD_CS_LOW();
800031b0:	31 8c       	mov	r12,24
800031b2:	f0 1f 00 a6 	mcall	80003448 <SD_GetCSDRegister+0x2a0>
  /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
  SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
800031b6:	e0 6a 00 ff 	mov	r10,255
800031ba:	30 0b       	mov	r11,0
800031bc:	30 9c       	mov	r12,9
800031be:	f0 1f 00 a4 	mcall	8000344c <SD_GetCSDRegister+0x2a4>
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
800031c2:	30 0c       	mov	r12,0
800031c4:	f0 1f 00 a3 	mcall	80003450 <SD_GetCSDRegister+0x2a8>
800031c8:	c0 40       	breq	800031d0 <SD_GetCSDRegister+0x28>
800031ca:	e0 6c 00 ff 	mov	r12,255
800031ce:	c3 99       	rjmp	80003440 <SD_GetCSDRegister+0x298>
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
800031d0:	e0 6c 00 fe 	mov	r12,254
800031d4:	f0 1f 00 9f 	mcall	80003450 <SD_GetCSDRegister+0x2a8>
800031d8:	c0 a1       	brne	800031ec <SD_GetCSDRegister+0x44>
800031da:	fa c6 ff ec 	sub	r6,sp,-20
  * @param  SD_csd: pointer on an SCD register structure
  * @retval The SD Response: 
  *         - SD_RESPONSE_FAILURE: Sequence failed
  *         - SD_RESPONSE_NO_ERROR: Sequence succeed
  */
SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
800031de:	fa c5 ff dc 	sub	r5,sp,-36
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
      {
        /*!< Store CSD register value on CSD_Tab */
        CSD_Tab[i] = SD_ReadByte();
800031e2:	f0 1f 00 9d 	mcall	80003454 <SD_GetCSDRegister+0x2ac>
800031e6:	0c cc       	st.b	r6++,r12
  /*!< Wait for response in the R1 format (0x00 is no errors) */
  if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
  {
    if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
    {
      for (i = 0; i < 16; i++)
800031e8:	0a 36       	cp.w	r6,r5
800031ea:	cf c1       	brne	800031e2 <SD_GetCSDRegister+0x3a>
          //printf("\n\r CSD_Tab[%d] 0x%X", i, CSD_Tab[i]);
        }
      }
    }
    /*!< Get CRC bytes (not really needed by us, but required by SD) */
    SD_WriteByte(SD_DUMMY_BYTE);
800031ec:	e0 6c 00 ff 	mov	r12,255
800031f0:	f0 1f 00 9a 	mcall	80003458 <SD_GetCSDRegister+0x2b0>
    SD_WriteByte(SD_DUMMY_BYTE);
800031f4:	e0 6c 00 ff 	mov	r12,255
800031f8:	f0 1f 00 98 	mcall	80003458 <SD_GetCSDRegister+0x2b0>
  else
  {
     return rvalue;
  }
  /*!< SD chip select high */
  SD_CS_HIGH();
800031fc:	31 8c       	mov	r12,24
800031fe:	f0 1f 00 98 	mcall	8000345c <SD_GetCSDRegister+0x2b4>
  /*!< Send dummy byte: 8 Clock pulses of delay */
  SD_WriteByte(SD_DUMMY_BYTE);
80003202:	e0 6c 00 ff 	mov	r12,255
80003206:	f0 1f 00 95 	mcall	80003458 <SD_GetCSDRegister+0x2b0>

  /*!< Byte 0 */
  SD_csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
8000320a:	fb 38 00 14 	ld.ub	r8,sp[20]
8000320e:	f0 09 16 06 	lsr	r9,r8,0x6
80003212:	ae 89       	st.b	r7[0x0],r9
  SD_csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
80003214:	f3 d8 c0 44 	bfextu	r9,r8,0x2,0x4
80003218:	ae 99       	st.b	r7[0x1],r9
  SD_csd->Reserved1 = CSD_Tab[0] & 0x03;
8000321a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000321e:	ae a8       	st.b	r7[0x2],r8

  if(0 == times)
80003220:	fe f8 02 40 	ld.w	r8,pc[576]
80003224:	70 08       	ld.w	r8,r8[0x0]
80003226:	58 08       	cp.w	r8,0
80003228:	c0 f1       	brne	80003246 <SD_GetCSDRegister+0x9e>
  {
    if(SD_csd->CSDStruct == 1)
8000322a:	0f 89       	ld.ub	r9,r7[0x0]
8000322c:	30 18       	mov	r8,1
8000322e:	f0 09 18 00 	cp.b	r9,r8
80003232:	c0 61       	brne	8000323e <SD_GetCSDRegister+0x96>
    {
      //printf("\n\r SDHC CSD Version 2.0 Acess AS SD High Capacity.");
      flag_SDHC = 1;
80003234:	10 99       	mov	r9,r8
80003236:	fe f8 02 2e 	ld.w	r8,pc[558]
8000323a:	b0 89       	st.b	r8[0x0],r9
8000323c:	c0 58       	rjmp	80003246 <SD_GetCSDRegister+0x9e>
    }
	else
	{
      //printf("\n\r SDSC CSD Version 1.0 Acess AS SD Standard Capacity.");	
      flag_SDHC = 0;
8000323e:	30 09       	mov	r9,0
80003240:	fe f8 02 24 	ld.w	r8,pc[548]
80003244:	b0 89       	st.b	r8[0x0],r9
	}
  }

  /*!< Byte 1 */
  SD_csd->TAAC = CSD_Tab[1];
80003246:	fb 38 00 15 	ld.ub	r8,sp[21]
8000324a:	ae b8       	st.b	r7[0x3],r8

  /*!< Byte 2 */
  SD_csd->NSAC = CSD_Tab[2];
8000324c:	fb 38 00 16 	ld.ub	r8,sp[22]
80003250:	ae c8       	st.b	r7[0x4],r8

  /*!< Byte 3 */
  SD_csd->MaxBusClkFrec = CSD_Tab[3];
80003252:	fb 38 00 17 	ld.ub	r8,sp[23]
80003256:	ae d8       	st.b	r7[0x5],r8

  /*!< Byte 4 */
  SD_csd->CardComdClasses = CSD_Tab[4] << 4;
80003258:	fb 38 00 18 	ld.ub	r8,sp[24]
8000325c:	a5 68       	lsl	r8,0x4
8000325e:	ae 38       	st.h	r7[0x6],r8

  /*!< Byte 5 */
  SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
80003260:	8e 39       	ld.sh	r9,r7[0x6]
80003262:	fb 38 00 19 	ld.ub	r8,sp[25]
80003266:	f3 e8 12 49 	or	r9,r9,r8>>0x4
8000326a:	ae 39       	st.h	r7[0x6],r9
  SD_csd->RdBlockLen = CSD_Tab[5] & 0x0F;
8000326c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003270:	ef 68 00 08 	st.b	r7[8],r8

  /*!< Byte 6 */
  SD_csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
80003274:	fb 38 00 1a 	ld.ub	r8,sp[26]
80003278:	f0 09 16 07 	lsr	r9,r8,0x7
8000327c:	ef 69 00 09 	st.b	r7[9],r9
  SD_csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
80003280:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
80003284:	ef 69 00 0a 	st.b	r7[10],r9
  SD_csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
80003288:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
8000328c:	ef 69 00 0b 	st.b	r7[11],r9
  SD_csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
80003290:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80003294:	ef 69 00 0c 	st.b	r7[12],r9
  SD_csd->Reserved2 = 0; /*!< Reserved */
80003298:	30 09       	mov	r9,0
8000329a:	ef 69 00 0d 	st.b	r7[13],r9

  if(flag_SDHC == 0)
8000329e:	4f 2a       	lddpc	r10,80003464 <SD_GetCSDRegister+0x2bc>
800032a0:	15 8a       	ld.ub	r10,r10[0x0]
800032a2:	f2 0a 18 00 	cp.b	r10,r9
800032a6:	c1 21       	brne	800032ca <SD_GetCSDRegister+0x122>
  {
    SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
800032a8:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800032ac:	ab 68       	lsl	r8,0xa
800032ae:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 7 */
    SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
800032b0:	6e 48       	ld.w	r8,r7[0x10]
800032b2:	fb 39 00 1b 	ld.ub	r9,sp[27]
800032b6:	f1 e9 10 28 	or	r8,r8,r9<<0x2
800032ba:	8f 48       	st.w	r7[0x10],r8
  
    /*!< Byte 8 */
    SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
800032bc:	6e 48       	ld.w	r8,r7[0x10]
800032be:	fb 39 00 1c 	ld.ub	r9,sp[28]
800032c2:	f1 e9 12 68 	or	r8,r8,r9>>0x6
800032c6:	8f 48       	st.w	r7[0x10],r8
800032c8:	c1 38       	rjmp	800032ee <SD_GetCSDRegister+0x146>
  }
  else
  {
    SD_csd->DeviceSize = (CSD_Tab[7] & 0x3F) << 16;
800032ca:	fb 38 00 1b 	ld.ub	r8,sp[27]
800032ce:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
800032d2:	b1 68       	lsl	r8,0x10
800032d4:	8f 48       	st.w	r7[0x10],r8
    /* Byte 7 */
    SD_csd->DeviceSize += (CSD_Tab[8]) << 8;
800032d6:	6e 49       	ld.w	r9,r7[0x10]
800032d8:	fb 38 00 1c 	ld.ub	r8,sp[28]
800032dc:	a9 68       	lsl	r8,0x8
800032de:	12 08       	add	r8,r9
800032e0:	8f 48       	st.w	r7[0x10],r8
    /* Byte 8 */
    SD_csd->DeviceSize += CSD_Tab[9] ;
800032e2:	6e 48       	ld.w	r8,r7[0x10]
800032e4:	fb 39 00 1d 	ld.ub	r9,sp[29]
800032e8:	f2 08 00 08 	add	r8,r9,r8
800032ec:	8f 48       	st.w	r7[0x10],r8
  }    

  SD_csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
800032ee:	fb 38 00 1c 	ld.ub	r8,sp[28]
800032f2:	f3 d8 c0 63 	bfextu	r9,r8,0x3,0x3
800032f6:	ef 69 00 14 	st.b	r7[20],r9
  SD_csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
800032fa:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800032fe:	ef 68 00 15 	st.b	r7[21],r8

  /*!< Byte 9 */
  SD_csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
80003302:	fb 38 00 1d 	ld.ub	r8,sp[29]
80003306:	f0 09 16 05 	lsr	r9,r8,0x5
8000330a:	ef 69 00 16 	st.b	r7[22],r9
  SD_csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
8000330e:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
80003312:	ef 69 00 17 	st.b	r7[23],r9
  SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
80003316:	a1 78       	lsl	r8,0x1
80003318:	e2 18 00 06 	andl	r8,0x6,COH
8000331c:	ef 68 00 18 	st.b	r7[24],r8
  /*!< Byte 10 */
  SD_csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
80003320:	ef 39 00 18 	ld.ub	r9,r7[24]
80003324:	fb 38 00 1e 	ld.ub	r8,sp[30]
80003328:	f3 e8 12 79 	or	r9,r9,r8>>0x7
8000332c:	ef 69 00 18 	st.b	r7[24],r9
    
  SD_csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
80003330:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
80003334:	ef 69 00 19 	st.b	r7[25],r9
  SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
80003338:	a1 78       	lsl	r8,0x1
8000333a:	e2 18 00 7e 	andl	r8,0x7e,COH
8000333e:	ef 68 00 1a 	st.b	r7[26],r8

  /*!< Byte 11 */
  SD_csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
80003342:	ef 39 00 1a 	ld.ub	r9,r7[26]
80003346:	fb 38 00 1f 	ld.ub	r8,sp[31]
8000334a:	f3 e8 12 79 	or	r9,r9,r8>>0x7
8000334e:	ef 69 00 1a 	st.b	r7[26],r9
  SD_csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
80003352:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80003356:	ef 68 00 1b 	st.b	r7[27],r8

  /*!< Byte 12 */
  SD_csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
8000335a:	fb 38 00 20 	ld.ub	r8,sp[32]
8000335e:	f0 09 16 07 	lsr	r9,r8,0x7
80003362:	ef 69 00 1c 	st.b	r7[28],r9
  SD_csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
80003366:	f3 d8 c0 a2 	bfextu	r9,r8,0x5,0x2
8000336a:	ef 69 00 1d 	st.b	r7[29],r9
  SD_csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
8000336e:	f3 d8 c0 43 	bfextu	r9,r8,0x2,0x3
80003372:	ef 69 00 1e 	st.b	r7[30],r9
  SD_csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
80003376:	a3 68       	lsl	r8,0x2
80003378:	e2 18 00 0c 	andl	r8,0xc,COH
8000337c:	ef 68 00 1f 	st.b	r7[31],r8

  /*!< Byte 13 */
  SD_csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
80003380:	ef 39 00 1f 	ld.ub	r9,r7[31]
80003384:	fb 38 00 21 	ld.ub	r8,sp[33]
80003388:	f3 e8 12 69 	or	r9,r9,r8>>0x6
8000338c:	ef 69 00 1f 	st.b	r7[31],r9
  SD_csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
80003390:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
80003394:	ef 69 00 20 	st.b	r7[32],r9
  SD_csd->Reserved3 = 0;
80003398:	30 09       	mov	r9,0
8000339a:	ef 69 00 21 	st.b	r7[33],r9
  SD_csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
8000339e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800033a2:	ef 68 00 22 	st.b	r7[34],r8

  /*!< Byte 14 */
  SD_csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
800033a6:	fb 38 00 22 	ld.ub	r8,sp[34]
800033aa:	f0 09 16 07 	lsr	r9,r8,0x7
800033ae:	ef 69 00 23 	st.b	r7[35],r9
  SD_csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
800033b2:	f3 d8 c0 c1 	bfextu	r9,r8,0x6,0x1
800033b6:	ef 69 00 24 	st.b	r7[36],r9
  SD_csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
800033ba:	f3 d8 c0 a1 	bfextu	r9,r8,0x5,0x1
800033be:	ef 69 00 25 	st.b	r7[37],r9
  SD_csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
800033c2:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
800033c6:	ef 69 00 26 	st.b	r7[38],r9
  SD_csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
800033ca:	f3 d8 c0 42 	bfextu	r9,r8,0x2,0x2
800033ce:	ef 69 00 27 	st.b	r7[39],r9
  SD_csd->ECC = (CSD_Tab[14] & 0x03);
800033d2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800033d6:	ef 68 00 28 	st.b	r7[40],r8

  /*!< Byte 15 */
  SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
800033da:	fb 38 00 23 	ld.ub	r8,sp[35]
800033de:	a1 98       	lsr	r8,0x1
800033e0:	ef 68 00 29 	st.b	r7[41],r8
  SD_csd->Reserved4 = 1;
800033e4:	30 18       	mov	r8,1
800033e6:	ef 68 00 2a 	st.b	r7[42],r8

  if(times < 3)
800033ea:	49 e8       	lddpc	r8,80003460 <SD_GetCSDRegister+0x2b8>
800033ec:	70 08       	ld.w	r8,r8[0x0]
800033ee:	58 28       	cp.w	r8,2
800033f0:	e0 88 00 04 	brls	800033f8 <SD_GetCSDRegister+0x250>
800033f4:	30 0c       	mov	r12,0
800033f6:	c2 58       	rjmp	80003440 <SD_GetCSDRegister+0x298>
  {
    if(flag_SDHC ==1)
800033f8:	49 b9       	lddpc	r9,80003464 <SD_GetCSDRegister+0x2bc>
800033fa:	13 8a       	ld.ub	r10,r9[0x0]
800033fc:	30 19       	mov	r9,1
800033fe:	f2 0a 18 00 	cp.b	r10,r9
80003402:	c0 51       	brne	8000340c <SD_GetCSDRegister+0x264>
    {
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
      //SD_csd->DeviceSizeMul = 8 ;
      
      CardCapacity = (SD_csd->DeviceSize + 1)*512;
80003404:	6e 49       	ld.w	r9,r7[0x10]
80003406:	2f f9       	sub	r9,-1
80003408:	a9 79       	lsl	r9,0x9
8000340a:	c0 c8       	rjmp	80003422 <SD_GetCSDRegister+0x27a>
      
    }

    else
    {
      CardCapacity = (SD_csd->DeviceSize + 1);
8000340c:	6e 4a       	ld.w	r10,r7[0x10]
8000340e:	2f fa       	sub	r10,-1
      CardCapacity *= (1 << (SD_csd->DeviceSizeMul + 2));
80003410:	ef 39 00 18 	ld.ub	r9,r7[24]
80003414:	2f e9       	sub	r9,-2
80003416:	f4 09 09 4a 	lsl	r10,r10,r9
      CardCapacity *= (1<<SD_csd->RdBlockLen);
8000341a:	ef 39 00 08 	ld.ub	r9,r7[8]
8000341e:	f4 09 09 49 	lsl	r9,r10,r9
      //printf("\n\r SD CardBlockSize %d CardCapacity %d M.", (1<<SD_csd->RdBlockLen), 
            //CardCapacity / 1024 / 1024);
    }
    
  if(times == 0)
80003422:	58 08       	cp.w	r8,0
80003424:	c0 91       	brne	80003436 <SD_GetCSDRegister+0x28e>
    {
	    uint8_t str[20];
        sprintf((char *)&str[0], " SD Card Size %dM. ", CardCapacity / 1024 / 1024);
80003426:	b5 89       	lsr	r9,0x14
80003428:	1a d9       	st.w	--sp,r9
8000342a:	49 0b       	lddpc	r11,80003468 <SD_GetCSDRegister+0x2c0>
8000342c:	fa cc ff fc 	sub	r12,sp,-4
80003430:	f0 1f 00 0f 	mcall	8000346c <SD_GetCSDRegister+0x2c4>
80003434:	2f fd       	sub	sp,-4
//	    LCD_DisplayStringLine(LCD_LINE_0, str);
    }
	times++;
80003436:	48 b8       	lddpc	r8,80003460 <SD_GetCSDRegister+0x2b8>
80003438:	70 09       	ld.w	r9,r8[0x0]
8000343a:	2f f9       	sub	r9,-1
8000343c:	91 09       	st.w	r8[0x0],r9
8000343e:	30 0c       	mov	r12,0
  }
  /*!< Return the reponse */
  return rvalue;
}
80003440:	2f 7d       	sub	sp,-36
80003442:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003446:	00 00       	add	r0,r0
80003448:	80 00       	ld.sh	r0,r0[0x0]
8000344a:	a3 e4       	*unknown*
8000344c:	80 00       	ld.sh	r0,r0[0x0]
8000344e:	2b 50       	sub	r0,-75
80003450:	80 00       	ld.sh	r0,r0[0x0]
80003452:	2a 90       	sub	r0,-87
80003454:	80 00       	ld.sh	r0,r0[0x0]
80003456:	2a 4c       	sub	r12,-92
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	2b 04       	sub	r4,-80
8000345c:	80 00       	ld.sh	r0,r0[0x0]
8000345e:	a3 c8       	cbr	r8,0x2
80003460:	00 00       	add	r0,r0
80003462:	0a 64       	and	r4,r5
80003464:	00 00       	add	r0,r0
80003466:	0a 68       	and	r8,r5
80003468:	80 01       	ld.sh	r1,r0[0x0]
8000346a:	09 a0       	ld.ub	r0,r4[0x2]
8000346c:	80 00       	ld.sh	r0,r0[0x0]
8000346e:	ac f4       	st.b	r6[0x7],r4

80003470 <SD_GetCardInfo>:
  * @   
  * @   
  * @ 
***------------------------------------------------------*/
SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
{
80003470:	eb cd 40 c0 	pushm	r6-r7,lr
80003474:	18 97       	mov	r7,r12
  static uint32_t i = 0;
  SD_Error status = SD_RESPONSE_FAILURE;

  status = SD_GetCSDRegister(&(cardinfo->SD_csd));
80003476:	18 96       	mov	r6,r12
80003478:	f0 1f 00 12 	mcall	800034c0 <SD_GetCardInfo+0x50>
  if(SD_RESPONSE_FAILURE == status)
8000347c:	e0 4c 00 ff 	cp.w	r12,255
80003480:	c0 41       	brne	80003488 <SD_GetCardInfo+0x18>
  {
    status = SD_GetCSDRegister(&(cardinfo->SD_csd));
80003482:	0e 9c       	mov	r12,r7
80003484:	f0 1f 00 0f 	mcall	800034c0 <SD_GetCardInfo+0x50>
  }
  status = SD_GetCIDRegister(&(cardinfo->SD_cid));
80003488:	ee cc ff d4 	sub	r12,r7,-44
8000348c:	f0 1f 00 0e 	mcall	800034c4 <SD_GetCardInfo+0x54>
  
  if (flag_SDHC = 1)
80003490:	30 19       	mov	r9,1
80003492:	48 e8       	lddpc	r8,800034c8 <SD_GetCardInfo+0x58>
80003494:	b0 89       	st.b	r8[0x0],r9
  {
	  
	  /* SDHC memory capacity = (C_SIZE+1) * 512K byte */
	  
	  cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ; 
80003496:	6e 48       	ld.w	r8,r7[0x10]
80003498:	2f f8       	sub	r8,-1
8000349a:	ef 48 00 44 	st.w	r7[68],r8
	  cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
8000349e:	ef 39 00 08 	ld.ub	r9,r7[8]
800034a2:	30 1a       	mov	r10,1
800034a4:	f4 09 09 49 	lsl	r9,r10,r9
800034a8:	ef 49 00 48 	st.w	r7[72],r9
	  cardinfo->CardCapacity *= cardinfo->CardBlockSize; 
800034ac:	f2 08 02 48 	mul	r8,r9,r8
800034b0:	ef 48 00 44 	st.w	r7[68],r8
  {
  
    //printf("\n\r SD CardBlockSize %d CardCapacity %d M", cardinfo->CardBlockSize, 
            //cardinfo->CardCapacity / 1024 / 1024);
  }
  i++; 
800034b4:	48 68       	lddpc	r8,800034cc <SD_GetCardInfo+0x5c>
800034b6:	70 09       	ld.w	r9,r8[0x0]
800034b8:	14 09       	add	r9,r10
800034ba:	91 09       	st.w	r8[0x0],r9
  
  /*!< Returns the reponse */
  return status;
}
800034bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	31 a8       	mov	r8,26
800034c4:	80 00       	ld.sh	r0,r0[0x0]
800034c6:	2d 54       	sub	r4,-43
800034c8:	00 00       	add	r0,r0
800034ca:	0a 68       	and	r8,r5
800034cc:	00 00       	add	r0,r0
800034ce:	0a 60       	and	r0,r5

800034d0 <SD_GetSectorCount>:
	}while(t<0XFFFFFF);//
	return SD_RESPONSE_FAILURE ;
}

uint32_t SD_GetSectorCount(void)
{
800034d0:	d4 01       	pushm	lr
800034d2:	21 3d       	sub	sp,76
	
	
	uint32_t  static temp;
	
	
	SD_GetCardInfo(&sdinfo);
800034d4:	1a 9c       	mov	r12,sp
800034d6:	f0 1f 00 05 	mcall	800034e8 <SD_GetSectorCount+0x18>
	
	temp = sdinfo.CardCapacity;
	
	temp = temp*(1024/512);//:1sector=512byte
800034da:	41 1c       	lddsp	r12,sp[0x44]
800034dc:	a1 7c       	lsl	r12,0x1
800034de:	48 48       	lddpc	r8,800034ec <SD_GetSectorCount+0x1c>
800034e0:	91 0c       	st.w	r8[0x0],r12
	
	return (temp);
	
	

}
800034e2:	2e dd       	sub	sp,-76
800034e4:	d8 02       	popm	pc
800034e6:	00 00       	add	r0,r0
800034e8:	80 00       	ld.sh	r0,r0[0x0]
800034ea:	34 70       	mov	r0,71
800034ec:	00 00       	add	r0,r0
800034ee:	0a 5c       	eor	r12,r5

800034f0 <MAL_WriteDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_WriteDisk(void *writebuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
800034f0:	d4 01       	pushm	lr
	
	
	if(count == 1)
800034f2:	30 18       	mov	r8,1
800034f4:	f0 09 18 00 	cp.b	r9,r8
800034f8:	c0 71       	brne	80003506 <MAL_WriteDisk+0x16>
	{
		
		if(SD_WriteBlock(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
800034fa:	5c 7a       	castu.h	r10
800034fc:	a9 7b       	lsl	r11,0x9
800034fe:	f0 1f 00 07 	mcall	80003518 <MAL_WriteDisk+0x28>
80003502:	c0 91       	brne	80003514 <MAL_WriteDisk+0x24>
80003504:	c0 68       	rjmp	80003510 <MAL_WriteDisk+0x20>
		
	}
	else
	{
		
		if(SD_WriteMultiBlocks(writebuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
80003506:	5c 7a       	castu.h	r10
80003508:	a9 7b       	lsl	r11,0x9
8000350a:	f0 1f 00 05 	mcall	8000351c <MAL_WriteDisk+0x2c>
8000350e:	c0 31       	brne	80003514 <MAL_WriteDisk+0x24>
80003510:	30 4c       	mov	r12,4
80003512:	d8 02       	popm	pc
80003514:	30 3c       	mov	r12,3
	
	return WRITE_DATA_ERR;
	
	
	
}
80003516:	d8 02       	popm	pc
80003518:	80 00       	ld.sh	r0,r0[0x0]
8000351a:	2f 4c       	sub	r12,-12
8000351c:	80 00       	ld.sh	r0,r0[0x0]
8000351e:	2e 84       	sub	r4,-24

80003520 <MAL_ReadDisk>:
* Output         :
* Return         : SD_ErrorStarus: SD Card Error code.
******************************************************************************************/

MAL_ErrorStarus MAL_ReadDisk(void *readbuff, uint32_t sector, uint32_t blockByteSize, uint8_t count)
{
80003520:	d4 01       	pushm	lr
	
	
	if(count == 1)
80003522:	30 18       	mov	r8,1
80003524:	f0 09 18 00 	cp.b	r9,r8
80003528:	c0 71       	brne	80003536 <MAL_ReadDisk+0x16>
	{
		
		if(SD_ReadBlock(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize)==SD_RESPONSE_NO_ERROR)//1
8000352a:	5c 7a       	castu.h	r10
8000352c:	a9 7b       	lsl	r11,0x9
8000352e:	f0 1f 00 07 	mcall	80003548 <MAL_ReadDisk+0x28>
80003532:	c0 91       	brne	80003544 <MAL_ReadDisk+0x24>
80003534:	c0 68       	rjmp	80003540 <MAL_ReadDisk+0x20>
		
	}
	else
	{
		
		if(SD_ReadMultiBlocks(readbuff, (sector*BLOCK_BYTE_SIZE), blockByteSize, count)==SD_RESPONSE_NO_ERROR)
80003536:	5c 7a       	castu.h	r10
80003538:	a9 7b       	lsl	r11,0x9
8000353a:	f0 1f 00 05 	mcall	8000354c <MAL_ReadDisk+0x2c>
8000353e:	c0 31       	brne	80003544 <MAL_ReadDisk+0x24>
80003540:	30 8c       	mov	r12,8
80003542:	d8 02       	popm	pc
80003544:	30 7c       	mov	r12,7
	
	return READ_DATA_ERR;
	
		
	
}
80003546:	d8 02       	popm	pc
80003548:	80 00       	ld.sh	r0,r0[0x0]
8000354a:	30 b8       	mov	r8,11
8000354c:	80 00       	ld.sh	r0,r0[0x0]
8000354e:	2f f4       	sub	r4,-1

80003550 <MAL_InitConfig>:
* Output         : None
* Return         : SDConfigStatus:SD Card initiation code
*******************************************************************************/

uint16_t MAL_InitConfig(void)
{
80003550:	d4 01       	pushm	lr
80003552:	21 3d       	sub	sp,76
	uint16_t status = SDConfig_OK;
        
    SD_CardInfo cardinfo;

      if(!(SD_Init()))
80003554:	f0 1f 00 06 	mcall	8000356c <MAL_InitConfig+0x1c>
80003558:	c0 30       	breq	8000355e <MAL_InitConfig+0xe>
8000355a:	30 1c       	mov	r12,1
8000355c:	c0 58       	rjmp	80003566 <MAL_InitConfig+0x16>
      {
        
			if(SD_GetCardInfo(&cardinfo)==0) /*SD */
8000355e:	1a 9c       	mov	r12,sp
80003560:	f0 1f 00 04 	mcall	80003570 <MAL_InitConfig+0x20>
80003564:	5f 1c       	srne	r12
			return status;//
      
      }    

        return SDConfig_FALL;
}
80003566:	2e dd       	sub	sp,-76
80003568:	d8 02       	popm	pc
8000356a:	00 00       	add	r0,r0
8000356c:	80 00       	ld.sh	r0,r0[0x0]
8000356e:	31 48       	mov	r8,20
80003570:	80 00       	ld.sh	r0,r0[0x0]
80003572:	34 70       	mov	r0,71

80003574 <fl_read>:
	}
	
}

void fl_read(void * path, S32 offset, void * buffer, U32 length)
{
80003574:	eb cd 40 f8 	pushm	r3-r7,lr
80003578:	20 2d       	sub	sp,8
8000357a:	18 95       	mov	r5,r12
8000357c:	16 94       	mov	r4,r11
8000357e:	14 93       	mov	r3,r10
80003580:	12 96       	mov	r6,r9
	
	fl_read_t * fl_read_ptr = pvPortMalloc(sizeof(fl_read_t));
80003582:	34 cc       	mov	r12,76
80003584:	f0 1f 00 16 	mcall	800035dc <fl_read+0x68>
80003588:	18 97       	mov	r7,r12
	
	sprintf(fl_read_ptr->path, "%s", path);
8000358a:	0a 9b       	mov	r11,r5
8000358c:	f0 1f 00 15 	mcall	800035e0 <fl_read+0x6c>
	fl_read_ptr->offset = offset;
80003590:	ef 44 00 40 	st.w	r7[64],r4
	fl_read_ptr->length = length;
80003594:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_read_ptr->buffer = pvPortMalloc(length);
80003598:	0c 9c       	mov	r12,r6
8000359a:	f0 1f 00 11 	mcall	800035dc <fl_read+0x68>
8000359e:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_read_ptr->buffer, buffer, length);
800035a2:	0c 9a       	mov	r10,r6
800035a4:	06 9b       	mov	r11,r3
800035a6:	f0 1f 00 10 	mcall	800035e4 <fl_read+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_READ;
800035aa:	e0 68 40 01 	mov	r8,16385
800035ae:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_read_ptr;
800035b0:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
800035b2:	48 e8       	lddpc	r8,800035e8 <fl_read+0x74>
800035b4:	70 0c       	ld.w	r12,r8[0x0]
800035b6:	30 09       	mov	r9,0
800035b8:	12 9a       	mov	r10,r9
800035ba:	1a 9b       	mov	r11,sp
800035bc:	f0 1f 00 0c 	mcall	800035ec <fl_read+0x78>
800035c0:	58 1c       	cp.w	r12,1
800035c2:	c0 a0       	breq	800035d6 <fl_read+0x62>
	{
		vPortFree(fl_read_ptr->buffer);
800035c4:	6f 2c       	ld.w	r12,r7[0x48]
800035c6:	f0 1f 00 0b 	mcall	800035f0 <fl_read+0x7c>
		vPortFree(fl_read_ptr);
800035ca:	0e 9c       	mov	r12,r7
800035cc:	f0 1f 00 09 	mcall	800035f0 <fl_read+0x7c>
		log("\n\r Rmm \n\r");//man...SPI_PBA
800035d0:	48 9c       	lddpc	r12,800035f4 <fl_read+0x80>
800035d2:	f0 1f 00 0a 	mcall	800035f8 <fl_read+0x84>
	}
	
}
800035d6:	2f ed       	sub	sp,-8
800035d8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800035dc:	80 00       	ld.sh	r0,r0[0x0]
800035de:	8f b4       	st.w	r7[0x2c],r4
800035e0:	80 00       	ld.sh	r0,r0[0x0]
800035e2:	ad 30       	mul	r0,r6
800035e4:	80 00       	ld.sh	r0,r0[0x0]
800035e6:	a8 be       	st.b	r4[0x3],lr
800035e8:	00 00       	add	r0,r0
800035ea:	0d 40       	ld.w	r0,--r6
800035ec:	80 00       	ld.sh	r0,r0[0x0]
800035ee:	93 08       	st.w	r9[0x0],r8
800035f0:	80 00       	ld.sh	r0,r0[0x0]
800035f2:	8f 8c       	st.w	r7[0x20],r12
800035f4:	80 01       	ld.sh	r1,r0[0x0]
800035f6:	09 e8       	ld.ub	r8,r4[0x6]
800035f8:	80 00       	ld.sh	r0,r0[0x0]
800035fa:	9e f8       	ld.uh	r8,pc[0xe]

800035fc <fl_write>:
	}
}


void fl_write(void * path, S32 offset, void * buffer, U32 length)
{
800035fc:	eb cd 40 f8 	pushm	r3-r7,lr
80003600:	20 2d       	sub	sp,8
80003602:	18 95       	mov	r5,r12
80003604:	16 94       	mov	r4,r11
80003606:	14 93       	mov	r3,r10
80003608:	12 96       	mov	r6,r9
	
	fl_write_t * fl_write_ptr = pvPortMalloc(sizeof(fl_write_t));
8000360a:	34 cc       	mov	r12,76
8000360c:	f0 1f 00 16 	mcall	80003664 <fl_write+0x68>
80003610:	18 97       	mov	r7,r12
	
	sprintf(fl_write_ptr->path, "%s", path);
80003612:	0a 9b       	mov	r11,r5
80003614:	f0 1f 00 15 	mcall	80003668 <fl_write+0x6c>
	fl_write_ptr->offset = offset;
80003618:	ef 44 00 40 	st.w	r7[64],r4
	fl_write_ptr->length = length;	
8000361c:	ef 46 00 44 	st.w	r7[68],r6
	
	fl_write_ptr->buffer = pvPortMalloc(length);
80003620:	0c 9c       	mov	r12,r6
80003622:	f0 1f 00 11 	mcall	80003664 <fl_write+0x68>
80003626:	ef 4c 00 48 	st.w	r7[72],r12
	memcpy(fl_write_ptr->buffer, buffer, length);
8000362a:	0c 9a       	mov	r10,r6
8000362c:	06 9b       	mov	r11,r3
8000362e:	f0 1f 00 10 	mcall	8000366c <fl_write+0x70>
	
	fl_oper_t fl_oper;
	
	fl_oper.opcode = FL_WRITE;
80003632:	e0 68 40 00 	mov	r8,16384
80003636:	ba 08       	st.h	sp[0x0],r8
	fl_oper.payload = fl_write_ptr;
80003638:	50 17       	stdsp	sp[0x4],r7
	
	if(pdTRUE != xQueueSend( fl_oper_queue, &fl_oper, 0 ))
8000363a:	48 e8       	lddpc	r8,80003670 <fl_write+0x74>
8000363c:	70 0c       	ld.w	r12,r8[0x0]
8000363e:	30 09       	mov	r9,0
80003640:	12 9a       	mov	r10,r9
80003642:	1a 9b       	mov	r11,sp
80003644:	f0 1f 00 0c 	mcall	80003674 <fl_write+0x78>
80003648:	58 1c       	cp.w	r12,1
8000364a:	c0 a0       	breq	8000365e <fl_write+0x62>
	{
		vPortFree(fl_write_ptr->buffer);
8000364c:	6f 2c       	ld.w	r12,r7[0x48]
8000364e:	f0 1f 00 0b 	mcall	80003678 <fl_write+0x7c>
		vPortFree(fl_write_ptr);
80003652:	0e 9c       	mov	r12,r7
80003654:	f0 1f 00 09 	mcall	80003678 <fl_write+0x7c>
		log("\n\r Wmm \n\r");//man...SPI_PBA
80003658:	48 9c       	lddpc	r12,8000367c <fl_write+0x80>
8000365a:	f0 1f 00 0a 	mcall	80003680 <fl_write+0x84>
	}
	
}
8000365e:	2f ed       	sub	sp,-8
80003660:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003664:	80 00       	ld.sh	r0,r0[0x0]
80003666:	8f b4       	st.w	r7[0x2c],r4
80003668:	80 00       	ld.sh	r0,r0[0x0]
8000366a:	ad 30       	mul	r0,r6
8000366c:	80 00       	ld.sh	r0,r0[0x0]
8000366e:	a8 be       	st.b	r4[0x3],lr
80003670:	00 00       	add	r0,r0
80003672:	0d 40       	ld.w	r0,--r6
80003674:	80 00       	ld.sh	r0,r0[0x0]
80003676:	93 08       	st.w	r9[0x0],r8
80003678:	80 00       	ld.sh	r0,r0[0x0]
8000367a:	8f 8c       	st.w	r7[0x20],r12
8000367c:	80 01       	ld.sh	r1,r0[0x0]
8000367e:	09 f4       	ld.ub	r4,r4[0x7]
80003680:	80 00       	ld.sh	r0,r0[0x0]
80003682:	9e f8       	ld.uh	r8,pc[0xe]

80003684 <fl_write_func>:
	f_mount(NULL, "/", 1);		
	return fs_ok;
}

fs_err_t fl_write_func(void * path, S32 offset, void * buffer, U32 length)
{	
80003684:	d4 31       	pushm	r0-r7,lr
80003686:	20 1d       	sub	sp,4
80003688:	18 97       	mov	r7,r12
8000368a:	16 96       	mov	r6,r11
8000368c:	14 94       	mov	r4,r10
8000368e:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
80003690:	30 1a       	mov	r10,1
80003692:	4c 7b       	lddpc	r11,800037ac <fl_write_func+0x128>
80003694:	4c 7c       	lddpc	r12,800037b0 <fl_write_func+0x12c>
80003696:	f0 1f 00 48 	mcall	800037b4 <fl_write_func+0x130>
8000369a:	e0 81 00 86 	brne	800037a6 <fl_write_func+0x122>
	{
		return amount_err;
	}
	
	FRESULT res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
8000369e:	0e 91       	mov	r1,r7
800036a0:	31 2a       	mov	r10,18
800036a2:	0e 9b       	mov	r11,r7
800036a4:	4c 5c       	lddpc	r12,800037b8 <fl_write_func+0x134>
800036a6:	f0 1f 00 46 	mcall	800037bc <fl_write_func+0x138>
	if(FR_NO_PATH == res)
800036aa:	58 5c       	cp.w	r12,5
800036ac:	c5 91       	brne	8000375e <fl_write_func+0xda>
	{
		if ( f_opendir(&dirs, "/") != FR_OK)
800036ae:	4c 0b       	lddpc	r11,800037ac <fl_write_func+0x128>
800036b0:	4c 4c       	lddpc	r12,800037c0 <fl_write_func+0x13c>
800036b2:	f0 1f 00 45 	mcall	800037c4 <fl_write_func+0x140>
800036b6:	c0 80       	breq	800036c6 <fl_write_func+0x42>
		{
			f_mount(NULL, "/", 1);
800036b8:	30 1a       	mov	r10,1
800036ba:	4b db       	lddpc	r11,800037ac <fl_write_func+0x128>
800036bc:	30 0c       	mov	r12,0
800036be:	f0 1f 00 3e 	mcall	800037b4 <fl_write_func+0x130>
800036c2:	30 6c       	mov	r12,6
			return fs_err;
800036c4:	c7 28       	rjmp	800037a8 <fl_write_func+0x124>
		}
		
		static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
		memcpy(path_bk, path, strlen(path));
800036c6:	0e 9c       	mov	r12,r7
800036c8:	f0 1f 00 40 	mcall	800037c8 <fl_write_func+0x144>
800036cc:	4c 03       	lddpc	r3,800037cc <fl_write_func+0x148>
800036ce:	18 9a       	mov	r10,r12
800036d0:	0e 9b       	mov	r11,r7
800036d2:	06 9c       	mov	r12,r3
800036d4:	f0 1f 00 3f 	mcall	800037d0 <fl_write_func+0x14c>
				
		char * dir = strtok(path_bk,"/");
800036d8:	4b 57       	lddpc	r7,800037ac <fl_write_func+0x128>
800036da:	0e 9b       	mov	r11,r7
800036dc:	06 9c       	mov	r12,r3
800036de:	f0 1f 00 3e 	mcall	800037d4 <fl_write_func+0x150>
		sprintf(filename,"//%s", dir);		
800036e2:	1a dc       	st.w	--sp,r12
800036e4:	4b db       	lddpc	r11,800037d8 <fl_write_func+0x154>
800036e6:	4b ec       	lddpc	r12,800037dc <fl_write_func+0x158>
800036e8:	f0 1f 00 3e 	mcall	800037e0 <fl_write_func+0x15c>
		dir = strtok(NULL,"/");
800036ec:	0e 9b       	mov	r11,r7
800036ee:	30 0c       	mov	r12,0
800036f0:	f0 1f 00 39 	mcall	800037d4 <fl_write_func+0x150>
800036f4:	18 97       	mov	r7,r12
		while(TRUE)
		{
			if(NULL != dir)
800036f6:	2f fd       	sub	sp,-4
800036f8:	58 0c       	cp.w	r12,0
800036fa:	c2 50       	breq	80003744 <fl_write_func+0xc0>
			{				
				res = f_mkdir(filename);
800036fc:	4b 83       	lddpc	r3,800037dc <fl_write_func+0x158>
				if((res == FR_OK) || (res == FR_EXIST))
800036fe:	30 02       	mov	r2,0
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003700:	4b 90       	lddpc	r0,800037e4 <fl_write_func+0x160>
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
			{				
				res = f_mkdir(filename);
80003702:	06 9c       	mov	r12,r3
80003704:	f0 1f 00 39 	mcall	800037e8 <fl_write_func+0x164>
				if((res == FR_OK) || (res == FR_EXIST))
80003708:	5f 09       	sreq	r9
8000370a:	58 8c       	cp.w	r12,8
8000370c:	5f 08       	sreq	r8
8000370e:	f3 e8 10 08 	or	r8,r9,r8
80003712:	e4 08 18 00 	cp.b	r8,r2
80003716:	c1 00       	breq	80003736 <fl_write_func+0xb2>
				{					
					sprintf(filename,"%s//%s", filename, dir);
80003718:	1a d7       	st.w	--sp,r7
8000371a:	1a d3       	st.w	--sp,r3
8000371c:	00 9b       	mov	r11,r0
8000371e:	06 9c       	mov	r12,r3
80003720:	f0 1f 00 30 	mcall	800037e0 <fl_write_func+0x15c>
					dir = strtok(NULL,"/");					
80003724:	4a 2b       	lddpc	r11,800037ac <fl_write_func+0x128>
80003726:	30 0c       	mov	r12,0
80003728:	f0 1f 00 2b 	mcall	800037d4 <fl_write_func+0x150>
8000372c:	18 97       	mov	r7,r12
		char * dir = strtok(path_bk,"/");
		sprintf(filename,"//%s", dir);		
		dir = strtok(NULL,"/");
		while(TRUE)
		{
			if(NULL != dir)
8000372e:	2f ed       	sub	sp,-8
80003730:	58 0c       	cp.w	r12,0
80003732:	ce 81       	brne	80003702 <fl_write_func+0x7e>
80003734:	c0 88       	rjmp	80003744 <fl_write_func+0xc0>
					sprintf(filename,"%s//%s", filename, dir);
					dir = strtok(NULL,"/");					
				}
				else
				{
					f_mount(NULL, "/", 1);	
80003736:	30 1a       	mov	r10,1
80003738:	49 db       	lddpc	r11,800037ac <fl_write_func+0x128>
8000373a:	30 0c       	mov	r12,0
8000373c:	f0 1f 00 1e 	mcall	800037b4 <fl_write_func+0x130>
80003740:	30 4c       	mov	r12,4
					return new_dir_err;
80003742:	c3 38       	rjmp	800037a8 <fl_write_func+0x124>
				}
				
			}
			else
			{
				res	= f_open (&fl, path, FA_WRITE | FA_OPEN_ALWAYS);
80003744:	31 2a       	mov	r10,18
80003746:	02 9b       	mov	r11,r1
80003748:	49 cc       	lddpc	r12,800037b8 <fl_write_func+0x134>
8000374a:	f0 1f 00 1d 	mcall	800037bc <fl_write_func+0x138>
				if(res != FR_OK)
8000374e:	c1 10       	breq	80003770 <fl_write_func+0xec>
				{					
					f_mount(NULL, "/", 1);	
80003750:	30 1a       	mov	r10,1
80003752:	49 7b       	lddpc	r11,800037ac <fl_write_func+0x128>
80003754:	30 0c       	mov	r12,0
80003756:	f0 1f 00 18 	mcall	800037b4 <fl_write_func+0x130>
8000375a:	30 3c       	mov	r12,3
					return open_fl_err;
8000375c:	c2 68       	rjmp	800037a8 <fl_write_func+0x124>
				}
				break;
			}
		}
	}
	else if(res != FR_OK)
8000375e:	58 0c       	cp.w	r12,0
80003760:	c0 80       	breq	80003770 <fl_write_func+0xec>
	{
		f_mount(NULL, "/", 1);
80003762:	30 1a       	mov	r10,1
80003764:	49 2b       	lddpc	r11,800037ac <fl_write_func+0x128>
80003766:	30 0c       	mov	r12,0
80003768:	f0 1f 00 13 	mcall	800037b4 <fl_write_func+0x130>
8000376c:	30 3c       	mov	r12,3
		return open_fl_err;
8000376e:	c1 d8       	rjmp	800037a8 <fl_write_func+0x124>
	}
	
	if(offset == FILE_END)
80003770:	5b f6       	cp.w	r6,-1
80003772:	c0 61       	brne	8000377e <fl_write_func+0xfa>
	{
		f_lseek(&fl, fl.fsize);
80003774:	49 1c       	lddpc	r12,800037b8 <fl_write_func+0x134>
80003776:	78 3b       	ld.w	r11,r12[0xc]
80003778:	f0 1f 00 1d 	mcall	800037ec <fl_write_func+0x168>
8000377c:	c0 58       	rjmp	80003786 <fl_write_func+0x102>
	}
	else
	{
		f_lseek(&fl, offset);
8000377e:	0c 9b       	mov	r11,r6
80003780:	48 ec       	lddpc	r12,800037b8 <fl_write_func+0x134>
80003782:	f0 1f 00 1b 	mcall	800037ec <fl_write_func+0x168>
	}
	
	UINT w;
	f_write (&fl, buffer, length, &w );
80003786:	48 d7       	lddpc	r7,800037b8 <fl_write_func+0x134>
80003788:	1a 99       	mov	r9,sp
8000378a:	0a 9a       	mov	r10,r5
8000378c:	08 9b       	mov	r11,r4
8000378e:	0e 9c       	mov	r12,r7
80003790:	f0 1f 00 18 	mcall	800037f0 <fl_write_func+0x16c>

	f_close (&fl);
80003794:	0e 9c       	mov	r12,r7
80003796:	f0 1f 00 18 	mcall	800037f4 <fl_write_func+0x170>
		
	f_mount(NULL, "/", 1);	
8000379a:	30 1a       	mov	r10,1
8000379c:	48 4b       	lddpc	r11,800037ac <fl_write_func+0x128>
8000379e:	30 0c       	mov	r12,0
800037a0:	f0 1f 00 05 	mcall	800037b4 <fl_write_func+0x130>
800037a4:	c0 28       	rjmp	800037a8 <fl_write_func+0x124>
}
800037a6:	30 2c       	mov	r12,2
800037a8:	2f fd       	sub	sp,-4
800037aa:	d8 32       	popm	r0-r7,pc
800037ac:	80 01       	ld.sh	r1,r0[0x0]
800037ae:	09 e4       	ld.ub	r4,r4[0x6]
800037b0:	00 00       	add	r0,r0
800037b2:	0a b0       	st.h	r5++,r0
800037b4:	80 00       	ld.sh	r0,r0[0x0]
800037b6:	73 80       	ld.w	r0,r9[0x60]
800037b8:	00 00       	add	r0,r0
800037ba:	0d c8       	ld.ub	r8,r6[0x4]
800037bc:	80 00       	ld.sh	r0,r0[0x0]
800037be:	83 4c       	st.w	r1[0x10],r12
800037c0:	00 00       	add	r0,r0
800037c2:	0c e0       	st.h	--r6,r0
800037c4:	80 00       	ld.sh	r0,r0[0x0]
800037c6:	81 10       	st.w	r0[0x4],r0
800037c8:	80 00       	ld.sh	r0,r0[0x0]
800037ca:	ad 42       	asr	r2,0xc
800037cc:	00 00       	add	r0,r0
800037ce:	0d 44       	ld.w	r4,--r6
800037d0:	80 00       	ld.sh	r0,r0[0x0]
800037d2:	a8 be       	st.b	r4[0x3],lr
800037d4:	80 00       	ld.sh	r0,r0[0x0]
800037d6:	ad 78       	lsl	r8,0xd
800037d8:	80 01       	ld.sh	r1,r0[0x0]
800037da:	0a 00       	add	r0,r5
800037dc:	00 00       	add	r0,r0
800037de:	0d 88       	ld.ub	r8,r6[0x0]
800037e0:	80 00       	ld.sh	r0,r0[0x0]
800037e2:	ac f4       	st.b	r6[0x7],r4
800037e4:	80 01       	ld.sh	r1,r0[0x0]
800037e6:	0a 08       	add	r8,r5
800037e8:	80 00       	ld.sh	r0,r0[0x0]
800037ea:	81 94       	st.w	r0[0x24],r4
800037ec:	80 00       	ld.sh	r0,r0[0x0]
800037ee:	85 ec       	st.w	r2[0x38],r12
800037f0:	80 00       	ld.sh	r0,r0[0x0]
800037f2:	88 a0       	ld.uh	r0,r4[0x4]
800037f4:	80 00       	ld.sh	r0,r0[0x0]
800037f6:	74 cc       	ld.w	r12,r10[0x30]

800037f8 <fl_read_func>:



fs_err_t fl_read_func(void * path, S32 offset, void * buffer, U32 length)
{
800037f8:	d4 31       	pushm	r0-r7,lr
800037fa:	20 1d       	sub	sp,4
800037fc:	18 97       	mov	r7,r12
800037fe:	16 96       	mov	r6,r11
80003800:	14 94       	mov	r4,r10
80003802:	12 95       	mov	r5,r9
	if(f_mount(&fs, "/", 1) != FR_OK)
80003804:	30 1a       	mov	r10,1
80003806:	4c 7b       	lddpc	r11,80003920 <fl_read_func+0x128>
80003808:	4c 7c       	lddpc	r12,80003924 <fl_read_func+0x12c>
8000380a:	f0 1f 00 48 	mcall	80003928 <fl_read_func+0x130>
8000380e:	e0 81 00 86 	brne	8000391a <fl_read_func+0x122>
		{
			return amount_err;
		}
	
		FRESULT res	= f_open (&fl, path, FA_READ | FA_OPEN_EXISTING);
80003812:	0e 91       	mov	r1,r7
80003814:	30 1a       	mov	r10,1
80003816:	0e 9b       	mov	r11,r7
80003818:	4c 5c       	lddpc	r12,8000392c <fl_read_func+0x134>
8000381a:	f0 1f 00 46 	mcall	80003930 <fl_read_func+0x138>
		if(FR_NO_PATH == res)
8000381e:	58 5c       	cp.w	r12,5
80003820:	c5 91       	brne	800038d2 <fl_read_func+0xda>
		{
			if ( f_opendir(&dirs, "/") != FR_OK)
80003822:	4c 0b       	lddpc	r11,80003920 <fl_read_func+0x128>
80003824:	4c 4c       	lddpc	r12,80003934 <fl_read_func+0x13c>
80003826:	f0 1f 00 45 	mcall	80003938 <fl_read_func+0x140>
8000382a:	c0 80       	breq	8000383a <fl_read_func+0x42>
			{
				f_mount(NULL, "/", 1);
8000382c:	30 1a       	mov	r10,1
8000382e:	4b db       	lddpc	r11,80003920 <fl_read_func+0x128>
80003830:	30 0c       	mov	r12,0
80003832:	f0 1f 00 3e 	mcall	80003928 <fl_read_func+0x130>
80003836:	30 6c       	mov	r12,6
				return fs_err;
80003838:	c7 28       	rjmp	8000391c <fl_read_func+0x124>
			}
		
			static char filename[MAX_PATH_LENGTH], path_bk[MAX_PATH_LENGTH];		
			memcpy(path_bk, path, strlen(path));
8000383a:	0e 9c       	mov	r12,r7
8000383c:	f0 1f 00 40 	mcall	8000393c <fl_read_func+0x144>
80003840:	4c 03       	lddpc	r3,80003940 <fl_read_func+0x148>
80003842:	18 9a       	mov	r10,r12
80003844:	0e 9b       	mov	r11,r7
80003846:	06 9c       	mov	r12,r3
80003848:	f0 1f 00 3f 	mcall	80003944 <fl_read_func+0x14c>
				
			char * dir = strtok(path_bk,"/");
8000384c:	4b 57       	lddpc	r7,80003920 <fl_read_func+0x128>
8000384e:	0e 9b       	mov	r11,r7
80003850:	06 9c       	mov	r12,r3
80003852:	f0 1f 00 3e 	mcall	80003948 <fl_read_func+0x150>
			sprintf(filename,"//%s", dir);		
80003856:	1a dc       	st.w	--sp,r12
80003858:	4b db       	lddpc	r11,8000394c <fl_read_func+0x154>
8000385a:	4b ec       	lddpc	r12,80003950 <fl_read_func+0x158>
8000385c:	f0 1f 00 3e 	mcall	80003954 <fl_read_func+0x15c>
			dir = strtok(NULL,"/");
80003860:	0e 9b       	mov	r11,r7
80003862:	30 0c       	mov	r12,0
80003864:	f0 1f 00 39 	mcall	80003948 <fl_read_func+0x150>
80003868:	18 97       	mov	r7,r12
			while(TRUE)
			{
				if(NULL != dir)
8000386a:	2f fd       	sub	sp,-4
8000386c:	58 0c       	cp.w	r12,0
8000386e:	c2 50       	breq	800038b8 <fl_read_func+0xc0>
				{				
					res = f_mkdir(filename);
80003870:	4b 83       	lddpc	r3,80003950 <fl_read_func+0x158>
					if((res == FR_OK) || (res == FR_EXIST))
80003872:	30 02       	mov	r2,0
					{					
						sprintf(filename,"%s//%s", filename, dir);
80003874:	4b 90       	lddpc	r0,80003958 <fl_read_func+0x160>
			dir = strtok(NULL,"/");
			while(TRUE)
			{
				if(NULL != dir)
				{				
					res = f_mkdir(filename);
80003876:	06 9c       	mov	r12,r3
80003878:	f0 1f 00 39 	mcall	8000395c <fl_read_func+0x164>
					if((res == FR_OK) || (res == FR_EXIST))
8000387c:	5f 09       	sreq	r9
8000387e:	58 8c       	cp.w	r12,8
80003880:	5f 08       	sreq	r8
80003882:	f3 e8 10 08 	or	r8,r9,r8
80003886:	e4 08 18 00 	cp.b	r8,r2
8000388a:	c1 00       	breq	800038aa <fl_read_func+0xb2>
					{					
						sprintf(filename,"%s//%s", filename, dir);
8000388c:	1a d7       	st.w	--sp,r7
8000388e:	1a d3       	st.w	--sp,r3
80003890:	00 9b       	mov	r11,r0
80003892:	06 9c       	mov	r12,r3
80003894:	f0 1f 00 30 	mcall	80003954 <fl_read_func+0x15c>
						dir = strtok(NULL,"/");					
80003898:	4a 2b       	lddpc	r11,80003920 <fl_read_func+0x128>
8000389a:	30 0c       	mov	r12,0
8000389c:	f0 1f 00 2b 	mcall	80003948 <fl_read_func+0x150>
800038a0:	18 97       	mov	r7,r12
			char * dir = strtok(path_bk,"/");
			sprintf(filename,"//%s", dir);		
			dir = strtok(NULL,"/");
			while(TRUE)
			{
				if(NULL != dir)
800038a2:	2f ed       	sub	sp,-8
800038a4:	58 0c       	cp.w	r12,0
800038a6:	ce 81       	brne	80003876 <fl_read_func+0x7e>
800038a8:	c0 88       	rjmp	800038b8 <fl_read_func+0xc0>
						sprintf(filename,"%s//%s", filename, dir);
						dir = strtok(NULL,"/");					
					}
					else
					{
						f_mount(NULL, "/", 1);	
800038aa:	30 1a       	mov	r10,1
800038ac:	49 db       	lddpc	r11,80003920 <fl_read_func+0x128>
800038ae:	30 0c       	mov	r12,0
800038b0:	f0 1f 00 1e 	mcall	80003928 <fl_read_func+0x130>
800038b4:	30 4c       	mov	r12,4
						return new_dir_err;
800038b6:	c3 38       	rjmp	8000391c <fl_read_func+0x124>
					}
				
				}
				else
				{
					res	= f_open (&fl, path, FA_READ | FA_OPEN_EXISTING);
800038b8:	30 1a       	mov	r10,1
800038ba:	02 9b       	mov	r11,r1
800038bc:	49 cc       	lddpc	r12,8000392c <fl_read_func+0x134>
800038be:	f0 1f 00 1d 	mcall	80003930 <fl_read_func+0x138>
					if(res != FR_OK)
800038c2:	c1 10       	breq	800038e4 <fl_read_func+0xec>
					{					
						f_mount(NULL, "/", 1);	
800038c4:	30 1a       	mov	r10,1
800038c6:	49 7b       	lddpc	r11,80003920 <fl_read_func+0x128>
800038c8:	30 0c       	mov	r12,0
800038ca:	f0 1f 00 18 	mcall	80003928 <fl_read_func+0x130>
800038ce:	30 3c       	mov	r12,3
						return open_fl_err;
800038d0:	c2 68       	rjmp	8000391c <fl_read_func+0x124>
					}
					break;
				}
			}
		}
		else if(res != FR_OK)
800038d2:	58 0c       	cp.w	r12,0
800038d4:	c0 80       	breq	800038e4 <fl_read_func+0xec>
		{
			f_mount(NULL, "/", 1);
800038d6:	30 1a       	mov	r10,1
800038d8:	49 2b       	lddpc	r11,80003920 <fl_read_func+0x128>
800038da:	30 0c       	mov	r12,0
800038dc:	f0 1f 00 13 	mcall	80003928 <fl_read_func+0x130>
800038e0:	30 3c       	mov	r12,3
			return open_fl_err;
800038e2:	c1 d8       	rjmp	8000391c <fl_read_func+0x124>
		}
	
		if(offset == FILE_END)
800038e4:	5b f6       	cp.w	r6,-1
800038e6:	c0 61       	brne	800038f2 <fl_read_func+0xfa>
		{
			f_lseek(&fl, fl.fsize);
800038e8:	49 1c       	lddpc	r12,8000392c <fl_read_func+0x134>
800038ea:	78 3b       	ld.w	r11,r12[0xc]
800038ec:	f0 1f 00 1d 	mcall	80003960 <fl_read_func+0x168>
800038f0:	c0 58       	rjmp	800038fa <fl_read_func+0x102>
		}
		else
		{
			f_lseek(&fl, offset);
800038f2:	0c 9b       	mov	r11,r6
800038f4:	48 ec       	lddpc	r12,8000392c <fl_read_func+0x134>
800038f6:	f0 1f 00 1b 	mcall	80003960 <fl_read_func+0x168>
		}
	
		UINT w;
		f_read (&fl, buffer, length, &w );
800038fa:	48 d7       	lddpc	r7,8000392c <fl_read_func+0x134>
800038fc:	1a 99       	mov	r9,sp
800038fe:	0a 9a       	mov	r10,r5
80003900:	08 9b       	mov	r11,r4
80003902:	0e 9c       	mov	r12,r7
80003904:	f0 1f 00 18 	mcall	80003964 <fl_read_func+0x16c>

		f_close (&fl);
80003908:	0e 9c       	mov	r12,r7
8000390a:	f0 1f 00 18 	mcall	80003968 <fl_read_func+0x170>
		
		f_mount(NULL, "/", 1);		
8000390e:	30 1a       	mov	r10,1
80003910:	48 4b       	lddpc	r11,80003920 <fl_read_func+0x128>
80003912:	30 0c       	mov	r12,0
80003914:	f0 1f 00 05 	mcall	80003928 <fl_read_func+0x130>
80003918:	c0 28       	rjmp	8000391c <fl_read_func+0x124>
	
	
	
	
	
}
8000391a:	30 2c       	mov	r12,2
8000391c:	2f fd       	sub	sp,-4
8000391e:	d8 32       	popm	r0-r7,pc
80003920:	80 01       	ld.sh	r1,r0[0x0]
80003922:	09 e4       	ld.ub	r4,r4[0x6]
80003924:	00 00       	add	r0,r0
80003926:	0a b0       	st.h	r5++,r0
80003928:	80 00       	ld.sh	r0,r0[0x0]
8000392a:	73 80       	ld.w	r0,r9[0x60]
8000392c:	00 00       	add	r0,r0
8000392e:	0d c8       	ld.ub	r8,r6[0x4]
80003930:	80 00       	ld.sh	r0,r0[0x0]
80003932:	83 4c       	st.w	r1[0x10],r12
80003934:	00 00       	add	r0,r0
80003936:	0c e0       	st.h	--r6,r0
80003938:	80 00       	ld.sh	r0,r0[0x0]
8000393a:	81 10       	st.w	r0[0x4],r0
8000393c:	80 00       	ld.sh	r0,r0[0x0]
8000393e:	ad 42       	asr	r2,0xc
80003940:	00 00       	add	r0,r0
80003942:	0a 6c       	and	r12,r5
80003944:	80 00       	ld.sh	r0,r0[0x0]
80003946:	a8 be       	st.b	r4[0x3],lr
80003948:	80 00       	ld.sh	r0,r0[0x0]
8000394a:	ad 78       	lsl	r8,0xd
8000394c:	80 01       	ld.sh	r1,r0[0x0]
8000394e:	0a 00       	add	r0,r5
80003950:	00 00       	add	r0,r0
80003952:	0d 00       	ld.w	r0,r6++
80003954:	80 00       	ld.sh	r0,r0[0x0]
80003956:	ac f4       	st.b	r6[0x7],r4
80003958:	80 01       	ld.sh	r1,r0[0x0]
8000395a:	0a 08       	add	r8,r5
8000395c:	80 00       	ld.sh	r0,r0[0x0]
8000395e:	81 94       	st.w	r0[0x24],r4
80003960:	80 00       	ld.sh	r0,r0[0x0]
80003962:	85 ec       	st.w	r2[0x38],r12
80003964:	80 00       	ld.sh	r0,r0[0x0]
80003966:	8a 80       	ld.uh	r0,r5[0x0]
80003968:	80 00       	ld.sh	r0,r0[0x0]
8000396a:	74 cc       	ld.w	r12,r10[0x30]

8000396c <fl_oper_process>:



static void fl_oper_process(void * pvParameters)
{
8000396c:	eb cd 40 fc 	pushm	r2-r7,lr
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
80003970:	30 8c       	mov	r12,8
80003972:	f0 1f 00 23 	mcall	800039fc <fl_oper_process+0x90>
80003976:	18 97       	mov	r7,r12
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
80003978:	4a 26       	lddpc	r6,80003a00 <fl_oper_process+0x94>
8000397a:	30 05       	mov	r5,0
8000397c:	3f f4       	mov	r4,-1
		{  
			switch(fl_oper->opcode)
8000397e:	e0 63 40 00 	mov	r3,16384
80003982:	e0 62 40 01 	mov	r2,16385
static void fl_oper_process(void * pvParameters)
{
	fl_oper_t * fl_oper = pvPortMalloc(sizeof(fl_oper_t));
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( fl_oper_queue, fl_oper, portMAX_DELAY ))
80003986:	6c 0c       	ld.w	r12,r6[0x0]
80003988:	0a 99       	mov	r9,r5
8000398a:	08 9a       	mov	r10,r4
8000398c:	0e 9b       	mov	r11,r7
8000398e:	f0 1f 00 1e 	mcall	80003a04 <fl_oper_process+0x98>
80003992:	58 1c       	cp.w	r12,1
80003994:	cf 91       	brne	80003986 <fl_oper_process+0x1a>
		{  
			switch(fl_oper->opcode)
80003996:	8e 08       	ld.sh	r8,r7[0x0]
80003998:	e6 08 19 00 	cp.h	r8,r3
8000399c:	c0 50       	breq	800039a6 <fl_oper_process+0x3a>
8000399e:	e4 08 19 00 	cp.h	r8,r2
800039a2:	c2 61       	brne	800039ee <fl_oper_process+0x82>
800039a4:	c1 38       	rjmp	800039ca <fl_oper_process+0x5e>
			{
			case FL_WRITE:
			
				if(NULL != fl_oper->payload)
800039a6:	6e 1c       	ld.w	r12,r7[0x4]
800039a8:	58 0c       	cp.w	r12,0
800039aa:	ce e0       	breq	80003986 <fl_oper_process+0x1a>
				{
					if(NULL != ((fl_write_t *)(fl_oper->payload))->buffer)
800039ac:	79 2a       	ld.w	r10,r12[0x48]
800039ae:	58 0a       	cp.w	r10,0
800039b0:	c0 90       	breq	800039c2 <fl_oper_process+0x56>
					{
						fl_write_func(((fl_write_t *)(fl_oper->payload))->path
800039b2:	79 19       	ld.w	r9,r12[0x44]
800039b4:	79 0b       	ld.w	r11,r12[0x40]
800039b6:	f0 1f 00 15 	mcall	80003a08 <fl_oper_process+0x9c>
							, ((fl_write_t *)(fl_oper->payload))->offset
							, ((fl_write_t *)(fl_oper->payload))->buffer
							, ((fl_write_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_write_t *)(fl_oper->payload))->buffer);
800039ba:	6e 18       	ld.w	r8,r7[0x4]
800039bc:	71 2c       	ld.w	r12,r8[0x48]
800039be:	f0 1f 00 14 	mcall	80003a0c <fl_oper_process+0xa0>
					}
					vPortFree(fl_oper->payload);					
800039c2:	6e 1c       	ld.w	r12,r7[0x4]
800039c4:	f0 1f 00 12 	mcall	80003a0c <fl_oper_process+0xa0>
800039c8:	cd fb       	rjmp	80003986 <fl_oper_process+0x1a>
				}
				break;
				
			case FL_READ:
			
				if(NULL != fl_oper->payload)
800039ca:	6e 1c       	ld.w	r12,r7[0x4]
800039cc:	58 0c       	cp.w	r12,0
800039ce:	cd c0       	breq	80003986 <fl_oper_process+0x1a>
				{
					if(NULL != ((fl_read_t *)(fl_oper->payload))->buffer)
800039d0:	79 2a       	ld.w	r10,r12[0x48]
800039d2:	58 0a       	cp.w	r10,0
800039d4:	c0 90       	breq	800039e6 <fl_oper_process+0x7a>
					{
						fl_read_func(((fl_read_t *)(fl_oper->payload))->path
800039d6:	79 19       	ld.w	r9,r12[0x44]
800039d8:	79 0b       	ld.w	r11,r12[0x40]
800039da:	f0 1f 00 0e 	mcall	80003a10 <fl_oper_process+0xa4>
						, ((fl_read_t *)(fl_oper->payload))->offset
						, ((fl_read_t *)(fl_oper->payload))->buffer
						, ((fl_read_t *)(fl_oper->payload))->length);
						
						vPortFree(((fl_read_t *)(fl_oper->payload))->buffer);
800039de:	6e 18       	ld.w	r8,r7[0x4]
800039e0:	71 2c       	ld.w	r12,r8[0x48]
800039e2:	f0 1f 00 0b 	mcall	80003a0c <fl_oper_process+0xa0>
					}
					vPortFree(fl_oper->payload);
800039e6:	6e 1c       	ld.w	r12,r7[0x4]
800039e8:	f0 1f 00 09 	mcall	80003a0c <fl_oper_process+0xa0>
800039ec:	cc db       	rjmp	80003986 <fl_oper_process+0x1a>
				break;
			
			   
								
			default:
				if(NULL != fl_oper->payload)
800039ee:	6e 1c       	ld.w	r12,r7[0x4]
800039f0:	58 0c       	cp.w	r12,0
800039f2:	cc a0       	breq	80003986 <fl_oper_process+0x1a>
				{
					vPortFree(fl_oper->payload);
800039f4:	f0 1f 00 06 	mcall	80003a0c <fl_oper_process+0xa0>
800039f8:	cc 7b       	rjmp	80003986 <fl_oper_process+0x1a>
800039fa:	00 00       	add	r0,r0
800039fc:	80 00       	ld.sh	r0,r0[0x0]
800039fe:	8f b4       	st.w	r7[0x2c],r4
80003a00:	00 00       	add	r0,r0
80003a02:	0d 40       	ld.w	r0,--r6
80003a04:	80 00       	ld.sh	r0,r0[0x0]
80003a06:	90 fc       	ld.uh	r12,r8[0xe]
80003a08:	80 00       	ld.sh	r0,r0[0x0]
80003a0a:	36 84       	mov	r4,104
80003a0c:	80 00       	ld.sh	r0,r0[0x0]
80003a0e:	8f 8c       	st.w	r7[0x20],r12
80003a10:	80 00       	ld.sh	r0,r0[0x0]
80003a12:	37 f8       	mov	r8,127

80003a14 <disk_init>:
APP_RES_OKDISK_OPERATION_ERRORSDFILE_OPERATION_ERROR
*/
//

fs_err_t disk_init(void)
{
80003a14:	d4 01       	pushm	lr
80003a16:	20 3d       	sub	sp,12
	char str[MAX_DISK_LABEL_SIZE];
	
	/*initialize disk*/
	if(MAL_InitConfig())
80003a18:	f0 1f 00 41 	mcall	80003b1c <disk_init+0x108>
80003a1c:	5c 8c       	casts.h	r12
80003a1e:	c0 30       	breq	80003a24 <disk_init+0x10>
80003a20:	30 1c       	mov	r12,1
80003a22:	c7 a8       	rjmp	80003b16 <disk_init+0x102>
	{
		return disk_err;
	}	
		
	if(f_mount(&fs, "/", 1) != FR_OK)
80003a24:	30 1a       	mov	r10,1
80003a26:	4b fb       	lddpc	r11,80003b20 <disk_init+0x10c>
80003a28:	4b fc       	lddpc	r12,80003b24 <disk_init+0x110>
80003a2a:	f0 1f 00 40 	mcall	80003b28 <disk_init+0x114>
80003a2e:	c0 30       	breq	80003a34 <disk_init+0x20>
80003a30:	30 2c       	mov	r12,2
80003a32:	c7 28       	rjmp	80003b16 <disk_init+0x102>
	{
		return amount_err;
	}
	
	FRESULT res = f_getfree("/", &clust, &pfs);
80003a34:	4b ea       	lddpc	r10,80003b2c <disk_init+0x118>
80003a36:	4b fb       	lddpc	r11,80003b30 <disk_init+0x11c>
80003a38:	4b ac       	lddpc	r12,80003b20 <disk_init+0x10c>
80003a3a:	f0 1f 00 3f 	mcall	80003b34 <disk_init+0x120>
	if(res == FR_NO_FILESYSTEM) 
80003a3e:	58 dc       	cp.w	r12,13
80003a40:	c1 41       	brne	80003a68 <disk_init+0x54>
	{
		/* Create a file system on the drive */
		res = f_mkfs (0, 0, 4096);
80003a42:	e0 6a 10 00 	mov	r10,4096
80003a46:	30 0b       	mov	r11,0
80003a48:	16 9c       	mov	r12,r11
80003a4a:	f0 1f 00 3c 	mcall	80003b38 <disk_init+0x124>
		if( f_getfree("/", &clust, &pfs) != FR_OK)
80003a4e:	4b 8a       	lddpc	r10,80003b2c <disk_init+0x118>
80003a50:	4b 8b       	lddpc	r11,80003b30 <disk_init+0x11c>
80003a52:	4b 4c       	lddpc	r12,80003b20 <disk_init+0x10c>
80003a54:	f0 1f 00 38 	mcall	80003b34 <disk_init+0x120>
80003a58:	c1 10       	breq	80003a7a <disk_init+0x66>
		{
			f_mount(NULL, "/", 1);	
80003a5a:	30 1a       	mov	r10,1
80003a5c:	4b 1b       	lddpc	r11,80003b20 <disk_init+0x10c>
80003a5e:	30 0c       	mov	r12,0
80003a60:	f0 1f 00 32 	mcall	80003b28 <disk_init+0x114>
80003a64:	30 5c       	mov	r12,5
			return no_fs;
80003a66:	c5 88       	rjmp	80003b16 <disk_init+0x102>
		}
	}
	else if(res != FR_OK)
80003a68:	58 0c       	cp.w	r12,0
80003a6a:	c0 80       	breq	80003a7a <disk_init+0x66>
	{
		f_mount(NULL, "/", 1);
80003a6c:	30 1a       	mov	r10,1
80003a6e:	4a db       	lddpc	r11,80003b20 <disk_init+0x10c>
80003a70:	30 0c       	mov	r12,0
80003a72:	f0 1f 00 2e 	mcall	80003b28 <disk_init+0x114>
80003a76:	30 6c       	mov	r12,6
		return fs_err;
80003a78:	c4 f8       	rjmp	80003b16 <disk_init+0x102>
	}
	
	
	//pdisk->freecap = ((clust*(pfs->csize)/1024/1024)*512);
	
	memset(str,0,MAX_DISK_LABEL_SIZE);
80003a7a:	1a 9b       	mov	r11,sp
80003a7c:	30 08       	mov	r8,0
80003a7e:	30 09       	mov	r9,0
80003a80:	fa e9 00 00 	st.d	sp[0],r8
80003a84:	30 0a       	mov	r10,0
80003a86:	50 2a       	stdsp	sp[0x8],r10
	if(f_getlabel("/", str, 0) != FR_OK)
80003a88:	4a 6c       	lddpc	r12,80003b20 <disk_init+0x10c>
80003a8a:	f0 1f 00 2d 	mcall	80003b3c <disk_init+0x128>
80003a8e:	c0 80       	breq	80003a9e <disk_init+0x8a>
	{
		f_mount(NULL, "/", 1);
80003a90:	30 1a       	mov	r10,1
80003a92:	4a 4b       	lddpc	r11,80003b20 <disk_init+0x10c>
80003a94:	30 0c       	mov	r12,0
80003a96:	f0 1f 00 25 	mcall	80003b28 <disk_init+0x114>
80003a9a:	30 6c       	mov	r12,6
		return fs_err;
80003a9c:	c3 d8       	rjmp	80003b16 <disk_init+0x102>
	}
		
	if(memcmp(DiskLabel, str, sizeof(DiskLabel) - 1) != 0)
80003a9e:	30 7a       	mov	r10,7
80003aa0:	1a 9b       	mov	r11,sp
80003aa2:	4a 8c       	lddpc	r12,80003b40 <disk_init+0x12c>
80003aa4:	f0 1f 00 28 	mcall	80003b44 <disk_init+0x130>
80003aa8:	c0 c0       	breq	80003ac0 <disk_init+0xac>
	{
		if(f_setlabel("MOTOREC") != FR_OK)
80003aaa:	4a 8c       	lddpc	r12,80003b48 <disk_init+0x134>
80003aac:	f0 1f 00 28 	mcall	80003b4c <disk_init+0x138>
80003ab0:	c0 80       	breq	80003ac0 <disk_init+0xac>
		{
			f_mount(NULL, "/", 1);
80003ab2:	30 1a       	mov	r10,1
80003ab4:	49 bb       	lddpc	r11,80003b20 <disk_init+0x10c>
80003ab6:	30 0c       	mov	r12,0
80003ab8:	f0 1f 00 1c 	mcall	80003b28 <disk_init+0x114>
80003abc:	30 6c       	mov	r12,6
			return fs_err;
80003abe:	c2 c8       	rjmp	80003b16 <disk_init+0x102>
		}
	}
			
	if ( f_opendir(&dirs, "/") == FR_OK)
80003ac0:	49 8b       	lddpc	r11,80003b20 <disk_init+0x10c>
80003ac2:	4a 4c       	lddpc	r12,80003b50 <disk_init+0x13c>
80003ac4:	f0 1f 00 24 	mcall	80003b54 <disk_init+0x140>
80003ac8:	c2 11       	brne	80003b0a <disk_init+0xf6>
	{
		if(f_open(&fl, "sys.ini", FA_CREATE_ALWAYS | FA_WRITE) == FR_OK )
80003aca:	30 aa       	mov	r10,10
80003acc:	4a 3b       	lddpc	r11,80003b58 <disk_init+0x144>
80003ace:	4a 4c       	lddpc	r12,80003b5c <disk_init+0x148>
80003ad0:	f0 1f 00 24 	mcall	80003b60 <disk_init+0x14c>
80003ad4:	c1 41       	brne	80003afc <disk_init+0xe8>
		{
			f_close(&fl);
80003ad6:	4a 2c       	lddpc	r12,80003b5c <disk_init+0x148>
80003ad8:	f0 1f 00 23 	mcall	80003b64 <disk_init+0x150>
		{
			f_mount(NULL, "/", 1);
			return fs_err;
		}
				
		f_mkdir("/REC");			
80003adc:	4a 3c       	lddpc	r12,80003b68 <disk_init+0x154>
80003ade:	f0 1f 00 24 	mcall	80003b6c <disk_init+0x158>
		f_mkdir("/REC/ZONE01");			
80003ae2:	4a 4c       	lddpc	r12,80003b70 <disk_init+0x15c>
80003ae4:	f0 1f 00 22 	mcall	80003b6c <disk_init+0x158>
		f_mkdir("/REC/ZONE01/CH01");		
80003ae8:	4a 3c       	lddpc	r12,80003b74 <disk_init+0x160>
80003aea:	f0 1f 00 21 	mcall	80003b6c <disk_init+0x158>
	{
		f_mount(NULL, "/", 1);
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
80003aee:	30 1a       	mov	r10,1
80003af0:	48 cb       	lddpc	r11,80003b20 <disk_init+0x10c>
80003af2:	30 0c       	mov	r12,0
80003af4:	f0 1f 00 0d 	mcall	80003b28 <disk_init+0x114>
80003af8:	30 0c       	mov	r12,0
	return fs_ok;
80003afa:	c0 e8       	rjmp	80003b16 <disk_init+0x102>
		{
			f_close(&fl);
		}
		else 
		{
			f_mount(NULL, "/", 1);
80003afc:	30 1a       	mov	r10,1
80003afe:	48 9b       	lddpc	r11,80003b20 <disk_init+0x10c>
80003b00:	30 0c       	mov	r12,0
80003b02:	f0 1f 00 0a 	mcall	80003b28 <disk_init+0x114>
80003b06:	30 6c       	mov	r12,6
			return fs_err;
80003b08:	c0 78       	rjmp	80003b16 <disk_init+0x102>
		f_mkdir("/REC/ZONE01");			
		f_mkdir("/REC/ZONE01/CH01");		
	}
	else 
	{
		f_mount(NULL, "/", 1);
80003b0a:	30 1a       	mov	r10,1
80003b0c:	48 5b       	lddpc	r11,80003b20 <disk_init+0x10c>
80003b0e:	30 0c       	mov	r12,0
80003b10:	f0 1f 00 06 	mcall	80003b28 <disk_init+0x114>
80003b14:	30 6c       	mov	r12,6
		return fs_err;
	}
	
	f_mount(NULL, "/", 1);		
	return fs_ok;
}
80003b16:	2f dd       	sub	sp,-12
80003b18:	d8 02       	popm	pc
80003b1a:	00 00       	add	r0,r0
80003b1c:	80 00       	ld.sh	r0,r0[0x0]
80003b1e:	35 50       	mov	r0,85
80003b20:	80 01       	ld.sh	r1,r0[0x0]
80003b22:	09 e4       	ld.ub	r4,r4[0x6]
80003b24:	00 00       	add	r0,r0
80003b26:	0a b0       	st.h	r5++,r0
80003b28:	80 00       	ld.sh	r0,r0[0x0]
80003b2a:	73 80       	ld.w	r0,r9[0x60]
80003b2c:	00 00       	add	r0,r0
80003b2e:	0d 84       	ld.ub	r4,r6[0x0]
80003b30:	00 00       	add	r0,r0
80003b32:	0a ac       	st.w	r5++,r12
80003b34:	80 00       	ld.sh	r0,r0[0x0]
80003b36:	85 00       	st.w	r2[0x0],r0
80003b38:	80 00       	ld.sh	r0,r0[0x0]
80003b3a:	68 44       	ld.w	r4,r4[0x10]
80003b3c:	80 00       	ld.sh	r0,r0[0x0]
80003b3e:	7a 7c       	ld.w	r12,sp[0x1c]
80003b40:	00 00       	add	r0,r0
80003b42:	04 f4       	st.b	--r2,r4
80003b44:	80 00       	ld.sh	r0,r0[0x0]
80003b46:	a8 98       	st.b	r4[0x1],r8
80003b48:	80 01       	ld.sh	r1,r0[0x0]
80003b4a:	0a 10       	sub	r0,r5
80003b4c:	80 00       	ld.sh	r0,r0[0x0]
80003b4e:	7b c8       	ld.w	r8,sp[0x70]
80003b50:	00 00       	add	r0,r0
80003b52:	0c e0       	st.h	--r6,r0
80003b54:	80 00       	ld.sh	r0,r0[0x0]
80003b56:	81 10       	st.w	r0[0x4],r0
80003b58:	80 01       	ld.sh	r1,r0[0x0]
80003b5a:	0a 18       	sub	r8,r5
80003b5c:	00 00       	add	r0,r0
80003b5e:	0d c8       	ld.ub	r8,r6[0x4]
80003b60:	80 00       	ld.sh	r0,r0[0x0]
80003b62:	83 4c       	st.w	r1[0x10],r12
80003b64:	80 00       	ld.sh	r0,r0[0x0]
80003b66:	74 cc       	ld.w	r12,r10[0x30]
80003b68:	80 01       	ld.sh	r1,r0[0x0]
80003b6a:	0a 20       	rsub	r0,r5
80003b6c:	80 00       	ld.sh	r0,r0[0x0]
80003b6e:	81 94       	st.w	r0[0x24],r4
80003b70:	80 01       	ld.sh	r1,r0[0x0]
80003b72:	0a 28       	rsub	r8,r5
80003b74:	80 01       	ld.sh	r1,r0[0x0]
80003b76:	0a 34       	cp.w	r4,r5

80003b78 <fs_init>:
}



fs_err_t fs_init(void)
{
80003b78:	eb cd 40 80 	pushm	r7,lr
	fs_err_t res = disk_init();
80003b7c:	f0 1f 00 0d 	mcall	80003bb0 <fs_init+0x38>
80003b80:	18 97       	mov	r7,r12
	if( fs_ok ==  res)
80003b82:	c1 31       	brne	80003ba8 <fs_init+0x30>
	{
		fl_oper_queue = xQueueCreate(20, sizeof(fl_oper_t)); //20*512bytes = 10k
80003b84:	30 8b       	mov	r11,8
80003b86:	31 4c       	mov	r12,20
80003b88:	f0 1f 00 0b 	mcall	80003bb4 <fs_init+0x3c>
80003b8c:	48 b8       	lddpc	r8,80003bb8 <fs_init+0x40>
80003b8e:	91 0c       	st.w	r8[0x0],r12
		
		/*create a task for files operation*/
		xTaskCreate(
80003b90:	30 09       	mov	r9,0
80003b92:	1a d9       	st.w	--sp,r9
80003b94:	1a d9       	st.w	--sp,r9
80003b96:	1a d9       	st.w	--sp,r9
80003b98:	30 28       	mov	r8,2
80003b9a:	e0 6a 02 00 	mov	r10,512
80003b9e:	48 8b       	lddpc	r11,80003bbc <fs_init+0x44>
80003ba0:	48 8c       	lddpc	r12,80003bc0 <fs_init+0x48>
80003ba2:	f0 1f 00 09 	mcall	80003bc4 <fs_init+0x4c>
		,  NULL
		,  2//1
		,  NULL
		);		
		
		return fs_ok;		
80003ba6:	2f dd       	sub	sp,-12
	}
	else
	{
		return res;
	}
}
80003ba8:	0e 9c       	mov	r12,r7
80003baa:	e3 cd 80 80 	ldm	sp++,r7,pc
80003bae:	00 00       	add	r0,r0
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	3a 14       	mov	r4,-95
80003bb4:	80 00       	ld.sh	r0,r0[0x0]
80003bb6:	94 60       	ld.sh	r0,r10[0xc]
80003bb8:	00 00       	add	r0,r0
80003bba:	0d 40       	ld.w	r0,--r6
80003bbc:	80 01       	ld.sh	r1,r0[0x0]
80003bbe:	0a 48       	or	r8,r5
80003bc0:	80 00       	ld.sh	r0,r0[0x0]
80003bc2:	39 6c       	mov	r12,-106
80003bc4:	80 00       	ld.sh	r0,r0[0x0]
80003bc6:	9b 34       	st.w	sp[0xc],r4

80003bc8 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80003bc8:	20 1c       	sub	r12,1
80003bca:	5c 5c       	castu.b	r12
80003bcc:	31 18       	mov	r8,17
80003bce:	f0 0c 18 00 	cp.b	r12,r8
80003bd2:	e0 88 00 03 	brls	80003bd8 <CalculateBurst+0x10>
80003bd6:	5e fd       	retal	0
80003bd8:	48 28       	lddpc	r8,80003be0 <CalculateBurst+0x18>
80003bda:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80003bde:	5e fc       	retal	r12
80003be0:	80 01       	ld.sh	r1,r0[0x0]
80003be2:	0a 58       	eor	r8,r5

80003be4 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80003be4:	eb cd 40 80 	pushm	r7,lr
	payload_rx_exec = payload_rx_func;
80003be8:	48 f8       	lddpc	r8,80003c24 <payload_init+0x40>
80003bea:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80003bec:	48 f8       	lddpc	r8,80003c28 <payload_init+0x44>
80003bee:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003bf0:	30 07       	mov	r7,0
80003bf2:	1a d7       	st.w	--sp,r7
80003bf4:	1a d7       	st.w	--sp,r7
80003bf6:	1a d7       	st.w	--sp,r7
80003bf8:	30 28       	mov	r8,2
80003bfa:	0e 99       	mov	r9,r7
80003bfc:	e0 6a 04 00 	mov	r10,1024
80003c00:	48 bb       	lddpc	r11,80003c2c <payload_init+0x48>
80003c02:	48 cc       	lddpc	r12,80003c30 <payload_init+0x4c>
80003c04:	f0 1f 00 0c 	mcall	80003c34 <payload_init+0x50>
	,  2
	,  NULL
	);
	
	/*this task is used to transmit  payload message*/
	xTaskCreate(
80003c08:	1a d7       	st.w	--sp,r7
80003c0a:	1a d7       	st.w	--sp,r7
80003c0c:	1a d7       	st.w	--sp,r7
80003c0e:	30 28       	mov	r8,2
80003c10:	0e 99       	mov	r9,r7
80003c12:	e0 6a 04 00 	mov	r10,1024
80003c16:	48 9b       	lddpc	r11,80003c38 <payload_init+0x54>
80003c18:	48 9c       	lddpc	r12,80003c3c <payload_init+0x58>
80003c1a:	f0 1f 00 07 	mcall	80003c34 <payload_init+0x50>
80003c1e:	2f ad       	sub	sp,-24
	,  2
	,  NULL
	);
	
	
}
80003c20:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c24:	00 00       	add	r0,r0
80003c26:	0f f0       	ld.ub	r0,r7[0x7]
80003c28:	00 00       	add	r0,r0
80003c2a:	0f f4       	ld.ub	r4,r7[0x7]
80003c2c:	80 01       	ld.sh	r1,r0[0x0]
80003c2e:	10 50       	eor	r0,r8
80003c30:	80 00       	ld.sh	r0,r0[0x0]
80003c32:	3c 8c       	mov	r12,-56
80003c34:	80 00       	ld.sh	r0,r0[0x0]
80003c36:	9b 34       	st.w	sp[0xc],r4
80003c38:	80 01       	ld.sh	r1,r0[0x0]
80003c3a:	10 5c       	eor	r12,r8
80003c3c:	80 00       	ld.sh	r0,r0[0x0]
80003c3e:	3c 40       	mov	r0,-60

80003c40 <payload_tx_process>:
Description: Transmit the payload
Calls:
Called By:task
*/
static void payload_tx_process(void * pvParameters)
{
80003c40:	eb cd 40 f8 	pushm	r3-r7,lr
80003c44:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
	
	if(NULL == phy_payload_frame_tx)
80003c46:	48 e8       	lddpc	r8,80003c7c <payload_tx_process+0x3c>
80003c48:	70 08       	ld.w	r8,r8[0x0]
80003c4a:	58 08       	cp.w	r8,0
80003c4c:	c0 71       	brne	80003c5a <payload_tx_process+0x1a>
	{
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003c4e:	30 4b       	mov	r11,4
80003c50:	30 5c       	mov	r12,5
80003c52:	f0 1f 00 0c 	mcall	80003c80 <payload_tx_process+0x40>
80003c56:	48 a8       	lddpc	r8,80003c7c <payload_tx_process+0x3c>
80003c58:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_tx, &payload_ptr,portMAX_DELAY ))
80003c5a:	48 96       	lddpc	r6,80003c7c <payload_tx_process+0x3c>
80003c5c:	30 05       	mov	r5,0
80003c5e:	3f f4       	mov	r4,-1
		{
			payload_tx_exec(payload_ptr);//app_payload_tx_proc();
80003c60:	48 93       	lddpc	r3,80003c84 <payload_tx_process+0x44>
		phy_payload_frame_tx = xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_tx, &payload_ptr,portMAX_DELAY ))
80003c62:	6c 0c       	ld.w	r12,r6[0x0]
80003c64:	0a 99       	mov	r9,r5
80003c66:	08 9a       	mov	r10,r4
80003c68:	1a 9b       	mov	r11,sp
80003c6a:	f0 1f 00 08 	mcall	80003c88 <payload_tx_process+0x48>
80003c6e:	58 1c       	cp.w	r12,1
80003c70:	cf 91       	brne	80003c62 <payload_tx_process+0x22>
		{
			payload_tx_exec(payload_ptr);//app_payload_tx_proc();
80003c72:	66 08       	ld.w	r8,r3[0x0]
80003c74:	40 0c       	lddsp	r12,sp[0x0]
80003c76:	5d 18       	icall	r8
80003c78:	cf 5b       	rjmp	80003c62 <payload_tx_process+0x22>
80003c7a:	00 00       	add	r0,r0
80003c7c:	00 00       	add	r0,r0
80003c7e:	10 58       	eor	r8,r8
80003c80:	80 00       	ld.sh	r0,r0[0x0]
80003c82:	94 60       	ld.sh	r0,r10[0xc]
80003c84:	00 00       	add	r0,r0
80003c86:	0f f4       	ld.ub	r4,r7[0x7]
80003c88:	80 00       	ld.sh	r0,r0[0x0]
80003c8a:	90 fc       	ld.uh	r12,r8[0xe]

80003c8c <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80003c8c:	eb cd 40 f8 	pushm	r3-r7,lr
80003c90:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80003c92:	48 e8       	lddpc	r8,80003cc8 <payload_rx_process+0x3c>
80003c94:	70 08       	ld.w	r8,r8[0x0]
80003c96:	58 08       	cp.w	r8,0
80003c98:	c0 71       	brne	80003ca6 <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003c9a:	30 4b       	mov	r11,4
80003c9c:	30 5c       	mov	r12,5
80003c9e:	f0 1f 00 0c 	mcall	80003ccc <payload_rx_process+0x40>
80003ca2:	48 a8       	lddpc	r8,80003cc8 <payload_rx_process+0x3c>
80003ca4:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003ca6:	48 96       	lddpc	r6,80003cc8 <payload_rx_process+0x3c>
80003ca8:	30 05       	mov	r5,0
80003caa:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003cac:	48 93       	lddpc	r3,80003cd0 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80003cae:	6c 0c       	ld.w	r12,r6[0x0]
80003cb0:	0a 99       	mov	r9,r5
80003cb2:	08 9a       	mov	r10,r4
80003cb4:	1a 9b       	mov	r11,sp
80003cb6:	f0 1f 00 08 	mcall	80003cd4 <payload_rx_process+0x48>
80003cba:	58 1c       	cp.w	r12,1
80003cbc:	cf 91       	brne	80003cae <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80003cbe:	66 08       	ld.w	r8,r3[0x0]
80003cc0:	40 0c       	lddsp	r12,sp[0x0]
80003cc2:	5d 18       	icall	r8
80003cc4:	cf 5b       	rjmp	80003cae <payload_rx_process+0x22>
80003cc6:	00 00       	add	r0,r0
80003cc8:	00 00       	add	r0,r0
80003cca:	10 08       	add	r8,r8
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	94 60       	ld.sh	r0,r10[0xc]
80003cd0:	00 00       	add	r0,r0
80003cd2:	0f f0       	ld.ub	r0,r7[0x7]
80003cd4:	80 00       	ld.sh	r0,r0[0x0]
80003cd6:	90 fc       	ld.uh	r12,r8[0xe]

80003cd8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80003cd8:	d4 01       	pushm	lr
80003cda:	20 2d       	sub	sp,8
80003cdc:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003cde:	30 09       	mov	r9,0
80003ce0:	fa ca ff f8 	sub	r10,sp,-8
80003ce4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80003ce6:	1a 9b       	mov	r11,sp
80003ce8:	f0 1f 00 02 	mcall	80003cf0 <set_idle_store_isr+0x18>
}
80003cec:	2f ed       	sub	sp,-8
80003cee:	d8 02       	popm	pc
80003cf0:	80 00       	ld.sh	r0,r0[0x0]
80003cf2:	92 b8       	ld.uh	r8,r9[0x6]

80003cf4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80003cf4:	d4 01       	pushm	lr
80003cf6:	20 2d       	sub	sp,8
80003cf8:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80003cfa:	58 0c       	cp.w	r12,0
80003cfc:	c1 10       	breq	80003d1e <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003cfe:	30 08       	mov	r8,0
80003d00:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80003d02:	98 88       	ld.uh	r8,r12[0x0]
80003d04:	e2 18 f0 00 	andl	r8,0xf000,COH
80003d08:	e0 48 40 00 	cp.w	r8,16384
80003d0c:	c0 91       	brne	80003d1e <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80003d0e:	48 68       	lddpc	r8,80003d24 <phy_rx+0x30>
80003d10:	70 0c       	ld.w	r12,r8[0x0]
80003d12:	30 09       	mov	r9,0
80003d14:	fa ca ff fc 	sub	r10,sp,-4
80003d18:	1a 9b       	mov	r11,sp
80003d1a:	f0 1f 00 04 	mcall	80003d28 <phy_rx+0x34>
		}	

    }
		
 
}
80003d1e:	2f ed       	sub	sp,-8
80003d20:	d8 02       	popm	pc
80003d22:	00 00       	add	r0,r0
80003d24:	00 00       	add	r0,r0
80003d26:	10 4c       	or	r12,r8
80003d28:	80 00       	ld.sh	r0,r0[0x0]
80003d2a:	92 b8       	ld.uh	r8,r9[0x6]

80003d2c <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80003d2c:	eb cd 40 80 	pushm	r7,lr
80003d30:	20 1d       	sub	sp,4
80003d32:	fa c7 ff fc 	sub	r7,sp,-4
80003d36:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80003d38:	30 09       	mov	r9,0
80003d3a:	12 9a       	mov	r10,r9
80003d3c:	1a 9b       	mov	r11,sp
80003d3e:	f0 1f 00 03 	mcall	80003d48 <set_idle_store+0x1c>
}
80003d42:	2f fd       	sub	sp,-4
80003d44:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d48:	80 00       	ld.sh	r0,r0[0x0]
80003d4a:	93 08       	st.w	r9[0x0],r8

80003d4c <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80003d4c:	d4 01       	pushm	lr
80003d4e:	20 1d       	sub	sp,4
80003d50:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80003d52:	98 88       	ld.uh	r8,r12[0x0]
80003d54:	e2 18 f0 00 	andl	r8,0xf000,COH
80003d58:	e0 48 40 00 	cp.w	r8,16384
80003d5c:	c0 d1       	brne	80003d76 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80003d5e:	49 08       	lddpc	r8,80003d9c <phy_tx+0x50>
80003d60:	70 08       	ld.w	r8,r8[0x0]
80003d62:	58 08       	cp.w	r8,0
80003d64:	c1 a0       	breq	80003d98 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80003d66:	48 e8       	lddpc	r8,80003d9c <phy_tx+0x50>
80003d68:	70 0c       	ld.w	r12,r8[0x0]
80003d6a:	30 09       	mov	r9,0
80003d6c:	12 9a       	mov	r10,r9
80003d6e:	1a 9b       	mov	r11,sp
80003d70:	f0 1f 00 0c 	mcall	80003da0 <phy_tx+0x54>
80003d74:	c1 28       	rjmp	80003d98 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80003d76:	e0 48 10 00 	cp.w	r8,4096
80003d7a:	5f 0a       	sreq	r10
80003d7c:	e0 48 20 00 	cp.w	r8,8192
80003d80:	5f 09       	sreq	r9
80003d82:	f5 e9 10 09 	or	r9,r10,r9
80003d86:	c0 71       	brne	80003d94 <phy_tx+0x48>
80003d88:	e0 48 50 00 	cp.w	r8,20480
80003d8c:	c0 40       	breq	80003d94 <phy_tx+0x48>
80003d8e:	e0 48 60 00 	cp.w	r8,24576
80003d92:	c0 31       	brne	80003d98 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80003d94:	48 48       	lddpc	r8,80003da4 <phy_tx+0x58>
80003d96:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80003d98:	2f fd       	sub	sp,-4
80003d9a:	d8 02       	popm	pc
80003d9c:	00 00       	add	r0,r0
80003d9e:	10 68       	and	r8,r8
80003da0:	80 00       	ld.sh	r0,r0[0x0]
80003da2:	93 08       	st.w	r9[0x0],r8
80003da4:	00 00       	add	r0,r0
80003da6:	10 58       	eor	r8,r8

80003da8 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80003da8:	d4 01       	pushm	lr
80003daa:	20 2d       	sub	sp,8
	void * ptr = NULL;
80003dac:	30 08       	mov	r8,0
80003dae:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003db0:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80003db2:	1a 9a       	mov	r10,sp
80003db4:	fa cb ff fc 	sub	r11,sp,-4
80003db8:	f0 1f 00 05 	mcall	80003dcc <get_idle_store_isr+0x24>
80003dbc:	58 1c       	cp.w	r12,1
80003dbe:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80003dc2:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80003dc6:	2f ed       	sub	sp,-8
80003dc8:	d8 02       	popm	pc
80003dca:	00 00       	add	r0,r0
80003dcc:	80 00       	ld.sh	r0,r0[0x0]
80003dce:	90 0c       	ld.sh	r12,r8[0x0]

80003dd0 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80003dd0:	eb cd 40 c0 	pushm	r6-r7,lr
80003dd4:	20 1d       	sub	sp,4
80003dd6:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80003dd8:	fe f8 05 10 	ld.w	r8,pc[1296]
80003ddc:	70 08       	ld.w	r8,r8[0x0]
80003dde:	58 08       	cp.w	r8,0
80003de0:	c7 40       	breq	80003ec8 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80003de2:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003de4:	30 08       	mov	r8,0
80003de6:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80003de8:	fe f8 05 04 	ld.w	r8,pc[1284]
80003dec:	70 08       	ld.w	r8,r8[0x0]
80003dee:	58 18       	cp.w	r8,1
80003df0:	c2 90       	breq	80003e42 <phy_tx_func+0x72>
80003df2:	c0 43       	brcs	80003dfa <phy_tx_func+0x2a>
80003df4:	58 28       	cp.w	r8,2
80003df6:	c6 91       	brne	80003ec8 <phy_tx_func+0xf8>
80003df8:	c6 18       	rjmp	80003eba <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80003dfa:	fe f8 04 ee 	ld.w	r8,pc[1262]
80003dfe:	70 0c       	ld.w	r12,r8[0x0]
80003e00:	1a 9a       	mov	r10,sp
80003e02:	fe fb 04 ee 	ld.w	r11,pc[1262]
80003e06:	f0 1f 01 3c 	mcall	800042f4 <phy_tx_func+0x524>
80003e0a:	58 1c       	cp.w	r12,1
80003e0c:	c1 51       	brne	80003e36 <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80003e0e:	fe f8 04 e2 	ld.w	r8,pc[1250]
80003e12:	70 08       	ld.w	r8,r8[0x0]
80003e14:	11 9a       	ld.ub	r10,r8[0x1]
80003e16:	fe f9 04 e2 	ld.w	r9,pc[1250]
80003e1a:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003e1c:	90 88       	ld.uh	r8,r8[0x0]
80003e1e:	ea 18 ab cd 	orh	r8,0xabcd
80003e22:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80003e24:	30 19       	mov	r9,1
80003e26:	fe f8 04 d6 	ld.w	r8,pc[1238]
80003e2a:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003e2c:	30 19       	mov	r9,1
80003e2e:	fe f8 04 be 	ld.w	r8,pc[1214]
80003e32:	91 09       	st.w	r8[0x0],r9
80003e34:	c4 a8       	rjmp	80003ec8 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003e36:	e0 68 5a 5a 	mov	r8,23130
80003e3a:	ea 18 ab cd 	orh	r8,0xabcd
80003e3e:	8f 18       	st.w	r7[0x4],r8
80003e40:	c4 48       	rjmp	80003ec8 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003e42:	fe f9 04 ba 	ld.w	r9,pc[1210]
80003e46:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003e48:	fe fa 04 a8 	ld.w	r10,pc[1192]
80003e4c:	74 0a       	ld.w	r10,r10[0x0]
80003e4e:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003e52:	b1 6a       	lsl	r10,0x10
80003e54:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003e56:	2f f8       	sub	r8,-1
80003e58:	5c 58       	castu.b	r8
80003e5a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003e5c:	fe fa 04 9c 	ld.w	r10,pc[1180]
80003e60:	94 09       	ld.sh	r9,r10[0x0]
80003e62:	20 29       	sub	r9,2
80003e64:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003e66:	30 0a       	mov	r10,0
80003e68:	f4 09 19 00 	cp.h	r9,r10
80003e6c:	e0 89 00 0b 	brgt	80003e82 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003e70:	78 18       	ld.w	r8,r12[0x4]
80003e72:	e8 18 00 ba 	orl	r8,0xba
80003e76:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80003e78:	30 09       	mov	r9,0
80003e7a:	fe f8 04 72 	ld.w	r8,pc[1138]
80003e7e:	91 09       	st.w	r8[0x0],r9
80003e80:	c2 48       	rjmp	80003ec8 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003e82:	fe f9 04 6e 	ld.w	r9,pc[1134]
80003e86:	72 09       	ld.w	r9,r9[0x0]
80003e88:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003e8c:	78 1a       	ld.w	r10,r12[0x4]
80003e8e:	f5 e9 10 09 	or	r9,r10,r9
80003e92:	99 19       	st.w	r12[0x4],r9
80003e94:	2f f8       	sub	r8,-1
80003e96:	fe f9 04 66 	ld.w	r9,pc[1126]
80003e9a:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003e9c:	fe f9 04 5c 	ld.w	r9,pc[1116]
80003ea0:	92 08       	ld.sh	r8,r9[0x0]
80003ea2:	20 28       	sub	r8,2
80003ea4:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003ea6:	30 09       	mov	r9,0
80003ea8:	f2 08 19 00 	cp.h	r8,r9
80003eac:	e0 89 00 0e 	brgt	80003ec8 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003eb0:	30 29       	mov	r9,2
80003eb2:	fe f8 04 3a 	ld.w	r8,pc[1082]
80003eb6:	91 09       	st.w	r8[0x0],r9
80003eb8:	c0 88       	rjmp	80003ec8 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80003eba:	fc 18 00 ba 	movh	r8,0xba
80003ebe:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003ec0:	30 09       	mov	r9,0
80003ec2:	fe f8 04 2a 	ld.w	r8,pc[1066]
80003ec6:	91 09       	st.w	r8[0x0],r9
	static U32 i = 0;
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if (AMBE_flag)
80003ec8:	fe f8 04 38 	ld.w	r8,pc[1080]
80003ecc:	11 89       	ld.ub	r9,r8[0x0]
80003ece:	30 08       	mov	r8,0
80003ed0:	f0 09 18 00 	cp.b	r9,r8
80003ed4:	e0 80 00 a4 	breq	8000401c <phy_tx_func+0x24c>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80003ed8:	fe f8 04 2c 	ld.w	r8,pc[1068]
80003edc:	70 08       	ld.w	r8,r8[0x0]
80003ede:	e0 48 05 b0 	cp.w	r8,1456
80003ee2:	f9 b8 02 00 	movhs	r8,0
80003ee6:	fe f9 04 1e 	ld.w	r9,pc[1054]
80003eea:	93 08       	st.w	r9[0x0],r8

	  //AMBE_flag
		switch(payload_tx_state)
80003eec:	fe f9 04 1c 	ld.w	r9,pc[1052]
80003ef0:	13 89       	ld.ub	r9,r9[0x0]
80003ef2:	30 1a       	mov	r10,1
80003ef4:	f4 09 18 00 	cp.b	r9,r10
80003ef8:	c3 e0       	breq	80003f74 <phy_tx_func+0x1a4>
80003efa:	c0 73       	brcs	80003f08 <phy_tx_func+0x138>
80003efc:	30 2a       	mov	r10,2
80003efe:	f4 09 18 00 	cp.b	r9,r10
80003f02:	e0 81 00 81 	brne	80004004 <phy_tx_func+0x234>
80003f06:	c6 98       	rjmp	80003fd8 <phy_tx_func+0x208>
		{
			case 0:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80003f08:	fe f8 04 04 	ld.w	r8,pc[1028]
80003f0c:	70 08       	ld.w	r8,r8[0x0]
80003f0e:	58 08       	cp.w	r8,0
80003f10:	c0 b0       	breq	80003f26 <phy_tx_func+0x156>
80003f12:	fe f8 03 fa 	ld.w	r8,pc[1018]
80003f16:	70 08       	ld.w	r8,r8[0x0]
80003f18:	58 98       	cp.w	r8,9
80003f1a:	c0 60       	breq	80003f26 <phy_tx_func+0x156>
80003f1c:	fe f8 03 f0 	ld.w	r8,pc[1008]
80003f20:	70 08       	ld.w	r8,r8[0x0]
80003f22:	58 18       	cp.w	r8,1
80003f24:	c0 a1       	brne	80003f38 <phy_tx_func+0x168>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80003f26:	e0 68 5a 5a 	mov	r8,23130
80003f2a:	ea 18 ab cd 	orh	r8,0xabcd
80003f2e:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80003f30:	30 08       	mov	r8,0
80003f32:	8f 38       	st.w	r7[0xc],r8
80003f34:	e0 8f 01 d6 	bral	800042e0 <phy_tx_func+0x510>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80003f38:	fe f8 03 d4 	ld.w	r8,pc[980]
80003f3c:	70 08       	ld.w	r8,r8[0x0]
80003f3e:	58 28       	cp.w	r8,2
80003f40:	c0 91       	brne	80003f52 <phy_tx_func+0x182>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80003f42:	fe f8 03 ce 	ld.w	r8,pc[974]
80003f46:	70 09       	ld.w	r9,r8[0x0]
80003f48:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80003f4a:	70 18       	ld.w	r8,r8[0x4]
80003f4c:	8f 38       	st.w	r7[0xc],r8
80003f4e:	e0 8f 01 c9 	bral	800042e0 <phy_tx_func+0x510>
				}
				else
				{
					payload_tx_state = 1;
80003f52:	30 19       	mov	r9,1
80003f54:	fe f8 03 b4 	ld.w	r8,pc[948]
80003f58:	b0 89       	st.b	r8[0x0],r9
					
					//0xABCDCOOE
					payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80003f5a:	e0 68 c0 0e 	mov	r8,49166
80003f5e:	ea 18 ab cd 	orh	r8,0xabcd
80003f62:	8f 28       	st.w	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[2] = VBSP_data[0];
80003f64:	fe f8 03 b0 	ld.w	r8,pc[944]
80003f68:	90 09       	ld.sh	r9,r8[0x0]
80003f6a:	ae 69       	st.h	r7[0xc],r9
					//0xF00x
					payload_tx_channel->word[3] = VBSP_data[1];
80003f6c:	90 18       	ld.sh	r8,r8[0x2]
80003f6e:	ae 78       	st.h	r7[0xe],r8
80003f70:	e0 8f 01 b8 	bral	800042e0 <phy_tx_func+0x510>
				break;
			
			case 1:
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80003f74:	fe 78 88 f2 	mov	r8,-30478
80003f78:	ae 48       	st.h	r7[0x8],r8
				
				payload_tx_channel->word[1] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80003f7a:	fe f8 03 8a 	ld.w	r8,pc[906]
80003f7e:	70 0a       	ld.w	r10,r8[0x0]
80003f80:	fe f9 03 98 	ld.w	r9,pc[920]
80003f84:	f2 0a 00 0b 	add	r11,r9,r10
80003f88:	17 9b       	ld.ub	r11,r11[0x1]
80003f8a:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80003f8e:	a9 6a       	lsl	r10,0x8
80003f90:	f6 0a 00 0a 	add	r10,r11,r10
80003f94:	ae 5a       	st.h	r7[0xa],r10
				A_index+=2;
80003f96:	70 0a       	ld.w	r10,r8[0x0]
80003f98:	2f ea       	sub	r10,-2
80003f9a:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[2] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80003f9c:	f2 0a 00 0b 	add	r11,r9,r10
80003fa0:	17 9b       	ld.ub	r11,r11[0x1]
80003fa2:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80003fa6:	a9 6a       	lsl	r10,0x8
80003fa8:	f6 0a 00 0a 	add	r10,r11,r10
80003fac:	ae 6a       	st.h	r7[0xc],r10
				A_index+=2;
80003fae:	70 0a       	ld.w	r10,r8[0x0]
80003fb0:	2f ea       	sub	r10,-2
80003fb2:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[3] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80003fb4:	f2 0a 00 0b 	add	r11,r9,r10
80003fb8:	17 9b       	ld.ub	r11,r11[0x1]
80003fba:	f2 0a 07 09 	ld.ub	r9,r9[r10]
80003fbe:	a9 69       	lsl	r9,0x8
80003fc0:	f6 09 00 09 	add	r9,r11,r9
80003fc4:	ae 79       	st.h	r7[0xe],r9
				A_index+=2;
80003fc6:	70 09       	ld.w	r9,r8[0x0]
80003fc8:	2f e9       	sub	r9,-2
80003fca:	91 09       	st.w	r8[0x0],r9
				
				payload_tx_state = 2;
80003fcc:	30 29       	mov	r9,2
80003fce:	fe f8 03 3a 	ld.w	r8,pc[826]
80003fd2:	b0 89       	st.b	r8[0x0],r9
80003fd4:	e0 8f 01 86 	bral	800042e0 <phy_tx_func+0x510>
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
					
					}
					
					***/
					payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//Pad_bits
80003fd8:	fe f9 03 40 	ld.w	r9,pc[832]
80003fdc:	f2 08 07 08 	ld.ub	r8,r9[r8]
80003fe0:	a9 68       	lsl	r8,0x8
80003fe2:	ae 48       	st.h	r7[0x8],r8
					A_index+=1;
80003fe4:	fe f8 03 20 	ld.w	r8,pc[800]
80003fe8:	70 09       	ld.w	r9,r8[0x0]
80003fea:	2f f9       	sub	r9,-1
80003fec:	91 09       	st.w	r8[0x0],r9
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80003fee:	e0 68 00 ba 	mov	r8,186
80003ff2:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80003ff4:	30 08       	mov	r8,0
80003ff6:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80003ff8:	ae 78       	st.h	r7[0xe],r8
				
					payload_tx_state = 0;
80003ffa:	fe f9 03 0e 	ld.w	r9,pc[782]
80003ffe:	b2 88       	st.b	r9[0x0],r8
80004000:	e0 8f 01 70 	bral	800042e0 <phy_tx_func+0x510>
				
				break;
				
			default:
			
				payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004004:	e0 68 5a 5a 	mov	r8,23130
80004008:	ea 18 ab cd 	orh	r8,0xabcd
8000400c:	8f 28       	st.w	r7[0x8],r8
				payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000400e:	30 08       	mov	r8,0
80004010:	8f 38       	st.w	r7[0xc],r8
				
				payload_tx_state = 0;
80004012:	fe f9 02 f6 	ld.w	r9,pc[758]
80004016:	b2 88       	st.b	r9[0x0],r8
80004018:	e0 8f 01 64 	bral	800042e0 <phy_tx_func+0x510>

#if 1
else//Send-PCM-data40bytes/2.5ms.
{
	
	index = (index >=30240) ? 0 : index;
8000401c:	fe f8 03 00 	ld.w	r8,pc[768]
80004020:	70 08       	ld.w	r8,r8[0x0]
80004022:	e0 48 76 20 	cp.w	r8,30240
80004026:	f9 b8 02 00 	movhs	r8,0
8000402a:	fe f9 02 f2 	ld.w	r9,pc[754]
8000402e:	93 08       	st.w	r9[0x0],r8
	
	if(is_unmute == 1)counter++;
80004030:	fe f8 02 f0 	ld.w	r8,pc[752]
80004034:	11 89       	ld.ub	r9,r8[0x0]
80004036:	30 18       	mov	r8,1
80004038:	f0 09 18 00 	cp.b	r9,r8
8000403c:	c0 61       	brne	80004048 <phy_tx_func+0x278>
8000403e:	fe f8 02 e6 	ld.w	r8,pc[742]
80004042:	70 09       	ld.w	r9,r8[0x0]
80004044:	2f f9       	sub	r9,-1
80004046:	91 09       	st.w	r8[0x0],r9
	
	switch(payload_tx_state)
80004048:	fe f8 02 c0 	ld.w	r8,pc[704]
8000404c:	11 88       	ld.ub	r8,r8[0x0]
8000404e:	30 19       	mov	r9,1
80004050:	f2 08 18 00 	cp.b	r8,r9
80004054:	c3 60       	breq	800040c0 <phy_tx_func+0x2f0>
80004056:	c0 73       	brcs	80004064 <phy_tx_func+0x294>
80004058:	30 29       	mov	r9,2
8000405a:	f2 08 18 00 	cp.b	r8,r9
8000405e:	e0 81 01 3e 	brne	800042da <phy_tx_func+0x50a>
80004062:	c7 c8       	rjmp	8000415a <phy_tx_func+0x38a>
	{
		case 0:
		
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004064:	e0 68 5a 5a 	mov	r8,23130
80004068:	ea 18 ab cd 	orh	r8,0xabcd
8000406c:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
8000406e:	30 08       	mov	r8,0
80004070:	8f 38       	st.w	r7[0xc],r8
		
			if(((counter % 20 )== 0) && (counter != 0) &&(is_unmute == 1))//20*125us = 2.5ms.
80004072:	fe f8 02 b2 	ld.w	r8,pc[690]
80004076:	70 08       	ld.w	r8,r8[0x0]
80004078:	e0 6b cc cd 	mov	r11,52429
8000407c:	ea 1b cc cc 	orh	r11,0xcccc
80004080:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80004084:	f6 09 16 04 	lsr	r9,r11,0x4
80004088:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000408c:	f0 09 01 29 	sub	r9,r8,r9<<0x2
80004090:	c1 21       	brne	800040b4 <phy_tx_func+0x2e4>
80004092:	58 08       	cp.w	r8,0
80004094:	c1 00       	breq	800040b4 <phy_tx_func+0x2e4>
80004096:	fe f8 02 8a 	ld.w	r8,pc[650]
8000409a:	11 89       	ld.ub	r9,r8[0x0]
8000409c:	30 18       	mov	r8,1
8000409e:	f0 09 18 00 	cp.b	r9,r8
800040a2:	c0 91       	brne	800040b4 <phy_tx_func+0x2e4>
			{
				payload_tx_state = 1;
800040a4:	10 99       	mov	r9,r8
800040a6:	fe f8 02 62 	ld.w	r8,pc[610]
800040aa:	b0 89       	st.b	r8[0x0],r9
				//payload_tx_state = 0;
				frame_number = 0;
800040ac:	30 09       	mov	r9,0
800040ae:	fe f8 02 7a 	ld.w	r8,pc[634]
800040b2:	b0 89       	st.b	r8[0x0],r9
	
			}
		
			send_num++;
800040b4:	fe f8 02 78 	ld.w	r8,pc[632]
800040b8:	70 09       	ld.w	r9,r8[0x0]
800040ba:	2f f9       	sub	r9,-1
800040bc:	91 09       	st.w	r8[0x0],r9
800040be:	c1 19       	rjmp	800042e0 <phy_tx_func+0x510>
			break;
		
		case 1:
		
	
			payload_tx_channel->word[0] = 0xABCD; 
800040c0:	fe 78 ab cd 	mov	r8,-21555
800040c4:	ae 48       	st.h	r7[0x8],r8
		
			if(frame_number == 0)
800040c6:	fe f8 02 62 	ld.w	r8,pc[610]
800040ca:	11 89       	ld.ub	r9,r8[0x0]
800040cc:	30 08       	mov	r8,0
800040ce:	f0 09 18 00 	cp.b	r9,r8
800040d2:	c1 b1       	brne	80004108 <phy_tx_func+0x338>
			{
				if (Silent_flag == 1)
800040d4:	fe f8 02 5c 	ld.w	r8,pc[604]
800040d8:	11 89       	ld.ub	r9,r8[0x0]
800040da:	30 18       	mov	r8,1
800040dc:	f0 09 18 00 	cp.b	r9,r8
800040e0:	c0 91       	brne	800040f2 <phy_tx_func+0x322>
				{
					//44betes-4bytes= 40bytes
					expexted_length = 0x2C;//One Descriptor Indicator
800040e2:	32 c9       	mov	r9,44
800040e4:	fe f8 02 50 	ld.w	r8,pc[592]
800040e8:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102C;//44betes-4bytes= 40bytes
800040ea:	e0 68 10 2c 	mov	r8,4140
800040ee:	ae 58       	st.h	r7[0xa],r8
800040f0:	c0 88       	rjmp	80004100 <phy_tx_func+0x330>
				}
				
				else
				{
					//first frame
					expexted_length = 0x2A;
800040f2:	32 a9       	mov	r9,42
800040f4:	fe f8 02 40 	ld.w	r8,pc[576]
800040f8:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x102A;//42-2= 40 bytes;	
800040fa:	e0 68 10 2a 	mov	r8,4138
800040fe:	ae 58       	st.h	r7[0xa],r8
				}
				
					last_frame = TRUE;
80004100:	30 19       	mov	r9,1
80004102:	fe f8 02 36 	ld.w	r8,pc[566]
80004106:	b0 89       	st.b	r8[0x0],r9
			//
			//
			//}
			//else//
			
			if (Silent_flag == 1)//
80004108:	fe f8 02 28 	ld.w	r8,pc[552]
8000410c:	11 89       	ld.ub	r9,r8[0x0]
8000410e:	30 18       	mov	r8,1
80004110:	f0 09 18 00 	cp.b	r9,r8
80004114:	c0 61       	brne	80004120 <phy_tx_func+0x350>
			{
			
				payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
80004116:	30 18       	mov	r8,1
80004118:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
8000411a:	30 48       	mov	r8,4
8000411c:	ae 78       	st.h	r7[0xe],r8
8000411e:	c1 38       	rjmp	80004144 <phy_tx_func+0x374>

			}
			else
			{
			
				payload_tx_channel->word[2] = 0x0000;
80004120:	30 08       	mov	r8,0
80004122:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80004124:	4f e8       	lddpc	r8,8000431c <phy_tx_func+0x54c>
80004126:	70 09       	ld.w	r9,r8[0x0]
80004128:	fe fa 02 14 	ld.w	r10,pc[532]
8000412c:	f4 09 00 0b 	add	r11,r10,r9
80004130:	17 9b       	ld.ub	r11,r11[0x1]
80004132:	f4 09 07 09 	ld.ub	r9,r10[r9]
80004136:	a9 69       	lsl	r9,0x8
80004138:	f6 09 00 09 	add	r9,r11,r9
8000413c:	ae 79       	st.h	r7[0xe],r9
				index+=2;
8000413e:	70 09       	ld.w	r9,r8[0x0]
80004140:	2f e9       	sub	r9,-2
80004142:	91 09       	st.w	r8[0x0],r9
			
			}
		
			expexted_length -= 4;
80004144:	4f c8       	lddpc	r8,80004334 <phy_tx_func+0x564>
80004146:	90 09       	ld.sh	r9,r8[0x0]
80004148:	20 49       	sub	r9,4
8000414a:	b0 09       	st.h	r8[0x0],r9
		
			//frame_number++;
			payload_tx_state = 2;
8000414c:	30 29       	mov	r9,2
8000414e:	4e f8       	lddpc	r8,80004308 <phy_tx_func+0x538>
80004150:	b0 89       	st.b	r8[0x0],r9
		
			i = 0;
80004152:	30 09       	mov	r9,0
80004154:	4f b8       	lddpc	r8,80004340 <phy_tx_func+0x570>
80004156:	91 09       	st.w	r8[0x0],r9
80004158:	cc 48       	rjmp	800042e0 <phy_tx_func+0x510>
		
			break;
		
		case 2:
		
			if(expexted_length <= 0)
8000415a:	4f 78       	lddpc	r8,80004334 <phy_tx_func+0x564>
8000415c:	90 09       	ld.sh	r9,r8[0x0]
8000415e:	30 08       	mov	r8,0
80004160:	f0 09 19 00 	cp.h	r9,r8
80004164:	e0 89 00 12 	brgt	80004188 <phy_tx_func+0x3b8>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80004168:	4f 48       	lddpc	r8,80004338 <phy_tx_func+0x568>
8000416a:	11 89       	ld.ub	r9,r8[0x0]
8000416c:	30 08       	mov	r8,0
8000416e:	f0 09 18 00 	cp.b	r9,r8
80004172:	5f 09       	sreq	r9
80004174:	4e 58       	lddpc	r8,80004308 <phy_tx_func+0x538>
80004176:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[0] = 0x00BA;
80004178:	e0 68 00 ba 	mov	r8,186
8000417c:	ae 48       	st.h	r7[0x8],r8
				payload_tx_channel->word[1] = 0x0000;
8000417e:	30 08       	mov	r8,0
80004180:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
80004182:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80004184:	ae 78       	st.h	r7[0xe],r8
80004186:	ca d8       	rjmp	800042e0 <phy_tx_func+0x510>
				break;
			}
		
			if(Silent_flag == 1)
80004188:	4e a8       	lddpc	r8,80004330 <phy_tx_func+0x560>
8000418a:	11 89       	ld.ub	r9,r8[0x0]
8000418c:	30 18       	mov	r8,1
8000418e:	f0 09 18 00 	cp.b	r9,r8
80004192:	c0 41       	brne	8000419a <phy_tx_func+0x3ca>
			{
				payload_tx_channel->word[0] =  0x0000;
80004194:	30 08       	mov	r8,0
80004196:	ae 48       	st.h	r7[0x8],r8
80004198:	c1 08       	rjmp	800041b8 <phy_tx_func+0x3e8>
			}
			else
			{
				//payload_tx_channel->word[0] = AudioData[index++] + (AudioData[index++] << 8);
				payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
8000419a:	4e 18       	lddpc	r8,8000431c <phy_tx_func+0x54c>
8000419c:	70 09       	ld.w	r9,r8[0x0]
8000419e:	4e 8a       	lddpc	r10,8000433c <phy_tx_func+0x56c>
800041a0:	f4 09 00 0b 	add	r11,r10,r9
800041a4:	17 9b       	ld.ub	r11,r11[0x1]
800041a6:	f4 09 07 09 	ld.ub	r9,r10[r9]
800041aa:	a9 69       	lsl	r9,0x8
800041ac:	f6 09 00 09 	add	r9,r11,r9
800041b0:	ae 49       	st.h	r7[0x8],r9
				index+=2;
800041b2:	70 09       	ld.w	r9,r8[0x0]
800041b4:	2f e9       	sub	r9,-2
800041b6:	91 09       	st.w	r8[0x0],r9
			
			}

			expexted_length -= 2;
800041b8:	4d f9       	lddpc	r9,80004334 <phy_tx_func+0x564>
800041ba:	92 08       	ld.sh	r8,r9[0x0]
800041bc:	20 28       	sub	r8,2
800041be:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
800041c0:	30 09       	mov	r9,0
800041c2:	f2 08 19 00 	cp.h	r8,r9
800041c6:	e0 89 00 11 	brgt	800041e8 <phy_tx_func+0x418>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
800041ca:	4d c8       	lddpc	r8,80004338 <phy_tx_func+0x568>
800041cc:	11 89       	ld.ub	r9,r8[0x0]
800041ce:	30 08       	mov	r8,0
800041d0:	f0 09 18 00 	cp.b	r9,r8
800041d4:	5f 09       	sreq	r9
800041d6:	4c d8       	lddpc	r8,80004308 <phy_tx_func+0x538>
800041d8:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[1] = 0x00BA;
800041da:	e0 68 00 ba 	mov	r8,186
800041de:	ae 58       	st.h	r7[0xa],r8
				payload_tx_channel->word[2] = 0x0000;
800041e0:	30 08       	mov	r8,0
800041e2:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
800041e4:	ae 78       	st.h	r7[0xe],r8
800041e6:	c7 d8       	rjmp	800042e0 <phy_tx_func+0x510>
				break;
			}
		
			if(Silent_flag == 1)
800041e8:	4d 28       	lddpc	r8,80004330 <phy_tx_func+0x560>
800041ea:	11 89       	ld.ub	r9,r8[0x0]
800041ec:	30 18       	mov	r8,1
800041ee:	f0 09 18 00 	cp.b	r9,r8
800041f2:	c0 41       	brne	800041fa <phy_tx_func+0x42a>
			{
				payload_tx_channel->word[1] =  0x0000;
800041f4:	30 08       	mov	r8,0
800041f6:	ae 58       	st.h	r7[0xa],r8
800041f8:	c1 08       	rjmp	80004218 <phy_tx_func+0x448>
			}
			else
			{
			
				payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800041fa:	4c 98       	lddpc	r8,8000431c <phy_tx_func+0x54c>
800041fc:	70 09       	ld.w	r9,r8[0x0]
800041fe:	4d 0a       	lddpc	r10,8000433c <phy_tx_func+0x56c>
80004200:	f4 09 00 0b 	add	r11,r10,r9
80004204:	17 9b       	ld.ub	r11,r11[0x1]
80004206:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000420a:	a9 69       	lsl	r9,0x8
8000420c:	f6 09 00 09 	add	r9,r11,r9
80004210:	ae 59       	st.h	r7[0xa],r9
				index+=2;
80004212:	70 09       	ld.w	r9,r8[0x0]
80004214:	2f e9       	sub	r9,-2
80004216:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80004218:	4c 79       	lddpc	r9,80004334 <phy_tx_func+0x564>
8000421a:	92 08       	ld.sh	r8,r9[0x0]
8000421c:	20 28       	sub	r8,2
8000421e:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
80004220:	30 09       	mov	r9,0
80004222:	f2 08 19 00 	cp.h	r8,r9
80004226:	e0 89 00 10 	brgt	80004246 <phy_tx_func+0x476>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
8000422a:	4c 48       	lddpc	r8,80004338 <phy_tx_func+0x568>
8000422c:	11 89       	ld.ub	r9,r8[0x0]
8000422e:	30 08       	mov	r8,0
80004230:	f0 09 18 00 	cp.b	r9,r8
80004234:	5f 09       	sreq	r9
80004236:	4b 58       	lddpc	r8,80004308 <phy_tx_func+0x538>
80004238:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[2] = 0x00BA;
8000423a:	e0 68 00 ba 	mov	r8,186
8000423e:	ae 68       	st.h	r7[0xc],r8
				payload_tx_channel->word[3] = 0x0000;
80004240:	30 08       	mov	r8,0
80004242:	ae 78       	st.h	r7[0xe],r8
80004244:	c4 e8       	rjmp	800042e0 <phy_tx_func+0x510>
				break;
			}
		
			if(Silent_flag == 1)
80004246:	4b b8       	lddpc	r8,80004330 <phy_tx_func+0x560>
80004248:	11 89       	ld.ub	r9,r8[0x0]
8000424a:	30 18       	mov	r8,1
8000424c:	f0 09 18 00 	cp.b	r9,r8
80004250:	c0 41       	brne	80004258 <phy_tx_func+0x488>
			{
				payload_tx_channel->word[2] =  0x0000;
80004252:	30 08       	mov	r8,0
80004254:	ae 68       	st.h	r7[0xc],r8
80004256:	c1 08       	rjmp	80004276 <phy_tx_func+0x4a6>
			}
			else
			{
			
				payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80004258:	4b 18       	lddpc	r8,8000431c <phy_tx_func+0x54c>
8000425a:	70 09       	ld.w	r9,r8[0x0]
8000425c:	4b 8a       	lddpc	r10,8000433c <phy_tx_func+0x56c>
8000425e:	f4 09 00 0b 	add	r11,r10,r9
80004262:	17 9b       	ld.ub	r11,r11[0x1]
80004264:	f4 09 07 09 	ld.ub	r9,r10[r9]
80004268:	a9 69       	lsl	r9,0x8
8000426a:	f6 09 00 09 	add	r9,r11,r9
8000426e:	ae 69       	st.h	r7[0xc],r9
				index+=2;
80004270:	70 09       	ld.w	r9,r8[0x0]
80004272:	2f e9       	sub	r9,-2
80004274:	91 09       	st.w	r8[0x0],r9
			}
			//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
80004276:	4b 09       	lddpc	r9,80004334 <phy_tx_func+0x564>
80004278:	92 08       	ld.sh	r8,r9[0x0]
8000427a:	20 28       	sub	r8,2
8000427c:	b2 08       	st.h	r9[0x0],r8
			if(expexted_length <= 0)
8000427e:	30 09       	mov	r9,0
80004280:	f2 08 19 00 	cp.h	r8,r9
80004284:	e0 89 00 0e 	brgt	800042a0 <phy_tx_func+0x4d0>
			{
				//last word 0x00BA
				payload_tx_state = last_frame ? 0 : 1;
80004288:	4a c8       	lddpc	r8,80004338 <phy_tx_func+0x568>
8000428a:	11 89       	ld.ub	r9,r8[0x0]
8000428c:	30 08       	mov	r8,0
8000428e:	f0 09 18 00 	cp.b	r9,r8
80004292:	5f 09       	sreq	r9
80004294:	49 d8       	lddpc	r8,80004308 <phy_tx_func+0x538>
80004296:	b0 89       	st.b	r8[0x0],r9
				payload_tx_channel->word[3] = 0x00BA;
80004298:	e0 68 00 ba 	mov	r8,186
8000429c:	ae 78       	st.h	r7[0xe],r8
8000429e:	c2 18       	rjmp	800042e0 <phy_tx_func+0x510>
				break;
			}
		
			if(Silent_flag == 1)
800042a0:	4a 48       	lddpc	r8,80004330 <phy_tx_func+0x560>
800042a2:	11 89       	ld.ub	r9,r8[0x0]
800042a4:	30 18       	mov	r8,1
800042a6:	f0 09 18 00 	cp.b	r9,r8
800042aa:	c0 41       	brne	800042b2 <phy_tx_func+0x4e2>
			{
				payload_tx_channel->word[3] =  0x0000;
800042ac:	30 08       	mov	r8,0
800042ae:	ae 78       	st.h	r7[0xe],r8
800042b0:	c1 08       	rjmp	800042d0 <phy_tx_func+0x500>
			}
			else
			{
			
				payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
800042b2:	49 b8       	lddpc	r8,8000431c <phy_tx_func+0x54c>
800042b4:	70 09       	ld.w	r9,r8[0x0]
800042b6:	4a 2a       	lddpc	r10,8000433c <phy_tx_func+0x56c>
800042b8:	f4 09 00 0b 	add	r11,r10,r9
800042bc:	17 9b       	ld.ub	r11,r11[0x1]
800042be:	f4 09 07 09 	ld.ub	r9,r10[r9]
800042c2:	a9 69       	lsl	r9,0x8
800042c4:	f6 09 00 09 	add	r9,r11,r9
800042c8:	ae 79       	st.h	r7[0xe],r9
				index+=2;
800042ca:	70 09       	ld.w	r9,r8[0x0]
800042cc:	2f e9       	sub	r9,-2
800042ce:	91 09       	st.w	r8[0x0],r9
			}
		
			//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
		
			expexted_length -= 2;
800042d0:	49 98       	lddpc	r8,80004334 <phy_tx_func+0x564>
800042d2:	90 09       	ld.sh	r9,r8[0x0]
800042d4:	20 29       	sub	r9,2
800042d6:	b0 09       	st.h	r8[0x0],r9
800042d8:	c0 48       	rjmp	800042e0 <phy_tx_func+0x510>
		
			break;
		
		default:
			payload_tx_state = 0;
800042da:	30 09       	mov	r9,0
800042dc:	48 b8       	lddpc	r8,80004308 <phy_tx_func+0x538>
800042de:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
800042e0:	2f fd       	sub	sp,-4
800042e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800042e6:	00 00       	add	r0,r0
800042e8:	00 00       	add	r0,r0
800042ea:	10 68       	and	r8,r8
800042ec:	00 00       	add	r0,r0
800042ee:	10 20       	rsub	r0,r8
800042f0:	00 00       	add	r0,r0
800042f2:	0f f8       	ld.ub	r8,r7[0x7]
800042f4:	80 00       	ld.sh	r0,r0[0x0]
800042f6:	90 0c       	ld.sh	r12,r8[0x0]
800042f8:	00 00       	add	r0,r0
800042fa:	10 4a       	or	r10,r8
800042fc:	00 00       	add	r0,r0
800042fe:	10 39       	cp.w	r9,r8
80004300:	00 00       	add	r0,r0
80004302:	0a 42       	or	r2,r5
80004304:	00 00       	add	r0,r0
80004306:	10 78       	tst	r8,r8
80004308:	00 00       	add	r0,r0
8000430a:	10 40       	or	r0,r8
8000430c:	00 00       	add	r0,r0
8000430e:	10 00       	add	r0,r8
80004310:	00 00       	add	r0,r0
80004312:	10 24       	rsub	r4,r8
80004314:	00 00       	add	r0,r0
80004316:	14 54       	eor	r4,r10
80004318:	80 01       	ld.sh	r1,r0[0x0]
8000431a:	0a a0       	st.w	r5++,r0
8000431c:	00 00       	add	r0,r0
8000431e:	10 1c       	sub	r12,r8
80004320:	00 00       	add	r0,r0
80004322:	0a 48       	or	r8,r5
80004324:	00 00       	add	r0,r0
80004326:	10 2c       	rsub	r12,r8
80004328:	00 00       	add	r0,r0
8000432a:	10 38       	cp.w	r8,r8
8000432c:	00 00       	add	r0,r0
8000432e:	10 44       	or	r4,r8
80004330:	00 00       	add	r0,r0
80004332:	0a 50       	eor	r0,r5
80004334:	00 00       	add	r0,r0
80004336:	10 50       	eor	r0,r8
80004338:	00 00       	add	r0,r0
8000433a:	10 3a       	cp.w	r10,r8
8000433c:	80 01       	ld.sh	r1,r0[0x0]
8000433e:	10 68       	and	r8,r8
80004340:	00 00       	add	r0,r0
80004342:	10 74       	tst	r4,r8

80004344 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80004344:	d4 01       	pushm	lr
80004346:	20 1d       	sub	sp,4
	void * ptr = NULL;
80004348:	30 0a       	mov	r10,0
8000434a:	fa cb ff fc 	sub	r11,sp,-4
8000434e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80004350:	14 99       	mov	r9,r10
80004352:	1a 9b       	mov	r11,sp
80004354:	f0 1f 00 05 	mcall	80004368 <get_idle_store+0x24>
80004358:	58 1c       	cp.w	r12,1
8000435a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
8000435e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80004362:	2f fd       	sub	sp,-4
80004364:	d8 02       	popm	pc
80004366:	00 00       	add	r0,r0
80004368:	80 00       	ld.sh	r0,r0[0x0]
8000436a:	90 fc       	ld.uh	r12,r8[0xe]

8000436c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
8000436c:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80004370:	f0 1f 00 21 	mcall	800043f4 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80004374:	4a 1b       	lddpc	r11,800043f8 <phy_init+0x8c>
80004376:	4a 2c       	lddpc	r12,800043fc <phy_init+0x90>
80004378:	f0 1f 00 22 	mcall	80004400 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
8000437c:	30 4b       	mov	r11,4
8000437e:	31 ec       	mov	r12,30
80004380:	f0 1f 00 21 	mcall	80004404 <phy_init+0x98>
80004384:	4a 18       	lddpc	r8,80004408 <phy_init+0x9c>
80004386:	91 0c       	st.w	r8[0x0],r12
80004388:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
8000438a:	10 96       	mov	r6,r8
8000438c:	4a 05       	lddpc	r5,8000440c <phy_init+0xa0>
8000438e:	6c 0c       	ld.w	r12,r6[0x0]
80004390:	ea 07 00 0b 	add	r11,r5,r7
80004394:	f0 1f 00 1f 	mcall	80004410 <phy_init+0xa4>
80004398:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
8000439c:	e0 47 1e 00 	cp.w	r7,7680
800043a0:	cf 71       	brne	8000438e <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043a2:	30 4b       	mov	r11,4
800043a4:	31 4c       	mov	r12,20
800043a6:	f0 1f 00 18 	mcall	80004404 <phy_init+0x98>
800043aa:	49 b8       	lddpc	r8,80004414 <phy_init+0xa8>
800043ac:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
800043ae:	30 4b       	mov	r11,4
800043b0:	30 ac       	mov	r12,10
800043b2:	f0 1f 00 15 	mcall	80004404 <phy_init+0x98>
800043b6:	49 98       	lddpc	r8,80004418 <phy_init+0xac>
800043b8:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
800043ba:	30 4b       	mov	r11,4
800043bc:	30 ac       	mov	r12,10
800043be:	f0 1f 00 12 	mcall	80004404 <phy_init+0x98>
800043c2:	49 78       	lddpc	r8,8000441c <phy_init+0xb0>
800043c4:	91 0c       	st.w	r8[0x0],r12
800043c6:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
800043c8:	10 96       	mov	r6,r8
800043ca:	49 65       	lddpc	r5,80004420 <phy_init+0xb4>
800043cc:	6c 0c       	ld.w	r12,r6[0x0]
800043ce:	ea 07 00 0b 	add	r11,r5,r7
800043d2:	f0 1f 00 10 	mcall	80004410 <phy_init+0xa4>
800043d6:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800043da:	e0 47 14 00 	cp.w	r7,5120
800043de:	cf 71       	brne	800043cc <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
800043e0:	e0 6b 01 00 	mov	r11,256
800043e4:	30 5c       	mov	r12,5
800043e6:	f0 1f 00 08 	mcall	80004404 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
800043ea:	48 f8       	lddpc	r8,80004424 <phy_init+0xb8>
800043ec:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
800043ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800043f2:	00 00       	add	r0,r0
800043f4:	80 00       	ld.sh	r0,r0[0x0]
800043f6:	50 2c       	stdsp	sp[0x8],r12
800043f8:	80 00       	ld.sh	r0,r0[0x0]
800043fa:	3d d0       	mov	r0,-35
800043fc:	80 00       	ld.sh	r0,r0[0x0]
800043fe:	44 88       	lddsp	r8,sp[0x120]
80004400:	80 00       	ld.sh	r0,r0[0x0]
80004402:	50 18       	stdsp	sp[0x4],r8
80004404:	80 00       	ld.sh	r0,r0[0x0]
80004406:	94 60       	ld.sh	r0,r10[0xc]
80004408:	00 00       	add	r0,r0
8000440a:	10 18       	sub	r8,r8
8000440c:	00 00       	add	r0,r0
8000440e:	28 58       	sub	r8,-123
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	3d 2c       	mov	r12,-46
80004414:	00 00       	add	r0,r0
80004416:	10 68       	and	r8,r8
80004418:	00 00       	add	r0,r0
8000441a:	10 4c       	or	r12,r8
8000441c:	00 00       	add	r0,r0
8000441e:	10 04       	add	r4,r8
80004420:	00 00       	add	r0,r0
80004422:	14 58       	eor	r8,r10
80004424:	00 00       	add	r0,r0
80004426:	10 58       	eor	r8,r8

80004428 <payload_rx>:




static void payload_rx(void * payload)
{
80004428:	d4 01       	pushm	lr
8000442a:	20 2d       	sub	sp,8
8000442c:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000442e:	30 08       	mov	r8,0
80004430:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80004432:	48 f8       	lddpc	r8,8000446c <payload_rx+0x44>
80004434:	70 08       	ld.w	r8,r8[0x0]
80004436:	58 08       	cp.w	r8,0
80004438:	c0 71       	brne	80004446 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
8000443a:	30 4b       	mov	r11,4
8000443c:	30 5c       	mov	r12,5
8000443e:	f0 1f 00 0d 	mcall	80004470 <payload_rx+0x48>
80004442:	48 b8       	lddpc	r8,8000446c <payload_rx+0x44>
80004444:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80004446:	48 a8       	lddpc	r8,8000446c <payload_rx+0x44>
80004448:	70 0c       	ld.w	r12,r8[0x0]
8000444a:	30 09       	mov	r9,0
8000444c:	fa ca ff fc 	sub	r10,sp,-4
80004450:	1a 9b       	mov	r11,sp
80004452:	f0 1f 00 09 	mcall	80004474 <payload_rx+0x4c>
80004456:	c0 91       	brne	80004468 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80004458:	48 88       	lddpc	r8,80004478 <payload_rx+0x50>
8000445a:	70 0c       	ld.w	r12,r8[0x0]
8000445c:	40 0b       	lddsp	r11,sp[0x0]
8000445e:	f0 1f 00 08 	mcall	8000447c <payload_rx+0x54>
		logFromISR("mm");
80004462:	48 8c       	lddpc	r12,80004480 <payload_rx+0x58>
80004464:	f0 1f 00 08 	mcall	80004484 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80004468:	2f ed       	sub	sp,-8
8000446a:	d8 02       	popm	pc
8000446c:	00 00       	add	r0,r0
8000446e:	10 08       	add	r8,r8
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	94 60       	ld.sh	r0,r10[0xc]
80004474:	80 00       	ld.sh	r0,r0[0x0]
80004476:	92 b8       	ld.uh	r8,r9[0x6]
80004478:	00 00       	add	r0,r0
8000447a:	10 04       	add	r4,r8
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	3c d8       	mov	r8,-51
80004480:	80 01       	ld.sh	r1,r0[0x0]
80004482:	94 18       	ld.sh	r8,r10[0x2]
80004484:	80 00       	ld.sh	r0,r0[0x0]
80004486:	a0 84       	st.b	r0[0x0],r4

80004488 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80004488:	eb cd 40 e0 	pushm	r5-r7,lr
8000448c:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000448e:	fe f8 09 de 	ld.w	r8,pc[2526]
80004492:	70 08       	ld.w	r8,r8[0x0]
80004494:	58 08       	cp.w	r8,0
80004496:	e0 80 01 05 	breq	800046a0 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000449a:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
8000449c:	fe f8 09 d4 	ld.w	r8,pc[2516]
800044a0:	70 09       	ld.w	r9,r8[0x0]
800044a2:	2f f9       	sub	r9,-1
800044a4:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800044a6:	fe f8 09 ce 	ld.w	r8,pc[2510]
800044aa:	70 08       	ld.w	r8,r8[0x0]
800044ac:	58 18       	cp.w	r8,1
800044ae:	e0 80 00 84 	breq	800045b6 <phy_rx_func+0x12e>
800044b2:	c0 73       	brcs	800044c0 <phy_rx_func+0x38>
800044b4:	58 28       	cp.w	r8,2
800044b6:	c5 b0       	breq	8000456c <phy_rx_func+0xe4>
800044b8:	58 38       	cp.w	r8,3
800044ba:	e0 81 00 f3 	brne	800046a0 <phy_rx_func+0x218>
800044be:	cd 38       	rjmp	80004664 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800044c0:	e0 6a 5a 5a 	mov	r10,23130
800044c4:	ea 1a ab cd 	orh	r10,0xabcd
800044c8:	14 36       	cp.w	r6,r10
800044ca:	e0 80 00 eb 	breq	800046a0 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800044ce:	ec 08 16 10 	lsr	r8,r6,0x10
800044d2:	e0 48 ab cd 	cp.w	r8,43981
800044d6:	e0 81 00 e5 	brne	800046a0 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800044da:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800044de:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800044e2:	20 28       	sub	r8,2
800044e4:	fe f9 09 94 	ld.w	r9,pc[2452]
800044e8:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800044ea:	30 09       	mov	r9,0
800044ec:	f2 08 19 00 	cp.h	r8,r9
800044f0:	e0 8a 00 d8 	brle	800046a0 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800044f4:	fe f8 09 88 	ld.w	r8,pc[2440]
800044f8:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800044fa:	fe f8 09 86 	ld.w	r8,pc[2438]
800044fe:	70 0c       	ld.w	r12,r8[0x0]
80004500:	f0 1f 02 61 	mcall	80004e84 <phy_rx_func+0x9fc>
80004504:	fe f8 09 84 	ld.w	r8,pc[2436]
80004508:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000450a:	58 0c       	cp.w	r12,0
8000450c:	e0 80 00 ca 	breq	800046a0 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80004510:	fe f8 09 6c 	ld.w	r8,pc[2412]
80004514:	90 09       	ld.sh	r9,r8[0x0]
80004516:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
8000451a:	2f f9       	sub	r9,-1
8000451c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000451e:	fe fa 09 6a 	ld.w	r10,pc[2410]
80004522:	74 0a       	ld.w	r10,r10[0x0]
80004524:	fe fb 09 4c 	ld.w	r11,pc[2380]
80004528:	76 0b       	ld.w	r11,r11[0x0]
8000452a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000452e:	2f f9       	sub	r9,-1
80004530:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80004532:	e2 16 0f 00 	andl	r6,0xf00,COH
80004536:	e0 46 01 00 	cp.w	r6,256
8000453a:	c0 c0       	breq	80004552 <phy_rx_func+0xca>
8000453c:	e0 8b 00 05 	brhi	80004546 <phy_rx_func+0xbe>
80004540:	58 06       	cp.w	r6,0
80004542:	c0 80       	breq	80004552 <phy_rx_func+0xca>
80004544:	c0 c8       	rjmp	8000455c <phy_rx_func+0xd4>
80004546:	e0 46 02 00 	cp.w	r6,512
8000454a:	c0 40       	breq	80004552 <phy_rx_func+0xca>
8000454c:	e0 46 03 00 	cp.w	r6,768
80004550:	c0 61       	brne	8000455c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80004552:	30 29       	mov	r9,2
80004554:	fe f8 09 20 	ld.w	r8,pc[2336]
80004558:	91 09       	st.w	r8[0x0],r9
8000455a:	ca 38       	rjmp	800046a0 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
8000455c:	fe f6 09 2c 	ld.w	r6,pc[2348]
80004560:	6c 0c       	ld.w	r12,r6[0x0]
80004562:	f0 1f 02 4b 	mcall	80004e8c <phy_rx_func+0xa04>
					phy_frame_ptr = NULL;					
80004566:	30 08       	mov	r8,0
80004568:	8d 08       	st.w	r6[0x0],r8
8000456a:	c9 b8       	rjmp	800046a0 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
8000456c:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80004570:	b1 86       	lsr	r6,0x10
80004572:	14 06       	add	r6,r10
80004574:	fe f8 09 1c 	ld.w	r8,pc[2332]
80004578:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000457a:	fe f8 09 02 	ld.w	r8,pc[2306]
8000457e:	90 09       	ld.sh	r9,r8[0x0]
80004580:	fe fb 09 08 	ld.w	r11,pc[2312]
80004584:	76 0b       	ld.w	r11,r11[0x0]
80004586:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000458a:	2f f9       	sub	r9,-1
8000458c:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
8000458e:	fe f9 08 ea 	ld.w	r9,pc[2282]
80004592:	92 08       	ld.sh	r8,r9[0x0]
80004594:	20 28       	sub	r8,2
80004596:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80004598:	30 09       	mov	r9,0
8000459a:	f2 08 19 00 	cp.h	r8,r9
8000459e:	e0 8a 00 07 	brle	800045ac <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
800045a2:	30 19       	mov	r9,1
800045a4:	fe f8 08 d0 	ld.w	r8,pc[2256]
800045a8:	91 09       	st.w	r8[0x0],r9
800045aa:	c7 b8       	rjmp	800046a0 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800045ac:	30 39       	mov	r9,3
800045ae:	fe f8 08 c6 	ld.w	r8,pc[2246]
800045b2:	91 09       	st.w	r8[0x0],r9
800045b4:	c7 68       	rjmp	800046a0 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800045b6:	ec 0a 14 10 	asr	r10,r6,0x10
800045ba:	fe f8 08 d6 	ld.w	r8,pc[2262]
800045be:	90 09       	ld.sh	r9,r8[0x0]
800045c0:	14 09       	add	r9,r10
800045c2:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800045c4:	fe f9 08 b8 	ld.w	r9,pc[2232]
800045c8:	92 08       	ld.sh	r8,r9[0x0]
800045ca:	fe fb 08 be 	ld.w	r11,pc[2238]
800045ce:	76 0b       	ld.w	r11,r11[0x0]
800045d0:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800045d4:	2f f8       	sub	r8,-1
800045d6:	5c 88       	casts.h	r8
800045d8:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800045da:	fe fa 08 9e 	ld.w	r10,pc[2206]
800045de:	94 09       	ld.sh	r9,r10[0x0]
800045e0:	20 29       	sub	r9,2
800045e2:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800045e4:	30 0a       	mov	r10,0
800045e6:	f4 09 19 00 	cp.h	r9,r10
800045ea:	e0 89 00 1f 	brgt	80004628 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800045ee:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800045f2:	e0 46 00 ba 	cp.w	r6,186
800045f6:	c0 d1       	brne	80004610 <phy_rx_func+0x188>
800045f8:	fe f8 08 98 	ld.w	r8,pc[2200]
800045fc:	90 09       	ld.sh	r9,r8[0x0]
800045fe:	f4 09 19 00 	cp.h	r9,r10
80004602:	c0 71       	brne	80004610 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80004604:	fe f8 08 84 	ld.w	r8,pc[2180]
80004608:	70 0c       	ld.w	r12,r8[0x0]
8000460a:	f0 1f 02 23 	mcall	80004e94 <phy_rx_func+0xa0c>
8000460e:	c0 88       	rjmp	8000461e <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80004610:	fe f6 08 78 	ld.w	r6,pc[2168]
80004614:	6c 0c       	ld.w	r12,r6[0x0]
80004616:	f0 1f 02 1e 	mcall	80004e8c <phy_rx_func+0xa04>
					phy_frame_ptr = NULL;
8000461a:	30 08       	mov	r8,0
8000461c:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000461e:	30 09       	mov	r9,0
80004620:	fe f8 08 54 	ld.w	r8,pc[2132]
80004624:	91 09       	st.w	r8[0x0],r9
80004626:	c3 d8       	rjmp	800046a0 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80004628:	5c 86       	casts.h	r6
8000462a:	fe f9 08 66 	ld.w	r9,pc[2150]
8000462e:	92 0a       	ld.sh	r10,r9[0x0]
80004630:	0c 0a       	add	r10,r6
80004632:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80004634:	fe f9 08 54 	ld.w	r9,pc[2132]
80004638:	72 09       	ld.w	r9,r9[0x0]
8000463a:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000463e:	2f f8       	sub	r8,-1
80004640:	fe f9 08 3c 	ld.w	r9,pc[2108]
80004644:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80004646:	fe f9 08 32 	ld.w	r9,pc[2098]
8000464a:	92 08       	ld.sh	r8,r9[0x0]
8000464c:	20 28       	sub	r8,2
8000464e:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80004650:	30 09       	mov	r9,0
80004652:	f2 08 19 00 	cp.h	r8,r9
80004656:	e0 89 00 25 	brgt	800046a0 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000465a:	30 39       	mov	r9,3
8000465c:	fe f8 08 18 	ld.w	r8,pc[2072]
80004660:	91 09       	st.w	r8[0x0],r9
80004662:	c1 f8       	rjmp	800046a0 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80004664:	e6 16 00 ff 	andh	r6,0xff,COH
80004668:	fc 19 00 ba 	movh	r9,0xba
8000466c:	12 36       	cp.w	r6,r9
8000466e:	c0 e1       	brne	8000468a <phy_rx_func+0x202>
80004670:	fe f8 08 20 	ld.w	r8,pc[2080]
80004674:	90 09       	ld.sh	r9,r8[0x0]
80004676:	30 08       	mov	r8,0
80004678:	f0 09 19 00 	cp.h	r9,r8
8000467c:	c0 71       	brne	8000468a <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000467e:	fe f8 08 0a 	ld.w	r8,pc[2058]
80004682:	70 0c       	ld.w	r12,r8[0x0]
80004684:	f0 1f 02 04 	mcall	80004e94 <phy_rx_func+0xa0c>
80004688:	c0 88       	rjmp	80004698 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
8000468a:	fe f6 07 fe 	ld.w	r6,pc[2046]
8000468e:	6c 0c       	ld.w	r12,r6[0x0]
80004690:	f0 1f 01 ff 	mcall	80004e8c <phy_rx_func+0xa04>
				phy_frame_ptr = NULL;
80004694:	30 08       	mov	r8,0
80004696:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80004698:	30 09       	mov	r9,0
8000469a:	fe f8 07 da 	ld.w	r8,pc[2010]
8000469e:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800046a0:	fe f8 07 f8 	ld.w	r8,pc[2040]
800046a4:	11 89       	ld.ub	r9,r8[0x0]
800046a6:	30 08       	mov	r8,0
800046a8:	f0 09 18 00 	cp.b	r9,r8
800046ac:	c1 31       	brne	800046d2 <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
800046ae:	fe f6 07 ee 	ld.w	r6,pc[2030]
800046b2:	6c 0c       	ld.w	r12,r6[0x0]
800046b4:	f0 1f 01 f4 	mcall	80004e84 <phy_rx_func+0x9fc>
800046b8:	fe f8 07 e8 	ld.w	r8,pc[2024]
800046bc:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800046be:	6c 0c       	ld.w	r12,r6[0x0]
800046c0:	f0 1f 01 f1 	mcall	80004e84 <phy_rx_func+0x9fc>
800046c4:	fe f8 07 e0 	ld.w	r8,pc[2016]
800046c8:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800046ca:	30 19       	mov	r9,1
800046cc:	fe f8 07 cc 	ld.w	r8,pc[1996]
800046d0:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800046d2:	fe f8 07 d6 	ld.w	r8,pc[2006]
800046d6:	70 08       	ld.w	r8,r8[0x0]
800046d8:	58 28       	cp.w	r8,2
800046da:	e0 80 01 72 	breq	800049be <phy_rx_func+0x536>
800046de:	58 38       	cp.w	r8,3
800046e0:	e0 80 02 30 	breq	80004b40 <phy_rx_func+0x6b8>
800046e4:	58 08       	cp.w	r8,0
800046e6:	e0 81 03 c0 	brne	80004e66 <phy_rx_func+0x9de>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800046ea:	6e 28       	ld.w	r8,r7[0x8]
800046ec:	e0 6a 5a 5a 	mov	r10,23130
800046f0:	ea 1a ab cd 	orh	r10,0xabcd
800046f4:	14 38       	cp.w	r8,r10
800046f6:	c0 71       	brne	80004704 <phy_rx_func+0x27c>
			{
				m_RxBurstType = VOICE_WATING;
800046f8:	30 09       	mov	r9,0
800046fa:	fe f8 07 b2 	ld.w	r8,pc[1970]
800046fe:	91 09       	st.w	r8[0x0],r9
80004700:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80004704:	10 99       	mov	r9,r8
80004706:	e0 19 00 00 	andl	r9,0x0
8000470a:	fc 1a ab cd 	movh	r10,0xabcd
8000470e:	14 39       	cp.w	r9,r10
80004710:	e0 81 03 ab 	brne	80004e66 <phy_rx_func+0x9de>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80004714:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004718:	fe f9 07 98 	ld.w	r9,pc[1944]
8000471c:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
8000471e:	fe f8 07 82 	ld.w	r8,pc[1922]
80004722:	70 08       	ld.w	r8,r8[0x0]
80004724:	58 08       	cp.w	r8,0
80004726:	c0 60       	breq	80004732 <phy_rx_func+0x2aa>
80004728:	fe f8 07 7c 	ld.w	r8,pc[1916]
8000472c:	70 08       	ld.w	r8,r8[0x0]
8000472e:	58 08       	cp.w	r8,0
80004730:	c1 61       	brne	8000475c <phy_rx_func+0x2d4>
			{
				payload_ptr = get_payload_idle_isr();
80004732:	fe f6 07 6a 	ld.w	r6,pc[1898]
80004736:	6c 0c       	ld.w	r12,r6[0x0]
80004738:	f0 1f 01 d3 	mcall	80004e84 <phy_rx_func+0x9fc>
8000473c:	fe f5 07 64 	ld.w	r5,pc[1892]
80004740:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
80004742:	6c 0c       	ld.w	r12,r6[0x0]
80004744:	f0 1f 01 d0 	mcall	80004e84 <phy_rx_func+0x9fc>
80004748:	fe f8 07 5c 	ld.w	r8,pc[1884]
8000474c:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
8000474e:	6a 08       	ld.w	r8,r5[0x0]
80004750:	58 08       	cp.w	r8,0
80004752:	e0 80 03 8a 	breq	80004e66 <phy_rx_func+0x9de>
80004756:	58 0c       	cp.w	r12,0
80004758:	e0 80 03 87 	breq	80004e66 <phy_rx_func+0x9de>
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000475c:	6e 28       	ld.w	r8,r7[0x8]
8000475e:	e2 18 f0 00 	andl	r8,0xf000,COH
80004762:	e0 48 c0 00 	cp.w	r8,49152
80004766:	e0 81 00 99 	brne	80004898 <phy_rx_func+0x410>
			{
				AMBE_flag = 1;
8000476a:	30 19       	mov	r9,1
8000476c:	fe f8 07 48 	ld.w	r8,pc[1864]
80004770:	b0 89       	st.b	r8[0x0],r9
								
				Item_ID = payload_rx_channel->byte[5];
80004772:	ef 39 00 0d 	ld.ub	r9,r7[13]
80004776:	fe f8 07 42 	ld.w	r8,pc[1858]
8000477a:	b0 89       	st.b	r8[0x0],r9
				
				VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
8000477c:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80004780:	fe f9 07 3c 	ld.w	r9,pc[1852]
80004784:	b2 8c       	st.b	r9[0x0],r12
					
				//The OB know the Call begin and discard the Voice Header
				//The OB know the Call end and discard the Voice  Terminator			
				if (Item_ID == Raw_Tx_Data_HT)
80004786:	11 89       	ld.ub	r9,r8[0x0]
80004788:	3f 08       	mov	r8,-16
8000478a:	f0 09 18 00 	cp.b	r9,r8
8000478e:	c3 61       	brne	800047fa <phy_rx_func+0x372>
				{
					//HT_index = 0;
					//AMBE_HT[0] = payload_rx_channel->dword[0];
					//AMBE_HT[1] = payload_rx_channel->dword[1];
					//
					if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80004790:	ef 38 00 0e 	ld.ub	r8,r7[14]
80004794:	e2 18 00 f0 	andl	r8,0xf0,COH
80004798:	59 08       	cp.w	r8,16
8000479a:	c0 71       	brne	800047a8 <phy_rx_func+0x320>
					{
						m_RxBurstType = VOICEHEADER;		
8000479c:	30 19       	mov	r9,1
8000479e:	fe f8 07 0e 	ld.w	r8,pc[1806]
800047a2:	91 09       	st.w	r8[0x0],r9
800047a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

					}
					else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800047a8:	e0 48 00 20 	cp.w	r8,32
800047ac:	c2 11       	brne	800047ee <phy_rx_func+0x366>
					{
						m_RxBurstType = VOICETERMINATOR;
800047ae:	30 99       	mov	r9,9
800047b0:	fe f8 06 fc 	ld.w	r8,pc[1788]
800047b4:	91 09       	st.w	r8[0x0],r9
						//AMBE-data and PCM-data is not the same. AMBE is compressed data,
						//if there was a missing portion, a clear voice is difficult to extract the data. 
						//It must ensure that all the data received AMBE.
						
						//0
						memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800047b6:	fe f6 07 0a 	ld.w	r6,pc[1802]
800047ba:	6c 08       	ld.w	r8,r6[0x0]
800047bc:	f0 0a 11 ff 	rsub	r10,r8,-1
800047c0:	fe f7 06 e4 	ld.w	r7,pc[1764]
800047c4:	2f f8       	sub	r8,-1
800047c6:	6e 0c       	ld.w	r12,r7[0x0]
800047c8:	f4 ca fe 00 	sub	r10,r10,-512
800047cc:	30 0b       	mov	r11,0
800047ce:	10 0c       	add	r12,r8
800047d0:	f0 1f 01 bd 	mcall	80004ec4 <phy_rx_func+0xa3c>
						
						RxAMBE_IsFillingNext8 = 0;
800047d4:	30 08       	mov	r8,0
800047d6:	8d 08       	st.w	r6[0x0],r8
						payload_rx(AMBE_payload_ptr);
800047d8:	6e 0c       	ld.w	r12,r7[0x0]
800047da:	f0 1f 01 bc 	mcall	80004ec8 <phy_rx_func+0xa40>
						AMBE_payload_ptr = get_payload_idle_isr();
800047de:	fe f8 06 be 	ld.w	r8,pc[1726]
800047e2:	70 0c       	ld.w	r12,r8[0x0]
800047e4:	f0 1f 01 a8 	mcall	80004e84 <phy_rx_func+0x9fc>
800047e8:	8f 0c       	st.w	r7[0x0],r12
800047ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						//logFromISR("\n\r QQ1 \n\r");
						
					}
					else//error voice
					{
						m_RxBurstType = VOICE_WATING;
800047ee:	30 09       	mov	r9,0
800047f0:	fe f8 06 bc 	ld.w	r8,pc[1724]
800047f4:	91 09       	st.w	r8[0x0],r9
800047f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					
					break;//WAITINGABAB.
		
						
				}
				else if (Item_ID == Vocoder_Bit_Stream_Parameter)//Vocoder Bits Stream Parameter
800047fa:	fe f8 06 be 	ld.w	r8,pc[1726]
800047fe:	11 89       	ld.ub	r9,r8[0x0]
80004800:	31 28       	mov	r8,18
80004802:	f0 09 18 00 	cp.b	r9,r8
80004806:	c0 d1       	brne	80004820 <phy_rx_func+0x398>
				{	
						
						VBSP_data[0] = payload_rx_channel->word[2];
80004808:	8e 69       	ld.sh	r9,r7[0xc]
8000480a:	fe f8 06 c2 	ld.w	r8,pc[1730]
8000480e:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[3];
80004810:	8e 79       	ld.sh	r9,r7[0xe]
80004812:	b0 19       	st.h	r8[0x2],r9
						m_RxBurstType = CalculateBurst(VF_SN);
80004814:	f0 1f 01 af 	mcall	80004ed0 <phy_rx_func+0xa48>
80004818:	fe f8 06 94 	ld.w	r8,pc[1684]
8000481c:	91 0c       	st.w	r8[0x0],r12
8000481e:	c3 78       	rjmp	8000488c <phy_rx_func+0x404>

				}
				else if ((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
80004820:	fe f8 06 98 	ld.w	r8,pc[1688]
80004824:	11 89       	ld.ub	r9,r8[0x0]
80004826:	30 48       	mov	r8,4
80004828:	f0 09 18 00 	cp.b	r9,r8
8000482c:	c0 80       	breq	8000483c <phy_rx_func+0x3b4>
8000482e:	fe f8 06 8a 	ld.w	r8,pc[1674]
80004832:	11 89       	ld.ub	r9,r8[0x0]
80004834:	30 38       	mov	r8,3
80004836:	f0 09 18 00 	cp.b	r9,r8
8000483a:	c1 c1       	brne	80004872 <phy_rx_func+0x3ea>
				{
					//break;
					m_RxBurstType = UNSUREDATA;
8000483c:	30 29       	mov	r9,2
8000483e:	fe f8 06 6e 	ld.w	r8,pc[1646]
80004842:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[0] = payload_rx_channel->dword[0];
80004844:	6e 29       	ld.w	r9,r7[0x8]
80004846:	fe f8 06 8e 	ld.w	r8,pc[1678]
8000484a:	91 09       	st.w	r8[0x0],r9
					AMBE_HT[1] = payload_rx_channel->dword[1];
8000484c:	6e 39       	ld.w	r9,r7[0xc]
8000484e:	91 19       	st.w	r8[0x4],r9
					
					if (RxBytesWaiting == 0x00000014)
80004850:	fe f8 06 60 	ld.w	r8,pc[1632]
80004854:	70 08       	ld.w	r8,r8[0x0]
80004856:	59 48       	cp.w	r8,20
80004858:	c0 61       	brne	80004864 <phy_rx_func+0x3dc>
					{
						RxBytesWaiting = 0x18;//24 Reassigned
8000485a:	31 89       	mov	r9,24
8000485c:	fe f8 06 54 	ld.w	r8,pc[1620]
80004860:	91 09       	st.w	r8[0x0],r9
80004862:	c1 58       	rjmp	8000488c <phy_rx_func+0x404>
						//_flag =0;
							
					}
					if (RxBytesWaiting == 0x00000010)
80004864:	59 08       	cp.w	r8,16
80004866:	c1 31       	brne	8000488c <phy_rx_func+0x404>
					{
						RxBytesWaiting = 0x10;//16 Reassigned
80004868:	31 09       	mov	r9,16
8000486a:	fe f8 06 46 	ld.w	r8,pc[1606]
8000486e:	91 09       	st.w	r8[0x0],r9
80004870:	c0 e8       	rjmp	8000488c <phy_rx_func+0x404>
					
				}
				else
				{
					
					logFromISR("\n\r Item_ID:%x \n\r", payload_rx_channel->word[2]);
80004872:	8e e8       	ld.uh	r8,r7[0xc]
80004874:	1a d8       	st.w	--sp,r8
80004876:	fe fc 06 62 	ld.w	r12,pc[1634]
8000487a:	f0 1f 01 99 	mcall	80004edc <phy_rx_func+0xa54>
					logFromISR("\n\r Axiba \n\r");
8000487e:	fe fc 06 62 	ld.w	r12,pc[1634]
80004882:	f0 1f 01 97 	mcall	80004edc <phy_rx_func+0xa54>
80004886:	2f fd       	sub	sp,-4
80004888:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//Radio Internal Parameter(0x7F):
					//The OB should use the route back this item to radio without change content.
					break;
				}
				
				RxMediaState = READING_AMBE_MEDIA;//Jump
8000488c:	30 39       	mov	r9,3
8000488e:	fe f8 06 1a 	ld.w	r8,pc[1562]
80004892:	91 09       	st.w	r8[0x0],r9
80004894:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80004898:	e0 48 10 00 	cp.w	r8,4096
8000489c:	5f 19       	srne	r9
8000489e:	e0 48 20 00 	cp.w	r8,8192
800048a2:	5f 18       	srne	r8
800048a4:	f3 e8 00 08 	and	r8,r9,r8
800048a8:	e0 81 02 df 	brne	80004e66 <phy_rx_func+0x9de>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_flag = 0;
800048ac:	fe f9 06 08 	ld.w	r9,pc[1544]
800048b0:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
800048b2:	fe f9 06 06 	ld.w	r9,pc[1542]
800048b6:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800048b8:	6e 28       	ld.w	r8,r7[0x8]
800048ba:	e2 18 0f 00 	andl	r8,0xf00,COH
800048be:	58 18       	cp.w	r8,1
800048c0:	e0 8b 00 4d 	brhi	8000495a <phy_rx_func+0x4d2>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800048c4:	fe f9 05 ec 	ld.w	r9,pc[1516]
800048c8:	72 08       	ld.w	r8,r9[0x0]
800048ca:	20 48       	sub	r8,4
800048cc:	93 08       	st.w	r9[0x0],r8
800048ce:	e0 80 02 cc 	breq	80004e66 <phy_rx_func+0x9de>
				ArrayDiscLength = payload_rx_channel->word[2];
800048d2:	8e 68       	ld.sh	r8,r7[0xc]
800048d4:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800048d8:	fe f9 06 0c 	ld.w	r9,pc[1548]
800048dc:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
800048de:	30 09       	mov	r9,0
800048e0:	f2 08 19 00 	cp.h	r8,r9
800048e4:	c0 70       	breq	800048f2 <phy_rx_func+0x46a>
800048e6:	30 19       	mov	r9,1
800048e8:	f2 08 19 00 	cp.h	r8,r9
800048ec:	e0 81 02 bd 	brne	80004e66 <phy_rx_func+0x9de>
800048f0:	c2 68       	rjmp	8000493c <phy_rx_func+0x4b4>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800048f2:	fe f8 05 f6 	ld.w	r8,pc[1526]
800048f6:	70 0a       	ld.w	r10,r8[0x0]
800048f8:	fe f9 05 a8 	ld.w	r9,pc[1448]
800048fc:	72 09       	ld.w	r9,r9[0x0]
800048fe:	8e 7b       	ld.sh	r11,r7[0xe]
80004900:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
80004904:	70 09       	ld.w	r9,r8[0x0]
80004906:	2f f9       	sub	r9,-1
80004908:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000490a:	e0 49 00 ff 	cp.w	r9,255
8000490e:	e0 88 00 11 	brls	80004930 <phy_rx_func+0x4a8>
						{
							RxMedia_IsFillingNext16 = 0;	
80004912:	30 09       	mov	r9,0
80004914:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
80004916:	fe f7 05 8a 	ld.w	r7,pc[1418]
8000491a:	6e 0c       	ld.w	r12,r7[0x0]
8000491c:	f0 1f 01 6b 	mcall	80004ec8 <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
80004920:	fe f8 05 7c 	ld.w	r8,pc[1404]
80004924:	70 0c       	ld.w	r12,r8[0x0]
80004926:	f0 1f 01 58 	mcall	80004e84 <phy_rx_func+0x9fc>
8000492a:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
8000492c:	e0 80 02 9d 	breq	80004e66 <phy_rx_func+0x9de>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
80004930:	30 29       	mov	r9,2
80004932:	fe f8 05 76 	ld.w	r8,pc[1398]
80004936:	91 09       	st.w	r8[0x0],r9
80004938:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
8000493c:	8e 79       	ld.sh	r9,r7[0xe]
8000493e:	30 38       	mov	r8,3
80004940:	f0 09 19 00 	cp.h	r9,r8
80004944:	c0 51       	brne	8000494e <phy_rx_func+0x4c6>
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
							{
								Terminator_Flag = 1;
80004946:	30 19       	mov	r9,1
80004948:	fe f8 05 a4 	ld.w	r8,pc[1444]
8000494c:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
8000494e:	30 29       	mov	r9,2
80004950:	fe f8 05 58 	ld.w	r8,pc[1368]
80004954:	91 09       	st.w	r8[0x0],r9
80004956:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
8000495a:	fe f8 05 56 	ld.w	r8,pc[1366]
8000495e:	70 08       	ld.w	r8,r8[0x0]
80004960:	58 18       	cp.w	r8,1
80004962:	e0 88 02 82 	brls	80004e66 <phy_rx_func+0x9de>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80004966:	fe f8 05 82 	ld.w	r8,pc[1410]
8000496a:	70 0a       	ld.w	r10,r8[0x0]
8000496c:	fe f9 05 34 	ld.w	r9,pc[1332]
80004970:	72 09       	ld.w	r9,r9[0x0]
80004972:	6e 3b       	ld.w	r11,r7[0xc]
80004974:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004978:	70 09       	ld.w	r9,r8[0x0]
8000497a:	2f f9       	sub	r9,-1
8000497c:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000497e:	e0 49 00 ff 	cp.w	r9,255
80004982:	e0 88 00 11 	brls	800049a4 <phy_rx_func+0x51c>
				{
					RxMedia_IsFillingNext16 = 0;
80004986:	30 09       	mov	r9,0
80004988:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000498a:	fe f7 05 16 	ld.w	r7,pc[1302]
8000498e:	6e 0c       	ld.w	r12,r7[0x0]
80004990:	f0 1f 01 4e 	mcall	80004ec8 <phy_rx_func+0xa40>
								payload_ptr = get_payload_idle_isr();
80004994:	fe f8 05 08 	ld.w	r8,pc[1288]
80004998:	70 0c       	ld.w	r12,r8[0x0]
8000499a:	f0 1f 01 3b 	mcall	80004e84 <phy_rx_func+0x9fc>
8000499e:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
800049a0:	e0 80 02 63 	breq	80004e66 <phy_rx_func+0x9de>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800049a4:	fe f9 05 0c 	ld.w	r9,pc[1292]
800049a8:	72 08       	ld.w	r8,r9[0x0]
800049aa:	20 28       	sub	r8,2
800049ac:	93 08       	st.w	r9[0x0],r8
800049ae:	e0 80 02 5c 	breq	80004e66 <phy_rx_func+0x9de>
				RxMediaState = READINGMEDIA;
800049b2:	30 29       	mov	r9,2
800049b4:	fe f8 04 f4 	ld.w	r8,pc[1268]
800049b8:	91 09       	st.w	r8[0x0],r9
800049ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800049be:	fe f8 05 2a 	ld.w	r8,pc[1322]
800049c2:	70 0a       	ld.w	r10,r8[0x0]
800049c4:	fe f9 04 dc 	ld.w	r9,pc[1244]
800049c8:	72 09       	ld.w	r9,r9[0x0]
800049ca:	8e 4b       	ld.sh	r11,r7[0x8]
800049cc:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800049d0:	70 09       	ld.w	r9,r8[0x0]
800049d2:	2f f9       	sub	r9,-1
800049d4:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800049d6:	e0 49 00 ff 	cp.w	r9,255
800049da:	e0 88 00 16 	brls	80004a06 <phy_rx_func+0x57e>
					{
							RxMedia_IsFillingNext16 = 0;
800049de:	30 09       	mov	r9,0
800049e0:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
800049e2:	fe f6 04 be 	ld.w	r6,pc[1214]
800049e6:	6c 0c       	ld.w	r12,r6[0x0]
800049e8:	f0 1f 01 38 	mcall	80004ec8 <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
800049ec:	fe f8 04 b0 	ld.w	r8,pc[1200]
800049f0:	70 0c       	ld.w	r12,r8[0x0]
800049f2:	f0 1f 01 25 	mcall	80004e84 <phy_rx_func+0x9fc>
800049f6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
800049f8:	c0 71       	brne	80004a06 <phy_rx_func+0x57e>
							{
								RxMediaState = WAITINGABAB;
800049fa:	30 09       	mov	r9,0
800049fc:	fe f8 04 ac 	ld.w	r8,pc[1196]
80004a00:	91 09       	st.w	r8[0x0],r9
80004a02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
80004a06:	fe f9 04 aa 	ld.w	r9,pc[1194]
80004a0a:	72 08       	ld.w	r8,r9[0x0]
80004a0c:	20 28       	sub	r8,2
80004a0e:	93 08       	st.w	r9[0x0],r8
80004a10:	c0 71       	brne	80004a1e <phy_rx_func+0x596>
				{
					RxMediaState = WAITINGABAB;
80004a12:	30 09       	mov	r9,0
80004a14:	fe f8 04 94 	ld.w	r8,pc[1172]
80004a18:	91 09       	st.w	r8[0x0],r9
80004a1a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80004a1e:	fe f8 04 ca 	ld.w	r8,pc[1226]
80004a22:	70 0a       	ld.w	r10,r8[0x0]
80004a24:	fe f9 04 7c 	ld.w	r9,pc[1148]
80004a28:	72 09       	ld.w	r9,r9[0x0]
80004a2a:	8e 5b       	ld.sh	r11,r7[0xa]
80004a2c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004a30:	70 09       	ld.w	r9,r8[0x0]
80004a32:	2f f9       	sub	r9,-1
80004a34:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a36:	e0 49 00 ff 	cp.w	r9,255
80004a3a:	e0 88 00 16 	brls	80004a66 <phy_rx_func+0x5de>
						{
							RxMedia_IsFillingNext16 = 0;
80004a3e:	30 09       	mov	r9,0
80004a40:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004a42:	fe f6 04 5e 	ld.w	r6,pc[1118]
80004a46:	6c 0c       	ld.w	r12,r6[0x0]
80004a48:	f0 1f 01 20 	mcall	80004ec8 <phy_rx_func+0xa40>
								payload_ptr = get_payload_idle_isr();
80004a4c:	fe f8 04 50 	ld.w	r8,pc[1104]
80004a50:	70 0c       	ld.w	r12,r8[0x0]
80004a52:	f0 1f 01 0d 	mcall	80004e84 <phy_rx_func+0x9fc>
80004a56:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80004a58:	c0 71       	brne	80004a66 <phy_rx_func+0x5de>
								{
									RxMediaState = WAITINGABAB;
80004a5a:	30 09       	mov	r9,0
80004a5c:	fe f8 04 4c 	ld.w	r8,pc[1100]
80004a60:	91 09       	st.w	r8[0x0],r9
80004a62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004a66:	fe f9 04 4a 	ld.w	r9,pc[1098]
80004a6a:	72 08       	ld.w	r8,r9[0x0]
80004a6c:	20 28       	sub	r8,2
80004a6e:	93 08       	st.w	r9[0x0],r8
80004a70:	c0 71       	brne	80004a7e <phy_rx_func+0x5f6>
					RxMediaState = WAITINGABAB;
80004a72:	30 09       	mov	r9,0
80004a74:	fe f8 04 34 	ld.w	r8,pc[1076]
80004a78:	91 09       	st.w	r8[0x0],r9
80004a7a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80004a7e:	fe f8 04 6a 	ld.w	r8,pc[1130]
80004a82:	70 0a       	ld.w	r10,r8[0x0]
80004a84:	fe f9 04 1c 	ld.w	r9,pc[1052]
80004a88:	72 09       	ld.w	r9,r9[0x0]
80004a8a:	8e 6b       	ld.sh	r11,r7[0xc]
80004a8c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004a90:	70 09       	ld.w	r9,r8[0x0]
80004a92:	2f f9       	sub	r9,-1
80004a94:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004a96:	e0 49 00 ff 	cp.w	r9,255
80004a9a:	e0 88 00 16 	brls	80004ac6 <phy_rx_func+0x63e>
						{
							RxMedia_IsFillingNext16 = 0;
80004a9e:	30 09       	mov	r9,0
80004aa0:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80004aa2:	fe f6 03 fe 	ld.w	r6,pc[1022]
80004aa6:	6c 0c       	ld.w	r12,r6[0x0]
80004aa8:	f0 1f 01 08 	mcall	80004ec8 <phy_rx_func+0xa40>
									payload_ptr = get_payload_idle_isr();
80004aac:	fe f8 03 f0 	ld.w	r8,pc[1008]
80004ab0:	70 0c       	ld.w	r12,r8[0x0]
80004ab2:	f0 1f 00 f5 	mcall	80004e84 <phy_rx_func+0x9fc>
80004ab6:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
80004ab8:	c0 71       	brne	80004ac6 <phy_rx_func+0x63e>
									{
										RxMediaState = WAITINGABAB;
80004aba:	30 09       	mov	r9,0
80004abc:	fe f8 03 ec 	ld.w	r8,pc[1004]
80004ac0:	91 09       	st.w	r8[0x0],r9
80004ac2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004ac6:	fe f9 03 ea 	ld.w	r9,pc[1002]
80004aca:	72 08       	ld.w	r8,r9[0x0]
80004acc:	20 28       	sub	r8,2
80004ace:	93 08       	st.w	r9[0x0],r8
80004ad0:	c0 71       	brne	80004ade <phy_rx_func+0x656>
					RxMediaState = WAITINGABAB;
80004ad2:	30 09       	mov	r9,0
80004ad4:	fe f8 03 d4 	ld.w	r8,pc[980]
80004ad8:	91 09       	st.w	r8[0x0],r9
80004ada:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80004ade:	fe f8 04 0a 	ld.w	r8,pc[1034]
80004ae2:	70 0a       	ld.w	r10,r8[0x0]
80004ae4:	fe f9 03 bc 	ld.w	r9,pc[956]
80004ae8:	72 09       	ld.w	r9,r9[0x0]
80004aea:	8e 7b       	ld.sh	r11,r7[0xe]
80004aec:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80004af0:	70 09       	ld.w	r9,r8[0x0]
80004af2:	2f f9       	sub	r9,-1
80004af4:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80004af6:	e0 49 00 ff 	cp.w	r9,255
80004afa:	e0 88 00 16 	brls	80004b26 <phy_rx_func+0x69e>
						{
							RxMedia_IsFillingNext16 = 0;
80004afe:	30 09       	mov	r9,0
80004b00:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80004b02:	fe f7 03 9e 	ld.w	r7,pc[926]
80004b06:	6e 0c       	ld.w	r12,r7[0x0]
80004b08:	f0 1f 00 f0 	mcall	80004ec8 <phy_rx_func+0xa40>
							payload_ptr = get_payload_idle_isr();
80004b0c:	fe f8 03 90 	ld.w	r8,pc[912]
80004b10:	70 0c       	ld.w	r12,r8[0x0]
80004b12:	f0 1f 00 dd 	mcall	80004e84 <phy_rx_func+0x9fc>
80004b16:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80004b18:	c0 71       	brne	80004b26 <phy_rx_func+0x69e>
							{
								RxMediaState = WAITINGABAB;
80004b1a:	30 09       	mov	r9,0
80004b1c:	fe f8 03 8c 	ld.w	r8,pc[908]
80004b20:	91 09       	st.w	r8[0x0],r9
80004b22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80004b26:	fe f9 03 8a 	ld.w	r9,pc[906]
80004b2a:	72 08       	ld.w	r8,r9[0x0]
80004b2c:	20 28       	sub	r8,2
80004b2e:	93 08       	st.w	r9[0x0],r8
80004b30:	e0 81 01 9b 	brne	80004e66 <phy_rx_func+0x9de>
					RxMediaState = WAITINGABAB;
80004b34:	30 09       	mov	r9,0
80004b36:	fe f8 03 72 	ld.w	r8,pc[882]
80004b3a:	91 09       	st.w	r8[0x0],r9
80004b3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			break; //End of READINGMEDIA.

		case READING_AMBE_MEDIA:
			
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80004b40:	fe f8 03 78 	ld.w	r8,pc[888]
80004b44:	11 89       	ld.ub	r9,r8[0x0]
80004b46:	31 28       	mov	r8,18
80004b48:	f0 09 18 00 	cp.b	r9,r8
80004b4c:	e0 81 01 32 	brne	80004db0 <phy_rx_func+0x928>
					{
						Item_ID = payload_rx_channel->byte[1];
80004b50:	ef 39 00 09 	ld.ub	r9,r7[9]
80004b54:	fe f8 03 64 	ld.w	r8,pc[868]
80004b58:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)
80004b5a:	11 89       	ld.ub	r9,r8[0x0]
80004b5c:	3f 28       	mov	r8,-14
80004b5e:	f0 09 18 00 	cp.b	r9,r8
80004b62:	e0 81 01 22 	brne	80004da6 <phy_rx_func+0x91e>
						{
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80004b66:	6e 29       	ld.w	r9,r7[0x8]
80004b68:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80004b6c:	fe f8 03 44 	ld.w	r8,pc[836]
80004b70:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80004b72:	8e 59       	ld.sh	r9,r7[0xa]
80004b74:	fe f8 03 7c 	ld.w	r8,pc[892]
80004b78:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80004b7a:	8e 69       	ld.sh	r9,r7[0xc]
80004b7c:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80004b7e:	8e 79       	ld.sh	r9,r7[0xe]
80004b80:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80004b82:	fe f8 03 3e 	ld.w	r8,pc[830]
80004b86:	fe f9 03 1e 	ld.w	r9,pc[798]
80004b8a:	72 0a       	ld.w	r10,r9[0x0]
80004b8c:	70 09       	ld.w	r9,r8[0x0]
80004b8e:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80004b92:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004b96:	70 09       	ld.w	r9,r8[0x0]
80004b98:	2f f9       	sub	r9,-1
80004b9a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004b9c:	e0 49 01 ff 	cp.w	r9,511
80004ba0:	e0 88 00 16 	brls	80004bcc <phy_rx_func+0x744>
							{
								RxAMBE_IsFillingNext8 = 0;
80004ba4:	30 09       	mov	r9,0
80004ba6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004ba8:	fe f6 02 fc 	ld.w	r6,pc[764]
80004bac:	6c 0c       	ld.w	r12,r6[0x0]
80004bae:	f0 1f 00 c7 	mcall	80004ec8 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004bb2:	fe f8 02 ea 	ld.w	r8,pc[746]
80004bb6:	70 0c       	ld.w	r12,r8[0x0]
80004bb8:	f0 1f 00 b3 	mcall	80004e84 <phy_rx_func+0x9fc>
80004bbc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004bbe:	c0 71       	brne	80004bcc <phy_rx_func+0x744>
								{
									RxMediaState = WAITINGABAB;
80004bc0:	30 09       	mov	r9,0
80004bc2:	fe f8 02 e6 	ld.w	r8,pc[742]
80004bc6:	91 09       	st.w	r8[0x0],r9
80004bc8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004bcc:	fe f9 02 e4 	ld.w	r9,pc[740]
80004bd0:	72 08       	ld.w	r8,r9[0x0]
80004bd2:	20 18       	sub	r8,1
80004bd4:	93 08       	st.w	r9[0x0],r8
80004bd6:	c0 71       	brne	80004be4 <phy_rx_func+0x75c>
								RxMediaState = WAITINGABAB;
80004bd8:	30 09       	mov	r9,0
80004bda:	fe f8 02 ce 	ld.w	r8,pc[718]
80004bde:	91 09       	st.w	r8[0x0],r9
80004be0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80004be4:	fe f8 02 dc 	ld.w	r8,pc[732]
80004be8:	fe f9 02 bc 	ld.w	r9,pc[700]
80004bec:	72 0a       	ld.w	r10,r9[0x0]
80004bee:	70 09       	ld.w	r9,r8[0x0]
80004bf0:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80004bf4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004bf8:	70 09       	ld.w	r9,r8[0x0]
80004bfa:	2f f9       	sub	r9,-1
80004bfc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004bfe:	e0 49 01 ff 	cp.w	r9,511
80004c02:	e0 88 00 16 	brls	80004c2e <phy_rx_func+0x7a6>
							{
								RxAMBE_IsFillingNext8 = 0;
80004c06:	30 09       	mov	r9,0
80004c08:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004c0a:	fe f6 02 9a 	ld.w	r6,pc[666]
80004c0e:	6c 0c       	ld.w	r12,r6[0x0]
80004c10:	f0 1f 00 ae 	mcall	80004ec8 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004c14:	fe f8 02 88 	ld.w	r8,pc[648]
80004c18:	70 0c       	ld.w	r12,r8[0x0]
80004c1a:	f0 1f 00 9b 	mcall	80004e84 <phy_rx_func+0x9fc>
80004c1e:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004c20:	c0 71       	brne	80004c2e <phy_rx_func+0x7a6>
								{
									RxMediaState = WAITINGABAB;
80004c22:	30 09       	mov	r9,0
80004c24:	fe f8 02 84 	ld.w	r8,pc[644]
80004c28:	91 09       	st.w	r8[0x0],r9
80004c2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004c2e:	fe f9 02 82 	ld.w	r9,pc[642]
80004c32:	72 08       	ld.w	r8,r9[0x0]
80004c34:	20 18       	sub	r8,1
80004c36:	93 08       	st.w	r9[0x0],r8
80004c38:	c0 71       	brne	80004c46 <phy_rx_func+0x7be>
								RxMediaState = WAITINGABAB;
80004c3a:	30 09       	mov	r9,0
80004c3c:	fe f8 02 6c 	ld.w	r8,pc[620]
80004c40:	91 09       	st.w	r8[0x0],r9
80004c42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80004c46:	fe f8 02 7a 	ld.w	r8,pc[634]
80004c4a:	fe f9 02 5a 	ld.w	r9,pc[602]
80004c4e:	72 0a       	ld.w	r10,r9[0x0]
80004c50:	70 09       	ld.w	r9,r8[0x0]
80004c52:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80004c56:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004c5a:	70 09       	ld.w	r9,r8[0x0]
80004c5c:	2f f9       	sub	r9,-1
80004c5e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004c60:	e0 49 01 ff 	cp.w	r9,511
80004c64:	e0 88 00 16 	brls	80004c90 <phy_rx_func+0x808>
							{
								RxAMBE_IsFillingNext8 = 0;
80004c68:	30 09       	mov	r9,0
80004c6a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004c6c:	fe f6 02 38 	ld.w	r6,pc[568]
80004c70:	6c 0c       	ld.w	r12,r6[0x0]
80004c72:	f0 1f 00 96 	mcall	80004ec8 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004c76:	fe f8 02 26 	ld.w	r8,pc[550]
80004c7a:	70 0c       	ld.w	r12,r8[0x0]
80004c7c:	f0 1f 00 82 	mcall	80004e84 <phy_rx_func+0x9fc>
80004c80:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004c82:	c0 71       	brne	80004c90 <phy_rx_func+0x808>
								{
									RxMediaState = WAITINGABAB;
80004c84:	30 09       	mov	r9,0
80004c86:	fe f8 02 22 	ld.w	r8,pc[546]
80004c8a:	91 09       	st.w	r8[0x0],r9
80004c8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004c90:	fe f9 02 20 	ld.w	r9,pc[544]
80004c94:	72 08       	ld.w	r8,r9[0x0]
80004c96:	20 18       	sub	r8,1
80004c98:	93 08       	st.w	r9[0x0],r8
80004c9a:	c0 71       	brne	80004ca8 <phy_rx_func+0x820>
								RxMediaState = WAITINGABAB;
80004c9c:	30 09       	mov	r9,0
80004c9e:	fe f8 02 0a 	ld.w	r8,pc[522]
80004ca2:	91 09       	st.w	r8[0x0],r9
80004ca4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80004ca8:	fe f8 02 18 	ld.w	r8,pc[536]
80004cac:	4f e9       	lddpc	r9,80004ea4 <phy_rx_func+0xa1c>
80004cae:	72 0a       	ld.w	r10,r9[0x0]
80004cb0:	70 09       	ld.w	r9,r8[0x0]
80004cb2:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80004cb6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004cba:	70 09       	ld.w	r9,r8[0x0]
80004cbc:	2f f9       	sub	r9,-1
80004cbe:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004cc0:	e0 49 01 ff 	cp.w	r9,511
80004cc4:	e0 88 00 13 	brls	80004cea <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
80004cc8:	30 09       	mov	r9,0
80004cca:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004ccc:	4f 66       	lddpc	r6,80004ea4 <phy_rx_func+0xa1c>
80004cce:	6c 0c       	ld.w	r12,r6[0x0]
80004cd0:	f0 1f 00 7e 	mcall	80004ec8 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004cd4:	4f 28       	lddpc	r8,80004e9c <phy_rx_func+0xa14>
80004cd6:	70 0c       	ld.w	r12,r8[0x0]
80004cd8:	f0 1f 00 6b 	mcall	80004e84 <phy_rx_func+0x9fc>
80004cdc:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004cde:	c0 61       	brne	80004cea <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80004ce0:	30 09       	mov	r9,0
80004ce2:	4f 28       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004ce4:	91 09       	st.w	r8[0x0],r9
80004ce6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004cea:	4f 29       	lddpc	r9,80004eb0 <phy_rx_func+0xa28>
80004cec:	72 08       	ld.w	r8,r9[0x0]
80004cee:	20 18       	sub	r8,1
80004cf0:	93 08       	st.w	r9[0x0],r8
80004cf2:	c0 61       	brne	80004cfe <phy_rx_func+0x876>
								RxMediaState = WAITINGABAB;
80004cf4:	30 09       	mov	r9,0
80004cf6:	4e d8       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004cf8:	91 09       	st.w	r8[0x0],r9
80004cfa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80004cfe:	4f 18       	lddpc	r8,80004ec0 <phy_rx_func+0xa38>
80004d00:	4e 99       	lddpc	r9,80004ea4 <phy_rx_func+0xa1c>
80004d02:	72 0a       	ld.w	r10,r9[0x0]
80004d04:	70 09       	ld.w	r9,r8[0x0]
80004d06:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80004d0a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004d0e:	70 09       	ld.w	r9,r8[0x0]
80004d10:	2f f9       	sub	r9,-1
80004d12:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004d14:	e0 49 01 ff 	cp.w	r9,511
80004d18:	e0 88 00 13 	brls	80004d3e <phy_rx_func+0x8b6>
							{
								RxAMBE_IsFillingNext8 = 0;
80004d1c:	30 09       	mov	r9,0
80004d1e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004d20:	4e 16       	lddpc	r6,80004ea4 <phy_rx_func+0xa1c>
80004d22:	6c 0c       	ld.w	r12,r6[0x0]
80004d24:	f0 1f 00 69 	mcall	80004ec8 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004d28:	4d d8       	lddpc	r8,80004e9c <phy_rx_func+0xa14>
80004d2a:	70 0c       	ld.w	r12,r8[0x0]
80004d2c:	f0 1f 00 56 	mcall	80004e84 <phy_rx_func+0x9fc>
80004d30:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004d32:	c0 61       	brne	80004d3e <phy_rx_func+0x8b6>
								{
									RxMediaState = WAITINGABAB;
80004d34:	30 09       	mov	r9,0
80004d36:	4d d8       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004d38:	91 09       	st.w	r8[0x0],r9
80004d3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004d3e:	4d d9       	lddpc	r9,80004eb0 <phy_rx_func+0xa28>
80004d40:	72 08       	ld.w	r8,r9[0x0]
80004d42:	20 18       	sub	r8,1
80004d44:	93 08       	st.w	r9[0x0],r8
80004d46:	c0 61       	brne	80004d52 <phy_rx_func+0x8ca>
								RxMediaState = WAITINGABAB;
80004d48:	30 09       	mov	r9,0
80004d4a:	4d 88       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004d4c:	91 09       	st.w	r8[0x0],r9
80004d4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80004d52:	4d c8       	lddpc	r8,80004ec0 <phy_rx_func+0xa38>
80004d54:	4d 49       	lddpc	r9,80004ea4 <phy_rx_func+0xa1c>
80004d56:	72 0a       	ld.w	r10,r9[0x0]
80004d58:	70 09       	ld.w	r9,r8[0x0]
80004d5a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80004d5e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80004d62:	70 09       	ld.w	r9,r8[0x0]
80004d64:	2f f9       	sub	r9,-1
80004d66:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004d68:	e0 49 01 ff 	cp.w	r9,511
80004d6c:	e0 88 00 13 	brls	80004d92 <phy_rx_func+0x90a>
							{
								RxAMBE_IsFillingNext8 = 0;
80004d70:	30 09       	mov	r9,0
80004d72:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80004d74:	4c c7       	lddpc	r7,80004ea4 <phy_rx_func+0xa1c>
80004d76:	6e 0c       	ld.w	r12,r7[0x0]
80004d78:	f0 1f 00 54 	mcall	80004ec8 <phy_rx_func+0xa40>
								AMBE_payload_ptr = get_payload_idle_isr();
80004d7c:	4c 88       	lddpc	r8,80004e9c <phy_rx_func+0xa14>
80004d7e:	70 0c       	ld.w	r12,r8[0x0]
80004d80:	f0 1f 00 41 	mcall	80004e84 <phy_rx_func+0x9fc>
80004d84:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80004d86:	c0 61       	brne	80004d92 <phy_rx_func+0x90a>
								{
									RxMediaState = WAITINGABAB;
80004d88:	30 09       	mov	r9,0
80004d8a:	4c 88       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004d8c:	91 09       	st.w	r8[0x0],r9
80004d8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80004d92:	4c 89       	lddpc	r9,80004eb0 <phy_rx_func+0xa28>
80004d94:	72 08       	ld.w	r8,r9[0x0]
80004d96:	20 18       	sub	r8,1
80004d98:	93 08       	st.w	r9[0x0],r8
80004d9a:	c6 61       	brne	80004e66 <phy_rx_func+0x9de>
								RxMediaState = WAITINGABAB;
80004d9c:	30 09       	mov	r9,0
80004d9e:	4c 38       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004da0:	91 09       	st.w	r8[0x0],r9
80004da2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80004da6:	30 09       	mov	r9,0
80004da8:	4c 08       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004daa:	91 09       	st.w	r8[0x0],r9
80004dac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80004db0:	4c 28       	lddpc	r8,80004eb8 <phy_rx_func+0xa30>
80004db2:	11 89       	ld.ub	r9,r8[0x0]
80004db4:	3f 28       	mov	r8,-14
80004db6:	f0 09 18 00 	cp.b	r9,r8
80004dba:	c3 81       	brne	80004e2a <phy_rx_func+0x9a2>
					{
						
						
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80004dbc:	8e 49       	ld.sh	r9,r7[0x8]
80004dbe:	4c d8       	lddpc	r8,80004ef0 <phy_rx_func+0xa68>
80004dc0:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80004dc2:	4c 08       	lddpc	r8,80004ec0 <phy_rx_func+0xa38>
80004dc4:	4b 89       	lddpc	r9,80004ea4 <phy_rx_func+0xa1c>
80004dc6:	72 0a       	ld.w	r10,r9[0x0]
80004dc8:	70 09       	ld.w	r9,r8[0x0]
80004dca:	ef 3b 00 08 	ld.ub	r11,r7[8]
80004dce:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80004dd2:	70 09       	ld.w	r9,r8[0x0]
80004dd4:	2f f9       	sub	r9,-1
80004dd6:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80004dd8:	e0 49 01 ff 	cp.w	r9,511
80004ddc:	e0 88 00 13 	brls	80004e02 <phy_rx_func+0x97a>
						{
							RxAMBE_IsFillingNext8 = 0;
80004de0:	30 09       	mov	r9,0
80004de2:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80004de4:	4b 07       	lddpc	r7,80004ea4 <phy_rx_func+0xa1c>
80004de6:	6e 0c       	ld.w	r12,r7[0x0]
80004de8:	f0 1f 00 38 	mcall	80004ec8 <phy_rx_func+0xa40>
							AMBE_payload_ptr = get_payload_idle_isr();
80004dec:	4a c8       	lddpc	r8,80004e9c <phy_rx_func+0xa14>
80004dee:	70 0c       	ld.w	r12,r8[0x0]
80004df0:	f0 1f 00 25 	mcall	80004e84 <phy_rx_func+0x9fc>
80004df4:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80004df6:	c0 61       	brne	80004e02 <phy_rx_func+0x97a>
							{
								RxMediaState = WAITINGABAB;
80004df8:	30 09       	mov	r9,0
80004dfa:	4a c8       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004dfc:	91 09       	st.w	r8[0x0],r9
80004dfe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80004e02:	4a c9       	lddpc	r9,80004eb0 <phy_rx_func+0xa28>
80004e04:	72 08       	ld.w	r8,r9[0x0]
80004e06:	20 18       	sub	r8,1
80004e08:	93 08       	st.w	r9[0x0],r8
80004e0a:	c0 61       	brne	80004e16 <phy_rx_func+0x98e>
							RxMediaState = WAITINGABAB;
80004e0c:	30 09       	mov	r9,0
80004e0e:	4a 78       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004e10:	91 09       	st.w	r8[0x0],r9
80004e12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
80004e16:	20 18       	sub	r8,1
80004e18:	4a 69       	lddpc	r9,80004eb0 <phy_rx_func+0xa28>
80004e1a:	93 08       	st.w	r9[0x0],r8
80004e1c:	58 08       	cp.w	r8,0
80004e1e:	c2 41       	brne	80004e66 <phy_rx_func+0x9de>
							RxMediaState = WAITINGABAB;
80004e20:	30 09       	mov	r9,0
80004e22:	4a 28       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004e24:	91 09       	st.w	r8[0x0],r9
80004e26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						*******************/
						
								
					}
					
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80004e2a:	4a 48       	lddpc	r8,80004eb8 <phy_rx_func+0xa30>
80004e2c:	11 89       	ld.ub	r9,r8[0x0]
80004e2e:	30 48       	mov	r8,4
80004e30:	f0 09 18 00 	cp.b	r9,r8
80004e34:	c0 70       	breq	80004e42 <phy_rx_func+0x9ba>
80004e36:	4a 18       	lddpc	r8,80004eb8 <phy_rx_func+0xa30>
80004e38:	11 89       	ld.ub	r9,r8[0x0]
80004e3a:	30 38       	mov	r8,3
80004e3c:	f0 09 18 00 	cp.b	r9,r8
80004e40:	c1 01       	brne	80004e60 <phy_rx_func+0x9d8>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80004e42:	6e 29       	ld.w	r9,r7[0x8]
80004e44:	4a 48       	lddpc	r8,80004ed4 <phy_rx_func+0xa4c>
80004e46:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80004e48:	6e 39       	ld.w	r9,r7[0xc]
80004e4a:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80004e4c:	49 99       	lddpc	r9,80004eb0 <phy_rx_func+0xa28>
80004e4e:	72 08       	ld.w	r8,r9[0x0]
80004e50:	20 88       	sub	r8,8
80004e52:	93 08       	st.w	r9[0x0],r8
80004e54:	c0 91       	brne	80004e66 <phy_rx_func+0x9de>
						{
					
							RxBytesWaiting = 0;
80004e56:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80004e58:	49 49       	lddpc	r9,80004ea8 <phy_rx_func+0xa20>
80004e5a:	93 08       	st.w	r9[0x0],r8
80004e5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					//}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80004e60:	30 09       	mov	r9,0
80004e62:	49 28       	lddpc	r8,80004ea8 <phy_rx_func+0xa20>
80004e64:	91 09       	st.w	r8[0x0],r9
80004e66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004e6a:	00 00       	add	r0,r0
80004e6c:	00 00       	add	r0,r0
80004e6e:	10 4c       	or	r12,r8
80004e70:	00 00       	add	r0,r0
80004e72:	10 6c       	and	r12,r8
80004e74:	00 00       	add	r0,r0
80004e76:	10 3c       	cp.w	r12,r8
80004e78:	00 00       	add	r0,r0
80004e7a:	10 60       	and	r0,r8
80004e7c:	00 00       	add	r0,r0
80004e7e:	10 14       	sub	r4,r8
80004e80:	00 00       	add	r0,r0
80004e82:	10 18       	sub	r8,r8
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	3d a8       	mov	r8,-38
80004e88:	00 00       	add	r0,r0
80004e8a:	10 70       	tst	r0,r8
80004e8c:	80 00       	ld.sh	r0,r0[0x0]
80004e8e:	8f 8c       	st.w	r7[0x20],r12
80004e90:	00 00       	add	r0,r0
80004e92:	10 48       	or	r8,r8
80004e94:	80 00       	ld.sh	r0,r0[0x0]
80004e96:	3c f4       	mov	r4,-49
80004e98:	00 00       	add	r0,r0
80004e9a:	10 7c       	tst	r12,r8
80004e9c:	00 00       	add	r0,r0
80004e9e:	10 04       	add	r4,r8
80004ea0:	00 00       	add	r0,r0
80004ea2:	10 10       	sub	r0,r8
80004ea4:	00 00       	add	r0,r0
80004ea6:	10 0c       	add	r12,r8
80004ea8:	00 00       	add	r0,r0
80004eaa:	10 54       	eor	r4,r8
80004eac:	00 00       	add	r0,r0
80004eae:	10 00       	add	r0,r8
80004eb0:	00 00       	add	r0,r0
80004eb2:	10 64       	and	r4,r8
80004eb4:	00 00       	add	r0,r0
80004eb6:	0a 42       	or	r2,r5
80004eb8:	00 00       	add	r0,r0
80004eba:	10 30       	cp.w	r0,r8
80004ebc:	00 00       	add	r0,r0
80004ebe:	0a 40       	or	r0,r5
80004ec0:	00 00       	add	r0,r0
80004ec2:	10 5c       	eor	r12,r8
80004ec4:	80 00       	ld.sh	r0,r0[0x0]
80004ec6:	aa 06       	st.h	r5[0x0],r6
80004ec8:	80 00       	ld.sh	r0,r0[0x0]
80004eca:	44 28       	lddsp	r8,sp[0x108]
80004ecc:	00 00       	add	r0,r0
80004ece:	14 54       	eor	r4,r10
80004ed0:	80 00       	ld.sh	r0,r0[0x0]
80004ed2:	3b c8       	mov	r8,-68
80004ed4:	00 00       	add	r0,r0
80004ed6:	10 24       	rsub	r4,r8
80004ed8:	80 01       	ld.sh	r1,r0[0x0]
80004eda:	94 1c       	ld.sh	r12,r10[0x2]
80004edc:	80 00       	ld.sh	r0,r0[0x0]
80004ede:	a0 84       	st.b	r0[0x0],r4
80004ee0:	80 01       	ld.sh	r1,r0[0x0]
80004ee2:	94 30       	ld.sh	r0,r10[0x6]
80004ee4:	00 00       	add	r0,r0
80004ee6:	10 34       	cp.w	r4,r8
80004ee8:	00 00       	add	r0,r0
80004eea:	0f fc       	ld.ub	r12,r7[0x7]
80004eec:	00 00       	add	r0,r0
80004eee:	0a 41       	or	r1,r5
80004ef0:	00 00       	add	r0,r0
80004ef2:	13 5c       	ld.sh	r12,--r9

80004ef4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004ef4:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004ef6:	49 88       	lddpc	r8,80004f54 <pdca_int_handler+0x60>
80004ef8:	11 89       	ld.ub	r9,r8[0x0]
80004efa:	ec 19 00 01 	eorl	r9,0x1
80004efe:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004f00:	11 89       	ld.ub	r9,r8[0x0]
80004f02:	a5 69       	lsl	r9,0x4
80004f04:	2f c9       	sub	r9,-4
80004f06:	49 5a       	lddpc	r10,80004f58 <pdca_int_handler+0x64>
80004f08:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80004f0a:	fe 7a 00 40 	mov	r10,-65472
80004f0e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004f10:	30 39       	mov	r9,3
80004f12:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004f14:	11 8a       	ld.ub	r10,r8[0x0]
80004f16:	a5 6a       	lsl	r10,0x4
80004f18:	2f ca       	sub	r10,-4
80004f1a:	49 18       	lddpc	r8,80004f5c <pdca_int_handler+0x68>
80004f1c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004f1e:	fe 78 00 00 	mov	r8,-65536
80004f22:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004f24:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004f26:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80004f28:	48 e8       	lddpc	r8,80004f60 <pdca_int_handler+0x6c>
80004f2a:	70 08       	ld.w	r8,r8[0x0]
80004f2c:	58 08       	cp.w	r8,0
80004f2e:	c0 70       	breq	80004f3c <pdca_int_handler+0x48>
80004f30:	48 99       	lddpc	r9,80004f54 <pdca_int_handler+0x60>
80004f32:	13 89       	ld.ub	r9,r9[0x0]
80004f34:	a5 69       	lsl	r9,0x4
80004f36:	48 ac       	lddpc	r12,80004f5c <pdca_int_handler+0x68>
80004f38:	12 0c       	add	r12,r9
80004f3a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80004f3c:	48 a8       	lddpc	r8,80004f64 <pdca_int_handler+0x70>
80004f3e:	70 08       	ld.w	r8,r8[0x0]
80004f40:	58 08       	cp.w	r8,0
80004f42:	c0 70       	breq	80004f50 <pdca_int_handler+0x5c>
80004f44:	48 49       	lddpc	r9,80004f54 <pdca_int_handler+0x60>
80004f46:	13 89       	ld.ub	r9,r9[0x0]
80004f48:	a5 69       	lsl	r9,0x4
80004f4a:	48 4c       	lddpc	r12,80004f58 <pdca_int_handler+0x64>
80004f4c:	12 0c       	add	r12,r9
80004f4e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80004f50:	d4 02       	popm	lr
80004f52:	d6 03       	rete
80004f54:	00 00       	add	r0,r0
80004f56:	46 5c       	lddsp	r12,sp[0x194]
80004f58:	00 00       	add	r0,r0
80004f5a:	46 84       	lddsp	r4,sp[0x1a0]
80004f5c:	00 00       	add	r0,r0
80004f5e:	46 64       	lddsp	r4,sp[0x198]
80004f60:	00 00       	add	r0,r0
80004f62:	10 80       	andn	r0,r8
80004f64:	00 00       	add	r0,r0
80004f66:	10 84       	andn	r4,r8

80004f68 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80004f68:	fe 78 10 00 	mov	r8,-61440
80004f6c:	e0 69 0d c0 	mov	r9,3520
80004f70:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004f74:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80004f78:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004f7c:	fe 78 34 00 	mov	r8,-52224
80004f80:	e0 69 80 00 	mov	r9,32768
80004f84:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80004f86:	30 09       	mov	r9,0
80004f88:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80004f8a:	e0 69 04 21 	mov	r9,1057
80004f8e:	ea 19 3f 20 	orh	r9,0x3f20
80004f92:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004f94:	e0 69 02 9f 	mov	r9,671
80004f98:	ea 19 01 00 	orh	r9,0x100
80004f9c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80004f9e:	e0 6a 04 02 	mov	r10,1026
80004fa2:	ea 1a 3f 20 	orh	r10,0x3f20
80004fa6:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80004fa8:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004faa:	5e fc       	retal	r12

80004fac <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004fac:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004fae:	30 19       	mov	r9,1
80004fb0:	49 78       	lddpc	r8,8000500c <local_start_PDC+0x60>
80004fb2:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004fb4:	fe 78 00 00 	mov	r8,-65536
80004fb8:	30 7b       	mov	r11,7
80004fba:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004fbc:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80004fbe:	49 59       	lddpc	r9,80005010 <local_start_PDC+0x64>
80004fc0:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004fc4:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004fc6:	30 3a       	mov	r10,3
80004fc8:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004fca:	30 1c       	mov	r12,1
80004fcc:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004fce:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004fd0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004fd2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004fd4:	30 2c       	mov	r12,2
80004fd6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004fd8:	48 f9       	lddpc	r9,80005014 <local_start_PDC+0x68>
80004fda:	e0 68 5a 5a 	mov	r8,23130
80004fde:	ea 18 ab cd 	orh	r8,0xabcd
80004fe2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004fe4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004fe6:	30 0e       	mov	lr,0
80004fe8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004fea:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004fec:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004fee:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004ff0:	fe 78 00 40 	mov	r8,-65472
80004ff4:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004ff6:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004ff8:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004ffc:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004ffe:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80005000:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80005002:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80005004:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80005006:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80005008:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000500a:	d8 02       	popm	pc
8000500c:	00 00       	add	r0,r0
8000500e:	46 5c       	lddsp	r12,sp[0x194]
80005010:	00 00       	add	r0,r0
80005012:	46 64       	lddsp	r4,sp[0x198]
80005014:	00 00       	add	r0,r0
80005016:	46 84       	lddsp	r4,sp[0x1a0]

80005018 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80005018:	48 38       	lddpc	r8,80005024 <register_rx_tx_func+0xc>
8000501a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
8000501c:	48 38       	lddpc	r8,80005028 <register_rx_tx_func+0x10>
8000501e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80005020:	5e fc       	retal	r12
80005022:	00 00       	add	r0,r0
80005024:	00 00       	add	r0,r0
80005026:	10 80       	andn	r0,r8
80005028:	00 00       	add	r0,r0
8000502a:	10 84       	andn	r4,r8

8000502c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
8000502c:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000502e:	fe 78 10 00 	mov	r8,-61440
80005032:	30 29       	mov	r9,2
80005034:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80005038:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000503c:	10 99       	mov	r9,r8
8000503e:	f2 f8 01 60 	ld.w	r8,r9[352]
80005042:	e2 18 00 02 	andl	r8,0x2,COH
80005046:	cf c0       	breq	8000503e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80005048:	fe 79 10 00 	mov	r9,-61440
8000504c:	f2 f8 01 60 	ld.w	r8,r9[352]
80005050:	e2 18 00 02 	andl	r8,0x2,COH
80005054:	cf c1       	brne	8000504c <ssc_init+0x20>
				
    INTC_register_interrupt (
80005056:	30 3a       	mov	r10,3
80005058:	36 0b       	mov	r11,96
8000505a:	48 bc       	lddpc	r12,80005084 <ssc_init+0x58>
8000505c:	f0 1f 00 0b 	mcall	80005088 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80005060:	f0 1f 00 0b 	mcall	8000508c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80005064:	f0 1f 00 0b 	mcall	80005090 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80005068:	fe 79 00 00 	mov	r9,-65536
8000506c:	30 18       	mov	r8,1
8000506e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80005070:	fe 7a 00 40 	mov	r10,-65472
80005074:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80005076:	e0 6b 01 01 	mov	r11,257
8000507a:	fe 7a 34 00 	mov	r10,-52224
8000507e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80005080:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80005082:	d8 02       	popm	pc
80005084:	80 00       	ld.sh	r0,r0[0x0]
80005086:	4e f4       	lddpc	r4,80005240 <xcmp_exec_func+0x28>
80005088:	80 00       	ld.sh	r0,r0[0x0]
8000508a:	5c 74       	castu.h	r4
8000508c:	80 00       	ld.sh	r0,r0[0x0]
8000508e:	4f 68       	lddpc	r8,80005264 <xcmp_init+0x4>
80005090:	80 00       	ld.sh	r0,r0[0x0]
80005092:	4f ac       	lddpc	r12,80005278 <xcmp_init+0x18>

80005094 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80005094:	48 28       	lddpc	r8,8000509c <xcmp_register_app_list+0x8>
80005096:	91 0c       	st.w	r8[0x0],r12
}
80005098:	5e fc       	retal	r12
8000509a:	00 00       	add	r0,r0
8000509c:	00 00       	add	r0,r0
8000509e:	46 a4       	lddsp	r4,sp[0x1a8]

800050a0 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800050a0:	eb cd 40 80 	pushm	r7,lr
800050a4:	fa cd 01 00 	sub	sp,sp,256
800050a8:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800050aa:	16 98       	mov	r8,r11
800050ac:	2f 08       	sub	r8,-16
800050ae:	af a8       	sbr	r8,0xe
800050b0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800050b2:	3f f8       	mov	r8,-1
800050b4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
800050b6:	30 b9       	mov	r9,11
800050b8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
800050ba:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
800050bc:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
800050be:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800050c0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
800050c2:	f6 ca ff fe 	sub	r10,r11,-2
800050c6:	18 9b       	mov	r11,r12
800050c8:	fa cc ff f0 	sub	r12,sp,-16
800050cc:	f0 1f 00 05 	mcall	800050e0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
800050d0:	2f e7       	sub	r7,-2
800050d2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
800050d4:	1a 9c       	mov	r12,sp
800050d6:	f0 1f 00 04 	mcall	800050e4 <xcmp_tx+0x44>
}
800050da:	2c 0d       	sub	sp,-256
800050dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800050e0:	80 00       	ld.sh	r0,r0[0x0]
800050e2:	a8 be       	st.b	r4[0x3],lr
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	55 5c       	stdsp	sp[0x154],r12

800050e8 <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
800050e8:	d4 01       	pushm	lr
800050ea:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
800050ee:	e0 68 04 21 	mov	r8,1057
800050f2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
800050f4:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
800050f8:	30 09       	mov	r9,0
800050fa:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
800050fc:	30 19       	mov	r9,1
800050fe:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
80005100:	30 39       	mov	r9,3
80005102:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80005104:	30 3b       	mov	r11,3
80005106:	fa cc ff fe 	sub	r12,sp,-2
8000510a:	f0 1f 00 03 	mcall	80005114 <xcmp_exit_device_control_mode+0x2c>
}
8000510e:	2c dd       	sub	sp,-204
80005110:	d8 02       	popm	pc
80005112:	00 00       	add	r0,r0
80005114:	80 00       	ld.sh	r0,r0[0x0]
80005116:	50 a0       	stdsp	sp[0x28],r0

80005118 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80005118:	d4 01       	pushm	lr
8000511a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
8000511e:	e0 68 04 21 	mov	r8,1057
80005122:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80005124:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80005128:	30 19       	mov	r9,1
8000512a:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
8000512c:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
8000512e:	30 39       	mov	r9,3
80005130:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80005132:	30 3b       	mov	r11,3
80005134:	fa cc ff fe 	sub	r12,sp,-2
80005138:	f0 1f 00 02 	mcall	80005140 <xcmp_enter_device_control_mode+0x28>
}
8000513c:	2c dd       	sub	sp,-204
8000513e:	d8 02       	popm	pc
80005140:	80 00       	ld.sh	r0,r0[0x0]
80005142:	50 a0       	stdsp	sp[0x28],r0

80005144 <xcmp_audio_route_AMBE>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_AMBE(void)
{
80005144:	d4 01       	pushm	lr
80005146:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
8000514a:	e0 68 04 14 	mov	r8,1044
8000514e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80005150:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80005154:	30 19       	mov	r9,1
80005156:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80005158:	30 09       	mov	r9,0
8000515a:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
8000515c:	30 49       	mov	r9,4
8000515e:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//
	//
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80005160:	30 fa       	mov	r10,15
80005162:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80005164:	30 c9       	mov	r9,12
80005166:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80005168:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
8000516a:	b0 ea       	st.b	r8[0x6],r10

	
	ptr->RoutingData[2].audioInput = Tx_Voice_Header;//IN_Option_Board;
8000516c:	31 1a       	mov	r10,17
8000516e:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80005170:	f1 69 00 08 	st.b	r8[8],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[3].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80005174:	31 3a       	mov	r10,19
80005176:	f1 6a 00 09 	st.b	r8[9],r10
	ptr->RoutingData[3].audioOutput = OUT_Option_Board;// OUT_Speaker;
8000517a:	f1 69 00 0a 	st.b	r8[10],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
8000517e:	30 bb       	mov	r11,11
80005180:	fa cc ff fe 	sub	r12,sp,-2
80005184:	f0 1f 00 02 	mcall	8000518c <xcmp_audio_route_AMBE+0x48>
}
80005188:	2c dd       	sub	sp,-204
8000518a:	d8 02       	popm	pc
8000518c:	80 00       	ld.sh	r0,r0[0x0]
8000518e:	50 a0       	stdsp	sp[0x28],r0

80005190 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80005190:	d4 01       	pushm	lr
80005192:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80005196:	e0 68 04 65 	mov	r8,1125
8000519a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
8000519c:	fa cc ff fe 	sub	r12,sp,-2
800051a0:	30 18       	mov	r8,1
800051a2:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
800051a4:	30 1b       	mov	r11,1
800051a6:	f0 1f 00 03 	mcall	800051b0 <xcmp_enter_enhanced_OB_mode+0x20>
}
800051aa:	2c dd       	sub	sp,-204
800051ac:	d8 02       	popm	pc
800051ae:	00 00       	add	r0,r0
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	50 a0       	stdsp	sp[0x28],r0

800051b4 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800051b4:	d4 01       	pushm	lr
800051b6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800051ba:	fe 78 b4 00 	mov	r8,-19456
800051be:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800051c0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
800051c4:	30 89       	mov	r9,8
800051c6:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800051c8:	30 19       	mov	r9,1
800051ca:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800051cc:	30 09       	mov	r9,0
800051ce:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800051d0:	30 5a       	mov	r10,5
800051d2:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800051d4:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800051d6:	30 7a       	mov	r10,7
800051d8:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800051da:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800051dc:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800051de:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800051e2:	30 9b       	mov	r11,9
800051e4:	fa cc ff fe 	sub	r12,sp,-2
800051e8:	f0 1f 00 02 	mcall	800051f0 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800051ec:	2c dd       	sub	sp,-204
800051ee:	d8 02       	popm	pc
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	50 a0       	stdsp	sp[0x28],r0

800051f4 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800051f4:	d4 01       	pushm	lr
800051f6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800051fa:	fe 78 80 00 	mov	r8,-32768
800051fe:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80005200:	30 38       	mov	r8,3
80005202:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80005204:	30 1b       	mov	r11,1
80005206:	fa cc ff fe 	sub	r12,sp,-2
8000520a:	f0 1f 00 03 	mcall	80005214 <xcmp_opcode_not_supported+0x20>
}
8000520e:	2c dd       	sub	sp,-204
80005210:	d8 02       	popm	pc
80005212:	00 00       	add	r0,r0
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	50 a0       	stdsp	sp[0x28],r0

80005218 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80005218:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
8000521a:	96 88       	ld.uh	r8,r11[0x0]
8000521c:	e2 18 f0 00 	andl	r8,0xf000,COH
80005220:	e0 48 80 00 	cp.w	r8,32768
80005224:	c0 f0       	breq	80005242 <xcmp_exec_func+0x2a>
80005226:	e0 48 b0 00 	cp.w	r8,45056
8000522a:	c1 20       	breq	8000524e <xcmp_exec_func+0x36>
8000522c:	58 08       	cp.w	r8,0
8000522e:	c1 51       	brne	80005258 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80005230:	78 08       	ld.w	r8,r12[0x0]
80005232:	58 08       	cp.w	r8,0
80005234:	c0 40       	breq	8000523c <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80005236:	16 9c       	mov	r12,r11
80005238:	5d 18       	icall	r8
8000523a:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
8000523c:	f0 1f 00 08 	mcall	8000525c <xcmp_exec_func+0x44>
80005240:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80005242:	78 18       	ld.w	r8,r12[0x4]
80005244:	58 08       	cp.w	r8,0
80005246:	c0 90       	breq	80005258 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80005248:	16 9c       	mov	r12,r11
8000524a:	5d 18       	icall	r8
8000524c:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000524e:	78 28       	ld.w	r8,r12[0x8]
80005250:	58 08       	cp.w	r8,0
80005252:	c0 30       	breq	80005258 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80005254:	16 9c       	mov	r12,r11
80005256:	5d 18       	icall	r8
80005258:	d8 02       	popm	pc
8000525a:	00 00       	add	r0,r0
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	51 f4       	stdsp	sp[0x7c],r4

80005260 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80005260:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
80005262:	f0 1f 00 0d 	mcall	80005294 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80005266:	48 dc       	lddpc	r12,80005298 <xcmp_init+0x38>
80005268:	f0 1f 00 0d 	mcall	8000529c <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
8000526c:	30 4b       	mov	r11,4
8000526e:	31 4c       	mov	r12,20
80005270:	f0 1f 00 0c 	mcall	800052a0 <xcmp_init+0x40>
80005274:	48 c8       	lddpc	r8,800052a4 <xcmp_init+0x44>
80005276:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80005278:	30 09       	mov	r9,0
8000527a:	1a d9       	st.w	--sp,r9
8000527c:	1a d9       	st.w	--sp,r9
8000527e:	1a d9       	st.w	--sp,r9
80005280:	30 38       	mov	r8,3
80005282:	e0 6a 01 80 	mov	r10,384
80005286:	48 9b       	lddpc	r11,800052a8 <xcmp_init+0x48>
80005288:	48 9c       	lddpc	r12,800052ac <xcmp_init+0x4c>
8000528a:	f0 1f 00 0a 	mcall	800052b0 <xcmp_init+0x50>
8000528e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80005290:	d8 02       	popm	pc
80005292:	00 00       	add	r0,r0
80005294:	80 00       	ld.sh	r0,r0[0x0]
80005296:	56 40       	stdsp	sp[0x190],r0
80005298:	80 00       	ld.sh	r0,r0[0x0]
8000529a:	53 b0       	stdsp	sp[0xec],r0
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	53 fc       	stdsp	sp[0xfc],r12
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	94 60       	ld.sh	r0,r10[0xc]
800052a4:	00 00       	add	r0,r0
800052a6:	10 94       	mov	r4,r8
800052a8:	80 01       	ld.sh	r1,r0[0x0]
800052aa:	94 3c       	ld.sh	r12,r10[0x6]
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	52 b4       	stdsp	sp[0xac],r4
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	9b 34       	st.w	sp[0xc],r4

800052b4 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800052b4:	d4 31       	pushm	r0-r7,lr
800052b6:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
800052b8:	4b 16       	lddpc	r6,8000537c <xcmp_rx_process+0xc8>
800052ba:	30 05       	mov	r5,0
800052bc:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800052be:	4b 13       	lddpc	r3,80005380 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800052c0:	4b 12       	lddpc	r2,80005384 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800052c2:	4b 21       	lddpc	r1,80005388 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800052c4:	4b 20       	lddpc	r0,8000538c <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
800052c6:	6c 0c       	ld.w	r12,r6[0x0]
800052c8:	0a 99       	mov	r9,r5
800052ca:	08 9a       	mov	r10,r4
800052cc:	1a 9b       	mov	r11,sp
800052ce:	f0 1f 00 31 	mcall	80005390 <xcmp_rx_process+0xdc>
800052d2:	58 1c       	cp.w	r12,1
800052d4:	cf 91       	brne	800052c6 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800052d6:	40 0b       	lddsp	r11,sp[0x0]
800052d8:	58 0b       	cp.w	r11,0
800052da:	cf 60       	breq	800052c6 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800052dc:	96 0a       	ld.sh	r10,r11[0x0]
800052de:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800052e2:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
800052e6:	59 c8       	cp.w	r8,28
800052e8:	c1 e0       	breq	80005324 <xcmp_rx_process+0x70>
800052ea:	e0 89 00 07 	brgt	800052f8 <xcmp_rx_process+0x44>
800052ee:	58 e8       	cp.w	r8,14
800052f0:	c0 e0       	breq	8000530c <xcmp_rx_process+0x58>
800052f2:	58 f8       	cp.w	r8,15
800052f4:	c2 41       	brne	8000533c <xcmp_rx_process+0x88>
800052f6:	c0 f8       	rjmp	80005314 <xcmp_rx_process+0x60>
800052f8:	e0 48 01 09 	cp.w	r8,265
800052fc:	c1 80       	breq	8000532c <xcmp_rx_process+0x78>
800052fe:	e0 48 01 0a 	cp.w	r8,266
80005302:	c1 90       	breq	80005334 <xcmp_rx_process+0x80>
80005304:	e0 48 00 2c 	cp.w	r8,44
80005308:	c1 a1       	brne	8000533c <xcmp_rx_process+0x88>
8000530a:	c0 98       	rjmp	8000531c <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
8000530c:	4a 2c       	lddpc	r12,80005394 <xcmp_rx_process+0xe0>
8000530e:	f0 1f 00 23 	mcall	80005398 <xcmp_rx_process+0xe4>
					break;
80005312:	c2 f8       	rjmp	80005370 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80005314:	4a 2c       	lddpc	r12,8000539c <xcmp_rx_process+0xe8>
80005316:	f0 1f 00 21 	mcall	80005398 <xcmp_rx_process+0xe4>
					break;
8000531a:	c2 b8       	rjmp	80005370 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
8000531c:	4a 1c       	lddpc	r12,800053a0 <xcmp_rx_process+0xec>
8000531e:	f0 1f 00 1f 	mcall	80005398 <xcmp_rx_process+0xe4>
					break;
80005322:	c2 78       	rjmp	80005370 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80005324:	04 9c       	mov	r12,r2
80005326:	f0 1f 00 1d 	mcall	80005398 <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000532a:	c2 38       	rjmp	80005370 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000532c:	02 9c       	mov	r12,r1
8000532e:	f0 1f 00 1b 	mcall	80005398 <xcmp_rx_process+0xe4>
					break;
80005332:	c1 f8       	rjmp	80005370 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80005334:	00 9c       	mov	r12,r0
80005336:	f0 1f 00 19 	mcall	80005398 <xcmp_rx_process+0xe4>
					break;
8000533a:	c1 b8       	rjmp	80005370 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000533c:	12 98       	mov	r8,r9
8000533e:	e2 18 04 00 	andl	r8,0x400,COH
80005342:	c0 70       	breq	80005350 <xcmp_rx_process+0x9c>
80005344:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80005348:	e0 48 00 68 	cp.w	r8,104
8000534c:	e0 8a 00 08 	brle	8000535c <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80005350:	e2 19 f0 00 	andl	r9,0xf000,COH
80005354:	c0 e1       	brne	80005370 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80005356:	f0 1f 00 14 	mcall	800053a4 <xcmp_rx_process+0xf0>
8000535a:	c0 b8       	rjmp	80005370 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
8000535c:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80005360:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80005364:	49 19       	lddpc	r9,800053a8 <xcmp_rx_process+0xf4>
80005366:	72 08       	ld.w	r8,r9[0x0]
80005368:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000536c:	f0 1f 00 0b 	mcall	80005398 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80005370:	66 0c       	ld.w	r12,r3[0x0]
80005372:	40 0b       	lddsp	r11,sp[0x0]
80005374:	f0 1f 00 0e 	mcall	800053ac <xcmp_rx_process+0xf8>
80005378:	ca 7b       	rjmp	800052c6 <xcmp_rx_process+0x12>
8000537a:	00 00       	add	r0,r0
8000537c:	00 00       	add	r0,r0
8000537e:	10 94       	mov	r4,r8
80005380:	00 00       	add	r0,r0
80005382:	10 18       	sub	r8,r8
80005384:	00 00       	add	r0,r0
80005386:	10 a4       	st.w	r8++,r4
80005388:	00 00       	add	r0,r0
8000538a:	10 98       	mov	r8,r8
8000538c:	00 00       	add	r0,r0
8000538e:	10 b0       	st.h	r8++,r0
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	90 fc       	ld.uh	r12,r8[0xe]
80005394:	00 00       	add	r0,r0
80005396:	10 c8       	st.b	r8++,r8
80005398:	80 00       	ld.sh	r0,r0[0x0]
8000539a:	52 18       	stdsp	sp[0x84],r8
8000539c:	00 00       	add	r0,r0
8000539e:	10 88       	andn	r8,r8
800053a0:	00 00       	add	r0,r0
800053a2:	10 bc       	st.h	r8++,r12
800053a4:	80 00       	ld.sh	r0,r0[0x0]
800053a6:	51 f4       	stdsp	sp[0x7c],r4
800053a8:	00 00       	add	r0,r0
800053aa:	46 a4       	lddsp	r4,sp[0x1a8]
800053ac:	80 00       	ld.sh	r0,r0[0x0]
800053ae:	3d 2c       	mov	r12,-46

800053b0 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800053b0:	eb cd 40 90 	pushm	r4,r7,lr
800053b4:	20 1d       	sub	sp,4
800053b6:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800053ba:	48 c8       	lddpc	r8,800053e8 <xcmp_rx+0x38>
800053bc:	70 0c       	ld.w	r12,r8[0x0]
800053be:	f0 1f 00 0c 	mcall	800053ec <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800053c2:	c1 00       	breq	800053e2 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800053c4:	fa c7 ff fc 	sub	r7,sp,-4
800053c8:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800053ca:	e0 6a 00 ca 	mov	r10,202
800053ce:	08 9b       	mov	r11,r4
800053d0:	f0 1f 00 08 	mcall	800053f0 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800053d4:	48 88       	lddpc	r8,800053f4 <xcmp_rx+0x44>
800053d6:	70 0c       	ld.w	r12,r8[0x0]
800053d8:	30 09       	mov	r9,0
800053da:	12 9a       	mov	r10,r9
800053dc:	1a 9b       	mov	r11,sp
800053de:	f0 1f 00 07 	mcall	800053f8 <xcmp_rx+0x48>
	}	
}
800053e2:	2f fd       	sub	sp,-4
800053e4:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800053e8:	00 00       	add	r0,r0
800053ea:	10 18       	sub	r8,r8
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	43 44       	lddsp	r4,sp[0xd0]
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	a8 be       	st.b	r4[0x3],lr
800053f4:	00 00       	add	r0,r0
800053f6:	10 94       	mov	r4,r8
800053f8:	80 00       	ld.sh	r0,r0[0x0]
800053fa:	93 08       	st.w	r9[0x0],r8

800053fc <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800053fc:	48 28       	lddpc	r8,80005404 <xnl_register_xcmp_func+0x8>
800053fe:	91 0c       	st.w	r8[0x0],r12
}
80005400:	5e fc       	retal	r12
80005402:	00 00       	add	r0,r0
80005404:	00 00       	add	r0,r0
80005406:	10 f8       	st.b	--r8,r8

80005408 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80005408:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000540a:	48 88       	lddpc	r8,80005428 <xnl_get_msg_ack_func+0x20>
8000540c:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
8000540e:	98 49       	ld.sh	r9,r12[0x8]
80005410:	f0 09 19 00 	cp.h	r9,r8
80005414:	c0 81       	brne	80005424 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80005416:	48 68       	lddpc	r8,8000542c <xnl_get_msg_ack_func+0x24>
80005418:	70 0c       	ld.w	r12,r8[0x0]
8000541a:	30 09       	mov	r9,0
8000541c:	12 9a       	mov	r10,r9
8000541e:	12 9b       	mov	r11,r9
80005420:	f0 1f 00 04 	mcall	80005430 <xnl_get_msg_ack_func+0x28>
80005424:	d8 02       	popm	pc
80005426:	00 00       	add	r0,r0
80005428:	00 00       	add	r0,r0
8000542a:	10 d8       	st.w	--r8,r8
8000542c:	00 00       	add	r0,r0
8000542e:	10 d4       	st.w	--r8,r4
80005430:	80 00       	ld.sh	r0,r0[0x0]
80005432:	93 08       	st.w	r9[0x0],r8

80005434 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80005434:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80005436:	4a 86       	lddpc	r6,800054d4 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80005438:	4a 82       	lddpc	r2,800054d8 <xnl_tx_process+0xa4>
8000543a:	4a 94       	lddpc	r4,800054dc <xnl_tx_process+0xa8>
8000543c:	30 07       	mov	r7,0
8000543e:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80005440:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80005442:	4a 85       	lddpc	r5,800054e0 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80005444:	4a 83       	lddpc	r3,800054e4 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80005446:	6c 08       	ld.w	r8,r6[0x0]
80005448:	58 08       	cp.w	r8,0
8000544a:	c0 40       	breq	80005452 <xnl_tx_process+0x1e>
8000544c:	58 18       	cp.w	r8,1
8000544e:	cf d1       	brne	80005448 <xnl_tx_process+0x14>
80005450:	c2 08       	rjmp	80005490 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80005452:	64 0c       	ld.w	r12,r2[0x0]
80005454:	0e 99       	mov	r9,r7
80005456:	02 9a       	mov	r10,r1
80005458:	08 9b       	mov	r11,r4
8000545a:	f0 1f 00 24 	mcall	800054e8 <xnl_tx_process+0xb4>
8000545e:	58 1c       	cp.w	r12,1
80005460:	cf 31       	brne	80005446 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80005462:	68 0c       	ld.w	r12,r4[0x0]
80005464:	58 0c       	cp.w	r12,0
80005466:	cf 00       	breq	80005446 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80005468:	98 28       	ld.sh	r8,r12[0x4]
8000546a:	e0 08 19 00 	cp.h	r8,r0
8000546e:	c0 41       	brne	80005476 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80005470:	f0 1f 00 1f 	mcall	800054ec <xnl_tx_process+0xb8>
						break;
80005474:	ce 9b       	rjmp	80005446 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80005476:	f0 1f 00 1f 	mcall	800054f0 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
8000547a:	30 18       	mov	r8,1
8000547c:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000547e:	66 0c       	ld.w	r12,r3[0x0]
80005480:	0e 99       	mov	r9,r7
80005482:	0e 9a       	mov	r10,r7
80005484:	0e 9b       	mov	r11,r7
80005486:	f0 1f 00 19 	mcall	800054e8 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
8000548a:	30 18       	mov	r8,1
8000548c:	8d 08       	st.w	r6[0x0],r8
8000548e:	cd cb       	rjmp	80005446 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80005490:	66 0c       	ld.w	r12,r3[0x0]
80005492:	0e 99       	mov	r9,r7
80005494:	36 4a       	mov	r10,100
80005496:	0e 9b       	mov	r11,r7
80005498:	f0 1f 00 14 	mcall	800054e8 <xnl_tx_process+0xb4>
8000549c:	58 1c       	cp.w	r12,1
8000549e:	c0 81       	brne	800054ae <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800054a0:	49 58       	lddpc	r8,800054f4 <xnl_tx_process+0xc0>
800054a2:	70 0c       	ld.w	r12,r8[0x0]
800054a4:	68 0b       	ld.w	r11,r4[0x0]
800054a6:	f0 1f 00 15 	mcall	800054f8 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800054aa:	8d 07       	st.w	r6[0x0],r7
800054ac:	cc db       	rjmp	80005446 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800054ae:	6a 08       	ld.w	r8,r5[0x0]
800054b0:	58 38       	cp.w	r8,3
800054b2:	e0 89 00 09 	brgt	800054c4 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800054b6:	68 0c       	ld.w	r12,r4[0x0]
800054b8:	f0 1f 00 0e 	mcall	800054f0 <xnl_tx_process+0xbc>
						xnl_send_times++;
800054bc:	6a 08       	ld.w	r8,r5[0x0]
800054be:	2f f8       	sub	r8,-1
800054c0:	8b 08       	st.w	r5[0x0],r8
800054c2:	cc 2b       	rjmp	80005446 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800054c4:	48 c8       	lddpc	r8,800054f4 <xnl_tx_process+0xc0>
800054c6:	70 0c       	ld.w	r12,r8[0x0]
800054c8:	68 0b       	ld.w	r11,r4[0x0]
800054ca:	f0 1f 00 0c 	mcall	800054f8 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800054ce:	8d 07       	st.w	r6[0x0],r7
800054d0:	cb bb       	rjmp	80005446 <xnl_tx_process+0x12>
800054d2:	00 00       	add	r0,r0
800054d4:	00 00       	add	r0,r0
800054d6:	10 ec       	st.h	--r8,r12
800054d8:	00 00       	add	r0,r0
800054da:	10 e8       	st.h	--r8,r8
800054dc:	00 00       	add	r0,r0
800054de:	10 e4       	st.h	--r8,r4
800054e0:	00 00       	add	r0,r0
800054e2:	10 f0       	st.b	--r8,r0
800054e4:	00 00       	add	r0,r0
800054e6:	10 d4       	st.w	--r8,r4
800054e8:	80 00       	ld.sh	r0,r0[0x0]
800054ea:	90 fc       	ld.uh	r12,r8[0xe]
800054ec:	80 00       	ld.sh	r0,r0[0x0]
800054ee:	8f 8c       	st.w	r7[0x20],r12
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	3d 4c       	mov	r12,-44
800054f4:	00 00       	add	r0,r0
800054f6:	10 18       	sub	r8,r8
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	3d 2c       	mov	r12,-46

800054fc <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
800054fc:	eb cd 40 fe 	pushm	r1-r7,lr
80005500:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80005502:	49 26       	lddpc	r6,80005548 <xnl_rx_process+0x4c>
80005504:	30 05       	mov	r5,0
80005506:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005508:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000550a:	49 11       	lddpc	r1,8000554c <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000550c:	49 12       	lddpc	r2,80005550 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000550e:	6c 0c       	ld.w	r12,r6[0x0]
80005510:	0a 99       	mov	r9,r5
80005512:	08 9a       	mov	r10,r4
80005514:	1a 9b       	mov	r11,sp
80005516:	f0 1f 00 10 	mcall	80005554 <xnl_rx_process+0x58>
8000551a:	58 1c       	cp.w	r12,1
8000551c:	cf 91       	brne	8000550e <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000551e:	40 0c       	lddsp	r12,sp[0x0]
80005520:	58 0c       	cp.w	r12,0
80005522:	cf 60       	breq	8000550e <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80005524:	98 28       	ld.sh	r8,r12[0x4]
80005526:	e6 08 19 00 	cp.h	r8,r3
8000552a:	e0 8b 00 0a 	brhi	8000553e <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000552e:	5c 78       	castu.h	r8
80005530:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80005534:	58 09       	cp.w	r9,0
80005536:	c0 40       	breq	8000553e <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80005538:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
8000553c:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000553e:	62 0c       	ld.w	r12,r1[0x0]
80005540:	40 0b       	lddsp	r11,sp[0x0]
80005542:	f0 1f 00 06 	mcall	80005558 <xnl_rx_process+0x5c>
80005546:	ce 4b       	rjmp	8000550e <xnl_rx_process+0x12>
80005548:	00 00       	add	r0,r0
8000554a:	10 4c       	or	r12,r8
8000554c:	00 00       	add	r0,r0
8000554e:	10 18       	sub	r8,r8
80005550:	00 00       	add	r0,r0
80005552:	04 fc       	st.b	--r2,r12
80005554:	80 00       	ld.sh	r0,r0[0x0]
80005556:	90 fc       	ld.uh	r12,r8[0xe]
80005558:	80 00       	ld.sh	r0,r0[0x0]
8000555a:	3d 2c       	mov	r12,-46

8000555c <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
8000555c:	eb cd 40 c0 	pushm	r6-r7,lr
80005560:	20 1d       	sub	sp,4
80005562:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80005564:	98 39       	ld.sh	r9,r12[0x6]
80005566:	3f f8       	mov	r8,-1
80005568:	f0 09 19 00 	cp.h	r9,r8
8000556c:	c0 a1       	brne	80005580 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
8000556e:	4a e9       	lddpc	r9,80005624 <xnl_tx+0xc8>
80005570:	13 88       	ld.ub	r8,r9[0x0]
80005572:	2f f8       	sub	r8,-1
80005574:	5c 58       	castu.b	r8
80005576:	b2 88       	st.b	r9[0x0],r8
80005578:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000557c:	a9 a8       	sbr	r8,0x8
8000557e:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80005580:	8c 49       	ld.sh	r9,r6[0x8]
80005582:	3f f8       	mov	r8,-1
80005584:	f0 09 19 00 	cp.h	r9,r8
80005588:	c0 41       	brne	80005590 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
8000558a:	4a 88       	lddpc	r8,80005628 <xnl_tx+0xcc>
8000558c:	90 18       	ld.sh	r8,r8[0x2]
8000558e:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80005590:	8c 59       	ld.sh	r9,r6[0xa]
80005592:	3f f8       	mov	r8,-1
80005594:	f0 09 19 00 	cp.h	r9,r8
80005598:	c0 41       	brne	800055a0 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
8000559a:	4a 48       	lddpc	r8,80005628 <xnl_tx+0xcc>
8000559c:	90 28       	ld.sh	r8,r8[0x4]
8000559e:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800055a0:	8c 69       	ld.sh	r9,r6[0xc]
800055a2:	3f f8       	mov	r8,-1
800055a4:	f0 09 19 00 	cp.h	r9,r8
800055a8:	c0 e1       	brne	800055c4 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800055aa:	4a 08       	lddpc	r8,80005628 <xnl_tx+0xcc>
800055ac:	90 49       	ld.sh	r9,r8[0x8]
800055ae:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800055b0:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800055b2:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800055b4:	90 49       	ld.sh	r9,r8[0x8]
800055b6:	e0 19 ff 00 	andl	r9,0xff00
800055ba:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800055be:	f3 e8 10 08 	or	r8,r9,r8
800055c2:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800055c4:	0d 98       	ld.ub	r8,r6[0x1]
800055c6:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800055c8:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800055cc:	10 0c       	add	r12,r8
800055ce:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800055d0:	58 0c       	cp.w	r12,0
800055d2:	e0 89 00 04 	brgt	800055da <xnl_tx+0x7e>
800055d6:	30 09       	mov	r9,0
800055d8:	c0 d8       	rjmp	800055f2 <xnl_tx+0x96>
800055da:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800055de:	2f ec       	sub	r12,-2
800055e0:	30 09       	mov	r9,0
800055e2:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800055e4:	15 1b       	ld.sh	r11,r10++
800055e6:	f6 09 00 09 	add	r9,r11,r9
800055ea:	5c 89       	casts.h	r9
		indextohWord     += 1;
800055ec:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800055ee:	18 38       	cp.w	r8,r12
800055f0:	cf a1       	brne	800055e4 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800055f2:	5c 39       	neg	r9
800055f4:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800055f6:	48 e8       	lddpc	r8,8000562c <xnl_tx+0xd0>
800055f8:	70 0c       	ld.w	r12,r8[0x0]
800055fa:	f0 1f 00 0e 	mcall	80005630 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800055fe:	c1 00       	breq	8000561e <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80005600:	fa c7 ff fc 	sub	r7,sp,-4
80005604:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80005606:	e0 6a 01 00 	mov	r10,256
8000560a:	0c 9b       	mov	r11,r6
8000560c:	f0 1f 00 0a 	mcall	80005634 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80005610:	48 a8       	lddpc	r8,80005638 <xnl_tx+0xdc>
80005612:	70 0c       	ld.w	r12,r8[0x0]
80005614:	30 09       	mov	r9,0
80005616:	12 9a       	mov	r10,r9
80005618:	1a 9b       	mov	r11,sp
8000561a:	f0 1f 00 09 	mcall	8000563c <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
8000561e:	2f fd       	sub	sp,-4
80005620:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005624:	00 00       	add	r0,r0
80005626:	10 f4       	st.b	--r8,r4
80005628:	00 00       	add	r0,r0
8000562a:	10 d8       	st.w	--r8,r8
8000562c:	00 00       	add	r0,r0
8000562e:	10 18       	sub	r8,r8
80005630:	80 00       	ld.sh	r0,r0[0x0]
80005632:	43 44       	lddsp	r4,sp[0xd0]
80005634:	80 00       	ld.sh	r0,r0[0x0]
80005636:	a8 be       	st.b	r4[0x3],lr
80005638:	00 00       	add	r0,r0
8000563a:	10 e8       	st.h	--r8,r8
8000563c:	80 00       	ld.sh	r0,r0[0x0]
8000563e:	93 08       	st.w	r9[0x0],r8

80005640 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80005640:	eb cd 40 80 	pushm	r7,lr
80005644:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80005648:	f0 1f 00 27 	mcall	800056e4 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
8000564c:	30 09       	mov	r9,0
8000564e:	4a 78       	lddpc	r8,800056e8 <xnl_init+0xa8>
80005650:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80005652:	30 0b       	mov	r11,0
80005654:	30 1c       	mov	r12,1
80005656:	f0 1f 00 26 	mcall	800056ec <xnl_init+0xac>
8000565a:	4a 68       	lddpc	r8,800056f0 <xnl_init+0xb0>
8000565c:	91 0c       	st.w	r8[0x0],r12
8000565e:	70 08       	ld.w	r8,r8[0x0]
80005660:	58 08       	cp.w	r8,0
80005662:	c0 80       	breq	80005672 <xnl_init+0x32>
80005664:	4a 38       	lddpc	r8,800056f0 <xnl_init+0xb0>
80005666:	70 0c       	ld.w	r12,r8[0x0]
80005668:	30 09       	mov	r9,0
8000566a:	12 9a       	mov	r10,r9
8000566c:	12 9b       	mov	r11,r9
8000566e:	f0 1f 00 22 	mcall	800056f4 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
80005672:	30 4b       	mov	r11,4
80005674:	31 4c       	mov	r12,20
80005676:	f0 1f 00 1e 	mcall	800056ec <xnl_init+0xac>
8000567a:	4a 08       	lddpc	r8,800056f8 <xnl_init+0xb8>
8000567c:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
8000567e:	30 07       	mov	r7,0
80005680:	1a d7       	st.w	--sp,r7
80005682:	1a d7       	st.w	--sp,r7
80005684:	1a d7       	st.w	--sp,r7
80005686:	30 38       	mov	r8,3
80005688:	0e 99       	mov	r9,r7
8000568a:	e0 6a 02 00 	mov	r10,512
8000568e:	49 cb       	lddpc	r11,800056fc <xnl_init+0xbc>
80005690:	49 cc       	lddpc	r12,80005700 <xnl_init+0xc0>
80005692:	f0 1f 00 1d 	mcall	80005704 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80005696:	1a d7       	st.w	--sp,r7
80005698:	1a d7       	st.w	--sp,r7
8000569a:	1a d7       	st.w	--sp,r7
8000569c:	30 38       	mov	r8,3
8000569e:	0e 99       	mov	r9,r7
800056a0:	e0 6a 03 20 	mov	r10,800
800056a4:	49 9b       	lddpc	r11,80005708 <xnl_init+0xc8>
800056a6:	49 ac       	lddpc	r12,8000570c <xnl_init+0xcc>
800056a8:	f0 1f 00 17 	mcall	80005704 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800056ac:	e0 68 40 0e 	mov	r8,16398
800056b0:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800056b4:	3f f8       	mov	r8,-1
800056b6:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800056ba:	30 38       	mov	r8,3
800056bc:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800056c0:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800056c4:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800056c8:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800056cc:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800056d0:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800056d4:	fa cc ff e8 	sub	r12,sp,-24
800056d8:	f0 1f 00 0e 	mcall	80005710 <xnl_init+0xd0>
800056dc:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
800056de:	2c 0d       	sub	sp,-256
800056e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	43 6c       	lddsp	r12,sp[0xd8]
800056e8:	00 00       	add	r0,r0
800056ea:	10 d8       	st.w	--r8,r8
800056ec:	80 00       	ld.sh	r0,r0[0x0]
800056ee:	94 60       	ld.sh	r0,r10[0xc]
800056f0:	00 00       	add	r0,r0
800056f2:	10 d4       	st.w	--r8,r4
800056f4:	80 00       	ld.sh	r0,r0[0x0]
800056f6:	93 08       	st.w	r9[0x0],r8
800056f8:	00 00       	add	r0,r0
800056fa:	10 e8       	st.h	--r8,r8
800056fc:	80 01       	ld.sh	r1,r0[0x0]
800056fe:	94 44       	ld.sh	r4,r10[0x8]
80005700:	80 00       	ld.sh	r0,r0[0x0]
80005702:	54 fc       	stdsp	sp[0x13c],r12
80005704:	80 00       	ld.sh	r0,r0[0x0]
80005706:	9b 34       	st.w	sp[0xc],r4
80005708:	80 01       	ld.sh	r1,r0[0x0]
8000570a:	02 00       	add	r0,r1
8000570c:	80 00       	ld.sh	r0,r0[0x0]
8000570e:	54 34       	stdsp	sp[0x10c],r4
80005710:	80 00       	ld.sh	r0,r0[0x0]
80005712:	55 5c       	stdsp	sp[0x154],r12

80005714 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80005714:	eb cd 40 80 	pushm	r7,lr
80005718:	fa cd 01 00 	sub	sp,sp,256
8000571c:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000571e:	e0 68 40 0e 	mov	r8,16398
80005722:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005724:	3f f8       	mov	r8,-1
80005726:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80005728:	30 c8       	mov	r8,12
8000572a:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
8000572c:	98 38       	ld.sh	r8,r12[0x6]
8000572e:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80005730:	98 58       	ld.sh	r8,r12[0xa]
80005732:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80005734:	98 48       	ld.sh	r8,r12[0x8]
80005736:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80005738:	98 68       	ld.sh	r8,r12[0xc]
8000573a:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
8000573c:	30 08       	mov	r8,0
8000573e:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005740:	1a 9c       	mov	r12,sp
80005742:	f0 1f 00 0a 	mcall	80005768 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80005746:	fa cd 00 cc 	sub	sp,sp,204
8000574a:	e0 6a 00 ca 	mov	r10,202
8000574e:	ee cb ff f0 	sub	r11,r7,-16
80005752:	1a 9c       	mov	r12,sp
80005754:	f0 1f 00 06 	mcall	8000576c <xnl_data_msg_func+0x58>
80005758:	48 68       	lddpc	r8,80005770 <xnl_data_msg_func+0x5c>
8000575a:	70 08       	ld.w	r8,r8[0x0]
8000575c:	5d 18       	icall	r8
8000575e:	fa cd ff 34 	sub	sp,sp,-204
}
80005762:	2c 0d       	sub	sp,-256
80005764:	e3 cd 80 80 	ldm	sp++,r7,pc
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	55 5c       	stdsp	sp[0x154],r12
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	a8 be       	st.b	r4[0x3],lr
80005770:	00 00       	add	r0,r0
80005772:	10 f8       	st.b	--r8,r8

80005774 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80005774:	d4 21       	pushm	r4-r7,lr
80005776:	fa cd 01 00 	sub	sp,sp,256
8000577a:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
8000577c:	4c 28       	lddpc	r8,80005884 <xnl_device_auth_reply_func+0x110>
8000577e:	11 88       	ld.ub	r8,r8[0x0]
80005780:	58 08       	cp.w	r8,0
80005782:	c7 e1       	brne	8000587e <xnl_device_auth_reply_func+0x10a>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80005784:	4c 18       	lddpc	r8,80005888 <xnl_device_auth_reply_func+0x114>
80005786:	70 0c       	ld.w	r12,r8[0x0]
80005788:	30 09       	mov	r9,0
8000578a:	12 9a       	mov	r10,r9
8000578c:	12 9b       	mov	r11,r9
8000578e:	f0 1f 00 40 	mcall	8000588c <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80005792:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80005796:	4b c8       	lddpc	r8,80005884 <xnl_device_auth_reply_func+0x110>
80005798:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
8000579a:	ef 39 00 12 	ld.ub	r9,r7[18]
8000579e:	ef 38 00 13 	ld.ub	r8,r7[19]
800057a2:	b1 68       	lsl	r8,0x10
800057a4:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800057a8:	ef 38 00 15 	ld.ub	r8,r7[21]
800057ac:	f3 e8 10 08 	or	r8,r9,r8
800057b0:	ef 39 00 14 	ld.ub	r9,r7[20]
800057b4:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800057b8:	ef 3a 00 16 	ld.ub	r10,r7[22]
800057bc:	ef 38 00 17 	ld.ub	r8,r7[23]
800057c0:	b1 68       	lsl	r8,0x10
800057c2:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800057c6:	ef 38 00 19 	ld.ub	r8,r7[25]
800057ca:	f5 e8 10 08 	or	r8,r10,r8
800057ce:	ef 3a 00 18 	ld.ub	r10,r7[24]
800057d2:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800057d6:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800057d8:	e0 64 79 b9 	mov	r4,31161
800057dc:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800057e0:	e0 65 45 07 	mov	r5,17671
800057e4:	ea 15 8a bd 	orh	r5,0x8abd
800057e8:	e0 66 f9 3d 	mov	r6,63805
800057ec:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800057f0:	e0 6e b8 cf 	mov	lr,47311
800057f4:	ea 1e 36 83 	orh	lr,0x3683
800057f8:	e0 67 aa 1c 	mov	r7,43548
800057fc:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80005800:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80005802:	f4 08 00 0c 	add	r12,r10,r8
80005806:	f0 0b 15 04 	lsl	r11,r8,0x4
8000580a:	0a 0b       	add	r11,r5
8000580c:	f9 eb 20 0b 	eor	r11,r12,r11
80005810:	f0 0c 16 05 	lsr	r12,r8,0x5
80005814:	0c 0c       	add	r12,r6
80005816:	18 5b       	eor	r11,r12
80005818:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
8000581a:	f2 0c 15 04 	lsl	r12,r9,0x4
8000581e:	1c 0c       	add	r12,lr
80005820:	f2 0b 16 05 	lsr	r11,r9,0x5
80005824:	0e 0b       	add	r11,r7
80005826:	f9 eb 20 0b 	eor	r11,r12,r11
8000582a:	f2 0a 00 0c 	add	r12,r9,r10
8000582e:	18 5b       	eor	r11,r12
80005830:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80005832:	e0 6b 37 20 	mov	r11,14112
80005836:	ea 1b c6 ef 	orh	r11,0xc6ef
8000583a:	16 3a       	cp.w	r10,r11
8000583c:	ce 21       	brne	80005800 <xnl_device_auth_reply_func+0x8c>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
8000583e:	e0 6a 40 1a 	mov	r10,16410
80005842:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80005844:	3f fa       	mov	r10,-1
80005846:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80005848:	30 6b       	mov	r11,6
8000584a:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000584c:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000584e:	48 eb       	lddpc	r11,80005884 <xnl_device_auth_reply_func+0x110>
80005850:	96 1c       	ld.sh	r12,r11[0x2]
80005852:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80005854:	96 2b       	ld.sh	r11,r11[0x4]
80005856:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80005858:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
8000585a:	30 ca       	mov	r10,12
8000585c:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
8000585e:	30 0a       	mov	r10,0
80005860:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80005864:	30 7a       	mov	r10,7
80005866:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
8000586a:	30 2a       	mov	r10,2
8000586c:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005870:	fa ca ff ec 	sub	r10,sp,-20
80005874:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80005876:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80005878:	1a 9c       	mov	r12,sp
8000587a:	f0 1f 00 06 	mcall	80005890 <xnl_device_auth_reply_func+0x11c>
}
8000587e:	2c 0d       	sub	sp,-256
80005880:	d8 22       	popm	r4-r7,pc
80005882:	00 00       	add	r0,r0
80005884:	00 00       	add	r0,r0
80005886:	10 d8       	st.w	--r8,r8
80005888:	00 00       	add	r0,r0
8000588a:	10 d4       	st.w	--r8,r4
8000588c:	80 00       	ld.sh	r0,r0[0x0]
8000588e:	93 08       	st.w	r9[0x0],r8
80005890:	80 00       	ld.sh	r0,r0[0x0]
80005892:	55 5c       	stdsp	sp[0x154],r12

80005894 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80005894:	eb cd 40 80 	pushm	r7,lr
80005898:	fa cd 01 00 	sub	sp,sp,256
8000589c:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
8000589e:	49 28       	lddpc	r8,800058e4 <xnl_master_status_brdcst_func+0x50>
800058a0:	11 88       	ld.ub	r8,r8[0x0]
800058a2:	58 08       	cp.w	r8,0
800058a4:	c1 c1       	brne	800058dc <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800058a6:	49 18       	lddpc	r8,800058e8 <xnl_master_status_brdcst_func+0x54>
800058a8:	70 0c       	ld.w	r12,r8[0x0]
800058aa:	30 09       	mov	r9,0
800058ac:	12 9a       	mov	r10,r9
800058ae:	12 9b       	mov	r11,r9
800058b0:	f0 1f 00 0f 	mcall	800058ec <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800058b4:	8e 58       	ld.sh	r8,r7[0xa]
800058b6:	48 c9       	lddpc	r9,800058e4 <xnl_master_status_brdcst_func+0x50>
800058b8:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800058ba:	e0 68 40 0e 	mov	r8,16398
800058be:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800058c0:	3f f8       	mov	r8,-1
800058c2:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800058c4:	30 4a       	mov	r10,4
800058c6:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800058c8:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800058ca:	92 19       	ld.sh	r9,r9[0x2]
800058cc:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800058ce:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800058d0:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800058d2:	30 08       	mov	r8,0
800058d4:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800058d6:	1a 9c       	mov	r12,sp
800058d8:	f0 1f 00 06 	mcall	800058f0 <xnl_master_status_brdcst_func+0x5c>
}
800058dc:	2c 0d       	sub	sp,-256
800058de:	e3 cd 80 80 	ldm	sp++,r7,pc
800058e2:	00 00       	add	r0,r0
800058e4:	00 00       	add	r0,r0
800058e6:	10 d8       	st.w	--r8,r8
800058e8:	00 00       	add	r0,r0
800058ea:	10 d4       	st.w	--r8,r4
800058ec:	80 00       	ld.sh	r0,r0[0x0]
800058ee:	93 08       	st.w	r9[0x0],r8
800058f0:	80 00       	ld.sh	r0,r0[0x0]
800058f2:	55 5c       	stdsp	sp[0x154],r12

800058f4 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800058f4:	eb cd 40 80 	pushm	r7,lr
800058f8:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800058fa:	49 38       	lddpc	r8,80005944 <xnl_device_conn_reply_func+0x50>
800058fc:	70 0c       	ld.w	r12,r8[0x0]
800058fe:	30 09       	mov	r9,0
80005900:	12 9a       	mov	r10,r9
80005902:	12 9b       	mov	r11,r9
80005904:	f0 1f 00 11 	mcall	80005948 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80005908:	ef 18 00 10 	ld.uh	r8,r7[16]
8000590c:	10 99       	mov	r9,r8
8000590e:	e2 19 ff 00 	andl	r9,0xff00,COH
80005912:	e0 49 01 00 	cp.w	r9,256
80005916:	c0 60       	breq	80005922 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80005918:	0e 9c       	mov	r12,r7
8000591a:	f0 1f 00 0d 	mcall	8000594c <xnl_device_conn_reply_func+0x58>
8000591e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80005922:	a9 68       	lsl	r8,0x8
80005924:	48 b9       	lddpc	r9,80005950 <xnl_device_conn_reply_func+0x5c>
80005926:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80005928:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
8000592c:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000592e:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80005932:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80005934:	30 18       	mov	r8,1
80005936:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80005938:	48 7c       	lddpc	r12,80005954 <xnl_device_conn_reply_func+0x60>
8000593a:	f0 1f 00 08 	mcall	80005958 <xnl_device_conn_reply_func+0x64>
8000593e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005942:	00 00       	add	r0,r0
80005944:	00 00       	add	r0,r0
80005946:	10 d4       	st.w	--r8,r4
80005948:	80 00       	ld.sh	r0,r0[0x0]
8000594a:	93 08       	st.w	r9[0x0],r8
8000594c:	80 00       	ld.sh	r0,r0[0x0]
8000594e:	58 94       	cp.w	r4,9
80005950:	00 00       	add	r0,r0
80005952:	10 d8       	st.w	--r8,r8
80005954:	80 01       	ld.sh	r1,r0[0x0]
80005956:	94 4c       	ld.sh	r12,r10[0x8]
80005958:	80 00       	ld.sh	r0,r0[0x0]
8000595a:	9e f8       	ld.uh	r8,pc[0xe]

8000595c <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
8000595c:	fe 78 0c 00 	mov	r8,-62464
80005960:	e0 69 03 07 	mov	r9,775
80005964:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80005966:	30 49       	mov	r9,4
80005968:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000596a:	71 59       	ld.w	r9,r8[0x54]
8000596c:	e2 19 00 80 	andl	r9,0x80,COH
80005970:	cf d0       	breq	8000596a <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
80005972:	fe 78 0c 00 	mov	r8,-62464
80005976:	30 59       	mov	r9,5
80005978:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
8000597a:	e0 69 01 0d 	mov	r9,269
8000597e:	ea 19 10 07 	orh	r9,0x1007
80005982:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005984:	71 59       	ld.w	r9,r8[0x54]
80005986:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000598a:	cf d0       	breq	80005984 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
8000598c:	fe 78 0c 00 	mov	r8,-62464
80005990:	fc 19 00 80 	movh	r9,0x80
80005994:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005996:	34 0a       	mov	r10,64
80005998:	fe 69 14 00 	mov	r9,-125952
8000599c:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000599e:	30 69       	mov	r9,6
800059a0:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800059a2:	30 19       	mov	r9,1
800059a4:	fe 68 10 00 	mov	r8,-126976
800059a8:	91 19       	st.w	r8[0x4],r9
}
800059aa:	5e fc       	retal	r12

800059ac <read_a_byte>:
*/
U32 read_a_byte(U32 subaddress, S8 *datareceived)
{
	U32 TWI_Status = 0;

	AVR32_TWI.cr   =  AVR32_TWI_CR_MSEN_MASK | AVR32_TWI_CR_SVDIS_MASK;
800059ac:	fe 78 2c 00 	mov	r8,-54272
800059b0:	32 49       	mov	r9,36
800059b2:	91 09       	st.w	r8[0x0],r9
	AVR32_TWI.mmr  =  PCF8563_ADDRESS        << AVR32_TWI_MMR_DADR_OFFSET   |
800059b4:	e0 69 11 00 	mov	r9,4352
800059b8:	ea 19 00 51 	orh	r9,0x51
800059bc:	91 19       	st.w	r8[0x4],r9
	PCF8563_ADDR_LGT		<< AVR32_TWI_MMR_IADRSZ_OFFSET |
	1					<< AVR32_TWI_MMR_MREAD_OFFSET;
	AVR32_TWI.iadr =  subaddress;
800059be:	91 3c       	st.w	r8[0xc],r12

	AVR32_TWI.cr   =  AVR32_TWI_START_MASK | AVR32_TWI_STOP_MASK;
800059c0:	30 39       	mov	r9,3
800059c2:	91 09       	st.w	r8[0x0],r9

	do
	{
		TWI_Status =  AVR32_TWI.sr & 0x00000102;
800059c4:	70 8c       	ld.w	r12,r8[0x20]
800059c6:	e2 1c 01 02 	andl	r12,0x102,COH
	}
	while (TWI_Status == 0);
800059ca:	cf d0       	breq	800059c4 <read_a_byte+0x18>

	if (!(TWI_Status & 0x00000100))
800059cc:	18 98       	mov	r8,r12
800059ce:	e2 18 01 00 	andl	r8,0x100,COH
800059d2:	c0 51       	brne	800059dc <read_a_byte+0x30>
	{
		*datareceived = AVR32_TWI.rhr;
800059d4:	fe 78 2c 00 	mov	r8,-54272
800059d8:	70 c8       	ld.w	r8,r8[0x30]
800059da:	b6 88       	st.b	r11[0x0],r8
	}
	while ((AVR32_TWI.sr & 0x00000001) == 0x00000000); //Wait for complete.
800059dc:	fe 78 2c 00 	mov	r8,-54272
800059e0:	70 89       	ld.w	r9,r8[0x20]
800059e2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800059e6:	cf d0       	breq	800059e0 <read_a_byte+0x34>
	return (TWI_Status);
}
800059e8:	5e fc       	retal	r12
800059ea:	d7 03       	nop

800059ec <rtc_read_time>:
Calls: 
    my_writeabyte
Return:rtc_err_t
*/
rtc_err_t rtc_read_time(date_time_t * t)
{	
800059ec:	eb cd 40 e0 	pushm	r5-r7,lr
800059f0:	20 2d       	sub	sp,8
800059f2:	18 97       	mov	r7,r12
	if(NULL != rtc_mutex)
800059f4:	4c 28       	lddpc	r8,80005afc <rtc_read_time+0x110>
800059f6:	70 08       	ld.w	r8,r8[0x0]
800059f8:	58 08       	cp.w	r8,0
800059fa:	c0 31       	brne	80005a00 <rtc_read_time+0x14>
800059fc:	30 3c       	mov	r12,3
800059fe:	c7 b8       	rjmp	80005af4 <rtc_read_time+0x108>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005a00:	4b f6       	lddpc	r6,80005afc <rtc_read_time+0x110>
80005a02:	6c 0c       	ld.w	r12,r6[0x0]
80005a04:	30 09       	mov	r9,0
80005a06:	3f fa       	mov	r10,-1
80005a08:	12 9b       	mov	r11,r9
80005a0a:	f0 1f 00 3e 	mcall	80005b00 <rtc_read_time+0x114>
	int RTC_Status;
	
	unsigned char time[8];
	
	/*read second*/
	res = read_a_byte(0x02, &time[0]);	
80005a0e:	1a 9b       	mov	r11,sp
80005a10:	30 2c       	mov	r12,2
80005a12:	f0 1f 00 3d 	mcall	80005b04 <rtc_read_time+0x118>
	t->second = ((time[0] & 0x7F) >> 4) * 10 + (time[0] & 0x0F);
80005a16:	1b 88       	ld.ub	r8,sp[0x0]
80005a18:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
80005a1c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005a20:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005a24:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005a28:	ae f9       	st.b	r7[0x7],r9
	
	/*read minute*/
	res = read_a_byte(0x03, &time[1]);
80005a2a:	fa cb ff ff 	sub	r11,sp,-1
80005a2e:	30 3c       	mov	r12,3
80005a30:	f0 1f 00 35 	mcall	80005b04 <rtc_read_time+0x118>
	t->minute = ((time[1] & 0x7F) >> 4) * 10 + (time[1] & 0x0F);
80005a34:	1b 98       	ld.ub	r8,sp[0x1]
80005a36:	f3 d8 c0 83 	bfextu	r9,r8,0x4,0x3
80005a3a:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005a3e:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005a42:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005a46:	ae e9       	st.b	r7[0x6],r9
	
	/*read hour*/
	res = read_a_byte(0x04, &time[2]);
80005a48:	fa cb ff fe 	sub	r11,sp,-2
80005a4c:	30 4c       	mov	r12,4
80005a4e:	f0 1f 00 2e 	mcall	80005b04 <rtc_read_time+0x118>
	t->hour = ((time[2] & 0x3F) >> 4) * 10 + (time[2] & 0x0F);
80005a52:	1b a8       	ld.ub	r8,sp[0x2]
80005a54:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005a58:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005a5c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005a60:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005a64:	ae d9       	st.b	r7[0x5],r9
	
	/*read day*/
	res = read_a_byte(0x05, &time[3]);
80005a66:	fa cb ff fd 	sub	r11,sp,-3
80005a6a:	30 5c       	mov	r12,5
80005a6c:	f0 1f 00 26 	mcall	80005b04 <rtc_read_time+0x118>
	t->day = ((time[3] & 0x3F) >> 4) * 10 + (time[3] & 0x0F);
80005a70:	1b b8       	ld.ub	r8,sp[0x3]
80005a72:	f3 d8 c0 82 	bfextu	r9,r8,0x4,0x2
80005a76:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005a7a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005a7e:	f0 09 00 19 	add	r9,r8,r9<<0x1
80005a82:	ae b9       	st.b	r7[0x3],r9
	
	/*read week*/
	res = read_a_byte(0x06, &time[4]);
80005a84:	fa cb ff fc 	sub	r11,sp,-4
80005a88:	30 6c       	mov	r12,6
80005a8a:	f0 1f 00 1f 	mcall	80005b04 <rtc_read_time+0x118>
	t->week = (time[4] & 0x0F);
80005a8e:	1b c8       	ld.ub	r8,sp[0x4]
80005a90:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005a94:	ae c8       	st.b	r7[0x4],r8
	
	/*read month*/
	res = read_a_byte(0x07, &time[5]);
80005a96:	fa cb ff fb 	sub	r11,sp,-5
80005a9a:	30 7c       	mov	r12,7
80005a9c:	f0 1f 00 1a 	mcall	80005b04 <rtc_read_time+0x118>
	t->month = ((time[5] & 0x1F) >> 4) * 10 + (time[5] & 0x0F);
80005aa0:	1b d8       	ld.ub	r8,sp[0x5]
80005aa2:	f3 d8 c0 81 	bfextu	r9,r8,0x4,0x1
80005aa6:	f2 0a 15 02 	lsl	r10,r9,0x2
80005aaa:	14 09       	add	r9,r10
80005aac:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80005ab0:	f0 09 00 18 	add	r8,r8,r9<<0x1
80005ab4:	ae a8       	st.b	r7[0x2],r8
	
	/*read year*/
	res = read_a_byte(0x08, &time[6]);
80005ab6:	fa cb ff fa 	sub	r11,sp,-6
80005aba:	30 8c       	mov	r12,8
80005abc:	f0 1f 00 12 	mcall	80005b04 <rtc_read_time+0x118>
80005ac0:	18 95       	mov	r5,r12
	t->year = ((time[6] & 0xFF) >> 4) * 10 + (time[6] & 0x0F) + 2000;
80005ac2:	1b e9       	ld.ub	r9,sp[0x6]
80005ac4:	f1 d9 c0 04 	bfextu	r8,r9,0x0,0x4
80005ac8:	f0 c8 f8 30 	sub	r8,r8,-2000
80005acc:	a5 89       	lsr	r9,0x4
80005ace:	f2 09 10 0a 	mul	r9,r9,10
80005ad2:	12 08       	add	r8,r9
80005ad4:	5c 78       	castu.h	r8
80005ad6:	30 0b       	mov	r11,0
80005ad8:	f0 09 16 08 	lsr	r9,r8,0x8
80005adc:	ae 89       	st.b	r7[0x0],r9
80005ade:	ae 98       	st.b	r7[0x1],r8
	
	/*finished accessing the shared resource.Release the semaphore.*/	
	xSemaphoreGive(rtc_mutex);	
80005ae0:	6c 0c       	ld.w	r12,r6[0x0]
80005ae2:	16 99       	mov	r9,r11
80005ae4:	16 9a       	mov	r10,r11
80005ae6:	f0 1f 00 09 	mcall	80005b08 <rtc_read_time+0x11c>
		
	if(res)
80005aea:	58 05       	cp.w	r5,0
80005aec:	f9 bc 01 00 	movne	r12,0
80005af0:	f9 bc 00 02 	moveq	r12,2
	{
		return rtc_success;
	}

	return rtc_write_err;
}
80005af4:	2f ed       	sub	sp,-8
80005af6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005afa:	00 00       	add	r0,r0
80005afc:	00 00       	add	r0,r0
80005afe:	11 08       	ld.w	r8,r8++
80005b00:	80 00       	ld.sh	r0,r0[0x0]
80005b02:	90 fc       	ld.uh	r12,r8[0xe]
80005b04:	80 00       	ld.sh	r0,r0[0x0]
80005b06:	59 ac       	cp.w	r12,26
80005b08:	80 00       	ld.sh	r0,r0[0x0]
80005b0a:	93 08       	st.w	r9[0x0],r8

80005b0c <getTime>:
Description: define now
Calls:
Return:date_time_t *
*/
date_time_t * getTime(void)
{
80005b0c:	eb cd 40 80 	pushm	r7,lr
	rtc_read_time(&date_time);
80005b10:	48 47       	lddpc	r7,80005b20 <getTime+0x14>
80005b12:	0e 9c       	mov	r12,r7
80005b14:	f0 1f 00 04 	mcall	80005b24 <getTime+0x18>
	return &date_time;
80005b18:	0e 9c       	mov	r12,r7
80005b1a:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b1e:	00 00       	add	r0,r0
80005b20:	00 00       	add	r0,r0
80005b22:	11 00       	ld.w	r0,r8++
80005b24:	80 00       	ld.sh	r0,r0[0x0]
80005b26:	59 ec       	cp.w	r12,30

80005b28 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80005b28:	eb cd 40 c0 	pushm	r6-r7,lr
80005b2c:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80005b2e:	f0 1f 00 1a 	mcall	80005b94 <rtc_init+0x6c>
80005b32:	49 a8       	lddpc	r8,80005b98 <rtc_init+0x70>
80005b34:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80005b36:	70 08       	ld.w	r8,r8[0x0]
80005b38:	58 08       	cp.w	r8,0
80005b3a:	c0 31       	brne	80005b40 <rtc_init+0x18>
80005b3c:	30 3c       	mov	r12,3
80005b3e:	c2 78       	rjmp	80005b8c <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80005b40:	49 66       	lddpc	r6,80005b98 <rtc_init+0x70>
80005b42:	6c 0c       	ld.w	r12,r6[0x0]
80005b44:	30 09       	mov	r9,0
80005b46:	3f fa       	mov	r10,-1
80005b48:	12 9b       	mov	r11,r9
80005b4a:	f0 1f 00 15 	mcall	80005b9c <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80005b4e:	30 2b       	mov	r11,2
80005b50:	49 4c       	lddpc	r12,80005ba0 <rtc_init+0x78>
80005b52:	f0 1f 00 15 	mcall	80005ba4 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80005b56:	e0 68 36 00 	mov	r8,13824
80005b5a:	ea 18 01 6e 	orh	r8,0x16e
80005b5e:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80005b60:	e2 78 0d 40 	mov	r8,200000
80005b64:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80005b66:	35 18       	mov	r8,81
80005b68:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80005b6c:	1a 9b       	mov	r11,sp
80005b6e:	fe 7c 2c 00 	mov	r12,-54272
80005b72:	f0 1f 00 0e 	mcall	80005ba8 <rtc_init+0x80>
80005b76:	48 e7       	lddpc	r7,80005bac <rtc_init+0x84>
80005b78:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80005b7a:	6c 0c       	ld.w	r12,r6[0x0]
80005b7c:	30 09       	mov	r9,0
80005b7e:	12 9a       	mov	r10,r9
80005b80:	12 9b       	mov	r11,r9
80005b82:	f0 1f 00 0c 	mcall	80005bb0 <rtc_init+0x88>
80005b86:	6e 08       	ld.w	r8,r7[0x0]
80005b88:	58 08       	cp.w	r8,0
80005b8a:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80005b8c:	2f dd       	sub	sp,-12
80005b8e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b92:	00 00       	add	r0,r0
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	94 08       	ld.sh	r8,r10[0x0]
80005b98:	00 00       	add	r0,r0
80005b9a:	11 08       	ld.w	r8,r8++
80005b9c:	80 00       	ld.sh	r0,r0[0x0]
80005b9e:	90 fc       	ld.uh	r12,r8[0xe]
80005ba0:	80 01       	ld.sh	r1,r0[0x0]
80005ba2:	94 60       	ld.sh	r0,r10[0xc]
80005ba4:	80 00       	ld.sh	r0,r0[0x0]
80005ba6:	a3 98       	lsr	r8,0x3
80005ba8:	80 00       	ld.sh	r0,r0[0x0]
80005baa:	62 14       	ld.w	r4,r1[0x4]
80005bac:	00 00       	add	r0,r0
80005bae:	10 fc       	st.b	--r8,r12
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	93 08       	st.w	r9[0x0],r8

80005bb4 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80005bb4:	fe 78 10 00 	mov	r8,-61440
80005bb8:	fc 19 00 10 	movh	r9,0x10
80005bbc:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80005bbe:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80005bc0:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80005bc2:	30 39       	mov	r9,3
80005bc4:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80005bc8:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80005bcc:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80005bd0:	fe 78 38 00 	mov	r8,-51200
80005bd4:	30 49       	mov	r9,4
80005bd6:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80005bda:	e0 69 91 0d 	mov	r9,37133
80005bde:	ea 19 00 52 	orh	r9,0x52
80005be2:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005be4:	32 09       	mov	r9,32
80005be6:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005be8:	30 59       	mov	r9,5
80005bea:	91 09       	st.w	r8[0x0],r9
}
80005bec:	5e fc       	retal	r12
80005bee:	d7 03       	nop

80005bf0 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80005bf0:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80005bf2:	30 2a       	mov	r10,2
80005bf4:	e0 6b 01 c1 	mov	r11,449
80005bf8:	48 ec       	lddpc	r12,80005c30 <tc_init+0x40>
80005bfa:	f0 1f 00 0f 	mcall	80005c34 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80005bfe:	48 fb       	lddpc	r11,80005c38 <tc_init+0x48>
80005c00:	fe 7c 38 00 	mov	r12,-51200
80005c04:	f0 1f 00 0e 	mcall	80005c3c <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80005c08:	e0 6a 75 30 	mov	r10,30000
80005c0c:	30 1b       	mov	r11,1
80005c0e:	fe 7c 38 00 	mov	r12,-51200
80005c12:	f0 1f 00 0c 	mcall	80005c40 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80005c16:	48 ca       	lddpc	r10,80005c44 <tc_init+0x54>
80005c18:	30 1b       	mov	r11,1
80005c1a:	fe 7c 38 00 	mov	r12,-51200
80005c1e:	f0 1f 00 0b 	mcall	80005c48 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80005c22:	30 1b       	mov	r11,1
80005c24:	fe 7c 38 00 	mov	r12,-51200
80005c28:	f0 1f 00 09 	mcall	80005c4c <tc_init+0x5c>
80005c2c:	d8 02       	popm	pc
80005c2e:	00 00       	add	r0,r0
80005c30:	80 00       	ld.sh	r0,r0[0x0]
80005c32:	5c 50       	castu.b	r0
80005c34:	80 00       	ld.sh	r0,r0[0x0]
80005c36:	5c 74       	castu.h	r4
80005c38:	80 01       	ld.sh	r1,r0[0x0]
80005c3a:	94 74       	ld.sh	r4,r10[0xe]
80005c3c:	80 00       	ld.sh	r0,r0[0x0]
80005c3e:	5f 5a       	srlt	r10
80005c40:	80 00       	ld.sh	r0,r0[0x0]
80005c42:	60 1a       	ld.w	r10,r0[0x4]
80005c44:	80 01       	ld.sh	r1,r0[0x0]
80005c46:	94 70       	ld.sh	r0,r10[0xe]
80005c48:	80 00       	ld.sh	r0,r0[0x0]
80005c4a:	60 4e       	ld.w	lr,r0[0x10]
80005c4c:	80 00       	ld.sh	r0,r0[0x0]
80005c4e:	5f f6       	sral	r6

80005c50 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80005c50:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80005c52:	48 68       	lddpc	r8,80005c68 <_tc_interrupt+0x18>
80005c54:	70 09       	ld.w	r9,r8[0x0]
80005c56:	2f f9       	sub	r9,-1
80005c58:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80005c5a:	30 1b       	mov	r11,1
80005c5c:	fe 7c 38 00 	mov	r12,-51200
80005c60:	f0 1f 00 03 	mcall	80005c6c <_tc_interrupt+0x1c>
	
}
80005c64:	d4 02       	popm	lr
80005c66:	d6 03       	rete
80005c68:	00 00       	add	r0,r0
80005c6a:	11 0c       	ld.w	r12,r8++
80005c6c:	80 00       	ld.sh	r0,r0[0x0]
80005c6e:	60 08       	ld.w	r8,r0[0x0]

80005c70 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005c70:	c0 08       	rjmp	80005c70 <_unhandled_interrupt>
80005c72:	d7 03       	nop

80005c74 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005c74:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005c78:	49 99       	lddpc	r9,80005cdc <INTC_register_interrupt+0x68>
80005c7a:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005c7e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005c82:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005c84:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005c88:	58 0a       	cp.w	r10,0
80005c8a:	c0 91       	brne	80005c9c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005c8c:	49 59       	lddpc	r9,80005ce0 <INTC_register_interrupt+0x6c>
80005c8e:	49 6a       	lddpc	r10,80005ce4 <INTC_register_interrupt+0x70>
80005c90:	12 1a       	sub	r10,r9
80005c92:	fe 79 08 00 	mov	r9,-63488
80005c96:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005c9a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005c9c:	58 1a       	cp.w	r10,1
80005c9e:	c0 a1       	brne	80005cb2 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005ca0:	49 09       	lddpc	r9,80005ce0 <INTC_register_interrupt+0x6c>
80005ca2:	49 2a       	lddpc	r10,80005ce8 <INTC_register_interrupt+0x74>
80005ca4:	12 1a       	sub	r10,r9
80005ca6:	bf aa       	sbr	r10,0x1e
80005ca8:	fe 79 08 00 	mov	r9,-63488
80005cac:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005cb0:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80005cb2:	58 2a       	cp.w	r10,2
80005cb4:	c0 a1       	brne	80005cc8 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80005cb6:	48 b9       	lddpc	r9,80005ce0 <INTC_register_interrupt+0x6c>
80005cb8:	48 da       	lddpc	r10,80005cec <INTC_register_interrupt+0x78>
80005cba:	12 1a       	sub	r10,r9
80005cbc:	bf ba       	sbr	r10,0x1f
80005cbe:	fe 79 08 00 	mov	r9,-63488
80005cc2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005cc6:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005cc8:	48 69       	lddpc	r9,80005ce0 <INTC_register_interrupt+0x6c>
80005cca:	48 aa       	lddpc	r10,80005cf0 <INTC_register_interrupt+0x7c>
80005ccc:	12 1a       	sub	r10,r9
80005cce:	ea 1a c0 00 	orh	r10,0xc000
80005cd2:	fe 79 08 00 	mov	r9,-63488
80005cd6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005cda:	5e fc       	retal	r12
80005cdc:	80 01       	ld.sh	r1,r0[0x0]
80005cde:	94 7c       	ld.sh	r12,r10[0xe]
80005ce0:	80 01       	ld.sh	r1,r0[0x0]
80005ce2:	00 00       	add	r0,r0
80005ce4:	80 01       	ld.sh	r1,r0[0x0]
80005ce6:	01 04       	ld.w	r4,r0++
80005ce8:	80 01       	ld.sh	r1,r0[0x0]
80005cea:	01 12       	ld.sh	r2,r0++
80005cec:	80 01       	ld.sh	r1,r0[0x0]
80005cee:	01 20       	ld.uh	r0,r0++
80005cf0:	80 01       	ld.sh	r1,r0[0x0]
80005cf2:	01 2e       	ld.uh	lr,r0++

80005cf4 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80005cf4:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005cf6:	49 18       	lddpc	r8,80005d38 <INTC_init_interrupts+0x44>
80005cf8:	e3 b8 00 01 	mtsr	0x4,r8
80005cfc:	49 0e       	lddpc	lr,80005d3c <INTC_init_interrupts+0x48>
80005cfe:	30 07       	mov	r7,0
80005d00:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005d02:	49 0c       	lddpc	r12,80005d40 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d04:	49 05       	lddpc	r5,80005d44 <INTC_init_interrupts+0x50>
80005d06:	10 15       	sub	r5,r8
80005d08:	fe 76 08 00 	mov	r6,-63488
80005d0c:	c1 08       	rjmp	80005d2c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005d0e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005d10:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d12:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005d14:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005d18:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d1a:	10 3a       	cp.w	r10,r8
80005d1c:	fe 9b ff fc 	brhi	80005d14 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005d20:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005d24:	2f f7       	sub	r7,-1
80005d26:	2f 8e       	sub	lr,-8
80005d28:	59 37       	cp.w	r7,19
80005d2a:	c0 50       	breq	80005d34 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005d2c:	7c 08       	ld.w	r8,lr[0x0]
80005d2e:	58 08       	cp.w	r8,0
80005d30:	ce f1       	brne	80005d0e <INTC_init_interrupts+0x1a>
80005d32:	cf 7b       	rjmp	80005d20 <INTC_init_interrupts+0x2c>
80005d34:	d8 22       	popm	r4-r7,pc
80005d36:	00 00       	add	r0,r0
80005d38:	80 01       	ld.sh	r1,r0[0x0]
80005d3a:	00 00       	add	r0,r0
80005d3c:	80 01       	ld.sh	r1,r0[0x0]
80005d3e:	94 7c       	ld.sh	r12,r10[0xe]
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	5c 70       	castu.h	r0
80005d44:	80 01       	ld.sh	r1,r0[0x0]
80005d46:	01 04       	ld.w	r4,r0++

80005d48 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005d48:	fe 78 08 00 	mov	r8,-63488
80005d4c:	e0 69 00 83 	mov	r9,131
80005d50:	f2 0c 01 0c 	sub	r12,r9,r12
80005d54:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005d58:	f2 ca ff c0 	sub	r10,r9,-64
80005d5c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005d60:	58 08       	cp.w	r8,0
80005d62:	c0 21       	brne	80005d66 <_get_interrupt_handler+0x1e>
80005d64:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005d66:	f0 08 12 00 	clz	r8,r8
80005d6a:	48 5a       	lddpc	r10,80005d7c <_get_interrupt_handler+0x34>
80005d6c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005d70:	f0 08 11 1f 	rsub	r8,r8,31
80005d74:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80005d76:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005d7a:	5e fc       	retal	r12
80005d7c:	80 01       	ld.sh	r1,r0[0x0]
80005d7e:	94 7c       	ld.sh	r12,r10[0xe]

80005d80 <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
80005d80:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005d84:	30 18       	mov	r8,1
80005d86:	f0 09 18 00 	cp.b	r9,r8
80005d8a:	e0 88 00 04 	brls	80005d92 <spi_initMaster+0x12>
80005d8e:	30 2c       	mov	r12,2
80005d90:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005d92:	e0 68 00 80 	mov	r8,128
80005d96:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80005d98:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80005d9a:	30 19       	mov	r9,1
80005d9c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005da0:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005da4:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80005da8:	30 09       	mov	r9,0
80005daa:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005dae:	30 fa       	mov	r10,15
80005db0:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80005db4:	99 18       	st.w	r12[0x4],r8
80005db6:	5e f9       	retal	r9

80005db8 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80005db8:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80005dba:	30 18       	mov	r8,1
80005dbc:	f0 0b 18 00 	cp.b	r11,r8
80005dc0:	5f be       	srhi	lr
80005dc2:	f0 0a 18 00 	cp.b	r10,r8
80005dc6:	5f b8       	srhi	r8
80005dc8:	fd e8 10 08 	or	r8,lr,r8
80005dcc:	c0 30       	breq	80005dd2 <spi_selectionMode+0x1a>
80005dce:	30 2c       	mov	r12,2
80005dd0:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
80005dd2:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
80005dd4:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005dd8:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80005ddc:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80005de0:	99 18       	st.w	r12[0x4],r8
80005de2:	d8 0a       	popm	pc,r12=0

80005de4 <spi_selectChip>:
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005de4:	78 18       	ld.w	r8,r12[0x4]
80005de6:	ea 18 00 0f 	orh	r8,0xf
80005dea:	99 18       	st.w	r12[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005dec:	78 18       	ld.w	r8,r12[0x4]
80005dee:	e2 18 00 04 	andl	r8,0x4,COH
80005df2:	c0 f0       	breq	80005e10 <spi_selectChip+0x2c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80005df4:	30 e8       	mov	r8,14
80005df6:	f0 0b 18 00 	cp.b	r11,r8
80005dfa:	e0 8b 00 19 	brhi	80005e2c <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80005dfe:	78 18       	ld.w	r8,r12[0x4]
80005e00:	b1 6b       	lsl	r11,0x10
80005e02:	ea 1b ff f0 	orh	r11,0xfff0
80005e06:	e8 1b ff ff 	orl	r11,0xffff
80005e0a:	10 6b       	and	r11,r8
80005e0c:	99 1b       	st.w	r12[0x4],r11
80005e0e:	5e fd       	retal	0
  } else {
    if (chip > 3) {
80005e10:	30 38       	mov	r8,3
80005e12:	f0 0b 18 00 	cp.b	r11,r8
80005e16:	e0 8b 00 0b 	brhi	80005e2c <spi_selectChip+0x48>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005e1a:	78 18       	ld.w	r8,r12[0x4]
80005e1c:	2f 0b       	sub	r11,-16
80005e1e:	30 19       	mov	r9,1
80005e20:	f2 0b 09 4b 	lsl	r11,r9,r11
80005e24:	5c db       	com	r11
80005e26:	10 6b       	and	r11,r8
80005e28:	99 1b       	st.w	r12[0x4],r11
80005e2a:	5e fd       	retal	0
80005e2c:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
80005e2e:	5e fc       	retal	r12

80005e30 <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80005e30:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005e34:	c0 58       	rjmp	80005e3e <spi_unselectChip+0xe>
    if (!timeout--) {
80005e36:	58 08       	cp.w	r8,0
80005e38:	c0 21       	brne	80005e3c <spi_unselectChip+0xc>
80005e3a:	5e ff       	retal	1
80005e3c:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005e3e:	78 49       	ld.w	r9,r12[0x10]
80005e40:	e2 19 02 00 	andl	r9,0x200,COH
80005e44:	cf 90       	breq	80005e36 <spi_unselectChip+0x6>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005e46:	78 18       	ld.w	r8,r12[0x4]
80005e48:	ea 18 00 0f 	orh	r8,0xf
80005e4c:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005e4e:	fc 18 01 00 	movh	r8,0x100
80005e52:	99 08       	st.w	r12[0x0],r8
80005e54:	5e fd       	retal	0

80005e56 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80005e56:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005e5a:	f7 38 00 0c 	ld.ub	r8,r11[12]
80005e5e:	30 39       	mov	r9,3
80005e60:	f2 08 18 00 	cp.b	r8,r9
80005e64:	e0 8b 00 57 	brhi	80005f12 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
80005e68:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005e6c:	30 1e       	mov	lr,1
80005e6e:	fc 09 18 00 	cp.b	r9,lr
80005e72:	e0 8b 00 50 	brhi	80005f12 <spi_setupChipReg+0xbc>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80005e76:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80005e7a:	30 77       	mov	r7,7
80005e7c:	ee 0e 18 00 	cp.b	lr,r7
80005e80:	e0 88 00 49 	brls	80005f12 <spi_setupChipReg+0xbc>
80005e84:	31 07       	mov	r7,16
80005e86:	ee 0e 18 00 	cp.b	lr,r7
80005e8a:	e0 8b 00 44 	brhi	80005f12 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005e8e:	76 17       	ld.w	r7,r11[0x4]
80005e90:	ee 06 16 01 	lsr	r6,r7,0x1
80005e94:	0c 0a       	add	r10,r6
80005e96:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80005e9a:	ec c7 00 01 	sub	r7,r6,1
80005e9e:	e0 47 00 fe 	cp.w	r7,254
80005ea2:	e0 8b 00 38 	brhi	80005f12 <spi_setupChipReg+0xbc>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80005ea6:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80005ea8:	58 06       	cp.w	r6,0
80005eaa:	c3 45       	brlt	80005f12 <spi_setupChipReg+0xbc>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80005eac:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80005eae:	f0 06 16 01 	lsr	r6,r8,0x1
80005eb2:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80005eb6:	ec 18 00 01 	eorl	r8,0x1
80005eba:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80005ebe:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
80005ec2:	20 8e       	sub	lr,8
80005ec4:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80005ec8:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80005ecc:	f7 38 00 09 	ld.ub	r8,r11[9]
80005ed0:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005ed4:	f7 38 00 0a 	ld.ub	r8,r11[10]
80005ed8:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80005edc:	17 88       	ld.ub	r8,r11[0x0]
80005ede:	30 19       	mov	r9,1
80005ee0:	f2 08 18 00 	cp.b	r8,r9
80005ee4:	c0 e0       	breq	80005f00 <spi_setupChipReg+0xaa>
80005ee6:	c0 a3       	brcs	80005efa <spi_setupChipReg+0xa4>
80005ee8:	30 29       	mov	r9,2
80005eea:	f2 08 18 00 	cp.b	r8,r9
80005eee:	c0 c0       	breq	80005f06 <spi_setupChipReg+0xb0>
80005ef0:	30 39       	mov	r9,3
80005ef2:	f2 08 18 00 	cp.b	r8,r9
80005ef6:	c0 e1       	brne	80005f12 <spi_setupChipReg+0xbc>
80005ef8:	c0 a8       	rjmp	80005f0c <spi_setupChipReg+0xb6>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80005efa:	99 ca       	st.w	r12[0x30],r10
80005efc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80005f00:	99 da       	st.w	r12[0x34],r10
80005f02:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80005f06:	99 ea       	st.w	r12[0x38],r10
80005f08:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80005f0c:	99 fa       	st.w	r12[0x3c],r10
80005f0e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
      break;
80005f12:	30 2c       	mov	r12,2
    }
  }
#endif

  return SPI_OK;
}
80005f14:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005f18 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005f18:	30 18       	mov	r8,1
80005f1a:	99 08       	st.w	r12[0x0],r8
}
80005f1c:	5e fc       	retal	r12

80005f1e <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80005f1e:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005f22:	c0 58       	rjmp	80005f2c <spi_write+0xe>
    if (!timeout--) {
80005f24:	58 08       	cp.w	r8,0
80005f26:	c0 21       	brne	80005f2a <spi_write+0xc>
80005f28:	5e ff       	retal	1
80005f2a:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005f2c:	78 49       	ld.w	r9,r12[0x10]
80005f2e:	e2 19 00 02 	andl	r9,0x2,COH
80005f32:	cf 90       	breq	80005f24 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005f34:	5c 7b       	castu.h	r11
80005f36:	99 3b       	st.w	r12[0xc],r11
80005f38:	5e fd       	retal	0

80005f3a <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80005f3a:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005f3e:	c0 58       	rjmp	80005f48 <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80005f40:	58 08       	cp.w	r8,0
80005f42:	c0 21       	brne	80005f46 <spi_read+0xc>
80005f44:	5e ff       	retal	1
80005f46:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80005f48:	78 49       	ld.w	r9,r12[0x10]
80005f4a:	e2 19 02 01 	andl	r9,0x201,COH
80005f4e:	e0 49 02 01 	cp.w	r9,513
80005f52:	cf 71       	brne	80005f40 <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005f54:	78 28       	ld.w	r8,r12[0x8]
80005f56:	b6 08       	st.h	r11[0x0],r8
80005f58:	5e fd       	retal	0

80005f5a <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80005f5a:	76 09       	ld.w	r9,r11[0x0]
80005f5c:	58 29       	cp.w	r9,2
80005f5e:	e0 88 00 03 	brls	80005f64 <tc_init_waveform+0xa>
80005f62:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80005f64:	76 18       	ld.w	r8,r11[0x4]
80005f66:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80005f6a:	af ba       	sbr	r10,0xf
80005f6c:	10 9b       	mov	r11,r8
80005f6e:	e6 1b c0 00 	andh	r11,0xc000,COH
80005f72:	16 4a       	or	r10,r11
80005f74:	10 9b       	mov	r11,r8
80005f76:	e6 1b 30 00 	andh	r11,0x3000,COH
80005f7a:	16 4a       	or	r10,r11
80005f7c:	10 9b       	mov	r11,r8
80005f7e:	e6 1b 0c 00 	andh	r11,0xc00,COH
80005f82:	16 4a       	or	r10,r11
80005f84:	10 9b       	mov	r11,r8
80005f86:	e6 1b 03 00 	andh	r11,0x300,COH
80005f8a:	16 4a       	or	r10,r11
80005f8c:	10 9b       	mov	r11,r8
80005f8e:	e6 1b 00 c0 	andh	r11,0xc0,COH
80005f92:	16 4a       	or	r10,r11
80005f94:	10 9b       	mov	r11,r8
80005f96:	e6 1b 00 30 	andh	r11,0x30,COH
80005f9a:	16 4a       	or	r10,r11
80005f9c:	10 9b       	mov	r11,r8
80005f9e:	e6 1b 00 0c 	andh	r11,0xc,COH
80005fa2:	16 4a       	or	r10,r11
80005fa4:	10 9b       	mov	r11,r8
80005fa6:	e6 1b 00 03 	andh	r11,0x3,COH
80005faa:	16 4a       	or	r10,r11
80005fac:	10 9b       	mov	r11,r8
80005fae:	e2 1b 60 00 	andl	r11,0x6000,COH
80005fb2:	16 4a       	or	r10,r11
80005fb4:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80005fb8:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80005fbc:	10 9b       	mov	r11,r8
80005fbe:	e2 1b 0c 00 	andl	r11,0xc00,COH
80005fc2:	16 4a       	or	r10,r11
80005fc4:	10 9b       	mov	r11,r8
80005fc6:	e2 1b 03 00 	andl	r11,0x300,COH
80005fca:	16 4a       	or	r10,r11
80005fcc:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80005fd0:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80005fd4:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80005fd8:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80005fdc:	10 9b       	mov	r11,r8
80005fde:	e2 1b 00 30 	andl	r11,0x30,COH
80005fe2:	16 4a       	or	r10,r11
80005fe4:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80005fe8:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80005fec:	a5 69       	lsl	r9,0x4
80005fee:	2f f9       	sub	r9,-1
80005ff0:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80005ff4:	5e fd       	retal	0

80005ff6 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80005ff6:	58 2b       	cp.w	r11,2
80005ff8:	e0 88 00 03 	brls	80005ffe <tc_start+0x8>
80005ffc:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005ffe:	a7 6b       	lsl	r11,0x6
80006000:	16 0c       	add	r12,r11
80006002:	30 58       	mov	r8,5
80006004:	99 08       	st.w	r12[0x0],r8
80006006:	5e fd       	retal	0

80006008 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80006008:	58 2b       	cp.w	r11,2
8000600a:	e0 88 00 03 	brls	80006010 <tc_read_sr+0x8>
8000600e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80006010:	a7 6b       	lsl	r11,0x6
80006012:	2e 0b       	sub	r11,-32
80006014:	16 0c       	add	r12,r11
80006016:	78 0c       	ld.w	r12,r12[0x0]
}
80006018:	5e fc       	retal	r12

8000601a <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000601a:	58 2b       	cp.w	r11,2
8000601c:	e0 88 00 03 	brls	80006022 <tc_write_rc+0x8>
80006020:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80006022:	f6 08 15 04 	lsl	r8,r11,0x4
80006026:	2f f8       	sub	r8,-1
80006028:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
8000602c:	e2 18 80 00 	andl	r8,0x8000,COH
80006030:	c0 c0       	breq	80006048 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80006032:	a7 6b       	lsl	r11,0x6
80006034:	16 0c       	add	r12,r11
80006036:	2e 4c       	sub	r12,-28
80006038:	78 08       	ld.w	r8,r12[0x0]
8000603a:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000603e:	e0 18 00 00 	andl	r8,0x0
80006042:	f3 e8 10 08 	or	r8,r9,r8
80006046:	99 08       	st.w	r12[0x0],r8

  return value;
80006048:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
8000604c:	5e fc       	retal	r12

8000604e <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
8000604e:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80006052:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80006056:	58 2b       	cp.w	r11,2
80006058:	e0 88 00 04 	brls	80006060 <tc_configure_interrupts+0x12>
8000605c:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80006060:	ee 19 00 01 	eorh	r9,0x1
80006064:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80006068:	74 08       	ld.w	r8,r10[0x0]
8000606a:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
8000606e:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80006072:	a7 6e       	lsl	lr,0x6
80006074:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80006078:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
8000607c:	0e 4e       	or	lr,r7
8000607e:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80006082:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80006086:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
8000608a:	fd e7 10 4e 	or	lr,lr,r7<<0x4
8000608e:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80006092:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80006096:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
8000609a:	fd e7 10 2e 	or	lr,lr,r7<<0x2
8000609e:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800060a2:	fd e8 10 18 	or	r8,lr,r8<<0x1
800060a6:	f6 0e 15 06 	lsl	lr,r11,0x6
800060aa:	f8 0e 00 0e 	add	lr,r12,lr
800060ae:	2d ce       	sub	lr,-36
800060b0:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
800060b2:	58 09       	cp.w	r9,0
800060b4:	c0 20       	breq	800060b8 <tc_configure_interrupts+0x6a>
800060b6:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800060b8:	74 08       	ld.w	r8,r10[0x0]
800060ba:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
800060be:	e0 65 00 80 	mov	r5,128
800060c2:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
800060c6:	74 08       	ld.w	r8,r10[0x0]
800060c8:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
800060cc:	f9 b4 00 40 	moveq	r4,64
800060d0:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
800060d4:	74 08       	ld.w	r8,r10[0x0]
800060d6:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
800060da:	f9 b3 00 20 	moveq	r3,32
800060de:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
800060e2:	74 08       	ld.w	r8,r10[0x0]
800060e4:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800060e8:	f9 b2 00 10 	moveq	r2,16
800060ec:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800060f0:	74 08       	ld.w	r8,r10[0x0]
800060f2:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800060f6:	f9 b6 00 08 	moveq	r6,8
800060fa:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800060fe:	74 08       	ld.w	r8,r10[0x0]
80006100:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80006104:	f9 b7 00 04 	moveq	r7,4
80006108:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
8000610c:	74 08       	ld.w	r8,r10[0x0]
8000610e:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80006112:	f9 be 00 02 	moveq	lr,2
80006116:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
8000611a:	74 08       	ld.w	r8,r10[0x0]
8000611c:	ec 18 00 01 	eorl	r8,0x1
80006120:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006124:	eb e8 10 08 	or	r8,r5,r8
80006128:	08 48       	or	r8,r4
8000612a:	06 48       	or	r8,r3
8000612c:	04 48       	or	r8,r2
8000612e:	0c 48       	or	r8,r6
80006130:	0e 48       	or	r8,r7
80006132:	1c 48       	or	r8,lr
80006134:	f6 0a 15 06 	lsl	r10,r11,0x6
80006138:	f8 0a 00 0a 	add	r10,r12,r10
8000613c:	2d 8a       	sub	r10,-40
8000613e:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80006140:	a7 6b       	lsl	r11,0x6
80006142:	2e 0b       	sub	r11,-32
80006144:	16 0c       	add	r12,r11
80006146:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80006148:	58 09       	cp.w	r9,0
8000614a:	c0 31       	brne	80006150 <tc_configure_interrupts+0x102>
8000614c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80006150:	d5 03       	csrf	0x10
80006152:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80006156:	d7 03       	nop

80006158 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80006158:	4a 78       	lddpc	r8,800061f4 <twi_master_interrupt_handler+0x9c>
8000615a:	70 08       	ld.w	r8,r8[0x0]
8000615c:	70 89       	ld.w	r9,r8[0x20]
8000615e:	4a 7a       	lddpc	r10,800061f8 <twi_master_interrupt_handler+0xa0>
80006160:	74 0a       	ld.w	r10,r10[0x0]
80006162:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80006166:	12 9a       	mov	r10,r9
80006168:	e2 1a 01 00 	andl	r10,0x100,COH
8000616c:	c3 91       	brne	800061de <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
8000616e:	12 9a       	mov	r10,r9
80006170:	e2 1a 00 02 	andl	r10,0x2,COH
80006174:	c1 70       	breq	800061a2 <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80006176:	4a 29       	lddpc	r9,800061fc <twi_master_interrupt_handler+0xa4>
80006178:	72 0a       	ld.w	r10,r9[0x0]
8000617a:	70 cb       	ld.w	r11,r8[0x30]
8000617c:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
8000617e:	72 0a       	ld.w	r10,r9[0x0]
80006180:	2f fa       	sub	r10,-1
80006182:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80006184:	49 f9       	lddpc	r9,80006200 <twi_master_interrupt_handler+0xa8>
80006186:	72 0a       	ld.w	r10,r9[0x0]
80006188:	20 1a       	sub	r10,1
8000618a:	93 0a       	st.w	r9[0x0],r10
8000618c:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
8000618e:	58 19       	cp.w	r9,1
80006190:	f9 b9 00 02 	moveq	r9,2
80006194:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80006198:	49 a9       	lddpc	r9,80006200 <twi_master_interrupt_handler+0xa8>
8000619a:	72 09       	ld.w	r9,r9[0x0]
8000619c:	58 09       	cp.w	r9,0
8000619e:	c2 30       	breq	800061e4 <twi_master_interrupt_handler+0x8c>
800061a0:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
800061a2:	12 9a       	mov	r10,r9
800061a4:	e2 1a 00 04 	andl	r10,0x4,COH
800061a8:	c1 70       	breq	800061d6 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
800061aa:	49 79       	lddpc	r9,80006204 <twi_master_interrupt_handler+0xac>
800061ac:	72 0a       	ld.w	r10,r9[0x0]
800061ae:	20 1a       	sub	r10,1
800061b0:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
800061b2:	72 09       	ld.w	r9,r9[0x0]
800061b4:	58 09       	cp.w	r9,0
800061b6:	e0 89 00 0a 	brgt	800061ca <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
800061ba:	49 09       	lddpc	r9,800061f8 <twi_master_interrupt_handler+0xa0>
800061bc:	30 1a       	mov	r10,1
800061be:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
800061c0:	3f fa       	mov	r10,-1
800061c2:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
800061c4:	72 09       	ld.w	r9,r9[0x0]
800061c6:	91 99       	st.w	r8[0x24],r9
800061c8:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
800061ca:	49 0a       	lddpc	r10,80006208 <twi_master_interrupt_handler+0xb0>
800061cc:	74 09       	ld.w	r9,r10[0x0]
800061ce:	13 3b       	ld.ub	r11,r9++
800061d0:	91 db       	st.w	r8[0x34],r11
800061d2:	95 09       	st.w	r10[0x0],r9
800061d4:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
800061d6:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800061da:	c0 51       	brne	800061e4 <twi_master_interrupt_handler+0x8c>
800061dc:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
800061de:	30 1a       	mov	r10,1
800061e0:	48 b9       	lddpc	r9,8000620c <twi_master_interrupt_handler+0xb4>
800061e2:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
800061e4:	3f f9       	mov	r9,-1
800061e6:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
800061e8:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
800061ea:	30 09       	mov	r9,0
800061ec:	48 98       	lddpc	r8,80006210 <twi_master_interrupt_handler+0xb8>
800061ee:	b0 89       	st.b	r8[0x0],r9
800061f0:	d6 03       	rete
800061f2:	00 00       	add	r0,r0
800061f4:	00 00       	add	r0,r0
800061f6:	11 c4       	ld.ub	r4,r8[0x4]
800061f8:	00 00       	add	r0,r0
800061fa:	11 c0       	ld.ub	r0,r8[0x4]
800061fc:	00 00       	add	r0,r0
800061fe:	11 d0       	ld.ub	r0,r8[0x5]
80006200:	00 00       	add	r0,r0
80006202:	11 cc       	ld.ub	r12,r8[0x4]
80006204:	00 00       	add	r0,r0
80006206:	11 bc       	ld.ub	r12,r8[0x3]
80006208:	00 00       	add	r0,r0
8000620a:	11 c8       	ld.ub	r8,r8[0x4]
8000620c:	00 00       	add	r0,r0
8000620e:	11 b9       	ld.ub	r9,r8[0x3]
80006210:	00 00       	add	r0,r0
80006212:	11 b8       	ld.ub	r8,r8[0x3]

80006214 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80006214:	eb cd 40 e0 	pushm	r5-r7,lr
80006218:	18 97       	mov	r7,r12
8000621a:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
8000621c:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80006220:	49 f9       	lddpc	r9,8000629c <twi_master_init+0x88>
80006222:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80006224:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80006226:	3f f9       	mov	r9,-1
80006228:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
8000622a:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
8000622c:	e0 69 00 80 	mov	r9,128
80006230:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006232:	e6 18 00 01 	andh	r8,0x1,COH
80006236:	c0 21       	brne	8000623a <twi_master_init+0x26>
      cpu_irq_enable();
80006238:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
8000623a:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000623c:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80006240:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80006242:	30 3a       	mov	r10,3
80006244:	e0 6b 01 60 	mov	r11,352
80006248:	49 6c       	lddpc	r12,800062a0 <twi_master_init+0x8c>
8000624a:	f0 1f 00 17 	mcall	800062a4 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000624e:	e6 16 00 01 	andh	r6,0x1,COH
80006252:	c0 21       	brne	80006256 <twi_master_init+0x42>
      cpu_irq_enable();
80006254:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80006256:	6a 19       	ld.w	r9,r5[0x4]
80006258:	a1 79       	lsl	r9,0x1
8000625a:	6a 08       	ld.w	r8,r5[0x0]
8000625c:	f0 09 0d 08 	divu	r8,r8,r9
80006260:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80006262:	e0 48 00 ff 	cp.w	r8,255
80006266:	e0 8b 00 04 	brhi	8000626e <twi_master_init+0x5a>
8000626a:	30 09       	mov	r9,0
8000626c:	c0 f8       	rjmp	8000628a <twi_master_init+0x76>
8000626e:	30 09       	mov	r9,0
80006270:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80006272:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80006274:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80006276:	e0 48 00 ff 	cp.w	r8,255
8000627a:	5f bb       	srhi	r11
8000627c:	58 69       	cp.w	r9,6
8000627e:	5f 8a       	srls	r10
80006280:	f7 ea 00 0a 	and	r10,r11,r10
80006284:	f8 0a 18 00 	cp.b	r10,r12
80006288:	cf 51       	brne	80006272 <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
8000628a:	b1 69       	lsl	r9,0x10
8000628c:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80006290:	f3 e8 10 08 	or	r8,r9,r8
80006294:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80006296:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000629a:	00 00       	add	r0,r0
8000629c:	00 00       	add	r0,r0
8000629e:	11 c4       	ld.ub	r4,r8[0x4]
800062a0:	80 00       	ld.sh	r0,r0[0x0]
800062a2:	61 58       	ld.w	r8,r0[0x54]
800062a4:	80 00       	ld.sh	r0,r0[0x0]
800062a6:	5c 74       	castu.h	r4

800062a8 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800062a8:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800062aa:	f6 08 15 04 	lsl	r8,r11,0x4
800062ae:	14 38       	cp.w	r8,r10
800062b0:	f9 b8 08 10 	movls	r8,16
800062b4:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800062b8:	f0 0b 02 4b 	mul	r11,r8,r11
800062bc:	f6 09 16 01 	lsr	r9,r11,0x1
800062c0:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800062c4:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800062c8:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800062cc:	f2 cb 00 01 	sub	r11,r9,1
800062d0:	e0 4b ff fe 	cp.w	r11,65534
800062d4:	e0 88 00 03 	brls	800062da <usart_set_async_baudrate+0x32>
800062d8:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800062da:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800062dc:	e8 6e 00 00 	mov	lr,524288
800062e0:	59 08       	cp.w	r8,16
800062e2:	fc 08 17 10 	movne	r8,lr
800062e6:	f9 b8 00 00 	moveq	r8,0
800062ea:	e4 1b ff f7 	andh	r11,0xfff7
800062ee:	e0 1b fe cf 	andl	r11,0xfecf
800062f2:	16 48       	or	r8,r11
800062f4:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800062f6:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800062fa:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800062fe:	99 89       	st.w	r12[0x20],r9
80006300:	d8 0a       	popm	pc,r12=0

80006302 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80006302:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80006304:	e2 18 00 02 	andl	r8,0x2,COH
80006308:	c0 31       	brne	8000630e <usart_write_char+0xc>
8000630a:	30 2c       	mov	r12,2
8000630c:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000630e:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80006312:	99 7b       	st.w	r12[0x1c],r11
80006314:	5e fd       	retal	0
80006316:	d7 03       	nop

80006318 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80006318:	eb cd 40 e0 	pushm	r5-r7,lr
8000631c:	18 96       	mov	r6,r12
8000631e:	16 95       	mov	r5,r11
80006320:	e0 67 27 0f 	mov	r7,9999
80006324:	c0 68       	rjmp	80006330 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80006326:	58 07       	cp.w	r7,0
80006328:	c0 31       	brne	8000632e <usart_putchar+0x16>
8000632a:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000632e:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80006330:	0a 9b       	mov	r11,r5
80006332:	0c 9c       	mov	r12,r6
80006334:	f0 1f 00 03 	mcall	80006340 <usart_putchar+0x28>
80006338:	cf 71       	brne	80006326 <usart_putchar+0xe>

  return USART_SUCCESS;
}
8000633a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000633e:	00 00       	add	r0,r0
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	63 02       	ld.w	r2,r1[0x40]

80006344 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80006344:	78 58       	ld.w	r8,r12[0x14]
80006346:	e2 18 00 e0 	andl	r8,0xe0,COH
8000634a:	c0 30       	breq	80006350 <usart_read_char+0xc>
8000634c:	30 4c       	mov	r12,4
8000634e:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80006350:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80006352:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006356:	c0 31       	brne	8000635c <usart_read_char+0x18>
80006358:	30 3c       	mov	r12,3
8000635a:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
8000635c:	78 68       	ld.w	r8,r12[0x18]
8000635e:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80006362:	97 08       	st.w	r11[0x0],r8
80006364:	5e fd       	retal	0
80006366:	d7 03       	nop

80006368 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80006368:	eb cd 40 c0 	pushm	r6-r7,lr
8000636c:	20 1d       	sub	sp,4
8000636e:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80006370:	1a 97       	mov	r7,sp
80006372:	1a 9b       	mov	r11,sp
80006374:	0c 9c       	mov	r12,r6
80006376:	f0 1f 00 07 	mcall	80006390 <usart_getchar+0x28>
8000637a:	58 3c       	cp.w	r12,3
8000637c:	cf b0       	breq	80006372 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000637e:	58 4c       	cp.w	r12,4
80006380:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80006384:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80006388:	2f fd       	sub	sp,-4
8000638a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000638e:	00 00       	add	r0,r0
80006390:	80 00       	ld.sh	r0,r0[0x0]
80006392:	63 44       	ld.w	r4,r1[0x50]

80006394 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80006394:	eb cd 40 c0 	pushm	r6-r7,lr
80006398:	18 96       	mov	r6,r12
8000639a:	16 97       	mov	r7,r11
  while (*string != '\0')
8000639c:	17 8b       	ld.ub	r11,r11[0x0]
8000639e:	58 0b       	cp.w	r11,0
800063a0:	c0 80       	breq	800063b0 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800063a2:	2f f7       	sub	r7,-1
800063a4:	0c 9c       	mov	r12,r6
800063a6:	f0 1f 00 04 	mcall	800063b4 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800063aa:	0f 8b       	ld.ub	r11,r7[0x0]
800063ac:	58 0b       	cp.w	r11,0
800063ae:	cf a1       	brne	800063a2 <usart_write_line+0xe>
800063b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063b4:	80 00       	ld.sh	r0,r0[0x0]
800063b6:	63 18       	ld.w	r8,r1[0x44]

800063b8 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800063b8:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800063bc:	e6 18 00 01 	andh	r8,0x1,COH
800063c0:	c0 71       	brne	800063ce <usart_reset+0x16>
800063c2:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800063c4:	3f f8       	mov	r8,-1
800063c6:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800063c8:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800063ca:	d5 03       	csrf	0x10
800063cc:	c0 48       	rjmp	800063d4 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800063ce:	3f f8       	mov	r8,-1
800063d0:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800063d2:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800063d4:	30 08       	mov	r8,0
800063d6:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800063d8:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800063da:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800063dc:	ea 68 61 0c 	mov	r8,680204
800063e0:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800063e2:	5e fc       	retal	r12

800063e4 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800063e4:	eb cd 40 e0 	pushm	r5-r7,lr
800063e8:	18 96       	mov	r6,r12
800063ea:	16 97       	mov	r7,r11
800063ec:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800063ee:	f0 1f 00 2f 	mcall	800064a8 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800063f2:	58 07       	cp.w	r7,0
800063f4:	c5 80       	breq	800064a4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800063f6:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800063f8:	30 49       	mov	r9,4
800063fa:	f2 08 18 00 	cp.b	r8,r9
800063fe:	e0 88 00 53 	brls	800064a4 <usart_init_rs232+0xc0>
80006402:	30 99       	mov	r9,9
80006404:	f2 08 18 00 	cp.b	r8,r9
80006408:	e0 8b 00 4e 	brhi	800064a4 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
8000640c:	0f d9       	ld.ub	r9,r7[0x5]
8000640e:	30 78       	mov	r8,7
80006410:	f0 09 18 00 	cp.b	r9,r8
80006414:	e0 8b 00 48 	brhi	800064a4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80006418:	8e 39       	ld.sh	r9,r7[0x6]
8000641a:	e0 68 01 01 	mov	r8,257
8000641e:	f0 09 19 00 	cp.h	r9,r8
80006422:	e0 8b 00 41 	brhi	800064a4 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80006426:	ef 39 00 08 	ld.ub	r9,r7[8]
8000642a:	30 38       	mov	r8,3
8000642c:	f0 09 18 00 	cp.b	r9,r8
80006430:	e0 8b 00 3a 	brhi	800064a4 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80006434:	0a 9a       	mov	r10,r5
80006436:	6e 0b       	ld.w	r11,r7[0x0]
80006438:	0c 9c       	mov	r12,r6
8000643a:	f0 1f 00 1d 	mcall	800064ac <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000643e:	58 1c       	cp.w	r12,1
80006440:	c3 20       	breq	800064a4 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80006442:	0f c8       	ld.ub	r8,r7[0x4]
80006444:	30 99       	mov	r9,9
80006446:	f2 08 18 00 	cp.b	r8,r9
8000644a:	c0 51       	brne	80006454 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
8000644c:	6c 18       	ld.w	r8,r6[0x4]
8000644e:	b1 b8       	sbr	r8,0x11
80006450:	8d 18       	st.w	r6[0x4],r8
80006452:	c0 68       	rjmp	8000645e <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80006454:	6c 19       	ld.w	r9,r6[0x4]
80006456:	20 58       	sub	r8,5
80006458:	f3 e8 10 68 	or	r8,r9,r8<<0x6
8000645c:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000645e:	6c 19       	ld.w	r9,r6[0x4]
80006460:	ef 3a 00 08 	ld.ub	r10,r7[8]
80006464:	0f d8       	ld.ub	r8,r7[0x5]
80006466:	a9 78       	lsl	r8,0x9
80006468:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
8000646c:	12 48       	or	r8,r9
8000646e:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80006470:	8e 38       	ld.sh	r8,r7[0x6]
80006472:	30 29       	mov	r9,2
80006474:	f2 08 19 00 	cp.h	r8,r9
80006478:	e0 88 00 09 	brls	8000648a <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000647c:	6c 18       	ld.w	r8,r6[0x4]
8000647e:	ad b8       	sbr	r8,0xd
80006480:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80006482:	8e b8       	ld.uh	r8,r7[0x6]
80006484:	20 28       	sub	r8,2
80006486:	8d a8       	st.w	r6[0x28],r8
80006488:	c0 68       	rjmp	80006494 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000648a:	6c 19       	ld.w	r9,r6[0x4]
8000648c:	5c 78       	castu.h	r8
8000648e:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80006492:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80006494:	6c 18       	ld.w	r8,r6[0x4]
80006496:	e0 18 ff f0 	andl	r8,0xfff0
8000649a:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
8000649c:	35 08       	mov	r8,80
8000649e:	8d 08       	st.w	r6[0x0],r8
800064a0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800064a4:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	63 b8       	ld.w	r8,r1[0x6c]
800064ac:	80 00       	ld.sh	r0,r0[0x0]
800064ae:	62 a8       	ld.w	r8,r1[0x28]

800064b0 <disk_status>:


	return RES_OK;

	
}
800064b0:	5e fd       	retal	0

800064b2 <disk_initialize>:
	//}
	//return STA_NOINIT;

	return stat;
	
}
800064b2:	5e fd       	retal	0

800064b4 <get_fattime>:
	
}
#endif

DWORD get_fattime(void)
{
800064b4:	d4 01       	pushm	lr
	DWORD current_time = 0;
	date_time_t *t = now();
800064b6:	f0 1f 00 0e 	mcall	800064ec <get_fattime+0x38>

	current_time = (t->year - 1980) << 25;
800064ba:	19 89       	ld.ub	r9,r12[0x0]
800064bc:	19 98       	ld.ub	r8,r12[0x1]
800064be:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800064c2:	f0 c8 07 bc 	sub	r8,r8,1980
800064c6:	b9 78       	lsl	r8,0x19
	current_time += t->month << 21;
800064c8:	19 aa       	ld.ub	r10,r12[0x2]
800064ca:	b5 7a       	lsl	r10,0x15
800064cc:	19 b9       	ld.ub	r9,r12[0x3]
800064ce:	b1 69       	lsl	r9,0x10
800064d0:	12 0a       	add	r10,r9
	current_time += t->day << 16;
800064d2:	19 f9       	ld.ub	r9,r12[0x7]
800064d4:	a1 99       	lsr	r9,0x1
800064d6:	12 0a       	add	r10,r9
	current_time += t->hour << 11;
800064d8:	19 d9       	ld.ub	r9,r12[0x5]
800064da:	ab 79       	lsl	r9,0xb
800064dc:	12 0a       	add	r10,r9
	current_time += t->minute << 5;
800064de:	19 e9       	ld.ub	r9,r12[0x6]
800064e0:	a5 79       	lsl	r9,0x5
800064e2:	f4 09 00 0c 	add	r12,r10,r9
	current_time += t->second / 2;
	
	return current_time;
800064e6:	10 0c       	add	r12,r8
800064e8:	d8 02       	popm	pc
800064ea:	00 00       	add	r0,r0
800064ec:	80 00       	ld.sh	r0,r0[0x0]
800064ee:	5b 0c       	cp.w	r12,-16

800064f0 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
800064f0:	eb cd 40 80 	pushm	r7,lr
800064f4:	14 97       	mov	r7,r10
	
	DRESULT res = RES_OK ;
	
	switch (cmd)
800064f6:	30 18       	mov	r8,1
800064f8:	f0 0b 18 00 	cp.b	r11,r8
800064fc:	c1 a0       	breq	80006530 <disk_ioctl+0x40>
800064fe:	58 0b       	cp.w	r11,0
80006500:	c0 c0       	breq	80006518 <disk_ioctl+0x28>
80006502:	30 28       	mov	r8,2
80006504:	f0 0b 18 00 	cp.b	r11,r8
80006508:	c0 a0       	breq	8000651c <disk_ioctl+0x2c>
8000650a:	30 38       	mov	r8,3
8000650c:	f0 0b 18 00 	cp.b	r11,r8
80006510:	c0 b0       	breq	80006526 <disk_ioctl+0x36>
80006512:	30 4c       	mov	r12,4
80006514:	e3 cd 80 80 	ldm	sp++,r7,pc
80006518:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	  
			break;
	  
		case GET_SECTOR_SIZE:
		
			*(WORD*)buff = 512;
8000651c:	e0 68 02 00 	mov	r8,512
80006520:	b4 08       	st.h	r10[0x0],r8
80006522:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;	
		
		case GET_BLOCK_SIZE:
		
			*(WORD*)buff = 512;
80006526:	e0 68 02 00 	mov	r8,512
8000652a:	b4 08       	st.h	r10[0x0],r8
8000652c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		
			break;
		
		case GET_SECTOR_COUNT:
		
			*(DWORD*)buff = SD_GetSectorCount();
80006530:	f0 1f 00 03 	mcall	8000653c <disk_ioctl+0x4c>
80006534:	8f 0c       	st.w	r7[0x0],r12
80006536:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
8000653a:	00 00       	add	r0,r0
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	34 d0       	mov	r0,77

80006540 <disk_write>:
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count			/* Number of sectors to write */
)
{
80006540:	d4 01       	pushm	lr
80006542:	16 9c       	mov	r12,r11
80006544:	14 9b       	mov	r11,r10


	*******************************/

	
	 if(MAL_WriteDisk(buff, sector, BLOCK_BYTE_SIZE, count)==WRITE_DATA_SUCCESS)
80006546:	5c 59       	castu.b	r9
80006548:	e0 6a 02 00 	mov	r10,512
8000654c:	f0 1f 00 03 	mcall	80006558 <disk_write+0x18>
80006550:	58 4c       	cp.w	r12,4
	 return RES_ERROR;
	



}
80006552:	5f 1c       	srne	r12
80006554:	d8 02       	popm	pc
80006556:	00 00       	add	r0,r0
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	34 f0       	mov	r0,79

8000655c <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
8000655c:	d4 01       	pushm	lr
8000655e:	16 9c       	mov	r12,r11
80006560:	14 9b       	mov	r11,r10

	***********************************/

	

	if(MAL_ReadDisk(buff, sector, BLOCK_BYTE_SIZE, count)==READ_DATA_SUCCESS)
80006562:	5c 59       	castu.b	r9
80006564:	e0 6a 02 00 	mov	r10,512
80006568:	f0 1f 00 03 	mcall	80006574 <disk_read+0x18>
8000656c:	58 8c       	cp.w	r12,8
   		return RES_ERROR;




}
8000656e:	5f 1c       	srne	r12
80006570:	d8 02       	popm	pc
80006572:	00 00       	add	r0,r0
80006574:	80 00       	ld.sh	r0,r0[0x0]
80006576:	35 20       	mov	r0,82

80006578 <mem_cpy>:
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
80006578:	58 0a       	cp.w	r10,0
8000657a:	5e 0c       	reteq	r12
8000657c:	30 08       	mov	r8,0
		*d++ = *s++;
8000657e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006582:	f8 08 0b 09 	st.b	r12[r8],r9
80006586:	2f f8       	sub	r8,-1
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
80006588:	14 38       	cp.w	r8,r10
8000658a:	cf a1       	brne	8000657e <mem_cpy+0x6>
8000658c:	5e fc       	retal	r12

8000658e <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
8000658e:	58 0a       	cp.w	r10,0
80006590:	5e 0c       	reteq	r12
		*d++ = (BYTE)val;
80006592:	18 cb       	st.b	r12++,r11
80006594:	20 1a       	sub	r10,1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
80006596:	cf e1       	brne	80006592 <mem_set+0x4>
80006598:	5e fc       	retal	r12

8000659a <chk_chr>:
	return r;
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
8000659a:	18 98       	mov	r8,r12
	while (*str && *str != chr) str++;
8000659c:	19 8c       	ld.ub	r12,r12[0x0]
8000659e:	58 0c       	cp.w	r12,0
800065a0:	5e 0c       	reteq	r12
800065a2:	16 3c       	cp.w	r12,r11
800065a4:	5e 0c       	reteq	r12
800065a6:	2f f8       	sub	r8,-1
800065a8:	11 8c       	ld.ub	r12,r8[0x0]
800065aa:	58 0c       	cp.w	r12,0
800065ac:	5e 0c       	reteq	r12
800065ae:	16 3c       	cp.w	r12,r11
800065b0:	cf b1       	brne	800065a6 <chk_chr+0xc>
	return *str;
}
800065b2:	5e fc       	retal	r12

800065b4 <clust2sect>:
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
800065b4:	20 2b       	sub	r11,2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
800065b6:	78 58       	ld.w	r8,r12[0x14]
800065b8:	20 28       	sub	r8,2
800065ba:	10 3b       	cp.w	r11,r8
800065bc:	c0 23       	brcs	800065c0 <clust2sect+0xc>
800065be:	5e fd       	retal	0
	return clst * fs->csize + fs->database;
800065c0:	19 a8       	ld.ub	r8,r12[0x2]
800065c2:	b1 3b       	mul	r11,r8
800065c4:	78 a8       	ld.w	r8,r12[0x28]
800065c6:	f6 08 00 0c 	add	r12,r11,r8
}
800065ca:	5e fc       	retal	r12

800065cc <clmt_clust>:
)
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
800065cc:	78 9a       	ld.w	r10,r12[0x24]
800065ce:	2f ca       	sub	r10,-4
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
800065d0:	78 08       	ld.w	r8,r12[0x0]
800065d2:	11 a8       	ld.ub	r8,r8[0x2]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
800065d4:	74 0c       	ld.w	r12,r10[0x0]
		if (!ncl) return 0;		/* End of table? (error) */
800065d6:	58 0c       	cp.w	r12,0
800065d8:	c1 80       	breq	80006608 <clmt_clust+0x3c>
{
	DWORD cl, ncl, *tbl;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
800065da:	f6 09 16 09 	lsr	r9,r11,0x9
800065de:	f2 08 0d 08 	divu	r8,r9,r8
800065e2:	10 99       	mov	r9,r8
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
800065e4:	2f ca       	sub	r10,-4
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
800065e6:	18 38       	cp.w	r8,r12
800065e8:	c0 82       	brcc	800065f8 <clmt_clust+0x2c>
800065ea:	c0 b8       	rjmp	80006600 <clmt_clust+0x34>
		cl -= ncl; tbl++;		/* Next fragment */
800065ec:	18 19       	sub	r9,r12
/* FAT handling - Convert offset into cluster with link map table        */
/*-----------------------------------------------------------------------*/

#if _USE_FASTSEEK
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
800065ee:	2f 8a       	sub	r10,-8
	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
		if (!ncl) return 0;		/* End of table? (error) */
		if (cl < ncl) break;	/* In this fragment? */
800065f0:	12 38       	cp.w	r8,r9
800065f2:	e0 8b 00 07 	brhi	80006600 <clmt_clust+0x34>
800065f6:	10 9c       	mov	r12,r8


	tbl = fp->cltbl + 1;	/* Top of CLMT */
	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
800065f8:	74 18       	ld.w	r8,r10[0x4]
		if (!ncl) return 0;		/* End of table? (error) */
800065fa:	58 08       	cp.w	r8,0
800065fc:	cf 81       	brne	800065ec <clmt_clust+0x20>
800065fe:	c0 58       	rjmp	80006608 <clmt_clust+0x3c>
		if (cl < ncl) break;	/* In this fragment? */
		cl -= ncl; tbl++;		/* Next fragment */
	}
	return cl + *tbl;	/* Return the cluster number */
80006600:	74 0c       	ld.w	r12,r10[0x0]
80006602:	f2 0c 00 0c 	add	r12,r9,r12
80006606:	5e fc       	retal	r12
80006608:	5e fd       	retal	0

8000660a <ld_clust>:
	const BYTE* dir	/* Pointer to the SFN entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
8000660a:	f7 39 00 1b 	ld.ub	r9,r11[27]
8000660e:	f7 38 00 1a 	ld.ub	r8,r11[26]
80006612:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (fs->fs_type == FS_FAT32)
80006616:	19 8a       	ld.ub	r10,r12[0x0]
80006618:	30 39       	mov	r9,3
8000661a:	f2 0a 18 00 	cp.b	r10,r9
8000661e:	c0 91       	brne	80006630 <ld_clust+0x26>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
80006620:	f7 3a 00 15 	ld.ub	r10,r11[21]
80006624:	f7 39 00 14 	ld.ub	r9,r11[20]
80006628:	f3 ea 10 89 	or	r9,r9,r10<<0x8
8000662c:	f1 e9 11 08 	or	r8,r8,r9<<0x10

	return cl;
}
80006630:	5e f8       	retal	r8

80006632 <st_clust>:
void st_clust (
	BYTE* dir,	/* Pointer to the SFN entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir + DIR_FstClusLO, cl);
80006632:	f9 6b 00 1a 	st.b	r12[26],r11
80006636:	f1 db c1 08 	bfextu	r8,r11,0x8,0x8
8000663a:	f9 68 00 1b 	st.b	r12[27],r8
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
8000663e:	b1 8b       	lsr	r11,0x10
80006640:	f9 6b 00 14 	st.b	r12[20],r11
80006644:	a9 8b       	lsr	r11,0x8
80006646:	f9 6b 00 15 	st.b	r12[21],r11
}
8000664a:	5e fc       	retal	r12

8000664c <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
8000664c:	d4 21       	pushm	r4-r7,lr
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
8000664e:	78 05       	ld.w	r5,r12[0x0]
80006650:	58 05       	cp.w	r5,0
80006652:	c5 50       	breq	800066fc <get_ldnumber+0xb0>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
80006654:	0b 84       	ld.ub	r4,r5[0x0]
80006656:	32 08       	mov	r8,32
80006658:	f0 04 18 00 	cp.b	r4,r8
8000665c:	5f b9       	srhi	r9
8000665e:	33 a8       	mov	r8,58
80006660:	f0 04 18 00 	cp.b	r4,r8
80006664:	5f 18       	srne	r8
80006666:	f3 e8 00 08 	and	r8,r9,r8
8000666a:	c0 41       	brne	80006672 <get_ldnumber+0x26>
8000666c:	08 99       	mov	r9,r4
8000666e:	0a 98       	mov	r8,r5
80006670:	c1 28       	rjmp	80006694 <get_ldnumber+0x48>
80006672:	0a 98       	mov	r8,r5
80006674:	32 06       	mov	r6,32
80006676:	33 a7       	mov	r7,58
80006678:	30 0e       	mov	lr,0
8000667a:	2f f8       	sub	r8,-1
8000667c:	11 89       	ld.ub	r9,r8[0x0]
8000667e:	ec 09 18 00 	cp.b	r9,r6
80006682:	5f bb       	srhi	r11
80006684:	ee 09 18 00 	cp.b	r9,r7
80006688:	5f 1a       	srne	r10
8000668a:	f7 ea 00 0a 	and	r10,r11,r10
8000668e:	fc 0a 18 00 	cp.b	r10,lr
80006692:	cf 41       	brne	8000667a <get_ldnumber+0x2e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
80006694:	33 aa       	mov	r10,58
80006696:	f4 09 18 00 	cp.b	r9,r10
8000669a:	c0 30       	breq	800066a0 <get_ldnumber+0x54>
8000669c:	30 04       	mov	r4,0
8000669e:	c3 08       	rjmp	800066fe <get_ldnumber+0xb2>
			tp = *path;
			i = *tp++ - '0'; 
800066a0:	23 04       	sub	r4,48
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
800066a2:	58 94       	cp.w	r4,9
800066a4:	5f 8a       	srls	r10
800066a6:	ea c9 ff ff 	sub	r9,r5,-1
800066aa:	12 38       	cp.w	r8,r9
800066ac:	5f 09       	sreq	r9
800066ae:	f5 e9 00 09 	and	r9,r10,r9
800066b2:	c0 60       	breq	800066be <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
800066b4:	58 04       	cp.w	r4,0
800066b6:	c2 31       	brne	800066fc <get_ldnumber+0xb0>
					vol = (int)i;
					*path = ++tt;
800066b8:	2f f8       	sub	r8,-1
800066ba:	99 08       	st.w	r12[0x0],r8
800066bc:	c2 18       	rjmp	800066fe <get_ldnumber+0xb2>
				}
			}
#if _STR_VOLUME_ID
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
800066be:	2f f8       	sub	r8,-1
				do {
					sp = str[i]; tp = *path;
800066c0:	49 17       	lddpc	r7,80006704 <get_ldnumber+0xb8>
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
						if (IsLower(tc)) tc -= 0x20;
800066c2:	31 96       	mov	r6,25
					} while (c && (TCHAR)c == tc);
800066c4:	30 0e       	mov	lr,0
			 else {	/* No numeric drive number, find string drive id */
				i = 0; tt++;
				do {
					sp = str[i]; tp = *path;
					do {	/* Compare a string drive id with path name */
						c = *sp++; tc = *tp++;
800066c6:	0f 3a       	ld.ub	r10,r7++
800066c8:	0b 39       	ld.ub	r9,r5++
						if (IsLower(tc)) tc -= 0x20;
800066ca:	f2 cb 00 61 	sub	r11,r9,97
800066ce:	ec 0b 18 00 	cp.b	r11,r6
800066d2:	e0 8b 00 03 	brhi	800066d8 <get_ldnumber+0x8c>
800066d6:	22 09       	sub	r9,32
					} while (c && (TCHAR)c == tc);
800066d8:	fc 0a 18 00 	cp.b	r10,lr
800066dc:	5f 1b       	srne	r11
800066de:	f2 0a 18 00 	cp.b	r10,r9
800066e2:	5f 09       	sreq	r9
800066e4:	f7 e9 00 09 	and	r9,r11,r9
800066e8:	fc 09 18 00 	cp.b	r9,lr
800066ec:	ce d1       	brne	800066c6 <get_ldnumber+0x7a>
				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
800066ee:	10 35       	cp.w	r5,r8
800066f0:	5f 19       	srne	r9
800066f2:	12 4b       	or	r11,r9
800066f4:	c0 41       	brne	800066fc <get_ldnumber+0xb0>
					vol = (int)i;
					*path = tt;
800066f6:	99 08       	st.w	r12[0x0],r8
800066f8:	30 04       	mov	r4,0
800066fa:	c0 28       	rjmp	800066fe <get_ldnumber+0xb2>
800066fc:	3f f4       	mov	r4,-1
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
800066fe:	08 9c       	mov	r12,r4
80006700:	d8 22       	popm	r4-r7,pc
80006702:	00 00       	add	r0,r0
80006704:	80 01       	ld.sh	r1,r0[0x0]
80006706:	95 40       	st.w	r10[0x10],r0

80006708 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
80006708:	eb cd 40 f8 	pushm	r3-r7,lr
8000670c:	18 97       	mov	r7,r12
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
8000670e:	19 c9       	ld.ub	r9,r12[0x4]
80006710:	30 08       	mov	r8,0
80006712:	f0 09 18 00 	cp.b	r9,r8
80006716:	c2 60       	breq	80006762 <sync_window+0x5a>
		wsect = fs->winsect;	/* Current sector number */
80006718:	78 b6       	ld.w	r6,r12[0x2c]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
8000671a:	f8 c4 ff d0 	sub	r4,r12,-48
8000671e:	30 19       	mov	r9,1
80006720:	0c 9a       	mov	r10,r6
80006722:	08 9b       	mov	r11,r4
80006724:	19 9c       	ld.ub	r12,r12[0x1]
80006726:	f0 1f 00 11 	mcall	80006768 <sync_window+0x60>
8000672a:	c0 30       	breq	80006730 <sync_window+0x28>
8000672c:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
80006730:	30 08       	mov	r8,0
80006732:	ae c8       	st.b	r7[0x4],r8
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
80006734:	6e 89       	ld.w	r9,r7[0x20]
80006736:	ec 09 01 09 	sub	r9,r6,r9
8000673a:	6e 68       	ld.w	r8,r7[0x18]
8000673c:	10 39       	cp.w	r9,r8
8000673e:	c1 22       	brcc	80006762 <sync_window+0x5a>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
80006740:	0f b5       	ld.ub	r5,r7[0x3]
80006742:	58 15       	cp.w	r5,1
80006744:	e0 88 00 0f 	brls	80006762 <sync_window+0x5a>
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
80006748:	30 13       	mov	r3,1
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
8000674a:	6e 68       	ld.w	r8,r7[0x18]
8000674c:	10 06       	add	r6,r8
					disk_write(fs->drv, fs->win, wsect, 1);
8000674e:	06 99       	mov	r9,r3
80006750:	0c 9a       	mov	r10,r6
80006752:	08 9b       	mov	r11,r4
80006754:	0f 9c       	ld.ub	r12,r7[0x1]
80006756:	f0 1f 00 05 	mcall	80006768 <sync_window+0x60>
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
			res = FR_DISK_ERR;
		} else {
			fs->wflag = 0;
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
8000675a:	20 15       	sub	r5,1
8000675c:	58 15       	cp.w	r5,1
8000675e:	fe 9b ff f6 	brhi	8000674a <sync_window+0x42>
80006762:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80006766:	00 00       	add	r0,r0
80006768:	80 00       	ld.sh	r0,r0[0x0]
8000676a:	65 40       	ld.w	r0,r2[0x50]

8000676c <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
8000676c:	eb cd 40 e0 	pushm	r5-r7,lr
80006770:	18 96       	mov	r6,r12
	FRESULT res;


	res = sync_window(fs);
80006772:	f0 1f 00 31 	mcall	80006834 <sync_fs+0xc8>
80006776:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80006778:	c5 a1       	brne	8000682c <sync_fs+0xc0>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
8000677a:	0d 89       	ld.ub	r9,r6[0x0]
8000677c:	30 38       	mov	r8,3
8000677e:	f0 09 18 00 	cp.b	r9,r8
80006782:	c4 e1       	brne	8000681e <sync_fs+0xb2>
80006784:	0d d9       	ld.ub	r9,r6[0x5]
80006786:	30 18       	mov	r8,1
80006788:	f0 09 18 00 	cp.b	r9,r8
8000678c:	c4 91       	brne	8000681e <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
8000678e:	ec c5 ff d0 	sub	r5,r6,-48
80006792:	e0 6a 02 00 	mov	r10,512
80006796:	30 0b       	mov	r11,0
80006798:	0a 9c       	mov	r12,r5
8000679a:	f0 1f 00 28 	mcall	80006838 <sync_fs+0xcc>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
8000679e:	35 58       	mov	r8,85
800067a0:	ed 68 02 2e 	st.b	r6[558],r8
800067a4:	3a a8       	mov	r8,-86
800067a6:	ed 68 02 2f 	st.b	r6[559],r8
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
800067aa:	35 28       	mov	r8,82
800067ac:	ed 68 00 30 	st.b	r6[48],r8
800067b0:	ed 68 00 31 	st.b	r6[49],r8
800067b4:	36 18       	mov	r8,97
800067b6:	ed 68 00 32 	st.b	r6[50],r8
800067ba:	34 19       	mov	r9,65
800067bc:	ed 69 00 33 	st.b	r6[51],r9
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
800067c0:	37 2a       	mov	r10,114
800067c2:	ed 6a 02 14 	st.b	r6[532],r10
800067c6:	ed 6a 02 15 	st.b	r6[533],r10
800067ca:	ed 69 02 16 	st.b	r6[534],r9
800067ce:	ed 68 02 17 	st.b	r6[535],r8
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
800067d2:	6c 48       	ld.w	r8,r6[0x10]
800067d4:	ed 68 02 18 	st.b	r6[536],r8
800067d8:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
800067dc:	ed 69 02 19 	st.b	r6[537],r9
800067e0:	f0 09 16 10 	lsr	r9,r8,0x10
800067e4:	ed 69 02 1a 	st.b	r6[538],r9
800067e8:	b9 88       	lsr	r8,0x18
800067ea:	ed 68 02 1b 	st.b	r6[539],r8
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
800067ee:	6c 38       	ld.w	r8,r6[0xc]
800067f0:	ed 68 02 1c 	st.b	r6[540],r8
800067f4:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
800067f8:	ed 69 02 1d 	st.b	r6[541],r9
800067fc:	f0 09 16 10 	lsr	r9,r8,0x10
80006800:	ed 69 02 1e 	st.b	r6[542],r9
80006804:	b9 88       	lsr	r8,0x18
80006806:	ed 68 02 1f 	st.b	r6[543],r8
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
8000680a:	6c 7a       	ld.w	r10,r6[0x1c]
8000680c:	2f fa       	sub	r10,-1
8000680e:	8d ba       	st.w	r6[0x2c],r10
			disk_write(fs->drv, fs->win, fs->winsect, 1);
80006810:	30 19       	mov	r9,1
80006812:	0a 9b       	mov	r11,r5
80006814:	0d 9c       	ld.ub	r12,r6[0x1]
80006816:	f0 1f 00 0a 	mcall	8000683c <sync_fs+0xd0>
			fs->fsi_flag = 0;
8000681a:	30 08       	mov	r8,0
8000681c:	ac d8       	st.b	r6[0x5],r8
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
8000681e:	30 0a       	mov	r10,0
80006820:	14 9b       	mov	r11,r10
80006822:	0d 9c       	ld.ub	r12,r6[0x1]
80006824:	f0 1f 00 07 	mcall	80006840 <sync_fs+0xd4>
80006828:	f9 b7 01 01 	movne	r7,1
			res = FR_DISK_ERR;
	}

	return res;
}
8000682c:	0e 9c       	mov	r12,r7
8000682e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006832:	00 00       	add	r0,r0
80006834:	80 00       	ld.sh	r0,r0[0x0]
80006836:	67 08       	ld.w	r8,r3[0x40]
80006838:	80 00       	ld.sh	r0,r0[0x0]
8000683a:	65 8e       	ld.w	lr,r2[0x60]
8000683c:	80 00       	ld.sh	r0,r0[0x0]
8000683e:	65 40       	ld.w	r0,r2[0x50]
80006840:	80 00       	ld.sh	r0,r0[0x0]
80006842:	64 f0       	ld.w	r0,r2[0x3c]

80006844 <f_mkfs>:
FRESULT f_mkfs (
	const TCHAR* path,	/* Logical drive number */
	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
	UINT au				/* Size of allocation unit in unit of byte or sector */
)
{
80006844:	d4 31       	pushm	r0-r7,lr
80006846:	20 ad       	sub	sp,40
80006848:	50 7c       	stdsp	sp[0x1c],r12
8000684a:	16 97       	mov	r7,r11
8000684c:	14 96       	mov	r6,r10
	DWORD eb[2];
#endif


	/* Check mounted drive and clear work area */
	if (sfd > 1) return FR_INVALID_PARAMETER;
8000684e:	30 18       	mov	r8,1
80006850:	f0 0b 18 00 	cp.b	r11,r8
80006854:	e0 88 00 05 	brls	8000685e <f_mkfs+0x1a>
80006858:	31 3c       	mov	r12,19
8000685a:	e0 8f 03 16 	bral	80006e86 <f_mkfs+0x642>
	vol = get_ldnumber(&path);
8000685e:	fa cc ff e4 	sub	r12,sp,-28
80006862:	f0 1f 01 8e 	mcall	80006e98 <f_mkfs+0x654>
	if (vol < 0) return FR_INVALID_DRIVE;
80006866:	c0 44       	brge	8000686e <f_mkfs+0x2a>
80006868:	30 bc       	mov	r12,11
8000686a:	e0 8f 03 0e 	bral	80006e86 <f_mkfs+0x642>
	fs = FatFs[vol];
8000686e:	fe f8 06 2e 	ld.w	r8,pc[1582]
80006872:	f0 0c 03 25 	ld.w	r5,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;
80006876:	58 05       	cp.w	r5,0
80006878:	c0 41       	brne	80006880 <f_mkfs+0x3c>
8000687a:	30 cc       	mov	r12,12
8000687c:	e0 8f 03 05 	bral	80006e86 <f_mkfs+0x642>
	fs->fs_type = 0;
80006880:	30 08       	mov	r8,0
80006882:	aa 88       	st.b	r5[0x0],r8
	pdrv = LD2PD(vol);	/* Physical drive */
	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/

	/* Get disk statics */
	stat = disk_initialize(pdrv);
80006884:	e9 dc c0 08 	bfextu	r4,r12,0x0,0x8
80006888:	08 9c       	mov	r12,r4
8000688a:	f0 1f 01 86 	mcall	80006ea0 <f_mkfs+0x65c>
	if (stat & STA_NOINIT) return FR_NOT_READY;
8000688e:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006892:	c0 40       	breq	8000689a <f_mkfs+0x56>
80006894:	30 3c       	mov	r12,3
80006896:	e0 8f 02 f8 	bral	80006e86 <f_mkfs+0x642>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
8000689a:	e2 1c 00 04 	andl	r12,0x4,COH
8000689e:	c0 40       	breq	800068a6 <f_mkfs+0x62>
800068a0:	30 ac       	mov	r12,10
800068a2:	e0 8f 02 f2 	bral	80006e86 <f_mkfs+0x642>
		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
		b_vol = LD_DWORD(tbl + 8);	/* Volume start sector */
		n_vol = LD_DWORD(tbl + 12);	/* Volume size */
	} else {
		/* Create a partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
800068a6:	fa ca ff e0 	sub	r10,sp,-32
800068aa:	30 1b       	mov	r11,1
800068ac:	08 9c       	mov	r12,r4
800068ae:	f0 1f 01 7e 	mcall	80006ea4 <f_mkfs+0x660>
800068b2:	e0 81 02 e7 	brne	80006e80 <f_mkfs+0x63c>
800068b6:	40 89       	lddsp	r9,sp[0x20]
800068b8:	e0 49 00 7f 	cp.w	r9,127
800068bc:	e0 88 02 e2 	brls	80006e80 <f_mkfs+0x63c>
			return FR_DISK_ERR;
		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
800068c0:	58 07       	cp.w	r7,0
800068c2:	f9 b1 01 00 	movne	r1,0
800068c6:	f9 b1 00 3f 	moveq	r1,63
		n_vol -= b_vol;				/* Volume size */
800068ca:	02 19       	sub	r9,r1
800068cc:	50 89       	stdsp	sp[0x20],r9
	}

	if (au & (au - 1)) au = 0;
800068ce:	ec c8 00 01 	sub	r8,r6,1
800068d2:	0c 68       	and	r8,r6
800068d4:	c0 31       	brne	800068da <f_mkfs+0x96>
	if (!au) {						/* AU auto selection */
800068d6:	58 06       	cp.w	r6,0
800068d8:	c1 a1       	brne	8000690c <f_mkfs+0xc8>
		vs = n_vol / (2000 / (SS(fs) / 512));
800068da:	e0 6b 4d d3 	mov	r11,19923
800068de:	ea 1b 10 62 	orh	r11,0x1062
800068e2:	f2 0b 06 4a 	mulu.d	r10,r9,r11
800068e6:	f6 0c 16 07 	lsr	r12,r11,0x7
		for (i = 0; vs < vst[i]; i++) ;
800068ea:	e0 4c 04 00 	cp.w	r12,1024
800068ee:	c0 33       	brcs	800068f4 <f_mkfs+0xb0>
800068f0:	30 08       	mov	r8,0
800068f2:	c0 98       	rjmp	80006904 <f_mkfs+0xc0>
800068f4:	fe fa 05 b4 	ld.w	r10,pc[1460]
800068f8:	2f ea       	sub	r10,-2
800068fa:	30 08       	mov	r8,0
800068fc:	2f f8       	sub	r8,-1
800068fe:	15 2b       	ld.uh	r11,r10++
80006900:	16 3c       	cp.w	r12,r11
80006902:	cf d3       	brcs	800068fc <f_mkfs+0xb8>
		au = cst[i];
80006904:	fe fa 05 a8 	ld.w	r10,pc[1448]
80006908:	f4 08 05 16 	ld.uh	r6,r10[r8<<0x1]
	}
	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
8000690c:	e0 46 01 ff 	cp.w	r6,511
80006910:	e0 88 00 03 	brls	80006916 <f_mkfs+0xd2>
80006914:	a9 96       	lsr	r6,0x9
	if (!au) au = 1;
80006916:	58 06       	cp.w	r6,0
80006918:	f9 b6 00 01 	moveq	r6,1
8000691c:	e0 60 00 80 	mov	r0,128
80006920:	00 36       	cp.w	r6,r0
80006922:	ec 00 17 80 	movls	r0,r6
	if (au > 128) au = 128;

	/* Pre-compute number of clusters and FAT sub-type */
	n_clst = n_vol / au;
80006926:	f2 00 0d 0a 	divu	r10,r9,r0
8000692a:	14 98       	mov	r8,r10
	fmt = FS_FAT12;
	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
8000692c:	e0 4a 0f f6 	cp.w	r10,4086
80006930:	f9 b3 03 01 	movlo	r3,1
80006934:	f9 b3 02 02 	movhs	r3,2
	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
80006938:	e0 4a ff f5 	cp.w	r10,65525
8000693c:	e0 88 00 04 	brls	80006944 <f_mkfs+0x100>
80006940:	30 33       	mov	r3,3
80006942:	c0 58       	rjmp	8000694c <f_mkfs+0x108>

	/* Determine offset and size of FAT structure */
	if (fmt == FS_FAT32) {
80006944:	30 3a       	mov	r10,3
80006946:	f4 03 18 00 	cp.b	r3,r10
8000694a:	c0 a1       	brne	8000695e <f_mkfs+0x11a>
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
8000694c:	a3 68       	lsl	r8,0x2
8000694e:	f0 c2 fd f9 	sub	r2,r8,-519
80006952:	a9 92       	lsr	r2,0x9
80006954:	30 0b       	mov	r11,0
80006956:	50 2b       	stdsp	sp[0x8],r11
80006958:	32 0a       	mov	r10,32
8000695a:	50 0a       	stdsp	sp[0x0],r10
8000695c:	c1 68       	rjmp	80006988 <f_mkfs+0x144>
		n_rsv = 32;
		n_dir = 0;
	} else {
		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
8000695e:	30 1a       	mov	r10,1
80006960:	f4 03 18 00 	cp.b	r3,r10
80006964:	c0 81       	brne	80006974 <f_mkfs+0x130>
80006966:	f0 08 00 18 	add	r8,r8,r8<<0x1
8000696a:	f0 c2 ff ff 	sub	r2,r8,-1
8000696e:	a1 92       	lsr	r2,0x1
80006970:	2f d2       	sub	r2,-3
80006972:	c0 48       	rjmp	8000697a <f_mkfs+0x136>
80006974:	2f e8       	sub	r8,-2
80006976:	f0 02 15 01 	lsl	r2,r8,0x1
		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
8000697a:	e4 c2 fe 01 	sub	r2,r2,-511
8000697e:	a9 92       	lsr	r2,0x9
80006980:	32 08       	mov	r8,32
80006982:	50 28       	stdsp	sp[0x8],r8
80006984:	30 1c       	mov	r12,1
80006986:	50 0c       	stdsp	sp[0x0],r12
		n_rsv = 1;
		n_dir = (DWORD)N_ROOTDIR * SZ_DIRE / SS(fs);
	}
	b_fat = b_vol + n_rsv;				/* FAT area start sector */
80006988:	40 0b       	lddsp	r11,sp[0x0]
8000698a:	02 0b       	add	r11,r1
8000698c:	50 1b       	stdsp	sp[0x4],r11
	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
	b_data = b_dir + n_dir;				/* Data area start sector */
8000698e:	40 26       	lddsp	r6,sp[0x8]
80006990:	04 06       	add	r6,r2
80006992:	16 06       	add	r6,r11
	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
80006994:	e0 01 01 08 	sub	r8,r0,r1
80006998:	0c 08       	add	r8,r6
8000699a:	10 39       	cp.w	r9,r8
8000699c:	e0 83 02 74 	brlo	80006e84 <f_mkfs+0x640>

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
800069a0:	fa ca ff dc 	sub	r10,sp,-36
800069a4:	30 3b       	mov	r11,3
800069a6:	08 9c       	mov	r12,r4
800069a8:	f0 1f 01 3f 	mcall	80006ea4 <f_mkfs+0x660>
800069ac:	c0 81       	brne	800069bc <f_mkfs+0x178>
800069ae:	40 98       	lddsp	r8,sp[0x24]
800069b0:	58 08       	cp.w	r8,0
800069b2:	c0 50       	breq	800069bc <f_mkfs+0x178>
800069b4:	e0 48 80 00 	cp.w	r8,32768
800069b8:	e0 88 00 04 	brls	800069c0 <f_mkfs+0x17c>
800069bc:	30 18       	mov	r8,1
800069be:	50 98       	stdsp	sp[0x24],r8
	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
800069c0:	40 98       	lddsp	r8,sp[0x24]
	n = (n - b_data) / N_FATS;
800069c2:	f0 c9 00 01 	sub	r9,r8,1
800069c6:	0c 09       	add	r9,r6
800069c8:	5c 38       	neg	r8
800069ca:	f3 e8 00 08 	and	r8,r9,r8
800069ce:	f0 06 01 06 	sub	r6,r8,r6
800069d2:	50 96       	stdsp	sp[0x24],r6
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
800069d4:	30 38       	mov	r8,3
800069d6:	f0 03 18 00 	cp.b	r3,r8
800069da:	c1 d1       	brne	80006a14 <f_mkfs+0x1d0>
		n_rsv += n;
800069dc:	40 0a       	lddsp	r10,sp[0x0]
800069de:	0c 0a       	add	r10,r6
800069e0:	50 0a       	stdsp	sp[0x0],r10
		b_fat += n;
800069e2:	40 19       	lddsp	r9,sp[0x4]
800069e4:	0c 09       	add	r9,r6
800069e6:	50 19       	stdsp	sp[0x4],r9
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
800069e8:	40 88       	lddsp	r8,sp[0x20]
800069ea:	f0 0a 01 0b 	sub	r11,r8,r10
800069ee:	04 1b       	sub	r11,r2
800069f0:	40 2c       	lddsp	r12,sp[0x8]
800069f2:	18 1b       	sub	r11,r12
800069f4:	f6 00 0d 0a 	divu	r10,r11,r0
800069f8:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
800069fa:	30 39       	mov	r9,3
800069fc:	f2 03 18 00 	cp.b	r3,r9
80006a00:	5f 0b       	sreq	r11
80006a02:	50 3b       	stdsp	sp[0xc],r11
		n_fat += n;
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006a04:	e0 4a ff f5 	cp.w	r10,65525
80006a08:	5f 89       	srls	r9
80006a0a:	f7 e9 00 09 	and	r9,r11,r9
80006a0e:	e0 81 02 3b 	brne	80006e84 <f_mkfs+0x640>
80006a12:	c1 a8       	rjmp	80006a46 <f_mkfs+0x202>
	n = (n - b_data) / N_FATS;
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
		n_rsv += n;
		b_fat += n;
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
80006a14:	0c 02       	add	r2,r6
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
80006a16:	40 88       	lddsp	r8,sp[0x20]
80006a18:	40 0a       	lddsp	r10,sp[0x0]
80006a1a:	f0 0a 01 0b 	sub	r11,r8,r10
80006a1e:	04 1b       	sub	r11,r2
80006a20:	40 29       	lddsp	r9,sp[0x8]
80006a22:	12 1b       	sub	r11,r9
80006a24:	f6 00 0d 0a 	divu	r10,r11,r0
80006a28:	50 4a       	stdsp	sp[0x10],r10
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
80006a2a:	30 29       	mov	r9,2
80006a2c:	f2 03 18 00 	cp.b	r3,r9
80006a30:	5f 0a       	sreq	r10
80006a32:	40 4c       	lddsp	r12,sp[0x10]
80006a34:	e0 4c 0f f5 	cp.w	r12,4085
80006a38:	5f 89       	srls	r9
80006a3a:	f5 e9 00 09 	and	r9,r10,r9
80006a3e:	e0 80 02 26 	breq	80006e8a <f_mkfs+0x646>
80006a42:	e0 8f 02 21 	bral	80006e84 <f_mkfs+0x640>
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
		return FR_MKFS_ABORTED;

	/* Determine system ID in the partition table */
	if (fmt == FS_FAT32) {
80006a46:	40 3b       	lddsp	r11,sp[0xc]
80006a48:	58 0b       	cp.w	r11,0
80006a4a:	c0 30       	breq	80006a50 <f_mkfs+0x20c>
80006a4c:	30 c6       	mov	r6,12
80006a4e:	c1 28       	rjmp	80006a72 <f_mkfs+0x22e>
		sys = 0x0C;		/* FAT32X */
	} else {
		if (fmt == FS_FAT12 && n_vol < 0x10000) {
80006a50:	30 19       	mov	r9,1
80006a52:	f2 03 18 00 	cp.b	r3,r9
80006a56:	c0 71       	brne	80006a64 <f_mkfs+0x220>
80006a58:	e0 48 ff ff 	cp.w	r8,65535
80006a5c:	e0 8b 00 0a 	brhi	80006a70 <f_mkfs+0x22c>
80006a60:	30 16       	mov	r6,1
80006a62:	c0 88       	rjmp	80006a72 <f_mkfs+0x22e>
			sys = 0x01;	/* FAT12(<65536) */
		} else {
			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
80006a64:	e0 48 ff ff 	cp.w	r8,65535
80006a68:	e0 8b 00 04 	brhi	80006a70 <f_mkfs+0x22c>
80006a6c:	30 46       	mov	r6,4
80006a6e:	c0 28       	rjmp	80006a72 <f_mkfs+0x22e>
80006a70:	30 66       	mov	r6,6
		tbl[4] = sys;
		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
			return FR_DISK_ERR;
		md = 0xF8;
	} else {
		if (sfd) {	/* No partition table (SFD) */
80006a72:	58 07       	cp.w	r7,0
80006a74:	c0 40       	breq	80006a7c <f_mkfs+0x238>
80006a76:	e0 67 00 f0 	mov	r7,240
80006a7a:	c5 68       	rjmp	80006b26 <f_mkfs+0x2e2>
			md = 0xF0;
		} else {	/* Create partition table (FDISK) */
			mem_set(fs->win, 0, SS(fs));
80006a7c:	ea ca ff d0 	sub	r10,r5,-48
80006a80:	50 5a       	stdsp	sp[0x14],r10
80006a82:	e0 6a 02 00 	mov	r10,512
80006a86:	30 0b       	mov	r11,0
80006a88:	40 5c       	lddsp	r12,sp[0x14]
80006a8a:	f0 1f 01 0a 	mcall	80006eb0 <f_mkfs+0x66c>
			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
80006a8e:	ea c8 fe 12 	sub	r8,r5,-494
			tbl[1] = 1;						/* Partition start head */
80006a92:	30 19       	mov	r9,1
80006a94:	b0 99       	st.b	r8[0x1],r9
			tbl[2] = 1;						/* Partition start sector */
80006a96:	b0 a9       	st.b	r8[0x2],r9
			tbl[3] = 0;						/* Partition start cylinder */
80006a98:	30 09       	mov	r9,0
80006a9a:	b0 b9       	st.b	r8[0x3],r9
			tbl[4] = sys;					/* System type */
80006a9c:	b0 c6       	st.b	r8[0x4],r6
			tbl[5] = 254;					/* Partition end head */
80006a9e:	3f ea       	mov	r10,-2
80006aa0:	b0 da       	st.b	r8[0x5],r10
			n = (b_vol + n_vol) / 63 / 255;
80006aa2:	40 8b       	lddsp	r11,sp[0x20]
80006aa4:	e2 0b 00 0b 	add	r11,r1,r11
80006aa8:	e0 6a 56 5b 	mov	r10,22107
80006aac:	ea 1a 05 15 	orh	r10,0x515
80006ab0:	f6 0a 06 46 	mulu.d	r6,r11,r10
80006ab4:	0e 9c       	mov	r12,r7
80006ab6:	f6 0c 01 0a 	sub	r10,r11,r12
80006aba:	a1 9a       	lsr	r10,0x1
80006abc:	f4 0c 00 07 	add	r7,r10,r12
80006ac0:	ee 0a 16 0d 	lsr	r10,r7,0xd
80006ac4:	50 9a       	stdsp	sp[0x24],r10
			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
80006ac6:	ee 0b 16 0f 	lsr	r11,r7,0xf
80006aca:	16 97       	mov	r7,r11
80006acc:	e8 17 00 3f 	orl	r7,0x3f
80006ad0:	b0 e7       	st.b	r8[0x6],r7
			tbl[7] = (BYTE)n;				/* End cylinder */
80006ad2:	40 9a       	lddsp	r10,sp[0x24]
80006ad4:	b0 fa       	st.b	r8[0x7],r10
			ST_DWORD(tbl + 8, 63);			/* Partition start in LBA */
80006ad6:	33 fa       	mov	r10,63
80006ad8:	f1 6a 00 08 	st.b	r8[8],r10
80006adc:	f1 69 00 09 	st.b	r8[9],r9
80006ae0:	f1 69 00 0a 	st.b	r8[10],r9
80006ae4:	f1 69 00 0b 	st.b	r8[11],r9
			ST_DWORD(tbl + 12, n_vol);		/* Partition size in LBA */
80006ae8:	40 89       	lddsp	r9,sp[0x20]
80006aea:	f1 69 00 0c 	st.b	r8[12],r9
80006aee:	fb 39 00 22 	ld.ub	r9,sp[34]
80006af2:	f1 69 00 0d 	st.b	r8[13],r9
80006af6:	fb 19 00 20 	ld.uh	r9,sp[32]
80006afa:	f1 69 00 0e 	st.b	r8[14],r9
80006afe:	fb 39 00 20 	ld.ub	r9,sp[32]
80006b02:	f1 69 00 0f 	st.b	r8[15],r9
			ST_WORD(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
80006b06:	35 58       	mov	r8,85
80006b08:	eb 68 02 2e 	st.b	r5[558],r8
80006b0c:	3a a8       	mov	r8,-86
80006b0e:	eb 68 02 2f 	st.b	r5[559],r8
			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
80006b12:	30 19       	mov	r9,1
80006b14:	30 0a       	mov	r10,0
80006b16:	40 5b       	lddsp	r11,sp[0x14]
80006b18:	08 9c       	mov	r12,r4
80006b1a:	f0 1f 00 e7 	mcall	80006eb4 <f_mkfs+0x670>
80006b1e:	e0 81 01 b1 	brne	80006e80 <f_mkfs+0x63c>
80006b22:	e0 67 00 f8 	mov	r7,248
			md = 0xF8;
		}
	}

	/* Create BPB in the VBR */
	tbl = fs->win;							/* Clear sector */
80006b26:	ea c6 ff d0 	sub	r6,r5,-48
	mem_set(tbl, 0, SS(fs));
80006b2a:	e0 6a 02 00 	mov	r10,512
80006b2e:	30 0b       	mov	r11,0
80006b30:	0c 9c       	mov	r12,r6
80006b32:	f0 1f 00 e0 	mcall	80006eb0 <f_mkfs+0x66c>
	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
80006b36:	30 ba       	mov	r10,11
80006b38:	fe fb 03 80 	ld.w	r11,pc[896]
80006b3c:	0c 9c       	mov	r12,r6
80006b3e:	f0 1f 00 e0 	mcall	80006ebc <f_mkfs+0x678>
	i = SS(fs);								/* Sector size */
	ST_WORD(tbl + BPB_BytsPerSec, i);
80006b42:	ea ca ff c5 	sub	r10,r5,-59
80006b46:	50 5a       	stdsp	sp[0x14],r10
80006b48:	30 08       	mov	r8,0
80006b4a:	b4 88       	st.b	r10[0x0],r8
80006b4c:	30 28       	mov	r8,2
80006b4e:	ed 68 00 0c 	st.b	r6[12],r8
	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
80006b52:	ed 60 00 0d 	st.b	r6[13],r0
	ST_WORD(tbl + BPB_RsvdSecCnt, n_rsv);	/* Reserved sectors */
80006b56:	40 09       	lddsp	r9,sp[0x0]
80006b58:	ed 69 00 0e 	st.b	r6[14],r9
80006b5c:	f1 d9 c1 08 	bfextu	r8,r9,0x8,0x8
80006b60:	ed 68 00 0f 	st.b	r6[15],r8
	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
80006b64:	30 18       	mov	r8,1
80006b66:	ed 68 00 10 	st.b	r6[16],r8
	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
80006b6a:	e0 68 02 00 	mov	r8,512
80006b6e:	40 3c       	lddsp	r12,sp[0xc]
80006b70:	58 0c       	cp.w	r12,0
80006b72:	f9 b8 01 00 	movne	r8,0
	ST_WORD(tbl + BPB_RootEntCnt, i);
80006b76:	ed 68 00 11 	st.b	r6[17],r8
80006b7a:	58 08       	cp.w	r8,0
80006b7c:	f9 b8 01 02 	movne	r8,2
80006b80:	f9 b8 00 00 	moveq	r8,0
80006b84:	ed 68 00 12 	st.b	r6[18],r8
	if (n_vol < 0x10000) {					/* Number of total sectors */
80006b88:	40 88       	lddsp	r8,sp[0x20]
80006b8a:	e0 48 ff ff 	cp.w	r8,65535
80006b8e:	e0 8b 00 09 	brhi	80006ba0 <f_mkfs+0x35c>
		ST_WORD(tbl + BPB_TotSec16, n_vol);
80006b92:	ed 68 00 13 	st.b	r6[19],r8
80006b96:	fb 38 00 22 	ld.ub	r8,sp[34]
80006b9a:	ed 68 00 14 	st.b	r6[20],r8
80006b9e:	c0 f8       	rjmp	80006bbc <f_mkfs+0x378>
	} else {
		ST_DWORD(tbl + BPB_TotSec32, n_vol);
80006ba0:	ed 68 00 20 	st.b	r6[32],r8
80006ba4:	fb 38 00 22 	ld.ub	r8,sp[34]
80006ba8:	ed 68 00 21 	st.b	r6[33],r8
80006bac:	fb 18 00 20 	ld.uh	r8,sp[32]
80006bb0:	ed 68 00 22 	st.b	r6[34],r8
80006bb4:	fb 38 00 20 	ld.ub	r8,sp[32]
80006bb8:	ed 68 00 23 	st.b	r6[35],r8
	}
	tbl[BPB_Media] = md;					/* Media descriptor */
80006bbc:	ed 67 00 15 	st.b	r6[21],r7
	ST_WORD(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
80006bc0:	33 f8       	mov	r8,63
80006bc2:	ed 68 00 18 	st.b	r6[24],r8
80006bc6:	30 08       	mov	r8,0
80006bc8:	ed 68 00 19 	st.b	r6[25],r8
	ST_WORD(tbl + BPB_NumHeads, 255);		/* Number of heads */
80006bcc:	3f f9       	mov	r9,-1
80006bce:	ed 69 00 1a 	st.b	r6[26],r9
80006bd2:	ed 68 00 1b 	st.b	r6[27],r8
	ST_DWORD(tbl + BPB_HiddSec, b_vol);		/* Hidden sectors */
80006bd6:	ed 61 00 1c 	st.b	r6[28],r1
80006bda:	30 08       	mov	r8,0
80006bdc:	ed 68 00 1d 	st.b	r6[29],r8
80006be0:	e2 08 16 10 	lsr	r8,r1,0x10
80006be4:	ed 68 00 1e 	st.b	r6[30],r8
80006be8:	e2 08 16 18 	lsr	r8,r1,0x18
80006bec:	ed 68 00 1f 	st.b	r6[31],r8
	n = GET_FATTIME();						/* Use current time as VSN */
80006bf0:	f0 1f 00 b4 	mcall	80006ec0 <f_mkfs+0x67c>
80006bf4:	50 9c       	stdsp	sp[0x24],r12
	if (fmt == FS_FAT32) {
80006bf6:	40 3a       	lddsp	r10,sp[0xc]
80006bf8:	58 0a       	cp.w	r10,0
80006bfa:	c3 f0       	breq	80006c78 <f_mkfs+0x434>
		ST_DWORD(tbl + BS_VolID32, n);		/* VSN */
80006bfc:	ed 6c 00 43 	st.b	r6[67],r12
80006c00:	fb 38 00 26 	ld.ub	r8,sp[38]
80006c04:	ed 68 00 44 	st.b	r6[68],r8
80006c08:	fb 18 00 24 	ld.uh	r8,sp[36]
80006c0c:	ed 68 00 45 	st.b	r6[69],r8
80006c10:	fb 38 00 24 	ld.ub	r8,sp[36]
80006c14:	ed 68 00 46 	st.b	r6[70],r8
		ST_DWORD(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
80006c18:	ed 62 00 24 	st.b	r6[36],r2
80006c1c:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80006c20:	ed 68 00 25 	st.b	r6[37],r8
80006c24:	e4 08 16 10 	lsr	r8,r2,0x10
80006c28:	ed 68 00 26 	st.b	r6[38],r8
80006c2c:	e4 08 16 18 	lsr	r8,r2,0x18
80006c30:	ed 68 00 27 	st.b	r6[39],r8
		ST_DWORD(tbl + BPB_RootClus, 2);	/* Root directory start cluster (2) */
80006c34:	30 28       	mov	r8,2
80006c36:	ed 68 00 2c 	st.b	r6[44],r8
80006c3a:	30 08       	mov	r8,0
80006c3c:	ed 68 00 2d 	st.b	r6[45],r8
80006c40:	ed 68 00 2e 	st.b	r6[46],r8
80006c44:	ed 68 00 2f 	st.b	r6[47],r8
		ST_WORD(tbl + BPB_FSInfo, 1);		/* FSINFO record offset (VBR + 1) */
80006c48:	30 19       	mov	r9,1
80006c4a:	ed 69 00 30 	st.b	r6[48],r9
80006c4e:	ed 68 00 31 	st.b	r6[49],r8
		ST_WORD(tbl + BPB_BkBootSec, 6);	/* Backup boot record offset (VBR + 6) */
80006c52:	30 69       	mov	r9,6
80006c54:	ed 69 00 32 	st.b	r6[50],r9
80006c58:	ed 68 00 33 	st.b	r6[51],r8
		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
80006c5c:	38 08       	mov	r8,-128
80006c5e:	ed 68 00 40 	st.b	r6[64],r8
		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
80006c62:	32 98       	mov	r8,41
80006c64:	ed 68 00 42 	st.b	r6[66],r8
		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
80006c68:	31 3a       	mov	r10,19
80006c6a:	fe fb 02 5a 	ld.w	r11,pc[602]
80006c6e:	ec cc ff b9 	sub	r12,r6,-71
80006c72:	f0 1f 00 93 	mcall	80006ebc <f_mkfs+0x678>
80006c76:	c2 28       	rjmp	80006cba <f_mkfs+0x476>
	} else {
		ST_DWORD(tbl + BS_VolID, n);		/* VSN */
80006c78:	ed 6c 00 27 	st.b	r6[39],r12
80006c7c:	fb 38 00 26 	ld.ub	r8,sp[38]
80006c80:	ed 68 00 28 	st.b	r6[40],r8
80006c84:	fb 18 00 24 	ld.uh	r8,sp[36]
80006c88:	ed 68 00 29 	st.b	r6[41],r8
80006c8c:	fb 38 00 24 	ld.ub	r8,sp[36]
80006c90:	ed 68 00 2a 	st.b	r6[42],r8
		ST_WORD(tbl + BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
80006c94:	ed 62 00 16 	st.b	r6[22],r2
80006c98:	f1 d2 c1 08 	bfextu	r8,r2,0x8,0x8
80006c9c:	ed 68 00 17 	st.b	r6[23],r8
		tbl[BS_DrvNum] = 0x80;				/* Drive number */
80006ca0:	38 08       	mov	r8,-128
80006ca2:	ed 68 00 24 	st.b	r6[36],r8
		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
80006ca6:	32 98       	mov	r8,41
80006ca8:	ed 68 00 26 	st.b	r6[38],r8
		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
80006cac:	31 3a       	mov	r10,19
80006cae:	fe fb 02 1a 	ld.w	r11,pc[538]
80006cb2:	ec cc ff d5 	sub	r12,r6,-43
80006cb6:	f0 1f 00 82 	mcall	80006ebc <f_mkfs+0x678>
	}
	ST_WORD(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
80006cba:	ec c9 fe 02 	sub	r9,r6,-510
80006cbe:	50 69       	stdsp	sp[0x18],r9
80006cc0:	35 58       	mov	r8,85
80006cc2:	b2 88       	st.b	r9[0x0],r8
80006cc4:	ec c8 fe 01 	sub	r8,r6,-511
80006cc8:	50 08       	stdsp	sp[0x0],r8
80006cca:	3a a8       	mov	r8,-86
80006ccc:	40 0c       	lddsp	r12,sp[0x0]
80006cce:	b8 88       	st.b	r12[0x0],r8
	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
80006cd0:	30 19       	mov	r9,1
80006cd2:	02 9a       	mov	r10,r1
80006cd4:	0c 9b       	mov	r11,r6
80006cd6:	08 9c       	mov	r12,r4
80006cd8:	f0 1f 00 77 	mcall	80006eb4 <f_mkfs+0x670>
80006cdc:	e0 81 00 d2 	brne	80006e80 <f_mkfs+0x63c>
		return FR_DISK_ERR;
	if (fmt == FS_FAT32)					/* Write it to the backup VBR if needed (VBR + 6) */
80006ce0:	40 3b       	lddsp	r11,sp[0xc]
80006ce2:	58 0b       	cp.w	r11,0
80006ce4:	c0 80       	breq	80006cf4 <f_mkfs+0x4b0>
		disk_write(pdrv, tbl, b_vol + 6, 1);
80006ce6:	30 19       	mov	r9,1
80006ce8:	e2 ca ff fa 	sub	r10,r1,-6
80006cec:	0c 9b       	mov	r11,r6
80006cee:	08 9c       	mov	r12,r4
80006cf0:	f0 1f 00 71 	mcall	80006eb4 <f_mkfs+0x670>

	/* Initialize FAT area */
	wsect = b_fat;
	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
80006cf4:	e0 6a 02 00 	mov	r10,512
80006cf8:	30 0b       	mov	r11,0
80006cfa:	0c 9c       	mov	r12,r6
80006cfc:	f0 1f 00 6d 	mcall	80006eb0 <f_mkfs+0x66c>
		n = md;								/* Media descriptor byte */
		if (fmt != FS_FAT32) {
80006d00:	30 38       	mov	r8,3
80006d02:	f0 03 18 00 	cp.b	r3,r8
80006d06:	c1 d0       	breq	80006d40 <f_mkfs+0x4fc>
			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
80006d08:	30 18       	mov	r8,1
80006d0a:	fe 7a ff 00 	mov	r10,-256
80006d0e:	e0 69 ff 00 	mov	r9,65280
80006d12:	ea 19 00 ff 	orh	r9,0xff
80006d16:	e6 08 18 00 	cp.b	r8,r3
80006d1a:	f2 08 17 00 	moveq	r8,r9
80006d1e:	f4 08 17 10 	movne	r8,r10
80006d22:	f1 e7 10 07 	or	r7,r8,r7
80006d26:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
80006d28:	eb 67 00 30 	st.b	r5[48],r7
80006d2c:	fb 38 00 26 	ld.ub	r8,sp[38]
80006d30:	ac 98       	st.b	r6[0x1],r8
80006d32:	fb 18 00 24 	ld.uh	r8,sp[36]
80006d36:	ac a8       	st.b	r6[0x2],r8
80006d38:	fb 38 00 24 	ld.ub	r8,sp[36]
80006d3c:	ac b8       	st.b	r6[0x3],r8
80006d3e:	c1 f8       	rjmp	80006d7c <f_mkfs+0x538>
		} else {
			n |= 0xFFFFFF00;
80006d40:	ea 17 ff ff 	orh	r7,0xffff
80006d44:	e8 17 ff 00 	orl	r7,0xff00
80006d48:	50 97       	stdsp	sp[0x24],r7
			ST_DWORD(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
80006d4a:	eb 67 00 30 	st.b	r5[48],r7
80006d4e:	fb 38 00 26 	ld.ub	r8,sp[38]
80006d52:	ac 98       	st.b	r6[0x1],r8
80006d54:	fb 18 00 24 	ld.uh	r8,sp[36]
80006d58:	ac a8       	st.b	r6[0x2],r8
80006d5a:	fb 38 00 24 	ld.ub	r8,sp[36]
80006d5e:	ac b8       	st.b	r6[0x3],r8
			ST_DWORD(tbl + 4, 0xFFFFFFFF);
80006d60:	3f f8       	mov	r8,-1
80006d62:	ac c8       	st.b	r6[0x4],r8
80006d64:	ac d8       	st.b	r6[0x5],r8
80006d66:	ac e8       	st.b	r6[0x6],r8
80006d68:	ac f8       	st.b	r6[0x7],r8
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
80006d6a:	ed 68 00 08 	st.b	r6[8],r8
80006d6e:	ed 68 00 09 	st.b	r6[9],r8
80006d72:	ed 68 00 0a 	st.b	r6[10],r8
80006d76:	30 f8       	mov	r8,15
80006d78:	40 5a       	lddsp	r10,sp[0x14]
80006d7a:	b4 88       	st.b	r10[0x0],r8
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006d7c:	30 19       	mov	r9,1
80006d7e:	40 1a       	lddsp	r10,sp[0x4]
80006d80:	0c 9b       	mov	r11,r6
80006d82:	08 9c       	mov	r12,r4
80006d84:	f0 1f 00 4c 	mcall	80006eb4 <f_mkfs+0x670>
80006d88:	c7 c1       	brne	80006e80 <f_mkfs+0x63c>
80006d8a:	40 13       	lddsp	r3,sp[0x4]
80006d8c:	2f f3       	sub	r3,-1
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
80006d8e:	e0 6a 02 00 	mov	r10,512
80006d92:	30 0b       	mov	r11,0
80006d94:	0c 9c       	mov	r12,r6
80006d96:	f0 1f 00 47 	mcall	80006eb0 <f_mkfs+0x66c>
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006d9a:	30 18       	mov	r8,1
80006d9c:	50 98       	stdsp	sp[0x24],r8
80006d9e:	10 32       	cp.w	r2,r8
80006da0:	e0 88 00 11 	brls	80006dc2 <f_mkfs+0x57e>
			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006da4:	10 97       	mov	r7,r8
80006da6:	0e 99       	mov	r9,r7
80006da8:	06 9a       	mov	r10,r3
80006daa:	0c 9b       	mov	r11,r6
80006dac:	08 9c       	mov	r12,r4
80006dae:	f0 1f 00 42 	mcall	80006eb4 <f_mkfs+0x670>
80006db2:	c6 71       	brne	80006e80 <f_mkfs+0x63c>
80006db4:	2f f3       	sub	r3,-1
			ST_DWORD(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
80006db6:	40 98       	lddsp	r8,sp[0x24]
80006db8:	2f f8       	sub	r8,-1
80006dba:	50 98       	stdsp	sp[0x24],r8
80006dbc:	10 32       	cp.w	r2,r8
80006dbe:	fe 9b ff f4 	brhi	80006da6 <f_mkfs+0x562>
				return FR_DISK_ERR;
		}
	}

	/* Initialize root directory */
	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
80006dc2:	40 29       	lddsp	r9,sp[0x8]
80006dc4:	40 38       	lddsp	r8,sp[0xc]
80006dc6:	58 08       	cp.w	r8,0
80006dc8:	f2 00 17 00 	moveq	r0,r9
	do {
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
80006dcc:	30 12       	mov	r2,1
80006dce:	06 9a       	mov	r10,r3
80006dd0:	f4 c7 ff ff 	sub	r7,r10,-1
80006dd4:	04 99       	mov	r9,r2
80006dd6:	0c 9b       	mov	r11,r6
80006dd8:	08 9c       	mov	r12,r4
80006dda:	f0 1f 00 37 	mcall	80006eb4 <f_mkfs+0x670>
80006dde:	c5 11       	brne	80006e80 <f_mkfs+0x63c>
			return FR_DISK_ERR;
	} while (--i);
80006de0:	20 10       	sub	r0,1
80006de2:	c0 30       	breq	80006de8 <f_mkfs+0x5a4>
80006de4:	0e 9a       	mov	r10,r7
80006de6:	cf 5b       	rjmp	80006dd0 <f_mkfs+0x58c>
		disk_ioctl(pdrv, CTRL_TRIM, eb);
	}
#endif

	/* Create FSINFO if needed */
	if (fmt == FS_FAT32) {
80006de8:	40 3c       	lddsp	r12,sp[0xc]
80006dea:	58 0c       	cp.w	r12,0
80006dec:	c4 30       	breq	80006e72 <f_mkfs+0x62e>
		ST_DWORD(tbl + FSI_LeadSig, 0x41615252);
80006dee:	35 28       	mov	r8,82
80006df0:	eb 68 00 30 	st.b	r5[48],r8
80006df4:	ac 98       	st.b	r6[0x1],r8
80006df6:	36 18       	mov	r8,97
80006df8:	ac a8       	st.b	r6[0x2],r8
80006dfa:	34 19       	mov	r9,65
80006dfc:	ac b9       	st.b	r6[0x3],r9
		ST_DWORD(tbl + FSI_StrucSig, 0x61417272);
80006dfe:	37 2a       	mov	r10,114
80006e00:	ed 6a 01 e4 	st.b	r6[484],r10
80006e04:	ed 6a 01 e5 	st.b	r6[485],r10
80006e08:	ed 69 01 e6 	st.b	r6[486],r9
80006e0c:	ed 68 01 e7 	st.b	r6[487],r8
		ST_DWORD(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
80006e10:	40 48       	lddsp	r8,sp[0x10]
80006e12:	20 18       	sub	r8,1
80006e14:	ed 68 01 e8 	st.b	r6[488],r8
80006e18:	40 48       	lddsp	r8,sp[0x10]
80006e1a:	20 18       	sub	r8,1
80006e1c:	f1 d8 c1 08 	bfextu	r8,r8,0x8,0x8
80006e20:	ed 68 01 e9 	st.b	r6[489],r8
80006e24:	40 48       	lddsp	r8,sp[0x10]
80006e26:	20 18       	sub	r8,1
80006e28:	f0 09 16 10 	lsr	r9,r8,0x10
80006e2c:	ed 69 01 ea 	st.b	r6[490],r9
80006e30:	b9 88       	lsr	r8,0x18
80006e32:	ed 68 01 eb 	st.b	r6[491],r8
		ST_DWORD(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
80006e36:	30 28       	mov	r8,2
80006e38:	ed 68 01 ec 	st.b	r6[492],r8
80006e3c:	30 08       	mov	r8,0
80006e3e:	ed 68 01 ed 	st.b	r6[493],r8
80006e42:	ed 68 01 ee 	st.b	r6[494],r8
80006e46:	ed 68 01 ef 	st.b	r6[495],r8
		ST_WORD(tbl + BS_55AA, 0xAA55);
80006e4a:	35 58       	mov	r8,85
80006e4c:	40 6b       	lddsp	r11,sp[0x18]
80006e4e:	b6 88       	st.b	r11[0x0],r8
80006e50:	3a a8       	mov	r8,-86
80006e52:	40 0a       	lddsp	r10,sp[0x0]
80006e54:	b4 88       	st.b	r10[0x0],r8
		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
80006e56:	30 19       	mov	r9,1
80006e58:	e2 09 00 0a 	add	r10,r1,r9
80006e5c:	0c 9b       	mov	r11,r6
80006e5e:	08 9c       	mov	r12,r4
80006e60:	f0 1f 00 15 	mcall	80006eb4 <f_mkfs+0x670>
		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
80006e64:	30 19       	mov	r9,1
80006e66:	e2 ca ff f9 	sub	r10,r1,-7
80006e6a:	0c 9b       	mov	r11,r6
80006e6c:	08 9c       	mov	r12,r4
80006e6e:	f0 1f 00 12 	mcall	80006eb4 <f_mkfs+0x670>
	}

	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
80006e72:	30 0a       	mov	r10,0
80006e74:	14 9b       	mov	r11,r10
80006e76:	08 9c       	mov	r12,r4
80006e78:	f0 1f 00 0b 	mcall	80006ea4 <f_mkfs+0x660>
80006e7c:	5f 1c       	srne	r12
80006e7e:	c0 48       	rjmp	80006e86 <f_mkfs+0x642>
80006e80:	30 1c       	mov	r12,1
80006e82:	c0 28       	rjmp	80006e86 <f_mkfs+0x642>
80006e84:	30 ec       	mov	r12,14
}
80006e86:	2f 6d       	sub	sp,-40
80006e88:	d8 32       	popm	r0-r7,pc
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
80006e8a:	30 39       	mov	r9,3
80006e8c:	f2 03 18 00 	cp.b	r3,r9
80006e90:	5f 09       	sreq	r9
80006e92:	50 39       	stdsp	sp[0xc],r9
80006e94:	fe 9f fd d9 	bral	80006a46 <f_mkfs+0x202>
80006e98:	80 00       	ld.sh	r0,r0[0x0]
80006e9a:	66 4c       	ld.w	r12,r3[0x10]
80006e9c:	00 00       	add	r0,r0
80006e9e:	11 d8       	ld.ub	r8,r8[0x5]
80006ea0:	80 00       	ld.sh	r0,r0[0x0]
80006ea2:	64 b2       	ld.w	r2,r2[0x2c]
80006ea4:	80 00       	ld.sh	r0,r0[0x0]
80006ea6:	64 f0       	ld.w	r0,r2[0x3c]
80006ea8:	80 01       	ld.sh	r1,r0[0x0]
80006eaa:	95 2a       	st.w	r10[0x8],r10
80006eac:	80 01       	ld.sh	r1,r0[0x0]
80006eae:	95 14       	st.w	r10[0x4],r4
80006eb0:	80 00       	ld.sh	r0,r0[0x0]
80006eb2:	65 8e       	ld.w	lr,r2[0x60]
80006eb4:	80 00       	ld.sh	r0,r0[0x0]
80006eb6:	65 40       	ld.w	r0,r2[0x50]
80006eb8:	80 01       	ld.sh	r1,r0[0x0]
80006eba:	95 44       	st.w	r10[0x10],r4
80006ebc:	80 00       	ld.sh	r0,r0[0x0]
80006ebe:	65 78       	ld.w	r8,r2[0x5c]
80006ec0:	80 00       	ld.sh	r0,r0[0x0]
80006ec2:	64 b4       	ld.w	r4,r2[0x2c]
80006ec4:	80 01       	ld.sh	r1,r0[0x0]
80006ec6:	95 50       	st.w	r10[0x14],r0
80006ec8:	80 01       	ld.sh	r1,r0[0x0]
80006eca:	95 64       	st.w	r10[0x18],r4

80006ecc <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
80006ecc:	d4 01       	pushm	lr
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id || (disk_status(fil->fs->drv) & STA_NOINIT))
80006ece:	58 0c       	cp.w	r12,0
80006ed0:	c1 40       	breq	80006ef8 <validate+0x2c>
80006ed2:	78 08       	ld.w	r8,r12[0x0]
80006ed4:	58 08       	cp.w	r8,0
80006ed6:	c1 10       	breq	80006ef8 <validate+0x2c>
80006ed8:	11 8a       	ld.ub	r10,r8[0x0]
80006eda:	30 09       	mov	r9,0
80006edc:	f2 0a 18 00 	cp.b	r10,r9
80006ee0:	c0 c0       	breq	80006ef8 <validate+0x2c>
80006ee2:	90 3a       	ld.sh	r10,r8[0x6]
80006ee4:	98 29       	ld.sh	r9,r12[0x4]
80006ee6:	f2 0a 19 00 	cp.h	r10,r9
80006eea:	c0 71       	brne	80006ef8 <validate+0x2c>
80006eec:	11 9c       	ld.ub	r12,r8[0x1]
80006eee:	f0 1f 00 04 	mcall	80006efc <validate+0x30>
80006ef2:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80006ef6:	c0 20       	breq	80006efa <validate+0x2e>
80006ef8:	30 9c       	mov	r12,9
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	return FR_OK;
}
80006efa:	d8 02       	popm	pc
80006efc:	80 00       	ld.sh	r0,r0[0x0]
80006efe:	64 b0       	ld.w	r0,r2[0x2c]

80006f00 <move_window>:
static
FRESULT move_window (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
80006f00:	eb cd 40 e0 	pushm	r5-r7,lr
80006f04:	18 97       	mov	r7,r12
80006f06:	16 95       	mov	r5,r11
	FRESULT res = FR_OK;


	if (sector != fs->winsect) {	/* Window offset changed? */
80006f08:	78 b8       	ld.w	r8,r12[0x2c]
80006f0a:	16 38       	cp.w	r8,r11
80006f0c:	c0 31       	brne	80006f12 <move_window+0x12>
80006f0e:	30 06       	mov	r6,0
80006f10:	c1 18       	rjmp	80006f32 <move_window+0x32>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
80006f12:	f0 1f 00 0a 	mcall	80006f38 <move_window+0x38>
80006f16:	18 96       	mov	r6,r12
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
80006f18:	c0 d1       	brne	80006f32 <move_window+0x32>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
80006f1a:	30 19       	mov	r9,1
80006f1c:	0a 9a       	mov	r10,r5
80006f1e:	ee cb ff d0 	sub	r11,r7,-48
80006f22:	0f 9c       	ld.ub	r12,r7[0x1]
80006f24:	f0 1f 00 06 	mcall	80006f3c <move_window+0x3c>
80006f28:	f9 b6 01 01 	movne	r6,1
80006f2c:	f9 b5 01 ff 	movne	r5,-1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
				res = FR_DISK_ERR;
			}
			fs->winsect = sector;
80006f30:	8f b5       	st.w	r7[0x2c],r5
		}
	}
	return res;
}
80006f32:	0c 9c       	mov	r12,r6
80006f34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006f38:	80 00       	ld.sh	r0,r0[0x0]
80006f3a:	67 08       	ld.w	r8,r3[0x40]
80006f3c:	80 00       	ld.sh	r0,r0[0x0]
80006f3e:	65 5c       	ld.w	r12,r2[0x54]

80006f40 <check_fs>:
static
BYTE check_fs (	/* 0:Valid FAT-BS, 1:Valid BS but not FAT, 2:Not a BS, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
80006f40:	eb cd 40 80 	pushm	r7,lr
80006f44:	18 97       	mov	r7,r12
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
80006f46:	30 08       	mov	r8,0
80006f48:	b8 c8       	st.b	r12[0x4],r8
80006f4a:	3f f8       	mov	r8,-1
80006f4c:	99 b8       	st.w	r12[0x2c],r8
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
80006f4e:	f0 1f 00 23 	mcall	80006fd8 <check_fs+0x98>
80006f52:	c0 40       	breq	80006f5a <check_fs+0x1a>
80006f54:	30 3c       	mov	r12,3
80006f56:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
80006f5a:	ef 39 02 2f 	ld.ub	r9,r7[559]
80006f5e:	ef 38 02 2e 	ld.ub	r8,r7[558]
80006f62:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80006f66:	fe 78 aa 55 	mov	r8,-21931
80006f6a:	f0 09 19 00 	cp.h	r9,r8
80006f6e:	c0 40       	breq	80006f76 <check_fs+0x36>
80006f70:	30 2c       	mov	r12,2
80006f72:	e3 cd 80 80 	ldm	sp++,r7,pc
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
80006f76:	ef 39 00 69 	ld.ub	r9,r7[105]
80006f7a:	ef 38 00 68 	ld.ub	r8,r7[104]
80006f7e:	b1 68       	lsl	r8,0x10
80006f80:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006f84:	ef 39 00 66 	ld.ub	r9,r7[102]
80006f88:	12 48       	or	r8,r9
80006f8a:	ef 39 00 67 	ld.ub	r9,r7[103]
80006f8e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006f92:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006f96:	e0 69 41 46 	mov	r9,16710
80006f9a:	ea 19 00 54 	orh	r9,0x54
80006f9e:	12 38       	cp.w	r8,r9
80006fa0:	c0 31       	brne	80006fa6 <check_fs+0x66>
80006fa2:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80006fa6:	ef 39 00 85 	ld.ub	r9,r7[133]
80006faa:	ef 38 00 84 	ld.ub	r8,r7[132]
80006fae:	b1 68       	lsl	r8,0x10
80006fb0:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80006fb4:	ef 39 00 82 	ld.ub	r9,r7[130]
80006fb8:	12 48       	or	r8,r9
80006fba:	ef 39 00 83 	ld.ub	r9,r7[131]
80006fbe:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006fc2:	f1 d8 c0 18 	bfextu	r8,r8,0x0,0x18
80006fc6:	e0 69 41 46 	mov	r9,16710
80006fca:	ea 19 00 54 	orh	r9,0x54
80006fce:	12 38       	cp.w	r8,r9
80006fd0:	5f 1c       	srne	r12
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
80006fd2:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fd6:	00 00       	add	r0,r0
80006fd8:	80 00       	ld.sh	r0,r0[0x0]
80006fda:	6f 00       	ld.w	r0,r7[0x40]

80006fdc <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
80006fdc:	eb cd 40 fb 	pushm	r0-r1,r3-r7,lr
80006fe0:	20 4d       	sub	sp,16
80006fe2:	18 95       	mov	r5,r12
80006fe4:	14 94       	mov	r4,r10
	FATFS *fs;
	UINT i;


	/* Get logical drive number from the path name */
	*rfs = 0;
80006fe6:	30 08       	mov	r8,0
80006fe8:	99 08       	st.w	r12[0x0],r8
	vol = get_ldnumber(path);
80006fea:	16 9c       	mov	r12,r11
80006fec:	f0 1f 00 de 	mcall	80007364 <find_volume+0x388>
80006ff0:	18 96       	mov	r6,r12
	if (vol < 0) return FR_INVALID_DRIVE;
80006ff2:	c0 34       	brge	80006ff8 <find_volume+0x1c>
80006ff4:	30 bc       	mov	r12,11
80006ff6:	ca a9       	rjmp	8000734a <find_volume+0x36e>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
80006ff8:	fe f8 03 70 	ld.w	r8,pc[880]
80006ffc:	f0 0c 03 27 	ld.w	r7,r8[r12<<0x2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
80007000:	58 07       	cp.w	r7,0
80007002:	c0 31       	brne	80007008 <find_volume+0x2c>
80007004:	30 cc       	mov	r12,12
80007006:	ca 29       	rjmp	8000734a <find_volume+0x36e>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
80007008:	8b 07       	st.w	r5[0x0],r7

	if (fs->fs_type) {					/* If the volume has been mounted */
8000700a:	0f 89       	ld.ub	r9,r7[0x0]
8000700c:	30 08       	mov	r8,0
8000700e:	f0 09 18 00 	cp.b	r9,r8
80007012:	c0 f0       	breq	80007030 <find_volume+0x54>
		stat = disk_status(fs->drv);
80007014:	0f 9c       	ld.ub	r12,r7[0x1]
80007016:	f0 1f 00 d6 	mcall	8000736c <find_volume+0x390>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
8000701a:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
8000701e:	c0 91       	brne	80007030 <find_volume+0x54>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
80007020:	58 04       	cp.w	r4,0
80007022:	e0 80 01 91 	breq	80007344 <find_volume+0x368>
80007026:	e2 1c 00 04 	andl	r12,0x4,COH
8000702a:	e0 81 01 8b 	brne	80007340 <find_volume+0x364>
8000702e:	c8 b9       	rjmp	80007344 <find_volume+0x368>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
80007030:	30 08       	mov	r8,0
80007032:	ae 88       	st.b	r7[0x0],r8
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
80007034:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80007038:	ae 9c       	st.b	r7[0x1],r12
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
8000703a:	f0 1f 00 ce 	mcall	80007370 <find_volume+0x394>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
8000703e:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80007042:	c0 30       	breq	80007048 <find_volume+0x6c>
80007044:	30 3c       	mov	r12,3
80007046:	c8 29       	rjmp	8000734a <find_volume+0x36e>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
80007048:	58 04       	cp.w	r4,0
8000704a:	c0 50       	breq	80007054 <find_volume+0x78>
8000704c:	e2 1c 00 04 	andl	r12,0x4,COH
80007050:	e0 81 01 78 	brne	80007340 <find_volume+0x364>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
80007054:	30 0b       	mov	r11,0
80007056:	0e 9c       	mov	r12,r7
80007058:	f0 1f 00 c7 	mcall	80007374 <find_volume+0x398>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
8000705c:	30 18       	mov	r8,1
8000705e:	f0 0c 18 00 	cp.b	r12,r8
80007062:	c0 30       	breq	80007068 <find_volume+0x8c>
80007064:	30 05       	mov	r5,0
80007066:	c3 48       	rjmp	800070ce <find_volume+0xf2>
80007068:	1a 96       	mov	r6,sp
8000706a:	1a 9a       	mov	r10,sp
8000706c:	e0 68 01 be 	mov	r8,446
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
80007070:	30 0c       	mov	r12,0
80007072:	30 04       	mov	r4,0
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
			pt = fs->win + MBR_Table + i * SZ_PTE;
80007074:	f0 c9 ff d0 	sub	r9,r8,-48
80007078:	ee 09 00 09 	add	r9,r7,r9
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
8000707c:	13 cb       	ld.ub	r11,r9[0x4]
8000707e:	f8 0b 18 00 	cp.b	r11,r12
80007082:	c0 31       	brne	80007088 <find_volume+0xac>
80007084:	08 99       	mov	r9,r4
80007086:	c0 f8       	rjmp	800070a4 <find_volume+0xc8>
80007088:	f3 35 00 0b 	ld.ub	r5,r9[11]
8000708c:	f3 3b 00 0a 	ld.ub	r11,r9[10]
80007090:	b1 6b       	lsl	r11,0x10
80007092:	f7 e5 11 8b 	or	r11,r11,r5<<0x18
80007096:	f3 35 00 08 	ld.ub	r5,r9[8]
8000709a:	0a 4b       	or	r11,r5
8000709c:	f3 39 00 09 	ld.ub	r9,r9[9]
800070a0:	f7 e9 10 89 	or	r9,r11,r9<<0x8
800070a4:	14 a9       	st.w	r10++,r9
800070a6:	2f 08       	sub	r8,-16
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		for (i = 0; i < 4; i++) {			/* Get partition offset */
800070a8:	e0 48 01 fe 	cp.w	r8,510
800070ac:	ce 41       	brne	80007074 <find_volume+0x98>
/*-----------------------------------------------------------------------*/
/* Find logical drive and check if the volume is mounted                 */
/*-----------------------------------------------------------------------*/

static
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
800070ae:	fa c4 ff f0 	sub	r4,sp,-16
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
800070b2:	30 23       	mov	r3,2
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
800070b4:	6c 05       	ld.w	r5,r6[0x0]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
800070b6:	58 05       	cp.w	r5,0
800070b8:	c0 31       	brne	800070be <find_volume+0xe2>
800070ba:	06 9c       	mov	r12,r3
800070bc:	c0 68       	rjmp	800070c8 <find_volume+0xec>
800070be:	0a 9b       	mov	r11,r5
800070c0:	0e 9c       	mov	r12,r7
800070c2:	f0 1f 00 ad 	mcall	80007374 <find_volume+0x398>
		} while (!LD2PT(vol) && fmt && ++i < 4);
800070c6:	c0 d0       	breq	800070e0 <find_volume+0x104>
800070c8:	2f c6       	sub	r6,-4
800070ca:	08 36       	cp.w	r6,r4
800070cc:	cf 41       	brne	800070b4 <find_volume+0xd8>
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
800070ce:	30 38       	mov	r8,3
800070d0:	f0 0c 18 00 	cp.b	r12,r8
800070d4:	c0 31       	brne	800070da <find_volume+0xfe>
800070d6:	30 1c       	mov	r12,1
800070d8:	c3 99       	rjmp	8000734a <find_volume+0x36e>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
800070da:	58 0c       	cp.w	r12,0
800070dc:	e0 81 01 36 	brne	80007348 <find_volume+0x36c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
800070e0:	ef 39 00 3c 	ld.ub	r9,r7[60]
800070e4:	ef 38 00 3b 	ld.ub	r8,r7[59]
800070e8:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800070ec:	e0 68 02 00 	mov	r8,512
800070f0:	f0 09 19 00 	cp.h	r9,r8
800070f4:	e0 81 01 2a 	brne	80007348 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
800070f8:	ef 39 00 47 	ld.ub	r9,r7[71]
800070fc:	ef 38 00 46 	ld.ub	r8,r7[70]
80007100:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
80007104:	c1 01       	brne	80007124 <find_volume+0x148>
80007106:	ef 39 00 57 	ld.ub	r9,r7[87]
8000710a:	ef 38 00 56 	ld.ub	r8,r7[86]
8000710e:	b1 68       	lsl	r8,0x10
80007110:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80007114:	ef 38 00 54 	ld.ub	r8,r7[84]
80007118:	f3 e8 10 08 	or	r8,r9,r8
8000711c:	ef 39 00 55 	ld.ub	r9,r7[85]
80007120:	f1 e9 10 88 	or	r8,r8,r9<<0x8
	fs->fsize = fasize;
80007124:	8f 68       	st.w	r7[0x18],r8

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
80007126:	ef 39 00 40 	ld.ub	r9,r7[64]
8000712a:	ae b9       	st.b	r7[0x3],r9
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
8000712c:	f2 cb 00 01 	sub	r11,r9,1
80007130:	30 1a       	mov	r10,1
80007132:	f4 0b 18 00 	cp.b	r11,r10
80007136:	e0 8b 01 09 	brhi	80007348 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
8000713a:	ef 3a 00 3d 	ld.ub	r10,r7[61]
8000713e:	ae aa       	st.b	r7[0x2],r10
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
80007140:	58 0a       	cp.w	r10,0
80007142:	e0 80 01 03 	breq	80007348 <find_volume+0x36c>
80007146:	f4 cb 00 01 	sub	r11,r10,1
8000714a:	14 6b       	and	r11,r10
8000714c:	e0 81 00 fe 	brne	80007348 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
80007150:	ef 3c 00 42 	ld.ub	r12,r7[66]
80007154:	ef 3b 00 41 	ld.ub	r11,r7[65]
80007158:	f7 ec 10 8b 	or	r11,r11,r12<<0x8
8000715c:	5c 8b       	casts.h	r11
8000715e:	ae 4b       	st.h	r7[0x8],r11
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
80007160:	f9 db c0 04 	bfextu	r12,r11,0x0,0x4
80007164:	e0 81 00 f2 	brne	80007348 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
80007168:	ef 36 00 44 	ld.ub	r6,r7[68]
8000716c:	ef 3c 00 43 	ld.ub	r12,r7[67]
80007170:	f9 e6 10 8c 	or	r12,r12,r6<<0x8
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
80007174:	c1 01       	brne	80007194 <find_volume+0x1b8>
80007176:	ef 36 00 53 	ld.ub	r6,r7[83]
8000717a:	ef 3c 00 52 	ld.ub	r12,r7[82]
8000717e:	b1 6c       	lsl	r12,0x10
80007180:	f9 e6 11 86 	or	r6,r12,r6<<0x18
80007184:	ef 3c 00 50 	ld.ub	r12,r7[80]
80007188:	ed ec 10 0c 	or	r12,r6,r12
8000718c:	ef 36 00 51 	ld.ub	r6,r7[81]
80007190:	f9 e6 10 8c 	or	r12,r12,r6<<0x8

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
80007194:	ef 34 00 3f 	ld.ub	r4,r7[63]
80007198:	ef 36 00 3e 	ld.ub	r6,r7[62]
8000719c:	ed e4 10 86 	or	r6,r6,r4<<0x8
800071a0:	5c 86       	casts.h	r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
800071a2:	e0 80 00 d3 	breq	80007348 <find_volume+0x36c>
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
800071a6:	b3 38       	mul	r8,r9

	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
800071a8:	e7 d6 c0 10 	bfextu	r3,r6,0x0,0x10
800071ac:	e9 db c0 8c 	bfextu	r4,r11,0x4,0xc
800071b0:	06 04       	add	r4,r3
800071b2:	10 04       	add	r4,r8
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
800071b4:	08 3c       	cp.w	r12,r4
800071b6:	e0 83 00 c9 	brlo	80007348 <find_volume+0x36c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
800071ba:	f8 04 01 01 	sub	r1,r12,r4
800071be:	e2 0a 0d 00 	divu	r0,r1,r10
800071c2:	00 99       	mov	r9,r0
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
800071c4:	58 00       	cp.w	r0,0
800071c6:	e0 80 00 c1 	breq	80007348 <find_volume+0x36c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
800071ca:	e0 40 0f f6 	cp.w	r0,4086
800071ce:	f9 b6 03 01 	movlo	r6,1
800071d2:	f9 b6 02 02 	movhs	r6,2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
800071d6:	e0 40 ff f5 	cp.w	r0,65525
800071da:	e0 8b 00 bb 	brhi	80007350 <find_volume+0x374>

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
800071de:	2f e9       	sub	r9,-2
800071e0:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
800071e2:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
800071e4:	ea 03 00 03 	add	r3,r5,r3
800071e8:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
800071ea:	0a 04       	add	r4,r5
800071ec:	8f a4       	st.w	r7[0x28],r4
	if (fmt == FS_FAT32) {
800071ee:	30 3a       	mov	r10,3
800071f0:	f4 06 18 00 	cp.b	r6,r10
800071f4:	c1 61       	brne	80007220 <find_volume+0x244>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
800071f6:	58 0b       	cp.w	r11,0
800071f8:	e0 81 00 a8 	brne	80007348 <find_volume+0x36c>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
800071fc:	ef 3a 00 5f 	ld.ub	r10,r7[95]
80007200:	ef 38 00 5e 	ld.ub	r8,r7[94]
80007204:	b1 68       	lsl	r8,0x10
80007206:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000720a:	ef 38 00 5c 	ld.ub	r8,r7[92]
8000720e:	f5 e8 10 08 	or	r8,r10,r8
80007212:	ef 3a 00 5d 	ld.ub	r10,r7[93]
80007216:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000721a:	8f 98       	st.w	r7[0x24],r8
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
8000721c:	a3 69       	lsl	r9,0x2
8000721e:	c1 38       	rjmp	80007244 <find_volume+0x268>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
80007220:	58 0b       	cp.w	r11,0
80007222:	e0 80 00 93 	breq	80007348 <find_volume+0x36c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
80007226:	06 08       	add	r8,r3
80007228:	8f 98       	st.w	r7[0x24],r8
		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
8000722a:	30 28       	mov	r8,2
8000722c:	f0 06 18 00 	cp.b	r6,r8
80007230:	c0 31       	brne	80007236 <find_volume+0x25a>
80007232:	a1 79       	lsl	r9,0x1
80007234:	c0 88       	rjmp	80007244 <find_volume+0x268>
80007236:	f2 09 00 18 	add	r8,r9,r9<<0x1
8000723a:	a1 98       	lsr	r8,0x1
8000723c:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80007240:	f0 09 00 09 	add	r9,r8,r9
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
80007244:	f2 c8 fe 01 	sub	r8,r9,-511
80007248:	a9 98       	lsr	r8,0x9
8000724a:	6e 69       	ld.w	r9,r7[0x18]
8000724c:	10 39       	cp.w	r9,r8
8000724e:	c7 d3       	brcs	80007348 <find_volume+0x36c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
80007250:	3f f8       	mov	r8,-1
80007252:	8f 48       	st.w	r7[0x10],r8
80007254:	8f 38       	st.w	r7[0xc],r8

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
80007256:	38 08       	mov	r8,-128
80007258:	ae d8       	st.b	r7[0x5],r8
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
8000725a:	30 38       	mov	r8,3
8000725c:	f0 06 18 00 	cp.b	r6,r8
80007260:	c6 81       	brne	80007330 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
80007262:	ef 39 00 61 	ld.ub	r9,r7[97]
80007266:	ef 38 00 60 	ld.ub	r8,r7[96]
8000726a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
8000726e:	30 18       	mov	r8,1
80007270:	f0 09 19 00 	cp.h	r9,r8
80007274:	c5 e1       	brne	80007330 <find_volume+0x354>
		&& move_window(fs, bsect + 1) == FR_OK)
80007276:	ea cb ff ff 	sub	r11,r5,-1
8000727a:	0e 9c       	mov	r12,r7
8000727c:	f0 1f 00 3f 	mcall	80007378 <find_volume+0x39c>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
#if (_FS_NOFSINFO & 3) != 3
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo == 1 */
80007280:	c5 81       	brne	80007330 <find_volume+0x354>
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
		&& move_window(fs, bsect + 1) == FR_OK)
	{
		fs->fsi_flag = 0;
80007282:	30 08       	mov	r8,0
80007284:	ae d8       	st.b	r7[0x5],r8
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
80007286:	ef 39 02 2f 	ld.ub	r9,r7[559]
8000728a:	ef 38 02 2e 	ld.ub	r8,r7[558]
8000728e:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80007292:	fe 78 aa 55 	mov	r8,-21931
80007296:	f0 09 19 00 	cp.h	r9,r8
8000729a:	c4 b1       	brne	80007330 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
8000729c:	ef 39 00 33 	ld.ub	r9,r7[51]
800072a0:	ef 38 00 32 	ld.ub	r8,r7[50]
800072a4:	b1 68       	lsl	r8,0x10
800072a6:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800072aa:	ef 38 00 30 	ld.ub	r8,r7[48]
800072ae:	f3 e8 10 08 	or	r8,r9,r8
800072b2:	ef 39 00 31 	ld.ub	r9,r7[49]
800072b6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800072ba:	e0 69 52 52 	mov	r9,21074
800072be:	ea 19 41 61 	orh	r9,0x4161
800072c2:	12 38       	cp.w	r8,r9
800072c4:	c3 61       	brne	80007330 <find_volume+0x354>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
800072c6:	ef 39 02 17 	ld.ub	r9,r7[535]
800072ca:	ef 38 02 16 	ld.ub	r8,r7[534]
800072ce:	b1 68       	lsl	r8,0x10
800072d0:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800072d4:	ef 38 02 14 	ld.ub	r8,r7[532]
800072d8:	f3 e8 10 08 	or	r8,r9,r8
800072dc:	ef 39 02 15 	ld.ub	r9,r7[533]
800072e0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800072e4:	e0 69 72 72 	mov	r9,29298
800072e8:	ea 19 61 41 	orh	r9,0x6141
800072ec:	12 38       	cp.w	r8,r9
800072ee:	c2 11       	brne	80007330 <find_volume+0x354>
		{
#if (_FS_NOFSINFO & 1) == 0
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
800072f0:	ef 39 02 1b 	ld.ub	r9,r7[539]
800072f4:	ef 38 02 1a 	ld.ub	r8,r7[538]
800072f8:	b1 68       	lsl	r8,0x10
800072fa:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800072fe:	ef 38 02 18 	ld.ub	r8,r7[536]
80007302:	f3 e8 10 08 	or	r8,r9,r8
80007306:	ef 39 02 19 	ld.ub	r9,r7[537]
8000730a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000730e:	8f 48       	st.w	r7[0x10],r8
#endif
#if (_FS_NOFSINFO & 2) == 0
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
80007310:	ef 39 02 1f 	ld.ub	r9,r7[543]
80007314:	ef 38 02 1e 	ld.ub	r8,r7[542]
80007318:	b1 68       	lsl	r8,0x10
8000731a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000731e:	ef 38 02 1c 	ld.ub	r8,r7[540]
80007322:	f3 e8 10 08 	or	r8,r9,r8
80007326:	ef 39 02 1d 	ld.ub	r9,r7[541]
8000732a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000732e:	8f 38       	st.w	r7[0xc],r8
#endif
		}
	}
#endif
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
80007330:	ae 86       	st.b	r7[0x0],r6
	fs->id = ++Fsid;	/* File system mount ID */
80007332:	49 39       	lddpc	r9,8000737c <find_volume+0x3a0>
80007334:	92 08       	ld.sh	r8,r9[0x0]
80007336:	2f f8       	sub	r8,-1
80007338:	b2 08       	st.h	r9[0x0],r8
8000733a:	ae 38       	st.h	r7[0x6],r8
8000733c:	30 0c       	mov	r12,0
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
8000733e:	c0 68       	rjmp	8000734a <find_volume+0x36e>
80007340:	30 ac       	mov	r12,10
80007342:	c0 48       	rjmp	8000734a <find_volume+0x36e>
80007344:	30 0c       	mov	r12,0
80007346:	c0 28       	rjmp	8000734a <find_volume+0x36e>
80007348:	30 dc       	mov	r12,13
}
8000734a:	2f cd       	sub	sp,-16
8000734c:	e3 cd 80 fb 	ldm	sp++,r0-r1,r3-r7,pc
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
80007350:	2f e9       	sub	r9,-2
80007352:	8f 59       	st.w	r7[0x14],r9
	fs->volbase = bsect;								/* Volume start sector */
80007354:	8f 75       	st.w	r7[0x1c],r5
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
80007356:	ea 03 00 03 	add	r3,r5,r3
8000735a:	8f 83       	st.w	r7[0x20],r3
	fs->database = bsect + sysect;						/* Data start sector */
8000735c:	0a 04       	add	r4,r5
8000735e:	8f a4       	st.w	r7[0x28],r4
80007360:	30 36       	mov	r6,3
80007362:	c4 ab       	rjmp	800071f6 <find_volume+0x21a>
80007364:	80 00       	ld.sh	r0,r0[0x0]
80007366:	66 4c       	ld.w	r12,r3[0x10]
80007368:	00 00       	add	r0,r0
8000736a:	11 d8       	ld.ub	r8,r8[0x5]
8000736c:	80 00       	ld.sh	r0,r0[0x0]
8000736e:	64 b0       	ld.w	r0,r2[0x2c]
80007370:	80 00       	ld.sh	r0,r0[0x0]
80007372:	64 b2       	ld.w	r2,r2[0x2c]
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	6f 40       	ld.w	r0,r7[0x50]
80007378:	80 00       	ld.sh	r0,r0[0x0]
8000737a:	6f 00       	ld.w	r0,r7[0x40]
8000737c:	00 00       	add	r0,r0
8000737e:	11 d4       	ld.ub	r4,r8[0x5]

80007380 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
80007380:	eb cd 40 40 	pushm	r6,lr
80007384:	20 3d       	sub	sp,12
80007386:	50 1c       	stdsp	sp[0x4],r12
80007388:	50 0b       	stdsp	sp[0x0],r11
8000738a:	14 96       	mov	r6,r10
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
8000738c:	fa cc ff f4 	sub	r12,sp,-12
80007390:	18 db       	st.w	--r12,r11


	vol = get_ldnumber(&rp);
80007392:	f0 1f 00 1a 	mcall	800073f8 <f_mount+0x78>
	if (vol < 0) return FR_INVALID_DRIVE;
80007396:	c0 34       	brge	8000739c <f_mount+0x1c>
80007398:	30 bc       	mov	r12,11
8000739a:	c2 58       	rjmp	800073e4 <f_mount+0x64>
	cfs = FatFs[vol];					/* Pointer to fs object */
8000739c:	49 88       	lddpc	r8,800073fc <f_mount+0x7c>
8000739e:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
800073a2:	58 08       	cp.w	r8,0
800073a4:	f9 b9 01 00 	movne	r9,0
800073a8:	f1 f9 1e 00 	st.bne	r8[0x0],r9
	}

	if (fs) {
800073ac:	40 18       	lddsp	r8,sp[0x4]
800073ae:	58 08       	cp.w	r8,0
800073b0:	c1 d0       	breq	800073ea <f_mount+0x6a>
		fs->fs_type = 0;				/* Clear new fs object */
800073b2:	30 09       	mov	r9,0
800073b4:	b0 89       	st.b	r8[0x0],r9
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
800073b6:	40 18       	lddsp	r8,sp[0x4]
800073b8:	49 1a       	lddpc	r10,800073fc <f_mount+0x7c>
800073ba:	f4 0c 09 28 	st.w	r10[r12<<0x2],r8

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
800073be:	58 08       	cp.w	r8,0
800073c0:	5f 0a       	sreq	r10
800073c2:	30 18       	mov	r8,1
800073c4:	f0 06 18 00 	cp.b	r6,r8
800073c8:	5f 18       	srne	r8
800073ca:	f5 e8 10 08 	or	r8,r10,r8
800073ce:	f2 08 18 00 	cp.b	r8,r9
800073d2:	c0 30       	breq	800073d8 <f_mount+0x58>
800073d4:	30 0c       	mov	r12,0
800073d6:	c0 78       	rjmp	800073e4 <f_mount+0x64>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
800073d8:	30 0a       	mov	r10,0
800073da:	1a 9b       	mov	r11,sp
800073dc:	fa cc ff fc 	sub	r12,sp,-4
800073e0:	f0 1f 00 08 	mcall	80007400 <f_mount+0x80>
	LEAVE_FF(fs, res);
}
800073e4:	2f dd       	sub	sp,-12
800073e6:	e3 cd 80 40 	ldm	sp++,r6,pc
		fs->fs_type = 0;				/* Clear new fs object */
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
800073ea:	30 08       	mov	r8,0
800073ec:	48 49       	lddpc	r9,800073fc <f_mount+0x7c>
800073ee:	f2 0c 09 28 	st.w	r9[r12<<0x2],r8
800073f2:	10 9c       	mov	r12,r8
800073f4:	cf 8b       	rjmp	800073e4 <f_mount+0x64>
800073f6:	00 00       	add	r0,r0
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	66 4c       	ld.w	r12,r3[0x10]
800073fc:	00 00       	add	r0,r0
800073fe:	11 d8       	ld.ub	r8,r8[0x5]
80007400:	80 00       	ld.sh	r0,r0[0x0]
80007402:	6f dc       	ld.w	r12,r7[0x74]

80007404 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
80007404:	eb cd 40 c0 	pushm	r6-r7,lr
80007408:	18 97       	mov	r7,r12
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
8000740a:	f0 1f 00 2b 	mcall	800074b4 <f_sync+0xb0>
	if (res == FR_OK) {
8000740e:	c5 11       	brne	800074b0 <f_sync+0xac>
		if (fp->flag & FA__WRITTEN) {	/* Is there any change to the file? */
80007410:	0f e8       	ld.ub	r8,r7[0x6]
80007412:	10 99       	mov	r9,r8
80007414:	e2 19 00 20 	andl	r9,0x20,COH
80007418:	c4 c0       	breq	800074b0 <f_sync+0xac>
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {	/* Write-back cached data if needed */
8000741a:	e2 18 00 40 	andl	r8,0x40,COH
8000741e:	c0 f0       	breq	8000743c <f_sync+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80007420:	6e 08       	ld.w	r8,r7[0x0]
80007422:	30 19       	mov	r9,1
80007424:	6e 6a       	ld.w	r10,r7[0x18]
80007426:	ee cb ff d8 	sub	r11,r7,-40
8000742a:	11 9c       	ld.ub	r12,r8[0x1]
8000742c:	f0 1f 00 23 	mcall	800074b8 <f_sync+0xb4>
80007430:	c0 30       	breq	80007436 <f_sync+0x32>
80007432:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
80007436:	0f e8       	ld.ub	r8,r7[0x6]
80007438:	a7 c8       	cbr	r8,0x6
8000743a:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
8000743c:	6e 7b       	ld.w	r11,r7[0x1c]
8000743e:	6e 0c       	ld.w	r12,r7[0x0]
80007440:	f0 1f 00 1f 	mcall	800074bc <f_sync+0xb8>
			if (res == FR_OK) {
80007444:	c3 61       	brne	800074b0 <f_sync+0xac>
				dir = fp->dir_ptr;
80007446:	6e 86       	ld.w	r6,r7[0x20]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
80007448:	ec c8 ff f5 	sub	r8,r6,-11
8000744c:	11 89       	ld.ub	r9,r8[0x0]
8000744e:	a5 b9       	sbr	r9,0x5
80007450:	b0 89       	st.b	r8[0x0],r9
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
80007452:	6e 38       	ld.w	r8,r7[0xc]
80007454:	ed 68 00 1c 	st.b	r6[28],r8
80007458:	ef 38 00 0e 	ld.ub	r8,r7[14]
8000745c:	ed 68 00 1d 	st.b	r6[29],r8
80007460:	8e e8       	ld.uh	r8,r7[0xc]
80007462:	ed 68 00 1e 	st.b	r6[30],r8
80007466:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000746a:	ed 68 00 1f 	st.b	r6[31],r8
				st_clust(dir, fp->sclust);					/* Update start cluster */
8000746e:	6e 4b       	ld.w	r11,r7[0x10]
80007470:	0c 9c       	mov	r12,r6
80007472:	f0 1f 00 14 	mcall	800074c0 <f_sync+0xbc>
				tm = GET_FATTIME();							/* Update modified time */
80007476:	f0 1f 00 14 	mcall	800074c4 <f_sync+0xc0>
				ST_DWORD(dir + DIR_WrtTime, tm);
8000747a:	ed 6c 00 16 	st.b	r6[22],r12
8000747e:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
80007482:	ed 68 00 17 	st.b	r6[23],r8
80007486:	f8 08 16 10 	lsr	r8,r12,0x10
8000748a:	ed 68 00 18 	st.b	r6[24],r8
8000748e:	b9 8c       	lsr	r12,0x18
80007490:	ed 6c 00 19 	st.b	r6[25],r12
				ST_WORD(dir + DIR_LstAccDate, 0);
80007494:	30 08       	mov	r8,0
80007496:	ed 68 00 12 	st.b	r6[18],r8
8000749a:	ed 68 00 13 	st.b	r6[19],r8
				fp->flag &= ~FA__WRITTEN;
8000749e:	0f e8       	ld.ub	r8,r7[0x6]
800074a0:	a5 d8       	cbr	r8,0x5
800074a2:	ae e8       	st.b	r7[0x6],r8
				fp->fs->wflag = 1;
800074a4:	6e 08       	ld.w	r8,r7[0x0]
800074a6:	30 19       	mov	r9,1
800074a8:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(fp->fs);
800074aa:	6e 0c       	ld.w	r12,r7[0x0]
800074ac:	f0 1f 00 07 	mcall	800074c8 <f_sync+0xc4>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
800074b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800074b4:	80 00       	ld.sh	r0,r0[0x0]
800074b6:	6e cc       	ld.w	r12,r7[0x30]
800074b8:	80 00       	ld.sh	r0,r0[0x0]
800074ba:	65 40       	ld.w	r0,r2[0x50]
800074bc:	80 00       	ld.sh	r0,r0[0x0]
800074be:	6f 00       	ld.w	r0,r7[0x40]
800074c0:	80 00       	ld.sh	r0,r0[0x0]
800074c2:	66 32       	ld.w	r2,r3[0xc]
800074c4:	80 00       	ld.sh	r0,r0[0x0]
800074c6:	64 b4       	ld.w	r4,r2[0x2c]
800074c8:	80 00       	ld.sh	r0,r0[0x0]
800074ca:	67 6c       	ld.w	r12,r3[0x58]

800074cc <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
800074cc:	eb cd 40 80 	pushm	r7,lr
800074d0:	18 97       	mov	r7,r12
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
800074d2:	f0 1f 00 07 	mcall	800074ec <f_close+0x20>
	if (res == FR_OK)
800074d6:	c0 81       	brne	800074e6 <f_close+0x1a>
#endif
	{
		res = validate(fp);				/* Lock volume */
800074d8:	0e 9c       	mov	r12,r7
800074da:	f0 1f 00 06 	mcall	800074f0 <f_close+0x24>
#endif
#if _FS_LOCK
			res = dec_lock(fp->lockid);	/* Decrement file open counter */
			if (res == FR_OK)
#endif
				fp->fs = 0;				/* Invalidate file object */
800074de:	f9 b8 00 00 	moveq	r8,0
800074e2:	ef f8 0a 00 	st.weq	r7[0x0],r8
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
800074e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800074ea:	00 00       	add	r0,r0
800074ec:	80 00       	ld.sh	r0,r0[0x0]
800074ee:	74 04       	ld.w	r4,r10[0x0]
800074f0:	80 00       	ld.sh	r0,r0[0x0]
800074f2:	6e cc       	ld.w	r12,r7[0x30]

800074f4 <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* File system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
800074f4:	d4 21       	pushm	r4-r7,lr
800074f6:	18 97       	mov	r7,r12
800074f8:	16 96       	mov	r6,r11
800074fa:	14 95       	mov	r5,r10
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
800074fc:	58 1b       	cp.w	r11,1
800074fe:	e0 88 00 90 	brls	8000761e <put_fat+0x12a>
80007502:	78 58       	ld.w	r8,r12[0x14]
80007504:	10 3b       	cp.w	r11,r8
80007506:	e0 82 00 8c 	brhs	8000761e <put_fat+0x12a>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
8000750a:	19 88       	ld.ub	r8,r12[0x0]
8000750c:	30 29       	mov	r9,2
8000750e:	f2 08 18 00 	cp.b	r8,r9
80007512:	c4 d0       	breq	800075ac <put_fat+0xb8>
80007514:	30 39       	mov	r9,3
80007516:	f2 08 18 00 	cp.b	r8,r9
8000751a:	c5 e0       	breq	800075d6 <put_fat+0xe2>
8000751c:	30 19       	mov	r9,1
8000751e:	f2 08 18 00 	cp.b	r8,r9
80007522:	c7 e1       	brne	8000761e <put_fat+0x12a>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
80007524:	f6 04 16 01 	lsr	r4,r11,0x1
80007528:	16 04       	add	r4,r11
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
8000752a:	e8 0b 16 09 	lsr	r11,r4,0x9
8000752e:	78 88       	ld.w	r8,r12[0x20]
80007530:	10 0b       	add	r11,r8
80007532:	f0 1f 00 3d 	mcall	80007624 <put_fat+0x130>
			if (res != FR_OK) break;
80007536:	c7 51       	brne	80007620 <put_fat+0x12c>
			p = &fs->win[bc++ % SS(fs)];
80007538:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
8000753c:	2f f4       	sub	r4,-1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
8000753e:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
80007542:	c0 d0       	breq	8000755c <put_fat+0x68>
80007544:	ee 08 00 09 	add	r9,r7,r8
80007548:	f3 39 00 30 	ld.ub	r9,r9[48]
8000754c:	f5 d5 c0 08 	bfextu	r10,r5,0x0,0x8
80007550:	f3 d9 c0 04 	bfextu	r9,r9,0x0,0x4
80007554:	f3 ea 10 49 	or	r9,r9,r10<<0x4
80007558:	5c 59       	castu.b	r9
8000755a:	c0 38       	rjmp	80007560 <put_fat+0x6c>
8000755c:	f3 d5 c0 08 	bfextu	r9,r5,0x0,0x8
80007560:	ee 08 00 08 	add	r8,r7,r8
80007564:	f1 69 00 30 	st.b	r8[48],r9
			fs->wflag = 1;
80007568:	30 18       	mov	r8,1
8000756a:	ae c8       	st.b	r7[0x4],r8
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
8000756c:	e8 0b 16 09 	lsr	r11,r4,0x9
80007570:	6e 88       	ld.w	r8,r7[0x20]
80007572:	10 0b       	add	r11,r8
80007574:	0e 9c       	mov	r12,r7
80007576:	f0 1f 00 2c 	mcall	80007624 <put_fat+0x130>
			if (res != FR_OK) break;
8000757a:	c5 31       	brne	80007620 <put_fat+0x12c>
			p = &fs->win[bc % SS(fs)];
8000757c:	e9 d4 c0 09 	bfextu	r4,r4,0x0,0x9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
80007580:	58 06       	cp.w	r6,0
80007582:	c0 40       	breq	8000758a <put_fat+0x96>
80007584:	eb d5 c0 88 	bfextu	r5,r5,0x4,0x8
80007588:	c0 b8       	rjmp	8000759e <put_fat+0xaa>
8000758a:	ee 04 00 08 	add	r8,r7,r4
8000758e:	f1 38 00 30 	ld.ub	r8,r8[48]
80007592:	eb d5 c1 04 	bfextu	r5,r5,0x8,0x4
80007596:	e2 18 00 f0 	andl	r8,0xf0,COH
8000759a:	f1 e5 10 05 	or	r5,r8,r5
8000759e:	ee 04 00 04 	add	r4,r7,r4
800075a2:	e9 65 00 30 	st.b	r4[48],r5
			fs->wflag = 1;
800075a6:	30 18       	mov	r8,1
800075a8:	ae c8       	st.b	r7[0x4],r8
			break;
800075aa:	d8 22       	popm	r4-r7,pc

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
800075ac:	a9 8b       	lsr	r11,0x8
800075ae:	78 88       	ld.w	r8,r12[0x20]
800075b0:	10 0b       	add	r11,r8
800075b2:	f0 1f 00 1d 	mcall	80007624 <put_fat+0x130>
			if (res != FR_OK) break;
800075b6:	c3 51       	brne	80007620 <put_fat+0x12c>
			p = &fs->win[clst * 2 % SS(fs)];
800075b8:	a1 76       	lsl	r6,0x1
800075ba:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			ST_WORD(p, (WORD)val);
800075be:	ee 06 00 08 	add	r8,r7,r6
800075c2:	f1 65 00 30 	st.b	r8[48],r5
800075c6:	10 96       	mov	r6,r8
800075c8:	eb d5 c1 08 	bfextu	r5,r5,0x8,0x8
800075cc:	f1 65 00 31 	st.b	r8[49],r5
			fs->wflag = 1;
800075d0:	30 18       	mov	r8,1
800075d2:	ae c8       	st.b	r7[0x4],r8
			break;
800075d4:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
800075d6:	a7 9b       	lsr	r11,0x7
800075d8:	78 88       	ld.w	r8,r12[0x20]
800075da:	10 0b       	add	r11,r8
800075dc:	f0 1f 00 12 	mcall	80007624 <put_fat+0x130>
			if (res != FR_OK) break;
800075e0:	c2 01       	brne	80007620 <put_fat+0x12c>
			p = &fs->win[clst * 4 % SS(fs)];
800075e2:	a3 66       	lsl	r6,0x2
800075e4:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
800075e8:	ec c8 ff d0 	sub	r8,r6,-48
800075ec:	ee 08 00 08 	add	r8,r7,r8
			val |= LD_DWORD(p) & 0xF0000000;
800075f0:	f0 c9 ff fd 	sub	r9,r8,-3
800075f4:	13 8a       	ld.ub	r10,r9[0x0]
800075f6:	b9 6a       	lsl	r10,0x18
800075f8:	ee 06 00 06 	add	r6,r7,r6
800075fc:	e6 1a f0 00 	andh	r10,0xf000,COH
80007600:	f5 e5 10 05 	or	r5,r10,r5
			ST_DWORD(p, val);
80007604:	ed 65 00 30 	st.b	r6[48],r5
80007608:	f5 d5 c1 08 	bfextu	r10,r5,0x8,0x8
8000760c:	b0 9a       	st.b	r8[0x1],r10
8000760e:	ea 0a 16 10 	lsr	r10,r5,0x10
80007612:	b0 aa       	st.b	r8[0x2],r10
80007614:	b9 85       	lsr	r5,0x18
80007616:	b2 85       	st.b	r9[0x0],r5
			fs->wflag = 1;
80007618:	30 18       	mov	r8,1
8000761a:	ae c8       	st.b	r7[0x4],r8
			break;
8000761c:	d8 22       	popm	r4-r7,pc
8000761e:	30 2c       	mov	r12,2
			res = FR_INT_ERR;
		}
	}

	return res;
}
80007620:	d8 22       	popm	r4-r7,pc
80007622:	00 00       	add	r0,r0
80007624:	80 00       	ld.sh	r0,r0[0x0]
80007626:	6f 00       	ld.w	r0,r7[0x40]

80007628 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* FAT index number (cluster number) to get the value */
)
{
80007628:	d4 21       	pushm	r4-r7,lr
8000762a:	18 97       	mov	r7,r12
8000762c:	16 96       	mov	r6,r11
	UINT wc, bc;
	BYTE *p;
	DWORD val;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
8000762e:	58 1b       	cp.w	r11,1
80007630:	e0 88 00 69 	brls	80007702 <get_fat+0xda>
80007634:	78 58       	ld.w	r8,r12[0x14]
80007636:	10 3b       	cp.w	r11,r8
80007638:	c6 52       	brcc	80007702 <get_fat+0xda>
		val = 1;	/* Internal error */

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */

		switch (fs->fs_type) {
8000763a:	19 88       	ld.ub	r8,r12[0x0]
8000763c:	30 29       	mov	r9,2
8000763e:	f2 08 18 00 	cp.b	r8,r9
80007642:	c3 10       	breq	800076a4 <get_fat+0x7c>
80007644:	30 39       	mov	r9,3
80007646:	f2 08 18 00 	cp.b	r8,r9
8000764a:	c4 00       	breq	800076ca <get_fat+0xa2>
8000764c:	30 19       	mov	r9,1
8000764e:	f2 08 18 00 	cp.b	r8,r9
80007652:	c5 81       	brne	80007702 <get_fat+0xda>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
80007654:	f6 05 16 01 	lsr	r5,r11,0x1
80007658:	16 05       	add	r5,r11
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
8000765a:	ea 0b 16 09 	lsr	r11,r5,0x9
8000765e:	78 88       	ld.w	r8,r12[0x20]
80007660:	10 0b       	add	r11,r8
80007662:	f0 1f 00 2a 	mcall	80007708 <get_fat+0xe0>
80007666:	c4 f1       	brne	80007704 <get_fat+0xdc>
			wc = fs->win[bc++ % SS(fs)];
80007668:	f1 d5 c0 09 	bfextu	r8,r5,0x0,0x9
8000766c:	ee 08 00 08 	add	r8,r7,r8
80007670:	f1 34 00 30 	ld.ub	r4,r8[48]
80007674:	2f f5       	sub	r5,-1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
80007676:	ea 0b 16 09 	lsr	r11,r5,0x9
8000767a:	6e 88       	ld.w	r8,r7[0x20]
8000767c:	10 0b       	add	r11,r8
8000767e:	0e 9c       	mov	r12,r7
80007680:	f0 1f 00 22 	mcall	80007708 <get_fat+0xe0>
80007684:	c4 01       	brne	80007704 <get_fat+0xdc>
			wc |= fs->win[bc % SS(fs)] << 8;
80007686:	eb d5 c0 09 	bfextu	r5,r5,0x0,0x9
8000768a:	0a 07       	add	r7,r5
8000768c:	ef 3c 00 30 	ld.ub	r12,r7[48]
80007690:	e9 ec 10 8c 	or	r12,r4,r12<<0x8
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
80007694:	ed d6 c0 01 	bfextu	r6,r6,0x0,0x1
80007698:	c0 30       	breq	8000769e <get_fat+0x76>
8000769a:	a5 8c       	lsr	r12,0x4
8000769c:	d8 22       	popm	r4-r7,pc
8000769e:	f9 dc c0 0c 	bfextu	r12,r12,0x0,0xc
800076a2:	d8 22       	popm	r4-r7,pc
			break;

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
800076a4:	a9 8b       	lsr	r11,0x8
800076a6:	78 88       	ld.w	r8,r12[0x20]
800076a8:	10 0b       	add	r11,r8
800076aa:	f0 1f 00 18 	mcall	80007708 <get_fat+0xe0>
800076ae:	c2 b1       	brne	80007704 <get_fat+0xdc>
			p = &fs->win[clst * 2 % SS(fs)];
800076b0:	a1 76       	lsl	r6,0x1
800076b2:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
			val = LD_WORD(p);
800076b6:	ee 06 00 08 	add	r8,r7,r6
800076ba:	10 97       	mov	r7,r8
800076bc:	f1 3c 00 31 	ld.ub	r12,r8[49]
800076c0:	f1 38 00 30 	ld.ub	r8,r8[48]
800076c4:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
			break;
800076c8:	d8 22       	popm	r4-r7,pc

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
800076ca:	a7 9b       	lsr	r11,0x7
800076cc:	78 88       	ld.w	r8,r12[0x20]
800076ce:	10 0b       	add	r11,r8
800076d0:	f0 1f 00 0e 	mcall	80007708 <get_fat+0xe0>
800076d4:	c1 81       	brne	80007704 <get_fat+0xdc>
			p = &fs->win[clst * 4 % SS(fs)];
800076d6:	a3 66       	lsl	r6,0x2
800076d8:	ed d6 c0 09 	bfextu	r6,r6,0x0,0x9
800076dc:	ec c8 ff d0 	sub	r8,r6,-48
800076e0:	ee 08 00 08 	add	r8,r7,r8
			val = LD_DWORD(p) & 0x0FFFFFFF;
800076e4:	11 a9       	ld.ub	r9,r8[0x2]
800076e6:	11 bc       	ld.ub	r12,r8[0x3]
800076e8:	b9 6c       	lsl	r12,0x18
800076ea:	f9 e9 11 0c 	or	r12,r12,r9<<0x10
800076ee:	11 98       	ld.ub	r8,r8[0x1]
800076f0:	f9 e8 10 8c 	or	r12,r12,r8<<0x8
800076f4:	0c 07       	add	r7,r6
800076f6:	ef 38 00 30 	ld.ub	r8,r7[48]
800076fa:	10 4c       	or	r12,r8
800076fc:	f9 dc c0 1c 	bfextu	r12,r12,0x0,0x1c
			break;
80007700:	d8 22       	popm	r4-r7,pc
80007702:	da 2a       	popm	r4-r7,pc,r12=1
80007704:	dc 2a       	popm	r4-r7,pc,r12=-1
80007706:	00 00       	add	r0,r0
80007708:	80 00       	ld.sh	r0,r0[0x0]
8000770a:	6f 00       	ld.w	r0,r7[0x40]

8000770c <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	UINT idx		/* Index of directory table */
)
{
8000770c:	eb cd 40 f8 	pushm	r3-r7,lr
80007710:	18 96       	mov	r6,r12
80007712:	16 95       	mov	r5,r11
	DWORD clst, sect;
	UINT ic;


	dp->index = (WORD)idx;	/* Current index */
80007714:	ac 3b       	st.h	r6[0x6],r11
	clst = dp->sclust;		/* Table start cluster (0:root) */
80007716:	78 28       	ld.w	r8,r12[0x8]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
80007718:	58 18       	cp.w	r8,1
8000771a:	c4 c0       	breq	800077b2 <dir_sdi+0xa6>
8000771c:	78 09       	ld.w	r9,r12[0x0]
8000771e:	72 5a       	ld.w	r10,r9[0x14]
80007720:	14 38       	cp.w	r8,r10
80007722:	c4 82       	brcc	800077b2 <dir_sdi+0xa6>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
80007724:	58 08       	cp.w	r8,0
80007726:	c0 f1       	brne	80007744 <dir_sdi+0x38>
80007728:	13 8b       	ld.ub	r11,r9[0x0]
8000772a:	30 3a       	mov	r10,3
8000772c:	f4 0b 18 00 	cp.b	r11,r10
80007730:	c0 41       	brne	80007738 <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
80007732:	72 97       	ld.w	r7,r9[0x24]

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
80007734:	58 07       	cp.w	r7,0
80007736:	c0 81       	brne	80007746 <dir_sdi+0x3a>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
80007738:	92 ca       	ld.uh	r10,r9[0x8]
8000773a:	14 35       	cp.w	r5,r10
8000773c:	c3 b2       	brcc	800077b2 <dir_sdi+0xa6>
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
8000773e:	72 9c       	ld.w	r12,r9[0x24]
80007740:	10 97       	mov	r7,r8
80007742:	c2 68       	rjmp	8000778e <dir_sdi+0x82>
80007744:	10 97       	mov	r7,r8
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
80007746:	13 a4       	ld.ub	r4,r9[0x2]
80007748:	a5 64       	lsl	r4,0x4
		while (idx >= ic) {	/* Follow cluster chain */
8000774a:	08 35       	cp.w	r5,r4
8000774c:	c1 d3       	brcs	80007786 <dir_sdi+0x7a>
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
8000774e:	e8 03 11 00 	rsub	r3,r4,0
80007752:	08 15       	sub	r5,r4
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
80007754:	0e 9b       	mov	r11,r7
80007756:	6c 0c       	ld.w	r12,r6[0x0]
80007758:	f0 1f 00 18 	mcall	800077b8 <dir_sdi+0xac>
8000775c:	18 97       	mov	r7,r12
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
8000775e:	5b fc       	cp.w	r12,-1
80007760:	c0 31       	brne	80007766 <dir_sdi+0x5a>
80007762:	e3 cf 90 f8 	ldm	sp++,r3-r7,pc,r12=1
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
80007766:	58 1c       	cp.w	r12,1
80007768:	e0 88 00 25 	brls	800077b2 <dir_sdi+0xa6>
8000776c:	6c 08       	ld.w	r8,r6[0x0]
8000776e:	70 58       	ld.w	r8,r8[0x14]
80007770:	10 3c       	cp.w	r12,r8
80007772:	c2 02       	brcc	800077b2 <dir_sdi+0xa6>
80007774:	ea 03 00 08 	add	r8,r5,r3
			return FR_INT_ERR;
		sect = dp->fs->dirbase;
	}
	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
80007778:	f0 04 00 09 	add	r9,r8,r4
8000777c:	12 34       	cp.w	r4,r9
8000777e:	e0 8b 00 04 	brhi	80007786 <dir_sdi+0x7a>
80007782:	10 95       	mov	r5,r8
80007784:	ce 8b       	rjmp	80007754 <dir_sdi+0x48>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
				return FR_INT_ERR;
			idx -= ic;
		}
		sect = clust2sect(dp->fs, clst);
80007786:	0e 9b       	mov	r11,r7
80007788:	6c 0c       	ld.w	r12,r6[0x0]
8000778a:	f0 1f 00 0d 	mcall	800077bc <dir_sdi+0xb0>
	}
	dp->clust = clst;	/* Current cluster# */
8000778e:	8d 37       	st.w	r6[0xc],r7
	if (!sect) return FR_INT_ERR;
80007790:	58 0c       	cp.w	r12,0
80007792:	c1 00       	breq	800077b2 <dir_sdi+0xa6>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
80007794:	ea 08 16 04 	lsr	r8,r5,0x4
80007798:	f0 0c 00 0c 	add	r12,r8,r12
8000779c:	8d 4c       	st.w	r6[0x10],r12
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
8000779e:	6c 08       	ld.w	r8,r6[0x0]
800077a0:	2d 08       	sub	r8,-48
800077a2:	eb d5 c0 04 	bfextu	r5,r5,0x0,0x4
800077a6:	a5 75       	lsl	r5,0x5
800077a8:	f0 05 00 05 	add	r5,r8,r5
800077ac:	8d 55       	st.w	r6[0x14],r5
800077ae:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0

	return FR_OK;
800077b2:	30 2c       	mov	r12,2
}
800077b4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800077b8:	80 00       	ld.sh	r0,r0[0x0]
800077ba:	76 28       	ld.w	r8,r11[0x8]
800077bc:	80 00       	ld.sh	r0,r0[0x0]
800077be:	65 b4       	ld.w	r4,r2[0x6c]

800077c0 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
800077c0:	eb cd 40 fc 	pushm	r2-r7,lr
800077c4:	18 96       	mov	r6,r12
800077c6:	16 92       	mov	r2,r11
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
800077c8:	58 0b       	cp.w	r11,0
800077ca:	c0 81       	brne	800077da <create_chain+0x1a>
		scl = fs->last_clust;			/* Get suggested start point */
800077cc:	78 35       	ld.w	r5,r12[0xc]
		if (!scl || scl >= fs->n_fatent) scl = 1;
800077ce:	58 05       	cp.w	r5,0
800077d0:	c1 10       	breq	800077f2 <create_chain+0x32>
800077d2:	78 58       	ld.w	r8,r12[0x14]
800077d4:	10 35       	cp.w	r5,r8
800077d6:	c0 e2       	brcc	800077f2 <create_chain+0x32>
800077d8:	c0 e8       	rjmp	800077f4 <create_chain+0x34>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
800077da:	f0 1f 00 2c 	mcall	80007888 <create_chain+0xc8>
		if (cs < 2) return 1;			/* Invalid value */
800077de:	58 1c       	cp.w	r12,1
800077e0:	e0 88 00 4f 	brls	8000787e <create_chain+0xbe>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
800077e4:	5b fc       	cp.w	r12,-1
800077e6:	c4 f0       	breq	80007884 <create_chain+0xc4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
800077e8:	6c 58       	ld.w	r8,r6[0x14]
800077ea:	10 3c       	cp.w	r12,r8
800077ec:	c4 c3       	brcs	80007884 <create_chain+0xc4>
800077ee:	04 95       	mov	r5,r2
800077f0:	c0 28       	rjmp	800077f4 <create_chain+0x34>
800077f2:	30 15       	mov	r5,1
800077f4:	0a 97       	mov	r7,r5
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
800077f6:	30 23       	mov	r3,2
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
800077f8:	30 04       	mov	r4,0
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
800077fa:	2f f7       	sub	r7,-1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
800077fc:	6c 58       	ld.w	r8,r6[0x14]
800077fe:	10 37       	cp.w	r7,r8
80007800:	c0 53       	brcs	8000780a <create_chain+0x4a>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
80007802:	58 15       	cp.w	r5,1
80007804:	e0 88 00 3f 	brls	80007882 <create_chain+0xc2>
80007808:	06 97       	mov	r7,r3
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
8000780a:	0e 9b       	mov	r11,r7
8000780c:	0c 9c       	mov	r12,r6
8000780e:	f0 1f 00 1f 	mcall	80007888 <create_chain+0xc8>
		if (cs == 0) break;				/* Found a free cluster */
80007812:	c0 d0       	breq	8000782c <create_chain+0x6c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
80007814:	5b fc       	cp.w	r12,-1
80007816:	5f 09       	sreq	r9
80007818:	58 1c       	cp.w	r12,1
8000781a:	5f 08       	sreq	r8
8000781c:	f3 e8 10 08 	or	r8,r9,r8
80007820:	e8 08 18 00 	cp.b	r8,r4
80007824:	c3 01       	brne	80007884 <create_chain+0xc4>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
80007826:	0a 37       	cp.w	r7,r5
80007828:	ce 91       	brne	800077fa <create_chain+0x3a>
8000782a:	c2 c8       	rjmp	80007882 <create_chain+0xc2>
8000782c:	0e 95       	mov	r5,r7
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
8000782e:	e0 6a ff ff 	mov	r10,65535
80007832:	ea 1a 0f ff 	orh	r10,0xfff
80007836:	0e 9b       	mov	r11,r7
80007838:	0c 9c       	mov	r12,r6
8000783a:	f0 1f 00 15 	mcall	8000788c <create_chain+0xcc>
	if (res == FR_OK && clst != 0) {
8000783e:	5f 09       	sreq	r9
80007840:	58 02       	cp.w	r2,0
80007842:	5f 18       	srne	r8
80007844:	f3 e8 00 08 	and	r8,r9,r8
80007848:	c0 60       	breq	80007854 <create_chain+0x94>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
8000784a:	0e 9a       	mov	r10,r7
8000784c:	04 9b       	mov	r11,r2
8000784e:	0c 9c       	mov	r12,r6
80007850:	f0 1f 00 0f 	mcall	8000788c <create_chain+0xcc>
	}
	if (res == FR_OK) {
80007854:	58 0c       	cp.w	r12,0
80007856:	c1 01       	brne	80007876 <create_chain+0xb6>
		fs->last_clust = ncl;			/* Update FSINFO */
80007858:	8d 35       	st.w	r6[0xc],r5
		if (fs->free_clust != 0xFFFFFFFF) {
8000785a:	6c 48       	ld.w	r8,r6[0x10]
8000785c:	5b f8       	cp.w	r8,-1
8000785e:	c0 41       	brne	80007866 <create_chain+0xa6>
80007860:	0e 9c       	mov	r12,r7
80007862:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fs->free_clust--;
80007866:	20 18       	sub	r8,1
80007868:	8d 48       	st.w	r6[0x10],r8
			fs->fsi_flag |= 1;
8000786a:	0d d8       	ld.ub	r8,r6[0x5]
8000786c:	a1 a8       	sbr	r8,0x0
8000786e:	ac d8       	st.b	r6[0x5],r8
80007870:	0e 9c       	mov	r12,r7
80007872:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
80007876:	58 1c       	cp.w	r12,1
80007878:	c0 31       	brne	8000787e <create_chain+0xbe>
8000787a:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
8000787e:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
80007882:	30 0c       	mov	r12,0
	}

	return ncl;		/* Return new cluster number or error code */
}
80007884:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007888:	80 00       	ld.sh	r0,r0[0x0]
8000788a:	76 28       	ld.w	r8,r11[0x8]
8000788c:	80 00       	ld.sh	r0,r0[0x0]
8000788e:	74 f4       	ld.w	r4,r10[0x3c]

80007890 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
80007890:	eb cd 40 fc 	pushm	r2-r7,lr
80007894:	18 97       	mov	r7,r12
80007896:	16 96       	mov	r6,r11
#if !_FS_READONLY
	UINT c;
#endif


	i = dp->index + 1;
80007898:	98 b5       	ld.uh	r5,r12[0x6]
8000789a:	2f f5       	sub	r5,-1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
8000789c:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800078a0:	c6 d0       	breq	8000797a <dir_next+0xea>
800078a2:	78 48       	ld.w	r8,r12[0x10]
800078a4:	58 08       	cp.w	r8,0
800078a6:	c6 a0       	breq	8000797a <dir_next+0xea>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
800078a8:	e9 d5 c0 04 	bfextu	r4,r5,0x0,0x4
800078ac:	c5 e1       	brne	80007968 <dir_next+0xd8>
		dp->sect++;					/* Next sector */
800078ae:	2f f8       	sub	r8,-1
800078b0:	99 48       	st.w	r12[0x10],r8

		if (!dp->clust) {		/* Static table */
800078b2:	78 3b       	ld.w	r11,r12[0xc]
800078b4:	58 0b       	cp.w	r11,0
800078b6:	c0 61       	brne	800078c2 <dir_next+0x32>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
800078b8:	78 08       	ld.w	r8,r12[0x0]
800078ba:	90 c8       	ld.uh	r8,r8[0x8]
800078bc:	10 35       	cp.w	r5,r8
800078be:	c5 53       	brcs	80007968 <dir_next+0xd8>
800078c0:	c5 d8       	rjmp	8000797a <dir_next+0xea>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
800078c2:	78 0c       	ld.w	r12,r12[0x0]
800078c4:	19 a8       	ld.ub	r8,r12[0x2]
800078c6:	20 18       	sub	r8,1
800078c8:	f1 e5 02 48 	and	r8,r8,r5>>0x4
800078cc:	c4 e1       	brne	80007968 <dir_next+0xd8>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
800078ce:	f0 1f 00 30 	mcall	8000798c <dir_next+0xfc>
800078d2:	18 93       	mov	r3,r12
				if (clst <= 1) return FR_INT_ERR;
800078d4:	58 1c       	cp.w	r12,1
800078d6:	e0 88 00 55 	brls	80007980 <dir_next+0xf0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
800078da:	5b fc       	cp.w	r12,-1
800078dc:	c5 50       	breq	80007986 <dir_next+0xf6>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
800078de:	6e 0c       	ld.w	r12,r7[0x0]
800078e0:	78 58       	ld.w	r8,r12[0x14]
800078e2:	10 33       	cp.w	r3,r8
800078e4:	c3 c3       	brcs	8000795c <dir_next+0xcc>
#if !_FS_READONLY
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
800078e6:	58 06       	cp.w	r6,0
800078e8:	c4 90       	breq	8000797a <dir_next+0xea>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
800078ea:	6e 3b       	ld.w	r11,r7[0xc]
800078ec:	f0 1f 00 29 	mcall	80007990 <dir_next+0x100>
800078f0:	18 93       	mov	r3,r12
					if (clst == 0) return FR_DENIED;			/* No free cluster */
800078f2:	c0 41       	brne	800078fa <dir_next+0x6a>
800078f4:	30 7c       	mov	r12,7
800078f6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
					if (clst == 1) return FR_INT_ERR;
800078fa:	58 1c       	cp.w	r12,1
800078fc:	c4 20       	breq	80007980 <dir_next+0xf0>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
800078fe:	5b fc       	cp.w	r12,-1
80007900:	c4 30       	breq	80007986 <dir_next+0xf6>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
80007902:	6e 0c       	ld.w	r12,r7[0x0]
80007904:	f0 1f 00 24 	mcall	80007994 <dir_next+0x104>
80007908:	c3 f1       	brne	80007986 <dir_next+0xf6>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
8000790a:	6e 0c       	ld.w	r12,r7[0x0]
8000790c:	e0 6a 02 00 	mov	r10,512
80007910:	30 0b       	mov	r11,0
80007912:	2d 0c       	sub	r12,-48
80007914:	f0 1f 00 21 	mcall	80007998 <dir_next+0x108>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
80007918:	6e 06       	ld.w	r6,r7[0x0]
8000791a:	06 9b       	mov	r11,r3
8000791c:	0c 9c       	mov	r12,r6
8000791e:	f0 1f 00 20 	mcall	8000799c <dir_next+0x10c>
80007922:	8d bc       	st.w	r6[0x2c],r12
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
80007924:	6e 08       	ld.w	r8,r7[0x0]
80007926:	11 aa       	ld.ub	r10,r8[0x2]
80007928:	30 09       	mov	r9,0
8000792a:	f2 0a 18 00 	cp.b	r10,r9
8000792e:	c0 31       	brne	80007934 <dir_next+0xa4>
80007930:	30 06       	mov	r6,0
80007932:	c1 28       	rjmp	80007956 <dir_next+0xc6>
80007934:	30 06       	mov	r6,0
						dp->fs->wflag = 1;
80007936:	30 12       	mov	r2,1
80007938:	b0 c2       	st.b	r8[0x4],r2
						if (sync_window(dp->fs)) return FR_DISK_ERR;
8000793a:	6e 0c       	ld.w	r12,r7[0x0]
8000793c:	f0 1f 00 16 	mcall	80007994 <dir_next+0x104>
80007940:	c2 31       	brne	80007986 <dir_next+0xf6>
						dp->fs->winsect++;
80007942:	6e 08       	ld.w	r8,r7[0x0]
80007944:	70 b9       	ld.w	r9,r8[0x2c]
80007946:	2f f9       	sub	r9,-1
80007948:	91 b9       	st.w	r8[0x2c],r9
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
8000794a:	2f f6       	sub	r6,-1
8000794c:	6e 08       	ld.w	r8,r7[0x0]
8000794e:	11 a9       	ld.ub	r9,r8[0x2]
80007950:	0c 39       	cp.w	r9,r6
80007952:	fe 9b ff f3 	brhi	80007938 <dir_next+0xa8>
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
80007956:	70 b9       	ld.w	r9,r8[0x2c]
80007958:	0c 19       	sub	r9,r6
8000795a:	91 b9       	st.w	r8[0x2c],r9
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
8000795c:	8f 33       	st.w	r7[0xc],r3
				dp->sect = clust2sect(dp->fs, clst);
8000795e:	06 9b       	mov	r11,r3
80007960:	6e 0c       	ld.w	r12,r7[0x0]
80007962:	f0 1f 00 0f 	mcall	8000799c <dir_next+0x10c>
80007966:	8f 4c       	st.w	r7[0x10],r12
			}
		}
	}

	dp->index = (WORD)i;	/* Current index */
80007968:	ae 35       	st.h	r7[0x6],r5
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
8000796a:	6e 08       	ld.w	r8,r7[0x0]
8000796c:	2d 08       	sub	r8,-48
8000796e:	a5 74       	lsl	r4,0x5
80007970:	f0 04 00 04 	add	r4,r8,r4
80007974:	8f 54       	st.w	r7[0x14],r4
80007976:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

	return FR_OK;
8000797a:	30 4c       	mov	r12,4
8000797c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007980:	30 2c       	mov	r12,2
80007982:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80007986:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
8000798a:	00 00       	add	r0,r0
8000798c:	80 00       	ld.sh	r0,r0[0x0]
8000798e:	76 28       	ld.w	r8,r11[0x8]
80007990:	80 00       	ld.sh	r0,r0[0x0]
80007992:	77 c0       	ld.w	r0,r11[0x70]
80007994:	80 00       	ld.sh	r0,r0[0x0]
80007996:	67 08       	ld.w	r8,r3[0x40]
80007998:	80 00       	ld.sh	r0,r0[0x0]
8000799a:	65 8e       	ld.w	lr,r2[0x60]
8000799c:	80 00       	ld.sh	r0,r0[0x0]
8000799e:	65 b4       	ld.w	r4,r2[0x6c]

800079a0 <remove_chain>:
static
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
800079a0:	d4 21       	pushm	r4-r7,lr
800079a2:	18 97       	mov	r7,r12
800079a4:	16 95       	mov	r5,r11
	DWORD nxt;
#if _USE_TRIM
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
800079a6:	58 1b       	cp.w	r11,1
800079a8:	e0 88 00 26 	brls	800079f4 <remove_chain+0x54>
800079ac:	78 58       	ld.w	r8,r12[0x14]
800079ae:	10 3b       	cp.w	r11,r8
800079b0:	c2 22       	brcc	800079f4 <remove_chain+0x54>
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
800079b2:	30 04       	mov	r4,0
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
800079b4:	0a 9b       	mov	r11,r5
800079b6:	0e 9c       	mov	r12,r7
800079b8:	f0 1f 00 10 	mcall	800079f8 <remove_chain+0x58>
800079bc:	18 96       	mov	r6,r12
			if (nxt == 0) break;				/* Empty cluster? */
800079be:	c0 21       	brne	800079c2 <remove_chain+0x22>
800079c0:	d8 2a       	popm	r4-r7,pc,r12=0
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
800079c2:	58 1c       	cp.w	r12,1
800079c4:	c1 80       	breq	800079f4 <remove_chain+0x54>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
800079c6:	5b fc       	cp.w	r12,-1
800079c8:	c0 21       	brne	800079cc <remove_chain+0x2c>
800079ca:	da 2a       	popm	r4-r7,pc,r12=1
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
800079cc:	08 9a       	mov	r10,r4
800079ce:	0a 9b       	mov	r11,r5
800079d0:	0e 9c       	mov	r12,r7
800079d2:	f0 1f 00 0b 	mcall	800079fc <remove_chain+0x5c>
			if (res != FR_OK) break;
800079d6:	c1 01       	brne	800079f6 <remove_chain+0x56>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
800079d8:	6e 48       	ld.w	r8,r7[0x10]
800079da:	5b f8       	cp.w	r8,-1
800079dc:	c0 60       	breq	800079e8 <remove_chain+0x48>
				fs->free_clust++;
800079de:	2f f8       	sub	r8,-1
800079e0:	8f 48       	st.w	r7[0x10],r8
				fs->fsi_flag |= 1;
800079e2:	0f d8       	ld.ub	r8,r7[0x5]
800079e4:	a1 a8       	sbr	r8,0x0
800079e6:	ae d8       	st.b	r7[0x5],r8
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
800079e8:	6e 58       	ld.w	r8,r7[0x14]
800079ea:	0c 38       	cp.w	r8,r6
800079ec:	e0 88 00 05 	brls	800079f6 <remove_chain+0x56>
800079f0:	0c 95       	mov	r5,r6
800079f2:	ce 1b       	rjmp	800079b4 <remove_chain+0x14>
800079f4:	30 2c       	mov	r12,2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
800079f6:	d8 22       	popm	r4-r7,pc
800079f8:	80 00       	ld.sh	r0,r0[0x0]
800079fa:	76 28       	ld.w	r8,r11[0x8]
800079fc:	80 00       	ld.sh	r0,r0[0x0]
800079fe:	74 f4       	ld.w	r4,r10[0x3c]

80007a00 <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
80007a00:	eb cd 40 fe 	pushm	r1-r7,lr
80007a04:	18 97       	mov	r7,r12
80007a06:	16 91       	mov	r1,r11
80007a08:	30 4c       	mov	r12,4
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007a0a:	3e 56       	mov	r6,-27
80007a0c:	32 e5       	mov	r5,46
80007a0e:	30 04       	mov	r4,0
80007a10:	30 f2       	mov	r2,15
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007a12:	30 03       	mov	r3,0
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007a14:	c2 58       	rjmp	80007a5e <dir_read+0x5e>
		res = move_window(dp->fs, dp->sect);
80007a16:	6e 0c       	ld.w	r12,r7[0x0]
80007a18:	f0 1f 00 17 	mcall	80007a74 <dir_read+0x74>
		if (res != FR_OK) break;
80007a1c:	c2 61       	brne	80007a68 <dir_read+0x68>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
80007a1e:	6e 59       	ld.w	r9,r7[0x14]
		c = dir[DIR_Name];
80007a20:	13 88       	ld.ub	r8,r9[0x0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80007a22:	58 08       	cp.w	r8,0
80007a24:	c2 60       	breq	80007a70 <dir_read+0x70>
		a = dir[DIR_Attr] & AM_MASK;
80007a26:	f3 3a 00 0b 	ld.ub	r10,r9[11]
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007a2a:	ec 08 18 00 	cp.b	r8,r6
80007a2e:	5f 19       	srne	r9
80007a30:	ea 08 18 00 	cp.b	r8,r5
80007a34:	5f 18       	srne	r8
80007a36:	f3 e8 00 08 	and	r8,r9,r8
80007a3a:	e8 08 18 00 	cp.b	r8,r4
80007a3e:	c0 b0       	breq	80007a54 <dir_read+0x54>
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		a = dir[DIR_Attr] & AM_MASK;
80007a40:	f1 da c0 06 	bfextu	r8,r10,0x0,0x6
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDEM && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
80007a44:	e4 08 18 00 	cp.b	r8,r2
80007a48:	c0 60       	breq	80007a54 <dir_read+0x54>
80007a4a:	a5 d8       	cbr	r8,0x5
80007a4c:	58 88       	cp.w	r8,8
80007a4e:	5f 08       	sreq	r8
80007a50:	02 38       	cp.w	r8,r1
80007a52:	c0 d0       	breq	80007a6c <dir_read+0x6c>
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
80007a54:	06 9b       	mov	r11,r3
80007a56:	0e 9c       	mov	r12,r7
80007a58:	f0 1f 00 08 	mcall	80007a78 <dir_read+0x78>
		if (res != FR_OK) break;
80007a5c:	c0 61       	brne	80007a68 <dir_read+0x68>
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dp->sect) {
80007a5e:	6e 4b       	ld.w	r11,r7[0x10]
80007a60:	58 0b       	cp.w	r11,0
80007a62:	cd a1       	brne	80007a16 <dir_read+0x16>
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007a64:	58 0c       	cp.w	r12,0
80007a66:	c0 30       	breq	80007a6c <dir_read+0x6c>
80007a68:	30 08       	mov	r8,0
80007a6a:	8f 48       	st.w	r7[0x10],r8

	return res;
}
80007a6c:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
#endif
		res = dir_next(dp, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dp->sect = 0;
80007a70:	30 4c       	mov	r12,4
80007a72:	cf bb       	rjmp	80007a68 <dir_read+0x68>
80007a74:	80 00       	ld.sh	r0,r0[0x0]
80007a76:	6f 00       	ld.w	r0,r7[0x40]
80007a78:	80 00       	ld.sh	r0,r0[0x0]
80007a7a:	78 90       	ld.w	r0,r12[0x24]

80007a7c <f_getlabel>:
FRESULT f_getlabel (
	const TCHAR* path,	/* Path name of the logical drive number */
	TCHAR* label,		/* Pointer to a buffer to return the volume label */
	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
)
{
80007a7c:	d4 21       	pushm	r4-r7,lr
80007a7e:	20 9d       	sub	sp,36
80007a80:	50 0c       	stdsp	sp[0x0],r12
80007a82:	16 96       	mov	r6,r11
80007a84:	14 95       	mov	r5,r10
	WCHAR w;
#endif


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
80007a86:	30 0a       	mov	r10,0
80007a88:	1a 9b       	mov	r11,sp
80007a8a:	fa cc ff fc 	sub	r12,sp,-4
80007a8e:	f0 1f 00 30 	mcall	80007b4c <f_getlabel+0xd0>
80007a92:	18 97       	mov	r7,r12

	/* Get volume label */
	if (res == FR_OK && label) {
80007a94:	5f 09       	sreq	r9
80007a96:	58 06       	cp.w	r6,0
80007a98:	5f 18       	srne	r8
80007a9a:	f3 e8 00 08 	and	r8,r9,r8
80007a9e:	c2 d0       	breq	80007af8 <f_getlabel+0x7c>
		dj.sclust = 0;					/* Open root directory */
80007aa0:	30 0b       	mov	r11,0
80007aa2:	50 3b       	stdsp	sp[0xc],r11
		res = dir_sdi(&dj, 0);
80007aa4:	fa cc ff fc 	sub	r12,sp,-4
80007aa8:	f0 1f 00 2a 	mcall	80007b50 <f_getlabel+0xd4>
80007aac:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007aae:	c4 c1       	brne	80007b46 <f_getlabel+0xca>
			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007ab0:	30 1b       	mov	r11,1
80007ab2:	fa cc ff fc 	sub	r12,sp,-4
80007ab6:	f0 1f 00 28 	mcall	80007b54 <f_getlabel+0xd8>
80007aba:	18 94       	mov	r4,r12
			if (res == FR_OK) {			/* A volume label is exist */
80007abc:	c1 81       	brne	80007aec <f_getlabel+0x70>
					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
						w = w << 8 | dj.dir[i++];
					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
				} while (j < 11);
#else
				mem_cpy(label, dj.dir, 11);
80007abe:	30 ba       	mov	r10,11
80007ac0:	40 6b       	lddsp	r11,sp[0x18]
80007ac2:	0c 9c       	mov	r12,r6
80007ac4:	f0 1f 00 25 	mcall	80007b58 <f_getlabel+0xdc>
#endif
				j = 11;
				do {
					label[j] = 0;
80007ac8:	30 08       	mov	r8,0
80007aca:	ed 68 00 0b 	st.b	r6[11],r8
80007ace:	2f 66       	sub	r6,-10
80007ad0:	30 b8       	mov	r8,11
					if (!j) break;
				} while (label[--j] == ' ');
80007ad2:	32 0a       	mov	r10,32
#else
				mem_cpy(label, dj.dir, 11);
#endif
				j = 11;
				do {
					label[j] = 0;
80007ad4:	30 0b       	mov	r11,0
80007ad6:	c0 58       	rjmp	80007ae0 <f_getlabel+0x64>
80007ad8:	ac 8b       	st.b	r6[0x0],r11
80007ada:	20 16       	sub	r6,1
					if (!j) break;
80007adc:	58 08       	cp.w	r8,0
80007ade:	c0 c0       	breq	80007af6 <f_getlabel+0x7a>
				} while (label[--j] == ' ');
80007ae0:	20 18       	sub	r8,1
80007ae2:	0d 89       	ld.ub	r9,r6[0x0]
80007ae4:	f4 09 18 00 	cp.b	r9,r10
80007ae8:	cf 80       	breq	80007ad8 <f_getlabel+0x5c>
80007aea:	c0 68       	rjmp	80007af6 <f_getlabel+0x7a>
			}
			if (res == FR_NO_FILE) {	/* No label, return nul string */
80007aec:	58 4c       	cp.w	r12,4
80007aee:	c0 41       	brne	80007af6 <f_getlabel+0x7a>
				label[0] = 0;
80007af0:	30 08       	mov	r8,0
80007af2:	ac 88       	st.b	r6[0x0],r8
80007af4:	c0 28       	rjmp	80007af8 <f_getlabel+0x7c>
80007af6:	08 97       	mov	r7,r4
			}
		}
	}

	/* Get volume serial number */
	if (res == FR_OK && vsn) {
80007af8:	58 07       	cp.w	r7,0
80007afa:	5f 09       	sreq	r9
80007afc:	58 05       	cp.w	r5,0
80007afe:	5f 18       	srne	r8
80007b00:	f3 e8 00 08 	and	r8,r9,r8
80007b04:	c2 10       	breq	80007b46 <f_getlabel+0xca>
		res = move_window(dj.fs, dj.fs->volbase);
80007b06:	40 1c       	lddsp	r12,sp[0x4]
80007b08:	78 7b       	ld.w	r11,r12[0x1c]
80007b0a:	f0 1f 00 15 	mcall	80007b5c <f_getlabel+0xe0>
80007b0e:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007b10:	c1 b1       	brne	80007b46 <f_getlabel+0xca>
			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
80007b12:	40 19       	lddsp	r9,sp[0x4]
80007b14:	13 8a       	ld.ub	r10,r9[0x0]
80007b16:	30 38       	mov	r8,3
80007b18:	f0 0a 18 00 	cp.b	r10,r8
80007b1c:	f9 b8 00 43 	moveq	r8,67
80007b20:	f9 b8 01 27 	movne	r8,39
			*vsn = LD_DWORD(&dj.fs->win[i]);
80007b24:	f2 08 00 08 	add	r8,r9,r8
80007b28:	f1 3a 00 33 	ld.ub	r10,r8[51]
80007b2c:	f1 39 00 32 	ld.ub	r9,r8[50]
80007b30:	b1 69       	lsl	r9,0x10
80007b32:	f3 ea 11 89 	or	r9,r9,r10<<0x18
80007b36:	f1 3a 00 30 	ld.ub	r10,r8[48]
80007b3a:	14 49       	or	r9,r10
80007b3c:	f1 38 00 31 	ld.ub	r8,r8[49]
80007b40:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80007b44:	8b 08       	st.w	r5[0x0],r8
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007b46:	0e 9c       	mov	r12,r7
80007b48:	2f 7d       	sub	sp,-36
80007b4a:	d8 22       	popm	r4-r7,pc
80007b4c:	80 00       	ld.sh	r0,r0[0x0]
80007b4e:	6f dc       	ld.w	r12,r7[0x74]
80007b50:	80 00       	ld.sh	r0,r0[0x0]
80007b52:	77 0c       	ld.w	r12,r11[0x40]
80007b54:	80 00       	ld.sh	r0,r0[0x0]
80007b56:	7a 00       	ld.w	r0,sp[0x0]
80007b58:	80 00       	ld.sh	r0,r0[0x0]
80007b5a:	65 78       	ld.w	r8,r2[0x5c]
80007b5c:	80 00       	ld.sh	r0,r0[0x0]
80007b5e:	6f 00       	ld.w	r0,r7[0x40]

80007b60 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate (1-21) */
)
{
80007b60:	eb cd 40 fe 	pushm	r1-r7,lr
80007b64:	18 97       	mov	r7,r12
80007b66:	16 92       	mov	r2,r11
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
80007b68:	30 0b       	mov	r11,0
80007b6a:	f0 1f 00 15 	mcall	80007bbc <dir_alloc+0x5c>
	if (res == FR_OK) {
80007b6e:	c2 21       	brne	80007bb2 <dir_alloc+0x52>
80007b70:	30 05       	mov	r5,0
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
			if (res != FR_OK) break;
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007b72:	3e 54       	mov	r4,-27
80007b74:	30 06       	mov	r6,0
80007b76:	0a 91       	mov	r1,r5
				if (++n == nent) break;	/* A block of contiguous free entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007b78:	30 13       	mov	r3,1

	res = dir_sdi(dp, 0);
	if (res == FR_OK) {
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
80007b7a:	6e 4b       	ld.w	r11,r7[0x10]
80007b7c:	6e 0c       	ld.w	r12,r7[0x0]
80007b7e:	f0 1f 00 11 	mcall	80007bc0 <dir_alloc+0x60>
			if (res != FR_OK) break;
80007b82:	c1 81       	brne	80007bb2 <dir_alloc+0x52>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
80007b84:	6e 58       	ld.w	r8,r7[0x14]
80007b86:	11 88       	ld.ub	r8,r8[0x0]
80007b88:	e8 08 18 00 	cp.b	r8,r4
80007b8c:	5f 09       	sreq	r9
80007b8e:	ec 08 18 00 	cp.b	r8,r6
80007b92:	5f 08       	sreq	r8
80007b94:	f3 e8 10 08 	or	r8,r9,r8
80007b98:	ec 08 18 00 	cp.b	r8,r6
80007b9c:	c0 31       	brne	80007ba2 <dir_alloc+0x42>
80007b9e:	02 95       	mov	r5,r1
80007ba0:	c0 48       	rjmp	80007ba8 <dir_alloc+0x48>
				if (++n == nent) break;	/* A block of contiguous free entries is found */
80007ba2:	2f f5       	sub	r5,-1
80007ba4:	04 35       	cp.w	r5,r2
80007ba6:	c0 90       	breq	80007bb8 <dir_alloc+0x58>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
80007ba8:	06 9b       	mov	r11,r3
80007baa:	0e 9c       	mov	r12,r7
80007bac:	f0 1f 00 06 	mcall	80007bc4 <dir_alloc+0x64>
		} while (res == FR_OK);
80007bb0:	ce 50       	breq	80007b7a <dir_alloc+0x1a>
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
80007bb2:	58 4c       	cp.w	r12,4
80007bb4:	f9 bc 00 07 	moveq	r12,7
	return res;
}
80007bb8:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80007bbc:	80 00       	ld.sh	r0,r0[0x0]
80007bbe:	77 0c       	ld.w	r12,r11[0x40]
80007bc0:	80 00       	ld.sh	r0,r0[0x0]
80007bc2:	6f 00       	ld.w	r0,r7[0x40]
80007bc4:	80 00       	ld.sh	r0,r0[0x0]
80007bc6:	78 90       	ld.w	r0,r12[0x24]

80007bc8 <f_setlabel>:
/*-----------------------------------------------------------------------*/

FRESULT f_setlabel (
	const TCHAR* label	/* Pointer to the volume label to set */
)
{
80007bc8:	d4 31       	pushm	r0-r7,lr
80007bca:	20 cd       	sub	sp,48
80007bcc:	50 0c       	stdsp	sp[0x0],r12
	WCHAR w;
	DWORD tm;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &label, 1);
80007bce:	30 1a       	mov	r10,1
80007bd0:	1a 9b       	mov	r11,sp
80007bd2:	fa cc ff f0 	sub	r12,sp,-16
80007bd6:	f0 1f 00 8b 	mcall	80007e00 <f_setlabel+0x238>
	if (res) LEAVE_FF(dj.fs, res);
80007bda:	e0 81 01 08 	brne	80007dea <f_setlabel+0x222>

	/* Create a volume label in directory form */
	vn[0] = 0;
80007bde:	30 08       	mov	r8,0
80007be0:	ba c8       	st.b	sp[0x4],r8
	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
80007be2:	40 0a       	lddsp	r10,sp[0x0]
80007be4:	15 89       	ld.ub	r9,r10[0x0]
80007be6:	f0 09 18 00 	cp.b	r9,r8
80007bea:	e0 80 00 90 	breq	80007d0a <f_setlabel+0x142>
80007bee:	30 07       	mov	r7,0
80007bf0:	2f f7       	sub	r7,-1
80007bf2:	f4 07 07 09 	ld.ub	r9,r10[r7]
80007bf6:	f0 09 18 00 	cp.b	r9,r8
80007bfa:	cf b1       	brne	80007bf0 <f_setlabel+0x28>
80007bfc:	0e 98       	mov	r8,r7
	for ( ; sl && label[sl - 1] == ' '; sl--) ;	/* Remove trailing spaces */
80007bfe:	58 07       	cp.w	r7,0
80007c00:	e0 80 00 85 	breq	80007d0a <f_setlabel+0x142>
80007c04:	f4 07 00 09 	add	r9,r10,r7
80007c08:	f3 3b ff ff 	ld.ub	r11,r9[-1]
80007c0c:	32 09       	mov	r9,32
80007c0e:	f2 0b 18 00 	cp.b	r11,r9
80007c12:	e0 81 00 ee 	brne	80007dee <f_setlabel+0x226>
80007c16:	20 28       	sub	r8,2
80007c18:	f4 08 00 08 	add	r8,r10,r8
80007c1c:	12 9a       	mov	r10,r9
80007c1e:	20 17       	sub	r7,1
80007c20:	c7 50       	breq	80007d0a <f_setlabel+0x142>
80007c22:	11 89       	ld.ub	r9,r8[0x0]
80007c24:	20 18       	sub	r8,1
80007c26:	f4 09 18 00 	cp.b	r9,r10
80007c2a:	cf a0       	breq	80007c1e <f_setlabel+0x56>
80007c2c:	ce 18       	rjmp	80007dee <f_setlabel+0x226>
		i = j = 0;
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
80007c2e:	40 08       	lddsp	r8,sp[0x0]
80007c30:	f0 04 07 06 	ld.ub	r6,r8[r4]
80007c34:	2f f4       	sub	r4,-1
			if (IsDBCS1(w))
80007c36:	ec c9 ff 81 	sub	r9,r6,-127
80007c3a:	e4 09 18 00 	cp.b	r9,r2
80007c3e:	e0 8b 00 24 	brhi	80007c86 <f_setlabel+0xbe>
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007c42:	58 95       	cp.w	r5,9
80007c44:	5f 8a       	srls	r10
80007c46:	0e 34       	cp.w	r4,r7
80007c48:	5f 39       	srlo	r9
80007c4a:	f5 e9 00 09 	and	r9,r10,r9
80007c4e:	e2 09 18 00 	cp.b	r9,r1
80007c52:	e0 80 00 c9 	breq	80007de4 <f_setlabel+0x21c>
80007c56:	f0 04 07 08 	ld.ub	r8,r8[r4]
80007c5a:	f0 c9 00 40 	sub	r9,r8,64
80007c5e:	33 eb       	mov	r11,62
80007c60:	f6 09 18 00 	cp.b	r9,r11
80007c64:	5f 8a       	srls	r10
80007c66:	f0 c9 00 80 	sub	r9,r8,128
80007c6a:	37 eb       	mov	r11,126
80007c6c:	f6 09 18 00 	cp.b	r9,r11
80007c70:	5f 89       	srls	r9
80007c72:	f5 e9 10 09 	or	r9,r10,r9
80007c76:	e2 09 18 00 	cp.b	r9,r1
80007c7a:	e0 80 00 b5 	breq	80007de4 <f_setlabel+0x21c>
80007c7e:	f1 e6 10 86 	or	r6,r8,r6<<0x8
80007c82:	5c 86       	casts.h	r6
80007c84:	2f f4       	sub	r4,-1
#if _USE_LFN
			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
#else
			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
80007c86:	ec c8 00 61 	sub	r8,r6,97
80007c8a:	31 9a       	mov	r10,25
80007c8c:	f4 08 19 00 	cp.h	r8,r10
80007c90:	e0 8b 00 04 	brhi	80007c98 <f_setlabel+0xd0>
80007c94:	22 06       	sub	r6,32
80007c96:	5c 86       	casts.h	r6
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007c98:	58 06       	cp.w	r6,0
80007c9a:	e0 80 00 a5 	breq	80007de4 <f_setlabel+0x21c>
80007c9e:	f7 d6 c0 10 	bfextu	r11,r6,0x0,0x10
80007ca2:	00 9c       	mov	r12,r0
80007ca4:	f0 1f 00 58 	mcall	80007e04 <f_setlabel+0x23c>
80007ca8:	e0 81 00 9e 	brne	80007de4 <f_setlabel+0x21c>
80007cac:	ec 03 19 00 	cp.h	r3,r6
80007cb0:	f9 b8 03 0a 	movlo	r8,10
80007cb4:	f9 b8 02 0b 	movhs	r8,11
80007cb8:	10 35       	cp.w	r5,r8
80007cba:	e0 82 00 95 	brhs	80007de4 <f_setlabel+0x21c>
				LEAVE_FF(dj.fs, FR_INVALID_NAME);
			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
80007cbe:	e6 06 19 00 	cp.h	r6,r3
80007cc2:	e0 88 00 0a 	brls	80007cd6 <f_setlabel+0x10e>
80007cc6:	fa c8 ff d0 	sub	r8,sp,-48
80007cca:	0a 08       	add	r8,r5
80007ccc:	f3 d6 c1 08 	bfextu	r9,r6,0x8,0x8
80007cd0:	f1 69 ff d4 	st.b	r8[-44],r9
80007cd4:	2f f5       	sub	r5,-1
			vn[j++] = (BYTE)w;
80007cd6:	fa c8 ff d0 	sub	r8,sp,-48
80007cda:	0a 08       	add	r8,r5
80007cdc:	f1 66 ff d4 	st.b	r8[-44],r6
80007ce0:	2f f5       	sub	r5,-1
		} while (i < sl);
80007ce2:	0e 34       	cp.w	r4,r7
80007ce4:	ca 53       	brcs	80007c2e <f_setlabel+0x66>
		while (j < 11) vn[j++] = ' ';	/* Fill remaining name field */
80007ce6:	58 a5       	cp.w	r5,10
80007ce8:	e0 8b 00 0c 	brhi	80007d00 <f_setlabel+0x138>
80007cec:	fa c9 ff fc 	sub	r9,sp,-4
80007cf0:	f2 05 00 08 	add	r8,r9,r5
80007cf4:	32 09       	mov	r9,32
80007cf6:	10 c9       	st.b	r8++,r9
80007cf8:	2f f5       	sub	r5,-1
80007cfa:	58 a5       	cp.w	r5,10
80007cfc:	fe 98 ff fd 	brls	80007cf6 <f_setlabel+0x12e>
		if (vn[0] == DDEM) LEAVE_FF(dj.fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
80007d00:	3e 58       	mov	r8,-27
80007d02:	1b c9       	ld.ub	r9,sp[0x4]
80007d04:	f0 09 18 00 	cp.b	r9,r8
80007d08:	c6 e0       	breq	80007de4 <f_setlabel+0x21c>
	}

	/* Set volume label */
	dj.sclust = 0;					/* Open root directory */
80007d0a:	30 0b       	mov	r11,0
80007d0c:	50 6b       	stdsp	sp[0x18],r11
	res = dir_sdi(&dj, 0);
80007d0e:	fa cc ff f0 	sub	r12,sp,-16
80007d12:	f0 1f 00 3e 	mcall	80007e08 <f_setlabel+0x240>
80007d16:	18 97       	mov	r7,r12
	if (res == FR_OK) {
80007d18:	c6 81       	brne	80007de8 <f_setlabel+0x220>
		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
80007d1a:	30 1b       	mov	r11,1
80007d1c:	fa cc ff f0 	sub	r12,sp,-16
80007d20:	f0 1f 00 3b 	mcall	80007e0c <f_setlabel+0x244>
		if (res == FR_OK) {			/* A volume label is found */
80007d24:	c2 a1       	brne	80007d78 <f_setlabel+0x1b0>
			if (vn[0]) {
80007d26:	30 08       	mov	r8,0
80007d28:	1b c9       	ld.ub	r9,sp[0x4]
80007d2a:	f0 09 18 00 	cp.b	r9,r8
80007d2e:	c1 b0       	breq	80007d64 <f_setlabel+0x19c>
				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
80007d30:	30 ba       	mov	r10,11
80007d32:	fa cb ff fc 	sub	r11,sp,-4
80007d36:	40 9c       	lddsp	r12,sp[0x24]
80007d38:	f0 1f 00 36 	mcall	80007e10 <f_setlabel+0x248>
				tm = GET_FATTIME();
80007d3c:	f0 1f 00 36 	mcall	80007e14 <f_setlabel+0x24c>
				ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007d40:	40 98       	lddsp	r8,sp[0x24]
80007d42:	f1 6c 00 16 	st.b	r8[22],r12
80007d46:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007d4a:	40 98       	lddsp	r8,sp[0x24]
80007d4c:	f1 69 00 17 	st.b	r8[23],r9
80007d50:	f8 09 16 10 	lsr	r9,r12,0x10
80007d54:	40 98       	lddsp	r8,sp[0x24]
80007d56:	f1 69 00 18 	st.b	r8[24],r9
80007d5a:	b9 8c       	lsr	r12,0x18
80007d5c:	40 98       	lddsp	r8,sp[0x24]
80007d5e:	f1 6c 00 19 	st.b	r8[25],r12
80007d62:	c0 48       	rjmp	80007d6a <f_setlabel+0x1a2>
			} else {
				dj.dir[0] = DDEM;			/* Remove the volume label */
80007d64:	3e 59       	mov	r9,-27
80007d66:	40 98       	lddsp	r8,sp[0x24]
80007d68:	b0 89       	st.b	r8[0x0],r9
			}
			dj.fs->wflag = 1;
80007d6a:	30 19       	mov	r9,1
80007d6c:	40 48       	lddsp	r8,sp[0x10]
80007d6e:	b0 c9       	st.b	r8[0x4],r9
			res = sync_fs(dj.fs);
80007d70:	40 4c       	lddsp	r12,sp[0x10]
80007d72:	f0 1f 00 2a 	mcall	80007e18 <f_setlabel+0x250>
80007d76:	c3 a8       	rjmp	80007dea <f_setlabel+0x222>
		} else {					/* No volume label is found or error */
			if (res == FR_NO_FILE) {
80007d78:	58 4c       	cp.w	r12,4
80007d7a:	c3 81       	brne	80007dea <f_setlabel+0x222>
				res = FR_OK;
				if (vn[0]) {				/* Create volume label as new */
80007d7c:	30 08       	mov	r8,0
80007d7e:	1b c9       	ld.ub	r9,sp[0x4]
80007d80:	f0 09 18 00 	cp.b	r9,r8
80007d84:	c3 20       	breq	80007de8 <f_setlabel+0x220>
					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
80007d86:	30 1b       	mov	r11,1
80007d88:	fa cc ff f0 	sub	r12,sp,-16
80007d8c:	f0 1f 00 24 	mcall	80007e1c <f_setlabel+0x254>
					if (res == FR_OK) {
80007d90:	c2 d1       	brne	80007dea <f_setlabel+0x222>
						mem_set(dj.dir, 0, SZ_DIRE);	/* Set volume label */
80007d92:	32 0a       	mov	r10,32
80007d94:	30 0b       	mov	r11,0
80007d96:	40 9c       	lddsp	r12,sp[0x24]
80007d98:	f0 1f 00 22 	mcall	80007e20 <f_setlabel+0x258>
						mem_cpy(dj.dir, vn, 11);
80007d9c:	30 ba       	mov	r10,11
80007d9e:	fa cb ff fc 	sub	r11,sp,-4
80007da2:	40 9c       	lddsp	r12,sp[0x24]
80007da4:	f0 1f 00 1b 	mcall	80007e10 <f_setlabel+0x248>
						dj.dir[DIR_Attr] = AM_VOL;
80007da8:	30 89       	mov	r9,8
80007daa:	40 98       	lddsp	r8,sp[0x24]
80007dac:	f1 69 00 0b 	st.b	r8[11],r9
						tm = GET_FATTIME();
80007db0:	f0 1f 00 19 	mcall	80007e14 <f_setlabel+0x24c>
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
80007db4:	40 98       	lddsp	r8,sp[0x24]
80007db6:	f1 6c 00 16 	st.b	r8[22],r12
80007dba:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
80007dbe:	40 98       	lddsp	r8,sp[0x24]
80007dc0:	f1 69 00 17 	st.b	r8[23],r9
80007dc4:	f8 09 16 10 	lsr	r9,r12,0x10
80007dc8:	40 98       	lddsp	r8,sp[0x24]
80007dca:	f1 69 00 18 	st.b	r8[24],r9
80007dce:	b9 8c       	lsr	r12,0x18
80007dd0:	40 98       	lddsp	r8,sp[0x24]
80007dd2:	f1 6c 00 19 	st.b	r8[25],r12
						dj.fs->wflag = 1;
80007dd6:	30 19       	mov	r9,1
80007dd8:	40 48       	lddsp	r8,sp[0x10]
80007dda:	b0 c9       	st.b	r8[0x4],r9
						res = sync_fs(dj.fs);
80007ddc:	40 4c       	lddsp	r12,sp[0x10]
80007dde:	f0 1f 00 0f 	mcall	80007e18 <f_setlabel+0x250>
80007de2:	c0 48       	rjmp	80007dea <f_setlabel+0x222>
80007de4:	30 6c       	mov	r12,6
80007de6:	c0 28       	rjmp	80007dea <f_setlabel+0x222>
80007de8:	0e 9c       	mov	r12,r7
			}
		}
	}

	LEAVE_FF(dj.fs, res);
}
80007dea:	2f 4d       	sub	sp,-48
80007dec:	d8 32       	popm	r0-r7,pc
						mem_cpy(dj.dir, vn, 11);
						dj.dir[DIR_Attr] = AM_VOL;
						tm = GET_FATTIME();
						ST_DWORD(dj.dir + DIR_WrtTime, tm);
						dj.fs->wflag = 1;
						res = sync_fs(dj.fs);
80007dee:	30 05       	mov	r5,0
80007df0:	0a 94       	mov	r4,r5
		do {
#if _USE_LFN && _LFN_UNICODE
			w = ff_convert(ff_wtoupper(label[i++]), 0);
#else
			w = (BYTE)label[i++];
			if (IsDBCS1(w))
80007df2:	37 d2       	mov	r2,125
				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
80007df4:	30 01       	mov	r1,0
#else
			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
#endif
			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
80007df6:	48 c0       	lddpc	r0,80007e24 <f_setlabel+0x25c>
80007df8:	e0 63 00 ff 	mov	r3,255
80007dfc:	c1 9b       	rjmp	80007c2e <f_setlabel+0x66>
80007dfe:	00 00       	add	r0,r0
80007e00:	80 00       	ld.sh	r0,r0[0x0]
80007e02:	6f dc       	ld.w	r12,r7[0x74]
80007e04:	80 00       	ld.sh	r0,r0[0x0]
80007e06:	65 9a       	ld.w	r10,r2[0x64]
80007e08:	80 00       	ld.sh	r0,r0[0x0]
80007e0a:	77 0c       	ld.w	r12,r11[0x40]
80007e0c:	80 00       	ld.sh	r0,r0[0x0]
80007e0e:	7a 00       	ld.w	r0,sp[0x0]
80007e10:	80 00       	ld.sh	r0,r0[0x0]
80007e12:	65 78       	ld.w	r8,r2[0x5c]
80007e14:	80 00       	ld.sh	r0,r0[0x0]
80007e16:	64 b4       	ld.w	r4,r2[0x2c]
80007e18:	80 00       	ld.sh	r0,r0[0x0]
80007e1a:	67 6c       	ld.w	r12,r3[0x58]
80007e1c:	80 00       	ld.sh	r0,r0[0x0]
80007e1e:	7b 60       	ld.w	r0,sp[0x58]
80007e20:	80 00       	ld.sh	r0,r0[0x0]
80007e22:	65 8e       	ld.w	lr,r2[0x60]
80007e24:	80 01       	ld.sh	r1,r0[0x0]
80007e26:	95 78       	st.w	r10[0x1c],r8

80007e28 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
80007e28:	eb cd 40 c0 	pushm	r6-r7,lr
80007e2c:	18 96       	mov	r6,r12
				res = dir_next(dp, 0);	/* Next entry */
			} while (res == FR_OK && --nent);
		}
	}
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
80007e2e:	30 1b       	mov	r11,1
80007e30:	f0 1f 00 0d 	mcall	80007e64 <dir_register+0x3c>
80007e34:	18 97       	mov	r7,r12
#endif

	if (res == FR_OK) {				/* Set SFN entry */
80007e36:	c1 41       	brne	80007e5e <dir_register+0x36>
		res = move_window(dp->fs, dp->sect);
80007e38:	6c 4b       	ld.w	r11,r6[0x10]
80007e3a:	6c 0c       	ld.w	r12,r6[0x0]
80007e3c:	f0 1f 00 0b 	mcall	80007e68 <dir_register+0x40>
80007e40:	18 97       	mov	r7,r12
		if (res == FR_OK) {
80007e42:	c0 e1       	brne	80007e5e <dir_register+0x36>
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
80007e44:	32 0a       	mov	r10,32
80007e46:	30 0b       	mov	r11,0
80007e48:	6c 5c       	ld.w	r12,r6[0x14]
80007e4a:	f0 1f 00 09 	mcall	80007e6c <dir_register+0x44>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
80007e4e:	30 ba       	mov	r10,11
80007e50:	6c 6b       	ld.w	r11,r6[0x18]
80007e52:	6c 5c       	ld.w	r12,r6[0x14]
80007e54:	f0 1f 00 07 	mcall	80007e70 <dir_register+0x48>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dp->fs->wflag = 1;
80007e58:	6c 08       	ld.w	r8,r6[0x0]
80007e5a:	30 19       	mov	r9,1
80007e5c:	b0 c9       	st.b	r8[0x4],r9
		}
	}

	return res;
}
80007e5e:	0e 9c       	mov	r12,r7
80007e60:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007e64:	80 00       	ld.sh	r0,r0[0x0]
80007e66:	7b 60       	ld.w	r0,sp[0x58]
80007e68:	80 00       	ld.sh	r0,r0[0x0]
80007e6a:	6f 00       	ld.w	r0,r7[0x40]
80007e6c:	80 00       	ld.sh	r0,r0[0x0]
80007e6e:	65 8e       	ld.w	lr,r2[0x60]
80007e70:	80 00       	ld.sh	r0,r0[0x0]
80007e72:	65 78       	ld.w	r8,r2[0x5c]

80007e74 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
80007e74:	d4 31       	pushm	r0-r7,lr
80007e76:	20 3d       	sub	sp,12
80007e78:	18 92       	mov	r2,r12
80007e7a:	16 97       	mov	r7,r11
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
80007e7c:	17 88       	ld.ub	r8,r11[0x0]
80007e7e:	32 f9       	mov	r9,47
80007e80:	f2 08 18 00 	cp.b	r8,r9
80007e84:	5f 09       	sreq	r9
80007e86:	35 ca       	mov	r10,92
80007e88:	f4 08 18 00 	cp.b	r8,r10
80007e8c:	5f 08       	sreq	r8
80007e8e:	f3 e8 10 08 	or	r8,r9,r8
		path++;
80007e92:	f7 b7 01 ff 	subne	r7,-1
	dp->sclust = 0;							/* Always start from the root directory */
80007e96:	30 08       	mov	r8,0
80007e98:	99 28       	st.w	r12[0x8],r8
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
80007e9a:	0f 89       	ld.ub	r9,r7[0x0]
80007e9c:	31 f8       	mov	r8,31
80007e9e:	f0 09 18 00 	cp.b	r9,r8
80007ea2:	e0 8b 00 08 	brhi	80007eb2 <follow_path+0x3e>
		res = dir_sdi(dp, 0);
80007ea6:	30 0b       	mov	r11,0
80007ea8:	f0 1f 00 93 	mcall	800080f4 <follow_path+0x280>
		dp->dir = 0;
80007eac:	30 08       	mov	r8,0
80007eae:	85 58       	st.w	r2[0x14],r8
80007eb0:	c1 49       	rjmp	800080d8 <follow_path+0x264>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Skip duplicated separator */
80007eb2:	32 f4       	mov	r4,47
80007eb4:	35 c3       	mov	r3,92
80007eb6:	30 06       	mov	r6,0
80007eb8:	0f 88       	ld.ub	r8,r7[0x0]
80007eba:	e8 08 18 00 	cp.b	r8,r4
80007ebe:	5f 09       	sreq	r9
80007ec0:	e6 08 18 00 	cp.b	r8,r3
80007ec4:	5f 08       	sreq	r8
80007ec6:	f3 e8 10 08 	or	r8,r9,r8
80007eca:	ec 08 18 00 	cp.b	r8,r6
80007ece:	c0 e0       	breq	80007eea <follow_path+0x76>
80007ed0:	2f f7       	sub	r7,-1
80007ed2:	0f 88       	ld.ub	r8,r7[0x0]
80007ed4:	e8 08 18 00 	cp.b	r8,r4
80007ed8:	5f 09       	sreq	r9
80007eda:	e6 08 18 00 	cp.b	r8,r3
80007ede:	5f 08       	sreq	r8
80007ee0:	f3 e8 10 08 	or	r8,r9,r8
80007ee4:	ec 08 18 00 	cp.b	r8,r6
80007ee8:	cf 41       	brne	80007ed0 <follow_path+0x5c>
	sfn = dp->fn;
80007eea:	64 6a       	ld.w	r10,r2[0x18]
80007eec:	50 2a       	stdsp	sp[0x8],r10
	mem_set(sfn, ' ', 11);
80007eee:	30 ba       	mov	r10,11
80007ef0:	32 0b       	mov	r11,32
80007ef2:	40 2c       	lddsp	r12,sp[0x8]
80007ef4:	f0 1f 00 81 	mcall	800080f8 <follow_path+0x284>
80007ef8:	30 89       	mov	r9,8
80007efa:	50 09       	stdsp	sp[0x0],r9
80007efc:	30 08       	mov	r8,0
80007efe:	50 18       	stdsp	sp[0x4],r8
80007f00:	10 90       	mov	r0,r8
80007f02:	10 91       	mov	r1,r8
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007f04:	0e 95       	mov	r5,r7
		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
80007f06:	ea 01 07 07 	ld.ub	r7,r5[r1]
80007f0a:	2f f1       	sub	r1,-1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
80007f0c:	32 09       	mov	r9,32
80007f0e:	f2 07 18 00 	cp.b	r7,r9
80007f12:	5f 88       	srls	r8
80007f14:	e8 07 18 00 	cp.b	r7,r4
80007f18:	5f 09       	sreq	r9
80007f1a:	f1 e9 10 09 	or	r9,r8,r9
80007f1e:	ec 09 18 00 	cp.b	r9,r6
80007f22:	c7 51       	brne	8000800c <follow_path+0x198>
80007f24:	e6 07 18 00 	cp.b	r7,r3
80007f28:	c7 20       	breq	8000800c <follow_path+0x198>
		if (c == '.' || i >= ni) {
80007f2a:	32 e8       	mov	r8,46
80007f2c:	f0 07 18 00 	cp.b	r7,r8
80007f30:	5f 09       	sreq	r9
80007f32:	40 0a       	lddsp	r10,sp[0x0]
80007f34:	14 30       	cp.w	r0,r10
80007f36:	5f 28       	srhs	r8
80007f38:	f3 e8 10 08 	or	r8,r9,r8
80007f3c:	ec 08 18 00 	cp.b	r8,r6
80007f40:	c1 50       	breq	80007f6a <follow_path+0xf6>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
80007f42:	58 8a       	cp.w	r10,8
80007f44:	5f 19       	srne	r9
80007f46:	32 e8       	mov	r8,46
80007f48:	f0 07 18 00 	cp.b	r7,r8
80007f4c:	5f 18       	srne	r8
80007f4e:	f3 e8 10 08 	or	r8,r9,r8
80007f52:	ec 08 18 00 	cp.b	r8,r6
80007f56:	e0 81 00 be 	brne	800080d2 <follow_path+0x25e>
			i = 8; ni = 11;
			b <<= 2; continue;
80007f5a:	40 18       	lddsp	r8,sp[0x4]
80007f5c:	a3 68       	lsl	r8,0x2
80007f5e:	5c 58       	castu.b	r8
80007f60:	50 18       	stdsp	sp[0x4],r8
80007f62:	30 ba       	mov	r10,11
80007f64:	50 0a       	stdsp	sp[0x0],r10
80007f66:	30 80       	mov	r0,8
80007f68:	cc fb       	rjmp	80007f06 <follow_path+0x92>
		}
		if (c >= 0x80) {				/* Extended character? */
80007f6a:	ec 07 18 00 	cp.b	r7,r6
80007f6e:	c0 54       	brge	80007f78 <follow_path+0x104>
			b |= 3;						/* Eliminate NT flag */
80007f70:	40 18       	lddsp	r8,sp[0x4]
80007f72:	e8 18 00 03 	orl	r8,0x3
80007f76:	50 18       	stdsp	sp[0x4],r8
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
80007f78:	0e 98       	mov	r8,r7
80007f7a:	28 18       	sub	r8,-127
80007f7c:	37 da       	mov	r10,125
80007f7e:	f4 08 18 00 	cp.b	r8,r10
80007f82:	e0 8b 00 23 	brhi	80007fc8 <follow_path+0x154>
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007f86:	ea 01 07 08 	ld.ub	r8,r5[r1]
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
80007f8a:	f0 c9 00 40 	sub	r9,r8,64
80007f8e:	33 ea       	mov	r10,62
80007f90:	f4 09 18 00 	cp.b	r9,r10
80007f94:	5f b9       	srhi	r9
80007f96:	f0 cb 00 80 	sub	r11,r8,128
80007f9a:	37 ea       	mov	r10,126
80007f9c:	f4 0b 18 00 	cp.b	r11,r10
80007fa0:	5f ba       	srhi	r10
80007fa2:	14 69       	and	r9,r10
80007fa4:	ec 09 18 00 	cp.b	r9,r6
80007fa8:	e0 81 00 95 	brne	800080d2 <follow_path+0x25e>
80007fac:	40 09       	lddsp	r9,sp[0x0]
80007fae:	20 19       	sub	r9,1
80007fb0:	12 30       	cp.w	r0,r9
80007fb2:	e0 82 00 90 	brhs	800080d2 <follow_path+0x25e>
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
80007fb6:	2f f1       	sub	r1,-1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
80007fb8:	40 29       	lddsp	r9,sp[0x8]
80007fba:	f2 00 0b 07 	st.b	r9[r0],r7
80007fbe:	2f f0       	sub	r0,-1
			sfn[i++] = d;
80007fc0:	f2 00 0b 08 	st.b	r9[r0],r8
80007fc4:	2f f0       	sub	r0,-1
80007fc6:	ca 0b       	rjmp	80007f06 <follow_path+0x92>
		} else {						/* SBC */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
80007fc8:	0e 9b       	mov	r11,r7
80007fca:	4c dc       	lddpc	r12,800080fc <follow_path+0x288>
80007fcc:	f0 1f 00 4d 	mcall	80008100 <follow_path+0x28c>
80007fd0:	e0 81 00 81 	brne	800080d2 <follow_path+0x25e>
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
80007fd4:	0e 98       	mov	r8,r7
80007fd6:	24 18       	sub	r8,65
80007fd8:	31 99       	mov	r9,25
80007fda:	f2 08 18 00 	cp.b	r8,r9
80007fde:	e0 8b 00 06 	brhi	80007fea <follow_path+0x176>
				b |= 2;
80007fe2:	40 18       	lddsp	r8,sp[0x4]
80007fe4:	a1 b8       	sbr	r8,0x1
80007fe6:	50 18       	stdsp	sp[0x4],r8
80007fe8:	c0 d8       	rjmp	80008002 <follow_path+0x18e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
80007fea:	0e 98       	mov	r8,r7
80007fec:	26 18       	sub	r8,97
80007fee:	31 9a       	mov	r10,25
80007ff0:	f4 08 18 00 	cp.b	r8,r10
80007ff4:	e0 8b 00 07 	brhi	80008002 <follow_path+0x18e>
					b |= 1; c -= 0x20;
80007ff8:	40 19       	lddsp	r9,sp[0x4]
80007ffa:	a1 a9       	sbr	r9,0x0
80007ffc:	50 19       	stdsp	sp[0x4],r9
80007ffe:	22 07       	sub	r7,32
80008000:	5c 57       	castu.b	r7
				}
			}
			sfn[i++] = c;
80008002:	40 28       	lddsp	r8,sp[0x8]
80008004:	f0 00 0b 07 	st.b	r8[r0],r7
80008008:	2f f0       	sub	r0,-1
8000800a:	c7 eb       	rjmp	80007f06 <follow_path+0x92>
8000800c:	0a 97       	mov	r7,r5
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
8000800e:	58 08       	cp.w	r8,0
80008010:	f9 b8 01 04 	movne	r8,4
80008014:	f9 b8 00 00 	moveq	r8,0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
80008018:	58 00       	cp.w	r0,0
8000801a:	c5 c0       	breq	800080d2 <follow_path+0x25e>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
8000801c:	40 29       	lddsp	r9,sp[0x8]
8000801e:	13 8a       	ld.ub	r10,r9[0x0]
80008020:	3e 59       	mov	r9,-27
80008022:	f2 0a 18 00 	cp.b	r10,r9
80008026:	f9 b9 00 05 	moveq	r9,5
8000802a:	fb fa 00 02 	ld.weq	r10,sp[0x8]
8000802e:	f5 f9 0e 00 	st.beq	r10[0x0],r9

	if (ni == 8) b <<= 2;
80008032:	40 09       	lddsp	r9,sp[0x0]
80008034:	58 89       	cp.w	r9,8
80008036:	c0 51       	brne	80008040 <follow_path+0x1cc>
80008038:	40 19       	lddsp	r9,sp[0x4]
8000803a:	a3 69       	lsl	r9,0x2
8000803c:	5c 59       	castu.b	r9
8000803e:	50 19       	stdsp	sp[0x4],r9
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
80008040:	40 19       	lddsp	r9,sp[0x4]
80008042:	f5 d9 c0 02 	bfextu	r10,r9,0x0,0x2
80008046:	58 1a       	cp.w	r10,1
80008048:	c0 21       	brne	8000804c <follow_path+0x1d8>
8000804a:	a5 a8       	sbr	r8,0x4
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
8000804c:	e2 19 00 0c 	andl	r9,0xc,COH
80008050:	58 49       	cp.w	r9,4
80008052:	c0 21       	brne	80008056 <follow_path+0x1e2>
80008054:	a3 b8       	sbr	r8,0x3

	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
80008056:	40 2a       	lddsp	r10,sp[0x8]
80008058:	f5 68 00 0b 	st.b	r10[11],r8
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
8000805c:	30 0b       	mov	r11,0
8000805e:	04 9c       	mov	r12,r2
80008060:	f0 1f 00 25 	mcall	800080f4 <follow_path+0x280>
	if (res != FR_OK) return res;
80008064:	c2 11       	brne	800080a6 <follow_path+0x232>

#if _USE_LFN
	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
#endif
	do {
		res = move_window(dp->fs, dp->sect);
80008066:	64 4b       	ld.w	r11,r2[0x10]
80008068:	64 0c       	ld.w	r12,r2[0x0]
8000806a:	f0 1f 00 27 	mcall	80008104 <follow_path+0x290>
		if (res != FR_OK) break;
8000806e:	c1 c1       	brne	800080a6 <follow_path+0x232>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
80008070:	64 59       	ld.w	r9,r2[0x14]
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
80008072:	13 88       	ld.ub	r8,r9[0x0]
80008074:	ec 08 18 00 	cp.b	r8,r6
80008078:	c3 90       	breq	800080ea <follow_path+0x276>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
8000807a:	f3 38 00 0b 	ld.ub	r8,r9[11]
8000807e:	e2 18 00 08 	andl	r8,0x8,COH
80008082:	c0 d1       	brne	8000809c <follow_path+0x228>
80008084:	64 65       	ld.w	r5,r2[0x18]
80008086:	c0 48       	rjmp	8000808e <follow_path+0x21a>
80008088:	2f f8       	sub	r8,-1
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
8000808a:	58 b8       	cp.w	r8,11
8000808c:	c2 80       	breq	800080dc <follow_path+0x268>
8000808e:	f2 08 07 0b 	ld.ub	r11,r9[r8]
80008092:	ea 08 07 0a 	ld.ub	r10,r5[r8]
80008096:	f4 0b 18 00 	cp.b	r11,r10
8000809a:	cf 70       	breq	80008088 <follow_path+0x214>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
8000809c:	30 0b       	mov	r11,0
8000809e:	04 9c       	mov	r12,r2
800080a0:	f0 1f 00 1a 	mcall	80008108 <follow_path+0x294>
	} while (res == FR_OK);
800080a4:	ce 10       	breq	80008066 <follow_path+0x1f2>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
800080a6:	64 68       	ld.w	r8,r2[0x18]
800080a8:	f1 38 00 0b 	ld.ub	r8,r8[11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
800080ac:	58 4c       	cp.w	r12,4
800080ae:	c1 51       	brne	800080d8 <follow_path+0x264>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
800080b0:	e2 18 00 04 	andl	r8,0x4,COH
800080b4:	c1 10       	breq	800080d6 <follow_path+0x262>
800080b6:	30 4c       	mov	r12,4
800080b8:	c1 08       	rjmp	800080d8 <follow_path+0x264>
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
800080ba:	64 5b       	ld.w	r11,r2[0x14]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
800080bc:	f7 38 00 0b 	ld.ub	r8,r11[11]
800080c0:	e2 18 00 10 	andl	r8,0x10,COH
800080c4:	c0 90       	breq	800080d6 <follow_path+0x262>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
800080c6:	02 07       	add	r7,r1
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
800080c8:	64 0c       	ld.w	r12,r2[0x0]
800080ca:	f0 1f 00 11 	mcall	8000810c <follow_path+0x298>
800080ce:	85 2c       	st.w	r2[0x8],r12
		}
800080d0:	cf 4a       	rjmp	80007eb8 <follow_path+0x44>
800080d2:	30 6c       	mov	r12,6
800080d4:	c0 28       	rjmp	800080d8 <follow_path+0x264>
800080d6:	30 5c       	mov	r12,5
	}

	return res;
}
800080d8:	2f dd       	sub	sp,-12
800080da:	d8 32       	popm	r0-r7,pc
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NSFLAG];
800080dc:	64 68       	ld.w	r8,r2[0x18]
800080de:	f1 38 00 0b 	ld.ub	r8,r8[11]
800080e2:	e2 18 00 04 	andl	r8,0x4,COH
800080e6:	ce a0       	breq	800080ba <follow_path+0x246>
800080e8:	cf 8b       	rjmp	800080d8 <follow_path+0x264>
800080ea:	64 68       	ld.w	r8,r2[0x18]
800080ec:	f1 38 00 0b 	ld.ub	r8,r8[11]
800080f0:	ce 0b       	rjmp	800080b0 <follow_path+0x23c>
800080f2:	00 00       	add	r0,r0
800080f4:	80 00       	ld.sh	r0,r0[0x0]
800080f6:	77 0c       	ld.w	r12,r11[0x40]
800080f8:	80 00       	ld.sh	r0,r0[0x0]
800080fa:	65 8e       	ld.w	lr,r2[0x60]
800080fc:	80 01       	ld.sh	r1,r0[0x0]
800080fe:	95 88       	st.w	r10[0x20],r8
80008100:	80 00       	ld.sh	r0,r0[0x0]
80008102:	65 9a       	ld.w	r10,r2[0x64]
80008104:	80 00       	ld.sh	r0,r0[0x0]
80008106:	6f 00       	ld.w	r0,r7[0x40]
80008108:	80 00       	ld.sh	r0,r0[0x0]
8000810a:	78 90       	ld.w	r0,r12[0x24]
8000810c:	80 00       	ld.sh	r0,r0[0x0]
8000810e:	66 0a       	ld.w	r10,r3[0x0]

80008110 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
80008110:	eb cd 40 80 	pushm	r7,lr
80008114:	20 5d       	sub	sp,20
80008116:	18 97       	mov	r7,r12
80008118:	50 0b       	stdsp	sp[0x0],r11
	FRESULT res;
	FATFS* fs;
	DEFINE_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
8000811a:	58 0c       	cp.w	r12,0
8000811c:	c0 31       	brne	80008122 <f_opendir+0x12>
8000811e:	30 9c       	mov	r12,9
80008120:	c2 d8       	rjmp	8000817a <f_opendir+0x6a>

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
80008122:	30 0a       	mov	r10,0
80008124:	1a 9b       	mov	r11,sp
80008126:	fa cc ff f0 	sub	r12,sp,-16
8000812a:	f0 1f 00 17 	mcall	80008184 <f_opendir+0x74>
	if (res == FR_OK) {
8000812e:	c2 41       	brne	80008176 <f_opendir+0x66>
		dp->fs = fs;
80008130:	40 48       	lddsp	r8,sp[0x10]
80008132:	8f 08       	st.w	r7[0x0],r8
		INIT_BUF(*dp);
80008134:	fa c8 ff fc 	sub	r8,sp,-4
80008138:	8f 68       	st.w	r7[0x18],r8
		res = follow_path(dp, path);			/* Follow the path to the directory */
8000813a:	40 0b       	lddsp	r11,sp[0x0]
8000813c:	0e 9c       	mov	r12,r7
8000813e:	f0 1f 00 13 	mcall	80008188 <f_opendir+0x78>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
80008142:	c1 61       	brne	8000816e <f_opendir+0x5e>
			if (dp->dir) {						/* It is not the origin directory itself */
80008144:	6e 5b       	ld.w	r11,r7[0x14]
80008146:	58 0b       	cp.w	r11,0
80008148:	c0 c0       	breq	80008160 <f_opendir+0x50>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
8000814a:	f7 38 00 0b 	ld.ub	r8,r11[11]
8000814e:	e2 18 00 10 	andl	r8,0x10,COH
80008152:	c0 31       	brne	80008158 <f_opendir+0x48>
80008154:	30 5c       	mov	r12,5
80008156:	c0 e8       	rjmp	80008172 <f_opendir+0x62>
					dp->sclust = ld_clust(fs, dp->dir);
80008158:	40 4c       	lddsp	r12,sp[0x10]
8000815a:	f0 1f 00 0d 	mcall	8000818c <f_opendir+0x7c>
8000815e:	8f 2c       	st.w	r7[0x8],r12
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
80008160:	40 48       	lddsp	r8,sp[0x10]
80008162:	90 38       	ld.sh	r8,r8[0x6]
80008164:	ae 28       	st.h	r7[0x4],r8
				res = dir_sdi(dp, 0);			/* Rewind directory */
80008166:	30 0b       	mov	r11,0
80008168:	0e 9c       	mov	r12,r7
8000816a:	f0 1f 00 0a 	mcall	80008190 <f_opendir+0x80>
					}
				}
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
8000816e:	58 4c       	cp.w	r12,4
80008170:	c0 80       	breq	80008180 <f_opendir+0x70>
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80008172:	58 0c       	cp.w	r12,0
80008174:	c0 30       	breq	8000817a <f_opendir+0x6a>
80008176:	30 08       	mov	r8,0
80008178:	8f 08       	st.w	r7[0x0],r8

	LEAVE_FF(fs, res);
}
8000817a:	2f bd       	sub	sp,-20
8000817c:	e3 cd 80 80 	ldm	sp++,r7,pc
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
80008180:	30 5c       	mov	r12,5
80008182:	cf ab       	rjmp	80008176 <f_opendir+0x66>
80008184:	80 00       	ld.sh	r0,r0[0x0]
80008186:	6f dc       	ld.w	r12,r7[0x74]
80008188:	80 00       	ld.sh	r0,r0[0x0]
8000818a:	7e 74       	ld.w	r4,pc[0x1c]
8000818c:	80 00       	ld.sh	r0,r0[0x0]
8000818e:	66 0a       	ld.w	r10,r3[0x0]
80008190:	80 00       	ld.sh	r0,r0[0x0]
80008192:	77 0c       	ld.w	r12,r11[0x40]

80008194 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
80008194:	d4 31       	pushm	r0-r7,lr
80008196:	21 0d       	sub	sp,64
80008198:	50 4c       	stdsp	sp[0x10],r12
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
8000819a:	f0 1f 00 61 	mcall	8000831c <f_mkdir+0x188>
8000819e:	18 95       	mov	r5,r12
	DEFINE_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
800081a0:	30 1a       	mov	r10,1
800081a2:	fa cb ff f0 	sub	r11,sp,-16
800081a6:	fa cc ff e0 	sub	r12,sp,-32
800081aa:	f0 1f 00 5e 	mcall	80008320 <f_mkdir+0x18c>
800081ae:	18 97       	mov	r7,r12
	if (res == FR_OK) {
800081b0:	c0 30       	breq	800081b6 <f_mkdir+0x22>
800081b2:	18 96       	mov	r6,r12
800081b4:	ca 78       	rjmp	80008302 <f_mkdir+0x16e>
		INIT_BUF(dj);
800081b6:	fa c8 ff ec 	sub	r8,sp,-20
800081ba:	50 e8       	stdsp	sp[0x38],r8
		res = follow_path(&dj, path);			/* Follow the file path */
800081bc:	40 4b       	lddsp	r11,sp[0x10]
800081be:	fa cc ff e0 	sub	r12,sp,-32
800081c2:	f0 1f 00 59 	mcall	80008324 <f_mkdir+0x190>
800081c6:	18 96       	mov	r6,r12
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
800081c8:	c0 31       	brne	800081ce <f_mkdir+0x3a>
800081ca:	30 86       	mov	r6,8
800081cc:	c9 b8       	rjmp	80008302 <f_mkdir+0x16e>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
800081ce:	58 4c       	cp.w	r12,4
800081d0:	e0 81 00 99 	brne	80008302 <f_mkdir+0x16e>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
800081d4:	30 0b       	mov	r11,0
800081d6:	40 8c       	lddsp	r12,sp[0x20]
800081d8:	f0 1f 00 54 	mcall	80008328 <f_mkdir+0x194>
800081dc:	18 92       	mov	r2,r12
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
800081de:	c0 31       	brne	800081e4 <f_mkdir+0x50>
800081e0:	30 77       	mov	r7,7
800081e2:	c0 88       	rjmp	800081f2 <f_mkdir+0x5e>
			if (dcl == 1) res = FR_INT_ERR;
800081e4:	58 1c       	cp.w	r12,1
800081e6:	c0 31       	brne	800081ec <f_mkdir+0x58>
800081e8:	30 27       	mov	r7,2
800081ea:	c6 c8       	rjmp	800082c2 <f_mkdir+0x12e>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
800081ec:	5b fc       	cp.w	r12,-1
800081ee:	e0 80 00 8d 	breq	80008308 <f_mkdir+0x174>
			if (res == FR_OK)					/* Flush FAT */
800081f2:	58 07       	cp.w	r7,0
800081f4:	c6 71       	brne	800082c2 <f_mkdir+0x12e>
				res = sync_window(dj.fs);
800081f6:	40 8c       	lddsp	r12,sp[0x20]
800081f8:	f0 1f 00 4d 	mcall	8000832c <f_mkdir+0x198>
800081fc:	18 97       	mov	r7,r12
			if (res == FR_OK) {					/* Initialize the new directory table */
800081fe:	c6 21       	brne	800082c2 <f_mkdir+0x12e>
				dsc = clust2sect(dj.fs, dcl);
80008200:	40 87       	lddsp	r7,sp[0x20]
80008202:	04 9b       	mov	r11,r2
80008204:	0e 9c       	mov	r12,r7
80008206:	f0 1f 00 4b 	mcall	80008330 <f_mkdir+0x19c>
8000820a:	18 94       	mov	r4,r12
				dir = dj.fs->win;
8000820c:	ee c3 ff d0 	sub	r3,r7,-48
				mem_set(dir, 0, SS(dj.fs));
80008210:	e0 6a 02 00 	mov	r10,512
80008214:	30 0b       	mov	r11,0
80008216:	06 9c       	mov	r12,r3
80008218:	f0 1f 00 47 	mcall	80008334 <f_mkdir+0x1a0>
				mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
8000821c:	30 ba       	mov	r10,11
8000821e:	32 0b       	mov	r11,32
80008220:	06 9c       	mov	r12,r3
80008222:	f0 1f 00 45 	mcall	80008334 <f_mkdir+0x1a0>
				dir[DIR_Name] = '.';
80008226:	32 e6       	mov	r6,46
80008228:	ef 66 00 30 	st.b	r7[48],r6
				dir[DIR_Attr] = AM_DIR;
8000822c:	31 08       	mov	r8,16
8000822e:	e7 68 00 0b 	st.b	r3[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);
80008232:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80008236:	50 38       	stdsp	sp[0xc],r8
80008238:	e7 68 00 16 	st.b	r3[22],r8
8000823c:	f1 d5 c1 08 	bfextu	r8,r5,0x8,0x8
80008240:	50 28       	stdsp	sp[0x8],r8
80008242:	e7 68 00 17 	st.b	r3[23],r8
80008246:	f1 d5 c2 08 	bfextu	r8,r5,0x10,0x8
8000824a:	50 18       	stdsp	sp[0x4],r8
8000824c:	e7 68 00 18 	st.b	r3[24],r8
80008250:	b9 85       	lsr	r5,0x18
80008252:	50 05       	stdsp	sp[0x0],r5
80008254:	e7 65 00 19 	st.b	r3[25],r5
				st_clust(dir, dcl);
80008258:	04 9b       	mov	r11,r2
8000825a:	06 9c       	mov	r12,r3
8000825c:	f0 1f 00 37 	mcall	80008338 <f_mkdir+0x1a4>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
80008260:	2b 07       	sub	r7,-80
80008262:	32 0a       	mov	r10,32
80008264:	06 9b       	mov	r11,r3
80008266:	0e 9c       	mov	r12,r7
80008268:	f0 1f 00 35 	mcall	8000833c <f_mkdir+0x1a8>
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
8000826c:	e7 66 00 21 	st.b	r3[33],r6
80008270:	40 ab       	lddsp	r11,sp[0x28]
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
80008272:	40 88       	lddsp	r8,sp[0x20]
80008274:	11 8a       	ld.ub	r10,r8[0x0]
80008276:	30 39       	mov	r9,3
80008278:	f2 0a 18 00 	cp.b	r10,r9
8000827c:	c0 51       	brne	80008286 <f_mkdir+0xf2>
8000827e:	70 98       	ld.w	r8,r8[0x24]
80008280:	16 38       	cp.w	r8,r11
80008282:	f9 bb 00 00 	moveq	r11,0
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
80008286:	0e 9c       	mov	r12,r7
80008288:	f0 1f 00 2c 	mcall	80008338 <f_mkdir+0x1a4>
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
8000828c:	40 88       	lddsp	r8,sp[0x20]
8000828e:	11 a6       	ld.ub	r6,r8[0x2]
80008290:	58 06       	cp.w	r6,0
80008292:	c3 d0       	breq	8000830c <f_mkdir+0x178>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
80008294:	30 15       	mov	r5,1
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
80008296:	e0 61 02 00 	mov	r1,512
8000829a:	30 00       	mov	r0,0
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
8000829c:	40 88       	lddsp	r8,sp[0x20]
8000829e:	91 b4       	st.w	r8[0x2c],r4
800082a0:	2f f4       	sub	r4,-1
					dj.fs->wflag = 1;
800082a2:	40 88       	lddsp	r8,sp[0x20]
800082a4:	b0 c5       	st.b	r8[0x4],r5
					res = sync_window(dj.fs);
800082a6:	40 8c       	lddsp	r12,sp[0x20]
800082a8:	f0 1f 00 21 	mcall	8000832c <f_mkdir+0x198>
					if (res != FR_OK) break;
800082ac:	c0 a1       	brne	800082c0 <f_mkdir+0x12c>
					mem_set(dir, 0, SS(dj.fs));
800082ae:	02 9a       	mov	r10,r1
800082b0:	00 9b       	mov	r11,r0
800082b2:	06 9c       	mov	r12,r3
800082b4:	f0 1f 00 20 	mcall	80008334 <f_mkdir+0x1a0>
				mem_cpy(dir + SZ_DIRE, dir, SZ_DIRE); 	/* Create ".." entry */
				dir[SZ_DIRE + 1] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				st_clust(dir + SZ_DIRE, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
800082b8:	20 16       	sub	r6,1
800082ba:	5c 56       	castu.b	r6
800082bc:	cf 01       	brne	8000829c <f_mkdir+0x108>
800082be:	c2 78       	rjmp	8000830c <f_mkdir+0x178>
800082c0:	18 97       	mov	r7,r12
800082c2:	0e 96       	mov	r6,r7
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
800082c4:	04 9b       	mov	r11,r2
800082c6:	40 8c       	lddsp	r12,sp[0x20]
800082c8:	f0 1f 00 1e 	mcall	80008340 <f_mkdir+0x1ac>
800082cc:	c1 b8       	rjmp	80008302 <f_mkdir+0x16e>
			} else {
				dir = dj.dir;
800082ce:	40 dc       	lddsp	r12,sp[0x34]
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
800082d0:	31 08       	mov	r8,16
800082d2:	f9 68 00 0b 	st.b	r12[11],r8
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
800082d6:	40 38       	lddsp	r8,sp[0xc]
800082d8:	f9 68 00 16 	st.b	r12[22],r8
800082dc:	40 28       	lddsp	r8,sp[0x8]
800082de:	f9 68 00 17 	st.b	r12[23],r8
800082e2:	40 18       	lddsp	r8,sp[0x4]
800082e4:	f9 68 00 18 	st.b	r12[24],r8
800082e8:	40 08       	lddsp	r8,sp[0x0]
800082ea:	f9 68 00 19 	st.b	r12[25],r8
				st_clust(dir, dcl);					/* Table start cluster */
800082ee:	04 9b       	mov	r11,r2
800082f0:	f0 1f 00 12 	mcall	80008338 <f_mkdir+0x1a4>
				dj.fs->wflag = 1;
800082f4:	30 19       	mov	r9,1
800082f6:	40 88       	lddsp	r8,sp[0x20]
800082f8:	b0 c9       	st.b	r8[0x4],r9
				res = sync_fs(dj.fs);
800082fa:	40 8c       	lddsp	r12,sp[0x20]
800082fc:	f0 1f 00 12 	mcall	80008344 <f_mkdir+0x1b0>
80008300:	18 96       	mov	r6,r12
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
80008302:	0c 9c       	mov	r12,r6
80008304:	2f 0d       	sub	sp,-64
80008306:	d8 32       	popm	r0-r7,pc
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir + DIR_WrtTime, tm);	/* Created time */
				st_clust(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
				res = sync_fs(dj.fs);
80008308:	30 17       	mov	r7,1
8000830a:	cd cb       	rjmp	800082c2 <f_mkdir+0x12e>
					res = sync_window(dj.fs);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
8000830c:	fa cc ff e0 	sub	r12,sp,-32
80008310:	f0 1f 00 0e 	mcall	80008348 <f_mkdir+0x1b4>
80008314:	18 96       	mov	r6,r12
			if (res != FR_OK) {
80008316:	cd c0       	breq	800082ce <f_mkdir+0x13a>
80008318:	cd 6b       	rjmp	800082c4 <f_mkdir+0x130>
8000831a:	00 00       	add	r0,r0
8000831c:	80 00       	ld.sh	r0,r0[0x0]
8000831e:	64 b4       	ld.w	r4,r2[0x2c]
80008320:	80 00       	ld.sh	r0,r0[0x0]
80008322:	6f dc       	ld.w	r12,r7[0x74]
80008324:	80 00       	ld.sh	r0,r0[0x0]
80008326:	7e 74       	ld.w	r4,pc[0x1c]
80008328:	80 00       	ld.sh	r0,r0[0x0]
8000832a:	77 c0       	ld.w	r0,r11[0x70]
8000832c:	80 00       	ld.sh	r0,r0[0x0]
8000832e:	67 08       	ld.w	r8,r3[0x40]
80008330:	80 00       	ld.sh	r0,r0[0x0]
80008332:	65 b4       	ld.w	r4,r2[0x6c]
80008334:	80 00       	ld.sh	r0,r0[0x0]
80008336:	65 8e       	ld.w	lr,r2[0x60]
80008338:	80 00       	ld.sh	r0,r0[0x0]
8000833a:	66 32       	ld.w	r2,r3[0xc]
8000833c:	80 00       	ld.sh	r0,r0[0x0]
8000833e:	65 78       	ld.w	r8,r2[0x5c]
80008340:	80 00       	ld.sh	r0,r0[0x0]
80008342:	79 a0       	ld.w	r0,r12[0x68]
80008344:	80 00       	ld.sh	r0,r0[0x0]
80008346:	67 6c       	ld.w	r12,r3[0x58]
80008348:	80 00       	ld.sh	r0,r0[0x0]
8000834a:	7e 28       	ld.w	r8,pc[0x8]

8000834c <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
8000834c:	eb cd 40 fc 	pushm	r2-r7,lr
80008350:	20 cd       	sub	sp,48
80008352:	18 97       	mov	r7,r12
80008354:	50 0b       	stdsp	sp[0x0],r11
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
80008356:	58 0c       	cp.w	r12,0
80008358:	c0 31       	brne	8000835e <f_open+0x12>
8000835a:	30 96       	mov	r6,9
8000835c:	cb 68       	rjmp	800084c8 <f_open+0x17c>
	fp->fs = 0;			/* Clear file object */
8000835e:	30 08       	mov	r8,0
80008360:	99 08       	st.w	r12[0x0],r8

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
80008362:	eb da c0 05 	bfextu	r5,r10,0x0,0x5
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
80008366:	0a 93       	mov	r3,r5
80008368:	e2 1a 00 1e 	andl	r10,0x1e,COH
8000836c:	1a 9b       	mov	r11,sp
8000836e:	fa cc ff f0 	sub	r12,sp,-16
80008372:	f0 1f 00 5c 	mcall	800084e0 <f_open+0x194>
80008376:	18 96       	mov	r6,r12
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
80008378:	e0 81 00 a8 	brne	800084c8 <f_open+0x17c>
		INIT_BUF(dj);
8000837c:	fa c8 ff fc 	sub	r8,sp,-4
80008380:	50 a8       	stdsp	sp[0x28],r8
		res = follow_path(&dj, path);	/* Follow the file path */
80008382:	40 0b       	lddsp	r11,sp[0x0]
80008384:	fa cc ff f0 	sub	r12,sp,-16
80008388:	f0 1f 00 57 	mcall	800084e4 <f_open+0x198>
		dir = dj.dir;
8000838c:	40 94       	lddsp	r4,sp[0x24]
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
8000838e:	c0 41       	brne	80008396 <f_open+0x4a>
			if (!dir)	/* Default directory itself */
80008390:	58 04       	cp.w	r4,0
80008392:	f9 bc 00 06 	moveq	r12,6
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
80008396:	06 98       	mov	r8,r3
80008398:	e2 18 00 1c 	andl	r8,0x1c,COH
8000839c:	c5 f0       	breq	8000845a <f_open+0x10e>
			if (res != FR_OK) {					/* No file, create new */
8000839e:	58 0c       	cp.w	r12,0
800083a0:	c0 d0       	breq	800083ba <f_open+0x6e>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
800083a2:	58 4c       	cp.w	r12,4
800083a4:	e0 81 00 91 	brne	800084c6 <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
800083a8:	fa cc ff f0 	sub	r12,sp,-16
800083ac:	f0 1f 00 4f 	mcall	800084e8 <f_open+0x19c>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
800083b0:	40 94       	lddsp	r4,sp[0x24]
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
800083b2:	e0 81 00 8a 	brne	800084c6 <f_open+0x17a>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
800083b6:	a3 b5       	sbr	r5,0x3
800083b8:	c0 c8       	rjmp	800083d0 <f_open+0x84>
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
800083ba:	e9 38 00 0b 	ld.ub	r8,r4[11]
800083be:	e2 18 00 11 	andl	r8,0x11,COH
800083c2:	c0 30       	breq	800083c8 <f_open+0x7c>
800083c4:	30 7c       	mov	r12,7
800083c6:	c8 08       	rjmp	800084c6 <f_open+0x17a>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
800083c8:	e2 13 00 04 	andl	r3,0x4,COH
800083cc:	e0 81 00 82 	brne	800084d0 <f_open+0x184>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
800083d0:	0a 98       	mov	r8,r5
800083d2:	e2 18 00 08 	andl	r8,0x8,COH
800083d6:	c7 f0       	breq	800084d4 <f_open+0x188>
				dw = GET_FATTIME();
800083d8:	f0 1f 00 45 	mcall	800084ec <f_open+0x1a0>
				ST_DWORD(dir + DIR_CrtTime, dw);/* Set created time */
800083dc:	f5 dc c0 08 	bfextu	r10,r12,0x0,0x8
800083e0:	e9 6a 00 0e 	st.b	r4[14],r10
800083e4:	f3 dc c1 08 	bfextu	r9,r12,0x8,0x8
800083e8:	e9 69 00 0f 	st.b	r4[15],r9
800083ec:	f1 dc c2 08 	bfextu	r8,r12,0x10,0x8
800083f0:	e9 68 00 10 	st.b	r4[16],r8
800083f4:	b9 8c       	lsr	r12,0x18
800083f6:	e9 6c 00 11 	st.b	r4[17],r12
				ST_DWORD(dir + DIR_WrtTime, dw);/* Set modified time */
800083fa:	e9 6a 00 16 	st.b	r4[22],r10
800083fe:	e9 69 00 17 	st.b	r4[23],r9
80008402:	e9 68 00 18 	st.b	r4[24],r8
80008406:	e9 6c 00 19 	st.b	r4[25],r12
				dir[DIR_Attr] = 0;				/* Reset attribute */
8000840a:	30 08       	mov	r8,0
8000840c:	e9 68 00 0b 	st.b	r4[11],r8
				ST_DWORD(dir + DIR_FileSize, 0);/* Reset file size */
80008410:	e9 68 00 1c 	st.b	r4[28],r8
80008414:	e9 68 00 1d 	st.b	r4[29],r8
80008418:	e9 68 00 1e 	st.b	r4[30],r8
8000841c:	e9 68 00 1f 	st.b	r4[31],r8
				cl = ld_clust(dj.fs, dir);		/* Get cluster chain */
80008420:	08 9b       	mov	r11,r4
80008422:	40 4c       	lddsp	r12,sp[0x10]
80008424:	f0 1f 00 33 	mcall	800084f0 <f_open+0x1a4>
80008428:	18 93       	mov	r3,r12
				st_clust(dir, 0);				/* Reset cluster */
8000842a:	30 0b       	mov	r11,0
8000842c:	08 9c       	mov	r12,r4
8000842e:	f0 1f 00 32 	mcall	800084f4 <f_open+0x1a8>
				dj.fs->wflag = 1;
80008432:	30 19       	mov	r9,1
80008434:	40 48       	lddsp	r8,sp[0x10]
80008436:	b0 c9       	st.b	r8[0x4],r9
				if (cl) {						/* Remove the cluster chain if exist */
80008438:	58 03       	cp.w	r3,0
8000843a:	c4 d0       	breq	800084d4 <f_open+0x188>
					dw = dj.fs->winsect;
8000843c:	40 4c       	lddsp	r12,sp[0x10]
8000843e:	78 b2       	ld.w	r2,r12[0x2c]
					res = remove_chain(dj.fs, cl);
80008440:	06 9b       	mov	r11,r3
80008442:	f0 1f 00 2e 	mcall	800084f8 <f_open+0x1ac>
					if (res == FR_OK) {
80008446:	c4 01       	brne	800084c6 <f_open+0x17a>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
80008448:	20 13       	sub	r3,1
8000844a:	40 48       	lddsp	r8,sp[0x10]
8000844c:	91 33       	st.w	r8[0xc],r3
						res = move_window(dj.fs, dw);
8000844e:	04 9b       	mov	r11,r2
80008450:	40 4c       	lddsp	r12,sp[0x10]
80008452:	f0 1f 00 2b 	mcall	800084fc <f_open+0x1b0>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
80008456:	c1 40       	breq	8000847e <f_open+0x132>
80008458:	c3 78       	rjmp	800084c6 <f_open+0x17a>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
8000845a:	58 0c       	cp.w	r12,0
8000845c:	c3 51       	brne	800084c6 <f_open+0x17a>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
8000845e:	e9 38 00 0b 	ld.ub	r8,r4[11]
80008462:	10 99       	mov	r9,r8
80008464:	e2 19 00 10 	andl	r9,0x10,COH
80008468:	c0 30       	breq	8000846e <f_open+0x122>
8000846a:	30 4c       	mov	r12,4
8000846c:	c2 d8       	rjmp	800084c6 <f_open+0x17a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
8000846e:	e2 13 00 02 	andl	r3,0x2,COH
80008472:	c3 10       	breq	800084d4 <f_open+0x188>
80008474:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008478:	c2 e0       	breq	800084d4 <f_open+0x188>
8000847a:	30 7c       	mov	r12,7
8000847c:	c2 58       	rjmp	800084c6 <f_open+0x17a>
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
8000847e:	a5 b5       	sbr	r5,0x5
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
80008480:	40 43       	lddsp	r3,sp[0x10]
80008482:	66 b8       	ld.w	r8,r3[0x2c]
80008484:	8f 78       	st.w	r7[0x1c],r8
			fp->dir_ptr = dir;
80008486:	8f 84       	st.w	r7[0x20],r4
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
80008488:	ae e5       	st.b	r7[0x6],r5
			fp->err = 0;						/* Clear error flag */
8000848a:	30 08       	mov	r8,0
8000848c:	ae f8       	st.b	r7[0x7],r8
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
8000848e:	08 9b       	mov	r11,r4
80008490:	06 9c       	mov	r12,r3
80008492:	f0 1f 00 18 	mcall	800084f0 <f_open+0x1a4>
80008496:	8f 4c       	st.w	r7[0x10],r12
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
80008498:	e9 39 00 1f 	ld.ub	r9,r4[31]
8000849c:	e9 38 00 1e 	ld.ub	r8,r4[30]
800084a0:	b1 68       	lsl	r8,0x10
800084a2:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800084a6:	e9 39 00 1c 	ld.ub	r9,r4[28]
800084aa:	12 48       	or	r8,r9
800084ac:	e9 39 00 1d 	ld.ub	r9,r4[29]
800084b0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800084b4:	8f 38       	st.w	r7[0xc],r8
			fp->fptr = 0;						/* File pointer */
800084b6:	30 08       	mov	r8,0
800084b8:	8f 28       	st.w	r7[0x8],r8
			fp->dsect = 0;
800084ba:	8f 68       	st.w	r7[0x18],r8
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
800084bc:	8f 98       	st.w	r7[0x24],r8
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
800084be:	8f 03       	st.w	r7[0x0],r3
			fp->id = fp->fs->id;
800084c0:	86 38       	ld.sh	r8,r3[0x6]
800084c2:	ae 28       	st.h	r7[0x4],r8
800084c4:	c0 28       	rjmp	800084c8 <f_open+0x17c>
800084c6:	18 96       	mov	r6,r12
		}
	}

	LEAVE_FF(dj.fs, res);
}
800084c8:	0c 9c       	mov	r12,r6
800084ca:	2f 4d       	sub	sp,-48
800084cc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
800084d0:	30 8c       	mov	r12,8
800084d2:	cf ab       	rjmp	800084c6 <f_open+0x17a>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
800084d4:	0a 98       	mov	r8,r5
800084d6:	e2 18 00 08 	andl	r8,0x8,COH
800084da:	cd 30       	breq	80008480 <f_open+0x134>
800084dc:	cd 1b       	rjmp	8000847e <f_open+0x132>
800084de:	00 00       	add	r0,r0
800084e0:	80 00       	ld.sh	r0,r0[0x0]
800084e2:	6f dc       	ld.w	r12,r7[0x74]
800084e4:	80 00       	ld.sh	r0,r0[0x0]
800084e6:	7e 74       	ld.w	r4,pc[0x1c]
800084e8:	80 00       	ld.sh	r0,r0[0x0]
800084ea:	7e 28       	ld.w	r8,pc[0x8]
800084ec:	80 00       	ld.sh	r0,r0[0x0]
800084ee:	64 b4       	ld.w	r4,r2[0x2c]
800084f0:	80 00       	ld.sh	r0,r0[0x0]
800084f2:	66 0a       	ld.w	r10,r3[0x0]
800084f4:	80 00       	ld.sh	r0,r0[0x0]
800084f6:	66 32       	ld.w	r2,r3[0xc]
800084f8:	80 00       	ld.sh	r0,r0[0x0]
800084fa:	79 a0       	ld.w	r0,r12[0x68]
800084fc:	80 00       	ld.sh	r0,r0[0x0]
800084fe:	6f 00       	ld.w	r0,r7[0x40]

80008500 <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
80008500:	d4 31       	pushm	r0-r7,lr
80008502:	20 2d       	sub	sp,8
80008504:	fa c7 ff f8 	sub	r7,sp,-8
80008508:	0e dc       	st.w	--r7,r12
8000850a:	16 90       	mov	r0,r11
8000850c:	14 96       	mov	r6,r10
	UINT i;
	BYTE fat, *p;


	/* Get logical drive number */
	res = find_volume(fatfs, &path, 0);
8000850e:	30 0a       	mov	r10,0
80008510:	0e 9b       	mov	r11,r7
80008512:	0c 9c       	mov	r12,r6
80008514:	f0 1f 00 33 	mcall	800085e0 <f_getfree+0xe0>
80008518:	18 93       	mov	r3,r12
	fs = *fatfs;
8000851a:	6c 06       	ld.w	r6,r6[0x0]
	if (res == FR_OK) {
8000851c:	c5 f1       	brne	800085da <f_getfree+0xda>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
8000851e:	6c 48       	ld.w	r8,r6[0x10]
80008520:	6c 57       	ld.w	r7,r6[0x14]
80008522:	ee c9 00 02 	sub	r9,r7,2
80008526:	12 38       	cp.w	r8,r9
80008528:	e0 8b 00 04 	brhi	80008530 <f_getfree+0x30>
			*nclst = fs->free_clust;
8000852c:	81 08       	st.w	r0[0x0],r8
8000852e:	c5 68       	rjmp	800085da <f_getfree+0xda>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
80008530:	0d 84       	ld.ub	r4,r6[0x0]
			nfree = 0;
			if (fat == FS_FAT12) {	/* Sector unalighed entries: Search FAT via regular routine. */
80008532:	30 18       	mov	r8,1
80008534:	f0 04 18 00 	cp.b	r4,r8
80008538:	c1 71       	brne	80008566 <f_getfree+0x66>
8000853a:	30 27       	mov	r7,2
8000853c:	30 05       	mov	r5,0
				clst = 2;
				do {
					stat = get_fat(fs, clst);
8000853e:	0e 9b       	mov	r11,r7
80008540:	0c 9c       	mov	r12,r6
80008542:	f0 1f 00 29 	mcall	800085e4 <f_getfree+0xe4>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
80008546:	5b fc       	cp.w	r12,-1
80008548:	c0 31       	brne	8000854e <f_getfree+0x4e>
8000854a:	30 1c       	mov	r12,1
8000854c:	c4 28       	rjmp	800085d0 <f_getfree+0xd0>
					if (stat == 1) { res = FR_INT_ERR; break; }
8000854e:	58 1c       	cp.w	r12,1
80008550:	c0 31       	brne	80008556 <f_getfree+0x56>
80008552:	30 2c       	mov	r12,2
80008554:	c3 e8       	rjmp	800085d0 <f_getfree+0xd0>
					if (stat == 0) nfree++;
80008556:	58 0c       	cp.w	r12,0
80008558:	f7 b5 00 ff 	subeq	r5,-1
				} while (++clst < fs->n_fatent);
8000855c:	2f f7       	sub	r7,-1
8000855e:	6c 58       	ld.w	r8,r6[0x14]
80008560:	10 37       	cp.w	r7,r8
80008562:	ce e3       	brcs	8000853e <f_getfree+0x3e>
80008564:	c3 58       	rjmp	800085ce <f_getfree+0xce>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
80008566:	6c 81       	ld.w	r1,r6[0x20]
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
						if (res != FR_OK) break;
						p = fs->win;
80008568:	30 08       	mov	r8,0
8000856a:	10 99       	mov	r9,r8
8000856c:	10 95       	mov	r5,r8
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
8000856e:	ec ca ff d0 	sub	r10,r6,-48
80008572:	50 0a       	stdsp	sp[0x0],r10
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
80008574:	30 22       	mov	r2,2
				} while (++clst < fs->n_fatent);
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
80008576:	58 09       	cp.w	r9,0
80008578:	c0 a1       	brne	8000858c <f_getfree+0x8c>
						res = move_window(fs, sect++);
8000857a:	02 9b       	mov	r11,r1
8000857c:	0c 9c       	mov	r12,r6
8000857e:	f0 1f 00 1b 	mcall	800085e8 <f_getfree+0xe8>
						if (res != FR_OK) break;
80008582:	c2 71       	brne	800085d0 <f_getfree+0xd0>
			} else {				/* Sector alighed entries: Accelerate the FAT search. */
				clst = fs->n_fatent; sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
80008584:	2f f1       	sub	r1,-1
80008586:	40 08       	lddsp	r8,sp[0x0]
80008588:	e0 69 02 00 	mov	r9,512
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
					}
					if (fat == FS_FAT16) {
8000858c:	e4 04 18 00 	cp.b	r4,r2
80008590:	c0 d1       	brne	800085aa <f_getfree+0xaa>
						if (LD_WORD(p) == 0) nfree++;
80008592:	11 9b       	ld.ub	r11,r8[0x1]
80008594:	11 8a       	ld.ub	r10,r8[0x0]
80008596:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
8000859a:	30 0b       	mov	r11,0
8000859c:	f6 0a 19 00 	cp.h	r10,r11
800085a0:	f7 b5 00 ff 	subeq	r5,-1
						p += 2; i -= 2;
800085a4:	2f e8       	sub	r8,-2
800085a6:	20 29       	sub	r9,2
800085a8:	c1 18       	rjmp	800085ca <f_getfree+0xca>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) nfree++;
800085aa:	11 bb       	ld.ub	r11,r8[0x3]
800085ac:	11 aa       	ld.ub	r10,r8[0x2]
800085ae:	b1 6a       	lsl	r10,0x10
800085b0:	f5 eb 11 8a 	or	r10,r10,r11<<0x18
800085b4:	11 8b       	ld.ub	r11,r8[0x0]
800085b6:	16 4a       	or	r10,r11
800085b8:	11 9b       	ld.ub	r11,r8[0x1]
800085ba:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
800085be:	f5 da c0 1c 	bfextu	r10,r10,0x0,0x1c
800085c2:	f7 b5 00 ff 	subeq	r5,-1
						p += 4; i -= 4;
800085c6:	2f c8       	sub	r8,-4
800085c8:	20 49       	sub	r9,4
					}
				} while (--clst);
800085ca:	20 17       	sub	r7,1
800085cc:	cd 51       	brne	80008576 <f_getfree+0x76>
800085ce:	06 9c       	mov	r12,r3
			}
			fs->free_clust = nfree;	/* free_clust is valid */
800085d0:	8d 45       	st.w	r6[0x10],r5
			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
800085d2:	0d d8       	ld.ub	r8,r6[0x5]
800085d4:	a1 a8       	sbr	r8,0x0
800085d6:	ac d8       	st.b	r6[0x5],r8
			*nclst = nfree;			/* Return the free clusters */
800085d8:	81 05       	st.w	r0[0x0],r5
		}
	}
	LEAVE_FF(fs, res);
}
800085da:	2f ed       	sub	sp,-8
800085dc:	d8 32       	popm	r0-r7,pc
800085de:	00 00       	add	r0,r0
800085e0:	80 00       	ld.sh	r0,r0[0x0]
800085e2:	6f dc       	ld.w	r12,r7[0x74]
800085e4:	80 00       	ld.sh	r0,r0[0x0]
800085e6:	76 28       	ld.w	r8,r11[0x8]
800085e8:	80 00       	ld.sh	r0,r0[0x0]
800085ea:	6f 00       	ld.w	r0,r7[0x40]

800085ec <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
800085ec:	d4 31       	pushm	r0-r7,lr
800085ee:	18 97       	mov	r7,r12
800085f0:	16 95       	mov	r5,r11
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif


	res = validate(fp);					/* Check validity of the object */
800085f2:	f0 1f 00 a5 	mcall	80008884 <f_lseek+0x298>
800085f6:	18 96       	mov	r6,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
800085f8:	e0 81 01 44 	brne	80008880 <f_lseek+0x294>
	if (fp->err)						/* Check error */
800085fc:	0f f8       	ld.ub	r8,r7[0x7]
800085fe:	58 08       	cp.w	r8,0
80008600:	c0 30       	breq	80008606 <f_lseek+0x1a>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008602:	10 96       	mov	r6,r8
80008604:	c3 e9       	rjmp	80008880 <f_lseek+0x294>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
80008606:	6e 93       	ld.w	r3,r7[0x24]
80008608:	58 03       	cp.w	r3,0
8000860a:	e0 80 00 85 	breq	80008714 <f_lseek+0x128>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
8000860e:	5b f5       	cp.w	r5,-1
80008610:	c3 71       	brne	8000867e <f_lseek+0x92>
			tbl = fp->cltbl;
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
80008612:	07 00       	ld.w	r0,r3++
			cl = fp->sclust;			/* Top of the chain */
80008614:	6e 41       	ld.w	r1,r7[0x10]
			if (cl) {
80008616:	58 01       	cp.w	r1,0
80008618:	c2 80       	breq	80008668 <f_lseek+0x7c>
8000861a:	30 22       	mov	r2,2
8000861c:	02 95       	mov	r5,r1
8000861e:	30 04       	mov	r4,0
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
80008620:	0a 9b       	mov	r11,r5
80008622:	6e 0c       	ld.w	r12,r7[0x0]
80008624:	f0 1f 00 99 	mcall	80008888 <f_lseek+0x29c>
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
80008628:	58 1c       	cp.w	r12,1
8000862a:	e0 8b 00 06 	brhi	80008636 <f_lseek+0x4a>
8000862e:	30 28       	mov	r8,2
80008630:	ae f8       	st.b	r7[0x7],r8
80008632:	30 26       	mov	r6,2
80008634:	c2 69       	rjmp	80008880 <f_lseek+0x294>
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008636:	5b fc       	cp.w	r12,-1
80008638:	c0 51       	brne	80008642 <f_lseek+0x56>
8000863a:	30 18       	mov	r8,1
8000863c:	ae f8       	st.b	r7[0x7],r8
8000863e:	30 16       	mov	r6,1
80008640:	c2 09       	rjmp	80008880 <f_lseek+0x294>
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
					do {
						pcl = cl; ncl++;
80008642:	2f f4       	sub	r4,-1
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
80008644:	2f f5       	sub	r5,-1
80008646:	0a 3c       	cp.w	r12,r5
80008648:	c0 31       	brne	8000864e <f_lseek+0x62>
8000864a:	18 95       	mov	r5,r12
8000864c:	ce ab       	rjmp	80008620 <f_lseek+0x34>
8000864e:	18 98       	mov	r8,r12
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
			cl = fp->sclust;			/* Top of the chain */
			if (cl) {
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
80008650:	2f e2       	sub	r2,-2
						pcl = cl; ncl++;
						cl = get_fat(fp->fs, cl);
						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
80008652:	04 30       	cp.w	r0,r2
80008654:	c0 33       	brcs	8000865a <f_lseek+0x6e>
						*tbl++ = ncl; *tbl++ = tcl;
80008656:	06 a4       	st.w	r3++,r4
80008658:	06 a1       	st.w	r3++,r1
					}
				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
8000865a:	6e 09       	ld.w	r9,r7[0x0]
8000865c:	72 59       	ld.w	r9,r9[0x14]
8000865e:	10 39       	cp.w	r9,r8
80008660:	e0 88 00 05 	brls	8000866a <f_lseek+0x7e>
80008664:	18 91       	mov	r1,r12
80008666:	cd bb       	rjmp	8000861c <f_lseek+0x30>
80008668:	30 22       	mov	r2,2
			}
			*fp->cltbl = ulen;	/* Number of items used */
8000866a:	6e 98       	ld.w	r8,r7[0x24]
8000866c:	91 02       	st.w	r8[0x0],r2
			if (ulen <= tlen)
8000866e:	00 32       	cp.w	r2,r0
80008670:	f9 b6 0b 11 	movhi	r6,17
				*tbl = 0;		/* Terminate table */
80008674:	f9 b8 08 00 	movls	r8,0
80008678:	e7 f8 8a 00 	st.wls	r3[0x0],r8
8000867c:	c0 29       	rjmp	80008880 <f_lseek+0x294>
8000867e:	6e 34       	ld.w	r4,r7[0xc]
80008680:	08 35       	cp.w	r5,r4
80008682:	e8 05 17 b0 	movhi	r5,r4
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */

		} else {						/* Fast seek */
			if (ofs > fp->fsize)		/* Clip offset at the file size */
				ofs = fp->fsize;
			fp->fptr = ofs;				/* Set file pointer */
80008686:	8f 25       	st.w	r7[0x8],r5
			if (ofs) {
80008688:	58 05       	cp.w	r5,0
8000868a:	e0 80 00 fb 	breq	80008880 <f_lseek+0x294>
				fp->clust = clmt_clust(fp, ofs - 1);
8000868e:	ea c4 00 01 	sub	r4,r5,1
80008692:	08 9b       	mov	r11,r4
80008694:	0e 9c       	mov	r12,r7
80008696:	f0 1f 00 7e 	mcall	8000888c <f_lseek+0x2a0>
8000869a:	18 9b       	mov	r11,r12
8000869c:	8f 5c       	st.w	r7[0x14],r12
				dsc = clust2sect(fp->fs, fp->clust);
8000869e:	6e 05       	ld.w	r5,r7[0x0]
800086a0:	0a 9c       	mov	r12,r5
800086a2:	f0 1f 00 7c 	mcall	80008890 <f_lseek+0x2a4>
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
800086a6:	c0 51       	brne	800086b0 <f_lseek+0xc4>
800086a8:	30 28       	mov	r8,2
800086aa:	ae f8       	st.b	r7[0x7],r8
800086ac:	30 26       	mov	r6,2
800086ae:	ce 98       	rjmp	80008880 <f_lseek+0x294>
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
800086b0:	0b a9       	ld.ub	r9,r5[0x2]
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
800086b2:	6e 28       	ld.w	r8,r7[0x8]
800086b4:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800086b8:	e0 80 00 e4 	breq	80008880 <f_lseek+0x294>
			fp->fptr = ofs;				/* Set file pointer */
			if (ofs) {
				fp->clust = clmt_clust(fp, ofs - 1);
				dsc = clust2sect(fp->fs, fp->clust);
				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
800086bc:	20 19       	sub	r9,1
800086be:	f3 e4 02 94 	and	r4,r9,r4>>0x9
800086c2:	f8 04 00 04 	add	r4,r12,r4
				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
800086c6:	6e 6a       	ld.w	r10,r7[0x18]
800086c8:	08 3a       	cp.w	r10,r4
800086ca:	e0 80 00 db 	breq	80008880 <f_lseek+0x294>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
800086ce:	0f e8       	ld.ub	r8,r7[0x6]
800086d0:	e2 18 00 40 	andl	r8,0x40,COH
800086d4:	c0 f0       	breq	800086f2 <f_lseek+0x106>
						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800086d6:	30 19       	mov	r9,1
800086d8:	ee cb ff d8 	sub	r11,r7,-40
800086dc:	0b 9c       	ld.ub	r12,r5[0x1]
800086de:	f0 1f 00 6e 	mcall	80008894 <f_lseek+0x2a8>
800086e2:	c0 50       	breq	800086ec <f_lseek+0x100>
							ABORT(fp->fs, FR_DISK_ERR);
800086e4:	30 18       	mov	r8,1
800086e6:	ae f8       	st.b	r7[0x7],r8
800086e8:	30 16       	mov	r6,1
800086ea:	cc b8       	rjmp	80008880 <f_lseek+0x294>
						fp->flag &= ~FA__DIRTY;
800086ec:	0f e8       	ld.ub	r8,r7[0x6]
800086ee:	a7 c8       	cbr	r8,0x6
800086f0:	ae e8       	st.b	r7[0x6],r8
					}
#endif
					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
800086f2:	6e 08       	ld.w	r8,r7[0x0]
800086f4:	30 19       	mov	r9,1
800086f6:	08 9a       	mov	r10,r4
800086f8:	ee cb ff d8 	sub	r11,r7,-40
800086fc:	11 9c       	ld.ub	r12,r8[0x1]
800086fe:	f0 1f 00 67 	mcall	80008898 <f_lseek+0x2ac>
						ABORT(fp->fs, FR_DISK_ERR);
80008702:	f9 b8 01 01 	movne	r8,1
80008706:	ef f8 1e 07 	st.bne	r7[0x7],r8
8000870a:	f9 b6 01 01 	movne	r6,1
#endif
					fp->dsect = dsc;
8000870e:	ef f4 0a 06 	st.weq	r7[0x18],r4
80008712:	cb 78       	rjmp	80008880 <f_lseek+0x294>

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
80008714:	6e 34       	ld.w	r4,r7[0xc]
	} else
#endif

	/* Normal Seek */
	{
		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
80008716:	08 35       	cp.w	r5,r4
80008718:	e0 88 00 06 	brls	80008724 <f_lseek+0x138>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
8000871c:	0f e8       	ld.ub	r8,r7[0x6]
8000871e:	e2 18 00 02 	andl	r8,0x2,COH
80008722:	c0 20       	breq	80008726 <f_lseek+0x13a>
80008724:	0a 94       	mov	r4,r5
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
80008726:	6e 29       	ld.w	r9,r7[0x8]
		fp->fptr = nsect = 0;
80008728:	30 08       	mov	r8,0
8000872a:	8f 28       	st.w	r7[0x8],r8
		if (ofs) {
8000872c:	58 04       	cp.w	r4,0
8000872e:	e0 80 00 a9 	breq	80008880 <f_lseek+0x294>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
80008732:	6e 08       	ld.w	r8,r7[0x0]
80008734:	11 a5       	ld.ub	r5,r8[0x2]
80008736:	a9 75       	lsl	r5,0x9
			if (ifptr > 0 &&
80008738:	58 09       	cp.w	r9,0
8000873a:	c1 30       	breq	80008760 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
8000873c:	20 19       	sub	r9,1

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
8000873e:	e8 cb 00 01 	sub	r11,r4,1
80008742:	f6 05 0d 0a 	divu	r10,r11,r5
80008746:	14 9b       	mov	r11,r10
80008748:	f2 05 0d 02 	divu	r2,r9,r5
8000874c:	04 3b       	cp.w	r11,r2
8000874e:	c0 93       	brcs	80008760 <f_lseek+0x174>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
80008750:	ea 08 11 00 	rsub	r8,r5,0
80008754:	f1 e9 00 09 	and	r9,r8,r9
80008758:	8f 29       	st.w	r7[0x8],r9
				ofs -= fp->fptr;
8000875a:	12 14       	sub	r4,r9
				clst = fp->clust;
8000875c:	6e 5c       	ld.w	r12,r7[0x14]

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
8000875e:	c1 68       	rjmp	8000878a <f_lseek+0x19e>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
80008760:	6e 4c       	ld.w	r12,r7[0x10]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
80008762:	58 0c       	cp.w	r12,0
80008764:	c1 21       	brne	80008788 <f_lseek+0x19c>
					clst = create_chain(fp->fs, 0);
80008766:	30 0b       	mov	r11,0
80008768:	10 9c       	mov	r12,r8
8000876a:	f0 1f 00 4d 	mcall	8000889c <f_lseek+0x2b0>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
8000876e:	58 1c       	cp.w	r12,1
80008770:	c0 51       	brne	8000877a <f_lseek+0x18e>
80008772:	30 28       	mov	r8,2
80008774:	ae f8       	st.b	r7[0x7],r8
80008776:	30 26       	mov	r6,2
80008778:	c8 48       	rjmp	80008880 <f_lseek+0x294>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
8000877a:	5b fc       	cp.w	r12,-1
8000877c:	c0 51       	brne	80008786 <f_lseek+0x19a>
8000877e:	30 18       	mov	r8,1
80008780:	ae f8       	st.b	r7[0x7],r8
80008782:	30 16       	mov	r6,1
80008784:	c7 e8       	rjmp	80008880 <f_lseek+0x294>
					fp->sclust = clst;
80008786:	8f 4c       	st.w	r7[0x10],r12
				}
#endif
				fp->clust = clst;
80008788:	8f 5c       	st.w	r7[0x14],r12
			}
			if (clst != 0) {
8000878a:	58 0c       	cp.w	r12,0
8000878c:	c4 80       	breq	8000881c <f_lseek+0x230>
				while (ofs > bcs) {						/* Cluster following loop */
8000878e:	0a 34       	cp.w	r4,r5
80008790:	e0 88 00 32 	brls	800087f4 <f_lseek+0x208>
#if _FS_MINIMIZE <= 2
/*-----------------------------------------------------------------------*/
/* Seek File R/W Pointer                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_lseek (
80008794:	ea 03 11 00 	rsub	r3,r5,0
80008798:	0a 14       	sub	r4,r5
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
8000879a:	0f e8       	ld.ub	r8,r7[0x6]
8000879c:	e2 18 00 02 	andl	r8,0x2,COH
800087a0:	c0 70       	breq	800087ae <f_lseek+0x1c2>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
800087a2:	18 9b       	mov	r11,r12
800087a4:	6e 0c       	ld.w	r12,r7[0x0]
800087a6:	f0 1f 00 3e 	mcall	8000889c <f_lseek+0x2b0>
						if (clst == 0) {				/* When disk gets full, clip file size */
800087aa:	c0 61       	brne	800087b6 <f_lseek+0x1ca>
800087ac:	c2 38       	rjmp	800087f2 <f_lseek+0x206>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
800087ae:	18 9b       	mov	r11,r12
800087b0:	6e 0c       	ld.w	r12,r7[0x0]
800087b2:	f0 1f 00 36 	mcall	80008888 <f_lseek+0x29c>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
800087b6:	5b fc       	cp.w	r12,-1
800087b8:	c0 51       	brne	800087c2 <f_lseek+0x1d6>
800087ba:	30 18       	mov	r8,1
800087bc:	ae f8       	st.b	r7[0x7],r8
800087be:	30 16       	mov	r6,1
800087c0:	c6 08       	rjmp	80008880 <f_lseek+0x294>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
800087c2:	58 1c       	cp.w	r12,1
800087c4:	e0 88 00 06 	brls	800087d0 <f_lseek+0x1e4>
800087c8:	6e 08       	ld.w	r8,r7[0x0]
800087ca:	70 58       	ld.w	r8,r8[0x14]
800087cc:	10 3c       	cp.w	r12,r8
800087ce:	c0 53       	brcs	800087d8 <f_lseek+0x1ec>
800087d0:	30 28       	mov	r8,2
800087d2:	ae f8       	st.b	r7[0x7],r8
800087d4:	30 26       	mov	r6,2
800087d6:	c5 58       	rjmp	80008880 <f_lseek+0x294>
					fp->clust = clst;
800087d8:	8f 5c       	st.w	r7[0x14],r12
					fp->fptr += bcs;
800087da:	6e 28       	ld.w	r8,r7[0x8]
800087dc:	0a 08       	add	r8,r5
800087de:	8f 28       	st.w	r7[0x8],r8
800087e0:	e8 03 00 08 	add	r8,r4,r3
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
800087e4:	f0 05 00 09 	add	r9,r8,r5
800087e8:	0a 39       	cp.w	r9,r5
800087ea:	e0 88 00 05 	brls	800087f4 <f_lseek+0x208>
800087ee:	10 94       	mov	r4,r8
800087f0:	cd 5b       	rjmp	8000879a <f_lseek+0x1ae>
800087f2:	0a 94       	mov	r4,r5
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
800087f4:	6e 28       	ld.w	r8,r7[0x8]
800087f6:	08 08       	add	r8,r4
800087f8:	8f 28       	st.w	r7[0x8],r8
				if (ofs % SS(fp->fs)) {
800087fa:	f1 d4 c0 09 	bfextu	r8,r4,0x0,0x9
800087fe:	c0 f0       	breq	8000881c <f_lseek+0x230>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
80008800:	18 9b       	mov	r11,r12
80008802:	6e 0c       	ld.w	r12,r7[0x0]
80008804:	f0 1f 00 23 	mcall	80008890 <f_lseek+0x2a4>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
80008808:	c0 51       	brne	80008812 <f_lseek+0x226>
8000880a:	30 28       	mov	r8,2
8000880c:	ae f8       	st.b	r7[0x7],r8
8000880e:	30 26       	mov	r6,2
80008810:	c3 88       	rjmp	80008880 <f_lseek+0x294>
					nsect += ofs / SS(fp->fs);
80008812:	e8 05 16 09 	lsr	r5,r4,0x9
80008816:	f8 05 00 05 	add	r5,r12,r5
8000881a:	c0 28       	rjmp	8000881e <f_lseek+0x232>
8000881c:	30 05       	mov	r5,0
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
8000881e:	6e 28       	ld.w	r8,r7[0x8]
80008820:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80008824:	c2 50       	breq	8000886e <f_lseek+0x282>
80008826:	6e 6a       	ld.w	r10,r7[0x18]
80008828:	0a 3a       	cp.w	r10,r5
8000882a:	c2 20       	breq	8000886e <f_lseek+0x282>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
8000882c:	0f e8       	ld.ub	r8,r7[0x6]
8000882e:	e2 18 00 40 	andl	r8,0x40,COH
80008832:	c1 00       	breq	80008852 <f_lseek+0x266>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008834:	6e 08       	ld.w	r8,r7[0x0]
80008836:	30 19       	mov	r9,1
80008838:	ee cb ff d8 	sub	r11,r7,-40
8000883c:	11 9c       	ld.ub	r12,r8[0x1]
8000883e:	f0 1f 00 16 	mcall	80008894 <f_lseek+0x2a8>
80008842:	c0 50       	breq	8000884c <f_lseek+0x260>
					ABORT(fp->fs, FR_DISK_ERR);
80008844:	30 18       	mov	r8,1
80008846:	ae f8       	st.b	r7[0x7],r8
80008848:	30 16       	mov	r6,1
8000884a:	c1 b8       	rjmp	80008880 <f_lseek+0x294>
				fp->flag &= ~FA__DIRTY;
8000884c:	0f e8       	ld.ub	r8,r7[0x6]
8000884e:	a7 c8       	cbr	r8,0x6
80008850:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
80008852:	6e 08       	ld.w	r8,r7[0x0]
80008854:	30 19       	mov	r9,1
80008856:	0a 9a       	mov	r10,r5
80008858:	ee cb ff d8 	sub	r11,r7,-40
8000885c:	11 9c       	ld.ub	r12,r8[0x1]
8000885e:	f0 1f 00 0f 	mcall	80008898 <f_lseek+0x2ac>
80008862:	c0 50       	breq	8000886c <f_lseek+0x280>
				ABORT(fp->fs, FR_DISK_ERR);
80008864:	30 18       	mov	r8,1
80008866:	ae f8       	st.b	r7[0x7],r8
80008868:	30 16       	mov	r6,1
8000886a:	c0 b8       	rjmp	80008880 <f_lseek+0x294>
#endif
			fp->dsect = nsect;
8000886c:	8f 65       	st.w	r7[0x18],r5
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
8000886e:	6e 28       	ld.w	r8,r7[0x8]
80008870:	6e 39       	ld.w	r9,r7[0xc]
80008872:	12 38       	cp.w	r8,r9
80008874:	e0 88 00 06 	brls	80008880 <f_lseek+0x294>
			fp->fsize = fp->fptr;
80008878:	8f 38       	st.w	r7[0xc],r8
			fp->flag |= FA__WRITTEN;
8000887a:	0f e8       	ld.ub	r8,r7[0x6]
8000887c:	a5 b8       	sbr	r8,0x5
8000887e:	ae e8       	st.b	r7[0x6],r8
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
80008880:	0c 9c       	mov	r12,r6
80008882:	d8 32       	popm	r0-r7,pc
80008884:	80 00       	ld.sh	r0,r0[0x0]
80008886:	6e cc       	ld.w	r12,r7[0x30]
80008888:	80 00       	ld.sh	r0,r0[0x0]
8000888a:	76 28       	ld.w	r8,r11[0x8]
8000888c:	80 00       	ld.sh	r0,r0[0x0]
8000888e:	65 cc       	ld.w	r12,r2[0x70]
80008890:	80 00       	ld.sh	r0,r0[0x0]
80008892:	65 b4       	ld.w	r4,r2[0x6c]
80008894:	80 00       	ld.sh	r0,r0[0x0]
80008896:	65 40       	ld.w	r0,r2[0x50]
80008898:	80 00       	ld.sh	r0,r0[0x0]
8000889a:	65 5c       	ld.w	r12,r2[0x54]
8000889c:	80 00       	ld.sh	r0,r0[0x0]
8000889e:	77 c0       	ld.w	r0,r11[0x70]

800088a0 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
800088a0:	d4 31       	pushm	r0-r7,lr
800088a2:	20 3d       	sub	sp,12
800088a4:	18 97       	mov	r7,r12
800088a6:	16 93       	mov	r3,r11
800088a8:	14 96       	mov	r6,r10
800088aa:	12 94       	mov	r4,r9
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
800088ac:	30 08       	mov	r8,0
800088ae:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);						/* Check validity */
800088b0:	f0 1f 00 6d 	mcall	80008a64 <f_write+0x1c4>
800088b4:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
800088b6:	e0 81 00 d3 	brne	80008a5c <f_write+0x1bc>
	if (fp->err)							/* Check error */
800088ba:	0f f8       	ld.ub	r8,r7[0x7]
800088bc:	58 08       	cp.w	r8,0
800088be:	c0 30       	breq	800088c4 <f_write+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
800088c0:	10 92       	mov	r2,r8
800088c2:	cc d8       	rjmp	80008a5c <f_write+0x1bc>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
800088c4:	0f e8       	ld.ub	r8,r7[0x6]
800088c6:	e2 18 00 02 	andl	r8,0x2,COH
800088ca:	c0 31       	brne	800088d0 <f_write+0x30>
800088cc:	30 72       	mov	r2,7
800088ce:	cc 78       	rjmp	80008a5c <f_write+0x1bc>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
800088d0:	6e 28       	ld.w	r8,r7[0x8]
800088d2:	ec 08 00 09 	add	r9,r6,r8
800088d6:	12 38       	cp.w	r8,r9
800088d8:	e0 8b 00 ba 	brhi	80008a4c <f_write+0x1ac>

	for ( ;  btw;							/* Repeat until all data written */
800088dc:	58 06       	cp.w	r6,0
800088de:	e0 80 00 b7 	breq	80008a4c <f_write+0x1ac>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
800088e2:	ee c8 ff d8 	sub	r8,r7,-40
800088e6:	50 18       	stdsp	sp[0x4],r8
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
800088e8:	50 08       	stdsp	sp[0x0],r8
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
800088ea:	50 2c       	stdsp	sp[0x8],r12
800088ec:	0c 95       	mov	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
800088ee:	6e 2b       	ld.w	r11,r7[0x8]
800088f0:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
800088f4:	e0 81 00 8c 	brne	80008a0c <f_write+0x16c>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
800088f8:	6e 08       	ld.w	r8,r7[0x0]
800088fa:	11 a6       	ld.ub	r6,r8[0x2]
800088fc:	20 16       	sub	r6,1
800088fe:	ed eb 02 96 	and	r6,r6,r11>>0x9
80008902:	5c 56       	castu.b	r6
			if (!csect) {					/* On the cluster boundary? */
80008904:	c2 91       	brne	80008956 <f_write+0xb6>
				if (fp->fptr == 0) {		/* On the top of the file? */
80008906:	58 0b       	cp.w	r11,0
80008908:	c0 81       	brne	80008918 <f_write+0x78>
					clst = fp->sclust;		/* Follow from the origin */
8000890a:	6e 4c       	ld.w	r12,r7[0x10]
					if (clst == 0)			/* When no cluster is allocated, */
8000890c:	58 0c       	cp.w	r12,0
8000890e:	c1 31       	brne	80008934 <f_write+0x94>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
80008910:	10 9c       	mov	r12,r8
80008912:	f0 1f 00 56 	mcall	80008a68 <f_write+0x1c8>
80008916:	c0 c8       	rjmp	8000892e <f_write+0x8e>
				} else {					/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008918:	6e 99       	ld.w	r9,r7[0x24]
8000891a:	58 09       	cp.w	r9,0
8000891c:	c0 50       	breq	80008926 <f_write+0x86>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
8000891e:	0e 9c       	mov	r12,r7
80008920:	f0 1f 00 53 	mcall	80008a6c <f_write+0x1cc>
80008924:	c0 58       	rjmp	8000892e <f_write+0x8e>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
80008926:	6e 5b       	ld.w	r11,r7[0x14]
80008928:	10 9c       	mov	r12,r8
8000892a:	f0 1f 00 50 	mcall	80008a68 <f_write+0x1c8>
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
8000892e:	58 0c       	cp.w	r12,0
80008930:	e0 80 00 8b 	breq	80008a46 <f_write+0x1a6>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
80008934:	58 1c       	cp.w	r12,1
80008936:	c0 51       	brne	80008940 <f_write+0xa0>
80008938:	30 28       	mov	r8,2
8000893a:	ae f8       	st.b	r7[0x7],r8
8000893c:	30 22       	mov	r2,2
8000893e:	c8 f8       	rjmp	80008a5c <f_write+0x1bc>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008940:	5b fc       	cp.w	r12,-1
80008942:	c0 51       	brne	8000894c <f_write+0xac>
80008944:	30 18       	mov	r8,1
80008946:	ae f8       	st.b	r7[0x7],r8
80008948:	30 12       	mov	r2,1
8000894a:	c8 98       	rjmp	80008a5c <f_write+0x1bc>
				fp->clust = clst;			/* Update current cluster */
8000894c:	8f 5c       	st.w	r7[0x14],r12
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
8000894e:	6e 48       	ld.w	r8,r7[0x10]
80008950:	58 08       	cp.w	r8,0
80008952:	ef fc 0a 04 	st.weq	r7[0x10],r12
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
80008956:	0f e8       	ld.ub	r8,r7[0x6]
80008958:	e2 18 00 40 	andl	r8,0x40,COH
8000895c:	c1 00       	breq	8000897c <f_write+0xdc>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
8000895e:	6e 08       	ld.w	r8,r7[0x0]
80008960:	30 19       	mov	r9,1
80008962:	6e 6a       	ld.w	r10,r7[0x18]
80008964:	40 1b       	lddsp	r11,sp[0x4]
80008966:	11 9c       	ld.ub	r12,r8[0x1]
80008968:	f0 1f 00 42 	mcall	80008a70 <f_write+0x1d0>
8000896c:	c0 50       	breq	80008976 <f_write+0xd6>
					ABORT(fp->fs, FR_DISK_ERR);
8000896e:	30 18       	mov	r8,1
80008970:	ae f8       	st.b	r7[0x7],r8
80008972:	30 12       	mov	r2,1
80008974:	c7 48       	rjmp	80008a5c <f_write+0x1bc>
				fp->flag &= ~FA__DIRTY;
80008976:	0f e8       	ld.ub	r8,r7[0x6]
80008978:	a7 c8       	cbr	r8,0x6
8000897a:	ae e8       	st.b	r7[0x6],r8
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
8000897c:	6e 01       	ld.w	r1,r7[0x0]
8000897e:	6e 5b       	ld.w	r11,r7[0x14]
80008980:	02 9c       	mov	r12,r1
80008982:	f0 1f 00 3d 	mcall	80008a74 <f_write+0x1d4>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
80008986:	c0 51       	brne	80008990 <f_write+0xf0>
80008988:	30 28       	mov	r8,2
8000898a:	ae f8       	st.b	r7[0x7],r8
8000898c:	30 22       	mov	r2,2
8000898e:	c6 78       	rjmp	80008a5c <f_write+0x1bc>
			sect += csect;
80008990:	f8 06 00 00 	add	r0,r12,r6
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
80008994:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {						/* Write maximum contiguous sectors directly */
80008998:	c2 70       	breq	800089e6 <f_write+0x146>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
8000899a:	03 a9       	ld.ub	r9,r1[0x2]
8000899c:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
800089a0:	12 38       	cp.w	r8,r9
800089a2:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
800089a6:	04 99       	mov	r9,r2
800089a8:	00 9a       	mov	r10,r0
800089aa:	06 9b       	mov	r11,r3
800089ac:	03 9c       	ld.ub	r12,r1[0x1]
800089ae:	f0 1f 00 31 	mcall	80008a70 <f_write+0x1d0>
800089b2:	c0 50       	breq	800089bc <f_write+0x11c>
					ABORT(fp->fs, FR_DISK_ERR);
800089b4:	30 18       	mov	r8,1
800089b6:	ae f8       	st.b	r7[0x7],r8
800089b8:	30 12       	mov	r2,1
800089ba:	c5 18       	rjmp	80008a5c <f_write+0x1bc>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
800089bc:	6e 6b       	ld.w	r11,r7[0x18]
800089be:	f6 00 01 00 	sub	r0,r11,r0
800089c2:	00 32       	cp.w	r2,r0
800089c4:	e0 88 00 0e 	brls	800089e0 <f_write+0x140>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
800089c8:	e0 0b 15 09 	lsl	r11,r0,0x9
800089cc:	e0 6a 02 00 	mov	r10,512
800089d0:	e6 0b 00 0b 	add	r11,r3,r11
800089d4:	40 0c       	lddsp	r12,sp[0x0]
800089d6:	f0 1f 00 29 	mcall	80008a78 <f_write+0x1d8>
					fp->flag &= ~FA__DIRTY;
800089da:	0f e8       	ld.ub	r8,r7[0x6]
800089dc:	a7 c8       	cbr	r8,0x6
800089de:	ae e8       	st.b	r7[0x6],r8
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
800089e0:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
800089e4:	c2 78       	rjmp	80008a32 <f_write+0x192>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
800089e6:	6e 68       	ld.w	r8,r7[0x18]
800089e8:	00 38       	cp.w	r8,r0
800089ea:	c1 00       	breq	80008a0a <f_write+0x16a>
				if (fp->fptr < fp->fsize &&
800089ec:	6e 29       	ld.w	r9,r7[0x8]
800089ee:	6e 38       	ld.w	r8,r7[0xc]
800089f0:	10 39       	cp.w	r9,r8
800089f2:	c0 c2       	brcc	80008a0a <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
800089f4:	30 19       	mov	r9,1
800089f6:	00 9a       	mov	r10,r0
800089f8:	40 1b       	lddsp	r11,sp[0x4]
800089fa:	03 9c       	ld.ub	r12,r1[0x1]
800089fc:	f0 1f 00 20 	mcall	80008a7c <f_write+0x1dc>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
80008a00:	c0 50       	breq	80008a0a <f_write+0x16a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
80008a02:	30 18       	mov	r8,1
80008a04:	ae f8       	st.b	r7[0x7],r8
80008a06:	30 12       	mov	r2,1
80008a08:	c2 a8       	rjmp	80008a5c <f_write+0x1bc>
			}
#endif
			fp->dsect = sect;
80008a0a:	8f 60       	st.w	r7[0x18],r0
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
80008a0c:	6e 2c       	ld.w	r12,r7[0x8]
80008a0e:	f9 dc c0 09 	bfextu	r12,r12,0x0,0x9
80008a12:	e0 66 02 00 	mov	r6,512
80008a16:	18 16       	sub	r6,r12
80008a18:	0c 35       	cp.w	r5,r6
80008a1a:	ea 06 17 80 	movls	r6,r5
		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
80008a1e:	0c 9a       	mov	r10,r6
80008a20:	06 9b       	mov	r11,r3
80008a22:	40 08       	lddsp	r8,sp[0x0]
80008a24:	f0 0c 00 0c 	add	r12,r8,r12
80008a28:	f0 1f 00 14 	mcall	80008a78 <f_write+0x1d8>
		fp->flag |= FA__DIRTY;
80008a2c:	0f e8       	ld.ub	r8,r7[0x6]
80008a2e:	a7 a8       	sbr	r8,0x6
80008a30:	ae e8       	st.b	r7[0x6],r8
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008a32:	6e 28       	ld.w	r8,r7[0x8]
80008a34:	0c 08       	add	r8,r6
80008a36:	8f 28       	st.w	r7[0x8],r8
80008a38:	68 08       	ld.w	r8,r4[0x0]
80008a3a:	0c 08       	add	r8,r6
80008a3c:	89 08       	st.w	r4[0x0],r8
80008a3e:	0c 15       	sub	r5,r6
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
80008a40:	c0 50       	breq	80008a4a <f_write+0x1aa>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
80008a42:	0c 03       	add	r3,r6
80008a44:	c5 5b       	rjmp	800088ee <f_write+0x4e>
80008a46:	40 22       	lddsp	r2,sp[0x8]
80008a48:	c0 28       	rjmp	80008a4c <f_write+0x1ac>
80008a4a:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
80008a4c:	6e 28       	ld.w	r8,r7[0x8]
80008a4e:	6e 39       	ld.w	r9,r7[0xc]
80008a50:	12 38       	cp.w	r8,r9
80008a52:	ef f8 ba 03 	st.whi	r7[0xc],r8
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
80008a56:	0f e8       	ld.ub	r8,r7[0x6]
80008a58:	a5 b8       	sbr	r8,0x5
80008a5a:	ae e8       	st.b	r7[0x6],r8

	LEAVE_FF(fp->fs, FR_OK);
}
80008a5c:	04 9c       	mov	r12,r2
80008a5e:	2f dd       	sub	sp,-12
80008a60:	d8 32       	popm	r0-r7,pc
80008a62:	00 00       	add	r0,r0
80008a64:	80 00       	ld.sh	r0,r0[0x0]
80008a66:	6e cc       	ld.w	r12,r7[0x30]
80008a68:	80 00       	ld.sh	r0,r0[0x0]
80008a6a:	77 c0       	ld.w	r0,r11[0x70]
80008a6c:	80 00       	ld.sh	r0,r0[0x0]
80008a6e:	65 cc       	ld.w	r12,r2[0x70]
80008a70:	80 00       	ld.sh	r0,r0[0x0]
80008a72:	65 40       	ld.w	r0,r2[0x50]
80008a74:	80 00       	ld.sh	r0,r0[0x0]
80008a76:	65 b4       	ld.w	r4,r2[0x6c]
80008a78:	80 00       	ld.sh	r0,r0[0x0]
80008a7a:	65 78       	ld.w	r8,r2[0x5c]
80008a7c:	80 00       	ld.sh	r0,r0[0x0]
80008a7e:	65 5c       	ld.w	r12,r2[0x54]

80008a80 <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
80008a80:	d4 31       	pushm	r0-r7,lr
80008a82:	20 3d       	sub	sp,12
80008a84:	18 97       	mov	r7,r12
80008a86:	16 93       	mov	r3,r11
80008a88:	14 96       	mov	r6,r10
80008a8a:	12 94       	mov	r4,r9
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
80008a8c:	30 08       	mov	r8,0
80008a8e:	93 08       	st.w	r9[0x0],r8

	res = validate(fp);							/* Check validity */
80008a90:	f0 1f 00 5e 	mcall	80008c08 <f_read+0x188>
80008a94:	18 92       	mov	r2,r12
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
80008a96:	e0 81 00 b5 	brne	80008c00 <f_read+0x180>
	if (fp->err)								/* Check error */
80008a9a:	0f f8       	ld.ub	r8,r7[0x7]
80008a9c:	58 08       	cp.w	r8,0
80008a9e:	c0 30       	breq	80008aa4 <f_read+0x24>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
80008aa0:	10 92       	mov	r2,r8
80008aa2:	ca f8       	rjmp	80008c00 <f_read+0x180>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
80008aa4:	0f e8       	ld.ub	r8,r7[0x6]
80008aa6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008aaa:	e0 80 00 a8 	breq	80008bfa <f_read+0x17a>
80008aae:	6e 35       	ld.w	r5,r7[0xc]
80008ab0:	6e 28       	ld.w	r8,r7[0x8]
80008ab2:	10 15       	sub	r5,r8
80008ab4:	0a 36       	cp.w	r6,r5
80008ab6:	ec 05 17 80 	movls	r5,r6
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
80008aba:	58 05       	cp.w	r5,0
80008abc:	e0 80 00 a2 	breq	80008c00 <f_read+0x180>
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008ac0:	ee c8 ff d8 	sub	r8,r7,-40
80008ac4:	50 08       	stdsp	sp[0x0],r8
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008ac6:	50 18       	stdsp	sp[0x4],r8
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008ac8:	50 2c       	stdsp	sp[0x8],r12
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
80008aca:	6e 2b       	ld.w	r11,r7[0x8]
80008acc:	f1 db c0 09 	bfextu	r8,r11,0x0,0x9
80008ad0:	c7 b1       	brne	80008bc6 <f_read+0x146>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
80008ad2:	6e 0c       	ld.w	r12,r7[0x0]
80008ad4:	19 a6       	ld.ub	r6,r12[0x2]
80008ad6:	20 16       	sub	r6,1
80008ad8:	ed eb 02 96 	and	r6,r6,r11>>0x9
80008adc:	5c 56       	castu.b	r6
			if (!csect) {						/* On the cluster boundary? */
80008ade:	c1 d1       	brne	80008b18 <f_read+0x98>
				if (fp->fptr == 0) {			/* On the top of the file? */
80008ae0:	58 0b       	cp.w	r11,0
80008ae2:	c0 31       	brne	80008ae8 <f_read+0x68>
					clst = fp->sclust;			/* Follow from the origin */
80008ae4:	6e 4c       	ld.w	r12,r7[0x10]
80008ae6:	c0 b8       	rjmp	80008afc <f_read+0x7c>
				} else {						/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl)
80008ae8:	6e 98       	ld.w	r8,r7[0x24]
80008aea:	58 08       	cp.w	r8,0
80008aec:	c0 50       	breq	80008af6 <f_read+0x76>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
80008aee:	0e 9c       	mov	r12,r7
80008af0:	f0 1f 00 47 	mcall	80008c0c <f_read+0x18c>
80008af4:	c0 48       	rjmp	80008afc <f_read+0x7c>
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
80008af6:	6e 5b       	ld.w	r11,r7[0x14]
80008af8:	f0 1f 00 46 	mcall	80008c10 <f_read+0x190>
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
80008afc:	58 1c       	cp.w	r12,1
80008afe:	e0 8b 00 06 	brhi	80008b0a <f_read+0x8a>
80008b02:	30 28       	mov	r8,2
80008b04:	ae f8       	st.b	r7[0x7],r8
80008b06:	30 22       	mov	r2,2
80008b08:	c7 c8       	rjmp	80008c00 <f_read+0x180>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
80008b0a:	5b fc       	cp.w	r12,-1
80008b0c:	c0 51       	brne	80008b16 <f_read+0x96>
80008b0e:	30 18       	mov	r8,1
80008b10:	ae f8       	st.b	r7[0x7],r8
80008b12:	30 12       	mov	r2,1
80008b14:	c7 68       	rjmp	80008c00 <f_read+0x180>
				fp->clust = clst;				/* Update current cluster */
80008b16:	8f 5c       	st.w	r7[0x14],r12
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
80008b18:	6e 01       	ld.w	r1,r7[0x0]
80008b1a:	6e 5b       	ld.w	r11,r7[0x14]
80008b1c:	02 9c       	mov	r12,r1
80008b1e:	f0 1f 00 3e 	mcall	80008c14 <f_read+0x194>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
80008b22:	c0 51       	brne	80008b2c <f_read+0xac>
80008b24:	30 28       	mov	r8,2
80008b26:	ae f8       	st.b	r7[0x7],r8
80008b28:	30 22       	mov	r2,2
80008b2a:	c6 b8       	rjmp	80008c00 <f_read+0x180>
			sect += csect;
80008b2c:	f8 06 00 00 	add	r0,r12,r6
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
80008b30:	ea 02 16 09 	lsr	r2,r5,0x9
			if (cc) {							/* Read maximum contiguous sectors directly */
80008b34:	c2 80       	breq	80008b84 <f_read+0x104>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
80008b36:	03 a9       	ld.ub	r9,r1[0x2]
80008b38:	e4 06 00 08 	add	r8,r2,r6
					cc = fp->fs->csize - csect;
80008b3c:	12 38       	cp.w	r8,r9
80008b3e:	f3 d6 eb 12 	subhi	r2,r9,r6
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
80008b42:	04 99       	mov	r9,r2
80008b44:	00 9a       	mov	r10,r0
80008b46:	06 9b       	mov	r11,r3
80008b48:	03 9c       	ld.ub	r12,r1[0x1]
80008b4a:	f0 1f 00 34 	mcall	80008c18 <f_read+0x198>
80008b4e:	c0 50       	breq	80008b58 <f_read+0xd8>
					ABORT(fp->fs, FR_DISK_ERR);
80008b50:	30 18       	mov	r8,1
80008b52:	ae f8       	st.b	r7[0x7],r8
80008b54:	30 12       	mov	r2,1
80008b56:	c5 58       	rjmp	80008c00 <f_read+0x180>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
80008b58:	0f e8       	ld.ub	r8,r7[0x6]
80008b5a:	e2 18 00 40 	andl	r8,0x40,COH
80008b5e:	c1 00       	breq	80008b7e <f_read+0xfe>
80008b60:	6e 6c       	ld.w	r12,r7[0x18]
80008b62:	f8 00 01 00 	sub	r0,r12,r0
80008b66:	00 32       	cp.w	r2,r0
80008b68:	e0 88 00 0b 	brls	80008b7e <f_read+0xfe>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
80008b6c:	e0 0c 15 09 	lsl	r12,r0,0x9
80008b70:	e0 6a 02 00 	mov	r10,512
80008b74:	40 0b       	lddsp	r11,sp[0x0]
80008b76:	e6 0c 00 0c 	add	r12,r3,r12
80008b7a:	f0 1f 00 29 	mcall	80008c1c <f_read+0x19c>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
80008b7e:	e4 06 15 09 	lsl	r6,r2,0x9
				continue;
80008b82:	c3 28       	rjmp	80008be6 <f_read+0x166>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
80008b84:	6e 6a       	ld.w	r10,r7[0x18]
80008b86:	00 3a       	cp.w	r10,r0
80008b88:	c1 e0       	breq	80008bc4 <f_read+0x144>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
80008b8a:	0f e8       	ld.ub	r8,r7[0x6]
80008b8c:	e2 18 00 40 	andl	r8,0x40,COH
80008b90:	c0 e0       	breq	80008bac <f_read+0x12c>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
80008b92:	30 19       	mov	r9,1
80008b94:	40 1b       	lddsp	r11,sp[0x4]
80008b96:	03 9c       	ld.ub	r12,r1[0x1]
80008b98:	f0 1f 00 22 	mcall	80008c20 <f_read+0x1a0>
80008b9c:	c0 50       	breq	80008ba6 <f_read+0x126>
						ABORT(fp->fs, FR_DISK_ERR);
80008b9e:	30 18       	mov	r8,1
80008ba0:	ae f8       	st.b	r7[0x7],r8
80008ba2:	30 12       	mov	r2,1
80008ba4:	c2 e8       	rjmp	80008c00 <f_read+0x180>
					fp->flag &= ~FA__DIRTY;
80008ba6:	0f e8       	ld.ub	r8,r7[0x6]
80008ba8:	a7 c8       	cbr	r8,0x6
80008baa:	ae e8       	st.b	r7[0x6],r8
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
80008bac:	6e 08       	ld.w	r8,r7[0x0]
80008bae:	30 19       	mov	r9,1
80008bb0:	00 9a       	mov	r10,r0
80008bb2:	40 1b       	lddsp	r11,sp[0x4]
80008bb4:	11 9c       	ld.ub	r12,r8[0x1]
80008bb6:	f0 1f 00 19 	mcall	80008c18 <f_read+0x198>
80008bba:	c0 50       	breq	80008bc4 <f_read+0x144>
					ABORT(fp->fs, FR_DISK_ERR);
80008bbc:	30 18       	mov	r8,1
80008bbe:	ae f8       	st.b	r7[0x7],r8
80008bc0:	30 12       	mov	r2,1
80008bc2:	c1 f8       	rjmp	80008c00 <f_read+0x180>
			}
#endif
			fp->dsect = sect;
80008bc4:	8f 60       	st.w	r7[0x18],r0
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
80008bc6:	6e 2b       	ld.w	r11,r7[0x8]
80008bc8:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80008bcc:	e0 66 02 00 	mov	r6,512
80008bd0:	16 16       	sub	r6,r11
80008bd2:	0c 35       	cp.w	r5,r6
80008bd4:	ea 06 17 80 	movls	r6,r5
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
80008bd8:	0c 9a       	mov	r10,r6
80008bda:	40 08       	lddsp	r8,sp[0x0]
80008bdc:	f0 0b 00 0b 	add	r11,r8,r11
80008be0:	06 9c       	mov	r12,r3
80008be2:	f0 1f 00 0f 	mcall	80008c1c <f_read+0x19c>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
80008be6:	6e 28       	ld.w	r8,r7[0x8]
80008be8:	0c 08       	add	r8,r6
80008bea:	8f 28       	st.w	r7[0x8],r8
80008bec:	68 08       	ld.w	r8,r4[0x0]
80008bee:	0c 08       	add	r8,r6
80008bf0:	89 08       	st.w	r4[0x0],r8
80008bf2:	0c 15       	sub	r5,r6
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
80008bf4:	c0 50       	breq	80008bfe <f_read+0x17e>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
80008bf6:	0c 03       	add	r3,r6
80008bf8:	c6 9b       	rjmp	80008aca <f_read+0x4a>
80008bfa:	30 72       	mov	r2,7
80008bfc:	c0 28       	rjmp	80008c00 <f_read+0x180>
80008bfe:	40 22       	lddsp	r2,sp[0x8]
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
80008c00:	04 9c       	mov	r12,r2
80008c02:	2f dd       	sub	sp,-12
80008c04:	d8 32       	popm	r0-r7,pc
80008c06:	00 00       	add	r0,r0
80008c08:	80 00       	ld.sh	r0,r0[0x0]
80008c0a:	6e cc       	ld.w	r12,r7[0x30]
80008c0c:	80 00       	ld.sh	r0,r0[0x0]
80008c0e:	65 cc       	ld.w	r12,r2[0x70]
80008c10:	80 00       	ld.sh	r0,r0[0x0]
80008c12:	76 28       	ld.w	r8,r11[0x8]
80008c14:	80 00       	ld.sh	r0,r0[0x0]
80008c16:	65 b4       	ld.w	r4,r2[0x6c]
80008c18:	80 00       	ld.sh	r0,r0[0x0]
80008c1a:	65 5c       	ld.w	r12,r2[0x54]
80008c1c:	80 00       	ld.sh	r0,r0[0x0]
80008c1e:	65 78       	ld.w	r8,r2[0x5c]
80008c20:	80 00       	ld.sh	r0,r0[0x0]
80008c22:	65 40       	ld.w	r0,r2[0x50]

80008c24 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80008c24:	f8 c8 ff f8 	sub	r8,r12,-8
80008c28:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80008c2a:	3f f9       	mov	r9,-1
80008c2c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80008c2e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80008c30:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80008c32:	30 08       	mov	r8,0
80008c34:	99 08       	st.w	r12[0x0],r8
}
80008c36:	5e fc       	retal	r12

80008c38 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80008c38:	30 08       	mov	r8,0
80008c3a:	99 48       	st.w	r12[0x10],r8
}
80008c3c:	5e fc       	retal	r12

80008c3e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80008c3e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80008c40:	70 19       	ld.w	r9,r8[0x4]
80008c42:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80008c44:	78 19       	ld.w	r9,r12[0x4]
80008c46:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008c48:	70 19       	ld.w	r9,r8[0x4]
80008c4a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80008c4c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80008c4e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008c50:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80008c52:	78 08       	ld.w	r8,r12[0x0]
80008c54:	2f f8       	sub	r8,-1
80008c56:	99 08       	st.w	r12[0x0],r8
}
80008c58:	5e fc       	retal	r12

80008c5a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80008c5a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80008c5c:	5b fa       	cp.w	r10,-1
80008c5e:	c0 31       	brne	80008c64 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80008c60:	78 48       	ld.w	r8,r12[0x10]
80008c62:	c0 c8       	rjmp	80008c7a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80008c64:	f8 c8 ff f8 	sub	r8,r12,-8
80008c68:	70 19       	ld.w	r9,r8[0x4]
80008c6a:	72 09       	ld.w	r9,r9[0x0]
80008c6c:	12 3a       	cp.w	r10,r9
80008c6e:	c0 63       	brcs	80008c7a <vListInsert+0x20>
80008c70:	70 18       	ld.w	r8,r8[0x4]
80008c72:	70 19       	ld.w	r9,r8[0x4]
80008c74:	72 09       	ld.w	r9,r9[0x0]
80008c76:	12 3a       	cp.w	r10,r9
80008c78:	cf c2       	brcc	80008c70 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80008c7a:	70 19       	ld.w	r9,r8[0x4]
80008c7c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008c7e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80008c80:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80008c82:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008c84:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80008c86:	78 08       	ld.w	r8,r12[0x0]
80008c88:	2f f8       	sub	r8,-1
80008c8a:	99 08       	st.w	r12[0x0],r8
}
80008c8c:	5e fc       	retal	r12

80008c8e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80008c8e:	78 18       	ld.w	r8,r12[0x4]
80008c90:	78 29       	ld.w	r9,r12[0x8]
80008c92:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80008c94:	78 28       	ld.w	r8,r12[0x8]
80008c96:	78 19       	ld.w	r9,r12[0x4]
80008c98:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80008c9a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80008c9c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80008c9e:	18 39       	cp.w	r9,r12
80008ca0:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80008ca4:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80008ca8:	30 09       	mov	r9,0
80008caa:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80008cac:	70 09       	ld.w	r9,r8[0x0]
80008cae:	20 19       	sub	r9,1
80008cb0:	91 09       	st.w	r8[0x0],r9
}
80008cb2:	5e fc       	retal	r12

80008cb4 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80008cb4:	e0 68 08 08 	mov	r8,2056
80008cb8:	ea 18 08 08 	orh	r8,0x808
80008cbc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80008cbe:	e0 68 09 09 	mov	r8,2313
80008cc2:	ea 18 09 09 	orh	r8,0x909
80008cc6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80008cc8:	e0 68 0a 0a 	mov	r8,2570
80008ccc:	ea 18 0a 0a 	orh	r8,0xa0a
80008cd0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80008cd2:	e0 68 0b 0b 	mov	r8,2827
80008cd6:	ea 18 0b 0b 	orh	r8,0xb0b
80008cda:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80008cdc:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80008cde:	e0 68 be ef 	mov	r8,48879
80008ce2:	ea 18 de ad 	orh	r8,0xdead
80008ce6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80008ce8:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80008cea:	fc 18 00 40 	movh	r8,0x40
80008cee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80008cf0:	e0 68 00 ff 	mov	r8,255
80008cf4:	ea 18 ff 00 	orh	r8,0xff00
80008cf8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80008cfa:	e0 68 01 01 	mov	r8,257
80008cfe:	ea 18 01 01 	orh	r8,0x101
80008d02:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80008d04:	e0 68 02 02 	mov	r8,514
80008d08:	ea 18 02 02 	orh	r8,0x202
80008d0c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80008d0e:	e0 68 03 03 	mov	r8,771
80008d12:	ea 18 03 03 	orh	r8,0x303
80008d16:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80008d18:	e0 68 04 04 	mov	r8,1028
80008d1c:	ea 18 04 04 	orh	r8,0x404
80008d20:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80008d22:	e0 68 05 05 	mov	r8,1285
80008d26:	ea 18 05 05 	orh	r8,0x505
80008d2a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80008d2c:	e0 68 06 06 	mov	r8,1542
80008d30:	ea 18 06 06 	orh	r8,0x606
80008d34:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80008d36:	e0 68 07 07 	mov	r8,1799
80008d3a:	ea 18 07 07 	orh	r8,0x707
80008d3e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80008d40:	30 08       	mov	r8,0
80008d42:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80008d44:	5e fc       	retal	r12
80008d46:	d7 03       	nop

80008d48 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80008d48:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80008d4a:	48 38       	lddpc	r8,80008d54 <vPortEnterCritical+0xc>
80008d4c:	70 09       	ld.w	r9,r8[0x0]
80008d4e:	2f f9       	sub	r9,-1
80008d50:	91 09       	st.w	r8[0x0],r9
}
80008d52:	5e fc       	retal	r12
80008d54:	00 00       	add	r0,r0
80008d56:	05 30       	ld.ub	r0,r2++

80008d58 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80008d58:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80008d5a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80008d5c:	30 0a       	mov	r10,0
80008d5e:	14 9b       	mov	r11,r10
80008d60:	49 2c       	lddpc	r12,80008da8 <xPortStartScheduler+0x50>
80008d62:	f0 1f 00 13 	mcall	80008dac <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80008d66:	e0 68 5d c0 	mov	r8,24000
80008d6a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80008d6e:	30 08       	mov	r8,0
80008d70:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80008d74:	e0 68 12 ac 	mov	r8,4780
80008d78:	ea 18 00 00 	orh	r8,0x0
80008d7c:	70 00       	ld.w	r0,r8[0x0]
80008d7e:	60 0d       	ld.w	sp,r0[0x0]
80008d80:	1b 00       	ld.w	r0,sp++
80008d82:	e0 68 05 30 	mov	r8,1328
80008d86:	ea 18 00 00 	orh	r8,0x0
80008d8a:	91 00       	st.w	r8[0x0],r0
80008d8c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008d90:	2f ed       	sub	sp,-8
80008d92:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80008d96:	fa f0 ff e0 	ld.w	r0,sp[-32]
80008d9a:	e3 b0 00 00 	mtsr	0x0,r0
80008d9e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80008da2:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80008da6:	d8 0a       	popm	pc,r12=0
80008da8:	80 00       	ld.sh	r0,r0[0x0]
80008daa:	8e 74       	ld.sh	r4,r7[0xe]
80008dac:	80 00       	ld.sh	r0,r0[0x0]
80008dae:	5c 74       	castu.h	r4

80008db0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80008db0:	20 6d       	sub	sp,24
80008db2:	eb cd 00 ff 	pushm	r0-r7
80008db6:	fa c7 ff c0 	sub	r7,sp,-64
80008dba:	ee f0 ff f8 	ld.w	r0,r7[-8]
80008dbe:	ef 40 ff e0 	st.w	r7[-32],r0
80008dc2:	ee f0 ff fc 	ld.w	r0,r7[-4]
80008dc6:	ef 40 ff e4 	st.w	r7[-28],r0
80008dca:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80008dce:	e0 68 05 30 	mov	r8,1328
80008dd2:	ea 18 00 00 	orh	r8,0x0
80008dd6:	70 00       	ld.w	r0,r8[0x0]
80008dd8:	1a d0       	st.w	--sp,r0
80008dda:	f0 1f 00 1a 	mcall	80008e40 <LABEL_RET_SCALL_263+0x14>
80008dde:	e0 68 12 ac 	mov	r8,4780
80008de2:	ea 18 00 00 	orh	r8,0x0
80008de6:	70 00       	ld.w	r0,r8[0x0]
80008de8:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80008dea:	f0 1f 00 17 	mcall	80008e44 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80008dee:	e0 68 12 ac 	mov	r8,4780
80008df2:	ea 18 00 00 	orh	r8,0x0
80008df6:	70 00       	ld.w	r0,r8[0x0]
80008df8:	60 0d       	ld.w	sp,r0[0x0]
80008dfa:	1b 00       	ld.w	r0,sp++
80008dfc:	e0 68 05 30 	mov	r8,1328
80008e00:	ea 18 00 00 	orh	r8,0x0
80008e04:	91 00       	st.w	r8[0x0],r0
80008e06:	fa c7 ff d8 	sub	r7,sp,-40
80008e0a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80008e0e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80008e12:	e0 61 05 30 	mov	r1,1328
80008e16:	ea 11 00 00 	orh	r1,0x0
80008e1a:	62 02       	ld.w	r2,r1[0x0]
80008e1c:	58 02       	cp.w	r2,0
80008e1e:	c0 70       	breq	80008e2c <LABEL_RET_SCALL_263>
80008e20:	e4 c2 00 01 	sub	r2,r2,1
80008e24:	83 02       	st.w	r1[0x0],r2
80008e26:	58 02       	cp.w	r2,0
80008e28:	c0 21       	brne	80008e2c <LABEL_RET_SCALL_263>
80008e2a:	b1 c0       	cbr	r0,0x10

80008e2c <LABEL_RET_SCALL_263>:
80008e2c:	ef 40 ff f8 	st.w	r7[-8],r0
80008e30:	ee f0 ff e4 	ld.w	r0,r7[-28]
80008e34:	ef 40 ff fc 	st.w	r7[-4],r0
80008e38:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008e3c:	2f ad       	sub	sp,-24
80008e3e:	d6 13       	rets
80008e40:	80 00       	ld.sh	r0,r0[0x0]
80008e42:	8d 48       	st.w	r6[0x10],r8
80008e44:	80 00       	ld.sh	r0,r0[0x0]
80008e46:	94 e4       	ld.uh	r4,r10[0xc]

80008e48 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80008e48:	e1 b8 00 43 	mfsr	r8,0x10c
80008e4c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80008e50:	5e fc       	retal	r12
80008e52:	d7 03       	nop

80008e54 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80008e54:	48 78       	lddpc	r8,80008e70 <vPortExitCritical+0x1c>
80008e56:	70 08       	ld.w	r8,r8[0x0]
80008e58:	58 08       	cp.w	r8,0
80008e5a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80008e5c:	48 58       	lddpc	r8,80008e70 <vPortExitCritical+0x1c>
80008e5e:	70 09       	ld.w	r9,r8[0x0]
80008e60:	20 19       	sub	r9,1
80008e62:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80008e64:	70 08       	ld.w	r8,r8[0x0]
80008e66:	58 08       	cp.w	r8,0
80008e68:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80008e6a:	d5 03       	csrf	0x10
80008e6c:	5e fc       	retal	r12
80008e6e:	00 00       	add	r0,r0
80008e70:	00 00       	add	r0,r0
80008e72:	05 30       	ld.ub	r0,r2++

80008e74 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80008e74:	eb cd 00 ff 	pushm	r0-r7
80008e78:	e0 68 05 30 	mov	r8,1328
80008e7c:	ea 18 00 00 	orh	r8,0x0
80008e80:	70 00       	ld.w	r0,r8[0x0]
80008e82:	1a d0       	st.w	--sp,r0
80008e84:	7a 90       	ld.w	r0,sp[0x24]
80008e86:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008e8a:	58 10       	cp.w	r0,1
80008e8c:	e0 8b 00 08 	brhi	80008e9c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80008e90:	e0 68 12 ac 	mov	r8,4780
80008e94:	ea 18 00 00 	orh	r8,0x0
80008e98:	70 00       	ld.w	r0,r8[0x0]
80008e9a:	81 0d       	st.w	r0[0x0],sp

80008e9c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80008e9c:	f0 1f 00 12 	mcall	80008ee4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80008ea0:	f0 1f 00 12 	mcall	80008ee8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80008ea4:	f0 1f 00 12 	mcall	80008eec <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80008ea8:	f0 1f 00 12 	mcall	80008ef0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80008eac:	7a 90       	ld.w	r0,sp[0x24]
80008eae:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008eb2:	58 10       	cp.w	r0,1
80008eb4:	e0 8b 00 0e 	brhi	80008ed0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80008eb8:	f0 1f 00 0c 	mcall	80008ee8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80008ebc:	f0 1f 00 0e 	mcall	80008ef4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80008ec0:	f0 1f 00 0c 	mcall	80008ef0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80008ec4:	e0 68 12 ac 	mov	r8,4780
80008ec8:	ea 18 00 00 	orh	r8,0x0
80008ecc:	70 00       	ld.w	r0,r8[0x0]
80008ece:	60 0d       	ld.w	sp,r0[0x0]

80008ed0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80008ed0:	1b 00       	ld.w	r0,sp++
80008ed2:	e0 68 05 30 	mov	r8,1328
80008ed6:	ea 18 00 00 	orh	r8,0x0
80008eda:	91 00       	st.w	r8[0x0],r0
80008edc:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008ee0:	d6 03       	rete
80008ee2:	00 00       	add	r0,r0
80008ee4:	80 00       	ld.sh	r0,r0[0x0]
80008ee6:	8e 48       	ld.sh	r8,r7[0x8]
80008ee8:	80 00       	ld.sh	r0,r0[0x0]
80008eea:	8d 48       	st.w	r6[0x10],r8
80008eec:	80 00       	ld.sh	r0,r0[0x0]
80008eee:	96 e8       	ld.uh	r8,r11[0xc]
80008ef0:	80 00       	ld.sh	r0,r0[0x0]
80008ef2:	8e 54       	ld.sh	r4,r7[0xa]
80008ef4:	80 00       	ld.sh	r0,r0[0x0]
80008ef6:	94 e4       	ld.uh	r4,r10[0xc]

80008ef8 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80008ef8:	d4 01       	pushm	lr
	vTaskSuspendAll();
80008efa:	f0 1f 00 02 	mcall	80008f00 <__malloc_lock+0x8>
}
80008efe:	d8 02       	popm	pc
80008f00:	80 00       	ld.sh	r0,r0[0x0]
80008f02:	94 d4       	ld.uh	r4,r10[0xa]

80008f04 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80008f04:	d4 01       	pushm	lr
	xTaskResumeAll();
80008f06:	f0 1f 00 02 	mcall	80008f0c <__malloc_unlock+0x8>
}
80008f0a:	d8 02       	popm	pc
80008f0c:	80 00       	ld.sh	r0,r0[0x0]
80008f0e:	98 90       	ld.uh	r0,r12[0x2]

80008f10 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80008f10:	d4 21       	pushm	r4-r7,lr
80008f12:	16 95       	mov	r5,r11
80008f14:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80008f16:	58 0c       	cp.w	r12,0
80008f18:	c0 30       	breq	80008f1e <_read+0xe>
80008f1a:	3f f7       	mov	r7,-1
80008f1c:	c1 48       	rjmp	80008f44 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80008f1e:	58 0a       	cp.w	r10,0
80008f20:	e0 89 00 04 	brgt	80008f28 <_read+0x18>
80008f24:	30 07       	mov	r7,0
80008f26:	c0 f8       	rjmp	80008f44 <_read+0x34>
80008f28:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80008f2a:	48 84       	lddpc	r4,80008f48 <_read+0x38>
80008f2c:	68 0c       	ld.w	r12,r4[0x0]
80008f2e:	f0 1f 00 08 	mcall	80008f4c <_read+0x3c>
    if (c < 0)
80008f32:	c0 95       	brlt	80008f44 <_read+0x34>
      break;

    *ptr++ = c;
80008f34:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80008f38:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80008f3a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80008f3e:	58 08       	cp.w	r8,0
80008f40:	fe 99 ff f6 	brgt	80008f2c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80008f44:	0e 9c       	mov	r12,r7
80008f46:	d8 22       	popm	r4-r7,pc
80008f48:	00 00       	add	r0,r0
80008f4a:	46 a8       	lddsp	r8,sp[0x1a8]
80008f4c:	80 00       	ld.sh	r0,r0[0x0]
80008f4e:	63 68       	ld.w	r8,r1[0x58]

80008f50 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80008f50:	d4 21       	pushm	r4-r7,lr
80008f52:	16 95       	mov	r5,r11
80008f54:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80008f56:	20 1c       	sub	r12,1
80008f58:	58 2c       	cp.w	r12,2
80008f5a:	e0 8b 00 12 	brhi	80008f7e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008f5e:	58 0a       	cp.w	r10,0
80008f60:	c0 31       	brne	80008f66 <_write+0x16>
80008f62:	30 07       	mov	r7,0
80008f64:	c0 e8       	rjmp	80008f80 <_write+0x30>
80008f66:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80008f68:	48 74       	lddpc	r4,80008f84 <_write+0x34>
80008f6a:	68 0c       	ld.w	r12,r4[0x0]
80008f6c:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80008f70:	f0 1f 00 06 	mcall	80008f88 <_write+0x38>
80008f74:	c0 55       	brlt	80008f7e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80008f76:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80008f78:	0e 36       	cp.w	r6,r7
80008f7a:	cf 81       	brne	80008f6a <_write+0x1a>
80008f7c:	c0 28       	rjmp	80008f80 <_write+0x30>
80008f7e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80008f80:	0e 9c       	mov	r12,r7
80008f82:	d8 22       	popm	r4-r7,pc
80008f84:	00 00       	add	r0,r0
80008f86:	46 a8       	lddsp	r8,sp[0x1a8]
80008f88:	80 00       	ld.sh	r0,r0[0x0]
80008f8a:	63 18       	ld.w	r8,r1[0x44]

80008f8c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80008f8c:	eb cd 40 80 	pushm	r7,lr
80008f90:	18 97       	mov	r7,r12
	if( pv )
80008f92:	58 0c       	cp.w	r12,0
80008f94:	c0 80       	breq	80008fa4 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80008f96:	f0 1f 00 05 	mcall	80008fa8 <vPortFree+0x1c>
		{
			free( pv );
80008f9a:	0e 9c       	mov	r12,r7
80008f9c:	f0 1f 00 04 	mcall	80008fac <vPortFree+0x20>
		}
		xTaskResumeAll();
80008fa0:	f0 1f 00 04 	mcall	80008fb0 <vPortFree+0x24>
80008fa4:	e3 cd 80 80 	ldm	sp++,r7,pc
80008fa8:	80 00       	ld.sh	r0,r0[0x0]
80008faa:	94 d4       	ld.uh	r4,r10[0xa]
80008fac:	80 00       	ld.sh	r0,r0[0x0]
80008fae:	a4 40       	st.h	r2[0x8],r0
80008fb0:	80 00       	ld.sh	r0,r0[0x0]
80008fb2:	98 90       	ld.uh	r0,r12[0x2]

80008fb4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80008fb4:	eb cd 40 80 	pushm	r7,lr
80008fb8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80008fba:	f0 1f 00 06 	mcall	80008fd0 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80008fbe:	0e 9c       	mov	r12,r7
80008fc0:	f0 1f 00 05 	mcall	80008fd4 <pvPortMalloc+0x20>
80008fc4:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80008fc6:	f0 1f 00 05 	mcall	80008fd8 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80008fca:	0e 9c       	mov	r12,r7
80008fcc:	e3 cd 80 80 	ldm	sp++,r7,pc
80008fd0:	80 00       	ld.sh	r0,r0[0x0]
80008fd2:	94 d4       	ld.uh	r4,r10[0xa]
80008fd4:	80 00       	ld.sh	r0,r0[0x0]
80008fd6:	a4 50       	st.h	r2[0xa],r0
80008fd8:	80 00       	ld.sh	r0,r0[0x0]
80008fda:	98 90       	ld.uh	r0,r12[0x2]

80008fdc <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80008fdc:	d4 01       	pushm	lr
80008fde:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80008fe0:	78 09       	ld.w	r9,r12[0x0]
80008fe2:	58 09       	cp.w	r9,0
80008fe4:	c1 10       	breq	80009006 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80008fe6:	78 3a       	ld.w	r10,r12[0xc]
80008fe8:	79 09       	ld.w	r9,r12[0x40]
80008fea:	f4 09 00 09 	add	r9,r10,r9
80008fee:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80008ff0:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80008ff2:	14 39       	cp.w	r9,r10
80008ff4:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80008ff8:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80008ffc:	79 0a       	ld.w	r10,r12[0x40]
80008ffe:	78 3b       	ld.w	r11,r12[0xc]
80009000:	10 9c       	mov	r12,r8
80009002:	f0 1f 00 02 	mcall	80009008 <prvCopyDataFromQueue+0x2c>
80009006:	d8 02       	popm	pc
80009008:	80 00       	ld.sh	r0,r0[0x0]
8000900a:	a8 be       	st.b	r4[0x3],lr

8000900c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
8000900c:	eb cd 40 c0 	pushm	r6-r7,lr
80009010:	18 97       	mov	r7,r12
80009012:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80009014:	78 e8       	ld.w	r8,r12[0x38]
80009016:	58 08       	cp.w	r8,0
80009018:	c0 31       	brne	8000901e <xQueueReceiveFromISR+0x12>
8000901a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8000901e:	f0 1f 00 0e 	mcall	80009054 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80009022:	6e e8       	ld.w	r8,r7[0x38]
80009024:	20 18       	sub	r8,1
80009026:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80009028:	6f 18       	ld.w	r8,r7[0x44]
8000902a:	5b f8       	cp.w	r8,-1
8000902c:	c0 d1       	brne	80009046 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000902e:	6e 48       	ld.w	r8,r7[0x10]
80009030:	58 08       	cp.w	r8,0
80009032:	c0 f0       	breq	80009050 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80009034:	ee cc ff f0 	sub	r12,r7,-16
80009038:	f0 1f 00 08 	mcall	80009058 <xQueueReceiveFromISR+0x4c>
8000903c:	c0 a0       	breq	80009050 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000903e:	30 1c       	mov	r12,1
80009040:	8d 0c       	st.w	r6[0x0],r12
80009042:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80009046:	2f f8       	sub	r8,-1
80009048:	ef 48 00 44 	st.w	r7[68],r8
8000904c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009050:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009054:	80 00       	ld.sh	r0,r0[0x0]
80009056:	8f dc       	st.w	r7[0x34],r12
80009058:	80 00       	ld.sh	r0,r0[0x0]
8000905a:	96 6c       	ld.sh	r12,r11[0xc]

8000905c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000905c:	eb cd 40 c0 	pushm	r6-r7,lr
80009060:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80009062:	f0 1f 00 23 	mcall	800090ec <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80009066:	6f 28       	ld.w	r8,r7[0x48]
80009068:	58 08       	cp.w	r8,0
8000906a:	e0 8a 00 18 	brle	8000909a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000906e:	6e 98       	ld.w	r8,r7[0x24]
80009070:	58 08       	cp.w	r8,0
80009072:	c1 40       	breq	8000909a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80009074:	ee c6 ff dc 	sub	r6,r7,-36
80009078:	c0 48       	rjmp	80009080 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000907a:	6e 98       	ld.w	r8,r7[0x24]
8000907c:	58 08       	cp.w	r8,0
8000907e:	c0 e0       	breq	8000909a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80009080:	0c 9c       	mov	r12,r6
80009082:	f0 1f 00 1c 	mcall	800090f0 <prvUnlockQueue+0x94>
80009086:	c0 30       	breq	8000908c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80009088:	f0 1f 00 1b 	mcall	800090f4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
8000908c:	6f 28       	ld.w	r8,r7[0x48]
8000908e:	20 18       	sub	r8,1
80009090:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80009094:	58 08       	cp.w	r8,0
80009096:	fe 99 ff f2 	brgt	8000907a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000909a:	3f f8       	mov	r8,-1
8000909c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800090a0:	f0 1f 00 16 	mcall	800090f8 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800090a4:	f0 1f 00 12 	mcall	800090ec <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800090a8:	6f 18       	ld.w	r8,r7[0x44]
800090aa:	58 08       	cp.w	r8,0
800090ac:	e0 8a 00 18 	brle	800090dc <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800090b0:	6e 48       	ld.w	r8,r7[0x10]
800090b2:	58 08       	cp.w	r8,0
800090b4:	c1 40       	breq	800090dc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800090b6:	ee c6 ff f0 	sub	r6,r7,-16
800090ba:	c0 48       	rjmp	800090c2 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800090bc:	6e 48       	ld.w	r8,r7[0x10]
800090be:	58 08       	cp.w	r8,0
800090c0:	c0 e0       	breq	800090dc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800090c2:	0c 9c       	mov	r12,r6
800090c4:	f0 1f 00 0b 	mcall	800090f0 <prvUnlockQueue+0x94>
800090c8:	c0 30       	breq	800090ce <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800090ca:	f0 1f 00 0b 	mcall	800090f4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800090ce:	6f 18       	ld.w	r8,r7[0x44]
800090d0:	20 18       	sub	r8,1
800090d2:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800090d6:	58 08       	cp.w	r8,0
800090d8:	fe 99 ff f2 	brgt	800090bc <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800090dc:	3f f8       	mov	r8,-1
800090de:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800090e2:	f0 1f 00 06 	mcall	800090f8 <prvUnlockQueue+0x9c>
}
800090e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800090ea:	00 00       	add	r0,r0
800090ec:	80 00       	ld.sh	r0,r0[0x0]
800090ee:	8d 48       	st.w	r6[0x10],r8
800090f0:	80 00       	ld.sh	r0,r0[0x0]
800090f2:	96 6c       	ld.sh	r12,r11[0xc]
800090f4:	80 00       	ld.sh	r0,r0[0x0]
800090f6:	95 78       	st.w	r10[0x1c],r8
800090f8:	80 00       	ld.sh	r0,r0[0x0]
800090fa:	8e 54       	ld.sh	r4,r7[0xa]

800090fc <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800090fc:	d4 31       	pushm	r0-r7,lr
800090fe:	20 5d       	sub	sp,20
80009100:	18 97       	mov	r7,r12
80009102:	50 0b       	stdsp	sp[0x0],r11
80009104:	50 2a       	stdsp	sp[0x8],r10
80009106:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80009108:	f8 c2 ff dc 	sub	r2,r12,-36
8000910c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000910e:	fa c4 ff f4 	sub	r4,sp,-12
80009112:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80009114:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80009116:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000911a:	f0 1f 00 3e 	mcall	80009210 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000911e:	6e e8       	ld.w	r8,r7[0x38]
80009120:	58 08       	cp.w	r8,0
80009122:	c2 a0       	breq	80009176 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80009124:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80009126:	40 0b       	lddsp	r11,sp[0x0]
80009128:	0e 9c       	mov	r12,r7
8000912a:	f0 1f 00 3b 	mcall	80009214 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
8000912e:	40 18       	lddsp	r8,sp[0x4]
80009130:	58 08       	cp.w	r8,0
80009132:	c1 51       	brne	8000915c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80009134:	6e e8       	ld.w	r8,r7[0x38]
80009136:	20 18       	sub	r8,1
80009138:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000913a:	6e 08       	ld.w	r8,r7[0x0]
8000913c:	58 08       	cp.w	r8,0
8000913e:	c0 41       	brne	80009146 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80009140:	f0 1f 00 36 	mcall	80009218 <xQueueGenericReceive+0x11c>
80009144:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80009146:	6e 48       	ld.w	r8,r7[0x10]
80009148:	58 08       	cp.w	r8,0
8000914a:	c1 20       	breq	8000916e <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
8000914c:	ee cc ff f0 	sub	r12,r7,-16
80009150:	f0 1f 00 33 	mcall	8000921c <xQueueGenericReceive+0x120>
80009154:	58 1c       	cp.w	r12,1
80009156:	c0 c1       	brne	8000916e <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80009158:	d7 33       	scall
8000915a:	c0 a8       	rjmp	8000916e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000915c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000915e:	6e 98       	ld.w	r8,r7[0x24]
80009160:	58 08       	cp.w	r8,0
80009162:	c0 60       	breq	8000916e <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80009164:	04 9c       	mov	r12,r2
80009166:	f0 1f 00 2e 	mcall	8000921c <xQueueGenericReceive+0x120>
8000916a:	c0 20       	breq	8000916e <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000916c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000916e:	f0 1f 00 2d 	mcall	80009220 <xQueueGenericReceive+0x124>
80009172:	30 1c       	mov	r12,1
				return pdPASS;
80009174:	c4 c8       	rjmp	8000920c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80009176:	40 28       	lddsp	r8,sp[0x8]
80009178:	58 08       	cp.w	r8,0
8000917a:	c0 51       	brne	80009184 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000917c:	f0 1f 00 29 	mcall	80009220 <xQueueGenericReceive+0x124>
80009180:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80009182:	c4 58       	rjmp	8000920c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80009184:	58 05       	cp.w	r5,0
80009186:	c0 51       	brne	80009190 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80009188:	08 9c       	mov	r12,r4
8000918a:	f0 1f 00 27 	mcall	80009224 <xQueueGenericReceive+0x128>
8000918e:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80009190:	f0 1f 00 24 	mcall	80009220 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80009194:	f0 1f 00 25 	mcall	80009228 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80009198:	f0 1f 00 1e 	mcall	80009210 <xQueueGenericReceive+0x114>
8000919c:	6f 18       	ld.w	r8,r7[0x44]
8000919e:	5b f8       	cp.w	r8,-1
800091a0:	ef f1 0a 11 	st.weq	r7[0x44],r1
800091a4:	6f 28       	ld.w	r8,r7[0x48]
800091a6:	5b f8       	cp.w	r8,-1
800091a8:	ef f1 0a 12 	st.weq	r7[0x48],r1
800091ac:	f0 1f 00 1d 	mcall	80009220 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800091b0:	06 9b       	mov	r11,r3
800091b2:	08 9c       	mov	r12,r4
800091b4:	f0 1f 00 1e 	mcall	8000922c <xQueueGenericReceive+0x130>
800091b8:	c2 41       	brne	80009200 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800091ba:	f0 1f 00 16 	mcall	80009210 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800091be:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800091c0:	f0 1f 00 18 	mcall	80009220 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800091c4:	58 06       	cp.w	r6,0
800091c6:	c1 71       	brne	800091f4 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800091c8:	6e 08       	ld.w	r8,r7[0x0]
800091ca:	58 08       	cp.w	r8,0
800091cc:	c0 81       	brne	800091dc <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800091ce:	f0 1f 00 11 	mcall	80009210 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800091d2:	6e 1c       	ld.w	r12,r7[0x4]
800091d4:	f0 1f 00 17 	mcall	80009230 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800091d8:	f0 1f 00 12 	mcall	80009220 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800091dc:	40 2b       	lddsp	r11,sp[0x8]
800091de:	04 9c       	mov	r12,r2
800091e0:	f0 1f 00 15 	mcall	80009234 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800091e4:	0e 9c       	mov	r12,r7
800091e6:	f0 1f 00 15 	mcall	80009238 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800091ea:	f0 1f 00 15 	mcall	8000923c <xQueueGenericReceive+0x140>
800091ee:	c9 61       	brne	8000911a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800091f0:	d7 33       	scall
800091f2:	c9 4b       	rjmp	8000911a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800091f4:	0e 9c       	mov	r12,r7
800091f6:	f0 1f 00 11 	mcall	80009238 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800091fa:	f0 1f 00 11 	mcall	8000923c <xQueueGenericReceive+0x140>
800091fe:	c8 eb       	rjmp	8000911a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80009200:	0e 9c       	mov	r12,r7
80009202:	f0 1f 00 0e 	mcall	80009238 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80009206:	f0 1f 00 0e 	mcall	8000923c <xQueueGenericReceive+0x140>
8000920a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
8000920c:	2f bd       	sub	sp,-20
8000920e:	d8 32       	popm	r0-r7,pc
80009210:	80 00       	ld.sh	r0,r0[0x0]
80009212:	8d 48       	st.w	r6[0x10],r8
80009214:	80 00       	ld.sh	r0,r0[0x0]
80009216:	8f dc       	st.w	r7[0x34],r12
80009218:	80 00       	ld.sh	r0,r0[0x0]
8000921a:	95 84       	st.w	r10[0x20],r4
8000921c:	80 00       	ld.sh	r0,r0[0x0]
8000921e:	96 6c       	ld.sh	r12,r11[0xc]
80009220:	80 00       	ld.sh	r0,r0[0x0]
80009222:	8e 54       	ld.sh	r4,r7[0xa]
80009224:	80 00       	ld.sh	r0,r0[0x0]
80009226:	95 60       	st.w	r10[0x18],r0
80009228:	80 00       	ld.sh	r0,r0[0x0]
8000922a:	94 d4       	ld.uh	r4,r10[0xa]
8000922c:	80 00       	ld.sh	r0,r0[0x0]
8000922e:	97 fc       	st.w	r11[0x3c],r12
80009230:	80 00       	ld.sh	r0,r0[0x0]
80009232:	95 e8       	st.w	r10[0x38],r8
80009234:	80 00       	ld.sh	r0,r0[0x0]
80009236:	9a 54       	ld.sh	r4,sp[0xa]
80009238:	80 00       	ld.sh	r0,r0[0x0]
8000923a:	90 5c       	ld.sh	r12,r8[0xa]
8000923c:	80 00       	ld.sh	r0,r0[0x0]
8000923e:	98 90       	ld.uh	r0,r12[0x2]

80009240 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80009240:	eb cd 40 80 	pushm	r7,lr
80009244:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80009246:	79 08       	ld.w	r8,r12[0x40]
80009248:	58 08       	cp.w	r8,0
8000924a:	c0 a1       	brne	8000925e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000924c:	78 08       	ld.w	r8,r12[0x0]
8000924e:	58 08       	cp.w	r8,0
80009250:	c2 b1       	brne	800092a6 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80009252:	78 1c       	ld.w	r12,r12[0x4]
80009254:	f0 1f 00 17 	mcall	800092b0 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80009258:	30 08       	mov	r8,0
8000925a:	8f 18       	st.w	r7[0x4],r8
8000925c:	c2 58       	rjmp	800092a6 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000925e:	58 0a       	cp.w	r10,0
80009260:	c1 01       	brne	80009280 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80009262:	10 9a       	mov	r10,r8
80009264:	78 2c       	ld.w	r12,r12[0x8]
80009266:	f0 1f 00 14 	mcall	800092b4 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000926a:	6e 29       	ld.w	r9,r7[0x8]
8000926c:	6f 08       	ld.w	r8,r7[0x40]
8000926e:	f2 08 00 08 	add	r8,r9,r8
80009272:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80009274:	6e 19       	ld.w	r9,r7[0x4]
80009276:	12 38       	cp.w	r8,r9
80009278:	c1 73       	brcs	800092a6 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000927a:	6e 08       	ld.w	r8,r7[0x0]
8000927c:	8f 28       	st.w	r7[0x8],r8
8000927e:	c1 48       	rjmp	800092a6 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80009280:	10 9a       	mov	r10,r8
80009282:	78 3c       	ld.w	r12,r12[0xc]
80009284:	f0 1f 00 0c 	mcall	800092b4 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80009288:	6f 08       	ld.w	r8,r7[0x40]
8000928a:	6e 39       	ld.w	r9,r7[0xc]
8000928c:	f2 08 01 08 	sub	r8,r9,r8
80009290:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80009292:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80009294:	12 38       	cp.w	r8,r9
80009296:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000929a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000929e:	f3 d8 e3 19 	subcs	r9,r9,r8
800092a2:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800092a6:	6e e8       	ld.w	r8,r7[0x38]
800092a8:	2f f8       	sub	r8,-1
800092aa:	8f e8       	st.w	r7[0x38],r8
}
800092ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800092b0:	80 00       	ld.sh	r0,r0[0x0]
800092b2:	95 90       	st.w	r10[0x24],r0
800092b4:	80 00       	ld.sh	r0,r0[0x0]
800092b6:	a8 be       	st.b	r4[0x3],lr

800092b8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800092b8:	eb cd 40 c0 	pushm	r6-r7,lr
800092bc:	18 97       	mov	r7,r12
800092be:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800092c0:	78 ec       	ld.w	r12,r12[0x38]
800092c2:	6e f8       	ld.w	r8,r7[0x3c]
800092c4:	10 3c       	cp.w	r12,r8
800092c6:	c0 33       	brcs	800092cc <xQueueGenericSendFromISR+0x14>
800092c8:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800092cc:	12 9a       	mov	r10,r9
800092ce:	0e 9c       	mov	r12,r7
800092d0:	f0 1f 00 0c 	mcall	80009300 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800092d4:	6f 28       	ld.w	r8,r7[0x48]
800092d6:	5b f8       	cp.w	r8,-1
800092d8:	c0 d1       	brne	800092f2 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800092da:	6e 98       	ld.w	r8,r7[0x24]
800092dc:	58 08       	cp.w	r8,0
800092de:	c0 f0       	breq	800092fc <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800092e0:	ee cc ff dc 	sub	r12,r7,-36
800092e4:	f0 1f 00 08 	mcall	80009304 <xQueueGenericSendFromISR+0x4c>
800092e8:	c0 a0       	breq	800092fc <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800092ea:	30 1c       	mov	r12,1
800092ec:	8d 0c       	st.w	r6[0x0],r12
800092ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800092f2:	2f f8       	sub	r8,-1
800092f4:	ef 48 00 48 	st.w	r7[72],r8
800092f8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800092fc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80009300:	80 00       	ld.sh	r0,r0[0x0]
80009302:	92 40       	ld.sh	r0,r9[0x8]
80009304:	80 00       	ld.sh	r0,r0[0x0]
80009306:	96 6c       	ld.sh	r12,r11[0xc]

80009308 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80009308:	d4 31       	pushm	r0-r7,lr
8000930a:	20 5d       	sub	sp,20
8000930c:	18 97       	mov	r7,r12
8000930e:	50 0b       	stdsp	sp[0x0],r11
80009310:	50 2a       	stdsp	sp[0x8],r10
80009312:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80009314:	f8 c0 ff f0 	sub	r0,r12,-16
80009318:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000931a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000931e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80009320:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80009324:	f0 1f 00 2f 	mcall	800093e0 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80009328:	6e e9       	ld.w	r9,r7[0x38]
8000932a:	6e f8       	ld.w	r8,r7[0x3c]
8000932c:	10 39       	cp.w	r9,r8
8000932e:	c1 42       	brcc	80009356 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80009330:	40 1a       	lddsp	r10,sp[0x4]
80009332:	40 0b       	lddsp	r11,sp[0x0]
80009334:	0e 9c       	mov	r12,r7
80009336:	f0 1f 00 2c 	mcall	800093e4 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000933a:	6e 98       	ld.w	r8,r7[0x24]
8000933c:	58 08       	cp.w	r8,0
8000933e:	c0 80       	breq	8000934e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80009340:	ee cc ff dc 	sub	r12,r7,-36
80009344:	f0 1f 00 29 	mcall	800093e8 <xQueueGenericSend+0xe0>
80009348:	58 1c       	cp.w	r12,1
8000934a:	c0 21       	brne	8000934e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000934c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000934e:	f0 1f 00 28 	mcall	800093ec <xQueueGenericSend+0xe4>
80009352:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80009354:	c4 38       	rjmp	800093da <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80009356:	40 28       	lddsp	r8,sp[0x8]
80009358:	58 08       	cp.w	r8,0
8000935a:	c0 51       	brne	80009364 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000935c:	f0 1f 00 24 	mcall	800093ec <xQueueGenericSend+0xe4>
80009360:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80009362:	c3 c8       	rjmp	800093da <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80009364:	58 04       	cp.w	r4,0
80009366:	c0 51       	brne	80009370 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80009368:	06 9c       	mov	r12,r3
8000936a:	f0 1f 00 22 	mcall	800093f0 <xQueueGenericSend+0xe8>
8000936e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80009370:	f0 1f 00 1f 	mcall	800093ec <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80009374:	f0 1f 00 20 	mcall	800093f4 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80009378:	f0 1f 00 1a 	mcall	800093e0 <xQueueGenericSend+0xd8>
8000937c:	6f 18       	ld.w	r8,r7[0x44]
8000937e:	5b f8       	cp.w	r8,-1
80009380:	ef f1 0a 11 	st.weq	r7[0x44],r1
80009384:	6f 28       	ld.w	r8,r7[0x48]
80009386:	5b f8       	cp.w	r8,-1
80009388:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000938c:	f0 1f 00 18 	mcall	800093ec <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80009390:	04 9b       	mov	r11,r2
80009392:	06 9c       	mov	r12,r3
80009394:	f0 1f 00 19 	mcall	800093f8 <xQueueGenericSend+0xf0>
80009398:	c1 b1       	brne	800093ce <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000939a:	f0 1f 00 12 	mcall	800093e0 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000939e:	6e e5       	ld.w	r5,r7[0x38]
800093a0:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800093a2:	f0 1f 00 13 	mcall	800093ec <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800093a6:	0c 35       	cp.w	r5,r6
800093a8:	c0 d1       	brne	800093c2 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800093aa:	40 2b       	lddsp	r11,sp[0x8]
800093ac:	00 9c       	mov	r12,r0
800093ae:	f0 1f 00 14 	mcall	800093fc <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800093b2:	0e 9c       	mov	r12,r7
800093b4:	f0 1f 00 13 	mcall	80009400 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800093b8:	f0 1f 00 13 	mcall	80009404 <xQueueGenericSend+0xfc>
800093bc:	cb 41       	brne	80009324 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800093be:	d7 33       	scall
800093c0:	cb 2b       	rjmp	80009324 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800093c2:	0e 9c       	mov	r12,r7
800093c4:	f0 1f 00 0f 	mcall	80009400 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800093c8:	f0 1f 00 0f 	mcall	80009404 <xQueueGenericSend+0xfc>
800093cc:	ca cb       	rjmp	80009324 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800093ce:	0e 9c       	mov	r12,r7
800093d0:	f0 1f 00 0c 	mcall	80009400 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800093d4:	f0 1f 00 0c 	mcall	80009404 <xQueueGenericSend+0xfc>
800093d8:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800093da:	2f bd       	sub	sp,-20
800093dc:	d8 32       	popm	r0-r7,pc
800093de:	00 00       	add	r0,r0
800093e0:	80 00       	ld.sh	r0,r0[0x0]
800093e2:	8d 48       	st.w	r6[0x10],r8
800093e4:	80 00       	ld.sh	r0,r0[0x0]
800093e6:	92 40       	ld.sh	r0,r9[0x8]
800093e8:	80 00       	ld.sh	r0,r0[0x0]
800093ea:	96 6c       	ld.sh	r12,r11[0xc]
800093ec:	80 00       	ld.sh	r0,r0[0x0]
800093ee:	8e 54       	ld.sh	r4,r7[0xa]
800093f0:	80 00       	ld.sh	r0,r0[0x0]
800093f2:	95 60       	st.w	r10[0x18],r0
800093f4:	80 00       	ld.sh	r0,r0[0x0]
800093f6:	94 d4       	ld.uh	r4,r10[0xa]
800093f8:	80 00       	ld.sh	r0,r0[0x0]
800093fa:	97 fc       	st.w	r11[0x3c],r12
800093fc:	80 00       	ld.sh	r0,r0[0x0]
800093fe:	9a 54       	ld.sh	r4,sp[0xa]
80009400:	80 00       	ld.sh	r0,r0[0x0]
80009402:	90 5c       	ld.sh	r12,r8[0xa]
80009404:	80 00       	ld.sh	r0,r0[0x0]
80009406:	98 90       	ld.uh	r0,r12[0x2]

80009408 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80009408:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000940c:	34 cc       	mov	r12,76
8000940e:	f0 1f 00 12 	mcall	80009454 <xQueueCreateMutex+0x4c>
80009412:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80009414:	c1 d0       	breq	8000944e <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80009416:	30 06       	mov	r6,0
80009418:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000941a:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
8000941c:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
8000941e:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80009420:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80009422:	30 18       	mov	r8,1
80009424:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80009426:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
8000942a:	3f f8       	mov	r8,-1
8000942c:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80009430:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80009434:	2f 0c       	sub	r12,-16
80009436:	f0 1f 00 09 	mcall	80009458 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000943a:	ee cc ff dc 	sub	r12,r7,-36
8000943e:	f0 1f 00 07 	mcall	80009458 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80009442:	0c 99       	mov	r9,r6
80009444:	0c 9a       	mov	r10,r6
80009446:	0c 9b       	mov	r11,r6
80009448:	0e 9c       	mov	r12,r7
8000944a:	f0 1f 00 05 	mcall	8000945c <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
8000944e:	0e 9c       	mov	r12,r7
80009450:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009454:	80 00       	ld.sh	r0,r0[0x0]
80009456:	8f b4       	st.w	r7[0x2c],r4
80009458:	80 00       	ld.sh	r0,r0[0x0]
8000945a:	8c 24       	ld.sh	r4,r6[0x4]
8000945c:	80 00       	ld.sh	r0,r0[0x0]
8000945e:	93 08       	st.w	r9[0x0],r8

80009460 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80009460:	d4 21       	pushm	r4-r7,lr
80009462:	18 97       	mov	r7,r12
80009464:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80009466:	58 0c       	cp.w	r12,0
80009468:	c2 f0       	breq	800094c6 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000946a:	34 cc       	mov	r12,76
8000946c:	f0 1f 00 17 	mcall	800094c8 <xQueueCreate+0x68>
80009470:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80009472:	c2 a0       	breq	800094c6 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80009474:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80009478:	e8 cc ff ff 	sub	r12,r4,-1
8000947c:	f0 1f 00 13 	mcall	800094c8 <xQueueCreate+0x68>
80009480:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80009482:	c1 e0       	breq	800094be <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80009484:	f8 04 00 04 	add	r4,r12,r4
80009488:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000948a:	30 08       	mov	r8,0
8000948c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000948e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80009490:	ee c8 00 01 	sub	r8,r7,1
80009494:	ad 38       	mul	r8,r6
80009496:	10 0c       	add	r12,r8
80009498:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000949a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000949c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800094a0:	3f f8       	mov	r8,-1
800094a2:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800094a6:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800094aa:	ea cc ff f0 	sub	r12,r5,-16
800094ae:	f0 1f 00 08 	mcall	800094cc <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800094b2:	ea cc ff dc 	sub	r12,r5,-36
800094b6:	f0 1f 00 06 	mcall	800094cc <xQueueCreate+0x6c>
800094ba:	0a 9c       	mov	r12,r5
800094bc:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800094be:	0a 9c       	mov	r12,r5
800094c0:	f0 1f 00 04 	mcall	800094d0 <xQueueCreate+0x70>
800094c4:	d8 2a       	popm	r4-r7,pc,r12=0
800094c6:	d8 2a       	popm	r4-r7,pc,r12=0
800094c8:	80 00       	ld.sh	r0,r0[0x0]
800094ca:	8f b4       	st.w	r7[0x2c],r4
800094cc:	80 00       	ld.sh	r0,r0[0x0]
800094ce:	8c 24       	ld.sh	r4,r6[0x4]
800094d0:	80 00       	ld.sh	r0,r0[0x0]
800094d2:	8f 8c       	st.w	r7[0x20],r12

800094d4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800094d4:	48 38       	lddpc	r8,800094e0 <vTaskSuspendAll+0xc>
800094d6:	70 09       	ld.w	r9,r8[0x0]
800094d8:	2f f9       	sub	r9,-1
800094da:	91 09       	st.w	r8[0x0],r9
}
800094dc:	5e fc       	retal	r12
800094de:	00 00       	add	r0,r0
800094e0:	00 00       	add	r0,r0
800094e2:	12 dc       	st.w	--r9,r12

800094e4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800094e4:	49 a8       	lddpc	r8,8000954c <vTaskSwitchContext+0x68>
800094e6:	70 08       	ld.w	r8,r8[0x0]
800094e8:	58 08       	cp.w	r8,0
800094ea:	c0 b1       	brne	80009500 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800094ec:	49 98       	lddpc	r8,80009550 <vTaskSwitchContext+0x6c>
800094ee:	70 08       	ld.w	r8,r8[0x0]
800094f0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800094f4:	49 89       	lddpc	r9,80009554 <vTaskSwitchContext+0x70>
800094f6:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800094fa:	58 08       	cp.w	r8,0
800094fc:	c0 60       	breq	80009508 <vTaskSwitchContext+0x24>
800094fe:	c1 18       	rjmp	80009520 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80009500:	30 19       	mov	r9,1
80009502:	49 68       	lddpc	r8,80009558 <vTaskSwitchContext+0x74>
80009504:	91 09       	st.w	r8[0x0],r9
80009506:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80009508:	49 28       	lddpc	r8,80009550 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000950a:	49 3a       	lddpc	r10,80009554 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000950c:	70 09       	ld.w	r9,r8[0x0]
8000950e:	20 19       	sub	r9,1
80009510:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80009512:	70 09       	ld.w	r9,r8[0x0]
80009514:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009518:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000951c:	58 09       	cp.w	r9,0
8000951e:	cf 70       	breq	8000950c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80009520:	48 c8       	lddpc	r8,80009550 <vTaskSwitchContext+0x6c>
80009522:	70 08       	ld.w	r8,r8[0x0]
80009524:	f0 08 00 28 	add	r8,r8,r8<<0x2
80009528:	48 b9       	lddpc	r9,80009554 <vTaskSwitchContext+0x70>
8000952a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000952e:	70 19       	ld.w	r9,r8[0x4]
80009530:	72 19       	ld.w	r9,r9[0x4]
80009532:	91 19       	st.w	r8[0x4],r9
80009534:	f0 ca ff f8 	sub	r10,r8,-8
80009538:	14 39       	cp.w	r9,r10
8000953a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000953e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80009542:	70 18       	ld.w	r8,r8[0x4]
80009544:	70 39       	ld.w	r9,r8[0xc]
80009546:	48 68       	lddpc	r8,8000955c <vTaskSwitchContext+0x78>
80009548:	91 09       	st.w	r8[0x0],r9
8000954a:	5e fc       	retal	r12
8000954c:	00 00       	add	r0,r0
8000954e:	12 dc       	st.w	--r9,r12
80009550:	00 00       	add	r0,r0
80009552:	13 14       	ld.sh	r4,r9++
80009554:	00 00       	add	r0,r0
80009556:	11 f8       	ld.ub	r8,r8[0x7]
80009558:	00 00       	add	r0,r0
8000955a:	12 fc       	st.b	--r9,r12
8000955c:	00 00       	add	r0,r0
8000955e:	12 ac       	st.w	r9++,r12

80009560 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80009560:	48 48       	lddpc	r8,80009570 <vTaskSetTimeOutState+0x10>
80009562:	70 08       	ld.w	r8,r8[0x0]
80009564:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80009566:	48 48       	lddpc	r8,80009574 <vTaskSetTimeOutState+0x14>
80009568:	70 08       	ld.w	r8,r8[0x0]
8000956a:	99 18       	st.w	r12[0x4],r8
}
8000956c:	5e fc       	retal	r12
8000956e:	00 00       	add	r0,r0
80009570:	00 00       	add	r0,r0
80009572:	11 f0       	ld.ub	r0,r8[0x7]
80009574:	00 00       	add	r0,r0
80009576:	12 d8       	st.w	--r9,r8

80009578 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80009578:	30 19       	mov	r9,1
8000957a:	48 28       	lddpc	r8,80009580 <vTaskMissedYield+0x8>
8000957c:	91 09       	st.w	r8[0x0],r9
}
8000957e:	5e fc       	retal	r12
80009580:	00 00       	add	r0,r0
80009582:	12 fc       	st.b	--r9,r12

80009584 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80009584:	48 28       	lddpc	r8,8000958c <xTaskGetCurrentTaskHandle+0x8>
80009586:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80009588:	5e fc       	retal	r12
8000958a:	00 00       	add	r0,r0
8000958c:	00 00       	add	r0,r0
8000958e:	12 ac       	st.w	r9++,r12

80009590 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80009590:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80009594:	58 0c       	cp.w	r12,0
80009596:	c1 f0       	breq	800095d4 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80009598:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000959a:	78 b9       	ld.w	r9,r12[0x2c]
8000959c:	79 18       	ld.w	r8,r12[0x44]
8000959e:	10 39       	cp.w	r9,r8
800095a0:	c1 a0       	breq	800095d4 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800095a2:	f8 c6 ff fc 	sub	r6,r12,-4
800095a6:	0c 9c       	mov	r12,r6
800095a8:	f0 1f 00 0c 	mcall	800095d8 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800095ac:	6f 1c       	ld.w	r12,r7[0x44]
800095ae:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800095b0:	f8 08 11 08 	rsub	r8,r12,8
800095b4:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800095b6:	48 a8       	lddpc	r8,800095dc <vTaskPriorityDisinherit+0x4c>
800095b8:	70 08       	ld.w	r8,r8[0x0]
800095ba:	10 3c       	cp.w	r12,r8
800095bc:	e0 88 00 04 	brls	800095c4 <vTaskPriorityDisinherit+0x34>
800095c0:	48 78       	lddpc	r8,800095dc <vTaskPriorityDisinherit+0x4c>
800095c2:	91 0c       	st.w	r8[0x0],r12
800095c4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800095c8:	0c 9b       	mov	r11,r6
800095ca:	48 68       	lddpc	r8,800095e0 <vTaskPriorityDisinherit+0x50>
800095cc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800095d0:	f0 1f 00 05 	mcall	800095e4 <vTaskPriorityDisinherit+0x54>
800095d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800095d8:	80 00       	ld.sh	r0,r0[0x0]
800095da:	8c 8e       	ld.uh	lr,r6[0x0]
800095dc:	00 00       	add	r0,r0
800095de:	13 14       	ld.sh	r4,r9++
800095e0:	00 00       	add	r0,r0
800095e2:	11 f8       	ld.ub	r8,r8[0x7]
800095e4:	80 00       	ld.sh	r0,r0[0x0]
800095e6:	8c 3e       	ld.sh	lr,r6[0x6]

800095e8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800095e8:	eb cd 40 c0 	pushm	r6-r7,lr
800095ec:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800095ee:	49 b8       	lddpc	r8,80009658 <vTaskPriorityInherit+0x70>
800095f0:	70 08       	ld.w	r8,r8[0x0]
800095f2:	78 b9       	ld.w	r9,r12[0x2c]
800095f4:	70 b8       	ld.w	r8,r8[0x2c]
800095f6:	10 39       	cp.w	r9,r8
800095f8:	c2 d2       	brcc	80009652 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800095fa:	49 88       	lddpc	r8,80009658 <vTaskPriorityInherit+0x70>
800095fc:	70 08       	ld.w	r8,r8[0x0]
800095fe:	70 b8       	ld.w	r8,r8[0x2c]
80009600:	f0 08 11 08 	rsub	r8,r8,8
80009604:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80009606:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000960a:	49 59       	lddpc	r9,8000965c <vTaskPriorityInherit+0x74>
8000960c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80009610:	78 59       	ld.w	r9,r12[0x14]
80009612:	10 39       	cp.w	r9,r8
80009614:	c1 b1       	brne	8000964a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80009616:	f8 c6 ff fc 	sub	r6,r12,-4
8000961a:	0c 9c       	mov	r12,r6
8000961c:	f0 1f 00 11 	mcall	80009660 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80009620:	48 e8       	lddpc	r8,80009658 <vTaskPriorityInherit+0x70>
80009622:	70 08       	ld.w	r8,r8[0x0]
80009624:	70 bc       	ld.w	r12,r8[0x2c]
80009626:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80009628:	48 f8       	lddpc	r8,80009664 <vTaskPriorityInherit+0x7c>
8000962a:	70 08       	ld.w	r8,r8[0x0]
8000962c:	10 3c       	cp.w	r12,r8
8000962e:	e0 88 00 04 	brls	80009636 <vTaskPriorityInherit+0x4e>
80009632:	48 d8       	lddpc	r8,80009664 <vTaskPriorityInherit+0x7c>
80009634:	91 0c       	st.w	r8[0x0],r12
80009636:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000963a:	0c 9b       	mov	r11,r6
8000963c:	48 88       	lddpc	r8,8000965c <vTaskPriorityInherit+0x74>
8000963e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009642:	f0 1f 00 0a 	mcall	80009668 <vTaskPriorityInherit+0x80>
80009646:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000964a:	48 48       	lddpc	r8,80009658 <vTaskPriorityInherit+0x70>
8000964c:	70 08       	ld.w	r8,r8[0x0]
8000964e:	70 b8       	ld.w	r8,r8[0x2c]
80009650:	99 b8       	st.w	r12[0x2c],r8
80009652:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009656:	00 00       	add	r0,r0
80009658:	00 00       	add	r0,r0
8000965a:	12 ac       	st.w	r9++,r12
8000965c:	00 00       	add	r0,r0
8000965e:	11 f8       	ld.ub	r8,r8[0x7]
80009660:	80 00       	ld.sh	r0,r0[0x0]
80009662:	8c 8e       	ld.uh	lr,r6[0x0]
80009664:	00 00       	add	r0,r0
80009666:	13 14       	ld.sh	r4,r9++
80009668:	80 00       	ld.sh	r0,r0[0x0]
8000966a:	8c 3e       	ld.sh	lr,r6[0x6]

8000966c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000966c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80009670:	78 38       	ld.w	r8,r12[0xc]
80009672:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80009674:	ee c6 ff e8 	sub	r6,r7,-24
80009678:	0c 9c       	mov	r12,r6
8000967a:	f0 1f 00 15 	mcall	800096cc <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000967e:	49 58       	lddpc	r8,800096d0 <xTaskRemoveFromEventList+0x64>
80009680:	70 08       	ld.w	r8,r8[0x0]
80009682:	58 08       	cp.w	r8,0
80009684:	c1 71       	brne	800096b2 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80009686:	ee c6 ff fc 	sub	r6,r7,-4
8000968a:	0c 9c       	mov	r12,r6
8000968c:	f0 1f 00 10 	mcall	800096cc <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80009690:	6e bc       	ld.w	r12,r7[0x2c]
80009692:	49 18       	lddpc	r8,800096d4 <xTaskRemoveFromEventList+0x68>
80009694:	70 08       	ld.w	r8,r8[0x0]
80009696:	10 3c       	cp.w	r12,r8
80009698:	e0 88 00 04 	brls	800096a0 <xTaskRemoveFromEventList+0x34>
8000969c:	48 e8       	lddpc	r8,800096d4 <xTaskRemoveFromEventList+0x68>
8000969e:	91 0c       	st.w	r8[0x0],r12
800096a0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800096a4:	0c 9b       	mov	r11,r6
800096a6:	48 d8       	lddpc	r8,800096d8 <xTaskRemoveFromEventList+0x6c>
800096a8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800096ac:	f0 1f 00 0c 	mcall	800096dc <xTaskRemoveFromEventList+0x70>
800096b0:	c0 58       	rjmp	800096ba <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800096b2:	0c 9b       	mov	r11,r6
800096b4:	48 bc       	lddpc	r12,800096e0 <xTaskRemoveFromEventList+0x74>
800096b6:	f0 1f 00 0a 	mcall	800096dc <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800096ba:	48 b8       	lddpc	r8,800096e4 <xTaskRemoveFromEventList+0x78>
800096bc:	70 08       	ld.w	r8,r8[0x0]
800096be:	6e b9       	ld.w	r9,r7[0x2c]
800096c0:	70 b8       	ld.w	r8,r8[0x2c]
800096c2:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800096c4:	5f 2c       	srhs	r12
800096c6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800096ca:	00 00       	add	r0,r0
800096cc:	80 00       	ld.sh	r0,r0[0x0]
800096ce:	8c 8e       	ld.uh	lr,r6[0x0]
800096d0:	00 00       	add	r0,r0
800096d2:	12 dc       	st.w	--r9,r12
800096d4:	00 00       	add	r0,r0
800096d6:	13 14       	ld.sh	r4,r9++
800096d8:	00 00       	add	r0,r0
800096da:	11 f8       	ld.ub	r8,r8[0x7]
800096dc:	80 00       	ld.sh	r0,r0[0x0]
800096de:	8c 3e       	ld.sh	lr,r6[0x6]
800096e0:	00 00       	add	r0,r0
800096e2:	12 b0       	st.h	r9++,r0
800096e4:	00 00       	add	r0,r0
800096e6:	12 ac       	st.w	r9++,r12

800096e8 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800096e8:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800096ec:	4b 98       	lddpc	r8,800097d0 <vTaskIncrementTick+0xe8>
800096ee:	70 08       	ld.w	r8,r8[0x0]
800096f0:	58 08       	cp.w	r8,0
800096f2:	c6 91       	brne	800097c4 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800096f4:	4b 88       	lddpc	r8,800097d4 <vTaskIncrementTick+0xec>
800096f6:	70 09       	ld.w	r9,r8[0x0]
800096f8:	2f f9       	sub	r9,-1
800096fa:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800096fc:	70 08       	ld.w	r8,r8[0x0]
800096fe:	58 08       	cp.w	r8,0
80009700:	c1 a1       	brne	80009734 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80009702:	4b 68       	lddpc	r8,800097d8 <vTaskIncrementTick+0xf0>
80009704:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80009706:	4b 69       	lddpc	r9,800097dc <vTaskIncrementTick+0xf4>
80009708:	72 0b       	ld.w	r11,r9[0x0]
8000970a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000970c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000970e:	4b 59       	lddpc	r9,800097e0 <vTaskIncrementTick+0xf8>
80009710:	72 0a       	ld.w	r10,r9[0x0]
80009712:	2f fa       	sub	r10,-1
80009714:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80009716:	70 08       	ld.w	r8,r8[0x0]
80009718:	70 08       	ld.w	r8,r8[0x0]
8000971a:	58 08       	cp.w	r8,0
8000971c:	c0 51       	brne	80009726 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000971e:	3f f9       	mov	r9,-1
80009720:	4b 18       	lddpc	r8,800097e4 <vTaskIncrementTick+0xfc>
80009722:	91 09       	st.w	r8[0x0],r9
80009724:	c0 88       	rjmp	80009734 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80009726:	4a d8       	lddpc	r8,800097d8 <vTaskIncrementTick+0xf0>
80009728:	70 08       	ld.w	r8,r8[0x0]
8000972a:	70 38       	ld.w	r8,r8[0xc]
8000972c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000972e:	70 19       	ld.w	r9,r8[0x4]
80009730:	4a d8       	lddpc	r8,800097e4 <vTaskIncrementTick+0xfc>
80009732:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80009734:	4a 88       	lddpc	r8,800097d4 <vTaskIncrementTick+0xec>
80009736:	70 09       	ld.w	r9,r8[0x0]
80009738:	4a b8       	lddpc	r8,800097e4 <vTaskIncrementTick+0xfc>
8000973a:	70 08       	ld.w	r8,r8[0x0]
8000973c:	10 39       	cp.w	r9,r8
8000973e:	c4 73       	brcs	800097cc <vTaskIncrementTick+0xe4>
80009740:	4a 68       	lddpc	r8,800097d8 <vTaskIncrementTick+0xf0>
80009742:	70 08       	ld.w	r8,r8[0x0]
80009744:	70 08       	ld.w	r8,r8[0x0]
80009746:	58 08       	cp.w	r8,0
80009748:	c0 c0       	breq	80009760 <vTaskIncrementTick+0x78>
8000974a:	4a 48       	lddpc	r8,800097d8 <vTaskIncrementTick+0xf0>
8000974c:	70 08       	ld.w	r8,r8[0x0]
8000974e:	70 38       	ld.w	r8,r8[0xc]
80009750:	70 37       	ld.w	r7,r8[0xc]
80009752:	6e 18       	ld.w	r8,r7[0x4]
80009754:	4a 09       	lddpc	r9,800097d4 <vTaskIncrementTick+0xec>
80009756:	72 09       	ld.w	r9,r9[0x0]
80009758:	12 38       	cp.w	r8,r9
8000975a:	e0 88 00 14 	brls	80009782 <vTaskIncrementTick+0x9a>
8000975e:	c0 e8       	rjmp	8000977a <vTaskIncrementTick+0x92>
80009760:	3f f9       	mov	r9,-1
80009762:	4a 18       	lddpc	r8,800097e4 <vTaskIncrementTick+0xfc>
80009764:	91 09       	st.w	r8[0x0],r9
80009766:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000976a:	6a 08       	ld.w	r8,r5[0x0]
8000976c:	70 38       	ld.w	r8,r8[0xc]
8000976e:	70 37       	ld.w	r7,r8[0xc]
80009770:	6e 18       	ld.w	r8,r7[0x4]
80009772:	64 09       	ld.w	r9,r2[0x0]
80009774:	12 38       	cp.w	r8,r9
80009776:	e0 88 00 0a 	brls	8000978a <vTaskIncrementTick+0xa2>
8000977a:	49 b9       	lddpc	r9,800097e4 <vTaskIncrementTick+0xfc>
8000977c:	93 08       	st.w	r9[0x0],r8
8000977e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80009782:	49 a4       	lddpc	r4,800097e8 <vTaskIncrementTick+0x100>
80009784:	49 a3       	lddpc	r3,800097ec <vTaskIncrementTick+0x104>
80009786:	49 55       	lddpc	r5,800097d8 <vTaskIncrementTick+0xf0>
80009788:	49 32       	lddpc	r2,800097d4 <vTaskIncrementTick+0xec>
8000978a:	ee c6 ff fc 	sub	r6,r7,-4
8000978e:	0c 9c       	mov	r12,r6
80009790:	f0 1f 00 18 	mcall	800097f0 <vTaskIncrementTick+0x108>
80009794:	6e a8       	ld.w	r8,r7[0x28]
80009796:	58 08       	cp.w	r8,0
80009798:	c0 50       	breq	800097a2 <vTaskIncrementTick+0xba>
8000979a:	ee cc ff e8 	sub	r12,r7,-24
8000979e:	f0 1f 00 15 	mcall	800097f0 <vTaskIncrementTick+0x108>
800097a2:	6e bc       	ld.w	r12,r7[0x2c]
800097a4:	68 08       	ld.w	r8,r4[0x0]
800097a6:	10 3c       	cp.w	r12,r8
800097a8:	e9 fc ba 00 	st.whi	r4[0x0],r12
800097ac:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800097b0:	0c 9b       	mov	r11,r6
800097b2:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800097b6:	f0 1f 00 10 	mcall	800097f4 <vTaskIncrementTick+0x10c>
800097ba:	6a 08       	ld.w	r8,r5[0x0]
800097bc:	70 08       	ld.w	r8,r8[0x0]
800097be:	58 08       	cp.w	r8,0
800097c0:	cd 51       	brne	8000976a <vTaskIncrementTick+0x82>
800097c2:	cc fb       	rjmp	80009760 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800097c4:	48 d8       	lddpc	r8,800097f8 <vTaskIncrementTick+0x110>
800097c6:	70 09       	ld.w	r9,r8[0x0]
800097c8:	2f f9       	sub	r9,-1
800097ca:	91 09       	st.w	r8[0x0],r9
800097cc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800097d0:	00 00       	add	r0,r0
800097d2:	12 dc       	st.w	--r9,r12
800097d4:	00 00       	add	r0,r0
800097d6:	12 d8       	st.w	--r9,r8
800097d8:	00 00       	add	r0,r0
800097da:	11 e4       	ld.ub	r4,r8[0x6]
800097dc:	00 00       	add	r0,r0
800097de:	11 f4       	ld.ub	r4,r8[0x7]
800097e0:	00 00       	add	r0,r0
800097e2:	11 f0       	ld.ub	r0,r8[0x7]
800097e4:	00 00       	add	r0,r0
800097e6:	05 34       	ld.ub	r4,r2++
800097e8:	00 00       	add	r0,r0
800097ea:	13 14       	ld.sh	r4,r9++
800097ec:	00 00       	add	r0,r0
800097ee:	11 f8       	ld.ub	r8,r8[0x7]
800097f0:	80 00       	ld.sh	r0,r0[0x0]
800097f2:	8c 8e       	ld.uh	lr,r6[0x0]
800097f4:	80 00       	ld.sh	r0,r0[0x0]
800097f6:	8c 3e       	ld.sh	lr,r6[0x6]
800097f8:	00 00       	add	r0,r0
800097fa:	11 dc       	ld.ub	r12,r8[0x5]

800097fc <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800097fc:	eb cd 40 c0 	pushm	r6-r7,lr
80009800:	18 97       	mov	r7,r12
80009802:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80009804:	f0 1f 00 15 	mcall	80009858 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80009808:	6c 08       	ld.w	r8,r6[0x0]
8000980a:	5b f8       	cp.w	r8,-1
8000980c:	c0 31       	brne	80009812 <xTaskCheckForTimeOut+0x16>
8000980e:	30 07       	mov	r7,0
80009810:	c1 f8       	rjmp	8000984e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80009812:	49 39       	lddpc	r9,8000985c <xTaskCheckForTimeOut+0x60>
80009814:	72 09       	ld.w	r9,r9[0x0]
80009816:	6e 0a       	ld.w	r10,r7[0x0]
80009818:	12 3a       	cp.w	r10,r9
8000981a:	c0 70       	breq	80009828 <xTaskCheckForTimeOut+0x2c>
8000981c:	49 19       	lddpc	r9,80009860 <xTaskCheckForTimeOut+0x64>
8000981e:	72 09       	ld.w	r9,r9[0x0]
80009820:	6e 1a       	ld.w	r10,r7[0x4]
80009822:	12 3a       	cp.w	r10,r9
80009824:	e0 88 00 14 	brls	8000984c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80009828:	48 e9       	lddpc	r9,80009860 <xTaskCheckForTimeOut+0x64>
8000982a:	72 0a       	ld.w	r10,r9[0x0]
8000982c:	6e 19       	ld.w	r9,r7[0x4]
8000982e:	12 1a       	sub	r10,r9
80009830:	14 38       	cp.w	r8,r10
80009832:	e0 88 00 0d 	brls	8000984c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80009836:	48 ba       	lddpc	r10,80009860 <xTaskCheckForTimeOut+0x64>
80009838:	74 0a       	ld.w	r10,r10[0x0]
8000983a:	14 19       	sub	r9,r10
8000983c:	f2 08 00 08 	add	r8,r9,r8
80009840:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80009842:	0e 9c       	mov	r12,r7
80009844:	f0 1f 00 08 	mcall	80009864 <xTaskCheckForTimeOut+0x68>
80009848:	30 07       	mov	r7,0
8000984a:	c0 28       	rjmp	8000984e <xTaskCheckForTimeOut+0x52>
8000984c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000984e:	f0 1f 00 07 	mcall	80009868 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80009852:	0e 9c       	mov	r12,r7
80009854:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009858:	80 00       	ld.sh	r0,r0[0x0]
8000985a:	8d 48       	st.w	r6[0x10],r8
8000985c:	00 00       	add	r0,r0
8000985e:	11 f0       	ld.ub	r0,r8[0x7]
80009860:	00 00       	add	r0,r0
80009862:	12 d8       	st.w	--r9,r8
80009864:	80 00       	ld.sh	r0,r0[0x0]
80009866:	95 60       	st.w	r10[0x18],r0
80009868:	80 00       	ld.sh	r0,r0[0x0]
8000986a:	8e 54       	ld.sh	r4,r7[0xa]

8000986c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
8000986c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80009870:	f0 1f 00 05 	mcall	80009884 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80009874:	48 58       	lddpc	r8,80009888 <xTaskGetTickCount+0x1c>
80009876:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80009878:	f0 1f 00 05 	mcall	8000988c <xTaskGetTickCount+0x20>

	return xTicks;
}
8000987c:	0e 9c       	mov	r12,r7
8000987e:	e3 cd 80 80 	ldm	sp++,r7,pc
80009882:	00 00       	add	r0,r0
80009884:	80 00       	ld.sh	r0,r0[0x0]
80009886:	8d 48       	st.w	r6[0x10],r8
80009888:	00 00       	add	r0,r0
8000988a:	12 d8       	st.w	--r9,r8
8000988c:	80 00       	ld.sh	r0,r0[0x0]
8000988e:	8e 54       	ld.sh	r4,r7[0xa]

80009890 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80009890:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80009894:	f0 1f 00 2c 	mcall	80009944 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80009898:	4a c8       	lddpc	r8,80009948 <xTaskResumeAll+0xb8>
8000989a:	70 09       	ld.w	r9,r8[0x0]
8000989c:	20 19       	sub	r9,1
8000989e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800098a0:	70 08       	ld.w	r8,r8[0x0]
800098a2:	58 08       	cp.w	r8,0
800098a4:	c4 91       	brne	80009936 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800098a6:	4a a8       	lddpc	r8,8000994c <xTaskResumeAll+0xbc>
800098a8:	70 08       	ld.w	r8,r8[0x0]
800098aa:	58 08       	cp.w	r8,0
800098ac:	c4 50       	breq	80009936 <xTaskResumeAll+0xa6>
800098ae:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800098b0:	4a 85       	lddpc	r5,80009950 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800098b2:	4a 93       	lddpc	r3,80009954 <xTaskResumeAll+0xc4>
800098b4:	4a 92       	lddpc	r2,80009958 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800098b6:	4a a1       	lddpc	r1,8000995c <xTaskResumeAll+0xcc>
800098b8:	c1 e8       	rjmp	800098f4 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800098ba:	6a 38       	ld.w	r8,r5[0xc]
800098bc:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800098be:	ee cc ff e8 	sub	r12,r7,-24
800098c2:	f0 1f 00 28 	mcall	80009960 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800098c6:	ee c6 ff fc 	sub	r6,r7,-4
800098ca:	0c 9c       	mov	r12,r6
800098cc:	f0 1f 00 25 	mcall	80009960 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800098d0:	6e bc       	ld.w	r12,r7[0x2c]
800098d2:	66 08       	ld.w	r8,r3[0x0]
800098d4:	10 3c       	cp.w	r12,r8
800098d6:	e7 fc ba 00 	st.whi	r3[0x0],r12
800098da:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800098de:	0c 9b       	mov	r11,r6
800098e0:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800098e4:	f0 1f 00 20 	mcall	80009964 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800098e8:	62 08       	ld.w	r8,r1[0x0]
800098ea:	6e b9       	ld.w	r9,r7[0x2c]
800098ec:	70 b8       	ld.w	r8,r8[0x2c]
800098ee:	10 39       	cp.w	r9,r8
800098f0:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800098f4:	6a 08       	ld.w	r8,r5[0x0]
800098f6:	58 08       	cp.w	r8,0
800098f8:	ce 11       	brne	800098ba <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800098fa:	49 c8       	lddpc	r8,80009968 <xTaskResumeAll+0xd8>
800098fc:	70 08       	ld.w	r8,r8[0x0]
800098fe:	58 08       	cp.w	r8,0
80009900:	c0 f0       	breq	8000991e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009902:	49 a8       	lddpc	r8,80009968 <xTaskResumeAll+0xd8>
80009904:	70 08       	ld.w	r8,r8[0x0]
80009906:	58 08       	cp.w	r8,0
80009908:	c1 10       	breq	8000992a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000990a:	49 87       	lddpc	r7,80009968 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
8000990c:	f0 1f 00 18 	mcall	8000996c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80009910:	6e 08       	ld.w	r8,r7[0x0]
80009912:	20 18       	sub	r8,1
80009914:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009916:	6e 08       	ld.w	r8,r7[0x0]
80009918:	58 08       	cp.w	r8,0
8000991a:	cf 91       	brne	8000990c <xTaskResumeAll+0x7c>
8000991c:	c0 78       	rjmp	8000992a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000991e:	58 14       	cp.w	r4,1
80009920:	c0 50       	breq	8000992a <xTaskResumeAll+0x9a>
80009922:	49 48       	lddpc	r8,80009970 <xTaskResumeAll+0xe0>
80009924:	70 08       	ld.w	r8,r8[0x0]
80009926:	58 18       	cp.w	r8,1
80009928:	c0 71       	brne	80009936 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000992a:	30 09       	mov	r9,0
8000992c:	49 18       	lddpc	r8,80009970 <xTaskResumeAll+0xe0>
8000992e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80009930:	d7 33       	scall
80009932:	30 17       	mov	r7,1
80009934:	c0 28       	rjmp	80009938 <xTaskResumeAll+0xa8>
80009936:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80009938:	f0 1f 00 0f 	mcall	80009974 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
8000993c:	0e 9c       	mov	r12,r7
8000993e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80009942:	00 00       	add	r0,r0
80009944:	80 00       	ld.sh	r0,r0[0x0]
80009946:	8d 48       	st.w	r6[0x10],r8
80009948:	00 00       	add	r0,r0
8000994a:	12 dc       	st.w	--r9,r12
8000994c:	00 00       	add	r0,r0
8000994e:	12 f8       	st.b	--r9,r8
80009950:	00 00       	add	r0,r0
80009952:	12 b0       	st.h	r9++,r0
80009954:	00 00       	add	r0,r0
80009956:	13 14       	ld.sh	r4,r9++
80009958:	00 00       	add	r0,r0
8000995a:	11 f8       	ld.ub	r8,r8[0x7]
8000995c:	00 00       	add	r0,r0
8000995e:	12 ac       	st.w	r9++,r12
80009960:	80 00       	ld.sh	r0,r0[0x0]
80009962:	8c 8e       	ld.uh	lr,r6[0x0]
80009964:	80 00       	ld.sh	r0,r0[0x0]
80009966:	8c 3e       	ld.sh	lr,r6[0x6]
80009968:	00 00       	add	r0,r0
8000996a:	11 dc       	ld.ub	r12,r8[0x5]
8000996c:	80 00       	ld.sh	r0,r0[0x0]
8000996e:	96 e8       	ld.uh	r8,r11[0xc]
80009970:	00 00       	add	r0,r0
80009972:	12 fc       	st.b	--r9,r12
80009974:	80 00       	ld.sh	r0,r0[0x0]
80009976:	8e 54       	ld.sh	r4,r7[0xa]

80009978 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80009978:	eb cd 40 80 	pushm	r7,lr
8000997c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000997e:	49 08       	lddpc	r8,800099bc <prvAddCurrentTaskToDelayedList+0x44>
80009980:	70 08       	ld.w	r8,r8[0x0]
80009982:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80009984:	48 f8       	lddpc	r8,800099c0 <prvAddCurrentTaskToDelayedList+0x48>
80009986:	70 08       	ld.w	r8,r8[0x0]
80009988:	10 3c       	cp.w	r12,r8
8000998a:	c0 a2       	brcc	8000999e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000998c:	48 c8       	lddpc	r8,800099bc <prvAddCurrentTaskToDelayedList+0x44>
8000998e:	70 0b       	ld.w	r11,r8[0x0]
80009990:	48 d8       	lddpc	r8,800099c4 <prvAddCurrentTaskToDelayedList+0x4c>
80009992:	70 0c       	ld.w	r12,r8[0x0]
80009994:	2f cb       	sub	r11,-4
80009996:	f0 1f 00 0d 	mcall	800099c8 <prvAddCurrentTaskToDelayedList+0x50>
8000999a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000999e:	48 88       	lddpc	r8,800099bc <prvAddCurrentTaskToDelayedList+0x44>
800099a0:	70 0b       	ld.w	r11,r8[0x0]
800099a2:	48 b8       	lddpc	r8,800099cc <prvAddCurrentTaskToDelayedList+0x54>
800099a4:	70 0c       	ld.w	r12,r8[0x0]
800099a6:	2f cb       	sub	r11,-4
800099a8:	f0 1f 00 08 	mcall	800099c8 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800099ac:	48 98       	lddpc	r8,800099d0 <prvAddCurrentTaskToDelayedList+0x58>
800099ae:	70 08       	ld.w	r8,r8[0x0]
800099b0:	10 37       	cp.w	r7,r8
800099b2:	c0 32       	brcc	800099b8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800099b4:	48 78       	lddpc	r8,800099d0 <prvAddCurrentTaskToDelayedList+0x58>
800099b6:	91 07       	st.w	r8[0x0],r7
800099b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800099bc:	00 00       	add	r0,r0
800099be:	12 ac       	st.w	r9++,r12
800099c0:	00 00       	add	r0,r0
800099c2:	12 d8       	st.w	--r9,r8
800099c4:	00 00       	add	r0,r0
800099c6:	11 f4       	ld.ub	r4,r8[0x7]
800099c8:	80 00       	ld.sh	r0,r0[0x0]
800099ca:	8c 5a       	ld.sh	r10,r6[0xa]
800099cc:	00 00       	add	r0,r0
800099ce:	11 e4       	ld.ub	r4,r8[0x6]
800099d0:	00 00       	add	r0,r0
800099d2:	05 34       	ld.ub	r4,r2++

800099d4 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800099d4:	eb cd 40 c0 	pushm	r6-r7,lr
800099d8:	18 96       	mov	r6,r12
800099da:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800099dc:	f0 1f 00 18 	mcall	80009a3c <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800099e0:	6c 08       	ld.w	r8,r6[0x0]
800099e2:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800099e4:	49 79       	lddpc	r9,80009a40 <vTaskDelayUntil+0x6c>
800099e6:	72 09       	ld.w	r9,r9[0x0]
800099e8:	12 38       	cp.w	r8,r9
800099ea:	e0 88 00 0c 	brls	80009a02 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800099ee:	0e 38       	cp.w	r8,r7
800099f0:	e0 88 00 22 	brls	80009a34 <vTaskDelayUntil+0x60>
800099f4:	49 38       	lddpc	r8,80009a40 <vTaskDelayUntil+0x6c>
800099f6:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800099f8:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800099fa:	10 37       	cp.w	r7,r8
800099fc:	e0 88 00 14 	brls	80009a24 <vTaskDelayUntil+0x50>
80009a00:	c0 a8       	rjmp	80009a14 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80009a02:	0e 38       	cp.w	r8,r7
80009a04:	e0 8b 00 16 	brhi	80009a30 <vTaskDelayUntil+0x5c>
80009a08:	48 e8       	lddpc	r8,80009a40 <vTaskDelayUntil+0x6c>
80009a0a:	70 08       	ld.w	r8,r8[0x0]
80009a0c:	10 37       	cp.w	r7,r8
80009a0e:	e0 8b 00 11 	brhi	80009a30 <vTaskDelayUntil+0x5c>
80009a12:	c1 18       	rjmp	80009a34 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009a14:	48 c8       	lddpc	r8,80009a44 <vTaskDelayUntil+0x70>
80009a16:	70 0c       	ld.w	r12,r8[0x0]
80009a18:	2f cc       	sub	r12,-4
80009a1a:	f0 1f 00 0c 	mcall	80009a48 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80009a1e:	0e 9c       	mov	r12,r7
80009a20:	f0 1f 00 0b 	mcall	80009a4c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80009a24:	f0 1f 00 0b 	mcall	80009a50 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80009a28:	c0 81       	brne	80009a38 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80009a2a:	d7 33       	scall
80009a2c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80009a30:	8d 07       	st.w	r6[0x0],r7
80009a32:	cf 1b       	rjmp	80009a14 <vTaskDelayUntil+0x40>
80009a34:	8d 07       	st.w	r6[0x0],r7
80009a36:	cf 7b       	rjmp	80009a24 <vTaskDelayUntil+0x50>
80009a38:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009a3c:	80 00       	ld.sh	r0,r0[0x0]
80009a3e:	94 d4       	ld.uh	r4,r10[0xa]
80009a40:	00 00       	add	r0,r0
80009a42:	12 d8       	st.w	--r9,r8
80009a44:	00 00       	add	r0,r0
80009a46:	12 ac       	st.w	r9++,r12
80009a48:	80 00       	ld.sh	r0,r0[0x0]
80009a4a:	8c 8e       	ld.uh	lr,r6[0x0]
80009a4c:	80 00       	ld.sh	r0,r0[0x0]
80009a4e:	99 78       	st.w	r12[0x1c],r8
80009a50:	80 00       	ld.sh	r0,r0[0x0]
80009a52:	98 90       	ld.uh	r0,r12[0x2]

80009a54 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80009a54:	eb cd 40 c0 	pushm	r6-r7,lr
80009a58:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80009a5a:	48 e7       	lddpc	r7,80009a90 <vTaskPlaceOnEventList+0x3c>
80009a5c:	6e 0b       	ld.w	r11,r7[0x0]
80009a5e:	2e 8b       	sub	r11,-24
80009a60:	f0 1f 00 0d 	mcall	80009a94 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009a64:	6e 0c       	ld.w	r12,r7[0x0]
80009a66:	2f cc       	sub	r12,-4
80009a68:	f0 1f 00 0c 	mcall	80009a98 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80009a6c:	5b f6       	cp.w	r6,-1
80009a6e:	c0 81       	brne	80009a7e <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009a70:	6e 0b       	ld.w	r11,r7[0x0]
80009a72:	2f cb       	sub	r11,-4
80009a74:	48 ac       	lddpc	r12,80009a9c <vTaskPlaceOnEventList+0x48>
80009a76:	f0 1f 00 0b 	mcall	80009aa0 <vTaskPlaceOnEventList+0x4c>
80009a7a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80009a7e:	48 a8       	lddpc	r8,80009aa4 <vTaskPlaceOnEventList+0x50>
80009a80:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80009a82:	ec 0c 00 0c 	add	r12,r6,r12
80009a86:	f0 1f 00 09 	mcall	80009aa8 <vTaskPlaceOnEventList+0x54>
80009a8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009a8e:	00 00       	add	r0,r0
80009a90:	00 00       	add	r0,r0
80009a92:	12 ac       	st.w	r9++,r12
80009a94:	80 00       	ld.sh	r0,r0[0x0]
80009a96:	8c 5a       	ld.sh	r10,r6[0xa]
80009a98:	80 00       	ld.sh	r0,r0[0x0]
80009a9a:	8c 8e       	ld.uh	lr,r6[0x0]
80009a9c:	00 00       	add	r0,r0
80009a9e:	13 00       	ld.w	r0,r9++
80009aa0:	80 00       	ld.sh	r0,r0[0x0]
80009aa2:	8c 3e       	ld.sh	lr,r6[0x6]
80009aa4:	00 00       	add	r0,r0
80009aa6:	12 d8       	st.w	--r9,r8
80009aa8:	80 00       	ld.sh	r0,r0[0x0]
80009aaa:	99 78       	st.w	r12[0x1c],r8

80009aac <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80009aac:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009ab0:	49 67       	lddpc	r7,80009b08 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80009ab2:	49 74       	lddpc	r4,80009b0c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80009ab4:	49 73       	lddpc	r3,80009b10 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009ab6:	49 85       	lddpc	r5,80009b14 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009ab8:	6e 08       	ld.w	r8,r7[0x0]
80009aba:	58 08       	cp.w	r8,0
80009abc:	c1 e0       	breq	80009af8 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80009abe:	f0 1f 00 17 	mcall	80009b18 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80009ac2:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80009ac4:	f0 1f 00 16 	mcall	80009b1c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80009ac8:	58 06       	cp.w	r6,0
80009aca:	c1 70       	breq	80009af8 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80009acc:	f0 1f 00 15 	mcall	80009b20 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80009ad0:	68 38       	ld.w	r8,r4[0xc]
80009ad2:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80009ad4:	ec cc ff fc 	sub	r12,r6,-4
80009ad8:	f0 1f 00 13 	mcall	80009b24 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80009adc:	66 08       	ld.w	r8,r3[0x0]
80009ade:	20 18       	sub	r8,1
80009ae0:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80009ae2:	6e 08       	ld.w	r8,r7[0x0]
80009ae4:	20 18       	sub	r8,1
80009ae6:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80009ae8:	f0 1f 00 10 	mcall	80009b28 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80009aec:	6c cc       	ld.w	r12,r6[0x30]
80009aee:	f0 1f 00 10 	mcall	80009b2c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80009af2:	0c 9c       	mov	r12,r6
80009af4:	f0 1f 00 0e 	mcall	80009b2c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009af8:	6a 08       	ld.w	r8,r5[0x0]
80009afa:	58 18       	cp.w	r8,1
80009afc:	e0 88 00 03 	brls	80009b02 <prvIdleTask+0x56>
			{
				taskYIELD();
80009b00:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80009b02:	f0 1f 00 0c 	mcall	80009b30 <prvIdleTask+0x84>
		}
		#endif
	}
80009b06:	cd 9b       	rjmp	80009ab8 <prvIdleTask+0xc>
80009b08:	00 00       	add	r0,r0
80009b0a:	11 ec       	ld.ub	r12,r8[0x6]
80009b0c:	00 00       	add	r0,r0
80009b0e:	12 98       	mov	r8,r9
80009b10:	00 00       	add	r0,r0
80009b12:	12 f8       	st.b	--r9,r8
80009b14:	00 00       	add	r0,r0
80009b16:	11 f8       	ld.ub	r8,r8[0x7]
80009b18:	80 00       	ld.sh	r0,r0[0x0]
80009b1a:	94 d4       	ld.uh	r4,r10[0xa]
80009b1c:	80 00       	ld.sh	r0,r0[0x0]
80009b1e:	98 90       	ld.uh	r0,r12[0x2]
80009b20:	80 00       	ld.sh	r0,r0[0x0]
80009b22:	8d 48       	st.w	r6[0x10],r8
80009b24:	80 00       	ld.sh	r0,r0[0x0]
80009b26:	8c 8e       	ld.uh	lr,r6[0x0]
80009b28:	80 00       	ld.sh	r0,r0[0x0]
80009b2a:	8e 54       	ld.sh	r4,r7[0xa]
80009b2c:	80 00       	ld.sh	r0,r0[0x0]
80009b2e:	8f 8c       	st.w	r7[0x20],r12
80009b30:	80 00       	ld.sh	r0,r0[0x0]
80009b32:	20 38       	sub	r8,3

80009b34 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80009b34:	d4 31       	pushm	r0-r7,lr
80009b36:	20 1d       	sub	sp,4
80009b38:	fa c4 ff d8 	sub	r4,sp,-40
80009b3c:	50 0c       	stdsp	sp[0x0],r12
80009b3e:	16 91       	mov	r1,r11
80009b40:	14 97       	mov	r7,r10
80009b42:	12 90       	mov	r0,r9
80009b44:	10 93       	mov	r3,r8
80009b46:	68 02       	ld.w	r2,r4[0x0]
80009b48:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80009b4a:	34 8c       	mov	r12,72
80009b4c:	f0 1f 00 5c 	mcall	80009cbc <xTaskGenericCreate+0x188>
80009b50:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80009b52:	c0 31       	brne	80009b58 <xTaskGenericCreate+0x24>
80009b54:	3f fc       	mov	r12,-1
80009b56:	ca f8       	rjmp	80009cb4 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009b58:	58 06       	cp.w	r6,0
80009b5a:	e0 81 00 af 	brne	80009cb8 <xTaskGenericCreate+0x184>
80009b5e:	0e 9c       	mov	r12,r7
80009b60:	5c 7c       	castu.h	r12
80009b62:	a3 6c       	lsl	r12,0x2
80009b64:	f0 1f 00 56 	mcall	80009cbc <xTaskGenericCreate+0x188>
80009b68:	18 96       	mov	r6,r12
80009b6a:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80009b6c:	c0 61       	brne	80009b78 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80009b6e:	0a 9c       	mov	r12,r5
80009b70:	f0 1f 00 54 	mcall	80009cc0 <xTaskGenericCreate+0x18c>
80009b74:	3f fc       	mov	r12,-1
80009b76:	c9 f8       	rjmp	80009cb4 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80009b78:	5c 77       	castu.h	r7
80009b7a:	ee 0a 15 02 	lsl	r10,r7,0x2
80009b7e:	e0 6b 00 a5 	mov	r11,165
80009b82:	0c 9c       	mov	r12,r6
80009b84:	f0 1f 00 50 	mcall	80009cc4 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80009b88:	ee c6 00 01 	sub	r6,r7,1
80009b8c:	6a c8       	ld.w	r8,r5[0x30]
80009b8e:	f0 06 00 26 	add	r6,r8,r6<<0x2
80009b92:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80009b96:	31 0a       	mov	r10,16
80009b98:	02 9b       	mov	r11,r1
80009b9a:	ea cc ff cc 	sub	r12,r5,-52
80009b9e:	f0 1f 00 4b 	mcall	80009cc8 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80009ba2:	30 08       	mov	r8,0
80009ba4:	eb 68 00 43 	st.b	r5[67],r8
80009ba8:	58 73       	cp.w	r3,7
80009baa:	e6 07 17 80 	movls	r7,r3
80009bae:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80009bb2:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80009bb4:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80009bb8:	ea c4 ff fc 	sub	r4,r5,-4
80009bbc:	08 9c       	mov	r12,r4
80009bbe:	f0 1f 00 44 	mcall	80009ccc <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80009bc2:	ea cc ff e8 	sub	r12,r5,-24
80009bc6:	f0 1f 00 42 	mcall	80009ccc <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80009bca:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80009bcc:	ee 07 11 08 	rsub	r7,r7,8
80009bd0:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80009bd2:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80009bd4:	00 9a       	mov	r10,r0
80009bd6:	40 0b       	lddsp	r11,sp[0x0]
80009bd8:	0c 9c       	mov	r12,r6
80009bda:	f0 1f 00 3e 	mcall	80009cd0 <xTaskGenericCreate+0x19c>
80009bde:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80009be0:	58 02       	cp.w	r2,0
80009be2:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80009be6:	f0 1f 00 3c 	mcall	80009cd4 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80009bea:	4b c8       	lddpc	r8,80009cd8 <xTaskGenericCreate+0x1a4>
80009bec:	70 09       	ld.w	r9,r8[0x0]
80009bee:	2f f9       	sub	r9,-1
80009bf0:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80009bf2:	4b b8       	lddpc	r8,80009cdc <xTaskGenericCreate+0x1a8>
80009bf4:	70 08       	ld.w	r8,r8[0x0]
80009bf6:	58 08       	cp.w	r8,0
80009bf8:	c2 61       	brne	80009c44 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80009bfa:	4b 98       	lddpc	r8,80009cdc <xTaskGenericCreate+0x1a8>
80009bfc:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80009bfe:	4b 78       	lddpc	r8,80009cd8 <xTaskGenericCreate+0x1a4>
80009c00:	70 08       	ld.w	r8,r8[0x0]
80009c02:	58 18       	cp.w	r8,1
80009c04:	c2 b1       	brne	80009c5a <xTaskGenericCreate+0x126>
80009c06:	4b 77       	lddpc	r7,80009ce0 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80009c08:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80009c0c:	0e 9c       	mov	r12,r7
80009c0e:	f0 1f 00 36 	mcall	80009ce4 <xTaskGenericCreate+0x1b0>
80009c12:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80009c14:	0c 37       	cp.w	r7,r6
80009c16:	cf b1       	brne	80009c0c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80009c18:	4b 47       	lddpc	r7,80009ce8 <xTaskGenericCreate+0x1b4>
80009c1a:	0e 9c       	mov	r12,r7
80009c1c:	f0 1f 00 32 	mcall	80009ce4 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80009c20:	4b 36       	lddpc	r6,80009cec <xTaskGenericCreate+0x1b8>
80009c22:	0c 9c       	mov	r12,r6
80009c24:	f0 1f 00 30 	mcall	80009ce4 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80009c28:	4b 2c       	lddpc	r12,80009cf0 <xTaskGenericCreate+0x1bc>
80009c2a:	f0 1f 00 2f 	mcall	80009ce4 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80009c2e:	4b 2c       	lddpc	r12,80009cf4 <xTaskGenericCreate+0x1c0>
80009c30:	f0 1f 00 2d 	mcall	80009ce4 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80009c34:	4b 1c       	lddpc	r12,80009cf8 <xTaskGenericCreate+0x1c4>
80009c36:	f0 1f 00 2c 	mcall	80009ce4 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80009c3a:	4b 18       	lddpc	r8,80009cfc <xTaskGenericCreate+0x1c8>
80009c3c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80009c3e:	4b 18       	lddpc	r8,80009d00 <xTaskGenericCreate+0x1cc>
80009c40:	91 06       	st.w	r8[0x0],r6
80009c42:	c0 c8       	rjmp	80009c5a <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80009c44:	4b 08       	lddpc	r8,80009d04 <xTaskGenericCreate+0x1d0>
80009c46:	70 08       	ld.w	r8,r8[0x0]
80009c48:	58 08       	cp.w	r8,0
80009c4a:	c0 81       	brne	80009c5a <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80009c4c:	4a 48       	lddpc	r8,80009cdc <xTaskGenericCreate+0x1a8>
80009c4e:	70 08       	ld.w	r8,r8[0x0]
80009c50:	70 b8       	ld.w	r8,r8[0x2c]
80009c52:	10 33       	cp.w	r3,r8
80009c54:	c0 33       	brcs	80009c5a <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80009c56:	4a 28       	lddpc	r8,80009cdc <xTaskGenericCreate+0x1a8>
80009c58:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80009c5a:	6a b8       	ld.w	r8,r5[0x2c]
80009c5c:	4a b9       	lddpc	r9,80009d08 <xTaskGenericCreate+0x1d4>
80009c5e:	72 09       	ld.w	r9,r9[0x0]
80009c60:	12 38       	cp.w	r8,r9
80009c62:	e0 88 00 04 	brls	80009c6a <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80009c66:	4a 99       	lddpc	r9,80009d08 <xTaskGenericCreate+0x1d4>
80009c68:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80009c6a:	4a 98       	lddpc	r8,80009d0c <xTaskGenericCreate+0x1d8>
80009c6c:	70 09       	ld.w	r9,r8[0x0]
80009c6e:	2f f9       	sub	r9,-1
80009c70:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80009c72:	6a b8       	ld.w	r8,r5[0x2c]
80009c74:	4a 79       	lddpc	r9,80009d10 <xTaskGenericCreate+0x1dc>
80009c76:	72 09       	ld.w	r9,r9[0x0]
80009c78:	12 38       	cp.w	r8,r9
80009c7a:	e0 88 00 04 	brls	80009c82 <xTaskGenericCreate+0x14e>
80009c7e:	4a 59       	lddpc	r9,80009d10 <xTaskGenericCreate+0x1dc>
80009c80:	93 08       	st.w	r9[0x0],r8
80009c82:	6a bc       	ld.w	r12,r5[0x2c]
80009c84:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80009c88:	08 9b       	mov	r11,r4
80009c8a:	49 68       	lddpc	r8,80009ce0 <xTaskGenericCreate+0x1ac>
80009c8c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80009c90:	f0 1f 00 21 	mcall	80009d14 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80009c94:	f0 1f 00 21 	mcall	80009d18 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80009c98:	49 b8       	lddpc	r8,80009d04 <xTaskGenericCreate+0x1d0>
80009c9a:	70 08       	ld.w	r8,r8[0x0]
80009c9c:	58 08       	cp.w	r8,0
80009c9e:	c0 a0       	breq	80009cb2 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80009ca0:	48 f8       	lddpc	r8,80009cdc <xTaskGenericCreate+0x1a8>
80009ca2:	70 08       	ld.w	r8,r8[0x0]
80009ca4:	70 b8       	ld.w	r8,r8[0x2c]
80009ca6:	10 33       	cp.w	r3,r8
80009ca8:	e0 88 00 05 	brls	80009cb2 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80009cac:	d7 33       	scall
80009cae:	30 1c       	mov	r12,1
80009cb0:	c0 28       	rjmp	80009cb4 <xTaskGenericCreate+0x180>
80009cb2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80009cb4:	2f fd       	sub	sp,-4
80009cb6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009cb8:	99 c6       	st.w	r12[0x30],r6
80009cba:	c5 fb       	rjmp	80009b78 <xTaskGenericCreate+0x44>
80009cbc:	80 00       	ld.sh	r0,r0[0x0]
80009cbe:	8f b4       	st.w	r7[0x2c],r4
80009cc0:	80 00       	ld.sh	r0,r0[0x0]
80009cc2:	8f 8c       	st.w	r7[0x20],r12
80009cc4:	80 00       	ld.sh	r0,r0[0x0]
80009cc6:	aa 06       	st.h	r5[0x0],r6
80009cc8:	80 00       	ld.sh	r0,r0[0x0]
80009cca:	ad 58       	asr	r8,0xd
80009ccc:	80 00       	ld.sh	r0,r0[0x0]
80009cce:	8c 38       	ld.sh	r8,r6[0x6]
80009cd0:	80 00       	ld.sh	r0,r0[0x0]
80009cd2:	8c b4       	ld.uh	r4,r6[0x6]
80009cd4:	80 00       	ld.sh	r0,r0[0x0]
80009cd6:	8d 48       	st.w	r6[0x10],r8
80009cd8:	00 00       	add	r0,r0
80009cda:	12 f8       	st.b	--r9,r8
80009cdc:	00 00       	add	r0,r0
80009cde:	12 ac       	st.w	r9++,r12
80009ce0:	00 00       	add	r0,r0
80009ce2:	11 f8       	ld.ub	r8,r8[0x7]
80009ce4:	80 00       	ld.sh	r0,r0[0x0]
80009ce6:	8c 24       	ld.sh	r4,r6[0x4]
80009ce8:	00 00       	add	r0,r0
80009cea:	12 c4       	st.b	r9++,r4
80009cec:	00 00       	add	r0,r0
80009cee:	12 e0       	st.h	--r9,r0
80009cf0:	00 00       	add	r0,r0
80009cf2:	12 b0       	st.h	r9++,r0
80009cf4:	00 00       	add	r0,r0
80009cf6:	12 98       	mov	r8,r9
80009cf8:	00 00       	add	r0,r0
80009cfa:	13 00       	ld.w	r0,r9++
80009cfc:	00 00       	add	r0,r0
80009cfe:	11 e4       	ld.ub	r4,r8[0x6]
80009d00:	00 00       	add	r0,r0
80009d02:	11 f4       	ld.ub	r4,r8[0x7]
80009d04:	00 00       	add	r0,r0
80009d06:	11 e8       	ld.ub	r8,r8[0x6]
80009d08:	00 00       	add	r0,r0
80009d0a:	11 e0       	ld.ub	r0,r8[0x6]
80009d0c:	00 00       	add	r0,r0
80009d0e:	12 f4       	st.b	--r9,r4
80009d10:	00 00       	add	r0,r0
80009d12:	13 14       	ld.sh	r4,r9++
80009d14:	80 00       	ld.sh	r0,r0[0x0]
80009d16:	8c 3e       	ld.sh	lr,r6[0x6]
80009d18:	80 00       	ld.sh	r0,r0[0x0]
80009d1a:	8e 54       	ld.sh	r4,r7[0xa]

80009d1c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80009d1c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80009d1e:	30 09       	mov	r9,0
80009d20:	1a d9       	st.w	--sp,r9
80009d22:	1a d9       	st.w	--sp,r9
80009d24:	1a d9       	st.w	--sp,r9
80009d26:	12 98       	mov	r8,r9
80009d28:	e0 6a 01 00 	mov	r10,256
80009d2c:	48 9b       	lddpc	r11,80009d50 <vTaskStartScheduler+0x34>
80009d2e:	48 ac       	lddpc	r12,80009d54 <vTaskStartScheduler+0x38>
80009d30:	f0 1f 00 0a 	mcall	80009d58 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80009d34:	2f dd       	sub	sp,-12
80009d36:	58 1c       	cp.w	r12,1
80009d38:	c0 a1       	brne	80009d4c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80009d3a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80009d3c:	30 19       	mov	r9,1
80009d3e:	48 88       	lddpc	r8,80009d5c <vTaskStartScheduler+0x40>
80009d40:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80009d42:	30 09       	mov	r9,0
80009d44:	48 78       	lddpc	r8,80009d60 <vTaskStartScheduler+0x44>
80009d46:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80009d48:	f0 1f 00 07 	mcall	80009d64 <vTaskStartScheduler+0x48>
80009d4c:	d8 02       	popm	pc
80009d4e:	00 00       	add	r0,r0
80009d50:	80 01       	ld.sh	r1,r0[0x0]
80009d52:	95 98       	st.w	r10[0x24],r8
80009d54:	80 00       	ld.sh	r0,r0[0x0]
80009d56:	9a ac       	ld.uh	r12,sp[0x4]
80009d58:	80 00       	ld.sh	r0,r0[0x0]
80009d5a:	9b 34       	st.w	sp[0xc],r4
80009d5c:	00 00       	add	r0,r0
80009d5e:	11 e8       	ld.ub	r8,r8[0x6]
80009d60:	00 00       	add	r0,r0
80009d62:	12 d8       	st.w	--r9,r8
80009d64:	80 00       	ld.sh	r0,r0[0x0]
80009d66:	8d 58       	st.w	r6[0x14],r8

80009d68 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80009d68:	16 cc       	st.b	r11++,r12
	return str;
}
80009d6a:	5e fb       	retal	r11

80009d6c <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80009d6c:	eb cd 40 c0 	pushm	r6-r7,lr
80009d70:	20 3d       	sub	sp,12
80009d72:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80009d74:	30 06       	mov	r6,0
80009d76:	30 07       	mov	r7,0
80009d78:	fa e7 00 00 	st.d	sp[0],r6
80009d7c:	30 0c       	mov	r12,0
80009d7e:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80009d80:	58 08       	cp.w	r8,0
80009d82:	c1 30       	breq	80009da8 <PrintHex+0x3c>
80009d84:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80009d86:	1a 9c       	mov	r12,sp
80009d88:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009d8c:	58 9e       	cp.w	lr,9
80009d8e:	e0 8a 00 04 	brle	80009d96 <PrintHex+0x2a>
80009d92:	2c 9e       	sub	lr,-55
80009d94:	c0 48       	rjmp	80009d9c <PrintHex+0x30>
80009d96:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80009d9a:	2d 0e       	sub	lr,-48
80009d9c:	f8 09 0b 0e 	st.b	r12[r9],lr
80009da0:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80009da2:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80009da4:	cf 21       	brne	80009d88 <PrintHex+0x1c>
80009da6:	c0 48       	rjmp	80009dae <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80009da8:	33 08       	mov	r8,48
80009daa:	ba 88       	st.b	sp[0x0],r8
80009dac:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80009dae:	f6 09 01 08 	sub	r8,r11,r9
80009db2:	58 08       	cp.w	r8,0
80009db4:	e0 8a 00 13 	brle	80009dda <PrintHex+0x6e>
	{
		char num = len - cnt;
80009db8:	12 1b       	sub	r11,r9
80009dba:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80009dbe:	18 9e       	mov	lr,r12
80009dc0:	58 0c       	cp.w	r12,0
80009dc2:	e0 8a 00 0c 	brle	80009dda <PrintHex+0x6e>
80009dc6:	1a 9b       	mov	r11,sp
80009dc8:	12 0b       	add	r11,r9
80009dca:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009dcc:	33 07       	mov	r7,48
80009dce:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009dd0:	2f f8       	sub	r8,-1
80009dd2:	1c 38       	cp.w	r8,lr
80009dd4:	cf d5       	brlt	80009dce <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009dd6:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009dda:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80009dde:	f0 cb ff ff 	sub	r11,r8,-1
80009de2:	58 0b       	cp.w	r11,0
80009de4:	e0 8a 00 19 	brle	80009e16 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80009de8:	fa cb ff f4 	sub	r11,sp,-12
80009dec:	f6 09 00 09 	add	r9,r11,r9
80009df0:	37 8b       	mov	r11,120
80009df2:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80009df6:	fa c9 ff f4 	sub	r9,sp,-12
80009dfa:	10 09       	add	r9,r8
80009dfc:	33 0b       	mov	r11,48
80009dfe:	f3 6b ff f4 	st.b	r9[-12],r11
80009e02:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80009e06:	fa ce 00 01 	sub	lr,sp,1
80009e0a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80009e0c:	11 8b       	ld.ub	r11,r8[0x0]
80009e0e:	12 cb       	st.b	r9++,r11
80009e10:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80009e12:	1c 38       	cp.w	r8,lr
80009e14:	cf c1       	brne	80009e0c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80009e16:	14 9c       	mov	r12,r10
80009e18:	2f dd       	sub	sp,-12
80009e1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80009e1e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80009e1e:	d4 21       	pushm	r4-r7,lr
80009e20:	20 3d       	sub	sp,12
80009e22:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80009e24:	30 06       	mov	r6,0
80009e26:	30 07       	mov	r7,0
80009e28:	fa e7 00 00 	st.d	sp[0],r6
80009e2c:	30 0c       	mov	r12,0
80009e2e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80009e30:	58 08       	cp.w	r8,0
80009e32:	c0 35       	brlt	80009e38 <PrintDec+0x1a>
80009e34:	14 97       	mov	r7,r10
80009e36:	c0 58       	rjmp	80009e40 <PrintDec+0x22>
	{
		*p++ = '-';
80009e38:	14 97       	mov	r7,r10
80009e3a:	32 d9       	mov	r9,45
80009e3c:	0e c9       	st.b	r7++,r9
		i = -i;
80009e3e:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80009e40:	58 08       	cp.w	r8,0
80009e42:	c0 51       	brne	80009e4c <PrintDec+0x2e>
80009e44:	33 08       	mov	r8,48
80009e46:	ba 88       	st.b	sp[0x0],r8
80009e48:	30 1e       	mov	lr,1
80009e4a:	c2 f8       	rjmp	80009ea8 <PrintDec+0x8a>
	
	int ten = i%10;
80009e4c:	e0 65 66 67 	mov	r5,26215
80009e50:	ea 15 66 66 	orh	r5,0x6666
80009e54:	f0 05 04 44 	muls.d	r4,r8,r5
80009e58:	ea 0c 14 02 	asr	r12,r5,0x2
80009e5c:	f0 09 14 1f 	asr	r9,r8,0x1f
80009e60:	f8 09 01 09 	sub	r9,r12,r9
80009e64:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009e68:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80009e6c:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80009e6e:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80009e70:	e0 66 66 67 	mov	r6,26215
80009e74:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80009e78:	2d 09       	sub	r9,-48
80009e7a:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80009e7e:	2f fe       	sub	lr,-1
		i /= 10;
80009e80:	f0 06 04 44 	muls.d	r4,r8,r6
80009e84:	ea 09 14 02 	asr	r9,r5,0x2
80009e88:	bf 58       	asr	r8,0x1f
80009e8a:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80009e8e:	f0 06 04 44 	muls.d	r4,r8,r6
80009e92:	ea 09 14 02 	asr	r9,r5,0x2
80009e96:	f0 05 14 1f 	asr	r5,r8,0x1f
80009e9a:	0a 19       	sub	r9,r5
80009e9c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80009ea0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80009ea4:	58 08       	cp.w	r8,0
80009ea6:	ce 91       	brne	80009e78 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80009ea8:	f6 0e 01 08 	sub	r8,r11,lr
80009eac:	58 08       	cp.w	r8,0
80009eae:	e0 89 00 06 	brgt	80009eba <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009eb2:	58 0e       	cp.w	lr,0
80009eb4:	e0 89 00 14 	brgt	80009edc <PrintDec+0xbe>
80009eb8:	c1 d8       	rjmp	80009ef2 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80009eba:	1c 1b       	sub	r11,lr
80009ebc:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80009ebe:	16 9c       	mov	r12,r11
80009ec0:	58 0b       	cp.w	r11,0
80009ec2:	fe 9a ff f8 	brle	80009eb2 <PrintDec+0x94>
80009ec6:	1a 99       	mov	r9,sp
80009ec8:	1c 09       	add	r9,lr
80009eca:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80009ecc:	33 06       	mov	r6,48
80009ece:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80009ed0:	2f f8       	sub	r8,-1
80009ed2:	18 38       	cp.w	r8,r12
80009ed4:	cf d5       	brlt	80009ece <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80009ed6:	f6 0e 00 0e 	add	lr,r11,lr
80009eda:	ce cb       	rjmp	80009eb2 <PrintDec+0x94>
80009edc:	fa c8 ff f4 	sub	r8,sp,-12
80009ee0:	1c 08       	add	r8,lr
80009ee2:	20 d8       	sub	r8,13
80009ee4:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80009ee8:	11 89       	ld.ub	r9,r8[0x0]
80009eea:	0e c9       	st.b	r7++,r9
80009eec:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80009eee:	16 38       	cp.w	r8,r11
80009ef0:	cf c1       	brne	80009ee8 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80009ef2:	14 9c       	mov	r12,r10
80009ef4:	2f dd       	sub	sp,-12
80009ef6:	d8 22       	popm	r4-r7,pc

80009ef8 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80009ef8:	d4 31       	pushm	r0-r7,lr
80009efa:	fa cd 02 08 	sub	sp,sp,520
80009efe:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80009f00:	e0 6a 01 00 	mov	r10,256
80009f04:	30 0b       	mov	r11,0
80009f06:	fa cc fe f8 	sub	r12,sp,-264
80009f0a:	f0 1f 00 4e 	mcall	8000a040 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80009f0e:	fa c4 fd d4 	sub	r4,sp,-556
80009f12:	30 0a       	mov	r10,0
80009f14:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009f16:	fa c3 ff fc 	sub	r3,sp,-4
80009f1a:	e0 61 01 00 	mov	r1,256
80009f1e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80009f20:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009f22:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80009f26:	02 9a       	mov	r10,r1
80009f28:	00 9b       	mov	r11,r0
80009f2a:	06 9c       	mov	r12,r3
80009f2c:	f0 1f 00 45 	mcall	8000a040 <log+0x148>
			
					if(*str == '%')
80009f30:	0f 88       	ld.ub	r8,r7[0x0]
80009f32:	e4 08 18 00 	cp.b	r8,r2
80009f36:	c5 71       	brne	80009fe4 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80009f38:	ee c8 ff ff 	sub	r8,r7,-1
80009f3c:	11 89       	ld.ub	r9,r8[0x0]
80009f3e:	4c 2a       	lddpc	r10,8000a044 <log+0x14c>
80009f40:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80009f42:	23 09       	sub	r9,48
80009f44:	30 9a       	mov	r10,9
80009f46:	f4 09 18 00 	cp.b	r9,r10
80009f4a:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80009f4e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80009f52:	f7 b9 08 30 	subls	r9,48
80009f56:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80009f5a:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80009f5e:	0f 88       	ld.ub	r8,r7[0x0]
80009f60:	22 58       	sub	r8,37
80009f62:	e0 48 00 53 	cp.w	r8,83
80009f66:	e0 8b 00 31 	brhi	80009fc8 <log+0xd0>
80009f6a:	4b 89       	lddpc	r9,8000a048 <log+0x150>
80009f6c:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80009f70:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80009f74:	06 9a       	mov	r10,r3
80009f76:	40 0b       	lddsp	r11,sp[0x0]
80009f78:	5c 5b       	castu.b	r11
80009f7a:	68 0c       	ld.w	r12,r4[0x0]
80009f7c:	f0 1f 00 34 	mcall	8000a04c <log+0x154>
							break;
80009f80:	c2 98       	rjmp	80009fd2 <log+0xda>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80009f82:	4b 4c       	lddpc	r12,8000a050 <log+0x158>
80009f84:	f0 1f 00 34 	mcall	8000a054 <log+0x15c>
80009f88:	08 95       	mov	r5,r4
80009f8a:	06 9c       	mov	r12,r3
							break;
80009f8c:	c2 38       	rjmp	80009fd2 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80009f8e:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80009f92:	06 9a       	mov	r10,r3
80009f94:	40 0b       	lddsp	r11,sp[0x0]
80009f96:	5c 5b       	castu.b	r11
80009f98:	68 0c       	ld.w	r12,r4[0x0]
80009f9a:	f0 1f 00 30 	mcall	8000a058 <log+0x160>
80009f9e:	06 9c       	mov	r12,r3
							break;
80009fa0:	c1 98       	rjmp	80009fd2 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80009fa2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80009fa6:	06 9b       	mov	r11,r3
80009fa8:	09 bc       	ld.ub	r12,r4[0x3]
80009faa:	f0 1f 00 2d 	mcall	8000a05c <log+0x164>
80009fae:	06 9c       	mov	r12,r3
							break;
80009fb0:	c1 18       	rjmp	80009fd2 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80009fb2:	e8 c5 ff fc 	sub	r5,r4,-4
80009fb6:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80009fb8:	c0 d8       	rjmp	80009fd2 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80009fba:	06 9b       	mov	r11,r3
80009fbc:	32 5c       	mov	r12,37
80009fbe:	f0 1f 00 28 	mcall	8000a05c <log+0x164>
80009fc2:	08 95       	mov	r5,r4
80009fc4:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80009fc6:	c0 68       	rjmp	80009fd2 <log+0xda>
							
							default:
							log("I need relax.");
80009fc8:	4a 6c       	lddpc	r12,8000a060 <log+0x168>
80009fca:	f0 1f 00 23 	mcall	8000a054 <log+0x15c>
80009fce:	08 95       	mov	r5,r4
80009fd0:	06 9c       	mov	r12,r3
						}
						str++;
80009fd2:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80009fd4:	1a dc       	st.w	--sp,r12
80009fd6:	1a d6       	st.w	--sp,r6
80009fd8:	4a 3b       	lddpc	r11,8000a064 <log+0x16c>
80009fda:	0c 9c       	mov	r12,r6
80009fdc:	f0 1f 00 23 	mcall	8000a068 <log+0x170>
80009fe0:	2f ed       	sub	sp,-8
80009fe2:	c0 a8       	rjmp	80009ff6 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80009fe4:	2f f7       	sub	r7,-1
80009fe6:	1a d8       	st.w	--sp,r8
80009fe8:	1a d6       	st.w	--sp,r6
80009fea:	4a 1b       	lddpc	r11,8000a06c <log+0x174>
80009fec:	0c 9c       	mov	r12,r6
80009fee:	f0 1f 00 1f 	mcall	8000a068 <log+0x170>
80009ff2:	08 95       	mov	r5,r4
80009ff4:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80009ff6:	0f 89       	ld.ub	r9,r7[0x0]
80009ff8:	30 08       	mov	r8,0
80009ffa:	f0 09 18 00 	cp.b	r9,r8
80009ffe:	c0 30       	breq	8000a004 <log+0x10c>
8000a000:	0a 94       	mov	r4,r5
8000a002:	c9 2b       	rjmp	80009f26 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000a004:	fa c7 fe f8 	sub	r7,sp,-264
8000a008:	1a d7       	st.w	--sp,r7
8000a00a:	49 ab       	lddpc	r11,8000a070 <log+0x178>
8000a00c:	0e 9c       	mov	r12,r7
8000a00e:	f0 1f 00 17 	mcall	8000a068 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000a012:	5c 5c       	castu.b	r12
8000a014:	f8 c6 ff ff 	sub	r6,r12,-1
8000a018:	0c 9c       	mov	r12,r6
8000a01a:	f0 1f 00 17 	mcall	8000a074 <log+0x17c>
8000a01e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
8000a020:	0c 9a       	mov	r10,r6
8000a022:	0e 9b       	mov	r11,r7
8000a024:	f0 1f 00 15 	mcall	8000a078 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
8000a028:	30 09       	mov	r9,0
8000a02a:	30 5a       	mov	r10,5
8000a02c:	fa cb fe f8 	sub	r11,sp,-264
8000a030:	49 38       	lddpc	r8,8000a07c <log+0x184>
8000a032:	70 0c       	ld.w	r12,r8[0x0]
8000a034:	f0 1f 00 13 	mcall	8000a080 <log+0x188>
8000a038:	2f fd       	sub	sp,-4
}
8000a03a:	fe 3d fd f8 	sub	sp,-520
8000a03e:	d8 32       	popm	r0-r7,pc
8000a040:	80 00       	ld.sh	r0,r0[0x0]
8000a042:	aa 06       	st.h	r5[0x0],r6
8000a044:	00 00       	add	r0,r0
8000a046:	13 18       	ld.sh	r8,r9++
8000a048:	80 01       	ld.sh	r1,r0[0x0]
8000a04a:	95 a0       	st.w	r10[0x28],r0
8000a04c:	80 00       	ld.sh	r0,r0[0x0]
8000a04e:	9e 1e       	ld.sh	lr,pc[0x2]
8000a050:	80 01       	ld.sh	r1,r0[0x0]
8000a052:	98 4c       	ld.sh	r12,r12[0x8]
8000a054:	80 00       	ld.sh	r0,r0[0x0]
8000a056:	9e f8       	ld.uh	r8,pc[0xe]
8000a058:	80 00       	ld.sh	r0,r0[0x0]
8000a05a:	9d 6c       	st.w	lr[0x18],r12
8000a05c:	80 00       	ld.sh	r0,r0[0x0]
8000a05e:	9d 68       	st.w	lr[0x18],r8
8000a060:	80 01       	ld.sh	r1,r0[0x0]
8000a062:	98 5c       	ld.sh	r12,r12[0xa]
8000a064:	80 01       	ld.sh	r1,r0[0x0]
8000a066:	98 6c       	ld.sh	r12,r12[0xc]
8000a068:	80 00       	ld.sh	r0,r0[0x0]
8000a06a:	ac f4       	st.b	r6[0x7],r4
8000a06c:	80 01       	ld.sh	r1,r0[0x0]
8000a06e:	98 74       	ld.sh	r4,r12[0xe]
8000a070:	80 01       	ld.sh	r1,r0[0x0]
8000a072:	98 7c       	ld.sh	r12,r12[0xe]
8000a074:	80 00       	ld.sh	r0,r0[0x0]
8000a076:	8f b4       	st.w	r7[0x2c],r4
8000a078:	80 00       	ld.sh	r0,r0[0x0]
8000a07a:	a8 be       	st.b	r4[0x3],lr
8000a07c:	00 00       	add	r0,r0
8000a07e:	46 ac       	lddsp	r12,sp[0x1a8]
8000a080:	80 00       	ld.sh	r0,r0[0x0]
8000a082:	93 08       	st.w	r9[0x0],r8

8000a084 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000a084:	d4 31       	pushm	r0-r7,lr
8000a086:	fa cd 02 0c 	sub	sp,sp,524
8000a08a:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000a08c:	e0 6a 01 00 	mov	r10,256
8000a090:	30 0b       	mov	r11,0
8000a092:	fa cc fe f4 	sub	r12,sp,-268
8000a096:	f0 1f 00 4c 	mcall	8000a1c4 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
8000a09a:	fa c4 fd d0 	sub	r4,sp,-560
8000a09e:	30 0a       	mov	r10,0
8000a0a0:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a0a2:	fa c3 ff fc 	sub	r3,sp,-4
8000a0a6:	e0 61 01 00 	mov	r1,256
8000a0aa:	14 90       	mov	r0,r10
			
			if(*str == '%')
8000a0ac:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a0ae:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a0b2:	02 9a       	mov	r10,r1
8000a0b4:	00 9b       	mov	r11,r0
8000a0b6:	06 9c       	mov	r12,r3
8000a0b8:	f0 1f 00 43 	mcall	8000a1c4 <logFromISR+0x140>
			
			if(*str == '%')
8000a0bc:	0f 88       	ld.ub	r8,r7[0x0]
8000a0be:	e4 08 18 00 	cp.b	r8,r2
8000a0c2:	c5 11       	brne	8000a164 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000a0c4:	ee c8 ff ff 	sub	r8,r7,-1
8000a0c8:	11 89       	ld.ub	r9,r8[0x0]
8000a0ca:	4c 0a       	lddpc	r10,8000a1c8 <logFromISR+0x144>
8000a0cc:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
8000a0ce:	23 09       	sub	r9,48
8000a0d0:	30 9a       	mov	r10,9
8000a0d2:	f4 09 18 00 	cp.b	r9,r10
8000a0d6:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
8000a0da:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000a0de:	f7 b9 08 30 	subls	r9,48
8000a0e2:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000a0e6:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
8000a0ea:	0f 88       	ld.ub	r8,r7[0x0]
8000a0ec:	22 58       	sub	r8,37
8000a0ee:	e0 48 00 53 	cp.w	r8,83
8000a0f2:	e0 8b 00 2b 	brhi	8000a148 <logFromISR+0xc4>
8000a0f6:	4b 69       	lddpc	r9,8000a1cc <logFromISR+0x148>
8000a0f8:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000a0fc:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
8000a100:	06 9a       	mov	r10,r3
8000a102:	40 0b       	lddsp	r11,sp[0x0]
8000a104:	5c 5b       	castu.b	r11
8000a106:	68 0c       	ld.w	r12,r4[0x0]
8000a108:	f0 1f 00 32 	mcall	8000a1d0 <logFromISR+0x14c>
					break;
8000a10c:	c2 38       	rjmp	8000a152 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000a10e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000a112:	06 9a       	mov	r10,r3
8000a114:	40 0b       	lddsp	r11,sp[0x0]
8000a116:	5c 5b       	castu.b	r11
8000a118:	68 0c       	ld.w	r12,r4[0x0]
8000a11a:	f0 1f 00 2f 	mcall	8000a1d4 <logFromISR+0x150>
8000a11e:	06 9c       	mov	r12,r3
					break;
8000a120:	c1 98       	rjmp	8000a152 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000a122:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000a126:	06 9b       	mov	r11,r3
8000a128:	09 bc       	ld.ub	r12,r4[0x3]
8000a12a:	f0 1f 00 2c 	mcall	8000a1d8 <logFromISR+0x154>
8000a12e:	06 9c       	mov	r12,r3
					break;
8000a130:	c1 18       	rjmp	8000a152 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000a132:	e8 c5 ff fc 	sub	r5,r4,-4
8000a136:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000a138:	c0 d8       	rjmp	8000a152 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000a13a:	06 9b       	mov	r11,r3
8000a13c:	32 5c       	mov	r12,37
8000a13e:	f0 1f 00 27 	mcall	8000a1d8 <logFromISR+0x154>
8000a142:	08 95       	mov	r5,r4
8000a144:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000a146:	c0 68       	rjmp	8000a152 <logFromISR+0xce>
					default:
					log("I need relax.");
8000a148:	4a 5c       	lddpc	r12,8000a1dc <logFromISR+0x158>
8000a14a:	f0 1f 00 26 	mcall	8000a1e0 <logFromISR+0x15c>
8000a14e:	08 95       	mov	r5,r4
8000a150:	06 9c       	mov	r12,r3
				}
				str++;
8000a152:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a154:	1a dc       	st.w	--sp,r12
8000a156:	1a d6       	st.w	--sp,r6
8000a158:	4a 3b       	lddpc	r11,8000a1e4 <logFromISR+0x160>
8000a15a:	0c 9c       	mov	r12,r6
8000a15c:	f0 1f 00 23 	mcall	8000a1e8 <logFromISR+0x164>
8000a160:	2f ed       	sub	sp,-8
8000a162:	c0 a8       	rjmp	8000a176 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a164:	2f f7       	sub	r7,-1
8000a166:	1a d8       	st.w	--sp,r8
8000a168:	1a d6       	st.w	--sp,r6
8000a16a:	4a 1b       	lddpc	r11,8000a1ec <logFromISR+0x168>
8000a16c:	0c 9c       	mov	r12,r6
8000a16e:	f0 1f 00 1f 	mcall	8000a1e8 <logFromISR+0x164>
8000a172:	08 95       	mov	r5,r4
8000a174:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000a176:	0f 89       	ld.ub	r9,r7[0x0]
8000a178:	30 08       	mov	r8,0
8000a17a:	f0 09 18 00 	cp.b	r9,r8
8000a17e:	c0 30       	breq	8000a184 <logFromISR+0x100>
8000a180:	0a 94       	mov	r4,r5
8000a182:	c9 8b       	rjmp	8000a0b2 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000a184:	fa c7 fe f4 	sub	r7,sp,-268
8000a188:	1a d7       	st.w	--sp,r7
8000a18a:	49 ab       	lddpc	r11,8000a1f0 <logFromISR+0x16c>
8000a18c:	0e 9c       	mov	r12,r7
8000a18e:	f0 1f 00 17 	mcall	8000a1e8 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000a192:	5c 5c       	castu.b	r12
8000a194:	f8 c6 ff ff 	sub	r6,r12,-1
8000a198:	0c 9c       	mov	r12,r6
8000a19a:	f0 1f 00 17 	mcall	8000a1f4 <logFromISR+0x170>
8000a19e:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
8000a1a0:	0c 9a       	mov	r10,r6
8000a1a2:	0e 9b       	mov	r11,r7
8000a1a4:	f0 1f 00 15 	mcall	8000a1f8 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000a1a8:	30 09       	mov	r9,0
8000a1aa:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000a1ac:	fa ca fe f8 	sub	r10,sp,-264
8000a1b0:	fa cb fe f4 	sub	r11,sp,-268
8000a1b4:	49 28       	lddpc	r8,8000a1fc <logFromISR+0x178>
8000a1b6:	70 0c       	ld.w	r12,r8[0x0]
8000a1b8:	f0 1f 00 12 	mcall	8000a200 <logFromISR+0x17c>
8000a1bc:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000a1be:	fe 3d fd f4 	sub	sp,-524
8000a1c2:	d8 32       	popm	r0-r7,pc
8000a1c4:	80 00       	ld.sh	r0,r0[0x0]
8000a1c6:	aa 06       	st.h	r5[0x0],r6
8000a1c8:	00 00       	add	r0,r0
8000a1ca:	13 19       	ld.sh	r9,r9++
8000a1cc:	80 01       	ld.sh	r1,r0[0x0]
8000a1ce:	96 f0       	ld.uh	r0,r11[0xe]
8000a1d0:	80 00       	ld.sh	r0,r0[0x0]
8000a1d2:	9e 1e       	ld.sh	lr,pc[0x2]
8000a1d4:	80 00       	ld.sh	r0,r0[0x0]
8000a1d6:	9d 6c       	st.w	lr[0x18],r12
8000a1d8:	80 00       	ld.sh	r0,r0[0x0]
8000a1da:	9d 68       	st.w	lr[0x18],r8
8000a1dc:	80 01       	ld.sh	r1,r0[0x0]
8000a1de:	98 5c       	ld.sh	r12,r12[0xa]
8000a1e0:	80 00       	ld.sh	r0,r0[0x0]
8000a1e2:	9e f8       	ld.uh	r8,pc[0xe]
8000a1e4:	80 01       	ld.sh	r1,r0[0x0]
8000a1e6:	98 6c       	ld.sh	r12,r12[0xc]
8000a1e8:	80 00       	ld.sh	r0,r0[0x0]
8000a1ea:	ac f4       	st.b	r6[0x7],r4
8000a1ec:	80 01       	ld.sh	r1,r0[0x0]
8000a1ee:	98 74       	ld.sh	r4,r12[0xe]
8000a1f0:	80 01       	ld.sh	r1,r0[0x0]
8000a1f2:	98 7c       	ld.sh	r12,r12[0xe]
8000a1f4:	80 00       	ld.sh	r0,r0[0x0]
8000a1f6:	8f b4       	st.w	r7[0x2c],r4
8000a1f8:	80 00       	ld.sh	r0,r0[0x0]
8000a1fa:	a8 be       	st.b	r4[0x3],lr
8000a1fc:	00 00       	add	r0,r0
8000a1fe:	46 ac       	lddsp	r12,sp[0x1a8]
8000a200:	80 00       	ld.sh	r0,r0[0x0]
8000a202:	92 b8       	ld.uh	r8,r9[0x6]

8000a204 <log_init>:
		
	return str;
}

void log_init(void)
{
8000a204:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000a206:	30 2b       	mov	r11,2
8000a208:	49 0c       	lddpc	r12,8000a248 <log_init+0x44>
8000a20a:	f0 1f 00 11 	mcall	8000a24c <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
8000a20e:	e0 6a 36 00 	mov	r10,13824
8000a212:	ea 1a 01 6e 	orh	r10,0x16e
8000a216:	48 fb       	lddpc	r11,8000a250 <log_init+0x4c>
8000a218:	fe 7c 18 00 	mov	r12,-59392
8000a21c:	f0 1f 00 0e 	mcall	8000a254 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000a220:	30 4b       	mov	r11,4
8000a222:	33 2c       	mov	r12,50
8000a224:	f0 1f 00 0d 	mcall	8000a258 <log_init+0x54>
8000a228:	48 d8       	lddpc	r8,8000a25c <log_init+0x58>
8000a22a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
8000a22c:	30 09       	mov	r9,0
8000a22e:	1a d9       	st.w	--sp,r9
8000a230:	1a d9       	st.w	--sp,r9
8000a232:	1a d9       	st.w	--sp,r9
8000a234:	30 28       	mov	r8,2
8000a236:	e0 6a 01 80 	mov	r10,384
8000a23a:	48 ab       	lddpc	r11,8000a260 <log_init+0x5c>
8000a23c:	48 ac       	lddpc	r12,8000a264 <log_init+0x60>
8000a23e:	f0 1f 00 0b 	mcall	8000a268 <log_init+0x64>
8000a242:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000a244:	d8 02       	popm	pc
8000a246:	00 00       	add	r0,r0
8000a248:	80 01       	ld.sh	r1,r0[0x0]
8000a24a:	98 88       	ld.uh	r8,r12[0x0]
8000a24c:	80 00       	ld.sh	r0,r0[0x0]
8000a24e:	a3 98       	lsr	r8,0x3
8000a250:	80 01       	ld.sh	r1,r0[0x0]
8000a252:	98 40       	ld.sh	r0,r12[0x8]
8000a254:	80 00       	ld.sh	r0,r0[0x0]
8000a256:	63 e4       	ld.w	r4,r1[0x78]
8000a258:	80 00       	ld.sh	r0,r0[0x0]
8000a25a:	94 60       	ld.sh	r0,r10[0xc]
8000a25c:	00 00       	add	r0,r0
8000a25e:	46 ac       	lddsp	r12,sp[0x1a8]
8000a260:	80 01       	ld.sh	r1,r0[0x0]
8000a262:	98 84       	ld.uh	r4,r12[0x0]
8000a264:	80 00       	ld.sh	r0,r0[0x0]
8000a266:	a2 6c       	st.h	r1[0xc],r12
8000a268:	80 00       	ld.sh	r0,r0[0x0]
8000a26a:	9b 34       	st.w	sp[0xc],r4

8000a26c <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
8000a26c:	eb cd 40 f8 	pushm	r3-r7,lr
8000a270:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000a272:	48 c7       	lddpc	r7,8000a2a0 <task_log+0x34>
8000a274:	30 05       	mov	r5,0
8000a276:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
8000a278:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000a27c:	0a 99       	mov	r9,r5
8000a27e:	08 9a       	mov	r10,r4
8000a280:	1a 9b       	mov	r11,sp
8000a282:	6e 0c       	ld.w	r12,r7[0x0]
8000a284:	f0 1f 00 08 	mcall	8000a2a4 <task_log+0x38>
8000a288:	58 1c       	cp.w	r12,1
8000a28a:	cf 91       	brne	8000a27c <task_log+0x10>
		{
			if( NULL != str)
8000a28c:	40 0b       	lddsp	r11,sp[0x0]
8000a28e:	58 0b       	cp.w	r11,0
8000a290:	cf 60       	breq	8000a27c <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000a292:	06 9c       	mov	r12,r3
8000a294:	f0 1f 00 05 	mcall	8000a2a8 <task_log+0x3c>
				vPortFree(str);
8000a298:	40 0c       	lddsp	r12,sp[0x0]
8000a29a:	f0 1f 00 05 	mcall	8000a2ac <task_log+0x40>
8000a29e:	ce fb       	rjmp	8000a27c <task_log+0x10>
8000a2a0:	00 00       	add	r0,r0
8000a2a2:	46 ac       	lddsp	r12,sp[0x1a8]
8000a2a4:	80 00       	ld.sh	r0,r0[0x0]
8000a2a6:	90 fc       	ld.uh	r12,r8[0xe]
8000a2a8:	80 00       	ld.sh	r0,r0[0x0]
8000a2aa:	63 94       	ld.w	r4,r1[0x64]
8000a2ac:	80 00       	ld.sh	r0,r0[0x0]
8000a2ae:	8f 8c       	st.w	r7[0x20],r12

8000a2b0 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
8000a2b0:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000a2b2:	fe 78 10 00 	mov	r8,-61440
8000a2b6:	30 19       	mov	r9,1
8000a2b8:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000a2bc:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000a2c0:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000a2c4:	d3 03       	ssrf	0x10
	local_start_pll0();
8000a2c6:	f0 1f 00 14 	mcall	8000a314 <main+0x64>
		
	INTC_init_interrupts();
8000a2ca:	f0 1f 00 14 	mcall	8000a318 <main+0x68>
	
	log_init();		
8000a2ce:	f0 1f 00 14 	mcall	8000a31c <main+0x6c>
	log("----start debug----");	
8000a2d2:	49 4c       	lddpc	r12,8000a320 <main+0x70>
8000a2d4:	f0 1f 00 14 	mcall	8000a324 <main+0x74>
		
	rtc_init();
8000a2d8:	f0 1f 00 14 	mcall	8000a328 <main+0x78>
	
	fs_init();//65795
8000a2dc:	f0 1f 00 14 	mcall	8000a32c <main+0x7c>

	tc_init();	
8000a2e0:	f0 1f 00 14 	mcall	8000a330 <main+0x80>
			
	xcmp_init();
8000a2e4:	f0 1f 00 14 	mcall	8000a334 <main+0x84>
	
	app_init();
8000a2e8:	f0 1f 00 14 	mcall	8000a338 <main+0x88>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000a2ec:	fe 79 10 00 	mov	r9,-61440
8000a2f0:	f2 f8 01 60 	ld.w	r8,r9[352]
8000a2f4:	e2 18 00 02 	andl	r8,0x2,COH
8000a2f8:	cf c0       	breq	8000a2f0 <main+0x40>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000a2fa:	fe 79 10 00 	mov	r9,-61440
8000a2fe:	f2 f8 01 60 	ld.w	r8,r9[352]
8000a302:	e2 18 00 02 	andl	r8,0x2,COH
8000a306:	cf c1       	brne	8000a2fe <main+0x4e>
	local_start_timer();
8000a308:	f0 1f 00 0d 	mcall	8000a33c <main+0x8c>
	
	Enable_global_interrupt();
8000a30c:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
8000a30e:	f0 1f 00 0d 	mcall	8000a340 <main+0x90>
	return 0;
}
8000a312:	d8 0a       	popm	pc,r12=0
8000a314:	80 00       	ld.sh	r0,r0[0x0]
8000a316:	59 5c       	cp.w	r12,21
8000a318:	80 00       	ld.sh	r0,r0[0x0]
8000a31a:	5c f4       	rol	r4
8000a31c:	80 00       	ld.sh	r0,r0[0x0]
8000a31e:	a2 04       	st.h	r1[0x0],r4
8000a320:	80 01       	ld.sh	r1,r0[0x0]
8000a322:	98 98       	ld.uh	r8,r12[0x2]
8000a324:	80 00       	ld.sh	r0,r0[0x0]
8000a326:	9e f8       	ld.uh	r8,pc[0xe]
8000a328:	80 00       	ld.sh	r0,r0[0x0]
8000a32a:	5b 28       	cp.w	r8,-14
8000a32c:	80 00       	ld.sh	r0,r0[0x0]
8000a32e:	3b 78       	mov	r8,-73
8000a330:	80 00       	ld.sh	r0,r0[0x0]
8000a332:	5b f0       	cp.w	r0,-1
8000a334:	80 00       	ld.sh	r0,r0[0x0]
8000a336:	52 60       	stdsp	sp[0x98],r0
8000a338:	80 00       	ld.sh	r0,r0[0x0]
8000a33a:	20 48       	sub	r8,4
8000a33c:	80 00       	ld.sh	r0,r0[0x0]
8000a33e:	5b b4       	cp.w	r4,-5
8000a340:	80 00       	ld.sh	r0,r0[0x0]
8000a342:	9d 1c       	st.w	lr[0x4],r12

8000a344 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a344:	f8 08 16 05 	lsr	r8,r12,0x5
8000a348:	a9 68       	lsl	r8,0x8
8000a34a:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
8000a34e:	58 1b       	cp.w	r11,1
8000a350:	c0 d0       	breq	8000a36a <gpio_enable_module_pin+0x26>
8000a352:	c0 63       	brcs	8000a35e <gpio_enable_module_pin+0x1a>
8000a354:	58 2b       	cp.w	r11,2
8000a356:	c1 00       	breq	8000a376 <gpio_enable_module_pin+0x32>
8000a358:	58 3b       	cp.w	r11,3
8000a35a:	c1 40       	breq	8000a382 <gpio_enable_module_pin+0x3e>
8000a35c:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000a35e:	30 19       	mov	r9,1
8000a360:	f2 0c 09 49 	lsl	r9,r9,r12
8000a364:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000a366:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a368:	c1 28       	rjmp	8000a38c <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000a36a:	30 19       	mov	r9,1
8000a36c:	f2 0c 09 49 	lsl	r9,r9,r12
8000a370:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000a372:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a374:	c0 c8       	rjmp	8000a38c <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000a376:	30 19       	mov	r9,1
8000a378:	f2 0c 09 49 	lsl	r9,r9,r12
8000a37c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000a37e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000a380:	c0 68       	rjmp	8000a38c <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000a382:	30 19       	mov	r9,1
8000a384:	f2 0c 09 49 	lsl	r9,r9,r12
8000a388:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000a38a:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000a38c:	30 19       	mov	r9,1
8000a38e:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a392:	91 2c       	st.w	r8[0x8],r12
8000a394:	5e fd       	retal	0
8000a396:	d7 03       	nop

8000a398 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000a398:	d4 21       	pushm	r4-r7,lr
8000a39a:	18 97       	mov	r7,r12
8000a39c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a39e:	58 0b       	cp.w	r11,0
8000a3a0:	c0 31       	brne	8000a3a6 <gpio_enable_module+0xe>
8000a3a2:	30 05       	mov	r5,0
8000a3a4:	c0 d8       	rjmp	8000a3be <gpio_enable_module+0x26>
8000a3a6:	30 06       	mov	r6,0
8000a3a8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000a3aa:	6e 1b       	ld.w	r11,r7[0x4]
8000a3ac:	6e 0c       	ld.w	r12,r7[0x0]
8000a3ae:	f0 1f 00 06 	mcall	8000a3c4 <gpio_enable_module+0x2c>
8000a3b2:	18 45       	or	r5,r12
		gpiomap++;
8000a3b4:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a3b6:	2f f6       	sub	r6,-1
8000a3b8:	0c 34       	cp.w	r4,r6
8000a3ba:	fe 9b ff f8 	brhi	8000a3aa <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000a3be:	0a 9c       	mov	r12,r5
8000a3c0:	d8 22       	popm	r4-r7,pc
8000a3c2:	00 00       	add	r0,r0
8000a3c4:	80 00       	ld.sh	r0,r0[0x0]
8000a3c6:	a3 44       	asr	r4,0x2

8000a3c8 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a3c8:	f8 08 16 05 	lsr	r8,r12,0x5
8000a3cc:	a9 68       	lsl	r8,0x8
8000a3ce:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
8000a3d2:	30 19       	mov	r9,1
8000a3d4:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a3d8:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000a3dc:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000a3e0:	91 1c       	st.w	r8[0x4],r12
}
8000a3e2:	5e fc       	retal	r12

8000a3e4 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a3e4:	f8 08 16 05 	lsr	r8,r12,0x5
8000a3e8:	a9 68       	lsl	r8,0x8
8000a3ea:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000a3ee:	30 19       	mov	r9,1
8000a3f0:	f2 0c 09 4c 	lsl	r12,r9,r12
8000a3f4:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000a3f8:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000a3fc:	91 1c       	st.w	r8[0x4],r12
}
8000a3fe:	5e fc       	retal	r12

8000a400 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000a400:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000a404:	fe c0 a4 04 	sub	r0,pc,-23548

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000a408:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000a40c:	d5 53       	csrf	0x15
  cp      r0, r1
8000a40e:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000a410:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000a414:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000a416:	c0 62       	brcc	8000a422 <idata_load_loop_end>
  cp      r0, r1
8000a418:	48 92       	lddpc	r2,8000a43c <udata_clear_loop_end+0x4>

8000a41a <idata_load_loop>:
  brlo    idata_load_loop
8000a41a:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000a41c:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000a41e:	02 30       	cp.w	r0,r1
  cp      r0, r1
8000a420:	cf d3       	brcs	8000a41a <idata_load_loop>

8000a422 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000a422:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
8000a426:	e0 61 46 b8 	mov	r1,18104
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
8000a42a:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
8000a42c:	c0 62       	brcc	8000a438 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000a42e:	30 02       	mov	r2,0
8000a430:	30 03       	mov	r3,0

8000a432 <udata_clear_loop>:
8000a432:	a1 22       	st.d	r0++,r2
8000a434:	02 30       	cp.w	r0,r1
8000a436:	cf e3       	brcs	8000a432 <udata_clear_loop>

8000a438 <udata_clear_loop_end>:
8000a438:	fe cf 01 88 	sub	pc,pc,392
8000a43c:	80 01       	ld.sh	r1,r0[0x0]
8000a43e:	9e 30       	ld.sh	r0,pc[0x6]

8000a440 <free>:
8000a440:	d4 01       	pushm	lr
8000a442:	e0 68 0a 38 	mov	r8,2616
8000a446:	18 9b       	mov	r11,r12
8000a448:	70 0c       	ld.w	r12,r8[0x0]
8000a44a:	e0 a0 1f 19 	rcall	8000e27c <_free_r>
8000a44e:	d8 02       	popm	pc

8000a450 <malloc>:
8000a450:	d4 01       	pushm	lr
8000a452:	e0 68 0a 38 	mov	r8,2616
8000a456:	18 9b       	mov	r11,r12
8000a458:	70 0c       	ld.w	r12,r8[0x0]
8000a45a:	c0 3c       	rcall	8000a460 <_malloc_r>
8000a45c:	d8 02       	popm	pc
8000a45e:	d7 03       	nop

8000a460 <_malloc_r>:
8000a460:	d4 31       	pushm	r0-r7,lr
8000a462:	f6 c8 ff f5 	sub	r8,r11,-11
8000a466:	18 95       	mov	r5,r12
8000a468:	10 97       	mov	r7,r8
8000a46a:	e0 17 ff f8 	andl	r7,0xfff8
8000a46e:	59 68       	cp.w	r8,22
8000a470:	f9 b7 08 10 	movls	r7,16
8000a474:	16 37       	cp.w	r7,r11
8000a476:	5f 38       	srlo	r8
8000a478:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000a47c:	c0 50       	breq	8000a486 <_malloc_r+0x26>
8000a47e:	30 c8       	mov	r8,12
8000a480:	99 38       	st.w	r12[0xc],r8
8000a482:	e0 8f 01 fa 	bral	8000a876 <_malloc_r+0x416>
8000a486:	fe b0 f5 39 	rcall	80008ef8 <__malloc_lock>
8000a48a:	e0 47 01 f7 	cp.w	r7,503
8000a48e:	e0 8b 00 1d 	brhi	8000a4c8 <_malloc_r+0x68>
8000a492:	ee 03 16 03 	lsr	r3,r7,0x3
8000a496:	e0 68 05 38 	mov	r8,1336
8000a49a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000a49e:	70 36       	ld.w	r6,r8[0xc]
8000a4a0:	10 36       	cp.w	r6,r8
8000a4a2:	c0 61       	brne	8000a4ae <_malloc_r+0x4e>
8000a4a4:	ec c8 ff f8 	sub	r8,r6,-8
8000a4a8:	70 36       	ld.w	r6,r8[0xc]
8000a4aa:	10 36       	cp.w	r6,r8
8000a4ac:	c0 c0       	breq	8000a4c4 <_malloc_r+0x64>
8000a4ae:	6c 18       	ld.w	r8,r6[0x4]
8000a4b0:	e0 18 ff fc 	andl	r8,0xfffc
8000a4b4:	6c 3a       	ld.w	r10,r6[0xc]
8000a4b6:	ec 08 00 09 	add	r9,r6,r8
8000a4ba:	0a 9c       	mov	r12,r5
8000a4bc:	6c 28       	ld.w	r8,r6[0x8]
8000a4be:	95 28       	st.w	r10[0x8],r8
8000a4c0:	91 3a       	st.w	r8[0xc],r10
8000a4c2:	c4 78       	rjmp	8000a550 <_malloc_r+0xf0>
8000a4c4:	2f e3       	sub	r3,-2
8000a4c6:	c4 d8       	rjmp	8000a560 <_malloc_r+0x100>
8000a4c8:	ee 03 16 09 	lsr	r3,r7,0x9
8000a4cc:	c0 41       	brne	8000a4d4 <_malloc_r+0x74>
8000a4ce:	ee 03 16 03 	lsr	r3,r7,0x3
8000a4d2:	c2 68       	rjmp	8000a51e <_malloc_r+0xbe>
8000a4d4:	58 43       	cp.w	r3,4
8000a4d6:	e0 8b 00 06 	brhi	8000a4e2 <_malloc_r+0x82>
8000a4da:	ee 03 16 06 	lsr	r3,r7,0x6
8000a4de:	2c 83       	sub	r3,-56
8000a4e0:	c1 f8       	rjmp	8000a51e <_malloc_r+0xbe>
8000a4e2:	59 43       	cp.w	r3,20
8000a4e4:	e0 8b 00 04 	brhi	8000a4ec <_malloc_r+0x8c>
8000a4e8:	2a 53       	sub	r3,-91
8000a4ea:	c1 a8       	rjmp	8000a51e <_malloc_r+0xbe>
8000a4ec:	e0 43 00 54 	cp.w	r3,84
8000a4f0:	e0 8b 00 06 	brhi	8000a4fc <_malloc_r+0x9c>
8000a4f4:	ee 03 16 0c 	lsr	r3,r7,0xc
8000a4f8:	29 23       	sub	r3,-110
8000a4fa:	c1 28       	rjmp	8000a51e <_malloc_r+0xbe>
8000a4fc:	e0 43 01 54 	cp.w	r3,340
8000a500:	e0 8b 00 06 	brhi	8000a50c <_malloc_r+0xac>
8000a504:	ee 03 16 0f 	lsr	r3,r7,0xf
8000a508:	28 93       	sub	r3,-119
8000a50a:	c0 a8       	rjmp	8000a51e <_malloc_r+0xbe>
8000a50c:	e0 43 05 54 	cp.w	r3,1364
8000a510:	e0 88 00 04 	brls	8000a518 <_malloc_r+0xb8>
8000a514:	37 e3       	mov	r3,126
8000a516:	c0 48       	rjmp	8000a51e <_malloc_r+0xbe>
8000a518:	ee 03 16 12 	lsr	r3,r7,0x12
8000a51c:	28 43       	sub	r3,-124
8000a51e:	e0 6a 05 38 	mov	r10,1336
8000a522:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000a526:	74 36       	ld.w	r6,r10[0xc]
8000a528:	c1 98       	rjmp	8000a55a <_malloc_r+0xfa>
8000a52a:	6c 19       	ld.w	r9,r6[0x4]
8000a52c:	e0 19 ff fc 	andl	r9,0xfffc
8000a530:	f2 07 01 0b 	sub	r11,r9,r7
8000a534:	58 fb       	cp.w	r11,15
8000a536:	e0 8a 00 04 	brle	8000a53e <_malloc_r+0xde>
8000a53a:	20 13       	sub	r3,1
8000a53c:	c1 18       	rjmp	8000a55e <_malloc_r+0xfe>
8000a53e:	6c 38       	ld.w	r8,r6[0xc]
8000a540:	58 0b       	cp.w	r11,0
8000a542:	c0 b5       	brlt	8000a558 <_malloc_r+0xf8>
8000a544:	6c 2a       	ld.w	r10,r6[0x8]
8000a546:	ec 09 00 09 	add	r9,r6,r9
8000a54a:	0a 9c       	mov	r12,r5
8000a54c:	91 2a       	st.w	r8[0x8],r10
8000a54e:	95 38       	st.w	r10[0xc],r8
8000a550:	72 18       	ld.w	r8,r9[0x4]
8000a552:	a1 a8       	sbr	r8,0x0
8000a554:	93 18       	st.w	r9[0x4],r8
8000a556:	cb c8       	rjmp	8000a6ce <_malloc_r+0x26e>
8000a558:	10 96       	mov	r6,r8
8000a55a:	14 36       	cp.w	r6,r10
8000a55c:	ce 71       	brne	8000a52a <_malloc_r+0xca>
8000a55e:	2f f3       	sub	r3,-1
8000a560:	e0 6a 05 38 	mov	r10,1336
8000a564:	f4 cc ff f8 	sub	r12,r10,-8
8000a568:	78 26       	ld.w	r6,r12[0x8]
8000a56a:	18 36       	cp.w	r6,r12
8000a56c:	c6 c0       	breq	8000a644 <_malloc_r+0x1e4>
8000a56e:	6c 19       	ld.w	r9,r6[0x4]
8000a570:	e0 19 ff fc 	andl	r9,0xfffc
8000a574:	f2 07 01 08 	sub	r8,r9,r7
8000a578:	58 f8       	cp.w	r8,15
8000a57a:	e0 89 00 8f 	brgt	8000a698 <_malloc_r+0x238>
8000a57e:	99 3c       	st.w	r12[0xc],r12
8000a580:	99 2c       	st.w	r12[0x8],r12
8000a582:	58 08       	cp.w	r8,0
8000a584:	c0 55       	brlt	8000a58e <_malloc_r+0x12e>
8000a586:	ec 09 00 09 	add	r9,r6,r9
8000a58a:	0a 9c       	mov	r12,r5
8000a58c:	ce 2b       	rjmp	8000a550 <_malloc_r+0xf0>
8000a58e:	e0 49 01 ff 	cp.w	r9,511
8000a592:	e0 8b 00 13 	brhi	8000a5b8 <_malloc_r+0x158>
8000a596:	a3 99       	lsr	r9,0x3
8000a598:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000a59c:	70 2b       	ld.w	r11,r8[0x8]
8000a59e:	8d 38       	st.w	r6[0xc],r8
8000a5a0:	8d 2b       	st.w	r6[0x8],r11
8000a5a2:	97 36       	st.w	r11[0xc],r6
8000a5a4:	91 26       	st.w	r8[0x8],r6
8000a5a6:	a3 49       	asr	r9,0x2
8000a5a8:	74 18       	ld.w	r8,r10[0x4]
8000a5aa:	30 1b       	mov	r11,1
8000a5ac:	f6 09 09 49 	lsl	r9,r11,r9
8000a5b0:	f1 e9 10 09 	or	r9,r8,r9
8000a5b4:	95 19       	st.w	r10[0x4],r9
8000a5b6:	c4 78       	rjmp	8000a644 <_malloc_r+0x1e4>
8000a5b8:	f2 0a 16 09 	lsr	r10,r9,0x9
8000a5bc:	58 4a       	cp.w	r10,4
8000a5be:	e0 8b 00 07 	brhi	8000a5cc <_malloc_r+0x16c>
8000a5c2:	f2 0a 16 06 	lsr	r10,r9,0x6
8000a5c6:	2c 8a       	sub	r10,-56
8000a5c8:	c2 08       	rjmp	8000a608 <_malloc_r+0x1a8>
8000a5ca:	d7 03       	nop
8000a5cc:	59 4a       	cp.w	r10,20
8000a5ce:	e0 8b 00 04 	brhi	8000a5d6 <_malloc_r+0x176>
8000a5d2:	2a 5a       	sub	r10,-91
8000a5d4:	c1 a8       	rjmp	8000a608 <_malloc_r+0x1a8>
8000a5d6:	e0 4a 00 54 	cp.w	r10,84
8000a5da:	e0 8b 00 06 	brhi	8000a5e6 <_malloc_r+0x186>
8000a5de:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000a5e2:	29 2a       	sub	r10,-110
8000a5e4:	c1 28       	rjmp	8000a608 <_malloc_r+0x1a8>
8000a5e6:	e0 4a 01 54 	cp.w	r10,340
8000a5ea:	e0 8b 00 06 	brhi	8000a5f6 <_malloc_r+0x196>
8000a5ee:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000a5f2:	28 9a       	sub	r10,-119
8000a5f4:	c0 a8       	rjmp	8000a608 <_malloc_r+0x1a8>
8000a5f6:	e0 4a 05 54 	cp.w	r10,1364
8000a5fa:	e0 88 00 04 	brls	8000a602 <_malloc_r+0x1a2>
8000a5fe:	37 ea       	mov	r10,126
8000a600:	c0 48       	rjmp	8000a608 <_malloc_r+0x1a8>
8000a602:	f2 0a 16 12 	lsr	r10,r9,0x12
8000a606:	28 4a       	sub	r10,-124
8000a608:	e0 6b 05 38 	mov	r11,1336
8000a60c:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000a610:	68 28       	ld.w	r8,r4[0x8]
8000a612:	08 38       	cp.w	r8,r4
8000a614:	c0 e1       	brne	8000a630 <_malloc_r+0x1d0>
8000a616:	76 19       	ld.w	r9,r11[0x4]
8000a618:	a3 4a       	asr	r10,0x2
8000a61a:	30 1e       	mov	lr,1
8000a61c:	fc 0a 09 4a 	lsl	r10,lr,r10
8000a620:	f3 ea 10 0a 	or	r10,r9,r10
8000a624:	10 99       	mov	r9,r8
8000a626:	97 1a       	st.w	r11[0x4],r10
8000a628:	c0 a8       	rjmp	8000a63c <_malloc_r+0x1dc>
8000a62a:	70 28       	ld.w	r8,r8[0x8]
8000a62c:	08 38       	cp.w	r8,r4
8000a62e:	c0 60       	breq	8000a63a <_malloc_r+0x1da>
8000a630:	70 1a       	ld.w	r10,r8[0x4]
8000a632:	e0 1a ff fc 	andl	r10,0xfffc
8000a636:	14 39       	cp.w	r9,r10
8000a638:	cf 93       	brcs	8000a62a <_malloc_r+0x1ca>
8000a63a:	70 39       	ld.w	r9,r8[0xc]
8000a63c:	8d 39       	st.w	r6[0xc],r9
8000a63e:	8d 28       	st.w	r6[0x8],r8
8000a640:	91 36       	st.w	r8[0xc],r6
8000a642:	93 26       	st.w	r9[0x8],r6
8000a644:	e6 08 14 02 	asr	r8,r3,0x2
8000a648:	30 1b       	mov	r11,1
8000a64a:	e0 64 05 38 	mov	r4,1336
8000a64e:	f6 08 09 4b 	lsl	r11,r11,r8
8000a652:	68 18       	ld.w	r8,r4[0x4]
8000a654:	10 3b       	cp.w	r11,r8
8000a656:	e0 8b 00 6b 	brhi	8000a72c <_malloc_r+0x2cc>
8000a65a:	f7 e8 00 09 	and	r9,r11,r8
8000a65e:	c0 b1       	brne	8000a674 <_malloc_r+0x214>
8000a660:	e0 13 ff fc 	andl	r3,0xfffc
8000a664:	a1 7b       	lsl	r11,0x1
8000a666:	2f c3       	sub	r3,-4
8000a668:	c0 38       	rjmp	8000a66e <_malloc_r+0x20e>
8000a66a:	2f c3       	sub	r3,-4
8000a66c:	a1 7b       	lsl	r11,0x1
8000a66e:	f7 e8 00 09 	and	r9,r11,r8
8000a672:	cf c0       	breq	8000a66a <_malloc_r+0x20a>
8000a674:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000a678:	06 92       	mov	r2,r3
8000a67a:	1c 91       	mov	r1,lr
8000a67c:	62 36       	ld.w	r6,r1[0xc]
8000a67e:	c2 e8       	rjmp	8000a6da <_malloc_r+0x27a>
8000a680:	6c 1a       	ld.w	r10,r6[0x4]
8000a682:	e0 1a ff fc 	andl	r10,0xfffc
8000a686:	f4 07 01 08 	sub	r8,r10,r7
8000a68a:	58 f8       	cp.w	r8,15
8000a68c:	e0 8a 00 15 	brle	8000a6b6 <_malloc_r+0x256>
8000a690:	6c 3a       	ld.w	r10,r6[0xc]
8000a692:	6c 29       	ld.w	r9,r6[0x8]
8000a694:	95 29       	st.w	r10[0x8],r9
8000a696:	93 3a       	st.w	r9[0xc],r10
8000a698:	0e 99       	mov	r9,r7
8000a69a:	ec 07 00 07 	add	r7,r6,r7
8000a69e:	a1 a9       	sbr	r9,0x0
8000a6a0:	99 37       	st.w	r12[0xc],r7
8000a6a2:	99 27       	st.w	r12[0x8],r7
8000a6a4:	8d 19       	st.w	r6[0x4],r9
8000a6a6:	ee 08 09 08 	st.w	r7[r8],r8
8000a6aa:	8f 2c       	st.w	r7[0x8],r12
8000a6ac:	8f 3c       	st.w	r7[0xc],r12
8000a6ae:	a1 a8       	sbr	r8,0x0
8000a6b0:	0a 9c       	mov	r12,r5
8000a6b2:	8f 18       	st.w	r7[0x4],r8
8000a6b4:	c0 d8       	rjmp	8000a6ce <_malloc_r+0x26e>
8000a6b6:	6c 39       	ld.w	r9,r6[0xc]
8000a6b8:	58 08       	cp.w	r8,0
8000a6ba:	c0 f5       	brlt	8000a6d8 <_malloc_r+0x278>
8000a6bc:	ec 0a 00 0a 	add	r10,r6,r10
8000a6c0:	74 18       	ld.w	r8,r10[0x4]
8000a6c2:	a1 a8       	sbr	r8,0x0
8000a6c4:	0a 9c       	mov	r12,r5
8000a6c6:	95 18       	st.w	r10[0x4],r8
8000a6c8:	6c 28       	ld.w	r8,r6[0x8]
8000a6ca:	93 28       	st.w	r9[0x8],r8
8000a6cc:	91 39       	st.w	r8[0xc],r9
8000a6ce:	fe b0 f4 1b 	rcall	80008f04 <__malloc_unlock>
8000a6d2:	ec cc ff f8 	sub	r12,r6,-8
8000a6d6:	d8 32       	popm	r0-r7,pc
8000a6d8:	12 96       	mov	r6,r9
8000a6da:	02 36       	cp.w	r6,r1
8000a6dc:	cd 21       	brne	8000a680 <_malloc_r+0x220>
8000a6de:	2f f2       	sub	r2,-1
8000a6e0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000a6e4:	c0 30       	breq	8000a6ea <_malloc_r+0x28a>
8000a6e6:	2f 81       	sub	r1,-8
8000a6e8:	cc ab       	rjmp	8000a67c <_malloc_r+0x21c>
8000a6ea:	1c 98       	mov	r8,lr
8000a6ec:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000a6f0:	c0 81       	brne	8000a700 <_malloc_r+0x2a0>
8000a6f2:	68 19       	ld.w	r9,r4[0x4]
8000a6f4:	f6 08 11 ff 	rsub	r8,r11,-1
8000a6f8:	f3 e8 00 08 	and	r8,r9,r8
8000a6fc:	89 18       	st.w	r4[0x4],r8
8000a6fe:	c0 78       	rjmp	8000a70c <_malloc_r+0x2ac>
8000a700:	f0 c9 00 08 	sub	r9,r8,8
8000a704:	20 13       	sub	r3,1
8000a706:	70 08       	ld.w	r8,r8[0x0]
8000a708:	12 38       	cp.w	r8,r9
8000a70a:	cf 10       	breq	8000a6ec <_malloc_r+0x28c>
8000a70c:	a1 7b       	lsl	r11,0x1
8000a70e:	68 18       	ld.w	r8,r4[0x4]
8000a710:	10 3b       	cp.w	r11,r8
8000a712:	e0 8b 00 0d 	brhi	8000a72c <_malloc_r+0x2cc>
8000a716:	58 0b       	cp.w	r11,0
8000a718:	c0 a0       	breq	8000a72c <_malloc_r+0x2cc>
8000a71a:	04 93       	mov	r3,r2
8000a71c:	c0 38       	rjmp	8000a722 <_malloc_r+0x2c2>
8000a71e:	2f c3       	sub	r3,-4
8000a720:	a1 7b       	lsl	r11,0x1
8000a722:	f7 e8 00 09 	and	r9,r11,r8
8000a726:	ca 71       	brne	8000a674 <_malloc_r+0x214>
8000a728:	cf bb       	rjmp	8000a71e <_malloc_r+0x2be>
8000a72a:	d7 03       	nop
8000a72c:	68 23       	ld.w	r3,r4[0x8]
8000a72e:	66 12       	ld.w	r2,r3[0x4]
8000a730:	e0 12 ff fc 	andl	r2,0xfffc
8000a734:	0e 32       	cp.w	r2,r7
8000a736:	5f 39       	srlo	r9
8000a738:	e4 07 01 08 	sub	r8,r2,r7
8000a73c:	58 f8       	cp.w	r8,15
8000a73e:	5f aa       	srle	r10
8000a740:	f5 e9 10 09 	or	r9,r10,r9
8000a744:	e0 80 00 9a 	breq	8000a878 <_malloc_r+0x418>
8000a748:	e0 68 13 24 	mov	r8,4900
8000a74c:	70 01       	ld.w	r1,r8[0x0]
8000a74e:	e0 68 09 44 	mov	r8,2372
8000a752:	2f 01       	sub	r1,-16
8000a754:	70 08       	ld.w	r8,r8[0x0]
8000a756:	0e 01       	add	r1,r7
8000a758:	5b f8       	cp.w	r8,-1
8000a75a:	c0 40       	breq	8000a762 <_malloc_r+0x302>
8000a75c:	28 11       	sub	r1,-127
8000a75e:	e0 11 ff 80 	andl	r1,0xff80
8000a762:	02 9b       	mov	r11,r1
8000a764:	0a 9c       	mov	r12,r5
8000a766:	e0 a0 02 b7 	rcall	8000acd4 <_sbrk_r>
8000a76a:	18 96       	mov	r6,r12
8000a76c:	5b fc       	cp.w	r12,-1
8000a76e:	c7 50       	breq	8000a858 <_malloc_r+0x3f8>
8000a770:	e6 02 00 08 	add	r8,r3,r2
8000a774:	10 3c       	cp.w	r12,r8
8000a776:	c0 32       	brcc	8000a77c <_malloc_r+0x31c>
8000a778:	08 33       	cp.w	r3,r4
8000a77a:	c6 f1       	brne	8000a858 <_malloc_r+0x3f8>
8000a77c:	e0 6a 13 28 	mov	r10,4904
8000a780:	74 09       	ld.w	r9,r10[0x0]
8000a782:	e2 09 00 09 	add	r9,r1,r9
8000a786:	95 09       	st.w	r10[0x0],r9
8000a788:	10 36       	cp.w	r6,r8
8000a78a:	c0 a1       	brne	8000a79e <_malloc_r+0x33e>
8000a78c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000a790:	c0 71       	brne	8000a79e <_malloc_r+0x33e>
8000a792:	e2 02 00 02 	add	r2,r1,r2
8000a796:	68 28       	ld.w	r8,r4[0x8]
8000a798:	a1 a2       	sbr	r2,0x0
8000a79a:	91 12       	st.w	r8[0x4],r2
8000a79c:	c4 f8       	rjmp	8000a83a <_malloc_r+0x3da>
8000a79e:	e0 6a 09 44 	mov	r10,2372
8000a7a2:	74 0b       	ld.w	r11,r10[0x0]
8000a7a4:	5b fb       	cp.w	r11,-1
8000a7a6:	c0 31       	brne	8000a7ac <_malloc_r+0x34c>
8000a7a8:	95 06       	st.w	r10[0x0],r6
8000a7aa:	c0 78       	rjmp	8000a7b8 <_malloc_r+0x358>
8000a7ac:	ec 09 00 09 	add	r9,r6,r9
8000a7b0:	e0 6a 13 28 	mov	r10,4904
8000a7b4:	10 19       	sub	r9,r8
8000a7b6:	95 09       	st.w	r10[0x0],r9
8000a7b8:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000a7bc:	f0 09 11 08 	rsub	r9,r8,8
8000a7c0:	58 08       	cp.w	r8,0
8000a7c2:	f2 08 17 10 	movne	r8,r9
8000a7c6:	ed d8 e1 06 	addne	r6,r6,r8
8000a7ca:	28 08       	sub	r8,-128
8000a7cc:	ec 01 00 01 	add	r1,r6,r1
8000a7d0:	0a 9c       	mov	r12,r5
8000a7d2:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000a7d6:	f0 01 01 01 	sub	r1,r8,r1
8000a7da:	02 9b       	mov	r11,r1
8000a7dc:	e0 a0 02 7c 	rcall	8000acd4 <_sbrk_r>
8000a7e0:	e0 68 13 28 	mov	r8,4904
8000a7e4:	5b fc       	cp.w	r12,-1
8000a7e6:	ec 0c 17 00 	moveq	r12,r6
8000a7ea:	f9 b1 00 00 	moveq	r1,0
8000a7ee:	70 09       	ld.w	r9,r8[0x0]
8000a7f0:	0c 1c       	sub	r12,r6
8000a7f2:	89 26       	st.w	r4[0x8],r6
8000a7f4:	02 0c       	add	r12,r1
8000a7f6:	12 01       	add	r1,r9
8000a7f8:	a1 ac       	sbr	r12,0x0
8000a7fa:	91 01       	st.w	r8[0x0],r1
8000a7fc:	8d 1c       	st.w	r6[0x4],r12
8000a7fe:	08 33       	cp.w	r3,r4
8000a800:	c1 d0       	breq	8000a83a <_malloc_r+0x3da>
8000a802:	58 f2       	cp.w	r2,15
8000a804:	e0 8b 00 05 	brhi	8000a80e <_malloc_r+0x3ae>
8000a808:	30 18       	mov	r8,1
8000a80a:	8d 18       	st.w	r6[0x4],r8
8000a80c:	c2 68       	rjmp	8000a858 <_malloc_r+0x3f8>
8000a80e:	30 59       	mov	r9,5
8000a810:	20 c2       	sub	r2,12
8000a812:	e0 12 ff f8 	andl	r2,0xfff8
8000a816:	e6 02 00 08 	add	r8,r3,r2
8000a81a:	91 29       	st.w	r8[0x8],r9
8000a81c:	91 19       	st.w	r8[0x4],r9
8000a81e:	66 18       	ld.w	r8,r3[0x4]
8000a820:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000a824:	e5 e8 10 08 	or	r8,r2,r8
8000a828:	87 18       	st.w	r3[0x4],r8
8000a82a:	58 f2       	cp.w	r2,15
8000a82c:	e0 88 00 07 	brls	8000a83a <_malloc_r+0x3da>
8000a830:	e6 cb ff f8 	sub	r11,r3,-8
8000a834:	0a 9c       	mov	r12,r5
8000a836:	e0 a0 1d 23 	rcall	8000e27c <_free_r>
8000a83a:	e0 69 13 20 	mov	r9,4896
8000a83e:	72 0a       	ld.w	r10,r9[0x0]
8000a840:	e0 68 13 28 	mov	r8,4904
8000a844:	70 08       	ld.w	r8,r8[0x0]
8000a846:	14 38       	cp.w	r8,r10
8000a848:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a84c:	e0 69 13 1c 	mov	r9,4892
8000a850:	72 0a       	ld.w	r10,r9[0x0]
8000a852:	14 38       	cp.w	r8,r10
8000a854:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000a858:	68 28       	ld.w	r8,r4[0x8]
8000a85a:	70 18       	ld.w	r8,r8[0x4]
8000a85c:	e0 18 ff fc 	andl	r8,0xfffc
8000a860:	0e 38       	cp.w	r8,r7
8000a862:	5f 39       	srlo	r9
8000a864:	0e 18       	sub	r8,r7
8000a866:	58 f8       	cp.w	r8,15
8000a868:	5f aa       	srle	r10
8000a86a:	f5 e9 10 09 	or	r9,r10,r9
8000a86e:	c0 50       	breq	8000a878 <_malloc_r+0x418>
8000a870:	0a 9c       	mov	r12,r5
8000a872:	fe b0 f3 49 	rcall	80008f04 <__malloc_unlock>
8000a876:	d8 3a       	popm	r0-r7,pc,r12=0
8000a878:	68 26       	ld.w	r6,r4[0x8]
8000a87a:	a1 a8       	sbr	r8,0x0
8000a87c:	0e 99       	mov	r9,r7
8000a87e:	a1 a9       	sbr	r9,0x0
8000a880:	8d 19       	st.w	r6[0x4],r9
8000a882:	ec 07 00 07 	add	r7,r6,r7
8000a886:	0a 9c       	mov	r12,r5
8000a888:	89 27       	st.w	r4[0x8],r7
8000a88a:	8f 18       	st.w	r7[0x4],r8
8000a88c:	fe b0 f3 3c 	rcall	80008f04 <__malloc_unlock>
8000a890:	ec cc ff f8 	sub	r12,r6,-8
8000a894:	d8 32       	popm	r0-r7,pc
8000a896:	d7 03       	nop

8000a898 <memcmp>:
8000a898:	d4 01       	pushm	lr
8000a89a:	30 08       	mov	r8,0
8000a89c:	c0 d8       	rjmp	8000a8b6 <memcmp+0x1e>
8000a89e:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000a8a2:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a8a6:	20 1a       	sub	r10,1
8000a8a8:	2f f8       	sub	r8,-1
8000a8aa:	f2 0e 18 00 	cp.b	lr,r9
8000a8ae:	c0 40       	breq	8000a8b6 <memcmp+0x1e>
8000a8b0:	fc 09 01 0c 	sub	r12,lr,r9
8000a8b4:	d8 02       	popm	pc
8000a8b6:	58 0a       	cp.w	r10,0
8000a8b8:	cf 31       	brne	8000a89e <memcmp+0x6>
8000a8ba:	14 9c       	mov	r12,r10
8000a8bc:	d8 02       	popm	pc

8000a8be <memcpy>:
8000a8be:	58 8a       	cp.w	r10,8
8000a8c0:	c2 f5       	brlt	8000a91e <memcpy+0x60>
8000a8c2:	f9 eb 10 09 	or	r9,r12,r11
8000a8c6:	e2 19 00 03 	andl	r9,0x3,COH
8000a8ca:	e0 81 00 97 	brne	8000a9f8 <memcpy+0x13a>
8000a8ce:	e0 4a 00 20 	cp.w	r10,32
8000a8d2:	c3 b4       	brge	8000a948 <memcpy+0x8a>
8000a8d4:	f4 08 14 02 	asr	r8,r10,0x2
8000a8d8:	f0 09 11 08 	rsub	r9,r8,8
8000a8dc:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000a8e0:	76 69       	ld.w	r9,r11[0x18]
8000a8e2:	99 69       	st.w	r12[0x18],r9
8000a8e4:	76 59       	ld.w	r9,r11[0x14]
8000a8e6:	99 59       	st.w	r12[0x14],r9
8000a8e8:	76 49       	ld.w	r9,r11[0x10]
8000a8ea:	99 49       	st.w	r12[0x10],r9
8000a8ec:	76 39       	ld.w	r9,r11[0xc]
8000a8ee:	99 39       	st.w	r12[0xc],r9
8000a8f0:	76 29       	ld.w	r9,r11[0x8]
8000a8f2:	99 29       	st.w	r12[0x8],r9
8000a8f4:	76 19       	ld.w	r9,r11[0x4]
8000a8f6:	99 19       	st.w	r12[0x4],r9
8000a8f8:	76 09       	ld.w	r9,r11[0x0]
8000a8fa:	99 09       	st.w	r12[0x0],r9
8000a8fc:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000a900:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000a904:	e0 1a 00 03 	andl	r10,0x3
8000a908:	f4 0a 11 04 	rsub	r10,r10,4
8000a90c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a910:	17 a9       	ld.ub	r9,r11[0x2]
8000a912:	b0 a9       	st.b	r8[0x2],r9
8000a914:	17 99       	ld.ub	r9,r11[0x1]
8000a916:	b0 99       	st.b	r8[0x1],r9
8000a918:	17 89       	ld.ub	r9,r11[0x0]
8000a91a:	b0 89       	st.b	r8[0x0],r9
8000a91c:	5e fc       	retal	r12
8000a91e:	f4 0a 11 09 	rsub	r10,r10,9
8000a922:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000a926:	17 f9       	ld.ub	r9,r11[0x7]
8000a928:	b8 f9       	st.b	r12[0x7],r9
8000a92a:	17 e9       	ld.ub	r9,r11[0x6]
8000a92c:	b8 e9       	st.b	r12[0x6],r9
8000a92e:	17 d9       	ld.ub	r9,r11[0x5]
8000a930:	b8 d9       	st.b	r12[0x5],r9
8000a932:	17 c9       	ld.ub	r9,r11[0x4]
8000a934:	b8 c9       	st.b	r12[0x4],r9
8000a936:	17 b9       	ld.ub	r9,r11[0x3]
8000a938:	b8 b9       	st.b	r12[0x3],r9
8000a93a:	17 a9       	ld.ub	r9,r11[0x2]
8000a93c:	b8 a9       	st.b	r12[0x2],r9
8000a93e:	17 99       	ld.ub	r9,r11[0x1]
8000a940:	b8 99       	st.b	r12[0x1],r9
8000a942:	17 89       	ld.ub	r9,r11[0x0]
8000a944:	b8 89       	st.b	r12[0x0],r9
8000a946:	5e fc       	retal	r12
8000a948:	eb cd 40 c0 	pushm	r6-r7,lr
8000a94c:	18 99       	mov	r9,r12
8000a94e:	22 0a       	sub	r10,32
8000a950:	b7 07       	ld.d	r6,r11++
8000a952:	b3 26       	st.d	r9++,r6
8000a954:	b7 07       	ld.d	r6,r11++
8000a956:	b3 26       	st.d	r9++,r6
8000a958:	b7 07       	ld.d	r6,r11++
8000a95a:	b3 26       	st.d	r9++,r6
8000a95c:	b7 07       	ld.d	r6,r11++
8000a95e:	b3 26       	st.d	r9++,r6
8000a960:	22 0a       	sub	r10,32
8000a962:	cf 74       	brge	8000a950 <memcpy+0x92>
8000a964:	2f 0a       	sub	r10,-16
8000a966:	c0 65       	brlt	8000a972 <memcpy+0xb4>
8000a968:	b7 07       	ld.d	r6,r11++
8000a96a:	b3 26       	st.d	r9++,r6
8000a96c:	b7 07       	ld.d	r6,r11++
8000a96e:	b3 26       	st.d	r9++,r6
8000a970:	21 0a       	sub	r10,16
8000a972:	5c 3a       	neg	r10
8000a974:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000a978:	d7 03       	nop
8000a97a:	d7 03       	nop
8000a97c:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000a980:	f3 66 00 0e 	st.b	r9[14],r6
8000a984:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000a988:	f3 66 00 0d 	st.b	r9[13],r6
8000a98c:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000a990:	f3 66 00 0c 	st.b	r9[12],r6
8000a994:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000a998:	f3 66 00 0b 	st.b	r9[11],r6
8000a99c:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000a9a0:	f3 66 00 0a 	st.b	r9[10],r6
8000a9a4:	f7 36 00 09 	ld.ub	r6,r11[9]
8000a9a8:	f3 66 00 09 	st.b	r9[9],r6
8000a9ac:	f7 36 00 08 	ld.ub	r6,r11[8]
8000a9b0:	f3 66 00 08 	st.b	r9[8],r6
8000a9b4:	f7 36 00 07 	ld.ub	r6,r11[7]
8000a9b8:	f3 66 00 07 	st.b	r9[7],r6
8000a9bc:	f7 36 00 06 	ld.ub	r6,r11[6]
8000a9c0:	f3 66 00 06 	st.b	r9[6],r6
8000a9c4:	f7 36 00 05 	ld.ub	r6,r11[5]
8000a9c8:	f3 66 00 05 	st.b	r9[5],r6
8000a9cc:	f7 36 00 04 	ld.ub	r6,r11[4]
8000a9d0:	f3 66 00 04 	st.b	r9[4],r6
8000a9d4:	f7 36 00 03 	ld.ub	r6,r11[3]
8000a9d8:	f3 66 00 03 	st.b	r9[3],r6
8000a9dc:	f7 36 00 02 	ld.ub	r6,r11[2]
8000a9e0:	f3 66 00 02 	st.b	r9[2],r6
8000a9e4:	f7 36 00 01 	ld.ub	r6,r11[1]
8000a9e8:	f3 66 00 01 	st.b	r9[1],r6
8000a9ec:	f7 36 00 00 	ld.ub	r6,r11[0]
8000a9f0:	f3 66 00 00 	st.b	r9[0],r6
8000a9f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a9f8:	20 1a       	sub	r10,1
8000a9fa:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000a9fe:	f8 0a 0b 09 	st.b	r12[r10],r9
8000aa02:	cf b1       	brne	8000a9f8 <memcpy+0x13a>
8000aa04:	5e fc       	retal	r12

8000aa06 <memset>:
8000aa06:	18 98       	mov	r8,r12
8000aa08:	c0 38       	rjmp	8000aa0e <memset+0x8>
8000aa0a:	10 cb       	st.b	r8++,r11
8000aa0c:	20 1a       	sub	r10,1
8000aa0e:	58 0a       	cp.w	r10,0
8000aa10:	cf d1       	brne	8000aa0a <memset+0x4>
8000aa12:	5e fc       	retal	r12

8000aa14 <_realloc_r>:
8000aa14:	d4 31       	pushm	r0-r7,lr
8000aa16:	20 1d       	sub	sp,4
8000aa18:	16 94       	mov	r4,r11
8000aa1a:	18 92       	mov	r2,r12
8000aa1c:	14 9b       	mov	r11,r10
8000aa1e:	58 04       	cp.w	r4,0
8000aa20:	c0 51       	brne	8000aa2a <_realloc_r+0x16>
8000aa22:	fe b0 fd 1f 	rcall	8000a460 <_malloc_r>
8000aa26:	18 95       	mov	r5,r12
8000aa28:	c5 39       	rjmp	8000acce <_realloc_r+0x2ba>
8000aa2a:	50 0a       	stdsp	sp[0x0],r10
8000aa2c:	fe b0 f2 66 	rcall	80008ef8 <__malloc_lock>
8000aa30:	40 0b       	lddsp	r11,sp[0x0]
8000aa32:	f6 c8 ff f5 	sub	r8,r11,-11
8000aa36:	e8 c1 00 08 	sub	r1,r4,8
8000aa3a:	10 96       	mov	r6,r8
8000aa3c:	62 1c       	ld.w	r12,r1[0x4]
8000aa3e:	e0 16 ff f8 	andl	r6,0xfff8
8000aa42:	59 68       	cp.w	r8,22
8000aa44:	f9 b6 08 10 	movls	r6,16
8000aa48:	16 36       	cp.w	r6,r11
8000aa4a:	5f 38       	srlo	r8
8000aa4c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000aa50:	c0 50       	breq	8000aa5a <_realloc_r+0x46>
8000aa52:	30 c8       	mov	r8,12
8000aa54:	30 05       	mov	r5,0
8000aa56:	85 38       	st.w	r2[0xc],r8
8000aa58:	c3 b9       	rjmp	8000acce <_realloc_r+0x2ba>
8000aa5a:	18 90       	mov	r0,r12
8000aa5c:	e0 10 ff fc 	andl	r0,0xfffc
8000aa60:	0c 30       	cp.w	r0,r6
8000aa62:	e0 84 01 0b 	brge	8000ac78 <_realloc_r+0x264>
8000aa66:	e0 68 05 38 	mov	r8,1336
8000aa6a:	e2 00 00 09 	add	r9,r1,r0
8000aa6e:	70 25       	ld.w	r5,r8[0x8]
8000aa70:	0a 39       	cp.w	r9,r5
8000aa72:	c0 90       	breq	8000aa84 <_realloc_r+0x70>
8000aa74:	72 1a       	ld.w	r10,r9[0x4]
8000aa76:	a1 ca       	cbr	r10,0x0
8000aa78:	f2 0a 00 0a 	add	r10,r9,r10
8000aa7c:	74 1a       	ld.w	r10,r10[0x4]
8000aa7e:	ed ba 00 00 	bld	r10,0x0
8000aa82:	c2 20       	breq	8000aac6 <_realloc_r+0xb2>
8000aa84:	72 1a       	ld.w	r10,r9[0x4]
8000aa86:	e0 1a ff fc 	andl	r10,0xfffc
8000aa8a:	f4 00 00 03 	add	r3,r10,r0
8000aa8e:	0a 39       	cp.w	r9,r5
8000aa90:	c1 31       	brne	8000aab6 <_realloc_r+0xa2>
8000aa92:	ec c7 ff f0 	sub	r7,r6,-16
8000aa96:	0e 33       	cp.w	r3,r7
8000aa98:	c1 95       	brlt	8000aaca <_realloc_r+0xb6>
8000aa9a:	e2 06 00 09 	add	r9,r1,r6
8000aa9e:	0c 13       	sub	r3,r6
8000aaa0:	a1 a3       	sbr	r3,0x0
8000aaa2:	93 13       	st.w	r9[0x4],r3
8000aaa4:	91 29       	st.w	r8[0x8],r9
8000aaa6:	04 9c       	mov	r12,r2
8000aaa8:	62 18       	ld.w	r8,r1[0x4]
8000aaaa:	08 95       	mov	r5,r4
8000aaac:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000aab0:	10 46       	or	r6,r8
8000aab2:	83 16       	st.w	r1[0x4],r6
8000aab4:	c0 b9       	rjmp	8000acca <_realloc_r+0x2b6>
8000aab6:	0c 33       	cp.w	r3,r6
8000aab8:	c0 95       	brlt	8000aaca <_realloc_r+0xb6>
8000aaba:	72 28       	ld.w	r8,r9[0x8]
8000aabc:	02 97       	mov	r7,r1
8000aabe:	72 39       	ld.w	r9,r9[0xc]
8000aac0:	93 28       	st.w	r9[0x8],r8
8000aac2:	91 39       	st.w	r8[0xc],r9
8000aac4:	cd c8       	rjmp	8000ac7c <_realloc_r+0x268>
8000aac6:	30 0a       	mov	r10,0
8000aac8:	14 99       	mov	r9,r10
8000aaca:	ed bc 00 00 	bld	r12,0x0
8000aace:	e0 80 00 95 	breq	8000abf8 <_realloc_r+0x1e4>
8000aad2:	62 07       	ld.w	r7,r1[0x0]
8000aad4:	e2 07 01 07 	sub	r7,r1,r7
8000aad8:	6e 1c       	ld.w	r12,r7[0x4]
8000aada:	e0 1c ff fc 	andl	r12,0xfffc
8000aade:	58 09       	cp.w	r9,0
8000aae0:	c5 60       	breq	8000ab8c <_realloc_r+0x178>
8000aae2:	f8 00 00 03 	add	r3,r12,r0
8000aae6:	0a 39       	cp.w	r9,r5
8000aae8:	c4 81       	brne	8000ab78 <_realloc_r+0x164>
8000aaea:	14 03       	add	r3,r10
8000aaec:	ec c9 ff f0 	sub	r9,r6,-16
8000aaf0:	12 33       	cp.w	r3,r9
8000aaf2:	c4 d5       	brlt	8000ab8c <_realloc_r+0x178>
8000aaf4:	6e 3a       	ld.w	r10,r7[0xc]
8000aaf6:	6e 29       	ld.w	r9,r7[0x8]
8000aaf8:	95 29       	st.w	r10[0x8],r9
8000aafa:	93 3a       	st.w	r9[0xc],r10
8000aafc:	ee c5 ff f8 	sub	r5,r7,-8
8000ab00:	e0 ca 00 04 	sub	r10,r0,4
8000ab04:	e0 4a 00 24 	cp.w	r10,36
8000ab08:	e0 8b 00 25 	brhi	8000ab52 <_realloc_r+0x13e>
8000ab0c:	0a 99       	mov	r9,r5
8000ab0e:	59 3a       	cp.w	r10,19
8000ab10:	e0 88 00 1a 	brls	8000ab44 <_realloc_r+0x130>
8000ab14:	09 09       	ld.w	r9,r4++
8000ab16:	8b 09       	st.w	r5[0x0],r9
8000ab18:	09 09       	ld.w	r9,r4++
8000ab1a:	8f 39       	st.w	r7[0xc],r9
8000ab1c:	ee c9 ff f0 	sub	r9,r7,-16
8000ab20:	59 ba       	cp.w	r10,27
8000ab22:	e0 88 00 11 	brls	8000ab44 <_realloc_r+0x130>
8000ab26:	09 0b       	ld.w	r11,r4++
8000ab28:	93 0b       	st.w	r9[0x0],r11
8000ab2a:	09 09       	ld.w	r9,r4++
8000ab2c:	8f 59       	st.w	r7[0x14],r9
8000ab2e:	ee c9 ff e8 	sub	r9,r7,-24
8000ab32:	e0 4a 00 24 	cp.w	r10,36
8000ab36:	c0 71       	brne	8000ab44 <_realloc_r+0x130>
8000ab38:	09 0a       	ld.w	r10,r4++
8000ab3a:	93 0a       	st.w	r9[0x0],r10
8000ab3c:	ee c9 ff e0 	sub	r9,r7,-32
8000ab40:	09 0a       	ld.w	r10,r4++
8000ab42:	8f 7a       	st.w	r7[0x1c],r10
8000ab44:	09 0a       	ld.w	r10,r4++
8000ab46:	12 aa       	st.w	r9++,r10
8000ab48:	68 0a       	ld.w	r10,r4[0x0]
8000ab4a:	93 0a       	st.w	r9[0x0],r10
8000ab4c:	68 1a       	ld.w	r10,r4[0x4]
8000ab4e:	93 1a       	st.w	r9[0x4],r10
8000ab50:	c0 78       	rjmp	8000ab5e <_realloc_r+0x14a>
8000ab52:	50 08       	stdsp	sp[0x0],r8
8000ab54:	08 9b       	mov	r11,r4
8000ab56:	0a 9c       	mov	r12,r5
8000ab58:	e0 a0 1e 35 	rcall	8000e7c2 <memmove>
8000ab5c:	40 08       	lddsp	r8,sp[0x0]
8000ab5e:	ee 06 00 09 	add	r9,r7,r6
8000ab62:	0c 13       	sub	r3,r6
8000ab64:	a1 a3       	sbr	r3,0x0
8000ab66:	93 13       	st.w	r9[0x4],r3
8000ab68:	91 29       	st.w	r8[0x8],r9
8000ab6a:	04 9c       	mov	r12,r2
8000ab6c:	6e 18       	ld.w	r8,r7[0x4]
8000ab6e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000ab72:	10 46       	or	r6,r8
8000ab74:	8f 16       	st.w	r7[0x4],r6
8000ab76:	ca a8       	rjmp	8000acca <_realloc_r+0x2b6>
8000ab78:	14 03       	add	r3,r10
8000ab7a:	0c 33       	cp.w	r3,r6
8000ab7c:	c0 85       	brlt	8000ab8c <_realloc_r+0x178>
8000ab7e:	72 28       	ld.w	r8,r9[0x8]
8000ab80:	72 39       	ld.w	r9,r9[0xc]
8000ab82:	93 28       	st.w	r9[0x8],r8
8000ab84:	91 39       	st.w	r8[0xc],r9
8000ab86:	6e 28       	ld.w	r8,r7[0x8]
8000ab88:	6e 39       	ld.w	r9,r7[0xc]
8000ab8a:	c0 78       	rjmp	8000ab98 <_realloc_r+0x184>
8000ab8c:	f8 00 00 03 	add	r3,r12,r0
8000ab90:	0c 33       	cp.w	r3,r6
8000ab92:	c3 35       	brlt	8000abf8 <_realloc_r+0x1e4>
8000ab94:	6e 39       	ld.w	r9,r7[0xc]
8000ab96:	6e 28       	ld.w	r8,r7[0x8]
8000ab98:	93 28       	st.w	r9[0x8],r8
8000ab9a:	91 39       	st.w	r8[0xc],r9
8000ab9c:	e0 ca 00 04 	sub	r10,r0,4
8000aba0:	ee cc ff f8 	sub	r12,r7,-8
8000aba4:	e0 4a 00 24 	cp.w	r10,36
8000aba8:	e0 8b 00 24 	brhi	8000abf0 <_realloc_r+0x1dc>
8000abac:	59 3a       	cp.w	r10,19
8000abae:	e0 88 00 1a 	brls	8000abe2 <_realloc_r+0x1ce>
8000abb2:	09 08       	ld.w	r8,r4++
8000abb4:	99 08       	st.w	r12[0x0],r8
8000abb6:	09 08       	ld.w	r8,r4++
8000abb8:	8f 38       	st.w	r7[0xc],r8
8000abba:	ee cc ff f0 	sub	r12,r7,-16
8000abbe:	59 ba       	cp.w	r10,27
8000abc0:	e0 88 00 11 	brls	8000abe2 <_realloc_r+0x1ce>
8000abc4:	09 08       	ld.w	r8,r4++
8000abc6:	99 08       	st.w	r12[0x0],r8
8000abc8:	09 08       	ld.w	r8,r4++
8000abca:	8f 58       	st.w	r7[0x14],r8
8000abcc:	ee cc ff e8 	sub	r12,r7,-24
8000abd0:	e0 4a 00 24 	cp.w	r10,36
8000abd4:	c0 71       	brne	8000abe2 <_realloc_r+0x1ce>
8000abd6:	09 08       	ld.w	r8,r4++
8000abd8:	99 08       	st.w	r12[0x0],r8
8000abda:	ee cc ff e0 	sub	r12,r7,-32
8000abde:	09 08       	ld.w	r8,r4++
8000abe0:	8f 78       	st.w	r7[0x1c],r8
8000abe2:	09 08       	ld.w	r8,r4++
8000abe4:	18 a8       	st.w	r12++,r8
8000abe6:	68 08       	ld.w	r8,r4[0x0]
8000abe8:	99 08       	st.w	r12[0x0],r8
8000abea:	68 18       	ld.w	r8,r4[0x4]
8000abec:	99 18       	st.w	r12[0x4],r8
8000abee:	c4 78       	rjmp	8000ac7c <_realloc_r+0x268>
8000abf0:	08 9b       	mov	r11,r4
8000abf2:	e0 a0 1d e8 	rcall	8000e7c2 <memmove>
8000abf6:	c4 38       	rjmp	8000ac7c <_realloc_r+0x268>
8000abf8:	04 9c       	mov	r12,r2
8000abfa:	fe b0 fc 33 	rcall	8000a460 <_malloc_r>
8000abfe:	18 95       	mov	r5,r12
8000ac00:	c3 a0       	breq	8000ac74 <_realloc_r+0x260>
8000ac02:	62 18       	ld.w	r8,r1[0x4]
8000ac04:	f8 c9 00 08 	sub	r9,r12,8
8000ac08:	a1 c8       	cbr	r8,0x0
8000ac0a:	e2 08 00 08 	add	r8,r1,r8
8000ac0e:	10 39       	cp.w	r9,r8
8000ac10:	c0 71       	brne	8000ac1e <_realloc_r+0x20a>
8000ac12:	72 13       	ld.w	r3,r9[0x4]
8000ac14:	02 97       	mov	r7,r1
8000ac16:	e0 13 ff fc 	andl	r3,0xfffc
8000ac1a:	00 03       	add	r3,r0
8000ac1c:	c3 08       	rjmp	8000ac7c <_realloc_r+0x268>
8000ac1e:	e0 ca 00 04 	sub	r10,r0,4
8000ac22:	e0 4a 00 24 	cp.w	r10,36
8000ac26:	e0 8b 00 20 	brhi	8000ac66 <_realloc_r+0x252>
8000ac2a:	08 99       	mov	r9,r4
8000ac2c:	18 98       	mov	r8,r12
8000ac2e:	59 3a       	cp.w	r10,19
8000ac30:	e0 88 00 14 	brls	8000ac58 <_realloc_r+0x244>
8000ac34:	13 0b       	ld.w	r11,r9++
8000ac36:	10 ab       	st.w	r8++,r11
8000ac38:	13 0b       	ld.w	r11,r9++
8000ac3a:	10 ab       	st.w	r8++,r11
8000ac3c:	59 ba       	cp.w	r10,27
8000ac3e:	e0 88 00 0d 	brls	8000ac58 <_realloc_r+0x244>
8000ac42:	13 0b       	ld.w	r11,r9++
8000ac44:	10 ab       	st.w	r8++,r11
8000ac46:	13 0b       	ld.w	r11,r9++
8000ac48:	10 ab       	st.w	r8++,r11
8000ac4a:	e0 4a 00 24 	cp.w	r10,36
8000ac4e:	c0 51       	brne	8000ac58 <_realloc_r+0x244>
8000ac50:	13 0a       	ld.w	r10,r9++
8000ac52:	10 aa       	st.w	r8++,r10
8000ac54:	13 0a       	ld.w	r10,r9++
8000ac56:	10 aa       	st.w	r8++,r10
8000ac58:	13 0a       	ld.w	r10,r9++
8000ac5a:	10 aa       	st.w	r8++,r10
8000ac5c:	72 0a       	ld.w	r10,r9[0x0]
8000ac5e:	91 0a       	st.w	r8[0x0],r10
8000ac60:	72 19       	ld.w	r9,r9[0x4]
8000ac62:	91 19       	st.w	r8[0x4],r9
8000ac64:	c0 48       	rjmp	8000ac6c <_realloc_r+0x258>
8000ac66:	08 9b       	mov	r11,r4
8000ac68:	e0 a0 1d ad 	rcall	8000e7c2 <memmove>
8000ac6c:	08 9b       	mov	r11,r4
8000ac6e:	04 9c       	mov	r12,r2
8000ac70:	e0 a0 1b 06 	rcall	8000e27c <_free_r>
8000ac74:	04 9c       	mov	r12,r2
8000ac76:	c2 a8       	rjmp	8000acca <_realloc_r+0x2b6>
8000ac78:	00 93       	mov	r3,r0
8000ac7a:	02 97       	mov	r7,r1
8000ac7c:	e6 06 01 09 	sub	r9,r3,r6
8000ac80:	6e 18       	ld.w	r8,r7[0x4]
8000ac82:	58 f9       	cp.w	r9,15
8000ac84:	e0 88 00 16 	brls	8000acb0 <_realloc_r+0x29c>
8000ac88:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000ac8c:	ed e8 10 08 	or	r8,r6,r8
8000ac90:	8f 18       	st.w	r7[0x4],r8
8000ac92:	12 98       	mov	r8,r9
8000ac94:	a1 a8       	sbr	r8,0x0
8000ac96:	ee 06 00 0b 	add	r11,r7,r6
8000ac9a:	f6 09 00 09 	add	r9,r11,r9
8000ac9e:	97 18       	st.w	r11[0x4],r8
8000aca0:	72 18       	ld.w	r8,r9[0x4]
8000aca2:	a1 a8       	sbr	r8,0x0
8000aca4:	2f 8b       	sub	r11,-8
8000aca6:	93 18       	st.w	r9[0x4],r8
8000aca8:	04 9c       	mov	r12,r2
8000acaa:	e0 a0 1a e9 	rcall	8000e27c <_free_r>
8000acae:	c0 b8       	rjmp	8000acc4 <_realloc_r+0x2b0>
8000acb0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000acb4:	e7 e8 10 08 	or	r8,r3,r8
8000acb8:	8f 18       	st.w	r7[0x4],r8
8000acba:	ee 03 00 03 	add	r3,r7,r3
8000acbe:	66 18       	ld.w	r8,r3[0x4]
8000acc0:	a1 a8       	sbr	r8,0x0
8000acc2:	87 18       	st.w	r3[0x4],r8
8000acc4:	04 9c       	mov	r12,r2
8000acc6:	ee c5 ff f8 	sub	r5,r7,-8
8000acca:	fe b0 f1 1d 	rcall	80008f04 <__malloc_unlock>
8000acce:	0a 9c       	mov	r12,r5
8000acd0:	2f fd       	sub	sp,-4
8000acd2:	d8 32       	popm	r0-r7,pc

8000acd4 <_sbrk_r>:
8000acd4:	d4 21       	pushm	r4-r7,lr
8000acd6:	30 08       	mov	r8,0
8000acd8:	18 97       	mov	r7,r12
8000acda:	e0 66 46 b0 	mov	r6,18096
8000acde:	16 9c       	mov	r12,r11
8000ace0:	8d 08       	st.w	r6[0x0],r8
8000ace2:	c1 1d       	rcall	8000af04 <_sbrk>
8000ace4:	5b fc       	cp.w	r12,-1
8000ace6:	c0 51       	brne	8000acf0 <_sbrk_r+0x1c>
8000ace8:	6c 08       	ld.w	r8,r6[0x0]
8000acea:	58 08       	cp.w	r8,0
8000acec:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000acf0:	d8 22       	popm	r4-r7,pc
8000acf2:	d7 03       	nop

8000acf4 <sprintf>:
8000acf4:	d4 01       	pushm	lr
8000acf6:	21 7d       	sub	sp,92
8000acf8:	e0 68 ff ff 	mov	r8,65535
8000acfc:	ea 18 7f ff 	orh	r8,0x7fff
8000ad00:	50 58       	stdsp	sp[0x14],r8
8000ad02:	50 28       	stdsp	sp[0x8],r8
8000ad04:	e0 68 02 08 	mov	r8,520
8000ad08:	ba 68       	st.h	sp[0xc],r8
8000ad0a:	3f f8       	mov	r8,-1
8000ad0c:	ba 78       	st.h	sp[0xe],r8
8000ad0e:	e0 68 0a 38 	mov	r8,2616
8000ad12:	50 4c       	stdsp	sp[0x10],r12
8000ad14:	16 9a       	mov	r10,r11
8000ad16:	50 0c       	stdsp	sp[0x0],r12
8000ad18:	fa c9 ff a0 	sub	r9,sp,-96
8000ad1c:	70 0c       	ld.w	r12,r8[0x0]
8000ad1e:	1a 9b       	mov	r11,sp
8000ad20:	e0 a0 02 ac 	rcall	8000b278 <_vfprintf_r>
8000ad24:	30 09       	mov	r9,0
8000ad26:	40 08       	lddsp	r8,sp[0x0]
8000ad28:	b0 89       	st.b	r8[0x0],r9
8000ad2a:	2e 9d       	sub	sp,-92
8000ad2c:	d8 02       	popm	pc
8000ad2e:	d7 03       	nop

8000ad30 <strcpy>:
8000ad30:	30 08       	mov	r8,0
8000ad32:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ad36:	f8 08 0b 09 	st.b	r12[r8],r9
8000ad3a:	2f f8       	sub	r8,-1
8000ad3c:	58 09       	cp.w	r9,0
8000ad3e:	cf a1       	brne	8000ad32 <strcpy+0x2>
8000ad40:	5e fc       	retal	r12

8000ad42 <strlen>:
8000ad42:	30 09       	mov	r9,0
8000ad44:	18 98       	mov	r8,r12
8000ad46:	c0 28       	rjmp	8000ad4a <strlen+0x8>
8000ad48:	2f f8       	sub	r8,-1
8000ad4a:	11 8a       	ld.ub	r10,r8[0x0]
8000ad4c:	f2 0a 18 00 	cp.b	r10,r9
8000ad50:	cf c1       	brne	8000ad48 <strlen+0x6>
8000ad52:	f0 0c 01 0c 	sub	r12,r8,r12
8000ad56:	5e fc       	retal	r12

8000ad58 <strncpy>:
8000ad58:	30 08       	mov	r8,0
8000ad5a:	10 3a       	cp.w	r10,r8
8000ad5c:	5e 0c       	reteq	r12
8000ad5e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ad62:	f8 08 0b 09 	st.b	r12[r8],r9
8000ad66:	2f f8       	sub	r8,-1
8000ad68:	58 09       	cp.w	r9,0
8000ad6a:	cf 81       	brne	8000ad5a <strncpy+0x2>
8000ad6c:	10 3a       	cp.w	r10,r8
8000ad6e:	5e 0c       	reteq	r12
8000ad70:	f8 08 0b 09 	st.b	r12[r8],r9
8000ad74:	2f f8       	sub	r8,-1
8000ad76:	cf bb       	rjmp	8000ad6c <strncpy+0x14>

8000ad78 <strtok>:
8000ad78:	d4 21       	pushm	r4-r7,lr
8000ad7a:	20 1d       	sub	sp,4
8000ad7c:	e0 65 0a 38 	mov	r5,2616
8000ad80:	18 97       	mov	r7,r12
8000ad82:	6a 04       	ld.w	r4,r5[0x0]
8000ad84:	e8 f6 00 e8 	ld.w	r6,r4[232]
8000ad88:	58 06       	cp.w	r6,0
8000ad8a:	c3 51       	brne	8000adf4 <strtok+0x7c>
8000ad8c:	50 0b       	stdsp	sp[0x0],r11
8000ad8e:	35 0c       	mov	r12,80
8000ad90:	fe b0 fb 60 	rcall	8000a450 <malloc>
8000ad94:	6a 08       	ld.w	r8,r5[0x0]
8000ad96:	e9 4c 00 e8 	st.w	r4[232],r12
8000ad9a:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ad9e:	93 26       	st.w	r9[0x8],r6
8000ada0:	93 06       	st.w	r9[0x0],r6
8000ada2:	93 16       	st.w	r9[0x4],r6
8000ada4:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ada8:	93 46       	st.w	r9[0x10],r6
8000adaa:	93 36       	st.w	r9[0xc],r6
8000adac:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000adb0:	93 66       	st.w	r9[0x18],r6
8000adb2:	93 56       	st.w	r9[0x14],r6
8000adb4:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000adb8:	93 b6       	st.w	r9[0x2c],r6
8000adba:	93 a6       	st.w	r9[0x28],r6
8000adbc:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000adc0:	93 d6       	st.w	r9[0x34],r6
8000adc2:	93 c6       	st.w	r9[0x30],r6
8000adc4:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000adc8:	93 f6       	st.w	r9[0x3c],r6
8000adca:	93 e6       	st.w	r9[0x38],r6
8000adcc:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000add0:	f3 46 00 44 	st.w	r9[68],r6
8000add4:	f3 46 00 40 	st.w	r9[64],r6
8000add8:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000addc:	f3 46 00 4c 	st.w	r9[76],r6
8000ade0:	f3 46 00 48 	st.w	r9[72],r6
8000ade4:	f0 f9 00 e8 	ld.w	r9,r8[232]
8000ade8:	f3 66 00 1c 	st.b	r9[28],r6
8000adec:	f0 f8 00 e8 	ld.w	r8,r8[232]
8000adf0:	40 0b       	lddsp	r11,sp[0x0]
8000adf2:	91 96       	st.w	r8[0x24],r6
8000adf4:	e0 68 0a 38 	mov	r8,2616
8000adf8:	70 08       	ld.w	r8,r8[0x0]
8000adfa:	0e 9c       	mov	r12,r7
8000adfc:	f0 fa 00 e8 	ld.w	r10,r8[232]
8000ae00:	30 19       	mov	r9,1
8000ae02:	c0 3c       	rcall	8000ae08 <__strtok_r>
8000ae04:	2f fd       	sub	sp,-4
8000ae06:	d8 22       	popm	r4-r7,pc

8000ae08 <__strtok_r>:
8000ae08:	d4 21       	pushm	r4-r7,lr
8000ae0a:	58 0c       	cp.w	r12,0
8000ae0c:	c0 41       	brne	8000ae14 <__strtok_r+0xc>
8000ae0e:	74 0c       	ld.w	r12,r10[0x0]
8000ae10:	58 0c       	cp.w	r12,0
8000ae12:	c2 90       	breq	8000ae64 <__strtok_r+0x5c>
8000ae14:	18 98       	mov	r8,r12
8000ae16:	16 97       	mov	r7,r11
8000ae18:	11 3e       	ld.ub	lr,r8++
8000ae1a:	c0 a8       	rjmp	8000ae2e <__strtok_r+0x26>
8000ae1c:	0c 3e       	cp.w	lr,r6
8000ae1e:	c0 81       	brne	8000ae2e <__strtok_r+0x26>
8000ae20:	58 09       	cp.w	r9,0
8000ae22:	c0 30       	breq	8000ae28 <__strtok_r+0x20>
8000ae24:	10 9c       	mov	r12,r8
8000ae26:	cf 7b       	rjmp	8000ae14 <__strtok_r+0xc>
8000ae28:	95 08       	st.w	r10[0x0],r8
8000ae2a:	b8 89       	st.b	r12[0x0],r9
8000ae2c:	d8 22       	popm	r4-r7,pc
8000ae2e:	0f 36       	ld.ub	r6,r7++
8000ae30:	58 06       	cp.w	r6,0
8000ae32:	cf 51       	brne	8000ae1c <__strtok_r+0x14>
8000ae34:	58 0e       	cp.w	lr,0
8000ae36:	c0 51       	brne	8000ae40 <__strtok_r+0x38>
8000ae38:	95 0e       	st.w	r10[0x0],lr
8000ae3a:	1c 9c       	mov	r12,lr
8000ae3c:	d8 22       	popm	r4-r7,pc
8000ae3e:	12 98       	mov	r8,r9
8000ae40:	10 99       	mov	r9,r8
8000ae42:	16 97       	mov	r7,r11
8000ae44:	13 3e       	ld.ub	lr,r9++
8000ae46:	0f 36       	ld.ub	r6,r7++
8000ae48:	1c 36       	cp.w	r6,lr
8000ae4a:	c0 a1       	brne	8000ae5e <__strtok_r+0x56>
8000ae4c:	58 0e       	cp.w	lr,0
8000ae4e:	fc 09 17 00 	moveq	r9,lr
8000ae52:	f9 bb 01 00 	movne	r11,0
8000ae56:	f1 fb 1e 00 	st.bne	r8[0x0],r11
8000ae5a:	95 09       	st.w	r10[0x0],r9
8000ae5c:	d8 22       	popm	r4-r7,pc
8000ae5e:	58 06       	cp.w	r6,0
8000ae60:	cf 31       	brne	8000ae46 <__strtok_r+0x3e>
8000ae62:	ce eb       	rjmp	8000ae3e <__strtok_r+0x36>
8000ae64:	d8 22       	popm	r4-r7,pc
8000ae66:	d7 03       	nop

8000ae68 <_close>:
8000ae68:	30 28       	mov	r8,2
8000ae6a:	d6 73       	breakpoint
8000ae6c:	3f fc       	mov	r12,-1
8000ae6e:	35 8b       	mov	r11,88
8000ae70:	58 0c       	cp.w	r12,0
8000ae72:	5e 4c       	retge	r12
8000ae74:	e0 6a 46 b0 	mov	r10,18096
8000ae78:	95 0b       	st.w	r10[0x0],r11
8000ae7a:	5e fc       	retal	r12

8000ae7c <_lseek>:
8000ae7c:	30 58       	mov	r8,5
8000ae7e:	d6 73       	breakpoint
8000ae80:	3f fc       	mov	r12,-1
8000ae82:	35 8b       	mov	r11,88
8000ae84:	58 0c       	cp.w	r12,0
8000ae86:	5e 4c       	retge	r12
8000ae88:	e0 6a 46 b0 	mov	r10,18096
8000ae8c:	95 0b       	st.w	r10[0x0],r11
8000ae8e:	5e fc       	retal	r12

8000ae90 <isatty>:
8000ae90:	30 b8       	mov	r8,11
8000ae92:	d6 73       	breakpoint
8000ae94:	3f fc       	mov	r12,-1
8000ae96:	35 8b       	mov	r11,88
8000ae98:	58 0c       	cp.w	r12,0
8000ae9a:	5e 4c       	retge	r12
8000ae9c:	e0 6a 46 b0 	mov	r10,18096
8000aea0:	95 0b       	st.w	r10[0x0],r11
8000aea2:	5e fc       	retal	r12

8000aea4 <_fstat_host>:
8000aea4:	30 98       	mov	r8,9
8000aea6:	d6 73       	breakpoint
8000aea8:	3f fc       	mov	r12,-1
8000aeaa:	35 8b       	mov	r11,88
8000aeac:	58 0c       	cp.w	r12,0
8000aeae:	5e 4c       	retge	r12
8000aeb0:	e0 6a 46 b0 	mov	r10,18096
8000aeb4:	95 0b       	st.w	r10[0x0],r11
8000aeb6:	5e fc       	retal	r12

8000aeb8 <_fstat>:
8000aeb8:	d4 21       	pushm	r4-r7,lr
8000aeba:	21 0d       	sub	sp,64
8000aebc:	16 97       	mov	r7,r11
8000aebe:	1a 9b       	mov	r11,sp
8000aec0:	cf 2f       	rcall	8000aea4 <_fstat_host>
8000aec2:	c0 34       	brge	8000aec8 <_fstat+0x10>
8000aec4:	3f fc       	mov	r12,-1
8000aec6:	c1 c8       	rjmp	8000aefe <_fstat+0x46>
8000aec8:	40 08       	lddsp	r8,sp[0x0]
8000aeca:	ae 08       	st.h	r7[0x0],r8
8000aecc:	40 18       	lddsp	r8,sp[0x4]
8000aece:	ae 18       	st.h	r7[0x2],r8
8000aed0:	40 28       	lddsp	r8,sp[0x8]
8000aed2:	8f 18       	st.w	r7[0x4],r8
8000aed4:	40 38       	lddsp	r8,sp[0xc]
8000aed6:	ae 48       	st.h	r7[0x8],r8
8000aed8:	40 48       	lddsp	r8,sp[0x10]
8000aeda:	ae 58       	st.h	r7[0xa],r8
8000aedc:	40 58       	lddsp	r8,sp[0x14]
8000aede:	ae 68       	st.h	r7[0xc],r8
8000aee0:	40 68       	lddsp	r8,sp[0x18]
8000aee2:	ae 78       	st.h	r7[0xe],r8
8000aee4:	40 88       	lddsp	r8,sp[0x20]
8000aee6:	8f 48       	st.w	r7[0x10],r8
8000aee8:	40 a8       	lddsp	r8,sp[0x28]
8000aeea:	8f b8       	st.w	r7[0x2c],r8
8000aeec:	40 c8       	lddsp	r8,sp[0x30]
8000aeee:	8f c8       	st.w	r7[0x30],r8
8000aef0:	40 d8       	lddsp	r8,sp[0x34]
8000aef2:	8f 58       	st.w	r7[0x14],r8
8000aef4:	40 e8       	lddsp	r8,sp[0x38]
8000aef6:	30 0c       	mov	r12,0
8000aef8:	8f 78       	st.w	r7[0x1c],r8
8000aefa:	40 f8       	lddsp	r8,sp[0x3c]
8000aefc:	8f 98       	st.w	r7[0x24],r8
8000aefe:	2f 0d       	sub	sp,-64
8000af00:	d8 22       	popm	r4-r7,pc
8000af02:	d7 03       	nop

8000af04 <_sbrk>:
8000af04:	d4 01       	pushm	lr
8000af06:	e0 68 13 50 	mov	r8,4944
8000af0a:	70 09       	ld.w	r9,r8[0x0]
8000af0c:	58 09       	cp.w	r9,0
8000af0e:	c0 41       	brne	8000af16 <_sbrk+0x12>
8000af10:	e0 69 46 b8 	mov	r9,18104
8000af14:	91 09       	st.w	r8[0x0],r9
8000af16:	e0 69 13 50 	mov	r9,4944
8000af1a:	e0 7a 70 00 	mov	r10,94208
8000af1e:	72 08       	ld.w	r8,r9[0x0]
8000af20:	f0 0c 00 0c 	add	r12,r8,r12
8000af24:	14 3c       	cp.w	r12,r10
8000af26:	e0 8b 00 04 	brhi	8000af2e <_sbrk+0x2a>
8000af2a:	93 0c       	st.w	r9[0x0],r12
8000af2c:	c0 68       	rjmp	8000af38 <_sbrk+0x34>
8000af2e:	e0 a0 18 2b 	rcall	8000df84 <__errno>
8000af32:	30 c8       	mov	r8,12
8000af34:	99 08       	st.w	r12[0x0],r8
8000af36:	3f f8       	mov	r8,-1
8000af38:	10 9c       	mov	r12,r8
8000af3a:	d8 02       	popm	pc

8000af3c <get_arg>:
8000af3c:	d4 31       	pushm	r0-r7,lr
8000af3e:	20 8d       	sub	sp,32
8000af40:	fa c4 ff bc 	sub	r4,sp,-68
8000af44:	50 4b       	stdsp	sp[0x10],r11
8000af46:	68 2e       	ld.w	lr,r4[0x8]
8000af48:	50 58       	stdsp	sp[0x14],r8
8000af4a:	12 96       	mov	r6,r9
8000af4c:	7c 0b       	ld.w	r11,lr[0x0]
8000af4e:	70 05       	ld.w	r5,r8[0x0]
8000af50:	50 6e       	stdsp	sp[0x18],lr
8000af52:	58 0b       	cp.w	r11,0
8000af54:	f4 0b 17 00 	moveq	r11,r10
8000af58:	68 03       	ld.w	r3,r4[0x0]
8000af5a:	68 11       	ld.w	r1,r4[0x4]
8000af5c:	40 49       	lddsp	r9,sp[0x10]
8000af5e:	30 08       	mov	r8,0
8000af60:	c2 e9       	rjmp	8000b1bc <get_arg+0x280>
8000af62:	2f fb       	sub	r11,-1
8000af64:	32 5c       	mov	r12,37
8000af66:	17 8a       	ld.ub	r10,r11[0x0]
8000af68:	f8 0a 18 00 	cp.b	r10,r12
8000af6c:	5f 1e       	srne	lr
8000af6e:	f0 0a 18 00 	cp.b	r10,r8
8000af72:	5f 1c       	srne	r12
8000af74:	fd ec 00 0c 	and	r12,lr,r12
8000af78:	f0 0c 18 00 	cp.b	r12,r8
8000af7c:	cf 31       	brne	8000af62 <get_arg+0x26>
8000af7e:	58 0a       	cp.w	r10,0
8000af80:	e0 80 01 2b 	breq	8000b1d6 <get_arg+0x29a>
8000af84:	30 0c       	mov	r12,0
8000af86:	3f fa       	mov	r10,-1
8000af88:	18 90       	mov	r0,r12
8000af8a:	50 3a       	stdsp	sp[0xc],r10
8000af8c:	18 94       	mov	r4,r12
8000af8e:	18 92       	mov	r2,r12
8000af90:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000af94:	16 97       	mov	r7,r11
8000af96:	50 7c       	stdsp	sp[0x1c],r12
8000af98:	4c ec       	lddpc	r12,8000b0d0 <get_arg+0x194>
8000af9a:	0f 3a       	ld.ub	r10,r7++
8000af9c:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000afa0:	40 7c       	lddsp	r12,sp[0x1c]
8000afa2:	1c 0c       	add	r12,lr
8000afa4:	4c ce       	lddpc	lr,8000b0d4 <get_arg+0x198>
8000afa6:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000afaa:	20 1e       	sub	lr,1
8000afac:	50 0e       	stdsp	sp[0x0],lr
8000afae:	4c be       	lddpc	lr,8000b0d8 <get_arg+0x19c>
8000afb0:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000afb4:	50 7c       	stdsp	sp[0x1c],r12
8000afb6:	40 0c       	lddsp	r12,sp[0x0]
8000afb8:	58 7c       	cp.w	r12,7
8000afba:	e0 8b 00 fa 	brhi	8000b1ae <get_arg+0x272>
8000afbe:	4c 8e       	lddpc	lr,8000b0dc <get_arg+0x1a0>
8000afc0:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000afc4:	36 8b       	mov	r11,104
8000afc6:	f6 0a 18 00 	cp.b	r10,r11
8000afca:	e0 80 00 f2 	breq	8000b1ae <get_arg+0x272>
8000afce:	37 1b       	mov	r11,113
8000afd0:	f6 0a 18 00 	cp.b	r10,r11
8000afd4:	c0 70       	breq	8000afe2 <get_arg+0xa6>
8000afd6:	34 cb       	mov	r11,76
8000afd8:	f6 0a 18 00 	cp.b	r10,r11
8000afdc:	c0 51       	brne	8000afe6 <get_arg+0xaa>
8000afde:	a3 b4       	sbr	r4,0x3
8000afe0:	ce 78       	rjmp	8000b1ae <get_arg+0x272>
8000afe2:	a5 b4       	sbr	r4,0x5
8000afe4:	ce 58       	rjmp	8000b1ae <get_arg+0x272>
8000afe6:	08 9a       	mov	r10,r4
8000afe8:	0e 9b       	mov	r11,r7
8000afea:	a5 aa       	sbr	r10,0x4
8000afec:	17 3c       	ld.ub	r12,r11++
8000afee:	a5 b4       	sbr	r4,0x5
8000aff0:	36 ce       	mov	lr,108
8000aff2:	fc 0c 18 00 	cp.b	r12,lr
8000aff6:	e0 80 00 dd 	breq	8000b1b0 <get_arg+0x274>
8000affa:	14 94       	mov	r4,r10
8000affc:	cd 98       	rjmp	8000b1ae <get_arg+0x272>
8000affe:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000b002:	36 7c       	mov	r12,103
8000b004:	f8 0a 18 00 	cp.b	r10,r12
8000b008:	e0 8b 00 27 	brhi	8000b056 <get_arg+0x11a>
8000b00c:	36 5b       	mov	r11,101
8000b00e:	f6 0a 18 00 	cp.b	r10,r11
8000b012:	c4 82       	brcc	8000b0a2 <get_arg+0x166>
8000b014:	34 fb       	mov	r11,79
8000b016:	f6 0a 18 00 	cp.b	r10,r11
8000b01a:	c4 80       	breq	8000b0aa <get_arg+0x16e>
8000b01c:	e0 8b 00 0c 	brhi	8000b034 <get_arg+0xf8>
8000b020:	34 5b       	mov	r11,69
8000b022:	f6 0a 18 00 	cp.b	r10,r11
8000b026:	c3 e0       	breq	8000b0a2 <get_arg+0x166>
8000b028:	34 7b       	mov	r11,71
8000b02a:	f6 0a 18 00 	cp.b	r10,r11
8000b02e:	c3 a0       	breq	8000b0a2 <get_arg+0x166>
8000b030:	34 4b       	mov	r11,68
8000b032:	c0 88       	rjmp	8000b042 <get_arg+0x106>
8000b034:	35 8b       	mov	r11,88
8000b036:	f6 0a 18 00 	cp.b	r10,r11
8000b03a:	c2 c0       	breq	8000b092 <get_arg+0x156>
8000b03c:	e0 8b 00 07 	brhi	8000b04a <get_arg+0x10e>
8000b040:	35 5b       	mov	r11,85
8000b042:	f6 0a 18 00 	cp.b	r10,r11
8000b046:	c3 51       	brne	8000b0b0 <get_arg+0x174>
8000b048:	c3 18       	rjmp	8000b0aa <get_arg+0x16e>
8000b04a:	36 3b       	mov	r11,99
8000b04c:	f6 0a 18 00 	cp.b	r10,r11
8000b050:	c2 f0       	breq	8000b0ae <get_arg+0x172>
8000b052:	36 4b       	mov	r11,100
8000b054:	c0 e8       	rjmp	8000b070 <get_arg+0x134>
8000b056:	37 0b       	mov	r11,112
8000b058:	f6 0a 18 00 	cp.b	r10,r11
8000b05c:	c2 50       	breq	8000b0a6 <get_arg+0x16a>
8000b05e:	e0 8b 00 0d 	brhi	8000b078 <get_arg+0x13c>
8000b062:	36 eb       	mov	r11,110
8000b064:	f6 0a 18 00 	cp.b	r10,r11
8000b068:	c1 f0       	breq	8000b0a6 <get_arg+0x16a>
8000b06a:	e0 8b 00 14 	brhi	8000b092 <get_arg+0x156>
8000b06e:	36 9b       	mov	r11,105
8000b070:	f6 0a 18 00 	cp.b	r10,r11
8000b074:	c1 e1       	brne	8000b0b0 <get_arg+0x174>
8000b076:	c0 e8       	rjmp	8000b092 <get_arg+0x156>
8000b078:	37 5b       	mov	r11,117
8000b07a:	f6 0a 18 00 	cp.b	r10,r11
8000b07e:	c0 a0       	breq	8000b092 <get_arg+0x156>
8000b080:	37 8b       	mov	r11,120
8000b082:	f6 0a 18 00 	cp.b	r10,r11
8000b086:	c0 60       	breq	8000b092 <get_arg+0x156>
8000b088:	37 3b       	mov	r11,115
8000b08a:	f6 0a 18 00 	cp.b	r10,r11
8000b08e:	c1 11       	brne	8000b0b0 <get_arg+0x174>
8000b090:	c0 b8       	rjmp	8000b0a6 <get_arg+0x16a>
8000b092:	ed b4 00 04 	bld	r4,0x4
8000b096:	c0 a0       	breq	8000b0aa <get_arg+0x16e>
8000b098:	ed b4 00 05 	bld	r4,0x5
8000b09c:	c0 91       	brne	8000b0ae <get_arg+0x172>
8000b09e:	30 20       	mov	r0,2
8000b0a0:	c0 88       	rjmp	8000b0b0 <get_arg+0x174>
8000b0a2:	30 40       	mov	r0,4
8000b0a4:	c0 68       	rjmp	8000b0b0 <get_arg+0x174>
8000b0a6:	30 30       	mov	r0,3
8000b0a8:	c0 48       	rjmp	8000b0b0 <get_arg+0x174>
8000b0aa:	30 10       	mov	r0,1
8000b0ac:	c0 28       	rjmp	8000b0b0 <get_arg+0x174>
8000b0ae:	30 00       	mov	r0,0
8000b0b0:	40 3b       	lddsp	r11,sp[0xc]
8000b0b2:	5b fb       	cp.w	r11,-1
8000b0b4:	c0 40       	breq	8000b0bc <get_arg+0x180>
8000b0b6:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000b0ba:	c7 a8       	rjmp	8000b1ae <get_arg+0x272>
8000b0bc:	58 60       	cp.w	r0,6
8000b0be:	e0 8b 00 78 	brhi	8000b1ae <get_arg+0x272>
8000b0c2:	6c 0a       	ld.w	r10,r6[0x0]
8000b0c4:	ea cc ff ff 	sub	r12,r5,-1
8000b0c8:	48 6e       	lddpc	lr,8000b0e0 <get_arg+0x1a4>
8000b0ca:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000b0ce:	d7 03       	nop
8000b0d0:	80 01       	ld.sh	r1,r0[0x0]
8000b0d2:	9b 80       	st.w	sp[0x20],r0
8000b0d4:	80 01       	ld.sh	r1,r0[0x0]
8000b0d6:	9a b8       	ld.uh	r8,sp[0x6]
8000b0d8:	80 01       	ld.sh	r1,r0[0x0]
8000b0da:	9a 4c       	ld.sh	r12,sp[0x8]
8000b0dc:	80 01       	ld.sh	r1,r0[0x0]
8000b0de:	98 ac       	ld.uh	r12,r12[0x4]
8000b0e0:	80 01       	ld.sh	r1,r0[0x0]
8000b0e2:	98 cc       	ld.uh	r12,r12[0x8]
8000b0e4:	f4 cb ff f8 	sub	r11,r10,-8
8000b0e8:	8d 0b       	st.w	r6[0x0],r11
8000b0ea:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b0ee:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b0f2:	c0 f8       	rjmp	8000b110 <get_arg+0x1d4>
8000b0f4:	f4 cb ff fc 	sub	r11,r10,-4
8000b0f8:	8d 0b       	st.w	r6[0x0],r11
8000b0fa:	74 0a       	ld.w	r10,r10[0x0]
8000b0fc:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b100:	c0 88       	rjmp	8000b110 <get_arg+0x1d4>
8000b102:	f4 cb ff f8 	sub	r11,r10,-8
8000b106:	8d 0b       	st.w	r6[0x0],r11
8000b108:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b10c:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b110:	0e 9b       	mov	r11,r7
8000b112:	18 95       	mov	r5,r12
8000b114:	c4 e8       	rjmp	8000b1b0 <get_arg+0x274>
8000b116:	62 0a       	ld.w	r10,r1[0x0]
8000b118:	5b fa       	cp.w	r10,-1
8000b11a:	c0 b1       	brne	8000b130 <get_arg+0x1f4>
8000b11c:	50 19       	stdsp	sp[0x4],r9
8000b11e:	50 28       	stdsp	sp[0x8],r8
8000b120:	e0 6a 00 80 	mov	r10,128
8000b124:	30 0b       	mov	r11,0
8000b126:	02 9c       	mov	r12,r1
8000b128:	fe b0 fc 6f 	rcall	8000aa06 <memset>
8000b12c:	40 28       	lddsp	r8,sp[0x8]
8000b12e:	40 19       	lddsp	r9,sp[0x4]
8000b130:	e4 cc 00 01 	sub	r12,r2,1
8000b134:	0e 9b       	mov	r11,r7
8000b136:	50 3c       	stdsp	sp[0xc],r12
8000b138:	f2 0c 0c 49 	max	r9,r9,r12
8000b13c:	c3 a8       	rjmp	8000b1b0 <get_arg+0x274>
8000b13e:	62 0a       	ld.w	r10,r1[0x0]
8000b140:	5b fa       	cp.w	r10,-1
8000b142:	c0 b1       	brne	8000b158 <get_arg+0x21c>
8000b144:	50 19       	stdsp	sp[0x4],r9
8000b146:	50 28       	stdsp	sp[0x8],r8
8000b148:	e0 6a 00 80 	mov	r10,128
8000b14c:	30 0b       	mov	r11,0
8000b14e:	02 9c       	mov	r12,r1
8000b150:	fe b0 fc 5b 	rcall	8000aa06 <memset>
8000b154:	40 28       	lddsp	r8,sp[0x8]
8000b156:	40 19       	lddsp	r9,sp[0x4]
8000b158:	20 12       	sub	r2,1
8000b15a:	30 0a       	mov	r10,0
8000b15c:	0e 9b       	mov	r11,r7
8000b15e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000b162:	f2 02 0c 49 	max	r9,r9,r2
8000b166:	c2 58       	rjmp	8000b1b0 <get_arg+0x274>
8000b168:	16 97       	mov	r7,r11
8000b16a:	6c 0a       	ld.w	r10,r6[0x0]
8000b16c:	f4 cb ff fc 	sub	r11,r10,-4
8000b170:	8d 0b       	st.w	r6[0x0],r11
8000b172:	74 0a       	ld.w	r10,r10[0x0]
8000b174:	0e 9b       	mov	r11,r7
8000b176:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b17a:	2f f5       	sub	r5,-1
8000b17c:	c1 a8       	rjmp	8000b1b0 <get_arg+0x274>
8000b17e:	f4 c2 00 30 	sub	r2,r10,48
8000b182:	c0 68       	rjmp	8000b18e <get_arg+0x252>
8000b184:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000b188:	2f f7       	sub	r7,-1
8000b18a:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000b18e:	0f 8a       	ld.ub	r10,r7[0x0]
8000b190:	58 0a       	cp.w	r10,0
8000b192:	c0 e0       	breq	8000b1ae <get_arg+0x272>
8000b194:	23 0a       	sub	r10,48
8000b196:	58 9a       	cp.w	r10,9
8000b198:	fe 98 ff f6 	brls	8000b184 <get_arg+0x248>
8000b19c:	c0 98       	rjmp	8000b1ae <get_arg+0x272>
8000b19e:	2f f7       	sub	r7,-1
8000b1a0:	0f 8a       	ld.ub	r10,r7[0x0]
8000b1a2:	58 0a       	cp.w	r10,0
8000b1a4:	c0 50       	breq	8000b1ae <get_arg+0x272>
8000b1a6:	23 0a       	sub	r10,48
8000b1a8:	58 9a       	cp.w	r10,9
8000b1aa:	fe 98 ff fa 	brls	8000b19e <get_arg+0x262>
8000b1ae:	0e 9b       	mov	r11,r7
8000b1b0:	40 7c       	lddsp	r12,sp[0x1c]
8000b1b2:	30 ba       	mov	r10,11
8000b1b4:	f4 0c 18 00 	cp.b	r12,r10
8000b1b8:	fe 91 fe ec 	brne	8000af90 <get_arg+0x54>
8000b1bc:	40 42       	lddsp	r2,sp[0x10]
8000b1be:	17 8c       	ld.ub	r12,r11[0x0]
8000b1c0:	0a 32       	cp.w	r2,r5
8000b1c2:	5f 4a       	srge	r10
8000b1c4:	f0 0c 18 00 	cp.b	r12,r8
8000b1c8:	5f 1c       	srne	r12
8000b1ca:	f9 ea 00 0a 	and	r10,r12,r10
8000b1ce:	f0 0a 18 00 	cp.b	r10,r8
8000b1d2:	fe 91 fe c9 	brne	8000af64 <get_arg+0x28>
8000b1d6:	30 08       	mov	r8,0
8000b1d8:	40 4e       	lddsp	lr,sp[0x10]
8000b1da:	17 8a       	ld.ub	r10,r11[0x0]
8000b1dc:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000b1e0:	f0 0a 18 00 	cp.b	r10,r8
8000b1e4:	fc 09 17 10 	movne	r9,lr
8000b1e8:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000b1ec:	06 9e       	mov	lr,r3
8000b1ee:	c2 a8       	rjmp	8000b242 <get_arg+0x306>
8000b1f0:	62 0a       	ld.w	r10,r1[0x0]
8000b1f2:	58 3a       	cp.w	r10,3
8000b1f4:	c1 e0       	breq	8000b230 <get_arg+0x2f4>
8000b1f6:	e0 89 00 07 	brgt	8000b204 <get_arg+0x2c8>
8000b1fa:	58 1a       	cp.w	r10,1
8000b1fc:	c1 a0       	breq	8000b230 <get_arg+0x2f4>
8000b1fe:	58 2a       	cp.w	r10,2
8000b200:	c1 81       	brne	8000b230 <get_arg+0x2f4>
8000b202:	c0 58       	rjmp	8000b20c <get_arg+0x2d0>
8000b204:	58 5a       	cp.w	r10,5
8000b206:	c0 c0       	breq	8000b21e <get_arg+0x2e2>
8000b208:	c0 b5       	brlt	8000b21e <get_arg+0x2e2>
8000b20a:	c1 38       	rjmp	8000b230 <get_arg+0x2f4>
8000b20c:	6c 0a       	ld.w	r10,r6[0x0]
8000b20e:	f4 cc ff f8 	sub	r12,r10,-8
8000b212:	8d 0c       	st.w	r6[0x0],r12
8000b214:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b218:	f0 e3 00 00 	st.d	r8[0],r2
8000b21c:	c1 08       	rjmp	8000b23c <get_arg+0x300>
8000b21e:	6c 0a       	ld.w	r10,r6[0x0]
8000b220:	f4 cc ff f8 	sub	r12,r10,-8
8000b224:	8d 0c       	st.w	r6[0x0],r12
8000b226:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b22a:	f0 e3 00 00 	st.d	r8[0],r2
8000b22e:	c0 78       	rjmp	8000b23c <get_arg+0x300>
8000b230:	6c 0a       	ld.w	r10,r6[0x0]
8000b232:	f4 cc ff fc 	sub	r12,r10,-4
8000b236:	8d 0c       	st.w	r6[0x0],r12
8000b238:	74 0a       	ld.w	r10,r10[0x0]
8000b23a:	91 0a       	st.w	r8[0x0],r10
8000b23c:	2f f5       	sub	r5,-1
8000b23e:	2f 88       	sub	r8,-8
8000b240:	2f c1       	sub	r1,-4
8000b242:	12 35       	cp.w	r5,r9
8000b244:	fe 9a ff d6 	brle	8000b1f0 <get_arg+0x2b4>
8000b248:	1c 93       	mov	r3,lr
8000b24a:	40 52       	lddsp	r2,sp[0x14]
8000b24c:	40 6e       	lddsp	lr,sp[0x18]
8000b24e:	85 05       	st.w	r2[0x0],r5
8000b250:	9d 0b       	st.w	lr[0x0],r11
8000b252:	40 4b       	lddsp	r11,sp[0x10]
8000b254:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000b258:	2f 8d       	sub	sp,-32
8000b25a:	d8 32       	popm	r0-r7,pc

8000b25c <__sprint_r>:
8000b25c:	d4 21       	pushm	r4-r7,lr
8000b25e:	14 97       	mov	r7,r10
8000b260:	74 28       	ld.w	r8,r10[0x8]
8000b262:	58 08       	cp.w	r8,0
8000b264:	c0 41       	brne	8000b26c <__sprint_r+0x10>
8000b266:	95 18       	st.w	r10[0x4],r8
8000b268:	10 9c       	mov	r12,r8
8000b26a:	d8 22       	popm	r4-r7,pc
8000b26c:	e0 a0 18 ce 	rcall	8000e408 <__sfvwrite_r>
8000b270:	30 08       	mov	r8,0
8000b272:	8f 18       	st.w	r7[0x4],r8
8000b274:	8f 28       	st.w	r7[0x8],r8
8000b276:	d8 22       	popm	r4-r7,pc

8000b278 <_vfprintf_r>:
8000b278:	d4 31       	pushm	r0-r7,lr
8000b27a:	fa cd 06 bc 	sub	sp,sp,1724
8000b27e:	51 09       	stdsp	sp[0x40],r9
8000b280:	16 91       	mov	r1,r11
8000b282:	14 97       	mov	r7,r10
8000b284:	18 95       	mov	r5,r12
8000b286:	e0 a0 1a 31 	rcall	8000e6e8 <_localeconv_r>
8000b28a:	78 0c       	ld.w	r12,r12[0x0]
8000b28c:	50 cc       	stdsp	sp[0x30],r12
8000b28e:	58 05       	cp.w	r5,0
8000b290:	c0 70       	breq	8000b29e <_vfprintf_r+0x26>
8000b292:	6a 68       	ld.w	r8,r5[0x18]
8000b294:	58 08       	cp.w	r8,0
8000b296:	c0 41       	brne	8000b29e <_vfprintf_r+0x26>
8000b298:	0a 9c       	mov	r12,r5
8000b29a:	e0 a0 17 57 	rcall	8000e148 <__sinit>
8000b29e:	4d 08       	lddpc	r8,8000b3dc <_vfprintf_r+0x164>
8000b2a0:	10 31       	cp.w	r1,r8
8000b2a2:	c0 31       	brne	8000b2a8 <_vfprintf_r+0x30>
8000b2a4:	6a 01       	ld.w	r1,r5[0x0]
8000b2a6:	c0 a8       	rjmp	8000b2ba <_vfprintf_r+0x42>
8000b2a8:	4c e8       	lddpc	r8,8000b3e0 <_vfprintf_r+0x168>
8000b2aa:	10 31       	cp.w	r1,r8
8000b2ac:	c0 31       	brne	8000b2b2 <_vfprintf_r+0x3a>
8000b2ae:	6a 11       	ld.w	r1,r5[0x4]
8000b2b0:	c0 58       	rjmp	8000b2ba <_vfprintf_r+0x42>
8000b2b2:	4c d8       	lddpc	r8,8000b3e4 <_vfprintf_r+0x16c>
8000b2b4:	10 31       	cp.w	r1,r8
8000b2b6:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000b2ba:	82 68       	ld.sh	r8,r1[0xc]
8000b2bc:	ed b8 00 03 	bld	r8,0x3
8000b2c0:	c0 41       	brne	8000b2c8 <_vfprintf_r+0x50>
8000b2c2:	62 48       	ld.w	r8,r1[0x10]
8000b2c4:	58 08       	cp.w	r8,0
8000b2c6:	c0 71       	brne	8000b2d4 <_vfprintf_r+0x5c>
8000b2c8:	02 9b       	mov	r11,r1
8000b2ca:	0a 9c       	mov	r12,r5
8000b2cc:	e0 a0 0f 6c 	rcall	8000d1a4 <__swsetup_r>
8000b2d0:	e0 81 0f 63 	brne	8000d196 <_vfprintf_r+0x1f1e>
8000b2d4:	82 68       	ld.sh	r8,r1[0xc]
8000b2d6:	10 99       	mov	r9,r8
8000b2d8:	e2 19 00 1a 	andl	r9,0x1a,COH
8000b2dc:	58 a9       	cp.w	r9,10
8000b2de:	c3 c1       	brne	8000b356 <_vfprintf_r+0xde>
8000b2e0:	82 79       	ld.sh	r9,r1[0xe]
8000b2e2:	30 0a       	mov	r10,0
8000b2e4:	f4 09 19 00 	cp.h	r9,r10
8000b2e8:	c3 75       	brlt	8000b356 <_vfprintf_r+0xde>
8000b2ea:	a1 d8       	cbr	r8,0x1
8000b2ec:	fb 58 05 d0 	st.h	sp[1488],r8
8000b2f0:	62 88       	ld.w	r8,r1[0x20]
8000b2f2:	fb 48 05 e4 	st.w	sp[1508],r8
8000b2f6:	62 a8       	ld.w	r8,r1[0x28]
8000b2f8:	fb 48 05 ec 	st.w	sp[1516],r8
8000b2fc:	fa c8 ff bc 	sub	r8,sp,-68
8000b300:	fb 48 05 d4 	st.w	sp[1492],r8
8000b304:	fb 48 05 c4 	st.w	sp[1476],r8
8000b308:	e0 68 04 00 	mov	r8,1024
8000b30c:	fb 48 05 d8 	st.w	sp[1496],r8
8000b310:	fb 48 05 cc 	st.w	sp[1484],r8
8000b314:	30 08       	mov	r8,0
8000b316:	fb 59 05 d2 	st.h	sp[1490],r9
8000b31a:	0e 9a       	mov	r10,r7
8000b31c:	41 09       	lddsp	r9,sp[0x40]
8000b31e:	fa c7 fa 3c 	sub	r7,sp,-1476
8000b322:	fb 48 05 dc 	st.w	sp[1500],r8
8000b326:	0a 9c       	mov	r12,r5
8000b328:	0e 9b       	mov	r11,r7
8000b32a:	ca 7f       	rcall	8000b278 <_vfprintf_r>
8000b32c:	50 bc       	stdsp	sp[0x2c],r12
8000b32e:	c0 95       	brlt	8000b340 <_vfprintf_r+0xc8>
8000b330:	0e 9b       	mov	r11,r7
8000b332:	0a 9c       	mov	r12,r5
8000b334:	e0 a0 16 2e 	rcall	8000df90 <_fflush_r>
8000b338:	40 be       	lddsp	lr,sp[0x2c]
8000b33a:	f9 be 01 ff 	movne	lr,-1
8000b33e:	50 be       	stdsp	sp[0x2c],lr
8000b340:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000b344:	ed b8 00 06 	bld	r8,0x6
8000b348:	e0 81 0f 29 	brne	8000d19a <_vfprintf_r+0x1f22>
8000b34c:	82 68       	ld.sh	r8,r1[0xc]
8000b34e:	a7 a8       	sbr	r8,0x6
8000b350:	a2 68       	st.h	r1[0xc],r8
8000b352:	e0 8f 0f 24 	bral	8000d19a <_vfprintf_r+0x1f22>
8000b356:	30 08       	mov	r8,0
8000b358:	fb 48 06 b4 	st.w	sp[1716],r8
8000b35c:	fb 48 06 90 	st.w	sp[1680],r8
8000b360:	fb 48 06 8c 	st.w	sp[1676],r8
8000b364:	fb 48 06 b0 	st.w	sp[1712],r8
8000b368:	30 08       	mov	r8,0
8000b36a:	30 09       	mov	r9,0
8000b36c:	50 a7       	stdsp	sp[0x28],r7
8000b36e:	50 78       	stdsp	sp[0x1c],r8
8000b370:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b374:	3f f8       	mov	r8,-1
8000b376:	50 59       	stdsp	sp[0x14],r9
8000b378:	fb 43 06 88 	st.w	sp[1672],r3
8000b37c:	fb 48 05 44 	st.w	sp[1348],r8
8000b380:	12 9c       	mov	r12,r9
8000b382:	50 69       	stdsp	sp[0x18],r9
8000b384:	50 d9       	stdsp	sp[0x34],r9
8000b386:	50 e9       	stdsp	sp[0x38],r9
8000b388:	50 b9       	stdsp	sp[0x2c],r9
8000b38a:	12 97       	mov	r7,r9
8000b38c:	0a 94       	mov	r4,r5
8000b38e:	40 a2       	lddsp	r2,sp[0x28]
8000b390:	32 5a       	mov	r10,37
8000b392:	30 08       	mov	r8,0
8000b394:	c0 28       	rjmp	8000b398 <_vfprintf_r+0x120>
8000b396:	2f f2       	sub	r2,-1
8000b398:	05 89       	ld.ub	r9,r2[0x0]
8000b39a:	f0 09 18 00 	cp.b	r9,r8
8000b39e:	5f 1b       	srne	r11
8000b3a0:	f4 09 18 00 	cp.b	r9,r10
8000b3a4:	5f 19       	srne	r9
8000b3a6:	f3 eb 00 0b 	and	r11,r9,r11
8000b3aa:	f0 0b 18 00 	cp.b	r11,r8
8000b3ae:	cf 41       	brne	8000b396 <_vfprintf_r+0x11e>
8000b3b0:	40 ab       	lddsp	r11,sp[0x28]
8000b3b2:	e4 0b 01 06 	sub	r6,r2,r11
8000b3b6:	c2 50       	breq	8000b400 <_vfprintf_r+0x188>
8000b3b8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000b3bc:	0c 08       	add	r8,r6
8000b3be:	87 0b       	st.w	r3[0x0],r11
8000b3c0:	fb 48 06 90 	st.w	sp[1680],r8
8000b3c4:	87 16       	st.w	r3[0x4],r6
8000b3c6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000b3ca:	2f f8       	sub	r8,-1
8000b3cc:	fb 48 06 8c 	st.w	sp[1676],r8
8000b3d0:	58 78       	cp.w	r8,7
8000b3d2:	e0 89 00 0b 	brgt	8000b3e8 <_vfprintf_r+0x170>
8000b3d6:	2f 83       	sub	r3,-8
8000b3d8:	c1 18       	rjmp	8000b3fa <_vfprintf_r+0x182>
8000b3da:	d7 03       	nop
8000b3dc:	80 01       	ld.sh	r1,r0[0x0]
8000b3de:	9c 90       	ld.uh	r0,lr[0x2]
8000b3e0:	80 01       	ld.sh	r1,r0[0x0]
8000b3e2:	9c b0       	ld.uh	r0,lr[0x6]
8000b3e4:	80 01       	ld.sh	r1,r0[0x0]
8000b3e6:	9c d0       	ld.uh	r0,lr[0xa]
8000b3e8:	fa ca f9 78 	sub	r10,sp,-1672
8000b3ec:	02 9b       	mov	r11,r1
8000b3ee:	08 9c       	mov	r12,r4
8000b3f0:	c3 6f       	rcall	8000b25c <__sprint_r>
8000b3f2:	e0 81 0e ce 	brne	8000d18e <_vfprintf_r+0x1f16>
8000b3f6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000b3fa:	40 ba       	lddsp	r10,sp[0x2c]
8000b3fc:	0c 0a       	add	r10,r6
8000b3fe:	50 ba       	stdsp	sp[0x2c],r10
8000b400:	05 89       	ld.ub	r9,r2[0x0]
8000b402:	30 08       	mov	r8,0
8000b404:	f0 09 18 00 	cp.b	r9,r8
8000b408:	e0 80 0e b2 	breq	8000d16c <_vfprintf_r+0x1ef4>
8000b40c:	30 09       	mov	r9,0
8000b40e:	fb 68 06 bb 	st.b	sp[1723],r8
8000b412:	0e 96       	mov	r6,r7
8000b414:	e4 c8 ff ff 	sub	r8,r2,-1
8000b418:	3f fe       	mov	lr,-1
8000b41a:	50 93       	stdsp	sp[0x24],r3
8000b41c:	50 41       	stdsp	sp[0x10],r1
8000b41e:	0e 93       	mov	r3,r7
8000b420:	04 91       	mov	r1,r2
8000b422:	50 89       	stdsp	sp[0x20],r9
8000b424:	50 a8       	stdsp	sp[0x28],r8
8000b426:	50 2e       	stdsp	sp[0x8],lr
8000b428:	50 39       	stdsp	sp[0xc],r9
8000b42a:	12 95       	mov	r5,r9
8000b42c:	12 90       	mov	r0,r9
8000b42e:	10 97       	mov	r7,r8
8000b430:	08 92       	mov	r2,r4
8000b432:	c0 78       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b434:	3f fc       	mov	r12,-1
8000b436:	08 97       	mov	r7,r4
8000b438:	50 2c       	stdsp	sp[0x8],r12
8000b43a:	c0 38       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b43c:	30 0b       	mov	r11,0
8000b43e:	50 3b       	stdsp	sp[0xc],r11
8000b440:	0f 38       	ld.ub	r8,r7++
8000b442:	c0 28       	rjmp	8000b446 <_vfprintf_r+0x1ce>
8000b444:	12 90       	mov	r0,r9
8000b446:	f0 c9 00 20 	sub	r9,r8,32
8000b44a:	e0 49 00 58 	cp.w	r9,88
8000b44e:	e0 8b 0a 36 	brhi	8000c8ba <_vfprintf_r+0x1642>
8000b452:	4d 9a       	lddpc	r10,8000b5b4 <_vfprintf_r+0x33c>
8000b454:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000b458:	50 a7       	stdsp	sp[0x28],r7
8000b45a:	50 80       	stdsp	sp[0x20],r0
8000b45c:	0c 97       	mov	r7,r6
8000b45e:	04 94       	mov	r4,r2
8000b460:	06 96       	mov	r6,r3
8000b462:	02 92       	mov	r2,r1
8000b464:	4d 59       	lddpc	r9,8000b5b8 <_vfprintf_r+0x340>
8000b466:	40 93       	lddsp	r3,sp[0x24]
8000b468:	10 90       	mov	r0,r8
8000b46a:	40 41       	lddsp	r1,sp[0x10]
8000b46c:	50 d9       	stdsp	sp[0x34],r9
8000b46e:	e0 8f 08 95 	bral	8000c598 <_vfprintf_r+0x1320>
8000b472:	30 08       	mov	r8,0
8000b474:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000b478:	f0 09 18 00 	cp.b	r9,r8
8000b47c:	ce 21       	brne	8000b440 <_vfprintf_r+0x1c8>
8000b47e:	32 08       	mov	r8,32
8000b480:	c6 e8       	rjmp	8000b55c <_vfprintf_r+0x2e4>
8000b482:	a1 a5       	sbr	r5,0x0
8000b484:	cd eb       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b486:	0f 89       	ld.ub	r9,r7[0x0]
8000b488:	f2 c8 00 30 	sub	r8,r9,48
8000b48c:	58 98       	cp.w	r8,9
8000b48e:	e0 8b 00 1d 	brhi	8000b4c8 <_vfprintf_r+0x250>
8000b492:	ee c8 ff ff 	sub	r8,r7,-1
8000b496:	30 0b       	mov	r11,0
8000b498:	23 09       	sub	r9,48
8000b49a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b49e:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000b4a2:	11 39       	ld.ub	r9,r8++
8000b4a4:	f2 ca 00 30 	sub	r10,r9,48
8000b4a8:	58 9a       	cp.w	r10,9
8000b4aa:	fe 98 ff f7 	brls	8000b498 <_vfprintf_r+0x220>
8000b4ae:	e0 49 00 24 	cp.w	r9,36
8000b4b2:	cc 51       	brne	8000b43c <_vfprintf_r+0x1c4>
8000b4b4:	e0 4b 00 20 	cp.w	r11,32
8000b4b8:	e0 89 0e 6a 	brgt	8000d18c <_vfprintf_r+0x1f14>
8000b4bc:	20 1b       	sub	r11,1
8000b4be:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b4c2:	12 3b       	cp.w	r11,r9
8000b4c4:	c0 95       	brlt	8000b4d6 <_vfprintf_r+0x25e>
8000b4c6:	c1 08       	rjmp	8000b4e6 <_vfprintf_r+0x26e>
8000b4c8:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000b4cc:	ec ca ff ff 	sub	r10,r6,-1
8000b4d0:	12 36       	cp.w	r6,r9
8000b4d2:	c1 f5       	brlt	8000b510 <_vfprintf_r+0x298>
8000b4d4:	c2 68       	rjmp	8000b520 <_vfprintf_r+0x2a8>
8000b4d6:	fa ce f9 44 	sub	lr,sp,-1724
8000b4da:	10 97       	mov	r7,r8
8000b4dc:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000b4e0:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000b4e4:	c3 58       	rjmp	8000b54e <_vfprintf_r+0x2d6>
8000b4e6:	10 97       	mov	r7,r8
8000b4e8:	fa c8 f9 50 	sub	r8,sp,-1712
8000b4ec:	1a d8       	st.w	--sp,r8
8000b4ee:	fa c8 fa b8 	sub	r8,sp,-1352
8000b4f2:	1a d8       	st.w	--sp,r8
8000b4f4:	fa c8 fb b4 	sub	r8,sp,-1100
8000b4f8:	02 9a       	mov	r10,r1
8000b4fa:	1a d8       	st.w	--sp,r8
8000b4fc:	04 9c       	mov	r12,r2
8000b4fe:	fa c8 f9 40 	sub	r8,sp,-1728
8000b502:	fa c9 ff b4 	sub	r9,sp,-76
8000b506:	fe b0 fd 1b 	rcall	8000af3c <get_arg>
8000b50a:	2f dd       	sub	sp,-12
8000b50c:	78 00       	ld.w	r0,r12[0x0]
8000b50e:	c2 08       	rjmp	8000b54e <_vfprintf_r+0x2d6>
8000b510:	fa cc f9 44 	sub	r12,sp,-1724
8000b514:	14 96       	mov	r6,r10
8000b516:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000b51a:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000b51e:	c1 88       	rjmp	8000b54e <_vfprintf_r+0x2d6>
8000b520:	41 08       	lddsp	r8,sp[0x40]
8000b522:	59 f9       	cp.w	r9,31
8000b524:	e0 89 00 11 	brgt	8000b546 <_vfprintf_r+0x2ce>
8000b528:	f0 cb ff fc 	sub	r11,r8,-4
8000b52c:	51 0b       	stdsp	sp[0x40],r11
8000b52e:	70 00       	ld.w	r0,r8[0x0]
8000b530:	fa cb f9 44 	sub	r11,sp,-1724
8000b534:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000b538:	f1 40 fd 88 	st.w	r8[-632],r0
8000b53c:	2f f9       	sub	r9,-1
8000b53e:	14 96       	mov	r6,r10
8000b540:	fb 49 06 b4 	st.w	sp[1716],r9
8000b544:	c0 58       	rjmp	8000b54e <_vfprintf_r+0x2d6>
8000b546:	70 00       	ld.w	r0,r8[0x0]
8000b548:	14 96       	mov	r6,r10
8000b54a:	2f c8       	sub	r8,-4
8000b54c:	51 08       	stdsp	sp[0x40],r8
8000b54e:	58 00       	cp.w	r0,0
8000b550:	fe 94 ff 78 	brge	8000b440 <_vfprintf_r+0x1c8>
8000b554:	5c 30       	neg	r0
8000b556:	a3 a5       	sbr	r5,0x2
8000b558:	c7 4b       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b55a:	32 b8       	mov	r8,43
8000b55c:	fb 68 06 bb 	st.b	sp[1723],r8
8000b560:	c7 0b       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b562:	0f 38       	ld.ub	r8,r7++
8000b564:	e0 48 00 2a 	cp.w	r8,42
8000b568:	c0 30       	breq	8000b56e <_vfprintf_r+0x2f6>
8000b56a:	30 09       	mov	r9,0
8000b56c:	c7 d8       	rjmp	8000b666 <_vfprintf_r+0x3ee>
8000b56e:	0f 88       	ld.ub	r8,r7[0x0]
8000b570:	f0 c9 00 30 	sub	r9,r8,48
8000b574:	58 99       	cp.w	r9,9
8000b576:	e0 8b 00 23 	brhi	8000b5bc <_vfprintf_r+0x344>
8000b57a:	ee c4 ff ff 	sub	r4,r7,-1
8000b57e:	30 0b       	mov	r11,0
8000b580:	23 08       	sub	r8,48
8000b582:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000b586:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000b58a:	09 38       	ld.ub	r8,r4++
8000b58c:	f0 c9 00 30 	sub	r9,r8,48
8000b590:	58 99       	cp.w	r9,9
8000b592:	fe 98 ff f7 	brls	8000b580 <_vfprintf_r+0x308>
8000b596:	e0 48 00 24 	cp.w	r8,36
8000b59a:	fe 91 ff 51 	brne	8000b43c <_vfprintf_r+0x1c4>
8000b59e:	e0 4b 00 20 	cp.w	r11,32
8000b5a2:	e0 89 0d f5 	brgt	8000d18c <_vfprintf_r+0x1f14>
8000b5a6:	20 1b       	sub	r11,1
8000b5a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b5ac:	10 3b       	cp.w	r11,r8
8000b5ae:	c0 e5       	brlt	8000b5ca <_vfprintf_r+0x352>
8000b5b0:	c1 58       	rjmp	8000b5da <_vfprintf_r+0x362>
8000b5b2:	d7 03       	nop
8000b5b4:	80 01       	ld.sh	r1,r0[0x0]
8000b5b6:	98 e8       	ld.uh	r8,r12[0xc]
8000b5b8:	80 01       	ld.sh	r1,r0[0x0]
8000b5ba:	9b 24       	st.w	sp[0x8],r4
8000b5bc:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000b5c0:	ec c9 ff ff 	sub	r9,r6,-1
8000b5c4:	14 36       	cp.w	r6,r10
8000b5c6:	c1 f5       	brlt	8000b604 <_vfprintf_r+0x38c>
8000b5c8:	c2 88       	rjmp	8000b618 <_vfprintf_r+0x3a0>
8000b5ca:	fa ca f9 44 	sub	r10,sp,-1724
8000b5ce:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000b5d2:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000b5d6:	50 2b       	stdsp	sp[0x8],r11
8000b5d8:	c3 c8       	rjmp	8000b650 <_vfprintf_r+0x3d8>
8000b5da:	fa c8 f9 50 	sub	r8,sp,-1712
8000b5de:	1a d8       	st.w	--sp,r8
8000b5e0:	fa c8 fa b8 	sub	r8,sp,-1352
8000b5e4:	1a d8       	st.w	--sp,r8
8000b5e6:	fa c8 fb b4 	sub	r8,sp,-1100
8000b5ea:	02 9a       	mov	r10,r1
8000b5ec:	1a d8       	st.w	--sp,r8
8000b5ee:	04 9c       	mov	r12,r2
8000b5f0:	fa c8 f9 40 	sub	r8,sp,-1728
8000b5f4:	fa c9 ff b4 	sub	r9,sp,-76
8000b5f8:	fe b0 fc a2 	rcall	8000af3c <get_arg>
8000b5fc:	2f dd       	sub	sp,-12
8000b5fe:	78 0c       	ld.w	r12,r12[0x0]
8000b600:	50 2c       	stdsp	sp[0x8],r12
8000b602:	c2 78       	rjmp	8000b650 <_vfprintf_r+0x3d8>
8000b604:	12 96       	mov	r6,r9
8000b606:	0e 94       	mov	r4,r7
8000b608:	fa c9 f9 44 	sub	r9,sp,-1724
8000b60c:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000b610:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000b614:	50 28       	stdsp	sp[0x8],r8
8000b616:	c1 d8       	rjmp	8000b650 <_vfprintf_r+0x3d8>
8000b618:	41 08       	lddsp	r8,sp[0x40]
8000b61a:	59 fa       	cp.w	r10,31
8000b61c:	e0 89 00 14 	brgt	8000b644 <_vfprintf_r+0x3cc>
8000b620:	f0 cb ff fc 	sub	r11,r8,-4
8000b624:	70 08       	ld.w	r8,r8[0x0]
8000b626:	51 0b       	stdsp	sp[0x40],r11
8000b628:	50 28       	stdsp	sp[0x8],r8
8000b62a:	fa c6 f9 44 	sub	r6,sp,-1724
8000b62e:	40 2e       	lddsp	lr,sp[0x8]
8000b630:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000b634:	f1 4e fd 88 	st.w	r8[-632],lr
8000b638:	2f fa       	sub	r10,-1
8000b63a:	0e 94       	mov	r4,r7
8000b63c:	fb 4a 06 b4 	st.w	sp[1716],r10
8000b640:	12 96       	mov	r6,r9
8000b642:	c0 78       	rjmp	8000b650 <_vfprintf_r+0x3d8>
8000b644:	70 0c       	ld.w	r12,r8[0x0]
8000b646:	0e 94       	mov	r4,r7
8000b648:	2f c8       	sub	r8,-4
8000b64a:	50 2c       	stdsp	sp[0x8],r12
8000b64c:	12 96       	mov	r6,r9
8000b64e:	51 08       	stdsp	sp[0x40],r8
8000b650:	40 2b       	lddsp	r11,sp[0x8]
8000b652:	58 0b       	cp.w	r11,0
8000b654:	fe 95 fe f0 	brlt	8000b434 <_vfprintf_r+0x1bc>
8000b658:	08 97       	mov	r7,r4
8000b65a:	cf 3a       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b65c:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b660:	0f 38       	ld.ub	r8,r7++
8000b662:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000b666:	f0 ca 00 30 	sub	r10,r8,48
8000b66a:	58 9a       	cp.w	r10,9
8000b66c:	fe 98 ff f8 	brls	8000b65c <_vfprintf_r+0x3e4>
8000b670:	3f fa       	mov	r10,-1
8000b672:	f2 0a 0c 49 	max	r9,r9,r10
8000b676:	50 29       	stdsp	sp[0x8],r9
8000b678:	ce 7a       	rjmp	8000b446 <_vfprintf_r+0x1ce>
8000b67a:	a7 b5       	sbr	r5,0x7
8000b67c:	ce 2a       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b67e:	30 09       	mov	r9,0
8000b680:	23 08       	sub	r8,48
8000b682:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000b686:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000b68a:	0f 38       	ld.ub	r8,r7++
8000b68c:	f0 ca 00 30 	sub	r10,r8,48
8000b690:	58 9a       	cp.w	r10,9
8000b692:	fe 98 ff f7 	brls	8000b680 <_vfprintf_r+0x408>
8000b696:	e0 48 00 24 	cp.w	r8,36
8000b69a:	fe 91 fe d5 	brne	8000b444 <_vfprintf_r+0x1cc>
8000b69e:	e0 49 00 20 	cp.w	r9,32
8000b6a2:	e0 89 0d 75 	brgt	8000d18c <_vfprintf_r+0x1f14>
8000b6a6:	f2 c3 00 01 	sub	r3,r9,1
8000b6aa:	30 19       	mov	r9,1
8000b6ac:	50 39       	stdsp	sp[0xc],r9
8000b6ae:	cc 9a       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b6b0:	a3 b5       	sbr	r5,0x3
8000b6b2:	cc 7a       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b6b4:	a7 a5       	sbr	r5,0x6
8000b6b6:	cc 5a       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b6b8:	0a 98       	mov	r8,r5
8000b6ba:	a5 b5       	sbr	r5,0x5
8000b6bc:	a5 a8       	sbr	r8,0x4
8000b6be:	0f 89       	ld.ub	r9,r7[0x0]
8000b6c0:	36 ce       	mov	lr,108
8000b6c2:	fc 09 18 00 	cp.b	r9,lr
8000b6c6:	f7 b7 00 ff 	subeq	r7,-1
8000b6ca:	f0 05 17 10 	movne	r5,r8
8000b6ce:	cb 9a       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b6d0:	a5 b5       	sbr	r5,0x5
8000b6d2:	cb 7a       	rjmp	8000b440 <_vfprintf_r+0x1c8>
8000b6d4:	50 a7       	stdsp	sp[0x28],r7
8000b6d6:	50 80       	stdsp	sp[0x20],r0
8000b6d8:	0c 97       	mov	r7,r6
8000b6da:	10 90       	mov	r0,r8
8000b6dc:	06 96       	mov	r6,r3
8000b6de:	04 94       	mov	r4,r2
8000b6e0:	40 93       	lddsp	r3,sp[0x24]
8000b6e2:	02 92       	mov	r2,r1
8000b6e4:	0e 99       	mov	r9,r7
8000b6e6:	40 41       	lddsp	r1,sp[0x10]
8000b6e8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b6ec:	40 3c       	lddsp	r12,sp[0xc]
8000b6ee:	58 0c       	cp.w	r12,0
8000b6f0:	c1 d0       	breq	8000b72a <_vfprintf_r+0x4b2>
8000b6f2:	10 36       	cp.w	r6,r8
8000b6f4:	c0 64       	brge	8000b700 <_vfprintf_r+0x488>
8000b6f6:	fa cb f9 44 	sub	r11,sp,-1724
8000b6fa:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b6fe:	c1 d8       	rjmp	8000b738 <_vfprintf_r+0x4c0>
8000b700:	fa c8 f9 50 	sub	r8,sp,-1712
8000b704:	1a d8       	st.w	--sp,r8
8000b706:	fa c8 fa b8 	sub	r8,sp,-1352
8000b70a:	1a d8       	st.w	--sp,r8
8000b70c:	fa c8 fb b4 	sub	r8,sp,-1100
8000b710:	1a d8       	st.w	--sp,r8
8000b712:	fa c8 f9 40 	sub	r8,sp,-1728
8000b716:	fa c9 ff b4 	sub	r9,sp,-76
8000b71a:	04 9a       	mov	r10,r2
8000b71c:	0c 9b       	mov	r11,r6
8000b71e:	08 9c       	mov	r12,r4
8000b720:	fe b0 fc 0e 	rcall	8000af3c <get_arg>
8000b724:	2f dd       	sub	sp,-12
8000b726:	19 b8       	ld.ub	r8,r12[0x3]
8000b728:	c2 28       	rjmp	8000b76c <_vfprintf_r+0x4f4>
8000b72a:	2f f7       	sub	r7,-1
8000b72c:	10 39       	cp.w	r9,r8
8000b72e:	c0 84       	brge	8000b73e <_vfprintf_r+0x4c6>
8000b730:	fa ca f9 44 	sub	r10,sp,-1724
8000b734:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000b738:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000b73c:	c1 88       	rjmp	8000b76c <_vfprintf_r+0x4f4>
8000b73e:	41 09       	lddsp	r9,sp[0x40]
8000b740:	59 f8       	cp.w	r8,31
8000b742:	e0 89 00 12 	brgt	8000b766 <_vfprintf_r+0x4ee>
8000b746:	f2 ca ff fc 	sub	r10,r9,-4
8000b74a:	51 0a       	stdsp	sp[0x40],r10
8000b74c:	72 09       	ld.w	r9,r9[0x0]
8000b74e:	fa c6 f9 44 	sub	r6,sp,-1724
8000b752:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000b756:	2f f8       	sub	r8,-1
8000b758:	f5 49 fd 88 	st.w	r10[-632],r9
8000b75c:	fb 48 06 b4 	st.w	sp[1716],r8
8000b760:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000b764:	c0 48       	rjmp	8000b76c <_vfprintf_r+0x4f4>
8000b766:	13 b8       	ld.ub	r8,r9[0x3]
8000b768:	2f c9       	sub	r9,-4
8000b76a:	51 09       	stdsp	sp[0x40],r9
8000b76c:	fb 68 06 60 	st.b	sp[1632],r8
8000b770:	30 0e       	mov	lr,0
8000b772:	30 08       	mov	r8,0
8000b774:	30 12       	mov	r2,1
8000b776:	fb 68 06 bb 	st.b	sp[1723],r8
8000b77a:	50 2e       	stdsp	sp[0x8],lr
8000b77c:	e0 8f 08 b1 	bral	8000c8de <_vfprintf_r+0x1666>
8000b780:	50 a7       	stdsp	sp[0x28],r7
8000b782:	50 80       	stdsp	sp[0x20],r0
8000b784:	0c 97       	mov	r7,r6
8000b786:	04 94       	mov	r4,r2
8000b788:	06 96       	mov	r6,r3
8000b78a:	02 92       	mov	r2,r1
8000b78c:	40 93       	lddsp	r3,sp[0x24]
8000b78e:	10 90       	mov	r0,r8
8000b790:	40 41       	lddsp	r1,sp[0x10]
8000b792:	a5 a5       	sbr	r5,0x4
8000b794:	c0 a8       	rjmp	8000b7a8 <_vfprintf_r+0x530>
8000b796:	50 a7       	stdsp	sp[0x28],r7
8000b798:	50 80       	stdsp	sp[0x20],r0
8000b79a:	0c 97       	mov	r7,r6
8000b79c:	04 94       	mov	r4,r2
8000b79e:	06 96       	mov	r6,r3
8000b7a0:	02 92       	mov	r2,r1
8000b7a2:	40 93       	lddsp	r3,sp[0x24]
8000b7a4:	10 90       	mov	r0,r8
8000b7a6:	40 41       	lddsp	r1,sp[0x10]
8000b7a8:	ed b5 00 05 	bld	r5,0x5
8000b7ac:	c5 11       	brne	8000b84e <_vfprintf_r+0x5d6>
8000b7ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b7b2:	40 3c       	lddsp	r12,sp[0xc]
8000b7b4:	58 0c       	cp.w	r12,0
8000b7b6:	c1 e0       	breq	8000b7f2 <_vfprintf_r+0x57a>
8000b7b8:	10 36       	cp.w	r6,r8
8000b7ba:	c0 64       	brge	8000b7c6 <_vfprintf_r+0x54e>
8000b7bc:	fa cb f9 44 	sub	r11,sp,-1724
8000b7c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b7c4:	c2 08       	rjmp	8000b804 <_vfprintf_r+0x58c>
8000b7c6:	fa c8 f9 50 	sub	r8,sp,-1712
8000b7ca:	1a d8       	st.w	--sp,r8
8000b7cc:	fa c8 fa b8 	sub	r8,sp,-1352
8000b7d0:	0c 9b       	mov	r11,r6
8000b7d2:	1a d8       	st.w	--sp,r8
8000b7d4:	fa c8 fb b4 	sub	r8,sp,-1100
8000b7d8:	1a d8       	st.w	--sp,r8
8000b7da:	fa c9 ff b4 	sub	r9,sp,-76
8000b7de:	fa c8 f9 40 	sub	r8,sp,-1728
8000b7e2:	04 9a       	mov	r10,r2
8000b7e4:	08 9c       	mov	r12,r4
8000b7e6:	fe b0 fb ab 	rcall	8000af3c <get_arg>
8000b7ea:	2f dd       	sub	sp,-12
8000b7ec:	78 1b       	ld.w	r11,r12[0x4]
8000b7ee:	78 09       	ld.w	r9,r12[0x0]
8000b7f0:	c2 b8       	rjmp	8000b846 <_vfprintf_r+0x5ce>
8000b7f2:	ee ca ff ff 	sub	r10,r7,-1
8000b7f6:	10 37       	cp.w	r7,r8
8000b7f8:	c0 b4       	brge	8000b80e <_vfprintf_r+0x596>
8000b7fa:	fa c9 f9 44 	sub	r9,sp,-1724
8000b7fe:	14 97       	mov	r7,r10
8000b800:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b804:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000b808:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000b80c:	c1 d8       	rjmp	8000b846 <_vfprintf_r+0x5ce>
8000b80e:	41 09       	lddsp	r9,sp[0x40]
8000b810:	59 f8       	cp.w	r8,31
8000b812:	e0 89 00 14 	brgt	8000b83a <_vfprintf_r+0x5c2>
8000b816:	f2 cb ff f8 	sub	r11,r9,-8
8000b81a:	51 0b       	stdsp	sp[0x40],r11
8000b81c:	fa c6 f9 44 	sub	r6,sp,-1724
8000b820:	72 1b       	ld.w	r11,r9[0x4]
8000b822:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000b826:	72 09       	ld.w	r9,r9[0x0]
8000b828:	f9 4b fd 8c 	st.w	r12[-628],r11
8000b82c:	f9 49 fd 88 	st.w	r12[-632],r9
8000b830:	2f f8       	sub	r8,-1
8000b832:	14 97       	mov	r7,r10
8000b834:	fb 48 06 b4 	st.w	sp[1716],r8
8000b838:	c0 78       	rjmp	8000b846 <_vfprintf_r+0x5ce>
8000b83a:	f2 c8 ff f8 	sub	r8,r9,-8
8000b83e:	72 1b       	ld.w	r11,r9[0x4]
8000b840:	14 97       	mov	r7,r10
8000b842:	51 08       	stdsp	sp[0x40],r8
8000b844:	72 09       	ld.w	r9,r9[0x0]
8000b846:	16 98       	mov	r8,r11
8000b848:	fa e9 00 00 	st.d	sp[0],r8
8000b84c:	ca e8       	rjmp	8000b9a8 <_vfprintf_r+0x730>
8000b84e:	ed b5 00 04 	bld	r5,0x4
8000b852:	c1 71       	brne	8000b880 <_vfprintf_r+0x608>
8000b854:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b858:	40 3e       	lddsp	lr,sp[0xc]
8000b85a:	58 0e       	cp.w	lr,0
8000b85c:	c0 80       	breq	8000b86c <_vfprintf_r+0x5f4>
8000b85e:	10 36       	cp.w	r6,r8
8000b860:	c6 94       	brge	8000b932 <_vfprintf_r+0x6ba>
8000b862:	fa cc f9 44 	sub	r12,sp,-1724
8000b866:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000b86a:	c8 28       	rjmp	8000b96e <_vfprintf_r+0x6f6>
8000b86c:	ee ca ff ff 	sub	r10,r7,-1
8000b870:	10 37       	cp.w	r7,r8
8000b872:	e0 84 00 81 	brge	8000b974 <_vfprintf_r+0x6fc>
8000b876:	fa cb f9 44 	sub	r11,sp,-1724
8000b87a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b87e:	c7 78       	rjmp	8000b96c <_vfprintf_r+0x6f4>
8000b880:	ed b5 00 06 	bld	r5,0x6
8000b884:	c4 b1       	brne	8000b91a <_vfprintf_r+0x6a2>
8000b886:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b88a:	40 3c       	lddsp	r12,sp[0xc]
8000b88c:	58 0c       	cp.w	r12,0
8000b88e:	c1 d0       	breq	8000b8c8 <_vfprintf_r+0x650>
8000b890:	10 36       	cp.w	r6,r8
8000b892:	c0 64       	brge	8000b89e <_vfprintf_r+0x626>
8000b894:	fa cb f9 44 	sub	r11,sp,-1724
8000b898:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b89c:	c1 f8       	rjmp	8000b8da <_vfprintf_r+0x662>
8000b89e:	fa c8 f9 50 	sub	r8,sp,-1712
8000b8a2:	1a d8       	st.w	--sp,r8
8000b8a4:	fa c8 fa b8 	sub	r8,sp,-1352
8000b8a8:	1a d8       	st.w	--sp,r8
8000b8aa:	fa c8 fb b4 	sub	r8,sp,-1100
8000b8ae:	1a d8       	st.w	--sp,r8
8000b8b0:	fa c8 f9 40 	sub	r8,sp,-1728
8000b8b4:	fa c9 ff b4 	sub	r9,sp,-76
8000b8b8:	04 9a       	mov	r10,r2
8000b8ba:	0c 9b       	mov	r11,r6
8000b8bc:	08 9c       	mov	r12,r4
8000b8be:	fe b0 fb 3f 	rcall	8000af3c <get_arg>
8000b8c2:	2f dd       	sub	sp,-12
8000b8c4:	98 18       	ld.sh	r8,r12[0x2]
8000b8c6:	c2 68       	rjmp	8000b912 <_vfprintf_r+0x69a>
8000b8c8:	ee ca ff ff 	sub	r10,r7,-1
8000b8cc:	10 37       	cp.w	r7,r8
8000b8ce:	c0 94       	brge	8000b8e0 <_vfprintf_r+0x668>
8000b8d0:	fa c9 f9 44 	sub	r9,sp,-1724
8000b8d4:	14 97       	mov	r7,r10
8000b8d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b8da:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000b8de:	c1 a8       	rjmp	8000b912 <_vfprintf_r+0x69a>
8000b8e0:	41 09       	lddsp	r9,sp[0x40]
8000b8e2:	59 f8       	cp.w	r8,31
8000b8e4:	e0 89 00 13 	brgt	8000b90a <_vfprintf_r+0x692>
8000b8e8:	f2 cb ff fc 	sub	r11,r9,-4
8000b8ec:	51 0b       	stdsp	sp[0x40],r11
8000b8ee:	72 09       	ld.w	r9,r9[0x0]
8000b8f0:	fa c6 f9 44 	sub	r6,sp,-1724
8000b8f4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000b8f8:	2f f8       	sub	r8,-1
8000b8fa:	f7 49 fd 88 	st.w	r11[-632],r9
8000b8fe:	fb 48 06 b4 	st.w	sp[1716],r8
8000b902:	14 97       	mov	r7,r10
8000b904:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000b908:	c0 58       	rjmp	8000b912 <_vfprintf_r+0x69a>
8000b90a:	92 18       	ld.sh	r8,r9[0x2]
8000b90c:	14 97       	mov	r7,r10
8000b90e:	2f c9       	sub	r9,-4
8000b910:	51 09       	stdsp	sp[0x40],r9
8000b912:	50 18       	stdsp	sp[0x4],r8
8000b914:	bf 58       	asr	r8,0x1f
8000b916:	50 08       	stdsp	sp[0x0],r8
8000b918:	c4 88       	rjmp	8000b9a8 <_vfprintf_r+0x730>
8000b91a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b91e:	40 3c       	lddsp	r12,sp[0xc]
8000b920:	58 0c       	cp.w	r12,0
8000b922:	c1 d0       	breq	8000b95c <_vfprintf_r+0x6e4>
8000b924:	10 36       	cp.w	r6,r8
8000b926:	c0 64       	brge	8000b932 <_vfprintf_r+0x6ba>
8000b928:	fa cb f9 44 	sub	r11,sp,-1724
8000b92c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000b930:	c1 f8       	rjmp	8000b96e <_vfprintf_r+0x6f6>
8000b932:	fa c8 f9 50 	sub	r8,sp,-1712
8000b936:	1a d8       	st.w	--sp,r8
8000b938:	fa c8 fa b8 	sub	r8,sp,-1352
8000b93c:	0c 9b       	mov	r11,r6
8000b93e:	1a d8       	st.w	--sp,r8
8000b940:	fa c8 fb b4 	sub	r8,sp,-1100
8000b944:	04 9a       	mov	r10,r2
8000b946:	1a d8       	st.w	--sp,r8
8000b948:	08 9c       	mov	r12,r4
8000b94a:	fa c8 f9 40 	sub	r8,sp,-1728
8000b94e:	fa c9 ff b4 	sub	r9,sp,-76
8000b952:	fe b0 fa f5 	rcall	8000af3c <get_arg>
8000b956:	2f dd       	sub	sp,-12
8000b958:	78 0b       	ld.w	r11,r12[0x0]
8000b95a:	c2 48       	rjmp	8000b9a2 <_vfprintf_r+0x72a>
8000b95c:	ee ca ff ff 	sub	r10,r7,-1
8000b960:	10 37       	cp.w	r7,r8
8000b962:	c0 94       	brge	8000b974 <_vfprintf_r+0x6fc>
8000b964:	fa c9 f9 44 	sub	r9,sp,-1724
8000b968:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000b96c:	14 97       	mov	r7,r10
8000b96e:	ec fb fd 88 	ld.w	r11,r6[-632]
8000b972:	c1 88       	rjmp	8000b9a2 <_vfprintf_r+0x72a>
8000b974:	41 09       	lddsp	r9,sp[0x40]
8000b976:	59 f8       	cp.w	r8,31
8000b978:	e0 89 00 11 	brgt	8000b99a <_vfprintf_r+0x722>
8000b97c:	f2 cb ff fc 	sub	r11,r9,-4
8000b980:	51 0b       	stdsp	sp[0x40],r11
8000b982:	fa c6 f9 44 	sub	r6,sp,-1724
8000b986:	72 0b       	ld.w	r11,r9[0x0]
8000b988:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000b98c:	f3 4b fd 88 	st.w	r9[-632],r11
8000b990:	2f f8       	sub	r8,-1
8000b992:	14 97       	mov	r7,r10
8000b994:	fb 48 06 b4 	st.w	sp[1716],r8
8000b998:	c0 58       	rjmp	8000b9a2 <_vfprintf_r+0x72a>
8000b99a:	72 0b       	ld.w	r11,r9[0x0]
8000b99c:	14 97       	mov	r7,r10
8000b99e:	2f c9       	sub	r9,-4
8000b9a0:	51 09       	stdsp	sp[0x40],r9
8000b9a2:	50 1b       	stdsp	sp[0x4],r11
8000b9a4:	bf 5b       	asr	r11,0x1f
8000b9a6:	50 0b       	stdsp	sp[0x0],r11
8000b9a8:	fa ea 00 00 	ld.d	r10,sp[0]
8000b9ac:	58 0a       	cp.w	r10,0
8000b9ae:	5c 2b       	cpc	r11
8000b9b0:	c0 e4       	brge	8000b9cc <_vfprintf_r+0x754>
8000b9b2:	30 08       	mov	r8,0
8000b9b4:	fa ea 00 00 	ld.d	r10,sp[0]
8000b9b8:	30 09       	mov	r9,0
8000b9ba:	f0 0a 01 0a 	sub	r10,r8,r10
8000b9be:	f2 0b 01 4b 	sbc	r11,r9,r11
8000b9c2:	32 d8       	mov	r8,45
8000b9c4:	fa eb 00 00 	st.d	sp[0],r10
8000b9c8:	fb 68 06 bb 	st.b	sp[1723],r8
8000b9cc:	30 18       	mov	r8,1
8000b9ce:	e0 8f 06 fe 	bral	8000c7ca <_vfprintf_r+0x1552>
8000b9d2:	50 a7       	stdsp	sp[0x28],r7
8000b9d4:	50 80       	stdsp	sp[0x20],r0
8000b9d6:	0c 97       	mov	r7,r6
8000b9d8:	04 94       	mov	r4,r2
8000b9da:	06 96       	mov	r6,r3
8000b9dc:	02 92       	mov	r2,r1
8000b9de:	40 93       	lddsp	r3,sp[0x24]
8000b9e0:	10 90       	mov	r0,r8
8000b9e2:	40 41       	lddsp	r1,sp[0x10]
8000b9e4:	0e 99       	mov	r9,r7
8000b9e6:	ed b5 00 03 	bld	r5,0x3
8000b9ea:	c4 11       	brne	8000ba6c <_vfprintf_r+0x7f4>
8000b9ec:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000b9f0:	40 3a       	lddsp	r10,sp[0xc]
8000b9f2:	58 0a       	cp.w	r10,0
8000b9f4:	c1 90       	breq	8000ba26 <_vfprintf_r+0x7ae>
8000b9f6:	10 36       	cp.w	r6,r8
8000b9f8:	c6 45       	brlt	8000bac0 <_vfprintf_r+0x848>
8000b9fa:	fa c8 f9 50 	sub	r8,sp,-1712
8000b9fe:	1a d8       	st.w	--sp,r8
8000ba00:	fa c8 fa b8 	sub	r8,sp,-1352
8000ba04:	1a d8       	st.w	--sp,r8
8000ba06:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba0a:	0c 9b       	mov	r11,r6
8000ba0c:	1a d8       	st.w	--sp,r8
8000ba0e:	04 9a       	mov	r10,r2
8000ba10:	fa c8 f9 40 	sub	r8,sp,-1728
8000ba14:	fa c9 ff b4 	sub	r9,sp,-76
8000ba18:	08 9c       	mov	r12,r4
8000ba1a:	fe b0 fa 91 	rcall	8000af3c <get_arg>
8000ba1e:	2f dd       	sub	sp,-12
8000ba20:	78 16       	ld.w	r6,r12[0x4]
8000ba22:	50 76       	stdsp	sp[0x1c],r6
8000ba24:	c4 88       	rjmp	8000bab4 <_vfprintf_r+0x83c>
8000ba26:	2f f7       	sub	r7,-1
8000ba28:	10 39       	cp.w	r9,r8
8000ba2a:	c0 c4       	brge	8000ba42 <_vfprintf_r+0x7ca>
8000ba2c:	fa ce f9 44 	sub	lr,sp,-1724
8000ba30:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000ba34:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000ba38:	50 7c       	stdsp	sp[0x1c],r12
8000ba3a:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000ba3e:	50 56       	stdsp	sp[0x14],r6
8000ba40:	c6 68       	rjmp	8000bb0c <_vfprintf_r+0x894>
8000ba42:	41 09       	lddsp	r9,sp[0x40]
8000ba44:	59 f8       	cp.w	r8,31
8000ba46:	e0 89 00 10 	brgt	8000ba66 <_vfprintf_r+0x7ee>
8000ba4a:	f2 ca ff f8 	sub	r10,r9,-8
8000ba4e:	72 1b       	ld.w	r11,r9[0x4]
8000ba50:	51 0a       	stdsp	sp[0x40],r10
8000ba52:	72 09       	ld.w	r9,r9[0x0]
8000ba54:	fa ca f9 44 	sub	r10,sp,-1724
8000ba58:	50 7b       	stdsp	sp[0x1c],r11
8000ba5a:	50 59       	stdsp	sp[0x14],r9
8000ba5c:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000ba60:	40 5b       	lddsp	r11,sp[0x14]
8000ba62:	40 7a       	lddsp	r10,sp[0x1c]
8000ba64:	c4 78       	rjmp	8000baf2 <_vfprintf_r+0x87a>
8000ba66:	72 18       	ld.w	r8,r9[0x4]
8000ba68:	50 78       	stdsp	sp[0x1c],r8
8000ba6a:	c4 c8       	rjmp	8000bb02 <_vfprintf_r+0x88a>
8000ba6c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ba70:	40 3e       	lddsp	lr,sp[0xc]
8000ba72:	58 0e       	cp.w	lr,0
8000ba74:	c2 30       	breq	8000baba <_vfprintf_r+0x842>
8000ba76:	10 36       	cp.w	r6,r8
8000ba78:	c0 94       	brge	8000ba8a <_vfprintf_r+0x812>
8000ba7a:	fa cc f9 44 	sub	r12,sp,-1724
8000ba7e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000ba82:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000ba86:	50 7b       	stdsp	sp[0x1c],r11
8000ba88:	cd 9b       	rjmp	8000ba3a <_vfprintf_r+0x7c2>
8000ba8a:	fa c8 f9 50 	sub	r8,sp,-1712
8000ba8e:	1a d8       	st.w	--sp,r8
8000ba90:	fa c8 fa b8 	sub	r8,sp,-1352
8000ba94:	04 9a       	mov	r10,r2
8000ba96:	1a d8       	st.w	--sp,r8
8000ba98:	fa c8 fb b4 	sub	r8,sp,-1100
8000ba9c:	0c 9b       	mov	r11,r6
8000ba9e:	1a d8       	st.w	--sp,r8
8000baa0:	08 9c       	mov	r12,r4
8000baa2:	fa c8 f9 40 	sub	r8,sp,-1728
8000baa6:	fa c9 ff b4 	sub	r9,sp,-76
8000baaa:	fe b0 fa 49 	rcall	8000af3c <get_arg>
8000baae:	2f dd       	sub	sp,-12
8000bab0:	78 1a       	ld.w	r10,r12[0x4]
8000bab2:	50 7a       	stdsp	sp[0x1c],r10
8000bab4:	78 0c       	ld.w	r12,r12[0x0]
8000bab6:	50 5c       	stdsp	sp[0x14],r12
8000bab8:	c2 a8       	rjmp	8000bb0c <_vfprintf_r+0x894>
8000baba:	2f f7       	sub	r7,-1
8000babc:	10 39       	cp.w	r9,r8
8000babe:	c0 94       	brge	8000bad0 <_vfprintf_r+0x858>
8000bac0:	fa c9 f9 44 	sub	r9,sp,-1724
8000bac4:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bac8:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000bacc:	50 78       	stdsp	sp[0x1c],r8
8000bace:	cb 6b       	rjmp	8000ba3a <_vfprintf_r+0x7c2>
8000bad0:	41 09       	lddsp	r9,sp[0x40]
8000bad2:	59 f8       	cp.w	r8,31
8000bad4:	e0 89 00 15 	brgt	8000bafe <_vfprintf_r+0x886>
8000bad8:	f2 ca ff f8 	sub	r10,r9,-8
8000badc:	72 16       	ld.w	r6,r9[0x4]
8000bade:	72 09       	ld.w	r9,r9[0x0]
8000bae0:	51 0a       	stdsp	sp[0x40],r10
8000bae2:	50 59       	stdsp	sp[0x14],r9
8000bae4:	fa ce f9 44 	sub	lr,sp,-1724
8000bae8:	50 76       	stdsp	sp[0x1c],r6
8000baea:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000baee:	40 5b       	lddsp	r11,sp[0x14]
8000baf0:	0c 9a       	mov	r10,r6
8000baf2:	f2 eb fd 88 	st.d	r9[-632],r10
8000baf6:	2f f8       	sub	r8,-1
8000baf8:	fb 48 06 b4 	st.w	sp[1716],r8
8000bafc:	c0 88       	rjmp	8000bb0c <_vfprintf_r+0x894>
8000bafe:	72 1c       	ld.w	r12,r9[0x4]
8000bb00:	50 7c       	stdsp	sp[0x1c],r12
8000bb02:	f2 c8 ff f8 	sub	r8,r9,-8
8000bb06:	51 08       	stdsp	sp[0x40],r8
8000bb08:	72 09       	ld.w	r9,r9[0x0]
8000bb0a:	50 59       	stdsp	sp[0x14],r9
8000bb0c:	40 5b       	lddsp	r11,sp[0x14]
8000bb0e:	40 7a       	lddsp	r10,sp[0x1c]
8000bb10:	e0 a0 19 64 	rcall	8000edd8 <__isinfd>
8000bb14:	18 96       	mov	r6,r12
8000bb16:	c1 50       	breq	8000bb40 <_vfprintf_r+0x8c8>
8000bb18:	30 08       	mov	r8,0
8000bb1a:	30 09       	mov	r9,0
8000bb1c:	40 5b       	lddsp	r11,sp[0x14]
8000bb1e:	40 7a       	lddsp	r10,sp[0x1c]
8000bb20:	e0 a0 1d ba 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000bb24:	c0 40       	breq	8000bb2c <_vfprintf_r+0x8b4>
8000bb26:	32 d8       	mov	r8,45
8000bb28:	fb 68 06 bb 	st.b	sp[1723],r8
8000bb2c:	4d 18       	lddpc	r8,8000bc70 <_vfprintf_r+0x9f8>
8000bb2e:	4d 26       	lddpc	r6,8000bc74 <_vfprintf_r+0x9fc>
8000bb30:	a7 d5       	cbr	r5,0x7
8000bb32:	e0 40 00 47 	cp.w	r0,71
8000bb36:	f0 06 17 a0 	movle	r6,r8
8000bb3a:	30 32       	mov	r2,3
8000bb3c:	e0 8f 06 d4 	bral	8000c8e4 <_vfprintf_r+0x166c>
8000bb40:	40 5b       	lddsp	r11,sp[0x14]
8000bb42:	40 7a       	lddsp	r10,sp[0x1c]
8000bb44:	e0 a0 19 5f 	rcall	8000ee02 <__isnand>
8000bb48:	c0 c0       	breq	8000bb60 <_vfprintf_r+0x8e8>
8000bb4a:	50 26       	stdsp	sp[0x8],r6
8000bb4c:	4c b8       	lddpc	r8,8000bc78 <_vfprintf_r+0xa00>
8000bb4e:	4c c6       	lddpc	r6,8000bc7c <_vfprintf_r+0xa04>
8000bb50:	a7 d5       	cbr	r5,0x7
8000bb52:	e0 40 00 47 	cp.w	r0,71
8000bb56:	f0 06 17 a0 	movle	r6,r8
8000bb5a:	30 32       	mov	r2,3
8000bb5c:	e0 8f 06 ca 	bral	8000c8f0 <_vfprintf_r+0x1678>
8000bb60:	40 2a       	lddsp	r10,sp[0x8]
8000bb62:	5b fa       	cp.w	r10,-1
8000bb64:	c0 41       	brne	8000bb6c <_vfprintf_r+0x8f4>
8000bb66:	30 69       	mov	r9,6
8000bb68:	50 29       	stdsp	sp[0x8],r9
8000bb6a:	c1 18       	rjmp	8000bb8c <_vfprintf_r+0x914>
8000bb6c:	e0 40 00 47 	cp.w	r0,71
8000bb70:	5f 09       	sreq	r9
8000bb72:	e0 40 00 67 	cp.w	r0,103
8000bb76:	5f 08       	sreq	r8
8000bb78:	f3 e8 10 08 	or	r8,r9,r8
8000bb7c:	f8 08 18 00 	cp.b	r8,r12
8000bb80:	c0 60       	breq	8000bb8c <_vfprintf_r+0x914>
8000bb82:	40 28       	lddsp	r8,sp[0x8]
8000bb84:	58 08       	cp.w	r8,0
8000bb86:	f9 b8 00 01 	moveq	r8,1
8000bb8a:	50 28       	stdsp	sp[0x8],r8
8000bb8c:	40 78       	lddsp	r8,sp[0x1c]
8000bb8e:	40 59       	lddsp	r9,sp[0x14]
8000bb90:	fa e9 06 94 	st.d	sp[1684],r8
8000bb94:	a9 a5       	sbr	r5,0x8
8000bb96:	fa f8 06 94 	ld.w	r8,sp[1684]
8000bb9a:	58 08       	cp.w	r8,0
8000bb9c:	c0 65       	brlt	8000bba8 <_vfprintf_r+0x930>
8000bb9e:	40 5e       	lddsp	lr,sp[0x14]
8000bba0:	30 0c       	mov	r12,0
8000bba2:	50 6e       	stdsp	sp[0x18],lr
8000bba4:	50 9c       	stdsp	sp[0x24],r12
8000bba6:	c0 78       	rjmp	8000bbb4 <_vfprintf_r+0x93c>
8000bba8:	40 5b       	lddsp	r11,sp[0x14]
8000bbaa:	32 da       	mov	r10,45
8000bbac:	ee 1b 80 00 	eorh	r11,0x8000
8000bbb0:	50 9a       	stdsp	sp[0x24],r10
8000bbb2:	50 6b       	stdsp	sp[0x18],r11
8000bbb4:	e0 40 00 46 	cp.w	r0,70
8000bbb8:	5f 09       	sreq	r9
8000bbba:	e0 40 00 66 	cp.w	r0,102
8000bbbe:	5f 08       	sreq	r8
8000bbc0:	f3 e8 10 08 	or	r8,r9,r8
8000bbc4:	50 48       	stdsp	sp[0x10],r8
8000bbc6:	c0 40       	breq	8000bbce <_vfprintf_r+0x956>
8000bbc8:	40 22       	lddsp	r2,sp[0x8]
8000bbca:	30 39       	mov	r9,3
8000bbcc:	c1 08       	rjmp	8000bbec <_vfprintf_r+0x974>
8000bbce:	e0 40 00 45 	cp.w	r0,69
8000bbd2:	5f 09       	sreq	r9
8000bbd4:	e0 40 00 65 	cp.w	r0,101
8000bbd8:	5f 08       	sreq	r8
8000bbda:	40 22       	lddsp	r2,sp[0x8]
8000bbdc:	10 49       	or	r9,r8
8000bbde:	2f f2       	sub	r2,-1
8000bbe0:	40 46       	lddsp	r6,sp[0x10]
8000bbe2:	ec 09 18 00 	cp.b	r9,r6
8000bbe6:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000bbea:	30 29       	mov	r9,2
8000bbec:	fa c8 f9 5c 	sub	r8,sp,-1700
8000bbf0:	1a d8       	st.w	--sp,r8
8000bbf2:	fa c8 f9 54 	sub	r8,sp,-1708
8000bbf6:	1a d8       	st.w	--sp,r8
8000bbf8:	fa c8 f9 4c 	sub	r8,sp,-1716
8000bbfc:	08 9c       	mov	r12,r4
8000bbfe:	1a d8       	st.w	--sp,r8
8000bc00:	04 98       	mov	r8,r2
8000bc02:	40 9b       	lddsp	r11,sp[0x24]
8000bc04:	40 aa       	lddsp	r10,sp[0x28]
8000bc06:	e0 a0 0b cf 	rcall	8000d3a4 <_dtoa_r>
8000bc0a:	e0 40 00 47 	cp.w	r0,71
8000bc0e:	5f 19       	srne	r9
8000bc10:	e0 40 00 67 	cp.w	r0,103
8000bc14:	5f 18       	srne	r8
8000bc16:	18 96       	mov	r6,r12
8000bc18:	2f dd       	sub	sp,-12
8000bc1a:	f3 e8 00 08 	and	r8,r9,r8
8000bc1e:	c0 41       	brne	8000bc26 <_vfprintf_r+0x9ae>
8000bc20:	ed b5 00 00 	bld	r5,0x0
8000bc24:	c3 81       	brne	8000bc94 <_vfprintf_r+0xa1c>
8000bc26:	ec 02 00 0e 	add	lr,r6,r2
8000bc2a:	50 3e       	stdsp	sp[0xc],lr
8000bc2c:	40 4c       	lddsp	r12,sp[0x10]
8000bc2e:	58 0c       	cp.w	r12,0
8000bc30:	c1 50       	breq	8000bc5a <_vfprintf_r+0x9e2>
8000bc32:	0d 89       	ld.ub	r9,r6[0x0]
8000bc34:	33 08       	mov	r8,48
8000bc36:	f0 09 18 00 	cp.b	r9,r8
8000bc3a:	c0 b1       	brne	8000bc50 <_vfprintf_r+0x9d8>
8000bc3c:	30 08       	mov	r8,0
8000bc3e:	30 09       	mov	r9,0
8000bc40:	40 6b       	lddsp	r11,sp[0x18]
8000bc42:	40 7a       	lddsp	r10,sp[0x1c]
8000bc44:	e0 a0 1c e1 	rcall	8000f606 <__avr32_f64_cmp_eq>
8000bc48:	fb b2 00 01 	rsubeq	r2,1
8000bc4c:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000bc50:	40 3b       	lddsp	r11,sp[0xc]
8000bc52:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000bc56:	10 0b       	add	r11,r8
8000bc58:	50 3b       	stdsp	sp[0xc],r11
8000bc5a:	40 6b       	lddsp	r11,sp[0x18]
8000bc5c:	30 08       	mov	r8,0
8000bc5e:	30 09       	mov	r9,0
8000bc60:	40 7a       	lddsp	r10,sp[0x1c]
8000bc62:	e0 a0 1c d2 	rcall	8000f606 <__avr32_f64_cmp_eq>
8000bc66:	c1 10       	breq	8000bc88 <_vfprintf_r+0xa10>
8000bc68:	40 3a       	lddsp	r10,sp[0xc]
8000bc6a:	fb 4a 06 a4 	st.w	sp[1700],r10
8000bc6e:	c0 d8       	rjmp	8000bc88 <_vfprintf_r+0xa10>
8000bc70:	80 01       	ld.sh	r1,r0[0x0]
8000bc72:	9b 38       	st.w	sp[0xc],r8
8000bc74:	80 01       	ld.sh	r1,r0[0x0]
8000bc76:	9b 3c       	st.w	sp[0xc],r12
8000bc78:	80 01       	ld.sh	r1,r0[0x0]
8000bc7a:	9b 40       	st.w	sp[0x10],r0
8000bc7c:	80 01       	ld.sh	r1,r0[0x0]
8000bc7e:	9b 44       	st.w	sp[0x10],r4
8000bc80:	10 c9       	st.b	r8++,r9
8000bc82:	fb 48 06 a4 	st.w	sp[1700],r8
8000bc86:	c0 28       	rjmp	8000bc8a <_vfprintf_r+0xa12>
8000bc88:	33 09       	mov	r9,48
8000bc8a:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000bc8e:	40 3e       	lddsp	lr,sp[0xc]
8000bc90:	1c 38       	cp.w	r8,lr
8000bc92:	cf 73       	brcs	8000bc80 <_vfprintf_r+0xa08>
8000bc94:	e0 40 00 47 	cp.w	r0,71
8000bc98:	5f 09       	sreq	r9
8000bc9a:	e0 40 00 67 	cp.w	r0,103
8000bc9e:	5f 08       	sreq	r8
8000bca0:	f3 e8 10 08 	or	r8,r9,r8
8000bca4:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000bca8:	0c 19       	sub	r9,r6
8000bcaa:	50 69       	stdsp	sp[0x18],r9
8000bcac:	58 08       	cp.w	r8,0
8000bcae:	c0 b0       	breq	8000bcc4 <_vfprintf_r+0xa4c>
8000bcb0:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000bcb4:	5b d8       	cp.w	r8,-3
8000bcb6:	c0 55       	brlt	8000bcc0 <_vfprintf_r+0xa48>
8000bcb8:	40 2c       	lddsp	r12,sp[0x8]
8000bcba:	18 38       	cp.w	r8,r12
8000bcbc:	e0 8a 00 6a 	brle	8000bd90 <_vfprintf_r+0xb18>
8000bcc0:	20 20       	sub	r0,2
8000bcc2:	c0 58       	rjmp	8000bccc <_vfprintf_r+0xa54>
8000bcc4:	e0 40 00 65 	cp.w	r0,101
8000bcc8:	e0 89 00 46 	brgt	8000bd54 <_vfprintf_r+0xadc>
8000bccc:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000bcd0:	fb 60 06 9c 	st.b	sp[1692],r0
8000bcd4:	20 1b       	sub	r11,1
8000bcd6:	fb 4b 06 ac 	st.w	sp[1708],r11
8000bcda:	c0 47       	brpl	8000bce2 <_vfprintf_r+0xa6a>
8000bcdc:	5c 3b       	neg	r11
8000bcde:	32 d8       	mov	r8,45
8000bce0:	c0 28       	rjmp	8000bce4 <_vfprintf_r+0xa6c>
8000bce2:	32 b8       	mov	r8,43
8000bce4:	fb 68 06 9d 	st.b	sp[1693],r8
8000bce8:	58 9b       	cp.w	r11,9
8000bcea:	e0 8a 00 1d 	brle	8000bd24 <_vfprintf_r+0xaac>
8000bcee:	fa c9 fa 35 	sub	r9,sp,-1483
8000bcf2:	30 aa       	mov	r10,10
8000bcf4:	12 98       	mov	r8,r9
8000bcf6:	0e 9c       	mov	r12,r7
8000bcf8:	0c 92       	mov	r2,r6
8000bcfa:	f6 0a 0c 06 	divs	r6,r11,r10
8000bcfe:	0e 9b       	mov	r11,r7
8000bd00:	2d 0b       	sub	r11,-48
8000bd02:	10 fb       	st.b	--r8,r11
8000bd04:	0c 9b       	mov	r11,r6
8000bd06:	58 96       	cp.w	r6,9
8000bd08:	fe 99 ff f9 	brgt	8000bcfa <_vfprintf_r+0xa82>
8000bd0c:	2d 0b       	sub	r11,-48
8000bd0e:	18 97       	mov	r7,r12
8000bd10:	04 96       	mov	r6,r2
8000bd12:	10 fb       	st.b	--r8,r11
8000bd14:	fa ca f9 62 	sub	r10,sp,-1694
8000bd18:	c0 38       	rjmp	8000bd1e <_vfprintf_r+0xaa6>
8000bd1a:	11 3b       	ld.ub	r11,r8++
8000bd1c:	14 cb       	st.b	r10++,r11
8000bd1e:	12 38       	cp.w	r8,r9
8000bd20:	cf d3       	brcs	8000bd1a <_vfprintf_r+0xaa2>
8000bd22:	c0 98       	rjmp	8000bd34 <_vfprintf_r+0xabc>
8000bd24:	2d 0b       	sub	r11,-48
8000bd26:	33 08       	mov	r8,48
8000bd28:	fb 6b 06 9f 	st.b	sp[1695],r11
8000bd2c:	fb 68 06 9e 	st.b	sp[1694],r8
8000bd30:	fa ca f9 60 	sub	r10,sp,-1696
8000bd34:	fa c8 f9 64 	sub	r8,sp,-1692
8000bd38:	f4 08 01 08 	sub	r8,r10,r8
8000bd3c:	50 e8       	stdsp	sp[0x38],r8
8000bd3e:	10 92       	mov	r2,r8
8000bd40:	40 6b       	lddsp	r11,sp[0x18]
8000bd42:	16 02       	add	r2,r11
8000bd44:	58 1b       	cp.w	r11,1
8000bd46:	e0 89 00 05 	brgt	8000bd50 <_vfprintf_r+0xad8>
8000bd4a:	ed b5 00 00 	bld	r5,0x0
8000bd4e:	c3 51       	brne	8000bdb8 <_vfprintf_r+0xb40>
8000bd50:	2f f2       	sub	r2,-1
8000bd52:	c3 38       	rjmp	8000bdb8 <_vfprintf_r+0xb40>
8000bd54:	e0 40 00 66 	cp.w	r0,102
8000bd58:	c1 c1       	brne	8000bd90 <_vfprintf_r+0xb18>
8000bd5a:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000bd5e:	58 02       	cp.w	r2,0
8000bd60:	e0 8a 00 0c 	brle	8000bd78 <_vfprintf_r+0xb00>
8000bd64:	40 2a       	lddsp	r10,sp[0x8]
8000bd66:	58 0a       	cp.w	r10,0
8000bd68:	c0 41       	brne	8000bd70 <_vfprintf_r+0xaf8>
8000bd6a:	ed b5 00 00 	bld	r5,0x0
8000bd6e:	c2 51       	brne	8000bdb8 <_vfprintf_r+0xb40>
8000bd70:	2f f2       	sub	r2,-1
8000bd72:	40 29       	lddsp	r9,sp[0x8]
8000bd74:	12 02       	add	r2,r9
8000bd76:	c0 b8       	rjmp	8000bd8c <_vfprintf_r+0xb14>
8000bd78:	40 28       	lddsp	r8,sp[0x8]
8000bd7a:	58 08       	cp.w	r8,0
8000bd7c:	c0 61       	brne	8000bd88 <_vfprintf_r+0xb10>
8000bd7e:	ed b5 00 00 	bld	r5,0x0
8000bd82:	c0 30       	breq	8000bd88 <_vfprintf_r+0xb10>
8000bd84:	30 12       	mov	r2,1
8000bd86:	c1 98       	rjmp	8000bdb8 <_vfprintf_r+0xb40>
8000bd88:	40 22       	lddsp	r2,sp[0x8]
8000bd8a:	2f e2       	sub	r2,-2
8000bd8c:	36 60       	mov	r0,102
8000bd8e:	c1 58       	rjmp	8000bdb8 <_vfprintf_r+0xb40>
8000bd90:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000bd94:	40 6e       	lddsp	lr,sp[0x18]
8000bd96:	1c 32       	cp.w	r2,lr
8000bd98:	c0 65       	brlt	8000bda4 <_vfprintf_r+0xb2c>
8000bd9a:	ed b5 00 00 	bld	r5,0x0
8000bd9e:	f7 b2 00 ff 	subeq	r2,-1
8000bda2:	c0 a8       	rjmp	8000bdb6 <_vfprintf_r+0xb3e>
8000bda4:	e4 08 11 02 	rsub	r8,r2,2
8000bda8:	40 6c       	lddsp	r12,sp[0x18]
8000bdaa:	58 02       	cp.w	r2,0
8000bdac:	f0 02 17 a0 	movle	r2,r8
8000bdb0:	f9 b2 09 01 	movgt	r2,1
8000bdb4:	18 02       	add	r2,r12
8000bdb6:	36 70       	mov	r0,103
8000bdb8:	40 9b       	lddsp	r11,sp[0x24]
8000bdba:	58 0b       	cp.w	r11,0
8000bdbc:	e0 80 05 94 	breq	8000c8e4 <_vfprintf_r+0x166c>
8000bdc0:	32 d8       	mov	r8,45
8000bdc2:	fb 68 06 bb 	st.b	sp[1723],r8
8000bdc6:	e0 8f 05 93 	bral	8000c8ec <_vfprintf_r+0x1674>
8000bdca:	50 a7       	stdsp	sp[0x28],r7
8000bdcc:	04 94       	mov	r4,r2
8000bdce:	0c 97       	mov	r7,r6
8000bdd0:	02 92       	mov	r2,r1
8000bdd2:	06 96       	mov	r6,r3
8000bdd4:	40 41       	lddsp	r1,sp[0x10]
8000bdd6:	40 93       	lddsp	r3,sp[0x24]
8000bdd8:	0e 99       	mov	r9,r7
8000bdda:	ed b5 00 05 	bld	r5,0x5
8000bdde:	c4 81       	brne	8000be6e <_vfprintf_r+0xbf6>
8000bde0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bde4:	40 3e       	lddsp	lr,sp[0xc]
8000bde6:	58 0e       	cp.w	lr,0
8000bde8:	c1 d0       	breq	8000be22 <_vfprintf_r+0xbaa>
8000bdea:	10 36       	cp.w	r6,r8
8000bdec:	c0 64       	brge	8000bdf8 <_vfprintf_r+0xb80>
8000bdee:	fa cc f9 44 	sub	r12,sp,-1724
8000bdf2:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bdf6:	c1 d8       	rjmp	8000be30 <_vfprintf_r+0xbb8>
8000bdf8:	fa c8 f9 50 	sub	r8,sp,-1712
8000bdfc:	1a d8       	st.w	--sp,r8
8000bdfe:	fa c8 fa b8 	sub	r8,sp,-1352
8000be02:	04 9a       	mov	r10,r2
8000be04:	1a d8       	st.w	--sp,r8
8000be06:	fa c8 fb b4 	sub	r8,sp,-1100
8000be0a:	0c 9b       	mov	r11,r6
8000be0c:	1a d8       	st.w	--sp,r8
8000be0e:	08 9c       	mov	r12,r4
8000be10:	fa c8 f9 40 	sub	r8,sp,-1728
8000be14:	fa c9 ff b4 	sub	r9,sp,-76
8000be18:	fe b0 f8 92 	rcall	8000af3c <get_arg>
8000be1c:	2f dd       	sub	sp,-12
8000be1e:	78 0a       	ld.w	r10,r12[0x0]
8000be20:	c2 08       	rjmp	8000be60 <_vfprintf_r+0xbe8>
8000be22:	2f f7       	sub	r7,-1
8000be24:	10 39       	cp.w	r9,r8
8000be26:	c0 84       	brge	8000be36 <_vfprintf_r+0xbbe>
8000be28:	fa cb f9 44 	sub	r11,sp,-1724
8000be2c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000be30:	ec fa fd 88 	ld.w	r10,r6[-632]
8000be34:	c1 68       	rjmp	8000be60 <_vfprintf_r+0xbe8>
8000be36:	41 09       	lddsp	r9,sp[0x40]
8000be38:	59 f8       	cp.w	r8,31
8000be3a:	e0 89 00 10 	brgt	8000be5a <_vfprintf_r+0xbe2>
8000be3e:	f2 ca ff fc 	sub	r10,r9,-4
8000be42:	51 0a       	stdsp	sp[0x40],r10
8000be44:	fa c6 f9 44 	sub	r6,sp,-1724
8000be48:	72 0a       	ld.w	r10,r9[0x0]
8000be4a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000be4e:	f3 4a fd 88 	st.w	r9[-632],r10
8000be52:	2f f8       	sub	r8,-1
8000be54:	fb 48 06 b4 	st.w	sp[1716],r8
8000be58:	c0 48       	rjmp	8000be60 <_vfprintf_r+0xbe8>
8000be5a:	72 0a       	ld.w	r10,r9[0x0]
8000be5c:	2f c9       	sub	r9,-4
8000be5e:	51 09       	stdsp	sp[0x40],r9
8000be60:	40 be       	lddsp	lr,sp[0x2c]
8000be62:	1c 98       	mov	r8,lr
8000be64:	95 1e       	st.w	r10[0x4],lr
8000be66:	bf 58       	asr	r8,0x1f
8000be68:	95 08       	st.w	r10[0x0],r8
8000be6a:	fe 9f fa 92 	bral	8000b38e <_vfprintf_r+0x116>
8000be6e:	ed b5 00 04 	bld	r5,0x4
8000be72:	c4 80       	breq	8000bf02 <_vfprintf_r+0xc8a>
8000be74:	e2 15 00 40 	andl	r5,0x40,COH
8000be78:	c4 50       	breq	8000bf02 <_vfprintf_r+0xc8a>
8000be7a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000be7e:	40 3c       	lddsp	r12,sp[0xc]
8000be80:	58 0c       	cp.w	r12,0
8000be82:	c1 d0       	breq	8000bebc <_vfprintf_r+0xc44>
8000be84:	10 36       	cp.w	r6,r8
8000be86:	c0 64       	brge	8000be92 <_vfprintf_r+0xc1a>
8000be88:	fa cb f9 44 	sub	r11,sp,-1724
8000be8c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000be90:	c1 d8       	rjmp	8000beca <_vfprintf_r+0xc52>
8000be92:	fa c8 f9 50 	sub	r8,sp,-1712
8000be96:	1a d8       	st.w	--sp,r8
8000be98:	fa c8 fa b8 	sub	r8,sp,-1352
8000be9c:	04 9a       	mov	r10,r2
8000be9e:	1a d8       	st.w	--sp,r8
8000bea0:	fa c8 fb b4 	sub	r8,sp,-1100
8000bea4:	0c 9b       	mov	r11,r6
8000bea6:	1a d8       	st.w	--sp,r8
8000bea8:	08 9c       	mov	r12,r4
8000beaa:	fa c8 f9 40 	sub	r8,sp,-1728
8000beae:	fa c9 ff b4 	sub	r9,sp,-76
8000beb2:	fe b0 f8 45 	rcall	8000af3c <get_arg>
8000beb6:	2f dd       	sub	sp,-12
8000beb8:	78 0a       	ld.w	r10,r12[0x0]
8000beba:	c2 08       	rjmp	8000befa <_vfprintf_r+0xc82>
8000bebc:	2f f7       	sub	r7,-1
8000bebe:	10 39       	cp.w	r9,r8
8000bec0:	c0 84       	brge	8000bed0 <_vfprintf_r+0xc58>
8000bec2:	fa ca f9 44 	sub	r10,sp,-1724
8000bec6:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000beca:	ec fa fd 88 	ld.w	r10,r6[-632]
8000bece:	c1 68       	rjmp	8000befa <_vfprintf_r+0xc82>
8000bed0:	41 09       	lddsp	r9,sp[0x40]
8000bed2:	59 f8       	cp.w	r8,31
8000bed4:	e0 89 00 10 	brgt	8000bef4 <_vfprintf_r+0xc7c>
8000bed8:	f2 ca ff fc 	sub	r10,r9,-4
8000bedc:	51 0a       	stdsp	sp[0x40],r10
8000bede:	fa c6 f9 44 	sub	r6,sp,-1724
8000bee2:	72 0a       	ld.w	r10,r9[0x0]
8000bee4:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bee8:	f3 4a fd 88 	st.w	r9[-632],r10
8000beec:	2f f8       	sub	r8,-1
8000beee:	fb 48 06 b4 	st.w	sp[1716],r8
8000bef2:	c0 48       	rjmp	8000befa <_vfprintf_r+0xc82>
8000bef4:	72 0a       	ld.w	r10,r9[0x0]
8000bef6:	2f c9       	sub	r9,-4
8000bef8:	51 09       	stdsp	sp[0x40],r9
8000befa:	40 be       	lddsp	lr,sp[0x2c]
8000befc:	b4 0e       	st.h	r10[0x0],lr
8000befe:	fe 9f fa 48 	bral	8000b38e <_vfprintf_r+0x116>
8000bf02:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bf06:	40 3c       	lddsp	r12,sp[0xc]
8000bf08:	58 0c       	cp.w	r12,0
8000bf0a:	c1 d0       	breq	8000bf44 <_vfprintf_r+0xccc>
8000bf0c:	10 36       	cp.w	r6,r8
8000bf0e:	c0 64       	brge	8000bf1a <_vfprintf_r+0xca2>
8000bf10:	fa cb f9 44 	sub	r11,sp,-1724
8000bf14:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bf18:	c1 d8       	rjmp	8000bf52 <_vfprintf_r+0xcda>
8000bf1a:	fa c8 f9 50 	sub	r8,sp,-1712
8000bf1e:	1a d8       	st.w	--sp,r8
8000bf20:	fa c8 fa b8 	sub	r8,sp,-1352
8000bf24:	04 9a       	mov	r10,r2
8000bf26:	1a d8       	st.w	--sp,r8
8000bf28:	fa c8 fb b4 	sub	r8,sp,-1100
8000bf2c:	0c 9b       	mov	r11,r6
8000bf2e:	1a d8       	st.w	--sp,r8
8000bf30:	08 9c       	mov	r12,r4
8000bf32:	fa c8 f9 40 	sub	r8,sp,-1728
8000bf36:	fa c9 ff b4 	sub	r9,sp,-76
8000bf3a:	fe b0 f8 01 	rcall	8000af3c <get_arg>
8000bf3e:	2f dd       	sub	sp,-12
8000bf40:	78 0a       	ld.w	r10,r12[0x0]
8000bf42:	c2 08       	rjmp	8000bf82 <_vfprintf_r+0xd0a>
8000bf44:	2f f7       	sub	r7,-1
8000bf46:	10 39       	cp.w	r9,r8
8000bf48:	c0 84       	brge	8000bf58 <_vfprintf_r+0xce0>
8000bf4a:	fa ca f9 44 	sub	r10,sp,-1724
8000bf4e:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bf52:	ec fa fd 88 	ld.w	r10,r6[-632]
8000bf56:	c1 68       	rjmp	8000bf82 <_vfprintf_r+0xd0a>
8000bf58:	41 09       	lddsp	r9,sp[0x40]
8000bf5a:	59 f8       	cp.w	r8,31
8000bf5c:	e0 89 00 10 	brgt	8000bf7c <_vfprintf_r+0xd04>
8000bf60:	f2 ca ff fc 	sub	r10,r9,-4
8000bf64:	51 0a       	stdsp	sp[0x40],r10
8000bf66:	fa c6 f9 44 	sub	r6,sp,-1724
8000bf6a:	72 0a       	ld.w	r10,r9[0x0]
8000bf6c:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000bf70:	f3 4a fd 88 	st.w	r9[-632],r10
8000bf74:	2f f8       	sub	r8,-1
8000bf76:	fb 48 06 b4 	st.w	sp[1716],r8
8000bf7a:	c0 48       	rjmp	8000bf82 <_vfprintf_r+0xd0a>
8000bf7c:	72 0a       	ld.w	r10,r9[0x0]
8000bf7e:	2f c9       	sub	r9,-4
8000bf80:	51 09       	stdsp	sp[0x40],r9
8000bf82:	40 be       	lddsp	lr,sp[0x2c]
8000bf84:	95 0e       	st.w	r10[0x0],lr
8000bf86:	fe 9f fa 04 	bral	8000b38e <_vfprintf_r+0x116>
8000bf8a:	50 a7       	stdsp	sp[0x28],r7
8000bf8c:	50 80       	stdsp	sp[0x20],r0
8000bf8e:	0c 97       	mov	r7,r6
8000bf90:	04 94       	mov	r4,r2
8000bf92:	06 96       	mov	r6,r3
8000bf94:	02 92       	mov	r2,r1
8000bf96:	40 93       	lddsp	r3,sp[0x24]
8000bf98:	10 90       	mov	r0,r8
8000bf9a:	40 41       	lddsp	r1,sp[0x10]
8000bf9c:	a5 a5       	sbr	r5,0x4
8000bf9e:	c0 a8       	rjmp	8000bfb2 <_vfprintf_r+0xd3a>
8000bfa0:	50 a7       	stdsp	sp[0x28],r7
8000bfa2:	50 80       	stdsp	sp[0x20],r0
8000bfa4:	0c 97       	mov	r7,r6
8000bfa6:	04 94       	mov	r4,r2
8000bfa8:	06 96       	mov	r6,r3
8000bfaa:	02 92       	mov	r2,r1
8000bfac:	40 93       	lddsp	r3,sp[0x24]
8000bfae:	10 90       	mov	r0,r8
8000bfb0:	40 41       	lddsp	r1,sp[0x10]
8000bfb2:	ed b5 00 05 	bld	r5,0x5
8000bfb6:	c5 d1       	brne	8000c070 <_vfprintf_r+0xdf8>
8000bfb8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bfbc:	40 3c       	lddsp	r12,sp[0xc]
8000bfbe:	58 0c       	cp.w	r12,0
8000bfc0:	c2 60       	breq	8000c00c <_vfprintf_r+0xd94>
8000bfc2:	10 36       	cp.w	r6,r8
8000bfc4:	c0 a4       	brge	8000bfd8 <_vfprintf_r+0xd60>
8000bfc6:	fa cb f9 44 	sub	r11,sp,-1724
8000bfca:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bfce:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000bfd2:	fa e9 00 00 	st.d	sp[0],r8
8000bfd6:	c1 88       	rjmp	8000c006 <_vfprintf_r+0xd8e>
8000bfd8:	fa c8 f9 50 	sub	r8,sp,-1712
8000bfdc:	1a d8       	st.w	--sp,r8
8000bfde:	fa c8 fa b8 	sub	r8,sp,-1352
8000bfe2:	04 9a       	mov	r10,r2
8000bfe4:	1a d8       	st.w	--sp,r8
8000bfe6:	0c 9b       	mov	r11,r6
8000bfe8:	fa c8 fb b4 	sub	r8,sp,-1100
8000bfec:	08 9c       	mov	r12,r4
8000bfee:	1a d8       	st.w	--sp,r8
8000bff0:	fa c8 f9 40 	sub	r8,sp,-1728
8000bff4:	fa c9 ff b4 	sub	r9,sp,-76
8000bff8:	fe b0 f7 a2 	rcall	8000af3c <get_arg>
8000bffc:	2f dd       	sub	sp,-12
8000bffe:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c002:	fa eb 00 00 	st.d	sp[0],r10
8000c006:	30 08       	mov	r8,0
8000c008:	e0 8f 03 de 	bral	8000c7c4 <_vfprintf_r+0x154c>
8000c00c:	ee ca ff ff 	sub	r10,r7,-1
8000c010:	10 37       	cp.w	r7,r8
8000c012:	c0 b4       	brge	8000c028 <_vfprintf_r+0xdb0>
8000c014:	fa c9 f9 44 	sub	r9,sp,-1724
8000c018:	14 97       	mov	r7,r10
8000c01a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c01e:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c022:	fa eb 00 00 	st.d	sp[0],r10
8000c026:	c1 88       	rjmp	8000c056 <_vfprintf_r+0xdde>
8000c028:	41 09       	lddsp	r9,sp[0x40]
8000c02a:	59 f8       	cp.w	r8,31
8000c02c:	e0 89 00 18 	brgt	8000c05c <_vfprintf_r+0xde4>
8000c030:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c034:	f2 cb ff f8 	sub	r11,r9,-8
8000c038:	fa e7 00 00 	st.d	sp[0],r6
8000c03c:	51 0b       	stdsp	sp[0x40],r11
8000c03e:	fa c6 f9 44 	sub	r6,sp,-1724
8000c042:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c046:	fa e6 00 00 	ld.d	r6,sp[0]
8000c04a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c04e:	2f f8       	sub	r8,-1
8000c050:	14 97       	mov	r7,r10
8000c052:	fb 48 06 b4 	st.w	sp[1716],r8
8000c056:	40 38       	lddsp	r8,sp[0xc]
8000c058:	e0 8f 03 b6 	bral	8000c7c4 <_vfprintf_r+0x154c>
8000c05c:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c060:	40 38       	lddsp	r8,sp[0xc]
8000c062:	fa e7 00 00 	st.d	sp[0],r6
8000c066:	2f 89       	sub	r9,-8
8000c068:	14 97       	mov	r7,r10
8000c06a:	51 09       	stdsp	sp[0x40],r9
8000c06c:	e0 8f 03 ac 	bral	8000c7c4 <_vfprintf_r+0x154c>
8000c070:	ed b5 00 04 	bld	r5,0x4
8000c074:	c1 61       	brne	8000c0a0 <_vfprintf_r+0xe28>
8000c076:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c07a:	40 3e       	lddsp	lr,sp[0xc]
8000c07c:	58 0e       	cp.w	lr,0
8000c07e:	c0 80       	breq	8000c08e <_vfprintf_r+0xe16>
8000c080:	10 36       	cp.w	r6,r8
8000c082:	c6 74       	brge	8000c150 <_vfprintf_r+0xed8>
8000c084:	fa cc f9 44 	sub	r12,sp,-1724
8000c088:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c08c:	c8 08       	rjmp	8000c18c <_vfprintf_r+0xf14>
8000c08e:	ee ca ff ff 	sub	r10,r7,-1
8000c092:	10 37       	cp.w	r7,r8
8000c094:	c7 f4       	brge	8000c192 <_vfprintf_r+0xf1a>
8000c096:	fa cb f9 44 	sub	r11,sp,-1724
8000c09a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c09e:	c7 68       	rjmp	8000c18a <_vfprintf_r+0xf12>
8000c0a0:	ed b5 00 06 	bld	r5,0x6
8000c0a4:	c4 a1       	brne	8000c138 <_vfprintf_r+0xec0>
8000c0a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c0aa:	40 3c       	lddsp	r12,sp[0xc]
8000c0ac:	58 0c       	cp.w	r12,0
8000c0ae:	c1 d0       	breq	8000c0e8 <_vfprintf_r+0xe70>
8000c0b0:	10 36       	cp.w	r6,r8
8000c0b2:	c0 64       	brge	8000c0be <_vfprintf_r+0xe46>
8000c0b4:	fa cb f9 44 	sub	r11,sp,-1724
8000c0b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c0bc:	c1 f8       	rjmp	8000c0fa <_vfprintf_r+0xe82>
8000c0be:	fa c8 f9 50 	sub	r8,sp,-1712
8000c0c2:	1a d8       	st.w	--sp,r8
8000c0c4:	fa c8 fa b8 	sub	r8,sp,-1352
8000c0c8:	1a d8       	st.w	--sp,r8
8000c0ca:	fa c8 fb b4 	sub	r8,sp,-1100
8000c0ce:	1a d8       	st.w	--sp,r8
8000c0d0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c0d4:	fa c9 ff b4 	sub	r9,sp,-76
8000c0d8:	04 9a       	mov	r10,r2
8000c0da:	0c 9b       	mov	r11,r6
8000c0dc:	08 9c       	mov	r12,r4
8000c0de:	fe b0 f7 2f 	rcall	8000af3c <get_arg>
8000c0e2:	2f dd       	sub	sp,-12
8000c0e4:	98 18       	ld.sh	r8,r12[0x2]
8000c0e6:	c2 68       	rjmp	8000c132 <_vfprintf_r+0xeba>
8000c0e8:	ee ca ff ff 	sub	r10,r7,-1
8000c0ec:	10 37       	cp.w	r7,r8
8000c0ee:	c0 94       	brge	8000c100 <_vfprintf_r+0xe88>
8000c0f0:	fa c9 f9 44 	sub	r9,sp,-1724
8000c0f4:	14 97       	mov	r7,r10
8000c0f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c0fa:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c0fe:	c1 a8       	rjmp	8000c132 <_vfprintf_r+0xeba>
8000c100:	41 09       	lddsp	r9,sp[0x40]
8000c102:	59 f8       	cp.w	r8,31
8000c104:	e0 89 00 13 	brgt	8000c12a <_vfprintf_r+0xeb2>
8000c108:	f2 cb ff fc 	sub	r11,r9,-4
8000c10c:	51 0b       	stdsp	sp[0x40],r11
8000c10e:	72 09       	ld.w	r9,r9[0x0]
8000c110:	fa c6 f9 44 	sub	r6,sp,-1724
8000c114:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c118:	2f f8       	sub	r8,-1
8000c11a:	f7 49 fd 88 	st.w	r11[-632],r9
8000c11e:	fb 48 06 b4 	st.w	sp[1716],r8
8000c122:	14 97       	mov	r7,r10
8000c124:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c128:	c0 58       	rjmp	8000c132 <_vfprintf_r+0xeba>
8000c12a:	92 18       	ld.sh	r8,r9[0x2]
8000c12c:	14 97       	mov	r7,r10
8000c12e:	2f c9       	sub	r9,-4
8000c130:	51 09       	stdsp	sp[0x40],r9
8000c132:	5c 78       	castu.h	r8
8000c134:	50 18       	stdsp	sp[0x4],r8
8000c136:	c4 68       	rjmp	8000c1c2 <_vfprintf_r+0xf4a>
8000c138:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c13c:	40 3c       	lddsp	r12,sp[0xc]
8000c13e:	58 0c       	cp.w	r12,0
8000c140:	c1 d0       	breq	8000c17a <_vfprintf_r+0xf02>
8000c142:	10 36       	cp.w	r6,r8
8000c144:	c0 64       	brge	8000c150 <_vfprintf_r+0xed8>
8000c146:	fa cb f9 44 	sub	r11,sp,-1724
8000c14a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c14e:	c1 f8       	rjmp	8000c18c <_vfprintf_r+0xf14>
8000c150:	fa c8 f9 50 	sub	r8,sp,-1712
8000c154:	1a d8       	st.w	--sp,r8
8000c156:	fa c8 fa b8 	sub	r8,sp,-1352
8000c15a:	0c 9b       	mov	r11,r6
8000c15c:	1a d8       	st.w	--sp,r8
8000c15e:	fa c8 fb b4 	sub	r8,sp,-1100
8000c162:	04 9a       	mov	r10,r2
8000c164:	1a d8       	st.w	--sp,r8
8000c166:	08 9c       	mov	r12,r4
8000c168:	fa c8 f9 40 	sub	r8,sp,-1728
8000c16c:	fa c9 ff b4 	sub	r9,sp,-76
8000c170:	fe b0 f6 e6 	rcall	8000af3c <get_arg>
8000c174:	2f dd       	sub	sp,-12
8000c176:	78 0b       	ld.w	r11,r12[0x0]
8000c178:	c2 48       	rjmp	8000c1c0 <_vfprintf_r+0xf48>
8000c17a:	ee ca ff ff 	sub	r10,r7,-1
8000c17e:	10 37       	cp.w	r7,r8
8000c180:	c0 94       	brge	8000c192 <_vfprintf_r+0xf1a>
8000c182:	fa c9 f9 44 	sub	r9,sp,-1724
8000c186:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c18a:	14 97       	mov	r7,r10
8000c18c:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c190:	c1 88       	rjmp	8000c1c0 <_vfprintf_r+0xf48>
8000c192:	41 09       	lddsp	r9,sp[0x40]
8000c194:	59 f8       	cp.w	r8,31
8000c196:	e0 89 00 11 	brgt	8000c1b8 <_vfprintf_r+0xf40>
8000c19a:	f2 cb ff fc 	sub	r11,r9,-4
8000c19e:	51 0b       	stdsp	sp[0x40],r11
8000c1a0:	fa c6 f9 44 	sub	r6,sp,-1724
8000c1a4:	72 0b       	ld.w	r11,r9[0x0]
8000c1a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c1aa:	f3 4b fd 88 	st.w	r9[-632],r11
8000c1ae:	2f f8       	sub	r8,-1
8000c1b0:	14 97       	mov	r7,r10
8000c1b2:	fb 48 06 b4 	st.w	sp[1716],r8
8000c1b6:	c0 58       	rjmp	8000c1c0 <_vfprintf_r+0xf48>
8000c1b8:	72 0b       	ld.w	r11,r9[0x0]
8000c1ba:	14 97       	mov	r7,r10
8000c1bc:	2f c9       	sub	r9,-4
8000c1be:	51 09       	stdsp	sp[0x40],r9
8000c1c0:	50 1b       	stdsp	sp[0x4],r11
8000c1c2:	30 0e       	mov	lr,0
8000c1c4:	50 0e       	stdsp	sp[0x0],lr
8000c1c6:	1c 98       	mov	r8,lr
8000c1c8:	e0 8f 02 fe 	bral	8000c7c4 <_vfprintf_r+0x154c>
8000c1cc:	50 a7       	stdsp	sp[0x28],r7
8000c1ce:	50 80       	stdsp	sp[0x20],r0
8000c1d0:	0c 97       	mov	r7,r6
8000c1d2:	04 94       	mov	r4,r2
8000c1d4:	06 96       	mov	r6,r3
8000c1d6:	02 92       	mov	r2,r1
8000c1d8:	40 93       	lddsp	r3,sp[0x24]
8000c1da:	40 41       	lddsp	r1,sp[0x10]
8000c1dc:	0e 99       	mov	r9,r7
8000c1de:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c1e2:	40 3c       	lddsp	r12,sp[0xc]
8000c1e4:	58 0c       	cp.w	r12,0
8000c1e6:	c1 d0       	breq	8000c220 <_vfprintf_r+0xfa8>
8000c1e8:	10 36       	cp.w	r6,r8
8000c1ea:	c0 64       	brge	8000c1f6 <_vfprintf_r+0xf7e>
8000c1ec:	fa cb f9 44 	sub	r11,sp,-1724
8000c1f0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c1f4:	c1 d8       	rjmp	8000c22e <_vfprintf_r+0xfb6>
8000c1f6:	fa c8 f9 50 	sub	r8,sp,-1712
8000c1fa:	1a d8       	st.w	--sp,r8
8000c1fc:	fa c8 fa b8 	sub	r8,sp,-1352
8000c200:	1a d8       	st.w	--sp,r8
8000c202:	fa c8 fb b4 	sub	r8,sp,-1100
8000c206:	1a d8       	st.w	--sp,r8
8000c208:	fa c9 ff b4 	sub	r9,sp,-76
8000c20c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c210:	04 9a       	mov	r10,r2
8000c212:	0c 9b       	mov	r11,r6
8000c214:	08 9c       	mov	r12,r4
8000c216:	fe b0 f6 93 	rcall	8000af3c <get_arg>
8000c21a:	2f dd       	sub	sp,-12
8000c21c:	78 09       	ld.w	r9,r12[0x0]
8000c21e:	c2 18       	rjmp	8000c260 <_vfprintf_r+0xfe8>
8000c220:	2f f7       	sub	r7,-1
8000c222:	10 39       	cp.w	r9,r8
8000c224:	c0 84       	brge	8000c234 <_vfprintf_r+0xfbc>
8000c226:	fa ca f9 44 	sub	r10,sp,-1724
8000c22a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c22e:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000c232:	c1 78       	rjmp	8000c260 <_vfprintf_r+0xfe8>
8000c234:	41 09       	lddsp	r9,sp[0x40]
8000c236:	59 f8       	cp.w	r8,31
8000c238:	e0 89 00 10 	brgt	8000c258 <_vfprintf_r+0xfe0>
8000c23c:	f2 ca ff fc 	sub	r10,r9,-4
8000c240:	51 0a       	stdsp	sp[0x40],r10
8000c242:	fa c6 f9 44 	sub	r6,sp,-1724
8000c246:	72 09       	ld.w	r9,r9[0x0]
8000c248:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000c24c:	f5 49 fd 88 	st.w	r10[-632],r9
8000c250:	2f f8       	sub	r8,-1
8000c252:	fb 48 06 b4 	st.w	sp[1716],r8
8000c256:	c0 58       	rjmp	8000c260 <_vfprintf_r+0xfe8>
8000c258:	f2 c8 ff fc 	sub	r8,r9,-4
8000c25c:	51 08       	stdsp	sp[0x40],r8
8000c25e:	72 09       	ld.w	r9,r9[0x0]
8000c260:	33 08       	mov	r8,48
8000c262:	fb 68 06 b8 	st.b	sp[1720],r8
8000c266:	37 88       	mov	r8,120
8000c268:	30 0e       	mov	lr,0
8000c26a:	fb 68 06 b9 	st.b	sp[1721],r8
8000c26e:	4c ac       	lddpc	r12,8000c394 <_vfprintf_r+0x111c>
8000c270:	50 19       	stdsp	sp[0x4],r9
8000c272:	a1 b5       	sbr	r5,0x1
8000c274:	50 0e       	stdsp	sp[0x0],lr
8000c276:	50 dc       	stdsp	sp[0x34],r12
8000c278:	30 28       	mov	r8,2
8000c27a:	37 80       	mov	r0,120
8000c27c:	e0 8f 02 a4 	bral	8000c7c4 <_vfprintf_r+0x154c>
8000c280:	50 a7       	stdsp	sp[0x28],r7
8000c282:	50 80       	stdsp	sp[0x20],r0
8000c284:	10 90       	mov	r0,r8
8000c286:	30 08       	mov	r8,0
8000c288:	fb 68 06 bb 	st.b	sp[1723],r8
8000c28c:	0c 97       	mov	r7,r6
8000c28e:	04 94       	mov	r4,r2
8000c290:	06 96       	mov	r6,r3
8000c292:	02 92       	mov	r2,r1
8000c294:	40 93       	lddsp	r3,sp[0x24]
8000c296:	40 41       	lddsp	r1,sp[0x10]
8000c298:	0e 99       	mov	r9,r7
8000c29a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c29e:	40 3b       	lddsp	r11,sp[0xc]
8000c2a0:	58 0b       	cp.w	r11,0
8000c2a2:	c1 d0       	breq	8000c2dc <_vfprintf_r+0x1064>
8000c2a4:	10 36       	cp.w	r6,r8
8000c2a6:	c0 64       	brge	8000c2b2 <_vfprintf_r+0x103a>
8000c2a8:	fa ca f9 44 	sub	r10,sp,-1724
8000c2ac:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c2b0:	c1 d8       	rjmp	8000c2ea <_vfprintf_r+0x1072>
8000c2b2:	fa c8 f9 50 	sub	r8,sp,-1712
8000c2b6:	1a d8       	st.w	--sp,r8
8000c2b8:	fa c8 fa b8 	sub	r8,sp,-1352
8000c2bc:	1a d8       	st.w	--sp,r8
8000c2be:	fa c8 fb b4 	sub	r8,sp,-1100
8000c2c2:	0c 9b       	mov	r11,r6
8000c2c4:	1a d8       	st.w	--sp,r8
8000c2c6:	04 9a       	mov	r10,r2
8000c2c8:	fa c8 f9 40 	sub	r8,sp,-1728
8000c2cc:	fa c9 ff b4 	sub	r9,sp,-76
8000c2d0:	08 9c       	mov	r12,r4
8000c2d2:	fe b0 f6 35 	rcall	8000af3c <get_arg>
8000c2d6:	2f dd       	sub	sp,-12
8000c2d8:	78 06       	ld.w	r6,r12[0x0]
8000c2da:	c2 08       	rjmp	8000c31a <_vfprintf_r+0x10a2>
8000c2dc:	2f f7       	sub	r7,-1
8000c2de:	10 39       	cp.w	r9,r8
8000c2e0:	c0 84       	brge	8000c2f0 <_vfprintf_r+0x1078>
8000c2e2:	fa c9 f9 44 	sub	r9,sp,-1724
8000c2e6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c2ea:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000c2ee:	c1 68       	rjmp	8000c31a <_vfprintf_r+0x10a2>
8000c2f0:	41 09       	lddsp	r9,sp[0x40]
8000c2f2:	59 f8       	cp.w	r8,31
8000c2f4:	e0 89 00 10 	brgt	8000c314 <_vfprintf_r+0x109c>
8000c2f8:	f2 ca ff fc 	sub	r10,r9,-4
8000c2fc:	51 0a       	stdsp	sp[0x40],r10
8000c2fe:	72 06       	ld.w	r6,r9[0x0]
8000c300:	fa ce f9 44 	sub	lr,sp,-1724
8000c304:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000c308:	f3 46 fd 88 	st.w	r9[-632],r6
8000c30c:	2f f8       	sub	r8,-1
8000c30e:	fb 48 06 b4 	st.w	sp[1716],r8
8000c312:	c0 48       	rjmp	8000c31a <_vfprintf_r+0x10a2>
8000c314:	72 06       	ld.w	r6,r9[0x0]
8000c316:	2f c9       	sub	r9,-4
8000c318:	51 09       	stdsp	sp[0x40],r9
8000c31a:	40 2c       	lddsp	r12,sp[0x8]
8000c31c:	58 0c       	cp.w	r12,0
8000c31e:	c1 05       	brlt	8000c33e <_vfprintf_r+0x10c6>
8000c320:	18 9a       	mov	r10,r12
8000c322:	30 0b       	mov	r11,0
8000c324:	0c 9c       	mov	r12,r6
8000c326:	e0 a0 12 43 	rcall	8000e7ac <memchr>
8000c32a:	e0 80 02 e0 	breq	8000c8ea <_vfprintf_r+0x1672>
8000c32e:	f8 06 01 02 	sub	r2,r12,r6
8000c332:	40 2b       	lddsp	r11,sp[0x8]
8000c334:	16 32       	cp.w	r2,r11
8000c336:	e0 89 02 da 	brgt	8000c8ea <_vfprintf_r+0x1672>
8000c33a:	e0 8f 02 d5 	bral	8000c8e4 <_vfprintf_r+0x166c>
8000c33e:	30 0a       	mov	r10,0
8000c340:	0c 9c       	mov	r12,r6
8000c342:	50 2a       	stdsp	sp[0x8],r10
8000c344:	fe b0 f4 ff 	rcall	8000ad42 <strlen>
8000c348:	18 92       	mov	r2,r12
8000c34a:	e0 8f 02 d3 	bral	8000c8f0 <_vfprintf_r+0x1678>
8000c34e:	50 a7       	stdsp	sp[0x28],r7
8000c350:	50 80       	stdsp	sp[0x20],r0
8000c352:	0c 97       	mov	r7,r6
8000c354:	04 94       	mov	r4,r2
8000c356:	06 96       	mov	r6,r3
8000c358:	02 92       	mov	r2,r1
8000c35a:	40 93       	lddsp	r3,sp[0x24]
8000c35c:	10 90       	mov	r0,r8
8000c35e:	40 41       	lddsp	r1,sp[0x10]
8000c360:	a5 a5       	sbr	r5,0x4
8000c362:	c0 a8       	rjmp	8000c376 <_vfprintf_r+0x10fe>
8000c364:	50 a7       	stdsp	sp[0x28],r7
8000c366:	50 80       	stdsp	sp[0x20],r0
8000c368:	0c 97       	mov	r7,r6
8000c36a:	04 94       	mov	r4,r2
8000c36c:	06 96       	mov	r6,r3
8000c36e:	02 92       	mov	r2,r1
8000c370:	40 93       	lddsp	r3,sp[0x24]
8000c372:	10 90       	mov	r0,r8
8000c374:	40 41       	lddsp	r1,sp[0x10]
8000c376:	ed b5 00 05 	bld	r5,0x5
8000c37a:	c5 71       	brne	8000c428 <_vfprintf_r+0x11b0>
8000c37c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c380:	40 39       	lddsp	r9,sp[0xc]
8000c382:	58 09       	cp.w	r9,0
8000c384:	c2 20       	breq	8000c3c8 <_vfprintf_r+0x1150>
8000c386:	10 36       	cp.w	r6,r8
8000c388:	c0 84       	brge	8000c398 <_vfprintf_r+0x1120>
8000c38a:	fa c8 f9 44 	sub	r8,sp,-1724
8000c38e:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000c392:	c2 48       	rjmp	8000c3da <_vfprintf_r+0x1162>
8000c394:	80 01       	ld.sh	r1,r0[0x0]
8000c396:	9b 48       	st.w	sp[0x10],r8
8000c398:	fa c8 f9 50 	sub	r8,sp,-1712
8000c39c:	1a d8       	st.w	--sp,r8
8000c39e:	fa c8 fa b8 	sub	r8,sp,-1352
8000c3a2:	1a d8       	st.w	--sp,r8
8000c3a4:	fa c8 fb b4 	sub	r8,sp,-1100
8000c3a8:	1a d8       	st.w	--sp,r8
8000c3aa:	fa c8 f9 40 	sub	r8,sp,-1728
8000c3ae:	fa c9 ff b4 	sub	r9,sp,-76
8000c3b2:	04 9a       	mov	r10,r2
8000c3b4:	0c 9b       	mov	r11,r6
8000c3b6:	08 9c       	mov	r12,r4
8000c3b8:	fe b0 f5 c2 	rcall	8000af3c <get_arg>
8000c3bc:	2f dd       	sub	sp,-12
8000c3be:	f8 e8 00 00 	ld.d	r8,r12[0]
8000c3c2:	fa e9 00 00 	st.d	sp[0],r8
8000c3c6:	c2 e8       	rjmp	8000c422 <_vfprintf_r+0x11aa>
8000c3c8:	ee ca ff ff 	sub	r10,r7,-1
8000c3cc:	10 37       	cp.w	r7,r8
8000c3ce:	c0 b4       	brge	8000c3e4 <_vfprintf_r+0x116c>
8000c3d0:	fa c8 f9 44 	sub	r8,sp,-1724
8000c3d4:	14 97       	mov	r7,r10
8000c3d6:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000c3da:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c3de:	fa eb 00 00 	st.d	sp[0],r10
8000c3e2:	c2 08       	rjmp	8000c422 <_vfprintf_r+0x11aa>
8000c3e4:	41 09       	lddsp	r9,sp[0x40]
8000c3e6:	59 f8       	cp.w	r8,31
8000c3e8:	e0 89 00 16 	brgt	8000c414 <_vfprintf_r+0x119c>
8000c3ec:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c3f0:	f2 cb ff f8 	sub	r11,r9,-8
8000c3f4:	fa e7 00 00 	st.d	sp[0],r6
8000c3f8:	51 0b       	stdsp	sp[0x40],r11
8000c3fa:	fa c6 f9 44 	sub	r6,sp,-1724
8000c3fe:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c402:	fa e6 00 00 	ld.d	r6,sp[0]
8000c406:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c40a:	2f f8       	sub	r8,-1
8000c40c:	14 97       	mov	r7,r10
8000c40e:	fb 48 06 b4 	st.w	sp[1716],r8
8000c412:	c0 88       	rjmp	8000c422 <_vfprintf_r+0x11aa>
8000c414:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c418:	2f 89       	sub	r9,-8
8000c41a:	fa e7 00 00 	st.d	sp[0],r6
8000c41e:	51 09       	stdsp	sp[0x40],r9
8000c420:	14 97       	mov	r7,r10
8000c422:	30 18       	mov	r8,1
8000c424:	e0 8f 01 d0 	bral	8000c7c4 <_vfprintf_r+0x154c>
8000c428:	ed b5 00 04 	bld	r5,0x4
8000c42c:	c1 61       	brne	8000c458 <_vfprintf_r+0x11e0>
8000c42e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c432:	40 3e       	lddsp	lr,sp[0xc]
8000c434:	58 0e       	cp.w	lr,0
8000c436:	c0 80       	breq	8000c446 <_vfprintf_r+0x11ce>
8000c438:	10 36       	cp.w	r6,r8
8000c43a:	c6 74       	brge	8000c508 <_vfprintf_r+0x1290>
8000c43c:	fa cc f9 44 	sub	r12,sp,-1724
8000c440:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c444:	c8 08       	rjmp	8000c544 <_vfprintf_r+0x12cc>
8000c446:	ee ca ff ff 	sub	r10,r7,-1
8000c44a:	10 37       	cp.w	r7,r8
8000c44c:	c7 f4       	brge	8000c54a <_vfprintf_r+0x12d2>
8000c44e:	fa cb f9 44 	sub	r11,sp,-1724
8000c452:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c456:	c7 68       	rjmp	8000c542 <_vfprintf_r+0x12ca>
8000c458:	ed b5 00 06 	bld	r5,0x6
8000c45c:	c4 a1       	brne	8000c4f0 <_vfprintf_r+0x1278>
8000c45e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c462:	40 3c       	lddsp	r12,sp[0xc]
8000c464:	58 0c       	cp.w	r12,0
8000c466:	c1 d0       	breq	8000c4a0 <_vfprintf_r+0x1228>
8000c468:	10 36       	cp.w	r6,r8
8000c46a:	c0 64       	brge	8000c476 <_vfprintf_r+0x11fe>
8000c46c:	fa cb f9 44 	sub	r11,sp,-1724
8000c470:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c474:	c1 f8       	rjmp	8000c4b2 <_vfprintf_r+0x123a>
8000c476:	fa c8 f9 50 	sub	r8,sp,-1712
8000c47a:	1a d8       	st.w	--sp,r8
8000c47c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c480:	1a d8       	st.w	--sp,r8
8000c482:	fa c8 fb b4 	sub	r8,sp,-1100
8000c486:	1a d8       	st.w	--sp,r8
8000c488:	fa c8 f9 40 	sub	r8,sp,-1728
8000c48c:	fa c9 ff b4 	sub	r9,sp,-76
8000c490:	04 9a       	mov	r10,r2
8000c492:	0c 9b       	mov	r11,r6
8000c494:	08 9c       	mov	r12,r4
8000c496:	fe b0 f5 53 	rcall	8000af3c <get_arg>
8000c49a:	2f dd       	sub	sp,-12
8000c49c:	98 18       	ld.sh	r8,r12[0x2]
8000c49e:	c2 68       	rjmp	8000c4ea <_vfprintf_r+0x1272>
8000c4a0:	ee ca ff ff 	sub	r10,r7,-1
8000c4a4:	10 37       	cp.w	r7,r8
8000c4a6:	c0 94       	brge	8000c4b8 <_vfprintf_r+0x1240>
8000c4a8:	fa c9 f9 44 	sub	r9,sp,-1724
8000c4ac:	14 97       	mov	r7,r10
8000c4ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c4b2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c4b6:	c1 a8       	rjmp	8000c4ea <_vfprintf_r+0x1272>
8000c4b8:	41 09       	lddsp	r9,sp[0x40]
8000c4ba:	59 f8       	cp.w	r8,31
8000c4bc:	e0 89 00 13 	brgt	8000c4e2 <_vfprintf_r+0x126a>
8000c4c0:	f2 cb ff fc 	sub	r11,r9,-4
8000c4c4:	51 0b       	stdsp	sp[0x40],r11
8000c4c6:	72 09       	ld.w	r9,r9[0x0]
8000c4c8:	fa c6 f9 44 	sub	r6,sp,-1724
8000c4cc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c4d0:	2f f8       	sub	r8,-1
8000c4d2:	f7 49 fd 88 	st.w	r11[-632],r9
8000c4d6:	fb 48 06 b4 	st.w	sp[1716],r8
8000c4da:	14 97       	mov	r7,r10
8000c4dc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c4e0:	c0 58       	rjmp	8000c4ea <_vfprintf_r+0x1272>
8000c4e2:	92 18       	ld.sh	r8,r9[0x2]
8000c4e4:	14 97       	mov	r7,r10
8000c4e6:	2f c9       	sub	r9,-4
8000c4e8:	51 09       	stdsp	sp[0x40],r9
8000c4ea:	5c 78       	castu.h	r8
8000c4ec:	50 18       	stdsp	sp[0x4],r8
8000c4ee:	c4 68       	rjmp	8000c57a <_vfprintf_r+0x1302>
8000c4f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c4f4:	40 3c       	lddsp	r12,sp[0xc]
8000c4f6:	58 0c       	cp.w	r12,0
8000c4f8:	c1 d0       	breq	8000c532 <_vfprintf_r+0x12ba>
8000c4fa:	10 36       	cp.w	r6,r8
8000c4fc:	c0 64       	brge	8000c508 <_vfprintf_r+0x1290>
8000c4fe:	fa cb f9 44 	sub	r11,sp,-1724
8000c502:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c506:	c1 f8       	rjmp	8000c544 <_vfprintf_r+0x12cc>
8000c508:	fa c8 f9 50 	sub	r8,sp,-1712
8000c50c:	1a d8       	st.w	--sp,r8
8000c50e:	fa c8 fa b8 	sub	r8,sp,-1352
8000c512:	0c 9b       	mov	r11,r6
8000c514:	1a d8       	st.w	--sp,r8
8000c516:	fa c8 fb b4 	sub	r8,sp,-1100
8000c51a:	04 9a       	mov	r10,r2
8000c51c:	1a d8       	st.w	--sp,r8
8000c51e:	08 9c       	mov	r12,r4
8000c520:	fa c8 f9 40 	sub	r8,sp,-1728
8000c524:	fa c9 ff b4 	sub	r9,sp,-76
8000c528:	fe b0 f5 0a 	rcall	8000af3c <get_arg>
8000c52c:	2f dd       	sub	sp,-12
8000c52e:	78 0b       	ld.w	r11,r12[0x0]
8000c530:	c2 48       	rjmp	8000c578 <_vfprintf_r+0x1300>
8000c532:	ee ca ff ff 	sub	r10,r7,-1
8000c536:	10 37       	cp.w	r7,r8
8000c538:	c0 94       	brge	8000c54a <_vfprintf_r+0x12d2>
8000c53a:	fa c9 f9 44 	sub	r9,sp,-1724
8000c53e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c542:	14 97       	mov	r7,r10
8000c544:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c548:	c1 88       	rjmp	8000c578 <_vfprintf_r+0x1300>
8000c54a:	41 09       	lddsp	r9,sp[0x40]
8000c54c:	59 f8       	cp.w	r8,31
8000c54e:	e0 89 00 11 	brgt	8000c570 <_vfprintf_r+0x12f8>
8000c552:	f2 cb ff fc 	sub	r11,r9,-4
8000c556:	51 0b       	stdsp	sp[0x40],r11
8000c558:	fa c6 f9 44 	sub	r6,sp,-1724
8000c55c:	72 0b       	ld.w	r11,r9[0x0]
8000c55e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c562:	f3 4b fd 88 	st.w	r9[-632],r11
8000c566:	2f f8       	sub	r8,-1
8000c568:	14 97       	mov	r7,r10
8000c56a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c56e:	c0 58       	rjmp	8000c578 <_vfprintf_r+0x1300>
8000c570:	72 0b       	ld.w	r11,r9[0x0]
8000c572:	14 97       	mov	r7,r10
8000c574:	2f c9       	sub	r9,-4
8000c576:	51 09       	stdsp	sp[0x40],r9
8000c578:	50 1b       	stdsp	sp[0x4],r11
8000c57a:	30 0e       	mov	lr,0
8000c57c:	30 18       	mov	r8,1
8000c57e:	50 0e       	stdsp	sp[0x0],lr
8000c580:	c2 29       	rjmp	8000c7c4 <_vfprintf_r+0x154c>
8000c582:	50 a7       	stdsp	sp[0x28],r7
8000c584:	50 80       	stdsp	sp[0x20],r0
8000c586:	0c 97       	mov	r7,r6
8000c588:	04 94       	mov	r4,r2
8000c58a:	06 96       	mov	r6,r3
8000c58c:	02 92       	mov	r2,r1
8000c58e:	4d 3c       	lddpc	r12,8000c6d8 <_vfprintf_r+0x1460>
8000c590:	40 93       	lddsp	r3,sp[0x24]
8000c592:	10 90       	mov	r0,r8
8000c594:	40 41       	lddsp	r1,sp[0x10]
8000c596:	50 dc       	stdsp	sp[0x34],r12
8000c598:	ed b5 00 05 	bld	r5,0x5
8000c59c:	c5 51       	brne	8000c646 <_vfprintf_r+0x13ce>
8000c59e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c5a2:	40 3b       	lddsp	r11,sp[0xc]
8000c5a4:	58 0b       	cp.w	r11,0
8000c5a6:	c2 20       	breq	8000c5ea <_vfprintf_r+0x1372>
8000c5a8:	10 36       	cp.w	r6,r8
8000c5aa:	c0 a4       	brge	8000c5be <_vfprintf_r+0x1346>
8000c5ac:	fa ca f9 44 	sub	r10,sp,-1724
8000c5b0:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c5b4:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c5b8:	fa e9 00 00 	st.d	sp[0],r8
8000c5bc:	cf 38       	rjmp	8000c7a2 <_vfprintf_r+0x152a>
8000c5be:	fa c8 f9 50 	sub	r8,sp,-1712
8000c5c2:	1a d8       	st.w	--sp,r8
8000c5c4:	fa c8 fa b8 	sub	r8,sp,-1352
8000c5c8:	04 9a       	mov	r10,r2
8000c5ca:	1a d8       	st.w	--sp,r8
8000c5cc:	0c 9b       	mov	r11,r6
8000c5ce:	fa c8 fb b4 	sub	r8,sp,-1100
8000c5d2:	08 9c       	mov	r12,r4
8000c5d4:	1a d8       	st.w	--sp,r8
8000c5d6:	fa c8 f9 40 	sub	r8,sp,-1728
8000c5da:	fa c9 ff b4 	sub	r9,sp,-76
8000c5de:	fe b0 f4 af 	rcall	8000af3c <get_arg>
8000c5e2:	2f dd       	sub	sp,-12
8000c5e4:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c5e8:	c0 c8       	rjmp	8000c600 <_vfprintf_r+0x1388>
8000c5ea:	ee ca ff ff 	sub	r10,r7,-1
8000c5ee:	10 37       	cp.w	r7,r8
8000c5f0:	c0 b4       	brge	8000c606 <_vfprintf_r+0x138e>
8000c5f2:	fa c9 f9 44 	sub	r9,sp,-1724
8000c5f6:	14 97       	mov	r7,r10
8000c5f8:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c5fc:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c600:	fa eb 00 00 	st.d	sp[0],r10
8000c604:	cc f8       	rjmp	8000c7a2 <_vfprintf_r+0x152a>
8000c606:	41 09       	lddsp	r9,sp[0x40]
8000c608:	59 f8       	cp.w	r8,31
8000c60a:	e0 89 00 16 	brgt	8000c636 <_vfprintf_r+0x13be>
8000c60e:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c612:	f2 cb ff f8 	sub	r11,r9,-8
8000c616:	fa e7 00 00 	st.d	sp[0],r6
8000c61a:	51 0b       	stdsp	sp[0x40],r11
8000c61c:	fa c6 f9 44 	sub	r6,sp,-1724
8000c620:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c624:	fa e6 00 00 	ld.d	r6,sp[0]
8000c628:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c62c:	2f f8       	sub	r8,-1
8000c62e:	14 97       	mov	r7,r10
8000c630:	fb 48 06 b4 	st.w	sp[1716],r8
8000c634:	cb 78       	rjmp	8000c7a2 <_vfprintf_r+0x152a>
8000c636:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c63a:	2f 89       	sub	r9,-8
8000c63c:	fa e7 00 00 	st.d	sp[0],r6
8000c640:	51 09       	stdsp	sp[0x40],r9
8000c642:	14 97       	mov	r7,r10
8000c644:	ca f8       	rjmp	8000c7a2 <_vfprintf_r+0x152a>
8000c646:	ed b5 00 04 	bld	r5,0x4
8000c64a:	c1 71       	brne	8000c678 <_vfprintf_r+0x1400>
8000c64c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c650:	40 3e       	lddsp	lr,sp[0xc]
8000c652:	58 0e       	cp.w	lr,0
8000c654:	c0 80       	breq	8000c664 <_vfprintf_r+0x13ec>
8000c656:	10 36       	cp.w	r6,r8
8000c658:	c6 a4       	brge	8000c72c <_vfprintf_r+0x14b4>
8000c65a:	fa cc f9 44 	sub	r12,sp,-1724
8000c65e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c662:	c8 38       	rjmp	8000c768 <_vfprintf_r+0x14f0>
8000c664:	ee ca ff ff 	sub	r10,r7,-1
8000c668:	10 37       	cp.w	r7,r8
8000c66a:	e0 84 00 82 	brge	8000c76e <_vfprintf_r+0x14f6>
8000c66e:	fa cb f9 44 	sub	r11,sp,-1724
8000c672:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c676:	c7 88       	rjmp	8000c766 <_vfprintf_r+0x14ee>
8000c678:	ed b5 00 06 	bld	r5,0x6
8000c67c:	c4 c1       	brne	8000c714 <_vfprintf_r+0x149c>
8000c67e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c682:	40 3c       	lddsp	r12,sp[0xc]
8000c684:	58 0c       	cp.w	r12,0
8000c686:	c1 d0       	breq	8000c6c0 <_vfprintf_r+0x1448>
8000c688:	10 36       	cp.w	r6,r8
8000c68a:	c0 64       	brge	8000c696 <_vfprintf_r+0x141e>
8000c68c:	fa cb f9 44 	sub	r11,sp,-1724
8000c690:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c694:	c1 f8       	rjmp	8000c6d2 <_vfprintf_r+0x145a>
8000c696:	fa c8 f9 50 	sub	r8,sp,-1712
8000c69a:	1a d8       	st.w	--sp,r8
8000c69c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c6a0:	1a d8       	st.w	--sp,r8
8000c6a2:	fa c8 fb b4 	sub	r8,sp,-1100
8000c6a6:	1a d8       	st.w	--sp,r8
8000c6a8:	fa c8 f9 40 	sub	r8,sp,-1728
8000c6ac:	fa c9 ff b4 	sub	r9,sp,-76
8000c6b0:	04 9a       	mov	r10,r2
8000c6b2:	0c 9b       	mov	r11,r6
8000c6b4:	08 9c       	mov	r12,r4
8000c6b6:	fe b0 f4 43 	rcall	8000af3c <get_arg>
8000c6ba:	2f dd       	sub	sp,-12
8000c6bc:	98 18       	ld.sh	r8,r12[0x2]
8000c6be:	c2 88       	rjmp	8000c70e <_vfprintf_r+0x1496>
8000c6c0:	ee ca ff ff 	sub	r10,r7,-1
8000c6c4:	10 37       	cp.w	r7,r8
8000c6c6:	c0 b4       	brge	8000c6dc <_vfprintf_r+0x1464>
8000c6c8:	fa c9 f9 44 	sub	r9,sp,-1724
8000c6cc:	14 97       	mov	r7,r10
8000c6ce:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c6d2:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c6d6:	c1 c8       	rjmp	8000c70e <_vfprintf_r+0x1496>
8000c6d8:	80 01       	ld.sh	r1,r0[0x0]
8000c6da:	9b 48       	st.w	sp[0x10],r8
8000c6dc:	41 09       	lddsp	r9,sp[0x40]
8000c6de:	59 f8       	cp.w	r8,31
8000c6e0:	e0 89 00 13 	brgt	8000c706 <_vfprintf_r+0x148e>
8000c6e4:	f2 cb ff fc 	sub	r11,r9,-4
8000c6e8:	51 0b       	stdsp	sp[0x40],r11
8000c6ea:	72 09       	ld.w	r9,r9[0x0]
8000c6ec:	fa c6 f9 44 	sub	r6,sp,-1724
8000c6f0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c6f4:	2f f8       	sub	r8,-1
8000c6f6:	f7 49 fd 88 	st.w	r11[-632],r9
8000c6fa:	fb 48 06 b4 	st.w	sp[1716],r8
8000c6fe:	14 97       	mov	r7,r10
8000c700:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c704:	c0 58       	rjmp	8000c70e <_vfprintf_r+0x1496>
8000c706:	92 18       	ld.sh	r8,r9[0x2]
8000c708:	14 97       	mov	r7,r10
8000c70a:	2f c9       	sub	r9,-4
8000c70c:	51 09       	stdsp	sp[0x40],r9
8000c70e:	5c 78       	castu.h	r8
8000c710:	50 18       	stdsp	sp[0x4],r8
8000c712:	c4 68       	rjmp	8000c79e <_vfprintf_r+0x1526>
8000c714:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c718:	40 3c       	lddsp	r12,sp[0xc]
8000c71a:	58 0c       	cp.w	r12,0
8000c71c:	c1 d0       	breq	8000c756 <_vfprintf_r+0x14de>
8000c71e:	10 36       	cp.w	r6,r8
8000c720:	c0 64       	brge	8000c72c <_vfprintf_r+0x14b4>
8000c722:	fa cb f9 44 	sub	r11,sp,-1724
8000c726:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c72a:	c1 f8       	rjmp	8000c768 <_vfprintf_r+0x14f0>
8000c72c:	fa c8 f9 50 	sub	r8,sp,-1712
8000c730:	1a d8       	st.w	--sp,r8
8000c732:	fa c8 fa b8 	sub	r8,sp,-1352
8000c736:	0c 9b       	mov	r11,r6
8000c738:	1a d8       	st.w	--sp,r8
8000c73a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c73e:	04 9a       	mov	r10,r2
8000c740:	1a d8       	st.w	--sp,r8
8000c742:	08 9c       	mov	r12,r4
8000c744:	fa c8 f9 40 	sub	r8,sp,-1728
8000c748:	fa c9 ff b4 	sub	r9,sp,-76
8000c74c:	fe b0 f3 f8 	rcall	8000af3c <get_arg>
8000c750:	2f dd       	sub	sp,-12
8000c752:	78 0b       	ld.w	r11,r12[0x0]
8000c754:	c2 48       	rjmp	8000c79c <_vfprintf_r+0x1524>
8000c756:	ee ca ff ff 	sub	r10,r7,-1
8000c75a:	10 37       	cp.w	r7,r8
8000c75c:	c0 94       	brge	8000c76e <_vfprintf_r+0x14f6>
8000c75e:	fa c9 f9 44 	sub	r9,sp,-1724
8000c762:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c766:	14 97       	mov	r7,r10
8000c768:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c76c:	c1 88       	rjmp	8000c79c <_vfprintf_r+0x1524>
8000c76e:	41 09       	lddsp	r9,sp[0x40]
8000c770:	59 f8       	cp.w	r8,31
8000c772:	e0 89 00 11 	brgt	8000c794 <_vfprintf_r+0x151c>
8000c776:	f2 cb ff fc 	sub	r11,r9,-4
8000c77a:	51 0b       	stdsp	sp[0x40],r11
8000c77c:	fa c6 f9 44 	sub	r6,sp,-1724
8000c780:	72 0b       	ld.w	r11,r9[0x0]
8000c782:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c786:	f3 4b fd 88 	st.w	r9[-632],r11
8000c78a:	2f f8       	sub	r8,-1
8000c78c:	14 97       	mov	r7,r10
8000c78e:	fb 48 06 b4 	st.w	sp[1716],r8
8000c792:	c0 58       	rjmp	8000c79c <_vfprintf_r+0x1524>
8000c794:	72 0b       	ld.w	r11,r9[0x0]
8000c796:	14 97       	mov	r7,r10
8000c798:	2f c9       	sub	r9,-4
8000c79a:	51 09       	stdsp	sp[0x40],r9
8000c79c:	50 1b       	stdsp	sp[0x4],r11
8000c79e:	30 0e       	mov	lr,0
8000c7a0:	50 0e       	stdsp	sp[0x0],lr
8000c7a2:	40 08       	lddsp	r8,sp[0x0]
8000c7a4:	40 1c       	lddsp	r12,sp[0x4]
8000c7a6:	18 48       	or	r8,r12
8000c7a8:	5f 19       	srne	r9
8000c7aa:	0a 98       	mov	r8,r5
8000c7ac:	eb e9 00 09 	and	r9,r5,r9
8000c7b0:	a1 b8       	sbr	r8,0x1
8000c7b2:	58 09       	cp.w	r9,0
8000c7b4:	c0 70       	breq	8000c7c2 <_vfprintf_r+0x154a>
8000c7b6:	10 95       	mov	r5,r8
8000c7b8:	fb 60 06 b9 	st.b	sp[1721],r0
8000c7bc:	33 08       	mov	r8,48
8000c7be:	fb 68 06 b8 	st.b	sp[1720],r8
8000c7c2:	30 28       	mov	r8,2
8000c7c4:	30 09       	mov	r9,0
8000c7c6:	fb 69 06 bb 	st.b	sp[1723],r9
8000c7ca:	0a 99       	mov	r9,r5
8000c7cc:	a7 d9       	cbr	r9,0x7
8000c7ce:	40 2b       	lddsp	r11,sp[0x8]
8000c7d0:	40 16       	lddsp	r6,sp[0x4]
8000c7d2:	58 0b       	cp.w	r11,0
8000c7d4:	5f 1a       	srne	r10
8000c7d6:	f2 05 17 40 	movge	r5,r9
8000c7da:	fa c2 f9 78 	sub	r2,sp,-1672
8000c7de:	40 09       	lddsp	r9,sp[0x0]
8000c7e0:	0c 49       	or	r9,r6
8000c7e2:	5f 19       	srne	r9
8000c7e4:	f5 e9 10 09 	or	r9,r10,r9
8000c7e8:	c5 c0       	breq	8000c8a0 <_vfprintf_r+0x1628>
8000c7ea:	30 19       	mov	r9,1
8000c7ec:	f2 08 18 00 	cp.b	r8,r9
8000c7f0:	c0 60       	breq	8000c7fc <_vfprintf_r+0x1584>
8000c7f2:	30 29       	mov	r9,2
8000c7f4:	f2 08 18 00 	cp.b	r8,r9
8000c7f8:	c0 41       	brne	8000c800 <_vfprintf_r+0x1588>
8000c7fa:	c3 c8       	rjmp	8000c872 <_vfprintf_r+0x15fa>
8000c7fc:	04 96       	mov	r6,r2
8000c7fe:	c3 08       	rjmp	8000c85e <_vfprintf_r+0x15e6>
8000c800:	04 96       	mov	r6,r2
8000c802:	fa e8 00 00 	ld.d	r8,sp[0]
8000c806:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000c80a:	2d 0a       	sub	r10,-48
8000c80c:	0c fa       	st.b	--r6,r10
8000c80e:	f0 0b 16 03 	lsr	r11,r8,0x3
8000c812:	f2 0c 16 03 	lsr	r12,r9,0x3
8000c816:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000c81a:	18 99       	mov	r9,r12
8000c81c:	16 98       	mov	r8,r11
8000c81e:	58 08       	cp.w	r8,0
8000c820:	5c 29       	cpc	r9
8000c822:	cf 21       	brne	8000c806 <_vfprintf_r+0x158e>
8000c824:	fa e9 00 00 	st.d	sp[0],r8
8000c828:	ed b5 00 00 	bld	r5,0x0
8000c82c:	c4 51       	brne	8000c8b6 <_vfprintf_r+0x163e>
8000c82e:	33 09       	mov	r9,48
8000c830:	f2 0a 18 00 	cp.b	r10,r9
8000c834:	c4 10       	breq	8000c8b6 <_vfprintf_r+0x163e>
8000c836:	0c f9       	st.b	--r6,r9
8000c838:	c3 f8       	rjmp	8000c8b6 <_vfprintf_r+0x163e>
8000c83a:	fa ea 00 00 	ld.d	r10,sp[0]
8000c83e:	30 a8       	mov	r8,10
8000c840:	30 09       	mov	r9,0
8000c842:	e0 a0 1a 1b 	rcall	8000fc78 <__avr32_umod64>
8000c846:	30 a8       	mov	r8,10
8000c848:	2d 0a       	sub	r10,-48
8000c84a:	30 09       	mov	r9,0
8000c84c:	ac 8a       	st.b	r6[0x0],r10
8000c84e:	fa ea 00 00 	ld.d	r10,sp[0]
8000c852:	e0 a0 18 e1 	rcall	8000fa14 <__avr32_udiv64>
8000c856:	16 99       	mov	r9,r11
8000c858:	14 98       	mov	r8,r10
8000c85a:	fa e9 00 00 	st.d	sp[0],r8
8000c85e:	20 16       	sub	r6,1
8000c860:	fa ea 00 00 	ld.d	r10,sp[0]
8000c864:	58 9a       	cp.w	r10,9
8000c866:	5c 2b       	cpc	r11
8000c868:	fe 9b ff e9 	brhi	8000c83a <_vfprintf_r+0x15c2>
8000c86c:	1b f8       	ld.ub	r8,sp[0x7]
8000c86e:	2d 08       	sub	r8,-48
8000c870:	c2 08       	rjmp	8000c8b0 <_vfprintf_r+0x1638>
8000c872:	04 96       	mov	r6,r2
8000c874:	fa e8 00 00 	ld.d	r8,sp[0]
8000c878:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000c87c:	40 de       	lddsp	lr,sp[0x34]
8000c87e:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000c882:	0c fa       	st.b	--r6,r10
8000c884:	f2 0b 16 04 	lsr	r11,r9,0x4
8000c888:	f0 0a 16 04 	lsr	r10,r8,0x4
8000c88c:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000c890:	16 99       	mov	r9,r11
8000c892:	14 98       	mov	r8,r10
8000c894:	58 08       	cp.w	r8,0
8000c896:	5c 29       	cpc	r9
8000c898:	cf 01       	brne	8000c878 <_vfprintf_r+0x1600>
8000c89a:	fa e9 00 00 	st.d	sp[0],r8
8000c89e:	c0 c8       	rjmp	8000c8b6 <_vfprintf_r+0x163e>
8000c8a0:	58 08       	cp.w	r8,0
8000c8a2:	c0 91       	brne	8000c8b4 <_vfprintf_r+0x163c>
8000c8a4:	ed b5 00 00 	bld	r5,0x0
8000c8a8:	c0 61       	brne	8000c8b4 <_vfprintf_r+0x163c>
8000c8aa:	fa c6 f9 79 	sub	r6,sp,-1671
8000c8ae:	33 08       	mov	r8,48
8000c8b0:	ac 88       	st.b	r6[0x0],r8
8000c8b2:	c0 28       	rjmp	8000c8b6 <_vfprintf_r+0x163e>
8000c8b4:	04 96       	mov	r6,r2
8000c8b6:	0c 12       	sub	r2,r6
8000c8b8:	c1 c8       	rjmp	8000c8f0 <_vfprintf_r+0x1678>
8000c8ba:	50 a7       	stdsp	sp[0x28],r7
8000c8bc:	50 80       	stdsp	sp[0x20],r0
8000c8be:	40 93       	lddsp	r3,sp[0x24]
8000c8c0:	0c 97       	mov	r7,r6
8000c8c2:	10 90       	mov	r0,r8
8000c8c4:	04 94       	mov	r4,r2
8000c8c6:	40 41       	lddsp	r1,sp[0x10]
8000c8c8:	58 08       	cp.w	r8,0
8000c8ca:	e0 80 04 51 	breq	8000d16c <_vfprintf_r+0x1ef4>
8000c8ce:	fb 68 06 60 	st.b	sp[1632],r8
8000c8d2:	30 0c       	mov	r12,0
8000c8d4:	30 08       	mov	r8,0
8000c8d6:	30 12       	mov	r2,1
8000c8d8:	fb 68 06 bb 	st.b	sp[1723],r8
8000c8dc:	50 2c       	stdsp	sp[0x8],r12
8000c8de:	fa c6 f9 a0 	sub	r6,sp,-1632
8000c8e2:	c0 78       	rjmp	8000c8f0 <_vfprintf_r+0x1678>
8000c8e4:	30 0b       	mov	r11,0
8000c8e6:	50 2b       	stdsp	sp[0x8],r11
8000c8e8:	c0 48       	rjmp	8000c8f0 <_vfprintf_r+0x1678>
8000c8ea:	40 22       	lddsp	r2,sp[0x8]
8000c8ec:	30 0a       	mov	r10,0
8000c8ee:	50 2a       	stdsp	sp[0x8],r10
8000c8f0:	40 29       	lddsp	r9,sp[0x8]
8000c8f2:	e4 09 0c 49 	max	r9,r2,r9
8000c8f6:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c8fa:	50 39       	stdsp	sp[0xc],r9
8000c8fc:	0a 9e       	mov	lr,r5
8000c8fe:	30 09       	mov	r9,0
8000c900:	e2 1e 00 02 	andl	lr,0x2,COH
8000c904:	f2 08 18 00 	cp.b	r8,r9
8000c908:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000c90c:	f7 b8 01 ff 	subne	r8,-1
8000c910:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000c914:	0a 9b       	mov	r11,r5
8000c916:	58 0e       	cp.w	lr,0
8000c918:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000c91c:	f7 bc 01 fe 	subne	r12,-2
8000c920:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000c924:	e2 1b 00 84 	andl	r11,0x84,COH
8000c928:	50 fe       	stdsp	sp[0x3c],lr
8000c92a:	50 9b       	stdsp	sp[0x24],r11
8000c92c:	c4 51       	brne	8000c9b6 <_vfprintf_r+0x173e>
8000c92e:	40 8a       	lddsp	r10,sp[0x20]
8000c930:	40 39       	lddsp	r9,sp[0xc]
8000c932:	12 1a       	sub	r10,r9
8000c934:	50 4a       	stdsp	sp[0x10],r10
8000c936:	58 0a       	cp.w	r10,0
8000c938:	e0 89 00 1f 	brgt	8000c976 <_vfprintf_r+0x16fe>
8000c93c:	c3 d8       	rjmp	8000c9b6 <_vfprintf_r+0x173e>
8000c93e:	2f 09       	sub	r9,-16
8000c940:	2f f8       	sub	r8,-1
8000c942:	4c ee       	lddpc	lr,8000ca78 <_vfprintf_r+0x1800>
8000c944:	31 0c       	mov	r12,16
8000c946:	fb 49 06 90 	st.w	sp[1680],r9
8000c94a:	87 0e       	st.w	r3[0x0],lr
8000c94c:	87 1c       	st.w	r3[0x4],r12
8000c94e:	fb 48 06 8c 	st.w	sp[1676],r8
8000c952:	58 78       	cp.w	r8,7
8000c954:	e0 89 00 04 	brgt	8000c95c <_vfprintf_r+0x16e4>
8000c958:	2f 83       	sub	r3,-8
8000c95a:	c0 b8       	rjmp	8000c970 <_vfprintf_r+0x16f8>
8000c95c:	fa ca f9 78 	sub	r10,sp,-1672
8000c960:	02 9b       	mov	r11,r1
8000c962:	08 9c       	mov	r12,r4
8000c964:	fe b0 f4 7c 	rcall	8000b25c <__sprint_r>
8000c968:	e0 81 04 13 	brne	8000d18e <_vfprintf_r+0x1f16>
8000c96c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c970:	40 4b       	lddsp	r11,sp[0x10]
8000c972:	21 0b       	sub	r11,16
8000c974:	50 4b       	stdsp	sp[0x10],r11
8000c976:	fa f9 06 90 	ld.w	r9,sp[1680]
8000c97a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c97e:	4b fa       	lddpc	r10,8000ca78 <_vfprintf_r+0x1800>
8000c980:	40 4e       	lddsp	lr,sp[0x10]
8000c982:	59 0e       	cp.w	lr,16
8000c984:	fe 99 ff dd 	brgt	8000c93e <_vfprintf_r+0x16c6>
8000c988:	1c 09       	add	r9,lr
8000c98a:	2f f8       	sub	r8,-1
8000c98c:	87 0a       	st.w	r3[0x0],r10
8000c98e:	fb 49 06 90 	st.w	sp[1680],r9
8000c992:	87 1e       	st.w	r3[0x4],lr
8000c994:	fb 48 06 8c 	st.w	sp[1676],r8
8000c998:	58 78       	cp.w	r8,7
8000c99a:	e0 89 00 04 	brgt	8000c9a2 <_vfprintf_r+0x172a>
8000c99e:	2f 83       	sub	r3,-8
8000c9a0:	c0 b8       	rjmp	8000c9b6 <_vfprintf_r+0x173e>
8000c9a2:	fa ca f9 78 	sub	r10,sp,-1672
8000c9a6:	02 9b       	mov	r11,r1
8000c9a8:	08 9c       	mov	r12,r4
8000c9aa:	fe b0 f4 59 	rcall	8000b25c <__sprint_r>
8000c9ae:	e0 81 03 f0 	brne	8000d18e <_vfprintf_r+0x1f16>
8000c9b2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c9b6:	30 09       	mov	r9,0
8000c9b8:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000c9bc:	f2 08 18 00 	cp.b	r8,r9
8000c9c0:	c1 f0       	breq	8000c9fe <_vfprintf_r+0x1786>
8000c9c2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c9c6:	fa c9 f9 45 	sub	r9,sp,-1723
8000c9ca:	2f f8       	sub	r8,-1
8000c9cc:	87 09       	st.w	r3[0x0],r9
8000c9ce:	fb 48 06 90 	st.w	sp[1680],r8
8000c9d2:	30 19       	mov	r9,1
8000c9d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c9d8:	87 19       	st.w	r3[0x4],r9
8000c9da:	2f f8       	sub	r8,-1
8000c9dc:	fb 48 06 8c 	st.w	sp[1676],r8
8000c9e0:	58 78       	cp.w	r8,7
8000c9e2:	e0 89 00 04 	brgt	8000c9ea <_vfprintf_r+0x1772>
8000c9e6:	2f 83       	sub	r3,-8
8000c9e8:	c0 b8       	rjmp	8000c9fe <_vfprintf_r+0x1786>
8000c9ea:	fa ca f9 78 	sub	r10,sp,-1672
8000c9ee:	02 9b       	mov	r11,r1
8000c9f0:	08 9c       	mov	r12,r4
8000c9f2:	fe b0 f4 35 	rcall	8000b25c <__sprint_r>
8000c9f6:	e0 81 03 cc 	brne	8000d18e <_vfprintf_r+0x1f16>
8000c9fa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000c9fe:	40 fc       	lddsp	r12,sp[0x3c]
8000ca00:	58 0c       	cp.w	r12,0
8000ca02:	c1 f0       	breq	8000ca40 <_vfprintf_r+0x17c8>
8000ca04:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ca08:	fa c9 f9 48 	sub	r9,sp,-1720
8000ca0c:	2f e8       	sub	r8,-2
8000ca0e:	87 09       	st.w	r3[0x0],r9
8000ca10:	fb 48 06 90 	st.w	sp[1680],r8
8000ca14:	30 29       	mov	r9,2
8000ca16:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ca1a:	87 19       	st.w	r3[0x4],r9
8000ca1c:	2f f8       	sub	r8,-1
8000ca1e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca22:	58 78       	cp.w	r8,7
8000ca24:	e0 89 00 04 	brgt	8000ca2c <_vfprintf_r+0x17b4>
8000ca28:	2f 83       	sub	r3,-8
8000ca2a:	c0 b8       	rjmp	8000ca40 <_vfprintf_r+0x17c8>
8000ca2c:	fa ca f9 78 	sub	r10,sp,-1672
8000ca30:	02 9b       	mov	r11,r1
8000ca32:	08 9c       	mov	r12,r4
8000ca34:	fe b0 f4 14 	rcall	8000b25c <__sprint_r>
8000ca38:	e0 81 03 ab 	brne	8000d18e <_vfprintf_r+0x1f16>
8000ca3c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca40:	40 9b       	lddsp	r11,sp[0x24]
8000ca42:	e0 4b 00 80 	cp.w	r11,128
8000ca46:	c4 a1       	brne	8000cada <_vfprintf_r+0x1862>
8000ca48:	40 8a       	lddsp	r10,sp[0x20]
8000ca4a:	40 39       	lddsp	r9,sp[0xc]
8000ca4c:	12 1a       	sub	r10,r9
8000ca4e:	50 4a       	stdsp	sp[0x10],r10
8000ca50:	58 0a       	cp.w	r10,0
8000ca52:	e0 89 00 24 	brgt	8000ca9a <_vfprintf_r+0x1822>
8000ca56:	c4 28       	rjmp	8000cada <_vfprintf_r+0x1862>
8000ca58:	2f 09       	sub	r9,-16
8000ca5a:	2f f8       	sub	r8,-1
8000ca5c:	48 8e       	lddpc	lr,8000ca7c <_vfprintf_r+0x1804>
8000ca5e:	31 0c       	mov	r12,16
8000ca60:	fb 49 06 90 	st.w	sp[1680],r9
8000ca64:	87 0e       	st.w	r3[0x0],lr
8000ca66:	87 1c       	st.w	r3[0x4],r12
8000ca68:	fb 48 06 8c 	st.w	sp[1676],r8
8000ca6c:	58 78       	cp.w	r8,7
8000ca6e:	e0 89 00 09 	brgt	8000ca80 <_vfprintf_r+0x1808>
8000ca72:	2f 83       	sub	r3,-8
8000ca74:	c1 08       	rjmp	8000ca94 <_vfprintf_r+0x181c>
8000ca76:	d7 03       	nop
8000ca78:	80 01       	ld.sh	r1,r0[0x0]
8000ca7a:	9b 60       	st.w	sp[0x18],r0
8000ca7c:	80 01       	ld.sh	r1,r0[0x0]
8000ca7e:	9b 70       	st.w	sp[0x1c],r0
8000ca80:	fa ca f9 78 	sub	r10,sp,-1672
8000ca84:	02 9b       	mov	r11,r1
8000ca86:	08 9c       	mov	r12,r4
8000ca88:	fe b0 f3 ea 	rcall	8000b25c <__sprint_r>
8000ca8c:	e0 81 03 81 	brne	8000d18e <_vfprintf_r+0x1f16>
8000ca90:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ca94:	40 4b       	lddsp	r11,sp[0x10]
8000ca96:	21 0b       	sub	r11,16
8000ca98:	50 4b       	stdsp	sp[0x10],r11
8000ca9a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ca9e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000caa2:	4c 6a       	lddpc	r10,8000cbb8 <_vfprintf_r+0x1940>
8000caa4:	40 4e       	lddsp	lr,sp[0x10]
8000caa6:	59 0e       	cp.w	lr,16
8000caa8:	fe 99 ff d8 	brgt	8000ca58 <_vfprintf_r+0x17e0>
8000caac:	1c 09       	add	r9,lr
8000caae:	2f f8       	sub	r8,-1
8000cab0:	87 0a       	st.w	r3[0x0],r10
8000cab2:	fb 49 06 90 	st.w	sp[1680],r9
8000cab6:	87 1e       	st.w	r3[0x4],lr
8000cab8:	fb 48 06 8c 	st.w	sp[1676],r8
8000cabc:	58 78       	cp.w	r8,7
8000cabe:	e0 89 00 04 	brgt	8000cac6 <_vfprintf_r+0x184e>
8000cac2:	2f 83       	sub	r3,-8
8000cac4:	c0 b8       	rjmp	8000cada <_vfprintf_r+0x1862>
8000cac6:	fa ca f9 78 	sub	r10,sp,-1672
8000caca:	02 9b       	mov	r11,r1
8000cacc:	08 9c       	mov	r12,r4
8000cace:	fe b0 f3 c7 	rcall	8000b25c <__sprint_r>
8000cad2:	e0 81 03 5e 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cad6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cada:	40 2c       	lddsp	r12,sp[0x8]
8000cadc:	04 1c       	sub	r12,r2
8000cade:	50 2c       	stdsp	sp[0x8],r12
8000cae0:	58 0c       	cp.w	r12,0
8000cae2:	e0 89 00 1f 	brgt	8000cb20 <_vfprintf_r+0x18a8>
8000cae6:	c3 d8       	rjmp	8000cb60 <_vfprintf_r+0x18e8>
8000cae8:	2f 09       	sub	r9,-16
8000caea:	2f f8       	sub	r8,-1
8000caec:	4b 3b       	lddpc	r11,8000cbb8 <_vfprintf_r+0x1940>
8000caee:	31 0a       	mov	r10,16
8000caf0:	fb 49 06 90 	st.w	sp[1680],r9
8000caf4:	87 0b       	st.w	r3[0x0],r11
8000caf6:	87 1a       	st.w	r3[0x4],r10
8000caf8:	fb 48 06 8c 	st.w	sp[1676],r8
8000cafc:	58 78       	cp.w	r8,7
8000cafe:	e0 89 00 04 	brgt	8000cb06 <_vfprintf_r+0x188e>
8000cb02:	2f 83       	sub	r3,-8
8000cb04:	c0 b8       	rjmp	8000cb1a <_vfprintf_r+0x18a2>
8000cb06:	fa ca f9 78 	sub	r10,sp,-1672
8000cb0a:	02 9b       	mov	r11,r1
8000cb0c:	08 9c       	mov	r12,r4
8000cb0e:	fe b0 f3 a7 	rcall	8000b25c <__sprint_r>
8000cb12:	e0 81 03 3e 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cb16:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb1a:	40 29       	lddsp	r9,sp[0x8]
8000cb1c:	21 09       	sub	r9,16
8000cb1e:	50 29       	stdsp	sp[0x8],r9
8000cb20:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cb24:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cb28:	4a 4a       	lddpc	r10,8000cbb8 <_vfprintf_r+0x1940>
8000cb2a:	40 2e       	lddsp	lr,sp[0x8]
8000cb2c:	59 0e       	cp.w	lr,16
8000cb2e:	fe 99 ff dd 	brgt	8000cae8 <_vfprintf_r+0x1870>
8000cb32:	1c 09       	add	r9,lr
8000cb34:	2f f8       	sub	r8,-1
8000cb36:	87 0a       	st.w	r3[0x0],r10
8000cb38:	fb 49 06 90 	st.w	sp[1680],r9
8000cb3c:	87 1e       	st.w	r3[0x4],lr
8000cb3e:	fb 48 06 8c 	st.w	sp[1676],r8
8000cb42:	58 78       	cp.w	r8,7
8000cb44:	e0 89 00 04 	brgt	8000cb4c <_vfprintf_r+0x18d4>
8000cb48:	2f 83       	sub	r3,-8
8000cb4a:	c0 b8       	rjmp	8000cb60 <_vfprintf_r+0x18e8>
8000cb4c:	fa ca f9 78 	sub	r10,sp,-1672
8000cb50:	02 9b       	mov	r11,r1
8000cb52:	08 9c       	mov	r12,r4
8000cb54:	fe b0 f3 84 	rcall	8000b25c <__sprint_r>
8000cb58:	e0 81 03 1b 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cb5c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cb60:	ed b5 00 08 	bld	r5,0x8
8000cb64:	c0 b0       	breq	8000cb7a <_vfprintf_r+0x1902>
8000cb66:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cb6a:	87 12       	st.w	r3[0x4],r2
8000cb6c:	87 06       	st.w	r3[0x0],r6
8000cb6e:	f0 02 00 02 	add	r2,r8,r2
8000cb72:	fb 42 06 90 	st.w	sp[1680],r2
8000cb76:	e0 8f 01 d5 	bral	8000cf20 <_vfprintf_r+0x1ca8>
8000cb7a:	e0 40 00 65 	cp.w	r0,101
8000cb7e:	e0 8a 01 d7 	brle	8000cf2c <_vfprintf_r+0x1cb4>
8000cb82:	30 08       	mov	r8,0
8000cb84:	30 09       	mov	r9,0
8000cb86:	40 5b       	lddsp	r11,sp[0x14]
8000cb88:	40 7a       	lddsp	r10,sp[0x1c]
8000cb8a:	e0 a0 15 3e 	rcall	8000f606 <__avr32_f64_cmp_eq>
8000cb8e:	c7 a0       	breq	8000cc82 <_vfprintf_r+0x1a0a>
8000cb90:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cb94:	48 a9       	lddpc	r9,8000cbbc <_vfprintf_r+0x1944>
8000cb96:	2f f8       	sub	r8,-1
8000cb98:	87 09       	st.w	r3[0x0],r9
8000cb9a:	fb 48 06 90 	st.w	sp[1680],r8
8000cb9e:	30 19       	mov	r9,1
8000cba0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cba4:	87 19       	st.w	r3[0x4],r9
8000cba6:	2f f8       	sub	r8,-1
8000cba8:	fb 48 06 8c 	st.w	sp[1676],r8
8000cbac:	58 78       	cp.w	r8,7
8000cbae:	e0 89 00 09 	brgt	8000cbc0 <_vfprintf_r+0x1948>
8000cbb2:	2f 83       	sub	r3,-8
8000cbb4:	c1 08       	rjmp	8000cbd4 <_vfprintf_r+0x195c>
8000cbb6:	d7 03       	nop
8000cbb8:	80 01       	ld.sh	r1,r0[0x0]
8000cbba:	9b 70       	st.w	sp[0x1c],r0
8000cbbc:	80 01       	ld.sh	r1,r0[0x0]
8000cbbe:	9b 5c       	st.w	sp[0x14],r12
8000cbc0:	fa ca f9 78 	sub	r10,sp,-1672
8000cbc4:	02 9b       	mov	r11,r1
8000cbc6:	08 9c       	mov	r12,r4
8000cbc8:	fe b0 f3 4a 	rcall	8000b25c <__sprint_r>
8000cbcc:	e0 81 02 e1 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cbd0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cbd4:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cbd8:	40 6c       	lddsp	r12,sp[0x18]
8000cbda:	18 38       	cp.w	r8,r12
8000cbdc:	c0 55       	brlt	8000cbe6 <_vfprintf_r+0x196e>
8000cbde:	ed b5 00 00 	bld	r5,0x0
8000cbe2:	e0 81 02 69 	brne	8000d0b4 <_vfprintf_r+0x1e3c>
8000cbe6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cbea:	2f f8       	sub	r8,-1
8000cbec:	40 cb       	lddsp	r11,sp[0x30]
8000cbee:	fb 48 06 90 	st.w	sp[1680],r8
8000cbf2:	30 19       	mov	r9,1
8000cbf4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cbf8:	87 0b       	st.w	r3[0x0],r11
8000cbfa:	2f f8       	sub	r8,-1
8000cbfc:	87 19       	st.w	r3[0x4],r9
8000cbfe:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc02:	58 78       	cp.w	r8,7
8000cc04:	e0 89 00 04 	brgt	8000cc0c <_vfprintf_r+0x1994>
8000cc08:	2f 83       	sub	r3,-8
8000cc0a:	c0 b8       	rjmp	8000cc20 <_vfprintf_r+0x19a8>
8000cc0c:	fa ca f9 78 	sub	r10,sp,-1672
8000cc10:	02 9b       	mov	r11,r1
8000cc12:	08 9c       	mov	r12,r4
8000cc14:	fe b0 f3 24 	rcall	8000b25c <__sprint_r>
8000cc18:	e0 81 02 bb 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cc1c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc20:	40 66       	lddsp	r6,sp[0x18]
8000cc22:	20 16       	sub	r6,1
8000cc24:	58 06       	cp.w	r6,0
8000cc26:	e0 89 00 1d 	brgt	8000cc60 <_vfprintf_r+0x19e8>
8000cc2a:	e0 8f 02 45 	bral	8000d0b4 <_vfprintf_r+0x1e3c>
8000cc2e:	2f 09       	sub	r9,-16
8000cc30:	2f f8       	sub	r8,-1
8000cc32:	fb 49 06 90 	st.w	sp[1680],r9
8000cc36:	87 02       	st.w	r3[0x0],r2
8000cc38:	87 10       	st.w	r3[0x4],r0
8000cc3a:	fb 48 06 8c 	st.w	sp[1676],r8
8000cc3e:	58 78       	cp.w	r8,7
8000cc40:	e0 89 00 04 	brgt	8000cc48 <_vfprintf_r+0x19d0>
8000cc44:	2f 83       	sub	r3,-8
8000cc46:	c0 b8       	rjmp	8000cc5c <_vfprintf_r+0x19e4>
8000cc48:	fa ca f9 78 	sub	r10,sp,-1672
8000cc4c:	02 9b       	mov	r11,r1
8000cc4e:	08 9c       	mov	r12,r4
8000cc50:	fe b0 f3 06 	rcall	8000b25c <__sprint_r>
8000cc54:	e0 81 02 9d 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cc58:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cc5c:	21 06       	sub	r6,16
8000cc5e:	c0 38       	rjmp	8000cc64 <_vfprintf_r+0x19ec>
8000cc60:	4d 22       	lddpc	r2,8000cda8 <_vfprintf_r+0x1b30>
8000cc62:	31 00       	mov	r0,16
8000cc64:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cc68:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cc6c:	4c fa       	lddpc	r10,8000cda8 <_vfprintf_r+0x1b30>
8000cc6e:	59 06       	cp.w	r6,16
8000cc70:	fe 99 ff df 	brgt	8000cc2e <_vfprintf_r+0x19b6>
8000cc74:	0c 09       	add	r9,r6
8000cc76:	87 0a       	st.w	r3[0x0],r10
8000cc78:	fb 49 06 90 	st.w	sp[1680],r9
8000cc7c:	2f f8       	sub	r8,-1
8000cc7e:	87 16       	st.w	r3[0x4],r6
8000cc80:	c5 39       	rjmp	8000cf26 <_vfprintf_r+0x1cae>
8000cc82:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000cc86:	58 0a       	cp.w	r10,0
8000cc88:	e0 89 00 94 	brgt	8000cdb0 <_vfprintf_r+0x1b38>
8000cc8c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cc90:	4c 79       	lddpc	r9,8000cdac <_vfprintf_r+0x1b34>
8000cc92:	2f f8       	sub	r8,-1
8000cc94:	87 09       	st.w	r3[0x0],r9
8000cc96:	fb 48 06 90 	st.w	sp[1680],r8
8000cc9a:	30 19       	mov	r9,1
8000cc9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cca0:	87 19       	st.w	r3[0x4],r9
8000cca2:	2f f8       	sub	r8,-1
8000cca4:	fb 48 06 8c 	st.w	sp[1676],r8
8000cca8:	58 78       	cp.w	r8,7
8000ccaa:	e0 89 00 04 	brgt	8000ccb2 <_vfprintf_r+0x1a3a>
8000ccae:	2f 83       	sub	r3,-8
8000ccb0:	c0 b8       	rjmp	8000ccc6 <_vfprintf_r+0x1a4e>
8000ccb2:	fa ca f9 78 	sub	r10,sp,-1672
8000ccb6:	02 9b       	mov	r11,r1
8000ccb8:	08 9c       	mov	r12,r4
8000ccba:	fe b0 f2 d1 	rcall	8000b25c <__sprint_r>
8000ccbe:	e0 81 02 68 	brne	8000d18e <_vfprintf_r+0x1f16>
8000ccc2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ccc6:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ccca:	58 08       	cp.w	r8,0
8000cccc:	c0 81       	brne	8000ccdc <_vfprintf_r+0x1a64>
8000ccce:	40 6a       	lddsp	r10,sp[0x18]
8000ccd0:	58 0a       	cp.w	r10,0
8000ccd2:	c0 51       	brne	8000ccdc <_vfprintf_r+0x1a64>
8000ccd4:	ed b5 00 00 	bld	r5,0x0
8000ccd8:	e0 81 01 ee 	brne	8000d0b4 <_vfprintf_r+0x1e3c>
8000ccdc:	40 c9       	lddsp	r9,sp[0x30]
8000ccde:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cce2:	2f f8       	sub	r8,-1
8000cce4:	87 09       	st.w	r3[0x0],r9
8000cce6:	fb 48 06 90 	st.w	sp[1680],r8
8000ccea:	30 19       	mov	r9,1
8000ccec:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ccf0:	87 19       	st.w	r3[0x4],r9
8000ccf2:	2f f8       	sub	r8,-1
8000ccf4:	fb 48 06 8c 	st.w	sp[1676],r8
8000ccf8:	58 78       	cp.w	r8,7
8000ccfa:	e0 89 00 04 	brgt	8000cd02 <_vfprintf_r+0x1a8a>
8000ccfe:	2f 83       	sub	r3,-8
8000cd00:	c0 b8       	rjmp	8000cd16 <_vfprintf_r+0x1a9e>
8000cd02:	fa ca f9 78 	sub	r10,sp,-1672
8000cd06:	02 9b       	mov	r11,r1
8000cd08:	08 9c       	mov	r12,r4
8000cd0a:	fe b0 f2 a9 	rcall	8000b25c <__sprint_r>
8000cd0e:	e0 81 02 40 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cd12:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd16:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000cd1a:	5c 32       	neg	r2
8000cd1c:	58 02       	cp.w	r2,0
8000cd1e:	e0 89 00 1d 	brgt	8000cd58 <_vfprintf_r+0x1ae0>
8000cd22:	c3 b8       	rjmp	8000cd98 <_vfprintf_r+0x1b20>
8000cd24:	2f 09       	sub	r9,-16
8000cd26:	2f f8       	sub	r8,-1
8000cd28:	31 0e       	mov	lr,16
8000cd2a:	fb 49 06 90 	st.w	sp[1680],r9
8000cd2e:	87 00       	st.w	r3[0x0],r0
8000cd30:	87 1e       	st.w	r3[0x4],lr
8000cd32:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd36:	58 78       	cp.w	r8,7
8000cd38:	e0 89 00 04 	brgt	8000cd40 <_vfprintf_r+0x1ac8>
8000cd3c:	2f 83       	sub	r3,-8
8000cd3e:	c0 b8       	rjmp	8000cd54 <_vfprintf_r+0x1adc>
8000cd40:	fa ca f9 78 	sub	r10,sp,-1672
8000cd44:	02 9b       	mov	r11,r1
8000cd46:	08 9c       	mov	r12,r4
8000cd48:	fe b0 f2 8a 	rcall	8000b25c <__sprint_r>
8000cd4c:	e0 81 02 21 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cd50:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd54:	21 02       	sub	r2,16
8000cd56:	c0 28       	rjmp	8000cd5a <_vfprintf_r+0x1ae2>
8000cd58:	49 40       	lddpc	r0,8000cda8 <_vfprintf_r+0x1b30>
8000cd5a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cd5e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cd62:	49 2a       	lddpc	r10,8000cda8 <_vfprintf_r+0x1b30>
8000cd64:	59 02       	cp.w	r2,16
8000cd66:	fe 99 ff df 	brgt	8000cd24 <_vfprintf_r+0x1aac>
8000cd6a:	04 09       	add	r9,r2
8000cd6c:	2f f8       	sub	r8,-1
8000cd6e:	87 0a       	st.w	r3[0x0],r10
8000cd70:	fb 49 06 90 	st.w	sp[1680],r9
8000cd74:	87 12       	st.w	r3[0x4],r2
8000cd76:	fb 48 06 8c 	st.w	sp[1676],r8
8000cd7a:	58 78       	cp.w	r8,7
8000cd7c:	e0 89 00 04 	brgt	8000cd84 <_vfprintf_r+0x1b0c>
8000cd80:	2f 83       	sub	r3,-8
8000cd82:	c0 b8       	rjmp	8000cd98 <_vfprintf_r+0x1b20>
8000cd84:	fa ca f9 78 	sub	r10,sp,-1672
8000cd88:	02 9b       	mov	r11,r1
8000cd8a:	08 9c       	mov	r12,r4
8000cd8c:	fe b0 f2 68 	rcall	8000b25c <__sprint_r>
8000cd90:	e0 81 01 ff 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cd94:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cd98:	40 6c       	lddsp	r12,sp[0x18]
8000cd9a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cd9e:	87 06       	st.w	r3[0x0],r6
8000cda0:	87 1c       	st.w	r3[0x4],r12
8000cda2:	18 08       	add	r8,r12
8000cda4:	cb c8       	rjmp	8000cf1c <_vfprintf_r+0x1ca4>
8000cda6:	d7 03       	nop
8000cda8:	80 01       	ld.sh	r1,r0[0x0]
8000cdaa:	9b 70       	st.w	sp[0x1c],r0
8000cdac:	80 01       	ld.sh	r1,r0[0x0]
8000cdae:	9b 5c       	st.w	sp[0x14],r12
8000cdb0:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cdb4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cdb8:	40 6b       	lddsp	r11,sp[0x18]
8000cdba:	16 3a       	cp.w	r10,r11
8000cdbc:	c6 d5       	brlt	8000ce96 <_vfprintf_r+0x1c1e>
8000cdbe:	16 09       	add	r9,r11
8000cdc0:	2f f8       	sub	r8,-1
8000cdc2:	87 06       	st.w	r3[0x0],r6
8000cdc4:	fb 49 06 90 	st.w	sp[1680],r9
8000cdc8:	87 1b       	st.w	r3[0x4],r11
8000cdca:	fb 48 06 8c 	st.w	sp[1676],r8
8000cdce:	58 78       	cp.w	r8,7
8000cdd0:	e0 89 00 04 	brgt	8000cdd8 <_vfprintf_r+0x1b60>
8000cdd4:	2f 83       	sub	r3,-8
8000cdd6:	c0 b8       	rjmp	8000cdec <_vfprintf_r+0x1b74>
8000cdd8:	fa ca f9 78 	sub	r10,sp,-1672
8000cddc:	02 9b       	mov	r11,r1
8000cdde:	08 9c       	mov	r12,r4
8000cde0:	fe b0 f2 3e 	rcall	8000b25c <__sprint_r>
8000cde4:	e0 81 01 d5 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cde8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cdec:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000cdf0:	40 6a       	lddsp	r10,sp[0x18]
8000cdf2:	14 16       	sub	r6,r10
8000cdf4:	58 06       	cp.w	r6,0
8000cdf6:	e0 89 00 1c 	brgt	8000ce2e <_vfprintf_r+0x1bb6>
8000cdfa:	c3 b8       	rjmp	8000ce70 <_vfprintf_r+0x1bf8>
8000cdfc:	2f 09       	sub	r9,-16
8000cdfe:	2f f8       	sub	r8,-1
8000ce00:	fb 49 06 90 	st.w	sp[1680],r9
8000ce04:	87 02       	st.w	r3[0x0],r2
8000ce06:	87 10       	st.w	r3[0x4],r0
8000ce08:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce0c:	58 78       	cp.w	r8,7
8000ce0e:	e0 89 00 04 	brgt	8000ce16 <_vfprintf_r+0x1b9e>
8000ce12:	2f 83       	sub	r3,-8
8000ce14:	c0 b8       	rjmp	8000ce2a <_vfprintf_r+0x1bb2>
8000ce16:	fa ca f9 78 	sub	r10,sp,-1672
8000ce1a:	02 9b       	mov	r11,r1
8000ce1c:	08 9c       	mov	r12,r4
8000ce1e:	fe b0 f2 1f 	rcall	8000b25c <__sprint_r>
8000ce22:	e0 81 01 b6 	brne	8000d18e <_vfprintf_r+0x1f16>
8000ce26:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ce2a:	21 06       	sub	r6,16
8000ce2c:	c0 38       	rjmp	8000ce32 <_vfprintf_r+0x1bba>
8000ce2e:	4d c2       	lddpc	r2,8000cf9c <_vfprintf_r+0x1d24>
8000ce30:	31 00       	mov	r0,16
8000ce32:	fa f9 06 90 	ld.w	r9,sp[1680]
8000ce36:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ce3a:	4d 9a       	lddpc	r10,8000cf9c <_vfprintf_r+0x1d24>
8000ce3c:	59 06       	cp.w	r6,16
8000ce3e:	fe 99 ff df 	brgt	8000cdfc <_vfprintf_r+0x1b84>
8000ce42:	0c 09       	add	r9,r6
8000ce44:	2f f8       	sub	r8,-1
8000ce46:	87 0a       	st.w	r3[0x0],r10
8000ce48:	fb 49 06 90 	st.w	sp[1680],r9
8000ce4c:	87 16       	st.w	r3[0x4],r6
8000ce4e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce52:	58 78       	cp.w	r8,7
8000ce54:	e0 89 00 04 	brgt	8000ce5c <_vfprintf_r+0x1be4>
8000ce58:	2f 83       	sub	r3,-8
8000ce5a:	c0 b8       	rjmp	8000ce70 <_vfprintf_r+0x1bf8>
8000ce5c:	fa ca f9 78 	sub	r10,sp,-1672
8000ce60:	02 9b       	mov	r11,r1
8000ce62:	08 9c       	mov	r12,r4
8000ce64:	fe b0 f1 fc 	rcall	8000b25c <__sprint_r>
8000ce68:	e0 81 01 93 	brne	8000d18e <_vfprintf_r+0x1f16>
8000ce6c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ce70:	ed b5 00 00 	bld	r5,0x0
8000ce74:	e0 81 01 20 	brne	8000d0b4 <_vfprintf_r+0x1e3c>
8000ce78:	40 c9       	lddsp	r9,sp[0x30]
8000ce7a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ce7e:	2f f8       	sub	r8,-1
8000ce80:	87 09       	st.w	r3[0x0],r9
8000ce82:	fb 48 06 90 	st.w	sp[1680],r8
8000ce86:	30 19       	mov	r9,1
8000ce88:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ce8c:	87 19       	st.w	r3[0x4],r9
8000ce8e:	2f f8       	sub	r8,-1
8000ce90:	fb 48 06 8c 	st.w	sp[1676],r8
8000ce94:	c0 29       	rjmp	8000d098 <_vfprintf_r+0x1e20>
8000ce96:	14 09       	add	r9,r10
8000ce98:	2f f8       	sub	r8,-1
8000ce9a:	fb 49 06 90 	st.w	sp[1680],r9
8000ce9e:	87 06       	st.w	r3[0x0],r6
8000cea0:	87 1a       	st.w	r3[0x4],r10
8000cea2:	fb 48 06 8c 	st.w	sp[1676],r8
8000cea6:	58 78       	cp.w	r8,7
8000cea8:	e0 89 00 04 	brgt	8000ceb0 <_vfprintf_r+0x1c38>
8000ceac:	2f 83       	sub	r3,-8
8000ceae:	c0 b8       	rjmp	8000cec4 <_vfprintf_r+0x1c4c>
8000ceb0:	fa ca f9 78 	sub	r10,sp,-1672
8000ceb4:	02 9b       	mov	r11,r1
8000ceb6:	08 9c       	mov	r12,r4
8000ceb8:	fe b0 f1 d2 	rcall	8000b25c <__sprint_r>
8000cebc:	e0 81 01 69 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cec0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cec4:	40 c8       	lddsp	r8,sp[0x30]
8000cec6:	87 08       	st.w	r3[0x0],r8
8000cec8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cecc:	2f f8       	sub	r8,-1
8000cece:	30 19       	mov	r9,1
8000ced0:	fb 48 06 90 	st.w	sp[1680],r8
8000ced4:	87 19       	st.w	r3[0x4],r9
8000ced6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ceda:	2f f8       	sub	r8,-1
8000cedc:	fb 48 06 8c 	st.w	sp[1676],r8
8000cee0:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000cee4:	58 78       	cp.w	r8,7
8000cee6:	e0 89 00 04 	brgt	8000ceee <_vfprintf_r+0x1c76>
8000ceea:	2f 83       	sub	r3,-8
8000ceec:	c0 b8       	rjmp	8000cf02 <_vfprintf_r+0x1c8a>
8000ceee:	fa ca f9 78 	sub	r10,sp,-1672
8000cef2:	02 9b       	mov	r11,r1
8000cef4:	08 9c       	mov	r12,r4
8000cef6:	fe b0 f1 b3 	rcall	8000b25c <__sprint_r>
8000cefa:	e0 81 01 4a 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cefe:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cf02:	04 06       	add	r6,r2
8000cf04:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000cf08:	87 06       	st.w	r3[0x0],r6
8000cf0a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000cf0e:	40 66       	lddsp	r6,sp[0x18]
8000cf10:	40 6e       	lddsp	lr,sp[0x18]
8000cf12:	10 16       	sub	r6,r8
8000cf14:	f2 08 01 08 	sub	r8,r9,r8
8000cf18:	87 16       	st.w	r3[0x4],r6
8000cf1a:	1c 08       	add	r8,lr
8000cf1c:	fb 48 06 90 	st.w	sp[1680],r8
8000cf20:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf24:	2f f8       	sub	r8,-1
8000cf26:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf2a:	cb 78       	rjmp	8000d098 <_vfprintf_r+0x1e20>
8000cf2c:	40 6c       	lddsp	r12,sp[0x18]
8000cf2e:	58 1c       	cp.w	r12,1
8000cf30:	e0 89 00 06 	brgt	8000cf3c <_vfprintf_r+0x1cc4>
8000cf34:	ed b5 00 00 	bld	r5,0x0
8000cf38:	e0 81 00 85 	brne	8000d042 <_vfprintf_r+0x1dca>
8000cf3c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cf40:	2f f8       	sub	r8,-1
8000cf42:	30 19       	mov	r9,1
8000cf44:	fb 48 06 90 	st.w	sp[1680],r8
8000cf48:	87 06       	st.w	r3[0x0],r6
8000cf4a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf4e:	87 19       	st.w	r3[0x4],r9
8000cf50:	2f f8       	sub	r8,-1
8000cf52:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf56:	58 78       	cp.w	r8,7
8000cf58:	e0 89 00 04 	brgt	8000cf60 <_vfprintf_r+0x1ce8>
8000cf5c:	2f 83       	sub	r3,-8
8000cf5e:	c0 b8       	rjmp	8000cf74 <_vfprintf_r+0x1cfc>
8000cf60:	fa ca f9 78 	sub	r10,sp,-1672
8000cf64:	02 9b       	mov	r11,r1
8000cf66:	08 9c       	mov	r12,r4
8000cf68:	fe b0 f1 7a 	rcall	8000b25c <__sprint_r>
8000cf6c:	e0 81 01 11 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cf70:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cf74:	fa f8 06 90 	ld.w	r8,sp[1680]
8000cf78:	2f f8       	sub	r8,-1
8000cf7a:	40 cb       	lddsp	r11,sp[0x30]
8000cf7c:	fb 48 06 90 	st.w	sp[1680],r8
8000cf80:	30 19       	mov	r9,1
8000cf82:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cf86:	87 0b       	st.w	r3[0x0],r11
8000cf88:	2f f8       	sub	r8,-1
8000cf8a:	87 19       	st.w	r3[0x4],r9
8000cf8c:	fb 48 06 8c 	st.w	sp[1676],r8
8000cf90:	58 78       	cp.w	r8,7
8000cf92:	e0 89 00 07 	brgt	8000cfa0 <_vfprintf_r+0x1d28>
8000cf96:	2f 83       	sub	r3,-8
8000cf98:	c0 e8       	rjmp	8000cfb4 <_vfprintf_r+0x1d3c>
8000cf9a:	d7 03       	nop
8000cf9c:	80 01       	ld.sh	r1,r0[0x0]
8000cf9e:	9b 70       	st.w	sp[0x1c],r0
8000cfa0:	fa ca f9 78 	sub	r10,sp,-1672
8000cfa4:	02 9b       	mov	r11,r1
8000cfa6:	08 9c       	mov	r12,r4
8000cfa8:	fe b0 f1 5a 	rcall	8000b25c <__sprint_r>
8000cfac:	e0 81 00 f1 	brne	8000d18e <_vfprintf_r+0x1f16>
8000cfb0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000cfb4:	30 08       	mov	r8,0
8000cfb6:	30 09       	mov	r9,0
8000cfb8:	40 5b       	lddsp	r11,sp[0x14]
8000cfba:	40 7a       	lddsp	r10,sp[0x1c]
8000cfbc:	e0 a0 13 25 	rcall	8000f606 <__avr32_f64_cmp_eq>
8000cfc0:	40 68       	lddsp	r8,sp[0x18]
8000cfc2:	20 18       	sub	r8,1
8000cfc4:	58 0c       	cp.w	r12,0
8000cfc6:	c0 d1       	brne	8000cfe0 <_vfprintf_r+0x1d68>
8000cfc8:	2f f6       	sub	r6,-1
8000cfca:	87 18       	st.w	r3[0x4],r8
8000cfcc:	87 06       	st.w	r3[0x0],r6
8000cfce:	fa f6 06 90 	ld.w	r6,sp[1680]
8000cfd2:	10 06       	add	r6,r8
8000cfd4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000cfd8:	fb 46 06 90 	st.w	sp[1680],r6
8000cfdc:	2f f8       	sub	r8,-1
8000cfde:	c2 f8       	rjmp	8000d03c <_vfprintf_r+0x1dc4>
8000cfe0:	10 96       	mov	r6,r8
8000cfe2:	58 08       	cp.w	r8,0
8000cfe4:	e0 89 00 1c 	brgt	8000d01c <_vfprintf_r+0x1da4>
8000cfe8:	c4 98       	rjmp	8000d07a <_vfprintf_r+0x1e02>
8000cfea:	2f 09       	sub	r9,-16
8000cfec:	2f f8       	sub	r8,-1
8000cfee:	fb 49 06 90 	st.w	sp[1680],r9
8000cff2:	87 02       	st.w	r3[0x0],r2
8000cff4:	87 10       	st.w	r3[0x4],r0
8000cff6:	fb 48 06 8c 	st.w	sp[1676],r8
8000cffa:	58 78       	cp.w	r8,7
8000cffc:	e0 89 00 04 	brgt	8000d004 <_vfprintf_r+0x1d8c>
8000d000:	2f 83       	sub	r3,-8
8000d002:	c0 b8       	rjmp	8000d018 <_vfprintf_r+0x1da0>
8000d004:	fa ca f9 78 	sub	r10,sp,-1672
8000d008:	02 9b       	mov	r11,r1
8000d00a:	08 9c       	mov	r12,r4
8000d00c:	fe b0 f1 28 	rcall	8000b25c <__sprint_r>
8000d010:	e0 81 00 bf 	brne	8000d18e <_vfprintf_r+0x1f16>
8000d014:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d018:	21 06       	sub	r6,16
8000d01a:	c0 38       	rjmp	8000d020 <_vfprintf_r+0x1da8>
8000d01c:	4d 22       	lddpc	r2,8000d164 <_vfprintf_r+0x1eec>
8000d01e:	31 00       	mov	r0,16
8000d020:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d024:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d028:	4c fa       	lddpc	r10,8000d164 <_vfprintf_r+0x1eec>
8000d02a:	59 06       	cp.w	r6,16
8000d02c:	fe 99 ff df 	brgt	8000cfea <_vfprintf_r+0x1d72>
8000d030:	0c 09       	add	r9,r6
8000d032:	87 0a       	st.w	r3[0x0],r10
8000d034:	fb 49 06 90 	st.w	sp[1680],r9
8000d038:	2f f8       	sub	r8,-1
8000d03a:	87 16       	st.w	r3[0x4],r6
8000d03c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d040:	c0 e8       	rjmp	8000d05c <_vfprintf_r+0x1de4>
8000d042:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d046:	2f f8       	sub	r8,-1
8000d048:	30 19       	mov	r9,1
8000d04a:	fb 48 06 90 	st.w	sp[1680],r8
8000d04e:	87 06       	st.w	r3[0x0],r6
8000d050:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d054:	87 19       	st.w	r3[0x4],r9
8000d056:	2f f8       	sub	r8,-1
8000d058:	fb 48 06 8c 	st.w	sp[1676],r8
8000d05c:	58 78       	cp.w	r8,7
8000d05e:	e0 89 00 04 	brgt	8000d066 <_vfprintf_r+0x1dee>
8000d062:	2f 83       	sub	r3,-8
8000d064:	c0 b8       	rjmp	8000d07a <_vfprintf_r+0x1e02>
8000d066:	fa ca f9 78 	sub	r10,sp,-1672
8000d06a:	02 9b       	mov	r11,r1
8000d06c:	08 9c       	mov	r12,r4
8000d06e:	fe b0 f0 f7 	rcall	8000b25c <__sprint_r>
8000d072:	e0 81 00 8e 	brne	8000d18e <_vfprintf_r+0x1f16>
8000d076:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d07a:	40 ea       	lddsp	r10,sp[0x38]
8000d07c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d080:	14 08       	add	r8,r10
8000d082:	fa c9 f9 64 	sub	r9,sp,-1692
8000d086:	fb 48 06 90 	st.w	sp[1680],r8
8000d08a:	87 1a       	st.w	r3[0x4],r10
8000d08c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d090:	87 09       	st.w	r3[0x0],r9
8000d092:	2f f8       	sub	r8,-1
8000d094:	fb 48 06 8c 	st.w	sp[1676],r8
8000d098:	58 78       	cp.w	r8,7
8000d09a:	e0 89 00 04 	brgt	8000d0a2 <_vfprintf_r+0x1e2a>
8000d09e:	2f 83       	sub	r3,-8
8000d0a0:	c0 a8       	rjmp	8000d0b4 <_vfprintf_r+0x1e3c>
8000d0a2:	fa ca f9 78 	sub	r10,sp,-1672
8000d0a6:	02 9b       	mov	r11,r1
8000d0a8:	08 9c       	mov	r12,r4
8000d0aa:	fe b0 f0 d9 	rcall	8000b25c <__sprint_r>
8000d0ae:	c7 01       	brne	8000d18e <_vfprintf_r+0x1f16>
8000d0b0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d0b4:	e2 15 00 04 	andl	r5,0x4,COH
8000d0b8:	c3 d0       	breq	8000d132 <_vfprintf_r+0x1eba>
8000d0ba:	40 86       	lddsp	r6,sp[0x20]
8000d0bc:	40 39       	lddsp	r9,sp[0xc]
8000d0be:	12 16       	sub	r6,r9
8000d0c0:	58 06       	cp.w	r6,0
8000d0c2:	e0 89 00 1a 	brgt	8000d0f6 <_vfprintf_r+0x1e7e>
8000d0c6:	c3 68       	rjmp	8000d132 <_vfprintf_r+0x1eba>
8000d0c8:	2f 09       	sub	r9,-16
8000d0ca:	2f f8       	sub	r8,-1
8000d0cc:	fb 49 06 90 	st.w	sp[1680],r9
8000d0d0:	87 05       	st.w	r3[0x0],r5
8000d0d2:	87 12       	st.w	r3[0x4],r2
8000d0d4:	fb 48 06 8c 	st.w	sp[1676],r8
8000d0d8:	58 78       	cp.w	r8,7
8000d0da:	e0 89 00 04 	brgt	8000d0e2 <_vfprintf_r+0x1e6a>
8000d0de:	2f 83       	sub	r3,-8
8000d0e0:	c0 98       	rjmp	8000d0f2 <_vfprintf_r+0x1e7a>
8000d0e2:	00 9a       	mov	r10,r0
8000d0e4:	02 9b       	mov	r11,r1
8000d0e6:	08 9c       	mov	r12,r4
8000d0e8:	fe b0 f0 ba 	rcall	8000b25c <__sprint_r>
8000d0ec:	c5 11       	brne	8000d18e <_vfprintf_r+0x1f16>
8000d0ee:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d0f2:	21 06       	sub	r6,16
8000d0f4:	c0 58       	rjmp	8000d0fe <_vfprintf_r+0x1e86>
8000d0f6:	49 d5       	lddpc	r5,8000d168 <_vfprintf_r+0x1ef0>
8000d0f8:	31 02       	mov	r2,16
8000d0fa:	fa c0 f9 78 	sub	r0,sp,-1672
8000d0fe:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d102:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d106:	49 9a       	lddpc	r10,8000d168 <_vfprintf_r+0x1ef0>
8000d108:	59 06       	cp.w	r6,16
8000d10a:	fe 99 ff df 	brgt	8000d0c8 <_vfprintf_r+0x1e50>
8000d10e:	0c 09       	add	r9,r6
8000d110:	2f f8       	sub	r8,-1
8000d112:	87 0a       	st.w	r3[0x0],r10
8000d114:	87 16       	st.w	r3[0x4],r6
8000d116:	fb 49 06 90 	st.w	sp[1680],r9
8000d11a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d11e:	58 78       	cp.w	r8,7
8000d120:	e0 8a 00 09 	brle	8000d132 <_vfprintf_r+0x1eba>
8000d124:	fa ca f9 78 	sub	r10,sp,-1672
8000d128:	02 9b       	mov	r11,r1
8000d12a:	08 9c       	mov	r12,r4
8000d12c:	fe b0 f0 98 	rcall	8000b25c <__sprint_r>
8000d130:	c2 f1       	brne	8000d18e <_vfprintf_r+0x1f16>
8000d132:	40 bc       	lddsp	r12,sp[0x2c]
8000d134:	40 36       	lddsp	r6,sp[0xc]
8000d136:	40 8e       	lddsp	lr,sp[0x20]
8000d138:	ec 0e 0c 48 	max	r8,r6,lr
8000d13c:	10 0c       	add	r12,r8
8000d13e:	50 bc       	stdsp	sp[0x2c],r12
8000d140:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d144:	58 08       	cp.w	r8,0
8000d146:	c0 80       	breq	8000d156 <_vfprintf_r+0x1ede>
8000d148:	fa ca f9 78 	sub	r10,sp,-1672
8000d14c:	02 9b       	mov	r11,r1
8000d14e:	08 9c       	mov	r12,r4
8000d150:	fe b0 f0 86 	rcall	8000b25c <__sprint_r>
8000d154:	c1 d1       	brne	8000d18e <_vfprintf_r+0x1f16>
8000d156:	30 0b       	mov	r11,0
8000d158:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d15c:	fb 4b 06 8c 	st.w	sp[1676],r11
8000d160:	fe 9f f1 17 	bral	8000b38e <_vfprintf_r+0x116>
8000d164:	80 01       	ld.sh	r1,r0[0x0]
8000d166:	9b 70       	st.w	sp[0x1c],r0
8000d168:	80 01       	ld.sh	r1,r0[0x0]
8000d16a:	9b 60       	st.w	sp[0x18],r0
8000d16c:	08 95       	mov	r5,r4
8000d16e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d172:	58 08       	cp.w	r8,0
8000d174:	c0 80       	breq	8000d184 <_vfprintf_r+0x1f0c>
8000d176:	08 9c       	mov	r12,r4
8000d178:	fa ca f9 78 	sub	r10,sp,-1672
8000d17c:	02 9b       	mov	r11,r1
8000d17e:	fe b0 f0 6f 	rcall	8000b25c <__sprint_r>
8000d182:	c0 61       	brne	8000d18e <_vfprintf_r+0x1f16>
8000d184:	30 08       	mov	r8,0
8000d186:	fb 48 06 8c 	st.w	sp[1676],r8
8000d18a:	c0 28       	rjmp	8000d18e <_vfprintf_r+0x1f16>
8000d18c:	40 41       	lddsp	r1,sp[0x10]
8000d18e:	82 68       	ld.sh	r8,r1[0xc]
8000d190:	ed b8 00 06 	bld	r8,0x6
8000d194:	c0 31       	brne	8000d19a <_vfprintf_r+0x1f22>
8000d196:	3f fa       	mov	r10,-1
8000d198:	50 ba       	stdsp	sp[0x2c],r10
8000d19a:	40 bc       	lddsp	r12,sp[0x2c]
8000d19c:	fe 3d f9 44 	sub	sp,-1724
8000d1a0:	d8 32       	popm	r0-r7,pc
8000d1a2:	d7 03       	nop

8000d1a4 <__swsetup_r>:
8000d1a4:	d4 21       	pushm	r4-r7,lr
8000d1a6:	e0 68 0a 38 	mov	r8,2616
8000d1aa:	18 96       	mov	r6,r12
8000d1ac:	16 97       	mov	r7,r11
8000d1ae:	70 0c       	ld.w	r12,r8[0x0]
8000d1b0:	58 0c       	cp.w	r12,0
8000d1b2:	c0 60       	breq	8000d1be <__swsetup_r+0x1a>
8000d1b4:	78 68       	ld.w	r8,r12[0x18]
8000d1b6:	58 08       	cp.w	r8,0
8000d1b8:	c0 31       	brne	8000d1be <__swsetup_r+0x1a>
8000d1ba:	e0 a0 07 c7 	rcall	8000e148 <__sinit>
8000d1be:	4a f8       	lddpc	r8,8000d278 <__swsetup_r+0xd4>
8000d1c0:	10 37       	cp.w	r7,r8
8000d1c2:	c0 61       	brne	8000d1ce <__swsetup_r+0x2a>
8000d1c4:	e0 68 0a 38 	mov	r8,2616
8000d1c8:	70 08       	ld.w	r8,r8[0x0]
8000d1ca:	70 07       	ld.w	r7,r8[0x0]
8000d1cc:	c1 08       	rjmp	8000d1ec <__swsetup_r+0x48>
8000d1ce:	4a c8       	lddpc	r8,8000d27c <__swsetup_r+0xd8>
8000d1d0:	10 37       	cp.w	r7,r8
8000d1d2:	c0 61       	brne	8000d1de <__swsetup_r+0x3a>
8000d1d4:	e0 68 0a 38 	mov	r8,2616
8000d1d8:	70 08       	ld.w	r8,r8[0x0]
8000d1da:	70 17       	ld.w	r7,r8[0x4]
8000d1dc:	c0 88       	rjmp	8000d1ec <__swsetup_r+0x48>
8000d1de:	4a 98       	lddpc	r8,8000d280 <__swsetup_r+0xdc>
8000d1e0:	10 37       	cp.w	r7,r8
8000d1e2:	c0 51       	brne	8000d1ec <__swsetup_r+0x48>
8000d1e4:	e0 68 0a 38 	mov	r8,2616
8000d1e8:	70 08       	ld.w	r8,r8[0x0]
8000d1ea:	70 27       	ld.w	r7,r8[0x8]
8000d1ec:	8e 68       	ld.sh	r8,r7[0xc]
8000d1ee:	ed b8 00 03 	bld	r8,0x3
8000d1f2:	c1 e0       	breq	8000d22e <__swsetup_r+0x8a>
8000d1f4:	ed b8 00 04 	bld	r8,0x4
8000d1f8:	c3 e1       	brne	8000d274 <__swsetup_r+0xd0>
8000d1fa:	ed b8 00 02 	bld	r8,0x2
8000d1fe:	c1 51       	brne	8000d228 <__swsetup_r+0x84>
8000d200:	6e db       	ld.w	r11,r7[0x34]
8000d202:	58 0b       	cp.w	r11,0
8000d204:	c0 a0       	breq	8000d218 <__swsetup_r+0x74>
8000d206:	ee c8 ff bc 	sub	r8,r7,-68
8000d20a:	10 3b       	cp.w	r11,r8
8000d20c:	c0 40       	breq	8000d214 <__swsetup_r+0x70>
8000d20e:	0c 9c       	mov	r12,r6
8000d210:	e0 a0 08 36 	rcall	8000e27c <_free_r>
8000d214:	30 08       	mov	r8,0
8000d216:	8f d8       	st.w	r7[0x34],r8
8000d218:	8e 68       	ld.sh	r8,r7[0xc]
8000d21a:	e0 18 ff db 	andl	r8,0xffdb
8000d21e:	ae 68       	st.h	r7[0xc],r8
8000d220:	30 08       	mov	r8,0
8000d222:	8f 18       	st.w	r7[0x4],r8
8000d224:	6e 48       	ld.w	r8,r7[0x10]
8000d226:	8f 08       	st.w	r7[0x0],r8
8000d228:	8e 68       	ld.sh	r8,r7[0xc]
8000d22a:	a3 b8       	sbr	r8,0x3
8000d22c:	ae 68       	st.h	r7[0xc],r8
8000d22e:	6e 48       	ld.w	r8,r7[0x10]
8000d230:	58 08       	cp.w	r8,0
8000d232:	c0 b1       	brne	8000d248 <__swsetup_r+0xa4>
8000d234:	8e 68       	ld.sh	r8,r7[0xc]
8000d236:	e2 18 02 80 	andl	r8,0x280,COH
8000d23a:	e0 48 02 00 	cp.w	r8,512
8000d23e:	c0 50       	breq	8000d248 <__swsetup_r+0xa4>
8000d240:	0c 9c       	mov	r12,r6
8000d242:	0e 9b       	mov	r11,r7
8000d244:	e0 a0 0a 56 	rcall	8000e6f0 <__smakebuf_r>
8000d248:	8e 69       	ld.sh	r9,r7[0xc]
8000d24a:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000d24e:	c0 70       	breq	8000d25c <__swsetup_r+0xb8>
8000d250:	30 08       	mov	r8,0
8000d252:	8f 28       	st.w	r7[0x8],r8
8000d254:	6e 58       	ld.w	r8,r7[0x14]
8000d256:	5c 38       	neg	r8
8000d258:	8f 68       	st.w	r7[0x18],r8
8000d25a:	c0 68       	rjmp	8000d266 <__swsetup_r+0xc2>
8000d25c:	ed b9 00 01 	bld	r9,0x1
8000d260:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000d264:	8f 28       	st.w	r7[0x8],r8
8000d266:	6e 48       	ld.w	r8,r7[0x10]
8000d268:	58 08       	cp.w	r8,0
8000d26a:	c0 61       	brne	8000d276 <__swsetup_r+0xd2>
8000d26c:	8e 68       	ld.sh	r8,r7[0xc]
8000d26e:	ed b8 00 07 	bld	r8,0x7
8000d272:	c0 21       	brne	8000d276 <__swsetup_r+0xd2>
8000d274:	dc 2a       	popm	r4-r7,pc,r12=-1
8000d276:	d8 2a       	popm	r4-r7,pc,r12=0
8000d278:	80 01       	ld.sh	r1,r0[0x0]
8000d27a:	9c 90       	ld.uh	r0,lr[0x2]
8000d27c:	80 01       	ld.sh	r1,r0[0x0]
8000d27e:	9c b0       	ld.uh	r0,lr[0x6]
8000d280:	80 01       	ld.sh	r1,r0[0x0]
8000d282:	9c d0       	ld.uh	r0,lr[0xa]

8000d284 <quorem>:
8000d284:	d4 31       	pushm	r0-r7,lr
8000d286:	20 2d       	sub	sp,8
8000d288:	18 97       	mov	r7,r12
8000d28a:	78 48       	ld.w	r8,r12[0x10]
8000d28c:	76 46       	ld.w	r6,r11[0x10]
8000d28e:	0c 38       	cp.w	r8,r6
8000d290:	c0 34       	brge	8000d296 <quorem+0x12>
8000d292:	30 0c       	mov	r12,0
8000d294:	c8 58       	rjmp	8000d39e <quorem+0x11a>
8000d296:	ec c2 ff fc 	sub	r2,r6,-4
8000d29a:	f6 c3 ff ec 	sub	r3,r11,-20
8000d29e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000d2a2:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000d2a6:	2f f9       	sub	r9,-1
8000d2a8:	20 16       	sub	r6,1
8000d2aa:	f8 09 0d 08 	divu	r8,r12,r9
8000d2ae:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000d2b2:	ee c4 ff ec 	sub	r4,r7,-20
8000d2b6:	10 95       	mov	r5,r8
8000d2b8:	58 08       	cp.w	r8,0
8000d2ba:	c4 10       	breq	8000d33c <quorem+0xb8>
8000d2bc:	30 09       	mov	r9,0
8000d2be:	06 9a       	mov	r10,r3
8000d2c0:	08 98       	mov	r8,r4
8000d2c2:	12 91       	mov	r1,r9
8000d2c4:	50 0b       	stdsp	sp[0x0],r11
8000d2c6:	70 0e       	ld.w	lr,r8[0x0]
8000d2c8:	b1 8e       	lsr	lr,0x10
8000d2ca:	50 1e       	stdsp	sp[0x4],lr
8000d2cc:	15 0e       	ld.w	lr,r10++
8000d2ce:	fc 00 16 10 	lsr	r0,lr,0x10
8000d2d2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d2d6:	ea 0e 03 41 	mac	r1,r5,lr
8000d2da:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000d2de:	b1 81       	lsr	r1,0x10
8000d2e0:	40 1b       	lddsp	r11,sp[0x4]
8000d2e2:	ea 00 02 40 	mul	r0,r5,r0
8000d2e6:	e2 00 00 00 	add	r0,r1,r0
8000d2ea:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000d2ee:	02 1b       	sub	r11,r1
8000d2f0:	50 1b       	stdsp	sp[0x4],r11
8000d2f2:	70 0b       	ld.w	r11,r8[0x0]
8000d2f4:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000d2f8:	02 09       	add	r9,r1
8000d2fa:	f2 0e 01 0e 	sub	lr,r9,lr
8000d2fe:	b0 1e       	st.h	r8[0x2],lr
8000d300:	fc 09 14 10 	asr	r9,lr,0x10
8000d304:	40 1e       	lddsp	lr,sp[0x4]
8000d306:	fc 09 00 09 	add	r9,lr,r9
8000d30a:	b0 09       	st.h	r8[0x0],r9
8000d30c:	e0 01 16 10 	lsr	r1,r0,0x10
8000d310:	2f c8       	sub	r8,-4
8000d312:	b1 49       	asr	r9,0x10
8000d314:	04 3a       	cp.w	r10,r2
8000d316:	fe 98 ff d8 	brls	8000d2c6 <quorem+0x42>
8000d31a:	40 0b       	lddsp	r11,sp[0x0]
8000d31c:	58 0c       	cp.w	r12,0
8000d31e:	c0 f1       	brne	8000d33c <quorem+0xb8>
8000d320:	ec c8 ff fb 	sub	r8,r6,-5
8000d324:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d328:	c0 28       	rjmp	8000d32c <quorem+0xa8>
8000d32a:	20 16       	sub	r6,1
8000d32c:	20 48       	sub	r8,4
8000d32e:	08 38       	cp.w	r8,r4
8000d330:	e0 88 00 05 	brls	8000d33a <quorem+0xb6>
8000d334:	70 09       	ld.w	r9,r8[0x0]
8000d336:	58 09       	cp.w	r9,0
8000d338:	cf 90       	breq	8000d32a <quorem+0xa6>
8000d33a:	8f 46       	st.w	r7[0x10],r6
8000d33c:	0e 9c       	mov	r12,r7
8000d33e:	e0 a0 0a d8 	rcall	8000e8ee <__mcmp>
8000d342:	c2 d5       	brlt	8000d39c <quorem+0x118>
8000d344:	2f f5       	sub	r5,-1
8000d346:	08 98       	mov	r8,r4
8000d348:	30 09       	mov	r9,0
8000d34a:	07 0b       	ld.w	r11,r3++
8000d34c:	f6 0a 16 10 	lsr	r10,r11,0x10
8000d350:	70 0c       	ld.w	r12,r8[0x0]
8000d352:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000d356:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d35a:	14 1e       	sub	lr,r10
8000d35c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d360:	16 1a       	sub	r10,r11
8000d362:	12 0a       	add	r10,r9
8000d364:	b0 1a       	st.h	r8[0x2],r10
8000d366:	b1 4a       	asr	r10,0x10
8000d368:	fc 0a 00 09 	add	r9,lr,r10
8000d36c:	b0 09       	st.h	r8[0x0],r9
8000d36e:	2f c8       	sub	r8,-4
8000d370:	b1 49       	asr	r9,0x10
8000d372:	04 33       	cp.w	r3,r2
8000d374:	fe 98 ff eb 	brls	8000d34a <quorem+0xc6>
8000d378:	ec c8 ff fb 	sub	r8,r6,-5
8000d37c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000d380:	58 09       	cp.w	r9,0
8000d382:	c0 d1       	brne	8000d39c <quorem+0x118>
8000d384:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d388:	c0 28       	rjmp	8000d38c <quorem+0x108>
8000d38a:	20 16       	sub	r6,1
8000d38c:	20 48       	sub	r8,4
8000d38e:	08 38       	cp.w	r8,r4
8000d390:	e0 88 00 05 	brls	8000d39a <quorem+0x116>
8000d394:	70 09       	ld.w	r9,r8[0x0]
8000d396:	58 09       	cp.w	r9,0
8000d398:	cf 90       	breq	8000d38a <quorem+0x106>
8000d39a:	8f 46       	st.w	r7[0x10],r6
8000d39c:	0a 9c       	mov	r12,r5
8000d39e:	2f ed       	sub	sp,-8
8000d3a0:	d8 32       	popm	r0-r7,pc
8000d3a2:	d7 03       	nop

8000d3a4 <_dtoa_r>:
8000d3a4:	d4 31       	pushm	r0-r7,lr
8000d3a6:	21 ad       	sub	sp,104
8000d3a8:	fa c4 ff 74 	sub	r4,sp,-140
8000d3ac:	18 97       	mov	r7,r12
8000d3ae:	16 95       	mov	r5,r11
8000d3b0:	68 2c       	ld.w	r12,r4[0x8]
8000d3b2:	50 c9       	stdsp	sp[0x30],r9
8000d3b4:	68 16       	ld.w	r6,r4[0x4]
8000d3b6:	68 09       	ld.w	r9,r4[0x0]
8000d3b8:	50 e8       	stdsp	sp[0x38],r8
8000d3ba:	14 94       	mov	r4,r10
8000d3bc:	51 2c       	stdsp	sp[0x48],r12
8000d3be:	fa e5 00 08 	st.d	sp[8],r4
8000d3c2:	51 59       	stdsp	sp[0x54],r9
8000d3c4:	6e 95       	ld.w	r5,r7[0x24]
8000d3c6:	58 05       	cp.w	r5,0
8000d3c8:	c0 91       	brne	8000d3da <_dtoa_r+0x36>
8000d3ca:	31 0c       	mov	r12,16
8000d3cc:	fe b0 e8 42 	rcall	8000a450 <malloc>
8000d3d0:	99 35       	st.w	r12[0xc],r5
8000d3d2:	8f 9c       	st.w	r7[0x24],r12
8000d3d4:	99 15       	st.w	r12[0x4],r5
8000d3d6:	99 25       	st.w	r12[0x8],r5
8000d3d8:	99 05       	st.w	r12[0x0],r5
8000d3da:	6e 99       	ld.w	r9,r7[0x24]
8000d3dc:	72 08       	ld.w	r8,r9[0x0]
8000d3de:	58 08       	cp.w	r8,0
8000d3e0:	c0 f0       	breq	8000d3fe <_dtoa_r+0x5a>
8000d3e2:	72 1a       	ld.w	r10,r9[0x4]
8000d3e4:	91 1a       	st.w	r8[0x4],r10
8000d3e6:	30 1a       	mov	r10,1
8000d3e8:	72 19       	ld.w	r9,r9[0x4]
8000d3ea:	f4 09 09 49 	lsl	r9,r10,r9
8000d3ee:	10 9b       	mov	r11,r8
8000d3f0:	91 29       	st.w	r8[0x8],r9
8000d3f2:	0e 9c       	mov	r12,r7
8000d3f4:	e0 a0 0a 96 	rcall	8000e920 <_Bfree>
8000d3f8:	6e 98       	ld.w	r8,r7[0x24]
8000d3fa:	30 09       	mov	r9,0
8000d3fc:	91 09       	st.w	r8[0x0],r9
8000d3fe:	40 28       	lddsp	r8,sp[0x8]
8000d400:	10 94       	mov	r4,r8
8000d402:	58 08       	cp.w	r8,0
8000d404:	c0 64       	brge	8000d410 <_dtoa_r+0x6c>
8000d406:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000d40a:	50 28       	stdsp	sp[0x8],r8
8000d40c:	30 18       	mov	r8,1
8000d40e:	c0 28       	rjmp	8000d412 <_dtoa_r+0x6e>
8000d410:	30 08       	mov	r8,0
8000d412:	8d 08       	st.w	r6[0x0],r8
8000d414:	fc 1c 7f f0 	movh	r12,0x7ff0
8000d418:	40 26       	lddsp	r6,sp[0x8]
8000d41a:	0c 98       	mov	r8,r6
8000d41c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000d420:	18 38       	cp.w	r8,r12
8000d422:	c1 e1       	brne	8000d45e <_dtoa_r+0xba>
8000d424:	e0 68 27 0f 	mov	r8,9999
8000d428:	41 5b       	lddsp	r11,sp[0x54]
8000d42a:	97 08       	st.w	r11[0x0],r8
8000d42c:	40 3a       	lddsp	r10,sp[0xc]
8000d42e:	58 0a       	cp.w	r10,0
8000d430:	c0 61       	brne	8000d43c <_dtoa_r+0x98>
8000d432:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000d436:	c0 31       	brne	8000d43c <_dtoa_r+0x98>
8000d438:	4a cc       	lddpc	r12,8000d4e8 <_dtoa_r+0x144>
8000d43a:	c0 28       	rjmp	8000d43e <_dtoa_r+0x9a>
8000d43c:	4a cc       	lddpc	r12,8000d4ec <_dtoa_r+0x148>
8000d43e:	41 29       	lddsp	r9,sp[0x48]
8000d440:	58 09       	cp.w	r9,0
8000d442:	e0 80 05 9e 	breq	8000df7e <_dtoa_r+0xbda>
8000d446:	f8 c8 ff fd 	sub	r8,r12,-3
8000d44a:	f8 c9 ff f8 	sub	r9,r12,-8
8000d44e:	11 8b       	ld.ub	r11,r8[0x0]
8000d450:	30 0a       	mov	r10,0
8000d452:	41 25       	lddsp	r5,sp[0x48]
8000d454:	f4 0b 18 00 	cp.b	r11,r10
8000d458:	f2 08 17 10 	movne	r8,r9
8000d45c:	c1 58       	rjmp	8000d486 <_dtoa_r+0xe2>
8000d45e:	fa ea 00 08 	ld.d	r10,sp[8]
8000d462:	30 08       	mov	r8,0
8000d464:	fa eb 00 3c 	st.d	sp[60],r10
8000d468:	30 09       	mov	r9,0
8000d46a:	e0 a0 10 ce 	rcall	8000f606 <__avr32_f64_cmp_eq>
8000d46e:	c0 f0       	breq	8000d48c <_dtoa_r+0xe8>
8000d470:	30 18       	mov	r8,1
8000d472:	41 5a       	lddsp	r10,sp[0x54]
8000d474:	95 08       	st.w	r10[0x0],r8
8000d476:	49 fc       	lddpc	r12,8000d4f0 <_dtoa_r+0x14c>
8000d478:	41 29       	lddsp	r9,sp[0x48]
8000d47a:	f8 08 00 08 	add	r8,r12,r8
8000d47e:	58 09       	cp.w	r9,0
8000d480:	e0 80 05 7f 	breq	8000df7e <_dtoa_r+0xbda>
8000d484:	12 95       	mov	r5,r9
8000d486:	8b 08       	st.w	r5[0x0],r8
8000d488:	e0 8f 05 7b 	bral	8000df7e <_dtoa_r+0xbda>
8000d48c:	fa c8 ff 9c 	sub	r8,sp,-100
8000d490:	fa c9 ff a0 	sub	r9,sp,-96
8000d494:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d498:	0e 9c       	mov	r12,r7
8000d49a:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000d49e:	e0 a0 0a 93 	rcall	8000e9c4 <__d2b>
8000d4a2:	18 93       	mov	r3,r12
8000d4a4:	58 05       	cp.w	r5,0
8000d4a6:	c0 d0       	breq	8000d4c0 <_dtoa_r+0x11c>
8000d4a8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d4ac:	30 04       	mov	r4,0
8000d4ae:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000d4b2:	ea c5 03 ff 	sub	r5,r5,1023
8000d4b6:	10 9b       	mov	r11,r8
8000d4b8:	51 74       	stdsp	sp[0x5c],r4
8000d4ba:	ea 1b 3f f0 	orh	r11,0x3ff0
8000d4be:	c2 a8       	rjmp	8000d512 <_dtoa_r+0x16e>
8000d4c0:	41 88       	lddsp	r8,sp[0x60]
8000d4c2:	41 9c       	lddsp	r12,sp[0x64]
8000d4c4:	10 0c       	add	r12,r8
8000d4c6:	f8 c5 fb ce 	sub	r5,r12,-1074
8000d4ca:	e0 45 00 20 	cp.w	r5,32
8000d4ce:	e0 8a 00 13 	brle	8000d4f4 <_dtoa_r+0x150>
8000d4d2:	f8 cc fb ee 	sub	r12,r12,-1042
8000d4d6:	40 3b       	lddsp	r11,sp[0xc]
8000d4d8:	ea 08 11 40 	rsub	r8,r5,64
8000d4dc:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000d4e0:	ec 08 09 46 	lsl	r6,r6,r8
8000d4e4:	0c 4c       	or	r12,r6
8000d4e6:	c0 c8       	rjmp	8000d4fe <_dtoa_r+0x15a>
8000d4e8:	80 01       	ld.sh	r1,r0[0x0]
8000d4ea:	9c 80       	ld.uh	r0,lr[0x0]
8000d4ec:	80 01       	ld.sh	r1,r0[0x0]
8000d4ee:	9c 8c       	ld.uh	r12,lr[0x0]
8000d4f0:	80 01       	ld.sh	r1,r0[0x0]
8000d4f2:	9b 5c       	st.w	sp[0x14],r12
8000d4f4:	ea 0c 11 20 	rsub	r12,r5,32
8000d4f8:	40 3a       	lddsp	r10,sp[0xc]
8000d4fa:	f4 0c 09 4c 	lsl	r12,r10,r12
8000d4fe:	e0 a0 10 10 	rcall	8000f51e <__avr32_u32_to_f64>
8000d502:	fc 18 fe 10 	movh	r8,0xfe10
8000d506:	30 19       	mov	r9,1
8000d508:	ea c5 04 33 	sub	r5,r5,1075
8000d50c:	f0 0b 00 0b 	add	r11,r8,r11
8000d510:	51 79       	stdsp	sp[0x5c],r9
8000d512:	30 08       	mov	r8,0
8000d514:	fc 19 3f f8 	movh	r9,0x3ff8
8000d518:	e0 a0 0e 98 	rcall	8000f248 <__avr32_f64_sub>
8000d51c:	e0 68 43 61 	mov	r8,17249
8000d520:	ea 18 63 6f 	orh	r8,0x636f
8000d524:	e0 69 87 a7 	mov	r9,34727
8000d528:	ea 19 3f d2 	orh	r9,0x3fd2
8000d52c:	e0 a0 0d a2 	rcall	8000f070 <__avr32_f64_mul>
8000d530:	e0 68 c8 b3 	mov	r8,51379
8000d534:	ea 18 8b 60 	orh	r8,0x8b60
8000d538:	e0 69 8a 28 	mov	r9,35368
8000d53c:	ea 19 3f c6 	orh	r9,0x3fc6
8000d540:	e0 a0 0f 52 	rcall	8000f3e4 <__avr32_f64_add>
8000d544:	0a 9c       	mov	r12,r5
8000d546:	14 90       	mov	r0,r10
8000d548:	16 91       	mov	r1,r11
8000d54a:	e0 a0 0f ee 	rcall	8000f526 <__avr32_s32_to_f64>
8000d54e:	e0 68 79 fb 	mov	r8,31227
8000d552:	ea 18 50 9f 	orh	r8,0x509f
8000d556:	e0 69 44 13 	mov	r9,17427
8000d55a:	ea 19 3f d3 	orh	r9,0x3fd3
8000d55e:	e0 a0 0d 89 	rcall	8000f070 <__avr32_f64_mul>
8000d562:	14 98       	mov	r8,r10
8000d564:	16 99       	mov	r9,r11
8000d566:	00 9a       	mov	r10,r0
8000d568:	02 9b       	mov	r11,r1
8000d56a:	e0 a0 0f 3d 	rcall	8000f3e4 <__avr32_f64_add>
8000d56e:	14 90       	mov	r0,r10
8000d570:	16 91       	mov	r1,r11
8000d572:	e0 a0 0f c3 	rcall	8000f4f8 <__avr32_f64_to_s32>
8000d576:	30 08       	mov	r8,0
8000d578:	18 96       	mov	r6,r12
8000d57a:	30 09       	mov	r9,0
8000d57c:	00 9a       	mov	r10,r0
8000d57e:	02 9b       	mov	r11,r1
8000d580:	e0 a0 10 8a 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000d584:	c0 c0       	breq	8000d59c <_dtoa_r+0x1f8>
8000d586:	0c 9c       	mov	r12,r6
8000d588:	e0 a0 0f cf 	rcall	8000f526 <__avr32_s32_to_f64>
8000d58c:	14 98       	mov	r8,r10
8000d58e:	16 99       	mov	r9,r11
8000d590:	00 9a       	mov	r10,r0
8000d592:	02 9b       	mov	r11,r1
8000d594:	e0 a0 10 39 	rcall	8000f606 <__avr32_f64_cmp_eq>
8000d598:	f7 b6 00 01 	subeq	r6,1
8000d59c:	59 66       	cp.w	r6,22
8000d59e:	e0 88 00 05 	brls	8000d5a8 <_dtoa_r+0x204>
8000d5a2:	30 18       	mov	r8,1
8000d5a4:	51 48       	stdsp	sp[0x50],r8
8000d5a6:	c1 28       	rjmp	8000d5ca <_dtoa_r+0x226>
8000d5a8:	4c 08       	lddpc	r8,8000d6a8 <_dtoa_r+0x304>
8000d5aa:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d5ae:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000d5b2:	e0 a0 10 71 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000d5b6:	f9 b4 00 00 	moveq	r4,0
8000d5ba:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000d5be:	f7 b6 01 01 	subne	r6,1
8000d5c2:	f9 bc 01 00 	movne	r12,0
8000d5c6:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000d5ca:	41 90       	lddsp	r0,sp[0x64]
8000d5cc:	20 10       	sub	r0,1
8000d5ce:	0a 10       	sub	r0,r5
8000d5d0:	c0 46       	brmi	8000d5d8 <_dtoa_r+0x234>
8000d5d2:	50 40       	stdsp	sp[0x10],r0
8000d5d4:	30 00       	mov	r0,0
8000d5d6:	c0 48       	rjmp	8000d5de <_dtoa_r+0x23a>
8000d5d8:	30 0b       	mov	r11,0
8000d5da:	5c 30       	neg	r0
8000d5dc:	50 4b       	stdsp	sp[0x10],r11
8000d5de:	ec 02 11 00 	rsub	r2,r6,0
8000d5e2:	58 06       	cp.w	r6,0
8000d5e4:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000d5e8:	f5 d6 e4 0a 	addge	r10,r10,r6
8000d5ec:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000d5f0:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000d5f4:	f9 b2 04 00 	movge	r2,0
8000d5f8:	e1 d6 e5 10 	sublt	r0,r0,r6
8000d5fc:	f9 b9 05 00 	movlt	r9,0
8000d600:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000d604:	40 c8       	lddsp	r8,sp[0x30]
8000d606:	58 98       	cp.w	r8,9
8000d608:	e0 8b 00 20 	brhi	8000d648 <_dtoa_r+0x2a4>
8000d60c:	58 58       	cp.w	r8,5
8000d60e:	f9 b4 0a 01 	movle	r4,1
8000d612:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000d616:	f7 b5 09 04 	subgt	r5,4
8000d61a:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000d61e:	f9 b4 09 00 	movgt	r4,0
8000d622:	40 cc       	lddsp	r12,sp[0x30]
8000d624:	58 3c       	cp.w	r12,3
8000d626:	c2 d0       	breq	8000d680 <_dtoa_r+0x2dc>
8000d628:	e0 89 00 05 	brgt	8000d632 <_dtoa_r+0x28e>
8000d62c:	58 2c       	cp.w	r12,2
8000d62e:	c1 01       	brne	8000d64e <_dtoa_r+0x2aa>
8000d630:	c1 88       	rjmp	8000d660 <_dtoa_r+0x2bc>
8000d632:	40 cb       	lddsp	r11,sp[0x30]
8000d634:	58 4b       	cp.w	r11,4
8000d636:	c0 60       	breq	8000d642 <_dtoa_r+0x29e>
8000d638:	58 5b       	cp.w	r11,5
8000d63a:	c0 a1       	brne	8000d64e <_dtoa_r+0x2aa>
8000d63c:	30 1a       	mov	r10,1
8000d63e:	50 da       	stdsp	sp[0x34],r10
8000d640:	c2 28       	rjmp	8000d684 <_dtoa_r+0x2e0>
8000d642:	30 19       	mov	r9,1
8000d644:	50 d9       	stdsp	sp[0x34],r9
8000d646:	c0 f8       	rjmp	8000d664 <_dtoa_r+0x2c0>
8000d648:	30 08       	mov	r8,0
8000d64a:	30 14       	mov	r4,1
8000d64c:	50 c8       	stdsp	sp[0x30],r8
8000d64e:	3f f5       	mov	r5,-1
8000d650:	30 1c       	mov	r12,1
8000d652:	30 0b       	mov	r11,0
8000d654:	50 95       	stdsp	sp[0x24],r5
8000d656:	50 dc       	stdsp	sp[0x34],r12
8000d658:	0a 91       	mov	r1,r5
8000d65a:	31 28       	mov	r8,18
8000d65c:	50 eb       	stdsp	sp[0x38],r11
8000d65e:	c2 08       	rjmp	8000d69e <_dtoa_r+0x2fa>
8000d660:	30 0a       	mov	r10,0
8000d662:	50 da       	stdsp	sp[0x34],r10
8000d664:	40 e9       	lddsp	r9,sp[0x38]
8000d666:	58 09       	cp.w	r9,0
8000d668:	e0 89 00 07 	brgt	8000d676 <_dtoa_r+0x2d2>
8000d66c:	30 18       	mov	r8,1
8000d66e:	50 98       	stdsp	sp[0x24],r8
8000d670:	10 91       	mov	r1,r8
8000d672:	50 e8       	stdsp	sp[0x38],r8
8000d674:	c1 58       	rjmp	8000d69e <_dtoa_r+0x2fa>
8000d676:	40 e5       	lddsp	r5,sp[0x38]
8000d678:	50 95       	stdsp	sp[0x24],r5
8000d67a:	0a 91       	mov	r1,r5
8000d67c:	0a 98       	mov	r8,r5
8000d67e:	c1 08       	rjmp	8000d69e <_dtoa_r+0x2fa>
8000d680:	30 0c       	mov	r12,0
8000d682:	50 dc       	stdsp	sp[0x34],r12
8000d684:	40 eb       	lddsp	r11,sp[0x38]
8000d686:	ec 0b 00 0b 	add	r11,r6,r11
8000d68a:	50 9b       	stdsp	sp[0x24],r11
8000d68c:	16 98       	mov	r8,r11
8000d68e:	2f f8       	sub	r8,-1
8000d690:	58 08       	cp.w	r8,0
8000d692:	e0 89 00 05 	brgt	8000d69c <_dtoa_r+0x2f8>
8000d696:	10 91       	mov	r1,r8
8000d698:	30 18       	mov	r8,1
8000d69a:	c0 28       	rjmp	8000d69e <_dtoa_r+0x2fa>
8000d69c:	10 91       	mov	r1,r8
8000d69e:	30 09       	mov	r9,0
8000d6a0:	6e 9a       	ld.w	r10,r7[0x24]
8000d6a2:	95 19       	st.w	r10[0x4],r9
8000d6a4:	30 49       	mov	r9,4
8000d6a6:	c0 78       	rjmp	8000d6b4 <_dtoa_r+0x310>
8000d6a8:	80 01       	ld.sh	r1,r0[0x0]
8000d6aa:	9d 40       	st.w	lr[0x10],r0
8000d6ac:	6a 1a       	ld.w	r10,r5[0x4]
8000d6ae:	a1 79       	lsl	r9,0x1
8000d6b0:	2f fa       	sub	r10,-1
8000d6b2:	8b 1a       	st.w	r5[0x4],r10
8000d6b4:	6e 95       	ld.w	r5,r7[0x24]
8000d6b6:	f2 ca ff ec 	sub	r10,r9,-20
8000d6ba:	10 3a       	cp.w	r10,r8
8000d6bc:	fe 98 ff f8 	brls	8000d6ac <_dtoa_r+0x308>
8000d6c0:	6a 1b       	ld.w	r11,r5[0x4]
8000d6c2:	0e 9c       	mov	r12,r7
8000d6c4:	e0 a0 09 48 	rcall	8000e954 <_Balloc>
8000d6c8:	58 e1       	cp.w	r1,14
8000d6ca:	5f 88       	srls	r8
8000d6cc:	8b 0c       	st.w	r5[0x0],r12
8000d6ce:	f1 e4 00 04 	and	r4,r8,r4
8000d6d2:	6e 98       	ld.w	r8,r7[0x24]
8000d6d4:	70 08       	ld.w	r8,r8[0x0]
8000d6d6:	50 88       	stdsp	sp[0x20],r8
8000d6d8:	e0 80 01 82 	breq	8000d9dc <_dtoa_r+0x638>
8000d6dc:	58 06       	cp.w	r6,0
8000d6de:	e0 8a 00 40 	brle	8000d75e <_dtoa_r+0x3ba>
8000d6e2:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000d6e6:	4c b8       	lddpc	r8,8000d810 <_dtoa_r+0x46c>
8000d6e8:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000d6ec:	fa e5 00 18 	st.d	sp[24],r4
8000d6f0:	ec 04 14 04 	asr	r4,r6,0x4
8000d6f4:	ed b4 00 04 	bld	r4,0x4
8000d6f8:	c0 30       	breq	8000d6fe <_dtoa_r+0x35a>
8000d6fa:	30 25       	mov	r5,2
8000d6fc:	c0 f8       	rjmp	8000d71a <_dtoa_r+0x376>
8000d6fe:	4c 68       	lddpc	r8,8000d814 <_dtoa_r+0x470>
8000d700:	f0 e8 00 20 	ld.d	r8,r8[32]
8000d704:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d708:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000d70c:	e0 a0 0f f8 	rcall	8000f6fc <__avr32_f64_div>
8000d710:	30 35       	mov	r5,3
8000d712:	14 98       	mov	r8,r10
8000d714:	16 99       	mov	r9,r11
8000d716:	fa e9 00 08 	st.d	sp[8],r8
8000d71a:	4b fc       	lddpc	r12,8000d814 <_dtoa_r+0x470>
8000d71c:	50 a3       	stdsp	sp[0x28],r3
8000d71e:	0c 93       	mov	r3,r6
8000d720:	18 96       	mov	r6,r12
8000d722:	c0 f8       	rjmp	8000d740 <_dtoa_r+0x39c>
8000d724:	fa ea 00 18 	ld.d	r10,sp[24]
8000d728:	ed b4 00 00 	bld	r4,0x0
8000d72c:	c0 81       	brne	8000d73c <_dtoa_r+0x398>
8000d72e:	ec e8 00 00 	ld.d	r8,r6[0]
8000d732:	2f f5       	sub	r5,-1
8000d734:	e0 a0 0c 9e 	rcall	8000f070 <__avr32_f64_mul>
8000d738:	fa eb 00 18 	st.d	sp[24],r10
8000d73c:	a1 54       	asr	r4,0x1
8000d73e:	2f 86       	sub	r6,-8
8000d740:	58 04       	cp.w	r4,0
8000d742:	cf 11       	brne	8000d724 <_dtoa_r+0x380>
8000d744:	fa e8 00 18 	ld.d	r8,sp[24]
8000d748:	fa ea 00 08 	ld.d	r10,sp[8]
8000d74c:	06 96       	mov	r6,r3
8000d74e:	e0 a0 0f d7 	rcall	8000f6fc <__avr32_f64_div>
8000d752:	40 a3       	lddsp	r3,sp[0x28]
8000d754:	14 98       	mov	r8,r10
8000d756:	16 99       	mov	r9,r11
8000d758:	fa e9 00 08 	st.d	sp[8],r8
8000d75c:	c2 d8       	rjmp	8000d7b6 <_dtoa_r+0x412>
8000d75e:	ec 08 11 00 	rsub	r8,r6,0
8000d762:	c0 31       	brne	8000d768 <_dtoa_r+0x3c4>
8000d764:	30 25       	mov	r5,2
8000d766:	c2 88       	rjmp	8000d7b6 <_dtoa_r+0x412>
8000d768:	4a bc       	lddpc	r12,8000d814 <_dtoa_r+0x470>
8000d76a:	f0 04 14 04 	asr	r4,r8,0x4
8000d76e:	50 1c       	stdsp	sp[0x4],r12
8000d770:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000d774:	4a 79       	lddpc	r9,8000d810 <_dtoa_r+0x46c>
8000d776:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d77a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d77e:	e0 a0 0c 79 	rcall	8000f070 <__avr32_f64_mul>
8000d782:	40 1c       	lddsp	r12,sp[0x4]
8000d784:	50 63       	stdsp	sp[0x18],r3
8000d786:	30 25       	mov	r5,2
8000d788:	0c 93       	mov	r3,r6
8000d78a:	fa eb 00 08 	st.d	sp[8],r10
8000d78e:	18 96       	mov	r6,r12
8000d790:	c0 f8       	rjmp	8000d7ae <_dtoa_r+0x40a>
8000d792:	fa ea 00 08 	ld.d	r10,sp[8]
8000d796:	ed b4 00 00 	bld	r4,0x0
8000d79a:	c0 81       	brne	8000d7aa <_dtoa_r+0x406>
8000d79c:	ec e8 00 00 	ld.d	r8,r6[0]
8000d7a0:	2f f5       	sub	r5,-1
8000d7a2:	e0 a0 0c 67 	rcall	8000f070 <__avr32_f64_mul>
8000d7a6:	fa eb 00 08 	st.d	sp[8],r10
8000d7aa:	a1 54       	asr	r4,0x1
8000d7ac:	2f 86       	sub	r6,-8
8000d7ae:	58 04       	cp.w	r4,0
8000d7b0:	cf 11       	brne	8000d792 <_dtoa_r+0x3ee>
8000d7b2:	06 96       	mov	r6,r3
8000d7b4:	40 63       	lddsp	r3,sp[0x18]
8000d7b6:	41 4a       	lddsp	r10,sp[0x50]
8000d7b8:	58 0a       	cp.w	r10,0
8000d7ba:	c2 f0       	breq	8000d818 <_dtoa_r+0x474>
8000d7bc:	fa e8 00 08 	ld.d	r8,sp[8]
8000d7c0:	58 01       	cp.w	r1,0
8000d7c2:	5f 94       	srgt	r4
8000d7c4:	fa e9 00 18 	st.d	sp[24],r8
8000d7c8:	30 08       	mov	r8,0
8000d7ca:	fc 19 3f f0 	movh	r9,0x3ff0
8000d7ce:	fa ea 00 18 	ld.d	r10,sp[24]
8000d7d2:	e0 a0 0f 61 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000d7d6:	f9 bc 00 00 	moveq	r12,0
8000d7da:	f9 bc 01 01 	movne	r12,1
8000d7de:	e9 ec 00 0c 	and	r12,r4,r12
8000d7e2:	c1 b0       	breq	8000d818 <_dtoa_r+0x474>
8000d7e4:	40 98       	lddsp	r8,sp[0x24]
8000d7e6:	58 08       	cp.w	r8,0
8000d7e8:	e0 8a 00 f6 	brle	8000d9d4 <_dtoa_r+0x630>
8000d7ec:	30 08       	mov	r8,0
8000d7ee:	fc 19 40 24 	movh	r9,0x4024
8000d7f2:	ec c4 00 01 	sub	r4,r6,1
8000d7f6:	fa ea 00 18 	ld.d	r10,sp[24]
8000d7fa:	2f f5       	sub	r5,-1
8000d7fc:	50 64       	stdsp	sp[0x18],r4
8000d7fe:	e0 a0 0c 39 	rcall	8000f070 <__avr32_f64_mul>
8000d802:	40 94       	lddsp	r4,sp[0x24]
8000d804:	14 98       	mov	r8,r10
8000d806:	16 99       	mov	r9,r11
8000d808:	fa e9 00 08 	st.d	sp[8],r8
8000d80c:	c0 88       	rjmp	8000d81c <_dtoa_r+0x478>
8000d80e:	d7 03       	nop
8000d810:	80 01       	ld.sh	r1,r0[0x0]
8000d812:	9d 40       	st.w	lr[0x10],r0
8000d814:	80 01       	ld.sh	r1,r0[0x0]
8000d816:	9e 08       	ld.sh	r8,pc[0x0]
8000d818:	50 66       	stdsp	sp[0x18],r6
8000d81a:	02 94       	mov	r4,r1
8000d81c:	0a 9c       	mov	r12,r5
8000d81e:	e0 a0 0e 84 	rcall	8000f526 <__avr32_s32_to_f64>
8000d822:	fa e8 00 08 	ld.d	r8,sp[8]
8000d826:	e0 a0 0c 25 	rcall	8000f070 <__avr32_f64_mul>
8000d82a:	30 08       	mov	r8,0
8000d82c:	fc 19 40 1c 	movh	r9,0x401c
8000d830:	e0 a0 0d da 	rcall	8000f3e4 <__avr32_f64_add>
8000d834:	14 98       	mov	r8,r10
8000d836:	16 99       	mov	r9,r11
8000d838:	fa e9 00 28 	st.d	sp[40],r8
8000d83c:	fc 18 fc c0 	movh	r8,0xfcc0
8000d840:	40 a5       	lddsp	r5,sp[0x28]
8000d842:	10 05       	add	r5,r8
8000d844:	50 a5       	stdsp	sp[0x28],r5
8000d846:	58 04       	cp.w	r4,0
8000d848:	c2 11       	brne	8000d88a <_dtoa_r+0x4e6>
8000d84a:	fa ea 00 08 	ld.d	r10,sp[8]
8000d84e:	30 08       	mov	r8,0
8000d850:	fc 19 40 14 	movh	r9,0x4014
8000d854:	e0 a0 0c fa 	rcall	8000f248 <__avr32_f64_sub>
8000d858:	40 bc       	lddsp	r12,sp[0x2c]
8000d85a:	fa eb 00 08 	st.d	sp[8],r10
8000d85e:	14 98       	mov	r8,r10
8000d860:	16 99       	mov	r9,r11
8000d862:	18 9a       	mov	r10,r12
8000d864:	0a 9b       	mov	r11,r5
8000d866:	e0 a0 0f 17 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000d86a:	e0 81 02 54 	brne	8000dd12 <_dtoa_r+0x96e>
8000d86e:	0a 98       	mov	r8,r5
8000d870:	40 b9       	lddsp	r9,sp[0x2c]
8000d872:	ee 18 80 00 	eorh	r8,0x8000
8000d876:	fa ea 00 08 	ld.d	r10,sp[8]
8000d87a:	10 95       	mov	r5,r8
8000d87c:	12 98       	mov	r8,r9
8000d87e:	0a 99       	mov	r9,r5
8000d880:	e0 a0 0f 0a 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000d884:	e0 81 02 3e 	brne	8000dd00 <_dtoa_r+0x95c>
8000d888:	ca 68       	rjmp	8000d9d4 <_dtoa_r+0x630>
8000d88a:	4c e9       	lddpc	r9,8000d9c0 <_dtoa_r+0x61c>
8000d88c:	e8 c8 00 01 	sub	r8,r4,1
8000d890:	40 d5       	lddsp	r5,sp[0x34]
8000d892:	58 05       	cp.w	r5,0
8000d894:	c4 f0       	breq	8000d932 <_dtoa_r+0x58e>
8000d896:	30 0c       	mov	r12,0
8000d898:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000d89c:	51 3c       	stdsp	sp[0x4c],r12
8000d89e:	30 0a       	mov	r10,0
8000d8a0:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d8a4:	e0 a0 0f 2c 	rcall	8000f6fc <__avr32_f64_div>
8000d8a8:	fa e8 00 28 	ld.d	r8,sp[40]
8000d8ac:	40 85       	lddsp	r5,sp[0x20]
8000d8ae:	e0 a0 0c cd 	rcall	8000f248 <__avr32_f64_sub>
8000d8b2:	fa eb 00 28 	st.d	sp[40],r10
8000d8b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000d8ba:	e0 a0 0e 1f 	rcall	8000f4f8 <__avr32_f64_to_s32>
8000d8be:	51 6c       	stdsp	sp[0x58],r12
8000d8c0:	e0 a0 0e 33 	rcall	8000f526 <__avr32_s32_to_f64>
8000d8c4:	14 98       	mov	r8,r10
8000d8c6:	16 99       	mov	r9,r11
8000d8c8:	fa ea 00 08 	ld.d	r10,sp[8]
8000d8cc:	e0 a0 0c be 	rcall	8000f248 <__avr32_f64_sub>
8000d8d0:	fa eb 00 08 	st.d	sp[8],r10
8000d8d4:	41 68       	lddsp	r8,sp[0x58]
8000d8d6:	2d 08       	sub	r8,-48
8000d8d8:	0a c8       	st.b	r5++,r8
8000d8da:	41 39       	lddsp	r9,sp[0x4c]
8000d8dc:	2f f9       	sub	r9,-1
8000d8de:	51 39       	stdsp	sp[0x4c],r9
8000d8e0:	fa e8 00 28 	ld.d	r8,sp[40]
8000d8e4:	e0 a0 0e d8 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000d8e8:	e0 81 03 3a 	brne	8000df5c <_dtoa_r+0xbb8>
8000d8ec:	fa e8 00 08 	ld.d	r8,sp[8]
8000d8f0:	30 0a       	mov	r10,0
8000d8f2:	fc 1b 3f f0 	movh	r11,0x3ff0
8000d8f6:	e0 a0 0c a9 	rcall	8000f248 <__avr32_f64_sub>
8000d8fa:	fa e8 00 28 	ld.d	r8,sp[40]
8000d8fe:	e0 a0 0e cb 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000d902:	fa ea 00 28 	ld.d	r10,sp[40]
8000d906:	30 08       	mov	r8,0
8000d908:	fc 19 40 24 	movh	r9,0x4024
8000d90c:	e0 81 00 da 	brne	8000dac0 <_dtoa_r+0x71c>
8000d910:	41 3c       	lddsp	r12,sp[0x4c]
8000d912:	08 3c       	cp.w	r12,r4
8000d914:	c6 04       	brge	8000d9d4 <_dtoa_r+0x630>
8000d916:	e0 a0 0b ad 	rcall	8000f070 <__avr32_f64_mul>
8000d91a:	30 08       	mov	r8,0
8000d91c:	fa eb 00 28 	st.d	sp[40],r10
8000d920:	fc 19 40 24 	movh	r9,0x4024
8000d924:	fa ea 00 08 	ld.d	r10,sp[8]
8000d928:	e0 a0 0b a4 	rcall	8000f070 <__avr32_f64_mul>
8000d92c:	fa eb 00 08 	st.d	sp[8],r10
8000d930:	cc 3b       	rjmp	8000d8b6 <_dtoa_r+0x512>
8000d932:	40 85       	lddsp	r5,sp[0x20]
8000d934:	08 05       	add	r5,r4
8000d936:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000d93a:	51 35       	stdsp	sp[0x4c],r5
8000d93c:	fa e8 00 28 	ld.d	r8,sp[40]
8000d940:	40 85       	lddsp	r5,sp[0x20]
8000d942:	e0 a0 0b 97 	rcall	8000f070 <__avr32_f64_mul>
8000d946:	fa eb 00 28 	st.d	sp[40],r10
8000d94a:	fa ea 00 08 	ld.d	r10,sp[8]
8000d94e:	e0 a0 0d d5 	rcall	8000f4f8 <__avr32_f64_to_s32>
8000d952:	51 6c       	stdsp	sp[0x58],r12
8000d954:	e0 a0 0d e9 	rcall	8000f526 <__avr32_s32_to_f64>
8000d958:	14 98       	mov	r8,r10
8000d95a:	16 99       	mov	r9,r11
8000d95c:	fa ea 00 08 	ld.d	r10,sp[8]
8000d960:	e0 a0 0c 74 	rcall	8000f248 <__avr32_f64_sub>
8000d964:	fa eb 00 08 	st.d	sp[8],r10
8000d968:	41 68       	lddsp	r8,sp[0x58]
8000d96a:	2d 08       	sub	r8,-48
8000d96c:	0a c8       	st.b	r5++,r8
8000d96e:	41 3c       	lddsp	r12,sp[0x4c]
8000d970:	18 35       	cp.w	r5,r12
8000d972:	c2 91       	brne	8000d9c4 <_dtoa_r+0x620>
8000d974:	30 08       	mov	r8,0
8000d976:	fc 19 3f e0 	movh	r9,0x3fe0
8000d97a:	fa ea 00 28 	ld.d	r10,sp[40]
8000d97e:	e0 a0 0d 33 	rcall	8000f3e4 <__avr32_f64_add>
8000d982:	40 85       	lddsp	r5,sp[0x20]
8000d984:	fa e8 00 08 	ld.d	r8,sp[8]
8000d988:	08 05       	add	r5,r4
8000d98a:	e0 a0 0e 85 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000d98e:	e0 81 00 99 	brne	8000dac0 <_dtoa_r+0x71c>
8000d992:	fa e8 00 28 	ld.d	r8,sp[40]
8000d996:	30 0a       	mov	r10,0
8000d998:	fc 1b 3f e0 	movh	r11,0x3fe0
8000d99c:	e0 a0 0c 56 	rcall	8000f248 <__avr32_f64_sub>
8000d9a0:	14 98       	mov	r8,r10
8000d9a2:	16 99       	mov	r9,r11
8000d9a4:	fa ea 00 08 	ld.d	r10,sp[8]
8000d9a8:	e0 a0 0e 76 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000d9ac:	c1 40       	breq	8000d9d4 <_dtoa_r+0x630>
8000d9ae:	33 09       	mov	r9,48
8000d9b0:	0a 98       	mov	r8,r5
8000d9b2:	11 7a       	ld.ub	r10,--r8
8000d9b4:	f2 0a 18 00 	cp.b	r10,r9
8000d9b8:	e0 81 02 d2 	brne	8000df5c <_dtoa_r+0xbb8>
8000d9bc:	10 95       	mov	r5,r8
8000d9be:	cf 9b       	rjmp	8000d9b0 <_dtoa_r+0x60c>
8000d9c0:	80 01       	ld.sh	r1,r0[0x0]
8000d9c2:	9d 40       	st.w	lr[0x10],r0
8000d9c4:	30 08       	mov	r8,0
8000d9c6:	fc 19 40 24 	movh	r9,0x4024
8000d9ca:	e0 a0 0b 53 	rcall	8000f070 <__avr32_f64_mul>
8000d9ce:	fa eb 00 08 	st.d	sp[8],r10
8000d9d2:	cb cb       	rjmp	8000d94a <_dtoa_r+0x5a6>
8000d9d4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000d9d8:	fa eb 00 08 	st.d	sp[8],r10
8000d9dc:	58 e6       	cp.w	r6,14
8000d9de:	5f ab       	srle	r11
8000d9e0:	41 8a       	lddsp	r10,sp[0x60]
8000d9e2:	30 08       	mov	r8,0
8000d9e4:	f4 09 11 ff 	rsub	r9,r10,-1
8000d9e8:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000d9ec:	f0 09 18 00 	cp.b	r9,r8
8000d9f0:	e0 80 00 81 	breq	8000daf2 <_dtoa_r+0x74e>
8000d9f4:	40 ea       	lddsp	r10,sp[0x38]
8000d9f6:	58 01       	cp.w	r1,0
8000d9f8:	5f a9       	srle	r9
8000d9fa:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000d9fe:	4c 9a       	lddpc	r10,8000db20 <_dtoa_r+0x77c>
8000da00:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000da04:	fa e5 00 10 	st.d	sp[16],r4
8000da08:	f0 09 18 00 	cp.b	r9,r8
8000da0c:	c1 40       	breq	8000da34 <_dtoa_r+0x690>
8000da0e:	58 01       	cp.w	r1,0
8000da10:	e0 81 01 78 	brne	8000dd00 <_dtoa_r+0x95c>
8000da14:	30 08       	mov	r8,0
8000da16:	fc 19 40 14 	movh	r9,0x4014
8000da1a:	08 9a       	mov	r10,r4
8000da1c:	0a 9b       	mov	r11,r5
8000da1e:	e0 a0 0b 29 	rcall	8000f070 <__avr32_f64_mul>
8000da22:	fa e8 00 08 	ld.d	r8,sp[8]
8000da26:	e0 a0 0e 03 	rcall	8000f62c <__avr32_f64_cmp_ge>
8000da2a:	e0 81 01 6b 	brne	8000dd00 <_dtoa_r+0x95c>
8000da2e:	02 92       	mov	r2,r1
8000da30:	e0 8f 01 73 	bral	8000dd16 <_dtoa_r+0x972>
8000da34:	40 85       	lddsp	r5,sp[0x20]
8000da36:	30 14       	mov	r4,1
8000da38:	fa e8 00 10 	ld.d	r8,sp[16]
8000da3c:	fa ea 00 08 	ld.d	r10,sp[8]
8000da40:	e0 a0 0e 5e 	rcall	8000f6fc <__avr32_f64_div>
8000da44:	e0 a0 0d 5a 	rcall	8000f4f8 <__avr32_f64_to_s32>
8000da48:	18 92       	mov	r2,r12
8000da4a:	e0 a0 0d 6e 	rcall	8000f526 <__avr32_s32_to_f64>
8000da4e:	fa e8 00 10 	ld.d	r8,sp[16]
8000da52:	e0 a0 0b 0f 	rcall	8000f070 <__avr32_f64_mul>
8000da56:	14 98       	mov	r8,r10
8000da58:	16 99       	mov	r9,r11
8000da5a:	fa ea 00 08 	ld.d	r10,sp[8]
8000da5e:	e0 a0 0b f5 	rcall	8000f248 <__avr32_f64_sub>
8000da62:	fa eb 00 08 	st.d	sp[8],r10
8000da66:	e4 c8 ff d0 	sub	r8,r2,-48
8000da6a:	0a c8       	st.b	r5++,r8
8000da6c:	fc 19 40 24 	movh	r9,0x4024
8000da70:	30 08       	mov	r8,0
8000da72:	02 34       	cp.w	r4,r1
8000da74:	c3 31       	brne	8000dada <_dtoa_r+0x736>
8000da76:	fa e8 00 08 	ld.d	r8,sp[8]
8000da7a:	e0 a0 0c b5 	rcall	8000f3e4 <__avr32_f64_add>
8000da7e:	16 91       	mov	r1,r11
8000da80:	14 90       	mov	r0,r10
8000da82:	14 98       	mov	r8,r10
8000da84:	02 99       	mov	r9,r1
8000da86:	fa ea 00 10 	ld.d	r10,sp[16]
8000da8a:	e0 a0 0e 05 	rcall	8000f694 <__avr32_f64_cmp_lt>
8000da8e:	c1 a1       	brne	8000dac2 <_dtoa_r+0x71e>
8000da90:	fa e8 00 10 	ld.d	r8,sp[16]
8000da94:	00 9a       	mov	r10,r0
8000da96:	02 9b       	mov	r11,r1
8000da98:	e0 a0 0d b7 	rcall	8000f606 <__avr32_f64_cmp_eq>
8000da9c:	e0 80 02 5f 	breq	8000df5a <_dtoa_r+0xbb6>
8000daa0:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000daa4:	c0 f1       	brne	8000dac2 <_dtoa_r+0x71e>
8000daa6:	e0 8f 02 5a 	bral	8000df5a <_dtoa_r+0xbb6>
8000daaa:	40 8a       	lddsp	r10,sp[0x20]
8000daac:	14 38       	cp.w	r8,r10
8000daae:	c0 30       	breq	8000dab4 <_dtoa_r+0x710>
8000dab0:	10 95       	mov	r5,r8
8000dab2:	c0 98       	rjmp	8000dac4 <_dtoa_r+0x720>
8000dab4:	33 08       	mov	r8,48
8000dab6:	40 89       	lddsp	r9,sp[0x20]
8000dab8:	2f f6       	sub	r6,-1
8000daba:	b2 88       	st.b	r9[0x0],r8
8000dabc:	40 88       	lddsp	r8,sp[0x20]
8000dabe:	c0 88       	rjmp	8000dace <_dtoa_r+0x72a>
8000dac0:	40 66       	lddsp	r6,sp[0x18]
8000dac2:	33 99       	mov	r9,57
8000dac4:	0a 98       	mov	r8,r5
8000dac6:	11 7a       	ld.ub	r10,--r8
8000dac8:	f2 0a 18 00 	cp.b	r10,r9
8000dacc:	ce f0       	breq	8000daaa <_dtoa_r+0x706>
8000dace:	50 66       	stdsp	sp[0x18],r6
8000dad0:	11 89       	ld.ub	r9,r8[0x0]
8000dad2:	2f f9       	sub	r9,-1
8000dad4:	b0 89       	st.b	r8[0x0],r9
8000dad6:	e0 8f 02 43 	bral	8000df5c <_dtoa_r+0xbb8>
8000dada:	e0 a0 0a cb 	rcall	8000f070 <__avr32_f64_mul>
8000dade:	2f f4       	sub	r4,-1
8000dae0:	fa eb 00 08 	st.d	sp[8],r10
8000dae4:	30 08       	mov	r8,0
8000dae6:	30 09       	mov	r9,0
8000dae8:	e0 a0 0d 8f 	rcall	8000f606 <__avr32_f64_cmp_eq>
8000daec:	ca 60       	breq	8000da38 <_dtoa_r+0x694>
8000daee:	e0 8f 02 36 	bral	8000df5a <_dtoa_r+0xbb6>
8000daf2:	40 d8       	lddsp	r8,sp[0x34]
8000daf4:	58 08       	cp.w	r8,0
8000daf6:	c0 51       	brne	8000db00 <_dtoa_r+0x75c>
8000daf8:	04 98       	mov	r8,r2
8000dafa:	00 95       	mov	r5,r0
8000dafc:	40 d4       	lddsp	r4,sp[0x34]
8000dafe:	c3 88       	rjmp	8000db6e <_dtoa_r+0x7ca>
8000db00:	40 c5       	lddsp	r5,sp[0x30]
8000db02:	58 15       	cp.w	r5,1
8000db04:	e0 89 00 10 	brgt	8000db24 <_dtoa_r+0x780>
8000db08:	41 74       	lddsp	r4,sp[0x5c]
8000db0a:	58 04       	cp.w	r4,0
8000db0c:	c0 40       	breq	8000db14 <_dtoa_r+0x770>
8000db0e:	f4 c9 fb cd 	sub	r9,r10,-1075
8000db12:	c0 48       	rjmp	8000db1a <_dtoa_r+0x776>
8000db14:	41 99       	lddsp	r9,sp[0x64]
8000db16:	f2 09 11 36 	rsub	r9,r9,54
8000db1a:	04 98       	mov	r8,r2
8000db1c:	00 95       	mov	r5,r0
8000db1e:	c1 d8       	rjmp	8000db58 <_dtoa_r+0x7b4>
8000db20:	80 01       	ld.sh	r1,r0[0x0]
8000db22:	9d 40       	st.w	lr[0x10],r0
8000db24:	e2 c8 00 01 	sub	r8,r1,1
8000db28:	58 01       	cp.w	r1,0
8000db2a:	e0 05 17 40 	movge	r5,r0
8000db2e:	e2 09 17 40 	movge	r9,r1
8000db32:	e1 d1 e5 15 	sublt	r5,r0,r1
8000db36:	f9 b9 05 00 	movlt	r9,0
8000db3a:	10 32       	cp.w	r2,r8
8000db3c:	e5 d8 e4 18 	subge	r8,r2,r8
8000db40:	f1 d2 e5 18 	sublt	r8,r8,r2
8000db44:	e5 d8 e5 02 	addlt	r2,r2,r8
8000db48:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000db4c:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000db50:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000db54:	f9 b8 05 00 	movlt	r8,0
8000db58:	40 4b       	lddsp	r11,sp[0x10]
8000db5a:	12 0b       	add	r11,r9
8000db5c:	50 08       	stdsp	sp[0x0],r8
8000db5e:	50 4b       	stdsp	sp[0x10],r11
8000db60:	12 00       	add	r0,r9
8000db62:	30 1b       	mov	r11,1
8000db64:	0e 9c       	mov	r12,r7
8000db66:	e0 a0 08 ab 	rcall	8000ecbc <__i2b>
8000db6a:	40 08       	lddsp	r8,sp[0x0]
8000db6c:	18 94       	mov	r4,r12
8000db6e:	40 4a       	lddsp	r10,sp[0x10]
8000db70:	58 05       	cp.w	r5,0
8000db72:	5f 99       	srgt	r9
8000db74:	58 0a       	cp.w	r10,0
8000db76:	5f 9a       	srgt	r10
8000db78:	f5 e9 00 09 	and	r9,r10,r9
8000db7c:	c0 80       	breq	8000db8c <_dtoa_r+0x7e8>
8000db7e:	40 4c       	lddsp	r12,sp[0x10]
8000db80:	f8 05 0d 49 	min	r9,r12,r5
8000db84:	12 1c       	sub	r12,r9
8000db86:	12 10       	sub	r0,r9
8000db88:	50 4c       	stdsp	sp[0x10],r12
8000db8a:	12 15       	sub	r5,r9
8000db8c:	58 02       	cp.w	r2,0
8000db8e:	e0 8a 00 27 	brle	8000dbdc <_dtoa_r+0x838>
8000db92:	40 db       	lddsp	r11,sp[0x34]
8000db94:	58 0b       	cp.w	r11,0
8000db96:	c1 d0       	breq	8000dbd0 <_dtoa_r+0x82c>
8000db98:	58 08       	cp.w	r8,0
8000db9a:	e0 8a 00 17 	brle	8000dbc8 <_dtoa_r+0x824>
8000db9e:	10 9a       	mov	r10,r8
8000dba0:	50 08       	stdsp	sp[0x0],r8
8000dba2:	08 9b       	mov	r11,r4
8000dba4:	0e 9c       	mov	r12,r7
8000dba6:	e0 a0 08 d1 	rcall	8000ed48 <__pow5mult>
8000dbaa:	06 9a       	mov	r10,r3
8000dbac:	18 9b       	mov	r11,r12
8000dbae:	18 94       	mov	r4,r12
8000dbb0:	0e 9c       	mov	r12,r7
8000dbb2:	e0 a0 08 05 	rcall	8000ebbc <__multiply>
8000dbb6:	18 99       	mov	r9,r12
8000dbb8:	06 9b       	mov	r11,r3
8000dbba:	50 19       	stdsp	sp[0x4],r9
8000dbbc:	0e 9c       	mov	r12,r7
8000dbbe:	e0 a0 06 b1 	rcall	8000e920 <_Bfree>
8000dbc2:	40 19       	lddsp	r9,sp[0x4]
8000dbc4:	40 08       	lddsp	r8,sp[0x0]
8000dbc6:	12 93       	mov	r3,r9
8000dbc8:	e4 08 01 0a 	sub	r10,r2,r8
8000dbcc:	c0 80       	breq	8000dbdc <_dtoa_r+0x838>
8000dbce:	c0 28       	rjmp	8000dbd2 <_dtoa_r+0x82e>
8000dbd0:	04 9a       	mov	r10,r2
8000dbd2:	06 9b       	mov	r11,r3
8000dbd4:	0e 9c       	mov	r12,r7
8000dbd6:	e0 a0 08 b9 	rcall	8000ed48 <__pow5mult>
8000dbda:	18 93       	mov	r3,r12
8000dbdc:	30 1b       	mov	r11,1
8000dbde:	0e 9c       	mov	r12,r7
8000dbe0:	e0 a0 08 6e 	rcall	8000ecbc <__i2b>
8000dbe4:	41 1a       	lddsp	r10,sp[0x44]
8000dbe6:	18 92       	mov	r2,r12
8000dbe8:	58 0a       	cp.w	r10,0
8000dbea:	e0 8a 00 07 	brle	8000dbf8 <_dtoa_r+0x854>
8000dbee:	18 9b       	mov	r11,r12
8000dbf0:	0e 9c       	mov	r12,r7
8000dbf2:	e0 a0 08 ab 	rcall	8000ed48 <__pow5mult>
8000dbf6:	18 92       	mov	r2,r12
8000dbf8:	40 c9       	lddsp	r9,sp[0x30]
8000dbfa:	58 19       	cp.w	r9,1
8000dbfc:	e0 89 00 14 	brgt	8000dc24 <_dtoa_r+0x880>
8000dc00:	40 38       	lddsp	r8,sp[0xc]
8000dc02:	58 08       	cp.w	r8,0
8000dc04:	c1 01       	brne	8000dc24 <_dtoa_r+0x880>
8000dc06:	40 29       	lddsp	r9,sp[0x8]
8000dc08:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000dc0c:	c0 c1       	brne	8000dc24 <_dtoa_r+0x880>
8000dc0e:	12 98       	mov	r8,r9
8000dc10:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000dc14:	c0 80       	breq	8000dc24 <_dtoa_r+0x880>
8000dc16:	40 4c       	lddsp	r12,sp[0x10]
8000dc18:	30 1b       	mov	r11,1
8000dc1a:	2f fc       	sub	r12,-1
8000dc1c:	2f f0       	sub	r0,-1
8000dc1e:	50 4c       	stdsp	sp[0x10],r12
8000dc20:	50 6b       	stdsp	sp[0x18],r11
8000dc22:	c0 38       	rjmp	8000dc28 <_dtoa_r+0x884>
8000dc24:	30 0a       	mov	r10,0
8000dc26:	50 6a       	stdsp	sp[0x18],r10
8000dc28:	41 19       	lddsp	r9,sp[0x44]
8000dc2a:	58 09       	cp.w	r9,0
8000dc2c:	c0 31       	brne	8000dc32 <_dtoa_r+0x88e>
8000dc2e:	30 1c       	mov	r12,1
8000dc30:	c0 98       	rjmp	8000dc42 <_dtoa_r+0x89e>
8000dc32:	64 48       	ld.w	r8,r2[0x10]
8000dc34:	2f c8       	sub	r8,-4
8000dc36:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000dc3a:	e0 a0 05 e3 	rcall	8000e800 <__hi0bits>
8000dc3e:	f8 0c 11 20 	rsub	r12,r12,32
8000dc42:	40 4b       	lddsp	r11,sp[0x10]
8000dc44:	f8 0b 00 08 	add	r8,r12,r11
8000dc48:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000dc4c:	c0 c0       	breq	8000dc64 <_dtoa_r+0x8c0>
8000dc4e:	f0 08 11 20 	rsub	r8,r8,32
8000dc52:	58 48       	cp.w	r8,4
8000dc54:	e0 8a 00 06 	brle	8000dc60 <_dtoa_r+0x8bc>
8000dc58:	20 48       	sub	r8,4
8000dc5a:	10 0b       	add	r11,r8
8000dc5c:	50 4b       	stdsp	sp[0x10],r11
8000dc5e:	c0 78       	rjmp	8000dc6c <_dtoa_r+0x8c8>
8000dc60:	58 48       	cp.w	r8,4
8000dc62:	c0 70       	breq	8000dc70 <_dtoa_r+0x8cc>
8000dc64:	40 4a       	lddsp	r10,sp[0x10]
8000dc66:	2e 48       	sub	r8,-28
8000dc68:	10 0a       	add	r10,r8
8000dc6a:	50 4a       	stdsp	sp[0x10],r10
8000dc6c:	10 00       	add	r0,r8
8000dc6e:	10 05       	add	r5,r8
8000dc70:	58 00       	cp.w	r0,0
8000dc72:	e0 8a 00 08 	brle	8000dc82 <_dtoa_r+0x8de>
8000dc76:	06 9b       	mov	r11,r3
8000dc78:	00 9a       	mov	r10,r0
8000dc7a:	0e 9c       	mov	r12,r7
8000dc7c:	e0 a0 07 5c 	rcall	8000eb34 <__lshift>
8000dc80:	18 93       	mov	r3,r12
8000dc82:	40 49       	lddsp	r9,sp[0x10]
8000dc84:	58 09       	cp.w	r9,0
8000dc86:	e0 8a 00 08 	brle	8000dc96 <_dtoa_r+0x8f2>
8000dc8a:	04 9b       	mov	r11,r2
8000dc8c:	12 9a       	mov	r10,r9
8000dc8e:	0e 9c       	mov	r12,r7
8000dc90:	e0 a0 07 52 	rcall	8000eb34 <__lshift>
8000dc94:	18 92       	mov	r2,r12
8000dc96:	41 48       	lddsp	r8,sp[0x50]
8000dc98:	58 08       	cp.w	r8,0
8000dc9a:	c1 b0       	breq	8000dcd0 <_dtoa_r+0x92c>
8000dc9c:	04 9b       	mov	r11,r2
8000dc9e:	06 9c       	mov	r12,r3
8000dca0:	e0 a0 06 27 	rcall	8000e8ee <__mcmp>
8000dca4:	c1 64       	brge	8000dcd0 <_dtoa_r+0x92c>
8000dca6:	06 9b       	mov	r11,r3
8000dca8:	30 09       	mov	r9,0
8000dcaa:	30 aa       	mov	r10,10
8000dcac:	0e 9c       	mov	r12,r7
8000dcae:	e0 a0 08 0f 	rcall	8000eccc <__multadd>
8000dcb2:	20 16       	sub	r6,1
8000dcb4:	18 93       	mov	r3,r12
8000dcb6:	40 dc       	lddsp	r12,sp[0x34]
8000dcb8:	58 0c       	cp.w	r12,0
8000dcba:	c0 31       	brne	8000dcc0 <_dtoa_r+0x91c>
8000dcbc:	40 91       	lddsp	r1,sp[0x24]
8000dcbe:	c0 98       	rjmp	8000dcd0 <_dtoa_r+0x92c>
8000dcc0:	08 9b       	mov	r11,r4
8000dcc2:	40 91       	lddsp	r1,sp[0x24]
8000dcc4:	30 09       	mov	r9,0
8000dcc6:	30 aa       	mov	r10,10
8000dcc8:	0e 9c       	mov	r12,r7
8000dcca:	e0 a0 08 01 	rcall	8000eccc <__multadd>
8000dcce:	18 94       	mov	r4,r12
8000dcd0:	58 01       	cp.w	r1,0
8000dcd2:	5f a9       	srle	r9
8000dcd4:	40 cb       	lddsp	r11,sp[0x30]
8000dcd6:	58 2b       	cp.w	r11,2
8000dcd8:	5f 98       	srgt	r8
8000dcda:	f3 e8 00 08 	and	r8,r9,r8
8000dcde:	c2 50       	breq	8000dd28 <_dtoa_r+0x984>
8000dce0:	58 01       	cp.w	r1,0
8000dce2:	c1 11       	brne	8000dd04 <_dtoa_r+0x960>
8000dce4:	04 9b       	mov	r11,r2
8000dce6:	02 99       	mov	r9,r1
8000dce8:	30 5a       	mov	r10,5
8000dcea:	0e 9c       	mov	r12,r7
8000dcec:	e0 a0 07 f0 	rcall	8000eccc <__multadd>
8000dcf0:	18 92       	mov	r2,r12
8000dcf2:	18 9b       	mov	r11,r12
8000dcf4:	06 9c       	mov	r12,r3
8000dcf6:	e0 a0 05 fc 	rcall	8000e8ee <__mcmp>
8000dcfa:	e0 89 00 0f 	brgt	8000dd18 <_dtoa_r+0x974>
8000dcfe:	c0 38       	rjmp	8000dd04 <_dtoa_r+0x960>
8000dd00:	30 02       	mov	r2,0
8000dd02:	04 94       	mov	r4,r2
8000dd04:	40 ea       	lddsp	r10,sp[0x38]
8000dd06:	30 09       	mov	r9,0
8000dd08:	5c da       	com	r10
8000dd0a:	40 85       	lddsp	r5,sp[0x20]
8000dd0c:	50 6a       	stdsp	sp[0x18],r10
8000dd0e:	50 49       	stdsp	sp[0x10],r9
8000dd10:	c0 f9       	rjmp	8000df2e <_dtoa_r+0xb8a>
8000dd12:	08 92       	mov	r2,r4
8000dd14:	40 66       	lddsp	r6,sp[0x18]
8000dd16:	04 94       	mov	r4,r2
8000dd18:	2f f6       	sub	r6,-1
8000dd1a:	50 66       	stdsp	sp[0x18],r6
8000dd1c:	33 18       	mov	r8,49
8000dd1e:	40 85       	lddsp	r5,sp[0x20]
8000dd20:	0a c8       	st.b	r5++,r8
8000dd22:	30 08       	mov	r8,0
8000dd24:	50 48       	stdsp	sp[0x10],r8
8000dd26:	c0 49       	rjmp	8000df2e <_dtoa_r+0xb8a>
8000dd28:	40 dc       	lddsp	r12,sp[0x34]
8000dd2a:	58 0c       	cp.w	r12,0
8000dd2c:	e0 80 00 b5 	breq	8000de96 <_dtoa_r+0xaf2>
8000dd30:	58 05       	cp.w	r5,0
8000dd32:	e0 8a 00 08 	brle	8000dd42 <_dtoa_r+0x99e>
8000dd36:	08 9b       	mov	r11,r4
8000dd38:	0a 9a       	mov	r10,r5
8000dd3a:	0e 9c       	mov	r12,r7
8000dd3c:	e0 a0 06 fc 	rcall	8000eb34 <__lshift>
8000dd40:	18 94       	mov	r4,r12
8000dd42:	40 6b       	lddsp	r11,sp[0x18]
8000dd44:	58 0b       	cp.w	r11,0
8000dd46:	c0 31       	brne	8000dd4c <_dtoa_r+0x9a8>
8000dd48:	08 9c       	mov	r12,r4
8000dd4a:	c1 38       	rjmp	8000dd70 <_dtoa_r+0x9cc>
8000dd4c:	68 1b       	ld.w	r11,r4[0x4]
8000dd4e:	0e 9c       	mov	r12,r7
8000dd50:	e0 a0 06 02 	rcall	8000e954 <_Balloc>
8000dd54:	68 4a       	ld.w	r10,r4[0x10]
8000dd56:	18 95       	mov	r5,r12
8000dd58:	e8 cb ff f4 	sub	r11,r4,-12
8000dd5c:	2f ea       	sub	r10,-2
8000dd5e:	2f 4c       	sub	r12,-12
8000dd60:	a3 6a       	lsl	r10,0x2
8000dd62:	fe b0 e5 ae 	rcall	8000a8be <memcpy>
8000dd66:	0a 9b       	mov	r11,r5
8000dd68:	30 1a       	mov	r10,1
8000dd6a:	0e 9c       	mov	r12,r7
8000dd6c:	e0 a0 06 e4 	rcall	8000eb34 <__lshift>
8000dd70:	50 44       	stdsp	sp[0x10],r4
8000dd72:	40 3a       	lddsp	r10,sp[0xc]
8000dd74:	30 19       	mov	r9,1
8000dd76:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000dd7a:	18 94       	mov	r4,r12
8000dd7c:	50 da       	stdsp	sp[0x34],r10
8000dd7e:	40 85       	lddsp	r5,sp[0x20]
8000dd80:	50 99       	stdsp	sp[0x24],r9
8000dd82:	50 26       	stdsp	sp[0x8],r6
8000dd84:	50 e1       	stdsp	sp[0x38],r1
8000dd86:	04 9b       	mov	r11,r2
8000dd88:	06 9c       	mov	r12,r3
8000dd8a:	fe b0 fa 7d 	rcall	8000d284 <quorem>
8000dd8e:	40 4b       	lddsp	r11,sp[0x10]
8000dd90:	f8 c0 ff d0 	sub	r0,r12,-48
8000dd94:	06 9c       	mov	r12,r3
8000dd96:	e0 a0 05 ac 	rcall	8000e8ee <__mcmp>
8000dd9a:	08 9a       	mov	r10,r4
8000dd9c:	50 6c       	stdsp	sp[0x18],r12
8000dd9e:	04 9b       	mov	r11,r2
8000dda0:	0e 9c       	mov	r12,r7
8000dda2:	e0 a0 06 61 	rcall	8000ea64 <__mdiff>
8000dda6:	18 91       	mov	r1,r12
8000dda8:	78 38       	ld.w	r8,r12[0xc]
8000ddaa:	58 08       	cp.w	r8,0
8000ddac:	c0 30       	breq	8000ddb2 <_dtoa_r+0xa0e>
8000ddae:	30 16       	mov	r6,1
8000ddb0:	c0 68       	rjmp	8000ddbc <_dtoa_r+0xa18>
8000ddb2:	18 9b       	mov	r11,r12
8000ddb4:	06 9c       	mov	r12,r3
8000ddb6:	e0 a0 05 9c 	rcall	8000e8ee <__mcmp>
8000ddba:	18 96       	mov	r6,r12
8000ddbc:	0e 9c       	mov	r12,r7
8000ddbe:	02 9b       	mov	r11,r1
8000ddc0:	e0 a0 05 b0 	rcall	8000e920 <_Bfree>
8000ddc4:	40 cc       	lddsp	r12,sp[0x30]
8000ddc6:	ed ec 10 08 	or	r8,r6,r12
8000ddca:	c0 d1       	brne	8000dde4 <_dtoa_r+0xa40>
8000ddcc:	40 db       	lddsp	r11,sp[0x34]
8000ddce:	58 0b       	cp.w	r11,0
8000ddd0:	c0 a1       	brne	8000dde4 <_dtoa_r+0xa40>
8000ddd2:	40 26       	lddsp	r6,sp[0x8]
8000ddd4:	e0 40 00 39 	cp.w	r0,57
8000ddd8:	c3 00       	breq	8000de38 <_dtoa_r+0xa94>
8000ddda:	40 6a       	lddsp	r10,sp[0x18]
8000dddc:	58 0a       	cp.w	r10,0
8000ddde:	e0 89 00 24 	brgt	8000de26 <_dtoa_r+0xa82>
8000dde2:	c2 f8       	rjmp	8000de40 <_dtoa_r+0xa9c>
8000dde4:	40 69       	lddsp	r9,sp[0x18]
8000dde6:	58 09       	cp.w	r9,0
8000dde8:	c0 85       	brlt	8000ddf8 <_dtoa_r+0xa54>
8000ddea:	12 98       	mov	r8,r9
8000ddec:	40 cc       	lddsp	r12,sp[0x30]
8000ddee:	18 48       	or	r8,r12
8000ddf0:	c1 d1       	brne	8000de2a <_dtoa_r+0xa86>
8000ddf2:	40 db       	lddsp	r11,sp[0x34]
8000ddf4:	58 0b       	cp.w	r11,0
8000ddf6:	c1 a1       	brne	8000de2a <_dtoa_r+0xa86>
8000ddf8:	0c 99       	mov	r9,r6
8000ddfa:	40 26       	lddsp	r6,sp[0x8]
8000ddfc:	58 09       	cp.w	r9,0
8000ddfe:	e0 8a 00 21 	brle	8000de40 <_dtoa_r+0xa9c>
8000de02:	06 9b       	mov	r11,r3
8000de04:	30 1a       	mov	r10,1
8000de06:	0e 9c       	mov	r12,r7
8000de08:	e0 a0 06 96 	rcall	8000eb34 <__lshift>
8000de0c:	04 9b       	mov	r11,r2
8000de0e:	18 93       	mov	r3,r12
8000de10:	e0 a0 05 6f 	rcall	8000e8ee <__mcmp>
8000de14:	e0 89 00 06 	brgt	8000de20 <_dtoa_r+0xa7c>
8000de18:	c1 41       	brne	8000de40 <_dtoa_r+0xa9c>
8000de1a:	ed b0 00 00 	bld	r0,0x0
8000de1e:	c1 11       	brne	8000de40 <_dtoa_r+0xa9c>
8000de20:	e0 40 00 39 	cp.w	r0,57
8000de24:	c0 a0       	breq	8000de38 <_dtoa_r+0xa94>
8000de26:	2f f0       	sub	r0,-1
8000de28:	c0 c8       	rjmp	8000de40 <_dtoa_r+0xa9c>
8000de2a:	58 06       	cp.w	r6,0
8000de2c:	e0 8a 00 0c 	brle	8000de44 <_dtoa_r+0xaa0>
8000de30:	40 26       	lddsp	r6,sp[0x8]
8000de32:	e0 40 00 39 	cp.w	r0,57
8000de36:	c0 41       	brne	8000de3e <_dtoa_r+0xa9a>
8000de38:	33 98       	mov	r8,57
8000de3a:	0a c8       	st.b	r5++,r8
8000de3c:	c6 78       	rjmp	8000df0a <_dtoa_r+0xb66>
8000de3e:	2f f0       	sub	r0,-1
8000de40:	0a c0       	st.b	r5++,r0
8000de42:	c7 58       	rjmp	8000df2c <_dtoa_r+0xb88>
8000de44:	0a c0       	st.b	r5++,r0
8000de46:	40 9a       	lddsp	r10,sp[0x24]
8000de48:	40 e9       	lddsp	r9,sp[0x38]
8000de4a:	12 3a       	cp.w	r10,r9
8000de4c:	c4 30       	breq	8000ded2 <_dtoa_r+0xb2e>
8000de4e:	06 9b       	mov	r11,r3
8000de50:	30 09       	mov	r9,0
8000de52:	30 aa       	mov	r10,10
8000de54:	0e 9c       	mov	r12,r7
8000de56:	e0 a0 07 3b 	rcall	8000eccc <__multadd>
8000de5a:	40 48       	lddsp	r8,sp[0x10]
8000de5c:	18 93       	mov	r3,r12
8000de5e:	08 38       	cp.w	r8,r4
8000de60:	c0 91       	brne	8000de72 <_dtoa_r+0xace>
8000de62:	10 9b       	mov	r11,r8
8000de64:	30 09       	mov	r9,0
8000de66:	30 aa       	mov	r10,10
8000de68:	0e 9c       	mov	r12,r7
8000de6a:	e0 a0 07 31 	rcall	8000eccc <__multadd>
8000de6e:	50 4c       	stdsp	sp[0x10],r12
8000de70:	c0 e8       	rjmp	8000de8c <_dtoa_r+0xae8>
8000de72:	40 4b       	lddsp	r11,sp[0x10]
8000de74:	30 09       	mov	r9,0
8000de76:	30 aa       	mov	r10,10
8000de78:	0e 9c       	mov	r12,r7
8000de7a:	e0 a0 07 29 	rcall	8000eccc <__multadd>
8000de7e:	08 9b       	mov	r11,r4
8000de80:	50 4c       	stdsp	sp[0x10],r12
8000de82:	30 09       	mov	r9,0
8000de84:	30 aa       	mov	r10,10
8000de86:	0e 9c       	mov	r12,r7
8000de88:	e0 a0 07 22 	rcall	8000eccc <__multadd>
8000de8c:	18 94       	mov	r4,r12
8000de8e:	40 9c       	lddsp	r12,sp[0x24]
8000de90:	2f fc       	sub	r12,-1
8000de92:	50 9c       	stdsp	sp[0x24],r12
8000de94:	c7 9b       	rjmp	8000dd86 <_dtoa_r+0x9e2>
8000de96:	30 18       	mov	r8,1
8000de98:	06 90       	mov	r0,r3
8000de9a:	40 85       	lddsp	r5,sp[0x20]
8000de9c:	08 93       	mov	r3,r4
8000de9e:	0c 94       	mov	r4,r6
8000dea0:	10 96       	mov	r6,r8
8000dea2:	04 9b       	mov	r11,r2
8000dea4:	00 9c       	mov	r12,r0
8000dea6:	fe b0 f9 ef 	rcall	8000d284 <quorem>
8000deaa:	2d 0c       	sub	r12,-48
8000deac:	0a cc       	st.b	r5++,r12
8000deae:	02 36       	cp.w	r6,r1
8000deb0:	c0 a4       	brge	8000dec4 <_dtoa_r+0xb20>
8000deb2:	00 9b       	mov	r11,r0
8000deb4:	30 09       	mov	r9,0
8000deb6:	30 aa       	mov	r10,10
8000deb8:	0e 9c       	mov	r12,r7
8000deba:	2f f6       	sub	r6,-1
8000debc:	e0 a0 07 08 	rcall	8000eccc <__multadd>
8000dec0:	18 90       	mov	r0,r12
8000dec2:	cf 0b       	rjmp	8000dea2 <_dtoa_r+0xafe>
8000dec4:	08 96       	mov	r6,r4
8000dec6:	30 0b       	mov	r11,0
8000dec8:	06 94       	mov	r4,r3
8000deca:	50 4b       	stdsp	sp[0x10],r11
8000decc:	00 93       	mov	r3,r0
8000dece:	18 90       	mov	r0,r12
8000ded0:	c0 28       	rjmp	8000ded4 <_dtoa_r+0xb30>
8000ded2:	40 26       	lddsp	r6,sp[0x8]
8000ded4:	06 9b       	mov	r11,r3
8000ded6:	30 1a       	mov	r10,1
8000ded8:	0e 9c       	mov	r12,r7
8000deda:	e0 a0 06 2d 	rcall	8000eb34 <__lshift>
8000dede:	04 9b       	mov	r11,r2
8000dee0:	18 93       	mov	r3,r12
8000dee2:	e0 a0 05 06 	rcall	8000e8ee <__mcmp>
8000dee6:	e0 89 00 12 	brgt	8000df0a <_dtoa_r+0xb66>
8000deea:	c1 b1       	brne	8000df20 <_dtoa_r+0xb7c>
8000deec:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000def0:	c0 d1       	brne	8000df0a <_dtoa_r+0xb66>
8000def2:	c1 78       	rjmp	8000df20 <_dtoa_r+0xb7c>
8000def4:	40 89       	lddsp	r9,sp[0x20]
8000def6:	12 38       	cp.w	r8,r9
8000def8:	c0 30       	breq	8000defe <_dtoa_r+0xb5a>
8000defa:	10 95       	mov	r5,r8
8000defc:	c0 88       	rjmp	8000df0c <_dtoa_r+0xb68>
8000defe:	2f f6       	sub	r6,-1
8000df00:	50 66       	stdsp	sp[0x18],r6
8000df02:	33 18       	mov	r8,49
8000df04:	40 8c       	lddsp	r12,sp[0x20]
8000df06:	b8 88       	st.b	r12[0x0],r8
8000df08:	c1 38       	rjmp	8000df2e <_dtoa_r+0xb8a>
8000df0a:	33 9a       	mov	r10,57
8000df0c:	0a 98       	mov	r8,r5
8000df0e:	11 79       	ld.ub	r9,--r8
8000df10:	f4 09 18 00 	cp.b	r9,r10
8000df14:	cf 00       	breq	8000def4 <_dtoa_r+0xb50>
8000df16:	2f f9       	sub	r9,-1
8000df18:	b0 89       	st.b	r8[0x0],r9
8000df1a:	c0 98       	rjmp	8000df2c <_dtoa_r+0xb88>
8000df1c:	10 95       	mov	r5,r8
8000df1e:	c0 28       	rjmp	8000df22 <_dtoa_r+0xb7e>
8000df20:	33 09       	mov	r9,48
8000df22:	0a 98       	mov	r8,r5
8000df24:	11 7a       	ld.ub	r10,--r8
8000df26:	f2 0a 18 00 	cp.b	r10,r9
8000df2a:	cf 90       	breq	8000df1c <_dtoa_r+0xb78>
8000df2c:	50 66       	stdsp	sp[0x18],r6
8000df2e:	04 9b       	mov	r11,r2
8000df30:	0e 9c       	mov	r12,r7
8000df32:	e0 a0 04 f7 	rcall	8000e920 <_Bfree>
8000df36:	58 04       	cp.w	r4,0
8000df38:	c1 20       	breq	8000df5c <_dtoa_r+0xbb8>
8000df3a:	40 4b       	lddsp	r11,sp[0x10]
8000df3c:	08 3b       	cp.w	r11,r4
8000df3e:	5f 19       	srne	r9
8000df40:	58 0b       	cp.w	r11,0
8000df42:	5f 18       	srne	r8
8000df44:	f3 e8 00 08 	and	r8,r9,r8
8000df48:	c0 40       	breq	8000df50 <_dtoa_r+0xbac>
8000df4a:	0e 9c       	mov	r12,r7
8000df4c:	e0 a0 04 ea 	rcall	8000e920 <_Bfree>
8000df50:	08 9b       	mov	r11,r4
8000df52:	0e 9c       	mov	r12,r7
8000df54:	e0 a0 04 e6 	rcall	8000e920 <_Bfree>
8000df58:	c0 28       	rjmp	8000df5c <_dtoa_r+0xbb8>
8000df5a:	50 66       	stdsp	sp[0x18],r6
8000df5c:	0e 9c       	mov	r12,r7
8000df5e:	06 9b       	mov	r11,r3
8000df60:	e0 a0 04 e0 	rcall	8000e920 <_Bfree>
8000df64:	30 08       	mov	r8,0
8000df66:	aa 88       	st.b	r5[0x0],r8
8000df68:	40 68       	lddsp	r8,sp[0x18]
8000df6a:	41 5a       	lddsp	r10,sp[0x54]
8000df6c:	2f f8       	sub	r8,-1
8000df6e:	41 29       	lddsp	r9,sp[0x48]
8000df70:	95 08       	st.w	r10[0x0],r8
8000df72:	40 8c       	lddsp	r12,sp[0x20]
8000df74:	58 09       	cp.w	r9,0
8000df76:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000df7a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000df7e:	2e 6d       	sub	sp,-104
8000df80:	d8 32       	popm	r0-r7,pc
8000df82:	d7 03       	nop

8000df84 <__errno>:
8000df84:	e0 68 0a 38 	mov	r8,2616
8000df88:	70 0c       	ld.w	r12,r8[0x0]
8000df8a:	2f 4c       	sub	r12,-12
8000df8c:	5e fc       	retal	r12
8000df8e:	d7 03       	nop

8000df90 <_fflush_r>:
8000df90:	d4 21       	pushm	r4-r7,lr
8000df92:	16 97       	mov	r7,r11
8000df94:	18 96       	mov	r6,r12
8000df96:	76 48       	ld.w	r8,r11[0x10]
8000df98:	58 08       	cp.w	r8,0
8000df9a:	c7 c0       	breq	8000e092 <_fflush_r+0x102>
8000df9c:	58 0c       	cp.w	r12,0
8000df9e:	c0 50       	breq	8000dfa8 <_fflush_r+0x18>
8000dfa0:	78 68       	ld.w	r8,r12[0x18]
8000dfa2:	58 08       	cp.w	r8,0
8000dfa4:	c0 21       	brne	8000dfa8 <_fflush_r+0x18>
8000dfa6:	cd 1c       	rcall	8000e148 <__sinit>
8000dfa8:	4b b8       	lddpc	r8,8000e094 <_fflush_r+0x104>
8000dfaa:	10 37       	cp.w	r7,r8
8000dfac:	c0 31       	brne	8000dfb2 <_fflush_r+0x22>
8000dfae:	6c 07       	ld.w	r7,r6[0x0]
8000dfb0:	c0 a8       	rjmp	8000dfc4 <_fflush_r+0x34>
8000dfb2:	4b a8       	lddpc	r8,8000e098 <_fflush_r+0x108>
8000dfb4:	10 37       	cp.w	r7,r8
8000dfb6:	c0 31       	brne	8000dfbc <_fflush_r+0x2c>
8000dfb8:	6c 17       	ld.w	r7,r6[0x4]
8000dfba:	c0 58       	rjmp	8000dfc4 <_fflush_r+0x34>
8000dfbc:	4b 88       	lddpc	r8,8000e09c <_fflush_r+0x10c>
8000dfbe:	10 37       	cp.w	r7,r8
8000dfc0:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000dfc4:	8e 6a       	ld.sh	r10,r7[0xc]
8000dfc6:	14 98       	mov	r8,r10
8000dfc8:	ed ba 00 03 	bld	r10,0x3
8000dfcc:	c4 20       	breq	8000e050 <_fflush_r+0xc0>
8000dfce:	ab ba       	sbr	r10,0xb
8000dfd0:	ae 6a       	st.h	r7[0xc],r10
8000dfd2:	6e 18       	ld.w	r8,r7[0x4]
8000dfd4:	58 08       	cp.w	r8,0
8000dfd6:	e0 89 00 06 	brgt	8000dfe2 <_fflush_r+0x52>
8000dfda:	6f 08       	ld.w	r8,r7[0x40]
8000dfdc:	58 08       	cp.w	r8,0
8000dfde:	e0 8a 00 5a 	brle	8000e092 <_fflush_r+0x102>
8000dfe2:	6e b8       	ld.w	r8,r7[0x2c]
8000dfe4:	58 08       	cp.w	r8,0
8000dfe6:	c5 60       	breq	8000e092 <_fflush_r+0x102>
8000dfe8:	e2 1a 10 00 	andl	r10,0x1000,COH
8000dfec:	c0 30       	breq	8000dff2 <_fflush_r+0x62>
8000dfee:	6f 55       	ld.w	r5,r7[0x54]
8000dff0:	c0 f8       	rjmp	8000e00e <_fflush_r+0x7e>
8000dff2:	30 19       	mov	r9,1
8000dff4:	6e 8b       	ld.w	r11,r7[0x20]
8000dff6:	0c 9c       	mov	r12,r6
8000dff8:	5d 18       	icall	r8
8000dffa:	18 95       	mov	r5,r12
8000dffc:	5b fc       	cp.w	r12,-1
8000dffe:	c0 81       	brne	8000e00e <_fflush_r+0x7e>
8000e000:	6c 38       	ld.w	r8,r6[0xc]
8000e002:	59 d8       	cp.w	r8,29
8000e004:	c4 70       	breq	8000e092 <_fflush_r+0x102>
8000e006:	8e 68       	ld.sh	r8,r7[0xc]
8000e008:	a7 a8       	sbr	r8,0x6
8000e00a:	ae 68       	st.h	r7[0xc],r8
8000e00c:	d8 22       	popm	r4-r7,pc
8000e00e:	8e 68       	ld.sh	r8,r7[0xc]
8000e010:	ed b8 00 02 	bld	r8,0x2
8000e014:	c0 91       	brne	8000e026 <_fflush_r+0x96>
8000e016:	6e 18       	ld.w	r8,r7[0x4]
8000e018:	10 15       	sub	r5,r8
8000e01a:	6e d8       	ld.w	r8,r7[0x34]
8000e01c:	58 08       	cp.w	r8,0
8000e01e:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000e022:	eb d8 e1 15 	subne	r5,r5,r8
8000e026:	6e b8       	ld.w	r8,r7[0x2c]
8000e028:	0c 9c       	mov	r12,r6
8000e02a:	30 09       	mov	r9,0
8000e02c:	0a 9a       	mov	r10,r5
8000e02e:	6e 8b       	ld.w	r11,r7[0x20]
8000e030:	5d 18       	icall	r8
8000e032:	8e 68       	ld.sh	r8,r7[0xc]
8000e034:	0a 3c       	cp.w	r12,r5
8000e036:	c2 61       	brne	8000e082 <_fflush_r+0xf2>
8000e038:	ab d8       	cbr	r8,0xb
8000e03a:	30 0c       	mov	r12,0
8000e03c:	6e 49       	ld.w	r9,r7[0x10]
8000e03e:	ae 68       	st.h	r7[0xc],r8
8000e040:	8f 1c       	st.w	r7[0x4],r12
8000e042:	8f 09       	st.w	r7[0x0],r9
8000e044:	ed b8 00 0c 	bld	r8,0xc
8000e048:	c2 51       	brne	8000e092 <_fflush_r+0x102>
8000e04a:	ef 45 00 54 	st.w	r7[84],r5
8000e04e:	d8 22       	popm	r4-r7,pc
8000e050:	6e 45       	ld.w	r5,r7[0x10]
8000e052:	58 05       	cp.w	r5,0
8000e054:	c1 f0       	breq	8000e092 <_fflush_r+0x102>
8000e056:	6e 04       	ld.w	r4,r7[0x0]
8000e058:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000e05c:	8f 05       	st.w	r7[0x0],r5
8000e05e:	f9 b8 01 00 	movne	r8,0
8000e062:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000e066:	0a 14       	sub	r4,r5
8000e068:	8f 28       	st.w	r7[0x8],r8
8000e06a:	c1 18       	rjmp	8000e08c <_fflush_r+0xfc>
8000e06c:	08 99       	mov	r9,r4
8000e06e:	0a 9a       	mov	r10,r5
8000e070:	6e a8       	ld.w	r8,r7[0x28]
8000e072:	6e 8b       	ld.w	r11,r7[0x20]
8000e074:	0c 9c       	mov	r12,r6
8000e076:	5d 18       	icall	r8
8000e078:	18 14       	sub	r4,r12
8000e07a:	58 0c       	cp.w	r12,0
8000e07c:	e0 89 00 07 	brgt	8000e08a <_fflush_r+0xfa>
8000e080:	8e 68       	ld.sh	r8,r7[0xc]
8000e082:	a7 a8       	sbr	r8,0x6
8000e084:	3f fc       	mov	r12,-1
8000e086:	ae 68       	st.h	r7[0xc],r8
8000e088:	d8 22       	popm	r4-r7,pc
8000e08a:	18 05       	add	r5,r12
8000e08c:	58 04       	cp.w	r4,0
8000e08e:	fe 99 ff ef 	brgt	8000e06c <_fflush_r+0xdc>
8000e092:	d8 2a       	popm	r4-r7,pc,r12=0
8000e094:	80 01       	ld.sh	r1,r0[0x0]
8000e096:	9c 90       	ld.uh	r0,lr[0x2]
8000e098:	80 01       	ld.sh	r1,r0[0x0]
8000e09a:	9c b0       	ld.uh	r0,lr[0x6]
8000e09c:	80 01       	ld.sh	r1,r0[0x0]
8000e09e:	9c d0       	ld.uh	r0,lr[0xa]

8000e0a0 <__sfp_lock_acquire>:
8000e0a0:	5e fc       	retal	r12

8000e0a2 <__sfp_lock_release>:
8000e0a2:	5e fc       	retal	r12

8000e0a4 <_cleanup_r>:
8000e0a4:	d4 01       	pushm	lr
8000e0a6:	fe cb f0 ba 	sub	r11,pc,-3910
8000e0aa:	e0 a0 02 f9 	rcall	8000e69c <_fwalk>
8000e0ae:	d8 02       	popm	pc

8000e0b0 <__sfmoreglue>:
8000e0b0:	d4 21       	pushm	r4-r7,lr
8000e0b2:	16 95       	mov	r5,r11
8000e0b4:	f6 06 10 5c 	mul	r6,r11,92
8000e0b8:	ec cb ff f4 	sub	r11,r6,-12
8000e0bc:	fe b0 e1 d2 	rcall	8000a460 <_malloc_r>
8000e0c0:	18 97       	mov	r7,r12
8000e0c2:	c0 90       	breq	8000e0d4 <__sfmoreglue+0x24>
8000e0c4:	99 15       	st.w	r12[0x4],r5
8000e0c6:	30 0b       	mov	r11,0
8000e0c8:	2f 4c       	sub	r12,-12
8000e0ca:	0c 9a       	mov	r10,r6
8000e0cc:	8f 2c       	st.w	r7[0x8],r12
8000e0ce:	8f 0b       	st.w	r7[0x0],r11
8000e0d0:	fe b0 e4 9b 	rcall	8000aa06 <memset>
8000e0d4:	0e 9c       	mov	r12,r7
8000e0d6:	d8 22       	popm	r4-r7,pc

8000e0d8 <__sfp>:
8000e0d8:	d4 21       	pushm	r4-r7,lr
8000e0da:	49 b8       	lddpc	r8,8000e144 <__sfp+0x6c>
8000e0dc:	18 96       	mov	r6,r12
8000e0de:	70 07       	ld.w	r7,r8[0x0]
8000e0e0:	6e 68       	ld.w	r8,r7[0x18]
8000e0e2:	58 08       	cp.w	r8,0
8000e0e4:	c0 31       	brne	8000e0ea <__sfp+0x12>
8000e0e6:	0e 9c       	mov	r12,r7
8000e0e8:	c3 0c       	rcall	8000e148 <__sinit>
8000e0ea:	ee c7 ff 28 	sub	r7,r7,-216
8000e0ee:	30 05       	mov	r5,0
8000e0f0:	6e 2c       	ld.w	r12,r7[0x8]
8000e0f2:	6e 18       	ld.w	r8,r7[0x4]
8000e0f4:	c0 68       	rjmp	8000e100 <__sfp+0x28>
8000e0f6:	98 69       	ld.sh	r9,r12[0xc]
8000e0f8:	ea 09 19 00 	cp.h	r9,r5
8000e0fc:	c1 10       	breq	8000e11e <__sfp+0x46>
8000e0fe:	2a 4c       	sub	r12,-92
8000e100:	20 18       	sub	r8,1
8000e102:	cf a7       	brpl	8000e0f6 <__sfp+0x1e>
8000e104:	6e 08       	ld.w	r8,r7[0x0]
8000e106:	58 08       	cp.w	r8,0
8000e108:	c0 61       	brne	8000e114 <__sfp+0x3c>
8000e10a:	30 4b       	mov	r11,4
8000e10c:	0c 9c       	mov	r12,r6
8000e10e:	cd 1f       	rcall	8000e0b0 <__sfmoreglue>
8000e110:	8f 0c       	st.w	r7[0x0],r12
8000e112:	c0 30       	breq	8000e118 <__sfp+0x40>
8000e114:	6e 07       	ld.w	r7,r7[0x0]
8000e116:	ce db       	rjmp	8000e0f0 <__sfp+0x18>
8000e118:	30 c8       	mov	r8,12
8000e11a:	8d 38       	st.w	r6[0xc],r8
8000e11c:	d8 22       	popm	r4-r7,pc
8000e11e:	30 08       	mov	r8,0
8000e120:	f9 48 00 4c 	st.w	r12[76],r8
8000e124:	99 08       	st.w	r12[0x0],r8
8000e126:	99 28       	st.w	r12[0x8],r8
8000e128:	99 18       	st.w	r12[0x4],r8
8000e12a:	99 48       	st.w	r12[0x10],r8
8000e12c:	99 58       	st.w	r12[0x14],r8
8000e12e:	99 68       	st.w	r12[0x18],r8
8000e130:	99 d8       	st.w	r12[0x34],r8
8000e132:	99 e8       	st.w	r12[0x38],r8
8000e134:	f9 48 00 48 	st.w	r12[72],r8
8000e138:	3f f8       	mov	r8,-1
8000e13a:	b8 78       	st.h	r12[0xe],r8
8000e13c:	30 18       	mov	r8,1
8000e13e:	b8 68       	st.h	r12[0xc],r8
8000e140:	d8 22       	popm	r4-r7,pc
8000e142:	d7 03       	nop
8000e144:	80 01       	ld.sh	r1,r0[0x0]
8000e146:	9c f4       	ld.uh	r4,lr[0xe]

8000e148 <__sinit>:
8000e148:	d4 21       	pushm	r4-r7,lr
8000e14a:	18 96       	mov	r6,r12
8000e14c:	78 67       	ld.w	r7,r12[0x18]
8000e14e:	58 07       	cp.w	r7,0
8000e150:	c4 91       	brne	8000e1e2 <__sinit+0x9a>
8000e152:	fe c8 00 ae 	sub	r8,pc,174
8000e156:	30 15       	mov	r5,1
8000e158:	99 a8       	st.w	r12[0x28],r8
8000e15a:	f9 47 00 d8 	st.w	r12[216],r7
8000e15e:	f9 47 00 dc 	st.w	r12[220],r7
8000e162:	f9 47 00 e0 	st.w	r12[224],r7
8000e166:	99 65       	st.w	r12[0x18],r5
8000e168:	cb 8f       	rcall	8000e0d8 <__sfp>
8000e16a:	8d 0c       	st.w	r6[0x0],r12
8000e16c:	0c 9c       	mov	r12,r6
8000e16e:	cb 5f       	rcall	8000e0d8 <__sfp>
8000e170:	8d 1c       	st.w	r6[0x4],r12
8000e172:	0c 9c       	mov	r12,r6
8000e174:	cb 2f       	rcall	8000e0d8 <__sfp>
8000e176:	6c 09       	ld.w	r9,r6[0x0]
8000e178:	30 48       	mov	r8,4
8000e17a:	93 07       	st.w	r9[0x0],r7
8000e17c:	b2 68       	st.h	r9[0xc],r8
8000e17e:	93 17       	st.w	r9[0x4],r7
8000e180:	93 27       	st.w	r9[0x8],r7
8000e182:	6c 18       	ld.w	r8,r6[0x4]
8000e184:	b2 77       	st.h	r9[0xe],r7
8000e186:	93 47       	st.w	r9[0x10],r7
8000e188:	93 57       	st.w	r9[0x14],r7
8000e18a:	93 67       	st.w	r9[0x18],r7
8000e18c:	93 89       	st.w	r9[0x20],r9
8000e18e:	91 07       	st.w	r8[0x0],r7
8000e190:	91 17       	st.w	r8[0x4],r7
8000e192:	91 27       	st.w	r8[0x8],r7
8000e194:	fe ce f3 20 	sub	lr,pc,-3296
8000e198:	fe cb f3 50 	sub	r11,pc,-3248
8000e19c:	93 9e       	st.w	r9[0x24],lr
8000e19e:	93 ab       	st.w	r9[0x28],r11
8000e1a0:	fe ca f3 78 	sub	r10,pc,-3208
8000e1a4:	fe c4 f3 84 	sub	r4,pc,-3196
8000e1a8:	93 ba       	st.w	r9[0x2c],r10
8000e1aa:	93 c4       	st.w	r9[0x30],r4
8000e1ac:	30 99       	mov	r9,9
8000e1ae:	b0 69       	st.h	r8[0xc],r9
8000e1b0:	b0 75       	st.h	r8[0xe],r5
8000e1b2:	91 c4       	st.w	r8[0x30],r4
8000e1b4:	91 47       	st.w	r8[0x10],r7
8000e1b6:	91 57       	st.w	r8[0x14],r7
8000e1b8:	91 67       	st.w	r8[0x18],r7
8000e1ba:	91 88       	st.w	r8[0x20],r8
8000e1bc:	91 9e       	st.w	r8[0x24],lr
8000e1be:	91 ab       	st.w	r8[0x28],r11
8000e1c0:	91 ba       	st.w	r8[0x2c],r10
8000e1c2:	8d 2c       	st.w	r6[0x8],r12
8000e1c4:	31 28       	mov	r8,18
8000e1c6:	99 07       	st.w	r12[0x0],r7
8000e1c8:	b8 68       	st.h	r12[0xc],r8
8000e1ca:	99 17       	st.w	r12[0x4],r7
8000e1cc:	99 27       	st.w	r12[0x8],r7
8000e1ce:	30 28       	mov	r8,2
8000e1d0:	b8 78       	st.h	r12[0xe],r8
8000e1d2:	99 c4       	st.w	r12[0x30],r4
8000e1d4:	99 67       	st.w	r12[0x18],r7
8000e1d6:	99 9e       	st.w	r12[0x24],lr
8000e1d8:	99 ab       	st.w	r12[0x28],r11
8000e1da:	99 ba       	st.w	r12[0x2c],r10
8000e1dc:	99 47       	st.w	r12[0x10],r7
8000e1de:	99 57       	st.w	r12[0x14],r7
8000e1e0:	99 8c       	st.w	r12[0x20],r12
8000e1e2:	d8 22       	popm	r4-r7,pc

8000e1e4 <_malloc_trim_r>:
8000e1e4:	d4 21       	pushm	r4-r7,lr
8000e1e6:	16 95       	mov	r5,r11
8000e1e8:	18 97       	mov	r7,r12
8000e1ea:	fe b0 d6 87 	rcall	80008ef8 <__malloc_lock>
8000e1ee:	e0 64 05 38 	mov	r4,1336
8000e1f2:	68 28       	ld.w	r8,r4[0x8]
8000e1f4:	70 16       	ld.w	r6,r8[0x4]
8000e1f6:	e0 16 ff fc 	andl	r6,0xfffc
8000e1fa:	ec c8 ff 91 	sub	r8,r6,-111
8000e1fe:	f0 05 01 05 	sub	r5,r8,r5
8000e202:	e0 15 ff 80 	andl	r5,0xff80
8000e206:	ea c5 00 80 	sub	r5,r5,128
8000e20a:	e0 45 00 7f 	cp.w	r5,127
8000e20e:	e0 8a 00 25 	brle	8000e258 <_malloc_trim_r+0x74>
8000e212:	30 0b       	mov	r11,0
8000e214:	0e 9c       	mov	r12,r7
8000e216:	fe b0 e5 5f 	rcall	8000acd4 <_sbrk_r>
8000e21a:	68 28       	ld.w	r8,r4[0x8]
8000e21c:	0c 08       	add	r8,r6
8000e21e:	10 3c       	cp.w	r12,r8
8000e220:	c1 c1       	brne	8000e258 <_malloc_trim_r+0x74>
8000e222:	ea 0b 11 00 	rsub	r11,r5,0
8000e226:	0e 9c       	mov	r12,r7
8000e228:	fe b0 e5 56 	rcall	8000acd4 <_sbrk_r>
8000e22c:	5b fc       	cp.w	r12,-1
8000e22e:	c1 91       	brne	8000e260 <_malloc_trim_r+0x7c>
8000e230:	30 0b       	mov	r11,0
8000e232:	0e 9c       	mov	r12,r7
8000e234:	fe b0 e5 50 	rcall	8000acd4 <_sbrk_r>
8000e238:	68 28       	ld.w	r8,r4[0x8]
8000e23a:	f8 08 01 09 	sub	r9,r12,r8
8000e23e:	58 f9       	cp.w	r9,15
8000e240:	e0 8a 00 0c 	brle	8000e258 <_malloc_trim_r+0x74>
8000e244:	a1 a9       	sbr	r9,0x0
8000e246:	91 19       	st.w	r8[0x4],r9
8000e248:	e0 68 09 44 	mov	r8,2372
8000e24c:	70 09       	ld.w	r9,r8[0x0]
8000e24e:	e0 68 13 28 	mov	r8,4904
8000e252:	f8 09 01 09 	sub	r9,r12,r9
8000e256:	91 09       	st.w	r8[0x0],r9
8000e258:	0e 9c       	mov	r12,r7
8000e25a:	fe b0 d6 55 	rcall	80008f04 <__malloc_unlock>
8000e25e:	d8 2a       	popm	r4-r7,pc,r12=0
8000e260:	68 28       	ld.w	r8,r4[0x8]
8000e262:	0a 16       	sub	r6,r5
8000e264:	a1 a6       	sbr	r6,0x0
8000e266:	91 16       	st.w	r8[0x4],r6
8000e268:	e0 68 13 28 	mov	r8,4904
8000e26c:	70 09       	ld.w	r9,r8[0x0]
8000e26e:	0a 19       	sub	r9,r5
8000e270:	0e 9c       	mov	r12,r7
8000e272:	91 09       	st.w	r8[0x0],r9
8000e274:	fe b0 d6 48 	rcall	80008f04 <__malloc_unlock>
8000e278:	da 2a       	popm	r4-r7,pc,r12=1
8000e27a:	d7 03       	nop

8000e27c <_free_r>:
8000e27c:	d4 21       	pushm	r4-r7,lr
8000e27e:	16 96       	mov	r6,r11
8000e280:	18 97       	mov	r7,r12
8000e282:	58 0b       	cp.w	r11,0
8000e284:	e0 80 00 c0 	breq	8000e404 <_free_r+0x188>
8000e288:	fe b0 d6 38 	rcall	80008ef8 <__malloc_lock>
8000e28c:	20 86       	sub	r6,8
8000e28e:	e0 6a 05 38 	mov	r10,1336
8000e292:	6c 18       	ld.w	r8,r6[0x4]
8000e294:	74 2e       	ld.w	lr,r10[0x8]
8000e296:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000e29a:	a1 c8       	cbr	r8,0x0
8000e29c:	ec 08 00 09 	add	r9,r6,r8
8000e2a0:	72 1b       	ld.w	r11,r9[0x4]
8000e2a2:	e0 1b ff fc 	andl	r11,0xfffc
8000e2a6:	1c 39       	cp.w	r9,lr
8000e2a8:	c1 e1       	brne	8000e2e4 <_free_r+0x68>
8000e2aa:	f6 08 00 08 	add	r8,r11,r8
8000e2ae:	58 0c       	cp.w	r12,0
8000e2b0:	c0 81       	brne	8000e2c0 <_free_r+0x44>
8000e2b2:	6c 09       	ld.w	r9,r6[0x0]
8000e2b4:	12 16       	sub	r6,r9
8000e2b6:	12 08       	add	r8,r9
8000e2b8:	6c 3b       	ld.w	r11,r6[0xc]
8000e2ba:	6c 29       	ld.w	r9,r6[0x8]
8000e2bc:	97 29       	st.w	r11[0x8],r9
8000e2be:	93 3b       	st.w	r9[0xc],r11
8000e2c0:	10 99       	mov	r9,r8
8000e2c2:	95 26       	st.w	r10[0x8],r6
8000e2c4:	a1 a9       	sbr	r9,0x0
8000e2c6:	8d 19       	st.w	r6[0x4],r9
8000e2c8:	e0 69 09 40 	mov	r9,2368
8000e2cc:	72 09       	ld.w	r9,r9[0x0]
8000e2ce:	12 38       	cp.w	r8,r9
8000e2d0:	c0 63       	brcs	8000e2dc <_free_r+0x60>
8000e2d2:	e0 68 13 24 	mov	r8,4900
8000e2d6:	0e 9c       	mov	r12,r7
8000e2d8:	70 0b       	ld.w	r11,r8[0x0]
8000e2da:	c8 5f       	rcall	8000e1e4 <_malloc_trim_r>
8000e2dc:	0e 9c       	mov	r12,r7
8000e2de:	fe b0 d6 13 	rcall	80008f04 <__malloc_unlock>
8000e2e2:	d8 22       	popm	r4-r7,pc
8000e2e4:	93 1b       	st.w	r9[0x4],r11
8000e2e6:	58 0c       	cp.w	r12,0
8000e2e8:	c0 30       	breq	8000e2ee <_free_r+0x72>
8000e2ea:	30 0c       	mov	r12,0
8000e2ec:	c1 08       	rjmp	8000e30c <_free_r+0x90>
8000e2ee:	6c 0e       	ld.w	lr,r6[0x0]
8000e2f0:	f4 c5 ff f8 	sub	r5,r10,-8
8000e2f4:	1c 16       	sub	r6,lr
8000e2f6:	1c 08       	add	r8,lr
8000e2f8:	6c 2e       	ld.w	lr,r6[0x8]
8000e2fa:	0a 3e       	cp.w	lr,r5
8000e2fc:	f9 bc 00 01 	moveq	r12,1
8000e300:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000e304:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000e308:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000e30c:	f2 0b 00 0e 	add	lr,r9,r11
8000e310:	7c 1e       	ld.w	lr,lr[0x4]
8000e312:	ed be 00 00 	bld	lr,0x0
8000e316:	c1 40       	breq	8000e33e <_free_r+0xc2>
8000e318:	16 08       	add	r8,r11
8000e31a:	58 0c       	cp.w	r12,0
8000e31c:	c0 d1       	brne	8000e336 <_free_r+0xba>
8000e31e:	e0 6e 05 38 	mov	lr,1336
8000e322:	72 2b       	ld.w	r11,r9[0x8]
8000e324:	2f 8e       	sub	lr,-8
8000e326:	1c 3b       	cp.w	r11,lr
8000e328:	c0 71       	brne	8000e336 <_free_r+0xba>
8000e32a:	97 36       	st.w	r11[0xc],r6
8000e32c:	97 26       	st.w	r11[0x8],r6
8000e32e:	8d 2b       	st.w	r6[0x8],r11
8000e330:	8d 3b       	st.w	r6[0xc],r11
8000e332:	30 1c       	mov	r12,1
8000e334:	c0 58       	rjmp	8000e33e <_free_r+0xc2>
8000e336:	72 2b       	ld.w	r11,r9[0x8]
8000e338:	72 39       	ld.w	r9,r9[0xc]
8000e33a:	93 2b       	st.w	r9[0x8],r11
8000e33c:	97 39       	st.w	r11[0xc],r9
8000e33e:	10 99       	mov	r9,r8
8000e340:	ec 08 09 08 	st.w	r6[r8],r8
8000e344:	a1 a9       	sbr	r9,0x0
8000e346:	8d 19       	st.w	r6[0x4],r9
8000e348:	58 0c       	cp.w	r12,0
8000e34a:	c5 a1       	brne	8000e3fe <_free_r+0x182>
8000e34c:	e0 48 01 ff 	cp.w	r8,511
8000e350:	e0 8b 00 13 	brhi	8000e376 <_free_r+0xfa>
8000e354:	a3 98       	lsr	r8,0x3
8000e356:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000e35a:	72 2b       	ld.w	r11,r9[0x8]
8000e35c:	8d 39       	st.w	r6[0xc],r9
8000e35e:	8d 2b       	st.w	r6[0x8],r11
8000e360:	97 36       	st.w	r11[0xc],r6
8000e362:	93 26       	st.w	r9[0x8],r6
8000e364:	a3 48       	asr	r8,0x2
8000e366:	74 19       	ld.w	r9,r10[0x4]
8000e368:	30 1b       	mov	r11,1
8000e36a:	f6 08 09 48 	lsl	r8,r11,r8
8000e36e:	f3 e8 10 08 	or	r8,r9,r8
8000e372:	95 18       	st.w	r10[0x4],r8
8000e374:	c4 58       	rjmp	8000e3fe <_free_r+0x182>
8000e376:	f0 0b 16 09 	lsr	r11,r8,0x9
8000e37a:	58 4b       	cp.w	r11,4
8000e37c:	e0 8b 00 06 	brhi	8000e388 <_free_r+0x10c>
8000e380:	f0 0b 16 06 	lsr	r11,r8,0x6
8000e384:	2c 8b       	sub	r11,-56
8000e386:	c2 08       	rjmp	8000e3c6 <_free_r+0x14a>
8000e388:	59 4b       	cp.w	r11,20
8000e38a:	e0 8b 00 04 	brhi	8000e392 <_free_r+0x116>
8000e38e:	2a 5b       	sub	r11,-91
8000e390:	c1 b8       	rjmp	8000e3c6 <_free_r+0x14a>
8000e392:	e0 4b 00 54 	cp.w	r11,84
8000e396:	e0 8b 00 06 	brhi	8000e3a2 <_free_r+0x126>
8000e39a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000e39e:	29 2b       	sub	r11,-110
8000e3a0:	c1 38       	rjmp	8000e3c6 <_free_r+0x14a>
8000e3a2:	e0 4b 01 54 	cp.w	r11,340
8000e3a6:	e0 8b 00 06 	brhi	8000e3b2 <_free_r+0x136>
8000e3aa:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000e3ae:	28 9b       	sub	r11,-119
8000e3b0:	c0 b8       	rjmp	8000e3c6 <_free_r+0x14a>
8000e3b2:	e0 4b 05 54 	cp.w	r11,1364
8000e3b6:	e0 88 00 05 	brls	8000e3c0 <_free_r+0x144>
8000e3ba:	37 eb       	mov	r11,126
8000e3bc:	c0 58       	rjmp	8000e3c6 <_free_r+0x14a>
8000e3be:	d7 03       	nop
8000e3c0:	f0 0b 16 12 	lsr	r11,r8,0x12
8000e3c4:	28 4b       	sub	r11,-124
8000e3c6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000e3ca:	78 29       	ld.w	r9,r12[0x8]
8000e3cc:	18 39       	cp.w	r9,r12
8000e3ce:	c0 e1       	brne	8000e3ea <_free_r+0x16e>
8000e3d0:	74 18       	ld.w	r8,r10[0x4]
8000e3d2:	a3 4b       	asr	r11,0x2
8000e3d4:	30 1c       	mov	r12,1
8000e3d6:	f8 0b 09 4b 	lsl	r11,r12,r11
8000e3da:	f1 eb 10 0b 	or	r11,r8,r11
8000e3de:	12 98       	mov	r8,r9
8000e3e0:	95 1b       	st.w	r10[0x4],r11
8000e3e2:	c0 a8       	rjmp	8000e3f6 <_free_r+0x17a>
8000e3e4:	72 29       	ld.w	r9,r9[0x8]
8000e3e6:	18 39       	cp.w	r9,r12
8000e3e8:	c0 60       	breq	8000e3f4 <_free_r+0x178>
8000e3ea:	72 1a       	ld.w	r10,r9[0x4]
8000e3ec:	e0 1a ff fc 	andl	r10,0xfffc
8000e3f0:	14 38       	cp.w	r8,r10
8000e3f2:	cf 93       	brcs	8000e3e4 <_free_r+0x168>
8000e3f4:	72 38       	ld.w	r8,r9[0xc]
8000e3f6:	8d 38       	st.w	r6[0xc],r8
8000e3f8:	8d 29       	st.w	r6[0x8],r9
8000e3fa:	93 36       	st.w	r9[0xc],r6
8000e3fc:	91 26       	st.w	r8[0x8],r6
8000e3fe:	0e 9c       	mov	r12,r7
8000e400:	fe b0 d5 82 	rcall	80008f04 <__malloc_unlock>
8000e404:	d8 22       	popm	r4-r7,pc
8000e406:	d7 03       	nop

8000e408 <__sfvwrite_r>:
8000e408:	d4 31       	pushm	r0-r7,lr
8000e40a:	20 3d       	sub	sp,12
8000e40c:	14 94       	mov	r4,r10
8000e40e:	18 95       	mov	r5,r12
8000e410:	16 97       	mov	r7,r11
8000e412:	74 28       	ld.w	r8,r10[0x8]
8000e414:	58 08       	cp.w	r8,0
8000e416:	e0 80 01 40 	breq	8000e696 <__sfvwrite_r+0x28e>
8000e41a:	96 68       	ld.sh	r8,r11[0xc]
8000e41c:	ed b8 00 03 	bld	r8,0x3
8000e420:	c0 41       	brne	8000e428 <__sfvwrite_r+0x20>
8000e422:	76 48       	ld.w	r8,r11[0x10]
8000e424:	58 08       	cp.w	r8,0
8000e426:	c0 c1       	brne	8000e43e <__sfvwrite_r+0x36>
8000e428:	0e 9b       	mov	r11,r7
8000e42a:	0a 9c       	mov	r12,r5
8000e42c:	fe b0 f6 bc 	rcall	8000d1a4 <__swsetup_r>
8000e430:	c0 70       	breq	8000e43e <__sfvwrite_r+0x36>
8000e432:	8e 68       	ld.sh	r8,r7[0xc]
8000e434:	a7 a8       	sbr	r8,0x6
8000e436:	ae 68       	st.h	r7[0xc],r8
8000e438:	30 98       	mov	r8,9
8000e43a:	8b 38       	st.w	r5[0xc],r8
8000e43c:	c2 b9       	rjmp	8000e692 <__sfvwrite_r+0x28a>
8000e43e:	8e 63       	ld.sh	r3,r7[0xc]
8000e440:	68 00       	ld.w	r0,r4[0x0]
8000e442:	06 96       	mov	r6,r3
8000e444:	e2 16 00 02 	andl	r6,0x2,COH
8000e448:	c2 10       	breq	8000e48a <__sfvwrite_r+0x82>
8000e44a:	30 03       	mov	r3,0
8000e44c:	e0 62 04 00 	mov	r2,1024
8000e450:	06 96       	mov	r6,r3
8000e452:	c0 48       	rjmp	8000e45a <__sfvwrite_r+0x52>
8000e454:	60 03       	ld.w	r3,r0[0x0]
8000e456:	60 16       	ld.w	r6,r0[0x4]
8000e458:	2f 80       	sub	r0,-8
8000e45a:	58 06       	cp.w	r6,0
8000e45c:	cf c0       	breq	8000e454 <__sfvwrite_r+0x4c>
8000e45e:	e0 46 04 00 	cp.w	r6,1024
8000e462:	ec 09 17 80 	movls	r9,r6
8000e466:	e4 09 17 b0 	movhi	r9,r2
8000e46a:	06 9a       	mov	r10,r3
8000e46c:	6e a8       	ld.w	r8,r7[0x28]
8000e46e:	6e 8b       	ld.w	r11,r7[0x20]
8000e470:	0a 9c       	mov	r12,r5
8000e472:	5d 18       	icall	r8
8000e474:	18 16       	sub	r6,r12
8000e476:	58 0c       	cp.w	r12,0
8000e478:	e0 8a 01 0a 	brle	8000e68c <__sfvwrite_r+0x284>
8000e47c:	68 28       	ld.w	r8,r4[0x8]
8000e47e:	18 18       	sub	r8,r12
8000e480:	89 28       	st.w	r4[0x8],r8
8000e482:	e0 80 01 0a 	breq	8000e696 <__sfvwrite_r+0x28e>
8000e486:	18 03       	add	r3,r12
8000e488:	ce 9b       	rjmp	8000e45a <__sfvwrite_r+0x52>
8000e48a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000e48e:	c0 70       	breq	8000e49c <__sfvwrite_r+0x94>
8000e490:	50 06       	stdsp	sp[0x0],r6
8000e492:	0c 93       	mov	r3,r6
8000e494:	0c 91       	mov	r1,r6
8000e496:	50 15       	stdsp	sp[0x4],r5
8000e498:	08 92       	mov	r2,r4
8000e49a:	c9 c8       	rjmp	8000e5d2 <__sfvwrite_r+0x1ca>
8000e49c:	06 96       	mov	r6,r3
8000e49e:	08 91       	mov	r1,r4
8000e4a0:	c0 48       	rjmp	8000e4a8 <__sfvwrite_r+0xa0>
8000e4a2:	60 03       	ld.w	r3,r0[0x0]
8000e4a4:	60 16       	ld.w	r6,r0[0x4]
8000e4a6:	2f 80       	sub	r0,-8
8000e4a8:	58 06       	cp.w	r6,0
8000e4aa:	cf c0       	breq	8000e4a2 <__sfvwrite_r+0x9a>
8000e4ac:	8e 68       	ld.sh	r8,r7[0xc]
8000e4ae:	6e 24       	ld.w	r4,r7[0x8]
8000e4b0:	10 99       	mov	r9,r8
8000e4b2:	e2 19 02 00 	andl	r9,0x200,COH
8000e4b6:	c5 50       	breq	8000e560 <__sfvwrite_r+0x158>
8000e4b8:	08 36       	cp.w	r6,r4
8000e4ba:	c4 43       	brcs	8000e542 <__sfvwrite_r+0x13a>
8000e4bc:	10 99       	mov	r9,r8
8000e4be:	e2 19 04 80 	andl	r9,0x480,COH
8000e4c2:	c4 00       	breq	8000e542 <__sfvwrite_r+0x13a>
8000e4c4:	6e 4b       	ld.w	r11,r7[0x10]
8000e4c6:	6e 09       	ld.w	r9,r7[0x0]
8000e4c8:	16 19       	sub	r9,r11
8000e4ca:	50 09       	stdsp	sp[0x0],r9
8000e4cc:	6e 59       	ld.w	r9,r7[0x14]
8000e4ce:	10 9c       	mov	r12,r8
8000e4d0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000e4d4:	30 28       	mov	r8,2
8000e4d6:	f4 08 0c 08 	divs	r8,r10,r8
8000e4da:	fa e9 00 04 	st.d	sp[4],r8
8000e4de:	10 94       	mov	r4,r8
8000e4e0:	40 09       	lddsp	r9,sp[0x0]
8000e4e2:	e2 1c 04 00 	andl	r12,0x400,COH
8000e4e6:	2f f9       	sub	r9,-1
8000e4e8:	0c 09       	add	r9,r6
8000e4ea:	12 38       	cp.w	r8,r9
8000e4ec:	f2 04 17 30 	movlo	r4,r9
8000e4f0:	58 0c       	cp.w	r12,0
8000e4f2:	c1 10       	breq	8000e514 <__sfvwrite_r+0x10c>
8000e4f4:	08 9b       	mov	r11,r4
8000e4f6:	0a 9c       	mov	r12,r5
8000e4f8:	fe b0 df b4 	rcall	8000a460 <_malloc_r>
8000e4fc:	18 92       	mov	r2,r12
8000e4fe:	c1 40       	breq	8000e526 <__sfvwrite_r+0x11e>
8000e500:	40 0a       	lddsp	r10,sp[0x0]
8000e502:	6e 4b       	ld.w	r11,r7[0x10]
8000e504:	fe b0 e1 dd 	rcall	8000a8be <memcpy>
8000e508:	8e 68       	ld.sh	r8,r7[0xc]
8000e50a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000e50e:	a7 b8       	sbr	r8,0x7
8000e510:	ae 68       	st.h	r7[0xc],r8
8000e512:	c0 d8       	rjmp	8000e52c <__sfvwrite_r+0x124>
8000e514:	08 9a       	mov	r10,r4
8000e516:	0a 9c       	mov	r12,r5
8000e518:	fe b0 e2 7e 	rcall	8000aa14 <_realloc_r>
8000e51c:	18 92       	mov	r2,r12
8000e51e:	c0 71       	brne	8000e52c <__sfvwrite_r+0x124>
8000e520:	6e 4b       	ld.w	r11,r7[0x10]
8000e522:	0a 9c       	mov	r12,r5
8000e524:	ca ce       	rcall	8000e27c <_free_r>
8000e526:	30 c8       	mov	r8,12
8000e528:	8b 38       	st.w	r5[0xc],r8
8000e52a:	cb 18       	rjmp	8000e68c <__sfvwrite_r+0x284>
8000e52c:	40 0a       	lddsp	r10,sp[0x0]
8000e52e:	40 09       	lddsp	r9,sp[0x0]
8000e530:	e8 0a 01 0a 	sub	r10,r4,r10
8000e534:	e4 09 00 08 	add	r8,r2,r9
8000e538:	8f 54       	st.w	r7[0x14],r4
8000e53a:	8f 2a       	st.w	r7[0x8],r10
8000e53c:	8f 08       	st.w	r7[0x0],r8
8000e53e:	8f 42       	st.w	r7[0x10],r2
8000e540:	0c 94       	mov	r4,r6
8000e542:	08 36       	cp.w	r6,r4
8000e544:	ec 04 17 30 	movlo	r4,r6
8000e548:	06 9b       	mov	r11,r3
8000e54a:	08 9a       	mov	r10,r4
8000e54c:	6e 0c       	ld.w	r12,r7[0x0]
8000e54e:	c3 ad       	rcall	8000e7c2 <memmove>
8000e550:	6e 08       	ld.w	r8,r7[0x0]
8000e552:	08 08       	add	r8,r4
8000e554:	8f 08       	st.w	r7[0x0],r8
8000e556:	6e 28       	ld.w	r8,r7[0x8]
8000e558:	08 18       	sub	r8,r4
8000e55a:	0c 94       	mov	r4,r6
8000e55c:	8f 28       	st.w	r7[0x8],r8
8000e55e:	c2 e8       	rjmp	8000e5ba <__sfvwrite_r+0x1b2>
8000e560:	08 36       	cp.w	r6,r4
8000e562:	5f ba       	srhi	r10
8000e564:	6e 0c       	ld.w	r12,r7[0x0]
8000e566:	6e 48       	ld.w	r8,r7[0x10]
8000e568:	10 3c       	cp.w	r12,r8
8000e56a:	5f b8       	srhi	r8
8000e56c:	f5 e8 00 08 	and	r8,r10,r8
8000e570:	f2 08 18 00 	cp.b	r8,r9
8000e574:	c0 d0       	breq	8000e58e <__sfvwrite_r+0x186>
8000e576:	06 9b       	mov	r11,r3
8000e578:	08 9a       	mov	r10,r4
8000e57a:	c2 4d       	rcall	8000e7c2 <memmove>
8000e57c:	6e 08       	ld.w	r8,r7[0x0]
8000e57e:	08 08       	add	r8,r4
8000e580:	0e 9b       	mov	r11,r7
8000e582:	8f 08       	st.w	r7[0x0],r8
8000e584:	0a 9c       	mov	r12,r5
8000e586:	fe b0 fd 05 	rcall	8000df90 <_fflush_r>
8000e58a:	c1 80       	breq	8000e5ba <__sfvwrite_r+0x1b2>
8000e58c:	c8 08       	rjmp	8000e68c <__sfvwrite_r+0x284>
8000e58e:	6e 59       	ld.w	r9,r7[0x14]
8000e590:	12 36       	cp.w	r6,r9
8000e592:	c0 a3       	brcs	8000e5a6 <__sfvwrite_r+0x19e>
8000e594:	6e a8       	ld.w	r8,r7[0x28]
8000e596:	06 9a       	mov	r10,r3
8000e598:	6e 8b       	ld.w	r11,r7[0x20]
8000e59a:	0a 9c       	mov	r12,r5
8000e59c:	5d 18       	icall	r8
8000e59e:	18 94       	mov	r4,r12
8000e5a0:	e0 89 00 0d 	brgt	8000e5ba <__sfvwrite_r+0x1b2>
8000e5a4:	c7 48       	rjmp	8000e68c <__sfvwrite_r+0x284>
8000e5a6:	0c 9a       	mov	r10,r6
8000e5a8:	06 9b       	mov	r11,r3
8000e5aa:	c0 cd       	rcall	8000e7c2 <memmove>
8000e5ac:	6e 08       	ld.w	r8,r7[0x0]
8000e5ae:	0c 08       	add	r8,r6
8000e5b0:	0c 94       	mov	r4,r6
8000e5b2:	8f 08       	st.w	r7[0x0],r8
8000e5b4:	6e 28       	ld.w	r8,r7[0x8]
8000e5b6:	0c 18       	sub	r8,r6
8000e5b8:	8f 28       	st.w	r7[0x8],r8
8000e5ba:	62 28       	ld.w	r8,r1[0x8]
8000e5bc:	08 18       	sub	r8,r4
8000e5be:	83 28       	st.w	r1[0x8],r8
8000e5c0:	c6 b0       	breq	8000e696 <__sfvwrite_r+0x28e>
8000e5c2:	08 16       	sub	r6,r4
8000e5c4:	08 03       	add	r3,r4
8000e5c6:	c7 1b       	rjmp	8000e4a8 <__sfvwrite_r+0xa0>
8000e5c8:	60 03       	ld.w	r3,r0[0x0]
8000e5ca:	60 11       	ld.w	r1,r0[0x4]
8000e5cc:	30 08       	mov	r8,0
8000e5ce:	2f 80       	sub	r0,-8
8000e5d0:	50 08       	stdsp	sp[0x0],r8
8000e5d2:	58 01       	cp.w	r1,0
8000e5d4:	cf a0       	breq	8000e5c8 <__sfvwrite_r+0x1c0>
8000e5d6:	40 0a       	lddsp	r10,sp[0x0]
8000e5d8:	58 0a       	cp.w	r10,0
8000e5da:	c1 41       	brne	8000e602 <__sfvwrite_r+0x1fa>
8000e5dc:	e2 c6 ff ff 	sub	r6,r1,-1
8000e5e0:	02 9a       	mov	r10,r1
8000e5e2:	30 ab       	mov	r11,10
8000e5e4:	06 9c       	mov	r12,r3
8000e5e6:	ce 3c       	rcall	8000e7ac <memchr>
8000e5e8:	f8 c8 ff ff 	sub	r8,r12,-1
8000e5ec:	58 0c       	cp.w	r12,0
8000e5ee:	f1 d3 e1 16 	subne	r6,r8,r3
8000e5f2:	f9 b9 01 01 	movne	r9,1
8000e5f6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e5fa:	f9 b8 00 01 	moveq	r8,1
8000e5fe:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000e602:	02 36       	cp.w	r6,r1
8000e604:	ec 04 17 80 	movls	r4,r6
8000e608:	e2 04 17 b0 	movhi	r4,r1
8000e60c:	6e 59       	ld.w	r9,r7[0x14]
8000e60e:	6e 25       	ld.w	r5,r7[0x8]
8000e610:	f2 05 00 05 	add	r5,r9,r5
8000e614:	0a 34       	cp.w	r4,r5
8000e616:	5f 9a       	srgt	r10
8000e618:	6e 0c       	ld.w	r12,r7[0x0]
8000e61a:	6e 48       	ld.w	r8,r7[0x10]
8000e61c:	10 3c       	cp.w	r12,r8
8000e61e:	5f b8       	srhi	r8
8000e620:	f5 e8 00 08 	and	r8,r10,r8
8000e624:	30 0a       	mov	r10,0
8000e626:	f4 08 18 00 	cp.b	r8,r10
8000e62a:	c0 d0       	breq	8000e644 <__sfvwrite_r+0x23c>
8000e62c:	06 9b       	mov	r11,r3
8000e62e:	0a 9a       	mov	r10,r5
8000e630:	cc 9c       	rcall	8000e7c2 <memmove>
8000e632:	6e 08       	ld.w	r8,r7[0x0]
8000e634:	0a 08       	add	r8,r5
8000e636:	0e 9b       	mov	r11,r7
8000e638:	8f 08       	st.w	r7[0x0],r8
8000e63a:	40 1c       	lddsp	r12,sp[0x4]
8000e63c:	fe b0 fc aa 	rcall	8000df90 <_fflush_r>
8000e640:	c1 70       	breq	8000e66e <__sfvwrite_r+0x266>
8000e642:	c2 58       	rjmp	8000e68c <__sfvwrite_r+0x284>
8000e644:	12 34       	cp.w	r4,r9
8000e646:	c0 a5       	brlt	8000e65a <__sfvwrite_r+0x252>
8000e648:	6e a8       	ld.w	r8,r7[0x28]
8000e64a:	06 9a       	mov	r10,r3
8000e64c:	6e 8b       	ld.w	r11,r7[0x20]
8000e64e:	40 1c       	lddsp	r12,sp[0x4]
8000e650:	5d 18       	icall	r8
8000e652:	18 95       	mov	r5,r12
8000e654:	e0 89 00 0d 	brgt	8000e66e <__sfvwrite_r+0x266>
8000e658:	c1 a8       	rjmp	8000e68c <__sfvwrite_r+0x284>
8000e65a:	08 9a       	mov	r10,r4
8000e65c:	06 9b       	mov	r11,r3
8000e65e:	cb 2c       	rcall	8000e7c2 <memmove>
8000e660:	6e 08       	ld.w	r8,r7[0x0]
8000e662:	08 08       	add	r8,r4
8000e664:	08 95       	mov	r5,r4
8000e666:	8f 08       	st.w	r7[0x0],r8
8000e668:	6e 28       	ld.w	r8,r7[0x8]
8000e66a:	08 18       	sub	r8,r4
8000e66c:	8f 28       	st.w	r7[0x8],r8
8000e66e:	0a 16       	sub	r6,r5
8000e670:	c0 71       	brne	8000e67e <__sfvwrite_r+0x276>
8000e672:	0e 9b       	mov	r11,r7
8000e674:	40 1c       	lddsp	r12,sp[0x4]
8000e676:	fe b0 fc 8d 	rcall	8000df90 <_fflush_r>
8000e67a:	c0 91       	brne	8000e68c <__sfvwrite_r+0x284>
8000e67c:	50 06       	stdsp	sp[0x0],r6
8000e67e:	64 28       	ld.w	r8,r2[0x8]
8000e680:	0a 18       	sub	r8,r5
8000e682:	85 28       	st.w	r2[0x8],r8
8000e684:	c0 90       	breq	8000e696 <__sfvwrite_r+0x28e>
8000e686:	0a 11       	sub	r1,r5
8000e688:	0a 03       	add	r3,r5
8000e68a:	ca 4b       	rjmp	8000e5d2 <__sfvwrite_r+0x1ca>
8000e68c:	8e 68       	ld.sh	r8,r7[0xc]
8000e68e:	a7 a8       	sbr	r8,0x6
8000e690:	ae 68       	st.h	r7[0xc],r8
8000e692:	3f fc       	mov	r12,-1
8000e694:	c0 28       	rjmp	8000e698 <__sfvwrite_r+0x290>
8000e696:	30 0c       	mov	r12,0
8000e698:	2f dd       	sub	sp,-12
8000e69a:	d8 32       	popm	r0-r7,pc

8000e69c <_fwalk>:
8000e69c:	d4 31       	pushm	r0-r7,lr
8000e69e:	30 05       	mov	r5,0
8000e6a0:	16 91       	mov	r1,r11
8000e6a2:	f8 c7 ff 28 	sub	r7,r12,-216
8000e6a6:	0a 92       	mov	r2,r5
8000e6a8:	fe b0 fc fc 	rcall	8000e0a0 <__sfp_lock_acquire>
8000e6ac:	3f f3       	mov	r3,-1
8000e6ae:	c1 68       	rjmp	8000e6da <_fwalk+0x3e>
8000e6b0:	6e 26       	ld.w	r6,r7[0x8]
8000e6b2:	6e 14       	ld.w	r4,r7[0x4]
8000e6b4:	2f 46       	sub	r6,-12
8000e6b6:	c0 c8       	rjmp	8000e6ce <_fwalk+0x32>
8000e6b8:	8c 08       	ld.sh	r8,r6[0x0]
8000e6ba:	e4 08 19 00 	cp.h	r8,r2
8000e6be:	c0 70       	breq	8000e6cc <_fwalk+0x30>
8000e6c0:	8c 18       	ld.sh	r8,r6[0x2]
8000e6c2:	e6 08 19 00 	cp.h	r8,r3
8000e6c6:	c0 30       	breq	8000e6cc <_fwalk+0x30>
8000e6c8:	5d 11       	icall	r1
8000e6ca:	18 45       	or	r5,r12
8000e6cc:	2a 46       	sub	r6,-92
8000e6ce:	20 14       	sub	r4,1
8000e6d0:	ec cc 00 0c 	sub	r12,r6,12
8000e6d4:	58 04       	cp.w	r4,0
8000e6d6:	cf 14       	brge	8000e6b8 <_fwalk+0x1c>
8000e6d8:	6e 07       	ld.w	r7,r7[0x0]
8000e6da:	58 07       	cp.w	r7,0
8000e6dc:	ce a1       	brne	8000e6b0 <_fwalk+0x14>
8000e6de:	fe b0 fc e2 	rcall	8000e0a2 <__sfp_lock_release>
8000e6e2:	0a 9c       	mov	r12,r5
8000e6e4:	d8 32       	popm	r0-r7,pc
8000e6e6:	d7 03       	nop

8000e6e8 <_localeconv_r>:
8000e6e8:	48 1c       	lddpc	r12,8000e6ec <_localeconv_r+0x4>
8000e6ea:	5e fc       	retal	r12
8000e6ec:	80 01       	ld.sh	r1,r0[0x0]
8000e6ee:	9c f8       	ld.uh	r8,lr[0xe]

8000e6f0 <__smakebuf_r>:
8000e6f0:	d4 21       	pushm	r4-r7,lr
8000e6f2:	20 fd       	sub	sp,60
8000e6f4:	96 68       	ld.sh	r8,r11[0xc]
8000e6f6:	16 97       	mov	r7,r11
8000e6f8:	18 96       	mov	r6,r12
8000e6fa:	e2 18 00 02 	andl	r8,0x2,COH
8000e6fe:	c3 d1       	brne	8000e778 <__smakebuf_r+0x88>
8000e700:	96 7b       	ld.sh	r11,r11[0xe]
8000e702:	f0 0b 19 00 	cp.h	r11,r8
8000e706:	c0 55       	brlt	8000e710 <__smakebuf_r+0x20>
8000e708:	1a 9a       	mov	r10,sp
8000e70a:	e0 a0 04 79 	rcall	8000effc <_fstat_r>
8000e70e:	c0 f4       	brge	8000e72c <__smakebuf_r+0x3c>
8000e710:	8e 65       	ld.sh	r5,r7[0xc]
8000e712:	0a 98       	mov	r8,r5
8000e714:	ab b8       	sbr	r8,0xb
8000e716:	e2 15 00 80 	andl	r5,0x80,COH
8000e71a:	ae 68       	st.h	r7[0xc],r8
8000e71c:	30 04       	mov	r4,0
8000e71e:	e0 68 04 00 	mov	r8,1024
8000e722:	f9 b5 01 40 	movne	r5,64
8000e726:	f0 05 17 00 	moveq	r5,r8
8000e72a:	c1 c8       	rjmp	8000e762 <__smakebuf_r+0x72>
8000e72c:	40 18       	lddsp	r8,sp[0x4]
8000e72e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000e732:	e0 48 20 00 	cp.w	r8,8192
8000e736:	5f 04       	sreq	r4
8000e738:	e0 48 80 00 	cp.w	r8,32768
8000e73c:	c0 e1       	brne	8000e758 <__smakebuf_r+0x68>
8000e73e:	6e b9       	ld.w	r9,r7[0x2c]
8000e740:	fe c8 f9 18 	sub	r8,pc,-1768
8000e744:	10 39       	cp.w	r9,r8
8000e746:	c0 91       	brne	8000e758 <__smakebuf_r+0x68>
8000e748:	8e 68       	ld.sh	r8,r7[0xc]
8000e74a:	e0 65 04 00 	mov	r5,1024
8000e74e:	ab a8       	sbr	r8,0xa
8000e750:	ef 45 00 50 	st.w	r7[80],r5
8000e754:	ae 68       	st.h	r7[0xc],r8
8000e756:	c0 68       	rjmp	8000e762 <__smakebuf_r+0x72>
8000e758:	8e 68       	ld.sh	r8,r7[0xc]
8000e75a:	e0 65 04 00 	mov	r5,1024
8000e75e:	ab b8       	sbr	r8,0xb
8000e760:	ae 68       	st.h	r7[0xc],r8
8000e762:	0a 9b       	mov	r11,r5
8000e764:	0c 9c       	mov	r12,r6
8000e766:	fe b0 de 7d 	rcall	8000a460 <_malloc_r>
8000e76a:	8e 68       	ld.sh	r8,r7[0xc]
8000e76c:	c0 d1       	brne	8000e786 <__smakebuf_r+0x96>
8000e76e:	ed b8 00 09 	bld	r8,0x9
8000e772:	c1 b0       	breq	8000e7a8 <__smakebuf_r+0xb8>
8000e774:	a1 b8       	sbr	r8,0x1
8000e776:	ae 68       	st.h	r7[0xc],r8
8000e778:	ee c8 ff b9 	sub	r8,r7,-71
8000e77c:	8f 48       	st.w	r7[0x10],r8
8000e77e:	8f 08       	st.w	r7[0x0],r8
8000e780:	30 18       	mov	r8,1
8000e782:	8f 58       	st.w	r7[0x14],r8
8000e784:	c1 28       	rjmp	8000e7a8 <__smakebuf_r+0xb8>
8000e786:	a7 b8       	sbr	r8,0x7
8000e788:	8f 4c       	st.w	r7[0x10],r12
8000e78a:	ae 68       	st.h	r7[0xc],r8
8000e78c:	8f 55       	st.w	r7[0x14],r5
8000e78e:	fe c8 06 ea 	sub	r8,pc,1770
8000e792:	8f 0c       	st.w	r7[0x0],r12
8000e794:	8d a8       	st.w	r6[0x28],r8
8000e796:	58 04       	cp.w	r4,0
8000e798:	c0 80       	breq	8000e7a8 <__smakebuf_r+0xb8>
8000e79a:	8e 7c       	ld.sh	r12,r7[0xe]
8000e79c:	fe b0 e3 7a 	rcall	8000ae90 <isatty>
8000e7a0:	c0 40       	breq	8000e7a8 <__smakebuf_r+0xb8>
8000e7a2:	8e 68       	ld.sh	r8,r7[0xc]
8000e7a4:	a1 a8       	sbr	r8,0x0
8000e7a6:	ae 68       	st.h	r7[0xc],r8
8000e7a8:	2f 1d       	sub	sp,-60
8000e7aa:	d8 22       	popm	r4-r7,pc

8000e7ac <memchr>:
8000e7ac:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000e7b0:	c0 68       	rjmp	8000e7bc <memchr+0x10>
8000e7b2:	20 1a       	sub	r10,1
8000e7b4:	19 88       	ld.ub	r8,r12[0x0]
8000e7b6:	16 38       	cp.w	r8,r11
8000e7b8:	5e 0c       	reteq	r12
8000e7ba:	2f fc       	sub	r12,-1
8000e7bc:	58 0a       	cp.w	r10,0
8000e7be:	cf a1       	brne	8000e7b2 <memchr+0x6>
8000e7c0:	5e fa       	retal	r10

8000e7c2 <memmove>:
8000e7c2:	d4 01       	pushm	lr
8000e7c4:	18 3b       	cp.w	r11,r12
8000e7c6:	c1 92       	brcc	8000e7f8 <memmove+0x36>
8000e7c8:	f6 0a 00 09 	add	r9,r11,r10
8000e7cc:	12 3c       	cp.w	r12,r9
8000e7ce:	c1 52       	brcc	8000e7f8 <memmove+0x36>
8000e7d0:	f8 0a 00 0b 	add	r11,r12,r10
8000e7d4:	30 08       	mov	r8,0
8000e7d6:	c0 68       	rjmp	8000e7e2 <memmove+0x20>
8000e7d8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000e7dc:	20 1a       	sub	r10,1
8000e7de:	f6 08 0b 0e 	st.b	r11[r8],lr
8000e7e2:	20 18       	sub	r8,1
8000e7e4:	58 0a       	cp.w	r10,0
8000e7e6:	cf 91       	brne	8000e7d8 <memmove+0x16>
8000e7e8:	d8 02       	popm	pc
8000e7ea:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000e7ee:	20 1a       	sub	r10,1
8000e7f0:	f8 08 0b 09 	st.b	r12[r8],r9
8000e7f4:	2f f8       	sub	r8,-1
8000e7f6:	c0 28       	rjmp	8000e7fa <memmove+0x38>
8000e7f8:	30 08       	mov	r8,0
8000e7fa:	58 0a       	cp.w	r10,0
8000e7fc:	cf 71       	brne	8000e7ea <memmove+0x28>
8000e7fe:	d8 02       	popm	pc

8000e800 <__hi0bits>:
8000e800:	18 98       	mov	r8,r12
8000e802:	e0 1c 00 00 	andl	r12,0x0
8000e806:	f0 09 15 10 	lsl	r9,r8,0x10
8000e80a:	58 0c       	cp.w	r12,0
8000e80c:	f2 08 17 00 	moveq	r8,r9
8000e810:	f9 bc 00 10 	moveq	r12,16
8000e814:	f9 bc 01 00 	movne	r12,0
8000e818:	10 9a       	mov	r10,r8
8000e81a:	f0 09 15 08 	lsl	r9,r8,0x8
8000e81e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000e822:	f7 bc 00 f8 	subeq	r12,-8
8000e826:	f2 08 17 00 	moveq	r8,r9
8000e82a:	10 9a       	mov	r10,r8
8000e82c:	f0 09 15 04 	lsl	r9,r8,0x4
8000e830:	e6 1a f0 00 	andh	r10,0xf000,COH
8000e834:	f7 bc 00 fc 	subeq	r12,-4
8000e838:	f2 08 17 00 	moveq	r8,r9
8000e83c:	10 9a       	mov	r10,r8
8000e83e:	f0 09 15 02 	lsl	r9,r8,0x2
8000e842:	e6 1a c0 00 	andh	r10,0xc000,COH
8000e846:	f7 bc 00 fe 	subeq	r12,-2
8000e84a:	f2 08 17 00 	moveq	r8,r9
8000e84e:	58 08       	cp.w	r8,0
8000e850:	5e 5c       	retlt	r12
8000e852:	ed b8 00 1e 	bld	r8,0x1e
8000e856:	f9 bc 01 20 	movne	r12,32
8000e85a:	f7 bc 00 ff 	subeq	r12,-1
8000e85e:	5e fc       	retal	r12

8000e860 <__lo0bits>:
8000e860:	18 99       	mov	r9,r12
8000e862:	78 08       	ld.w	r8,r12[0x0]
8000e864:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000e868:	c1 50       	breq	8000e892 <__lo0bits+0x32>
8000e86a:	ed b8 00 00 	bld	r8,0x0
8000e86e:	c0 21       	brne	8000e872 <__lo0bits+0x12>
8000e870:	5e fd       	retal	0
8000e872:	10 9b       	mov	r11,r8
8000e874:	f0 0a 16 01 	lsr	r10,r8,0x1
8000e878:	e2 1b 00 02 	andl	r11,0x2,COH
8000e87c:	a3 88       	lsr	r8,0x2
8000e87e:	58 0b       	cp.w	r11,0
8000e880:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000e884:	f9 bc 01 01 	movne	r12,1
8000e888:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000e88c:	f9 bc 00 02 	moveq	r12,2
8000e890:	5e fc       	retal	r12
8000e892:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000e896:	f0 0b 16 10 	lsr	r11,r8,0x10
8000e89a:	58 0a       	cp.w	r10,0
8000e89c:	f6 08 17 00 	moveq	r8,r11
8000e8a0:	f9 bc 00 10 	moveq	r12,16
8000e8a4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000e8a8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000e8ac:	58 0b       	cp.w	r11,0
8000e8ae:	f7 bc 00 f8 	subeq	r12,-8
8000e8b2:	f4 08 17 00 	moveq	r8,r10
8000e8b6:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000e8ba:	f0 0a 16 04 	lsr	r10,r8,0x4
8000e8be:	58 0b       	cp.w	r11,0
8000e8c0:	f7 bc 00 fc 	subeq	r12,-4
8000e8c4:	f4 08 17 00 	moveq	r8,r10
8000e8c8:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000e8cc:	f0 0a 16 02 	lsr	r10,r8,0x2
8000e8d0:	58 0b       	cp.w	r11,0
8000e8d2:	f7 bc 00 fe 	subeq	r12,-2
8000e8d6:	f4 08 17 00 	moveq	r8,r10
8000e8da:	ed b8 00 00 	bld	r8,0x0
8000e8de:	c0 60       	breq	8000e8ea <__lo0bits+0x8a>
8000e8e0:	a1 98       	lsr	r8,0x1
8000e8e2:	c0 31       	brne	8000e8e8 <__lo0bits+0x88>
8000e8e4:	32 0c       	mov	r12,32
8000e8e6:	5e fc       	retal	r12
8000e8e8:	2f fc       	sub	r12,-1
8000e8ea:	93 08       	st.w	r9[0x0],r8
8000e8ec:	5e fc       	retal	r12

8000e8ee <__mcmp>:
8000e8ee:	d4 01       	pushm	lr
8000e8f0:	18 98       	mov	r8,r12
8000e8f2:	76 49       	ld.w	r9,r11[0x10]
8000e8f4:	78 4c       	ld.w	r12,r12[0x10]
8000e8f6:	12 1c       	sub	r12,r9
8000e8f8:	c1 31       	brne	8000e91e <__mcmp+0x30>
8000e8fa:	2f b9       	sub	r9,-5
8000e8fc:	a3 69       	lsl	r9,0x2
8000e8fe:	12 0b       	add	r11,r9
8000e900:	f0 09 00 09 	add	r9,r8,r9
8000e904:	2e c8       	sub	r8,-20
8000e906:	13 4e       	ld.w	lr,--r9
8000e908:	17 4a       	ld.w	r10,--r11
8000e90a:	14 3e       	cp.w	lr,r10
8000e90c:	c0 60       	breq	8000e918 <__mcmp+0x2a>
8000e90e:	f9 bc 03 ff 	movlo	r12,-1
8000e912:	f9 bc 02 01 	movhs	r12,1
8000e916:	d8 02       	popm	pc
8000e918:	10 39       	cp.w	r9,r8
8000e91a:	fe 9b ff f6 	brhi	8000e906 <__mcmp+0x18>
8000e91e:	d8 02       	popm	pc

8000e920 <_Bfree>:
8000e920:	d4 21       	pushm	r4-r7,lr
8000e922:	18 97       	mov	r7,r12
8000e924:	16 95       	mov	r5,r11
8000e926:	78 96       	ld.w	r6,r12[0x24]
8000e928:	58 06       	cp.w	r6,0
8000e92a:	c0 91       	brne	8000e93c <_Bfree+0x1c>
8000e92c:	31 0c       	mov	r12,16
8000e92e:	fe b0 dd 91 	rcall	8000a450 <malloc>
8000e932:	99 36       	st.w	r12[0xc],r6
8000e934:	8f 9c       	st.w	r7[0x24],r12
8000e936:	99 16       	st.w	r12[0x4],r6
8000e938:	99 26       	st.w	r12[0x8],r6
8000e93a:	99 06       	st.w	r12[0x0],r6
8000e93c:	58 05       	cp.w	r5,0
8000e93e:	c0 90       	breq	8000e950 <_Bfree+0x30>
8000e940:	6a 19       	ld.w	r9,r5[0x4]
8000e942:	6e 98       	ld.w	r8,r7[0x24]
8000e944:	70 38       	ld.w	r8,r8[0xc]
8000e946:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000e94a:	8b 0a       	st.w	r5[0x0],r10
8000e94c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000e950:	d8 22       	popm	r4-r7,pc
8000e952:	d7 03       	nop

8000e954 <_Balloc>:
8000e954:	d4 21       	pushm	r4-r7,lr
8000e956:	18 97       	mov	r7,r12
8000e958:	16 96       	mov	r6,r11
8000e95a:	78 95       	ld.w	r5,r12[0x24]
8000e95c:	58 05       	cp.w	r5,0
8000e95e:	c0 91       	brne	8000e970 <_Balloc+0x1c>
8000e960:	31 0c       	mov	r12,16
8000e962:	fe b0 dd 77 	rcall	8000a450 <malloc>
8000e966:	99 35       	st.w	r12[0xc],r5
8000e968:	8f 9c       	st.w	r7[0x24],r12
8000e96a:	99 15       	st.w	r12[0x4],r5
8000e96c:	99 25       	st.w	r12[0x8],r5
8000e96e:	99 05       	st.w	r12[0x0],r5
8000e970:	6e 95       	ld.w	r5,r7[0x24]
8000e972:	6a 38       	ld.w	r8,r5[0xc]
8000e974:	58 08       	cp.w	r8,0
8000e976:	c0 b1       	brne	8000e98c <_Balloc+0x38>
8000e978:	31 0a       	mov	r10,16
8000e97a:	30 4b       	mov	r11,4
8000e97c:	0e 9c       	mov	r12,r7
8000e97e:	e0 a0 02 9d 	rcall	8000eeb8 <_calloc_r>
8000e982:	8b 3c       	st.w	r5[0xc],r12
8000e984:	6e 98       	ld.w	r8,r7[0x24]
8000e986:	70 3c       	ld.w	r12,r8[0xc]
8000e988:	58 0c       	cp.w	r12,0
8000e98a:	c1 b0       	breq	8000e9c0 <_Balloc+0x6c>
8000e98c:	6e 98       	ld.w	r8,r7[0x24]
8000e98e:	70 38       	ld.w	r8,r8[0xc]
8000e990:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000e994:	70 0c       	ld.w	r12,r8[0x0]
8000e996:	58 0c       	cp.w	r12,0
8000e998:	c0 40       	breq	8000e9a0 <_Balloc+0x4c>
8000e99a:	78 09       	ld.w	r9,r12[0x0]
8000e99c:	91 09       	st.w	r8[0x0],r9
8000e99e:	c0 e8       	rjmp	8000e9ba <_Balloc+0x66>
8000e9a0:	0e 9c       	mov	r12,r7
8000e9a2:	30 17       	mov	r7,1
8000e9a4:	0e 9b       	mov	r11,r7
8000e9a6:	ee 06 09 47 	lsl	r7,r7,r6
8000e9aa:	ee ca ff fb 	sub	r10,r7,-5
8000e9ae:	a3 6a       	lsl	r10,0x2
8000e9b0:	e0 a0 02 84 	rcall	8000eeb8 <_calloc_r>
8000e9b4:	c0 60       	breq	8000e9c0 <_Balloc+0x6c>
8000e9b6:	99 16       	st.w	r12[0x4],r6
8000e9b8:	99 27       	st.w	r12[0x8],r7
8000e9ba:	30 08       	mov	r8,0
8000e9bc:	99 38       	st.w	r12[0xc],r8
8000e9be:	99 48       	st.w	r12[0x10],r8
8000e9c0:	d8 22       	popm	r4-r7,pc
8000e9c2:	d7 03       	nop

8000e9c4 <__d2b>:
8000e9c4:	d4 31       	pushm	r0-r7,lr
8000e9c6:	20 2d       	sub	sp,8
8000e9c8:	16 93       	mov	r3,r11
8000e9ca:	12 96       	mov	r6,r9
8000e9cc:	10 95       	mov	r5,r8
8000e9ce:	14 92       	mov	r2,r10
8000e9d0:	30 1b       	mov	r11,1
8000e9d2:	cc 1f       	rcall	8000e954 <_Balloc>
8000e9d4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000e9d8:	50 09       	stdsp	sp[0x0],r9
8000e9da:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000e9de:	b5 a9       	sbr	r9,0x14
8000e9e0:	f0 01 16 14 	lsr	r1,r8,0x14
8000e9e4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000e9e8:	18 94       	mov	r4,r12
8000e9ea:	58 02       	cp.w	r2,0
8000e9ec:	c1 d0       	breq	8000ea26 <__d2b+0x62>
8000e9ee:	fa cc ff f8 	sub	r12,sp,-8
8000e9f2:	18 d2       	st.w	--r12,r2
8000e9f4:	c3 6f       	rcall	8000e860 <__lo0bits>
8000e9f6:	40 18       	lddsp	r8,sp[0x4]
8000e9f8:	c0 d0       	breq	8000ea12 <__d2b+0x4e>
8000e9fa:	40 09       	lddsp	r9,sp[0x0]
8000e9fc:	f8 0a 11 20 	rsub	r10,r12,32
8000ea00:	f2 0a 09 4a 	lsl	r10,r9,r10
8000ea04:	f5 e8 10 08 	or	r8,r10,r8
8000ea08:	89 58       	st.w	r4[0x14],r8
8000ea0a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000ea0e:	50 09       	stdsp	sp[0x0],r9
8000ea10:	c0 28       	rjmp	8000ea14 <__d2b+0x50>
8000ea12:	89 58       	st.w	r4[0x14],r8
8000ea14:	40 08       	lddsp	r8,sp[0x0]
8000ea16:	58 08       	cp.w	r8,0
8000ea18:	f9 b3 01 02 	movne	r3,2
8000ea1c:	f9 b3 00 01 	moveq	r3,1
8000ea20:	89 68       	st.w	r4[0x18],r8
8000ea22:	89 43       	st.w	r4[0x10],r3
8000ea24:	c0 88       	rjmp	8000ea34 <__d2b+0x70>
8000ea26:	1a 9c       	mov	r12,sp
8000ea28:	c1 cf       	rcall	8000e860 <__lo0bits>
8000ea2a:	30 13       	mov	r3,1
8000ea2c:	40 08       	lddsp	r8,sp[0x0]
8000ea2e:	2e 0c       	sub	r12,-32
8000ea30:	89 43       	st.w	r4[0x10],r3
8000ea32:	89 58       	st.w	r4[0x14],r8
8000ea34:	58 01       	cp.w	r1,0
8000ea36:	c0 90       	breq	8000ea48 <__d2b+0x84>
8000ea38:	e2 c1 04 33 	sub	r1,r1,1075
8000ea3c:	18 01       	add	r1,r12
8000ea3e:	8d 01       	st.w	r6[0x0],r1
8000ea40:	f8 0c 11 35 	rsub	r12,r12,53
8000ea44:	8b 0c       	st.w	r5[0x0],r12
8000ea46:	c0 c8       	rjmp	8000ea5e <__d2b+0x9a>
8000ea48:	e6 c8 ff fc 	sub	r8,r3,-4
8000ea4c:	f8 cc 04 32 	sub	r12,r12,1074
8000ea50:	a5 73       	lsl	r3,0x5
8000ea52:	8d 0c       	st.w	r6[0x0],r12
8000ea54:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000ea58:	cd 4e       	rcall	8000e800 <__hi0bits>
8000ea5a:	18 13       	sub	r3,r12
8000ea5c:	8b 03       	st.w	r5[0x0],r3
8000ea5e:	08 9c       	mov	r12,r4
8000ea60:	2f ed       	sub	sp,-8
8000ea62:	d8 32       	popm	r0-r7,pc

8000ea64 <__mdiff>:
8000ea64:	d4 31       	pushm	r0-r7,lr
8000ea66:	74 48       	ld.w	r8,r10[0x10]
8000ea68:	76 45       	ld.w	r5,r11[0x10]
8000ea6a:	16 97       	mov	r7,r11
8000ea6c:	14 96       	mov	r6,r10
8000ea6e:	10 15       	sub	r5,r8
8000ea70:	c1 31       	brne	8000ea96 <__mdiff+0x32>
8000ea72:	2f b8       	sub	r8,-5
8000ea74:	ee ce ff ec 	sub	lr,r7,-20
8000ea78:	a3 68       	lsl	r8,0x2
8000ea7a:	f4 08 00 0b 	add	r11,r10,r8
8000ea7e:	ee 08 00 08 	add	r8,r7,r8
8000ea82:	11 4a       	ld.w	r10,--r8
8000ea84:	17 49       	ld.w	r9,--r11
8000ea86:	12 3a       	cp.w	r10,r9
8000ea88:	c0 30       	breq	8000ea8e <__mdiff+0x2a>
8000ea8a:	c0 e2       	brcc	8000eaa6 <__mdiff+0x42>
8000ea8c:	c0 78       	rjmp	8000ea9a <__mdiff+0x36>
8000ea8e:	1c 38       	cp.w	r8,lr
8000ea90:	fe 9b ff f9 	brhi	8000ea82 <__mdiff+0x1e>
8000ea94:	c4 98       	rjmp	8000eb26 <__mdiff+0xc2>
8000ea96:	58 05       	cp.w	r5,0
8000ea98:	c0 64       	brge	8000eaa4 <__mdiff+0x40>
8000ea9a:	0e 98       	mov	r8,r7
8000ea9c:	30 15       	mov	r5,1
8000ea9e:	0c 97       	mov	r7,r6
8000eaa0:	10 96       	mov	r6,r8
8000eaa2:	c0 28       	rjmp	8000eaa6 <__mdiff+0x42>
8000eaa4:	30 05       	mov	r5,0
8000eaa6:	6e 1b       	ld.w	r11,r7[0x4]
8000eaa8:	c5 6f       	rcall	8000e954 <_Balloc>
8000eaaa:	6e 49       	ld.w	r9,r7[0x10]
8000eaac:	6c 44       	ld.w	r4,r6[0x10]
8000eaae:	99 35       	st.w	r12[0xc],r5
8000eab0:	2f b4       	sub	r4,-5
8000eab2:	f2 c5 ff fb 	sub	r5,r9,-5
8000eab6:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000eaba:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000eabe:	2e c6       	sub	r6,-20
8000eac0:	2e c7       	sub	r7,-20
8000eac2:	f8 c8 ff ec 	sub	r8,r12,-20
8000eac6:	30 0a       	mov	r10,0
8000eac8:	0f 0e       	ld.w	lr,r7++
8000eaca:	0d 0b       	ld.w	r11,r6++
8000eacc:	fc 02 16 10 	lsr	r2,lr,0x10
8000ead0:	f6 03 16 10 	lsr	r3,r11,0x10
8000ead4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ead8:	e4 03 01 03 	sub	r3,r2,r3
8000eadc:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000eae0:	fc 0b 01 0b 	sub	r11,lr,r11
8000eae4:	f6 0a 00 0a 	add	r10,r11,r10
8000eae8:	b0 1a       	st.h	r8[0x2],r10
8000eaea:	b1 4a       	asr	r10,0x10
8000eaec:	e6 0a 00 0a 	add	r10,r3,r10
8000eaf0:	b0 0a       	st.h	r8[0x0],r10
8000eaf2:	2f c8       	sub	r8,-4
8000eaf4:	b1 4a       	asr	r10,0x10
8000eaf6:	08 36       	cp.w	r6,r4
8000eaf8:	ce 83       	brcs	8000eac8 <__mdiff+0x64>
8000eafa:	c0 d8       	rjmp	8000eb14 <__mdiff+0xb0>
8000eafc:	0f 0b       	ld.w	r11,r7++
8000eafe:	f6 0e 16 10 	lsr	lr,r11,0x10
8000eb02:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000eb06:	16 0a       	add	r10,r11
8000eb08:	b0 1a       	st.h	r8[0x2],r10
8000eb0a:	b1 4a       	asr	r10,0x10
8000eb0c:	1c 0a       	add	r10,lr
8000eb0e:	b0 0a       	st.h	r8[0x0],r10
8000eb10:	2f c8       	sub	r8,-4
8000eb12:	b1 4a       	asr	r10,0x10
8000eb14:	0a 37       	cp.w	r7,r5
8000eb16:	cf 33       	brcs	8000eafc <__mdiff+0x98>
8000eb18:	c0 28       	rjmp	8000eb1c <__mdiff+0xb8>
8000eb1a:	20 19       	sub	r9,1
8000eb1c:	11 4a       	ld.w	r10,--r8
8000eb1e:	58 0a       	cp.w	r10,0
8000eb20:	cf d0       	breq	8000eb1a <__mdiff+0xb6>
8000eb22:	99 49       	st.w	r12[0x10],r9
8000eb24:	d8 32       	popm	r0-r7,pc
8000eb26:	30 0b       	mov	r11,0
8000eb28:	c1 6f       	rcall	8000e954 <_Balloc>
8000eb2a:	30 18       	mov	r8,1
8000eb2c:	99 48       	st.w	r12[0x10],r8
8000eb2e:	30 08       	mov	r8,0
8000eb30:	99 58       	st.w	r12[0x14],r8
8000eb32:	d8 32       	popm	r0-r7,pc

8000eb34 <__lshift>:
8000eb34:	d4 31       	pushm	r0-r7,lr
8000eb36:	16 97       	mov	r7,r11
8000eb38:	76 46       	ld.w	r6,r11[0x10]
8000eb3a:	f4 02 14 05 	asr	r2,r10,0x5
8000eb3e:	2f f6       	sub	r6,-1
8000eb40:	14 93       	mov	r3,r10
8000eb42:	18 94       	mov	r4,r12
8000eb44:	04 06       	add	r6,r2
8000eb46:	76 1b       	ld.w	r11,r11[0x4]
8000eb48:	6e 28       	ld.w	r8,r7[0x8]
8000eb4a:	c0 38       	rjmp	8000eb50 <__lshift+0x1c>
8000eb4c:	2f fb       	sub	r11,-1
8000eb4e:	a1 78       	lsl	r8,0x1
8000eb50:	10 36       	cp.w	r6,r8
8000eb52:	fe 99 ff fd 	brgt	8000eb4c <__lshift+0x18>
8000eb56:	08 9c       	mov	r12,r4
8000eb58:	cf ee       	rcall	8000e954 <_Balloc>
8000eb5a:	30 09       	mov	r9,0
8000eb5c:	18 95       	mov	r5,r12
8000eb5e:	f8 c8 ff ec 	sub	r8,r12,-20
8000eb62:	12 9a       	mov	r10,r9
8000eb64:	c0 38       	rjmp	8000eb6a <__lshift+0x36>
8000eb66:	10 aa       	st.w	r8++,r10
8000eb68:	2f f9       	sub	r9,-1
8000eb6a:	04 39       	cp.w	r9,r2
8000eb6c:	cf d5       	brlt	8000eb66 <__lshift+0x32>
8000eb6e:	6e 4b       	ld.w	r11,r7[0x10]
8000eb70:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000eb74:	2f bb       	sub	r11,-5
8000eb76:	ee c9 ff ec 	sub	r9,r7,-20
8000eb7a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000eb7e:	58 03       	cp.w	r3,0
8000eb80:	c1 30       	breq	8000eba6 <__lshift+0x72>
8000eb82:	e6 0c 11 20 	rsub	r12,r3,32
8000eb86:	30 0a       	mov	r10,0
8000eb88:	72 02       	ld.w	r2,r9[0x0]
8000eb8a:	e4 03 09 42 	lsl	r2,r2,r3
8000eb8e:	04 4a       	or	r10,r2
8000eb90:	10 aa       	st.w	r8++,r10
8000eb92:	13 0a       	ld.w	r10,r9++
8000eb94:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000eb98:	16 39       	cp.w	r9,r11
8000eb9a:	cf 73       	brcs	8000eb88 <__lshift+0x54>
8000eb9c:	91 0a       	st.w	r8[0x0],r10
8000eb9e:	58 0a       	cp.w	r10,0
8000eba0:	c0 70       	breq	8000ebae <__lshift+0x7a>
8000eba2:	2f f6       	sub	r6,-1
8000eba4:	c0 58       	rjmp	8000ebae <__lshift+0x7a>
8000eba6:	13 0a       	ld.w	r10,r9++
8000eba8:	10 aa       	st.w	r8++,r10
8000ebaa:	16 39       	cp.w	r9,r11
8000ebac:	cf d3       	brcs	8000eba6 <__lshift+0x72>
8000ebae:	08 9c       	mov	r12,r4
8000ebb0:	20 16       	sub	r6,1
8000ebb2:	0e 9b       	mov	r11,r7
8000ebb4:	8b 46       	st.w	r5[0x10],r6
8000ebb6:	cb 5e       	rcall	8000e920 <_Bfree>
8000ebb8:	0a 9c       	mov	r12,r5
8000ebba:	d8 32       	popm	r0-r7,pc

8000ebbc <__multiply>:
8000ebbc:	d4 31       	pushm	r0-r7,lr
8000ebbe:	20 2d       	sub	sp,8
8000ebc0:	76 49       	ld.w	r9,r11[0x10]
8000ebc2:	74 48       	ld.w	r8,r10[0x10]
8000ebc4:	16 96       	mov	r6,r11
8000ebc6:	14 95       	mov	r5,r10
8000ebc8:	10 39       	cp.w	r9,r8
8000ebca:	ec 08 17 50 	movlt	r8,r6
8000ebce:	ea 06 17 50 	movlt	r6,r5
8000ebd2:	f0 05 17 50 	movlt	r5,r8
8000ebd6:	6c 28       	ld.w	r8,r6[0x8]
8000ebd8:	76 43       	ld.w	r3,r11[0x10]
8000ebda:	74 42       	ld.w	r2,r10[0x10]
8000ebdc:	76 1b       	ld.w	r11,r11[0x4]
8000ebde:	e4 03 00 07 	add	r7,r2,r3
8000ebe2:	10 37       	cp.w	r7,r8
8000ebe4:	f7 bb 09 ff 	subgt	r11,-1
8000ebe8:	cb 6e       	rcall	8000e954 <_Balloc>
8000ebea:	ee c4 ff fb 	sub	r4,r7,-5
8000ebee:	f8 c9 ff ec 	sub	r9,r12,-20
8000ebf2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ebf6:	30 0a       	mov	r10,0
8000ebf8:	12 98       	mov	r8,r9
8000ebfa:	c0 28       	rjmp	8000ebfe <__multiply+0x42>
8000ebfc:	10 aa       	st.w	r8++,r10
8000ebfe:	08 38       	cp.w	r8,r4
8000ec00:	cf e3       	brcs	8000ebfc <__multiply+0x40>
8000ec02:	2f b3       	sub	r3,-5
8000ec04:	2f b2       	sub	r2,-5
8000ec06:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ec0a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ec0e:	ec cb ff ec 	sub	r11,r6,-20
8000ec12:	50 12       	stdsp	sp[0x4],r2
8000ec14:	ea ca ff ec 	sub	r10,r5,-20
8000ec18:	c4 48       	rjmp	8000eca0 <__multiply+0xe4>
8000ec1a:	94 95       	ld.uh	r5,r10[0x2]
8000ec1c:	58 05       	cp.w	r5,0
8000ec1e:	c2 00       	breq	8000ec5e <__multiply+0xa2>
8000ec20:	12 98       	mov	r8,r9
8000ec22:	16 96       	mov	r6,r11
8000ec24:	30 0e       	mov	lr,0
8000ec26:	50 09       	stdsp	sp[0x0],r9
8000ec28:	0d 02       	ld.w	r2,r6++
8000ec2a:	e4 00 16 10 	lsr	r0,r2,0x10
8000ec2e:	70 01       	ld.w	r1,r8[0x0]
8000ec30:	70 09       	ld.w	r9,r8[0x0]
8000ec32:	b1 81       	lsr	r1,0x10
8000ec34:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ec38:	e0 05 03 41 	mac	r1,r0,r5
8000ec3c:	ab 32       	mul	r2,r5
8000ec3e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ec42:	00 02       	add	r2,r0
8000ec44:	e4 0e 00 0e 	add	lr,r2,lr
8000ec48:	b0 1e       	st.h	r8[0x2],lr
8000ec4a:	b1 8e       	lsr	lr,0x10
8000ec4c:	1c 01       	add	r1,lr
8000ec4e:	b0 01       	st.h	r8[0x0],r1
8000ec50:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ec54:	2f c8       	sub	r8,-4
8000ec56:	06 36       	cp.w	r6,r3
8000ec58:	ce 83       	brcs	8000ec28 <__multiply+0x6c>
8000ec5a:	40 09       	lddsp	r9,sp[0x0]
8000ec5c:	91 0e       	st.w	r8[0x0],lr
8000ec5e:	94 86       	ld.uh	r6,r10[0x0]
8000ec60:	58 06       	cp.w	r6,0
8000ec62:	c1 d0       	breq	8000ec9c <__multiply+0xe0>
8000ec64:	72 02       	ld.w	r2,r9[0x0]
8000ec66:	12 98       	mov	r8,r9
8000ec68:	16 9e       	mov	lr,r11
8000ec6a:	30 05       	mov	r5,0
8000ec6c:	b0 12       	st.h	r8[0x2],r2
8000ec6e:	1d 01       	ld.w	r1,lr++
8000ec70:	90 82       	ld.uh	r2,r8[0x0]
8000ec72:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ec76:	ad 30       	mul	r0,r6
8000ec78:	e0 02 00 02 	add	r2,r0,r2
8000ec7c:	e4 05 00 05 	add	r5,r2,r5
8000ec80:	b0 05       	st.h	r8[0x0],r5
8000ec82:	b1 85       	lsr	r5,0x10
8000ec84:	b1 81       	lsr	r1,0x10
8000ec86:	2f c8       	sub	r8,-4
8000ec88:	ad 31       	mul	r1,r6
8000ec8a:	90 92       	ld.uh	r2,r8[0x2]
8000ec8c:	e2 02 00 02 	add	r2,r1,r2
8000ec90:	0a 02       	add	r2,r5
8000ec92:	e4 05 16 10 	lsr	r5,r2,0x10
8000ec96:	06 3e       	cp.w	lr,r3
8000ec98:	ce a3       	brcs	8000ec6c <__multiply+0xb0>
8000ec9a:	91 02       	st.w	r8[0x0],r2
8000ec9c:	2f ca       	sub	r10,-4
8000ec9e:	2f c9       	sub	r9,-4
8000eca0:	40 18       	lddsp	r8,sp[0x4]
8000eca2:	10 3a       	cp.w	r10,r8
8000eca4:	cb b3       	brcs	8000ec1a <__multiply+0x5e>
8000eca6:	c0 28       	rjmp	8000ecaa <__multiply+0xee>
8000eca8:	20 17       	sub	r7,1
8000ecaa:	58 07       	cp.w	r7,0
8000ecac:	e0 8a 00 05 	brle	8000ecb6 <__multiply+0xfa>
8000ecb0:	09 48       	ld.w	r8,--r4
8000ecb2:	58 08       	cp.w	r8,0
8000ecb4:	cf a0       	breq	8000eca8 <__multiply+0xec>
8000ecb6:	99 47       	st.w	r12[0x10],r7
8000ecb8:	2f ed       	sub	sp,-8
8000ecba:	d8 32       	popm	r0-r7,pc

8000ecbc <__i2b>:
8000ecbc:	d4 21       	pushm	r4-r7,lr
8000ecbe:	16 97       	mov	r7,r11
8000ecc0:	30 1b       	mov	r11,1
8000ecc2:	c4 9e       	rcall	8000e954 <_Balloc>
8000ecc4:	30 19       	mov	r9,1
8000ecc6:	99 57       	st.w	r12[0x14],r7
8000ecc8:	99 49       	st.w	r12[0x10],r9
8000ecca:	d8 22       	popm	r4-r7,pc

8000eccc <__multadd>:
8000eccc:	d4 31       	pushm	r0-r7,lr
8000ecce:	30 08       	mov	r8,0
8000ecd0:	12 95       	mov	r5,r9
8000ecd2:	16 97       	mov	r7,r11
8000ecd4:	18 96       	mov	r6,r12
8000ecd6:	76 44       	ld.w	r4,r11[0x10]
8000ecd8:	f6 c9 ff ec 	sub	r9,r11,-20
8000ecdc:	72 0b       	ld.w	r11,r9[0x0]
8000ecde:	f6 0c 16 10 	lsr	r12,r11,0x10
8000ece2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ece6:	f4 0c 02 4c 	mul	r12,r10,r12
8000ecea:	f4 0b 03 45 	mac	r5,r10,r11
8000ecee:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000ecf2:	b1 85       	lsr	r5,0x10
8000ecf4:	18 05       	add	r5,r12
8000ecf6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000ecfa:	f8 0b 00 0b 	add	r11,r12,r11
8000ecfe:	12 ab       	st.w	r9++,r11
8000ed00:	2f f8       	sub	r8,-1
8000ed02:	b1 85       	lsr	r5,0x10
8000ed04:	08 38       	cp.w	r8,r4
8000ed06:	ce b5       	brlt	8000ecdc <__multadd+0x10>
8000ed08:	58 05       	cp.w	r5,0
8000ed0a:	c1 c0       	breq	8000ed42 <__multadd+0x76>
8000ed0c:	6e 28       	ld.w	r8,r7[0x8]
8000ed0e:	10 34       	cp.w	r4,r8
8000ed10:	c1 35       	brlt	8000ed36 <__multadd+0x6a>
8000ed12:	6e 1b       	ld.w	r11,r7[0x4]
8000ed14:	0c 9c       	mov	r12,r6
8000ed16:	2f fb       	sub	r11,-1
8000ed18:	c1 ee       	rcall	8000e954 <_Balloc>
8000ed1a:	6e 4a       	ld.w	r10,r7[0x10]
8000ed1c:	ee cb ff f4 	sub	r11,r7,-12
8000ed20:	18 93       	mov	r3,r12
8000ed22:	2f ea       	sub	r10,-2
8000ed24:	2f 4c       	sub	r12,-12
8000ed26:	a3 6a       	lsl	r10,0x2
8000ed28:	fe b0 dd cb 	rcall	8000a8be <memcpy>
8000ed2c:	0e 9b       	mov	r11,r7
8000ed2e:	0c 9c       	mov	r12,r6
8000ed30:	fe b0 fd f8 	rcall	8000e920 <_Bfree>
8000ed34:	06 97       	mov	r7,r3
8000ed36:	e8 c8 ff ff 	sub	r8,r4,-1
8000ed3a:	2f b4       	sub	r4,-5
8000ed3c:	8f 48       	st.w	r7[0x10],r8
8000ed3e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000ed42:	0e 9c       	mov	r12,r7
8000ed44:	d8 32       	popm	r0-r7,pc
8000ed46:	d7 03       	nop

8000ed48 <__pow5mult>:
8000ed48:	d4 31       	pushm	r0-r7,lr
8000ed4a:	14 96       	mov	r6,r10
8000ed4c:	18 97       	mov	r7,r12
8000ed4e:	16 94       	mov	r4,r11
8000ed50:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000ed54:	c0 80       	breq	8000ed64 <__pow5mult+0x1c>
8000ed56:	20 18       	sub	r8,1
8000ed58:	49 f9       	lddpc	r9,8000edd4 <__pow5mult+0x8c>
8000ed5a:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000ed5e:	30 09       	mov	r9,0
8000ed60:	cb 6f       	rcall	8000eccc <__multadd>
8000ed62:	18 94       	mov	r4,r12
8000ed64:	a3 46       	asr	r6,0x2
8000ed66:	c3 40       	breq	8000edce <__pow5mult+0x86>
8000ed68:	6e 95       	ld.w	r5,r7[0x24]
8000ed6a:	58 05       	cp.w	r5,0
8000ed6c:	c0 91       	brne	8000ed7e <__pow5mult+0x36>
8000ed6e:	31 0c       	mov	r12,16
8000ed70:	fe b0 db 70 	rcall	8000a450 <malloc>
8000ed74:	99 35       	st.w	r12[0xc],r5
8000ed76:	8f 9c       	st.w	r7[0x24],r12
8000ed78:	99 15       	st.w	r12[0x4],r5
8000ed7a:	99 25       	st.w	r12[0x8],r5
8000ed7c:	99 05       	st.w	r12[0x0],r5
8000ed7e:	6e 93       	ld.w	r3,r7[0x24]
8000ed80:	66 25       	ld.w	r5,r3[0x8]
8000ed82:	58 05       	cp.w	r5,0
8000ed84:	c0 c1       	brne	8000ed9c <__pow5mult+0x54>
8000ed86:	e0 6b 02 71 	mov	r11,625
8000ed8a:	0e 9c       	mov	r12,r7
8000ed8c:	c9 8f       	rcall	8000ecbc <__i2b>
8000ed8e:	87 2c       	st.w	r3[0x8],r12
8000ed90:	30 08       	mov	r8,0
8000ed92:	18 95       	mov	r5,r12
8000ed94:	99 08       	st.w	r12[0x0],r8
8000ed96:	c0 38       	rjmp	8000ed9c <__pow5mult+0x54>
8000ed98:	06 9c       	mov	r12,r3
8000ed9a:	18 95       	mov	r5,r12
8000ed9c:	ed b6 00 00 	bld	r6,0x0
8000eda0:	c0 b1       	brne	8000edb6 <__pow5mult+0x6e>
8000eda2:	08 9b       	mov	r11,r4
8000eda4:	0a 9a       	mov	r10,r5
8000eda6:	0e 9c       	mov	r12,r7
8000eda8:	c0 af       	rcall	8000ebbc <__multiply>
8000edaa:	08 9b       	mov	r11,r4
8000edac:	18 93       	mov	r3,r12
8000edae:	0e 9c       	mov	r12,r7
8000edb0:	06 94       	mov	r4,r3
8000edb2:	fe b0 fd b7 	rcall	8000e920 <_Bfree>
8000edb6:	a1 56       	asr	r6,0x1
8000edb8:	c0 b0       	breq	8000edce <__pow5mult+0x86>
8000edba:	6a 03       	ld.w	r3,r5[0x0]
8000edbc:	58 03       	cp.w	r3,0
8000edbe:	ce d1       	brne	8000ed98 <__pow5mult+0x50>
8000edc0:	0a 9a       	mov	r10,r5
8000edc2:	0a 9b       	mov	r11,r5
8000edc4:	0e 9c       	mov	r12,r7
8000edc6:	cf be       	rcall	8000ebbc <__multiply>
8000edc8:	8b 0c       	st.w	r5[0x0],r12
8000edca:	99 03       	st.w	r12[0x0],r3
8000edcc:	ce 7b       	rjmp	8000ed9a <__pow5mult+0x52>
8000edce:	08 9c       	mov	r12,r4
8000edd0:	d8 32       	popm	r0-r7,pc
8000edd2:	d7 03       	nop
8000edd4:	80 01       	ld.sh	r1,r0[0x0]
8000edd6:	9d 34       	st.w	lr[0xc],r4

8000edd8 <__isinfd>:
8000edd8:	14 98       	mov	r8,r10
8000edda:	fc 19 7f f0 	movh	r9,0x7ff0
8000edde:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ede2:	f0 0b 11 00 	rsub	r11,r8,0
8000ede6:	f7 e8 10 08 	or	r8,r11,r8
8000edea:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000edee:	f2 08 01 08 	sub	r8,r9,r8
8000edf2:	f0 0c 11 00 	rsub	r12,r8,0
8000edf6:	f9 e8 10 08 	or	r8,r12,r8
8000edfa:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000edfe:	2f fc       	sub	r12,-1
8000ee00:	5e fc       	retal	r12

8000ee02 <__isnand>:
8000ee02:	14 98       	mov	r8,r10
8000ee04:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ee08:	f0 0c 11 00 	rsub	r12,r8,0
8000ee0c:	10 4c       	or	r12,r8
8000ee0e:	fc 18 7f f0 	movh	r8,0x7ff0
8000ee12:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ee16:	f0 0c 01 0c 	sub	r12,r8,r12
8000ee1a:	bf 9c       	lsr	r12,0x1f
8000ee1c:	5e fc       	retal	r12
8000ee1e:	d7 03       	nop

8000ee20 <__sclose>:
8000ee20:	d4 01       	pushm	lr
8000ee22:	96 7b       	ld.sh	r11,r11[0xe]
8000ee24:	c7 6c       	rcall	8000ef10 <_close_r>
8000ee26:	d8 02       	popm	pc

8000ee28 <__sseek>:
8000ee28:	d4 21       	pushm	r4-r7,lr
8000ee2a:	16 97       	mov	r7,r11
8000ee2c:	96 7b       	ld.sh	r11,r11[0xe]
8000ee2e:	cf 9c       	rcall	8000f020 <_lseek_r>
8000ee30:	8e 68       	ld.sh	r8,r7[0xc]
8000ee32:	10 99       	mov	r9,r8
8000ee34:	ad c8       	cbr	r8,0xc
8000ee36:	ad a9       	sbr	r9,0xc
8000ee38:	5b fc       	cp.w	r12,-1
8000ee3a:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000ee3e:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000ee42:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000ee46:	d8 22       	popm	r4-r7,pc

8000ee48 <__swrite>:
8000ee48:	d4 21       	pushm	r4-r7,lr
8000ee4a:	96 68       	ld.sh	r8,r11[0xc]
8000ee4c:	16 97       	mov	r7,r11
8000ee4e:	14 95       	mov	r5,r10
8000ee50:	12 94       	mov	r4,r9
8000ee52:	e2 18 01 00 	andl	r8,0x100,COH
8000ee56:	18 96       	mov	r6,r12
8000ee58:	c0 50       	breq	8000ee62 <__swrite+0x1a>
8000ee5a:	30 29       	mov	r9,2
8000ee5c:	30 0a       	mov	r10,0
8000ee5e:	96 7b       	ld.sh	r11,r11[0xe]
8000ee60:	ce 0c       	rcall	8000f020 <_lseek_r>
8000ee62:	8e 68       	ld.sh	r8,r7[0xc]
8000ee64:	ad c8       	cbr	r8,0xc
8000ee66:	08 99       	mov	r9,r4
8000ee68:	0a 9a       	mov	r10,r5
8000ee6a:	8e 7b       	ld.sh	r11,r7[0xe]
8000ee6c:	0c 9c       	mov	r12,r6
8000ee6e:	ae 68       	st.h	r7[0xc],r8
8000ee70:	c1 0c       	rcall	8000ee90 <_write_r>
8000ee72:	d8 22       	popm	r4-r7,pc

8000ee74 <__sread>:
8000ee74:	d4 21       	pushm	r4-r7,lr
8000ee76:	16 97       	mov	r7,r11
8000ee78:	96 7b       	ld.sh	r11,r11[0xe]
8000ee7a:	ce 7c       	rcall	8000f048 <_read_r>
8000ee7c:	c0 65       	brlt	8000ee88 <__sread+0x14>
8000ee7e:	6f 58       	ld.w	r8,r7[0x54]
8000ee80:	18 08       	add	r8,r12
8000ee82:	ef 48 00 54 	st.w	r7[84],r8
8000ee86:	d8 22       	popm	r4-r7,pc
8000ee88:	8e 68       	ld.sh	r8,r7[0xc]
8000ee8a:	ad c8       	cbr	r8,0xc
8000ee8c:	ae 68       	st.h	r7[0xc],r8
8000ee8e:	d8 22       	popm	r4-r7,pc

8000ee90 <_write_r>:
8000ee90:	d4 21       	pushm	r4-r7,lr
8000ee92:	16 98       	mov	r8,r11
8000ee94:	18 97       	mov	r7,r12
8000ee96:	10 9c       	mov	r12,r8
8000ee98:	30 08       	mov	r8,0
8000ee9a:	14 9b       	mov	r11,r10
8000ee9c:	e0 66 46 b0 	mov	r6,18096
8000eea0:	12 9a       	mov	r10,r9
8000eea2:	8d 08       	st.w	r6[0x0],r8
8000eea4:	fe b0 d0 56 	rcall	80008f50 <_write>
8000eea8:	5b fc       	cp.w	r12,-1
8000eeaa:	c0 51       	brne	8000eeb4 <_write_r+0x24>
8000eeac:	6c 08       	ld.w	r8,r6[0x0]
8000eeae:	58 08       	cp.w	r8,0
8000eeb0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000eeb4:	d8 22       	popm	r4-r7,pc
8000eeb6:	d7 03       	nop

8000eeb8 <_calloc_r>:
8000eeb8:	d4 21       	pushm	r4-r7,lr
8000eeba:	f4 0b 02 4b 	mul	r11,r10,r11
8000eebe:	fe b0 da d1 	rcall	8000a460 <_malloc_r>
8000eec2:	18 97       	mov	r7,r12
8000eec4:	c2 30       	breq	8000ef0a <_calloc_r+0x52>
8000eec6:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000eeca:	e0 1a ff fc 	andl	r10,0xfffc
8000eece:	20 4a       	sub	r10,4
8000eed0:	e0 4a 00 24 	cp.w	r10,36
8000eed4:	e0 8b 00 18 	brhi	8000ef04 <_calloc_r+0x4c>
8000eed8:	18 98       	mov	r8,r12
8000eeda:	59 3a       	cp.w	r10,19
8000eedc:	e0 88 00 0f 	brls	8000eefa <_calloc_r+0x42>
8000eee0:	30 09       	mov	r9,0
8000eee2:	10 a9       	st.w	r8++,r9
8000eee4:	10 a9       	st.w	r8++,r9
8000eee6:	59 ba       	cp.w	r10,27
8000eee8:	e0 88 00 09 	brls	8000eefa <_calloc_r+0x42>
8000eeec:	10 a9       	st.w	r8++,r9
8000eeee:	10 a9       	st.w	r8++,r9
8000eef0:	e0 4a 00 24 	cp.w	r10,36
8000eef4:	c0 31       	brne	8000eefa <_calloc_r+0x42>
8000eef6:	10 a9       	st.w	r8++,r9
8000eef8:	10 a9       	st.w	r8++,r9
8000eefa:	30 09       	mov	r9,0
8000eefc:	10 a9       	st.w	r8++,r9
8000eefe:	91 19       	st.w	r8[0x4],r9
8000ef00:	91 09       	st.w	r8[0x0],r9
8000ef02:	c0 48       	rjmp	8000ef0a <_calloc_r+0x52>
8000ef04:	30 0b       	mov	r11,0
8000ef06:	fe b0 dd 80 	rcall	8000aa06 <memset>
8000ef0a:	0e 9c       	mov	r12,r7
8000ef0c:	d8 22       	popm	r4-r7,pc
8000ef0e:	d7 03       	nop

8000ef10 <_close_r>:
8000ef10:	d4 21       	pushm	r4-r7,lr
8000ef12:	30 08       	mov	r8,0
8000ef14:	18 97       	mov	r7,r12
8000ef16:	e0 66 46 b0 	mov	r6,18096
8000ef1a:	16 9c       	mov	r12,r11
8000ef1c:	8d 08       	st.w	r6[0x0],r8
8000ef1e:	fe b0 df a5 	rcall	8000ae68 <_close>
8000ef22:	5b fc       	cp.w	r12,-1
8000ef24:	c0 51       	brne	8000ef2e <_close_r+0x1e>
8000ef26:	6c 08       	ld.w	r8,r6[0x0]
8000ef28:	58 08       	cp.w	r8,0
8000ef2a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ef2e:	d8 22       	popm	r4-r7,pc

8000ef30 <_fclose_r>:
8000ef30:	d4 21       	pushm	r4-r7,lr
8000ef32:	18 96       	mov	r6,r12
8000ef34:	16 97       	mov	r7,r11
8000ef36:	58 0b       	cp.w	r11,0
8000ef38:	c0 31       	brne	8000ef3e <_fclose_r+0xe>
8000ef3a:	16 95       	mov	r5,r11
8000ef3c:	c5 08       	rjmp	8000efdc <_fclose_r+0xac>
8000ef3e:	fe b0 f8 b1 	rcall	8000e0a0 <__sfp_lock_acquire>
8000ef42:	58 06       	cp.w	r6,0
8000ef44:	c0 70       	breq	8000ef52 <_fclose_r+0x22>
8000ef46:	6c 68       	ld.w	r8,r6[0x18]
8000ef48:	58 08       	cp.w	r8,0
8000ef4a:	c0 41       	brne	8000ef52 <_fclose_r+0x22>
8000ef4c:	0c 9c       	mov	r12,r6
8000ef4e:	fe b0 f8 fd 	rcall	8000e148 <__sinit>
8000ef52:	4a 48       	lddpc	r8,8000efe0 <_fclose_r+0xb0>
8000ef54:	10 37       	cp.w	r7,r8
8000ef56:	c0 31       	brne	8000ef5c <_fclose_r+0x2c>
8000ef58:	6c 07       	ld.w	r7,r6[0x0]
8000ef5a:	c0 a8       	rjmp	8000ef6e <_fclose_r+0x3e>
8000ef5c:	4a 28       	lddpc	r8,8000efe4 <_fclose_r+0xb4>
8000ef5e:	10 37       	cp.w	r7,r8
8000ef60:	c0 31       	brne	8000ef66 <_fclose_r+0x36>
8000ef62:	6c 17       	ld.w	r7,r6[0x4]
8000ef64:	c0 58       	rjmp	8000ef6e <_fclose_r+0x3e>
8000ef66:	4a 18       	lddpc	r8,8000efe8 <_fclose_r+0xb8>
8000ef68:	10 37       	cp.w	r7,r8
8000ef6a:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ef6e:	8e 69       	ld.sh	r9,r7[0xc]
8000ef70:	30 08       	mov	r8,0
8000ef72:	f0 09 19 00 	cp.h	r9,r8
8000ef76:	c0 51       	brne	8000ef80 <_fclose_r+0x50>
8000ef78:	fe b0 f8 95 	rcall	8000e0a2 <__sfp_lock_release>
8000ef7c:	30 05       	mov	r5,0
8000ef7e:	c2 f8       	rjmp	8000efdc <_fclose_r+0xac>
8000ef80:	0e 9b       	mov	r11,r7
8000ef82:	0c 9c       	mov	r12,r6
8000ef84:	fe b0 f8 06 	rcall	8000df90 <_fflush_r>
8000ef88:	6e c8       	ld.w	r8,r7[0x30]
8000ef8a:	18 95       	mov	r5,r12
8000ef8c:	58 08       	cp.w	r8,0
8000ef8e:	c0 60       	breq	8000ef9a <_fclose_r+0x6a>
8000ef90:	6e 8b       	ld.w	r11,r7[0x20]
8000ef92:	0c 9c       	mov	r12,r6
8000ef94:	5d 18       	icall	r8
8000ef96:	f9 b5 05 ff 	movlt	r5,-1
8000ef9a:	8e 68       	ld.sh	r8,r7[0xc]
8000ef9c:	ed b8 00 07 	bld	r8,0x7
8000efa0:	c0 51       	brne	8000efaa <_fclose_r+0x7a>
8000efa2:	6e 4b       	ld.w	r11,r7[0x10]
8000efa4:	0c 9c       	mov	r12,r6
8000efa6:	fe b0 f9 6b 	rcall	8000e27c <_free_r>
8000efaa:	6e db       	ld.w	r11,r7[0x34]
8000efac:	58 0b       	cp.w	r11,0
8000efae:	c0 a0       	breq	8000efc2 <_fclose_r+0x92>
8000efb0:	ee c8 ff bc 	sub	r8,r7,-68
8000efb4:	10 3b       	cp.w	r11,r8
8000efb6:	c0 40       	breq	8000efbe <_fclose_r+0x8e>
8000efb8:	0c 9c       	mov	r12,r6
8000efba:	fe b0 f9 61 	rcall	8000e27c <_free_r>
8000efbe:	30 08       	mov	r8,0
8000efc0:	8f d8       	st.w	r7[0x34],r8
8000efc2:	6f 2b       	ld.w	r11,r7[0x48]
8000efc4:	58 0b       	cp.w	r11,0
8000efc6:	c0 70       	breq	8000efd4 <_fclose_r+0xa4>
8000efc8:	0c 9c       	mov	r12,r6
8000efca:	fe b0 f9 59 	rcall	8000e27c <_free_r>
8000efce:	30 08       	mov	r8,0
8000efd0:	ef 48 00 48 	st.w	r7[72],r8
8000efd4:	30 08       	mov	r8,0
8000efd6:	ae 68       	st.h	r7[0xc],r8
8000efd8:	fe b0 f8 65 	rcall	8000e0a2 <__sfp_lock_release>
8000efdc:	0a 9c       	mov	r12,r5
8000efde:	d8 22       	popm	r4-r7,pc
8000efe0:	80 01       	ld.sh	r1,r0[0x0]
8000efe2:	9c 90       	ld.uh	r0,lr[0x2]
8000efe4:	80 01       	ld.sh	r1,r0[0x0]
8000efe6:	9c b0       	ld.uh	r0,lr[0x6]
8000efe8:	80 01       	ld.sh	r1,r0[0x0]
8000efea:	9c d0       	ld.uh	r0,lr[0xa]

8000efec <fclose>:
8000efec:	d4 01       	pushm	lr
8000efee:	e0 68 0a 38 	mov	r8,2616
8000eff2:	18 9b       	mov	r11,r12
8000eff4:	70 0c       	ld.w	r12,r8[0x0]
8000eff6:	c9 df       	rcall	8000ef30 <_fclose_r>
8000eff8:	d8 02       	popm	pc
8000effa:	d7 03       	nop

8000effc <_fstat_r>:
8000effc:	d4 21       	pushm	r4-r7,lr
8000effe:	16 98       	mov	r8,r11
8000f000:	18 97       	mov	r7,r12
8000f002:	10 9c       	mov	r12,r8
8000f004:	30 08       	mov	r8,0
8000f006:	e0 66 46 b0 	mov	r6,18096
8000f00a:	14 9b       	mov	r11,r10
8000f00c:	8d 08       	st.w	r6[0x0],r8
8000f00e:	fe b0 df 55 	rcall	8000aeb8 <_fstat>
8000f012:	5b fc       	cp.w	r12,-1
8000f014:	c0 51       	brne	8000f01e <_fstat_r+0x22>
8000f016:	6c 08       	ld.w	r8,r6[0x0]
8000f018:	58 08       	cp.w	r8,0
8000f01a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f01e:	d8 22       	popm	r4-r7,pc

8000f020 <_lseek_r>:
8000f020:	d4 21       	pushm	r4-r7,lr
8000f022:	16 98       	mov	r8,r11
8000f024:	18 97       	mov	r7,r12
8000f026:	10 9c       	mov	r12,r8
8000f028:	30 08       	mov	r8,0
8000f02a:	14 9b       	mov	r11,r10
8000f02c:	e0 66 46 b0 	mov	r6,18096
8000f030:	12 9a       	mov	r10,r9
8000f032:	8d 08       	st.w	r6[0x0],r8
8000f034:	fe b0 df 24 	rcall	8000ae7c <_lseek>
8000f038:	5b fc       	cp.w	r12,-1
8000f03a:	c0 51       	brne	8000f044 <_lseek_r+0x24>
8000f03c:	6c 08       	ld.w	r8,r6[0x0]
8000f03e:	58 08       	cp.w	r8,0
8000f040:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f044:	d8 22       	popm	r4-r7,pc
8000f046:	d7 03       	nop

8000f048 <_read_r>:
8000f048:	d4 21       	pushm	r4-r7,lr
8000f04a:	16 98       	mov	r8,r11
8000f04c:	18 97       	mov	r7,r12
8000f04e:	10 9c       	mov	r12,r8
8000f050:	30 08       	mov	r8,0
8000f052:	14 9b       	mov	r11,r10
8000f054:	e0 66 46 b0 	mov	r6,18096
8000f058:	12 9a       	mov	r10,r9
8000f05a:	8d 08       	st.w	r6[0x0],r8
8000f05c:	fe b0 cf 5a 	rcall	80008f10 <_read>
8000f060:	5b fc       	cp.w	r12,-1
8000f062:	c0 51       	brne	8000f06c <_read_r+0x24>
8000f064:	6c 08       	ld.w	r8,r6[0x0]
8000f066:	58 08       	cp.w	r8,0
8000f068:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f06c:	d8 22       	popm	r4-r7,pc
8000f06e:	d7 03       	nop

8000f070 <__avr32_f64_mul>:
8000f070:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000f074:	e0 80 00 dc 	breq	8000f22c <__avr32_f64_mul_op1_zero>
8000f078:	d4 21       	pushm	r4-r7,lr
8000f07a:	f7 e9 20 0e 	eor	lr,r11,r9
8000f07e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f082:	30 15       	mov	r5,1
8000f084:	c4 30       	breq	8000f10a <__avr32_f64_mul_op1_subnormal>
8000f086:	ab 6b       	lsl	r11,0xa
8000f088:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000f08c:	ab 6a       	lsl	r10,0xa
8000f08e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000f092:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f096:	c5 c0       	breq	8000f14e <__avr32_f64_mul_op2_subnormal>
8000f098:	a1 78       	lsl	r8,0x1
8000f09a:	5c f9       	rol	r9
8000f09c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000f0a0:	e0 47 07 ff 	cp.w	r7,2047
8000f0a4:	c7 70       	breq	8000f192 <__avr32_f64_mul_op_nan_or_inf>
8000f0a6:	e0 46 07 ff 	cp.w	r6,2047
8000f0aa:	c7 40       	breq	8000f192 <__avr32_f64_mul_op_nan_or_inf>
8000f0ac:	ee 06 00 0c 	add	r12,r7,r6
8000f0b0:	e0 2c 03 fe 	sub	r12,1022
8000f0b4:	f6 08 06 44 	mulu.d	r4,r11,r8
8000f0b8:	f4 09 07 44 	macu.d	r4,r10,r9
8000f0bc:	f4 08 06 46 	mulu.d	r6,r10,r8
8000f0c0:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000f0c4:	08 07       	add	r7,r4
8000f0c6:	f4 05 00 4a 	adc	r10,r10,r5
8000f0ca:	5c 0b       	acr	r11
8000f0cc:	ed bb 00 14 	bld	r11,0x14
8000f0d0:	c0 50       	breq	8000f0da <__avr32_f64_mul+0x6a>
8000f0d2:	a1 77       	lsl	r7,0x1
8000f0d4:	5c fa       	rol	r10
8000f0d6:	5c fb       	rol	r11
8000f0d8:	20 1c       	sub	r12,1
8000f0da:	58 0c       	cp.w	r12,0
8000f0dc:	e0 8a 00 6f 	brle	8000f1ba <__avr32_f64_mul_res_subnormal>
8000f0e0:	e0 4c 07 ff 	cp.w	r12,2047
8000f0e4:	e0 84 00 9c 	brge	8000f21c <__avr32_f64_mul_res_inf>
8000f0e8:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000f0ec:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000f0f0:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000f0f4:	ee 17 80 00 	eorh	r7,0x8000
8000f0f8:	f1 b7 04 20 	satu	r7,0x1
8000f0fc:	0e 0a       	add	r10,r7
8000f0fe:	5c 0b       	acr	r11
8000f100:	ed be 00 1f 	bld	lr,0x1f
8000f104:	ef bb 00 1f 	bst	r11,0x1f
8000f108:	d8 22       	popm	r4-r7,pc

8000f10a <__avr32_f64_mul_op1_subnormal>:
8000f10a:	e4 1b 00 0f 	andh	r11,0xf
8000f10e:	f4 0c 12 00 	clz	r12,r10
8000f112:	f6 06 12 00 	clz	r6,r11
8000f116:	f7 bc 03 e1 	sublo	r12,-31
8000f11a:	f8 06 17 30 	movlo	r6,r12
8000f11e:	f7 b6 02 01 	subhs	r6,1
8000f122:	e0 46 00 20 	cp.w	r6,32
8000f126:	c0 d4       	brge	8000f140 <__avr32_f64_mul_op1_subnormal+0x36>
8000f128:	ec 0c 11 20 	rsub	r12,r6,32
8000f12c:	f6 06 09 4b 	lsl	r11,r11,r6
8000f130:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000f134:	18 4b       	or	r11,r12
8000f136:	f4 06 09 4a 	lsl	r10,r10,r6
8000f13a:	20 b6       	sub	r6,11
8000f13c:	0c 17       	sub	r7,r6
8000f13e:	ca ab       	rjmp	8000f092 <__avr32_f64_mul+0x22>
8000f140:	f4 06 09 4b 	lsl	r11,r10,r6
8000f144:	c6 40       	breq	8000f20c <__avr32_f64_mul_res_zero>
8000f146:	30 0a       	mov	r10,0
8000f148:	20 b6       	sub	r6,11
8000f14a:	0c 17       	sub	r7,r6
8000f14c:	ca 3b       	rjmp	8000f092 <__avr32_f64_mul+0x22>

8000f14e <__avr32_f64_mul_op2_subnormal>:
8000f14e:	e4 19 00 0f 	andh	r9,0xf
8000f152:	f0 0c 12 00 	clz	r12,r8
8000f156:	f2 05 12 00 	clz	r5,r9
8000f15a:	f7 bc 03 ea 	sublo	r12,-22
8000f15e:	f8 05 17 30 	movlo	r5,r12
8000f162:	f7 b5 02 0a 	subhs	r5,10
8000f166:	e0 45 00 20 	cp.w	r5,32
8000f16a:	c0 d4       	brge	8000f184 <__avr32_f64_mul_op2_subnormal+0x36>
8000f16c:	ea 0c 11 20 	rsub	r12,r5,32
8000f170:	f2 05 09 49 	lsl	r9,r9,r5
8000f174:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000f178:	18 49       	or	r9,r12
8000f17a:	f0 05 09 48 	lsl	r8,r8,r5
8000f17e:	20 25       	sub	r5,2
8000f180:	0a 16       	sub	r6,r5
8000f182:	c8 fb       	rjmp	8000f0a0 <__avr32_f64_mul+0x30>
8000f184:	f0 05 09 49 	lsl	r9,r8,r5
8000f188:	c4 20       	breq	8000f20c <__avr32_f64_mul_res_zero>
8000f18a:	30 08       	mov	r8,0
8000f18c:	20 25       	sub	r5,2
8000f18e:	0a 16       	sub	r6,r5
8000f190:	c8 8b       	rjmp	8000f0a0 <__avr32_f64_mul+0x30>

8000f192 <__avr32_f64_mul_op_nan_or_inf>:
8000f192:	e4 19 00 0f 	andh	r9,0xf
8000f196:	e4 1b 00 0f 	andh	r11,0xf
8000f19a:	14 4b       	or	r11,r10
8000f19c:	10 49       	or	r9,r8
8000f19e:	e0 47 07 ff 	cp.w	r7,2047
8000f1a2:	c0 91       	brne	8000f1b4 <__avr32_f64_mul_op1_not_naninf>
8000f1a4:	58 0b       	cp.w	r11,0
8000f1a6:	c3 81       	brne	8000f216 <__avr32_f64_mul_res_nan>
8000f1a8:	e0 46 07 ff 	cp.w	r6,2047
8000f1ac:	c3 81       	brne	8000f21c <__avr32_f64_mul_res_inf>
8000f1ae:	58 09       	cp.w	r9,0
8000f1b0:	c3 60       	breq	8000f21c <__avr32_f64_mul_res_inf>
8000f1b2:	c3 28       	rjmp	8000f216 <__avr32_f64_mul_res_nan>

8000f1b4 <__avr32_f64_mul_op1_not_naninf>:
8000f1b4:	58 09       	cp.w	r9,0
8000f1b6:	c3 30       	breq	8000f21c <__avr32_f64_mul_res_inf>
8000f1b8:	c2 f8       	rjmp	8000f216 <__avr32_f64_mul_res_nan>

8000f1ba <__avr32_f64_mul_res_subnormal>:
8000f1ba:	5c 3c       	neg	r12
8000f1bc:	2f fc       	sub	r12,-1
8000f1be:	f1 bc 04 c0 	satu	r12,0x6
8000f1c2:	e0 4c 00 20 	cp.w	r12,32
8000f1c6:	c1 14       	brge	8000f1e8 <__avr32_f64_mul_res_subnormal+0x2e>
8000f1c8:	f8 08 11 20 	rsub	r8,r12,32
8000f1cc:	0e 46       	or	r6,r7
8000f1ce:	ee 0c 0a 47 	lsr	r7,r7,r12
8000f1d2:	f4 08 09 49 	lsl	r9,r10,r8
8000f1d6:	12 47       	or	r7,r9
8000f1d8:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f1dc:	f6 08 09 49 	lsl	r9,r11,r8
8000f1e0:	12 4a       	or	r10,r9
8000f1e2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f1e6:	c8 3b       	rjmp	8000f0ec <__avr32_f64_mul+0x7c>
8000f1e8:	f8 08 11 20 	rsub	r8,r12,32
8000f1ec:	f9 b9 00 00 	moveq	r9,0
8000f1f0:	c0 30       	breq	8000f1f6 <__avr32_f64_mul_res_subnormal+0x3c>
8000f1f2:	f6 08 09 49 	lsl	r9,r11,r8
8000f1f6:	0e 46       	or	r6,r7
8000f1f8:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000f1fc:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f200:	f3 ea 10 07 	or	r7,r9,r10
8000f204:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000f208:	30 0b       	mov	r11,0
8000f20a:	c7 1b       	rjmp	8000f0ec <__avr32_f64_mul+0x7c>

8000f20c <__avr32_f64_mul_res_zero>:
8000f20c:	1c 9b       	mov	r11,lr
8000f20e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f212:	30 0a       	mov	r10,0
8000f214:	d8 22       	popm	r4-r7,pc

8000f216 <__avr32_f64_mul_res_nan>:
8000f216:	3f fb       	mov	r11,-1
8000f218:	3f fa       	mov	r10,-1
8000f21a:	d8 22       	popm	r4-r7,pc

8000f21c <__avr32_f64_mul_res_inf>:
8000f21c:	f0 6b 00 00 	mov	r11,-1048576
8000f220:	ed be 00 1f 	bld	lr,0x1f
8000f224:	ef bb 00 1f 	bst	r11,0x1f
8000f228:	30 0a       	mov	r10,0
8000f22a:	d8 22       	popm	r4-r7,pc

8000f22c <__avr32_f64_mul_op1_zero>:
8000f22c:	f7 e9 20 0b 	eor	r11,r11,r9
8000f230:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f234:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000f238:	e0 4c 07 ff 	cp.w	r12,2047
8000f23c:	5e 1c       	retne	r12
8000f23e:	3f fa       	mov	r10,-1
8000f240:	3f fb       	mov	r11,-1
8000f242:	5e fc       	retal	r12

8000f244 <__avr32_f64_sub_from_add>:
8000f244:	ee 19 80 00 	eorh	r9,0x8000

8000f248 <__avr32_f64_sub>:
8000f248:	f7 e9 20 0c 	eor	r12,r11,r9
8000f24c:	e0 86 00 ca 	brmi	8000f3e0 <__avr32_f64_add_from_sub>
8000f250:	eb cd 40 e0 	pushm	r5-r7,lr
8000f254:	16 9c       	mov	r12,r11
8000f256:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f25a:	bf db       	cbr	r11,0x1f
8000f25c:	bf d9       	cbr	r9,0x1f
8000f25e:	10 3a       	cp.w	r10,r8
8000f260:	f2 0b 13 00 	cpc	r11,r9
8000f264:	c0 92       	brcc	8000f276 <__avr32_f64_sub+0x2e>
8000f266:	16 97       	mov	r7,r11
8000f268:	12 9b       	mov	r11,r9
8000f26a:	0e 99       	mov	r9,r7
8000f26c:	14 97       	mov	r7,r10
8000f26e:	10 9a       	mov	r10,r8
8000f270:	0e 98       	mov	r8,r7
8000f272:	ee 1c 80 00 	eorh	r12,0x8000
8000f276:	f6 07 16 14 	lsr	r7,r11,0x14
8000f27a:	ab 7b       	lsl	r11,0xb
8000f27c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f280:	ab 7a       	lsl	r10,0xb
8000f282:	bf bb       	sbr	r11,0x1f
8000f284:	f2 06 16 14 	lsr	r6,r9,0x14
8000f288:	c4 40       	breq	8000f310 <__avr32_f64_sub_opL_subnormal>
8000f28a:	ab 79       	lsl	r9,0xb
8000f28c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f290:	ab 78       	lsl	r8,0xb
8000f292:	bf b9       	sbr	r9,0x1f

8000f294 <__avr32_f64_sub_opL_subnormal_done>:
8000f294:	e0 47 07 ff 	cp.w	r7,2047
8000f298:	c4 f0       	breq	8000f336 <__avr32_f64_sub_opH_nan_or_inf>
8000f29a:	0e 26       	rsub	r6,r7
8000f29c:	c1 20       	breq	8000f2c0 <__avr32_f64_sub_shift_done>
8000f29e:	ec 05 11 20 	rsub	r5,r6,32
8000f2a2:	e0 46 00 20 	cp.w	r6,32
8000f2a6:	c7 c2       	brcc	8000f39e <__avr32_f64_sub_longshift>
8000f2a8:	f0 05 09 4e 	lsl	lr,r8,r5
8000f2ac:	f2 05 09 45 	lsl	r5,r9,r5
8000f2b0:	f0 06 0a 48 	lsr	r8,r8,r6
8000f2b4:	f2 06 0a 49 	lsr	r9,r9,r6
8000f2b8:	0a 48       	or	r8,r5
8000f2ba:	58 0e       	cp.w	lr,0
8000f2bc:	5f 1e       	srne	lr
8000f2be:	1c 48       	or	r8,lr

8000f2c0 <__avr32_f64_sub_shift_done>:
8000f2c0:	10 1a       	sub	r10,r8
8000f2c2:	f6 09 01 4b 	sbc	r11,r11,r9
8000f2c6:	f6 06 12 00 	clz	r6,r11
8000f2ca:	c0 e0       	breq	8000f2e6 <__avr32_f64_sub_longnormalize_done>
8000f2cc:	c7 83       	brcs	8000f3bc <__avr32_f64_sub_longnormalize>
8000f2ce:	ec 0e 11 20 	rsub	lr,r6,32
8000f2d2:	f6 06 09 4b 	lsl	r11,r11,r6
8000f2d6:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f2da:	1c 4b       	or	r11,lr
8000f2dc:	f4 06 09 4a 	lsl	r10,r10,r6
8000f2e0:	0c 17       	sub	r7,r6
8000f2e2:	e0 8a 00 39 	brle	8000f354 <__avr32_f64_sub_subnormal_result>

8000f2e6 <__avr32_f64_sub_longnormalize_done>:
8000f2e6:	f4 09 15 15 	lsl	r9,r10,0x15
8000f2ea:	ab 9a       	lsr	r10,0xb
8000f2ec:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f2f0:	ab 9b       	lsr	r11,0xb
8000f2f2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f2f6:	18 4b       	or	r11,r12

8000f2f8 <__avr32_f64_sub_round>:
8000f2f8:	fc 17 80 00 	movh	r7,0x8000
8000f2fc:	ed ba 00 00 	bld	r10,0x0
8000f300:	f7 b7 01 ff 	subne	r7,-1
8000f304:	0e 39       	cp.w	r9,r7
8000f306:	5f 29       	srhs	r9
8000f308:	12 0a       	add	r10,r9
8000f30a:	5c 0b       	acr	r11
8000f30c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f310 <__avr32_f64_sub_opL_subnormal>:
8000f310:	ab 79       	lsl	r9,0xb
8000f312:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f316:	ab 78       	lsl	r8,0xb
8000f318:	f3 e8 10 0e 	or	lr,r9,r8
8000f31c:	f9 b6 01 01 	movne	r6,1
8000f320:	ee 0e 11 00 	rsub	lr,r7,0
8000f324:	f9 b7 00 01 	moveq	r7,1
8000f328:	ef bb 00 1f 	bst	r11,0x1f
8000f32c:	f7 ea 10 0e 	or	lr,r11,r10
8000f330:	f9 b7 00 00 	moveq	r7,0
8000f334:	cb 0b       	rjmp	8000f294 <__avr32_f64_sub_opL_subnormal_done>

8000f336 <__avr32_f64_sub_opH_nan_or_inf>:
8000f336:	bf db       	cbr	r11,0x1f
8000f338:	f7 ea 10 0e 	or	lr,r11,r10
8000f33c:	c0 81       	brne	8000f34c <__avr32_f64_sub_return_nan>
8000f33e:	e0 46 07 ff 	cp.w	r6,2047
8000f342:	c0 50       	breq	8000f34c <__avr32_f64_sub_return_nan>
8000f344:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000f348:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f34c <__avr32_f64_sub_return_nan>:
8000f34c:	3f fa       	mov	r10,-1
8000f34e:	3f fb       	mov	r11,-1
8000f350:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f354 <__avr32_f64_sub_subnormal_result>:
8000f354:	5c 37       	neg	r7
8000f356:	2f f7       	sub	r7,-1
8000f358:	f1 b7 04 c0 	satu	r7,0x6
8000f35c:	e0 47 00 20 	cp.w	r7,32
8000f360:	c1 14       	brge	8000f382 <__avr32_f64_sub_subnormal_result+0x2e>
8000f362:	ee 08 11 20 	rsub	r8,r7,32
8000f366:	f4 08 09 49 	lsl	r9,r10,r8
8000f36a:	5f 16       	srne	r6
8000f36c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f370:	0c 4a       	or	r10,r6
8000f372:	f6 08 09 49 	lsl	r9,r11,r8
8000f376:	f5 e9 10 0a 	or	r10,r10,r9
8000f37a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000f37e:	30 07       	mov	r7,0
8000f380:	cb 3b       	rjmp	8000f2e6 <__avr32_f64_sub_longnormalize_done>
8000f382:	ee 08 11 40 	rsub	r8,r7,64
8000f386:	f6 08 09 49 	lsl	r9,r11,r8
8000f38a:	14 49       	or	r9,r10
8000f38c:	5f 16       	srne	r6
8000f38e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f392:	0c 4a       	or	r10,r6
8000f394:	30 0b       	mov	r11,0
8000f396:	30 07       	mov	r7,0
8000f398:	ca 7b       	rjmp	8000f2e6 <__avr32_f64_sub_longnormalize_done>
8000f39a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f39e <__avr32_f64_sub_longshift>:
8000f39e:	f1 b6 04 c0 	satu	r6,0x6
8000f3a2:	f0 0e 17 00 	moveq	lr,r8
8000f3a6:	c0 40       	breq	8000f3ae <__avr32_f64_sub_longshift+0x10>
8000f3a8:	f2 05 09 4e 	lsl	lr,r9,r5
8000f3ac:	10 4e       	or	lr,r8
8000f3ae:	f2 06 0a 48 	lsr	r8,r9,r6
8000f3b2:	30 09       	mov	r9,0
8000f3b4:	58 0e       	cp.w	lr,0
8000f3b6:	5f 1e       	srne	lr
8000f3b8:	1c 48       	or	r8,lr
8000f3ba:	c8 3b       	rjmp	8000f2c0 <__avr32_f64_sub_shift_done>

8000f3bc <__avr32_f64_sub_longnormalize>:
8000f3bc:	f4 06 12 00 	clz	r6,r10
8000f3c0:	f9 b7 03 00 	movlo	r7,0
8000f3c4:	f9 b6 03 00 	movlo	r6,0
8000f3c8:	f9 bc 03 00 	movlo	r12,0
8000f3cc:	f7 b6 02 e0 	subhs	r6,-32
8000f3d0:	f4 06 09 4b 	lsl	r11,r10,r6
8000f3d4:	30 0a       	mov	r10,0
8000f3d6:	0c 17       	sub	r7,r6
8000f3d8:	fe 9a ff be 	brle	8000f354 <__avr32_f64_sub_subnormal_result>
8000f3dc:	c8 5b       	rjmp	8000f2e6 <__avr32_f64_sub_longnormalize_done>
8000f3de:	d7 03       	nop

8000f3e0 <__avr32_f64_add_from_sub>:
8000f3e0:	ee 19 80 00 	eorh	r9,0x8000

8000f3e4 <__avr32_f64_add>:
8000f3e4:	f7 e9 20 0c 	eor	r12,r11,r9
8000f3e8:	fe 96 ff 2e 	brmi	8000f244 <__avr32_f64_sub_from_add>
8000f3ec:	eb cd 40 e0 	pushm	r5-r7,lr
8000f3f0:	16 9c       	mov	r12,r11
8000f3f2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f3f6:	bf db       	cbr	r11,0x1f
8000f3f8:	bf d9       	cbr	r9,0x1f
8000f3fa:	12 3b       	cp.w	r11,r9
8000f3fc:	c0 72       	brcc	8000f40a <__avr32_f64_add+0x26>
8000f3fe:	16 97       	mov	r7,r11
8000f400:	12 9b       	mov	r11,r9
8000f402:	0e 99       	mov	r9,r7
8000f404:	14 97       	mov	r7,r10
8000f406:	10 9a       	mov	r10,r8
8000f408:	0e 98       	mov	r8,r7
8000f40a:	30 0e       	mov	lr,0
8000f40c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f410:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000f414:	b5 ab       	sbr	r11,0x14
8000f416:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f41a:	c6 20       	breq	8000f4de <__avr32_f64_add_op2_subnormal>
8000f41c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000f420:	b5 a9       	sbr	r9,0x14
8000f422:	e0 47 07 ff 	cp.w	r7,2047
8000f426:	c2 80       	breq	8000f476 <__avr32_f64_add_opH_nan_or_inf>
8000f428:	0e 26       	rsub	r6,r7
8000f42a:	c1 20       	breq	8000f44e <__avr32_f64_add_shift_done>
8000f42c:	e0 46 00 36 	cp.w	r6,54
8000f430:	c1 52       	brcc	8000f45a <__avr32_f64_add_res_of_done>
8000f432:	ec 05 11 20 	rsub	r5,r6,32
8000f436:	e0 46 00 20 	cp.w	r6,32
8000f43a:	c3 52       	brcc	8000f4a4 <__avr32_f64_add_longshift>
8000f43c:	f0 05 09 4e 	lsl	lr,r8,r5
8000f440:	f2 05 09 45 	lsl	r5,r9,r5
8000f444:	f0 06 0a 48 	lsr	r8,r8,r6
8000f448:	f2 06 0a 49 	lsr	r9,r9,r6
8000f44c:	0a 48       	or	r8,r5

8000f44e <__avr32_f64_add_shift_done>:
8000f44e:	10 0a       	add	r10,r8
8000f450:	f6 09 00 4b 	adc	r11,r11,r9
8000f454:	ed bb 00 15 	bld	r11,0x15
8000f458:	c3 40       	breq	8000f4c0 <__avr32_f64_add_res_of>

8000f45a <__avr32_f64_add_res_of_done>:
8000f45a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f45e:	18 4b       	or	r11,r12

8000f460 <__avr32_f64_add_round>:
8000f460:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000f464:	18 4e       	or	lr,r12
8000f466:	ee 1e 80 00 	eorh	lr,0x8000
8000f46a:	f1 be 04 20 	satu	lr,0x1
8000f46e:	1c 0a       	add	r10,lr
8000f470:	5c 0b       	acr	r11
8000f472:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f476 <__avr32_f64_add_opH_nan_or_inf>:
8000f476:	b5 cb       	cbr	r11,0x14
8000f478:	f7 ea 10 0e 	or	lr,r11,r10
8000f47c:	c1 01       	brne	8000f49c <__avr32_f64_add_return_nan>
8000f47e:	e0 46 07 ff 	cp.w	r6,2047
8000f482:	c0 30       	breq	8000f488 <__avr32_f64_add_opL_nan_or_inf>
8000f484:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f488 <__avr32_f64_add_opL_nan_or_inf>:
8000f488:	b5 c9       	cbr	r9,0x14
8000f48a:	f3 e8 10 0e 	or	lr,r9,r8
8000f48e:	c0 71       	brne	8000f49c <__avr32_f64_add_return_nan>
8000f490:	30 0a       	mov	r10,0
8000f492:	fc 1b 7f f0 	movh	r11,0x7ff0
8000f496:	18 4b       	or	r11,r12
8000f498:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f49c <__avr32_f64_add_return_nan>:
8000f49c:	3f fa       	mov	r10,-1
8000f49e:	3f fb       	mov	r11,-1
8000f4a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f4a4 <__avr32_f64_add_longshift>:
8000f4a4:	f1 b6 04 c0 	satu	r6,0x6
8000f4a8:	f0 0e 17 00 	moveq	lr,r8
8000f4ac:	c0 60       	breq	8000f4b8 <__avr32_f64_add_longshift+0x14>
8000f4ae:	f2 05 09 4e 	lsl	lr,r9,r5
8000f4b2:	58 08       	cp.w	r8,0
8000f4b4:	5f 18       	srne	r8
8000f4b6:	10 4e       	or	lr,r8
8000f4b8:	f2 06 0a 48 	lsr	r8,r9,r6
8000f4bc:	30 09       	mov	r9,0
8000f4be:	cc 8b       	rjmp	8000f44e <__avr32_f64_add_shift_done>

8000f4c0 <__avr32_f64_add_res_of>:
8000f4c0:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000f4c4:	a1 9b       	lsr	r11,0x1
8000f4c6:	5d 0a       	ror	r10
8000f4c8:	5d 0e       	ror	lr
8000f4ca:	2f f7       	sub	r7,-1
8000f4cc:	e0 47 07 ff 	cp.w	r7,2047
8000f4d0:	f9 ba 00 00 	moveq	r10,0
8000f4d4:	f9 bb 00 00 	moveq	r11,0
8000f4d8:	f9 be 00 00 	moveq	lr,0
8000f4dc:	cb fb       	rjmp	8000f45a <__avr32_f64_add_res_of_done>

8000f4de <__avr32_f64_add_op2_subnormal>:
8000f4de:	30 16       	mov	r6,1
8000f4e0:	58 07       	cp.w	r7,0
8000f4e2:	ca 01       	brne	8000f422 <__avr32_f64_add+0x3e>
8000f4e4:	b5 cb       	cbr	r11,0x14
8000f4e6:	10 0a       	add	r10,r8
8000f4e8:	f6 09 00 4b 	adc	r11,r11,r9
8000f4ec:	18 4b       	or	r11,r12
8000f4ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000f4f2:	d7 03       	nop

8000f4f4 <__avr32_f64_to_u32>:
8000f4f4:	58 0b       	cp.w	r11,0
8000f4f6:	5e 6d       	retmi	0

8000f4f8 <__avr32_f64_to_s32>:
8000f4f8:	f6 0c 15 01 	lsl	r12,r11,0x1
8000f4fc:	b5 9c       	lsr	r12,0x15
8000f4fe:	e0 2c 03 ff 	sub	r12,1023
8000f502:	5e 3d       	retlo	0
8000f504:	f8 0c 11 1f 	rsub	r12,r12,31
8000f508:	16 99       	mov	r9,r11
8000f50a:	ab 7b       	lsl	r11,0xb
8000f50c:	bf bb       	sbr	r11,0x1f
8000f50e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f512:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f516:	a1 79       	lsl	r9,0x1
8000f518:	5e 2b       	reths	r11
8000f51a:	5c 3b       	neg	r11
8000f51c:	5e fb       	retal	r11

8000f51e <__avr32_u32_to_f64>:
8000f51e:	f8 cb 00 00 	sub	r11,r12,0
8000f522:	30 0c       	mov	r12,0
8000f524:	c0 38       	rjmp	8000f52a <__avr32_s32_to_f64+0x4>

8000f526 <__avr32_s32_to_f64>:
8000f526:	18 9b       	mov	r11,r12
8000f528:	5c 4b       	abs	r11
8000f52a:	30 0a       	mov	r10,0
8000f52c:	5e 0b       	reteq	r11
8000f52e:	d4 01       	pushm	lr
8000f530:	e0 69 04 1e 	mov	r9,1054
8000f534:	f6 08 12 00 	clz	r8,r11
8000f538:	c1 70       	breq	8000f566 <__avr32_s32_to_f64+0x40>
8000f53a:	c0 c3       	brcs	8000f552 <__avr32_s32_to_f64+0x2c>
8000f53c:	f0 0e 11 20 	rsub	lr,r8,32
8000f540:	f6 08 09 4b 	lsl	r11,r11,r8
8000f544:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f548:	1c 4b       	or	r11,lr
8000f54a:	f4 08 09 4a 	lsl	r10,r10,r8
8000f54e:	10 19       	sub	r9,r8
8000f550:	c0 b8       	rjmp	8000f566 <__avr32_s32_to_f64+0x40>
8000f552:	f4 08 12 00 	clz	r8,r10
8000f556:	f9 b8 03 00 	movlo	r8,0
8000f55a:	f7 b8 02 e0 	subhs	r8,-32
8000f55e:	f4 08 09 4b 	lsl	r11,r10,r8
8000f562:	30 0a       	mov	r10,0
8000f564:	10 19       	sub	r9,r8
8000f566:	58 09       	cp.w	r9,0
8000f568:	e0 89 00 30 	brgt	8000f5c8 <__avr32_s32_to_f64+0xa2>
8000f56c:	5c 39       	neg	r9
8000f56e:	2f f9       	sub	r9,-1
8000f570:	e0 49 00 36 	cp.w	r9,54
8000f574:	c0 43       	brcs	8000f57c <__avr32_s32_to_f64+0x56>
8000f576:	30 0b       	mov	r11,0
8000f578:	30 0a       	mov	r10,0
8000f57a:	c2 68       	rjmp	8000f5c6 <__avr32_s32_to_f64+0xa0>
8000f57c:	2f 69       	sub	r9,-10
8000f57e:	f2 08 11 20 	rsub	r8,r9,32
8000f582:	e0 49 00 20 	cp.w	r9,32
8000f586:	c0 b2       	brcc	8000f59c <__avr32_s32_to_f64+0x76>
8000f588:	f4 08 09 4e 	lsl	lr,r10,r8
8000f58c:	f6 08 09 48 	lsl	r8,r11,r8
8000f590:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f594:	f6 09 0a 4b 	lsr	r11,r11,r9
8000f598:	10 4b       	or	r11,r8
8000f59a:	c0 88       	rjmp	8000f5aa <__avr32_s32_to_f64+0x84>
8000f59c:	f6 08 09 4e 	lsl	lr,r11,r8
8000f5a0:	14 4e       	or	lr,r10
8000f5a2:	16 9a       	mov	r10,r11
8000f5a4:	30 0b       	mov	r11,0
8000f5a6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000f5aa:	ed ba 00 00 	bld	r10,0x0
8000f5ae:	c0 92       	brcc	8000f5c0 <__avr32_s32_to_f64+0x9a>
8000f5b0:	1c 7e       	tst	lr,lr
8000f5b2:	c0 41       	brne	8000f5ba <__avr32_s32_to_f64+0x94>
8000f5b4:	ed ba 00 01 	bld	r10,0x1
8000f5b8:	c0 42       	brcc	8000f5c0 <__avr32_s32_to_f64+0x9a>
8000f5ba:	2f fa       	sub	r10,-1
8000f5bc:	f7 bb 02 ff 	subhs	r11,-1
8000f5c0:	5c fc       	rol	r12
8000f5c2:	5d 0b       	ror	r11
8000f5c4:	5d 0a       	ror	r10
8000f5c6:	d8 02       	popm	pc
8000f5c8:	e0 68 03 ff 	mov	r8,1023
8000f5cc:	ed ba 00 0b 	bld	r10,0xb
8000f5d0:	f7 b8 00 ff 	subeq	r8,-1
8000f5d4:	10 0a       	add	r10,r8
8000f5d6:	5c 0b       	acr	r11
8000f5d8:	f7 b9 03 fe 	sublo	r9,-2
8000f5dc:	e0 49 07 ff 	cp.w	r9,2047
8000f5e0:	c0 55       	brlt	8000f5ea <__avr32_s32_to_f64+0xc4>
8000f5e2:	30 0a       	mov	r10,0
8000f5e4:	fc 1b ff e0 	movh	r11,0xffe0
8000f5e8:	c0 c8       	rjmp	8000f600 <__floatsidf_return_op1>
8000f5ea:	ed bb 00 1f 	bld	r11,0x1f
8000f5ee:	f7 b9 01 01 	subne	r9,1
8000f5f2:	ab 9a       	lsr	r10,0xb
8000f5f4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f5f8:	a1 7b       	lsl	r11,0x1
8000f5fa:	ab 9b       	lsr	r11,0xb
8000f5fc:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000f600 <__floatsidf_return_op1>:
8000f600:	a1 7c       	lsl	r12,0x1
8000f602:	5d 0b       	ror	r11
8000f604:	d8 02       	popm	pc

8000f606 <__avr32_f64_cmp_eq>:
8000f606:	10 3a       	cp.w	r10,r8
8000f608:	f2 0b 13 00 	cpc	r11,r9
8000f60c:	c0 80       	breq	8000f61c <__avr32_f64_cmp_eq+0x16>
8000f60e:	a1 7b       	lsl	r11,0x1
8000f610:	a1 79       	lsl	r9,0x1
8000f612:	14 4b       	or	r11,r10
8000f614:	12 4b       	or	r11,r9
8000f616:	10 4b       	or	r11,r8
8000f618:	5e 0f       	reteq	1
8000f61a:	5e fd       	retal	0
8000f61c:	a1 7b       	lsl	r11,0x1
8000f61e:	fc 1c ff e0 	movh	r12,0xffe0
8000f622:	58 0a       	cp.w	r10,0
8000f624:	f8 0b 13 00 	cpc	r11,r12
8000f628:	5e 8f       	retls	1
8000f62a:	5e fd       	retal	0

8000f62c <__avr32_f64_cmp_ge>:
8000f62c:	1a de       	st.w	--sp,lr
8000f62e:	1a d7       	st.w	--sp,r7
8000f630:	a1 7b       	lsl	r11,0x1
8000f632:	5f 3c       	srlo	r12
8000f634:	a1 79       	lsl	r9,0x1
8000f636:	5f 37       	srlo	r7
8000f638:	5c fc       	rol	r12
8000f63a:	fc 1e ff e0 	movh	lr,0xffe0
8000f63e:	58 0a       	cp.w	r10,0
8000f640:	fc 0b 13 00 	cpc	r11,lr
8000f644:	e0 8b 00 1d 	brhi	8000f67e <__avr32_f64_cmp_ge+0x52>
8000f648:	58 08       	cp.w	r8,0
8000f64a:	fc 09 13 00 	cpc	r9,lr
8000f64e:	e0 8b 00 18 	brhi	8000f67e <__avr32_f64_cmp_ge+0x52>
8000f652:	58 0b       	cp.w	r11,0
8000f654:	f5 ba 00 00 	subfeq	r10,0
8000f658:	c1 50       	breq	8000f682 <__avr32_f64_cmp_ge+0x56>
8000f65a:	1b 07       	ld.w	r7,sp++
8000f65c:	1b 0e       	ld.w	lr,sp++
8000f65e:	58 3c       	cp.w	r12,3
8000f660:	c0 a0       	breq	8000f674 <__avr32_f64_cmp_ge+0x48>
8000f662:	58 1c       	cp.w	r12,1
8000f664:	c0 33       	brcs	8000f66a <__avr32_f64_cmp_ge+0x3e>
8000f666:	5e 0f       	reteq	1
8000f668:	5e 1d       	retne	0
8000f66a:	10 3a       	cp.w	r10,r8
8000f66c:	f2 0b 13 00 	cpc	r11,r9
8000f670:	5e 2f       	reths	1
8000f672:	5e 3d       	retlo	0
8000f674:	14 38       	cp.w	r8,r10
8000f676:	f6 09 13 00 	cpc	r9,r11
8000f67a:	5e 2f       	reths	1
8000f67c:	5e 3d       	retlo	0
8000f67e:	1b 07       	ld.w	r7,sp++
8000f680:	d8 0a       	popm	pc,r12=0
8000f682:	58 17       	cp.w	r7,1
8000f684:	5f 0c       	sreq	r12
8000f686:	58 09       	cp.w	r9,0
8000f688:	f5 b8 00 00 	subfeq	r8,0
8000f68c:	1b 07       	ld.w	r7,sp++
8000f68e:	1b 0e       	ld.w	lr,sp++
8000f690:	5e 0f       	reteq	1
8000f692:	5e fc       	retal	r12

8000f694 <__avr32_f64_cmp_lt>:
8000f694:	1a de       	st.w	--sp,lr
8000f696:	1a d7       	st.w	--sp,r7
8000f698:	a1 7b       	lsl	r11,0x1
8000f69a:	5f 3c       	srlo	r12
8000f69c:	a1 79       	lsl	r9,0x1
8000f69e:	5f 37       	srlo	r7
8000f6a0:	5c fc       	rol	r12
8000f6a2:	fc 1e ff e0 	movh	lr,0xffe0
8000f6a6:	58 0a       	cp.w	r10,0
8000f6a8:	fc 0b 13 00 	cpc	r11,lr
8000f6ac:	e0 8b 00 1d 	brhi	8000f6e6 <__avr32_f64_cmp_lt+0x52>
8000f6b0:	58 08       	cp.w	r8,0
8000f6b2:	fc 09 13 00 	cpc	r9,lr
8000f6b6:	e0 8b 00 18 	brhi	8000f6e6 <__avr32_f64_cmp_lt+0x52>
8000f6ba:	58 0b       	cp.w	r11,0
8000f6bc:	f5 ba 00 00 	subfeq	r10,0
8000f6c0:	c1 50       	breq	8000f6ea <__avr32_f64_cmp_lt+0x56>
8000f6c2:	1b 07       	ld.w	r7,sp++
8000f6c4:	1b 0e       	ld.w	lr,sp++
8000f6c6:	58 3c       	cp.w	r12,3
8000f6c8:	c0 a0       	breq	8000f6dc <__avr32_f64_cmp_lt+0x48>
8000f6ca:	58 1c       	cp.w	r12,1
8000f6cc:	c0 33       	brcs	8000f6d2 <__avr32_f64_cmp_lt+0x3e>
8000f6ce:	5e 0d       	reteq	0
8000f6d0:	5e 1f       	retne	1
8000f6d2:	10 3a       	cp.w	r10,r8
8000f6d4:	f2 0b 13 00 	cpc	r11,r9
8000f6d8:	5e 2d       	reths	0
8000f6da:	5e 3f       	retlo	1
8000f6dc:	14 38       	cp.w	r8,r10
8000f6de:	f6 09 13 00 	cpc	r9,r11
8000f6e2:	5e 2d       	reths	0
8000f6e4:	5e 3f       	retlo	1
8000f6e6:	1b 07       	ld.w	r7,sp++
8000f6e8:	d8 0a       	popm	pc,r12=0
8000f6ea:	58 17       	cp.w	r7,1
8000f6ec:	5f 1c       	srne	r12
8000f6ee:	58 09       	cp.w	r9,0
8000f6f0:	f5 b8 00 00 	subfeq	r8,0
8000f6f4:	1b 07       	ld.w	r7,sp++
8000f6f6:	1b 0e       	ld.w	lr,sp++
8000f6f8:	5e 0d       	reteq	0
8000f6fa:	5e fc       	retal	r12

8000f6fc <__avr32_f64_div>:
8000f6fc:	eb cd 40 ff 	pushm	r0-r7,lr
8000f700:	f7 e9 20 0e 	eor	lr,r11,r9
8000f704:	f6 07 16 14 	lsr	r7,r11,0x14
8000f708:	a9 7b       	lsl	r11,0x9
8000f70a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000f70e:	a9 7a       	lsl	r10,0x9
8000f710:	bd bb       	sbr	r11,0x1d
8000f712:	e4 1b 3f ff 	andh	r11,0x3fff
8000f716:	ab d7       	cbr	r7,0xb
8000f718:	e0 80 00 cc 	breq	8000f8b0 <__avr32_f64_div_round_subnormal+0x54>
8000f71c:	e0 47 07 ff 	cp.w	r7,2047
8000f720:	e0 84 00 b5 	brge	8000f88a <__avr32_f64_div_round_subnormal+0x2e>
8000f724:	f2 06 16 14 	lsr	r6,r9,0x14
8000f728:	a9 79       	lsl	r9,0x9
8000f72a:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000f72e:	a9 78       	lsl	r8,0x9
8000f730:	bd b9       	sbr	r9,0x1d
8000f732:	e4 19 3f ff 	andh	r9,0x3fff
8000f736:	ab d6       	cbr	r6,0xb
8000f738:	e0 80 00 e2 	breq	8000f8fc <__avr32_f64_div_round_subnormal+0xa0>
8000f73c:	e0 46 07 ff 	cp.w	r6,2047
8000f740:	e0 84 00 b2 	brge	8000f8a4 <__avr32_f64_div_round_subnormal+0x48>
8000f744:	0c 17       	sub	r7,r6
8000f746:	fe 37 fc 01 	sub	r7,-1023
8000f74a:	fc 1c 80 00 	movh	r12,0x8000
8000f74e:	f8 03 16 01 	lsr	r3,r12,0x1
8000f752:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000f756:	5c d4       	com	r4
8000f758:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000f75c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f760:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f764:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f768:	ea 03 15 02 	lsl	r3,r5,0x2
8000f76c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f770:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f774:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f778:	ea 03 15 02 	lsl	r3,r5,0x2
8000f77c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f780:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000f784:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f788:	ea 03 15 02 	lsl	r3,r5,0x2
8000f78c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f790:	e4 09 07 40 	macu.d	r0,r2,r9
8000f794:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f798:	02 04       	add	r4,r1
8000f79a:	5c 05       	acr	r5
8000f79c:	a3 65       	lsl	r5,0x2
8000f79e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f7a2:	a3 64       	lsl	r4,0x2
8000f7a4:	5c 34       	neg	r4
8000f7a6:	f8 05 01 45 	sbc	r5,r12,r5
8000f7aa:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f7ae:	e4 05 07 40 	macu.d	r0,r2,r5
8000f7b2:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f7b6:	02 04       	add	r4,r1
8000f7b8:	5c 05       	acr	r5
8000f7ba:	ea 03 15 02 	lsl	r3,r5,0x2
8000f7be:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f7c2:	e8 02 15 02 	lsl	r2,r4,0x2
8000f7c6:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f7ca:	e4 09 07 40 	macu.d	r0,r2,r9
8000f7ce:	e6 09 06 44 	mulu.d	r4,r3,r9
8000f7d2:	02 04       	add	r4,r1
8000f7d4:	5c 05       	acr	r5
8000f7d6:	a3 65       	lsl	r5,0x2
8000f7d8:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000f7dc:	a3 64       	lsl	r4,0x2
8000f7de:	5c 34       	neg	r4
8000f7e0:	f8 05 01 45 	sbc	r5,r12,r5
8000f7e4:	e6 04 06 40 	mulu.d	r0,r3,r4
8000f7e8:	e4 05 07 40 	macu.d	r0,r2,r5
8000f7ec:	e6 05 06 44 	mulu.d	r4,r3,r5
8000f7f0:	02 04       	add	r4,r1
8000f7f2:	5c 05       	acr	r5
8000f7f4:	ea 03 15 02 	lsl	r3,r5,0x2
8000f7f8:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000f7fc:	e8 02 15 02 	lsl	r2,r4,0x2
8000f800:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000f804:	e4 0b 07 40 	macu.d	r0,r2,r11
8000f808:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000f80c:	02 02       	add	r2,r1
8000f80e:	5c 03       	acr	r3
8000f810:	ed b3 00 1c 	bld	r3,0x1c
8000f814:	c0 90       	breq	8000f826 <__avr32_f64_div+0x12a>
8000f816:	a1 72       	lsl	r2,0x1
8000f818:	5c f3       	rol	r3
8000f81a:	20 17       	sub	r7,1
8000f81c:	a3 9a       	lsr	r10,0x3
8000f81e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000f822:	a3 9b       	lsr	r11,0x3
8000f824:	c0 58       	rjmp	8000f82e <__avr32_f64_div+0x132>
8000f826:	a5 8a       	lsr	r10,0x4
8000f828:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000f82c:	a5 8b       	lsr	r11,0x4
8000f82e:	58 07       	cp.w	r7,0
8000f830:	e0 8a 00 8b 	brle	8000f946 <__avr32_f64_div_res_subnormal>
8000f834:	e0 12 ff 00 	andl	r2,0xff00
8000f838:	e8 12 00 80 	orl	r2,0x80
8000f83c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000f840:	e4 09 07 40 	macu.d	r0,r2,r9
8000f844:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f848:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f84c:	00 05       	add	r5,r0
8000f84e:	f0 01 00 48 	adc	r8,r8,r1
8000f852:	5c 09       	acr	r9
8000f854:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f858:	58 04       	cp.w	r4,0
8000f85a:	5c 25       	cpc	r5

8000f85c <__avr32_f64_div_round_subnormal>:
8000f85c:	f4 08 13 00 	cpc	r8,r10
8000f860:	f6 09 13 00 	cpc	r9,r11
8000f864:	5f 36       	srlo	r6
8000f866:	f8 06 17 00 	moveq	r6,r12
8000f86a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000f86e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000f872:	e6 0b 16 08 	lsr	r11,r3,0x8
8000f876:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f87a:	ed be 00 1f 	bld	lr,0x1f
8000f87e:	ef bb 00 1f 	bst	r11,0x1f
8000f882:	0c 0a       	add	r10,r6
8000f884:	5c 0b       	acr	r11
8000f886:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f88a:	e4 1b 00 0f 	andh	r11,0xf
8000f88e:	14 4b       	or	r11,r10
8000f890:	e0 81 00 a7 	brne	8000f9de <__avr32_f64_div_res_subnormal+0x98>
8000f894:	f2 06 16 14 	lsr	r6,r9,0x14
8000f898:	ab d6       	cbr	r6,0xb
8000f89a:	e0 46 07 ff 	cp.w	r6,2047
8000f89e:	e0 81 00 a4 	brne	8000f9e6 <__avr32_f64_div_res_subnormal+0xa0>
8000f8a2:	c9 e8       	rjmp	8000f9de <__avr32_f64_div_res_subnormal+0x98>
8000f8a4:	e4 19 00 0f 	andh	r9,0xf
8000f8a8:	10 49       	or	r9,r8
8000f8aa:	e0 81 00 9a 	brne	8000f9de <__avr32_f64_div_res_subnormal+0x98>
8000f8ae:	c9 28       	rjmp	8000f9d2 <__avr32_f64_div_res_subnormal+0x8c>
8000f8b0:	a3 7b       	lsl	r11,0x3
8000f8b2:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000f8b6:	a3 7a       	lsl	r10,0x3
8000f8b8:	f5 eb 10 04 	or	r4,r10,r11
8000f8bc:	e0 80 00 a0 	breq	8000f9fc <__avr32_f64_div_op1_zero>
8000f8c0:	f6 04 12 00 	clz	r4,r11
8000f8c4:	c1 70       	breq	8000f8f2 <__avr32_f64_div_round_subnormal+0x96>
8000f8c6:	c0 c3       	brcs	8000f8de <__avr32_f64_div_round_subnormal+0x82>
8000f8c8:	e8 05 11 20 	rsub	r5,r4,32
8000f8cc:	f6 04 09 4b 	lsl	r11,r11,r4
8000f8d0:	f4 05 0a 45 	lsr	r5,r10,r5
8000f8d4:	0a 4b       	or	r11,r5
8000f8d6:	f4 04 09 4a 	lsl	r10,r10,r4
8000f8da:	08 17       	sub	r7,r4
8000f8dc:	c0 b8       	rjmp	8000f8f2 <__avr32_f64_div_round_subnormal+0x96>
8000f8de:	f4 04 12 00 	clz	r4,r10
8000f8e2:	f9 b4 03 00 	movlo	r4,0
8000f8e6:	f7 b4 02 e0 	subhs	r4,-32
8000f8ea:	f4 04 09 4b 	lsl	r11,r10,r4
8000f8ee:	30 0a       	mov	r10,0
8000f8f0:	08 17       	sub	r7,r4
8000f8f2:	a3 8a       	lsr	r10,0x2
8000f8f4:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000f8f8:	a3 8b       	lsr	r11,0x2
8000f8fa:	c1 1b       	rjmp	8000f71c <__avr32_f64_div+0x20>
8000f8fc:	a3 79       	lsl	r9,0x3
8000f8fe:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000f902:	a3 78       	lsl	r8,0x3
8000f904:	f3 e8 10 04 	or	r4,r9,r8
8000f908:	c6 f0       	breq	8000f9e6 <__avr32_f64_div_res_subnormal+0xa0>
8000f90a:	f2 04 12 00 	clz	r4,r9
8000f90e:	c1 70       	breq	8000f93c <__avr32_f64_div_round_subnormal+0xe0>
8000f910:	c0 c3       	brcs	8000f928 <__avr32_f64_div_round_subnormal+0xcc>
8000f912:	e8 05 11 20 	rsub	r5,r4,32
8000f916:	f2 04 09 49 	lsl	r9,r9,r4
8000f91a:	f0 05 0a 45 	lsr	r5,r8,r5
8000f91e:	0a 49       	or	r9,r5
8000f920:	f0 04 09 48 	lsl	r8,r8,r4
8000f924:	08 16       	sub	r6,r4
8000f926:	c0 b8       	rjmp	8000f93c <__avr32_f64_div_round_subnormal+0xe0>
8000f928:	f0 04 12 00 	clz	r4,r8
8000f92c:	f9 b4 03 00 	movlo	r4,0
8000f930:	f7 b4 02 e0 	subhs	r4,-32
8000f934:	f0 04 09 49 	lsl	r9,r8,r4
8000f938:	30 08       	mov	r8,0
8000f93a:	08 16       	sub	r6,r4
8000f93c:	a3 88       	lsr	r8,0x2
8000f93e:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000f942:	a3 89       	lsr	r9,0x2
8000f944:	cf ca       	rjmp	8000f73c <__avr32_f64_div+0x40>

8000f946 <__avr32_f64_div_res_subnormal>:
8000f946:	5c 37       	neg	r7
8000f948:	2f f7       	sub	r7,-1
8000f94a:	f1 b7 04 c0 	satu	r7,0x6
8000f94e:	e0 47 00 20 	cp.w	r7,32
8000f952:	c1 54       	brge	8000f97c <__avr32_f64_div_res_subnormal+0x36>
8000f954:	ee 06 11 20 	rsub	r6,r7,32
8000f958:	e4 07 0a 42 	lsr	r2,r2,r7
8000f95c:	e6 06 09 4c 	lsl	r12,r3,r6
8000f960:	18 42       	or	r2,r12
8000f962:	e6 07 0a 43 	lsr	r3,r3,r7
8000f966:	f4 06 09 41 	lsl	r1,r10,r6
8000f96a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f96e:	f6 06 09 4c 	lsl	r12,r11,r6
8000f972:	18 4a       	or	r10,r12
8000f974:	f6 07 0a 4b 	lsr	r11,r11,r7
8000f978:	30 00       	mov	r0,0
8000f97a:	c1 58       	rjmp	8000f9a4 <__avr32_f64_div_res_subnormal+0x5e>
8000f97c:	ee 06 11 20 	rsub	r6,r7,32
8000f980:	f9 b0 00 00 	moveq	r0,0
8000f984:	f9 bc 00 00 	moveq	r12,0
8000f988:	c0 50       	breq	8000f992 <__avr32_f64_div_res_subnormal+0x4c>
8000f98a:	f4 06 09 40 	lsl	r0,r10,r6
8000f98e:	f6 06 09 4c 	lsl	r12,r11,r6
8000f992:	e6 07 0a 42 	lsr	r2,r3,r7
8000f996:	30 03       	mov	r3,0
8000f998:	f4 07 0a 41 	lsr	r1,r10,r7
8000f99c:	18 41       	or	r1,r12
8000f99e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000f9a2:	30 0b       	mov	r11,0
8000f9a4:	e0 12 ff 00 	andl	r2,0xff00
8000f9a8:	e8 12 00 80 	orl	r2,0x80
8000f9ac:	e6 08 06 46 	mulu.d	r6,r3,r8
8000f9b0:	e4 09 07 46 	macu.d	r6,r2,r9
8000f9b4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000f9b8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000f9bc:	0c 05       	add	r5,r6
8000f9be:	f0 07 00 48 	adc	r8,r8,r7
8000f9c2:	5c 09       	acr	r9
8000f9c4:	30 07       	mov	r7,0
8000f9c6:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000f9ca:	00 34       	cp.w	r4,r0
8000f9cc:	e2 05 13 00 	cpc	r5,r1
8000f9d0:	c4 6b       	rjmp	8000f85c <__avr32_f64_div_round_subnormal>
8000f9d2:	1c 9b       	mov	r11,lr
8000f9d4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f9d8:	30 0a       	mov	r10,0
8000f9da:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f9de:	3f fb       	mov	r11,-1
8000f9e0:	30 0a       	mov	r10,0
8000f9e2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000f9e6:	f5 eb 10 04 	or	r4,r10,r11
8000f9ea:	c0 90       	breq	8000f9fc <__avr32_f64_div_op1_zero>
8000f9ec:	1c 9b       	mov	r11,lr
8000f9ee:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f9f2:	ea 1b 7f f0 	orh	r11,0x7ff0
8000f9f6:	30 0a       	mov	r10,0
8000f9f8:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000f9fc <__avr32_f64_div_op1_zero>:
8000f9fc:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000fa00:	ce f0       	breq	8000f9de <__avr32_f64_div_res_subnormal+0x98>
8000fa02:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000fa06:	e0 44 07 ff 	cp.w	r4,2047
8000fa0a:	ce 41       	brne	8000f9d2 <__avr32_f64_div_res_subnormal+0x8c>
8000fa0c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000fa10:	ce 10       	breq	8000f9d2 <__avr32_f64_div_res_subnormal+0x8c>
8000fa12:	ce 6b       	rjmp	8000f9de <__avr32_f64_div_res_subnormal+0x98>

8000fa14 <__avr32_udiv64>:
8000fa14:	d4 31       	pushm	r0-r7,lr
8000fa16:	1a 97       	mov	r7,sp
8000fa18:	20 3d       	sub	sp,12
8000fa1a:	10 9c       	mov	r12,r8
8000fa1c:	12 9e       	mov	lr,r9
8000fa1e:	14 93       	mov	r3,r10
8000fa20:	58 09       	cp.w	r9,0
8000fa22:	e0 81 00 bd 	brne	8000fb9c <__avr32_udiv64+0x188>
8000fa26:	16 38       	cp.w	r8,r11
8000fa28:	e0 88 00 40 	brls	8000faa8 <__avr32_udiv64+0x94>
8000fa2c:	f0 08 12 00 	clz	r8,r8
8000fa30:	c0 d0       	breq	8000fa4a <__avr32_udiv64+0x36>
8000fa32:	f6 08 09 4b 	lsl	r11,r11,r8
8000fa36:	f0 09 11 20 	rsub	r9,r8,32
8000fa3a:	f8 08 09 4c 	lsl	r12,r12,r8
8000fa3e:	f4 09 0a 49 	lsr	r9,r10,r9
8000fa42:	f4 08 09 43 	lsl	r3,r10,r8
8000fa46:	f3 eb 10 0b 	or	r11,r9,r11
8000fa4a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000fa4e:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000fa52:	f6 0e 0d 00 	divu	r0,r11,lr
8000fa56:	e6 0b 16 10 	lsr	r11,r3,0x10
8000fa5a:	00 99       	mov	r9,r0
8000fa5c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fa60:	e0 0a 02 48 	mul	r8,r0,r10
8000fa64:	10 3b       	cp.w	r11,r8
8000fa66:	c0 a2       	brcc	8000fa7a <__avr32_udiv64+0x66>
8000fa68:	20 19       	sub	r9,1
8000fa6a:	18 0b       	add	r11,r12
8000fa6c:	18 3b       	cp.w	r11,r12
8000fa6e:	c0 63       	brcs	8000fa7a <__avr32_udiv64+0x66>
8000fa70:	10 3b       	cp.w	r11,r8
8000fa72:	f7 b9 03 01 	sublo	r9,1
8000fa76:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fa7a:	f6 08 01 01 	sub	r1,r11,r8
8000fa7e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000fa82:	e2 0e 0d 00 	divu	r0,r1,lr
8000fa86:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fa8a:	00 98       	mov	r8,r0
8000fa8c:	e0 0a 02 4a 	mul	r10,r0,r10
8000fa90:	14 33       	cp.w	r3,r10
8000fa92:	c0 82       	brcc	8000faa2 <__avr32_udiv64+0x8e>
8000fa94:	20 18       	sub	r8,1
8000fa96:	18 03       	add	r3,r12
8000fa98:	18 33       	cp.w	r3,r12
8000fa9a:	c0 43       	brcs	8000faa2 <__avr32_udiv64+0x8e>
8000fa9c:	14 33       	cp.w	r3,r10
8000fa9e:	f7 b8 03 01 	sublo	r8,1
8000faa2:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000faa6:	cd f8       	rjmp	8000fc64 <__avr32_udiv64+0x250>
8000faa8:	58 08       	cp.w	r8,0
8000faaa:	c0 51       	brne	8000fab4 <__avr32_udiv64+0xa0>
8000faac:	30 19       	mov	r9,1
8000faae:	f2 08 0d 08 	divu	r8,r9,r8
8000fab2:	10 9c       	mov	r12,r8
8000fab4:	f8 06 12 00 	clz	r6,r12
8000fab8:	c0 41       	brne	8000fac0 <__avr32_udiv64+0xac>
8000faba:	18 1b       	sub	r11,r12
8000fabc:	30 19       	mov	r9,1
8000fabe:	c4 08       	rjmp	8000fb3e <__avr32_udiv64+0x12a>
8000fac0:	ec 01 11 20 	rsub	r1,r6,32
8000fac4:	f4 01 0a 49 	lsr	r9,r10,r1
8000fac8:	f8 06 09 4c 	lsl	r12,r12,r6
8000facc:	f6 06 09 48 	lsl	r8,r11,r6
8000fad0:	f6 01 0a 41 	lsr	r1,r11,r1
8000fad4:	f3 e8 10 08 	or	r8,r9,r8
8000fad8:	f8 03 16 10 	lsr	r3,r12,0x10
8000fadc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000fae0:	e2 03 0d 00 	divu	r0,r1,r3
8000fae4:	f0 0b 16 10 	lsr	r11,r8,0x10
8000fae8:	00 9e       	mov	lr,r0
8000faea:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000faee:	e0 05 02 49 	mul	r9,r0,r5
8000faf2:	12 3b       	cp.w	r11,r9
8000faf4:	c0 a2       	brcc	8000fb08 <__avr32_udiv64+0xf4>
8000faf6:	20 1e       	sub	lr,1
8000faf8:	18 0b       	add	r11,r12
8000fafa:	18 3b       	cp.w	r11,r12
8000fafc:	c0 63       	brcs	8000fb08 <__avr32_udiv64+0xf4>
8000fafe:	12 3b       	cp.w	r11,r9
8000fb00:	f7 be 03 01 	sublo	lr,1
8000fb04:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fb08:	12 1b       	sub	r11,r9
8000fb0a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000fb0e:	f6 03 0d 02 	divu	r2,r11,r3
8000fb12:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000fb16:	04 99       	mov	r9,r2
8000fb18:	e4 05 02 4b 	mul	r11,r2,r5
8000fb1c:	16 38       	cp.w	r8,r11
8000fb1e:	c0 a2       	brcc	8000fb32 <__avr32_udiv64+0x11e>
8000fb20:	20 19       	sub	r9,1
8000fb22:	18 08       	add	r8,r12
8000fb24:	18 38       	cp.w	r8,r12
8000fb26:	c0 63       	brcs	8000fb32 <__avr32_udiv64+0x11e>
8000fb28:	16 38       	cp.w	r8,r11
8000fb2a:	f7 b9 03 01 	sublo	r9,1
8000fb2e:	f1 dc e3 08 	addcs	r8,r8,r12
8000fb32:	f4 06 09 43 	lsl	r3,r10,r6
8000fb36:	f0 0b 01 0b 	sub	r11,r8,r11
8000fb3a:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000fb3e:	f8 06 16 10 	lsr	r6,r12,0x10
8000fb42:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000fb46:	f6 06 0d 00 	divu	r0,r11,r6
8000fb4a:	e6 0b 16 10 	lsr	r11,r3,0x10
8000fb4e:	00 9a       	mov	r10,r0
8000fb50:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fb54:	e0 0e 02 48 	mul	r8,r0,lr
8000fb58:	10 3b       	cp.w	r11,r8
8000fb5a:	c0 a2       	brcc	8000fb6e <__avr32_udiv64+0x15a>
8000fb5c:	20 1a       	sub	r10,1
8000fb5e:	18 0b       	add	r11,r12
8000fb60:	18 3b       	cp.w	r11,r12
8000fb62:	c0 63       	brcs	8000fb6e <__avr32_udiv64+0x15a>
8000fb64:	10 3b       	cp.w	r11,r8
8000fb66:	f7 ba 03 01 	sublo	r10,1
8000fb6a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fb6e:	f6 08 01 01 	sub	r1,r11,r8
8000fb72:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000fb76:	e2 06 0d 00 	divu	r0,r1,r6
8000fb7a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000fb7e:	00 98       	mov	r8,r0
8000fb80:	e0 0e 02 4b 	mul	r11,r0,lr
8000fb84:	16 33       	cp.w	r3,r11
8000fb86:	c0 82       	brcc	8000fb96 <__avr32_udiv64+0x182>
8000fb88:	20 18       	sub	r8,1
8000fb8a:	18 03       	add	r3,r12
8000fb8c:	18 33       	cp.w	r3,r12
8000fb8e:	c0 43       	brcs	8000fb96 <__avr32_udiv64+0x182>
8000fb90:	16 33       	cp.w	r3,r11
8000fb92:	f7 b8 03 01 	sublo	r8,1
8000fb96:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000fb9a:	c6 98       	rjmp	8000fc6c <__avr32_udiv64+0x258>
8000fb9c:	16 39       	cp.w	r9,r11
8000fb9e:	e0 8b 00 65 	brhi	8000fc68 <__avr32_udiv64+0x254>
8000fba2:	f2 09 12 00 	clz	r9,r9
8000fba6:	c0 b1       	brne	8000fbbc <__avr32_udiv64+0x1a8>
8000fba8:	10 3a       	cp.w	r10,r8
8000fbaa:	5f 2a       	srhs	r10
8000fbac:	1c 3b       	cp.w	r11,lr
8000fbae:	5f b8       	srhi	r8
8000fbb0:	10 4a       	or	r10,r8
8000fbb2:	f2 0a 18 00 	cp.b	r10,r9
8000fbb6:	c5 90       	breq	8000fc68 <__avr32_udiv64+0x254>
8000fbb8:	30 18       	mov	r8,1
8000fbba:	c5 98       	rjmp	8000fc6c <__avr32_udiv64+0x258>
8000fbbc:	f0 09 09 46 	lsl	r6,r8,r9
8000fbc0:	f2 03 11 20 	rsub	r3,r9,32
8000fbc4:	fc 09 09 4e 	lsl	lr,lr,r9
8000fbc8:	f0 03 0a 48 	lsr	r8,r8,r3
8000fbcc:	f6 09 09 4c 	lsl	r12,r11,r9
8000fbd0:	f4 03 0a 42 	lsr	r2,r10,r3
8000fbd4:	ef 46 ff f4 	st.w	r7[-12],r6
8000fbd8:	f6 03 0a 43 	lsr	r3,r11,r3
8000fbdc:	18 42       	or	r2,r12
8000fbde:	f1 ee 10 0c 	or	r12,r8,lr
8000fbe2:	f8 01 16 10 	lsr	r1,r12,0x10
8000fbe6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000fbea:	e6 01 0d 04 	divu	r4,r3,r1
8000fbee:	e4 03 16 10 	lsr	r3,r2,0x10
8000fbf2:	08 9e       	mov	lr,r4
8000fbf4:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000fbf8:	e8 06 02 48 	mul	r8,r4,r6
8000fbfc:	10 33       	cp.w	r3,r8
8000fbfe:	c0 a2       	brcc	8000fc12 <__avr32_udiv64+0x1fe>
8000fc00:	20 1e       	sub	lr,1
8000fc02:	18 03       	add	r3,r12
8000fc04:	18 33       	cp.w	r3,r12
8000fc06:	c0 63       	brcs	8000fc12 <__avr32_udiv64+0x1fe>
8000fc08:	10 33       	cp.w	r3,r8
8000fc0a:	f7 be 03 01 	sublo	lr,1
8000fc0e:	e7 dc e3 03 	addcs	r3,r3,r12
8000fc12:	10 13       	sub	r3,r8
8000fc14:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000fc18:	e6 01 0d 00 	divu	r0,r3,r1
8000fc1c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000fc20:	00 98       	mov	r8,r0
8000fc22:	e0 06 02 46 	mul	r6,r0,r6
8000fc26:	0c 3b       	cp.w	r11,r6
8000fc28:	c0 a2       	brcc	8000fc3c <__avr32_udiv64+0x228>
8000fc2a:	20 18       	sub	r8,1
8000fc2c:	18 0b       	add	r11,r12
8000fc2e:	18 3b       	cp.w	r11,r12
8000fc30:	c0 63       	brcs	8000fc3c <__avr32_udiv64+0x228>
8000fc32:	0c 3b       	cp.w	r11,r6
8000fc34:	f7 dc e3 0b 	addcs	r11,r11,r12
8000fc38:	f7 b8 03 01 	sublo	r8,1
8000fc3c:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000fc40:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000fc44:	0c 1b       	sub	r11,r6
8000fc46:	f0 04 06 42 	mulu.d	r2,r8,r4
8000fc4a:	06 95       	mov	r5,r3
8000fc4c:	16 35       	cp.w	r5,r11
8000fc4e:	e0 8b 00 0a 	brhi	8000fc62 <__avr32_udiv64+0x24e>
8000fc52:	5f 0b       	sreq	r11
8000fc54:	f4 09 09 49 	lsl	r9,r10,r9
8000fc58:	12 32       	cp.w	r2,r9
8000fc5a:	5f b9       	srhi	r9
8000fc5c:	f7 e9 00 09 	and	r9,r11,r9
8000fc60:	c0 60       	breq	8000fc6c <__avr32_udiv64+0x258>
8000fc62:	20 18       	sub	r8,1
8000fc64:	30 09       	mov	r9,0
8000fc66:	c0 38       	rjmp	8000fc6c <__avr32_udiv64+0x258>
8000fc68:	30 09       	mov	r9,0
8000fc6a:	12 98       	mov	r8,r9
8000fc6c:	10 9a       	mov	r10,r8
8000fc6e:	12 93       	mov	r3,r9
8000fc70:	10 92       	mov	r2,r8
8000fc72:	12 9b       	mov	r11,r9
8000fc74:	2f dd       	sub	sp,-12
8000fc76:	d8 32       	popm	r0-r7,pc

8000fc78 <__avr32_umod64>:
8000fc78:	d4 31       	pushm	r0-r7,lr
8000fc7a:	1a 97       	mov	r7,sp
8000fc7c:	20 3d       	sub	sp,12
8000fc7e:	10 9c       	mov	r12,r8
8000fc80:	12 95       	mov	r5,r9
8000fc82:	14 9e       	mov	lr,r10
8000fc84:	16 91       	mov	r1,r11
8000fc86:	16 96       	mov	r6,r11
8000fc88:	58 09       	cp.w	r9,0
8000fc8a:	e0 81 00 81 	brne	8000fd8c <__avr32_umod64+0x114>
8000fc8e:	16 38       	cp.w	r8,r11
8000fc90:	e0 88 00 12 	brls	8000fcb4 <__avr32_umod64+0x3c>
8000fc94:	f0 08 12 00 	clz	r8,r8
8000fc98:	c4 e0       	breq	8000fd34 <__avr32_umod64+0xbc>
8000fc9a:	f6 08 09 46 	lsl	r6,r11,r8
8000fc9e:	f8 08 09 4c 	lsl	r12,r12,r8
8000fca2:	f0 0b 11 20 	rsub	r11,r8,32
8000fca6:	f4 08 09 4e 	lsl	lr,r10,r8
8000fcaa:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000fcae:	f7 e6 10 06 	or	r6,r11,r6
8000fcb2:	c4 18       	rjmp	8000fd34 <__avr32_umod64+0xbc>
8000fcb4:	58 08       	cp.w	r8,0
8000fcb6:	c0 51       	brne	8000fcc0 <__avr32_umod64+0x48>
8000fcb8:	30 19       	mov	r9,1
8000fcba:	f2 08 0d 08 	divu	r8,r9,r8
8000fcbe:	10 9c       	mov	r12,r8
8000fcc0:	f8 08 12 00 	clz	r8,r12
8000fcc4:	c0 31       	brne	8000fcca <__avr32_umod64+0x52>
8000fcc6:	18 16       	sub	r6,r12
8000fcc8:	c3 68       	rjmp	8000fd34 <__avr32_umod64+0xbc>
8000fcca:	f0 03 11 20 	rsub	r3,r8,32
8000fcce:	f4 03 0a 4b 	lsr	r11,r10,r3
8000fcd2:	f8 08 09 4c 	lsl	r12,r12,r8
8000fcd6:	ec 08 09 49 	lsl	r9,r6,r8
8000fcda:	ec 03 0a 43 	lsr	r3,r6,r3
8000fcde:	f7 e9 10 09 	or	r9,r11,r9
8000fce2:	f8 05 16 10 	lsr	r5,r12,0x10
8000fce6:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000fcea:	e6 05 0d 02 	divu	r2,r3,r5
8000fcee:	f2 0e 16 10 	lsr	lr,r9,0x10
8000fcf2:	ec 02 02 4b 	mul	r11,r6,r2
8000fcf6:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000fcfa:	16 3e       	cp.w	lr,r11
8000fcfc:	c0 72       	brcc	8000fd0a <__avr32_umod64+0x92>
8000fcfe:	18 0e       	add	lr,r12
8000fd00:	18 3e       	cp.w	lr,r12
8000fd02:	c0 43       	brcs	8000fd0a <__avr32_umod64+0x92>
8000fd04:	16 3e       	cp.w	lr,r11
8000fd06:	fd dc e3 0e 	addcs	lr,lr,r12
8000fd0a:	fc 0b 01 03 	sub	r3,lr,r11
8000fd0e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000fd12:	e6 05 0d 02 	divu	r2,r3,r5
8000fd16:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000fd1a:	a5 36       	mul	r6,r2
8000fd1c:	0c 39       	cp.w	r9,r6
8000fd1e:	c0 72       	brcc	8000fd2c <__avr32_umod64+0xb4>
8000fd20:	18 09       	add	r9,r12
8000fd22:	18 39       	cp.w	r9,r12
8000fd24:	c0 43       	brcs	8000fd2c <__avr32_umod64+0xb4>
8000fd26:	0c 39       	cp.w	r9,r6
8000fd28:	f3 dc e3 09 	addcs	r9,r9,r12
8000fd2c:	f2 06 01 06 	sub	r6,r9,r6
8000fd30:	f4 08 09 4e 	lsl	lr,r10,r8
8000fd34:	f8 0a 16 10 	lsr	r10,r12,0x10
8000fd38:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000fd3c:	ec 0a 0d 02 	divu	r2,r6,r10
8000fd40:	fc 09 16 10 	lsr	r9,lr,0x10
8000fd44:	ea 02 02 4b 	mul	r11,r5,r2
8000fd48:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000fd4c:	16 39       	cp.w	r9,r11
8000fd4e:	c0 72       	brcc	8000fd5c <__avr32_umod64+0xe4>
8000fd50:	18 09       	add	r9,r12
8000fd52:	18 39       	cp.w	r9,r12
8000fd54:	c0 43       	brcs	8000fd5c <__avr32_umod64+0xe4>
8000fd56:	16 39       	cp.w	r9,r11
8000fd58:	f3 dc e3 09 	addcs	r9,r9,r12
8000fd5c:	f2 0b 01 0b 	sub	r11,r9,r11
8000fd60:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000fd64:	f6 0a 0d 0a 	divu	r10,r11,r10
8000fd68:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000fd6c:	ea 0a 02 4a 	mul	r10,r5,r10
8000fd70:	14 3e       	cp.w	lr,r10
8000fd72:	c0 72       	brcc	8000fd80 <__avr32_umod64+0x108>
8000fd74:	18 0e       	add	lr,r12
8000fd76:	18 3e       	cp.w	lr,r12
8000fd78:	c0 43       	brcs	8000fd80 <__avr32_umod64+0x108>
8000fd7a:	14 3e       	cp.w	lr,r10
8000fd7c:	fd dc e3 0e 	addcs	lr,lr,r12
8000fd80:	fc 0a 01 0a 	sub	r10,lr,r10
8000fd84:	30 0b       	mov	r11,0
8000fd86:	f4 08 0a 4a 	lsr	r10,r10,r8
8000fd8a:	c7 b8       	rjmp	8000fe80 <__avr32_umod64+0x208>
8000fd8c:	16 39       	cp.w	r9,r11
8000fd8e:	e0 8b 00 79 	brhi	8000fe80 <__avr32_umod64+0x208>
8000fd92:	f2 09 12 00 	clz	r9,r9
8000fd96:	c1 21       	brne	8000fdba <__avr32_umod64+0x142>
8000fd98:	10 3a       	cp.w	r10,r8
8000fd9a:	5f 2b       	srhs	r11
8000fd9c:	0a 31       	cp.w	r1,r5
8000fd9e:	5f ba       	srhi	r10
8000fda0:	f7 ea 10 0a 	or	r10,r11,r10
8000fda4:	f2 0a 18 00 	cp.b	r10,r9
8000fda8:	c0 60       	breq	8000fdb4 <__avr32_umod64+0x13c>
8000fdaa:	fc 08 01 0c 	sub	r12,lr,r8
8000fdae:	e2 05 01 46 	sbc	r6,r1,r5
8000fdb2:	18 9e       	mov	lr,r12
8000fdb4:	0c 9b       	mov	r11,r6
8000fdb6:	1c 9a       	mov	r10,lr
8000fdb8:	c6 48       	rjmp	8000fe80 <__avr32_umod64+0x208>
8000fdba:	ea 09 09 4c 	lsl	r12,r5,r9
8000fdbe:	f2 06 11 20 	rsub	r6,r9,32
8000fdc2:	f6 09 09 4b 	lsl	r11,r11,r9
8000fdc6:	f0 09 09 42 	lsl	r2,r8,r9
8000fdca:	ef 46 ff f4 	st.w	r7[-12],r6
8000fdce:	f0 06 0a 48 	lsr	r8,r8,r6
8000fdd2:	18 48       	or	r8,r12
8000fdd4:	e2 06 0a 4c 	lsr	r12,r1,r6
8000fdd8:	f4 09 09 43 	lsl	r3,r10,r9
8000fddc:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000fde0:	f4 06 0a 4a 	lsr	r10,r10,r6
8000fde4:	16 4a       	or	r10,r11
8000fde6:	f0 0b 16 10 	lsr	r11,r8,0x10
8000fdea:	f8 0b 0d 04 	divu	r4,r12,r11
8000fdee:	f4 0c 16 10 	lsr	r12,r10,0x10
8000fdf2:	08 91       	mov	r1,r4
8000fdf4:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000fdf8:	e8 0e 02 46 	mul	r6,r4,lr
8000fdfc:	0c 3c       	cp.w	r12,r6
8000fdfe:	c0 a2       	brcc	8000fe12 <__avr32_umod64+0x19a>
8000fe00:	20 11       	sub	r1,1
8000fe02:	10 0c       	add	r12,r8
8000fe04:	10 3c       	cp.w	r12,r8
8000fe06:	c0 63       	brcs	8000fe12 <__avr32_umod64+0x19a>
8000fe08:	0c 3c       	cp.w	r12,r6
8000fe0a:	f7 b1 03 01 	sublo	r1,1
8000fe0e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000fe12:	0c 1c       	sub	r12,r6
8000fe14:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000fe18:	f8 0b 0d 04 	divu	r4,r12,r11
8000fe1c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000fe20:	08 96       	mov	r6,r4
8000fe22:	e8 0e 02 4e 	mul	lr,r4,lr
8000fe26:	1c 3b       	cp.w	r11,lr
8000fe28:	c0 a2       	brcc	8000fe3c <__avr32_umod64+0x1c4>
8000fe2a:	20 16       	sub	r6,1
8000fe2c:	10 0b       	add	r11,r8
8000fe2e:	10 3b       	cp.w	r11,r8
8000fe30:	c0 63       	brcs	8000fe3c <__avr32_umod64+0x1c4>
8000fe32:	1c 3b       	cp.w	r11,lr
8000fe34:	f7 b6 03 01 	sublo	r6,1
8000fe38:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000fe3c:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000fe40:	1c 1b       	sub	r11,lr
8000fe42:	e2 02 06 40 	mulu.d	r0,r1,r2
8000fe46:	00 9e       	mov	lr,r0
8000fe48:	02 9c       	mov	r12,r1
8000fe4a:	16 3c       	cp.w	r12,r11
8000fe4c:	e0 8b 00 08 	brhi	8000fe5c <__avr32_umod64+0x1e4>
8000fe50:	5f 06       	sreq	r6
8000fe52:	06 30       	cp.w	r0,r3
8000fe54:	5f ba       	srhi	r10
8000fe56:	ed ea 00 0a 	and	r10,r6,r10
8000fe5a:	c0 60       	breq	8000fe66 <__avr32_umod64+0x1ee>
8000fe5c:	fc 02 01 04 	sub	r4,lr,r2
8000fe60:	f8 08 01 4c 	sbc	r12,r12,r8
8000fe64:	08 9e       	mov	lr,r4
8000fe66:	e6 0e 01 0a 	sub	r10,r3,lr
8000fe6a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000fe6e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000fe72:	f8 09 0a 4b 	lsr	r11,r12,r9
8000fe76:	f4 09 0a 4a 	lsr	r10,r10,r9
8000fe7a:	f8 01 09 4c 	lsl	r12,r12,r1
8000fe7e:	18 4a       	or	r10,r12
8000fe80:	2f dd       	sub	sp,-12
8000fe82:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80010000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
80010000:	c0 08       	rjmp	80010000 <_evba>
	...

80010004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
80010004:	c0 08       	rjmp	80010004 <_handle_TLB_Multiple_Hit>
	...

80010008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
80010008:	c0 08       	rjmp	80010008 <_handle_Bus_Error_Data_Fetch>
	...

8001000c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8001000c:	c0 08       	rjmp	8001000c <_handle_Bus_Error_Instruction_Fetch>
	...

80010010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
80010010:	c0 08       	rjmp	80010010 <_handle_NMI>
	...

80010014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
80010014:	c0 08       	rjmp	80010014 <_handle_Instruction_Address>
	...

80010018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
80010018:	c0 08       	rjmp	80010018 <_handle_ITLB_Protection>
	...

8001001c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8001001c:	c0 08       	rjmp	8001001c <_handle_Breakpoint>
	...

80010020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
80010020:	c0 08       	rjmp	80010020 <_handle_Illegal_Opcode>
	...

80010024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
80010024:	c0 08       	rjmp	80010024 <_handle_Unimplemented_Instruction>
	...

80010028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
80010028:	c0 08       	rjmp	80010028 <_handle_Privilege_Violation>
	...

8001002c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8001002c:	c0 08       	rjmp	8001002c <_handle_Floating_Point>
	...

80010030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
80010030:	c0 08       	rjmp	80010030 <_handle_Coprocessor_Absent>
	...

80010034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
80010034:	c0 08       	rjmp	80010034 <_handle_Data_Address_Read>
	...

80010038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
80010038:	c0 08       	rjmp	80010038 <_handle_Data_Address_Write>
	...

8001003c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8001003c:	c0 08       	rjmp	8001003c <_handle_DTLB_Protection_Read>
	...

80010040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
80010040:	c0 08       	rjmp	80010040 <_handle_DTLB_Protection_Write>
	...

80010044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
80010044:	c0 08       	rjmp	80010044 <_handle_DTLB_Modified>
	...

80010050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
80010050:	c0 08       	rjmp	80010050 <_handle_ITLB_Miss>
	...

80010060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
80010060:	c0 08       	rjmp	80010060 <_handle_DTLB_Miss_Read>
	...

80010070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
80010070:	c0 08       	rjmp	80010070 <_handle_DTLB_Miss_Write>
	...

80010100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80010100:	fe cf 73 50 	sub	pc,pc,29520

80010104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80010104:	30 0c       	mov	r12,0
80010106:	fe b0 ae 21 	rcall	80005d48 <_get_interrupt_handler>
8001010a:	58 0c       	cp.w	r12,0
8001010c:	f8 0f 17 10 	movne	pc,r12
80010110:	d6 03       	rete

80010112 <_int1>:
80010112:	30 1c       	mov	r12,1
80010114:	fe b0 ae 1a 	rcall	80005d48 <_get_interrupt_handler>
80010118:	58 0c       	cp.w	r12,0
8001011a:	f8 0f 17 10 	movne	pc,r12
8001011e:	d6 03       	rete

80010120 <_int2>:
80010120:	30 2c       	mov	r12,2
80010122:	fe b0 ae 13 	rcall	80005d48 <_get_interrupt_handler>
80010126:	58 0c       	cp.w	r12,0
80010128:	f8 0f 17 10 	movne	pc,r12
8001012c:	d6 03       	rete

8001012e <_int3>:
8001012e:	30 3c       	mov	r12,3
80010130:	fe b0 ae 0c 	rcall	80005d48 <_get_interrupt_handler>
80010134:	58 0c       	cp.w	r12,0
80010136:	f8 0f 17 10 	movne	pc,r12
8001013a:	d6 03       	rete

8001013c <ipr_val>:
8001013c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8001014c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001015c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001016c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001017c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001018c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001019c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800101fc:	d7 03 d7 03                                         ....
