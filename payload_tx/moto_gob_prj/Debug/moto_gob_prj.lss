
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002010  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000e4ec  80002010  80002010  00002410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80010600  80010600  00010a00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000099c  80010800  80010800  00010c00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8001119c  8001119c  0001159c  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a4c  00000008  800111a0  00011808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  00000a54  80011bec  00012254  2**0
                  ALLOC
  9 .bss          000048d0  00000a58  00000a58  00000000  2**2
                  ALLOC
 10 .heap         00011cd8  00005328  00005328  00000000  2**0
                  ALLOC
 11 .comment      00000030  00000000  00000000  00012254  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 00001330  00000000  00000000  00012288  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 00002743  00000000  00000000  000135b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   000297e9  00000000  00000000  00015cfb  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 0000638d  00000000  00000000  0003f4e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   00015cfe  00000000  00000000  00045871  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  000034a0  00000000  00000000  0005b570  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    000072ff  00000000  00000000  0005ea10  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0000b050  00000000  00000000  00065d0f  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_macinfo 0150c593  00000000  00000000  00070d5f  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 22 .debug_ranges 00001370  00000000  00000000  0157d2f8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	48 1f       	lddpc	pc,80000004 <_start+0x4>
80000002:	d7 03       	nop
80000004:	80 00       	ld.sh	r0,r0[0x0]
80000006:	ab b4       	sbr	r4,0xb

80000008 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000008:	e0 8f 10 00 	bral	80002008 <program_start>
	...

80002008 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002008:	fe ff 00 04 	ld.w	pc,pc[4]
8000200c:	80 00       	ld.sh	r0,r0[0x0]
8000200e:	ab b4       	sbr	r4,0xb

Disassembly of section .text:

80002010 <DeviceInitializationStatus_brdcst_func-0x71c>:
80002010:	54 6f       	stdsp	sp[0x118],pc
80002012:	6e 65       	ld.w	r5,r7[0x18]
80002014:	20 4f       	sub	pc,4
80002016:	4b 00       	lddpc	r0,800020d4 <program_start+0xcc>
80002018:	54 6f       	stdsp	sp[0x118],pc
8000201a:	6e 65       	ld.w	r5,r7[0x18]
8000201c:	20 65       	sub	r5,6
8000201e:	72 72       	ld.w	r2,r9[0x1c]
80002020:	6f 72       	ld.w	r2,r7[0x5c]
80002022:	00 00       	add	r0,r0
80002024:	0a 0d       	add	sp,r5
80002026:	20 44       	sub	r4,4
80002028:	63 6d       	ld.w	sp,r1[0x58]
8000202a:	2d 45       	sub	r5,-44
8000202c:	6e 74       	ld.w	r4,r7[0x1c]
8000202e:	65 72       	ld.w	r2,r2[0x5c]
80002030:	20 4f       	sub	pc,4
80002032:	4b 20       	lddpc	r0,800020f8 <program_start+0xf0>
80002034:	0a 0d       	add	sp,r5
80002036:	00 00       	add	r0,r0
80002038:	0a 0d       	add	sp,r5
8000203a:	20 44       	sub	r4,4
8000203c:	63 6d       	ld.w	sp,r1[0x58]
8000203e:	2d 45       	sub	r5,-44
80002040:	78 69       	ld.w	r9,r12[0x18]
80002042:	74 20       	ld.w	r0,r10[0x8]
80002044:	4f 4b       	lddpc	r11,80002214 <program_start+0x20c>
80002046:	20 0a       	sub	r10,0
80002048:	0d 00       	ld.w	r0,r6++
8000204a:	00 00       	add	r0,r0
8000204c:	0a 0d       	add	sp,r5
8000204e:	20 44       	sub	r4,4
80002050:	63 6d       	ld.w	sp,r1[0x58]
80002052:	2d 52       	sub	r2,-43
80002054:	65 76       	ld.w	r6,r2[0x5c]
80002056:	6f 6b       	ld.w	r11,r7[0x58]
80002058:	65 20       	ld.w	r0,r2[0x48]
8000205a:	0a 0d       	add	sp,r5
8000205c:	00 00       	add	r0,r0
8000205e:	00 00       	add	r0,r0
80002060:	64 63       	ld.w	r3,r2[0x18]
80002062:	6d 20       	ld.w	r0,r6[0x48]
80002064:	4f 4b       	lddpc	r11,80002234 <program_start+0x22c>
80002066:	2d 6d       	sub	sp,-168
80002068:	6f 25       	ld.w	r5,r7[0x48]
8000206a:	58 00       	cp.w	r0,0
8000206c:	64 63       	ld.w	r3,r2[0x18]
8000206e:	6d 20       	ld.w	r0,r6[0x48]
80002070:	65 72       	ld.w	r2,r2[0x5c]
80002072:	72 6f       	ld.w	pc,r9[0x18]
80002074:	72 00       	ld.w	r0,r9[0x0]
80002076:	00 00       	add	r0,r0
80002078:	0a 0d       	add	sp,r5
8000207a:	20 44       	sub	r4,4
8000207c:	63 6d       	ld.w	sp,r1[0x58]
8000207e:	5f 62       	srmi	r2
80002080:	72 64       	ld.w	r4,r9[0x18]
80002082:	63 73       	ld.w	r3,r1[0x5c]
80002084:	74 20       	ld.w	r0,r10[0x8]
80002086:	0a 0d       	add	sp,r5
80002088:	00 00       	add	r0,r0
8000208a:	00 00       	add	r0,r0
8000208c:	0a 0d       	add	sp,r5
8000208e:	20 46       	sub	r6,4
80002090:	75 6e       	ld.w	lr,r10[0x58]
80002092:	63 74       	ld.w	r4,r1[0x5c]
80002094:	69 6f       	ld.w	pc,r4[0x58]
80002096:	6e 3a       	ld.w	r10,r7[0xc]
80002098:	20 25       	sub	r5,2
8000209a:	78 20       	ld.w	r0,r12[0x8]
8000209c:	0a 0d       	add	sp,r5
8000209e:	20 00       	sub	r0,0
800020a0:	0a 0d       	add	sp,r5
800020a2:	20 43       	sub	r3,4
800020a4:	6f 6e       	ld.w	lr,r7[0x58]
800020a6:	74 72       	ld.w	r2,r10[0x1c]
800020a8:	6f 6c       	ld.w	r12,r7[0x58]
800020aa:	54 79       	stdsp	sp[0x11c],r9
800020ac:	70 65       	ld.w	r5,r8[0x18]
800020ae:	3a 20       	mov	r0,-94
800020b0:	25 78       	sub	r8,87
800020b2:	20 0a       	sub	r10,0
800020b4:	0d 20       	ld.uh	r0,r6++
800020b6:	00 00       	add	r0,r0
800020b8:	0a 0d       	add	sp,r5
800020ba:	20 43       	sub	r3,4
800020bc:	6f 6e       	ld.w	lr,r7[0x58]
800020be:	74 72       	ld.w	r2,r10[0x1c]
800020c0:	6f 6c       	ld.w	r12,r7[0x58]
800020c2:	54 79       	stdsp	sp[0x11c],r9
800020c4:	70 65       	ld.w	r5,r8[0x18]
800020c6:	53 69       	stdsp	sp[0xd8],r9
800020c8:	7a 65       	ld.w	r5,sp[0x18]
800020ca:	3a 20       	mov	r0,-94
800020cc:	25 78       	sub	r8,87
800020ce:	20 0a       	sub	r10,0
800020d0:	0d 20       	ld.uh	r0,r6++
800020d2:	00 00       	add	r0,r0
800020d4:	0a 0d       	add	sp,r5
800020d6:	20 4d       	sub	sp,16
800020d8:	69 63       	ld.w	r3,r4[0x58]
800020da:	5f 72       	srpl	r2
800020dc:	65 70       	ld.w	r0,r2[0x5c]
800020de:	6c 79       	ld.w	r9,r6[0x1c]
800020e0:	20 0a       	sub	r10,0
800020e2:	0d 00       	ld.w	r0,r6++
800020e4:	0a 0d       	add	sp,r5
800020e6:	20 4d       	sub	sp,16
800020e8:	69 63       	ld.w	r3,r4[0x58]
800020ea:	5f 63       	srmi	r3
800020ec:	6c 6f       	ld.w	pc,r6[0x18]
800020ee:	73 65       	ld.w	r5,r9[0x58]
800020f0:	5f 6f       	srmi	pc
800020f2:	6b 20       	ld.w	r0,r5[0x48]
800020f4:	0a 0d       	add	sp,r5
800020f6:	20 00       	sub	r0,0
800020f8:	0a 0d       	add	sp,r5
800020fa:	20 4d       	sub	sp,16
800020fc:	69 63       	ld.w	r3,r4[0x58]
800020fe:	5f 74       	srpl	r4
80002100:	79 70       	ld.w	r0,r12[0x5c]
80002102:	65 3a       	ld.w	r10,r2[0x4c]
80002104:	20 25       	sub	r5,2
80002106:	78 20       	ld.w	r0,r12[0x8]
80002108:	0a 0d       	add	sp,r5
8000210a:	20 00       	sub	r0,0
8000210c:	0a 0d       	add	sp,r5
8000210e:	20 53       	sub	r3,5
80002110:	69 67       	ld.w	r7,r4[0x58]
80002112:	6e 61       	ld.w	r1,r7[0x18]
80002114:	6c 69       	ld.w	r9,r6[0x18]
80002116:	6e 67       	ld.w	r7,r7[0x18]
80002118:	5f 74       	srpl	r4
8000211a:	79 70       	ld.w	r0,r12[0x5c]
8000211c:	65 3a       	ld.w	r10,r2[0x4c]
8000211e:	20 25       	sub	r5,2
80002120:	78 20       	ld.w	r0,r12[0x8]
80002122:	0a 0d       	add	sp,r5
80002124:	20 00       	sub	r0,0
80002126:	00 00       	add	r0,r0
80002128:	0a 0d       	add	sp,r5
8000212a:	20 4d       	sub	sp,16
8000212c:	69 63       	ld.w	r3,r4[0x58]
8000212e:	5f 73       	srpl	r3
80002130:	74 61       	ld.w	r1,r10[0x18]
80002132:	74 65       	ld.w	r5,r10[0x18]
80002134:	3a 20       	mov	r0,-94
80002136:	25 78       	sub	r8,87
80002138:	20 0a       	sub	r10,0
8000213a:	0d 20       	ld.uh	r0,r6++
8000213c:	00 00       	add	r0,r0
8000213e:	00 00       	add	r0,r0
80002140:	0a 0d       	add	sp,r5
80002142:	20 47       	sub	r7,4
80002144:	61 69       	ld.w	r9,r0[0x58]
80002146:	6e 5f       	ld.w	pc,r7[0x14]
80002148:	6f 66       	ld.w	r6,r7[0x58]
8000214a:	66 73       	ld.w	r3,r3[0x1c]
8000214c:	65 74       	ld.w	r4,r2[0x5c]
8000214e:	3a 20       	mov	r0,-94
80002150:	25 78       	sub	r8,87
80002152:	20 0a       	sub	r10,0
80002154:	0d 20       	ld.uh	r0,r6++
80002156:	00 00       	add	r0,r0
80002158:	0a 0d       	add	sp,r5
8000215a:	20 4d       	sub	sp,16
8000215c:	69 63       	ld.w	r3,r4[0x58]
8000215e:	5f 66       	srmi	r6
80002160:	75 6e       	ld.w	lr,r10[0x58]
80002162:	63 74       	ld.w	r4,r1[0x5c]
80002164:	69 6f       	ld.w	pc,r4[0x58]
80002166:	6e 3a       	ld.w	r10,r7[0xc]
80002168:	20 25       	sub	r5,2
8000216a:	78 20       	ld.w	r0,r12[0x8]
8000216c:	0a 0d       	add	sp,r5
8000216e:	20 00       	sub	r0,0
80002170:	0a 0d       	add	sp,r5
80002172:	20 4d       	sub	sp,16
80002174:	69 63       	ld.w	r3,r4[0x58]
80002176:	20 65       	sub	r5,6
80002178:	72 72       	ld.w	r2,r9[0x1c]
8000217a:	6f 72       	ld.w	r2,r7[0x5c]
8000217c:	20 0a       	sub	r10,0
8000217e:	0d 00       	ld.w	r0,r6++
80002180:	0a 0d       	add	sp,r5
80002182:	20 4d       	sub	sp,16
80002184:	69 63       	ld.w	r3,r4[0x58]
80002186:	5f 44       	srge	r4
80002188:	69 73       	ld.w	r3,r4[0x5c]
8000218a:	61 62       	ld.w	r2,r0[0x58]
8000218c:	6c 65       	ld.w	r5,r6[0x18]
8000218e:	64 20       	ld.w	r0,r2[0x8]
80002190:	0a 0d       	add	sp,r5
80002192:	00 00       	add	r0,r0
80002194:	0a 0d       	add	sp,r5
80002196:	20 4d       	sub	sp,16
80002198:	69 63       	ld.w	r3,r4[0x58]
8000219a:	5f 45       	srge	r5
8000219c:	6e 61       	ld.w	r1,r7[0x18]
8000219e:	62 6c       	ld.w	r12,r1[0x18]
800021a0:	65 64       	ld.w	r4,r2[0x58]
800021a2:	20 0a       	sub	r10,0
800021a4:	0d 00       	ld.w	r0,r6++
800021a6:	00 00       	add	r0,r0
800021a8:	73 70       	ld.w	r0,r9[0x5c]
800021aa:	6b 20       	ld.w	r0,r5[0x48]
800021ac:	4f 4b       	lddpc	r11,8000237c <program_start+0x374>
800021ae:	20 2d       	sub	sp,8
800021b0:	73 74       	ld.w	r4,r9[0x5c]
800021b2:	25 32       	sub	r2,83
800021b4:	78 00       	ld.w	r0,r12[0x0]
800021b6:	00 00       	add	r0,r0
800021b8:	73 70       	ld.w	r0,r9[0x5c]
800021ba:	6b 20       	ld.w	r0,r5[0x48]
800021bc:	65 72       	ld.w	r2,r2[0x5c]
800021be:	72 6f       	ld.w	pc,r9[0x18]
800021c0:	72 00       	ld.w	r0,r9[0x0]
800021c2:	00 00       	add	r0,r0
800021c4:	73 70       	ld.w	r0,r9[0x5c]
800021c6:	6b 5f       	ld.w	pc,r5[0x54]
800021c8:	73 5f       	ld.w	pc,r9[0x54]
800021ca:	63 6c       	ld.w	r12,r1[0x58]
800021cc:	6f 73       	ld.w	r3,r7[0x5c]
800021ce:	65 20       	ld.w	r0,r2[0x48]
800021d0:	00 00       	add	r0,r0
800021d2:	00 00       	add	r0,r0
800021d4:	73 70       	ld.w	r0,r9[0x5c]
800021d6:	6b 5f       	ld.w	pc,r5[0x54]
800021d8:	73 5f       	ld.w	pc,r9[0x54]
800021da:	6f 70       	ld.w	r0,r7[0x5c]
800021dc:	65 6e       	ld.w	lr,r2[0x58]
800021de:	20 00       	sub	r0,0
800021e0:	0a 0d       	add	sp,r5
800021e2:	20 45       	sub	r5,4
800021e4:	6e 61       	ld.w	r1,r7[0x18]
800021e6:	62 6c       	ld.w	r12,r1[0x18]
800021e8:	65 5f       	ld.w	pc,r2[0x54]
800021ea:	49 41       	lddpc	r1,80002238 <program_start+0x230>
800021ec:	20 4f       	sub	pc,4
800021ee:	4b 20       	lddpc	r0,800022b4 <program_start+0x2ac>
800021f0:	0a 0d       	add	sp,r5
800021f2:	00 00       	add	r0,r0
800021f4:	0a 0d       	add	sp,r5
800021f6:	20 41       	sub	r1,4
800021f8:	74 74       	ld.w	r4,r10[0x1c]
800021fa:	65 6e       	ld.w	lr,r2[0x58]
800021fc:	75 61       	ld.w	r1,r10[0x58]
800021fe:	74 6f       	ld.w	pc,r10[0x18]
80002200:	72 5f       	ld.w	pc,r9[0x14]
80002202:	4e 75       	lddpc	r5,8000239c <program_start+0x394>
80002204:	6d 62       	ld.w	r2,r6[0x58]
80002206:	65 72       	ld.w	r2,r2[0x5c]
80002208:	3a 20       	mov	r0,-94
8000220a:	25 78       	sub	r8,87
8000220c:	20 0a       	sub	r10,0
8000220e:	0d 00       	ld.w	r0,r6++
80002210:	0a 0d       	add	sp,r5
80002212:	20 56       	sub	r6,5
80002214:	6f 6c       	ld.w	r12,r7[0x58]
80002216:	75 6d       	ld.w	sp,r10[0x58]
80002218:	65 43       	ld.w	r3,r2[0x50]
8000221a:	6f 6e       	ld.w	lr,r7[0x58]
8000221c:	74 72       	ld.w	r2,r10[0x1c]
8000221e:	6f 6c       	ld.w	r12,r7[0x58]
80002220:	3a 20       	mov	r0,-94
80002222:	25 78       	sub	r8,87
80002224:	20 0a       	sub	r10,0
80002226:	0d 00       	ld.w	r0,r6++
80002228:	0a 0d       	add	sp,r5
8000222a:	20 45       	sub	r5,4
8000222c:	6e 61       	ld.w	r1,r7[0x18]
8000222e:	62 6c       	ld.w	r12,r1[0x18]
80002230:	65 5f       	ld.w	pc,r2[0x54]
80002232:	49 41       	lddpc	r1,80002280 <program_start+0x278>
80002234:	20 65       	sub	r5,6
80002236:	72 72       	ld.w	r2,r9[0x1c]
80002238:	6f 72       	ld.w	r2,r7[0x5c]
8000223a:	20 0a       	sub	r10,0
8000223c:	0d 00       	ld.w	r0,r6++
8000223e:	00 00       	add	r0,r0
80002240:	41 75       	lddsp	r5,sp[0x5c]
80002242:	64 69       	ld.w	r9,r2[0x18]
80002244:	6f 52       	ld.w	r2,r7[0x54]
80002246:	6f 75       	ld.w	r5,r7[0x5c]
80002248:	74 69       	ld.w	r9,r10[0x18]
8000224a:	6e 67       	ld.w	r7,r7[0x18]
8000224c:	20 4f       	sub	pc,4
8000224e:	4b 00       	lddpc	r0,8000230c <program_start+0x304>
80002250:	41 75       	lddsp	r5,sp[0x5c]
80002252:	64 69       	ld.w	r9,r2[0x18]
80002254:	6f 52       	ld.w	r2,r7[0x54]
80002256:	6f 75       	ld.w	r5,r7[0x5c]
80002258:	74 69       	ld.w	r9,r10[0x18]
8000225a:	6e 67       	ld.w	r7,r7[0x18]
8000225c:	20 65       	sub	r5,6
8000225e:	72 72       	ld.w	r2,r9[0x1c]
80002260:	6f 72       	ld.w	r2,r7[0x5c]
80002262:	00 00       	add	r0,r0
80002264:	0a 0d       	add	sp,r5
80002266:	20 20       	sub	r0,2
80002268:	54 72       	stdsp	sp[0x11c],r2
8000226a:	61 6e       	ld.w	lr,r0[0x58]
8000226c:	73 6d       	ld.w	sp,r9[0x58]
8000226e:	69 74       	ld.w	r4,r4[0x5c]
80002270:	43 6f       	lddsp	pc,sp[0xd8]
80002272:	6e 74       	ld.w	r4,r7[0x1c]
80002274:	72 6f       	ld.w	pc,r9[0x18]
80002276:	6c 20       	ld.w	r0,r6[0x8]
80002278:	4f 4b       	lddpc	r11,80002448 <program_start+0x440>
8000227a:	20 0a       	sub	r10,0
8000227c:	0d 20       	ld.uh	r0,r6++
8000227e:	00 00       	add	r0,r0
80002280:	0a 0d       	add	sp,r5
80002282:	20 46       	sub	r6,4
80002284:	75 6e       	ld.w	lr,r10[0x58]
80002286:	63 74       	ld.w	r4,r1[0x5c]
80002288:	69 6f       	ld.w	pc,r4[0x58]
8000228a:	6e 3a       	ld.w	r10,r7[0xc]
8000228c:	20 25       	sub	r5,2
8000228e:	78 20       	ld.w	r0,r12[0x8]
80002290:	0a 0d       	add	sp,r5
80002292:	00 00       	add	r0,r0
80002294:	0a 0d       	add	sp,r5
80002296:	20 4d       	sub	sp,16
80002298:	6f 64       	ld.w	r4,r7[0x58]
8000229a:	65 20       	ld.w	r0,r2[0x48]
8000229c:	6f 66       	ld.w	r6,r7[0x58]
8000229e:	20 4f       	sub	pc,4
800022a0:	70 65       	ld.w	r5,r8[0x18]
800022a2:	72 61       	ld.w	r1,r9[0x18]
800022a4:	74 69       	ld.w	r9,r10[0x18]
800022a6:	6f 6e       	ld.w	lr,r7[0x58]
800022a8:	3a 20       	mov	r0,-94
800022aa:	25 78       	sub	r8,87
800022ac:	20 0a       	sub	r10,0
800022ae:	0d 00       	ld.w	r0,r6++
800022b0:	0a 0d       	add	sp,r5
800022b2:	20 53       	sub	r3,5
800022b4:	74 61       	ld.w	r1,r10[0x18]
800022b6:	74 65       	ld.w	r5,r10[0x18]
800022b8:	3a 20       	mov	r0,-94
800022ba:	25 78       	sub	r8,87
800022bc:	20 0a       	sub	r10,0
800022be:	0d 00       	ld.w	r0,r6++
800022c0:	54 72       	stdsp	sp[0x11c],r2
800022c2:	61 6e       	ld.w	lr,r0[0x58]
800022c4:	73 6d       	ld.w	sp,r9[0x58]
800022c6:	69 74       	ld.w	r4,r4[0x5c]
800022c8:	43 6f       	lddsp	pc,sp[0xd8]
800022ca:	6e 74       	ld.w	r4,r7[0x1c]
800022cc:	72 6f       	ld.w	pc,r9[0x18]
800022ce:	6c 20       	ld.w	r0,r6[0x8]
800022d0:	65 72       	ld.w	r2,r2[0x5c]
800022d2:	72 6f       	ld.w	pc,r9[0x18]
800022d4:	72 00       	ld.w	r0,r9[0x0]
800022d6:	00 00       	add	r0,r0
800022d8:	0a 0d       	add	sp,r5
800022da:	20 20       	sub	r0,2
800022dc:	53 74       	stdsp	sp[0xdc],r4
800022de:	61 6e       	ld.w	lr,r0[0x58]
800022e0:	64 62       	ld.w	r2,r2[0x18]
800022e2:	79 2d       	ld.w	sp,r12[0x48]
800022e4:	52 65       	stdsp	sp[0x98],r5
800022e6:	63 65       	ld.w	r5,r1[0x58]
800022e8:	69 76       	ld.w	r6,r4[0x5c]
800022ea:	65 20       	ld.w	r0,r2[0x48]
800022ec:	0a 0d       	add	sp,r5
800022ee:	20 00       	sub	r0,0
800022f0:	0a 0d       	add	sp,r5
800022f2:	20 20       	sub	r0,2
800022f4:	54 72       	stdsp	sp[0x11c],r2
800022f6:	61 6e       	ld.w	lr,r0[0x58]
800022f8:	73 6d       	ld.w	sp,r9[0x58]
800022fa:	69 74       	ld.w	r4,r4[0x5c]
800022fc:	20 0a       	sub	r10,0
800022fe:	0d 20       	ld.uh	r0,r6++
80002300:	00 00       	add	r0,r0
80002302:	00 00       	add	r0,r0
80002304:	0a 0d       	add	sp,r5
80002306:	20 20       	sub	r0,2
80002308:	43 61       	lddsp	r1,sp[0xd8]
8000230a:	6c 6c       	ld.w	r12,r6[0x18]
8000230c:	5f 73       	srpl	r3
8000230e:	74 61       	ld.w	r1,r10[0x18]
80002310:	74 65       	ld.w	r5,r10[0x18]
80002312:	3a 20       	mov	r0,-94
80002314:	25 78       	sub	r8,87
80002316:	20 0a       	sub	r10,0
80002318:	0d 20       	ld.uh	r0,r6++
8000231a:	00 00       	add	r0,r0
8000231c:	0a 0d       	add	sp,r5
8000231e:	20 44       	sub	r4,4
80002320:	41 54       	lddsp	r4,sp[0x54]
80002322:	41 72       	lddsp	r2,sp[0x5c]
80002324:	65 70       	ld.w	r0,r2[0x5c]
80002326:	20 4f       	sub	pc,4
80002328:	4b 20       	lddpc	r0,800023f0 <program_start+0x3e8>
8000232a:	0a 0d       	add	sp,r5
8000232c:	00 00       	add	r0,r0
8000232e:	00 00       	add	r0,r0
80002330:	0a 0d       	add	sp,r5
80002332:	20 52       	sub	r2,5
80002334:	65 73       	ld.w	r3,r2[0x5c]
80002336:	75 6c       	ld.w	r12,r10[0x58]
80002338:	74 3a       	ld.w	r10,r10[0xc]
8000233a:	20 20       	sub	r0,2
8000233c:	25 58       	sub	r8,85
8000233e:	20 0a       	sub	r10,0
80002340:	0d 00       	ld.w	r0,r6++
80002342:	00 00       	add	r0,r0
80002344:	0a 0d       	add	sp,r5
80002346:	20 44       	sub	r4,4
80002348:	41 54       	lddsp	r4,sp[0x54]
8000234a:	41 72       	lddsp	r2,sp[0x5c]
8000234c:	65 70       	ld.w	r0,r2[0x5c]
8000234e:	20 65       	sub	r5,6
80002350:	72 72       	ld.w	r2,r9[0x1c]
80002352:	6f 72       	ld.w	r2,r7[0x5c]
80002354:	20 0a       	sub	r10,0
80002356:	0d 00       	ld.w	r0,r6++
80002358:	0a 0d       	add	sp,r5
8000235a:	20 46       	sub	r6,4
8000235c:	75 6e       	ld.w	lr,r10[0x58]
8000235e:	63 3a       	ld.w	r10,r1[0x4c]
80002360:	20 20       	sub	r0,2
80002362:	25 58       	sub	r8,85
80002364:	20 0a       	sub	r10,0
80002366:	0d 00       	ld.w	r0,r6++
80002368:	0a 0d       	add	sp,r5
8000236a:	20 49       	sub	r9,4
8000236c:	44 3a       	lddsp	r10,sp[0x10c]
8000236e:	20 20       	sub	r0,2
80002370:	25 58       	sub	r8,85
80002372:	20 0a       	sub	r10,0
80002374:	0d 00       	ld.w	r0,r6++
80002376:	00 00       	add	r0,r0
80002378:	0a 0d       	add	sp,r5
8000237a:	20 43       	sub	r3,4
8000237c:	53 42       	stdsp	sp[0xd0],r2
8000237e:	4b 5f       	lddpc	pc,80002450 <program_start+0x448>
80002380:	52 58       	stdsp	sp[0x94],r8
80002382:	20 4f       	sub	pc,4
80002384:	4b 20       	lddpc	r0,8000244c <program_start+0x444>
80002386:	0a 0d       	add	sp,r5
80002388:	00 00       	add	r0,r0
8000238a:	00 00       	add	r0,r0
8000238c:	0a 0d       	add	sp,r5
8000238e:	20 53       	sub	r3,5
80002390:	65 73       	ld.w	r3,r2[0x5c]
80002392:	73 69       	ld.w	r9,r9[0x58]
80002394:	6f 6e       	ld.w	lr,r7[0x58]
80002396:	5f 49       	srge	r9
80002398:	44 3a       	lddsp	r10,sp[0x10c]
8000239a:	20 25       	sub	r5,2
8000239c:	78 20       	ld.w	r0,r12[0x8]
8000239e:	0a 0d       	add	sp,r5
800023a0:	00 00       	add	r0,r0
800023a2:	00 00       	add	r0,r0
800023a4:	0a 0d       	add	sp,r5
800023a6:	20 70       	sub	r0,7
800023a8:	61 79       	ld.w	r9,r0[0x5c]
800023aa:	6c 61       	ld.w	r1,r6[0x18]
800023ac:	6f 64       	ld.w	r4,r7[0x58]
800023ae:	5f 6c       	srmi	r12
800023b0:	65 6e       	ld.w	lr,r2[0x58]
800023b2:	67 74       	ld.w	r4,r3[0x5c]
800023b4:	68 3a       	ld.w	r10,r4[0xc]
800023b6:	20 25       	sub	r5,2
800023b8:	64 20       	ld.w	r0,r2[0x8]
800023ba:	0a 0d       	add	sp,r5
800023bc:	00 00       	add	r0,r0
800023be:	00 00       	add	r0,r0
800023c0:	0a 0d       	add	sp,r5
800023c2:	20 70       	sub	r0,7
800023c4:	61 79       	ld.w	r9,r0[0x5c]
800023c6:	6c 6f       	ld.w	pc,r6[0x18]
800023c8:	61 64       	ld.w	r4,r0[0x58]
800023ca:	5b 25       	cp.w	r5,-14
800023cc:	64 5d       	ld.w	sp,r2[0x14]
800023ce:	3a 20       	mov	r0,-94
800023d0:	25 58       	sub	r8,85
800023d2:	20 0a       	sub	r10,0
800023d4:	0d 00       	ld.w	r0,r6++
800023d6:	00 00       	add	r0,r0
800023d8:	0a 0d       	add	sp,r5
800023da:	20 53       	sub	r3,5
800023dc:	74 61       	ld.w	r1,r10[0x18]
800023de:	74 65       	ld.w	r5,r10[0x18]
800023e0:	3a 20       	mov	r0,-94
800023e2:	30 78       	mov	r8,7
800023e4:	20 25       	sub	r5,2
800023e6:	58 20       	cp.w	r0,2
800023e8:	0a 0d       	add	sp,r5
800023ea:	00 00       	add	r0,r0
800023ec:	0a 0d       	add	sp,r5
800023ee:	20 42       	sub	r2,4
800023f0:	75 74       	ld.w	r4,r10[0x5c]
800023f2:	74 6f       	ld.w	pc,r10[0x18]
800023f4:	6e 5f       	ld.w	pc,r7[0x14]
800023f6:	43 6f       	lddsp	pc,sp[0xd8]
800023f8:	6e 66       	ld.w	r6,r7[0x18]
800023fa:	69 67       	ld.w	r7,r4[0x58]
800023fc:	20 4f       	sub	pc,4
800023fe:	4b 20       	lddpc	r0,800024c4 <program_start+0x4bc>
80002400:	0a 0d       	add	sp,r5
80002402:	00 00       	add	r0,r0
80002404:	0a 0d       	add	sp,r5
80002406:	20 46       	sub	r6,4
80002408:	75 6e       	ld.w	lr,r10[0x58]
8000240a:	63 74       	ld.w	r4,r1[0x5c]
8000240c:	69 6f       	ld.w	pc,r4[0x58]
8000240e:	6e 3a       	ld.w	r10,r7[0xc]
80002410:	20 25       	sub	r5,2
80002412:	58 20       	cp.w	r0,2
80002414:	0a 0d       	add	sp,r5
80002416:	00 00       	add	r0,r0
80002418:	0a 0d       	add	sp,r5
8000241a:	20 42       	sub	r2,4
8000241c:	75 74       	ld.w	r4,r10[0x5c]
8000241e:	74 6f       	ld.w	pc,r10[0x18]
80002420:	6e 5f       	ld.w	pc,r7[0x14]
80002422:	52 65       	stdsp	sp[0x98],r5
80002424:	71 75       	ld.w	r5,r8[0x5c]
80002426:	65 73       	ld.w	r3,r2[0x5c]
80002428:	74 20       	ld.w	r0,r10[0x8]
8000242a:	65 72       	ld.w	r2,r2[0x5c]
8000242c:	72 6f       	ld.w	pc,r9[0x18]
8000242e:	72 20       	ld.w	r0,r9[0x8]
80002430:	0a 0d       	add	sp,r5
80002432:	00 00       	add	r0,r0
80002434:	0a 0d       	add	sp,r5
80002436:	20 50       	sub	r0,5
80002438:	68 79       	ld.w	r9,r4[0x1c]
8000243a:	73 69       	ld.w	r9,r9[0x58]
8000243c:	63 61       	ld.w	r1,r1[0x58]
8000243e:	6c 55       	ld.w	r5,r6[0x14]
80002440:	73 65       	ld.w	r5,r9[0x58]
80002442:	72 49       	ld.w	r9,r9[0x10]
80002444:	6e 70       	ld.w	r0,r7[0x1c]
80002446:	75 74       	ld.w	r4,r10[0x5c]
80002448:	5f 62       	srmi	r2
8000244a:	72 6f       	ld.w	pc,r9[0x18]
8000244c:	61 64       	ld.w	r4,r0[0x58]
8000244e:	63 61       	ld.w	r1,r1[0x58]
80002450:	73 74       	ld.w	r4,r9[0x5c]
80002452:	20 20       	sub	r0,2
80002454:	0a 0d       	add	sp,r5
80002456:	00 00       	add	r0,r0
80002458:	0a 0d       	add	sp,r5
8000245a:	20 50       	sub	r0,5
8000245c:	55 49       	stdsp	sp[0x150],r9
8000245e:	5f 53       	srlt	r3
80002460:	6f 75       	ld.w	r5,r7[0x5c]
80002462:	72 63       	ld.w	r3,r9[0x18]
80002464:	65 3a       	ld.w	r10,r2[0x4c]
80002466:	20 25       	sub	r5,2
80002468:	58 20       	cp.w	r0,2
8000246a:	0a 0d       	add	sp,r5
8000246c:	00 00       	add	r0,r0
8000246e:	00 00       	add	r0,r0
80002470:	0a 0d       	add	sp,r5
80002472:	20 50       	sub	r0,5
80002474:	55 49       	stdsp	sp[0x150],r9
80002476:	5f 54       	srlt	r4
80002478:	79 70       	ld.w	r0,r12[0x5c]
8000247a:	65 3a       	ld.w	r10,r2[0x4c]
8000247c:	20 25       	sub	r5,2
8000247e:	58 20       	cp.w	r0,2
80002480:	0a 0d       	add	sp,r5
80002482:	00 00       	add	r0,r0
80002484:	0a 0d       	add	sp,r5
80002486:	20 50       	sub	r0,5
80002488:	55 49       	stdsp	sp[0x150],r9
8000248a:	5f 49       	srge	r9
8000248c:	44 3a       	lddsp	r10,sp[0x10c]
8000248e:	20 25       	sub	r5,2
80002490:	58 20       	cp.w	r0,2
80002492:	0a 0d       	add	sp,r5
80002494:	00 00       	add	r0,r0
80002496:	00 00       	add	r0,r0
80002498:	0a 0d       	add	sp,r5
8000249a:	20 50       	sub	r0,5
8000249c:	55 49       	stdsp	sp[0x150],r9
8000249e:	5f 53       	srlt	r3
800024a0:	74 61       	ld.w	r1,r10[0x18]
800024a2:	74 65       	ld.w	r5,r10[0x18]
800024a4:	3a 20       	mov	r0,-94
800024a6:	25 58       	sub	r8,85
800024a8:	20 0a       	sub	r10,0
800024aa:	0d 00       	ld.w	r0,r6++
800024ac:	0a 0d       	add	sp,r5
800024ae:	20 50       	sub	r0,5
800024b0:	55 49       	stdsp	sp[0x150],r9
800024b2:	5f 53       	srlt	r3
800024b4:	74 61       	ld.w	r1,r10[0x18]
800024b6:	74 65       	ld.w	r5,r10[0x18]
800024b8:	5f 4d       	srge	sp
800024ba:	69 6e       	ld.w	lr,r4[0x58]
800024bc:	5f 56       	srlt	r6
800024be:	61 6c       	ld.w	r12,r0[0x58]
800024c0:	75 65       	ld.w	r5,r10[0x58]
800024c2:	3a 20       	mov	r0,-94
800024c4:	25 58       	sub	r8,85
800024c6:	20 0a       	sub	r10,0
800024c8:	0d 00       	ld.w	r0,r6++
800024ca:	00 00       	add	r0,r0
800024cc:	0a 0d       	add	sp,r5
800024ce:	20 50       	sub	r0,5
800024d0:	55 49       	stdsp	sp[0x150],r9
800024d2:	5f 53       	srlt	r3
800024d4:	74 61       	ld.w	r1,r10[0x18]
800024d6:	74 65       	ld.w	r5,r10[0x18]
800024d8:	5f 4d       	srge	sp
800024da:	61 78       	ld.w	r8,r0[0x5c]
800024dc:	5f 56       	srlt	r6
800024de:	61 6c       	ld.w	r12,r0[0x58]
800024e0:	75 65       	ld.w	r5,r10[0x58]
800024e2:	3a 20       	mov	r0,-94
800024e4:	25 58       	sub	r8,85
800024e6:	20 0a       	sub	r10,0
800024e8:	0d 00       	ld.w	r0,r6++
800024ea:	00 00       	add	r0,r0
800024ec:	0a 0d       	add	sp,r5
800024ee:	20 42       	sub	r2,4
800024f0:	75 74       	ld.w	r4,r10[0x5c]
800024f2:	74 6f       	ld.w	pc,r10[0x18]
800024f4:	6e 43       	ld.w	r3,r7[0x10]
800024f6:	6f 6e       	ld.w	lr,r7[0x58]
800024f8:	66 69       	ld.w	r9,r3[0x18]
800024fa:	67 5f       	ld.w	pc,r3[0x54]
800024fc:	62 72       	ld.w	r2,r1[0x1c]
800024fe:	6f 61       	ld.w	r1,r7[0x58]
80002500:	64 63       	ld.w	r3,r2[0x18]
80002502:	61 73       	ld.w	r3,r0[0x5c]
80002504:	74 20       	ld.w	r0,r10[0x8]
80002506:	20 0a       	sub	r10,0
80002508:	0d 00       	ld.w	r0,r6++
8000250a:	00 00       	add	r0,r0
8000250c:	0a 0d       	add	sp,r5
8000250e:	20 4e       	sub	lr,4
80002510:	75 6d       	ld.w	sp,r10[0x58]
80002512:	4f 66       	lddpc	r6,800026e8 <program_start+0x6e0>
80002514:	42 75       	lddsp	r5,sp[0x9c]
80002516:	74 74       	ld.w	r4,r10[0x1c]
80002518:	6f 6e       	ld.w	lr,r7[0x58]
8000251a:	73 3a       	ld.w	r10,r9[0x4c]
8000251c:	20 25       	sub	r5,2
8000251e:	64 20       	ld.w	r0,r2[0x8]
80002520:	0a 0d       	add	sp,r5
80002522:	00 00       	add	r0,r0
80002524:	0a 0d       	add	sp,r5
80002526:	20 42       	sub	r2,4
80002528:	75 74       	ld.w	r4,r10[0x5c]
8000252a:	74 6f       	ld.w	pc,r10[0x18]
8000252c:	6e 49       	ld.w	r9,r7[0x10]
8000252e:	6e 66       	ld.w	r6,r7[0x18]
80002530:	6f 53       	ld.w	r3,r7[0x54]
80002532:	74 72       	ld.w	r2,r10[0x1c]
80002534:	75 63       	ld.w	r3,r10[0x58]
80002536:	74 53       	ld.w	r3,r10[0x14]
80002538:	69 7a       	ld.w	r10,r4[0x5c]
8000253a:	65 3a       	ld.w	r10,r2[0x4c]
8000253c:	20 25       	sub	r5,2
8000253e:	78 20       	ld.w	r0,r12[0x8]
80002540:	0a 0d       	add	sp,r5
80002542:	00 00       	add	r0,r0
80002544:	0a 0d       	add	sp,r5
80002546:	20 42       	sub	r2,4
80002548:	75 74       	ld.w	r4,r10[0x5c]
8000254a:	74 6f       	ld.w	pc,r10[0x18]
8000254c:	6e 49       	ld.w	r9,r7[0x10]
8000254e:	6e 66       	ld.w	r6,r7[0x18]
80002550:	6f 5b       	ld.w	r11,r7[0x54]
80002552:	25 64       	sub	r4,86
80002554:	5d 2e       	mustr	lr
80002556:	42 74       	lddsp	r4,sp[0x9c]
80002558:	5f 49       	srge	r9
8000255a:	64 65       	ld.w	r5,r2[0x18]
8000255c:	6e 74       	ld.w	r4,r7[0x1c]
8000255e:	69 66       	ld.w	r6,r4[0x58]
80002560:	69 65       	ld.w	r5,r4[0x58]
80002562:	72 3a       	ld.w	r10,r9[0xc]
80002564:	20 25       	sub	r5,2
80002566:	78 20       	ld.w	r0,r12[0x8]
80002568:	0a 0d       	add	sp,r5
8000256a:	00 00       	add	r0,r0
8000256c:	0a 0d       	add	sp,r5
8000256e:	20 42       	sub	r2,4
80002570:	75 74       	ld.w	r4,r10[0x5c]
80002572:	74 6f       	ld.w	pc,r10[0x18]
80002574:	6e 49       	ld.w	r9,r7[0x10]
80002576:	6e 66       	ld.w	r6,r7[0x18]
80002578:	6f 5b       	ld.w	r11,r7[0x54]
8000257a:	25 64       	sub	r4,86
8000257c:	5d 2e       	mustr	lr
8000257e:	53 5f       	stdsp	sp[0xd4],pc
80002580:	50 72       	stdsp	sp[0x1c],r2
80002582:	65 73       	ld.w	r3,r2[0x5c]
80002584:	73 46       	ld.w	r6,r9[0x50]
80002586:	65 61       	ld.w	r1,r2[0x58]
80002588:	74 75       	ld.w	r5,r10[0x1c]
8000258a:	72 65       	ld.w	r5,r9[0x18]
8000258c:	3a 20       	mov	r0,-94
8000258e:	25 78       	sub	r8,87
80002590:	20 0a       	sub	r10,0
80002592:	0d 00       	ld.w	r0,r6++
80002594:	0a 0d       	add	sp,r5
80002596:	20 42       	sub	r2,4
80002598:	75 74       	ld.w	r4,r10[0x5c]
8000259a:	74 6f       	ld.w	pc,r10[0x18]
8000259c:	6e 49       	ld.w	r9,r7[0x10]
8000259e:	6e 66       	ld.w	r6,r7[0x18]
800025a0:	6f 5b       	ld.w	r11,r7[0x54]
800025a2:	25 64       	sub	r4,86
800025a4:	5d 2e       	mustr	lr
800025a6:	52 65       	stdsp	sp[0x98],r5
800025a8:	73 65       	ld.w	r5,r9[0x58]
800025aa:	72 76       	ld.w	r6,r9[0x1c]
800025ac:	65 64       	ld.w	r4,r2[0x58]
800025ae:	31 3a       	mov	r10,19
800025b0:	20 25       	sub	r5,2
800025b2:	78 20       	ld.w	r0,r12[0x8]
800025b4:	0a 0d       	add	sp,r5
800025b6:	00 00       	add	r0,r0
800025b8:	0a 0d       	add	sp,r5
800025ba:	20 42       	sub	r2,4
800025bc:	75 74       	ld.w	r4,r10[0x5c]
800025be:	74 6f       	ld.w	pc,r10[0x18]
800025c0:	6e 49       	ld.w	r9,r7[0x10]
800025c2:	6e 66       	ld.w	r6,r7[0x18]
800025c4:	6f 5b       	ld.w	r11,r7[0x54]
800025c6:	25 64       	sub	r4,86
800025c8:	5d 2e       	mustr	lr
800025ca:	4c 5f       	lddpc	pc,800026dc <program_start+0x6d4>
800025cc:	50 72       	stdsp	sp[0x1c],r2
800025ce:	65 73       	ld.w	r3,r2[0x5c]
800025d0:	73 46       	ld.w	r6,r9[0x50]
800025d2:	65 61       	ld.w	r1,r2[0x58]
800025d4:	74 75       	ld.w	r5,r10[0x1c]
800025d6:	72 65       	ld.w	r5,r9[0x18]
800025d8:	3a 20       	mov	r0,-94
800025da:	25 78       	sub	r8,87
800025dc:	20 0a       	sub	r10,0
800025de:	0d 00       	ld.w	r0,r6++
800025e0:	0a 0d       	add	sp,r5
800025e2:	20 42       	sub	r2,4
800025e4:	75 74       	ld.w	r4,r10[0x5c]
800025e6:	74 6f       	ld.w	pc,r10[0x18]
800025e8:	6e 49       	ld.w	r9,r7[0x10]
800025ea:	6e 66       	ld.w	r6,r7[0x18]
800025ec:	6f 5b       	ld.w	r11,r7[0x54]
800025ee:	25 64       	sub	r4,86
800025f0:	5d 2e       	mustr	lr
800025f2:	52 65       	stdsp	sp[0x98],r5
800025f4:	73 65       	ld.w	r5,r9[0x58]
800025f6:	72 76       	ld.w	r6,r9[0x1c]
800025f8:	65 64       	ld.w	r4,r2[0x58]
800025fa:	32 3a       	mov	r10,35
800025fc:	20 25       	sub	r5,2
800025fe:	78 20       	ld.w	r0,r12[0x8]
80002600:	0a 0d       	add	sp,r5
80002602:	00 00       	add	r0,r0
80002604:	0a 0d       	add	sp,r5
80002606:	20 44       	sub	r4,4
80002608:	4d 52       	lddpc	r2,8000275c <DeviceInitializationStatus_brdcst_func+0x30>
8000260a:	5f 43       	srge	r3
8000260c:	53 42       	stdsp	sp[0xd0],r2
8000260e:	4b 20       	lddpc	r0,800026d4 <program_start+0x6cc>
80002610:	4f 4b       	lddpc	r11,800027e0 <ToneControl_reply_func>
80002612:	20 0a       	sub	r10,0
80002614:	0d 00       	ld.w	r0,r6++
80002616:	00 00       	add	r0,r0
80002618:	0a 0d       	add	sp,r5
8000261a:	20 45       	sub	r5,4
8000261c:	6e 5f       	ld.w	pc,r7[0x14]
8000261e:	4f 42       	lddpc	r2,800027ec <ToneControl_reply_func+0xc>
80002620:	5f 45       	srge	r5
80002622:	6e 74       	ld.w	r4,r7[0x1c]
80002624:	65 72       	ld.w	r2,r2[0x5c]
80002626:	20 4f       	sub	pc,4
80002628:	4b 20       	lddpc	r0,800026f0 <program_start+0x6e8>
8000262a:	0a 0d       	add	sp,r5
8000262c:	00 00       	add	r0,r0
8000262e:	00 00       	add	r0,r0
80002630:	0a 0d       	add	sp,r5
80002632:	20 45       	sub	r5,4
80002634:	6e 5f       	ld.w	pc,r7[0x14]
80002636:	4f 42       	lddpc	r2,80002804 <ToneControl_reply_func+0x24>
80002638:	5f 45       	srge	r5
8000263a:	78 69       	ld.w	r9,r12[0x18]
8000263c:	74 20       	ld.w	r0,r10[0x8]
8000263e:	4f 4b       	lddpc	r11,8000280c <ToneControl_reply_func+0x2c>
80002640:	20 0a       	sub	r10,0
80002642:	0d 00       	ld.w	r0,r6++
80002644:	0a 0d       	add	sp,r5
80002646:	20 45       	sub	r5,4
80002648:	6e 5f       	ld.w	pc,r7[0x14]
8000264a:	4f 42       	lddpc	r2,80002818 <dcm_reply_func>
8000264c:	5f 43       	srge	r3
8000264e:	6f 6e       	ld.w	lr,r7[0x58]
80002650:	74 72       	ld.w	r2,r10[0x1c]
80002652:	6f 6c       	ld.w	r12,r7[0x58]
80002654:	3a 20       	mov	r0,-94
80002656:	25 78       	sub	r8,87
80002658:	20 0a       	sub	r10,0
8000265a:	0d 00       	ld.w	r0,r6++
8000265c:	0a 0d       	add	sp,r5
8000265e:	20 45       	sub	r5,4
80002660:	6e 5f       	ld.w	pc,r7[0x14]
80002662:	4f 42       	lddpc	r2,80002830 <dcm_reply_func+0x18>
80002664:	5f 43       	srge	r3
80002666:	6f 6e       	ld.w	lr,r7[0x58]
80002668:	74 72       	ld.w	r2,r10[0x1c]
8000266a:	6f 6c       	ld.w	r12,r7[0x58]
8000266c:	20 65       	sub	r5,6
8000266e:	72 72       	ld.w	r2,r9[0x1c]
80002670:	6f 72       	ld.w	r2,r7[0x5c]
80002672:	20 0a       	sub	r10,0
80002674:	0d 00       	ld.w	r0,r6++
80002676:	00 00       	add	r0,r0
80002678:	0a 0d       	add	sp,r5
8000267a:	20 45       	sub	r5,4
8000267c:	6e 5f       	ld.w	pc,r7[0x14]
8000267e:	4f 42       	lddpc	r2,8000284c <dcm_reply_func+0x34>
80002680:	5f 72       	srpl	r2
80002682:	65 73       	ld.w	r3,r2[0x5c]
80002684:	75 6c       	ld.w	r12,r10[0x58]
80002686:	74 3a       	ld.w	r10,r10[0xc]
80002688:	20 25       	sub	r5,2
8000268a:	78 20       	ld.w	r0,r12[0x8]
8000268c:	0a 0d       	add	sp,r5
8000268e:	00 00       	add	r0,r0
80002690:	0a 0d       	add	sp,r5
80002692:	20 45       	sub	r5,4
80002694:	6e 5f       	ld.w	pc,r7[0x14]
80002696:	4f 42       	lddpc	r2,80002864 <dcm_reply_func+0x4c>
80002698:	20 42       	sub	r2,4
8000269a:	72 6f       	ld.w	pc,r9[0x18]
8000269c:	61 64       	ld.w	r4,r0[0x58]
8000269e:	63 61       	ld.w	r1,r1[0x58]
800026a0:	73 74       	ld.w	r4,r9[0x5c]
800026a2:	20 0a       	sub	r10,0
800026a4:	0d 00       	ld.w	r0,r6++
800026a6:	00 00       	add	r0,r0
800026a8:	0a 0d       	add	sp,r5
800026aa:	20 46       	sub	r6,4
800026ac:	6f 72       	ld.w	r2,r7[0x5c]
800026ae:	77 61       	ld.w	r1,r11[0x58]
800026b0:	72 64       	ld.w	r4,r9[0x18]
800026b2:	20 44       	sub	r4,4
800026b4:	61 74       	ld.w	r4,r0[0x5c]
800026b6:	61 20       	ld.w	r0,r0[0x48]
800026b8:	52 65       	stdsp	sp[0x98],r5
800026ba:	71 75       	ld.w	r5,r8[0x5c]
800026bc:	65 73       	ld.w	r3,r2[0x5c]
800026be:	74 20       	ld.w	r0,r10[0x8]
800026c0:	0a 0d       	add	sp,r5
800026c2:	00 00       	add	r0,r0
800026c4:	0a 0d       	add	sp,r5
800026c6:	20 46       	sub	r6,4
800026c8:	6f 72       	ld.w	r2,r7[0x5c]
800026ca:	77 61       	ld.w	r1,r11[0x58]
800026cc:	72 64       	ld.w	r4,r9[0x18]
800026ce:	20 44       	sub	r4,4
800026d0:	61 74       	ld.w	r4,r0[0x5c]
800026d2:	61 20       	ld.w	r0,r0[0x48]
800026d4:	52 65       	stdsp	sp[0x98],r5
800026d6:	70 6c       	ld.w	r12,r8[0x18]
800026d8:	79 20       	ld.w	r0,r12[0x48]
800026da:	0a 0d       	add	sp,r5
800026dc:	00 00       	add	r0,r0
800026de:	00 00       	add	r0,r0
800026e0:	0a 0d       	add	sp,r5
800026e2:	20 46       	sub	r6,4
800026e4:	6f 72       	ld.w	r2,r7[0x5c]
800026e6:	77 61       	ld.w	r1,r11[0x58]
800026e8:	72 64       	ld.w	r4,r9[0x18]
800026ea:	20 44       	sub	r4,4
800026ec:	61 74       	ld.w	r4,r0[0x5c]
800026ee:	61 20       	ld.w	r0,r0[0x48]
800026f0:	42 72       	lddsp	r2,sp[0x9c]
800026f2:	6f 61       	ld.w	r1,r7[0x58]
800026f4:	64 63       	ld.w	r3,r2[0x18]
800026f6:	61 73       	ld.w	r3,r0[0x5c]
800026f8:	74 20       	ld.w	r0,r10[0x8]
800026fa:	0a 0d       	add	sp,r5
800026fc:	00 00       	add	r0,r0
800026fe:	00 00       	add	r0,r0
80002700:	58 4e       	cp.w	lr,4
80002702:	4c 5f       	lddpc	pc,80002814 <ToneControl_reply_func+0x34>
80002704:	54 58       	stdsp	sp[0x114],r8
80002706:	00 00       	add	r0,r0
80002708:	0a 0d       	add	sp,r5
8000270a:	20 63       	sub	r3,6
8000270c:	6f 75       	ld.w	r5,r7[0x5c]
8000270e:	6e 74       	ld.w	r4,r7[0x1c]
80002710:	65 72       	ld.w	r2,r2[0x5c]
80002712:	3a 20       	mov	r0,-94
80002714:	25 64       	sub	r4,86
80002716:	20 0a       	sub	r10,0
80002718:	0d 00       	ld.w	r0,r6++
8000271a:	00 00       	add	r0,r0
8000271c:	0a 0d       	add	sp,r5
8000271e:	20 77       	sub	r7,7
80002720:	3a 20       	mov	r0,-94
80002722:	0a 0d       	add	sp,r5
80002724:	00 00       	add	r0,r0
80002726:	00 00       	add	r0,r0
80002728:	52 00       	stdsp	sp[0x80],r0
	...

8000272c <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
8000272c:	eb cd 40 80 	pushm	r7,lr
80002730:	1a 97       	mov	r7,sp
80002732:	20 1d       	sub	sp,4
80002734:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[4] == 0x01)
80002738:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000273c:	11 e9       	ld.ub	r9,r8[0x6]
8000273e:	30 18       	mov	r8,1
80002740:	f0 09 18 00 	cp.b	r9,r8
80002744:	c0 81       	brne	80002754 <DeviceInitializationStatus_brdcst_func+0x28>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002746:	48 e8       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
80002748:	70 08       	ld.w	r8,r8[0x0]
8000274a:	10 99       	mov	r9,r8
8000274c:	a1 a9       	sbr	r9,0x0
8000274e:	48 c8       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
80002750:	91 09       	st.w	r8[0x0],r9
80002752:	c1 18       	rjmp	80002774 <DeviceInitializationStatus_brdcst_func+0x48>
	}
	else if(xcmp->u8[4] != 0x02)
80002754:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002758:	11 e9       	ld.ub	r9,r8[0x6]
8000275a:	30 28       	mov	r8,2
8000275c:	f0 09 18 00 	cp.b	r9,r8
80002760:	c0 a0       	breq	80002774 <DeviceInitializationStatus_brdcst_func+0x48>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002762:	48 78       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
80002764:	70 08       	ld.w	r8,r8[0x0]
80002766:	10 99       	mov	r9,r8
80002768:	e0 19 ff fc 	andl	r9,0xfffc
8000276c:	48 48       	lddpc	r8,8000277c <DeviceInitializationStatus_brdcst_func+0x50>
8000276e:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002770:	f0 1f 00 04 	mcall	80002780 <DeviceInitializationStatus_brdcst_func+0x54>
	}
}
80002774:	2f fd       	sub	sp,-4
80002776:	e3 cd 80 80 	ldm	sp++,r7,pc
8000277a:	00 00       	add	r0,r0
8000277c:	00 00       	add	r0,r0
8000277e:	0d 9c       	ld.ub	r12,r6[0x1]
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	66 84       	ld.w	r4,r3[0x20]

80002784 <DeviceManagement_brdcst_func>:

void DeviceManagement_brdcst_func(xcmp_fragment_t * xcmp)
{
80002784:	eb cd 40 80 	pushm	r7,lr
80002788:	1a 97       	mov	r7,sp
8000278a:	20 2d       	sub	sp,8
8000278c:	ef 4c ff f8 	st.w	r7[-8],r12
		U8 temp = 0;
80002790:	30 08       	mov	r8,0
80002792:	ef 68 ff ff 	st.b	r7[-1],r8
		temp  = xcmp->u8[1] << 8;
80002796:	30 08       	mov	r8,0
80002798:	ef 68 ff ff 	st.b	r7[-1],r8
		temp |= xcmp->u8[2];
8000279c:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027a0:	11 c9       	ld.ub	r9,r8[0x4]
800027a2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800027a6:	f3 e8 10 08 	or	r8,r9,r8
800027aa:	ef 68 ff ff 	st.b	r7[-1],r8
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
800027ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800027b2:	11 a9       	ld.ub	r9,r8[0x2]
800027b4:	30 18       	mov	r8,1
800027b6:	f0 09 18 00 	cp.b	r9,r8
800027ba:	c0 81       	brne	800027ca <DeviceManagement_brdcst_func+0x46>
			{
				bunchofrandomstatusflags |= 0x00000002;
800027bc:	48 88       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027be:	70 08       	ld.w	r8,r8[0x0]
800027c0:	10 99       	mov	r9,r8
800027c2:	a1 b9       	sbr	r9,0x1
800027c4:	48 68       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027c6:	91 09       	st.w	r8[0x0],r9
800027c8:	c0 78       	rjmp	800027d6 <DeviceManagement_brdcst_func+0x52>
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
800027ca:	48 58       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027cc:	70 08       	ld.w	r8,r8[0x0]
800027ce:	10 99       	mov	r9,r8
800027d0:	a1 d9       	cbr	r9,0x1
800027d2:	48 38       	lddpc	r8,800027dc <DeviceManagement_brdcst_func+0x58>
800027d4:	91 09       	st.w	r8[0x0],r9
			}
		}
}
800027d6:	2f ed       	sub	sp,-8
800027d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800027dc:	00 00       	add	r0,r0
800027de:	0d 9c       	ld.ub	r12,r6[0x1]

800027e0 <ToneControl_reply_func>:

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027e0:	eb cd 40 80 	pushm	r7,lr
800027e4:	1a 97       	mov	r7,sp
800027e6:	20 1d       	sub	sp,4
800027e8:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027ec:	ee f8 ff fc 	ld.w	r8,r7[-4]
800027f0:	11 a8       	ld.ub	r8,r8[0x2]
800027f2:	58 08       	cp.w	r8,0
800027f4:	c0 51       	brne	800027fe <ToneControl_reply_func+0x1e>
	{		
		log("Tone OK");
800027f6:	48 6c       	lddpc	r12,8000280c <ToneControl_reply_func+0x2c>
800027f8:	f0 1f 00 06 	mcall	80002810 <ToneControl_reply_func+0x30>
800027fc:	c0 48       	rjmp	80002804 <ToneControl_reply_func+0x24>
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800027fe:	48 6c       	lddpc	r12,80002814 <ToneControl_reply_func+0x34>
80002800:	f0 1f 00 04 	mcall	80002810 <ToneControl_reply_func+0x30>
	}
}
80002804:	2f fd       	sub	sp,-4
80002806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000280a:	00 00       	add	r0,r0
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	20 10       	sub	r0,1
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	a3 80       	lsr	r0,0x2
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	20 18       	sub	r8,1

80002818 <dcm_reply_func>:

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002818:	eb cd 40 80 	pushm	r7,lr
8000281c:	1a 97       	mov	r7,sp
8000281e:	20 1d       	sub	sp,4
80002820:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002824:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002828:	11 a8       	ld.ub	r8,r8[0x2]
8000282a:	58 08       	cp.w	r8,0
8000282c:	c2 11       	brne	8000286e <dcm_reply_func+0x56>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000282e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002832:	11 b9       	ld.ub	r9,r8[0x3]
80002834:	30 18       	mov	r8,1
80002836:	f0 09 18 00 	cp.b	r9,r8
8000283a:	c0 51       	brne	80002844 <dcm_reply_func+0x2c>
		{
			log("\n\r Dcm-Enter OK \n\r");
8000283c:	49 0c       	lddpc	r12,8000287c <dcm_reply_func+0x64>
8000283e:	f0 1f 00 11 	mcall	80002880 <dcm_reply_func+0x68>
80002842:	c0 d8       	rjmp	8000285c <dcm_reply_func+0x44>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
80002844:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002848:	11 b8       	ld.ub	r8,r8[0x3]
8000284a:	58 08       	cp.w	r8,0
8000284c:	c0 51       	brne	80002856 <dcm_reply_func+0x3e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000284e:	48 ec       	lddpc	r12,80002884 <dcm_reply_func+0x6c>
80002850:	f0 1f 00 0c 	mcall	80002880 <dcm_reply_func+0x68>
80002854:	c0 48       	rjmp	8000285c <dcm_reply_func+0x44>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002856:	48 dc       	lddpc	r12,80002888 <dcm_reply_func+0x70>
80002858:	f0 1f 00 0a 	mcall	80002880 <dcm_reply_func+0x68>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000285c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002860:	11 d8       	ld.ub	r8,r8[0x5]
80002862:	1a d8       	st.w	--sp,r8
80002864:	48 ac       	lddpc	r12,8000288c <dcm_reply_func+0x74>
80002866:	f0 1f 00 07 	mcall	80002880 <dcm_reply_func+0x68>
8000286a:	2f fd       	sub	sp,-4
8000286c:	c0 48       	rjmp	80002874 <dcm_reply_func+0x5c>
	}
	else
	{
		log("dcm error");
8000286e:	48 9c       	lddpc	r12,80002890 <dcm_reply_func+0x78>
80002870:	f0 1f 00 04 	mcall	80002880 <dcm_reply_func+0x68>
	}
}
80002874:	2f fd       	sub	sp,-4
80002876:	e3 cd 80 80 	ldm	sp++,r7,pc
8000287a:	00 00       	add	r0,r0
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	20 24       	sub	r4,2
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	a3 80       	lsr	r0,0x2
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	20 38       	sub	r8,3
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	20 4c       	sub	r12,4
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	20 60       	sub	r0,6
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	20 6c       	sub	r12,6

80002894 <dcm_brdcst_func>:


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002894:	eb cd 40 80 	pushm	r7,lr
80002898:	1a 97       	mov	r7,sp
8000289a:	20 2d       	sub	sp,8
8000289c:	ef 4c ff f8 	st.w	r7[-8],r12
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800028a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028a4:	2f e8       	sub	r8,-2
800028a6:	ef 48 ff fc 	st.w	r7[-4],r8
	
	log("\n\r Dcm_brdcst \n\r");		
800028aa:	49 0c       	lddpc	r12,800028e8 <dcm_brdcst_func+0x54>
800028ac:	f0 1f 00 10 	mcall	800028ec <dcm_brdcst_func+0x58>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800028b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028b4:	11 88       	ld.ub	r8,r8[0x0]
800028b6:	1a d8       	st.w	--sp,r8
800028b8:	48 ec       	lddpc	r12,800028f0 <dcm_brdcst_func+0x5c>
800028ba:	f0 1f 00 0d 	mcall	800028ec <dcm_brdcst_func+0x58>
800028be:	2f fd       	sub	sp,-4
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800028c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028c4:	11 a8       	ld.ub	r8,r8[0x2]
800028c6:	1a d8       	st.w	--sp,r8
800028c8:	48 bc       	lddpc	r12,800028f4 <dcm_brdcst_func+0x60>
800028ca:	f0 1f 00 09 	mcall	800028ec <dcm_brdcst_func+0x58>
800028ce:	2f fd       	sub	sp,-4
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800028d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800028d4:	11 98       	ld.ub	r8,r8[0x1]
800028d6:	1a d8       	st.w	--sp,r8
800028d8:	48 8c       	lddpc	r12,800028f8 <dcm_brdcst_func+0x64>
800028da:	f0 1f 00 05 	mcall	800028ec <dcm_brdcst_func+0x58>
800028de:	2f fd       	sub	sp,-4
	
	
}
800028e0:	2f ed       	sub	sp,-8
800028e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800028e6:	00 00       	add	r0,r0
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	20 78       	sub	r8,7
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	a3 80       	lsr	r0,0x2
800028f0:	80 00       	ld.sh	r0,r0[0x0]
800028f2:	20 8c       	sub	r12,8
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	20 a0       	sub	r0,10
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	20 b8       	sub	r8,11

800028fc <mic_reply_func>:

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800028fc:	eb cd 40 80 	pushm	r7,lr
80002900:	1a 97       	mov	r7,sp
80002902:	20 2d       	sub	sp,8
80002904:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002908:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000290c:	2f e8       	sub	r8,-2
8000290e:	ef 48 ff fc 	st.w	r7[-4],r8
	
	log("\n\r Mic_reply \n\r");
80002912:	4a 2c       	lddpc	r12,80002998 <mic_reply_func+0x9c>
80002914:	f0 1f 00 22 	mcall	8000299c <mic_reply_func+0xa0>
	if (ptr->Result == 0x00)
80002918:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000291c:	11 88       	ld.ub	r8,r8[0x0]
8000291e:	58 08       	cp.w	r8,0
80002920:	c3 51       	brne	8000298a <mic_reply_func+0x8e>
	{
		
		if (ptr->Function == Mic_Disable)
80002922:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002926:	11 99       	ld.ub	r9,r8[0x1]
80002928:	30 28       	mov	r8,2
8000292a:	f0 09 18 00 	cp.b	r9,r8
8000292e:	c2 51       	brne	80002978 <mic_reply_func+0x7c>
		{
		
			log("\n\r Mic_close_ok \n\r " );
80002930:	49 cc       	lddpc	r12,800029a0 <mic_reply_func+0xa4>
80002932:	f0 1f 00 1b 	mcall	8000299c <mic_reply_func+0xa0>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002936:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000293a:	11 a8       	ld.ub	r8,r8[0x2]
8000293c:	1a d8       	st.w	--sp,r8
8000293e:	49 ac       	lddpc	r12,800029a4 <mic_reply_func+0xa8>
80002940:	f0 1f 00 17 	mcall	8000299c <mic_reply_func+0xa0>
80002944:	2f fd       	sub	sp,-4
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002946:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000294a:	11 b8       	ld.ub	r8,r8[0x3]
8000294c:	1a d8       	st.w	--sp,r8
8000294e:	49 7c       	lddpc	r12,800029a8 <mic_reply_func+0xac>
80002950:	f0 1f 00 13 	mcall	8000299c <mic_reply_func+0xa0>
80002954:	2f fd       	sub	sp,-4
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002956:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000295a:	11 c8       	ld.ub	r8,r8[0x4]
8000295c:	1a d8       	st.w	--sp,r8
8000295e:	49 4c       	lddpc	r12,800029ac <mic_reply_func+0xb0>
80002960:	f0 1f 00 0f 	mcall	8000299c <mic_reply_func+0xa0>
80002964:	2f fd       	sub	sp,-4
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002966:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000296a:	11 d8       	ld.ub	r8,r8[0x5]
8000296c:	1a d8       	st.w	--sp,r8
8000296e:	49 1c       	lddpc	r12,800029b0 <mic_reply_func+0xb4>
80002970:	f0 1f 00 0b 	mcall	8000299c <mic_reply_func+0xa0>
80002974:	2f fd       	sub	sp,-4
80002976:	c0 d8       	rjmp	80002990 <mic_reply_func+0x94>
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002978:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000297c:	11 98       	ld.ub	r8,r8[0x1]
8000297e:	1a d8       	st.w	--sp,r8
80002980:	48 dc       	lddpc	r12,800029b4 <mic_reply_func+0xb8>
80002982:	f0 1f 00 07 	mcall	8000299c <mic_reply_func+0xa0>
80002986:	2f fd       	sub	sp,-4
80002988:	c0 48       	rjmp	80002990 <mic_reply_func+0x94>
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000298a:	48 cc       	lddpc	r12,800029b8 <mic_reply_func+0xbc>
8000298c:	f0 1f 00 04 	mcall	8000299c <mic_reply_func+0xa0>
		
	}
	
	
	
}
80002990:	2f ed       	sub	sp,-8
80002992:	e3 cd 80 80 	ldm	sp++,r7,pc
80002996:	00 00       	add	r0,r0
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	20 d4       	sub	r4,13
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	a3 80       	lsr	r0,0x2
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	20 e4       	sub	r4,14
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	20 f8       	sub	r8,15
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	21 0c       	sub	r12,16
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	21 28       	sub	r8,18
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	21 40       	sub	r0,20
800029b4:	80 00       	ld.sh	r0,r0[0x0]
800029b6:	21 58       	sub	r8,21
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	21 70       	sub	r0,23

800029bc <mic_brdcst_func>:

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800029bc:	eb cd 40 80 	pushm	r7,lr
800029c0:	1a 97       	mov	r7,sp
800029c2:	20 2d       	sub	sp,8
800029c4:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800029c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800029cc:	2f e8       	sub	r8,-2
800029ce:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800029d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800029d6:	11 a8       	ld.ub	r8,r8[0x2]
800029d8:	58 08       	cp.w	r8,0
800029da:	c0 71       	brne	800029e8 <mic_brdcst_func+0x2c>
	{
		log("\n\r Mic_Disabled \n\r");	
800029dc:	49 0c       	lddpc	r12,80002a1c <mic_brdcst_func+0x60>
800029de:	f0 1f 00 11 	mcall	80002a20 <mic_brdcst_func+0x64>
		Mic_is_Enabled = 0;
800029e2:	49 19       	lddpc	r9,80002a24 <mic_brdcst_func+0x68>
800029e4:	30 08       	mov	r8,0
800029e6:	b2 88       	st.b	r9[0x0],r8
	} 
	if(ptr->Mic_State == 0x11)
800029e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800029ec:	11 a9       	ld.ub	r9,r8[0x2]
800029ee:	31 18       	mov	r8,17
800029f0:	f0 09 18 00 	cp.b	r9,r8
800029f4:	c1 11       	brne	80002a16 <mic_brdcst_func+0x5a>
	{
		log("\n\r Mic_Enabled \n\r");
800029f6:	48 dc       	lddpc	r12,80002a28 <mic_brdcst_func+0x6c>
800029f8:	f0 1f 00 0a 	mcall	80002a20 <mic_brdcst_func+0x64>
		Mic_is_Enabled = 1;
800029fc:	48 a9       	lddpc	r9,80002a24 <mic_brdcst_func+0x68>
800029fe:	30 18       	mov	r8,1
80002a00:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002a02:	48 98       	lddpc	r8,80002a24 <mic_brdcst_func+0x68>
80002a04:	11 88       	ld.ub	r8,r8[0x0]
80002a06:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002a0a:	30 18       	mov	r8,1
80002a0c:	f0 09 18 00 	cp.b	r9,r8
80002a10:	c0 31       	brne	80002a16 <mic_brdcst_func+0x5a>
80002a12:	48 78       	lddpc	r8,80002a2c <mic_brdcst_func+0x70>
80002a14:	11 88       	ld.ub	r8,r8[0x0]
	}
	//log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
	//log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
			
	
}
80002a16:	2f ed       	sub	sp,-8
80002a18:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a1c:	80 00       	ld.sh	r0,r0[0x0]
80002a1e:	21 80       	sub	r0,24
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	a3 80       	lsr	r0,0x2
80002a24:	00 00       	add	r0,r0
80002a26:	0a 5d       	eor	sp,r5
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	21 94       	sub	r4,25
80002a2c:	00 00       	add	r0,r0
80002a2e:	0a 5e       	eor	lr,r5

80002a30 <spk_reply_func>:

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002a30:	eb cd 40 80 	pushm	r7,lr
80002a34:	1a 97       	mov	r7,sp
80002a36:	20 1d       	sub	sp,4
80002a38:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002a3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a40:	11 a8       	ld.ub	r8,r8[0x2]
80002a42:	58 08       	cp.w	r8,0
80002a44:	c1 21       	brne	80002a68 <spk_reply_func+0x38>
	{
		
		if(xcmp->u8[4])
80002a46:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a4a:	11 e8       	ld.ub	r8,r8[0x6]
80002a4c:	58 08       	cp.w	r8,0
80002a4e:	c0 40       	breq	80002a56 <spk_reply_func+0x26>
		{
			Speaker_is_unmute = 1;
80002a50:	48 b9       	lddpc	r9,80002a7c <spk_reply_func+0x4c>
80002a52:	30 18       	mov	r8,1
80002a54:	b2 88       	st.b	r9[0x0],r8
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002a56:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a5a:	11 e8       	ld.ub	r8,r8[0x6]
80002a5c:	1a d8       	st.w	--sp,r8
80002a5e:	48 9c       	lddpc	r12,80002a80 <spk_reply_func+0x50>
80002a60:	f0 1f 00 09 	mcall	80002a84 <spk_reply_func+0x54>
80002a64:	2f fd       	sub	sp,-4
80002a66:	c0 78       	rjmp	80002a74 <spk_reply_func+0x44>
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002a68:	48 59       	lddpc	r9,80002a7c <spk_reply_func+0x4c>
80002a6a:	30 08       	mov	r8,0
80002a6c:	b2 88       	st.b	r9[0x0],r8
		log("spk error");
80002a6e:	48 7c       	lddpc	r12,80002a88 <spk_reply_func+0x58>
80002a70:	f0 1f 00 05 	mcall	80002a84 <spk_reply_func+0x54>
	}
}
80002a74:	2f fd       	sub	sp,-4
80002a76:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a7a:	00 00       	add	r0,r0
80002a7c:	00 00       	add	r0,r0
80002a7e:	0a 58       	eor	r8,r5
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	21 a8       	sub	r8,26
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	a3 80       	lsr	r0,0x2
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	21 b8       	sub	r8,27

80002a8c <spk_brdcst_func>:

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002a8c:	eb cd 40 80 	pushm	r7,lr
80002a90:	1a 97       	mov	r7,sp
80002a92:	20 1d       	sub	sp,4
80002a94:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002a98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a9c:	11 d8       	ld.ub	r8,r8[0x5]
80002a9e:	58 08       	cp.w	r8,0
80002aa0:	c0 81       	brne	80002ab0 <spk_brdcst_func+0x24>
	{
		Speaker_is_unmute =0;
80002aa2:	48 99       	lddpc	r9,80002ac4 <spk_brdcst_func+0x38>
80002aa4:	30 08       	mov	r8,0
80002aa6:	b2 88       	st.b	r9[0x0],r8
		//Silent_flag = 0;
		log("spk_s_close ");
80002aa8:	48 8c       	lddpc	r12,80002ac8 <spk_brdcst_func+0x3c>
80002aaa:	f0 1f 00 09 	mcall	80002acc <spk_brdcst_func+0x40>
80002aae:	c0 78       	rjmp	80002abc <spk_brdcst_func+0x30>
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002ab0:	48 59       	lddpc	r9,80002ac4 <spk_brdcst_func+0x38>
80002ab2:	30 18       	mov	r8,1
80002ab4:	b2 88       	st.b	r9[0x0],r8
		log("spk_s_open ");	
80002ab6:	48 7c       	lddpc	r12,80002ad0 <spk_brdcst_func+0x44>
80002ab8:	f0 1f 00 05 	mcall	80002acc <spk_brdcst_func+0x40>
	}
	
	
	
	
}
80002abc:	2f fd       	sub	sp,-4
80002abe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ac2:	00 00       	add	r0,r0
80002ac4:	00 00       	add	r0,r0
80002ac6:	0a 58       	eor	r8,r5
80002ac8:	80 00       	ld.sh	r0,r0[0x0]
80002aca:	21 c4       	sub	r4,28
80002acc:	80 00       	ld.sh	r0,r0[0x0]
80002ace:	a3 80       	lsr	r0,0x2
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	21 d4       	sub	r4,29

80002ad4 <Volume_reply_func>:


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002ad4:	eb cd 40 80 	pushm	r7,lr
80002ad8:	1a 97       	mov	r7,sp
80002ada:	20 2d       	sub	sp,8
80002adc:	ef 4c ff f8 	st.w	r7[-8],r12
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002ae0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ae4:	2f e8       	sub	r8,-2
80002ae6:	ef 48 ff fc 	st.w	r7[-4],r8
	
		if (ptr->Result == xcmp_Res_Success)
80002aea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002aee:	11 88       	ld.ub	r8,r8[0x0]
80002af0:	58 08       	cp.w	r8,0
80002af2:	c2 41       	brne	80002b3a <Volume_reply_func+0x66>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002af4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002af8:	11 b9       	ld.ub	r9,r8[0x3]
80002afa:	31 08       	mov	r8,16
80002afc:	f0 09 18 00 	cp.b	r9,r8
80002b00:	c1 41       	brne	80002b28 <Volume_reply_func+0x54>
			{
				log("\n\r Enable_IA OK \n\r");
80002b02:	49 2c       	lddpc	r12,80002b48 <Volume_reply_func+0x74>
80002b04:	f0 1f 00 12 	mcall	80002b4c <Volume_reply_func+0x78>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002b08:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b0c:	11 98       	ld.ub	r8,r8[0x1]
80002b0e:	f0 09 15 08 	lsl	r9,r8,0x8
80002b12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b16:	11 a8       	ld.ub	r8,r8[0x2]
80002b18:	f3 e8 10 08 	or	r8,r9,r8
80002b1c:	1a d8       	st.w	--sp,r8
80002b1e:	48 dc       	lddpc	r12,80002b50 <Volume_reply_func+0x7c>
80002b20:	f0 1f 00 0b 	mcall	80002b4c <Volume_reply_func+0x78>
80002b24:	2f fd       	sub	sp,-4
80002b26:	c0 d8       	rjmp	80002b40 <Volume_reply_func+0x6c>
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002b28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b2c:	11 b8       	ld.ub	r8,r8[0x3]
80002b2e:	1a d8       	st.w	--sp,r8
80002b30:	48 9c       	lddpc	r12,80002b54 <Volume_reply_func+0x80>
80002b32:	f0 1f 00 07 	mcall	80002b4c <Volume_reply_func+0x78>
80002b36:	2f fd       	sub	sp,-4
80002b38:	c0 48       	rjmp	80002b40 <Volume_reply_func+0x6c>
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002b3a:	48 8c       	lddpc	r12,80002b58 <Volume_reply_func+0x84>
80002b3c:	f0 1f 00 04 	mcall	80002b4c <Volume_reply_func+0x78>
		}
	
	
	
}
80002b40:	2f ed       	sub	sp,-8
80002b42:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b46:	00 00       	add	r0,r0
80002b48:	80 00       	ld.sh	r0,r0[0x0]
80002b4a:	21 e0       	sub	r0,30
80002b4c:	80 00       	ld.sh	r0,r0[0x0]
80002b4e:	a3 80       	lsr	r0,0x2
80002b50:	80 00       	ld.sh	r0,r0[0x0]
80002b52:	21 f4       	sub	r4,31
80002b54:	80 00       	ld.sh	r0,r0[0x0]
80002b56:	22 10       	sub	r0,33
80002b58:	80 00       	ld.sh	r0,r0[0x0]
80002b5a:	22 28       	sub	r8,34

80002b5c <Volume_brdcst_func>:

void Volume_brdcst_func(xcmp_fragment_t * xcmp)
{
80002b5c:	eb cd 40 80 	pushm	r7,lr
80002b60:	1a 97       	mov	r7,sp
80002b62:	20 2d       	sub	sp,8
80002b64:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	VolumeControl_brdcst_t *ptr = (VolumeControl_brdcst_t* )xcmp->u8;
80002b68:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b6c:	2f e8       	sub	r8,-2
80002b6e:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002b72:	2f ed       	sub	sp,-8
80002b74:	e3 cd 80 80 	ldm	sp++,r7,pc

80002b78 <AudioRoutingControl_reply_func>:


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002b78:	eb cd 40 80 	pushm	r7,lr
80002b7c:	1a 97       	mov	r7,sp
80002b7e:	20 1d       	sub	sp,4
80002b80:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002b84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b88:	11 a8       	ld.ub	r8,r8[0x2]
80002b8a:	58 08       	cp.w	r8,0
80002b8c:	c0 71       	brne	80002b9a <AudioRoutingControl_reply_func+0x22>
	{
		log("AudioRouting OK");
80002b8e:	48 7c       	lddpc	r12,80002ba8 <AudioRoutingControl_reply_func+0x30>
80002b90:	f0 1f 00 07 	mcall	80002bac <AudioRoutingControl_reply_func+0x34>
		xcmp_IdleTestTone();//
80002b94:	f0 1f 00 07 	mcall	80002bb0 <AudioRoutingControl_reply_func+0x38>
80002b98:	c0 48       	rjmp	80002ba0 <AudioRoutingControl_reply_func+0x28>
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002b9a:	48 7c       	lddpc	r12,80002bb4 <AudioRoutingControl_reply_func+0x3c>
80002b9c:	f0 1f 00 04 	mcall	80002bac <AudioRoutingControl_reply_func+0x34>
		//log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
		
	}
}
80002ba0:	2f fd       	sub	sp,-4
80002ba2:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ba6:	00 00       	add	r0,r0
80002ba8:	80 00       	ld.sh	r0,r0[0x0]
80002baa:	22 40       	sub	r0,36
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	a3 80       	lsr	r0,0x2
80002bb0:	80 00       	ld.sh	r0,r0[0x0]
80002bb2:	67 00       	ld.w	r0,r3[0x40]
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	22 50       	sub	r0,37

80002bb8 <AudioRoutingControl_brdcst_func>:


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002bb8:	eb cd 40 80 	pushm	r7,lr
80002bbc:	1a 97       	mov	r7,sp
80002bbe:	20 2d       	sub	sp,8
80002bc0:	ef 4c ff f8 	st.w	r7[-8],r12
	
	U16 num_routings = 0;
80002bc4:	30 08       	mov	r8,0
80002bc6:	ef 58 ff fc 	st.h	r7[-4],r8
	U8 j = 0 ;
80002bca:	30 08       	mov	r8,0
80002bcc:	ef 68 ff ff 	st.b	r7[-1],r8
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
80002bd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bd4:	11 a8       	ld.ub	r8,r8[0x2]
80002bd6:	a9 68       	lsl	r8,0x8
80002bd8:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002bdc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002be0:	11 b8       	ld.ub	r8,r8[0x3]
80002be2:	f3 e8 10 08 	or	r8,r9,r8
80002be6:	5c 88       	casts.h	r8
80002be8:	ef 58 ff fc 	st.h	r7[-4],r8
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002bec:	2f ed       	sub	sp,-8
80002bee:	e3 cd 80 80 	ldm	sp++,r7,pc
80002bf2:	d7 03       	nop

80002bf4 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002bf4:	eb cd 40 80 	pushm	r7,lr
80002bf8:	1a 97       	mov	r7,sp
80002bfa:	20 2d       	sub	sp,8
80002bfc:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002c00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c04:	2f e8       	sub	r8,-2
80002c06:	ef 48 ff fc 	st.w	r7[-4],r8
	
	if (ptr->Result == xcmp_Res_Success)
80002c0a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c0e:	11 88       	ld.ub	r8,r8[0x0]
80002c10:	58 08       	cp.w	r8,0
80002c12:	c1 d1       	brne	80002c4c <TransmitControl_reply_func+0x58>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002c14:	49 1c       	lddpc	r12,80002c58 <TransmitControl_reply_func+0x64>
80002c16:	f0 1f 00 12 	mcall	80002c5c <TransmitControl_reply_func+0x68>
		log("\n\r Function: %x \n\r", ptr->Function);
80002c1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c1e:	11 98       	ld.ub	r8,r8[0x1]
80002c20:	1a d8       	st.w	--sp,r8
80002c22:	49 0c       	lddpc	r12,80002c60 <TransmitControl_reply_func+0x6c>
80002c24:	f0 1f 00 0e 	mcall	80002c5c <TransmitControl_reply_func+0x68>
80002c28:	2f fd       	sub	sp,-4
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002c2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c2e:	11 a8       	ld.ub	r8,r8[0x2]
80002c30:	1a d8       	st.w	--sp,r8
80002c32:	48 dc       	lddpc	r12,80002c64 <TransmitControl_reply_func+0x70>
80002c34:	f0 1f 00 0a 	mcall	80002c5c <TransmitControl_reply_func+0x68>
80002c38:	2f fd       	sub	sp,-4
		log("\n\r State: %x \n\r", ptr->State);
80002c3a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c3e:	11 b8       	ld.ub	r8,r8[0x3]
80002c40:	1a d8       	st.w	--sp,r8
80002c42:	48 ac       	lddpc	r12,80002c68 <TransmitControl_reply_func+0x74>
80002c44:	f0 1f 00 06 	mcall	80002c5c <TransmitControl_reply_func+0x68>
80002c48:	2f fd       	sub	sp,-4
80002c4a:	c0 48       	rjmp	80002c52 <TransmitControl_reply_func+0x5e>
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002c4c:	48 8c       	lddpc	r12,80002c6c <TransmitControl_reply_func+0x78>
80002c4e:	f0 1f 00 04 	mcall	80002c5c <TransmitControl_reply_func+0x68>
	}
	

}
80002c52:	2f ed       	sub	sp,-8
80002c54:	e3 cd 80 80 	ldm	sp++,r7,pc
80002c58:	80 00       	ld.sh	r0,r0[0x0]
80002c5a:	22 64       	sub	r4,38
80002c5c:	80 00       	ld.sh	r0,r0[0x0]
80002c5e:	a3 80       	lsr	r0,0x2
80002c60:	80 00       	ld.sh	r0,r0[0x0]
80002c62:	22 80       	sub	r0,40
80002c64:	80 00       	ld.sh	r0,r0[0x0]
80002c66:	22 94       	sub	r4,41
80002c68:	80 00       	ld.sh	r0,r0[0x0]
80002c6a:	22 b0       	sub	r0,43
80002c6c:	80 00       	ld.sh	r0,r0[0x0]
80002c6e:	22 c0       	sub	r0,44

80002c70 <TransmitControl_brdcst_func>:


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002c70:	eb cd 40 80 	pushm	r7,lr
80002c74:	1a 97       	mov	r7,sp
80002c76:	20 2d       	sub	sp,8
80002c78:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002c7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c80:	2f e8       	sub	r8,-2
80002c82:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002c86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c8a:	11 98       	ld.ub	r8,r8[0x1]
80002c8c:	58 08       	cp.w	r8,0
80002c8e:	c0 71       	brne	80002c9c <TransmitControl_brdcst_func+0x2c>
	{
		log("\n\r  Standby-Receive \n\r ");
80002c90:	48 bc       	lddpc	r12,80002cbc <TransmitControl_brdcst_func+0x4c>
80002c92:	f0 1f 00 0c 	mcall	80002cc0 <TransmitControl_brdcst_func+0x50>
		Radio_Transmit_State = 0;
80002c96:	48 c9       	lddpc	r9,80002cc4 <TransmitControl_brdcst_func+0x54>
80002c98:	30 08       	mov	r8,0
80002c9a:	b2 88       	st.b	r9[0x0],r8
	}
	if (ptr->State == 0x01)
80002c9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ca0:	11 99       	ld.ub	r9,r8[0x1]
80002ca2:	30 18       	mov	r8,1
80002ca4:	f0 09 18 00 	cp.b	r9,r8
80002ca8:	c0 71       	brne	80002cb6 <TransmitControl_brdcst_func+0x46>
	{
		log("\n\r  Transmit \n\r ");
80002caa:	48 8c       	lddpc	r12,80002cc8 <TransmitControl_brdcst_func+0x58>
80002cac:	f0 1f 00 05 	mcall	80002cc0 <TransmitControl_brdcst_func+0x50>
		Radio_Transmit_State = 1;
80002cb0:	48 59       	lddpc	r9,80002cc4 <TransmitControl_brdcst_func+0x54>
80002cb2:	30 18       	mov	r8,1
80002cb4:	b2 88       	st.b	r9[0x0],r8
	//log("\n\r  State: %x \n\r ", ptr->State );
	//log("\n\r  State_change_reason: %x \n\r ", ptr->State_change_reason );
	//
	
	
}
80002cb6:	2f ed       	sub	sp,-8
80002cb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80002cbc:	80 00       	ld.sh	r0,r0[0x0]
80002cbe:	22 d8       	sub	r8,45
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	a3 80       	lsr	r0,0x2
80002cc4:	00 00       	add	r0,r0
80002cc6:	0a 5c       	eor	r12,r5
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	22 f0       	sub	r0,47

80002ccc <CallControl_brdcst_func>:


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002ccc:	eb cd 40 80 	pushm	r7,lr
80002cd0:	1a 97       	mov	r7,sp
80002cd2:	20 2d       	sub	sp,8
80002cd4:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002cd8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cdc:	2f e8       	sub	r8,-2
80002cde:	ef 48 ff fc 	st.w	r7[-4],r8
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002ce2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ce6:	11 98       	ld.ub	r8,r8[0x1]
80002ce8:	1a d8       	st.w	--sp,r8
80002cea:	48 ec       	lddpc	r12,80002d20 <CallControl_brdcst_func+0x54>
80002cec:	f0 1f 00 0e 	mcall	80002d24 <CallControl_brdcst_func+0x58>
80002cf0:	2f fd       	sub	sp,-4
	if (ptr->Callstate == Call_Ended)//0x03
80002cf2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cf6:	11 99       	ld.ub	r9,r8[0x1]
80002cf8:	30 38       	mov	r8,3
80002cfa:	f0 09 18 00 	cp.b	r9,r8
80002cfe:	c0 41       	brne	80002d06 <CallControl_brdcst_func+0x3a>
	{
		//
		//xcmp_audio_route_revert();
		Call_Begin = 0;
80002d00:	48 a9       	lddpc	r9,80002d28 <CallControl_brdcst_func+0x5c>
80002d02:	30 08       	mov	r8,0
80002d04:	b2 88       	st.b	r9[0x0],r8
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002d06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d0a:	11 99       	ld.ub	r9,r8[0x1]
80002d0c:	30 48       	mov	r8,4
80002d0e:	f0 09 18 00 	cp.b	r9,r8
80002d12:	c0 41       	brne	80002d1a <CallControl_brdcst_func+0x4e>
	{
		Call_Begin = 1;
80002d14:	48 59       	lddpc	r9,80002d28 <CallControl_brdcst_func+0x5c>
80002d16:	30 18       	mov	r8,1
80002d18:	b2 88       	st.b	r9[0x0],r8
		//xcmp_audio_route_decoder_AMBE();

	}
	
	
}
80002d1a:	2f ed       	sub	sp,-8
80002d1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d20:	80 00       	ld.sh	r0,r0[0x0]
80002d22:	23 04       	sub	r4,48
80002d24:	80 00       	ld.sh	r0,r0[0x0]
80002d26:	a3 80       	lsr	r0,0x2
80002d28:	00 00       	add	r0,r0
80002d2a:	0a 5e       	eor	lr,r5

80002d2c <DataSession_reply_func>:



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002d2c:	eb cd 40 80 	pushm	r7,lr
80002d30:	1a 97       	mov	r7,sp
80002d32:	20 1d       	sub	sp,4
80002d34:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002d38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d3c:	11 a8       	ld.ub	r8,r8[0x2]
80002d3e:	58 08       	cp.w	r8,0
80002d40:	c0 51       	brne	80002d4a <DataSession_reply_func+0x1e>
	{
		log("\n\r DATArep OK \n\r");
80002d42:	49 2c       	lddpc	r12,80002d88 <DataSession_reply_func+0x5c>
80002d44:	f0 1f 00 12 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d48:	c1 c8       	rjmp	80002d80 <DataSession_reply_func+0x54>
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002d4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d4e:	11 a8       	ld.ub	r8,r8[0x2]
80002d50:	1a d8       	st.w	--sp,r8
80002d52:	49 0c       	lddpc	r12,80002d90 <DataSession_reply_func+0x64>
80002d54:	f0 1f 00 0e 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d58:	2f fd       	sub	sp,-4
		log("\n\r DATArep error \n\r");
80002d5a:	48 fc       	lddpc	r12,80002d94 <DataSession_reply_func+0x68>
80002d5c:	f0 1f 00 0c 	mcall	80002d8c <DataSession_reply_func+0x60>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002d60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d64:	11 b8       	ld.ub	r8,r8[0x3]
80002d66:	1a d8       	st.w	--sp,r8
80002d68:	48 cc       	lddpc	r12,80002d98 <DataSession_reply_func+0x6c>
80002d6a:	f0 1f 00 09 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d6e:	2f fd       	sub	sp,-4
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
80002d70:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d74:	11 c8       	ld.ub	r8,r8[0x4]
80002d76:	1a d8       	st.w	--sp,r8
80002d78:	48 9c       	lddpc	r12,80002d9c <DataSession_reply_func+0x70>
80002d7a:	f0 1f 00 05 	mcall	80002d8c <DataSession_reply_func+0x60>
80002d7e:	2f fd       	sub	sp,-4
	}
	
}
80002d80:	2f fd       	sub	sp,-4
80002d82:	e3 cd 80 80 	ldm	sp++,r7,pc
80002d86:	00 00       	add	r0,r0
80002d88:	80 00       	ld.sh	r0,r0[0x0]
80002d8a:	23 1c       	sub	r12,49
80002d8c:	80 00       	ld.sh	r0,r0[0x0]
80002d8e:	a3 80       	lsr	r0,0x2
80002d90:	80 00       	ld.sh	r0,r0[0x0]
80002d92:	23 30       	sub	r0,51
80002d94:	80 00       	ld.sh	r0,r0[0x0]
80002d96:	23 44       	sub	r4,52
80002d98:	80 00       	ld.sh	r0,r0[0x0]
80002d9a:	23 58       	sub	r8,53
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	23 68       	sub	r8,54

80002da0 <DataSession_brdcst_func>:

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002da0:	eb cd 40 80 	pushm	r7,lr
80002da4:	1a 97       	mov	r7,sp
80002da6:	20 4d       	sub	sp,16
80002da8:	ef 4c ff f0 	st.w	r7[-16],r12
	U8 Session_number = 0;
80002dac:	30 08       	mov	r8,0
80002dae:	ef 68 ff f7 	st.b	r7[-9],r8
	U16 data_length = 0;
80002db2:	30 08       	mov	r8,0
80002db4:	ef 58 ff f8 	st.h	r7[-8],r8
	U8 i = 0;
80002db8:	30 08       	mov	r8,0
80002dba:	ef 68 ff fb 	st.b	r7[-5],r8
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002dbe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002dc2:	2f e8       	sub	r8,-2
80002dc4:	ef 48 ff fc 	st.w	r7[-4],r8

	if (ptr->State == CSBK_DATA_RX_Suc)
80002dc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dcc:	11 89       	ld.ub	r9,r8[0x0]
80002dce:	32 48       	mov	r8,36
80002dd0:	f0 09 18 00 	cp.b	r9,r8
80002dd4:	c4 71       	brne	80002e62 <DataSession_brdcst_func+0xc2>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002dd6:	4a 9c       	lddpc	r12,80002e78 <DataSession_brdcst_func+0xd8>
80002dd8:	f0 1f 00 29 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
80002ddc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002de0:	11 98       	ld.ub	r8,r8[0x1]
80002de2:	ef 68 ff f7 	st.b	r7[-9],r8
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002de6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dea:	11 a8       	ld.ub	r8,r8[0x2]
80002dec:	a9 68       	lsl	r8,0x8
80002dee:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002df2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002df6:	11 b8       	ld.ub	r8,r8[0x3]
80002df8:	f3 e8 10 08 	or	r8,r9,r8
80002dfc:	5c 88       	casts.h	r8
80002dfe:	ef 58 ff f8 	st.h	r7[-8],r8

		log("\n\r Session_ID: %x \n\r",Session_number );
80002e02:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80002e06:	1a d8       	st.w	--sp,r8
80002e08:	49 ec       	lddpc	r12,80002e80 <DataSession_brdcst_func+0xe0>
80002e0a:	f0 1f 00 1d 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e0e:	2f fd       	sub	sp,-4
		log("\n\r paylaod_length: %d \n\r",data_length );
80002e10:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80002e14:	1a d8       	st.w	--sp,r8
80002e16:	49 cc       	lddpc	r12,80002e84 <DataSession_brdcst_func+0xe4>
80002e18:	f0 1f 00 19 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e1c:	2f fd       	sub	sp,-4
		for(i=0; i<data_length; i++)
80002e1e:	30 08       	mov	r8,0
80002e20:	ef 68 ff fb 	st.b	r7[-5],r8
80002e24:	c1 68       	rjmp	80002e50 <DataSession_brdcst_func+0xb0>
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002e26:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e2a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002e2e:	f2 08 00 08 	add	r8,r9,r8
80002e32:	11 c8       	ld.ub	r8,r8[0x4]
80002e34:	10 99       	mov	r9,r8
80002e36:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e3a:	1a d9       	st.w	--sp,r9
80002e3c:	1a d8       	st.w	--sp,r8
80002e3e:	49 3c       	lddpc	r12,80002e88 <DataSession_brdcst_func+0xe8>
80002e40:	f0 1f 00 0f 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e44:	2f ed       	sub	sp,-8
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002e46:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e4a:	2f f8       	sub	r8,-1
80002e4c:	ef 68 ff fb 	st.b	r7[-5],r8
80002e50:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80002e54:	ef 09 ff f8 	ld.sh	r9,r7[-8]
80002e58:	f0 09 19 00 	cp.h	r9,r8
80002e5c:	fe 9b ff e5 	brhi	80002e26 <DataSession_brdcst_func+0x86>
80002e60:	c0 98       	rjmp	80002e72 <DataSession_brdcst_func+0xd2>
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002e62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e66:	11 88       	ld.ub	r8,r8[0x0]
80002e68:	1a d8       	st.w	--sp,r8
80002e6a:	48 9c       	lddpc	r12,80002e8c <DataSession_brdcst_func+0xec>
80002e6c:	f0 1f 00 04 	mcall	80002e7c <DataSession_brdcst_func+0xdc>
80002e70:	2f fd       	sub	sp,-4
		
	}
	
}
80002e72:	2f cd       	sub	sp,-16
80002e74:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e78:	80 00       	ld.sh	r0,r0[0x0]
80002e7a:	23 78       	sub	r8,55
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	a3 80       	lsr	r0,0x2
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	23 8c       	sub	r12,56
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	23 a4       	sub	r4,58
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	23 c0       	sub	r0,60
80002e8c:	80 00       	ld.sh	r0,r0[0x0]
80002e8e:	23 d8       	sub	r8,61

80002e90 <ButtonConfig_reply_func>:

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002e90:	eb cd 40 80 	pushm	r7,lr
80002e94:	1a 97       	mov	r7,sp
80002e96:	20 2d       	sub	sp,8
80002e98:	ef 4c ff f8 	st.w	r7[-8],r12
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002e9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ea0:	2f e8       	sub	r8,-2
80002ea2:	ef 48 ff fc 	st.w	r7[-4],r8
	if (ptr->Result == xcmp_Res_Success)
80002ea6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002eaa:	11 88       	ld.ub	r8,r8[0x0]
80002eac:	58 08       	cp.w	r8,0
80002eae:	c0 d1       	brne	80002ec8 <ButtonConfig_reply_func+0x38>
	{
		log("\n\r Button_Config OK \n\r");
80002eb0:	48 9c       	lddpc	r12,80002ed4 <ButtonConfig_reply_func+0x44>
80002eb2:	f0 1f 00 0a 	mcall	80002ed8 <ButtonConfig_reply_func+0x48>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002eb6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002eba:	11 98       	ld.ub	r8,r8[0x1]
80002ebc:	1a d8       	st.w	--sp,r8
80002ebe:	48 8c       	lddpc	r12,80002edc <ButtonConfig_reply_func+0x4c>
80002ec0:	f0 1f 00 06 	mcall	80002ed8 <ButtonConfig_reply_func+0x48>
80002ec4:	2f fd       	sub	sp,-4
80002ec6:	c0 48       	rjmp	80002ece <ButtonConfig_reply_func+0x3e>
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002ec8:	48 6c       	lddpc	r12,80002ee0 <ButtonConfig_reply_func+0x50>
80002eca:	f0 1f 00 04 	mcall	80002ed8 <ButtonConfig_reply_func+0x48>
	}
	
}
80002ece:	2f ed       	sub	sp,-8
80002ed0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	23 ec       	sub	r12,62
80002ed8:	80 00       	ld.sh	r0,r0[0x0]
80002eda:	a3 80       	lsr	r0,0x2
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	24 04       	sub	r4,64
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	24 18       	sub	r8,65

80002ee4 <Phyuserinput_brdcst_func>:


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002ee4:	eb cd 40 80 	pushm	r7,lr
80002ee8:	1a 97       	mov	r7,sp
80002eea:	20 3d       	sub	sp,12
80002eec:	ef 4c ff f4 	st.w	r7[-12],r12
	U8 PUI_Source =0;
80002ef0:	30 08       	mov	r8,0
80002ef2:	ef 68 ff f8 	st.b	r7[-8],r8
	U8 PUI_Type =0;
80002ef6:	30 08       	mov	r8,0
80002ef8:	ef 68 ff f9 	st.b	r7[-7],r8
	U16 PUI_ID =0;
80002efc:	30 08       	mov	r8,0
80002efe:	ef 58 ff fa 	st.h	r7[-6],r8
	U8 PUI_State =0;
80002f02:	30 08       	mov	r8,0
80002f04:	ef 68 ff fd 	st.b	r7[-3],r8
	U8 PUI_State_Min_Value =0;
80002f08:	30 08       	mov	r8,0
80002f0a:	ef 68 ff fe 	st.b	r7[-2],r8
	U8 PUI_State_Max_Value =0;
80002f0e:	30 08       	mov	r8,0
80002f10:	ef 68 ff ff 	st.b	r7[-1],r8
	
	PUI_Source = xcmp->u8[0];
80002f14:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f18:	11 a8       	ld.ub	r8,r8[0x2]
80002f1a:	ef 68 ff f8 	st.b	r7[-8],r8
	PUI_Type = xcmp ->u8[1];
80002f1e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f22:	11 b8       	ld.ub	r8,r8[0x3]
80002f24:	ef 68 ff f9 	st.b	r7[-7],r8
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002f28:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f2c:	11 c8       	ld.ub	r8,r8[0x4]
80002f2e:	a9 68       	lsl	r8,0x8
80002f30:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80002f34:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f38:	11 d8       	ld.ub	r8,r8[0x5]
80002f3a:	f3 e8 10 08 	or	r8,r9,r8
80002f3e:	5c 88       	casts.h	r8
80002f40:	ef 58 ff fa 	st.h	r7[-6],r8
	PUI_State = xcmp->u8[4];
80002f44:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f48:	11 e8       	ld.ub	r8,r8[0x6]
80002f4a:	ef 68 ff fd 	st.b	r7[-3],r8
	PUI_State_Min_Value = xcmp->u8[5];
80002f4e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f52:	11 f8       	ld.ub	r8,r8[0x7]
80002f54:	ef 68 ff fe 	st.b	r7[-2],r8
	PUI_State_Max_Value = xcmp->u8[6];
80002f58:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f5c:	f1 38 00 08 	ld.ub	r8,r8[8]
80002f60:	ef 68 ff ff 	st.b	r7[-1],r8
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002f64:	49 8c       	lddpc	r12,80002fc4 <Phyuserinput_brdcst_func+0xe0>
80002f66:	f0 1f 00 19 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002f6a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80002f6e:	1a d8       	st.w	--sp,r8
80002f70:	49 7c       	lddpc	r12,80002fcc <Phyuserinput_brdcst_func+0xe8>
80002f72:	f0 1f 00 16 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002f76:	2f fd       	sub	sp,-4
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002f78:	ef 38 ff f9 	ld.ub	r8,r7[-7]
80002f7c:	1a d8       	st.w	--sp,r8
80002f7e:	49 5c       	lddpc	r12,80002fd0 <Phyuserinput_brdcst_func+0xec>
80002f80:	f0 1f 00 12 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002f84:	2f fd       	sub	sp,-4
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
80002f86:	ef 18 ff fa 	ld.uh	r8,r7[-6]
80002f8a:	1a d8       	st.w	--sp,r8
80002f8c:	49 2c       	lddpc	r12,80002fd4 <Phyuserinput_brdcst_func+0xf0>
80002f8e:	f0 1f 00 0f 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002f92:	2f fd       	sub	sp,-4
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002f94:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80002f98:	1a d8       	st.w	--sp,r8
80002f9a:	49 0c       	lddpc	r12,80002fd8 <Phyuserinput_brdcst_func+0xf4>
80002f9c:	f0 1f 00 0b 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002fa0:	2f fd       	sub	sp,-4
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002fa2:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80002fa6:	1a d8       	st.w	--sp,r8
80002fa8:	48 dc       	lddpc	r12,80002fdc <Phyuserinput_brdcst_func+0xf8>
80002faa:	f0 1f 00 08 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002fae:	2f fd       	sub	sp,-4
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002fb0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002fb4:	1a d8       	st.w	--sp,r8
80002fb6:	48 bc       	lddpc	r12,80002fe0 <Phyuserinput_brdcst_func+0xfc>
80002fb8:	f0 1f 00 04 	mcall	80002fc8 <Phyuserinput_brdcst_func+0xe4>
80002fbc:	2f fd       	sub	sp,-4
	
	
	
	
	
}
80002fbe:	2f dd       	sub	sp,-12
80002fc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	24 34       	sub	r4,67
80002fc8:	80 00       	ld.sh	r0,r0[0x0]
80002fca:	a3 80       	lsr	r0,0x2
80002fcc:	80 00       	ld.sh	r0,r0[0x0]
80002fce:	24 58       	sub	r8,69
80002fd0:	80 00       	ld.sh	r0,r0[0x0]
80002fd2:	24 70       	sub	r0,71
80002fd4:	80 00       	ld.sh	r0,r0[0x0]
80002fd6:	24 84       	sub	r4,72
80002fd8:	80 00       	ld.sh	r0,r0[0x0]
80002fda:	24 98       	sub	r8,73
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	24 ac       	sub	r12,74
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	24 cc       	sub	r12,76

80002fe4 <ButtonConfig_brdcst_func>:


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002fe4:	eb cd 40 80 	pushm	r7,lr
80002fe8:	1a 97       	mov	r7,sp
80002fea:	20 3d       	sub	sp,12
80002fec:	ef 4c ff f4 	st.w	r7[-12],r12
	U8 Num_Button =0;
80002ff0:	30 08       	mov	r8,0
80002ff2:	ef 68 ff fa 	st.b	r7[-6],r8
	U8 i = 0 ;
80002ff6:	30 08       	mov	r8,0
80002ff8:	ef 68 ff fb 	st.b	r7[-5],r8
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002ffc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003000:	2f e8       	sub	r8,-2
80003002:	ef 48 ff fc 	st.w	r7[-4],r8
	
	Num_Button = ptr->NumOfButtons;
80003006:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000300a:	11 98       	ld.ub	r8,r8[0x1]
8000300c:	ef 68 ff fa 	st.b	r7[-6],r8
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80003010:	4f 0c       	lddpc	r12,800031d0 <ButtonConfig_brdcst_func+0x1ec>
80003012:	f0 1f 00 71 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
80003016:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000301a:	11 88       	ld.ub	r8,r8[0x0]
8000301c:	1a d8       	st.w	--sp,r8
8000301e:	4e fc       	lddpc	r12,800031d8 <ButtonConfig_brdcst_func+0x1f4>
80003020:	f0 1f 00 6d 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003024:	2f fd       	sub	sp,-4
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80003026:	ef 38 ff fa 	ld.ub	r8,r7[-6]
8000302a:	1a d8       	st.w	--sp,r8
8000302c:	4e cc       	lddpc	r12,800031dc <ButtonConfig_brdcst_func+0x1f8>
8000302e:	f0 1f 00 6a 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003032:	2f fd       	sub	sp,-4
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80003034:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003038:	11 a8       	ld.ub	r8,r8[0x2]
8000303a:	1a d8       	st.w	--sp,r8
8000303c:	4e 9c       	lddpc	r12,800031e0 <ButtonConfig_brdcst_func+0x1fc>
8000303e:	f0 1f 00 66 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003042:	2f fd       	sub	sp,-4
	
	for (i; i<Num_Button; i++)
80003044:	cb a8       	rjmp	800031b8 <ButtonConfig_brdcst_func+0x1d4>
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
80003046:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000304a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000304e:	12 98       	mov	r8,r9
80003050:	a3 68       	lsl	r8,0x2
80003052:	12 08       	add	r8,r9
80003054:	a1 78       	lsl	r8,0x1
80003056:	f4 08 00 08 	add	r8,r10,r8
8000305a:	2f d8       	sub	r8,-3
8000305c:	11 88       	ld.ub	r8,r8[0x0]
8000305e:	f0 0a 15 08 	lsl	r10,r8,0x8
80003062:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003066:	ee fb ff fc 	ld.w	r11,r7[-4]
8000306a:	12 98       	mov	r8,r9
8000306c:	a3 68       	lsl	r8,0x2
8000306e:	12 08       	add	r8,r9
80003070:	a1 78       	lsl	r8,0x1
80003072:	f6 08 00 08 	add	r8,r11,r8
80003076:	2f c8       	sub	r8,-4
80003078:	11 88       	ld.ub	r8,r8[0x0]
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000307a:	f5 e8 10 09 	or	r9,r10,r8
8000307e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80003082:	1a d9       	st.w	--sp,r9
80003084:	1a d8       	st.w	--sp,r8
80003086:	4d 8c       	lddpc	r12,800031e4 <ButtonConfig_brdcst_func+0x200>
80003088:	f0 1f 00 53 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
8000308c:	2f ed       	sub	sp,-8
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
8000308e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003092:	ee fa ff fc 	ld.w	r10,r7[-4]
80003096:	12 98       	mov	r8,r9
80003098:	a3 68       	lsl	r8,0x2
8000309a:	12 08       	add	r8,r9
8000309c:	a1 78       	lsl	r8,0x1
8000309e:	f4 08 00 08 	add	r8,r10,r8
800030a2:	2f b8       	sub	r8,-5
800030a4:	11 88       	ld.ub	r8,r8[0x0]
800030a6:	f0 0a 15 08 	lsl	r10,r8,0x8
800030aa:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030ae:	ee fb ff fc 	ld.w	r11,r7[-4]
800030b2:	12 98       	mov	r8,r9
800030b4:	a3 68       	lsl	r8,0x2
800030b6:	12 08       	add	r8,r9
800030b8:	a1 78       	lsl	r8,0x1
800030ba:	f6 08 00 08 	add	r8,r11,r8
800030be:	2f a8       	sub	r8,-6
800030c0:	11 88       	ld.ub	r8,r8[0x0]
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800030c2:	f5 e8 10 09 	or	r9,r10,r8
800030c6:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800030ca:	1a d9       	st.w	--sp,r9
800030cc:	1a d8       	st.w	--sp,r8
800030ce:	4c 7c       	lddpc	r12,800031e8 <ButtonConfig_brdcst_func+0x204>
800030d0:	f0 1f 00 41 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
800030d4:	2f ed       	sub	sp,-8
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
800030d6:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030da:	ee fa ff fc 	ld.w	r10,r7[-4]
800030de:	12 98       	mov	r8,r9
800030e0:	a3 68       	lsl	r8,0x2
800030e2:	12 08       	add	r8,r9
800030e4:	a1 78       	lsl	r8,0x1
800030e6:	f4 08 00 08 	add	r8,r10,r8
800030ea:	2f 98       	sub	r8,-7
800030ec:	11 88       	ld.ub	r8,r8[0x0]
800030ee:	f0 0a 15 08 	lsl	r10,r8,0x8
800030f2:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800030f6:	ee fb ff fc 	ld.w	r11,r7[-4]
800030fa:	12 98       	mov	r8,r9
800030fc:	a3 68       	lsl	r8,0x2
800030fe:	12 08       	add	r8,r9
80003100:	a1 78       	lsl	r8,0x1
80003102:	f6 08 00 08 	add	r8,r11,r8
80003106:	2f 88       	sub	r8,-8
80003108:	11 88       	ld.ub	r8,r8[0x0]
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000310a:	f5 e8 10 09 	or	r9,r10,r8
8000310e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80003112:	1a d9       	st.w	--sp,r9
80003114:	1a d8       	st.w	--sp,r8
80003116:	4b 6c       	lddpc	r12,800031ec <ButtonConfig_brdcst_func+0x208>
80003118:	f0 1f 00 2f 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
8000311c:	2f ed       	sub	sp,-8
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
8000311e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003122:	ee fa ff fc 	ld.w	r10,r7[-4]
80003126:	12 98       	mov	r8,r9
80003128:	a3 68       	lsl	r8,0x2
8000312a:	12 08       	add	r8,r9
8000312c:	a1 78       	lsl	r8,0x1
8000312e:	f4 08 00 08 	add	r8,r10,r8
80003132:	2f 78       	sub	r8,-9
80003134:	11 88       	ld.ub	r8,r8[0x0]
80003136:	f0 0a 15 08 	lsl	r10,r8,0x8
8000313a:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000313e:	ee fb ff fc 	ld.w	r11,r7[-4]
80003142:	12 98       	mov	r8,r9
80003144:	a3 68       	lsl	r8,0x2
80003146:	12 08       	add	r8,r9
80003148:	a1 78       	lsl	r8,0x1
8000314a:	f6 08 00 08 	add	r8,r11,r8
8000314e:	2f 68       	sub	r8,-10
80003150:	11 88       	ld.ub	r8,r8[0x0]
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80003152:	f5 e8 10 09 	or	r9,r10,r8
80003156:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000315a:	1a d9       	st.w	--sp,r9
8000315c:	1a d8       	st.w	--sp,r8
8000315e:	4a 5c       	lddpc	r12,800031f0 <ButtonConfig_brdcst_func+0x20c>
80003160:	f0 1f 00 1d 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
80003164:	2f ed       	sub	sp,-8
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
				(ptr->ButtonInfo[i].Reserved2[0]<<8) | (ptr->ButtonInfo[i].Reserved2[1]));
80003166:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000316a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000316e:	12 98       	mov	r8,r9
80003170:	a3 68       	lsl	r8,0x2
80003172:	12 08       	add	r8,r9
80003174:	a1 78       	lsl	r8,0x1
80003176:	f4 08 00 08 	add	r8,r10,r8
8000317a:	2f 58       	sub	r8,-11
8000317c:	11 88       	ld.ub	r8,r8[0x0]
8000317e:	f0 0a 15 08 	lsl	r10,r8,0x8
80003182:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003186:	ee fb ff fc 	ld.w	r11,r7[-4]
8000318a:	12 98       	mov	r8,r9
8000318c:	a3 68       	lsl	r8,0x2
8000318e:	12 08       	add	r8,r9
80003190:	a1 78       	lsl	r8,0x1
80003192:	f6 08 00 08 	add	r8,r11,r8
80003196:	2f 48       	sub	r8,-12
80003198:	11 88       	ld.ub	r8,r8[0x0]
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000319a:	f5 e8 10 09 	or	r9,r10,r8
8000319e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800031a2:	1a d9       	st.w	--sp,r9
800031a4:	1a d8       	st.w	--sp,r8
800031a6:	49 4c       	lddpc	r12,800031f4 <ButtonConfig_brdcst_func+0x210>
800031a8:	f0 1f 00 0b 	mcall	800031d4 <ButtonConfig_brdcst_func+0x1f0>
800031ac:	2f ed       	sub	sp,-8
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800031ae:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800031b2:	2f f8       	sub	r8,-1
800031b4:	ef 68 ff fb 	st.b	r7[-5],r8
800031b8:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800031bc:	ef 38 ff fa 	ld.ub	r8,r7[-6]
800031c0:	f0 09 18 00 	cp.b	r9,r8
800031c4:	fe 93 ff 41 	brlo	80003046 <ButtonConfig_brdcst_func+0x62>
		
	}
	

	
}
800031c8:	2f dd       	sub	sp,-12
800031ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800031ce:	00 00       	add	r0,r0
800031d0:	80 00       	ld.sh	r0,r0[0x0]
800031d2:	24 ec       	sub	r12,78
800031d4:	80 00       	ld.sh	r0,r0[0x0]
800031d6:	a3 80       	lsr	r0,0x2
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	24 04       	sub	r4,64
800031dc:	80 00       	ld.sh	r0,r0[0x0]
800031de:	25 0c       	sub	r12,80
800031e0:	80 00       	ld.sh	r0,r0[0x0]
800031e2:	25 24       	sub	r4,82
800031e4:	80 00       	ld.sh	r0,r0[0x0]
800031e6:	25 44       	sub	r4,84
800031e8:	80 00       	ld.sh	r0,r0[0x0]
800031ea:	25 6c       	sub	r12,86
800031ec:	80 00       	ld.sh	r0,r0[0x0]
800031ee:	25 94       	sub	r4,89
800031f0:	80 00       	ld.sh	r0,r0[0x0]
800031f2:	25 b8       	sub	r8,91
800031f4:	80 00       	ld.sh	r0,r0[0x0]
800031f6:	25 e0       	sub	r0,94

800031f8 <SingleDetection_brdcst_func>:


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800031f8:	eb cd 40 80 	pushm	r7,lr
800031fc:	1a 97       	mov	r7,sp
800031fe:	20 1d       	sub	sp,4
80003200:	ef 4c ff fc 	st.w	r7[-4],r12
	if (xcmp->u8[0] == 0x11)
80003204:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003208:	11 a9       	ld.ub	r9,r8[0x2]
8000320a:	31 18       	mov	r8,17
8000320c:	f0 09 18 00 	cp.b	r9,r8
80003210:	c0 41       	brne	80003218 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
80003212:	48 4c       	lddpc	r12,80003220 <SingleDetection_brdcst_func+0x28>
80003214:	f0 1f 00 04 	mcall	80003224 <SingleDetection_brdcst_func+0x2c>
		//log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
	}
	

	//;
}
80003218:	2f fd       	sub	sp,-4
8000321a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000321e:	00 00       	add	r0,r0
80003220:	80 00       	ld.sh	r0,r0[0x0]
80003222:	26 04       	sub	r4,96
80003224:	80 00       	ld.sh	r0,r0[0x0]
80003226:	a3 80       	lsr	r0,0x2

80003228 <EnOB_reply_func>:



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80003228:	eb cd 40 80 	pushm	r7,lr
8000322c:	1a 97       	mov	r7,sp
8000322e:	20 1d       	sub	sp,4
80003230:	ef 4c ff fc 	st.w	r7[-4],r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80003234:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003238:	11 a8       	ld.ub	r8,r8[0x2]
8000323a:	58 08       	cp.w	r8,0
8000323c:	c1 e1       	brne	80003278 <EnOB_reply_func+0x50>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
8000323e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003242:	11 b9       	ld.ub	r9,r8[0x3]
80003244:	30 18       	mov	r8,1
80003246:	f0 09 18 00 	cp.b	r9,r8
8000324a:	c0 51       	brne	80003254 <EnOB_reply_func+0x2c>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000324c:	49 2c       	lddpc	r12,80003294 <EnOB_reply_func+0x6c>
8000324e:	f0 1f 00 13 	mcall	80003298 <EnOB_reply_func+0x70>
80003252:	c1 e8       	rjmp	8000328e <EnOB_reply_func+0x66>
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80003254:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003258:	11 b8       	ld.ub	r8,r8[0x3]
8000325a:	58 08       	cp.w	r8,0
8000325c:	c0 51       	brne	80003266 <EnOB_reply_func+0x3e>
		{
			log("\n\r En_OB_Exit OK \n\r");
8000325e:	49 0c       	lddpc	r12,8000329c <EnOB_reply_func+0x74>
80003260:	f0 1f 00 0e 	mcall	80003298 <EnOB_reply_func+0x70>
80003264:	c1 58       	rjmp	8000328e <EnOB_reply_func+0x66>
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
80003266:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000326a:	11 b8       	ld.ub	r8,r8[0x3]
8000326c:	1a d8       	st.w	--sp,r8
8000326e:	48 dc       	lddpc	r12,800032a0 <EnOB_reply_func+0x78>
80003270:	f0 1f 00 0a 	mcall	80003298 <EnOB_reply_func+0x70>
80003274:	2f fd       	sub	sp,-4
80003276:	c0 c8       	rjmp	8000328e <EnOB_reply_func+0x66>
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80003278:	48 bc       	lddpc	r12,800032a4 <EnOB_reply_func+0x7c>
8000327a:	f0 1f 00 08 	mcall	80003298 <EnOB_reply_func+0x70>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000327e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003282:	11 a8       	ld.ub	r8,r8[0x2]
80003284:	1a d8       	st.w	--sp,r8
80003286:	48 9c       	lddpc	r12,800032a8 <EnOB_reply_func+0x80>
80003288:	f0 1f 00 04 	mcall	80003298 <EnOB_reply_func+0x70>
8000328c:	2f fd       	sub	sp,-4
		
	}
	
	
}
8000328e:	2f fd       	sub	sp,-4
80003290:	e3 cd 80 80 	ldm	sp++,r7,pc
80003294:	80 00       	ld.sh	r0,r0[0x0]
80003296:	26 18       	sub	r8,97
80003298:	80 00       	ld.sh	r0,r0[0x0]
8000329a:	a3 80       	lsr	r0,0x2
8000329c:	80 00       	ld.sh	r0,r0[0x0]
8000329e:	26 30       	sub	r0,99
800032a0:	80 00       	ld.sh	r0,r0[0x0]
800032a2:	26 44       	sub	r4,100
800032a4:	80 00       	ld.sh	r0,r0[0x0]
800032a6:	26 5c       	sub	r12,101
800032a8:	80 00       	ld.sh	r0,r0[0x0]
800032aa:	26 78       	sub	r8,103

800032ac <EnOB_brdcst_func>:

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800032ac:	eb cd 40 80 	pushm	r7,lr
800032b0:	1a 97       	mov	r7,sp
800032b2:	20 1d       	sub	sp,4
800032b4:	ef 4c ff fc 	st.w	r7[-4],r12
	
	
	log("\n\r En_OB Broadcast \n\r");
800032b8:	48 3c       	lddpc	r12,800032c4 <EnOB_brdcst_func+0x18>
800032ba:	f0 1f 00 04 	mcall	800032c8 <EnOB_brdcst_func+0x1c>
}
800032be:	2f fd       	sub	sp,-4
800032c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800032c4:	80 00       	ld.sh	r0,r0[0x0]
800032c6:	26 90       	sub	r0,105
800032c8:	80 00       	ld.sh	r0,r0[0x0]
800032ca:	a3 80       	lsr	r0,0x2

800032cc <FD_request_func>:



void FD_request_func(xcmp_fragment_t * xcmp)
{
800032cc:	eb cd 40 80 	pushm	r7,lr
800032d0:	1a 97       	mov	r7,sp
800032d2:	20 1d       	sub	sp,4
800032d4:	ef 4c ff fc 	st.w	r7[-4],r12
	
	log("\n\r Forward Data Request \n\r");
800032d8:	48 3c       	lddpc	r12,800032e4 <FD_request_func+0x18>
800032da:	f0 1f 00 04 	mcall	800032e8 <FD_request_func+0x1c>
	
	
}
800032de:	2f fd       	sub	sp,-4
800032e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800032e4:	80 00       	ld.sh	r0,r0[0x0]
800032e6:	26 a8       	sub	r8,106
800032e8:	80 00       	ld.sh	r0,r0[0x0]
800032ea:	a3 80       	lsr	r0,0x2

800032ec <FD_reply_func>:

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800032ec:	eb cd 40 80 	pushm	r7,lr
800032f0:	1a 97       	mov	r7,sp
800032f2:	20 1d       	sub	sp,4
800032f4:	ef 4c ff fc 	st.w	r7[-4],r12
	
	log("\n\r Forward Data Reply \n\r");
800032f8:	48 3c       	lddpc	r12,80003304 <FD_reply_func+0x18>
800032fa:	f0 1f 00 04 	mcall	80003308 <FD_reply_func+0x1c>
	
	
}
800032fe:	2f fd       	sub	sp,-4
80003300:	e3 cd 80 80 	ldm	sp++,r7,pc
80003304:	80 00       	ld.sh	r0,r0[0x0]
80003306:	26 c4       	sub	r4,108
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	a3 80       	lsr	r0,0x2

8000330c <FD_brdcst_func>:

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000330c:	eb cd 40 80 	pushm	r7,lr
80003310:	1a 97       	mov	r7,sp
80003312:	20 1d       	sub	sp,4
80003314:	ef 4c ff fc 	st.w	r7[-4],r12
	
	
	log("\n\r Forward Data Broadcast \n\r");
80003318:	48 3c       	lddpc	r12,80003324 <FD_brdcst_func+0x18>
8000331a:	f0 1f 00 04 	mcall	80003328 <FD_brdcst_func+0x1c>
	
}
8000331e:	2f fd       	sub	sp,-4
80003320:	e3 cd 80 80 	ldm	sp++,r7,pc
80003324:	80 00       	ld.sh	r0,r0[0x0]
80003326:	26 e0       	sub	r0,110
80003328:	80 00       	ld.sh	r0,r0[0x0]
8000332a:	a3 80       	lsr	r0,0x2

8000332c <app_init>:
														
		
};

void app_init(void)
{	
8000332c:	eb cd 40 80 	pushm	r7,lr
80003330:	1a 97       	mov	r7,sp
	//app_payload_rx_procPCM
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80003332:	48 eb       	lddpc	r11,80003368 <app_init+0x3c>
80003334:	48 ec       	lddpc	r12,8000336c <app_init+0x40>
80003336:	f0 1f 00 0f 	mcall	80003370 <app_init+0x44>
	xcmp_register_app_list(the_app_list);
8000333a:	48 fc       	lddpc	r12,80003374 <app_init+0x48>
8000333c:	f0 1f 00 0f 	mcall	80003378 <app_init+0x4c>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80003340:	48 fb       	lddpc	r11,8000337c <app_init+0x50>
80003342:	30 08       	mov	r8,0
80003344:	1a d8       	st.w	--sp,r8
80003346:	30 08       	mov	r8,0
80003348:	1a d8       	st.w	--sp,r8
8000334a:	30 08       	mov	r8,0
8000334c:	1a d8       	st.w	--sp,r8
8000334e:	30 18       	mov	r8,1
80003350:	30 09       	mov	r9,0
80003352:	e0 6a 01 80 	mov	r10,384
80003356:	48 bc       	lddpc	r12,80003380 <app_init+0x54>
80003358:	f0 1f 00 0b 	mcall	80003384 <app_init+0x58>
8000335c:	2f dd       	sub	sp,-12
8000335e:	18 99       	mov	r9,r12
80003360:	48 a8       	lddpc	r8,80003388 <app_init+0x5c>
80003362:	91 09       	st.w	r8[0x0],r9
	,  NULL
	,  1
	,  NULL );
	
	
}
80003364:	e3 cd 80 80 	ldm	sp++,r7,pc
80003368:	80 00       	ld.sh	r0,r0[0x0]
8000336a:	34 c4       	mov	r4,76
8000336c:	80 00       	ld.sh	r0,r0[0x0]
8000336e:	34 64       	mov	r4,70
80003370:	80 00       	ld.sh	r0,r0[0x0]
80003372:	42 58       	lddsp	r8,sp[0x94]
80003374:	00 00       	add	r0,r0
80003376:	00 08       	add	r8,r0
80003378:	80 00       	ld.sh	r0,r0[0x0]
8000337a:	66 34       	ld.w	r4,r3[0xc]
8000337c:	80 00       	ld.sh	r0,r0[0x0]
8000337e:	27 00       	sub	r0,112
80003380:	80 00       	ld.sh	r0,r0[0x0]
80003382:	33 8c       	mov	r12,56
80003384:	80 00       	ld.sh	r0,r0[0x0]
80003386:	91 ac       	st.w	r8[0x28],r12
80003388:	00 00       	add	r0,r0
8000338a:	0a 74       	tst	r4,r5

8000338c <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
8000338c:	eb cd 40 80 	pushm	r7,lr
80003390:	1a 97       	mov	r7,sp
80003392:	20 3d       	sub	sp,12
80003394:	ef 4c ff f4 	st.w	r7[-12],r12
	static int counter=0;
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,2s x  2000hz = 4000
80003398:	e0 68 0f a0 	mov	r8,4000
8000339c:	ef 48 ff f8 	st.w	r7[-8],r8
	U8 Burst_ID = 0;
800033a0:	30 08       	mov	r8,0
800033a2:	ef 68 ff ff 	st.b	r7[-1],r8
	
	 xLastWakeTime = xTaskGetTickCount();
800033a6:	f0 1f 00 26 	mcall	8000343c <app_cfg+0xb0>
800033aa:	18 99       	mov	r9,r12
800033ac:	4a 58       	lddpc	r8,80003440 <app_cfg+0xb4>
800033ae:	91 09       	st.w	r8[0x0],r9
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//
800033b0:	4a 58       	lddpc	r8,80003444 <app_cfg+0xb8>
800033b2:	70 08       	ld.w	r8,r8[0x0]
800033b4:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800033b8:	58 38       	cp.w	r8,3
800033ba:	c2 d1       	brne	80003414 <app_cfg+0x88>
		{	
			//if((++coun) % 3 ==0)		
			{
				
				// xcmp_audio_route_speaker();
				xcmp_IdleTestTone();
800033bc:	f0 1f 00 23 	mcall	80003448 <app_cfg+0xbc>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800033c0:	4a 38       	lddpc	r8,8000344c <app_cfg+0xc0>
800033c2:	70 08       	ld.w	r8,r8[0x0]
800033c4:	58 08       	cp.w	r8,0
800033c6:	c0 71       	brne	800033d4 <app_cfg+0x48>
				{
					xcmp_data_session();
800033c8:	f0 1f 00 22 	mcall	80003450 <app_cfg+0xc4>
					//xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800033cc:	4a 08       	lddpc	r8,8000344c <app_cfg+0xc0>
800033ce:	30 19       	mov	r9,1
800033d0:	91 09       	st.w	r8[0x0],r9
800033d2:	c2 18       	rjmp	80003414 <app_cfg+0x88>
				}
				else if(isAudioRouting == 1)
800033d4:	49 e8       	lddpc	r8,8000344c <app_cfg+0xc0>
800033d6:	70 08       	ld.w	r8,r8[0x0]
800033d8:	58 18       	cp.w	r8,1
800033da:	c0 51       	brne	800033e4 <app_cfg+0x58>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800033dc:	49 c8       	lddpc	r8,8000344c <app_cfg+0xc0>
800033de:	30 29       	mov	r9,2
800033e0:	91 09       	st.w	r8[0x0],r9
800033e2:	c1 98       	rjmp	80003414 <app_cfg+0x88>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800033e4:	49 a8       	lddpc	r8,8000344c <app_cfg+0xc0>
800033e6:	70 08       	ld.w	r8,r8[0x0]
800033e8:	58 28       	cp.w	r8,2
800033ea:	c0 71       	brne	800033f8 <app_cfg+0x6c>
				{
					xcmp_data_session();
800033ec:	f0 1f 00 19 	mcall	80003450 <app_cfg+0xc4>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800033f0:	49 78       	lddpc	r8,8000344c <app_cfg+0xc0>
800033f2:	30 39       	mov	r9,3
800033f4:	91 09       	st.w	r8[0x0],r9
800033f6:	c0 f8       	rjmp	80003414 <app_cfg+0x88>
					
				}
				else if(isAudioRouting == 3)
800033f8:	49 58       	lddpc	r8,8000344c <app_cfg+0xc0>
800033fa:	70 08       	ld.w	r8,r8[0x0]
800033fc:	58 38       	cp.w	r8,3
800033fe:	c0 51       	brne	80003408 <app_cfg+0x7c>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
80003400:	49 38       	lddpc	r8,8000344c <app_cfg+0xc0>
80003402:	30 49       	mov	r9,4
80003404:	91 09       	st.w	r8[0x0],r9
80003406:	c0 78       	rjmp	80003414 <app_cfg+0x88>
					
				}
				else
				{
					isAudioRouting++;
80003408:	49 18       	lddpc	r8,8000344c <app_cfg+0xc0>
8000340a:	70 08       	ld.w	r8,r8[0x0]
8000340c:	f0 c9 ff ff 	sub	r9,r8,-1
80003410:	48 f8       	lddpc	r8,8000344c <app_cfg+0xc0>
80003412:	91 09       	st.w	r8[0x0],r9
				//}
			}
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//300ms
		counter++;
80003414:	49 08       	lddpc	r8,80003454 <app_cfg+0xc8>
80003416:	70 08       	ld.w	r8,r8[0x0]
80003418:	f0 c9 ff ff 	sub	r9,r8,-1
8000341c:	48 e8       	lddpc	r8,80003454 <app_cfg+0xc8>
8000341e:	91 09       	st.w	r8[0x0],r9
		log("\n\r counter: %d \n\r", counter);
80003420:	48 d8       	lddpc	r8,80003454 <app_cfg+0xc8>
80003422:	70 08       	ld.w	r8,r8[0x0]
80003424:	1a d8       	st.w	--sp,r8
80003426:	48 dc       	lddpc	r12,80003458 <app_cfg+0xcc>
80003428:	f0 1f 00 0d 	mcall	8000345c <app_cfg+0xd0>
8000342c:	2f fd       	sub	sp,-4
		//log("\n\r xLastWakeTime: %d \n\r", xLastWakeTime);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//1000ms
8000342e:	e0 6b 07 d0 	mov	r11,2000
80003432:	48 4c       	lddpc	r12,80003440 <app_cfg+0xb4>
80003434:	f0 1f 00 0b 	mcall	80003460 <app_cfg+0xd4>
	}
80003438:	cb cb       	rjmp	800033b0 <app_cfg+0x24>
8000343a:	00 00       	add	r0,r0
8000343c:	80 00       	ld.sh	r0,r0[0x0]
8000343e:	95 fc       	st.w	r10[0x3c],r12
80003440:	00 00       	add	r0,r0
80003442:	0a 68       	and	r8,r5
80003444:	00 00       	add	r0,r0
80003446:	0d 9c       	ld.ub	r12,r6[0x1]
80003448:	80 00       	ld.sh	r0,r0[0x0]
8000344a:	67 00       	ld.w	r0,r3[0x40]
8000344c:	00 00       	add	r0,r0
8000344e:	0a 6c       	and	r12,r5
80003450:	80 00       	ld.sh	r0,r0[0x0]
80003452:	67 68       	ld.w	r8,r3[0x58]
80003454:	00 00       	add	r0,r0
80003456:	0a 70       	tst	r0,r5
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	27 08       	sub	r8,112
8000345c:	80 00       	ld.sh	r0,r0[0x0]
8000345e:	a3 80       	lsr	r0,0x2
80003460:	80 00       	ld.sh	r0,r0[0x0]
80003462:	93 74       	st.w	r9[0x1c],r4

80003464 <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
80003464:	eb cd 40 80 	pushm	r7,lr
80003468:	1a 97       	mov	r7,sp
8000346a:	20 1d       	sub	sp,4
8000346c:	ef 4c ff fc 	st.w	r7[-4],r12
	static  U8 times_counter = 0;
	
	times_counter++;
80003470:	48 f8       	lddpc	r8,800034ac <app_payload_rx_proc+0x48>
80003472:	11 88       	ld.ub	r8,r8[0x0]
80003474:	2f f8       	sub	r8,-1
80003476:	5c 58       	castu.b	r8
80003478:	48 d9       	lddpc	r9,800034ac <app_payload_rx_proc+0x48>
8000347a:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
8000347c:	48 c8       	lddpc	r8,800034ac <app_payload_rx_proc+0x48>
8000347e:	11 89       	ld.ub	r9,r8[0x0]
80003480:	30 38       	mov	r8,3
80003482:	f0 09 18 00 	cp.b	r9,r8
80003486:	c0 71       	brne	80003494 <app_payload_rx_proc+0x30>
	{
		times_counter = 0 ;
80003488:	48 99       	lddpc	r9,800034ac <app_payload_rx_proc+0x48>
8000348a:	30 08       	mov	r8,0
8000348c:	b2 88       	st.b	r9[0x0],r8
		log("\n\r w: \n\r");
8000348e:	48 9c       	lddpc	r12,800034b0 <app_payload_rx_proc+0x4c>
80003490:	f0 1f 00 09 	mcall	800034b4 <app_payload_rx_proc+0x50>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//mic
80003494:	48 98       	lddpc	r8,800034b8 <app_payload_rx_proc+0x54>
80003496:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80003498:	48 98       	lddpc	r8,800034bc <app_payload_rx_proc+0x58>
8000349a:	70 08       	ld.w	r8,r8[0x0]
8000349c:	ee fb ff fc 	ld.w	r11,r7[-4]
800034a0:	10 9c       	mov	r12,r8
800034a2:	f0 1f 00 08 	mcall	800034c0 <app_payload_rx_proc+0x5c>

}
800034a6:	2f fd       	sub	sp,-4
800034a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800034ac:	00 00       	add	r0,r0
800034ae:	0a 64       	and	r4,r5
800034b0:	80 00       	ld.sh	r0,r0[0x0]
800034b2:	27 1c       	sub	r12,113
800034b4:	80 00       	ld.sh	r0,r0[0x0]
800034b6:	a3 80       	lsr	r0,0x2
800034b8:	00 00       	add	r0,r0
800034ba:	0a 5a       	eor	r10,r5
800034bc:	00 00       	add	r0,r0
800034be:	0a 94       	mov	r4,r5
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	5f d4       	srvc	r4

800034c4 <app_payload_tx_proc>:


static void app_payload_tx_proc(void  * payload)
{
800034c4:	eb cd 40 80 	pushm	r7,lr
800034c8:	1a 97       	mov	r7,sp
800034ca:	20 1d       	sub	sp,4
800034cc:	ef 4c ff fc 	st.w	r7[-4],r12
  log("R");
800034d0:	48 3c       	lddpc	r12,800034dc <app_payload_tx_proc+0x18>
800034d2:	f0 1f 00 04 	mcall	800034e0 <app_payload_tx_proc+0x1c>
  //
  //
  //set_payload_idle(payload);


}
800034d6:	2f fd       	sub	sp,-4
800034d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800034dc:	80 00       	ld.sh	r0,r0[0x0]
800034de:	27 28       	sub	r8,114
800034e0:	80 00       	ld.sh	r0,r0[0x0]
800034e2:	a3 80       	lsr	r0,0x2

800034e4 <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
800034e4:	eb cd 40 80 	pushm	r7,lr
800034e8:	1a 97       	mov	r7,sp
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
800034ea:	48 58       	lddpc	r8,800034fc <vApplicationIdleHook+0x18>
800034ec:	70 08       	ld.w	r8,r8[0x0]
800034ee:	f0 c9 ff ff 	sub	r9,r8,-1
800034f2:	48 38       	lddpc	r8,800034fc <vApplicationIdleHook+0x18>
800034f4:	91 09       	st.w	r8[0x0],r9
	
}
800034f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800034fa:	00 00       	add	r0,r0
800034fc:	00 00       	add	r0,r0
800034fe:	0a 60       	and	r0,r5

80003500 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80003500:	eb cd 40 80 	pushm	r7,lr
80003504:	1a 97       	mov	r7,sp
80003506:	20 5d       	sub	sp,20
	U16 status = 0xff;
80003508:	e0 68 00 ff 	mov	r8,255
8000350c:	ef 58 ff fe 	st.h	r7[-2],r8
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80003510:	4b b8       	lddpc	r8,800035fc <data_flash_init+0xfc>
80003512:	ee ca 00 14 	sub	r10,r7,20
80003516:	10 9b       	mov	r11,r8
80003518:	f6 e8 00 00 	ld.d	r8,r11[0]
8000351c:	f4 e9 00 00 	st.d	r10[0],r8
80003520:	f6 e8 00 08 	ld.d	r8,r11[8]
80003524:	f4 e9 00 08 	st.d	r10[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80003528:	30 4b       	mov	r11,4
8000352a:	4b 6c       	lddpc	r12,80003600 <data_flash_init+0x100>
8000352c:	f0 1f 00 36 	mcall	80003604 <data_flash_init+0x104>

	// Configure PA25 as WP pin - 1: deasserted (allow write) always
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80003530:	31 9c       	mov	r12,25
80003532:	f0 1f 00 36 	mcall	80003608 <data_flash_init+0x108>
 	gpio_set_gpio_pin(AVR32_PIN_PA25);
80003536:	31 9c       	mov	r12,25
80003538:	f0 1f 00 35 	mcall	8000360c <data_flash_init+0x10c>

	spi = &AVR32_SPI;
8000353c:	4b 58       	lddpc	r8,80003610 <data_flash_init+0x110>
8000353e:	fe 79 24 00 	mov	r9,-56320
80003542:	91 09       	st.w	r8[0x0],r9

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80003544:	4b 38       	lddpc	r8,80003610 <data_flash_init+0x110>
80003546:	70 08       	ld.w	r8,r8[0x0]
80003548:	ee c9 00 14 	sub	r9,r7,20
8000354c:	12 9b       	mov	r11,r9
8000354e:	10 9c       	mov	r12,r8
80003550:	f0 1f 00 31 	mcall	80003614 <data_flash_init+0x114>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80003554:	4a f8       	lddpc	r8,80003610 <data_flash_init+0x110>
80003556:	70 08       	ld.w	r8,r8[0x0]
80003558:	30 09       	mov	r9,0
8000355a:	30 0a       	mov	r10,0
8000355c:	30 0b       	mov	r11,0
8000355e:	10 9c       	mov	r12,r8
80003560:	f0 1f 00 2e 	mcall	80003618 <data_flash_init+0x118>

	// Enable SPI.
	spi_enable(spi);
80003564:	4a b8       	lddpc	r8,80003610 <data_flash_init+0x110>
80003566:	70 08       	ld.w	r8,r8[0x0]
80003568:	10 9c       	mov	r12,r8
8000356a:	f0 1f 00 2d 	mcall	8000361c <data_flash_init+0x11c>

	// Initialize data flash with SPI clock Osc0.
	if (spi_setupChipReg(spi, &spiOptions, 2*FOSC0) != SPI_OK)
8000356e:	4a 98       	lddpc	r8,80003610 <data_flash_init+0x110>
80003570:	70 08       	ld.w	r8,r8[0x0]
80003572:	ee c9 00 14 	sub	r9,r7,20
80003576:	e0 6a 36 00 	mov	r10,13824
8000357a:	ea 1a 01 6e 	orh	r10,0x16e
8000357e:	12 9b       	mov	r11,r9
80003580:	10 9c       	mov	r12,r8
80003582:	f0 1f 00 28 	mcall	80003620 <data_flash_init+0x120>
80003586:	18 98       	mov	r8,r12
80003588:	58 08       	cp.w	r8,0
8000358a:	c0 50       	breq	80003594 <data_flash_init+0x94>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_SPI_INIT);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
8000358c:	4a 69       	lddpc	r9,80003624 <data_flash_init+0x124>
8000358e:	30 28       	mov	r8,2
80003590:	b2 88       	st.b	r9[0x0],r8
		return;
80003592:	c3 28       	rjmp	800035f6 <data_flash_init+0xf6>
	}

	if (data_flash_check_device_id() != TRUE)
80003594:	f0 1f 00 25 	mcall	80003628 <data_flash_init+0x128>
80003598:	18 98       	mov	r8,r12
8000359a:	10 99       	mov	r9,r8
8000359c:	30 18       	mov	r8,1
8000359e:	f0 09 18 00 	cp.b	r9,r8
800035a2:	c0 50       	breq	800035ac <data_flash_init+0xac>
	{
		//fatal_error(FATAL_ERROR_DATA_FLASH_READ_ID);
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
800035a4:	4a 09       	lddpc	r9,80003624 <data_flash_init+0x124>
800035a6:	30 38       	mov	r8,3
800035a8:	b2 88       	st.b	r9[0x0],r8
		return;
800035aa:	c2 68       	rjmp	800035f6 <data_flash_init+0xf6>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
800035ac:	30 09       	mov	r9,0
800035ae:	30 0a       	mov	r10,0
800035b0:	30 0b       	mov	r11,0
800035b2:	30 6c       	mov	r12,6
800035b4:	f0 1f 00 1e 	mcall	8000362c <data_flash_init+0x12c>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
800035b8:	30 09       	mov	r9,0
800035ba:	30 0a       	mov	r10,0
800035bc:	30 0b       	mov	r11,0
800035be:	30 1c       	mov	r12,1
800035c0:	f0 1f 00 1b 	mcall	8000362c <data_flash_init+0x12c>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
800035c4:	30 09       	mov	r9,0
800035c6:	30 0a       	mov	r10,0
800035c8:	30 0b       	mov	r11,0
800035ca:	30 5c       	mov	r12,5
800035cc:	f0 1f 00 18 	mcall	8000362c <data_flash_init+0x12c>
800035d0:	18 98       	mov	r8,r12
800035d2:	5c 88       	casts.h	r8
800035d4:	ef 58 ff fe 	st.h	r7[-2],r8
	// after 5 seconds, perform a test on write and read back 0x5A5A to address 0x00001002
	// then read address 0x00001002 every 5s and report to radio with failure

	//test_data_flash(FALSE);
	//create_data_flash_test_task();
	create_data_list();
800035d8:	f0 1f 00 16 	mcall	80003630 <data_flash_init+0x130>
	
	data_flash_read_block(LABEL_ADDRESS, 512, FLASH_BUF);
800035dc:	49 6a       	lddpc	r10,80003634 <data_flash_init+0x134>
800035de:	e0 6b 02 00 	mov	r11,512
800035e2:	30 0c       	mov	r12,0
800035e4:	f0 1f 00 15 	mcall	80003638 <data_flash_init+0x138>
	data_flash_read_block(LABEL_ADDRESS, 512, FLASH_BUF);
800035e8:	49 3a       	lddpc	r10,80003634 <data_flash_init+0x134>
800035ea:	e0 6b 02 00 	mov	r11,512
800035ee:	30 0c       	mov	r12,0
800035f0:	f0 1f 00 12 	mcall	80003638 <data_flash_init+0x138>
	//playback_voice_data(1);
	//playback_voice_data(5);
	//playback_voice_data(4);

	
	return;
800035f4:	d7 03       	nop
}
800035f6:	2f bd       	sub	sp,-20
800035f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800035fc:	80 01       	ld.sh	r1,r0[0x0]
800035fe:	08 04       	add	r4,r4
80003600:	80 01       	ld.sh	r1,r0[0x0]
80003602:	08 14       	sub	r4,r4
80003604:	80 00       	ld.sh	r0,r0[0x0]
80003606:	a9 7c       	lsl	r12,0x9
80003608:	80 00       	ld.sh	r0,r0[0x0]
8000360a:	aa fc       	st.b	r5[0x7],r12
8000360c:	80 00       	ld.sh	r0,r0[0x0]
8000360e:	ab 4c       	asr	r12,0xa
80003610:	00 00       	add	r0,r0
80003612:	1f a0       	ld.ub	r0,pc[0x2]
80003614:	80 00       	ld.sh	r0,r0[0x0]
80003616:	74 de       	ld.w	lr,r10[0x34]
80003618:	80 00       	ld.sh	r0,r0[0x0]
8000361a:	75 72       	ld.w	r2,r10[0x5c]
8000361c:	80 00       	ld.sh	r0,r0[0x0]
8000361e:	78 88       	ld.w	r8,r12[0x20]
80003620:	80 00       	ld.sh	r0,r0[0x0]
80003622:	77 08       	ld.w	r8,r11[0x40]
80003624:	00 00       	add	r0,r0
80003626:	0a 78       	tst	r8,r5
80003628:	80 00       	ld.sh	r0,r0[0x0]
8000362a:	36 3c       	mov	r12,99
8000362c:	80 00       	ld.sh	r0,r0[0x0]
8000362e:	36 fc       	mov	r12,111
80003630:	80 00       	ld.sh	r0,r0[0x0]
80003632:	39 d4       	mov	r4,-99
80003634:	00 00       	add	r0,r0
80003636:	0d a0       	ld.ub	r0,r6[0x2]
80003638:	80 00       	ld.sh	r0,r0[0x0]
8000363a:	41 10       	lddsp	r0,sp[0x44]

8000363c <data_flash_check_device_id>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
8000363c:	eb cd 40 80 	pushm	r7,lr
80003640:	1a 97       	mov	r7,sp
80003642:	20 1d       	sub	sp,4
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80003644:	4a 79       	lddpc	r9,800036e0 <data_flash_check_device_id+0xa4>
80003646:	ee c8 00 04 	sub	r8,r7,4
8000364a:	30 4a       	mov	r10,4
8000364c:	12 9b       	mov	r11,r9
8000364e:	10 9c       	mov	r12,r8
80003650:	f0 1f 00 25 	mcall	800036e4 <data_flash_check_device_id+0xa8>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_0);
80003654:	4a 58       	lddpc	r8,800036e8 <data_flash_check_device_id+0xac>
80003656:	70 08       	ld.w	r8,r8[0x0]
80003658:	30 0b       	mov	r11,0
8000365a:	10 9c       	mov	r12,r8
8000365c:	f0 1f 00 24 	mcall	800036ec <data_flash_check_device_id+0xb0>

	/* Send the Status Register Read command. */
	spi_write(spi, READ_M_D_ID);
80003660:	4a 28       	lddpc	r8,800036e8 <data_flash_check_device_id+0xac>
80003662:	70 08       	ld.w	r8,r8[0x0]
80003664:	e0 6b 00 9f 	mov	r11,159
80003668:	10 9c       	mov	r12,r8
8000366a:	f0 1f 00 22 	mcall	800036f0 <data_flash_check_device_id+0xb4>

	/* Send 2 dummy byte to read the status register. */
	spi_write_dummy();
8000366e:	49 f8       	lddpc	r8,800036e8 <data_flash_check_device_id+0xac>
80003670:	70 08       	ld.w	r8,r8[0x0]
80003672:	e0 6b 00 ff 	mov	r11,255
80003676:	10 9c       	mov	r12,r8
80003678:	f0 1f 00 1e 	mcall	800036f0 <data_flash_check_device_id+0xb4>
	spi_read(spi, &manufacturer_device_id[0]);
8000367c:	49 b8       	lddpc	r8,800036e8 <data_flash_check_device_id+0xac>
8000367e:	70 08       	ld.w	r8,r8[0x0]
80003680:	ee c9 00 04 	sub	r9,r7,4
80003684:	12 9b       	mov	r11,r9
80003686:	10 9c       	mov	r12,r8
80003688:	f0 1f 00 1b 	mcall	800036f4 <data_flash_check_device_id+0xb8>
	spi_write_dummy();
8000368c:	49 78       	lddpc	r8,800036e8 <data_flash_check_device_id+0xac>
8000368e:	70 08       	ld.w	r8,r8[0x0]
80003690:	e0 6b 00 ff 	mov	r11,255
80003694:	10 9c       	mov	r12,r8
80003696:	f0 1f 00 17 	mcall	800036f0 <data_flash_check_device_id+0xb4>
	spi_read(spi, &manufacturer_device_id[1]);
8000369a:	49 48       	lddpc	r8,800036e8 <data_flash_check_device_id+0xac>
8000369c:	70 08       	ld.w	r8,r8[0x0]
8000369e:	ee c9 00 04 	sub	r9,r7,4
800036a2:	2f e9       	sub	r9,-2
800036a4:	12 9b       	mov	r11,r9
800036a6:	10 9c       	mov	r12,r8
800036a8:	f0 1f 00 13 	mcall	800036f4 <data_flash_check_device_id+0xb8>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_0);
800036ac:	48 f8       	lddpc	r8,800036e8 <data_flash_check_device_id+0xac>
800036ae:	70 08       	ld.w	r8,r8[0x0]
800036b0:	30 0b       	mov	r11,0
800036b2:	10 9c       	mov	r12,r8
800036b4:	f0 1f 00 11 	mcall	800036f8 <data_flash_check_device_id+0xbc>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0x1F) || (manufacturer_device_id[1] != 0x48))
800036b8:	ef 09 ff fc 	ld.sh	r9,r7[-4]
800036bc:	31 f8       	mov	r8,31
800036be:	f0 09 19 00 	cp.h	r9,r8
800036c2:	c0 71       	brne	800036d0 <data_flash_check_device_id+0x94>
800036c4:	ef 09 ff fe 	ld.sh	r9,r7[-2]
800036c8:	34 88       	mov	r8,72
800036ca:	f0 09 19 00 	cp.h	r9,r8
800036ce:	c0 30       	breq	800036d4 <data_flash_check_device_id+0x98>
    {
    	return FALSE;
800036d0:	30 08       	mov	r8,0
800036d2:	c0 28       	rjmp	800036d6 <data_flash_check_device_id+0x9a>
    }

    return TRUE;
800036d4:	30 18       	mov	r8,1
}
800036d6:	10 9c       	mov	r12,r8
800036d8:	2f fd       	sub	sp,-4
800036da:	e3 cd 80 80 	ldm	sp++,r7,pc
800036de:	00 00       	add	r0,r0
800036e0:	80 01       	ld.sh	r1,r0[0x0]
800036e2:	08 00       	add	r0,r4
800036e4:	80 00       	ld.sh	r0,r0[0x0]
800036e6:	b0 72       	st.h	r8[0xe],r2
800036e8:	00 00       	add	r0,r0
800036ea:	1f a0       	ld.ub	r0,pc[0x2]
800036ec:	80 00       	ld.sh	r0,r0[0x0]
800036ee:	76 06       	ld.w	r6,r11[0x0]
800036f0:	80 00       	ld.sh	r0,r0[0x0]
800036f2:	78 a2       	ld.w	r2,r12[0x28]
800036f4:	80 00       	ld.sh	r0,r0[0x0]
800036f6:	78 fa       	ld.w	r10,r12[0x3c]
800036f8:	80 00       	ld.sh	r0,r0[0x0]
800036fa:	76 9e       	ld.w	lr,r11[0x24]

800036fc <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
800036fc:	eb cd 40 80 	pushm	r7,lr
80003700:	1a 97       	mov	r7,sp
80003702:	20 7d       	sub	sp,28
80003704:	ef 4b ff ec 	st.w	r7[-20],r11
80003708:	ef 4a ff e8 	st.w	r7[-24],r10
8000370c:	12 98       	mov	r8,r9
8000370e:	18 99       	mov	r9,r12
80003710:	ef 59 ff f0 	st.h	r7[-16],r9
80003714:	ef 58 ff e4 	st.h	r7[-28],r8
	U16 status = 1;
80003718:	30 18       	mov	r8,1
8000371a:	ef 58 ff fc 	st.h	r7[-4],r8
	U16 i = 0;
8000371e:	30 08       	mov	r8,0
80003720:	ef 58 ff fe 	st.h	r7[-2],r8

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80003724:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003728:	e6 18 00 ff 	andh	r8,0xff,COH
8000372c:	b1 88       	lsr	r8,0x10
8000372e:	5c 88       	casts.h	r8
80003730:	ef 58 ff fa 	st.h	r7[-6],r8
	addr[1] = (address & 0x0000ff00) >> 8;
80003734:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003738:	e2 18 ff 00 	andl	r8,0xff00,COH
8000373c:	a9 88       	lsr	r8,0x8
8000373e:	5c 88       	casts.h	r8
80003740:	ef 58 ff f8 	st.h	r7[-8],r8
	addr[0] = (address & 0x000000ff);
80003744:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003748:	5c 88       	casts.h	r8
8000374a:	5c 88       	casts.h	r8
8000374c:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003750:	ef 58 ff f6 	st.h	r7[-10],r8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_0);
80003754:	fe f8 02 6c 	ld.w	r8,pc[620]
80003758:	70 08       	ld.w	r8,r8[0x0]
8000375a:	30 0b       	mov	r11,0
8000375c:	10 9c       	mov	r12,r8
8000375e:	f0 1f 00 9a 	mcall	800039c4 <send_flash_command+0x2c8>

    switch (command)
80003762:	ef 18 ff f0 	ld.uh	r8,r7[-16]
80003766:	58 58       	cp.w	r8,5
80003768:	c2 30       	breq	800037ae <send_flash_command+0xb2>
8000376a:	e0 89 00 10 	brgt	8000378a <send_flash_command+0x8e>
8000376e:	58 28       	cp.w	r8,2
80003770:	c7 20       	breq	80003854 <send_flash_command+0x158>
80003772:	e0 89 00 06 	brgt	8000377e <send_flash_command+0x82>
80003776:	58 18       	cp.w	r8,1
80003778:	e0 80 01 0a 	breq	8000398c <send_flash_command+0x290>
8000377c:	c1 69       	rjmp	800039a8 <send_flash_command+0x2ac>
8000377e:	58 38       	cp.w	r8,3
80003780:	e0 80 00 b5 	breq	800038ea <send_flash_command+0x1ee>
80003784:	58 48       	cp.w	r8,4
80003786:	c2 e0       	breq	800037e2 <send_flash_command+0xe6>
80003788:	c1 09       	rjmp	800039a8 <send_flash_command+0x2ac>
8000378a:	e0 48 00 52 	cp.w	r8,82
8000378e:	c3 30       	breq	800037f4 <send_flash_command+0xf8>
80003790:	e0 89 00 08 	brgt	800037a0 <send_flash_command+0xa4>
80003794:	58 68       	cp.w	r8,6
80003796:	c2 60       	breq	800037e2 <send_flash_command+0xe6>
80003798:	e0 48 00 20 	cp.w	r8,32
8000379c:	c2 c0       	breq	800037f4 <send_flash_command+0xf8>
8000379e:	c0 59       	rjmp	800039a8 <send_flash_command+0x2ac>
800037a0:	e0 48 00 60 	cp.w	r8,96
800037a4:	c4 f0       	breq	80003842 <send_flash_command+0x146>
800037a6:	e0 48 00 d8 	cp.w	r8,216
800037aa:	c2 50       	breq	800037f4 <send_flash_command+0xf8>
800037ac:	cf e8       	rjmp	800039a8 <send_flash_command+0x2ac>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
800037ae:	ef 19 ff f0 	ld.uh	r9,r7[-16]
800037b2:	fe f8 02 0e 	ld.w	r8,pc[526]
800037b6:	70 08       	ld.w	r8,r8[0x0]
800037b8:	12 9b       	mov	r11,r9
800037ba:	10 9c       	mov	r12,r8
800037bc:	f0 1f 00 83 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_dummy();
800037c0:	fe f8 02 00 	ld.w	r8,pc[512]
800037c4:	70 08       	ld.w	r8,r8[0x0]
800037c6:	e0 6b 00 ff 	mov	r11,255
800037ca:	10 9c       	mov	r12,r8
800037cc:	f0 1f 00 7f 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_read_byte(&status);
800037d0:	4f c8       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
800037d2:	70 08       	ld.w	r8,r8[0x0]
800037d4:	ee c9 00 04 	sub	r9,r7,4
800037d8:	12 9b       	mov	r11,r9
800037da:	10 9c       	mov	r12,r8
800037dc:	f0 1f 00 7c 	mcall	800039cc <send_flash_command+0x2d0>
			break;
800037e0:	ce 48       	rjmp	800039a8 <send_flash_command+0x2ac>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
800037e2:	ef 19 ff f0 	ld.uh	r9,r7[-16]
800037e6:	4f 78       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
800037e8:	70 08       	ld.w	r8,r8[0x0]
800037ea:	12 9b       	mov	r11,r9
800037ec:	10 9c       	mov	r12,r8
800037ee:	f0 1f 00 77 	mcall	800039c8 <send_flash_command+0x2cc>
			break;
800037f2:	cd b8       	rjmp	800039a8 <send_flash_command+0x2ac>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
800037f4:	ef 19 ff f0 	ld.uh	r9,r7[-16]
800037f8:	4f 28       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
800037fa:	70 08       	ld.w	r8,r8[0x0]
800037fc:	12 9b       	mov	r11,r9
800037fe:	10 9c       	mov	r12,r8
80003800:	f0 1f 00 72 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_byte(addr[2]);
80003804:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80003808:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000380c:	4e d8       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
8000380e:	70 08       	ld.w	r8,r8[0x0]
80003810:	12 9b       	mov	r11,r9
80003812:	10 9c       	mov	r12,r8
80003814:	f0 1f 00 6d 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_byte(addr[1]);
80003818:	ef 08 ff f8 	ld.sh	r8,r7[-8]
8000381c:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003820:	4e 88       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
80003822:	70 08       	ld.w	r8,r8[0x0]
80003824:	12 9b       	mov	r11,r9
80003826:	10 9c       	mov	r12,r8
80003828:	f0 1f 00 68 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_byte(addr[0]);
8000382c:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80003830:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003834:	4e 38       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
80003836:	70 08       	ld.w	r8,r8[0x0]
80003838:	12 9b       	mov	r11,r9
8000383a:	10 9c       	mov	r12,r8
8000383c:	f0 1f 00 63 	mcall	800039c8 <send_flash_command+0x2cc>
			break;
80003840:	cb 48       	rjmp	800039a8 <send_flash_command+0x2ac>
		case CHIP_ERASE:
			spi_write_byte(command);
80003842:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003846:	4d f8       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
80003848:	70 08       	ld.w	r8,r8[0x0]
8000384a:	12 9b       	mov	r11,r9
8000384c:	10 9c       	mov	r12,r8
8000384e:	f0 1f 00 5f 	mcall	800039c8 <send_flash_command+0x2cc>
			break;
80003852:	ca b8       	rjmp	800039a8 <send_flash_command+0x2ac>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80003854:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003858:	4d a8       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
8000385a:	70 08       	ld.w	r8,r8[0x0]
8000385c:	12 9b       	mov	r11,r9
8000385e:	10 9c       	mov	r12,r8
80003860:	f0 1f 00 5a 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_byte(addr[2]);
80003864:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80003868:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000386c:	4d 58       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
8000386e:	70 08       	ld.w	r8,r8[0x0]
80003870:	12 9b       	mov	r11,r9
80003872:	10 9c       	mov	r12,r8
80003874:	f0 1f 00 55 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_byte(addr[1]);
80003878:	ef 08 ff f8 	ld.sh	r8,r7[-8]
8000387c:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003880:	4d 08       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
80003882:	70 08       	ld.w	r8,r8[0x0]
80003884:	12 9b       	mov	r11,r9
80003886:	10 9c       	mov	r12,r8
80003888:	f0 1f 00 50 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_byte(addr[0]);
8000388c:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80003890:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003894:	4c b8       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
80003896:	70 08       	ld.w	r8,r8[0x0]
80003898:	12 9b       	mov	r11,r9
8000389a:	10 9c       	mov	r12,r8
8000389c:	f0 1f 00 4b 	mcall	800039c8 <send_flash_command+0x2cc>
			for (i = 0; i < length; i++)
800038a0:	30 08       	mov	r8,0
800038a2:	ef 58 ff fe 	st.h	r7[-2],r8
800038a6:	c1 a8       	rjmp	800038da <send_flash_command+0x1de>
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
800038a8:	ee f8 ff e8 	ld.w	r8,r7[-24]
800038ac:	11 88       	ld.ub	r8,r8[0x0]
800038ae:	ef 58 ff f4 	st.h	r7[-12],r8
				data_ptr++;
800038b2:	ee f8 ff e8 	ld.w	r8,r7[-24]
800038b6:	2f f8       	sub	r8,-1
800038b8:	ef 48 ff e8 	st.w	r7[-24],r8
				spi_write_byte(data_u16);
800038bc:	ef 08 ff f4 	ld.sh	r8,r7[-12]
800038c0:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800038c4:	4b f8       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
800038c6:	70 08       	ld.w	r8,r8[0x0]
800038c8:	12 9b       	mov	r11,r9
800038ca:	10 9c       	mov	r12,r8
800038cc:	f0 1f 00 3f 	mcall	800039c8 <send_flash_command+0x2cc>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
800038d0:	ef 08 ff fe 	ld.sh	r8,r7[-2]
800038d4:	2f f8       	sub	r8,-1
800038d6:	ef 58 ff fe 	st.h	r7[-2],r8
800038da:	ef 09 ff fe 	ld.sh	r9,r7[-2]
800038de:	ef 08 ff e4 	ld.sh	r8,r7[-28]
800038e2:	f0 09 19 00 	cp.h	r9,r8
800038e6:	ce 13       	brcs	800038a8 <send_flash_command+0x1ac>
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
800038e8:	c6 08       	rjmp	800039a8 <send_flash_command+0x2ac>
		case READ_ARRAY:
			spi_write_byte(command);
800038ea:	ef 19 ff f0 	ld.uh	r9,r7[-16]
800038ee:	4b 58       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
800038f0:	70 08       	ld.w	r8,r8[0x0]
800038f2:	12 9b       	mov	r11,r9
800038f4:	10 9c       	mov	r12,r8
800038f6:	f0 1f 00 35 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_byte(addr[2]);
800038fa:	ef 08 ff fa 	ld.sh	r8,r7[-6]
800038fe:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003902:	4b 08       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
80003904:	70 08       	ld.w	r8,r8[0x0]
80003906:	12 9b       	mov	r11,r9
80003908:	10 9c       	mov	r12,r8
8000390a:	f0 1f 00 30 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_byte(addr[1]);
8000390e:	ef 08 ff f8 	ld.sh	r8,r7[-8]
80003912:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80003916:	4a b8       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
80003918:	70 08       	ld.w	r8,r8[0x0]
8000391a:	12 9b       	mov	r11,r9
8000391c:	10 9c       	mov	r12,r8
8000391e:	f0 1f 00 2b 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_byte(addr[0]);
80003922:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80003926:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000392a:	4a 68       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
8000392c:	70 08       	ld.w	r8,r8[0x0]
8000392e:	12 9b       	mov	r11,r9
80003930:	10 9c       	mov	r12,r8
80003932:	f0 1f 00 26 	mcall	800039c8 <send_flash_command+0x2cc>
			for (i = 0; i < length; i++)
80003936:	30 08       	mov	r8,0
80003938:	ef 58 ff fe 	st.h	r7[-2],r8
8000393c:	c2 08       	rjmp	8000397c <send_flash_command+0x280>
			{
				spi_write_dummy();
8000393e:	4a 18       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
80003940:	70 08       	ld.w	r8,r8[0x0]
80003942:	e0 6b 00 ff 	mov	r11,255
80003946:	10 9c       	mov	r12,r8
80003948:	f0 1f 00 20 	mcall	800039c8 <send_flash_command+0x2cc>
				spi_read_byte(&data_u16);
8000394c:	49 d8       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
8000394e:	70 08       	ld.w	r8,r8[0x0]
80003950:	ee c9 00 0c 	sub	r9,r7,12
80003954:	12 9b       	mov	r11,r9
80003956:	10 9c       	mov	r12,r8
80003958:	f0 1f 00 1d 	mcall	800039cc <send_flash_command+0x2d0>
				*data_ptr = (U8)data_u16;
8000395c:	ef 08 ff f4 	ld.sh	r8,r7[-12]
80003960:	5c 58       	castu.b	r8
80003962:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003966:	b2 88       	st.b	r9[0x0],r8
				data_ptr++;
80003968:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000396c:	2f f8       	sub	r8,-1
8000396e:	ef 48 ff e8 	st.w	r7[-24],r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80003972:	ef 08 ff fe 	ld.sh	r8,r7[-2]
80003976:	2f f8       	sub	r8,-1
80003978:	ef 58 ff fe 	st.h	r7[-2],r8
8000397c:	ef 09 ff fe 	ld.sh	r9,r7[-2]
80003980:	ef 08 ff e4 	ld.sh	r8,r7[-28]
80003984:	f0 09 19 00 	cp.h	r9,r8
80003988:	cd b3       	brcs	8000393e <send_flash_command+0x242>
				spi_write_dummy();
				spi_read_byte(&data_u16);
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
8000398a:	c0 f8       	rjmp	800039a8 <send_flash_command+0x2ac>
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
8000398c:	ef 19 ff f0 	ld.uh	r9,r7[-16]
80003990:	48 c8       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
80003992:	70 08       	ld.w	r8,r8[0x0]
80003994:	12 9b       	mov	r11,r9
80003996:	10 9c       	mov	r12,r8
80003998:	f0 1f 00 0c 	mcall	800039c8 <send_flash_command+0x2cc>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
8000399c:	48 98       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
8000399e:	70 08       	ld.w	r8,r8[0x0]
800039a0:	30 0b       	mov	r11,0
800039a2:	10 9c       	mov	r12,r8
800039a4:	f0 1f 00 09 	mcall	800039c8 <send_flash_command+0x2cc>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_0);
800039a8:	48 68       	lddpc	r8,800039c0 <send_flash_command+0x2c4>
800039aa:	70 08       	ld.w	r8,r8[0x0]
800039ac:	30 0b       	mov	r11,0
800039ae:	10 9c       	mov	r12,r8
800039b0:	f0 1f 00 08 	mcall	800039d0 <send_flash_command+0x2d4>

	return status;
800039b4:	ef 08 ff fc 	ld.sh	r8,r7[-4]
}
800039b8:	10 9c       	mov	r12,r8
800039ba:	2f 9d       	sub	sp,-28
800039bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800039c0:	00 00       	add	r0,r0
800039c2:	1f a0       	ld.ub	r0,pc[0x2]
800039c4:	80 00       	ld.sh	r0,r0[0x0]
800039c6:	76 06       	ld.w	r6,r11[0x0]
800039c8:	80 00       	ld.sh	r0,r0[0x0]
800039ca:	78 a2       	ld.w	r2,r12[0x28]
800039cc:	80 00       	ld.sh	r0,r0[0x0]
800039ce:	78 fa       	ld.w	r10,r12[0x3c]
800039d0:	80 00       	ld.sh	r0,r0[0x0]
800039d2:	76 9e       	ld.w	lr,r11[0x24]

800039d4 <create_data_list>:
* ----------  --------  ----------  --------------------------------------------
* 20-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
static Bool create_data_list(void)
{
800039d4:	eb cd 40 80 	pushm	r7,lr
800039d8:	1a 97       	mov	r7,sp
800039da:	20 7d       	sub	sp,28
	df_status_t return_code = DF_OK;
800039dc:	30 08       	mov	r8,0
800039de:	ef 48 ff f0 	st.w	r7[-16],r8
	unsigned int i = 0;
800039e2:	30 08       	mov	r8,0
800039e4:	ef 48 ff f4 	st.w	r7[-12],r8
	unsigned int address =0x00000000;	
800039e8:	30 08       	mov	r8,0
800039ea:	ef 48 ff f8 	st.w	r7[-8],r8
	char str[10];
	memset(str, 0x00, sizeof(str));
800039ee:	ee c8 00 1c 	sub	r8,r7,28
800039f2:	30 aa       	mov	r10,10
800039f4:	30 0b       	mov	r11,0
800039f6:	10 9c       	mov	r12,r8
800039f8:	f0 1f 00 6c 	mcall	80003ba8 <create_data_list+0x1d4>
	
	/* bytes remained less than one page */
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
800039fc:	ee c8 00 1c 	sub	r8,r7,28
80003a00:	10 9a       	mov	r10,r8
80003a02:	30 7b       	mov	r11,7
80003a04:	30 0c       	mov	r12,0
80003a06:	f0 1f 00 6a 	mcall	80003bac <create_data_list+0x1d8>
80003a0a:	18 98       	mov	r8,r12
80003a0c:	ef 48 ff f0 	st.w	r7[-16],r8
	if(return_code == DF_OK)
80003a10:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003a14:	58 08       	cp.w	r8,0
80003a16:	e0 81 00 c4 	brne	80003b9e <create_data_list+0x1ca>
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
80003a1a:	ee c8 00 1c 	sub	r8,r7,28
80003a1e:	30 7a       	mov	r10,7
80003a20:	10 9b       	mov	r11,r8
80003a22:	4e 4c       	lddpc	r12,80003bb0 <create_data_list+0x1dc>
80003a24:	f0 1f 00 64 	mcall	80003bb4 <create_data_list+0x1e0>
80003a28:	18 98       	mov	r8,r12
80003a2a:	58 08       	cp.w	r8,0
80003a2c:	c4 60       	breq	80003ab8 <create_data_list+0xe4>
		{
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
80003a2e:	c1 a8       	rjmp	80003a62 <create_data_list+0x8e>
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
80003a30:	30 3b       	mov	r11,3
80003a32:	ee fc ff f8 	ld.w	r12,r7[-8]
80003a36:	f0 1f 00 61 	mcall	80003bb8 <create_data_list+0x1e4>
80003a3a:	18 98       	mov	r8,r12
80003a3c:	ef 48 ff f0 	st.w	r7[-16],r8
				if(return_code != DF_ERASE_COMPLETED)
80003a40:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003a44:	58 58       	cp.w	r8,5
80003a46:	c0 30       	breq	80003a4c <create_data_list+0x78>
				{
					return FALSE;
80003a48:	30 08       	mov	r8,0
80003a4a:	ca b8       	rjmp	80003ba0 <create_data_list+0x1cc>
				}
				address+=65536;//64k*1024=65536bytes
80003a4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a50:	fe 38 00 00 	sub	r8,-65536
80003a54:	ef 48 ff f8 	st.w	r7[-8],r8
	if(return_code == DF_OK)
	{
		if(memcmp(FlashLabel, str, sizeof(FlashLabel)-1) != 0)//compare label
		{
			//erase
			for(i; i < (VOICE_LIST_BOUNDARY/(64*1024)); i++)//8*64k
80003a58:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003a5c:	2f f8       	sub	r8,-1
80003a5e:	ef 48 ff f4 	st.w	r7[-12],r8
80003a62:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003a66:	58 78       	cp.w	r8,7
80003a68:	fe 98 ff e4 	brls	80003a30 <create_data_list+0x5c>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(FlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80003a6c:	30 7a       	mov	r10,7
80003a6e:	30 0b       	mov	r11,0
80003a70:	4d 0c       	lddpc	r12,80003bb0 <create_data_list+0x1dc>
80003a72:	f0 1f 00 53 	mcall	80003bbc <create_data_list+0x1e8>
80003a76:	18 98       	mov	r8,r12
80003a78:	ef 48 ff f0 	st.w	r7[-16],r8
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80003a7c:	ee c8 00 1c 	sub	r8,r7,28
80003a80:	30 aa       	mov	r10,10
80003a82:	30 0b       	mov	r11,0
80003a84:	10 9c       	mov	r12,r8
80003a86:	f0 1f 00 49 	mcall	80003ba8 <create_data_list+0x1d4>
			return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80003a8a:	ee c8 00 1c 	sub	r8,r7,28
80003a8e:	30 2a       	mov	r10,2
80003a90:	30 ab       	mov	r11,10
80003a92:	10 9c       	mov	r12,r8
80003a94:	f0 1f 00 4a 	mcall	80003bbc <create_data_list+0x1e8>
80003a98:	18 98       	mov	r8,r12
80003a9a:	ef 48 ff f0 	st.w	r7[-16],r8
			if(return_code != DF_WRITE_COMPLETED)
80003a9e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003aa2:	58 78       	cp.w	r8,7
80003aa4:	c0 30       	breq	80003aaa <create_data_list+0xd6>
			{
				return FALSE;
80003aa6:	30 08       	mov	r8,0
80003aa8:	c7 c8       	rjmp	80003ba0 <create_data_list+0x1cc>
			}
			data_flash_read_block(LABEL_ADDRESS, 512, FLASH_BUF);										
80003aaa:	4c 6a       	lddpc	r10,80003bc0 <create_data_list+0x1ec>
80003aac:	e0 6b 02 00 	mov	r11,512
80003ab0:	30 0c       	mov	r12,0
80003ab2:	f0 1f 00 3f 	mcall	80003bac <create_data_list+0x1d8>
80003ab6:	c6 f8       	rjmp	80003b94 <create_data_list+0x1c0>
		}
		else//success
		{	
			//Get the current voice index
			return_code = data_flash_read_block(VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH, &current_voice_index);
80003ab8:	4c 38       	lddpc	r8,80003bc4 <create_data_list+0x1f0>
80003aba:	10 9a       	mov	r10,r8
80003abc:	30 2b       	mov	r11,2
80003abe:	30 ac       	mov	r12,10
80003ac0:	f0 1f 00 3b 	mcall	80003bac <create_data_list+0x1d8>
80003ac4:	18 98       	mov	r8,r12
80003ac6:	ef 48 ff f0 	st.w	r7[-16],r8
			if(return_code == DF_OK) 
80003aca:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003ace:	58 08       	cp.w	r8,0
80003ad0:	c6 01       	brne	80003b90 <create_data_list+0x1bc>
			{	
				//Calculates the offset address of the current stored voice
				if(current_voice_index != 0){
80003ad2:	4b d8       	lddpc	r8,80003bc4 <create_data_list+0x1f0>
80003ad4:	90 08       	ld.sh	r8,r8[0x0]
80003ad6:	58 08       	cp.w	r8,0
80003ad8:	c5 e0       	breq	80003b94 <create_data_list+0x1c0>
					
					if(current_voice_index > 100){//reset list numbers
80003ada:	4b b8       	lddpc	r8,80003bc4 <create_data_list+0x1f0>
80003adc:	90 09       	ld.sh	r9,r8[0x0]
80003ade:	36 48       	mov	r8,100
80003ae0:	f0 09 19 00 	cp.h	r9,r8
80003ae4:	e0 88 00 12 	brls	80003b08 <create_data_list+0x134>
						return_code = data_flash_write(str, VOICE_NUMBERS_ADDRESS, VOICE_NUMBERS_LENGTH);
80003ae8:	ee c8 00 1c 	sub	r8,r7,28
80003aec:	30 2a       	mov	r10,2
80003aee:	30 ab       	mov	r11,10
80003af0:	10 9c       	mov	r12,r8
80003af2:	f0 1f 00 33 	mcall	80003bbc <create_data_list+0x1e8>
80003af6:	18 98       	mov	r8,r12
80003af8:	ef 48 ff f0 	st.w	r7[-16],r8
						if(return_code != DF_WRITE_COMPLETED)
80003afc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003b00:	58 78       	cp.w	r8,7
80003b02:	c0 30       	breq	80003b08 <create_data_list+0x134>
						{
							return FALSE;
80003b04:	30 08       	mov	r8,0
80003b06:	c4 d8       	rjmp	80003ba0 <create_data_list+0x1cc>
						}
					}
					
					address = START_ADDRESS_OF_VOICE_INFO + ((current_voice_index -1)*VOICE_INFO_LENGTH);
80003b08:	4a f8       	lddpc	r8,80003bc4 <create_data_list+0x1f0>
80003b0a:	90 08       	ld.sh	r8,r8[0x0]
80003b0c:	5c 78       	castu.h	r8
80003b0e:	2f f8       	sub	r8,-1
80003b10:	a3 78       	lsl	r8,0x3
80003b12:	ef 48 ff f8 	st.w	r7[-8],r8
					return_code = data_flash_read_block(address, VOICE_INFO_LENGTH, (U8 *)str);
80003b16:	ee c8 00 1c 	sub	r8,r7,28
80003b1a:	10 9a       	mov	r10,r8
80003b1c:	30 8b       	mov	r11,8
80003b1e:	ee fc ff f8 	ld.w	r12,r7[-8]
80003b22:	f0 1f 00 23 	mcall	80003bac <create_data_list+0x1d8>
80003b26:	18 98       	mov	r8,r12
80003b28:	ef 48 ff f0 	st.w	r7[-16],r8
					if(return_code == DF_OK)
80003b2c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003b30:	58 08       	cp.w	r8,0
80003b32:	c3 11       	brne	80003b94 <create_data_list+0x1c0>
					{
						VoiceList_Info_t *ptr = (VoiceList_Info_t *)str;
80003b34:	ee c8 00 1c 	sub	r8,r7,28
80003b38:	ef 48 ff fc 	st.w	r7[-4],r8
						if(ptr->numb == current_voice_index)
80003b3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b40:	11 89       	ld.ub	r9,r8[0x0]
80003b42:	a9 69       	lsl	r9,0x8
80003b44:	11 98       	ld.ub	r8,r8[0x1]
80003b46:	12 48       	or	r8,r9
80003b48:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80003b4c:	49 e8       	lddpc	r8,80003bc4 <create_data_list+0x1f0>
80003b4e:	90 08       	ld.sh	r8,r8[0x0]
80003b50:	f0 09 19 00 	cp.h	r9,r8
80003b54:	c1 c1       	brne	80003b8c <create_data_list+0x1b8>
						{
							current_save_voice_offset = ptr->address + ptr->offset;						
80003b56:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b5a:	11 a9       	ld.ub	r9,r8[0x2]
80003b5c:	b9 69       	lsl	r9,0x18
80003b5e:	11 ba       	ld.ub	r10,r8[0x3]
80003b60:	b1 6a       	lsl	r10,0x10
80003b62:	f5 e9 10 09 	or	r9,r10,r9
80003b66:	11 ca       	ld.ub	r10,r8[0x4]
80003b68:	a9 6a       	lsl	r10,0x8
80003b6a:	f5 e9 10 09 	or	r9,r10,r9
80003b6e:	11 d8       	ld.ub	r8,r8[0x5]
80003b70:	12 48       	or	r8,r9
80003b72:	10 99       	mov	r9,r8
80003b74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b78:	11 ea       	ld.ub	r10,r8[0x6]
80003b7a:	a9 6a       	lsl	r10,0x8
80003b7c:	11 f8       	ld.ub	r8,r8[0x7]
80003b7e:	14 48       	or	r8,r10
80003b80:	5c 88       	casts.h	r8
80003b82:	5c 78       	castu.h	r8
80003b84:	10 09       	add	r9,r8
80003b86:	49 18       	lddpc	r8,80003bc8 <create_data_list+0x1f4>
80003b88:	91 09       	st.w	r8[0x0],r9
80003b8a:	c0 58       	rjmp	80003b94 <create_data_list+0x1c0>
						}
						else
							return FALSE;		
80003b8c:	30 08       	mov	r8,0
80003b8e:	c0 98       	rjmp	80003ba0 <create_data_list+0x1cc>
					}
				}
			}
			else
				return FALSE;
80003b90:	30 08       	mov	r8,0
80003b92:	c0 78       	rjmp	80003ba0 <create_data_list+0x1cc>
		}
		flash_init_success_flag = 1;
80003b94:	48 e9       	lddpc	r9,80003bcc <create_data_list+0x1f8>
80003b96:	30 18       	mov	r8,1
80003b98:	b2 88       	st.b	r9[0x0],r8
		return TRUE;
80003b9a:	30 18       	mov	r8,1
80003b9c:	c0 28       	rjmp	80003ba0 <create_data_list+0x1cc>
	}
	return FALSE;
80003b9e:	30 08       	mov	r8,0

}
80003ba0:	10 9c       	mov	r12,r8
80003ba2:	2f 9d       	sub	sp,-28
80003ba4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ba8:	80 00       	ld.sh	r0,r0[0x0]
80003baa:	b1 ba       	sbr	r10,0x11
80003bac:	80 00       	ld.sh	r0,r0[0x0]
80003bae:	41 10       	lddsp	r0,sp[0x44]
80003bb0:	00 00       	add	r0,r0
80003bb2:	04 f4       	st.b	--r2,r4
80003bb4:	80 00       	ld.sh	r0,r0[0x0]
80003bb6:	b0 4c       	st.h	r8[0x8],r12
80003bb8:	80 00       	ld.sh	r0,r0[0x0]
80003bba:	3b d0       	mov	r0,-67
80003bbc:	80 00       	ld.sh	r0,r0[0x0]
80003bbe:	3c d0       	mov	r0,-51
80003bc0:	00 00       	add	r0,r0
80003bc2:	0d a0       	ld.ub	r0,r6[0x2]
80003bc4:	00 00       	add	r0,r0
80003bc6:	0a 7a       	tst	r10,r5
80003bc8:	00 00       	add	r0,r0
80003bca:	04 fc       	st.b	--r2,r12
80003bcc:	00 00       	add	r0,r0
80003bce:	0a 7c       	tst	r12,r5

80003bd0 <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80003bd0:	eb cd 40 80 	pushm	r7,lr
80003bd4:	1a 97       	mov	r7,sp
80003bd6:	20 5d       	sub	sp,20
80003bd8:	ef 4c ff f0 	st.w	r7[-16],r12
80003bdc:	ef 4b ff ec 	st.w	r7[-20],r11
	U16 status = 1;
80003be0:	30 18       	mov	r8,1
80003be2:	ef 58 ff f4 	st.h	r7[-12],r8
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
80003be6:	30 48       	mov	r8,4
80003be8:	ef 48 ff f8 	st.w	r7[-8],r8
	U16 count = 0; /* to monitor erase time consumption */
80003bec:	30 08       	mov	r8,0
80003bee:	ef 58 ff fe 	st.h	r7[-2],r8

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80003bf2:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003bf6:	e0 69 ff fe 	mov	r9,65534
80003bfa:	ea 19 00 7f 	orh	r9,0x7f
80003bfe:	12 38       	cp.w	r8,r9
80003c00:	e0 88 00 04 	brls	80003c08 <data_flash_erase_block+0x38>
	{
		return DF_INVALID_PARAM;
80003c04:	30 18       	mov	r8,1
80003c06:	c5 f8       	rjmp	80003cc4 <data_flash_erase_block+0xf4>
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80003c08:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003c0c:	58 18       	cp.w	r8,1
80003c0e:	c0 51       	brne	80003c18 <data_flash_erase_block+0x48>
		erase_commond = BLOCK_ERASE_4KB;
80003c10:	32 08       	mov	r8,32
80003c12:	ef 58 ff f6 	st.h	r7[-10],r8
80003c16:	c0 d8       	rjmp	80003c30 <data_flash_erase_block+0x60>
	else if (block_size == DF_BLOCK_32KB)
80003c18:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003c1c:	58 28       	cp.w	r8,2
80003c1e:	c0 51       	brne	80003c28 <data_flash_erase_block+0x58>
		erase_commond = BLOCK_ERASE_32KB;
80003c20:	35 28       	mov	r8,82
80003c22:	ef 58 ff f6 	st.h	r7[-10],r8
80003c26:	c0 58       	rjmp	80003c30 <data_flash_erase_block+0x60>
	else /* (block_size == DF_BLOCK_64KB) */
		erase_commond = BLOCK_ERASE_64KB;
80003c28:	e0 68 00 d8 	mov	r8,216
80003c2c:	ef 58 ff f6 	st.h	r7[-10],r8

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80003c30:	30 09       	mov	r9,0
80003c32:	30 0a       	mov	r10,0
80003c34:	30 0b       	mov	r11,0
80003c36:	30 5c       	mov	r12,5
80003c38:	f0 1f 00 25 	mcall	80003ccc <data_flash_erase_block+0xfc>
80003c3c:	18 98       	mov	r8,r12
80003c3e:	5c 88       	casts.h	r8
80003c40:	ef 58 ff f4 	st.h	r7[-12],r8
	if ((status & STATUS_BUSY) != 0)
80003c44:	ef 18 ff f4 	ld.uh	r8,r7[-12]
80003c48:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003c4c:	5c 58       	castu.b	r8
80003c4e:	c0 30       	breq	80003c54 <data_flash_erase_block+0x84>
	{
		return DF_DEVICE_BUSY;
80003c50:	30 28       	mov	r8,2
80003c52:	c3 98       	rjmp	80003cc4 <data_flash_erase_block+0xf4>
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80003c54:	30 09       	mov	r9,0
80003c56:	30 0a       	mov	r10,0
80003c58:	30 0b       	mov	r11,0
80003c5a:	30 6c       	mov	r12,6
80003c5c:	f0 1f 00 1c 	mcall	80003ccc <data_flash_erase_block+0xfc>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80003c60:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80003c64:	30 09       	mov	r9,0
80003c66:	30 0a       	mov	r10,0
80003c68:	ee fb ff f0 	ld.w	r11,r7[-16]
80003c6c:	10 9c       	mov	r12,r8
80003c6e:	f0 1f 00 18 	mcall	80003ccc <data_flash_erase_block+0xfc>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80003c72:	30 09       	mov	r9,0
80003c74:	30 0a       	mov	r10,0
80003c76:	30 0b       	mov	r11,0
80003c78:	30 5c       	mov	r12,5
80003c7a:	f0 1f 00 15 	mcall	80003ccc <data_flash_erase_block+0xfc>
80003c7e:	18 98       	mov	r8,r12
80003c80:	5c 88       	casts.h	r8
80003c82:	ef 58 ff f4 	st.h	r7[-12],r8
		count++;
80003c86:	ef 08 ff fe 	ld.sh	r8,r7[-2]
80003c8a:	2f f8       	sub	r8,-1
80003c8c:	ef 58 ff fe 	st.h	r7[-2],r8
	} while((status & STATUS_BUSY) != 0);
80003c90:	ef 18 ff f4 	ld.uh	r8,r7[-12]
80003c94:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003c98:	5c 58       	castu.b	r8
80003c9a:	ce c1       	brne	80003c72 <data_flash_erase_block+0xa2>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80003c9c:	ef 18 ff f4 	ld.uh	r8,r7[-12]
80003ca0:	e2 18 00 20 	andl	r8,0x20,COH
80003ca4:	c0 50       	breq	80003cae <data_flash_erase_block+0xde>
	{
		return_code = DF_ERASE_FAIL;
80003ca6:	30 48       	mov	r8,4
80003ca8:	ef 48 ff f8 	st.w	r7[-8],r8
80003cac:	c0 48       	rjmp	80003cb4 <data_flash_erase_block+0xe4>
	}
#endif
	else
	{
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
80003cae:	30 58       	mov	r8,5
80003cb0:	ef 48 ff f8 	st.w	r7[-8],r8
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80003cb4:	30 09       	mov	r9,0
80003cb6:	30 0a       	mov	r10,0
80003cb8:	30 0b       	mov	r11,0
80003cba:	30 4c       	mov	r12,4
80003cbc:	f0 1f 00 04 	mcall	80003ccc <data_flash_erase_block+0xfc>

	return return_code;
80003cc0:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80003cc4:	10 9c       	mov	r12,r8
80003cc6:	2f bd       	sub	sp,-20
80003cc8:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ccc:	80 00       	ld.sh	r0,r0[0x0]
80003cce:	36 fc       	mov	r12,111

80003cd0 <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80003cd0:	eb cd 40 80 	pushm	r7,lr
80003cd4:	1a 97       	mov	r7,sp
80003cd6:	20 7d       	sub	sp,28
80003cd8:	ef 4c ff ec 	st.w	r7[-20],r12
80003cdc:	ef 4b ff e8 	st.w	r7[-24],r11
80003ce0:	14 98       	mov	r8,r10
80003ce2:	ef 58 ff e4 	st.h	r7[-28],r8
	U32 secpos;
	U16 secoff;
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;
80003ce6:	30 08       	mov	r8,0
80003ce8:	ef 48 ff fc 	st.w	r7[-4],r8

	secpos	=	address/4096;// 0~2047 for AT25DF641 
80003cec:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003cf0:	ad 88       	lsr	r8,0xc
80003cf2:	ef 48 ff f0 	st.w	r7[-16],r8
	secoff	=	address%4096;//
80003cf6:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003cfa:	5c 88       	casts.h	r8
80003cfc:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
80003d00:	ef 58 ff f6 	st.h	r7[-10],r8
	secremain	=	4096-secoff;//
80003d04:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80003d08:	e0 69 10 00 	mov	r9,4096
80003d0c:	10 19       	sub	r9,r8
80003d0e:	ef 59 ff f8 	st.h	r7[-8],r9
	if(data_length <= secremain)secremain = data_length;//4096
80003d12:	ef 09 ff e4 	ld.sh	r9,r7[-28]
80003d16:	ef 08 ff f8 	ld.sh	r8,r7[-8]
80003d1a:	f0 09 19 00 	cp.h	r9,r8
80003d1e:	e0 8b 00 06 	brhi	80003d2a <data_flash_write+0x5a>
80003d22:	ef 08 ff e4 	ld.sh	r8,r7[-28]
80003d26:	ef 58 ff f8 	st.h	r7[-8],r8
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//
80003d2a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003d2e:	ad 68       	lsl	r8,0xc
80003d30:	4d 6a       	lddpc	r10,80003e88 <data_flash_write+0x1b8>
80003d32:	e0 6b 10 00 	mov	r11,4096
80003d36:	10 9c       	mov	r12,r8
80003d38:	f0 1f 00 55 	mcall	80003e8c <data_flash_write+0x1bc>
		for(i=0; i<secremain; i++)//
80003d3c:	30 08       	mov	r8,0
80003d3e:	ef 58 ff fa 	st.h	r7[-6],r8
80003d42:	c1 38       	rjmp	80003d68 <data_flash_write+0x98>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//
80003d44:	ef 19 ff f6 	ld.uh	r9,r7[-10]
80003d48:	ef 18 ff fa 	ld.uh	r8,r7[-6]
80003d4c:	f2 08 00 08 	add	r8,r9,r8
80003d50:	4c e9       	lddpc	r9,80003e88 <data_flash_write+0x1b8>
80003d52:	f2 08 07 09 	ld.ub	r9,r9[r8]
80003d56:	3f f8       	mov	r8,-1
80003d58:	f0 09 18 00 	cp.b	r9,r8
80003d5c:	c0 e1       	brne	80003d78 <data_flash_write+0xa8>
	secremain	=	4096-secoff;//
	if(data_length <= secremain)secremain = data_length;//4096
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//
		for(i=0; i<secremain; i++)//
80003d5e:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80003d62:	2f f8       	sub	r8,-1
80003d64:	ef 58 ff fa 	st.h	r7[-6],r8
80003d68:	ef 09 ff fa 	ld.sh	r9,r7[-6]
80003d6c:	ef 08 ff f8 	ld.sh	r8,r7[-8]
80003d70:	f0 09 19 00 	cp.h	r9,r8
80003d74:	ce 83       	brcs	80003d44 <data_flash_write+0x74>
80003d76:	c0 28       	rjmp	80003d7a <data_flash_write+0xaa>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//
80003d78:	d7 03       	nop
		}
		if(i < secremain)//
80003d7a:	ef 09 ff fa 	ld.sh	r9,r7[-6]
80003d7e:	ef 08 ff f8 	ld.sh	r8,r7[-8]
80003d82:	f0 09 19 00 	cp.h	r9,r8
80003d86:	c3 52       	brcc	80003df0 <data_flash_write+0x120>
		{
			return_code = data_flash_erase_block(secpos, DF_BLOCK_4KB);//
80003d88:	30 1b       	mov	r11,1
80003d8a:	ee fc ff f0 	ld.w	r12,r7[-16]
80003d8e:	f0 1f 00 41 	mcall	80003e90 <data_flash_write+0x1c0>
80003d92:	18 98       	mov	r8,r12
80003d94:	ef 48 ff fc 	st.w	r7[-4],r8
			for(i=0; i<secremain; i++)	   //
80003d98:	30 08       	mov	r8,0
80003d9a:	ef 58 ff fa 	st.h	r7[-6],r8
80003d9e:	c1 58       	rjmp	80003dc8 <data_flash_write+0xf8>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80003da0:	ef 19 ff fa 	ld.uh	r9,r7[-6]
80003da4:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80003da8:	10 09       	add	r9,r8
80003daa:	ef 18 ff fa 	ld.uh	r8,r7[-6]
80003dae:	ee fa ff ec 	ld.w	r10,r7[-20]
80003db2:	f4 08 00 08 	add	r8,r10,r8
80003db6:	11 88       	ld.ub	r8,r8[0x0]
80003db8:	4b 4a       	lddpc	r10,80003e88 <data_flash_write+0x1b8>
80003dba:	f4 09 0b 08 	st.b	r10[r9],r8
			if(FLASH_BUF[secoff+i]!=0XFF)break;//
		}
		if(i < secremain)//
		{
			return_code = data_flash_erase_block(secpos, DF_BLOCK_4KB);//
			for(i=0; i<secremain; i++)	   //
80003dbe:	ef 08 ff fa 	ld.sh	r8,r7[-6]
80003dc2:	2f f8       	sub	r8,-1
80003dc4:	ef 58 ff fa 	st.h	r7[-6],r8
80003dc8:	ef 09 ff fa 	ld.sh	r9,r7[-6]
80003dcc:	ef 08 ff f8 	ld.sh	r8,r7[-8]
80003dd0:	f0 09 19 00 	cp.h	r9,r8
80003dd4:	ce 63       	brcs	80003da0 <data_flash_write+0xd0>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//
80003dd6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003dda:	ad 68       	lsl	r8,0xc
80003ddc:	e0 6a 10 00 	mov	r10,4096
80003de0:	10 9b       	mov	r11,r8
80003de2:	4a ac       	lddpc	r12,80003e88 <data_flash_write+0x1b8>
80003de4:	f0 1f 00 2c 	mcall	80003e94 <data_flash_write+0x1c4>
80003de8:	18 98       	mov	r8,r12
80003dea:	ef 48 ff fc 	st.w	r7[-4],r8
80003dee:	c0 d8       	rjmp	80003e08 <data_flash_write+0x138>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//,.
80003df0:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003df4:	10 9a       	mov	r10,r8
80003df6:	ee fb ff e8 	ld.w	r11,r7[-24]
80003dfa:	ee fc ff ec 	ld.w	r12,r7[-20]
80003dfe:	f0 1f 00 26 	mcall	80003e94 <data_flash_write+0x1c4>
80003e02:	18 98       	mov	r8,r12
80003e04:	ef 48 ff fc 	st.w	r7[-4],r8
		}
		if(data_length==secremain)break;//
80003e08:	ef 09 ff e4 	ld.sh	r9,r7[-28]
80003e0c:	ef 08 ff f8 	ld.sh	r8,r7[-8]
80003e10:	f0 09 19 00 	cp.h	r9,r8
80003e14:	c0 71       	brne	80003e22 <data_flash_write+0x152>
			if(data_length>4096)secremain=4096;	//
			else secremain=data_length;			//
		}
	}
	
	return return_code;
80003e16:	ee f8 ff fc 	ld.w	r8,r7[-4]
	
}
80003e1a:	10 9c       	mov	r12,r8
80003e1c:	2f 9d       	sub	sp,-28
80003e1e:	e3 cd 80 80 	ldm	sp++,r7,pc
			return_code = data_flash_write_block(data_ptr, address, secremain);//,.
		}
		if(data_length==secremain)break;//
		else//
		{
			secpos++;//1
80003e22:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003e26:	2f f8       	sub	r8,-1
80003e28:	ef 48 ff f0 	st.w	r7[-16],r8
			secoff=0;//0
80003e2c:	30 08       	mov	r8,0
80003e2e:	ef 58 ff f6 	st.h	r7[-10],r8

			data_ptr+=secremain;  //
80003e32:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003e36:	ee f9 ff ec 	ld.w	r9,r7[-20]
80003e3a:	f2 08 00 08 	add	r8,r9,r8
80003e3e:	ef 48 ff ec 	st.w	r7[-20],r8
			address+=secremain;//
80003e42:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80003e46:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003e4a:	f2 08 00 08 	add	r8,r9,r8
80003e4e:	ef 48 ff e8 	st.w	r7[-24],r8
			data_length-=secremain;				//
80003e52:	ef 09 ff e4 	ld.sh	r9,r7[-28]
80003e56:	ef 08 ff f8 	ld.sh	r8,r7[-8]
80003e5a:	f2 08 01 08 	sub	r8,r9,r8
80003e5e:	ef 58 ff e4 	st.h	r7[-28],r8
			if(data_length>4096)secremain=4096;	//
80003e62:	ef 09 ff e4 	ld.sh	r9,r7[-28]
80003e66:	e0 68 10 00 	mov	r8,4096
80003e6a:	f0 09 19 00 	cp.h	r9,r8
80003e6e:	e0 88 00 07 	brls	80003e7c <data_flash_write+0x1ac>
80003e72:	e0 68 10 00 	mov	r8,4096
80003e76:	ef 58 ff f8 	st.h	r7[-8],r8
			else secremain=data_length;			//
		}
	}
80003e7a:	c5 8b       	rjmp	80003d2a <data_flash_write+0x5a>

			data_ptr+=secremain;  //
			address+=secremain;//
			data_length-=secremain;				//
			if(data_length>4096)secremain=4096;	//
			else secremain=data_length;			//
80003e7c:	ef 08 ff e4 	ld.sh	r8,r7[-28]
80003e80:	ef 58 ff f8 	st.h	r7[-8],r8
		}
	}
80003e84:	c5 3b       	rjmp	80003d2a <data_flash_write+0x5a>
80003e86:	00 00       	add	r0,r0
80003e88:	00 00       	add	r0,r0
80003e8a:	0d a0       	ld.ub	r0,r6[0x2]
80003e8c:	80 00       	ld.sh	r0,r0[0x0]
80003e8e:	41 10       	lddsp	r0,sp[0x44]
80003e90:	80 00       	ld.sh	r0,r0[0x0]
80003e92:	3b d0       	mov	r0,-67
80003e94:	80 00       	ld.sh	r0,r0[0x0]
80003e96:	3e 98       	mov	r8,-23

80003e98 <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80003e98:	eb cd 40 80 	pushm	r7,lr
80003e9c:	1a 97       	mov	r7,sp
80003e9e:	20 6d       	sub	sp,24
80003ea0:	ef 4c ff f0 	st.w	r7[-16],r12
80003ea4:	ef 4b ff ec 	st.w	r7[-20],r11
80003ea8:	14 98       	mov	r8,r10
80003eaa:	ef 58 ff e8 	st.h	r7[-24],r8
	df_status_t return_code = DF_WRITE_COMPLETED;
80003eae:	30 78       	mov	r8,7
80003eb0:	ef 48 ff f4 	st.w	r7[-12],r8
	U32 write_addr = address;
80003eb4:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003eb8:	ef 48 ff f8 	st.w	r7[-8],r8
	U16 bytes_remained = data_length;
80003ebc:	ef 08 ff e8 	ld.sh	r8,r7[-24]
80003ec0:	ef 58 ff fe 	st.h	r7[-2],r8

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80003ec4:	c9 78       	rjmp	80003ff2 <data_flash_write_block+0x15a>
	{
		if ((write_addr & 0xFF) == 0)
80003ec6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003eca:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003ece:	c3 71       	brne	80003f3c <data_flash_write_block+0xa4>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80003ed0:	ef 09 ff fe 	ld.sh	r9,r7[-2]
80003ed4:	e0 68 01 00 	mov	r8,256
80003ed8:	f0 09 19 00 	cp.h	r9,r8
80003edc:	e0 8b 00 12 	brhi	80003f00 <data_flash_write_block+0x68>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80003ee0:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80003ee4:	10 9a       	mov	r10,r8
80003ee6:	ee fb ff f8 	ld.w	r11,r7[-8]
80003eea:	ee fc ff f0 	ld.w	r12,r7[-16]
80003eee:	f0 1f 00 4a 	mcall	80004014 <data_flash_write_block+0x17c>
80003ef2:	18 98       	mov	r8,r12
80003ef4:	ef 48 ff f4 	st.w	r7[-12],r8
				bytes_remained = 0;	/* end while loop */
80003ef8:	30 08       	mov	r8,0
80003efa:	ef 58 ff fe 	st.h	r7[-2],r8
80003efe:	c7 a8       	rjmp	80003ff2 <data_flash_write_block+0x15a>
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80003f00:	e0 6a 01 00 	mov	r10,256
80003f04:	ee fb ff f8 	ld.w	r11,r7[-8]
80003f08:	ee fc ff f0 	ld.w	r12,r7[-16]
80003f0c:	f0 1f 00 42 	mcall	80004014 <data_flash_write_block+0x17c>
80003f10:	18 98       	mov	r8,r12
80003f12:	ef 48 ff f4 	st.w	r7[-12],r8
				bytes_remained -= DF_PAGE_SIZE;
80003f16:	ef 08 ff fe 	ld.sh	r8,r7[-2]
80003f1a:	f0 c8 01 00 	sub	r8,r8,256
80003f1e:	ef 58 ff fe 	st.h	r7[-2],r8
				data_ptr += DF_PAGE_SIZE;
80003f22:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003f26:	f0 c8 ff 00 	sub	r8,r8,-256
80003f2a:	ef 48 ff f0 	st.w	r7[-16],r8
				write_addr += DF_PAGE_SIZE;
80003f2e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f32:	f0 c8 ff 00 	sub	r8,r8,-256
80003f36:	ef 48 ff f8 	st.w	r7[-8],r8
80003f3a:	c5 c8       	rjmp	80003ff2 <data_flash_write_block+0x15a>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80003f3c:	ef 19 ff fe 	ld.uh	r9,r7[-2]
80003f40:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f44:	10 09       	add	r9,r8
80003f46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f4a:	e8 18 00 ff 	orl	r8,0xff
80003f4e:	10 39       	cp.w	r9,r8
80003f50:	e0 88 00 42 	brls	80003fd4 <data_flash_write_block+0x13c>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80003f54:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f58:	5c 88       	casts.h	r8
80003f5a:	e0 18 ff 00 	andl	r8,0xff00
80003f5e:	5c 88       	casts.h	r8
80003f60:	e0 69 01 00 	mov	r9,256
80003f64:	f2 08 01 08 	sub	r8,r9,r8
80003f68:	5c 88       	casts.h	r8
80003f6a:	5c 78       	castu.h	r8
80003f6c:	10 9a       	mov	r10,r8
80003f6e:	ee fb ff f8 	ld.w	r11,r7[-8]
80003f72:	ee fc ff f0 	ld.w	r12,r7[-16]
80003f76:	f0 1f 00 28 	mcall	80004014 <data_flash_write_block+0x17c>
80003f7a:	18 98       	mov	r8,r12
80003f7c:	ef 48 ff f4 	st.w	r7[-12],r8
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80003f80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f84:	5c 88       	casts.h	r8
80003f86:	e0 18 ff 00 	andl	r8,0xff00
80003f8a:	5c 88       	casts.h	r8
80003f8c:	ef 09 ff fe 	ld.sh	r9,r7[-2]
80003f90:	f2 08 00 08 	add	r8,r9,r8
80003f94:	5c 88       	casts.h	r8
80003f96:	f0 c8 01 00 	sub	r8,r8,256
80003f9a:	ef 58 ff fe 	st.h	r7[-2],r8
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80003f9e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fa2:	e4 18 00 7f 	andh	r8,0x7f
80003fa6:	e0 18 ff 00 	andl	r8,0xff00
80003faa:	e0 69 01 00 	mov	r9,256
80003fae:	f2 08 01 08 	sub	r8,r9,r8
80003fb2:	ee f9 ff f0 	ld.w	r9,r7[-16]
80003fb6:	f2 08 00 08 	add	r8,r9,r8
80003fba:	ef 48 ff f0 	st.w	r7[-16],r8
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80003fbe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fc2:	e4 18 ff 80 	andh	r8,0xff80
80003fc6:	e0 18 00 ff 	andl	r8,0xff
80003fca:	f0 c8 ff 00 	sub	r8,r8,-256
80003fce:	ef 48 ff f8 	st.w	r7[-8],r8
80003fd2:	c1 08       	rjmp	80003ff2 <data_flash_write_block+0x15a>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80003fd4:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80003fd8:	10 9a       	mov	r10,r8
80003fda:	ee fb ff f8 	ld.w	r11,r7[-8]
80003fde:	ee fc ff f0 	ld.w	r12,r7[-16]
80003fe2:	f0 1f 00 0d 	mcall	80004014 <data_flash_write_block+0x17c>
80003fe6:	18 98       	mov	r8,r12
80003fe8:	ef 48 ff f4 	st.w	r7[-12],r8
				bytes_remained = 0; /* end while loop */
80003fec:	30 08       	mov	r8,0
80003fee:	ef 58 ff fe 	st.h	r7[-2],r8
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80003ff2:	ef 09 ff fe 	ld.sh	r9,r7[-2]
80003ff6:	30 08       	mov	r8,0
80003ff8:	f0 09 19 00 	cp.h	r9,r8
80003ffc:	c0 60       	breq	80004008 <data_flash_write_block+0x170>
80003ffe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004002:	58 78       	cp.w	r8,7
80004004:	fe 90 ff 61 	breq	80003ec6 <data_flash_write_block+0x2e>
				bytes_remained = 0; /* end while loop */
			}
		}
	}	/* end of while */

	return return_code;
80004008:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
8000400c:	10 9c       	mov	r12,r8
8000400e:	2f ad       	sub	sp,-24
80004010:	e3 cd 80 80 	ldm	sp++,r7,pc
80004014:	80 00       	ld.sh	r0,r0[0x0]
80004016:	40 18       	lddsp	r8,sp[0x4]

80004018 <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80004018:	eb cd 40 80 	pushm	r7,lr
8000401c:	1a 97       	mov	r7,sp
8000401e:	20 6d       	sub	sp,24
80004020:	ef 4c ff f0 	st.w	r7[-16],r12
80004024:	ef 4b ff ec 	st.w	r7[-20],r11
80004028:	14 98       	mov	r8,r10
8000402a:	ef 58 ff e8 	st.h	r7[-24],r8
	U16 status = 1;
8000402e:	30 18       	mov	r8,1
80004030:	ef 58 ff f6 	st.h	r7[-10],r8
	df_status_t return_code = DF_WRITE_FAIL;
80004034:	30 68       	mov	r8,6
80004036:	ef 48 ff f8 	st.w	r7[-8],r8
	U16 count = 0; /* to monitor write time consumption */
8000403a:	30 08       	mov	r8,0
8000403c:	ef 58 ff fe 	st.h	r7[-2],r8

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80004040:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004044:	58 08       	cp.w	r8,0
80004046:	c1 20       	breq	8000406a <data_flash_write_page+0x52>
80004048:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000404c:	e0 69 ff fe 	mov	r9,65534
80004050:	ea 19 00 7f 	orh	r9,0x7f
80004054:	12 38       	cp.w	r8,r9
80004056:	e0 8b 00 0a 	brhi	8000406a <data_flash_write_page+0x52>
8000405a:	ef 09 ff e8 	ld.sh	r9,r7[-24]
8000405e:	e0 68 01 00 	mov	r8,256
80004062:	f0 09 19 00 	cp.h	r9,r8
80004066:	e0 88 00 04 	brls	8000406e <data_flash_write_page+0x56>
	{
		return DF_INVALID_PARAM;
8000406a:	30 18       	mov	r8,1
8000406c:	c4 c8       	rjmp	80004104 <data_flash_write_page+0xec>
	}

	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
8000406e:	30 09       	mov	r9,0
80004070:	30 0a       	mov	r10,0
80004072:	30 0b       	mov	r11,0
80004074:	30 5c       	mov	r12,5
80004076:	f0 1f 00 26 	mcall	8000410c <data_flash_write_page+0xf4>
8000407a:	18 98       	mov	r8,r12
8000407c:	5c 88       	casts.h	r8
8000407e:	ef 58 ff f6 	st.h	r7[-10],r8
	if ((status & STATUS_BUSY) != 0)
80004082:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80004086:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000408a:	5c 58       	castu.b	r8
8000408c:	c0 30       	breq	80004092 <data_flash_write_page+0x7a>
	{
		return DF_DEVICE_BUSY;
8000408e:	30 28       	mov	r8,2
80004090:	c3 a8       	rjmp	80004104 <data_flash_write_page+0xec>
	}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80004092:	30 09       	mov	r9,0
80004094:	30 0a       	mov	r10,0
80004096:	30 0b       	mov	r11,0
80004098:	30 6c       	mov	r12,6
8000409a:	f0 1f 00 1d 	mcall	8000410c <data_flash_write_page+0xf4>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
8000409e:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800040a2:	10 99       	mov	r9,r8
800040a4:	ee fa ff f0 	ld.w	r10,r7[-16]
800040a8:	ee fb ff ec 	ld.w	r11,r7[-20]
800040ac:	30 2c       	mov	r12,2
800040ae:	f0 1f 00 18 	mcall	8000410c <data_flash_write_page+0xf4>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
800040b2:	30 09       	mov	r9,0
800040b4:	30 0a       	mov	r10,0
800040b6:	30 0b       	mov	r11,0
800040b8:	30 5c       	mov	r12,5
800040ba:	f0 1f 00 15 	mcall	8000410c <data_flash_write_page+0xf4>
800040be:	18 98       	mov	r8,r12
800040c0:	5c 88       	casts.h	r8
800040c2:	ef 58 ff f6 	st.h	r7[-10],r8
		count++;
800040c6:	ef 08 ff fe 	ld.sh	r8,r7[-2]
800040ca:	2f f8       	sub	r8,-1
800040cc:	ef 58 ff fe 	st.h	r7[-2],r8
	} while((status & STATUS_BUSY) != 0);
800040d0:	ef 18 ff f6 	ld.uh	r8,r7[-10]
800040d4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800040d8:	5c 58       	castu.b	r8
800040da:	ce c1       	brne	800040b2 <data_flash_write_page+0x9a>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
800040dc:	ef 18 ff f6 	ld.uh	r8,r7[-10]
800040e0:	e2 18 00 20 	andl	r8,0x20,COH
800040e4:	c0 50       	breq	800040ee <data_flash_write_page+0xd6>
	{
		return_code = DF_WRITE_FAIL;
800040e6:	30 68       	mov	r8,6
800040e8:	ef 48 ff f8 	st.w	r7[-8],r8
800040ec:	c0 48       	rjmp	800040f4 <data_flash_write_page+0xdc>
	}
#endif
	else
	{
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
800040ee:	30 78       	mov	r8,7
800040f0:	ef 48 ff f8 	st.w	r7[-8],r8
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
800040f4:	30 09       	mov	r9,0
800040f6:	30 0a       	mov	r10,0
800040f8:	30 0b       	mov	r11,0
800040fa:	30 4c       	mov	r12,4
800040fc:	f0 1f 00 04 	mcall	8000410c <data_flash_write_page+0xf4>

	return return_code;
80004100:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80004104:	10 9c       	mov	r12,r8
80004106:	2f ad       	sub	sp,-24
80004108:	e3 cd 80 80 	ldm	sp++,r7,pc
8000410c:	80 00       	ld.sh	r0,r0[0x0]
8000410e:	36 fc       	mov	r12,111

80004110 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80004110:	eb cd 40 80 	pushm	r7,lr
80004114:	1a 97       	mov	r7,sp
80004116:	20 3d       	sub	sp,12
80004118:	ef 4c ff fc 	st.w	r7[-4],r12
8000411c:	16 98       	mov	r8,r11
8000411e:	ef 4a ff f4 	st.w	r7[-12],r10
80004122:	ef 58 ff f8 	st.h	r7[-8],r8
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80004126:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000412a:	58 08       	cp.w	r8,0
8000412c:	c1 20       	breq	80004150 <data_flash_read_block+0x40>
8000412e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004132:	e0 69 ff fe 	mov	r9,65534
80004136:	ea 19 00 7f 	orh	r9,0x7f
8000413a:	12 38       	cp.w	r8,r9
8000413c:	e0 8b 00 0a 	brhi	80004150 <data_flash_read_block+0x40>
80004140:	ef 09 ff f8 	ld.sh	r9,r7[-8]
80004144:	e0 68 10 00 	mov	r8,4096
80004148:	f0 09 19 00 	cp.h	r9,r8
8000414c:	e0 88 00 04 	brls	80004154 <data_flash_read_block+0x44>
	{
		return DF_INVALID_PARAM;
80004150:	30 18       	mov	r8,1
80004152:	c0 c8       	rjmp	8000416a <data_flash_read_block+0x5a>
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80004154:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80004158:	10 99       	mov	r9,r8
8000415a:	ee fa ff f4 	ld.w	r10,r7[-12]
8000415e:	ee fb ff fc 	ld.w	r11,r7[-4]
80004162:	30 3c       	mov	r12,3
80004164:	f0 1f 00 04 	mcall	80004174 <data_flash_read_block+0x64>

	return DF_OK;
80004168:	30 08       	mov	r8,0
}
8000416a:	10 9c       	mov	r12,r8
8000416c:	2f dd       	sub	sp,-12
8000416e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004172:	00 00       	add	r0,r0
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	36 fc       	mov	r12,111

80004178 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80004178:	eb cd 40 80 	pushm	r7,lr
8000417c:	1a 97       	mov	r7,sp
8000417e:	20 2d       	sub	sp,8
80004180:	18 98       	mov	r8,r12
80004182:	ef 68 ff f8 	st.b	r7[-8],r8
	U8 Burst_ID = 0;
80004186:	30 08       	mov	r8,0
80004188:	ef 68 ff ff 	st.b	r7[-1],r8
	
	switch(vf_sn)
8000418c:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80004190:	20 18       	sub	r8,1
80004192:	59 18       	cp.w	r8,17
80004194:	e0 8b 00 23 	brhi	800041da <CalculateBurst+0x62>
80004198:	49 59       	lddpc	r9,800041ec <CalculateBurst+0x74>
8000419a:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
	{
		case 0x01:
		case 0x02:
		case 0x03:
		
			Burst_ID = 0x0A;
8000419e:	30 a8       	mov	r8,10
800041a0:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_A;
800041a4:	30 48       	mov	r8,4
800041a6:	c1 e8       	rjmp	800041e2 <CalculateBurst+0x6a>
		
		case 0x04:
		case 0x05:
		case 0x06:
		
			Burst_ID = 0x0B;
800041a8:	30 b8       	mov	r8,11
800041aa:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_B;
800041ae:	30 58       	mov	r8,5
800041b0:	c1 98       	rjmp	800041e2 <CalculateBurst+0x6a>
		
		case 0x07:
		case 0x08:
		case 0x09:
		
			Burst_ID = 0x0C;
800041b2:	30 c8       	mov	r8,12
800041b4:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_C;
800041b8:	30 68       	mov	r8,6
800041ba:	c1 48       	rjmp	800041e2 <CalculateBurst+0x6a>
		
		case 0x0A:
		case 0x0B:
		case 0x0C:
		
			Burst_ID = 0x0D;
800041bc:	30 d8       	mov	r8,13
800041be:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_D;
800041c2:	30 78       	mov	r8,7
800041c4:	c0 f8       	rjmp	800041e2 <CalculateBurst+0x6a>
		
		case 0x0D:
		case 0x0E:
		case 0x0F:
		
			Burst_ID = 0x0E;
800041c6:	30 e8       	mov	r8,14
800041c8:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_E;
800041cc:	30 88       	mov	r8,8
800041ce:	c0 a8       	rjmp	800041e2 <CalculateBurst+0x6a>
			
		case 0x10:
		case 0x11:
		case 0x12:
		
				Burst_ID = 0x0F;
800041d0:	30 f8       	mov	r8,15
800041d2:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICEBURST_F;     
800041d6:	30 98       	mov	r8,9
800041d8:	c0 58       	rjmp	800041e2 <CalculateBurst+0x6a>
		
		default:
		
			Burst_ID = 0x00;
800041da:	30 08       	mov	r8,0
800041dc:	ef 68 ff ff 	st.b	r7[-1],r8
			return VOICE_WATING;
800041e0:	30 08       	mov	r8,0
		
	}
	
}
800041e2:	10 9c       	mov	r12,r8
800041e4:	2f ed       	sub	sp,-8
800041e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800041ea:	00 00       	add	r0,r0
800041ec:	80 01       	ld.sh	r1,r0[0x0]
800041ee:	08 3c       	cp.w	r12,r4
800041f0:	50 41       	stdsp	sp[0x10],r1
800041f2:	59 4c       	cp.w	r12,20
800041f4:	4f 41       	lddpc	r1,800043c4 <phy_init+0xcc>
800041f6:	44 5f       	lddsp	pc,sp[0x114]
800041f8:	52 58       	stdsp	sp[0x94],r8
	...

800041fc <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
800041fc:	eb cd 40 80 	pushm	r7,lr
80004200:	1a 97       	mov	r7,sp
80004202:	20 2d       	sub	sp,8
80004204:	ef 4c ff f8 	st.w	r7[-8],r12
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80004208:	49 08       	lddpc	r8,80004248 <payload_rx_process+0x4c>
8000420a:	70 08       	ld.w	r8,r8[0x0]
8000420c:	58 08       	cp.w	r8,0
8000420e:	c0 a1       	brne	80004222 <payload_rx_process+0x26>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004210:	30 4b       	mov	r11,4
80004212:	30 5c       	mov	r12,5
80004214:	f0 1f 00 0e 	mcall	8000424c <payload_rx_process+0x50>
80004218:	18 99       	mov	r9,r12
8000421a:	48 c8       	lddpc	r8,80004248 <payload_rx_process+0x4c>
8000421c:	91 09       	st.w	r8[0x0],r9
8000421e:	c0 28       	rjmp	80004222 <payload_rx_process+0x26>
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
		}
	
	}
80004220:	d7 03       	nop
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80004222:	48 a8       	lddpc	r8,80004248 <payload_rx_process+0x4c>
80004224:	70 08       	ld.w	r8,r8[0x0]
80004226:	ee cb 00 04 	sub	r11,r7,4
8000422a:	30 09       	mov	r9,0
8000422c:	3f fa       	mov	r10,-1
8000422e:	10 9c       	mov	r12,r8
80004230:	f0 1f 00 08 	mcall	80004250 <payload_rx_process+0x54>
80004234:	18 98       	mov	r8,r12
80004236:	58 18       	cp.w	r8,1
80004238:	cf 41       	brne	80004220 <payload_rx_process+0x24>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
8000423a:	48 78       	lddpc	r8,80004254 <payload_rx_process+0x58>
8000423c:	70 08       	ld.w	r8,r8[0x0]
8000423e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004242:	12 9c       	mov	r12,r9
80004244:	5d 18       	icall	r8
		}
	
	}
80004246:	ce eb       	rjmp	80004222 <payload_rx_process+0x26>
80004248:	00 00       	add	r0,r0
8000424a:	0a 9c       	mov	r12,r5
8000424c:	80 00       	ld.sh	r0,r0[0x0]
8000424e:	89 3c       	st.w	r4[0xc],r12
80004250:	80 00       	ld.sh	r0,r0[0x0]
80004252:	8c 60       	ld.sh	r0,r6[0xc]
80004254:	00 00       	add	r0,r0
80004256:	0a 80       	andn	r0,r5

80004258 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80004258:	eb cd 40 80 	pushm	r7,lr
8000425c:	1a 97       	mov	r7,sp
8000425e:	20 2d       	sub	sp,8
80004260:	ef 4c ff fc 	st.w	r7[-4],r12
80004264:	ef 4b ff f8 	st.w	r7[-8],r11
	payload_rx_exec = payload_rx_func;
80004268:	48 d8       	lddpc	r8,8000429c <payload_init+0x44>
8000426a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000426e:	91 09       	st.w	r8[0x0],r9
	payload_tx_exec = payload_tx_func;
80004270:	48 c8       	lddpc	r8,800042a0 <payload_init+0x48>
80004272:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004276:	91 09       	st.w	r8[0x0],r9
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004278:	48 bb       	lddpc	r11,800042a4 <payload_init+0x4c>
8000427a:	30 08       	mov	r8,0
8000427c:	1a d8       	st.w	--sp,r8
8000427e:	30 08       	mov	r8,0
80004280:	1a d8       	st.w	--sp,r8
80004282:	30 08       	mov	r8,0
80004284:	1a d8       	st.w	--sp,r8
80004286:	30 28       	mov	r8,2
80004288:	30 09       	mov	r9,0
8000428a:	e0 6a 04 00 	mov	r10,1024
8000428e:	48 7c       	lddpc	r12,800042a8 <payload_init+0x50>
80004290:	f0 1f 00 07 	mcall	800042ac <payload_init+0x54>
80004294:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
80004296:	2f ed       	sub	sp,-8
80004298:	e3 cd 80 80 	ldm	sp++,r7,pc
8000429c:	00 00       	add	r0,r0
8000429e:	0a 80       	andn	r0,r5
800042a0:	00 00       	add	r0,r0
800042a2:	0a 84       	andn	r4,r5
800042a4:	80 00       	ld.sh	r0,r0[0x0]
800042a6:	41 f0       	lddsp	r0,sp[0x7c]
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	41 fc       	lddsp	r12,sp[0x7c]
800042ac:	80 00       	ld.sh	r0,r0[0x0]
800042ae:	91 ac       	st.w	r8[0x28],r12
800042b0:	6d 6d       	ld.w	sp,r6[0x58]
800042b2:	00 00       	add	r0,r0
800042b4:	0a 0d       	add	sp,r5
800042b6:	20 78       	sub	r8,7
800042b8:	78 78       	ld.w	r8,r12[0x1c]
800042ba:	78 78       	ld.w	r8,r12[0x1c]
800042bc:	5f 51       	srlt	r1
800042be:	51 5f       	stdsp	sp[0x54],pc
800042c0:	78 78       	ld.w	r8,r12[0x1c]
800042c2:	78 78       	ld.w	r8,r12[0x1c]
800042c4:	78 20       	ld.w	r0,r12[0x8]
800042c6:	0a 0d       	add	sp,r5
800042c8:	00 00       	add	r0,r0
800042ca:	00 00       	add	r0,r0
800042cc:	0a 0d       	add	sp,r5
800042ce:	20 52       	sub	r2,5
800042d0:	61 64       	ld.w	r4,r0[0x58]
800042d2:	69 6f       	ld.w	pc,r4[0x58]
800042d4:	20 49       	sub	r9,4
800042d6:	6e 74       	ld.w	r4,r7[0x1c]
800042d8:	65 72       	ld.w	r2,r2[0x5c]
800042da:	6e 61       	ld.w	r1,r7[0x18]
800042dc:	6c 20       	ld.w	r0,r6[0x8]
800042de:	70 61       	ld.w	r1,r8[0x18]
800042e0:	72 61       	ld.w	r1,r9[0x18]
800042e2:	6d 65       	ld.w	r5,r6[0x58]
800042e4:	74 65       	ld.w	r5,r10[0x18]
800042e6:	72 20       	ld.w	r0,r9[0x8]
800042e8:	6c 65       	ld.w	r5,r6[0x18]
800042ea:	6e 67       	ld.w	r7,r7[0x18]
800042ec:	74 68       	ld.w	r8,r10[0x18]
800042ee:	20 65       	sub	r5,6
800042f0:	72 72       	ld.w	r2,r9[0x1c]
800042f2:	6f 72       	ld.w	r2,r7[0x5c]
800042f4:	20 0a       	sub	r10,0
800042f6:	0d 00       	ld.w	r0,r6++

800042f8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800042f8:	eb cd 40 80 	pushm	r7,lr
800042fc:	1a 97       	mov	r7,sp
800042fe:	20 4d       	sub	sp,16
    /*initialize the SSC*/
    ssc_init();
80004300:	f0 1f 00 34 	mcall	800043d0 <phy_init+0xd8>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80004304:	4b 4b       	lddpc	r11,800043d4 <phy_init+0xdc>
80004306:	4b 5c       	lddpc	r12,800043d8 <phy_init+0xe0>
80004308:	f0 1f 00 35 	mcall	800043dc <phy_init+0xe4>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
8000430c:	30 4b       	mov	r11,4
8000430e:	31 ec       	mov	r12,30
80004310:	f0 1f 00 34 	mcall	800043e0 <phy_init+0xe8>
80004314:	18 99       	mov	r9,r12
80004316:	4b 48       	lddpc	r8,800043e4 <phy_init+0xec>
80004318:	91 09       	st.w	r8[0x0],r9
	phy_fragment_t * xnl_ptr = NULL;
8000431a:	30 08       	mov	r8,0
8000431c:	ef 48 ff f0 	st.w	r7[-16],r8
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004320:	30 08       	mov	r8,0
80004322:	ef 48 ff f8 	st.w	r7[-8],r8
80004326:	c1 28       	rjmp	8000434a <phy_init+0x52>
	{
		set_xnl_idle(&xnl_store[i]);
80004328:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000432c:	f0 09 15 08 	lsl	r9,r8,0x8
80004330:	4a e8       	lddpc	r8,800043e8 <phy_init+0xf0>
80004332:	10 09       	add	r9,r8
80004334:	4a c8       	lddpc	r8,800043e4 <phy_init+0xec>
80004336:	70 08       	ld.w	r8,r8[0x0]
80004338:	12 9b       	mov	r11,r9
8000433a:	10 9c       	mov	r12,r8
8000433c:	f0 1f 00 2c 	mcall	800043ec <phy_init+0xf4>
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004340:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004344:	2f f8       	sub	r8,-1
80004346:	ef 48 ff f8 	st.w	r7[-8],r8
8000434a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000434e:	59 d8       	cp.w	r8,29
80004350:	fe 9a ff ec 	brle	80004328 <phy_init+0x30>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004354:	30 4b       	mov	r11,4
80004356:	31 4c       	mov	r12,20
80004358:	f0 1f 00 22 	mcall	800043e0 <phy_init+0xe8>
8000435c:	18 99       	mov	r9,r12
8000435e:	4a 58       	lddpc	r8,800043f0 <phy_init+0xf8>
80004360:	91 09       	st.w	r8[0x0],r9
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004362:	30 4b       	mov	r11,4
80004364:	30 ac       	mov	r12,10
80004366:	f0 1f 00 1f 	mcall	800043e0 <phy_init+0xe8>
8000436a:	18 99       	mov	r9,r12
8000436c:	4a 28       	lddpc	r8,800043f4 <phy_init+0xfc>
8000436e:	91 09       	st.w	r8[0x0],r9
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004370:	30 4b       	mov	r11,4
80004372:	30 ac       	mov	r12,10
80004374:	f0 1f 00 1b 	mcall	800043e0 <phy_init+0xe8>
80004378:	18 99       	mov	r9,r12
8000437a:	4a 08       	lddpc	r8,800043f8 <phy_init+0x100>
8000437c:	91 09       	st.w	r8[0x0],r9
	U8 * payload_ptr = NULL;
8000437e:	30 08       	mov	r8,0
80004380:	ef 48 ff f4 	st.w	r7[-12],r8
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004384:	30 08       	mov	r8,0
80004386:	ef 48 ff fc 	st.w	r7[-4],r8
8000438a:	c1 28       	rjmp	800043ae <phy_init+0xb6>
	{
		set_payload_idle(payload_store[i]);
8000438c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004390:	f0 09 15 09 	lsl	r9,r8,0x9
80004394:	49 a8       	lddpc	r8,800043fc <phy_init+0x104>
80004396:	10 09       	add	r9,r8
80004398:	49 88       	lddpc	r8,800043f8 <phy_init+0x100>
8000439a:	70 08       	ld.w	r8,r8[0x0]
8000439c:	12 9b       	mov	r11,r9
8000439e:	10 9c       	mov	r12,r8
800043a0:	f0 1f 00 13 	mcall	800043ec <phy_init+0xf4>
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
800043a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043a8:	2f f8       	sub	r8,-1
800043aa:	ef 48 ff fc 	st.w	r7[-4],r8
800043ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800043b2:	58 98       	cp.w	r8,9
800043b4:	fe 9a ff ec 	brle	8000438c <phy_init+0x94>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
800043b8:	e0 6b 01 00 	mov	r11,256
800043bc:	30 5c       	mov	r12,5
800043be:	f0 1f 00 09 	mcall	800043e0 <phy_init+0xe8>
800043c2:	18 99       	mov	r9,r12
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
800043c4:	48 f8       	lddpc	r8,80004400 <phy_init+0x108>
800043c6:	91 09       	st.w	r8[0x0],r9
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
800043c8:	2f cd       	sub	sp,-16
800043ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800043ce:	00 00       	add	r0,r0
800043d0:	80 00       	ld.sh	r0,r0[0x0]
800043d2:	62 44       	ld.w	r4,r1[0x10]
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	45 10       	lddsp	r0,sp[0x144]
800043d8:	80 00       	ld.sh	r0,r0[0x0]
800043da:	45 50       	lddsp	r0,sp[0x154]
800043dc:	80 00       	ld.sh	r0,r0[0x0]
800043de:	62 c4       	ld.w	r4,r1[0x30]
800043e0:	80 00       	ld.sh	r0,r0[0x0]
800043e2:	89 3c       	st.w	r4[0xc],r12
800043e4:	00 00       	add	r0,r0
800043e6:	0a 88       	andn	r8,r5
800043e8:	00 00       	add	r0,r0
800043ea:	34 c6       	mov	r6,76
800043ec:	80 00       	ld.sh	r0,r0[0x0]
800043ee:	5f d4       	srvc	r4
800043f0:	00 00       	add	r0,r0
800043f2:	0a 8c       	andn	r12,r5
800043f4:	00 00       	add	r0,r0
800043f6:	0a 90       	mov	r0,r5
800043f8:	00 00       	add	r0,r0
800043fa:	0a 94       	mov	r4,r5
800043fc:	00 00       	add	r0,r0
800043fe:	20 c6       	sub	r6,12
80004400:	00 00       	add	r0,r0
80004402:	0a 98       	mov	r8,r5

80004404 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80004404:	eb cd 40 80 	pushm	r7,lr
80004408:	1a 97       	mov	r7,sp
8000440a:	20 2d       	sub	sp,8
8000440c:	ef 4c ff f8 	st.w	r7[-8],r12
    Bool res = FALSE;
80004410:	30 08       	mov	r8,0
80004412:	ef 68 ff fd 	st.b	r7[-3],r8
	
	U16 phy_ctrl = phy->xnl_fragment.phy_header.phy_control;
80004416:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000441a:	90 08       	ld.sh	r8,r8[0x0]
8000441c:	ef 58 ff fe 	st.h	r7[-2],r8
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80004420:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80004424:	e2 18 f0 00 	andl	r8,0xf000,COH
80004428:	e0 48 40 00 	cp.w	r8,16384
8000442c:	c1 51       	brne	80004456 <phy_tx+0x52>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
8000442e:	49 b8       	lddpc	r8,80004498 <phy_tx+0x94>
80004430:	70 08       	ld.w	r8,r8[0x0]
80004432:	58 08       	cp.w	r8,0
80004434:	c2 f0       	breq	80004492 <phy_tx+0x8e>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80004436:	49 98       	lddpc	r8,80004498 <phy_tx+0x94>
80004438:	70 08       	ld.w	r8,r8[0x0]
8000443a:	ee cb 00 08 	sub	r11,r7,8
8000443e:	30 09       	mov	r9,0
80004440:	30 0a       	mov	r10,0
80004442:	10 9c       	mov	r12,r8
80004444:	f0 1f 00 16 	mcall	8000449c <phy_tx+0x98>
80004448:	18 98       	mov	r8,r12
8000444a:	58 18       	cp.w	r8,1
8000444c:	c2 31       	brne	80004492 <phy_tx+0x8e>
			{
				res = TRUE;
8000444e:	30 18       	mov	r8,1
80004450:	ef 68 ff fd 	st.b	r7[-3],r8
80004454:	c1 f8       	rjmp	80004492 <phy_tx+0x8e>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80004456:	ef 18 ff fe 	ld.uh	r8,r7[-2]
8000445a:	e2 18 f0 00 	andl	r8,0xf000,COH
8000445e:	e0 48 10 00 	cp.w	r8,4096
80004462:	c1 60       	breq	8000448e <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
80004464:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80004468:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000446c:	e0 48 20 00 	cp.w	r8,8192
80004470:	c0 f0       	breq	8000448e <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
80004472:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80004476:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
8000447a:	e0 48 50 00 	cp.w	r8,20480
8000447e:	c0 80       	breq	8000448e <phy_tx+0x8a>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
80004480:	ef 18 ff fe 	ld.uh	r8,r7[-2]
80004484:	e2 18 f0 00 	andl	r8,0xf000,COH
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80004488:	e0 48 60 00 	cp.w	r8,24576
8000448c:	c0 31       	brne	80004492 <phy_tx+0x8e>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
8000448e:	48 58       	lddpc	r8,800044a0 <phy_tx+0x9c>
80004490:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80004492:	2f ed       	sub	sp,-8
80004494:	e3 cd 80 80 	ldm	sp++,r7,pc
80004498:	00 00       	add	r0,r0
8000449a:	0a 8c       	andn	r12,r5
8000449c:	80 00       	ld.sh	r0,r0[0x0]
8000449e:	8a 54       	ld.sh	r4,r5[0xa]
800044a0:	00 00       	add	r0,r0
800044a2:	0a 98       	mov	r8,r5

800044a4 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800044a4:	eb cd 40 80 	pushm	r7,lr
800044a8:	1a 97       	mov	r7,sp
800044aa:	20 3d       	sub	sp,12
800044ac:	ef 4c ff f4 	st.w	r7[-12],r12
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800044b0:	30 08       	mov	r8,0
800044b2:	ef 48 ff f8 	st.w	r7[-8],r8
	
	//phy_fragment_t * xx = pvPortMalloc(sizeof(phy_fragment_t));
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
800044b6:	30 08       	mov	r8,0
800044b8:	ef 68 ff fd 	st.b	r7[-3],r8
	
	if(NULL == phy_ptr)
800044bc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800044c0:	58 08       	cp.w	r8,0
800044c2:	c1 e0       	breq	800044fe <phy_rx+0x5a>
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800044c4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800044c8:	90 08       	ld.sh	r8,r8[0x0]
800044ca:	ef 58 ff fe 	st.h	r7[-2],r8

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
800044ce:	ef 18 ff fe 	ld.uh	r8,r7[-2]
800044d2:	e2 18 f0 00 	andl	r8,0xf000,COH
800044d6:	e0 48 40 00 	cp.w	r8,16384
800044da:	c1 31       	brne	80004500 <phy_rx+0x5c>
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800044dc:	48 b8       	lddpc	r8,80004508 <phy_rx+0x64>
800044de:	70 08       	ld.w	r8,r8[0x0]
800044e0:	ee ca 00 08 	sub	r10,r7,8
800044e4:	ee cb 00 0c 	sub	r11,r7,12
800044e8:	30 09       	mov	r9,0
800044ea:	10 9c       	mov	r12,r8
800044ec:	f0 1f 00 08 	mcall	8000450c <phy_rx+0x68>
800044f0:	18 98       	mov	r8,r12
800044f2:	58 18       	cp.w	r8,1
800044f4:	c0 61       	brne	80004500 <phy_rx+0x5c>
			///*  */
			//if (xHigherPriorityTaskWoken == pdTRUE)
			//{
				//taskYIELD();
			//}
			res = TRUE;
800044f6:	30 18       	mov	r8,1
800044f8:	ef 68 ff fd 	st.b	r7[-3],r8
800044fc:	c0 28       	rjmp	80004500 <phy_rx+0x5c>
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
	{
		return;
800044fe:	d7 03       	nop
		}	

    }
		
 
}
80004500:	2f dd       	sub	sp,-12
80004502:	e3 cd 80 80 	ldm	sp++,r7,pc
80004506:	00 00       	add	r0,r0
80004508:	00 00       	add	r0,r0
8000450a:	0a 90       	mov	r0,r5
8000450c:	80 00       	ld.sh	r0,r0[0x0]
8000450e:	8b bc       	st.w	r5[0x2c],r12

80004510 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80004510:	eb cd 40 80 	pushm	r7,lr
80004514:	1a 97       	mov	r7,sp
80004516:	20 1d       	sub	sp,4
80004518:	ef 4c ff fc 	st.w	r7[-4],r12
    if(NULL != phy_xnl_frame_tx)
8000451c:	48 a8       	lddpc	r8,80004544 <phy_tx_func+0x34>
8000451e:	70 08       	ld.w	r8,r8[0x0]
80004520:	58 08       	cp.w	r8,0
80004522:	c0 70       	breq	80004530 <phy_tx_func+0x20>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80004524:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004528:	2f c8       	sub	r8,-4
8000452a:	10 9c       	mov	r12,r8
8000452c:	f0 1f 00 07 	mcall	80004548 <phy_tx_func+0x38>
    {
		//
		//if (ENABLE == PLAYBACK_ENABLE)
		{
			/*send ssc data in payload(media) frame*/
			phy_payload_tx(&(((ssc_fragment_t * )ssc)->payload_channel));	
80004530:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004534:	2f 88       	sub	r8,-8
80004536:	10 9c       	mov	r12,r8
80004538:	f0 1f 00 05 	mcall	8000454c <phy_tx_func+0x3c>
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
8000453c:	2f fd       	sub	sp,-4
8000453e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004542:	00 00       	add	r0,r0
80004544:	00 00       	add	r0,r0
80004546:	0a 8c       	andn	r12,r5
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	45 90       	lddsp	r0,sp[0x164]
8000454c:	80 00       	ld.sh	r0,r0[0x0]
8000454e:	49 f8       	lddpc	r8,800045c8 <phy_xnl_tx+0x38>

80004550 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80004550:	eb cd 40 80 	pushm	r7,lr
80004554:	1a 97       	mov	r7,sp
80004556:	20 1d       	sub	sp,4
80004558:	ef 4c ff fc 	st.w	r7[-4],r12
		
	if(NULL != phy_xnl_frame_rx)
8000455c:	48 a8       	lddpc	r8,80004584 <phy_rx_func+0x34>
8000455e:	70 08       	ld.w	r8,r8[0x0]
80004560:	58 08       	cp.w	r8,0
80004562:	c0 70       	breq	80004570 <phy_rx_func+0x20>
	{
		/*receive ssc data in xnl frame*/
		phy_xnl_rx(&(((ssc_fragment_t * )ssc)->xnl_channel));
80004564:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004568:	2f c8       	sub	r8,-4
8000456a:	10 9c       	mov	r12,r8
8000456c:	f0 1f 00 07 	mcall	80004588 <phy_rx_func+0x38>
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80004570:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004574:	2f 88       	sub	r8,-8
80004576:	10 9c       	mov	r12,r8
80004578:	f0 1f 00 05 	mcall	8000458c <phy_rx_func+0x3c>
	}
	#endif /*end if*/
	
	
}
8000457c:	2f fd       	sub	sp,-4
8000457e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004582:	00 00       	add	r0,r0
80004584:	00 00       	add	r0,r0
80004586:	0a 90       	mov	r0,r5
80004588:	80 00       	ld.sh	r0,r0[0x0]
8000458a:	46 f0       	lddsp	r0,sp[0x1bc]
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	50 70       	stdsp	sp[0x1c],r0

80004590 <phy_xnl_tx>:
Calls:   
    xQueueReceiveFromISR -- freertos
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
80004590:	eb cd 40 80 	pushm	r7,lr
80004594:	1a 97       	mov	r7,sp
80004596:	20 2d       	sub	sp,8
80004598:	ef 4c ff f8 	st.w	r7[-8],r12
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000459c:	30 08       	mov	r8,0
8000459e:	ef 48 ff fc 	st.w	r7[-4],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
800045a2:	4c e8       	lddpc	r8,800046d8 <phy_xnl_tx+0x148>
800045a4:	70 08       	ld.w	r8,r8[0x0]
800045a6:	58 18       	cp.w	r8,1
800045a8:	c3 a0       	breq	8000461c <phy_xnl_tx+0x8c>
800045aa:	c0 53       	brcs	800045b4 <phy_xnl_tx+0x24>
800045ac:	58 28       	cp.w	r8,2
800045ae:	e0 80 00 88 	breq	800046be <phy_xnl_tx+0x12e>
800045b2:	c9 08       	rjmp	800046d2 <phy_xnl_tx+0x142>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
800045b4:	4c a8       	lddpc	r8,800046dc <phy_xnl_tx+0x14c>
800045b6:	70 08       	ld.w	r8,r8[0x0]
800045b8:	ee c9 00 04 	sub	r9,r7,4
800045bc:	12 9a       	mov	r10,r9
800045be:	4c 9b       	lddpc	r11,800046e0 <phy_xnl_tx+0x150>
800045c0:	10 9c       	mov	r12,r8
800045c2:	f0 1f 00 49 	mcall	800046e4 <phy_xnl_tx+0x154>
800045c6:	18 98       	mov	r8,r12
800045c8:	58 18       	cp.w	r8,1
800045ca:	c2 11       	brne	8000460c <phy_xnl_tx+0x7c>
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
				     phy_ptr->xnl_fragment.phy_header.phy_control & 0x000000FF;
800045cc:	4c 58       	lddpc	r8,800046e0 <phy_xnl_tx+0x150>
800045ce:	70 08       	ld.w	r8,r8[0x0]
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
800045d0:	90 08       	ld.sh	r8,r8[0x0]
800045d2:	5c 88       	casts.h	r8
800045d4:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800045d8:	4c 49       	lddpc	r9,800046e8 <phy_xnl_tx+0x158>
800045da:	b2 08       	st.h	r9[0x0],r8
				/*
				Handle to first fragment. Assume index to a valid fragment block.
                Points to first hWord in fragment block.
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
800045dc:	4c 18       	lddpc	r8,800046e0 <phy_xnl_tx+0x150>
800045de:	70 08       	ld.w	r8,r8[0x0]
800045e0:	90 08       	ld.sh	r8,r8[0x0]
				
				/*
				Handle to first fragment. Assume index to a valid fragment block.
                Points to first hWord in fragment block.
				*/
				xnl_tx_channel->dword = 
800045e2:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800045e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045ea:	91 09       	st.w	r8[0x0],r9
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
800045ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045f0:	70 08       	ld.w	r8,r8[0x0]
800045f2:	10 99       	mov	r9,r8
800045f4:	ea 19 ab cd 	orh	r9,0xabcd
800045f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045fc:	91 09       	st.w	r8[0x0],r9
				
				phy_tx_index = 1;
800045fe:	4b c9       	lddpc	r9,800046ec <phy_xnl_tx+0x15c>
80004600:	30 18       	mov	r8,1
80004602:	b2 88       	st.b	r9[0x0],r8
				phy_tx_state = WRITE_NEXT_DWORD;	
80004604:	4b 58       	lddpc	r8,800046d8 <phy_xnl_tx+0x148>
80004606:	30 19       	mov	r9,1
80004608:	91 09       	st.w	r8[0x0],r9
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
8000460a:	c6 48       	rjmp	800046d2 <phy_xnl_tx+0x142>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
8000460c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004610:	e0 69 5a 5a 	mov	r9,23130
80004614:	ea 19 ab cd 	orh	r9,0xabcd
80004618:	91 09       	st.w	r8[0x0],r9
			}			
			break;
8000461a:	c5 c8       	rjmp	800046d2 <phy_xnl_tx+0x142>
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
8000461c:	4b 18       	lddpc	r8,800046e0 <phy_xnl_tx+0x150>
8000461e:	70 09       	ld.w	r9,r8[0x0]
80004620:	4b 38       	lddpc	r8,800046ec <phy_xnl_tx+0x15c>
80004622:	11 88       	ld.ub	r8,r8[0x0]
80004624:	10 9a       	mov	r10,r8
80004626:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
8000462a:	5c 79       	castu.h	r9
8000462c:	b1 69       	lsl	r9,0x10
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
8000462e:	12 9a       	mov	r10,r9
80004630:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004634:	93 0a       	st.w	r9[0x0],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80004636:	2f f8       	sub	r8,-1
80004638:	5c 58       	castu.b	r8
8000463a:	4a d9       	lddpc	r9,800046ec <phy_xnl_tx+0x15c>
8000463c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000463e:	4a b8       	lddpc	r8,800046e8 <phy_xnl_tx+0x158>
80004640:	90 08       	ld.sh	r8,r8[0x0]
80004642:	20 28       	sub	r8,2
80004644:	5c 88       	casts.h	r8
80004646:	5c 88       	casts.h	r8
80004648:	4a 89       	lddpc	r9,800046e8 <phy_xnl_tx+0x158>
8000464a:	b2 08       	st.h	r9[0x0],r8
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
8000464c:	4a 78       	lddpc	r8,800046e8 <phy_xnl_tx+0x158>
8000464e:	90 09       	ld.sh	r9,r8[0x0]
80004650:	30 08       	mov	r8,0
80004652:	f0 09 19 00 	cp.h	r9,r8
80004656:	e0 89 00 0f 	brgt	80004674 <phy_xnl_tx+0xe4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
8000465a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000465e:	70 08       	ld.w	r8,r8[0x0]
80004660:	10 99       	mov	r9,r8
80004662:	e8 19 00 ba 	orl	r9,0xba
80004666:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000466a:	91 09       	st.w	r8[0x0],r9
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
8000466c:	49 b8       	lddpc	r8,800046d8 <phy_xnl_tx+0x148>
8000466e:	30 09       	mov	r9,0
80004670:	91 09       	st.w	r8[0x0],r9
				break;
80004672:	c3 08       	rjmp	800046d2 <phy_xnl_tx+0x142>
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80004674:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004678:	70 0a       	ld.w	r10,r8[0x0]
8000467a:	49 a8       	lddpc	r8,800046e0 <phy_xnl_tx+0x150>
8000467c:	70 09       	ld.w	r9,r8[0x0]
8000467e:	49 c8       	lddpc	r8,800046ec <phy_xnl_tx+0x15c>
80004680:	11 88       	ld.ub	r8,r8[0x0]
80004682:	10 9b       	mov	r11,r8
80004684:	f2 0b 04 19 	ld.sh	r9,r9[r11<<0x1]
80004688:	5c 79       	castu.h	r9
8000468a:	12 4a       	or	r10,r9
8000468c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004690:	93 0a       	st.w	r9[0x0],r10
80004692:	2f f8       	sub	r8,-1
80004694:	5c 58       	castu.b	r8
80004696:	49 69       	lddpc	r9,800046ec <phy_xnl_tx+0x15c>
80004698:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
8000469a:	49 48       	lddpc	r8,800046e8 <phy_xnl_tx+0x158>
8000469c:	90 08       	ld.sh	r8,r8[0x0]
8000469e:	20 28       	sub	r8,2
800046a0:	5c 88       	casts.h	r8
800046a2:	5c 88       	casts.h	r8
800046a4:	49 19       	lddpc	r9,800046e8 <phy_xnl_tx+0x158>
800046a6:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
800046a8:	49 08       	lddpc	r8,800046e8 <phy_xnl_tx+0x158>
800046aa:	90 09       	ld.sh	r9,r8[0x0]
800046ac:	30 08       	mov	r8,0
800046ae:	f0 09 19 00 	cp.h	r9,r8
800046b2:	e0 89 00 0f 	brgt	800046d0 <phy_xnl_tx+0x140>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
800046b6:	48 98       	lddpc	r8,800046d8 <phy_xnl_tx+0x148>
800046b8:	30 29       	mov	r9,2
800046ba:	91 09       	st.w	r8[0x0],r9
			}
			break;
800046bc:	c0 b8       	rjmp	800046d2 <phy_xnl_tx+0x142>

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
800046be:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046c2:	fc 19 00 ba 	movh	r9,0xba
800046c6:	91 09       	st.w	r8[0x0],r9
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
800046c8:	48 48       	lddpc	r8,800046d8 <phy_xnl_tx+0x148>
800046ca:	30 09       	mov	r9,0
800046cc:	91 09       	st.w	r8[0x0],r9
800046ce:	c0 28       	rjmp	800046d2 <phy_xnl_tx+0x142>
			if (phy_tx_expexted_length <= 0)
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
			}
			break;
800046d0:	d7 03       	nop
			/*This fragment finished.*/
			
		default:
			break;
	}
}
800046d2:	2f ed       	sub	sp,-8
800046d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800046d8:	00 00       	add	r0,r0
800046da:	0a f0       	st.b	--r5,r0
800046dc:	00 00       	add	r0,r0
800046de:	0a 8c       	andn	r12,r5
800046e0:	00 00       	add	r0,r0
800046e2:	0a f4       	st.b	--r5,r4
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	8e 4c       	ld.sh	r12,r7[0x8]
800046e8:	00 00       	add	r0,r0
800046ea:	0a f8       	st.b	--r5,r8
800046ec:	00 00       	add	r0,r0
800046ee:	0a fa       	st.b	--r5,r10

800046f0 <phy_xnl_rx>:
Calls:   
    phy_rx
Called By: phy_rx_func
*/
static void phy_xnl_rx(xnl_channel_t * xnl_rx_channel)
{
800046f0:	eb cd 40 80 	pushm	r7,lr
800046f4:	1a 97       	mov	r7,sp
800046f6:	20 3d       	sub	sp,12
800046f8:	ef 4c ff f4 	st.w	r7[-12],r12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800046fc:	30 08       	mov	r8,0
800046fe:	ef 48 ff f8 	st.w	r7[-8],r8
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80004702:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004706:	70 08       	ld.w	r8,r8[0x0]
80004708:	ef 48 ff fc 	st.w	r7[-4],r8

	phy_rx_count++;
8000470c:	fe f8 02 c4 	ld.w	r8,pc[708]
80004710:	70 08       	ld.w	r8,r8[0x0]
80004712:	f0 c9 ff ff 	sub	r9,r8,-1
80004716:	fe f8 02 ba 	ld.w	r8,pc[698]
8000471a:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000471c:	fe f8 02 b8 	ld.w	r8,pc[696]
80004720:	70 08       	ld.w	r8,r8[0x0]
80004722:	58 18       	cp.w	r8,1
80004724:	e0 80 00 ba 	breq	80004898 <phy_xnl_rx+0x1a8>
80004728:	c0 93       	brcs	8000473a <phy_xnl_rx+0x4a>
8000472a:	58 28       	cp.w	r8,2
8000472c:	e0 80 00 81 	breq	8000482e <phy_xnl_rx+0x13e>
80004730:	58 38       	cp.w	r8,3
80004732:	e0 80 01 24 	breq	8000497a <phy_xnl_rx+0x28a>
80004736:	e0 8f 01 49 	bral	800049c8 <phy_xnl_rx+0x2d8>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000473a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000473e:	e0 69 5a 5a 	mov	r9,23130
80004742:	ea 19 ab cd 	orh	r9,0xabcd
80004746:	12 38       	cp.w	r8,r9
80004748:	e0 80 01 37 	breq	800049b6 <phy_xnl_rx+0x2c6>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000474c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004750:	b1 88       	lsr	r8,0x10
80004752:	e0 48 ab cd 	cp.w	r8,43981
80004756:	e0 81 01 32 	brne	800049ba <phy_xnl_rx+0x2ca>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000475a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000475e:	5c 88       	casts.h	r8
80004760:	5c 88       	casts.h	r8
80004762:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80004766:	20 28       	sub	r8,2
80004768:	5c 88       	casts.h	r8
8000476a:	5c 88       	casts.h	r8
8000476c:	fe f9 02 6c 	ld.w	r9,pc[620]
80004770:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80004772:	fe f8 02 66 	ld.w	r8,pc[614]
80004776:	90 09       	ld.sh	r9,r8[0x0]
80004778:	30 08       	mov	r8,0
8000477a:	f0 09 19 00 	cp.h	r9,r8
8000477e:	e0 8a 01 20 	brle	800049be <phy_xnl_rx+0x2ce>
			{
				break;
			}
		
			phy_rx_length = 0;
80004782:	fe f9 02 5a 	ld.w	r9,pc[602]
80004786:	30 08       	mov	r8,0
80004788:	b2 08       	st.h	r9[0x0],r8
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
8000478a:	fe f8 02 56 	ld.w	r8,pc[598]
8000478e:	70 08       	ld.w	r8,r8[0x0]
80004790:	10 9c       	mov	r12,r8
80004792:	f0 1f 00 95 	mcall	800049e4 <phy_xnl_rx+0x2f4>
80004796:	18 98       	mov	r8,r12
80004798:	10 99       	mov	r9,r8
8000479a:	fe f8 02 4e 	ld.w	r8,pc[590]
8000479e:	91 09       	st.w	r8[0x0],r9
			if(NULL == phy_frame_ptr)
800047a0:	fe f8 02 48 	ld.w	r8,pc[584]
800047a4:	70 08       	ld.w	r8,r8[0x0]
800047a6:	58 08       	cp.w	r8,0
800047a8:	e0 80 01 0d 	breq	800049c2 <phy_xnl_rx+0x2d2>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800047ac:	fe f8 02 3c 	ld.w	r8,pc[572]
800047b0:	70 0a       	ld.w	r10,r8[0x0]
800047b2:	fe f8 02 2a 	ld.w	r8,pc[554]
800047b6:	90 08       	ld.sh	r8,r8[0x0]
800047b8:	10 9b       	mov	r11,r8
800047ba:	ee f9 ff fc 	ld.w	r9,r7[-4]
800047be:	5c 89       	casts.h	r9
800047c0:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
800047c4:	2f f8       	sub	r8,-1
800047c6:	5c 88       	casts.h	r8
800047c8:	fe f9 02 14 	ld.w	r9,pc[532]
800047cc:	b2 08       	st.h	r9[0x0],r8
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800047ce:	fe f8 02 1a 	ld.w	r8,pc[538]
800047d2:	70 0a       	ld.w	r10,r8[0x0]
800047d4:	fe f8 02 08 	ld.w	r8,pc[520]
800047d8:	90 08       	ld.sh	r8,r8[0x0]
800047da:	10 9b       	mov	r11,r8
800047dc:	4f d9       	lddpc	r9,800049d0 <phy_xnl_rx+0x2e0>
800047de:	72 09       	ld.w	r9,r9[0x0]
800047e0:	5c 89       	casts.h	r9
800047e2:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
800047e6:	2f f8       	sub	r8,-1
800047e8:	5c 88       	casts.h	r8
800047ea:	4f d9       	lddpc	r9,800049dc <phy_xnl_rx+0x2ec>
800047ec:	b2 08       	st.h	r9[0x0],r8
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800047ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047f2:	e2 18 0f 00 	andl	r8,0xf00,COH
800047f6:	e0 48 01 00 	cp.w	r8,256
800047fa:	c0 c0       	breq	80004812 <phy_xnl_rx+0x122>
800047fc:	e0 8b 00 05 	brhi	80004806 <phy_xnl_rx+0x116>
80004800:	58 08       	cp.w	r8,0
80004802:	c0 80       	breq	80004812 <phy_xnl_rx+0x122>
80004804:	c0 c8       	rjmp	8000481c <phy_xnl_rx+0x12c>
80004806:	e0 48 02 00 	cp.w	r8,512
8000480a:	c0 40       	breq	80004812 <phy_xnl_rx+0x122>
8000480c:	e0 48 03 00 	cp.w	r8,768
80004810:	c0 61       	brne	8000481c <phy_xnl_rx+0x12c>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80004812:	4f 18       	lddpc	r8,800049d4 <phy_xnl_rx+0x2e4>
80004814:	30 29       	mov	r9,2
80004816:	91 09       	st.w	r8[0x0],r9
				break;
80004818:	d7 03       	nop
				default:
					vPortFree(phy_frame_ptr);
					phy_frame_ptr = NULL;					
				break;
			}	
			break;
8000481a:	cd 78       	rjmp	800049c8 <phy_xnl_rx+0x2d8>
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
				break;
				default:
					vPortFree(phy_frame_ptr);
8000481c:	4f 38       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
8000481e:	70 08       	ld.w	r8,r8[0x0]
80004820:	10 9c       	mov	r12,r8
80004822:	f0 1f 00 73 	mcall	800049ec <phy_xnl_rx+0x2fc>
					phy_frame_ptr = NULL;					
80004826:	4f 18       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
80004828:	30 09       	mov	r9,0
8000482a:	91 09       	st.w	r8[0x0],r9
				break;
			}	
			break;
8000482c:	cc e8       	rjmp	800049c8 <phy_xnl_rx+0x2d8>
		Gets here on CSUM. Expect at least one hWord payload. Gets here once 
		on every fragment.*/	
		case WAITING_CHECK_SUM:
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
8000482e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004832:	b1 88       	lsr	r8,0x10
80004834:	5c 88       	casts.h	r8
80004836:	4e f9       	lddpc	r9,800049f0 <phy_xnl_rx+0x300>
80004838:	b2 08       	st.h	r9[0x0],r8
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
8000483a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000483e:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004842:	4e c8       	lddpc	r8,800049f0 <phy_xnl_rx+0x300>
80004844:	90 08       	ld.sh	r8,r8[0x0]
80004846:	f2 08 00 08 	add	r8,r9,r8
8000484a:	5c 88       	casts.h	r8
8000484c:	4e 99       	lddpc	r9,800049f0 <phy_xnl_rx+0x300>
8000484e:	b2 08       	st.h	r9[0x0],r8
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80004850:	4e 68       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
80004852:	70 0a       	ld.w	r10,r8[0x0]
80004854:	4e 28       	lddpc	r8,800049dc <phy_xnl_rx+0x2ec>
80004856:	90 08       	ld.sh	r8,r8[0x0]
80004858:	10 9b       	mov	r11,r8
8000485a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000485e:	5c 89       	casts.h	r9
80004860:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
80004864:	2f f8       	sub	r8,-1
80004866:	5c 88       	casts.h	r8
80004868:	4d d9       	lddpc	r9,800049dc <phy_xnl_rx+0x2ec>
8000486a:	b2 08       	st.h	r9[0x0],r8
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
8000486c:	4d b8       	lddpc	r8,800049d8 <phy_xnl_rx+0x2e8>
8000486e:	90 08       	ld.sh	r8,r8[0x0]
80004870:	20 28       	sub	r8,2
80004872:	5c 88       	casts.h	r8
80004874:	5c 88       	casts.h	r8
80004876:	4d 99       	lddpc	r9,800049d8 <phy_xnl_rx+0x2e8>
80004878:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000487a:	4d 88       	lddpc	r8,800049d8 <phy_xnl_rx+0x2e8>
8000487c:	90 09       	ld.sh	r9,r8[0x0]
8000487e:	30 08       	mov	r8,0
80004880:	f0 09 19 00 	cp.h	r9,r8
80004884:	e0 8a 00 06 	brle	80004890 <phy_xnl_rx+0x1a0>
			{					  
				phy_rx_state = READING_FRAGMENT;
80004888:	4d 38       	lddpc	r8,800049d4 <phy_xnl_rx+0x2e4>
8000488a:	30 19       	mov	r9,1
8000488c:	91 09       	st.w	r8[0x0],r9
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
			}			
		
			break;
8000488e:	c9 d8       	rjmp	800049c8 <phy_xnl_rx+0x2d8>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80004890:	4d 18       	lddpc	r8,800049d4 <phy_xnl_rx+0x2e4>
80004892:	30 39       	mov	r9,3
80004894:	91 09       	st.w	r8[0x0],r9
			}			
		
			break;
80004896:	c9 98       	rjmp	800049c8 <phy_xnl_rx+0x2d8>

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80004898:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000489c:	b1 88       	lsr	r8,0x10
8000489e:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800048a2:	4d 48       	lddpc	r8,800049f0 <phy_xnl_rx+0x300>
800048a4:	90 08       	ld.sh	r8,r8[0x0]
800048a6:	f2 08 00 08 	add	r8,r9,r8
800048aa:	5c 88       	casts.h	r8
800048ac:	4d 19       	lddpc	r9,800049f0 <phy_xnl_rx+0x300>
800048ae:	b2 08       	st.h	r9[0x0],r8
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800048b0:	4c e8       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
800048b2:	70 0a       	ld.w	r10,r8[0x0]
800048b4:	4c a8       	lddpc	r8,800049dc <phy_xnl_rx+0x2ec>
800048b6:	90 08       	ld.sh	r8,r8[0x0]
800048b8:	10 9b       	mov	r11,r8
												 (phy_dword & 0xFFFF0000) >> 16;
800048ba:	ee f9 ff fc 	ld.w	r9,r7[-4]
800048be:	b1 89       	lsr	r9,0x10
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800048c0:	5c 89       	casts.h	r9
800048c2:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
800048c6:	2f f8       	sub	r8,-1
800048c8:	5c 88       	casts.h	r8
800048ca:	4c 59       	lddpc	r9,800049dc <phy_xnl_rx+0x2ec>
800048cc:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800048ce:	4c 38       	lddpc	r8,800049d8 <phy_xnl_rx+0x2e8>
800048d0:	90 08       	ld.sh	r8,r8[0x0]
800048d2:	20 28       	sub	r8,2
800048d4:	5c 88       	casts.h	r8
800048d6:	5c 88       	casts.h	r8
800048d8:	4c 09       	lddpc	r9,800049d8 <phy_xnl_rx+0x2e8>
800048da:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800048dc:	4b f8       	lddpc	r8,800049d8 <phy_xnl_rx+0x2e8>
800048de:	90 09       	ld.sh	r9,r8[0x0]
800048e0:	30 08       	mov	r8,0
800048e2:	f0 09 19 00 	cp.h	r9,r8
800048e6:	e0 89 00 1f 	brgt	80004924 <phy_xnl_rx+0x234>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800048ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800048ee:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
800048f2:	e0 48 00 ba 	cp.w	r8,186
800048f6:	c0 b1       	brne	8000490c <phy_xnl_rx+0x21c>
					&& (phy_check_sum == 0))
800048f8:	4b e8       	lddpc	r8,800049f0 <phy_xnl_rx+0x300>
800048fa:	90 08       	ld.sh	r8,r8[0x0]
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800048fc:	58 08       	cp.w	r8,0
800048fe:	c0 71       	brne	8000490c <phy_xnl_rx+0x21c>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80004900:	4b a8       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
80004902:	70 08       	ld.w	r8,r8[0x0]
80004904:	10 9c       	mov	r12,r8
80004906:	f0 1f 00 3c 	mcall	800049f4 <phy_xnl_rx+0x304>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000490a:	c0 98       	rjmp	8000491c <phy_xnl_rx+0x22c>
				{
					phy_rx(phy_frame_ptr);
				}
				else
				{
					vPortFree(phy_frame_ptr);
8000490c:	4b 78       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
8000490e:	70 08       	ld.w	r8,r8[0x0]
80004910:	10 9c       	mov	r12,r8
80004912:	f0 1f 00 37 	mcall	800049ec <phy_xnl_rx+0x2fc>
					phy_frame_ptr = NULL;
80004916:	4b 58       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
80004918:	30 09       	mov	r9,0
8000491a:	91 09       	st.w	r8[0x0],r9
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000491c:	4a e8       	lddpc	r8,800049d4 <phy_xnl_rx+0x2e4>
8000491e:	30 09       	mov	r9,0
80004920:	91 09       	st.w	r8[0x0],r9
				break;
80004922:	c5 38       	rjmp	800049c8 <phy_xnl_rx+0x2d8>
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80004924:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004928:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000492c:	4b 18       	lddpc	r8,800049f0 <phy_xnl_rx+0x300>
8000492e:	90 08       	ld.sh	r8,r8[0x0]
80004930:	f2 08 00 08 	add	r8,r9,r8
80004934:	5c 88       	casts.h	r8
80004936:	4a f9       	lddpc	r9,800049f0 <phy_xnl_rx+0x300>
80004938:	b2 08       	st.h	r9[0x0],r8
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000493a:	4a c8       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
8000493c:	70 0a       	ld.w	r10,r8[0x0]
8000493e:	4a 88       	lddpc	r8,800049dc <phy_xnl_rx+0x2ec>
80004940:	90 08       	ld.sh	r8,r8[0x0]
80004942:	10 9b       	mov	r11,r8
80004944:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004948:	5c 89       	casts.h	r9
8000494a:	f4 0b 0a 19 	st.h	r10[r11<<0x1],r9
8000494e:	2f f8       	sub	r8,-1
80004950:	5c 88       	casts.h	r8
80004952:	4a 39       	lddpc	r9,800049dc <phy_xnl_rx+0x2ec>
80004954:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80004956:	4a 18       	lddpc	r8,800049d8 <phy_xnl_rx+0x2e8>
80004958:	90 08       	ld.sh	r8,r8[0x0]
8000495a:	20 28       	sub	r8,2
8000495c:	5c 88       	casts.h	r8
8000495e:	5c 88       	casts.h	r8
80004960:	49 e9       	lddpc	r9,800049d8 <phy_xnl_rx+0x2e8>
80004962:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80004964:	49 d8       	lddpc	r8,800049d8 <phy_xnl_rx+0x2e8>
80004966:	90 09       	ld.sh	r9,r8[0x0]
80004968:	30 08       	mov	r8,0
8000496a:	f0 09 19 00 	cp.h	r9,r8
8000496e:	e0 89 00 2c 	brgt	800049c6 <phy_xnl_rx+0x2d6>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80004972:	49 98       	lddpc	r8,800049d4 <phy_xnl_rx+0x2e4>
80004974:	30 39       	mov	r9,3
80004976:	91 09       	st.w	r8[0x0],r9
			}/*else, next Word contains more payload.*/
			break;
80004978:	c2 88       	rjmp	800049c8 <phy_xnl_rx+0x2d8>

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000497a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000497e:	e6 18 00 ff 	andh	r8,0xff,COH
80004982:	fc 19 00 ba 	movh	r9,0xba
80004986:	12 38       	cp.w	r8,r9
80004988:	c0 b1       	brne	8000499e <phy_xnl_rx+0x2ae>
				&& (phy_check_sum == 0))/*Good checksum*/
8000498a:	49 a8       	lddpc	r8,800049f0 <phy_xnl_rx+0x300>
8000498c:	90 08       	ld.sh	r8,r8[0x0]
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000498e:	58 08       	cp.w	r8,0
80004990:	c0 71       	brne	8000499e <phy_xnl_rx+0x2ae>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80004992:	49 68       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
80004994:	70 08       	ld.w	r8,r8[0x0]
80004996:	10 9c       	mov	r12,r8
80004998:	f0 1f 00 17 	mcall	800049f4 <phy_xnl_rx+0x304>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
8000499c:	c0 98       	rjmp	800049ae <phy_xnl_rx+0x2be>
				phy_rx(phy_frame_ptr);

			}
			else
			{
				vPortFree(phy_frame_ptr);
8000499e:	49 38       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
800049a0:	70 08       	ld.w	r8,r8[0x0]
800049a2:	10 9c       	mov	r12,r8
800049a4:	f0 1f 00 12 	mcall	800049ec <phy_xnl_rx+0x2fc>
				phy_frame_ptr = NULL;
800049a8:	49 08       	lddpc	r8,800049e8 <phy_xnl_rx+0x2f8>
800049aa:	30 09       	mov	r9,0
800049ac:	91 09       	st.w	r8[0x0],r9
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800049ae:	48 a8       	lddpc	r8,800049d4 <phy_xnl_rx+0x2e4>
800049b0:	30 09       	mov	r9,0
800049b2:	91 09       	st.w	r8[0x0],r9
800049b4:	c0 a8       	rjmp	800049c8 <phy_xnl_rx+0x2d8>
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
			{
				break;
800049b6:	d7 03       	nop
800049b8:	c0 88       	rjmp	800049c8 <phy_xnl_rx+0x2d8>
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
			{			
				break;
800049ba:	d7 03       	nop
800049bc:	c0 68       	rjmp	800049c8 <phy_xnl_rx+0x2d8>
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
			{
				break;
800049be:	d7 03       	nop
800049c0:	c0 48       	rjmp	800049c8 <phy_xnl_rx+0x2d8>
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
			if(NULL == phy_frame_ptr)
			{
				break;
800049c2:	d7 03       	nop
800049c4:	c0 28       	rjmp	800049c8 <phy_xnl_rx+0x2d8>
			if (phy_rx_expexted_length <= 0)
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
			}/*else, next Word contains more payload.*/
			break;
800049c6:	d7 03       	nop
			phy_rx_state = WAITING_FOR_HEADER;
			break;
		default:
		break;
	}/*End of phy_rx_state switch.*/
}
800049c8:	2f dd       	sub	sp,-12
800049ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800049ce:	00 00       	add	r0,r0
800049d0:	00 00       	add	r0,r0
800049d2:	0a dc       	st.w	--r5,r12
800049d4:	00 00       	add	r0,r0
800049d6:	0a e0       	st.h	--r5,r0
800049d8:	00 00       	add	r0,r0
800049da:	0a e4       	st.h	--r5,r4
800049dc:	00 00       	add	r0,r0
800049de:	0a e6       	st.h	--r5,r6
800049e0:	00 00       	add	r0,r0
800049e2:	0a 88       	andn	r8,r5
800049e4:	80 00       	ld.sh	r0,r0[0x0]
800049e6:	5f 8c       	srls	r12
800049e8:	00 00       	add	r0,r0
800049ea:	0a e8       	st.h	--r5,r8
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	89 04       	st.w	r4[0x0],r4
800049f0:	00 00       	add	r0,r0
800049f2:	0a ec       	st.h	--r5,r12
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	44 a4       	lddsp	r4,sp[0x128]

800049f8 <phy_payload_tx>:
Calls: 
Called By:phy_tx_func
*/

static void phy_payload_tx(payload_channel_t * payload_tx_channel)
{
800049f8:	eb cd 40 80 	pushm	r7,lr
800049fc:	1a 97       	mov	r7,sp
800049fe:	20 1d       	sub	sp,4
80004a00:	ef 4c ff fc 	st.w	r7[-4],r12
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80004a04:	fe f8 05 b8 	ld.w	r8,pc[1464]
80004a08:	11 89       	ld.ub	r9,r8[0x0]
80004a0a:	30 18       	mov	r8,1
80004a0c:	f0 09 18 00 	cp.b	r9,r8
80004a10:	e0 81 02 c8 	brne	80004fa0 <phy_payload_tx+0x5a8>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80004a14:	fe f8 05 ac 	ld.w	r8,pc[1452]
80004a18:	70 08       	ld.w	r8,r8[0x0]
80004a1a:	e0 48 05 af 	cp.w	r8,1455
80004a1e:	e0 8b 00 06 	brhi	80004a2a <phy_payload_tx+0x32>
80004a22:	fe f8 05 9e 	ld.w	r8,pc[1438]
80004a26:	70 08       	ld.w	r8,r8[0x0]
80004a28:	c0 28       	rjmp	80004a2c <phy_payload_tx+0x34>
80004a2a:	30 08       	mov	r8,0
80004a2c:	fe f9 05 94 	ld.w	r9,pc[1428]
80004a30:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80004a32:	fe f8 05 92 	ld.w	r8,pc[1426]
80004a36:	70 08       	ld.w	r8,r8[0x0]
80004a38:	58 68       	cp.w	r8,6
80004a3a:	e0 8b 02 a4 	brhi	80004f82 <phy_payload_tx+0x58a>
80004a3e:	fe f9 05 8a 	ld.w	r9,pc[1418]
80004a42:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80004a46:	fe f8 05 86 	ld.w	r8,pc[1414]
80004a4a:	70 08       	ld.w	r8,r8[0x0]
80004a4c:	58 08       	cp.w	r8,0
80004a4e:	c0 b0       	breq	80004a64 <phy_payload_tx+0x6c>
80004a50:	fe f8 05 7c 	ld.w	r8,pc[1404]
80004a54:	70 08       	ld.w	r8,r8[0x0]
80004a56:	58 a8       	cp.w	r8,10
80004a58:	c0 60       	breq	80004a64 <phy_payload_tx+0x6c>
80004a5a:	fe f8 05 72 	ld.w	r8,pc[1394]
80004a5e:	70 08       	ld.w	r8,r8[0x0]
80004a60:	58 18       	cp.w	r8,1
80004a62:	c0 f1       	brne	80004a80 <phy_payload_tx+0x88>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004a64:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a68:	e0 69 5a 5a 	mov	r9,23130
80004a6c:	ea 19 ab cd 	orh	r9,0xabcd
80004a70:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004a72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a76:	30 09       	mov	r9,0
80004a78:	91 19       	st.w	r8[0x4],r9
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80004a7a:	d7 03       	nop
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
80004a7c:	e0 8f 02 9d 	bral	80004fb6 <phy_payload_tx+0x5be>
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80004a80:	fe f8 05 4c 	ld.w	r8,pc[1356]
80004a84:	70 08       	ld.w	r8,r8[0x0]
80004a86:	58 38       	cp.w	r8,3
80004a88:	c0 f1       	brne	80004aa6 <phy_payload_tx+0xae>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80004a8a:	fe f8 05 46 	ld.w	r8,pc[1350]
80004a8e:	70 09       	ld.w	r9,r8[0x0]
80004a90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004a94:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80004a96:	fe f8 05 3a 	ld.w	r8,pc[1338]
80004a9a:	70 19       	ld.w	r9,r8[0x4]
80004a9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004aa0:	91 19       	st.w	r8[0x4],r9
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
80004aa2:	e0 8f 02 8a 	bral	80004fb6 <phy_payload_tx+0x5be>
				else//
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//
80004aa6:	fe f8 05 26 	ld.w	r8,pc[1318]
80004aaa:	70 08       	ld.w	r8,r8[0x0]
80004aac:	58 28       	cp.w	r8,2
80004aae:	c1 a1       	brne	80004ae2 <phy_payload_tx+0xea>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80004ab0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ab4:	e0 69 c0 32 	mov	r9,49202
80004ab8:	ea 19 ab cd 	orh	r9,0xabcd
80004abc:	91 09       	st.w	r8[0x0],r9
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80004abe:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004ac2:	fe 78 84 7f 	mov	r8,-31617
80004ac6:	b2 28       	st.h	r9[0x4],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80004ac8:	fe f8 05 0c 	ld.w	r8,pc[1292]
80004acc:	90 08       	ld.sh	r8,r8[0x0]
80004ace:	5c 88       	casts.h	r8
80004ad0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004ad4:	b2 38       	st.h	r9[0x6],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80004ad6:	fe f8 04 ee 	ld.w	r8,pc[1262]
80004ada:	30 39       	mov	r9,3
80004adc:	91 09       	st.w	r8[0x0],r9
						AMBEpayload_tx_state = AMBE_EN_FIRST;
					}

				}
				
				break;
80004ade:	e0 8f 02 6c 	bral	80004fb6 <phy_payload_tx+0x5be>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80004ae2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ae6:	e0 69 c0 0e 	mov	r9,49166
80004aea:	ea 19 ab cd 	orh	r9,0xabcd
80004aee:	91 09       	st.w	r8[0x0],r9
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80004af0:	fe f8 04 e8 	ld.w	r8,pc[1256]
80004af4:	90 08       	ld.sh	r8,r8[0x0]
80004af6:	5c 88       	casts.h	r8
80004af8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004afc:	b2 28       	st.h	r9[0x4],r8
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80004afe:	fe f8 04 da 	ld.w	r8,pc[1242]
80004b02:	90 18       	ld.sh	r8,r8[0x2]
80004b04:	5c 88       	casts.h	r8
80004b06:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b0a:	b2 38       	st.h	r9[0x6],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80004b0c:	fe f8 04 b8 	ld.w	r8,pc[1208]
80004b10:	30 19       	mov	r9,1
80004b12:	91 09       	st.w	r8[0x0],r9
					}

				}
				
				break;
80004b14:	e0 8f 02 51 	bral	80004fb6 <phy_payload_tx+0x5be>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80004b18:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b1c:	fe 78 88 f2 	mov	r8,-30478
80004b20:	b2 08       	st.h	r9[0x0],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//
80004b22:	fe f8 04 aa 	ld.w	r8,pc[1194]
80004b26:	70 08       	ld.w	r8,r8[0x0]
80004b28:	58 48       	cp.w	r8,4
80004b2a:	c0 60       	breq	80004b36 <phy_payload_tx+0x13e>
80004b2c:	c7 73       	brcs	80004c1a <phy_payload_tx+0x222>
80004b2e:	58 98       	cp.w	r8,9
80004b30:	e0 8b 00 75 	brhi	80004c1a <phy_payload_tx+0x222>
80004b34:	c4 78       	rjmp	80004bc2 <phy_payload_tx+0x1ca>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80004b36:	fe f8 04 a6 	ld.w	r8,pc[1190]
80004b3a:	11 89       	ld.ub	r9,r8[0x0]
80004b3c:	30 18       	mov	r8,1
80004b3e:	f0 09 18 00 	cp.b	r9,r8
80004b42:	c1 41       	brne	80004b6a <phy_payload_tx+0x172>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80004b44:	fe f8 04 9c 	ld.w	r8,pc[1180]
80004b48:	90 08       	ld.sh	r8,r8[0x0]
80004b4a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b4e:	b2 18       	st.h	r9[0x2],r8
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80004b50:	fe f8 04 90 	ld.w	r8,pc[1168]
80004b54:	90 18       	ld.sh	r8,r8[0x2]
80004b56:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b5a:	b2 28       	st.h	r9[0x4],r8
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80004b5c:	fe f8 04 84 	ld.w	r8,pc[1156]
80004b60:	90 28       	ld.sh	r8,r8[0x4]
80004b62:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b66:	b2 38       	st.h	r9[0x6],r8
80004b68:	c2 88       	rjmp	80004bb8 <phy_payload_tx+0x1c0>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80004b6a:	fe f8 04 76 	ld.w	r8,pc[1142]
80004b6e:	90 09       	ld.sh	r9,r8[0x0]
80004b70:	fe f8 04 74 	ld.w	r8,pc[1140]
80004b74:	90 08       	ld.sh	r8,r8[0x0]
80004b76:	5c 88       	casts.h	r8
80004b78:	f3 e8 20 08 	eor	r8,r9,r8
80004b7c:	5c 88       	casts.h	r8
80004b7e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b82:	b2 18       	st.h	r9[0x2],r8
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80004b84:	fe f8 04 5c 	ld.w	r8,pc[1116]
80004b88:	90 19       	ld.sh	r9,r8[0x2]
80004b8a:	fe f8 04 5a 	ld.w	r8,pc[1114]
80004b8e:	90 18       	ld.sh	r8,r8[0x2]
80004b90:	5c 88       	casts.h	r8
80004b92:	f3 e8 20 08 	eor	r8,r9,r8
80004b96:	5c 88       	casts.h	r8
80004b98:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004b9c:	b2 28       	st.h	r9[0x4],r8
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80004b9e:	fe f8 04 42 	ld.w	r8,pc[1090]
80004ba2:	90 29       	ld.sh	r9,r8[0x4]
80004ba4:	fe f8 04 40 	ld.w	r8,pc[1088]
80004ba8:	90 28       	ld.sh	r8,r8[0x4]
80004baa:	5c 88       	casts.h	r8
80004bac:	f3 e8 20 08 	eor	r8,r9,r8
80004bb0:	5c 88       	casts.h	r8
80004bb2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004bb6:	b2 38       	st.h	r9[0x6],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80004bb8:	fe f8 04 0c 	ld.w	r8,pc[1036]
80004bbc:	30 29       	mov	r9,2
80004bbe:	91 09       	st.w	r8[0x0],r9
					
						break;
80004bc0:	c3 e8       	rjmp	80004c3c <phy_payload_tx+0x244>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80004bc2:	fe f8 04 1e 	ld.w	r8,pc[1054]
80004bc6:	90 09       	ld.sh	r9,r8[0x0]
80004bc8:	fe f8 04 1c 	ld.w	r8,pc[1052]
80004bcc:	90 08       	ld.sh	r8,r8[0x0]
80004bce:	5c 88       	casts.h	r8
80004bd0:	f3 e8 20 08 	eor	r8,r9,r8
80004bd4:	5c 88       	casts.h	r8
80004bd6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004bda:	b2 18       	st.h	r9[0x2],r8
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80004bdc:	fe f8 04 04 	ld.w	r8,pc[1028]
80004be0:	90 19       	ld.sh	r9,r8[0x2]
80004be2:	fe f8 04 02 	ld.w	r8,pc[1026]
80004be6:	90 18       	ld.sh	r8,r8[0x2]
80004be8:	5c 88       	casts.h	r8
80004bea:	f3 e8 20 08 	eor	r8,r9,r8
80004bee:	5c 88       	casts.h	r8
80004bf0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004bf4:	b2 28       	st.h	r9[0x4],r8
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80004bf6:	fe f8 03 ea 	ld.w	r8,pc[1002]
80004bfa:	90 29       	ld.sh	r9,r8[0x4]
80004bfc:	fe f8 03 e8 	ld.w	r8,pc[1000]
80004c00:	90 28       	ld.sh	r8,r8[0x4]
80004c02:	5c 88       	casts.h	r8
80004c04:	f3 e8 20 08 	eor	r8,r9,r8
80004c08:	5c 88       	casts.h	r8
80004c0a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004c0e:	b2 38       	st.h	r9[0x6],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80004c10:	fe f8 03 b4 	ld.w	r8,pc[948]
80004c14:	30 29       	mov	r9,2
80004c16:	91 09       	st.w	r8[0x0],r9
				
						break;
80004c18:	c1 28       	rjmp	80004c3c <phy_payload_tx+0x244>
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004c1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c1e:	e0 69 5a 5a 	mov	r9,23130
80004c22:	ea 19 ab cd 	orh	r9,0xabcd
80004c26:	91 09       	st.w	r8[0x0],r9
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004c28:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004c2c:	30 09       	mov	r9,0
80004c2e:	91 19       	st.w	r8[0x4],r9
							
							AMBEpayload_tx_state = AMBE_IDLE;
80004c30:	fe f8 03 94 	ld.w	r8,pc[916]
80004c34:	30 09       	mov	r9,0
80004c36:	91 09       	st.w	r8[0x0],r9
				}
		
		
		
		
				break;
80004c38:	e0 8f 01 bf 	bral	80004fb6 <phy_payload_tx+0x5be>
80004c3c:	e0 8f 01 bd 	bral	80004fb6 <phy_payload_tx+0x5be>
						  1:VF1 of first Burst A after last Voice Header (49 bits).
						  2:Last 4 bits (bit 45 to bit 48) of every 49 bits AMBE Voice Frame. (72 bits@Super Frame).
					
					*/
					
					payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
80004c40:	fe f8 03 a4 	ld.w	r8,pc[932]
80004c44:	90 38       	ld.sh	r8,r8[0x6]
80004c46:	5c 88       	casts.h	r8
80004c48:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004c4c:	b2 08       	st.h	r9[0x0],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//Pad_bits
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80004c4e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004c52:	e0 68 00 ba 	mov	r8,186
80004c56:	b2 18       	st.h	r9[0x2],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80004c58:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004c5c:	30 08       	mov	r8,0
80004c5e:	b2 28       	st.h	r9[0x4],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80004c60:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004c64:	30 08       	mov	r8,0
80004c66:	b2 38       	st.h	r9[0x6],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80004c68:	fe f8 03 5c 	ld.w	r8,pc[860]
80004c6c:	30 09       	mov	r9,0
80004c6e:	91 09       	st.w	r8[0x0],r9
				
				break;
80004c70:	e0 8f 01 a3 	bral	80004fb6 <phy_payload_tx+0x5be>
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80004c74:	fe f8 03 60 	ld.w	r8,pc[864]
80004c78:	90 18       	ld.sh	r8,r8[0x2]
80004c7a:	5c 88       	casts.h	r8
80004c7c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004c80:	b2 08       	st.h	r9[0x0],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80004c82:	fe f8 03 56 	ld.w	r8,pc[854]
80004c86:	90 08       	ld.sh	r8,r8[0x0]
80004c88:	5c 88       	casts.h	r8
80004c8a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004c8e:	b2 18       	st.h	r9[0x2],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80004c90:	fe f8 03 3c 	ld.w	r8,pc[828]
80004c94:	70 08       	ld.w	r8,r8[0x0]
80004c96:	58 48       	cp.w	r8,4
80004c98:	c1 21       	brne	80004cbc <phy_payload_tx+0x2c4>
80004c9a:	fe f8 03 42 	ld.w	r8,pc[834]
80004c9e:	11 89       	ld.ub	r9,r8[0x0]
80004ca0:	30 18       	mov	r8,1
80004ca2:	f0 09 18 00 	cp.b	r9,r8
80004ca6:	c0 b1       	brne	80004cbc <phy_payload_tx+0x2c4>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80004ca8:	fe f8 03 30 	ld.w	r8,pc[816]
80004cac:	90 18       	ld.sh	r8,r8[0x2]
80004cae:	5c 88       	casts.h	r8
80004cb0:	a9 a8       	sbr	r8,0x8
80004cb2:	5c 88       	casts.h	r8
80004cb4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004cb8:	b2 28       	st.h	r9[0x4],r8
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80004cba:	c0 88       	rjmp	80004cca <phy_payload_tx+0x2d2>
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80004cbc:	fe f8 03 1c 	ld.w	r8,pc[796]
80004cc0:	90 18       	ld.sh	r8,r8[0x2]
80004cc2:	5c 88       	casts.h	r8
80004cc4:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004cc8:	b2 28       	st.h	r9[0x4],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80004cca:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004cce:	fe 78 9a 13 	mov	r8,-26093
80004cd2:	b2 38       	st.h	r9[0x6],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80004cd4:	fe f8 02 f0 	ld.w	r8,pc[752]
80004cd8:	30 49       	mov	r9,4
80004cda:	91 09       	st.w	r8[0x0],r9
					
				break;
80004cdc:	e0 8f 01 6d 	bral	80004fb6 <phy_payload_tx+0x5be>
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80004ce0:	fe f8 03 08 	ld.w	r8,pc[776]
80004ce4:	70 09       	ld.w	r9,r8[0x0]
80004ce6:	fe f8 03 06 	ld.w	r8,pc[774]
80004cea:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80004cee:	5c 88       	casts.h	r8
80004cf0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004cf4:	b2 08       	st.h	r9[0x0],r8
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80004cf6:	fe f8 02 f2 	ld.w	r8,pc[754]
80004cfa:	70 08       	ld.w	r8,r8[0x0]
80004cfc:	f0 c9 ff ff 	sub	r9,r8,-1
80004d00:	fe f8 02 ec 	ld.w	r8,pc[748]
80004d04:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80004d08:	5c 88       	casts.h	r8
80004d0a:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d0e:	b2 18       	st.h	r9[0x2],r8
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80004d10:	fe f8 02 d8 	ld.w	r8,pc[728]
80004d14:	70 08       	ld.w	r8,r8[0x0]
80004d16:	f0 c9 ff fe 	sub	r9,r8,-2
80004d1a:	fe f8 02 d2 	ld.w	r8,pc[722]
80004d1e:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80004d22:	5c 88       	casts.h	r8
80004d24:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d28:	b2 28       	st.h	r9[0x4],r8
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80004d2a:	fe f8 02 be 	ld.w	r8,pc[702]
80004d2e:	70 08       	ld.w	r8,r8[0x0]
80004d30:	f0 c9 ff fd 	sub	r9,r8,-3
80004d34:	fe f8 02 b8 	ld.w	r8,pc[696]
80004d38:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80004d3c:	5c 88       	casts.h	r8
80004d3e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d42:	b2 38       	st.h	r9[0x6],r8
						Soft_index +=4;
80004d44:	fe f8 02 a4 	ld.w	r8,pc[676]
80004d48:	70 08       	ld.w	r8,r8[0x0]
80004d4a:	f0 c9 ff fc 	sub	r9,r8,-4
80004d4e:	fe f8 02 9a 	ld.w	r8,pc[666]
80004d52:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80004d54:	fe f8 02 94 	ld.w	r8,pc[660]
80004d58:	70 08       	ld.w	r8,r8[0x0]
80004d5a:	58 c8       	cp.w	r8,12
80004d5c:	c0 71       	brne	80004d6a <phy_payload_tx+0x372>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80004d5e:	fe f8 02 66 	ld.w	r8,pc[614]
80004d62:	30 59       	mov	r9,5
80004d64:	91 09       	st.w	r8[0x0],r9
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
			
				break;	
80004d66:	e0 8f 01 28 	bral	80004fb6 <phy_payload_tx+0x5be>
							AMBEpayload_tx_state = AMBE_DE_THIRD;
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80004d6a:	fe f8 02 5a 	ld.w	r8,pc[602]
80004d6e:	30 49       	mov	r9,4
80004d70:	91 09       	st.w	r8[0x0],r9
			
				break;	
80004d72:	e0 8f 01 22 	bral	80004fb6 <phy_payload_tx+0x5be>
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80004d76:	fe f8 02 72 	ld.w	r8,pc[626]
80004d7a:	70 09       	ld.w	r9,r8[0x0]
80004d7c:	fe f8 02 70 	ld.w	r8,pc[624]
80004d80:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80004d84:	5c 88       	casts.h	r8
80004d86:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d8a:	b2 08       	st.h	r9[0x0],r8
					Soft_index = 0 ;//
80004d8c:	fe f8 02 5c 	ld.w	r8,pc[604]
80004d90:	30 09       	mov	r9,0
80004d92:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 
					payload_tx_channel->word[1] = 0x8003;
80004d94:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d98:	fe 78 80 03 	mov	r8,-32765
80004d9c:	b2 18       	st.h	r9[0x2],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80004d9e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004da2:	fe 78 88 f3 	mov	r8,-30477
80004da6:	b2 28       	st.h	r9[0x4],r8
				
					switch (m_RxBurstType)//
80004da8:	fe f8 02 24 	ld.w	r8,pc[548]
80004dac:	70 08       	ld.w	r8,r8[0x0]
80004dae:	58 48       	cp.w	r8,4
80004db0:	c0 60       	breq	80004dbc <phy_payload_tx+0x3c4>
80004db2:	c3 e3       	brcs	80004e2e <phy_payload_tx+0x436>
80004db4:	58 98       	cp.w	r8,9
80004db6:	e0 8b 00 3c 	brhi	80004e2e <phy_payload_tx+0x436>
80004dba:	c2 98       	rjmp	80004e0c <phy_payload_tx+0x414>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80004dbc:	fe f8 02 20 	ld.w	r8,pc[544]
80004dc0:	11 89       	ld.ub	r9,r8[0x0]
80004dc2:	30 18       	mov	r8,1
80004dc4:	f0 09 18 00 	cp.b	r9,r8
80004dc8:	c1 01       	brne	80004de8 <phy_payload_tx+0x3f0>
									//if(AMBEBurst_rawdata[0] == Public_AMBEkey[0])//0X1AC3
									{
										
									
										//Pick up public key
										AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80004dca:	fe f8 02 1a 	ld.w	r8,pc[538]
80004dce:	90 08       	ld.sh	r8,r8[0x0]
80004dd0:	5c 88       	casts.h	r8
80004dd2:	fe f9 02 1e 	ld.w	r9,pc[542]
80004dd6:	b2 08       	st.h	r9[0x0],r8
									
										//Post back data
										payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80004dd8:	fe f8 02 0c 	ld.w	r8,pc[524]
80004ddc:	90 08       	ld.sh	r8,r8[0x0]
80004dde:	5c 88       	casts.h	r8
80004de0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004de4:	b2 38       	st.h	r9[0x6],r8
80004de6:	c0 f8       	rjmp	80004e04 <phy_payload_tx+0x40c>
								else//VF_SN==2/3
								{	
									//Decrypt AMBE data(XOR) 
									//Recover data

									payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80004de8:	fe f8 02 08 	ld.w	r8,pc[520]
80004dec:	90 08       	ld.sh	r8,r8[0x0]
80004dee:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004df2:	4f d8       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004df4:	90 08       	ld.sh	r8,r8[0x0]
80004df6:	5c 88       	casts.h	r8
80004df8:	f3 e8 20 08 	eor	r8,r9,r8
80004dfc:	5c 88       	casts.h	r8
80004dfe:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004e02:	b2 38       	st.h	r9[0x6],r8
									
									//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80004e04:	4f 08       	lddpc	r8,80004fc4 <phy_payload_tx+0x5cc>
80004e06:	30 69       	mov	r9,6
80004e08:	91 09       	st.w	r8[0x0],r9
					
							break;
80004e0a:	c2 18       	rjmp	80004e4c <phy_payload_tx+0x454>
						
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80004e0c:	4f 98       	lddpc	r8,80004ff0 <phy_payload_tx+0x5f8>
80004e0e:	90 08       	ld.sh	r8,r8[0x0]
80004e10:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004e14:	4f 48       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004e16:	90 08       	ld.sh	r8,r8[0x0]
80004e18:	5c 88       	casts.h	r8
80004e1a:	f3 e8 20 08 	eor	r8,r9,r8
80004e1e:	5c 88       	casts.h	r8
80004e20:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004e24:	b2 38       	st.h	r9[0x6],r8
								//payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80004e26:	4e 88       	lddpc	r8,80004fc4 <phy_payload_tx+0x5cc>
80004e28:	30 69       	mov	r9,6
80004e2a:	91 09       	st.w	r8[0x0],r9
				
							break;
80004e2c:	c1 08       	rjmp	80004e4c <phy_payload_tx+0x454>
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004e2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e32:	e0 69 5a 5a 	mov	r9,23130
80004e36:	ea 19 ab cd 	orh	r9,0xabcd
80004e3a:	91 09       	st.w	r8[0x0],r9
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004e3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e40:	30 09       	mov	r9,0
80004e42:	91 19       	st.w	r8[0x4],r9
								AMBEpayload_tx_state = AMBE_IDLE;
80004e44:	4e 08       	lddpc	r8,80004fc4 <phy_payload_tx+0x5cc>
80004e46:	30 09       	mov	r9,0
80004e48:	91 09       	st.w	r8[0x0],r9
					
							break;
					}
		
					break;
80004e4a:	cb 68       	rjmp	80004fb6 <phy_payload_tx+0x5be>
80004e4c:	cb 58       	rjmp	80004fb6 <phy_payload_tx+0x5be>
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//
80004e4e:	4e 08       	lddpc	r8,80004fcc <phy_payload_tx+0x5d4>
80004e50:	70 08       	ld.w	r8,r8[0x0]
80004e52:	58 48       	cp.w	r8,4
80004e54:	c0 70       	breq	80004e62 <phy_payload_tx+0x46a>
80004e56:	e0 83 00 85 	brlo	80004f60 <phy_payload_tx+0x568>
80004e5a:	58 98       	cp.w	r8,9
80004e5c:	e0 8b 00 82 	brhi	80004f60 <phy_payload_tx+0x568>
80004e60:	c5 78       	rjmp	80004f0e <phy_payload_tx+0x516>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80004e62:	4d f8       	lddpc	r8,80004fdc <phy_payload_tx+0x5e4>
80004e64:	11 89       	ld.ub	r9,r8[0x0]
80004e66:	30 18       	mov	r8,1
80004e68:	f0 09 18 00 	cp.b	r9,r8
80004e6c:	c2 81       	brne	80004ebc <phy_payload_tx+0x4c4>
								//if(AMBEBurst_rawdata[1] == Public_AMBEkey[1])//0X1840
								{
								
									//Pick up public key
							
									AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80004e6e:	4d e8       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004e70:	90 18       	ld.sh	r8,r8[0x2]
80004e72:	5c 88       	casts.h	r8
80004e74:	4d f9       	lddpc	r9,80004ff0 <phy_payload_tx+0x5f8>
80004e76:	b2 18       	st.h	r9[0x2],r8
									AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80004e78:	4d b8       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004e7a:	90 28       	ld.sh	r8,r8[0x4]
80004e7c:	5c 88       	casts.h	r8
80004e7e:	4d d9       	lddpc	r9,80004ff0 <phy_payload_tx+0x5f8>
80004e80:	b2 28       	st.h	r9[0x4],r8
									AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80004e82:	4d 98       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004e84:	90 38       	ld.sh	r8,r8[0x6]
80004e86:	5c 88       	casts.h	r8
80004e88:	4d a9       	lddpc	r9,80004ff0 <phy_payload_tx+0x5f8>
80004e8a:	b2 38       	st.h	r9[0x6],r8
							
									//Post back data
									payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80004e8c:	4d 68       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004e8e:	90 18       	ld.sh	r8,r8[0x2]
80004e90:	5c 88       	casts.h	r8
80004e92:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004e96:	b2 08       	st.h	r9[0x0],r8
									payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80004e98:	4d 38       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004e9a:	90 28       	ld.sh	r8,r8[0x4]
80004e9c:	5c 88       	casts.h	r8
80004e9e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004ea2:	b2 18       	st.h	r9[0x2],r8
									payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80004ea4:	4d 08       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004ea6:	90 38       	ld.sh	r8,r8[0x6]
80004ea8:	5c 88       	casts.h	r8
80004eaa:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004eae:	b2 28       	st.h	r9[0x4],r8
									payload_tx_channel->word[3] = 0x00BA ;
80004eb0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004eb4:	e0 68 00 ba 	mov	r8,186
80004eb8:	b2 38       	st.h	r9[0x6],r8
80004eba:	c2 68       	rjmp	80004f06 <phy_payload_tx+0x50e>
							{
							
								//Decrypt AMBE data(XOR)
								//Recover data

									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80004ebc:	4c a8       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004ebe:	90 18       	ld.sh	r8,r8[0x2]
80004ec0:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004ec4:	4c b8       	lddpc	r8,80004ff0 <phy_payload_tx+0x5f8>
80004ec6:	90 18       	ld.sh	r8,r8[0x2]
80004ec8:	5c 88       	casts.h	r8
80004eca:	f3 e8 20 08 	eor	r8,r9,r8
80004ece:	5c 88       	casts.h	r8
80004ed0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004ed4:	b2 08       	st.h	r9[0x0],r8
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80004ed6:	4c 48       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004ed8:	90 28       	ld.sh	r8,r8[0x4]
80004eda:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004ede:	4c 58       	lddpc	r8,80004ff0 <phy_payload_tx+0x5f8>
80004ee0:	90 28       	ld.sh	r8,r8[0x4]
80004ee2:	5c 88       	casts.h	r8
80004ee4:	f3 e8 20 08 	eor	r8,r9,r8
80004ee8:	5c 88       	casts.h	r8
80004eea:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004eee:	b2 18       	st.h	r9[0x2],r8
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80004ef0:	4b d8       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004ef2:	90 38       	ld.sh	r8,r8[0x6]
80004ef4:	5c 88       	casts.h	r8
80004ef6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004efa:	b2 28       	st.h	r9[0x4],r8
									
									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
									
									payload_tx_channel->word[3] = 0x00BA ;
80004efc:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004f00:	e0 68 00 ba 	mov	r8,186
80004f04:	b2 38       	st.h	r9[0x6],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80004f06:	4b 08       	lddpc	r8,80004fc4 <phy_payload_tx+0x5cc>
80004f08:	30 09       	mov	r9,0
80004f0a:	91 09       	st.w	r8[0x0],r9
						
						break;
80004f0c:	c3 98       	rjmp	80004f7e <phy_payload_tx+0x586>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
80004f0e:	4b 68       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004f10:	90 18       	ld.sh	r8,r8[0x2]
80004f12:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004f16:	4b 78       	lddpc	r8,80004ff0 <phy_payload_tx+0x5f8>
80004f18:	90 18       	ld.sh	r8,r8[0x2]
80004f1a:	5c 88       	casts.h	r8
80004f1c:	f3 e8 20 08 	eor	r8,r9,r8
80004f20:	5c 88       	casts.h	r8
80004f22:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004f26:	b2 08       	st.h	r9[0x0],r8
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
80004f28:	4a f8       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004f2a:	90 28       	ld.sh	r8,r8[0x4]
80004f2c:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004f30:	4b 08       	lddpc	r8,80004ff0 <phy_payload_tx+0x5f8>
80004f32:	90 28       	ld.sh	r8,r8[0x4]
80004f34:	5c 88       	casts.h	r8
80004f36:	f3 e8 20 08 	eor	r8,r9,r8
80004f3a:	5c 88       	casts.h	r8
80004f3c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004f40:	b2 18       	st.h	r9[0x2],r8
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
80004f42:	4a 98       	lddpc	r8,80004fe4 <phy_payload_tx+0x5ec>
80004f44:	90 38       	ld.sh	r8,r8[0x6]
80004f46:	5c 88       	casts.h	r8
80004f48:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004f4c:	b2 28       	st.h	r9[0x4],r8
							
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]);
							
							payload_tx_channel->word[3] = 0x00BA ;
80004f4e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004f52:	e0 68 00 ba 	mov	r8,186
80004f56:	b2 38       	st.h	r9[0x6],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80004f58:	49 b8       	lddpc	r8,80004fc4 <phy_payload_tx+0x5cc>
80004f5a:	30 09       	mov	r9,0
80004f5c:	91 09       	st.w	r8[0x0],r9
						
							break;
80004f5e:	c1 08       	rjmp	80004f7e <phy_payload_tx+0x586>
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004f60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f64:	e0 69 5a 5a 	mov	r9,23130
80004f68:	ea 19 ab cd 	orh	r9,0xabcd
80004f6c:	91 09       	st.w	r8[0x0],r9
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004f6e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f72:	30 09       	mov	r9,0
80004f74:	91 19       	st.w	r8[0x4],r9
							AMBEpayload_tx_state = AMBE_IDLE;
80004f76:	49 48       	lddpc	r8,80004fc4 <phy_payload_tx+0x5cc>
80004f78:	30 09       	mov	r9,0
80004f7a:	91 09       	st.w	r8[0x0],r9
							
							break;
					}

				break;
80004f7c:	c1 d8       	rjmp	80004fb6 <phy_payload_tx+0x5be>
80004f7e:	d7 03       	nop
80004f80:	c1 b8       	rjmp	80004fb6 <phy_payload_tx+0x5be>
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004f82:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f86:	e0 69 5a 5a 	mov	r9,23130
80004f8a:	ea 19 ab cd 	orh	r9,0xabcd
80004f8e:	91 09       	st.w	r8[0x0],r9
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004f90:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f94:	30 09       	mov	r9,0
80004f96:	91 19       	st.w	r8[0x4],r9
					
					AMBEpayload_tx_state = AMBE_IDLE;
80004f98:	48 b8       	lddpc	r8,80004fc4 <phy_payload_tx+0x5cc>
80004f9a:	30 09       	mov	r9,0
80004f9c:	91 09       	st.w	r8[0x0],r9
80004f9e:	c0 c8       	rjmp	80004fb6 <phy_payload_tx+0x5be>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80004fa0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fa4:	e0 69 5a 5a 	mov	r9,23130
80004fa8:	ea 19 ab cd 	orh	r9,0xabcd
80004fac:	91 09       	st.w	r8[0x0],r9
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80004fae:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fb2:	30 09       	mov	r9,0
80004fb4:	91 19       	st.w	r8[0x4],r9

	}//end of Send-PCM-data
	
#endif

}
80004fb6:	2f fd       	sub	sp,-4
80004fb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fbc:	00 00       	add	r0,r0
80004fbe:	0a 5b       	eor	r11,r5
80004fc0:	00 00       	add	r0,r0
80004fc2:	0a d0       	st.w	--r5,r0
80004fc4:	00 00       	add	r0,r0
80004fc6:	0a d4       	st.w	--r5,r4
80004fc8:	80 01       	ld.sh	r1,r0[0x0]
80004fca:	08 84       	andn	r4,r4
80004fcc:	00 00       	add	r0,r0
80004fce:	0a a0       	st.w	r5++,r0
80004fd0:	00 00       	add	r0,r0
80004fd2:	0a a4       	st.w	r5++,r4
80004fd4:	00 00       	add	r0,r0
80004fd6:	1f ac       	ld.ub	r12,pc[0x2]
80004fd8:	00 00       	add	r0,r0
80004fda:	20 a8       	sub	r8,10
80004fdc:	00 00       	add	r0,r0
80004fde:	0a 5f       	eor	pc,r5
80004fe0:	80 01       	ld.sh	r1,r0[0x0]
80004fe2:	08 34       	cp.w	r4,r4
80004fe4:	00 00       	add	r0,r0
80004fe6:	1f a4       	ld.ub	r4,pc[0x2]
80004fe8:	00 00       	add	r0,r0
80004fea:	0a d8       	st.w	--r5,r8
80004fec:	00 00       	add	r0,r0
80004fee:	20 ac       	sub	r12,10
80004ff0:	00 00       	add	r0,r0
80004ff2:	1f b0       	ld.ub	r0,pc[0x3]

80004ff4 <payload_rx>:




static void payload_rx(void * payload)
{
80004ff4:	eb cd 40 80 	pushm	r7,lr
80004ff8:	1a 97       	mov	r7,sp
80004ffa:	20 2d       	sub	sp,8
80004ffc:	ef 4c ff f8 	st.w	r7[-8],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80005000:	30 08       	mov	r8,0
80005002:	ef 48 ff fc 	st.w	r7[-4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80005006:	49 48       	lddpc	r8,80005054 <payload_rx+0x60>
80005008:	70 08       	ld.w	r8,r8[0x0]
8000500a:	58 08       	cp.w	r8,0
8000500c:	c0 81       	brne	8000501c <payload_rx+0x28>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
8000500e:	30 4b       	mov	r11,4
80005010:	30 5c       	mov	r12,5
80005012:	f0 1f 00 12 	mcall	80005058 <payload_rx+0x64>
80005016:	18 99       	mov	r9,r12
80005018:	48 f8       	lddpc	r8,80005054 <payload_rx+0x60>
8000501a:	91 09       	st.w	r8[0x0],r9
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000501c:	48 e8       	lddpc	r8,80005054 <payload_rx+0x60>
8000501e:	70 08       	ld.w	r8,r8[0x0]
80005020:	ee ca 00 04 	sub	r10,r7,4
80005024:	ee cb 00 08 	sub	r11,r7,8
80005028:	30 09       	mov	r9,0
8000502a:	10 9c       	mov	r12,r8
8000502c:	f0 1f 00 0c 	mcall	8000505c <payload_rx+0x68>
80005030:	18 98       	mov	r8,r12
80005032:	58 08       	cp.w	r8,0
80005034:	c0 c1       	brne	8000504c <payload_rx+0x58>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80005036:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000503a:	48 a8       	lddpc	r8,80005060 <payload_rx+0x6c>
8000503c:	70 08       	ld.w	r8,r8[0x0]
8000503e:	12 9b       	mov	r11,r9
80005040:	10 9c       	mov	r12,r8
80005042:	f0 1f 00 09 	mcall	80005064 <payload_rx+0x70>
		logFromISR("mm");
80005046:	48 9c       	lddpc	r12,80005068 <payload_rx+0x74>
80005048:	f0 1f 00 09 	mcall	8000506c <payload_rx+0x78>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
8000504c:	2f ed       	sub	sp,-8
8000504e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005052:	00 00       	add	r0,r0
80005054:	00 00       	add	r0,r0
80005056:	0a 9c       	mov	r12,r5
80005058:	80 00       	ld.sh	r0,r0[0x0]
8000505a:	89 3c       	st.w	r4[0xc],r12
8000505c:	80 00       	ld.sh	r0,r0[0x0]
8000505e:	8b bc       	st.w	r5[0x2c],r12
80005060:	00 00       	add	r0,r0
80005062:	0a 94       	mov	r4,r5
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	60 00       	ld.w	r0,r0[0x0]
80005068:	80 00       	ld.sh	r0,r0[0x0]
8000506a:	42 b0       	lddsp	r0,sp[0xac]
8000506c:	80 00       	ld.sh	r0,r0[0x0]
8000506e:	a5 f0       	*unknown*

80005070 <phy_payload_rx>:
Description: receive payload(mdia) packet
Calls: 
Called By:phy_rx_func
*/
static void phy_payload_rx(payload_channel_t * payload_rx_channel)
{
80005070:	eb cd 40 80 	pushm	r7,lr
80005074:	1a 97       	mov	r7,sp
80005076:	20 2d       	sub	sp,8
80005078:	ef 4c ff f8 	st.w	r7[-8],r12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000507c:	30 08       	mov	r8,0
8000507e:	ef 48 ff fc 	st.w	r7[-4],r8
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80005082:	fe f8 0e 5e 	ld.w	r8,pc[3678]
80005086:	11 88       	ld.ub	r8,r8[0x0]
80005088:	58 08       	cp.w	r8,0
8000508a:	c1 01       	brne	800050aa <phy_payload_rx+0x3a>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
8000508c:	fe f8 0e 58 	ld.w	r8,pc[3672]
80005090:	70 08       	ld.w	r8,r8[0x0]
80005092:	10 9c       	mov	r12,r8
80005094:	f0 1f 03 95 	mcall	80005ee8 <phy_payload_rx+0xe78>
80005098:	18 98       	mov	r8,r12
8000509a:	10 99       	mov	r9,r8
8000509c:	fe f8 0e 50 	ld.w	r8,pc[3664]
800050a0:	91 09       	st.w	r8[0x0],r9
		is_first = TRUE;
800050a2:	fe f9 0e 3e 	ld.w	r9,pc[3646]
800050a6:	30 18       	mov	r8,1
800050a8:	b2 88       	st.b	r9[0x0],r8
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800050aa:	fe f8 0e 46 	ld.w	r8,pc[3654]
800050ae:	70 08       	ld.w	r8,r8[0x0]
800050b0:	58 38       	cp.w	r8,3
800050b2:	e0 80 06 ad 	breq	80005e0c <phy_payload_rx+0xd9c>
800050b6:	58 48       	cp.w	r8,4
800050b8:	e0 80 01 4e 	breq	80005354 <phy_payload_rx+0x2e4>
800050bc:	58 08       	cp.w	r8,0
800050be:	e0 81 07 0e 	brne	80005eda <phy_payload_rx+0xe6a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800050c2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050c6:	70 08       	ld.w	r8,r8[0x0]
800050c8:	e0 69 5a 5a 	mov	r9,23130
800050cc:	ea 19 ab cd 	orh	r9,0xabcd
800050d0:	12 38       	cp.w	r8,r9
800050d2:	c0 71       	brne	800050e0 <phy_payload_rx+0x70>
			{
				m_RxBurstType = VOICE_WATING;
800050d4:	fe f8 0e 20 	ld.w	r8,pc[3616]
800050d8:	30 09       	mov	r9,0
800050da:	91 09       	st.w	r8[0x0],r9
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
800050dc:	e0 8f 06 ff 	bral	80005eda <phy_payload_rx+0xe6a>
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800050e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050e4:	70 08       	ld.w	r8,r8[0x0]
800050e6:	e0 18 00 00 	andl	r8,0x0
800050ea:	fc 19 ab cd 	movh	r9,0xabcd
800050ee:	12 38       	cp.w	r8,r9
800050f0:	e0 81 06 ea 	brne	80005ec4 <phy_payload_rx+0xe54>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800050f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050f8:	70 08       	ld.w	r8,r8[0x0]
800050fa:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800050fe:	fe f8 0d fa 	ld.w	r8,pc[3578]
80005102:	91 09       	st.w	r8[0x0],r9
		
			if( (NULL== AMBE_payload_ptr))
80005104:	fe f8 0d e8 	ld.w	r8,pc[3560]
80005108:	70 08       	ld.w	r8,r8[0x0]
8000510a:	58 08       	cp.w	r8,0
8000510c:	c1 71       	brne	8000513a <phy_payload_rx+0xca>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
8000510e:	fe f8 0d d6 	ld.w	r8,pc[3542]
80005112:	70 08       	ld.w	r8,r8[0x0]
80005114:	10 9c       	mov	r12,r8
80005116:	f0 1f 03 75 	mcall	80005ee8 <phy_payload_rx+0xe78>
8000511a:	18 98       	mov	r8,r12
8000511c:	10 99       	mov	r9,r8
8000511e:	fe f8 0d ce 	ld.w	r8,pc[3534]
80005122:	91 09       	st.w	r8[0x0],r9
				
				if (NULL== AMBE_payload_ptr)
80005124:	fe f8 0d c8 	ld.w	r8,pc[3528]
80005128:	70 08       	ld.w	r8,r8[0x0]
8000512a:	58 08       	cp.w	r8,0
8000512c:	c0 71       	brne	8000513a <phy_payload_rx+0xca>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//
8000512e:	fe fc 0d ce 	ld.w	r12,pc[3534]
80005132:	f0 1f 03 74 	mcall	80005f00 <phy_payload_rx+0xe90>
					break;
80005136:	e0 8f 06 d2 	bral	80005eda <phy_payload_rx+0xe6a>
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
8000513a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000513e:	70 08       	ld.w	r8,r8[0x0]
80005140:	e2 18 f0 00 	andl	r8,0xf000,COH
80005144:	e0 48 c0 00 	cp.w	r8,49152
80005148:	e0 81 01 00 	brne	80005348 <phy_payload_rx+0x2d8>
			{
				AMBE_Media = 1;	
8000514c:	fe f9 0d b8 	ld.w	r9,pc[3512]
80005150:	30 18       	mov	r8,1
80005152:	b2 88       	st.b	r9[0x0],r8
											
				Item_ID = payload_rx_channel->byte[5];
80005154:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005158:	11 d8       	ld.ub	r8,r8[0x5]
8000515a:	fe f9 0d ae 	ld.w	r9,pc[3502]
8000515e:	b2 88       	st.b	r9[0x0],r8
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80005160:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005164:	11 c8       	ld.ub	r8,r8[0x4]
80005166:	f3 d8 c0 07 	bfextu	r9,r8,0x0,0x7
8000516a:	fe f8 0d a2 	ld.w	r8,pc[3490]
8000516e:	91 09       	st.w	r8[0x0],r9
								
				switch(Item_ID)
80005170:	fe f8 0d 98 	ld.w	r8,pc[3480]
80005174:	11 88       	ld.ub	r8,r8[0x0]
80005176:	5c 58       	castu.b	r8
80005178:	e0 48 00 7f 	cp.w	r8,127
8000517c:	e0 80 00 8b 	breq	80005292 <phy_payload_rx+0x222>
80005180:	e0 89 00 07 	brgt	8000518e <phy_payload_rx+0x11e>
80005184:	59 28       	cp.w	r8,18
80005186:	c5 00       	breq	80005226 <phy_payload_rx+0x1b6>
80005188:	59 38       	cp.w	r8,19
8000518a:	c7 f0       	breq	80005288 <phy_payload_rx+0x218>
8000518c:	cb 48       	rjmp	800052f4 <phy_payload_rx+0x284>
8000518e:	f0 c8 00 f0 	sub	r8,r8,240
80005192:	58 18       	cp.w	r8,1
80005194:	e0 8b 00 b0 	brhi	800052f4 <phy_payload_rx+0x284>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80005198:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000519c:	11 e8       	ld.ub	r8,r8[0x6]
8000519e:	e2 18 00 f0 	andl	r8,0xf0,COH
800051a2:	59 08       	cp.w	r8,16
800051a4:	c0 61       	brne	800051b0 <phy_payload_rx+0x140>
							{
								m_RxBurstType = VOICEHEADER;
800051a6:	fe f8 0d 4e 	ld.w	r8,pc[3406]
800051aa:	30 19       	mov	r9,1
800051ac:	91 09       	st.w	r8[0x0],r9
800051ae:	c3 b8       	rjmp	80005224 <phy_payload_rx+0x1b4>

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800051b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800051b4:	11 e8       	ld.ub	r8,r8[0x6]
800051b6:	e2 18 00 f0 	andl	r8,0xf0,COH
800051ba:	e0 48 00 20 	cp.w	r8,32
800051be:	c2 f1       	brne	8000521c <phy_payload_rx+0x1ac>
							{
								m_RxBurstType = VOICETERMINATOR;
800051c0:	fe f8 0d 34 	ld.w	r8,pc[3380]
800051c4:	30 a9       	mov	r9,10
800051c6:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//0
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800051c8:	fe f8 0d 48 	ld.w	r8,pc[3400]
800051cc:	70 08       	ld.w	r8,r8[0x0]
800051ce:	5c d8       	com	r8
800051d0:	f0 c9 fe 00 	sub	r9,r8,-512
800051d4:	fe f8 0d 18 	ld.w	r8,pc[3352]
800051d8:	70 0a       	ld.w	r10,r8[0x0]
800051da:	fe f8 0d 36 	ld.w	r8,pc[3382]
800051de:	70 08       	ld.w	r8,r8[0x0]
800051e0:	2f f8       	sub	r8,-1
800051e2:	f4 08 00 08 	add	r8,r10,r8
800051e6:	12 9a       	mov	r10,r9
800051e8:	30 0b       	mov	r11,0
800051ea:	10 9c       	mov	r12,r8
800051ec:	f0 1f 03 4a 	mcall	80005f14 <phy_payload_rx+0xea4>
								
								RxAMBE_IsFillingNext8 = 0;
800051f0:	fe f8 0d 20 	ld.w	r8,pc[3360]
800051f4:	30 09       	mov	r9,0
800051f6:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800051f8:	fe f8 0c f4 	ld.w	r8,pc[3316]
800051fc:	70 08       	ld.w	r8,r8[0x0]
800051fe:	10 9c       	mov	r12,r8
80005200:	f0 1f 03 46 	mcall	80005f18 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005204:	fe f8 0c e0 	ld.w	r8,pc[3296]
80005208:	70 08       	ld.w	r8,r8[0x0]
8000520a:	10 9c       	mov	r12,r8
8000520c:	f0 1f 03 37 	mcall	80005ee8 <phy_payload_rx+0xe78>
80005210:	18 98       	mov	r8,r12
80005212:	10 99       	mov	r9,r8
80005214:	fe f8 0c d8 	ld.w	r8,pc[3288]
80005218:	91 09       	st.w	r8[0x0],r9
8000521a:	c0 58       	rjmp	80005224 <phy_payload_rx+0x1b4>
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000521c:	fe f8 0c d8 	ld.w	r8,pc[3288]
80005220:	30 09       	mov	r9,0
80005222:	91 09       	st.w	r8[0x0],r9
							}
							
						break;//WAITINGABAB.
80005224:	c9 08       	rjmp	80005344 <phy_payload_rx+0x2d4>
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80005226:	fe f8 0c d2 	ld.w	r8,pc[3282]
8000522a:	70 08       	ld.w	r8,r8[0x0]
8000522c:	f0 c9 00 04 	sub	r9,r8,4
80005230:	fe f8 0c c8 	ld.w	r8,pc[3272]
80005234:	91 09       	st.w	r8[0x0],r9
80005236:	fe f8 0c c2 	ld.w	r8,pc[3266]
8000523a:	70 08       	ld.w	r8,r8[0x0]
8000523c:	58 08       	cp.w	r8,0
8000523e:	c0 21       	brne	80005242 <phy_payload_rx+0x1d2>
80005240:	c8 28       	rjmp	80005344 <phy_payload_rx+0x2d4>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80005242:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005246:	11 f8       	ld.ub	r8,r8[0x7]
80005248:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000524c:	fe f9 0c d0 	ld.w	r9,pc[3280]
80005250:	b2 88       	st.b	r9[0x0],r8
							
							VBSP_data[0] = payload_rx_channel->word[2];
80005252:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005256:	90 28       	ld.sh	r8,r8[0x4]
80005258:	fe f9 0c c8 	ld.w	r9,pc[3272]
8000525c:	b2 08       	st.h	r9[0x0],r8
							VBSP_data[1] = payload_rx_channel->word[3];
8000525e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005262:	90 38       	ld.sh	r8,r8[0x6]
80005264:	fe f9 0c bc 	ld.w	r9,pc[3260]
80005268:	b2 18       	st.h	r9[0x2],r8
							
							m_RxBurstType = CalculateBurst(VF_SN);
8000526a:	fe f8 0c b2 	ld.w	r8,pc[3250]
8000526e:	11 88       	ld.ub	r8,r8[0x0]
80005270:	10 9c       	mov	r12,r8
80005272:	f0 1f 03 2d 	mcall	80005f24 <phy_payload_rx+0xeb4>
80005276:	18 99       	mov	r9,r12
80005278:	fe f8 0c 7c 	ld.w	r8,pc[3196]
8000527c:	91 09       	st.w	r8[0x0],r9
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000527e:	fe f8 0c 72 	ld.w	r8,pc[3186]
80005282:	30 49       	mov	r9,4
80005284:	91 09       	st.w	r8[0x0],r9
							
					
						break;//Jump to READING_AMBE_MEDIA
80005286:	c5 f8       	rjmp	80005344 <phy_payload_rx+0x2d4>
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80005288:	fe f8 0c 6c 	ld.w	r8,pc[3180]
8000528c:	30 09       	mov	r9,0
8000528e:	91 09       	st.w	r8[0x0],r9
						
						break;//WAITINGABAB.
80005290:	c5 a8       	rjmp	80005344 <phy_payload_rx+0x2d4>
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80005292:	fe f8 0c 66 	ld.w	r8,pc[3174]
80005296:	70 08       	ld.w	r8,r8[0x0]
80005298:	f0 c9 00 04 	sub	r9,r8,4
8000529c:	fe f8 0c 5c 	ld.w	r8,pc[3164]
800052a0:	91 09       	st.w	r8[0x0],r9
800052a2:	fe f8 0c 56 	ld.w	r8,pc[3158]
800052a6:	70 08       	ld.w	r8,r8[0x0]
800052a8:	58 08       	cp.w	r8,0
800052aa:	c0 21       	brne	800052ae <phy_payload_rx+0x23e>
800052ac:	c4 c8       	rjmp	80005344 <phy_payload_rx+0x2d4>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800052ae:	fe f8 0c 7a 	ld.w	r8,pc[3194]
800052b2:	70 0a       	ld.w	r10,r8[0x0]
800052b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800052b8:	90 38       	ld.sh	r8,r8[0x6]
800052ba:	fe f9 0c 72 	ld.w	r9,pc[3186]
800052be:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							RxData_IsFillingNext16 += 1; 
800052c2:	fe f8 0c 66 	ld.w	r8,pc[3174]
800052c6:	70 08       	ld.w	r8,r8[0x0]
800052c8:	f0 c9 ff ff 	sub	r9,r8,-1
800052cc:	fe f8 0c 5c 	ld.w	r8,pc[3164]
800052d0:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
800052d2:	fe f8 0c 3a 	ld.w	r8,pc[3130]
800052d6:	70 08       	ld.w	r8,r8[0x0]
800052d8:	f0 c9 00 02 	sub	r9,r8,2
800052dc:	fe f8 0c 30 	ld.w	r8,pc[3120]
800052e0:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
800052e2:	fe f8 0c 12 	ld.w	r8,pc[3090]
800052e6:	30 29       	mov	r9,2
800052e8:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
800052ea:	fe f8 0c 06 	ld.w	r8,pc[3078]
800052ee:	30 39       	mov	r9,3
800052f0:	91 09       	st.w	r8[0x0],r9
							
					
						break;//Jump to READING_AMBE_AUX
800052f2:	c2 98       	rjmp	80005344 <phy_payload_rx+0x2d4>
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
800052f4:	fe f8 0c 00 	ld.w	r8,pc[3072]
800052f8:	30 39       	mov	r9,3
800052fa:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
800052fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005300:	70 09       	ld.w	r9,r8[0x0]
80005302:	fe f8 0c 2e 	ld.w	r8,pc[3118]
80005306:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80005308:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000530c:	70 19       	ld.w	r9,r8[0x4]
8000530e:	fe f8 0c 22 	ld.w	r8,pc[3106]
80005312:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80005314:	fe f8 0b e4 	ld.w	r8,pc[3044]
80005318:	70 08       	ld.w	r8,r8[0x0]
8000531a:	59 48       	cp.w	r8,20
8000531c:	c0 51       	brne	80005326 <phy_payload_rx+0x2b6>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000531e:	fe f8 0b da 	ld.w	r8,pc[3034]
80005322:	31 89       	mov	r9,24
80005324:	91 09       	st.w	r8[0x0],r9
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80005326:	fe f8 0b d2 	ld.w	r8,pc[3026]
8000532a:	70 08       	ld.w	r8,r8[0x0]
8000532c:	59 08       	cp.w	r8,16
8000532e:	c0 51       	brne	80005338 <phy_payload_rx+0x2c8>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80005330:	fe f8 0b c8 	ld.w	r8,pc[3016]
80005334:	31 09       	mov	r9,16
80005336:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80005338:	fe f8 0b b8 	ld.w	r8,pc[3000]
8000533c:	30 49       	mov	r9,4
8000533e:	91 09       	st.w	r8[0x0],r9
					
						break;//Jump to READING_AMBE_MEDIA
									
			
				}
				break;
80005340:	e0 8f 05 cd 	bral	80005eda <phy_payload_rx+0xe6a>
80005344:	e0 8f 05 cb 	bral	80005eda <phy_payload_rx+0xe6a>
			}
			
			else
			{
				AMBE_Media = 0;	
80005348:	fe f9 0b bc 	ld.w	r9,pc[3004]
8000534c:	30 08       	mov	r8,0
8000534e:	b2 88       	st.b	r9[0x0],r8
				break;
80005350:	e0 8f 05 c5 	bral	80005eda <phy_payload_rx+0xe6a>

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80005354:	fe f8 0b b4 	ld.w	r8,pc[2996]
80005358:	11 88       	ld.ub	r8,r8[0x0]
8000535a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000535e:	31 28       	mov	r8,18
80005360:	f0 09 18 00 	cp.b	r9,r8
80005364:	e0 81 02 07 	brne	80005772 <phy_payload_rx+0x702>
					{
						Item_ID = payload_rx_channel->byte[1];
80005368:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000536c:	11 98       	ld.ub	r8,r8[0x1]
8000536e:	fe f9 0b 9a 	ld.w	r9,pc[2970]
80005372:	b2 88       	st.b	r9[0x0],r8
						if (Item_ID == Post_Voice_Encoder_Data)//
80005374:	fe f8 0b 94 	ld.w	r8,pc[2964]
80005378:	11 88       	ld.ub	r8,r8[0x0]
8000537a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000537e:	3f 28       	mov	r8,-14
80005380:	f0 09 18 00 	cp.b	r9,r8
80005384:	e0 81 01 f1 	brne	80005766 <phy_payload_rx+0x6f6>
						{
							AMBE_tx_flag = 1;
80005388:	fe f9 0b ac 	ld.w	r9,pc[2988]
8000538c:	30 18       	mov	r8,1
8000538e:	b2 88       	st.b	r9[0x0],r8
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80005390:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005394:	70 08       	ld.w	r8,r8[0x0]
80005396:	e6 18 7f 00 	andh	r8,0x7f00,COH
8000539a:	f0 09 16 18 	lsr	r9,r8,0x18
8000539e:	fe f8 0b 5a 	ld.w	r8,pc[2906]
800053a2:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800053a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053a8:	90 18       	ld.sh	r8,r8[0x2]
800053aa:	fe f9 0b 8e 	ld.w	r9,pc[2958]
800053ae:	b2 08       	st.h	r9[0x0],r8
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800053b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053b4:	90 28       	ld.sh	r8,r8[0x4]
800053b6:	fe f9 0b 82 	ld.w	r9,pc[2946]
800053ba:	b2 18       	st.h	r9[0x2],r8
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800053bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053c0:	90 38       	ld.sh	r8,r8[0x6]
800053c2:	fe f9 0b 76 	ld.w	r9,pc[2934]
800053c6:	b2 28       	st.h	r9[0x4],r8
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800053c8:	fe f8 0b 24 	ld.w	r8,pc[2852]
800053cc:	70 09       	ld.w	r9,r8[0x0]
800053ce:	fe f8 0b 42 	ld.w	r8,pc[2882]
800053d2:	70 08       	ld.w	r8,r8[0x0]
800053d4:	10 09       	add	r9,r8
800053d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800053da:	11 a8       	ld.ub	r8,r8[0x2]
800053dc:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
800053de:	fe f8 0b 32 	ld.w	r8,pc[2866]
800053e2:	70 08       	ld.w	r8,r8[0x0]
800053e4:	f0 c9 ff ff 	sub	r9,r8,-1
800053e8:	fe f8 0b 28 	ld.w	r8,pc[2856]
800053ec:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800053ee:	fe f8 0b 22 	ld.w	r8,pc[2850]
800053f2:	70 08       	ld.w	r8,r8[0x0]
800053f4:	e0 48 01 ff 	cp.w	r8,511
800053f8:	e0 88 00 22 	brls	8000543c <phy_payload_rx+0x3cc>
							{
								RxAMBE_IsFillingNext8 = 0;
800053fc:	fe f8 0b 14 	ld.w	r8,pc[2836]
80005400:	30 09       	mov	r9,0
80005402:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80005404:	fe f8 0a e8 	ld.w	r8,pc[2792]
80005408:	70 08       	ld.w	r8,r8[0x0]
8000540a:	10 9c       	mov	r12,r8
8000540c:	f0 1f 02 c3 	mcall	80005f18 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005410:	fe f8 0a d4 	ld.w	r8,pc[2772]
80005414:	70 08       	ld.w	r8,r8[0x0]
80005416:	10 9c       	mov	r12,r8
80005418:	f0 1f 02 b4 	mcall	80005ee8 <phy_payload_rx+0xe78>
8000541c:	18 98       	mov	r8,r12
8000541e:	10 99       	mov	r9,r8
80005420:	fe f8 0a cc 	ld.w	r8,pc[2764]
80005424:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80005426:	fe f8 0a c6 	ld.w	r8,pc[2758]
8000542a:	70 08       	ld.w	r8,r8[0x0]
8000542c:	58 08       	cp.w	r8,0
8000542e:	c0 71       	brne	8000543c <phy_payload_rx+0x3cc>
								{
									RxMediaState = WAITINGABAB;
80005430:	fe f8 0a c0 	ld.w	r8,pc[2752]
80005434:	30 09       	mov	r9,0
80005436:	91 09       	st.w	r8[0x0],r9
									break;
80005438:	e0 8f 05 51 	bral	80005eda <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000543c:	fe f8 0a bc 	ld.w	r8,pc[2748]
80005440:	70 08       	ld.w	r8,r8[0x0]
80005442:	f0 c9 00 01 	sub	r9,r8,1
80005446:	fe f8 0a b2 	ld.w	r8,pc[2738]
8000544a:	91 09       	st.w	r8[0x0],r9
8000544c:	fe f8 0a ac 	ld.w	r8,pc[2732]
80005450:	70 08       	ld.w	r8,r8[0x0]
80005452:	58 08       	cp.w	r8,0
80005454:	c0 71       	brne	80005462 <phy_payload_rx+0x3f2>
								RxMediaState = WAITINGABAB;
80005456:	fe f8 0a 9a 	ld.w	r8,pc[2714]
8000545a:	30 09       	mov	r9,0
8000545c:	91 09       	st.w	r8[0x0],r9
								break;
8000545e:	e0 8f 05 3e 	bral	80005eda <phy_payload_rx+0xe6a>
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80005462:	fe f8 0a 8a 	ld.w	r8,pc[2698]
80005466:	70 09       	ld.w	r9,r8[0x0]
80005468:	fe f8 0a a8 	ld.w	r8,pc[2728]
8000546c:	70 08       	ld.w	r8,r8[0x0]
8000546e:	10 09       	add	r9,r8
80005470:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005474:	11 b8       	ld.ub	r8,r8[0x3]
80005476:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80005478:	fe f8 0a 98 	ld.w	r8,pc[2712]
8000547c:	70 08       	ld.w	r8,r8[0x0]
8000547e:	f0 c9 ff ff 	sub	r9,r8,-1
80005482:	fe f8 0a 8e 	ld.w	r8,pc[2702]
80005486:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005488:	fe f8 0a 88 	ld.w	r8,pc[2696]
8000548c:	70 08       	ld.w	r8,r8[0x0]
8000548e:	e0 48 01 ff 	cp.w	r8,511
80005492:	e0 88 00 22 	brls	800054d6 <phy_payload_rx+0x466>
							{
								RxAMBE_IsFillingNext8 = 0;
80005496:	fe f8 0a 7a 	ld.w	r8,pc[2682]
8000549a:	30 09       	mov	r9,0
8000549c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000549e:	fe f8 0a 4e 	ld.w	r8,pc[2638]
800054a2:	70 08       	ld.w	r8,r8[0x0]
800054a4:	10 9c       	mov	r12,r8
800054a6:	f0 1f 02 9d 	mcall	80005f18 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
800054aa:	fe f8 0a 3a 	ld.w	r8,pc[2618]
800054ae:	70 08       	ld.w	r8,r8[0x0]
800054b0:	10 9c       	mov	r12,r8
800054b2:	f0 1f 02 8e 	mcall	80005ee8 <phy_payload_rx+0xe78>
800054b6:	18 98       	mov	r8,r12
800054b8:	10 99       	mov	r9,r8
800054ba:	fe f8 0a 32 	ld.w	r8,pc[2610]
800054be:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
800054c0:	fe f8 0a 2c 	ld.w	r8,pc[2604]
800054c4:	70 08       	ld.w	r8,r8[0x0]
800054c6:	58 08       	cp.w	r8,0
800054c8:	c0 71       	brne	800054d6 <phy_payload_rx+0x466>
								{
									RxMediaState = WAITINGABAB;
800054ca:	fe f8 0a 26 	ld.w	r8,pc[2598]
800054ce:	30 09       	mov	r9,0
800054d0:	91 09       	st.w	r8[0x0],r9
									break;
800054d2:	e0 8f 05 04 	bral	80005eda <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800054d6:	fe f8 0a 22 	ld.w	r8,pc[2594]
800054da:	70 08       	ld.w	r8,r8[0x0]
800054dc:	f0 c9 00 01 	sub	r9,r8,1
800054e0:	fe f8 0a 18 	ld.w	r8,pc[2584]
800054e4:	91 09       	st.w	r8[0x0],r9
800054e6:	fe f8 0a 12 	ld.w	r8,pc[2578]
800054ea:	70 08       	ld.w	r8,r8[0x0]
800054ec:	58 08       	cp.w	r8,0
800054ee:	c0 71       	brne	800054fc <phy_payload_rx+0x48c>
								RxMediaState = WAITINGABAB;
800054f0:	fe f8 0a 00 	ld.w	r8,pc[2560]
800054f4:	30 09       	mov	r9,0
800054f6:	91 09       	st.w	r8[0x0],r9
								break;
800054f8:	e0 8f 04 f1 	bral	80005eda <phy_payload_rx+0xe6a>
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800054fc:	fe f8 09 f0 	ld.w	r8,pc[2544]
80005500:	70 09       	ld.w	r9,r8[0x0]
80005502:	fe f8 0a 0e 	ld.w	r8,pc[2574]
80005506:	70 08       	ld.w	r8,r8[0x0]
80005508:	10 09       	add	r9,r8
8000550a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000550e:	11 c8       	ld.ub	r8,r8[0x4]
80005510:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80005512:	fe f8 09 fe 	ld.w	r8,pc[2558]
80005516:	70 08       	ld.w	r8,r8[0x0]
80005518:	f0 c9 ff ff 	sub	r9,r8,-1
8000551c:	fe f8 09 f4 	ld.w	r8,pc[2548]
80005520:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005522:	fe f8 09 ee 	ld.w	r8,pc[2542]
80005526:	70 08       	ld.w	r8,r8[0x0]
80005528:	e0 48 01 ff 	cp.w	r8,511
8000552c:	e0 88 00 22 	brls	80005570 <phy_payload_rx+0x500>
							{
								RxAMBE_IsFillingNext8 = 0;
80005530:	fe f8 09 e0 	ld.w	r8,pc[2528]
80005534:	30 09       	mov	r9,0
80005536:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80005538:	fe f8 09 b4 	ld.w	r8,pc[2484]
8000553c:	70 08       	ld.w	r8,r8[0x0]
8000553e:	10 9c       	mov	r12,r8
80005540:	f0 1f 02 76 	mcall	80005f18 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005544:	fe f8 09 a0 	ld.w	r8,pc[2464]
80005548:	70 08       	ld.w	r8,r8[0x0]
8000554a:	10 9c       	mov	r12,r8
8000554c:	f0 1f 02 67 	mcall	80005ee8 <phy_payload_rx+0xe78>
80005550:	18 98       	mov	r8,r12
80005552:	10 99       	mov	r9,r8
80005554:	fe f8 09 98 	ld.w	r8,pc[2456]
80005558:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
8000555a:	fe f8 09 92 	ld.w	r8,pc[2450]
8000555e:	70 08       	ld.w	r8,r8[0x0]
80005560:	58 08       	cp.w	r8,0
80005562:	c0 71       	brne	80005570 <phy_payload_rx+0x500>
								{
									RxMediaState = WAITINGABAB;
80005564:	fe f8 09 8c 	ld.w	r8,pc[2444]
80005568:	30 09       	mov	r9,0
8000556a:	91 09       	st.w	r8[0x0],r9
									break;
8000556c:	e0 8f 04 b7 	bral	80005eda <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80005570:	fe f8 09 88 	ld.w	r8,pc[2440]
80005574:	70 08       	ld.w	r8,r8[0x0]
80005576:	f0 c9 00 01 	sub	r9,r8,1
8000557a:	fe f8 09 7e 	ld.w	r8,pc[2430]
8000557e:	91 09       	st.w	r8[0x0],r9
80005580:	fe f8 09 78 	ld.w	r8,pc[2424]
80005584:	70 08       	ld.w	r8,r8[0x0]
80005586:	58 08       	cp.w	r8,0
80005588:	c0 71       	brne	80005596 <phy_payload_rx+0x526>
								RxMediaState = WAITINGABAB;
8000558a:	fe f8 09 66 	ld.w	r8,pc[2406]
8000558e:	30 09       	mov	r9,0
80005590:	91 09       	st.w	r8[0x0],r9
								break;
80005592:	e0 8f 04 a4 	bral	80005eda <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80005596:	fe f8 09 56 	ld.w	r8,pc[2390]
8000559a:	70 09       	ld.w	r9,r8[0x0]
8000559c:	fe f8 09 74 	ld.w	r8,pc[2420]
800055a0:	70 08       	ld.w	r8,r8[0x0]
800055a2:	10 09       	add	r9,r8
800055a4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800055a8:	11 d8       	ld.ub	r8,r8[0x5]
800055aa:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
800055ac:	fe f8 09 64 	ld.w	r8,pc[2404]
800055b0:	70 08       	ld.w	r8,r8[0x0]
800055b2:	f0 c9 ff ff 	sub	r9,r8,-1
800055b6:	fe f8 09 5a 	ld.w	r8,pc[2394]
800055ba:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800055bc:	fe f8 09 54 	ld.w	r8,pc[2388]
800055c0:	70 08       	ld.w	r8,r8[0x0]
800055c2:	e0 48 01 ff 	cp.w	r8,511
800055c6:	e0 88 00 22 	brls	8000560a <phy_payload_rx+0x59a>
							{
								RxAMBE_IsFillingNext8 = 0;
800055ca:	fe f8 09 46 	ld.w	r8,pc[2374]
800055ce:	30 09       	mov	r9,0
800055d0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800055d2:	fe f8 09 1a 	ld.w	r8,pc[2330]
800055d6:	70 08       	ld.w	r8,r8[0x0]
800055d8:	10 9c       	mov	r12,r8
800055da:	f0 1f 02 50 	mcall	80005f18 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
800055de:	fe f8 09 06 	ld.w	r8,pc[2310]
800055e2:	70 08       	ld.w	r8,r8[0x0]
800055e4:	10 9c       	mov	r12,r8
800055e6:	f0 1f 02 41 	mcall	80005ee8 <phy_payload_rx+0xe78>
800055ea:	18 98       	mov	r8,r12
800055ec:	10 99       	mov	r9,r8
800055ee:	fe f8 08 fe 	ld.w	r8,pc[2302]
800055f2:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
800055f4:	fe f8 08 f8 	ld.w	r8,pc[2296]
800055f8:	70 08       	ld.w	r8,r8[0x0]
800055fa:	58 08       	cp.w	r8,0
800055fc:	c0 71       	brne	8000560a <phy_payload_rx+0x59a>
								{
									RxMediaState = WAITINGABAB;
800055fe:	fe f8 08 f2 	ld.w	r8,pc[2290]
80005602:	30 09       	mov	r9,0
80005604:	91 09       	st.w	r8[0x0],r9
									break;
80005606:	e0 8f 04 6a 	bral	80005eda <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000560a:	fe f8 08 ee 	ld.w	r8,pc[2286]
8000560e:	70 08       	ld.w	r8,r8[0x0]
80005610:	f0 c9 00 01 	sub	r9,r8,1
80005614:	fe f8 08 e4 	ld.w	r8,pc[2276]
80005618:	91 09       	st.w	r8[0x0],r9
8000561a:	fe f8 08 de 	ld.w	r8,pc[2270]
8000561e:	70 08       	ld.w	r8,r8[0x0]
80005620:	58 08       	cp.w	r8,0
80005622:	c0 71       	brne	80005630 <phy_payload_rx+0x5c0>
								RxMediaState = WAITINGABAB;
80005624:	fe f8 08 cc 	ld.w	r8,pc[2252]
80005628:	30 09       	mov	r9,0
8000562a:	91 09       	st.w	r8[0x0],r9
								break;
8000562c:	e0 8f 04 57 	bral	80005eda <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
80005630:	fe f8 08 bc 	ld.w	r8,pc[2236]
80005634:	70 09       	ld.w	r9,r8[0x0]
80005636:	fe f8 08 da 	ld.w	r8,pc[2266]
8000563a:	70 08       	ld.w	r8,r8[0x0]
8000563c:	10 09       	add	r9,r8
8000563e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005642:	11 e8       	ld.ub	r8,r8[0x6]
80005644:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
80005646:	fe f8 08 ca 	ld.w	r8,pc[2250]
8000564a:	70 08       	ld.w	r8,r8[0x0]
8000564c:	f0 c9 ff ff 	sub	r9,r8,-1
80005650:	fe f8 08 c0 	ld.w	r8,pc[2240]
80005654:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005656:	fe f8 08 ba 	ld.w	r8,pc[2234]
8000565a:	70 08       	ld.w	r8,r8[0x0]
8000565c:	e0 48 01 ff 	cp.w	r8,511
80005660:	e0 88 00 22 	brls	800056a4 <phy_payload_rx+0x634>
							{
								RxAMBE_IsFillingNext8 = 0;
80005664:	fe f8 08 ac 	ld.w	r8,pc[2220]
80005668:	30 09       	mov	r9,0
8000566a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000566c:	fe f8 08 80 	ld.w	r8,pc[2176]
80005670:	70 08       	ld.w	r8,r8[0x0]
80005672:	10 9c       	mov	r12,r8
80005674:	f0 1f 02 29 	mcall	80005f18 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005678:	fe f8 08 6c 	ld.w	r8,pc[2156]
8000567c:	70 08       	ld.w	r8,r8[0x0]
8000567e:	10 9c       	mov	r12,r8
80005680:	f0 1f 02 1a 	mcall	80005ee8 <phy_payload_rx+0xe78>
80005684:	18 98       	mov	r8,r12
80005686:	10 99       	mov	r9,r8
80005688:	fe f8 08 64 	ld.w	r8,pc[2148]
8000568c:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
8000568e:	fe f8 08 5e 	ld.w	r8,pc[2142]
80005692:	70 08       	ld.w	r8,r8[0x0]
80005694:	58 08       	cp.w	r8,0
80005696:	c0 71       	brne	800056a4 <phy_payload_rx+0x634>
								{
									RxMediaState = WAITINGABAB;
80005698:	fe f8 08 58 	ld.w	r8,pc[2136]
8000569c:	30 09       	mov	r9,0
8000569e:	91 09       	st.w	r8[0x0],r9
									break;
800056a0:	e0 8f 04 1d 	bral	80005eda <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800056a4:	fe f8 08 54 	ld.w	r8,pc[2132]
800056a8:	70 08       	ld.w	r8,r8[0x0]
800056aa:	f0 c9 00 01 	sub	r9,r8,1
800056ae:	fe f8 08 4a 	ld.w	r8,pc[2122]
800056b2:	91 09       	st.w	r8[0x0],r9
800056b4:	fe f8 08 44 	ld.w	r8,pc[2116]
800056b8:	70 08       	ld.w	r8,r8[0x0]
800056ba:	58 08       	cp.w	r8,0
800056bc:	c0 71       	brne	800056ca <phy_payload_rx+0x65a>
								RxMediaState = WAITINGABAB;
800056be:	fe f8 08 32 	ld.w	r8,pc[2098]
800056c2:	30 09       	mov	r9,0
800056c4:	91 09       	st.w	r8[0x0],r9
								break;
800056c6:	e0 8f 04 0a 	bral	80005eda <phy_payload_rx+0xe6a>
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800056ca:	fe f8 08 22 	ld.w	r8,pc[2082]
800056ce:	70 09       	ld.w	r9,r8[0x0]
800056d0:	fe f8 08 40 	ld.w	r8,pc[2112]
800056d4:	70 08       	ld.w	r8,r8[0x0]
800056d6:	10 09       	add	r9,r8
800056d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800056dc:	11 f8       	ld.ub	r8,r8[0x7]
800056de:	b2 88       	st.b	r9[0x0],r8
							RxAMBE_IsFillingNext8 += 1;
800056e0:	fe f8 08 30 	ld.w	r8,pc[2096]
800056e4:	70 08       	ld.w	r8,r8[0x0]
800056e6:	f0 c9 ff ff 	sub	r9,r8,-1
800056ea:	fe f8 08 26 	ld.w	r8,pc[2086]
800056ee:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800056f0:	fe f8 08 20 	ld.w	r8,pc[2080]
800056f4:	70 08       	ld.w	r8,r8[0x0]
800056f6:	e0 48 01 ff 	cp.w	r8,511
800056fa:	e0 88 00 22 	brls	8000573e <phy_payload_rx+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
800056fe:	fe f8 08 12 	ld.w	r8,pc[2066]
80005702:	30 09       	mov	r9,0
80005704:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80005706:	fe f8 07 e6 	ld.w	r8,pc[2022]
8000570a:	70 08       	ld.w	r8,r8[0x0]
8000570c:	10 9c       	mov	r12,r8
8000570e:	f0 1f 02 03 	mcall	80005f18 <phy_payload_rx+0xea8>
								AMBE_payload_ptr = get_payload_idle_isr();
80005712:	fe f8 07 d2 	ld.w	r8,pc[2002]
80005716:	70 08       	ld.w	r8,r8[0x0]
80005718:	10 9c       	mov	r12,r8
8000571a:	f0 1f 01 f4 	mcall	80005ee8 <phy_payload_rx+0xe78>
8000571e:	18 98       	mov	r8,r12
80005720:	10 99       	mov	r9,r8
80005722:	fe f8 07 ca 	ld.w	r8,pc[1994]
80005726:	91 09       	st.w	r8[0x0],r9
								if(NULL == AMBE_payload_ptr)
80005728:	fe f8 07 c4 	ld.w	r8,pc[1988]
8000572c:	70 08       	ld.w	r8,r8[0x0]
8000572e:	58 08       	cp.w	r8,0
80005730:	c0 71       	brne	8000573e <phy_payload_rx+0x6ce>
								{
									RxMediaState = WAITINGABAB;
80005732:	fe f8 07 be 	ld.w	r8,pc[1982]
80005736:	30 09       	mov	r9,0
80005738:	91 09       	st.w	r8[0x0],r9
									break;
8000573a:	e0 8f 03 d0 	bral	80005eda <phy_payload_rx+0xe6a>
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000573e:	fe f8 07 ba 	ld.w	r8,pc[1978]
80005742:	70 08       	ld.w	r8,r8[0x0]
80005744:	f0 c9 00 01 	sub	r9,r8,1
80005748:	fe f8 07 b0 	ld.w	r8,pc[1968]
8000574c:	91 09       	st.w	r8[0x0],r9
8000574e:	fe f8 07 aa 	ld.w	r8,pc[1962]
80005752:	70 08       	ld.w	r8,r8[0x0]
80005754:	58 08       	cp.w	r8,0
80005756:	e0 81 03 b9 	brne	80005ec8 <phy_payload_rx+0xe58>
								RxMediaState = WAITINGABAB;
8000575a:	fe f8 07 96 	ld.w	r8,pc[1942]
8000575e:	30 09       	mov	r9,0
80005760:	91 09       	st.w	r8[0x0],r9
								break;
80005762:	e0 8f 03 bc 	bral	80005eda <phy_payload_rx+0xe6a>
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80005766:	fe f8 07 8a 	ld.w	r8,pc[1930]
8000576a:	30 09       	mov	r9,0
8000576c:	91 09       	st.w	r8[0x0],r9
							break;
8000576e:	e0 8f 03 b6 	bral	80005eda <phy_payload_rx+0xe6a>
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80005772:	fe f8 07 96 	ld.w	r8,pc[1942]
80005776:	11 88       	ld.ub	r8,r8[0x0]
80005778:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000577c:	3f 28       	mov	r8,-14
8000577e:	f0 09 18 00 	cp.b	r9,r8
80005782:	c6 81       	brne	80005852 <phy_payload_rx+0x7e2>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80005784:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005788:	90 08       	ld.sh	r8,r8[0x0]
8000578a:	fe f9 07 ae 	ld.w	r9,pc[1966]
8000578e:	b2 38       	st.h	r9[0x6],r8
						//AMBE_Per_Burst_Flag = 1;
						
						//MOTO.bitpad-bits
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80005790:	fe f8 07 5c 	ld.w	r8,pc[1884]
80005794:	70 09       	ld.w	r9,r8[0x0]
80005796:	fe f8 07 7a 	ld.w	r8,pc[1914]
8000579a:	70 08       	ld.w	r8,r8[0x0]
8000579c:	10 09       	add	r9,r8
8000579e:	ee f8 ff f8 	ld.w	r8,r7[-8]
800057a2:	11 88       	ld.ub	r8,r8[0x0]
800057a4:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
800057a6:	fe f8 07 6a 	ld.w	r8,pc[1898]
800057aa:	70 08       	ld.w	r8,r8[0x0]
800057ac:	f0 c9 ff ff 	sub	r9,r8,-1
800057b0:	fe f8 07 60 	ld.w	r8,pc[1888]
800057b4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800057b6:	fe f8 07 5a 	ld.w	r8,pc[1882]
800057ba:	70 08       	ld.w	r8,r8[0x0]
800057bc:	e0 48 01 ff 	cp.w	r8,511
800057c0:	e0 88 00 22 	brls	80005804 <phy_payload_rx+0x794>
						{
							RxAMBE_IsFillingNext8 = 0;
800057c4:	fe f8 07 4c 	ld.w	r8,pc[1868]
800057c8:	30 09       	mov	r9,0
800057ca:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800057cc:	fe f8 07 20 	ld.w	r8,pc[1824]
800057d0:	70 08       	ld.w	r8,r8[0x0]
800057d2:	10 9c       	mov	r12,r8
800057d4:	f0 1f 01 d1 	mcall	80005f18 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
800057d8:	fe f8 07 0c 	ld.w	r8,pc[1804]
800057dc:	70 08       	ld.w	r8,r8[0x0]
800057de:	10 9c       	mov	r12,r8
800057e0:	f0 1f 01 c2 	mcall	80005ee8 <phy_payload_rx+0xe78>
800057e4:	18 98       	mov	r8,r12
800057e6:	10 99       	mov	r9,r8
800057e8:	fe f8 07 04 	ld.w	r8,pc[1796]
800057ec:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
800057ee:	fe f8 06 fe 	ld.w	r8,pc[1790]
800057f2:	70 08       	ld.w	r8,r8[0x0]
800057f4:	58 08       	cp.w	r8,0
800057f6:	c0 71       	brne	80005804 <phy_payload_rx+0x794>
							{
								RxMediaState = WAITINGABAB;
800057f8:	fe f8 06 f8 	ld.w	r8,pc[1784]
800057fc:	30 09       	mov	r9,0
800057fe:	91 09       	st.w	r8[0x0],r9
								break;
80005800:	e0 8f 03 6d 	bral	80005eda <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005804:	fe f8 06 f4 	ld.w	r8,pc[1780]
80005808:	70 08       	ld.w	r8,r8[0x0]
8000580a:	f0 c9 00 01 	sub	r9,r8,1
8000580e:	fe f8 06 ea 	ld.w	r8,pc[1770]
80005812:	91 09       	st.w	r8[0x0],r9
80005814:	fe f8 06 e4 	ld.w	r8,pc[1764]
80005818:	70 08       	ld.w	r8,r8[0x0]
8000581a:	58 08       	cp.w	r8,0
8000581c:	c0 71       	brne	8000582a <phy_payload_rx+0x7ba>
							RxMediaState = WAITINGABAB;
8000581e:	fe f8 06 d2 	ld.w	r8,pc[1746]
80005822:	30 09       	mov	r9,0
80005824:	91 09       	st.w	r8[0x0],r9
							break;
80005826:	e0 8f 03 5a 	bral	80005eda <phy_payload_rx+0xe6a>
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//AMBE Vocoder Bits Stream(bit59~63),
8000582a:	fe f8 06 ce 	ld.w	r8,pc[1742]
8000582e:	70 08       	ld.w	r8,r8[0x0]
80005830:	f0 c9 00 01 	sub	r9,r8,1
80005834:	fe f8 06 c4 	ld.w	r8,pc[1732]
80005838:	91 09       	st.w	r8[0x0],r9
8000583a:	fe f8 06 be 	ld.w	r8,pc[1726]
8000583e:	70 08       	ld.w	r8,r8[0x0]
80005840:	58 08       	cp.w	r8,0
80005842:	e0 81 03 45 	brne	80005ecc <phy_payload_rx+0xe5c>
							RxMediaState = WAITINGABAB;
80005846:	fe f8 06 aa 	ld.w	r8,pc[1706]
8000584a:	30 09       	mov	r9,0
8000584c:	91 09       	st.w	r8[0x0],r9
							break;
8000584e:	e0 8f 03 46 	bral	80005eda <phy_payload_rx+0xe6a>
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80005852:	fe f8 06 b6 	ld.w	r8,pc[1718]
80005856:	11 88       	ld.ub	r8,r8[0x0]
80005858:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000585c:	3f 38       	mov	r8,-13
8000585e:	f0 09 18 00 	cp.b	r9,r8
80005862:	e0 81 01 a9 	brne	80005bb4 <phy_payload_rx+0xb44>
					{
						//
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80005866:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000586a:	90 08       	ld.sh	r8,r8[0x0]
8000586c:	fe f9 06 cc 	ld.w	r9,pc[1740]
80005870:	b2 18       	st.h	r9[0x2],r8
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80005872:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005876:	90 18       	ld.sh	r8,r8[0x2]
80005878:	fe f9 06 c0 	ld.w	r9,pc[1728]
8000587c:	b2 28       	st.h	r9[0x4],r8
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000587e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005882:	90 28       	ld.sh	r8,r8[0x4]
80005884:	fe f9 06 b4 	ld.w	r9,pc[1716]
80005888:	b2 38       	st.h	r9[0x6],r8
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
8000588a:	fe f8 06 62 	ld.w	r8,pc[1634]
8000588e:	70 09       	ld.w	r9,r8[0x0]
80005890:	fe f8 06 80 	ld.w	r8,pc[1664]
80005894:	70 08       	ld.w	r8,r8[0x0]
80005896:	10 09       	add	r9,r8
80005898:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000589c:	11 88       	ld.ub	r8,r8[0x0]
8000589e:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
800058a0:	fe f8 06 70 	ld.w	r8,pc[1648]
800058a4:	70 08       	ld.w	r8,r8[0x0]
800058a6:	f0 c9 ff ff 	sub	r9,r8,-1
800058aa:	fe f8 06 66 	ld.w	r8,pc[1638]
800058ae:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800058b0:	fe f8 06 60 	ld.w	r8,pc[1632]
800058b4:	70 08       	ld.w	r8,r8[0x0]
800058b6:	e0 48 01 ff 	cp.w	r8,511
800058ba:	e0 88 00 22 	brls	800058fe <phy_payload_rx+0x88e>
						{
							RxAMBE_IsFillingNext8 = 0;
800058be:	fe f8 06 52 	ld.w	r8,pc[1618]
800058c2:	30 09       	mov	r9,0
800058c4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800058c6:	fe f8 06 26 	ld.w	r8,pc[1574]
800058ca:	70 08       	ld.w	r8,r8[0x0]
800058cc:	10 9c       	mov	r12,r8
800058ce:	f0 1f 01 93 	mcall	80005f18 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
800058d2:	fe f8 06 12 	ld.w	r8,pc[1554]
800058d6:	70 08       	ld.w	r8,r8[0x0]
800058d8:	10 9c       	mov	r12,r8
800058da:	f0 1f 01 84 	mcall	80005ee8 <phy_payload_rx+0xe78>
800058de:	18 98       	mov	r8,r12
800058e0:	10 99       	mov	r9,r8
800058e2:	fe f8 06 0a 	ld.w	r8,pc[1546]
800058e6:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
800058e8:	fe f8 06 04 	ld.w	r8,pc[1540]
800058ec:	70 08       	ld.w	r8,r8[0x0]
800058ee:	58 08       	cp.w	r8,0
800058f0:	c0 71       	brne	800058fe <phy_payload_rx+0x88e>
							{
								RxMediaState = WAITINGABAB;
800058f2:	fe f8 05 fe 	ld.w	r8,pc[1534]
800058f6:	30 09       	mov	r9,0
800058f8:	91 09       	st.w	r8[0x0],r9
								break;
800058fa:	e0 8f 02 f0 	bral	80005eda <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800058fe:	fe f8 05 fa 	ld.w	r8,pc[1530]
80005902:	70 08       	ld.w	r8,r8[0x0]
80005904:	f0 c9 00 01 	sub	r9,r8,1
80005908:	fe f8 05 f0 	ld.w	r8,pc[1520]
8000590c:	91 09       	st.w	r8[0x0],r9
8000590e:	fe f8 05 ea 	ld.w	r8,pc[1514]
80005912:	70 08       	ld.w	r8,r8[0x0]
80005914:	58 08       	cp.w	r8,0
80005916:	c0 71       	brne	80005924 <phy_payload_rx+0x8b4>
							RxMediaState = WAITINGABAB;
80005918:	fe f8 05 d8 	ld.w	r8,pc[1496]
8000591c:	30 09       	mov	r9,0
8000591e:	91 09       	st.w	r8[0x0],r9
							break;
80005920:	e0 8f 02 dd 	bral	80005eda <phy_payload_rx+0xe6a>
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80005924:	fe f8 05 c8 	ld.w	r8,pc[1480]
80005928:	70 09       	ld.w	r9,r8[0x0]
8000592a:	fe f8 05 e6 	ld.w	r8,pc[1510]
8000592e:	70 08       	ld.w	r8,r8[0x0]
80005930:	10 09       	add	r9,r8
80005932:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005936:	11 98       	ld.ub	r8,r8[0x1]
80005938:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
8000593a:	fe f8 05 d6 	ld.w	r8,pc[1494]
8000593e:	70 08       	ld.w	r8,r8[0x0]
80005940:	f0 c9 ff ff 	sub	r9,r8,-1
80005944:	fe f8 05 cc 	ld.w	r8,pc[1484]
80005948:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000594a:	fe f8 05 c6 	ld.w	r8,pc[1478]
8000594e:	70 08       	ld.w	r8,r8[0x0]
80005950:	e0 48 01 ff 	cp.w	r8,511
80005954:	e0 88 00 22 	brls	80005998 <phy_payload_rx+0x928>
						{
							RxAMBE_IsFillingNext8 = 0;
80005958:	fe f8 05 b8 	ld.w	r8,pc[1464]
8000595c:	30 09       	mov	r9,0
8000595e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005960:	fe f8 05 8c 	ld.w	r8,pc[1420]
80005964:	70 08       	ld.w	r8,r8[0x0]
80005966:	10 9c       	mov	r12,r8
80005968:	f0 1f 01 6c 	mcall	80005f18 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
8000596c:	fe f8 05 78 	ld.w	r8,pc[1400]
80005970:	70 08       	ld.w	r8,r8[0x0]
80005972:	10 9c       	mov	r12,r8
80005974:	f0 1f 01 5d 	mcall	80005ee8 <phy_payload_rx+0xe78>
80005978:	18 98       	mov	r8,r12
8000597a:	10 99       	mov	r9,r8
8000597c:	fe f8 05 70 	ld.w	r8,pc[1392]
80005980:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005982:	fe f8 05 6a 	ld.w	r8,pc[1386]
80005986:	70 08       	ld.w	r8,r8[0x0]
80005988:	58 08       	cp.w	r8,0
8000598a:	c0 71       	brne	80005998 <phy_payload_rx+0x928>
							{
								RxMediaState = WAITINGABAB;
8000598c:	fe f8 05 64 	ld.w	r8,pc[1380]
80005990:	30 09       	mov	r9,0
80005992:	91 09       	st.w	r8[0x0],r9
								break;
80005994:	e0 8f 02 a3 	bral	80005eda <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005998:	fe f8 05 60 	ld.w	r8,pc[1376]
8000599c:	70 08       	ld.w	r8,r8[0x0]
8000599e:	f0 c9 00 01 	sub	r9,r8,1
800059a2:	fe f8 05 56 	ld.w	r8,pc[1366]
800059a6:	91 09       	st.w	r8[0x0],r9
800059a8:	fe f8 05 50 	ld.w	r8,pc[1360]
800059ac:	70 08       	ld.w	r8,r8[0x0]
800059ae:	58 08       	cp.w	r8,0
800059b0:	c0 71       	brne	800059be <phy_payload_rx+0x94e>
							RxMediaState = WAITINGABAB;
800059b2:	fe f8 05 3e 	ld.w	r8,pc[1342]
800059b6:	30 09       	mov	r9,0
800059b8:	91 09       	st.w	r8[0x0],r9
							break;
800059ba:	e0 8f 02 90 	bral	80005eda <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800059be:	fe f8 05 2e 	ld.w	r8,pc[1326]
800059c2:	70 09       	ld.w	r9,r8[0x0]
800059c4:	fe f8 05 4c 	ld.w	r8,pc[1356]
800059c8:	70 08       	ld.w	r8,r8[0x0]
800059ca:	10 09       	add	r9,r8
800059cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800059d0:	11 a8       	ld.ub	r8,r8[0x2]
800059d2:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
800059d4:	fe f8 05 3c 	ld.w	r8,pc[1340]
800059d8:	70 08       	ld.w	r8,r8[0x0]
800059da:	f0 c9 ff ff 	sub	r9,r8,-1
800059de:	fe f8 05 32 	ld.w	r8,pc[1330]
800059e2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800059e4:	fe f8 05 2c 	ld.w	r8,pc[1324]
800059e8:	70 08       	ld.w	r8,r8[0x0]
800059ea:	e0 48 01 ff 	cp.w	r8,511
800059ee:	e0 88 00 22 	brls	80005a32 <phy_payload_rx+0x9c2>
						{
							RxAMBE_IsFillingNext8 = 0;
800059f2:	fe f8 05 1e 	ld.w	r8,pc[1310]
800059f6:	30 09       	mov	r9,0
800059f8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800059fa:	fe f8 04 f2 	ld.w	r8,pc[1266]
800059fe:	70 08       	ld.w	r8,r8[0x0]
80005a00:	10 9c       	mov	r12,r8
80005a02:	f0 1f 01 46 	mcall	80005f18 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80005a06:	fe f8 04 de 	ld.w	r8,pc[1246]
80005a0a:	70 08       	ld.w	r8,r8[0x0]
80005a0c:	10 9c       	mov	r12,r8
80005a0e:	f0 1f 01 37 	mcall	80005ee8 <phy_payload_rx+0xe78>
80005a12:	18 98       	mov	r8,r12
80005a14:	10 99       	mov	r9,r8
80005a16:	fe f8 04 d6 	ld.w	r8,pc[1238]
80005a1a:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005a1c:	fe f8 04 d0 	ld.w	r8,pc[1232]
80005a20:	70 08       	ld.w	r8,r8[0x0]
80005a22:	58 08       	cp.w	r8,0
80005a24:	c0 71       	brne	80005a32 <phy_payload_rx+0x9c2>
							{
								RxMediaState = WAITINGABAB;
80005a26:	fe f8 04 ca 	ld.w	r8,pc[1226]
80005a2a:	30 09       	mov	r9,0
80005a2c:	91 09       	st.w	r8[0x0],r9
								break;
80005a2e:	e0 8f 02 56 	bral	80005eda <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005a32:	fe f8 04 c6 	ld.w	r8,pc[1222]
80005a36:	70 08       	ld.w	r8,r8[0x0]
80005a38:	f0 c9 00 01 	sub	r9,r8,1
80005a3c:	fe f8 04 bc 	ld.w	r8,pc[1212]
80005a40:	91 09       	st.w	r8[0x0],r9
80005a42:	fe f8 04 b6 	ld.w	r8,pc[1206]
80005a46:	70 08       	ld.w	r8,r8[0x0]
80005a48:	58 08       	cp.w	r8,0
80005a4a:	c0 71       	brne	80005a58 <phy_payload_rx+0x9e8>
							RxMediaState = WAITINGABAB;
80005a4c:	fe f8 04 a4 	ld.w	r8,pc[1188]
80005a50:	30 09       	mov	r9,0
80005a52:	91 09       	st.w	r8[0x0],r9
							break;
80005a54:	e0 8f 02 43 	bral	80005eda <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80005a58:	fe f8 04 94 	ld.w	r8,pc[1172]
80005a5c:	70 09       	ld.w	r9,r8[0x0]
80005a5e:	fe f8 04 b2 	ld.w	r8,pc[1202]
80005a62:	70 08       	ld.w	r8,r8[0x0]
80005a64:	10 09       	add	r9,r8
80005a66:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005a6a:	11 b8       	ld.ub	r8,r8[0x3]
80005a6c:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80005a6e:	fe f8 04 a2 	ld.w	r8,pc[1186]
80005a72:	70 08       	ld.w	r8,r8[0x0]
80005a74:	f0 c9 ff ff 	sub	r9,r8,-1
80005a78:	fe f8 04 98 	ld.w	r8,pc[1176]
80005a7c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005a7e:	fe f8 04 92 	ld.w	r8,pc[1170]
80005a82:	70 08       	ld.w	r8,r8[0x0]
80005a84:	e0 48 01 ff 	cp.w	r8,511
80005a88:	e0 88 00 22 	brls	80005acc <phy_payload_rx+0xa5c>
						{
							RxAMBE_IsFillingNext8 = 0;
80005a8c:	fe f8 04 84 	ld.w	r8,pc[1156]
80005a90:	30 09       	mov	r9,0
80005a92:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005a94:	fe f8 04 58 	ld.w	r8,pc[1112]
80005a98:	70 08       	ld.w	r8,r8[0x0]
80005a9a:	10 9c       	mov	r12,r8
80005a9c:	f0 1f 01 1f 	mcall	80005f18 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80005aa0:	fe f8 04 44 	ld.w	r8,pc[1092]
80005aa4:	70 08       	ld.w	r8,r8[0x0]
80005aa6:	10 9c       	mov	r12,r8
80005aa8:	f0 1f 01 10 	mcall	80005ee8 <phy_payload_rx+0xe78>
80005aac:	18 98       	mov	r8,r12
80005aae:	10 99       	mov	r9,r8
80005ab0:	fe f8 04 3c 	ld.w	r8,pc[1084]
80005ab4:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005ab6:	fe f8 04 36 	ld.w	r8,pc[1078]
80005aba:	70 08       	ld.w	r8,r8[0x0]
80005abc:	58 08       	cp.w	r8,0
80005abe:	c0 71       	brne	80005acc <phy_payload_rx+0xa5c>
							{
								RxMediaState = WAITINGABAB;
80005ac0:	fe f8 04 30 	ld.w	r8,pc[1072]
80005ac4:	30 09       	mov	r9,0
80005ac6:	91 09       	st.w	r8[0x0],r9
								break;
80005ac8:	e0 8f 02 09 	bral	80005eda <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005acc:	fe f8 04 2c 	ld.w	r8,pc[1068]
80005ad0:	70 08       	ld.w	r8,r8[0x0]
80005ad2:	f0 c9 00 01 	sub	r9,r8,1
80005ad6:	fe f8 04 22 	ld.w	r8,pc[1058]
80005ada:	91 09       	st.w	r8[0x0],r9
80005adc:	fe f8 04 1c 	ld.w	r8,pc[1052]
80005ae0:	70 08       	ld.w	r8,r8[0x0]
80005ae2:	58 08       	cp.w	r8,0
80005ae4:	c0 71       	brne	80005af2 <phy_payload_rx+0xa82>
							RxMediaState = WAITINGABAB;
80005ae6:	fe f8 04 0a 	ld.w	r8,pc[1034]
80005aea:	30 09       	mov	r9,0
80005aec:	91 09       	st.w	r8[0x0],r9
							break;
80005aee:	e0 8f 01 f6 	bral	80005eda <phy_payload_rx+0xe6a>
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80005af2:	fe f8 03 fa 	ld.w	r8,pc[1018]
80005af6:	70 09       	ld.w	r9,r8[0x0]
80005af8:	fe f8 04 18 	ld.w	r8,pc[1048]
80005afc:	70 08       	ld.w	r8,r8[0x0]
80005afe:	10 09       	add	r9,r8
80005b00:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005b04:	11 c8       	ld.ub	r8,r8[0x4]
80005b06:	b2 88       	st.b	r9[0x0],r8
						RxAMBE_IsFillingNext8 += 1;
80005b08:	fe f8 04 08 	ld.w	r8,pc[1032]
80005b0c:	70 08       	ld.w	r8,r8[0x0]
80005b0e:	f0 c9 ff ff 	sub	r9,r8,-1
80005b12:	fe f8 03 fe 	ld.w	r8,pc[1022]
80005b16:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005b18:	fe f8 03 f8 	ld.w	r8,pc[1016]
80005b1c:	70 08       	ld.w	r8,r8[0x0]
80005b1e:	e0 48 01 ff 	cp.w	r8,511
80005b22:	e0 88 00 22 	brls	80005b66 <phy_payload_rx+0xaf6>
						{
							RxAMBE_IsFillingNext8 = 0;
80005b26:	fe f8 03 ea 	ld.w	r8,pc[1002]
80005b2a:	30 09       	mov	r9,0
80005b2c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80005b2e:	fe f8 03 be 	ld.w	r8,pc[958]
80005b32:	70 08       	ld.w	r8,r8[0x0]
80005b34:	10 9c       	mov	r12,r8
80005b36:	f0 1f 00 f9 	mcall	80005f18 <phy_payload_rx+0xea8>
							AMBE_payload_ptr = get_payload_idle_isr();
80005b3a:	fe f8 03 aa 	ld.w	r8,pc[938]
80005b3e:	70 08       	ld.w	r8,r8[0x0]
80005b40:	10 9c       	mov	r12,r8
80005b42:	f0 1f 00 ea 	mcall	80005ee8 <phy_payload_rx+0xe78>
80005b46:	18 98       	mov	r8,r12
80005b48:	10 99       	mov	r9,r8
80005b4a:	fe f8 03 a2 	ld.w	r8,pc[930]
80005b4e:	91 09       	st.w	r8[0x0],r9
							if(NULL == AMBE_payload_ptr)
80005b50:	fe f8 03 9c 	ld.w	r8,pc[924]
80005b54:	70 08       	ld.w	r8,r8[0x0]
80005b56:	58 08       	cp.w	r8,0
80005b58:	c0 71       	brne	80005b66 <phy_payload_rx+0xaf6>
							{
								RxMediaState = WAITINGABAB;
80005b5a:	fe f8 03 96 	ld.w	r8,pc[918]
80005b5e:	30 09       	mov	r9,0
80005b60:	91 09       	st.w	r8[0x0],r9
								break;
80005b62:	e0 8f 01 bc 	bral	80005eda <phy_payload_rx+0xe6a>
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80005b66:	fe f8 03 92 	ld.w	r8,pc[914]
80005b6a:	70 08       	ld.w	r8,r8[0x0]
80005b6c:	f0 c9 00 01 	sub	r9,r8,1
80005b70:	fe f8 03 88 	ld.w	r8,pc[904]
80005b74:	91 09       	st.w	r8[0x0],r9
80005b76:	fe f8 03 82 	ld.w	r8,pc[898]
80005b7a:	70 08       	ld.w	r8,r8[0x0]
80005b7c:	58 08       	cp.w	r8,0
80005b7e:	c0 71       	brne	80005b8c <phy_payload_rx+0xb1c>
							RxMediaState = WAITINGABAB;
80005b80:	fe f8 03 70 	ld.w	r8,pc[880]
80005b84:	30 09       	mov	r9,0
80005b86:	91 09       	st.w	r8[0x0],r9
							break;
80005b88:	e0 8f 01 a9 	bral	80005eda <phy_payload_rx+0xe6a>
						}
						
						//AMBE Vocoder Bits Stream(bit59~63),
						if ((RxBytesWaiting -= 1) <= 0){
80005b8c:	fe f8 03 6c 	ld.w	r8,pc[876]
80005b90:	70 08       	ld.w	r8,r8[0x0]
80005b92:	f0 c9 00 01 	sub	r9,r8,1
80005b96:	fe f8 03 62 	ld.w	r8,pc[866]
80005b9a:	91 09       	st.w	r8[0x0],r9
80005b9c:	fe f8 03 5c 	ld.w	r8,pc[860]
80005ba0:	70 08       	ld.w	r8,r8[0x0]
80005ba2:	58 08       	cp.w	r8,0
80005ba4:	e0 81 01 96 	brne	80005ed0 <phy_payload_rx+0xe60>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80005ba8:	fe f8 03 48 	ld.w	r8,pc[840]
80005bac:	30 09       	mov	r9,0
80005bae:	91 09       	st.w	r8[0x0],r9
							break;
80005bb0:	e0 8f 01 95 	bral	80005eda <phy_payload_rx+0xe6a>
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80005bb4:	fe f8 03 54 	ld.w	r8,pc[852]
80005bb8:	11 88       	ld.ub	r8,r8[0x0]
80005bba:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005bbe:	30 48       	mov	r8,4
80005bc0:	f0 09 18 00 	cp.b	r9,r8
80005bc4:	c0 a0       	breq	80005bd8 <phy_payload_rx+0xb68>
80005bc6:	fe f8 03 42 	ld.w	r8,pc[834]
80005bca:	11 88       	ld.ub	r8,r8[0x0]
80005bcc:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005bd0:	30 38       	mov	r8,3
80005bd2:	f0 09 18 00 	cp.b	r9,r8
80005bd6:	c2 51       	brne	80005c20 <phy_payload_rx+0xbb0>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80005bd8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005bdc:	70 09       	ld.w	r9,r8[0x0]
80005bde:	fe f8 03 52 	ld.w	r8,pc[850]
80005be2:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80005be4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005be8:	70 19       	ld.w	r9,r8[0x4]
80005bea:	fe f8 03 46 	ld.w	r8,pc[838]
80005bee:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80005bf0:	fe f8 03 08 	ld.w	r8,pc[776]
80005bf4:	70 08       	ld.w	r8,r8[0x0]
80005bf6:	f0 c9 00 08 	sub	r9,r8,8
80005bfa:	fe f8 02 fe 	ld.w	r8,pc[766]
80005bfe:	91 09       	st.w	r8[0x0],r9
80005c00:	fe f8 02 f8 	ld.w	r8,pc[760]
80005c04:	70 08       	ld.w	r8,r8[0x0]
80005c06:	58 08       	cp.w	r8,0
80005c08:	e0 81 01 66 	brne	80005ed4 <phy_payload_rx+0xe64>
						{
					
							RxBytesWaiting = 0;
80005c0c:	fe f8 02 ec 	ld.w	r8,pc[748]
80005c10:	30 09       	mov	r9,0
80005c12:	91 09       	st.w	r8[0x0],r9
							RxMediaState = WAITINGABAB;
80005c14:	fe f8 02 dc 	ld.w	r8,pc[732]
80005c18:	30 09       	mov	r9,0
80005c1a:	91 09       	st.w	r8[0x0],r9
							break;
80005c1c:	e0 8f 01 5f 	bral	80005eda <phy_payload_rx+0xe6a>
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80005c20:	fe f8 02 e8 	ld.w	r8,pc[744]
80005c24:	11 88       	ld.ub	r8,r8[0x0]
80005c26:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005c2a:	31 38       	mov	r8,19
80005c2c:	f0 09 18 00 	cp.b	r9,r8
80005c30:	e0 81 00 ea 	brne	80005e04 <phy_payload_rx+0xd94>
					{							
						if (SDV_Index == 12)
80005c34:	fe f8 03 08 	ld.w	r8,pc[776]
80005c38:	11 89       	ld.ub	r9,r8[0x0]
80005c3a:	30 c8       	mov	r8,12
80005c3c:	f0 09 18 00 	cp.b	r9,r8
80005c40:	e0 81 00 b4 	brne	80005da8 <phy_payload_rx+0xd38>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80005c44:	fe f8 02 f8 	ld.w	r8,pc[760]
80005c48:	11 88       	ld.ub	r8,r8[0x0]
80005c4a:	10 9a       	mov	r10,r8
80005c4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005c50:	90 08       	ld.sh	r8,r8[0x0]
80005c52:	fe f9 02 ee 	ld.w	r9,pc[750]
80005c56:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							
							SDV_Index = 0;
80005c5a:	fe f9 02 e2 	ld.w	r9,pc[738]
80005c5e:	30 08       	mov	r8,0
80005c60:	b2 88       	st.b	r9[0x0],r8
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
80005c62:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005c66:	11 d9       	ld.ub	r9,r8[0x5]
80005c68:	3f 38       	mov	r8,-13
80005c6a:	f0 09 18 00 	cp.b	r9,r8
80005c6e:	e0 81 00 99 	brne	80005da0 <phy_payload_rx+0xd30>
							{
									Item_ID = Pre_Voice_Decoder_Data;
80005c72:	fe f9 02 96 	ld.w	r9,pc[662]
80005c76:	3f 38       	mov	r8,-13
80005c78:	b2 88       	st.b	r9[0x0],r8
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80005c7a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005c7e:	11 c8       	ld.ub	r8,r8[0x4]
80005c80:	f3 d8 c0 07 	bfextu	r9,r8,0x0,0x7
80005c84:	fe f8 02 74 	ld.w	r8,pc[628]
80005c88:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//AMBE
80005c8a:	fe f9 02 ba 	ld.w	r9,pc[698]
80005c8e:	30 18       	mov	r8,1
80005c90:	b2 88       	st.b	r9[0x0],r8
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//
80005c92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005c96:	90 38       	ld.sh	r8,r8[0x6]
80005c98:	fe f9 02 a0 	ld.w	r9,pc[672]
80005c9c:	b2 08       	st.h	r9[0x0],r8
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80005c9e:	fe f8 02 4e 	ld.w	r8,pc[590]
80005ca2:	70 09       	ld.w	r9,r8[0x0]
80005ca4:	fe f8 02 6c 	ld.w	r8,pc[620]
80005ca8:	70 08       	ld.w	r8,r8[0x0]
80005caa:	10 09       	add	r9,r8
80005cac:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005cb0:	11 e8       	ld.ub	r8,r8[0x6]
80005cb2:	b2 88       	st.b	r9[0x0],r8
									RxAMBE_IsFillingNext8 += 1;
80005cb4:	fe f8 02 5c 	ld.w	r8,pc[604]
80005cb8:	70 08       	ld.w	r8,r8[0x0]
80005cba:	f0 c9 ff ff 	sub	r9,r8,-1
80005cbe:	fe f8 02 52 	ld.w	r8,pc[594]
80005cc2:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005cc4:	fe f8 02 4c 	ld.w	r8,pc[588]
80005cc8:	70 08       	ld.w	r8,r8[0x0]
80005cca:	e0 48 01 ff 	cp.w	r8,511
80005cce:	e0 88 00 1e 	brls	80005d0a <phy_payload_rx+0xc9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80005cd2:	fe f8 02 3e 	ld.w	r8,pc[574]
80005cd6:	30 09       	mov	r9,0
80005cd8:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80005cda:	fe f8 02 12 	ld.w	r8,pc[530]
80005cde:	70 08       	ld.w	r8,r8[0x0]
80005ce0:	10 9c       	mov	r12,r8
80005ce2:	f0 1f 00 8e 	mcall	80005f18 <phy_payload_rx+0xea8>
										AMBE_payload_ptr = get_payload_idle_isr();
80005ce6:	fe f8 01 fe 	ld.w	r8,pc[510]
80005cea:	70 08       	ld.w	r8,r8[0x0]
80005cec:	10 9c       	mov	r12,r8
80005cee:	f0 1f 00 7f 	mcall	80005ee8 <phy_payload_rx+0xe78>
80005cf2:	18 98       	mov	r8,r12
80005cf4:	10 99       	mov	r9,r8
80005cf6:	4f e8       	lddpc	r8,80005eec <phy_payload_rx+0xe7c>
80005cf8:	91 09       	st.w	r8[0x0],r9
										if(NULL == AMBE_payload_ptr)
80005cfa:	4f d8       	lddpc	r8,80005eec <phy_payload_rx+0xe7c>
80005cfc:	70 08       	ld.w	r8,r8[0x0]
80005cfe:	58 08       	cp.w	r8,0
80005d00:	c0 51       	brne	80005d0a <phy_payload_rx+0xc9a>
										{
											RxMediaState = WAITINGABAB;
80005d02:	4f c8       	lddpc	r8,80005ef0 <phy_payload_rx+0xe80>
80005d04:	30 09       	mov	r9,0
80005d06:	91 09       	st.w	r8[0x0],r9
											break;
80005d08:	ce 98       	rjmp	80005eda <phy_payload_rx+0xe6a>
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80005d0a:	4f c8       	lddpc	r8,80005ef8 <phy_payload_rx+0xe88>
80005d0c:	70 08       	ld.w	r8,r8[0x0]
80005d0e:	f0 c9 00 01 	sub	r9,r8,1
80005d12:	4f a8       	lddpc	r8,80005ef8 <phy_payload_rx+0xe88>
80005d14:	91 09       	st.w	r8[0x0],r9
80005d16:	4f 98       	lddpc	r8,80005ef8 <phy_payload_rx+0xe88>
80005d18:	70 08       	ld.w	r8,r8[0x0]
80005d1a:	58 08       	cp.w	r8,0
80005d1c:	c0 51       	brne	80005d26 <phy_payload_rx+0xcb6>
										RxMediaState = WAITINGABAB;
80005d1e:	4f 58       	lddpc	r8,80005ef0 <phy_payload_rx+0xe80>
80005d20:	30 09       	mov	r9,0
80005d22:	91 09       	st.w	r8[0x0],r9
										break;
80005d24:	cd b8       	rjmp	80005eda <phy_payload_rx+0xe6a>
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80005d26:	4f 28       	lddpc	r8,80005eec <phy_payload_rx+0xe7c>
80005d28:	70 09       	ld.w	r9,r8[0x0]
80005d2a:	4f a8       	lddpc	r8,80005f10 <phy_payload_rx+0xea0>
80005d2c:	70 08       	ld.w	r8,r8[0x0]
80005d2e:	10 09       	add	r9,r8
80005d30:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d34:	11 f8       	ld.ub	r8,r8[0x7]
80005d36:	b2 88       	st.b	r9[0x0],r8
									RxAMBE_IsFillingNext8 += 1;
80005d38:	4f 68       	lddpc	r8,80005f10 <phy_payload_rx+0xea0>
80005d3a:	70 08       	ld.w	r8,r8[0x0]
80005d3c:	f0 c9 ff ff 	sub	r9,r8,-1
80005d40:	4f 48       	lddpc	r8,80005f10 <phy_payload_rx+0xea0>
80005d42:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80005d44:	4f 38       	lddpc	r8,80005f10 <phy_payload_rx+0xea0>
80005d46:	70 08       	ld.w	r8,r8[0x0]
80005d48:	e0 48 01 ff 	cp.w	r8,511
80005d4c:	e0 88 00 1b 	brls	80005d82 <phy_payload_rx+0xd12>
									{
										RxAMBE_IsFillingNext8 = 0;
80005d50:	4f 08       	lddpc	r8,80005f10 <phy_payload_rx+0xea0>
80005d52:	30 09       	mov	r9,0
80005d54:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80005d56:	4e 68       	lddpc	r8,80005eec <phy_payload_rx+0xe7c>
80005d58:	70 08       	ld.w	r8,r8[0x0]
80005d5a:	10 9c       	mov	r12,r8
80005d5c:	f0 1f 00 6f 	mcall	80005f18 <phy_payload_rx+0xea8>
										AMBE_payload_ptr = get_payload_idle_isr();
80005d60:	4e 18       	lddpc	r8,80005ee4 <phy_payload_rx+0xe74>
80005d62:	70 08       	ld.w	r8,r8[0x0]
80005d64:	10 9c       	mov	r12,r8
80005d66:	f0 1f 00 61 	mcall	80005ee8 <phy_payload_rx+0xe78>
80005d6a:	18 98       	mov	r8,r12
80005d6c:	10 99       	mov	r9,r8
80005d6e:	4e 08       	lddpc	r8,80005eec <phy_payload_rx+0xe7c>
80005d70:	91 09       	st.w	r8[0x0],r9
										if(NULL == AMBE_payload_ptr)
80005d72:	4d f8       	lddpc	r8,80005eec <phy_payload_rx+0xe7c>
80005d74:	70 08       	ld.w	r8,r8[0x0]
80005d76:	58 08       	cp.w	r8,0
80005d78:	c0 51       	brne	80005d82 <phy_payload_rx+0xd12>
										{
											RxMediaState = WAITINGABAB;
80005d7a:	4d e8       	lddpc	r8,80005ef0 <phy_payload_rx+0xe80>
80005d7c:	30 09       	mov	r9,0
80005d7e:	91 09       	st.w	r8[0x0],r9
											break;
80005d80:	ca d8       	rjmp	80005eda <phy_payload_rx+0xe6a>
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80005d82:	4d e8       	lddpc	r8,80005ef8 <phy_payload_rx+0xe88>
80005d84:	70 08       	ld.w	r8,r8[0x0]
80005d86:	f0 c9 00 01 	sub	r9,r8,1
80005d8a:	4d c8       	lddpc	r8,80005ef8 <phy_payload_rx+0xe88>
80005d8c:	91 09       	st.w	r8[0x0],r9
80005d8e:	4d b8       	lddpc	r8,80005ef8 <phy_payload_rx+0xe88>
80005d90:	70 08       	ld.w	r8,r8[0x0]
80005d92:	58 08       	cp.w	r8,0
80005d94:	e0 81 00 a2 	brne	80005ed8 <phy_payload_rx+0xe68>
										RxMediaState = WAITINGABAB;
80005d98:	4d 68       	lddpc	r8,80005ef0 <phy_payload_rx+0xe80>
80005d9a:	30 09       	mov	r9,0
80005d9c:	91 09       	st.w	r8[0x0],r9
										break;
80005d9e:	c9 e8       	rjmp	80005eda <phy_payload_rx+0xe6a>
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80005da0:	4d 48       	lddpc	r8,80005ef0 <phy_payload_rx+0xe80>
80005da2:	30 09       	mov	r9,0
80005da4:	91 09       	st.w	r8[0x0],r9
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
							SDV_Index +=4;
									
						}
							
							break;
80005da6:	c9 a8       	rjmp	80005eda <phy_payload_rx+0xe6a>
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80005da8:	4e 58       	lddpc	r8,80005f3c <phy_payload_rx+0xecc>
80005daa:	11 88       	ld.ub	r8,r8[0x0]
80005dac:	10 9a       	mov	r10,r8
80005dae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005db2:	90 08       	ld.sh	r8,r8[0x0]
80005db4:	4e 39       	lddpc	r9,80005f40 <phy_payload_rx+0xed0>
80005db6:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80005dba:	4e 18       	lddpc	r8,80005f3c <phy_payload_rx+0xecc>
80005dbc:	11 88       	ld.ub	r8,r8[0x0]
80005dbe:	f0 ca ff ff 	sub	r10,r8,-1
80005dc2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005dc6:	90 18       	ld.sh	r8,r8[0x2]
80005dc8:	4d e9       	lddpc	r9,80005f40 <phy_payload_rx+0xed0>
80005dca:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80005dce:	4d c8       	lddpc	r8,80005f3c <phy_payload_rx+0xecc>
80005dd0:	11 88       	ld.ub	r8,r8[0x0]
80005dd2:	f0 ca ff fe 	sub	r10,r8,-2
80005dd6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005dda:	90 28       	ld.sh	r8,r8[0x4]
80005ddc:	4d 99       	lddpc	r9,80005f40 <phy_payload_rx+0xed0>
80005dde:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80005de2:	4d 78       	lddpc	r8,80005f3c <phy_payload_rx+0xecc>
80005de4:	11 88       	ld.ub	r8,r8[0x0]
80005de6:	f0 ca ff fd 	sub	r10,r8,-3
80005dea:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005dee:	90 38       	ld.sh	r8,r8[0x6]
80005df0:	4d 49       	lddpc	r9,80005f40 <phy_payload_rx+0xed0>
80005df2:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
							SDV_Index +=4;
80005df6:	4d 28       	lddpc	r8,80005f3c <phy_payload_rx+0xecc>
80005df8:	11 88       	ld.ub	r8,r8[0x0]
80005dfa:	2f c8       	sub	r8,-4
80005dfc:	5c 58       	castu.b	r8
80005dfe:	4d 09       	lddpc	r9,80005f3c <phy_payload_rx+0xecc>
80005e00:	b2 88       	st.b	r9[0x0],r8
									
						}
							
							break;
80005e02:	c6 c8       	rjmp	80005eda <phy_payload_rx+0xe6a>
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80005e04:	4b b8       	lddpc	r8,80005ef0 <phy_payload_rx+0xe80>
80005e06:	30 09       	mov	r9,0
80005e08:	91 09       	st.w	r8[0x0],r9
						break;
80005e0a:	c6 88       	rjmp	80005eda <phy_payload_rx+0xe6a>
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80005e0c:	4c 78       	lddpc	r8,80005f28 <phy_payload_rx+0xeb8>
80005e0e:	70 0a       	ld.w	r10,r8[0x0]
80005e10:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e14:	90 08       	ld.sh	r8,r8[0x0]
80005e16:	4c 69       	lddpc	r9,80005f2c <phy_payload_rx+0xebc>
80005e18:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
				RxData_IsFillingNext16 += 1;
80005e1c:	4c 38       	lddpc	r8,80005f28 <phy_payload_rx+0xeb8>
80005e1e:	70 08       	ld.w	r8,r8[0x0]
80005e20:	f0 c9 ff ff 	sub	r9,r8,-1
80005e24:	4c 18       	lddpc	r8,80005f28 <phy_payload_rx+0xeb8>
80005e26:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80005e28:	4b 98       	lddpc	r8,80005f0c <phy_payload_rx+0xe9c>
80005e2a:	70 08       	ld.w	r8,r8[0x0]
80005e2c:	f0 c9 00 02 	sub	r9,r8,2
80005e30:	4b 78       	lddpc	r8,80005f0c <phy_payload_rx+0xe9c>
80005e32:	91 09       	st.w	r8[0x0],r9
80005e34:	4b 68       	lddpc	r8,80005f0c <phy_payload_rx+0xe9c>
80005e36:	70 08       	ld.w	r8,r8[0x0]
80005e38:	58 08       	cp.w	r8,0
80005e3a:	c3 e1       	brne	80005eb6 <phy_payload_rx+0xe46>
				{
					RxData_IsFillingNext16 = 0;
80005e3c:	4b b8       	lddpc	r8,80005f28 <phy_payload_rx+0xeb8>
80005e3e:	30 09       	mov	r9,0
80005e40:	91 09       	st.w	r8[0x0],r9
				
					if (payload_rx_channel->word[1] == 0x8212 )
80005e42:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e46:	90 19       	ld.sh	r9,r8[0x2]
80005e48:	fe 78 82 12 	mov	r8,-32238
80005e4c:	f0 09 19 00 	cp.h	r9,r8
80005e50:	c2 f1       	brne	80005eae <phy_payload_rx+0xe3e>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80005e52:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e56:	11 d8       	ld.ub	r8,r8[0x5]
80005e58:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80005e5c:	4b 09       	lddpc	r9,80005f1c <phy_payload_rx+0xeac>
80005e5e:	b2 88       	st.b	r9[0x0],r8
							
						VBSP_data[0] = payload_rx_channel->word[1];
80005e60:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e64:	90 18       	ld.sh	r8,r8[0x2]
80005e66:	4a f9       	lddpc	r9,80005f20 <phy_payload_rx+0xeb0>
80005e68:	b2 08       	st.h	r9[0x0],r8
						VBSP_data[1] = payload_rx_channel->word[2];
80005e6a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e6e:	90 28       	ld.sh	r8,r8[0x4]
80005e70:	4a c9       	lddpc	r9,80005f20 <phy_payload_rx+0xeb0>
80005e72:	b2 18       	st.h	r9[0x2],r8
							
						m_RxBurstType = CalculateBurst(VF_SN);
80005e74:	4a a8       	lddpc	r8,80005f1c <phy_payload_rx+0xeac>
80005e76:	11 88       	ld.ub	r8,r8[0x0]
80005e78:	10 9c       	mov	r12,r8
80005e7a:	f0 1f 00 2b 	mcall	80005f24 <phy_payload_rx+0xeb4>
80005e7e:	18 99       	mov	r9,r12
80005e80:	49 d8       	lddpc	r8,80005ef4 <phy_payload_rx+0xe84>
80005e82:	91 09       	st.w	r8[0x0],r9
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
80005e84:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e88:	11 f9       	ld.ub	r9,r8[0x7]
80005e8a:	31 38       	mov	r8,19
80005e8c:	f0 09 18 00 	cp.b	r9,r8
80005e90:	c0 81       	brne	80005ea0 <phy_payload_rx+0xe30>
						{
							Item_ID = Soft_Decision_Value;	
80005e92:	49 e9       	lddpc	r9,80005f08 <phy_payload_rx+0xe98>
80005e94:	31 38       	mov	r8,19
80005e96:	b2 88       	st.b	r9[0x0],r8
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80005e98:	49 88       	lddpc	r8,80005ef8 <phy_payload_rx+0xe88>
80005e9a:	30 09       	mov	r9,0
80005e9c:	91 09       	st.w	r8[0x0],r9
80005e9e:	c0 48       	rjmp	80005ea6 <phy_payload_rx+0xe36>
						}
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
80005ea0:	49 48       	lddpc	r8,80005ef0 <phy_payload_rx+0xe80>
80005ea2:	30 09       	mov	r9,0
80005ea4:	91 09       	st.w	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80005ea6:	49 38       	lddpc	r8,80005ef0 <phy_payload_rx+0xe80>
80005ea8:	30 49       	mov	r9,4
80005eaa:	91 09       	st.w	r8[0x0],r9
80005eac:	c1 78       	rjmp	80005eda <phy_payload_rx+0xe6a>
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80005eae:	49 18       	lddpc	r8,80005ef0 <phy_payload_rx+0xe80>
80005eb0:	30 09       	mov	r9,0
80005eb2:	91 09       	st.w	r8[0x0],r9
80005eb4:	c1 38       	rjmp	80005eda <phy_payload_rx+0xe6a>
					}

				}
				else
				{//
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80005eb6:	4a 5c       	lddpc	r12,80005f48 <phy_payload_rx+0xed8>
80005eb8:	f0 1f 00 12 	mcall	80005f00 <phy_payload_rx+0xe90>
					RxMediaState = WAITINGABAB;//Jump
80005ebc:	48 d8       	lddpc	r8,80005ef0 <phy_payload_rx+0xe80>
80005ebe:	30 09       	mov	r9,0
80005ec0:	91 09       	st.w	r8[0x0],r9
80005ec2:	c0 c8       	rjmp	80005eda <phy_payload_rx+0xe6a>
				m_RxBurstType = VOICE_WATING;
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80005ec4:	d7 03       	nop
80005ec6:	c0 a8       	rjmp	80005eda <phy_payload_rx+0xe6a>
						RxMediaState  = WAITINGABAB;
						break;
					}
			
			
			break;//End of READING_AMBE_MEDIA.
80005ec8:	d7 03       	nop
80005eca:	c0 88       	rjmp	80005eda <phy_payload_rx+0xe6a>
80005ecc:	d7 03       	nop
80005ece:	c0 68       	rjmp	80005eda <phy_payload_rx+0xe6a>
80005ed0:	d7 03       	nop
80005ed2:	c0 48       	rjmp	80005eda <phy_payload_rx+0xe6a>
							RxBytesWaiting = 0;
							RxMediaState = WAITINGABAB;
							break;
			
						}
						break;
80005ed4:	d7 03       	nop
80005ed6:	c0 28       	rjmp	80005eda <phy_payload_rx+0xe6a>
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
							SDV_Index +=4;
									
						}
							
							break;
80005ed8:	d7 03       	nop

#endif
		case BGFORCERESET: //Do nothing.
		break;
	}//End of RxMedia Phy Handler.
}
80005eda:	2f ed       	sub	sp,-8
80005edc:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ee0:	00 00       	add	r0,r0
80005ee2:	0a ac       	st.w	r5++,r12
80005ee4:	00 00       	add	r0,r0
80005ee6:	0a 94       	mov	r4,r5
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	5f 8c       	srls	r12
80005eec:	00 00       	add	r0,r0
80005eee:	0a b0       	st.h	r5++,r0
80005ef0:	00 00       	add	r0,r0
80005ef2:	0a b4       	st.h	r5++,r4
80005ef4:	00 00       	add	r0,r0
80005ef6:	0a a0       	st.w	r5++,r0
80005ef8:	00 00       	add	r0,r0
80005efa:	0a b8       	st.h	r5++,r8
80005efc:	80 00       	ld.sh	r0,r0[0x0]
80005efe:	42 b4       	lddsp	r4,sp[0xac]
80005f00:	80 00       	ld.sh	r0,r0[0x0]
80005f02:	a5 f0       	*unknown*
80005f04:	00 00       	add	r0,r0
80005f06:	0a 5b       	eor	r11,r5
80005f08:	00 00       	add	r0,r0
80005f0a:	0a bc       	st.h	r5++,r12
80005f0c:	00 00       	add	r0,r0
80005f0e:	0a c0       	st.b	r5++,r0
80005f10:	00 00       	add	r0,r0
80005f12:	0a c4       	st.b	r5++,r4
80005f14:	80 00       	ld.sh	r0,r0[0x0]
80005f16:	b1 ba       	sbr	r10,0x11
80005f18:	80 00       	ld.sh	r0,r0[0x0]
80005f1a:	4f f4       	lddpc	r4,80006114 <local_start_SSC+0x24>
80005f1c:	00 00       	add	r0,r0
80005f1e:	0a 5f       	eor	pc,r5
80005f20:	00 00       	add	r0,r0
80005f22:	20 a8       	sub	r8,10
80005f24:	80 00       	ld.sh	r0,r0[0x0]
80005f26:	41 78       	lddsp	r8,sp[0x5c]
80005f28:	00 00       	add	r0,r0
80005f2a:	0a c8       	st.b	r5++,r8
80005f2c:	00 00       	add	r0,r0
80005f2e:	1f ac       	ld.ub	r12,pc[0x2]
80005f30:	00 00       	add	r0,r0
80005f32:	0a a4       	st.w	r5++,r4
80005f34:	00 00       	add	r0,r0
80005f36:	0a 5a       	eor	r10,r5
80005f38:	00 00       	add	r0,r0
80005f3a:	1f a4       	ld.ub	r4,pc[0x2]
80005f3c:	00 00       	add	r0,r0
80005f3e:	0a cc       	st.b	r5++,r12
80005f40:	00 00       	add	r0,r0
80005f42:	20 ac       	sub	r12,10
80005f44:	00 00       	add	r0,r0
80005f46:	0a 59       	eor	r9,r5
80005f48:	80 00       	ld.sh	r0,r0[0x0]
80005f4a:	42 cc       	lddsp	r12,sp[0xb0]

80005f4c <get_idle_store>:
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80005f4c:	eb cd 40 80 	pushm	r7,lr
80005f50:	1a 97       	mov	r7,sp
80005f52:	20 2d       	sub	sp,8
80005f54:	ef 4c ff f8 	st.w	r7[-8],r12
	void * ptr = NULL;
80005f58:	30 08       	mov	r8,0
80005f5a:	ef 48 ff fc 	st.w	r7[-4],r8

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80005f5e:	ee c8 00 04 	sub	r8,r7,4
80005f62:	30 09       	mov	r9,0
80005f64:	30 0a       	mov	r10,0
80005f66:	10 9b       	mov	r11,r8
80005f68:	ee fc ff f8 	ld.w	r12,r7[-8]
80005f6c:	f0 1f 00 07 	mcall	80005f88 <get_idle_store+0x3c>
80005f70:	18 98       	mov	r8,r12
80005f72:	58 18       	cp.w	r8,1
80005f74:	c0 41       	brne	80005f7c <get_idle_store+0x30>
	{
		return ptr;
80005f76:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005f7a:	c0 28       	rjmp	80005f7e <get_idle_store+0x32>
	}
	else
	{
		return NULL;
80005f7c:	30 08       	mov	r8,0
	}
}
80005f7e:	10 9c       	mov	r12,r8
80005f80:	2f ed       	sub	sp,-8
80005f82:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f86:	00 00       	add	r0,r0
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	8c 60       	ld.sh	r0,r6[0xc]

80005f8c <get_idle_store_isr>:

void * get_idle_store_isr(xQueueHandle store)
{
80005f8c:	eb cd 40 80 	pushm	r7,lr
80005f90:	1a 97       	mov	r7,sp
80005f92:	20 3d       	sub	sp,12
80005f94:	ef 4c ff f4 	st.w	r7[-12],r12
	void * ptr = NULL;
80005f98:	30 08       	mov	r8,0
80005f9a:	ef 48 ff fc 	st.w	r7[-4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80005f9e:	30 08       	mov	r8,0
80005fa0:	ef 48 ff f8 	st.w	r7[-8],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80005fa4:	ee c9 00 08 	sub	r9,r7,8
80005fa8:	ee c8 00 04 	sub	r8,r7,4
80005fac:	12 9a       	mov	r10,r9
80005fae:	10 9b       	mov	r11,r8
80005fb0:	ee fc ff f4 	ld.w	r12,r7[-12]
80005fb4:	f0 1f 00 07 	mcall	80005fd0 <get_idle_store_isr+0x44>
80005fb8:	18 98       	mov	r8,r12
80005fba:	58 18       	cp.w	r8,1
80005fbc:	c0 41       	brne	80005fc4 <get_idle_store_isr+0x38>
	{
		return ptr;
80005fbe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005fc2:	c0 28       	rjmp	80005fc6 <get_idle_store_isr+0x3a>
	}
	else
	{
		return NULL;
80005fc4:	30 08       	mov	r8,0
	}
}
80005fc6:	10 9c       	mov	r12,r8
80005fc8:	2f dd       	sub	sp,-12
80005fca:	e3 cd 80 80 	ldm	sp++,r7,pc
80005fce:	00 00       	add	r0,r0
80005fd0:	80 00       	ld.sh	r0,r0[0x0]
80005fd2:	8e 4c       	ld.sh	r12,r7[0x8]

80005fd4 <set_idle_store>:


void set_idle_store(xQueueHandle store, void * ptr)
{
80005fd4:	eb cd 40 80 	pushm	r7,lr
80005fd8:	1a 97       	mov	r7,sp
80005fda:	20 2d       	sub	sp,8
80005fdc:	ef 4c ff fc 	st.w	r7[-4],r12
80005fe0:	ef 4b ff f8 	st.w	r7[-8],r11
	xQueueSend(store, &ptr, 0);
80005fe4:	ee c8 00 08 	sub	r8,r7,8
80005fe8:	30 09       	mov	r9,0
80005fea:	30 0a       	mov	r10,0
80005fec:	10 9b       	mov	r11,r8
80005fee:	ee fc ff fc 	ld.w	r12,r7[-4]
80005ff2:	f0 1f 00 03 	mcall	80005ffc <set_idle_store+0x28>
}
80005ff6:	2f ed       	sub	sp,-8
80005ff8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ffc:	80 00       	ld.sh	r0,r0[0x0]
80005ffe:	8a 54       	ld.sh	r4,r5[0xa]

80006000 <set_idle_store_isr>:

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80006000:	eb cd 40 80 	pushm	r7,lr
80006004:	1a 97       	mov	r7,sp
80006006:	20 3d       	sub	sp,12
80006008:	ef 4c ff f8 	st.w	r7[-8],r12
8000600c:	ef 4b ff f4 	st.w	r7[-12],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006010:	30 08       	mov	r8,0
80006012:	ef 48 ff fc 	st.w	r7[-4],r8
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80006016:	ee ca 00 04 	sub	r10,r7,4
8000601a:	ee c8 00 0c 	sub	r8,r7,12
8000601e:	30 09       	mov	r9,0
80006020:	10 9b       	mov	r11,r8
80006022:	ee fc ff f8 	ld.w	r12,r7[-8]
80006026:	f0 1f 00 03 	mcall	80006030 <set_idle_store_isr+0x30>
}
8000602a:	2f dd       	sub	sp,-12
8000602c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	8b bc       	st.w	r5[0x2c],r12

80006034 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80006034:	eb cd 40 80 	pushm	r7,lr
80006038:	1a 97       	mov	r7,sp
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
8000603a:	4a 98       	lddpc	r8,800060dc <pdca_int_handler+0xa8>
8000603c:	11 88       	ld.ub	r8,r8[0x0]
8000603e:	5c 58       	castu.b	r8
80006040:	ec 18 00 01 	eorl	r8,0x1
80006044:	5c 58       	castu.b	r8
80006046:	4a 69       	lddpc	r9,800060dc <pdca_int_handler+0xa8>
80006048:	b2 88       	st.b	r9[0x0],r8
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
8000604a:	fe 79 00 40 	mov	r9,-65472
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
8000604e:	4a 48       	lddpc	r8,800060dc <pdca_int_handler+0xa8>
80006050:	11 88       	ld.ub	r8,r8[0x0]
80006052:	5c 58       	castu.b	r8
80006054:	a3 68       	lsl	r8,0x2
80006056:	2f f8       	sub	r8,-1
80006058:	f0 0a 15 02 	lsl	r10,r8,0x2
8000605c:	4a 18       	lddpc	r8,800060e0 <pdca_int_handler+0xac>
8000605e:	f4 08 00 08 	add	r8,r10,r8
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80006062:	93 38       	st.w	r9[0xc],r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80006064:	fe 78 00 40 	mov	r8,-65472
80006068:	30 39       	mov	r9,3
8000606a:	91 49       	st.w	r8[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
8000606c:	fe 79 00 00 	mov	r9,-65536
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80006070:	49 b8       	lddpc	r8,800060dc <pdca_int_handler+0xa8>
80006072:	11 88       	ld.ub	r8,r8[0x0]
80006074:	5c 58       	castu.b	r8
80006076:	a3 68       	lsl	r8,0x2
80006078:	2f f8       	sub	r8,-1
8000607a:	f0 0a 15 02 	lsl	r10,r8,0x2
8000607e:	49 a8       	lddpc	r8,800060e4 <pdca_int_handler+0xb0>
80006080:	f4 08 00 08 	add	r8,r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80006084:	93 38       	st.w	r9[0xc],r8
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80006086:	fe 78 00 00 	mov	r8,-65536
8000608a:	30 39       	mov	r9,3
8000608c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
8000608e:	fe 78 00 00 	mov	r8,-65536
80006092:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80006094:	49 58       	lddpc	r8,800060e8 <pdca_int_handler+0xb4>
80006096:	70 08       	ld.w	r8,r8[0x0]
80006098:	58 08       	cp.w	r8,0
8000609a:	c0 d0       	breq	800060b4 <pdca_int_handler+0x80>
8000609c:	49 38       	lddpc	r8,800060e8 <pdca_int_handler+0xb4>
8000609e:	70 09       	ld.w	r9,r8[0x0]
800060a0:	48 f8       	lddpc	r8,800060dc <pdca_int_handler+0xa8>
800060a2:	11 88       	ld.ub	r8,r8[0x0]
800060a4:	5c 58       	castu.b	r8
800060a6:	f0 0a 15 04 	lsl	r10,r8,0x4
800060aa:	48 f8       	lddpc	r8,800060e4 <pdca_int_handler+0xb0>
800060ac:	f4 08 00 08 	add	r8,r10,r8
800060b0:	10 9c       	mov	r12,r8
800060b2:	5d 19       	icall	r9

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
800060b4:	48 e8       	lddpc	r8,800060ec <pdca_int_handler+0xb8>
800060b6:	70 08       	ld.w	r8,r8[0x0]
800060b8:	58 08       	cp.w	r8,0
800060ba:	c0 d0       	breq	800060d4 <pdca_int_handler+0xa0>
800060bc:	48 c8       	lddpc	r8,800060ec <pdca_int_handler+0xb8>
800060be:	70 09       	ld.w	r9,r8[0x0]
800060c0:	48 78       	lddpc	r8,800060dc <pdca_int_handler+0xa8>
800060c2:	11 88       	ld.ub	r8,r8[0x0]
800060c4:	5c 58       	castu.b	r8
800060c6:	f0 0a 15 04 	lsl	r10,r8,0x4
800060ca:	48 68       	lddpc	r8,800060e0 <pdca_int_handler+0xac>
800060cc:	f4 08 00 08 	add	r8,r10,r8
800060d0:	10 9c       	mov	r12,r8
800060d2:	5d 19       	icall	r9

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800060d4:	e3 cd 40 80 	ldm	sp++,r7,lr
800060d8:	d6 03       	rete
800060da:	00 00       	add	r0,r0
800060dc:	00 00       	add	r0,r0
800060de:	52 cc       	stdsp	sp[0xb0],r12
800060e0:	00 00       	add	r0,r0
800060e2:	52 f4       	stdsp	sp[0xbc],r4
800060e4:	00 00       	add	r0,r0
800060e6:	52 d4       	stdsp	sp[0xb4],r4
800060e8:	00 00       	add	r0,r0
800060ea:	0a fc       	st.b	--r5,r12
800060ec:	00 00       	add	r0,r0
800060ee:	0b 00       	ld.w	r0,r5++

800060f0 <local_start_SSC>:
    Before using the SSC transmitter, the PIO controller must be configured to 
    dedicate the SSC,transmitter I/O lines to the SSC peripheral mode. [23.6.1]
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_SSC(void)
{
800060f0:	eb cd 40 80 	pushm	r7,lr
800060f4:	1a 97       	mov	r7,sp
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800060f6:	fe 78 10 00 	mov	r8,-61440
800060fa:	e0 69 0d c0 	mov	r9,3520
800060fe:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80006102:	fe 78 10 00 	mov	r8,-61440
80006106:	e0 69 0d c0 	mov	r9,3520
8000610a:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
8000610e:	fe 78 10 00 	mov	r8,-61440
80006112:	e0 69 0d c0 	mov	r9,3520
80006116:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
8000611a:	fe 78 34 00 	mov	r8,-52224
8000611e:	e0 69 80 00 	mov	r9,32768
80006122:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80006124:	fe 78 34 00 	mov	r8,-52224
80006128:	30 09       	mov	r9,0
8000612a:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000612c:	fe 78 34 00 	mov	r8,-52224
80006130:	e0 69 04 21 	mov	r9,1057
80006134:	ea 19 3f 20 	orh	r9,0x3f20
80006138:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
8000613a:	fe 78 34 00 	mov	r8,-52224
8000613e:	e0 69 02 9f 	mov	r9,671
80006142:	ea 19 01 00 	orh	r9,0x100
80006146:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80006148:	fe 78 34 00 	mov	r8,-52224
8000614c:	e0 69 04 02 	mov	r9,1026
80006150:	ea 19 3f 20 	orh	r9,0x3f20
80006154:	91 49       	st.w	r8[0x10],r9
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80006156:	fe 78 34 00 	mov	r8,-52224
8000615a:	e0 69 02 9f 	mov	r9,671
8000615e:	ea 19 01 00 	orh	r9,0x100
80006162:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80006164:	e3 cd 80 80 	ldm	sp++,r7,pc

80006168 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80006168:	eb cd 40 80 	pushm	r7,lr
8000616c:	1a 97       	mov	r7,sp
    /*Toggle Index*/	
    BufferIndex = 1;
8000616e:	4b 39       	lddpc	r9,80006238 <local_start_PDC+0xd0>
80006170:	30 18       	mov	r8,1
80006172:	b2 88       	st.b	r9[0x0],r8
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80006174:	fe 78 00 00 	mov	r8,-65536
80006178:	30 79       	mov	r9,7
8000617a:	91 99       	st.w	r8[0x24],r9
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
8000617c:	fe 78 00 00 	mov	r8,-65536
80006180:	70 b8       	ld.w	r8,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80006182:	fe 78 00 00 	mov	r8,-65536
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80006186:	4a e9       	lddpc	r9,8000623c <local_start_PDC+0xd4>
80006188:	2f c9       	sub	r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
8000618a:	91 09       	st.w	r8[0x0],r9
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
8000618c:	fe 78 00 00 	mov	r8,-65536
80006190:	30 39       	mov	r9,3
80006192:	91 29       	st.w	r8[0x8],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80006194:	fe 78 00 00 	mov	r8,-65536
80006198:	30 19       	mov	r9,1
8000619a:	91 19       	st.w	r8[0x4],r9
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
8000619c:	fe 78 00 00 	mov	r8,-65536
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
800061a0:	4a 79       	lddpc	r9,8000623c <local_start_PDC+0xd4>
800061a2:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
800061a4:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
800061a6:	fe 78 00 00 	mov	r8,-65536
800061aa:	30 39       	mov	r9,3
800061ac:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
800061ae:	fe 78 00 00 	mov	r8,-65536
800061b2:	30 29       	mov	r9,2
800061b4:	91 69       	st.w	r8[0x18],r9

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
800061b6:	4a 38       	lddpc	r8,80006240 <local_start_PDC+0xd8>
800061b8:	e0 69 5a 5a 	mov	r9,23130
800061bc:	ea 19 ab cd 	orh	r9,0xabcd
800061c0:	91 19       	st.w	r8[0x4],r9
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
800061c2:	4a 08       	lddpc	r8,80006240 <local_start_PDC+0xd8>
800061c4:	e0 69 5a 5a 	mov	r9,23130
800061c8:	ea 19 ab cd 	orh	r9,0xabcd
800061cc:	91 29       	st.w	r8[0x8],r9
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
800061ce:	49 d8       	lddpc	r8,80006240 <local_start_PDC+0xd8>
800061d0:	30 09       	mov	r9,0
800061d2:	91 39       	st.w	r8[0xc],r9
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
800061d4:	49 b8       	lddpc	r8,80006240 <local_start_PDC+0xd8>
800061d6:	e0 69 5a 5a 	mov	r9,23130
800061da:	ea 19 ab cd 	orh	r9,0xabcd
800061de:	91 59       	st.w	r8[0x14],r9
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
800061e0:	49 88       	lddpc	r8,80006240 <local_start_PDC+0xd8>
800061e2:	e0 69 5a 5a 	mov	r9,23130
800061e6:	ea 19 ab cd 	orh	r9,0xabcd
800061ea:	91 69       	st.w	r8[0x18],r9
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
800061ec:	49 58       	lddpc	r8,80006240 <local_start_PDC+0xd8>
800061ee:	30 09       	mov	r9,0
800061f0:	91 79       	st.w	r8[0x1c],r9

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
800061f2:	fe 78 00 40 	mov	r8,-65472
800061f6:	30 79       	mov	r9,7
800061f8:	91 99       	st.w	r8[0x24],r9
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
800061fa:	fe 78 00 40 	mov	r8,-65472
800061fe:	70 b8       	ld.w	r8,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80006200:	fe 78 00 40 	mov	r8,-65472
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80006204:	48 f9       	lddpc	r9,80006240 <local_start_PDC+0xd8>
80006206:	2f c9       	sub	r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80006208:	91 09       	st.w	r8[0x0],r9
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000620a:	fe 78 00 40 	mov	r8,-65472
8000620e:	30 39       	mov	r9,3
80006210:	91 29       	st.w	r8[0x8],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80006212:	fe 78 00 40 	mov	r8,-65472
80006216:	30 79       	mov	r9,7
80006218:	91 19       	st.w	r8[0x4],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
8000621a:	fe 78 00 40 	mov	r8,-65472
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000621e:	48 99       	lddpc	r9,80006240 <local_start_PDC+0xd8>
80006220:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80006222:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80006224:	fe 78 00 40 	mov	r8,-65472
80006228:	30 39       	mov	r9,3
8000622a:	91 49       	st.w	r8[0x10],r9
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000622c:	fe 78 00 40 	mov	r8,-65472
80006230:	30 29       	mov	r9,2
80006232:	91 69       	st.w	r8[0x18],r9
}/*End of local_start_PDC.*/
80006234:	e3 cd 80 80 	ldm	sp++,r7,pc
80006238:	00 00       	add	r0,r0
8000623a:	52 cc       	stdsp	sp[0xb0],r12
8000623c:	00 00       	add	r0,r0
8000623e:	52 d4       	stdsp	sp[0xb4],r4
80006240:	00 00       	add	r0,r0
80006242:	52 f4       	stdsp	sp[0xbc],r4

80006244 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80006244:	eb cd 40 80 	pushm	r7,lr
80006248:	1a 97       	mov	r7,sp
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;	
8000624a:	fe 78 10 00 	mov	r8,-61440
8000624e:	30 29       	mov	r9,2
80006250:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80006254:	fe 78 10 00 	mov	r8,-61440
80006258:	30 29       	mov	r9,2
8000625a:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000625e:	fe 78 10 00 	mov	r8,-61440
80006262:	f0 f8 01 60 	ld.w	r8,r8[352]
80006266:	e2 18 00 02 	andl	r8,0x2,COH
8000626a:	cf a0       	breq	8000625e <ssc_init+0x1a>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000626c:	fe 78 10 00 	mov	r8,-61440
80006270:	f0 f8 01 60 	ld.w	r8,r8[352]
80006274:	e2 18 00 02 	andl	r8,0x2,COH
80006278:	cf a1       	brne	8000626c <ssc_init+0x28>
				
    INTC_register_interrupt (
8000627a:	30 3a       	mov	r10,3
8000627c:	36 0b       	mov	r11,96
8000627e:	48 ec       	lddpc	r12,800062b4 <ssc_init+0x70>
80006280:	f0 1f 00 0e 	mcall	800062b8 <ssc_init+0x74>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80006284:	f0 1f 00 0e 	mcall	800062bc <ssc_init+0x78>

    /*config the PDCA*/
    local_start_PDC();
80006288:	f0 1f 00 0e 	mcall	800062c0 <ssc_init+0x7c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
8000628c:	fe 78 00 00 	mov	r8,-65536
80006290:	30 19       	mov	r9,1
80006292:	91 59       	st.w	r8[0x14],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80006294:	fe 78 00 40 	mov	r8,-65472
80006298:	30 19       	mov	r9,1
8000629a:	91 59       	st.w	r8[0x14],r9
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000629c:	fe 78 34 00 	mov	r8,-52224
800062a0:	e0 69 01 01 	mov	r9,257
800062a4:	91 09       	st.w	r8[0x0],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
800062a6:	fe 78 00 00 	mov	r8,-65536
800062aa:	30 19       	mov	r9,1
800062ac:	91 89       	st.w	r8[0x20],r9
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
800062ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800062b2:	00 00       	add	r0,r0
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	60 34       	ld.w	r4,r0[0xc]
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	73 b4       	ld.w	r4,r9[0x6c]
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	60 f0       	ld.w	r0,r0[0x3c]
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	61 68       	ld.w	r8,r0[0x58]

800062c4 <register_rx_tx_func>:
	void ( *tx_exec)(void *) -- send ssc function
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
800062c4:	eb cd 40 80 	pushm	r7,lr
800062c8:	1a 97       	mov	r7,sp
800062ca:	20 2d       	sub	sp,8
800062cc:	ef 4c ff fc 	st.w	r7[-4],r12
800062d0:	ef 4b ff f8 	st.w	r7[-8],r11
	 phy_rx_exec = rx_exec;
800062d4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800062d8:	48 58       	lddpc	r8,800062ec <register_rx_tx_func+0x28>
800062da:	91 09       	st.w	r8[0x0],r9
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800062dc:	ee f9 ff f8 	ld.w	r9,r7[-8]
800062e0:	48 48       	lddpc	r8,800062f0 <register_rx_tx_func+0x2c>
800062e2:	91 09       	st.w	r8[0x0],r9
	 
}/*End of register_tx_rx_func.*/
800062e4:	2f ed       	sub	sp,-8
800062e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800062ea:	00 00       	add	r0,r0
800062ec:	00 00       	add	r0,r0
800062ee:	0a fc       	st.b	--r5,r12
800062f0:	00 00       	add	r0,r0
800062f2:	0b 00       	ld.w	r0,r5++
800062f4:	58 43       	cp.w	r3,4
800062f6:	4d 50       	lddpc	r0,80006448 <xcmp_exec_func+0x60>
800062f8:	5f 52       	srlt	r2
800062fa:	58 00       	cp.w	r0,0

800062fc <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800062fc:	eb cd 40 80 	pushm	r7,lr
80006300:	1a 97       	mov	r7,sp
80006302:	fa cd 01 08 	sub	sp,sp,264
80006306:	ef 4c fe fc 	st.w	r7[-260],r12
8000630a:	16 98       	mov	r8,r11
8000630c:	ef 68 fe f8 	st.b	r7[-264],r8
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80006310:	ef 38 fe f8 	ld.ub	r8,r7[-264]
80006314:	2f 08       	sub	r8,-16
80006316:	5c 88       	casts.h	r8
80006318:	5c 88       	casts.h	r8
8000631a:	af a8       	sbr	r8,0xe
8000631c:	5c 88       	casts.h	r8
8000631e:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80006322:	3f f8       	mov	r8,-1
80006324:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80006328:	30 b8       	mov	r8,11
8000632a:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000632e:	3f f8       	mov	r8,-1
80006330:	ef 58 ff 06 	st.h	r7[-250],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80006334:	3f f8       	mov	r8,-1
80006336:	ef 58 ff 08 	st.h	r7[-248],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000633a:	3f f8       	mov	r8,-1
8000633c:	ef 58 ff 0a 	st.h	r7[-246],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80006340:	3f f8       	mov	r8,-1
80006342:	ef 58 ff 0c 	st.h	r7[-244],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80006346:	ef 38 fe f8 	ld.ub	r8,r7[-264]
8000634a:	2f e8       	sub	r8,-2
8000634c:	10 99       	mov	r9,r8
8000634e:	ee c8 01 00 	sub	r8,r7,256
80006352:	2f 08       	sub	r8,-16
80006354:	12 9a       	mov	r10,r9
80006356:	ee fb fe fc 	ld.w	r11,r7[-260]
8000635a:	10 9c       	mov	r12,r8
8000635c:	f0 1f 00 09 	mcall	80006380 <xcmp_tx+0x84>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80006360:	ef 38 fe f8 	ld.ub	r8,r7[-264]
80006364:	2f e8       	sub	r8,-2
80006366:	5c 88       	casts.h	r8
80006368:	5c 88       	casts.h	r8
8000636a:	ef 58 ff 0e 	st.h	r7[-242],r8
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
8000636e:	ee c8 01 00 	sub	r8,r7,256
80006372:	10 9c       	mov	r12,r8
80006374:	f0 1f 00 04 	mcall	80006384 <xcmp_tx+0x88>
}
80006378:	2b ed       	sub	sp,-264
8000637a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000637e:	00 00       	add	r0,r0
80006380:	80 00       	ld.sh	r0,r0[0x0]
80006382:	b0 72       	st.h	r8[0xe],r2
80006384:	80 00       	ld.sh	r0,r0[0x0]
80006386:	6d 74       	ld.w	r4,r6[0x5c]

80006388 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80006388:	eb cd 40 c0 	pushm	r6-r7,lr
8000638c:	1a 97       	mov	r7,sp
8000638e:	20 1d       	sub	sp,4
80006390:	ee c6 ff f4 	sub	r6,r7,-12
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80006394:	49 08       	lddpc	r8,800063d4 <xcmp_rx+0x4c>
80006396:	70 08       	ld.w	r8,r8[0x0]
80006398:	10 9c       	mov	r12,r8
8000639a:	f0 1f 00 10 	mcall	800063d8 <xcmp_rx+0x50>
8000639e:	18 98       	mov	r8,r12
800063a0:	ef 48 ff fc 	st.w	r7[-4],r8
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
800063a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063a8:	58 08       	cp.w	r8,0
800063aa:	c1 20       	breq	800063ce <xcmp_rx+0x46>
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
800063ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800063b0:	e0 6a 00 ca 	mov	r10,202
800063b4:	0c 9b       	mov	r11,r6
800063b6:	10 9c       	mov	r12,r8
800063b8:	f0 1f 00 09 	mcall	800063dc <xcmp_rx+0x54>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
800063bc:	48 98       	lddpc	r8,800063e0 <xcmp_rx+0x58>
800063be:	70 08       	ld.w	r8,r8[0x0]
800063c0:	ee cb 00 04 	sub	r11,r7,4
800063c4:	30 09       	mov	r9,0
800063c6:	30 0a       	mov	r10,0
800063c8:	10 9c       	mov	r12,r8
800063ca:	f0 1f 00 07 	mcall	800063e4 <xcmp_rx+0x5c>
	}	
}
800063ce:	2f fd       	sub	sp,-4
800063d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063d4:	00 00       	add	r0,r0
800063d6:	0a 88       	andn	r8,r5
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	5f 4c       	srge	r12
800063dc:	80 00       	ld.sh	r0,r0[0x0]
800063de:	b0 72       	st.h	r8[0xe],r2
800063e0:	00 00       	add	r0,r0
800063e2:	0b 04       	ld.w	r4,r5++
800063e4:	80 00       	ld.sh	r0,r0[0x0]
800063e6:	8a 54       	ld.sh	r4,r5[0xa]

800063e8 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800063e8:	eb cd 40 80 	pushm	r7,lr
800063ec:	1a 97       	mov	r7,sp
800063ee:	20 2d       	sub	sp,8
800063f0:	ef 4c ff fc 	st.w	r7[-4],r12
800063f4:	ef 4b ff f8 	st.w	r7[-8],r11
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800063f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800063fc:	90 08       	ld.sh	r8,r8[0x0]
800063fe:	5c 78       	castu.h	r8
80006400:	e2 18 f0 00 	andl	r8,0xf000,COH
80006404:	e0 48 80 00 	cp.w	r8,32768
80006408:	c1 50       	breq	80006432 <xcmp_exec_func+0x4a>
8000640a:	e0 48 b0 00 	cp.w	r8,45056
8000640e:	c1 e0       	breq	8000644a <xcmp_exec_func+0x62>
80006410:	58 08       	cp.w	r8,0
80006412:	c2 91       	brne	80006464 <xcmp_exec_func+0x7c>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80006414:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006418:	70 08       	ld.w	r8,r8[0x0]
8000641a:	58 08       	cp.w	r8,0
8000641c:	c0 80       	breq	8000642c <xcmp_exec_func+0x44>
			{
				exec->xcmp_rx_req(xcmp);
8000641e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006422:	70 08       	ld.w	r8,r8[0x0]
80006424:	ee fc ff f8 	ld.w	r12,r7[-8]
80006428:	5d 18       	icall	r8
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
			}
			break;
8000642a:	c1 d8       	rjmp	80006464 <xcmp_exec_func+0x7c>
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to radio */
				xcmp_opcode_not_supported();
8000642c:	f0 1f 00 10 	mcall	8000646c <xcmp_exec_func+0x84>
			}
			break;
80006430:	c1 a8       	rjmp	80006464 <xcmp_exec_func+0x7c>
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80006432:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006436:	70 18       	ld.w	r8,r8[0x4]
80006438:	58 08       	cp.w	r8,0
8000643a:	c1 40       	breq	80006462 <xcmp_exec_func+0x7a>
			{
				exec->xcmp_rx_reply(xcmp);
8000643c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006440:	70 18       	ld.w	r8,r8[0x4]
80006442:	ee fc ff f8 	ld.w	r12,r7[-8]
80006446:	5d 18       	icall	r8
			}
			break;
80006448:	c0 e8       	rjmp	80006464 <xcmp_exec_func+0x7c>
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000644a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000644e:	70 28       	ld.w	r8,r8[0x8]
80006450:	58 08       	cp.w	r8,0
80006452:	c0 90       	breq	80006464 <xcmp_exec_func+0x7c>
			{
				exec->xcmp_rx_brdcst(xcmp);
80006454:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006458:	70 28       	ld.w	r8,r8[0x8]
8000645a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000645e:	5d 18       	icall	r8
80006460:	c0 28       	rjmp	80006464 <xcmp_exec_func+0x7c>
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
			{
				exec->xcmp_rx_reply(xcmp);
			}
			break;
80006462:	d7 03       	nop
			break;
			
		default:
			break;
	}
}
80006464:	2f ed       	sub	sp,-8
80006466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000646a:	00 00       	add	r0,r0
8000646c:	80 00       	ld.sh	r0,r0[0x0]
8000646e:	66 54       	ld.w	r4,r3[0x14]

80006470 <xcmp_rx_process>:
Calls: xQueueReceive -- freertos
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80006470:	eb cd 40 80 	pushm	r7,lr
80006474:	1a 97       	mov	r7,sp
80006476:	fa cd 00 d4 	sub	sp,sp,212
8000647a:	ef 4c ff 2c 	st.w	r7[-212],r12
8000647e:	c0 28       	rjmp	80006482 <xcmp_rx_process+0x12>
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
		}

	}
80006480:	d7 03       	nop
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//10ms
80006482:	4c 88       	lddpc	r8,800065a0 <xcmp_rx_process+0x130>
80006484:	70 08       	ld.w	r8,r8[0x0]
80006486:	ee cb 00 d0 	sub	r11,r7,208
8000648a:	30 09       	mov	r9,0
8000648c:	31 4a       	mov	r10,20
8000648e:	10 9c       	mov	r12,r8
80006490:	f0 1f 00 45 	mcall	800065a4 <xcmp_rx_process+0x134>
80006494:	18 98       	mov	r8,r12
80006496:	58 18       	cp.w	r8,1
80006498:	cf 41       	brne	80006480 <xcmp_rx_process+0x10>
		{									
			if(NULL == ptr)
8000649a:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000649e:	58 08       	cp.w	r8,0
800064a0:	c0 31       	brne	800064a6 <xcmp_rx_process+0x36>
			{
				continue;
800064a2:	d7 03       	nop
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
		}

	}
800064a4:	ce fb       	rjmp	80006482 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800064a6:	ee f8 ff 30 	ld.w	r8,r7[-208]
800064aa:	90 08       	ld.sh	r8,r8[0x0]
800064ac:	5c 78       	castu.h	r8
800064ae:	f1 d8 c0 0c 	bfextu	r8,r8,0x0,0xc
800064b2:	59 c8       	cp.w	r8,28
800064b4:	c2 70       	breq	80006502 <xcmp_rx_process+0x92>
800064b6:	e0 89 00 07 	brgt	800064c4 <xcmp_rx_process+0x54>
800064ba:	58 e8       	cp.w	r8,14
800064bc:	c0 e0       	breq	800064d8 <xcmp_rx_process+0x68>
800064be:	58 f8       	cp.w	r8,15
800064c0:	c1 30       	breq	800064e6 <xcmp_rx_process+0x76>
800064c2:	c3 58       	rjmp	8000652c <xcmp_rx_process+0xbc>
800064c4:	e0 48 01 09 	cp.w	r8,265
800064c8:	c2 40       	breq	80006510 <xcmp_rx_process+0xa0>
800064ca:	e0 48 01 0a 	cp.w	r8,266
800064ce:	c2 80       	breq	8000651e <xcmp_rx_process+0xae>
800064d0:	e0 48 00 2c 	cp.w	r8,44
800064d4:	c1 00       	breq	800064f4 <xcmp_rx_process+0x84>
800064d6:	c2 b8       	rjmp	8000652c <xcmp_rx_process+0xbc>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
800064d8:	ee f8 ff 30 	ld.w	r8,r7[-208]
800064dc:	10 9b       	mov	r11,r8
800064de:	4b 3c       	lddpc	r12,800065a8 <xcmp_rx_process+0x138>
800064e0:	f0 1f 00 33 	mcall	800065ac <xcmp_rx_process+0x13c>
					break;
800064e4:	c5 58       	rjmp	8000658e <xcmp_rx_process+0x11e>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
800064e6:	ee f8 ff 30 	ld.w	r8,r7[-208]
800064ea:	10 9b       	mov	r11,r8
800064ec:	4b 1c       	lddpc	r12,800065b0 <xcmp_rx_process+0x140>
800064ee:	f0 1f 00 30 	mcall	800065ac <xcmp_rx_process+0x13c>
					break;
800064f2:	c4 e8       	rjmp	8000658e <xcmp_rx_process+0x11e>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800064f4:	ee f8 ff 30 	ld.w	r8,r7[-208]
800064f8:	10 9b       	mov	r11,r8
800064fa:	4a fc       	lddpc	r12,800065b4 <xcmp_rx_process+0x144>
800064fc:	f0 1f 00 2c 	mcall	800065ac <xcmp_rx_process+0x13c>
					break;
80006500:	c4 78       	rjmp	8000658e <xcmp_rx_process+0x11e>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80006502:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006506:	10 9b       	mov	r11,r8
80006508:	4a cc       	lddpc	r12,800065b8 <xcmp_rx_process+0x148>
8000650a:	f0 1f 00 29 	mcall	800065ac <xcmp_rx_process+0x13c>
						, ptr);
					break;
8000650e:	c4 08       	rjmp	8000658e <xcmp_rx_process+0x11e>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80006510:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006514:	10 9b       	mov	r11,r8
80006516:	4a ac       	lddpc	r12,800065bc <xcmp_rx_process+0x14c>
80006518:	f0 1f 00 25 	mcall	800065ac <xcmp_rx_process+0x13c>
					break;
8000651c:	c3 98       	rjmp	8000658e <xcmp_rx_process+0x11e>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000651e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006522:	10 9b       	mov	r11,r8
80006524:	4a 7c       	lddpc	r12,800065c0 <xcmp_rx_process+0x150>
80006526:	f0 1f 00 22 	mcall	800065ac <xcmp_rx_process+0x13c>
					break;
8000652a:	c3 28       	rjmp	8000658e <xcmp_rx_process+0x11e>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000652c:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006530:	90 08       	ld.sh	r8,r8[0x0]
80006532:	5c 78       	castu.h	r8
80006534:	e2 18 04 00 	andl	r8,0x400,COH
80006538:	c0 b0       	breq	8000654e <xcmp_rx_process+0xde>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
8000653a:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000653e:	90 08       	ld.sh	r8,r8[0x0]
80006540:	5c 78       	castu.h	r8
80006542:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80006546:	e0 48 00 68 	cp.w	r8,104
8000654a:	e0 8a 00 0c 	brle	80006562 <xcmp_rx_process+0xf2>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
8000654e:	ee f8 ff 30 	ld.w	r8,r7[-208]
80006552:	90 08       	ld.sh	r8,r8[0x0]
80006554:	5c 78       	castu.h	r8
80006556:	e2 18 f0 00 	andl	r8,0xf000,COH
8000655a:	c1 91       	brne	8000658c <xcmp_rx_process+0x11c>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000655c:	f0 1f 00 1a 	mcall	800065c4 <xcmp_rx_process+0x154>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80006560:	c1 78       	rjmp	8000658e <xcmp_rx_process+0x11e>
							xcmp_opcode_not_supported();
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80006562:	ee fa ff 30 	ld.w	r10,r7[-208]
80006566:	49 98       	lddpc	r8,800065c8 <xcmp_rx_process+0x158>
80006568:	70 0b       	ld.w	r11,r8[0x0]
8000656a:	ee f8 ff 30 	ld.w	r8,r7[-208]
8000656e:	90 08       	ld.sh	r8,r8[0x0]
80006570:	5c 78       	castu.h	r8
80006572:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80006576:	12 98       	mov	r8,r9
80006578:	a1 78       	lsl	r8,0x1
8000657a:	12 08       	add	r8,r9
8000657c:	a3 68       	lsl	r8,0x2
8000657e:	f6 08 00 08 	add	r8,r11,r8
80006582:	14 9b       	mov	r11,r10
80006584:	10 9c       	mov	r12,r8
80006586:	f0 1f 00 0a 	mcall	800065ac <xcmp_rx_process+0x13c>
8000658a:	c0 28       	rjmp	8000658e <xcmp_rx_process+0x11e>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
8000658c:	d7 03       	nop
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
8000658e:	ee f9 ff 30 	ld.w	r9,r7[-208]
80006592:	48 f8       	lddpc	r8,800065cc <xcmp_rx_process+0x15c>
80006594:	70 08       	ld.w	r8,r8[0x0]
80006596:	12 9b       	mov	r11,r9
80006598:	10 9c       	mov	r12,r8
8000659a:	f0 1f 00 0e 	mcall	800065d0 <xcmp_rx_process+0x160>
		}

	}
8000659e:	c7 2b       	rjmp	80006482 <xcmp_rx_process+0x12>
800065a0:	00 00       	add	r0,r0
800065a2:	0b 04       	ld.w	r4,r5++
800065a4:	80 00       	ld.sh	r0,r0[0x0]
800065a6:	8c 60       	ld.sh	r0,r6[0xc]
800065a8:	00 00       	add	r0,r0
800065aa:	0b 08       	ld.w	r8,r5++
800065ac:	80 00       	ld.sh	r0,r0[0x0]
800065ae:	63 e8       	ld.w	r8,r1[0x78]
800065b0:	00 00       	add	r0,r0
800065b2:	0b 14       	ld.sh	r4,r5++
800065b4:	00 00       	add	r0,r0
800065b6:	0b 20       	ld.uh	r0,r5++
800065b8:	00 00       	add	r0,r0
800065ba:	0b 2c       	ld.uh	r12,r5++
800065bc:	00 00       	add	r0,r0
800065be:	0b 38       	ld.ub	r8,r5++
800065c0:	00 00       	add	r0,r0
800065c2:	0b 44       	ld.w	r4,--r5
800065c4:	80 00       	ld.sh	r0,r0[0x0]
800065c6:	66 54       	ld.w	r4,r3[0x14]
800065c8:	00 00       	add	r0,r0
800065ca:	53 14       	stdsp	sp[0xc4],r4
800065cc:	00 00       	add	r0,r0
800065ce:	0a 88       	andn	r8,r5
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	5f d4       	srvc	r4

800065d4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800065d4:	eb cd 40 80 	pushm	r7,lr
800065d8:	1a 97       	mov	r7,sp
	/*initialize the xnl*/
	xnl_init();
800065da:	f0 1f 00 0f 	mcall	80006614 <xcmp_init+0x40>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800065de:	48 fc       	lddpc	r12,80006618 <xcmp_init+0x44>
800065e0:	f0 1f 00 0f 	mcall	8000661c <xcmp_init+0x48>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800065e4:	30 4b       	mov	r11,4
800065e6:	31 4c       	mov	r12,20
800065e8:	f0 1f 00 0e 	mcall	80006620 <xcmp_init+0x4c>
800065ec:	18 99       	mov	r9,r12
800065ee:	48 e8       	lddpc	r8,80006624 <xcmp_init+0x50>
800065f0:	91 09       	st.w	r8[0x0],r9
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800065f2:	48 eb       	lddpc	r11,80006628 <xcmp_init+0x54>
800065f4:	30 08       	mov	r8,0
800065f6:	1a d8       	st.w	--sp,r8
800065f8:	30 08       	mov	r8,0
800065fa:	1a d8       	st.w	--sp,r8
800065fc:	30 08       	mov	r8,0
800065fe:	1a d8       	st.w	--sp,r8
80006600:	30 38       	mov	r8,3
80006602:	30 09       	mov	r9,0
80006604:	e0 6a 01 80 	mov	r10,384
80006608:	48 9c       	lddpc	r12,8000662c <xcmp_init+0x58>
8000660a:	f0 1f 00 0a 	mcall	80006630 <xcmp_init+0x5c>
8000660e:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
80006610:	e3 cd 80 80 	ldm	sp++,r7,pc
80006614:	80 00       	ld.sh	r0,r0[0x0]
80006616:	70 60       	ld.w	r0,r8[0x18]
80006618:	80 00       	ld.sh	r0,r0[0x0]
8000661a:	63 88       	ld.w	r8,r1[0x60]
8000661c:	80 00       	ld.sh	r0,r0[0x0]
8000661e:	6d 54       	ld.w	r4,r6[0x54]
80006620:	80 00       	ld.sh	r0,r0[0x0]
80006622:	89 3c       	st.w	r4[0xc],r12
80006624:	00 00       	add	r0,r0
80006626:	0b 04       	ld.w	r4,r5++
80006628:	80 00       	ld.sh	r0,r0[0x0]
8000662a:	62 f4       	ld.w	r4,r1[0x3c]
8000662c:	80 00       	ld.sh	r0,r0[0x0]
8000662e:	64 70       	ld.w	r0,r2[0x1c]
80006630:	80 00       	ld.sh	r0,r0[0x0]
80006632:	91 ac       	st.w	r8[0x28],r12

80006634 <xcmp_register_app_list>:
Description: register the app list
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
80006634:	eb cd 40 80 	pushm	r7,lr
80006638:	1a 97       	mov	r7,sp
8000663a:	20 1d       	sub	sp,4
8000663c:	ef 4c ff fc 	st.w	r7[-4],r12
	app_list = (app_exec_t *)list;
80006640:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006644:	48 38       	lddpc	r8,80006650 <xcmp_register_app_list+0x1c>
80006646:	91 09       	st.w	r8[0x0],r9
}
80006648:	2f fd       	sub	sp,-4
8000664a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000664e:	00 00       	add	r0,r0
80006650:	00 00       	add	r0,r0
80006652:	53 14       	stdsp	sp[0xc4],r4

80006654 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80006654:	eb cd 40 80 	pushm	r7,lr
80006658:	1a 97       	mov	r7,sp
8000665a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
8000665e:	fe 78 80 00 	mov	r8,-32768
80006662:	ef 58 ff 36 	st.h	r7[-202],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80006666:	30 38       	mov	r8,3
80006668:	ef 68 ff 38 	st.b	r7[-200],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000666c:	ee c8 00 ca 	sub	r8,r7,202
80006670:	30 1b       	mov	r11,1
80006672:	10 9c       	mov	r12,r8
80006674:	f0 1f 00 03 	mcall	80006680 <xcmp_opcode_not_supported+0x2c>
}
80006678:	2c dd       	sub	sp,-204
8000667a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000667e:	00 00       	add	r0,r0
80006680:	80 00       	ld.sh	r0,r0[0x0]
80006682:	62 fc       	ld.w	r12,r1[0x3c]

80006684 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80006684:	eb cd 40 80 	pushm	r7,lr
80006688:	1a 97       	mov	r7,sp
8000668a:	fa cd 00 d0 	sub	sp,sp,208
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
8000668e:	fe 78 b4 00 	mov	r8,-19456
80006692:	ef 58 ff 32 	st.h	r7[-206],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80006696:	ee c8 00 ce 	sub	r8,r7,206
8000669a:	2f e8       	sub	r8,-2
8000669c:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/*xcmp version 8.1.0.5*///
	ptr->XCMPVersion[0] = 0x08;
800066a0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066a4:	30 88       	mov	r8,8
800066a6:	b2 88       	st.b	r9[0x0],r8
	ptr->XCMPVersion[1] = 0x01;
800066a8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066ac:	30 18       	mov	r8,1
800066ae:	b2 98       	st.b	r9[0x1],r8
	ptr->XCMPVersion[2] = 0x00;
800066b0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066b4:	30 08       	mov	r8,0
800066b6:	b2 a8       	st.b	r9[0x2],r8
	ptr->XCMPVersion[3] = 0x05;
800066b8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066bc:	30 58       	mov	r8,5
800066be:	b2 b8       	st.b	r9[0x3],r8
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800066c0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066c4:	30 08       	mov	r8,0
800066c6:	b2 c8       	st.b	r9[0x4],r8
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800066c8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066cc:	30 78       	mov	r8,7
800066ce:	b2 d8       	st.b	r9[0x5],r8
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800066d0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066d4:	30 08       	mov	r8,0
800066d6:	b2 e8       	st.b	r9[0x6],r8
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800066d8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066dc:	30 08       	mov	r8,0
800066de:	b2 f8       	st.b	r9[0x7],r8
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800066e0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066e4:	30 08       	mov	r8,0
800066e6:	f3 68 00 08 	st.b	r9[8],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800066ea:	ee c8 00 ce 	sub	r8,r7,206
800066ee:	30 9b       	mov	r11,9
800066f0:	10 9c       	mov	r12,r8
800066f2:	f0 1f 00 03 	mcall	800066fc <xcmp_DeviceInitializationStatus_request+0x78>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800066f6:	2c cd       	sub	sp,-208
800066f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800066fc:	80 00       	ld.sh	r0,r0[0x0]
800066fe:	62 fc       	ld.w	r12,r1[0x3c]

80006700 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80006700:	eb cd 40 80 	pushm	r7,lr
80006704:	1a 97       	mov	r7,sp
80006706:	fa cd 00 d0 	sub	sp,sp,208
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000670a:	e0 68 04 09 	mov	r8,1033
8000670e:	ef 58 ff 32 	st.h	r7[-206],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80006712:	ee c8 00 ce 	sub	r8,r7,206
80006716:	2f e8       	sub	r8,-2
80006718:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
8000671c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006720:	30 18       	mov	r8,1
80006722:	b2 88       	st.b	r9[0x0],r8
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80006724:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006728:	30 08       	mov	r8,0
8000672a:	b2 98       	st.b	r9[0x1],r8
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
8000672c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006730:	30 c8       	mov	r8,12
80006732:	b2 a8       	st.b	r9[0x2],r8
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80006734:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006738:	30 08       	mov	r8,0
8000673a:	b2 b8       	st.b	r9[0x3],r8
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000673c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006740:	2f c8       	sub	r8,-4
80006742:	30 8a       	mov	r10,8
80006744:	30 0b       	mov	r11,0
80006746:	10 9c       	mov	r12,r8
80006748:	f0 1f 00 06 	mcall	80006760 <xcmp_IdleTestTone+0x60>
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
8000674c:	ee c8 00 ce 	sub	r8,r7,206
80006750:	30 cb       	mov	r11,12
80006752:	10 9c       	mov	r12,r8
80006754:	f0 1f 00 04 	mcall	80006764 <xcmp_IdleTestTone+0x64>
}
80006758:	2c cd       	sub	sp,-208
8000675a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000675e:	00 00       	add	r0,r0
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	b1 ba       	sbr	r10,0x11
80006764:	80 00       	ld.sh	r0,r0[0x0]
80006766:	62 fc       	ld.w	r12,r1[0x3c]

80006768 <xcmp_data_session>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session(void)
{
80006768:	eb cd 40 80 	pushm	r7,lr
8000676c:	1a 97       	mov	r7,sp
8000676e:	fa cd 00 d0 	sub	sp,sp,208
	//U8 *DMR_Raw_Data= &DataPayload[0];
	U8 i =0;
80006772:	30 08       	mov	r8,0
80006774:	ef 68 ff fb 	st.b	r7[-5],r8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_DATA_REQUEST;
80006778:	e0 68 04 1d 	mov	r8,1053
8000677c:	ef 58 ff 30 	st.h	r7[-208],r8
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80006780:	ee c8 00 d0 	sub	r8,r7,208
80006784:	2f e8       	sub	r8,-2
80006786:	ef 48 ff fc 	st.w	r7[-4],r8
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//ID:2
	//
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
	//ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
	
	ptr->Function = Single_Data_Uint;//0x01
8000678a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000678e:	30 18       	mov	r8,1
80006790:	b2 88       	st.b	r9[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = DMR_CSBK_Data;//0x70
80006792:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006796:	37 08       	mov	r8,112
80006798:	b2 98       	st.b	r9[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_Mototrbo_Address;//0x01
8000679a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000679e:	30 18       	mov	r8,1
800067a0:	b2 a8       	st.b	r9[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_Mototrbo_Address_Size;//0x03
800067a2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067a6:	30 38       	mov	r8,3
800067a8:	b2 b8       	st.b	r9[0x3],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x00;
800067aa:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067ae:	30 08       	mov	r8,0
800067b0:	b2 c8       	st.b	r9[0x4],r8
	ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;
800067b2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067b6:	30 08       	mov	r8,0
800067b8:	b2 d8       	st.b	r9[0x5],r8
	ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x02;//ID:2
800067ba:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067be:	30 28       	mov	r8,2
800067c0:	b2 e8       	st.b	r9[0x6],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//0x00
800067c2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067c6:	34 08       	mov	r8,64
800067c8:	b2 f8       	st.b	r9[0x7],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//0x00
800067ca:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067ce:	36 18       	mov	r8,97
800067d0:	f3 68 00 08 	st.b	r9[8],r8
	    ////
    ////}
	//
	
	//
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800067d4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067d8:	30 08       	mov	r8,0
800067da:	f3 68 00 09 	st.b	r9[9],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//
800067de:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067e2:	30 08       	mov	r8,0
800067e4:	f3 68 00 0a 	st.b	r9[10],r8
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//
800067e8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067ec:	31 48       	mov	r8,20
800067ee:	f3 68 00 0b 	st.b	r9[11],r8
	
	for (i=0; i< sizeof(DataPayload) ; i++)
800067f2:	30 08       	mov	r8,0
800067f4:	ef 68 ff fb 	st.b	r7[-5],r8
800067f8:	c1 38       	rjmp	8000681e <xcmp_data_session+0xb6>
	{
	
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//
800067fa:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800067fe:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80006802:	49 0a       	lddpc	r10,80006840 <xcmp_data_session+0xd8>
80006804:	f4 08 07 08 	ld.ub	r8,r10[r8]
80006808:	ee fa ff fc 	ld.w	r10,r7[-4]
8000680c:	f4 09 00 09 	add	r9,r10,r9
80006810:	f3 68 00 0c 	st.b	r9[12],r8
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
	
	ptr->DataPayload.DataPayload_Length[0] =(sizeof(DataPayload) >> 8) & 0xFF ;//
	ptr->DataPayload.DataPayload_Length[1] =sizeof(DataPayload) & 0xFF  ;//
	
	for (i=0; i< sizeof(DataPayload) ; i++)
80006814:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80006818:	2f f8       	sub	r8,-1
8000681a:	ef 68 ff fb 	st.b	r7[-5],r8
8000681e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80006822:	31 38       	mov	r8,19
80006824:	f0 09 18 00 	cp.b	r9,r8
80006828:	fe 98 ff e9 	brls	800067fa <xcmp_data_session+0x92>
		ptr->DataPayload.DataPayload[i] = DataPayload[i];//
		
	}
	
	/*send xcmp frame*///
	xcmp_tx( &xcmp_farme, sizeof(DataSession_req_t));
8000682c:	ee c8 00 d0 	sub	r8,r7,208
80006830:	32 0b       	mov	r11,32
80006832:	10 9c       	mov	r12,r8
80006834:	f0 1f 00 04 	mcall	80006844 <xcmp_data_session+0xdc>
}
80006838:	2c cd       	sub	sp,-208
8000683a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000683e:	00 00       	add	r0,r0
80006840:	00 00       	add	r0,r0
80006842:	05 00       	ld.w	r0,r2++
80006844:	80 00       	ld.sh	r0,r0[0x0]
80006846:	62 fc       	ld.w	r12,r1[0x3c]
80006848:	63 6f       	ld.w	pc,r1[0x58]
8000684a:	6e 6e       	ld.w	lr,r7[0x18]
8000684c:	65 63       	ld.w	r3,r2[0x58]
8000684e:	74 65       	ld.w	r5,r10[0x18]
80006850:	64 20       	ld.w	r0,r2[0x8]
80006852:	66 69       	ld.w	r9,r3[0x18]
80006854:	6e 69       	ld.w	r9,r7[0x18]
80006856:	73 68       	ld.w	r8,r9[0x58]
80006858:	00 00       	add	r0,r0
8000685a:	00 00       	add	r0,r0
8000685c:	58 4e       	cp.w	lr,4
8000685e:	4c 5f       	lddpc	pc,80006970 <check_sum+0x58>
80006860:	52 58       	stdsp	sp[0x94],r8
80006862:	00 00       	add	r0,r0
80006864:	58 4e       	cp.w	lr,4
80006866:	4c 5f       	lddpc	pc,80006978 <check_sum+0x60>
80006868:	54 58       	stdsp	sp[0x114],r8
	...

8000686c <encipher>:
Calls:   
Called By: xnl_device_auth_reply_func
Output: U32 *const w
*/
static void encipher(U32 *const v, U32 *const w, const U32 *const k)
{
8000686c:	eb cd 40 ef 	pushm	r0-r3,r5-r7,lr
80006870:	1a 97       	mov	r7,sp
80006872:	20 4d       	sub	sp,16
80006874:	ef 4c ff fc 	st.w	r7[-4],r12
80006878:	ef 4b ff f8 	st.w	r7[-8],r11
8000687c:	ef 4a ff f4 	st.w	r7[-12],r10
	register U32 y=v[0], z=v[1], sum=0;
80006880:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006884:	70 06       	ld.w	r6,r8[0x0]
80006886:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000688a:	2f c8       	sub	r8,-4
8000688c:	70 0e       	ld.w	lr,r8[0x0]
8000688e:	30 05       	mov	r5,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
80006890:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006894:	70 08       	ld.w	r8,r8[0x0]
80006896:	ef 48 ff f0 	st.w	r7[-16],r8
8000689a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000689e:	2f c8       	sub	r8,-4
800068a0:	70 00       	ld.w	r0,r8[0x0]
800068a2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800068a6:	2f 88       	sub	r8,-8
800068a8:	70 01       	ld.w	r1,r8[0x0]
800068aa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800068ae:	2f 48       	sub	r8,-12
800068b0:	70 02       	ld.w	r2,r8[0x0]
	register U32 n=32;
800068b2:	32 03       	mov	r3,32

	while(n-->0)
800068b4:	c2 08       	rjmp	800068f4 <encipher+0x88>
	{
		sum += authDelta;		
800068b6:	49 88       	lddpc	r8,80006914 <encipher+0xa8>
800068b8:	70 08       	ld.w	r8,r8[0x0]
800068ba:	10 05       	add	r5,r8
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800068bc:	fc 08 15 04 	lsl	r8,lr,0x4
800068c0:	ee fa ff f0 	ld.w	r10,r7[-16]
800068c4:	f0 0a 00 09 	add	r9,r8,r10
800068c8:	fc 05 00 08 	add	r8,lr,r5
800068cc:	10 59       	eor	r9,r8
800068ce:	fc 08 16 05 	lsr	r8,lr,0x5
800068d2:	00 08       	add	r8,r0
800068d4:	f3 e8 20 08 	eor	r8,r9,r8
800068d8:	10 06       	add	r6,r8
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800068da:	ec 08 15 04 	lsl	r8,r6,0x4
800068de:	f0 01 00 09 	add	r9,r8,r1
800068e2:	ec 05 00 08 	add	r8,r6,r5
800068e6:	10 59       	eor	r9,r8
800068e8:	ec 08 16 05 	lsr	r8,r6,0x5
800068ec:	04 08       	add	r8,r2
800068ee:	f3 e8 20 08 	eor	r8,r9,r8
800068f2:	10 0e       	add	lr,r8
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
800068f4:	58 03       	cp.w	r3,0
800068f6:	5f 18       	srne	r8
800068f8:	5c 58       	castu.b	r8
800068fa:	20 13       	sub	r3,1
800068fc:	58 08       	cp.w	r8,0
800068fe:	cd c1       	brne	800068b6 <encipher+0x4a>
		sum += authDelta;		
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
	}

	w[0]=y; w[1]=z;
80006900:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006904:	91 06       	st.w	r8[0x0],r6
80006906:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000690a:	2f c8       	sub	r8,-4
8000690c:	91 0e       	st.w	r8[0x0],lr
}
8000690e:	2f cd       	sub	sp,-16
80006910:	e3 cd 80 ef 	ldm	sp++,r0-r3,r5-r7,pc
80006914:	80 01       	ld.sh	r1,r0[0x0]
80006916:	08 b0       	st.h	r4++,r0

80006918 <check_sum>:
Calls:   
Called By: xnl_tx
Return:U16
*/
static U16 check_sum (xnl_fragment_t * xnl)
{
80006918:	eb cd 40 80 	pushm	r7,lr
8000691c:	1a 97       	mov	r7,sp
8000691e:	20 4d       	sub	sp,16
80006920:	ef 4c ff f0 	st.w	r7[-16],r12
	*/	
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
80006924:	30 08       	mov	r8,0
80006926:	ef 58 ff f6 	st.h	r7[-10],r8
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000692a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000692e:	90 08       	ld.sh	r8,r8[0x0]
80006930:	5c 78       	castu.h	r8
80006932:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80006936:	20 28       	sub	r8,2
80006938:	ef 48 ff fc 	st.w	r7[-4],r8
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000693c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006940:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80006944:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006948:	f2 08 00 08 	add	r8,r9,r8
8000694c:	a1 58       	asr	r8,0x1
8000694e:	ef 48 ff fc 	st.w	r7[-4],r8
	indextohWord = 2;
80006952:	30 28       	mov	r8,2
80006954:	ef 48 ff f8 	st.w	r7[-8],r8
	while (hWordswithinFrag > 0)
80006958:	c1 98       	rjmp	8000698a <check_sum+0x72>
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000695a:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000695e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006962:	a1 78       	lsl	r8,0x1
80006964:	f2 08 00 08 	add	r8,r9,r8
80006968:	90 08       	ld.sh	r8,r8[0x0]
8000696a:	ef 09 ff f6 	ld.sh	r9,r7[-10]
8000696e:	f2 08 00 08 	add	r8,r9,r8
80006972:	ef 58 ff f6 	st.h	r7[-10],r8
		indextohWord     += 1;
80006976:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000697a:	2f f8       	sub	r8,-1
8000697c:	ef 48 ff f8 	st.w	r7[-8],r8
		hWordswithinFrag -= 1;
80006980:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006984:	20 18       	sub	r8,1
80006986:	ef 48 ff fc 	st.w	r7[-4],r8
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
8000698a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000698e:	58 08       	cp.w	r8,0
80006990:	fe 99 ff e5 	brgt	8000695a <check_sum+0x42>
		sumScratch += *((U16*)xnl + indextohWord);
		indextohWord     += 1;
		hWordswithinFrag -= 1;
	}
	
	return -sumScratch;
80006994:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80006998:	5c 38       	neg	r8
8000699a:	5c 88       	casts.h	r8
}
8000699c:	10 9c       	mov	r12,r8
8000699e:	2f cd       	sub	sp,-16
800069a0:	e3 cd 80 80 	ldm	sp++,r7,pc

800069a4 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
static void xnl_send_device_master_query(void)
{
800069a4:	eb cd 40 80 	pushm	r7,lr
800069a8:	1a 97       	mov	r7,sp
800069aa:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800069ae:	e0 68 40 0e 	mov	r8,16398
800069b2:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800069b6:	3f f8       	mov	r8,-1
800069b8:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800069bc:	30 38       	mov	r8,3
800069be:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
800069c2:	30 08       	mov	r8,0
800069c4:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
800069c8:	30 08       	mov	r8,0
800069ca:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
800069ce:	30 08       	mov	r8,0
800069d0:	ef 58 ff 0a 	st.h	r7[-246],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
800069d4:	30 08       	mov	r8,0
800069d6:	ef 58 ff 0c 	st.h	r7[-244],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
800069da:	30 08       	mov	r8,0
800069dc:	ef 58 ff 0e 	st.h	r7[-242],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800069e0:	ee c8 01 00 	sub	r8,r7,256
800069e4:	10 9c       	mov	r12,r8
800069e6:	f0 1f 00 03 	mcall	800069f0 <xnl_send_device_master_query+0x4c>
}
800069ea:	2c 0d       	sub	sp,-256
800069ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800069f0:	80 00       	ld.sh	r0,r0[0x0]
800069f2:	6d 74       	ld.w	r4,r6[0x5c]

800069f4 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800069f4:	eb cd 40 80 	pushm	r7,lr
800069f8:	1a 97       	mov	r7,sp
800069fa:	fa cd 01 04 	sub	sp,sp,260
800069fe:	ef 4c fe fc 	st.w	r7[-260],r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80006a02:	49 c8       	lddpc	r8,80006a70 <xnl_master_status_brdcst_func+0x7c>
80006a04:	11 88       	ld.ub	r8,r8[0x0]
80006a06:	5c 58       	castu.b	r8
80006a08:	c2 f1       	brne	80006a66 <xnl_master_status_brdcst_func+0x72>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80006a0a:	49 b8       	lddpc	r8,80006a74 <xnl_master_status_brdcst_func+0x80>
80006a0c:	70 08       	ld.w	r8,r8[0x0]
80006a0e:	30 09       	mov	r9,0
80006a10:	30 0a       	mov	r10,0
80006a12:	30 0b       	mov	r11,0
80006a14:	10 9c       	mov	r12,r8
80006a16:	f0 1f 00 19 	mcall	80006a78 <xnl_master_status_brdcst_func+0x84>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80006a1a:	ee f8 fe fc 	ld.w	r8,r7[-260]
80006a1e:	90 58       	ld.sh	r8,r8[0xa]
80006a20:	49 49       	lddpc	r9,80006a70 <xnl_master_status_brdcst_func+0x7c>
80006a22:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80006a24:	e0 68 40 0e 	mov	r8,16398
80006a28:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80006a2c:	3f f8       	mov	r8,-1
80006a2e:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80006a32:	30 48       	mov	r8,4
80006a34:	ef 58 ff 04 	st.h	r7[-252],r8
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80006a38:	3f f8       	mov	r8,-1
80006a3a:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80006a3e:	48 d8       	lddpc	r8,80006a70 <xnl_master_status_brdcst_func+0x7c>
80006a40:	90 18       	ld.sh	r8,r8[0x2]
80006a42:	5c 88       	casts.h	r8
80006a44:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80006a48:	3f f8       	mov	r8,-1
80006a4a:	ef 58 ff 0a 	st.h	r7[-246],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80006a4e:	3f f8       	mov	r8,-1
80006a50:	ef 58 ff 0c 	st.h	r7[-244],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80006a54:	30 08       	mov	r8,0
80006a56:	ef 58 ff 0e 	st.h	r7[-242],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80006a5a:	ee c8 01 00 	sub	r8,r7,256
80006a5e:	10 9c       	mov	r12,r8
80006a60:	f0 1f 00 07 	mcall	80006a7c <xnl_master_status_brdcst_func+0x88>
80006a64:	c0 28       	rjmp	80006a68 <xnl_master_status_brdcst_func+0x74>
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
	{
		return;	
80006a66:	d7 03       	nop
		
	xnl_frame.xnl_header.payload_length = 0;
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
}
80006a68:	2b fd       	sub	sp,-260
80006a6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a6e:	00 00       	add	r0,r0
80006a70:	00 00       	add	r0,r0
80006a72:	0b 50       	ld.sh	r0,--r5
80006a74:	00 00       	add	r0,r0
80006a76:	0b 64       	ld.uh	r4,--r5
80006a78:	80 00       	ld.sh	r0,r0[0x0]
80006a7a:	8a 54       	ld.sh	r4,r5[0xa]
80006a7c:	80 00       	ld.sh	r0,r0[0x0]
80006a7e:	6d 74       	ld.w	r4,r6[0x5c]

80006a80 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80006a80:	eb cd 40 80 	pushm	r7,lr
80006a84:	1a 97       	mov	r7,sp
80006a86:	fa cd 01 14 	sub	sp,sp,276
80006a8a:	ef 4c fe ec 	st.w	r7[-276],r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80006a8e:	4c 78       	lddpc	r8,80006ba8 <xnl_device_auth_reply_func+0x128>
80006a90:	11 88       	ld.ub	r8,r8[0x0]
80006a92:	5c 58       	castu.b	r8
80006a94:	e0 81 00 86 	brne	80006ba0 <xnl_device_auth_reply_func+0x120>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80006a98:	4c 58       	lddpc	r8,80006bac <xnl_device_auth_reply_func+0x12c>
80006a9a:	70 08       	ld.w	r8,r8[0x0]
80006a9c:	30 09       	mov	r9,0
80006a9e:	30 0a       	mov	r10,0
80006aa0:	30 0b       	mov	r11,0
80006aa2:	10 9c       	mov	r12,r8
80006aa4:	f0 1f 00 43 	mcall	80006bb0 <xnl_device_auth_reply_func+0x130>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80006aa8:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006aac:	f1 08 00 10 	ld.sh	r8,r8[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80006ab0:	4b e9       	lddpc	r9,80006ba8 <xnl_device_auth_reply_func+0x128>
80006ab2:	b2 28       	st.h	r9[0x4],r8
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006ab4:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006ab8:	f1 38 00 12 	ld.ub	r8,r8[18]
	  .unencrypted_authentication_value[0])<<24	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006abc:	f0 09 15 18 	lsl	r9,r8,0x18
80006ac0:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006ac4:	f1 38 00 13 	ld.ub	r8,r8[19]
	  .unencrypted_authentication_value[1])<<16	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006ac8:	b1 68       	lsl	r8,0x10
80006aca:	10 49       	or	r9,r8
80006acc:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006ad0:	f1 38 00 14 	ld.ub	r8,r8[20]
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006ad4:	a9 68       	lsl	r8,0x8
80006ad6:	10 49       	or	r9,r8
80006ad8:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006adc:	f1 38 00 15 	ld.ub	r8,r8[21]
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006ae0:	f3 e8 10 08 	or	r8,r9,r8
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80006ae4:	ef 48 ff f8 	st.w	r7[-8],r8
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006ae8:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006aec:	f1 38 00 16 	ld.ub	r8,r8[22]
	  .unencrypted_authentication_value[4])<<24
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006af0:	f0 09 15 18 	lsl	r9,r8,0x18
80006af4:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006af8:	f1 38 00 17 	ld.ub	r8,r8[23]
	   .unencrypted_authentication_value[5])<<16
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006afc:	b1 68       	lsl	r8,0x10
80006afe:	10 49       	or	r9,r8
80006b00:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006b04:	f1 38 00 18 	ld.ub	r8,r8[24]
	   .unencrypted_authentication_value[6])<<8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006b08:	a9 68       	lsl	r8,0x8
80006b0a:	10 49       	or	r9,r8
80006b0c:	ee f8 fe ec 	ld.w	r8,r7[-276]
80006b10:	f1 38 00 19 	ld.ub	r8,r8[25]
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
	  (xnl->xnl_payload.xnl_content_device_auth_key_reply
80006b14:	f3 e8 10 08 	or	r8,r9,r8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80006b18:	ef 48 ff fc 	st.w	r7[-4],r8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	   .unencrypted_authentication_value[6])<<8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	   .unencrypted_authentication_value[7]);
	
	encipher(&v_vector[0], &w_vector[0], &authKey[0]);
80006b1c:	ee c9 00 10 	sub	r9,r7,16
80006b20:	ee c8 00 08 	sub	r8,r7,8
80006b24:	4a 4a       	lddpc	r10,80006bb4 <xnl_device_auth_reply_func+0x134>
80006b26:	12 9b       	mov	r11,r9
80006b28:	10 9c       	mov	r12,r8
80006b2a:	f0 1f 00 24 	mcall	80006bb8 <xnl_device_auth_reply_func+0x138>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80006b2e:	e0 68 40 1a 	mov	r8,16410
80006b32:	ef 58 fe f0 	st.h	r7[-272],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80006b36:	3f f8       	mov	r8,-1
80006b38:	ef 58 fe f2 	st.h	r7[-270],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80006b3c:	30 68       	mov	r8,6
80006b3e:	ef 58 fe f4 	st.h	r7[-268],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80006b42:	3f f8       	mov	r8,-1
80006b44:	ef 58 fe f6 	st.h	r7[-266],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80006b48:	49 88       	lddpc	r8,80006ba8 <xnl_device_auth_reply_func+0x128>
80006b4a:	90 18       	ld.sh	r8,r8[0x2]
80006b4c:	5c 88       	casts.h	r8
80006b4e:	ef 58 fe f8 	st.h	r7[-264],r8
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80006b52:	49 68       	lddpc	r8,80006ba8 <xnl_device_auth_reply_func+0x128>
80006b54:	90 28       	ld.sh	r8,r8[0x4]
80006b56:	5c 88       	casts.h	r8
80006b58:	ef 58 fe fa 	st.h	r7[-262],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80006b5c:	3f f8       	mov	r8,-1
80006b5e:	ef 58 fe fc 	st.h	r7[-260],r8
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80006b62:	30 c8       	mov	r8,12
80006b64:	ef 58 fe fe 	st.h	r7[-258],r8
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80006b68:	30 08       	mov	r8,0
80006b6a:	ef 58 ff 00 	st.h	r7[-256],r8
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80006b6e:	30 78       	mov	r8,7
80006b70:	ef 68 ff 02 	st.b	r7[-254],r8
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80006b74:	30 28       	mov	r8,2
80006b76:	ef 68 ff 03 	st.b	r7[-253],r8
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80006b7a:	ee c8 01 10 	sub	r8,r7,272
80006b7e:	2e c8       	sub	r8,-20
	                         .encrypted_authentication_value[0])) = w_vector[0];
80006b80:	ee f9 ff f0 	ld.w	r9,r7[-16]
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80006b84:	91 09       	st.w	r8[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80006b86:	ee c8 01 10 	sub	r8,r7,272
80006b8a:	2e c8       	sub	r8,-20
80006b8c:	2f c8       	sub	r8,-4
	                         .encrypted_authentication_value[4])) = w_vector[1];
80006b8e:	ee f9 ff f4 	ld.w	r9,r7[-12]
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80006b92:	91 09       	st.w	r8[0x0],r9
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80006b94:	ee c8 01 10 	sub	r8,r7,272
80006b98:	10 9c       	mov	r12,r8
80006b9a:	f0 1f 00 09 	mcall	80006bbc <xnl_device_auth_reply_func+0x13c>
80006b9e:	c0 28       	rjmp	80006ba2 <xnl_device_auth_reply_func+0x122>
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
	{
		return;		
80006ba0:	d7 03       	nop
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
}
80006ba2:	2b bd       	sub	sp,-276
80006ba4:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ba8:	00 00       	add	r0,r0
80006baa:	0b 50       	ld.sh	r0,--r5
80006bac:	00 00       	add	r0,r0
80006bae:	0b 64       	ld.uh	r4,--r5
80006bb0:	80 00       	ld.sh	r0,r0[0x0]
80006bb2:	8a 54       	ld.sh	r4,r5[0xa]
80006bb4:	80 01       	ld.sh	r1,r0[0x0]
80006bb6:	08 a0       	st.w	r4++,r0
80006bb8:	80 00       	ld.sh	r0,r0[0x0]
80006bba:	68 6c       	ld.w	r12,r4[0x18]
80006bbc:	80 00       	ld.sh	r0,r0[0x0]
80006bbe:	6d 74       	ld.w	r4,r6[0x5c]

80006bc0 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80006bc0:	eb cd 40 80 	pushm	r7,lr
80006bc4:	1a 97       	mov	r7,sp
80006bc6:	20 1d       	sub	sp,4
80006bc8:	ef 4c ff fc 	st.w	r7[-4],r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80006bcc:	49 b8       	lddpc	r8,80006c38 <xnl_device_conn_reply_func+0x78>
80006bce:	70 08       	ld.w	r8,r8[0x0]
80006bd0:	30 09       	mov	r9,0
80006bd2:	30 0a       	mov	r10,0
80006bd4:	30 0b       	mov	r11,0
80006bd6:	10 9c       	mov	r12,r8
80006bd8:	f0 1f 00 19 	mcall	80006c3c <xnl_device_conn_reply_func+0x7c>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80006bdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006be0:	f1 08 00 10 	ld.sh	r8,r8[16]
80006be4:	5c 78       	castu.h	r8
80006be6:	e2 18 ff 00 	andl	r8,0xff00,COH
80006bea:	e0 48 01 00 	cp.w	r8,256
80006bee:	c0 60       	breq	80006bfa <xnl_device_conn_reply_func+0x3a>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80006bf0:	ee fc ff fc 	ld.w	r12,r7[-4]
80006bf4:	f0 1f 00 13 	mcall	80006c40 <xnl_device_conn_reply_func+0x80>
80006bf8:	c1 c8       	rjmp	80006c30 <xnl_device_conn_reply_func+0x70>
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80006bfa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006bfe:	f1 08 00 10 	ld.sh	r8,r8[16]
80006c02:	5c 78       	castu.h	r8
80006c04:	a9 68       	lsl	r8,0x8
80006c06:	5c 88       	casts.h	r8
80006c08:	48 f9       	lddpc	r9,80006c44 <xnl_device_conn_reply_func+0x84>
80006c0a:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80006c0c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c10:	f1 08 00 14 	ld.sh	r8,r8[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80006c14:	48 c9       	lddpc	r9,80006c44 <xnl_device_conn_reply_func+0x84>
80006c16:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80006c18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006c1c:	f1 08 00 12 	ld.sh	r8,r8[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80006c20:	48 99       	lddpc	r9,80006c44 <xnl_device_conn_reply_func+0x84>
80006c22:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80006c24:	48 89       	lddpc	r9,80006c44 <xnl_device_conn_reply_func+0x84>
80006c26:	30 18       	mov	r8,1
80006c28:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80006c2a:	48 8c       	lddpc	r12,80006c48 <xnl_device_conn_reply_func+0x88>
80006c2c:	f0 1f 00 08 	mcall	80006c4c <xnl_device_conn_reply_func+0x8c>
	}
	
	//xcmp_audio_route_speaker();
	
}
80006c30:	2f fd       	sub	sp,-4
80006c32:	e3 cd 80 80 	ldm	sp++,r7,pc
80006c36:	00 00       	add	r0,r0
80006c38:	00 00       	add	r0,r0
80006c3a:	0b 64       	ld.uh	r4,--r5
80006c3c:	80 00       	ld.sh	r0,r0[0x0]
80006c3e:	8a 54       	ld.sh	r4,r5[0xa]
80006c40:	80 00       	ld.sh	r0,r0[0x0]
80006c42:	69 f4       	ld.w	r4,r4[0x7c]
80006c44:	00 00       	add	r0,r0
80006c46:	0b 50       	ld.sh	r0,--r5
80006c48:	80 00       	ld.sh	r0,r0[0x0]
80006c4a:	68 48       	ld.w	r8,r4[0x10]
80006c4c:	80 00       	ld.sh	r0,r0[0x0]
80006c4e:	a3 80       	lsr	r0,0x2

80006c50 <xnl_send_msg_ack>:
Description: send data message ack.
Calls:xnl_tx
Register:xnl_data_msg_func
*/
static void xnl_send_msg_ack(xnl_header_t * hdr)
{	
80006c50:	eb cd 40 80 	pushm	r7,lr
80006c54:	1a 97       	mov	r7,sp
80006c56:	fa cd 01 04 	sub	sp,sp,260
80006c5a:	ef 4c fe fc 	st.w	r7[-260],r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80006c5e:	e0 68 40 0e 	mov	r8,16398
80006c62:	ef 58 ff 00 	st.h	r7[-256],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80006c66:	3f f8       	mov	r8,-1
80006c68:	ef 58 ff 02 	st.h	r7[-254],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80006c6c:	30 c8       	mov	r8,12
80006c6e:	ef 58 ff 04 	st.h	r7[-252],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80006c72:	ee f8 fe fc 	ld.w	r8,r7[-260]
80006c76:	90 18       	ld.sh	r8,r8[0x2]
80006c78:	ef 58 ff 06 	st.h	r7[-250],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80006c7c:	ee f8 fe fc 	ld.w	r8,r7[-260]
80006c80:	90 38       	ld.sh	r8,r8[0x6]
80006c82:	ef 58 ff 08 	st.h	r7[-248],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80006c86:	ee f8 fe fc 	ld.w	r8,r7[-260]
80006c8a:	90 28       	ld.sh	r8,r8[0x4]
80006c8c:	ef 58 ff 0a 	st.h	r7[-246],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80006c90:	ee f8 fe fc 	ld.w	r8,r7[-260]
80006c94:	90 48       	ld.sh	r8,r8[0x8]
80006c96:	ef 58 ff 0c 	st.h	r7[-244],r8
	xnl_frame.xnl_header.payload_length = 0;
80006c9a:	30 08       	mov	r8,0
80006c9c:	ef 58 ff 0e 	st.h	r7[-242],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80006ca0:	ee c8 01 00 	sub	r8,r7,256
80006ca4:	10 9c       	mov	r12,r8
80006ca6:	f0 1f 00 03 	mcall	80006cb0 <xnl_send_msg_ack+0x60>
}
80006caa:	2b fd       	sub	sp,-260
80006cac:	e3 cd 80 80 	ldm	sp++,r7,pc
80006cb0:	80 00       	ld.sh	r0,r0[0x0]
80006cb2:	6d 74       	ld.w	r4,r6[0x5c]

80006cb4 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80006cb4:	eb cd 40 c0 	pushm	r6-r7,lr
80006cb8:	1a 97       	mov	r7,sp
80006cba:	20 1d       	sub	sp,4
80006cbc:	ef 4c ff fc 	st.w	r7[-4],r12
	If cannot schedule ACK, just leave without processing message; 
	XNL will retry again, and hopefully our Tx resources will then be free. If 
	ACK has been scheduled. It most likely is already owned by the 
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
80006cc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006cc4:	2f c8       	sub	r8,-4
80006cc6:	10 9c       	mov	r12,r8
80006cc8:	f0 1f 00 0b 	mcall	80006cf4 <xnl_data_msg_func+0x40>
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80006ccc:	48 b8       	lddpc	r8,80006cf8 <xnl_data_msg_func+0x44>
80006cce:	70 06       	ld.w	r6,r8[0x0]
80006cd0:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006cd4:	fa cd 00 cc 	sub	sp,sp,204
80006cd8:	1a 98       	mov	r8,sp
80006cda:	2f 09       	sub	r9,-16
80006cdc:	e0 6a 00 ca 	mov	r10,202
80006ce0:	12 9b       	mov	r11,r9
80006ce2:	10 9c       	mov	r12,r8
80006ce4:	f0 1f 00 06 	mcall	80006cfc <xnl_data_msg_func+0x48>
80006ce8:	5d 16       	icall	r6
80006cea:	fa cd ff 34 	sub	sp,sp,-204
}
80006cee:	2f fd       	sub	sp,-4
80006cf0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006cf4:	80 00       	ld.sh	r0,r0[0x0]
80006cf6:	6c 50       	ld.w	r0,r6[0x14]
80006cf8:	00 00       	add	r0,r0
80006cfa:	0b 5c       	ld.sh	r12,--r5
80006cfc:	80 00       	ld.sh	r0,r0[0x0]
80006cfe:	b0 72       	st.h	r8[0xe],r2

80006d00 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80006d00:	eb cd 40 80 	pushm	r7,lr
80006d04:	1a 97       	mov	r7,sp
80006d06:	20 2d       	sub	sp,8
80006d08:	ef 4c ff f8 	st.w	r7[-8],r12
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80006d0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006d10:	90 48       	ld.sh	r8,r8[0x8]
80006d12:	ef 58 ff fc 	st.h	r7[-4],r8
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80006d16:	48 d8       	lddpc	r8,80006d48 <xnl_get_msg_ack_func+0x48>
80006d18:	90 28       	ld.sh	r8,r8[0x4]
80006d1a:	5c 88       	casts.h	r8
80006d1c:	ef 09 ff fc 	ld.sh	r9,r7[-4]
80006d20:	f0 09 19 00 	cp.h	r9,r8
80006d24:	c0 e1       	brne	80006d40 <xnl_get_msg_ack_func+0x40>
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
80006d26:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006d2a:	90 68       	ld.sh	r8,r8[0xc]
80006d2c:	ef 58 ff fe 	st.h	r7[-2],r8
		xSemaphoreGive(xnl_timeout_semphr);	
80006d30:	48 78       	lddpc	r8,80006d4c <xnl_get_msg_ack_func+0x4c>
80006d32:	70 08       	ld.w	r8,r8[0x0]
80006d34:	30 09       	mov	r9,0
80006d36:	30 0a       	mov	r10,0
80006d38:	30 0b       	mov	r11,0
80006d3a:	10 9c       	mov	r12,r8
80006d3c:	f0 1f 00 05 	mcall	80006d50 <xnl_get_msg_ack_func+0x50>
	}
	
	
	
	//xSemaphoreGive(xnl_timeout_semphr);	
}
80006d40:	2f ed       	sub	sp,-8
80006d42:	e3 cd 80 80 	ldm	sp++,r7,pc
80006d46:	00 00       	add	r0,r0
80006d48:	00 00       	add	r0,r0
80006d4a:	0b 50       	ld.sh	r0,--r5
80006d4c:	00 00       	add	r0,r0
80006d4e:	0b 64       	ld.uh	r4,--r5
80006d50:	80 00       	ld.sh	r0,r0[0x0]
80006d52:	8a 54       	ld.sh	r4,r5[0xa]

80006d54 <xnl_register_xcmp_func>:
/**
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
80006d54:	eb cd 40 80 	pushm	r7,lr
80006d58:	1a 97       	mov	r7,sp
80006d5a:	20 1d       	sub	sp,4
80006d5c:	ef 4c ff fc 	st.w	r7[-4],r12
	 xcmp_exec = func;
80006d60:	48 48       	lddpc	r8,80006d70 <xnl_register_xcmp_func+0x1c>
80006d62:	ee f9 ff fc 	ld.w	r9,r7[-4]
80006d66:	91 09       	st.w	r8[0x0],r9
}
80006d68:	2f fd       	sub	sp,-4
80006d6a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006d6e:	00 00       	add	r0,r0
80006d70:	00 00       	add	r0,r0
80006d72:	0b 5c       	ld.sh	r12,--r5

80006d74 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80006d74:	eb cd 40 80 	pushm	r7,lr
80006d78:	1a 97       	mov	r7,sp
80006d7a:	20 3d       	sub	sp,12
80006d7c:	ef 4c ff f4 	st.w	r7[-12],r12
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006d80:	30 08       	mov	r8,0
80006d82:	ef 48 ff fc 	st.w	r7[-4],r8
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80006d86:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006d8a:	90 39       	ld.sh	r9,r8[0x6]
80006d8c:	3f f8       	mov	r8,-1
80006d8e:	f0 09 19 00 	cp.h	r9,r8
80006d92:	c1 01       	brne	80006db2 <xnl_tx+0x3e>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80006d94:	4b a8       	lddpc	r8,80006e7c <xnl_tx+0x108>
80006d96:	11 88       	ld.ub	r8,r8[0x0]
80006d98:	2f f8       	sub	r8,-1
80006d9a:	5c 58       	castu.b	r8
80006d9c:	4b 89       	lddpc	r9,80006e7c <xnl_tx+0x108>
80006d9e:	b2 88       	st.b	r9[0x0],r8
80006da0:	4b 78       	lddpc	r8,80006e7c <xnl_tx+0x108>
80006da2:	11 88       	ld.ub	r8,r8[0x0]
80006da4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80006da8:	a9 a8       	sbr	r8,0x8
80006daa:	5c 88       	casts.h	r8
80006dac:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006db0:	b2 38       	st.h	r9[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80006db2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006db6:	90 49       	ld.sh	r9,r8[0x8]
80006db8:	3f f8       	mov	r8,-1
80006dba:	f0 09 19 00 	cp.h	r9,r8
80006dbe:	c0 71       	brne	80006dcc <xnl_tx+0x58>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80006dc0:	4b 08       	lddpc	r8,80006e80 <xnl_tx+0x10c>
80006dc2:	90 18       	ld.sh	r8,r8[0x2]
80006dc4:	5c 88       	casts.h	r8
80006dc6:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006dca:	b2 48       	st.h	r9[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80006dcc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006dd0:	90 59       	ld.sh	r9,r8[0xa]
80006dd2:	3f f8       	mov	r8,-1
80006dd4:	f0 09 19 00 	cp.h	r9,r8
80006dd8:	c0 71       	brne	80006de6 <xnl_tx+0x72>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80006dda:	4a a8       	lddpc	r8,80006e80 <xnl_tx+0x10c>
80006ddc:	90 28       	ld.sh	r8,r8[0x4]
80006dde:	5c 88       	casts.h	r8
80006de0:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006de4:	b2 58       	st.h	r9[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80006de6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006dea:	90 69       	ld.sh	r9,r8[0xc]
80006dec:	3f f8       	mov	r8,-1
80006dee:	f0 09 19 00 	cp.h	r9,r8
80006df2:	c1 a1       	brne	80006e26 <xnl_tx+0xb2>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80006df4:	4a 38       	lddpc	r8,80006e80 <xnl_tx+0x10c>
80006df6:	90 48       	ld.sh	r8,r8[0x8]
80006df8:	5c 88       	casts.h	r8
80006dfa:	2f f8       	sub	r8,-1
80006dfc:	5c 88       	casts.h	r8
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80006dfe:	4a 19       	lddpc	r9,80006e80 <xnl_tx+0x10c>
80006e00:	b2 48       	st.h	r9[0x8],r8
		  ((++xnl_information.transaction_id) & 0xFF) 
80006e02:	4a 08       	lddpc	r8,80006e80 <xnl_tx+0x10c>
80006e04:	90 48       	ld.sh	r8,r8[0x8]
80006e06:	5c 88       	casts.h	r8
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80006e08:	5c 88       	casts.h	r8
80006e0a:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80006e0e:	49 d9       	lddpc	r9,80006e80 <xnl_tx+0x10c>
80006e10:	92 49       	ld.sh	r9,r9[0x8]
80006e12:	5c 89       	casts.h	r9
80006e14:	5c 89       	casts.h	r9
80006e16:	e0 19 ff 00 	andl	r9,0xff00
80006e1a:	5c 89       	casts.h	r9
80006e1c:	12 48       	or	r8,r9
80006e1e:	5c 88       	casts.h	r8
80006e20:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006e24:	b2 68       	st.h	r9[0xc],r8
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80006e26:	ee fc ff f4 	ld.w	r12,r7[-12]
80006e2a:	f0 1f 00 17 	mcall	80006e84 <xnl_tx+0x110>
80006e2e:	18 98       	mov	r8,r12
80006e30:	5c 88       	casts.h	r8
80006e32:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006e36:	b2 18       	st.h	r9[0x2],r8
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80006e38:	49 48       	lddpc	r8,80006e88 <xnl_tx+0x114>
80006e3a:	70 08       	ld.w	r8,r8[0x0]
80006e3c:	10 9c       	mov	r12,r8
80006e3e:	f0 1f 00 14 	mcall	80006e8c <xnl_tx+0x118>
80006e42:	18 98       	mov	r8,r12
80006e44:	ef 48 ff f8 	st.w	r7[-8],r8
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80006e48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006e4c:	58 08       	cp.w	r8,0
80006e4e:	c1 30       	breq	80006e74 <xnl_tx+0x100>
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80006e50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006e54:	e0 6a 01 00 	mov	r10,256
80006e58:	ee fb ff f4 	ld.w	r11,r7[-12]
80006e5c:	10 9c       	mov	r12,r8
80006e5e:	f0 1f 00 0d 	mcall	80006e90 <xnl_tx+0x11c>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80006e62:	48 d8       	lddpc	r8,80006e94 <xnl_tx+0x120>
80006e64:	70 08       	ld.w	r8,r8[0x0]
80006e66:	ee cb 00 08 	sub	r11,r7,8
80006e6a:	30 09       	mov	r9,0
80006e6c:	30 0a       	mov	r10,0
80006e6e:	10 9c       	mov	r12,r8
80006e70:	f0 1f 00 0a 	mcall	80006e98 <xnl_tx+0x124>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80006e74:	2f dd       	sub	sp,-12
80006e76:	e3 cd 80 80 	ldm	sp++,r7,pc
80006e7a:	00 00       	add	r0,r0
80006e7c:	00 00       	add	r0,r0
80006e7e:	0b 74       	ld.ub	r4,--r5
80006e80:	00 00       	add	r0,r0
80006e82:	0b 50       	ld.sh	r0,--r5
80006e84:	80 00       	ld.sh	r0,r0[0x0]
80006e86:	69 18       	ld.w	r8,r4[0x44]
80006e88:	00 00       	add	r0,r0
80006e8a:	0a 88       	andn	r8,r5
80006e8c:	80 00       	ld.sh	r0,r0[0x0]
80006e8e:	5f 4c       	srge	r12
80006e90:	80 00       	ld.sh	r0,r0[0x0]
80006e92:	b0 72       	st.h	r8[0xe],r2
80006e94:	00 00       	add	r0,r0
80006e96:	0b 60       	ld.uh	r0,--r5
80006e98:	80 00       	ld.sh	r0,r0[0x0]
80006e9a:	8a 54       	ld.sh	r4,r5[0xa]

80006e9c <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80006e9c:	eb cd 40 80 	pushm	r7,lr
80006ea0:	1a 97       	mov	r7,sp
80006ea2:	20 1d       	sub	sp,4
80006ea4:	ef 4c ff fc 	st.w	r7[-4],r12
	static  xnl_fragment_t * ptr;//
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80006ea8:	4b 68       	lddpc	r8,80006f80 <xnl_tx_process+0xe4>
80006eaa:	70 08       	ld.w	r8,r8[0x0]
80006eac:	58 08       	cp.w	r8,0
80006eae:	c0 40       	breq	80006eb6 <xnl_tx_process+0x1a>
80006eb0:	58 18       	cp.w	r8,1
80006eb2:	c3 10       	breq	80006f14 <xnl_tx_process+0x78>
				}
				break;
			default:
				break;
		}
	}
80006eb4:	cf ab       	rjmp	80006ea8 <xnl_tx_process+0xc>
	for(;;)
	{		
		switch(xnl_tx_state)
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80006eb6:	4b 48       	lddpc	r8,80006f84 <xnl_tx_process+0xe8>
80006eb8:	70 08       	ld.w	r8,r8[0x0]
80006eba:	30 09       	mov	r9,0
80006ebc:	3f fa       	mov	r10,-1
80006ebe:	4b 3b       	lddpc	r11,80006f88 <xnl_tx_process+0xec>
80006ec0:	10 9c       	mov	r12,r8
80006ec2:	f0 1f 00 33 	mcall	80006f8c <xnl_tx_process+0xf0>
80006ec6:	18 98       	mov	r8,r12
80006ec8:	58 18       	cp.w	r8,1
80006eca:	c2 41       	brne	80006f12 <xnl_tx_process+0x76>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80006ecc:	4a f8       	lddpc	r8,80006f88 <xnl_tx_process+0xec>
80006ece:	70 08       	ld.w	r8,r8[0x0]
80006ed0:	58 08       	cp.w	r8,0
80006ed2:	c0 21       	brne	80006ed6 <xnl_tx_process+0x3a>
					{
						break;
80006ed4:	c5 48       	rjmp	80006f7c <xnl_tx_process+0xe0>
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80006ed6:	4a d8       	lddpc	r8,80006f88 <xnl_tx_process+0xec>
80006ed8:	70 08       	ld.w	r8,r8[0x0]
80006eda:	90 28       	ld.sh	r8,r8[0x4]
80006edc:	58 08       	cp.w	r8,0
80006ede:	c0 71       	brne	80006eec <xnl_tx_process+0x50>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80006ee0:	4a a8       	lddpc	r8,80006f88 <xnl_tx_process+0xec>
80006ee2:	70 08       	ld.w	r8,r8[0x0]
80006ee4:	10 9c       	mov	r12,r8
80006ee6:	f0 1f 00 2b 	mcall	80006f90 <xnl_tx_process+0xf4>
						break;
80006eea:	c4 98       	rjmp	80006f7c <xnl_tx_process+0xe0>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80006eec:	4a 78       	lddpc	r8,80006f88 <xnl_tx_process+0xec>
80006eee:	70 08       	ld.w	r8,r8[0x0]
80006ef0:	10 9c       	mov	r12,r8
80006ef2:	f0 1f 00 29 	mcall	80006f94 <xnl_tx_process+0xf8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80006ef6:	4a 98       	lddpc	r8,80006f98 <xnl_tx_process+0xfc>
80006ef8:	30 19       	mov	r9,1
80006efa:	91 09       	st.w	r8[0x0],r9
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80006efc:	4a 88       	lddpc	r8,80006f9c <xnl_tx_process+0x100>
80006efe:	70 08       	ld.w	r8,r8[0x0]
80006f00:	30 09       	mov	r9,0
80006f02:	30 0a       	mov	r10,0
80006f04:	30 0b       	mov	r11,0
80006f06:	10 9c       	mov	r12,r8
80006f08:	f0 1f 00 21 	mcall	80006f8c <xnl_tx_process+0xf0>
					xnl_tx_state = WAITING_FOR_REPLY;
80006f0c:	49 d8       	lddpc	r8,80006f80 <xnl_tx_process+0xe4>
80006f0e:	30 19       	mov	r9,1
80006f10:	91 09       	st.w	r8[0x0],r9
				}
				break;
80006f12:	c3 58       	rjmp	80006f7c <xnl_tx_process+0xe0>
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://ACKdata/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80006f14:	4a 28       	lddpc	r8,80006f9c <xnl_tx_process+0x100>
80006f16:	70 08       	ld.w	r8,r8[0x0]
80006f18:	30 09       	mov	r9,0
80006f1a:	36 4a       	mov	r10,100
80006f1c:	30 0b       	mov	r11,0
80006f1e:	10 9c       	mov	r12,r8
80006f20:	f0 1f 00 1b 	mcall	80006f8c <xnl_tx_process+0xf0>
80006f24:	18 98       	mov	r8,r12
80006f26:	58 18       	cp.w	r8,1
80006f28:	c0 d1       	brne	80006f42 <xnl_tx_process+0xa6>
					, ( portTickType )50*2/ portTICK_RATE_MS))//ADK500ms,freertos
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80006f2a:	49 88       	lddpc	r8,80006f88 <xnl_tx_process+0xec>
80006f2c:	70 09       	ld.w	r9,r8[0x0]
80006f2e:	49 d8       	lddpc	r8,80006fa0 <xnl_tx_process+0x104>
80006f30:	70 08       	ld.w	r8,r8[0x0]
80006f32:	12 9b       	mov	r11,r9
80006f34:	10 9c       	mov	r12,r8
80006f36:	f0 1f 00 1c 	mcall	80006fa4 <xnl_tx_process+0x108>
					xnl_tx_state = WAITING_FOR_TX;
80006f3a:	49 28       	lddpc	r8,80006f80 <xnl_tx_process+0xe4>
80006f3c:	30 09       	mov	r9,0
80006f3e:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
80006f40:	cb 4b       	rjmp	80006ea8 <xnl_tx_process+0xc>
					xnl_tx_state = WAITING_FOR_TX;
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80006f42:	49 68       	lddpc	r8,80006f98 <xnl_tx_process+0xfc>
80006f44:	70 08       	ld.w	r8,r8[0x0]
80006f46:	58 38       	cp.w	r8,3
80006f48:	e0 89 00 0e 	brgt	80006f64 <xnl_tx_process+0xc8>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80006f4c:	48 f8       	lddpc	r8,80006f88 <xnl_tx_process+0xec>
80006f4e:	70 08       	ld.w	r8,r8[0x0]
80006f50:	10 9c       	mov	r12,r8
80006f52:	f0 1f 00 11 	mcall	80006f94 <xnl_tx_process+0xf8>
						xnl_send_times++;
80006f56:	49 18       	lddpc	r8,80006f98 <xnl_tx_process+0xfc>
80006f58:	70 08       	ld.w	r8,r8[0x0]
80006f5a:	f0 c9 ff ff 	sub	r9,r8,-1
80006f5e:	48 f8       	lddpc	r8,80006f98 <xnl_tx_process+0xfc>
80006f60:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
80006f62:	ca 3b       	rjmp	80006ea8 <xnl_tx_process+0xc>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80006f64:	48 98       	lddpc	r8,80006f88 <xnl_tx_process+0xec>
80006f66:	70 09       	ld.w	r9,r8[0x0]
80006f68:	48 e8       	lddpc	r8,80006fa0 <xnl_tx_process+0x104>
80006f6a:	70 08       	ld.w	r8,r8[0x0]
80006f6c:	12 9b       	mov	r11,r9
80006f6e:	10 9c       	mov	r12,r8
80006f70:	f0 1f 00 0d 	mcall	80006fa4 <xnl_tx_process+0x108>
						xnl_tx_state = WAITING_FOR_TX;
80006f74:	48 38       	lddpc	r8,80006f80 <xnl_tx_process+0xe4>
80006f76:	30 09       	mov	r9,0
80006f78:	91 09       	st.w	r8[0x0],r9
				}
				break;
			default:
				break;
		}
	}
80006f7a:	c9 7b       	rjmp	80006ea8 <xnl_tx_process+0xc>
80006f7c:	c9 6b       	rjmp	80006ea8 <xnl_tx_process+0xc>
80006f7e:	00 00       	add	r0,r0
80006f80:	00 00       	add	r0,r0
80006f82:	0b 68       	ld.uh	r8,--r5
80006f84:	00 00       	add	r0,r0
80006f86:	0b 60       	ld.uh	r0,--r5
80006f88:	00 00       	add	r0,r0
80006f8a:	0b 6c       	ld.uh	r12,--r5
80006f8c:	80 00       	ld.sh	r0,r0[0x0]
80006f8e:	8c 60       	ld.sh	r0,r6[0xc]
80006f90:	80 00       	ld.sh	r0,r0[0x0]
80006f92:	89 04       	st.w	r4[0x0],r4
80006f94:	80 00       	ld.sh	r0,r0[0x0]
80006f96:	44 04       	lddsp	r4,sp[0x100]
80006f98:	00 00       	add	r0,r0
80006f9a:	0b 70       	ld.ub	r0,--r5
80006f9c:	00 00       	add	r0,r0
80006f9e:	0b 64       	ld.uh	r4,--r5
80006fa0:	00 00       	add	r0,r0
80006fa2:	0a 88       	andn	r8,r5
80006fa4:	80 00       	ld.sh	r0,r0[0x0]
80006fa6:	5f d4       	srvc	r4

80006fa8 <xnl_rx>:
Description: Receive the XNL and perform the corresponding functions
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
80006fa8:	eb cd 40 80 	pushm	r7,lr
80006fac:	1a 97       	mov	r7,sp
80006fae:	20 1d       	sub	sp,4
80006fb0:	ef 4c ff fc 	st.w	r7[-4],r12
	if(xnl->xnl_header.opcode > 0x0C)	
80006fb4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006fb8:	90 29       	ld.sh	r9,r8[0x4]
80006fba:	30 c8       	mov	r8,12
80006fbc:	f0 09 19 00 	cp.h	r9,r8
80006fc0:	e0 8b 00 18 	brhi	80006ff0 <xnl_rx+0x48>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80006fc4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006fc8:	90 28       	ld.sh	r8,r8[0x4]
80006fca:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80006fce:	48 b8       	lddpc	r8,80006ff8 <xnl_rx+0x50>
80006fd0:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006fd4:	58 08       	cp.w	r8,0
80006fd6:	c0 e0       	breq	80006ff2 <xnl_rx+0x4a>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80006fd8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006fdc:	90 28       	ld.sh	r8,r8[0x4]
80006fde:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80006fe2:	48 68       	lddpc	r8,80006ff8 <xnl_rx+0x50>
80006fe4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80006fe8:	ee fc ff fc 	ld.w	r12,r7[-4]
80006fec:	5d 18       	icall	r8
80006fee:	c0 28       	rjmp	80006ff2 <xnl_rx+0x4a>
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
80006ff0:	d7 03       	nop
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
	}
}
80006ff2:	2f fd       	sub	sp,-4
80006ff4:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ff8:	00 00       	add	r0,r0
80006ffa:	05 14       	ld.sh	r4,r2++

80006ffc <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80006ffc:	eb cd 40 80 	pushm	r7,lr
80007000:	1a 97       	mov	r7,sp
80007002:	20 2d       	sub	sp,8
80007004:	ef 4c ff f8 	st.w	r7[-8],r12
80007008:	c0 48       	rjmp	80007010 <xnl_rx_process+0x14>
				
				//vPortFree(xnl_ptr);
			}			
		}
		
	}
8000700a:	d7 03       	nop
8000700c:	c0 28       	rjmp	80007010 <xnl_rx_process+0x14>
8000700e:	d7 03       	nop
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80007010:	48 f8       	lddpc	r8,8000704c <xnl_rx_process+0x50>
80007012:	70 08       	ld.w	r8,r8[0x0]
80007014:	ee cb 00 04 	sub	r11,r7,4
80007018:	30 09       	mov	r9,0
8000701a:	3f fa       	mov	r10,-1
8000701c:	10 9c       	mov	r12,r8
8000701e:	f0 1f 00 0d 	mcall	80007050 <xnl_rx_process+0x54>
80007022:	18 98       	mov	r8,r12
80007024:	58 18       	cp.w	r8,1
80007026:	cf 21       	brne	8000700a <xnl_rx_process+0xe>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80007028:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000702c:	58 08       	cp.w	r8,0
8000702e:	cf 00       	breq	8000700e <xnl_rx_process+0x12>
			{
				xnl_rx(xnl_ptr);
80007030:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007034:	10 9c       	mov	r12,r8
80007036:	f0 1f 00 08 	mcall	80007054 <xnl_rx_process+0x58>
				set_xnl_idle(xnl_ptr);
8000703a:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000703e:	48 78       	lddpc	r8,80007058 <xnl_rx_process+0x5c>
80007040:	70 08       	ld.w	r8,r8[0x0]
80007042:	12 9b       	mov	r11,r9
80007044:	10 9c       	mov	r12,r8
80007046:	f0 1f 00 06 	mcall	8000705c <xnl_rx_process+0x60>
				
				//vPortFree(xnl_ptr);
			}			
		}
		
	}
8000704a:	ce 3b       	rjmp	80007010 <xnl_rx_process+0x14>
8000704c:	00 00       	add	r0,r0
8000704e:	0a 90       	mov	r0,r5
80007050:	80 00       	ld.sh	r0,r0[0x0]
80007052:	8c 60       	ld.sh	r0,r6[0xc]
80007054:	80 00       	ld.sh	r0,r0[0x0]
80007056:	6f a8       	ld.w	r8,r7[0x68]
80007058:	00 00       	add	r0,r0
8000705a:	0a 88       	andn	r8,r5
8000705c:	80 00       	ld.sh	r0,r0[0x0]
8000705e:	5f d4       	srvc	r4

80007060 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80007060:	eb cd 40 80 	pushm	r7,lr
80007064:	1a 97       	mov	r7,sp
	/*initialize the physical layer*/
	phy_init();
80007066:	f0 1f 00 21 	mcall	800070e8 <xnl_init+0x88>
	
	xnl_information.is_connected = FALSE;
8000706a:	4a 19       	lddpc	r9,800070ec <xnl_init+0x8c>
8000706c:	30 08       	mov	r8,0
8000706e:	b2 88       	st.b	r9[0x0],r8

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80007070:	30 0b       	mov	r11,0
80007072:	30 1c       	mov	r12,1
80007074:	f0 1f 00 1f 	mcall	800070f0 <xnl_init+0x90>
80007078:	18 99       	mov	r9,r12
8000707a:	49 f8       	lddpc	r8,800070f4 <xnl_init+0x94>
8000707c:	91 09       	st.w	r8[0x0],r9
8000707e:	49 e8       	lddpc	r8,800070f4 <xnl_init+0x94>
80007080:	70 08       	ld.w	r8,r8[0x0]
80007082:	58 08       	cp.w	r8,0
80007084:	c0 90       	breq	80007096 <xnl_init+0x36>
80007086:	49 c8       	lddpc	r8,800070f4 <xnl_init+0x94>
80007088:	70 08       	ld.w	r8,r8[0x0]
8000708a:	30 09       	mov	r9,0
8000708c:	30 0a       	mov	r10,0
8000708e:	30 0b       	mov	r11,0
80007090:	10 9c       	mov	r12,r8
80007092:	f0 1f 00 1a 	mcall	800070f8 <xnl_init+0x98>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //xnl_frame_tx
80007096:	30 4b       	mov	r11,4
80007098:	31 4c       	mov	r12,20
8000709a:	f0 1f 00 16 	mcall	800070f0 <xnl_init+0x90>
8000709e:	18 99       	mov	r9,r12
800070a0:	49 78       	lddpc	r8,800070fc <xnl_init+0x9c>
800070a2:	91 09       	st.w	r8[0x0],r9
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800070a4:	49 7b       	lddpc	r11,80007100 <xnl_init+0xa0>
800070a6:	30 08       	mov	r8,0
800070a8:	1a d8       	st.w	--sp,r8
800070aa:	30 08       	mov	r8,0
800070ac:	1a d8       	st.w	--sp,r8
800070ae:	30 08       	mov	r8,0
800070b0:	1a d8       	st.w	--sp,r8
800070b2:	30 38       	mov	r8,3
800070b4:	30 09       	mov	r9,0
800070b6:	e0 6a 02 00 	mov	r10,512
800070ba:	49 3c       	lddpc	r12,80007104 <xnl_init+0xa4>
800070bc:	f0 1f 00 13 	mcall	80007108 <xnl_init+0xa8>
800070c0:	2f dd       	sub	sp,-12
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800070c2:	49 3b       	lddpc	r11,8000710c <xnl_init+0xac>
800070c4:	30 08       	mov	r8,0
800070c6:	1a d8       	st.w	--sp,r8
800070c8:	30 08       	mov	r8,0
800070ca:	1a d8       	st.w	--sp,r8
800070cc:	30 08       	mov	r8,0
800070ce:	1a d8       	st.w	--sp,r8
800070d0:	30 38       	mov	r8,3
800070d2:	30 09       	mov	r9,0
800070d4:	e0 6a 03 20 	mov	r10,800
800070d8:	48 ec       	lddpc	r12,80007110 <xnl_init+0xb0>
800070da:	f0 1f 00 0c 	mcall	80007108 <xnl_init+0xa8>
800070de:	2f dd       	sub	sp,-12
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
800070e0:	f0 1f 00 0d 	mcall	80007114 <xnl_init+0xb4>
}
800070e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	42 f8       	lddsp	r8,sp[0xbc]
800070ec:	00 00       	add	r0,r0
800070ee:	0b 50       	ld.sh	r0,--r5
800070f0:	80 00       	ld.sh	r0,r0[0x0]
800070f2:	89 3c       	st.w	r4[0xc],r12
800070f4:	00 00       	add	r0,r0
800070f6:	0b 64       	ld.uh	r4,--r5
800070f8:	80 00       	ld.sh	r0,r0[0x0]
800070fa:	8a 54       	ld.sh	r4,r5[0xa]
800070fc:	00 00       	add	r0,r0
800070fe:	0b 60       	ld.uh	r0,--r5
80007100:	80 00       	ld.sh	r0,r0[0x0]
80007102:	68 5c       	ld.w	r12,r4[0x14]
80007104:	80 00       	ld.sh	r0,r0[0x0]
80007106:	6f fc       	ld.w	r12,r7[0x7c]
80007108:	80 00       	ld.sh	r0,r0[0x0]
8000710a:	91 ac       	st.w	r8[0x28],r12
8000710c:	80 00       	ld.sh	r0,r0[0x0]
8000710e:	68 64       	ld.w	r4,r4[0x18]
80007110:	80 00       	ld.sh	r0,r0[0x0]
80007112:	6e 9c       	ld.w	r12,r7[0x24]
80007114:	80 00       	ld.sh	r0,r0[0x0]
80007116:	69 a4       	ld.w	r4,r4[0x68]

80007118 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80007118:	eb cd 40 80 	pushm	r7,lr
8000711c:	1a 97       	mov	r7,sp
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
8000711e:	fe 78 0c 00 	mov	r8,-62464
80007122:	e0 69 03 07 	mov	r9,775
80007126:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80007128:	fe 78 0c 00 	mov	r8,-62464
8000712c:	30 49       	mov	r9,4
8000712e:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80007130:	fe 78 0c 00 	mov	r8,-62464
80007134:	71 58       	ld.w	r8,r8[0x54]
80007136:	e2 18 00 80 	andl	r8,0x80,COH
8000713a:	cf b0       	breq	80007130 <local_start_pll0+0x18>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000713c:	fe 78 0c 00 	mov	r8,-62464
80007140:	30 59       	mov	r9,5
80007142:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80007144:	fe 78 0c 00 	mov	r8,-62464
80007148:	e0 69 01 0d 	mov	r9,269
8000714c:	ea 19 10 07 	orh	r9,0x1007
80007150:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80007152:	fe 78 0c 00 	mov	r8,-62464
80007156:	71 58       	ld.w	r8,r8[0x54]
80007158:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000715c:	cf b0       	breq	80007152 <local_start_pll0+0x3a>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
8000715e:	fe 78 0c 00 	mov	r8,-62464
80007162:	fc 19 00 80 	movh	r9,0x80
80007166:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80007168:	fe 68 14 00 	mov	r8,-125952
8000716c:	34 09       	mov	r9,64
8000716e:	91 09       	st.w	r8[0x0],r9

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80007170:	fe 78 0c 00 	mov	r8,-62464
80007174:	30 69       	mov	r9,6
80007176:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80007178:	fe 68 10 00 	mov	r8,-126976
8000717c:	30 19       	mov	r9,1
8000717e:	91 19       	st.w	r8[0x4],r9
}
80007180:	e3 cd 80 80 	ldm	sp++,r7,pc

80007184 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80007184:	eb cd 40 80 	pushm	r7,lr
80007188:	1a 97       	mov	r7,sp
	// Increment the 10ms seconds counter
	tc_tick++;
8000718a:	48 88       	lddpc	r8,800071a8 <_tc_interrupt+0x24>
8000718c:	70 08       	ld.w	r8,r8[0x0]
8000718e:	f0 c9 ff ff 	sub	r9,r8,-1
80007192:	48 68       	lddpc	r8,800071a8 <_tc_interrupt+0x24>
80007194:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80007196:	30 1b       	mov	r11,1
80007198:	fe 7c 38 00 	mov	r12,-51200
8000719c:	f0 1f 00 04 	mcall	800071ac <_tc_interrupt+0x28>
	
}
800071a0:	e3 cd 40 80 	ldm	sp++,r7,lr
800071a4:	d6 03       	rete
800071a6:	00 00       	add	r0,r0
800071a8:	00 00       	add	r0,r0
800071aa:	0b 78       	ld.ub	r8,--r5
800071ac:	80 00       	ld.sh	r0,r0[0x0]
800071ae:	7c ee       	ld.w	lr,lr[0x38]

800071b0 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800071b0:	eb cd 40 80 	pushm	r7,lr
800071b4:	1a 97       	mov	r7,sp
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
800071b6:	fe 78 10 00 	mov	r8,-61440
800071ba:	fc 19 00 10 	movh	r9,0x10
800071be:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
800071c0:	fe 78 10 00 	mov	r8,-61440
800071c4:	fc 19 00 10 	movh	r9,0x10
800071c8:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
800071ca:	fe 78 10 00 	mov	r8,-61440
800071ce:	fc 19 00 10 	movh	r9,0x10
800071d2:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
800071d4:	fe 78 10 00 	mov	r8,-61440
800071d8:	30 39       	mov	r9,3
800071da:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
800071de:	fe 78 10 00 	mov	r8,-61440
800071e2:	30 39       	mov	r9,3
800071e4:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800071e8:	fe 78 10 00 	mov	r8,-61440
800071ec:	30 39       	mov	r9,3
800071ee:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800071f2:	fe 78 38 00 	mov	r8,-51200
800071f6:	30 49       	mov	r9,4
800071f8:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800071fc:	fe 78 38 00 	mov	r8,-51200
80007200:	e0 69 91 0d 	mov	r9,37133
80007204:	ea 19 00 52 	orh	r9,0x52
80007208:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
8000720a:	fe 78 38 00 	mov	r8,-51200
8000720e:	32 09       	mov	r9,32
80007210:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80007212:	fe 78 38 00 	mov	r8,-51200
80007216:	30 59       	mov	r9,5
80007218:	91 09       	st.w	r8[0x0],r9
}
8000721a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000721e:	d7 03       	nop

80007220 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80007220:	eb cd 40 80 	pushm	r7,lr
80007224:	1a 97       	mov	r7,sp
80007226:	20 1d       	sub	sp,4

	volatile avr32_tc_t * tc = EXAMPLE_TC;
80007228:	fe 78 38 00 	mov	r8,-51200
8000722c:	ef 48 ff fc 	st.w	r7[-4],r8
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80007230:	30 2a       	mov	r10,2
80007232:	e0 6b 01 c1 	mov	r11,449
80007236:	48 fc       	lddpc	r12,80007270 <tc_init+0x50>
80007238:	f0 1f 00 0f 	mcall	80007274 <tc_init+0x54>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
8000723c:	48 fb       	lddpc	r11,80007278 <tc_init+0x58>
8000723e:	ee fc ff fc 	ld.w	r12,r7[-4]
80007242:	f0 1f 00 0f 	mcall	8000727c <tc_init+0x5c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80007246:	e0 6a 75 30 	mov	r10,30000
8000724a:	30 1b       	mov	r11,1
8000724c:	ee fc ff fc 	ld.w	r12,r7[-4]
80007250:	f0 1f 00 0c 	mcall	80007280 <tc_init+0x60>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80007254:	48 ca       	lddpc	r10,80007284 <tc_init+0x64>
80007256:	30 1b       	mov	r11,1
80007258:	ee fc ff fc 	ld.w	r12,r7[-4]
8000725c:	f0 1f 00 0b 	mcall	80007288 <tc_init+0x68>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80007260:	30 1b       	mov	r11,1
80007262:	ee fc ff fc 	ld.w	r12,r7[-4]
80007266:	f0 1f 00 0a 	mcall	8000728c <tc_init+0x6c>
8000726a:	2f fd       	sub	sp,-4
8000726c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007270:	80 00       	ld.sh	r0,r0[0x0]
80007272:	71 84       	ld.w	r4,r8[0x60]
80007274:	80 00       	ld.sh	r0,r0[0x0]
80007276:	73 b4       	ld.w	r4,r9[0x6c]
80007278:	80 01       	ld.sh	r1,r0[0x0]
8000727a:	08 b4       	st.h	r4++,r4
8000727c:	80 00       	ld.sh	r0,r0[0x0]
8000727e:	7b 60       	ld.w	r0,sp[0x58]
80007280:	80 00       	ld.sh	r0,r0[0x0]
80007282:	7d 28       	ld.w	r8,lr[0x48]
80007284:	80 01       	ld.sh	r1,r0[0x0]
80007286:	08 bc       	st.h	r4++,r12
80007288:	80 00       	ld.sh	r0,r0[0x0]
8000728a:	79 78       	ld.w	r8,r12[0x5c]
8000728c:	80 00       	ld.sh	r0,r0[0x0]
8000728e:	7c b4       	ld.w	r4,lr[0x2c]

80007290 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80007290:	eb cd 40 80 	pushm	r7,lr
80007294:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
80007296:	c0 08       	rjmp	80007296 <_unhandled_interrupt+0x6>

80007298 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
80007298:	eb cd 40 80 	pushm	r7,lr
8000729c:	1a 97       	mov	r7,sp
8000729e:	20 3d       	sub	sp,12
800072a0:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800072a4:	fe 78 08 00 	mov	r8,-63488
800072a8:	ee f9 ff f4 	ld.w	r9,r7[-12]
800072ac:	f2 09 11 03 	rsub	r9,r9,3
800072b0:	28 09       	sub	r9,-128
800072b2:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800072b6:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800072ba:	fe 78 08 00 	mov	r8,-63488
800072be:	ee f9 ff f8 	ld.w	r9,r7[-8]
800072c2:	2c 09       	sub	r9,-64
800072c4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800072c8:	ef 48 ff fc 	st.w	r7[-4],r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
800072cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800072d0:	58 08       	cp.w	r8,0
800072d2:	c1 30       	breq	800072f8 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
800072d4:	ee f9 ff f8 	ld.w	r9,r7[-8]
800072d8:	48 b8       	lddpc	r8,80007304 <_get_interrupt_handler+0x6c>
800072da:	a1 79       	lsl	r9,0x1
800072dc:	2f f9       	sub	r9,-1
800072de:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800072e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800072e6:	f0 08 12 00 	clz	r8,r8
800072ea:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
800072ee:	a3 68       	lsl	r8,0x2
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
800072f0:	f2 08 00 08 	add	r8,r9,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
800072f4:	70 08       	ld.w	r8,r8[0x0]
800072f6:	c0 28       	rjmp	800072fa <_get_interrupt_handler+0x62>
800072f8:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800072fa:	10 9c       	mov	r12,r8
800072fc:	2f dd       	sub	sp,-12
800072fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80007302:	00 00       	add	r0,r0
80007304:	80 01       	ld.sh	r1,r0[0x0]
80007306:	08 c0       	st.b	r4++,r0

80007308 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80007308:	eb cd 40 80 	pushm	r7,lr
8000730c:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000730e:	48 38       	lddpc	r8,80007318 <INTC_init_evba+0x10>
80007310:	e3 b8 00 01 	mtsr	0x4,r8
}
80007314:	e3 cd 80 80 	ldm	sp++,r7,pc
80007318:	80 01       	ld.sh	r1,r0[0x0]
8000731a:	06 00       	add	r0,r3

8000731c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
8000731c:	eb cd 40 80 	pushm	r7,lr
80007320:	1a 97       	mov	r7,sp
80007322:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80007324:	f0 1f 00 1f 	mcall	800073a0 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80007328:	30 08       	mov	r8,0
8000732a:	ef 48 ff f8 	st.w	r7[-8],r8
8000732e:	c3 18       	rjmp	80007390 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80007330:	30 08       	mov	r8,0
80007332:	ef 48 ff fc 	st.w	r7[-4],r8
80007336:	c1 48       	rjmp	8000735e <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80007338:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000733c:	49 a8       	lddpc	r8,800073a4 <INTC_init_interrupts+0x88>
8000733e:	a1 79       	lsl	r9,0x1
80007340:	2f f9       	sub	r9,-1
80007342:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80007346:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000734a:	a3 68       	lsl	r8,0x2
8000734c:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80007350:	49 69       	lddpc	r9,800073a8 <INTC_init_interrupts+0x8c>
80007352:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80007354:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007358:	2f f8       	sub	r8,-1
8000735a:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
8000735e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007362:	49 18       	lddpc	r8,800073a4 <INTC_init_interrupts+0x88>
80007364:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80007368:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000736c:	10 39       	cp.w	r9,r8
8000736e:	fe 9b ff e5 	brhi	80007338 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80007372:	fe 78 08 00 	mov	r8,-63488
80007376:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000737a:	48 db       	lddpc	r11,800073ac <INTC_init_interrupts+0x90>
8000737c:	48 da       	lddpc	r10,800073b0 <INTC_init_interrupts+0x94>
8000737e:	f6 0a 01 0a 	sub	r10,r11,r10
80007382:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80007386:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000738a:	2f f8       	sub	r8,-1
8000738c:	ef 48 ff f8 	st.w	r7[-8],r8
80007390:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007394:	59 28       	cp.w	r8,18
80007396:	fe 98 ff cd 	brls	80007330 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
8000739a:	2f ed       	sub	sp,-8
8000739c:	e3 cd 80 80 	ldm	sp++,r7,pc
800073a0:	80 00       	ld.sh	r0,r0[0x0]
800073a2:	73 08       	ld.w	r8,r9[0x40]
800073a4:	80 01       	ld.sh	r1,r0[0x0]
800073a6:	08 c0       	st.b	r4++,r0
800073a8:	80 00       	ld.sh	r0,r0[0x0]
800073aa:	72 90       	ld.w	r0,r9[0x24]
800073ac:	80 01       	ld.sh	r1,r0[0x0]
800073ae:	07 04       	ld.w	r4,r3++
800073b0:	80 01       	ld.sh	r1,r0[0x0]
800073b2:	06 00       	add	r0,r3

800073b4 <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
800073b4:	eb cd 40 80 	pushm	r7,lr
800073b8:	1a 97       	mov	r7,sp
800073ba:	20 4d       	sub	sp,16
800073bc:	ef 4c ff f8 	st.w	r7[-8],r12
800073c0:	ef 4b ff f4 	st.w	r7[-12],r11
800073c4:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800073c8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800073cc:	a5 98       	lsr	r8,0x5
800073ce:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800073d2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800073d6:	4a 78       	lddpc	r8,80007470 <INTC_register_interrupt+0xbc>
800073d8:	a1 79       	lsl	r9,0x1
800073da:	2f f9       	sub	r9,-1
800073dc:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800073e0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800073e4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800073e8:	a3 68       	lsl	r8,0x2
800073ea:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800073ee:	ee f9 ff f8 	ld.w	r9,r7[-8]
800073f2:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800073f4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800073f8:	58 08       	cp.w	r8,0
800073fa:	c0 c1       	brne	80007412 <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800073fc:	fe 78 08 00 	mov	r8,-63488
80007400:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007404:	49 cb       	lddpc	r11,80007474 <INTC_register_interrupt+0xc0>
80007406:	49 da       	lddpc	r10,80007478 <INTC_register_interrupt+0xc4>
80007408:	f6 0a 01 0a 	sub	r10,r11,r10
8000740c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007410:	c2 d8       	rjmp	8000746a <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80007412:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007416:	58 18       	cp.w	r8,1
80007418:	c0 d1       	brne	80007432 <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000741a:	fe 78 08 00 	mov	r8,-63488
8000741e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007422:	49 7b       	lddpc	r11,8000747c <INTC_register_interrupt+0xc8>
80007424:	49 5a       	lddpc	r10,80007478 <INTC_register_interrupt+0xc4>
80007426:	f6 0a 01 0a 	sub	r10,r11,r10
8000742a:	bf aa       	sbr	r10,0x1e
8000742c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007430:	c1 d8       	rjmp	8000746a <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80007432:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007436:	58 28       	cp.w	r8,2
80007438:	c0 d1       	brne	80007452 <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000743a:	fe 78 08 00 	mov	r8,-63488
8000743e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007442:	49 0b       	lddpc	r11,80007480 <INTC_register_interrupt+0xcc>
80007444:	48 da       	lddpc	r10,80007478 <INTC_register_interrupt+0xc4>
80007446:	f6 0a 01 0a 	sub	r10,r11,r10
8000744a:	bf ba       	sbr	r10,0x1f
8000744c:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80007450:	c0 d8       	rjmp	8000746a <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80007452:	fe 78 08 00 	mov	r8,-63488
80007456:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000745a:	48 bb       	lddpc	r11,80007484 <INTC_register_interrupt+0xd0>
8000745c:	48 7a       	lddpc	r10,80007478 <INTC_register_interrupt+0xc4>
8000745e:	f6 0a 01 0a 	sub	r10,r11,r10
80007462:	ea 1a c0 00 	orh	r10,0xc000
80007466:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
8000746a:	2f cd       	sub	sp,-16
8000746c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007470:	80 01       	ld.sh	r1,r0[0x0]
80007472:	08 c0       	st.b	r4++,r0
80007474:	80 01       	ld.sh	r1,r0[0x0]
80007476:	07 04       	ld.w	r4,r3++
80007478:	80 01       	ld.sh	r1,r0[0x0]
8000747a:	06 00       	add	r0,r3
8000747c:	80 01       	ld.sh	r1,r0[0x0]
8000747e:	07 12       	ld.sh	r2,r3++
80007480:	80 01       	ld.sh	r1,r0[0x0]
80007482:	07 20       	ld.uh	r0,r3++
80007484:	80 01       	ld.sh	r1,r0[0x0]
80007486:	07 2e       	ld.uh	lr,r3++

80007488 <getBaudDiv>:
 * \return Divider or error code.
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
80007488:	eb cd 40 80 	pushm	r7,lr
8000748c:	1a 97       	mov	r7,sp
8000748e:	20 3d       	sub	sp,12
80007490:	ef 4c ff f8 	st.w	r7[-8],r12
80007494:	ef 4b ff f4 	st.w	r7[-12],r11
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80007498:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000749c:	70 18       	ld.w	r8,r8[0x4]
8000749e:	f0 09 16 01 	lsr	r9,r8,0x1
800074a2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800074a6:	f2 08 00 08 	add	r8,r9,r8
800074aa:	ee f9 ff f8 	ld.w	r9,r7[-8]
800074ae:	72 19       	ld.w	r9,r9[0x4]
800074b0:	f0 09 0d 08 	divu	r8,r8,r9
800074b4:	ef 48 ff fc 	st.w	r7[-4],r8

  if (baudDiv <= 0 || baudDiv > 255) {
800074b8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800074bc:	58 08       	cp.w	r8,0
800074be:	e0 8a 00 08 	brle	800074ce <getBaudDiv+0x46>
800074c2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800074c6:	e0 48 00 ff 	cp.w	r8,255
800074ca:	e0 8a 00 04 	brle	800074d2 <getBaudDiv+0x4a>
    return -1;
800074ce:	3f f8       	mov	r8,-1
800074d0:	c0 38       	rjmp	800074d6 <getBaudDiv+0x4e>
  }

  return baudDiv;
800074d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800074d6:	10 9c       	mov	r12,r8
800074d8:	2f dd       	sub	sp,-12
800074da:	e3 cd 80 80 	ldm	sp++,r7,pc

800074de <spi_initMaster>:
  return SPI_OK;
}


spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
800074de:	eb cd 40 80 	pushm	r7,lr
800074e2:	1a 97       	mov	r7,sp
800074e4:	20 3d       	sub	sp,12
800074e6:	ef 4c ff f8 	st.w	r7[-8],r12
800074ea:	ef 4b ff f4 	st.w	r7[-12],r11
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
800074ee:	ee f8 ff f4 	ld.w	r8,r7[-12]
800074f2:	f1 39 00 0d 	ld.ub	r9,r8[13]
800074f6:	30 18       	mov	r8,1
800074f8:	f0 09 18 00 	cp.b	r9,r8
800074fc:	e0 88 00 04 	brls	80007504 <spi_initMaster+0x26>
    return SPI_ERROR_ARGUMENT;
80007500:	30 28       	mov	r8,2
80007502:	c3 48       	rjmp	8000756a <spi_initMaster+0x8c>
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80007504:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007508:	e0 69 00 80 	mov	r9,128
8000750c:	91 09       	st.w	r8[0x0],r9

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
8000750e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007512:	70 18       	ld.w	r8,r8[0x4]
80007514:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.mstr = 1;
80007518:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000751c:	30 19       	mov	r9,1
8000751e:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80007522:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80007526:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000752a:	f1 38 00 0d 	ld.ub	r8,r8[13]
8000752e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007532:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80007536:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000753a:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
8000753e:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.llb = 0;
80007542:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007546:	30 09       	mov	r9,0
80007548:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
8000754c:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80007550:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007554:	30 f9       	mov	r9,15
80007556:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
8000755a:	ef 48 ff fc 	st.w	r7[-4],r8
  spi->mr = u_avr32_spi_mr.mr;
8000755e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007562:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007566:	91 19       	st.w	r8[0x4],r9

  return SPI_OK;
80007568:	30 08       	mov	r8,0
}
8000756a:	10 9c       	mov	r12,r8
8000756c:	2f dd       	sub	sp,-12
8000756e:	e3 cd 80 80 	ldm	sp++,r7,pc

80007572 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80007572:	eb cd 40 80 	pushm	r7,lr
80007576:	1a 97       	mov	r7,sp
80007578:	20 5d       	sub	sp,20
8000757a:	ef 4c ff f8 	st.w	r7[-8],r12
8000757e:	12 98       	mov	r8,r9
80007580:	16 99       	mov	r9,r11
80007582:	ef 69 ff f4 	st.b	r7[-12],r9
80007586:	14 99       	mov	r9,r10
80007588:	ef 69 ff f0 	st.b	r7[-16],r9
8000758c:	ef 68 ff ec 	st.b	r7[-20],r8
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80007590:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80007594:	30 18       	mov	r8,1
80007596:	f0 09 18 00 	cp.b	r9,r8
8000759a:	e0 8b 00 09 	brhi	800075ac <spi_selectionMode+0x3a>
8000759e:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800075a2:	30 18       	mov	r8,1
800075a4:	f0 09 18 00 	cp.b	r9,r8
800075a8:	e0 88 00 04 	brls	800075b0 <spi_selectionMode+0x3e>
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
800075ac:	30 28       	mov	r8,2
800075ae:	c2 88       	rjmp	800075fe <spi_selectionMode+0x8c>
  }

  u_avr32_spi_mr.mr = spi->mr;
800075b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800075b4:	70 18       	ld.w	r8,r8[0x4]
800075b6:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.ps = variable_ps;
800075ba:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800075be:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800075c2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800075c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800075ca:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800075ce:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800075d2:	ef 38 ff f0 	ld.ub	r8,r7[-16]
800075d6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800075da:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800075de:	ee f8 ff fc 	ld.w	r8,r7[-4]
800075e2:	f1 d9 d0 41 	bfins	r8,r9,0x2,0x1
800075e6:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_spi_mr.MR.dlybcs = delay;
800075ea:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800075ee:	ef 68 ff fc 	st.b	r7[-4],r8
  spi->mr = u_avr32_spi_mr.mr;
800075f2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800075f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800075fa:	91 19       	st.w	r8[0x4],r9

  return SPI_OK;
800075fc:	30 08       	mov	r8,0
}
800075fe:	10 9c       	mov	r12,r8
80007600:	2f bd       	sub	sp,-20
80007602:	e3 cd 80 80 	ldm	sp++,r7,pc

80007606 <spi_selectChip>:


spi_status_t spi_selectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80007606:	eb cd 40 80 	pushm	r7,lr
8000760a:	1a 97       	mov	r7,sp
8000760c:	20 2d       	sub	sp,8
8000760e:	ef 4c ff fc 	st.w	r7[-4],r12
80007612:	16 98       	mov	r8,r11
80007614:	ef 68 ff f8 	st.b	r7[-8],r8
   */
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80007618:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000761c:	70 18       	ld.w	r8,r8[0x4]
8000761e:	10 99       	mov	r9,r8
80007620:	ea 19 00 0f 	orh	r9,0xf
80007624:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007628:	91 19       	st.w	r8[0x4],r9

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000762a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000762e:	70 18       	ld.w	r8,r8[0x4]
80007630:	e2 18 00 04 	andl	r8,0x4,COH
80007634:	c1 90       	breq	80007666 <spi_selectChip+0x60>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80007636:	ef 39 ff f8 	ld.ub	r9,r7[-8]
8000763a:	30 e8       	mov	r8,14
8000763c:	f0 09 18 00 	cp.b	r9,r8
80007640:	e0 88 00 04 	brls	80007648 <spi_selectChip+0x42>
      return SPI_ERROR_ARGUMENT;
80007644:	30 28       	mov	r8,2
80007646:	c2 88       	rjmp	80007696 <spi_selectChip+0x90>
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80007648:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000764c:	70 19       	ld.w	r9,r8[0x4]
8000764e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80007652:	b1 68       	lsl	r8,0x10
80007654:	ea 18 ff f0 	orh	r8,0xfff0
80007658:	e8 18 ff ff 	orl	r8,0xffff
8000765c:	10 69       	and	r9,r8
8000765e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007662:	91 19       	st.w	r8[0x4],r9
80007664:	c1 88       	rjmp	80007694 <spi_selectChip+0x8e>
  } else {
    if (chip > 3) {
80007666:	ef 39 ff f8 	ld.ub	r9,r7[-8]
8000766a:	30 38       	mov	r8,3
8000766c:	f0 09 18 00 	cp.b	r9,r8
80007670:	e0 88 00 04 	brls	80007678 <spi_selectChip+0x72>
      return SPI_ERROR_ARGUMENT;
80007674:	30 28       	mov	r8,2
80007676:	c1 08       	rjmp	80007696 <spi_selectChip+0x90>
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80007678:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000767c:	70 19       	ld.w	r9,r8[0x4]
8000767e:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80007682:	2f 08       	sub	r8,-16
80007684:	30 1a       	mov	r10,1
80007686:	f4 08 09 48 	lsl	r8,r10,r8
8000768a:	5c d8       	com	r8
8000768c:	10 69       	and	r9,r8
8000768e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007692:	91 19       	st.w	r8[0x4],r9
  }

  return SPI_OK;
80007694:	30 08       	mov	r8,0
}
80007696:	10 9c       	mov	r12,r8
80007698:	2f ed       	sub	sp,-8
8000769a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000769e <spi_unselectChip>:


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
8000769e:	eb cd 40 80 	pushm	r7,lr
800076a2:	1a 97       	mov	r7,sp
800076a4:	20 3d       	sub	sp,12
800076a6:	ef 4c ff f8 	st.w	r7[-8],r12
800076aa:	16 98       	mov	r8,r11
800076ac:	ef 68 ff f4 	st.b	r7[-12],r8
  unsigned int timeout = SPI_TIMEOUT;
800076b0:	e0 68 27 10 	mov	r8,10000
800076b4:	ef 48 ff fc 	st.w	r7[-4],r8

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800076b8:	c0 f8       	rjmp	800076d6 <spi_unselectChip+0x38>
    if (!timeout--) {
800076ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800076be:	58 08       	cp.w	r8,0
800076c0:	5f 08       	sreq	r8
800076c2:	5c 58       	castu.b	r8
800076c4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800076c8:	20 19       	sub	r9,1
800076ca:	ef 49 ff fc 	st.w	r7[-4],r9
800076ce:	58 08       	cp.w	r8,0
800076d0:	c0 30       	breq	800076d6 <spi_unselectChip+0x38>
      return SPI_ERROR_TIMEOUT;
800076d2:	30 18       	mov	r8,1
800076d4:	c1 68       	rjmp	80007700 <spi_unselectChip+0x62>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800076d6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800076da:	70 48       	ld.w	r8,r8[0x10]
800076dc:	e2 18 02 00 	andl	r8,0x200,COH
800076e0:	ce d0       	breq	800076ba <spi_unselectChip+0x1c>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
800076e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800076e6:	70 18       	ld.w	r8,r8[0x4]
800076e8:	10 99       	mov	r9,r8
800076ea:	ea 19 00 0f 	orh	r9,0xf
800076ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800076f2:	91 19       	st.w	r8[0x4],r9

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
800076f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800076f8:	fc 19 01 00 	movh	r9,0x100
800076fc:	91 09       	st.w	r8[0x0],r9

#ifdef FREERTOS_USED
  xSemaphoreGive(xSPIMutex);
#endif

  return SPI_OK;
800076fe:	30 08       	mov	r8,0
}
80007700:	10 9c       	mov	r12,r8
80007702:	2f dd       	sub	sp,-12
80007704:	e3 cd 80 80 	ldm	sp++,r7,pc

80007708 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80007708:	eb cd 40 80 	pushm	r7,lr
8000770c:	1a 97       	mov	r7,sp
8000770e:	20 5d       	sub	sp,20
80007710:	ef 4c ff f4 	st.w	r7[-12],r12
80007714:	ef 4b ff f0 	st.w	r7[-16],r11
80007718:	ef 4a ff ec 	st.w	r7[-20],r10
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
8000771c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007720:	f1 39 00 0c 	ld.ub	r9,r8[12]
80007724:	30 38       	mov	r8,3
80007726:	f0 09 18 00 	cp.b	r9,r8
8000772a:	e0 8b 00 1d 	brhi	80007764 <spi_setupChipReg+0x5c>
      options->stay_act > 1 ||
8000772e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007732:	f1 39 00 0b 	ld.ub	r9,r8[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80007736:	30 18       	mov	r8,1
80007738:	f0 09 18 00 	cp.b	r9,r8
8000773c:	e0 8b 00 14 	brhi	80007764 <spi_setupChipReg+0x5c>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80007740:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007744:	f1 39 00 08 	ld.ub	r9,r8[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80007748:	30 78       	mov	r8,7
8000774a:	f0 09 18 00 	cp.b	r9,r8
8000774e:	e0 88 00 0b 	brls	80007764 <spi_setupChipReg+0x5c>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80007752:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007756:	f1 39 00 08 	ld.ub	r9,r8[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
8000775a:	31 08       	mov	r8,16
8000775c:	f0 09 18 00 	cp.b	r9,r8
80007760:	e0 88 00 04 	brls	80007768 <spi_setupChipReg+0x60>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
    return SPI_ERROR_ARGUMENT;
80007764:	30 28       	mov	r8,2
80007766:	c8 b8       	rjmp	8000787c <spi_setupChipReg+0x174>
  }

  int baudDiv = getBaudDiv(options, pba_hz);
80007768:	ee fb ff ec 	ld.w	r11,r7[-20]
8000776c:	ee fc ff f0 	ld.w	r12,r7[-16]
80007770:	f0 1f 00 45 	mcall	80007884 <spi_setupChipReg+0x17c>
80007774:	18 98       	mov	r8,r12
80007776:	ef 48 ff fc 	st.w	r7[-4],r8

  if (baudDiv < 0) {
8000777a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000777e:	58 08       	cp.w	r8,0
80007780:	c0 34       	brge	80007786 <spi_setupChipReg+0x7e>
    return SPI_ERROR_ARGUMENT;
80007782:	30 28       	mov	r8,2
80007784:	c7 c8       	rjmp	8000787c <spi_setupChipReg+0x174>
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80007786:	30 08       	mov	r8,0
80007788:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
8000778c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007790:	f1 38 00 0c 	ld.ub	r8,r8[12]
80007794:	a1 98       	lsr	r8,0x1
80007796:	5c 58       	castu.b	r8
80007798:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000779c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800077a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077a4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
800077a8:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
800077ac:	ee f8 ff f0 	ld.w	r8,r7[-16]
800077b0:	f1 38 00 0c 	ld.ub	r8,r8[12]
800077b4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800077b8:	5f 08       	sreq	r8
800077ba:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800077be:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077c2:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800077c6:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
800077ca:	ee f8 ff f0 	ld.w	r8,r7[-16]
800077ce:	f1 38 00 0b 	ld.ub	r8,r8[11]
800077d2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800077d6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800077da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077de:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
800077e2:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
800077e6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800077ea:	f1 38 00 08 	ld.ub	r8,r8[8]
800077ee:	20 88       	sub	r8,8
800077f0:	5c 58       	castu.b	r8
800077f2:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800077f6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800077fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077fe:	f1 d9 d0 84 	bfins	r8,r9,0x4,0x4
80007802:	ef 48 ff f8 	st.w	r7[-8],r8
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80007806:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000780a:	5c 58       	castu.b	r8
8000780c:	ef 68 ff fa 	st.b	r7[-6],r8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80007810:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007814:	f1 38 00 09 	ld.ub	r8,r8[9]
80007818:	ef 68 ff f9 	st.b	r7[-7],r8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
8000781c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007820:	f1 38 00 0a 	ld.ub	r8,r8[10]
80007824:	ef 68 ff f8 	st.b	r7[-8],r8

  switch(options->reg) {
80007828:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000782c:	11 88       	ld.ub	r8,r8[0x0]
8000782e:	58 18       	cp.w	r8,1
80007830:	c1 10       	breq	80007852 <spi_setupChipReg+0x14a>
80007832:	e0 89 00 05 	brgt	8000783c <spi_setupChipReg+0x134>
80007836:	58 08       	cp.w	r8,0
80007838:	c0 70       	breq	80007846 <spi_setupChipReg+0x13e>
8000783a:	c1 e8       	rjmp	80007876 <spi_setupChipReg+0x16e>
8000783c:	58 28       	cp.w	r8,2
8000783e:	c1 00       	breq	8000785e <spi_setupChipReg+0x156>
80007840:	58 38       	cp.w	r8,3
80007842:	c1 40       	breq	8000786a <spi_setupChipReg+0x162>
80007844:	c1 98       	rjmp	80007876 <spi_setupChipReg+0x16e>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80007846:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000784a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000784e:	91 c9       	st.w	r8[0x30],r9
      break;
80007850:	c1 58       	rjmp	8000787a <spi_setupChipReg+0x172>
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80007852:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007856:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000785a:	91 d9       	st.w	r8[0x34],r9
      break;
8000785c:	c0 f8       	rjmp	8000787a <spi_setupChipReg+0x172>
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
8000785e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007862:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007866:	91 e9       	st.w	r8[0x38],r9
      break;
80007868:	c0 98       	rjmp	8000787a <spi_setupChipReg+0x172>
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
8000786a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000786e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007872:	91 f9       	st.w	r8[0x3c],r9
      break;
80007874:	c0 38       	rjmp	8000787a <spi_setupChipReg+0x172>
    default:
      return SPI_ERROR_ARGUMENT;
80007876:	30 28       	mov	r8,2
80007878:	c0 28       	rjmp	8000787c <spi_setupChipReg+0x174>
      while(1);
    }
  }
#endif

  return SPI_OK;
8000787a:	30 08       	mov	r8,0
}
8000787c:	10 9c       	mov	r12,r8
8000787e:	2f bd       	sub	sp,-20
80007880:	e3 cd 80 80 	ldm	sp++,r7,pc
80007884:	80 00       	ld.sh	r0,r0[0x0]
80007886:	74 88       	ld.w	r8,r10[0x20]

80007888 <spi_enable>:


void spi_enable(volatile avr32_spi_t *spi)
{
80007888:	eb cd 40 80 	pushm	r7,lr
8000788c:	1a 97       	mov	r7,sp
8000788e:	20 1d       	sub	sp,4
80007890:	ef 4c ff fc 	st.w	r7[-4],r12
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80007894:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007898:	30 19       	mov	r9,1
8000789a:	91 09       	st.w	r8[0x0],r9
}
8000789c:	2f fd       	sub	sp,-4
8000789e:	e3 cd 80 80 	ldm	sp++,r7,pc

800078a2 <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
800078a2:	eb cd 40 80 	pushm	r7,lr
800078a6:	1a 97       	mov	r7,sp
800078a8:	20 3d       	sub	sp,12
800078aa:	ef 4c ff f8 	st.w	r7[-8],r12
800078ae:	16 98       	mov	r8,r11
800078b0:	ef 58 ff f4 	st.h	r7[-12],r8
  unsigned int timeout = SPI_TIMEOUT;
800078b4:	e0 68 27 10 	mov	r8,10000
800078b8:	ef 48 ff fc 	st.w	r7[-4],r8

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800078bc:	c0 f8       	rjmp	800078da <spi_write+0x38>
    if (!timeout--) {
800078be:	ee f8 ff fc 	ld.w	r8,r7[-4]
800078c2:	58 08       	cp.w	r8,0
800078c4:	5f 08       	sreq	r8
800078c6:	5c 58       	castu.b	r8
800078c8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800078cc:	20 19       	sub	r9,1
800078ce:	ef 49 ff fc 	st.w	r7[-4],r9
800078d2:	58 08       	cp.w	r8,0
800078d4:	c0 30       	breq	800078da <spi_write+0x38>
      return SPI_ERROR_TIMEOUT;
800078d6:	30 18       	mov	r8,1
800078d8:	c0 d8       	rjmp	800078f2 <spi_write+0x50>

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800078da:	ee f8 ff f8 	ld.w	r8,r7[-8]
800078de:	70 48       	ld.w	r8,r8[0x10]
800078e0:	e2 18 00 02 	andl	r8,0x2,COH
800078e4:	ce d0       	breq	800078be <spi_write+0x1c>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800078e6:	ef 19 ff f4 	ld.uh	r9,r7[-12]
800078ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800078ee:	91 39       	st.w	r8[0xc],r9

  return SPI_OK;
800078f0:	30 08       	mov	r8,0
}
800078f2:	10 9c       	mov	r12,r8
800078f4:	2f dd       	sub	sp,-12
800078f6:	e3 cd 80 80 	ldm	sp++,r7,pc

800078fa <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
800078fa:	eb cd 40 80 	pushm	r7,lr
800078fe:	1a 97       	mov	r7,sp
80007900:	20 3d       	sub	sp,12
80007902:	ef 4c ff f8 	st.w	r7[-8],r12
80007906:	ef 4b ff f4 	st.w	r7[-12],r11
  unsigned int timeout = SPI_TIMEOUT;
8000790a:	e0 68 27 10 	mov	r8,10000
8000790e:	ef 48 ff fc 	st.w	r7[-4],r8

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80007912:	c0 f8       	rjmp	80007930 <spi_read+0x36>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80007914:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007918:	58 08       	cp.w	r8,0
8000791a:	5f 08       	sreq	r8
8000791c:	5c 58       	castu.b	r8
8000791e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007922:	20 19       	sub	r9,1
80007924:	ef 49 ff fc 	st.w	r7[-4],r9
80007928:	58 08       	cp.w	r8,0
8000792a:	c0 30       	breq	80007930 <spi_read+0x36>
      return SPI_ERROR_TIMEOUT;
8000792c:	30 18       	mov	r8,1
8000792e:	c1 18       	rjmp	80007950 <spi_read+0x56>

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80007930:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007934:	70 48       	ld.w	r8,r8[0x10]
80007936:	e2 18 02 01 	andl	r8,0x201,COH
8000793a:	e0 48 02 01 	cp.w	r8,513
8000793e:	ce b1       	brne	80007914 <spi_read+0x1a>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80007940:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007944:	70 28       	ld.w	r8,r8[0x8]
80007946:	5c 88       	casts.h	r8
80007948:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000794c:	b2 08       	st.h	r9[0x0],r8

  return SPI_OK;
8000794e:	30 08       	mov	r8,0
}
80007950:	10 9c       	mov	r12,r8
80007952:	2f dd       	sub	sp,-12
80007954:	e3 cd 80 80 	ldm	sp++,r7,pc

80007958 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80007958:	eb cd 40 80 	pushm	r7,lr
8000795c:	1a 97       	mov	r7,sp
8000795e:	20 1d       	sub	sp,4
80007960:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80007964:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007968:	e6 18 00 01 	andh	r8,0x1,COH
8000796c:	5f 08       	sreq	r8
8000796e:	5c 58       	castu.b	r8
}
80007970:	10 9c       	mov	r12,r8
80007972:	2f fd       	sub	sp,-4
80007974:	e3 cd 80 80 	ldm	sp++,r7,pc

80007978 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80007978:	eb cd 40 80 	pushm	r7,lr
8000797c:	1a 97       	mov	r7,sp
8000797e:	20 4d       	sub	sp,16
80007980:	ef 4c ff f8 	st.w	r7[-8],r12
80007984:	ef 4b ff f4 	st.w	r7[-12],r11
80007988:	ef 4a ff f0 	st.w	r7[-16],r10
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000798c:	e1 b8 00 00 	mfsr	r8,0x0
80007990:	10 9c       	mov	r12,r8
80007992:	f0 1f 00 73 	mcall	80007b5c <tc_configure_interrupts+0x1e4>
80007996:	18 98       	mov	r8,r12
80007998:	ef 68 ff ff 	st.b	r7[-1],r8

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000799c:	ee f8 ff f4 	ld.w	r8,r7[-12]
800079a0:	58 28       	cp.w	r8,2
800079a2:	e0 88 00 04 	brls	800079aa <tc_configure_interrupts+0x32>
    return TC_INVALID_ARGUMENT;
800079a6:	3f f8       	mov	r8,-1
800079a8:	cd 68       	rjmp	80007b54 <tc_configure_interrupts+0x1dc>

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
800079aa:	ee fb ff f4 	ld.w	r11,r7[-12]
800079ae:	ee f8 ff f0 	ld.w	r8,r7[-16]
800079b2:	70 08       	ld.w	r8,r8[0x0]
800079b4:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
800079b8:	5c 58       	castu.b	r8
800079ba:	f0 09 15 07 	lsl	r9,r8,0x7
                             bitfield->ldrbs << AVR32_TC_LDRBS_OFFSET |
800079be:	ee f8 ff f0 	ld.w	r8,r7[-16]
800079c2:	70 08       	ld.w	r8,r8[0x0]
800079c4:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
800079c8:	5c 58       	castu.b	r8
800079ca:	a7 68       	lsl	r8,0x6
800079cc:	10 49       	or	r9,r8
                             bitfield->ldras << AVR32_TC_LDRAS_OFFSET |
800079ce:	ee f8 ff f0 	ld.w	r8,r7[-16]
800079d2:	70 08       	ld.w	r8,r8[0x0]
800079d4:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
800079d8:	5c 58       	castu.b	r8
800079da:	a5 78       	lsl	r8,0x5
800079dc:	10 49       	or	r9,r8
                             bitfield->cpcs << AVR32_TC_CPCS_OFFSET |
800079de:	ee f8 ff f0 	ld.w	r8,r7[-16]
800079e2:	70 08       	ld.w	r8,r8[0x0]
800079e4:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800079e8:	5c 58       	castu.b	r8
800079ea:	a5 68       	lsl	r8,0x4
800079ec:	10 49       	or	r9,r8
                             bitfield->cpbs << AVR32_TC_CPBS_OFFSET |
800079ee:	ee f8 ff f0 	ld.w	r8,r7[-16]
800079f2:	70 08       	ld.w	r8,r8[0x0]
800079f4:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800079f8:	5c 58       	castu.b	r8
800079fa:	a3 78       	lsl	r8,0x3
800079fc:	10 49       	or	r9,r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
800079fe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007a02:	70 08       	ld.w	r8,r8[0x0]
80007a04:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80007a08:	5c 58       	castu.b	r8
80007a0a:	a3 68       	lsl	r8,0x2
80007a0c:	10 49       	or	r9,r8
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
80007a0e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007a12:	70 08       	ld.w	r8,r8[0x0]
80007a14:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80007a18:	5c 58       	castu.b	r8
80007a1a:	a1 78       	lsl	r8,0x1
80007a1c:	10 49       	or	r9,r8
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;
80007a1e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007a22:	70 08       	ld.w	r8,r8[0x0]
80007a24:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a28:	5c 58       	castu.b	r8
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80007a2a:	f3 e8 10 08 	or	r8,r9,r8
80007a2e:	10 99       	mov	r9,r8
80007a30:	ee fa ff f8 	ld.w	r10,r7[-8]
80007a34:	f6 08 15 06 	lsl	r8,r11,0x6
80007a38:	f4 08 00 08 	add	r8,r10,r8
80007a3c:	2d c8       	sub	r8,-36
80007a3e:	91 09       	st.w	r8[0x0],r9
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80007a40:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007a44:	30 08       	mov	r8,0
80007a46:	f0 09 18 00 	cp.b	r9,r8
80007a4a:	c0 20       	breq	80007a4e <tc_configure_interrupts+0xd6>
80007a4c:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80007a4e:	ee fb ff f4 	ld.w	r11,r7[-12]
80007a52:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007a56:	70 08       	ld.w	r8,r8[0x0]
80007a58:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80007a5c:	5c 58       	castu.b	r8
80007a5e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a62:	c0 41       	brne	80007a6a <tc_configure_interrupts+0xf2>
80007a64:	e0 69 00 80 	mov	r9,128
80007a68:	c0 28       	rjmp	80007a6c <tc_configure_interrupts+0xf4>
80007a6a:	30 09       	mov	r9,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80007a6c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007a70:	70 08       	ld.w	r8,r8[0x0]
80007a72:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80007a76:	5c 58       	castu.b	r8
80007a78:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a7c:	c0 31       	brne	80007a82 <tc_configure_interrupts+0x10a>
80007a7e:	34 08       	mov	r8,64
80007a80:	c0 28       	rjmp	80007a84 <tc_configure_interrupts+0x10c>
80007a82:	30 08       	mov	r8,0
80007a84:	10 49       	or	r9,r8
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80007a86:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007a8a:	70 08       	ld.w	r8,r8[0x0]
80007a8c:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80007a90:	5c 58       	castu.b	r8
80007a92:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a96:	c0 31       	brne	80007a9c <tc_configure_interrupts+0x124>
80007a98:	32 08       	mov	r8,32
80007a9a:	c0 28       	rjmp	80007a9e <tc_configure_interrupts+0x126>
80007a9c:	30 08       	mov	r8,0
80007a9e:	10 49       	or	r9,r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80007aa0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007aa4:	70 08       	ld.w	r8,r8[0x0]
80007aa6:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80007aaa:	5c 58       	castu.b	r8
80007aac:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007ab0:	c0 31       	brne	80007ab6 <tc_configure_interrupts+0x13e>
80007ab2:	31 08       	mov	r8,16
80007ab4:	c0 28       	rjmp	80007ab8 <tc_configure_interrupts+0x140>
80007ab6:	30 08       	mov	r8,0
80007ab8:	10 49       	or	r9,r8
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80007aba:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007abe:	70 08       	ld.w	r8,r8[0x0]
80007ac0:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80007ac4:	5c 58       	castu.b	r8
80007ac6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007aca:	c0 31       	brne	80007ad0 <tc_configure_interrupts+0x158>
80007acc:	30 88       	mov	r8,8
80007ace:	c0 28       	rjmp	80007ad2 <tc_configure_interrupts+0x15a>
80007ad0:	30 08       	mov	r8,0
80007ad2:	10 49       	or	r9,r8
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80007ad4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007ad8:	70 08       	ld.w	r8,r8[0x0]
80007ada:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80007ade:	5c 58       	castu.b	r8
80007ae0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007ae4:	c0 31       	brne	80007aea <tc_configure_interrupts+0x172>
80007ae6:	30 48       	mov	r8,4
80007ae8:	c0 28       	rjmp	80007aec <tc_configure_interrupts+0x174>
80007aea:	30 08       	mov	r8,0
80007aec:	10 49       	or	r9,r8
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80007aee:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007af2:	70 08       	ld.w	r8,r8[0x0]
80007af4:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80007af8:	5c 58       	castu.b	r8
80007afa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007afe:	c0 31       	brne	80007b04 <tc_configure_interrupts+0x18c>
80007b00:	30 28       	mov	r8,2
80007b02:	c0 28       	rjmp	80007b06 <tc_configure_interrupts+0x18e>
80007b04:	30 08       	mov	r8,0
80007b06:	10 49       	or	r9,r8
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
80007b08:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007b0c:	70 08       	ld.w	r8,r8[0x0]
80007b0e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b12:	5c 58       	castu.b	r8
80007b14:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b18:	5f 08       	sreq	r8
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80007b1a:	f3 e8 10 08 	or	r8,r9,r8
80007b1e:	10 99       	mov	r9,r8
80007b20:	ee fa ff f8 	ld.w	r10,r7[-8]
80007b24:	f6 08 15 06 	lsl	r8,r11,0x6
80007b28:	f4 08 00 08 	add	r8,r10,r8
80007b2c:	2d 88       	sub	r8,-40
80007b2e:	91 09       	st.w	r8[0x0],r9
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80007b30:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007b34:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007b38:	a1 78       	lsl	r8,0x1
80007b3a:	2f f8       	sub	r8,-1
80007b3c:	a5 78       	lsl	r8,0x5
80007b3e:	f2 08 00 08 	add	r8,r9,r8
80007b42:	70 08       	ld.w	r8,r8[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80007b44:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007b48:	30 08       	mov	r8,0
80007b4a:	f0 09 18 00 	cp.b	r9,r8
80007b4e:	c0 20       	breq	80007b52 <tc_configure_interrupts+0x1da>
80007b50:	d5 03       	csrf	0x10

  return 0;
80007b52:	30 08       	mov	r8,0
}
80007b54:	10 9c       	mov	r12,r8
80007b56:	2f cd       	sub	sp,-16
80007b58:	e3 cd 80 80 	ldm	sp++,r7,pc
80007b5c:	80 00       	ld.sh	r0,r0[0x0]
80007b5e:	79 58       	ld.w	r8,r12[0x54]

80007b60 <tc_init_waveform>:
  return 0;
}


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
80007b60:	eb cd 40 80 	pushm	r7,lr
80007b64:	1a 97       	mov	r7,sp
80007b66:	20 2d       	sub	sp,8
80007b68:	ef 4c ff fc 	st.w	r7[-4],r12
80007b6c:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80007b70:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b74:	70 08       	ld.w	r8,r8[0x0]
80007b76:	58 28       	cp.w	r8,2
80007b78:	e0 88 00 04 	brls	80007b80 <tc_init_waveform+0x20>
    return TC_INVALID_ARGUMENT;
80007b7c:	3f f8       	mov	r8,-1
80007b7e:	c9 78       	rjmp	80007cac <tc_init_waveform+0x14c>

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80007b80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b84:	70 09       	ld.w	r9,r8[0x0]
80007b86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b8a:	70 18       	ld.w	r8,r8[0x4]
80007b8c:	f1 d8 c3 c2 	bfextu	r8,r8,0x1e,0x2
80007b90:	5c 58       	castu.b	r8
80007b92:	f0 0a 15 1e 	lsl	r10,r8,0x1e
                                  opt->beevt << AVR32_TC_BEEVT_OFFSET |
80007b96:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007b9a:	70 18       	ld.w	r8,r8[0x4]
80007b9c:	f1 d8 c3 82 	bfextu	r8,r8,0x1c,0x2
80007ba0:	5c 58       	castu.b	r8
80007ba2:	bd 68       	lsl	r8,0x1c
80007ba4:	10 4a       	or	r10,r8
                                  opt->bcpc << AVR32_TC_BCPC_OFFSET |
80007ba6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007baa:	70 18       	ld.w	r8,r8[0x4]
80007bac:	f1 d8 c3 42 	bfextu	r8,r8,0x1a,0x2
80007bb0:	5c 58       	castu.b	r8
80007bb2:	bb 68       	lsl	r8,0x1a
80007bb4:	10 4a       	or	r10,r8
                                  opt->bcpb << AVR32_TC_BCPB_OFFSET |
80007bb6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007bba:	70 18       	ld.w	r8,r8[0x4]
80007bbc:	f1 d8 c3 02 	bfextu	r8,r8,0x18,0x2
80007bc0:	5c 58       	castu.b	r8
80007bc2:	b9 68       	lsl	r8,0x18
80007bc4:	10 4a       	or	r10,r8
                                  opt->aswtrg << AVR32_TC_ASWTRG_OFFSET |
80007bc6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007bca:	70 18       	ld.w	r8,r8[0x4]
80007bcc:	f1 d8 c2 c2 	bfextu	r8,r8,0x16,0x2
80007bd0:	5c 58       	castu.b	r8
80007bd2:	b7 68       	lsl	r8,0x16
80007bd4:	10 4a       	or	r10,r8
                                  opt->aeevt << AVR32_TC_AEEVT_OFFSET |
80007bd6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007bda:	70 18       	ld.w	r8,r8[0x4]
80007bdc:	f1 d8 c2 82 	bfextu	r8,r8,0x14,0x2
80007be0:	5c 58       	castu.b	r8
80007be2:	b5 68       	lsl	r8,0x14
80007be4:	10 4a       	or	r10,r8
                                  opt->acpc << AVR32_TC_ACPC_OFFSET |
80007be6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007bea:	70 18       	ld.w	r8,r8[0x4]
80007bec:	f1 d8 c2 42 	bfextu	r8,r8,0x12,0x2
80007bf0:	5c 58       	castu.b	r8
80007bf2:	b3 68       	lsl	r8,0x12
80007bf4:	10 4a       	or	r10,r8
                                  opt->acpa << AVR32_TC_ACPA_OFFSET |
80007bf6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007bfa:	70 18       	ld.w	r8,r8[0x4]
80007bfc:	f1 d8 c2 02 	bfextu	r8,r8,0x10,0x2
80007c00:	5c 58       	castu.b	r8
80007c02:	b1 68       	lsl	r8,0x10
80007c04:	f5 e8 10 08 	or	r8,r10,r8
                                  1 << AVR32_TC_WAVE_OFFSET |
80007c08:	10 9a       	mov	r10,r8
80007c0a:	af ba       	sbr	r10,0xf
                                  opt->wavsel << AVR32_TC_WAVSEL_OFFSET |
80007c0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c10:	70 18       	ld.w	r8,r8[0x4]
80007c12:	f1 d8 c1 a2 	bfextu	r8,r8,0xd,0x2
80007c16:	5c 58       	castu.b	r8
80007c18:	ad 78       	lsl	r8,0xd
80007c1a:	10 4a       	or	r10,r8
                                  opt->enetrg << AVR32_TC_ENETRG_OFFSET |
80007c1c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c20:	70 18       	ld.w	r8,r8[0x4]
80007c22:	f1 d8 c1 81 	bfextu	r8,r8,0xc,0x1
80007c26:	5c 58       	castu.b	r8
80007c28:	ad 68       	lsl	r8,0xc
80007c2a:	10 4a       	or	r10,r8
                                  opt->eevt << AVR32_TC_EEVT_OFFSET |
80007c2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c30:	70 18       	ld.w	r8,r8[0x4]
80007c32:	f1 d8 c1 42 	bfextu	r8,r8,0xa,0x2
80007c36:	5c 58       	castu.b	r8
80007c38:	ab 68       	lsl	r8,0xa
80007c3a:	10 4a       	or	r10,r8
                                  opt->eevtedg << AVR32_TC_EEVTEDG_OFFSET |
80007c3c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c40:	70 18       	ld.w	r8,r8[0x4]
80007c42:	f1 d8 c1 02 	bfextu	r8,r8,0x8,0x2
80007c46:	5c 58       	castu.b	r8
80007c48:	a9 68       	lsl	r8,0x8
80007c4a:	10 4a       	or	r10,r8
                                  opt->cpcdis << AVR32_TC_CPCDIS_OFFSET |
80007c4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c50:	70 18       	ld.w	r8,r8[0x4]
80007c52:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80007c56:	5c 58       	castu.b	r8
80007c58:	a7 78       	lsl	r8,0x7
80007c5a:	10 4a       	or	r10,r8
                                  opt->cpcstop << AVR32_TC_CPCSTOP_OFFSET |
80007c5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c60:	70 18       	ld.w	r8,r8[0x4]
80007c62:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80007c66:	5c 58       	castu.b	r8
80007c68:	a7 68       	lsl	r8,0x6
80007c6a:	10 4a       	or	r10,r8
                                  opt->burst << AVR32_TC_BURST_OFFSET |
80007c6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c70:	70 18       	ld.w	r8,r8[0x4]
80007c72:	f1 d8 c0 82 	bfextu	r8,r8,0x4,0x2
80007c76:	5c 58       	castu.b	r8
80007c78:	a5 68       	lsl	r8,0x4
80007c7a:	10 4a       	or	r10,r8
                                  opt->clki << AVR32_TC_CLKI_OFFSET |
80007c7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c80:	70 18       	ld.w	r8,r8[0x4]
80007c82:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80007c86:	5c 58       	castu.b	r8
80007c88:	a3 78       	lsl	r8,0x3
80007c8a:	10 4a       	or	r10,r8
                                  opt->tcclks << AVR32_TC_TCCLKS_OFFSET;
80007c8c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007c90:	70 18       	ld.w	r8,r8[0x4]
80007c92:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80007c96:	5c 58       	castu.b	r8
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80007c98:	f5 e8 10 08 	or	r8,r10,r8
80007c9c:	10 9a       	mov	r10,r8
80007c9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007ca2:	a5 69       	lsl	r9,0x4
80007ca4:	2f f9       	sub	r9,-1
80007ca6:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
                                  opt->cpcstop << AVR32_TC_CPCSTOP_OFFSET |
                                  opt->burst << AVR32_TC_BURST_OFFSET |
                                  opt->clki << AVR32_TC_CLKI_OFFSET |
                                  opt->tcclks << AVR32_TC_TCCLKS_OFFSET;

  return 0;
80007caa:	30 08       	mov	r8,0
}
80007cac:	10 9c       	mov	r12,r8
80007cae:	2f ed       	sub	sp,-8
80007cb0:	e3 cd 80 80 	ldm	sp++,r7,pc

80007cb4 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
80007cb4:	eb cd 40 80 	pushm	r7,lr
80007cb8:	1a 97       	mov	r7,sp
80007cba:	20 2d       	sub	sp,8
80007cbc:	ef 4c ff fc 	st.w	r7[-4],r12
80007cc0:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80007cc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007cc8:	58 28       	cp.w	r8,2
80007cca:	e0 88 00 04 	brls	80007cd2 <tc_start+0x1e>
    return TC_INVALID_ARGUMENT;
80007cce:	3f f8       	mov	r8,-1
80007cd0:	c0 b8       	rjmp	80007ce6 <tc_start+0x32>

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80007cd2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007cd6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007cda:	a7 68       	lsl	r8,0x6
80007cdc:	f2 08 00 08 	add	r8,r9,r8
80007ce0:	30 59       	mov	r9,5
80007ce2:	91 09       	st.w	r8[0x0],r9

  return 0;
80007ce4:	30 08       	mov	r8,0
}
80007ce6:	10 9c       	mov	r12,r8
80007ce8:	2f ed       	sub	sp,-8
80007cea:	e3 cd 80 80 	ldm	sp++,r7,pc

80007cee <tc_read_sr>:
  tc->bcr = AVR32_TC_BCR_SYNC_MASK;
}


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
80007cee:	eb cd 40 80 	pushm	r7,lr
80007cf2:	1a 97       	mov	r7,sp
80007cf4:	20 2d       	sub	sp,8
80007cf6:	ef 4c ff fc 	st.w	r7[-4],r12
80007cfa:	ef 4b ff f8 	st.w	r7[-8],r11
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80007cfe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d02:	58 28       	cp.w	r8,2
80007d04:	e0 88 00 04 	brls	80007d0c <tc_read_sr+0x1e>
    return TC_INVALID_ARGUMENT;
80007d08:	3f f8       	mov	r8,-1
80007d0a:	c0 b8       	rjmp	80007d20 <tc_read_sr+0x32>

  return tc->channel[channel].sr;
80007d0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d10:	ee f9 ff fc 	ld.w	r9,r7[-4]
80007d14:	a1 78       	lsl	r8,0x1
80007d16:	2f f8       	sub	r8,-1
80007d18:	a5 78       	lsl	r8,0x5
80007d1a:	f2 08 00 08 	add	r8,r9,r8
80007d1e:	70 08       	ld.w	r8,r8[0x0]
}
80007d20:	10 9c       	mov	r12,r8
80007d22:	2f ed       	sub	sp,-8
80007d24:	e3 cd 80 80 	ldm	sp++,r7,pc

80007d28 <tc_write_rc>:
  return value;
}


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
80007d28:	eb cd 40 80 	pushm	r7,lr
80007d2c:	1a 97       	mov	r7,sp
80007d2e:	20 3d       	sub	sp,12
80007d30:	ef 4c ff fc 	st.w	r7[-4],r12
80007d34:	ef 4b ff f8 	st.w	r7[-8],r11
80007d38:	14 98       	mov	r8,r10
80007d3a:	ef 58 ff f4 	st.h	r7[-12],r8
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80007d3e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d42:	58 28       	cp.w	r8,2
80007d44:	e0 88 00 04 	brls	80007d4c <tc_write_rc+0x24>
    return TC_INVALID_ARGUMENT;
80007d48:	3f f8       	mov	r8,-1
80007d4a:	c2 78       	rjmp	80007d98 <tc_write_rc+0x70>

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80007d4c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007d50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007d54:	a5 69       	lsl	r9,0x4
80007d56:	2f f9       	sub	r9,-1
80007d58:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80007d5c:	e2 18 80 00 	andl	r8,0x8000,COH
80007d60:	c1 a0       	breq	80007d94 <tc_write_rc+0x6c>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80007d62:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007d66:	ee f9 ff f8 	ld.w	r9,r7[-8]
80007d6a:	ee fa ff fc 	ld.w	r10,r7[-4]
80007d6e:	a7 69       	lsl	r9,0x6
80007d70:	f4 09 00 09 	add	r9,r10,r9
80007d74:	2e 49       	sub	r9,-28
80007d76:	72 09       	ld.w	r9,r9[0x0]
80007d78:	12 9a       	mov	r10,r9
80007d7a:	e0 1a 00 00 	andl	r10,0x0
80007d7e:	ef 19 ff f4 	ld.uh	r9,r7[-12]
80007d82:	f5 e9 10 09 	or	r9,r10,r9
80007d86:	ee fa ff fc 	ld.w	r10,r7[-4]
80007d8a:	a7 68       	lsl	r8,0x6
80007d8c:	f4 08 00 08 	add	r8,r10,r8
80007d90:	2e 48       	sub	r8,-28
80007d92:	91 09       	st.w	r8[0x0],r9

  return value;
80007d94:	ef 18 ff f4 	ld.uh	r8,r7[-12]
}
80007d98:	10 9c       	mov	r12,r8
80007d9a:	2f dd       	sub	sp,-12
80007d9c:	e3 cd 80 80 	ldm	sp++,r7,pc

80007da0 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80007da0:	eb cd 40 80 	pushm	r7,lr
80007da4:	1a 97       	mov	r7,sp
80007da6:	20 1d       	sub	sp,4
80007da8:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80007dac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007db0:	e6 18 00 01 	andh	r8,0x1,COH
80007db4:	5f 08       	sreq	r8
80007db6:	5c 58       	castu.b	r8
}
80007db8:	10 9c       	mov	r12,r8
80007dba:	2f fd       	sub	sp,-4
80007dbc:	e3 cd 80 80 	ldm	sp++,r7,pc

80007dc0 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80007dc0:	eb cd 40 80 	pushm	r7,lr
80007dc4:	1a 97       	mov	r7,sp
80007dc6:	20 7d       	sub	sp,28
80007dc8:	ef 4c ff ec 	st.w	r7[-20],r12
80007dcc:	ef 4b ff e8 	st.w	r7[-24],r11
80007dd0:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80007dd4:	ee f8 ff e8 	ld.w	r8,r7[-24]
80007dd8:	f0 09 15 04 	lsl	r9,r8,0x4
80007ddc:	ee f8 ff e4 	ld.w	r8,r7[-28]
80007de0:	10 39       	cp.w	r9,r8
80007de2:	e0 8b 00 04 	brhi	80007dea <usart_set_async_baudrate+0x2a>
80007de6:	31 08       	mov	r8,16
80007de8:	c0 28       	rjmp	80007dec <usart_set_async_baudrate+0x2c>
80007dea:	30 88       	mov	r8,8
80007dec:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80007df0:	ee f8 ff e4 	ld.w	r8,r7[-28]
80007df4:	f0 09 15 03 	lsl	r9,r8,0x3
80007df8:	ee fa ff f0 	ld.w	r10,r7[-16]
80007dfc:	ee f8 ff e8 	ld.w	r8,r7[-24]
80007e00:	f4 08 02 48 	mul	r8,r10,r8
80007e04:	a1 98       	lsr	r8,0x1
80007e06:	f2 08 00 08 	add	r8,r9,r8
80007e0a:	ee fa ff f0 	ld.w	r10,r7[-16]
80007e0e:	ee f9 ff e8 	ld.w	r9,r7[-24]
80007e12:	f4 09 02 49 	mul	r9,r10,r9
80007e16:	f0 09 0d 08 	divu	r8,r8,r9
80007e1a:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80007e1e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007e22:	a3 98       	lsr	r8,0x3
80007e24:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80007e28:	ee f8 ff f4 	ld.w	r8,r7[-12]
80007e2c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80007e30:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80007e34:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007e38:	58 08       	cp.w	r8,0
80007e3a:	c0 70       	breq	80007e48 <usart_set_async_baudrate+0x88>
80007e3c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007e40:	e0 48 ff ff 	cp.w	r8,65535
80007e44:	e0 88 00 04 	brls	80007e4c <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80007e48:	30 18       	mov	r8,1
80007e4a:	c2 08       	rjmp	80007e8a <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80007e4c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007e50:	70 18       	ld.w	r8,r8[0x4]
80007e52:	10 99       	mov	r9,r8
80007e54:	e4 19 ff f7 	andh	r9,0xfff7
80007e58:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80007e5c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80007e60:	59 08       	cp.w	r8,16
80007e62:	c0 40       	breq	80007e6a <usart_set_async_baudrate+0xaa>
80007e64:	e8 68 00 00 	mov	r8,524288
80007e68:	c0 28       	rjmp	80007e6c <usart_set_async_baudrate+0xac>
80007e6a:	30 08       	mov	r8,0
80007e6c:	10 49       	or	r9,r8
80007e6e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007e72:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
80007e74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007e78:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80007e7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007e80:	10 49       	or	r9,r8
80007e82:	ee f8 ff ec 	ld.w	r8,r7[-20]
80007e86:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80007e88:	30 08       	mov	r8,0
}
80007e8a:	10 9c       	mov	r12,r8
80007e8c:	2f 9d       	sub	sp,-28
80007e8e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007e92:	d7 03       	nop

80007e94 <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
80007e94:	eb cd 40 80 	pushm	r7,lr
80007e98:	1a 97       	mov	r7,sp
80007e9a:	20 2d       	sub	sp,8
80007e9c:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80007ea0:	e1 b8 00 00 	mfsr	r8,0x0
80007ea4:	10 9c       	mov	r12,r8
80007ea6:	f0 1f 00 18 	mcall	80007f04 <usart_reset+0x70>
80007eaa:	18 98       	mov	r8,r12
80007eac:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80007eb0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007eb4:	30 08       	mov	r8,0
80007eb6:	f0 09 18 00 	cp.b	r9,r8
80007eba:	c0 20       	breq	80007ebe <usart_reset+0x2a>
80007ebc:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80007ebe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ec2:	3f f9       	mov	r9,-1
80007ec4:	91 39       	st.w	r8[0xc],r9
  usart->csr;
80007ec6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007eca:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80007ecc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007ed0:	30 08       	mov	r8,0
80007ed2:	f0 09 18 00 	cp.b	r9,r8
80007ed6:	c0 20       	breq	80007eda <usart_reset+0x46>
80007ed8:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80007eda:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ede:	30 09       	mov	r9,0
80007ee0:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
80007ee2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ee6:	30 09       	mov	r9,0
80007ee8:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
80007eea:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007eee:	30 09       	mov	r9,0
80007ef0:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80007ef2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007ef6:	ea 69 61 0c 	mov	r9,680204
80007efa:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80007efc:	2f ed       	sub	sp,-8
80007efe:	e3 cd 80 80 	ldm	sp++,r7,pc
80007f02:	00 00       	add	r0,r0
80007f04:	80 00       	ld.sh	r0,r0[0x0]
80007f06:	7d a0       	ld.w	r0,lr[0x68]

80007f08 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80007f08:	eb cd 40 80 	pushm	r7,lr
80007f0c:	1a 97       	mov	r7,sp
80007f0e:	20 3d       	sub	sp,12
80007f10:	ef 4c ff fc 	st.w	r7[-4],r12
80007f14:	ef 4b ff f8 	st.w	r7[-8],r11
80007f18:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80007f1c:	ee fc ff fc 	ld.w	r12,r7[-4]
80007f20:	f0 1f 00 54 	mcall	80008070 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80007f24:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f28:	58 08       	cp.w	r8,0
80007f2a:	c3 90       	breq	80007f9c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80007f2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f30:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007f32:	30 48       	mov	r8,4
80007f34:	f0 09 18 00 	cp.b	r9,r8
80007f38:	e0 88 00 32 	brls	80007f9c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80007f3c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f40:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007f42:	30 98       	mov	r8,9
80007f44:	f0 09 18 00 	cp.b	r9,r8
80007f48:	e0 8b 00 2a 	brhi	80007f9c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80007f4c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f50:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007f52:	30 78       	mov	r8,7
80007f54:	f0 09 18 00 	cp.b	r9,r8
80007f58:	e0 8b 00 22 	brhi	80007f9c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80007f5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f60:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007f62:	e0 68 01 01 	mov	r8,257
80007f66:	f0 09 19 00 	cp.h	r9,r8
80007f6a:	e0 8b 00 19 	brhi	80007f9c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80007f6e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f72:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007f76:	30 38       	mov	r8,3
80007f78:	f0 09 18 00 	cp.b	r9,r8
80007f7c:	e0 8b 00 10 	brhi	80007f9c <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80007f80:	ee f9 ff f4 	ld.w	r9,r7[-12]
80007f84:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007f88:	70 08       	ld.w	r8,r8[0x0]
80007f8a:	12 9a       	mov	r10,r9
80007f8c:	10 9b       	mov	r11,r8
80007f8e:	ee fc ff fc 	ld.w	r12,r7[-4]
80007f92:	f0 1f 00 39 	mcall	80008074 <usart_init_rs232+0x16c>
80007f96:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80007f98:	58 18       	cp.w	r8,1
80007f9a:	c0 31       	brne	80007fa0 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80007f9c:	30 18       	mov	r8,1
80007f9e:	c6 48       	rjmp	80008066 <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80007fa0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007fa4:	11 c9       	ld.ub	r9,r8[0x4]
80007fa6:	30 98       	mov	r8,9
80007fa8:	f0 09 18 00 	cp.b	r9,r8
80007fac:	c0 a1       	brne	80007fc0 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80007fae:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007fb2:	70 18       	ld.w	r8,r8[0x4]
80007fb4:	10 99       	mov	r9,r8
80007fb6:	b1 b9       	sbr	r9,0x11
80007fb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007fbc:	91 19       	st.w	r8[0x4],r9
80007fbe:	c0 d8       	rjmp	80007fd8 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80007fc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007fc4:	70 19       	ld.w	r9,r8[0x4]
80007fc6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007fca:	11 c8       	ld.ub	r8,r8[0x4]
80007fcc:	20 58       	sub	r8,5
80007fce:	a7 68       	lsl	r8,0x6
80007fd0:	10 49       	or	r9,r8
80007fd2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007fd6:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80007fd8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007fdc:	70 19       	ld.w	r9,r8[0x4]
80007fde:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007fe2:	11 d8       	ld.ub	r8,r8[0x5]
80007fe4:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
80007fe8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007fec:	f1 38 00 08 	ld.ub	r8,r8[8]
80007ff0:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80007ff2:	f5 e8 10 08 	or	r8,r10,r8
80007ff6:	10 49       	or	r9,r8
80007ff8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007ffc:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80007ffe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008002:	90 39       	ld.sh	r9,r8[0x6]
80008004:	30 28       	mov	r8,2
80008006:	f0 09 19 00 	cp.h	r9,r8
8000800a:	e0 88 00 14 	brls	80008032 <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
8000800e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008012:	70 18       	ld.w	r8,r8[0x4]
80008014:	10 99       	mov	r9,r8
80008016:	ad b9       	sbr	r9,0xd
80008018:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000801c:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000801e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008022:	90 38       	ld.sh	r8,r8[0x6]
80008024:	5c 78       	castu.h	r8
80008026:	20 28       	sub	r8,2
80008028:	10 99       	mov	r9,r8
8000802a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000802e:	91 a9       	st.w	r8[0x28],r9
80008030:	c0 d8       	rjmp	8000804a <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80008032:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008036:	70 19       	ld.w	r9,r8[0x4]
80008038:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000803c:	90 38       	ld.sh	r8,r8[0x6]
8000803e:	5c 78       	castu.h	r8
80008040:	ad 68       	lsl	r8,0xc
80008042:	10 49       	or	r9,r8
80008044:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008048:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
8000804a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000804e:	70 18       	ld.w	r8,r8[0x4]
80008050:	10 99       	mov	r9,r8
80008052:	e0 19 ff f0 	andl	r9,0xfff0
80008056:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000805a:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
8000805c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008060:	35 09       	mov	r9,80
80008062:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80008064:	30 08       	mov	r8,0
}
80008066:	10 9c       	mov	r12,r8
80008068:	2f dd       	sub	sp,-12
8000806a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000806e:	00 00       	add	r0,r0
80008070:	80 00       	ld.sh	r0,r0[0x0]
80008072:	7e 94       	ld.w	r4,pc[0x24]
80008074:	80 00       	ld.sh	r0,r0[0x0]
80008076:	7d c0       	ld.w	r0,lr[0x70]

80008078 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80008078:	eb cd 40 80 	pushm	r7,lr
8000807c:	1a 97       	mov	r7,sp
8000807e:	20 3d       	sub	sp,12
80008080:	ef 4c ff f8 	st.w	r7[-8],r12
80008084:	ef 4b ff f4 	st.w	r7[-12],r11
80008088:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000808c:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80008090:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008094:	70 58       	ld.w	r8,r8[0x14]
80008096:	e2 18 00 02 	andl	r8,0x2,COH
8000809a:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
8000809c:	58 08       	cp.w	r8,0
8000809e:	c0 a0       	breq	800080b2 <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800080a0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800080a4:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
800080a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800080ac:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
800080ae:	30 08       	mov	r8,0
800080b0:	c0 28       	rjmp	800080b4 <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
800080b2:	30 28       	mov	r8,2
}
800080b4:	10 9c       	mov	r12,r8
800080b6:	2f dd       	sub	sp,-12
800080b8:	e3 cd 80 80 	ldm	sp++,r7,pc

800080bc <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800080bc:	eb cd 40 80 	pushm	r7,lr
800080c0:	1a 97       	mov	r7,sp
800080c2:	20 3d       	sub	sp,12
800080c4:	ef 4c ff f8 	st.w	r7[-8],r12
800080c8:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
800080cc:	e0 68 27 10 	mov	r8,10000
800080d0:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
800080d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800080d8:	58 08       	cp.w	r8,0
800080da:	5f 08       	sreq	r8
800080dc:	5c 58       	castu.b	r8
800080de:	ee f9 ff fc 	ld.w	r9,r7[-4]
800080e2:	20 19       	sub	r9,1
800080e4:	ef 49 ff fc 	st.w	r7[-4],r9
800080e8:	58 08       	cp.w	r8,0
800080ea:	c0 30       	breq	800080f0 <usart_putchar+0x34>
800080ec:	3f f8       	mov	r8,-1
800080ee:	c0 b8       	rjmp	80008104 <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800080f0:	ee fb ff f4 	ld.w	r11,r7[-12]
800080f4:	ee fc ff f8 	ld.w	r12,r7[-8]
800080f8:	f0 1f 00 05 	mcall	8000810c <usart_putchar+0x50>
800080fc:	18 98       	mov	r8,r12
800080fe:	58 08       	cp.w	r8,0
80008100:	ce a1       	brne	800080d4 <usart_putchar+0x18>

  return USART_SUCCESS;
80008102:	30 08       	mov	r8,0
}
80008104:	10 9c       	mov	r12,r8
80008106:	2f dd       	sub	sp,-12
80008108:	e3 cd 80 80 	ldm	sp++,r7,pc
8000810c:	80 00       	ld.sh	r0,r0[0x0]
8000810e:	80 78       	ld.sh	r8,r0[0xe]

80008110 <usart_read_char>:


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80008110:	eb cd 40 80 	pushm	r7,lr
80008114:	1a 97       	mov	r7,sp
80008116:	20 3d       	sub	sp,12
80008118:	ef 4c ff f8 	st.w	r7[-8],r12
8000811c:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80008120:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008124:	70 58       	ld.w	r8,r8[0x14]
80008126:	e2 18 00 e0 	andl	r8,0xe0,COH
8000812a:	c0 30       	breq	80008130 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
8000812c:	30 48       	mov	r8,4
8000812e:	c1 68       	rjmp	8000815a <usart_read_char+0x4a>
80008130:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008134:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80008138:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000813c:	70 58       	ld.w	r8,r8[0x14]
8000813e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80008142:	c0 b0       	breq	80008158 <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80008144:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008148:	70 68       	ld.w	r8,r8[0x18]
8000814a:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000814e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008152:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
80008154:	30 08       	mov	r8,0
80008156:	c0 28       	rjmp	8000815a <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80008158:	30 38       	mov	r8,3
}
8000815a:	10 9c       	mov	r12,r8
8000815c:	2f dd       	sub	sp,-12
8000815e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008162:	d7 03       	nop

80008164 <usart_getchar>:


int usart_getchar(volatile avr32_usart_t *usart)
{
80008164:	eb cd 40 80 	pushm	r7,lr
80008168:	1a 97       	mov	r7,sp
8000816a:	20 3d       	sub	sp,12
8000816c:	ef 4c ff f4 	st.w	r7[-12],r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80008170:	ee c8 00 08 	sub	r8,r7,8
80008174:	10 9b       	mov	r11,r8
80008176:	ee fc ff f4 	ld.w	r12,r7[-12]
8000817a:	f0 1f 00 0b 	mcall	800081a4 <usart_getchar+0x40>
8000817e:	18 98       	mov	r8,r12
80008180:	ef 48 ff fc 	st.w	r7[-4],r8
80008184:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008188:	58 38       	cp.w	r8,3
8000818a:	cf 30       	breq	80008170 <usart_getchar+0xc>

  if (ret == USART_RX_ERROR)
8000818c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008190:	58 48       	cp.w	r8,4
80008192:	c0 31       	brne	80008198 <usart_getchar+0x34>
    return USART_FAILURE;
80008194:	3f f8       	mov	r8,-1
80008196:	c0 38       	rjmp	8000819c <usart_getchar+0x38>

  return c;
80008198:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000819c:	10 9c       	mov	r12,r8
8000819e:	2f dd       	sub	sp,-12
800081a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800081a4:	80 00       	ld.sh	r0,r0[0x0]
800081a6:	81 10       	st.w	r0[0x4],r0

800081a8 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800081a8:	eb cd 40 80 	pushm	r7,lr
800081ac:	1a 97       	mov	r7,sp
800081ae:	20 2d       	sub	sp,8
800081b0:	ef 4c ff fc 	st.w	r7[-4],r12
800081b4:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
800081b8:	c0 e8       	rjmp	800081d4 <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
800081ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800081be:	11 88       	ld.ub	r8,r8[0x0]
800081c0:	ee f9 ff f8 	ld.w	r9,r7[-8]
800081c4:	2f f9       	sub	r9,-1
800081c6:	ef 49 ff f8 	st.w	r7[-8],r9
800081ca:	10 9b       	mov	r11,r8
800081cc:	ee fc ff fc 	ld.w	r12,r7[-4]
800081d0:	f0 1f 00 05 	mcall	800081e4 <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800081d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800081d8:	11 88       	ld.ub	r8,r8[0x0]
800081da:	58 08       	cp.w	r8,0
800081dc:	ce f1       	brne	800081ba <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
800081de:	2f ed       	sub	sp,-8
800081e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800081e4:	80 00       	ld.sh	r0,r0[0x0]
800081e6:	80 bc       	ld.uh	r12,r0[0x6]

800081e8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
800081e8:	eb cd 40 80 	pushm	r7,lr
800081ec:	1a 97       	mov	r7,sp
800081ee:	20 1d       	sub	sp,4
800081f0:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800081f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800081f8:	2f 88       	sub	r8,-8
800081fa:	10 99       	mov	r9,r8
800081fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008200:	91 19       	st.w	r8[0x4],r9

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80008202:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008206:	3f f9       	mov	r9,-1
80008208:	91 29       	st.w	r8[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000820a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000820e:	2f 88       	sub	r8,-8
80008210:	10 99       	mov	r9,r8
80008212:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008216:	91 39       	st.w	r8[0xc],r9
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80008218:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000821c:	2f 88       	sub	r8,-8
8000821e:	10 99       	mov	r9,r8
80008220:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008224:	91 49       	st.w	r8[0x10],r9

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80008226:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000822a:	30 09       	mov	r9,0
8000822c:	91 09       	st.w	r8[0x0],r9
}
8000822e:	2f fd       	sub	sp,-4
80008230:	e3 cd 80 80 	ldm	sp++,r7,pc

80008234 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
80008234:	eb cd 40 80 	pushm	r7,lr
80008238:	1a 97       	mov	r7,sp
8000823a:	20 1d       	sub	sp,4
8000823c:	ef 4c ff fc 	st.w	r7[-4],r12
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80008240:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008244:	30 09       	mov	r9,0
80008246:	91 49       	st.w	r8[0x10],r9
}
80008248:	2f fd       	sub	sp,-4
8000824a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000824e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
8000824e:	eb cd 40 80 	pushm	r7,lr
80008252:	1a 97       	mov	r7,sp
80008254:	20 3d       	sub	sp,12
80008256:	ef 4c ff f8 	st.w	r7[-8],r12
8000825a:	ef 4b ff f4 	st.w	r7[-12],r11

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000825e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008262:	70 18       	ld.w	r8,r8[0x4]
80008264:	ef 48 ff fc 	st.w	r7[-4],r8

	pxNewListItem->pxNext = pxIndex->pxNext;
80008268:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000826c:	70 19       	ld.w	r9,r8[0x4]
8000826e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008272:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80008274:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008278:	70 19       	ld.w	r9,r8[0x4]
8000827a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000827e:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008280:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008284:	70 18       	ld.w	r8,r8[0x4]
80008286:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000828a:	91 29       	st.w	r8[0x8],r9
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
8000828c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80008290:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008294:	91 19       	st.w	r8[0x4],r9
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80008296:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000829a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000829e:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800082a0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800082a4:	ee f9 ff f8 	ld.w	r9,r7[-8]
800082a8:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
800082aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800082ae:	70 08       	ld.w	r8,r8[0x0]
800082b0:	f0 c9 ff ff 	sub	r9,r8,-1
800082b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800082b8:	91 09       	st.w	r8[0x0],r9
}
800082ba:	2f dd       	sub	sp,-12
800082bc:	e3 cd 80 80 	ldm	sp++,r7,pc

800082c0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
800082c0:	eb cd 40 80 	pushm	r7,lr
800082c4:	1a 97       	mov	r7,sp
800082c6:	20 4d       	sub	sp,16
800082c8:	ef 4c ff f4 	st.w	r7[-12],r12
800082cc:	ef 4b ff f0 	st.w	r7[-16],r11
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800082d0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800082d4:	70 08       	ld.w	r8,r8[0x0]
800082d6:	ef 48 ff fc 	st.w	r7[-4],r8
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800082da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800082de:	5b f8       	cp.w	r8,-1
800082e0:	c0 71       	brne	800082ee <vListInsert+0x2e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800082e2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800082e6:	70 48       	ld.w	r8,r8[0x10]
800082e8:	ef 48 ff f8 	st.w	r7[-8],r8
800082ec:	c1 58       	rjmp	80008316 <vListInsert+0x56>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800082ee:	ee f8 ff f4 	ld.w	r8,r7[-12]
800082f2:	2f 88       	sub	r8,-8
800082f4:	ef 48 ff f8 	st.w	r7[-8],r8
800082f8:	c0 68       	rjmp	80008304 <vListInsert+0x44>
800082fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800082fe:	70 18       	ld.w	r8,r8[0x4]
80008300:	ef 48 ff f8 	st.w	r7[-8],r8
80008304:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008308:	70 18       	ld.w	r8,r8[0x4]
8000830a:	70 09       	ld.w	r9,r8[0x0]
8000830c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008310:	10 39       	cp.w	r9,r8
80008312:	fe 98 ff f4 	brls	800082fa <vListInsert+0x3a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80008316:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000831a:	70 19       	ld.w	r9,r8[0x4]
8000831c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008320:	91 19       	st.w	r8[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80008322:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008326:	70 18       	ld.w	r8,r8[0x4]
80008328:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000832c:	91 29       	st.w	r8[0x8],r9
	pxNewListItem->pxPrevious = pxIterator;
8000832e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008332:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008336:	91 29       	st.w	r8[0x8],r9
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80008338:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000833c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008340:	91 19       	st.w	r8[0x4],r9

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80008342:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008346:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000834a:	91 49       	st.w	r8[0x10],r9

	( pxList->uxNumberOfItems )++;
8000834c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008350:	70 08       	ld.w	r8,r8[0x0]
80008352:	f0 c9 ff ff 	sub	r9,r8,-1
80008356:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000835a:	91 09       	st.w	r8[0x0],r9
}
8000835c:	2f cd       	sub	sp,-16
8000835e:	e3 cd 80 80 	ldm	sp++,r7,pc

80008362 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
80008362:	eb cd 40 80 	pushm	r7,lr
80008366:	1a 97       	mov	r7,sp
80008368:	20 2d       	sub	sp,8
8000836a:	ef 4c ff f8 	st.w	r7[-8],r12
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000836e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008372:	70 18       	ld.w	r8,r8[0x4]
80008374:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008378:	72 29       	ld.w	r9,r9[0x8]
8000837a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000837c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008380:	70 28       	ld.w	r8,r8[0x8]
80008382:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008386:	72 19       	ld.w	r9,r9[0x4]
80008388:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000838a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000838e:	70 48       	ld.w	r8,r8[0x10]
80008390:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80008394:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008398:	70 19       	ld.w	r9,r8[0x4]
8000839a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000839e:	10 39       	cp.w	r9,r8
800083a0:	c0 71       	brne	800083ae <vListRemove+0x4c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800083a2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800083a6:	70 29       	ld.w	r9,r8[0x8]
800083a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800083ac:	91 19       	st.w	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800083ae:	ee f8 ff f8 	ld.w	r8,r7[-8]
800083b2:	30 09       	mov	r9,0
800083b4:	91 49       	st.w	r8[0x10],r9
	( pxList->uxNumberOfItems )--;
800083b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800083ba:	70 08       	ld.w	r8,r8[0x0]
800083bc:	f0 c9 00 01 	sub	r9,r8,1
800083c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800083c4:	91 09       	st.w	r8[0x0],r9
}
800083c6:	2f ed       	sub	sp,-8
800083c8:	e3 cd 80 80 	ldm	sp++,r7,pc

800083cc <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800083cc:	eb cd 40 80 	pushm	r7,lr
800083d0:	1a 97       	mov	r7,sp
800083d2:	20 1d       	sub	sp,4
800083d4:	ef 4c ff fc 	st.w	r7[-4],r12
	vTaskSuspendAll();
800083d8:	f0 1f 00 03 	mcall	800083e4 <__malloc_lock+0x18>
}
800083dc:	2f fd       	sub	sp,-4
800083de:	e3 cd 80 80 	ldm	sp++,r7,pc
800083e2:	00 00       	add	r0,r0
800083e4:	80 00       	ld.sh	r0,r0[0x0]
800083e6:	94 b8       	ld.uh	r8,r10[0x6]

800083e8 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800083e8:	eb cd 40 80 	pushm	r7,lr
800083ec:	1a 97       	mov	r7,sp
800083ee:	20 1d       	sub	sp,4
800083f0:	ef 4c ff fc 	st.w	r7[-4],r12
	xTaskResumeAll();
800083f4:	f0 1f 00 03 	mcall	80008400 <__malloc_unlock+0x18>
}
800083f8:	2f fd       	sub	sp,-4
800083fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800083fe:	00 00       	add	r0,r0
80008400:	80 00       	ld.sh	r0,r0[0x0]
80008402:	94 d4       	ld.uh	r4,r10[0xa]

80008404 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80008404:	eb cd 00 ff 	pushm	r0-r7
80008408:	e0 68 05 48 	mov	r8,1352
8000840c:	ea 18 00 00 	orh	r8,0x0
80008410:	70 00       	ld.w	r0,r8[0x0]
80008412:	1a d0       	st.w	--sp,r0
80008414:	7a 90       	ld.w	r0,sp[0x24]
80008416:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000841a:	58 10       	cp.w	r0,1
8000841c:	e0 8b 00 08 	brhi	8000842c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80008420:	e0 68 0c 24 	mov	r8,3108
80008424:	ea 18 00 00 	orh	r8,0x0
80008428:	70 00       	ld.w	r0,r8[0x0]
8000842a:	81 0d       	st.w	r0[0x0],sp

8000842c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
8000842c:	f0 1f 00 12 	mcall	80008474 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80008430:	f0 1f 00 12 	mcall	80008478 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80008434:	f0 1f 00 12 	mcall	8000847c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80008438:	f0 1f 00 12 	mcall	80008480 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000843c:	7a 90       	ld.w	r0,sp[0x24]
8000843e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80008442:	58 10       	cp.w	r0,1
80008444:	e0 8b 00 0e 	brhi	80008460 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80008448:	f0 1f 00 0c 	mcall	80008478 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
8000844c:	f0 1f 00 0e 	mcall	80008484 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80008450:	f0 1f 00 0c 	mcall	80008480 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80008454:	e0 68 0c 24 	mov	r8,3108
80008458:	ea 18 00 00 	orh	r8,0x0
8000845c:	70 00       	ld.w	r0,r8[0x0]
8000845e:	60 0d       	ld.w	sp,r0[0x0]

80008460 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80008460:	1b 00       	ld.w	r0,sp++
80008462:	e0 68 05 48 	mov	r8,1352
80008466:	ea 18 00 00 	orh	r8,0x0
8000846a:	91 00       	st.w	r8[0x0],r0
8000846c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008470:	d6 03       	rete
80008472:	00 00       	add	r0,r0
80008474:	80 00       	ld.sh	r0,r0[0x0]
80008476:	87 70       	st.w	r3[0x1c],r0
80008478:	80 00       	ld.sh	r0,r0[0x0]
8000847a:	85 20       	st.w	r2[0x8],r0
8000847c:	80 00       	ld.sh	r0,r0[0x0]
8000847e:	96 2c       	ld.sh	r12,r11[0x4]
80008480:	80 00       	ld.sh	r0,r0[0x0]
80008482:	85 3c       	st.w	r2[0xc],r12
80008484:	80 00       	ld.sh	r0,r0[0x0]
80008486:	97 8c       	st.w	r11[0x20],r12

80008488 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80008488:	20 6d       	sub	sp,24
8000848a:	eb cd 00 ff 	pushm	r0-r7
8000848e:	fa c7 ff c0 	sub	r7,sp,-64
80008492:	ee f0 ff f8 	ld.w	r0,r7[-8]
80008496:	ef 40 ff e0 	st.w	r7[-32],r0
8000849a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000849e:	ef 40 ff e4 	st.w	r7[-28],r0
800084a2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800084a6:	e0 68 05 48 	mov	r8,1352
800084aa:	ea 18 00 00 	orh	r8,0x0
800084ae:	70 00       	ld.w	r0,r8[0x0]
800084b0:	1a d0       	st.w	--sp,r0
800084b2:	f0 1f 00 1a 	mcall	80008518 <LABEL_RET_SCALL_263+0x14>
800084b6:	e0 68 0c 24 	mov	r8,3108
800084ba:	ea 18 00 00 	orh	r8,0x0
800084be:	70 00       	ld.w	r0,r8[0x0]
800084c0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800084c2:	f0 1f 00 17 	mcall	8000851c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800084c6:	e0 68 0c 24 	mov	r8,3108
800084ca:	ea 18 00 00 	orh	r8,0x0
800084ce:	70 00       	ld.w	r0,r8[0x0]
800084d0:	60 0d       	ld.w	sp,r0[0x0]
800084d2:	1b 00       	ld.w	r0,sp++
800084d4:	e0 68 05 48 	mov	r8,1352
800084d8:	ea 18 00 00 	orh	r8,0x0
800084dc:	91 00       	st.w	r8[0x0],r0
800084de:	fa c7 ff d8 	sub	r7,sp,-40
800084e2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800084e6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800084ea:	e0 61 05 48 	mov	r1,1352
800084ee:	ea 11 00 00 	orh	r1,0x0
800084f2:	62 02       	ld.w	r2,r1[0x0]
800084f4:	58 02       	cp.w	r2,0
800084f6:	c0 70       	breq	80008504 <LABEL_RET_SCALL_263>
800084f8:	e4 c2 00 01 	sub	r2,r2,1
800084fc:	83 02       	st.w	r1[0x0],r2
800084fe:	58 02       	cp.w	r2,0
80008500:	c0 21       	brne	80008504 <LABEL_RET_SCALL_263>
80008502:	b1 c0       	cbr	r0,0x10

80008504 <LABEL_RET_SCALL_263>:
80008504:	ef 40 ff f8 	st.w	r7[-8],r0
80008508:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000850c:	ef 40 ff fc 	st.w	r7[-4],r0
80008510:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008514:	2f ad       	sub	sp,-24
80008516:	d6 13       	rets
80008518:	80 00       	ld.sh	r0,r0[0x0]
8000851a:	85 20       	st.w	r2[0x8],r0
8000851c:	80 00       	ld.sh	r0,r0[0x0]
8000851e:	97 8c       	st.w	r11[0x20],r12

80008520 <vPortEnterCritical>:
/* The code generated by the GCC compiler uses the stack in different ways at
different optimisation levels.  The interrupt flags can therefore not always
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
80008520:	eb cd 40 80 	pushm	r7,lr
80008524:	1a 97       	mov	r7,sp
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80008526:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80008528:	48 48       	lddpc	r8,80008538 <vPortEnterCritical+0x18>
8000852a:	70 08       	ld.w	r8,r8[0x0]
8000852c:	f0 c9 ff ff 	sub	r9,r8,-1
80008530:	48 28       	lddpc	r8,80008538 <vPortEnterCritical+0x18>
80008532:	91 09       	st.w	r8[0x0],r9
}
80008534:	e3 cd 80 80 	ldm	sp++,r7,pc
80008538:	00 00       	add	r0,r0
8000853a:	05 48       	ld.w	r8,--r2

8000853c <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
8000853c:	eb cd 40 80 	pushm	r7,lr
80008540:	1a 97       	mov	r7,sp
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80008542:	48 98       	lddpc	r8,80008564 <vPortExitCritical+0x28>
80008544:	70 08       	ld.w	r8,r8[0x0]
80008546:	58 08       	cp.w	r8,0
80008548:	c0 c0       	breq	80008560 <vPortExitCritical+0x24>
	{
		ulCriticalNesting--;
8000854a:	48 78       	lddpc	r8,80008564 <vPortExitCritical+0x28>
8000854c:	70 08       	ld.w	r8,r8[0x0]
8000854e:	f0 c9 00 01 	sub	r9,r8,1
80008552:	48 58       	lddpc	r8,80008564 <vPortExitCritical+0x28>
80008554:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80008556:	48 48       	lddpc	r8,80008564 <vPortExitCritical+0x28>
80008558:	70 08       	ld.w	r8,r8[0x0]
8000855a:	58 08       	cp.w	r8,0
8000855c:	c0 21       	brne	80008560 <vPortExitCritical+0x24>
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000855e:	d5 03       	csrf	0x10
		}
	}
}
80008560:	e3 cd 80 80 	ldm	sp++,r7,pc
80008564:	00 00       	add	r0,r0
80008566:	05 48       	ld.w	r8,--r2

80008568 <pxPortInitialiseStack>:
 * portSAVE_CONTEXT had been called.
 *
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80008568:	eb cd 40 80 	pushm	r7,lr
8000856c:	1a 97       	mov	r7,sp
8000856e:	20 3d       	sub	sp,12
80008570:	ef 4c ff fc 	st.w	r7[-4],r12
80008574:	ef 4b ff f8 	st.w	r7[-8],r11
80008578:	ef 4a ff f4 	st.w	r7[-12],r10
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
8000857c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008580:	20 48       	sub	r8,4
80008582:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80008586:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000858a:	e0 69 08 08 	mov	r9,2056
8000858e:	ea 19 08 08 	orh	r9,0x808
80008592:	91 09       	st.w	r8[0x0],r9
80008594:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008598:	20 48       	sub	r8,4
8000859a:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000859e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085a2:	e0 69 09 09 	mov	r9,2313
800085a6:	ea 19 09 09 	orh	r9,0x909
800085aa:	91 09       	st.w	r8[0x0],r9
800085ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085b0:	20 48       	sub	r8,4
800085b2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800085b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085ba:	e0 69 0a 0a 	mov	r9,2570
800085be:	ea 19 0a 0a 	orh	r9,0xa0a
800085c2:	91 09       	st.w	r8[0x0],r9
800085c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085c8:	20 48       	sub	r8,4
800085ca:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800085ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085d2:	e0 69 0b 0b 	mov	r9,2827
800085d6:	ea 19 0b 0b 	orh	r9,0xb0b
800085da:	91 09       	st.w	r8[0x0],r9
800085dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085e0:	20 48       	sub	r8,4
800085e2:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800085e6:	ee f9 ff f4 	ld.w	r9,r7[-12]
800085ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085ee:	91 09       	st.w	r8[0x0],r9
800085f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085f4:	20 48       	sub	r8,4
800085f6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800085fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800085fe:	e0 69 be ef 	mov	r9,48879
80008602:	ea 19 de ad 	orh	r9,0xdead
80008606:	91 09       	st.w	r8[0x0],r9
80008608:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000860c:	20 48       	sub	r8,4
8000860e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80008612:	ee f9 ff f8 	ld.w	r9,r7[-8]
80008616:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000861a:	91 09       	st.w	r8[0x0],r9
8000861c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008620:	20 48       	sub	r8,4
80008622:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80008626:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000862a:	fc 19 00 40 	movh	r9,0x40
8000862e:	91 09       	st.w	r8[0x0],r9
80008630:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008634:	20 48       	sub	r8,4
80008636:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
8000863a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000863e:	e0 69 00 ff 	mov	r9,255
80008642:	ea 19 ff 00 	orh	r9,0xff00
80008646:	91 09       	st.w	r8[0x0],r9
80008648:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000864c:	20 48       	sub	r8,4
8000864e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80008652:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008656:	e0 69 01 01 	mov	r9,257
8000865a:	ea 19 01 01 	orh	r9,0x101
8000865e:	91 09       	st.w	r8[0x0],r9
80008660:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008664:	20 48       	sub	r8,4
80008666:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000866a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000866e:	e0 69 02 02 	mov	r9,514
80008672:	ea 19 02 02 	orh	r9,0x202
80008676:	91 09       	st.w	r8[0x0],r9
80008678:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000867c:	20 48       	sub	r8,4
8000867e:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80008682:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008686:	e0 69 03 03 	mov	r9,771
8000868a:	ea 19 03 03 	orh	r9,0x303
8000868e:	91 09       	st.w	r8[0x0],r9
80008690:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008694:	20 48       	sub	r8,4
80008696:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000869a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000869e:	e0 69 04 04 	mov	r9,1028
800086a2:	ea 19 04 04 	orh	r9,0x404
800086a6:	91 09       	st.w	r8[0x0],r9
800086a8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086ac:	20 48       	sub	r8,4
800086ae:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800086b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086b6:	e0 69 05 05 	mov	r9,1285
800086ba:	ea 19 05 05 	orh	r9,0x505
800086be:	91 09       	st.w	r8[0x0],r9
800086c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086c4:	20 48       	sub	r8,4
800086c6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800086ca:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086ce:	e0 69 06 06 	mov	r9,1542
800086d2:	ea 19 06 06 	orh	r9,0x606
800086d6:	91 09       	st.w	r8[0x0],r9
800086d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086dc:	20 48       	sub	r8,4
800086de:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800086e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086e6:	e0 69 07 07 	mov	r9,1799
800086ea:	ea 19 07 07 	orh	r9,0x707
800086ee:	91 09       	st.w	r8[0x0],r9
800086f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086f4:	20 48       	sub	r8,4
800086f6:	ef 48 ff fc 	st.w	r7[-4],r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800086fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800086fe:	30 09       	mov	r9,0
80008700:	91 09       	st.w	r8[0x0],r9

	return pxTopOfStack;
80008702:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80008706:	10 9c       	mov	r12,r8
80008708:	2f dd       	sub	sp,-12
8000870a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000870e:	d7 03       	nop

80008710 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80008710:	eb cd 40 80 	pushm	r7,lr
80008714:	1a 97       	mov	r7,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
80008716:	f0 1f 00 10 	mcall	80008754 <xPortStartScheduler+0x44>

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000871a:	e0 68 0c 24 	mov	r8,3108
8000871e:	ea 18 00 00 	orh	r8,0x0
80008722:	70 00       	ld.w	r0,r8[0x0]
80008724:	60 0d       	ld.w	sp,r0[0x0]
80008726:	1b 00       	ld.w	r0,sp++
80008728:	e0 68 05 48 	mov	r8,1352
8000872c:	ea 18 00 00 	orh	r8,0x0
80008730:	91 00       	st.w	r8[0x0],r0
80008732:	e3 cd 00 ff 	ldm	sp++,r0-r7
80008736:	2f ed       	sub	sp,-8
80008738:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000873c:	fa f0 ff e0 	ld.w	r0,sp[-32]
80008740:	e3 b0 00 00 	mtsr	0x0,r0
80008744:	fa f0 ff dc 	ld.w	r0,sp[-36]
80008748:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
8000874c:	30 08       	mov	r8,0
}
8000874e:	10 9c       	mov	r12,r8
80008750:	e3 cd 80 80 	ldm	sp++,r7,pc
80008754:	80 00       	ld.sh	r0,r0[0x0]
80008756:	87 84       	st.w	r3[0x20],r4

80008758 <prvScheduleFirstTick>:

/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
80008758:	eb cd 40 80 	pushm	r7,lr
8000875c:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000875e:	e0 68 5d c0 	mov	r8,24000
80008762:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80008766:	30 08       	mov	r8,0
80008768:	e3 b8 00 42 	mtsr	0x108,r8
	}
8000876c:	e3 cd 80 80 	ldm	sp++,r7,pc

80008770 <prvClearCcInt>:

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
80008770:	eb cd 40 80 	pushm	r7,lr
80008774:	1a 97       	mov	r7,sp
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80008776:	e1 b8 00 43 	mfsr	r8,0x10c
8000877a:	e3 b8 00 43 	mtsr	0x10c,r8
	}
8000877e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008782:	d7 03       	nop

80008784 <prvSetupTimerInterrupt>:
#endif
/*-----------------------------------------------------------*/

/* Setup the timer to generate the tick interrupts. */
static void prvSetupTimerInterrupt(void)
{
80008784:	eb cd 40 80 	pushm	r7,lr
80008788:	1a 97       	mov	r7,sp
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000878a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
8000878c:	30 0a       	mov	r10,0
8000878e:	30 0b       	mov	r11,0
80008790:	48 4c       	lddpc	r12,800087a0 <prvSetupTimerInterrupt+0x1c>
80008792:	f0 1f 00 05 	mcall	800087a4 <prvSetupTimerInterrupt+0x20>
		prvScheduleFirstTick();
80008796:	f0 1f 00 05 	mcall	800087a8 <prvSetupTimerInterrupt+0x24>
	}
	#endif
}
8000879a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000879e:	00 00       	add	r0,r0
800087a0:	80 00       	ld.sh	r0,r0[0x0]
800087a2:	84 04       	ld.sh	r4,r2[0x0]
800087a4:	80 00       	ld.sh	r0,r0[0x0]
800087a6:	73 b4       	ld.w	r4,r9[0x6c]
800087a8:	80 00       	ld.sh	r0,r0[0x0]
800087aa:	87 58       	st.w	r3[0x14],r8

800087ac <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800087ac:	eb cd 40 80 	pushm	r7,lr
800087b0:	1a 97       	mov	r7,sp
800087b2:	20 5d       	sub	sp,20
800087b4:	ef 4c ff f4 	st.w	r7[-12],r12
800087b8:	ef 4b ff f0 	st.w	r7[-16],r11
800087bc:	ef 4a ff ec 	st.w	r7[-20],r10
  int nChars = 0;
800087c0:	30 08       	mov	r8,0
800087c2:	ef 48 ff f8 	st.w	r7[-8],r8

  if (file != 0)
800087c6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800087ca:	58 08       	cp.w	r8,0
800087cc:	c2 40       	breq	80008814 <_read+0x68>
    return -1;
800087ce:	3f f8       	mov	r8,-1
800087d0:	c2 b8       	rjmp	80008826 <_read+0x7a>

  for (; len > 0; --len)
  {
    int c = usart_getchar(stdio_usart_base);
800087d2:	49 88       	lddpc	r8,80008830 <_read+0x84>
800087d4:	70 08       	ld.w	r8,r8[0x0]
800087d6:	10 9c       	mov	r12,r8
800087d8:	f0 1f 00 17 	mcall	80008834 <_read+0x88>
800087dc:	18 98       	mov	r8,r12
800087de:	ef 48 ff fc 	st.w	r7[-4],r8
    if (c < 0)
800087e2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800087e6:	58 08       	cp.w	r8,0
800087e8:	c1 c5       	brlt	80008820 <_read+0x74>
      break;

    *ptr++ = c;
800087ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800087ee:	5c 58       	castu.b	r8
800087f0:	ee f9 ff f0 	ld.w	r9,r7[-16]
800087f4:	b2 88       	st.b	r9[0x0],r8
800087f6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800087fa:	2f f8       	sub	r8,-1
800087fc:	ef 48 ff f0 	st.w	r7[-16],r8
    ++nChars;
80008800:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008804:	2f f8       	sub	r8,-1
80008806:	ef 48 ff f8 	st.w	r7[-8],r8
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000880a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000880e:	20 18       	sub	r8,1
80008810:	ef 48 ff ec 	st.w	r7[-20],r8
80008814:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008818:	58 08       	cp.w	r8,0
8000881a:	fe 99 ff dc 	brgt	800087d2 <_read+0x26>
8000881e:	c0 28       	rjmp	80008822 <_read+0x76>
  {
    int c = usart_getchar(stdio_usart_base);
    if (c < 0)
      break;
80008820:	d7 03       	nop

    *ptr++ = c;
    ++nChars;
  }

  return nChars;
80008822:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80008826:	10 9c       	mov	r12,r8
80008828:	2f bd       	sub	sp,-20
8000882a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000882e:	00 00       	add	r0,r0
80008830:	00 00       	add	r0,r0
80008832:	53 18       	stdsp	sp[0xc4],r8
80008834:	80 00       	ld.sh	r0,r0[0x0]
80008836:	81 64       	st.w	r0[0x18],r4

80008838 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80008838:	eb cd 40 80 	pushm	r7,lr
8000883c:	1a 97       	mov	r7,sp
8000883e:	20 4d       	sub	sp,16
80008840:	ef 4c ff f8 	st.w	r7[-8],r12
80008844:	ef 4b ff f4 	st.w	r7[-12],r11
80008848:	ef 4a ff f0 	st.w	r7[-16],r10
  int nChars = 0;
8000884c:	30 08       	mov	r8,0
8000884e:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
80008852:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008856:	58 18       	cp.w	r8,1
80008858:	c2 90       	breq	800088aa <_write+0x72>
8000885a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000885e:	58 28       	cp.w	r8,2
80008860:	c2 50       	breq	800088aa <_write+0x72>
80008862:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008866:	58 38       	cp.w	r8,3
80008868:	c2 10       	breq	800088aa <_write+0x72>
       && (file != 2) && (file!=3))
    return -1;
8000886a:	3f f8       	mov	r8,-1
8000886c:	c2 58       	rjmp	800088b6 <_write+0x7e>

  for (; len != 0; --len)
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
8000886e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008872:	11 88       	ld.ub	r8,r8[0x0]
80008874:	10 99       	mov	r9,r8
80008876:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000887a:	2f f8       	sub	r8,-1
8000887c:	ef 48 ff f4 	st.w	r7[-12],r8
80008880:	49 08       	lddpc	r8,800088c0 <_write+0x88>
80008882:	70 08       	ld.w	r8,r8[0x0]
80008884:	12 9b       	mov	r11,r9
80008886:	10 9c       	mov	r12,r8
80008888:	f0 1f 00 0f 	mcall	800088c4 <_write+0x8c>
8000888c:	18 98       	mov	r8,r12
8000888e:	58 08       	cp.w	r8,0
80008890:	c0 34       	brge	80008896 <_write+0x5e>
    {
      return -1;
80008892:	3f f8       	mov	r8,-1
80008894:	c1 18       	rjmp	800088b6 <_write+0x7e>
    }

    ++nChars;
80008896:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000889a:	2f f8       	sub	r8,-1
8000889c:	ef 48 ff fc 	st.w	r7[-4],r8

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800088a0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800088a4:	20 18       	sub	r8,1
800088a6:	ef 48 ff f0 	st.w	r7[-16],r8
800088aa:	ee f8 ff f0 	ld.w	r8,r7[-16]
800088ae:	58 08       	cp.w	r8,0
800088b0:	cd f1       	brne	8000886e <_write+0x36>
    }

    ++nChars;
  }

  return nChars;
800088b2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800088b6:	10 9c       	mov	r12,r8
800088b8:	2f cd       	sub	sp,-16
800088ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800088be:	00 00       	add	r0,r0
800088c0:	00 00       	add	r0,r0
800088c2:	53 18       	stdsp	sp[0xc4],r8
800088c4:	80 00       	ld.sh	r0,r0[0x0]
800088c6:	80 bc       	ld.uh	r12,r0[0x6]

800088c8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800088c8:	eb cd 40 80 	pushm	r7,lr
800088cc:	1a 97       	mov	r7,sp
800088ce:	20 2d       	sub	sp,8
800088d0:	ef 4c ff f8 	st.w	r7[-8],r12
void *pvReturn;

	vTaskSuspendAll();
800088d4:	f0 1f 00 09 	mcall	800088f8 <pvPortMalloc+0x30>
	{
		pvReturn = malloc( xWantedSize );
800088d8:	ee fc ff f8 	ld.w	r12,r7[-8]
800088dc:	f0 1f 00 08 	mcall	800088fc <pvPortMalloc+0x34>
800088e0:	18 98       	mov	r8,r12
800088e2:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	xTaskResumeAll();
800088e6:	f0 1f 00 07 	mcall	80008900 <pvPortMalloc+0x38>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
800088ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800088ee:	10 9c       	mov	r12,r8
800088f0:	2f ed       	sub	sp,-8
800088f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800088f6:	00 00       	add	r0,r0
800088f8:	80 00       	ld.sh	r0,r0[0x0]
800088fa:	94 b8       	ld.uh	r8,r10[0x6]
800088fc:	80 00       	ld.sh	r0,r0[0x0]
800088fe:	ac 04       	st.h	r6[0x0],r4
80008900:	80 00       	ld.sh	r0,r0[0x0]
80008902:	94 d4       	ld.uh	r4,r10[0xa]

80008904 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80008904:	eb cd 40 80 	pushm	r7,lr
80008908:	1a 97       	mov	r7,sp
8000890a:	20 1d       	sub	sp,4
8000890c:	ef 4c ff fc 	st.w	r7[-4],r12
	if( pv )
80008910:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008914:	58 08       	cp.w	r8,0
80008916:	c0 90       	breq	80008928 <vPortFree+0x24>
	{
		vTaskSuspendAll();
80008918:	f0 1f 00 06 	mcall	80008930 <vPortFree+0x2c>
		{
			free( pv );
8000891c:	ee fc ff fc 	ld.w	r12,r7[-4]
80008920:	f0 1f 00 05 	mcall	80008934 <vPortFree+0x30>
		}
		xTaskResumeAll();
80008924:	f0 1f 00 05 	mcall	80008938 <vPortFree+0x34>
	}
}
80008928:	2f fd       	sub	sp,-4
8000892a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000892e:	00 00       	add	r0,r0
80008930:	80 00       	ld.sh	r0,r0[0x0]
80008932:	94 b8       	ld.uh	r8,r10[0x6]
80008934:	80 00       	ld.sh	r0,r0[0x0]
80008936:	ab f4       	*unknown*
80008938:	80 00       	ld.sh	r0,r0[0x0]
8000893a:	94 d4       	ld.uh	r4,r10[0xa]

8000893c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000893c:	eb cd 40 80 	pushm	r7,lr
80008940:	1a 97       	mov	r7,sp
80008942:	20 5d       	sub	sp,20
80008944:	ef 4c ff f0 	st.w	r7[-16],r12
80008948:	ef 4b ff ec 	st.w	r7[-20],r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
8000894c:	30 08       	mov	r8,0
8000894e:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80008952:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008956:	58 08       	cp.w	r8,0
80008958:	c7 20       	breq	80008a3c <xQueueCreate+0x100>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000895a:	34 cc       	mov	r12,76
8000895c:	f0 1f 00 3b 	mcall	80008a48 <xQueueCreate+0x10c>
80008960:	18 98       	mov	r8,r12
80008962:	ef 48 ff f4 	st.w	r7[-12],r8
		if( pxNewQueue != NULL )
80008966:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000896a:	58 08       	cp.w	r8,0
8000896c:	c6 80       	breq	80008a3c <xQueueCreate+0x100>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000896e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80008972:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008976:	f2 08 02 48 	mul	r8,r9,r8
8000897a:	2f f8       	sub	r8,-1
8000897c:	ef 48 ff f8 	st.w	r7[-8],r8

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80008980:	ee fc ff f8 	ld.w	r12,r7[-8]
80008984:	f0 1f 00 31 	mcall	80008a48 <xQueueCreate+0x10c>
80008988:	18 98       	mov	r8,r12
8000898a:	10 99       	mov	r9,r8
8000898c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008990:	91 09       	st.w	r8[0x0],r9
			if( pxNewQueue->pcHead != NULL )
80008992:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008996:	70 08       	ld.w	r8,r8[0x0]
80008998:	58 08       	cp.w	r8,0
8000899a:	c4 d0       	breq	80008a34 <xQueueCreate+0xf8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000899c:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089a0:	70 09       	ld.w	r9,r8[0x0]
800089a2:	ee fa ff f0 	ld.w	r10,r7[-16]
800089a6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800089aa:	f4 08 02 48 	mul	r8,r10,r8
800089ae:	10 09       	add	r9,r8
800089b0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089b4:	91 19       	st.w	r8[0x4],r9
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800089b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089ba:	30 09       	mov	r9,0
800089bc:	91 e9       	st.w	r8[0x38],r9
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800089be:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089c2:	70 09       	ld.w	r9,r8[0x0]
800089c4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089c8:	91 29       	st.w	r8[0x8],r9
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800089ca:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089ce:	70 09       	ld.w	r9,r8[0x0]
800089d0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800089d4:	f0 ca 00 01 	sub	r10,r8,1
800089d8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800089dc:	f4 08 02 48 	mul	r8,r10,r8
800089e0:	10 09       	add	r9,r8
800089e2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089e6:	91 39       	st.w	r8[0xc],r9
				pxNewQueue->uxLength = uxQueueLength;
800089e8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089ec:	ee f9 ff f0 	ld.w	r9,r7[-16]
800089f0:	91 f9       	st.w	r8[0x3c],r9
				pxNewQueue->uxItemSize = uxItemSize;
800089f2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800089f6:	ee f9 ff ec 	ld.w	r9,r7[-20]
800089fa:	f1 49 00 40 	st.w	r8[64],r9
				pxNewQueue->xRxLock = queueUNLOCKED;
800089fe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a02:	3f f9       	mov	r9,-1
80008a04:	f1 49 00 44 	st.w	r8[68],r9
				pxNewQueue->xTxLock = queueUNLOCKED;
80008a08:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a0c:	3f f9       	mov	r9,-1
80008a0e:	f1 49 00 48 	st.w	r8[72],r9

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80008a12:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a16:	2f 08       	sub	r8,-16
80008a18:	10 9c       	mov	r12,r8
80008a1a:	f0 1f 00 0d 	mcall	80008a4c <xQueueCreate+0x110>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80008a1e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a22:	2d c8       	sub	r8,-36
80008a24:	10 9c       	mov	r12,r8
80008a26:	f0 1f 00 0a 	mcall	80008a4c <xQueueCreate+0x110>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
80008a2a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008a2e:	ef 48 ff fc 	st.w	r7[-4],r8
80008a32:	c0 58       	rjmp	80008a3c <xQueueCreate+0x100>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80008a34:	ee fc ff f4 	ld.w	r12,r7[-12]
80008a38:	f0 1f 00 06 	mcall	80008a50 <xQueueCreate+0x114>
		}
	}

	configASSERT( xReturn );

	return xReturn;
80008a3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80008a40:	10 9c       	mov	r12,r8
80008a42:	2f bd       	sub	sp,-20
80008a44:	e3 cd 80 80 	ldm	sp++,r7,pc
80008a48:	80 00       	ld.sh	r0,r0[0x0]
80008a4a:	88 c8       	ld.uh	r8,r4[0x8]
80008a4c:	80 00       	ld.sh	r0,r0[0x0]
80008a4e:	81 e8       	st.w	r0[0x38],r8
80008a50:	80 00       	ld.sh	r0,r0[0x0]
80008a52:	89 04       	st.w	r4[0x0],r4

80008a54 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80008a54:	eb cd 40 80 	pushm	r7,lr
80008a58:	1a 97       	mov	r7,sp
80008a5a:	20 7d       	sub	sp,28
80008a5c:	ef 4c ff f0 	st.w	r7[-16],r12
80008a60:	ef 4b ff ec 	st.w	r7[-20],r11
80008a64:	ef 4a ff e8 	st.w	r7[-24],r10
80008a68:	ef 49 ff e4 	st.w	r7[-28],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80008a6c:	30 08       	mov	r8,0
80008a6e:	ef 48 ff fc 	st.w	r7[-4],r8
80008a72:	c0 28       	rjmp	80008a76 <xQueueGenericSend+0x22>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80008a74:	d7 03       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80008a76:	f0 1f 00 47 	mcall	80008b90 <xQueueGenericSend+0x13c>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008a7a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008a7e:	70 e9       	ld.w	r9,r8[0x38]
80008a80:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008a84:	70 f8       	ld.w	r8,r8[0x3c]
80008a86:	10 39       	cp.w	r9,r8
80008a88:	c1 c2       	brcc	80008ac0 <xQueueGenericSend+0x6c>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008a8a:	ee fa ff e4 	ld.w	r10,r7[-28]
80008a8e:	ee fb ff ec 	ld.w	r11,r7[-20]
80008a92:	ee fc ff f0 	ld.w	r12,r7[-16]
80008a96:	f0 1f 00 40 	mcall	80008b94 <xQueueGenericSend+0x140>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008a9a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008a9e:	70 98       	ld.w	r8,r8[0x24]
80008aa0:	58 08       	cp.w	r8,0
80008aa2:	c0 b0       	breq	80008ab8 <xQueueGenericSend+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80008aa4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008aa8:	2d c8       	sub	r8,-36
80008aaa:	10 9c       	mov	r12,r8
80008aac:	f0 1f 00 3b 	mcall	80008b98 <xQueueGenericSend+0x144>
80008ab0:	18 98       	mov	r8,r12
80008ab2:	58 18       	cp.w	r8,1
80008ab4:	c0 21       	brne	80008ab8 <xQueueGenericSend+0x64>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80008ab6:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80008ab8:	f0 1f 00 39 	mcall	80008b9c <xQueueGenericSend+0x148>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80008abc:	30 18       	mov	r8,1
80008abe:	c6 58       	rjmp	80008b88 <xQueueGenericSend+0x134>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008ac0:	ee f8 ff e8 	ld.w	r8,r7[-24]
80008ac4:	58 08       	cp.w	r8,0
80008ac6:	c0 51       	brne	80008ad0 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008ac8:	f0 1f 00 35 	mcall	80008b9c <xQueueGenericSend+0x148>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80008acc:	30 08       	mov	r8,0
80008ace:	c5 d8       	rjmp	80008b88 <xQueueGenericSend+0x134>
				}
				else if( xEntryTimeSet == pdFALSE )
80008ad0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008ad4:	58 08       	cp.w	r8,0
80008ad6:	c0 91       	brne	80008ae8 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008ad8:	ee c8 00 0c 	sub	r8,r7,12
80008adc:	10 9c       	mov	r12,r8
80008ade:	f0 1f 00 31 	mcall	80008ba0 <xQueueGenericSend+0x14c>
					xEntryTimeSet = pdTRUE;
80008ae2:	30 18       	mov	r8,1
80008ae4:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80008ae8:	f0 1f 00 2d 	mcall	80008b9c <xQueueGenericSend+0x148>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008aec:	f0 1f 00 2e 	mcall	80008ba4 <xQueueGenericSend+0x150>
		prvLockQueue( pxQueue );
80008af0:	f0 1f 00 28 	mcall	80008b90 <xQueueGenericSend+0x13c>
80008af4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008af8:	71 18       	ld.w	r8,r8[0x44]
80008afa:	5b f8       	cp.w	r8,-1
80008afc:	c0 61       	brne	80008b08 <xQueueGenericSend+0xb4>
80008afe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008b02:	30 09       	mov	r9,0
80008b04:	f1 49 00 44 	st.w	r8[68],r9
80008b08:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008b0c:	71 28       	ld.w	r8,r8[0x48]
80008b0e:	5b f8       	cp.w	r8,-1
80008b10:	c0 61       	brne	80008b1c <xQueueGenericSend+0xc8>
80008b12:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008b16:	30 09       	mov	r9,0
80008b18:	f1 49 00 48 	st.w	r8[72],r9
80008b1c:	f0 1f 00 20 	mcall	80008b9c <xQueueGenericSend+0x148>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008b20:	ee c9 00 18 	sub	r9,r7,24
80008b24:	ee c8 00 0c 	sub	r8,r7,12
80008b28:	12 9b       	mov	r11,r9
80008b2a:	10 9c       	mov	r12,r8
80008b2c:	f0 1f 00 1f 	mcall	80008ba8 <xQueueGenericSend+0x154>
80008b30:	18 98       	mov	r8,r12
80008b32:	58 08       	cp.w	r8,0
80008b34:	c2 31       	brne	80008b7a <xQueueGenericSend+0x126>
		{
			if( prvIsQueueFull( pxQueue ) )
80008b36:	ee fc ff f0 	ld.w	r12,r7[-16]
80008b3a:	f0 1f 00 1d 	mcall	80008bac <xQueueGenericSend+0x158>
80008b3e:	18 98       	mov	r8,r12
80008b40:	58 08       	cp.w	r8,0
80008b42:	c1 50       	breq	80008b6c <xQueueGenericSend+0x118>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80008b44:	ee f9 ff e8 	ld.w	r9,r7[-24]
80008b48:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008b4c:	2f 08       	sub	r8,-16
80008b4e:	12 9b       	mov	r11,r9
80008b50:	10 9c       	mov	r12,r8
80008b52:	f0 1f 00 18 	mcall	80008bb0 <xQueueGenericSend+0x15c>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80008b56:	ee fc ff f0 	ld.w	r12,r7[-16]
80008b5a:	f0 1f 00 17 	mcall	80008bb4 <xQueueGenericSend+0x160>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80008b5e:	f0 1f 00 17 	mcall	80008bb8 <xQueueGenericSend+0x164>
80008b62:	18 98       	mov	r8,r12
80008b64:	58 08       	cp.w	r8,0
80008b66:	c8 71       	brne	80008a74 <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
80008b68:	d7 33       	scall
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80008b6a:	c8 6b       	rjmp	80008a76 <xQueueGenericSend+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008b6c:	ee fc ff f0 	ld.w	r12,r7[-16]
80008b70:	f0 1f 00 11 	mcall	80008bb4 <xQueueGenericSend+0x160>
				( void ) xTaskResumeAll();
80008b74:	f0 1f 00 11 	mcall	80008bb8 <xQueueGenericSend+0x164>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
80008b78:	c7 fb       	rjmp	80008a76 <xQueueGenericSend+0x22>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80008b7a:	ee fc ff f0 	ld.w	r12,r7[-16]
80008b7e:	f0 1f 00 0e 	mcall	80008bb4 <xQueueGenericSend+0x160>
			( void ) xTaskResumeAll();
80008b82:	f0 1f 00 0e 	mcall	80008bb8 <xQueueGenericSend+0x164>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
80008b86:	30 08       	mov	r8,0
		}
	}
}
80008b88:	10 9c       	mov	r12,r8
80008b8a:	2f 9d       	sub	sp,-28
80008b8c:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b90:	80 00       	ld.sh	r0,r0[0x0]
80008b92:	85 20       	st.w	r2[0x8],r0
80008b94:	80 00       	ld.sh	r0,r0[0x0]
80008b96:	8e f0       	ld.uh	r0,r7[0xe]
80008b98:	80 00       	ld.sh	r0,r0[0x0]
80008b9a:	98 bc       	ld.uh	r12,r12[0x6]
80008b9c:	80 00       	ld.sh	r0,r0[0x0]
80008b9e:	85 3c       	st.w	r2[0xc],r12
80008ba0:	80 00       	ld.sh	r0,r0[0x0]
80008ba2:	99 8c       	st.w	r12[0x20],r12
80008ba4:	80 00       	ld.sh	r0,r0[0x0]
80008ba6:	94 b8       	ld.uh	r8,r10[0x6]
80008ba8:	80 00       	ld.sh	r0,r0[0x0]
80008baa:	99 bc       	st.w	r12[0x2c],r12
80008bac:	80 00       	ld.sh	r0,r0[0x0]
80008bae:	91 68       	st.w	r8[0x18],r8
80008bb0:	80 00       	ld.sh	r0,r0[0x0]
80008bb2:	98 3c       	ld.sh	r12,r12[0x6]
80008bb4:	80 00       	ld.sh	r0,r0[0x0]
80008bb6:	90 60       	ld.sh	r0,r8[0xc]
80008bb8:	80 00       	ld.sh	r0,r0[0x0]
80008bba:	94 d4       	ld.uh	r4,r10[0xa]

80008bbc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80008bbc:	eb cd 40 80 	pushm	r7,lr
80008bc0:	1a 97       	mov	r7,sp
80008bc2:	20 6d       	sub	sp,24
80008bc4:	ef 4c ff f4 	st.w	r7[-12],r12
80008bc8:	ef 4b ff f0 	st.w	r7[-16],r11
80008bcc:	ef 4a ff ec 	st.w	r7[-20],r10
80008bd0:	ef 49 ff e8 	st.w	r7[-24],r9
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80008bd4:	30 08       	mov	r8,0
80008bd6:	ef 48 ff fc 	st.w	r7[-4],r8
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80008bda:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008bde:	70 e9       	ld.w	r9,r8[0x38]
80008be0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008be4:	70 f8       	ld.w	r8,r8[0x3c]
80008be6:	10 39       	cp.w	r9,r8
80008be8:	c2 e2       	brcc	80008c44 <xQueueGenericSendFromISR+0x88>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80008bea:	ee fa ff e8 	ld.w	r10,r7[-24]
80008bee:	ee fb ff f0 	ld.w	r11,r7[-16]
80008bf2:	ee fc ff f4 	ld.w	r12,r7[-12]
80008bf6:	f0 1f 00 19 	mcall	80008c58 <xQueueGenericSendFromISR+0x9c>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80008bfa:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008bfe:	71 28       	ld.w	r8,r8[0x48]
80008c00:	5b f8       	cp.w	r8,-1
80008c02:	c1 41       	brne	80008c2a <xQueueGenericSendFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008c04:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008c08:	70 98       	ld.w	r8,r8[0x24]
80008c0a:	58 08       	cp.w	r8,0
80008c0c:	c1 80       	breq	80008c3c <xQueueGenericSendFromISR+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008c0e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008c12:	2d c8       	sub	r8,-36
80008c14:	10 9c       	mov	r12,r8
80008c16:	f0 1f 00 12 	mcall	80008c5c <xQueueGenericSendFromISR+0xa0>
80008c1a:	18 98       	mov	r8,r12
80008c1c:	58 08       	cp.w	r8,0
80008c1e:	c0 f0       	breq	80008c3c <xQueueGenericSendFromISR+0x80>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80008c20:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008c24:	30 19       	mov	r9,1
80008c26:	91 09       	st.w	r8[0x0],r9
80008c28:	c0 a8       	rjmp	80008c3c <xQueueGenericSendFromISR+0x80>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80008c2a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008c2e:	71 28       	ld.w	r8,r8[0x48]
80008c30:	f0 c9 ff ff 	sub	r9,r8,-1
80008c34:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008c38:	f1 49 00 48 	st.w	r8[72],r9
			}

			xReturn = pdPASS;
80008c3c:	30 18       	mov	r8,1
80008c3e:	ef 48 ff f8 	st.w	r7[-8],r8
80008c42:	c0 48       	rjmp	80008c4a <xQueueGenericSendFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
80008c44:	30 08       	mov	r8,0
80008c46:	ef 48 ff f8 	st.w	r7[-8],r8
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
80008c4a:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80008c4e:	10 9c       	mov	r12,r8
80008c50:	2f ad       	sub	sp,-24
80008c52:	e3 cd 80 80 	ldm	sp++,r7,pc
80008c56:	00 00       	add	r0,r0
80008c58:	80 00       	ld.sh	r0,r0[0x0]
80008c5a:	8e f0       	ld.uh	r0,r7[0xe]
80008c5c:	80 00       	ld.sh	r0,r0[0x0]
80008c5e:	98 bc       	ld.uh	r12,r12[0x6]

80008c60 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80008c60:	eb cd 40 80 	pushm	r7,lr
80008c64:	1a 97       	mov	r7,sp
80008c66:	20 8d       	sub	sp,32
80008c68:	ef 4c ff ec 	st.w	r7[-20],r12
80008c6c:	ef 4b ff e8 	st.w	r7[-24],r11
80008c70:	ef 4a ff e4 	st.w	r7[-28],r10
80008c74:	ef 49 ff e0 	st.w	r7[-32],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
80008c78:	30 08       	mov	r8,0
80008c7a:	ef 48 ff f8 	st.w	r7[-8],r8
80008c7e:	c0 28       	rjmp	80008c82 <xQueueGenericReceive+0x22>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80008c80:	d7 03       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80008c82:	f0 1f 00 66 	mcall	80008e18 <xQueueGenericReceive+0x1b8>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008c86:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008c8a:	70 e8       	ld.w	r8,r8[0x38]
80008c8c:	58 08       	cp.w	r8,0
80008c8e:	c4 c0       	breq	80008d26 <xQueueGenericReceive+0xc6>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80008c90:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008c94:	70 38       	ld.w	r8,r8[0xc]
80008c96:	ef 48 ff fc 	st.w	r7[-4],r8

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80008c9a:	ee fb ff e8 	ld.w	r11,r7[-24]
80008c9e:	ee fc ff ec 	ld.w	r12,r7[-20]
80008ca2:	f0 1f 00 5f 	mcall	80008e1c <xQueueGenericReceive+0x1bc>

				if( xJustPeeking == pdFALSE )
80008ca6:	ee f8 ff e0 	ld.w	r8,r7[-32]
80008caa:	58 08       	cp.w	r8,0
80008cac:	c2 51       	brne	80008cf6 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80008cae:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008cb2:	70 e8       	ld.w	r8,r8[0x38]
80008cb4:	f0 c9 00 01 	sub	r9,r8,1
80008cb8:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008cbc:	91 e9       	st.w	r8[0x38],r9

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008cbe:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008cc2:	70 08       	ld.w	r8,r8[0x0]
80008cc4:	58 08       	cp.w	r8,0
80008cc6:	c0 81       	brne	80008cd6 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80008cc8:	f0 1f 00 56 	mcall	80008e20 <xQueueGenericReceive+0x1c0>
80008ccc:	18 98       	mov	r8,r12
80008cce:	10 99       	mov	r9,r8
80008cd0:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008cd4:	91 19       	st.w	r8[0x4],r9
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008cd6:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008cda:	70 48       	ld.w	r8,r8[0x10]
80008cdc:	58 08       	cp.w	r8,0
80008cde:	c2 00       	breq	80008d1e <xQueueGenericReceive+0xbe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80008ce0:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008ce4:	2f 08       	sub	r8,-16
80008ce6:	10 9c       	mov	r12,r8
80008ce8:	f0 1f 00 4f 	mcall	80008e24 <xQueueGenericReceive+0x1c4>
80008cec:	18 98       	mov	r8,r12
80008cee:	58 18       	cp.w	r8,1
80008cf0:	c1 71       	brne	80008d1e <xQueueGenericReceive+0xbe>
						{
							portYIELD_WITHIN_API();
80008cf2:	d7 33       	scall
80008cf4:	c1 58       	rjmp	80008d1e <xQueueGenericReceive+0xbe>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80008cf6:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008cfa:	ee f9 ff fc 	ld.w	r9,r7[-4]
80008cfe:	91 39       	st.w	r8[0xc],r9

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80008d00:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008d04:	70 98       	ld.w	r8,r8[0x24]
80008d06:	58 08       	cp.w	r8,0
80008d08:	c0 b0       	breq	80008d1e <xQueueGenericReceive+0xbe>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80008d0a:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008d0e:	2d c8       	sub	r8,-36
80008d10:	10 9c       	mov	r12,r8
80008d12:	f0 1f 00 45 	mcall	80008e24 <xQueueGenericReceive+0x1c4>
80008d16:	18 98       	mov	r8,r12
80008d18:	58 08       	cp.w	r8,0
80008d1a:	c0 20       	breq	80008d1e <xQueueGenericReceive+0xbe>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80008d1c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80008d1e:	f0 1f 00 43 	mcall	80008e28 <xQueueGenericReceive+0x1c8>
				return pdPASS;
80008d22:	30 18       	mov	r8,1
80008d24:	c7 58       	rjmp	80008e0e <xQueueGenericReceive+0x1ae>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80008d26:	ee f8 ff e4 	ld.w	r8,r7[-28]
80008d2a:	58 08       	cp.w	r8,0
80008d2c:	c0 51       	brne	80008d36 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80008d2e:	f0 1f 00 3f 	mcall	80008e28 <xQueueGenericReceive+0x1c8>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80008d32:	30 08       	mov	r8,0
80008d34:	c6 d8       	rjmp	80008e0e <xQueueGenericReceive+0x1ae>
				}
				else if( xEntryTimeSet == pdFALSE )
80008d36:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008d3a:	58 08       	cp.w	r8,0
80008d3c:	c0 91       	brne	80008d4e <xQueueGenericReceive+0xee>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80008d3e:	ee c8 00 10 	sub	r8,r7,16
80008d42:	10 9c       	mov	r12,r8
80008d44:	f0 1f 00 3a 	mcall	80008e2c <xQueueGenericReceive+0x1cc>
					xEntryTimeSet = pdTRUE;
80008d48:	30 18       	mov	r8,1
80008d4a:	ef 48 ff f8 	st.w	r7[-8],r8
				}
			}
		}
		taskEXIT_CRITICAL();
80008d4e:	f0 1f 00 37 	mcall	80008e28 <xQueueGenericReceive+0x1c8>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80008d52:	f0 1f 00 38 	mcall	80008e30 <xQueueGenericReceive+0x1d0>
		prvLockQueue( pxQueue );
80008d56:	f0 1f 00 31 	mcall	80008e18 <xQueueGenericReceive+0x1b8>
80008d5a:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008d5e:	71 18       	ld.w	r8,r8[0x44]
80008d60:	5b f8       	cp.w	r8,-1
80008d62:	c0 61       	brne	80008d6e <xQueueGenericReceive+0x10e>
80008d64:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008d68:	30 09       	mov	r9,0
80008d6a:	f1 49 00 44 	st.w	r8[68],r9
80008d6e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008d72:	71 28       	ld.w	r8,r8[0x48]
80008d74:	5b f8       	cp.w	r8,-1
80008d76:	c0 61       	brne	80008d82 <xQueueGenericReceive+0x122>
80008d78:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008d7c:	30 09       	mov	r9,0
80008d7e:	f1 49 00 48 	st.w	r8[72],r9
80008d82:	f0 1f 00 2a 	mcall	80008e28 <xQueueGenericReceive+0x1c8>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80008d86:	ee c9 00 1c 	sub	r9,r7,28
80008d8a:	ee c8 00 10 	sub	r8,r7,16
80008d8e:	12 9b       	mov	r11,r9
80008d90:	10 9c       	mov	r12,r8
80008d92:	f0 1f 00 29 	mcall	80008e34 <xQueueGenericReceive+0x1d4>
80008d96:	18 98       	mov	r8,r12
80008d98:	58 08       	cp.w	r8,0
80008d9a:	c3 31       	brne	80008e00 <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) )
80008d9c:	ee fc ff ec 	ld.w	r12,r7[-20]
80008da0:	f0 1f 00 26 	mcall	80008e38 <xQueueGenericReceive+0x1d8>
80008da4:	18 98       	mov	r8,r12
80008da6:	58 08       	cp.w	r8,0
80008da8:	c2 50       	breq	80008df2 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008daa:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008dae:	70 08       	ld.w	r8,r8[0x0]
80008db0:	58 08       	cp.w	r8,0
80008db2:	c0 b1       	brne	80008dc8 <xQueueGenericReceive+0x168>
					{
						portENTER_CRITICAL();
80008db4:	f0 1f 00 19 	mcall	80008e18 <xQueueGenericReceive+0x1b8>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80008db8:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008dbc:	70 18       	ld.w	r8,r8[0x4]
80008dbe:	10 9c       	mov	r12,r8
80008dc0:	f0 1f 00 1f 	mcall	80008e3c <xQueueGenericReceive+0x1dc>
						}
						portEXIT_CRITICAL();
80008dc4:	f0 1f 00 19 	mcall	80008e28 <xQueueGenericReceive+0x1c8>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80008dc8:	ee f9 ff e4 	ld.w	r9,r7[-28]
80008dcc:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008dd0:	2d c8       	sub	r8,-36
80008dd2:	12 9b       	mov	r11,r9
80008dd4:	10 9c       	mov	r12,r8
80008dd6:	f0 1f 00 1b 	mcall	80008e40 <xQueueGenericReceive+0x1e0>
				prvUnlockQueue( pxQueue );
80008dda:	ee fc ff ec 	ld.w	r12,r7[-20]
80008dde:	f0 1f 00 1a 	mcall	80008e44 <xQueueGenericReceive+0x1e4>
				if( !xTaskResumeAll() )
80008de2:	f0 1f 00 1a 	mcall	80008e48 <xQueueGenericReceive+0x1e8>
80008de6:	18 98       	mov	r8,r12
80008de8:	58 08       	cp.w	r8,0
80008dea:	fe 91 ff 4b 	brne	80008c80 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
80008dee:	d7 33       	scall
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80008df0:	c4 9b       	rjmp	80008c82 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80008df2:	ee fc ff ec 	ld.w	r12,r7[-20]
80008df6:	f0 1f 00 14 	mcall	80008e44 <xQueueGenericReceive+0x1e4>
				( void ) xTaskResumeAll();
80008dfa:	f0 1f 00 14 	mcall	80008e48 <xQueueGenericReceive+0x1e8>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
80008dfe:	c4 2b       	rjmp	80008c82 <xQueueGenericReceive+0x22>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80008e00:	ee fc ff ec 	ld.w	r12,r7[-20]
80008e04:	f0 1f 00 10 	mcall	80008e44 <xQueueGenericReceive+0x1e4>
			( void ) xTaskResumeAll();
80008e08:	f0 1f 00 10 	mcall	80008e48 <xQueueGenericReceive+0x1e8>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
80008e0c:	30 08       	mov	r8,0
		}
	}
}
80008e0e:	10 9c       	mov	r12,r8
80008e10:	2f 8d       	sub	sp,-32
80008e12:	e3 cd 80 80 	ldm	sp++,r7,pc
80008e16:	00 00       	add	r0,r0
80008e18:	80 00       	ld.sh	r0,r0[0x0]
80008e1a:	85 20       	st.w	r2[0x8],r0
80008e1c:	80 00       	ld.sh	r0,r0[0x0]
80008e1e:	8f f4       	st.w	r7[0x3c],r4
80008e20:	80 00       	ld.sh	r0,r0[0x0]
80008e22:	9d cc       	st.w	lr[0x30],r12
80008e24:	80 00       	ld.sh	r0,r0[0x0]
80008e26:	98 bc       	ld.uh	r12,r12[0x6]
80008e28:	80 00       	ld.sh	r0,r0[0x0]
80008e2a:	85 3c       	st.w	r2[0xc],r12
80008e2c:	80 00       	ld.sh	r0,r0[0x0]
80008e2e:	99 8c       	st.w	r12[0x20],r12
80008e30:	80 00       	ld.sh	r0,r0[0x0]
80008e32:	94 b8       	ld.uh	r8,r10[0x6]
80008e34:	80 00       	ld.sh	r0,r0[0x0]
80008e36:	99 bc       	st.w	r12[0x2c],r12
80008e38:	80 00       	ld.sh	r0,r0[0x0]
80008e3a:	91 30       	st.w	r8[0xc],r0
80008e3c:	80 00       	ld.sh	r0,r0[0x0]
80008e3e:	9d ec       	st.w	lr[0x38],r12
80008e40:	80 00       	ld.sh	r0,r0[0x0]
80008e42:	98 3c       	ld.sh	r12,r12[0x6]
80008e44:	80 00       	ld.sh	r0,r0[0x0]
80008e46:	90 60       	ld.sh	r0,r8[0xc]
80008e48:	80 00       	ld.sh	r0,r0[0x0]
80008e4a:	94 d4       	ld.uh	r4,r10[0xa]

80008e4c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80008e4c:	eb cd 40 80 	pushm	r7,lr
80008e50:	1a 97       	mov	r7,sp
80008e52:	20 5d       	sub	sp,20
80008e54:	ef 4c ff f4 	st.w	r7[-12],r12
80008e58:	ef 4b ff f0 	st.w	r7[-16],r11
80008e5c:	ef 4a ff ec 	st.w	r7[-20],r10

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80008e60:	30 08       	mov	r8,0
80008e62:	ef 48 ff fc 	st.w	r7[-4],r8
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80008e66:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008e6a:	70 e8       	ld.w	r8,r8[0x38]
80008e6c:	58 08       	cp.w	r8,0
80008e6e:	c3 40       	breq	80008ed6 <xQueueReceiveFromISR+0x8a>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80008e70:	ee fb ff f0 	ld.w	r11,r7[-16]
80008e74:	ee fc ff f4 	ld.w	r12,r7[-12]
80008e78:	f0 1f 00 1c 	mcall	80008ee8 <xQueueReceiveFromISR+0x9c>
			--( pxQueue->uxMessagesWaiting );
80008e7c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008e80:	70 e8       	ld.w	r8,r8[0x38]
80008e82:	f0 c9 00 01 	sub	r9,r8,1
80008e86:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008e8a:	91 e9       	st.w	r8[0x38],r9

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80008e8c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008e90:	71 18       	ld.w	r8,r8[0x44]
80008e92:	5b f8       	cp.w	r8,-1
80008e94:	c1 41       	brne	80008ebc <xQueueReceiveFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80008e96:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008e9a:	70 48       	ld.w	r8,r8[0x10]
80008e9c:	58 08       	cp.w	r8,0
80008e9e:	c1 80       	breq	80008ece <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80008ea0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008ea4:	2f 08       	sub	r8,-16
80008ea6:	10 9c       	mov	r12,r8
80008ea8:	f0 1f 00 11 	mcall	80008eec <xQueueReceiveFromISR+0xa0>
80008eac:	18 98       	mov	r8,r12
80008eae:	58 08       	cp.w	r8,0
80008eb0:	c0 f0       	breq	80008ece <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80008eb2:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008eb6:	30 19       	mov	r9,1
80008eb8:	91 09       	st.w	r8[0x0],r9
80008eba:	c0 a8       	rjmp	80008ece <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80008ebc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008ec0:	71 18       	ld.w	r8,r8[0x44]
80008ec2:	f0 c9 ff ff 	sub	r9,r8,-1
80008ec6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008eca:	f1 49 00 44 	st.w	r8[68],r9
			}

			xReturn = pdPASS;
80008ece:	30 18       	mov	r8,1
80008ed0:	ef 48 ff f8 	st.w	r7[-8],r8
80008ed4:	c0 48       	rjmp	80008edc <xQueueReceiveFromISR+0x90>
		}
		else
		{
			xReturn = pdFAIL;
80008ed6:	30 08       	mov	r8,0
80008ed8:	ef 48 ff f8 	st.w	r7[-8],r8
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
80008edc:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80008ee0:	10 9c       	mov	r12,r8
80008ee2:	2f bd       	sub	sp,-20
80008ee4:	e3 cd 80 80 	ldm	sp++,r7,pc
80008ee8:	80 00       	ld.sh	r0,r0[0x0]
80008eea:	8f f4       	st.w	r7[0x3c],r4
80008eec:	80 00       	ld.sh	r0,r0[0x0]
80008eee:	98 bc       	ld.uh	r12,r12[0x6]

80008ef0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80008ef0:	eb cd 40 80 	pushm	r7,lr
80008ef4:	1a 97       	mov	r7,sp
80008ef6:	20 3d       	sub	sp,12
80008ef8:	ef 4c ff fc 	st.w	r7[-4],r12
80008efc:	ef 4b ff f8 	st.w	r7[-8],r11
80008f00:	ef 4a ff f4 	st.w	r7[-12],r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80008f04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f08:	71 08       	ld.w	r8,r8[0x40]
80008f0a:	58 08       	cp.w	r8,0
80008f0c:	c1 11       	brne	80008f2e <prvCopyDataToQueue+0x3e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80008f0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f12:	70 08       	ld.w	r8,r8[0x0]
80008f14:	58 08       	cp.w	r8,0
80008f16:	c5 f1       	brne	80008fd4 <prvCopyDataToQueue+0xe4>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80008f18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f1c:	70 18       	ld.w	r8,r8[0x4]
80008f1e:	10 9c       	mov	r12,r8
80008f20:	f0 1f 00 33 	mcall	80008fec <prvCopyDataToQueue+0xfc>
				pxQueue->pxMutexHolder = NULL;
80008f24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f28:	30 09       	mov	r9,0
80008f2a:	91 19       	st.w	r8[0x4],r9
80008f2c:	c5 48       	rjmp	80008fd4 <prvCopyDataToQueue+0xe4>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80008f2e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008f32:	58 08       	cp.w	r8,0
80008f34:	c2 61       	brne	80008f80 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008f36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f3a:	71 09       	ld.w	r9,r8[0x40]
80008f3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f40:	70 28       	ld.w	r8,r8[0x8]
80008f42:	12 9a       	mov	r10,r9
80008f44:	ee fb ff f8 	ld.w	r11,r7[-8]
80008f48:	10 9c       	mov	r12,r8
80008f4a:	f0 1f 00 2a 	mcall	80008ff0 <prvCopyDataToQueue+0x100>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80008f4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f52:	70 29       	ld.w	r9,r8[0x8]
80008f54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f58:	71 08       	ld.w	r8,r8[0x40]
80008f5a:	10 09       	add	r9,r8
80008f5c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f60:	91 29       	st.w	r8[0x8],r9
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80008f62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f66:	70 29       	ld.w	r9,r8[0x8]
80008f68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f6c:	70 18       	ld.w	r8,r8[0x4]
80008f6e:	10 39       	cp.w	r9,r8
80008f70:	c3 23       	brcs	80008fd4 <prvCopyDataToQueue+0xe4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80008f72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f76:	70 09       	ld.w	r9,r8[0x0]
80008f78:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f7c:	91 29       	st.w	r8[0x8],r9
80008f7e:	c2 b8       	rjmp	80008fd4 <prvCopyDataToQueue+0xe4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80008f80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f84:	71 09       	ld.w	r9,r8[0x40]
80008f86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f8a:	70 38       	ld.w	r8,r8[0xc]
80008f8c:	12 9a       	mov	r10,r9
80008f8e:	ee fb ff f8 	ld.w	r11,r7[-8]
80008f92:	10 9c       	mov	r12,r8
80008f94:	f0 1f 00 17 	mcall	80008ff0 <prvCopyDataToQueue+0x100>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80008f98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008f9c:	70 39       	ld.w	r9,r8[0xc]
80008f9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008fa2:	71 08       	ld.w	r8,r8[0x40]
80008fa4:	5c 38       	neg	r8
80008fa6:	10 09       	add	r9,r8
80008fa8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008fac:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80008fae:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008fb2:	70 39       	ld.w	r9,r8[0xc]
80008fb4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008fb8:	70 08       	ld.w	r8,r8[0x0]
80008fba:	10 39       	cp.w	r9,r8
80008fbc:	c0 c2       	brcc	80008fd4 <prvCopyDataToQueue+0xe4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80008fbe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008fc2:	70 19       	ld.w	r9,r8[0x4]
80008fc4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008fc8:	71 08       	ld.w	r8,r8[0x40]
80008fca:	5c 38       	neg	r8
80008fcc:	10 09       	add	r9,r8
80008fce:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008fd2:	91 39       	st.w	r8[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80008fd4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008fd8:	70 e8       	ld.w	r8,r8[0x38]
80008fda:	f0 c9 ff ff 	sub	r9,r8,-1
80008fde:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008fe2:	91 e9       	st.w	r8[0x38],r9
}
80008fe4:	2f dd       	sub	sp,-12
80008fe6:	e3 cd 80 80 	ldm	sp++,r7,pc
80008fea:	00 00       	add	r0,r0
80008fec:	80 00       	ld.sh	r0,r0[0x0]
80008fee:	9e c0       	ld.uh	r0,pc[0x8]
80008ff0:	80 00       	ld.sh	r0,r0[0x0]
80008ff2:	b0 72       	st.h	r8[0xe],r2

80008ff4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80008ff4:	eb cd 40 80 	pushm	r7,lr
80008ff8:	1a 97       	mov	r7,sp
80008ffa:	20 2d       	sub	sp,8
80008ffc:	ef 4c ff fc 	st.w	r7[-4],r12
80009000:	ef 4b ff f8 	st.w	r7[-8],r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80009004:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009008:	70 08       	ld.w	r8,r8[0x0]
8000900a:	58 08       	cp.w	r8,0
8000900c:	c2 50       	breq	80009056 <prvCopyDataFromQueue+0x62>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000900e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009012:	70 39       	ld.w	r9,r8[0xc]
80009014:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009018:	71 08       	ld.w	r8,r8[0x40]
8000901a:	10 09       	add	r9,r8
8000901c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009020:	91 39       	st.w	r8[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80009022:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009026:	70 39       	ld.w	r9,r8[0xc]
80009028:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000902c:	70 18       	ld.w	r8,r8[0x4]
8000902e:	10 39       	cp.w	r9,r8
80009030:	c0 73       	brcs	8000903e <prvCopyDataFromQueue+0x4a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80009032:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009036:	70 09       	ld.w	r9,r8[0x0]
80009038:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000903c:	91 39       	st.w	r8[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000903e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009042:	71 09       	ld.w	r9,r8[0x40]
80009044:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009048:	70 38       	ld.w	r8,r8[0xc]
8000904a:	12 9a       	mov	r10,r9
8000904c:	10 9b       	mov	r11,r8
8000904e:	ee fc ff f8 	ld.w	r12,r7[-8]
80009052:	f0 1f 00 03 	mcall	8000905c <prvCopyDataFromQueue+0x68>
	}
}
80009056:	2f ed       	sub	sp,-8
80009058:	e3 cd 80 80 	ldm	sp++,r7,pc
8000905c:	80 00       	ld.sh	r0,r0[0x0]
8000905e:	b0 72       	st.h	r8[0xe],r2

80009060 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80009060:	eb cd 40 80 	pushm	r7,lr
80009064:	1a 97       	mov	r7,sp
80009066:	20 1d       	sub	sp,4
80009068:	ef 4c ff fc 	st.w	r7[-4],r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000906c:	f0 1f 00 2d 	mcall	80009120 <prvUnlockQueue+0xc0>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80009070:	c1 a8       	rjmp	800090a4 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80009072:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009076:	70 98       	ld.w	r8,r8[0x24]
80009078:	58 08       	cp.w	r8,0
8000907a:	c1 c0       	breq	800090b2 <prvUnlockQueue+0x52>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000907c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009080:	2d c8       	sub	r8,-36
80009082:	10 9c       	mov	r12,r8
80009084:	f0 1f 00 28 	mcall	80009124 <prvUnlockQueue+0xc4>
80009088:	18 98       	mov	r8,r12
8000908a:	58 08       	cp.w	r8,0
8000908c:	c0 30       	breq	80009092 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
8000908e:	f0 1f 00 27 	mcall	80009128 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xTxLock );
80009092:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009096:	71 28       	ld.w	r8,r8[0x48]
80009098:	f0 c9 00 01 	sub	r9,r8,1
8000909c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800090a0:	f1 49 00 48 	st.w	r8[72],r9
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800090a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800090a8:	71 28       	ld.w	r8,r8[0x48]
800090aa:	58 08       	cp.w	r8,0
800090ac:	fe 99 ff e3 	brgt	80009072 <prvUnlockQueue+0x12>
800090b0:	c0 28       	rjmp	800090b4 <prvUnlockQueue+0x54>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
800090b2:	d7 03       	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800090b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800090b8:	3f f9       	mov	r9,-1
800090ba:	f1 49 00 48 	st.w	r8[72],r9
	}
	taskEXIT_CRITICAL();
800090be:	f0 1f 00 1c 	mcall	8000912c <prvUnlockQueue+0xcc>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800090c2:	f0 1f 00 18 	mcall	80009120 <prvUnlockQueue+0xc0>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800090c6:	c1 a8       	rjmp	800090fa <prvUnlockQueue+0x9a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800090c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800090cc:	70 48       	ld.w	r8,r8[0x10]
800090ce:	58 08       	cp.w	r8,0
800090d0:	c1 c0       	breq	80009108 <prvUnlockQueue+0xa8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800090d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800090d6:	2f 08       	sub	r8,-16
800090d8:	10 9c       	mov	r12,r8
800090da:	f0 1f 00 13 	mcall	80009124 <prvUnlockQueue+0xc4>
800090de:	18 98       	mov	r8,r12
800090e0:	58 08       	cp.w	r8,0
800090e2:	c0 30       	breq	800090e8 <prvUnlockQueue+0x88>
				{
					vTaskMissedYield();
800090e4:	f0 1f 00 11 	mcall	80009128 <prvUnlockQueue+0xc8>
				}

				--( pxQueue->xRxLock );
800090e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800090ec:	71 18       	ld.w	r8,r8[0x44]
800090ee:	f0 c9 00 01 	sub	r9,r8,1
800090f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800090f6:	f1 49 00 44 	st.w	r8[68],r9
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800090fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800090fe:	71 18       	ld.w	r8,r8[0x44]
80009100:	58 08       	cp.w	r8,0
80009102:	fe 99 ff e3 	brgt	800090c8 <prvUnlockQueue+0x68>
80009106:	c0 28       	rjmp	8000910a <prvUnlockQueue+0xaa>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
80009108:	d7 03       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
8000910a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000910e:	3f f9       	mov	r9,-1
80009110:	f1 49 00 44 	st.w	r8[68],r9
	}
	taskEXIT_CRITICAL();
80009114:	f0 1f 00 06 	mcall	8000912c <prvUnlockQueue+0xcc>
}
80009118:	2f fd       	sub	sp,-4
8000911a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000911e:	00 00       	add	r0,r0
80009120:	80 00       	ld.sh	r0,r0[0x0]
80009122:	85 20       	st.w	r2[0x8],r0
80009124:	80 00       	ld.sh	r0,r0[0x0]
80009126:	98 bc       	ld.uh	r12,r12[0x6]
80009128:	80 00       	ld.sh	r0,r0[0x0]
8000912a:	9a 74       	ld.sh	r4,sp[0xe]
8000912c:	80 00       	ld.sh	r0,r0[0x0]
8000912e:	85 3c       	st.w	r2[0xc],r12

80009130 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
80009130:	eb cd 40 80 	pushm	r7,lr
80009134:	1a 97       	mov	r7,sp
80009136:	20 2d       	sub	sp,8
80009138:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000913c:	f0 1f 00 09 	mcall	80009160 <prvIsQueueEmpty+0x30>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80009140:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009144:	70 e8       	ld.w	r8,r8[0x38]
80009146:	58 08       	cp.w	r8,0
80009148:	5f 08       	sreq	r8
8000914a:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
8000914e:	f0 1f 00 06 	mcall	80009164 <prvIsQueueEmpty+0x34>

	return xReturn;
80009152:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009156:	10 9c       	mov	r12,r8
80009158:	2f ed       	sub	sp,-8
8000915a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000915e:	00 00       	add	r0,r0
80009160:	80 00       	ld.sh	r0,r0[0x0]
80009162:	85 20       	st.w	r2[0x8],r0
80009164:	80 00       	ld.sh	r0,r0[0x0]
80009166:	85 3c       	st.w	r2[0xc],r12

80009168 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
80009168:	eb cd 40 80 	pushm	r7,lr
8000916c:	1a 97       	mov	r7,sp
8000916e:	20 2d       	sub	sp,8
80009170:	ef 4c ff f8 	st.w	r7[-8],r12
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80009174:	f0 1f 00 0a 	mcall	8000919c <prvIsQueueFull+0x34>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80009178:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000917c:	70 e9       	ld.w	r9,r8[0x38]
8000917e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009182:	70 f8       	ld.w	r8,r8[0x3c]
80009184:	10 39       	cp.w	r9,r8
80009186:	5f 08       	sreq	r8
80009188:	ef 48 ff fc 	st.w	r7[-4],r8
	taskEXIT_CRITICAL();
8000918c:	f0 1f 00 05 	mcall	800091a0 <prvIsQueueFull+0x38>

	return xReturn;
80009190:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009194:	10 9c       	mov	r12,r8
80009196:	2f ed       	sub	sp,-8
80009198:	e3 cd 80 80 	ldm	sp++,r7,pc
8000919c:	80 00       	ld.sh	r0,r0[0x0]
8000919e:	85 20       	st.w	r2[0x8],r0
800091a0:	80 00       	ld.sh	r0,r0[0x0]
800091a2:	85 3c       	st.w	r2[0xc],r12
800091a4:	49 44       	lddpc	r4,800091f4 <xTaskGenericCreate+0x48>
800091a6:	4c 45       	lddpc	r5,800092b4 <xTaskGenericCreate+0x108>
800091a8:	00 00       	add	r0,r0
	...

800091ac <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800091ac:	eb cd 40 c0 	pushm	r6-r7,lr
800091b0:	1a 97       	mov	r7,sp
800091b2:	20 8d       	sub	sp,32
800091b4:	ee c6 ff f4 	sub	r6,r7,-12
800091b8:	ef 4c ff f0 	st.w	r7[-16],r12
800091bc:	ef 4b ff ec 	st.w	r7[-20],r11
800091c0:	ef 49 ff e4 	st.w	r7[-28],r9
800091c4:	ef 48 ff e0 	st.w	r7[-32],r8
800091c8:	14 98       	mov	r8,r10
800091ca:	ef 58 ff e8 	st.h	r7[-24],r8
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
800091ce:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800091d2:	6c 1b       	ld.w	r11,r6[0x4]
800091d4:	10 9c       	mov	r12,r8
800091d6:	f0 1f 00 5a 	mcall	8000933c <xTaskGenericCreate+0x190>
800091da:	18 98       	mov	r8,r12
800091dc:	ef 48 ff f8 	st.w	r7[-8],r8

	if( pxNewTCB != NULL )
800091e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800091e4:	58 08       	cp.w	r8,0
800091e6:	e0 80 00 92 	breq	8000930a <xTaskGenericCreate+0x15e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
800091ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800091ee:	70 c9       	ld.w	r9,r8[0x30]
800091f0:	ef 18 ff e8 	ld.uh	r8,r7[-24]
800091f4:	20 18       	sub	r8,1
800091f6:	a3 68       	lsl	r8,0x2
800091f8:	f2 08 00 08 	add	r8,r9,r8
800091fc:	ef 48 ff fc 	st.w	r7[-4],r8
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80009200:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009204:	e0 18 ff fc 	andl	r8,0xfffc
80009208:	ef 48 ff fc 	st.w	r7[-4],r8
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
8000920c:	ef 18 ff e8 	ld.uh	r8,r7[-24]
80009210:	6c 29       	ld.w	r9,r6[0x8]
80009212:	ee fa ff e0 	ld.w	r10,r7[-32]
80009216:	ee fb ff ec 	ld.w	r11,r7[-20]
8000921a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000921e:	f0 1f 00 49 	mcall	80009340 <xTaskGenericCreate+0x194>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80009222:	ee fa ff e4 	ld.w	r10,r7[-28]
80009226:	ee fb ff f0 	ld.w	r11,r7[-16]
8000922a:	ee fc ff fc 	ld.w	r12,r7[-4]
8000922e:	f0 1f 00 46 	mcall	80009344 <xTaskGenericCreate+0x198>
80009232:	18 98       	mov	r8,r12
80009234:	10 99       	mov	r9,r8
80009236:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000923a:	91 09       	st.w	r8[0x0],r9
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
8000923c:	6c 08       	ld.w	r8,r6[0x0]
8000923e:	58 08       	cp.w	r8,0
80009240:	c0 50       	breq	8000924a <xTaskGenericCreate+0x9e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80009242:	6c 08       	ld.w	r8,r6[0x0]
80009244:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009248:	91 09       	st.w	r8[0x0],r9
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000924a:	f0 1f 00 40 	mcall	80009348 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
8000924e:	4c 08       	lddpc	r8,8000934c <xTaskGenericCreate+0x1a0>
80009250:	70 08       	ld.w	r8,r8[0x0]
80009252:	f0 c9 ff ff 	sub	r9,r8,-1
80009256:	4b e8       	lddpc	r8,8000934c <xTaskGenericCreate+0x1a0>
80009258:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000925a:	4b e8       	lddpc	r8,80009350 <xTaskGenericCreate+0x1a4>
8000925c:	70 08       	ld.w	r8,r8[0x0]
8000925e:	58 08       	cp.w	r8,0
80009260:	c0 c1       	brne	80009278 <xTaskGenericCreate+0xcc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80009262:	4b c8       	lddpc	r8,80009350 <xTaskGenericCreate+0x1a4>
80009264:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009268:	91 09       	st.w	r8[0x0],r9

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000926a:	4b 98       	lddpc	r8,8000934c <xTaskGenericCreate+0x1a0>
8000926c:	70 08       	ld.w	r8,r8[0x0]
8000926e:	58 18       	cp.w	r8,1
80009270:	c1 41       	brne	80009298 <xTaskGenericCreate+0xec>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
80009272:	f0 1f 00 39 	mcall	80009354 <xTaskGenericCreate+0x1a8>
80009276:	c1 18       	rjmp	80009298 <xTaskGenericCreate+0xec>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80009278:	4b 88       	lddpc	r8,80009358 <xTaskGenericCreate+0x1ac>
8000927a:	70 08       	ld.w	r8,r8[0x0]
8000927c:	58 08       	cp.w	r8,0
8000927e:	c0 d1       	brne	80009298 <xTaskGenericCreate+0xec>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80009280:	4b 48       	lddpc	r8,80009350 <xTaskGenericCreate+0x1a4>
80009282:	70 08       	ld.w	r8,r8[0x0]
80009284:	70 b9       	ld.w	r9,r8[0x2c]
80009286:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000928a:	10 39       	cp.w	r9,r8
8000928c:	e0 8b 00 06 	brhi	80009298 <xTaskGenericCreate+0xec>
					{
						pxCurrentTCB = pxNewTCB;
80009290:	4b 08       	lddpc	r8,80009350 <xTaskGenericCreate+0x1a4>
80009292:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009296:	91 09       	st.w	r8[0x0],r9
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80009298:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000929c:	70 b9       	ld.w	r9,r8[0x2c]
8000929e:	4b 08       	lddpc	r8,8000935c <xTaskGenericCreate+0x1b0>
800092a0:	70 08       	ld.w	r8,r8[0x0]
800092a2:	10 39       	cp.w	r9,r8
800092a4:	e0 88 00 07 	brls	800092b2 <xTaskGenericCreate+0x106>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800092a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800092ac:	70 b9       	ld.w	r9,r8[0x2c]
800092ae:	4a c8       	lddpc	r8,8000935c <xTaskGenericCreate+0x1b0>
800092b0:	91 09       	st.w	r8[0x0],r9
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800092b2:	4a c8       	lddpc	r8,80009360 <xTaskGenericCreate+0x1b4>
800092b4:	70 08       	ld.w	r8,r8[0x0]
800092b6:	f0 c9 ff ff 	sub	r9,r8,-1
800092ba:	4a a8       	lddpc	r8,80009360 <xTaskGenericCreate+0x1b4>
800092bc:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800092be:	ee f8 ff f8 	ld.w	r8,r7[-8]
800092c2:	70 b9       	ld.w	r9,r8[0x2c]
800092c4:	4a 88       	lddpc	r8,80009364 <xTaskGenericCreate+0x1b8>
800092c6:	70 08       	ld.w	r8,r8[0x0]
800092c8:	10 39       	cp.w	r9,r8
800092ca:	e0 88 00 07 	brls	800092d8 <xTaskGenericCreate+0x12c>
800092ce:	ee f8 ff f8 	ld.w	r8,r7[-8]
800092d2:	70 b9       	ld.w	r9,r8[0x2c]
800092d4:	4a 48       	lddpc	r8,80009364 <xTaskGenericCreate+0x1b8>
800092d6:	91 09       	st.w	r8[0x0],r9
800092d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800092dc:	f0 ca ff fc 	sub	r10,r8,-4
800092e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800092e4:	70 b9       	ld.w	r9,r8[0x2c]
800092e6:	12 98       	mov	r8,r9
800092e8:	a3 68       	lsl	r8,0x2
800092ea:	12 08       	add	r8,r9
800092ec:	a3 68       	lsl	r8,0x2
800092ee:	10 99       	mov	r9,r8
800092f0:	49 e8       	lddpc	r8,80009368 <xTaskGenericCreate+0x1bc>
800092f2:	f2 08 00 08 	add	r8,r9,r8
800092f6:	14 9b       	mov	r11,r10
800092f8:	10 9c       	mov	r12,r8
800092fa:	f0 1f 00 1d 	mcall	8000936c <xTaskGenericCreate+0x1c0>

			xReturn = pdPASS;
800092fe:	30 18       	mov	r8,1
80009300:	ef 48 ff f4 	st.w	r7[-12],r8
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80009304:	f0 1f 00 1b 	mcall	80009370 <xTaskGenericCreate+0x1c4>
80009308:	c0 48       	rjmp	80009310 <xTaskGenericCreate+0x164>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
8000930a:	3f f8       	mov	r8,-1
8000930c:	ef 48 ff f4 	st.w	r7[-12],r8
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
80009310:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009314:	58 18       	cp.w	r8,1
80009316:	c0 d1       	brne	80009330 <xTaskGenericCreate+0x184>
	{
		if( xSchedulerRunning != pdFALSE )
80009318:	49 08       	lddpc	r8,80009358 <xTaskGenericCreate+0x1ac>
8000931a:	70 08       	ld.w	r8,r8[0x0]
8000931c:	58 08       	cp.w	r8,0
8000931e:	c0 90       	breq	80009330 <xTaskGenericCreate+0x184>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80009320:	48 c8       	lddpc	r8,80009350 <xTaskGenericCreate+0x1a4>
80009322:	70 08       	ld.w	r8,r8[0x0]
80009324:	70 b9       	ld.w	r9,r8[0x2c]
80009326:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000932a:	10 39       	cp.w	r9,r8
8000932c:	c0 22       	brcc	80009330 <xTaskGenericCreate+0x184>
			{
				portYIELD_WITHIN_API();
8000932e:	d7 33       	scall
			}
		}
	}

	return xReturn;
80009330:	ee f8 ff f4 	ld.w	r8,r7[-12]
}
80009334:	10 9c       	mov	r12,r8
80009336:	2f 8d       	sub	sp,-32
80009338:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000933c:	80 00       	ld.sh	r0,r0[0x0]
8000933e:	9d 0c       	st.w	lr[0x0],r12
80009340:	80 00       	ld.sh	r0,r0[0x0]
80009342:	9a b8       	ld.uh	r8,sp[0x6]
80009344:	80 00       	ld.sh	r0,r0[0x0]
80009346:	85 68       	st.w	r2[0x18],r8
80009348:	80 00       	ld.sh	r0,r0[0x0]
8000934a:	85 20       	st.w	r2[0x8],r0
8000934c:	00 00       	add	r0,r0
8000934e:	0d 38       	ld.ub	r8,r6++
80009350:	00 00       	add	r0,r0
80009352:	0c 24       	rsub	r4,r6
80009354:	80 00       	ld.sh	r0,r0[0x0]
80009356:	9b 60       	st.w	sp[0x18],r0
80009358:	00 00       	add	r0,r0
8000935a:	0d 48       	ld.w	r8,--r6
8000935c:	00 00       	add	r0,r0
8000935e:	0d 40       	ld.w	r0,--r6
80009360:	00 00       	add	r0,r0
80009362:	0d 5c       	ld.sh	r12,--r6
80009364:	00 00       	add	r0,r0
80009366:	0d 44       	ld.w	r4,--r6
80009368:	00 00       	add	r0,r0
8000936a:	0c 28       	rsub	r8,r6
8000936c:	80 00       	ld.sh	r0,r0[0x0]
8000936e:	82 4e       	ld.sh	lr,r1[0x8]
80009370:	80 00       	ld.sh	r0,r0[0x0]
80009372:	85 3c       	st.w	r2[0xc],r12

80009374 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80009374:	eb cd 40 80 	pushm	r7,lr
80009378:	1a 97       	mov	r7,sp
8000937a:	20 5d       	sub	sp,20
8000937c:	ef 4c ff f0 	st.w	r7[-16],r12
80009380:	ef 4b ff ec 	st.w	r7[-20],r11
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
80009384:	30 08       	mov	r8,0
80009386:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000938a:	f0 1f 00 2d 	mcall	8000943c <vTaskDelayUntil+0xc8>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
8000938e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80009392:	70 09       	ld.w	r9,r8[0x0]
80009394:	ee f8 ff ec 	ld.w	r8,r7[-20]
80009398:	f2 08 00 08 	add	r8,r9,r8
8000939c:	ef 48 ff f4 	st.w	r7[-12],r8

			if( xTickCount < *pxPreviousWakeTime )
800093a0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800093a4:	70 09       	ld.w	r9,r8[0x0]
800093a6:	4a 78       	lddpc	r8,80009440 <vTaskDelayUntil+0xcc>
800093a8:	70 08       	ld.w	r8,r8[0x0]
800093aa:	10 39       	cp.w	r9,r8
800093ac:	e0 88 00 15 	brls	800093d6 <vTaskDelayUntil+0x62>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800093b0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800093b4:	70 09       	ld.w	r9,r8[0x0]
800093b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800093ba:	10 39       	cp.w	r9,r8
800093bc:	e0 88 00 1f 	brls	800093fa <vTaskDelayUntil+0x86>
800093c0:	4a 08       	lddpc	r8,80009440 <vTaskDelayUntil+0xcc>
800093c2:	70 08       	ld.w	r8,r8[0x0]
800093c4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800093c8:	10 39       	cp.w	r9,r8
800093ca:	e0 88 00 18 	brls	800093fa <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
800093ce:	30 18       	mov	r8,1
800093d0:	ef 48 ff fc 	st.w	r7[-4],r8
800093d4:	c1 38       	rjmp	800093fa <vTaskDelayUntil+0x86>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
800093d6:	ee f8 ff f0 	ld.w	r8,r7[-16]
800093da:	70 09       	ld.w	r9,r8[0x0]
800093dc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800093e0:	10 39       	cp.w	r9,r8
800093e2:	e0 8b 00 09 	brhi	800093f4 <vTaskDelayUntil+0x80>
800093e6:	49 78       	lddpc	r8,80009440 <vTaskDelayUntil+0xcc>
800093e8:	70 08       	ld.w	r8,r8[0x0]
800093ea:	ee f9 ff f4 	ld.w	r9,r7[-12]
800093ee:	10 39       	cp.w	r9,r8
800093f0:	e0 88 00 05 	brls	800093fa <vTaskDelayUntil+0x86>
				{
					xShouldDelay = pdTRUE;
800093f4:	30 18       	mov	r8,1
800093f6:	ef 48 ff fc 	st.w	r7[-4],r8
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800093fa:	ee f8 ff f0 	ld.w	r8,r7[-16]
800093fe:	ee f9 ff f4 	ld.w	r9,r7[-12]
80009402:	91 09       	st.w	r8[0x0],r9

			if( xShouldDelay != pdFALSE )
80009404:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009408:	58 08       	cp.w	r8,0
8000940a:	c0 b0       	breq	80009420 <vTaskDelayUntil+0xac>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000940c:	48 e8       	lddpc	r8,80009444 <vTaskDelayUntil+0xd0>
8000940e:	70 08       	ld.w	r8,r8[0x0]
80009410:	2f c8       	sub	r8,-4
80009412:	10 9c       	mov	r12,r8
80009414:	f0 1f 00 0d 	mcall	80009448 <vTaskDelayUntil+0xd4>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80009418:	ee fc ff f4 	ld.w	r12,r7[-12]
8000941c:	f0 1f 00 0c 	mcall	8000944c <vTaskDelayUntil+0xd8>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80009420:	f0 1f 00 0c 	mcall	80009450 <vTaskDelayUntil+0xdc>
80009424:	18 98       	mov	r8,r12
80009426:	ef 48 ff f8 	st.w	r7[-8],r8

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000942a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000942e:	58 08       	cp.w	r8,0
80009430:	c0 21       	brne	80009434 <vTaskDelayUntil+0xc0>
		{
			portYIELD_WITHIN_API();
80009432:	d7 33       	scall
		}
	}
80009434:	2f bd       	sub	sp,-20
80009436:	e3 cd 80 80 	ldm	sp++,r7,pc
8000943a:	00 00       	add	r0,r0
8000943c:	80 00       	ld.sh	r0,r0[0x0]
8000943e:	94 b8       	ld.uh	r8,r10[0x6]
80009440:	00 00       	add	r0,r0
80009442:	0d 3c       	ld.ub	r12,r6++
80009444:	00 00       	add	r0,r0
80009446:	0c 24       	rsub	r4,r6
80009448:	80 00       	ld.sh	r0,r0[0x0]
8000944a:	83 62       	st.w	r1[0x18],r2
8000944c:	80 00       	ld.sh	r0,r0[0x0]
8000944e:	9c 8c       	ld.uh	r12,lr[0x0]
80009450:	80 00       	ld.sh	r0,r0[0x0]
80009452:	94 d4       	ld.uh	r4,r10[0xa]

80009454 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80009454:	eb cd 40 80 	pushm	r7,lr
80009458:	1a 97       	mov	r7,sp
8000945a:	20 1d       	sub	sp,4
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000945c:	49 1b       	lddpc	r11,800094a0 <vTaskStartScheduler+0x4c>
8000945e:	30 08       	mov	r8,0
80009460:	1a d8       	st.w	--sp,r8
80009462:	30 08       	mov	r8,0
80009464:	1a d8       	st.w	--sp,r8
80009466:	30 08       	mov	r8,0
80009468:	1a d8       	st.w	--sp,r8
8000946a:	30 08       	mov	r8,0
8000946c:	30 09       	mov	r9,0
8000946e:	e0 6a 01 00 	mov	r10,256
80009472:	48 dc       	lddpc	r12,800094a4 <vTaskStartScheduler+0x50>
80009474:	f0 1f 00 0d 	mcall	800094a8 <vTaskStartScheduler+0x54>
80009478:	2f dd       	sub	sp,-12
8000947a:	18 98       	mov	r8,r12
8000947c:	ef 48 ff fc 	st.w	r7[-4],r8
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80009480:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009484:	58 18       	cp.w	r8,1
80009486:	c0 a1       	brne	8000949a <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80009488:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000948a:	48 98       	lddpc	r8,800094ac <vTaskStartScheduler+0x58>
8000948c:	30 19       	mov	r9,1
8000948e:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80009490:	48 88       	lddpc	r8,800094b0 <vTaskStartScheduler+0x5c>
80009492:	30 09       	mov	r9,0
80009494:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80009496:	f0 1f 00 08 	mcall	800094b4 <vTaskStartScheduler+0x60>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
8000949a:	2f fd       	sub	sp,-4
8000949c:	e3 cd 80 80 	ldm	sp++,r7,pc
800094a0:	80 00       	ld.sh	r0,r0[0x0]
800094a2:	91 a4       	st.w	r8[0x28],r4
800094a4:	80 00       	ld.sh	r0,r0[0x0]
800094a6:	9a 88       	ld.uh	r8,sp[0x0]
800094a8:	80 00       	ld.sh	r0,r0[0x0]
800094aa:	91 ac       	st.w	r8[0x28],r12
800094ac:	00 00       	add	r0,r0
800094ae:	0d 48       	ld.w	r8,--r6
800094b0:	00 00       	add	r0,r0
800094b2:	0d 3c       	ld.ub	r12,r6++
800094b4:	80 00       	ld.sh	r0,r0[0x0]
800094b6:	87 10       	st.w	r3[0x4],r0

800094b8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
800094b8:	eb cd 40 80 	pushm	r7,lr
800094bc:	1a 97       	mov	r7,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800094be:	48 58       	lddpc	r8,800094d0 <vTaskSuspendAll+0x18>
800094c0:	70 08       	ld.w	r8,r8[0x0]
800094c2:	f0 c9 ff ff 	sub	r9,r8,-1
800094c6:	48 38       	lddpc	r8,800094d0 <vTaskSuspendAll+0x18>
800094c8:	91 09       	st.w	r8[0x0],r9
}
800094ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800094ce:	00 00       	add	r0,r0
800094d0:	00 00       	add	r0,r0
800094d2:	0d 4c       	ld.w	r12,--r6

800094d4 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800094d4:	eb cd 40 c0 	pushm	r6-r7,lr
800094d8:	1a 97       	mov	r7,sp
800094da:	20 2d       	sub	sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
800094dc:	30 08       	mov	r8,0
800094de:	ef 48 ff f8 	st.w	r7[-8],r8
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800094e2:	f0 1f 00 3a 	mcall	800095c8 <xTaskResumeAll+0xf4>
	{
		--uxSchedulerSuspended;
800094e6:	4b a8       	lddpc	r8,800095cc <xTaskResumeAll+0xf8>
800094e8:	70 08       	ld.w	r8,r8[0x0]
800094ea:	f0 c9 00 01 	sub	r9,r8,1
800094ee:	4b 88       	lddpc	r8,800095cc <xTaskResumeAll+0xf8>
800094f0:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800094f2:	4b 78       	lddpc	r8,800095cc <xTaskResumeAll+0xf8>
800094f4:	70 08       	ld.w	r8,r8[0x0]
800094f6:	58 08       	cp.w	r8,0
800094f8:	c5 f1       	brne	800095b6 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800094fa:	4b 68       	lddpc	r8,800095d0 <xTaskResumeAll+0xfc>
800094fc:	70 08       	ld.w	r8,r8[0x0]
800094fe:	58 08       	cp.w	r8,0
80009500:	c5 b0       	breq	800095b6 <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
80009502:	30 08       	mov	r8,0
80009504:	ef 48 ff fc 	st.w	r7[-4],r8

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80009508:	c3 08       	rjmp	80009568 <xTaskResumeAll+0x94>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000950a:	4b 38       	lddpc	r8,800095d4 <xTaskResumeAll+0x100>
8000950c:	70 38       	ld.w	r8,r8[0xc]
8000950e:	70 38       	ld.w	r8,r8[0xc]
80009510:	10 96       	mov	r6,r8
					vListRemove( &( pxTCB->xEventListItem ) );
80009512:	ec c8 ff e8 	sub	r8,r6,-24
80009516:	10 9c       	mov	r12,r8
80009518:	f0 1f 00 30 	mcall	800095d8 <xTaskResumeAll+0x104>
					vListRemove( &( pxTCB->xGenericListItem ) );
8000951c:	ec c8 ff fc 	sub	r8,r6,-4
80009520:	10 9c       	mov	r12,r8
80009522:	f0 1f 00 2e 	mcall	800095d8 <xTaskResumeAll+0x104>
					prvAddTaskToReadyQueue( pxTCB );
80009526:	6c b9       	ld.w	r9,r6[0x2c]
80009528:	4a d8       	lddpc	r8,800095dc <xTaskResumeAll+0x108>
8000952a:	70 08       	ld.w	r8,r8[0x0]
8000952c:	10 39       	cp.w	r9,r8
8000952e:	e0 88 00 05 	brls	80009538 <xTaskResumeAll+0x64>
80009532:	6c b9       	ld.w	r9,r6[0x2c]
80009534:	4a a8       	lddpc	r8,800095dc <xTaskResumeAll+0x108>
80009536:	91 09       	st.w	r8[0x0],r9
80009538:	ec ca ff fc 	sub	r10,r6,-4
8000953c:	6c b9       	ld.w	r9,r6[0x2c]
8000953e:	12 98       	mov	r8,r9
80009540:	a3 68       	lsl	r8,0x2
80009542:	12 08       	add	r8,r9
80009544:	a3 68       	lsl	r8,0x2
80009546:	10 99       	mov	r9,r8
80009548:	4a 68       	lddpc	r8,800095e0 <xTaskResumeAll+0x10c>
8000954a:	f2 08 00 08 	add	r8,r9,r8
8000954e:	14 9b       	mov	r11,r10
80009550:	10 9c       	mov	r12,r8
80009552:	f0 1f 00 25 	mcall	800095e4 <xTaskResumeAll+0x110>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009556:	6c b9       	ld.w	r9,r6[0x2c]
80009558:	4a 48       	lddpc	r8,800095e8 <xTaskResumeAll+0x114>
8000955a:	70 08       	ld.w	r8,r8[0x0]
8000955c:	70 b8       	ld.w	r8,r8[0x2c]
8000955e:	10 39       	cp.w	r9,r8
80009560:	c0 43       	brcs	80009568 <xTaskResumeAll+0x94>
					{
						xYieldRequired = pdTRUE;
80009562:	30 18       	mov	r8,1
80009564:	ef 48 ff fc 	st.w	r7[-4],r8
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80009568:	49 b8       	lddpc	r8,800095d4 <xTaskResumeAll+0x100>
8000956a:	70 08       	ld.w	r8,r8[0x0]
8000956c:	58 08       	cp.w	r8,0
8000956e:	cc e1       	brne	8000950a <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009570:	49 f8       	lddpc	r8,800095ec <xTaskResumeAll+0x118>
80009572:	70 08       	ld.w	r8,r8[0x0]
80009574:	58 08       	cp.w	r8,0
80009576:	c1 10       	breq	80009598 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80009578:	c0 98       	rjmp	8000958a <xTaskResumeAll+0xb6>
					{
						vTaskIncrementTick();
8000957a:	f0 1f 00 1e 	mcall	800095f0 <xTaskResumeAll+0x11c>
						--uxMissedTicks;
8000957e:	49 c8       	lddpc	r8,800095ec <xTaskResumeAll+0x118>
80009580:	70 08       	ld.w	r8,r8[0x0]
80009582:	f0 c9 00 01 	sub	r9,r8,1
80009586:	49 a8       	lddpc	r8,800095ec <xTaskResumeAll+0x118>
80009588:	91 09       	st.w	r8[0x0],r9
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000958a:	49 98       	lddpc	r8,800095ec <xTaskResumeAll+0x118>
8000958c:	70 08       	ld.w	r8,r8[0x0]
8000958e:	58 08       	cp.w	r8,0
80009590:	cf 51       	brne	8000957a <xTaskResumeAll+0xa6>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
80009592:	30 18       	mov	r8,1
80009594:	ef 48 ff fc 	st.w	r7[-4],r8
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80009598:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000959c:	58 18       	cp.w	r8,1
8000959e:	c0 50       	breq	800095a8 <xTaskResumeAll+0xd4>
800095a0:	49 58       	lddpc	r8,800095f4 <xTaskResumeAll+0x120>
800095a2:	70 08       	ld.w	r8,r8[0x0]
800095a4:	58 18       	cp.w	r8,1
800095a6:	c0 81       	brne	800095b6 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
800095a8:	30 18       	mov	r8,1
800095aa:	ef 48 ff f8 	st.w	r7[-8],r8
					xMissedYield = pdFALSE;
800095ae:	49 28       	lddpc	r8,800095f4 <xTaskResumeAll+0x120>
800095b0:	30 09       	mov	r9,0
800095b2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800095b4:	d7 33       	scall
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800095b6:	f0 1f 00 11 	mcall	800095f8 <xTaskResumeAll+0x124>

	return xAlreadyYielded;
800095ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800095be:	10 9c       	mov	r12,r8
800095c0:	2f ed       	sub	sp,-8
800095c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800095c6:	00 00       	add	r0,r0
800095c8:	80 00       	ld.sh	r0,r0[0x0]
800095ca:	85 20       	st.w	r2[0x8],r0
800095cc:	00 00       	add	r0,r0
800095ce:	0d 4c       	ld.w	r12,--r6
800095d0:	00 00       	add	r0,r0
800095d2:	0d 38       	ld.ub	r8,r6++
800095d4:	00 00       	add	r0,r0
800095d6:	0c f8       	st.b	--r6,r8
800095d8:	80 00       	ld.sh	r0,r0[0x0]
800095da:	83 62       	st.w	r1[0x18],r2
800095dc:	00 00       	add	r0,r0
800095de:	0d 44       	ld.w	r4,--r6
800095e0:	00 00       	add	r0,r0
800095e2:	0c 28       	rsub	r8,r6
800095e4:	80 00       	ld.sh	r0,r0[0x0]
800095e6:	82 4e       	ld.sh	lr,r1[0x8]
800095e8:	00 00       	add	r0,r0
800095ea:	0c 24       	rsub	r4,r6
800095ec:	00 00       	add	r0,r0
800095ee:	0d 50       	ld.sh	r0,--r6
800095f0:	80 00       	ld.sh	r0,r0[0x0]
800095f2:	96 2c       	ld.sh	r12,r11[0x4]
800095f4:	00 00       	add	r0,r0
800095f6:	0d 54       	ld.sh	r4,--r6
800095f8:	80 00       	ld.sh	r0,r0[0x0]
800095fa:	85 3c       	st.w	r2[0xc],r12

800095fc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800095fc:	eb cd 40 80 	pushm	r7,lr
80009600:	1a 97       	mov	r7,sp
80009602:	20 1d       	sub	sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80009604:	f0 1f 00 07 	mcall	80009620 <xTaskGetTickCount+0x24>
	{
		xTicks = xTickCount;
80009608:	48 78       	lddpc	r8,80009624 <xTaskGetTickCount+0x28>
8000960a:	70 08       	ld.w	r8,r8[0x0]
8000960c:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	taskEXIT_CRITICAL();
80009610:	f0 1f 00 06 	mcall	80009628 <xTaskGetTickCount+0x2c>

	return xTicks;
80009614:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009618:	10 9c       	mov	r12,r8
8000961a:	2f fd       	sub	sp,-4
8000961c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009620:	80 00       	ld.sh	r0,r0[0x0]
80009622:	85 20       	st.w	r2[0x8],r0
80009624:	00 00       	add	r0,r0
80009626:	0d 3c       	ld.ub	r12,r6++
80009628:	80 00       	ld.sh	r0,r0[0x0]
8000962a:	85 3c       	st.w	r2[0xc],r12

8000962c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
8000962c:	eb cd 40 80 	pushm	r7,lr
80009630:	1a 97       	mov	r7,sp
80009632:	20 3d       	sub	sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80009634:	4c b8       	lddpc	r8,80009760 <vTaskIncrementTick+0x134>
80009636:	70 08       	ld.w	r8,r8[0x0]
80009638:	58 08       	cp.w	r8,0
8000963a:	e0 81 00 89 	brne	8000974c <vTaskIncrementTick+0x120>
	{
		++xTickCount;
8000963e:	4c a8       	lddpc	r8,80009764 <vTaskIncrementTick+0x138>
80009640:	70 08       	ld.w	r8,r8[0x0]
80009642:	f0 c9 ff ff 	sub	r9,r8,-1
80009646:	4c 88       	lddpc	r8,80009764 <vTaskIncrementTick+0x138>
80009648:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000964a:	4c 78       	lddpc	r8,80009764 <vTaskIncrementTick+0x138>
8000964c:	70 08       	ld.w	r8,r8[0x0]
8000964e:	58 08       	cp.w	r8,0
80009650:	c2 71       	brne	8000969e <vTaskIncrementTick+0x72>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80009652:	4c 68       	lddpc	r8,80009768 <vTaskIncrementTick+0x13c>
80009654:	70 08       	ld.w	r8,r8[0x0]
80009656:	ef 48 ff f8 	st.w	r7[-8],r8
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000965a:	4c 58       	lddpc	r8,8000976c <vTaskIncrementTick+0x140>
8000965c:	70 09       	ld.w	r9,r8[0x0]
8000965e:	4c 38       	lddpc	r8,80009768 <vTaskIncrementTick+0x13c>
80009660:	91 09       	st.w	r8[0x0],r9
			pxOverflowDelayedTaskList = pxTemp;
80009662:	4c 38       	lddpc	r8,8000976c <vTaskIncrementTick+0x140>
80009664:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009668:	91 09       	st.w	r8[0x0],r9
			xNumOfOverflows++;
8000966a:	4c 28       	lddpc	r8,80009770 <vTaskIncrementTick+0x144>
8000966c:	70 08       	ld.w	r8,r8[0x0]
8000966e:	f0 c9 ff ff 	sub	r9,r8,-1
80009672:	4c 08       	lddpc	r8,80009770 <vTaskIncrementTick+0x144>
80009674:	91 09       	st.w	r8[0x0],r9

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80009676:	4b d8       	lddpc	r8,80009768 <vTaskIncrementTick+0x13c>
80009678:	70 08       	ld.w	r8,r8[0x0]
8000967a:	70 08       	ld.w	r8,r8[0x0]
8000967c:	58 08       	cp.w	r8,0
8000967e:	c0 51       	brne	80009688 <vTaskIncrementTick+0x5c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80009680:	4b d8       	lddpc	r8,80009774 <vTaskIncrementTick+0x148>
80009682:	3f f9       	mov	r9,-1
80009684:	91 09       	st.w	r8[0x0],r9
80009686:	c0 c8       	rjmp	8000969e <vTaskIncrementTick+0x72>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80009688:	4b 88       	lddpc	r8,80009768 <vTaskIncrementTick+0x13c>
8000968a:	70 08       	ld.w	r8,r8[0x0]
8000968c:	70 38       	ld.w	r8,r8[0xc]
8000968e:	70 38       	ld.w	r8,r8[0xc]
80009690:	ef 48 ff f4 	st.w	r7[-12],r8
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80009694:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009698:	70 19       	ld.w	r9,r8[0x4]
8000969a:	4b 78       	lddpc	r8,80009774 <vTaskIncrementTick+0x148>
8000969c:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000969e:	4b 28       	lddpc	r8,80009764 <vTaskIncrementTick+0x138>
800096a0:	70 09       	ld.w	r9,r8[0x0]
800096a2:	4b 58       	lddpc	r8,80009774 <vTaskIncrementTick+0x148>
800096a4:	70 08       	ld.w	r8,r8[0x0]
800096a6:	10 39       	cp.w	r9,r8
800096a8:	c5 83       	brcs	80009758 <vTaskIncrementTick+0x12c>
800096aa:	4b 08       	lddpc	r8,80009768 <vTaskIncrementTick+0x13c>
800096ac:	70 08       	ld.w	r8,r8[0x0]
800096ae:	70 08       	ld.w	r8,r8[0x0]
800096b0:	58 08       	cp.w	r8,0
800096b2:	c0 51       	brne	800096bc <vTaskIncrementTick+0x90>
800096b4:	4b 08       	lddpc	r8,80009774 <vTaskIncrementTick+0x148>
800096b6:	3f f9       	mov	r9,-1
800096b8:	91 09       	st.w	r8[0x0],r9
800096ba:	c4 f8       	rjmp	80009758 <vTaskIncrementTick+0x12c>
800096bc:	4a b8       	lddpc	r8,80009768 <vTaskIncrementTick+0x13c>
800096be:	70 08       	ld.w	r8,r8[0x0]
800096c0:	70 38       	ld.w	r8,r8[0xc]
800096c2:	70 38       	ld.w	r8,r8[0xc]
800096c4:	ef 48 ff f4 	st.w	r7[-12],r8
800096c8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800096cc:	70 18       	ld.w	r8,r8[0x4]
800096ce:	ef 48 ff fc 	st.w	r7[-4],r8
800096d2:	4a 58       	lddpc	r8,80009764 <vTaskIncrementTick+0x138>
800096d4:	70 09       	ld.w	r9,r8[0x0]
800096d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800096da:	10 39       	cp.w	r9,r8
800096dc:	c0 62       	brcc	800096e8 <vTaskIncrementTick+0xbc>
800096de:	4a 68       	lddpc	r8,80009774 <vTaskIncrementTick+0x148>
800096e0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800096e4:	91 09       	st.w	r8[0x0],r9
800096e6:	c3 98       	rjmp	80009758 <vTaskIncrementTick+0x12c>
800096e8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800096ec:	2f c8       	sub	r8,-4
800096ee:	10 9c       	mov	r12,r8
800096f0:	f0 1f 00 22 	mcall	80009778 <vTaskIncrementTick+0x14c>
800096f4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800096f8:	70 a8       	ld.w	r8,r8[0x28]
800096fa:	58 08       	cp.w	r8,0
800096fc:	c0 70       	breq	8000970a <vTaskIncrementTick+0xde>
800096fe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009702:	2e 88       	sub	r8,-24
80009704:	10 9c       	mov	r12,r8
80009706:	f0 1f 00 1d 	mcall	80009778 <vTaskIncrementTick+0x14c>
8000970a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000970e:	70 b9       	ld.w	r9,r8[0x2c]
80009710:	49 b8       	lddpc	r8,8000977c <vTaskIncrementTick+0x150>
80009712:	70 08       	ld.w	r8,r8[0x0]
80009714:	10 39       	cp.w	r9,r8
80009716:	e0 88 00 07 	brls	80009724 <vTaskIncrementTick+0xf8>
8000971a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000971e:	70 b9       	ld.w	r9,r8[0x2c]
80009720:	49 78       	lddpc	r8,8000977c <vTaskIncrementTick+0x150>
80009722:	91 09       	st.w	r8[0x0],r9
80009724:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009728:	f0 ca ff fc 	sub	r10,r8,-4
8000972c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009730:	70 b9       	ld.w	r9,r8[0x2c]
80009732:	12 98       	mov	r8,r9
80009734:	a3 68       	lsl	r8,0x2
80009736:	12 08       	add	r8,r9
80009738:	a3 68       	lsl	r8,0x2
8000973a:	10 99       	mov	r9,r8
8000973c:	49 18       	lddpc	r8,80009780 <vTaskIncrementTick+0x154>
8000973e:	f2 08 00 08 	add	r8,r9,r8
80009742:	14 9b       	mov	r11,r10
80009744:	10 9c       	mov	r12,r8
80009746:	f0 1f 00 10 	mcall	80009784 <vTaskIncrementTick+0x158>
8000974a:	cb 0b       	rjmp	800096aa <vTaskIncrementTick+0x7e>
	}
	else
	{
		++uxMissedTicks;
8000974c:	48 f8       	lddpc	r8,80009788 <vTaskIncrementTick+0x15c>
8000974e:	70 08       	ld.w	r8,r8[0x0]
80009750:	f0 c9 ff ff 	sub	r9,r8,-1
80009754:	48 d8       	lddpc	r8,80009788 <vTaskIncrementTick+0x15c>
80009756:	91 09       	st.w	r8[0x0],r9
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
80009758:	2f dd       	sub	sp,-12
8000975a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000975e:	00 00       	add	r0,r0
80009760:	00 00       	add	r0,r0
80009762:	0d 4c       	ld.w	r12,--r6
80009764:	00 00       	add	r0,r0
80009766:	0d 3c       	ld.ub	r12,r6++
80009768:	00 00       	add	r0,r0
8000976a:	0c f0       	st.b	--r6,r0
8000976c:	00 00       	add	r0,r0
8000976e:	0c f4       	st.b	--r6,r4
80009770:	00 00       	add	r0,r0
80009772:	0d 58       	ld.sh	r8,--r6
80009774:	00 00       	add	r0,r0
80009776:	05 4c       	ld.w	r12,--r2
80009778:	80 00       	ld.sh	r0,r0[0x0]
8000977a:	83 62       	st.w	r1[0x18],r2
8000977c:	00 00       	add	r0,r0
8000977e:	0d 44       	ld.w	r4,--r6
80009780:	00 00       	add	r0,r0
80009782:	0c 28       	rsub	r8,r6
80009784:	80 00       	ld.sh	r0,r0[0x0]
80009786:	82 4e       	ld.sh	lr,r1[0x8]
80009788:	00 00       	add	r0,r0
8000978a:	0d 50       	ld.sh	r0,--r6

8000978c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
8000978c:	eb cd 40 80 	pushm	r7,lr
80009790:	1a 97       	mov	r7,sp
80009792:	20 1d       	sub	sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80009794:	4a 58       	lddpc	r8,80009828 <vTaskSwitchContext+0x9c>
80009796:	70 08       	ld.w	r8,r8[0x0]
80009798:	58 08       	cp.w	r8,0
8000979a:	c0 c0       	breq	800097b2 <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
8000979c:	4a 48       	lddpc	r8,8000982c <vTaskSwitchContext+0xa0>
8000979e:	30 19       	mov	r9,1
800097a0:	91 09       	st.w	r8[0x0],r9
800097a2:	c3 f8       	rjmp	80009820 <vTaskSwitchContext+0x94>

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800097a4:	4a 38       	lddpc	r8,80009830 <vTaskSwitchContext+0xa4>
800097a6:	70 08       	ld.w	r8,r8[0x0]
800097a8:	f0 c9 00 01 	sub	r9,r8,1
800097ac:	4a 18       	lddpc	r8,80009830 <vTaskSwitchContext+0xa4>
800097ae:	91 09       	st.w	r8[0x0],r9
800097b0:	c0 28       	rjmp	800097b4 <vTaskSwitchContext+0x28>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800097b2:	d7 03       	nop
800097b4:	49 f8       	lddpc	r8,80009830 <vTaskSwitchContext+0xa4>
800097b6:	70 09       	ld.w	r9,r8[0x0]
800097b8:	12 98       	mov	r8,r9
800097ba:	a3 68       	lsl	r8,0x2
800097bc:	12 08       	add	r8,r9
800097be:	a3 68       	lsl	r8,0x2
800097c0:	10 99       	mov	r9,r8
800097c2:	49 d8       	lddpc	r8,80009834 <vTaskSwitchContext+0xa8>
800097c4:	f2 08 00 08 	add	r8,r9,r8
800097c8:	70 08       	ld.w	r8,r8[0x0]
800097ca:	58 08       	cp.w	r8,0
800097cc:	ce c0       	breq	800097a4 <vTaskSwitchContext+0x18>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800097ce:	49 98       	lddpc	r8,80009830 <vTaskSwitchContext+0xa4>
800097d0:	70 09       	ld.w	r9,r8[0x0]
800097d2:	12 98       	mov	r8,r9
800097d4:	a3 68       	lsl	r8,0x2
800097d6:	12 08       	add	r8,r9
800097d8:	a3 68       	lsl	r8,0x2
800097da:	10 99       	mov	r9,r8
800097dc:	49 68       	lddpc	r8,80009834 <vTaskSwitchContext+0xa8>
800097de:	f2 08 00 08 	add	r8,r9,r8
800097e2:	ef 48 ff fc 	st.w	r7[-4],r8
800097e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800097ea:	70 18       	ld.w	r8,r8[0x4]
800097ec:	70 19       	ld.w	r9,r8[0x4]
800097ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800097f2:	91 19       	st.w	r8[0x4],r9
800097f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800097f8:	70 19       	ld.w	r9,r8[0x4]
800097fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800097fe:	2f 88       	sub	r8,-8
80009800:	10 39       	cp.w	r9,r8
80009802:	c0 81       	brne	80009812 <vTaskSwitchContext+0x86>
80009804:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009808:	70 18       	ld.w	r8,r8[0x4]
8000980a:	70 19       	ld.w	r9,r8[0x4]
8000980c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009810:	91 19       	st.w	r8[0x4],r9
80009812:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009816:	70 18       	ld.w	r8,r8[0x4]
80009818:	70 38       	ld.w	r8,r8[0xc]
8000981a:	10 99       	mov	r9,r8
8000981c:	48 78       	lddpc	r8,80009838 <vTaskSwitchContext+0xac>
8000981e:	91 09       	st.w	r8[0x0],r9

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
80009820:	2f fd       	sub	sp,-4
80009822:	e3 cd 80 80 	ldm	sp++,r7,pc
80009826:	00 00       	add	r0,r0
80009828:	00 00       	add	r0,r0
8000982a:	0d 4c       	ld.w	r12,--r6
8000982c:	00 00       	add	r0,r0
8000982e:	0d 54       	ld.sh	r4,--r6
80009830:	00 00       	add	r0,r0
80009832:	0d 44       	ld.w	r4,--r6
80009834:	00 00       	add	r0,r0
80009836:	0c 28       	rsub	r8,r6
80009838:	00 00       	add	r0,r0
8000983a:	0c 24       	rsub	r4,r6

8000983c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
8000983c:	eb cd 40 80 	pushm	r7,lr
80009840:	1a 97       	mov	r7,sp
80009842:	20 3d       	sub	sp,12
80009844:	ef 4c ff f8 	st.w	r7[-8],r12
80009848:	ef 4b ff f4 	st.w	r7[-12],r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000984c:	49 58       	lddpc	r8,800098a0 <vTaskPlaceOnEventList+0x64>
8000984e:	70 08       	ld.w	r8,r8[0x0]
80009850:	2e 88       	sub	r8,-24
80009852:	10 9b       	mov	r11,r8
80009854:	ee fc ff f8 	ld.w	r12,r7[-8]
80009858:	f0 1f 00 13 	mcall	800098a4 <vTaskPlaceOnEventList+0x68>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000985c:	49 18       	lddpc	r8,800098a0 <vTaskPlaceOnEventList+0x64>
8000985e:	70 08       	ld.w	r8,r8[0x0]
80009860:	2f c8       	sub	r8,-4
80009862:	10 9c       	mov	r12,r8
80009864:	f0 1f 00 11 	mcall	800098a8 <vTaskPlaceOnEventList+0x6c>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80009868:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000986c:	5b f8       	cp.w	r8,-1
8000986e:	c0 91       	brne	80009880 <vTaskPlaceOnEventList+0x44>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009870:	48 c8       	lddpc	r8,800098a0 <vTaskPlaceOnEventList+0x64>
80009872:	70 08       	ld.w	r8,r8[0x0]
80009874:	2f c8       	sub	r8,-4
80009876:	10 9b       	mov	r11,r8
80009878:	48 dc       	lddpc	r12,800098ac <vTaskPlaceOnEventList+0x70>
8000987a:	f0 1f 00 0e 	mcall	800098b0 <vTaskPlaceOnEventList+0x74>
8000987e:	c0 d8       	rjmp	80009898 <vTaskPlaceOnEventList+0x5c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80009880:	48 d8       	lddpc	r8,800098b4 <vTaskPlaceOnEventList+0x78>
80009882:	70 09       	ld.w	r9,r8[0x0]
80009884:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009888:	f2 08 00 08 	add	r8,r9,r8
8000988c:	ef 48 ff fc 	st.w	r7[-4],r8
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80009890:	ee fc ff fc 	ld.w	r12,r7[-4]
80009894:	f0 1f 00 09 	mcall	800098b8 <vTaskPlaceOnEventList+0x7c>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
80009898:	2f dd       	sub	sp,-12
8000989a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000989e:	00 00       	add	r0,r0
800098a0:	00 00       	add	r0,r0
800098a2:	0c 24       	rsub	r4,r6
800098a4:	80 00       	ld.sh	r0,r0[0x0]
800098a6:	82 c0       	ld.uh	r0,r1[0x8]
800098a8:	80 00       	ld.sh	r0,r0[0x0]
800098aa:	83 62       	st.w	r1[0x18],r2
800098ac:	00 00       	add	r0,r0
800098ae:	0d 24       	ld.uh	r4,r6++
800098b0:	80 00       	ld.sh	r0,r0[0x0]
800098b2:	82 4e       	ld.sh	lr,r1[0x8]
800098b4:	00 00       	add	r0,r0
800098b6:	0d 3c       	ld.ub	r12,r6++
800098b8:	80 00       	ld.sh	r0,r0[0x0]
800098ba:	9c 8c       	ld.uh	r12,lr[0x0]

800098bc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800098bc:	eb cd 40 80 	pushm	r7,lr
800098c0:	1a 97       	mov	r7,sp
800098c2:	20 3d       	sub	sp,12
800098c4:	ef 4c ff f4 	st.w	r7[-12],r12
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800098c8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800098cc:	70 38       	ld.w	r8,r8[0xc]
800098ce:	70 38       	ld.w	r8,r8[0xc]
800098d0:	ef 48 ff f8 	st.w	r7[-8],r8
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800098d4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800098d8:	2e 88       	sub	r8,-24
800098da:	10 9c       	mov	r12,r8
800098dc:	f0 1f 00 25 	mcall	80009970 <xTaskRemoveFromEventList+0xb4>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800098e0:	4a 58       	lddpc	r8,80009974 <xTaskRemoveFromEventList+0xb8>
800098e2:	70 08       	ld.w	r8,r8[0x0]
800098e4:	58 08       	cp.w	r8,0
800098e6:	c2 81       	brne	80009936 <xTaskRemoveFromEventList+0x7a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800098e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800098ec:	2f c8       	sub	r8,-4
800098ee:	10 9c       	mov	r12,r8
800098f0:	f0 1f 00 20 	mcall	80009970 <xTaskRemoveFromEventList+0xb4>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800098f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800098f8:	70 b9       	ld.w	r9,r8[0x2c]
800098fa:	4a 08       	lddpc	r8,80009978 <xTaskRemoveFromEventList+0xbc>
800098fc:	70 08       	ld.w	r8,r8[0x0]
800098fe:	10 39       	cp.w	r9,r8
80009900:	e0 88 00 07 	brls	8000990e <xTaskRemoveFromEventList+0x52>
80009904:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009908:	70 b9       	ld.w	r9,r8[0x2c]
8000990a:	49 c8       	lddpc	r8,80009978 <xTaskRemoveFromEventList+0xbc>
8000990c:	91 09       	st.w	r8[0x0],r9
8000990e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009912:	f0 ca ff fc 	sub	r10,r8,-4
80009916:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000991a:	70 b9       	ld.w	r9,r8[0x2c]
8000991c:	12 98       	mov	r8,r9
8000991e:	a3 68       	lsl	r8,0x2
80009920:	12 08       	add	r8,r9
80009922:	a3 68       	lsl	r8,0x2
80009924:	10 99       	mov	r9,r8
80009926:	49 68       	lddpc	r8,8000997c <xTaskRemoveFromEventList+0xc0>
80009928:	f2 08 00 08 	add	r8,r9,r8
8000992c:	14 9b       	mov	r11,r10
8000992e:	10 9c       	mov	r12,r8
80009930:	f0 1f 00 14 	mcall	80009980 <xTaskRemoveFromEventList+0xc4>
80009934:	c0 88       	rjmp	80009944 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80009936:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000993a:	2e 88       	sub	r8,-24
8000993c:	10 9b       	mov	r11,r8
8000993e:	49 2c       	lddpc	r12,80009984 <xTaskRemoveFromEventList+0xc8>
80009940:	f0 1f 00 10 	mcall	80009980 <xTaskRemoveFromEventList+0xc4>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80009944:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009948:	70 b9       	ld.w	r9,r8[0x2c]
8000994a:	49 08       	lddpc	r8,80009988 <xTaskRemoveFromEventList+0xcc>
8000994c:	70 08       	ld.w	r8,r8[0x0]
8000994e:	70 b8       	ld.w	r8,r8[0x2c]
80009950:	10 39       	cp.w	r9,r8
80009952:	c0 53       	brcs	8000995c <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
80009954:	30 18       	mov	r8,1
80009956:	ef 48 ff fc 	st.w	r7[-4],r8
8000995a:	c0 48       	rjmp	80009962 <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
8000995c:	30 08       	mov	r8,0
8000995e:	ef 48 ff fc 	st.w	r7[-4],r8
	}

	return xReturn;
80009962:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009966:	10 9c       	mov	r12,r8
80009968:	2f dd       	sub	sp,-12
8000996a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000996e:	00 00       	add	r0,r0
80009970:	80 00       	ld.sh	r0,r0[0x0]
80009972:	83 62       	st.w	r1[0x18],r2
80009974:	00 00       	add	r0,r0
80009976:	0d 4c       	ld.w	r12,--r6
80009978:	00 00       	add	r0,r0
8000997a:	0d 44       	ld.w	r4,--r6
8000997c:	00 00       	add	r0,r0
8000997e:	0c 28       	rsub	r8,r6
80009980:	80 00       	ld.sh	r0,r0[0x0]
80009982:	82 4e       	ld.sh	lr,r1[0x8]
80009984:	00 00       	add	r0,r0
80009986:	0c f8       	st.b	--r6,r8
80009988:	00 00       	add	r0,r0
8000998a:	0c 24       	rsub	r4,r6

8000998c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
8000998c:	eb cd 40 80 	pushm	r7,lr
80009990:	1a 97       	mov	r7,sp
80009992:	20 1d       	sub	sp,4
80009994:	ef 4c ff fc 	st.w	r7[-4],r12
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80009998:	48 78       	lddpc	r8,800099b4 <vTaskSetTimeOutState+0x28>
8000999a:	70 09       	ld.w	r9,r8[0x0]
8000999c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800099a0:	91 09       	st.w	r8[0x0],r9
	pxTimeOut->xTimeOnEntering = xTickCount;
800099a2:	48 68       	lddpc	r8,800099b8 <vTaskSetTimeOutState+0x2c>
800099a4:	70 09       	ld.w	r9,r8[0x0]
800099a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800099aa:	91 19       	st.w	r8[0x4],r9
}
800099ac:	2f fd       	sub	sp,-4
800099ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800099b2:	00 00       	add	r0,r0
800099b4:	00 00       	add	r0,r0
800099b6:	0d 58       	ld.sh	r8,--r6
800099b8:	00 00       	add	r0,r0
800099ba:	0d 3c       	ld.ub	r12,r6++

800099bc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800099bc:	eb cd 40 80 	pushm	r7,lr
800099c0:	1a 97       	mov	r7,sp
800099c2:	20 3d       	sub	sp,12
800099c4:	ef 4c ff f8 	st.w	r7[-8],r12
800099c8:	ef 4b ff f4 	st.w	r7[-12],r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800099cc:	f0 1f 00 25 	mcall	80009a60 <xTaskCheckForTimeOut+0xa4>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800099d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800099d4:	70 08       	ld.w	r8,r8[0x0]
800099d6:	5b f8       	cp.w	r8,-1
800099d8:	c0 51       	brne	800099e2 <xTaskCheckForTimeOut+0x26>
			{
				xReturn = pdFALSE;
800099da:	30 08       	mov	r8,0
800099dc:	ef 48 ff fc 	st.w	r7[-4],r8
800099e0:	c3 88       	rjmp	80009a50 <xTaskCheckForTimeOut+0x94>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800099e2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800099e6:	70 09       	ld.w	r9,r8[0x0]
800099e8:	49 f8       	lddpc	r8,80009a64 <xTaskCheckForTimeOut+0xa8>
800099ea:	70 08       	ld.w	r8,r8[0x0]
800099ec:	10 39       	cp.w	r9,r8
800099ee:	c0 d0       	breq	80009a08 <xTaskCheckForTimeOut+0x4c>
800099f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800099f4:	70 19       	ld.w	r9,r8[0x4]
800099f6:	49 d8       	lddpc	r8,80009a68 <xTaskCheckForTimeOut+0xac>
800099f8:	70 08       	ld.w	r8,r8[0x0]
800099fa:	10 39       	cp.w	r9,r8
800099fc:	e0 8b 00 06 	brhi	80009a08 <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
80009a00:	30 18       	mov	r8,1
80009a02:	ef 48 ff fc 	st.w	r7[-4],r8
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80009a06:	c2 58       	rjmp	80009a50 <xTaskCheckForTimeOut+0x94>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80009a08:	49 88       	lddpc	r8,80009a68 <xTaskCheckForTimeOut+0xac>
80009a0a:	70 09       	ld.w	r9,r8[0x0]
80009a0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009a10:	70 18       	ld.w	r8,r8[0x4]
80009a12:	10 19       	sub	r9,r8
80009a14:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009a18:	70 08       	ld.w	r8,r8[0x0]
80009a1a:	10 39       	cp.w	r9,r8
80009a1c:	c1 72       	brcc	80009a4a <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80009a1e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009a22:	70 09       	ld.w	r9,r8[0x0]
80009a24:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009a28:	70 1a       	ld.w	r10,r8[0x4]
80009a2a:	49 08       	lddpc	r8,80009a68 <xTaskCheckForTimeOut+0xac>
80009a2c:	70 08       	ld.w	r8,r8[0x0]
80009a2e:	f4 08 01 08 	sub	r8,r10,r8
80009a32:	10 09       	add	r9,r8
80009a34:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009a38:	91 09       	st.w	r8[0x0],r9
			vTaskSetTimeOutState( pxTimeOut );
80009a3a:	ee fc ff f8 	ld.w	r12,r7[-8]
80009a3e:	f0 1f 00 0c 	mcall	80009a6c <xTaskCheckForTimeOut+0xb0>
			xReturn = pdFALSE;
80009a42:	30 08       	mov	r8,0
80009a44:	ef 48 ff fc 	st.w	r7[-4],r8
80009a48:	c0 48       	rjmp	80009a50 <xTaskCheckForTimeOut+0x94>
		}
		else
		{
			xReturn = pdTRUE;
80009a4a:	30 18       	mov	r8,1
80009a4c:	ef 48 ff fc 	st.w	r7[-4],r8
		}
	}
	taskEXIT_CRITICAL();
80009a50:	f0 1f 00 08 	mcall	80009a70 <xTaskCheckForTimeOut+0xb4>

	return xReturn;
80009a54:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009a58:	10 9c       	mov	r12,r8
80009a5a:	2f dd       	sub	sp,-12
80009a5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80009a60:	80 00       	ld.sh	r0,r0[0x0]
80009a62:	85 20       	st.w	r2[0x8],r0
80009a64:	00 00       	add	r0,r0
80009a66:	0d 58       	ld.sh	r8,--r6
80009a68:	00 00       	add	r0,r0
80009a6a:	0d 3c       	ld.ub	r12,r6++
80009a6c:	80 00       	ld.sh	r0,r0[0x0]
80009a6e:	99 8c       	st.w	r12[0x20],r12
80009a70:	80 00       	ld.sh	r0,r0[0x0]
80009a72:	85 3c       	st.w	r2[0xc],r12

80009a74 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
80009a74:	eb cd 40 80 	pushm	r7,lr
80009a78:	1a 97       	mov	r7,sp
	xMissedYield = pdTRUE;
80009a7a:	48 38       	lddpc	r8,80009a84 <vTaskMissedYield+0x10>
80009a7c:	30 19       	mov	r9,1
80009a7e:	91 09       	st.w	r8[0x0],r9
}
80009a80:	e3 cd 80 80 	ldm	sp++,r7,pc
80009a84:	00 00       	add	r0,r0
80009a86:	0d 54       	ld.sh	r4,--r6

80009a88 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80009a88:	eb cd 40 80 	pushm	r7,lr
80009a8c:	1a 97       	mov	r7,sp
80009a8e:	20 1d       	sub	sp,4
80009a90:	ef 4c ff fc 	st.w	r7[-4],r12
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
80009a94:	f0 1f 00 06 	mcall	80009aac <prvIdleTask+0x24>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80009a98:	48 68       	lddpc	r8,80009ab0 <prvIdleTask+0x28>
80009a9a:	70 08       	ld.w	r8,r8[0x0]
80009a9c:	58 18       	cp.w	r8,1
80009a9e:	e0 88 00 03 	brls	80009aa4 <prvIdleTask+0x1c>
			{
				taskYIELD();
80009aa2:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80009aa4:	f0 1f 00 04 	mcall	80009ab4 <prvIdleTask+0x2c>
		}
		#endif
	}
80009aa8:	cf 6b       	rjmp	80009a94 <prvIdleTask+0xc>
80009aaa:	00 00       	add	r0,r0
80009aac:	80 00       	ld.sh	r0,r0[0x0]
80009aae:	9b f4       	st.w	sp[0x3c],r4
80009ab0:	00 00       	add	r0,r0
80009ab2:	0c 28       	rsub	r8,r6
80009ab4:	80 00       	ld.sh	r0,r0[0x0]
80009ab6:	34 e4       	mov	r4,78

80009ab8 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
80009ab8:	eb cd 40 80 	pushm	r7,lr
80009abc:	1a 97       	mov	r7,sp
80009abe:	20 5d       	sub	sp,20
80009ac0:	ef 4c ff fc 	st.w	r7[-4],r12
80009ac4:	ef 4b ff f8 	st.w	r7[-8],r11
80009ac8:	ef 4a ff f4 	st.w	r7[-12],r10
80009acc:	ef 49 ff f0 	st.w	r7[-16],r9
80009ad0:	ef 58 ff ec 	st.h	r7[-20],r8
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80009ad4:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009ad8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009adc:	2c c8       	sub	r8,-52
80009ade:	31 0a       	mov	r10,16
80009ae0:	12 9b       	mov	r11,r9
80009ae2:	10 9c       	mov	r12,r8
80009ae4:	f0 1f 00 1d 	mcall	80009b58 <prvInitialiseTCBVariables+0xa0>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80009ae8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009aec:	30 08       	mov	r8,0
80009aee:	f3 68 00 43 	st.b	r9[67],r8

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
80009af2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009af6:	58 78       	cp.w	r8,7
80009af8:	e0 88 00 05 	brls	80009b02 <prvInitialiseTCBVariables+0x4a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
80009afc:	30 78       	mov	r8,7
80009afe:	ef 48 ff f4 	st.w	r7[-12],r8
	}

	pxTCB->uxPriority = uxPriority;
80009b02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b06:	ee f9 ff f4 	ld.w	r9,r7[-12]
80009b0a:	91 b9       	st.w	r8[0x2c],r9
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80009b0c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b10:	ee f9 ff f4 	ld.w	r9,r7[-12]
80009b14:	f1 49 00 44 	st.w	r8[68],r9
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80009b18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b1c:	2f c8       	sub	r8,-4
80009b1e:	10 9c       	mov	r12,r8
80009b20:	f0 1f 00 0f 	mcall	80009b5c <prvInitialiseTCBVariables+0xa4>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80009b24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b28:	2e 88       	sub	r8,-24
80009b2a:	10 9c       	mov	r12,r8
80009b2c:	f0 1f 00 0c 	mcall	80009b5c <prvInitialiseTCBVariables+0xa4>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80009b30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b34:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009b38:	91 49       	st.w	r8[0x10],r9

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80009b3a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009b3e:	f0 09 11 08 	rsub	r9,r8,8
80009b42:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b46:	91 69       	st.w	r8[0x18],r9
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80009b48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b4c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009b50:	91 99       	st.w	r8[0x24],r9
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
80009b52:	2f bd       	sub	sp,-20
80009b54:	e3 cd 80 80 	ldm	sp++,r7,pc
80009b58:	80 00       	ld.sh	r0,r0[0x0]
80009b5a:	b4 fc       	st.b	r10[0x7],r12
80009b5c:	80 00       	ld.sh	r0,r0[0x0]
80009b5e:	82 34       	ld.sh	r4,r1[0x6]

80009b60 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
80009b60:	eb cd 40 80 	pushm	r7,lr
80009b64:	1a 97       	mov	r7,sp
80009b66:	20 1d       	sub	sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80009b68:	30 08       	mov	r8,0
80009b6a:	ef 48 ff fc 	st.w	r7[-4],r8
80009b6e:	c1 38       	rjmp	80009b94 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80009b70:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009b74:	12 98       	mov	r8,r9
80009b76:	a3 68       	lsl	r8,0x2
80009b78:	12 08       	add	r8,r9
80009b7a:	a3 68       	lsl	r8,0x2
80009b7c:	10 99       	mov	r9,r8
80009b7e:	49 58       	lddpc	r8,80009bd0 <prvInitialiseTaskLists+0x70>
80009b80:	f2 08 00 08 	add	r8,r9,r8
80009b84:	10 9c       	mov	r12,r8
80009b86:	f0 1f 00 14 	mcall	80009bd4 <prvInitialiseTaskLists+0x74>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80009b8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b8e:	2f f8       	sub	r8,-1
80009b90:	ef 48 ff fc 	st.w	r7[-4],r8
80009b94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009b98:	58 78       	cp.w	r8,7
80009b9a:	fe 98 ff eb 	brls	80009b70 <prvInitialiseTaskLists+0x10>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80009b9e:	48 fc       	lddpc	r12,80009bd8 <prvInitialiseTaskLists+0x78>
80009ba0:	f0 1f 00 0d 	mcall	80009bd4 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80009ba4:	48 ec       	lddpc	r12,80009bdc <prvInitialiseTaskLists+0x7c>
80009ba6:	f0 1f 00 0c 	mcall	80009bd4 <prvInitialiseTaskLists+0x74>
	vListInitialise( ( xList * ) &xPendingReadyList );
80009baa:	48 ec       	lddpc	r12,80009be0 <prvInitialiseTaskLists+0x80>
80009bac:	f0 1f 00 0a 	mcall	80009bd4 <prvInitialiseTaskLists+0x74>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80009bb0:	48 dc       	lddpc	r12,80009be4 <prvInitialiseTaskLists+0x84>
80009bb2:	f0 1f 00 09 	mcall	80009bd4 <prvInitialiseTaskLists+0x74>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80009bb6:	48 dc       	lddpc	r12,80009be8 <prvInitialiseTaskLists+0x88>
80009bb8:	f0 1f 00 07 	mcall	80009bd4 <prvInitialiseTaskLists+0x74>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80009bbc:	48 c8       	lddpc	r8,80009bec <prvInitialiseTaskLists+0x8c>
80009bbe:	48 79       	lddpc	r9,80009bd8 <prvInitialiseTaskLists+0x78>
80009bc0:	91 09       	st.w	r8[0x0],r9
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80009bc2:	48 c8       	lddpc	r8,80009bf0 <prvInitialiseTaskLists+0x90>
80009bc4:	48 69       	lddpc	r9,80009bdc <prvInitialiseTaskLists+0x7c>
80009bc6:	91 09       	st.w	r8[0x0],r9
}
80009bc8:	2f fd       	sub	sp,-4
80009bca:	e3 cd 80 80 	ldm	sp++,r7,pc
80009bce:	00 00       	add	r0,r0
80009bd0:	00 00       	add	r0,r0
80009bd2:	0c 28       	rsub	r8,r6
80009bd4:	80 00       	ld.sh	r0,r0[0x0]
80009bd6:	81 e8       	st.w	r0[0x38],r8
80009bd8:	00 00       	add	r0,r0
80009bda:	0c c8       	st.b	r6++,r8
80009bdc:	00 00       	add	r0,r0
80009bde:	0c dc       	st.w	--r6,r12
80009be0:	00 00       	add	r0,r0
80009be2:	0c f8       	st.b	--r6,r8
80009be4:	00 00       	add	r0,r0
80009be6:	0d 0c       	ld.w	r12,r6++
80009be8:	00 00       	add	r0,r0
80009bea:	0d 24       	ld.uh	r4,r6++
80009bec:	00 00       	add	r0,r0
80009bee:	0c f0       	st.b	--r6,r0
80009bf0:	00 00       	add	r0,r0
80009bf2:	0c f4       	st.b	--r6,r4

80009bf4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
80009bf4:	eb cd 40 80 	pushm	r7,lr
80009bf8:	1a 97       	mov	r7,sp
80009bfa:	20 2d       	sub	sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80009bfc:	49 b8       	lddpc	r8,80009c68 <prvCheckTasksWaitingTermination+0x74>
80009bfe:	70 08       	ld.w	r8,r8[0x0]
80009c00:	58 08       	cp.w	r8,0
80009c02:	c2 f0       	breq	80009c60 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
80009c04:	f0 1f 00 1a 	mcall	80009c6c <prvCheckTasksWaitingTermination+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80009c08:	49 a8       	lddpc	r8,80009c70 <prvCheckTasksWaitingTermination+0x7c>
80009c0a:	70 08       	ld.w	r8,r8[0x0]
80009c0c:	58 08       	cp.w	r8,0
80009c0e:	5f 08       	sreq	r8
80009c10:	ef 48 ff f8 	st.w	r7[-8],r8
			xTaskResumeAll();
80009c14:	f0 1f 00 18 	mcall	80009c74 <prvCheckTasksWaitingTermination+0x80>

			if( xListIsEmpty == pdFALSE )
80009c18:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009c1c:	58 08       	cp.w	r8,0
80009c1e:	c2 11       	brne	80009c60 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80009c20:	f0 1f 00 16 	mcall	80009c78 <prvCheckTasksWaitingTermination+0x84>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80009c24:	49 38       	lddpc	r8,80009c70 <prvCheckTasksWaitingTermination+0x7c>
80009c26:	2f 88       	sub	r8,-8
80009c28:	70 18       	ld.w	r8,r8[0x4]
80009c2a:	70 38       	ld.w	r8,r8[0xc]
80009c2c:	ef 48 ff fc 	st.w	r7[-4],r8
					vListRemove( &( pxTCB->xGenericListItem ) );
80009c30:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009c34:	2f c8       	sub	r8,-4
80009c36:	10 9c       	mov	r12,r8
80009c38:	f0 1f 00 11 	mcall	80009c7c <prvCheckTasksWaitingTermination+0x88>
					--uxCurrentNumberOfTasks;
80009c3c:	49 18       	lddpc	r8,80009c80 <prvCheckTasksWaitingTermination+0x8c>
80009c3e:	70 08       	ld.w	r8,r8[0x0]
80009c40:	f0 c9 00 01 	sub	r9,r8,1
80009c44:	48 f8       	lddpc	r8,80009c80 <prvCheckTasksWaitingTermination+0x8c>
80009c46:	91 09       	st.w	r8[0x0],r9
					--uxTasksDeleted;
80009c48:	48 88       	lddpc	r8,80009c68 <prvCheckTasksWaitingTermination+0x74>
80009c4a:	70 08       	ld.w	r8,r8[0x0]
80009c4c:	f0 c9 00 01 	sub	r9,r8,1
80009c50:	48 68       	lddpc	r8,80009c68 <prvCheckTasksWaitingTermination+0x74>
80009c52:	91 09       	st.w	r8[0x0],r9
				}
				taskEXIT_CRITICAL();
80009c54:	f0 1f 00 0c 	mcall	80009c84 <prvCheckTasksWaitingTermination+0x90>

				prvDeleteTCB( pxTCB );
80009c58:	ee fc ff fc 	ld.w	r12,r7[-4]
80009c5c:	f0 1f 00 0b 	mcall	80009c88 <prvCheckTasksWaitingTermination+0x94>
			}
		}
	}
	#endif
}
80009c60:	2f ed       	sub	sp,-8
80009c62:	e3 cd 80 80 	ldm	sp++,r7,pc
80009c66:	00 00       	add	r0,r0
80009c68:	00 00       	add	r0,r0
80009c6a:	0d 20       	ld.uh	r0,r6++
80009c6c:	80 00       	ld.sh	r0,r0[0x0]
80009c6e:	94 b8       	ld.uh	r8,r10[0x6]
80009c70:	00 00       	add	r0,r0
80009c72:	0d 0c       	ld.w	r12,r6++
80009c74:	80 00       	ld.sh	r0,r0[0x0]
80009c76:	94 d4       	ld.uh	r4,r10[0xa]
80009c78:	80 00       	ld.sh	r0,r0[0x0]
80009c7a:	85 20       	st.w	r2[0x8],r0
80009c7c:	80 00       	ld.sh	r0,r0[0x0]
80009c7e:	83 62       	st.w	r1[0x18],r2
80009c80:	00 00       	add	r0,r0
80009c82:	0d 38       	ld.ub	r8,r6++
80009c84:	80 00       	ld.sh	r0,r0[0x0]
80009c86:	85 3c       	st.w	r2[0xc],r12
80009c88:	80 00       	ld.sh	r0,r0[0x0]
80009c8a:	9d a0       	st.w	lr[0x28],r0

80009c8c <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80009c8c:	eb cd 40 80 	pushm	r7,lr
80009c90:	1a 97       	mov	r7,sp
80009c92:	20 1d       	sub	sp,4
80009c94:	ef 4c ff fc 	st.w	r7[-4],r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80009c98:	49 78       	lddpc	r8,80009cf4 <prvAddCurrentTaskToDelayedList+0x68>
80009c9a:	70 08       	ld.w	r8,r8[0x0]
80009c9c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009ca0:	91 19       	st.w	r8[0x4],r9

	if( xTimeToWake < xTickCount )
80009ca2:	49 68       	lddpc	r8,80009cf8 <prvAddCurrentTaskToDelayedList+0x6c>
80009ca4:	70 08       	ld.w	r8,r8[0x0]
80009ca6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009caa:	10 39       	cp.w	r9,r8
80009cac:	c0 c2       	brcc	80009cc4 <prvAddCurrentTaskToDelayedList+0x38>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009cae:	49 28       	lddpc	r8,80009cf4 <prvAddCurrentTaskToDelayedList+0x68>
80009cb0:	70 08       	ld.w	r8,r8[0x0]
80009cb2:	f0 c9 ff fc 	sub	r9,r8,-4
80009cb6:	49 28       	lddpc	r8,80009cfc <prvAddCurrentTaskToDelayedList+0x70>
80009cb8:	70 08       	ld.w	r8,r8[0x0]
80009cba:	12 9b       	mov	r11,r9
80009cbc:	10 9c       	mov	r12,r8
80009cbe:	f0 1f 00 11 	mcall	80009d00 <prvAddCurrentTaskToDelayedList+0x74>
80009cc2:	c1 58       	rjmp	80009cec <prvAddCurrentTaskToDelayedList+0x60>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80009cc4:	48 c8       	lddpc	r8,80009cf4 <prvAddCurrentTaskToDelayedList+0x68>
80009cc6:	70 08       	ld.w	r8,r8[0x0]
80009cc8:	f0 c9 ff fc 	sub	r9,r8,-4
80009ccc:	48 e8       	lddpc	r8,80009d04 <prvAddCurrentTaskToDelayedList+0x78>
80009cce:	70 08       	ld.w	r8,r8[0x0]
80009cd0:	12 9b       	mov	r11,r9
80009cd2:	10 9c       	mov	r12,r8
80009cd4:	f0 1f 00 0b 	mcall	80009d00 <prvAddCurrentTaskToDelayedList+0x74>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80009cd8:	48 c8       	lddpc	r8,80009d08 <prvAddCurrentTaskToDelayedList+0x7c>
80009cda:	70 08       	ld.w	r8,r8[0x0]
80009cdc:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009ce0:	10 39       	cp.w	r9,r8
80009ce2:	c0 52       	brcc	80009cec <prvAddCurrentTaskToDelayedList+0x60>
		{
			xNextTaskUnblockTime = xTimeToWake;
80009ce4:	48 98       	lddpc	r8,80009d08 <prvAddCurrentTaskToDelayedList+0x7c>
80009ce6:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009cea:	91 09       	st.w	r8[0x0],r9
		}
	}
}
80009cec:	2f fd       	sub	sp,-4
80009cee:	e3 cd 80 80 	ldm	sp++,r7,pc
80009cf2:	00 00       	add	r0,r0
80009cf4:	00 00       	add	r0,r0
80009cf6:	0c 24       	rsub	r4,r6
80009cf8:	00 00       	add	r0,r0
80009cfa:	0d 3c       	ld.ub	r12,r6++
80009cfc:	00 00       	add	r0,r0
80009cfe:	0c f4       	st.b	--r6,r4
80009d00:	80 00       	ld.sh	r0,r0[0x0]
80009d02:	82 c0       	ld.uh	r0,r1[0x8]
80009d04:	00 00       	add	r0,r0
80009d06:	0c f0       	st.b	--r6,r0
80009d08:	00 00       	add	r0,r0
80009d0a:	05 4c       	ld.w	r12,--r2

80009d0c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
80009d0c:	eb cd 40 80 	pushm	r7,lr
80009d10:	1a 97       	mov	r7,sp
80009d12:	20 3d       	sub	sp,12
80009d14:	18 98       	mov	r8,r12
80009d16:	ef 4b ff f4 	st.w	r7[-12],r11
80009d1a:	ef 58 ff f8 	st.h	r7[-8],r8
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80009d1e:	34 8c       	mov	r12,72
80009d20:	f0 1f 00 1d 	mcall	80009d94 <prvAllocateTCBAndStack+0x88>
80009d24:	18 98       	mov	r8,r12
80009d26:	ef 48 ff fc 	st.w	r7[-4],r8

	if( pxNewTCB != NULL )
80009d2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009d2e:	58 08       	cp.w	r8,0
80009d30:	c2 c0       	breq	80009d88 <prvAllocateTCBAndStack+0x7c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80009d32:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009d36:	58 08       	cp.w	r8,0
80009d38:	c0 91       	brne	80009d4a <prvAllocateTCBAndStack+0x3e>
80009d3a:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80009d3e:	a3 68       	lsl	r8,0x2
80009d40:	10 9c       	mov	r12,r8
80009d42:	f0 1f 00 15 	mcall	80009d94 <prvAllocateTCBAndStack+0x88>
80009d46:	18 98       	mov	r8,r12
80009d48:	c0 38       	rjmp	80009d4e <prvAllocateTCBAndStack+0x42>
80009d4a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80009d4e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80009d52:	93 c8       	st.w	r9[0x30],r8

		if( pxNewTCB->pxStack == NULL )
80009d54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009d58:	70 c8       	ld.w	r8,r8[0x30]
80009d5a:	58 08       	cp.w	r8,0
80009d5c:	c0 91       	brne	80009d6e <prvAllocateTCBAndStack+0x62>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80009d5e:	ee fc ff fc 	ld.w	r12,r7[-4]
80009d62:	f0 1f 00 0e 	mcall	80009d98 <prvAllocateTCBAndStack+0x8c>
			pxNewTCB = NULL;
80009d66:	30 08       	mov	r8,0
80009d68:	ef 48 ff fc 	st.w	r7[-4],r8
80009d6c:	c0 e8       	rjmp	80009d88 <prvAllocateTCBAndStack+0x7c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80009d6e:	ef 18 ff f8 	ld.uh	r8,r7[-8]
80009d72:	f0 09 15 02 	lsl	r9,r8,0x2
80009d76:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009d7a:	70 c8       	ld.w	r8,r8[0x30]
80009d7c:	12 9a       	mov	r10,r9
80009d7e:	e0 6b 00 a5 	mov	r11,165
80009d82:	10 9c       	mov	r12,r8
80009d84:	f0 1f 00 06 	mcall	80009d9c <prvAllocateTCBAndStack+0x90>
		}
	}

	return pxNewTCB;
80009d88:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80009d8c:	10 9c       	mov	r12,r8
80009d8e:	2f dd       	sub	sp,-12
80009d90:	e3 cd 80 80 	ldm	sp++,r7,pc
80009d94:	80 00       	ld.sh	r0,r0[0x0]
80009d96:	88 c8       	ld.uh	r8,r4[0x8]
80009d98:	80 00       	ld.sh	r0,r0[0x0]
80009d9a:	89 04       	st.w	r4[0x0],r4
80009d9c:	80 00       	ld.sh	r0,r0[0x0]
80009d9e:	b1 ba       	sbr	r10,0x11

80009da0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
80009da0:	eb cd 40 80 	pushm	r7,lr
80009da4:	1a 97       	mov	r7,sp
80009da6:	20 1d       	sub	sp,4
80009da8:	ef 4c ff fc 	st.w	r7[-4],r12
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80009dac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009db0:	70 c8       	ld.w	r8,r8[0x30]
80009db2:	10 9c       	mov	r12,r8
80009db4:	f0 1f 00 05 	mcall	80009dc8 <prvDeleteTCB+0x28>
		vPortFree( pxTCB );
80009db8:	ee fc ff fc 	ld.w	r12,r7[-4]
80009dbc:	f0 1f 00 03 	mcall	80009dc8 <prvDeleteTCB+0x28>
	}
80009dc0:	2f fd       	sub	sp,-4
80009dc2:	e3 cd 80 80 	ldm	sp++,r7,pc
80009dc6:	00 00       	add	r0,r0
80009dc8:	80 00       	ld.sh	r0,r0[0x0]
80009dca:	89 04       	st.w	r4[0x0],r4

80009dcc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
80009dcc:	eb cd 40 80 	pushm	r7,lr
80009dd0:	1a 97       	mov	r7,sp
80009dd2:	20 1d       	sub	sp,4
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80009dd4:	48 58       	lddpc	r8,80009de8 <xTaskGetCurrentTaskHandle+0x1c>
80009dd6:	70 08       	ld.w	r8,r8[0x0]
80009dd8:	ef 48 ff fc 	st.w	r7[-4],r8

		return xReturn;
80009ddc:	ee f8 ff fc 	ld.w	r8,r7[-4]
	}
80009de0:	10 9c       	mov	r12,r8
80009de2:	2f fd       	sub	sp,-4
80009de4:	e3 cd 80 80 	ldm	sp++,r7,pc
80009de8:	00 00       	add	r0,r0
80009dea:	0c 24       	rsub	r4,r6

80009dec <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80009dec:	eb cd 40 80 	pushm	r7,lr
80009df0:	1a 97       	mov	r7,sp
80009df2:	20 2d       	sub	sp,8
80009df4:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80009df8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009dfc:	ef 48 ff fc 	st.w	r7[-4],r8

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80009e00:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e04:	70 b9       	ld.w	r9,r8[0x2c]
80009e06:	4a a8       	lddpc	r8,80009eac <vTaskPriorityInherit+0xc0>
80009e08:	70 08       	ld.w	r8,r8[0x0]
80009e0a:	70 b8       	ld.w	r8,r8[0x2c]
80009e0c:	10 39       	cp.w	r9,r8
80009e0e:	c4 c2       	brcc	80009ea6 <vTaskPriorityInherit+0xba>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80009e10:	4a 78       	lddpc	r8,80009eac <vTaskPriorityInherit+0xc0>
80009e12:	70 08       	ld.w	r8,r8[0x0]
80009e14:	70 b8       	ld.w	r8,r8[0x2c]
80009e16:	f0 09 11 08 	rsub	r9,r8,8
80009e1a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e1e:	91 69       	st.w	r8[0x18],r9

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80009e20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e24:	70 5a       	ld.w	r10,r8[0x14]
80009e26:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e2a:	70 b9       	ld.w	r9,r8[0x2c]
80009e2c:	12 98       	mov	r8,r9
80009e2e:	a3 68       	lsl	r8,0x2
80009e30:	12 08       	add	r8,r9
80009e32:	a3 68       	lsl	r8,0x2
80009e34:	10 99       	mov	r9,r8
80009e36:	49 f8       	lddpc	r8,80009eb0 <vTaskPriorityInherit+0xc4>
80009e38:	f2 08 00 08 	add	r8,r9,r8
80009e3c:	10 3a       	cp.w	r10,r8
80009e3e:	c2 e1       	brne	80009e9a <vTaskPriorityInherit+0xae>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80009e40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e44:	2f c8       	sub	r8,-4
80009e46:	10 9c       	mov	r12,r8
80009e48:	f0 1f 00 1b 	mcall	80009eb4 <vTaskPriorityInherit+0xc8>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80009e4c:	49 88       	lddpc	r8,80009eac <vTaskPriorityInherit+0xc0>
80009e4e:	70 08       	ld.w	r8,r8[0x0]
80009e50:	70 b9       	ld.w	r9,r8[0x2c]
80009e52:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e56:	91 b9       	st.w	r8[0x2c],r9
				prvAddTaskToReadyQueue( pxTCB );
80009e58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e5c:	70 b9       	ld.w	r9,r8[0x2c]
80009e5e:	49 78       	lddpc	r8,80009eb8 <vTaskPriorityInherit+0xcc>
80009e60:	70 08       	ld.w	r8,r8[0x0]
80009e62:	10 39       	cp.w	r9,r8
80009e64:	e0 88 00 07 	brls	80009e72 <vTaskPriorityInherit+0x86>
80009e68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e6c:	70 b9       	ld.w	r9,r8[0x2c]
80009e6e:	49 38       	lddpc	r8,80009eb8 <vTaskPriorityInherit+0xcc>
80009e70:	91 09       	st.w	r8[0x0],r9
80009e72:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e76:	f0 ca ff fc 	sub	r10,r8,-4
80009e7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009e7e:	70 b9       	ld.w	r9,r8[0x2c]
80009e80:	12 98       	mov	r8,r9
80009e82:	a3 68       	lsl	r8,0x2
80009e84:	12 08       	add	r8,r9
80009e86:	a3 68       	lsl	r8,0x2
80009e88:	10 99       	mov	r9,r8
80009e8a:	48 a8       	lddpc	r8,80009eb0 <vTaskPriorityInherit+0xc4>
80009e8c:	f2 08 00 08 	add	r8,r9,r8
80009e90:	14 9b       	mov	r11,r10
80009e92:	10 9c       	mov	r12,r8
80009e94:	f0 1f 00 0a 	mcall	80009ebc <vTaskPriorityInherit+0xd0>
80009e98:	c0 78       	rjmp	80009ea6 <vTaskPriorityInherit+0xba>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80009e9a:	48 58       	lddpc	r8,80009eac <vTaskPriorityInherit+0xc0>
80009e9c:	70 08       	ld.w	r8,r8[0x0]
80009e9e:	70 b9       	ld.w	r9,r8[0x2c]
80009ea0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009ea4:	91 b9       	st.w	r8[0x2c],r9
			}
		}
	}
80009ea6:	2f ed       	sub	sp,-8
80009ea8:	e3 cd 80 80 	ldm	sp++,r7,pc
80009eac:	00 00       	add	r0,r0
80009eae:	0c 24       	rsub	r4,r6
80009eb0:	00 00       	add	r0,r0
80009eb2:	0c 28       	rsub	r8,r6
80009eb4:	80 00       	ld.sh	r0,r0[0x0]
80009eb6:	83 62       	st.w	r1[0x18],r2
80009eb8:	00 00       	add	r0,r0
80009eba:	0d 44       	ld.w	r4,--r6
80009ebc:	80 00       	ld.sh	r0,r0[0x0]
80009ebe:	82 4e       	ld.sh	lr,r1[0x8]

80009ec0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80009ec0:	eb cd 40 80 	pushm	r7,lr
80009ec4:	1a 97       	mov	r7,sp
80009ec6:	20 2d       	sub	sp,8
80009ec8:	ef 4c ff f8 	st.w	r7[-8],r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80009ecc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009ed0:	ef 48 ff fc 	st.w	r7[-4],r8

		if( pxMutexHolder != NULL )
80009ed4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009ed8:	58 08       	cp.w	r8,0
80009eda:	c3 d0       	breq	80009f54 <vTaskPriorityDisinherit+0x94>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80009edc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009ee0:	70 b9       	ld.w	r9,r8[0x2c]
80009ee2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009ee6:	71 18       	ld.w	r8,r8[0x44]
80009ee8:	10 39       	cp.w	r9,r8
80009eea:	c3 50       	breq	80009f54 <vTaskPriorityDisinherit+0x94>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80009eec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009ef0:	2f c8       	sub	r8,-4
80009ef2:	10 9c       	mov	r12,r8
80009ef4:	f0 1f 00 1a 	mcall	80009f5c <vTaskPriorityDisinherit+0x9c>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80009ef8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009efc:	71 19       	ld.w	r9,r8[0x44]
80009efe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009f02:	91 b9       	st.w	r8[0x2c],r9
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80009f04:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009f08:	70 b8       	ld.w	r8,r8[0x2c]
80009f0a:	f0 09 11 08 	rsub	r9,r8,8
80009f0e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009f12:	91 69       	st.w	r8[0x18],r9
				prvAddTaskToReadyQueue( pxTCB );
80009f14:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009f18:	70 b9       	ld.w	r9,r8[0x2c]
80009f1a:	49 28       	lddpc	r8,80009f60 <vTaskPriorityDisinherit+0xa0>
80009f1c:	70 08       	ld.w	r8,r8[0x0]
80009f1e:	10 39       	cp.w	r9,r8
80009f20:	e0 88 00 07 	brls	80009f2e <vTaskPriorityDisinherit+0x6e>
80009f24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009f28:	70 b9       	ld.w	r9,r8[0x2c]
80009f2a:	48 e8       	lddpc	r8,80009f60 <vTaskPriorityDisinherit+0xa0>
80009f2c:	91 09       	st.w	r8[0x0],r9
80009f2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009f32:	f0 ca ff fc 	sub	r10,r8,-4
80009f36:	ee f8 ff fc 	ld.w	r8,r7[-4]
80009f3a:	70 b9       	ld.w	r9,r8[0x2c]
80009f3c:	12 98       	mov	r8,r9
80009f3e:	a3 68       	lsl	r8,0x2
80009f40:	12 08       	add	r8,r9
80009f42:	a3 68       	lsl	r8,0x2
80009f44:	10 99       	mov	r9,r8
80009f46:	48 88       	lddpc	r8,80009f64 <vTaskPriorityDisinherit+0xa4>
80009f48:	f2 08 00 08 	add	r8,r9,r8
80009f4c:	14 9b       	mov	r11,r10
80009f4e:	10 9c       	mov	r12,r8
80009f50:	f0 1f 00 06 	mcall	80009f68 <vTaskPriorityDisinherit+0xa8>
			}
		}
	}
80009f54:	2f ed       	sub	sp,-8
80009f56:	e3 cd 80 80 	ldm	sp++,r7,pc
80009f5a:	00 00       	add	r0,r0
80009f5c:	80 00       	ld.sh	r0,r0[0x0]
80009f5e:	83 62       	st.w	r1[0x18],r2
80009f60:	00 00       	add	r0,r0
80009f62:	0d 44       	ld.w	r4,--r6
80009f64:	00 00       	add	r0,r0
80009f66:	0c 28       	rsub	r8,r6
80009f68:	80 00       	ld.sh	r0,r0[0x0]
80009f6a:	82 4e       	ld.sh	lr,r1[0x8]
80009f6c:	4c 4f       	lddpc	pc,8000a07c <PrintDec+0xa0>
80009f6e:	47 00       	lddsp	r0,sp[0x1c0]
80009f70:	49 20       	lddpc	r0,80009fb8 <PrintChar+0x10>
80009f72:	6e 65       	ld.w	r5,r7[0x18]
80009f74:	65 64       	ld.w	r4,r2[0x58]
80009f76:	20 66       	sub	r6,6
80009f78:	6c 6f       	ld.w	pc,r6[0x18]
80009f7a:	61 74       	ld.w	r4,r0[0x5c]
80009f7c:	2e 00       	sub	r0,-32
80009f7e:	00 00       	add	r0,r0
80009f80:	49 20       	lddpc	r0,80009fc8 <PrintChar+0x20>
80009f82:	6e 65       	ld.w	r5,r7[0x18]
80009f84:	65 64       	ld.w	r4,r2[0x58]
80009f86:	20 72       	sub	r2,7
80009f88:	65 6c       	ld.w	r12,r2[0x58]
80009f8a:	61 78       	ld.w	r8,r0[0x5c]
80009f8c:	2e 00       	sub	r0,-32
80009f8e:	00 00       	add	r0,r0
80009f90:	25 73       	sub	r3,87
80009f92:	25 73       	sub	r3,87
80009f94:	00 00       	add	r0,r0
80009f96:	00 00       	add	r0,r0
80009f98:	25 73       	sub	r3,87
80009f9a:	25 63       	sub	r3,86
80009f9c:	00 00       	add	r0,r0
80009f9e:	00 00       	add	r0,r0
80009fa0:	25 73       	sub	r3,87
80009fa2:	0d 0a       	ld.w	r10,r6++
80009fa4:	00 00       	add	r0,r0
	...

80009fa8 <PrintChar>:

	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
80009fa8:	eb cd 40 80 	pushm	r7,lr
80009fac:	1a 97       	mov	r7,sp
80009fae:	20 2d       	sub	sp,8
80009fb0:	18 98       	mov	r8,r12
80009fb2:	ef 4b ff f8 	st.w	r7[-8],r11
80009fb6:	ef 68 ff fc 	st.b	r7[-4],r8
	*str++ = c;
80009fba:	ee f9 ff f8 	ld.w	r9,r7[-8]
80009fbe:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80009fc2:	b2 88       	st.b	r9[0x0],r8
80009fc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80009fc8:	2f f8       	sub	r8,-1
80009fca:	ef 48 ff f8 	st.w	r7[-8],r8
	return str;
80009fce:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80009fd2:	10 9c       	mov	r12,r8
80009fd4:	2f ed       	sub	sp,-8
80009fd6:	e3 cd 80 80 	ldm	sp++,r7,pc
80009fda:	d7 03       	nop

80009fdc <PrintDec>:

char * PrintDec(int i, char len, char * str)
{
80009fdc:	eb cd 40 80 	pushm	r7,lr
80009fe0:	1a 97       	mov	r7,sp
80009fe2:	20 cd       	sub	sp,48
80009fe4:	ef 4c ff d8 	st.w	r7[-40],r12
80009fe8:	16 98       	mov	r8,r11
80009fea:	ef 4a ff d0 	st.w	r7[-48],r10
80009fee:	ef 68 ff d4 	st.b	r7[-44],r8
	char * p = str;
80009ff2:	ee f8 ff d0 	ld.w	r8,r7[-48]
80009ff6:	ef 48 ff e8 	st.w	r7[-24],r8
	
	int sign = i>=0 ? 0 : 1;
80009ffa:	ee f8 ff d8 	ld.w	r8,r7[-40]
80009ffe:	bf 98       	lsr	r8,0x1f
8000a000:	ef 48 ff ec 	st.w	r7[-20],r8
	char s[10];
	memset(s, 0 , 10);
8000a004:	ee c8 00 24 	sub	r8,r7,36
8000a008:	30 aa       	mov	r10,10
8000a00a:	30 0b       	mov	r11,0
8000a00c:	10 9c       	mov	r12,r8
8000a00e:	f0 1f 00 61 	mcall	8000a190 <PrintDec+0x1b4>
	int cnt=0;
8000a012:	30 08       	mov	r8,0
8000a014:	ef 48 ff f0 	st.w	r7[-16],r8
	if(sign)
8000a018:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000a01c:	58 08       	cp.w	r8,0
8000a01e:	c0 f0       	breq	8000a03c <PrintDec+0x60>
	{
		*p++ = '-';
8000a020:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000a024:	32 d8       	mov	r8,45
8000a026:	b2 88       	st.b	r9[0x0],r8
8000a028:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a02c:	2f f8       	sub	r8,-1
8000a02e:	ef 48 ff e8 	st.w	r7[-24],r8
		i = -i;
8000a032:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000a036:	5c 38       	neg	r8
8000a038:	ef 48 ff d8 	st.w	r7[-40],r8
	}
	
	if(i == 0 )s[cnt++] = '0';
8000a03c:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000a040:	58 08       	cp.w	r8,0
8000a042:	c0 d1       	brne	8000a05c <PrintDec+0x80>
8000a044:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a048:	ee 08 00 09 	add	r9,r7,r8
8000a04c:	33 08       	mov	r8,48
8000a04e:	f3 68 ff dc 	st.b	r9[-36],r8
8000a052:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a056:	2f f8       	sub	r8,-1
8000a058:	ef 48 ff f0 	st.w	r7[-16],r8
	
	int ten = i%10;
8000a05c:	ee f9 ff d8 	ld.w	r9,r7[-40]
8000a060:	e0 68 66 67 	mov	r8,26215
8000a064:	ea 18 66 66 	orh	r8,0x6666
8000a068:	f2 08 04 4a 	muls.d	r10,r9,r8
8000a06c:	f6 0a 14 02 	asr	r10,r11,0x2
8000a070:	f2 08 14 1f 	asr	r8,r9,0x1f
8000a074:	10 1a       	sub	r10,r8
8000a076:	14 98       	mov	r8,r10
8000a078:	a3 68       	lsl	r8,0x2
8000a07a:	14 08       	add	r8,r10
8000a07c:	a1 78       	lsl	r8,0x1
8000a07e:	f2 08 01 08 	sub	r8,r9,r8
8000a082:	ef 48 ff f4 	st.w	r7[-12],r8
	while(i)
8000a086:	c3 58       	rjmp	8000a0f0 <PrintDec+0x114>
	{
		s[cnt] = ten+'0';
8000a088:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000a08c:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a090:	5c 58       	castu.b	r8
8000a092:	2d 08       	sub	r8,-48
8000a094:	5c 58       	castu.b	r8
8000a096:	ee 09 00 09 	add	r9,r7,r9
8000a09a:	f3 68 ff dc 	st.b	r9[-36],r8
		cnt++;
8000a09e:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a0a2:	2f f8       	sub	r8,-1
8000a0a4:	ef 48 ff f0 	st.w	r7[-16],r8
		i /= 10;
8000a0a8:	ee fa ff d8 	ld.w	r10,r7[-40]
8000a0ac:	e0 68 66 67 	mov	r8,26215
8000a0b0:	ea 18 66 66 	orh	r8,0x6666
8000a0b4:	f4 08 04 48 	muls.d	r8,r10,r8
8000a0b8:	a3 49       	asr	r9,0x2
8000a0ba:	f4 08 14 1f 	asr	r8,r10,0x1f
8000a0be:	f2 08 01 08 	sub	r8,r9,r8
8000a0c2:	ef 48 ff d8 	st.w	r7[-40],r8
		ten = i%10;
8000a0c6:	ee f9 ff d8 	ld.w	r9,r7[-40]
8000a0ca:	e0 68 66 67 	mov	r8,26215
8000a0ce:	ea 18 66 66 	orh	r8,0x6666
8000a0d2:	f2 08 04 4a 	muls.d	r10,r9,r8
8000a0d6:	f6 0a 14 02 	asr	r10,r11,0x2
8000a0da:	f2 08 14 1f 	asr	r8,r9,0x1f
8000a0de:	10 1a       	sub	r10,r8
8000a0e0:	14 98       	mov	r8,r10
8000a0e2:	a3 68       	lsl	r8,0x2
8000a0e4:	14 08       	add	r8,r10
8000a0e6:	a1 78       	lsl	r8,0x1
8000a0e8:	f2 08 01 08 	sub	r8,r9,r8
8000a0ec:	ef 48 ff f4 	st.w	r7[-12],r8
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000a0f0:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000a0f4:	58 08       	cp.w	r8,0
8000a0f6:	cc 91       	brne	8000a088 <PrintDec+0xac>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
8000a0f8:	ef 39 ff d4 	ld.ub	r9,r7[-44]
8000a0fc:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a100:	f2 08 01 08 	sub	r8,r9,r8
8000a104:	58 08       	cp.w	r8,0
8000a106:	e0 8a 00 3a 	brle	8000a17a <PrintDec+0x19e>
	{
		char num = len - cnt;
8000a10a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a10e:	5c 58       	castu.b	r8
8000a110:	ef 39 ff d4 	ld.ub	r9,r7[-44]
8000a114:	10 19       	sub	r9,r8
8000a116:	ef 69 ff fb 	st.b	r7[-5],r9
		for(int i = 0; i < num; i++)
8000a11a:	30 08       	mov	r8,0
8000a11c:	ef 48 ff fc 	st.w	r7[-4],r8
8000a120:	c1 28       	rjmp	8000a144 <PrintDec+0x168>
		{
			s[cnt++] = '0';
8000a122:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a126:	ee 08 00 09 	add	r9,r7,r8
8000a12a:	33 08       	mov	r8,48
8000a12c:	f3 68 ff dc 	st.b	r9[-36],r8
8000a130:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a134:	2f f8       	sub	r8,-1
8000a136:	ef 48 ff f0 	st.w	r7[-16],r8
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000a13a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a13e:	2f f8       	sub	r8,-1
8000a140:	ef 48 ff fc 	st.w	r7[-4],r8
8000a144:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000a148:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a14c:	10 39       	cp.w	r9,r8
8000a14e:	fe 99 ff ea 	brgt	8000a122 <PrintDec+0x146>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000a152:	c1 48       	rjmp	8000a17a <PrintDec+0x19e>
	*p++ = s[--cnt];
8000a154:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a158:	20 18       	sub	r8,1
8000a15a:	ef 48 ff f0 	st.w	r7[-16],r8
8000a15e:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a162:	ee 08 00 08 	add	r8,r7,r8
8000a166:	f1 38 ff dc 	ld.ub	r8,r8[-36]
8000a16a:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000a16e:	b2 88       	st.b	r9[0x0],r8
8000a170:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a174:	2f f8       	sub	r8,-1
8000a176:	ef 48 ff e8 	st.w	r7[-24],r8
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000a17a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a17e:	58 08       	cp.w	r8,0
8000a180:	fe 99 ff ea 	brgt	8000a154 <PrintDec+0x178>
	*p++ = s[--cnt];
	
	return str;
8000a184:	ee f8 ff d0 	ld.w	r8,r7[-48]
}
8000a188:	10 9c       	mov	r12,r8
8000a18a:	2f 4d       	sub	sp,-48
8000a18c:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a190:	80 00       	ld.sh	r0,r0[0x0]
8000a192:	b1 ba       	sbr	r10,0x11

8000a194 <PrintHex>:

char * PrintHex(int i,char len, char * str)
{
8000a194:	eb cd 40 80 	pushm	r7,lr
8000a198:	1a 97       	mov	r7,sp
8000a19a:	20 ad       	sub	sp,40
8000a19c:	ef 4c ff e0 	st.w	r7[-32],r12
8000a1a0:	16 98       	mov	r8,r11
8000a1a2:	ef 4a ff d8 	st.w	r7[-40],r10
8000a1a6:	ef 68 ff dc 	st.b	r7[-36],r8
	char * p = str;
8000a1aa:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000a1ae:	ef 48 ff f0 	st.w	r7[-16],r8
	char s[12];
	memset(s, 0 , 12);
8000a1b2:	ee c8 00 1c 	sub	r8,r7,28
8000a1b6:	30 ca       	mov	r10,12
8000a1b8:	30 0b       	mov	r11,0
8000a1ba:	10 9c       	mov	r12,r8
8000a1bc:	f0 1f 00 53 	mcall	8000a308 <PrintHex+0x174>
	int cnt=0;
8000a1c0:	30 08       	mov	r8,0
8000a1c2:	ef 48 ff f4 	st.w	r7[-12],r8
	
	if(i)
8000a1c6:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a1ca:	58 08       	cp.w	r8,0
8000a1cc:	c2 d0       	breq	8000a226 <PrintHex+0x92>
	while(i)
8000a1ce:	c2 78       	rjmp	8000a21c <PrintHex+0x88>
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000a1d0:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000a1d4:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a1d8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a1dc:	58 98       	cp.w	r8,9
8000a1de:	e0 8a 00 0a 	brle	8000a1f2 <PrintHex+0x5e>
8000a1e2:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a1e6:	5c 58       	castu.b	r8
8000a1e8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a1ec:	2c 98       	sub	r8,-55
8000a1ee:	5c 58       	castu.b	r8
8000a1f0:	c0 88       	rjmp	8000a200 <PrintHex+0x6c>
8000a1f2:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a1f6:	5c 58       	castu.b	r8
8000a1f8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a1fc:	2d 08       	sub	r8,-48
8000a1fe:	5c 58       	castu.b	r8
8000a200:	ee 09 00 09 	add	r9,r7,r9
8000a204:	f3 68 ff e4 	st.b	r9[-28],r8
8000a208:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a20c:	2f f8       	sub	r8,-1
8000a20e:	ef 48 ff f4 	st.w	r7[-12],r8
		i = (i >> 4 ) & 0x0FFFFFFF;
8000a212:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a216:	a5 88       	lsr	r8,0x4
8000a218:	ef 48 ff e0 	st.w	r7[-32],r8
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000a21c:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000a220:	58 08       	cp.w	r8,0
8000a222:	cd 71       	brne	8000a1d0 <PrintHex+0x3c>
8000a224:	c0 d8       	rjmp	8000a23e <PrintHex+0xaa>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
8000a226:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a22a:	ee 08 00 09 	add	r9,r7,r8
8000a22e:	33 08       	mov	r8,48
8000a230:	f3 68 ff e4 	st.b	r9[-28],r8
8000a234:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a238:	2f f8       	sub	r8,-1
8000a23a:	ef 48 ff f4 	st.w	r7[-12],r8
	
	if(len - cnt > 0 )
8000a23e:	ef 39 ff dc 	ld.ub	r9,r7[-36]
8000a242:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a246:	f2 08 01 08 	sub	r8,r9,r8
8000a24a:	58 08       	cp.w	r8,0
8000a24c:	e0 8a 00 26 	brle	8000a298 <PrintHex+0x104>
	{
		char num = len - cnt;
8000a250:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a254:	5c 58       	castu.b	r8
8000a256:	ef 39 ff dc 	ld.ub	r9,r7[-36]
8000a25a:	10 19       	sub	r9,r8
8000a25c:	ef 69 ff fb 	st.b	r7[-5],r9
		for(int i = 0; i < num; i++)
8000a260:	30 08       	mov	r8,0
8000a262:	ef 48 ff fc 	st.w	r7[-4],r8
8000a266:	c1 28       	rjmp	8000a28a <PrintHex+0xf6>
		{
			s[cnt++] = '0';
8000a268:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a26c:	ee 08 00 09 	add	r9,r7,r8
8000a270:	33 08       	mov	r8,48
8000a272:	f3 68 ff e4 	st.b	r9[-28],r8
8000a276:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a27a:	2f f8       	sub	r8,-1
8000a27c:	ef 48 ff f4 	st.w	r7[-12],r8
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
8000a280:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a284:	2f f8       	sub	r8,-1
8000a286:	ef 48 ff fc 	st.w	r7[-4],r8
8000a28a:	ef 39 ff fb 	ld.ub	r9,r7[-5]
8000a28e:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a292:	10 39       	cp.w	r9,r8
8000a294:	fe 99 ff ea 	brgt	8000a268 <PrintHex+0xd4>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
8000a298:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a29c:	ee 08 00 09 	add	r9,r7,r8
8000a2a0:	37 88       	mov	r8,120
8000a2a2:	f3 68 ff e4 	st.b	r9[-28],r8
8000a2a6:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a2aa:	2f f8       	sub	r8,-1
8000a2ac:	ef 48 ff f4 	st.w	r7[-12],r8
	s[cnt++] = '0';
8000a2b0:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a2b4:	ee 08 00 09 	add	r9,r7,r8
8000a2b8:	33 08       	mov	r8,48
8000a2ba:	f3 68 ff e4 	st.b	r9[-28],r8
8000a2be:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a2c2:	2f f8       	sub	r8,-1
8000a2c4:	ef 48 ff f4 	st.w	r7[-12],r8
	
	while(cnt>0)
8000a2c8:	c1 48       	rjmp	8000a2f0 <PrintHex+0x15c>
	*p++ = s[--cnt];
8000a2ca:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a2ce:	20 18       	sub	r8,1
8000a2d0:	ef 48 ff f4 	st.w	r7[-12],r8
8000a2d4:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a2d8:	ee 08 00 08 	add	r8,r7,r8
8000a2dc:	f1 38 ff e4 	ld.ub	r8,r8[-28]
8000a2e0:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000a2e4:	b2 88       	st.b	r9[0x0],r8
8000a2e6:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a2ea:	2f f8       	sub	r8,-1
8000a2ec:	ef 48 ff f0 	st.w	r7[-16],r8
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000a2f0:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a2f4:	58 08       	cp.w	r8,0
8000a2f6:	fe 99 ff ea 	brgt	8000a2ca <PrintHex+0x136>
	*p++ = s[--cnt];
		
	return str;
8000a2fa:	ee f8 ff d8 	ld.w	r8,r7[-40]
}
8000a2fe:	10 9c       	mov	r12,r8
8000a300:	2f 6d       	sub	sp,-40
8000a302:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a306:	00 00       	add	r0,r0
8000a308:	80 00       	ld.sh	r0,r0[0x0]
8000a30a:	b1 ba       	sbr	r10,0x11

8000a30c <log_init>:

void log_init(void)
{
8000a30c:	eb cd 40 80 	pushm	r7,lr
8000a310:	1a 97       	mov	r7,sp
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000a312:	30 2b       	mov	r11,2
8000a314:	49 2c       	lddpc	r12,8000a35c <log_init+0x50>
8000a316:	f0 1f 00 13 	mcall	8000a360 <log_init+0x54>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);		
8000a31a:	e0 6a 36 00 	mov	r10,13824
8000a31e:	ea 1a 01 6e 	orh	r10,0x16e
8000a322:	49 1b       	lddpc	r11,8000a364 <log_init+0x58>
8000a324:	fe 7c 18 00 	mov	r12,-59392
8000a328:	f0 1f 00 10 	mcall	8000a368 <log_init+0x5c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
8000a32c:	30 4b       	mov	r11,4
8000a32e:	33 2c       	mov	r12,50
8000a330:	f0 1f 00 0f 	mcall	8000a36c <log_init+0x60>
8000a334:	18 99       	mov	r9,r12
8000a336:	48 f8       	lddpc	r8,8000a370 <log_init+0x64>
8000a338:	91 09       	st.w	r8[0x0],r9
	
	xTaskCreate(
8000a33a:	48 fb       	lddpc	r11,8000a374 <log_init+0x68>
8000a33c:	30 08       	mov	r8,0
8000a33e:	1a d8       	st.w	--sp,r8
8000a340:	30 08       	mov	r8,0
8000a342:	1a d8       	st.w	--sp,r8
8000a344:	30 08       	mov	r8,0
8000a346:	1a d8       	st.w	--sp,r8
8000a348:	30 28       	mov	r8,2
8000a34a:	30 09       	mov	r9,0
8000a34c:	e0 6a 01 80 	mov	r10,384
8000a350:	48 ac       	lddpc	r12,8000a378 <log_init+0x6c>
8000a352:	f0 1f 00 0b 	mcall	8000a37c <log_init+0x70>
8000a356:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000a358:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a35c:	80 01       	ld.sh	r1,r0[0x0]
8000a35e:	0b f8       	ld.ub	r8,r5[0x7]
8000a360:	80 00       	ld.sh	r0,r0[0x0]
8000a362:	a9 7c       	lsl	r12,0x9
8000a364:	80 01       	ld.sh	r1,r0[0x0]
8000a366:	0c 08       	add	r8,r6
8000a368:	80 00       	ld.sh	r0,r0[0x0]
8000a36a:	7f 08       	ld.w	r8,pc[0x40]
8000a36c:	80 00       	ld.sh	r0,r0[0x0]
8000a36e:	89 3c       	st.w	r4[0xc],r12
8000a370:	00 00       	add	r0,r0
8000a372:	53 1c       	stdsp	sp[0xc4],r12
8000a374:	80 00       	ld.sh	r0,r0[0x0]
8000a376:	9f 6c       	st.w	pc[0x18],r12
8000a378:	80 00       	ld.sh	r0,r0[0x0]
8000a37a:	a8 5c       	st.h	r4[0xa],r12
8000a37c:	80 00       	ld.sh	r0,r0[0x0]
8000a37e:	91 ac       	st.w	r8[0x28],r12

8000a380 <log>:

int log(char * content, ...)
{
8000a380:	eb cd 40 c0 	pushm	r6-r7,lr
8000a384:	1a 97       	mov	r7,sp
8000a386:	fa cd 02 28 	sub	sp,sp,552
8000a38a:	ee c6 ff f4 	sub	r6,r7,-12
8000a38e:	ef 4c fd d8 	st.w	r7[-552],r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
8000a392:	ee c8 01 1c 	sub	r8,r7,284
8000a396:	e0 6a 01 00 	mov	r10,256
8000a39a:	30 0b       	mov	r11,0
8000a39c:	10 9c       	mov	r12,r8
8000a39e:	f0 1f 00 84 	mcall	8000a5ac <log+0x22c>
	
	int len = 0 ;
8000a3a2:	30 08       	mov	r8,0
8000a3a4:	ef 48 ff e4 	st.w	r7[-28],r8
	

	va_list arg_ptr;
	char* str = content;
8000a3a8:	ee f8 fd d8 	ld.w	r8,r7[-552]
8000a3ac:	ef 48 ff e8 	st.w	r7[-24],r8
	int x;
	char y;
	float f;
	//char* s;
	char length= 0;
8000a3b0:	30 08       	mov	r8,0
8000a3b2:	ef 68 ff fb 	st.b	r7[-5],r8
		
	va_start(arg_ptr, content);
8000a3b6:	ec c8 00 00 	sub	r8,r6,0
8000a3ba:	ef 48 fe e0 	st.w	r7[-288],r8
		//str += 4;
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
8000a3be:	ee c8 02 24 	sub	r8,r7,548
8000a3c2:	ef 48 ff fc 	st.w	r7[-4],r8
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a3c6:	e0 6a 01 00 	mov	r10,256
8000a3ca:	30 0b       	mov	r11,0
8000a3cc:	ee fc ff fc 	ld.w	r12,r7[-4]
8000a3d0:	f0 1f 00 77 	mcall	8000a5ac <log+0x22c>
			
					if(*str == '%')
8000a3d4:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a3d8:	11 89       	ld.ub	r9,r8[0x0]
8000a3da:	32 58       	mov	r8,37
8000a3dc:	f0 09 18 00 	cp.b	r9,r8
8000a3e0:	e0 81 00 9a 	brne	8000a514 <log+0x194>
					{
						static char lench = 0;
						lench =*(str + 1);
8000a3e4:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a3e8:	2f f8       	sub	r8,-1
8000a3ea:	11 88       	ld.ub	r8,r8[0x0]
8000a3ec:	4f 19       	lddpc	r9,8000a5b0 <log+0x230>
8000a3ee:	b2 88       	st.b	r9[0x0],r8
						if((lench >= '0') &&  (lench <= '9'))
8000a3f0:	4f 08       	lddpc	r8,8000a5b0 <log+0x230>
8000a3f2:	11 89       	ld.ub	r9,r8[0x0]
8000a3f4:	32 f8       	mov	r8,47
8000a3f6:	f0 09 18 00 	cp.b	r9,r8
8000a3fa:	e0 88 00 14 	brls	8000a422 <log+0xa2>
8000a3fe:	4e d8       	lddpc	r8,8000a5b0 <log+0x230>
8000a400:	11 89       	ld.ub	r9,r8[0x0]
8000a402:	33 98       	mov	r8,57
8000a404:	f0 09 18 00 	cp.b	r9,r8
8000a408:	e0 8b 00 0d 	brhi	8000a422 <log+0xa2>
						{
							len = *(++str) - '0';
8000a40c:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a410:	2f f8       	sub	r8,-1
8000a412:	ef 48 ff e8 	st.w	r7[-24],r8
8000a416:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a41a:	11 88       	ld.ub	r8,r8[0x0]
8000a41c:	23 08       	sub	r8,48
8000a41e:	ef 48 ff e4 	st.w	r7[-28],r8
						}
						
						str++;
8000a422:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a426:	2f f8       	sub	r8,-1
8000a428:	ef 48 ff e8 	st.w	r7[-24],r8
						
						switch(*(str))
8000a42c:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a430:	11 88       	ld.ub	r8,r8[0x0]
8000a432:	22 58       	sub	r8,37
8000a434:	e0 48 00 53 	cp.w	r8,83
8000a438:	e0 8b 00 55 	brhi	8000a4e2 <log+0x162>
8000a43c:	4d e9       	lddpc	r9,8000a5b4 <log+0x234>
8000a43e:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
8000a442:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a446:	f0 c9 ff fc 	sub	r9,r8,-4
8000a44a:	ef 49 fe e0 	st.w	r7[-288],r9
8000a44e:	70 08       	ld.w	r8,r8[0x0]
8000a450:	ef 48 ff ec 	st.w	r7[-20],r8
							strTmp = PrintDec(x, len, strTmp);
8000a454:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000a458:	5c 58       	castu.b	r8
8000a45a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000a45e:	10 9b       	mov	r11,r8
8000a460:	ee fc ff ec 	ld.w	r12,r7[-20]
8000a464:	f0 1f 00 55 	mcall	8000a5b8 <log+0x238>
8000a468:	18 98       	mov	r8,r12
8000a46a:	ef 48 ff fc 	st.w	r7[-4],r8
							break;
8000a46e:	c3 d8       	rjmp	8000a4e8 <log+0x168>
							
							case('f')://
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000a470:	4d 3c       	lddpc	r12,8000a5bc <log+0x23c>
8000a472:	f0 1f 00 54 	mcall	8000a5c0 <log+0x240>
							break;
8000a476:	c3 98       	rjmp	8000a4e8 <log+0x168>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
8000a478:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a47c:	f0 c9 ff fc 	sub	r9,r8,-4
8000a480:	ef 49 fe e0 	st.w	r7[-288],r9
8000a484:	70 08       	ld.w	r8,r8[0x0]
8000a486:	ef 48 ff ec 	st.w	r7[-20],r8
							PrintHex(x,len, strTmp);
8000a48a:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000a48e:	5c 58       	castu.b	r8
8000a490:	ee fa ff fc 	ld.w	r10,r7[-4]
8000a494:	10 9b       	mov	r11,r8
8000a496:	ee fc ff ec 	ld.w	r12,r7[-20]
8000a49a:	f0 1f 00 4b 	mcall	8000a5c4 <log+0x244>
							break;
8000a49e:	c2 58       	rjmp	8000a4e8 <log+0x168>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000a4a0:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a4a4:	f0 c9 ff fc 	sub	r9,r8,-4
8000a4a8:	ef 49 fe e0 	st.w	r7[-288],r9
8000a4ac:	70 08       	ld.w	r8,r8[0x0]
8000a4ae:	ef 68 ff f3 	st.b	r7[-13],r8
							PrintChar(y, strTmp);
8000a4b2:	ef 38 ff f3 	ld.ub	r8,r7[-13]
8000a4b6:	ee fb ff fc 	ld.w	r11,r7[-4]
8000a4ba:	10 9c       	mov	r12,r8
8000a4bc:	f0 1f 00 43 	mcall	8000a5c8 <log+0x248>
							break;
8000a4c0:	c1 48       	rjmp	8000a4e8 <log+0x168>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000a4c2:	ee f8 fe e0 	ld.w	r8,r7[-288]
8000a4c6:	f0 c9 ff fc 	sub	r9,r8,-4
8000a4ca:	ef 49 fe e0 	st.w	r7[-288],r9
8000a4ce:	70 08       	ld.w	r8,r8[0x0]
8000a4d0:	ef 48 ff fc 	st.w	r7[-4],r8
							//PrintStr(s);
							break;
8000a4d4:	c0 a8       	rjmp	8000a4e8 <log+0x168>
							
							case('%'):
							PrintChar('%', strTmp);
8000a4d6:	ee fb ff fc 	ld.w	r11,r7[-4]
8000a4da:	32 5c       	mov	r12,37
8000a4dc:	f0 1f 00 3b 	mcall	8000a5c8 <log+0x248>
							//PrintChar('%');
							break;
8000a4e0:	c0 48       	rjmp	8000a4e8 <log+0x168>
							
							default:
							log("I need relax.");
8000a4e2:	4b bc       	lddpc	r12,8000a5cc <log+0x24c>
8000a4e4:	f0 1f 00 37 	mcall	8000a5c0 <log+0x240>
						}
						str++;
8000a4e8:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a4ec:	2f f8       	sub	r8,-1
8000a4ee:	ef 48 ff e8 	st.w	r7[-24],r8
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a4f2:	ee c8 01 1c 	sub	r8,r7,284
8000a4f6:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a4fa:	1a d9       	st.w	--sp,r9
8000a4fc:	ee c9 01 1c 	sub	r9,r7,284
8000a500:	1a d9       	st.w	--sp,r9
8000a502:	4b 4b       	lddpc	r11,8000a5d0 <log+0x250>
8000a504:	10 9c       	mov	r12,r8
8000a506:	f0 1f 00 34 	mcall	8000a5d4 <log+0x254>
8000a50a:	2f ed       	sub	sp,-8
8000a50c:	18 98       	mov	r8,r12
8000a50e:	ef 68 ff fb 	st.b	r7[-5],r8
8000a512:	c1 88       	rjmp	8000a542 <log+0x1c2>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a514:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a518:	11 88       	ld.ub	r8,r8[0x0]
8000a51a:	10 99       	mov	r9,r8
8000a51c:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a520:	2f f8       	sub	r8,-1
8000a522:	ef 48 ff e8 	st.w	r7[-24],r8
8000a526:	ee c8 01 1c 	sub	r8,r7,284
8000a52a:	1a d9       	st.w	--sp,r9
8000a52c:	ee c9 01 1c 	sub	r9,r7,284
8000a530:	1a d9       	st.w	--sp,r9
8000a532:	4a ab       	lddpc	r11,8000a5d8 <log+0x258>
8000a534:	10 9c       	mov	r12,r8
8000a536:	f0 1f 00 28 	mcall	8000a5d4 <log+0x254>
8000a53a:	2f ed       	sub	sp,-8
8000a53c:	18 98       	mov	r8,r12
8000a53e:	ef 68 ff fb 	st.b	r7[-5],r8
			
			
			
	}while(*str != '\0');
8000a542:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000a546:	11 88       	ld.ub	r8,r8[0x0]
8000a548:	58 08       	cp.w	r8,0
8000a54a:	fe 91 ff 3a 	brne	8000a3be <log+0x3e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000a54e:	ee c8 01 1c 	sub	r8,r7,284
8000a552:	ee c9 01 1c 	sub	r9,r7,284
8000a556:	1a d9       	st.w	--sp,r9
8000a558:	4a 1b       	lddpc	r11,8000a5dc <log+0x25c>
8000a55a:	10 9c       	mov	r12,r8
8000a55c:	f0 1f 00 1e 	mcall	8000a5d4 <log+0x254>
8000a560:	2f fd       	sub	sp,-4
8000a562:	18 98       	mov	r8,r12
8000a564:	ef 68 ff fb 	st.b	r7[-5],r8
	
	char * p = pvPortMalloc(length+1);
8000a568:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000a56c:	2f f8       	sub	r8,-1
8000a56e:	10 9c       	mov	r12,r8
8000a570:	f0 1f 00 1c 	mcall	8000a5e0 <log+0x260>
8000a574:	18 98       	mov	r8,r12
8000a576:	ef 48 fe dc 	st.w	r7[-292],r8
	memcpy(p, logTmp, length+1);
8000a57a:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000a57e:	2f f8       	sub	r8,-1
8000a580:	10 9a       	mov	r10,r8
8000a582:	ee f8 fe dc 	ld.w	r8,r7[-292]
8000a586:	ee c9 01 1c 	sub	r9,r7,284
8000a58a:	12 9b       	mov	r11,r9
8000a58c:	10 9c       	mov	r12,r8
8000a58e:	f0 1f 00 16 	mcall	8000a5e4 <log+0x264>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
8000a592:	49 68       	lddpc	r8,8000a5e8 <log+0x268>
8000a594:	70 08       	ld.w	r8,r8[0x0]
8000a596:	ee cb 01 24 	sub	r11,r7,292
8000a59a:	30 09       	mov	r9,0
8000a59c:	30 5a       	mov	r10,5
8000a59e:	10 9c       	mov	r12,r8
8000a5a0:	f0 1f 00 13 	mcall	8000a5ec <log+0x26c>
	
	
}
8000a5a4:	fe 3d fd d8 	sub	sp,-552
8000a5a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a5ac:	80 00       	ld.sh	r0,r0[0x0]
8000a5ae:	b1 ba       	sbr	r10,0x11
8000a5b0:	00 00       	add	r0,r0
8000a5b2:	0d 61       	ld.uh	r1,--r6
8000a5b4:	80 01       	ld.sh	r1,r0[0x0]
8000a5b6:	09 58       	ld.sh	r8,--r4
8000a5b8:	80 00       	ld.sh	r0,r0[0x0]
8000a5ba:	9f dc       	st.w	pc[0x34],r12
8000a5bc:	80 00       	ld.sh	r0,r0[0x0]
8000a5be:	9f 70       	st.w	pc[0x1c],r0
8000a5c0:	80 00       	ld.sh	r0,r0[0x0]
8000a5c2:	a3 80       	lsr	r0,0x2
8000a5c4:	80 00       	ld.sh	r0,r0[0x0]
8000a5c6:	a1 94       	lsr	r4,0x1
8000a5c8:	80 00       	ld.sh	r0,r0[0x0]
8000a5ca:	9f a8       	st.w	pc[0x28],r8
8000a5cc:	80 00       	ld.sh	r0,r0[0x0]
8000a5ce:	9f 80       	st.w	pc[0x20],r0
8000a5d0:	80 00       	ld.sh	r0,r0[0x0]
8000a5d2:	9f 90       	st.w	pc[0x24],r0
8000a5d4:	80 00       	ld.sh	r0,r0[0x0]
8000a5d6:	b4 a8       	st.b	r10[0x2],r8
8000a5d8:	80 00       	ld.sh	r0,r0[0x0]
8000a5da:	9f 98       	st.w	pc[0x24],r8
8000a5dc:	80 00       	ld.sh	r0,r0[0x0]
8000a5de:	9f a0       	st.w	pc[0x28],r0
8000a5e0:	80 00       	ld.sh	r0,r0[0x0]
8000a5e2:	88 c8       	ld.uh	r8,r4[0x8]
8000a5e4:	80 00       	ld.sh	r0,r0[0x0]
8000a5e6:	b0 72       	st.h	r8[0xe],r2
8000a5e8:	00 00       	add	r0,r0
8000a5ea:	53 1c       	stdsp	sp[0xc4],r12
8000a5ec:	80 00       	ld.sh	r0,r0[0x0]
8000a5ee:	8a 54       	ld.sh	r4,r5[0xa]

8000a5f0 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000a5f0:	eb cd 40 c0 	pushm	r6-r7,lr
8000a5f4:	1a 97       	mov	r7,sp
8000a5f6:	fa cd 02 24 	sub	sp,sp,548
8000a5fa:	ee c6 ff f4 	sub	r6,r7,-12
8000a5fe:	ef 4c fd dc 	st.w	r7[-548],r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
8000a602:	ee c8 01 14 	sub	r8,r7,276
8000a606:	e0 6a 01 00 	mov	r10,256
8000a60a:	30 0b       	mov	r11,0
8000a60c:	10 9c       	mov	r12,r8
8000a60e:	f0 1f 00 84 	mcall	8000a81c <logFromISR+0x22c>
		
		int len = 0 ;
8000a612:	30 08       	mov	r8,0
8000a614:	ef 48 ff ec 	st.w	r7[-20],r8
		

		va_list arg_ptr;
		char* str = content;
8000a618:	ee f8 fd dc 	ld.w	r8,r7[-548]
8000a61c:	ef 48 ff f0 	st.w	r7[-16],r8
		int x;
		char y;
		//char* s;
		char length= 0;
8000a620:	30 08       	mov	r8,0
8000a622:	ef 68 ff fb 	st.b	r7[-5],r8
		
		va_start(arg_ptr, content);
8000a626:	ec c8 00 00 	sub	r8,r6,0
8000a62a:	ef 48 fe e8 	st.w	r7[-280],r8
		//str += 4;
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
8000a62e:	ee c8 02 20 	sub	r8,r7,544
8000a632:	ef 48 ff fc 	st.w	r7[-4],r8
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000a636:	e0 6a 01 00 	mov	r10,256
8000a63a:	30 0b       	mov	r11,0
8000a63c:	ee fc ff fc 	ld.w	r12,r7[-4]
8000a640:	f0 1f 00 77 	mcall	8000a81c <logFromISR+0x22c>
			
			if(*str == '%')
8000a644:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a648:	11 89       	ld.ub	r9,r8[0x0]
8000a64a:	32 58       	mov	r8,37
8000a64c:	f0 09 18 00 	cp.b	r9,r8
8000a650:	e0 81 00 96 	brne	8000a77c <logFromISR+0x18c>
			{
				static char lench = 0;
				lench =*(str + 1);
8000a654:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a658:	2f f8       	sub	r8,-1
8000a65a:	11 88       	ld.ub	r8,r8[0x0]
8000a65c:	4f 19       	lddpc	r9,8000a820 <logFromISR+0x230>
8000a65e:	b2 88       	st.b	r9[0x0],r8
				if((lench >= '0') &&  (lench <= '9'))
8000a660:	4f 08       	lddpc	r8,8000a820 <logFromISR+0x230>
8000a662:	11 89       	ld.ub	r9,r8[0x0]
8000a664:	32 f8       	mov	r8,47
8000a666:	f0 09 18 00 	cp.b	r9,r8
8000a66a:	e0 88 00 14 	brls	8000a692 <logFromISR+0xa2>
8000a66e:	4e d8       	lddpc	r8,8000a820 <logFromISR+0x230>
8000a670:	11 89       	ld.ub	r9,r8[0x0]
8000a672:	33 98       	mov	r8,57
8000a674:	f0 09 18 00 	cp.b	r9,r8
8000a678:	e0 8b 00 0d 	brhi	8000a692 <logFromISR+0xa2>
				{
					len = *(++str) - '0';
8000a67c:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a680:	2f f8       	sub	r8,-1
8000a682:	ef 48 ff f0 	st.w	r7[-16],r8
8000a686:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a68a:	11 88       	ld.ub	r8,r8[0x0]
8000a68c:	23 08       	sub	r8,48
8000a68e:	ef 48 ff ec 	st.w	r7[-20],r8
				}
				
				str++;
8000a692:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a696:	2f f8       	sub	r8,-1
8000a698:	ef 48 ff f0 	st.w	r7[-16],r8
				
				switch(*(str))
8000a69c:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a6a0:	11 88       	ld.ub	r8,r8[0x0]
8000a6a2:	22 58       	sub	r8,37
8000a6a4:	e0 48 00 53 	cp.w	r8,83
8000a6a8:	e0 8b 00 51 	brhi	8000a74a <logFromISR+0x15a>
8000a6ac:	4d e9       	lddpc	r9,8000a824 <logFromISR+0x234>
8000a6ae:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
8000a6b2:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000a6b6:	f0 c9 ff fc 	sub	r9,r8,-4
8000a6ba:	ef 49 fe e8 	st.w	r7[-280],r9
8000a6be:	70 08       	ld.w	r8,r8[0x0]
8000a6c0:	ef 48 ff f4 	st.w	r7[-12],r8
					strTmp = PrintDec(x, len, strTmp);
8000a6c4:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000a6c8:	5c 58       	castu.b	r8
8000a6ca:	ee fa ff fc 	ld.w	r10,r7[-4]
8000a6ce:	10 9b       	mov	r11,r8
8000a6d0:	ee fc ff f4 	ld.w	r12,r7[-12]
8000a6d4:	f0 1f 00 55 	mcall	8000a828 <logFromISR+0x238>
8000a6d8:	18 98       	mov	r8,r12
8000a6da:	ef 48 ff fc 	st.w	r7[-4],r8
					break;
8000a6de:	c3 98       	rjmp	8000a750 <logFromISR+0x160>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
8000a6e0:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000a6e4:	f0 c9 ff fc 	sub	r9,r8,-4
8000a6e8:	ef 49 fe e8 	st.w	r7[-280],r9
8000a6ec:	70 08       	ld.w	r8,r8[0x0]
8000a6ee:	ef 48 ff f4 	st.w	r7[-12],r8
					PrintHex(x,len, strTmp);
8000a6f2:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000a6f6:	5c 58       	castu.b	r8
8000a6f8:	ee fa ff fc 	ld.w	r10,r7[-4]
8000a6fc:	10 9b       	mov	r11,r8
8000a6fe:	ee fc ff f4 	ld.w	r12,r7[-12]
8000a702:	f0 1f 00 4b 	mcall	8000a82c <logFromISR+0x23c>
					break;
8000a706:	c2 58       	rjmp	8000a750 <logFromISR+0x160>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000a708:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000a70c:	f0 c9 ff fc 	sub	r9,r8,-4
8000a710:	ef 49 fe e8 	st.w	r7[-280],r9
8000a714:	70 08       	ld.w	r8,r8[0x0]
8000a716:	ef 68 ff fa 	st.b	r7[-6],r8
					PrintChar(y, strTmp);
8000a71a:	ef 38 ff fa 	ld.ub	r8,r7[-6]
8000a71e:	ee fb ff fc 	ld.w	r11,r7[-4]
8000a722:	10 9c       	mov	r12,r8
8000a724:	f0 1f 00 43 	mcall	8000a830 <logFromISR+0x240>
					break;
8000a728:	c1 48       	rjmp	8000a750 <logFromISR+0x160>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000a72a:	ee f8 fe e8 	ld.w	r8,r7[-280]
8000a72e:	f0 c9 ff fc 	sub	r9,r8,-4
8000a732:	ef 49 fe e8 	st.w	r7[-280],r9
8000a736:	70 08       	ld.w	r8,r8[0x0]
8000a738:	ef 48 ff fc 	st.w	r7[-4],r8
					//PrintStr(s);
					break;
8000a73c:	c0 a8       	rjmp	8000a750 <logFromISR+0x160>
					case('%'):
					PrintChar('%', strTmp);
8000a73e:	ee fb ff fc 	ld.w	r11,r7[-4]
8000a742:	32 5c       	mov	r12,37
8000a744:	f0 1f 00 3b 	mcall	8000a830 <logFromISR+0x240>
					//PrintChar('%');
					break;
8000a748:	c0 48       	rjmp	8000a750 <logFromISR+0x160>
					default:
					log("I need relax.");
8000a74a:	4b bc       	lddpc	r12,8000a834 <logFromISR+0x244>
8000a74c:	f0 1f 00 3b 	mcall	8000a838 <logFromISR+0x248>
				}
				str++;
8000a750:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a754:	2f f8       	sub	r8,-1
8000a756:	ef 48 ff f0 	st.w	r7[-16],r8
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000a75a:	ee c8 01 14 	sub	r8,r7,276
8000a75e:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a762:	1a d9       	st.w	--sp,r9
8000a764:	ee c9 01 14 	sub	r9,r7,276
8000a768:	1a d9       	st.w	--sp,r9
8000a76a:	4b 5b       	lddpc	r11,8000a83c <logFromISR+0x24c>
8000a76c:	10 9c       	mov	r12,r8
8000a76e:	f0 1f 00 35 	mcall	8000a840 <logFromISR+0x250>
8000a772:	2f ed       	sub	sp,-8
8000a774:	18 98       	mov	r8,r12
8000a776:	ef 68 ff fb 	st.b	r7[-5],r8
8000a77a:	c1 88       	rjmp	8000a7aa <logFromISR+0x1ba>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000a77c:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a780:	11 88       	ld.ub	r8,r8[0x0]
8000a782:	10 99       	mov	r9,r8
8000a784:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a788:	2f f8       	sub	r8,-1
8000a78a:	ef 48 ff f0 	st.w	r7[-16],r8
8000a78e:	ee c8 01 14 	sub	r8,r7,276
8000a792:	1a d9       	st.w	--sp,r9
8000a794:	ee c9 01 14 	sub	r9,r7,276
8000a798:	1a d9       	st.w	--sp,r9
8000a79a:	4a bb       	lddpc	r11,8000a844 <logFromISR+0x254>
8000a79c:	10 9c       	mov	r12,r8
8000a79e:	f0 1f 00 29 	mcall	8000a840 <logFromISR+0x250>
8000a7a2:	2f ed       	sub	sp,-8
8000a7a4:	18 98       	mov	r8,r12
8000a7a6:	ef 68 ff fb 	st.b	r7[-5],r8
			
			
			
		}while(*str != '\0');
8000a7aa:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a7ae:	11 88       	ld.ub	r8,r8[0x0]
8000a7b0:	58 08       	cp.w	r8,0
8000a7b2:	fe 91 ff 3e 	brne	8000a62e <logFromISR+0x3e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000a7b6:	ee c8 01 14 	sub	r8,r7,276
8000a7ba:	ee c9 01 14 	sub	r9,r7,276
8000a7be:	1a d9       	st.w	--sp,r9
8000a7c0:	4a 2b       	lddpc	r11,8000a848 <logFromISR+0x258>
8000a7c2:	10 9c       	mov	r12,r8
8000a7c4:	f0 1f 00 1f 	mcall	8000a840 <logFromISR+0x250>
8000a7c8:	2f fd       	sub	sp,-4
8000a7ca:	18 98       	mov	r8,r12
8000a7cc:	ef 68 ff fb 	st.b	r7[-5],r8
		
		char * p = pvPortMalloc(length+1);
8000a7d0:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000a7d4:	2f f8       	sub	r8,-1
8000a7d6:	10 9c       	mov	r12,r8
8000a7d8:	f0 1f 00 1d 	mcall	8000a84c <logFromISR+0x25c>
8000a7dc:	18 98       	mov	r8,r12
8000a7de:	ef 48 fe e4 	st.w	r7[-284],r8
		memcpy(p, logTmp, length+1);
8000a7e2:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000a7e6:	2f f8       	sub	r8,-1
8000a7e8:	10 9a       	mov	r10,r8
8000a7ea:	ee f8 fe e4 	ld.w	r8,r7[-284]
8000a7ee:	ee c9 01 14 	sub	r9,r7,276
8000a7f2:	12 9b       	mov	r11,r9
8000a7f4:	10 9c       	mov	r12,r8
8000a7f6:	f0 1f 00 17 	mcall	8000a850 <logFromISR+0x260>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000a7fa:	30 08       	mov	r8,0
8000a7fc:	ef 48 fe e0 	st.w	r7[-288],r8
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
8000a800:	49 58       	lddpc	r8,8000a854 <logFromISR+0x264>
8000a802:	70 08       	ld.w	r8,r8[0x0]
8000a804:	ee ca 01 20 	sub	r10,r7,288
8000a808:	ee cb 01 1c 	sub	r11,r7,284
8000a80c:	30 09       	mov	r9,0
8000a80e:	10 9c       	mov	r12,r8
8000a810:	f0 1f 00 12 	mcall	8000a858 <logFromISR+0x268>
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
8000a814:	fe 3d fd dc 	sub	sp,-548
8000a818:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000a81c:	80 00       	ld.sh	r0,r0[0x0]
8000a81e:	b1 ba       	sbr	r10,0x11
8000a820:	00 00       	add	r0,r0
8000a822:	0d 60       	ld.uh	r0,--r6
8000a824:	80 01       	ld.sh	r1,r0[0x0]
8000a826:	0a a8       	st.w	r5++,r8
8000a828:	80 00       	ld.sh	r0,r0[0x0]
8000a82a:	9f dc       	st.w	pc[0x34],r12
8000a82c:	80 00       	ld.sh	r0,r0[0x0]
8000a82e:	a1 94       	lsr	r4,0x1
8000a830:	80 00       	ld.sh	r0,r0[0x0]
8000a832:	9f a8       	st.w	pc[0x28],r8
8000a834:	80 00       	ld.sh	r0,r0[0x0]
8000a836:	9f 80       	st.w	pc[0x20],r0
8000a838:	80 00       	ld.sh	r0,r0[0x0]
8000a83a:	a3 80       	lsr	r0,0x2
8000a83c:	80 00       	ld.sh	r0,r0[0x0]
8000a83e:	9f 90       	st.w	pc[0x24],r0
8000a840:	80 00       	ld.sh	r0,r0[0x0]
8000a842:	b4 a8       	st.b	r10[0x2],r8
8000a844:	80 00       	ld.sh	r0,r0[0x0]
8000a846:	9f 98       	st.w	pc[0x24],r8
8000a848:	80 00       	ld.sh	r0,r0[0x0]
8000a84a:	9f a0       	st.w	pc[0x28],r0
8000a84c:	80 00       	ld.sh	r0,r0[0x0]
8000a84e:	88 c8       	ld.uh	r8,r4[0x8]
8000a850:	80 00       	ld.sh	r0,r0[0x0]
8000a852:	b0 72       	st.h	r8[0xe],r2
8000a854:	00 00       	add	r0,r0
8000a856:	53 1c       	stdsp	sp[0xc4],r12
8000a858:	80 00       	ld.sh	r0,r0[0x0]
8000a85a:	8b bc       	st.w	r5[0x2c],r12

8000a85c <task_log>:
	
static void task_log(void * pvParameters)
{
8000a85c:	eb cd 40 80 	pushm	r7,lr
8000a860:	1a 97       	mov	r7,sp
8000a862:	20 2d       	sub	sp,8
8000a864:	ef 4c ff f8 	st.w	r7[-8],r12
8000a868:	c0 48       	rjmp	8000a870 <task_log+0x14>
				vPortFree(str);
			}
			
		}

	}
8000a86a:	d7 03       	nop
8000a86c:	c0 28       	rjmp	8000a870 <task_log+0x14>
8000a86e:	d7 03       	nop
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000a870:	48 f8       	lddpc	r8,8000a8ac <task_log+0x50>
8000a872:	70 08       	ld.w	r8,r8[0x0]
8000a874:	ee cb 00 04 	sub	r11,r7,4
8000a878:	30 09       	mov	r9,0
8000a87a:	3f fa       	mov	r10,-1
8000a87c:	10 9c       	mov	r12,r8
8000a87e:	f0 1f 00 0d 	mcall	8000a8b0 <task_log+0x54>
8000a882:	18 98       	mov	r8,r12
8000a884:	58 18       	cp.w	r8,1
8000a886:	cf 21       	brne	8000a86a <task_log+0xe>
		{
			if( NULL != str)
8000a888:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a88c:	58 08       	cp.w	r8,0
8000a88e:	cf 00       	breq	8000a86e <task_log+0x12>
			{
				usart_write_line(EXAMPLE_USART, str);
8000a890:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a894:	10 9b       	mov	r11,r8
8000a896:	fe 7c 18 00 	mov	r12,-59392
8000a89a:	f0 1f 00 07 	mcall	8000a8b4 <task_log+0x58>
				vPortFree(str);
8000a89e:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a8a2:	10 9c       	mov	r12,r8
8000a8a4:	f0 1f 00 05 	mcall	8000a8b8 <task_log+0x5c>
			}
			
		}

	}
8000a8a8:	ce 4b       	rjmp	8000a870 <task_log+0x14>
8000a8aa:	00 00       	add	r0,r0
8000a8ac:	00 00       	add	r0,r0
8000a8ae:	53 1c       	stdsp	sp[0xc4],r12
8000a8b0:	80 00       	ld.sh	r0,r0[0x0]
8000a8b2:	8c 60       	ld.sh	r0,r6[0xc]
8000a8b4:	80 00       	ld.sh	r0,r0[0x0]
8000a8b6:	81 a8       	st.w	r0[0x28],r8
8000a8b8:	80 00       	ld.sh	r0,r0[0x0]
8000a8ba:	89 04       	st.w	r4[0x0],r4
8000a8bc:	2d 2d       	sub	sp,-184
8000a8be:	2d 2d       	sub	sp,-184
8000a8c0:	73 74       	ld.w	r4,r9[0x5c]
8000a8c2:	61 72       	ld.w	r2,r0[0x5c]
8000a8c4:	74 20       	ld.w	r0,r10[0x8]
8000a8c6:	64 65       	ld.w	r5,r2[0x18]
8000a8c8:	62 75       	ld.w	r5,r1[0x1c]
8000a8ca:	67 a3       	ld.w	r3,r3[0x68]
8000a8cc:	ac 20       	st.h	r6[0x4],r0
8000a8ce:	79 6f       	ld.w	pc,r12[0x58]
8000a8d0:	79 6f       	ld.w	pc,r12[0x58]
8000a8d2:	2d 2d       	sub	sp,-184
8000a8d4:	2d 2d       	sub	sp,-184
	...

8000a8d8 <main>:
//#include "fs/fs.h"
#include "rtc/rtc.h"
#include "data_flash/data_flash.h"

int main(void)
{
8000a8d8:	eb cd 40 80 	pushm	r7,lr
8000a8dc:	1a 97       	mov	r7,sp
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000a8de:	fe 78 10 00 	mov	r8,-61440
8000a8e2:	30 19       	mov	r9,1
8000a8e4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
8000a8e8:	fe 78 10 00 	mov	r8,-61440
8000a8ec:	30 19       	mov	r9,1
8000a8ee:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
8000a8f2:	fe 78 10 00 	mov	r8,-61440
8000a8f6:	30 19       	mov	r9,1
8000a8f8:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000a8fc:	d3 03       	ssrf	0x10
	local_start_pll0();
8000a8fe:	f0 1f 00 15 	mcall	8000a950 <main+0x78>
		
	INTC_init_interrupts();
8000a902:	f0 1f 00 15 	mcall	8000a954 <main+0x7c>
	
	log_init();		
8000a906:	f0 1f 00 15 	mcall	8000a958 <main+0x80>
	log("----start debug yoyo----");	
8000a90a:	49 5c       	lddpc	r12,8000a95c <main+0x84>
8000a90c:	f0 1f 00 15 	mcall	8000a960 <main+0x88>
	
	data_flash_init();
8000a910:	f0 1f 00 15 	mcall	8000a964 <main+0x8c>
		
	//rtc_init();
	
	//fs_init();//65795,RadioOBSD

	tc_init();	
8000a914:	f0 1f 00 15 	mcall	8000a968 <main+0x90>
			
	xcmp_init();
8000a918:	f0 1f 00 15 	mcall	8000a96c <main+0x94>
	
	app_init();
8000a91c:	f0 1f 00 15 	mcall	8000a970 <main+0x98>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
8000a920:	fe 78 10 00 	mov	r8,-61440
8000a924:	f0 f8 01 60 	ld.w	r8,r8[352]
8000a928:	e2 18 00 02 	andl	r8,0x2,COH
8000a92c:	cf a0       	breq	8000a920 <main+0x48>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000a92e:	fe 78 10 00 	mov	r8,-61440
8000a932:	f0 f8 01 60 	ld.w	r8,r8[352]
8000a936:	e2 18 00 02 	andl	r8,0x2,COH
8000a93a:	cf a1       	brne	8000a92e <main+0x56>
	local_start_timer();
8000a93c:	f0 1f 00 0e 	mcall	8000a974 <main+0x9c>
	
	Enable_global_interrupt();
8000a940:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
8000a942:	f0 1f 00 0e 	mcall	8000a978 <main+0xa0>
	return 0;
8000a946:	30 08       	mov	r8,0
}
8000a948:	10 9c       	mov	r12,r8
8000a94a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a94e:	00 00       	add	r0,r0
8000a950:	80 00       	ld.sh	r0,r0[0x0]
8000a952:	71 18       	ld.w	r8,r8[0x44]
8000a954:	80 00       	ld.sh	r0,r0[0x0]
8000a956:	73 1c       	ld.w	r12,r9[0x44]
8000a958:	80 00       	ld.sh	r0,r0[0x0]
8000a95a:	a3 0c       	ld.d	r12,r1
8000a95c:	80 00       	ld.sh	r0,r0[0x0]
8000a95e:	a8 bc       	st.b	r4[0x3],r12
8000a960:	80 00       	ld.sh	r0,r0[0x0]
8000a962:	a3 80       	lsr	r0,0x2
8000a964:	80 00       	ld.sh	r0,r0[0x0]
8000a966:	35 00       	mov	r0,80
8000a968:	80 00       	ld.sh	r0,r0[0x0]
8000a96a:	72 20       	ld.w	r0,r9[0x8]
8000a96c:	80 00       	ld.sh	r0,r0[0x0]
8000a96e:	65 d4       	ld.w	r4,r2[0x74]
8000a970:	80 00       	ld.sh	r0,r0[0x0]
8000a972:	33 2c       	mov	r12,50
8000a974:	80 00       	ld.sh	r0,r0[0x0]
8000a976:	71 b0       	ld.w	r0,r8[0x6c]
8000a978:	80 00       	ld.sh	r0,r0[0x0]
8000a97a:	94 54       	ld.sh	r4,r10[0xa]

8000a97c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000a97c:	eb cd 40 80 	pushm	r7,lr
8000a980:	1a 97       	mov	r7,sp
8000a982:	20 4d       	sub	sp,16
8000a984:	ef 4c ff f4 	st.w	r7[-12],r12
8000a988:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
8000a98c:	30 08       	mov	r8,0
8000a98e:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a992:	30 08       	mov	r8,0
8000a994:	ef 48 ff fc 	st.w	r7[-4],r8
8000a998:	c1 c8       	rjmp	8000a9d0 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000a99a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a99e:	70 19       	ld.w	r9,r8[0x4]
8000a9a0:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a9a4:	70 08       	ld.w	r8,r8[0x0]
8000a9a6:	12 9b       	mov	r11,r9
8000a9a8:	10 9c       	mov	r12,r8
8000a9aa:	f0 1f 00 10 	mcall	8000a9e8 <gpio_enable_module+0x6c>
8000a9ae:	18 98       	mov	r8,r12
8000a9b0:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000a9b4:	f3 e8 10 08 	or	r8,r9,r8
8000a9b8:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
8000a9bc:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000a9c0:	2f 88       	sub	r8,-8
8000a9c2:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000a9c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000a9ca:	2f f8       	sub	r8,-1
8000a9cc:	ef 48 ff fc 	st.w	r7[-4],r8
8000a9d0:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000a9d4:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000a9d8:	10 39       	cp.w	r9,r8
8000a9da:	ce 03       	brcs	8000a99a <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
8000a9dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
8000a9e0:	10 9c       	mov	r12,r8
8000a9e2:	2f cd       	sub	sp,-16
8000a9e4:	e3 cd 80 80 	ldm	sp++,r7,pc
8000a9e8:	80 00       	ld.sh	r0,r0[0x0]
8000a9ea:	a9 ec       	*unknown*

8000a9ec <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
8000a9ec:	eb cd 40 80 	pushm	r7,lr
8000a9f0:	1a 97       	mov	r7,sp
8000a9f2:	20 3d       	sub	sp,12
8000a9f4:	ef 4c ff f8 	st.w	r7[-8],r12
8000a9f8:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000a9fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aa00:	a5 98       	lsr	r8,0x5
8000aa02:	a9 68       	lsl	r8,0x8
8000aa04:	e0 28 f0 00 	sub	r8,61440
8000aa08:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
8000aa0c:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000aa10:	58 18       	cp.w	r8,1
8000aa12:	c1 e0       	breq	8000aa4e <gpio_enable_module_pin+0x62>
8000aa14:	c0 63       	brcs	8000aa20 <gpio_enable_module_pin+0x34>
8000aa16:	58 28       	cp.w	r8,2
8000aa18:	c3 20       	breq	8000aa7c <gpio_enable_module_pin+0x90>
8000aa1a:	58 38       	cp.w	r8,3
8000aa1c:	c4 70       	breq	8000aaaa <gpio_enable_module_pin+0xbe>
8000aa1e:	c5 d8       	rjmp	8000aad8 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000aa20:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aa24:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aa28:	30 19       	mov	r9,1
8000aa2a:	f2 08 09 48 	lsl	r8,r9,r8
8000aa2e:	10 99       	mov	r9,r8
8000aa30:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aa34:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000aa36:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aa3a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aa3e:	30 19       	mov	r9,1
8000aa40:	f2 08 09 48 	lsl	r8,r9,r8
8000aa44:	10 99       	mov	r9,r8
8000aa46:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aa4a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000aa4c:	c4 88       	rjmp	8000aadc <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000aa4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aa52:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aa56:	30 19       	mov	r9,1
8000aa58:	f2 08 09 48 	lsl	r8,r9,r8
8000aa5c:	10 99       	mov	r9,r8
8000aa5e:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aa62:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000aa64:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aa68:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aa6c:	30 19       	mov	r9,1
8000aa6e:	f2 08 09 48 	lsl	r8,r9,r8
8000aa72:	10 99       	mov	r9,r8
8000aa74:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aa78:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000aa7a:	c3 18       	rjmp	8000aadc <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000aa7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aa80:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aa84:	30 19       	mov	r9,1
8000aa86:	f2 08 09 48 	lsl	r8,r9,r8
8000aa8a:	10 99       	mov	r9,r8
8000aa8c:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aa90:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000aa92:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aa96:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aa9a:	30 19       	mov	r9,1
8000aa9c:	f2 08 09 48 	lsl	r8,r9,r8
8000aaa0:	10 99       	mov	r9,r8
8000aaa2:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aaa6:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000aaa8:	c1 a8       	rjmp	8000aadc <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000aaaa:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aaae:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aab2:	30 19       	mov	r9,1
8000aab4:	f2 08 09 48 	lsl	r8,r9,r8
8000aab8:	10 99       	mov	r9,r8
8000aaba:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aabe:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000aac0:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aac4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aac8:	30 19       	mov	r9,1
8000aaca:	f2 08 09 48 	lsl	r8,r9,r8
8000aace:	10 99       	mov	r9,r8
8000aad0:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aad4:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000aad6:	c0 38       	rjmp	8000aadc <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
8000aad8:	30 18       	mov	r8,1
8000aada:	c0 d8       	rjmp	8000aaf4 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000aadc:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000aae0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aae4:	30 19       	mov	r9,1
8000aae6:	f2 08 09 48 	lsl	r8,r9,r8
8000aaea:	10 99       	mov	r9,r8
8000aaec:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000aaf0:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
8000aaf2:	30 08       	mov	r8,0
}
8000aaf4:	10 9c       	mov	r12,r8
8000aaf6:	2f dd       	sub	sp,-12
8000aaf8:	e3 cd 80 80 	ldm	sp++,r7,pc

8000aafc <gpio_enable_gpio_pin>:
 *            GPIO mode of PX21, AVR32_PIN_PX21 can be used. Module pins such as
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
8000aafc:	eb cd 40 80 	pushm	r7,lr
8000ab00:	1a 97       	mov	r7,sp
8000ab02:	20 2d       	sub	sp,8
8000ab04:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000ab08:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000ab0c:	a5 98       	lsr	r8,0x5
8000ab0e:	a9 68       	lsl	r8,0x8
8000ab10:	e0 28 f0 00 	sub	r8,61440
8000ab14:	ef 48 ff fc 	st.w	r7[-4],r8
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000ab18:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000ab1c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ab20:	30 19       	mov	r9,1
8000ab22:	f2 08 09 48 	lsl	r8,r9,r8
8000ab26:	10 99       	mov	r9,r8
8000ab28:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000ab2c:	f1 49 00 48 	st.w	r8[72],r9
	gpio_port->gpers = 1 << (pin & 0x1F);
8000ab30:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000ab34:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ab38:	30 19       	mov	r9,1
8000ab3a:	f2 08 09 48 	lsl	r8,r9,r8
8000ab3e:	10 99       	mov	r9,r8
8000ab40:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000ab44:	91 19       	st.w	r8[0x4],r9
}
8000ab46:	2f ed       	sub	sp,-8
8000ab48:	e3 cd 80 80 	ldm	sp++,r7,pc

8000ab4c <gpio_set_gpio_pin>:
/** \brief Drives a GPIO pin to 1.
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
8000ab4c:	eb cd 40 80 	pushm	r7,lr
8000ab50:	1a 97       	mov	r7,sp
8000ab52:	20 2d       	sub	sp,8
8000ab54:	ef 4c ff f8 	st.w	r7[-8],r12
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000ab58:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000ab5c:	a5 98       	lsr	r8,0x5
8000ab5e:	a9 68       	lsl	r8,0x8
8000ab60:	e0 28 f0 00 	sub	r8,61440
8000ab64:	ef 48 ff fc 	st.w	r7[-4],r8
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);																				
8000ab68:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000ab6c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ab70:	30 19       	mov	r9,1
8000ab72:	f2 08 09 48 	lsl	r8,r9,r8
8000ab76:	10 99       	mov	r9,r8
8000ab78:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000ab7c:	f1 49 00 54 	st.w	r8[84],r9
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
8000ab80:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000ab84:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ab88:	30 19       	mov	r9,1
8000ab8a:	f2 08 09 48 	lsl	r8,r9,r8
8000ab8e:	10 99       	mov	r9,r8
8000ab90:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000ab94:	f1 49 00 44 	st.w	r8[68],r9
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000ab98:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000ab9c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000aba0:	30 19       	mov	r9,1
8000aba2:	f2 08 09 48 	lsl	r8,r9,r8
8000aba6:	10 99       	mov	r9,r8
8000aba8:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000abac:	91 19       	st.w	r8[0x4],r9
}
8000abae:	2f ed       	sub	sp,-8
8000abb0:	e3 cd 80 80 	ldm	sp++,r7,pc

8000abb4 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000abb4:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000abb8:	fe c0 a5 b8 	sub	r0,pc,-23112

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
8000abbc:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000abc0:	d5 53       	csrf	0x15
  cp      r0, r1
8000abc2:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000abc4:	e0 61 0a 58 	mov	r1,2648
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000abc8:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000abca:	c0 72       	brcc	8000abd8 <idata_load_loop_end>
  cp      r0, r1
8000abcc:	fe c2 9a 2c 	sub	r2,pc,-26068

8000abd0 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000abd0:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000abd2:	a1 24       	st.d	r0++,r4
  cp      r0, r1
8000abd4:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000abd6:	cf d3       	brcs	8000abd0 <idata_load_loop>

8000abd8 <idata_load_loop_end>:
  mov     r2, 0
8000abd8:	e0 60 0a 58 	mov	r0,2648
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
8000abdc:	e0 61 53 28 	mov	r1,21288
  cp      r0, r1
  brlo    udata_clear_loop
8000abe0:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000abe2:	c0 62       	brcc	8000abee <udata_clear_loop_end>
8000abe4:	30 02       	mov	r2,0
8000abe6:	30 03       	mov	r3,0

8000abe8 <udata_clear_loop>:
8000abe8:	a1 22       	st.d	r0++,r2
8000abea:	02 30       	cp.w	r0,r1
8000abec:	cf e3       	brcs	8000abe8 <udata_clear_loop>

8000abee <udata_clear_loop_end>:
8000abee:	fe cf 03 16 	sub	pc,pc,790
8000abf2:	d7 03       	nop

8000abf4 <free>:
8000abf4:	d4 01       	pushm	lr
8000abf6:	e0 68 0a 50 	mov	r8,2640
8000abfa:	18 9b       	mov	r11,r12
8000abfc:	70 0c       	ld.w	r12,r8[0x0]
8000abfe:	e0 a0 1e 7f 	rcall	8000e8fc <_free_r>
8000ac02:	d8 02       	popm	pc

8000ac04 <malloc>:
8000ac04:	d4 01       	pushm	lr
8000ac06:	e0 68 0a 50 	mov	r8,2640
8000ac0a:	18 9b       	mov	r11,r12
8000ac0c:	70 0c       	ld.w	r12,r8[0x0]
8000ac0e:	c0 3c       	rcall	8000ac14 <_malloc_r>
8000ac10:	d8 02       	popm	pc
8000ac12:	d7 03       	nop

8000ac14 <_malloc_r>:
8000ac14:	d4 31       	pushm	r0-r7,lr
8000ac16:	f6 c8 ff f5 	sub	r8,r11,-11
8000ac1a:	18 95       	mov	r5,r12
8000ac1c:	10 97       	mov	r7,r8
8000ac1e:	e0 17 ff f8 	andl	r7,0xfff8
8000ac22:	59 68       	cp.w	r8,22
8000ac24:	f9 b7 08 10 	movls	r7,16
8000ac28:	16 37       	cp.w	r7,r11
8000ac2a:	5f 38       	srlo	r8
8000ac2c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000ac30:	c0 50       	breq	8000ac3a <_malloc_r+0x26>
8000ac32:	30 c8       	mov	r8,12
8000ac34:	99 38       	st.w	r12[0xc],r8
8000ac36:	e0 8f 01 fa 	bral	8000b02a <_malloc_r+0x416>
8000ac3a:	fe b0 eb c9 	rcall	800083cc <__malloc_lock>
8000ac3e:	e0 47 01 f7 	cp.w	r7,503
8000ac42:	e0 8b 00 1d 	brhi	8000ac7c <_malloc_r+0x68>
8000ac46:	ee 03 16 03 	lsr	r3,r7,0x3
8000ac4a:	e0 68 05 50 	mov	r8,1360
8000ac4e:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000ac52:	70 36       	ld.w	r6,r8[0xc]
8000ac54:	10 36       	cp.w	r6,r8
8000ac56:	c0 61       	brne	8000ac62 <_malloc_r+0x4e>
8000ac58:	ec c8 ff f8 	sub	r8,r6,-8
8000ac5c:	70 36       	ld.w	r6,r8[0xc]
8000ac5e:	10 36       	cp.w	r6,r8
8000ac60:	c0 c0       	breq	8000ac78 <_malloc_r+0x64>
8000ac62:	6c 18       	ld.w	r8,r6[0x4]
8000ac64:	e0 18 ff fc 	andl	r8,0xfffc
8000ac68:	6c 3a       	ld.w	r10,r6[0xc]
8000ac6a:	ec 08 00 09 	add	r9,r6,r8
8000ac6e:	0a 9c       	mov	r12,r5
8000ac70:	6c 28       	ld.w	r8,r6[0x8]
8000ac72:	95 28       	st.w	r10[0x8],r8
8000ac74:	91 3a       	st.w	r8[0xc],r10
8000ac76:	c4 78       	rjmp	8000ad04 <_malloc_r+0xf0>
8000ac78:	2f e3       	sub	r3,-2
8000ac7a:	c4 d8       	rjmp	8000ad14 <_malloc_r+0x100>
8000ac7c:	ee 03 16 09 	lsr	r3,r7,0x9
8000ac80:	c0 41       	brne	8000ac88 <_malloc_r+0x74>
8000ac82:	ee 03 16 03 	lsr	r3,r7,0x3
8000ac86:	c2 68       	rjmp	8000acd2 <_malloc_r+0xbe>
8000ac88:	58 43       	cp.w	r3,4
8000ac8a:	e0 8b 00 06 	brhi	8000ac96 <_malloc_r+0x82>
8000ac8e:	ee 03 16 06 	lsr	r3,r7,0x6
8000ac92:	2c 83       	sub	r3,-56
8000ac94:	c1 f8       	rjmp	8000acd2 <_malloc_r+0xbe>
8000ac96:	59 43       	cp.w	r3,20
8000ac98:	e0 8b 00 04 	brhi	8000aca0 <_malloc_r+0x8c>
8000ac9c:	2a 53       	sub	r3,-91
8000ac9e:	c1 a8       	rjmp	8000acd2 <_malloc_r+0xbe>
8000aca0:	e0 43 00 54 	cp.w	r3,84
8000aca4:	e0 8b 00 06 	brhi	8000acb0 <_malloc_r+0x9c>
8000aca8:	ee 03 16 0c 	lsr	r3,r7,0xc
8000acac:	29 23       	sub	r3,-110
8000acae:	c1 28       	rjmp	8000acd2 <_malloc_r+0xbe>
8000acb0:	e0 43 01 54 	cp.w	r3,340
8000acb4:	e0 8b 00 06 	brhi	8000acc0 <_malloc_r+0xac>
8000acb8:	ee 03 16 0f 	lsr	r3,r7,0xf
8000acbc:	28 93       	sub	r3,-119
8000acbe:	c0 a8       	rjmp	8000acd2 <_malloc_r+0xbe>
8000acc0:	e0 43 05 54 	cp.w	r3,1364
8000acc4:	e0 88 00 04 	brls	8000accc <_malloc_r+0xb8>
8000acc8:	37 e3       	mov	r3,126
8000acca:	c0 48       	rjmp	8000acd2 <_malloc_r+0xbe>
8000accc:	ee 03 16 12 	lsr	r3,r7,0x12
8000acd0:	28 43       	sub	r3,-124
8000acd2:	e0 6a 05 50 	mov	r10,1360
8000acd6:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000acda:	74 36       	ld.w	r6,r10[0xc]
8000acdc:	c1 98       	rjmp	8000ad0e <_malloc_r+0xfa>
8000acde:	6c 19       	ld.w	r9,r6[0x4]
8000ace0:	e0 19 ff fc 	andl	r9,0xfffc
8000ace4:	f2 07 01 0b 	sub	r11,r9,r7
8000ace8:	58 fb       	cp.w	r11,15
8000acea:	e0 8a 00 04 	brle	8000acf2 <_malloc_r+0xde>
8000acee:	20 13       	sub	r3,1
8000acf0:	c1 18       	rjmp	8000ad12 <_malloc_r+0xfe>
8000acf2:	6c 38       	ld.w	r8,r6[0xc]
8000acf4:	58 0b       	cp.w	r11,0
8000acf6:	c0 b5       	brlt	8000ad0c <_malloc_r+0xf8>
8000acf8:	6c 2a       	ld.w	r10,r6[0x8]
8000acfa:	ec 09 00 09 	add	r9,r6,r9
8000acfe:	0a 9c       	mov	r12,r5
8000ad00:	91 2a       	st.w	r8[0x8],r10
8000ad02:	95 38       	st.w	r10[0xc],r8
8000ad04:	72 18       	ld.w	r8,r9[0x4]
8000ad06:	a1 a8       	sbr	r8,0x0
8000ad08:	93 18       	st.w	r9[0x4],r8
8000ad0a:	cb c8       	rjmp	8000ae82 <_malloc_r+0x26e>
8000ad0c:	10 96       	mov	r6,r8
8000ad0e:	14 36       	cp.w	r6,r10
8000ad10:	ce 71       	brne	8000acde <_malloc_r+0xca>
8000ad12:	2f f3       	sub	r3,-1
8000ad14:	e0 6a 05 50 	mov	r10,1360
8000ad18:	f4 cc ff f8 	sub	r12,r10,-8
8000ad1c:	78 26       	ld.w	r6,r12[0x8]
8000ad1e:	18 36       	cp.w	r6,r12
8000ad20:	c6 c0       	breq	8000adf8 <_malloc_r+0x1e4>
8000ad22:	6c 19       	ld.w	r9,r6[0x4]
8000ad24:	e0 19 ff fc 	andl	r9,0xfffc
8000ad28:	f2 07 01 08 	sub	r8,r9,r7
8000ad2c:	58 f8       	cp.w	r8,15
8000ad2e:	e0 89 00 8f 	brgt	8000ae4c <_malloc_r+0x238>
8000ad32:	99 3c       	st.w	r12[0xc],r12
8000ad34:	99 2c       	st.w	r12[0x8],r12
8000ad36:	58 08       	cp.w	r8,0
8000ad38:	c0 55       	brlt	8000ad42 <_malloc_r+0x12e>
8000ad3a:	ec 09 00 09 	add	r9,r6,r9
8000ad3e:	0a 9c       	mov	r12,r5
8000ad40:	ce 2b       	rjmp	8000ad04 <_malloc_r+0xf0>
8000ad42:	e0 49 01 ff 	cp.w	r9,511
8000ad46:	e0 8b 00 13 	brhi	8000ad6c <_malloc_r+0x158>
8000ad4a:	a3 99       	lsr	r9,0x3
8000ad4c:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000ad50:	70 2b       	ld.w	r11,r8[0x8]
8000ad52:	8d 38       	st.w	r6[0xc],r8
8000ad54:	8d 2b       	st.w	r6[0x8],r11
8000ad56:	97 36       	st.w	r11[0xc],r6
8000ad58:	91 26       	st.w	r8[0x8],r6
8000ad5a:	a3 49       	asr	r9,0x2
8000ad5c:	74 18       	ld.w	r8,r10[0x4]
8000ad5e:	30 1b       	mov	r11,1
8000ad60:	f6 09 09 49 	lsl	r9,r11,r9
8000ad64:	f1 e9 10 09 	or	r9,r8,r9
8000ad68:	95 19       	st.w	r10[0x4],r9
8000ad6a:	c4 78       	rjmp	8000adf8 <_malloc_r+0x1e4>
8000ad6c:	f2 0a 16 09 	lsr	r10,r9,0x9
8000ad70:	58 4a       	cp.w	r10,4
8000ad72:	e0 8b 00 07 	brhi	8000ad80 <_malloc_r+0x16c>
8000ad76:	f2 0a 16 06 	lsr	r10,r9,0x6
8000ad7a:	2c 8a       	sub	r10,-56
8000ad7c:	c2 08       	rjmp	8000adbc <_malloc_r+0x1a8>
8000ad7e:	d7 03       	nop
8000ad80:	59 4a       	cp.w	r10,20
8000ad82:	e0 8b 00 04 	brhi	8000ad8a <_malloc_r+0x176>
8000ad86:	2a 5a       	sub	r10,-91
8000ad88:	c1 a8       	rjmp	8000adbc <_malloc_r+0x1a8>
8000ad8a:	e0 4a 00 54 	cp.w	r10,84
8000ad8e:	e0 8b 00 06 	brhi	8000ad9a <_malloc_r+0x186>
8000ad92:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000ad96:	29 2a       	sub	r10,-110
8000ad98:	c1 28       	rjmp	8000adbc <_malloc_r+0x1a8>
8000ad9a:	e0 4a 01 54 	cp.w	r10,340
8000ad9e:	e0 8b 00 06 	brhi	8000adaa <_malloc_r+0x196>
8000ada2:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000ada6:	28 9a       	sub	r10,-119
8000ada8:	c0 a8       	rjmp	8000adbc <_malloc_r+0x1a8>
8000adaa:	e0 4a 05 54 	cp.w	r10,1364
8000adae:	e0 88 00 04 	brls	8000adb6 <_malloc_r+0x1a2>
8000adb2:	37 ea       	mov	r10,126
8000adb4:	c0 48       	rjmp	8000adbc <_malloc_r+0x1a8>
8000adb6:	f2 0a 16 12 	lsr	r10,r9,0x12
8000adba:	28 4a       	sub	r10,-124
8000adbc:	e0 6b 05 50 	mov	r11,1360
8000adc0:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000adc4:	68 28       	ld.w	r8,r4[0x8]
8000adc6:	08 38       	cp.w	r8,r4
8000adc8:	c0 e1       	brne	8000ade4 <_malloc_r+0x1d0>
8000adca:	76 19       	ld.w	r9,r11[0x4]
8000adcc:	a3 4a       	asr	r10,0x2
8000adce:	30 1e       	mov	lr,1
8000add0:	fc 0a 09 4a 	lsl	r10,lr,r10
8000add4:	f3 ea 10 0a 	or	r10,r9,r10
8000add8:	10 99       	mov	r9,r8
8000adda:	97 1a       	st.w	r11[0x4],r10
8000addc:	c0 a8       	rjmp	8000adf0 <_malloc_r+0x1dc>
8000adde:	70 28       	ld.w	r8,r8[0x8]
8000ade0:	08 38       	cp.w	r8,r4
8000ade2:	c0 60       	breq	8000adee <_malloc_r+0x1da>
8000ade4:	70 1a       	ld.w	r10,r8[0x4]
8000ade6:	e0 1a ff fc 	andl	r10,0xfffc
8000adea:	14 39       	cp.w	r9,r10
8000adec:	cf 93       	brcs	8000adde <_malloc_r+0x1ca>
8000adee:	70 39       	ld.w	r9,r8[0xc]
8000adf0:	8d 39       	st.w	r6[0xc],r9
8000adf2:	8d 28       	st.w	r6[0x8],r8
8000adf4:	91 36       	st.w	r8[0xc],r6
8000adf6:	93 26       	st.w	r9[0x8],r6
8000adf8:	e6 08 14 02 	asr	r8,r3,0x2
8000adfc:	30 1b       	mov	r11,1
8000adfe:	e0 64 05 50 	mov	r4,1360
8000ae02:	f6 08 09 4b 	lsl	r11,r11,r8
8000ae06:	68 18       	ld.w	r8,r4[0x4]
8000ae08:	10 3b       	cp.w	r11,r8
8000ae0a:	e0 8b 00 6b 	brhi	8000aee0 <_malloc_r+0x2cc>
8000ae0e:	f7 e8 00 09 	and	r9,r11,r8
8000ae12:	c0 b1       	brne	8000ae28 <_malloc_r+0x214>
8000ae14:	e0 13 ff fc 	andl	r3,0xfffc
8000ae18:	a1 7b       	lsl	r11,0x1
8000ae1a:	2f c3       	sub	r3,-4
8000ae1c:	c0 38       	rjmp	8000ae22 <_malloc_r+0x20e>
8000ae1e:	2f c3       	sub	r3,-4
8000ae20:	a1 7b       	lsl	r11,0x1
8000ae22:	f7 e8 00 09 	and	r9,r11,r8
8000ae26:	cf c0       	breq	8000ae1e <_malloc_r+0x20a>
8000ae28:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000ae2c:	06 92       	mov	r2,r3
8000ae2e:	1c 91       	mov	r1,lr
8000ae30:	62 36       	ld.w	r6,r1[0xc]
8000ae32:	c2 e8       	rjmp	8000ae8e <_malloc_r+0x27a>
8000ae34:	6c 1a       	ld.w	r10,r6[0x4]
8000ae36:	e0 1a ff fc 	andl	r10,0xfffc
8000ae3a:	f4 07 01 08 	sub	r8,r10,r7
8000ae3e:	58 f8       	cp.w	r8,15
8000ae40:	e0 8a 00 15 	brle	8000ae6a <_malloc_r+0x256>
8000ae44:	6c 3a       	ld.w	r10,r6[0xc]
8000ae46:	6c 29       	ld.w	r9,r6[0x8]
8000ae48:	95 29       	st.w	r10[0x8],r9
8000ae4a:	93 3a       	st.w	r9[0xc],r10
8000ae4c:	0e 99       	mov	r9,r7
8000ae4e:	ec 07 00 07 	add	r7,r6,r7
8000ae52:	a1 a9       	sbr	r9,0x0
8000ae54:	99 37       	st.w	r12[0xc],r7
8000ae56:	99 27       	st.w	r12[0x8],r7
8000ae58:	8d 19       	st.w	r6[0x4],r9
8000ae5a:	ee 08 09 08 	st.w	r7[r8],r8
8000ae5e:	8f 2c       	st.w	r7[0x8],r12
8000ae60:	8f 3c       	st.w	r7[0xc],r12
8000ae62:	a1 a8       	sbr	r8,0x0
8000ae64:	0a 9c       	mov	r12,r5
8000ae66:	8f 18       	st.w	r7[0x4],r8
8000ae68:	c0 d8       	rjmp	8000ae82 <_malloc_r+0x26e>
8000ae6a:	6c 39       	ld.w	r9,r6[0xc]
8000ae6c:	58 08       	cp.w	r8,0
8000ae6e:	c0 f5       	brlt	8000ae8c <_malloc_r+0x278>
8000ae70:	ec 0a 00 0a 	add	r10,r6,r10
8000ae74:	74 18       	ld.w	r8,r10[0x4]
8000ae76:	a1 a8       	sbr	r8,0x0
8000ae78:	0a 9c       	mov	r12,r5
8000ae7a:	95 18       	st.w	r10[0x4],r8
8000ae7c:	6c 28       	ld.w	r8,r6[0x8]
8000ae7e:	93 28       	st.w	r9[0x8],r8
8000ae80:	91 39       	st.w	r8[0xc],r9
8000ae82:	fe b0 ea b3 	rcall	800083e8 <__malloc_unlock>
8000ae86:	ec cc ff f8 	sub	r12,r6,-8
8000ae8a:	d8 32       	popm	r0-r7,pc
8000ae8c:	12 96       	mov	r6,r9
8000ae8e:	02 36       	cp.w	r6,r1
8000ae90:	cd 21       	brne	8000ae34 <_malloc_r+0x220>
8000ae92:	2f f2       	sub	r2,-1
8000ae94:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000ae98:	c0 30       	breq	8000ae9e <_malloc_r+0x28a>
8000ae9a:	2f 81       	sub	r1,-8
8000ae9c:	cc ab       	rjmp	8000ae30 <_malloc_r+0x21c>
8000ae9e:	1c 98       	mov	r8,lr
8000aea0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000aea4:	c0 81       	brne	8000aeb4 <_malloc_r+0x2a0>
8000aea6:	68 19       	ld.w	r9,r4[0x4]
8000aea8:	f6 08 11 ff 	rsub	r8,r11,-1
8000aeac:	f3 e8 00 08 	and	r8,r9,r8
8000aeb0:	89 18       	st.w	r4[0x4],r8
8000aeb2:	c0 78       	rjmp	8000aec0 <_malloc_r+0x2ac>
8000aeb4:	f0 c9 00 08 	sub	r9,r8,8
8000aeb8:	20 13       	sub	r3,1
8000aeba:	70 08       	ld.w	r8,r8[0x0]
8000aebc:	12 38       	cp.w	r8,r9
8000aebe:	cf 10       	breq	8000aea0 <_malloc_r+0x28c>
8000aec0:	a1 7b       	lsl	r11,0x1
8000aec2:	68 18       	ld.w	r8,r4[0x4]
8000aec4:	10 3b       	cp.w	r11,r8
8000aec6:	e0 8b 00 0d 	brhi	8000aee0 <_malloc_r+0x2cc>
8000aeca:	58 0b       	cp.w	r11,0
8000aecc:	c0 a0       	breq	8000aee0 <_malloc_r+0x2cc>
8000aece:	04 93       	mov	r3,r2
8000aed0:	c0 38       	rjmp	8000aed6 <_malloc_r+0x2c2>
8000aed2:	2f c3       	sub	r3,-4
8000aed4:	a1 7b       	lsl	r11,0x1
8000aed6:	f7 e8 00 09 	and	r9,r11,r8
8000aeda:	ca 71       	brne	8000ae28 <_malloc_r+0x214>
8000aedc:	cf bb       	rjmp	8000aed2 <_malloc_r+0x2be>
8000aede:	d7 03       	nop
8000aee0:	68 23       	ld.w	r3,r4[0x8]
8000aee2:	66 12       	ld.w	r2,r3[0x4]
8000aee4:	e0 12 ff fc 	andl	r2,0xfffc
8000aee8:	0e 32       	cp.w	r2,r7
8000aeea:	5f 39       	srlo	r9
8000aeec:	e4 07 01 08 	sub	r8,r2,r7
8000aef0:	58 f8       	cp.w	r8,15
8000aef2:	5f aa       	srle	r10
8000aef4:	f5 e9 10 09 	or	r9,r10,r9
8000aef8:	e0 80 00 9a 	breq	8000b02c <_malloc_r+0x418>
8000aefc:	e0 68 0d 6c 	mov	r8,3436
8000af00:	70 01       	ld.w	r1,r8[0x0]
8000af02:	e0 68 09 5c 	mov	r8,2396
8000af06:	2f 01       	sub	r1,-16
8000af08:	70 08       	ld.w	r8,r8[0x0]
8000af0a:	0e 01       	add	r1,r7
8000af0c:	5b f8       	cp.w	r8,-1
8000af0e:	c0 40       	breq	8000af16 <_malloc_r+0x302>
8000af10:	28 11       	sub	r1,-127
8000af12:	e0 11 ff 80 	andl	r1,0xff80
8000af16:	02 9b       	mov	r11,r1
8000af18:	0a 9c       	mov	r12,r5
8000af1a:	e0 a0 02 b7 	rcall	8000b488 <_sbrk_r>
8000af1e:	18 96       	mov	r6,r12
8000af20:	5b fc       	cp.w	r12,-1
8000af22:	c7 50       	breq	8000b00c <_malloc_r+0x3f8>
8000af24:	e6 02 00 08 	add	r8,r3,r2
8000af28:	10 3c       	cp.w	r12,r8
8000af2a:	c0 32       	brcc	8000af30 <_malloc_r+0x31c>
8000af2c:	08 33       	cp.w	r3,r4
8000af2e:	c6 f1       	brne	8000b00c <_malloc_r+0x3f8>
8000af30:	e0 6a 0d 70 	mov	r10,3440
8000af34:	74 09       	ld.w	r9,r10[0x0]
8000af36:	e2 09 00 09 	add	r9,r1,r9
8000af3a:	95 09       	st.w	r10[0x0],r9
8000af3c:	10 36       	cp.w	r6,r8
8000af3e:	c0 a1       	brne	8000af52 <_malloc_r+0x33e>
8000af40:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000af44:	c0 71       	brne	8000af52 <_malloc_r+0x33e>
8000af46:	e2 02 00 02 	add	r2,r1,r2
8000af4a:	68 28       	ld.w	r8,r4[0x8]
8000af4c:	a1 a2       	sbr	r2,0x0
8000af4e:	91 12       	st.w	r8[0x4],r2
8000af50:	c4 f8       	rjmp	8000afee <_malloc_r+0x3da>
8000af52:	e0 6a 09 5c 	mov	r10,2396
8000af56:	74 0b       	ld.w	r11,r10[0x0]
8000af58:	5b fb       	cp.w	r11,-1
8000af5a:	c0 31       	brne	8000af60 <_malloc_r+0x34c>
8000af5c:	95 06       	st.w	r10[0x0],r6
8000af5e:	c0 78       	rjmp	8000af6c <_malloc_r+0x358>
8000af60:	ec 09 00 09 	add	r9,r6,r9
8000af64:	e0 6a 0d 70 	mov	r10,3440
8000af68:	10 19       	sub	r9,r8
8000af6a:	95 09       	st.w	r10[0x0],r9
8000af6c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000af70:	f0 09 11 08 	rsub	r9,r8,8
8000af74:	58 08       	cp.w	r8,0
8000af76:	f2 08 17 10 	movne	r8,r9
8000af7a:	ed d8 e1 06 	addne	r6,r6,r8
8000af7e:	28 08       	sub	r8,-128
8000af80:	ec 01 00 01 	add	r1,r6,r1
8000af84:	0a 9c       	mov	r12,r5
8000af86:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000af8a:	f0 01 01 01 	sub	r1,r8,r1
8000af8e:	02 9b       	mov	r11,r1
8000af90:	e0 a0 02 7c 	rcall	8000b488 <_sbrk_r>
8000af94:	e0 68 0d 70 	mov	r8,3440
8000af98:	5b fc       	cp.w	r12,-1
8000af9a:	ec 0c 17 00 	moveq	r12,r6
8000af9e:	f9 b1 00 00 	moveq	r1,0
8000afa2:	70 09       	ld.w	r9,r8[0x0]
8000afa4:	0c 1c       	sub	r12,r6
8000afa6:	89 26       	st.w	r4[0x8],r6
8000afa8:	02 0c       	add	r12,r1
8000afaa:	12 01       	add	r1,r9
8000afac:	a1 ac       	sbr	r12,0x0
8000afae:	91 01       	st.w	r8[0x0],r1
8000afb0:	8d 1c       	st.w	r6[0x4],r12
8000afb2:	08 33       	cp.w	r3,r4
8000afb4:	c1 d0       	breq	8000afee <_malloc_r+0x3da>
8000afb6:	58 f2       	cp.w	r2,15
8000afb8:	e0 8b 00 05 	brhi	8000afc2 <_malloc_r+0x3ae>
8000afbc:	30 18       	mov	r8,1
8000afbe:	8d 18       	st.w	r6[0x4],r8
8000afc0:	c2 68       	rjmp	8000b00c <_malloc_r+0x3f8>
8000afc2:	30 59       	mov	r9,5
8000afc4:	20 c2       	sub	r2,12
8000afc6:	e0 12 ff f8 	andl	r2,0xfff8
8000afca:	e6 02 00 08 	add	r8,r3,r2
8000afce:	91 29       	st.w	r8[0x8],r9
8000afd0:	91 19       	st.w	r8[0x4],r9
8000afd2:	66 18       	ld.w	r8,r3[0x4]
8000afd4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000afd8:	e5 e8 10 08 	or	r8,r2,r8
8000afdc:	87 18       	st.w	r3[0x4],r8
8000afde:	58 f2       	cp.w	r2,15
8000afe0:	e0 88 00 07 	brls	8000afee <_malloc_r+0x3da>
8000afe4:	e6 cb ff f8 	sub	r11,r3,-8
8000afe8:	0a 9c       	mov	r12,r5
8000afea:	e0 a0 1c 89 	rcall	8000e8fc <_free_r>
8000afee:	e0 69 0d 68 	mov	r9,3432
8000aff2:	72 0a       	ld.w	r10,r9[0x0]
8000aff4:	e0 68 0d 70 	mov	r8,3440
8000aff8:	70 08       	ld.w	r8,r8[0x0]
8000affa:	14 38       	cp.w	r8,r10
8000affc:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000b000:	e0 69 0d 64 	mov	r9,3428
8000b004:	72 0a       	ld.w	r10,r9[0x0]
8000b006:	14 38       	cp.w	r8,r10
8000b008:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000b00c:	68 28       	ld.w	r8,r4[0x8]
8000b00e:	70 18       	ld.w	r8,r8[0x4]
8000b010:	e0 18 ff fc 	andl	r8,0xfffc
8000b014:	0e 38       	cp.w	r8,r7
8000b016:	5f 39       	srlo	r9
8000b018:	0e 18       	sub	r8,r7
8000b01a:	58 f8       	cp.w	r8,15
8000b01c:	5f aa       	srle	r10
8000b01e:	f5 e9 10 09 	or	r9,r10,r9
8000b022:	c0 50       	breq	8000b02c <_malloc_r+0x418>
8000b024:	0a 9c       	mov	r12,r5
8000b026:	fe b0 e9 e1 	rcall	800083e8 <__malloc_unlock>
8000b02a:	d8 3a       	popm	r0-r7,pc,r12=0
8000b02c:	68 26       	ld.w	r6,r4[0x8]
8000b02e:	a1 a8       	sbr	r8,0x0
8000b030:	0e 99       	mov	r9,r7
8000b032:	a1 a9       	sbr	r9,0x0
8000b034:	8d 19       	st.w	r6[0x4],r9
8000b036:	ec 07 00 07 	add	r7,r6,r7
8000b03a:	0a 9c       	mov	r12,r5
8000b03c:	89 27       	st.w	r4[0x8],r7
8000b03e:	8f 18       	st.w	r7[0x4],r8
8000b040:	fe b0 e9 d4 	rcall	800083e8 <__malloc_unlock>
8000b044:	ec cc ff f8 	sub	r12,r6,-8
8000b048:	d8 32       	popm	r0-r7,pc
8000b04a:	d7 03       	nop

8000b04c <memcmp>:
8000b04c:	d4 01       	pushm	lr
8000b04e:	30 08       	mov	r8,0
8000b050:	c0 d8       	rjmp	8000b06a <memcmp+0x1e>
8000b052:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000b056:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b05a:	20 1a       	sub	r10,1
8000b05c:	2f f8       	sub	r8,-1
8000b05e:	f2 0e 18 00 	cp.b	lr,r9
8000b062:	c0 40       	breq	8000b06a <memcmp+0x1e>
8000b064:	fc 09 01 0c 	sub	r12,lr,r9
8000b068:	d8 02       	popm	pc
8000b06a:	58 0a       	cp.w	r10,0
8000b06c:	cf 31       	brne	8000b052 <memcmp+0x6>
8000b06e:	14 9c       	mov	r12,r10
8000b070:	d8 02       	popm	pc

8000b072 <memcpy>:
8000b072:	58 8a       	cp.w	r10,8
8000b074:	c2 f5       	brlt	8000b0d2 <memcpy+0x60>
8000b076:	f9 eb 10 09 	or	r9,r12,r11
8000b07a:	e2 19 00 03 	andl	r9,0x3,COH
8000b07e:	e0 81 00 97 	brne	8000b1ac <memcpy+0x13a>
8000b082:	e0 4a 00 20 	cp.w	r10,32
8000b086:	c3 b4       	brge	8000b0fc <memcpy+0x8a>
8000b088:	f4 08 14 02 	asr	r8,r10,0x2
8000b08c:	f0 09 11 08 	rsub	r9,r8,8
8000b090:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000b094:	76 69       	ld.w	r9,r11[0x18]
8000b096:	99 69       	st.w	r12[0x18],r9
8000b098:	76 59       	ld.w	r9,r11[0x14]
8000b09a:	99 59       	st.w	r12[0x14],r9
8000b09c:	76 49       	ld.w	r9,r11[0x10]
8000b09e:	99 49       	st.w	r12[0x10],r9
8000b0a0:	76 39       	ld.w	r9,r11[0xc]
8000b0a2:	99 39       	st.w	r12[0xc],r9
8000b0a4:	76 29       	ld.w	r9,r11[0x8]
8000b0a6:	99 29       	st.w	r12[0x8],r9
8000b0a8:	76 19       	ld.w	r9,r11[0x4]
8000b0aa:	99 19       	st.w	r12[0x4],r9
8000b0ac:	76 09       	ld.w	r9,r11[0x0]
8000b0ae:	99 09       	st.w	r12[0x0],r9
8000b0b0:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000b0b4:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000b0b8:	e0 1a 00 03 	andl	r10,0x3
8000b0bc:	f4 0a 11 04 	rsub	r10,r10,4
8000b0c0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000b0c4:	17 a9       	ld.ub	r9,r11[0x2]
8000b0c6:	b0 a9       	st.b	r8[0x2],r9
8000b0c8:	17 99       	ld.ub	r9,r11[0x1]
8000b0ca:	b0 99       	st.b	r8[0x1],r9
8000b0cc:	17 89       	ld.ub	r9,r11[0x0]
8000b0ce:	b0 89       	st.b	r8[0x0],r9
8000b0d0:	5e fc       	retal	r12
8000b0d2:	f4 0a 11 09 	rsub	r10,r10,9
8000b0d6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000b0da:	17 f9       	ld.ub	r9,r11[0x7]
8000b0dc:	b8 f9       	st.b	r12[0x7],r9
8000b0de:	17 e9       	ld.ub	r9,r11[0x6]
8000b0e0:	b8 e9       	st.b	r12[0x6],r9
8000b0e2:	17 d9       	ld.ub	r9,r11[0x5]
8000b0e4:	b8 d9       	st.b	r12[0x5],r9
8000b0e6:	17 c9       	ld.ub	r9,r11[0x4]
8000b0e8:	b8 c9       	st.b	r12[0x4],r9
8000b0ea:	17 b9       	ld.ub	r9,r11[0x3]
8000b0ec:	b8 b9       	st.b	r12[0x3],r9
8000b0ee:	17 a9       	ld.ub	r9,r11[0x2]
8000b0f0:	b8 a9       	st.b	r12[0x2],r9
8000b0f2:	17 99       	ld.ub	r9,r11[0x1]
8000b0f4:	b8 99       	st.b	r12[0x1],r9
8000b0f6:	17 89       	ld.ub	r9,r11[0x0]
8000b0f8:	b8 89       	st.b	r12[0x0],r9
8000b0fa:	5e fc       	retal	r12
8000b0fc:	eb cd 40 c0 	pushm	r6-r7,lr
8000b100:	18 99       	mov	r9,r12
8000b102:	22 0a       	sub	r10,32
8000b104:	b7 07       	ld.d	r6,r11++
8000b106:	b3 26       	st.d	r9++,r6
8000b108:	b7 07       	ld.d	r6,r11++
8000b10a:	b3 26       	st.d	r9++,r6
8000b10c:	b7 07       	ld.d	r6,r11++
8000b10e:	b3 26       	st.d	r9++,r6
8000b110:	b7 07       	ld.d	r6,r11++
8000b112:	b3 26       	st.d	r9++,r6
8000b114:	22 0a       	sub	r10,32
8000b116:	cf 74       	brge	8000b104 <memcpy+0x92>
8000b118:	2f 0a       	sub	r10,-16
8000b11a:	c0 65       	brlt	8000b126 <memcpy+0xb4>
8000b11c:	b7 07       	ld.d	r6,r11++
8000b11e:	b3 26       	st.d	r9++,r6
8000b120:	b7 07       	ld.d	r6,r11++
8000b122:	b3 26       	st.d	r9++,r6
8000b124:	21 0a       	sub	r10,16
8000b126:	5c 3a       	neg	r10
8000b128:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000b12c:	d7 03       	nop
8000b12e:	d7 03       	nop
8000b130:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000b134:	f3 66 00 0e 	st.b	r9[14],r6
8000b138:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000b13c:	f3 66 00 0d 	st.b	r9[13],r6
8000b140:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000b144:	f3 66 00 0c 	st.b	r9[12],r6
8000b148:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000b14c:	f3 66 00 0b 	st.b	r9[11],r6
8000b150:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000b154:	f3 66 00 0a 	st.b	r9[10],r6
8000b158:	f7 36 00 09 	ld.ub	r6,r11[9]
8000b15c:	f3 66 00 09 	st.b	r9[9],r6
8000b160:	f7 36 00 08 	ld.ub	r6,r11[8]
8000b164:	f3 66 00 08 	st.b	r9[8],r6
8000b168:	f7 36 00 07 	ld.ub	r6,r11[7]
8000b16c:	f3 66 00 07 	st.b	r9[7],r6
8000b170:	f7 36 00 06 	ld.ub	r6,r11[6]
8000b174:	f3 66 00 06 	st.b	r9[6],r6
8000b178:	f7 36 00 05 	ld.ub	r6,r11[5]
8000b17c:	f3 66 00 05 	st.b	r9[5],r6
8000b180:	f7 36 00 04 	ld.ub	r6,r11[4]
8000b184:	f3 66 00 04 	st.b	r9[4],r6
8000b188:	f7 36 00 03 	ld.ub	r6,r11[3]
8000b18c:	f3 66 00 03 	st.b	r9[3],r6
8000b190:	f7 36 00 02 	ld.ub	r6,r11[2]
8000b194:	f3 66 00 02 	st.b	r9[2],r6
8000b198:	f7 36 00 01 	ld.ub	r6,r11[1]
8000b19c:	f3 66 00 01 	st.b	r9[1],r6
8000b1a0:	f7 36 00 00 	ld.ub	r6,r11[0]
8000b1a4:	f3 66 00 00 	st.b	r9[0],r6
8000b1a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000b1ac:	20 1a       	sub	r10,1
8000b1ae:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000b1b2:	f8 0a 0b 09 	st.b	r12[r10],r9
8000b1b6:	cf b1       	brne	8000b1ac <memcpy+0x13a>
8000b1b8:	5e fc       	retal	r12

8000b1ba <memset>:
8000b1ba:	18 98       	mov	r8,r12
8000b1bc:	c0 38       	rjmp	8000b1c2 <memset+0x8>
8000b1be:	10 cb       	st.b	r8++,r11
8000b1c0:	20 1a       	sub	r10,1
8000b1c2:	58 0a       	cp.w	r10,0
8000b1c4:	cf d1       	brne	8000b1be <memset+0x4>
8000b1c6:	5e fc       	retal	r12

8000b1c8 <_realloc_r>:
8000b1c8:	d4 31       	pushm	r0-r7,lr
8000b1ca:	20 1d       	sub	sp,4
8000b1cc:	16 94       	mov	r4,r11
8000b1ce:	18 92       	mov	r2,r12
8000b1d0:	14 9b       	mov	r11,r10
8000b1d2:	58 04       	cp.w	r4,0
8000b1d4:	c0 51       	brne	8000b1de <_realloc_r+0x16>
8000b1d6:	fe b0 fd 1f 	rcall	8000ac14 <_malloc_r>
8000b1da:	18 95       	mov	r5,r12
8000b1dc:	c5 39       	rjmp	8000b482 <_realloc_r+0x2ba>
8000b1de:	50 0a       	stdsp	sp[0x0],r10
8000b1e0:	fe b0 e8 f6 	rcall	800083cc <__malloc_lock>
8000b1e4:	40 0b       	lddsp	r11,sp[0x0]
8000b1e6:	f6 c8 ff f5 	sub	r8,r11,-11
8000b1ea:	e8 c1 00 08 	sub	r1,r4,8
8000b1ee:	10 96       	mov	r6,r8
8000b1f0:	62 1c       	ld.w	r12,r1[0x4]
8000b1f2:	e0 16 ff f8 	andl	r6,0xfff8
8000b1f6:	59 68       	cp.w	r8,22
8000b1f8:	f9 b6 08 10 	movls	r6,16
8000b1fc:	16 36       	cp.w	r6,r11
8000b1fe:	5f 38       	srlo	r8
8000b200:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000b204:	c0 50       	breq	8000b20e <_realloc_r+0x46>
8000b206:	30 c8       	mov	r8,12
8000b208:	30 05       	mov	r5,0
8000b20a:	85 38       	st.w	r2[0xc],r8
8000b20c:	c3 b9       	rjmp	8000b482 <_realloc_r+0x2ba>
8000b20e:	18 90       	mov	r0,r12
8000b210:	e0 10 ff fc 	andl	r0,0xfffc
8000b214:	0c 30       	cp.w	r0,r6
8000b216:	e0 84 01 0b 	brge	8000b42c <_realloc_r+0x264>
8000b21a:	e0 68 05 50 	mov	r8,1360
8000b21e:	e2 00 00 09 	add	r9,r1,r0
8000b222:	70 25       	ld.w	r5,r8[0x8]
8000b224:	0a 39       	cp.w	r9,r5
8000b226:	c0 90       	breq	8000b238 <_realloc_r+0x70>
8000b228:	72 1a       	ld.w	r10,r9[0x4]
8000b22a:	a1 ca       	cbr	r10,0x0
8000b22c:	f2 0a 00 0a 	add	r10,r9,r10
8000b230:	74 1a       	ld.w	r10,r10[0x4]
8000b232:	ed ba 00 00 	bld	r10,0x0
8000b236:	c2 20       	breq	8000b27a <_realloc_r+0xb2>
8000b238:	72 1a       	ld.w	r10,r9[0x4]
8000b23a:	e0 1a ff fc 	andl	r10,0xfffc
8000b23e:	f4 00 00 03 	add	r3,r10,r0
8000b242:	0a 39       	cp.w	r9,r5
8000b244:	c1 31       	brne	8000b26a <_realloc_r+0xa2>
8000b246:	ec c7 ff f0 	sub	r7,r6,-16
8000b24a:	0e 33       	cp.w	r3,r7
8000b24c:	c1 95       	brlt	8000b27e <_realloc_r+0xb6>
8000b24e:	e2 06 00 09 	add	r9,r1,r6
8000b252:	0c 13       	sub	r3,r6
8000b254:	a1 a3       	sbr	r3,0x0
8000b256:	93 13       	st.w	r9[0x4],r3
8000b258:	91 29       	st.w	r8[0x8],r9
8000b25a:	04 9c       	mov	r12,r2
8000b25c:	62 18       	ld.w	r8,r1[0x4]
8000b25e:	08 95       	mov	r5,r4
8000b260:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b264:	10 46       	or	r6,r8
8000b266:	83 16       	st.w	r1[0x4],r6
8000b268:	c0 b9       	rjmp	8000b47e <_realloc_r+0x2b6>
8000b26a:	0c 33       	cp.w	r3,r6
8000b26c:	c0 95       	brlt	8000b27e <_realloc_r+0xb6>
8000b26e:	72 28       	ld.w	r8,r9[0x8]
8000b270:	02 97       	mov	r7,r1
8000b272:	72 39       	ld.w	r9,r9[0xc]
8000b274:	93 28       	st.w	r9[0x8],r8
8000b276:	91 39       	st.w	r8[0xc],r9
8000b278:	cd c8       	rjmp	8000b430 <_realloc_r+0x268>
8000b27a:	30 0a       	mov	r10,0
8000b27c:	14 99       	mov	r9,r10
8000b27e:	ed bc 00 00 	bld	r12,0x0
8000b282:	e0 80 00 95 	breq	8000b3ac <_realloc_r+0x1e4>
8000b286:	62 07       	ld.w	r7,r1[0x0]
8000b288:	e2 07 01 07 	sub	r7,r1,r7
8000b28c:	6e 1c       	ld.w	r12,r7[0x4]
8000b28e:	e0 1c ff fc 	andl	r12,0xfffc
8000b292:	58 09       	cp.w	r9,0
8000b294:	c5 60       	breq	8000b340 <_realloc_r+0x178>
8000b296:	f8 00 00 03 	add	r3,r12,r0
8000b29a:	0a 39       	cp.w	r9,r5
8000b29c:	c4 81       	brne	8000b32c <_realloc_r+0x164>
8000b29e:	14 03       	add	r3,r10
8000b2a0:	ec c9 ff f0 	sub	r9,r6,-16
8000b2a4:	12 33       	cp.w	r3,r9
8000b2a6:	c4 d5       	brlt	8000b340 <_realloc_r+0x178>
8000b2a8:	6e 3a       	ld.w	r10,r7[0xc]
8000b2aa:	6e 29       	ld.w	r9,r7[0x8]
8000b2ac:	95 29       	st.w	r10[0x8],r9
8000b2ae:	93 3a       	st.w	r9[0xc],r10
8000b2b0:	ee c5 ff f8 	sub	r5,r7,-8
8000b2b4:	e0 ca 00 04 	sub	r10,r0,4
8000b2b8:	e0 4a 00 24 	cp.w	r10,36
8000b2bc:	e0 8b 00 25 	brhi	8000b306 <_realloc_r+0x13e>
8000b2c0:	0a 99       	mov	r9,r5
8000b2c2:	59 3a       	cp.w	r10,19
8000b2c4:	e0 88 00 1a 	brls	8000b2f8 <_realloc_r+0x130>
8000b2c8:	09 09       	ld.w	r9,r4++
8000b2ca:	8b 09       	st.w	r5[0x0],r9
8000b2cc:	09 09       	ld.w	r9,r4++
8000b2ce:	8f 39       	st.w	r7[0xc],r9
8000b2d0:	ee c9 ff f0 	sub	r9,r7,-16
8000b2d4:	59 ba       	cp.w	r10,27
8000b2d6:	e0 88 00 11 	brls	8000b2f8 <_realloc_r+0x130>
8000b2da:	09 0b       	ld.w	r11,r4++
8000b2dc:	93 0b       	st.w	r9[0x0],r11
8000b2de:	09 09       	ld.w	r9,r4++
8000b2e0:	8f 59       	st.w	r7[0x14],r9
8000b2e2:	ee c9 ff e8 	sub	r9,r7,-24
8000b2e6:	e0 4a 00 24 	cp.w	r10,36
8000b2ea:	c0 71       	brne	8000b2f8 <_realloc_r+0x130>
8000b2ec:	09 0a       	ld.w	r10,r4++
8000b2ee:	93 0a       	st.w	r9[0x0],r10
8000b2f0:	ee c9 ff e0 	sub	r9,r7,-32
8000b2f4:	09 0a       	ld.w	r10,r4++
8000b2f6:	8f 7a       	st.w	r7[0x1c],r10
8000b2f8:	09 0a       	ld.w	r10,r4++
8000b2fa:	12 aa       	st.w	r9++,r10
8000b2fc:	68 0a       	ld.w	r10,r4[0x0]
8000b2fe:	93 0a       	st.w	r9[0x0],r10
8000b300:	68 1a       	ld.w	r10,r4[0x4]
8000b302:	93 1a       	st.w	r9[0x4],r10
8000b304:	c0 78       	rjmp	8000b312 <_realloc_r+0x14a>
8000b306:	50 08       	stdsp	sp[0x0],r8
8000b308:	08 9b       	mov	r11,r4
8000b30a:	0a 9c       	mov	r12,r5
8000b30c:	e0 a0 1d 9b 	rcall	8000ee42 <memmove>
8000b310:	40 08       	lddsp	r8,sp[0x0]
8000b312:	ee 06 00 09 	add	r9,r7,r6
8000b316:	0c 13       	sub	r3,r6
8000b318:	a1 a3       	sbr	r3,0x0
8000b31a:	93 13       	st.w	r9[0x4],r3
8000b31c:	91 29       	st.w	r8[0x8],r9
8000b31e:	04 9c       	mov	r12,r2
8000b320:	6e 18       	ld.w	r8,r7[0x4]
8000b322:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b326:	10 46       	or	r6,r8
8000b328:	8f 16       	st.w	r7[0x4],r6
8000b32a:	ca a8       	rjmp	8000b47e <_realloc_r+0x2b6>
8000b32c:	14 03       	add	r3,r10
8000b32e:	0c 33       	cp.w	r3,r6
8000b330:	c0 85       	brlt	8000b340 <_realloc_r+0x178>
8000b332:	72 28       	ld.w	r8,r9[0x8]
8000b334:	72 39       	ld.w	r9,r9[0xc]
8000b336:	93 28       	st.w	r9[0x8],r8
8000b338:	91 39       	st.w	r8[0xc],r9
8000b33a:	6e 28       	ld.w	r8,r7[0x8]
8000b33c:	6e 39       	ld.w	r9,r7[0xc]
8000b33e:	c0 78       	rjmp	8000b34c <_realloc_r+0x184>
8000b340:	f8 00 00 03 	add	r3,r12,r0
8000b344:	0c 33       	cp.w	r3,r6
8000b346:	c3 35       	brlt	8000b3ac <_realloc_r+0x1e4>
8000b348:	6e 39       	ld.w	r9,r7[0xc]
8000b34a:	6e 28       	ld.w	r8,r7[0x8]
8000b34c:	93 28       	st.w	r9[0x8],r8
8000b34e:	91 39       	st.w	r8[0xc],r9
8000b350:	e0 ca 00 04 	sub	r10,r0,4
8000b354:	ee cc ff f8 	sub	r12,r7,-8
8000b358:	e0 4a 00 24 	cp.w	r10,36
8000b35c:	e0 8b 00 24 	brhi	8000b3a4 <_realloc_r+0x1dc>
8000b360:	59 3a       	cp.w	r10,19
8000b362:	e0 88 00 1a 	brls	8000b396 <_realloc_r+0x1ce>
8000b366:	09 08       	ld.w	r8,r4++
8000b368:	99 08       	st.w	r12[0x0],r8
8000b36a:	09 08       	ld.w	r8,r4++
8000b36c:	8f 38       	st.w	r7[0xc],r8
8000b36e:	ee cc ff f0 	sub	r12,r7,-16
8000b372:	59 ba       	cp.w	r10,27
8000b374:	e0 88 00 11 	brls	8000b396 <_realloc_r+0x1ce>
8000b378:	09 08       	ld.w	r8,r4++
8000b37a:	99 08       	st.w	r12[0x0],r8
8000b37c:	09 08       	ld.w	r8,r4++
8000b37e:	8f 58       	st.w	r7[0x14],r8
8000b380:	ee cc ff e8 	sub	r12,r7,-24
8000b384:	e0 4a 00 24 	cp.w	r10,36
8000b388:	c0 71       	brne	8000b396 <_realloc_r+0x1ce>
8000b38a:	09 08       	ld.w	r8,r4++
8000b38c:	99 08       	st.w	r12[0x0],r8
8000b38e:	ee cc ff e0 	sub	r12,r7,-32
8000b392:	09 08       	ld.w	r8,r4++
8000b394:	8f 78       	st.w	r7[0x1c],r8
8000b396:	09 08       	ld.w	r8,r4++
8000b398:	18 a8       	st.w	r12++,r8
8000b39a:	68 08       	ld.w	r8,r4[0x0]
8000b39c:	99 08       	st.w	r12[0x0],r8
8000b39e:	68 18       	ld.w	r8,r4[0x4]
8000b3a0:	99 18       	st.w	r12[0x4],r8
8000b3a2:	c4 78       	rjmp	8000b430 <_realloc_r+0x268>
8000b3a4:	08 9b       	mov	r11,r4
8000b3a6:	e0 a0 1d 4e 	rcall	8000ee42 <memmove>
8000b3aa:	c4 38       	rjmp	8000b430 <_realloc_r+0x268>
8000b3ac:	04 9c       	mov	r12,r2
8000b3ae:	fe b0 fc 33 	rcall	8000ac14 <_malloc_r>
8000b3b2:	18 95       	mov	r5,r12
8000b3b4:	c3 a0       	breq	8000b428 <_realloc_r+0x260>
8000b3b6:	62 18       	ld.w	r8,r1[0x4]
8000b3b8:	f8 c9 00 08 	sub	r9,r12,8
8000b3bc:	a1 c8       	cbr	r8,0x0
8000b3be:	e2 08 00 08 	add	r8,r1,r8
8000b3c2:	10 39       	cp.w	r9,r8
8000b3c4:	c0 71       	brne	8000b3d2 <_realloc_r+0x20a>
8000b3c6:	72 13       	ld.w	r3,r9[0x4]
8000b3c8:	02 97       	mov	r7,r1
8000b3ca:	e0 13 ff fc 	andl	r3,0xfffc
8000b3ce:	00 03       	add	r3,r0
8000b3d0:	c3 08       	rjmp	8000b430 <_realloc_r+0x268>
8000b3d2:	e0 ca 00 04 	sub	r10,r0,4
8000b3d6:	e0 4a 00 24 	cp.w	r10,36
8000b3da:	e0 8b 00 20 	brhi	8000b41a <_realloc_r+0x252>
8000b3de:	08 99       	mov	r9,r4
8000b3e0:	18 98       	mov	r8,r12
8000b3e2:	59 3a       	cp.w	r10,19
8000b3e4:	e0 88 00 14 	brls	8000b40c <_realloc_r+0x244>
8000b3e8:	13 0b       	ld.w	r11,r9++
8000b3ea:	10 ab       	st.w	r8++,r11
8000b3ec:	13 0b       	ld.w	r11,r9++
8000b3ee:	10 ab       	st.w	r8++,r11
8000b3f0:	59 ba       	cp.w	r10,27
8000b3f2:	e0 88 00 0d 	brls	8000b40c <_realloc_r+0x244>
8000b3f6:	13 0b       	ld.w	r11,r9++
8000b3f8:	10 ab       	st.w	r8++,r11
8000b3fa:	13 0b       	ld.w	r11,r9++
8000b3fc:	10 ab       	st.w	r8++,r11
8000b3fe:	e0 4a 00 24 	cp.w	r10,36
8000b402:	c0 51       	brne	8000b40c <_realloc_r+0x244>
8000b404:	13 0a       	ld.w	r10,r9++
8000b406:	10 aa       	st.w	r8++,r10
8000b408:	13 0a       	ld.w	r10,r9++
8000b40a:	10 aa       	st.w	r8++,r10
8000b40c:	13 0a       	ld.w	r10,r9++
8000b40e:	10 aa       	st.w	r8++,r10
8000b410:	72 0a       	ld.w	r10,r9[0x0]
8000b412:	91 0a       	st.w	r8[0x0],r10
8000b414:	72 19       	ld.w	r9,r9[0x4]
8000b416:	91 19       	st.w	r8[0x4],r9
8000b418:	c0 48       	rjmp	8000b420 <_realloc_r+0x258>
8000b41a:	08 9b       	mov	r11,r4
8000b41c:	e0 a0 1d 13 	rcall	8000ee42 <memmove>
8000b420:	08 9b       	mov	r11,r4
8000b422:	04 9c       	mov	r12,r2
8000b424:	e0 a0 1a 6c 	rcall	8000e8fc <_free_r>
8000b428:	04 9c       	mov	r12,r2
8000b42a:	c2 a8       	rjmp	8000b47e <_realloc_r+0x2b6>
8000b42c:	00 93       	mov	r3,r0
8000b42e:	02 97       	mov	r7,r1
8000b430:	e6 06 01 09 	sub	r9,r3,r6
8000b434:	6e 18       	ld.w	r8,r7[0x4]
8000b436:	58 f9       	cp.w	r9,15
8000b438:	e0 88 00 16 	brls	8000b464 <_realloc_r+0x29c>
8000b43c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b440:	ed e8 10 08 	or	r8,r6,r8
8000b444:	8f 18       	st.w	r7[0x4],r8
8000b446:	12 98       	mov	r8,r9
8000b448:	a1 a8       	sbr	r8,0x0
8000b44a:	ee 06 00 0b 	add	r11,r7,r6
8000b44e:	f6 09 00 09 	add	r9,r11,r9
8000b452:	97 18       	st.w	r11[0x4],r8
8000b454:	72 18       	ld.w	r8,r9[0x4]
8000b456:	a1 a8       	sbr	r8,0x0
8000b458:	2f 8b       	sub	r11,-8
8000b45a:	93 18       	st.w	r9[0x4],r8
8000b45c:	04 9c       	mov	r12,r2
8000b45e:	e0 a0 1a 4f 	rcall	8000e8fc <_free_r>
8000b462:	c0 b8       	rjmp	8000b478 <_realloc_r+0x2b0>
8000b464:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b468:	e7 e8 10 08 	or	r8,r3,r8
8000b46c:	8f 18       	st.w	r7[0x4],r8
8000b46e:	ee 03 00 03 	add	r3,r7,r3
8000b472:	66 18       	ld.w	r8,r3[0x4]
8000b474:	a1 a8       	sbr	r8,0x0
8000b476:	87 18       	st.w	r3[0x4],r8
8000b478:	04 9c       	mov	r12,r2
8000b47a:	ee c5 ff f8 	sub	r5,r7,-8
8000b47e:	fe b0 e7 b5 	rcall	800083e8 <__malloc_unlock>
8000b482:	0a 9c       	mov	r12,r5
8000b484:	2f fd       	sub	sp,-4
8000b486:	d8 32       	popm	r0-r7,pc

8000b488 <_sbrk_r>:
8000b488:	d4 21       	pushm	r4-r7,lr
8000b48a:	30 08       	mov	r8,0
8000b48c:	18 97       	mov	r7,r12
8000b48e:	e0 66 53 20 	mov	r6,21280
8000b492:	16 9c       	mov	r12,r11
8000b494:	8d 08       	st.w	r6[0x0],r8
8000b496:	c9 1c       	rcall	8000b5b8 <_sbrk>
8000b498:	5b fc       	cp.w	r12,-1
8000b49a:	c0 51       	brne	8000b4a4 <_sbrk_r+0x1c>
8000b49c:	6c 08       	ld.w	r8,r6[0x0]
8000b49e:	58 08       	cp.w	r8,0
8000b4a0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b4a4:	d8 22       	popm	r4-r7,pc
8000b4a6:	d7 03       	nop

8000b4a8 <sprintf>:
8000b4a8:	d4 01       	pushm	lr
8000b4aa:	21 7d       	sub	sp,92
8000b4ac:	e0 68 ff ff 	mov	r8,65535
8000b4b0:	ea 18 7f ff 	orh	r8,0x7fff
8000b4b4:	50 58       	stdsp	sp[0x14],r8
8000b4b6:	50 28       	stdsp	sp[0x8],r8
8000b4b8:	e0 68 02 08 	mov	r8,520
8000b4bc:	ba 68       	st.h	sp[0xc],r8
8000b4be:	3f f8       	mov	r8,-1
8000b4c0:	ba 78       	st.h	sp[0xe],r8
8000b4c2:	e0 68 0a 50 	mov	r8,2640
8000b4c6:	50 4c       	stdsp	sp[0x10],r12
8000b4c8:	16 9a       	mov	r10,r11
8000b4ca:	50 0c       	stdsp	sp[0x0],r12
8000b4cc:	fa c9 ff a0 	sub	r9,sp,-96
8000b4d0:	70 0c       	ld.w	r12,r8[0x0]
8000b4d2:	1a 9b       	mov	r11,sp
8000b4d4:	e0 a0 02 26 	rcall	8000b920 <_vfprintf_r>
8000b4d8:	30 09       	mov	r9,0
8000b4da:	40 08       	lddsp	r8,sp[0x0]
8000b4dc:	b0 89       	st.b	r8[0x0],r9
8000b4de:	2e 9d       	sub	sp,-92
8000b4e0:	d8 02       	popm	pc
8000b4e2:	d7 03       	nop

8000b4e4 <strlen>:
8000b4e4:	30 09       	mov	r9,0
8000b4e6:	18 98       	mov	r8,r12
8000b4e8:	c0 28       	rjmp	8000b4ec <strlen+0x8>
8000b4ea:	2f f8       	sub	r8,-1
8000b4ec:	11 8a       	ld.ub	r10,r8[0x0]
8000b4ee:	f2 0a 18 00 	cp.b	r10,r9
8000b4f2:	cf c1       	brne	8000b4ea <strlen+0x6>
8000b4f4:	f0 0c 01 0c 	sub	r12,r8,r12
8000b4f8:	5e fc       	retal	r12
8000b4fa:	d7 03       	nop

8000b4fc <strncpy>:
8000b4fc:	30 08       	mov	r8,0
8000b4fe:	10 3a       	cp.w	r10,r8
8000b500:	5e 0c       	reteq	r12
8000b502:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b506:	f8 08 0b 09 	st.b	r12[r8],r9
8000b50a:	2f f8       	sub	r8,-1
8000b50c:	58 09       	cp.w	r9,0
8000b50e:	cf 81       	brne	8000b4fe <strncpy+0x2>
8000b510:	10 3a       	cp.w	r10,r8
8000b512:	5e 0c       	reteq	r12
8000b514:	f8 08 0b 09 	st.b	r12[r8],r9
8000b518:	2f f8       	sub	r8,-1
8000b51a:	cf bb       	rjmp	8000b510 <strncpy+0x14>

8000b51c <_close>:
8000b51c:	30 28       	mov	r8,2
8000b51e:	d6 73       	breakpoint
8000b520:	3f fc       	mov	r12,-1
8000b522:	35 8b       	mov	r11,88
8000b524:	58 0c       	cp.w	r12,0
8000b526:	5e 4c       	retge	r12
8000b528:	e0 6a 53 20 	mov	r10,21280
8000b52c:	95 0b       	st.w	r10[0x0],r11
8000b52e:	5e fc       	retal	r12

8000b530 <_lseek>:
8000b530:	30 58       	mov	r8,5
8000b532:	d6 73       	breakpoint
8000b534:	3f fc       	mov	r12,-1
8000b536:	35 8b       	mov	r11,88
8000b538:	58 0c       	cp.w	r12,0
8000b53a:	5e 4c       	retge	r12
8000b53c:	e0 6a 53 20 	mov	r10,21280
8000b540:	95 0b       	st.w	r10[0x0],r11
8000b542:	5e fc       	retal	r12

8000b544 <isatty>:
8000b544:	30 b8       	mov	r8,11
8000b546:	d6 73       	breakpoint
8000b548:	3f fc       	mov	r12,-1
8000b54a:	35 8b       	mov	r11,88
8000b54c:	58 0c       	cp.w	r12,0
8000b54e:	5e 4c       	retge	r12
8000b550:	e0 6a 53 20 	mov	r10,21280
8000b554:	95 0b       	st.w	r10[0x0],r11
8000b556:	5e fc       	retal	r12

8000b558 <_fstat_host>:
8000b558:	30 98       	mov	r8,9
8000b55a:	d6 73       	breakpoint
8000b55c:	3f fc       	mov	r12,-1
8000b55e:	35 8b       	mov	r11,88
8000b560:	58 0c       	cp.w	r12,0
8000b562:	5e 4c       	retge	r12
8000b564:	e0 6a 53 20 	mov	r10,21280
8000b568:	95 0b       	st.w	r10[0x0],r11
8000b56a:	5e fc       	retal	r12

8000b56c <_fstat>:
8000b56c:	d4 21       	pushm	r4-r7,lr
8000b56e:	21 0d       	sub	sp,64
8000b570:	16 97       	mov	r7,r11
8000b572:	1a 9b       	mov	r11,sp
8000b574:	cf 2f       	rcall	8000b558 <_fstat_host>
8000b576:	c0 34       	brge	8000b57c <_fstat+0x10>
8000b578:	3f fc       	mov	r12,-1
8000b57a:	c1 c8       	rjmp	8000b5b2 <_fstat+0x46>
8000b57c:	40 08       	lddsp	r8,sp[0x0]
8000b57e:	ae 08       	st.h	r7[0x0],r8
8000b580:	40 18       	lddsp	r8,sp[0x4]
8000b582:	ae 18       	st.h	r7[0x2],r8
8000b584:	40 28       	lddsp	r8,sp[0x8]
8000b586:	8f 18       	st.w	r7[0x4],r8
8000b588:	40 38       	lddsp	r8,sp[0xc]
8000b58a:	ae 48       	st.h	r7[0x8],r8
8000b58c:	40 48       	lddsp	r8,sp[0x10]
8000b58e:	ae 58       	st.h	r7[0xa],r8
8000b590:	40 58       	lddsp	r8,sp[0x14]
8000b592:	ae 68       	st.h	r7[0xc],r8
8000b594:	40 68       	lddsp	r8,sp[0x18]
8000b596:	ae 78       	st.h	r7[0xe],r8
8000b598:	40 88       	lddsp	r8,sp[0x20]
8000b59a:	8f 48       	st.w	r7[0x10],r8
8000b59c:	40 a8       	lddsp	r8,sp[0x28]
8000b59e:	8f b8       	st.w	r7[0x2c],r8
8000b5a0:	40 c8       	lddsp	r8,sp[0x30]
8000b5a2:	8f c8       	st.w	r7[0x30],r8
8000b5a4:	40 d8       	lddsp	r8,sp[0x34]
8000b5a6:	8f 58       	st.w	r7[0x14],r8
8000b5a8:	40 e8       	lddsp	r8,sp[0x38]
8000b5aa:	30 0c       	mov	r12,0
8000b5ac:	8f 78       	st.w	r7[0x1c],r8
8000b5ae:	40 f8       	lddsp	r8,sp[0x3c]
8000b5b0:	8f 98       	st.w	r7[0x24],r8
8000b5b2:	2f 0d       	sub	sp,-64
8000b5b4:	d8 22       	popm	r4-r7,pc
8000b5b6:	d7 03       	nop

8000b5b8 <_sbrk>:
8000b5b8:	d4 01       	pushm	lr
8000b5ba:	e0 68 0d 98 	mov	r8,3480
8000b5be:	70 09       	ld.w	r9,r8[0x0]
8000b5c0:	58 09       	cp.w	r9,0
8000b5c2:	c0 41       	brne	8000b5ca <_sbrk+0x12>
8000b5c4:	e0 69 53 28 	mov	r9,21288
8000b5c8:	91 09       	st.w	r8[0x0],r9
8000b5ca:	e0 69 0d 98 	mov	r9,3480
8000b5ce:	e0 7a 70 00 	mov	r10,94208
8000b5d2:	72 08       	ld.w	r8,r9[0x0]
8000b5d4:	f0 0c 00 0c 	add	r12,r8,r12
8000b5d8:	14 3c       	cp.w	r12,r10
8000b5da:	e0 8b 00 04 	brhi	8000b5e2 <_sbrk+0x2a>
8000b5de:	93 0c       	st.w	r9[0x0],r12
8000b5e0:	c0 68       	rjmp	8000b5ec <_sbrk+0x34>
8000b5e2:	e0 a0 18 15 	rcall	8000e60c <__errno>
8000b5e6:	30 c8       	mov	r8,12
8000b5e8:	99 08       	st.w	r12[0x0],r8
8000b5ea:	3f f8       	mov	r8,-1
8000b5ec:	10 9c       	mov	r12,r8
8000b5ee:	d8 02       	popm	pc

8000b5f0 <get_arg>:
8000b5f0:	d4 31       	pushm	r0-r7,lr
8000b5f2:	20 8d       	sub	sp,32
8000b5f4:	fa c4 ff bc 	sub	r4,sp,-68
8000b5f8:	50 4b       	stdsp	sp[0x10],r11
8000b5fa:	68 2e       	ld.w	lr,r4[0x8]
8000b5fc:	50 58       	stdsp	sp[0x14],r8
8000b5fe:	12 96       	mov	r6,r9
8000b600:	7c 0b       	ld.w	r11,lr[0x0]
8000b602:	70 05       	ld.w	r5,r8[0x0]
8000b604:	50 6e       	stdsp	sp[0x18],lr
8000b606:	58 0b       	cp.w	r11,0
8000b608:	f4 0b 17 00 	moveq	r11,r10
8000b60c:	68 03       	ld.w	r3,r4[0x0]
8000b60e:	68 11       	ld.w	r1,r4[0x4]
8000b610:	40 49       	lddsp	r9,sp[0x10]
8000b612:	30 08       	mov	r8,0
8000b614:	c2 89       	rjmp	8000b864 <get_arg+0x274>
8000b616:	2f fb       	sub	r11,-1
8000b618:	32 5c       	mov	r12,37
8000b61a:	17 8a       	ld.ub	r10,r11[0x0]
8000b61c:	f8 0a 18 00 	cp.b	r10,r12
8000b620:	5f 1e       	srne	lr
8000b622:	f0 0a 18 00 	cp.b	r10,r8
8000b626:	5f 1c       	srne	r12
8000b628:	fd ec 00 0c 	and	r12,lr,r12
8000b62c:	f0 0c 18 00 	cp.b	r12,r8
8000b630:	cf 31       	brne	8000b616 <get_arg+0x26>
8000b632:	58 0a       	cp.w	r10,0
8000b634:	e0 80 01 25 	breq	8000b87e <get_arg+0x28e>
8000b638:	30 0c       	mov	r12,0
8000b63a:	3f fa       	mov	r10,-1
8000b63c:	18 90       	mov	r0,r12
8000b63e:	50 3a       	stdsp	sp[0xc],r10
8000b640:	18 94       	mov	r4,r12
8000b642:	18 92       	mov	r2,r12
8000b644:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000b648:	16 97       	mov	r7,r11
8000b64a:	50 7c       	stdsp	sp[0x1c],r12
8000b64c:	fe cc a7 64 	sub	r12,pc,-22684
8000b650:	0f 3a       	ld.ub	r10,r7++
8000b652:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000b656:	40 7c       	lddsp	r12,sp[0x1c]
8000b658:	1c 0c       	add	r12,lr
8000b65a:	fe ce a8 3a 	sub	lr,pc,-22470
8000b65e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000b662:	20 1e       	sub	lr,1
8000b664:	50 0e       	stdsp	sp[0x0],lr
8000b666:	fe ce a8 b2 	sub	lr,pc,-22350
8000b66a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000b66e:	50 7c       	stdsp	sp[0x1c],r12
8000b670:	40 0c       	lddsp	r12,sp[0x0]
8000b672:	58 7c       	cp.w	r12,7
8000b674:	e0 8b 00 f1 	brhi	8000b856 <get_arg+0x266>
8000b678:	fe ce aa 64 	sub	lr,pc,-21916
8000b67c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000b680:	36 8b       	mov	r11,104
8000b682:	f6 0a 18 00 	cp.b	r10,r11
8000b686:	e0 80 00 e8 	breq	8000b856 <get_arg+0x266>
8000b68a:	37 1b       	mov	r11,113
8000b68c:	f6 0a 18 00 	cp.b	r10,r11
8000b690:	c0 70       	breq	8000b69e <get_arg+0xae>
8000b692:	34 cb       	mov	r11,76
8000b694:	f6 0a 18 00 	cp.b	r10,r11
8000b698:	c0 51       	brne	8000b6a2 <get_arg+0xb2>
8000b69a:	a3 b4       	sbr	r4,0x3
8000b69c:	cd d8       	rjmp	8000b856 <get_arg+0x266>
8000b69e:	a5 b4       	sbr	r4,0x5
8000b6a0:	cd b8       	rjmp	8000b856 <get_arg+0x266>
8000b6a2:	08 9a       	mov	r10,r4
8000b6a4:	0e 9b       	mov	r11,r7
8000b6a6:	a5 aa       	sbr	r10,0x4
8000b6a8:	17 3c       	ld.ub	r12,r11++
8000b6aa:	a5 b4       	sbr	r4,0x5
8000b6ac:	36 ce       	mov	lr,108
8000b6ae:	fc 0c 18 00 	cp.b	r12,lr
8000b6b2:	e0 80 00 d3 	breq	8000b858 <get_arg+0x268>
8000b6b6:	14 94       	mov	r4,r10
8000b6b8:	cc f8       	rjmp	8000b856 <get_arg+0x266>
8000b6ba:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000b6be:	36 7c       	mov	r12,103
8000b6c0:	f8 0a 18 00 	cp.b	r10,r12
8000b6c4:	e0 8b 00 27 	brhi	8000b712 <get_arg+0x122>
8000b6c8:	36 5b       	mov	r11,101
8000b6ca:	f6 0a 18 00 	cp.b	r10,r11
8000b6ce:	c4 82       	brcc	8000b75e <get_arg+0x16e>
8000b6d0:	34 fb       	mov	r11,79
8000b6d2:	f6 0a 18 00 	cp.b	r10,r11
8000b6d6:	c4 80       	breq	8000b766 <get_arg+0x176>
8000b6d8:	e0 8b 00 0c 	brhi	8000b6f0 <get_arg+0x100>
8000b6dc:	34 5b       	mov	r11,69
8000b6de:	f6 0a 18 00 	cp.b	r10,r11
8000b6e2:	c3 e0       	breq	8000b75e <get_arg+0x16e>
8000b6e4:	34 7b       	mov	r11,71
8000b6e6:	f6 0a 18 00 	cp.b	r10,r11
8000b6ea:	c3 a0       	breq	8000b75e <get_arg+0x16e>
8000b6ec:	34 4b       	mov	r11,68
8000b6ee:	c0 88       	rjmp	8000b6fe <get_arg+0x10e>
8000b6f0:	35 8b       	mov	r11,88
8000b6f2:	f6 0a 18 00 	cp.b	r10,r11
8000b6f6:	c2 c0       	breq	8000b74e <get_arg+0x15e>
8000b6f8:	e0 8b 00 07 	brhi	8000b706 <get_arg+0x116>
8000b6fc:	35 5b       	mov	r11,85
8000b6fe:	f6 0a 18 00 	cp.b	r10,r11
8000b702:	c3 51       	brne	8000b76c <get_arg+0x17c>
8000b704:	c3 18       	rjmp	8000b766 <get_arg+0x176>
8000b706:	36 3b       	mov	r11,99
8000b708:	f6 0a 18 00 	cp.b	r10,r11
8000b70c:	c2 f0       	breq	8000b76a <get_arg+0x17a>
8000b70e:	36 4b       	mov	r11,100
8000b710:	c0 e8       	rjmp	8000b72c <get_arg+0x13c>
8000b712:	37 0b       	mov	r11,112
8000b714:	f6 0a 18 00 	cp.b	r10,r11
8000b718:	c2 50       	breq	8000b762 <get_arg+0x172>
8000b71a:	e0 8b 00 0d 	brhi	8000b734 <get_arg+0x144>
8000b71e:	36 eb       	mov	r11,110
8000b720:	f6 0a 18 00 	cp.b	r10,r11
8000b724:	c1 f0       	breq	8000b762 <get_arg+0x172>
8000b726:	e0 8b 00 14 	brhi	8000b74e <get_arg+0x15e>
8000b72a:	36 9b       	mov	r11,105
8000b72c:	f6 0a 18 00 	cp.b	r10,r11
8000b730:	c1 e1       	brne	8000b76c <get_arg+0x17c>
8000b732:	c0 e8       	rjmp	8000b74e <get_arg+0x15e>
8000b734:	37 5b       	mov	r11,117
8000b736:	f6 0a 18 00 	cp.b	r10,r11
8000b73a:	c0 a0       	breq	8000b74e <get_arg+0x15e>
8000b73c:	37 8b       	mov	r11,120
8000b73e:	f6 0a 18 00 	cp.b	r10,r11
8000b742:	c0 60       	breq	8000b74e <get_arg+0x15e>
8000b744:	37 3b       	mov	r11,115
8000b746:	f6 0a 18 00 	cp.b	r10,r11
8000b74a:	c1 11       	brne	8000b76c <get_arg+0x17c>
8000b74c:	c0 b8       	rjmp	8000b762 <get_arg+0x172>
8000b74e:	ed b4 00 04 	bld	r4,0x4
8000b752:	c0 a0       	breq	8000b766 <get_arg+0x176>
8000b754:	ed b4 00 05 	bld	r4,0x5
8000b758:	c0 91       	brne	8000b76a <get_arg+0x17a>
8000b75a:	30 20       	mov	r0,2
8000b75c:	c0 88       	rjmp	8000b76c <get_arg+0x17c>
8000b75e:	30 40       	mov	r0,4
8000b760:	c0 68       	rjmp	8000b76c <get_arg+0x17c>
8000b762:	30 30       	mov	r0,3
8000b764:	c0 48       	rjmp	8000b76c <get_arg+0x17c>
8000b766:	30 10       	mov	r0,1
8000b768:	c0 28       	rjmp	8000b76c <get_arg+0x17c>
8000b76a:	30 00       	mov	r0,0
8000b76c:	40 3b       	lddsp	r11,sp[0xc]
8000b76e:	5b fb       	cp.w	r11,-1
8000b770:	c0 40       	breq	8000b778 <get_arg+0x188>
8000b772:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000b776:	c7 08       	rjmp	8000b856 <get_arg+0x266>
8000b778:	58 60       	cp.w	r0,6
8000b77a:	e0 8b 00 6e 	brhi	8000b856 <get_arg+0x266>
8000b77e:	6c 0a       	ld.w	r10,r6[0x0]
8000b780:	ea cc ff ff 	sub	r12,r5,-1
8000b784:	fe ce ab 50 	sub	lr,pc,-21680
8000b788:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000b78c:	f4 cb ff f8 	sub	r11,r10,-8
8000b790:	8d 0b       	st.w	r6[0x0],r11
8000b792:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b796:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b79a:	c0 f8       	rjmp	8000b7b8 <get_arg+0x1c8>
8000b79c:	f4 cb ff fc 	sub	r11,r10,-4
8000b7a0:	8d 0b       	st.w	r6[0x0],r11
8000b7a2:	74 0a       	ld.w	r10,r10[0x0]
8000b7a4:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b7a8:	c0 88       	rjmp	8000b7b8 <get_arg+0x1c8>
8000b7aa:	f4 cb ff f8 	sub	r11,r10,-8
8000b7ae:	8d 0b       	st.w	r6[0x0],r11
8000b7b0:	f4 ea 00 00 	ld.d	r10,r10[0]
8000b7b4:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000b7b8:	0e 9b       	mov	r11,r7
8000b7ba:	18 95       	mov	r5,r12
8000b7bc:	c4 e8       	rjmp	8000b858 <get_arg+0x268>
8000b7be:	62 0a       	ld.w	r10,r1[0x0]
8000b7c0:	5b fa       	cp.w	r10,-1
8000b7c2:	c0 b1       	brne	8000b7d8 <get_arg+0x1e8>
8000b7c4:	50 19       	stdsp	sp[0x4],r9
8000b7c6:	50 28       	stdsp	sp[0x8],r8
8000b7c8:	e0 6a 00 80 	mov	r10,128
8000b7cc:	30 0b       	mov	r11,0
8000b7ce:	02 9c       	mov	r12,r1
8000b7d0:	fe b0 fc f5 	rcall	8000b1ba <memset>
8000b7d4:	40 28       	lddsp	r8,sp[0x8]
8000b7d6:	40 19       	lddsp	r9,sp[0x4]
8000b7d8:	e4 cc 00 01 	sub	r12,r2,1
8000b7dc:	0e 9b       	mov	r11,r7
8000b7de:	50 3c       	stdsp	sp[0xc],r12
8000b7e0:	f2 0c 0c 49 	max	r9,r9,r12
8000b7e4:	c3 a8       	rjmp	8000b858 <get_arg+0x268>
8000b7e6:	62 0a       	ld.w	r10,r1[0x0]
8000b7e8:	5b fa       	cp.w	r10,-1
8000b7ea:	c0 b1       	brne	8000b800 <get_arg+0x210>
8000b7ec:	50 19       	stdsp	sp[0x4],r9
8000b7ee:	50 28       	stdsp	sp[0x8],r8
8000b7f0:	e0 6a 00 80 	mov	r10,128
8000b7f4:	30 0b       	mov	r11,0
8000b7f6:	02 9c       	mov	r12,r1
8000b7f8:	fe b0 fc e1 	rcall	8000b1ba <memset>
8000b7fc:	40 28       	lddsp	r8,sp[0x8]
8000b7fe:	40 19       	lddsp	r9,sp[0x4]
8000b800:	20 12       	sub	r2,1
8000b802:	30 0a       	mov	r10,0
8000b804:	0e 9b       	mov	r11,r7
8000b806:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000b80a:	f2 02 0c 49 	max	r9,r9,r2
8000b80e:	c2 58       	rjmp	8000b858 <get_arg+0x268>
8000b810:	16 97       	mov	r7,r11
8000b812:	6c 0a       	ld.w	r10,r6[0x0]
8000b814:	f4 cb ff fc 	sub	r11,r10,-4
8000b818:	8d 0b       	st.w	r6[0x0],r11
8000b81a:	74 0a       	ld.w	r10,r10[0x0]
8000b81c:	0e 9b       	mov	r11,r7
8000b81e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000b822:	2f f5       	sub	r5,-1
8000b824:	c1 a8       	rjmp	8000b858 <get_arg+0x268>
8000b826:	f4 c2 00 30 	sub	r2,r10,48
8000b82a:	c0 68       	rjmp	8000b836 <get_arg+0x246>
8000b82c:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000b830:	2f f7       	sub	r7,-1
8000b832:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000b836:	0f 8a       	ld.ub	r10,r7[0x0]
8000b838:	58 0a       	cp.w	r10,0
8000b83a:	c0 e0       	breq	8000b856 <get_arg+0x266>
8000b83c:	23 0a       	sub	r10,48
8000b83e:	58 9a       	cp.w	r10,9
8000b840:	fe 98 ff f6 	brls	8000b82c <get_arg+0x23c>
8000b844:	c0 98       	rjmp	8000b856 <get_arg+0x266>
8000b846:	2f f7       	sub	r7,-1
8000b848:	0f 8a       	ld.ub	r10,r7[0x0]
8000b84a:	58 0a       	cp.w	r10,0
8000b84c:	c0 50       	breq	8000b856 <get_arg+0x266>
8000b84e:	23 0a       	sub	r10,48
8000b850:	58 9a       	cp.w	r10,9
8000b852:	fe 98 ff fa 	brls	8000b846 <get_arg+0x256>
8000b856:	0e 9b       	mov	r11,r7
8000b858:	40 7c       	lddsp	r12,sp[0x1c]
8000b85a:	30 ba       	mov	r10,11
8000b85c:	f4 0c 18 00 	cp.b	r12,r10
8000b860:	fe 91 fe f2 	brne	8000b644 <get_arg+0x54>
8000b864:	40 42       	lddsp	r2,sp[0x10]
8000b866:	17 8c       	ld.ub	r12,r11[0x0]
8000b868:	0a 32       	cp.w	r2,r5
8000b86a:	5f 4a       	srge	r10
8000b86c:	f0 0c 18 00 	cp.b	r12,r8
8000b870:	5f 1c       	srne	r12
8000b872:	f9 ea 00 0a 	and	r10,r12,r10
8000b876:	f0 0a 18 00 	cp.b	r10,r8
8000b87a:	fe 91 fe cf 	brne	8000b618 <get_arg+0x28>
8000b87e:	30 08       	mov	r8,0
8000b880:	40 4e       	lddsp	lr,sp[0x10]
8000b882:	17 8a       	ld.ub	r10,r11[0x0]
8000b884:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000b888:	f0 0a 18 00 	cp.b	r10,r8
8000b88c:	fc 09 17 10 	movne	r9,lr
8000b890:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000b894:	06 9e       	mov	lr,r3
8000b896:	c2 a8       	rjmp	8000b8ea <get_arg+0x2fa>
8000b898:	62 0a       	ld.w	r10,r1[0x0]
8000b89a:	58 3a       	cp.w	r10,3
8000b89c:	c1 e0       	breq	8000b8d8 <get_arg+0x2e8>
8000b89e:	e0 89 00 07 	brgt	8000b8ac <get_arg+0x2bc>
8000b8a2:	58 1a       	cp.w	r10,1
8000b8a4:	c1 a0       	breq	8000b8d8 <get_arg+0x2e8>
8000b8a6:	58 2a       	cp.w	r10,2
8000b8a8:	c1 81       	brne	8000b8d8 <get_arg+0x2e8>
8000b8aa:	c0 58       	rjmp	8000b8b4 <get_arg+0x2c4>
8000b8ac:	58 5a       	cp.w	r10,5
8000b8ae:	c0 c0       	breq	8000b8c6 <get_arg+0x2d6>
8000b8b0:	c0 b5       	brlt	8000b8c6 <get_arg+0x2d6>
8000b8b2:	c1 38       	rjmp	8000b8d8 <get_arg+0x2e8>
8000b8b4:	6c 0a       	ld.w	r10,r6[0x0]
8000b8b6:	f4 cc ff f8 	sub	r12,r10,-8
8000b8ba:	8d 0c       	st.w	r6[0x0],r12
8000b8bc:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b8c0:	f0 e3 00 00 	st.d	r8[0],r2
8000b8c4:	c1 08       	rjmp	8000b8e4 <get_arg+0x2f4>
8000b8c6:	6c 0a       	ld.w	r10,r6[0x0]
8000b8c8:	f4 cc ff f8 	sub	r12,r10,-8
8000b8cc:	8d 0c       	st.w	r6[0x0],r12
8000b8ce:	f4 e2 00 00 	ld.d	r2,r10[0]
8000b8d2:	f0 e3 00 00 	st.d	r8[0],r2
8000b8d6:	c0 78       	rjmp	8000b8e4 <get_arg+0x2f4>
8000b8d8:	6c 0a       	ld.w	r10,r6[0x0]
8000b8da:	f4 cc ff fc 	sub	r12,r10,-4
8000b8de:	8d 0c       	st.w	r6[0x0],r12
8000b8e0:	74 0a       	ld.w	r10,r10[0x0]
8000b8e2:	91 0a       	st.w	r8[0x0],r10
8000b8e4:	2f f5       	sub	r5,-1
8000b8e6:	2f 88       	sub	r8,-8
8000b8e8:	2f c1       	sub	r1,-4
8000b8ea:	12 35       	cp.w	r5,r9
8000b8ec:	fe 9a ff d6 	brle	8000b898 <get_arg+0x2a8>
8000b8f0:	1c 93       	mov	r3,lr
8000b8f2:	40 52       	lddsp	r2,sp[0x14]
8000b8f4:	40 6e       	lddsp	lr,sp[0x18]
8000b8f6:	85 05       	st.w	r2[0x0],r5
8000b8f8:	9d 0b       	st.w	lr[0x0],r11
8000b8fa:	40 4b       	lddsp	r11,sp[0x10]
8000b8fc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000b900:	2f 8d       	sub	sp,-32
8000b902:	d8 32       	popm	r0-r7,pc

8000b904 <__sprint_r>:
8000b904:	d4 21       	pushm	r4-r7,lr
8000b906:	14 97       	mov	r7,r10
8000b908:	74 28       	ld.w	r8,r10[0x8]
8000b90a:	58 08       	cp.w	r8,0
8000b90c:	c0 41       	brne	8000b914 <__sprint_r+0x10>
8000b90e:	95 18       	st.w	r10[0x4],r8
8000b910:	10 9c       	mov	r12,r8
8000b912:	d8 22       	popm	r4-r7,pc
8000b914:	e0 a0 18 ba 	rcall	8000ea88 <__sfvwrite_r>
8000b918:	30 08       	mov	r8,0
8000b91a:	8f 18       	st.w	r7[0x4],r8
8000b91c:	8f 28       	st.w	r7[0x8],r8
8000b91e:	d8 22       	popm	r4-r7,pc

8000b920 <_vfprintf_r>:
8000b920:	d4 31       	pushm	r0-r7,lr
8000b922:	fa cd 06 bc 	sub	sp,sp,1724
8000b926:	51 09       	stdsp	sp[0x40],r9
8000b928:	16 91       	mov	r1,r11
8000b92a:	14 97       	mov	r7,r10
8000b92c:	18 95       	mov	r5,r12
8000b92e:	e0 a0 1a 1d 	rcall	8000ed68 <_localeconv_r>
8000b932:	78 0c       	ld.w	r12,r12[0x0]
8000b934:	50 cc       	stdsp	sp[0x30],r12
8000b936:	58 05       	cp.w	r5,0
8000b938:	c0 70       	breq	8000b946 <_vfprintf_r+0x26>
8000b93a:	6a 68       	ld.w	r8,r5[0x18]
8000b93c:	58 08       	cp.w	r8,0
8000b93e:	c0 41       	brne	8000b946 <_vfprintf_r+0x26>
8000b940:	0a 9c       	mov	r12,r5
8000b942:	e0 a0 17 43 	rcall	8000e7c8 <__sinit>
8000b946:	fe c8 a9 4e 	sub	r8,pc,-22194
8000b94a:	10 31       	cp.w	r1,r8
8000b94c:	c0 31       	brne	8000b952 <_vfprintf_r+0x32>
8000b94e:	6a 01       	ld.w	r1,r5[0x0]
8000b950:	c0 c8       	rjmp	8000b968 <_vfprintf_r+0x48>
8000b952:	fe c8 a9 3a 	sub	r8,pc,-22214
8000b956:	10 31       	cp.w	r1,r8
8000b958:	c0 31       	brne	8000b95e <_vfprintf_r+0x3e>
8000b95a:	6a 11       	ld.w	r1,r5[0x4]
8000b95c:	c0 68       	rjmp	8000b968 <_vfprintf_r+0x48>
8000b95e:	fe c8 a9 26 	sub	r8,pc,-22234
8000b962:	10 31       	cp.w	r1,r8
8000b964:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000b968:	82 68       	ld.sh	r8,r1[0xc]
8000b96a:	ed b8 00 03 	bld	r8,0x3
8000b96e:	c0 41       	brne	8000b976 <_vfprintf_r+0x56>
8000b970:	62 48       	ld.w	r8,r1[0x10]
8000b972:	58 08       	cp.w	r8,0
8000b974:	c0 71       	brne	8000b982 <_vfprintf_r+0x62>
8000b976:	02 9b       	mov	r11,r1
8000b978:	0a 9c       	mov	r12,r5
8000b97a:	e0 a0 0f 5d 	rcall	8000d834 <__swsetup_r>
8000b97e:	e0 81 0f 54 	brne	8000d826 <_vfprintf_r+0x1f06>
8000b982:	82 68       	ld.sh	r8,r1[0xc]
8000b984:	10 99       	mov	r9,r8
8000b986:	e2 19 00 1a 	andl	r9,0x1a,COH
8000b98a:	58 a9       	cp.w	r9,10
8000b98c:	c3 c1       	brne	8000ba04 <_vfprintf_r+0xe4>
8000b98e:	82 79       	ld.sh	r9,r1[0xe]
8000b990:	30 0a       	mov	r10,0
8000b992:	f4 09 19 00 	cp.h	r9,r10
8000b996:	c3 75       	brlt	8000ba04 <_vfprintf_r+0xe4>
8000b998:	a1 d8       	cbr	r8,0x1
8000b99a:	fb 58 05 d0 	st.h	sp[1488],r8
8000b99e:	62 88       	ld.w	r8,r1[0x20]
8000b9a0:	fb 48 05 e4 	st.w	sp[1508],r8
8000b9a4:	62 a8       	ld.w	r8,r1[0x28]
8000b9a6:	fb 48 05 ec 	st.w	sp[1516],r8
8000b9aa:	fa c8 ff bc 	sub	r8,sp,-68
8000b9ae:	fb 48 05 d4 	st.w	sp[1492],r8
8000b9b2:	fb 48 05 c4 	st.w	sp[1476],r8
8000b9b6:	e0 68 04 00 	mov	r8,1024
8000b9ba:	fb 48 05 d8 	st.w	sp[1496],r8
8000b9be:	fb 48 05 cc 	st.w	sp[1484],r8
8000b9c2:	30 08       	mov	r8,0
8000b9c4:	fb 59 05 d2 	st.h	sp[1490],r9
8000b9c8:	0e 9a       	mov	r10,r7
8000b9ca:	41 09       	lddsp	r9,sp[0x40]
8000b9cc:	fa c7 fa 3c 	sub	r7,sp,-1476
8000b9d0:	fb 48 05 dc 	st.w	sp[1500],r8
8000b9d4:	0a 9c       	mov	r12,r5
8000b9d6:	0e 9b       	mov	r11,r7
8000b9d8:	ca 4f       	rcall	8000b920 <_vfprintf_r>
8000b9da:	50 bc       	stdsp	sp[0x2c],r12
8000b9dc:	c0 95       	brlt	8000b9ee <_vfprintf_r+0xce>
8000b9de:	0e 9b       	mov	r11,r7
8000b9e0:	0a 9c       	mov	r12,r5
8000b9e2:	e0 a0 16 1b 	rcall	8000e618 <_fflush_r>
8000b9e6:	40 be       	lddsp	lr,sp[0x2c]
8000b9e8:	f9 be 01 ff 	movne	lr,-1
8000b9ec:	50 be       	stdsp	sp[0x2c],lr
8000b9ee:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000b9f2:	ed b8 00 06 	bld	r8,0x6
8000b9f6:	e0 81 0f 1a 	brne	8000d82a <_vfprintf_r+0x1f0a>
8000b9fa:	82 68       	ld.sh	r8,r1[0xc]
8000b9fc:	a7 a8       	sbr	r8,0x6
8000b9fe:	a2 68       	st.h	r1[0xc],r8
8000ba00:	e0 8f 0f 15 	bral	8000d82a <_vfprintf_r+0x1f0a>
8000ba04:	30 08       	mov	r8,0
8000ba06:	fb 48 06 b4 	st.w	sp[1716],r8
8000ba0a:	fb 48 06 90 	st.w	sp[1680],r8
8000ba0e:	fb 48 06 8c 	st.w	sp[1676],r8
8000ba12:	fb 48 06 b0 	st.w	sp[1712],r8
8000ba16:	30 08       	mov	r8,0
8000ba18:	30 09       	mov	r9,0
8000ba1a:	50 a7       	stdsp	sp[0x28],r7
8000ba1c:	50 78       	stdsp	sp[0x1c],r8
8000ba1e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ba22:	3f f8       	mov	r8,-1
8000ba24:	50 59       	stdsp	sp[0x14],r9
8000ba26:	fb 43 06 88 	st.w	sp[1672],r3
8000ba2a:	fb 48 05 44 	st.w	sp[1348],r8
8000ba2e:	12 9c       	mov	r12,r9
8000ba30:	50 69       	stdsp	sp[0x18],r9
8000ba32:	50 d9       	stdsp	sp[0x34],r9
8000ba34:	50 e9       	stdsp	sp[0x38],r9
8000ba36:	50 b9       	stdsp	sp[0x2c],r9
8000ba38:	12 97       	mov	r7,r9
8000ba3a:	0a 94       	mov	r4,r5
8000ba3c:	40 a2       	lddsp	r2,sp[0x28]
8000ba3e:	32 5a       	mov	r10,37
8000ba40:	30 08       	mov	r8,0
8000ba42:	c0 28       	rjmp	8000ba46 <_vfprintf_r+0x126>
8000ba44:	2f f2       	sub	r2,-1
8000ba46:	05 89       	ld.ub	r9,r2[0x0]
8000ba48:	f0 09 18 00 	cp.b	r9,r8
8000ba4c:	5f 1b       	srne	r11
8000ba4e:	f4 09 18 00 	cp.b	r9,r10
8000ba52:	5f 19       	srne	r9
8000ba54:	f3 eb 00 0b 	and	r11,r9,r11
8000ba58:	f0 0b 18 00 	cp.b	r11,r8
8000ba5c:	cf 41       	brne	8000ba44 <_vfprintf_r+0x124>
8000ba5e:	40 ab       	lddsp	r11,sp[0x28]
8000ba60:	e4 0b 01 06 	sub	r6,r2,r11
8000ba64:	c1 e0       	breq	8000baa0 <_vfprintf_r+0x180>
8000ba66:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ba6a:	0c 08       	add	r8,r6
8000ba6c:	87 0b       	st.w	r3[0x0],r11
8000ba6e:	fb 48 06 90 	st.w	sp[1680],r8
8000ba72:	87 16       	st.w	r3[0x4],r6
8000ba74:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ba78:	2f f8       	sub	r8,-1
8000ba7a:	fb 48 06 8c 	st.w	sp[1676],r8
8000ba7e:	58 78       	cp.w	r8,7
8000ba80:	e0 89 00 04 	brgt	8000ba88 <_vfprintf_r+0x168>
8000ba84:	2f 83       	sub	r3,-8
8000ba86:	c0 a8       	rjmp	8000ba9a <_vfprintf_r+0x17a>
8000ba88:	fa ca f9 78 	sub	r10,sp,-1672
8000ba8c:	02 9b       	mov	r11,r1
8000ba8e:	08 9c       	mov	r12,r4
8000ba90:	c3 af       	rcall	8000b904 <__sprint_r>
8000ba92:	e0 81 0e c6 	brne	8000d81e <_vfprintf_r+0x1efe>
8000ba96:	fa c3 f9 e0 	sub	r3,sp,-1568
8000ba9a:	40 ba       	lddsp	r10,sp[0x2c]
8000ba9c:	0c 0a       	add	r10,r6
8000ba9e:	50 ba       	stdsp	sp[0x2c],r10
8000baa0:	05 89       	ld.ub	r9,r2[0x0]
8000baa2:	30 08       	mov	r8,0
8000baa4:	f0 09 18 00 	cp.b	r9,r8
8000baa8:	e0 80 0e aa 	breq	8000d7fc <_vfprintf_r+0x1edc>
8000baac:	30 09       	mov	r9,0
8000baae:	fb 68 06 bb 	st.b	sp[1723],r8
8000bab2:	0e 96       	mov	r6,r7
8000bab4:	e4 c8 ff ff 	sub	r8,r2,-1
8000bab8:	3f fe       	mov	lr,-1
8000baba:	50 93       	stdsp	sp[0x24],r3
8000babc:	50 41       	stdsp	sp[0x10],r1
8000babe:	0e 93       	mov	r3,r7
8000bac0:	04 91       	mov	r1,r2
8000bac2:	50 89       	stdsp	sp[0x20],r9
8000bac4:	50 a8       	stdsp	sp[0x28],r8
8000bac6:	50 2e       	stdsp	sp[0x8],lr
8000bac8:	50 39       	stdsp	sp[0xc],r9
8000baca:	12 95       	mov	r5,r9
8000bacc:	12 90       	mov	r0,r9
8000bace:	10 97       	mov	r7,r8
8000bad0:	08 92       	mov	r2,r4
8000bad2:	c0 78       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bad4:	3f fc       	mov	r12,-1
8000bad6:	08 97       	mov	r7,r4
8000bad8:	50 2c       	stdsp	sp[0x8],r12
8000bada:	c0 38       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000badc:	30 0b       	mov	r11,0
8000bade:	50 3b       	stdsp	sp[0xc],r11
8000bae0:	0f 38       	ld.ub	r8,r7++
8000bae2:	c0 28       	rjmp	8000bae6 <_vfprintf_r+0x1c6>
8000bae4:	12 90       	mov	r0,r9
8000bae6:	f0 c9 00 20 	sub	r9,r8,32
8000baea:	e0 49 00 58 	cp.w	r9,88
8000baee:	e0 8b 0a 30 	brhi	8000cf4e <_vfprintf_r+0x162e>
8000baf2:	fe ca ae a2 	sub	r10,pc,-20830
8000baf6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000bafa:	50 a7       	stdsp	sp[0x28],r7
8000bafc:	50 80       	stdsp	sp[0x20],r0
8000bafe:	0c 97       	mov	r7,r6
8000bb00:	04 94       	mov	r4,r2
8000bb02:	06 96       	mov	r6,r3
8000bb04:	02 92       	mov	r2,r1
8000bb06:	fe c9 ac 7a 	sub	r9,pc,-21382
8000bb0a:	40 93       	lddsp	r3,sp[0x24]
8000bb0c:	10 90       	mov	r0,r8
8000bb0e:	40 41       	lddsp	r1,sp[0x10]
8000bb10:	50 d9       	stdsp	sp[0x34],r9
8000bb12:	e0 8f 08 8e 	bral	8000cc2e <_vfprintf_r+0x130e>
8000bb16:	30 08       	mov	r8,0
8000bb18:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000bb1c:	f0 09 18 00 	cp.b	r9,r8
8000bb20:	ce 01       	brne	8000bae0 <_vfprintf_r+0x1c0>
8000bb22:	32 08       	mov	r8,32
8000bb24:	c6 e8       	rjmp	8000bc00 <_vfprintf_r+0x2e0>
8000bb26:	a1 a5       	sbr	r5,0x0
8000bb28:	cd cb       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bb2a:	0f 89       	ld.ub	r9,r7[0x0]
8000bb2c:	f2 c8 00 30 	sub	r8,r9,48
8000bb30:	58 98       	cp.w	r8,9
8000bb32:	e0 8b 00 1d 	brhi	8000bb6c <_vfprintf_r+0x24c>
8000bb36:	ee c8 ff ff 	sub	r8,r7,-1
8000bb3a:	30 0b       	mov	r11,0
8000bb3c:	23 09       	sub	r9,48
8000bb3e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000bb42:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000bb46:	11 39       	ld.ub	r9,r8++
8000bb48:	f2 ca 00 30 	sub	r10,r9,48
8000bb4c:	58 9a       	cp.w	r10,9
8000bb4e:	fe 98 ff f7 	brls	8000bb3c <_vfprintf_r+0x21c>
8000bb52:	e0 49 00 24 	cp.w	r9,36
8000bb56:	cc 31       	brne	8000badc <_vfprintf_r+0x1bc>
8000bb58:	e0 4b 00 20 	cp.w	r11,32
8000bb5c:	e0 89 0e 60 	brgt	8000d81c <_vfprintf_r+0x1efc>
8000bb60:	20 1b       	sub	r11,1
8000bb62:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000bb66:	12 3b       	cp.w	r11,r9
8000bb68:	c0 95       	brlt	8000bb7a <_vfprintf_r+0x25a>
8000bb6a:	c1 08       	rjmp	8000bb8a <_vfprintf_r+0x26a>
8000bb6c:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000bb70:	ec ca ff ff 	sub	r10,r6,-1
8000bb74:	12 36       	cp.w	r6,r9
8000bb76:	c1 f5       	brlt	8000bbb4 <_vfprintf_r+0x294>
8000bb78:	c2 68       	rjmp	8000bbc4 <_vfprintf_r+0x2a4>
8000bb7a:	fa ce f9 44 	sub	lr,sp,-1724
8000bb7e:	10 97       	mov	r7,r8
8000bb80:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000bb84:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000bb88:	c3 58       	rjmp	8000bbf2 <_vfprintf_r+0x2d2>
8000bb8a:	10 97       	mov	r7,r8
8000bb8c:	fa c8 f9 50 	sub	r8,sp,-1712
8000bb90:	1a d8       	st.w	--sp,r8
8000bb92:	fa c8 fa b8 	sub	r8,sp,-1352
8000bb96:	1a d8       	st.w	--sp,r8
8000bb98:	fa c8 fb b4 	sub	r8,sp,-1100
8000bb9c:	02 9a       	mov	r10,r1
8000bb9e:	1a d8       	st.w	--sp,r8
8000bba0:	04 9c       	mov	r12,r2
8000bba2:	fa c8 f9 40 	sub	r8,sp,-1728
8000bba6:	fa c9 ff b4 	sub	r9,sp,-76
8000bbaa:	fe b0 fd 23 	rcall	8000b5f0 <get_arg>
8000bbae:	2f dd       	sub	sp,-12
8000bbb0:	78 00       	ld.w	r0,r12[0x0]
8000bbb2:	c2 08       	rjmp	8000bbf2 <_vfprintf_r+0x2d2>
8000bbb4:	fa cc f9 44 	sub	r12,sp,-1724
8000bbb8:	14 96       	mov	r6,r10
8000bbba:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000bbbe:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000bbc2:	c1 88       	rjmp	8000bbf2 <_vfprintf_r+0x2d2>
8000bbc4:	41 08       	lddsp	r8,sp[0x40]
8000bbc6:	59 f9       	cp.w	r9,31
8000bbc8:	e0 89 00 11 	brgt	8000bbea <_vfprintf_r+0x2ca>
8000bbcc:	f0 cb ff fc 	sub	r11,r8,-4
8000bbd0:	51 0b       	stdsp	sp[0x40],r11
8000bbd2:	70 00       	ld.w	r0,r8[0x0]
8000bbd4:	fa cb f9 44 	sub	r11,sp,-1724
8000bbd8:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000bbdc:	f1 40 fd 88 	st.w	r8[-632],r0
8000bbe0:	2f f9       	sub	r9,-1
8000bbe2:	14 96       	mov	r6,r10
8000bbe4:	fb 49 06 b4 	st.w	sp[1716],r9
8000bbe8:	c0 58       	rjmp	8000bbf2 <_vfprintf_r+0x2d2>
8000bbea:	70 00       	ld.w	r0,r8[0x0]
8000bbec:	14 96       	mov	r6,r10
8000bbee:	2f c8       	sub	r8,-4
8000bbf0:	51 08       	stdsp	sp[0x40],r8
8000bbf2:	58 00       	cp.w	r0,0
8000bbf4:	fe 94 ff 76 	brge	8000bae0 <_vfprintf_r+0x1c0>
8000bbf8:	5c 30       	neg	r0
8000bbfa:	a3 a5       	sbr	r5,0x2
8000bbfc:	c7 2b       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bbfe:	32 b8       	mov	r8,43
8000bc00:	fb 68 06 bb 	st.b	sp[1723],r8
8000bc04:	c6 eb       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bc06:	0f 38       	ld.ub	r8,r7++
8000bc08:	e0 48 00 2a 	cp.w	r8,42
8000bc0c:	c0 30       	breq	8000bc12 <_vfprintf_r+0x2f2>
8000bc0e:	30 09       	mov	r9,0
8000bc10:	c7 98       	rjmp	8000bd02 <_vfprintf_r+0x3e2>
8000bc12:	0f 88       	ld.ub	r8,r7[0x0]
8000bc14:	f0 c9 00 30 	sub	r9,r8,48
8000bc18:	58 99       	cp.w	r9,9
8000bc1a:	e0 8b 00 1f 	brhi	8000bc58 <_vfprintf_r+0x338>
8000bc1e:	ee c4 ff ff 	sub	r4,r7,-1
8000bc22:	30 0b       	mov	r11,0
8000bc24:	23 08       	sub	r8,48
8000bc26:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000bc2a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000bc2e:	09 38       	ld.ub	r8,r4++
8000bc30:	f0 c9 00 30 	sub	r9,r8,48
8000bc34:	58 99       	cp.w	r9,9
8000bc36:	fe 98 ff f7 	brls	8000bc24 <_vfprintf_r+0x304>
8000bc3a:	e0 48 00 24 	cp.w	r8,36
8000bc3e:	fe 91 ff 4f 	brne	8000badc <_vfprintf_r+0x1bc>
8000bc42:	e0 4b 00 20 	cp.w	r11,32
8000bc46:	e0 89 0d eb 	brgt	8000d81c <_vfprintf_r+0x1efc>
8000bc4a:	20 1b       	sub	r11,1
8000bc4c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bc50:	10 3b       	cp.w	r11,r8
8000bc52:	c0 a5       	brlt	8000bc66 <_vfprintf_r+0x346>
8000bc54:	c1 18       	rjmp	8000bc76 <_vfprintf_r+0x356>
8000bc56:	d7 03       	nop
8000bc58:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000bc5c:	ec c9 ff ff 	sub	r9,r6,-1
8000bc60:	14 36       	cp.w	r6,r10
8000bc62:	c1 f5       	brlt	8000bca0 <_vfprintf_r+0x380>
8000bc64:	c2 88       	rjmp	8000bcb4 <_vfprintf_r+0x394>
8000bc66:	fa ca f9 44 	sub	r10,sp,-1724
8000bc6a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000bc6e:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000bc72:	50 2b       	stdsp	sp[0x8],r11
8000bc74:	c3 c8       	rjmp	8000bcec <_vfprintf_r+0x3cc>
8000bc76:	fa c8 f9 50 	sub	r8,sp,-1712
8000bc7a:	1a d8       	st.w	--sp,r8
8000bc7c:	fa c8 fa b8 	sub	r8,sp,-1352
8000bc80:	1a d8       	st.w	--sp,r8
8000bc82:	fa c8 fb b4 	sub	r8,sp,-1100
8000bc86:	02 9a       	mov	r10,r1
8000bc88:	1a d8       	st.w	--sp,r8
8000bc8a:	04 9c       	mov	r12,r2
8000bc8c:	fa c8 f9 40 	sub	r8,sp,-1728
8000bc90:	fa c9 ff b4 	sub	r9,sp,-76
8000bc94:	fe b0 fc ae 	rcall	8000b5f0 <get_arg>
8000bc98:	2f dd       	sub	sp,-12
8000bc9a:	78 0c       	ld.w	r12,r12[0x0]
8000bc9c:	50 2c       	stdsp	sp[0x8],r12
8000bc9e:	c2 78       	rjmp	8000bcec <_vfprintf_r+0x3cc>
8000bca0:	12 96       	mov	r6,r9
8000bca2:	0e 94       	mov	r4,r7
8000bca4:	fa c9 f9 44 	sub	r9,sp,-1724
8000bca8:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000bcac:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000bcb0:	50 28       	stdsp	sp[0x8],r8
8000bcb2:	c1 d8       	rjmp	8000bcec <_vfprintf_r+0x3cc>
8000bcb4:	41 08       	lddsp	r8,sp[0x40]
8000bcb6:	59 fa       	cp.w	r10,31
8000bcb8:	e0 89 00 14 	brgt	8000bce0 <_vfprintf_r+0x3c0>
8000bcbc:	f0 cb ff fc 	sub	r11,r8,-4
8000bcc0:	70 08       	ld.w	r8,r8[0x0]
8000bcc2:	51 0b       	stdsp	sp[0x40],r11
8000bcc4:	50 28       	stdsp	sp[0x8],r8
8000bcc6:	fa c6 f9 44 	sub	r6,sp,-1724
8000bcca:	40 2e       	lddsp	lr,sp[0x8]
8000bccc:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000bcd0:	f1 4e fd 88 	st.w	r8[-632],lr
8000bcd4:	2f fa       	sub	r10,-1
8000bcd6:	0e 94       	mov	r4,r7
8000bcd8:	fb 4a 06 b4 	st.w	sp[1716],r10
8000bcdc:	12 96       	mov	r6,r9
8000bcde:	c0 78       	rjmp	8000bcec <_vfprintf_r+0x3cc>
8000bce0:	70 0c       	ld.w	r12,r8[0x0]
8000bce2:	0e 94       	mov	r4,r7
8000bce4:	2f c8       	sub	r8,-4
8000bce6:	50 2c       	stdsp	sp[0x8],r12
8000bce8:	12 96       	mov	r6,r9
8000bcea:	51 08       	stdsp	sp[0x40],r8
8000bcec:	40 2b       	lddsp	r11,sp[0x8]
8000bcee:	58 0b       	cp.w	r11,0
8000bcf0:	fe 95 fe f2 	brlt	8000bad4 <_vfprintf_r+0x1b4>
8000bcf4:	08 97       	mov	r7,r4
8000bcf6:	cf 5a       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bcf8:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000bcfc:	0f 38       	ld.ub	r8,r7++
8000bcfe:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000bd02:	f0 ca 00 30 	sub	r10,r8,48
8000bd06:	58 9a       	cp.w	r10,9
8000bd08:	fe 98 ff f8 	brls	8000bcf8 <_vfprintf_r+0x3d8>
8000bd0c:	3f fa       	mov	r10,-1
8000bd0e:	f2 0a 0c 49 	max	r9,r9,r10
8000bd12:	50 29       	stdsp	sp[0x8],r9
8000bd14:	ce 9a       	rjmp	8000bae6 <_vfprintf_r+0x1c6>
8000bd16:	a7 b5       	sbr	r5,0x7
8000bd18:	ce 4a       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bd1a:	30 09       	mov	r9,0
8000bd1c:	23 08       	sub	r8,48
8000bd1e:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000bd22:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000bd26:	0f 38       	ld.ub	r8,r7++
8000bd28:	f0 ca 00 30 	sub	r10,r8,48
8000bd2c:	58 9a       	cp.w	r10,9
8000bd2e:	fe 98 ff f7 	brls	8000bd1c <_vfprintf_r+0x3fc>
8000bd32:	e0 48 00 24 	cp.w	r8,36
8000bd36:	fe 91 fe d7 	brne	8000bae4 <_vfprintf_r+0x1c4>
8000bd3a:	e0 49 00 20 	cp.w	r9,32
8000bd3e:	e0 89 0d 6f 	brgt	8000d81c <_vfprintf_r+0x1efc>
8000bd42:	f2 c3 00 01 	sub	r3,r9,1
8000bd46:	30 19       	mov	r9,1
8000bd48:	50 39       	stdsp	sp[0xc],r9
8000bd4a:	cc ba       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bd4c:	a3 b5       	sbr	r5,0x3
8000bd4e:	cc 9a       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bd50:	a7 a5       	sbr	r5,0x6
8000bd52:	cc 7a       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bd54:	0a 98       	mov	r8,r5
8000bd56:	a5 b5       	sbr	r5,0x5
8000bd58:	a5 a8       	sbr	r8,0x4
8000bd5a:	0f 89       	ld.ub	r9,r7[0x0]
8000bd5c:	36 ce       	mov	lr,108
8000bd5e:	fc 09 18 00 	cp.b	r9,lr
8000bd62:	f7 b7 00 ff 	subeq	r7,-1
8000bd66:	f0 05 17 10 	movne	r5,r8
8000bd6a:	cb ba       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bd6c:	a5 b5       	sbr	r5,0x5
8000bd6e:	cb 9a       	rjmp	8000bae0 <_vfprintf_r+0x1c0>
8000bd70:	50 a7       	stdsp	sp[0x28],r7
8000bd72:	50 80       	stdsp	sp[0x20],r0
8000bd74:	0c 97       	mov	r7,r6
8000bd76:	10 90       	mov	r0,r8
8000bd78:	06 96       	mov	r6,r3
8000bd7a:	04 94       	mov	r4,r2
8000bd7c:	40 93       	lddsp	r3,sp[0x24]
8000bd7e:	02 92       	mov	r2,r1
8000bd80:	0e 99       	mov	r9,r7
8000bd82:	40 41       	lddsp	r1,sp[0x10]
8000bd84:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bd88:	40 3c       	lddsp	r12,sp[0xc]
8000bd8a:	58 0c       	cp.w	r12,0
8000bd8c:	c1 d0       	breq	8000bdc6 <_vfprintf_r+0x4a6>
8000bd8e:	10 36       	cp.w	r6,r8
8000bd90:	c0 64       	brge	8000bd9c <_vfprintf_r+0x47c>
8000bd92:	fa cb f9 44 	sub	r11,sp,-1724
8000bd96:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bd9a:	c1 d8       	rjmp	8000bdd4 <_vfprintf_r+0x4b4>
8000bd9c:	fa c8 f9 50 	sub	r8,sp,-1712
8000bda0:	1a d8       	st.w	--sp,r8
8000bda2:	fa c8 fa b8 	sub	r8,sp,-1352
8000bda6:	1a d8       	st.w	--sp,r8
8000bda8:	fa c8 fb b4 	sub	r8,sp,-1100
8000bdac:	1a d8       	st.w	--sp,r8
8000bdae:	fa c8 f9 40 	sub	r8,sp,-1728
8000bdb2:	fa c9 ff b4 	sub	r9,sp,-76
8000bdb6:	04 9a       	mov	r10,r2
8000bdb8:	0c 9b       	mov	r11,r6
8000bdba:	08 9c       	mov	r12,r4
8000bdbc:	fe b0 fc 1a 	rcall	8000b5f0 <get_arg>
8000bdc0:	2f dd       	sub	sp,-12
8000bdc2:	19 b8       	ld.ub	r8,r12[0x3]
8000bdc4:	c2 28       	rjmp	8000be08 <_vfprintf_r+0x4e8>
8000bdc6:	2f f7       	sub	r7,-1
8000bdc8:	10 39       	cp.w	r9,r8
8000bdca:	c0 84       	brge	8000bdda <_vfprintf_r+0x4ba>
8000bdcc:	fa ca f9 44 	sub	r10,sp,-1724
8000bdd0:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000bdd4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000bdd8:	c1 88       	rjmp	8000be08 <_vfprintf_r+0x4e8>
8000bdda:	41 09       	lddsp	r9,sp[0x40]
8000bddc:	59 f8       	cp.w	r8,31
8000bdde:	e0 89 00 12 	brgt	8000be02 <_vfprintf_r+0x4e2>
8000bde2:	f2 ca ff fc 	sub	r10,r9,-4
8000bde6:	51 0a       	stdsp	sp[0x40],r10
8000bde8:	72 09       	ld.w	r9,r9[0x0]
8000bdea:	fa c6 f9 44 	sub	r6,sp,-1724
8000bdee:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000bdf2:	2f f8       	sub	r8,-1
8000bdf4:	f5 49 fd 88 	st.w	r10[-632],r9
8000bdf8:	fb 48 06 b4 	st.w	sp[1716],r8
8000bdfc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000be00:	c0 48       	rjmp	8000be08 <_vfprintf_r+0x4e8>
8000be02:	13 b8       	ld.ub	r8,r9[0x3]
8000be04:	2f c9       	sub	r9,-4
8000be06:	51 09       	stdsp	sp[0x40],r9
8000be08:	fb 68 06 60 	st.b	sp[1632],r8
8000be0c:	30 0e       	mov	lr,0
8000be0e:	30 08       	mov	r8,0
8000be10:	30 12       	mov	r2,1
8000be12:	fb 68 06 bb 	st.b	sp[1723],r8
8000be16:	50 2e       	stdsp	sp[0x8],lr
8000be18:	e0 8f 08 ad 	bral	8000cf72 <_vfprintf_r+0x1652>
8000be1c:	50 a7       	stdsp	sp[0x28],r7
8000be1e:	50 80       	stdsp	sp[0x20],r0
8000be20:	0c 97       	mov	r7,r6
8000be22:	04 94       	mov	r4,r2
8000be24:	06 96       	mov	r6,r3
8000be26:	02 92       	mov	r2,r1
8000be28:	40 93       	lddsp	r3,sp[0x24]
8000be2a:	10 90       	mov	r0,r8
8000be2c:	40 41       	lddsp	r1,sp[0x10]
8000be2e:	a5 a5       	sbr	r5,0x4
8000be30:	c0 a8       	rjmp	8000be44 <_vfprintf_r+0x524>
8000be32:	50 a7       	stdsp	sp[0x28],r7
8000be34:	50 80       	stdsp	sp[0x20],r0
8000be36:	0c 97       	mov	r7,r6
8000be38:	04 94       	mov	r4,r2
8000be3a:	06 96       	mov	r6,r3
8000be3c:	02 92       	mov	r2,r1
8000be3e:	40 93       	lddsp	r3,sp[0x24]
8000be40:	10 90       	mov	r0,r8
8000be42:	40 41       	lddsp	r1,sp[0x10]
8000be44:	ed b5 00 05 	bld	r5,0x5
8000be48:	c5 11       	brne	8000beea <_vfprintf_r+0x5ca>
8000be4a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000be4e:	40 3c       	lddsp	r12,sp[0xc]
8000be50:	58 0c       	cp.w	r12,0
8000be52:	c1 e0       	breq	8000be8e <_vfprintf_r+0x56e>
8000be54:	10 36       	cp.w	r6,r8
8000be56:	c0 64       	brge	8000be62 <_vfprintf_r+0x542>
8000be58:	fa cb f9 44 	sub	r11,sp,-1724
8000be5c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000be60:	c2 08       	rjmp	8000bea0 <_vfprintf_r+0x580>
8000be62:	fa c8 f9 50 	sub	r8,sp,-1712
8000be66:	1a d8       	st.w	--sp,r8
8000be68:	fa c8 fa b8 	sub	r8,sp,-1352
8000be6c:	0c 9b       	mov	r11,r6
8000be6e:	1a d8       	st.w	--sp,r8
8000be70:	fa c8 fb b4 	sub	r8,sp,-1100
8000be74:	1a d8       	st.w	--sp,r8
8000be76:	fa c9 ff b4 	sub	r9,sp,-76
8000be7a:	fa c8 f9 40 	sub	r8,sp,-1728
8000be7e:	04 9a       	mov	r10,r2
8000be80:	08 9c       	mov	r12,r4
8000be82:	fe b0 fb b7 	rcall	8000b5f0 <get_arg>
8000be86:	2f dd       	sub	sp,-12
8000be88:	78 1b       	ld.w	r11,r12[0x4]
8000be8a:	78 09       	ld.w	r9,r12[0x0]
8000be8c:	c2 b8       	rjmp	8000bee2 <_vfprintf_r+0x5c2>
8000be8e:	ee ca ff ff 	sub	r10,r7,-1
8000be92:	10 37       	cp.w	r7,r8
8000be94:	c0 b4       	brge	8000beaa <_vfprintf_r+0x58a>
8000be96:	fa c9 f9 44 	sub	r9,sp,-1724
8000be9a:	14 97       	mov	r7,r10
8000be9c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bea0:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000bea4:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000bea8:	c1 d8       	rjmp	8000bee2 <_vfprintf_r+0x5c2>
8000beaa:	41 09       	lddsp	r9,sp[0x40]
8000beac:	59 f8       	cp.w	r8,31
8000beae:	e0 89 00 14 	brgt	8000bed6 <_vfprintf_r+0x5b6>
8000beb2:	f2 cb ff f8 	sub	r11,r9,-8
8000beb6:	51 0b       	stdsp	sp[0x40],r11
8000beb8:	fa c6 f9 44 	sub	r6,sp,-1724
8000bebc:	72 1b       	ld.w	r11,r9[0x4]
8000bebe:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000bec2:	72 09       	ld.w	r9,r9[0x0]
8000bec4:	f9 4b fd 8c 	st.w	r12[-628],r11
8000bec8:	f9 49 fd 88 	st.w	r12[-632],r9
8000becc:	2f f8       	sub	r8,-1
8000bece:	14 97       	mov	r7,r10
8000bed0:	fb 48 06 b4 	st.w	sp[1716],r8
8000bed4:	c0 78       	rjmp	8000bee2 <_vfprintf_r+0x5c2>
8000bed6:	f2 c8 ff f8 	sub	r8,r9,-8
8000beda:	72 1b       	ld.w	r11,r9[0x4]
8000bedc:	14 97       	mov	r7,r10
8000bede:	51 08       	stdsp	sp[0x40],r8
8000bee0:	72 09       	ld.w	r9,r9[0x0]
8000bee2:	16 98       	mov	r8,r11
8000bee4:	fa e9 00 00 	st.d	sp[0],r8
8000bee8:	ca e8       	rjmp	8000c044 <_vfprintf_r+0x724>
8000beea:	ed b5 00 04 	bld	r5,0x4
8000beee:	c1 71       	brne	8000bf1c <_vfprintf_r+0x5fc>
8000bef0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bef4:	40 3e       	lddsp	lr,sp[0xc]
8000bef6:	58 0e       	cp.w	lr,0
8000bef8:	c0 80       	breq	8000bf08 <_vfprintf_r+0x5e8>
8000befa:	10 36       	cp.w	r6,r8
8000befc:	c6 94       	brge	8000bfce <_vfprintf_r+0x6ae>
8000befe:	fa cc f9 44 	sub	r12,sp,-1724
8000bf02:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000bf06:	c8 28       	rjmp	8000c00a <_vfprintf_r+0x6ea>
8000bf08:	ee ca ff ff 	sub	r10,r7,-1
8000bf0c:	10 37       	cp.w	r7,r8
8000bf0e:	e0 84 00 81 	brge	8000c010 <_vfprintf_r+0x6f0>
8000bf12:	fa cb f9 44 	sub	r11,sp,-1724
8000bf16:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bf1a:	c7 78       	rjmp	8000c008 <_vfprintf_r+0x6e8>
8000bf1c:	ed b5 00 06 	bld	r5,0x6
8000bf20:	c4 b1       	brne	8000bfb6 <_vfprintf_r+0x696>
8000bf22:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bf26:	40 3c       	lddsp	r12,sp[0xc]
8000bf28:	58 0c       	cp.w	r12,0
8000bf2a:	c1 d0       	breq	8000bf64 <_vfprintf_r+0x644>
8000bf2c:	10 36       	cp.w	r6,r8
8000bf2e:	c0 64       	brge	8000bf3a <_vfprintf_r+0x61a>
8000bf30:	fa cb f9 44 	sub	r11,sp,-1724
8000bf34:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bf38:	c1 f8       	rjmp	8000bf76 <_vfprintf_r+0x656>
8000bf3a:	fa c8 f9 50 	sub	r8,sp,-1712
8000bf3e:	1a d8       	st.w	--sp,r8
8000bf40:	fa c8 fa b8 	sub	r8,sp,-1352
8000bf44:	1a d8       	st.w	--sp,r8
8000bf46:	fa c8 fb b4 	sub	r8,sp,-1100
8000bf4a:	1a d8       	st.w	--sp,r8
8000bf4c:	fa c8 f9 40 	sub	r8,sp,-1728
8000bf50:	fa c9 ff b4 	sub	r9,sp,-76
8000bf54:	04 9a       	mov	r10,r2
8000bf56:	0c 9b       	mov	r11,r6
8000bf58:	08 9c       	mov	r12,r4
8000bf5a:	fe b0 fb 4b 	rcall	8000b5f0 <get_arg>
8000bf5e:	2f dd       	sub	sp,-12
8000bf60:	98 18       	ld.sh	r8,r12[0x2]
8000bf62:	c2 68       	rjmp	8000bfae <_vfprintf_r+0x68e>
8000bf64:	ee ca ff ff 	sub	r10,r7,-1
8000bf68:	10 37       	cp.w	r7,r8
8000bf6a:	c0 94       	brge	8000bf7c <_vfprintf_r+0x65c>
8000bf6c:	fa c9 f9 44 	sub	r9,sp,-1724
8000bf70:	14 97       	mov	r7,r10
8000bf72:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000bf76:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000bf7a:	c1 a8       	rjmp	8000bfae <_vfprintf_r+0x68e>
8000bf7c:	41 09       	lddsp	r9,sp[0x40]
8000bf7e:	59 f8       	cp.w	r8,31
8000bf80:	e0 89 00 13 	brgt	8000bfa6 <_vfprintf_r+0x686>
8000bf84:	f2 cb ff fc 	sub	r11,r9,-4
8000bf88:	51 0b       	stdsp	sp[0x40],r11
8000bf8a:	72 09       	ld.w	r9,r9[0x0]
8000bf8c:	fa c6 f9 44 	sub	r6,sp,-1724
8000bf90:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000bf94:	2f f8       	sub	r8,-1
8000bf96:	f7 49 fd 88 	st.w	r11[-632],r9
8000bf9a:	fb 48 06 b4 	st.w	sp[1716],r8
8000bf9e:	14 97       	mov	r7,r10
8000bfa0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000bfa4:	c0 58       	rjmp	8000bfae <_vfprintf_r+0x68e>
8000bfa6:	92 18       	ld.sh	r8,r9[0x2]
8000bfa8:	14 97       	mov	r7,r10
8000bfaa:	2f c9       	sub	r9,-4
8000bfac:	51 09       	stdsp	sp[0x40],r9
8000bfae:	50 18       	stdsp	sp[0x4],r8
8000bfb0:	bf 58       	asr	r8,0x1f
8000bfb2:	50 08       	stdsp	sp[0x0],r8
8000bfb4:	c4 88       	rjmp	8000c044 <_vfprintf_r+0x724>
8000bfb6:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000bfba:	40 3c       	lddsp	r12,sp[0xc]
8000bfbc:	58 0c       	cp.w	r12,0
8000bfbe:	c1 d0       	breq	8000bff8 <_vfprintf_r+0x6d8>
8000bfc0:	10 36       	cp.w	r6,r8
8000bfc2:	c0 64       	brge	8000bfce <_vfprintf_r+0x6ae>
8000bfc4:	fa cb f9 44 	sub	r11,sp,-1724
8000bfc8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000bfcc:	c1 f8       	rjmp	8000c00a <_vfprintf_r+0x6ea>
8000bfce:	fa c8 f9 50 	sub	r8,sp,-1712
8000bfd2:	1a d8       	st.w	--sp,r8
8000bfd4:	fa c8 fa b8 	sub	r8,sp,-1352
8000bfd8:	0c 9b       	mov	r11,r6
8000bfda:	1a d8       	st.w	--sp,r8
8000bfdc:	fa c8 fb b4 	sub	r8,sp,-1100
8000bfe0:	04 9a       	mov	r10,r2
8000bfe2:	1a d8       	st.w	--sp,r8
8000bfe4:	08 9c       	mov	r12,r4
8000bfe6:	fa c8 f9 40 	sub	r8,sp,-1728
8000bfea:	fa c9 ff b4 	sub	r9,sp,-76
8000bfee:	fe b0 fb 01 	rcall	8000b5f0 <get_arg>
8000bff2:	2f dd       	sub	sp,-12
8000bff4:	78 0b       	ld.w	r11,r12[0x0]
8000bff6:	c2 48       	rjmp	8000c03e <_vfprintf_r+0x71e>
8000bff8:	ee ca ff ff 	sub	r10,r7,-1
8000bffc:	10 37       	cp.w	r7,r8
8000bffe:	c0 94       	brge	8000c010 <_vfprintf_r+0x6f0>
8000c000:	fa c9 f9 44 	sub	r9,sp,-1724
8000c004:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c008:	14 97       	mov	r7,r10
8000c00a:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c00e:	c1 88       	rjmp	8000c03e <_vfprintf_r+0x71e>
8000c010:	41 09       	lddsp	r9,sp[0x40]
8000c012:	59 f8       	cp.w	r8,31
8000c014:	e0 89 00 11 	brgt	8000c036 <_vfprintf_r+0x716>
8000c018:	f2 cb ff fc 	sub	r11,r9,-4
8000c01c:	51 0b       	stdsp	sp[0x40],r11
8000c01e:	fa c6 f9 44 	sub	r6,sp,-1724
8000c022:	72 0b       	ld.w	r11,r9[0x0]
8000c024:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c028:	f3 4b fd 88 	st.w	r9[-632],r11
8000c02c:	2f f8       	sub	r8,-1
8000c02e:	14 97       	mov	r7,r10
8000c030:	fb 48 06 b4 	st.w	sp[1716],r8
8000c034:	c0 58       	rjmp	8000c03e <_vfprintf_r+0x71e>
8000c036:	72 0b       	ld.w	r11,r9[0x0]
8000c038:	14 97       	mov	r7,r10
8000c03a:	2f c9       	sub	r9,-4
8000c03c:	51 09       	stdsp	sp[0x40],r9
8000c03e:	50 1b       	stdsp	sp[0x4],r11
8000c040:	bf 5b       	asr	r11,0x1f
8000c042:	50 0b       	stdsp	sp[0x0],r11
8000c044:	fa ea 00 00 	ld.d	r10,sp[0]
8000c048:	58 0a       	cp.w	r10,0
8000c04a:	5c 2b       	cpc	r11
8000c04c:	c0 e4       	brge	8000c068 <_vfprintf_r+0x748>
8000c04e:	30 08       	mov	r8,0
8000c050:	fa ea 00 00 	ld.d	r10,sp[0]
8000c054:	30 09       	mov	r9,0
8000c056:	f0 0a 01 0a 	sub	r10,r8,r10
8000c05a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000c05e:	32 d8       	mov	r8,45
8000c060:	fa eb 00 00 	st.d	sp[0],r10
8000c064:	fb 68 06 bb 	st.b	sp[1723],r8
8000c068:	30 18       	mov	r8,1
8000c06a:	e0 8f 06 fa 	bral	8000ce5e <_vfprintf_r+0x153e>
8000c06e:	50 a7       	stdsp	sp[0x28],r7
8000c070:	50 80       	stdsp	sp[0x20],r0
8000c072:	0c 97       	mov	r7,r6
8000c074:	04 94       	mov	r4,r2
8000c076:	06 96       	mov	r6,r3
8000c078:	02 92       	mov	r2,r1
8000c07a:	40 93       	lddsp	r3,sp[0x24]
8000c07c:	10 90       	mov	r0,r8
8000c07e:	40 41       	lddsp	r1,sp[0x10]
8000c080:	0e 99       	mov	r9,r7
8000c082:	ed b5 00 03 	bld	r5,0x3
8000c086:	c4 11       	brne	8000c108 <_vfprintf_r+0x7e8>
8000c088:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c08c:	40 3a       	lddsp	r10,sp[0xc]
8000c08e:	58 0a       	cp.w	r10,0
8000c090:	c1 90       	breq	8000c0c2 <_vfprintf_r+0x7a2>
8000c092:	10 36       	cp.w	r6,r8
8000c094:	c6 45       	brlt	8000c15c <_vfprintf_r+0x83c>
8000c096:	fa c8 f9 50 	sub	r8,sp,-1712
8000c09a:	1a d8       	st.w	--sp,r8
8000c09c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c0a0:	1a d8       	st.w	--sp,r8
8000c0a2:	fa c8 fb b4 	sub	r8,sp,-1100
8000c0a6:	0c 9b       	mov	r11,r6
8000c0a8:	1a d8       	st.w	--sp,r8
8000c0aa:	04 9a       	mov	r10,r2
8000c0ac:	fa c8 f9 40 	sub	r8,sp,-1728
8000c0b0:	fa c9 ff b4 	sub	r9,sp,-76
8000c0b4:	08 9c       	mov	r12,r4
8000c0b6:	fe b0 fa 9d 	rcall	8000b5f0 <get_arg>
8000c0ba:	2f dd       	sub	sp,-12
8000c0bc:	78 16       	ld.w	r6,r12[0x4]
8000c0be:	50 76       	stdsp	sp[0x1c],r6
8000c0c0:	c4 88       	rjmp	8000c150 <_vfprintf_r+0x830>
8000c0c2:	2f f7       	sub	r7,-1
8000c0c4:	10 39       	cp.w	r9,r8
8000c0c6:	c0 c4       	brge	8000c0de <_vfprintf_r+0x7be>
8000c0c8:	fa ce f9 44 	sub	lr,sp,-1724
8000c0cc:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000c0d0:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000c0d4:	50 7c       	stdsp	sp[0x1c],r12
8000c0d6:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000c0da:	50 56       	stdsp	sp[0x14],r6
8000c0dc:	c6 68       	rjmp	8000c1a8 <_vfprintf_r+0x888>
8000c0de:	41 09       	lddsp	r9,sp[0x40]
8000c0e0:	59 f8       	cp.w	r8,31
8000c0e2:	e0 89 00 10 	brgt	8000c102 <_vfprintf_r+0x7e2>
8000c0e6:	f2 ca ff f8 	sub	r10,r9,-8
8000c0ea:	72 1b       	ld.w	r11,r9[0x4]
8000c0ec:	51 0a       	stdsp	sp[0x40],r10
8000c0ee:	72 09       	ld.w	r9,r9[0x0]
8000c0f0:	fa ca f9 44 	sub	r10,sp,-1724
8000c0f4:	50 7b       	stdsp	sp[0x1c],r11
8000c0f6:	50 59       	stdsp	sp[0x14],r9
8000c0f8:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000c0fc:	40 5b       	lddsp	r11,sp[0x14]
8000c0fe:	40 7a       	lddsp	r10,sp[0x1c]
8000c100:	c4 78       	rjmp	8000c18e <_vfprintf_r+0x86e>
8000c102:	72 18       	ld.w	r8,r9[0x4]
8000c104:	50 78       	stdsp	sp[0x1c],r8
8000c106:	c4 c8       	rjmp	8000c19e <_vfprintf_r+0x87e>
8000c108:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c10c:	40 3e       	lddsp	lr,sp[0xc]
8000c10e:	58 0e       	cp.w	lr,0
8000c110:	c2 30       	breq	8000c156 <_vfprintf_r+0x836>
8000c112:	10 36       	cp.w	r6,r8
8000c114:	c0 94       	brge	8000c126 <_vfprintf_r+0x806>
8000c116:	fa cc f9 44 	sub	r12,sp,-1724
8000c11a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c11e:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000c122:	50 7b       	stdsp	sp[0x1c],r11
8000c124:	cd 9b       	rjmp	8000c0d6 <_vfprintf_r+0x7b6>
8000c126:	fa c8 f9 50 	sub	r8,sp,-1712
8000c12a:	1a d8       	st.w	--sp,r8
8000c12c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c130:	04 9a       	mov	r10,r2
8000c132:	1a d8       	st.w	--sp,r8
8000c134:	fa c8 fb b4 	sub	r8,sp,-1100
8000c138:	0c 9b       	mov	r11,r6
8000c13a:	1a d8       	st.w	--sp,r8
8000c13c:	08 9c       	mov	r12,r4
8000c13e:	fa c8 f9 40 	sub	r8,sp,-1728
8000c142:	fa c9 ff b4 	sub	r9,sp,-76
8000c146:	fe b0 fa 55 	rcall	8000b5f0 <get_arg>
8000c14a:	2f dd       	sub	sp,-12
8000c14c:	78 1a       	ld.w	r10,r12[0x4]
8000c14e:	50 7a       	stdsp	sp[0x1c],r10
8000c150:	78 0c       	ld.w	r12,r12[0x0]
8000c152:	50 5c       	stdsp	sp[0x14],r12
8000c154:	c2 a8       	rjmp	8000c1a8 <_vfprintf_r+0x888>
8000c156:	2f f7       	sub	r7,-1
8000c158:	10 39       	cp.w	r9,r8
8000c15a:	c0 94       	brge	8000c16c <_vfprintf_r+0x84c>
8000c15c:	fa c9 f9 44 	sub	r9,sp,-1724
8000c160:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c164:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000c168:	50 78       	stdsp	sp[0x1c],r8
8000c16a:	cb 6b       	rjmp	8000c0d6 <_vfprintf_r+0x7b6>
8000c16c:	41 09       	lddsp	r9,sp[0x40]
8000c16e:	59 f8       	cp.w	r8,31
8000c170:	e0 89 00 15 	brgt	8000c19a <_vfprintf_r+0x87a>
8000c174:	f2 ca ff f8 	sub	r10,r9,-8
8000c178:	72 16       	ld.w	r6,r9[0x4]
8000c17a:	72 09       	ld.w	r9,r9[0x0]
8000c17c:	51 0a       	stdsp	sp[0x40],r10
8000c17e:	50 59       	stdsp	sp[0x14],r9
8000c180:	fa ce f9 44 	sub	lr,sp,-1724
8000c184:	50 76       	stdsp	sp[0x1c],r6
8000c186:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000c18a:	40 5b       	lddsp	r11,sp[0x14]
8000c18c:	0c 9a       	mov	r10,r6
8000c18e:	f2 eb fd 88 	st.d	r9[-632],r10
8000c192:	2f f8       	sub	r8,-1
8000c194:	fb 48 06 b4 	st.w	sp[1716],r8
8000c198:	c0 88       	rjmp	8000c1a8 <_vfprintf_r+0x888>
8000c19a:	72 1c       	ld.w	r12,r9[0x4]
8000c19c:	50 7c       	stdsp	sp[0x1c],r12
8000c19e:	f2 c8 ff f8 	sub	r8,r9,-8
8000c1a2:	51 08       	stdsp	sp[0x40],r8
8000c1a4:	72 09       	ld.w	r9,r9[0x0]
8000c1a6:	50 59       	stdsp	sp[0x14],r9
8000c1a8:	40 5b       	lddsp	r11,sp[0x14]
8000c1aa:	40 7a       	lddsp	r10,sp[0x1c]
8000c1ac:	e0 a0 19 54 	rcall	8000f454 <__isinfd>
8000c1b0:	18 96       	mov	r6,r12
8000c1b2:	c1 70       	breq	8000c1e0 <_vfprintf_r+0x8c0>
8000c1b4:	30 08       	mov	r8,0
8000c1b6:	30 09       	mov	r9,0
8000c1b8:	40 5b       	lddsp	r11,sp[0x14]
8000c1ba:	40 7a       	lddsp	r10,sp[0x1c]
8000c1bc:	e0 a0 1d a8 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000c1c0:	c0 40       	breq	8000c1c8 <_vfprintf_r+0x8a8>
8000c1c2:	32 d8       	mov	r8,45
8000c1c4:	fb 68 06 bb 	st.b	sp[1723],r8
8000c1c8:	fe c8 b3 28 	sub	r8,pc,-19672
8000c1cc:	fe c6 b3 28 	sub	r6,pc,-19672
8000c1d0:	a7 d5       	cbr	r5,0x7
8000c1d2:	e0 40 00 47 	cp.w	r0,71
8000c1d6:	f0 06 17 a0 	movle	r6,r8
8000c1da:	30 32       	mov	r2,3
8000c1dc:	e0 8f 06 ce 	bral	8000cf78 <_vfprintf_r+0x1658>
8000c1e0:	40 5b       	lddsp	r11,sp[0x14]
8000c1e2:	40 7a       	lddsp	r10,sp[0x1c]
8000c1e4:	e0 a0 19 4d 	rcall	8000f47e <__isnand>
8000c1e8:	c0 e0       	breq	8000c204 <_vfprintf_r+0x8e4>
8000c1ea:	50 26       	stdsp	sp[0x8],r6
8000c1ec:	fe c8 b3 44 	sub	r8,pc,-19644
8000c1f0:	fe c6 b3 44 	sub	r6,pc,-19644
8000c1f4:	a7 d5       	cbr	r5,0x7
8000c1f6:	e0 40 00 47 	cp.w	r0,71
8000c1fa:	f0 06 17 a0 	movle	r6,r8
8000c1fe:	30 32       	mov	r2,3
8000c200:	e0 8f 06 c2 	bral	8000cf84 <_vfprintf_r+0x1664>
8000c204:	40 2a       	lddsp	r10,sp[0x8]
8000c206:	5b fa       	cp.w	r10,-1
8000c208:	c0 41       	brne	8000c210 <_vfprintf_r+0x8f0>
8000c20a:	30 69       	mov	r9,6
8000c20c:	50 29       	stdsp	sp[0x8],r9
8000c20e:	c1 18       	rjmp	8000c230 <_vfprintf_r+0x910>
8000c210:	e0 40 00 47 	cp.w	r0,71
8000c214:	5f 09       	sreq	r9
8000c216:	e0 40 00 67 	cp.w	r0,103
8000c21a:	5f 08       	sreq	r8
8000c21c:	f3 e8 10 08 	or	r8,r9,r8
8000c220:	f8 08 18 00 	cp.b	r8,r12
8000c224:	c0 60       	breq	8000c230 <_vfprintf_r+0x910>
8000c226:	40 28       	lddsp	r8,sp[0x8]
8000c228:	58 08       	cp.w	r8,0
8000c22a:	f9 b8 00 01 	moveq	r8,1
8000c22e:	50 28       	stdsp	sp[0x8],r8
8000c230:	40 78       	lddsp	r8,sp[0x1c]
8000c232:	40 59       	lddsp	r9,sp[0x14]
8000c234:	fa e9 06 94 	st.d	sp[1684],r8
8000c238:	a9 a5       	sbr	r5,0x8
8000c23a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000c23e:	58 08       	cp.w	r8,0
8000c240:	c0 65       	brlt	8000c24c <_vfprintf_r+0x92c>
8000c242:	40 5e       	lddsp	lr,sp[0x14]
8000c244:	30 0c       	mov	r12,0
8000c246:	50 6e       	stdsp	sp[0x18],lr
8000c248:	50 9c       	stdsp	sp[0x24],r12
8000c24a:	c0 78       	rjmp	8000c258 <_vfprintf_r+0x938>
8000c24c:	40 5b       	lddsp	r11,sp[0x14]
8000c24e:	32 da       	mov	r10,45
8000c250:	ee 1b 80 00 	eorh	r11,0x8000
8000c254:	50 9a       	stdsp	sp[0x24],r10
8000c256:	50 6b       	stdsp	sp[0x18],r11
8000c258:	e0 40 00 46 	cp.w	r0,70
8000c25c:	5f 09       	sreq	r9
8000c25e:	e0 40 00 66 	cp.w	r0,102
8000c262:	5f 08       	sreq	r8
8000c264:	f3 e8 10 08 	or	r8,r9,r8
8000c268:	50 48       	stdsp	sp[0x10],r8
8000c26a:	c0 40       	breq	8000c272 <_vfprintf_r+0x952>
8000c26c:	40 22       	lddsp	r2,sp[0x8]
8000c26e:	30 39       	mov	r9,3
8000c270:	c1 08       	rjmp	8000c290 <_vfprintf_r+0x970>
8000c272:	e0 40 00 45 	cp.w	r0,69
8000c276:	5f 09       	sreq	r9
8000c278:	e0 40 00 65 	cp.w	r0,101
8000c27c:	5f 08       	sreq	r8
8000c27e:	40 22       	lddsp	r2,sp[0x8]
8000c280:	10 49       	or	r9,r8
8000c282:	2f f2       	sub	r2,-1
8000c284:	40 46       	lddsp	r6,sp[0x10]
8000c286:	ec 09 18 00 	cp.b	r9,r6
8000c28a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000c28e:	30 29       	mov	r9,2
8000c290:	fa c8 f9 5c 	sub	r8,sp,-1700
8000c294:	1a d8       	st.w	--sp,r8
8000c296:	fa c8 f9 54 	sub	r8,sp,-1708
8000c29a:	1a d8       	st.w	--sp,r8
8000c29c:	fa c8 f9 4c 	sub	r8,sp,-1716
8000c2a0:	08 9c       	mov	r12,r4
8000c2a2:	1a d8       	st.w	--sp,r8
8000c2a4:	04 98       	mov	r8,r2
8000c2a6:	40 9b       	lddsp	r11,sp[0x24]
8000c2a8:	40 aa       	lddsp	r10,sp[0x28]
8000c2aa:	e0 a0 0b c3 	rcall	8000da30 <_dtoa_r>
8000c2ae:	e0 40 00 47 	cp.w	r0,71
8000c2b2:	5f 19       	srne	r9
8000c2b4:	e0 40 00 67 	cp.w	r0,103
8000c2b8:	5f 18       	srne	r8
8000c2ba:	18 96       	mov	r6,r12
8000c2bc:	2f dd       	sub	sp,-12
8000c2be:	f3 e8 00 08 	and	r8,r9,r8
8000c2c2:	c0 41       	brne	8000c2ca <_vfprintf_r+0x9aa>
8000c2c4:	ed b5 00 00 	bld	r5,0x0
8000c2c8:	c3 01       	brne	8000c328 <_vfprintf_r+0xa08>
8000c2ca:	ec 02 00 0e 	add	lr,r6,r2
8000c2ce:	50 3e       	stdsp	sp[0xc],lr
8000c2d0:	40 4c       	lddsp	r12,sp[0x10]
8000c2d2:	58 0c       	cp.w	r12,0
8000c2d4:	c1 50       	breq	8000c2fe <_vfprintf_r+0x9de>
8000c2d6:	0d 89       	ld.ub	r9,r6[0x0]
8000c2d8:	33 08       	mov	r8,48
8000c2da:	f0 09 18 00 	cp.b	r9,r8
8000c2de:	c0 b1       	brne	8000c2f4 <_vfprintf_r+0x9d4>
8000c2e0:	30 08       	mov	r8,0
8000c2e2:	30 09       	mov	r9,0
8000c2e4:	40 6b       	lddsp	r11,sp[0x18]
8000c2e6:	40 7a       	lddsp	r10,sp[0x1c]
8000c2e8:	e0 a0 1c cb 	rcall	8000fc7e <__avr32_f64_cmp_eq>
8000c2ec:	fb b2 00 01 	rsubeq	r2,1
8000c2f0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000c2f4:	40 3b       	lddsp	r11,sp[0xc]
8000c2f6:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c2fa:	10 0b       	add	r11,r8
8000c2fc:	50 3b       	stdsp	sp[0xc],r11
8000c2fe:	40 6b       	lddsp	r11,sp[0x18]
8000c300:	30 08       	mov	r8,0
8000c302:	30 09       	mov	r9,0
8000c304:	40 7a       	lddsp	r10,sp[0x1c]
8000c306:	e0 a0 1c bc 	rcall	8000fc7e <__avr32_f64_cmp_eq>
8000c30a:	c0 90       	breq	8000c31c <_vfprintf_r+0x9fc>
8000c30c:	40 3a       	lddsp	r10,sp[0xc]
8000c30e:	fb 4a 06 a4 	st.w	sp[1700],r10
8000c312:	c0 58       	rjmp	8000c31c <_vfprintf_r+0x9fc>
8000c314:	10 c9       	st.b	r8++,r9
8000c316:	fb 48 06 a4 	st.w	sp[1700],r8
8000c31a:	c0 28       	rjmp	8000c31e <_vfprintf_r+0x9fe>
8000c31c:	33 09       	mov	r9,48
8000c31e:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000c322:	40 3e       	lddsp	lr,sp[0xc]
8000c324:	1c 38       	cp.w	r8,lr
8000c326:	cf 73       	brcs	8000c314 <_vfprintf_r+0x9f4>
8000c328:	e0 40 00 47 	cp.w	r0,71
8000c32c:	5f 09       	sreq	r9
8000c32e:	e0 40 00 67 	cp.w	r0,103
8000c332:	5f 08       	sreq	r8
8000c334:	f3 e8 10 08 	or	r8,r9,r8
8000c338:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000c33c:	0c 19       	sub	r9,r6
8000c33e:	50 69       	stdsp	sp[0x18],r9
8000c340:	58 08       	cp.w	r8,0
8000c342:	c0 b0       	breq	8000c358 <_vfprintf_r+0xa38>
8000c344:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000c348:	5b d8       	cp.w	r8,-3
8000c34a:	c0 55       	brlt	8000c354 <_vfprintf_r+0xa34>
8000c34c:	40 2c       	lddsp	r12,sp[0x8]
8000c34e:	18 38       	cp.w	r8,r12
8000c350:	e0 8a 00 6a 	brle	8000c424 <_vfprintf_r+0xb04>
8000c354:	20 20       	sub	r0,2
8000c356:	c0 58       	rjmp	8000c360 <_vfprintf_r+0xa40>
8000c358:	e0 40 00 65 	cp.w	r0,101
8000c35c:	e0 89 00 46 	brgt	8000c3e8 <_vfprintf_r+0xac8>
8000c360:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000c364:	fb 60 06 9c 	st.b	sp[1692],r0
8000c368:	20 1b       	sub	r11,1
8000c36a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000c36e:	c0 47       	brpl	8000c376 <_vfprintf_r+0xa56>
8000c370:	5c 3b       	neg	r11
8000c372:	32 d8       	mov	r8,45
8000c374:	c0 28       	rjmp	8000c378 <_vfprintf_r+0xa58>
8000c376:	32 b8       	mov	r8,43
8000c378:	fb 68 06 9d 	st.b	sp[1693],r8
8000c37c:	58 9b       	cp.w	r11,9
8000c37e:	e0 8a 00 1d 	brle	8000c3b8 <_vfprintf_r+0xa98>
8000c382:	fa c9 fa 35 	sub	r9,sp,-1483
8000c386:	30 aa       	mov	r10,10
8000c388:	12 98       	mov	r8,r9
8000c38a:	0e 9c       	mov	r12,r7
8000c38c:	0c 92       	mov	r2,r6
8000c38e:	f6 0a 0c 06 	divs	r6,r11,r10
8000c392:	0e 9b       	mov	r11,r7
8000c394:	2d 0b       	sub	r11,-48
8000c396:	10 fb       	st.b	--r8,r11
8000c398:	0c 9b       	mov	r11,r6
8000c39a:	58 96       	cp.w	r6,9
8000c39c:	fe 99 ff f9 	brgt	8000c38e <_vfprintf_r+0xa6e>
8000c3a0:	2d 0b       	sub	r11,-48
8000c3a2:	18 97       	mov	r7,r12
8000c3a4:	04 96       	mov	r6,r2
8000c3a6:	10 fb       	st.b	--r8,r11
8000c3a8:	fa ca f9 62 	sub	r10,sp,-1694
8000c3ac:	c0 38       	rjmp	8000c3b2 <_vfprintf_r+0xa92>
8000c3ae:	11 3b       	ld.ub	r11,r8++
8000c3b0:	14 cb       	st.b	r10++,r11
8000c3b2:	12 38       	cp.w	r8,r9
8000c3b4:	cf d3       	brcs	8000c3ae <_vfprintf_r+0xa8e>
8000c3b6:	c0 98       	rjmp	8000c3c8 <_vfprintf_r+0xaa8>
8000c3b8:	2d 0b       	sub	r11,-48
8000c3ba:	33 08       	mov	r8,48
8000c3bc:	fb 6b 06 9f 	st.b	sp[1695],r11
8000c3c0:	fb 68 06 9e 	st.b	sp[1694],r8
8000c3c4:	fa ca f9 60 	sub	r10,sp,-1696
8000c3c8:	fa c8 f9 64 	sub	r8,sp,-1692
8000c3cc:	f4 08 01 08 	sub	r8,r10,r8
8000c3d0:	50 e8       	stdsp	sp[0x38],r8
8000c3d2:	10 92       	mov	r2,r8
8000c3d4:	40 6b       	lddsp	r11,sp[0x18]
8000c3d6:	16 02       	add	r2,r11
8000c3d8:	58 1b       	cp.w	r11,1
8000c3da:	e0 89 00 05 	brgt	8000c3e4 <_vfprintf_r+0xac4>
8000c3de:	ed b5 00 00 	bld	r5,0x0
8000c3e2:	c3 51       	brne	8000c44c <_vfprintf_r+0xb2c>
8000c3e4:	2f f2       	sub	r2,-1
8000c3e6:	c3 38       	rjmp	8000c44c <_vfprintf_r+0xb2c>
8000c3e8:	e0 40 00 66 	cp.w	r0,102
8000c3ec:	c1 c1       	brne	8000c424 <_vfprintf_r+0xb04>
8000c3ee:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c3f2:	58 02       	cp.w	r2,0
8000c3f4:	e0 8a 00 0c 	brle	8000c40c <_vfprintf_r+0xaec>
8000c3f8:	40 2a       	lddsp	r10,sp[0x8]
8000c3fa:	58 0a       	cp.w	r10,0
8000c3fc:	c0 41       	brne	8000c404 <_vfprintf_r+0xae4>
8000c3fe:	ed b5 00 00 	bld	r5,0x0
8000c402:	c2 51       	brne	8000c44c <_vfprintf_r+0xb2c>
8000c404:	2f f2       	sub	r2,-1
8000c406:	40 29       	lddsp	r9,sp[0x8]
8000c408:	12 02       	add	r2,r9
8000c40a:	c0 b8       	rjmp	8000c420 <_vfprintf_r+0xb00>
8000c40c:	40 28       	lddsp	r8,sp[0x8]
8000c40e:	58 08       	cp.w	r8,0
8000c410:	c0 61       	brne	8000c41c <_vfprintf_r+0xafc>
8000c412:	ed b5 00 00 	bld	r5,0x0
8000c416:	c0 30       	breq	8000c41c <_vfprintf_r+0xafc>
8000c418:	30 12       	mov	r2,1
8000c41a:	c1 98       	rjmp	8000c44c <_vfprintf_r+0xb2c>
8000c41c:	40 22       	lddsp	r2,sp[0x8]
8000c41e:	2f e2       	sub	r2,-2
8000c420:	36 60       	mov	r0,102
8000c422:	c1 58       	rjmp	8000c44c <_vfprintf_r+0xb2c>
8000c424:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000c428:	40 6e       	lddsp	lr,sp[0x18]
8000c42a:	1c 32       	cp.w	r2,lr
8000c42c:	c0 65       	brlt	8000c438 <_vfprintf_r+0xb18>
8000c42e:	ed b5 00 00 	bld	r5,0x0
8000c432:	f7 b2 00 ff 	subeq	r2,-1
8000c436:	c0 a8       	rjmp	8000c44a <_vfprintf_r+0xb2a>
8000c438:	e4 08 11 02 	rsub	r8,r2,2
8000c43c:	40 6c       	lddsp	r12,sp[0x18]
8000c43e:	58 02       	cp.w	r2,0
8000c440:	f0 02 17 a0 	movle	r2,r8
8000c444:	f9 b2 09 01 	movgt	r2,1
8000c448:	18 02       	add	r2,r12
8000c44a:	36 70       	mov	r0,103
8000c44c:	40 9b       	lddsp	r11,sp[0x24]
8000c44e:	58 0b       	cp.w	r11,0
8000c450:	e0 80 05 94 	breq	8000cf78 <_vfprintf_r+0x1658>
8000c454:	32 d8       	mov	r8,45
8000c456:	fb 68 06 bb 	st.b	sp[1723],r8
8000c45a:	e0 8f 05 93 	bral	8000cf80 <_vfprintf_r+0x1660>
8000c45e:	50 a7       	stdsp	sp[0x28],r7
8000c460:	04 94       	mov	r4,r2
8000c462:	0c 97       	mov	r7,r6
8000c464:	02 92       	mov	r2,r1
8000c466:	06 96       	mov	r6,r3
8000c468:	40 41       	lddsp	r1,sp[0x10]
8000c46a:	40 93       	lddsp	r3,sp[0x24]
8000c46c:	0e 99       	mov	r9,r7
8000c46e:	ed b5 00 05 	bld	r5,0x5
8000c472:	c4 81       	brne	8000c502 <_vfprintf_r+0xbe2>
8000c474:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c478:	40 3e       	lddsp	lr,sp[0xc]
8000c47a:	58 0e       	cp.w	lr,0
8000c47c:	c1 d0       	breq	8000c4b6 <_vfprintf_r+0xb96>
8000c47e:	10 36       	cp.w	r6,r8
8000c480:	c0 64       	brge	8000c48c <_vfprintf_r+0xb6c>
8000c482:	fa cc f9 44 	sub	r12,sp,-1724
8000c486:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c48a:	c1 d8       	rjmp	8000c4c4 <_vfprintf_r+0xba4>
8000c48c:	fa c8 f9 50 	sub	r8,sp,-1712
8000c490:	1a d8       	st.w	--sp,r8
8000c492:	fa c8 fa b8 	sub	r8,sp,-1352
8000c496:	04 9a       	mov	r10,r2
8000c498:	1a d8       	st.w	--sp,r8
8000c49a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c49e:	0c 9b       	mov	r11,r6
8000c4a0:	1a d8       	st.w	--sp,r8
8000c4a2:	08 9c       	mov	r12,r4
8000c4a4:	fa c8 f9 40 	sub	r8,sp,-1728
8000c4a8:	fa c9 ff b4 	sub	r9,sp,-76
8000c4ac:	fe b0 f8 a2 	rcall	8000b5f0 <get_arg>
8000c4b0:	2f dd       	sub	sp,-12
8000c4b2:	78 0a       	ld.w	r10,r12[0x0]
8000c4b4:	c2 08       	rjmp	8000c4f4 <_vfprintf_r+0xbd4>
8000c4b6:	2f f7       	sub	r7,-1
8000c4b8:	10 39       	cp.w	r9,r8
8000c4ba:	c0 84       	brge	8000c4ca <_vfprintf_r+0xbaa>
8000c4bc:	fa cb f9 44 	sub	r11,sp,-1724
8000c4c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c4c4:	ec fa fd 88 	ld.w	r10,r6[-632]
8000c4c8:	c1 68       	rjmp	8000c4f4 <_vfprintf_r+0xbd4>
8000c4ca:	41 09       	lddsp	r9,sp[0x40]
8000c4cc:	59 f8       	cp.w	r8,31
8000c4ce:	e0 89 00 10 	brgt	8000c4ee <_vfprintf_r+0xbce>
8000c4d2:	f2 ca ff fc 	sub	r10,r9,-4
8000c4d6:	51 0a       	stdsp	sp[0x40],r10
8000c4d8:	fa c6 f9 44 	sub	r6,sp,-1724
8000c4dc:	72 0a       	ld.w	r10,r9[0x0]
8000c4de:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c4e2:	f3 4a fd 88 	st.w	r9[-632],r10
8000c4e6:	2f f8       	sub	r8,-1
8000c4e8:	fb 48 06 b4 	st.w	sp[1716],r8
8000c4ec:	c0 48       	rjmp	8000c4f4 <_vfprintf_r+0xbd4>
8000c4ee:	72 0a       	ld.w	r10,r9[0x0]
8000c4f0:	2f c9       	sub	r9,-4
8000c4f2:	51 09       	stdsp	sp[0x40],r9
8000c4f4:	40 be       	lddsp	lr,sp[0x2c]
8000c4f6:	1c 98       	mov	r8,lr
8000c4f8:	95 1e       	st.w	r10[0x4],lr
8000c4fa:	bf 58       	asr	r8,0x1f
8000c4fc:	95 08       	st.w	r10[0x0],r8
8000c4fe:	fe 9f fa 9f 	bral	8000ba3c <_vfprintf_r+0x11c>
8000c502:	ed b5 00 04 	bld	r5,0x4
8000c506:	c4 80       	breq	8000c596 <_vfprintf_r+0xc76>
8000c508:	e2 15 00 40 	andl	r5,0x40,COH
8000c50c:	c4 50       	breq	8000c596 <_vfprintf_r+0xc76>
8000c50e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c512:	40 3c       	lddsp	r12,sp[0xc]
8000c514:	58 0c       	cp.w	r12,0
8000c516:	c1 d0       	breq	8000c550 <_vfprintf_r+0xc30>
8000c518:	10 36       	cp.w	r6,r8
8000c51a:	c0 64       	brge	8000c526 <_vfprintf_r+0xc06>
8000c51c:	fa cb f9 44 	sub	r11,sp,-1724
8000c520:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c524:	c1 d8       	rjmp	8000c55e <_vfprintf_r+0xc3e>
8000c526:	fa c8 f9 50 	sub	r8,sp,-1712
8000c52a:	1a d8       	st.w	--sp,r8
8000c52c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c530:	04 9a       	mov	r10,r2
8000c532:	1a d8       	st.w	--sp,r8
8000c534:	fa c8 fb b4 	sub	r8,sp,-1100
8000c538:	0c 9b       	mov	r11,r6
8000c53a:	1a d8       	st.w	--sp,r8
8000c53c:	08 9c       	mov	r12,r4
8000c53e:	fa c8 f9 40 	sub	r8,sp,-1728
8000c542:	fa c9 ff b4 	sub	r9,sp,-76
8000c546:	fe b0 f8 55 	rcall	8000b5f0 <get_arg>
8000c54a:	2f dd       	sub	sp,-12
8000c54c:	78 0a       	ld.w	r10,r12[0x0]
8000c54e:	c2 08       	rjmp	8000c58e <_vfprintf_r+0xc6e>
8000c550:	2f f7       	sub	r7,-1
8000c552:	10 39       	cp.w	r9,r8
8000c554:	c0 84       	brge	8000c564 <_vfprintf_r+0xc44>
8000c556:	fa ca f9 44 	sub	r10,sp,-1724
8000c55a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c55e:	ec fa fd 88 	ld.w	r10,r6[-632]
8000c562:	c1 68       	rjmp	8000c58e <_vfprintf_r+0xc6e>
8000c564:	41 09       	lddsp	r9,sp[0x40]
8000c566:	59 f8       	cp.w	r8,31
8000c568:	e0 89 00 10 	brgt	8000c588 <_vfprintf_r+0xc68>
8000c56c:	f2 ca ff fc 	sub	r10,r9,-4
8000c570:	51 0a       	stdsp	sp[0x40],r10
8000c572:	fa c6 f9 44 	sub	r6,sp,-1724
8000c576:	72 0a       	ld.w	r10,r9[0x0]
8000c578:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c57c:	f3 4a fd 88 	st.w	r9[-632],r10
8000c580:	2f f8       	sub	r8,-1
8000c582:	fb 48 06 b4 	st.w	sp[1716],r8
8000c586:	c0 48       	rjmp	8000c58e <_vfprintf_r+0xc6e>
8000c588:	72 0a       	ld.w	r10,r9[0x0]
8000c58a:	2f c9       	sub	r9,-4
8000c58c:	51 09       	stdsp	sp[0x40],r9
8000c58e:	40 be       	lddsp	lr,sp[0x2c]
8000c590:	b4 0e       	st.h	r10[0x0],lr
8000c592:	fe 9f fa 55 	bral	8000ba3c <_vfprintf_r+0x11c>
8000c596:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c59a:	40 3c       	lddsp	r12,sp[0xc]
8000c59c:	58 0c       	cp.w	r12,0
8000c59e:	c1 d0       	breq	8000c5d8 <_vfprintf_r+0xcb8>
8000c5a0:	10 36       	cp.w	r6,r8
8000c5a2:	c0 64       	brge	8000c5ae <_vfprintf_r+0xc8e>
8000c5a4:	fa cb f9 44 	sub	r11,sp,-1724
8000c5a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c5ac:	c1 d8       	rjmp	8000c5e6 <_vfprintf_r+0xcc6>
8000c5ae:	fa c8 f9 50 	sub	r8,sp,-1712
8000c5b2:	1a d8       	st.w	--sp,r8
8000c5b4:	fa c8 fa b8 	sub	r8,sp,-1352
8000c5b8:	04 9a       	mov	r10,r2
8000c5ba:	1a d8       	st.w	--sp,r8
8000c5bc:	fa c8 fb b4 	sub	r8,sp,-1100
8000c5c0:	0c 9b       	mov	r11,r6
8000c5c2:	1a d8       	st.w	--sp,r8
8000c5c4:	08 9c       	mov	r12,r4
8000c5c6:	fa c8 f9 40 	sub	r8,sp,-1728
8000c5ca:	fa c9 ff b4 	sub	r9,sp,-76
8000c5ce:	fe b0 f8 11 	rcall	8000b5f0 <get_arg>
8000c5d2:	2f dd       	sub	sp,-12
8000c5d4:	78 0a       	ld.w	r10,r12[0x0]
8000c5d6:	c2 08       	rjmp	8000c616 <_vfprintf_r+0xcf6>
8000c5d8:	2f f7       	sub	r7,-1
8000c5da:	10 39       	cp.w	r9,r8
8000c5dc:	c0 84       	brge	8000c5ec <_vfprintf_r+0xccc>
8000c5de:	fa ca f9 44 	sub	r10,sp,-1724
8000c5e2:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c5e6:	ec fa fd 88 	ld.w	r10,r6[-632]
8000c5ea:	c1 68       	rjmp	8000c616 <_vfprintf_r+0xcf6>
8000c5ec:	41 09       	lddsp	r9,sp[0x40]
8000c5ee:	59 f8       	cp.w	r8,31
8000c5f0:	e0 89 00 10 	brgt	8000c610 <_vfprintf_r+0xcf0>
8000c5f4:	f2 ca ff fc 	sub	r10,r9,-4
8000c5f8:	51 0a       	stdsp	sp[0x40],r10
8000c5fa:	fa c6 f9 44 	sub	r6,sp,-1724
8000c5fe:	72 0a       	ld.w	r10,r9[0x0]
8000c600:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c604:	f3 4a fd 88 	st.w	r9[-632],r10
8000c608:	2f f8       	sub	r8,-1
8000c60a:	fb 48 06 b4 	st.w	sp[1716],r8
8000c60e:	c0 48       	rjmp	8000c616 <_vfprintf_r+0xcf6>
8000c610:	72 0a       	ld.w	r10,r9[0x0]
8000c612:	2f c9       	sub	r9,-4
8000c614:	51 09       	stdsp	sp[0x40],r9
8000c616:	40 be       	lddsp	lr,sp[0x2c]
8000c618:	95 0e       	st.w	r10[0x0],lr
8000c61a:	fe 9f fa 11 	bral	8000ba3c <_vfprintf_r+0x11c>
8000c61e:	50 a7       	stdsp	sp[0x28],r7
8000c620:	50 80       	stdsp	sp[0x20],r0
8000c622:	0c 97       	mov	r7,r6
8000c624:	04 94       	mov	r4,r2
8000c626:	06 96       	mov	r6,r3
8000c628:	02 92       	mov	r2,r1
8000c62a:	40 93       	lddsp	r3,sp[0x24]
8000c62c:	10 90       	mov	r0,r8
8000c62e:	40 41       	lddsp	r1,sp[0x10]
8000c630:	a5 a5       	sbr	r5,0x4
8000c632:	c0 a8       	rjmp	8000c646 <_vfprintf_r+0xd26>
8000c634:	50 a7       	stdsp	sp[0x28],r7
8000c636:	50 80       	stdsp	sp[0x20],r0
8000c638:	0c 97       	mov	r7,r6
8000c63a:	04 94       	mov	r4,r2
8000c63c:	06 96       	mov	r6,r3
8000c63e:	02 92       	mov	r2,r1
8000c640:	40 93       	lddsp	r3,sp[0x24]
8000c642:	10 90       	mov	r0,r8
8000c644:	40 41       	lddsp	r1,sp[0x10]
8000c646:	ed b5 00 05 	bld	r5,0x5
8000c64a:	c5 d1       	brne	8000c704 <_vfprintf_r+0xde4>
8000c64c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c650:	40 3c       	lddsp	r12,sp[0xc]
8000c652:	58 0c       	cp.w	r12,0
8000c654:	c2 60       	breq	8000c6a0 <_vfprintf_r+0xd80>
8000c656:	10 36       	cp.w	r6,r8
8000c658:	c0 a4       	brge	8000c66c <_vfprintf_r+0xd4c>
8000c65a:	fa cb f9 44 	sub	r11,sp,-1724
8000c65e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c662:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000c666:	fa e9 00 00 	st.d	sp[0],r8
8000c66a:	c1 88       	rjmp	8000c69a <_vfprintf_r+0xd7a>
8000c66c:	fa c8 f9 50 	sub	r8,sp,-1712
8000c670:	1a d8       	st.w	--sp,r8
8000c672:	fa c8 fa b8 	sub	r8,sp,-1352
8000c676:	04 9a       	mov	r10,r2
8000c678:	1a d8       	st.w	--sp,r8
8000c67a:	0c 9b       	mov	r11,r6
8000c67c:	fa c8 fb b4 	sub	r8,sp,-1100
8000c680:	08 9c       	mov	r12,r4
8000c682:	1a d8       	st.w	--sp,r8
8000c684:	fa c8 f9 40 	sub	r8,sp,-1728
8000c688:	fa c9 ff b4 	sub	r9,sp,-76
8000c68c:	fe b0 f7 b2 	rcall	8000b5f0 <get_arg>
8000c690:	2f dd       	sub	sp,-12
8000c692:	f8 ea 00 00 	ld.d	r10,r12[0]
8000c696:	fa eb 00 00 	st.d	sp[0],r10
8000c69a:	30 08       	mov	r8,0
8000c69c:	e0 8f 03 de 	bral	8000ce58 <_vfprintf_r+0x1538>
8000c6a0:	ee ca ff ff 	sub	r10,r7,-1
8000c6a4:	10 37       	cp.w	r7,r8
8000c6a6:	c0 b4       	brge	8000c6bc <_vfprintf_r+0xd9c>
8000c6a8:	fa c9 f9 44 	sub	r9,sp,-1724
8000c6ac:	14 97       	mov	r7,r10
8000c6ae:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c6b2:	ec ea fd 88 	ld.d	r10,r6[-632]
8000c6b6:	fa eb 00 00 	st.d	sp[0],r10
8000c6ba:	c1 88       	rjmp	8000c6ea <_vfprintf_r+0xdca>
8000c6bc:	41 09       	lddsp	r9,sp[0x40]
8000c6be:	59 f8       	cp.w	r8,31
8000c6c0:	e0 89 00 18 	brgt	8000c6f0 <_vfprintf_r+0xdd0>
8000c6c4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c6c8:	f2 cb ff f8 	sub	r11,r9,-8
8000c6cc:	fa e7 00 00 	st.d	sp[0],r6
8000c6d0:	51 0b       	stdsp	sp[0x40],r11
8000c6d2:	fa c6 f9 44 	sub	r6,sp,-1724
8000c6d6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c6da:	fa e6 00 00 	ld.d	r6,sp[0]
8000c6de:	f2 e7 fd 88 	st.d	r9[-632],r6
8000c6e2:	2f f8       	sub	r8,-1
8000c6e4:	14 97       	mov	r7,r10
8000c6e6:	fb 48 06 b4 	st.w	sp[1716],r8
8000c6ea:	40 38       	lddsp	r8,sp[0xc]
8000c6ec:	e0 8f 03 b6 	bral	8000ce58 <_vfprintf_r+0x1538>
8000c6f0:	f2 e6 00 00 	ld.d	r6,r9[0]
8000c6f4:	40 38       	lddsp	r8,sp[0xc]
8000c6f6:	fa e7 00 00 	st.d	sp[0],r6
8000c6fa:	2f 89       	sub	r9,-8
8000c6fc:	14 97       	mov	r7,r10
8000c6fe:	51 09       	stdsp	sp[0x40],r9
8000c700:	e0 8f 03 ac 	bral	8000ce58 <_vfprintf_r+0x1538>
8000c704:	ed b5 00 04 	bld	r5,0x4
8000c708:	c1 61       	brne	8000c734 <_vfprintf_r+0xe14>
8000c70a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c70e:	40 3e       	lddsp	lr,sp[0xc]
8000c710:	58 0e       	cp.w	lr,0
8000c712:	c0 80       	breq	8000c722 <_vfprintf_r+0xe02>
8000c714:	10 36       	cp.w	r6,r8
8000c716:	c6 74       	brge	8000c7e4 <_vfprintf_r+0xec4>
8000c718:	fa cc f9 44 	sub	r12,sp,-1724
8000c71c:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000c720:	c8 08       	rjmp	8000c820 <_vfprintf_r+0xf00>
8000c722:	ee ca ff ff 	sub	r10,r7,-1
8000c726:	10 37       	cp.w	r7,r8
8000c728:	c7 f4       	brge	8000c826 <_vfprintf_r+0xf06>
8000c72a:	fa cb f9 44 	sub	r11,sp,-1724
8000c72e:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c732:	c7 68       	rjmp	8000c81e <_vfprintf_r+0xefe>
8000c734:	ed b5 00 06 	bld	r5,0x6
8000c738:	c4 a1       	brne	8000c7cc <_vfprintf_r+0xeac>
8000c73a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c73e:	40 3c       	lddsp	r12,sp[0xc]
8000c740:	58 0c       	cp.w	r12,0
8000c742:	c1 d0       	breq	8000c77c <_vfprintf_r+0xe5c>
8000c744:	10 36       	cp.w	r6,r8
8000c746:	c0 64       	brge	8000c752 <_vfprintf_r+0xe32>
8000c748:	fa cb f9 44 	sub	r11,sp,-1724
8000c74c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c750:	c1 f8       	rjmp	8000c78e <_vfprintf_r+0xe6e>
8000c752:	fa c8 f9 50 	sub	r8,sp,-1712
8000c756:	1a d8       	st.w	--sp,r8
8000c758:	fa c8 fa b8 	sub	r8,sp,-1352
8000c75c:	1a d8       	st.w	--sp,r8
8000c75e:	fa c8 fb b4 	sub	r8,sp,-1100
8000c762:	1a d8       	st.w	--sp,r8
8000c764:	fa c8 f9 40 	sub	r8,sp,-1728
8000c768:	fa c9 ff b4 	sub	r9,sp,-76
8000c76c:	04 9a       	mov	r10,r2
8000c76e:	0c 9b       	mov	r11,r6
8000c770:	08 9c       	mov	r12,r4
8000c772:	fe b0 f7 3f 	rcall	8000b5f0 <get_arg>
8000c776:	2f dd       	sub	sp,-12
8000c778:	98 18       	ld.sh	r8,r12[0x2]
8000c77a:	c2 68       	rjmp	8000c7c6 <_vfprintf_r+0xea6>
8000c77c:	ee ca ff ff 	sub	r10,r7,-1
8000c780:	10 37       	cp.w	r7,r8
8000c782:	c0 94       	brge	8000c794 <_vfprintf_r+0xe74>
8000c784:	fa c9 f9 44 	sub	r9,sp,-1724
8000c788:	14 97       	mov	r7,r10
8000c78a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c78e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000c792:	c1 a8       	rjmp	8000c7c6 <_vfprintf_r+0xea6>
8000c794:	41 09       	lddsp	r9,sp[0x40]
8000c796:	59 f8       	cp.w	r8,31
8000c798:	e0 89 00 13 	brgt	8000c7be <_vfprintf_r+0xe9e>
8000c79c:	f2 cb ff fc 	sub	r11,r9,-4
8000c7a0:	51 0b       	stdsp	sp[0x40],r11
8000c7a2:	72 09       	ld.w	r9,r9[0x0]
8000c7a4:	fa c6 f9 44 	sub	r6,sp,-1724
8000c7a8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000c7ac:	2f f8       	sub	r8,-1
8000c7ae:	f7 49 fd 88 	st.w	r11[-632],r9
8000c7b2:	fb 48 06 b4 	st.w	sp[1716],r8
8000c7b6:	14 97       	mov	r7,r10
8000c7b8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000c7bc:	c0 58       	rjmp	8000c7c6 <_vfprintf_r+0xea6>
8000c7be:	92 18       	ld.sh	r8,r9[0x2]
8000c7c0:	14 97       	mov	r7,r10
8000c7c2:	2f c9       	sub	r9,-4
8000c7c4:	51 09       	stdsp	sp[0x40],r9
8000c7c6:	5c 78       	castu.h	r8
8000c7c8:	50 18       	stdsp	sp[0x4],r8
8000c7ca:	c4 68       	rjmp	8000c856 <_vfprintf_r+0xf36>
8000c7cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c7d0:	40 3c       	lddsp	r12,sp[0xc]
8000c7d2:	58 0c       	cp.w	r12,0
8000c7d4:	c1 d0       	breq	8000c80e <_vfprintf_r+0xeee>
8000c7d6:	10 36       	cp.w	r6,r8
8000c7d8:	c0 64       	brge	8000c7e4 <_vfprintf_r+0xec4>
8000c7da:	fa cb f9 44 	sub	r11,sp,-1724
8000c7de:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c7e2:	c1 f8       	rjmp	8000c820 <_vfprintf_r+0xf00>
8000c7e4:	fa c8 f9 50 	sub	r8,sp,-1712
8000c7e8:	1a d8       	st.w	--sp,r8
8000c7ea:	fa c8 fa b8 	sub	r8,sp,-1352
8000c7ee:	0c 9b       	mov	r11,r6
8000c7f0:	1a d8       	st.w	--sp,r8
8000c7f2:	fa c8 fb b4 	sub	r8,sp,-1100
8000c7f6:	04 9a       	mov	r10,r2
8000c7f8:	1a d8       	st.w	--sp,r8
8000c7fa:	08 9c       	mov	r12,r4
8000c7fc:	fa c8 f9 40 	sub	r8,sp,-1728
8000c800:	fa c9 ff b4 	sub	r9,sp,-76
8000c804:	fe b0 f6 f6 	rcall	8000b5f0 <get_arg>
8000c808:	2f dd       	sub	sp,-12
8000c80a:	78 0b       	ld.w	r11,r12[0x0]
8000c80c:	c2 48       	rjmp	8000c854 <_vfprintf_r+0xf34>
8000c80e:	ee ca ff ff 	sub	r10,r7,-1
8000c812:	10 37       	cp.w	r7,r8
8000c814:	c0 94       	brge	8000c826 <_vfprintf_r+0xf06>
8000c816:	fa c9 f9 44 	sub	r9,sp,-1724
8000c81a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c81e:	14 97       	mov	r7,r10
8000c820:	ec fb fd 88 	ld.w	r11,r6[-632]
8000c824:	c1 88       	rjmp	8000c854 <_vfprintf_r+0xf34>
8000c826:	41 09       	lddsp	r9,sp[0x40]
8000c828:	59 f8       	cp.w	r8,31
8000c82a:	e0 89 00 11 	brgt	8000c84c <_vfprintf_r+0xf2c>
8000c82e:	f2 cb ff fc 	sub	r11,r9,-4
8000c832:	51 0b       	stdsp	sp[0x40],r11
8000c834:	fa c6 f9 44 	sub	r6,sp,-1724
8000c838:	72 0b       	ld.w	r11,r9[0x0]
8000c83a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000c83e:	f3 4b fd 88 	st.w	r9[-632],r11
8000c842:	2f f8       	sub	r8,-1
8000c844:	14 97       	mov	r7,r10
8000c846:	fb 48 06 b4 	st.w	sp[1716],r8
8000c84a:	c0 58       	rjmp	8000c854 <_vfprintf_r+0xf34>
8000c84c:	72 0b       	ld.w	r11,r9[0x0]
8000c84e:	14 97       	mov	r7,r10
8000c850:	2f c9       	sub	r9,-4
8000c852:	51 09       	stdsp	sp[0x40],r9
8000c854:	50 1b       	stdsp	sp[0x4],r11
8000c856:	30 0e       	mov	lr,0
8000c858:	50 0e       	stdsp	sp[0x0],lr
8000c85a:	1c 98       	mov	r8,lr
8000c85c:	e0 8f 02 fe 	bral	8000ce58 <_vfprintf_r+0x1538>
8000c860:	50 a7       	stdsp	sp[0x28],r7
8000c862:	50 80       	stdsp	sp[0x20],r0
8000c864:	0c 97       	mov	r7,r6
8000c866:	04 94       	mov	r4,r2
8000c868:	06 96       	mov	r6,r3
8000c86a:	02 92       	mov	r2,r1
8000c86c:	40 93       	lddsp	r3,sp[0x24]
8000c86e:	40 41       	lddsp	r1,sp[0x10]
8000c870:	0e 99       	mov	r9,r7
8000c872:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c876:	40 3c       	lddsp	r12,sp[0xc]
8000c878:	58 0c       	cp.w	r12,0
8000c87a:	c1 d0       	breq	8000c8b4 <_vfprintf_r+0xf94>
8000c87c:	10 36       	cp.w	r6,r8
8000c87e:	c0 64       	brge	8000c88a <_vfprintf_r+0xf6a>
8000c880:	fa cb f9 44 	sub	r11,sp,-1724
8000c884:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c888:	c1 d8       	rjmp	8000c8c2 <_vfprintf_r+0xfa2>
8000c88a:	fa c8 f9 50 	sub	r8,sp,-1712
8000c88e:	1a d8       	st.w	--sp,r8
8000c890:	fa c8 fa b8 	sub	r8,sp,-1352
8000c894:	1a d8       	st.w	--sp,r8
8000c896:	fa c8 fb b4 	sub	r8,sp,-1100
8000c89a:	1a d8       	st.w	--sp,r8
8000c89c:	fa c9 ff b4 	sub	r9,sp,-76
8000c8a0:	fa c8 f9 40 	sub	r8,sp,-1728
8000c8a4:	04 9a       	mov	r10,r2
8000c8a6:	0c 9b       	mov	r11,r6
8000c8a8:	08 9c       	mov	r12,r4
8000c8aa:	fe b0 f6 a3 	rcall	8000b5f0 <get_arg>
8000c8ae:	2f dd       	sub	sp,-12
8000c8b0:	78 09       	ld.w	r9,r12[0x0]
8000c8b2:	c2 18       	rjmp	8000c8f4 <_vfprintf_r+0xfd4>
8000c8b4:	2f f7       	sub	r7,-1
8000c8b6:	10 39       	cp.w	r9,r8
8000c8b8:	c0 84       	brge	8000c8c8 <_vfprintf_r+0xfa8>
8000c8ba:	fa ca f9 44 	sub	r10,sp,-1724
8000c8be:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c8c2:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000c8c6:	c1 78       	rjmp	8000c8f4 <_vfprintf_r+0xfd4>
8000c8c8:	41 09       	lddsp	r9,sp[0x40]
8000c8ca:	59 f8       	cp.w	r8,31
8000c8cc:	e0 89 00 10 	brgt	8000c8ec <_vfprintf_r+0xfcc>
8000c8d0:	f2 ca ff fc 	sub	r10,r9,-4
8000c8d4:	51 0a       	stdsp	sp[0x40],r10
8000c8d6:	fa c6 f9 44 	sub	r6,sp,-1724
8000c8da:	72 09       	ld.w	r9,r9[0x0]
8000c8dc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000c8e0:	f5 49 fd 88 	st.w	r10[-632],r9
8000c8e4:	2f f8       	sub	r8,-1
8000c8e6:	fb 48 06 b4 	st.w	sp[1716],r8
8000c8ea:	c0 58       	rjmp	8000c8f4 <_vfprintf_r+0xfd4>
8000c8ec:	f2 c8 ff fc 	sub	r8,r9,-4
8000c8f0:	51 08       	stdsp	sp[0x40],r8
8000c8f2:	72 09       	ld.w	r9,r9[0x0]
8000c8f4:	33 08       	mov	r8,48
8000c8f6:	fb 68 06 b8 	st.b	sp[1720],r8
8000c8fa:	37 88       	mov	r8,120
8000c8fc:	30 0e       	mov	lr,0
8000c8fe:	fb 68 06 b9 	st.b	sp[1721],r8
8000c902:	fe cc ba 52 	sub	r12,pc,-17838
8000c906:	50 19       	stdsp	sp[0x4],r9
8000c908:	a1 b5       	sbr	r5,0x1
8000c90a:	50 0e       	stdsp	sp[0x0],lr
8000c90c:	50 dc       	stdsp	sp[0x34],r12
8000c90e:	30 28       	mov	r8,2
8000c910:	37 80       	mov	r0,120
8000c912:	e0 8f 02 a3 	bral	8000ce58 <_vfprintf_r+0x1538>
8000c916:	50 a7       	stdsp	sp[0x28],r7
8000c918:	50 80       	stdsp	sp[0x20],r0
8000c91a:	10 90       	mov	r0,r8
8000c91c:	30 08       	mov	r8,0
8000c91e:	fb 68 06 bb 	st.b	sp[1723],r8
8000c922:	0c 97       	mov	r7,r6
8000c924:	04 94       	mov	r4,r2
8000c926:	06 96       	mov	r6,r3
8000c928:	02 92       	mov	r2,r1
8000c92a:	40 93       	lddsp	r3,sp[0x24]
8000c92c:	40 41       	lddsp	r1,sp[0x10]
8000c92e:	0e 99       	mov	r9,r7
8000c930:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c934:	40 3b       	lddsp	r11,sp[0xc]
8000c936:	58 0b       	cp.w	r11,0
8000c938:	c1 d0       	breq	8000c972 <_vfprintf_r+0x1052>
8000c93a:	10 36       	cp.w	r6,r8
8000c93c:	c0 64       	brge	8000c948 <_vfprintf_r+0x1028>
8000c93e:	fa ca f9 44 	sub	r10,sp,-1724
8000c942:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c946:	c1 d8       	rjmp	8000c980 <_vfprintf_r+0x1060>
8000c948:	fa c8 f9 50 	sub	r8,sp,-1712
8000c94c:	1a d8       	st.w	--sp,r8
8000c94e:	fa c8 fa b8 	sub	r8,sp,-1352
8000c952:	1a d8       	st.w	--sp,r8
8000c954:	fa c8 fb b4 	sub	r8,sp,-1100
8000c958:	0c 9b       	mov	r11,r6
8000c95a:	1a d8       	st.w	--sp,r8
8000c95c:	04 9a       	mov	r10,r2
8000c95e:	fa c8 f9 40 	sub	r8,sp,-1728
8000c962:	fa c9 ff b4 	sub	r9,sp,-76
8000c966:	08 9c       	mov	r12,r4
8000c968:	fe b0 f6 44 	rcall	8000b5f0 <get_arg>
8000c96c:	2f dd       	sub	sp,-12
8000c96e:	78 06       	ld.w	r6,r12[0x0]
8000c970:	c2 08       	rjmp	8000c9b0 <_vfprintf_r+0x1090>
8000c972:	2f f7       	sub	r7,-1
8000c974:	10 39       	cp.w	r9,r8
8000c976:	c0 84       	brge	8000c986 <_vfprintf_r+0x1066>
8000c978:	fa c9 f9 44 	sub	r9,sp,-1724
8000c97c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c980:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000c984:	c1 68       	rjmp	8000c9b0 <_vfprintf_r+0x1090>
8000c986:	41 09       	lddsp	r9,sp[0x40]
8000c988:	59 f8       	cp.w	r8,31
8000c98a:	e0 89 00 10 	brgt	8000c9aa <_vfprintf_r+0x108a>
8000c98e:	f2 ca ff fc 	sub	r10,r9,-4
8000c992:	51 0a       	stdsp	sp[0x40],r10
8000c994:	72 06       	ld.w	r6,r9[0x0]
8000c996:	fa ce f9 44 	sub	lr,sp,-1724
8000c99a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000c99e:	f3 46 fd 88 	st.w	r9[-632],r6
8000c9a2:	2f f8       	sub	r8,-1
8000c9a4:	fb 48 06 b4 	st.w	sp[1716],r8
8000c9a8:	c0 48       	rjmp	8000c9b0 <_vfprintf_r+0x1090>
8000c9aa:	72 06       	ld.w	r6,r9[0x0]
8000c9ac:	2f c9       	sub	r9,-4
8000c9ae:	51 09       	stdsp	sp[0x40],r9
8000c9b0:	40 2c       	lddsp	r12,sp[0x8]
8000c9b2:	58 0c       	cp.w	r12,0
8000c9b4:	c1 05       	brlt	8000c9d4 <_vfprintf_r+0x10b4>
8000c9b6:	18 9a       	mov	r10,r12
8000c9b8:	30 0b       	mov	r11,0
8000c9ba:	0c 9c       	mov	r12,r6
8000c9bc:	e0 a0 12 38 	rcall	8000ee2c <memchr>
8000c9c0:	e0 80 02 df 	breq	8000cf7e <_vfprintf_r+0x165e>
8000c9c4:	f8 06 01 02 	sub	r2,r12,r6
8000c9c8:	40 2b       	lddsp	r11,sp[0x8]
8000c9ca:	16 32       	cp.w	r2,r11
8000c9cc:	e0 89 02 d9 	brgt	8000cf7e <_vfprintf_r+0x165e>
8000c9d0:	e0 8f 02 d4 	bral	8000cf78 <_vfprintf_r+0x1658>
8000c9d4:	30 0a       	mov	r10,0
8000c9d6:	0c 9c       	mov	r12,r6
8000c9d8:	50 2a       	stdsp	sp[0x8],r10
8000c9da:	fe b0 f5 85 	rcall	8000b4e4 <strlen>
8000c9de:	18 92       	mov	r2,r12
8000c9e0:	e0 8f 02 d2 	bral	8000cf84 <_vfprintf_r+0x1664>
8000c9e4:	50 a7       	stdsp	sp[0x28],r7
8000c9e6:	50 80       	stdsp	sp[0x20],r0
8000c9e8:	0c 97       	mov	r7,r6
8000c9ea:	04 94       	mov	r4,r2
8000c9ec:	06 96       	mov	r6,r3
8000c9ee:	02 92       	mov	r2,r1
8000c9f0:	40 93       	lddsp	r3,sp[0x24]
8000c9f2:	10 90       	mov	r0,r8
8000c9f4:	40 41       	lddsp	r1,sp[0x10]
8000c9f6:	a5 a5       	sbr	r5,0x4
8000c9f8:	c0 a8       	rjmp	8000ca0c <_vfprintf_r+0x10ec>
8000c9fa:	50 a7       	stdsp	sp[0x28],r7
8000c9fc:	50 80       	stdsp	sp[0x20],r0
8000c9fe:	0c 97       	mov	r7,r6
8000ca00:	04 94       	mov	r4,r2
8000ca02:	06 96       	mov	r6,r3
8000ca04:	02 92       	mov	r2,r1
8000ca06:	40 93       	lddsp	r3,sp[0x24]
8000ca08:	10 90       	mov	r0,r8
8000ca0a:	40 41       	lddsp	r1,sp[0x10]
8000ca0c:	ed b5 00 05 	bld	r5,0x5
8000ca10:	c5 61       	brne	8000cabc <_vfprintf_r+0x119c>
8000ca12:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ca16:	40 39       	lddsp	r9,sp[0xc]
8000ca18:	58 09       	cp.w	r9,0
8000ca1a:	c2 10       	breq	8000ca5c <_vfprintf_r+0x113c>
8000ca1c:	10 36       	cp.w	r6,r8
8000ca1e:	c0 74       	brge	8000ca2c <_vfprintf_r+0x110c>
8000ca20:	fa c8 f9 44 	sub	r8,sp,-1724
8000ca24:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000ca28:	c2 38       	rjmp	8000ca6e <_vfprintf_r+0x114e>
8000ca2a:	d7 03       	nop
8000ca2c:	fa c8 f9 50 	sub	r8,sp,-1712
8000ca30:	1a d8       	st.w	--sp,r8
8000ca32:	fa c8 fa b8 	sub	r8,sp,-1352
8000ca36:	1a d8       	st.w	--sp,r8
8000ca38:	fa c8 fb b4 	sub	r8,sp,-1100
8000ca3c:	1a d8       	st.w	--sp,r8
8000ca3e:	fa c8 f9 40 	sub	r8,sp,-1728
8000ca42:	fa c9 ff b4 	sub	r9,sp,-76
8000ca46:	04 9a       	mov	r10,r2
8000ca48:	0c 9b       	mov	r11,r6
8000ca4a:	08 9c       	mov	r12,r4
8000ca4c:	fe b0 f5 d2 	rcall	8000b5f0 <get_arg>
8000ca50:	2f dd       	sub	sp,-12
8000ca52:	f8 e8 00 00 	ld.d	r8,r12[0]
8000ca56:	fa e9 00 00 	st.d	sp[0],r8
8000ca5a:	c2 e8       	rjmp	8000cab6 <_vfprintf_r+0x1196>
8000ca5c:	ee ca ff ff 	sub	r10,r7,-1
8000ca60:	10 37       	cp.w	r7,r8
8000ca62:	c0 b4       	brge	8000ca78 <_vfprintf_r+0x1158>
8000ca64:	fa c8 f9 44 	sub	r8,sp,-1724
8000ca68:	14 97       	mov	r7,r10
8000ca6a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000ca6e:	ec ea fd 88 	ld.d	r10,r6[-632]
8000ca72:	fa eb 00 00 	st.d	sp[0],r10
8000ca76:	c2 08       	rjmp	8000cab6 <_vfprintf_r+0x1196>
8000ca78:	41 09       	lddsp	r9,sp[0x40]
8000ca7a:	59 f8       	cp.w	r8,31
8000ca7c:	e0 89 00 16 	brgt	8000caa8 <_vfprintf_r+0x1188>
8000ca80:	f2 e6 00 00 	ld.d	r6,r9[0]
8000ca84:	f2 cb ff f8 	sub	r11,r9,-8
8000ca88:	fa e7 00 00 	st.d	sp[0],r6
8000ca8c:	51 0b       	stdsp	sp[0x40],r11
8000ca8e:	fa c6 f9 44 	sub	r6,sp,-1724
8000ca92:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ca96:	fa e6 00 00 	ld.d	r6,sp[0]
8000ca9a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000ca9e:	2f f8       	sub	r8,-1
8000caa0:	14 97       	mov	r7,r10
8000caa2:	fb 48 06 b4 	st.w	sp[1716],r8
8000caa6:	c0 88       	rjmp	8000cab6 <_vfprintf_r+0x1196>
8000caa8:	f2 e6 00 00 	ld.d	r6,r9[0]
8000caac:	2f 89       	sub	r9,-8
8000caae:	fa e7 00 00 	st.d	sp[0],r6
8000cab2:	51 09       	stdsp	sp[0x40],r9
8000cab4:	14 97       	mov	r7,r10
8000cab6:	30 18       	mov	r8,1
8000cab8:	e0 8f 01 d0 	bral	8000ce58 <_vfprintf_r+0x1538>
8000cabc:	ed b5 00 04 	bld	r5,0x4
8000cac0:	c1 61       	brne	8000caec <_vfprintf_r+0x11cc>
8000cac2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cac6:	40 3e       	lddsp	lr,sp[0xc]
8000cac8:	58 0e       	cp.w	lr,0
8000caca:	c0 80       	breq	8000cada <_vfprintf_r+0x11ba>
8000cacc:	10 36       	cp.w	r6,r8
8000cace:	c6 74       	brge	8000cb9c <_vfprintf_r+0x127c>
8000cad0:	fa cc f9 44 	sub	r12,sp,-1724
8000cad4:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000cad8:	c8 08       	rjmp	8000cbd8 <_vfprintf_r+0x12b8>
8000cada:	ee ca ff ff 	sub	r10,r7,-1
8000cade:	10 37       	cp.w	r7,r8
8000cae0:	c7 f4       	brge	8000cbde <_vfprintf_r+0x12be>
8000cae2:	fa cb f9 44 	sub	r11,sp,-1724
8000cae6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000caea:	c7 68       	rjmp	8000cbd6 <_vfprintf_r+0x12b6>
8000caec:	ed b5 00 06 	bld	r5,0x6
8000caf0:	c4 a1       	brne	8000cb84 <_vfprintf_r+0x1264>
8000caf2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000caf6:	40 3c       	lddsp	r12,sp[0xc]
8000caf8:	58 0c       	cp.w	r12,0
8000cafa:	c1 d0       	breq	8000cb34 <_vfprintf_r+0x1214>
8000cafc:	10 36       	cp.w	r6,r8
8000cafe:	c0 64       	brge	8000cb0a <_vfprintf_r+0x11ea>
8000cb00:	fa cb f9 44 	sub	r11,sp,-1724
8000cb04:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cb08:	c1 f8       	rjmp	8000cb46 <_vfprintf_r+0x1226>
8000cb0a:	fa c8 f9 50 	sub	r8,sp,-1712
8000cb0e:	1a d8       	st.w	--sp,r8
8000cb10:	fa c8 fa b8 	sub	r8,sp,-1352
8000cb14:	1a d8       	st.w	--sp,r8
8000cb16:	fa c8 fb b4 	sub	r8,sp,-1100
8000cb1a:	1a d8       	st.w	--sp,r8
8000cb1c:	fa c8 f9 40 	sub	r8,sp,-1728
8000cb20:	fa c9 ff b4 	sub	r9,sp,-76
8000cb24:	04 9a       	mov	r10,r2
8000cb26:	0c 9b       	mov	r11,r6
8000cb28:	08 9c       	mov	r12,r4
8000cb2a:	fe b0 f5 63 	rcall	8000b5f0 <get_arg>
8000cb2e:	2f dd       	sub	sp,-12
8000cb30:	98 18       	ld.sh	r8,r12[0x2]
8000cb32:	c2 68       	rjmp	8000cb7e <_vfprintf_r+0x125e>
8000cb34:	ee ca ff ff 	sub	r10,r7,-1
8000cb38:	10 37       	cp.w	r7,r8
8000cb3a:	c0 94       	brge	8000cb4c <_vfprintf_r+0x122c>
8000cb3c:	fa c9 f9 44 	sub	r9,sp,-1724
8000cb40:	14 97       	mov	r7,r10
8000cb42:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cb46:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000cb4a:	c1 a8       	rjmp	8000cb7e <_vfprintf_r+0x125e>
8000cb4c:	41 09       	lddsp	r9,sp[0x40]
8000cb4e:	59 f8       	cp.w	r8,31
8000cb50:	e0 89 00 13 	brgt	8000cb76 <_vfprintf_r+0x1256>
8000cb54:	f2 cb ff fc 	sub	r11,r9,-4
8000cb58:	51 0b       	stdsp	sp[0x40],r11
8000cb5a:	72 09       	ld.w	r9,r9[0x0]
8000cb5c:	fa c6 f9 44 	sub	r6,sp,-1724
8000cb60:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000cb64:	2f f8       	sub	r8,-1
8000cb66:	f7 49 fd 88 	st.w	r11[-632],r9
8000cb6a:	fb 48 06 b4 	st.w	sp[1716],r8
8000cb6e:	14 97       	mov	r7,r10
8000cb70:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000cb74:	c0 58       	rjmp	8000cb7e <_vfprintf_r+0x125e>
8000cb76:	92 18       	ld.sh	r8,r9[0x2]
8000cb78:	14 97       	mov	r7,r10
8000cb7a:	2f c9       	sub	r9,-4
8000cb7c:	51 09       	stdsp	sp[0x40],r9
8000cb7e:	5c 78       	castu.h	r8
8000cb80:	50 18       	stdsp	sp[0x4],r8
8000cb82:	c4 68       	rjmp	8000cc0e <_vfprintf_r+0x12ee>
8000cb84:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cb88:	40 3c       	lddsp	r12,sp[0xc]
8000cb8a:	58 0c       	cp.w	r12,0
8000cb8c:	c1 d0       	breq	8000cbc6 <_vfprintf_r+0x12a6>
8000cb8e:	10 36       	cp.w	r6,r8
8000cb90:	c0 64       	brge	8000cb9c <_vfprintf_r+0x127c>
8000cb92:	fa cb f9 44 	sub	r11,sp,-1724
8000cb96:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cb9a:	c1 f8       	rjmp	8000cbd8 <_vfprintf_r+0x12b8>
8000cb9c:	fa c8 f9 50 	sub	r8,sp,-1712
8000cba0:	1a d8       	st.w	--sp,r8
8000cba2:	fa c8 fa b8 	sub	r8,sp,-1352
8000cba6:	0c 9b       	mov	r11,r6
8000cba8:	1a d8       	st.w	--sp,r8
8000cbaa:	fa c8 fb b4 	sub	r8,sp,-1100
8000cbae:	04 9a       	mov	r10,r2
8000cbb0:	1a d8       	st.w	--sp,r8
8000cbb2:	08 9c       	mov	r12,r4
8000cbb4:	fa c8 f9 40 	sub	r8,sp,-1728
8000cbb8:	fa c9 ff b4 	sub	r9,sp,-76
8000cbbc:	fe b0 f5 1a 	rcall	8000b5f0 <get_arg>
8000cbc0:	2f dd       	sub	sp,-12
8000cbc2:	78 0b       	ld.w	r11,r12[0x0]
8000cbc4:	c2 48       	rjmp	8000cc0c <_vfprintf_r+0x12ec>
8000cbc6:	ee ca ff ff 	sub	r10,r7,-1
8000cbca:	10 37       	cp.w	r7,r8
8000cbcc:	c0 94       	brge	8000cbde <_vfprintf_r+0x12be>
8000cbce:	fa c9 f9 44 	sub	r9,sp,-1724
8000cbd2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cbd6:	14 97       	mov	r7,r10
8000cbd8:	ec fb fd 88 	ld.w	r11,r6[-632]
8000cbdc:	c1 88       	rjmp	8000cc0c <_vfprintf_r+0x12ec>
8000cbde:	41 09       	lddsp	r9,sp[0x40]
8000cbe0:	59 f8       	cp.w	r8,31
8000cbe2:	e0 89 00 11 	brgt	8000cc04 <_vfprintf_r+0x12e4>
8000cbe6:	f2 cb ff fc 	sub	r11,r9,-4
8000cbea:	51 0b       	stdsp	sp[0x40],r11
8000cbec:	fa c6 f9 44 	sub	r6,sp,-1724
8000cbf0:	72 0b       	ld.w	r11,r9[0x0]
8000cbf2:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000cbf6:	f3 4b fd 88 	st.w	r9[-632],r11
8000cbfa:	2f f8       	sub	r8,-1
8000cbfc:	14 97       	mov	r7,r10
8000cbfe:	fb 48 06 b4 	st.w	sp[1716],r8
8000cc02:	c0 58       	rjmp	8000cc0c <_vfprintf_r+0x12ec>
8000cc04:	72 0b       	ld.w	r11,r9[0x0]
8000cc06:	14 97       	mov	r7,r10
8000cc08:	2f c9       	sub	r9,-4
8000cc0a:	51 09       	stdsp	sp[0x40],r9
8000cc0c:	50 1b       	stdsp	sp[0x4],r11
8000cc0e:	30 0e       	mov	lr,0
8000cc10:	30 18       	mov	r8,1
8000cc12:	50 0e       	stdsp	sp[0x0],lr
8000cc14:	c2 29       	rjmp	8000ce58 <_vfprintf_r+0x1538>
8000cc16:	50 a7       	stdsp	sp[0x28],r7
8000cc18:	50 80       	stdsp	sp[0x20],r0
8000cc1a:	0c 97       	mov	r7,r6
8000cc1c:	04 94       	mov	r4,r2
8000cc1e:	06 96       	mov	r6,r3
8000cc20:	02 92       	mov	r2,r1
8000cc22:	fe cc bd 72 	sub	r12,pc,-17038
8000cc26:	40 93       	lddsp	r3,sp[0x24]
8000cc28:	10 90       	mov	r0,r8
8000cc2a:	40 41       	lddsp	r1,sp[0x10]
8000cc2c:	50 dc       	stdsp	sp[0x34],r12
8000cc2e:	ed b5 00 05 	bld	r5,0x5
8000cc32:	c5 51       	brne	8000ccdc <_vfprintf_r+0x13bc>
8000cc34:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cc38:	40 3b       	lddsp	r11,sp[0xc]
8000cc3a:	58 0b       	cp.w	r11,0
8000cc3c:	c2 20       	breq	8000cc80 <_vfprintf_r+0x1360>
8000cc3e:	10 36       	cp.w	r6,r8
8000cc40:	c0 a4       	brge	8000cc54 <_vfprintf_r+0x1334>
8000cc42:	fa ca f9 44 	sub	r10,sp,-1724
8000cc46:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000cc4a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000cc4e:	fa e9 00 00 	st.d	sp[0],r8
8000cc52:	cf 28       	rjmp	8000ce36 <_vfprintf_r+0x1516>
8000cc54:	fa c8 f9 50 	sub	r8,sp,-1712
8000cc58:	1a d8       	st.w	--sp,r8
8000cc5a:	fa c8 fa b8 	sub	r8,sp,-1352
8000cc5e:	04 9a       	mov	r10,r2
8000cc60:	1a d8       	st.w	--sp,r8
8000cc62:	0c 9b       	mov	r11,r6
8000cc64:	fa c8 fb b4 	sub	r8,sp,-1100
8000cc68:	08 9c       	mov	r12,r4
8000cc6a:	1a d8       	st.w	--sp,r8
8000cc6c:	fa c8 f9 40 	sub	r8,sp,-1728
8000cc70:	fa c9 ff b4 	sub	r9,sp,-76
8000cc74:	fe b0 f4 be 	rcall	8000b5f0 <get_arg>
8000cc78:	2f dd       	sub	sp,-12
8000cc7a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000cc7e:	c0 c8       	rjmp	8000cc96 <_vfprintf_r+0x1376>
8000cc80:	ee ca ff ff 	sub	r10,r7,-1
8000cc84:	10 37       	cp.w	r7,r8
8000cc86:	c0 b4       	brge	8000cc9c <_vfprintf_r+0x137c>
8000cc88:	fa c9 f9 44 	sub	r9,sp,-1724
8000cc8c:	14 97       	mov	r7,r10
8000cc8e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cc92:	ec ea fd 88 	ld.d	r10,r6[-632]
8000cc96:	fa eb 00 00 	st.d	sp[0],r10
8000cc9a:	cc e8       	rjmp	8000ce36 <_vfprintf_r+0x1516>
8000cc9c:	41 09       	lddsp	r9,sp[0x40]
8000cc9e:	59 f8       	cp.w	r8,31
8000cca0:	e0 89 00 16 	brgt	8000cccc <_vfprintf_r+0x13ac>
8000cca4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000cca8:	f2 cb ff f8 	sub	r11,r9,-8
8000ccac:	fa e7 00 00 	st.d	sp[0],r6
8000ccb0:	51 0b       	stdsp	sp[0x40],r11
8000ccb2:	fa c6 f9 44 	sub	r6,sp,-1724
8000ccb6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ccba:	fa e6 00 00 	ld.d	r6,sp[0]
8000ccbe:	f2 e7 fd 88 	st.d	r9[-632],r6
8000ccc2:	2f f8       	sub	r8,-1
8000ccc4:	14 97       	mov	r7,r10
8000ccc6:	fb 48 06 b4 	st.w	sp[1716],r8
8000ccca:	cb 68       	rjmp	8000ce36 <_vfprintf_r+0x1516>
8000cccc:	f2 e6 00 00 	ld.d	r6,r9[0]
8000ccd0:	2f 89       	sub	r9,-8
8000ccd2:	fa e7 00 00 	st.d	sp[0],r6
8000ccd6:	51 09       	stdsp	sp[0x40],r9
8000ccd8:	14 97       	mov	r7,r10
8000ccda:	ca e8       	rjmp	8000ce36 <_vfprintf_r+0x1516>
8000ccdc:	ed b5 00 04 	bld	r5,0x4
8000cce0:	c1 71       	brne	8000cd0e <_vfprintf_r+0x13ee>
8000cce2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cce6:	40 3e       	lddsp	lr,sp[0xc]
8000cce8:	58 0e       	cp.w	lr,0
8000ccea:	c0 80       	breq	8000ccfa <_vfprintf_r+0x13da>
8000ccec:	10 36       	cp.w	r6,r8
8000ccee:	c6 94       	brge	8000cdc0 <_vfprintf_r+0x14a0>
8000ccf0:	fa cc f9 44 	sub	r12,sp,-1724
8000ccf4:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000ccf8:	c8 28       	rjmp	8000cdfc <_vfprintf_r+0x14dc>
8000ccfa:	ee ca ff ff 	sub	r10,r7,-1
8000ccfe:	10 37       	cp.w	r7,r8
8000cd00:	e0 84 00 81 	brge	8000ce02 <_vfprintf_r+0x14e2>
8000cd04:	fa cb f9 44 	sub	r11,sp,-1724
8000cd08:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cd0c:	c7 78       	rjmp	8000cdfa <_vfprintf_r+0x14da>
8000cd0e:	ed b5 00 06 	bld	r5,0x6
8000cd12:	c4 b1       	brne	8000cda8 <_vfprintf_r+0x1488>
8000cd14:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cd18:	40 3c       	lddsp	r12,sp[0xc]
8000cd1a:	58 0c       	cp.w	r12,0
8000cd1c:	c1 d0       	breq	8000cd56 <_vfprintf_r+0x1436>
8000cd1e:	10 36       	cp.w	r6,r8
8000cd20:	c0 64       	brge	8000cd2c <_vfprintf_r+0x140c>
8000cd22:	fa cb f9 44 	sub	r11,sp,-1724
8000cd26:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cd2a:	c1 f8       	rjmp	8000cd68 <_vfprintf_r+0x1448>
8000cd2c:	fa c8 f9 50 	sub	r8,sp,-1712
8000cd30:	1a d8       	st.w	--sp,r8
8000cd32:	fa c8 fa b8 	sub	r8,sp,-1352
8000cd36:	1a d8       	st.w	--sp,r8
8000cd38:	fa c8 fb b4 	sub	r8,sp,-1100
8000cd3c:	1a d8       	st.w	--sp,r8
8000cd3e:	fa c8 f9 40 	sub	r8,sp,-1728
8000cd42:	fa c9 ff b4 	sub	r9,sp,-76
8000cd46:	04 9a       	mov	r10,r2
8000cd48:	0c 9b       	mov	r11,r6
8000cd4a:	08 9c       	mov	r12,r4
8000cd4c:	fe b0 f4 52 	rcall	8000b5f0 <get_arg>
8000cd50:	2f dd       	sub	sp,-12
8000cd52:	98 18       	ld.sh	r8,r12[0x2]
8000cd54:	c2 78       	rjmp	8000cda2 <_vfprintf_r+0x1482>
8000cd56:	ee ca ff ff 	sub	r10,r7,-1
8000cd5a:	10 37       	cp.w	r7,r8
8000cd5c:	c0 a4       	brge	8000cd70 <_vfprintf_r+0x1450>
8000cd5e:	fa c9 f9 44 	sub	r9,sp,-1724
8000cd62:	14 97       	mov	r7,r10
8000cd64:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cd68:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000cd6c:	c1 b8       	rjmp	8000cda2 <_vfprintf_r+0x1482>
8000cd6e:	d7 03       	nop
8000cd70:	41 09       	lddsp	r9,sp[0x40]
8000cd72:	59 f8       	cp.w	r8,31
8000cd74:	e0 89 00 13 	brgt	8000cd9a <_vfprintf_r+0x147a>
8000cd78:	f2 cb ff fc 	sub	r11,r9,-4
8000cd7c:	51 0b       	stdsp	sp[0x40],r11
8000cd7e:	72 09       	ld.w	r9,r9[0x0]
8000cd80:	fa c6 f9 44 	sub	r6,sp,-1724
8000cd84:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000cd88:	2f f8       	sub	r8,-1
8000cd8a:	f7 49 fd 88 	st.w	r11[-632],r9
8000cd8e:	fb 48 06 b4 	st.w	sp[1716],r8
8000cd92:	14 97       	mov	r7,r10
8000cd94:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000cd98:	c0 58       	rjmp	8000cda2 <_vfprintf_r+0x1482>
8000cd9a:	92 18       	ld.sh	r8,r9[0x2]
8000cd9c:	14 97       	mov	r7,r10
8000cd9e:	2f c9       	sub	r9,-4
8000cda0:	51 09       	stdsp	sp[0x40],r9
8000cda2:	5c 78       	castu.h	r8
8000cda4:	50 18       	stdsp	sp[0x4],r8
8000cda6:	c4 68       	rjmp	8000ce32 <_vfprintf_r+0x1512>
8000cda8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cdac:	40 3c       	lddsp	r12,sp[0xc]
8000cdae:	58 0c       	cp.w	r12,0
8000cdb0:	c1 d0       	breq	8000cdea <_vfprintf_r+0x14ca>
8000cdb2:	10 36       	cp.w	r6,r8
8000cdb4:	c0 64       	brge	8000cdc0 <_vfprintf_r+0x14a0>
8000cdb6:	fa cb f9 44 	sub	r11,sp,-1724
8000cdba:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cdbe:	c1 f8       	rjmp	8000cdfc <_vfprintf_r+0x14dc>
8000cdc0:	fa c8 f9 50 	sub	r8,sp,-1712
8000cdc4:	1a d8       	st.w	--sp,r8
8000cdc6:	fa c8 fa b8 	sub	r8,sp,-1352
8000cdca:	0c 9b       	mov	r11,r6
8000cdcc:	1a d8       	st.w	--sp,r8
8000cdce:	fa c8 fb b4 	sub	r8,sp,-1100
8000cdd2:	04 9a       	mov	r10,r2
8000cdd4:	1a d8       	st.w	--sp,r8
8000cdd6:	08 9c       	mov	r12,r4
8000cdd8:	fa c8 f9 40 	sub	r8,sp,-1728
8000cddc:	fa c9 ff b4 	sub	r9,sp,-76
8000cde0:	fe b0 f4 08 	rcall	8000b5f0 <get_arg>
8000cde4:	2f dd       	sub	sp,-12
8000cde6:	78 0b       	ld.w	r11,r12[0x0]
8000cde8:	c2 48       	rjmp	8000ce30 <_vfprintf_r+0x1510>
8000cdea:	ee ca ff ff 	sub	r10,r7,-1
8000cdee:	10 37       	cp.w	r7,r8
8000cdf0:	c0 94       	brge	8000ce02 <_vfprintf_r+0x14e2>
8000cdf2:	fa c9 f9 44 	sub	r9,sp,-1724
8000cdf6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cdfa:	14 97       	mov	r7,r10
8000cdfc:	ec fb fd 88 	ld.w	r11,r6[-632]
8000ce00:	c1 88       	rjmp	8000ce30 <_vfprintf_r+0x1510>
8000ce02:	41 09       	lddsp	r9,sp[0x40]
8000ce04:	59 f8       	cp.w	r8,31
8000ce06:	e0 89 00 11 	brgt	8000ce28 <_vfprintf_r+0x1508>
8000ce0a:	f2 cb ff fc 	sub	r11,r9,-4
8000ce0e:	51 0b       	stdsp	sp[0x40],r11
8000ce10:	fa c6 f9 44 	sub	r6,sp,-1724
8000ce14:	72 0b       	ld.w	r11,r9[0x0]
8000ce16:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000ce1a:	f3 4b fd 88 	st.w	r9[-632],r11
8000ce1e:	2f f8       	sub	r8,-1
8000ce20:	14 97       	mov	r7,r10
8000ce22:	fb 48 06 b4 	st.w	sp[1716],r8
8000ce26:	c0 58       	rjmp	8000ce30 <_vfprintf_r+0x1510>
8000ce28:	72 0b       	ld.w	r11,r9[0x0]
8000ce2a:	14 97       	mov	r7,r10
8000ce2c:	2f c9       	sub	r9,-4
8000ce2e:	51 09       	stdsp	sp[0x40],r9
8000ce30:	50 1b       	stdsp	sp[0x4],r11
8000ce32:	30 0e       	mov	lr,0
8000ce34:	50 0e       	stdsp	sp[0x0],lr
8000ce36:	40 08       	lddsp	r8,sp[0x0]
8000ce38:	40 1c       	lddsp	r12,sp[0x4]
8000ce3a:	18 48       	or	r8,r12
8000ce3c:	5f 19       	srne	r9
8000ce3e:	0a 98       	mov	r8,r5
8000ce40:	eb e9 00 09 	and	r9,r5,r9
8000ce44:	a1 b8       	sbr	r8,0x1
8000ce46:	58 09       	cp.w	r9,0
8000ce48:	c0 70       	breq	8000ce56 <_vfprintf_r+0x1536>
8000ce4a:	10 95       	mov	r5,r8
8000ce4c:	fb 60 06 b9 	st.b	sp[1721],r0
8000ce50:	33 08       	mov	r8,48
8000ce52:	fb 68 06 b8 	st.b	sp[1720],r8
8000ce56:	30 28       	mov	r8,2
8000ce58:	30 09       	mov	r9,0
8000ce5a:	fb 69 06 bb 	st.b	sp[1723],r9
8000ce5e:	0a 99       	mov	r9,r5
8000ce60:	a7 d9       	cbr	r9,0x7
8000ce62:	40 2b       	lddsp	r11,sp[0x8]
8000ce64:	40 16       	lddsp	r6,sp[0x4]
8000ce66:	58 0b       	cp.w	r11,0
8000ce68:	5f 1a       	srne	r10
8000ce6a:	f2 05 17 40 	movge	r5,r9
8000ce6e:	fa c2 f9 78 	sub	r2,sp,-1672
8000ce72:	40 09       	lddsp	r9,sp[0x0]
8000ce74:	0c 49       	or	r9,r6
8000ce76:	5f 19       	srne	r9
8000ce78:	f5 e9 10 09 	or	r9,r10,r9
8000ce7c:	c5 c0       	breq	8000cf34 <_vfprintf_r+0x1614>
8000ce7e:	30 19       	mov	r9,1
8000ce80:	f2 08 18 00 	cp.b	r8,r9
8000ce84:	c0 60       	breq	8000ce90 <_vfprintf_r+0x1570>
8000ce86:	30 29       	mov	r9,2
8000ce88:	f2 08 18 00 	cp.b	r8,r9
8000ce8c:	c0 41       	brne	8000ce94 <_vfprintf_r+0x1574>
8000ce8e:	c3 c8       	rjmp	8000cf06 <_vfprintf_r+0x15e6>
8000ce90:	04 96       	mov	r6,r2
8000ce92:	c3 08       	rjmp	8000cef2 <_vfprintf_r+0x15d2>
8000ce94:	04 96       	mov	r6,r2
8000ce96:	fa e8 00 00 	ld.d	r8,sp[0]
8000ce9a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000ce9e:	2d 0a       	sub	r10,-48
8000cea0:	0c fa       	st.b	--r6,r10
8000cea2:	f0 0b 16 03 	lsr	r11,r8,0x3
8000cea6:	f2 0c 16 03 	lsr	r12,r9,0x3
8000ceaa:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000ceae:	18 99       	mov	r9,r12
8000ceb0:	16 98       	mov	r8,r11
8000ceb2:	58 08       	cp.w	r8,0
8000ceb4:	5c 29       	cpc	r9
8000ceb6:	cf 21       	brne	8000ce9a <_vfprintf_r+0x157a>
8000ceb8:	fa e9 00 00 	st.d	sp[0],r8
8000cebc:	ed b5 00 00 	bld	r5,0x0
8000cec0:	c4 51       	brne	8000cf4a <_vfprintf_r+0x162a>
8000cec2:	33 09       	mov	r9,48
8000cec4:	f2 0a 18 00 	cp.b	r10,r9
8000cec8:	c4 10       	breq	8000cf4a <_vfprintf_r+0x162a>
8000ceca:	0c f9       	st.b	--r6,r9
8000cecc:	c3 f8       	rjmp	8000cf4a <_vfprintf_r+0x162a>
8000cece:	fa ea 00 00 	ld.d	r10,sp[0]
8000ced2:	30 a8       	mov	r8,10
8000ced4:	30 09       	mov	r9,0
8000ced6:	e0 a0 1a 0d 	rcall	800102f0 <__avr32_umod64>
8000ceda:	30 a8       	mov	r8,10
8000cedc:	2d 0a       	sub	r10,-48
8000cede:	30 09       	mov	r9,0
8000cee0:	ac 8a       	st.b	r6[0x0],r10
8000cee2:	fa ea 00 00 	ld.d	r10,sp[0]
8000cee6:	e0 a0 18 d3 	rcall	8001008c <__avr32_udiv64>
8000ceea:	16 99       	mov	r9,r11
8000ceec:	14 98       	mov	r8,r10
8000ceee:	fa e9 00 00 	st.d	sp[0],r8
8000cef2:	20 16       	sub	r6,1
8000cef4:	fa ea 00 00 	ld.d	r10,sp[0]
8000cef8:	58 9a       	cp.w	r10,9
8000cefa:	5c 2b       	cpc	r11
8000cefc:	fe 9b ff e9 	brhi	8000cece <_vfprintf_r+0x15ae>
8000cf00:	1b f8       	ld.ub	r8,sp[0x7]
8000cf02:	2d 08       	sub	r8,-48
8000cf04:	c2 08       	rjmp	8000cf44 <_vfprintf_r+0x1624>
8000cf06:	04 96       	mov	r6,r2
8000cf08:	fa e8 00 00 	ld.d	r8,sp[0]
8000cf0c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000cf10:	40 de       	lddsp	lr,sp[0x34]
8000cf12:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000cf16:	0c fa       	st.b	--r6,r10
8000cf18:	f2 0b 16 04 	lsr	r11,r9,0x4
8000cf1c:	f0 0a 16 04 	lsr	r10,r8,0x4
8000cf20:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000cf24:	16 99       	mov	r9,r11
8000cf26:	14 98       	mov	r8,r10
8000cf28:	58 08       	cp.w	r8,0
8000cf2a:	5c 29       	cpc	r9
8000cf2c:	cf 01       	brne	8000cf0c <_vfprintf_r+0x15ec>
8000cf2e:	fa e9 00 00 	st.d	sp[0],r8
8000cf32:	c0 c8       	rjmp	8000cf4a <_vfprintf_r+0x162a>
8000cf34:	58 08       	cp.w	r8,0
8000cf36:	c0 91       	brne	8000cf48 <_vfprintf_r+0x1628>
8000cf38:	ed b5 00 00 	bld	r5,0x0
8000cf3c:	c0 61       	brne	8000cf48 <_vfprintf_r+0x1628>
8000cf3e:	fa c6 f9 79 	sub	r6,sp,-1671
8000cf42:	33 08       	mov	r8,48
8000cf44:	ac 88       	st.b	r6[0x0],r8
8000cf46:	c0 28       	rjmp	8000cf4a <_vfprintf_r+0x162a>
8000cf48:	04 96       	mov	r6,r2
8000cf4a:	0c 12       	sub	r2,r6
8000cf4c:	c1 c8       	rjmp	8000cf84 <_vfprintf_r+0x1664>
8000cf4e:	50 a7       	stdsp	sp[0x28],r7
8000cf50:	50 80       	stdsp	sp[0x20],r0
8000cf52:	40 93       	lddsp	r3,sp[0x24]
8000cf54:	0c 97       	mov	r7,r6
8000cf56:	10 90       	mov	r0,r8
8000cf58:	04 94       	mov	r4,r2
8000cf5a:	40 41       	lddsp	r1,sp[0x10]
8000cf5c:	58 08       	cp.w	r8,0
8000cf5e:	e0 80 04 4f 	breq	8000d7fc <_vfprintf_r+0x1edc>
8000cf62:	fb 68 06 60 	st.b	sp[1632],r8
8000cf66:	30 0c       	mov	r12,0
8000cf68:	30 08       	mov	r8,0
8000cf6a:	30 12       	mov	r2,1
8000cf6c:	fb 68 06 bb 	st.b	sp[1723],r8
8000cf70:	50 2c       	stdsp	sp[0x8],r12
8000cf72:	fa c6 f9 a0 	sub	r6,sp,-1632
8000cf76:	c0 78       	rjmp	8000cf84 <_vfprintf_r+0x1664>
8000cf78:	30 0b       	mov	r11,0
8000cf7a:	50 2b       	stdsp	sp[0x8],r11
8000cf7c:	c0 48       	rjmp	8000cf84 <_vfprintf_r+0x1664>
8000cf7e:	40 22       	lddsp	r2,sp[0x8]
8000cf80:	30 0a       	mov	r10,0
8000cf82:	50 2a       	stdsp	sp[0x8],r10
8000cf84:	40 29       	lddsp	r9,sp[0x8]
8000cf86:	e4 09 0c 49 	max	r9,r2,r9
8000cf8a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000cf8e:	50 39       	stdsp	sp[0xc],r9
8000cf90:	0a 9e       	mov	lr,r5
8000cf92:	30 09       	mov	r9,0
8000cf94:	e2 1e 00 02 	andl	lr,0x2,COH
8000cf98:	f2 08 18 00 	cp.b	r8,r9
8000cf9c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000cfa0:	f7 b8 01 ff 	subne	r8,-1
8000cfa4:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000cfa8:	0a 9b       	mov	r11,r5
8000cfaa:	58 0e       	cp.w	lr,0
8000cfac:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000cfb0:	f7 bc 01 fe 	subne	r12,-2
8000cfb4:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000cfb8:	e2 1b 00 84 	andl	r11,0x84,COH
8000cfbc:	50 fe       	stdsp	sp[0x3c],lr
8000cfbe:	50 9b       	stdsp	sp[0x24],r11
8000cfc0:	c4 71       	brne	8000d04e <_vfprintf_r+0x172e>
8000cfc2:	40 8a       	lddsp	r10,sp[0x20]
8000cfc4:	40 39       	lddsp	r9,sp[0xc]
8000cfc6:	12 1a       	sub	r10,r9
8000cfc8:	50 4a       	stdsp	sp[0x10],r10
8000cfca:	58 0a       	cp.w	r10,0
8000cfcc:	e0 89 00 20 	brgt	8000d00c <_vfprintf_r+0x16ec>
8000cfd0:	c3 f8       	rjmp	8000d04e <_vfprintf_r+0x172e>
8000cfd2:	2f 09       	sub	r9,-16
8000cfd4:	2f f8       	sub	r8,-1
8000cfd6:	fe ce c1 0e 	sub	lr,pc,-16114
8000cfda:	31 0c       	mov	r12,16
8000cfdc:	fb 49 06 90 	st.w	sp[1680],r9
8000cfe0:	87 0e       	st.w	r3[0x0],lr
8000cfe2:	87 1c       	st.w	r3[0x4],r12
8000cfe4:	fb 48 06 8c 	st.w	sp[1676],r8
8000cfe8:	58 78       	cp.w	r8,7
8000cfea:	e0 89 00 04 	brgt	8000cff2 <_vfprintf_r+0x16d2>
8000cfee:	2f 83       	sub	r3,-8
8000cff0:	c0 b8       	rjmp	8000d006 <_vfprintf_r+0x16e6>
8000cff2:	fa ca f9 78 	sub	r10,sp,-1672
8000cff6:	02 9b       	mov	r11,r1
8000cff8:	08 9c       	mov	r12,r4
8000cffa:	fe b0 f4 85 	rcall	8000b904 <__sprint_r>
8000cffe:	e0 81 04 10 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d002:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d006:	40 4b       	lddsp	r11,sp[0x10]
8000d008:	21 0b       	sub	r11,16
8000d00a:	50 4b       	stdsp	sp[0x10],r11
8000d00c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d010:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d014:	fe ca c1 4c 	sub	r10,pc,-16052
8000d018:	40 4e       	lddsp	lr,sp[0x10]
8000d01a:	59 0e       	cp.w	lr,16
8000d01c:	fe 99 ff db 	brgt	8000cfd2 <_vfprintf_r+0x16b2>
8000d020:	1c 09       	add	r9,lr
8000d022:	2f f8       	sub	r8,-1
8000d024:	87 0a       	st.w	r3[0x0],r10
8000d026:	fb 49 06 90 	st.w	sp[1680],r9
8000d02a:	87 1e       	st.w	r3[0x4],lr
8000d02c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d030:	58 78       	cp.w	r8,7
8000d032:	e0 89 00 04 	brgt	8000d03a <_vfprintf_r+0x171a>
8000d036:	2f 83       	sub	r3,-8
8000d038:	c0 b8       	rjmp	8000d04e <_vfprintf_r+0x172e>
8000d03a:	fa ca f9 78 	sub	r10,sp,-1672
8000d03e:	02 9b       	mov	r11,r1
8000d040:	08 9c       	mov	r12,r4
8000d042:	fe b0 f4 61 	rcall	8000b904 <__sprint_r>
8000d046:	e0 81 03 ec 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d04a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d04e:	30 09       	mov	r9,0
8000d050:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000d054:	f2 08 18 00 	cp.b	r8,r9
8000d058:	c1 f0       	breq	8000d096 <_vfprintf_r+0x1776>
8000d05a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d05e:	fa c9 f9 45 	sub	r9,sp,-1723
8000d062:	2f f8       	sub	r8,-1
8000d064:	87 09       	st.w	r3[0x0],r9
8000d066:	fb 48 06 90 	st.w	sp[1680],r8
8000d06a:	30 19       	mov	r9,1
8000d06c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d070:	87 19       	st.w	r3[0x4],r9
8000d072:	2f f8       	sub	r8,-1
8000d074:	fb 48 06 8c 	st.w	sp[1676],r8
8000d078:	58 78       	cp.w	r8,7
8000d07a:	e0 89 00 04 	brgt	8000d082 <_vfprintf_r+0x1762>
8000d07e:	2f 83       	sub	r3,-8
8000d080:	c0 b8       	rjmp	8000d096 <_vfprintf_r+0x1776>
8000d082:	fa ca f9 78 	sub	r10,sp,-1672
8000d086:	02 9b       	mov	r11,r1
8000d088:	08 9c       	mov	r12,r4
8000d08a:	fe b0 f4 3d 	rcall	8000b904 <__sprint_r>
8000d08e:	e0 81 03 c8 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d092:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d096:	40 fc       	lddsp	r12,sp[0x3c]
8000d098:	58 0c       	cp.w	r12,0
8000d09a:	c1 f0       	breq	8000d0d8 <_vfprintf_r+0x17b8>
8000d09c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d0a0:	fa c9 f9 48 	sub	r9,sp,-1720
8000d0a4:	2f e8       	sub	r8,-2
8000d0a6:	87 09       	st.w	r3[0x0],r9
8000d0a8:	fb 48 06 90 	st.w	sp[1680],r8
8000d0ac:	30 29       	mov	r9,2
8000d0ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d0b2:	87 19       	st.w	r3[0x4],r9
8000d0b4:	2f f8       	sub	r8,-1
8000d0b6:	fb 48 06 8c 	st.w	sp[1676],r8
8000d0ba:	58 78       	cp.w	r8,7
8000d0bc:	e0 89 00 04 	brgt	8000d0c4 <_vfprintf_r+0x17a4>
8000d0c0:	2f 83       	sub	r3,-8
8000d0c2:	c0 b8       	rjmp	8000d0d8 <_vfprintf_r+0x17b8>
8000d0c4:	fa ca f9 78 	sub	r10,sp,-1672
8000d0c8:	02 9b       	mov	r11,r1
8000d0ca:	08 9c       	mov	r12,r4
8000d0cc:	fe b0 f4 1c 	rcall	8000b904 <__sprint_r>
8000d0d0:	e0 81 03 a7 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d0d4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d0d8:	40 9b       	lddsp	r11,sp[0x24]
8000d0da:	e0 4b 00 80 	cp.w	r11,128
8000d0de:	c4 71       	brne	8000d16c <_vfprintf_r+0x184c>
8000d0e0:	40 8a       	lddsp	r10,sp[0x20]
8000d0e2:	40 39       	lddsp	r9,sp[0xc]
8000d0e4:	12 1a       	sub	r10,r9
8000d0e6:	50 4a       	stdsp	sp[0x10],r10
8000d0e8:	58 0a       	cp.w	r10,0
8000d0ea:	e0 89 00 20 	brgt	8000d12a <_vfprintf_r+0x180a>
8000d0ee:	c3 f8       	rjmp	8000d16c <_vfprintf_r+0x184c>
8000d0f0:	2f 09       	sub	r9,-16
8000d0f2:	2f f8       	sub	r8,-1
8000d0f4:	fe ce c2 1c 	sub	lr,pc,-15844
8000d0f8:	31 0c       	mov	r12,16
8000d0fa:	fb 49 06 90 	st.w	sp[1680],r9
8000d0fe:	87 0e       	st.w	r3[0x0],lr
8000d100:	87 1c       	st.w	r3[0x4],r12
8000d102:	fb 48 06 8c 	st.w	sp[1676],r8
8000d106:	58 78       	cp.w	r8,7
8000d108:	e0 89 00 04 	brgt	8000d110 <_vfprintf_r+0x17f0>
8000d10c:	2f 83       	sub	r3,-8
8000d10e:	c0 b8       	rjmp	8000d124 <_vfprintf_r+0x1804>
8000d110:	fa ca f9 78 	sub	r10,sp,-1672
8000d114:	02 9b       	mov	r11,r1
8000d116:	08 9c       	mov	r12,r4
8000d118:	fe b0 f3 f6 	rcall	8000b904 <__sprint_r>
8000d11c:	e0 81 03 81 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d120:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d124:	40 4b       	lddsp	r11,sp[0x10]
8000d126:	21 0b       	sub	r11,16
8000d128:	50 4b       	stdsp	sp[0x10],r11
8000d12a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d12e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d132:	fe ca c2 5a 	sub	r10,pc,-15782
8000d136:	40 4e       	lddsp	lr,sp[0x10]
8000d138:	59 0e       	cp.w	lr,16
8000d13a:	fe 99 ff db 	brgt	8000d0f0 <_vfprintf_r+0x17d0>
8000d13e:	1c 09       	add	r9,lr
8000d140:	2f f8       	sub	r8,-1
8000d142:	87 0a       	st.w	r3[0x0],r10
8000d144:	fb 49 06 90 	st.w	sp[1680],r9
8000d148:	87 1e       	st.w	r3[0x4],lr
8000d14a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d14e:	58 78       	cp.w	r8,7
8000d150:	e0 89 00 04 	brgt	8000d158 <_vfprintf_r+0x1838>
8000d154:	2f 83       	sub	r3,-8
8000d156:	c0 b8       	rjmp	8000d16c <_vfprintf_r+0x184c>
8000d158:	fa ca f9 78 	sub	r10,sp,-1672
8000d15c:	02 9b       	mov	r11,r1
8000d15e:	08 9c       	mov	r12,r4
8000d160:	fe b0 f3 d2 	rcall	8000b904 <__sprint_r>
8000d164:	e0 81 03 5d 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d168:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d16c:	40 2c       	lddsp	r12,sp[0x8]
8000d16e:	04 1c       	sub	r12,r2
8000d170:	50 2c       	stdsp	sp[0x8],r12
8000d172:	58 0c       	cp.w	r12,0
8000d174:	e0 89 00 20 	brgt	8000d1b4 <_vfprintf_r+0x1894>
8000d178:	c3 f8       	rjmp	8000d1f6 <_vfprintf_r+0x18d6>
8000d17a:	2f 09       	sub	r9,-16
8000d17c:	2f f8       	sub	r8,-1
8000d17e:	fe cb c2 a6 	sub	r11,pc,-15706
8000d182:	31 0a       	mov	r10,16
8000d184:	fb 49 06 90 	st.w	sp[1680],r9
8000d188:	87 0b       	st.w	r3[0x0],r11
8000d18a:	87 1a       	st.w	r3[0x4],r10
8000d18c:	fb 48 06 8c 	st.w	sp[1676],r8
8000d190:	58 78       	cp.w	r8,7
8000d192:	e0 89 00 04 	brgt	8000d19a <_vfprintf_r+0x187a>
8000d196:	2f 83       	sub	r3,-8
8000d198:	c0 b8       	rjmp	8000d1ae <_vfprintf_r+0x188e>
8000d19a:	fa ca f9 78 	sub	r10,sp,-1672
8000d19e:	02 9b       	mov	r11,r1
8000d1a0:	08 9c       	mov	r12,r4
8000d1a2:	fe b0 f3 b1 	rcall	8000b904 <__sprint_r>
8000d1a6:	e0 81 03 3c 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d1aa:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d1ae:	40 29       	lddsp	r9,sp[0x8]
8000d1b0:	21 09       	sub	r9,16
8000d1b2:	50 29       	stdsp	sp[0x8],r9
8000d1b4:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d1b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d1bc:	fe ca c2 e4 	sub	r10,pc,-15644
8000d1c0:	40 2e       	lddsp	lr,sp[0x8]
8000d1c2:	59 0e       	cp.w	lr,16
8000d1c4:	fe 99 ff db 	brgt	8000d17a <_vfprintf_r+0x185a>
8000d1c8:	1c 09       	add	r9,lr
8000d1ca:	2f f8       	sub	r8,-1
8000d1cc:	87 0a       	st.w	r3[0x0],r10
8000d1ce:	fb 49 06 90 	st.w	sp[1680],r9
8000d1d2:	87 1e       	st.w	r3[0x4],lr
8000d1d4:	fb 48 06 8c 	st.w	sp[1676],r8
8000d1d8:	58 78       	cp.w	r8,7
8000d1da:	e0 89 00 04 	brgt	8000d1e2 <_vfprintf_r+0x18c2>
8000d1de:	2f 83       	sub	r3,-8
8000d1e0:	c0 b8       	rjmp	8000d1f6 <_vfprintf_r+0x18d6>
8000d1e2:	fa ca f9 78 	sub	r10,sp,-1672
8000d1e6:	02 9b       	mov	r11,r1
8000d1e8:	08 9c       	mov	r12,r4
8000d1ea:	fe b0 f3 8d 	rcall	8000b904 <__sprint_r>
8000d1ee:	e0 81 03 18 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d1f2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d1f6:	ed b5 00 08 	bld	r5,0x8
8000d1fa:	c0 b0       	breq	8000d210 <_vfprintf_r+0x18f0>
8000d1fc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d200:	87 12       	st.w	r3[0x4],r2
8000d202:	87 06       	st.w	r3[0x0],r6
8000d204:	f0 02 00 02 	add	r2,r8,r2
8000d208:	fb 42 06 90 	st.w	sp[1680],r2
8000d20c:	e0 8f 01 d4 	bral	8000d5b4 <_vfprintf_r+0x1c94>
8000d210:	e0 40 00 65 	cp.w	r0,101
8000d214:	e0 8a 01 d6 	brle	8000d5c0 <_vfprintf_r+0x1ca0>
8000d218:	30 08       	mov	r8,0
8000d21a:	30 09       	mov	r9,0
8000d21c:	40 5b       	lddsp	r11,sp[0x14]
8000d21e:	40 7a       	lddsp	r10,sp[0x1c]
8000d220:	e0 a0 15 2f 	rcall	8000fc7e <__avr32_f64_cmp_eq>
8000d224:	c7 90       	breq	8000d316 <_vfprintf_r+0x19f6>
8000d226:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d22a:	fe c9 c3 66 	sub	r9,pc,-15514
8000d22e:	2f f8       	sub	r8,-1
8000d230:	87 09       	st.w	r3[0x0],r9
8000d232:	fb 48 06 90 	st.w	sp[1680],r8
8000d236:	30 19       	mov	r9,1
8000d238:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d23c:	87 19       	st.w	r3[0x4],r9
8000d23e:	2f f8       	sub	r8,-1
8000d240:	fb 48 06 8c 	st.w	sp[1676],r8
8000d244:	58 78       	cp.w	r8,7
8000d246:	e0 89 00 05 	brgt	8000d250 <_vfprintf_r+0x1930>
8000d24a:	2f 83       	sub	r3,-8
8000d24c:	c0 c8       	rjmp	8000d264 <_vfprintf_r+0x1944>
8000d24e:	d7 03       	nop
8000d250:	fa ca f9 78 	sub	r10,sp,-1672
8000d254:	02 9b       	mov	r11,r1
8000d256:	08 9c       	mov	r12,r4
8000d258:	fe b0 f3 56 	rcall	8000b904 <__sprint_r>
8000d25c:	e0 81 02 e1 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d260:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d264:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000d268:	40 6c       	lddsp	r12,sp[0x18]
8000d26a:	18 38       	cp.w	r8,r12
8000d26c:	c0 55       	brlt	8000d276 <_vfprintf_r+0x1956>
8000d26e:	ed b5 00 00 	bld	r5,0x0
8000d272:	e0 81 02 6b 	brne	8000d748 <_vfprintf_r+0x1e28>
8000d276:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d27a:	2f f8       	sub	r8,-1
8000d27c:	40 cb       	lddsp	r11,sp[0x30]
8000d27e:	fb 48 06 90 	st.w	sp[1680],r8
8000d282:	30 19       	mov	r9,1
8000d284:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d288:	87 0b       	st.w	r3[0x0],r11
8000d28a:	2f f8       	sub	r8,-1
8000d28c:	87 19       	st.w	r3[0x4],r9
8000d28e:	fb 48 06 8c 	st.w	sp[1676],r8
8000d292:	58 78       	cp.w	r8,7
8000d294:	e0 89 00 04 	brgt	8000d29c <_vfprintf_r+0x197c>
8000d298:	2f 83       	sub	r3,-8
8000d29a:	c0 b8       	rjmp	8000d2b0 <_vfprintf_r+0x1990>
8000d29c:	fa ca f9 78 	sub	r10,sp,-1672
8000d2a0:	02 9b       	mov	r11,r1
8000d2a2:	08 9c       	mov	r12,r4
8000d2a4:	fe b0 f3 30 	rcall	8000b904 <__sprint_r>
8000d2a8:	e0 81 02 bb 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d2ac:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d2b0:	40 66       	lddsp	r6,sp[0x18]
8000d2b2:	20 16       	sub	r6,1
8000d2b4:	58 06       	cp.w	r6,0
8000d2b6:	e0 89 00 1d 	brgt	8000d2f0 <_vfprintf_r+0x19d0>
8000d2ba:	e0 8f 02 47 	bral	8000d748 <_vfprintf_r+0x1e28>
8000d2be:	2f 09       	sub	r9,-16
8000d2c0:	2f f8       	sub	r8,-1
8000d2c2:	fb 49 06 90 	st.w	sp[1680],r9
8000d2c6:	87 02       	st.w	r3[0x0],r2
8000d2c8:	87 10       	st.w	r3[0x4],r0
8000d2ca:	fb 48 06 8c 	st.w	sp[1676],r8
8000d2ce:	58 78       	cp.w	r8,7
8000d2d0:	e0 89 00 04 	brgt	8000d2d8 <_vfprintf_r+0x19b8>
8000d2d4:	2f 83       	sub	r3,-8
8000d2d6:	c0 b8       	rjmp	8000d2ec <_vfprintf_r+0x19cc>
8000d2d8:	fa ca f9 78 	sub	r10,sp,-1672
8000d2dc:	02 9b       	mov	r11,r1
8000d2de:	08 9c       	mov	r12,r4
8000d2e0:	fe b0 f3 12 	rcall	8000b904 <__sprint_r>
8000d2e4:	e0 81 02 9d 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d2e8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d2ec:	21 06       	sub	r6,16
8000d2ee:	c0 48       	rjmp	8000d2f6 <_vfprintf_r+0x19d6>
8000d2f0:	fe c2 c4 18 	sub	r2,pc,-15336
8000d2f4:	31 00       	mov	r0,16
8000d2f6:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d2fa:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d2fe:	fe ca c4 26 	sub	r10,pc,-15322
8000d302:	59 06       	cp.w	r6,16
8000d304:	fe 99 ff dd 	brgt	8000d2be <_vfprintf_r+0x199e>
8000d308:	0c 09       	add	r9,r6
8000d30a:	87 0a       	st.w	r3[0x0],r10
8000d30c:	fb 49 06 90 	st.w	sp[1680],r9
8000d310:	2f f8       	sub	r8,-1
8000d312:	87 16       	st.w	r3[0x4],r6
8000d314:	c5 39       	rjmp	8000d5ba <_vfprintf_r+0x1c9a>
8000d316:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000d31a:	58 0a       	cp.w	r10,0
8000d31c:	e0 89 00 92 	brgt	8000d440 <_vfprintf_r+0x1b20>
8000d320:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d324:	fe c9 c4 60 	sub	r9,pc,-15264
8000d328:	2f f8       	sub	r8,-1
8000d32a:	87 09       	st.w	r3[0x0],r9
8000d32c:	fb 48 06 90 	st.w	sp[1680],r8
8000d330:	30 19       	mov	r9,1
8000d332:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d336:	87 19       	st.w	r3[0x4],r9
8000d338:	2f f8       	sub	r8,-1
8000d33a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d33e:	58 78       	cp.w	r8,7
8000d340:	e0 89 00 04 	brgt	8000d348 <_vfprintf_r+0x1a28>
8000d344:	2f 83       	sub	r3,-8
8000d346:	c0 b8       	rjmp	8000d35c <_vfprintf_r+0x1a3c>
8000d348:	fa ca f9 78 	sub	r10,sp,-1672
8000d34c:	02 9b       	mov	r11,r1
8000d34e:	08 9c       	mov	r12,r4
8000d350:	fe b0 f2 da 	rcall	8000b904 <__sprint_r>
8000d354:	e0 81 02 65 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d358:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d35c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000d360:	58 08       	cp.w	r8,0
8000d362:	c0 81       	brne	8000d372 <_vfprintf_r+0x1a52>
8000d364:	40 6a       	lddsp	r10,sp[0x18]
8000d366:	58 0a       	cp.w	r10,0
8000d368:	c0 51       	brne	8000d372 <_vfprintf_r+0x1a52>
8000d36a:	ed b5 00 00 	bld	r5,0x0
8000d36e:	e0 81 01 ed 	brne	8000d748 <_vfprintf_r+0x1e28>
8000d372:	40 c9       	lddsp	r9,sp[0x30]
8000d374:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d378:	2f f8       	sub	r8,-1
8000d37a:	87 09       	st.w	r3[0x0],r9
8000d37c:	fb 48 06 90 	st.w	sp[1680],r8
8000d380:	30 19       	mov	r9,1
8000d382:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d386:	87 19       	st.w	r3[0x4],r9
8000d388:	2f f8       	sub	r8,-1
8000d38a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d38e:	58 78       	cp.w	r8,7
8000d390:	e0 89 00 04 	brgt	8000d398 <_vfprintf_r+0x1a78>
8000d394:	2f 83       	sub	r3,-8
8000d396:	c0 b8       	rjmp	8000d3ac <_vfprintf_r+0x1a8c>
8000d398:	fa ca f9 78 	sub	r10,sp,-1672
8000d39c:	02 9b       	mov	r11,r1
8000d39e:	08 9c       	mov	r12,r4
8000d3a0:	fe b0 f2 b2 	rcall	8000b904 <__sprint_r>
8000d3a4:	e0 81 02 3d 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d3a8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d3ac:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000d3b0:	5c 32       	neg	r2
8000d3b2:	58 02       	cp.w	r2,0
8000d3b4:	e0 89 00 1d 	brgt	8000d3ee <_vfprintf_r+0x1ace>
8000d3b8:	c3 d8       	rjmp	8000d432 <_vfprintf_r+0x1b12>
8000d3ba:	2f 09       	sub	r9,-16
8000d3bc:	2f f8       	sub	r8,-1
8000d3be:	31 0e       	mov	lr,16
8000d3c0:	fb 49 06 90 	st.w	sp[1680],r9
8000d3c4:	87 00       	st.w	r3[0x0],r0
8000d3c6:	87 1e       	st.w	r3[0x4],lr
8000d3c8:	fb 48 06 8c 	st.w	sp[1676],r8
8000d3cc:	58 78       	cp.w	r8,7
8000d3ce:	e0 89 00 04 	brgt	8000d3d6 <_vfprintf_r+0x1ab6>
8000d3d2:	2f 83       	sub	r3,-8
8000d3d4:	c0 b8       	rjmp	8000d3ea <_vfprintf_r+0x1aca>
8000d3d6:	fa ca f9 78 	sub	r10,sp,-1672
8000d3da:	02 9b       	mov	r11,r1
8000d3dc:	08 9c       	mov	r12,r4
8000d3de:	fe b0 f2 93 	rcall	8000b904 <__sprint_r>
8000d3e2:	e0 81 02 1e 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d3e6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d3ea:	21 02       	sub	r2,16
8000d3ec:	c0 38       	rjmp	8000d3f2 <_vfprintf_r+0x1ad2>
8000d3ee:	fe c0 c5 16 	sub	r0,pc,-15082
8000d3f2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d3f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d3fa:	fe ca c5 22 	sub	r10,pc,-15070
8000d3fe:	59 02       	cp.w	r2,16
8000d400:	fe 99 ff dd 	brgt	8000d3ba <_vfprintf_r+0x1a9a>
8000d404:	04 09       	add	r9,r2
8000d406:	2f f8       	sub	r8,-1
8000d408:	87 0a       	st.w	r3[0x0],r10
8000d40a:	fb 49 06 90 	st.w	sp[1680],r9
8000d40e:	87 12       	st.w	r3[0x4],r2
8000d410:	fb 48 06 8c 	st.w	sp[1676],r8
8000d414:	58 78       	cp.w	r8,7
8000d416:	e0 89 00 04 	brgt	8000d41e <_vfprintf_r+0x1afe>
8000d41a:	2f 83       	sub	r3,-8
8000d41c:	c0 b8       	rjmp	8000d432 <_vfprintf_r+0x1b12>
8000d41e:	fa ca f9 78 	sub	r10,sp,-1672
8000d422:	02 9b       	mov	r11,r1
8000d424:	08 9c       	mov	r12,r4
8000d426:	fe b0 f2 6f 	rcall	8000b904 <__sprint_r>
8000d42a:	e0 81 01 fa 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d42e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d432:	40 6c       	lddsp	r12,sp[0x18]
8000d434:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d438:	87 06       	st.w	r3[0x0],r6
8000d43a:	87 1c       	st.w	r3[0x4],r12
8000d43c:	18 08       	add	r8,r12
8000d43e:	cb 98       	rjmp	8000d5b0 <_vfprintf_r+0x1c90>
8000d440:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d444:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d448:	40 6b       	lddsp	r11,sp[0x18]
8000d44a:	16 3a       	cp.w	r10,r11
8000d44c:	c6 f5       	brlt	8000d52a <_vfprintf_r+0x1c0a>
8000d44e:	16 09       	add	r9,r11
8000d450:	2f f8       	sub	r8,-1
8000d452:	87 06       	st.w	r3[0x0],r6
8000d454:	fb 49 06 90 	st.w	sp[1680],r9
8000d458:	87 1b       	st.w	r3[0x4],r11
8000d45a:	fb 48 06 8c 	st.w	sp[1676],r8
8000d45e:	58 78       	cp.w	r8,7
8000d460:	e0 89 00 04 	brgt	8000d468 <_vfprintf_r+0x1b48>
8000d464:	2f 83       	sub	r3,-8
8000d466:	c0 b8       	rjmp	8000d47c <_vfprintf_r+0x1b5c>
8000d468:	fa ca f9 78 	sub	r10,sp,-1672
8000d46c:	02 9b       	mov	r11,r1
8000d46e:	08 9c       	mov	r12,r4
8000d470:	fe b0 f2 4a 	rcall	8000b904 <__sprint_r>
8000d474:	e0 81 01 d5 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d478:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d47c:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000d480:	40 6a       	lddsp	r10,sp[0x18]
8000d482:	14 16       	sub	r6,r10
8000d484:	58 06       	cp.w	r6,0
8000d486:	e0 89 00 1c 	brgt	8000d4be <_vfprintf_r+0x1b9e>
8000d48a:	c3 d8       	rjmp	8000d504 <_vfprintf_r+0x1be4>
8000d48c:	2f 09       	sub	r9,-16
8000d48e:	2f f8       	sub	r8,-1
8000d490:	fb 49 06 90 	st.w	sp[1680],r9
8000d494:	87 02       	st.w	r3[0x0],r2
8000d496:	87 10       	st.w	r3[0x4],r0
8000d498:	fb 48 06 8c 	st.w	sp[1676],r8
8000d49c:	58 78       	cp.w	r8,7
8000d49e:	e0 89 00 04 	brgt	8000d4a6 <_vfprintf_r+0x1b86>
8000d4a2:	2f 83       	sub	r3,-8
8000d4a4:	c0 b8       	rjmp	8000d4ba <_vfprintf_r+0x1b9a>
8000d4a6:	fa ca f9 78 	sub	r10,sp,-1672
8000d4aa:	02 9b       	mov	r11,r1
8000d4ac:	08 9c       	mov	r12,r4
8000d4ae:	fe b0 f2 2b 	rcall	8000b904 <__sprint_r>
8000d4b2:	e0 81 01 b6 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d4b6:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d4ba:	21 06       	sub	r6,16
8000d4bc:	c0 48       	rjmp	8000d4c4 <_vfprintf_r+0x1ba4>
8000d4be:	fe c2 c5 e6 	sub	r2,pc,-14874
8000d4c2:	31 00       	mov	r0,16
8000d4c4:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d4c8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d4cc:	fe ca c5 f4 	sub	r10,pc,-14860
8000d4d0:	59 06       	cp.w	r6,16
8000d4d2:	fe 99 ff dd 	brgt	8000d48c <_vfprintf_r+0x1b6c>
8000d4d6:	0c 09       	add	r9,r6
8000d4d8:	2f f8       	sub	r8,-1
8000d4da:	87 0a       	st.w	r3[0x0],r10
8000d4dc:	fb 49 06 90 	st.w	sp[1680],r9
8000d4e0:	87 16       	st.w	r3[0x4],r6
8000d4e2:	fb 48 06 8c 	st.w	sp[1676],r8
8000d4e6:	58 78       	cp.w	r8,7
8000d4e8:	e0 89 00 04 	brgt	8000d4f0 <_vfprintf_r+0x1bd0>
8000d4ec:	2f 83       	sub	r3,-8
8000d4ee:	c0 b8       	rjmp	8000d504 <_vfprintf_r+0x1be4>
8000d4f0:	fa ca f9 78 	sub	r10,sp,-1672
8000d4f4:	02 9b       	mov	r11,r1
8000d4f6:	08 9c       	mov	r12,r4
8000d4f8:	fe b0 f2 06 	rcall	8000b904 <__sprint_r>
8000d4fc:	e0 81 01 91 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d500:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d504:	ed b5 00 00 	bld	r5,0x0
8000d508:	e0 81 01 20 	brne	8000d748 <_vfprintf_r+0x1e28>
8000d50c:	40 c9       	lddsp	r9,sp[0x30]
8000d50e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d512:	2f f8       	sub	r8,-1
8000d514:	87 09       	st.w	r3[0x0],r9
8000d516:	fb 48 06 90 	st.w	sp[1680],r8
8000d51a:	30 19       	mov	r9,1
8000d51c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d520:	87 19       	st.w	r3[0x4],r9
8000d522:	2f f8       	sub	r8,-1
8000d524:	fb 48 06 8c 	st.w	sp[1676],r8
8000d528:	c0 29       	rjmp	8000d72c <_vfprintf_r+0x1e0c>
8000d52a:	14 09       	add	r9,r10
8000d52c:	2f f8       	sub	r8,-1
8000d52e:	fb 49 06 90 	st.w	sp[1680],r9
8000d532:	87 06       	st.w	r3[0x0],r6
8000d534:	87 1a       	st.w	r3[0x4],r10
8000d536:	fb 48 06 8c 	st.w	sp[1676],r8
8000d53a:	58 78       	cp.w	r8,7
8000d53c:	e0 89 00 04 	brgt	8000d544 <_vfprintf_r+0x1c24>
8000d540:	2f 83       	sub	r3,-8
8000d542:	c0 b8       	rjmp	8000d558 <_vfprintf_r+0x1c38>
8000d544:	fa ca f9 78 	sub	r10,sp,-1672
8000d548:	02 9b       	mov	r11,r1
8000d54a:	08 9c       	mov	r12,r4
8000d54c:	fe b0 f1 dc 	rcall	8000b904 <__sprint_r>
8000d550:	e0 81 01 67 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d554:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d558:	40 c8       	lddsp	r8,sp[0x30]
8000d55a:	87 08       	st.w	r3[0x0],r8
8000d55c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d560:	2f f8       	sub	r8,-1
8000d562:	30 19       	mov	r9,1
8000d564:	fb 48 06 90 	st.w	sp[1680],r8
8000d568:	87 19       	st.w	r3[0x4],r9
8000d56a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d56e:	2f f8       	sub	r8,-1
8000d570:	fb 48 06 8c 	st.w	sp[1676],r8
8000d574:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000d578:	58 78       	cp.w	r8,7
8000d57a:	e0 89 00 04 	brgt	8000d582 <_vfprintf_r+0x1c62>
8000d57e:	2f 83       	sub	r3,-8
8000d580:	c0 b8       	rjmp	8000d596 <_vfprintf_r+0x1c76>
8000d582:	fa ca f9 78 	sub	r10,sp,-1672
8000d586:	02 9b       	mov	r11,r1
8000d588:	08 9c       	mov	r12,r4
8000d58a:	fe b0 f1 bd 	rcall	8000b904 <__sprint_r>
8000d58e:	e0 81 01 48 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d592:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d596:	04 06       	add	r6,r2
8000d598:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000d59c:	87 06       	st.w	r3[0x0],r6
8000d59e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d5a2:	40 66       	lddsp	r6,sp[0x18]
8000d5a4:	40 6e       	lddsp	lr,sp[0x18]
8000d5a6:	10 16       	sub	r6,r8
8000d5a8:	f2 08 01 08 	sub	r8,r9,r8
8000d5ac:	87 16       	st.w	r3[0x4],r6
8000d5ae:	1c 08       	add	r8,lr
8000d5b0:	fb 48 06 90 	st.w	sp[1680],r8
8000d5b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d5b8:	2f f8       	sub	r8,-1
8000d5ba:	fb 48 06 8c 	st.w	sp[1676],r8
8000d5be:	cb 78       	rjmp	8000d72c <_vfprintf_r+0x1e0c>
8000d5c0:	40 6c       	lddsp	r12,sp[0x18]
8000d5c2:	58 1c       	cp.w	r12,1
8000d5c4:	e0 89 00 06 	brgt	8000d5d0 <_vfprintf_r+0x1cb0>
8000d5c8:	ed b5 00 00 	bld	r5,0x0
8000d5cc:	e0 81 00 85 	brne	8000d6d6 <_vfprintf_r+0x1db6>
8000d5d0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d5d4:	2f f8       	sub	r8,-1
8000d5d6:	30 19       	mov	r9,1
8000d5d8:	fb 48 06 90 	st.w	sp[1680],r8
8000d5dc:	87 06       	st.w	r3[0x0],r6
8000d5de:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d5e2:	87 19       	st.w	r3[0x4],r9
8000d5e4:	2f f8       	sub	r8,-1
8000d5e6:	fb 48 06 8c 	st.w	sp[1676],r8
8000d5ea:	58 78       	cp.w	r8,7
8000d5ec:	e0 89 00 04 	brgt	8000d5f4 <_vfprintf_r+0x1cd4>
8000d5f0:	2f 83       	sub	r3,-8
8000d5f2:	c0 b8       	rjmp	8000d608 <_vfprintf_r+0x1ce8>
8000d5f4:	fa ca f9 78 	sub	r10,sp,-1672
8000d5f8:	02 9b       	mov	r11,r1
8000d5fa:	08 9c       	mov	r12,r4
8000d5fc:	fe b0 f1 84 	rcall	8000b904 <__sprint_r>
8000d600:	e0 81 01 0f 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d604:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d608:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d60c:	2f f8       	sub	r8,-1
8000d60e:	40 cb       	lddsp	r11,sp[0x30]
8000d610:	fb 48 06 90 	st.w	sp[1680],r8
8000d614:	30 19       	mov	r9,1
8000d616:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d61a:	87 0b       	st.w	r3[0x0],r11
8000d61c:	2f f8       	sub	r8,-1
8000d61e:	87 19       	st.w	r3[0x4],r9
8000d620:	fb 48 06 8c 	st.w	sp[1676],r8
8000d624:	58 78       	cp.w	r8,7
8000d626:	e0 89 00 05 	brgt	8000d630 <_vfprintf_r+0x1d10>
8000d62a:	2f 83       	sub	r3,-8
8000d62c:	c0 c8       	rjmp	8000d644 <_vfprintf_r+0x1d24>
8000d62e:	d7 03       	nop
8000d630:	fa ca f9 78 	sub	r10,sp,-1672
8000d634:	02 9b       	mov	r11,r1
8000d636:	08 9c       	mov	r12,r4
8000d638:	fe b0 f1 66 	rcall	8000b904 <__sprint_r>
8000d63c:	e0 81 00 f1 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d640:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d644:	30 08       	mov	r8,0
8000d646:	30 09       	mov	r9,0
8000d648:	40 5b       	lddsp	r11,sp[0x14]
8000d64a:	40 7a       	lddsp	r10,sp[0x1c]
8000d64c:	e0 a0 13 19 	rcall	8000fc7e <__avr32_f64_cmp_eq>
8000d650:	40 68       	lddsp	r8,sp[0x18]
8000d652:	20 18       	sub	r8,1
8000d654:	58 0c       	cp.w	r12,0
8000d656:	c0 d1       	brne	8000d670 <_vfprintf_r+0x1d50>
8000d658:	2f f6       	sub	r6,-1
8000d65a:	87 18       	st.w	r3[0x4],r8
8000d65c:	87 06       	st.w	r3[0x0],r6
8000d65e:	fa f6 06 90 	ld.w	r6,sp[1680]
8000d662:	10 06       	add	r6,r8
8000d664:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d668:	fb 46 06 90 	st.w	sp[1680],r6
8000d66c:	2f f8       	sub	r8,-1
8000d66e:	c3 18       	rjmp	8000d6d0 <_vfprintf_r+0x1db0>
8000d670:	10 96       	mov	r6,r8
8000d672:	58 08       	cp.w	r8,0
8000d674:	e0 89 00 1c 	brgt	8000d6ac <_vfprintf_r+0x1d8c>
8000d678:	c4 b8       	rjmp	8000d70e <_vfprintf_r+0x1dee>
8000d67a:	2f 09       	sub	r9,-16
8000d67c:	2f f8       	sub	r8,-1
8000d67e:	fb 49 06 90 	st.w	sp[1680],r9
8000d682:	87 02       	st.w	r3[0x0],r2
8000d684:	87 10       	st.w	r3[0x4],r0
8000d686:	fb 48 06 8c 	st.w	sp[1676],r8
8000d68a:	58 78       	cp.w	r8,7
8000d68c:	e0 89 00 04 	brgt	8000d694 <_vfprintf_r+0x1d74>
8000d690:	2f 83       	sub	r3,-8
8000d692:	c0 b8       	rjmp	8000d6a8 <_vfprintf_r+0x1d88>
8000d694:	fa ca f9 78 	sub	r10,sp,-1672
8000d698:	02 9b       	mov	r11,r1
8000d69a:	08 9c       	mov	r12,r4
8000d69c:	fe b0 f1 34 	rcall	8000b904 <__sprint_r>
8000d6a0:	e0 81 00 bf 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d6a4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d6a8:	21 06       	sub	r6,16
8000d6aa:	c0 48       	rjmp	8000d6b2 <_vfprintf_r+0x1d92>
8000d6ac:	fe c2 c7 d4 	sub	r2,pc,-14380
8000d6b0:	31 00       	mov	r0,16
8000d6b2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d6b6:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d6ba:	fe ca c7 e2 	sub	r10,pc,-14366
8000d6be:	59 06       	cp.w	r6,16
8000d6c0:	fe 99 ff dd 	brgt	8000d67a <_vfprintf_r+0x1d5a>
8000d6c4:	0c 09       	add	r9,r6
8000d6c6:	87 0a       	st.w	r3[0x0],r10
8000d6c8:	fb 49 06 90 	st.w	sp[1680],r9
8000d6cc:	2f f8       	sub	r8,-1
8000d6ce:	87 16       	st.w	r3[0x4],r6
8000d6d0:	fb 48 06 8c 	st.w	sp[1676],r8
8000d6d4:	c0 e8       	rjmp	8000d6f0 <_vfprintf_r+0x1dd0>
8000d6d6:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d6da:	2f f8       	sub	r8,-1
8000d6dc:	30 19       	mov	r9,1
8000d6de:	fb 48 06 90 	st.w	sp[1680],r8
8000d6e2:	87 06       	st.w	r3[0x0],r6
8000d6e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d6e8:	87 19       	st.w	r3[0x4],r9
8000d6ea:	2f f8       	sub	r8,-1
8000d6ec:	fb 48 06 8c 	st.w	sp[1676],r8
8000d6f0:	58 78       	cp.w	r8,7
8000d6f2:	e0 89 00 04 	brgt	8000d6fa <_vfprintf_r+0x1dda>
8000d6f6:	2f 83       	sub	r3,-8
8000d6f8:	c0 b8       	rjmp	8000d70e <_vfprintf_r+0x1dee>
8000d6fa:	fa ca f9 78 	sub	r10,sp,-1672
8000d6fe:	02 9b       	mov	r11,r1
8000d700:	08 9c       	mov	r12,r4
8000d702:	fe b0 f1 01 	rcall	8000b904 <__sprint_r>
8000d706:	e0 81 00 8c 	brne	8000d81e <_vfprintf_r+0x1efe>
8000d70a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d70e:	40 ea       	lddsp	r10,sp[0x38]
8000d710:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d714:	14 08       	add	r8,r10
8000d716:	fa c9 f9 64 	sub	r9,sp,-1692
8000d71a:	fb 48 06 90 	st.w	sp[1680],r8
8000d71e:	87 1a       	st.w	r3[0x4],r10
8000d720:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d724:	87 09       	st.w	r3[0x0],r9
8000d726:	2f f8       	sub	r8,-1
8000d728:	fb 48 06 8c 	st.w	sp[1676],r8
8000d72c:	58 78       	cp.w	r8,7
8000d72e:	e0 89 00 04 	brgt	8000d736 <_vfprintf_r+0x1e16>
8000d732:	2f 83       	sub	r3,-8
8000d734:	c0 a8       	rjmp	8000d748 <_vfprintf_r+0x1e28>
8000d736:	fa ca f9 78 	sub	r10,sp,-1672
8000d73a:	02 9b       	mov	r11,r1
8000d73c:	08 9c       	mov	r12,r4
8000d73e:	fe b0 f0 e3 	rcall	8000b904 <__sprint_r>
8000d742:	c6 e1       	brne	8000d81e <_vfprintf_r+0x1efe>
8000d744:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d748:	e2 15 00 04 	andl	r5,0x4,COH
8000d74c:	c3 f0       	breq	8000d7ca <_vfprintf_r+0x1eaa>
8000d74e:	40 86       	lddsp	r6,sp[0x20]
8000d750:	40 39       	lddsp	r9,sp[0xc]
8000d752:	12 16       	sub	r6,r9
8000d754:	58 06       	cp.w	r6,0
8000d756:	e0 89 00 1a 	brgt	8000d78a <_vfprintf_r+0x1e6a>
8000d75a:	c3 88       	rjmp	8000d7ca <_vfprintf_r+0x1eaa>
8000d75c:	2f 09       	sub	r9,-16
8000d75e:	2f f8       	sub	r8,-1
8000d760:	fb 49 06 90 	st.w	sp[1680],r9
8000d764:	87 05       	st.w	r3[0x0],r5
8000d766:	87 12       	st.w	r3[0x4],r2
8000d768:	fb 48 06 8c 	st.w	sp[1676],r8
8000d76c:	58 78       	cp.w	r8,7
8000d76e:	e0 89 00 04 	brgt	8000d776 <_vfprintf_r+0x1e56>
8000d772:	2f 83       	sub	r3,-8
8000d774:	c0 98       	rjmp	8000d786 <_vfprintf_r+0x1e66>
8000d776:	00 9a       	mov	r10,r0
8000d778:	02 9b       	mov	r11,r1
8000d77a:	08 9c       	mov	r12,r4
8000d77c:	fe b0 f0 c4 	rcall	8000b904 <__sprint_r>
8000d780:	c4 f1       	brne	8000d81e <_vfprintf_r+0x1efe>
8000d782:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d786:	21 06       	sub	r6,16
8000d788:	c0 68       	rjmp	8000d794 <_vfprintf_r+0x1e74>
8000d78a:	fe c5 c8 c2 	sub	r5,pc,-14142
8000d78e:	31 02       	mov	r2,16
8000d790:	fa c0 f9 78 	sub	r0,sp,-1672
8000d794:	fa f9 06 90 	ld.w	r9,sp[1680]
8000d798:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000d79c:	fe ca c8 d4 	sub	r10,pc,-14124
8000d7a0:	59 06       	cp.w	r6,16
8000d7a2:	fe 99 ff dd 	brgt	8000d75c <_vfprintf_r+0x1e3c>
8000d7a6:	0c 09       	add	r9,r6
8000d7a8:	2f f8       	sub	r8,-1
8000d7aa:	87 0a       	st.w	r3[0x0],r10
8000d7ac:	87 16       	st.w	r3[0x4],r6
8000d7ae:	fb 49 06 90 	st.w	sp[1680],r9
8000d7b2:	fb 48 06 8c 	st.w	sp[1676],r8
8000d7b6:	58 78       	cp.w	r8,7
8000d7b8:	e0 8a 00 09 	brle	8000d7ca <_vfprintf_r+0x1eaa>
8000d7bc:	fa ca f9 78 	sub	r10,sp,-1672
8000d7c0:	02 9b       	mov	r11,r1
8000d7c2:	08 9c       	mov	r12,r4
8000d7c4:	fe b0 f0 a0 	rcall	8000b904 <__sprint_r>
8000d7c8:	c2 b1       	brne	8000d81e <_vfprintf_r+0x1efe>
8000d7ca:	40 bc       	lddsp	r12,sp[0x2c]
8000d7cc:	40 36       	lddsp	r6,sp[0xc]
8000d7ce:	40 8e       	lddsp	lr,sp[0x20]
8000d7d0:	ec 0e 0c 48 	max	r8,r6,lr
8000d7d4:	10 0c       	add	r12,r8
8000d7d6:	50 bc       	stdsp	sp[0x2c],r12
8000d7d8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d7dc:	58 08       	cp.w	r8,0
8000d7de:	c0 80       	breq	8000d7ee <_vfprintf_r+0x1ece>
8000d7e0:	fa ca f9 78 	sub	r10,sp,-1672
8000d7e4:	02 9b       	mov	r11,r1
8000d7e6:	08 9c       	mov	r12,r4
8000d7e8:	fe b0 f0 8e 	rcall	8000b904 <__sprint_r>
8000d7ec:	c1 91       	brne	8000d81e <_vfprintf_r+0x1efe>
8000d7ee:	30 0b       	mov	r11,0
8000d7f0:	fa c3 f9 e0 	sub	r3,sp,-1568
8000d7f4:	fb 4b 06 8c 	st.w	sp[1676],r11
8000d7f8:	fe 9f f1 22 	bral	8000ba3c <_vfprintf_r+0x11c>
8000d7fc:	08 95       	mov	r5,r4
8000d7fe:	fa f8 06 90 	ld.w	r8,sp[1680]
8000d802:	58 08       	cp.w	r8,0
8000d804:	c0 80       	breq	8000d814 <_vfprintf_r+0x1ef4>
8000d806:	08 9c       	mov	r12,r4
8000d808:	fa ca f9 78 	sub	r10,sp,-1672
8000d80c:	02 9b       	mov	r11,r1
8000d80e:	fe b0 f0 7b 	rcall	8000b904 <__sprint_r>
8000d812:	c0 61       	brne	8000d81e <_vfprintf_r+0x1efe>
8000d814:	30 08       	mov	r8,0
8000d816:	fb 48 06 8c 	st.w	sp[1676],r8
8000d81a:	c0 28       	rjmp	8000d81e <_vfprintf_r+0x1efe>
8000d81c:	40 41       	lddsp	r1,sp[0x10]
8000d81e:	82 68       	ld.sh	r8,r1[0xc]
8000d820:	ed b8 00 06 	bld	r8,0x6
8000d824:	c0 31       	brne	8000d82a <_vfprintf_r+0x1f0a>
8000d826:	3f fa       	mov	r10,-1
8000d828:	50 ba       	stdsp	sp[0x2c],r10
8000d82a:	40 bc       	lddsp	r12,sp[0x2c]
8000d82c:	fe 3d f9 44 	sub	sp,-1724
8000d830:	d8 32       	popm	r0-r7,pc
8000d832:	d7 03       	nop

8000d834 <__swsetup_r>:
8000d834:	d4 21       	pushm	r4-r7,lr
8000d836:	e0 68 0a 50 	mov	r8,2640
8000d83a:	18 96       	mov	r6,r12
8000d83c:	16 97       	mov	r7,r11
8000d83e:	70 0c       	ld.w	r12,r8[0x0]
8000d840:	58 0c       	cp.w	r12,0
8000d842:	c0 60       	breq	8000d84e <__swsetup_r+0x1a>
8000d844:	78 68       	ld.w	r8,r12[0x18]
8000d846:	58 08       	cp.w	r8,0
8000d848:	c0 31       	brne	8000d84e <__swsetup_r+0x1a>
8000d84a:	e0 a0 07 bf 	rcall	8000e7c8 <__sinit>
8000d84e:	fe c8 c8 56 	sub	r8,pc,-14250
8000d852:	10 37       	cp.w	r7,r8
8000d854:	c0 61       	brne	8000d860 <__swsetup_r+0x2c>
8000d856:	e0 68 0a 50 	mov	r8,2640
8000d85a:	70 08       	ld.w	r8,r8[0x0]
8000d85c:	70 07       	ld.w	r7,r8[0x0]
8000d85e:	c1 28       	rjmp	8000d882 <__swsetup_r+0x4e>
8000d860:	fe c8 c8 48 	sub	r8,pc,-14264
8000d864:	10 37       	cp.w	r7,r8
8000d866:	c0 61       	brne	8000d872 <__swsetup_r+0x3e>
8000d868:	e0 68 0a 50 	mov	r8,2640
8000d86c:	70 08       	ld.w	r8,r8[0x0]
8000d86e:	70 17       	ld.w	r7,r8[0x4]
8000d870:	c0 98       	rjmp	8000d882 <__swsetup_r+0x4e>
8000d872:	fe c8 c8 3a 	sub	r8,pc,-14278
8000d876:	10 37       	cp.w	r7,r8
8000d878:	c0 51       	brne	8000d882 <__swsetup_r+0x4e>
8000d87a:	e0 68 0a 50 	mov	r8,2640
8000d87e:	70 08       	ld.w	r8,r8[0x0]
8000d880:	70 27       	ld.w	r7,r8[0x8]
8000d882:	8e 68       	ld.sh	r8,r7[0xc]
8000d884:	ed b8 00 03 	bld	r8,0x3
8000d888:	c1 e0       	breq	8000d8c4 <__swsetup_r+0x90>
8000d88a:	ed b8 00 04 	bld	r8,0x4
8000d88e:	c3 e1       	brne	8000d90a <__swsetup_r+0xd6>
8000d890:	ed b8 00 02 	bld	r8,0x2
8000d894:	c1 51       	brne	8000d8be <__swsetup_r+0x8a>
8000d896:	6e db       	ld.w	r11,r7[0x34]
8000d898:	58 0b       	cp.w	r11,0
8000d89a:	c0 a0       	breq	8000d8ae <__swsetup_r+0x7a>
8000d89c:	ee c8 ff bc 	sub	r8,r7,-68
8000d8a0:	10 3b       	cp.w	r11,r8
8000d8a2:	c0 40       	breq	8000d8aa <__swsetup_r+0x76>
8000d8a4:	0c 9c       	mov	r12,r6
8000d8a6:	e0 a0 08 2b 	rcall	8000e8fc <_free_r>
8000d8aa:	30 08       	mov	r8,0
8000d8ac:	8f d8       	st.w	r7[0x34],r8
8000d8ae:	8e 68       	ld.sh	r8,r7[0xc]
8000d8b0:	e0 18 ff db 	andl	r8,0xffdb
8000d8b4:	ae 68       	st.h	r7[0xc],r8
8000d8b6:	30 08       	mov	r8,0
8000d8b8:	8f 18       	st.w	r7[0x4],r8
8000d8ba:	6e 48       	ld.w	r8,r7[0x10]
8000d8bc:	8f 08       	st.w	r7[0x0],r8
8000d8be:	8e 68       	ld.sh	r8,r7[0xc]
8000d8c0:	a3 b8       	sbr	r8,0x3
8000d8c2:	ae 68       	st.h	r7[0xc],r8
8000d8c4:	6e 48       	ld.w	r8,r7[0x10]
8000d8c6:	58 08       	cp.w	r8,0
8000d8c8:	c0 b1       	brne	8000d8de <__swsetup_r+0xaa>
8000d8ca:	8e 68       	ld.sh	r8,r7[0xc]
8000d8cc:	e2 18 02 80 	andl	r8,0x280,COH
8000d8d0:	e0 48 02 00 	cp.w	r8,512
8000d8d4:	c0 50       	breq	8000d8de <__swsetup_r+0xaa>
8000d8d6:	0c 9c       	mov	r12,r6
8000d8d8:	0e 9b       	mov	r11,r7
8000d8da:	e0 a0 0a 4b 	rcall	8000ed70 <__smakebuf_r>
8000d8de:	8e 69       	ld.sh	r9,r7[0xc]
8000d8e0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000d8e4:	c0 70       	breq	8000d8f2 <__swsetup_r+0xbe>
8000d8e6:	30 08       	mov	r8,0
8000d8e8:	8f 28       	st.w	r7[0x8],r8
8000d8ea:	6e 58       	ld.w	r8,r7[0x14]
8000d8ec:	5c 38       	neg	r8
8000d8ee:	8f 68       	st.w	r7[0x18],r8
8000d8f0:	c0 68       	rjmp	8000d8fc <__swsetup_r+0xc8>
8000d8f2:	ed b9 00 01 	bld	r9,0x1
8000d8f6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000d8fa:	8f 28       	st.w	r7[0x8],r8
8000d8fc:	6e 48       	ld.w	r8,r7[0x10]
8000d8fe:	58 08       	cp.w	r8,0
8000d900:	c0 61       	brne	8000d90c <__swsetup_r+0xd8>
8000d902:	8e 68       	ld.sh	r8,r7[0xc]
8000d904:	ed b8 00 07 	bld	r8,0x7
8000d908:	c0 21       	brne	8000d90c <__swsetup_r+0xd8>
8000d90a:	dc 2a       	popm	r4-r7,pc,r12=-1
8000d90c:	d8 2a       	popm	r4-r7,pc,r12=0
8000d90e:	d7 03       	nop

8000d910 <quorem>:
8000d910:	d4 31       	pushm	r0-r7,lr
8000d912:	20 2d       	sub	sp,8
8000d914:	18 97       	mov	r7,r12
8000d916:	78 48       	ld.w	r8,r12[0x10]
8000d918:	76 46       	ld.w	r6,r11[0x10]
8000d91a:	0c 38       	cp.w	r8,r6
8000d91c:	c0 34       	brge	8000d922 <quorem+0x12>
8000d91e:	30 0c       	mov	r12,0
8000d920:	c8 58       	rjmp	8000da2a <quorem+0x11a>
8000d922:	ec c2 ff fc 	sub	r2,r6,-4
8000d926:	f6 c3 ff ec 	sub	r3,r11,-20
8000d92a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000d92e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000d932:	2f f9       	sub	r9,-1
8000d934:	20 16       	sub	r6,1
8000d936:	f8 09 0d 08 	divu	r8,r12,r9
8000d93a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000d93e:	ee c4 ff ec 	sub	r4,r7,-20
8000d942:	10 95       	mov	r5,r8
8000d944:	58 08       	cp.w	r8,0
8000d946:	c4 10       	breq	8000d9c8 <quorem+0xb8>
8000d948:	30 09       	mov	r9,0
8000d94a:	06 9a       	mov	r10,r3
8000d94c:	08 98       	mov	r8,r4
8000d94e:	12 91       	mov	r1,r9
8000d950:	50 0b       	stdsp	sp[0x0],r11
8000d952:	70 0e       	ld.w	lr,r8[0x0]
8000d954:	b1 8e       	lsr	lr,0x10
8000d956:	50 1e       	stdsp	sp[0x4],lr
8000d958:	15 0e       	ld.w	lr,r10++
8000d95a:	fc 00 16 10 	lsr	r0,lr,0x10
8000d95e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000d962:	ea 0e 03 41 	mac	r1,r5,lr
8000d966:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000d96a:	b1 81       	lsr	r1,0x10
8000d96c:	40 1b       	lddsp	r11,sp[0x4]
8000d96e:	ea 00 02 40 	mul	r0,r5,r0
8000d972:	e2 00 00 00 	add	r0,r1,r0
8000d976:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000d97a:	02 1b       	sub	r11,r1
8000d97c:	50 1b       	stdsp	sp[0x4],r11
8000d97e:	70 0b       	ld.w	r11,r8[0x0]
8000d980:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000d984:	02 09       	add	r9,r1
8000d986:	f2 0e 01 0e 	sub	lr,r9,lr
8000d98a:	b0 1e       	st.h	r8[0x2],lr
8000d98c:	fc 09 14 10 	asr	r9,lr,0x10
8000d990:	40 1e       	lddsp	lr,sp[0x4]
8000d992:	fc 09 00 09 	add	r9,lr,r9
8000d996:	b0 09       	st.h	r8[0x0],r9
8000d998:	e0 01 16 10 	lsr	r1,r0,0x10
8000d99c:	2f c8       	sub	r8,-4
8000d99e:	b1 49       	asr	r9,0x10
8000d9a0:	04 3a       	cp.w	r10,r2
8000d9a2:	fe 98 ff d8 	brls	8000d952 <quorem+0x42>
8000d9a6:	40 0b       	lddsp	r11,sp[0x0]
8000d9a8:	58 0c       	cp.w	r12,0
8000d9aa:	c0 f1       	brne	8000d9c8 <quorem+0xb8>
8000d9ac:	ec c8 ff fb 	sub	r8,r6,-5
8000d9b0:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000d9b4:	c0 28       	rjmp	8000d9b8 <quorem+0xa8>
8000d9b6:	20 16       	sub	r6,1
8000d9b8:	20 48       	sub	r8,4
8000d9ba:	08 38       	cp.w	r8,r4
8000d9bc:	e0 88 00 05 	brls	8000d9c6 <quorem+0xb6>
8000d9c0:	70 09       	ld.w	r9,r8[0x0]
8000d9c2:	58 09       	cp.w	r9,0
8000d9c4:	cf 90       	breq	8000d9b6 <quorem+0xa6>
8000d9c6:	8f 46       	st.w	r7[0x10],r6
8000d9c8:	0e 9c       	mov	r12,r7
8000d9ca:	e0 a0 0a d2 	rcall	8000ef6e <__mcmp>
8000d9ce:	c2 d5       	brlt	8000da28 <quorem+0x118>
8000d9d0:	2f f5       	sub	r5,-1
8000d9d2:	08 98       	mov	r8,r4
8000d9d4:	30 09       	mov	r9,0
8000d9d6:	07 0b       	ld.w	r11,r3++
8000d9d8:	f6 0a 16 10 	lsr	r10,r11,0x10
8000d9dc:	70 0c       	ld.w	r12,r8[0x0]
8000d9de:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000d9e2:	f8 0e 16 10 	lsr	lr,r12,0x10
8000d9e6:	14 1e       	sub	lr,r10
8000d9e8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000d9ec:	16 1a       	sub	r10,r11
8000d9ee:	12 0a       	add	r10,r9
8000d9f0:	b0 1a       	st.h	r8[0x2],r10
8000d9f2:	b1 4a       	asr	r10,0x10
8000d9f4:	fc 0a 00 09 	add	r9,lr,r10
8000d9f8:	b0 09       	st.h	r8[0x0],r9
8000d9fa:	2f c8       	sub	r8,-4
8000d9fc:	b1 49       	asr	r9,0x10
8000d9fe:	04 33       	cp.w	r3,r2
8000da00:	fe 98 ff eb 	brls	8000d9d6 <quorem+0xc6>
8000da04:	ec c8 ff fb 	sub	r8,r6,-5
8000da08:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000da0c:	58 09       	cp.w	r9,0
8000da0e:	c0 d1       	brne	8000da28 <quorem+0x118>
8000da10:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000da14:	c0 28       	rjmp	8000da18 <quorem+0x108>
8000da16:	20 16       	sub	r6,1
8000da18:	20 48       	sub	r8,4
8000da1a:	08 38       	cp.w	r8,r4
8000da1c:	e0 88 00 05 	brls	8000da26 <quorem+0x116>
8000da20:	70 09       	ld.w	r9,r8[0x0]
8000da22:	58 09       	cp.w	r9,0
8000da24:	cf 90       	breq	8000da16 <quorem+0x106>
8000da26:	8f 46       	st.w	r7[0x10],r6
8000da28:	0a 9c       	mov	r12,r5
8000da2a:	2f ed       	sub	sp,-8
8000da2c:	d8 32       	popm	r0-r7,pc
8000da2e:	d7 03       	nop

8000da30 <_dtoa_r>:
8000da30:	d4 31       	pushm	r0-r7,lr
8000da32:	21 ad       	sub	sp,104
8000da34:	fa c4 ff 74 	sub	r4,sp,-140
8000da38:	18 97       	mov	r7,r12
8000da3a:	16 95       	mov	r5,r11
8000da3c:	68 2c       	ld.w	r12,r4[0x8]
8000da3e:	50 c9       	stdsp	sp[0x30],r9
8000da40:	68 16       	ld.w	r6,r4[0x4]
8000da42:	68 09       	ld.w	r9,r4[0x0]
8000da44:	50 e8       	stdsp	sp[0x38],r8
8000da46:	14 94       	mov	r4,r10
8000da48:	51 2c       	stdsp	sp[0x48],r12
8000da4a:	fa e5 00 08 	st.d	sp[8],r4
8000da4e:	51 59       	stdsp	sp[0x54],r9
8000da50:	6e 95       	ld.w	r5,r7[0x24]
8000da52:	58 05       	cp.w	r5,0
8000da54:	c0 91       	brne	8000da66 <_dtoa_r+0x36>
8000da56:	31 0c       	mov	r12,16
8000da58:	fe b0 e8 d6 	rcall	8000ac04 <malloc>
8000da5c:	99 35       	st.w	r12[0xc],r5
8000da5e:	8f 9c       	st.w	r7[0x24],r12
8000da60:	99 15       	st.w	r12[0x4],r5
8000da62:	99 25       	st.w	r12[0x8],r5
8000da64:	99 05       	st.w	r12[0x0],r5
8000da66:	6e 99       	ld.w	r9,r7[0x24]
8000da68:	72 08       	ld.w	r8,r9[0x0]
8000da6a:	58 08       	cp.w	r8,0
8000da6c:	c0 f0       	breq	8000da8a <_dtoa_r+0x5a>
8000da6e:	72 1a       	ld.w	r10,r9[0x4]
8000da70:	91 1a       	st.w	r8[0x4],r10
8000da72:	30 1a       	mov	r10,1
8000da74:	72 19       	ld.w	r9,r9[0x4]
8000da76:	f4 09 09 49 	lsl	r9,r10,r9
8000da7a:	10 9b       	mov	r11,r8
8000da7c:	91 29       	st.w	r8[0x8],r9
8000da7e:	0e 9c       	mov	r12,r7
8000da80:	e0 a0 0a 90 	rcall	8000efa0 <_Bfree>
8000da84:	6e 98       	ld.w	r8,r7[0x24]
8000da86:	30 09       	mov	r9,0
8000da88:	91 09       	st.w	r8[0x0],r9
8000da8a:	40 28       	lddsp	r8,sp[0x8]
8000da8c:	10 94       	mov	r4,r8
8000da8e:	58 08       	cp.w	r8,0
8000da90:	c0 64       	brge	8000da9c <_dtoa_r+0x6c>
8000da92:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000da96:	50 28       	stdsp	sp[0x8],r8
8000da98:	30 18       	mov	r8,1
8000da9a:	c0 28       	rjmp	8000da9e <_dtoa_r+0x6e>
8000da9c:	30 08       	mov	r8,0
8000da9e:	8d 08       	st.w	r6[0x0],r8
8000daa0:	fc 1c 7f f0 	movh	r12,0x7ff0
8000daa4:	40 26       	lddsp	r6,sp[0x8]
8000daa6:	0c 98       	mov	r8,r6
8000daa8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000daac:	18 38       	cp.w	r8,r12
8000daae:	c2 01       	brne	8000daee <_dtoa_r+0xbe>
8000dab0:	e0 68 27 0f 	mov	r8,9999
8000dab4:	41 5b       	lddsp	r11,sp[0x54]
8000dab6:	97 08       	st.w	r11[0x0],r8
8000dab8:	40 3a       	lddsp	r10,sp[0xc]
8000daba:	58 0a       	cp.w	r10,0
8000dabc:	c0 71       	brne	8000daca <_dtoa_r+0x9a>
8000dabe:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000dac2:	c0 41       	brne	8000daca <_dtoa_r+0x9a>
8000dac4:	fe cc ca dc 	sub	r12,pc,-13604
8000dac8:	c0 38       	rjmp	8000dace <_dtoa_r+0x9e>
8000daca:	fe cc ca d6 	sub	r12,pc,-13610
8000dace:	41 29       	lddsp	r9,sp[0x48]
8000dad0:	58 09       	cp.w	r9,0
8000dad2:	e0 80 05 9a 	breq	8000e606 <_dtoa_r+0xbd6>
8000dad6:	f8 c8 ff fd 	sub	r8,r12,-3
8000dada:	f8 c9 ff f8 	sub	r9,r12,-8
8000dade:	11 8b       	ld.ub	r11,r8[0x0]
8000dae0:	30 0a       	mov	r10,0
8000dae2:	41 25       	lddsp	r5,sp[0x48]
8000dae4:	f4 0b 18 00 	cp.b	r11,r10
8000dae8:	f2 08 17 10 	movne	r8,r9
8000daec:	c1 68       	rjmp	8000db18 <_dtoa_r+0xe8>
8000daee:	fa ea 00 08 	ld.d	r10,sp[8]
8000daf2:	30 08       	mov	r8,0
8000daf4:	fa eb 00 3c 	st.d	sp[60],r10
8000daf8:	30 09       	mov	r9,0
8000dafa:	e0 a0 10 c2 	rcall	8000fc7e <__avr32_f64_cmp_eq>
8000dafe:	c1 00       	breq	8000db1e <_dtoa_r+0xee>
8000db00:	30 18       	mov	r8,1
8000db02:	41 5a       	lddsp	r10,sp[0x54]
8000db04:	95 08       	st.w	r10[0x0],r8
8000db06:	fe cc cc 42 	sub	r12,pc,-13246
8000db0a:	41 29       	lddsp	r9,sp[0x48]
8000db0c:	f8 08 00 08 	add	r8,r12,r8
8000db10:	58 09       	cp.w	r9,0
8000db12:	e0 80 05 7a 	breq	8000e606 <_dtoa_r+0xbd6>
8000db16:	12 95       	mov	r5,r9
8000db18:	8b 08       	st.w	r5[0x0],r8
8000db1a:	e0 8f 05 76 	bral	8000e606 <_dtoa_r+0xbd6>
8000db1e:	fa c8 ff 9c 	sub	r8,sp,-100
8000db22:	fa c9 ff a0 	sub	r9,sp,-96
8000db26:	fa ea 00 3c 	ld.d	r10,sp[60]
8000db2a:	0e 9c       	mov	r12,r7
8000db2c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000db30:	e0 a0 0a 8a 	rcall	8000f044 <__d2b>
8000db34:	18 93       	mov	r3,r12
8000db36:	58 05       	cp.w	r5,0
8000db38:	c0 d0       	breq	8000db52 <_dtoa_r+0x122>
8000db3a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000db3e:	30 04       	mov	r4,0
8000db40:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000db44:	ea c5 03 ff 	sub	r5,r5,1023
8000db48:	10 9b       	mov	r11,r8
8000db4a:	51 74       	stdsp	sp[0x5c],r4
8000db4c:	ea 1b 3f f0 	orh	r11,0x3ff0
8000db50:	c2 58       	rjmp	8000db9a <_dtoa_r+0x16a>
8000db52:	41 88       	lddsp	r8,sp[0x60]
8000db54:	41 9c       	lddsp	r12,sp[0x64]
8000db56:	10 0c       	add	r12,r8
8000db58:	f8 c5 fb ce 	sub	r5,r12,-1074
8000db5c:	e0 45 00 20 	cp.w	r5,32
8000db60:	e0 8a 00 0e 	brle	8000db7c <_dtoa_r+0x14c>
8000db64:	f8 cc fb ee 	sub	r12,r12,-1042
8000db68:	40 3b       	lddsp	r11,sp[0xc]
8000db6a:	ea 08 11 40 	rsub	r8,r5,64
8000db6e:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000db72:	ec 08 09 46 	lsl	r6,r6,r8
8000db76:	0c 4c       	or	r12,r6
8000db78:	c0 78       	rjmp	8000db86 <_dtoa_r+0x156>
8000db7a:	d7 03       	nop
8000db7c:	ea 0c 11 20 	rsub	r12,r5,32
8000db80:	40 3a       	lddsp	r10,sp[0xc]
8000db82:	f4 0c 09 4c 	lsl	r12,r10,r12
8000db86:	e0 a0 10 08 	rcall	8000fb96 <__avr32_u32_to_f64>
8000db8a:	fc 18 fe 10 	movh	r8,0xfe10
8000db8e:	30 19       	mov	r9,1
8000db90:	ea c5 04 33 	sub	r5,r5,1075
8000db94:	f0 0b 00 0b 	add	r11,r8,r11
8000db98:	51 79       	stdsp	sp[0x5c],r9
8000db9a:	30 08       	mov	r8,0
8000db9c:	fc 19 3f f8 	movh	r9,0x3ff8
8000dba0:	e0 a0 0e 90 	rcall	8000f8c0 <__avr32_f64_sub>
8000dba4:	e0 68 43 61 	mov	r8,17249
8000dba8:	ea 18 63 6f 	orh	r8,0x636f
8000dbac:	e0 69 87 a7 	mov	r9,34727
8000dbb0:	ea 19 3f d2 	orh	r9,0x3fd2
8000dbb4:	e0 a0 0d 9a 	rcall	8000f6e8 <__avr32_f64_mul>
8000dbb8:	e0 68 c8 b3 	mov	r8,51379
8000dbbc:	ea 18 8b 60 	orh	r8,0x8b60
8000dbc0:	e0 69 8a 28 	mov	r9,35368
8000dbc4:	ea 19 3f c6 	orh	r9,0x3fc6
8000dbc8:	e0 a0 0f 4a 	rcall	8000fa5c <__avr32_f64_add>
8000dbcc:	0a 9c       	mov	r12,r5
8000dbce:	14 90       	mov	r0,r10
8000dbd0:	16 91       	mov	r1,r11
8000dbd2:	e0 a0 0f e6 	rcall	8000fb9e <__avr32_s32_to_f64>
8000dbd6:	e0 68 79 fb 	mov	r8,31227
8000dbda:	ea 18 50 9f 	orh	r8,0x509f
8000dbde:	e0 69 44 13 	mov	r9,17427
8000dbe2:	ea 19 3f d3 	orh	r9,0x3fd3
8000dbe6:	e0 a0 0d 81 	rcall	8000f6e8 <__avr32_f64_mul>
8000dbea:	14 98       	mov	r8,r10
8000dbec:	16 99       	mov	r9,r11
8000dbee:	00 9a       	mov	r10,r0
8000dbf0:	02 9b       	mov	r11,r1
8000dbf2:	e0 a0 0f 35 	rcall	8000fa5c <__avr32_f64_add>
8000dbf6:	14 90       	mov	r0,r10
8000dbf8:	16 91       	mov	r1,r11
8000dbfa:	e0 a0 0f bb 	rcall	8000fb70 <__avr32_f64_to_s32>
8000dbfe:	30 08       	mov	r8,0
8000dc00:	18 96       	mov	r6,r12
8000dc02:	30 09       	mov	r9,0
8000dc04:	00 9a       	mov	r10,r0
8000dc06:	02 9b       	mov	r11,r1
8000dc08:	e0 a0 10 82 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000dc0c:	c0 c0       	breq	8000dc24 <_dtoa_r+0x1f4>
8000dc0e:	0c 9c       	mov	r12,r6
8000dc10:	e0 a0 0f c7 	rcall	8000fb9e <__avr32_s32_to_f64>
8000dc14:	14 98       	mov	r8,r10
8000dc16:	16 99       	mov	r9,r11
8000dc18:	00 9a       	mov	r10,r0
8000dc1a:	02 9b       	mov	r11,r1
8000dc1c:	e0 a0 10 31 	rcall	8000fc7e <__avr32_f64_cmp_eq>
8000dc20:	f7 b6 00 01 	subeq	r6,1
8000dc24:	59 66       	cp.w	r6,22
8000dc26:	e0 88 00 05 	brls	8000dc30 <_dtoa_r+0x200>
8000dc2a:	30 18       	mov	r8,1
8000dc2c:	51 48       	stdsp	sp[0x50],r8
8000dc2e:	c1 38       	rjmp	8000dc54 <_dtoa_r+0x224>
8000dc30:	fe c8 cb 84 	sub	r8,pc,-13436
8000dc34:	fa ea 00 3c 	ld.d	r10,sp[60]
8000dc38:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000dc3c:	e0 a0 10 68 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000dc40:	f9 b4 00 00 	moveq	r4,0
8000dc44:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000dc48:	f7 b6 01 01 	subne	r6,1
8000dc4c:	f9 bc 01 00 	movne	r12,0
8000dc50:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000dc54:	41 90       	lddsp	r0,sp[0x64]
8000dc56:	20 10       	sub	r0,1
8000dc58:	0a 10       	sub	r0,r5
8000dc5a:	c0 46       	brmi	8000dc62 <_dtoa_r+0x232>
8000dc5c:	50 40       	stdsp	sp[0x10],r0
8000dc5e:	30 00       	mov	r0,0
8000dc60:	c0 48       	rjmp	8000dc68 <_dtoa_r+0x238>
8000dc62:	30 0b       	mov	r11,0
8000dc64:	5c 30       	neg	r0
8000dc66:	50 4b       	stdsp	sp[0x10],r11
8000dc68:	ec 02 11 00 	rsub	r2,r6,0
8000dc6c:	58 06       	cp.w	r6,0
8000dc6e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000dc72:	f5 d6 e4 0a 	addge	r10,r10,r6
8000dc76:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000dc7a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000dc7e:	f9 b2 04 00 	movge	r2,0
8000dc82:	e1 d6 e5 10 	sublt	r0,r0,r6
8000dc86:	f9 b9 05 00 	movlt	r9,0
8000dc8a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000dc8e:	40 c8       	lddsp	r8,sp[0x30]
8000dc90:	58 98       	cp.w	r8,9
8000dc92:	e0 8b 00 20 	brhi	8000dcd2 <_dtoa_r+0x2a2>
8000dc96:	58 58       	cp.w	r8,5
8000dc98:	f9 b4 0a 01 	movle	r4,1
8000dc9c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000dca0:	f7 b5 09 04 	subgt	r5,4
8000dca4:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000dca8:	f9 b4 09 00 	movgt	r4,0
8000dcac:	40 cc       	lddsp	r12,sp[0x30]
8000dcae:	58 3c       	cp.w	r12,3
8000dcb0:	c2 d0       	breq	8000dd0a <_dtoa_r+0x2da>
8000dcb2:	e0 89 00 05 	brgt	8000dcbc <_dtoa_r+0x28c>
8000dcb6:	58 2c       	cp.w	r12,2
8000dcb8:	c1 01       	brne	8000dcd8 <_dtoa_r+0x2a8>
8000dcba:	c1 88       	rjmp	8000dcea <_dtoa_r+0x2ba>
8000dcbc:	40 cb       	lddsp	r11,sp[0x30]
8000dcbe:	58 4b       	cp.w	r11,4
8000dcc0:	c0 60       	breq	8000dccc <_dtoa_r+0x29c>
8000dcc2:	58 5b       	cp.w	r11,5
8000dcc4:	c0 a1       	brne	8000dcd8 <_dtoa_r+0x2a8>
8000dcc6:	30 1a       	mov	r10,1
8000dcc8:	50 da       	stdsp	sp[0x34],r10
8000dcca:	c2 28       	rjmp	8000dd0e <_dtoa_r+0x2de>
8000dccc:	30 19       	mov	r9,1
8000dcce:	50 d9       	stdsp	sp[0x34],r9
8000dcd0:	c0 f8       	rjmp	8000dcee <_dtoa_r+0x2be>
8000dcd2:	30 08       	mov	r8,0
8000dcd4:	30 14       	mov	r4,1
8000dcd6:	50 c8       	stdsp	sp[0x30],r8
8000dcd8:	3f f5       	mov	r5,-1
8000dcda:	30 1c       	mov	r12,1
8000dcdc:	30 0b       	mov	r11,0
8000dcde:	50 95       	stdsp	sp[0x24],r5
8000dce0:	50 dc       	stdsp	sp[0x34],r12
8000dce2:	0a 91       	mov	r1,r5
8000dce4:	31 28       	mov	r8,18
8000dce6:	50 eb       	stdsp	sp[0x38],r11
8000dce8:	c2 08       	rjmp	8000dd28 <_dtoa_r+0x2f8>
8000dcea:	30 0a       	mov	r10,0
8000dcec:	50 da       	stdsp	sp[0x34],r10
8000dcee:	40 e9       	lddsp	r9,sp[0x38]
8000dcf0:	58 09       	cp.w	r9,0
8000dcf2:	e0 89 00 07 	brgt	8000dd00 <_dtoa_r+0x2d0>
8000dcf6:	30 18       	mov	r8,1
8000dcf8:	50 98       	stdsp	sp[0x24],r8
8000dcfa:	10 91       	mov	r1,r8
8000dcfc:	50 e8       	stdsp	sp[0x38],r8
8000dcfe:	c1 58       	rjmp	8000dd28 <_dtoa_r+0x2f8>
8000dd00:	40 e5       	lddsp	r5,sp[0x38]
8000dd02:	50 95       	stdsp	sp[0x24],r5
8000dd04:	0a 91       	mov	r1,r5
8000dd06:	0a 98       	mov	r8,r5
8000dd08:	c1 08       	rjmp	8000dd28 <_dtoa_r+0x2f8>
8000dd0a:	30 0c       	mov	r12,0
8000dd0c:	50 dc       	stdsp	sp[0x34],r12
8000dd0e:	40 eb       	lddsp	r11,sp[0x38]
8000dd10:	ec 0b 00 0b 	add	r11,r6,r11
8000dd14:	50 9b       	stdsp	sp[0x24],r11
8000dd16:	16 98       	mov	r8,r11
8000dd18:	2f f8       	sub	r8,-1
8000dd1a:	58 08       	cp.w	r8,0
8000dd1c:	e0 89 00 05 	brgt	8000dd26 <_dtoa_r+0x2f6>
8000dd20:	10 91       	mov	r1,r8
8000dd22:	30 18       	mov	r8,1
8000dd24:	c0 28       	rjmp	8000dd28 <_dtoa_r+0x2f8>
8000dd26:	10 91       	mov	r1,r8
8000dd28:	30 09       	mov	r9,0
8000dd2a:	6e 9a       	ld.w	r10,r7[0x24]
8000dd2c:	95 19       	st.w	r10[0x4],r9
8000dd2e:	30 49       	mov	r9,4
8000dd30:	c0 68       	rjmp	8000dd3c <_dtoa_r+0x30c>
8000dd32:	d7 03       	nop
8000dd34:	6a 1a       	ld.w	r10,r5[0x4]
8000dd36:	a1 79       	lsl	r9,0x1
8000dd38:	2f fa       	sub	r10,-1
8000dd3a:	8b 1a       	st.w	r5[0x4],r10
8000dd3c:	6e 95       	ld.w	r5,r7[0x24]
8000dd3e:	f2 ca ff ec 	sub	r10,r9,-20
8000dd42:	10 3a       	cp.w	r10,r8
8000dd44:	fe 98 ff f8 	brls	8000dd34 <_dtoa_r+0x304>
8000dd48:	6a 1b       	ld.w	r11,r5[0x4]
8000dd4a:	0e 9c       	mov	r12,r7
8000dd4c:	e0 a0 09 44 	rcall	8000efd4 <_Balloc>
8000dd50:	58 e1       	cp.w	r1,14
8000dd52:	5f 88       	srls	r8
8000dd54:	8b 0c       	st.w	r5[0x0],r12
8000dd56:	f1 e4 00 04 	and	r4,r8,r4
8000dd5a:	6e 98       	ld.w	r8,r7[0x24]
8000dd5c:	70 08       	ld.w	r8,r8[0x0]
8000dd5e:	50 88       	stdsp	sp[0x20],r8
8000dd60:	e0 80 01 82 	breq	8000e064 <_dtoa_r+0x634>
8000dd64:	58 06       	cp.w	r6,0
8000dd66:	e0 8a 00 43 	brle	8000ddec <_dtoa_r+0x3bc>
8000dd6a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000dd6e:	fe c8 cc c2 	sub	r8,pc,-13118
8000dd72:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000dd76:	fa e5 00 18 	st.d	sp[24],r4
8000dd7a:	ec 04 14 04 	asr	r4,r6,0x4
8000dd7e:	ed b4 00 04 	bld	r4,0x4
8000dd82:	c0 30       	breq	8000dd88 <_dtoa_r+0x358>
8000dd84:	30 25       	mov	r5,2
8000dd86:	c1 08       	rjmp	8000dda6 <_dtoa_r+0x376>
8000dd88:	fe c8 cc 14 	sub	r8,pc,-13292
8000dd8c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000dd90:	fa ea 00 3c 	ld.d	r10,sp[60]
8000dd94:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000dd98:	e0 a0 0f ee 	rcall	8000fd74 <__avr32_f64_div>
8000dd9c:	30 35       	mov	r5,3
8000dd9e:	14 98       	mov	r8,r10
8000dda0:	16 99       	mov	r9,r11
8000dda2:	fa e9 00 08 	st.d	sp[8],r8
8000dda6:	fe cc cc 32 	sub	r12,pc,-13262
8000ddaa:	50 a3       	stdsp	sp[0x28],r3
8000ddac:	0c 93       	mov	r3,r6
8000ddae:	18 96       	mov	r6,r12
8000ddb0:	c0 f8       	rjmp	8000ddce <_dtoa_r+0x39e>
8000ddb2:	fa ea 00 18 	ld.d	r10,sp[24]
8000ddb6:	ed b4 00 00 	bld	r4,0x0
8000ddba:	c0 81       	brne	8000ddca <_dtoa_r+0x39a>
8000ddbc:	ec e8 00 00 	ld.d	r8,r6[0]
8000ddc0:	2f f5       	sub	r5,-1
8000ddc2:	e0 a0 0c 93 	rcall	8000f6e8 <__avr32_f64_mul>
8000ddc6:	fa eb 00 18 	st.d	sp[24],r10
8000ddca:	a1 54       	asr	r4,0x1
8000ddcc:	2f 86       	sub	r6,-8
8000ddce:	58 04       	cp.w	r4,0
8000ddd0:	cf 11       	brne	8000ddb2 <_dtoa_r+0x382>
8000ddd2:	fa e8 00 18 	ld.d	r8,sp[24]
8000ddd6:	fa ea 00 08 	ld.d	r10,sp[8]
8000ddda:	06 96       	mov	r6,r3
8000dddc:	e0 a0 0f cc 	rcall	8000fd74 <__avr32_f64_div>
8000dde0:	40 a3       	lddsp	r3,sp[0x28]
8000dde2:	14 98       	mov	r8,r10
8000dde4:	16 99       	mov	r9,r11
8000dde6:	fa e9 00 08 	st.d	sp[8],r8
8000ddea:	c2 f8       	rjmp	8000de48 <_dtoa_r+0x418>
8000ddec:	ec 08 11 00 	rsub	r8,r6,0
8000ddf0:	c0 31       	brne	8000ddf6 <_dtoa_r+0x3c6>
8000ddf2:	30 25       	mov	r5,2
8000ddf4:	c2 a8       	rjmp	8000de48 <_dtoa_r+0x418>
8000ddf6:	fe cc cc 82 	sub	r12,pc,-13182
8000ddfa:	f0 04 14 04 	asr	r4,r8,0x4
8000ddfe:	50 1c       	stdsp	sp[0x4],r12
8000de00:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000de04:	fe c9 cd 58 	sub	r9,pc,-12968
8000de08:	fa ea 00 3c 	ld.d	r10,sp[60]
8000de0c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000de10:	e0 a0 0c 6c 	rcall	8000f6e8 <__avr32_f64_mul>
8000de14:	40 1c       	lddsp	r12,sp[0x4]
8000de16:	50 63       	stdsp	sp[0x18],r3
8000de18:	30 25       	mov	r5,2
8000de1a:	0c 93       	mov	r3,r6
8000de1c:	fa eb 00 08 	st.d	sp[8],r10
8000de20:	18 96       	mov	r6,r12
8000de22:	c0 f8       	rjmp	8000de40 <_dtoa_r+0x410>
8000de24:	fa ea 00 08 	ld.d	r10,sp[8]
8000de28:	ed b4 00 00 	bld	r4,0x0
8000de2c:	c0 81       	brne	8000de3c <_dtoa_r+0x40c>
8000de2e:	ec e8 00 00 	ld.d	r8,r6[0]
8000de32:	2f f5       	sub	r5,-1
8000de34:	e0 a0 0c 5a 	rcall	8000f6e8 <__avr32_f64_mul>
8000de38:	fa eb 00 08 	st.d	sp[8],r10
8000de3c:	a1 54       	asr	r4,0x1
8000de3e:	2f 86       	sub	r6,-8
8000de40:	58 04       	cp.w	r4,0
8000de42:	cf 11       	brne	8000de24 <_dtoa_r+0x3f4>
8000de44:	06 96       	mov	r6,r3
8000de46:	40 63       	lddsp	r3,sp[0x18]
8000de48:	41 4a       	lddsp	r10,sp[0x50]
8000de4a:	58 0a       	cp.w	r10,0
8000de4c:	c2 a0       	breq	8000dea0 <_dtoa_r+0x470>
8000de4e:	fa e8 00 08 	ld.d	r8,sp[8]
8000de52:	58 01       	cp.w	r1,0
8000de54:	5f 94       	srgt	r4
8000de56:	fa e9 00 18 	st.d	sp[24],r8
8000de5a:	30 08       	mov	r8,0
8000de5c:	fc 19 3f f0 	movh	r9,0x3ff0
8000de60:	fa ea 00 18 	ld.d	r10,sp[24]
8000de64:	e0 a0 0f 54 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000de68:	f9 bc 00 00 	moveq	r12,0
8000de6c:	f9 bc 01 01 	movne	r12,1
8000de70:	e9 ec 00 0c 	and	r12,r4,r12
8000de74:	c1 60       	breq	8000dea0 <_dtoa_r+0x470>
8000de76:	40 98       	lddsp	r8,sp[0x24]
8000de78:	58 08       	cp.w	r8,0
8000de7a:	e0 8a 00 f1 	brle	8000e05c <_dtoa_r+0x62c>
8000de7e:	30 08       	mov	r8,0
8000de80:	fc 19 40 24 	movh	r9,0x4024
8000de84:	ec c4 00 01 	sub	r4,r6,1
8000de88:	fa ea 00 18 	ld.d	r10,sp[24]
8000de8c:	2f f5       	sub	r5,-1
8000de8e:	50 64       	stdsp	sp[0x18],r4
8000de90:	e0 a0 0c 2c 	rcall	8000f6e8 <__avr32_f64_mul>
8000de94:	40 94       	lddsp	r4,sp[0x24]
8000de96:	14 98       	mov	r8,r10
8000de98:	16 99       	mov	r9,r11
8000de9a:	fa e9 00 08 	st.d	sp[8],r8
8000de9e:	c0 38       	rjmp	8000dea4 <_dtoa_r+0x474>
8000dea0:	50 66       	stdsp	sp[0x18],r6
8000dea2:	02 94       	mov	r4,r1
8000dea4:	0a 9c       	mov	r12,r5
8000dea6:	e0 a0 0e 7c 	rcall	8000fb9e <__avr32_s32_to_f64>
8000deaa:	fa e8 00 08 	ld.d	r8,sp[8]
8000deae:	e0 a0 0c 1d 	rcall	8000f6e8 <__avr32_f64_mul>
8000deb2:	30 08       	mov	r8,0
8000deb4:	fc 19 40 1c 	movh	r9,0x401c
8000deb8:	e0 a0 0d d2 	rcall	8000fa5c <__avr32_f64_add>
8000debc:	14 98       	mov	r8,r10
8000debe:	16 99       	mov	r9,r11
8000dec0:	fa e9 00 28 	st.d	sp[40],r8
8000dec4:	fc 18 fc c0 	movh	r8,0xfcc0
8000dec8:	40 a5       	lddsp	r5,sp[0x28]
8000deca:	10 05       	add	r5,r8
8000decc:	50 a5       	stdsp	sp[0x28],r5
8000dece:	58 04       	cp.w	r4,0
8000ded0:	c2 11       	brne	8000df12 <_dtoa_r+0x4e2>
8000ded2:	fa ea 00 08 	ld.d	r10,sp[8]
8000ded6:	30 08       	mov	r8,0
8000ded8:	fc 19 40 14 	movh	r9,0x4014
8000dedc:	e0 a0 0c f2 	rcall	8000f8c0 <__avr32_f64_sub>
8000dee0:	40 bc       	lddsp	r12,sp[0x2c]
8000dee2:	fa eb 00 08 	st.d	sp[8],r10
8000dee6:	14 98       	mov	r8,r10
8000dee8:	16 99       	mov	r9,r11
8000deea:	18 9a       	mov	r10,r12
8000deec:	0a 9b       	mov	r11,r5
8000deee:	e0 a0 0f 0f 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000def2:	e0 81 02 54 	brne	8000e39a <_dtoa_r+0x96a>
8000def6:	0a 98       	mov	r8,r5
8000def8:	40 b9       	lddsp	r9,sp[0x2c]
8000defa:	ee 18 80 00 	eorh	r8,0x8000
8000defe:	fa ea 00 08 	ld.d	r10,sp[8]
8000df02:	10 95       	mov	r5,r8
8000df04:	12 98       	mov	r8,r9
8000df06:	0a 99       	mov	r9,r5
8000df08:	e0 a0 0f 02 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000df0c:	e0 81 02 3e 	brne	8000e388 <_dtoa_r+0x958>
8000df10:	ca 68       	rjmp	8000e05c <_dtoa_r+0x62c>
8000df12:	fe c9 ce 66 	sub	r9,pc,-12698
8000df16:	e8 c8 00 01 	sub	r8,r4,1
8000df1a:	40 d5       	lddsp	r5,sp[0x34]
8000df1c:	58 05       	cp.w	r5,0
8000df1e:	c4 f0       	breq	8000dfbc <_dtoa_r+0x58c>
8000df20:	30 0c       	mov	r12,0
8000df22:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000df26:	51 3c       	stdsp	sp[0x4c],r12
8000df28:	30 0a       	mov	r10,0
8000df2a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000df2e:	e0 a0 0f 23 	rcall	8000fd74 <__avr32_f64_div>
8000df32:	fa e8 00 28 	ld.d	r8,sp[40]
8000df36:	40 85       	lddsp	r5,sp[0x20]
8000df38:	e0 a0 0c c4 	rcall	8000f8c0 <__avr32_f64_sub>
8000df3c:	fa eb 00 28 	st.d	sp[40],r10
8000df40:	fa ea 00 08 	ld.d	r10,sp[8]
8000df44:	e0 a0 0e 16 	rcall	8000fb70 <__avr32_f64_to_s32>
8000df48:	51 6c       	stdsp	sp[0x58],r12
8000df4a:	e0 a0 0e 2a 	rcall	8000fb9e <__avr32_s32_to_f64>
8000df4e:	14 98       	mov	r8,r10
8000df50:	16 99       	mov	r9,r11
8000df52:	fa ea 00 08 	ld.d	r10,sp[8]
8000df56:	e0 a0 0c b5 	rcall	8000f8c0 <__avr32_f64_sub>
8000df5a:	fa eb 00 08 	st.d	sp[8],r10
8000df5e:	41 68       	lddsp	r8,sp[0x58]
8000df60:	2d 08       	sub	r8,-48
8000df62:	0a c8       	st.b	r5++,r8
8000df64:	41 39       	lddsp	r9,sp[0x4c]
8000df66:	2f f9       	sub	r9,-1
8000df68:	51 39       	stdsp	sp[0x4c],r9
8000df6a:	fa e8 00 28 	ld.d	r8,sp[40]
8000df6e:	e0 a0 0e cf 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000df72:	e0 81 03 39 	brne	8000e5e4 <_dtoa_r+0xbb4>
8000df76:	fa e8 00 08 	ld.d	r8,sp[8]
8000df7a:	30 0a       	mov	r10,0
8000df7c:	fc 1b 3f f0 	movh	r11,0x3ff0
8000df80:	e0 a0 0c a0 	rcall	8000f8c0 <__avr32_f64_sub>
8000df84:	fa e8 00 28 	ld.d	r8,sp[40]
8000df88:	e0 a0 0e c2 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000df8c:	fa ea 00 28 	ld.d	r10,sp[40]
8000df90:	30 08       	mov	r8,0
8000df92:	fc 19 40 24 	movh	r9,0x4024
8000df96:	e0 81 00 da 	brne	8000e14a <_dtoa_r+0x71a>
8000df9a:	41 3c       	lddsp	r12,sp[0x4c]
8000df9c:	08 3c       	cp.w	r12,r4
8000df9e:	c5 f4       	brge	8000e05c <_dtoa_r+0x62c>
8000dfa0:	e0 a0 0b a4 	rcall	8000f6e8 <__avr32_f64_mul>
8000dfa4:	30 08       	mov	r8,0
8000dfa6:	fa eb 00 28 	st.d	sp[40],r10
8000dfaa:	fc 19 40 24 	movh	r9,0x4024
8000dfae:	fa ea 00 08 	ld.d	r10,sp[8]
8000dfb2:	e0 a0 0b 9b 	rcall	8000f6e8 <__avr32_f64_mul>
8000dfb6:	fa eb 00 08 	st.d	sp[8],r10
8000dfba:	cc 3b       	rjmp	8000df40 <_dtoa_r+0x510>
8000dfbc:	40 85       	lddsp	r5,sp[0x20]
8000dfbe:	08 05       	add	r5,r4
8000dfc0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000dfc4:	51 35       	stdsp	sp[0x4c],r5
8000dfc6:	fa e8 00 28 	ld.d	r8,sp[40]
8000dfca:	40 85       	lddsp	r5,sp[0x20]
8000dfcc:	e0 a0 0b 8e 	rcall	8000f6e8 <__avr32_f64_mul>
8000dfd0:	fa eb 00 28 	st.d	sp[40],r10
8000dfd4:	fa ea 00 08 	ld.d	r10,sp[8]
8000dfd8:	e0 a0 0d cc 	rcall	8000fb70 <__avr32_f64_to_s32>
8000dfdc:	51 6c       	stdsp	sp[0x58],r12
8000dfde:	e0 a0 0d e0 	rcall	8000fb9e <__avr32_s32_to_f64>
8000dfe2:	14 98       	mov	r8,r10
8000dfe4:	16 99       	mov	r9,r11
8000dfe6:	fa ea 00 08 	ld.d	r10,sp[8]
8000dfea:	e0 a0 0c 6b 	rcall	8000f8c0 <__avr32_f64_sub>
8000dfee:	fa eb 00 08 	st.d	sp[8],r10
8000dff2:	41 68       	lddsp	r8,sp[0x58]
8000dff4:	2d 08       	sub	r8,-48
8000dff6:	0a c8       	st.b	r5++,r8
8000dff8:	41 3c       	lddsp	r12,sp[0x4c]
8000dffa:	18 35       	cp.w	r5,r12
8000dffc:	c2 81       	brne	8000e04c <_dtoa_r+0x61c>
8000dffe:	30 08       	mov	r8,0
8000e000:	fc 19 3f e0 	movh	r9,0x3fe0
8000e004:	fa ea 00 28 	ld.d	r10,sp[40]
8000e008:	e0 a0 0d 2a 	rcall	8000fa5c <__avr32_f64_add>
8000e00c:	40 85       	lddsp	r5,sp[0x20]
8000e00e:	fa e8 00 08 	ld.d	r8,sp[8]
8000e012:	08 05       	add	r5,r4
8000e014:	e0 a0 0e 7c 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000e018:	e0 81 00 99 	brne	8000e14a <_dtoa_r+0x71a>
8000e01c:	fa e8 00 28 	ld.d	r8,sp[40]
8000e020:	30 0a       	mov	r10,0
8000e022:	fc 1b 3f e0 	movh	r11,0x3fe0
8000e026:	e0 a0 0c 4d 	rcall	8000f8c0 <__avr32_f64_sub>
8000e02a:	14 98       	mov	r8,r10
8000e02c:	16 99       	mov	r9,r11
8000e02e:	fa ea 00 08 	ld.d	r10,sp[8]
8000e032:	e0 a0 0e 6d 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000e036:	c1 30       	breq	8000e05c <_dtoa_r+0x62c>
8000e038:	33 09       	mov	r9,48
8000e03a:	0a 98       	mov	r8,r5
8000e03c:	11 7a       	ld.ub	r10,--r8
8000e03e:	f2 0a 18 00 	cp.b	r10,r9
8000e042:	e0 81 02 d1 	brne	8000e5e4 <_dtoa_r+0xbb4>
8000e046:	10 95       	mov	r5,r8
8000e048:	cf 9b       	rjmp	8000e03a <_dtoa_r+0x60a>
8000e04a:	d7 03       	nop
8000e04c:	30 08       	mov	r8,0
8000e04e:	fc 19 40 24 	movh	r9,0x4024
8000e052:	e0 a0 0b 4b 	rcall	8000f6e8 <__avr32_f64_mul>
8000e056:	fa eb 00 08 	st.d	sp[8],r10
8000e05a:	cb db       	rjmp	8000dfd4 <_dtoa_r+0x5a4>
8000e05c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000e060:	fa eb 00 08 	st.d	sp[8],r10
8000e064:	58 e6       	cp.w	r6,14
8000e066:	5f ab       	srle	r11
8000e068:	41 8a       	lddsp	r10,sp[0x60]
8000e06a:	30 08       	mov	r8,0
8000e06c:	f4 09 11 ff 	rsub	r9,r10,-1
8000e070:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000e074:	f0 09 18 00 	cp.b	r9,r8
8000e078:	e0 80 00 82 	breq	8000e17c <_dtoa_r+0x74c>
8000e07c:	40 ea       	lddsp	r10,sp[0x38]
8000e07e:	58 01       	cp.w	r1,0
8000e080:	5f a9       	srle	r9
8000e082:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000e086:	fe ca cf da 	sub	r10,pc,-12326
8000e08a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000e08e:	fa e5 00 10 	st.d	sp[16],r4
8000e092:	f0 09 18 00 	cp.b	r9,r8
8000e096:	c1 40       	breq	8000e0be <_dtoa_r+0x68e>
8000e098:	58 01       	cp.w	r1,0
8000e09a:	e0 81 01 77 	brne	8000e388 <_dtoa_r+0x958>
8000e09e:	30 08       	mov	r8,0
8000e0a0:	fc 19 40 14 	movh	r9,0x4014
8000e0a4:	08 9a       	mov	r10,r4
8000e0a6:	0a 9b       	mov	r11,r5
8000e0a8:	e0 a0 0b 20 	rcall	8000f6e8 <__avr32_f64_mul>
8000e0ac:	fa e8 00 08 	ld.d	r8,sp[8]
8000e0b0:	e0 a0 0d fa 	rcall	8000fca4 <__avr32_f64_cmp_ge>
8000e0b4:	e0 81 01 6a 	brne	8000e388 <_dtoa_r+0x958>
8000e0b8:	02 92       	mov	r2,r1
8000e0ba:	e0 8f 01 72 	bral	8000e39e <_dtoa_r+0x96e>
8000e0be:	40 85       	lddsp	r5,sp[0x20]
8000e0c0:	30 14       	mov	r4,1
8000e0c2:	fa e8 00 10 	ld.d	r8,sp[16]
8000e0c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000e0ca:	e0 a0 0e 55 	rcall	8000fd74 <__avr32_f64_div>
8000e0ce:	e0 a0 0d 51 	rcall	8000fb70 <__avr32_f64_to_s32>
8000e0d2:	18 92       	mov	r2,r12
8000e0d4:	e0 a0 0d 65 	rcall	8000fb9e <__avr32_s32_to_f64>
8000e0d8:	fa e8 00 10 	ld.d	r8,sp[16]
8000e0dc:	e0 a0 0b 06 	rcall	8000f6e8 <__avr32_f64_mul>
8000e0e0:	14 98       	mov	r8,r10
8000e0e2:	16 99       	mov	r9,r11
8000e0e4:	fa ea 00 08 	ld.d	r10,sp[8]
8000e0e8:	e0 a0 0b ec 	rcall	8000f8c0 <__avr32_f64_sub>
8000e0ec:	fa eb 00 08 	st.d	sp[8],r10
8000e0f0:	e4 c8 ff d0 	sub	r8,r2,-48
8000e0f4:	0a c8       	st.b	r5++,r8
8000e0f6:	fc 19 40 24 	movh	r9,0x4024
8000e0fa:	30 08       	mov	r8,0
8000e0fc:	02 34       	cp.w	r4,r1
8000e0fe:	c3 31       	brne	8000e164 <_dtoa_r+0x734>
8000e100:	fa e8 00 08 	ld.d	r8,sp[8]
8000e104:	e0 a0 0c ac 	rcall	8000fa5c <__avr32_f64_add>
8000e108:	16 91       	mov	r1,r11
8000e10a:	14 90       	mov	r0,r10
8000e10c:	14 98       	mov	r8,r10
8000e10e:	02 99       	mov	r9,r1
8000e110:	fa ea 00 10 	ld.d	r10,sp[16]
8000e114:	e0 a0 0d fc 	rcall	8000fd0c <__avr32_f64_cmp_lt>
8000e118:	c1 a1       	brne	8000e14c <_dtoa_r+0x71c>
8000e11a:	fa e8 00 10 	ld.d	r8,sp[16]
8000e11e:	00 9a       	mov	r10,r0
8000e120:	02 9b       	mov	r11,r1
8000e122:	e0 a0 0d ae 	rcall	8000fc7e <__avr32_f64_cmp_eq>
8000e126:	e0 80 02 5e 	breq	8000e5e2 <_dtoa_r+0xbb2>
8000e12a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000e12e:	c0 f1       	brne	8000e14c <_dtoa_r+0x71c>
8000e130:	e0 8f 02 59 	bral	8000e5e2 <_dtoa_r+0xbb2>
8000e134:	40 8a       	lddsp	r10,sp[0x20]
8000e136:	14 38       	cp.w	r8,r10
8000e138:	c0 30       	breq	8000e13e <_dtoa_r+0x70e>
8000e13a:	10 95       	mov	r5,r8
8000e13c:	c0 98       	rjmp	8000e14e <_dtoa_r+0x71e>
8000e13e:	33 08       	mov	r8,48
8000e140:	40 89       	lddsp	r9,sp[0x20]
8000e142:	2f f6       	sub	r6,-1
8000e144:	b2 88       	st.b	r9[0x0],r8
8000e146:	40 88       	lddsp	r8,sp[0x20]
8000e148:	c0 88       	rjmp	8000e158 <_dtoa_r+0x728>
8000e14a:	40 66       	lddsp	r6,sp[0x18]
8000e14c:	33 99       	mov	r9,57
8000e14e:	0a 98       	mov	r8,r5
8000e150:	11 7a       	ld.ub	r10,--r8
8000e152:	f2 0a 18 00 	cp.b	r10,r9
8000e156:	ce f0       	breq	8000e134 <_dtoa_r+0x704>
8000e158:	50 66       	stdsp	sp[0x18],r6
8000e15a:	11 89       	ld.ub	r9,r8[0x0]
8000e15c:	2f f9       	sub	r9,-1
8000e15e:	b0 89       	st.b	r8[0x0],r9
8000e160:	e0 8f 02 42 	bral	8000e5e4 <_dtoa_r+0xbb4>
8000e164:	e0 a0 0a c2 	rcall	8000f6e8 <__avr32_f64_mul>
8000e168:	2f f4       	sub	r4,-1
8000e16a:	fa eb 00 08 	st.d	sp[8],r10
8000e16e:	30 08       	mov	r8,0
8000e170:	30 09       	mov	r9,0
8000e172:	e0 a0 0d 86 	rcall	8000fc7e <__avr32_f64_cmp_eq>
8000e176:	ca 60       	breq	8000e0c2 <_dtoa_r+0x692>
8000e178:	e0 8f 02 35 	bral	8000e5e2 <_dtoa_r+0xbb2>
8000e17c:	40 d8       	lddsp	r8,sp[0x34]
8000e17e:	58 08       	cp.w	r8,0
8000e180:	c0 51       	brne	8000e18a <_dtoa_r+0x75a>
8000e182:	04 98       	mov	r8,r2
8000e184:	00 95       	mov	r5,r0
8000e186:	40 d4       	lddsp	r4,sp[0x34]
8000e188:	c3 78       	rjmp	8000e1f6 <_dtoa_r+0x7c6>
8000e18a:	40 c5       	lddsp	r5,sp[0x30]
8000e18c:	58 15       	cp.w	r5,1
8000e18e:	e0 89 00 0f 	brgt	8000e1ac <_dtoa_r+0x77c>
8000e192:	41 74       	lddsp	r4,sp[0x5c]
8000e194:	58 04       	cp.w	r4,0
8000e196:	c0 40       	breq	8000e19e <_dtoa_r+0x76e>
8000e198:	f4 c9 fb cd 	sub	r9,r10,-1075
8000e19c:	c0 48       	rjmp	8000e1a4 <_dtoa_r+0x774>
8000e19e:	41 99       	lddsp	r9,sp[0x64]
8000e1a0:	f2 09 11 36 	rsub	r9,r9,54
8000e1a4:	04 98       	mov	r8,r2
8000e1a6:	00 95       	mov	r5,r0
8000e1a8:	c1 c8       	rjmp	8000e1e0 <_dtoa_r+0x7b0>
8000e1aa:	d7 03       	nop
8000e1ac:	e2 c8 00 01 	sub	r8,r1,1
8000e1b0:	58 01       	cp.w	r1,0
8000e1b2:	e0 05 17 40 	movge	r5,r0
8000e1b6:	e2 09 17 40 	movge	r9,r1
8000e1ba:	e1 d1 e5 15 	sublt	r5,r0,r1
8000e1be:	f9 b9 05 00 	movlt	r9,0
8000e1c2:	10 32       	cp.w	r2,r8
8000e1c4:	e5 d8 e4 18 	subge	r8,r2,r8
8000e1c8:	f1 d2 e5 18 	sublt	r8,r8,r2
8000e1cc:	e5 d8 e5 02 	addlt	r2,r2,r8
8000e1d0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000e1d4:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000e1d8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000e1dc:	f9 b8 05 00 	movlt	r8,0
8000e1e0:	40 4b       	lddsp	r11,sp[0x10]
8000e1e2:	12 0b       	add	r11,r9
8000e1e4:	50 08       	stdsp	sp[0x0],r8
8000e1e6:	50 4b       	stdsp	sp[0x10],r11
8000e1e8:	12 00       	add	r0,r9
8000e1ea:	30 1b       	mov	r11,1
8000e1ec:	0e 9c       	mov	r12,r7
8000e1ee:	e0 a0 08 a7 	rcall	8000f33c <__i2b>
8000e1f2:	40 08       	lddsp	r8,sp[0x0]
8000e1f4:	18 94       	mov	r4,r12
8000e1f6:	40 4a       	lddsp	r10,sp[0x10]
8000e1f8:	58 05       	cp.w	r5,0
8000e1fa:	5f 99       	srgt	r9
8000e1fc:	58 0a       	cp.w	r10,0
8000e1fe:	5f 9a       	srgt	r10
8000e200:	f5 e9 00 09 	and	r9,r10,r9
8000e204:	c0 80       	breq	8000e214 <_dtoa_r+0x7e4>
8000e206:	40 4c       	lddsp	r12,sp[0x10]
8000e208:	f8 05 0d 49 	min	r9,r12,r5
8000e20c:	12 1c       	sub	r12,r9
8000e20e:	12 10       	sub	r0,r9
8000e210:	50 4c       	stdsp	sp[0x10],r12
8000e212:	12 15       	sub	r5,r9
8000e214:	58 02       	cp.w	r2,0
8000e216:	e0 8a 00 27 	brle	8000e264 <_dtoa_r+0x834>
8000e21a:	40 db       	lddsp	r11,sp[0x34]
8000e21c:	58 0b       	cp.w	r11,0
8000e21e:	c1 d0       	breq	8000e258 <_dtoa_r+0x828>
8000e220:	58 08       	cp.w	r8,0
8000e222:	e0 8a 00 17 	brle	8000e250 <_dtoa_r+0x820>
8000e226:	10 9a       	mov	r10,r8
8000e228:	50 08       	stdsp	sp[0x0],r8
8000e22a:	08 9b       	mov	r11,r4
8000e22c:	0e 9c       	mov	r12,r7
8000e22e:	e0 a0 08 cd 	rcall	8000f3c8 <__pow5mult>
8000e232:	06 9a       	mov	r10,r3
8000e234:	18 9b       	mov	r11,r12
8000e236:	18 94       	mov	r4,r12
8000e238:	0e 9c       	mov	r12,r7
8000e23a:	e0 a0 08 01 	rcall	8000f23c <__multiply>
8000e23e:	18 99       	mov	r9,r12
8000e240:	06 9b       	mov	r11,r3
8000e242:	50 19       	stdsp	sp[0x4],r9
8000e244:	0e 9c       	mov	r12,r7
8000e246:	e0 a0 06 ad 	rcall	8000efa0 <_Bfree>
8000e24a:	40 19       	lddsp	r9,sp[0x4]
8000e24c:	40 08       	lddsp	r8,sp[0x0]
8000e24e:	12 93       	mov	r3,r9
8000e250:	e4 08 01 0a 	sub	r10,r2,r8
8000e254:	c0 80       	breq	8000e264 <_dtoa_r+0x834>
8000e256:	c0 28       	rjmp	8000e25a <_dtoa_r+0x82a>
8000e258:	04 9a       	mov	r10,r2
8000e25a:	06 9b       	mov	r11,r3
8000e25c:	0e 9c       	mov	r12,r7
8000e25e:	e0 a0 08 b5 	rcall	8000f3c8 <__pow5mult>
8000e262:	18 93       	mov	r3,r12
8000e264:	30 1b       	mov	r11,1
8000e266:	0e 9c       	mov	r12,r7
8000e268:	e0 a0 08 6a 	rcall	8000f33c <__i2b>
8000e26c:	41 1a       	lddsp	r10,sp[0x44]
8000e26e:	18 92       	mov	r2,r12
8000e270:	58 0a       	cp.w	r10,0
8000e272:	e0 8a 00 07 	brle	8000e280 <_dtoa_r+0x850>
8000e276:	18 9b       	mov	r11,r12
8000e278:	0e 9c       	mov	r12,r7
8000e27a:	e0 a0 08 a7 	rcall	8000f3c8 <__pow5mult>
8000e27e:	18 92       	mov	r2,r12
8000e280:	40 c9       	lddsp	r9,sp[0x30]
8000e282:	58 19       	cp.w	r9,1
8000e284:	e0 89 00 14 	brgt	8000e2ac <_dtoa_r+0x87c>
8000e288:	40 38       	lddsp	r8,sp[0xc]
8000e28a:	58 08       	cp.w	r8,0
8000e28c:	c1 01       	brne	8000e2ac <_dtoa_r+0x87c>
8000e28e:	40 29       	lddsp	r9,sp[0x8]
8000e290:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000e294:	c0 c1       	brne	8000e2ac <_dtoa_r+0x87c>
8000e296:	12 98       	mov	r8,r9
8000e298:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000e29c:	c0 80       	breq	8000e2ac <_dtoa_r+0x87c>
8000e29e:	40 4c       	lddsp	r12,sp[0x10]
8000e2a0:	30 1b       	mov	r11,1
8000e2a2:	2f fc       	sub	r12,-1
8000e2a4:	2f f0       	sub	r0,-1
8000e2a6:	50 4c       	stdsp	sp[0x10],r12
8000e2a8:	50 6b       	stdsp	sp[0x18],r11
8000e2aa:	c0 38       	rjmp	8000e2b0 <_dtoa_r+0x880>
8000e2ac:	30 0a       	mov	r10,0
8000e2ae:	50 6a       	stdsp	sp[0x18],r10
8000e2b0:	41 19       	lddsp	r9,sp[0x44]
8000e2b2:	58 09       	cp.w	r9,0
8000e2b4:	c0 31       	brne	8000e2ba <_dtoa_r+0x88a>
8000e2b6:	30 1c       	mov	r12,1
8000e2b8:	c0 98       	rjmp	8000e2ca <_dtoa_r+0x89a>
8000e2ba:	64 48       	ld.w	r8,r2[0x10]
8000e2bc:	2f c8       	sub	r8,-4
8000e2be:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000e2c2:	e0 a0 05 df 	rcall	8000ee80 <__hi0bits>
8000e2c6:	f8 0c 11 20 	rsub	r12,r12,32
8000e2ca:	40 4b       	lddsp	r11,sp[0x10]
8000e2cc:	f8 0b 00 08 	add	r8,r12,r11
8000e2d0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000e2d4:	c0 c0       	breq	8000e2ec <_dtoa_r+0x8bc>
8000e2d6:	f0 08 11 20 	rsub	r8,r8,32
8000e2da:	58 48       	cp.w	r8,4
8000e2dc:	e0 8a 00 06 	brle	8000e2e8 <_dtoa_r+0x8b8>
8000e2e0:	20 48       	sub	r8,4
8000e2e2:	10 0b       	add	r11,r8
8000e2e4:	50 4b       	stdsp	sp[0x10],r11
8000e2e6:	c0 78       	rjmp	8000e2f4 <_dtoa_r+0x8c4>
8000e2e8:	58 48       	cp.w	r8,4
8000e2ea:	c0 70       	breq	8000e2f8 <_dtoa_r+0x8c8>
8000e2ec:	40 4a       	lddsp	r10,sp[0x10]
8000e2ee:	2e 48       	sub	r8,-28
8000e2f0:	10 0a       	add	r10,r8
8000e2f2:	50 4a       	stdsp	sp[0x10],r10
8000e2f4:	10 00       	add	r0,r8
8000e2f6:	10 05       	add	r5,r8
8000e2f8:	58 00       	cp.w	r0,0
8000e2fa:	e0 8a 00 08 	brle	8000e30a <_dtoa_r+0x8da>
8000e2fe:	06 9b       	mov	r11,r3
8000e300:	00 9a       	mov	r10,r0
8000e302:	0e 9c       	mov	r12,r7
8000e304:	e0 a0 07 58 	rcall	8000f1b4 <__lshift>
8000e308:	18 93       	mov	r3,r12
8000e30a:	40 49       	lddsp	r9,sp[0x10]
8000e30c:	58 09       	cp.w	r9,0
8000e30e:	e0 8a 00 08 	brle	8000e31e <_dtoa_r+0x8ee>
8000e312:	04 9b       	mov	r11,r2
8000e314:	12 9a       	mov	r10,r9
8000e316:	0e 9c       	mov	r12,r7
8000e318:	e0 a0 07 4e 	rcall	8000f1b4 <__lshift>
8000e31c:	18 92       	mov	r2,r12
8000e31e:	41 48       	lddsp	r8,sp[0x50]
8000e320:	58 08       	cp.w	r8,0
8000e322:	c1 b0       	breq	8000e358 <_dtoa_r+0x928>
8000e324:	04 9b       	mov	r11,r2
8000e326:	06 9c       	mov	r12,r3
8000e328:	e0 a0 06 23 	rcall	8000ef6e <__mcmp>
8000e32c:	c1 64       	brge	8000e358 <_dtoa_r+0x928>
8000e32e:	06 9b       	mov	r11,r3
8000e330:	30 09       	mov	r9,0
8000e332:	30 aa       	mov	r10,10
8000e334:	0e 9c       	mov	r12,r7
8000e336:	e0 a0 08 0b 	rcall	8000f34c <__multadd>
8000e33a:	20 16       	sub	r6,1
8000e33c:	18 93       	mov	r3,r12
8000e33e:	40 dc       	lddsp	r12,sp[0x34]
8000e340:	58 0c       	cp.w	r12,0
8000e342:	c0 31       	brne	8000e348 <_dtoa_r+0x918>
8000e344:	40 91       	lddsp	r1,sp[0x24]
8000e346:	c0 98       	rjmp	8000e358 <_dtoa_r+0x928>
8000e348:	08 9b       	mov	r11,r4
8000e34a:	40 91       	lddsp	r1,sp[0x24]
8000e34c:	30 09       	mov	r9,0
8000e34e:	30 aa       	mov	r10,10
8000e350:	0e 9c       	mov	r12,r7
8000e352:	e0 a0 07 fd 	rcall	8000f34c <__multadd>
8000e356:	18 94       	mov	r4,r12
8000e358:	58 01       	cp.w	r1,0
8000e35a:	5f a9       	srle	r9
8000e35c:	40 cb       	lddsp	r11,sp[0x30]
8000e35e:	58 2b       	cp.w	r11,2
8000e360:	5f 98       	srgt	r8
8000e362:	f3 e8 00 08 	and	r8,r9,r8
8000e366:	c2 50       	breq	8000e3b0 <_dtoa_r+0x980>
8000e368:	58 01       	cp.w	r1,0
8000e36a:	c1 11       	brne	8000e38c <_dtoa_r+0x95c>
8000e36c:	04 9b       	mov	r11,r2
8000e36e:	02 99       	mov	r9,r1
8000e370:	30 5a       	mov	r10,5
8000e372:	0e 9c       	mov	r12,r7
8000e374:	e0 a0 07 ec 	rcall	8000f34c <__multadd>
8000e378:	18 92       	mov	r2,r12
8000e37a:	18 9b       	mov	r11,r12
8000e37c:	06 9c       	mov	r12,r3
8000e37e:	e0 a0 05 f8 	rcall	8000ef6e <__mcmp>
8000e382:	e0 89 00 0f 	brgt	8000e3a0 <_dtoa_r+0x970>
8000e386:	c0 38       	rjmp	8000e38c <_dtoa_r+0x95c>
8000e388:	30 02       	mov	r2,0
8000e38a:	04 94       	mov	r4,r2
8000e38c:	40 ea       	lddsp	r10,sp[0x38]
8000e38e:	30 09       	mov	r9,0
8000e390:	5c da       	com	r10
8000e392:	40 85       	lddsp	r5,sp[0x20]
8000e394:	50 6a       	stdsp	sp[0x18],r10
8000e396:	50 49       	stdsp	sp[0x10],r9
8000e398:	c0 f9       	rjmp	8000e5b6 <_dtoa_r+0xb86>
8000e39a:	08 92       	mov	r2,r4
8000e39c:	40 66       	lddsp	r6,sp[0x18]
8000e39e:	04 94       	mov	r4,r2
8000e3a0:	2f f6       	sub	r6,-1
8000e3a2:	50 66       	stdsp	sp[0x18],r6
8000e3a4:	33 18       	mov	r8,49
8000e3a6:	40 85       	lddsp	r5,sp[0x20]
8000e3a8:	0a c8       	st.b	r5++,r8
8000e3aa:	30 08       	mov	r8,0
8000e3ac:	50 48       	stdsp	sp[0x10],r8
8000e3ae:	c0 49       	rjmp	8000e5b6 <_dtoa_r+0xb86>
8000e3b0:	40 dc       	lddsp	r12,sp[0x34]
8000e3b2:	58 0c       	cp.w	r12,0
8000e3b4:	e0 80 00 b5 	breq	8000e51e <_dtoa_r+0xaee>
8000e3b8:	58 05       	cp.w	r5,0
8000e3ba:	e0 8a 00 08 	brle	8000e3ca <_dtoa_r+0x99a>
8000e3be:	08 9b       	mov	r11,r4
8000e3c0:	0a 9a       	mov	r10,r5
8000e3c2:	0e 9c       	mov	r12,r7
8000e3c4:	e0 a0 06 f8 	rcall	8000f1b4 <__lshift>
8000e3c8:	18 94       	mov	r4,r12
8000e3ca:	40 6b       	lddsp	r11,sp[0x18]
8000e3cc:	58 0b       	cp.w	r11,0
8000e3ce:	c0 31       	brne	8000e3d4 <_dtoa_r+0x9a4>
8000e3d0:	08 9c       	mov	r12,r4
8000e3d2:	c1 38       	rjmp	8000e3f8 <_dtoa_r+0x9c8>
8000e3d4:	68 1b       	ld.w	r11,r4[0x4]
8000e3d6:	0e 9c       	mov	r12,r7
8000e3d8:	e0 a0 05 fe 	rcall	8000efd4 <_Balloc>
8000e3dc:	68 4a       	ld.w	r10,r4[0x10]
8000e3de:	18 95       	mov	r5,r12
8000e3e0:	e8 cb ff f4 	sub	r11,r4,-12
8000e3e4:	2f ea       	sub	r10,-2
8000e3e6:	2f 4c       	sub	r12,-12
8000e3e8:	a3 6a       	lsl	r10,0x2
8000e3ea:	fe b0 e6 44 	rcall	8000b072 <memcpy>
8000e3ee:	0a 9b       	mov	r11,r5
8000e3f0:	30 1a       	mov	r10,1
8000e3f2:	0e 9c       	mov	r12,r7
8000e3f4:	e0 a0 06 e0 	rcall	8000f1b4 <__lshift>
8000e3f8:	50 44       	stdsp	sp[0x10],r4
8000e3fa:	40 3a       	lddsp	r10,sp[0xc]
8000e3fc:	30 19       	mov	r9,1
8000e3fe:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000e402:	18 94       	mov	r4,r12
8000e404:	50 da       	stdsp	sp[0x34],r10
8000e406:	40 85       	lddsp	r5,sp[0x20]
8000e408:	50 99       	stdsp	sp[0x24],r9
8000e40a:	50 26       	stdsp	sp[0x8],r6
8000e40c:	50 e1       	stdsp	sp[0x38],r1
8000e40e:	04 9b       	mov	r11,r2
8000e410:	06 9c       	mov	r12,r3
8000e412:	fe b0 fa 7f 	rcall	8000d910 <quorem>
8000e416:	40 4b       	lddsp	r11,sp[0x10]
8000e418:	f8 c0 ff d0 	sub	r0,r12,-48
8000e41c:	06 9c       	mov	r12,r3
8000e41e:	e0 a0 05 a8 	rcall	8000ef6e <__mcmp>
8000e422:	08 9a       	mov	r10,r4
8000e424:	50 6c       	stdsp	sp[0x18],r12
8000e426:	04 9b       	mov	r11,r2
8000e428:	0e 9c       	mov	r12,r7
8000e42a:	e0 a0 06 5d 	rcall	8000f0e4 <__mdiff>
8000e42e:	18 91       	mov	r1,r12
8000e430:	78 38       	ld.w	r8,r12[0xc]
8000e432:	58 08       	cp.w	r8,0
8000e434:	c0 30       	breq	8000e43a <_dtoa_r+0xa0a>
8000e436:	30 16       	mov	r6,1
8000e438:	c0 68       	rjmp	8000e444 <_dtoa_r+0xa14>
8000e43a:	18 9b       	mov	r11,r12
8000e43c:	06 9c       	mov	r12,r3
8000e43e:	e0 a0 05 98 	rcall	8000ef6e <__mcmp>
8000e442:	18 96       	mov	r6,r12
8000e444:	0e 9c       	mov	r12,r7
8000e446:	02 9b       	mov	r11,r1
8000e448:	e0 a0 05 ac 	rcall	8000efa0 <_Bfree>
8000e44c:	40 cc       	lddsp	r12,sp[0x30]
8000e44e:	ed ec 10 08 	or	r8,r6,r12
8000e452:	c0 d1       	brne	8000e46c <_dtoa_r+0xa3c>
8000e454:	40 db       	lddsp	r11,sp[0x34]
8000e456:	58 0b       	cp.w	r11,0
8000e458:	c0 a1       	brne	8000e46c <_dtoa_r+0xa3c>
8000e45a:	40 26       	lddsp	r6,sp[0x8]
8000e45c:	e0 40 00 39 	cp.w	r0,57
8000e460:	c3 00       	breq	8000e4c0 <_dtoa_r+0xa90>
8000e462:	40 6a       	lddsp	r10,sp[0x18]
8000e464:	58 0a       	cp.w	r10,0
8000e466:	e0 89 00 24 	brgt	8000e4ae <_dtoa_r+0xa7e>
8000e46a:	c2 f8       	rjmp	8000e4c8 <_dtoa_r+0xa98>
8000e46c:	40 69       	lddsp	r9,sp[0x18]
8000e46e:	58 09       	cp.w	r9,0
8000e470:	c0 85       	brlt	8000e480 <_dtoa_r+0xa50>
8000e472:	12 98       	mov	r8,r9
8000e474:	40 cc       	lddsp	r12,sp[0x30]
8000e476:	18 48       	or	r8,r12
8000e478:	c1 d1       	brne	8000e4b2 <_dtoa_r+0xa82>
8000e47a:	40 db       	lddsp	r11,sp[0x34]
8000e47c:	58 0b       	cp.w	r11,0
8000e47e:	c1 a1       	brne	8000e4b2 <_dtoa_r+0xa82>
8000e480:	0c 99       	mov	r9,r6
8000e482:	40 26       	lddsp	r6,sp[0x8]
8000e484:	58 09       	cp.w	r9,0
8000e486:	e0 8a 00 21 	brle	8000e4c8 <_dtoa_r+0xa98>
8000e48a:	06 9b       	mov	r11,r3
8000e48c:	30 1a       	mov	r10,1
8000e48e:	0e 9c       	mov	r12,r7
8000e490:	e0 a0 06 92 	rcall	8000f1b4 <__lshift>
8000e494:	04 9b       	mov	r11,r2
8000e496:	18 93       	mov	r3,r12
8000e498:	e0 a0 05 6b 	rcall	8000ef6e <__mcmp>
8000e49c:	e0 89 00 06 	brgt	8000e4a8 <_dtoa_r+0xa78>
8000e4a0:	c1 41       	brne	8000e4c8 <_dtoa_r+0xa98>
8000e4a2:	ed b0 00 00 	bld	r0,0x0
8000e4a6:	c1 11       	brne	8000e4c8 <_dtoa_r+0xa98>
8000e4a8:	e0 40 00 39 	cp.w	r0,57
8000e4ac:	c0 a0       	breq	8000e4c0 <_dtoa_r+0xa90>
8000e4ae:	2f f0       	sub	r0,-1
8000e4b0:	c0 c8       	rjmp	8000e4c8 <_dtoa_r+0xa98>
8000e4b2:	58 06       	cp.w	r6,0
8000e4b4:	e0 8a 00 0c 	brle	8000e4cc <_dtoa_r+0xa9c>
8000e4b8:	40 26       	lddsp	r6,sp[0x8]
8000e4ba:	e0 40 00 39 	cp.w	r0,57
8000e4be:	c0 41       	brne	8000e4c6 <_dtoa_r+0xa96>
8000e4c0:	33 98       	mov	r8,57
8000e4c2:	0a c8       	st.b	r5++,r8
8000e4c4:	c6 78       	rjmp	8000e592 <_dtoa_r+0xb62>
8000e4c6:	2f f0       	sub	r0,-1
8000e4c8:	0a c0       	st.b	r5++,r0
8000e4ca:	c7 58       	rjmp	8000e5b4 <_dtoa_r+0xb84>
8000e4cc:	0a c0       	st.b	r5++,r0
8000e4ce:	40 9a       	lddsp	r10,sp[0x24]
8000e4d0:	40 e9       	lddsp	r9,sp[0x38]
8000e4d2:	12 3a       	cp.w	r10,r9
8000e4d4:	c4 30       	breq	8000e55a <_dtoa_r+0xb2a>
8000e4d6:	06 9b       	mov	r11,r3
8000e4d8:	30 09       	mov	r9,0
8000e4da:	30 aa       	mov	r10,10
8000e4dc:	0e 9c       	mov	r12,r7
8000e4de:	e0 a0 07 37 	rcall	8000f34c <__multadd>
8000e4e2:	40 48       	lddsp	r8,sp[0x10]
8000e4e4:	18 93       	mov	r3,r12
8000e4e6:	08 38       	cp.w	r8,r4
8000e4e8:	c0 91       	brne	8000e4fa <_dtoa_r+0xaca>
8000e4ea:	10 9b       	mov	r11,r8
8000e4ec:	30 09       	mov	r9,0
8000e4ee:	30 aa       	mov	r10,10
8000e4f0:	0e 9c       	mov	r12,r7
8000e4f2:	e0 a0 07 2d 	rcall	8000f34c <__multadd>
8000e4f6:	50 4c       	stdsp	sp[0x10],r12
8000e4f8:	c0 e8       	rjmp	8000e514 <_dtoa_r+0xae4>
8000e4fa:	40 4b       	lddsp	r11,sp[0x10]
8000e4fc:	30 09       	mov	r9,0
8000e4fe:	30 aa       	mov	r10,10
8000e500:	0e 9c       	mov	r12,r7
8000e502:	e0 a0 07 25 	rcall	8000f34c <__multadd>
8000e506:	08 9b       	mov	r11,r4
8000e508:	50 4c       	stdsp	sp[0x10],r12
8000e50a:	30 09       	mov	r9,0
8000e50c:	30 aa       	mov	r10,10
8000e50e:	0e 9c       	mov	r12,r7
8000e510:	e0 a0 07 1e 	rcall	8000f34c <__multadd>
8000e514:	18 94       	mov	r4,r12
8000e516:	40 9c       	lddsp	r12,sp[0x24]
8000e518:	2f fc       	sub	r12,-1
8000e51a:	50 9c       	stdsp	sp[0x24],r12
8000e51c:	c7 9b       	rjmp	8000e40e <_dtoa_r+0x9de>
8000e51e:	30 18       	mov	r8,1
8000e520:	06 90       	mov	r0,r3
8000e522:	40 85       	lddsp	r5,sp[0x20]
8000e524:	08 93       	mov	r3,r4
8000e526:	0c 94       	mov	r4,r6
8000e528:	10 96       	mov	r6,r8
8000e52a:	04 9b       	mov	r11,r2
8000e52c:	00 9c       	mov	r12,r0
8000e52e:	fe b0 f9 f1 	rcall	8000d910 <quorem>
8000e532:	2d 0c       	sub	r12,-48
8000e534:	0a cc       	st.b	r5++,r12
8000e536:	02 36       	cp.w	r6,r1
8000e538:	c0 a4       	brge	8000e54c <_dtoa_r+0xb1c>
8000e53a:	00 9b       	mov	r11,r0
8000e53c:	30 09       	mov	r9,0
8000e53e:	30 aa       	mov	r10,10
8000e540:	0e 9c       	mov	r12,r7
8000e542:	2f f6       	sub	r6,-1
8000e544:	e0 a0 07 04 	rcall	8000f34c <__multadd>
8000e548:	18 90       	mov	r0,r12
8000e54a:	cf 0b       	rjmp	8000e52a <_dtoa_r+0xafa>
8000e54c:	08 96       	mov	r6,r4
8000e54e:	30 0b       	mov	r11,0
8000e550:	06 94       	mov	r4,r3
8000e552:	50 4b       	stdsp	sp[0x10],r11
8000e554:	00 93       	mov	r3,r0
8000e556:	18 90       	mov	r0,r12
8000e558:	c0 28       	rjmp	8000e55c <_dtoa_r+0xb2c>
8000e55a:	40 26       	lddsp	r6,sp[0x8]
8000e55c:	06 9b       	mov	r11,r3
8000e55e:	30 1a       	mov	r10,1
8000e560:	0e 9c       	mov	r12,r7
8000e562:	e0 a0 06 29 	rcall	8000f1b4 <__lshift>
8000e566:	04 9b       	mov	r11,r2
8000e568:	18 93       	mov	r3,r12
8000e56a:	e0 a0 05 02 	rcall	8000ef6e <__mcmp>
8000e56e:	e0 89 00 12 	brgt	8000e592 <_dtoa_r+0xb62>
8000e572:	c1 b1       	brne	8000e5a8 <_dtoa_r+0xb78>
8000e574:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000e578:	c0 d1       	brne	8000e592 <_dtoa_r+0xb62>
8000e57a:	c1 78       	rjmp	8000e5a8 <_dtoa_r+0xb78>
8000e57c:	40 89       	lddsp	r9,sp[0x20]
8000e57e:	12 38       	cp.w	r8,r9
8000e580:	c0 30       	breq	8000e586 <_dtoa_r+0xb56>
8000e582:	10 95       	mov	r5,r8
8000e584:	c0 88       	rjmp	8000e594 <_dtoa_r+0xb64>
8000e586:	2f f6       	sub	r6,-1
8000e588:	50 66       	stdsp	sp[0x18],r6
8000e58a:	33 18       	mov	r8,49
8000e58c:	40 8c       	lddsp	r12,sp[0x20]
8000e58e:	b8 88       	st.b	r12[0x0],r8
8000e590:	c1 38       	rjmp	8000e5b6 <_dtoa_r+0xb86>
8000e592:	33 9a       	mov	r10,57
8000e594:	0a 98       	mov	r8,r5
8000e596:	11 79       	ld.ub	r9,--r8
8000e598:	f4 09 18 00 	cp.b	r9,r10
8000e59c:	cf 00       	breq	8000e57c <_dtoa_r+0xb4c>
8000e59e:	2f f9       	sub	r9,-1
8000e5a0:	b0 89       	st.b	r8[0x0],r9
8000e5a2:	c0 98       	rjmp	8000e5b4 <_dtoa_r+0xb84>
8000e5a4:	10 95       	mov	r5,r8
8000e5a6:	c0 28       	rjmp	8000e5aa <_dtoa_r+0xb7a>
8000e5a8:	33 09       	mov	r9,48
8000e5aa:	0a 98       	mov	r8,r5
8000e5ac:	11 7a       	ld.ub	r10,--r8
8000e5ae:	f2 0a 18 00 	cp.b	r10,r9
8000e5b2:	cf 90       	breq	8000e5a4 <_dtoa_r+0xb74>
8000e5b4:	50 66       	stdsp	sp[0x18],r6
8000e5b6:	04 9b       	mov	r11,r2
8000e5b8:	0e 9c       	mov	r12,r7
8000e5ba:	e0 a0 04 f3 	rcall	8000efa0 <_Bfree>
8000e5be:	58 04       	cp.w	r4,0
8000e5c0:	c1 20       	breq	8000e5e4 <_dtoa_r+0xbb4>
8000e5c2:	40 4b       	lddsp	r11,sp[0x10]
8000e5c4:	08 3b       	cp.w	r11,r4
8000e5c6:	5f 19       	srne	r9
8000e5c8:	58 0b       	cp.w	r11,0
8000e5ca:	5f 18       	srne	r8
8000e5cc:	f3 e8 00 08 	and	r8,r9,r8
8000e5d0:	c0 40       	breq	8000e5d8 <_dtoa_r+0xba8>
8000e5d2:	0e 9c       	mov	r12,r7
8000e5d4:	e0 a0 04 e6 	rcall	8000efa0 <_Bfree>
8000e5d8:	08 9b       	mov	r11,r4
8000e5da:	0e 9c       	mov	r12,r7
8000e5dc:	e0 a0 04 e2 	rcall	8000efa0 <_Bfree>
8000e5e0:	c0 28       	rjmp	8000e5e4 <_dtoa_r+0xbb4>
8000e5e2:	50 66       	stdsp	sp[0x18],r6
8000e5e4:	0e 9c       	mov	r12,r7
8000e5e6:	06 9b       	mov	r11,r3
8000e5e8:	e0 a0 04 dc 	rcall	8000efa0 <_Bfree>
8000e5ec:	30 08       	mov	r8,0
8000e5ee:	aa 88       	st.b	r5[0x0],r8
8000e5f0:	40 68       	lddsp	r8,sp[0x18]
8000e5f2:	41 5a       	lddsp	r10,sp[0x54]
8000e5f4:	2f f8       	sub	r8,-1
8000e5f6:	41 29       	lddsp	r9,sp[0x48]
8000e5f8:	95 08       	st.w	r10[0x0],r8
8000e5fa:	40 8c       	lddsp	r12,sp[0x20]
8000e5fc:	58 09       	cp.w	r9,0
8000e5fe:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000e602:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000e606:	2e 6d       	sub	sp,-104
8000e608:	d8 32       	popm	r0-r7,pc
8000e60a:	d7 03       	nop

8000e60c <__errno>:
8000e60c:	e0 68 0a 50 	mov	r8,2640
8000e610:	70 0c       	ld.w	r12,r8[0x0]
8000e612:	2f 4c       	sub	r12,-12
8000e614:	5e fc       	retal	r12
8000e616:	d7 03       	nop

8000e618 <_fflush_r>:
8000e618:	d4 21       	pushm	r4-r7,lr
8000e61a:	16 97       	mov	r7,r11
8000e61c:	18 96       	mov	r6,r12
8000e61e:	76 48       	ld.w	r8,r11[0x10]
8000e620:	58 08       	cp.w	r8,0
8000e622:	c7 f0       	breq	8000e720 <_fflush_r+0x108>
8000e624:	58 0c       	cp.w	r12,0
8000e626:	c0 50       	breq	8000e630 <_fflush_r+0x18>
8000e628:	78 68       	ld.w	r8,r12[0x18]
8000e62a:	58 08       	cp.w	r8,0
8000e62c:	c0 21       	brne	8000e630 <_fflush_r+0x18>
8000e62e:	cc dc       	rcall	8000e7c8 <__sinit>
8000e630:	fe c8 d6 38 	sub	r8,pc,-10696
8000e634:	10 37       	cp.w	r7,r8
8000e636:	c0 31       	brne	8000e63c <_fflush_r+0x24>
8000e638:	6c 07       	ld.w	r7,r6[0x0]
8000e63a:	c0 c8       	rjmp	8000e652 <_fflush_r+0x3a>
8000e63c:	fe c8 d6 24 	sub	r8,pc,-10716
8000e640:	10 37       	cp.w	r7,r8
8000e642:	c0 31       	brne	8000e648 <_fflush_r+0x30>
8000e644:	6c 17       	ld.w	r7,r6[0x4]
8000e646:	c0 68       	rjmp	8000e652 <_fflush_r+0x3a>
8000e648:	fe c8 d6 10 	sub	r8,pc,-10736
8000e64c:	10 37       	cp.w	r7,r8
8000e64e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000e652:	8e 6a       	ld.sh	r10,r7[0xc]
8000e654:	14 98       	mov	r8,r10
8000e656:	ed ba 00 03 	bld	r10,0x3
8000e65a:	c4 20       	breq	8000e6de <_fflush_r+0xc6>
8000e65c:	ab ba       	sbr	r10,0xb
8000e65e:	ae 6a       	st.h	r7[0xc],r10
8000e660:	6e 18       	ld.w	r8,r7[0x4]
8000e662:	58 08       	cp.w	r8,0
8000e664:	e0 89 00 06 	brgt	8000e670 <_fflush_r+0x58>
8000e668:	6f 08       	ld.w	r8,r7[0x40]
8000e66a:	58 08       	cp.w	r8,0
8000e66c:	e0 8a 00 5a 	brle	8000e720 <_fflush_r+0x108>
8000e670:	6e b8       	ld.w	r8,r7[0x2c]
8000e672:	58 08       	cp.w	r8,0
8000e674:	c5 60       	breq	8000e720 <_fflush_r+0x108>
8000e676:	e2 1a 10 00 	andl	r10,0x1000,COH
8000e67a:	c0 30       	breq	8000e680 <_fflush_r+0x68>
8000e67c:	6f 55       	ld.w	r5,r7[0x54]
8000e67e:	c0 f8       	rjmp	8000e69c <_fflush_r+0x84>
8000e680:	30 19       	mov	r9,1
8000e682:	6e 8b       	ld.w	r11,r7[0x20]
8000e684:	0c 9c       	mov	r12,r6
8000e686:	5d 18       	icall	r8
8000e688:	18 95       	mov	r5,r12
8000e68a:	5b fc       	cp.w	r12,-1
8000e68c:	c0 81       	brne	8000e69c <_fflush_r+0x84>
8000e68e:	6c 38       	ld.w	r8,r6[0xc]
8000e690:	59 d8       	cp.w	r8,29
8000e692:	c4 70       	breq	8000e720 <_fflush_r+0x108>
8000e694:	8e 68       	ld.sh	r8,r7[0xc]
8000e696:	a7 a8       	sbr	r8,0x6
8000e698:	ae 68       	st.h	r7[0xc],r8
8000e69a:	d8 22       	popm	r4-r7,pc
8000e69c:	8e 68       	ld.sh	r8,r7[0xc]
8000e69e:	ed b8 00 02 	bld	r8,0x2
8000e6a2:	c0 91       	brne	8000e6b4 <_fflush_r+0x9c>
8000e6a4:	6e 18       	ld.w	r8,r7[0x4]
8000e6a6:	10 15       	sub	r5,r8
8000e6a8:	6e d8       	ld.w	r8,r7[0x34]
8000e6aa:	58 08       	cp.w	r8,0
8000e6ac:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000e6b0:	eb d8 e1 15 	subne	r5,r5,r8
8000e6b4:	6e b8       	ld.w	r8,r7[0x2c]
8000e6b6:	0c 9c       	mov	r12,r6
8000e6b8:	30 09       	mov	r9,0
8000e6ba:	0a 9a       	mov	r10,r5
8000e6bc:	6e 8b       	ld.w	r11,r7[0x20]
8000e6be:	5d 18       	icall	r8
8000e6c0:	8e 68       	ld.sh	r8,r7[0xc]
8000e6c2:	0a 3c       	cp.w	r12,r5
8000e6c4:	c2 61       	brne	8000e710 <_fflush_r+0xf8>
8000e6c6:	ab d8       	cbr	r8,0xb
8000e6c8:	30 0c       	mov	r12,0
8000e6ca:	6e 49       	ld.w	r9,r7[0x10]
8000e6cc:	ae 68       	st.h	r7[0xc],r8
8000e6ce:	8f 1c       	st.w	r7[0x4],r12
8000e6d0:	8f 09       	st.w	r7[0x0],r9
8000e6d2:	ed b8 00 0c 	bld	r8,0xc
8000e6d6:	c2 51       	brne	8000e720 <_fflush_r+0x108>
8000e6d8:	ef 45 00 54 	st.w	r7[84],r5
8000e6dc:	d8 22       	popm	r4-r7,pc
8000e6de:	6e 45       	ld.w	r5,r7[0x10]
8000e6e0:	58 05       	cp.w	r5,0
8000e6e2:	c1 f0       	breq	8000e720 <_fflush_r+0x108>
8000e6e4:	6e 04       	ld.w	r4,r7[0x0]
8000e6e6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000e6ea:	8f 05       	st.w	r7[0x0],r5
8000e6ec:	f9 b8 01 00 	movne	r8,0
8000e6f0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000e6f4:	0a 14       	sub	r4,r5
8000e6f6:	8f 28       	st.w	r7[0x8],r8
8000e6f8:	c1 18       	rjmp	8000e71a <_fflush_r+0x102>
8000e6fa:	08 99       	mov	r9,r4
8000e6fc:	0a 9a       	mov	r10,r5
8000e6fe:	6e a8       	ld.w	r8,r7[0x28]
8000e700:	6e 8b       	ld.w	r11,r7[0x20]
8000e702:	0c 9c       	mov	r12,r6
8000e704:	5d 18       	icall	r8
8000e706:	18 14       	sub	r4,r12
8000e708:	58 0c       	cp.w	r12,0
8000e70a:	e0 89 00 07 	brgt	8000e718 <_fflush_r+0x100>
8000e70e:	8e 68       	ld.sh	r8,r7[0xc]
8000e710:	a7 a8       	sbr	r8,0x6
8000e712:	3f fc       	mov	r12,-1
8000e714:	ae 68       	st.h	r7[0xc],r8
8000e716:	d8 22       	popm	r4-r7,pc
8000e718:	18 05       	add	r5,r12
8000e71a:	58 04       	cp.w	r4,0
8000e71c:	fe 99 ff ef 	brgt	8000e6fa <_fflush_r+0xe2>
8000e720:	d8 2a       	popm	r4-r7,pc,r12=0
8000e722:	d7 03       	nop

8000e724 <__sfp_lock_acquire>:
8000e724:	5e fc       	retal	r12

8000e726 <__sfp_lock_release>:
8000e726:	5e fc       	retal	r12

8000e728 <_cleanup_r>:
8000e728:	d4 01       	pushm	lr
8000e72a:	fe cb f0 c6 	sub	r11,pc,-3898
8000e72e:	e0 a0 02 f7 	rcall	8000ed1c <_fwalk>
8000e732:	d8 02       	popm	pc

8000e734 <__sfmoreglue>:
8000e734:	d4 21       	pushm	r4-r7,lr
8000e736:	16 95       	mov	r5,r11
8000e738:	f6 06 10 5c 	mul	r6,r11,92
8000e73c:	ec cb ff f4 	sub	r11,r6,-12
8000e740:	fe b0 e2 6a 	rcall	8000ac14 <_malloc_r>
8000e744:	18 97       	mov	r7,r12
8000e746:	c0 90       	breq	8000e758 <__sfmoreglue+0x24>
8000e748:	99 15       	st.w	r12[0x4],r5
8000e74a:	30 0b       	mov	r11,0
8000e74c:	2f 4c       	sub	r12,-12
8000e74e:	0c 9a       	mov	r10,r6
8000e750:	8f 2c       	st.w	r7[0x8],r12
8000e752:	8f 0b       	st.w	r7[0x0],r11
8000e754:	fe b0 e5 33 	rcall	8000b1ba <memset>
8000e758:	0e 9c       	mov	r12,r7
8000e75a:	d8 22       	popm	r4-r7,pc

8000e75c <__sfp>:
8000e75c:	d4 21       	pushm	r4-r7,lr
8000e75e:	fe c8 d7 02 	sub	r8,pc,-10494
8000e762:	18 96       	mov	r6,r12
8000e764:	70 07       	ld.w	r7,r8[0x0]
8000e766:	6e 68       	ld.w	r8,r7[0x18]
8000e768:	58 08       	cp.w	r8,0
8000e76a:	c0 31       	brne	8000e770 <__sfp+0x14>
8000e76c:	0e 9c       	mov	r12,r7
8000e76e:	c2 dc       	rcall	8000e7c8 <__sinit>
8000e770:	ee c7 ff 28 	sub	r7,r7,-216
8000e774:	30 05       	mov	r5,0
8000e776:	6e 2c       	ld.w	r12,r7[0x8]
8000e778:	6e 18       	ld.w	r8,r7[0x4]
8000e77a:	c0 68       	rjmp	8000e786 <__sfp+0x2a>
8000e77c:	98 69       	ld.sh	r9,r12[0xc]
8000e77e:	ea 09 19 00 	cp.h	r9,r5
8000e782:	c1 10       	breq	8000e7a4 <__sfp+0x48>
8000e784:	2a 4c       	sub	r12,-92
8000e786:	20 18       	sub	r8,1
8000e788:	cf a7       	brpl	8000e77c <__sfp+0x20>
8000e78a:	6e 08       	ld.w	r8,r7[0x0]
8000e78c:	58 08       	cp.w	r8,0
8000e78e:	c0 61       	brne	8000e79a <__sfp+0x3e>
8000e790:	30 4b       	mov	r11,4
8000e792:	0c 9c       	mov	r12,r6
8000e794:	cd 0f       	rcall	8000e734 <__sfmoreglue>
8000e796:	8f 0c       	st.w	r7[0x0],r12
8000e798:	c0 30       	breq	8000e79e <__sfp+0x42>
8000e79a:	6e 07       	ld.w	r7,r7[0x0]
8000e79c:	ce db       	rjmp	8000e776 <__sfp+0x1a>
8000e79e:	30 c8       	mov	r8,12
8000e7a0:	8d 38       	st.w	r6[0xc],r8
8000e7a2:	d8 22       	popm	r4-r7,pc
8000e7a4:	30 08       	mov	r8,0
8000e7a6:	f9 48 00 4c 	st.w	r12[76],r8
8000e7aa:	99 08       	st.w	r12[0x0],r8
8000e7ac:	99 28       	st.w	r12[0x8],r8
8000e7ae:	99 18       	st.w	r12[0x4],r8
8000e7b0:	99 48       	st.w	r12[0x10],r8
8000e7b2:	99 58       	st.w	r12[0x14],r8
8000e7b4:	99 68       	st.w	r12[0x18],r8
8000e7b6:	99 d8       	st.w	r12[0x34],r8
8000e7b8:	99 e8       	st.w	r12[0x38],r8
8000e7ba:	f9 48 00 48 	st.w	r12[72],r8
8000e7be:	3f f8       	mov	r8,-1
8000e7c0:	b8 78       	st.h	r12[0xe],r8
8000e7c2:	30 18       	mov	r8,1
8000e7c4:	b8 68       	st.h	r12[0xc],r8
8000e7c6:	d8 22       	popm	r4-r7,pc

8000e7c8 <__sinit>:
8000e7c8:	d4 21       	pushm	r4-r7,lr
8000e7ca:	18 96       	mov	r6,r12
8000e7cc:	78 67       	ld.w	r7,r12[0x18]
8000e7ce:	58 07       	cp.w	r7,0
8000e7d0:	c4 91       	brne	8000e862 <__sinit+0x9a>
8000e7d2:	fe c8 00 aa 	sub	r8,pc,170
8000e7d6:	30 15       	mov	r5,1
8000e7d8:	99 a8       	st.w	r12[0x28],r8
8000e7da:	f9 47 00 d8 	st.w	r12[216],r7
8000e7de:	f9 47 00 dc 	st.w	r12[220],r7
8000e7e2:	f9 47 00 e0 	st.w	r12[224],r7
8000e7e6:	99 65       	st.w	r12[0x18],r5
8000e7e8:	cb af       	rcall	8000e75c <__sfp>
8000e7ea:	8d 0c       	st.w	r6[0x0],r12
8000e7ec:	0c 9c       	mov	r12,r6
8000e7ee:	cb 7f       	rcall	8000e75c <__sfp>
8000e7f0:	8d 1c       	st.w	r6[0x4],r12
8000e7f2:	0c 9c       	mov	r12,r6
8000e7f4:	cb 4f       	rcall	8000e75c <__sfp>
8000e7f6:	6c 09       	ld.w	r9,r6[0x0]
8000e7f8:	30 48       	mov	r8,4
8000e7fa:	93 07       	st.w	r9[0x0],r7
8000e7fc:	b2 68       	st.h	r9[0xc],r8
8000e7fe:	93 17       	st.w	r9[0x4],r7
8000e800:	93 27       	st.w	r9[0x8],r7
8000e802:	6c 18       	ld.w	r8,r6[0x4]
8000e804:	b2 77       	st.h	r9[0xe],r7
8000e806:	93 47       	st.w	r9[0x10],r7
8000e808:	93 57       	st.w	r9[0x14],r7
8000e80a:	93 67       	st.w	r9[0x18],r7
8000e80c:	93 89       	st.w	r9[0x20],r9
8000e80e:	91 07       	st.w	r8[0x0],r7
8000e810:	91 17       	st.w	r8[0x4],r7
8000e812:	91 27       	st.w	r8[0x8],r7
8000e814:	fe ce f3 24 	sub	lr,pc,-3292
8000e818:	fe cb f3 54 	sub	r11,pc,-3244
8000e81c:	93 9e       	st.w	r9[0x24],lr
8000e81e:	93 ab       	st.w	r9[0x28],r11
8000e820:	fe ca f3 7c 	sub	r10,pc,-3204
8000e824:	fe c4 f3 88 	sub	r4,pc,-3192
8000e828:	93 ba       	st.w	r9[0x2c],r10
8000e82a:	93 c4       	st.w	r9[0x30],r4
8000e82c:	30 99       	mov	r9,9
8000e82e:	b0 69       	st.h	r8[0xc],r9
8000e830:	b0 75       	st.h	r8[0xe],r5
8000e832:	91 c4       	st.w	r8[0x30],r4
8000e834:	91 47       	st.w	r8[0x10],r7
8000e836:	91 57       	st.w	r8[0x14],r7
8000e838:	91 67       	st.w	r8[0x18],r7
8000e83a:	91 88       	st.w	r8[0x20],r8
8000e83c:	91 9e       	st.w	r8[0x24],lr
8000e83e:	91 ab       	st.w	r8[0x28],r11
8000e840:	91 ba       	st.w	r8[0x2c],r10
8000e842:	8d 2c       	st.w	r6[0x8],r12
8000e844:	31 28       	mov	r8,18
8000e846:	99 07       	st.w	r12[0x0],r7
8000e848:	b8 68       	st.h	r12[0xc],r8
8000e84a:	99 17       	st.w	r12[0x4],r7
8000e84c:	99 27       	st.w	r12[0x8],r7
8000e84e:	30 28       	mov	r8,2
8000e850:	b8 78       	st.h	r12[0xe],r8
8000e852:	99 c4       	st.w	r12[0x30],r4
8000e854:	99 67       	st.w	r12[0x18],r7
8000e856:	99 9e       	st.w	r12[0x24],lr
8000e858:	99 ab       	st.w	r12[0x28],r11
8000e85a:	99 ba       	st.w	r12[0x2c],r10
8000e85c:	99 47       	st.w	r12[0x10],r7
8000e85e:	99 57       	st.w	r12[0x14],r7
8000e860:	99 8c       	st.w	r12[0x20],r12
8000e862:	d8 22       	popm	r4-r7,pc

8000e864 <_malloc_trim_r>:
8000e864:	d4 21       	pushm	r4-r7,lr
8000e866:	16 95       	mov	r5,r11
8000e868:	18 97       	mov	r7,r12
8000e86a:	fe b0 cd b1 	rcall	800083cc <__malloc_lock>
8000e86e:	e0 64 05 50 	mov	r4,1360
8000e872:	68 28       	ld.w	r8,r4[0x8]
8000e874:	70 16       	ld.w	r6,r8[0x4]
8000e876:	e0 16 ff fc 	andl	r6,0xfffc
8000e87a:	ec c8 ff 91 	sub	r8,r6,-111
8000e87e:	f0 05 01 05 	sub	r5,r8,r5
8000e882:	e0 15 ff 80 	andl	r5,0xff80
8000e886:	ea c5 00 80 	sub	r5,r5,128
8000e88a:	e0 45 00 7f 	cp.w	r5,127
8000e88e:	e0 8a 00 25 	brle	8000e8d8 <_malloc_trim_r+0x74>
8000e892:	30 0b       	mov	r11,0
8000e894:	0e 9c       	mov	r12,r7
8000e896:	fe b0 e5 f9 	rcall	8000b488 <_sbrk_r>
8000e89a:	68 28       	ld.w	r8,r4[0x8]
8000e89c:	0c 08       	add	r8,r6
8000e89e:	10 3c       	cp.w	r12,r8
8000e8a0:	c1 c1       	brne	8000e8d8 <_malloc_trim_r+0x74>
8000e8a2:	ea 0b 11 00 	rsub	r11,r5,0
8000e8a6:	0e 9c       	mov	r12,r7
8000e8a8:	fe b0 e5 f0 	rcall	8000b488 <_sbrk_r>
8000e8ac:	5b fc       	cp.w	r12,-1
8000e8ae:	c1 91       	brne	8000e8e0 <_malloc_trim_r+0x7c>
8000e8b0:	30 0b       	mov	r11,0
8000e8b2:	0e 9c       	mov	r12,r7
8000e8b4:	fe b0 e5 ea 	rcall	8000b488 <_sbrk_r>
8000e8b8:	68 28       	ld.w	r8,r4[0x8]
8000e8ba:	f8 08 01 09 	sub	r9,r12,r8
8000e8be:	58 f9       	cp.w	r9,15
8000e8c0:	e0 8a 00 0c 	brle	8000e8d8 <_malloc_trim_r+0x74>
8000e8c4:	a1 a9       	sbr	r9,0x0
8000e8c6:	91 19       	st.w	r8[0x4],r9
8000e8c8:	e0 68 09 5c 	mov	r8,2396
8000e8cc:	70 09       	ld.w	r9,r8[0x0]
8000e8ce:	e0 68 0d 70 	mov	r8,3440
8000e8d2:	f8 09 01 09 	sub	r9,r12,r9
8000e8d6:	91 09       	st.w	r8[0x0],r9
8000e8d8:	0e 9c       	mov	r12,r7
8000e8da:	fe b0 cd 87 	rcall	800083e8 <__malloc_unlock>
8000e8de:	d8 2a       	popm	r4-r7,pc,r12=0
8000e8e0:	68 28       	ld.w	r8,r4[0x8]
8000e8e2:	0a 16       	sub	r6,r5
8000e8e4:	a1 a6       	sbr	r6,0x0
8000e8e6:	91 16       	st.w	r8[0x4],r6
8000e8e8:	e0 68 0d 70 	mov	r8,3440
8000e8ec:	70 09       	ld.w	r9,r8[0x0]
8000e8ee:	0a 19       	sub	r9,r5
8000e8f0:	0e 9c       	mov	r12,r7
8000e8f2:	91 09       	st.w	r8[0x0],r9
8000e8f4:	fe b0 cd 7a 	rcall	800083e8 <__malloc_unlock>
8000e8f8:	da 2a       	popm	r4-r7,pc,r12=1
8000e8fa:	d7 03       	nop

8000e8fc <_free_r>:
8000e8fc:	d4 21       	pushm	r4-r7,lr
8000e8fe:	16 96       	mov	r6,r11
8000e900:	18 97       	mov	r7,r12
8000e902:	58 0b       	cp.w	r11,0
8000e904:	e0 80 00 c0 	breq	8000ea84 <_free_r+0x188>
8000e908:	fe b0 cd 62 	rcall	800083cc <__malloc_lock>
8000e90c:	20 86       	sub	r6,8
8000e90e:	e0 6a 05 50 	mov	r10,1360
8000e912:	6c 18       	ld.w	r8,r6[0x4]
8000e914:	74 2e       	ld.w	lr,r10[0x8]
8000e916:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000e91a:	a1 c8       	cbr	r8,0x0
8000e91c:	ec 08 00 09 	add	r9,r6,r8
8000e920:	72 1b       	ld.w	r11,r9[0x4]
8000e922:	e0 1b ff fc 	andl	r11,0xfffc
8000e926:	1c 39       	cp.w	r9,lr
8000e928:	c1 e1       	brne	8000e964 <_free_r+0x68>
8000e92a:	f6 08 00 08 	add	r8,r11,r8
8000e92e:	58 0c       	cp.w	r12,0
8000e930:	c0 81       	brne	8000e940 <_free_r+0x44>
8000e932:	6c 09       	ld.w	r9,r6[0x0]
8000e934:	12 16       	sub	r6,r9
8000e936:	12 08       	add	r8,r9
8000e938:	6c 3b       	ld.w	r11,r6[0xc]
8000e93a:	6c 29       	ld.w	r9,r6[0x8]
8000e93c:	97 29       	st.w	r11[0x8],r9
8000e93e:	93 3b       	st.w	r9[0xc],r11
8000e940:	10 99       	mov	r9,r8
8000e942:	95 26       	st.w	r10[0x8],r6
8000e944:	a1 a9       	sbr	r9,0x0
8000e946:	8d 19       	st.w	r6[0x4],r9
8000e948:	e0 69 09 58 	mov	r9,2392
8000e94c:	72 09       	ld.w	r9,r9[0x0]
8000e94e:	12 38       	cp.w	r8,r9
8000e950:	c0 63       	brcs	8000e95c <_free_r+0x60>
8000e952:	e0 68 0d 6c 	mov	r8,3436
8000e956:	0e 9c       	mov	r12,r7
8000e958:	70 0b       	ld.w	r11,r8[0x0]
8000e95a:	c8 5f       	rcall	8000e864 <_malloc_trim_r>
8000e95c:	0e 9c       	mov	r12,r7
8000e95e:	fe b0 cd 45 	rcall	800083e8 <__malloc_unlock>
8000e962:	d8 22       	popm	r4-r7,pc
8000e964:	93 1b       	st.w	r9[0x4],r11
8000e966:	58 0c       	cp.w	r12,0
8000e968:	c0 30       	breq	8000e96e <_free_r+0x72>
8000e96a:	30 0c       	mov	r12,0
8000e96c:	c1 08       	rjmp	8000e98c <_free_r+0x90>
8000e96e:	6c 0e       	ld.w	lr,r6[0x0]
8000e970:	f4 c5 ff f8 	sub	r5,r10,-8
8000e974:	1c 16       	sub	r6,lr
8000e976:	1c 08       	add	r8,lr
8000e978:	6c 2e       	ld.w	lr,r6[0x8]
8000e97a:	0a 3e       	cp.w	lr,r5
8000e97c:	f9 bc 00 01 	moveq	r12,1
8000e980:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000e984:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000e988:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000e98c:	f2 0b 00 0e 	add	lr,r9,r11
8000e990:	7c 1e       	ld.w	lr,lr[0x4]
8000e992:	ed be 00 00 	bld	lr,0x0
8000e996:	c1 40       	breq	8000e9be <_free_r+0xc2>
8000e998:	16 08       	add	r8,r11
8000e99a:	58 0c       	cp.w	r12,0
8000e99c:	c0 d1       	brne	8000e9b6 <_free_r+0xba>
8000e99e:	e0 6e 05 50 	mov	lr,1360
8000e9a2:	72 2b       	ld.w	r11,r9[0x8]
8000e9a4:	2f 8e       	sub	lr,-8
8000e9a6:	1c 3b       	cp.w	r11,lr
8000e9a8:	c0 71       	brne	8000e9b6 <_free_r+0xba>
8000e9aa:	97 36       	st.w	r11[0xc],r6
8000e9ac:	97 26       	st.w	r11[0x8],r6
8000e9ae:	8d 2b       	st.w	r6[0x8],r11
8000e9b0:	8d 3b       	st.w	r6[0xc],r11
8000e9b2:	30 1c       	mov	r12,1
8000e9b4:	c0 58       	rjmp	8000e9be <_free_r+0xc2>
8000e9b6:	72 2b       	ld.w	r11,r9[0x8]
8000e9b8:	72 39       	ld.w	r9,r9[0xc]
8000e9ba:	93 2b       	st.w	r9[0x8],r11
8000e9bc:	97 39       	st.w	r11[0xc],r9
8000e9be:	10 99       	mov	r9,r8
8000e9c0:	ec 08 09 08 	st.w	r6[r8],r8
8000e9c4:	a1 a9       	sbr	r9,0x0
8000e9c6:	8d 19       	st.w	r6[0x4],r9
8000e9c8:	58 0c       	cp.w	r12,0
8000e9ca:	c5 a1       	brne	8000ea7e <_free_r+0x182>
8000e9cc:	e0 48 01 ff 	cp.w	r8,511
8000e9d0:	e0 8b 00 13 	brhi	8000e9f6 <_free_r+0xfa>
8000e9d4:	a3 98       	lsr	r8,0x3
8000e9d6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000e9da:	72 2b       	ld.w	r11,r9[0x8]
8000e9dc:	8d 39       	st.w	r6[0xc],r9
8000e9de:	8d 2b       	st.w	r6[0x8],r11
8000e9e0:	97 36       	st.w	r11[0xc],r6
8000e9e2:	93 26       	st.w	r9[0x8],r6
8000e9e4:	a3 48       	asr	r8,0x2
8000e9e6:	74 19       	ld.w	r9,r10[0x4]
8000e9e8:	30 1b       	mov	r11,1
8000e9ea:	f6 08 09 48 	lsl	r8,r11,r8
8000e9ee:	f3 e8 10 08 	or	r8,r9,r8
8000e9f2:	95 18       	st.w	r10[0x4],r8
8000e9f4:	c4 58       	rjmp	8000ea7e <_free_r+0x182>
8000e9f6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000e9fa:	58 4b       	cp.w	r11,4
8000e9fc:	e0 8b 00 06 	brhi	8000ea08 <_free_r+0x10c>
8000ea00:	f0 0b 16 06 	lsr	r11,r8,0x6
8000ea04:	2c 8b       	sub	r11,-56
8000ea06:	c2 08       	rjmp	8000ea46 <_free_r+0x14a>
8000ea08:	59 4b       	cp.w	r11,20
8000ea0a:	e0 8b 00 04 	brhi	8000ea12 <_free_r+0x116>
8000ea0e:	2a 5b       	sub	r11,-91
8000ea10:	c1 b8       	rjmp	8000ea46 <_free_r+0x14a>
8000ea12:	e0 4b 00 54 	cp.w	r11,84
8000ea16:	e0 8b 00 06 	brhi	8000ea22 <_free_r+0x126>
8000ea1a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000ea1e:	29 2b       	sub	r11,-110
8000ea20:	c1 38       	rjmp	8000ea46 <_free_r+0x14a>
8000ea22:	e0 4b 01 54 	cp.w	r11,340
8000ea26:	e0 8b 00 06 	brhi	8000ea32 <_free_r+0x136>
8000ea2a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000ea2e:	28 9b       	sub	r11,-119
8000ea30:	c0 b8       	rjmp	8000ea46 <_free_r+0x14a>
8000ea32:	e0 4b 05 54 	cp.w	r11,1364
8000ea36:	e0 88 00 05 	brls	8000ea40 <_free_r+0x144>
8000ea3a:	37 eb       	mov	r11,126
8000ea3c:	c0 58       	rjmp	8000ea46 <_free_r+0x14a>
8000ea3e:	d7 03       	nop
8000ea40:	f0 0b 16 12 	lsr	r11,r8,0x12
8000ea44:	28 4b       	sub	r11,-124
8000ea46:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000ea4a:	78 29       	ld.w	r9,r12[0x8]
8000ea4c:	18 39       	cp.w	r9,r12
8000ea4e:	c0 e1       	brne	8000ea6a <_free_r+0x16e>
8000ea50:	74 18       	ld.w	r8,r10[0x4]
8000ea52:	a3 4b       	asr	r11,0x2
8000ea54:	30 1c       	mov	r12,1
8000ea56:	f8 0b 09 4b 	lsl	r11,r12,r11
8000ea5a:	f1 eb 10 0b 	or	r11,r8,r11
8000ea5e:	12 98       	mov	r8,r9
8000ea60:	95 1b       	st.w	r10[0x4],r11
8000ea62:	c0 a8       	rjmp	8000ea76 <_free_r+0x17a>
8000ea64:	72 29       	ld.w	r9,r9[0x8]
8000ea66:	18 39       	cp.w	r9,r12
8000ea68:	c0 60       	breq	8000ea74 <_free_r+0x178>
8000ea6a:	72 1a       	ld.w	r10,r9[0x4]
8000ea6c:	e0 1a ff fc 	andl	r10,0xfffc
8000ea70:	14 38       	cp.w	r8,r10
8000ea72:	cf 93       	brcs	8000ea64 <_free_r+0x168>
8000ea74:	72 38       	ld.w	r8,r9[0xc]
8000ea76:	8d 38       	st.w	r6[0xc],r8
8000ea78:	8d 29       	st.w	r6[0x8],r9
8000ea7a:	93 36       	st.w	r9[0xc],r6
8000ea7c:	91 26       	st.w	r8[0x8],r6
8000ea7e:	0e 9c       	mov	r12,r7
8000ea80:	fe b0 cc b4 	rcall	800083e8 <__malloc_unlock>
8000ea84:	d8 22       	popm	r4-r7,pc
8000ea86:	d7 03       	nop

8000ea88 <__sfvwrite_r>:
8000ea88:	d4 31       	pushm	r0-r7,lr
8000ea8a:	20 3d       	sub	sp,12
8000ea8c:	14 94       	mov	r4,r10
8000ea8e:	18 95       	mov	r5,r12
8000ea90:	16 97       	mov	r7,r11
8000ea92:	74 28       	ld.w	r8,r10[0x8]
8000ea94:	58 08       	cp.w	r8,0
8000ea96:	e0 80 01 40 	breq	8000ed16 <__sfvwrite_r+0x28e>
8000ea9a:	96 68       	ld.sh	r8,r11[0xc]
8000ea9c:	ed b8 00 03 	bld	r8,0x3
8000eaa0:	c0 41       	brne	8000eaa8 <__sfvwrite_r+0x20>
8000eaa2:	76 48       	ld.w	r8,r11[0x10]
8000eaa4:	58 08       	cp.w	r8,0
8000eaa6:	c0 c1       	brne	8000eabe <__sfvwrite_r+0x36>
8000eaa8:	0e 9b       	mov	r11,r7
8000eaaa:	0a 9c       	mov	r12,r5
8000eaac:	fe b0 f6 c4 	rcall	8000d834 <__swsetup_r>
8000eab0:	c0 70       	breq	8000eabe <__sfvwrite_r+0x36>
8000eab2:	8e 68       	ld.sh	r8,r7[0xc]
8000eab4:	a7 a8       	sbr	r8,0x6
8000eab6:	ae 68       	st.h	r7[0xc],r8
8000eab8:	30 98       	mov	r8,9
8000eaba:	8b 38       	st.w	r5[0xc],r8
8000eabc:	c2 b9       	rjmp	8000ed12 <__sfvwrite_r+0x28a>
8000eabe:	8e 63       	ld.sh	r3,r7[0xc]
8000eac0:	68 00       	ld.w	r0,r4[0x0]
8000eac2:	06 96       	mov	r6,r3
8000eac4:	e2 16 00 02 	andl	r6,0x2,COH
8000eac8:	c2 10       	breq	8000eb0a <__sfvwrite_r+0x82>
8000eaca:	30 03       	mov	r3,0
8000eacc:	e0 62 04 00 	mov	r2,1024
8000ead0:	06 96       	mov	r6,r3
8000ead2:	c0 48       	rjmp	8000eada <__sfvwrite_r+0x52>
8000ead4:	60 03       	ld.w	r3,r0[0x0]
8000ead6:	60 16       	ld.w	r6,r0[0x4]
8000ead8:	2f 80       	sub	r0,-8
8000eada:	58 06       	cp.w	r6,0
8000eadc:	cf c0       	breq	8000ead4 <__sfvwrite_r+0x4c>
8000eade:	e0 46 04 00 	cp.w	r6,1024
8000eae2:	ec 09 17 80 	movls	r9,r6
8000eae6:	e4 09 17 b0 	movhi	r9,r2
8000eaea:	06 9a       	mov	r10,r3
8000eaec:	6e a8       	ld.w	r8,r7[0x28]
8000eaee:	6e 8b       	ld.w	r11,r7[0x20]
8000eaf0:	0a 9c       	mov	r12,r5
8000eaf2:	5d 18       	icall	r8
8000eaf4:	18 16       	sub	r6,r12
8000eaf6:	58 0c       	cp.w	r12,0
8000eaf8:	e0 8a 01 0a 	brle	8000ed0c <__sfvwrite_r+0x284>
8000eafc:	68 28       	ld.w	r8,r4[0x8]
8000eafe:	18 18       	sub	r8,r12
8000eb00:	89 28       	st.w	r4[0x8],r8
8000eb02:	e0 80 01 0a 	breq	8000ed16 <__sfvwrite_r+0x28e>
8000eb06:	18 03       	add	r3,r12
8000eb08:	ce 9b       	rjmp	8000eada <__sfvwrite_r+0x52>
8000eb0a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000eb0e:	c0 70       	breq	8000eb1c <__sfvwrite_r+0x94>
8000eb10:	50 06       	stdsp	sp[0x0],r6
8000eb12:	0c 93       	mov	r3,r6
8000eb14:	0c 91       	mov	r1,r6
8000eb16:	50 15       	stdsp	sp[0x4],r5
8000eb18:	08 92       	mov	r2,r4
8000eb1a:	c9 c8       	rjmp	8000ec52 <__sfvwrite_r+0x1ca>
8000eb1c:	06 96       	mov	r6,r3
8000eb1e:	08 91       	mov	r1,r4
8000eb20:	c0 48       	rjmp	8000eb28 <__sfvwrite_r+0xa0>
8000eb22:	60 03       	ld.w	r3,r0[0x0]
8000eb24:	60 16       	ld.w	r6,r0[0x4]
8000eb26:	2f 80       	sub	r0,-8
8000eb28:	58 06       	cp.w	r6,0
8000eb2a:	cf c0       	breq	8000eb22 <__sfvwrite_r+0x9a>
8000eb2c:	8e 68       	ld.sh	r8,r7[0xc]
8000eb2e:	6e 24       	ld.w	r4,r7[0x8]
8000eb30:	10 99       	mov	r9,r8
8000eb32:	e2 19 02 00 	andl	r9,0x200,COH
8000eb36:	c5 50       	breq	8000ebe0 <__sfvwrite_r+0x158>
8000eb38:	08 36       	cp.w	r6,r4
8000eb3a:	c4 43       	brcs	8000ebc2 <__sfvwrite_r+0x13a>
8000eb3c:	10 99       	mov	r9,r8
8000eb3e:	e2 19 04 80 	andl	r9,0x480,COH
8000eb42:	c4 00       	breq	8000ebc2 <__sfvwrite_r+0x13a>
8000eb44:	6e 4b       	ld.w	r11,r7[0x10]
8000eb46:	6e 09       	ld.w	r9,r7[0x0]
8000eb48:	16 19       	sub	r9,r11
8000eb4a:	50 09       	stdsp	sp[0x0],r9
8000eb4c:	6e 59       	ld.w	r9,r7[0x14]
8000eb4e:	10 9c       	mov	r12,r8
8000eb50:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000eb54:	30 28       	mov	r8,2
8000eb56:	f4 08 0c 08 	divs	r8,r10,r8
8000eb5a:	fa e9 00 04 	st.d	sp[4],r8
8000eb5e:	10 94       	mov	r4,r8
8000eb60:	40 09       	lddsp	r9,sp[0x0]
8000eb62:	e2 1c 04 00 	andl	r12,0x400,COH
8000eb66:	2f f9       	sub	r9,-1
8000eb68:	0c 09       	add	r9,r6
8000eb6a:	12 38       	cp.w	r8,r9
8000eb6c:	f2 04 17 30 	movlo	r4,r9
8000eb70:	58 0c       	cp.w	r12,0
8000eb72:	c1 10       	breq	8000eb94 <__sfvwrite_r+0x10c>
8000eb74:	08 9b       	mov	r11,r4
8000eb76:	0a 9c       	mov	r12,r5
8000eb78:	fe b0 e0 4e 	rcall	8000ac14 <_malloc_r>
8000eb7c:	18 92       	mov	r2,r12
8000eb7e:	c1 40       	breq	8000eba6 <__sfvwrite_r+0x11e>
8000eb80:	40 0a       	lddsp	r10,sp[0x0]
8000eb82:	6e 4b       	ld.w	r11,r7[0x10]
8000eb84:	fe b0 e2 77 	rcall	8000b072 <memcpy>
8000eb88:	8e 68       	ld.sh	r8,r7[0xc]
8000eb8a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000eb8e:	a7 b8       	sbr	r8,0x7
8000eb90:	ae 68       	st.h	r7[0xc],r8
8000eb92:	c0 d8       	rjmp	8000ebac <__sfvwrite_r+0x124>
8000eb94:	08 9a       	mov	r10,r4
8000eb96:	0a 9c       	mov	r12,r5
8000eb98:	fe b0 e3 18 	rcall	8000b1c8 <_realloc_r>
8000eb9c:	18 92       	mov	r2,r12
8000eb9e:	c0 71       	brne	8000ebac <__sfvwrite_r+0x124>
8000eba0:	6e 4b       	ld.w	r11,r7[0x10]
8000eba2:	0a 9c       	mov	r12,r5
8000eba4:	ca ce       	rcall	8000e8fc <_free_r>
8000eba6:	30 c8       	mov	r8,12
8000eba8:	8b 38       	st.w	r5[0xc],r8
8000ebaa:	cb 18       	rjmp	8000ed0c <__sfvwrite_r+0x284>
8000ebac:	40 0a       	lddsp	r10,sp[0x0]
8000ebae:	40 09       	lddsp	r9,sp[0x0]
8000ebb0:	e8 0a 01 0a 	sub	r10,r4,r10
8000ebb4:	e4 09 00 08 	add	r8,r2,r9
8000ebb8:	8f 54       	st.w	r7[0x14],r4
8000ebba:	8f 2a       	st.w	r7[0x8],r10
8000ebbc:	8f 08       	st.w	r7[0x0],r8
8000ebbe:	8f 42       	st.w	r7[0x10],r2
8000ebc0:	0c 94       	mov	r4,r6
8000ebc2:	08 36       	cp.w	r6,r4
8000ebc4:	ec 04 17 30 	movlo	r4,r6
8000ebc8:	06 9b       	mov	r11,r3
8000ebca:	08 9a       	mov	r10,r4
8000ebcc:	6e 0c       	ld.w	r12,r7[0x0]
8000ebce:	c3 ad       	rcall	8000ee42 <memmove>
8000ebd0:	6e 08       	ld.w	r8,r7[0x0]
8000ebd2:	08 08       	add	r8,r4
8000ebd4:	8f 08       	st.w	r7[0x0],r8
8000ebd6:	6e 28       	ld.w	r8,r7[0x8]
8000ebd8:	08 18       	sub	r8,r4
8000ebda:	0c 94       	mov	r4,r6
8000ebdc:	8f 28       	st.w	r7[0x8],r8
8000ebde:	c2 e8       	rjmp	8000ec3a <__sfvwrite_r+0x1b2>
8000ebe0:	08 36       	cp.w	r6,r4
8000ebe2:	5f ba       	srhi	r10
8000ebe4:	6e 0c       	ld.w	r12,r7[0x0]
8000ebe6:	6e 48       	ld.w	r8,r7[0x10]
8000ebe8:	10 3c       	cp.w	r12,r8
8000ebea:	5f b8       	srhi	r8
8000ebec:	f5 e8 00 08 	and	r8,r10,r8
8000ebf0:	f2 08 18 00 	cp.b	r8,r9
8000ebf4:	c0 d0       	breq	8000ec0e <__sfvwrite_r+0x186>
8000ebf6:	06 9b       	mov	r11,r3
8000ebf8:	08 9a       	mov	r10,r4
8000ebfa:	c2 4d       	rcall	8000ee42 <memmove>
8000ebfc:	6e 08       	ld.w	r8,r7[0x0]
8000ebfe:	08 08       	add	r8,r4
8000ec00:	0e 9b       	mov	r11,r7
8000ec02:	8f 08       	st.w	r7[0x0],r8
8000ec04:	0a 9c       	mov	r12,r5
8000ec06:	fe b0 fd 09 	rcall	8000e618 <_fflush_r>
8000ec0a:	c1 80       	breq	8000ec3a <__sfvwrite_r+0x1b2>
8000ec0c:	c8 08       	rjmp	8000ed0c <__sfvwrite_r+0x284>
8000ec0e:	6e 59       	ld.w	r9,r7[0x14]
8000ec10:	12 36       	cp.w	r6,r9
8000ec12:	c0 a3       	brcs	8000ec26 <__sfvwrite_r+0x19e>
8000ec14:	6e a8       	ld.w	r8,r7[0x28]
8000ec16:	06 9a       	mov	r10,r3
8000ec18:	6e 8b       	ld.w	r11,r7[0x20]
8000ec1a:	0a 9c       	mov	r12,r5
8000ec1c:	5d 18       	icall	r8
8000ec1e:	18 94       	mov	r4,r12
8000ec20:	e0 89 00 0d 	brgt	8000ec3a <__sfvwrite_r+0x1b2>
8000ec24:	c7 48       	rjmp	8000ed0c <__sfvwrite_r+0x284>
8000ec26:	0c 9a       	mov	r10,r6
8000ec28:	06 9b       	mov	r11,r3
8000ec2a:	c0 cd       	rcall	8000ee42 <memmove>
8000ec2c:	6e 08       	ld.w	r8,r7[0x0]
8000ec2e:	0c 08       	add	r8,r6
8000ec30:	0c 94       	mov	r4,r6
8000ec32:	8f 08       	st.w	r7[0x0],r8
8000ec34:	6e 28       	ld.w	r8,r7[0x8]
8000ec36:	0c 18       	sub	r8,r6
8000ec38:	8f 28       	st.w	r7[0x8],r8
8000ec3a:	62 28       	ld.w	r8,r1[0x8]
8000ec3c:	08 18       	sub	r8,r4
8000ec3e:	83 28       	st.w	r1[0x8],r8
8000ec40:	c6 b0       	breq	8000ed16 <__sfvwrite_r+0x28e>
8000ec42:	08 16       	sub	r6,r4
8000ec44:	08 03       	add	r3,r4
8000ec46:	c7 1b       	rjmp	8000eb28 <__sfvwrite_r+0xa0>
8000ec48:	60 03       	ld.w	r3,r0[0x0]
8000ec4a:	60 11       	ld.w	r1,r0[0x4]
8000ec4c:	30 08       	mov	r8,0
8000ec4e:	2f 80       	sub	r0,-8
8000ec50:	50 08       	stdsp	sp[0x0],r8
8000ec52:	58 01       	cp.w	r1,0
8000ec54:	cf a0       	breq	8000ec48 <__sfvwrite_r+0x1c0>
8000ec56:	40 0a       	lddsp	r10,sp[0x0]
8000ec58:	58 0a       	cp.w	r10,0
8000ec5a:	c1 41       	brne	8000ec82 <__sfvwrite_r+0x1fa>
8000ec5c:	e2 c6 ff ff 	sub	r6,r1,-1
8000ec60:	02 9a       	mov	r10,r1
8000ec62:	30 ab       	mov	r11,10
8000ec64:	06 9c       	mov	r12,r3
8000ec66:	ce 3c       	rcall	8000ee2c <memchr>
8000ec68:	f8 c8 ff ff 	sub	r8,r12,-1
8000ec6c:	58 0c       	cp.w	r12,0
8000ec6e:	f1 d3 e1 16 	subne	r6,r8,r3
8000ec72:	f9 b9 01 01 	movne	r9,1
8000ec76:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ec7a:	f9 b8 00 01 	moveq	r8,1
8000ec7e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000ec82:	02 36       	cp.w	r6,r1
8000ec84:	ec 04 17 80 	movls	r4,r6
8000ec88:	e2 04 17 b0 	movhi	r4,r1
8000ec8c:	6e 59       	ld.w	r9,r7[0x14]
8000ec8e:	6e 25       	ld.w	r5,r7[0x8]
8000ec90:	f2 05 00 05 	add	r5,r9,r5
8000ec94:	0a 34       	cp.w	r4,r5
8000ec96:	5f 9a       	srgt	r10
8000ec98:	6e 0c       	ld.w	r12,r7[0x0]
8000ec9a:	6e 48       	ld.w	r8,r7[0x10]
8000ec9c:	10 3c       	cp.w	r12,r8
8000ec9e:	5f b8       	srhi	r8
8000eca0:	f5 e8 00 08 	and	r8,r10,r8
8000eca4:	30 0a       	mov	r10,0
8000eca6:	f4 08 18 00 	cp.b	r8,r10
8000ecaa:	c0 d0       	breq	8000ecc4 <__sfvwrite_r+0x23c>
8000ecac:	06 9b       	mov	r11,r3
8000ecae:	0a 9a       	mov	r10,r5
8000ecb0:	cc 9c       	rcall	8000ee42 <memmove>
8000ecb2:	6e 08       	ld.w	r8,r7[0x0]
8000ecb4:	0a 08       	add	r8,r5
8000ecb6:	0e 9b       	mov	r11,r7
8000ecb8:	8f 08       	st.w	r7[0x0],r8
8000ecba:	40 1c       	lddsp	r12,sp[0x4]
8000ecbc:	fe b0 fc ae 	rcall	8000e618 <_fflush_r>
8000ecc0:	c1 70       	breq	8000ecee <__sfvwrite_r+0x266>
8000ecc2:	c2 58       	rjmp	8000ed0c <__sfvwrite_r+0x284>
8000ecc4:	12 34       	cp.w	r4,r9
8000ecc6:	c0 a5       	brlt	8000ecda <__sfvwrite_r+0x252>
8000ecc8:	6e a8       	ld.w	r8,r7[0x28]
8000ecca:	06 9a       	mov	r10,r3
8000eccc:	6e 8b       	ld.w	r11,r7[0x20]
8000ecce:	40 1c       	lddsp	r12,sp[0x4]
8000ecd0:	5d 18       	icall	r8
8000ecd2:	18 95       	mov	r5,r12
8000ecd4:	e0 89 00 0d 	brgt	8000ecee <__sfvwrite_r+0x266>
8000ecd8:	c1 a8       	rjmp	8000ed0c <__sfvwrite_r+0x284>
8000ecda:	08 9a       	mov	r10,r4
8000ecdc:	06 9b       	mov	r11,r3
8000ecde:	cb 2c       	rcall	8000ee42 <memmove>
8000ece0:	6e 08       	ld.w	r8,r7[0x0]
8000ece2:	08 08       	add	r8,r4
8000ece4:	08 95       	mov	r5,r4
8000ece6:	8f 08       	st.w	r7[0x0],r8
8000ece8:	6e 28       	ld.w	r8,r7[0x8]
8000ecea:	08 18       	sub	r8,r4
8000ecec:	8f 28       	st.w	r7[0x8],r8
8000ecee:	0a 16       	sub	r6,r5
8000ecf0:	c0 71       	brne	8000ecfe <__sfvwrite_r+0x276>
8000ecf2:	0e 9b       	mov	r11,r7
8000ecf4:	40 1c       	lddsp	r12,sp[0x4]
8000ecf6:	fe b0 fc 91 	rcall	8000e618 <_fflush_r>
8000ecfa:	c0 91       	brne	8000ed0c <__sfvwrite_r+0x284>
8000ecfc:	50 06       	stdsp	sp[0x0],r6
8000ecfe:	64 28       	ld.w	r8,r2[0x8]
8000ed00:	0a 18       	sub	r8,r5
8000ed02:	85 28       	st.w	r2[0x8],r8
8000ed04:	c0 90       	breq	8000ed16 <__sfvwrite_r+0x28e>
8000ed06:	0a 11       	sub	r1,r5
8000ed08:	0a 03       	add	r3,r5
8000ed0a:	ca 4b       	rjmp	8000ec52 <__sfvwrite_r+0x1ca>
8000ed0c:	8e 68       	ld.sh	r8,r7[0xc]
8000ed0e:	a7 a8       	sbr	r8,0x6
8000ed10:	ae 68       	st.h	r7[0xc],r8
8000ed12:	3f fc       	mov	r12,-1
8000ed14:	c0 28       	rjmp	8000ed18 <__sfvwrite_r+0x290>
8000ed16:	30 0c       	mov	r12,0
8000ed18:	2f dd       	sub	sp,-12
8000ed1a:	d8 32       	popm	r0-r7,pc

8000ed1c <_fwalk>:
8000ed1c:	d4 31       	pushm	r0-r7,lr
8000ed1e:	30 05       	mov	r5,0
8000ed20:	16 91       	mov	r1,r11
8000ed22:	f8 c7 ff 28 	sub	r7,r12,-216
8000ed26:	0a 92       	mov	r2,r5
8000ed28:	fe b0 fc fe 	rcall	8000e724 <__sfp_lock_acquire>
8000ed2c:	3f f3       	mov	r3,-1
8000ed2e:	c1 68       	rjmp	8000ed5a <_fwalk+0x3e>
8000ed30:	6e 26       	ld.w	r6,r7[0x8]
8000ed32:	6e 14       	ld.w	r4,r7[0x4]
8000ed34:	2f 46       	sub	r6,-12
8000ed36:	c0 c8       	rjmp	8000ed4e <_fwalk+0x32>
8000ed38:	8c 08       	ld.sh	r8,r6[0x0]
8000ed3a:	e4 08 19 00 	cp.h	r8,r2
8000ed3e:	c0 70       	breq	8000ed4c <_fwalk+0x30>
8000ed40:	8c 18       	ld.sh	r8,r6[0x2]
8000ed42:	e6 08 19 00 	cp.h	r8,r3
8000ed46:	c0 30       	breq	8000ed4c <_fwalk+0x30>
8000ed48:	5d 11       	icall	r1
8000ed4a:	18 45       	or	r5,r12
8000ed4c:	2a 46       	sub	r6,-92
8000ed4e:	20 14       	sub	r4,1
8000ed50:	ec cc 00 0c 	sub	r12,r6,12
8000ed54:	58 04       	cp.w	r4,0
8000ed56:	cf 14       	brge	8000ed38 <_fwalk+0x1c>
8000ed58:	6e 07       	ld.w	r7,r7[0x0]
8000ed5a:	58 07       	cp.w	r7,0
8000ed5c:	ce a1       	brne	8000ed30 <_fwalk+0x14>
8000ed5e:	fe b0 fc e4 	rcall	8000e726 <__sfp_lock_release>
8000ed62:	0a 9c       	mov	r12,r5
8000ed64:	d8 32       	popm	r0-r7,pc
8000ed66:	d7 03       	nop

8000ed68 <_localeconv_r>:
8000ed68:	fe cc dd 08 	sub	r12,pc,-8952
8000ed6c:	5e fc       	retal	r12
8000ed6e:	d7 03       	nop

8000ed70 <__smakebuf_r>:
8000ed70:	d4 21       	pushm	r4-r7,lr
8000ed72:	20 fd       	sub	sp,60
8000ed74:	96 68       	ld.sh	r8,r11[0xc]
8000ed76:	16 97       	mov	r7,r11
8000ed78:	18 96       	mov	r6,r12
8000ed7a:	e2 18 00 02 	andl	r8,0x2,COH
8000ed7e:	c3 d1       	brne	8000edf8 <__smakebuf_r+0x88>
8000ed80:	96 7b       	ld.sh	r11,r11[0xe]
8000ed82:	f0 0b 19 00 	cp.h	r11,r8
8000ed86:	c0 55       	brlt	8000ed90 <__smakebuf_r+0x20>
8000ed88:	1a 9a       	mov	r10,sp
8000ed8a:	e0 a0 04 75 	rcall	8000f674 <_fstat_r>
8000ed8e:	c0 f4       	brge	8000edac <__smakebuf_r+0x3c>
8000ed90:	8e 65       	ld.sh	r5,r7[0xc]
8000ed92:	0a 98       	mov	r8,r5
8000ed94:	ab b8       	sbr	r8,0xb
8000ed96:	e2 15 00 80 	andl	r5,0x80,COH
8000ed9a:	ae 68       	st.h	r7[0xc],r8
8000ed9c:	30 04       	mov	r4,0
8000ed9e:	e0 68 04 00 	mov	r8,1024
8000eda2:	f9 b5 01 40 	movne	r5,64
8000eda6:	f0 05 17 00 	moveq	r5,r8
8000edaa:	c1 c8       	rjmp	8000ede2 <__smakebuf_r+0x72>
8000edac:	40 18       	lddsp	r8,sp[0x4]
8000edae:	e2 18 f0 00 	andl	r8,0xf000,COH
8000edb2:	e0 48 20 00 	cp.w	r8,8192
8000edb6:	5f 04       	sreq	r4
8000edb8:	e0 48 80 00 	cp.w	r8,32768
8000edbc:	c0 e1       	brne	8000edd8 <__smakebuf_r+0x68>
8000edbe:	6e b9       	ld.w	r9,r7[0x2c]
8000edc0:	fe c8 f9 1c 	sub	r8,pc,-1764
8000edc4:	10 39       	cp.w	r9,r8
8000edc6:	c0 91       	brne	8000edd8 <__smakebuf_r+0x68>
8000edc8:	8e 68       	ld.sh	r8,r7[0xc]
8000edca:	e0 65 04 00 	mov	r5,1024
8000edce:	ab a8       	sbr	r8,0xa
8000edd0:	ef 45 00 50 	st.w	r7[80],r5
8000edd4:	ae 68       	st.h	r7[0xc],r8
8000edd6:	c0 68       	rjmp	8000ede2 <__smakebuf_r+0x72>
8000edd8:	8e 68       	ld.sh	r8,r7[0xc]
8000edda:	e0 65 04 00 	mov	r5,1024
8000edde:	ab b8       	sbr	r8,0xb
8000ede0:	ae 68       	st.h	r7[0xc],r8
8000ede2:	0a 9b       	mov	r11,r5
8000ede4:	0c 9c       	mov	r12,r6
8000ede6:	fe b0 df 17 	rcall	8000ac14 <_malloc_r>
8000edea:	8e 68       	ld.sh	r8,r7[0xc]
8000edec:	c0 d1       	brne	8000ee06 <__smakebuf_r+0x96>
8000edee:	ed b8 00 09 	bld	r8,0x9
8000edf2:	c1 b0       	breq	8000ee28 <__smakebuf_r+0xb8>
8000edf4:	a1 b8       	sbr	r8,0x1
8000edf6:	ae 68       	st.h	r7[0xc],r8
8000edf8:	ee c8 ff b9 	sub	r8,r7,-71
8000edfc:	8f 48       	st.w	r7[0x10],r8
8000edfe:	8f 08       	st.w	r7[0x0],r8
8000ee00:	30 18       	mov	r8,1
8000ee02:	8f 58       	st.w	r7[0x14],r8
8000ee04:	c1 28       	rjmp	8000ee28 <__smakebuf_r+0xb8>
8000ee06:	a7 b8       	sbr	r8,0x7
8000ee08:	8f 4c       	st.w	r7[0x10],r12
8000ee0a:	ae 68       	st.h	r7[0xc],r8
8000ee0c:	8f 55       	st.w	r7[0x14],r5
8000ee0e:	fe c8 06 e6 	sub	r8,pc,1766
8000ee12:	8f 0c       	st.w	r7[0x0],r12
8000ee14:	8d a8       	st.w	r6[0x28],r8
8000ee16:	58 04       	cp.w	r4,0
8000ee18:	c0 80       	breq	8000ee28 <__smakebuf_r+0xb8>
8000ee1a:	8e 7c       	ld.sh	r12,r7[0xe]
8000ee1c:	fe b0 e3 94 	rcall	8000b544 <isatty>
8000ee20:	c0 40       	breq	8000ee28 <__smakebuf_r+0xb8>
8000ee22:	8e 68       	ld.sh	r8,r7[0xc]
8000ee24:	a1 a8       	sbr	r8,0x0
8000ee26:	ae 68       	st.h	r7[0xc],r8
8000ee28:	2f 1d       	sub	sp,-60
8000ee2a:	d8 22       	popm	r4-r7,pc

8000ee2c <memchr>:
8000ee2c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000ee30:	c0 68       	rjmp	8000ee3c <memchr+0x10>
8000ee32:	20 1a       	sub	r10,1
8000ee34:	19 88       	ld.ub	r8,r12[0x0]
8000ee36:	16 38       	cp.w	r8,r11
8000ee38:	5e 0c       	reteq	r12
8000ee3a:	2f fc       	sub	r12,-1
8000ee3c:	58 0a       	cp.w	r10,0
8000ee3e:	cf a1       	brne	8000ee32 <memchr+0x6>
8000ee40:	5e fa       	retal	r10

8000ee42 <memmove>:
8000ee42:	d4 01       	pushm	lr
8000ee44:	18 3b       	cp.w	r11,r12
8000ee46:	c1 92       	brcc	8000ee78 <memmove+0x36>
8000ee48:	f6 0a 00 09 	add	r9,r11,r10
8000ee4c:	12 3c       	cp.w	r12,r9
8000ee4e:	c1 52       	brcc	8000ee78 <memmove+0x36>
8000ee50:	f8 0a 00 0b 	add	r11,r12,r10
8000ee54:	30 08       	mov	r8,0
8000ee56:	c0 68       	rjmp	8000ee62 <memmove+0x20>
8000ee58:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000ee5c:	20 1a       	sub	r10,1
8000ee5e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000ee62:	20 18       	sub	r8,1
8000ee64:	58 0a       	cp.w	r10,0
8000ee66:	cf 91       	brne	8000ee58 <memmove+0x16>
8000ee68:	d8 02       	popm	pc
8000ee6a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000ee6e:	20 1a       	sub	r10,1
8000ee70:	f8 08 0b 09 	st.b	r12[r8],r9
8000ee74:	2f f8       	sub	r8,-1
8000ee76:	c0 28       	rjmp	8000ee7a <memmove+0x38>
8000ee78:	30 08       	mov	r8,0
8000ee7a:	58 0a       	cp.w	r10,0
8000ee7c:	cf 71       	brne	8000ee6a <memmove+0x28>
8000ee7e:	d8 02       	popm	pc

8000ee80 <__hi0bits>:
8000ee80:	18 98       	mov	r8,r12
8000ee82:	e0 1c 00 00 	andl	r12,0x0
8000ee86:	f0 09 15 10 	lsl	r9,r8,0x10
8000ee8a:	58 0c       	cp.w	r12,0
8000ee8c:	f2 08 17 00 	moveq	r8,r9
8000ee90:	f9 bc 00 10 	moveq	r12,16
8000ee94:	f9 bc 01 00 	movne	r12,0
8000ee98:	10 9a       	mov	r10,r8
8000ee9a:	f0 09 15 08 	lsl	r9,r8,0x8
8000ee9e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000eea2:	f7 bc 00 f8 	subeq	r12,-8
8000eea6:	f2 08 17 00 	moveq	r8,r9
8000eeaa:	10 9a       	mov	r10,r8
8000eeac:	f0 09 15 04 	lsl	r9,r8,0x4
8000eeb0:	e6 1a f0 00 	andh	r10,0xf000,COH
8000eeb4:	f7 bc 00 fc 	subeq	r12,-4
8000eeb8:	f2 08 17 00 	moveq	r8,r9
8000eebc:	10 9a       	mov	r10,r8
8000eebe:	f0 09 15 02 	lsl	r9,r8,0x2
8000eec2:	e6 1a c0 00 	andh	r10,0xc000,COH
8000eec6:	f7 bc 00 fe 	subeq	r12,-2
8000eeca:	f2 08 17 00 	moveq	r8,r9
8000eece:	58 08       	cp.w	r8,0
8000eed0:	5e 5c       	retlt	r12
8000eed2:	ed b8 00 1e 	bld	r8,0x1e
8000eed6:	f9 bc 01 20 	movne	r12,32
8000eeda:	f7 bc 00 ff 	subeq	r12,-1
8000eede:	5e fc       	retal	r12

8000eee0 <__lo0bits>:
8000eee0:	18 99       	mov	r9,r12
8000eee2:	78 08       	ld.w	r8,r12[0x0]
8000eee4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000eee8:	c1 50       	breq	8000ef12 <__lo0bits+0x32>
8000eeea:	ed b8 00 00 	bld	r8,0x0
8000eeee:	c0 21       	brne	8000eef2 <__lo0bits+0x12>
8000eef0:	5e fd       	retal	0
8000eef2:	10 9b       	mov	r11,r8
8000eef4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000eef8:	e2 1b 00 02 	andl	r11,0x2,COH
8000eefc:	a3 88       	lsr	r8,0x2
8000eefe:	58 0b       	cp.w	r11,0
8000ef00:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000ef04:	f9 bc 01 01 	movne	r12,1
8000ef08:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000ef0c:	f9 bc 00 02 	moveq	r12,2
8000ef10:	5e fc       	retal	r12
8000ef12:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000ef16:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ef1a:	58 0a       	cp.w	r10,0
8000ef1c:	f6 08 17 00 	moveq	r8,r11
8000ef20:	f9 bc 00 10 	moveq	r12,16
8000ef24:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000ef28:	f0 0a 16 08 	lsr	r10,r8,0x8
8000ef2c:	58 0b       	cp.w	r11,0
8000ef2e:	f7 bc 00 f8 	subeq	r12,-8
8000ef32:	f4 08 17 00 	moveq	r8,r10
8000ef36:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000ef3a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000ef3e:	58 0b       	cp.w	r11,0
8000ef40:	f7 bc 00 fc 	subeq	r12,-4
8000ef44:	f4 08 17 00 	moveq	r8,r10
8000ef48:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000ef4c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000ef50:	58 0b       	cp.w	r11,0
8000ef52:	f7 bc 00 fe 	subeq	r12,-2
8000ef56:	f4 08 17 00 	moveq	r8,r10
8000ef5a:	ed b8 00 00 	bld	r8,0x0
8000ef5e:	c0 60       	breq	8000ef6a <__lo0bits+0x8a>
8000ef60:	a1 98       	lsr	r8,0x1
8000ef62:	c0 31       	brne	8000ef68 <__lo0bits+0x88>
8000ef64:	32 0c       	mov	r12,32
8000ef66:	5e fc       	retal	r12
8000ef68:	2f fc       	sub	r12,-1
8000ef6a:	93 08       	st.w	r9[0x0],r8
8000ef6c:	5e fc       	retal	r12

8000ef6e <__mcmp>:
8000ef6e:	d4 01       	pushm	lr
8000ef70:	18 98       	mov	r8,r12
8000ef72:	76 49       	ld.w	r9,r11[0x10]
8000ef74:	78 4c       	ld.w	r12,r12[0x10]
8000ef76:	12 1c       	sub	r12,r9
8000ef78:	c1 31       	brne	8000ef9e <__mcmp+0x30>
8000ef7a:	2f b9       	sub	r9,-5
8000ef7c:	a3 69       	lsl	r9,0x2
8000ef7e:	12 0b       	add	r11,r9
8000ef80:	f0 09 00 09 	add	r9,r8,r9
8000ef84:	2e c8       	sub	r8,-20
8000ef86:	13 4e       	ld.w	lr,--r9
8000ef88:	17 4a       	ld.w	r10,--r11
8000ef8a:	14 3e       	cp.w	lr,r10
8000ef8c:	c0 60       	breq	8000ef98 <__mcmp+0x2a>
8000ef8e:	f9 bc 03 ff 	movlo	r12,-1
8000ef92:	f9 bc 02 01 	movhs	r12,1
8000ef96:	d8 02       	popm	pc
8000ef98:	10 39       	cp.w	r9,r8
8000ef9a:	fe 9b ff f6 	brhi	8000ef86 <__mcmp+0x18>
8000ef9e:	d8 02       	popm	pc

8000efa0 <_Bfree>:
8000efa0:	d4 21       	pushm	r4-r7,lr
8000efa2:	18 97       	mov	r7,r12
8000efa4:	16 95       	mov	r5,r11
8000efa6:	78 96       	ld.w	r6,r12[0x24]
8000efa8:	58 06       	cp.w	r6,0
8000efaa:	c0 91       	brne	8000efbc <_Bfree+0x1c>
8000efac:	31 0c       	mov	r12,16
8000efae:	fe b0 de 2b 	rcall	8000ac04 <malloc>
8000efb2:	99 36       	st.w	r12[0xc],r6
8000efb4:	8f 9c       	st.w	r7[0x24],r12
8000efb6:	99 16       	st.w	r12[0x4],r6
8000efb8:	99 26       	st.w	r12[0x8],r6
8000efba:	99 06       	st.w	r12[0x0],r6
8000efbc:	58 05       	cp.w	r5,0
8000efbe:	c0 90       	breq	8000efd0 <_Bfree+0x30>
8000efc0:	6a 19       	ld.w	r9,r5[0x4]
8000efc2:	6e 98       	ld.w	r8,r7[0x24]
8000efc4:	70 38       	ld.w	r8,r8[0xc]
8000efc6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000efca:	8b 0a       	st.w	r5[0x0],r10
8000efcc:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000efd0:	d8 22       	popm	r4-r7,pc
8000efd2:	d7 03       	nop

8000efd4 <_Balloc>:
8000efd4:	d4 21       	pushm	r4-r7,lr
8000efd6:	18 97       	mov	r7,r12
8000efd8:	16 96       	mov	r6,r11
8000efda:	78 95       	ld.w	r5,r12[0x24]
8000efdc:	58 05       	cp.w	r5,0
8000efde:	c0 91       	brne	8000eff0 <_Balloc+0x1c>
8000efe0:	31 0c       	mov	r12,16
8000efe2:	fe b0 de 11 	rcall	8000ac04 <malloc>
8000efe6:	99 35       	st.w	r12[0xc],r5
8000efe8:	8f 9c       	st.w	r7[0x24],r12
8000efea:	99 15       	st.w	r12[0x4],r5
8000efec:	99 25       	st.w	r12[0x8],r5
8000efee:	99 05       	st.w	r12[0x0],r5
8000eff0:	6e 95       	ld.w	r5,r7[0x24]
8000eff2:	6a 38       	ld.w	r8,r5[0xc]
8000eff4:	58 08       	cp.w	r8,0
8000eff6:	c0 b1       	brne	8000f00c <_Balloc+0x38>
8000eff8:	31 0a       	mov	r10,16
8000effa:	30 4b       	mov	r11,4
8000effc:	0e 9c       	mov	r12,r7
8000effe:	e0 a0 02 9b 	rcall	8000f534 <_calloc_r>
8000f002:	8b 3c       	st.w	r5[0xc],r12
8000f004:	6e 98       	ld.w	r8,r7[0x24]
8000f006:	70 3c       	ld.w	r12,r8[0xc]
8000f008:	58 0c       	cp.w	r12,0
8000f00a:	c1 b0       	breq	8000f040 <_Balloc+0x6c>
8000f00c:	6e 98       	ld.w	r8,r7[0x24]
8000f00e:	70 38       	ld.w	r8,r8[0xc]
8000f010:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000f014:	70 0c       	ld.w	r12,r8[0x0]
8000f016:	58 0c       	cp.w	r12,0
8000f018:	c0 40       	breq	8000f020 <_Balloc+0x4c>
8000f01a:	78 09       	ld.w	r9,r12[0x0]
8000f01c:	91 09       	st.w	r8[0x0],r9
8000f01e:	c0 e8       	rjmp	8000f03a <_Balloc+0x66>
8000f020:	0e 9c       	mov	r12,r7
8000f022:	30 17       	mov	r7,1
8000f024:	0e 9b       	mov	r11,r7
8000f026:	ee 06 09 47 	lsl	r7,r7,r6
8000f02a:	ee ca ff fb 	sub	r10,r7,-5
8000f02e:	a3 6a       	lsl	r10,0x2
8000f030:	e0 a0 02 82 	rcall	8000f534 <_calloc_r>
8000f034:	c0 60       	breq	8000f040 <_Balloc+0x6c>
8000f036:	99 16       	st.w	r12[0x4],r6
8000f038:	99 27       	st.w	r12[0x8],r7
8000f03a:	30 08       	mov	r8,0
8000f03c:	99 38       	st.w	r12[0xc],r8
8000f03e:	99 48       	st.w	r12[0x10],r8
8000f040:	d8 22       	popm	r4-r7,pc
8000f042:	d7 03       	nop

8000f044 <__d2b>:
8000f044:	d4 31       	pushm	r0-r7,lr
8000f046:	20 2d       	sub	sp,8
8000f048:	16 93       	mov	r3,r11
8000f04a:	12 96       	mov	r6,r9
8000f04c:	10 95       	mov	r5,r8
8000f04e:	14 92       	mov	r2,r10
8000f050:	30 1b       	mov	r11,1
8000f052:	cc 1f       	rcall	8000efd4 <_Balloc>
8000f054:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000f058:	50 09       	stdsp	sp[0x0],r9
8000f05a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000f05e:	b5 a9       	sbr	r9,0x14
8000f060:	f0 01 16 14 	lsr	r1,r8,0x14
8000f064:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000f068:	18 94       	mov	r4,r12
8000f06a:	58 02       	cp.w	r2,0
8000f06c:	c1 d0       	breq	8000f0a6 <__d2b+0x62>
8000f06e:	fa cc ff f8 	sub	r12,sp,-8
8000f072:	18 d2       	st.w	--r12,r2
8000f074:	c3 6f       	rcall	8000eee0 <__lo0bits>
8000f076:	40 18       	lddsp	r8,sp[0x4]
8000f078:	c0 d0       	breq	8000f092 <__d2b+0x4e>
8000f07a:	40 09       	lddsp	r9,sp[0x0]
8000f07c:	f8 0a 11 20 	rsub	r10,r12,32
8000f080:	f2 0a 09 4a 	lsl	r10,r9,r10
8000f084:	f5 e8 10 08 	or	r8,r10,r8
8000f088:	89 58       	st.w	r4[0x14],r8
8000f08a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000f08e:	50 09       	stdsp	sp[0x0],r9
8000f090:	c0 28       	rjmp	8000f094 <__d2b+0x50>
8000f092:	89 58       	st.w	r4[0x14],r8
8000f094:	40 08       	lddsp	r8,sp[0x0]
8000f096:	58 08       	cp.w	r8,0
8000f098:	f9 b3 01 02 	movne	r3,2
8000f09c:	f9 b3 00 01 	moveq	r3,1
8000f0a0:	89 68       	st.w	r4[0x18],r8
8000f0a2:	89 43       	st.w	r4[0x10],r3
8000f0a4:	c0 88       	rjmp	8000f0b4 <__d2b+0x70>
8000f0a6:	1a 9c       	mov	r12,sp
8000f0a8:	c1 cf       	rcall	8000eee0 <__lo0bits>
8000f0aa:	30 13       	mov	r3,1
8000f0ac:	40 08       	lddsp	r8,sp[0x0]
8000f0ae:	2e 0c       	sub	r12,-32
8000f0b0:	89 43       	st.w	r4[0x10],r3
8000f0b2:	89 58       	st.w	r4[0x14],r8
8000f0b4:	58 01       	cp.w	r1,0
8000f0b6:	c0 90       	breq	8000f0c8 <__d2b+0x84>
8000f0b8:	e2 c1 04 33 	sub	r1,r1,1075
8000f0bc:	18 01       	add	r1,r12
8000f0be:	8d 01       	st.w	r6[0x0],r1
8000f0c0:	f8 0c 11 35 	rsub	r12,r12,53
8000f0c4:	8b 0c       	st.w	r5[0x0],r12
8000f0c6:	c0 c8       	rjmp	8000f0de <__d2b+0x9a>
8000f0c8:	e6 c8 ff fc 	sub	r8,r3,-4
8000f0cc:	f8 cc 04 32 	sub	r12,r12,1074
8000f0d0:	a5 73       	lsl	r3,0x5
8000f0d2:	8d 0c       	st.w	r6[0x0],r12
8000f0d4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000f0d8:	cd 4e       	rcall	8000ee80 <__hi0bits>
8000f0da:	18 13       	sub	r3,r12
8000f0dc:	8b 03       	st.w	r5[0x0],r3
8000f0de:	08 9c       	mov	r12,r4
8000f0e0:	2f ed       	sub	sp,-8
8000f0e2:	d8 32       	popm	r0-r7,pc

8000f0e4 <__mdiff>:
8000f0e4:	d4 31       	pushm	r0-r7,lr
8000f0e6:	74 48       	ld.w	r8,r10[0x10]
8000f0e8:	76 45       	ld.w	r5,r11[0x10]
8000f0ea:	16 97       	mov	r7,r11
8000f0ec:	14 96       	mov	r6,r10
8000f0ee:	10 15       	sub	r5,r8
8000f0f0:	c1 31       	brne	8000f116 <__mdiff+0x32>
8000f0f2:	2f b8       	sub	r8,-5
8000f0f4:	ee ce ff ec 	sub	lr,r7,-20
8000f0f8:	a3 68       	lsl	r8,0x2
8000f0fa:	f4 08 00 0b 	add	r11,r10,r8
8000f0fe:	ee 08 00 08 	add	r8,r7,r8
8000f102:	11 4a       	ld.w	r10,--r8
8000f104:	17 49       	ld.w	r9,--r11
8000f106:	12 3a       	cp.w	r10,r9
8000f108:	c0 30       	breq	8000f10e <__mdiff+0x2a>
8000f10a:	c0 e2       	brcc	8000f126 <__mdiff+0x42>
8000f10c:	c0 78       	rjmp	8000f11a <__mdiff+0x36>
8000f10e:	1c 38       	cp.w	r8,lr
8000f110:	fe 9b ff f9 	brhi	8000f102 <__mdiff+0x1e>
8000f114:	c4 98       	rjmp	8000f1a6 <__mdiff+0xc2>
8000f116:	58 05       	cp.w	r5,0
8000f118:	c0 64       	brge	8000f124 <__mdiff+0x40>
8000f11a:	0e 98       	mov	r8,r7
8000f11c:	30 15       	mov	r5,1
8000f11e:	0c 97       	mov	r7,r6
8000f120:	10 96       	mov	r6,r8
8000f122:	c0 28       	rjmp	8000f126 <__mdiff+0x42>
8000f124:	30 05       	mov	r5,0
8000f126:	6e 1b       	ld.w	r11,r7[0x4]
8000f128:	c5 6f       	rcall	8000efd4 <_Balloc>
8000f12a:	6e 49       	ld.w	r9,r7[0x10]
8000f12c:	6c 44       	ld.w	r4,r6[0x10]
8000f12e:	99 35       	st.w	r12[0xc],r5
8000f130:	2f b4       	sub	r4,-5
8000f132:	f2 c5 ff fb 	sub	r5,r9,-5
8000f136:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000f13a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000f13e:	2e c6       	sub	r6,-20
8000f140:	2e c7       	sub	r7,-20
8000f142:	f8 c8 ff ec 	sub	r8,r12,-20
8000f146:	30 0a       	mov	r10,0
8000f148:	0f 0e       	ld.w	lr,r7++
8000f14a:	0d 0b       	ld.w	r11,r6++
8000f14c:	fc 02 16 10 	lsr	r2,lr,0x10
8000f150:	f6 03 16 10 	lsr	r3,r11,0x10
8000f154:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000f158:	e4 03 01 03 	sub	r3,r2,r3
8000f15c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000f160:	fc 0b 01 0b 	sub	r11,lr,r11
8000f164:	f6 0a 00 0a 	add	r10,r11,r10
8000f168:	b0 1a       	st.h	r8[0x2],r10
8000f16a:	b1 4a       	asr	r10,0x10
8000f16c:	e6 0a 00 0a 	add	r10,r3,r10
8000f170:	b0 0a       	st.h	r8[0x0],r10
8000f172:	2f c8       	sub	r8,-4
8000f174:	b1 4a       	asr	r10,0x10
8000f176:	08 36       	cp.w	r6,r4
8000f178:	ce 83       	brcs	8000f148 <__mdiff+0x64>
8000f17a:	c0 d8       	rjmp	8000f194 <__mdiff+0xb0>
8000f17c:	0f 0b       	ld.w	r11,r7++
8000f17e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000f182:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000f186:	16 0a       	add	r10,r11
8000f188:	b0 1a       	st.h	r8[0x2],r10
8000f18a:	b1 4a       	asr	r10,0x10
8000f18c:	1c 0a       	add	r10,lr
8000f18e:	b0 0a       	st.h	r8[0x0],r10
8000f190:	2f c8       	sub	r8,-4
8000f192:	b1 4a       	asr	r10,0x10
8000f194:	0a 37       	cp.w	r7,r5
8000f196:	cf 33       	brcs	8000f17c <__mdiff+0x98>
8000f198:	c0 28       	rjmp	8000f19c <__mdiff+0xb8>
8000f19a:	20 19       	sub	r9,1
8000f19c:	11 4a       	ld.w	r10,--r8
8000f19e:	58 0a       	cp.w	r10,0
8000f1a0:	cf d0       	breq	8000f19a <__mdiff+0xb6>
8000f1a2:	99 49       	st.w	r12[0x10],r9
8000f1a4:	d8 32       	popm	r0-r7,pc
8000f1a6:	30 0b       	mov	r11,0
8000f1a8:	c1 6f       	rcall	8000efd4 <_Balloc>
8000f1aa:	30 18       	mov	r8,1
8000f1ac:	99 48       	st.w	r12[0x10],r8
8000f1ae:	30 08       	mov	r8,0
8000f1b0:	99 58       	st.w	r12[0x14],r8
8000f1b2:	d8 32       	popm	r0-r7,pc

8000f1b4 <__lshift>:
8000f1b4:	d4 31       	pushm	r0-r7,lr
8000f1b6:	16 97       	mov	r7,r11
8000f1b8:	76 46       	ld.w	r6,r11[0x10]
8000f1ba:	f4 02 14 05 	asr	r2,r10,0x5
8000f1be:	2f f6       	sub	r6,-1
8000f1c0:	14 93       	mov	r3,r10
8000f1c2:	18 94       	mov	r4,r12
8000f1c4:	04 06       	add	r6,r2
8000f1c6:	76 1b       	ld.w	r11,r11[0x4]
8000f1c8:	6e 28       	ld.w	r8,r7[0x8]
8000f1ca:	c0 38       	rjmp	8000f1d0 <__lshift+0x1c>
8000f1cc:	2f fb       	sub	r11,-1
8000f1ce:	a1 78       	lsl	r8,0x1
8000f1d0:	10 36       	cp.w	r6,r8
8000f1d2:	fe 99 ff fd 	brgt	8000f1cc <__lshift+0x18>
8000f1d6:	08 9c       	mov	r12,r4
8000f1d8:	cf ee       	rcall	8000efd4 <_Balloc>
8000f1da:	30 09       	mov	r9,0
8000f1dc:	18 95       	mov	r5,r12
8000f1de:	f8 c8 ff ec 	sub	r8,r12,-20
8000f1e2:	12 9a       	mov	r10,r9
8000f1e4:	c0 38       	rjmp	8000f1ea <__lshift+0x36>
8000f1e6:	10 aa       	st.w	r8++,r10
8000f1e8:	2f f9       	sub	r9,-1
8000f1ea:	04 39       	cp.w	r9,r2
8000f1ec:	cf d5       	brlt	8000f1e6 <__lshift+0x32>
8000f1ee:	6e 4b       	ld.w	r11,r7[0x10]
8000f1f0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000f1f4:	2f bb       	sub	r11,-5
8000f1f6:	ee c9 ff ec 	sub	r9,r7,-20
8000f1fa:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000f1fe:	58 03       	cp.w	r3,0
8000f200:	c1 30       	breq	8000f226 <__lshift+0x72>
8000f202:	e6 0c 11 20 	rsub	r12,r3,32
8000f206:	30 0a       	mov	r10,0
8000f208:	72 02       	ld.w	r2,r9[0x0]
8000f20a:	e4 03 09 42 	lsl	r2,r2,r3
8000f20e:	04 4a       	or	r10,r2
8000f210:	10 aa       	st.w	r8++,r10
8000f212:	13 0a       	ld.w	r10,r9++
8000f214:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f218:	16 39       	cp.w	r9,r11
8000f21a:	cf 73       	brcs	8000f208 <__lshift+0x54>
8000f21c:	91 0a       	st.w	r8[0x0],r10
8000f21e:	58 0a       	cp.w	r10,0
8000f220:	c0 70       	breq	8000f22e <__lshift+0x7a>
8000f222:	2f f6       	sub	r6,-1
8000f224:	c0 58       	rjmp	8000f22e <__lshift+0x7a>
8000f226:	13 0a       	ld.w	r10,r9++
8000f228:	10 aa       	st.w	r8++,r10
8000f22a:	16 39       	cp.w	r9,r11
8000f22c:	cf d3       	brcs	8000f226 <__lshift+0x72>
8000f22e:	08 9c       	mov	r12,r4
8000f230:	20 16       	sub	r6,1
8000f232:	0e 9b       	mov	r11,r7
8000f234:	8b 46       	st.w	r5[0x10],r6
8000f236:	cb 5e       	rcall	8000efa0 <_Bfree>
8000f238:	0a 9c       	mov	r12,r5
8000f23a:	d8 32       	popm	r0-r7,pc

8000f23c <__multiply>:
8000f23c:	d4 31       	pushm	r0-r7,lr
8000f23e:	20 2d       	sub	sp,8
8000f240:	76 49       	ld.w	r9,r11[0x10]
8000f242:	74 48       	ld.w	r8,r10[0x10]
8000f244:	16 96       	mov	r6,r11
8000f246:	14 95       	mov	r5,r10
8000f248:	10 39       	cp.w	r9,r8
8000f24a:	ec 08 17 50 	movlt	r8,r6
8000f24e:	ea 06 17 50 	movlt	r6,r5
8000f252:	f0 05 17 50 	movlt	r5,r8
8000f256:	6c 28       	ld.w	r8,r6[0x8]
8000f258:	76 43       	ld.w	r3,r11[0x10]
8000f25a:	74 42       	ld.w	r2,r10[0x10]
8000f25c:	76 1b       	ld.w	r11,r11[0x4]
8000f25e:	e4 03 00 07 	add	r7,r2,r3
8000f262:	10 37       	cp.w	r7,r8
8000f264:	f7 bb 09 ff 	subgt	r11,-1
8000f268:	cb 6e       	rcall	8000efd4 <_Balloc>
8000f26a:	ee c4 ff fb 	sub	r4,r7,-5
8000f26e:	f8 c9 ff ec 	sub	r9,r12,-20
8000f272:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000f276:	30 0a       	mov	r10,0
8000f278:	12 98       	mov	r8,r9
8000f27a:	c0 28       	rjmp	8000f27e <__multiply+0x42>
8000f27c:	10 aa       	st.w	r8++,r10
8000f27e:	08 38       	cp.w	r8,r4
8000f280:	cf e3       	brcs	8000f27c <__multiply+0x40>
8000f282:	2f b3       	sub	r3,-5
8000f284:	2f b2       	sub	r2,-5
8000f286:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000f28a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000f28e:	ec cb ff ec 	sub	r11,r6,-20
8000f292:	50 12       	stdsp	sp[0x4],r2
8000f294:	ea ca ff ec 	sub	r10,r5,-20
8000f298:	c4 48       	rjmp	8000f320 <__multiply+0xe4>
8000f29a:	94 95       	ld.uh	r5,r10[0x2]
8000f29c:	58 05       	cp.w	r5,0
8000f29e:	c2 00       	breq	8000f2de <__multiply+0xa2>
8000f2a0:	12 98       	mov	r8,r9
8000f2a2:	16 96       	mov	r6,r11
8000f2a4:	30 0e       	mov	lr,0
8000f2a6:	50 09       	stdsp	sp[0x0],r9
8000f2a8:	0d 02       	ld.w	r2,r6++
8000f2aa:	e4 00 16 10 	lsr	r0,r2,0x10
8000f2ae:	70 01       	ld.w	r1,r8[0x0]
8000f2b0:	70 09       	ld.w	r9,r8[0x0]
8000f2b2:	b1 81       	lsr	r1,0x10
8000f2b4:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000f2b8:	e0 05 03 41 	mac	r1,r0,r5
8000f2bc:	ab 32       	mul	r2,r5
8000f2be:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000f2c2:	00 02       	add	r2,r0
8000f2c4:	e4 0e 00 0e 	add	lr,r2,lr
8000f2c8:	b0 1e       	st.h	r8[0x2],lr
8000f2ca:	b1 8e       	lsr	lr,0x10
8000f2cc:	1c 01       	add	r1,lr
8000f2ce:	b0 01       	st.h	r8[0x0],r1
8000f2d0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000f2d4:	2f c8       	sub	r8,-4
8000f2d6:	06 36       	cp.w	r6,r3
8000f2d8:	ce 83       	brcs	8000f2a8 <__multiply+0x6c>
8000f2da:	40 09       	lddsp	r9,sp[0x0]
8000f2dc:	91 0e       	st.w	r8[0x0],lr
8000f2de:	94 86       	ld.uh	r6,r10[0x0]
8000f2e0:	58 06       	cp.w	r6,0
8000f2e2:	c1 d0       	breq	8000f31c <__multiply+0xe0>
8000f2e4:	72 02       	ld.w	r2,r9[0x0]
8000f2e6:	12 98       	mov	r8,r9
8000f2e8:	16 9e       	mov	lr,r11
8000f2ea:	30 05       	mov	r5,0
8000f2ec:	b0 12       	st.h	r8[0x2],r2
8000f2ee:	1d 01       	ld.w	r1,lr++
8000f2f0:	90 82       	ld.uh	r2,r8[0x0]
8000f2f2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000f2f6:	ad 30       	mul	r0,r6
8000f2f8:	e0 02 00 02 	add	r2,r0,r2
8000f2fc:	e4 05 00 05 	add	r5,r2,r5
8000f300:	b0 05       	st.h	r8[0x0],r5
8000f302:	b1 85       	lsr	r5,0x10
8000f304:	b1 81       	lsr	r1,0x10
8000f306:	2f c8       	sub	r8,-4
8000f308:	ad 31       	mul	r1,r6
8000f30a:	90 92       	ld.uh	r2,r8[0x2]
8000f30c:	e2 02 00 02 	add	r2,r1,r2
8000f310:	0a 02       	add	r2,r5
8000f312:	e4 05 16 10 	lsr	r5,r2,0x10
8000f316:	06 3e       	cp.w	lr,r3
8000f318:	ce a3       	brcs	8000f2ec <__multiply+0xb0>
8000f31a:	91 02       	st.w	r8[0x0],r2
8000f31c:	2f ca       	sub	r10,-4
8000f31e:	2f c9       	sub	r9,-4
8000f320:	40 18       	lddsp	r8,sp[0x4]
8000f322:	10 3a       	cp.w	r10,r8
8000f324:	cb b3       	brcs	8000f29a <__multiply+0x5e>
8000f326:	c0 28       	rjmp	8000f32a <__multiply+0xee>
8000f328:	20 17       	sub	r7,1
8000f32a:	58 07       	cp.w	r7,0
8000f32c:	e0 8a 00 05 	brle	8000f336 <__multiply+0xfa>
8000f330:	09 48       	ld.w	r8,--r4
8000f332:	58 08       	cp.w	r8,0
8000f334:	cf a0       	breq	8000f328 <__multiply+0xec>
8000f336:	99 47       	st.w	r12[0x10],r7
8000f338:	2f ed       	sub	sp,-8
8000f33a:	d8 32       	popm	r0-r7,pc

8000f33c <__i2b>:
8000f33c:	d4 21       	pushm	r4-r7,lr
8000f33e:	16 97       	mov	r7,r11
8000f340:	30 1b       	mov	r11,1
8000f342:	c4 9e       	rcall	8000efd4 <_Balloc>
8000f344:	30 19       	mov	r9,1
8000f346:	99 57       	st.w	r12[0x14],r7
8000f348:	99 49       	st.w	r12[0x10],r9
8000f34a:	d8 22       	popm	r4-r7,pc

8000f34c <__multadd>:
8000f34c:	d4 31       	pushm	r0-r7,lr
8000f34e:	30 08       	mov	r8,0
8000f350:	12 95       	mov	r5,r9
8000f352:	16 97       	mov	r7,r11
8000f354:	18 96       	mov	r6,r12
8000f356:	76 44       	ld.w	r4,r11[0x10]
8000f358:	f6 c9 ff ec 	sub	r9,r11,-20
8000f35c:	72 0b       	ld.w	r11,r9[0x0]
8000f35e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000f362:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000f366:	f4 0c 02 4c 	mul	r12,r10,r12
8000f36a:	f4 0b 03 45 	mac	r5,r10,r11
8000f36e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000f372:	b1 85       	lsr	r5,0x10
8000f374:	18 05       	add	r5,r12
8000f376:	ea 0c 15 10 	lsl	r12,r5,0x10
8000f37a:	f8 0b 00 0b 	add	r11,r12,r11
8000f37e:	12 ab       	st.w	r9++,r11
8000f380:	2f f8       	sub	r8,-1
8000f382:	b1 85       	lsr	r5,0x10
8000f384:	08 38       	cp.w	r8,r4
8000f386:	ce b5       	brlt	8000f35c <__multadd+0x10>
8000f388:	58 05       	cp.w	r5,0
8000f38a:	c1 c0       	breq	8000f3c2 <__multadd+0x76>
8000f38c:	6e 28       	ld.w	r8,r7[0x8]
8000f38e:	10 34       	cp.w	r4,r8
8000f390:	c1 35       	brlt	8000f3b6 <__multadd+0x6a>
8000f392:	6e 1b       	ld.w	r11,r7[0x4]
8000f394:	0c 9c       	mov	r12,r6
8000f396:	2f fb       	sub	r11,-1
8000f398:	c1 ee       	rcall	8000efd4 <_Balloc>
8000f39a:	6e 4a       	ld.w	r10,r7[0x10]
8000f39c:	ee cb ff f4 	sub	r11,r7,-12
8000f3a0:	18 93       	mov	r3,r12
8000f3a2:	2f ea       	sub	r10,-2
8000f3a4:	2f 4c       	sub	r12,-12
8000f3a6:	a3 6a       	lsl	r10,0x2
8000f3a8:	fe b0 de 65 	rcall	8000b072 <memcpy>
8000f3ac:	0e 9b       	mov	r11,r7
8000f3ae:	0c 9c       	mov	r12,r6
8000f3b0:	fe b0 fd f8 	rcall	8000efa0 <_Bfree>
8000f3b4:	06 97       	mov	r7,r3
8000f3b6:	e8 c8 ff ff 	sub	r8,r4,-1
8000f3ba:	2f b4       	sub	r4,-5
8000f3bc:	8f 48       	st.w	r7[0x10],r8
8000f3be:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000f3c2:	0e 9c       	mov	r12,r7
8000f3c4:	d8 32       	popm	r0-r7,pc
8000f3c6:	d7 03       	nop

8000f3c8 <__pow5mult>:
8000f3c8:	d4 31       	pushm	r0-r7,lr
8000f3ca:	14 96       	mov	r6,r10
8000f3cc:	18 97       	mov	r7,r12
8000f3ce:	16 94       	mov	r4,r11
8000f3d0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000f3d4:	c0 90       	breq	8000f3e6 <__pow5mult+0x1e>
8000f3d6:	20 18       	sub	r8,1
8000f3d8:	fe c9 e3 38 	sub	r9,pc,-7368
8000f3dc:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000f3e0:	30 09       	mov	r9,0
8000f3e2:	cb 5f       	rcall	8000f34c <__multadd>
8000f3e4:	18 94       	mov	r4,r12
8000f3e6:	a3 46       	asr	r6,0x2
8000f3e8:	c3 40       	breq	8000f450 <__pow5mult+0x88>
8000f3ea:	6e 95       	ld.w	r5,r7[0x24]
8000f3ec:	58 05       	cp.w	r5,0
8000f3ee:	c0 91       	brne	8000f400 <__pow5mult+0x38>
8000f3f0:	31 0c       	mov	r12,16
8000f3f2:	fe b0 dc 09 	rcall	8000ac04 <malloc>
8000f3f6:	99 35       	st.w	r12[0xc],r5
8000f3f8:	8f 9c       	st.w	r7[0x24],r12
8000f3fa:	99 15       	st.w	r12[0x4],r5
8000f3fc:	99 25       	st.w	r12[0x8],r5
8000f3fe:	99 05       	st.w	r12[0x0],r5
8000f400:	6e 93       	ld.w	r3,r7[0x24]
8000f402:	66 25       	ld.w	r5,r3[0x8]
8000f404:	58 05       	cp.w	r5,0
8000f406:	c0 c1       	brne	8000f41e <__pow5mult+0x56>
8000f408:	e0 6b 02 71 	mov	r11,625
8000f40c:	0e 9c       	mov	r12,r7
8000f40e:	c9 7f       	rcall	8000f33c <__i2b>
8000f410:	87 2c       	st.w	r3[0x8],r12
8000f412:	30 08       	mov	r8,0
8000f414:	18 95       	mov	r5,r12
8000f416:	99 08       	st.w	r12[0x0],r8
8000f418:	c0 38       	rjmp	8000f41e <__pow5mult+0x56>
8000f41a:	06 9c       	mov	r12,r3
8000f41c:	18 95       	mov	r5,r12
8000f41e:	ed b6 00 00 	bld	r6,0x0
8000f422:	c0 b1       	brne	8000f438 <__pow5mult+0x70>
8000f424:	08 9b       	mov	r11,r4
8000f426:	0a 9a       	mov	r10,r5
8000f428:	0e 9c       	mov	r12,r7
8000f42a:	c0 9f       	rcall	8000f23c <__multiply>
8000f42c:	08 9b       	mov	r11,r4
8000f42e:	18 93       	mov	r3,r12
8000f430:	0e 9c       	mov	r12,r7
8000f432:	06 94       	mov	r4,r3
8000f434:	fe b0 fd b6 	rcall	8000efa0 <_Bfree>
8000f438:	a1 56       	asr	r6,0x1
8000f43a:	c0 b0       	breq	8000f450 <__pow5mult+0x88>
8000f43c:	6a 03       	ld.w	r3,r5[0x0]
8000f43e:	58 03       	cp.w	r3,0
8000f440:	ce d1       	brne	8000f41a <__pow5mult+0x52>
8000f442:	0a 9a       	mov	r10,r5
8000f444:	0a 9b       	mov	r11,r5
8000f446:	0e 9c       	mov	r12,r7
8000f448:	cf ae       	rcall	8000f23c <__multiply>
8000f44a:	8b 0c       	st.w	r5[0x0],r12
8000f44c:	99 03       	st.w	r12[0x0],r3
8000f44e:	ce 7b       	rjmp	8000f41c <__pow5mult+0x54>
8000f450:	08 9c       	mov	r12,r4
8000f452:	d8 32       	popm	r0-r7,pc

8000f454 <__isinfd>:
8000f454:	14 98       	mov	r8,r10
8000f456:	fc 19 7f f0 	movh	r9,0x7ff0
8000f45a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000f45e:	f0 0b 11 00 	rsub	r11,r8,0
8000f462:	f7 e8 10 08 	or	r8,r11,r8
8000f466:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000f46a:	f2 08 01 08 	sub	r8,r9,r8
8000f46e:	f0 0c 11 00 	rsub	r12,r8,0
8000f472:	f9 e8 10 08 	or	r8,r12,r8
8000f476:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000f47a:	2f fc       	sub	r12,-1
8000f47c:	5e fc       	retal	r12

8000f47e <__isnand>:
8000f47e:	14 98       	mov	r8,r10
8000f480:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000f484:	f0 0c 11 00 	rsub	r12,r8,0
8000f488:	10 4c       	or	r12,r8
8000f48a:	fc 18 7f f0 	movh	r8,0x7ff0
8000f48e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000f492:	f0 0c 01 0c 	sub	r12,r8,r12
8000f496:	bf 9c       	lsr	r12,0x1f
8000f498:	5e fc       	retal	r12
8000f49a:	d7 03       	nop

8000f49c <__sclose>:
8000f49c:	d4 01       	pushm	lr
8000f49e:	96 7b       	ld.sh	r11,r11[0xe]
8000f4a0:	c7 6c       	rcall	8000f58c <_close_r>
8000f4a2:	d8 02       	popm	pc

8000f4a4 <__sseek>:
8000f4a4:	d4 21       	pushm	r4-r7,lr
8000f4a6:	16 97       	mov	r7,r11
8000f4a8:	96 7b       	ld.sh	r11,r11[0xe]
8000f4aa:	cf 7c       	rcall	8000f698 <_lseek_r>
8000f4ac:	8e 68       	ld.sh	r8,r7[0xc]
8000f4ae:	10 99       	mov	r9,r8
8000f4b0:	ad c8       	cbr	r8,0xc
8000f4b2:	ad a9       	sbr	r9,0xc
8000f4b4:	5b fc       	cp.w	r12,-1
8000f4b6:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000f4ba:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000f4be:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000f4c2:	d8 22       	popm	r4-r7,pc

8000f4c4 <__swrite>:
8000f4c4:	d4 21       	pushm	r4-r7,lr
8000f4c6:	96 68       	ld.sh	r8,r11[0xc]
8000f4c8:	16 97       	mov	r7,r11
8000f4ca:	14 95       	mov	r5,r10
8000f4cc:	12 94       	mov	r4,r9
8000f4ce:	e2 18 01 00 	andl	r8,0x100,COH
8000f4d2:	18 96       	mov	r6,r12
8000f4d4:	c0 50       	breq	8000f4de <__swrite+0x1a>
8000f4d6:	30 29       	mov	r9,2
8000f4d8:	30 0a       	mov	r10,0
8000f4da:	96 7b       	ld.sh	r11,r11[0xe]
8000f4dc:	cd ec       	rcall	8000f698 <_lseek_r>
8000f4de:	8e 68       	ld.sh	r8,r7[0xc]
8000f4e0:	ad c8       	cbr	r8,0xc
8000f4e2:	08 99       	mov	r9,r4
8000f4e4:	0a 9a       	mov	r10,r5
8000f4e6:	8e 7b       	ld.sh	r11,r7[0xe]
8000f4e8:	0c 9c       	mov	r12,r6
8000f4ea:	ae 68       	st.h	r7[0xc],r8
8000f4ec:	c1 0c       	rcall	8000f50c <_write_r>
8000f4ee:	d8 22       	popm	r4-r7,pc

8000f4f0 <__sread>:
8000f4f0:	d4 21       	pushm	r4-r7,lr
8000f4f2:	16 97       	mov	r7,r11
8000f4f4:	96 7b       	ld.sh	r11,r11[0xe]
8000f4f6:	ce 5c       	rcall	8000f6c0 <_read_r>
8000f4f8:	c0 65       	brlt	8000f504 <__sread+0x14>
8000f4fa:	6f 58       	ld.w	r8,r7[0x54]
8000f4fc:	18 08       	add	r8,r12
8000f4fe:	ef 48 00 54 	st.w	r7[84],r8
8000f502:	d8 22       	popm	r4-r7,pc
8000f504:	8e 68       	ld.sh	r8,r7[0xc]
8000f506:	ad c8       	cbr	r8,0xc
8000f508:	ae 68       	st.h	r7[0xc],r8
8000f50a:	d8 22       	popm	r4-r7,pc

8000f50c <_write_r>:
8000f50c:	d4 21       	pushm	r4-r7,lr
8000f50e:	16 98       	mov	r8,r11
8000f510:	18 97       	mov	r7,r12
8000f512:	10 9c       	mov	r12,r8
8000f514:	30 08       	mov	r8,0
8000f516:	14 9b       	mov	r11,r10
8000f518:	e0 66 53 20 	mov	r6,21280
8000f51c:	12 9a       	mov	r10,r9
8000f51e:	8d 08       	st.w	r6[0x0],r8
8000f520:	fe b0 c9 8c 	rcall	80008838 <_write>
8000f524:	5b fc       	cp.w	r12,-1
8000f526:	c0 51       	brne	8000f530 <_write_r+0x24>
8000f528:	6c 08       	ld.w	r8,r6[0x0]
8000f52a:	58 08       	cp.w	r8,0
8000f52c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f530:	d8 22       	popm	r4-r7,pc
8000f532:	d7 03       	nop

8000f534 <_calloc_r>:
8000f534:	d4 21       	pushm	r4-r7,lr
8000f536:	f4 0b 02 4b 	mul	r11,r10,r11
8000f53a:	fe b0 db 6d 	rcall	8000ac14 <_malloc_r>
8000f53e:	18 97       	mov	r7,r12
8000f540:	c2 30       	breq	8000f586 <_calloc_r+0x52>
8000f542:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000f546:	e0 1a ff fc 	andl	r10,0xfffc
8000f54a:	20 4a       	sub	r10,4
8000f54c:	e0 4a 00 24 	cp.w	r10,36
8000f550:	e0 8b 00 18 	brhi	8000f580 <_calloc_r+0x4c>
8000f554:	18 98       	mov	r8,r12
8000f556:	59 3a       	cp.w	r10,19
8000f558:	e0 88 00 0f 	brls	8000f576 <_calloc_r+0x42>
8000f55c:	30 09       	mov	r9,0
8000f55e:	10 a9       	st.w	r8++,r9
8000f560:	10 a9       	st.w	r8++,r9
8000f562:	59 ba       	cp.w	r10,27
8000f564:	e0 88 00 09 	brls	8000f576 <_calloc_r+0x42>
8000f568:	10 a9       	st.w	r8++,r9
8000f56a:	10 a9       	st.w	r8++,r9
8000f56c:	e0 4a 00 24 	cp.w	r10,36
8000f570:	c0 31       	brne	8000f576 <_calloc_r+0x42>
8000f572:	10 a9       	st.w	r8++,r9
8000f574:	10 a9       	st.w	r8++,r9
8000f576:	30 09       	mov	r9,0
8000f578:	10 a9       	st.w	r8++,r9
8000f57a:	91 19       	st.w	r8[0x4],r9
8000f57c:	91 09       	st.w	r8[0x0],r9
8000f57e:	c0 48       	rjmp	8000f586 <_calloc_r+0x52>
8000f580:	30 0b       	mov	r11,0
8000f582:	fe b0 de 1c 	rcall	8000b1ba <memset>
8000f586:	0e 9c       	mov	r12,r7
8000f588:	d8 22       	popm	r4-r7,pc
8000f58a:	d7 03       	nop

8000f58c <_close_r>:
8000f58c:	d4 21       	pushm	r4-r7,lr
8000f58e:	30 08       	mov	r8,0
8000f590:	18 97       	mov	r7,r12
8000f592:	e0 66 53 20 	mov	r6,21280
8000f596:	16 9c       	mov	r12,r11
8000f598:	8d 08       	st.w	r6[0x0],r8
8000f59a:	fe b0 df c1 	rcall	8000b51c <_close>
8000f59e:	5b fc       	cp.w	r12,-1
8000f5a0:	c0 51       	brne	8000f5aa <_close_r+0x1e>
8000f5a2:	6c 08       	ld.w	r8,r6[0x0]
8000f5a4:	58 08       	cp.w	r8,0
8000f5a6:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f5aa:	d8 22       	popm	r4-r7,pc

8000f5ac <_fclose_r>:
8000f5ac:	d4 21       	pushm	r4-r7,lr
8000f5ae:	18 96       	mov	r6,r12
8000f5b0:	16 97       	mov	r7,r11
8000f5b2:	58 0b       	cp.w	r11,0
8000f5b4:	c0 31       	brne	8000f5ba <_fclose_r+0xe>
8000f5b6:	16 95       	mov	r5,r11
8000f5b8:	c5 38       	rjmp	8000f65e <_fclose_r+0xb2>
8000f5ba:	fe b0 f8 b5 	rcall	8000e724 <__sfp_lock_acquire>
8000f5be:	58 06       	cp.w	r6,0
8000f5c0:	c0 70       	breq	8000f5ce <_fclose_r+0x22>
8000f5c2:	6c 68       	ld.w	r8,r6[0x18]
8000f5c4:	58 08       	cp.w	r8,0
8000f5c6:	c0 41       	brne	8000f5ce <_fclose_r+0x22>
8000f5c8:	0c 9c       	mov	r12,r6
8000f5ca:	fe b0 f8 ff 	rcall	8000e7c8 <__sinit>
8000f5ce:	fe c8 e5 d6 	sub	r8,pc,-6698
8000f5d2:	10 37       	cp.w	r7,r8
8000f5d4:	c0 31       	brne	8000f5da <_fclose_r+0x2e>
8000f5d6:	6c 07       	ld.w	r7,r6[0x0]
8000f5d8:	c0 c8       	rjmp	8000f5f0 <_fclose_r+0x44>
8000f5da:	fe c8 e5 c2 	sub	r8,pc,-6718
8000f5de:	10 37       	cp.w	r7,r8
8000f5e0:	c0 31       	brne	8000f5e6 <_fclose_r+0x3a>
8000f5e2:	6c 17       	ld.w	r7,r6[0x4]
8000f5e4:	c0 68       	rjmp	8000f5f0 <_fclose_r+0x44>
8000f5e6:	fe c8 e5 ae 	sub	r8,pc,-6738
8000f5ea:	10 37       	cp.w	r7,r8
8000f5ec:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000f5f0:	8e 69       	ld.sh	r9,r7[0xc]
8000f5f2:	30 08       	mov	r8,0
8000f5f4:	f0 09 19 00 	cp.h	r9,r8
8000f5f8:	c0 51       	brne	8000f602 <_fclose_r+0x56>
8000f5fa:	fe b0 f8 96 	rcall	8000e726 <__sfp_lock_release>
8000f5fe:	30 05       	mov	r5,0
8000f600:	c2 f8       	rjmp	8000f65e <_fclose_r+0xb2>
8000f602:	0e 9b       	mov	r11,r7
8000f604:	0c 9c       	mov	r12,r6
8000f606:	fe b0 f8 09 	rcall	8000e618 <_fflush_r>
8000f60a:	6e c8       	ld.w	r8,r7[0x30]
8000f60c:	18 95       	mov	r5,r12
8000f60e:	58 08       	cp.w	r8,0
8000f610:	c0 60       	breq	8000f61c <_fclose_r+0x70>
8000f612:	6e 8b       	ld.w	r11,r7[0x20]
8000f614:	0c 9c       	mov	r12,r6
8000f616:	5d 18       	icall	r8
8000f618:	f9 b5 05 ff 	movlt	r5,-1
8000f61c:	8e 68       	ld.sh	r8,r7[0xc]
8000f61e:	ed b8 00 07 	bld	r8,0x7
8000f622:	c0 51       	brne	8000f62c <_fclose_r+0x80>
8000f624:	6e 4b       	ld.w	r11,r7[0x10]
8000f626:	0c 9c       	mov	r12,r6
8000f628:	fe b0 f9 6a 	rcall	8000e8fc <_free_r>
8000f62c:	6e db       	ld.w	r11,r7[0x34]
8000f62e:	58 0b       	cp.w	r11,0
8000f630:	c0 a0       	breq	8000f644 <_fclose_r+0x98>
8000f632:	ee c8 ff bc 	sub	r8,r7,-68
8000f636:	10 3b       	cp.w	r11,r8
8000f638:	c0 40       	breq	8000f640 <_fclose_r+0x94>
8000f63a:	0c 9c       	mov	r12,r6
8000f63c:	fe b0 f9 60 	rcall	8000e8fc <_free_r>
8000f640:	30 08       	mov	r8,0
8000f642:	8f d8       	st.w	r7[0x34],r8
8000f644:	6f 2b       	ld.w	r11,r7[0x48]
8000f646:	58 0b       	cp.w	r11,0
8000f648:	c0 70       	breq	8000f656 <_fclose_r+0xaa>
8000f64a:	0c 9c       	mov	r12,r6
8000f64c:	fe b0 f9 58 	rcall	8000e8fc <_free_r>
8000f650:	30 08       	mov	r8,0
8000f652:	ef 48 00 48 	st.w	r7[72],r8
8000f656:	30 08       	mov	r8,0
8000f658:	ae 68       	st.h	r7[0xc],r8
8000f65a:	fe b0 f8 66 	rcall	8000e726 <__sfp_lock_release>
8000f65e:	0a 9c       	mov	r12,r5
8000f660:	d8 22       	popm	r4-r7,pc
8000f662:	d7 03       	nop

8000f664 <fclose>:
8000f664:	d4 01       	pushm	lr
8000f666:	e0 68 0a 50 	mov	r8,2640
8000f66a:	18 9b       	mov	r11,r12
8000f66c:	70 0c       	ld.w	r12,r8[0x0]
8000f66e:	c9 ff       	rcall	8000f5ac <_fclose_r>
8000f670:	d8 02       	popm	pc
8000f672:	d7 03       	nop

8000f674 <_fstat_r>:
8000f674:	d4 21       	pushm	r4-r7,lr
8000f676:	16 98       	mov	r8,r11
8000f678:	18 97       	mov	r7,r12
8000f67a:	10 9c       	mov	r12,r8
8000f67c:	30 08       	mov	r8,0
8000f67e:	e0 66 53 20 	mov	r6,21280
8000f682:	14 9b       	mov	r11,r10
8000f684:	8d 08       	st.w	r6[0x0],r8
8000f686:	fe b0 df 73 	rcall	8000b56c <_fstat>
8000f68a:	5b fc       	cp.w	r12,-1
8000f68c:	c0 51       	brne	8000f696 <_fstat_r+0x22>
8000f68e:	6c 08       	ld.w	r8,r6[0x0]
8000f690:	58 08       	cp.w	r8,0
8000f692:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f696:	d8 22       	popm	r4-r7,pc

8000f698 <_lseek_r>:
8000f698:	d4 21       	pushm	r4-r7,lr
8000f69a:	16 98       	mov	r8,r11
8000f69c:	18 97       	mov	r7,r12
8000f69e:	10 9c       	mov	r12,r8
8000f6a0:	30 08       	mov	r8,0
8000f6a2:	14 9b       	mov	r11,r10
8000f6a4:	e0 66 53 20 	mov	r6,21280
8000f6a8:	12 9a       	mov	r10,r9
8000f6aa:	8d 08       	st.w	r6[0x0],r8
8000f6ac:	fe b0 df 42 	rcall	8000b530 <_lseek>
8000f6b0:	5b fc       	cp.w	r12,-1
8000f6b2:	c0 51       	brne	8000f6bc <_lseek_r+0x24>
8000f6b4:	6c 08       	ld.w	r8,r6[0x0]
8000f6b6:	58 08       	cp.w	r8,0
8000f6b8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f6bc:	d8 22       	popm	r4-r7,pc
8000f6be:	d7 03       	nop

8000f6c0 <_read_r>:
8000f6c0:	d4 21       	pushm	r4-r7,lr
8000f6c2:	16 98       	mov	r8,r11
8000f6c4:	18 97       	mov	r7,r12
8000f6c6:	10 9c       	mov	r12,r8
8000f6c8:	30 08       	mov	r8,0
8000f6ca:	14 9b       	mov	r11,r10
8000f6cc:	e0 66 53 20 	mov	r6,21280
8000f6d0:	12 9a       	mov	r10,r9
8000f6d2:	8d 08       	st.w	r6[0x0],r8
8000f6d4:	fe b0 c8 6c 	rcall	800087ac <_read>
8000f6d8:	5b fc       	cp.w	r12,-1
8000f6da:	c0 51       	brne	8000f6e4 <_read_r+0x24>
8000f6dc:	6c 08       	ld.w	r8,r6[0x0]
8000f6de:	58 08       	cp.w	r8,0
8000f6e0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f6e4:	d8 22       	popm	r4-r7,pc
8000f6e6:	d7 03       	nop

8000f6e8 <__avr32_f64_mul>:
8000f6e8:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000f6ec:	e0 80 00 dc 	breq	8000f8a4 <__avr32_f64_mul_op1_zero>
8000f6f0:	d4 21       	pushm	r4-r7,lr
8000f6f2:	f7 e9 20 0e 	eor	lr,r11,r9
8000f6f6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000f6fa:	30 15       	mov	r5,1
8000f6fc:	c4 30       	breq	8000f782 <__avr32_f64_mul_op1_subnormal>
8000f6fe:	ab 6b       	lsl	r11,0xa
8000f700:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000f704:	ab 6a       	lsl	r10,0xa
8000f706:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000f70a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000f70e:	c5 c0       	breq	8000f7c6 <__avr32_f64_mul_op2_subnormal>
8000f710:	a1 78       	lsl	r8,0x1
8000f712:	5c f9       	rol	r9
8000f714:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000f718:	e0 47 07 ff 	cp.w	r7,2047
8000f71c:	c7 70       	breq	8000f80a <__avr32_f64_mul_op_nan_or_inf>
8000f71e:	e0 46 07 ff 	cp.w	r6,2047
8000f722:	c7 40       	breq	8000f80a <__avr32_f64_mul_op_nan_or_inf>
8000f724:	ee 06 00 0c 	add	r12,r7,r6
8000f728:	e0 2c 03 fe 	sub	r12,1022
8000f72c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000f730:	f4 09 07 44 	macu.d	r4,r10,r9
8000f734:	f4 08 06 46 	mulu.d	r6,r10,r8
8000f738:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000f73c:	08 07       	add	r7,r4
8000f73e:	f4 05 00 4a 	adc	r10,r10,r5
8000f742:	5c 0b       	acr	r11
8000f744:	ed bb 00 14 	bld	r11,0x14
8000f748:	c0 50       	breq	8000f752 <__avr32_f64_mul+0x6a>
8000f74a:	a1 77       	lsl	r7,0x1
8000f74c:	5c fa       	rol	r10
8000f74e:	5c fb       	rol	r11
8000f750:	20 1c       	sub	r12,1
8000f752:	58 0c       	cp.w	r12,0
8000f754:	e0 8a 00 6f 	brle	8000f832 <__avr32_f64_mul_res_subnormal>
8000f758:	e0 4c 07 ff 	cp.w	r12,2047
8000f75c:	e0 84 00 9c 	brge	8000f894 <__avr32_f64_mul_res_inf>
8000f760:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000f764:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000f768:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000f76c:	ee 17 80 00 	eorh	r7,0x8000
8000f770:	f1 b7 04 20 	satu	r7,0x1
8000f774:	0e 0a       	add	r10,r7
8000f776:	5c 0b       	acr	r11
8000f778:	ed be 00 1f 	bld	lr,0x1f
8000f77c:	ef bb 00 1f 	bst	r11,0x1f
8000f780:	d8 22       	popm	r4-r7,pc

8000f782 <__avr32_f64_mul_op1_subnormal>:
8000f782:	e4 1b 00 0f 	andh	r11,0xf
8000f786:	f4 0c 12 00 	clz	r12,r10
8000f78a:	f6 06 12 00 	clz	r6,r11
8000f78e:	f7 bc 03 e1 	sublo	r12,-31
8000f792:	f8 06 17 30 	movlo	r6,r12
8000f796:	f7 b6 02 01 	subhs	r6,1
8000f79a:	e0 46 00 20 	cp.w	r6,32
8000f79e:	c0 d4       	brge	8000f7b8 <__avr32_f64_mul_op1_subnormal+0x36>
8000f7a0:	ec 0c 11 20 	rsub	r12,r6,32
8000f7a4:	f6 06 09 4b 	lsl	r11,r11,r6
8000f7a8:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000f7ac:	18 4b       	or	r11,r12
8000f7ae:	f4 06 09 4a 	lsl	r10,r10,r6
8000f7b2:	20 b6       	sub	r6,11
8000f7b4:	0c 17       	sub	r7,r6
8000f7b6:	ca ab       	rjmp	8000f70a <__avr32_f64_mul+0x22>
8000f7b8:	f4 06 09 4b 	lsl	r11,r10,r6
8000f7bc:	c6 40       	breq	8000f884 <__avr32_f64_mul_res_zero>
8000f7be:	30 0a       	mov	r10,0
8000f7c0:	20 b6       	sub	r6,11
8000f7c2:	0c 17       	sub	r7,r6
8000f7c4:	ca 3b       	rjmp	8000f70a <__avr32_f64_mul+0x22>

8000f7c6 <__avr32_f64_mul_op2_subnormal>:
8000f7c6:	e4 19 00 0f 	andh	r9,0xf
8000f7ca:	f0 0c 12 00 	clz	r12,r8
8000f7ce:	f2 05 12 00 	clz	r5,r9
8000f7d2:	f7 bc 03 ea 	sublo	r12,-22
8000f7d6:	f8 05 17 30 	movlo	r5,r12
8000f7da:	f7 b5 02 0a 	subhs	r5,10
8000f7de:	e0 45 00 20 	cp.w	r5,32
8000f7e2:	c0 d4       	brge	8000f7fc <__avr32_f64_mul_op2_subnormal+0x36>
8000f7e4:	ea 0c 11 20 	rsub	r12,r5,32
8000f7e8:	f2 05 09 49 	lsl	r9,r9,r5
8000f7ec:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000f7f0:	18 49       	or	r9,r12
8000f7f2:	f0 05 09 48 	lsl	r8,r8,r5
8000f7f6:	20 25       	sub	r5,2
8000f7f8:	0a 16       	sub	r6,r5
8000f7fa:	c8 fb       	rjmp	8000f718 <__avr32_f64_mul+0x30>
8000f7fc:	f0 05 09 49 	lsl	r9,r8,r5
8000f800:	c4 20       	breq	8000f884 <__avr32_f64_mul_res_zero>
8000f802:	30 08       	mov	r8,0
8000f804:	20 25       	sub	r5,2
8000f806:	0a 16       	sub	r6,r5
8000f808:	c8 8b       	rjmp	8000f718 <__avr32_f64_mul+0x30>

8000f80a <__avr32_f64_mul_op_nan_or_inf>:
8000f80a:	e4 19 00 0f 	andh	r9,0xf
8000f80e:	e4 1b 00 0f 	andh	r11,0xf
8000f812:	14 4b       	or	r11,r10
8000f814:	10 49       	or	r9,r8
8000f816:	e0 47 07 ff 	cp.w	r7,2047
8000f81a:	c0 91       	brne	8000f82c <__avr32_f64_mul_op1_not_naninf>
8000f81c:	58 0b       	cp.w	r11,0
8000f81e:	c3 81       	brne	8000f88e <__avr32_f64_mul_res_nan>
8000f820:	e0 46 07 ff 	cp.w	r6,2047
8000f824:	c3 81       	brne	8000f894 <__avr32_f64_mul_res_inf>
8000f826:	58 09       	cp.w	r9,0
8000f828:	c3 60       	breq	8000f894 <__avr32_f64_mul_res_inf>
8000f82a:	c3 28       	rjmp	8000f88e <__avr32_f64_mul_res_nan>

8000f82c <__avr32_f64_mul_op1_not_naninf>:
8000f82c:	58 09       	cp.w	r9,0
8000f82e:	c3 30       	breq	8000f894 <__avr32_f64_mul_res_inf>
8000f830:	c2 f8       	rjmp	8000f88e <__avr32_f64_mul_res_nan>

8000f832 <__avr32_f64_mul_res_subnormal>:
8000f832:	5c 3c       	neg	r12
8000f834:	2f fc       	sub	r12,-1
8000f836:	f1 bc 04 c0 	satu	r12,0x6
8000f83a:	e0 4c 00 20 	cp.w	r12,32
8000f83e:	c1 14       	brge	8000f860 <__avr32_f64_mul_res_subnormal+0x2e>
8000f840:	f8 08 11 20 	rsub	r8,r12,32
8000f844:	0e 46       	or	r6,r7
8000f846:	ee 0c 0a 47 	lsr	r7,r7,r12
8000f84a:	f4 08 09 49 	lsl	r9,r10,r8
8000f84e:	12 47       	or	r7,r9
8000f850:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f854:	f6 08 09 49 	lsl	r9,r11,r8
8000f858:	12 4a       	or	r10,r9
8000f85a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000f85e:	c8 3b       	rjmp	8000f764 <__avr32_f64_mul+0x7c>
8000f860:	f8 08 11 20 	rsub	r8,r12,32
8000f864:	f9 b9 00 00 	moveq	r9,0
8000f868:	c0 30       	breq	8000f86e <__avr32_f64_mul_res_subnormal+0x3c>
8000f86a:	f6 08 09 49 	lsl	r9,r11,r8
8000f86e:	0e 46       	or	r6,r7
8000f870:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000f874:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000f878:	f3 ea 10 07 	or	r7,r9,r10
8000f87c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000f880:	30 0b       	mov	r11,0
8000f882:	c7 1b       	rjmp	8000f764 <__avr32_f64_mul+0x7c>

8000f884 <__avr32_f64_mul_res_zero>:
8000f884:	1c 9b       	mov	r11,lr
8000f886:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f88a:	30 0a       	mov	r10,0
8000f88c:	d8 22       	popm	r4-r7,pc

8000f88e <__avr32_f64_mul_res_nan>:
8000f88e:	3f fb       	mov	r11,-1
8000f890:	3f fa       	mov	r10,-1
8000f892:	d8 22       	popm	r4-r7,pc

8000f894 <__avr32_f64_mul_res_inf>:
8000f894:	f0 6b 00 00 	mov	r11,-1048576
8000f898:	ed be 00 1f 	bld	lr,0x1f
8000f89c:	ef bb 00 1f 	bst	r11,0x1f
8000f8a0:	30 0a       	mov	r10,0
8000f8a2:	d8 22       	popm	r4-r7,pc

8000f8a4 <__avr32_f64_mul_op1_zero>:
8000f8a4:	f7 e9 20 0b 	eor	r11,r11,r9
8000f8a8:	e6 1b 80 00 	andh	r11,0x8000,COH
8000f8ac:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000f8b0:	e0 4c 07 ff 	cp.w	r12,2047
8000f8b4:	5e 1c       	retne	r12
8000f8b6:	3f fa       	mov	r10,-1
8000f8b8:	3f fb       	mov	r11,-1
8000f8ba:	5e fc       	retal	r12

8000f8bc <__avr32_f64_sub_from_add>:
8000f8bc:	ee 19 80 00 	eorh	r9,0x8000

8000f8c0 <__avr32_f64_sub>:
8000f8c0:	f7 e9 20 0c 	eor	r12,r11,r9
8000f8c4:	e0 86 00 ca 	brmi	8000fa58 <__avr32_f64_add_from_sub>
8000f8c8:	eb cd 40 e0 	pushm	r5-r7,lr
8000f8cc:	16 9c       	mov	r12,r11
8000f8ce:	e6 1c 80 00 	andh	r12,0x8000,COH
8000f8d2:	bf db       	cbr	r11,0x1f
8000f8d4:	bf d9       	cbr	r9,0x1f
8000f8d6:	10 3a       	cp.w	r10,r8
8000f8d8:	f2 0b 13 00 	cpc	r11,r9
8000f8dc:	c0 92       	brcc	8000f8ee <__avr32_f64_sub+0x2e>
8000f8de:	16 97       	mov	r7,r11
8000f8e0:	12 9b       	mov	r11,r9
8000f8e2:	0e 99       	mov	r9,r7
8000f8e4:	14 97       	mov	r7,r10
8000f8e6:	10 9a       	mov	r10,r8
8000f8e8:	0e 98       	mov	r8,r7
8000f8ea:	ee 1c 80 00 	eorh	r12,0x8000
8000f8ee:	f6 07 16 14 	lsr	r7,r11,0x14
8000f8f2:	ab 7b       	lsl	r11,0xb
8000f8f4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000f8f8:	ab 7a       	lsl	r10,0xb
8000f8fa:	bf bb       	sbr	r11,0x1f
8000f8fc:	f2 06 16 14 	lsr	r6,r9,0x14
8000f900:	c4 40       	breq	8000f988 <__avr32_f64_sub_opL_subnormal>
8000f902:	ab 79       	lsl	r9,0xb
8000f904:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f908:	ab 78       	lsl	r8,0xb
8000f90a:	bf b9       	sbr	r9,0x1f

8000f90c <__avr32_f64_sub_opL_subnormal_done>:
8000f90c:	e0 47 07 ff 	cp.w	r7,2047
8000f910:	c4 f0       	breq	8000f9ae <__avr32_f64_sub_opH_nan_or_inf>
8000f912:	0e 26       	rsub	r6,r7
8000f914:	c1 20       	breq	8000f938 <__avr32_f64_sub_shift_done>
8000f916:	ec 05 11 20 	rsub	r5,r6,32
8000f91a:	e0 46 00 20 	cp.w	r6,32
8000f91e:	c7 c2       	brcc	8000fa16 <__avr32_f64_sub_longshift>
8000f920:	f0 05 09 4e 	lsl	lr,r8,r5
8000f924:	f2 05 09 45 	lsl	r5,r9,r5
8000f928:	f0 06 0a 48 	lsr	r8,r8,r6
8000f92c:	f2 06 0a 49 	lsr	r9,r9,r6
8000f930:	0a 48       	or	r8,r5
8000f932:	58 0e       	cp.w	lr,0
8000f934:	5f 1e       	srne	lr
8000f936:	1c 48       	or	r8,lr

8000f938 <__avr32_f64_sub_shift_done>:
8000f938:	10 1a       	sub	r10,r8
8000f93a:	f6 09 01 4b 	sbc	r11,r11,r9
8000f93e:	f6 06 12 00 	clz	r6,r11
8000f942:	c0 e0       	breq	8000f95e <__avr32_f64_sub_longnormalize_done>
8000f944:	c7 83       	brcs	8000fa34 <__avr32_f64_sub_longnormalize>
8000f946:	ec 0e 11 20 	rsub	lr,r6,32
8000f94a:	f6 06 09 4b 	lsl	r11,r11,r6
8000f94e:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000f952:	1c 4b       	or	r11,lr
8000f954:	f4 06 09 4a 	lsl	r10,r10,r6
8000f958:	0c 17       	sub	r7,r6
8000f95a:	e0 8a 00 39 	brle	8000f9cc <__avr32_f64_sub_subnormal_result>

8000f95e <__avr32_f64_sub_longnormalize_done>:
8000f95e:	f4 09 15 15 	lsl	r9,r10,0x15
8000f962:	ab 9a       	lsr	r10,0xb
8000f964:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000f968:	ab 9b       	lsr	r11,0xb
8000f96a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000f96e:	18 4b       	or	r11,r12

8000f970 <__avr32_f64_sub_round>:
8000f970:	fc 17 80 00 	movh	r7,0x8000
8000f974:	ed ba 00 00 	bld	r10,0x0
8000f978:	f7 b7 01 ff 	subne	r7,-1
8000f97c:	0e 39       	cp.w	r9,r7
8000f97e:	5f 29       	srhs	r9
8000f980:	12 0a       	add	r10,r9
8000f982:	5c 0b       	acr	r11
8000f984:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f988 <__avr32_f64_sub_opL_subnormal>:
8000f988:	ab 79       	lsl	r9,0xb
8000f98a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000f98e:	ab 78       	lsl	r8,0xb
8000f990:	f3 e8 10 0e 	or	lr,r9,r8
8000f994:	f9 b6 01 01 	movne	r6,1
8000f998:	ee 0e 11 00 	rsub	lr,r7,0
8000f99c:	f9 b7 00 01 	moveq	r7,1
8000f9a0:	ef bb 00 1f 	bst	r11,0x1f
8000f9a4:	f7 ea 10 0e 	or	lr,r11,r10
8000f9a8:	f9 b7 00 00 	moveq	r7,0
8000f9ac:	cb 0b       	rjmp	8000f90c <__avr32_f64_sub_opL_subnormal_done>

8000f9ae <__avr32_f64_sub_opH_nan_or_inf>:
8000f9ae:	bf db       	cbr	r11,0x1f
8000f9b0:	f7 ea 10 0e 	or	lr,r11,r10
8000f9b4:	c0 81       	brne	8000f9c4 <__avr32_f64_sub_return_nan>
8000f9b6:	e0 46 07 ff 	cp.w	r6,2047
8000f9ba:	c0 50       	breq	8000f9c4 <__avr32_f64_sub_return_nan>
8000f9bc:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000f9c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f9c4 <__avr32_f64_sub_return_nan>:
8000f9c4:	3f fa       	mov	r10,-1
8000f9c6:	3f fb       	mov	r11,-1
8000f9c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000f9cc <__avr32_f64_sub_subnormal_result>:
8000f9cc:	5c 37       	neg	r7
8000f9ce:	2f f7       	sub	r7,-1
8000f9d0:	f1 b7 04 c0 	satu	r7,0x6
8000f9d4:	e0 47 00 20 	cp.w	r7,32
8000f9d8:	c1 14       	brge	8000f9fa <__avr32_f64_sub_subnormal_result+0x2e>
8000f9da:	ee 08 11 20 	rsub	r8,r7,32
8000f9de:	f4 08 09 49 	lsl	r9,r10,r8
8000f9e2:	5f 16       	srne	r6
8000f9e4:	f4 07 0a 4a 	lsr	r10,r10,r7
8000f9e8:	0c 4a       	or	r10,r6
8000f9ea:	f6 08 09 49 	lsl	r9,r11,r8
8000f9ee:	f5 e9 10 0a 	or	r10,r10,r9
8000f9f2:	f4 07 0a 4b 	lsr	r11,r10,r7
8000f9f6:	30 07       	mov	r7,0
8000f9f8:	cb 3b       	rjmp	8000f95e <__avr32_f64_sub_longnormalize_done>
8000f9fa:	ee 08 11 40 	rsub	r8,r7,64
8000f9fe:	f6 08 09 49 	lsl	r9,r11,r8
8000fa02:	14 49       	or	r9,r10
8000fa04:	5f 16       	srne	r6
8000fa06:	f6 07 0a 4a 	lsr	r10,r11,r7
8000fa0a:	0c 4a       	or	r10,r6
8000fa0c:	30 0b       	mov	r11,0
8000fa0e:	30 07       	mov	r7,0
8000fa10:	ca 7b       	rjmp	8000f95e <__avr32_f64_sub_longnormalize_done>
8000fa12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000fa16 <__avr32_f64_sub_longshift>:
8000fa16:	f1 b6 04 c0 	satu	r6,0x6
8000fa1a:	f0 0e 17 00 	moveq	lr,r8
8000fa1e:	c0 40       	breq	8000fa26 <__avr32_f64_sub_longshift+0x10>
8000fa20:	f2 05 09 4e 	lsl	lr,r9,r5
8000fa24:	10 4e       	or	lr,r8
8000fa26:	f2 06 0a 48 	lsr	r8,r9,r6
8000fa2a:	30 09       	mov	r9,0
8000fa2c:	58 0e       	cp.w	lr,0
8000fa2e:	5f 1e       	srne	lr
8000fa30:	1c 48       	or	r8,lr
8000fa32:	c8 3b       	rjmp	8000f938 <__avr32_f64_sub_shift_done>

8000fa34 <__avr32_f64_sub_longnormalize>:
8000fa34:	f4 06 12 00 	clz	r6,r10
8000fa38:	f9 b7 03 00 	movlo	r7,0
8000fa3c:	f9 b6 03 00 	movlo	r6,0
8000fa40:	f9 bc 03 00 	movlo	r12,0
8000fa44:	f7 b6 02 e0 	subhs	r6,-32
8000fa48:	f4 06 09 4b 	lsl	r11,r10,r6
8000fa4c:	30 0a       	mov	r10,0
8000fa4e:	0c 17       	sub	r7,r6
8000fa50:	fe 9a ff be 	brle	8000f9cc <__avr32_f64_sub_subnormal_result>
8000fa54:	c8 5b       	rjmp	8000f95e <__avr32_f64_sub_longnormalize_done>
8000fa56:	d7 03       	nop

8000fa58 <__avr32_f64_add_from_sub>:
8000fa58:	ee 19 80 00 	eorh	r9,0x8000

8000fa5c <__avr32_f64_add>:
8000fa5c:	f7 e9 20 0c 	eor	r12,r11,r9
8000fa60:	fe 96 ff 2e 	brmi	8000f8bc <__avr32_f64_sub_from_add>
8000fa64:	eb cd 40 e0 	pushm	r5-r7,lr
8000fa68:	16 9c       	mov	r12,r11
8000fa6a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000fa6e:	bf db       	cbr	r11,0x1f
8000fa70:	bf d9       	cbr	r9,0x1f
8000fa72:	12 3b       	cp.w	r11,r9
8000fa74:	c0 72       	brcc	8000fa82 <__avr32_f64_add+0x26>
8000fa76:	16 97       	mov	r7,r11
8000fa78:	12 9b       	mov	r11,r9
8000fa7a:	0e 99       	mov	r9,r7
8000fa7c:	14 97       	mov	r7,r10
8000fa7e:	10 9a       	mov	r10,r8
8000fa80:	0e 98       	mov	r8,r7
8000fa82:	30 0e       	mov	lr,0
8000fa84:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000fa88:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000fa8c:	b5 ab       	sbr	r11,0x14
8000fa8e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000fa92:	c6 20       	breq	8000fb56 <__avr32_f64_add_op2_subnormal>
8000fa94:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000fa98:	b5 a9       	sbr	r9,0x14
8000fa9a:	e0 47 07 ff 	cp.w	r7,2047
8000fa9e:	c2 80       	breq	8000faee <__avr32_f64_add_opH_nan_or_inf>
8000faa0:	0e 26       	rsub	r6,r7
8000faa2:	c1 20       	breq	8000fac6 <__avr32_f64_add_shift_done>
8000faa4:	e0 46 00 36 	cp.w	r6,54
8000faa8:	c1 52       	brcc	8000fad2 <__avr32_f64_add_res_of_done>
8000faaa:	ec 05 11 20 	rsub	r5,r6,32
8000faae:	e0 46 00 20 	cp.w	r6,32
8000fab2:	c3 52       	brcc	8000fb1c <__avr32_f64_add_longshift>
8000fab4:	f0 05 09 4e 	lsl	lr,r8,r5
8000fab8:	f2 05 09 45 	lsl	r5,r9,r5
8000fabc:	f0 06 0a 48 	lsr	r8,r8,r6
8000fac0:	f2 06 0a 49 	lsr	r9,r9,r6
8000fac4:	0a 48       	or	r8,r5

8000fac6 <__avr32_f64_add_shift_done>:
8000fac6:	10 0a       	add	r10,r8
8000fac8:	f6 09 00 4b 	adc	r11,r11,r9
8000facc:	ed bb 00 15 	bld	r11,0x15
8000fad0:	c3 40       	breq	8000fb38 <__avr32_f64_add_res_of>

8000fad2 <__avr32_f64_add_res_of_done>:
8000fad2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000fad6:	18 4b       	or	r11,r12

8000fad8 <__avr32_f64_add_round>:
8000fad8:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000fadc:	18 4e       	or	lr,r12
8000fade:	ee 1e 80 00 	eorh	lr,0x8000
8000fae2:	f1 be 04 20 	satu	lr,0x1
8000fae6:	1c 0a       	add	r10,lr
8000fae8:	5c 0b       	acr	r11
8000faea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000faee <__avr32_f64_add_opH_nan_or_inf>:
8000faee:	b5 cb       	cbr	r11,0x14
8000faf0:	f7 ea 10 0e 	or	lr,r11,r10
8000faf4:	c1 01       	brne	8000fb14 <__avr32_f64_add_return_nan>
8000faf6:	e0 46 07 ff 	cp.w	r6,2047
8000fafa:	c0 30       	breq	8000fb00 <__avr32_f64_add_opL_nan_or_inf>
8000fafc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000fb00 <__avr32_f64_add_opL_nan_or_inf>:
8000fb00:	b5 c9       	cbr	r9,0x14
8000fb02:	f3 e8 10 0e 	or	lr,r9,r8
8000fb06:	c0 71       	brne	8000fb14 <__avr32_f64_add_return_nan>
8000fb08:	30 0a       	mov	r10,0
8000fb0a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000fb0e:	18 4b       	or	r11,r12
8000fb10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000fb14 <__avr32_f64_add_return_nan>:
8000fb14:	3f fa       	mov	r10,-1
8000fb16:	3f fb       	mov	r11,-1
8000fb18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000fb1c <__avr32_f64_add_longshift>:
8000fb1c:	f1 b6 04 c0 	satu	r6,0x6
8000fb20:	f0 0e 17 00 	moveq	lr,r8
8000fb24:	c0 60       	breq	8000fb30 <__avr32_f64_add_longshift+0x14>
8000fb26:	f2 05 09 4e 	lsl	lr,r9,r5
8000fb2a:	58 08       	cp.w	r8,0
8000fb2c:	5f 18       	srne	r8
8000fb2e:	10 4e       	or	lr,r8
8000fb30:	f2 06 0a 48 	lsr	r8,r9,r6
8000fb34:	30 09       	mov	r9,0
8000fb36:	cc 8b       	rjmp	8000fac6 <__avr32_f64_add_shift_done>

8000fb38 <__avr32_f64_add_res_of>:
8000fb38:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000fb3c:	a1 9b       	lsr	r11,0x1
8000fb3e:	5d 0a       	ror	r10
8000fb40:	5d 0e       	ror	lr
8000fb42:	2f f7       	sub	r7,-1
8000fb44:	e0 47 07 ff 	cp.w	r7,2047
8000fb48:	f9 ba 00 00 	moveq	r10,0
8000fb4c:	f9 bb 00 00 	moveq	r11,0
8000fb50:	f9 be 00 00 	moveq	lr,0
8000fb54:	cb fb       	rjmp	8000fad2 <__avr32_f64_add_res_of_done>

8000fb56 <__avr32_f64_add_op2_subnormal>:
8000fb56:	30 16       	mov	r6,1
8000fb58:	58 07       	cp.w	r7,0
8000fb5a:	ca 01       	brne	8000fa9a <__avr32_f64_add+0x3e>
8000fb5c:	b5 cb       	cbr	r11,0x14
8000fb5e:	10 0a       	add	r10,r8
8000fb60:	f6 09 00 4b 	adc	r11,r11,r9
8000fb64:	18 4b       	or	r11,r12
8000fb66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000fb6a:	d7 03       	nop

8000fb6c <__avr32_f64_to_u32>:
8000fb6c:	58 0b       	cp.w	r11,0
8000fb6e:	5e 6d       	retmi	0

8000fb70 <__avr32_f64_to_s32>:
8000fb70:	f6 0c 15 01 	lsl	r12,r11,0x1
8000fb74:	b5 9c       	lsr	r12,0x15
8000fb76:	e0 2c 03 ff 	sub	r12,1023
8000fb7a:	5e 3d       	retlo	0
8000fb7c:	f8 0c 11 1f 	rsub	r12,r12,31
8000fb80:	16 99       	mov	r9,r11
8000fb82:	ab 7b       	lsl	r11,0xb
8000fb84:	bf bb       	sbr	r11,0x1f
8000fb86:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000fb8a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000fb8e:	a1 79       	lsl	r9,0x1
8000fb90:	5e 2b       	reths	r11
8000fb92:	5c 3b       	neg	r11
8000fb94:	5e fb       	retal	r11

8000fb96 <__avr32_u32_to_f64>:
8000fb96:	f8 cb 00 00 	sub	r11,r12,0
8000fb9a:	30 0c       	mov	r12,0
8000fb9c:	c0 38       	rjmp	8000fba2 <__avr32_s32_to_f64+0x4>

8000fb9e <__avr32_s32_to_f64>:
8000fb9e:	18 9b       	mov	r11,r12
8000fba0:	5c 4b       	abs	r11
8000fba2:	30 0a       	mov	r10,0
8000fba4:	5e 0b       	reteq	r11
8000fba6:	d4 01       	pushm	lr
8000fba8:	e0 69 04 1e 	mov	r9,1054
8000fbac:	f6 08 12 00 	clz	r8,r11
8000fbb0:	c1 70       	breq	8000fbde <__avr32_s32_to_f64+0x40>
8000fbb2:	c0 c3       	brcs	8000fbca <__avr32_s32_to_f64+0x2c>
8000fbb4:	f0 0e 11 20 	rsub	lr,r8,32
8000fbb8:	f6 08 09 4b 	lsl	r11,r11,r8
8000fbbc:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000fbc0:	1c 4b       	or	r11,lr
8000fbc2:	f4 08 09 4a 	lsl	r10,r10,r8
8000fbc6:	10 19       	sub	r9,r8
8000fbc8:	c0 b8       	rjmp	8000fbde <__avr32_s32_to_f64+0x40>
8000fbca:	f4 08 12 00 	clz	r8,r10
8000fbce:	f9 b8 03 00 	movlo	r8,0
8000fbd2:	f7 b8 02 e0 	subhs	r8,-32
8000fbd6:	f4 08 09 4b 	lsl	r11,r10,r8
8000fbda:	30 0a       	mov	r10,0
8000fbdc:	10 19       	sub	r9,r8
8000fbde:	58 09       	cp.w	r9,0
8000fbe0:	e0 89 00 30 	brgt	8000fc40 <__avr32_s32_to_f64+0xa2>
8000fbe4:	5c 39       	neg	r9
8000fbe6:	2f f9       	sub	r9,-1
8000fbe8:	e0 49 00 36 	cp.w	r9,54
8000fbec:	c0 43       	brcs	8000fbf4 <__avr32_s32_to_f64+0x56>
8000fbee:	30 0b       	mov	r11,0
8000fbf0:	30 0a       	mov	r10,0
8000fbf2:	c2 68       	rjmp	8000fc3e <__avr32_s32_to_f64+0xa0>
8000fbf4:	2f 69       	sub	r9,-10
8000fbf6:	f2 08 11 20 	rsub	r8,r9,32
8000fbfa:	e0 49 00 20 	cp.w	r9,32
8000fbfe:	c0 b2       	brcc	8000fc14 <__avr32_s32_to_f64+0x76>
8000fc00:	f4 08 09 4e 	lsl	lr,r10,r8
8000fc04:	f6 08 09 48 	lsl	r8,r11,r8
8000fc08:	f4 09 0a 4a 	lsr	r10,r10,r9
8000fc0c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000fc10:	10 4b       	or	r11,r8
8000fc12:	c0 88       	rjmp	8000fc22 <__avr32_s32_to_f64+0x84>
8000fc14:	f6 08 09 4e 	lsl	lr,r11,r8
8000fc18:	14 4e       	or	lr,r10
8000fc1a:	16 9a       	mov	r10,r11
8000fc1c:	30 0b       	mov	r11,0
8000fc1e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000fc22:	ed ba 00 00 	bld	r10,0x0
8000fc26:	c0 92       	brcc	8000fc38 <__avr32_s32_to_f64+0x9a>
8000fc28:	1c 7e       	tst	lr,lr
8000fc2a:	c0 41       	brne	8000fc32 <__avr32_s32_to_f64+0x94>
8000fc2c:	ed ba 00 01 	bld	r10,0x1
8000fc30:	c0 42       	brcc	8000fc38 <__avr32_s32_to_f64+0x9a>
8000fc32:	2f fa       	sub	r10,-1
8000fc34:	f7 bb 02 ff 	subhs	r11,-1
8000fc38:	5c fc       	rol	r12
8000fc3a:	5d 0b       	ror	r11
8000fc3c:	5d 0a       	ror	r10
8000fc3e:	d8 02       	popm	pc
8000fc40:	e0 68 03 ff 	mov	r8,1023
8000fc44:	ed ba 00 0b 	bld	r10,0xb
8000fc48:	f7 b8 00 ff 	subeq	r8,-1
8000fc4c:	10 0a       	add	r10,r8
8000fc4e:	5c 0b       	acr	r11
8000fc50:	f7 b9 03 fe 	sublo	r9,-2
8000fc54:	e0 49 07 ff 	cp.w	r9,2047
8000fc58:	c0 55       	brlt	8000fc62 <__avr32_s32_to_f64+0xc4>
8000fc5a:	30 0a       	mov	r10,0
8000fc5c:	fc 1b ff e0 	movh	r11,0xffe0
8000fc60:	c0 c8       	rjmp	8000fc78 <__floatsidf_return_op1>
8000fc62:	ed bb 00 1f 	bld	r11,0x1f
8000fc66:	f7 b9 01 01 	subne	r9,1
8000fc6a:	ab 9a       	lsr	r10,0xb
8000fc6c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000fc70:	a1 7b       	lsl	r11,0x1
8000fc72:	ab 9b       	lsr	r11,0xb
8000fc74:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000fc78 <__floatsidf_return_op1>:
8000fc78:	a1 7c       	lsl	r12,0x1
8000fc7a:	5d 0b       	ror	r11
8000fc7c:	d8 02       	popm	pc

8000fc7e <__avr32_f64_cmp_eq>:
8000fc7e:	10 3a       	cp.w	r10,r8
8000fc80:	f2 0b 13 00 	cpc	r11,r9
8000fc84:	c0 80       	breq	8000fc94 <__avr32_f64_cmp_eq+0x16>
8000fc86:	a1 7b       	lsl	r11,0x1
8000fc88:	a1 79       	lsl	r9,0x1
8000fc8a:	14 4b       	or	r11,r10
8000fc8c:	12 4b       	or	r11,r9
8000fc8e:	10 4b       	or	r11,r8
8000fc90:	5e 0f       	reteq	1
8000fc92:	5e fd       	retal	0
8000fc94:	a1 7b       	lsl	r11,0x1
8000fc96:	fc 1c ff e0 	movh	r12,0xffe0
8000fc9a:	58 0a       	cp.w	r10,0
8000fc9c:	f8 0b 13 00 	cpc	r11,r12
8000fca0:	5e 8f       	retls	1
8000fca2:	5e fd       	retal	0

8000fca4 <__avr32_f64_cmp_ge>:
8000fca4:	1a de       	st.w	--sp,lr
8000fca6:	1a d7       	st.w	--sp,r7
8000fca8:	a1 7b       	lsl	r11,0x1
8000fcaa:	5f 3c       	srlo	r12
8000fcac:	a1 79       	lsl	r9,0x1
8000fcae:	5f 37       	srlo	r7
8000fcb0:	5c fc       	rol	r12
8000fcb2:	fc 1e ff e0 	movh	lr,0xffe0
8000fcb6:	58 0a       	cp.w	r10,0
8000fcb8:	fc 0b 13 00 	cpc	r11,lr
8000fcbc:	e0 8b 00 1d 	brhi	8000fcf6 <__avr32_f64_cmp_ge+0x52>
8000fcc0:	58 08       	cp.w	r8,0
8000fcc2:	fc 09 13 00 	cpc	r9,lr
8000fcc6:	e0 8b 00 18 	brhi	8000fcf6 <__avr32_f64_cmp_ge+0x52>
8000fcca:	58 0b       	cp.w	r11,0
8000fccc:	f5 ba 00 00 	subfeq	r10,0
8000fcd0:	c1 50       	breq	8000fcfa <__avr32_f64_cmp_ge+0x56>
8000fcd2:	1b 07       	ld.w	r7,sp++
8000fcd4:	1b 0e       	ld.w	lr,sp++
8000fcd6:	58 3c       	cp.w	r12,3
8000fcd8:	c0 a0       	breq	8000fcec <__avr32_f64_cmp_ge+0x48>
8000fcda:	58 1c       	cp.w	r12,1
8000fcdc:	c0 33       	brcs	8000fce2 <__avr32_f64_cmp_ge+0x3e>
8000fcde:	5e 0f       	reteq	1
8000fce0:	5e 1d       	retne	0
8000fce2:	10 3a       	cp.w	r10,r8
8000fce4:	f2 0b 13 00 	cpc	r11,r9
8000fce8:	5e 2f       	reths	1
8000fcea:	5e 3d       	retlo	0
8000fcec:	14 38       	cp.w	r8,r10
8000fcee:	f6 09 13 00 	cpc	r9,r11
8000fcf2:	5e 2f       	reths	1
8000fcf4:	5e 3d       	retlo	0
8000fcf6:	1b 07       	ld.w	r7,sp++
8000fcf8:	d8 0a       	popm	pc,r12=0
8000fcfa:	58 17       	cp.w	r7,1
8000fcfc:	5f 0c       	sreq	r12
8000fcfe:	58 09       	cp.w	r9,0
8000fd00:	f5 b8 00 00 	subfeq	r8,0
8000fd04:	1b 07       	ld.w	r7,sp++
8000fd06:	1b 0e       	ld.w	lr,sp++
8000fd08:	5e 0f       	reteq	1
8000fd0a:	5e fc       	retal	r12

8000fd0c <__avr32_f64_cmp_lt>:
8000fd0c:	1a de       	st.w	--sp,lr
8000fd0e:	1a d7       	st.w	--sp,r7
8000fd10:	a1 7b       	lsl	r11,0x1
8000fd12:	5f 3c       	srlo	r12
8000fd14:	a1 79       	lsl	r9,0x1
8000fd16:	5f 37       	srlo	r7
8000fd18:	5c fc       	rol	r12
8000fd1a:	fc 1e ff e0 	movh	lr,0xffe0
8000fd1e:	58 0a       	cp.w	r10,0
8000fd20:	fc 0b 13 00 	cpc	r11,lr
8000fd24:	e0 8b 00 1d 	brhi	8000fd5e <__avr32_f64_cmp_lt+0x52>
8000fd28:	58 08       	cp.w	r8,0
8000fd2a:	fc 09 13 00 	cpc	r9,lr
8000fd2e:	e0 8b 00 18 	brhi	8000fd5e <__avr32_f64_cmp_lt+0x52>
8000fd32:	58 0b       	cp.w	r11,0
8000fd34:	f5 ba 00 00 	subfeq	r10,0
8000fd38:	c1 50       	breq	8000fd62 <__avr32_f64_cmp_lt+0x56>
8000fd3a:	1b 07       	ld.w	r7,sp++
8000fd3c:	1b 0e       	ld.w	lr,sp++
8000fd3e:	58 3c       	cp.w	r12,3
8000fd40:	c0 a0       	breq	8000fd54 <__avr32_f64_cmp_lt+0x48>
8000fd42:	58 1c       	cp.w	r12,1
8000fd44:	c0 33       	brcs	8000fd4a <__avr32_f64_cmp_lt+0x3e>
8000fd46:	5e 0d       	reteq	0
8000fd48:	5e 1f       	retne	1
8000fd4a:	10 3a       	cp.w	r10,r8
8000fd4c:	f2 0b 13 00 	cpc	r11,r9
8000fd50:	5e 2d       	reths	0
8000fd52:	5e 3f       	retlo	1
8000fd54:	14 38       	cp.w	r8,r10
8000fd56:	f6 09 13 00 	cpc	r9,r11
8000fd5a:	5e 2d       	reths	0
8000fd5c:	5e 3f       	retlo	1
8000fd5e:	1b 07       	ld.w	r7,sp++
8000fd60:	d8 0a       	popm	pc,r12=0
8000fd62:	58 17       	cp.w	r7,1
8000fd64:	5f 1c       	srne	r12
8000fd66:	58 09       	cp.w	r9,0
8000fd68:	f5 b8 00 00 	subfeq	r8,0
8000fd6c:	1b 07       	ld.w	r7,sp++
8000fd6e:	1b 0e       	ld.w	lr,sp++
8000fd70:	5e 0d       	reteq	0
8000fd72:	5e fc       	retal	r12

8000fd74 <__avr32_f64_div>:
8000fd74:	eb cd 40 ff 	pushm	r0-r7,lr
8000fd78:	f7 e9 20 0e 	eor	lr,r11,r9
8000fd7c:	f6 07 16 14 	lsr	r7,r11,0x14
8000fd80:	a9 7b       	lsl	r11,0x9
8000fd82:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000fd86:	a9 7a       	lsl	r10,0x9
8000fd88:	bd bb       	sbr	r11,0x1d
8000fd8a:	e4 1b 3f ff 	andh	r11,0x3fff
8000fd8e:	ab d7       	cbr	r7,0xb
8000fd90:	e0 80 00 cc 	breq	8000ff28 <__avr32_f64_div_round_subnormal+0x54>
8000fd94:	e0 47 07 ff 	cp.w	r7,2047
8000fd98:	e0 84 00 b5 	brge	8000ff02 <__avr32_f64_div_round_subnormal+0x2e>
8000fd9c:	f2 06 16 14 	lsr	r6,r9,0x14
8000fda0:	a9 79       	lsl	r9,0x9
8000fda2:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000fda6:	a9 78       	lsl	r8,0x9
8000fda8:	bd b9       	sbr	r9,0x1d
8000fdaa:	e4 19 3f ff 	andh	r9,0x3fff
8000fdae:	ab d6       	cbr	r6,0xb
8000fdb0:	e0 80 00 e2 	breq	8000ff74 <__avr32_f64_div_round_subnormal+0xa0>
8000fdb4:	e0 46 07 ff 	cp.w	r6,2047
8000fdb8:	e0 84 00 b2 	brge	8000ff1c <__avr32_f64_div_round_subnormal+0x48>
8000fdbc:	0c 17       	sub	r7,r6
8000fdbe:	fe 37 fc 01 	sub	r7,-1023
8000fdc2:	fc 1c 80 00 	movh	r12,0x8000
8000fdc6:	f8 03 16 01 	lsr	r3,r12,0x1
8000fdca:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000fdce:	5c d4       	com	r4
8000fdd0:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000fdd4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fdd8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000fddc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fde0:	ea 03 15 02 	lsl	r3,r5,0x2
8000fde4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fde8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000fdec:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fdf0:	ea 03 15 02 	lsl	r3,r5,0x2
8000fdf4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fdf8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000fdfc:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fe00:	ea 03 15 02 	lsl	r3,r5,0x2
8000fe04:	e6 08 06 40 	mulu.d	r0,r3,r8
8000fe08:	e4 09 07 40 	macu.d	r0,r2,r9
8000fe0c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fe10:	02 04       	add	r4,r1
8000fe12:	5c 05       	acr	r5
8000fe14:	a3 65       	lsl	r5,0x2
8000fe16:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000fe1a:	a3 64       	lsl	r4,0x2
8000fe1c:	5c 34       	neg	r4
8000fe1e:	f8 05 01 45 	sbc	r5,r12,r5
8000fe22:	e6 04 06 40 	mulu.d	r0,r3,r4
8000fe26:	e4 05 07 40 	macu.d	r0,r2,r5
8000fe2a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fe2e:	02 04       	add	r4,r1
8000fe30:	5c 05       	acr	r5
8000fe32:	ea 03 15 02 	lsl	r3,r5,0x2
8000fe36:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000fe3a:	e8 02 15 02 	lsl	r2,r4,0x2
8000fe3e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000fe42:	e4 09 07 40 	macu.d	r0,r2,r9
8000fe46:	e6 09 06 44 	mulu.d	r4,r3,r9
8000fe4a:	02 04       	add	r4,r1
8000fe4c:	5c 05       	acr	r5
8000fe4e:	a3 65       	lsl	r5,0x2
8000fe50:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000fe54:	a3 64       	lsl	r4,0x2
8000fe56:	5c 34       	neg	r4
8000fe58:	f8 05 01 45 	sbc	r5,r12,r5
8000fe5c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000fe60:	e4 05 07 40 	macu.d	r0,r2,r5
8000fe64:	e6 05 06 44 	mulu.d	r4,r3,r5
8000fe68:	02 04       	add	r4,r1
8000fe6a:	5c 05       	acr	r5
8000fe6c:	ea 03 15 02 	lsl	r3,r5,0x2
8000fe70:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000fe74:	e8 02 15 02 	lsl	r2,r4,0x2
8000fe78:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000fe7c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000fe80:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000fe84:	02 02       	add	r2,r1
8000fe86:	5c 03       	acr	r3
8000fe88:	ed b3 00 1c 	bld	r3,0x1c
8000fe8c:	c0 90       	breq	8000fe9e <__avr32_f64_div+0x12a>
8000fe8e:	a1 72       	lsl	r2,0x1
8000fe90:	5c f3       	rol	r3
8000fe92:	20 17       	sub	r7,1
8000fe94:	a3 9a       	lsr	r10,0x3
8000fe96:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000fe9a:	a3 9b       	lsr	r11,0x3
8000fe9c:	c0 58       	rjmp	8000fea6 <__avr32_f64_div+0x132>
8000fe9e:	a5 8a       	lsr	r10,0x4
8000fea0:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000fea4:	a5 8b       	lsr	r11,0x4
8000fea6:	58 07       	cp.w	r7,0
8000fea8:	e0 8a 00 8b 	brle	8000ffbe <__avr32_f64_div_res_subnormal>
8000feac:	e0 12 ff 00 	andl	r2,0xff00
8000feb0:	e8 12 00 80 	orl	r2,0x80
8000feb4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000feb8:	e4 09 07 40 	macu.d	r0,r2,r9
8000febc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000fec0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000fec4:	00 05       	add	r5,r0
8000fec6:	f0 01 00 48 	adc	r8,r8,r1
8000feca:	5c 09       	acr	r9
8000fecc:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000fed0:	58 04       	cp.w	r4,0
8000fed2:	5c 25       	cpc	r5

8000fed4 <__avr32_f64_div_round_subnormal>:
8000fed4:	f4 08 13 00 	cpc	r8,r10
8000fed8:	f6 09 13 00 	cpc	r9,r11
8000fedc:	5f 36       	srlo	r6
8000fede:	f8 06 17 00 	moveq	r6,r12
8000fee2:	e4 0a 16 08 	lsr	r10,r2,0x8
8000fee6:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000feea:	e6 0b 16 08 	lsr	r11,r3,0x8
8000feee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000fef2:	ed be 00 1f 	bld	lr,0x1f
8000fef6:	ef bb 00 1f 	bst	r11,0x1f
8000fefa:	0c 0a       	add	r10,r6
8000fefc:	5c 0b       	acr	r11
8000fefe:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000ff02:	e4 1b 00 0f 	andh	r11,0xf
8000ff06:	14 4b       	or	r11,r10
8000ff08:	e0 81 00 a7 	brne	80010056 <__avr32_f64_div_res_subnormal+0x98>
8000ff0c:	f2 06 16 14 	lsr	r6,r9,0x14
8000ff10:	ab d6       	cbr	r6,0xb
8000ff12:	e0 46 07 ff 	cp.w	r6,2047
8000ff16:	e0 81 00 a4 	brne	8001005e <__avr32_f64_div_res_subnormal+0xa0>
8000ff1a:	c9 e8       	rjmp	80010056 <__avr32_f64_div_res_subnormal+0x98>
8000ff1c:	e4 19 00 0f 	andh	r9,0xf
8000ff20:	10 49       	or	r9,r8
8000ff22:	e0 81 00 9a 	brne	80010056 <__avr32_f64_div_res_subnormal+0x98>
8000ff26:	c9 28       	rjmp	8001004a <__avr32_f64_div_res_subnormal+0x8c>
8000ff28:	a3 7b       	lsl	r11,0x3
8000ff2a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000ff2e:	a3 7a       	lsl	r10,0x3
8000ff30:	f5 eb 10 04 	or	r4,r10,r11
8000ff34:	e0 80 00 a0 	breq	80010074 <__avr32_f64_div_op1_zero>
8000ff38:	f6 04 12 00 	clz	r4,r11
8000ff3c:	c1 70       	breq	8000ff6a <__avr32_f64_div_round_subnormal+0x96>
8000ff3e:	c0 c3       	brcs	8000ff56 <__avr32_f64_div_round_subnormal+0x82>
8000ff40:	e8 05 11 20 	rsub	r5,r4,32
8000ff44:	f6 04 09 4b 	lsl	r11,r11,r4
8000ff48:	f4 05 0a 45 	lsr	r5,r10,r5
8000ff4c:	0a 4b       	or	r11,r5
8000ff4e:	f4 04 09 4a 	lsl	r10,r10,r4
8000ff52:	08 17       	sub	r7,r4
8000ff54:	c0 b8       	rjmp	8000ff6a <__avr32_f64_div_round_subnormal+0x96>
8000ff56:	f4 04 12 00 	clz	r4,r10
8000ff5a:	f9 b4 03 00 	movlo	r4,0
8000ff5e:	f7 b4 02 e0 	subhs	r4,-32
8000ff62:	f4 04 09 4b 	lsl	r11,r10,r4
8000ff66:	30 0a       	mov	r10,0
8000ff68:	08 17       	sub	r7,r4
8000ff6a:	a3 8a       	lsr	r10,0x2
8000ff6c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000ff70:	a3 8b       	lsr	r11,0x2
8000ff72:	c1 1b       	rjmp	8000fd94 <__avr32_f64_div+0x20>
8000ff74:	a3 79       	lsl	r9,0x3
8000ff76:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000ff7a:	a3 78       	lsl	r8,0x3
8000ff7c:	f3 e8 10 04 	or	r4,r9,r8
8000ff80:	c6 f0       	breq	8001005e <__avr32_f64_div_res_subnormal+0xa0>
8000ff82:	f2 04 12 00 	clz	r4,r9
8000ff86:	c1 70       	breq	8000ffb4 <__avr32_f64_div_round_subnormal+0xe0>
8000ff88:	c0 c3       	brcs	8000ffa0 <__avr32_f64_div_round_subnormal+0xcc>
8000ff8a:	e8 05 11 20 	rsub	r5,r4,32
8000ff8e:	f2 04 09 49 	lsl	r9,r9,r4
8000ff92:	f0 05 0a 45 	lsr	r5,r8,r5
8000ff96:	0a 49       	or	r9,r5
8000ff98:	f0 04 09 48 	lsl	r8,r8,r4
8000ff9c:	08 16       	sub	r6,r4
8000ff9e:	c0 b8       	rjmp	8000ffb4 <__avr32_f64_div_round_subnormal+0xe0>
8000ffa0:	f0 04 12 00 	clz	r4,r8
8000ffa4:	f9 b4 03 00 	movlo	r4,0
8000ffa8:	f7 b4 02 e0 	subhs	r4,-32
8000ffac:	f0 04 09 49 	lsl	r9,r8,r4
8000ffb0:	30 08       	mov	r8,0
8000ffb2:	08 16       	sub	r6,r4
8000ffb4:	a3 88       	lsr	r8,0x2
8000ffb6:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000ffba:	a3 89       	lsr	r9,0x2
8000ffbc:	cf ca       	rjmp	8000fdb4 <__avr32_f64_div+0x40>

8000ffbe <__avr32_f64_div_res_subnormal>:
8000ffbe:	5c 37       	neg	r7
8000ffc0:	2f f7       	sub	r7,-1
8000ffc2:	f1 b7 04 c0 	satu	r7,0x6
8000ffc6:	e0 47 00 20 	cp.w	r7,32
8000ffca:	c1 54       	brge	8000fff4 <__avr32_f64_div_res_subnormal+0x36>
8000ffcc:	ee 06 11 20 	rsub	r6,r7,32
8000ffd0:	e4 07 0a 42 	lsr	r2,r2,r7
8000ffd4:	e6 06 09 4c 	lsl	r12,r3,r6
8000ffd8:	18 42       	or	r2,r12
8000ffda:	e6 07 0a 43 	lsr	r3,r3,r7
8000ffde:	f4 06 09 41 	lsl	r1,r10,r6
8000ffe2:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ffe6:	f6 06 09 4c 	lsl	r12,r11,r6
8000ffea:	18 4a       	or	r10,r12
8000ffec:	f6 07 0a 4b 	lsr	r11,r11,r7
8000fff0:	30 00       	mov	r0,0
8000fff2:	c1 58       	rjmp	8001001c <__avr32_f64_div_res_subnormal+0x5e>
8000fff4:	ee 06 11 20 	rsub	r6,r7,32
8000fff8:	f9 b0 00 00 	moveq	r0,0
8000fffc:	f9 bc 00 00 	moveq	r12,0
80010000:	c0 50       	breq	8001000a <__avr32_f64_div_res_subnormal+0x4c>
80010002:	f4 06 09 40 	lsl	r0,r10,r6
80010006:	f6 06 09 4c 	lsl	r12,r11,r6
8001000a:	e6 07 0a 42 	lsr	r2,r3,r7
8001000e:	30 03       	mov	r3,0
80010010:	f4 07 0a 41 	lsr	r1,r10,r7
80010014:	18 41       	or	r1,r12
80010016:	f6 07 0a 4a 	lsr	r10,r11,r7
8001001a:	30 0b       	mov	r11,0
8001001c:	e0 12 ff 00 	andl	r2,0xff00
80010020:	e8 12 00 80 	orl	r2,0x80
80010024:	e6 08 06 46 	mulu.d	r6,r3,r8
80010028:	e4 09 07 46 	macu.d	r6,r2,r9
8001002c:	e4 08 06 44 	mulu.d	r4,r2,r8
80010030:	e6 09 06 48 	mulu.d	r8,r3,r9
80010034:	0c 05       	add	r5,r6
80010036:	f0 07 00 48 	adc	r8,r8,r7
8001003a:	5c 09       	acr	r9
8001003c:	30 07       	mov	r7,0
8001003e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
80010042:	00 34       	cp.w	r4,r0
80010044:	e2 05 13 00 	cpc	r5,r1
80010048:	c4 6b       	rjmp	8000fed4 <__avr32_f64_div_round_subnormal>
8001004a:	1c 9b       	mov	r11,lr
8001004c:	e6 1b 80 00 	andh	r11,0x8000,COH
80010050:	30 0a       	mov	r10,0
80010052:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80010056:	3f fb       	mov	r11,-1
80010058:	30 0a       	mov	r10,0
8001005a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8001005e:	f5 eb 10 04 	or	r4,r10,r11
80010062:	c0 90       	breq	80010074 <__avr32_f64_div_op1_zero>
80010064:	1c 9b       	mov	r11,lr
80010066:	e6 1b 80 00 	andh	r11,0x8000,COH
8001006a:	ea 1b 7f f0 	orh	r11,0x7ff0
8001006e:	30 0a       	mov	r10,0
80010070:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

80010074 <__avr32_f64_div_op1_zero>:
80010074:	f1 e9 10 15 	or	r5,r8,r9<<0x1
80010078:	ce f0       	breq	80010056 <__avr32_f64_div_res_subnormal+0x98>
8001007a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8001007e:	e0 44 07 ff 	cp.w	r4,2047
80010082:	ce 41       	brne	8001004a <__avr32_f64_div_res_subnormal+0x8c>
80010084:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
80010088:	ce 10       	breq	8001004a <__avr32_f64_div_res_subnormal+0x8c>
8001008a:	ce 6b       	rjmp	80010056 <__avr32_f64_div_res_subnormal+0x98>

8001008c <__avr32_udiv64>:
8001008c:	d4 31       	pushm	r0-r7,lr
8001008e:	1a 97       	mov	r7,sp
80010090:	20 3d       	sub	sp,12
80010092:	10 9c       	mov	r12,r8
80010094:	12 9e       	mov	lr,r9
80010096:	14 93       	mov	r3,r10
80010098:	58 09       	cp.w	r9,0
8001009a:	e0 81 00 bd 	brne	80010214 <__avr32_udiv64+0x188>
8001009e:	16 38       	cp.w	r8,r11
800100a0:	e0 88 00 40 	brls	80010120 <__avr32_udiv64+0x94>
800100a4:	f0 08 12 00 	clz	r8,r8
800100a8:	c0 d0       	breq	800100c2 <__avr32_udiv64+0x36>
800100aa:	f6 08 09 4b 	lsl	r11,r11,r8
800100ae:	f0 09 11 20 	rsub	r9,r8,32
800100b2:	f8 08 09 4c 	lsl	r12,r12,r8
800100b6:	f4 09 0a 49 	lsr	r9,r10,r9
800100ba:	f4 08 09 43 	lsl	r3,r10,r8
800100be:	f3 eb 10 0b 	or	r11,r9,r11
800100c2:	f8 0e 16 10 	lsr	lr,r12,0x10
800100c6:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
800100ca:	f6 0e 0d 00 	divu	r0,r11,lr
800100ce:	e6 0b 16 10 	lsr	r11,r3,0x10
800100d2:	00 99       	mov	r9,r0
800100d4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800100d8:	e0 0a 02 48 	mul	r8,r0,r10
800100dc:	10 3b       	cp.w	r11,r8
800100de:	c0 a2       	brcc	800100f2 <__avr32_udiv64+0x66>
800100e0:	20 19       	sub	r9,1
800100e2:	18 0b       	add	r11,r12
800100e4:	18 3b       	cp.w	r11,r12
800100e6:	c0 63       	brcs	800100f2 <__avr32_udiv64+0x66>
800100e8:	10 3b       	cp.w	r11,r8
800100ea:	f7 b9 03 01 	sublo	r9,1
800100ee:	f7 dc e3 0b 	addcs	r11,r11,r12
800100f2:	f6 08 01 01 	sub	r1,r11,r8
800100f6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800100fa:	e2 0e 0d 00 	divu	r0,r1,lr
800100fe:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80010102:	00 98       	mov	r8,r0
80010104:	e0 0a 02 4a 	mul	r10,r0,r10
80010108:	14 33       	cp.w	r3,r10
8001010a:	c0 82       	brcc	8001011a <__avr32_udiv64+0x8e>
8001010c:	20 18       	sub	r8,1
8001010e:	18 03       	add	r3,r12
80010110:	18 33       	cp.w	r3,r12
80010112:	c0 43       	brcs	8001011a <__avr32_udiv64+0x8e>
80010114:	14 33       	cp.w	r3,r10
80010116:	f7 b8 03 01 	sublo	r8,1
8001011a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8001011e:	cd f8       	rjmp	800102dc <__avr32_udiv64+0x250>
80010120:	58 08       	cp.w	r8,0
80010122:	c0 51       	brne	8001012c <__avr32_udiv64+0xa0>
80010124:	30 19       	mov	r9,1
80010126:	f2 08 0d 08 	divu	r8,r9,r8
8001012a:	10 9c       	mov	r12,r8
8001012c:	f8 06 12 00 	clz	r6,r12
80010130:	c0 41       	brne	80010138 <__avr32_udiv64+0xac>
80010132:	18 1b       	sub	r11,r12
80010134:	30 19       	mov	r9,1
80010136:	c4 08       	rjmp	800101b6 <__avr32_udiv64+0x12a>
80010138:	ec 01 11 20 	rsub	r1,r6,32
8001013c:	f4 01 0a 49 	lsr	r9,r10,r1
80010140:	f8 06 09 4c 	lsl	r12,r12,r6
80010144:	f6 06 09 48 	lsl	r8,r11,r6
80010148:	f6 01 0a 41 	lsr	r1,r11,r1
8001014c:	f3 e8 10 08 	or	r8,r9,r8
80010150:	f8 03 16 10 	lsr	r3,r12,0x10
80010154:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80010158:	e2 03 0d 00 	divu	r0,r1,r3
8001015c:	f0 0b 16 10 	lsr	r11,r8,0x10
80010160:	00 9e       	mov	lr,r0
80010162:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80010166:	e0 05 02 49 	mul	r9,r0,r5
8001016a:	12 3b       	cp.w	r11,r9
8001016c:	c0 a2       	brcc	80010180 <__avr32_udiv64+0xf4>
8001016e:	20 1e       	sub	lr,1
80010170:	18 0b       	add	r11,r12
80010172:	18 3b       	cp.w	r11,r12
80010174:	c0 63       	brcs	80010180 <__avr32_udiv64+0xf4>
80010176:	12 3b       	cp.w	r11,r9
80010178:	f7 be 03 01 	sublo	lr,1
8001017c:	f7 dc e3 0b 	addcs	r11,r11,r12
80010180:	12 1b       	sub	r11,r9
80010182:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80010186:	f6 03 0d 02 	divu	r2,r11,r3
8001018a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8001018e:	04 99       	mov	r9,r2
80010190:	e4 05 02 4b 	mul	r11,r2,r5
80010194:	16 38       	cp.w	r8,r11
80010196:	c0 a2       	brcc	800101aa <__avr32_udiv64+0x11e>
80010198:	20 19       	sub	r9,1
8001019a:	18 08       	add	r8,r12
8001019c:	18 38       	cp.w	r8,r12
8001019e:	c0 63       	brcs	800101aa <__avr32_udiv64+0x11e>
800101a0:	16 38       	cp.w	r8,r11
800101a2:	f7 b9 03 01 	sublo	r9,1
800101a6:	f1 dc e3 08 	addcs	r8,r8,r12
800101aa:	f4 06 09 43 	lsl	r3,r10,r6
800101ae:	f0 0b 01 0b 	sub	r11,r8,r11
800101b2:	f3 ee 11 09 	or	r9,r9,lr<<0x10
800101b6:	f8 06 16 10 	lsr	r6,r12,0x10
800101ba:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
800101be:	f6 06 0d 00 	divu	r0,r11,r6
800101c2:	e6 0b 16 10 	lsr	r11,r3,0x10
800101c6:	00 9a       	mov	r10,r0
800101c8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800101cc:	e0 0e 02 48 	mul	r8,r0,lr
800101d0:	10 3b       	cp.w	r11,r8
800101d2:	c0 a2       	brcc	800101e6 <__avr32_udiv64+0x15a>
800101d4:	20 1a       	sub	r10,1
800101d6:	18 0b       	add	r11,r12
800101d8:	18 3b       	cp.w	r11,r12
800101da:	c0 63       	brcs	800101e6 <__avr32_udiv64+0x15a>
800101dc:	10 3b       	cp.w	r11,r8
800101de:	f7 ba 03 01 	sublo	r10,1
800101e2:	f7 dc e3 0b 	addcs	r11,r11,r12
800101e6:	f6 08 01 01 	sub	r1,r11,r8
800101ea:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800101ee:	e2 06 0d 00 	divu	r0,r1,r6
800101f2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800101f6:	00 98       	mov	r8,r0
800101f8:	e0 0e 02 4b 	mul	r11,r0,lr
800101fc:	16 33       	cp.w	r3,r11
800101fe:	c0 82       	brcc	8001020e <__avr32_udiv64+0x182>
80010200:	20 18       	sub	r8,1
80010202:	18 03       	add	r3,r12
80010204:	18 33       	cp.w	r3,r12
80010206:	c0 43       	brcs	8001020e <__avr32_udiv64+0x182>
80010208:	16 33       	cp.w	r3,r11
8001020a:	f7 b8 03 01 	sublo	r8,1
8001020e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80010212:	c6 98       	rjmp	800102e4 <__avr32_udiv64+0x258>
80010214:	16 39       	cp.w	r9,r11
80010216:	e0 8b 00 65 	brhi	800102e0 <__avr32_udiv64+0x254>
8001021a:	f2 09 12 00 	clz	r9,r9
8001021e:	c0 b1       	brne	80010234 <__avr32_udiv64+0x1a8>
80010220:	10 3a       	cp.w	r10,r8
80010222:	5f 2a       	srhs	r10
80010224:	1c 3b       	cp.w	r11,lr
80010226:	5f b8       	srhi	r8
80010228:	10 4a       	or	r10,r8
8001022a:	f2 0a 18 00 	cp.b	r10,r9
8001022e:	c5 90       	breq	800102e0 <__avr32_udiv64+0x254>
80010230:	30 18       	mov	r8,1
80010232:	c5 98       	rjmp	800102e4 <__avr32_udiv64+0x258>
80010234:	f0 09 09 46 	lsl	r6,r8,r9
80010238:	f2 03 11 20 	rsub	r3,r9,32
8001023c:	fc 09 09 4e 	lsl	lr,lr,r9
80010240:	f0 03 0a 48 	lsr	r8,r8,r3
80010244:	f6 09 09 4c 	lsl	r12,r11,r9
80010248:	f4 03 0a 42 	lsr	r2,r10,r3
8001024c:	ef 46 ff f4 	st.w	r7[-12],r6
80010250:	f6 03 0a 43 	lsr	r3,r11,r3
80010254:	18 42       	or	r2,r12
80010256:	f1 ee 10 0c 	or	r12,r8,lr
8001025a:	f8 01 16 10 	lsr	r1,r12,0x10
8001025e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80010262:	e6 01 0d 04 	divu	r4,r3,r1
80010266:	e4 03 16 10 	lsr	r3,r2,0x10
8001026a:	08 9e       	mov	lr,r4
8001026c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80010270:	e8 06 02 48 	mul	r8,r4,r6
80010274:	10 33       	cp.w	r3,r8
80010276:	c0 a2       	brcc	8001028a <__avr32_udiv64+0x1fe>
80010278:	20 1e       	sub	lr,1
8001027a:	18 03       	add	r3,r12
8001027c:	18 33       	cp.w	r3,r12
8001027e:	c0 63       	brcs	8001028a <__avr32_udiv64+0x1fe>
80010280:	10 33       	cp.w	r3,r8
80010282:	f7 be 03 01 	sublo	lr,1
80010286:	e7 dc e3 03 	addcs	r3,r3,r12
8001028a:	10 13       	sub	r3,r8
8001028c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80010290:	e6 01 0d 00 	divu	r0,r3,r1
80010294:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80010298:	00 98       	mov	r8,r0
8001029a:	e0 06 02 46 	mul	r6,r0,r6
8001029e:	0c 3b       	cp.w	r11,r6
800102a0:	c0 a2       	brcc	800102b4 <__avr32_udiv64+0x228>
800102a2:	20 18       	sub	r8,1
800102a4:	18 0b       	add	r11,r12
800102a6:	18 3b       	cp.w	r11,r12
800102a8:	c0 63       	brcs	800102b4 <__avr32_udiv64+0x228>
800102aa:	0c 3b       	cp.w	r11,r6
800102ac:	f7 dc e3 0b 	addcs	r11,r11,r12
800102b0:	f7 b8 03 01 	sublo	r8,1
800102b4:	f1 ee 11 08 	or	r8,r8,lr<<0x10
800102b8:	ee f4 ff f4 	ld.w	r4,r7[-12]
800102bc:	0c 1b       	sub	r11,r6
800102be:	f0 04 06 42 	mulu.d	r2,r8,r4
800102c2:	06 95       	mov	r5,r3
800102c4:	16 35       	cp.w	r5,r11
800102c6:	e0 8b 00 0a 	brhi	800102da <__avr32_udiv64+0x24e>
800102ca:	5f 0b       	sreq	r11
800102cc:	f4 09 09 49 	lsl	r9,r10,r9
800102d0:	12 32       	cp.w	r2,r9
800102d2:	5f b9       	srhi	r9
800102d4:	f7 e9 00 09 	and	r9,r11,r9
800102d8:	c0 60       	breq	800102e4 <__avr32_udiv64+0x258>
800102da:	20 18       	sub	r8,1
800102dc:	30 09       	mov	r9,0
800102de:	c0 38       	rjmp	800102e4 <__avr32_udiv64+0x258>
800102e0:	30 09       	mov	r9,0
800102e2:	12 98       	mov	r8,r9
800102e4:	10 9a       	mov	r10,r8
800102e6:	12 93       	mov	r3,r9
800102e8:	10 92       	mov	r2,r8
800102ea:	12 9b       	mov	r11,r9
800102ec:	2f dd       	sub	sp,-12
800102ee:	d8 32       	popm	r0-r7,pc

800102f0 <__avr32_umod64>:
800102f0:	d4 31       	pushm	r0-r7,lr
800102f2:	1a 97       	mov	r7,sp
800102f4:	20 3d       	sub	sp,12
800102f6:	10 9c       	mov	r12,r8
800102f8:	12 95       	mov	r5,r9
800102fa:	14 9e       	mov	lr,r10
800102fc:	16 91       	mov	r1,r11
800102fe:	16 96       	mov	r6,r11
80010300:	58 09       	cp.w	r9,0
80010302:	e0 81 00 81 	brne	80010404 <__avr32_umod64+0x114>
80010306:	16 38       	cp.w	r8,r11
80010308:	e0 88 00 12 	brls	8001032c <__avr32_umod64+0x3c>
8001030c:	f0 08 12 00 	clz	r8,r8
80010310:	c4 e0       	breq	800103ac <__avr32_umod64+0xbc>
80010312:	f6 08 09 46 	lsl	r6,r11,r8
80010316:	f8 08 09 4c 	lsl	r12,r12,r8
8001031a:	f0 0b 11 20 	rsub	r11,r8,32
8001031e:	f4 08 09 4e 	lsl	lr,r10,r8
80010322:	f4 0b 0a 4b 	lsr	r11,r10,r11
80010326:	f7 e6 10 06 	or	r6,r11,r6
8001032a:	c4 18       	rjmp	800103ac <__avr32_umod64+0xbc>
8001032c:	58 08       	cp.w	r8,0
8001032e:	c0 51       	brne	80010338 <__avr32_umod64+0x48>
80010330:	30 19       	mov	r9,1
80010332:	f2 08 0d 08 	divu	r8,r9,r8
80010336:	10 9c       	mov	r12,r8
80010338:	f8 08 12 00 	clz	r8,r12
8001033c:	c0 31       	brne	80010342 <__avr32_umod64+0x52>
8001033e:	18 16       	sub	r6,r12
80010340:	c3 68       	rjmp	800103ac <__avr32_umod64+0xbc>
80010342:	f0 03 11 20 	rsub	r3,r8,32
80010346:	f4 03 0a 4b 	lsr	r11,r10,r3
8001034a:	f8 08 09 4c 	lsl	r12,r12,r8
8001034e:	ec 08 09 49 	lsl	r9,r6,r8
80010352:	ec 03 0a 43 	lsr	r3,r6,r3
80010356:	f7 e9 10 09 	or	r9,r11,r9
8001035a:	f8 05 16 10 	lsr	r5,r12,0x10
8001035e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80010362:	e6 05 0d 02 	divu	r2,r3,r5
80010366:	f2 0e 16 10 	lsr	lr,r9,0x10
8001036a:	ec 02 02 4b 	mul	r11,r6,r2
8001036e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
80010372:	16 3e       	cp.w	lr,r11
80010374:	c0 72       	brcc	80010382 <__avr32_umod64+0x92>
80010376:	18 0e       	add	lr,r12
80010378:	18 3e       	cp.w	lr,r12
8001037a:	c0 43       	brcs	80010382 <__avr32_umod64+0x92>
8001037c:	16 3e       	cp.w	lr,r11
8001037e:	fd dc e3 0e 	addcs	lr,lr,r12
80010382:	fc 0b 01 03 	sub	r3,lr,r11
80010386:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8001038a:	e6 05 0d 02 	divu	r2,r3,r5
8001038e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
80010392:	a5 36       	mul	r6,r2
80010394:	0c 39       	cp.w	r9,r6
80010396:	c0 72       	brcc	800103a4 <__avr32_umod64+0xb4>
80010398:	18 09       	add	r9,r12
8001039a:	18 39       	cp.w	r9,r12
8001039c:	c0 43       	brcs	800103a4 <__avr32_umod64+0xb4>
8001039e:	0c 39       	cp.w	r9,r6
800103a0:	f3 dc e3 09 	addcs	r9,r9,r12
800103a4:	f2 06 01 06 	sub	r6,r9,r6
800103a8:	f4 08 09 4e 	lsl	lr,r10,r8
800103ac:	f8 0a 16 10 	lsr	r10,r12,0x10
800103b0:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800103b4:	ec 0a 0d 02 	divu	r2,r6,r10
800103b8:	fc 09 16 10 	lsr	r9,lr,0x10
800103bc:	ea 02 02 4b 	mul	r11,r5,r2
800103c0:	f3 e3 11 09 	or	r9,r9,r3<<0x10
800103c4:	16 39       	cp.w	r9,r11
800103c6:	c0 72       	brcc	800103d4 <__avr32_umod64+0xe4>
800103c8:	18 09       	add	r9,r12
800103ca:	18 39       	cp.w	r9,r12
800103cc:	c0 43       	brcs	800103d4 <__avr32_umod64+0xe4>
800103ce:	16 39       	cp.w	r9,r11
800103d0:	f3 dc e3 09 	addcs	r9,r9,r12
800103d4:	f2 0b 01 0b 	sub	r11,r9,r11
800103d8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800103dc:	f6 0a 0d 0a 	divu	r10,r11,r10
800103e0:	fd eb 11 0e 	or	lr,lr,r11<<0x10
800103e4:	ea 0a 02 4a 	mul	r10,r5,r10
800103e8:	14 3e       	cp.w	lr,r10
800103ea:	c0 72       	brcc	800103f8 <__avr32_umod64+0x108>
800103ec:	18 0e       	add	lr,r12
800103ee:	18 3e       	cp.w	lr,r12
800103f0:	c0 43       	brcs	800103f8 <__avr32_umod64+0x108>
800103f2:	14 3e       	cp.w	lr,r10
800103f4:	fd dc e3 0e 	addcs	lr,lr,r12
800103f8:	fc 0a 01 0a 	sub	r10,lr,r10
800103fc:	30 0b       	mov	r11,0
800103fe:	f4 08 0a 4a 	lsr	r10,r10,r8
80010402:	c7 b8       	rjmp	800104f8 <__avr32_umod64+0x208>
80010404:	16 39       	cp.w	r9,r11
80010406:	e0 8b 00 79 	brhi	800104f8 <__avr32_umod64+0x208>
8001040a:	f2 09 12 00 	clz	r9,r9
8001040e:	c1 21       	brne	80010432 <__avr32_umod64+0x142>
80010410:	10 3a       	cp.w	r10,r8
80010412:	5f 2b       	srhs	r11
80010414:	0a 31       	cp.w	r1,r5
80010416:	5f ba       	srhi	r10
80010418:	f7 ea 10 0a 	or	r10,r11,r10
8001041c:	f2 0a 18 00 	cp.b	r10,r9
80010420:	c0 60       	breq	8001042c <__avr32_umod64+0x13c>
80010422:	fc 08 01 0c 	sub	r12,lr,r8
80010426:	e2 05 01 46 	sbc	r6,r1,r5
8001042a:	18 9e       	mov	lr,r12
8001042c:	0c 9b       	mov	r11,r6
8001042e:	1c 9a       	mov	r10,lr
80010430:	c6 48       	rjmp	800104f8 <__avr32_umod64+0x208>
80010432:	ea 09 09 4c 	lsl	r12,r5,r9
80010436:	f2 06 11 20 	rsub	r6,r9,32
8001043a:	f6 09 09 4b 	lsl	r11,r11,r9
8001043e:	f0 09 09 42 	lsl	r2,r8,r9
80010442:	ef 46 ff f4 	st.w	r7[-12],r6
80010446:	f0 06 0a 48 	lsr	r8,r8,r6
8001044a:	18 48       	or	r8,r12
8001044c:	e2 06 0a 4c 	lsr	r12,r1,r6
80010450:	f4 09 09 43 	lsl	r3,r10,r9
80010454:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
80010458:	f4 06 0a 4a 	lsr	r10,r10,r6
8001045c:	16 4a       	or	r10,r11
8001045e:	f0 0b 16 10 	lsr	r11,r8,0x10
80010462:	f8 0b 0d 04 	divu	r4,r12,r11
80010466:	f4 0c 16 10 	lsr	r12,r10,0x10
8001046a:	08 91       	mov	r1,r4
8001046c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
80010470:	e8 0e 02 46 	mul	r6,r4,lr
80010474:	0c 3c       	cp.w	r12,r6
80010476:	c0 a2       	brcc	8001048a <__avr32_umod64+0x19a>
80010478:	20 11       	sub	r1,1
8001047a:	10 0c       	add	r12,r8
8001047c:	10 3c       	cp.w	r12,r8
8001047e:	c0 63       	brcs	8001048a <__avr32_umod64+0x19a>
80010480:	0c 3c       	cp.w	r12,r6
80010482:	f7 b1 03 01 	sublo	r1,1
80010486:	f9 d8 e3 0c 	addcs	r12,r12,r8
8001048a:	0c 1c       	sub	r12,r6
8001048c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
80010490:	f8 0b 0d 04 	divu	r4,r12,r11
80010494:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
80010498:	08 96       	mov	r6,r4
8001049a:	e8 0e 02 4e 	mul	lr,r4,lr
8001049e:	1c 3b       	cp.w	r11,lr
800104a0:	c0 a2       	brcc	800104b4 <__avr32_umod64+0x1c4>
800104a2:	20 16       	sub	r6,1
800104a4:	10 0b       	add	r11,r8
800104a6:	10 3b       	cp.w	r11,r8
800104a8:	c0 63       	brcs	800104b4 <__avr32_umod64+0x1c4>
800104aa:	1c 3b       	cp.w	r11,lr
800104ac:	f7 b6 03 01 	sublo	r6,1
800104b0:	f7 d8 e3 0b 	addcs	r11,r11,r8
800104b4:	ed e1 11 01 	or	r1,r6,r1<<0x10
800104b8:	1c 1b       	sub	r11,lr
800104ba:	e2 02 06 40 	mulu.d	r0,r1,r2
800104be:	00 9e       	mov	lr,r0
800104c0:	02 9c       	mov	r12,r1
800104c2:	16 3c       	cp.w	r12,r11
800104c4:	e0 8b 00 08 	brhi	800104d4 <__avr32_umod64+0x1e4>
800104c8:	5f 06       	sreq	r6
800104ca:	06 30       	cp.w	r0,r3
800104cc:	5f ba       	srhi	r10
800104ce:	ed ea 00 0a 	and	r10,r6,r10
800104d2:	c0 60       	breq	800104de <__avr32_umod64+0x1ee>
800104d4:	fc 02 01 04 	sub	r4,lr,r2
800104d8:	f8 08 01 4c 	sbc	r12,r12,r8
800104dc:	08 9e       	mov	lr,r4
800104de:	e6 0e 01 0a 	sub	r10,r3,lr
800104e2:	f6 0c 01 4c 	sbc	r12,r11,r12
800104e6:	ee f1 ff f4 	ld.w	r1,r7[-12]
800104ea:	f8 09 0a 4b 	lsr	r11,r12,r9
800104ee:	f4 09 0a 4a 	lsr	r10,r10,r9
800104f2:	f8 01 09 4c 	lsl	r12,r12,r1
800104f6:	18 4a       	or	r10,r12
800104f8:	2f dd       	sub	sp,-12
800104fa:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

80010600 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
80010600:	c0 08       	rjmp	80010600 <_evba>
	...

80010604 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
80010604:	c0 08       	rjmp	80010604 <_handle_TLB_Multiple_Hit>
	...

80010608 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
80010608:	c0 08       	rjmp	80010608 <_handle_Bus_Error_Data_Fetch>
	...

8001060c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8001060c:	c0 08       	rjmp	8001060c <_handle_Bus_Error_Instruction_Fetch>
	...

80010610 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
80010610:	c0 08       	rjmp	80010610 <_handle_NMI>
	...

80010614 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
80010614:	c0 08       	rjmp	80010614 <_handle_Instruction_Address>
	...

80010618 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
80010618:	c0 08       	rjmp	80010618 <_handle_ITLB_Protection>
	...

8001061c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8001061c:	c0 08       	rjmp	8001061c <_handle_Breakpoint>
	...

80010620 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
80010620:	c0 08       	rjmp	80010620 <_handle_Illegal_Opcode>
	...

80010624 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
80010624:	c0 08       	rjmp	80010624 <_handle_Unimplemented_Instruction>
	...

80010628 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
80010628:	c0 08       	rjmp	80010628 <_handle_Privilege_Violation>
	...

8001062c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8001062c:	c0 08       	rjmp	8001062c <_handle_Floating_Point>
	...

80010630 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
80010630:	c0 08       	rjmp	80010630 <_handle_Coprocessor_Absent>
	...

80010634 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
80010634:	c0 08       	rjmp	80010634 <_handle_Data_Address_Read>
	...

80010638 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
80010638:	c0 08       	rjmp	80010638 <_handle_Data_Address_Write>
	...

8001063c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8001063c:	c0 08       	rjmp	8001063c <_handle_DTLB_Protection_Read>
	...

80010640 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
80010640:	c0 08       	rjmp	80010640 <_handle_DTLB_Protection_Write>
	...

80010644 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
80010644:	c0 08       	rjmp	80010644 <_handle_DTLB_Modified>
	...

80010650 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
80010650:	c0 08       	rjmp	80010650 <_handle_ITLB_Miss>
	...

80010660 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
80010660:	c0 08       	rjmp	80010660 <_handle_DTLB_Miss_Read>
	...

80010670 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
80010670:	c0 08       	rjmp	80010670 <_handle_DTLB_Miss_Write>
	...

80010700 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80010700:	49 3f       	lddpc	pc,8001074c <ipr_val+0x10>
80010702:	d7 03       	nop

80010704 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80010704:	30 0c       	mov	r12,0
80010706:	fe b0 b5 c9 	rcall	80007298 <_get_interrupt_handler>
8001070a:	58 0c       	cp.w	r12,0
8001070c:	f8 0f 17 10 	movne	pc,r12
80010710:	d6 03       	rete

80010712 <_int1>:
80010712:	30 1c       	mov	r12,1
80010714:	fe b0 b5 c2 	rcall	80007298 <_get_interrupt_handler>
80010718:	58 0c       	cp.w	r12,0
8001071a:	f8 0f 17 10 	movne	pc,r12
8001071e:	d6 03       	rete

80010720 <_int2>:
80010720:	30 2c       	mov	r12,2
80010722:	fe b0 b5 bb 	rcall	80007298 <_get_interrupt_handler>
80010726:	58 0c       	cp.w	r12,0
80010728:	f8 0f 17 10 	movne	pc,r12
8001072c:	d6 03       	rete

8001072e <_int3>:
8001072e:	30 3c       	mov	r12,3
80010730:	fe b0 b5 b4 	rcall	80007298 <_get_interrupt_handler>
80010734:	58 0c       	cp.w	r12,0
80010736:	f8 0f 17 10 	movne	pc,r12
8001073a:	d6 03       	rete

8001073c <ipr_val>:
8001073c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8001074c:	80 00 84 88 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001075c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001076c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001077c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001078c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8001079c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800107ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800107bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800107cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800107dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800107ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
800107fc:	d7 03 d7 03                                         ....
