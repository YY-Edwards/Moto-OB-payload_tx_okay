
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a054  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c200  8000c200  0000c600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001138  8000c400  8000c400  0000c800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a2c  00000008  8000d538  0000dc08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a34  8000df64  0000e634  2**0
                  ALLOC
  8 .bss          000036e8  00000a38  00000a38  00000000  2**2
                  ALLOC
  9 .heap         00012ee0  00004120  00004120  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000e634  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001158  00000000  00000000  0000e668  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000024f9  00000000  00000000  0000f7c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00028356  00000000  00000000  00011cb9  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00006793  00000000  00000000  0003a00f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c194  00000000  00000000  000407a2  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002d24  00000000  00000000  0004c938  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006cf5  00000000  00000000  0004f65c  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000c9e8  00000000  00000000  00056351  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001240  00000000  00000000  00062d40  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 98 c8 	sub	pc,pc,-26424

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b8 cc 	sub	pc,pc,-18228

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 98       	ld.ub	r8,r6[0x1]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 54       	eor	r4,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 20       	sub	r0,18
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 18       	sub	r8,-127
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 e8       	sub	r8,-114
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3e 64       	mov	r4,-26
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c4 00       	breq	80002106 <app_cfg+0x72>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	5e ac       	retle	r12
80002090:	00 00       	add	r0,r0
80002092:	0a 3c       	cp.w	r12,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 1a 	mcall	800020fc <app_cfg+0x68>
8000209a:	49 a8       	lddpc	r8,80002100 <app_cfg+0x6c>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 a6       	lddpc	r6,80002104 <app_cfg+0x70>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 a4       	lddpc	r4,80002108 <app_cfg+0x74>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 41       	mov	r1,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 32       	mov	r2,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 20       	mov	r0,2
					xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 07 d0 	mov	r5,2000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 d1       	brne	800020f2 <app_cfg+0x5e>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020ba:	68 08       	ld.w	r8,r4[0x0]
800020bc:	58 08       	cp.w	r8,0
800020be:	c0 71       	brne	800020cc <app_cfg+0x38>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
800020c0:	f0 1f 00 13 	mcall	8000210c <app_cfg+0x78>
					xcmp_enter_enhanced_OB_mode();
800020c4:	f0 1f 00 13 	mcall	80002110 <app_cfg+0x7c>
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c8:	89 03       	st.w	r4[0x0],r3
800020ca:	c1 48       	rjmp	800020f2 <app_cfg+0x5e>
				}
				else if(isAudioRouting == 1)
800020cc:	58 18       	cp.w	r8,1
800020ce:	c0 71       	brne	800020dc <app_cfg+0x48>
				{
					xcmp_exit_device_control_mode();
800020d0:	f0 1f 00 11 	mcall	80002114 <app_cfg+0x80>
					xcmp_audio_route_AMBE();
800020d4:	f0 1f 00 11 	mcall	80002118 <app_cfg+0x84>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020d8:	89 00       	st.w	r4[0x0],r0
800020da:	c0 c8       	rjmp	800020f2 <app_cfg+0x5e>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020dc:	58 28       	cp.w	r8,2
800020de:	c0 31       	brne	800020e4 <app_cfg+0x50>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020e0:	89 02       	st.w	r4[0x0],r2
800020e2:	c0 88       	rjmp	800020f2 <app_cfg+0x5e>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020e4:	58 38       	cp.w	r8,3
800020e6:	e9 f1 0a 00 	st.weq	r4[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
800020ea:	f7 b8 01 ff 	subne	r8,-1
800020ee:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020f2:	0a 9b       	mov	r11,r5
800020f4:	0e 9c       	mov	r12,r7
800020f6:	f0 1f 00 0a 	mcall	8000211c <app_cfg+0x88>
	}
800020fa:	cd bb       	rjmp	800020b0 <app_cfg+0x1c>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	5b e4       	cp.w	r4,-2
80002100:	00 00       	add	r0,r0
80002102:	0a 48       	or	r8,r5
80002104:	00 00       	add	r0,r0
80002106:	0d 98       	ld.ub	r8,r6[0x1]
80002108:	00 00       	add	r0,r0
8000210a:	0a 44       	or	r4,r5
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	3e e8       	mov	r8,-18
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	3f 74       	mov	r4,-9
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	3e b8       	mov	r8,-21
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	3f 14       	mov	r4,-15
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	5d 4c       	*unknown*

80002120 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002120:	d4 01       	pushm	lr
  log("R");
80002122:	48 3c       	lddpc	r12,8000212c <app_payload_tx_proc+0xc>
80002124:	f0 1f 00 03 	mcall	80002130 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002128:	d8 02       	popm	pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	c4 08       	rjmp	800021ae <EnOB_reply_func+0x2a>
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	62 70       	ld.w	r0,r1[0x1c]

80002134 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002134:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002136:	48 3c       	lddpc	r12,80002140 <FD_brdcst_func+0xc>
80002138:	f0 1f 00 03 	mcall	80002144 <FD_brdcst_func+0x10>
	
}
8000213c:	d8 02       	popm	pc
8000213e:	00 00       	add	r0,r0
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	c4 0c       	rcall	800021c2 <EnOB_reply_func+0x3e>
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	62 70       	ld.w	r0,r1[0x1c]

80002148 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002148:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000214a:	48 3c       	lddpc	r12,80002154 <FD_reply_func+0xc>
8000214c:	f0 1f 00 03 	mcall	80002158 <FD_reply_func+0x10>
	
	
}
80002150:	d8 02       	popm	pc
80002152:	00 00       	add	r0,r0
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	c4 2c       	rcall	800021da <EnOB_reply_func+0x56>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	62 70       	ld.w	r0,r1[0x1c]

8000215c <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
8000215c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
8000215e:	48 3c       	lddpc	r12,80002168 <FD_request_func+0xc>
80002160:	f0 1f 00 03 	mcall	8000216c <FD_request_func+0x10>
	
	
}
80002164:	d8 02       	popm	pc
80002166:	00 00       	add	r0,r0
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	c4 48       	rjmp	800021f2 <EnOB_reply_func+0x6e>
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	62 70       	ld.w	r0,r1[0x1c]

80002170 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002170:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002172:	48 3c       	lddpc	r12,8000217c <EnOB_brdcst_func+0xc>
80002174:	f0 1f 00 03 	mcall	80002180 <EnOB_brdcst_func+0x10>
}
80002178:	d8 02       	popm	pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	c4 64       	brge	8000220a <SingleDetection_brdcst_func+0x16>
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	62 70       	ld.w	r0,r1[0x1c]

80002184 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002184:	eb cd 40 80 	pushm	r7,lr
80002188:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000218a:	19 a9       	ld.ub	r9,r12[0x2]
8000218c:	30 08       	mov	r8,0
8000218e:	f0 09 18 00 	cp.b	r9,r8
80002192:	c1 91       	brne	800021c4 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002194:	19 b8       	ld.ub	r8,r12[0x3]
80002196:	30 19       	mov	r9,1
80002198:	f2 08 18 00 	cp.b	r8,r9
8000219c:	c0 61       	brne	800021a8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000219e:	49 0c       	lddpc	r12,800021dc <EnOB_reply_func+0x58>
800021a0:	f0 1f 00 10 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021a4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021a8:	58 08       	cp.w	r8,0
800021aa:	c0 61       	brne	800021b6 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021ac:	48 ec       	lddpc	r12,800021e4 <EnOB_reply_func+0x60>
800021ae:	f0 1f 00 0d 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021b2:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021b6:	1a d8       	st.w	--sp,r8
800021b8:	48 cc       	lddpc	r12,800021e8 <EnOB_reply_func+0x64>
800021ba:	f0 1f 00 0a 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021be:	2f fd       	sub	sp,-4
800021c0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021c4:	48 ac       	lddpc	r12,800021ec <EnOB_reply_func+0x68>
800021c6:	f0 1f 00 07 	mcall	800021e0 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021ca:	0f a8       	ld.ub	r8,r7[0x2]
800021cc:	1a d8       	st.w	--sp,r8
800021ce:	48 9c       	lddpc	r12,800021f0 <EnOB_reply_func+0x6c>
800021d0:	f0 1f 00 04 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021d4:	2f fd       	sub	sp,-4
800021d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800021da:	00 00       	add	r0,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	c4 7c       	rcall	8000226c <ButtonConfig_brdcst_func+0x5c>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	62 70       	ld.w	r0,r1[0x1c]
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	c4 94       	brge	80002278 <ButtonConfig_brdcst_func+0x68>
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	c4 a8       	rjmp	8000227e <ButtonConfig_brdcst_func+0x6e>
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	c4 c0       	breq	80002286 <ButtonConfig_brdcst_func+0x76>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	c4 dc       	rcall	8000228c <ButtonConfig_brdcst_func+0x7c>

800021f4 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021f6:	19 a9       	ld.ub	r9,r12[0x2]
800021f8:	31 18       	mov	r8,17
800021fa:	f0 09 18 00 	cp.b	r9,r8
800021fe:	c0 41       	brne	80002206 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002200:	48 2c       	lddpc	r12,80002208 <SingleDetection_brdcst_func+0x14>
80002202:	f0 1f 00 03 	mcall	8000220c <SingleDetection_brdcst_func+0x18>
80002206:	d8 02       	popm	pc
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	c4 f4       	brge	800022a8 <ButtonConfig_brdcst_func+0x98>
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	62 70       	ld.w	r0,r1[0x1c]

80002210 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002210:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002212:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002216:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002218:	4a bc       	lddpc	r12,800022c4 <ButtonConfig_brdcst_func+0xb4>
8000221a:	f0 1f 00 2c 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000221e:	0f 88       	ld.ub	r8,r7[0x0]
80002220:	1a d8       	st.w	--sp,r8
80002222:	4a bc       	lddpc	r12,800022cc <ButtonConfig_brdcst_func+0xbc>
80002224:	f0 1f 00 29 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002228:	1a d5       	st.w	--sp,r5
8000222a:	4a ac       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xc0>
8000222c:	f0 1f 00 27 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002230:	0f a8       	ld.ub	r8,r7[0x2]
80002232:	1a d8       	st.w	--sp,r8
80002234:	4a 8c       	lddpc	r12,800022d4 <ButtonConfig_brdcst_func+0xc4>
80002236:	f0 1f 00 25 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000223a:	2f dd       	sub	sp,-12
8000223c:	58 05       	cp.w	r5,0
8000223e:	c4 10       	breq	800022c0 <ButtonConfig_brdcst_func+0xb0>
80002240:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002242:	4a 64       	lddpc	r4,800022d8 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002244:	4a 63       	lddpc	r3,800022dc <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002246:	4a 72       	lddpc	r2,800022e0 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002248:	4a 71       	lddpc	r1,800022e4 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000224a:	4a 80       	lddpc	r0,800022e8 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000224c:	0f b9       	ld.ub	r9,r7[0x3]
8000224e:	0f c8       	ld.ub	r8,r7[0x4]
80002250:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002254:	1a d8       	st.w	--sp,r8
80002256:	1a d6       	st.w	--sp,r6
80002258:	08 9c       	mov	r12,r4
8000225a:	f0 1f 00 1c 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225e:	0f d9       	ld.ub	r9,r7[0x5]
80002260:	0f e8       	ld.ub	r8,r7[0x6]
80002262:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002266:	1a d8       	st.w	--sp,r8
80002268:	1a d6       	st.w	--sp,r6
8000226a:	06 9c       	mov	r12,r3
8000226c:	f0 1f 00 17 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002270:	0f f9       	ld.ub	r9,r7[0x7]
80002272:	ef 38 00 08 	ld.ub	r8,r7[8]
80002276:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227a:	1a d8       	st.w	--sp,r8
8000227c:	1a d6       	st.w	--sp,r6
8000227e:	04 9c       	mov	r12,r2
80002280:	f0 1f 00 12 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002284:	ef 39 00 09 	ld.ub	r9,r7[9]
80002288:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000228c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002290:	1a d8       	st.w	--sp,r8
80002292:	1a d6       	st.w	--sp,r6
80002294:	02 9c       	mov	r12,r1
80002296:	f0 1f 00 0d 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000229a:	2f 8d       	sub	sp,-32
8000229c:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022a0:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022a4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a8:	1a d8       	st.w	--sp,r8
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	00 9c       	mov	r12,r0
800022ae:	f0 1f 00 07 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
800022b2:	2f f6       	sub	r6,-1
800022b4:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022b6:	2f ed       	sub	sp,-8
800022b8:	ec 05 18 00 	cp.b	r5,r6
800022bc:	fe 9b ff c8 	brhi	8000224c <ButtonConfig_brdcst_func+0x3c>
800022c0:	d8 32       	popm	r0-r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	c5 08       	rjmp	80002366 <ButtonConfig_reply_func+0x2>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	62 70       	ld.w	r0,r1[0x1c]
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c5 28       	rjmp	80002372 <ButtonConfig_reply_func+0xe>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c5 3c       	rcall	80002378 <ButtonConfig_reply_func+0x14>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c5 54       	brge	80002380 <ButtonConfig_reply_func+0x1c>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c5 74       	brge	80002388 <ButtonConfig_reply_func+0x24>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c5 9c       	rcall	80002390 <ButtonConfig_reply_func+0x2c>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c5 c4       	brge	8000239a <ButtonConfig_reply_func+0x36>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c5 e8       	rjmp	800023a2 <ButtonConfig_reply_func+0x3e>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c6 10       	breq	800023ac <DataSession_brdcst_func+0x4>

800022ec <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022ec:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022f0:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022f2:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022f4:	19 c7       	ld.ub	r7,r12[0x4]
800022f6:	19 d8       	ld.ub	r8,r12[0x5]
800022f8:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022fc:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022fe:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002300:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002304:	49 0c       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x58>
80002306:	f0 1f 00 11 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000230a:	1a d6       	st.w	--sp,r6
8000230c:	49 0c       	lddpc	r12,8000234c <Phyuserinput_brdcst_func+0x60>
8000230e:	f0 1f 00 0f 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002312:	1a d5       	st.w	--sp,r5
80002314:	48 fc       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x64>
80002316:	f0 1f 00 0d 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000231a:	5c 77       	castu.h	r7
8000231c:	1a d7       	st.w	--sp,r7
8000231e:	48 ec       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x68>
80002320:	f0 1f 00 0a 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002324:	1a d4       	st.w	--sp,r4
80002326:	48 dc       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x6c>
80002328:	f0 1f 00 08 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
8000232c:	1a d3       	st.w	--sp,r3
8000232e:	48 cc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x70>
80002330:	f0 1f 00 06 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002334:	1a d2       	st.w	--sp,r2
80002336:	48 bc       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x74>
80002338:	f0 1f 00 04 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
8000233c:	2f ad       	sub	sp,-24
	
	
	
	
	
}
8000233e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002342:	00 00       	add	r0,r0
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	c6 34       	brge	8000240c <DataSession_brdcst_func+0x64>
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	62 70       	ld.w	r0,r1[0x1c]
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	c6 58       	rjmp	80002418 <DataSession_brdcst_func+0x70>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c6 70       	breq	80002420 <DataSession_brdcst_func+0x78>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	c6 84       	brge	80002426 <DataSession_brdcst_func+0x7e>
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	c6 98       	rjmp	8000242c <DataSession_reply_func>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	c6 ac       	rcall	80002432 <DataSession_reply_func+0x6>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	c6 cc       	rcall	8000243a <DataSession_reply_func+0xe>

80002364 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002364:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002368:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000236c:	0f 89       	ld.ub	r9,r7[0x0]
8000236e:	30 08       	mov	r8,0
80002370:	f0 09 18 00 	cp.b	r9,r8
80002374:	c0 c1       	brne	8000238c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002376:	48 9c       	lddpc	r12,80002398 <ButtonConfig_reply_func+0x34>
80002378:	f0 1f 00 09 	mcall	8000239c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000237c:	0f 98       	ld.ub	r8,r7[0x1]
8000237e:	1a d8       	st.w	--sp,r8
80002380:	48 8c       	lddpc	r12,800023a0 <ButtonConfig_reply_func+0x3c>
80002382:	f0 1f 00 07 	mcall	8000239c <ButtonConfig_reply_func+0x38>
80002386:	2f fd       	sub	sp,-4
80002388:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000238c:	48 6c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x40>
8000238e:	f0 1f 00 04 	mcall	8000239c <ButtonConfig_reply_func+0x38>
80002392:	e3 cd 80 80 	ldm	sp++,r7,pc
80002396:	00 00       	add	r0,r0
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	c6 ec       	rcall	80002476 <DataSession_reply_func+0x4a>
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	62 70       	ld.w	r0,r1[0x1c]
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	c5 28       	rjmp	80002446 <DataSession_reply_func+0x1a>
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	c7 04       	brge	80002486 <CallControl_brdcst_func+0x2>

800023a8 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023a8:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023aa:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023ae:	0d 88       	ld.ub	r8,r6[0x0]
800023b0:	32 49       	mov	r9,36
800023b2:	f2 08 18 00 	cp.b	r8,r9
800023b6:	c2 91       	brne	80002408 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023b8:	49 7c       	lddpc	r12,80002414 <DataSession_brdcst_func+0x6c>
800023ba:	f0 1f 00 18 	mcall	80002418 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023be:	0d a5       	ld.ub	r5,r6[0x2]
800023c0:	0d b8       	ld.ub	r8,r6[0x3]
800023c2:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023c6:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023c8:	0d 98       	ld.ub	r8,r6[0x1]
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	49 4c       	lddpc	r12,8000241c <DataSession_brdcst_func+0x74>
800023ce:	f0 1f 00 13 	mcall	80002418 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023d2:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023d6:	1a d8       	st.w	--sp,r8
800023d8:	49 2c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x78>
800023da:	f0 1f 00 10 	mcall	80002418 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023de:	2f ed       	sub	sp,-8
800023e0:	58 05       	cp.w	r5,0
800023e2:	c1 80       	breq	80002412 <DataSession_brdcst_func+0x6a>
800023e4:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023e6:	49 04       	lddpc	r4,80002424 <DataSession_brdcst_func+0x7c>
800023e8:	ec 07 00 08 	add	r8,r6,r7
800023ec:	11 c8       	ld.ub	r8,r8[0x4]
800023ee:	1a d8       	st.w	--sp,r8
800023f0:	1a d7       	st.w	--sp,r7
800023f2:	08 9c       	mov	r12,r4
800023f4:	f0 1f 00 09 	mcall	80002418 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023f8:	2f f7       	sub	r7,-1
800023fa:	5c 57       	castu.b	r7
800023fc:	2f ed       	sub	sp,-8
800023fe:	ee 05 19 00 	cp.h	r5,r7
80002402:	fe 9b ff f3 	brhi	800023e8 <DataSession_brdcst_func+0x40>
80002406:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002408:	1a d8       	st.w	--sp,r8
8000240a:	48 8c       	lddpc	r12,80002428 <DataSession_brdcst_func+0x80>
8000240c:	f0 1f 00 03 	mcall	80002418 <DataSession_brdcst_func+0x70>
80002410:	2f fd       	sub	sp,-4
80002412:	d8 22       	popm	r4-r7,pc
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	c7 20       	breq	800024fa <TransmitControl_brdcst_func+0x32>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	62 70       	ld.w	r0,r1[0x1c]
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	c7 34       	brge	80002504 <TransmitControl_brdcst_func+0x3c>
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	c7 4c       	rcall	8000250a <TransmitControl_brdcst_func+0x42>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	c7 68       	rjmp	80002512 <TransmitControl_reply_func+0x2>
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	c7 80       	breq	8000251a <TransmitControl_reply_func+0xa>

8000242c <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000242c:	eb cd 40 80 	pushm	r7,lr
80002430:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002432:	19 a8       	ld.ub	r8,r12[0x2]
80002434:	58 08       	cp.w	r8,0
80002436:	c0 61       	brne	80002442 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002438:	48 dc       	lddpc	r12,8000246c <DataSession_reply_func+0x40>
8000243a:	f0 1f 00 0e 	mcall	80002470 <DataSession_reply_func+0x44>
8000243e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 cc       	lddpc	r12,80002474 <DataSession_reply_func+0x48>
80002446:	f0 1f 00 0b 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
8000244a:	48 cc       	lddpc	r12,80002478 <DataSession_reply_func+0x4c>
8000244c:	f0 1f 00 09 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002450:	0f b8       	ld.ub	r8,r7[0x3]
80002452:	1a d8       	st.w	--sp,r8
80002454:	48 ac       	lddpc	r12,8000247c <DataSession_reply_func+0x50>
80002456:	f0 1f 00 07 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
8000245a:	0f c8       	ld.ub	r8,r7[0x4]
8000245c:	1a d8       	st.w	--sp,r8
8000245e:	48 9c       	lddpc	r12,80002480 <DataSession_reply_func+0x54>
80002460:	f0 1f 00 04 	mcall	80002470 <DataSession_reply_func+0x44>
80002464:	2f dd       	sub	sp,-12
80002466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246a:	00 00       	add	r0,r0
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	c7 94       	brge	80002560 <TransmitControl_reply_func+0x50>
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	62 70       	ld.w	r0,r1[0x1c]
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	c7 a8       	rjmp	8000256a <TransmitControl_reply_func+0x5a>
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	c7 bc       	rcall	80002570 <Volume_reply_func>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	c7 d0       	breq	80002578 <Volume_reply_func+0x8>
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	c7 e0       	breq	8000257e <Volume_reply_func+0xe>

80002484 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
8000248c:	0f 98       	ld.ub	r8,r7[0x1]
8000248e:	1a d8       	st.w	--sp,r8
80002490:	48 bc       	lddpc	r12,800024bc <CallControl_brdcst_func+0x38>
80002492:	f0 1f 00 0c 	mcall	800024c0 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002496:	2f fd       	sub	sp,-4
80002498:	0f 99       	ld.ub	r9,r7[0x1]
8000249a:	30 38       	mov	r8,3
8000249c:	f0 09 18 00 	cp.b	r9,r8
800024a0:	c0 41       	brne	800024a8 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024a2:	30 09       	mov	r9,0
800024a4:	48 88       	lddpc	r8,800024c4 <CallControl_brdcst_func+0x40>
800024a6:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024a8:	0f 99       	ld.ub	r9,r7[0x1]
800024aa:	30 48       	mov	r8,4
800024ac:	f0 09 18 00 	cp.b	r9,r8
800024b0:	c0 41       	brne	800024b8 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024b2:	30 19       	mov	r9,1
800024b4:	48 48       	lddpc	r8,800024c4 <CallControl_brdcst_func+0x40>
800024b6:	b0 89       	st.b	r8[0x0],r9
800024b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	c7 f0       	breq	800025bc <Volume_reply_func+0x4c>
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	62 70       	ld.w	r0,r1[0x1c]
800024c4:	00 00       	add	r0,r0
800024c6:	0a 4d       	or	sp,r5

800024c8 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024c8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024cc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024d0:	0f 99       	ld.ub	r9,r7[0x1]
800024d2:	30 08       	mov	r8,0
800024d4:	f0 09 18 00 	cp.b	r9,r8
800024d8:	c0 71       	brne	800024e6 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024da:	48 ac       	lddpc	r12,80002500 <TransmitControl_brdcst_func+0x38>
800024dc:	f0 1f 00 0a 	mcall	80002504 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024e0:	30 09       	mov	r9,0
800024e2:	48 a8       	lddpc	r8,80002508 <TransmitControl_brdcst_func+0x40>
800024e4:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024e6:	0f 99       	ld.ub	r9,r7[0x1]
800024e8:	30 18       	mov	r8,1
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 71       	brne	800024fc <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024f0:	48 7c       	lddpc	r12,8000250c <TransmitControl_brdcst_func+0x44>
800024f2:	f0 1f 00 05 	mcall	80002504 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024f6:	30 19       	mov	r9,1
800024f8:	48 48       	lddpc	r8,80002508 <TransmitControl_brdcst_func+0x40>
800024fa:	b0 89       	st.b	r8[0x0],r9
800024fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	c8 08       	rjmp	80002602 <spk_brdcst_func+0x2e>
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	62 70       	ld.w	r0,r1[0x1c]
80002508:	00 00       	add	r0,r0
8000250a:	0a 4c       	or	r12,r5
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	c8 20       	breq	80002412 <DataSession_brdcst_func+0x6a>

80002510 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002510:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002514:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002518:	0f 89       	ld.ub	r9,r7[0x0]
8000251a:	30 08       	mov	r8,0
8000251c:	f0 09 18 00 	cp.b	r9,r8
80002520:	c1 61       	brne	8000254c <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002522:	48 ec       	lddpc	r12,80002558 <TransmitControl_reply_func+0x48>
80002524:	f0 1f 00 0e 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002528:	0f 98       	ld.ub	r8,r7[0x1]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 dc       	lddpc	r12,80002560 <TransmitControl_reply_func+0x50>
8000252e:	f0 1f 00 0c 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002532:	0f a8       	ld.ub	r8,r7[0x2]
80002534:	1a d8       	st.w	--sp,r8
80002536:	48 cc       	lddpc	r12,80002564 <TransmitControl_reply_func+0x54>
80002538:	f0 1f 00 09 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
8000253c:	0f b8       	ld.ub	r8,r7[0x3]
8000253e:	1a d8       	st.w	--sp,r8
80002540:	48 ac       	lddpc	r12,80002568 <TransmitControl_reply_func+0x58>
80002542:	f0 1f 00 07 	mcall	8000255c <TransmitControl_reply_func+0x4c>
80002546:	2f dd       	sub	sp,-12
80002548:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
8000254c:	48 8c       	lddpc	r12,8000256c <TransmitControl_reply_func+0x5c>
8000254e:	f0 1f 00 04 	mcall	8000255c <TransmitControl_reply_func+0x4c>
80002552:	e3 cd 80 80 	ldm	sp++,r7,pc
80002556:	00 00       	add	r0,r0
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	c8 34       	brge	80002460 <DataSession_reply_func+0x34>
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	62 70       	ld.w	r0,r1[0x1c]
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	c8 50       	breq	8000246c <DataSession_reply_func+0x40>
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	c8 64       	brge	80002472 <DataSession_reply_func+0x46>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	c8 80       	breq	8000247a <DataSession_reply_func+0x4e>
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	c8 90       	breq	80002480 <DataSession_reply_func+0x54>

80002570 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002570:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002574:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002578:	0f 89       	ld.ub	r9,r7[0x0]
8000257a:	30 08       	mov	r8,0
8000257c:	f0 09 18 00 	cp.b	r9,r8
80002580:	c1 b1       	brne	800025b6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002582:	0f b8       	ld.ub	r8,r7[0x3]
80002584:	31 09       	mov	r9,16
80002586:	f2 08 18 00 	cp.b	r8,r9
8000258a:	c0 f1       	brne	800025a8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000258c:	48 dc       	lddpc	r12,800025c0 <Volume_reply_func+0x50>
8000258e:	f0 1f 00 0e 	mcall	800025c4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002592:	0f 99       	ld.ub	r9,r7[0x1]
80002594:	0f a8       	ld.ub	r8,r7[0x2]
80002596:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000259a:	1a d8       	st.w	--sp,r8
8000259c:	48 bc       	lddpc	r12,800025c8 <Volume_reply_func+0x58>
8000259e:	f0 1f 00 0a 	mcall	800025c4 <Volume_reply_func+0x54>
800025a2:	2f fd       	sub	sp,-4
800025a4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025a8:	1a d8       	st.w	--sp,r8
800025aa:	48 9c       	lddpc	r12,800025cc <Volume_reply_func+0x5c>
800025ac:	f0 1f 00 06 	mcall	800025c4 <Volume_reply_func+0x54>
800025b0:	2f fd       	sub	sp,-4
800025b2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025b6:	48 7c       	lddpc	r12,800025d0 <Volume_reply_func+0x60>
800025b8:	f0 1f 00 03 	mcall	800025c4 <Volume_reply_func+0x54>
800025bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	c8 a8       	rjmp	800026d6 <mic_reply_func+0x2a>
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	62 70       	ld.w	r0,r1[0x1c]
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	c8 bc       	rcall	800026e0 <mic_reply_func+0x34>
800025cc:	80 00       	ld.sh	r0,r0[0x0]
800025ce:	c8 d8       	rjmp	800026e8 <mic_reply_func+0x3c>
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	c8 f0       	breq	800024f0 <TransmitControl_brdcst_func+0x28>

800025d4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025d4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025d6:	19 d9       	ld.ub	r9,r12[0x5]
800025d8:	30 08       	mov	r8,0
800025da:	f0 09 18 00 	cp.b	r9,r8
800025de:	c0 81       	brne	800025ee <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800025e0:	10 99       	mov	r9,r8
800025e2:	48 78       	lddpc	r8,800025fc <spk_brdcst_func+0x28>
800025e4:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800025e6:	48 7c       	lddpc	r12,80002600 <spk_brdcst_func+0x2c>
800025e8:	f0 1f 00 07 	mcall	80002604 <spk_brdcst_func+0x30>
800025ec:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800025ee:	30 19       	mov	r9,1
800025f0:	48 38       	lddpc	r8,800025fc <spk_brdcst_func+0x28>
800025f2:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800025f4:	48 5c       	lddpc	r12,80002608 <spk_brdcst_func+0x34>
800025f6:	f0 1f 00 04 	mcall	80002604 <spk_brdcst_func+0x30>
800025fa:	d8 02       	popm	pc
800025fc:	00 00       	add	r0,r0
800025fe:	0a 38       	cp.w	r8,r5
80002600:	80 00       	ld.sh	r0,r0[0x0]
80002602:	c9 08       	rjmp	80002722 <mic_reply_func+0x76>
80002604:	80 00       	ld.sh	r0,r0[0x0]
80002606:	62 70       	ld.w	r0,r1[0x1c]
80002608:	80 00       	ld.sh	r0,r0[0x0]
8000260a:	c9 18       	rjmp	8000272c <mic_reply_func+0x80>

8000260c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000260c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000260e:	19 a9       	ld.ub	r9,r12[0x2]
80002610:	30 08       	mov	r8,0
80002612:	f0 09 18 00 	cp.b	r9,r8
80002616:	c0 f1       	brne	80002634 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002618:	19 e9       	ld.ub	r9,r12[0x6]
8000261a:	f0 09 18 00 	cp.b	r9,r8
8000261e:	c0 40       	breq	80002626 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002620:	30 19       	mov	r9,1
80002622:	48 98       	lddpc	r8,80002644 <spk_reply_func+0x38>
80002624:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002626:	19 e8       	ld.ub	r8,r12[0x6]
80002628:	1a d8       	st.w	--sp,r8
8000262a:	48 8c       	lddpc	r12,80002648 <spk_reply_func+0x3c>
8000262c:	f0 1f 00 08 	mcall	8000264c <spk_reply_func+0x40>
80002630:	2f fd       	sub	sp,-4
80002632:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002634:	30 09       	mov	r9,0
80002636:	48 48       	lddpc	r8,80002644 <spk_reply_func+0x38>
80002638:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000263a:	48 6c       	lddpc	r12,80002650 <spk_reply_func+0x44>
8000263c:	f0 1f 00 04 	mcall	8000264c <spk_reply_func+0x40>
80002640:	d8 02       	popm	pc
80002642:	00 00       	add	r0,r0
80002644:	00 00       	add	r0,r0
80002646:	0a 38       	cp.w	r8,r5
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	c9 24       	brge	8000256e <TransmitControl_reply_func+0x5e>
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	62 70       	ld.w	r0,r1[0x1c]
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	c9 34       	brge	80002578 <Volume_reply_func+0x8>

80002654 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002654:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002658:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000265c:	0f a9       	ld.ub	r9,r7[0x2]
8000265e:	30 08       	mov	r8,0
80002660:	f0 09 18 00 	cp.b	r9,r8
80002664:	c0 71       	brne	80002672 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002666:	48 dc       	lddpc	r12,80002698 <mic_brdcst_func+0x44>
80002668:	f0 1f 00 0d 	mcall	8000269c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000266c:	30 09       	mov	r9,0
8000266e:	48 d8       	lddpc	r8,800026a0 <mic_brdcst_func+0x4c>
80002670:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002672:	0f a9       	ld.ub	r9,r7[0x2]
80002674:	31 18       	mov	r8,17
80002676:	f0 09 18 00 	cp.b	r9,r8
8000267a:	c0 d1       	brne	80002694 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000267c:	48 ac       	lddpc	r12,800026a4 <mic_brdcst_func+0x50>
8000267e:	f0 1f 00 08 	mcall	8000269c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002682:	48 89       	lddpc	r9,800026a0 <mic_brdcst_func+0x4c>
80002684:	30 18       	mov	r8,1
80002686:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002688:	13 89       	ld.ub	r9,r9[0x0]
8000268a:	f0 09 18 00 	cp.b	r9,r8
8000268e:	c0 31       	brne	80002694 <mic_brdcst_func+0x40>
80002690:	48 68       	lddpc	r8,800026a8 <mic_brdcst_func+0x54>
80002692:	11 88       	ld.ub	r8,r8[0x0]
80002694:	e3 cd 80 80 	ldm	sp++,r7,pc
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	c9 40       	breq	800025c2 <Volume_reply_func+0x52>
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	62 70       	ld.w	r0,r1[0x1c]
800026a0:	00 00       	add	r0,r0
800026a2:	0a 51       	eor	r1,r5
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	c9 54       	brge	800025d0 <Volume_reply_func+0x60>
800026a8:	00 00       	add	r0,r0
800026aa:	0a 4d       	or	sp,r5

800026ac <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026b0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026b4:	49 ac       	lddpc	r12,8000271c <mic_reply_func+0x70>
800026b6:	f0 1f 00 1b 	mcall	80002720 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026ba:	0f 89       	ld.ub	r9,r7[0x0]
800026bc:	30 08       	mov	r8,0
800026be:	f0 09 18 00 	cp.b	r9,r8
800026c2:	c2 71       	brne	80002710 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026c4:	0f 98       	ld.ub	r8,r7[0x1]
800026c6:	30 29       	mov	r9,2
800026c8:	f2 08 18 00 	cp.b	r8,r9
800026cc:	c1 b1       	brne	80002702 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026ce:	49 6c       	lddpc	r12,80002724 <mic_reply_func+0x78>
800026d0:	f0 1f 00 14 	mcall	80002720 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026d4:	0f a8       	ld.ub	r8,r7[0x2]
800026d6:	1a d8       	st.w	--sp,r8
800026d8:	49 4c       	lddpc	r12,80002728 <mic_reply_func+0x7c>
800026da:	f0 1f 00 12 	mcall	80002720 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026de:	0f b8       	ld.ub	r8,r7[0x3]
800026e0:	1a d8       	st.w	--sp,r8
800026e2:	49 3c       	lddpc	r12,8000272c <mic_reply_func+0x80>
800026e4:	f0 1f 00 0f 	mcall	80002720 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800026e8:	0f c8       	ld.ub	r8,r7[0x4]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	49 1c       	lddpc	r12,80002730 <mic_reply_func+0x84>
800026ee:	f0 1f 00 0d 	mcall	80002720 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800026f2:	0f d8       	ld.ub	r8,r7[0x5]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	49 0c       	lddpc	r12,80002734 <mic_reply_func+0x88>
800026f8:	f0 1f 00 0a 	mcall	80002720 <mic_reply_func+0x74>
800026fc:	2f cd       	sub	sp,-16
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002702:	1a d8       	st.w	--sp,r8
80002704:	48 dc       	lddpc	r12,80002738 <mic_reply_func+0x8c>
80002706:	f0 1f 00 07 	mcall	80002720 <mic_reply_func+0x74>
8000270a:	2f fd       	sub	sp,-4
8000270c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002710:	48 bc       	lddpc	r12,8000273c <mic_reply_func+0x90>
80002712:	f0 1f 00 04 	mcall	80002720 <mic_reply_func+0x74>
80002716:	e3 cd 80 80 	ldm	sp++,r7,pc
8000271a:	00 00       	add	r0,r0
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	c9 68       	rjmp	8000284a <app_payload_rx_proc+0x32>
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	62 70       	ld.w	r0,r1[0x1c]
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	c9 78       	rjmp	80002854 <app_payload_rx_proc+0x3c>
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	c9 8c       	rcall	8000285a <app_payload_rx_proc+0x42>
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	c9 a0       	breq	80002662 <mic_brdcst_func+0xe>
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	c9 bc       	rcall	80002868 <AudioRoutingControl_reply_func+0x4>
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	c9 d4       	brge	80002670 <mic_brdcst_func+0x1c>
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	c9 ec       	rcall	80002876 <AudioRoutingControl_reply_func+0x12>
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	ca 04       	brge	8000267e <mic_brdcst_func+0x2a>

80002740 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002740:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002744:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002748:	48 bc       	lddpc	r12,80002774 <dcm_brdcst_func+0x34>
8000274a:	f0 1f 00 0c 	mcall	80002778 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000274e:	0f 88       	ld.ub	r8,r7[0x0]
80002750:	1a d8       	st.w	--sp,r8
80002752:	48 bc       	lddpc	r12,8000277c <dcm_brdcst_func+0x3c>
80002754:	f0 1f 00 09 	mcall	80002778 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002758:	0f a8       	ld.ub	r8,r7[0x2]
8000275a:	1a d8       	st.w	--sp,r8
8000275c:	48 9c       	lddpc	r12,80002780 <dcm_brdcst_func+0x40>
8000275e:	f0 1f 00 07 	mcall	80002778 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002762:	0f 98       	ld.ub	r8,r7[0x1]
80002764:	1a d8       	st.w	--sp,r8
80002766:	48 8c       	lddpc	r12,80002784 <dcm_brdcst_func+0x44>
80002768:	f0 1f 00 04 	mcall	80002778 <dcm_brdcst_func+0x38>
8000276c:	2f dd       	sub	sp,-12
	
	
}
8000276e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002772:	00 00       	add	r0,r0
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	ca 14       	brge	800026b8 <mic_reply_func+0xc>
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	62 70       	ld.w	r0,r1[0x1c]
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	ca 28       	rjmp	800028c2 <DeviceInitializationStatus_brdcst_func+0x2e>
80002780:	80 00       	ld.sh	r0,r0[0x0]
80002782:	ca 3c       	rcall	800028c8 <DeviceInitializationStatus_brdcst_func+0x34>
80002784:	80 00       	ld.sh	r0,r0[0x0]
80002786:	ca 54       	brge	800026d0 <mic_reply_func+0x24>

80002788 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002788:	eb cd 40 80 	pushm	r7,lr
8000278c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000278e:	19 a9       	ld.ub	r9,r12[0x2]
80002790:	30 08       	mov	r8,0
80002792:	f0 09 18 00 	cp.b	r9,r8
80002796:	c1 b1       	brne	800027cc <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002798:	19 b8       	ld.ub	r8,r12[0x3]
8000279a:	30 19       	mov	r9,1
8000279c:	f2 08 18 00 	cp.b	r8,r9
800027a0:	c0 51       	brne	800027aa <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027a2:	48 ec       	lddpc	r12,800027d8 <dcm_reply_func+0x50>
800027a4:	f0 1f 00 0e 	mcall	800027dc <dcm_reply_func+0x54>
800027a8:	c0 a8       	rjmp	800027bc <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027aa:	58 08       	cp.w	r8,0
800027ac:	c0 51       	brne	800027b6 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027ae:	48 dc       	lddpc	r12,800027e0 <dcm_reply_func+0x58>
800027b0:	f0 1f 00 0b 	mcall	800027dc <dcm_reply_func+0x54>
800027b4:	c0 48       	rjmp	800027bc <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027b6:	48 cc       	lddpc	r12,800027e4 <dcm_reply_func+0x5c>
800027b8:	f0 1f 00 09 	mcall	800027dc <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027bc:	0f d8       	ld.ub	r8,r7[0x5]
800027be:	1a d8       	st.w	--sp,r8
800027c0:	48 ac       	lddpc	r12,800027e8 <dcm_reply_func+0x60>
800027c2:	f0 1f 00 07 	mcall	800027dc <dcm_reply_func+0x54>
800027c6:	2f fd       	sub	sp,-4
800027c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027cc:	48 8c       	lddpc	r12,800027ec <dcm_reply_func+0x64>
800027ce:	f0 1f 00 04 	mcall	800027dc <dcm_reply_func+0x54>
800027d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027d6:	00 00       	add	r0,r0
800027d8:	80 00       	ld.sh	r0,r0[0x0]
800027da:	ca 70       	breq	80002728 <mic_reply_func+0x7c>
800027dc:	80 00       	ld.sh	r0,r0[0x0]
800027de:	62 70       	ld.w	r0,r1[0x1c]
800027e0:	80 00       	ld.sh	r0,r0[0x0]
800027e2:	ca 84       	brge	80002732 <mic_reply_func+0x86>
800027e4:	80 00       	ld.sh	r0,r0[0x0]
800027e6:	ca 98       	rjmp	80002938 <payload_rx_process+0x18>
800027e8:	80 00       	ld.sh	r0,r0[0x0]
800027ea:	ca ac       	rcall	8000293e <payload_rx_process+0x1e>
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	ca b8       	rjmp	80002944 <payload_rx_process+0x24>

800027f0 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800027f0:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800027f2:	19 a9       	ld.ub	r9,r12[0x2]
800027f4:	30 08       	mov	r8,0
800027f6:	f0 09 18 00 	cp.b	r9,r8
800027fa:	c0 51       	brne	80002804 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
800027fc:	48 4c       	lddpc	r12,8000280c <ToneControl_reply_func+0x1c>
800027fe:	f0 1f 00 05 	mcall	80002810 <ToneControl_reply_func+0x20>
80002802:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002804:	48 4c       	lddpc	r12,80002814 <ToneControl_reply_func+0x24>
80002806:	f0 1f 00 03 	mcall	80002810 <ToneControl_reply_func+0x20>
8000280a:	d8 02       	popm	pc
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	ca c4       	brge	80002766 <dcm_brdcst_func+0x26>
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	62 70       	ld.w	r0,r1[0x1c]
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	ca cc       	rcall	8000296e <set_idle_store_isr+0x2>

80002818 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002818:	eb cd 40 80 	pushm	r7,lr
8000281c:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000281e:	48 c9       	lddpc	r9,8000284c <app_payload_rx_proc+0x34>
80002820:	13 88       	ld.ub	r8,r9[0x0]
80002822:	2f f8       	sub	r8,-1
80002824:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002826:	30 39       	mov	r9,3
80002828:	f2 08 18 00 	cp.b	r8,r9
8000282c:	c0 71       	brne	8000283a <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000282e:	30 09       	mov	r9,0
80002830:	48 78       	lddpc	r8,8000284c <app_payload_rx_proc+0x34>
80002832:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002834:	48 7c       	lddpc	r12,80002850 <app_payload_rx_proc+0x38>
80002836:	f0 1f 00 08 	mcall	80002854 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000283a:	48 88       	lddpc	r8,80002858 <app_payload_rx_proc+0x40>
8000283c:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000283e:	48 88       	lddpc	r8,8000285c <app_payload_rx_proc+0x44>
80002840:	70 0c       	ld.w	r12,r8[0x0]
80002842:	0e 9b       	mov	r11,r7
80002844:	f0 1f 00 07 	mcall	80002860 <app_payload_rx_proc+0x48>

}
80002848:	e3 cd 80 80 	ldm	sp++,r7,pc
8000284c:	00 00       	add	r0,r0
8000284e:	0a 50       	eor	r0,r5
80002850:	80 00       	ld.sh	r0,r0[0x0]
80002852:	ca d8       	rjmp	800029ac <phy_rx+0x24>
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	62 70       	ld.w	r0,r1[0x1c]
80002858:	00 00       	add	r0,r0
8000285a:	0a 52       	eor	r2,r5
8000285c:	00 00       	add	r0,r0
8000285e:	0a 6c       	and	r12,r5
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	29 c0       	sub	r0,-100

80002864 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002864:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002866:	19 a9       	ld.ub	r9,r12[0x2]
80002868:	30 08       	mov	r8,0
8000286a:	f0 09 18 00 	cp.b	r9,r8
8000286e:	c0 71       	brne	8000287c <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
80002870:	48 5c       	lddpc	r12,80002884 <AudioRoutingControl_reply_func+0x20>
80002872:	f0 1f 00 06 	mcall	80002888 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002876:	f0 1f 00 06 	mcall	8000288c <AudioRoutingControl_reply_func+0x28>
8000287a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000287c:	48 5c       	lddpc	r12,80002890 <AudioRoutingControl_reply_func+0x2c>
8000287e:	f0 1f 00 03 	mcall	80002888 <AudioRoutingControl_reply_func+0x24>
80002882:	d8 02       	popm	pc
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	ca e4       	brge	800027e2 <dcm_reply_func+0x5a>
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	62 70       	ld.w	r0,r1[0x1c]
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	40 44       	lddsp	r4,sp[0x10]
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	ca f4       	brge	800027f0 <ToneControl_reply_func>

80002894 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002894:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002896:	19 e8       	ld.ub	r8,r12[0x6]
80002898:	30 19       	mov	r9,1
8000289a:	f2 08 18 00 	cp.b	r8,r9
8000289e:	c0 61       	brne	800028aa <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028a0:	48 98       	lddpc	r8,800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800028a2:	70 09       	ld.w	r9,r8[0x0]
800028a4:	a1 a9       	sbr	r9,0x0
800028a6:	91 09       	st.w	r8[0x0],r9
800028a8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028aa:	30 29       	mov	r9,2
800028ac:	f2 08 18 00 	cp.b	r8,r9
800028b0:	c0 80       	breq	800028c0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028b2:	48 58       	lddpc	r8,800028c4 <DeviceInitializationStatus_brdcst_func+0x30>
800028b4:	70 09       	ld.w	r9,r8[0x0]
800028b6:	e0 19 ff fc 	andl	r9,0xfffc
800028ba:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028bc:	f0 1f 00 03 	mcall	800028c8 <DeviceInitializationStatus_brdcst_func+0x34>
800028c0:	d8 02       	popm	pc
800028c2:	00 00       	add	r0,r0
800028c4:	00 00       	add	r0,r0
800028c6:	0d 98       	ld.ub	r8,r6[0x1]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	3f 98       	mov	r8,-7

800028cc <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028cc:	20 1c       	sub	r12,1
800028ce:	5c 5c       	castu.b	r12
800028d0:	31 18       	mov	r8,17
800028d2:	f0 0c 18 00 	cp.b	r12,r8
800028d6:	e0 88 00 03 	brls	800028dc <CalculateBurst+0x10>
800028da:	5e fd       	retal	0
800028dc:	48 28       	lddpc	r8,800028e4 <CalculateBurst+0x18>
800028de:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800028e2:	5e fc       	retal	r12
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	cb 10       	breq	80002848 <app_payload_rx_proc+0x30>

800028e8 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028e8:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028ea:	48 98       	lddpc	r8,8000290c <payload_init+0x24>
800028ec:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028ee:	48 98       	lddpc	r8,80002910 <payload_init+0x28>
800028f0:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028f2:	30 09       	mov	r9,0
800028f4:	1a d9       	st.w	--sp,r9
800028f6:	1a d9       	st.w	--sp,r9
800028f8:	1a d9       	st.w	--sp,r9
800028fa:	30 28       	mov	r8,2
800028fc:	e0 6a 04 00 	mov	r10,1024
80002900:	48 5b       	lddpc	r11,80002914 <payload_init+0x2c>
80002902:	48 6c       	lddpc	r12,80002918 <payload_init+0x30>
80002904:	f0 1f 00 06 	mcall	8000291c <payload_init+0x34>
80002908:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000290a:	d8 02       	popm	pc
8000290c:	00 00       	add	r0,r0
8000290e:	0a 58       	eor	r8,r5
80002910:	00 00       	add	r0,r0
80002912:	0a 5c       	eor	r12,r5
80002914:	80 00       	ld.sh	r0,r0[0x0]
80002916:	cb 58       	rjmp	80002a80 <phy_tx_func+0x1c>
80002918:	80 00       	ld.sh	r0,r0[0x0]
8000291a:	29 20       	sub	r0,-110
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	5e ac       	retle	r12

80002920 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002920:	eb cd 40 f8 	pushm	r3-r7,lr
80002924:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002926:	48 e8       	lddpc	r8,8000295c <payload_rx_process+0x3c>
80002928:	70 08       	ld.w	r8,r8[0x0]
8000292a:	58 08       	cp.w	r8,0
8000292c:	c0 71       	brne	8000293a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000292e:	30 4b       	mov	r11,4
80002930:	30 5c       	mov	r12,5
80002932:	f0 1f 00 0c 	mcall	80002960 <payload_rx_process+0x40>
80002936:	48 a8       	lddpc	r8,8000295c <payload_rx_process+0x3c>
80002938:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000293a:	48 96       	lddpc	r6,8000295c <payload_rx_process+0x3c>
8000293c:	30 05       	mov	r5,0
8000293e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002940:	48 93       	lddpc	r3,80002964 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002942:	6c 0c       	ld.w	r12,r6[0x0]
80002944:	0a 99       	mov	r9,r5
80002946:	08 9a       	mov	r10,r4
80002948:	1a 9b       	mov	r11,sp
8000294a:	f0 1f 00 08 	mcall	80002968 <payload_rx_process+0x48>
8000294e:	58 1c       	cp.w	r12,1
80002950:	cf 91       	brne	80002942 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002952:	66 08       	ld.w	r8,r3[0x0]
80002954:	40 0c       	lddsp	r12,sp[0x0]
80002956:	5d 18       	icall	r8
80002958:	cf 5b       	rjmp	80002942 <payload_rx_process+0x22>
8000295a:	00 00       	add	r0,r0
8000295c:	00 00       	add	r0,r0
8000295e:	0a 90       	mov	r0,r5
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	57 d8       	stdsp	sp[0x1f4],r8
80002964:	00 00       	add	r0,r0
80002966:	0a 58       	eor	r8,r5
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	54 74       	stdsp	sp[0x11c],r4

8000296c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000296c:	d4 01       	pushm	lr
8000296e:	20 2d       	sub	sp,8
80002970:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002972:	30 09       	mov	r9,0
80002974:	fa ca ff f8 	sub	r10,sp,-8
80002978:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000297a:	1a 9b       	mov	r11,sp
8000297c:	f0 1f 00 02 	mcall	80002984 <set_idle_store_isr+0x18>
}
80002980:	2f ed       	sub	sp,-8
80002982:	d8 02       	popm	pc
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	56 30       	stdsp	sp[0x18c],r0

80002988 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002988:	d4 01       	pushm	lr
8000298a:	20 2d       	sub	sp,8
8000298c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000298e:	58 0c       	cp.w	r12,0
80002990:	c1 10       	breq	800029b2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002992:	30 08       	mov	r8,0
80002994:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002996:	98 88       	ld.uh	r8,r12[0x0]
80002998:	e2 18 f0 00 	andl	r8,0xf000,COH
8000299c:	e0 48 40 00 	cp.w	r8,16384
800029a0:	c0 91       	brne	800029b2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029a2:	48 68       	lddpc	r8,800029b8 <phy_rx+0x30>
800029a4:	70 0c       	ld.w	r12,r8[0x0]
800029a6:	30 09       	mov	r9,0
800029a8:	fa ca ff fc 	sub	r10,sp,-4
800029ac:	1a 9b       	mov	r11,sp
800029ae:	f0 1f 00 04 	mcall	800029bc <phy_rx+0x34>
		}	

    }
		
 
}
800029b2:	2f ed       	sub	sp,-8
800029b4:	d8 02       	popm	pc
800029b6:	00 00       	add	r0,r0
800029b8:	00 00       	add	r0,r0
800029ba:	0a b4       	st.h	r5++,r4
800029bc:	80 00       	ld.sh	r0,r0[0x0]
800029be:	56 30       	stdsp	sp[0x18c],r0

800029c0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029c0:	eb cd 40 80 	pushm	r7,lr
800029c4:	20 1d       	sub	sp,4
800029c6:	fa c7 ff fc 	sub	r7,sp,-4
800029ca:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029cc:	30 09       	mov	r9,0
800029ce:	12 9a       	mov	r10,r9
800029d0:	1a 9b       	mov	r11,sp
800029d2:	f0 1f 00 03 	mcall	800029dc <set_idle_store+0x1c>
}
800029d6:	2f fd       	sub	sp,-4
800029d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	56 80       	stdsp	sp[0x1a0],r0

800029e0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029e0:	d4 01       	pushm	lr
800029e2:	20 1d       	sub	sp,4
800029e4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029e6:	98 88       	ld.uh	r8,r12[0x0]
800029e8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029ec:	e0 48 40 00 	cp.w	r8,16384
800029f0:	c0 d1       	brne	80002a0a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029f2:	49 08       	lddpc	r8,80002a30 <phy_tx+0x50>
800029f4:	70 08       	ld.w	r8,r8[0x0]
800029f6:	58 08       	cp.w	r8,0
800029f8:	c1 a0       	breq	80002a2c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800029fa:	48 e8       	lddpc	r8,80002a30 <phy_tx+0x50>
800029fc:	70 0c       	ld.w	r12,r8[0x0]
800029fe:	30 09       	mov	r9,0
80002a00:	12 9a       	mov	r10,r9
80002a02:	1a 9b       	mov	r11,sp
80002a04:	f0 1f 00 0c 	mcall	80002a34 <phy_tx+0x54>
80002a08:	c1 28       	rjmp	80002a2c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a0a:	e0 48 10 00 	cp.w	r8,4096
80002a0e:	5f 0a       	sreq	r10
80002a10:	e0 48 20 00 	cp.w	r8,8192
80002a14:	5f 09       	sreq	r9
80002a16:	f5 e9 10 09 	or	r9,r10,r9
80002a1a:	c0 71       	brne	80002a28 <phy_tx+0x48>
80002a1c:	e0 48 50 00 	cp.w	r8,20480
80002a20:	c0 40       	breq	80002a28 <phy_tx+0x48>
80002a22:	e0 48 60 00 	cp.w	r8,24576
80002a26:	c0 31       	brne	80002a2c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a28:	48 48       	lddpc	r8,80002a38 <phy_tx+0x58>
80002a2a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a2c:	2f fd       	sub	sp,-4
80002a2e:	d8 02       	popm	pc
80002a30:	00 00       	add	r0,r0
80002a32:	0a c8       	st.b	r5++,r8
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	56 80       	stdsp	sp[0x1a0],r0
80002a38:	00 00       	add	r0,r0
80002a3a:	0a b0       	st.h	r5++,r0

80002a3c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a3c:	d4 01       	pushm	lr
80002a3e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a40:	30 08       	mov	r8,0
80002a42:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a44:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a46:	1a 9a       	mov	r10,sp
80002a48:	fa cb ff fc 	sub	r11,sp,-4
80002a4c:	f0 1f 00 05 	mcall	80002a60 <get_idle_store_isr+0x24>
80002a50:	58 1c       	cp.w	r12,1
80002a52:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a56:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a5a:	2f ed       	sub	sp,-8
80002a5c:	d8 02       	popm	pc
80002a5e:	00 00       	add	r0,r0
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	53 84       	stdsp	sp[0xe0],r4

80002a64 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a64:	eb cd 40 c0 	pushm	r6-r7,lr
80002a68:	20 1d       	sub	sp,4
80002a6a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a6c:	fe f8 04 6c 	ld.w	r8,pc[1132]
80002a70:	70 08       	ld.w	r8,r8[0x0]
80002a72:	58 08       	cp.w	r8,0
80002a74:	c7 40       	breq	80002b5c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a76:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a78:	30 08       	mov	r8,0
80002a7a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a7c:	fe f8 04 60 	ld.w	r8,pc[1120]
80002a80:	70 08       	ld.w	r8,r8[0x0]
80002a82:	58 18       	cp.w	r8,1
80002a84:	c2 90       	breq	80002ad6 <phy_tx_func+0x72>
80002a86:	c0 43       	brcs	80002a8e <phy_tx_func+0x2a>
80002a88:	58 28       	cp.w	r8,2
80002a8a:	c6 91       	brne	80002b5c <phy_tx_func+0xf8>
80002a8c:	c6 18       	rjmp	80002b4e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a8e:	fe f8 04 4a 	ld.w	r8,pc[1098]
80002a92:	70 0c       	ld.w	r12,r8[0x0]
80002a94:	1a 9a       	mov	r10,sp
80002a96:	fe fb 04 4a 	ld.w	r11,pc[1098]
80002a9a:	f0 1f 01 13 	mcall	80002ee4 <phy_tx_func+0x480>
80002a9e:	58 1c       	cp.w	r12,1
80002aa0:	c1 51       	brne	80002aca <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002aa2:	fe f8 04 3e 	ld.w	r8,pc[1086]
80002aa6:	70 08       	ld.w	r8,r8[0x0]
80002aa8:	11 9a       	ld.ub	r10,r8[0x1]
80002aaa:	fe f9 04 3e 	ld.w	r9,pc[1086]
80002aae:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ab0:	90 88       	ld.uh	r8,r8[0x0]
80002ab2:	ea 18 ab cd 	orh	r8,0xabcd
80002ab6:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ab8:	30 19       	mov	r9,1
80002aba:	fe f8 04 32 	ld.w	r8,pc[1074]
80002abe:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ac0:	30 19       	mov	r9,1
80002ac2:	fe f8 04 1a 	ld.w	r8,pc[1050]
80002ac6:	91 09       	st.w	r8[0x0],r9
80002ac8:	c4 a8       	rjmp	80002b5c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002aca:	e0 68 5a 5a 	mov	r8,23130
80002ace:	ea 18 ab cd 	orh	r8,0xabcd
80002ad2:	8f 18       	st.w	r7[0x4],r8
80002ad4:	c4 48       	rjmp	80002b5c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ad6:	fe f9 04 16 	ld.w	r9,pc[1046]
80002ada:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002adc:	fe fa 04 04 	ld.w	r10,pc[1028]
80002ae0:	74 0a       	ld.w	r10,r10[0x0]
80002ae2:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002ae6:	b1 6a       	lsl	r10,0x10
80002ae8:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002aea:	2f f8       	sub	r8,-1
80002aec:	5c 58       	castu.b	r8
80002aee:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002af0:	fe fa 03 f8 	ld.w	r10,pc[1016]
80002af4:	94 09       	ld.sh	r9,r10[0x0]
80002af6:	20 29       	sub	r9,2
80002af8:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002afa:	30 0a       	mov	r10,0
80002afc:	f4 09 19 00 	cp.h	r9,r10
80002b00:	e0 89 00 0b 	brgt	80002b16 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b04:	78 18       	ld.w	r8,r12[0x4]
80002b06:	e8 18 00 ba 	orl	r8,0xba
80002b0a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b0c:	30 09       	mov	r9,0
80002b0e:	fe f8 03 ce 	ld.w	r8,pc[974]
80002b12:	91 09       	st.w	r8[0x0],r9
80002b14:	c2 48       	rjmp	80002b5c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b16:	fe f9 03 ca 	ld.w	r9,pc[970]
80002b1a:	72 09       	ld.w	r9,r9[0x0]
80002b1c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b20:	78 1a       	ld.w	r10,r12[0x4]
80002b22:	f5 e9 10 09 	or	r9,r10,r9
80002b26:	99 19       	st.w	r12[0x4],r9
80002b28:	2f f8       	sub	r8,-1
80002b2a:	fe f9 03 c2 	ld.w	r9,pc[962]
80002b2e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b30:	fe f9 03 b8 	ld.w	r9,pc[952]
80002b34:	92 08       	ld.sh	r8,r9[0x0]
80002b36:	20 28       	sub	r8,2
80002b38:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b3a:	30 09       	mov	r9,0
80002b3c:	f2 08 19 00 	cp.h	r8,r9
80002b40:	e0 89 00 0e 	brgt	80002b5c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b44:	30 29       	mov	r9,2
80002b46:	fe f8 03 96 	ld.w	r8,pc[918]
80002b4a:	91 09       	st.w	r8[0x0],r9
80002b4c:	c0 88       	rjmp	80002b5c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b4e:	fc 18 00 ba 	movh	r8,0xba
80002b52:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b54:	30 09       	mov	r9,0
80002b56:	fe f8 03 86 	ld.w	r8,pc[902]
80002b5a:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002b5c:	fe f8 03 94 	ld.w	r8,pc[916]
80002b60:	11 89       	ld.ub	r9,r8[0x0]
80002b62:	30 18       	mov	r8,1
80002b64:	f0 09 18 00 	cp.b	r9,r8
80002b68:	e0 81 01 ad 	brne	80002ec2 <phy_tx_func+0x45e>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b6c:	fe f8 03 88 	ld.w	r8,pc[904]
80002b70:	70 08       	ld.w	r8,r8[0x0]
80002b72:	e0 48 05 b0 	cp.w	r8,1456
80002b76:	f9 b8 02 00 	movhs	r8,0
80002b7a:	fe f9 03 7a 	ld.w	r9,pc[890]
80002b7e:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002b80:	fe f8 03 78 	ld.w	r8,pc[888]
80002b84:	70 08       	ld.w	r8,r8[0x0]
80002b86:	58 68       	cp.w	r8,6
80002b88:	e0 8b 01 93 	brhi	80002eae <phy_tx_func+0x44a>
80002b8c:	fe f9 03 70 	ld.w	r9,pc[880]
80002b90:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002b94:	fe f8 03 6c 	ld.w	r8,pc[876]
80002b98:	70 08       	ld.w	r8,r8[0x0]
80002b9a:	58 08       	cp.w	r8,0
80002b9c:	c0 b0       	breq	80002bb2 <phy_tx_func+0x14e>
80002b9e:	fe f8 03 62 	ld.w	r8,pc[866]
80002ba2:	70 08       	ld.w	r8,r8[0x0]
80002ba4:	58 a8       	cp.w	r8,10
80002ba6:	c0 60       	breq	80002bb2 <phy_tx_func+0x14e>
80002ba8:	fe f8 03 58 	ld.w	r8,pc[856]
80002bac:	70 08       	ld.w	r8,r8[0x0]
80002bae:	58 18       	cp.w	r8,1
80002bb0:	c0 a1       	brne	80002bc4 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bb2:	e0 68 5a 5a 	mov	r8,23130
80002bb6:	ea 18 ab cd 	orh	r8,0xabcd
80002bba:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002bbc:	30 08       	mov	r8,0
80002bbe:	8f 38       	st.w	r7[0xc],r8
80002bc0:	e0 8f 01 88 	bral	80002ed0 <phy_tx_func+0x46c>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002bc4:	fe f8 03 3c 	ld.w	r8,pc[828]
80002bc8:	70 08       	ld.w	r8,r8[0x0]
80002bca:	58 38       	cp.w	r8,3
80002bcc:	c0 91       	brne	80002bde <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bce:	fe f8 03 36 	ld.w	r8,pc[822]
80002bd2:	70 09       	ld.w	r9,r8[0x0]
80002bd4:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bd6:	70 18       	ld.w	r8,r8[0x4]
80002bd8:	8f 38       	st.w	r7[0xc],r8
80002bda:	e0 8f 01 7b 	bral	80002ed0 <phy_tx_func+0x46c>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002bde:	fe f8 03 22 	ld.w	r8,pc[802]
80002be2:	70 08       	ld.w	r8,r8[0x0]
80002be4:	58 28       	cp.w	r8,2
80002be6:	c1 31       	brne	80002c0c <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002be8:	e0 68 c0 32 	mov	r8,49202
80002bec:	ea 18 ab cd 	orh	r8,0xabcd
80002bf0:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002bf2:	fe 78 84 7f 	mov	r8,-31617
80002bf6:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002bf8:	fe f8 03 10 	ld.w	r8,pc[784]
80002bfc:	90 08       	ld.sh	r8,r8[0x0]
80002bfe:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c00:	30 39       	mov	r9,3
80002c02:	fe f8 02 f6 	ld.w	r8,pc[758]
80002c06:	91 09       	st.w	r8[0x0],r9
80002c08:	e0 8f 01 64 	bral	80002ed0 <phy_tx_func+0x46c>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c0c:	e0 68 c0 0e 	mov	r8,49166
80002c10:	ea 18 ab cd 	orh	r8,0xabcd
80002c14:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c16:	fe f8 02 f6 	ld.w	r8,pc[758]
80002c1a:	90 09       	ld.sh	r9,r8[0x0]
80002c1c:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c1e:	90 18       	ld.sh	r8,r8[0x2]
80002c20:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c22:	30 19       	mov	r9,1
80002c24:	fe f8 02 d4 	ld.w	r8,pc[724]
80002c28:	91 09       	st.w	r8[0x0],r9
80002c2a:	e0 8f 01 53 	bral	80002ed0 <phy_tx_func+0x46c>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c2e:	fe 78 88 f2 	mov	r8,-30478
80002c32:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c34:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c38:	70 08       	ld.w	r8,r8[0x0]
80002c3a:	58 48       	cp.w	r8,4
80002c3c:	c0 60       	breq	80002c48 <phy_tx_func+0x1e4>
80002c3e:	c4 53       	brcs	80002cc8 <phy_tx_func+0x264>
80002c40:	58 98       	cp.w	r8,9
80002c42:	e0 8b 00 43 	brhi	80002cc8 <phy_tx_func+0x264>
80002c46:	c2 98       	rjmp	80002c98 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c48:	fe f8 02 c8 	ld.w	r8,pc[712]
80002c4c:	11 89       	ld.ub	r9,r8[0x0]
80002c4e:	30 18       	mov	r8,1
80002c50:	f0 09 18 00 	cp.b	r9,r8
80002c54:	c0 a1       	brne	80002c68 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c56:	fe f8 02 be 	ld.w	r8,pc[702]
80002c5a:	90 09       	ld.sh	r9,r8[0x0]
80002c5c:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002c5e:	90 19       	ld.sh	r9,r8[0x2]
80002c60:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002c62:	90 28       	ld.sh	r8,r8[0x4]
80002c64:	ae 78       	st.h	r7[0xe],r8
80002c66:	c1 48       	rjmp	80002c8e <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c68:	fe f9 02 b0 	ld.w	r9,pc[688]
80002c6c:	92 0b       	ld.sh	r11,r9[0x0]
80002c6e:	fe f8 02 a6 	ld.w	r8,pc[678]
80002c72:	90 0a       	ld.sh	r10,r8[0x0]
80002c74:	f7 ea 20 0a 	eor	r10,r11,r10
80002c78:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002c7a:	92 1b       	ld.sh	r11,r9[0x2]
80002c7c:	90 1a       	ld.sh	r10,r8[0x2]
80002c7e:	f7 ea 20 0a 	eor	r10,r11,r10
80002c82:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002c84:	92 29       	ld.sh	r9,r9[0x4]
80002c86:	90 28       	ld.sh	r8,r8[0x4]
80002c88:	f3 e8 20 08 	eor	r8,r9,r8
80002c8c:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002c8e:	30 29       	mov	r9,2
80002c90:	fe f8 02 68 	ld.w	r8,pc[616]
80002c94:	91 09       	st.w	r8[0x0],r9
80002c96:	c1 d9       	rjmp	80002ed0 <phy_tx_func+0x46c>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c98:	fe f9 02 80 	ld.w	r9,pc[640]
80002c9c:	92 0b       	ld.sh	r11,r9[0x0]
80002c9e:	fe f8 02 76 	ld.w	r8,pc[630]
80002ca2:	90 0a       	ld.sh	r10,r8[0x0]
80002ca4:	f7 ea 20 0a 	eor	r10,r11,r10
80002ca8:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002caa:	92 1b       	ld.sh	r11,r9[0x2]
80002cac:	90 1a       	ld.sh	r10,r8[0x2]
80002cae:	f7 ea 20 0a 	eor	r10,r11,r10
80002cb2:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cb4:	92 29       	ld.sh	r9,r9[0x4]
80002cb6:	90 28       	ld.sh	r8,r8[0x4]
80002cb8:	f3 e8 20 08 	eor	r8,r9,r8
80002cbc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cbe:	30 29       	mov	r9,2
80002cc0:	fe f8 02 38 	ld.w	r8,pc[568]
80002cc4:	91 09       	st.w	r8[0x0],r9
80002cc6:	c0 59       	rjmp	80002ed0 <phy_tx_func+0x46c>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002cc8:	e0 68 5a 5a 	mov	r8,23130
80002ccc:	ea 18 ab cd 	orh	r8,0xabcd
80002cd0:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002cd2:	30 08       	mov	r8,0
80002cd4:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002cd6:	fe f9 02 22 	ld.w	r9,pc[546]
80002cda:	93 08       	st.w	r9[0x0],r8
80002cdc:	cf a8       	rjmp	80002ed0 <phy_tx_func+0x46c>
					
				
					//Encrypted AMBE data(XOR)
					//payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
				
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
80002cde:	fe f8 02 22 	ld.w	r8,pc[546]
80002ce2:	70 08       	ld.w	r8,r8[0x0]
80002ce4:	58 48       	cp.w	r8,4
80002ce6:	c0 d1       	brne	80002d00 <phy_tx_func+0x29c>
80002ce8:	fe f8 02 28 	ld.w	r8,pc[552]
80002cec:	11 89       	ld.ub	r9,r8[0x0]
80002cee:	30 18       	mov	r8,1
80002cf0:	f0 09 18 00 	cp.b	r9,r8
80002cf4:	c0 61       	brne	80002d00 <phy_tx_func+0x29c>
					{
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3])) ;
80002cf6:	fe f8 02 1e 	ld.w	r8,pc[542]
80002cfa:	90 38       	ld.sh	r8,r8[0x6]
80002cfc:	ae 48       	st.h	r7[0x8],r8
80002cfe:	c0 a8       	rjmp	80002d12 <phy_tx_func+0x2ae>
					}
					else{
						
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002d00:	fe f8 02 18 	ld.w	r8,pc[536]
80002d04:	90 39       	ld.sh	r9,r8[0x6]
80002d06:	fe f8 02 0e 	ld.w	r8,pc[526]
80002d0a:	90 38       	ld.sh	r8,r8[0x6]
80002d0c:	f3 e8 20 08 	eor	r8,r9,r8
80002d10:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d12:	e0 68 00 ba 	mov	r8,186
80002d16:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d18:	30 08       	mov	r8,0
80002d1a:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d1c:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d1e:	30 09       	mov	r9,0
80002d20:	4f 68       	lddpc	r8,80002ef8 <phy_tx_func+0x494>
80002d22:	91 09       	st.w	r8[0x0],r9
80002d24:	cd 68       	rjmp	80002ed0 <phy_tx_func+0x46c>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d26:	4f 98       	lddpc	r8,80002f08 <phy_tx_func+0x4a4>
80002d28:	90 18       	ld.sh	r8,r8[0x2]
80002d2a:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d2c:	4f 88       	lddpc	r8,80002f0c <phy_tx_func+0x4a8>
80002d2e:	90 08       	ld.sh	r8,r8[0x0]
80002d30:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d32:	4f 48       	lddpc	r8,80002f00 <phy_tx_func+0x49c>
80002d34:	70 08       	ld.w	r8,r8[0x0]
80002d36:	58 48       	cp.w	r8,4
80002d38:	c0 c1       	brne	80002d50 <phy_tx_func+0x2ec>
80002d3a:	4f 68       	lddpc	r8,80002f10 <phy_tx_func+0x4ac>
80002d3c:	11 89       	ld.ub	r9,r8[0x0]
80002d3e:	30 18       	mov	r8,1
80002d40:	f0 09 18 00 	cp.b	r9,r8
80002d44:	c0 61       	brne	80002d50 <phy_tx_func+0x2ec>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d46:	4f 28       	lddpc	r8,80002f0c <phy_tx_func+0x4a8>
80002d48:	90 18       	ld.sh	r8,r8[0x2]
80002d4a:	a9 a8       	sbr	r8,0x8
80002d4c:	ae 68       	st.h	r7[0xc],r8
80002d4e:	c0 48       	rjmp	80002d56 <phy_tx_func+0x2f2>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d50:	4e f8       	lddpc	r8,80002f0c <phy_tx_func+0x4a8>
80002d52:	90 18       	ld.sh	r8,r8[0x2]
80002d54:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d56:	fe 78 9a 13 	mov	r8,-26093
80002d5a:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d5c:	30 49       	mov	r9,4
80002d5e:	4e 78       	lddpc	r8,80002ef8 <phy_tx_func+0x494>
80002d60:	91 09       	st.w	r8[0x0],r9
80002d62:	cb 78       	rjmp	80002ed0 <phy_tx_func+0x46c>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d64:	4e e8       	lddpc	r8,80002f1c <phy_tx_func+0x4b8>
80002d66:	70 0a       	ld.w	r10,r8[0x0]
80002d68:	4e e9       	lddpc	r9,80002f20 <phy_tx_func+0x4bc>
80002d6a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d6e:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d70:	70 0a       	ld.w	r10,r8[0x0]
80002d72:	2f fa       	sub	r10,-1
80002d74:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d78:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d7a:	70 0a       	ld.w	r10,r8[0x0]
80002d7c:	2f ea       	sub	r10,-2
80002d7e:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d82:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002d84:	70 0a       	ld.w	r10,r8[0x0]
80002d86:	2f da       	sub	r10,-3
80002d88:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002d8c:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002d8e:	70 09       	ld.w	r9,r8[0x0]
80002d90:	2f c9       	sub	r9,-4
80002d92:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002d94:	58 c9       	cp.w	r9,12
80002d96:	c0 51       	brne	80002da0 <phy_tx_func+0x33c>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002d98:	30 59       	mov	r9,5
80002d9a:	4d 88       	lddpc	r8,80002ef8 <phy_tx_func+0x494>
80002d9c:	91 09       	st.w	r8[0x0],r9
80002d9e:	c9 98       	rjmp	80002ed0 <phy_tx_func+0x46c>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002da0:	30 49       	mov	r9,4
80002da2:	4d 68       	lddpc	r8,80002ef8 <phy_tx_func+0x494>
80002da4:	91 09       	st.w	r8[0x0],r9
80002da6:	c9 58       	rjmp	80002ed0 <phy_tx_func+0x46c>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002da8:	4d d8       	lddpc	r8,80002f1c <phy_tx_func+0x4b8>
80002daa:	70 0a       	ld.w	r10,r8[0x0]
80002dac:	4d d9       	lddpc	r9,80002f20 <phy_tx_func+0x4bc>
80002dae:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002db2:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002db4:	30 09       	mov	r9,0
80002db6:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002db8:	fe 78 80 03 	mov	r8,-32765
80002dbc:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002dbe:	fe 78 88 f3 	mov	r8,-30477
80002dc2:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002dc4:	4c f8       	lddpc	r8,80002f00 <phy_tx_func+0x49c>
80002dc6:	70 08       	ld.w	r8,r8[0x0]
80002dc8:	58 48       	cp.w	r8,4
80002dca:	c0 60       	breq	80002dd6 <phy_tx_func+0x372>
80002dcc:	c2 03       	brcs	80002e0c <phy_tx_func+0x3a8>
80002dce:	58 98       	cp.w	r8,9
80002dd0:	e0 8b 00 1e 	brhi	80002e0c <phy_tx_func+0x3a8>
80002dd4:	c1 58       	rjmp	80002dfe <phy_tx_func+0x39a>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002dd6:	4c f8       	lddpc	r8,80002f10 <phy_tx_func+0x4ac>
80002dd8:	11 89       	ld.ub	r9,r8[0x0]
80002dda:	30 18       	mov	r8,1
80002ddc:	f0 09 18 00 	cp.b	r9,r8
80002de0:	c0 81       	brne	80002df0 <phy_tx_func+0x38c>
								{	
									//Pick up public key
									AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002de2:	4c e8       	lddpc	r8,80002f18 <phy_tx_func+0x4b4>
80002de4:	90 0a       	ld.sh	r10,r8[0x0]
80002de6:	4d 09       	lddpc	r9,80002f24 <phy_tx_func+0x4c0>
80002de8:	b2 0a       	st.h	r9[0x0],r10
									
									//Post back data
									payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002dea:	90 08       	ld.sh	r8,r8[0x0]
80002dec:	ae 78       	st.h	r7[0xe],r8
80002dee:	c0 48       	rjmp	80002df6 <phy_tx_func+0x392>
									//Decrypt AMBE data(XOR) 
									//Recover data

									//payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
									
									payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
80002df0:	4c a8       	lddpc	r8,80002f18 <phy_tx_func+0x4b4>
80002df2:	90 08       	ld.sh	r8,r8[0x0]
80002df4:	ae 78       	st.h	r7[0xe],r8
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002df6:	30 69       	mov	r9,6
80002df8:	4c 08       	lddpc	r8,80002ef8 <phy_tx_func+0x494>
80002dfa:	91 09       	st.w	r8[0x0],r9
80002dfc:	c6 a8       	rjmp	80002ed0 <phy_tx_func+0x46c>
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								//payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
								payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
80002dfe:	4c 78       	lddpc	r8,80002f18 <phy_tx_func+0x4b4>
80002e00:	90 08       	ld.sh	r8,r8[0x0]
80002e02:	ae 78       	st.h	r7[0xe],r8
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e04:	30 69       	mov	r9,6
80002e06:	4b d8       	lddpc	r8,80002ef8 <phy_tx_func+0x494>
80002e08:	91 09       	st.w	r8[0x0],r9
80002e0a:	c6 38       	rjmp	80002ed0 <phy_tx_func+0x46c>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e0c:	e0 68 5a 5a 	mov	r8,23130
80002e10:	ea 18 ab cd 	orh	r8,0xabcd
80002e14:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e16:	30 08       	mov	r8,0
80002e18:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e1a:	4b 89       	lddpc	r9,80002ef8 <phy_tx_func+0x494>
80002e1c:	93 08       	st.w	r9[0x0],r8
80002e1e:	c5 98       	rjmp	80002ed0 <phy_tx_func+0x46c>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e20:	4b 88       	lddpc	r8,80002f00 <phy_tx_func+0x49c>
80002e22:	70 08       	ld.w	r8,r8[0x0]
80002e24:	58 48       	cp.w	r8,4
80002e26:	c0 60       	breq	80002e32 <phy_tx_func+0x3ce>
80002e28:	c3 93       	brcs	80002e9a <phy_tx_func+0x436>
80002e2a:	58 98       	cp.w	r8,9
80002e2c:	e0 8b 00 37 	brhi	80002e9a <phy_tx_func+0x436>
80002e30:	c2 78       	rjmp	80002e7e <phy_tx_func+0x41a>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e32:	4b 88       	lddpc	r8,80002f10 <phy_tx_func+0x4ac>
80002e34:	11 89       	ld.ub	r9,r8[0x0]
80002e36:	30 18       	mov	r8,1
80002e38:	f0 09 18 00 	cp.b	r9,r8
80002e3c:	c1 31       	brne	80002e62 <phy_tx_func+0x3fe>
							{
								//Pick up public key
							
								AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e3e:	4b 78       	lddpc	r8,80002f18 <phy_tx_func+0x4b4>
80002e40:	90 1a       	ld.sh	r10,r8[0x2]
80002e42:	4b 99       	lddpc	r9,80002f24 <phy_tx_func+0x4c0>
80002e44:	b2 1a       	st.h	r9[0x2],r10
								AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e46:	90 2a       	ld.sh	r10,r8[0x4]
80002e48:	b2 2a       	st.h	r9[0x4],r10
								AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e4a:	90 3a       	ld.sh	r10,r8[0x6]
80002e4c:	b2 3a       	st.h	r9[0x6],r10
							
								//Post back data
								payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e4e:	90 19       	ld.sh	r9,r8[0x2]
80002e50:	ae 49       	st.h	r7[0x8],r9
								payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e52:	90 29       	ld.sh	r9,r8[0x4]
80002e54:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e56:	90 38       	ld.sh	r8,r8[0x6]
80002e58:	ae 68       	st.h	r7[0xc],r8
								payload_tx_channel->word[3] = 0x00BA ;
80002e5a:	e0 68 00 ba 	mov	r8,186
80002e5e:	ae 78       	st.h	r7[0xe],r8
80002e60:	c0 b8       	rjmp	80002e76 <phy_tx_func+0x412>

									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3] ^ AMBE_DecryptionKey[3]);
									
									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
80002e62:	4a e8       	lddpc	r8,80002f18 <phy_tx_func+0x4b4>
80002e64:	90 19       	ld.sh	r9,r8[0x2]
80002e66:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
80002e68:	90 29       	ld.sh	r9,r8[0x4]
80002e6a:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]) ;
80002e6c:	90 38       	ld.sh	r8,r8[0x6]
80002e6e:	ae 68       	st.h	r7[0xc],r8
									
									payload_tx_channel->word[3] = 0x00BA ;
80002e70:	e0 68 00 ba 	mov	r8,186
80002e74:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e76:	30 09       	mov	r9,0
80002e78:	4a 08       	lddpc	r8,80002ef8 <phy_tx_func+0x494>
80002e7a:	91 09       	st.w	r8[0x0],r9
80002e7c:	c2 a8       	rjmp	80002ed0 <phy_tx_func+0x46c>
							//Recover data
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3] ^ AMBE_DecryptionKey[3]);
							
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
80002e7e:	4a 78       	lddpc	r8,80002f18 <phy_tx_func+0x4b4>
80002e80:	90 19       	ld.sh	r9,r8[0x2]
80002e82:	ae 49       	st.h	r7[0x8],r9
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
80002e84:	90 29       	ld.sh	r9,r8[0x4]
80002e86:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]) ;
80002e88:	90 38       	ld.sh	r8,r8[0x6]
80002e8a:	ae 68       	st.h	r7[0xc],r8
							
							payload_tx_channel->word[3] = 0x00BA ;
80002e8c:	e0 68 00 ba 	mov	r8,186
80002e90:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e92:	30 09       	mov	r9,0
80002e94:	49 98       	lddpc	r8,80002ef8 <phy_tx_func+0x494>
80002e96:	91 09       	st.w	r8[0x0],r9
80002e98:	c1 c8       	rjmp	80002ed0 <phy_tx_func+0x46c>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e9a:	e0 68 5a 5a 	mov	r8,23130
80002e9e:	ea 18 ab cd 	orh	r8,0xabcd
80002ea2:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ea4:	30 08       	mov	r8,0
80002ea6:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002ea8:	49 49       	lddpc	r9,80002ef8 <phy_tx_func+0x494>
80002eaa:	93 08       	st.w	r9[0x0],r8
80002eac:	c1 28       	rjmp	80002ed0 <phy_tx_func+0x46c>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eae:	e0 68 5a 5a 	mov	r8,23130
80002eb2:	ea 18 ab cd 	orh	r8,0xabcd
80002eb6:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002eb8:	30 08       	mov	r8,0
80002eba:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002ebc:	48 f9       	lddpc	r9,80002ef8 <phy_tx_func+0x494>
80002ebe:	93 08       	st.w	r9[0x0],r8
80002ec0:	c0 88       	rjmp	80002ed0 <phy_tx_func+0x46c>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ec2:	e0 68 5a 5a 	mov	r8,23130
80002ec6:	ea 18 ab cd 	orh	r8,0xabcd
80002eca:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ecc:	30 08       	mov	r8,0
80002ece:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002ed0:	2f fd       	sub	sp,-4
80002ed2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ed6:	00 00       	add	r0,r0
80002ed8:	00 00       	add	r0,r0
80002eda:	0a c8       	st.b	r5++,r8
80002edc:	00 00       	add	r0,r0
80002ede:	0a 74       	tst	r4,r5
80002ee0:	00 00       	add	r0,r0
80002ee2:	0a 7c       	tst	r12,r5
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	53 84       	stdsp	sp[0xe0],r4
80002ee8:	00 00       	add	r0,r0
80002eea:	0a c4       	st.b	r5++,r4
80002eec:	00 00       	add	r0,r0
80002eee:	0a 88       	andn	r8,r5
80002ef0:	00 00       	add	r0,r0
80002ef2:	0a 4f       	or	pc,r5
80002ef4:	00 00       	add	r0,r0
80002ef6:	0a 78       	tst	r8,r5
80002ef8:	00 00       	add	r0,r0
80002efa:	0a a8       	st.w	r5++,r8
80002efc:	80 00       	ld.sh	r0,r0[0x0]
80002efe:	cb 64       	brge	80002e6a <phy_tx_func+0x406>
80002f00:	00 00       	add	r0,r0
80002f02:	0a 64       	and	r4,r5
80002f04:	00 00       	add	r0,r0
80002f06:	0a d0       	st.w	--r5,r0
80002f08:	00 00       	add	r0,r0
80002f0a:	0d a4       	ld.ub	r4,r6[0x2]
80002f0c:	00 00       	add	r0,r0
80002f0e:	0e a0       	st.w	r7++,r0
80002f10:	00 00       	add	r0,r0
80002f12:	0a 40       	or	r0,r5
80002f14:	80 00       	ld.sh	r0,r0[0x0]
80002f16:	cb 08       	rjmp	80003076 <phy_rx_func+0xa>
80002f18:	00 00       	add	r0,r0
80002f1a:	0d 9c       	ld.ub	r12,r6[0x1]
80002f1c:	00 00       	add	r0,r0
80002f1e:	0a a0       	st.w	r5++,r0
80002f20:	00 00       	add	r0,r0
80002f22:	0e a4       	st.w	r7++,r4
80002f24:	00 00       	add	r0,r0
80002f26:	0d a8       	ld.ub	r8,r6[0x2]

80002f28 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f28:	d4 01       	pushm	lr
80002f2a:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f2c:	30 0a       	mov	r10,0
80002f2e:	fa cb ff fc 	sub	r11,sp,-4
80002f32:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f34:	14 99       	mov	r9,r10
80002f36:	1a 9b       	mov	r11,sp
80002f38:	f0 1f 00 05 	mcall	80002f4c <get_idle_store+0x24>
80002f3c:	58 1c       	cp.w	r12,1
80002f3e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f42:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f46:	2f fd       	sub	sp,-4
80002f48:	d8 02       	popm	pc
80002f4a:	00 00       	add	r0,r0
80002f4c:	80 00       	ld.sh	r0,r0[0x0]
80002f4e:	54 74       	stdsp	sp[0x11c],r4

80002f50 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f50:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002f54:	f0 1f 00 21 	mcall	80002fd8 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f58:	4a 1b       	lddpc	r11,80002fdc <phy_init+0x8c>
80002f5a:	4a 2c       	lddpc	r12,80002fe0 <phy_init+0x90>
80002f5c:	f0 1f 00 22 	mcall	80002fe4 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002f60:	30 4b       	mov	r11,4
80002f62:	31 ec       	mov	r12,30
80002f64:	f0 1f 00 21 	mcall	80002fe8 <phy_init+0x98>
80002f68:	4a 18       	lddpc	r8,80002fec <phy_init+0x9c>
80002f6a:	91 0c       	st.w	r8[0x0],r12
80002f6c:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002f6e:	10 96       	mov	r6,r8
80002f70:	4a 05       	lddpc	r5,80002ff0 <phy_init+0xa0>
80002f72:	6c 0c       	ld.w	r12,r6[0x0]
80002f74:	ea 07 00 0b 	add	r11,r5,r7
80002f78:	f0 1f 00 1f 	mcall	80002ff4 <phy_init+0xa4>
80002f7c:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002f80:	e0 47 1e 00 	cp.w	r7,7680
80002f84:	cf 71       	brne	80002f72 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f86:	30 4b       	mov	r11,4
80002f88:	31 4c       	mov	r12,20
80002f8a:	f0 1f 00 18 	mcall	80002fe8 <phy_init+0x98>
80002f8e:	49 b8       	lddpc	r8,80002ff8 <phy_init+0xa8>
80002f90:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f92:	30 4b       	mov	r11,4
80002f94:	30 ac       	mov	r12,10
80002f96:	f0 1f 00 15 	mcall	80002fe8 <phy_init+0x98>
80002f9a:	49 98       	lddpc	r8,80002ffc <phy_init+0xac>
80002f9c:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002f9e:	30 4b       	mov	r11,4
80002fa0:	30 ac       	mov	r12,10
80002fa2:	f0 1f 00 12 	mcall	80002fe8 <phy_init+0x98>
80002fa6:	49 78       	lddpc	r8,80003000 <phy_init+0xb0>
80002fa8:	91 0c       	st.w	r8[0x0],r12
80002faa:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002fac:	10 96       	mov	r6,r8
80002fae:	49 65       	lddpc	r5,80003004 <phy_init+0xb4>
80002fb0:	6c 0c       	ld.w	r12,r6[0x0]
80002fb2:	ea 07 00 0b 	add	r11,r5,r7
80002fb6:	f0 1f 00 10 	mcall	80002ff4 <phy_init+0xa4>
80002fba:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002fbe:	e0 47 14 00 	cp.w	r7,5120
80002fc2:	cf 71       	brne	80002fb0 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80002fc4:	e0 6b 01 00 	mov	r11,256
80002fc8:	30 5c       	mov	r12,5
80002fca:	f0 1f 00 08 	mcall	80002fe8 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80002fce:	48 f8       	lddpc	r8,80003008 <phy_init+0xb8>
80002fd0:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80002fd2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002fd6:	00 00       	add	r0,r0
80002fd8:	80 00       	ld.sh	r0,r0[0x0]
80002fda:	3d fc       	mov	r12,-33
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	2a 64       	sub	r4,-90
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	30 6c       	mov	r12,6
80002fe4:	80 00       	ld.sh	r0,r0[0x0]
80002fe6:	3d e8       	mov	r8,-34
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	57 d8       	stdsp	sp[0x1f4],r8
80002fec:	00 00       	add	r0,r0
80002fee:	0a 98       	mov	r8,r5
80002ff0:	00 00       	add	r0,r0
80002ff2:	22 be       	sub	lr,43
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	29 c0       	sub	r0,-100
80002ff8:	00 00       	add	r0,r0
80002ffa:	0a c8       	st.b	r5++,r8
80002ffc:	00 00       	add	r0,r0
80002ffe:	0a b4       	st.h	r5++,r4
80003000:	00 00       	add	r0,r0
80003002:	0a 6c       	and	r12,r5
80003004:	00 00       	add	r0,r0
80003006:	0e be       	st.h	r7++,lr
80003008:	00 00       	add	r0,r0
8000300a:	0a b0       	st.h	r5++,r0

8000300c <payload_rx>:




static void payload_rx(void * payload)
{
8000300c:	d4 01       	pushm	lr
8000300e:	20 2d       	sub	sp,8
80003010:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003012:	30 08       	mov	r8,0
80003014:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80003016:	48 f8       	lddpc	r8,80003050 <payload_rx+0x44>
80003018:	70 08       	ld.w	r8,r8[0x0]
8000301a:	58 08       	cp.w	r8,0
8000301c:	c0 71       	brne	8000302a <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
8000301e:	30 4b       	mov	r11,4
80003020:	30 5c       	mov	r12,5
80003022:	f0 1f 00 0d 	mcall	80003054 <payload_rx+0x48>
80003026:	48 b8       	lddpc	r8,80003050 <payload_rx+0x44>
80003028:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000302a:	48 a8       	lddpc	r8,80003050 <payload_rx+0x44>
8000302c:	70 0c       	ld.w	r12,r8[0x0]
8000302e:	30 09       	mov	r9,0
80003030:	fa ca ff fc 	sub	r10,sp,-4
80003034:	1a 9b       	mov	r11,sp
80003036:	f0 1f 00 09 	mcall	80003058 <payload_rx+0x4c>
8000303a:	c0 91       	brne	8000304c <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
8000303c:	48 88       	lddpc	r8,8000305c <payload_rx+0x50>
8000303e:	70 0c       	ld.w	r12,r8[0x0]
80003040:	40 0b       	lddsp	r11,sp[0x0]
80003042:	f0 1f 00 08 	mcall	80003060 <payload_rx+0x54>
		logFromISR("mm");
80003046:	48 8c       	lddpc	r12,80003064 <payload_rx+0x58>
80003048:	f0 1f 00 08 	mcall	80003068 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
8000304c:	2f ed       	sub	sp,-8
8000304e:	d8 02       	popm	pc
80003050:	00 00       	add	r0,r0
80003052:	0a 90       	mov	r0,r5
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	57 d8       	stdsp	sp[0x1f4],r8
80003058:	80 00       	ld.sh	r0,r0[0x0]
8000305a:	56 30       	stdsp	sp[0x18c],r0
8000305c:	00 00       	add	r0,r0
8000305e:	0a 6c       	and	r12,r5
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	29 6c       	sub	r12,-106
80003064:	80 00       	ld.sh	r0,r0[0x0]
80003066:	cb 80       	breq	80002fd6 <phy_init+0x86>
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	63 fc       	ld.w	r12,r1[0x7c]

8000306c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
8000306c:	eb cd 40 e0 	pushm	r5-r7,lr
80003070:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003072:	fe f8 0b be 	ld.w	r8,pc[3006]
80003076:	70 08       	ld.w	r8,r8[0x0]
80003078:	58 08       	cp.w	r8,0
8000307a:	e0 80 01 05 	breq	80003284 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000307e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003080:	fe f8 0b b4 	ld.w	r8,pc[2996]
80003084:	70 09       	ld.w	r9,r8[0x0]
80003086:	2f f9       	sub	r9,-1
80003088:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
8000308a:	fe f8 0b ae 	ld.w	r8,pc[2990]
8000308e:	70 08       	ld.w	r8,r8[0x0]
80003090:	58 18       	cp.w	r8,1
80003092:	e0 80 00 84 	breq	8000319a <phy_rx_func+0x12e>
80003096:	c0 73       	brcs	800030a4 <phy_rx_func+0x38>
80003098:	58 28       	cp.w	r8,2
8000309a:	c5 b0       	breq	80003150 <phy_rx_func+0xe4>
8000309c:	58 38       	cp.w	r8,3
8000309e:	e0 81 00 f3 	brne	80003284 <phy_rx_func+0x218>
800030a2:	cd 38       	rjmp	80003248 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800030a4:	e0 6a 5a 5a 	mov	r10,23130
800030a8:	ea 1a ab cd 	orh	r10,0xabcd
800030ac:	14 36       	cp.w	r6,r10
800030ae:	e0 80 00 eb 	breq	80003284 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800030b2:	ec 08 16 10 	lsr	r8,r6,0x10
800030b6:	e0 48 ab cd 	cp.w	r8,43981
800030ba:	e0 81 00 e5 	brne	80003284 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800030be:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800030c2:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800030c6:	20 28       	sub	r8,2
800030c8:	fe f9 0b 74 	ld.w	r9,pc[2932]
800030cc:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800030ce:	30 09       	mov	r9,0
800030d0:	f2 08 19 00 	cp.h	r8,r9
800030d4:	e0 8a 00 d8 	brle	80003284 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800030d8:	fe f8 0b 68 	ld.w	r8,pc[2920]
800030dc:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800030de:	fe f8 0b 66 	ld.w	r8,pc[2918]
800030e2:	70 0c       	ld.w	r12,r8[0x0]
800030e4:	f0 1f 02 d9 	mcall	80003c48 <phy_rx_func+0xbdc>
800030e8:	fe f8 0b 64 	ld.w	r8,pc[2916]
800030ec:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
800030ee:	58 0c       	cp.w	r12,0
800030f0:	e0 80 00 ca 	breq	80003284 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
800030f4:	fe f8 0b 4c 	ld.w	r8,pc[2892]
800030f8:	90 09       	ld.sh	r9,r8[0x0]
800030fa:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800030fe:	2f f9       	sub	r9,-1
80003100:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003102:	fe fa 0b 4a 	ld.w	r10,pc[2890]
80003106:	74 0a       	ld.w	r10,r10[0x0]
80003108:	fe fb 0b 2c 	ld.w	r11,pc[2860]
8000310c:	76 0b       	ld.w	r11,r11[0x0]
8000310e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003112:	2f f9       	sub	r9,-1
80003114:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003116:	e2 16 0f 00 	andl	r6,0xf00,COH
8000311a:	e0 46 01 00 	cp.w	r6,256
8000311e:	c0 c0       	breq	80003136 <phy_rx_func+0xca>
80003120:	e0 8b 00 05 	brhi	8000312a <phy_rx_func+0xbe>
80003124:	58 06       	cp.w	r6,0
80003126:	c0 80       	breq	80003136 <phy_rx_func+0xca>
80003128:	c0 c8       	rjmp	80003140 <phy_rx_func+0xd4>
8000312a:	e0 46 02 00 	cp.w	r6,512
8000312e:	c0 40       	breq	80003136 <phy_rx_func+0xca>
80003130:	e0 46 03 00 	cp.w	r6,768
80003134:	c0 61       	brne	80003140 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003136:	30 29       	mov	r9,2
80003138:	fe f8 0b 00 	ld.w	r8,pc[2816]
8000313c:	91 09       	st.w	r8[0x0],r9
8000313e:	ca 38       	rjmp	80003284 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003140:	fe f6 0b 0c 	ld.w	r6,pc[2828]
80003144:	6c 0c       	ld.w	r12,r6[0x0]
80003146:	f0 1f 02 c3 	mcall	80003c50 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
8000314a:	30 08       	mov	r8,0
8000314c:	8d 08       	st.w	r6[0x0],r8
8000314e:	c9 b8       	rjmp	80003284 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003150:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003154:	b1 86       	lsr	r6,0x10
80003156:	14 06       	add	r6,r10
80003158:	fe f8 0a fc 	ld.w	r8,pc[2812]
8000315c:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000315e:	fe f8 0a e2 	ld.w	r8,pc[2786]
80003162:	90 09       	ld.sh	r9,r8[0x0]
80003164:	fe fb 0a e8 	ld.w	r11,pc[2792]
80003168:	76 0b       	ld.w	r11,r11[0x0]
8000316a:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000316e:	2f f9       	sub	r9,-1
80003170:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003172:	fe f9 0a ca 	ld.w	r9,pc[2762]
80003176:	92 08       	ld.sh	r8,r9[0x0]
80003178:	20 28       	sub	r8,2
8000317a:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000317c:	30 09       	mov	r9,0
8000317e:	f2 08 19 00 	cp.h	r8,r9
80003182:	e0 8a 00 07 	brle	80003190 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003186:	30 19       	mov	r9,1
80003188:	fe f8 0a b0 	ld.w	r8,pc[2736]
8000318c:	91 09       	st.w	r8[0x0],r9
8000318e:	c7 b8       	rjmp	80003284 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003190:	30 39       	mov	r9,3
80003192:	fe f8 0a a6 	ld.w	r8,pc[2726]
80003196:	91 09       	st.w	r8[0x0],r9
80003198:	c7 68       	rjmp	80003284 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
8000319a:	ec 0a 14 10 	asr	r10,r6,0x10
8000319e:	fe f8 0a b6 	ld.w	r8,pc[2742]
800031a2:	90 09       	ld.sh	r9,r8[0x0]
800031a4:	14 09       	add	r9,r10
800031a6:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800031a8:	fe f9 0a 98 	ld.w	r9,pc[2712]
800031ac:	92 08       	ld.sh	r8,r9[0x0]
800031ae:	fe fb 0a 9e 	ld.w	r11,pc[2718]
800031b2:	76 0b       	ld.w	r11,r11[0x0]
800031b4:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800031b8:	2f f8       	sub	r8,-1
800031ba:	5c 88       	casts.h	r8
800031bc:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800031be:	fe fa 0a 7e 	ld.w	r10,pc[2686]
800031c2:	94 09       	ld.sh	r9,r10[0x0]
800031c4:	20 29       	sub	r9,2
800031c6:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800031c8:	30 0a       	mov	r10,0
800031ca:	f4 09 19 00 	cp.h	r9,r10
800031ce:	e0 89 00 1f 	brgt	8000320c <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800031d2:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800031d6:	e0 46 00 ba 	cp.w	r6,186
800031da:	c0 d1       	brne	800031f4 <phy_rx_func+0x188>
800031dc:	fe f8 0a 78 	ld.w	r8,pc[2680]
800031e0:	90 09       	ld.sh	r9,r8[0x0]
800031e2:	f4 09 19 00 	cp.h	r9,r10
800031e6:	c0 71       	brne	800031f4 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
800031e8:	fe f8 0a 64 	ld.w	r8,pc[2660]
800031ec:	70 0c       	ld.w	r12,r8[0x0]
800031ee:	f0 1f 02 9b 	mcall	80003c58 <phy_rx_func+0xbec>
800031f2:	c0 88       	rjmp	80003202 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
800031f4:	fe f6 0a 58 	ld.w	r6,pc[2648]
800031f8:	6c 0c       	ld.w	r12,r6[0x0]
800031fa:	f0 1f 02 96 	mcall	80003c50 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
800031fe:	30 08       	mov	r8,0
80003200:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003202:	30 09       	mov	r9,0
80003204:	fe f8 0a 34 	ld.w	r8,pc[2612]
80003208:	91 09       	st.w	r8[0x0],r9
8000320a:	c3 d8       	rjmp	80003284 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000320c:	5c 86       	casts.h	r6
8000320e:	fe f9 0a 46 	ld.w	r9,pc[2630]
80003212:	92 0a       	ld.sh	r10,r9[0x0]
80003214:	0c 0a       	add	r10,r6
80003216:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003218:	fe f9 0a 34 	ld.w	r9,pc[2612]
8000321c:	72 09       	ld.w	r9,r9[0x0]
8000321e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003222:	2f f8       	sub	r8,-1
80003224:	fe f9 0a 1c 	ld.w	r9,pc[2588]
80003228:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000322a:	fe f9 0a 12 	ld.w	r9,pc[2578]
8000322e:	92 08       	ld.sh	r8,r9[0x0]
80003230:	20 28       	sub	r8,2
80003232:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003234:	30 09       	mov	r9,0
80003236:	f2 08 19 00 	cp.h	r8,r9
8000323a:	e0 89 00 25 	brgt	80003284 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000323e:	30 39       	mov	r9,3
80003240:	fe f8 09 f8 	ld.w	r8,pc[2552]
80003244:	91 09       	st.w	r8[0x0],r9
80003246:	c1 f8       	rjmp	80003284 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003248:	e6 16 00 ff 	andh	r6,0xff,COH
8000324c:	fc 19 00 ba 	movh	r9,0xba
80003250:	12 36       	cp.w	r6,r9
80003252:	c0 e1       	brne	8000326e <phy_rx_func+0x202>
80003254:	fe f8 0a 00 	ld.w	r8,pc[2560]
80003258:	90 09       	ld.sh	r9,r8[0x0]
8000325a:	30 08       	mov	r8,0
8000325c:	f0 09 19 00 	cp.h	r9,r8
80003260:	c0 71       	brne	8000326e <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003262:	fe f8 09 ea 	ld.w	r8,pc[2538]
80003266:	70 0c       	ld.w	r12,r8[0x0]
80003268:	f0 1f 02 7c 	mcall	80003c58 <phy_rx_func+0xbec>
8000326c:	c0 88       	rjmp	8000327c <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
8000326e:	fe f6 09 de 	ld.w	r6,pc[2526]
80003272:	6c 0c       	ld.w	r12,r6[0x0]
80003274:	f0 1f 02 77 	mcall	80003c50 <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
80003278:	30 08       	mov	r8,0
8000327a:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000327c:	30 09       	mov	r9,0
8000327e:	fe f8 09 ba 	ld.w	r8,pc[2490]
80003282:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
80003284:	fe f8 09 d8 	ld.w	r8,pc[2520]
80003288:	11 89       	ld.ub	r9,r8[0x0]
8000328a:	30 08       	mov	r8,0
8000328c:	f0 09 18 00 	cp.b	r9,r8
80003290:	c0 d1       	brne	800032aa <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
80003292:	fe f8 09 ce 	ld.w	r8,pc[2510]
80003296:	70 0c       	ld.w	r12,r8[0x0]
80003298:	f0 1f 02 6c 	mcall	80003c48 <phy_rx_func+0xbdc>
8000329c:	fe f8 09 c8 	ld.w	r8,pc[2504]
800032a0:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800032a2:	30 19       	mov	r9,1
800032a4:	fe f8 09 b8 	ld.w	r8,pc[2488]
800032a8:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800032aa:	fe f8 09 be 	ld.w	r8,pc[2494]
800032ae:	70 08       	ld.w	r8,r8[0x0]
800032b0:	58 38       	cp.w	r8,3
800032b2:	e0 80 04 7a 	breq	80003ba6 <phy_rx_func+0xb3a>
800032b6:	58 48       	cp.w	r8,4
800032b8:	e0 80 01 02 	breq	800034bc <phy_rx_func+0x450>
800032bc:	58 08       	cp.w	r8,0
800032be:	e0 81 04 b7 	brne	80003c2c <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800032c2:	6e 28       	ld.w	r8,r7[0x8]
800032c4:	e0 6a 5a 5a 	mov	r10,23130
800032c8:	ea 1a ab cd 	orh	r10,0xabcd
800032cc:	14 38       	cp.w	r8,r10
800032ce:	c0 71       	brne	800032dc <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
800032d0:	30 09       	mov	r9,0
800032d2:	fe f8 09 9a 	ld.w	r8,pc[2458]
800032d6:	91 09       	st.w	r8[0x0],r9
800032d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800032dc:	10 99       	mov	r9,r8
800032de:	e0 19 00 00 	andl	r9,0x0
800032e2:	fc 1a ab cd 	movh	r10,0xabcd
800032e6:	14 39       	cp.w	r9,r10
800032e8:	e0 81 04 a2 	brne	80003c2c <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800032ec:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800032f0:	fe f9 09 80 	ld.w	r9,pc[2432]
800032f4:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
800032f6:	fe f8 09 6e 	ld.w	r8,pc[2414]
800032fa:	70 08       	ld.w	r8,r8[0x0]
800032fc:	58 08       	cp.w	r8,0
800032fe:	c1 11       	brne	80003320 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
80003300:	fe f8 09 60 	ld.w	r8,pc[2400]
80003304:	70 0c       	ld.w	r12,r8[0x0]
80003306:	f0 1f 02 51 	mcall	80003c48 <phy_rx_func+0xbdc>
8000330a:	fe f8 09 5a 	ld.w	r8,pc[2394]
8000330e:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
80003310:	58 0c       	cp.w	r12,0
80003312:	c0 71       	brne	80003320 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003314:	fe fc 09 60 	ld.w	r12,pc[2400]
80003318:	f0 1f 02 58 	mcall	80003c78 <phy_rx_func+0xc0c>
8000331c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003320:	6e 28       	ld.w	r8,r7[0x8]
80003322:	e2 18 f0 00 	andl	r8,0xf000,COH
80003326:	e0 48 c0 00 	cp.w	r8,49152
8000332a:	e0 81 00 c3 	brne	800034b0 <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
8000332e:	30 19       	mov	r9,1
80003330:	fe f8 09 4c 	ld.w	r8,pc[2380]
80003334:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
80003336:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000333a:	fe f8 09 46 	ld.w	r8,pc[2374]
8000333e:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003340:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003344:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80003348:	fe f9 09 3c 	ld.w	r9,pc[2364]
8000334c:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
8000334e:	11 88       	ld.ub	r8,r8[0x0]
80003350:	37 f9       	mov	r9,127
80003352:	f2 08 18 00 	cp.b	r8,r9
80003356:	c6 d0       	breq	80003430 <phy_rx_func+0x3c4>
80003358:	e0 8b 00 0c 	brhi	80003370 <phy_rx_func+0x304>
8000335c:	31 29       	mov	r9,18
8000335e:	f2 08 18 00 	cp.b	r8,r9
80003362:	c4 20       	breq	800033e6 <phy_rx_func+0x37a>
80003364:	31 39       	mov	r9,19
80003366:	f2 08 18 00 	cp.b	r8,r9
8000336a:	e0 81 00 83 	brne	80003470 <phy_rx_func+0x404>
8000336e:	c5 b8       	rjmp	80003424 <phy_rx_func+0x3b8>
80003370:	2f 08       	sub	r8,-16
80003372:	30 19       	mov	r9,1
80003374:	f2 08 18 00 	cp.b	r8,r9
80003378:	e0 8b 00 7c 	brhi	80003470 <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000337c:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003380:	e2 18 00 f0 	andl	r8,0xf0,COH
80003384:	59 08       	cp.w	r8,16
80003386:	c0 71       	brne	80003394 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
80003388:	30 19       	mov	r9,1
8000338a:	fe f8 08 e2 	ld.w	r8,pc[2274]
8000338e:	91 09       	st.w	r8[0x0],r9
80003390:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003394:	e0 48 00 20 	cp.w	r8,32
80003398:	c2 11       	brne	800033da <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
8000339a:	30 a9       	mov	r9,10
8000339c:	fe f8 08 d0 	ld.w	r8,pc[2256]
800033a0:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800033a2:	fe f6 08 e6 	ld.w	r6,pc[2278]
800033a6:	6c 08       	ld.w	r8,r6[0x0]
800033a8:	f0 0a 11 ff 	rsub	r10,r8,-1
800033ac:	fe f7 08 b8 	ld.w	r7,pc[2232]
800033b0:	2f f8       	sub	r8,-1
800033b2:	6e 0c       	ld.w	r12,r7[0x0]
800033b4:	f4 ca fe 00 	sub	r10,r10,-512
800033b8:	30 0b       	mov	r11,0
800033ba:	10 0c       	add	r12,r8
800033bc:	f0 1f 02 34 	mcall	80003c8c <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
800033c0:	30 08       	mov	r8,0
800033c2:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800033c4:	6e 0c       	ld.w	r12,r7[0x0]
800033c6:	f0 1f 02 33 	mcall	80003c90 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800033ca:	fe f8 08 96 	ld.w	r8,pc[2198]
800033ce:	70 0c       	ld.w	r12,r8[0x0]
800033d0:	f0 1f 02 1e 	mcall	80003c48 <phy_rx_func+0xbdc>
800033d4:	8f 0c       	st.w	r7[0x0],r12
800033d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800033da:	30 09       	mov	r9,0
800033dc:	fe f8 08 90 	ld.w	r8,pc[2192]
800033e0:	91 09       	st.w	r8[0x0],r9
800033e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800033e6:	fe f9 08 8a 	ld.w	r9,pc[2186]
800033ea:	72 08       	ld.w	r8,r9[0x0]
800033ec:	20 48       	sub	r8,4
800033ee:	93 08       	st.w	r9[0x0],r8
800033f0:	e0 80 04 1e 	breq	80003c2c <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800033f4:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800033f8:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800033fc:	fe f8 08 98 	ld.w	r8,pc[2200]
80003400:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003402:	8e 69       	ld.sh	r9,r7[0xc]
80003404:	fe f8 08 94 	ld.w	r8,pc[2196]
80003408:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000340a:	8e 79       	ld.sh	r9,r7[0xe]
8000340c:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
8000340e:	f0 1f 02 24 	mcall	80003c9c <phy_rx_func+0xc30>
80003412:	fe f8 08 5a 	ld.w	r8,pc[2138]
80003416:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003418:	30 49       	mov	r9,4
8000341a:	fe f8 08 4e 	ld.w	r8,pc[2126]
8000341e:	91 09       	st.w	r8[0x0],r9
80003420:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003424:	30 09       	mov	r9,0
80003426:	fe f8 08 46 	ld.w	r8,pc[2118]
8000342a:	91 09       	st.w	r8[0x0],r9
8000342c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003430:	fe f9 08 40 	ld.w	r9,pc[2112]
80003434:	72 08       	ld.w	r8,r9[0x0]
80003436:	20 48       	sub	r8,4
80003438:	93 08       	st.w	r9[0x0],r8
8000343a:	e0 80 03 f9 	breq	80003c2c <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000343e:	fe f8 08 62 	ld.w	r8,pc[2146]
80003442:	70 09       	ld.w	r9,r8[0x0]
80003444:	8e 7b       	ld.sh	r11,r7[0xe]
80003446:	fe fa 08 5e 	ld.w	r10,pc[2142]
8000344a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000344e:	2f f9       	sub	r9,-1
80003450:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003452:	fe f8 08 32 	ld.w	r8,pc[2098]
80003456:	70 09       	ld.w	r9,r8[0x0]
80003458:	20 29       	sub	r9,2
8000345a:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000345c:	30 29       	mov	r9,2
8000345e:	fe f8 08 0e 	ld.w	r8,pc[2062]
80003462:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003464:	30 39       	mov	r9,3
80003466:	fe f8 08 02 	ld.w	r8,pc[2050]
8000346a:	91 09       	st.w	r8[0x0],r9
8000346c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003470:	30 39       	mov	r9,3
80003472:	fe f8 07 fa 	ld.w	r8,pc[2042]
80003476:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003478:	6e 29       	ld.w	r9,r7[0x8]
8000347a:	fe f8 08 2e 	ld.w	r8,pc[2094]
8000347e:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003480:	6e 39       	ld.w	r9,r7[0xc]
80003482:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003484:	fe f8 07 ec 	ld.w	r8,pc[2028]
80003488:	70 08       	ld.w	r8,r8[0x0]
8000348a:	59 48       	cp.w	r8,20
8000348c:	c0 61       	brne	80003498 <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000348e:	31 89       	mov	r9,24
80003490:	fe f8 07 e0 	ld.w	r8,pc[2016]
80003494:	91 09       	st.w	r8[0x0],r9
80003496:	c0 78       	rjmp	800034a4 <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003498:	59 08       	cp.w	r8,16
8000349a:	c0 51       	brne	800034a4 <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000349c:	31 09       	mov	r9,16
8000349e:	fe f8 07 d2 	ld.w	r8,pc[2002]
800034a2:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034a4:	30 49       	mov	r9,4
800034a6:	fe f8 07 c2 	ld.w	r8,pc[1986]
800034aa:	91 09       	st.w	r8[0x0],r9
800034ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
800034b0:	30 09       	mov	r9,0
800034b2:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034b6:	b0 89       	st.b	r8[0x0],r9
800034b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034bc:	fe f8 07 c4 	ld.w	r8,pc[1988]
800034c0:	11 89       	ld.ub	r9,r8[0x0]
800034c2:	31 28       	mov	r8,18
800034c4:	f0 09 18 00 	cp.b	r9,r8
800034c8:	e0 81 01 4c 	brne	80003760 <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
800034cc:	ef 39 00 09 	ld.ub	r9,r7[9]
800034d0:	fe f8 07 b0 	ld.w	r8,pc[1968]
800034d4:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800034d6:	11 89       	ld.ub	r9,r8[0x0]
800034d8:	3f 28       	mov	r8,-14
800034da:	f0 09 18 00 	cp.b	r9,r8
800034de:	e0 81 01 3b 	brne	80003754 <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
800034e2:	30 19       	mov	r9,1
800034e4:	fe f8 07 c8 	ld.w	r8,pc[1992]
800034e8:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
800034ea:	6e 29       	ld.w	r9,r7[0x8]
800034ec:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
800034f0:	fe f8 07 80 	ld.w	r8,pc[1920]
800034f4:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800034f6:	8e 59       	ld.sh	r9,r7[0xa]
800034f8:	fe f8 07 b8 	ld.w	r8,pc[1976]
800034fc:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800034fe:	8e 69       	ld.sh	r9,r7[0xc]
80003500:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003502:	8e 79       	ld.sh	r9,r7[0xe]
80003504:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003506:	fe f8 07 82 	ld.w	r8,pc[1922]
8000350a:	fe f9 07 5a 	ld.w	r9,pc[1882]
8000350e:	72 0a       	ld.w	r10,r9[0x0]
80003510:	70 09       	ld.w	r9,r8[0x0]
80003512:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003516:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000351a:	70 09       	ld.w	r9,r8[0x0]
8000351c:	2f f9       	sub	r9,-1
8000351e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003520:	e0 49 01 ff 	cp.w	r9,511
80003524:	e0 88 00 16 	brls	80003550 <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003528:	30 09       	mov	r9,0
8000352a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000352c:	fe f6 07 38 	ld.w	r6,pc[1848]
80003530:	6c 0c       	ld.w	r12,r6[0x0]
80003532:	f0 1f 01 d8 	mcall	80003c90 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003536:	fe f8 07 2a 	ld.w	r8,pc[1834]
8000353a:	70 0c       	ld.w	r12,r8[0x0]
8000353c:	f0 1f 01 c3 	mcall	80003c48 <phy_rx_func+0xbdc>
80003540:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003542:	c0 71       	brne	80003550 <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003544:	30 09       	mov	r9,0
80003546:	fe f8 07 22 	ld.w	r8,pc[1826]
8000354a:	91 09       	st.w	r8[0x0],r9
8000354c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003550:	fe f9 07 20 	ld.w	r9,pc[1824]
80003554:	72 08       	ld.w	r8,r9[0x0]
80003556:	20 18       	sub	r8,1
80003558:	93 08       	st.w	r9[0x0],r8
8000355a:	c0 71       	brne	80003568 <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
8000355c:	30 09       	mov	r9,0
8000355e:	fe f8 07 0a 	ld.w	r8,pc[1802]
80003562:	91 09       	st.w	r8[0x0],r9
80003564:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003568:	fe f8 07 20 	ld.w	r8,pc[1824]
8000356c:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003570:	72 0a       	ld.w	r10,r9[0x0]
80003572:	70 09       	ld.w	r9,r8[0x0]
80003574:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003578:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000357c:	70 09       	ld.w	r9,r8[0x0]
8000357e:	2f f9       	sub	r9,-1
80003580:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003582:	e0 49 01 ff 	cp.w	r9,511
80003586:	e0 88 00 16 	brls	800035b2 <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
8000358a:	30 09       	mov	r9,0
8000358c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000358e:	fe f6 06 d6 	ld.w	r6,pc[1750]
80003592:	6c 0c       	ld.w	r12,r6[0x0]
80003594:	f0 1f 01 bf 	mcall	80003c90 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003598:	fe f8 06 c8 	ld.w	r8,pc[1736]
8000359c:	70 0c       	ld.w	r12,r8[0x0]
8000359e:	f0 1f 01 ab 	mcall	80003c48 <phy_rx_func+0xbdc>
800035a2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035a4:	c0 71       	brne	800035b2 <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
800035a6:	30 09       	mov	r9,0
800035a8:	fe f8 06 c0 	ld.w	r8,pc[1728]
800035ac:	91 09       	st.w	r8[0x0],r9
800035ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035b2:	fe f9 06 be 	ld.w	r9,pc[1726]
800035b6:	72 08       	ld.w	r8,r9[0x0]
800035b8:	20 18       	sub	r8,1
800035ba:	93 08       	st.w	r9[0x0],r8
800035bc:	c0 71       	brne	800035ca <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
800035be:	30 09       	mov	r9,0
800035c0:	fe f8 06 a8 	ld.w	r8,pc[1704]
800035c4:	91 09       	st.w	r8[0x0],r9
800035c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035ca:	fe f8 06 be 	ld.w	r8,pc[1726]
800035ce:	fe f9 06 96 	ld.w	r9,pc[1686]
800035d2:	72 0a       	ld.w	r10,r9[0x0]
800035d4:	70 09       	ld.w	r9,r8[0x0]
800035d6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800035da:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035de:	70 09       	ld.w	r9,r8[0x0]
800035e0:	2f f9       	sub	r9,-1
800035e2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035e4:	e0 49 01 ff 	cp.w	r9,511
800035e8:	e0 88 00 16 	brls	80003614 <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
800035ec:	30 09       	mov	r9,0
800035ee:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035f0:	fe f6 06 74 	ld.w	r6,pc[1652]
800035f4:	6c 0c       	ld.w	r12,r6[0x0]
800035f6:	f0 1f 01 a7 	mcall	80003c90 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800035fa:	fe f8 06 66 	ld.w	r8,pc[1638]
800035fe:	70 0c       	ld.w	r12,r8[0x0]
80003600:	f0 1f 01 92 	mcall	80003c48 <phy_rx_func+0xbdc>
80003604:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003606:	c0 71       	brne	80003614 <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
80003608:	30 09       	mov	r9,0
8000360a:	fe f8 06 5e 	ld.w	r8,pc[1630]
8000360e:	91 09       	st.w	r8[0x0],r9
80003610:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003614:	fe f9 06 5c 	ld.w	r9,pc[1628]
80003618:	72 08       	ld.w	r8,r9[0x0]
8000361a:	20 18       	sub	r8,1
8000361c:	93 08       	st.w	r9[0x0],r8
8000361e:	c0 71       	brne	8000362c <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003620:	30 09       	mov	r9,0
80003622:	fe f8 06 46 	ld.w	r8,pc[1606]
80003626:	91 09       	st.w	r8[0x0],r9
80003628:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000362c:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003630:	fe f9 06 34 	ld.w	r9,pc[1588]
80003634:	72 0a       	ld.w	r10,r9[0x0]
80003636:	70 09       	ld.w	r9,r8[0x0]
80003638:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000363c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003640:	70 09       	ld.w	r9,r8[0x0]
80003642:	2f f9       	sub	r9,-1
80003644:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003646:	e0 49 01 ff 	cp.w	r9,511
8000364a:	e0 88 00 16 	brls	80003676 <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
8000364e:	30 09       	mov	r9,0
80003650:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003652:	fe f6 06 12 	ld.w	r6,pc[1554]
80003656:	6c 0c       	ld.w	r12,r6[0x0]
80003658:	f0 1f 01 8e 	mcall	80003c90 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000365c:	fe f8 06 04 	ld.w	r8,pc[1540]
80003660:	70 0c       	ld.w	r12,r8[0x0]
80003662:	f0 1f 01 7a 	mcall	80003c48 <phy_rx_func+0xbdc>
80003666:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003668:	c0 71       	brne	80003676 <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
8000366a:	30 09       	mov	r9,0
8000366c:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003670:	91 09       	st.w	r8[0x0],r9
80003672:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003676:	fe f9 05 fa 	ld.w	r9,pc[1530]
8000367a:	72 08       	ld.w	r8,r9[0x0]
8000367c:	20 18       	sub	r8,1
8000367e:	93 08       	st.w	r9[0x0],r8
80003680:	c0 71       	brne	8000368e <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
80003682:	30 09       	mov	r9,0
80003684:	fe f8 05 e4 	ld.w	r8,pc[1508]
80003688:	91 09       	st.w	r8[0x0],r9
8000368a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
8000368e:	fe f8 05 fa 	ld.w	r8,pc[1530]
80003692:	fe f9 05 d2 	ld.w	r9,pc[1490]
80003696:	72 0a       	ld.w	r10,r9[0x0]
80003698:	70 09       	ld.w	r9,r8[0x0]
8000369a:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000369e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036a2:	70 09       	ld.w	r9,r8[0x0]
800036a4:	2f f9       	sub	r9,-1
800036a6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036a8:	e0 49 01 ff 	cp.w	r9,511
800036ac:	e0 88 00 16 	brls	800036d8 <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
800036b0:	30 09       	mov	r9,0
800036b2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036b4:	fe f6 05 b0 	ld.w	r6,pc[1456]
800036b8:	6c 0c       	ld.w	r12,r6[0x0]
800036ba:	f0 1f 01 76 	mcall	80003c90 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800036be:	fe f8 05 a2 	ld.w	r8,pc[1442]
800036c2:	70 0c       	ld.w	r12,r8[0x0]
800036c4:	f0 1f 01 61 	mcall	80003c48 <phy_rx_func+0xbdc>
800036c8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036ca:	c0 71       	brne	800036d8 <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
800036cc:	30 09       	mov	r9,0
800036ce:	fe f8 05 9a 	ld.w	r8,pc[1434]
800036d2:	91 09       	st.w	r8[0x0],r9
800036d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036d8:	fe f9 05 98 	ld.w	r9,pc[1432]
800036dc:	72 08       	ld.w	r8,r9[0x0]
800036de:	20 18       	sub	r8,1
800036e0:	93 08       	st.w	r9[0x0],r8
800036e2:	c0 71       	brne	800036f0 <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
800036e4:	30 09       	mov	r9,0
800036e6:	fe f8 05 82 	ld.w	r8,pc[1410]
800036ea:	91 09       	st.w	r8[0x0],r9
800036ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
800036f0:	fe f8 05 98 	ld.w	r8,pc[1432]
800036f4:	fe f9 05 70 	ld.w	r9,pc[1392]
800036f8:	72 0a       	ld.w	r10,r9[0x0]
800036fa:	70 09       	ld.w	r9,r8[0x0]
800036fc:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003700:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003704:	70 09       	ld.w	r9,r8[0x0]
80003706:	2f f9       	sub	r9,-1
80003708:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000370a:	e0 49 01 ff 	cp.w	r9,511
8000370e:	e0 88 00 16 	brls	8000373a <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80003712:	30 09       	mov	r9,0
80003714:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003716:	fe f7 05 4e 	ld.w	r7,pc[1358]
8000371a:	6e 0c       	ld.w	r12,r7[0x0]
8000371c:	f0 1f 01 5d 	mcall	80003c90 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003720:	fe f8 05 40 	ld.w	r8,pc[1344]
80003724:	70 0c       	ld.w	r12,r8[0x0]
80003726:	f0 1f 01 49 	mcall	80003c48 <phy_rx_func+0xbdc>
8000372a:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000372c:	c0 71       	brne	8000373a <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
8000372e:	30 09       	mov	r9,0
80003730:	fe f8 05 38 	ld.w	r8,pc[1336]
80003734:	91 09       	st.w	r8[0x0],r9
80003736:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000373a:	fe f9 05 36 	ld.w	r9,pc[1334]
8000373e:	72 08       	ld.w	r8,r9[0x0]
80003740:	20 18       	sub	r8,1
80003742:	93 08       	st.w	r9[0x0],r8
80003744:	e0 81 02 74 	brne	80003c2c <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
80003748:	30 09       	mov	r9,0
8000374a:	fe f8 05 1e 	ld.w	r8,pc[1310]
8000374e:	91 09       	st.w	r8[0x0],r9
80003750:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003754:	30 09       	mov	r9,0
80003756:	fe f8 05 12 	ld.w	r8,pc[1298]
8000375a:	91 09       	st.w	r8[0x0],r9
8000375c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003760:	fe f8 05 20 	ld.w	r8,pc[1312]
80003764:	11 89       	ld.ub	r9,r8[0x0]
80003766:	3f 28       	mov	r8,-14
80003768:	f0 09 18 00 	cp.b	r9,r8
8000376c:	c4 31       	brne	800037f2 <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
8000376e:	8e 49       	ld.sh	r9,r7[0x8]
80003770:	fe f8 05 40 	ld.w	r8,pc[1344]
80003774:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003776:	fe f8 05 12 	ld.w	r8,pc[1298]
8000377a:	fe f9 04 ea 	ld.w	r9,pc[1258]
8000377e:	72 0a       	ld.w	r10,r9[0x0]
80003780:	70 09       	ld.w	r9,r8[0x0]
80003782:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003786:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000378a:	70 09       	ld.w	r9,r8[0x0]
8000378c:	2f f9       	sub	r9,-1
8000378e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003790:	e0 49 01 ff 	cp.w	r9,511
80003794:	e0 88 00 16 	brls	800037c0 <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
80003798:	30 09       	mov	r9,0
8000379a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000379c:	fe f7 04 c8 	ld.w	r7,pc[1224]
800037a0:	6e 0c       	ld.w	r12,r7[0x0]
800037a2:	f0 1f 01 3c 	mcall	80003c90 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800037a6:	fe f8 04 ba 	ld.w	r8,pc[1210]
800037aa:	70 0c       	ld.w	r12,r8[0x0]
800037ac:	f0 1f 01 27 	mcall	80003c48 <phy_rx_func+0xbdc>
800037b0:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037b2:	c0 71       	brne	800037c0 <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
800037b4:	30 09       	mov	r9,0
800037b6:	fe f8 04 b2 	ld.w	r8,pc[1202]
800037ba:	91 09       	st.w	r8[0x0],r9
800037bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037c0:	fe f9 04 b0 	ld.w	r9,pc[1200]
800037c4:	72 08       	ld.w	r8,r9[0x0]
800037c6:	20 18       	sub	r8,1
800037c8:	93 08       	st.w	r9[0x0],r8
800037ca:	c0 71       	brne	800037d8 <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
800037cc:	30 09       	mov	r9,0
800037ce:	fe f8 04 9a 	ld.w	r8,pc[1178]
800037d2:	91 09       	st.w	r8[0x0],r9
800037d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800037d8:	20 18       	sub	r8,1
800037da:	fe f9 04 96 	ld.w	r9,pc[1174]
800037de:	93 08       	st.w	r9[0x0],r8
800037e0:	58 08       	cp.w	r8,0
800037e2:	e0 81 02 25 	brne	80003c2c <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
800037e6:	30 09       	mov	r9,0
800037e8:	fe f8 04 80 	ld.w	r8,pc[1152]
800037ec:	91 09       	st.w	r8[0x0],r9
800037ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800037f2:	fe f8 04 8e 	ld.w	r8,pc[1166]
800037f6:	11 89       	ld.ub	r9,r8[0x0]
800037f8:	3f 38       	mov	r8,-13
800037fa:	f0 09 18 00 	cp.b	r9,r8
800037fe:	e0 81 01 0c 	brne	80003a16 <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003802:	8e 49       	ld.sh	r9,r7[0x8]
80003804:	fe f8 04 ac 	ld.w	r8,pc[1196]
80003808:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000380a:	8e 59       	ld.sh	r9,r7[0xa]
8000380c:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000380e:	8e 69       	ld.sh	r9,r7[0xc]
80003810:	b0 39       	st.h	r8[0x6],r9
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003812:	fe f8 04 76 	ld.w	r8,pc[1142]
80003816:	fe f9 04 4e 	ld.w	r9,pc[1102]
8000381a:	72 0a       	ld.w	r10,r9[0x0]
8000381c:	70 09       	ld.w	r9,r8[0x0]
8000381e:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003822:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003826:	70 09       	ld.w	r9,r8[0x0]
80003828:	2f f9       	sub	r9,-1
8000382a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000382c:	e0 49 01 ff 	cp.w	r9,511
80003830:	e0 88 00 16 	brls	8000385c <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003834:	30 09       	mov	r9,0
80003836:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003838:	fe f6 04 2c 	ld.w	r6,pc[1068]
8000383c:	6c 0c       	ld.w	r12,r6[0x0]
8000383e:	f0 1f 01 15 	mcall	80003c90 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003842:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003846:	70 0c       	ld.w	r12,r8[0x0]
80003848:	f0 1f 01 00 	mcall	80003c48 <phy_rx_func+0xbdc>
8000384c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000384e:	c0 71       	brne	8000385c <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003850:	30 09       	mov	r9,0
80003852:	fe f8 04 16 	ld.w	r8,pc[1046]
80003856:	91 09       	st.w	r8[0x0],r9
80003858:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000385c:	fe f9 04 14 	ld.w	r9,pc[1044]
80003860:	72 08       	ld.w	r8,r9[0x0]
80003862:	20 18       	sub	r8,1
80003864:	93 08       	st.w	r9[0x0],r8
80003866:	c0 71       	brne	80003874 <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
80003868:	30 09       	mov	r9,0
8000386a:	fe f8 03 fe 	ld.w	r8,pc[1022]
8000386e:	91 09       	st.w	r8[0x0],r9
80003870:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003874:	fe f8 04 14 	ld.w	r8,pc[1044]
80003878:	fe f9 03 ec 	ld.w	r9,pc[1004]
8000387c:	72 0a       	ld.w	r10,r9[0x0]
8000387e:	70 09       	ld.w	r9,r8[0x0]
80003880:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003884:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003888:	70 09       	ld.w	r9,r8[0x0]
8000388a:	2f f9       	sub	r9,-1
8000388c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000388e:	e0 49 01 ff 	cp.w	r9,511
80003892:	e0 88 00 16 	brls	800038be <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
80003896:	30 09       	mov	r9,0
80003898:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000389a:	fe f6 03 ca 	ld.w	r6,pc[970]
8000389e:	6c 0c       	ld.w	r12,r6[0x0]
800038a0:	f0 1f 00 fc 	mcall	80003c90 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800038a4:	fe f8 03 bc 	ld.w	r8,pc[956]
800038a8:	70 0c       	ld.w	r12,r8[0x0]
800038aa:	f0 1f 00 e8 	mcall	80003c48 <phy_rx_func+0xbdc>
800038ae:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038b0:	c0 71       	brne	800038be <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
800038b2:	30 09       	mov	r9,0
800038b4:	fe f8 03 b4 	ld.w	r8,pc[948]
800038b8:	91 09       	st.w	r8[0x0],r9
800038ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038be:	fe f9 03 b2 	ld.w	r9,pc[946]
800038c2:	72 08       	ld.w	r8,r9[0x0]
800038c4:	20 18       	sub	r8,1
800038c6:	93 08       	st.w	r9[0x0],r8
800038c8:	c0 71       	brne	800038d6 <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
800038ca:	30 09       	mov	r9,0
800038cc:	fe f8 03 9c 	ld.w	r8,pc[924]
800038d0:	91 09       	st.w	r8[0x0],r9
800038d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800038d6:	fe f8 03 b2 	ld.w	r8,pc[946]
800038da:	fe f9 03 8a 	ld.w	r9,pc[906]
800038de:	72 0a       	ld.w	r10,r9[0x0]
800038e0:	70 09       	ld.w	r9,r8[0x0]
800038e2:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800038e6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038ea:	70 09       	ld.w	r9,r8[0x0]
800038ec:	2f f9       	sub	r9,-1
800038ee:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038f0:	e0 49 01 ff 	cp.w	r9,511
800038f4:	e0 88 00 16 	brls	80003920 <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
800038f8:	30 09       	mov	r9,0
800038fa:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038fc:	fe f6 03 68 	ld.w	r6,pc[872]
80003900:	6c 0c       	ld.w	r12,r6[0x0]
80003902:	f0 1f 00 e4 	mcall	80003c90 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003906:	fe f8 03 5a 	ld.w	r8,pc[858]
8000390a:	70 0c       	ld.w	r12,r8[0x0]
8000390c:	f0 1f 00 cf 	mcall	80003c48 <phy_rx_func+0xbdc>
80003910:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003912:	c0 71       	brne	80003920 <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003914:	30 09       	mov	r9,0
80003916:	fe f8 03 52 	ld.w	r8,pc[850]
8000391a:	91 09       	st.w	r8[0x0],r9
8000391c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003920:	fe f9 03 50 	ld.w	r9,pc[848]
80003924:	72 08       	ld.w	r8,r9[0x0]
80003926:	20 18       	sub	r8,1
80003928:	93 08       	st.w	r9[0x0],r8
8000392a:	c0 71       	brne	80003938 <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
8000392c:	30 09       	mov	r9,0
8000392e:	fe f8 03 3a 	ld.w	r8,pc[826]
80003932:	91 09       	st.w	r8[0x0],r9
80003934:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003938:	fe f8 03 50 	ld.w	r8,pc[848]
8000393c:	fe f9 03 28 	ld.w	r9,pc[808]
80003940:	72 0a       	ld.w	r10,r9[0x0]
80003942:	70 09       	ld.w	r9,r8[0x0]
80003944:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003948:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000394c:	70 09       	ld.w	r9,r8[0x0]
8000394e:	2f f9       	sub	r9,-1
80003950:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003952:	e0 49 01 ff 	cp.w	r9,511
80003956:	e0 88 00 16 	brls	80003982 <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
8000395a:	30 09       	mov	r9,0
8000395c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000395e:	fe f6 03 06 	ld.w	r6,pc[774]
80003962:	6c 0c       	ld.w	r12,r6[0x0]
80003964:	f0 1f 00 cb 	mcall	80003c90 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003968:	fe f8 02 f8 	ld.w	r8,pc[760]
8000396c:	70 0c       	ld.w	r12,r8[0x0]
8000396e:	f0 1f 00 b7 	mcall	80003c48 <phy_rx_func+0xbdc>
80003972:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003974:	c0 71       	brne	80003982 <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
80003976:	30 09       	mov	r9,0
80003978:	fe f8 02 f0 	ld.w	r8,pc[752]
8000397c:	91 09       	st.w	r8[0x0],r9
8000397e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003982:	fe f9 02 ee 	ld.w	r9,pc[750]
80003986:	72 08       	ld.w	r8,r9[0x0]
80003988:	20 18       	sub	r8,1
8000398a:	93 08       	st.w	r9[0x0],r8
8000398c:	c0 71       	brne	8000399a <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
8000398e:	30 09       	mov	r9,0
80003990:	fe f8 02 d8 	ld.w	r8,pc[728]
80003994:	91 09       	st.w	r8[0x0],r9
80003996:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
8000399a:	fe f8 02 ee 	ld.w	r8,pc[750]
8000399e:	fe f9 02 c6 	ld.w	r9,pc[710]
800039a2:	72 0a       	ld.w	r10,r9[0x0]
800039a4:	70 09       	ld.w	r9,r8[0x0]
800039a6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039aa:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039ae:	70 09       	ld.w	r9,r8[0x0]
800039b0:	2f f9       	sub	r9,-1
800039b2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039b4:	e0 49 01 ff 	cp.w	r9,511
800039b8:	e0 88 00 16 	brls	800039e4 <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
800039bc:	30 09       	mov	r9,0
800039be:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039c0:	fe f7 02 a4 	ld.w	r7,pc[676]
800039c4:	6e 0c       	ld.w	r12,r7[0x0]
800039c6:	f0 1f 00 b3 	mcall	80003c90 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800039ca:	fe f8 02 96 	ld.w	r8,pc[662]
800039ce:	70 0c       	ld.w	r12,r8[0x0]
800039d0:	f0 1f 00 9e 	mcall	80003c48 <phy_rx_func+0xbdc>
800039d4:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039d6:	c0 71       	brne	800039e4 <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
800039d8:	30 09       	mov	r9,0
800039da:	fe f8 02 8e 	ld.w	r8,pc[654]
800039de:	91 09       	st.w	r8[0x0],r9
800039e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039e4:	fe f9 02 8c 	ld.w	r9,pc[652]
800039e8:	72 08       	ld.w	r8,r9[0x0]
800039ea:	20 18       	sub	r8,1
800039ec:	93 08       	st.w	r9[0x0],r8
800039ee:	c0 71       	brne	800039fc <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
800039f0:	30 09       	mov	r9,0
800039f2:	fe f8 02 76 	ld.w	r8,pc[630]
800039f6:	91 09       	st.w	r8[0x0],r9
800039f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
800039fc:	20 18       	sub	r8,1
800039fe:	fe f9 02 72 	ld.w	r9,pc[626]
80003a02:	93 08       	st.w	r9[0x0],r8
80003a04:	58 08       	cp.w	r8,0
80003a06:	e0 81 01 13 	brne	80003c2c <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a0a:	30 09       	mov	r9,0
80003a0c:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a10:	91 09       	st.w	r8[0x0],r9
80003a12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a16:	fe f8 02 6a 	ld.w	r8,pc[618]
80003a1a:	11 89       	ld.ub	r9,r8[0x0]
80003a1c:	30 48       	mov	r8,4
80003a1e:	f0 09 18 00 	cp.b	r9,r8
80003a22:	c0 80       	breq	80003a32 <phy_rx_func+0x9c6>
80003a24:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a28:	11 89       	ld.ub	r9,r8[0x0]
80003a2a:	30 38       	mov	r8,3
80003a2c:	f0 09 18 00 	cp.b	r9,r8
80003a30:	c1 41       	brne	80003a58 <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a32:	6e 29       	ld.w	r9,r7[0x8]
80003a34:	fe f8 02 74 	ld.w	r8,pc[628]
80003a38:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a3a:	6e 39       	ld.w	r9,r7[0xc]
80003a3c:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a3e:	fe f9 02 32 	ld.w	r9,pc[562]
80003a42:	72 08       	ld.w	r8,r9[0x0]
80003a44:	20 88       	sub	r8,8
80003a46:	93 08       	st.w	r9[0x0],r8
80003a48:	e0 81 00 f2 	brne	80003c2c <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80003a4c:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a4e:	fe f9 02 1a 	ld.w	r9,pc[538]
80003a52:	93 08       	st.w	r9[0x0],r8
80003a54:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a58:	fe f8 02 28 	ld.w	r8,pc[552]
80003a5c:	11 89       	ld.ub	r9,r8[0x0]
80003a5e:	31 38       	mov	r8,19
80003a60:	f0 09 18 00 	cp.b	r9,r8
80003a64:	e0 81 00 9c 	brne	80003b9c <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
80003a68:	fe f8 02 4c 	ld.w	r8,pc[588]
80003a6c:	11 88       	ld.ub	r8,r8[0x0]
80003a6e:	30 c9       	mov	r9,12
80003a70:	f2 08 18 00 	cp.b	r8,r9
80003a74:	e0 81 00 7b 	brne	80003b6a <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003a78:	8e 49       	ld.sh	r9,r7[0x8]
80003a7a:	fe f8 02 3e 	ld.w	r8,pc[574]
80003a7e:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003a82:	30 09       	mov	r9,0
80003a84:	fe f8 02 30 	ld.w	r8,pc[560]
80003a88:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a8a:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003a8e:	3f 38       	mov	r8,-13
80003a90:	f0 09 18 00 	cp.b	r9,r8
80003a94:	c6 61       	brne	80003b60 <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003a96:	10 99       	mov	r9,r8
80003a98:	4f a8       	lddpc	r8,80003c80 <phy_rx_func+0xc14>
80003a9a:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003a9c:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003aa0:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003aa4:	4f 38       	lddpc	r8,80003c70 <phy_rx_func+0xc04>
80003aa6:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003aa8:	30 19       	mov	r9,1
80003aaa:	fe f8 02 12 	ld.w	r8,pc[530]
80003aae:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ab0:	8e 79       	ld.sh	r9,r7[0xe]
80003ab2:	fe f8 01 fe 	ld.w	r8,pc[510]
80003ab6:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003ab8:	4f 48       	lddpc	r8,80003c88 <phy_rx_func+0xc1c>
80003aba:	4e b9       	lddpc	r9,80003c64 <phy_rx_func+0xbf8>
80003abc:	72 0a       	ld.w	r10,r9[0x0]
80003abe:	70 09       	ld.w	r9,r8[0x0]
80003ac0:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ac4:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003ac8:	70 09       	ld.w	r9,r8[0x0]
80003aca:	2f f9       	sub	r9,-1
80003acc:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003ace:	e0 49 01 ff 	cp.w	r9,511
80003ad2:	e0 88 00 13 	brls	80003af8 <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
80003ad6:	30 09       	mov	r9,0
80003ad8:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003ada:	4e 36       	lddpc	r6,80003c64 <phy_rx_func+0xbf8>
80003adc:	6c 0c       	ld.w	r12,r6[0x0]
80003ade:	f0 1f 00 6d 	mcall	80003c90 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003ae2:	4e 08       	lddpc	r8,80003c60 <phy_rx_func+0xbf4>
80003ae4:	70 0c       	ld.w	r12,r8[0x0]
80003ae6:	f0 1f 00 59 	mcall	80003c48 <phy_rx_func+0xbdc>
80003aea:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003aec:	c0 61       	brne	80003af8 <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80003aee:	30 09       	mov	r9,0
80003af0:	4d e8       	lddpc	r8,80003c68 <phy_rx_func+0xbfc>
80003af2:	91 09       	st.w	r8[0x0],r9
80003af4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003af8:	4d e9       	lddpc	r9,80003c70 <phy_rx_func+0xc04>
80003afa:	72 08       	ld.w	r8,r9[0x0]
80003afc:	20 18       	sub	r8,1
80003afe:	93 08       	st.w	r9[0x0],r8
80003b00:	c0 61       	brne	80003b0c <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80003b02:	30 09       	mov	r9,0
80003b04:	4d 98       	lddpc	r8,80003c68 <phy_rx_func+0xbfc>
80003b06:	91 09       	st.w	r8[0x0],r9
80003b08:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b0c:	4d f8       	lddpc	r8,80003c88 <phy_rx_func+0xc1c>
80003b0e:	4d 69       	lddpc	r9,80003c64 <phy_rx_func+0xbf8>
80003b10:	72 0a       	ld.w	r10,r9[0x0]
80003b12:	70 09       	ld.w	r9,r8[0x0]
80003b14:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b18:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b1c:	70 09       	ld.w	r9,r8[0x0]
80003b1e:	2f f9       	sub	r9,-1
80003b20:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b22:	e0 49 01 ff 	cp.w	r9,511
80003b26:	e0 88 00 13 	brls	80003b4c <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b2a:	30 09       	mov	r9,0
80003b2c:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b2e:	4c e7       	lddpc	r7,80003c64 <phy_rx_func+0xbf8>
80003b30:	6e 0c       	ld.w	r12,r7[0x0]
80003b32:	f0 1f 00 58 	mcall	80003c90 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b36:	4c b8       	lddpc	r8,80003c60 <phy_rx_func+0xbf4>
80003b38:	70 0c       	ld.w	r12,r8[0x0]
80003b3a:	f0 1f 00 44 	mcall	80003c48 <phy_rx_func+0xbdc>
80003b3e:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b40:	c0 61       	brne	80003b4c <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
80003b42:	30 09       	mov	r9,0
80003b44:	4c 98       	lddpc	r8,80003c68 <phy_rx_func+0xbfc>
80003b46:	91 09       	st.w	r8[0x0],r9
80003b48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b4c:	4c 99       	lddpc	r9,80003c70 <phy_rx_func+0xc04>
80003b4e:	72 08       	ld.w	r8,r9[0x0]
80003b50:	20 18       	sub	r8,1
80003b52:	93 08       	st.w	r9[0x0],r8
80003b54:	c6 c1       	brne	80003c2c <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
80003b56:	30 09       	mov	r9,0
80003b58:	4c 48       	lddpc	r8,80003c68 <phy_rx_func+0xbfc>
80003b5a:	91 09       	st.w	r8[0x0],r9
80003b5c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b60:	30 09       	mov	r9,0
80003b62:	4c 28       	lddpc	r8,80003c68 <phy_rx_func+0xbfc>
80003b64:	91 09       	st.w	r8[0x0],r9
80003b66:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b6a:	8e 4a       	ld.sh	r10,r7[0x8]
80003b6c:	4d 39       	lddpc	r9,80003cb8 <phy_rx_func+0xc4c>
80003b6e:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003b72:	4d 1a       	lddpc	r10,80003cb4 <phy_rx_func+0xc48>
80003b74:	15 88       	ld.ub	r8,r10[0x0]
80003b76:	f0 cb ff ff 	sub	r11,r8,-1
80003b7a:	8e 5c       	ld.sh	r12,r7[0xa]
80003b7c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003b80:	f0 cb ff fe 	sub	r11,r8,-2
80003b84:	8e 6c       	ld.sh	r12,r7[0xc]
80003b86:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003b8a:	f0 cb ff fd 	sub	r11,r8,-3
80003b8e:	8e 7c       	ld.sh	r12,r7[0xe]
80003b90:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003b94:	2f c8       	sub	r8,-4
80003b96:	b4 88       	st.b	r10[0x0],r8
80003b98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003b9c:	30 09       	mov	r9,0
80003b9e:	4b 38       	lddpc	r8,80003c68 <phy_rx_func+0xbfc>
80003ba0:	91 09       	st.w	r8[0x0],r9
80003ba2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003ba6:	4b f8       	lddpc	r8,80003ca0 <phy_rx_func+0xc34>
80003ba8:	70 09       	ld.w	r9,r8[0x0]
80003baa:	8e 4b       	ld.sh	r11,r7[0x8]
80003bac:	4b ea       	lddpc	r10,80003ca4 <phy_rx_func+0xc38>
80003bae:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003bb2:	2f f9       	sub	r9,-1
80003bb4:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003bb6:	4b 48       	lddpc	r8,80003c84 <phy_rx_func+0xc18>
80003bb8:	70 09       	ld.w	r9,r8[0x0]
80003bba:	20 29       	sub	r9,2
80003bbc:	91 09       	st.w	r8[0x0],r9
80003bbe:	70 08       	ld.w	r8,r8[0x0]
80003bc0:	58 08       	cp.w	r8,0
80003bc2:	c2 f1       	brne	80003c20 <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
80003bc4:	30 09       	mov	r9,0
80003bc6:	4b 78       	lddpc	r8,80003ca0 <phy_rx_func+0xc34>
80003bc8:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bca:	8e 59       	ld.sh	r9,r7[0xa]
80003bcc:	fe 78 82 12 	mov	r8,-32238
80003bd0:	f0 09 19 00 	cp.h	r9,r8
80003bd4:	c2 11       	brne	80003c16 <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003bd6:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003bda:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003bde:	4a e8       	lddpc	r8,80003c94 <phy_rx_func+0xc28>
80003be0:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003be2:	8e 59       	ld.sh	r9,r7[0xa]
80003be4:	4a d8       	lddpc	r8,80003c98 <phy_rx_func+0xc2c>
80003be6:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003be8:	8e 69       	ld.sh	r9,r7[0xc]
80003bea:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003bec:	f0 1f 00 2c 	mcall	80003c9c <phy_rx_func+0xc30>
80003bf0:	49 f8       	lddpc	r8,80003c6c <phy_rx_func+0xc00>
80003bf2:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bf4:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003bf8:	31 38       	mov	r8,19
80003bfa:	f0 09 18 00 	cp.b	r9,r8
80003bfe:	c0 71       	brne	80003c0c <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c00:	10 99       	mov	r9,r8
80003c02:	4a 08       	lddpc	r8,80003c80 <phy_rx_func+0xc14>
80003c04:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c06:	30 09       	mov	r9,0
80003c08:	49 a8       	lddpc	r8,80003c70 <phy_rx_func+0xc04>
80003c0a:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c0c:	30 49       	mov	r9,4
80003c0e:	49 78       	lddpc	r8,80003c68 <phy_rx_func+0xbfc>
80003c10:	91 09       	st.w	r8[0x0],r9
80003c12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c16:	30 09       	mov	r9,0
80003c18:	49 48       	lddpc	r8,80003c68 <phy_rx_func+0xbfc>
80003c1a:	91 09       	st.w	r8[0x0],r9
80003c1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c20:	4a 8c       	lddpc	r12,80003cc0 <phy_rx_func+0xc54>
80003c22:	f0 1f 00 16 	mcall	80003c78 <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
80003c26:	30 09       	mov	r9,0
80003c28:	49 08       	lddpc	r8,80003c68 <phy_rx_func+0xbfc>
80003c2a:	91 09       	st.w	r8[0x0],r9
80003c2c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c30:	00 00       	add	r0,r0
80003c32:	0a b4       	st.h	r5++,r4
80003c34:	00 00       	add	r0,r0
80003c36:	0a ac       	st.w	r5++,r12
80003c38:	00 00       	add	r0,r0
80003c3a:	0a 68       	and	r8,r5
80003c3c:	00 00       	add	r0,r0
80003c3e:	0a 60       	and	r0,r5
80003c40:	00 00       	add	r0,r0
80003c42:	0a cc       	st.b	r5++,r12
80003c44:	00 00       	add	r0,r0
80003c46:	0a 98       	mov	r8,r5
80003c48:	80 00       	ld.sh	r0,r0[0x0]
80003c4a:	2a 3c       	sub	r12,-93
80003c4c:	00 00       	add	r0,r0
80003c4e:	0a 70       	tst	r0,r5
80003c50:	80 00       	ld.sh	r0,r0[0x0]
80003c52:	53 04       	stdsp	sp[0xc0],r4
80003c54:	00 00       	add	r0,r0
80003c56:	0a 94       	mov	r4,r5
80003c58:	80 00       	ld.sh	r0,r0[0x0]
80003c5a:	29 88       	sub	r8,-104
80003c5c:	00 00       	add	r0,r0
80003c5e:	0a a4       	st.w	r5++,r4
80003c60:	00 00       	add	r0,r0
80003c62:	0a 6c       	and	r12,r5
80003c64:	00 00       	add	r0,r0
80003c66:	0a 8c       	andn	r12,r5
80003c68:	00 00       	add	r0,r0
80003c6a:	0a b8       	st.h	r5++,r8
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a 64       	and	r4,r5
80003c70:	00 00       	add	r0,r0
80003c72:	0a c0       	st.b	r5++,r0
80003c74:	80 00       	ld.sh	r0,r0[0x0]
80003c76:	cb 84       	brge	80003be6 <phy_rx_func+0xb7a>
80003c78:	80 00       	ld.sh	r0,r0[0x0]
80003c7a:	63 fc       	ld.w	r12,r1[0x7c]
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a 4f       	or	pc,r5
80003c80:	00 00       	add	r0,r0
80003c82:	0a c6       	st.b	r5++,r6
80003c84:	00 00       	add	r0,r0
80003c86:	0a 84       	andn	r4,r5
80003c88:	00 00       	add	r0,r0
80003c8a:	0a 9c       	mov	r12,r5
80003c8c:	80 00       	ld.sh	r0,r0[0x0]
80003c8e:	6d 18       	ld.w	r8,r6[0x44]
80003c90:	80 00       	ld.sh	r0,r0[0x0]
80003c92:	30 0c       	mov	r12,0
80003c94:	00 00       	add	r0,r0
80003c96:	0a 40       	or	r0,r5
80003c98:	00 00       	add	r0,r0
80003c9a:	0e a0       	st.w	r7++,r0
80003c9c:	80 00       	ld.sh	r0,r0[0x0]
80003c9e:	28 cc       	sub	r12,-116
80003ca0:	00 00       	add	r0,r0
80003ca2:	0a bc       	st.h	r5++,r12
80003ca4:	00 00       	add	r0,r0
80003ca6:	0d a4       	ld.ub	r4,r6[0x2]
80003ca8:	00 00       	add	r0,r0
80003caa:	0a d0       	st.w	--r5,r0
80003cac:	00 00       	add	r0,r0
80003cae:	0a 52       	eor	r2,r5
80003cb0:	00 00       	add	r0,r0
80003cb2:	0d 9c       	ld.ub	r12,r6[0x1]
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a 80       	andn	r0,r5
80003cb8:	00 00       	add	r0,r0
80003cba:	0e a4       	st.w	r7++,r4
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a 4e       	or	lr,r5
80003cc0:	80 00       	ld.sh	r0,r0[0x0]
80003cc2:	cb 9c       	rcall	80003e34 <ssc_init+0x38>

80003cc4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003cc4:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003cc6:	49 88       	lddpc	r8,80003d24 <pdca_int_handler+0x60>
80003cc8:	11 89       	ld.ub	r9,r8[0x0]
80003cca:	ec 19 00 01 	eorl	r9,0x1
80003cce:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003cd0:	11 89       	ld.ub	r9,r8[0x0]
80003cd2:	a5 69       	lsl	r9,0x4
80003cd4:	2f c9       	sub	r9,-4
80003cd6:	49 5a       	lddpc	r10,80003d28 <pdca_int_handler+0x64>
80003cd8:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003cda:	fe 7a 00 40 	mov	r10,-65472
80003cde:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003ce0:	30 39       	mov	r9,3
80003ce2:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003ce4:	11 8a       	ld.ub	r10,r8[0x0]
80003ce6:	a5 6a       	lsl	r10,0x4
80003ce8:	2f ca       	sub	r10,-4
80003cea:	49 18       	lddpc	r8,80003d2c <pdca_int_handler+0x68>
80003cec:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003cee:	fe 78 00 00 	mov	r8,-65536
80003cf2:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003cf4:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003cf6:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003cf8:	48 e8       	lddpc	r8,80003d30 <pdca_int_handler+0x6c>
80003cfa:	70 08       	ld.w	r8,r8[0x0]
80003cfc:	58 08       	cp.w	r8,0
80003cfe:	c0 70       	breq	80003d0c <pdca_int_handler+0x48>
80003d00:	48 99       	lddpc	r9,80003d24 <pdca_int_handler+0x60>
80003d02:	13 89       	ld.ub	r9,r9[0x0]
80003d04:	a5 69       	lsl	r9,0x4
80003d06:	48 ac       	lddpc	r12,80003d2c <pdca_int_handler+0x68>
80003d08:	12 0c       	add	r12,r9
80003d0a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d0c:	48 a8       	lddpc	r8,80003d34 <pdca_int_handler+0x70>
80003d0e:	70 08       	ld.w	r8,r8[0x0]
80003d10:	58 08       	cp.w	r8,0
80003d12:	c0 70       	breq	80003d20 <pdca_int_handler+0x5c>
80003d14:	48 49       	lddpc	r9,80003d24 <pdca_int_handler+0x60>
80003d16:	13 89       	ld.ub	r9,r9[0x0]
80003d18:	a5 69       	lsl	r9,0x4
80003d1a:	48 4c       	lddpc	r12,80003d28 <pdca_int_handler+0x64>
80003d1c:	12 0c       	add	r12,r9
80003d1e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d20:	d4 02       	popm	lr
80003d22:	d6 03       	rete
80003d24:	00 00       	add	r0,r0
80003d26:	40 c4       	lddsp	r4,sp[0x30]
80003d28:	00 00       	add	r0,r0
80003d2a:	40 ec       	lddsp	r12,sp[0x38]
80003d2c:	00 00       	add	r0,r0
80003d2e:	40 cc       	lddsp	r12,sp[0x30]
80003d30:	00 00       	add	r0,r0
80003d32:	0a d8       	st.w	--r5,r8
80003d34:	00 00       	add	r0,r0
80003d36:	0a dc       	st.w	--r5,r12

80003d38 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d38:	fe 78 10 00 	mov	r8,-61440
80003d3c:	e0 69 0d c0 	mov	r9,3520
80003d40:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d44:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d48:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d4c:	fe 78 34 00 	mov	r8,-52224
80003d50:	e0 69 80 00 	mov	r9,32768
80003d54:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003d56:	30 09       	mov	r9,0
80003d58:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003d5a:	e0 69 04 21 	mov	r9,1057
80003d5e:	ea 19 3f 20 	orh	r9,0x3f20
80003d62:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003d64:	e0 69 02 9f 	mov	r9,671
80003d68:	ea 19 01 00 	orh	r9,0x100
80003d6c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003d6e:	e0 6a 04 02 	mov	r10,1026
80003d72:	ea 1a 3f 20 	orh	r10,0x3f20
80003d76:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003d78:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003d7a:	5e fc       	retal	r12

80003d7c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003d7c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003d7e:	30 19       	mov	r9,1
80003d80:	49 78       	lddpc	r8,80003ddc <local_start_PDC+0x60>
80003d82:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003d84:	fe 78 00 00 	mov	r8,-65536
80003d88:	30 7b       	mov	r11,7
80003d8a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003d8c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003d8e:	49 59       	lddpc	r9,80003de0 <local_start_PDC+0x64>
80003d90:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003d94:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003d96:	30 3a       	mov	r10,3
80003d98:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003d9a:	30 1c       	mov	r12,1
80003d9c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003d9e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003da0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003da2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003da4:	30 2c       	mov	r12,2
80003da6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003da8:	48 f9       	lddpc	r9,80003de4 <local_start_PDC+0x68>
80003daa:	e0 68 5a 5a 	mov	r8,23130
80003dae:	ea 18 ab cd 	orh	r8,0xabcd
80003db2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003db4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003db6:	30 0e       	mov	lr,0
80003db8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003dba:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003dbc:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003dbe:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003dc0:	fe 78 00 40 	mov	r8,-65472
80003dc4:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003dc6:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003dc8:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003dcc:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003dce:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003dd0:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003dd2:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003dd4:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003dd6:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003dd8:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003dda:	d8 02       	popm	pc
80003ddc:	00 00       	add	r0,r0
80003dde:	40 c4       	lddsp	r4,sp[0x30]
80003de0:	00 00       	add	r0,r0
80003de2:	40 cc       	lddsp	r12,sp[0x30]
80003de4:	00 00       	add	r0,r0
80003de6:	40 ec       	lddsp	r12,sp[0x38]

80003de8 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003de8:	48 38       	lddpc	r8,80003df4 <register_rx_tx_func+0xc>
80003dea:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003dec:	48 38       	lddpc	r8,80003df8 <register_rx_tx_func+0x10>
80003dee:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003df0:	5e fc       	retal	r12
80003df2:	00 00       	add	r0,r0
80003df4:	00 00       	add	r0,r0
80003df6:	0a d8       	st.w	--r5,r8
80003df8:	00 00       	add	r0,r0
80003dfa:	0a dc       	st.w	--r5,r12

80003dfc <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003dfc:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003dfe:	fe 78 10 00 	mov	r8,-61440
80003e02:	30 29       	mov	r9,2
80003e04:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e08:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e0c:	10 99       	mov	r9,r8
80003e0e:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e12:	e2 18 00 02 	andl	r8,0x2,COH
80003e16:	cf c0       	breq	80003e0e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e18:	fe 79 10 00 	mov	r9,-61440
80003e1c:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e20:	e2 18 00 02 	andl	r8,0x2,COH
80003e24:	cf c1       	brne	80003e1c <ssc_init+0x20>
				
    INTC_register_interrupt (
80003e26:	30 3a       	mov	r10,3
80003e28:	36 0b       	mov	r11,96
80003e2a:	48 bc       	lddpc	r12,80003e54 <ssc_init+0x58>
80003e2c:	f0 1f 00 0b 	mcall	80003e58 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003e30:	f0 1f 00 0b 	mcall	80003e5c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003e34:	f0 1f 00 0b 	mcall	80003e60 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e38:	fe 79 00 00 	mov	r9,-65536
80003e3c:	30 18       	mov	r8,1
80003e3e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e40:	fe 7a 00 40 	mov	r10,-65472
80003e44:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e46:	e0 6b 01 01 	mov	r11,257
80003e4a:	fe 7a 34 00 	mov	r10,-52224
80003e4e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003e50:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003e52:	d8 02       	popm	pc
80003e54:	80 00       	ld.sh	r0,r0[0x0]
80003e56:	3c c4       	mov	r4,-52
80003e58:	80 00       	ld.sh	r0,r0[0x0]
80003e5a:	49 3c       	lddpc	r12,80003ea4 <xcmp_tx+0x34>
80003e5c:	80 00       	ld.sh	r0,r0[0x0]
80003e5e:	3d 38       	mov	r8,-45
80003e60:	80 00       	ld.sh	r0,r0[0x0]
80003e62:	3d 7c       	mov	r12,-41

80003e64 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003e64:	48 28       	lddpc	r8,80003e6c <xcmp_register_app_list+0x8>
80003e66:	91 0c       	st.w	r8[0x0],r12
}
80003e68:	5e fc       	retal	r12
80003e6a:	00 00       	add	r0,r0
80003e6c:	00 00       	add	r0,r0
80003e6e:	41 0c       	lddsp	r12,sp[0x40]

80003e70 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003e70:	eb cd 40 80 	pushm	r7,lr
80003e74:	fa cd 01 00 	sub	sp,sp,256
80003e78:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003e7a:	16 98       	mov	r8,r11
80003e7c:	2f 08       	sub	r8,-16
80003e7e:	af a8       	sbr	r8,0xe
80003e80:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003e82:	3f f8       	mov	r8,-1
80003e84:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003e86:	30 b9       	mov	r9,11
80003e88:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003e8a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003e8c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003e8e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003e90:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003e92:	f6 ca ff fe 	sub	r10,r11,-2
80003e96:	18 9b       	mov	r11,r12
80003e98:	fa cc ff f0 	sub	r12,sp,-16
80003e9c:	f0 1f 00 05 	mcall	80003eb0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003ea0:	2f e7       	sub	r7,-2
80003ea2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003ea4:	1a 9c       	mov	r12,sp
80003ea6:	f0 1f 00 04 	mcall	80003eb4 <xcmp_tx+0x44>
}
80003eaa:	2c 0d       	sub	sp,-256
80003eac:	e3 cd 80 80 	ldm	sp++,r7,pc
80003eb0:	80 00       	ld.sh	r0,r0[0x0]
80003eb2:	6b d0       	ld.w	r0,r5[0x74]
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	43 a0       	lddsp	r0,sp[0xe8]

80003eb8 <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
80003eb8:	d4 01       	pushm	lr
80003eba:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80003ebe:	e0 68 04 21 	mov	r8,1057
80003ec2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80003ec4:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
80003ec8:	30 09       	mov	r9,0
80003eca:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80003ecc:	30 19       	mov	r9,1
80003ece:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
80003ed0:	30 39       	mov	r9,3
80003ed2:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80003ed4:	30 3b       	mov	r11,3
80003ed6:	fa cc ff fe 	sub	r12,sp,-2
80003eda:	f0 1f 00 03 	mcall	80003ee4 <xcmp_exit_device_control_mode+0x2c>
}
80003ede:	2c dd       	sub	sp,-204
80003ee0:	d8 02       	popm	pc
80003ee2:	00 00       	add	r0,r0
80003ee4:	80 00       	ld.sh	r0,r0[0x0]
80003ee6:	3e 70       	mov	r0,-25

80003ee8 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80003ee8:	d4 01       	pushm	lr
80003eea:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80003eee:	e0 68 04 21 	mov	r8,1057
80003ef2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80003ef4:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80003ef8:	30 19       	mov	r9,1
80003efa:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80003efc:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80003efe:	30 39       	mov	r9,3
80003f00:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80003f02:	30 3b       	mov	r11,3
80003f04:	fa cc ff fe 	sub	r12,sp,-2
80003f08:	f0 1f 00 02 	mcall	80003f10 <xcmp_enter_device_control_mode+0x28>
}
80003f0c:	2c dd       	sub	sp,-204
80003f0e:	d8 02       	popm	pc
80003f10:	80 00       	ld.sh	r0,r0[0x0]
80003f12:	3e 70       	mov	r0,-25

80003f14 <xcmp_audio_route_AMBE>:
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
}


void xcmp_audio_route_AMBE(void)
{
80003f14:	d4 01       	pushm	lr
80003f16:	fa cd 00 cc 	sub	sp,sp,204

	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80003f1a:	e0 68 04 14 	mov	r8,1044
80003f1e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80003f20:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80003f24:	30 19       	mov	r9,1
80003f26:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 6;// 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80003f28:	30 09       	mov	r9,0
80003f2a:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80003f2c:	30 69       	mov	r9,6
80003f2e:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//测试
	//注意：经测试发现，这里的路径配置，需要特别注意先后顺序，否则会提示参数错误。
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80003f30:	30 fa       	mov	r10,15
80003f32:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f34:	30 c9       	mov	r9,12
80003f36:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80003f38:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
80003f3a:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->RoutingData[2].audioInput = Pre_AMBE_Decoder;//IN_Option_Board;
80003f3c:	31 0a       	mov	r10,16
80003f3e:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f40:	f1 69 00 08 	st.b	r8[8],r9
	ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
80003f44:	f1 69 00 09 	st.b	r8[9],r9
	ptr->RoutingData[3].audioOutput = Pre_AMBE_Decoder;// OUT_Speaker;
80003f48:	f1 6a 00 0a 	st.b	r8[10],r10
	
	ptr->RoutingData[4].audioInput = Tx_Voice_Header;//IN_Option_Board;
80003f4c:	31 1a       	mov	r10,17
80003f4e:	f1 6a 00 0b 	st.b	r8[11],r10
	ptr->RoutingData[4].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f52:	f1 69 00 0c 	st.b	r8[12],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[5].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80003f56:	31 3a       	mov	r10,19
80003f58:	f1 6a 00 0d 	st.b	r8[13],r10
	ptr->RoutingData[5].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f5c:	f1 69 00 0e 	st.b	r8[14],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80003f60:	30 fb       	mov	r11,15
80003f62:	fa cc ff fe 	sub	r12,sp,-2
80003f66:	f0 1f 00 03 	mcall	80003f70 <xcmp_audio_route_AMBE+0x5c>

	
}
80003f6a:	2c dd       	sub	sp,-204
80003f6c:	d8 02       	popm	pc
80003f6e:	00 00       	add	r0,r0
80003f70:	80 00       	ld.sh	r0,r0[0x0]
80003f72:	3e 70       	mov	r0,-25

80003f74 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80003f74:	d4 01       	pushm	lr
80003f76:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80003f7a:	e0 68 04 65 	mov	r8,1125
80003f7e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80003f80:	fa cc ff fe 	sub	r12,sp,-2
80003f84:	30 18       	mov	r8,1
80003f86:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80003f88:	30 1b       	mov	r11,1
80003f8a:	f0 1f 00 03 	mcall	80003f94 <xcmp_enter_enhanced_OB_mode+0x20>
}
80003f8e:	2c dd       	sub	sp,-204
80003f90:	d8 02       	popm	pc
80003f92:	00 00       	add	r0,r0
80003f94:	80 00       	ld.sh	r0,r0[0x0]
80003f96:	3e 70       	mov	r0,-25

80003f98 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003f98:	d4 01       	pushm	lr
80003f9a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003f9e:	fe 78 b4 00 	mov	r8,-19456
80003fa2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003fa4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003fa8:	30 89       	mov	r9,8
80003faa:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003fac:	30 19       	mov	r9,1
80003fae:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003fb0:	30 09       	mov	r9,0
80003fb2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003fb4:	30 5a       	mov	r10,5
80003fb6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003fb8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003fba:	30 7a       	mov	r10,7
80003fbc:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003fbe:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003fc0:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003fc2:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003fc6:	30 9b       	mov	r11,9
80003fc8:	fa cc ff fe 	sub	r12,sp,-2
80003fcc:	f0 1f 00 02 	mcall	80003fd4 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003fd0:	2c dd       	sub	sp,-204
80003fd2:	d8 02       	popm	pc
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	3e 70       	mov	r0,-25

80003fd8 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003fd8:	d4 01       	pushm	lr
80003fda:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003fde:	fe 78 80 00 	mov	r8,-32768
80003fe2:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003fe4:	30 38       	mov	r8,3
80003fe6:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003fe8:	30 1b       	mov	r11,1
80003fea:	fa cc ff fe 	sub	r12,sp,-2
80003fee:	f0 1f 00 03 	mcall	80003ff8 <xcmp_opcode_not_supported+0x20>
}
80003ff2:	2c dd       	sub	sp,-204
80003ff4:	d8 02       	popm	pc
80003ff6:	00 00       	add	r0,r0
80003ff8:	80 00       	ld.sh	r0,r0[0x0]
80003ffa:	3e 70       	mov	r0,-25

80003ffc <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003ffc:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003ffe:	96 88       	ld.uh	r8,r11[0x0]
80004000:	e2 18 f0 00 	andl	r8,0xf000,COH
80004004:	e0 48 80 00 	cp.w	r8,32768
80004008:	c0 f0       	breq	80004026 <xcmp_exec_func+0x2a>
8000400a:	e0 48 b0 00 	cp.w	r8,45056
8000400e:	c1 20       	breq	80004032 <xcmp_exec_func+0x36>
80004010:	58 08       	cp.w	r8,0
80004012:	c1 51       	brne	8000403c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004014:	78 08       	ld.w	r8,r12[0x0]
80004016:	58 08       	cp.w	r8,0
80004018:	c0 40       	breq	80004020 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000401a:	16 9c       	mov	r12,r11
8000401c:	5d 18       	icall	r8
8000401e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004020:	f0 1f 00 08 	mcall	80004040 <xcmp_exec_func+0x44>
80004024:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004026:	78 18       	ld.w	r8,r12[0x4]
80004028:	58 08       	cp.w	r8,0
8000402a:	c0 90       	breq	8000403c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
8000402c:	16 9c       	mov	r12,r11
8000402e:	5d 18       	icall	r8
80004030:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004032:	78 28       	ld.w	r8,r12[0x8]
80004034:	58 08       	cp.w	r8,0
80004036:	c0 30       	breq	8000403c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004038:	16 9c       	mov	r12,r11
8000403a:	5d 18       	icall	r8
8000403c:	d8 02       	popm	pc
8000403e:	00 00       	add	r0,r0
80004040:	80 00       	ld.sh	r0,r0[0x0]
80004042:	3f d8       	mov	r8,-3

80004044 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004044:	d4 01       	pushm	lr
80004046:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000404a:	e0 68 04 09 	mov	r8,1033
8000404e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004050:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004054:	30 19       	mov	r9,1
80004056:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80004058:	30 09       	mov	r9,0
8000405a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
8000405c:	30 ca       	mov	r10,12
8000405e:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004060:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004062:	fb 69 00 08 	st.b	sp[8],r9
80004066:	fa c8 ff f7 	sub	r8,sp,-9
8000406a:	b0 89       	st.b	r8[0x0],r9
8000406c:	fa c8 ff f6 	sub	r8,sp,-10
80004070:	b0 89       	st.b	r8[0x0],r9
80004072:	fa c8 ff f5 	sub	r8,sp,-11
80004076:	b0 89       	st.b	r8[0x0],r9
80004078:	fa c8 ff f4 	sub	r8,sp,-12
8000407c:	b0 89       	st.b	r8[0x0],r9
8000407e:	fa c8 ff f3 	sub	r8,sp,-13
80004082:	b0 89       	st.b	r8[0x0],r9
80004084:	fa c8 ff f2 	sub	r8,sp,-14
80004088:	b0 89       	st.b	r8[0x0],r9
8000408a:	fa c8 ff f1 	sub	r8,sp,-15
8000408e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80004090:	30 cb       	mov	r11,12
80004092:	fa cc ff fe 	sub	r12,sp,-2
80004096:	f0 1f 00 03 	mcall	800040a0 <xcmp_IdleTestTone+0x5c>
}
8000409a:	2c dd       	sub	sp,-204
8000409c:	d8 02       	popm	pc
8000409e:	00 00       	add	r0,r0
800040a0:	80 00       	ld.sh	r0,r0[0x0]
800040a2:	3e 70       	mov	r0,-25

800040a4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040a4:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
800040a6:	f0 1f 00 0d 	mcall	800040d8 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040aa:	48 dc       	lddpc	r12,800040dc <xcmp_init+0x38>
800040ac:	f0 1f 00 0d 	mcall	800040e0 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800040b0:	30 4b       	mov	r11,4
800040b2:	31 4c       	mov	r12,20
800040b4:	f0 1f 00 0c 	mcall	800040e4 <xcmp_init+0x40>
800040b8:	48 c8       	lddpc	r8,800040e8 <xcmp_init+0x44>
800040ba:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800040bc:	30 09       	mov	r9,0
800040be:	1a d9       	st.w	--sp,r9
800040c0:	1a d9       	st.w	--sp,r9
800040c2:	1a d9       	st.w	--sp,r9
800040c4:	30 38       	mov	r8,3
800040c6:	e0 6a 01 80 	mov	r10,384
800040ca:	48 9b       	lddpc	r11,800040ec <xcmp_init+0x48>
800040cc:	48 9c       	lddpc	r12,800040f0 <xcmp_init+0x4c>
800040ce:	f0 1f 00 0a 	mcall	800040f4 <xcmp_init+0x50>
800040d2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
800040d4:	d8 02       	popm	pc
800040d6:	00 00       	add	r0,r0
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	44 84       	lddsp	r4,sp[0x120]
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	41 f4       	lddsp	r4,sp[0x7c]
800040e0:	80 00       	ld.sh	r0,r0[0x0]
800040e2:	42 40       	lddsp	r0,sp[0x90]
800040e4:	80 00       	ld.sh	r0,r0[0x0]
800040e6:	57 d8       	stdsp	sp[0x1f4],r8
800040e8:	00 00       	add	r0,r0
800040ea:	0a ec       	st.h	--r5,r12
800040ec:	80 00       	ld.sh	r0,r0[0x0]
800040ee:	cb c8       	rjmp	80004266 <xnl_get_msg_ack_func+0x1a>
800040f0:	80 00       	ld.sh	r0,r0[0x0]
800040f2:	40 f8       	lddsp	r8,sp[0x3c]
800040f4:	80 00       	ld.sh	r0,r0[0x0]
800040f6:	5e ac       	retle	r12

800040f8 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800040f8:	d4 31       	pushm	r0-r7,lr
800040fa:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800040fc:	4b 16       	lddpc	r6,800041c0 <xcmp_rx_process+0xc8>
800040fe:	30 05       	mov	r5,0
80004100:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004102:	4b 13       	lddpc	r3,800041c4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004104:	4b 12       	lddpc	r2,800041c8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004106:	4b 21       	lddpc	r1,800041cc <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004108:	4b 20       	lddpc	r0,800041d0 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000410a:	6c 0c       	ld.w	r12,r6[0x0]
8000410c:	0a 99       	mov	r9,r5
8000410e:	08 9a       	mov	r10,r4
80004110:	1a 9b       	mov	r11,sp
80004112:	f0 1f 00 31 	mcall	800041d4 <xcmp_rx_process+0xdc>
80004116:	58 1c       	cp.w	r12,1
80004118:	cf 91       	brne	8000410a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000411a:	40 0b       	lddsp	r11,sp[0x0]
8000411c:	58 0b       	cp.w	r11,0
8000411e:	cf 60       	breq	8000410a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004120:	96 0a       	ld.sh	r10,r11[0x0]
80004122:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004126:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000412a:	59 c8       	cp.w	r8,28
8000412c:	c1 e0       	breq	80004168 <xcmp_rx_process+0x70>
8000412e:	e0 89 00 07 	brgt	8000413c <xcmp_rx_process+0x44>
80004132:	58 e8       	cp.w	r8,14
80004134:	c0 e0       	breq	80004150 <xcmp_rx_process+0x58>
80004136:	58 f8       	cp.w	r8,15
80004138:	c2 41       	brne	80004180 <xcmp_rx_process+0x88>
8000413a:	c0 f8       	rjmp	80004158 <xcmp_rx_process+0x60>
8000413c:	e0 48 01 09 	cp.w	r8,265
80004140:	c1 80       	breq	80004170 <xcmp_rx_process+0x78>
80004142:	e0 48 01 0a 	cp.w	r8,266
80004146:	c1 90       	breq	80004178 <xcmp_rx_process+0x80>
80004148:	e0 48 00 2c 	cp.w	r8,44
8000414c:	c1 a1       	brne	80004180 <xcmp_rx_process+0x88>
8000414e:	c0 98       	rjmp	80004160 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004150:	4a 2c       	lddpc	r12,800041d8 <xcmp_rx_process+0xe0>
80004152:	f0 1f 00 23 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
80004156:	c2 f8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004158:	4a 2c       	lddpc	r12,800041e0 <xcmp_rx_process+0xe8>
8000415a:	f0 1f 00 21 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
8000415e:	c2 b8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004160:	4a 1c       	lddpc	r12,800041e4 <xcmp_rx_process+0xec>
80004162:	f0 1f 00 1f 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
80004166:	c2 78       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004168:	04 9c       	mov	r12,r2
8000416a:	f0 1f 00 1d 	mcall	800041dc <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000416e:	c2 38       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004170:	02 9c       	mov	r12,r1
80004172:	f0 1f 00 1b 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
80004176:	c1 f8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004178:	00 9c       	mov	r12,r0
8000417a:	f0 1f 00 19 	mcall	800041dc <xcmp_rx_process+0xe4>
					break;
8000417e:	c1 b8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80004180:	12 98       	mov	r8,r9
80004182:	e2 18 04 00 	andl	r8,0x400,COH
80004186:	c0 70       	breq	80004194 <xcmp_rx_process+0x9c>
80004188:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000418c:	e0 48 00 68 	cp.w	r8,104
80004190:	e0 8a 00 08 	brle	800041a0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004194:	e2 19 f0 00 	andl	r9,0xf000,COH
80004198:	c0 e1       	brne	800041b4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000419a:	f0 1f 00 14 	mcall	800041e8 <xcmp_rx_process+0xf0>
8000419e:	c0 b8       	rjmp	800041b4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041a0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041a4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041a8:	49 19       	lddpc	r9,800041ec <xcmp_rx_process+0xf4>
800041aa:	72 08       	ld.w	r8,r9[0x0]
800041ac:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800041b0:	f0 1f 00 0b 	mcall	800041dc <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041b4:	66 0c       	ld.w	r12,r3[0x0]
800041b6:	40 0b       	lddsp	r11,sp[0x0]
800041b8:	f0 1f 00 0e 	mcall	800041f0 <xcmp_rx_process+0xf8>
800041bc:	ca 7b       	rjmp	8000410a <xcmp_rx_process+0x12>
800041be:	00 00       	add	r0,r0
800041c0:	00 00       	add	r0,r0
800041c2:	0a ec       	st.h	--r5,r12
800041c4:	00 00       	add	r0,r0
800041c6:	0a 98       	mov	r8,r5
800041c8:	00 00       	add	r0,r0
800041ca:	0a fc       	st.b	--r5,r12
800041cc:	00 00       	add	r0,r0
800041ce:	0a f0       	st.b	--r5,r0
800041d0:	00 00       	add	r0,r0
800041d2:	0b 08       	ld.w	r8,r5++
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	54 74       	stdsp	sp[0x11c],r4
800041d8:	00 00       	add	r0,r0
800041da:	0b 20       	ld.uh	r0,r5++
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	3f fc       	mov	r12,-1
800041e0:	00 00       	add	r0,r0
800041e2:	0a e0       	st.h	--r5,r0
800041e4:	00 00       	add	r0,r0
800041e6:	0b 14       	ld.sh	r4,r5++
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	3f d8       	mov	r8,-3
800041ec:	00 00       	add	r0,r0
800041ee:	41 0c       	lddsp	r12,sp[0x40]
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	29 c0       	sub	r0,-100

800041f4 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
800041f4:	eb cd 40 90 	pushm	r4,r7,lr
800041f8:	20 1d       	sub	sp,4
800041fa:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
800041fe:	48 c8       	lddpc	r8,8000422c <xcmp_rx+0x38>
80004200:	70 0c       	ld.w	r12,r8[0x0]
80004202:	f0 1f 00 0c 	mcall	80004230 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004206:	c1 00       	breq	80004226 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004208:	fa c7 ff fc 	sub	r7,sp,-4
8000420c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000420e:	e0 6a 00 ca 	mov	r10,202
80004212:	08 9b       	mov	r11,r4
80004214:	f0 1f 00 08 	mcall	80004234 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004218:	48 88       	lddpc	r8,80004238 <xcmp_rx+0x44>
8000421a:	70 0c       	ld.w	r12,r8[0x0]
8000421c:	30 09       	mov	r9,0
8000421e:	12 9a       	mov	r10,r9
80004220:	1a 9b       	mov	r11,sp
80004222:	f0 1f 00 07 	mcall	8000423c <xcmp_rx+0x48>
	}	
}
80004226:	2f fd       	sub	sp,-4
80004228:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000422c:	00 00       	add	r0,r0
8000422e:	0a 98       	mov	r8,r5
80004230:	80 00       	ld.sh	r0,r0[0x0]
80004232:	2f 28       	sub	r8,-14
80004234:	80 00       	ld.sh	r0,r0[0x0]
80004236:	6b d0       	ld.w	r0,r5[0x74]
80004238:	00 00       	add	r0,r0
8000423a:	0a ec       	st.h	--r5,r12
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	56 80       	stdsp	sp[0x1a0],r0

80004240 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004240:	48 28       	lddpc	r8,80004248 <xnl_register_xcmp_func+0x8>
80004242:	91 0c       	st.w	r8[0x0],r12
}
80004244:	5e fc       	retal	r12
80004246:	00 00       	add	r0,r0
80004248:	00 00       	add	r0,r0
8000424a:	0b 4c       	ld.w	r12,--r5

8000424c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000424c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000424e:	48 88       	lddpc	r8,8000426c <xnl_get_msg_ack_func+0x20>
80004250:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004252:	98 49       	ld.sh	r9,r12[0x8]
80004254:	f0 09 19 00 	cp.h	r9,r8
80004258:	c0 81       	brne	80004268 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000425a:	48 68       	lddpc	r8,80004270 <xnl_get_msg_ack_func+0x24>
8000425c:	70 0c       	ld.w	r12,r8[0x0]
8000425e:	30 09       	mov	r9,0
80004260:	12 9a       	mov	r10,r9
80004262:	12 9b       	mov	r11,r9
80004264:	f0 1f 00 04 	mcall	80004274 <xnl_get_msg_ack_func+0x28>
80004268:	d8 02       	popm	pc
8000426a:	00 00       	add	r0,r0
8000426c:	00 00       	add	r0,r0
8000426e:	0b 32       	ld.ub	r2,r5++
80004270:	00 00       	add	r0,r0
80004272:	0b 2c       	ld.uh	r12,r5++
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	56 80       	stdsp	sp[0x1a0],r0

80004278 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004278:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000427a:	4a 86       	lddpc	r6,80004318 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000427c:	4a 82       	lddpc	r2,8000431c <xnl_tx_process+0xa4>
8000427e:	4a 94       	lddpc	r4,80004320 <xnl_tx_process+0xa8>
80004280:	30 07       	mov	r7,0
80004282:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004284:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80004286:	4a 85       	lddpc	r5,80004324 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004288:	4a 83       	lddpc	r3,80004328 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000428a:	6c 08       	ld.w	r8,r6[0x0]
8000428c:	58 08       	cp.w	r8,0
8000428e:	c0 40       	breq	80004296 <xnl_tx_process+0x1e>
80004290:	58 18       	cp.w	r8,1
80004292:	cf d1       	brne	8000428c <xnl_tx_process+0x14>
80004294:	c2 08       	rjmp	800042d4 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004296:	64 0c       	ld.w	r12,r2[0x0]
80004298:	0e 99       	mov	r9,r7
8000429a:	02 9a       	mov	r10,r1
8000429c:	08 9b       	mov	r11,r4
8000429e:	f0 1f 00 24 	mcall	8000432c <xnl_tx_process+0xb4>
800042a2:	58 1c       	cp.w	r12,1
800042a4:	cf 31       	brne	8000428a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800042a6:	68 0c       	ld.w	r12,r4[0x0]
800042a8:	58 0c       	cp.w	r12,0
800042aa:	cf 00       	breq	8000428a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800042ac:	98 28       	ld.sh	r8,r12[0x4]
800042ae:	e0 08 19 00 	cp.h	r8,r0
800042b2:	c0 41       	brne	800042ba <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800042b4:	f0 1f 00 1f 	mcall	80004330 <xnl_tx_process+0xb8>
						break;
800042b8:	ce 9b       	rjmp	8000428a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800042ba:	f0 1f 00 1f 	mcall	80004334 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800042be:	30 18       	mov	r8,1
800042c0:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800042c2:	66 0c       	ld.w	r12,r3[0x0]
800042c4:	0e 99       	mov	r9,r7
800042c6:	0e 9a       	mov	r10,r7
800042c8:	0e 9b       	mov	r11,r7
800042ca:	f0 1f 00 19 	mcall	8000432c <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800042ce:	30 18       	mov	r8,1
800042d0:	8d 08       	st.w	r6[0x0],r8
800042d2:	cd cb       	rjmp	8000428a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800042d4:	66 0c       	ld.w	r12,r3[0x0]
800042d6:	0e 99       	mov	r9,r7
800042d8:	36 4a       	mov	r10,100
800042da:	0e 9b       	mov	r11,r7
800042dc:	f0 1f 00 14 	mcall	8000432c <xnl_tx_process+0xb4>
800042e0:	58 1c       	cp.w	r12,1
800042e2:	c0 81       	brne	800042f2 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
800042e4:	49 58       	lddpc	r8,80004338 <xnl_tx_process+0xc0>
800042e6:	70 0c       	ld.w	r12,r8[0x0]
800042e8:	68 0b       	ld.w	r11,r4[0x0]
800042ea:	f0 1f 00 15 	mcall	8000433c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800042ee:	8d 07       	st.w	r6[0x0],r7
800042f0:	cc db       	rjmp	8000428a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800042f2:	6a 08       	ld.w	r8,r5[0x0]
800042f4:	58 38       	cp.w	r8,3
800042f6:	e0 89 00 09 	brgt	80004308 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800042fa:	68 0c       	ld.w	r12,r4[0x0]
800042fc:	f0 1f 00 0e 	mcall	80004334 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004300:	6a 08       	ld.w	r8,r5[0x0]
80004302:	2f f8       	sub	r8,-1
80004304:	8b 08       	st.w	r5[0x0],r8
80004306:	cc 2b       	rjmp	8000428a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004308:	48 c8       	lddpc	r8,80004338 <xnl_tx_process+0xc0>
8000430a:	70 0c       	ld.w	r12,r8[0x0]
8000430c:	68 0b       	ld.w	r11,r4[0x0]
8000430e:	f0 1f 00 0c 	mcall	8000433c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004312:	8d 07       	st.w	r6[0x0],r7
80004314:	cb bb       	rjmp	8000428a <xnl_tx_process+0x12>
80004316:	00 00       	add	r0,r0
80004318:	00 00       	add	r0,r0
8000431a:	0b 48       	ld.w	r8,--r5
8000431c:	00 00       	add	r0,r0
8000431e:	0b 3c       	ld.ub	r12,r5++
80004320:	00 00       	add	r0,r0
80004322:	0b 40       	ld.w	r0,--r5
80004324:	00 00       	add	r0,r0
80004326:	0b 44       	ld.w	r4,--r5
80004328:	00 00       	add	r0,r0
8000432a:	0b 2c       	ld.uh	r12,r5++
8000432c:	80 00       	ld.sh	r0,r0[0x0]
8000432e:	54 74       	stdsp	sp[0x11c],r4
80004330:	80 00       	ld.sh	r0,r0[0x0]
80004332:	53 04       	stdsp	sp[0xc0],r4
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	29 e0       	sub	r0,-98
80004338:	00 00       	add	r0,r0
8000433a:	0a 98       	mov	r8,r5
8000433c:	80 00       	ld.sh	r0,r0[0x0]
8000433e:	29 c0       	sub	r0,-100

80004340 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004340:	eb cd 40 fe 	pushm	r1-r7,lr
80004344:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004346:	49 26       	lddpc	r6,8000438c <xnl_rx_process+0x4c>
80004348:	30 05       	mov	r5,0
8000434a:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000434c:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000434e:	49 11       	lddpc	r1,80004390 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004350:	49 12       	lddpc	r2,80004394 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004352:	6c 0c       	ld.w	r12,r6[0x0]
80004354:	0a 99       	mov	r9,r5
80004356:	08 9a       	mov	r10,r4
80004358:	1a 9b       	mov	r11,sp
8000435a:	f0 1f 00 10 	mcall	80004398 <xnl_rx_process+0x58>
8000435e:	58 1c       	cp.w	r12,1
80004360:	cf 91       	brne	80004352 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004362:	40 0c       	lddsp	r12,sp[0x0]
80004364:	58 0c       	cp.w	r12,0
80004366:	cf 60       	breq	80004352 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004368:	98 28       	ld.sh	r8,r12[0x4]
8000436a:	e6 08 19 00 	cp.h	r8,r3
8000436e:	e0 8b 00 0a 	brhi	80004382 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004372:	5c 78       	castu.h	r8
80004374:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004378:	58 09       	cp.w	r9,0
8000437a:	c0 40       	breq	80004382 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
8000437c:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004380:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004382:	62 0c       	ld.w	r12,r1[0x0]
80004384:	40 0b       	lddsp	r11,sp[0x0]
80004386:	f0 1f 00 06 	mcall	8000439c <xnl_rx_process+0x5c>
8000438a:	ce 4b       	rjmp	80004352 <xnl_rx_process+0x12>
8000438c:	00 00       	add	r0,r0
8000438e:	0a b4       	st.h	r5++,r4
80004390:	00 00       	add	r0,r0
80004392:	0a 98       	mov	r8,r5
80004394:	00 00       	add	r0,r0
80004396:	04 f4       	st.b	--r2,r4
80004398:	80 00       	ld.sh	r0,r0[0x0]
8000439a:	54 74       	stdsp	sp[0x11c],r4
8000439c:	80 00       	ld.sh	r0,r0[0x0]
8000439e:	29 c0       	sub	r0,-100

800043a0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800043a0:	eb cd 40 c0 	pushm	r6-r7,lr
800043a4:	20 1d       	sub	sp,4
800043a6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800043a8:	98 39       	ld.sh	r9,r12[0x6]
800043aa:	3f f8       	mov	r8,-1
800043ac:	f0 09 19 00 	cp.h	r9,r8
800043b0:	c0 a1       	brne	800043c4 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800043b2:	4a e9       	lddpc	r9,80004468 <xnl_tx+0xc8>
800043b4:	13 88       	ld.ub	r8,r9[0x0]
800043b6:	2f f8       	sub	r8,-1
800043b8:	5c 58       	castu.b	r8
800043ba:	b2 88       	st.b	r9[0x0],r8
800043bc:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800043c0:	a9 a8       	sbr	r8,0x8
800043c2:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800043c4:	8c 49       	ld.sh	r9,r6[0x8]
800043c6:	3f f8       	mov	r8,-1
800043c8:	f0 09 19 00 	cp.h	r9,r8
800043cc:	c0 41       	brne	800043d4 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800043ce:	4a 88       	lddpc	r8,8000446c <xnl_tx+0xcc>
800043d0:	90 18       	ld.sh	r8,r8[0x2]
800043d2:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800043d4:	8c 59       	ld.sh	r9,r6[0xa]
800043d6:	3f f8       	mov	r8,-1
800043d8:	f0 09 19 00 	cp.h	r9,r8
800043dc:	c0 41       	brne	800043e4 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800043de:	4a 48       	lddpc	r8,8000446c <xnl_tx+0xcc>
800043e0:	90 28       	ld.sh	r8,r8[0x4]
800043e2:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800043e4:	8c 69       	ld.sh	r9,r6[0xc]
800043e6:	3f f8       	mov	r8,-1
800043e8:	f0 09 19 00 	cp.h	r9,r8
800043ec:	c0 e1       	brne	80004408 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800043ee:	4a 08       	lddpc	r8,8000446c <xnl_tx+0xcc>
800043f0:	90 49       	ld.sh	r9,r8[0x8]
800043f2:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800043f4:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800043f6:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800043f8:	90 49       	ld.sh	r9,r8[0x8]
800043fa:	e0 19 ff 00 	andl	r9,0xff00
800043fe:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004402:	f3 e8 10 08 	or	r8,r9,r8
80004406:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004408:	0d 98       	ld.ub	r8,r6[0x1]
8000440a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000440c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004410:	10 0c       	add	r12,r8
80004412:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004414:	58 0c       	cp.w	r12,0
80004416:	e0 89 00 04 	brgt	8000441e <xnl_tx+0x7e>
8000441a:	30 09       	mov	r9,0
8000441c:	c0 d8       	rjmp	80004436 <xnl_tx+0x96>
8000441e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004422:	2f ec       	sub	r12,-2
80004424:	30 09       	mov	r9,0
80004426:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004428:	15 1b       	ld.sh	r11,r10++
8000442a:	f6 09 00 09 	add	r9,r11,r9
8000442e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004430:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004432:	18 38       	cp.w	r8,r12
80004434:	cf a1       	brne	80004428 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004436:	5c 39       	neg	r9
80004438:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000443a:	48 e8       	lddpc	r8,80004470 <xnl_tx+0xd0>
8000443c:	70 0c       	ld.w	r12,r8[0x0]
8000443e:	f0 1f 00 0e 	mcall	80004474 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004442:	c1 00       	breq	80004462 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004444:	fa c7 ff fc 	sub	r7,sp,-4
80004448:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000444a:	e0 6a 01 00 	mov	r10,256
8000444e:	0c 9b       	mov	r11,r6
80004450:	f0 1f 00 0a 	mcall	80004478 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004454:	48 a8       	lddpc	r8,8000447c <xnl_tx+0xdc>
80004456:	70 0c       	ld.w	r12,r8[0x0]
80004458:	30 09       	mov	r9,0
8000445a:	12 9a       	mov	r10,r9
8000445c:	1a 9b       	mov	r11,sp
8000445e:	f0 1f 00 09 	mcall	80004480 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004462:	2f fd       	sub	sp,-4
80004464:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004468:	00 00       	add	r0,r0
8000446a:	0b 30       	ld.ub	r0,r5++
8000446c:	00 00       	add	r0,r0
8000446e:	0b 32       	ld.ub	r2,r5++
80004470:	00 00       	add	r0,r0
80004472:	0a 98       	mov	r8,r5
80004474:	80 00       	ld.sh	r0,r0[0x0]
80004476:	2f 28       	sub	r8,-14
80004478:	80 00       	ld.sh	r0,r0[0x0]
8000447a:	6b d0       	ld.w	r0,r5[0x74]
8000447c:	00 00       	add	r0,r0
8000447e:	0b 3c       	ld.ub	r12,r5++
80004480:	80 00       	ld.sh	r0,r0[0x0]
80004482:	56 80       	stdsp	sp[0x1a0],r0

80004484 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80004484:	eb cd 40 80 	pushm	r7,lr
80004488:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
8000448c:	f0 1f 00 27 	mcall	80004528 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
80004490:	30 09       	mov	r9,0
80004492:	4a 78       	lddpc	r8,8000452c <xnl_init+0xa8>
80004494:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80004496:	30 0b       	mov	r11,0
80004498:	30 1c       	mov	r12,1
8000449a:	f0 1f 00 26 	mcall	80004530 <xnl_init+0xac>
8000449e:	4a 68       	lddpc	r8,80004534 <xnl_init+0xb0>
800044a0:	91 0c       	st.w	r8[0x0],r12
800044a2:	70 08       	ld.w	r8,r8[0x0]
800044a4:	58 08       	cp.w	r8,0
800044a6:	c0 80       	breq	800044b6 <xnl_init+0x32>
800044a8:	4a 38       	lddpc	r8,80004534 <xnl_init+0xb0>
800044aa:	70 0c       	ld.w	r12,r8[0x0]
800044ac:	30 09       	mov	r9,0
800044ae:	12 9a       	mov	r10,r9
800044b0:	12 9b       	mov	r11,r9
800044b2:	f0 1f 00 22 	mcall	80004538 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800044b6:	30 4b       	mov	r11,4
800044b8:	31 4c       	mov	r12,20
800044ba:	f0 1f 00 1e 	mcall	80004530 <xnl_init+0xac>
800044be:	4a 08       	lddpc	r8,8000453c <xnl_init+0xb8>
800044c0:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800044c2:	30 07       	mov	r7,0
800044c4:	1a d7       	st.w	--sp,r7
800044c6:	1a d7       	st.w	--sp,r7
800044c8:	1a d7       	st.w	--sp,r7
800044ca:	30 38       	mov	r8,3
800044cc:	0e 99       	mov	r9,r7
800044ce:	e0 6a 02 00 	mov	r10,512
800044d2:	49 cb       	lddpc	r11,80004540 <xnl_init+0xbc>
800044d4:	49 cc       	lddpc	r12,80004544 <xnl_init+0xc0>
800044d6:	f0 1f 00 1d 	mcall	80004548 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800044da:	1a d7       	st.w	--sp,r7
800044dc:	1a d7       	st.w	--sp,r7
800044de:	1a d7       	st.w	--sp,r7
800044e0:	30 38       	mov	r8,3
800044e2:	0e 99       	mov	r9,r7
800044e4:	e0 6a 03 20 	mov	r10,800
800044e8:	49 9b       	lddpc	r11,8000454c <xnl_init+0xc8>
800044ea:	49 ac       	lddpc	r12,80004550 <xnl_init+0xcc>
800044ec:	f0 1f 00 17 	mcall	80004548 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800044f0:	e0 68 40 0e 	mov	r8,16398
800044f4:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800044f8:	3f f8       	mov	r8,-1
800044fa:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
800044fe:	30 38       	mov	r8,3
80004500:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004504:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004508:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000450c:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004510:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004514:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004518:	fa cc ff e8 	sub	r12,sp,-24
8000451c:	f0 1f 00 0e 	mcall	80004554 <xnl_init+0xd0>
80004520:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80004522:	2c 0d       	sub	sp,-256
80004524:	e3 cd 80 80 	ldm	sp++,r7,pc
80004528:	80 00       	ld.sh	r0,r0[0x0]
8000452a:	2f 50       	sub	r0,-11
8000452c:	00 00       	add	r0,r0
8000452e:	0b 32       	ld.ub	r2,r5++
80004530:	80 00       	ld.sh	r0,r0[0x0]
80004532:	57 d8       	stdsp	sp[0x1f4],r8
80004534:	00 00       	add	r0,r0
80004536:	0b 2c       	ld.uh	r12,r5++
80004538:	80 00       	ld.sh	r0,r0[0x0]
8000453a:	56 80       	stdsp	sp[0x1a0],r0
8000453c:	00 00       	add	r0,r0
8000453e:	0b 3c       	ld.ub	r12,r5++
80004540:	80 00       	ld.sh	r0,r0[0x0]
80004542:	cb d0       	breq	800044bc <xnl_init+0x38>
80004544:	80 00       	ld.sh	r0,r0[0x0]
80004546:	43 40       	lddsp	r0,sp[0xd0]
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	5e ac       	retle	r12
8000454c:	80 00       	ld.sh	r0,r0[0x0]
8000454e:	c4 00       	breq	800045ce <xnl_device_auth_reply_func+0x16>
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	42 78       	lddsp	r8,sp[0x9c]
80004554:	80 00       	ld.sh	r0,r0[0x0]
80004556:	43 a0       	lddsp	r0,sp[0xe8]

80004558 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004558:	eb cd 40 80 	pushm	r7,lr
8000455c:	fa cd 01 00 	sub	sp,sp,256
80004560:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004562:	e0 68 40 0e 	mov	r8,16398
80004566:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004568:	3f f8       	mov	r8,-1
8000456a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000456c:	30 c8       	mov	r8,12
8000456e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004570:	98 38       	ld.sh	r8,r12[0x6]
80004572:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004574:	98 58       	ld.sh	r8,r12[0xa]
80004576:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004578:	98 48       	ld.sh	r8,r12[0x8]
8000457a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000457c:	98 68       	ld.sh	r8,r12[0xc]
8000457e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004580:	30 08       	mov	r8,0
80004582:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004584:	1a 9c       	mov	r12,sp
80004586:	f0 1f 00 0a 	mcall	800045ac <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000458a:	fa cd 00 cc 	sub	sp,sp,204
8000458e:	e0 6a 00 ca 	mov	r10,202
80004592:	ee cb ff f0 	sub	r11,r7,-16
80004596:	1a 9c       	mov	r12,sp
80004598:	f0 1f 00 06 	mcall	800045b0 <xnl_data_msg_func+0x58>
8000459c:	48 68       	lddpc	r8,800045b4 <xnl_data_msg_func+0x5c>
8000459e:	70 08       	ld.w	r8,r8[0x0]
800045a0:	5d 18       	icall	r8
800045a2:	fa cd ff 34 	sub	sp,sp,-204
}
800045a6:	2c 0d       	sub	sp,-256
800045a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800045ac:	80 00       	ld.sh	r0,r0[0x0]
800045ae:	43 a0       	lddsp	r0,sp[0xe8]
800045b0:	80 00       	ld.sh	r0,r0[0x0]
800045b2:	6b d0       	ld.w	r0,r5[0x74]
800045b4:	00 00       	add	r0,r0
800045b6:	0b 4c       	ld.w	r12,--r5

800045b8 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800045b8:	d4 21       	pushm	r4-r7,lr
800045ba:	fa cd 01 00 	sub	sp,sp,256
800045be:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800045c0:	4c 28       	lddpc	r8,800046c8 <xnl_device_auth_reply_func+0x110>
800045c2:	11 88       	ld.ub	r8,r8[0x0]
800045c4:	58 08       	cp.w	r8,0
800045c6:	e0 81 00 7f 	brne	800046c4 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800045ca:	4c 18       	lddpc	r8,800046cc <xnl_device_auth_reply_func+0x114>
800045cc:	70 0c       	ld.w	r12,r8[0x0]
800045ce:	30 09       	mov	r9,0
800045d0:	12 9a       	mov	r10,r9
800045d2:	12 9b       	mov	r11,r9
800045d4:	f0 1f 00 3f 	mcall	800046d0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800045d8:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800045dc:	4b b8       	lddpc	r8,800046c8 <xnl_device_auth_reply_func+0x110>
800045de:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800045e0:	ef 39 00 12 	ld.ub	r9,r7[18]
800045e4:	ef 38 00 13 	ld.ub	r8,r7[19]
800045e8:	b1 68       	lsl	r8,0x10
800045ea:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800045ee:	ef 38 00 15 	ld.ub	r8,r7[21]
800045f2:	f3 e8 10 08 	or	r8,r9,r8
800045f6:	ef 39 00 14 	ld.ub	r9,r7[20]
800045fa:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800045fe:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004602:	ef 38 00 17 	ld.ub	r8,r7[23]
80004606:	b1 68       	lsl	r8,0x10
80004608:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000460c:	ef 38 00 19 	ld.ub	r8,r7[25]
80004610:	f5 e8 10 08 	or	r8,r10,r8
80004614:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004618:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000461c:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000461e:	e0 64 79 b9 	mov	r4,31161
80004622:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004626:	e0 65 45 07 	mov	r5,17671
8000462a:	ea 15 8a bd 	orh	r5,0x8abd
8000462e:	e0 66 f9 3d 	mov	r6,63805
80004632:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004636:	e0 6e b8 cf 	mov	lr,47311
8000463a:	ea 1e 36 83 	orh	lr,0x3683
8000463e:	e0 67 aa 1c 	mov	r7,43548
80004642:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004646:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004648:	f4 08 00 0c 	add	r12,r10,r8
8000464c:	f0 0b 15 04 	lsl	r11,r8,0x4
80004650:	0a 0b       	add	r11,r5
80004652:	f9 eb 20 0b 	eor	r11,r12,r11
80004656:	f0 0c 16 05 	lsr	r12,r8,0x5
8000465a:	0c 0c       	add	r12,r6
8000465c:	18 5b       	eor	r11,r12
8000465e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004660:	f2 0c 15 04 	lsl	r12,r9,0x4
80004664:	1c 0c       	add	r12,lr
80004666:	f2 0b 16 05 	lsr	r11,r9,0x5
8000466a:	0e 0b       	add	r11,r7
8000466c:	f9 eb 20 0b 	eor	r11,r12,r11
80004670:	f2 0a 00 0c 	add	r12,r9,r10
80004674:	18 5b       	eor	r11,r12
80004676:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004678:	e0 6b 37 20 	mov	r11,14112
8000467c:	ea 1b c6 ef 	orh	r11,0xc6ef
80004680:	16 3a       	cp.w	r10,r11
80004682:	ce 21       	brne	80004646 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004684:	e0 6a 40 1a 	mov	r10,16410
80004688:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000468a:	3f fa       	mov	r10,-1
8000468c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000468e:	30 6b       	mov	r11,6
80004690:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004692:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004694:	48 db       	lddpc	r11,800046c8 <xnl_device_auth_reply_func+0x110>
80004696:	96 1c       	ld.sh	r12,r11[0x2]
80004698:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000469a:	96 2b       	ld.sh	r11,r11[0x4]
8000469c:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000469e:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800046a0:	30 ca       	mov	r10,12
800046a2:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800046a4:	30 0a       	mov	r10,0
800046a6:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800046aa:	30 7a       	mov	r10,7
800046ac:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800046b0:	30 2a       	mov	r10,2
800046b2:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800046b6:	fa ca ff ec 	sub	r10,sp,-20
800046ba:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800046bc:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800046be:	1a 9c       	mov	r12,sp
800046c0:	f0 1f 00 05 	mcall	800046d4 <xnl_device_auth_reply_func+0x11c>
}
800046c4:	2c 0d       	sub	sp,-256
800046c6:	d8 22       	popm	r4-r7,pc
800046c8:	00 00       	add	r0,r0
800046ca:	0b 32       	ld.ub	r2,r5++
800046cc:	00 00       	add	r0,r0
800046ce:	0b 2c       	ld.uh	r12,r5++
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	56 80       	stdsp	sp[0x1a0],r0
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	43 a0       	lddsp	r0,sp[0xe8]

800046d8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800046d8:	eb cd 40 80 	pushm	r7,lr
800046dc:	fa cd 01 00 	sub	sp,sp,256
800046e0:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800046e2:	49 28       	lddpc	r8,80004728 <xnl_master_status_brdcst_func+0x50>
800046e4:	11 88       	ld.ub	r8,r8[0x0]
800046e6:	58 08       	cp.w	r8,0
800046e8:	c1 c1       	brne	80004720 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800046ea:	49 18       	lddpc	r8,8000472c <xnl_master_status_brdcst_func+0x54>
800046ec:	70 0c       	ld.w	r12,r8[0x0]
800046ee:	30 09       	mov	r9,0
800046f0:	12 9a       	mov	r10,r9
800046f2:	12 9b       	mov	r11,r9
800046f4:	f0 1f 00 0f 	mcall	80004730 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800046f8:	8e 58       	ld.sh	r8,r7[0xa]
800046fa:	48 c9       	lddpc	r9,80004728 <xnl_master_status_brdcst_func+0x50>
800046fc:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800046fe:	e0 68 40 0e 	mov	r8,16398
80004702:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004704:	3f f8       	mov	r8,-1
80004706:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004708:	30 4a       	mov	r10,4
8000470a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000470c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000470e:	92 19       	ld.sh	r9,r9[0x2]
80004710:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004712:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004714:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004716:	30 08       	mov	r8,0
80004718:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000471a:	1a 9c       	mov	r12,sp
8000471c:	f0 1f 00 06 	mcall	80004734 <xnl_master_status_brdcst_func+0x5c>
}
80004720:	2c 0d       	sub	sp,-256
80004722:	e3 cd 80 80 	ldm	sp++,r7,pc
80004726:	00 00       	add	r0,r0
80004728:	00 00       	add	r0,r0
8000472a:	0b 32       	ld.ub	r2,r5++
8000472c:	00 00       	add	r0,r0
8000472e:	0b 2c       	ld.uh	r12,r5++
80004730:	80 00       	ld.sh	r0,r0[0x0]
80004732:	56 80       	stdsp	sp[0x1a0],r0
80004734:	80 00       	ld.sh	r0,r0[0x0]
80004736:	43 a0       	lddsp	r0,sp[0xe8]

80004738 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004738:	eb cd 40 80 	pushm	r7,lr
8000473c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000473e:	49 38       	lddpc	r8,80004788 <xnl_device_conn_reply_func+0x50>
80004740:	70 0c       	ld.w	r12,r8[0x0]
80004742:	30 09       	mov	r9,0
80004744:	12 9a       	mov	r10,r9
80004746:	12 9b       	mov	r11,r9
80004748:	f0 1f 00 11 	mcall	8000478c <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000474c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004750:	10 99       	mov	r9,r8
80004752:	e2 19 ff 00 	andl	r9,0xff00,COH
80004756:	e0 49 01 00 	cp.w	r9,256
8000475a:	c0 60       	breq	80004766 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000475c:	0e 9c       	mov	r12,r7
8000475e:	f0 1f 00 0d 	mcall	80004790 <xnl_device_conn_reply_func+0x58>
80004762:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004766:	a9 68       	lsl	r8,0x8
80004768:	48 b9       	lddpc	r9,80004794 <xnl_device_conn_reply_func+0x5c>
8000476a:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
8000476c:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004770:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004772:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004776:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004778:	30 18       	mov	r8,1
8000477a:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
8000477c:	48 7c       	lddpc	r12,80004798 <xnl_device_conn_reply_func+0x60>
8000477e:	f0 1f 00 08 	mcall	8000479c <xnl_device_conn_reply_func+0x64>
80004782:	e3 cd 80 80 	ldm	sp++,r7,pc
80004786:	00 00       	add	r0,r0
80004788:	00 00       	add	r0,r0
8000478a:	0b 2c       	ld.uh	r12,r5++
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	56 80       	stdsp	sp[0x1a0],r0
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	46 d8       	lddsp	r8,sp[0x1b4]
80004794:	00 00       	add	r0,r0
80004796:	0b 32       	ld.ub	r2,r5++
80004798:	80 00       	ld.sh	r0,r0[0x0]
8000479a:	cb d8       	rjmp	80004914 <tc_init+0x5c>
8000479c:	80 00       	ld.sh	r0,r0[0x0]
8000479e:	62 70       	ld.w	r0,r1[0x1c]

800047a0 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800047a0:	fe 78 0c 00 	mov	r8,-62464
800047a4:	e0 69 03 07 	mov	r9,775
800047a8:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800047aa:	30 49       	mov	r9,4
800047ac:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800047ae:	71 59       	ld.w	r9,r8[0x54]
800047b0:	e2 19 00 80 	andl	r9,0x80,COH
800047b4:	cf d0       	breq	800047ae <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800047b6:	fe 78 0c 00 	mov	r8,-62464
800047ba:	30 59       	mov	r9,5
800047bc:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800047be:	e0 69 01 0d 	mov	r9,269
800047c2:	ea 19 10 07 	orh	r9,0x1007
800047c6:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800047c8:	71 59       	ld.w	r9,r8[0x54]
800047ca:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800047ce:	cf d0       	breq	800047c8 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800047d0:	fe 78 0c 00 	mov	r8,-62464
800047d4:	fc 19 00 80 	movh	r9,0x80
800047d8:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800047da:	34 0a       	mov	r10,64
800047dc:	fe 69 14 00 	mov	r9,-125952
800047e0:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800047e2:	30 69       	mov	r9,6
800047e4:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800047e6:	30 19       	mov	r9,1
800047e8:	fe 68 10 00 	mov	r8,-126976
800047ec:	91 19       	st.w	r8[0x4],r9
}
800047ee:	5e fc       	retal	r12

800047f0 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
800047f0:	eb cd 40 c0 	pushm	r6-r7,lr
800047f4:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
800047f6:	f0 1f 00 1a 	mcall	8000485c <rtc_init+0x6c>
800047fa:	49 a8       	lddpc	r8,80004860 <rtc_init+0x70>
800047fc:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
800047fe:	70 08       	ld.w	r8,r8[0x0]
80004800:	58 08       	cp.w	r8,0
80004802:	c0 31       	brne	80004808 <rtc_init+0x18>
80004804:	30 3c       	mov	r12,3
80004806:	c2 78       	rjmp	80004854 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80004808:	49 66       	lddpc	r6,80004860 <rtc_init+0x70>
8000480a:	6c 0c       	ld.w	r12,r6[0x0]
8000480c:	30 09       	mov	r9,0
8000480e:	3f fa       	mov	r10,-1
80004810:	12 9b       	mov	r11,r9
80004812:	f0 1f 00 15 	mcall	80004864 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80004816:	30 2b       	mov	r11,2
80004818:	49 4c       	lddpc	r12,80004868 <rtc_init+0x78>
8000481a:	f0 1f 00 15 	mcall	8000486c <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
8000481e:	e0 68 36 00 	mov	r8,13824
80004822:	ea 18 01 6e 	orh	r8,0x16e
80004826:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80004828:	e2 78 0d 40 	mov	r8,200000
8000482c:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
8000482e:	35 18       	mov	r8,81
80004830:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80004834:	1a 9b       	mov	r11,sp
80004836:	fe 7c 2c 00 	mov	r12,-54272
8000483a:	f0 1f 00 0e 	mcall	80004870 <rtc_init+0x80>
8000483e:	48 e7       	lddpc	r7,80004874 <rtc_init+0x84>
80004840:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80004842:	6c 0c       	ld.w	r12,r6[0x0]
80004844:	30 09       	mov	r9,0
80004846:	12 9a       	mov	r10,r9
80004848:	12 9b       	mov	r11,r9
8000484a:	f0 1f 00 0c 	mcall	80004878 <rtc_init+0x88>
8000484e:	6e 08       	ld.w	r8,r7[0x0]
80004850:	58 08       	cp.w	r8,0
80004852:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80004854:	2f dd       	sub	sp,-12
80004856:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000485a:	00 00       	add	r0,r0
8000485c:	80 00       	ld.sh	r0,r0[0x0]
8000485e:	57 80       	stdsp	sp[0x1e0],r0
80004860:	00 00       	add	r0,r0
80004862:	0b 54       	ld.sh	r4,--r5
80004864:	80 00       	ld.sh	r0,r0[0x0]
80004866:	54 74       	stdsp	sp[0x11c],r4
80004868:	80 00       	ld.sh	r0,r0[0x0]
8000486a:	cb ec       	rcall	800049e6 <INTC_init_interrupts+0x2a>
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	67 08       	ld.w	r8,r3[0x40]
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	4d 00       	lddpc	r0,800049b0 <INTC_register_interrupt+0x74>
80004874:	00 00       	add	r0,r0
80004876:	0b 50       	ld.sh	r0,--r5
80004878:	80 00       	ld.sh	r0,r0[0x0]
8000487a:	56 80       	stdsp	sp[0x1a0],r0

8000487c <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
8000487c:	fe 78 10 00 	mov	r8,-61440
80004880:	fc 19 00 10 	movh	r9,0x10
80004884:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004886:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004888:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
8000488a:	30 39       	mov	r9,3
8000488c:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004890:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004894:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004898:	fe 78 38 00 	mov	r8,-51200
8000489c:	30 49       	mov	r9,4
8000489e:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800048a2:	e0 69 91 0d 	mov	r9,37133
800048a6:	ea 19 00 52 	orh	r9,0x52
800048aa:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800048ac:	32 09       	mov	r9,32
800048ae:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800048b0:	30 59       	mov	r9,5
800048b2:	91 09       	st.w	r8[0x0],r9
}
800048b4:	5e fc       	retal	r12
800048b6:	d7 03       	nop

800048b8 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
800048b8:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
800048ba:	30 2a       	mov	r10,2
800048bc:	e0 6b 01 c1 	mov	r11,449
800048c0:	48 ec       	lddpc	r12,800048f8 <tc_init+0x40>
800048c2:	f0 1f 00 0f 	mcall	800048fc <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
800048c6:	48 fb       	lddpc	r11,80004900 <tc_init+0x48>
800048c8:	fe 7c 38 00 	mov	r12,-51200
800048cc:	f0 1f 00 0e 	mcall	80004904 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
800048d0:	e0 6a 75 30 	mov	r10,30000
800048d4:	30 1b       	mov	r11,1
800048d6:	fe 7c 38 00 	mov	r12,-51200
800048da:	f0 1f 00 0c 	mcall	80004908 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
800048de:	48 ca       	lddpc	r10,8000490c <tc_init+0x54>
800048e0:	30 1b       	mov	r11,1
800048e2:	fe 7c 38 00 	mov	r12,-51200
800048e6:	f0 1f 00 0b 	mcall	80004910 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
800048ea:	30 1b       	mov	r11,1
800048ec:	fe 7c 38 00 	mov	r12,-51200
800048f0:	f0 1f 00 09 	mcall	80004914 <tc_init+0x5c>
800048f4:	d8 02       	popm	pc
800048f6:	00 00       	add	r0,r0
800048f8:	80 00       	ld.sh	r0,r0[0x0]
800048fa:	49 18       	lddpc	r8,8000493c <INTC_register_interrupt>
800048fc:	80 00       	ld.sh	r0,r0[0x0]
800048fe:	49 3c       	lddpc	r12,80004948 <INTC_register_interrupt+0xc>
80004900:	80 00       	ld.sh	r0,r0[0x0]
80004902:	cc 00       	breq	80004882 <local_start_timer+0x6>
80004904:	80 00       	ld.sh	r0,r0[0x0]
80004906:	4a 48       	lddpc	r8,80004994 <INTC_register_interrupt+0x58>
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	4b 08       	lddpc	r8,800049c8 <INTC_init_interrupts+0xc>
8000490c:	80 00       	ld.sh	r0,r0[0x0]
8000490e:	cb fc       	rcall	80004a8c <tc_init_waveform+0x44>
80004910:	80 00       	ld.sh	r0,r0[0x0]
80004912:	4b 3c       	lddpc	r12,800049dc <INTC_init_interrupts+0x20>
80004914:	80 00       	ld.sh	r0,r0[0x0]
80004916:	4a e4       	lddpc	r4,800049cc <INTC_init_interrupts+0x10>

80004918 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004918:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
8000491a:	48 68       	lddpc	r8,80004930 <_tc_interrupt+0x18>
8000491c:	70 09       	ld.w	r9,r8[0x0]
8000491e:	2f f9       	sub	r9,-1
80004920:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004922:	30 1b       	mov	r11,1
80004924:	fe 7c 38 00 	mov	r12,-51200
80004928:	f0 1f 00 03 	mcall	80004934 <_tc_interrupt+0x1c>
	
}
8000492c:	d4 02       	popm	lr
8000492e:	d6 03       	rete
80004930:	00 00       	add	r0,r0
80004932:	0b 58       	ld.sh	r8,--r5
80004934:	80 00       	ld.sh	r0,r0[0x0]
80004936:	4a f6       	lddpc	r6,800049f0 <INTC_init_interrupts+0x34>

80004938 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004938:	c0 08       	rjmp	80004938 <_unhandled_interrupt>
8000493a:	d7 03       	nop

8000493c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000493c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004940:	49 99       	lddpc	r9,800049a4 <INTC_register_interrupt+0x68>
80004942:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004946:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000494a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000494c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004950:	58 0a       	cp.w	r10,0
80004952:	c0 91       	brne	80004964 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004954:	49 59       	lddpc	r9,800049a8 <INTC_register_interrupt+0x6c>
80004956:	49 6a       	lddpc	r10,800049ac <INTC_register_interrupt+0x70>
80004958:	12 1a       	sub	r10,r9
8000495a:	fe 79 08 00 	mov	r9,-63488
8000495e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004962:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004964:	58 1a       	cp.w	r10,1
80004966:	c0 a1       	brne	8000497a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004968:	49 09       	lddpc	r9,800049a8 <INTC_register_interrupt+0x6c>
8000496a:	49 2a       	lddpc	r10,800049b0 <INTC_register_interrupt+0x74>
8000496c:	12 1a       	sub	r10,r9
8000496e:	bf aa       	sbr	r10,0x1e
80004970:	fe 79 08 00 	mov	r9,-63488
80004974:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004978:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000497a:	58 2a       	cp.w	r10,2
8000497c:	c0 a1       	brne	80004990 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000497e:	48 b9       	lddpc	r9,800049a8 <INTC_register_interrupt+0x6c>
80004980:	48 da       	lddpc	r10,800049b4 <INTC_register_interrupt+0x78>
80004982:	12 1a       	sub	r10,r9
80004984:	bf ba       	sbr	r10,0x1f
80004986:	fe 79 08 00 	mov	r9,-63488
8000498a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000498e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004990:	48 69       	lddpc	r9,800049a8 <INTC_register_interrupt+0x6c>
80004992:	48 aa       	lddpc	r10,800049b8 <INTC_register_interrupt+0x7c>
80004994:	12 1a       	sub	r10,r9
80004996:	ea 1a c0 00 	orh	r10,0xc000
8000499a:	fe 79 08 00 	mov	r9,-63488
8000499e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800049a2:	5e fc       	retal	r12
800049a4:	80 00       	ld.sh	r0,r0[0x0]
800049a6:	cc 08       	rjmp	80004b26 <tc_write_rc+0x1e>
800049a8:	80 00       	ld.sh	r0,r0[0x0]
800049aa:	c2 00       	breq	800049ea <INTC_init_interrupts+0x2e>
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	c3 04       	brge	80004a0e <INTC_init_interrupts+0x52>
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	c3 12       	brcc	80004a14 <_get_interrupt_handler+0x4>
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	c3 20       	breq	80004a1a <_get_interrupt_handler+0xa>
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	c3 2e       	rcall	8000461e <xnl_device_auth_reply_func+0x66>

800049bc <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800049bc:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800049be:	49 18       	lddpc	r8,80004a00 <INTC_init_interrupts+0x44>
800049c0:	e3 b8 00 01 	mtsr	0x4,r8
800049c4:	49 0e       	lddpc	lr,80004a04 <INTC_init_interrupts+0x48>
800049c6:	30 07       	mov	r7,0
800049c8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800049ca:	49 0c       	lddpc	r12,80004a08 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800049cc:	49 05       	lddpc	r5,80004a0c <INTC_init_interrupts+0x50>
800049ce:	10 15       	sub	r5,r8
800049d0:	fe 76 08 00 	mov	r6,-63488
800049d4:	c1 08       	rjmp	800049f4 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800049d6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800049d8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800049da:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800049dc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800049e0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800049e2:	10 3a       	cp.w	r10,r8
800049e4:	fe 9b ff fc 	brhi	800049dc <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800049e8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800049ec:	2f f7       	sub	r7,-1
800049ee:	2f 8e       	sub	lr,-8
800049f0:	59 37       	cp.w	r7,19
800049f2:	c0 50       	breq	800049fc <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800049f4:	7c 08       	ld.w	r8,lr[0x0]
800049f6:	58 08       	cp.w	r8,0
800049f8:	ce f1       	brne	800049d6 <INTC_init_interrupts+0x1a>
800049fa:	cf 7b       	rjmp	800049e8 <INTC_init_interrupts+0x2c>
800049fc:	d8 22       	popm	r4-r7,pc
800049fe:	00 00       	add	r0,r0
80004a00:	80 00       	ld.sh	r0,r0[0x0]
80004a02:	c2 00       	breq	80004a42 <_get_interrupt_handler+0x32>
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	cc 08       	rjmp	80004b86 <tc_configure_interrupts+0x4a>
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	49 38       	lddpc	r8,80004a54 <tc_init_waveform+0xc>
80004a0c:	80 00       	ld.sh	r0,r0[0x0]
80004a0e:	c3 04       	brge	80004a6e <tc_init_waveform+0x26>

80004a10 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004a10:	fe 78 08 00 	mov	r8,-63488
80004a14:	e0 69 00 83 	mov	r9,131
80004a18:	f2 0c 01 0c 	sub	r12,r9,r12
80004a1c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004a20:	f2 ca ff c0 	sub	r10,r9,-64
80004a24:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004a28:	58 08       	cp.w	r8,0
80004a2a:	c0 21       	brne	80004a2e <_get_interrupt_handler+0x1e>
80004a2c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004a2e:	f0 08 12 00 	clz	r8,r8
80004a32:	48 5a       	lddpc	r10,80004a44 <_get_interrupt_handler+0x34>
80004a34:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004a38:	f0 08 11 1f 	rsub	r8,r8,31
80004a3c:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004a3e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004a42:	5e fc       	retal	r12
80004a44:	80 00       	ld.sh	r0,r0[0x0]
80004a46:	cc 08       	rjmp	80004bc6 <tc_configure_interrupts+0x8a>

80004a48 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004a48:	76 09       	ld.w	r9,r11[0x0]
80004a4a:	58 29       	cp.w	r9,2
80004a4c:	e0 88 00 03 	brls	80004a52 <tc_init_waveform+0xa>
80004a50:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004a52:	76 18       	ld.w	r8,r11[0x4]
80004a54:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004a58:	af ba       	sbr	r10,0xf
80004a5a:	10 9b       	mov	r11,r8
80004a5c:	e6 1b c0 00 	andh	r11,0xc000,COH
80004a60:	16 4a       	or	r10,r11
80004a62:	10 9b       	mov	r11,r8
80004a64:	e6 1b 30 00 	andh	r11,0x3000,COH
80004a68:	16 4a       	or	r10,r11
80004a6a:	10 9b       	mov	r11,r8
80004a6c:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004a70:	16 4a       	or	r10,r11
80004a72:	10 9b       	mov	r11,r8
80004a74:	e6 1b 03 00 	andh	r11,0x300,COH
80004a78:	16 4a       	or	r10,r11
80004a7a:	10 9b       	mov	r11,r8
80004a7c:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004a80:	16 4a       	or	r10,r11
80004a82:	10 9b       	mov	r11,r8
80004a84:	e6 1b 00 30 	andh	r11,0x30,COH
80004a88:	16 4a       	or	r10,r11
80004a8a:	10 9b       	mov	r11,r8
80004a8c:	e6 1b 00 0c 	andh	r11,0xc,COH
80004a90:	16 4a       	or	r10,r11
80004a92:	10 9b       	mov	r11,r8
80004a94:	e6 1b 00 03 	andh	r11,0x3,COH
80004a98:	16 4a       	or	r10,r11
80004a9a:	10 9b       	mov	r11,r8
80004a9c:	e2 1b 60 00 	andl	r11,0x6000,COH
80004aa0:	16 4a       	or	r10,r11
80004aa2:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80004aa6:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80004aaa:	10 9b       	mov	r11,r8
80004aac:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004ab0:	16 4a       	or	r10,r11
80004ab2:	10 9b       	mov	r11,r8
80004ab4:	e2 1b 03 00 	andl	r11,0x300,COH
80004ab8:	16 4a       	or	r10,r11
80004aba:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004abe:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80004ac2:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80004ac6:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80004aca:	10 9b       	mov	r11,r8
80004acc:	e2 1b 00 30 	andl	r11,0x30,COH
80004ad0:	16 4a       	or	r10,r11
80004ad2:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004ad6:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80004ada:	a5 69       	lsl	r9,0x4
80004adc:	2f f9       	sub	r9,-1
80004ade:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004ae2:	5e fd       	retal	0

80004ae4 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004ae4:	58 2b       	cp.w	r11,2
80004ae6:	e0 88 00 03 	brls	80004aec <tc_start+0x8>
80004aea:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004aec:	a7 6b       	lsl	r11,0x6
80004aee:	16 0c       	add	r12,r11
80004af0:	30 58       	mov	r8,5
80004af2:	99 08       	st.w	r12[0x0],r8
80004af4:	5e fd       	retal	0

80004af6 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004af6:	58 2b       	cp.w	r11,2
80004af8:	e0 88 00 03 	brls	80004afe <tc_read_sr+0x8>
80004afc:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004afe:	a7 6b       	lsl	r11,0x6
80004b00:	2e 0b       	sub	r11,-32
80004b02:	16 0c       	add	r12,r11
80004b04:	78 0c       	ld.w	r12,r12[0x0]
}
80004b06:	5e fc       	retal	r12

80004b08 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004b08:	58 2b       	cp.w	r11,2
80004b0a:	e0 88 00 03 	brls	80004b10 <tc_write_rc+0x8>
80004b0e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004b10:	f6 08 15 04 	lsl	r8,r11,0x4
80004b14:	2f f8       	sub	r8,-1
80004b16:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004b1a:	e2 18 80 00 	andl	r8,0x8000,COH
80004b1e:	c0 c0       	breq	80004b36 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004b20:	a7 6b       	lsl	r11,0x6
80004b22:	16 0c       	add	r12,r11
80004b24:	2e 4c       	sub	r12,-28
80004b26:	78 08       	ld.w	r8,r12[0x0]
80004b28:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004b2c:	e0 18 00 00 	andl	r8,0x0
80004b30:	f3 e8 10 08 	or	r8,r9,r8
80004b34:	99 08       	st.w	r12[0x0],r8

  return value;
80004b36:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004b3a:	5e fc       	retal	r12

80004b3c <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004b3c:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004b40:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004b44:	58 2b       	cp.w	r11,2
80004b46:	e0 88 00 04 	brls	80004b4e <tc_configure_interrupts+0x12>
80004b4a:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004b4e:	ee 19 00 01 	eorh	r9,0x1
80004b52:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004b56:	74 08       	ld.w	r8,r10[0x0]
80004b58:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004b5c:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004b60:	a7 6e       	lsl	lr,0x6
80004b62:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004b66:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004b6a:	0e 4e       	or	lr,r7
80004b6c:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004b70:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004b74:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004b78:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004b7c:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004b80:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004b84:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004b88:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004b8c:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004b90:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004b94:	f6 0e 15 06 	lsl	lr,r11,0x6
80004b98:	f8 0e 00 0e 	add	lr,r12,lr
80004b9c:	2d ce       	sub	lr,-36
80004b9e:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004ba0:	58 09       	cp.w	r9,0
80004ba2:	c0 20       	breq	80004ba6 <tc_configure_interrupts+0x6a>
80004ba4:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004ba6:	74 08       	ld.w	r8,r10[0x0]
80004ba8:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004bac:	e0 65 00 80 	mov	r5,128
80004bb0:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004bb4:	74 08       	ld.w	r8,r10[0x0]
80004bb6:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004bba:	f9 b4 00 40 	moveq	r4,64
80004bbe:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004bc2:	74 08       	ld.w	r8,r10[0x0]
80004bc4:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004bc8:	f9 b3 00 20 	moveq	r3,32
80004bcc:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004bd0:	74 08       	ld.w	r8,r10[0x0]
80004bd2:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80004bd6:	f9 b2 00 10 	moveq	r2,16
80004bda:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004bde:	74 08       	ld.w	r8,r10[0x0]
80004be0:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004be4:	f9 b6 00 08 	moveq	r6,8
80004be8:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004bec:	74 08       	ld.w	r8,r10[0x0]
80004bee:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004bf2:	f9 b7 00 04 	moveq	r7,4
80004bf6:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004bfa:	74 08       	ld.w	r8,r10[0x0]
80004bfc:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004c00:	f9 be 00 02 	moveq	lr,2
80004c04:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004c08:	74 08       	ld.w	r8,r10[0x0]
80004c0a:	ec 18 00 01 	eorl	r8,0x1
80004c0e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004c12:	eb e8 10 08 	or	r8,r5,r8
80004c16:	08 48       	or	r8,r4
80004c18:	06 48       	or	r8,r3
80004c1a:	04 48       	or	r8,r2
80004c1c:	0c 48       	or	r8,r6
80004c1e:	0e 48       	or	r8,r7
80004c20:	1c 48       	or	r8,lr
80004c22:	f6 0a 15 06 	lsl	r10,r11,0x6
80004c26:	f8 0a 00 0a 	add	r10,r12,r10
80004c2a:	2d 8a       	sub	r10,-40
80004c2c:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004c2e:	a7 6b       	lsl	r11,0x6
80004c30:	2e 0b       	sub	r11,-32
80004c32:	16 0c       	add	r12,r11
80004c34:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004c36:	58 09       	cp.w	r9,0
80004c38:	c0 31       	brne	80004c3e <tc_configure_interrupts+0x102>
80004c3a:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004c3e:	d5 03       	csrf	0x10
80004c40:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004c44 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80004c44:	4a 78       	lddpc	r8,80004ce0 <twi_master_interrupt_handler+0x9c>
80004c46:	70 08       	ld.w	r8,r8[0x0]
80004c48:	70 89       	ld.w	r9,r8[0x20]
80004c4a:	4a 7a       	lddpc	r10,80004ce4 <twi_master_interrupt_handler+0xa0>
80004c4c:	74 0a       	ld.w	r10,r10[0x0]
80004c4e:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80004c52:	12 9a       	mov	r10,r9
80004c54:	e2 1a 01 00 	andl	r10,0x100,COH
80004c58:	c3 91       	brne	80004cca <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80004c5a:	12 9a       	mov	r10,r9
80004c5c:	e2 1a 00 02 	andl	r10,0x2,COH
80004c60:	c1 70       	breq	80004c8e <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80004c62:	4a 29       	lddpc	r9,80004ce8 <twi_master_interrupt_handler+0xa4>
80004c64:	72 0a       	ld.w	r10,r9[0x0]
80004c66:	70 cb       	ld.w	r11,r8[0x30]
80004c68:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80004c6a:	72 0a       	ld.w	r10,r9[0x0]
80004c6c:	2f fa       	sub	r10,-1
80004c6e:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80004c70:	49 f9       	lddpc	r9,80004cec <twi_master_interrupt_handler+0xa8>
80004c72:	72 0a       	ld.w	r10,r9[0x0]
80004c74:	20 1a       	sub	r10,1
80004c76:	93 0a       	st.w	r9[0x0],r10
80004c78:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80004c7a:	58 19       	cp.w	r9,1
80004c7c:	f9 b9 00 02 	moveq	r9,2
80004c80:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80004c84:	49 a9       	lddpc	r9,80004cec <twi_master_interrupt_handler+0xa8>
80004c86:	72 09       	ld.w	r9,r9[0x0]
80004c88:	58 09       	cp.w	r9,0
80004c8a:	c2 30       	breq	80004cd0 <twi_master_interrupt_handler+0x8c>
80004c8c:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80004c8e:	12 9a       	mov	r10,r9
80004c90:	e2 1a 00 04 	andl	r10,0x4,COH
80004c94:	c1 70       	breq	80004cc2 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80004c96:	49 79       	lddpc	r9,80004cf0 <twi_master_interrupt_handler+0xac>
80004c98:	72 0a       	ld.w	r10,r9[0x0]
80004c9a:	20 1a       	sub	r10,1
80004c9c:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80004c9e:	72 09       	ld.w	r9,r9[0x0]
80004ca0:	58 09       	cp.w	r9,0
80004ca2:	e0 89 00 0a 	brgt	80004cb6 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004ca6:	49 09       	lddpc	r9,80004ce4 <twi_master_interrupt_handler+0xa0>
80004ca8:	30 1a       	mov	r10,1
80004caa:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80004cac:	3f fa       	mov	r10,-1
80004cae:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80004cb0:	72 09       	ld.w	r9,r9[0x0]
80004cb2:	91 99       	st.w	r8[0x24],r9
80004cb4:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80004cb6:	49 0a       	lddpc	r10,80004cf4 <twi_master_interrupt_handler+0xb0>
80004cb8:	74 09       	ld.w	r9,r10[0x0]
80004cba:	13 3b       	ld.ub	r11,r9++
80004cbc:	91 db       	st.w	r8[0x34],r11
80004cbe:	95 09       	st.w	r10[0x0],r9
80004cc0:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80004cc2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004cc6:	c0 51       	brne	80004cd0 <twi_master_interrupt_handler+0x8c>
80004cc8:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80004cca:	30 1a       	mov	r10,1
80004ccc:	48 b9       	lddpc	r9,80004cf8 <twi_master_interrupt_handler+0xb4>
80004cce:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80004cd0:	3f f9       	mov	r9,-1
80004cd2:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80004cd4:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80004cd6:	30 09       	mov	r9,0
80004cd8:	48 98       	lddpc	r8,80004cfc <twi_master_interrupt_handler+0xb8>
80004cda:	b0 89       	st.b	r8[0x0],r9
80004cdc:	d6 03       	rete
80004cde:	00 00       	add	r0,r0
80004ce0:	00 00       	add	r0,r0
80004ce2:	0c 10       	sub	r0,r6
80004ce4:	00 00       	add	r0,r0
80004ce6:	0c 0c       	add	r12,r6
80004ce8:	00 00       	add	r0,r0
80004cea:	0c 1c       	sub	r12,r6
80004cec:	00 00       	add	r0,r0
80004cee:	0c 18       	sub	r8,r6
80004cf0:	00 00       	add	r0,r0
80004cf2:	0c 08       	add	r8,r6
80004cf4:	00 00       	add	r0,r0
80004cf6:	0c 14       	sub	r4,r6
80004cf8:	00 00       	add	r0,r0
80004cfa:	0c 05       	add	r5,r6
80004cfc:	00 00       	add	r0,r0
80004cfe:	0c 04       	add	r4,r6

80004d00 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004d00:	eb cd 40 e0 	pushm	r5-r7,lr
80004d04:	18 97       	mov	r7,r12
80004d06:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80004d08:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80004d0c:	49 f9       	lddpc	r9,80004d88 <twi_master_init+0x88>
80004d0e:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80004d10:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80004d12:	3f f9       	mov	r9,-1
80004d14:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80004d16:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004d18:	e0 69 00 80 	mov	r9,128
80004d1c:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004d1e:	e6 18 00 01 	andh	r8,0x1,COH
80004d22:	c0 21       	brne	80004d26 <twi_master_init+0x26>
      cpu_irq_enable();
80004d24:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80004d26:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004d28:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80004d2c:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80004d2e:	30 3a       	mov	r10,3
80004d30:	e0 6b 01 60 	mov	r11,352
80004d34:	49 6c       	lddpc	r12,80004d8c <twi_master_init+0x8c>
80004d36:	f0 1f 00 17 	mcall	80004d90 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004d3a:	e6 16 00 01 	andh	r6,0x1,COH
80004d3e:	c0 21       	brne	80004d42 <twi_master_init+0x42>
      cpu_irq_enable();
80004d40:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80004d42:	6a 19       	ld.w	r9,r5[0x4]
80004d44:	a1 79       	lsl	r9,0x1
80004d46:	6a 08       	ld.w	r8,r5[0x0]
80004d48:	f0 09 0d 08 	divu	r8,r8,r9
80004d4c:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004d4e:	e0 48 00 ff 	cp.w	r8,255
80004d52:	e0 8b 00 04 	brhi	80004d5a <twi_master_init+0x5a>
80004d56:	30 09       	mov	r9,0
80004d58:	c0 f8       	rjmp	80004d76 <twi_master_init+0x76>
80004d5a:	30 09       	mov	r9,0
80004d5c:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80004d5e:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80004d60:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004d62:	e0 48 00 ff 	cp.w	r8,255
80004d66:	5f bb       	srhi	r11
80004d68:	58 69       	cp.w	r9,6
80004d6a:	5f 8a       	srls	r10
80004d6c:	f7 ea 00 0a 	and	r10,r11,r10
80004d70:	f8 0a 18 00 	cp.b	r10,r12
80004d74:	cf 51       	brne	80004d5e <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80004d76:	b1 69       	lsl	r9,0x10
80004d78:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80004d7c:	f3 e8 10 08 	or	r8,r9,r8
80004d80:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80004d82:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80004d86:	00 00       	add	r0,r0
80004d88:	00 00       	add	r0,r0
80004d8a:	0c 10       	sub	r0,r6
80004d8c:	80 00       	ld.sh	r0,r0[0x0]
80004d8e:	4c 44       	lddpc	r4,80004e9c <usart_write_line+0x1c>
80004d90:	80 00       	ld.sh	r0,r0[0x0]
80004d92:	49 3c       	lddpc	r12,80004ddc <usart_set_async_baudrate+0x48>

80004d94 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004d94:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004d96:	f6 08 15 04 	lsl	r8,r11,0x4
80004d9a:	14 38       	cp.w	r8,r10
80004d9c:	f9 b8 08 10 	movls	r8,16
80004da0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004da4:	f0 0b 02 4b 	mul	r11,r8,r11
80004da8:	f6 09 16 01 	lsr	r9,r11,0x1
80004dac:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004db0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004db4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004db8:	f2 cb 00 01 	sub	r11,r9,1
80004dbc:	e0 4b ff fe 	cp.w	r11,65534
80004dc0:	e0 88 00 03 	brls	80004dc6 <usart_set_async_baudrate+0x32>
80004dc4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004dc6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004dc8:	e8 6e 00 00 	mov	lr,524288
80004dcc:	59 08       	cp.w	r8,16
80004dce:	fc 08 17 10 	movne	r8,lr
80004dd2:	f9 b8 00 00 	moveq	r8,0
80004dd6:	e4 1b ff f7 	andh	r11,0xfff7
80004dda:	e0 1b fe cf 	andl	r11,0xfecf
80004dde:	16 48       	or	r8,r11
80004de0:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004de2:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004de6:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004dea:	99 89       	st.w	r12[0x20],r9
80004dec:	d8 0a       	popm	pc,r12=0

80004dee <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004dee:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004df0:	e2 18 00 02 	andl	r8,0x2,COH
80004df4:	c0 31       	brne	80004dfa <usart_write_char+0xc>
80004df6:	30 2c       	mov	r12,2
80004df8:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004dfa:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004dfe:	99 7b       	st.w	r12[0x1c],r11
80004e00:	5e fd       	retal	0
80004e02:	d7 03       	nop

80004e04 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004e04:	eb cd 40 e0 	pushm	r5-r7,lr
80004e08:	18 96       	mov	r6,r12
80004e0a:	16 95       	mov	r5,r11
80004e0c:	e0 67 27 0f 	mov	r7,9999
80004e10:	c0 68       	rjmp	80004e1c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004e12:	58 07       	cp.w	r7,0
80004e14:	c0 31       	brne	80004e1a <usart_putchar+0x16>
80004e16:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004e1a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004e1c:	0a 9b       	mov	r11,r5
80004e1e:	0c 9c       	mov	r12,r6
80004e20:	f0 1f 00 03 	mcall	80004e2c <usart_putchar+0x28>
80004e24:	cf 71       	brne	80004e12 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004e26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004e2a:	00 00       	add	r0,r0
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	4d ee       	lddpc	lr,80004fa4 <vListInitialise+0x8>

80004e30 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004e30:	78 58       	ld.w	r8,r12[0x14]
80004e32:	e2 18 00 e0 	andl	r8,0xe0,COH
80004e36:	c0 30       	breq	80004e3c <usart_read_char+0xc>
80004e38:	30 4c       	mov	r12,4
80004e3a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004e3c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004e3e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e42:	c0 31       	brne	80004e48 <usart_read_char+0x18>
80004e44:	30 3c       	mov	r12,3
80004e46:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004e48:	78 68       	ld.w	r8,r12[0x18]
80004e4a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004e4e:	97 08       	st.w	r11[0x0],r8
80004e50:	5e fd       	retal	0
80004e52:	d7 03       	nop

80004e54 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004e54:	eb cd 40 c0 	pushm	r6-r7,lr
80004e58:	20 1d       	sub	sp,4
80004e5a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004e5c:	1a 97       	mov	r7,sp
80004e5e:	1a 9b       	mov	r11,sp
80004e60:	0c 9c       	mov	r12,r6
80004e62:	f0 1f 00 07 	mcall	80004e7c <usart_getchar+0x28>
80004e66:	58 3c       	cp.w	r12,3
80004e68:	cf b0       	breq	80004e5e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004e6a:	58 4c       	cp.w	r12,4
80004e6c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004e70:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004e74:	2f fd       	sub	sp,-4
80004e76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e7a:	00 00       	add	r0,r0
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	4e 30       	lddpc	r0,80005008 <vListRemove+0x2>

80004e80 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004e80:	eb cd 40 c0 	pushm	r6-r7,lr
80004e84:	18 96       	mov	r6,r12
80004e86:	16 97       	mov	r7,r11
  while (*string != '\0')
80004e88:	17 8b       	ld.ub	r11,r11[0x0]
80004e8a:	58 0b       	cp.w	r11,0
80004e8c:	c0 80       	breq	80004e9c <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004e8e:	2f f7       	sub	r7,-1
80004e90:	0c 9c       	mov	r12,r6
80004e92:	f0 1f 00 04 	mcall	80004ea0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004e96:	0f 8b       	ld.ub	r11,r7[0x0]
80004e98:	58 0b       	cp.w	r11,0
80004e9a:	cf a1       	brne	80004e8e <usart_write_line+0xe>
80004e9c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ea0:	80 00       	ld.sh	r0,r0[0x0]
80004ea2:	4e 04       	lddpc	r4,80005020 <vListRemove+0x1a>

80004ea4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004ea4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004ea8:	e6 18 00 01 	andh	r8,0x1,COH
80004eac:	c0 71       	brne	80004eba <usart_reset+0x16>
80004eae:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004eb0:	3f f8       	mov	r8,-1
80004eb2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004eb4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004eb6:	d5 03       	csrf	0x10
80004eb8:	c0 48       	rjmp	80004ec0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004eba:	3f f8       	mov	r8,-1
80004ebc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004ebe:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004ec0:	30 08       	mov	r8,0
80004ec2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004ec4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004ec6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004ec8:	ea 68 61 0c 	mov	r8,680204
80004ecc:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004ece:	5e fc       	retal	r12

80004ed0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004ed0:	eb cd 40 e0 	pushm	r5-r7,lr
80004ed4:	18 96       	mov	r6,r12
80004ed6:	16 97       	mov	r7,r11
80004ed8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004eda:	f0 1f 00 2f 	mcall	80004f94 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004ede:	58 07       	cp.w	r7,0
80004ee0:	c5 80       	breq	80004f90 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004ee2:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004ee4:	30 49       	mov	r9,4
80004ee6:	f2 08 18 00 	cp.b	r8,r9
80004eea:	e0 88 00 53 	brls	80004f90 <usart_init_rs232+0xc0>
80004eee:	30 99       	mov	r9,9
80004ef0:	f2 08 18 00 	cp.b	r8,r9
80004ef4:	e0 8b 00 4e 	brhi	80004f90 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004ef8:	0f d9       	ld.ub	r9,r7[0x5]
80004efa:	30 78       	mov	r8,7
80004efc:	f0 09 18 00 	cp.b	r9,r8
80004f00:	e0 8b 00 48 	brhi	80004f90 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004f04:	8e 39       	ld.sh	r9,r7[0x6]
80004f06:	e0 68 01 01 	mov	r8,257
80004f0a:	f0 09 19 00 	cp.h	r9,r8
80004f0e:	e0 8b 00 41 	brhi	80004f90 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004f12:	ef 39 00 08 	ld.ub	r9,r7[8]
80004f16:	30 38       	mov	r8,3
80004f18:	f0 09 18 00 	cp.b	r9,r8
80004f1c:	e0 8b 00 3a 	brhi	80004f90 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004f20:	0a 9a       	mov	r10,r5
80004f22:	6e 0b       	ld.w	r11,r7[0x0]
80004f24:	0c 9c       	mov	r12,r6
80004f26:	f0 1f 00 1d 	mcall	80004f98 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004f2a:	58 1c       	cp.w	r12,1
80004f2c:	c3 20       	breq	80004f90 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004f2e:	0f c8       	ld.ub	r8,r7[0x4]
80004f30:	30 99       	mov	r9,9
80004f32:	f2 08 18 00 	cp.b	r8,r9
80004f36:	c0 51       	brne	80004f40 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004f38:	6c 18       	ld.w	r8,r6[0x4]
80004f3a:	b1 b8       	sbr	r8,0x11
80004f3c:	8d 18       	st.w	r6[0x4],r8
80004f3e:	c0 68       	rjmp	80004f4a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004f40:	6c 19       	ld.w	r9,r6[0x4]
80004f42:	20 58       	sub	r8,5
80004f44:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004f48:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004f4a:	6c 19       	ld.w	r9,r6[0x4]
80004f4c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004f50:	0f d8       	ld.ub	r8,r7[0x5]
80004f52:	a9 78       	lsl	r8,0x9
80004f54:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004f58:	12 48       	or	r8,r9
80004f5a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004f5c:	8e 38       	ld.sh	r8,r7[0x6]
80004f5e:	30 29       	mov	r9,2
80004f60:	f2 08 19 00 	cp.h	r8,r9
80004f64:	e0 88 00 09 	brls	80004f76 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004f68:	6c 18       	ld.w	r8,r6[0x4]
80004f6a:	ad b8       	sbr	r8,0xd
80004f6c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004f6e:	8e b8       	ld.uh	r8,r7[0x6]
80004f70:	20 28       	sub	r8,2
80004f72:	8d a8       	st.w	r6[0x28],r8
80004f74:	c0 68       	rjmp	80004f80 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004f76:	6c 19       	ld.w	r9,r6[0x4]
80004f78:	5c 78       	castu.h	r8
80004f7a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004f7e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004f80:	6c 18       	ld.w	r8,r6[0x4]
80004f82:	e0 18 ff f0 	andl	r8,0xfff0
80004f86:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004f88:	35 08       	mov	r8,80
80004f8a:	8d 08       	st.w	r6[0x0],r8
80004f8c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004f90:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	4e a4       	lddpc	r4,8000513c <SCALLYield+0x14>
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	4d 94       	lddpc	r4,800050fc <xPortStartScheduler+0x2c>

80004f9c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004f9c:	f8 c8 ff f8 	sub	r8,r12,-8
80004fa0:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004fa2:	3f f9       	mov	r9,-1
80004fa4:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004fa6:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004fa8:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004faa:	30 08       	mov	r8,0
80004fac:	99 08       	st.w	r12[0x0],r8
}
80004fae:	5e fc       	retal	r12

80004fb0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004fb0:	30 08       	mov	r8,0
80004fb2:	99 48       	st.w	r12[0x10],r8
}
80004fb4:	5e fc       	retal	r12

80004fb6 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004fb6:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004fb8:	70 19       	ld.w	r9,r8[0x4]
80004fba:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004fbc:	78 19       	ld.w	r9,r12[0x4]
80004fbe:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004fc0:	70 19       	ld.w	r9,r8[0x4]
80004fc2:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004fc4:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004fc6:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004fc8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004fca:	78 08       	ld.w	r8,r12[0x0]
80004fcc:	2f f8       	sub	r8,-1
80004fce:	99 08       	st.w	r12[0x0],r8
}
80004fd0:	5e fc       	retal	r12

80004fd2 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004fd2:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004fd4:	5b fa       	cp.w	r10,-1
80004fd6:	c0 31       	brne	80004fdc <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004fd8:	78 48       	ld.w	r8,r12[0x10]
80004fda:	c0 c8       	rjmp	80004ff2 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004fdc:	f8 c8 ff f8 	sub	r8,r12,-8
80004fe0:	70 19       	ld.w	r9,r8[0x4]
80004fe2:	72 09       	ld.w	r9,r9[0x0]
80004fe4:	12 3a       	cp.w	r10,r9
80004fe6:	c0 63       	brcs	80004ff2 <vListInsert+0x20>
80004fe8:	70 18       	ld.w	r8,r8[0x4]
80004fea:	70 19       	ld.w	r9,r8[0x4]
80004fec:	72 09       	ld.w	r9,r9[0x0]
80004fee:	12 3a       	cp.w	r10,r9
80004ff0:	cf c2       	brcc	80004fe8 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004ff2:	70 19       	ld.w	r9,r8[0x4]
80004ff4:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004ff6:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004ff8:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004ffa:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004ffc:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004ffe:	78 08       	ld.w	r8,r12[0x0]
80005000:	2f f8       	sub	r8,-1
80005002:	99 08       	st.w	r12[0x0],r8
}
80005004:	5e fc       	retal	r12

80005006 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005006:	78 18       	ld.w	r8,r12[0x4]
80005008:	78 29       	ld.w	r9,r12[0x8]
8000500a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000500c:	78 28       	ld.w	r8,r12[0x8]
8000500e:	78 19       	ld.w	r9,r12[0x4]
80005010:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005012:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005014:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005016:	18 39       	cp.w	r9,r12
80005018:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
8000501c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005020:	30 09       	mov	r9,0
80005022:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005024:	70 09       	ld.w	r9,r8[0x0]
80005026:	20 19       	sub	r9,1
80005028:	91 09       	st.w	r8[0x0],r9
}
8000502a:	5e fc       	retal	r12

8000502c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000502c:	e0 68 08 08 	mov	r8,2056
80005030:	ea 18 08 08 	orh	r8,0x808
80005034:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005036:	e0 68 09 09 	mov	r8,2313
8000503a:	ea 18 09 09 	orh	r8,0x909
8000503e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005040:	e0 68 0a 0a 	mov	r8,2570
80005044:	ea 18 0a 0a 	orh	r8,0xa0a
80005048:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000504a:	e0 68 0b 0b 	mov	r8,2827
8000504e:	ea 18 0b 0b 	orh	r8,0xb0b
80005052:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005054:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005056:	e0 68 be ef 	mov	r8,48879
8000505a:	ea 18 de ad 	orh	r8,0xdead
8000505e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005060:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005062:	fc 18 00 40 	movh	r8,0x40
80005066:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005068:	e0 68 00 ff 	mov	r8,255
8000506c:	ea 18 ff 00 	orh	r8,0xff00
80005070:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005072:	e0 68 01 01 	mov	r8,257
80005076:	ea 18 01 01 	orh	r8,0x101
8000507a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000507c:	e0 68 02 02 	mov	r8,514
80005080:	ea 18 02 02 	orh	r8,0x202
80005084:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005086:	e0 68 03 03 	mov	r8,771
8000508a:	ea 18 03 03 	orh	r8,0x303
8000508e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005090:	e0 68 04 04 	mov	r8,1028
80005094:	ea 18 04 04 	orh	r8,0x404
80005098:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000509a:	e0 68 05 05 	mov	r8,1285
8000509e:	ea 18 05 05 	orh	r8,0x505
800050a2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800050a4:	e0 68 06 06 	mov	r8,1542
800050a8:	ea 18 06 06 	orh	r8,0x606
800050ac:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800050ae:	e0 68 07 07 	mov	r8,1799
800050b2:	ea 18 07 07 	orh	r8,0x707
800050b6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800050b8:	30 08       	mov	r8,0
800050ba:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800050bc:	5e fc       	retal	r12
800050be:	d7 03       	nop

800050c0 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800050c0:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800050c2:	48 38       	lddpc	r8,800050cc <vPortEnterCritical+0xc>
800050c4:	70 09       	ld.w	r9,r8[0x0]
800050c6:	2f f9       	sub	r9,-1
800050c8:	91 09       	st.w	r8[0x0],r9
}
800050ca:	5e fc       	retal	r12
800050cc:	00 00       	add	r0,r0
800050ce:	05 28       	ld.uh	r8,r2++

800050d0 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800050d0:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800050d2:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800050d4:	30 0a       	mov	r10,0
800050d6:	14 9b       	mov	r11,r10
800050d8:	49 2c       	lddpc	r12,80005120 <xPortStartScheduler+0x50>
800050da:	f0 1f 00 13 	mcall	80005124 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800050de:	e0 68 5d c0 	mov	r8,24000
800050e2:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800050e6:	30 08       	mov	r8,0
800050e8:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800050ec:	e0 68 0c f0 	mov	r8,3312
800050f0:	ea 18 00 00 	orh	r8,0x0
800050f4:	70 00       	ld.w	r0,r8[0x0]
800050f6:	60 0d       	ld.w	sp,r0[0x0]
800050f8:	1b 00       	ld.w	r0,sp++
800050fa:	e0 68 05 28 	mov	r8,1320
800050fe:	ea 18 00 00 	orh	r8,0x0
80005102:	91 00       	st.w	r8[0x0],r0
80005104:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005108:	2f ed       	sub	sp,-8
8000510a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000510e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005112:	e3 b0 00 00 	mtsr	0x0,r0
80005116:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000511a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000511e:	d8 0a       	popm	pc,r12=0
80005120:	80 00       	ld.sh	r0,r0[0x0]
80005122:	51 ec       	stdsp	sp[0x78],r12
80005124:	80 00       	ld.sh	r0,r0[0x0]
80005126:	49 3c       	lddpc	r12,80005170 <SCALLYield+0x48>

80005128 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005128:	20 6d       	sub	sp,24
8000512a:	eb cd 00 ff 	pushm	r0-r7
8000512e:	fa c7 ff c0 	sub	r7,sp,-64
80005132:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005136:	ef 40 ff e0 	st.w	r7[-32],r0
8000513a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000513e:	ef 40 ff e4 	st.w	r7[-28],r0
80005142:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005146:	e0 68 05 28 	mov	r8,1320
8000514a:	ea 18 00 00 	orh	r8,0x0
8000514e:	70 00       	ld.w	r0,r8[0x0]
80005150:	1a d0       	st.w	--sp,r0
80005152:	f0 1f 00 1a 	mcall	800051b8 <LABEL_RET_SCALL_263+0x14>
80005156:	e0 68 0c f0 	mov	r8,3312
8000515a:	ea 18 00 00 	orh	r8,0x0
8000515e:	70 00       	ld.w	r0,r8[0x0]
80005160:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005162:	f0 1f 00 17 	mcall	800051bc <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005166:	e0 68 0c f0 	mov	r8,3312
8000516a:	ea 18 00 00 	orh	r8,0x0
8000516e:	70 00       	ld.w	r0,r8[0x0]
80005170:	60 0d       	ld.w	sp,r0[0x0]
80005172:	1b 00       	ld.w	r0,sp++
80005174:	e0 68 05 28 	mov	r8,1320
80005178:	ea 18 00 00 	orh	r8,0x0
8000517c:	91 00       	st.w	r8[0x0],r0
8000517e:	fa c7 ff d8 	sub	r7,sp,-40
80005182:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005186:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000518a:	e0 61 05 28 	mov	r1,1320
8000518e:	ea 11 00 00 	orh	r1,0x0
80005192:	62 02       	ld.w	r2,r1[0x0]
80005194:	58 02       	cp.w	r2,0
80005196:	c0 70       	breq	800051a4 <LABEL_RET_SCALL_263>
80005198:	e4 c2 00 01 	sub	r2,r2,1
8000519c:	83 02       	st.w	r1[0x0],r2
8000519e:	58 02       	cp.w	r2,0
800051a0:	c0 21       	brne	800051a4 <LABEL_RET_SCALL_263>
800051a2:	b1 c0       	cbr	r0,0x10

800051a4 <LABEL_RET_SCALL_263>:
800051a4:	ef 40 ff f8 	st.w	r7[-8],r0
800051a8:	ee f0 ff e4 	ld.w	r0,r7[-28]
800051ac:	ef 40 ff fc 	st.w	r7[-4],r0
800051b0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800051b4:	2f ad       	sub	sp,-24
800051b6:	d6 13       	rets
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	50 c0       	stdsp	sp[0x30],r0
800051bc:	80 00       	ld.sh	r0,r0[0x0]
800051be:	58 5c       	cp.w	r12,5

800051c0 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800051c0:	e1 b8 00 43 	mfsr	r8,0x10c
800051c4:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800051c8:	5e fc       	retal	r12
800051ca:	d7 03       	nop

800051cc <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800051cc:	48 78       	lddpc	r8,800051e8 <vPortExitCritical+0x1c>
800051ce:	70 08       	ld.w	r8,r8[0x0]
800051d0:	58 08       	cp.w	r8,0
800051d2:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800051d4:	48 58       	lddpc	r8,800051e8 <vPortExitCritical+0x1c>
800051d6:	70 09       	ld.w	r9,r8[0x0]
800051d8:	20 19       	sub	r9,1
800051da:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800051dc:	70 08       	ld.w	r8,r8[0x0]
800051de:	58 08       	cp.w	r8,0
800051e0:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800051e2:	d5 03       	csrf	0x10
800051e4:	5e fc       	retal	r12
800051e6:	00 00       	add	r0,r0
800051e8:	00 00       	add	r0,r0
800051ea:	05 28       	ld.uh	r8,r2++

800051ec <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800051ec:	eb cd 00 ff 	pushm	r0-r7
800051f0:	e0 68 05 28 	mov	r8,1320
800051f4:	ea 18 00 00 	orh	r8,0x0
800051f8:	70 00       	ld.w	r0,r8[0x0]
800051fa:	1a d0       	st.w	--sp,r0
800051fc:	7a 90       	ld.w	r0,sp[0x24]
800051fe:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005202:	58 10       	cp.w	r0,1
80005204:	e0 8b 00 08 	brhi	80005214 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005208:	e0 68 0c f0 	mov	r8,3312
8000520c:	ea 18 00 00 	orh	r8,0x0
80005210:	70 00       	ld.w	r0,r8[0x0]
80005212:	81 0d       	st.w	r0[0x0],sp

80005214 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005214:	f0 1f 00 12 	mcall	8000525c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005218:	f0 1f 00 12 	mcall	80005260 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
8000521c:	f0 1f 00 12 	mcall	80005264 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005220:	f0 1f 00 12 	mcall	80005268 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005224:	7a 90       	ld.w	r0,sp[0x24]
80005226:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000522a:	58 10       	cp.w	r0,1
8000522c:	e0 8b 00 0e 	brhi	80005248 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005230:	f0 1f 00 0c 	mcall	80005260 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005234:	f0 1f 00 0e 	mcall	8000526c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005238:	f0 1f 00 0c 	mcall	80005268 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
8000523c:	e0 68 0c f0 	mov	r8,3312
80005240:	ea 18 00 00 	orh	r8,0x0
80005244:	70 00       	ld.w	r0,r8[0x0]
80005246:	60 0d       	ld.w	sp,r0[0x0]

80005248 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005248:	1b 00       	ld.w	r0,sp++
8000524a:	e0 68 05 28 	mov	r8,1320
8000524e:	ea 18 00 00 	orh	r8,0x0
80005252:	91 00       	st.w	r8[0x0],r0
80005254:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005258:	d6 03       	rete
8000525a:	00 00       	add	r0,r0
8000525c:	80 00       	ld.sh	r0,r0[0x0]
8000525e:	51 c0       	stdsp	sp[0x70],r0
80005260:	80 00       	ld.sh	r0,r0[0x0]
80005262:	50 c0       	stdsp	sp[0x30],r0
80005264:	80 00       	ld.sh	r0,r0[0x0]
80005266:	5a 60       	cp.w	r0,-26
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	51 cc       	stdsp	sp[0x70],r12
8000526c:	80 00       	ld.sh	r0,r0[0x0]
8000526e:	58 5c       	cp.w	r12,5

80005270 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005270:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005272:	f0 1f 00 02 	mcall	80005278 <__malloc_lock+0x8>
}
80005276:	d8 02       	popm	pc
80005278:	80 00       	ld.sh	r0,r0[0x0]
8000527a:	58 4c       	cp.w	r12,4

8000527c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000527c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000527e:	f0 1f 00 02 	mcall	80005284 <__malloc_unlock+0x8>
}
80005282:	d8 02       	popm	pc
80005284:	80 00       	ld.sh	r0,r0[0x0]
80005286:	5c 08       	acr	r8

80005288 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005288:	d4 21       	pushm	r4-r7,lr
8000528a:	16 95       	mov	r5,r11
8000528c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000528e:	58 0c       	cp.w	r12,0
80005290:	c0 30       	breq	80005296 <_read+0xe>
80005292:	3f f7       	mov	r7,-1
80005294:	c1 48       	rjmp	800052bc <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005296:	58 0a       	cp.w	r10,0
80005298:	e0 89 00 04 	brgt	800052a0 <_read+0x18>
8000529c:	30 07       	mov	r7,0
8000529e:	c0 f8       	rjmp	800052bc <_read+0x34>
800052a0:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800052a2:	48 84       	lddpc	r4,800052c0 <_read+0x38>
800052a4:	68 0c       	ld.w	r12,r4[0x0]
800052a6:	f0 1f 00 08 	mcall	800052c4 <_read+0x3c>
    if (c < 0)
800052aa:	c0 95       	brlt	800052bc <_read+0x34>
      break;

    *ptr++ = c;
800052ac:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800052b0:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800052b2:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800052b6:	58 08       	cp.w	r8,0
800052b8:	fe 99 ff f6 	brgt	800052a4 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800052bc:	0e 9c       	mov	r12,r7
800052be:	d8 22       	popm	r4-r7,pc
800052c0:	00 00       	add	r0,r0
800052c2:	41 10       	lddsp	r0,sp[0x44]
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	4e 54       	lddpc	r4,80005458 <prvUnlockQueue+0x84>

800052c8 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800052c8:	d4 21       	pushm	r4-r7,lr
800052ca:	16 95       	mov	r5,r11
800052cc:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800052ce:	20 1c       	sub	r12,1
800052d0:	58 2c       	cp.w	r12,2
800052d2:	e0 8b 00 12 	brhi	800052f6 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800052d6:	58 0a       	cp.w	r10,0
800052d8:	c0 31       	brne	800052de <_write+0x16>
800052da:	30 07       	mov	r7,0
800052dc:	c0 e8       	rjmp	800052f8 <_write+0x30>
800052de:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
800052e0:	48 74       	lddpc	r4,800052fc <_write+0x34>
800052e2:	68 0c       	ld.w	r12,r4[0x0]
800052e4:	ea 07 07 0b 	ld.ub	r11,r5[r7]
800052e8:	f0 1f 00 06 	mcall	80005300 <_write+0x38>
800052ec:	c0 55       	brlt	800052f6 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
800052ee:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800052f0:	0e 36       	cp.w	r6,r7
800052f2:	cf 81       	brne	800052e2 <_write+0x1a>
800052f4:	c0 28       	rjmp	800052f8 <_write+0x30>
800052f6:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
800052f8:	0e 9c       	mov	r12,r7
800052fa:	d8 22       	popm	r4-r7,pc
800052fc:	00 00       	add	r0,r0
800052fe:	41 10       	lddsp	r0,sp[0x44]
80005300:	80 00       	ld.sh	r0,r0[0x0]
80005302:	4e 04       	lddpc	r4,80005480 <xQueueGenericReceive+0xc>

80005304 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005304:	eb cd 40 80 	pushm	r7,lr
80005308:	18 97       	mov	r7,r12
	if( pv )
8000530a:	58 0c       	cp.w	r12,0
8000530c:	c0 80       	breq	8000531c <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000530e:	f0 1f 00 05 	mcall	80005320 <vPortFree+0x1c>
		{
			free( pv );
80005312:	0e 9c       	mov	r12,r7
80005314:	f0 1f 00 04 	mcall	80005324 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005318:	f0 1f 00 04 	mcall	80005328 <vPortFree+0x24>
8000531c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005320:	80 00       	ld.sh	r0,r0[0x0]
80005322:	58 4c       	cp.w	r12,4
80005324:	80 00       	ld.sh	r0,r0[0x0]
80005326:	67 78       	ld.w	r8,r3[0x5c]
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	5c 08       	acr	r8

8000532c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000532c:	eb cd 40 80 	pushm	r7,lr
80005330:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005332:	f0 1f 00 06 	mcall	80005348 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005336:	0e 9c       	mov	r12,r7
80005338:	f0 1f 00 05 	mcall	8000534c <pvPortMalloc+0x20>
8000533c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000533e:	f0 1f 00 05 	mcall	80005350 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005342:	0e 9c       	mov	r12,r7
80005344:	e3 cd 80 80 	ldm	sp++,r7,pc
80005348:	80 00       	ld.sh	r0,r0[0x0]
8000534a:	58 4c       	cp.w	r12,4
8000534c:	80 00       	ld.sh	r0,r0[0x0]
8000534e:	67 88       	ld.w	r8,r3[0x60]
80005350:	80 00       	ld.sh	r0,r0[0x0]
80005352:	5c 08       	acr	r8

80005354 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005354:	d4 01       	pushm	lr
80005356:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005358:	78 09       	ld.w	r9,r12[0x0]
8000535a:	58 09       	cp.w	r9,0
8000535c:	c1 10       	breq	8000537e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000535e:	78 3a       	ld.w	r10,r12[0xc]
80005360:	79 09       	ld.w	r9,r12[0x40]
80005362:	f4 09 00 09 	add	r9,r10,r9
80005366:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005368:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000536a:	14 39       	cp.w	r9,r10
8000536c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005370:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005374:	79 0a       	ld.w	r10,r12[0x40]
80005376:	78 3b       	ld.w	r11,r12[0xc]
80005378:	10 9c       	mov	r12,r8
8000537a:	f0 1f 00 02 	mcall	80005380 <prvCopyDataFromQueue+0x2c>
8000537e:	d8 02       	popm	pc
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	6b d0       	ld.w	r0,r5[0x74]

80005384 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005384:	eb cd 40 c0 	pushm	r6-r7,lr
80005388:	18 97       	mov	r7,r12
8000538a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000538c:	78 e8       	ld.w	r8,r12[0x38]
8000538e:	58 08       	cp.w	r8,0
80005390:	c0 31       	brne	80005396 <xQueueReceiveFromISR+0x12>
80005392:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005396:	f0 1f 00 0e 	mcall	800053cc <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000539a:	6e e8       	ld.w	r8,r7[0x38]
8000539c:	20 18       	sub	r8,1
8000539e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800053a0:	6f 18       	ld.w	r8,r7[0x44]
800053a2:	5b f8       	cp.w	r8,-1
800053a4:	c0 d1       	brne	800053be <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800053a6:	6e 48       	ld.w	r8,r7[0x10]
800053a8:	58 08       	cp.w	r8,0
800053aa:	c0 f0       	breq	800053c8 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800053ac:	ee cc ff f0 	sub	r12,r7,-16
800053b0:	f0 1f 00 08 	mcall	800053d0 <xQueueReceiveFromISR+0x4c>
800053b4:	c0 a0       	breq	800053c8 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800053b6:	30 1c       	mov	r12,1
800053b8:	8d 0c       	st.w	r6[0x0],r12
800053ba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800053be:	2f f8       	sub	r8,-1
800053c0:	ef 48 00 44 	st.w	r7[68],r8
800053c4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800053c8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	53 54       	stdsp	sp[0xd4],r4
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	59 e4       	cp.w	r4,30

800053d4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800053d4:	eb cd 40 c0 	pushm	r6-r7,lr
800053d8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800053da:	f0 1f 00 23 	mcall	80005464 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800053de:	6f 28       	ld.w	r8,r7[0x48]
800053e0:	58 08       	cp.w	r8,0
800053e2:	e0 8a 00 18 	brle	80005412 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800053e6:	6e 98       	ld.w	r8,r7[0x24]
800053e8:	58 08       	cp.w	r8,0
800053ea:	c1 40       	breq	80005412 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800053ec:	ee c6 ff dc 	sub	r6,r7,-36
800053f0:	c0 48       	rjmp	800053f8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800053f2:	6e 98       	ld.w	r8,r7[0x24]
800053f4:	58 08       	cp.w	r8,0
800053f6:	c0 e0       	breq	80005412 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800053f8:	0c 9c       	mov	r12,r6
800053fa:	f0 1f 00 1c 	mcall	80005468 <prvUnlockQueue+0x94>
800053fe:	c0 30       	breq	80005404 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005400:	f0 1f 00 1b 	mcall	8000546c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005404:	6f 28       	ld.w	r8,r7[0x48]
80005406:	20 18       	sub	r8,1
80005408:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000540c:	58 08       	cp.w	r8,0
8000540e:	fe 99 ff f2 	brgt	800053f2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005412:	3f f8       	mov	r8,-1
80005414:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005418:	f0 1f 00 16 	mcall	80005470 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000541c:	f0 1f 00 12 	mcall	80005464 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005420:	6f 18       	ld.w	r8,r7[0x44]
80005422:	58 08       	cp.w	r8,0
80005424:	e0 8a 00 18 	brle	80005454 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005428:	6e 48       	ld.w	r8,r7[0x10]
8000542a:	58 08       	cp.w	r8,0
8000542c:	c1 40       	breq	80005454 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000542e:	ee c6 ff f0 	sub	r6,r7,-16
80005432:	c0 48       	rjmp	8000543a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005434:	6e 48       	ld.w	r8,r7[0x10]
80005436:	58 08       	cp.w	r8,0
80005438:	c0 e0       	breq	80005454 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000543a:	0c 9c       	mov	r12,r6
8000543c:	f0 1f 00 0b 	mcall	80005468 <prvUnlockQueue+0x94>
80005440:	c0 30       	breq	80005446 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005442:	f0 1f 00 0b 	mcall	8000546c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005446:	6f 18       	ld.w	r8,r7[0x44]
80005448:	20 18       	sub	r8,1
8000544a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000544e:	58 08       	cp.w	r8,0
80005450:	fe 99 ff f2 	brgt	80005434 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005454:	3f f8       	mov	r8,-1
80005456:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000545a:	f0 1f 00 06 	mcall	80005470 <prvUnlockQueue+0x9c>
}
8000545e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005462:	00 00       	add	r0,r0
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	50 c0       	stdsp	sp[0x30],r0
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	59 e4       	cp.w	r4,30
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	58 f0       	cp.w	r0,15
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	51 cc       	stdsp	sp[0x70],r12

80005474 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005474:	d4 31       	pushm	r0-r7,lr
80005476:	20 5d       	sub	sp,20
80005478:	18 97       	mov	r7,r12
8000547a:	50 0b       	stdsp	sp[0x0],r11
8000547c:	50 2a       	stdsp	sp[0x8],r10
8000547e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005480:	f8 c2 ff dc 	sub	r2,r12,-36
80005484:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005486:	fa c4 ff f4 	sub	r4,sp,-12
8000548a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000548c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000548e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80005492:	f0 1f 00 3e 	mcall	80005588 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005496:	6e e8       	ld.w	r8,r7[0x38]
80005498:	58 08       	cp.w	r8,0
8000549a:	c2 a0       	breq	800054ee <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000549c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000549e:	40 0b       	lddsp	r11,sp[0x0]
800054a0:	0e 9c       	mov	r12,r7
800054a2:	f0 1f 00 3b 	mcall	8000558c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800054a6:	40 18       	lddsp	r8,sp[0x4]
800054a8:	58 08       	cp.w	r8,0
800054aa:	c1 51       	brne	800054d4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800054ac:	6e e8       	ld.w	r8,r7[0x38]
800054ae:	20 18       	sub	r8,1
800054b0:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800054b2:	6e 08       	ld.w	r8,r7[0x0]
800054b4:	58 08       	cp.w	r8,0
800054b6:	c0 41       	brne	800054be <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800054b8:	f0 1f 00 36 	mcall	80005590 <xQueueGenericReceive+0x11c>
800054bc:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800054be:	6e 48       	ld.w	r8,r7[0x10]
800054c0:	58 08       	cp.w	r8,0
800054c2:	c1 20       	breq	800054e6 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800054c4:	ee cc ff f0 	sub	r12,r7,-16
800054c8:	f0 1f 00 33 	mcall	80005594 <xQueueGenericReceive+0x120>
800054cc:	58 1c       	cp.w	r12,1
800054ce:	c0 c1       	brne	800054e6 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800054d0:	d7 33       	scall
800054d2:	c0 a8       	rjmp	800054e6 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800054d4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800054d6:	6e 98       	ld.w	r8,r7[0x24]
800054d8:	58 08       	cp.w	r8,0
800054da:	c0 60       	breq	800054e6 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800054dc:	04 9c       	mov	r12,r2
800054de:	f0 1f 00 2e 	mcall	80005594 <xQueueGenericReceive+0x120>
800054e2:	c0 20       	breq	800054e6 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
800054e4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
800054e6:	f0 1f 00 2d 	mcall	80005598 <xQueueGenericReceive+0x124>
800054ea:	30 1c       	mov	r12,1
				return pdPASS;
800054ec:	c4 c8       	rjmp	80005584 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800054ee:	40 28       	lddsp	r8,sp[0x8]
800054f0:	58 08       	cp.w	r8,0
800054f2:	c0 51       	brne	800054fc <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800054f4:	f0 1f 00 29 	mcall	80005598 <xQueueGenericReceive+0x124>
800054f8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
800054fa:	c4 58       	rjmp	80005584 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
800054fc:	58 05       	cp.w	r5,0
800054fe:	c0 51       	brne	80005508 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005500:	08 9c       	mov	r12,r4
80005502:	f0 1f 00 27 	mcall	8000559c <xQueueGenericReceive+0x128>
80005506:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005508:	f0 1f 00 24 	mcall	80005598 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000550c:	f0 1f 00 25 	mcall	800055a0 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005510:	f0 1f 00 1e 	mcall	80005588 <xQueueGenericReceive+0x114>
80005514:	6f 18       	ld.w	r8,r7[0x44]
80005516:	5b f8       	cp.w	r8,-1
80005518:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000551c:	6f 28       	ld.w	r8,r7[0x48]
8000551e:	5b f8       	cp.w	r8,-1
80005520:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005524:	f0 1f 00 1d 	mcall	80005598 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005528:	06 9b       	mov	r11,r3
8000552a:	08 9c       	mov	r12,r4
8000552c:	f0 1f 00 1e 	mcall	800055a4 <xQueueGenericReceive+0x130>
80005530:	c2 41       	brne	80005578 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005532:	f0 1f 00 16 	mcall	80005588 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005536:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005538:	f0 1f 00 18 	mcall	80005598 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000553c:	58 06       	cp.w	r6,0
8000553e:	c1 71       	brne	8000556c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005540:	6e 08       	ld.w	r8,r7[0x0]
80005542:	58 08       	cp.w	r8,0
80005544:	c0 81       	brne	80005554 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005546:	f0 1f 00 11 	mcall	80005588 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000554a:	6e 1c       	ld.w	r12,r7[0x4]
8000554c:	f0 1f 00 17 	mcall	800055a8 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005550:	f0 1f 00 12 	mcall	80005598 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005554:	40 2b       	lddsp	r11,sp[0x8]
80005556:	04 9c       	mov	r12,r2
80005558:	f0 1f 00 15 	mcall	800055ac <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000555c:	0e 9c       	mov	r12,r7
8000555e:	f0 1f 00 15 	mcall	800055b0 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005562:	f0 1f 00 15 	mcall	800055b4 <xQueueGenericReceive+0x140>
80005566:	c9 61       	brne	80005492 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005568:	d7 33       	scall
8000556a:	c9 4b       	rjmp	80005492 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000556c:	0e 9c       	mov	r12,r7
8000556e:	f0 1f 00 11 	mcall	800055b0 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005572:	f0 1f 00 11 	mcall	800055b4 <xQueueGenericReceive+0x140>
80005576:	c8 eb       	rjmp	80005492 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005578:	0e 9c       	mov	r12,r7
8000557a:	f0 1f 00 0e 	mcall	800055b0 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000557e:	f0 1f 00 0e 	mcall	800055b4 <xQueueGenericReceive+0x140>
80005582:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005584:	2f bd       	sub	sp,-20
80005586:	d8 32       	popm	r0-r7,pc
80005588:	80 00       	ld.sh	r0,r0[0x0]
8000558a:	50 c0       	stdsp	sp[0x30],r0
8000558c:	80 00       	ld.sh	r0,r0[0x0]
8000558e:	53 54       	stdsp	sp[0xd4],r4
80005590:	80 00       	ld.sh	r0,r0[0x0]
80005592:	58 fc       	cp.w	r12,15
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	59 e4       	cp.w	r4,30
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	51 cc       	stdsp	sp[0x70],r12
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	58 d8       	cp.w	r8,13
800055a0:	80 00       	ld.sh	r0,r0[0x0]
800055a2:	58 4c       	cp.w	r12,4
800055a4:	80 00       	ld.sh	r0,r0[0x0]
800055a6:	5b 74       	cp.w	r4,-9
800055a8:	80 00       	ld.sh	r0,r0[0x0]
800055aa:	59 60       	cp.w	r0,22
800055ac:	80 00       	ld.sh	r0,r0[0x0]
800055ae:	5d cc       	*unknown*
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	53 d4       	stdsp	sp[0xf4],r4
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	5c 08       	acr	r8

800055b8 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800055b8:	eb cd 40 80 	pushm	r7,lr
800055bc:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800055be:	79 08       	ld.w	r8,r12[0x40]
800055c0:	58 08       	cp.w	r8,0
800055c2:	c0 a1       	brne	800055d6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800055c4:	78 08       	ld.w	r8,r12[0x0]
800055c6:	58 08       	cp.w	r8,0
800055c8:	c2 b1       	brne	8000561e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800055ca:	78 1c       	ld.w	r12,r12[0x4]
800055cc:	f0 1f 00 17 	mcall	80005628 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800055d0:	30 08       	mov	r8,0
800055d2:	8f 18       	st.w	r7[0x4],r8
800055d4:	c2 58       	rjmp	8000561e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800055d6:	58 0a       	cp.w	r10,0
800055d8:	c1 01       	brne	800055f8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800055da:	10 9a       	mov	r10,r8
800055dc:	78 2c       	ld.w	r12,r12[0x8]
800055de:	f0 1f 00 14 	mcall	8000562c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800055e2:	6e 29       	ld.w	r9,r7[0x8]
800055e4:	6f 08       	ld.w	r8,r7[0x40]
800055e6:	f2 08 00 08 	add	r8,r9,r8
800055ea:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800055ec:	6e 19       	ld.w	r9,r7[0x4]
800055ee:	12 38       	cp.w	r8,r9
800055f0:	c1 73       	brcs	8000561e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800055f2:	6e 08       	ld.w	r8,r7[0x0]
800055f4:	8f 28       	st.w	r7[0x8],r8
800055f6:	c1 48       	rjmp	8000561e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800055f8:	10 9a       	mov	r10,r8
800055fa:	78 3c       	ld.w	r12,r12[0xc]
800055fc:	f0 1f 00 0c 	mcall	8000562c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005600:	6f 08       	ld.w	r8,r7[0x40]
80005602:	6e 39       	ld.w	r9,r7[0xc]
80005604:	f2 08 01 08 	sub	r8,r9,r8
80005608:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000560a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000560c:	12 38       	cp.w	r8,r9
8000560e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005612:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005616:	f3 d8 e3 19 	subcs	r9,r9,r8
8000561a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000561e:	6e e8       	ld.w	r8,r7[0x38]
80005620:	2f f8       	sub	r8,-1
80005622:	8f e8       	st.w	r7[0x38],r8
}
80005624:	e3 cd 80 80 	ldm	sp++,r7,pc
80005628:	80 00       	ld.sh	r0,r0[0x0]
8000562a:	59 08       	cp.w	r8,16
8000562c:	80 00       	ld.sh	r0,r0[0x0]
8000562e:	6b d0       	ld.w	r0,r5[0x74]

80005630 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005630:	eb cd 40 c0 	pushm	r6-r7,lr
80005634:	18 97       	mov	r7,r12
80005636:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005638:	78 ec       	ld.w	r12,r12[0x38]
8000563a:	6e f8       	ld.w	r8,r7[0x3c]
8000563c:	10 3c       	cp.w	r12,r8
8000563e:	c0 33       	brcs	80005644 <xQueueGenericSendFromISR+0x14>
80005640:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005644:	12 9a       	mov	r10,r9
80005646:	0e 9c       	mov	r12,r7
80005648:	f0 1f 00 0c 	mcall	80005678 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000564c:	6f 28       	ld.w	r8,r7[0x48]
8000564e:	5b f8       	cp.w	r8,-1
80005650:	c0 d1       	brne	8000566a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005652:	6e 98       	ld.w	r8,r7[0x24]
80005654:	58 08       	cp.w	r8,0
80005656:	c0 f0       	breq	80005674 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005658:	ee cc ff dc 	sub	r12,r7,-36
8000565c:	f0 1f 00 08 	mcall	8000567c <xQueueGenericSendFromISR+0x4c>
80005660:	c0 a0       	breq	80005674 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005662:	30 1c       	mov	r12,1
80005664:	8d 0c       	st.w	r6[0x0],r12
80005666:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000566a:	2f f8       	sub	r8,-1
8000566c:	ef 48 00 48 	st.w	r7[72],r8
80005670:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005674:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005678:	80 00       	ld.sh	r0,r0[0x0]
8000567a:	55 b8       	stdsp	sp[0x16c],r8
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	59 e4       	cp.w	r4,30

80005680 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005680:	d4 31       	pushm	r0-r7,lr
80005682:	20 5d       	sub	sp,20
80005684:	18 97       	mov	r7,r12
80005686:	50 0b       	stdsp	sp[0x0],r11
80005688:	50 2a       	stdsp	sp[0x8],r10
8000568a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000568c:	f8 c0 ff f0 	sub	r0,r12,-16
80005690:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005692:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005696:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005698:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000569c:	f0 1f 00 2f 	mcall	80005758 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800056a0:	6e e9       	ld.w	r9,r7[0x38]
800056a2:	6e f8       	ld.w	r8,r7[0x3c]
800056a4:	10 39       	cp.w	r9,r8
800056a6:	c1 42       	brcc	800056ce <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800056a8:	40 1a       	lddsp	r10,sp[0x4]
800056aa:	40 0b       	lddsp	r11,sp[0x0]
800056ac:	0e 9c       	mov	r12,r7
800056ae:	f0 1f 00 2c 	mcall	8000575c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800056b2:	6e 98       	ld.w	r8,r7[0x24]
800056b4:	58 08       	cp.w	r8,0
800056b6:	c0 80       	breq	800056c6 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800056b8:	ee cc ff dc 	sub	r12,r7,-36
800056bc:	f0 1f 00 29 	mcall	80005760 <xQueueGenericSend+0xe0>
800056c0:	58 1c       	cp.w	r12,1
800056c2:	c0 21       	brne	800056c6 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800056c4:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800056c6:	f0 1f 00 28 	mcall	80005764 <xQueueGenericSend+0xe4>
800056ca:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800056cc:	c4 38       	rjmp	80005752 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800056ce:	40 28       	lddsp	r8,sp[0x8]
800056d0:	58 08       	cp.w	r8,0
800056d2:	c0 51       	brne	800056dc <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800056d4:	f0 1f 00 24 	mcall	80005764 <xQueueGenericSend+0xe4>
800056d8:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800056da:	c3 c8       	rjmp	80005752 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800056dc:	58 04       	cp.w	r4,0
800056de:	c0 51       	brne	800056e8 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800056e0:	06 9c       	mov	r12,r3
800056e2:	f0 1f 00 22 	mcall	80005768 <xQueueGenericSend+0xe8>
800056e6:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800056e8:	f0 1f 00 1f 	mcall	80005764 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800056ec:	f0 1f 00 20 	mcall	8000576c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800056f0:	f0 1f 00 1a 	mcall	80005758 <xQueueGenericSend+0xd8>
800056f4:	6f 18       	ld.w	r8,r7[0x44]
800056f6:	5b f8       	cp.w	r8,-1
800056f8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800056fc:	6f 28       	ld.w	r8,r7[0x48]
800056fe:	5b f8       	cp.w	r8,-1
80005700:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005704:	f0 1f 00 18 	mcall	80005764 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005708:	04 9b       	mov	r11,r2
8000570a:	06 9c       	mov	r12,r3
8000570c:	f0 1f 00 19 	mcall	80005770 <xQueueGenericSend+0xf0>
80005710:	c1 b1       	brne	80005746 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005712:	f0 1f 00 12 	mcall	80005758 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005716:	6e e5       	ld.w	r5,r7[0x38]
80005718:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000571a:	f0 1f 00 13 	mcall	80005764 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000571e:	0c 35       	cp.w	r5,r6
80005720:	c0 d1       	brne	8000573a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005722:	40 2b       	lddsp	r11,sp[0x8]
80005724:	00 9c       	mov	r12,r0
80005726:	f0 1f 00 14 	mcall	80005774 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000572a:	0e 9c       	mov	r12,r7
8000572c:	f0 1f 00 13 	mcall	80005778 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005730:	f0 1f 00 13 	mcall	8000577c <xQueueGenericSend+0xfc>
80005734:	cb 41       	brne	8000569c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005736:	d7 33       	scall
80005738:	cb 2b       	rjmp	8000569c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000573a:	0e 9c       	mov	r12,r7
8000573c:	f0 1f 00 0f 	mcall	80005778 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005740:	f0 1f 00 0f 	mcall	8000577c <xQueueGenericSend+0xfc>
80005744:	ca cb       	rjmp	8000569c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005746:	0e 9c       	mov	r12,r7
80005748:	f0 1f 00 0c 	mcall	80005778 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000574c:	f0 1f 00 0c 	mcall	8000577c <xQueueGenericSend+0xfc>
80005750:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005752:	2f bd       	sub	sp,-20
80005754:	d8 32       	popm	r0-r7,pc
80005756:	00 00       	add	r0,r0
80005758:	80 00       	ld.sh	r0,r0[0x0]
8000575a:	50 c0       	stdsp	sp[0x30],r0
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	55 b8       	stdsp	sp[0x16c],r8
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	59 e4       	cp.w	r4,30
80005764:	80 00       	ld.sh	r0,r0[0x0]
80005766:	51 cc       	stdsp	sp[0x70],r12
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	58 d8       	cp.w	r8,13
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	58 4c       	cp.w	r12,4
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	5b 74       	cp.w	r4,-9
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	5d cc       	*unknown*
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	53 d4       	stdsp	sp[0xf4],r4
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	5c 08       	acr	r8

80005780 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005780:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005784:	34 cc       	mov	r12,76
80005786:	f0 1f 00 12 	mcall	800057cc <xQueueCreateMutex+0x4c>
8000578a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000578c:	c1 d0       	breq	800057c6 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000578e:	30 06       	mov	r6,0
80005790:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005792:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005794:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80005796:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005798:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000579a:	30 18       	mov	r8,1
8000579c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000579e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800057a2:	3f f8       	mov	r8,-1
800057a4:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800057a8:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800057ac:	2f 0c       	sub	r12,-16
800057ae:	f0 1f 00 09 	mcall	800057d0 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800057b2:	ee cc ff dc 	sub	r12,r7,-36
800057b6:	f0 1f 00 07 	mcall	800057d0 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800057ba:	0c 99       	mov	r9,r6
800057bc:	0c 9a       	mov	r10,r6
800057be:	0c 9b       	mov	r11,r6
800057c0:	0e 9c       	mov	r12,r7
800057c2:	f0 1f 00 05 	mcall	800057d4 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800057c6:	0e 9c       	mov	r12,r7
800057c8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	53 2c       	stdsp	sp[0xc8],r12
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	4f 9c       	lddpc	r12,800059b4 <vTaskPriorityInherit+0x54>
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	56 80       	stdsp	sp[0x1a0],r0

800057d8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800057d8:	d4 21       	pushm	r4-r7,lr
800057da:	18 97       	mov	r7,r12
800057dc:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800057de:	58 0c       	cp.w	r12,0
800057e0:	c2 f0       	breq	8000583e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800057e2:	34 cc       	mov	r12,76
800057e4:	f0 1f 00 17 	mcall	80005840 <xQueueCreate+0x68>
800057e8:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800057ea:	c2 a0       	breq	8000583e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800057ec:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800057f0:	e8 cc ff ff 	sub	r12,r4,-1
800057f4:	f0 1f 00 13 	mcall	80005840 <xQueueCreate+0x68>
800057f8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800057fa:	c1 e0       	breq	80005836 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800057fc:	f8 04 00 04 	add	r4,r12,r4
80005800:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005802:	30 08       	mov	r8,0
80005804:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005806:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005808:	ee c8 00 01 	sub	r8,r7,1
8000580c:	ad 38       	mul	r8,r6
8000580e:	10 0c       	add	r12,r8
80005810:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005812:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005814:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005818:	3f f8       	mov	r8,-1
8000581a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000581e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005822:	ea cc ff f0 	sub	r12,r5,-16
80005826:	f0 1f 00 08 	mcall	80005844 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000582a:	ea cc ff dc 	sub	r12,r5,-36
8000582e:	f0 1f 00 06 	mcall	80005844 <xQueueCreate+0x6c>
80005832:	0a 9c       	mov	r12,r5
80005834:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005836:	0a 9c       	mov	r12,r5
80005838:	f0 1f 00 04 	mcall	80005848 <xQueueCreate+0x70>
8000583c:	d8 2a       	popm	r4-r7,pc,r12=0
8000583e:	d8 2a       	popm	r4-r7,pc,r12=0
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	53 2c       	stdsp	sp[0xc8],r12
80005844:	80 00       	ld.sh	r0,r0[0x0]
80005846:	4f 9c       	lddpc	r12,80005a28 <xTaskRemoveFromEventList+0x44>
80005848:	80 00       	ld.sh	r0,r0[0x0]
8000584a:	53 04       	stdsp	sp[0xc0],r4

8000584c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000584c:	48 38       	lddpc	r8,80005858 <vTaskSuspendAll+0xc>
8000584e:	70 09       	ld.w	r9,r8[0x0]
80005850:	2f f9       	sub	r9,-1
80005852:	91 09       	st.w	r8[0x0],r9
}
80005854:	5e fc       	retal	r12
80005856:	00 00       	add	r0,r0
80005858:	00 00       	add	r0,r0
8000585a:	0d 20       	ld.uh	r0,r6++

8000585c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000585c:	49 a8       	lddpc	r8,800058c4 <vTaskSwitchContext+0x68>
8000585e:	70 08       	ld.w	r8,r8[0x0]
80005860:	58 08       	cp.w	r8,0
80005862:	c0 b1       	brne	80005878 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005864:	49 98       	lddpc	r8,800058c8 <vTaskSwitchContext+0x6c>
80005866:	70 08       	ld.w	r8,r8[0x0]
80005868:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000586c:	49 89       	lddpc	r9,800058cc <vTaskSwitchContext+0x70>
8000586e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005872:	58 08       	cp.w	r8,0
80005874:	c0 60       	breq	80005880 <vTaskSwitchContext+0x24>
80005876:	c1 18       	rjmp	80005898 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005878:	30 19       	mov	r9,1
8000587a:	49 68       	lddpc	r8,800058d0 <vTaskSwitchContext+0x74>
8000587c:	91 09       	st.w	r8[0x0],r9
8000587e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005880:	49 28       	lddpc	r8,800058c8 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005882:	49 3a       	lddpc	r10,800058cc <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005884:	70 09       	ld.w	r9,r8[0x0]
80005886:	20 19       	sub	r9,1
80005888:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000588a:	70 09       	ld.w	r9,r8[0x0]
8000588c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005890:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005894:	58 09       	cp.w	r9,0
80005896:	cf 70       	breq	80005884 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005898:	48 c8       	lddpc	r8,800058c8 <vTaskSwitchContext+0x6c>
8000589a:	70 08       	ld.w	r8,r8[0x0]
8000589c:	f0 08 00 28 	add	r8,r8,r8<<0x2
800058a0:	48 b9       	lddpc	r9,800058cc <vTaskSwitchContext+0x70>
800058a2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800058a6:	70 19       	ld.w	r9,r8[0x4]
800058a8:	72 19       	ld.w	r9,r9[0x4]
800058aa:	91 19       	st.w	r8[0x4],r9
800058ac:	f0 ca ff f8 	sub	r10,r8,-8
800058b0:	14 39       	cp.w	r9,r10
800058b2:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800058b6:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800058ba:	70 18       	ld.w	r8,r8[0x4]
800058bc:	70 39       	ld.w	r9,r8[0xc]
800058be:	48 68       	lddpc	r8,800058d4 <vTaskSwitchContext+0x78>
800058c0:	91 09       	st.w	r8[0x0],r9
800058c2:	5e fc       	retal	r12
800058c4:	00 00       	add	r0,r0
800058c6:	0d 20       	ld.uh	r0,r6++
800058c8:	00 00       	add	r0,r0
800058ca:	0d 58       	ld.sh	r8,--r6
800058cc:	00 00       	add	r0,r0
800058ce:	0c 3c       	cp.w	r12,r6
800058d0:	00 00       	add	r0,r0
800058d2:	0d 40       	ld.w	r0,--r6
800058d4:	00 00       	add	r0,r0
800058d6:	0c f0       	st.b	--r6,r0

800058d8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800058d8:	48 48       	lddpc	r8,800058e8 <vTaskSetTimeOutState+0x10>
800058da:	70 08       	ld.w	r8,r8[0x0]
800058dc:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800058de:	48 48       	lddpc	r8,800058ec <vTaskSetTimeOutState+0x14>
800058e0:	70 08       	ld.w	r8,r8[0x0]
800058e2:	99 18       	st.w	r12[0x4],r8
}
800058e4:	5e fc       	retal	r12
800058e6:	00 00       	add	r0,r0
800058e8:	00 00       	add	r0,r0
800058ea:	0c 34       	cp.w	r4,r6
800058ec:	00 00       	add	r0,r0
800058ee:	0d 1c       	ld.sh	r12,r6++

800058f0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800058f0:	30 19       	mov	r9,1
800058f2:	48 28       	lddpc	r8,800058f8 <vTaskMissedYield+0x8>
800058f4:	91 09       	st.w	r8[0x0],r9
}
800058f6:	5e fc       	retal	r12
800058f8:	00 00       	add	r0,r0
800058fa:	0d 40       	ld.w	r0,--r6

800058fc <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800058fc:	48 28       	lddpc	r8,80005904 <xTaskGetCurrentTaskHandle+0x8>
800058fe:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005900:	5e fc       	retal	r12
80005902:	00 00       	add	r0,r0
80005904:	00 00       	add	r0,r0
80005906:	0c f0       	st.b	--r6,r0

80005908 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005908:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000590c:	58 0c       	cp.w	r12,0
8000590e:	c1 f0       	breq	8000594c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005910:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005912:	78 b9       	ld.w	r9,r12[0x2c]
80005914:	79 18       	ld.w	r8,r12[0x44]
80005916:	10 39       	cp.w	r9,r8
80005918:	c1 a0       	breq	8000594c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000591a:	f8 c6 ff fc 	sub	r6,r12,-4
8000591e:	0c 9c       	mov	r12,r6
80005920:	f0 1f 00 0c 	mcall	80005950 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005924:	6f 1c       	ld.w	r12,r7[0x44]
80005926:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005928:	f8 08 11 08 	rsub	r8,r12,8
8000592c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000592e:	48 a8       	lddpc	r8,80005954 <vTaskPriorityDisinherit+0x4c>
80005930:	70 08       	ld.w	r8,r8[0x0]
80005932:	10 3c       	cp.w	r12,r8
80005934:	e0 88 00 04 	brls	8000593c <vTaskPriorityDisinherit+0x34>
80005938:	48 78       	lddpc	r8,80005954 <vTaskPriorityDisinherit+0x4c>
8000593a:	91 0c       	st.w	r8[0x0],r12
8000593c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005940:	0c 9b       	mov	r11,r6
80005942:	48 68       	lddpc	r8,80005958 <vTaskPriorityDisinherit+0x50>
80005944:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005948:	f0 1f 00 05 	mcall	8000595c <vTaskPriorityDisinherit+0x54>
8000594c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005950:	80 00       	ld.sh	r0,r0[0x0]
80005952:	50 06       	stdsp	sp[0x0],r6
80005954:	00 00       	add	r0,r0
80005956:	0d 58       	ld.sh	r8,--r6
80005958:	00 00       	add	r0,r0
8000595a:	0c 3c       	cp.w	r12,r6
8000595c:	80 00       	ld.sh	r0,r0[0x0]
8000595e:	4f b6       	lddpc	r6,80005b48 <vTaskIncrementTick+0xe8>

80005960 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005960:	eb cd 40 c0 	pushm	r6-r7,lr
80005964:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005966:	49 b8       	lddpc	r8,800059d0 <vTaskPriorityInherit+0x70>
80005968:	70 08       	ld.w	r8,r8[0x0]
8000596a:	78 b9       	ld.w	r9,r12[0x2c]
8000596c:	70 b8       	ld.w	r8,r8[0x2c]
8000596e:	10 39       	cp.w	r9,r8
80005970:	c2 d2       	brcc	800059ca <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005972:	49 88       	lddpc	r8,800059d0 <vTaskPriorityInherit+0x70>
80005974:	70 08       	ld.w	r8,r8[0x0]
80005976:	70 b8       	ld.w	r8,r8[0x2c]
80005978:	f0 08 11 08 	rsub	r8,r8,8
8000597c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000597e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005982:	49 59       	lddpc	r9,800059d4 <vTaskPriorityInherit+0x74>
80005984:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005988:	78 59       	ld.w	r9,r12[0x14]
8000598a:	10 39       	cp.w	r9,r8
8000598c:	c1 b1       	brne	800059c2 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000598e:	f8 c6 ff fc 	sub	r6,r12,-4
80005992:	0c 9c       	mov	r12,r6
80005994:	f0 1f 00 11 	mcall	800059d8 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005998:	48 e8       	lddpc	r8,800059d0 <vTaskPriorityInherit+0x70>
8000599a:	70 08       	ld.w	r8,r8[0x0]
8000599c:	70 bc       	ld.w	r12,r8[0x2c]
8000599e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800059a0:	48 f8       	lddpc	r8,800059dc <vTaskPriorityInherit+0x7c>
800059a2:	70 08       	ld.w	r8,r8[0x0]
800059a4:	10 3c       	cp.w	r12,r8
800059a6:	e0 88 00 04 	brls	800059ae <vTaskPriorityInherit+0x4e>
800059aa:	48 d8       	lddpc	r8,800059dc <vTaskPriorityInherit+0x7c>
800059ac:	91 0c       	st.w	r8[0x0],r12
800059ae:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800059b2:	0c 9b       	mov	r11,r6
800059b4:	48 88       	lddpc	r8,800059d4 <vTaskPriorityInherit+0x74>
800059b6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800059ba:	f0 1f 00 0a 	mcall	800059e0 <vTaskPriorityInherit+0x80>
800059be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800059c2:	48 48       	lddpc	r8,800059d0 <vTaskPriorityInherit+0x70>
800059c4:	70 08       	ld.w	r8,r8[0x0]
800059c6:	70 b8       	ld.w	r8,r8[0x2c]
800059c8:	99 b8       	st.w	r12[0x2c],r8
800059ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059ce:	00 00       	add	r0,r0
800059d0:	00 00       	add	r0,r0
800059d2:	0c f0       	st.b	--r6,r0
800059d4:	00 00       	add	r0,r0
800059d6:	0c 3c       	cp.w	r12,r6
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	50 06       	stdsp	sp[0x0],r6
800059dc:	00 00       	add	r0,r0
800059de:	0d 58       	ld.sh	r8,--r6
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	4f b6       	lddpc	r6,80005bcc <xTaskCheckForTimeOut+0x58>

800059e4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800059e4:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800059e8:	78 38       	ld.w	r8,r12[0xc]
800059ea:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800059ec:	ee c6 ff e8 	sub	r6,r7,-24
800059f0:	0c 9c       	mov	r12,r6
800059f2:	f0 1f 00 15 	mcall	80005a44 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800059f6:	49 58       	lddpc	r8,80005a48 <xTaskRemoveFromEventList+0x64>
800059f8:	70 08       	ld.w	r8,r8[0x0]
800059fa:	58 08       	cp.w	r8,0
800059fc:	c1 71       	brne	80005a2a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800059fe:	ee c6 ff fc 	sub	r6,r7,-4
80005a02:	0c 9c       	mov	r12,r6
80005a04:	f0 1f 00 10 	mcall	80005a44 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005a08:	6e bc       	ld.w	r12,r7[0x2c]
80005a0a:	49 18       	lddpc	r8,80005a4c <xTaskRemoveFromEventList+0x68>
80005a0c:	70 08       	ld.w	r8,r8[0x0]
80005a0e:	10 3c       	cp.w	r12,r8
80005a10:	e0 88 00 04 	brls	80005a18 <xTaskRemoveFromEventList+0x34>
80005a14:	48 e8       	lddpc	r8,80005a4c <xTaskRemoveFromEventList+0x68>
80005a16:	91 0c       	st.w	r8[0x0],r12
80005a18:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a1c:	0c 9b       	mov	r11,r6
80005a1e:	48 d8       	lddpc	r8,80005a50 <xTaskRemoveFromEventList+0x6c>
80005a20:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005a24:	f0 1f 00 0c 	mcall	80005a54 <xTaskRemoveFromEventList+0x70>
80005a28:	c0 58       	rjmp	80005a32 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005a2a:	0c 9b       	mov	r11,r6
80005a2c:	48 bc       	lddpc	r12,80005a58 <xTaskRemoveFromEventList+0x74>
80005a2e:	f0 1f 00 0a 	mcall	80005a54 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005a32:	48 b8       	lddpc	r8,80005a5c <xTaskRemoveFromEventList+0x78>
80005a34:	70 08       	ld.w	r8,r8[0x0]
80005a36:	6e b9       	ld.w	r9,r7[0x2c]
80005a38:	70 b8       	ld.w	r8,r8[0x2c]
80005a3a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005a3c:	5f 2c       	srhs	r12
80005a3e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a42:	00 00       	add	r0,r0
80005a44:	80 00       	ld.sh	r0,r0[0x0]
80005a46:	50 06       	stdsp	sp[0x0],r6
80005a48:	00 00       	add	r0,r0
80005a4a:	0d 20       	ld.uh	r0,r6++
80005a4c:	00 00       	add	r0,r0
80005a4e:	0d 58       	ld.sh	r8,--r6
80005a50:	00 00       	add	r0,r0
80005a52:	0c 3c       	cp.w	r12,r6
80005a54:	80 00       	ld.sh	r0,r0[0x0]
80005a56:	4f b6       	lddpc	r6,80005c40 <xTaskResumeAll+0x38>
80005a58:	00 00       	add	r0,r0
80005a5a:	0c f4       	st.b	--r6,r4
80005a5c:	00 00       	add	r0,r0
80005a5e:	0c f0       	st.b	--r6,r0

80005a60 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005a60:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a64:	4b 98       	lddpc	r8,80005b48 <vTaskIncrementTick+0xe8>
80005a66:	70 08       	ld.w	r8,r8[0x0]
80005a68:	58 08       	cp.w	r8,0
80005a6a:	c6 91       	brne	80005b3c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005a6c:	4b 88       	lddpc	r8,80005b4c <vTaskIncrementTick+0xec>
80005a6e:	70 09       	ld.w	r9,r8[0x0]
80005a70:	2f f9       	sub	r9,-1
80005a72:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005a74:	70 08       	ld.w	r8,r8[0x0]
80005a76:	58 08       	cp.w	r8,0
80005a78:	c1 a1       	brne	80005aac <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005a7a:	4b 68       	lddpc	r8,80005b50 <vTaskIncrementTick+0xf0>
80005a7c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005a7e:	4b 69       	lddpc	r9,80005b54 <vTaskIncrementTick+0xf4>
80005a80:	72 0b       	ld.w	r11,r9[0x0]
80005a82:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005a84:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005a86:	4b 59       	lddpc	r9,80005b58 <vTaskIncrementTick+0xf8>
80005a88:	72 0a       	ld.w	r10,r9[0x0]
80005a8a:	2f fa       	sub	r10,-1
80005a8c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005a8e:	70 08       	ld.w	r8,r8[0x0]
80005a90:	70 08       	ld.w	r8,r8[0x0]
80005a92:	58 08       	cp.w	r8,0
80005a94:	c0 51       	brne	80005a9e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005a96:	3f f9       	mov	r9,-1
80005a98:	4b 18       	lddpc	r8,80005b5c <vTaskIncrementTick+0xfc>
80005a9a:	91 09       	st.w	r8[0x0],r9
80005a9c:	c0 88       	rjmp	80005aac <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005a9e:	4a d8       	lddpc	r8,80005b50 <vTaskIncrementTick+0xf0>
80005aa0:	70 08       	ld.w	r8,r8[0x0]
80005aa2:	70 38       	ld.w	r8,r8[0xc]
80005aa4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005aa6:	70 19       	ld.w	r9,r8[0x4]
80005aa8:	4a d8       	lddpc	r8,80005b5c <vTaskIncrementTick+0xfc>
80005aaa:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005aac:	4a 88       	lddpc	r8,80005b4c <vTaskIncrementTick+0xec>
80005aae:	70 09       	ld.w	r9,r8[0x0]
80005ab0:	4a b8       	lddpc	r8,80005b5c <vTaskIncrementTick+0xfc>
80005ab2:	70 08       	ld.w	r8,r8[0x0]
80005ab4:	10 39       	cp.w	r9,r8
80005ab6:	c4 73       	brcs	80005b44 <vTaskIncrementTick+0xe4>
80005ab8:	4a 68       	lddpc	r8,80005b50 <vTaskIncrementTick+0xf0>
80005aba:	70 08       	ld.w	r8,r8[0x0]
80005abc:	70 08       	ld.w	r8,r8[0x0]
80005abe:	58 08       	cp.w	r8,0
80005ac0:	c0 c0       	breq	80005ad8 <vTaskIncrementTick+0x78>
80005ac2:	4a 48       	lddpc	r8,80005b50 <vTaskIncrementTick+0xf0>
80005ac4:	70 08       	ld.w	r8,r8[0x0]
80005ac6:	70 38       	ld.w	r8,r8[0xc]
80005ac8:	70 37       	ld.w	r7,r8[0xc]
80005aca:	6e 18       	ld.w	r8,r7[0x4]
80005acc:	4a 09       	lddpc	r9,80005b4c <vTaskIncrementTick+0xec>
80005ace:	72 09       	ld.w	r9,r9[0x0]
80005ad0:	12 38       	cp.w	r8,r9
80005ad2:	e0 88 00 14 	brls	80005afa <vTaskIncrementTick+0x9a>
80005ad6:	c0 e8       	rjmp	80005af2 <vTaskIncrementTick+0x92>
80005ad8:	3f f9       	mov	r9,-1
80005ada:	4a 18       	lddpc	r8,80005b5c <vTaskIncrementTick+0xfc>
80005adc:	91 09       	st.w	r8[0x0],r9
80005ade:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005ae2:	6a 08       	ld.w	r8,r5[0x0]
80005ae4:	70 38       	ld.w	r8,r8[0xc]
80005ae6:	70 37       	ld.w	r7,r8[0xc]
80005ae8:	6e 18       	ld.w	r8,r7[0x4]
80005aea:	64 09       	ld.w	r9,r2[0x0]
80005aec:	12 38       	cp.w	r8,r9
80005aee:	e0 88 00 0a 	brls	80005b02 <vTaskIncrementTick+0xa2>
80005af2:	49 b9       	lddpc	r9,80005b5c <vTaskIncrementTick+0xfc>
80005af4:	93 08       	st.w	r9[0x0],r8
80005af6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005afa:	49 a4       	lddpc	r4,80005b60 <vTaskIncrementTick+0x100>
80005afc:	49 a3       	lddpc	r3,80005b64 <vTaskIncrementTick+0x104>
80005afe:	49 55       	lddpc	r5,80005b50 <vTaskIncrementTick+0xf0>
80005b00:	49 32       	lddpc	r2,80005b4c <vTaskIncrementTick+0xec>
80005b02:	ee c6 ff fc 	sub	r6,r7,-4
80005b06:	0c 9c       	mov	r12,r6
80005b08:	f0 1f 00 18 	mcall	80005b68 <vTaskIncrementTick+0x108>
80005b0c:	6e a8       	ld.w	r8,r7[0x28]
80005b0e:	58 08       	cp.w	r8,0
80005b10:	c0 50       	breq	80005b1a <vTaskIncrementTick+0xba>
80005b12:	ee cc ff e8 	sub	r12,r7,-24
80005b16:	f0 1f 00 15 	mcall	80005b68 <vTaskIncrementTick+0x108>
80005b1a:	6e bc       	ld.w	r12,r7[0x2c]
80005b1c:	68 08       	ld.w	r8,r4[0x0]
80005b1e:	10 3c       	cp.w	r12,r8
80005b20:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005b24:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005b28:	0c 9b       	mov	r11,r6
80005b2a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005b2e:	f0 1f 00 10 	mcall	80005b6c <vTaskIncrementTick+0x10c>
80005b32:	6a 08       	ld.w	r8,r5[0x0]
80005b34:	70 08       	ld.w	r8,r8[0x0]
80005b36:	58 08       	cp.w	r8,0
80005b38:	cd 51       	brne	80005ae2 <vTaskIncrementTick+0x82>
80005b3a:	cc fb       	rjmp	80005ad8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005b3c:	48 d8       	lddpc	r8,80005b70 <vTaskIncrementTick+0x110>
80005b3e:	70 09       	ld.w	r9,r8[0x0]
80005b40:	2f f9       	sub	r9,-1
80005b42:	91 09       	st.w	r8[0x0],r9
80005b44:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005b48:	00 00       	add	r0,r0
80005b4a:	0d 20       	ld.uh	r0,r6++
80005b4c:	00 00       	add	r0,r0
80005b4e:	0d 1c       	ld.sh	r12,r6++
80005b50:	00 00       	add	r0,r0
80005b52:	0c 28       	rsub	r8,r6
80005b54:	00 00       	add	r0,r0
80005b56:	0c 38       	cp.w	r8,r6
80005b58:	00 00       	add	r0,r0
80005b5a:	0c 34       	cp.w	r4,r6
80005b5c:	00 00       	add	r0,r0
80005b5e:	05 2c       	ld.uh	r12,r2++
80005b60:	00 00       	add	r0,r0
80005b62:	0d 58       	ld.sh	r8,--r6
80005b64:	00 00       	add	r0,r0
80005b66:	0c 3c       	cp.w	r12,r6
80005b68:	80 00       	ld.sh	r0,r0[0x0]
80005b6a:	50 06       	stdsp	sp[0x0],r6
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	4f b6       	lddpc	r6,80005d58 <vTaskDelayUntil+0xc>
80005b70:	00 00       	add	r0,r0
80005b72:	0c 20       	rsub	r0,r6

80005b74 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005b74:	eb cd 40 c0 	pushm	r6-r7,lr
80005b78:	18 97       	mov	r7,r12
80005b7a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005b7c:	f0 1f 00 15 	mcall	80005bd0 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005b80:	6c 08       	ld.w	r8,r6[0x0]
80005b82:	5b f8       	cp.w	r8,-1
80005b84:	c0 31       	brne	80005b8a <xTaskCheckForTimeOut+0x16>
80005b86:	30 07       	mov	r7,0
80005b88:	c1 f8       	rjmp	80005bc6 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005b8a:	49 39       	lddpc	r9,80005bd4 <xTaskCheckForTimeOut+0x60>
80005b8c:	72 09       	ld.w	r9,r9[0x0]
80005b8e:	6e 0a       	ld.w	r10,r7[0x0]
80005b90:	12 3a       	cp.w	r10,r9
80005b92:	c0 70       	breq	80005ba0 <xTaskCheckForTimeOut+0x2c>
80005b94:	49 19       	lddpc	r9,80005bd8 <xTaskCheckForTimeOut+0x64>
80005b96:	72 09       	ld.w	r9,r9[0x0]
80005b98:	6e 1a       	ld.w	r10,r7[0x4]
80005b9a:	12 3a       	cp.w	r10,r9
80005b9c:	e0 88 00 14 	brls	80005bc4 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005ba0:	48 e9       	lddpc	r9,80005bd8 <xTaskCheckForTimeOut+0x64>
80005ba2:	72 0a       	ld.w	r10,r9[0x0]
80005ba4:	6e 19       	ld.w	r9,r7[0x4]
80005ba6:	12 1a       	sub	r10,r9
80005ba8:	14 38       	cp.w	r8,r10
80005baa:	e0 88 00 0d 	brls	80005bc4 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005bae:	48 ba       	lddpc	r10,80005bd8 <xTaskCheckForTimeOut+0x64>
80005bb0:	74 0a       	ld.w	r10,r10[0x0]
80005bb2:	14 19       	sub	r9,r10
80005bb4:	f2 08 00 08 	add	r8,r9,r8
80005bb8:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005bba:	0e 9c       	mov	r12,r7
80005bbc:	f0 1f 00 08 	mcall	80005bdc <xTaskCheckForTimeOut+0x68>
80005bc0:	30 07       	mov	r7,0
80005bc2:	c0 28       	rjmp	80005bc6 <xTaskCheckForTimeOut+0x52>
80005bc4:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005bc6:	f0 1f 00 07 	mcall	80005be0 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005bca:	0e 9c       	mov	r12,r7
80005bcc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bd0:	80 00       	ld.sh	r0,r0[0x0]
80005bd2:	50 c0       	stdsp	sp[0x30],r0
80005bd4:	00 00       	add	r0,r0
80005bd6:	0c 34       	cp.w	r4,r6
80005bd8:	00 00       	add	r0,r0
80005bda:	0d 1c       	ld.sh	r12,r6++
80005bdc:	80 00       	ld.sh	r0,r0[0x0]
80005bde:	58 d8       	cp.w	r8,13
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	51 cc       	stdsp	sp[0x70],r12

80005be4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005be4:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005be8:	f0 1f 00 05 	mcall	80005bfc <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005bec:	48 58       	lddpc	r8,80005c00 <xTaskGetTickCount+0x1c>
80005bee:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005bf0:	f0 1f 00 05 	mcall	80005c04 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005bf4:	0e 9c       	mov	r12,r7
80005bf6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bfa:	00 00       	add	r0,r0
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	50 c0       	stdsp	sp[0x30],r0
80005c00:	00 00       	add	r0,r0
80005c02:	0d 1c       	ld.sh	r12,r6++
80005c04:	80 00       	ld.sh	r0,r0[0x0]
80005c06:	51 cc       	stdsp	sp[0x70],r12

80005c08 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005c08:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005c0c:	f0 1f 00 2c 	mcall	80005cbc <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005c10:	4a c8       	lddpc	r8,80005cc0 <xTaskResumeAll+0xb8>
80005c12:	70 09       	ld.w	r9,r8[0x0]
80005c14:	20 19       	sub	r9,1
80005c16:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005c18:	70 08       	ld.w	r8,r8[0x0]
80005c1a:	58 08       	cp.w	r8,0
80005c1c:	c4 91       	brne	80005cae <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005c1e:	4a a8       	lddpc	r8,80005cc4 <xTaskResumeAll+0xbc>
80005c20:	70 08       	ld.w	r8,r8[0x0]
80005c22:	58 08       	cp.w	r8,0
80005c24:	c4 50       	breq	80005cae <xTaskResumeAll+0xa6>
80005c26:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005c28:	4a 85       	lddpc	r5,80005cc8 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005c2a:	4a 93       	lddpc	r3,80005ccc <xTaskResumeAll+0xc4>
80005c2c:	4a 92       	lddpc	r2,80005cd0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c2e:	4a a1       	lddpc	r1,80005cd4 <xTaskResumeAll+0xcc>
80005c30:	c1 e8       	rjmp	80005c6c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005c32:	6a 38       	ld.w	r8,r5[0xc]
80005c34:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005c36:	ee cc ff e8 	sub	r12,r7,-24
80005c3a:	f0 1f 00 28 	mcall	80005cd8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005c3e:	ee c6 ff fc 	sub	r6,r7,-4
80005c42:	0c 9c       	mov	r12,r6
80005c44:	f0 1f 00 25 	mcall	80005cd8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005c48:	6e bc       	ld.w	r12,r7[0x2c]
80005c4a:	66 08       	ld.w	r8,r3[0x0]
80005c4c:	10 3c       	cp.w	r12,r8
80005c4e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005c52:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005c56:	0c 9b       	mov	r11,r6
80005c58:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005c5c:	f0 1f 00 20 	mcall	80005cdc <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c60:	62 08       	ld.w	r8,r1[0x0]
80005c62:	6e b9       	ld.w	r9,r7[0x2c]
80005c64:	70 b8       	ld.w	r8,r8[0x2c]
80005c66:	10 39       	cp.w	r9,r8
80005c68:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005c6c:	6a 08       	ld.w	r8,r5[0x0]
80005c6e:	58 08       	cp.w	r8,0
80005c70:	ce 11       	brne	80005c32 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c72:	49 c8       	lddpc	r8,80005ce0 <xTaskResumeAll+0xd8>
80005c74:	70 08       	ld.w	r8,r8[0x0]
80005c76:	58 08       	cp.w	r8,0
80005c78:	c0 f0       	breq	80005c96 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c7a:	49 a8       	lddpc	r8,80005ce0 <xTaskResumeAll+0xd8>
80005c7c:	70 08       	ld.w	r8,r8[0x0]
80005c7e:	58 08       	cp.w	r8,0
80005c80:	c1 10       	breq	80005ca2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005c82:	49 87       	lddpc	r7,80005ce0 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005c84:	f0 1f 00 18 	mcall	80005ce4 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005c88:	6e 08       	ld.w	r8,r7[0x0]
80005c8a:	20 18       	sub	r8,1
80005c8c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c8e:	6e 08       	ld.w	r8,r7[0x0]
80005c90:	58 08       	cp.w	r8,0
80005c92:	cf 91       	brne	80005c84 <xTaskResumeAll+0x7c>
80005c94:	c0 78       	rjmp	80005ca2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005c96:	58 14       	cp.w	r4,1
80005c98:	c0 50       	breq	80005ca2 <xTaskResumeAll+0x9a>
80005c9a:	49 48       	lddpc	r8,80005ce8 <xTaskResumeAll+0xe0>
80005c9c:	70 08       	ld.w	r8,r8[0x0]
80005c9e:	58 18       	cp.w	r8,1
80005ca0:	c0 71       	brne	80005cae <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005ca2:	30 09       	mov	r9,0
80005ca4:	49 18       	lddpc	r8,80005ce8 <xTaskResumeAll+0xe0>
80005ca6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005ca8:	d7 33       	scall
80005caa:	30 17       	mov	r7,1
80005cac:	c0 28       	rjmp	80005cb0 <xTaskResumeAll+0xa8>
80005cae:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005cb0:	f0 1f 00 0f 	mcall	80005cec <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005cb4:	0e 9c       	mov	r12,r7
80005cb6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005cba:	00 00       	add	r0,r0
80005cbc:	80 00       	ld.sh	r0,r0[0x0]
80005cbe:	50 c0       	stdsp	sp[0x30],r0
80005cc0:	00 00       	add	r0,r0
80005cc2:	0d 20       	ld.uh	r0,r6++
80005cc4:	00 00       	add	r0,r0
80005cc6:	0d 3c       	ld.ub	r12,r6++
80005cc8:	00 00       	add	r0,r0
80005cca:	0c f4       	st.b	--r6,r4
80005ccc:	00 00       	add	r0,r0
80005cce:	0d 58       	ld.sh	r8,--r6
80005cd0:	00 00       	add	r0,r0
80005cd2:	0c 3c       	cp.w	r12,r6
80005cd4:	00 00       	add	r0,r0
80005cd6:	0c f0       	st.b	--r6,r0
80005cd8:	80 00       	ld.sh	r0,r0[0x0]
80005cda:	50 06       	stdsp	sp[0x0],r6
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	4f b6       	lddpc	r6,80005ec8 <xTaskGenericCreate+0x1c>
80005ce0:	00 00       	add	r0,r0
80005ce2:	0c 20       	rsub	r0,r6
80005ce4:	80 00       	ld.sh	r0,r0[0x0]
80005ce6:	5a 60       	cp.w	r0,-26
80005ce8:	00 00       	add	r0,r0
80005cea:	0d 40       	ld.w	r0,--r6
80005cec:	80 00       	ld.sh	r0,r0[0x0]
80005cee:	51 cc       	stdsp	sp[0x70],r12

80005cf0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005cf0:	eb cd 40 80 	pushm	r7,lr
80005cf4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005cf6:	49 08       	lddpc	r8,80005d34 <prvAddCurrentTaskToDelayedList+0x44>
80005cf8:	70 08       	ld.w	r8,r8[0x0]
80005cfa:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005cfc:	48 f8       	lddpc	r8,80005d38 <prvAddCurrentTaskToDelayedList+0x48>
80005cfe:	70 08       	ld.w	r8,r8[0x0]
80005d00:	10 3c       	cp.w	r12,r8
80005d02:	c0 a2       	brcc	80005d16 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d04:	48 c8       	lddpc	r8,80005d34 <prvAddCurrentTaskToDelayedList+0x44>
80005d06:	70 0b       	ld.w	r11,r8[0x0]
80005d08:	48 d8       	lddpc	r8,80005d3c <prvAddCurrentTaskToDelayedList+0x4c>
80005d0a:	70 0c       	ld.w	r12,r8[0x0]
80005d0c:	2f cb       	sub	r11,-4
80005d0e:	f0 1f 00 0d 	mcall	80005d40 <prvAddCurrentTaskToDelayedList+0x50>
80005d12:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d16:	48 88       	lddpc	r8,80005d34 <prvAddCurrentTaskToDelayedList+0x44>
80005d18:	70 0b       	ld.w	r11,r8[0x0]
80005d1a:	48 b8       	lddpc	r8,80005d44 <prvAddCurrentTaskToDelayedList+0x54>
80005d1c:	70 0c       	ld.w	r12,r8[0x0]
80005d1e:	2f cb       	sub	r11,-4
80005d20:	f0 1f 00 08 	mcall	80005d40 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005d24:	48 98       	lddpc	r8,80005d48 <prvAddCurrentTaskToDelayedList+0x58>
80005d26:	70 08       	ld.w	r8,r8[0x0]
80005d28:	10 37       	cp.w	r7,r8
80005d2a:	c0 32       	brcc	80005d30 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005d2c:	48 78       	lddpc	r8,80005d48 <prvAddCurrentTaskToDelayedList+0x58>
80005d2e:	91 07       	st.w	r8[0x0],r7
80005d30:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d34:	00 00       	add	r0,r0
80005d36:	0c f0       	st.b	--r6,r0
80005d38:	00 00       	add	r0,r0
80005d3a:	0d 1c       	ld.sh	r12,r6++
80005d3c:	00 00       	add	r0,r0
80005d3e:	0c 38       	cp.w	r8,r6
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	4f d2       	lddpc	r2,80005f34 <xTaskGenericCreate+0x88>
80005d44:	00 00       	add	r0,r0
80005d46:	0c 28       	rsub	r8,r6
80005d48:	00 00       	add	r0,r0
80005d4a:	05 2c       	ld.uh	r12,r2++

80005d4c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005d4c:	eb cd 40 c0 	pushm	r6-r7,lr
80005d50:	18 96       	mov	r6,r12
80005d52:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005d54:	f0 1f 00 18 	mcall	80005db4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005d58:	6c 08       	ld.w	r8,r6[0x0]
80005d5a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005d5c:	49 79       	lddpc	r9,80005db8 <vTaskDelayUntil+0x6c>
80005d5e:	72 09       	ld.w	r9,r9[0x0]
80005d60:	12 38       	cp.w	r8,r9
80005d62:	e0 88 00 0c 	brls	80005d7a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005d66:	0e 38       	cp.w	r8,r7
80005d68:	e0 88 00 22 	brls	80005dac <vTaskDelayUntil+0x60>
80005d6c:	49 38       	lddpc	r8,80005db8 <vTaskDelayUntil+0x6c>
80005d6e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005d70:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005d72:	10 37       	cp.w	r7,r8
80005d74:	e0 88 00 14 	brls	80005d9c <vTaskDelayUntil+0x50>
80005d78:	c0 a8       	rjmp	80005d8c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005d7a:	0e 38       	cp.w	r8,r7
80005d7c:	e0 8b 00 16 	brhi	80005da8 <vTaskDelayUntil+0x5c>
80005d80:	48 e8       	lddpc	r8,80005db8 <vTaskDelayUntil+0x6c>
80005d82:	70 08       	ld.w	r8,r8[0x0]
80005d84:	10 37       	cp.w	r7,r8
80005d86:	e0 8b 00 11 	brhi	80005da8 <vTaskDelayUntil+0x5c>
80005d8a:	c1 18       	rjmp	80005dac <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d8c:	48 c8       	lddpc	r8,80005dbc <vTaskDelayUntil+0x70>
80005d8e:	70 0c       	ld.w	r12,r8[0x0]
80005d90:	2f cc       	sub	r12,-4
80005d92:	f0 1f 00 0c 	mcall	80005dc0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005d96:	0e 9c       	mov	r12,r7
80005d98:	f0 1f 00 0b 	mcall	80005dc4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005d9c:	f0 1f 00 0b 	mcall	80005dc8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005da0:	c0 81       	brne	80005db0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005da2:	d7 33       	scall
80005da4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005da8:	8d 07       	st.w	r6[0x0],r7
80005daa:	cf 1b       	rjmp	80005d8c <vTaskDelayUntil+0x40>
80005dac:	8d 07       	st.w	r6[0x0],r7
80005dae:	cf 7b       	rjmp	80005d9c <vTaskDelayUntil+0x50>
80005db0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005db4:	80 00       	ld.sh	r0,r0[0x0]
80005db6:	58 4c       	cp.w	r12,4
80005db8:	00 00       	add	r0,r0
80005dba:	0d 1c       	ld.sh	r12,r6++
80005dbc:	00 00       	add	r0,r0
80005dbe:	0c f0       	st.b	--r6,r0
80005dc0:	80 00       	ld.sh	r0,r0[0x0]
80005dc2:	50 06       	stdsp	sp[0x0],r6
80005dc4:	80 00       	ld.sh	r0,r0[0x0]
80005dc6:	5c f0       	rol	r0
80005dc8:	80 00       	ld.sh	r0,r0[0x0]
80005dca:	5c 08       	acr	r8

80005dcc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005dcc:	eb cd 40 c0 	pushm	r6-r7,lr
80005dd0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005dd2:	48 e7       	lddpc	r7,80005e08 <vTaskPlaceOnEventList+0x3c>
80005dd4:	6e 0b       	ld.w	r11,r7[0x0]
80005dd6:	2e 8b       	sub	r11,-24
80005dd8:	f0 1f 00 0d 	mcall	80005e0c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ddc:	6e 0c       	ld.w	r12,r7[0x0]
80005dde:	2f cc       	sub	r12,-4
80005de0:	f0 1f 00 0c 	mcall	80005e10 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005de4:	5b f6       	cp.w	r6,-1
80005de6:	c0 81       	brne	80005df6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005de8:	6e 0b       	ld.w	r11,r7[0x0]
80005dea:	2f cb       	sub	r11,-4
80005dec:	48 ac       	lddpc	r12,80005e14 <vTaskPlaceOnEventList+0x48>
80005dee:	f0 1f 00 0b 	mcall	80005e18 <vTaskPlaceOnEventList+0x4c>
80005df2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005df6:	48 a8       	lddpc	r8,80005e1c <vTaskPlaceOnEventList+0x50>
80005df8:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005dfa:	ec 0c 00 0c 	add	r12,r6,r12
80005dfe:	f0 1f 00 09 	mcall	80005e20 <vTaskPlaceOnEventList+0x54>
80005e02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e06:	00 00       	add	r0,r0
80005e08:	00 00       	add	r0,r0
80005e0a:	0c f0       	st.b	--r6,r0
80005e0c:	80 00       	ld.sh	r0,r0[0x0]
80005e0e:	4f d2       	lddpc	r2,80006000 <xTaskGenericCreate+0x154>
80005e10:	80 00       	ld.sh	r0,r0[0x0]
80005e12:	50 06       	stdsp	sp[0x0],r6
80005e14:	00 00       	add	r0,r0
80005e16:	0d 44       	ld.w	r4,--r6
80005e18:	80 00       	ld.sh	r0,r0[0x0]
80005e1a:	4f b6       	lddpc	r6,80006004 <xTaskGenericCreate+0x158>
80005e1c:	00 00       	add	r0,r0
80005e1e:	0d 1c       	ld.sh	r12,r6++
80005e20:	80 00       	ld.sh	r0,r0[0x0]
80005e22:	5c f0       	rol	r0

80005e24 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005e24:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005e28:	49 67       	lddpc	r7,80005e80 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005e2a:	49 74       	lddpc	r4,80005e84 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005e2c:	49 73       	lddpc	r3,80005e88 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005e2e:	49 85       	lddpc	r5,80005e8c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005e30:	6e 08       	ld.w	r8,r7[0x0]
80005e32:	58 08       	cp.w	r8,0
80005e34:	c1 e0       	breq	80005e70 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005e36:	f0 1f 00 17 	mcall	80005e90 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005e3a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005e3c:	f0 1f 00 16 	mcall	80005e94 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005e40:	58 06       	cp.w	r6,0
80005e42:	c1 70       	breq	80005e70 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005e44:	f0 1f 00 15 	mcall	80005e98 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005e48:	68 38       	ld.w	r8,r4[0xc]
80005e4a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005e4c:	ec cc ff fc 	sub	r12,r6,-4
80005e50:	f0 1f 00 13 	mcall	80005e9c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005e54:	66 08       	ld.w	r8,r3[0x0]
80005e56:	20 18       	sub	r8,1
80005e58:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005e5a:	6e 08       	ld.w	r8,r7[0x0]
80005e5c:	20 18       	sub	r8,1
80005e5e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005e60:	f0 1f 00 10 	mcall	80005ea0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005e64:	6c cc       	ld.w	r12,r6[0x30]
80005e66:	f0 1f 00 10 	mcall	80005ea4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005e6a:	0c 9c       	mov	r12,r6
80005e6c:	f0 1f 00 0e 	mcall	80005ea4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005e70:	6a 08       	ld.w	r8,r5[0x0]
80005e72:	58 18       	cp.w	r8,1
80005e74:	e0 88 00 03 	brls	80005e7a <prvIdleTask+0x56>
			{
				taskYIELD();
80005e78:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005e7a:	f0 1f 00 0c 	mcall	80005ea8 <prvIdleTask+0x84>
		}
		#endif
	}
80005e7e:	cd 9b       	rjmp	80005e30 <prvIdleTask+0xc>
80005e80:	00 00       	add	r0,r0
80005e82:	0c 30       	cp.w	r0,r6
80005e84:	00 00       	add	r0,r0
80005e86:	0c dc       	st.w	--r6,r12
80005e88:	00 00       	add	r0,r0
80005e8a:	0d 3c       	ld.ub	r12,r6++
80005e8c:	00 00       	add	r0,r0
80005e8e:	0c 3c       	cp.w	r12,r6
80005e90:	80 00       	ld.sh	r0,r0[0x0]
80005e92:	58 4c       	cp.w	r12,4
80005e94:	80 00       	ld.sh	r0,r0[0x0]
80005e96:	5c 08       	acr	r8
80005e98:	80 00       	ld.sh	r0,r0[0x0]
80005e9a:	50 c0       	stdsp	sp[0x30],r0
80005e9c:	80 00       	ld.sh	r0,r0[0x0]
80005e9e:	50 06       	stdsp	sp[0x0],r6
80005ea0:	80 00       	ld.sh	r0,r0[0x0]
80005ea2:	51 cc       	stdsp	sp[0x70],r12
80005ea4:	80 00       	ld.sh	r0,r0[0x0]
80005ea6:	53 04       	stdsp	sp[0xc0],r4
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	20 30       	sub	r0,3

80005eac <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005eac:	d4 31       	pushm	r0-r7,lr
80005eae:	20 1d       	sub	sp,4
80005eb0:	fa c4 ff d8 	sub	r4,sp,-40
80005eb4:	50 0c       	stdsp	sp[0x0],r12
80005eb6:	16 91       	mov	r1,r11
80005eb8:	14 97       	mov	r7,r10
80005eba:	12 90       	mov	r0,r9
80005ebc:	10 93       	mov	r3,r8
80005ebe:	68 02       	ld.w	r2,r4[0x0]
80005ec0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005ec2:	34 8c       	mov	r12,72
80005ec4:	f0 1f 00 5c 	mcall	80006034 <xTaskGenericCreate+0x188>
80005ec8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005eca:	c0 31       	brne	80005ed0 <xTaskGenericCreate+0x24>
80005ecc:	3f fc       	mov	r12,-1
80005ece:	ca f8       	rjmp	8000602c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005ed0:	58 06       	cp.w	r6,0
80005ed2:	e0 81 00 af 	brne	80006030 <xTaskGenericCreate+0x184>
80005ed6:	0e 9c       	mov	r12,r7
80005ed8:	5c 7c       	castu.h	r12
80005eda:	a3 6c       	lsl	r12,0x2
80005edc:	f0 1f 00 56 	mcall	80006034 <xTaskGenericCreate+0x188>
80005ee0:	18 96       	mov	r6,r12
80005ee2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005ee4:	c0 61       	brne	80005ef0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005ee6:	0a 9c       	mov	r12,r5
80005ee8:	f0 1f 00 54 	mcall	80006038 <xTaskGenericCreate+0x18c>
80005eec:	3f fc       	mov	r12,-1
80005eee:	c9 f8       	rjmp	8000602c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005ef0:	5c 77       	castu.h	r7
80005ef2:	ee 0a 15 02 	lsl	r10,r7,0x2
80005ef6:	e0 6b 00 a5 	mov	r11,165
80005efa:	0c 9c       	mov	r12,r6
80005efc:	f0 1f 00 50 	mcall	8000603c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005f00:	ee c6 00 01 	sub	r6,r7,1
80005f04:	6a c8       	ld.w	r8,r5[0x30]
80005f06:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005f0a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005f0e:	31 0a       	mov	r10,16
80005f10:	02 9b       	mov	r11,r1
80005f12:	ea cc ff cc 	sub	r12,r5,-52
80005f16:	f0 1f 00 4b 	mcall	80006040 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005f1a:	30 08       	mov	r8,0
80005f1c:	eb 68 00 43 	st.b	r5[67],r8
80005f20:	58 73       	cp.w	r3,7
80005f22:	e6 07 17 80 	movls	r7,r3
80005f26:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005f2a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005f2c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005f30:	ea c4 ff fc 	sub	r4,r5,-4
80005f34:	08 9c       	mov	r12,r4
80005f36:	f0 1f 00 44 	mcall	80006044 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005f3a:	ea cc ff e8 	sub	r12,r5,-24
80005f3e:	f0 1f 00 42 	mcall	80006044 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005f42:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005f44:	ee 07 11 08 	rsub	r7,r7,8
80005f48:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005f4a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005f4c:	00 9a       	mov	r10,r0
80005f4e:	40 0b       	lddsp	r11,sp[0x0]
80005f50:	0c 9c       	mov	r12,r6
80005f52:	f0 1f 00 3e 	mcall	80006048 <xTaskGenericCreate+0x19c>
80005f56:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005f58:	58 02       	cp.w	r2,0
80005f5a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005f5e:	f0 1f 00 3c 	mcall	8000604c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005f62:	4b c8       	lddpc	r8,80006050 <xTaskGenericCreate+0x1a4>
80005f64:	70 09       	ld.w	r9,r8[0x0]
80005f66:	2f f9       	sub	r9,-1
80005f68:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005f6a:	4b b8       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a8>
80005f6c:	70 08       	ld.w	r8,r8[0x0]
80005f6e:	58 08       	cp.w	r8,0
80005f70:	c2 61       	brne	80005fbc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005f72:	4b 98       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a8>
80005f74:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005f76:	4b 78       	lddpc	r8,80006050 <xTaskGenericCreate+0x1a4>
80005f78:	70 08       	ld.w	r8,r8[0x0]
80005f7a:	58 18       	cp.w	r8,1
80005f7c:	c2 b1       	brne	80005fd2 <xTaskGenericCreate+0x126>
80005f7e:	4b 77       	lddpc	r7,80006058 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005f80:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005f84:	0e 9c       	mov	r12,r7
80005f86:	f0 1f 00 36 	mcall	8000605c <xTaskGenericCreate+0x1b0>
80005f8a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005f8c:	0c 37       	cp.w	r7,r6
80005f8e:	cf b1       	brne	80005f84 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005f90:	4b 47       	lddpc	r7,80006060 <xTaskGenericCreate+0x1b4>
80005f92:	0e 9c       	mov	r12,r7
80005f94:	f0 1f 00 32 	mcall	8000605c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005f98:	4b 36       	lddpc	r6,80006064 <xTaskGenericCreate+0x1b8>
80005f9a:	0c 9c       	mov	r12,r6
80005f9c:	f0 1f 00 30 	mcall	8000605c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005fa0:	4b 2c       	lddpc	r12,80006068 <xTaskGenericCreate+0x1bc>
80005fa2:	f0 1f 00 2f 	mcall	8000605c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005fa6:	4b 2c       	lddpc	r12,8000606c <xTaskGenericCreate+0x1c0>
80005fa8:	f0 1f 00 2d 	mcall	8000605c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005fac:	4b 1c       	lddpc	r12,80006070 <xTaskGenericCreate+0x1c4>
80005fae:	f0 1f 00 2c 	mcall	8000605c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005fb2:	4b 18       	lddpc	r8,80006074 <xTaskGenericCreate+0x1c8>
80005fb4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005fb6:	4b 18       	lddpc	r8,80006078 <xTaskGenericCreate+0x1cc>
80005fb8:	91 06       	st.w	r8[0x0],r6
80005fba:	c0 c8       	rjmp	80005fd2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005fbc:	4b 08       	lddpc	r8,8000607c <xTaskGenericCreate+0x1d0>
80005fbe:	70 08       	ld.w	r8,r8[0x0]
80005fc0:	58 08       	cp.w	r8,0
80005fc2:	c0 81       	brne	80005fd2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005fc4:	4a 48       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a8>
80005fc6:	70 08       	ld.w	r8,r8[0x0]
80005fc8:	70 b8       	ld.w	r8,r8[0x2c]
80005fca:	10 33       	cp.w	r3,r8
80005fcc:	c0 33       	brcs	80005fd2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005fce:	4a 28       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a8>
80005fd0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005fd2:	6a b8       	ld.w	r8,r5[0x2c]
80005fd4:	4a b9       	lddpc	r9,80006080 <xTaskGenericCreate+0x1d4>
80005fd6:	72 09       	ld.w	r9,r9[0x0]
80005fd8:	12 38       	cp.w	r8,r9
80005fda:	e0 88 00 04 	brls	80005fe2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005fde:	4a 99       	lddpc	r9,80006080 <xTaskGenericCreate+0x1d4>
80005fe0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005fe2:	4a 98       	lddpc	r8,80006084 <xTaskGenericCreate+0x1d8>
80005fe4:	70 09       	ld.w	r9,r8[0x0]
80005fe6:	2f f9       	sub	r9,-1
80005fe8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005fea:	6a b8       	ld.w	r8,r5[0x2c]
80005fec:	4a 79       	lddpc	r9,80006088 <xTaskGenericCreate+0x1dc>
80005fee:	72 09       	ld.w	r9,r9[0x0]
80005ff0:	12 38       	cp.w	r8,r9
80005ff2:	e0 88 00 04 	brls	80005ffa <xTaskGenericCreate+0x14e>
80005ff6:	4a 59       	lddpc	r9,80006088 <xTaskGenericCreate+0x1dc>
80005ff8:	93 08       	st.w	r9[0x0],r8
80005ffa:	6a bc       	ld.w	r12,r5[0x2c]
80005ffc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006000:	08 9b       	mov	r11,r4
80006002:	49 68       	lddpc	r8,80006058 <xTaskGenericCreate+0x1ac>
80006004:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006008:	f0 1f 00 21 	mcall	8000608c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000600c:	f0 1f 00 21 	mcall	80006090 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006010:	49 b8       	lddpc	r8,8000607c <xTaskGenericCreate+0x1d0>
80006012:	70 08       	ld.w	r8,r8[0x0]
80006014:	58 08       	cp.w	r8,0
80006016:	c0 a0       	breq	8000602a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006018:	48 f8       	lddpc	r8,80006054 <xTaskGenericCreate+0x1a8>
8000601a:	70 08       	ld.w	r8,r8[0x0]
8000601c:	70 b8       	ld.w	r8,r8[0x2c]
8000601e:	10 33       	cp.w	r3,r8
80006020:	e0 88 00 05 	brls	8000602a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006024:	d7 33       	scall
80006026:	30 1c       	mov	r12,1
80006028:	c0 28       	rjmp	8000602c <xTaskGenericCreate+0x180>
8000602a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000602c:	2f fd       	sub	sp,-4
8000602e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006030:	99 c6       	st.w	r12[0x30],r6
80006032:	c5 fb       	rjmp	80005ef0 <xTaskGenericCreate+0x44>
80006034:	80 00       	ld.sh	r0,r0[0x0]
80006036:	53 2c       	stdsp	sp[0xc8],r12
80006038:	80 00       	ld.sh	r0,r0[0x0]
8000603a:	53 04       	stdsp	sp[0xc0],r4
8000603c:	80 00       	ld.sh	r0,r0[0x0]
8000603e:	6d 18       	ld.w	r8,r6[0x44]
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	70 5c       	ld.w	r12,r8[0x14]
80006044:	80 00       	ld.sh	r0,r0[0x0]
80006046:	4f b0       	lddpc	r0,80006230 <PrintDec+0x9a>
80006048:	80 00       	ld.sh	r0,r0[0x0]
8000604a:	50 2c       	stdsp	sp[0x8],r12
8000604c:	80 00       	ld.sh	r0,r0[0x0]
8000604e:	50 c0       	stdsp	sp[0x30],r0
80006050:	00 00       	add	r0,r0
80006052:	0d 3c       	ld.ub	r12,r6++
80006054:	00 00       	add	r0,r0
80006056:	0c f0       	st.b	--r6,r0
80006058:	00 00       	add	r0,r0
8000605a:	0c 3c       	cp.w	r12,r6
8000605c:	80 00       	ld.sh	r0,r0[0x0]
8000605e:	4f 9c       	lddpc	r12,80006240 <PrintDec+0xaa>
80006060:	00 00       	add	r0,r0
80006062:	0d 08       	ld.w	r8,r6++
80006064:	00 00       	add	r0,r0
80006066:	0d 24       	ld.uh	r4,r6++
80006068:	00 00       	add	r0,r0
8000606a:	0c f4       	st.b	--r6,r4
8000606c:	00 00       	add	r0,r0
8000606e:	0c dc       	st.w	--r6,r12
80006070:	00 00       	add	r0,r0
80006072:	0d 44       	ld.w	r4,--r6
80006074:	00 00       	add	r0,r0
80006076:	0c 28       	rsub	r8,r6
80006078:	00 00       	add	r0,r0
8000607a:	0c 38       	cp.w	r8,r6
8000607c:	00 00       	add	r0,r0
8000607e:	0c 2c       	rsub	r12,r6
80006080:	00 00       	add	r0,r0
80006082:	0c 24       	rsub	r4,r6
80006084:	00 00       	add	r0,r0
80006086:	0d 38       	ld.ub	r8,r6++
80006088:	00 00       	add	r0,r0
8000608a:	0d 58       	ld.sh	r8,--r6
8000608c:	80 00       	ld.sh	r0,r0[0x0]
8000608e:	4f b6       	lddpc	r6,80006278 <log+0x8>
80006090:	80 00       	ld.sh	r0,r0[0x0]
80006092:	51 cc       	stdsp	sp[0x70],r12

80006094 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006094:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006096:	30 09       	mov	r9,0
80006098:	1a d9       	st.w	--sp,r9
8000609a:	1a d9       	st.w	--sp,r9
8000609c:	1a d9       	st.w	--sp,r9
8000609e:	12 98       	mov	r8,r9
800060a0:	e0 6a 01 00 	mov	r10,256
800060a4:	48 9b       	lddpc	r11,800060c8 <vTaskStartScheduler+0x34>
800060a6:	48 ac       	lddpc	r12,800060cc <vTaskStartScheduler+0x38>
800060a8:	f0 1f 00 0a 	mcall	800060d0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800060ac:	2f dd       	sub	sp,-12
800060ae:	58 1c       	cp.w	r12,1
800060b0:	c0 a1       	brne	800060c4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800060b2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800060b4:	30 19       	mov	r9,1
800060b6:	48 88       	lddpc	r8,800060d4 <vTaskStartScheduler+0x40>
800060b8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800060ba:	30 09       	mov	r9,0
800060bc:	48 78       	lddpc	r8,800060d8 <vTaskStartScheduler+0x44>
800060be:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800060c0:	f0 1f 00 07 	mcall	800060dc <vTaskStartScheduler+0x48>
800060c4:	d8 02       	popm	pc
800060c6:	00 00       	add	r0,r0
800060c8:	80 00       	ld.sh	r0,r0[0x0]
800060ca:	cc a0       	breq	8000605e <xTaskGenericCreate+0x1b2>
800060cc:	80 00       	ld.sh	r0,r0[0x0]
800060ce:	5e 24       	reths	r4
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	5e ac       	retle	r12
800060d4:	00 00       	add	r0,r0
800060d6:	0c 2c       	rsub	r12,r6
800060d8:	00 00       	add	r0,r0
800060da:	0d 1c       	ld.sh	r12,r6++
800060dc:	80 00       	ld.sh	r0,r0[0x0]
800060de:	50 d0       	stdsp	sp[0x34],r0

800060e0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800060e0:	16 cc       	st.b	r11++,r12
	return str;
}
800060e2:	5e fb       	retal	r11

800060e4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800060e4:	eb cd 40 c0 	pushm	r6-r7,lr
800060e8:	20 3d       	sub	sp,12
800060ea:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800060ec:	30 06       	mov	r6,0
800060ee:	30 07       	mov	r7,0
800060f0:	fa e7 00 00 	st.d	sp[0],r6
800060f4:	30 0c       	mov	r12,0
800060f6:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800060f8:	58 08       	cp.w	r8,0
800060fa:	c1 30       	breq	80006120 <PrintHex+0x3c>
800060fc:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800060fe:	1a 9c       	mov	r12,sp
80006100:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006104:	58 9e       	cp.w	lr,9
80006106:	e0 8a 00 04 	brle	8000610e <PrintHex+0x2a>
8000610a:	2c 9e       	sub	lr,-55
8000610c:	c0 48       	rjmp	80006114 <PrintHex+0x30>
8000610e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006112:	2d 0e       	sub	lr,-48
80006114:	f8 09 0b 0e 	st.b	r12[r9],lr
80006118:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000611a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000611c:	cf 21       	brne	80006100 <PrintHex+0x1c>
8000611e:	c0 48       	rjmp	80006126 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006120:	33 08       	mov	r8,48
80006122:	ba 88       	st.b	sp[0x0],r8
80006124:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006126:	f6 09 01 08 	sub	r8,r11,r9
8000612a:	58 08       	cp.w	r8,0
8000612c:	e0 8a 00 13 	brle	80006152 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006130:	12 1b       	sub	r11,r9
80006132:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006136:	18 9e       	mov	lr,r12
80006138:	58 0c       	cp.w	r12,0
8000613a:	e0 8a 00 0c 	brle	80006152 <PrintHex+0x6e>
8000613e:	1a 9b       	mov	r11,sp
80006140:	12 0b       	add	r11,r9
80006142:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006144:	33 07       	mov	r7,48
80006146:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006148:	2f f8       	sub	r8,-1
8000614a:	1c 38       	cp.w	r8,lr
8000614c:	cf d5       	brlt	80006146 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000614e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006152:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006156:	f0 cb ff ff 	sub	r11,r8,-1
8000615a:	58 0b       	cp.w	r11,0
8000615c:	e0 8a 00 19 	brle	8000618e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006160:	fa cb ff f4 	sub	r11,sp,-12
80006164:	f6 09 00 09 	add	r9,r11,r9
80006168:	37 8b       	mov	r11,120
8000616a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000616e:	fa c9 ff f4 	sub	r9,sp,-12
80006172:	10 09       	add	r9,r8
80006174:	33 0b       	mov	r11,48
80006176:	f3 6b ff f4 	st.b	r9[-12],r11
8000617a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000617e:	fa ce 00 01 	sub	lr,sp,1
80006182:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006184:	11 8b       	ld.ub	r11,r8[0x0]
80006186:	12 cb       	st.b	r9++,r11
80006188:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000618a:	1c 38       	cp.w	r8,lr
8000618c:	cf c1       	brne	80006184 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000618e:	14 9c       	mov	r12,r10
80006190:	2f dd       	sub	sp,-12
80006192:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006196 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006196:	d4 21       	pushm	r4-r7,lr
80006198:	20 3d       	sub	sp,12
8000619a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
8000619c:	30 06       	mov	r6,0
8000619e:	30 07       	mov	r7,0
800061a0:	fa e7 00 00 	st.d	sp[0],r6
800061a4:	30 0c       	mov	r12,0
800061a6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800061a8:	58 08       	cp.w	r8,0
800061aa:	c0 35       	brlt	800061b0 <PrintDec+0x1a>
800061ac:	14 97       	mov	r7,r10
800061ae:	c0 58       	rjmp	800061b8 <PrintDec+0x22>
	{
		*p++ = '-';
800061b0:	14 97       	mov	r7,r10
800061b2:	32 d9       	mov	r9,45
800061b4:	0e c9       	st.b	r7++,r9
		i = -i;
800061b6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800061b8:	58 08       	cp.w	r8,0
800061ba:	c0 51       	brne	800061c4 <PrintDec+0x2e>
800061bc:	33 08       	mov	r8,48
800061be:	ba 88       	st.b	sp[0x0],r8
800061c0:	30 1e       	mov	lr,1
800061c2:	c2 f8       	rjmp	80006220 <PrintDec+0x8a>
	
	int ten = i%10;
800061c4:	e0 65 66 67 	mov	r5,26215
800061c8:	ea 15 66 66 	orh	r5,0x6666
800061cc:	f0 05 04 44 	muls.d	r4,r8,r5
800061d0:	ea 0c 14 02 	asr	r12,r5,0x2
800061d4:	f0 09 14 1f 	asr	r9,r8,0x1f
800061d8:	f8 09 01 09 	sub	r9,r12,r9
800061dc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800061e0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800061e4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800061e6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800061e8:	e0 66 66 67 	mov	r6,26215
800061ec:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
800061f0:	2d 09       	sub	r9,-48
800061f2:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
800061f6:	2f fe       	sub	lr,-1
		i /= 10;
800061f8:	f0 06 04 44 	muls.d	r4,r8,r6
800061fc:	ea 09 14 02 	asr	r9,r5,0x2
80006200:	bf 58       	asr	r8,0x1f
80006202:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006206:	f0 06 04 44 	muls.d	r4,r8,r6
8000620a:	ea 09 14 02 	asr	r9,r5,0x2
8000620e:	f0 05 14 1f 	asr	r5,r8,0x1f
80006212:	0a 19       	sub	r9,r5
80006214:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006218:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000621c:	58 08       	cp.w	r8,0
8000621e:	ce 91       	brne	800061f0 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006220:	f6 0e 01 08 	sub	r8,r11,lr
80006224:	58 08       	cp.w	r8,0
80006226:	e0 89 00 06 	brgt	80006232 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000622a:	58 0e       	cp.w	lr,0
8000622c:	e0 89 00 14 	brgt	80006254 <PrintDec+0xbe>
80006230:	c1 d8       	rjmp	8000626a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006232:	1c 1b       	sub	r11,lr
80006234:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006236:	16 9c       	mov	r12,r11
80006238:	58 0b       	cp.w	r11,0
8000623a:	fe 9a ff f8 	brle	8000622a <PrintDec+0x94>
8000623e:	1a 99       	mov	r9,sp
80006240:	1c 09       	add	r9,lr
80006242:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006244:	33 06       	mov	r6,48
80006246:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006248:	2f f8       	sub	r8,-1
8000624a:	18 38       	cp.w	r8,r12
8000624c:	cf d5       	brlt	80006246 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000624e:	f6 0e 00 0e 	add	lr,r11,lr
80006252:	ce cb       	rjmp	8000622a <PrintDec+0x94>
80006254:	fa c8 ff f4 	sub	r8,sp,-12
80006258:	1c 08       	add	r8,lr
8000625a:	20 d8       	sub	r8,13
8000625c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006260:	11 89       	ld.ub	r9,r8[0x0]
80006262:	0e c9       	st.b	r7++,r9
80006264:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006266:	16 38       	cp.w	r8,r11
80006268:	cf c1       	brne	80006260 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000626a:	14 9c       	mov	r12,r10
8000626c:	2f dd       	sub	sp,-12
8000626e:	d8 22       	popm	r4-r7,pc

80006270 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006270:	d4 31       	pushm	r0-r7,lr
80006272:	fa cd 02 08 	sub	sp,sp,520
80006276:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006278:	e0 6a 01 00 	mov	r10,256
8000627c:	30 0b       	mov	r11,0
8000627e:	fa cc fe f8 	sub	r12,sp,-264
80006282:	f0 1f 00 4e 	mcall	800063b8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006286:	fa c4 fd d4 	sub	r4,sp,-556
8000628a:	30 0a       	mov	r10,0
8000628c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000628e:	fa c3 ff fc 	sub	r3,sp,-4
80006292:	e0 61 01 00 	mov	r1,256
80006296:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006298:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000629a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000629e:	02 9a       	mov	r10,r1
800062a0:	00 9b       	mov	r11,r0
800062a2:	06 9c       	mov	r12,r3
800062a4:	f0 1f 00 45 	mcall	800063b8 <log+0x148>
			
					if(*str == '%')
800062a8:	0f 88       	ld.ub	r8,r7[0x0]
800062aa:	e4 08 18 00 	cp.b	r8,r2
800062ae:	c5 71       	brne	8000635c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800062b0:	ee c8 ff ff 	sub	r8,r7,-1
800062b4:	11 89       	ld.ub	r9,r8[0x0]
800062b6:	4c 2a       	lddpc	r10,800063bc <log+0x14c>
800062b8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800062ba:	23 09       	sub	r9,48
800062bc:	30 9a       	mov	r10,9
800062be:	f4 09 18 00 	cp.b	r9,r10
800062c2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800062c6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800062ca:	f7 b9 08 30 	subls	r9,48
800062ce:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800062d2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800062d6:	0f 88       	ld.ub	r8,r7[0x0]
800062d8:	22 58       	sub	r8,37
800062da:	e0 48 00 53 	cp.w	r8,83
800062de:	e0 8b 00 31 	brhi	80006340 <log+0xd0>
800062e2:	4b 89       	lddpc	r9,800063c0 <log+0x150>
800062e4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800062e8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800062ec:	06 9a       	mov	r10,r3
800062ee:	40 0b       	lddsp	r11,sp[0x0]
800062f0:	5c 5b       	castu.b	r11
800062f2:	68 0c       	ld.w	r12,r4[0x0]
800062f4:	f0 1f 00 34 	mcall	800063c4 <log+0x154>
							break;
800062f8:	c2 98       	rjmp	8000634a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
800062fa:	4b 4c       	lddpc	r12,800063c8 <log+0x158>
800062fc:	f0 1f 00 34 	mcall	800063cc <log+0x15c>
80006300:	08 95       	mov	r5,r4
80006302:	06 9c       	mov	r12,r3
							break;
80006304:	c2 38       	rjmp	8000634a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006306:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000630a:	06 9a       	mov	r10,r3
8000630c:	40 0b       	lddsp	r11,sp[0x0]
8000630e:	5c 5b       	castu.b	r11
80006310:	68 0c       	ld.w	r12,r4[0x0]
80006312:	f0 1f 00 30 	mcall	800063d0 <log+0x160>
80006316:	06 9c       	mov	r12,r3
							break;
80006318:	c1 98       	rjmp	8000634a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000631a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000631e:	06 9b       	mov	r11,r3
80006320:	09 bc       	ld.ub	r12,r4[0x3]
80006322:	f0 1f 00 2d 	mcall	800063d4 <log+0x164>
80006326:	06 9c       	mov	r12,r3
							break;
80006328:	c1 18       	rjmp	8000634a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000632a:	e8 c5 ff fc 	sub	r5,r4,-4
8000632e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006330:	c0 d8       	rjmp	8000634a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006332:	06 9b       	mov	r11,r3
80006334:	32 5c       	mov	r12,37
80006336:	f0 1f 00 28 	mcall	800063d4 <log+0x164>
8000633a:	08 95       	mov	r5,r4
8000633c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000633e:	c0 68       	rjmp	8000634a <log+0xda>
							
							default:
							log("I need relax.");
80006340:	4a 6c       	lddpc	r12,800063d8 <log+0x168>
80006342:	f0 1f 00 23 	mcall	800063cc <log+0x15c>
80006346:	08 95       	mov	r5,r4
80006348:	06 9c       	mov	r12,r3
						}
						str++;
8000634a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000634c:	1a dc       	st.w	--sp,r12
8000634e:	1a d6       	st.w	--sp,r6
80006350:	4a 3b       	lddpc	r11,800063dc <log+0x16c>
80006352:	0c 9c       	mov	r12,r6
80006354:	f0 1f 00 23 	mcall	800063e0 <log+0x170>
80006358:	2f ed       	sub	sp,-8
8000635a:	c0 a8       	rjmp	8000636e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000635c:	2f f7       	sub	r7,-1
8000635e:	1a d8       	st.w	--sp,r8
80006360:	1a d6       	st.w	--sp,r6
80006362:	4a 1b       	lddpc	r11,800063e4 <log+0x174>
80006364:	0c 9c       	mov	r12,r6
80006366:	f0 1f 00 1f 	mcall	800063e0 <log+0x170>
8000636a:	08 95       	mov	r5,r4
8000636c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000636e:	0f 89       	ld.ub	r9,r7[0x0]
80006370:	30 08       	mov	r8,0
80006372:	f0 09 18 00 	cp.b	r9,r8
80006376:	c0 30       	breq	8000637c <log+0x10c>
80006378:	0a 94       	mov	r4,r5
8000637a:	c9 2b       	rjmp	8000629e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000637c:	fa c7 fe f8 	sub	r7,sp,-264
80006380:	1a d7       	st.w	--sp,r7
80006382:	49 ab       	lddpc	r11,800063e8 <log+0x178>
80006384:	0e 9c       	mov	r12,r7
80006386:	f0 1f 00 17 	mcall	800063e0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000638a:	5c 5c       	castu.b	r12
8000638c:	f8 c6 ff ff 	sub	r6,r12,-1
80006390:	0c 9c       	mov	r12,r6
80006392:	f0 1f 00 17 	mcall	800063ec <log+0x17c>
80006396:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006398:	0c 9a       	mov	r10,r6
8000639a:	0e 9b       	mov	r11,r7
8000639c:	f0 1f 00 15 	mcall	800063f0 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
800063a0:	30 09       	mov	r9,0
800063a2:	30 5a       	mov	r10,5
800063a4:	fa cb fe f8 	sub	r11,sp,-264
800063a8:	49 38       	lddpc	r8,800063f4 <log+0x184>
800063aa:	70 0c       	ld.w	r12,r8[0x0]
800063ac:	f0 1f 00 13 	mcall	800063f8 <log+0x188>
800063b0:	2f fd       	sub	sp,-4
}
800063b2:	fe 3d fd f8 	sub	sp,-520
800063b6:	d8 32       	popm	r0-r7,pc
800063b8:	80 00       	ld.sh	r0,r0[0x0]
800063ba:	6d 18       	ld.w	r8,r6[0x44]
800063bc:	00 00       	add	r0,r0
800063be:	0d 5c       	ld.sh	r12,--r6
800063c0:	80 00       	ld.sh	r0,r0[0x0]
800063c2:	cc a8       	rjmp	80006556 <logFromISR+0x15a>
800063c4:	80 00       	ld.sh	r0,r0[0x0]
800063c6:	61 96       	ld.w	r6,r0[0x64]
800063c8:	80 00       	ld.sh	r0,r0[0x0]
800063ca:	cf 54       	brge	800063b4 <log+0x144>
800063cc:	80 00       	ld.sh	r0,r0[0x0]
800063ce:	62 70       	ld.w	r0,r1[0x1c]
800063d0:	80 00       	ld.sh	r0,r0[0x0]
800063d2:	60 e4       	ld.w	r4,r0[0x38]
800063d4:	80 00       	ld.sh	r0,r0[0x0]
800063d6:	60 e0       	ld.w	r0,r0[0x38]
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	cf 64       	brge	800063c6 <log+0x156>
800063dc:	80 00       	ld.sh	r0,r0[0x0]
800063de:	cf 74       	brge	800063cc <log+0x15c>
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	70 08       	ld.w	r8,r8[0x0]
800063e4:	80 00       	ld.sh	r0,r0[0x0]
800063e6:	cf 7c       	rcall	800065d4 <log_init+0x58>
800063e8:	80 00       	ld.sh	r0,r0[0x0]
800063ea:	cf 84       	brge	800063da <log+0x16a>
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	53 2c       	stdsp	sp[0xc8],r12
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	6b d0       	ld.w	r0,r5[0x74]
800063f4:	00 00       	add	r0,r0
800063f6:	41 14       	lddsp	r4,sp[0x44]
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	56 80       	stdsp	sp[0x1a0],r0

800063fc <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
800063fc:	d4 31       	pushm	r0-r7,lr
800063fe:	fa cd 02 0c 	sub	sp,sp,524
80006402:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006404:	e0 6a 01 00 	mov	r10,256
80006408:	30 0b       	mov	r11,0
8000640a:	fa cc fe f4 	sub	r12,sp,-268
8000640e:	f0 1f 00 4c 	mcall	8000653c <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80006412:	fa c4 fd d0 	sub	r4,sp,-560
80006416:	30 0a       	mov	r10,0
80006418:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000641a:	fa c3 ff fc 	sub	r3,sp,-4
8000641e:	e0 61 01 00 	mov	r1,256
80006422:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006424:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006426:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000642a:	02 9a       	mov	r10,r1
8000642c:	00 9b       	mov	r11,r0
8000642e:	06 9c       	mov	r12,r3
80006430:	f0 1f 00 43 	mcall	8000653c <logFromISR+0x140>
			
			if(*str == '%')
80006434:	0f 88       	ld.ub	r8,r7[0x0]
80006436:	e4 08 18 00 	cp.b	r8,r2
8000643a:	c5 11       	brne	800064dc <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000643c:	ee c8 ff ff 	sub	r8,r7,-1
80006440:	11 89       	ld.ub	r9,r8[0x0]
80006442:	4c 0a       	lddpc	r10,80006540 <logFromISR+0x144>
80006444:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006446:	23 09       	sub	r9,48
80006448:	30 9a       	mov	r10,9
8000644a:	f4 09 18 00 	cp.b	r9,r10
8000644e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006452:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006456:	f7 b9 08 30 	subls	r9,48
8000645a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000645e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006462:	0f 88       	ld.ub	r8,r7[0x0]
80006464:	22 58       	sub	r8,37
80006466:	e0 48 00 53 	cp.w	r8,83
8000646a:	e0 8b 00 2b 	brhi	800064c0 <logFromISR+0xc4>
8000646e:	4b 69       	lddpc	r9,80006544 <logFromISR+0x148>
80006470:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006474:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006478:	06 9a       	mov	r10,r3
8000647a:	40 0b       	lddsp	r11,sp[0x0]
8000647c:	5c 5b       	castu.b	r11
8000647e:	68 0c       	ld.w	r12,r4[0x0]
80006480:	f0 1f 00 32 	mcall	80006548 <logFromISR+0x14c>
					break;
80006484:	c2 38       	rjmp	800064ca <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80006486:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000648a:	06 9a       	mov	r10,r3
8000648c:	40 0b       	lddsp	r11,sp[0x0]
8000648e:	5c 5b       	castu.b	r11
80006490:	68 0c       	ld.w	r12,r4[0x0]
80006492:	f0 1f 00 2f 	mcall	8000654c <logFromISR+0x150>
80006496:	06 9c       	mov	r12,r3
					break;
80006498:	c1 98       	rjmp	800064ca <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000649a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000649e:	06 9b       	mov	r11,r3
800064a0:	09 bc       	ld.ub	r12,r4[0x3]
800064a2:	f0 1f 00 2c 	mcall	80006550 <logFromISR+0x154>
800064a6:	06 9c       	mov	r12,r3
					break;
800064a8:	c1 18       	rjmp	800064ca <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800064aa:	e8 c5 ff fc 	sub	r5,r4,-4
800064ae:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800064b0:	c0 d8       	rjmp	800064ca <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800064b2:	06 9b       	mov	r11,r3
800064b4:	32 5c       	mov	r12,37
800064b6:	f0 1f 00 27 	mcall	80006550 <logFromISR+0x154>
800064ba:	08 95       	mov	r5,r4
800064bc:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800064be:	c0 68       	rjmp	800064ca <logFromISR+0xce>
					default:
					log("I need relax.");
800064c0:	4a 5c       	lddpc	r12,80006554 <logFromISR+0x158>
800064c2:	f0 1f 00 26 	mcall	80006558 <logFromISR+0x15c>
800064c6:	08 95       	mov	r5,r4
800064c8:	06 9c       	mov	r12,r3
				}
				str++;
800064ca:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800064cc:	1a dc       	st.w	--sp,r12
800064ce:	1a d6       	st.w	--sp,r6
800064d0:	4a 3b       	lddpc	r11,8000655c <logFromISR+0x160>
800064d2:	0c 9c       	mov	r12,r6
800064d4:	f0 1f 00 23 	mcall	80006560 <logFromISR+0x164>
800064d8:	2f ed       	sub	sp,-8
800064da:	c0 a8       	rjmp	800064ee <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800064dc:	2f f7       	sub	r7,-1
800064de:	1a d8       	st.w	--sp,r8
800064e0:	1a d6       	st.w	--sp,r6
800064e2:	4a 1b       	lddpc	r11,80006564 <logFromISR+0x168>
800064e4:	0c 9c       	mov	r12,r6
800064e6:	f0 1f 00 1f 	mcall	80006560 <logFromISR+0x164>
800064ea:	08 95       	mov	r5,r4
800064ec:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800064ee:	0f 89       	ld.ub	r9,r7[0x0]
800064f0:	30 08       	mov	r8,0
800064f2:	f0 09 18 00 	cp.b	r9,r8
800064f6:	c0 30       	breq	800064fc <logFromISR+0x100>
800064f8:	0a 94       	mov	r4,r5
800064fa:	c9 8b       	rjmp	8000642a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
800064fc:	fa c7 fe f4 	sub	r7,sp,-268
80006500:	1a d7       	st.w	--sp,r7
80006502:	49 ab       	lddpc	r11,80006568 <logFromISR+0x16c>
80006504:	0e 9c       	mov	r12,r7
80006506:	f0 1f 00 17 	mcall	80006560 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000650a:	5c 5c       	castu.b	r12
8000650c:	f8 c6 ff ff 	sub	r6,r12,-1
80006510:	0c 9c       	mov	r12,r6
80006512:	f0 1f 00 17 	mcall	8000656c <logFromISR+0x170>
80006516:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006518:	0c 9a       	mov	r10,r6
8000651a:	0e 9b       	mov	r11,r7
8000651c:	f0 1f 00 15 	mcall	80006570 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006520:	30 09       	mov	r9,0
80006522:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006524:	fa ca fe f8 	sub	r10,sp,-264
80006528:	fa cb fe f4 	sub	r11,sp,-268
8000652c:	49 28       	lddpc	r8,80006574 <logFromISR+0x178>
8000652e:	70 0c       	ld.w	r12,r8[0x0]
80006530:	f0 1f 00 12 	mcall	80006578 <logFromISR+0x17c>
80006534:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006536:	fe 3d fd f4 	sub	sp,-524
8000653a:	d8 32       	popm	r0-r7,pc
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	6d 18       	ld.w	r8,r6[0x44]
80006540:	00 00       	add	r0,r0
80006542:	0d 5d       	ld.sh	sp,--r6
80006544:	80 00       	ld.sh	r0,r0[0x0]
80006546:	cd f8       	rjmp	80006704 <gpio_enable_module_pin+0x50>
80006548:	80 00       	ld.sh	r0,r0[0x0]
8000654a:	61 96       	ld.w	r6,r0[0x64]
8000654c:	80 00       	ld.sh	r0,r0[0x0]
8000654e:	60 e4       	ld.w	r4,r0[0x38]
80006550:	80 00       	ld.sh	r0,r0[0x0]
80006552:	60 e0       	ld.w	r0,r0[0x38]
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	cf 64       	brge	80006542 <logFromISR+0x146>
80006558:	80 00       	ld.sh	r0,r0[0x0]
8000655a:	62 70       	ld.w	r0,r1[0x1c]
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	cf 74       	brge	8000654c <logFromISR+0x150>
80006560:	80 00       	ld.sh	r0,r0[0x0]
80006562:	70 08       	ld.w	r8,r8[0x0]
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	cf 7c       	rcall	80006754 <idata_load_loop>
80006568:	80 00       	ld.sh	r0,r0[0x0]
8000656a:	cf 84       	brge	8000655a <logFromISR+0x15e>
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	53 2c       	stdsp	sp[0xc8],r12
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	6b d0       	ld.w	r0,r5[0x74]
80006574:	00 00       	add	r0,r0
80006576:	41 14       	lddsp	r4,sp[0x44]
80006578:	80 00       	ld.sh	r0,r0[0x0]
8000657a:	56 30       	stdsp	sp[0x18c],r0

8000657c <log_init>:
		
	return str;
}

void log_init(void)
{
8000657c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000657e:	30 2b       	mov	r11,2
80006580:	49 0c       	lddpc	r12,800065c0 <log_init+0x44>
80006582:	f0 1f 00 11 	mcall	800065c4 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80006586:	e0 6a 36 00 	mov	r10,13824
8000658a:	ea 1a 01 6e 	orh	r10,0x16e
8000658e:	48 fb       	lddpc	r11,800065c8 <log_init+0x4c>
80006590:	fe 7c 18 00 	mov	r12,-59392
80006594:	f0 1f 00 0e 	mcall	800065cc <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80006598:	30 4b       	mov	r11,4
8000659a:	33 2c       	mov	r12,50
8000659c:	f0 1f 00 0d 	mcall	800065d0 <log_init+0x54>
800065a0:	48 d8       	lddpc	r8,800065d4 <log_init+0x58>
800065a2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800065a4:	30 09       	mov	r9,0
800065a6:	1a d9       	st.w	--sp,r9
800065a8:	1a d9       	st.w	--sp,r9
800065aa:	1a d9       	st.w	--sp,r9
800065ac:	30 28       	mov	r8,2
800065ae:	e0 6a 01 80 	mov	r10,384
800065b2:	48 ab       	lddpc	r11,800065d8 <log_init+0x5c>
800065b4:	48 ac       	lddpc	r12,800065dc <log_init+0x60>
800065b6:	f0 1f 00 0b 	mcall	800065e0 <log_init+0x64>
800065ba:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800065bc:	d8 02       	popm	pc
800065be:	00 00       	add	r0,r0
800065c0:	80 00       	ld.sh	r0,r0[0x0]
800065c2:	cf 90       	breq	800065b4 <log_init+0x38>
800065c4:	80 00       	ld.sh	r0,r0[0x0]
800065c6:	67 08       	ld.w	r8,r3[0x40]
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	cf 48       	rjmp	800067b2 <_malloc_r+0x1a>
800065cc:	80 00       	ld.sh	r0,r0[0x0]
800065ce:	4e d0       	lddpc	r0,80006780 <free+0x8>
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	57 d8       	stdsp	sp[0x1f4],r8
800065d4:	00 00       	add	r0,r0
800065d6:	41 14       	lddsp	r4,sp[0x44]
800065d8:	80 00       	ld.sh	r0,r0[0x0]
800065da:	cf 8c       	rcall	800067ca <_malloc_r+0x32>
800065dc:	80 00       	ld.sh	r0,r0[0x0]
800065de:	65 e4       	ld.w	r4,r2[0x78]
800065e0:	80 00       	ld.sh	r0,r0[0x0]
800065e2:	5e ac       	retle	r12

800065e4 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
800065e4:	eb cd 40 f8 	pushm	r3-r7,lr
800065e8:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800065ea:	48 c7       	lddpc	r7,80006618 <task_log+0x34>
800065ec:	30 05       	mov	r5,0
800065ee:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800065f0:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800065f4:	0a 99       	mov	r9,r5
800065f6:	08 9a       	mov	r10,r4
800065f8:	1a 9b       	mov	r11,sp
800065fa:	6e 0c       	ld.w	r12,r7[0x0]
800065fc:	f0 1f 00 08 	mcall	8000661c <task_log+0x38>
80006600:	58 1c       	cp.w	r12,1
80006602:	cf 91       	brne	800065f4 <task_log+0x10>
		{
			if( NULL != str)
80006604:	40 0b       	lddsp	r11,sp[0x0]
80006606:	58 0b       	cp.w	r11,0
80006608:	cf 60       	breq	800065f4 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000660a:	06 9c       	mov	r12,r3
8000660c:	f0 1f 00 05 	mcall	80006620 <task_log+0x3c>
				vPortFree(str);
80006610:	40 0c       	lddsp	r12,sp[0x0]
80006612:	f0 1f 00 05 	mcall	80006624 <task_log+0x40>
80006616:	ce fb       	rjmp	800065f4 <task_log+0x10>
80006618:	00 00       	add	r0,r0
8000661a:	41 14       	lddsp	r4,sp[0x44]
8000661c:	80 00       	ld.sh	r0,r0[0x0]
8000661e:	54 74       	stdsp	sp[0x11c],r4
80006620:	80 00       	ld.sh	r0,r0[0x0]
80006622:	4e 80       	lddpc	r0,800067c0 <_malloc_r+0x28>
80006624:	80 00       	ld.sh	r0,r0[0x0]
80006626:	53 04       	stdsp	sp[0xc0],r4

80006628 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80006628:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000662a:	fe 78 10 00 	mov	r8,-61440
8000662e:	30 19       	mov	r9,1
80006630:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006634:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006638:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000663c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000663e:	f0 1f 00 13 	mcall	80006688 <main+0x60>
		
	INTC_init_interrupts();
80006642:	f0 1f 00 13 	mcall	8000668c <main+0x64>
	
	log_init();		
80006646:	f0 1f 00 13 	mcall	80006690 <main+0x68>
	log("----start debug----");	
8000664a:	49 3c       	lddpc	r12,80006694 <main+0x6c>
8000664c:	f0 1f 00 13 	mcall	80006698 <main+0x70>
		
	rtc_init();
80006650:	f0 1f 00 13 	mcall	8000669c <main+0x74>
	
	//fs_init();//65795机器无法通过文件系统初始化

	tc_init();	
80006654:	f0 1f 00 13 	mcall	800066a0 <main+0x78>
			
	xcmp_init();
80006658:	f0 1f 00 13 	mcall	800066a4 <main+0x7c>
	
	app_init();
8000665c:	f0 1f 00 13 	mcall	800066a8 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006660:	fe 79 10 00 	mov	r9,-61440
80006664:	f2 f8 01 60 	ld.w	r8,r9[352]
80006668:	e2 18 00 02 	andl	r8,0x2,COH
8000666c:	cf c0       	breq	80006664 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000666e:	fe 79 10 00 	mov	r9,-61440
80006672:	f2 f8 01 60 	ld.w	r8,r9[352]
80006676:	e2 18 00 02 	andl	r8,0x2,COH
8000667a:	cf c1       	brne	80006672 <main+0x4a>
	local_start_timer();
8000667c:	f0 1f 00 0c 	mcall	800066ac <main+0x84>
	
	Enable_global_interrupt();
80006680:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80006682:	f0 1f 00 0c 	mcall	800066b0 <main+0x88>
	return 0;
}
80006686:	d8 0a       	popm	pc,r12=0
80006688:	80 00       	ld.sh	r0,r0[0x0]
8000668a:	47 a0       	lddsp	r0,sp[0x1e8]
8000668c:	80 00       	ld.sh	r0,r0[0x0]
8000668e:	49 bc       	lddpc	r12,800066f8 <gpio_enable_module_pin+0x44>
80006690:	80 00       	ld.sh	r0,r0[0x0]
80006692:	65 7c       	ld.w	r12,r2[0x5c]
80006694:	80 00       	ld.sh	r0,r0[0x0]
80006696:	cf a0       	breq	8000668a <main+0x62>
80006698:	80 00       	ld.sh	r0,r0[0x0]
8000669a:	62 70       	ld.w	r0,r1[0x1c]
8000669c:	80 00       	ld.sh	r0,r0[0x0]
8000669e:	47 f0       	lddsp	r0,sp[0x1fc]
800066a0:	80 00       	ld.sh	r0,r0[0x0]
800066a2:	48 b8       	lddpc	r8,800066cc <gpio_enable_module_pin+0x18>
800066a4:	80 00       	ld.sh	r0,r0[0x0]
800066a6:	40 a4       	lddsp	r4,sp[0x28]
800066a8:	80 00       	ld.sh	r0,r0[0x0]
800066aa:	20 40       	sub	r0,4
800066ac:	80 00       	ld.sh	r0,r0[0x0]
800066ae:	48 7c       	lddpc	r12,800066c8 <gpio_enable_module_pin+0x14>
800066b0:	80 00       	ld.sh	r0,r0[0x0]
800066b2:	60 94       	ld.w	r4,r0[0x24]

800066b4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800066b4:	f8 08 16 05 	lsr	r8,r12,0x5
800066b8:	a9 68       	lsl	r8,0x8
800066ba:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800066be:	58 1b       	cp.w	r11,1
800066c0:	c0 d0       	breq	800066da <gpio_enable_module_pin+0x26>
800066c2:	c0 63       	brcs	800066ce <gpio_enable_module_pin+0x1a>
800066c4:	58 2b       	cp.w	r11,2
800066c6:	c1 00       	breq	800066e6 <gpio_enable_module_pin+0x32>
800066c8:	58 3b       	cp.w	r11,3
800066ca:	c1 40       	breq	800066f2 <gpio_enable_module_pin+0x3e>
800066cc:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800066ce:	30 19       	mov	r9,1
800066d0:	f2 0c 09 49 	lsl	r9,r9,r12
800066d4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800066d6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800066d8:	c1 28       	rjmp	800066fc <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800066da:	30 19       	mov	r9,1
800066dc:	f2 0c 09 49 	lsl	r9,r9,r12
800066e0:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800066e2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800066e4:	c0 c8       	rjmp	800066fc <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800066e6:	30 19       	mov	r9,1
800066e8:	f2 0c 09 49 	lsl	r9,r9,r12
800066ec:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800066ee:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800066f0:	c0 68       	rjmp	800066fc <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800066f2:	30 19       	mov	r9,1
800066f4:	f2 0c 09 49 	lsl	r9,r9,r12
800066f8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800066fa:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800066fc:	30 19       	mov	r9,1
800066fe:	f2 0c 09 4c 	lsl	r12,r9,r12
80006702:	91 2c       	st.w	r8[0x8],r12
80006704:	5e fd       	retal	0
80006706:	d7 03       	nop

80006708 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006708:	d4 21       	pushm	r4-r7,lr
8000670a:	18 97       	mov	r7,r12
8000670c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000670e:	58 0b       	cp.w	r11,0
80006710:	c0 31       	brne	80006716 <gpio_enable_module+0xe>
80006712:	30 05       	mov	r5,0
80006714:	c0 d8       	rjmp	8000672e <gpio_enable_module+0x26>
80006716:	30 06       	mov	r6,0
80006718:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000671a:	6e 1b       	ld.w	r11,r7[0x4]
8000671c:	6e 0c       	ld.w	r12,r7[0x0]
8000671e:	f0 1f 00 06 	mcall	80006734 <gpio_enable_module+0x2c>
80006722:	18 45       	or	r5,r12
		gpiomap++;
80006724:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006726:	2f f6       	sub	r6,-1
80006728:	0c 34       	cp.w	r4,r6
8000672a:	fe 9b ff f8 	brhi	8000671a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000672e:	0a 9c       	mov	r12,r5
80006730:	d8 22       	popm	r4-r7,pc
80006732:	00 00       	add	r0,r0
80006734:	80 00       	ld.sh	r0,r0[0x0]
80006736:	66 b4       	ld.w	r4,r3[0x2c]

80006738 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006738:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000673c:	fe c0 a5 3c 	sub	r0,pc,-23236

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006740:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006744:	d5 53       	csrf	0x15
  cp      r0, r1
80006746:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006748:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000674c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000674e:	c0 72       	brcc	8000675c <idata_load_loop_end>
  cp      r0, r1
80006750:	fe c2 92 18 	sub	r2,pc,-28136

80006754 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006754:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80006756:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80006758:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000675a:	cf d3       	brcs	80006754 <idata_load_loop>

8000675c <idata_load_loop_end>:
  mov     r2, 0
8000675c:	e0 60 0a 38 	mov	r0,2616
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006760:	e0 61 41 20 	mov	r1,16672
  cp      r0, r1
  brlo    udata_clear_loop
80006764:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006766:	c0 62       	brcc	80006772 <udata_clear_loop_end>
80006768:	30 02       	mov	r2,0
8000676a:	30 03       	mov	r3,0

8000676c <udata_clear_loop>:
8000676c:	a1 22       	st.d	r0++,r2
8000676e:	02 30       	cp.w	r0,r1
80006770:	cf e3       	brcs	8000676c <udata_clear_loop>

80006772 <udata_clear_loop_end>:
80006772:	fe cf 01 4a 	sub	pc,pc,330
80006776:	d7 03       	nop

80006778 <free>:
80006778:	d4 01       	pushm	lr
8000677a:	e0 68 0a 30 	mov	r8,2608
8000677e:	18 9b       	mov	r11,r12
80006780:	70 0c       	ld.w	r12,r8[0x0]
80006782:	e0 a0 1e 6d 	rcall	8000a45c <_free_r>
80006786:	d8 02       	popm	pc

80006788 <malloc>:
80006788:	d4 01       	pushm	lr
8000678a:	e0 68 0a 30 	mov	r8,2608
8000678e:	18 9b       	mov	r11,r12
80006790:	70 0c       	ld.w	r12,r8[0x0]
80006792:	c0 3c       	rcall	80006798 <_malloc_r>
80006794:	d8 02       	popm	pc
80006796:	d7 03       	nop

80006798 <_malloc_r>:
80006798:	d4 31       	pushm	r0-r7,lr
8000679a:	f6 c8 ff f5 	sub	r8,r11,-11
8000679e:	18 95       	mov	r5,r12
800067a0:	10 97       	mov	r7,r8
800067a2:	e0 17 ff f8 	andl	r7,0xfff8
800067a6:	59 68       	cp.w	r8,22
800067a8:	f9 b7 08 10 	movls	r7,16
800067ac:	16 37       	cp.w	r7,r11
800067ae:	5f 38       	srlo	r8
800067b0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800067b4:	c0 50       	breq	800067be <_malloc_r+0x26>
800067b6:	30 c8       	mov	r8,12
800067b8:	99 38       	st.w	r12[0xc],r8
800067ba:	e0 8f 01 fa 	bral	80006bae <_malloc_r+0x416>
800067be:	fe b0 f5 59 	rcall	80005270 <__malloc_lock>
800067c2:	e0 47 01 f7 	cp.w	r7,503
800067c6:	e0 8b 00 1d 	brhi	80006800 <_malloc_r+0x68>
800067ca:	ee 03 16 03 	lsr	r3,r7,0x3
800067ce:	e0 68 05 30 	mov	r8,1328
800067d2:	f0 03 00 38 	add	r8,r8,r3<<0x3
800067d6:	70 36       	ld.w	r6,r8[0xc]
800067d8:	10 36       	cp.w	r6,r8
800067da:	c0 61       	brne	800067e6 <_malloc_r+0x4e>
800067dc:	ec c8 ff f8 	sub	r8,r6,-8
800067e0:	70 36       	ld.w	r6,r8[0xc]
800067e2:	10 36       	cp.w	r6,r8
800067e4:	c0 c0       	breq	800067fc <_malloc_r+0x64>
800067e6:	6c 18       	ld.w	r8,r6[0x4]
800067e8:	e0 18 ff fc 	andl	r8,0xfffc
800067ec:	6c 3a       	ld.w	r10,r6[0xc]
800067ee:	ec 08 00 09 	add	r9,r6,r8
800067f2:	0a 9c       	mov	r12,r5
800067f4:	6c 28       	ld.w	r8,r6[0x8]
800067f6:	95 28       	st.w	r10[0x8],r8
800067f8:	91 3a       	st.w	r8[0xc],r10
800067fa:	c4 78       	rjmp	80006888 <_malloc_r+0xf0>
800067fc:	2f e3       	sub	r3,-2
800067fe:	c4 d8       	rjmp	80006898 <_malloc_r+0x100>
80006800:	ee 03 16 09 	lsr	r3,r7,0x9
80006804:	c0 41       	brne	8000680c <_malloc_r+0x74>
80006806:	ee 03 16 03 	lsr	r3,r7,0x3
8000680a:	c2 68       	rjmp	80006856 <_malloc_r+0xbe>
8000680c:	58 43       	cp.w	r3,4
8000680e:	e0 8b 00 06 	brhi	8000681a <_malloc_r+0x82>
80006812:	ee 03 16 06 	lsr	r3,r7,0x6
80006816:	2c 83       	sub	r3,-56
80006818:	c1 f8       	rjmp	80006856 <_malloc_r+0xbe>
8000681a:	59 43       	cp.w	r3,20
8000681c:	e0 8b 00 04 	brhi	80006824 <_malloc_r+0x8c>
80006820:	2a 53       	sub	r3,-91
80006822:	c1 a8       	rjmp	80006856 <_malloc_r+0xbe>
80006824:	e0 43 00 54 	cp.w	r3,84
80006828:	e0 8b 00 06 	brhi	80006834 <_malloc_r+0x9c>
8000682c:	ee 03 16 0c 	lsr	r3,r7,0xc
80006830:	29 23       	sub	r3,-110
80006832:	c1 28       	rjmp	80006856 <_malloc_r+0xbe>
80006834:	e0 43 01 54 	cp.w	r3,340
80006838:	e0 8b 00 06 	brhi	80006844 <_malloc_r+0xac>
8000683c:	ee 03 16 0f 	lsr	r3,r7,0xf
80006840:	28 93       	sub	r3,-119
80006842:	c0 a8       	rjmp	80006856 <_malloc_r+0xbe>
80006844:	e0 43 05 54 	cp.w	r3,1364
80006848:	e0 88 00 04 	brls	80006850 <_malloc_r+0xb8>
8000684c:	37 e3       	mov	r3,126
8000684e:	c0 48       	rjmp	80006856 <_malloc_r+0xbe>
80006850:	ee 03 16 12 	lsr	r3,r7,0x12
80006854:	28 43       	sub	r3,-124
80006856:	e0 6a 05 30 	mov	r10,1328
8000685a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000685e:	74 36       	ld.w	r6,r10[0xc]
80006860:	c1 98       	rjmp	80006892 <_malloc_r+0xfa>
80006862:	6c 19       	ld.w	r9,r6[0x4]
80006864:	e0 19 ff fc 	andl	r9,0xfffc
80006868:	f2 07 01 0b 	sub	r11,r9,r7
8000686c:	58 fb       	cp.w	r11,15
8000686e:	e0 8a 00 04 	brle	80006876 <_malloc_r+0xde>
80006872:	20 13       	sub	r3,1
80006874:	c1 18       	rjmp	80006896 <_malloc_r+0xfe>
80006876:	6c 38       	ld.w	r8,r6[0xc]
80006878:	58 0b       	cp.w	r11,0
8000687a:	c0 b5       	brlt	80006890 <_malloc_r+0xf8>
8000687c:	6c 2a       	ld.w	r10,r6[0x8]
8000687e:	ec 09 00 09 	add	r9,r6,r9
80006882:	0a 9c       	mov	r12,r5
80006884:	91 2a       	st.w	r8[0x8],r10
80006886:	95 38       	st.w	r10[0xc],r8
80006888:	72 18       	ld.w	r8,r9[0x4]
8000688a:	a1 a8       	sbr	r8,0x0
8000688c:	93 18       	st.w	r9[0x4],r8
8000688e:	cb c8       	rjmp	80006a06 <_malloc_r+0x26e>
80006890:	10 96       	mov	r6,r8
80006892:	14 36       	cp.w	r6,r10
80006894:	ce 71       	brne	80006862 <_malloc_r+0xca>
80006896:	2f f3       	sub	r3,-1
80006898:	e0 6a 05 30 	mov	r10,1328
8000689c:	f4 cc ff f8 	sub	r12,r10,-8
800068a0:	78 26       	ld.w	r6,r12[0x8]
800068a2:	18 36       	cp.w	r6,r12
800068a4:	c6 c0       	breq	8000697c <_malloc_r+0x1e4>
800068a6:	6c 19       	ld.w	r9,r6[0x4]
800068a8:	e0 19 ff fc 	andl	r9,0xfffc
800068ac:	f2 07 01 08 	sub	r8,r9,r7
800068b0:	58 f8       	cp.w	r8,15
800068b2:	e0 89 00 8f 	brgt	800069d0 <_malloc_r+0x238>
800068b6:	99 3c       	st.w	r12[0xc],r12
800068b8:	99 2c       	st.w	r12[0x8],r12
800068ba:	58 08       	cp.w	r8,0
800068bc:	c0 55       	brlt	800068c6 <_malloc_r+0x12e>
800068be:	ec 09 00 09 	add	r9,r6,r9
800068c2:	0a 9c       	mov	r12,r5
800068c4:	ce 2b       	rjmp	80006888 <_malloc_r+0xf0>
800068c6:	e0 49 01 ff 	cp.w	r9,511
800068ca:	e0 8b 00 13 	brhi	800068f0 <_malloc_r+0x158>
800068ce:	a3 99       	lsr	r9,0x3
800068d0:	f4 09 00 38 	add	r8,r10,r9<<0x3
800068d4:	70 2b       	ld.w	r11,r8[0x8]
800068d6:	8d 38       	st.w	r6[0xc],r8
800068d8:	8d 2b       	st.w	r6[0x8],r11
800068da:	97 36       	st.w	r11[0xc],r6
800068dc:	91 26       	st.w	r8[0x8],r6
800068de:	a3 49       	asr	r9,0x2
800068e0:	74 18       	ld.w	r8,r10[0x4]
800068e2:	30 1b       	mov	r11,1
800068e4:	f6 09 09 49 	lsl	r9,r11,r9
800068e8:	f1 e9 10 09 	or	r9,r8,r9
800068ec:	95 19       	st.w	r10[0x4],r9
800068ee:	c4 78       	rjmp	8000697c <_malloc_r+0x1e4>
800068f0:	f2 0a 16 09 	lsr	r10,r9,0x9
800068f4:	58 4a       	cp.w	r10,4
800068f6:	e0 8b 00 07 	brhi	80006904 <_malloc_r+0x16c>
800068fa:	f2 0a 16 06 	lsr	r10,r9,0x6
800068fe:	2c 8a       	sub	r10,-56
80006900:	c2 08       	rjmp	80006940 <_malloc_r+0x1a8>
80006902:	d7 03       	nop
80006904:	59 4a       	cp.w	r10,20
80006906:	e0 8b 00 04 	brhi	8000690e <_malloc_r+0x176>
8000690a:	2a 5a       	sub	r10,-91
8000690c:	c1 a8       	rjmp	80006940 <_malloc_r+0x1a8>
8000690e:	e0 4a 00 54 	cp.w	r10,84
80006912:	e0 8b 00 06 	brhi	8000691e <_malloc_r+0x186>
80006916:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000691a:	29 2a       	sub	r10,-110
8000691c:	c1 28       	rjmp	80006940 <_malloc_r+0x1a8>
8000691e:	e0 4a 01 54 	cp.w	r10,340
80006922:	e0 8b 00 06 	brhi	8000692e <_malloc_r+0x196>
80006926:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000692a:	28 9a       	sub	r10,-119
8000692c:	c0 a8       	rjmp	80006940 <_malloc_r+0x1a8>
8000692e:	e0 4a 05 54 	cp.w	r10,1364
80006932:	e0 88 00 04 	brls	8000693a <_malloc_r+0x1a2>
80006936:	37 ea       	mov	r10,126
80006938:	c0 48       	rjmp	80006940 <_malloc_r+0x1a8>
8000693a:	f2 0a 16 12 	lsr	r10,r9,0x12
8000693e:	28 4a       	sub	r10,-124
80006940:	e0 6b 05 30 	mov	r11,1328
80006944:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006948:	68 28       	ld.w	r8,r4[0x8]
8000694a:	08 38       	cp.w	r8,r4
8000694c:	c0 e1       	brne	80006968 <_malloc_r+0x1d0>
8000694e:	76 19       	ld.w	r9,r11[0x4]
80006950:	a3 4a       	asr	r10,0x2
80006952:	30 1e       	mov	lr,1
80006954:	fc 0a 09 4a 	lsl	r10,lr,r10
80006958:	f3 ea 10 0a 	or	r10,r9,r10
8000695c:	10 99       	mov	r9,r8
8000695e:	97 1a       	st.w	r11[0x4],r10
80006960:	c0 a8       	rjmp	80006974 <_malloc_r+0x1dc>
80006962:	70 28       	ld.w	r8,r8[0x8]
80006964:	08 38       	cp.w	r8,r4
80006966:	c0 60       	breq	80006972 <_malloc_r+0x1da>
80006968:	70 1a       	ld.w	r10,r8[0x4]
8000696a:	e0 1a ff fc 	andl	r10,0xfffc
8000696e:	14 39       	cp.w	r9,r10
80006970:	cf 93       	brcs	80006962 <_malloc_r+0x1ca>
80006972:	70 39       	ld.w	r9,r8[0xc]
80006974:	8d 39       	st.w	r6[0xc],r9
80006976:	8d 28       	st.w	r6[0x8],r8
80006978:	91 36       	st.w	r8[0xc],r6
8000697a:	93 26       	st.w	r9[0x8],r6
8000697c:	e6 08 14 02 	asr	r8,r3,0x2
80006980:	30 1b       	mov	r11,1
80006982:	e0 64 05 30 	mov	r4,1328
80006986:	f6 08 09 4b 	lsl	r11,r11,r8
8000698a:	68 18       	ld.w	r8,r4[0x4]
8000698c:	10 3b       	cp.w	r11,r8
8000698e:	e0 8b 00 6b 	brhi	80006a64 <_malloc_r+0x2cc>
80006992:	f7 e8 00 09 	and	r9,r11,r8
80006996:	c0 b1       	brne	800069ac <_malloc_r+0x214>
80006998:	e0 13 ff fc 	andl	r3,0xfffc
8000699c:	a1 7b       	lsl	r11,0x1
8000699e:	2f c3       	sub	r3,-4
800069a0:	c0 38       	rjmp	800069a6 <_malloc_r+0x20e>
800069a2:	2f c3       	sub	r3,-4
800069a4:	a1 7b       	lsl	r11,0x1
800069a6:	f7 e8 00 09 	and	r9,r11,r8
800069aa:	cf c0       	breq	800069a2 <_malloc_r+0x20a>
800069ac:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800069b0:	06 92       	mov	r2,r3
800069b2:	1c 91       	mov	r1,lr
800069b4:	62 36       	ld.w	r6,r1[0xc]
800069b6:	c2 e8       	rjmp	80006a12 <_malloc_r+0x27a>
800069b8:	6c 1a       	ld.w	r10,r6[0x4]
800069ba:	e0 1a ff fc 	andl	r10,0xfffc
800069be:	f4 07 01 08 	sub	r8,r10,r7
800069c2:	58 f8       	cp.w	r8,15
800069c4:	e0 8a 00 15 	brle	800069ee <_malloc_r+0x256>
800069c8:	6c 3a       	ld.w	r10,r6[0xc]
800069ca:	6c 29       	ld.w	r9,r6[0x8]
800069cc:	95 29       	st.w	r10[0x8],r9
800069ce:	93 3a       	st.w	r9[0xc],r10
800069d0:	0e 99       	mov	r9,r7
800069d2:	ec 07 00 07 	add	r7,r6,r7
800069d6:	a1 a9       	sbr	r9,0x0
800069d8:	99 37       	st.w	r12[0xc],r7
800069da:	99 27       	st.w	r12[0x8],r7
800069dc:	8d 19       	st.w	r6[0x4],r9
800069de:	ee 08 09 08 	st.w	r7[r8],r8
800069e2:	8f 2c       	st.w	r7[0x8],r12
800069e4:	8f 3c       	st.w	r7[0xc],r12
800069e6:	a1 a8       	sbr	r8,0x0
800069e8:	0a 9c       	mov	r12,r5
800069ea:	8f 18       	st.w	r7[0x4],r8
800069ec:	c0 d8       	rjmp	80006a06 <_malloc_r+0x26e>
800069ee:	6c 39       	ld.w	r9,r6[0xc]
800069f0:	58 08       	cp.w	r8,0
800069f2:	c0 f5       	brlt	80006a10 <_malloc_r+0x278>
800069f4:	ec 0a 00 0a 	add	r10,r6,r10
800069f8:	74 18       	ld.w	r8,r10[0x4]
800069fa:	a1 a8       	sbr	r8,0x0
800069fc:	0a 9c       	mov	r12,r5
800069fe:	95 18       	st.w	r10[0x4],r8
80006a00:	6c 28       	ld.w	r8,r6[0x8]
80006a02:	93 28       	st.w	r9[0x8],r8
80006a04:	91 39       	st.w	r8[0xc],r9
80006a06:	fe b0 f4 3b 	rcall	8000527c <__malloc_unlock>
80006a0a:	ec cc ff f8 	sub	r12,r6,-8
80006a0e:	d8 32       	popm	r0-r7,pc
80006a10:	12 96       	mov	r6,r9
80006a12:	02 36       	cp.w	r6,r1
80006a14:	cd 21       	brne	800069b8 <_malloc_r+0x220>
80006a16:	2f f2       	sub	r2,-1
80006a18:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006a1c:	c0 30       	breq	80006a22 <_malloc_r+0x28a>
80006a1e:	2f 81       	sub	r1,-8
80006a20:	cc ab       	rjmp	800069b4 <_malloc_r+0x21c>
80006a22:	1c 98       	mov	r8,lr
80006a24:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006a28:	c0 81       	brne	80006a38 <_malloc_r+0x2a0>
80006a2a:	68 19       	ld.w	r9,r4[0x4]
80006a2c:	f6 08 11 ff 	rsub	r8,r11,-1
80006a30:	f3 e8 00 08 	and	r8,r9,r8
80006a34:	89 18       	st.w	r4[0x4],r8
80006a36:	c0 78       	rjmp	80006a44 <_malloc_r+0x2ac>
80006a38:	f0 c9 00 08 	sub	r9,r8,8
80006a3c:	20 13       	sub	r3,1
80006a3e:	70 08       	ld.w	r8,r8[0x0]
80006a40:	12 38       	cp.w	r8,r9
80006a42:	cf 10       	breq	80006a24 <_malloc_r+0x28c>
80006a44:	a1 7b       	lsl	r11,0x1
80006a46:	68 18       	ld.w	r8,r4[0x4]
80006a48:	10 3b       	cp.w	r11,r8
80006a4a:	e0 8b 00 0d 	brhi	80006a64 <_malloc_r+0x2cc>
80006a4e:	58 0b       	cp.w	r11,0
80006a50:	c0 a0       	breq	80006a64 <_malloc_r+0x2cc>
80006a52:	04 93       	mov	r3,r2
80006a54:	c0 38       	rjmp	80006a5a <_malloc_r+0x2c2>
80006a56:	2f c3       	sub	r3,-4
80006a58:	a1 7b       	lsl	r11,0x1
80006a5a:	f7 e8 00 09 	and	r9,r11,r8
80006a5e:	ca 71       	brne	800069ac <_malloc_r+0x214>
80006a60:	cf bb       	rjmp	80006a56 <_malloc_r+0x2be>
80006a62:	d7 03       	nop
80006a64:	68 23       	ld.w	r3,r4[0x8]
80006a66:	66 12       	ld.w	r2,r3[0x4]
80006a68:	e0 12 ff fc 	andl	r2,0xfffc
80006a6c:	0e 32       	cp.w	r2,r7
80006a6e:	5f 39       	srlo	r9
80006a70:	e4 07 01 08 	sub	r8,r2,r7
80006a74:	58 f8       	cp.w	r8,15
80006a76:	5f aa       	srle	r10
80006a78:	f5 e9 10 09 	or	r9,r10,r9
80006a7c:	e0 80 00 9a 	breq	80006bb0 <_malloc_r+0x418>
80006a80:	e0 68 0d 68 	mov	r8,3432
80006a84:	70 01       	ld.w	r1,r8[0x0]
80006a86:	e0 68 09 3c 	mov	r8,2364
80006a8a:	2f 01       	sub	r1,-16
80006a8c:	70 08       	ld.w	r8,r8[0x0]
80006a8e:	0e 01       	add	r1,r7
80006a90:	5b f8       	cp.w	r8,-1
80006a92:	c0 40       	breq	80006a9a <_malloc_r+0x302>
80006a94:	28 11       	sub	r1,-127
80006a96:	e0 11 ff 80 	andl	r1,0xff80
80006a9a:	02 9b       	mov	r11,r1
80006a9c:	0a 9c       	mov	r12,r5
80006a9e:	e0 a0 02 a5 	rcall	80006fe8 <_sbrk_r>
80006aa2:	18 96       	mov	r6,r12
80006aa4:	5b fc       	cp.w	r12,-1
80006aa6:	c7 50       	breq	80006b90 <_malloc_r+0x3f8>
80006aa8:	e6 02 00 08 	add	r8,r3,r2
80006aac:	10 3c       	cp.w	r12,r8
80006aae:	c0 32       	brcc	80006ab4 <_malloc_r+0x31c>
80006ab0:	08 33       	cp.w	r3,r4
80006ab2:	c6 f1       	brne	80006b90 <_malloc_r+0x3f8>
80006ab4:	e0 6a 0d 6c 	mov	r10,3436
80006ab8:	74 09       	ld.w	r9,r10[0x0]
80006aba:	e2 09 00 09 	add	r9,r1,r9
80006abe:	95 09       	st.w	r10[0x0],r9
80006ac0:	10 36       	cp.w	r6,r8
80006ac2:	c0 a1       	brne	80006ad6 <_malloc_r+0x33e>
80006ac4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006ac8:	c0 71       	brne	80006ad6 <_malloc_r+0x33e>
80006aca:	e2 02 00 02 	add	r2,r1,r2
80006ace:	68 28       	ld.w	r8,r4[0x8]
80006ad0:	a1 a2       	sbr	r2,0x0
80006ad2:	91 12       	st.w	r8[0x4],r2
80006ad4:	c4 f8       	rjmp	80006b72 <_malloc_r+0x3da>
80006ad6:	e0 6a 09 3c 	mov	r10,2364
80006ada:	74 0b       	ld.w	r11,r10[0x0]
80006adc:	5b fb       	cp.w	r11,-1
80006ade:	c0 31       	brne	80006ae4 <_malloc_r+0x34c>
80006ae0:	95 06       	st.w	r10[0x0],r6
80006ae2:	c0 78       	rjmp	80006af0 <_malloc_r+0x358>
80006ae4:	ec 09 00 09 	add	r9,r6,r9
80006ae8:	e0 6a 0d 6c 	mov	r10,3436
80006aec:	10 19       	sub	r9,r8
80006aee:	95 09       	st.w	r10[0x0],r9
80006af0:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006af4:	f0 09 11 08 	rsub	r9,r8,8
80006af8:	58 08       	cp.w	r8,0
80006afa:	f2 08 17 10 	movne	r8,r9
80006afe:	ed d8 e1 06 	addne	r6,r6,r8
80006b02:	28 08       	sub	r8,-128
80006b04:	ec 01 00 01 	add	r1,r6,r1
80006b08:	0a 9c       	mov	r12,r5
80006b0a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006b0e:	f0 01 01 01 	sub	r1,r8,r1
80006b12:	02 9b       	mov	r11,r1
80006b14:	e0 a0 02 6a 	rcall	80006fe8 <_sbrk_r>
80006b18:	e0 68 0d 6c 	mov	r8,3436
80006b1c:	5b fc       	cp.w	r12,-1
80006b1e:	ec 0c 17 00 	moveq	r12,r6
80006b22:	f9 b1 00 00 	moveq	r1,0
80006b26:	70 09       	ld.w	r9,r8[0x0]
80006b28:	0c 1c       	sub	r12,r6
80006b2a:	89 26       	st.w	r4[0x8],r6
80006b2c:	02 0c       	add	r12,r1
80006b2e:	12 01       	add	r1,r9
80006b30:	a1 ac       	sbr	r12,0x0
80006b32:	91 01       	st.w	r8[0x0],r1
80006b34:	8d 1c       	st.w	r6[0x4],r12
80006b36:	08 33       	cp.w	r3,r4
80006b38:	c1 d0       	breq	80006b72 <_malloc_r+0x3da>
80006b3a:	58 f2       	cp.w	r2,15
80006b3c:	e0 8b 00 05 	brhi	80006b46 <_malloc_r+0x3ae>
80006b40:	30 18       	mov	r8,1
80006b42:	8d 18       	st.w	r6[0x4],r8
80006b44:	c2 68       	rjmp	80006b90 <_malloc_r+0x3f8>
80006b46:	30 59       	mov	r9,5
80006b48:	20 c2       	sub	r2,12
80006b4a:	e0 12 ff f8 	andl	r2,0xfff8
80006b4e:	e6 02 00 08 	add	r8,r3,r2
80006b52:	91 29       	st.w	r8[0x8],r9
80006b54:	91 19       	st.w	r8[0x4],r9
80006b56:	66 18       	ld.w	r8,r3[0x4]
80006b58:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006b5c:	e5 e8 10 08 	or	r8,r2,r8
80006b60:	87 18       	st.w	r3[0x4],r8
80006b62:	58 f2       	cp.w	r2,15
80006b64:	e0 88 00 07 	brls	80006b72 <_malloc_r+0x3da>
80006b68:	e6 cb ff f8 	sub	r11,r3,-8
80006b6c:	0a 9c       	mov	r12,r5
80006b6e:	e0 a0 1c 77 	rcall	8000a45c <_free_r>
80006b72:	e0 69 0d 64 	mov	r9,3428
80006b76:	72 0a       	ld.w	r10,r9[0x0]
80006b78:	e0 68 0d 6c 	mov	r8,3436
80006b7c:	70 08       	ld.w	r8,r8[0x0]
80006b7e:	14 38       	cp.w	r8,r10
80006b80:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006b84:	e0 69 0d 60 	mov	r9,3424
80006b88:	72 0a       	ld.w	r10,r9[0x0]
80006b8a:	14 38       	cp.w	r8,r10
80006b8c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006b90:	68 28       	ld.w	r8,r4[0x8]
80006b92:	70 18       	ld.w	r8,r8[0x4]
80006b94:	e0 18 ff fc 	andl	r8,0xfffc
80006b98:	0e 38       	cp.w	r8,r7
80006b9a:	5f 39       	srlo	r9
80006b9c:	0e 18       	sub	r8,r7
80006b9e:	58 f8       	cp.w	r8,15
80006ba0:	5f aa       	srle	r10
80006ba2:	f5 e9 10 09 	or	r9,r10,r9
80006ba6:	c0 50       	breq	80006bb0 <_malloc_r+0x418>
80006ba8:	0a 9c       	mov	r12,r5
80006baa:	fe b0 f3 69 	rcall	8000527c <__malloc_unlock>
80006bae:	d8 3a       	popm	r0-r7,pc,r12=0
80006bb0:	68 26       	ld.w	r6,r4[0x8]
80006bb2:	a1 a8       	sbr	r8,0x0
80006bb4:	0e 99       	mov	r9,r7
80006bb6:	a1 a9       	sbr	r9,0x0
80006bb8:	8d 19       	st.w	r6[0x4],r9
80006bba:	ec 07 00 07 	add	r7,r6,r7
80006bbe:	0a 9c       	mov	r12,r5
80006bc0:	89 27       	st.w	r4[0x8],r7
80006bc2:	8f 18       	st.w	r7[0x4],r8
80006bc4:	fe b0 f3 5c 	rcall	8000527c <__malloc_unlock>
80006bc8:	ec cc ff f8 	sub	r12,r6,-8
80006bcc:	d8 32       	popm	r0-r7,pc
80006bce:	d7 03       	nop

80006bd0 <memcpy>:
80006bd0:	58 8a       	cp.w	r10,8
80006bd2:	c2 f5       	brlt	80006c30 <memcpy+0x60>
80006bd4:	f9 eb 10 09 	or	r9,r12,r11
80006bd8:	e2 19 00 03 	andl	r9,0x3,COH
80006bdc:	e0 81 00 97 	brne	80006d0a <memcpy+0x13a>
80006be0:	e0 4a 00 20 	cp.w	r10,32
80006be4:	c3 b4       	brge	80006c5a <memcpy+0x8a>
80006be6:	f4 08 14 02 	asr	r8,r10,0x2
80006bea:	f0 09 11 08 	rsub	r9,r8,8
80006bee:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006bf2:	76 69       	ld.w	r9,r11[0x18]
80006bf4:	99 69       	st.w	r12[0x18],r9
80006bf6:	76 59       	ld.w	r9,r11[0x14]
80006bf8:	99 59       	st.w	r12[0x14],r9
80006bfa:	76 49       	ld.w	r9,r11[0x10]
80006bfc:	99 49       	st.w	r12[0x10],r9
80006bfe:	76 39       	ld.w	r9,r11[0xc]
80006c00:	99 39       	st.w	r12[0xc],r9
80006c02:	76 29       	ld.w	r9,r11[0x8]
80006c04:	99 29       	st.w	r12[0x8],r9
80006c06:	76 19       	ld.w	r9,r11[0x4]
80006c08:	99 19       	st.w	r12[0x4],r9
80006c0a:	76 09       	ld.w	r9,r11[0x0]
80006c0c:	99 09       	st.w	r12[0x0],r9
80006c0e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006c12:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006c16:	e0 1a 00 03 	andl	r10,0x3
80006c1a:	f4 0a 11 04 	rsub	r10,r10,4
80006c1e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006c22:	17 a9       	ld.ub	r9,r11[0x2]
80006c24:	b0 a9       	st.b	r8[0x2],r9
80006c26:	17 99       	ld.ub	r9,r11[0x1]
80006c28:	b0 99       	st.b	r8[0x1],r9
80006c2a:	17 89       	ld.ub	r9,r11[0x0]
80006c2c:	b0 89       	st.b	r8[0x0],r9
80006c2e:	5e fc       	retal	r12
80006c30:	f4 0a 11 09 	rsub	r10,r10,9
80006c34:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006c38:	17 f9       	ld.ub	r9,r11[0x7]
80006c3a:	b8 f9       	st.b	r12[0x7],r9
80006c3c:	17 e9       	ld.ub	r9,r11[0x6]
80006c3e:	b8 e9       	st.b	r12[0x6],r9
80006c40:	17 d9       	ld.ub	r9,r11[0x5]
80006c42:	b8 d9       	st.b	r12[0x5],r9
80006c44:	17 c9       	ld.ub	r9,r11[0x4]
80006c46:	b8 c9       	st.b	r12[0x4],r9
80006c48:	17 b9       	ld.ub	r9,r11[0x3]
80006c4a:	b8 b9       	st.b	r12[0x3],r9
80006c4c:	17 a9       	ld.ub	r9,r11[0x2]
80006c4e:	b8 a9       	st.b	r12[0x2],r9
80006c50:	17 99       	ld.ub	r9,r11[0x1]
80006c52:	b8 99       	st.b	r12[0x1],r9
80006c54:	17 89       	ld.ub	r9,r11[0x0]
80006c56:	b8 89       	st.b	r12[0x0],r9
80006c58:	5e fc       	retal	r12
80006c5a:	eb cd 40 c0 	pushm	r6-r7,lr
80006c5e:	18 99       	mov	r9,r12
80006c60:	22 0a       	sub	r10,32
80006c62:	b7 07       	ld.d	r6,r11++
80006c64:	b3 26       	st.d	r9++,r6
80006c66:	b7 07       	ld.d	r6,r11++
80006c68:	b3 26       	st.d	r9++,r6
80006c6a:	b7 07       	ld.d	r6,r11++
80006c6c:	b3 26       	st.d	r9++,r6
80006c6e:	b7 07       	ld.d	r6,r11++
80006c70:	b3 26       	st.d	r9++,r6
80006c72:	22 0a       	sub	r10,32
80006c74:	cf 74       	brge	80006c62 <memcpy+0x92>
80006c76:	2f 0a       	sub	r10,-16
80006c78:	c0 65       	brlt	80006c84 <memcpy+0xb4>
80006c7a:	b7 07       	ld.d	r6,r11++
80006c7c:	b3 26       	st.d	r9++,r6
80006c7e:	b7 07       	ld.d	r6,r11++
80006c80:	b3 26       	st.d	r9++,r6
80006c82:	21 0a       	sub	r10,16
80006c84:	5c 3a       	neg	r10
80006c86:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006c8a:	d7 03       	nop
80006c8c:	d7 03       	nop
80006c8e:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006c92:	f3 66 00 0e 	st.b	r9[14],r6
80006c96:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006c9a:	f3 66 00 0d 	st.b	r9[13],r6
80006c9e:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006ca2:	f3 66 00 0c 	st.b	r9[12],r6
80006ca6:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006caa:	f3 66 00 0b 	st.b	r9[11],r6
80006cae:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006cb2:	f3 66 00 0a 	st.b	r9[10],r6
80006cb6:	f7 36 00 09 	ld.ub	r6,r11[9]
80006cba:	f3 66 00 09 	st.b	r9[9],r6
80006cbe:	f7 36 00 08 	ld.ub	r6,r11[8]
80006cc2:	f3 66 00 08 	st.b	r9[8],r6
80006cc6:	f7 36 00 07 	ld.ub	r6,r11[7]
80006cca:	f3 66 00 07 	st.b	r9[7],r6
80006cce:	f7 36 00 06 	ld.ub	r6,r11[6]
80006cd2:	f3 66 00 06 	st.b	r9[6],r6
80006cd6:	f7 36 00 05 	ld.ub	r6,r11[5]
80006cda:	f3 66 00 05 	st.b	r9[5],r6
80006cde:	f7 36 00 04 	ld.ub	r6,r11[4]
80006ce2:	f3 66 00 04 	st.b	r9[4],r6
80006ce6:	f7 36 00 03 	ld.ub	r6,r11[3]
80006cea:	f3 66 00 03 	st.b	r9[3],r6
80006cee:	f7 36 00 02 	ld.ub	r6,r11[2]
80006cf2:	f3 66 00 02 	st.b	r9[2],r6
80006cf6:	f7 36 00 01 	ld.ub	r6,r11[1]
80006cfa:	f3 66 00 01 	st.b	r9[1],r6
80006cfe:	f7 36 00 00 	ld.ub	r6,r11[0]
80006d02:	f3 66 00 00 	st.b	r9[0],r6
80006d06:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006d0a:	20 1a       	sub	r10,1
80006d0c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006d10:	f8 0a 0b 09 	st.b	r12[r10],r9
80006d14:	cf b1       	brne	80006d0a <memcpy+0x13a>
80006d16:	5e fc       	retal	r12

80006d18 <memset>:
80006d18:	18 98       	mov	r8,r12
80006d1a:	c0 38       	rjmp	80006d20 <memset+0x8>
80006d1c:	10 cb       	st.b	r8++,r11
80006d1e:	20 1a       	sub	r10,1
80006d20:	58 0a       	cp.w	r10,0
80006d22:	cf d1       	brne	80006d1c <memset+0x4>
80006d24:	5e fc       	retal	r12
80006d26:	d7 03       	nop

80006d28 <_realloc_r>:
80006d28:	d4 31       	pushm	r0-r7,lr
80006d2a:	20 1d       	sub	sp,4
80006d2c:	16 94       	mov	r4,r11
80006d2e:	18 92       	mov	r2,r12
80006d30:	14 9b       	mov	r11,r10
80006d32:	58 04       	cp.w	r4,0
80006d34:	c0 51       	brne	80006d3e <_realloc_r+0x16>
80006d36:	fe b0 fd 31 	rcall	80006798 <_malloc_r>
80006d3a:	18 95       	mov	r5,r12
80006d3c:	c5 39       	rjmp	80006fe2 <_realloc_r+0x2ba>
80006d3e:	50 0a       	stdsp	sp[0x0],r10
80006d40:	fe b0 f2 98 	rcall	80005270 <__malloc_lock>
80006d44:	40 0b       	lddsp	r11,sp[0x0]
80006d46:	f6 c8 ff f5 	sub	r8,r11,-11
80006d4a:	e8 c1 00 08 	sub	r1,r4,8
80006d4e:	10 96       	mov	r6,r8
80006d50:	62 1c       	ld.w	r12,r1[0x4]
80006d52:	e0 16 ff f8 	andl	r6,0xfff8
80006d56:	59 68       	cp.w	r8,22
80006d58:	f9 b6 08 10 	movls	r6,16
80006d5c:	16 36       	cp.w	r6,r11
80006d5e:	5f 38       	srlo	r8
80006d60:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006d64:	c0 50       	breq	80006d6e <_realloc_r+0x46>
80006d66:	30 c8       	mov	r8,12
80006d68:	30 05       	mov	r5,0
80006d6a:	85 38       	st.w	r2[0xc],r8
80006d6c:	c3 b9       	rjmp	80006fe2 <_realloc_r+0x2ba>
80006d6e:	18 90       	mov	r0,r12
80006d70:	e0 10 ff fc 	andl	r0,0xfffc
80006d74:	0c 30       	cp.w	r0,r6
80006d76:	e0 84 01 0b 	brge	80006f8c <_realloc_r+0x264>
80006d7a:	e0 68 05 30 	mov	r8,1328
80006d7e:	e2 00 00 09 	add	r9,r1,r0
80006d82:	70 25       	ld.w	r5,r8[0x8]
80006d84:	0a 39       	cp.w	r9,r5
80006d86:	c0 90       	breq	80006d98 <_realloc_r+0x70>
80006d88:	72 1a       	ld.w	r10,r9[0x4]
80006d8a:	a1 ca       	cbr	r10,0x0
80006d8c:	f2 0a 00 0a 	add	r10,r9,r10
80006d90:	74 1a       	ld.w	r10,r10[0x4]
80006d92:	ed ba 00 00 	bld	r10,0x0
80006d96:	c2 20       	breq	80006dda <_realloc_r+0xb2>
80006d98:	72 1a       	ld.w	r10,r9[0x4]
80006d9a:	e0 1a ff fc 	andl	r10,0xfffc
80006d9e:	f4 00 00 03 	add	r3,r10,r0
80006da2:	0a 39       	cp.w	r9,r5
80006da4:	c1 31       	brne	80006dca <_realloc_r+0xa2>
80006da6:	ec c7 ff f0 	sub	r7,r6,-16
80006daa:	0e 33       	cp.w	r3,r7
80006dac:	c1 95       	brlt	80006dde <_realloc_r+0xb6>
80006dae:	e2 06 00 09 	add	r9,r1,r6
80006db2:	0c 13       	sub	r3,r6
80006db4:	a1 a3       	sbr	r3,0x0
80006db6:	93 13       	st.w	r9[0x4],r3
80006db8:	91 29       	st.w	r8[0x8],r9
80006dba:	04 9c       	mov	r12,r2
80006dbc:	62 18       	ld.w	r8,r1[0x4]
80006dbe:	08 95       	mov	r5,r4
80006dc0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006dc4:	10 46       	or	r6,r8
80006dc6:	83 16       	st.w	r1[0x4],r6
80006dc8:	c0 b9       	rjmp	80006fde <_realloc_r+0x2b6>
80006dca:	0c 33       	cp.w	r3,r6
80006dcc:	c0 95       	brlt	80006dde <_realloc_r+0xb6>
80006dce:	72 28       	ld.w	r8,r9[0x8]
80006dd0:	02 97       	mov	r7,r1
80006dd2:	72 39       	ld.w	r9,r9[0xc]
80006dd4:	93 28       	st.w	r9[0x8],r8
80006dd6:	91 39       	st.w	r8[0xc],r9
80006dd8:	cd c8       	rjmp	80006f90 <_realloc_r+0x268>
80006dda:	30 0a       	mov	r10,0
80006ddc:	14 99       	mov	r9,r10
80006dde:	ed bc 00 00 	bld	r12,0x0
80006de2:	e0 80 00 95 	breq	80006f0c <_realloc_r+0x1e4>
80006de6:	62 07       	ld.w	r7,r1[0x0]
80006de8:	e2 07 01 07 	sub	r7,r1,r7
80006dec:	6e 1c       	ld.w	r12,r7[0x4]
80006dee:	e0 1c ff fc 	andl	r12,0xfffc
80006df2:	58 09       	cp.w	r9,0
80006df4:	c5 60       	breq	80006ea0 <_realloc_r+0x178>
80006df6:	f8 00 00 03 	add	r3,r12,r0
80006dfa:	0a 39       	cp.w	r9,r5
80006dfc:	c4 81       	brne	80006e8c <_realloc_r+0x164>
80006dfe:	14 03       	add	r3,r10
80006e00:	ec c9 ff f0 	sub	r9,r6,-16
80006e04:	12 33       	cp.w	r3,r9
80006e06:	c4 d5       	brlt	80006ea0 <_realloc_r+0x178>
80006e08:	6e 3a       	ld.w	r10,r7[0xc]
80006e0a:	6e 29       	ld.w	r9,r7[0x8]
80006e0c:	95 29       	st.w	r10[0x8],r9
80006e0e:	93 3a       	st.w	r9[0xc],r10
80006e10:	ee c5 ff f8 	sub	r5,r7,-8
80006e14:	e0 ca 00 04 	sub	r10,r0,4
80006e18:	e0 4a 00 24 	cp.w	r10,36
80006e1c:	e0 8b 00 25 	brhi	80006e66 <_realloc_r+0x13e>
80006e20:	0a 99       	mov	r9,r5
80006e22:	59 3a       	cp.w	r10,19
80006e24:	e0 88 00 1a 	brls	80006e58 <_realloc_r+0x130>
80006e28:	09 09       	ld.w	r9,r4++
80006e2a:	8b 09       	st.w	r5[0x0],r9
80006e2c:	09 09       	ld.w	r9,r4++
80006e2e:	8f 39       	st.w	r7[0xc],r9
80006e30:	ee c9 ff f0 	sub	r9,r7,-16
80006e34:	59 ba       	cp.w	r10,27
80006e36:	e0 88 00 11 	brls	80006e58 <_realloc_r+0x130>
80006e3a:	09 0b       	ld.w	r11,r4++
80006e3c:	93 0b       	st.w	r9[0x0],r11
80006e3e:	09 09       	ld.w	r9,r4++
80006e40:	8f 59       	st.w	r7[0x14],r9
80006e42:	ee c9 ff e8 	sub	r9,r7,-24
80006e46:	e0 4a 00 24 	cp.w	r10,36
80006e4a:	c0 71       	brne	80006e58 <_realloc_r+0x130>
80006e4c:	09 0a       	ld.w	r10,r4++
80006e4e:	93 0a       	st.w	r9[0x0],r10
80006e50:	ee c9 ff e0 	sub	r9,r7,-32
80006e54:	09 0a       	ld.w	r10,r4++
80006e56:	8f 7a       	st.w	r7[0x1c],r10
80006e58:	09 0a       	ld.w	r10,r4++
80006e5a:	12 aa       	st.w	r9++,r10
80006e5c:	68 0a       	ld.w	r10,r4[0x0]
80006e5e:	93 0a       	st.w	r9[0x0],r10
80006e60:	68 1a       	ld.w	r10,r4[0x4]
80006e62:	93 1a       	st.w	r9[0x4],r10
80006e64:	c0 78       	rjmp	80006e72 <_realloc_r+0x14a>
80006e66:	50 08       	stdsp	sp[0x0],r8
80006e68:	08 9b       	mov	r11,r4
80006e6a:	0a 9c       	mov	r12,r5
80006e6c:	e0 a0 1d 9b 	rcall	8000a9a2 <memmove>
80006e70:	40 08       	lddsp	r8,sp[0x0]
80006e72:	ee 06 00 09 	add	r9,r7,r6
80006e76:	0c 13       	sub	r3,r6
80006e78:	a1 a3       	sbr	r3,0x0
80006e7a:	93 13       	st.w	r9[0x4],r3
80006e7c:	91 29       	st.w	r8[0x8],r9
80006e7e:	04 9c       	mov	r12,r2
80006e80:	6e 18       	ld.w	r8,r7[0x4]
80006e82:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006e86:	10 46       	or	r6,r8
80006e88:	8f 16       	st.w	r7[0x4],r6
80006e8a:	ca a8       	rjmp	80006fde <_realloc_r+0x2b6>
80006e8c:	14 03       	add	r3,r10
80006e8e:	0c 33       	cp.w	r3,r6
80006e90:	c0 85       	brlt	80006ea0 <_realloc_r+0x178>
80006e92:	72 28       	ld.w	r8,r9[0x8]
80006e94:	72 39       	ld.w	r9,r9[0xc]
80006e96:	93 28       	st.w	r9[0x8],r8
80006e98:	91 39       	st.w	r8[0xc],r9
80006e9a:	6e 28       	ld.w	r8,r7[0x8]
80006e9c:	6e 39       	ld.w	r9,r7[0xc]
80006e9e:	c0 78       	rjmp	80006eac <_realloc_r+0x184>
80006ea0:	f8 00 00 03 	add	r3,r12,r0
80006ea4:	0c 33       	cp.w	r3,r6
80006ea6:	c3 35       	brlt	80006f0c <_realloc_r+0x1e4>
80006ea8:	6e 39       	ld.w	r9,r7[0xc]
80006eaa:	6e 28       	ld.w	r8,r7[0x8]
80006eac:	93 28       	st.w	r9[0x8],r8
80006eae:	91 39       	st.w	r8[0xc],r9
80006eb0:	e0 ca 00 04 	sub	r10,r0,4
80006eb4:	ee cc ff f8 	sub	r12,r7,-8
80006eb8:	e0 4a 00 24 	cp.w	r10,36
80006ebc:	e0 8b 00 24 	brhi	80006f04 <_realloc_r+0x1dc>
80006ec0:	59 3a       	cp.w	r10,19
80006ec2:	e0 88 00 1a 	brls	80006ef6 <_realloc_r+0x1ce>
80006ec6:	09 08       	ld.w	r8,r4++
80006ec8:	99 08       	st.w	r12[0x0],r8
80006eca:	09 08       	ld.w	r8,r4++
80006ecc:	8f 38       	st.w	r7[0xc],r8
80006ece:	ee cc ff f0 	sub	r12,r7,-16
80006ed2:	59 ba       	cp.w	r10,27
80006ed4:	e0 88 00 11 	brls	80006ef6 <_realloc_r+0x1ce>
80006ed8:	09 08       	ld.w	r8,r4++
80006eda:	99 08       	st.w	r12[0x0],r8
80006edc:	09 08       	ld.w	r8,r4++
80006ede:	8f 58       	st.w	r7[0x14],r8
80006ee0:	ee cc ff e8 	sub	r12,r7,-24
80006ee4:	e0 4a 00 24 	cp.w	r10,36
80006ee8:	c0 71       	brne	80006ef6 <_realloc_r+0x1ce>
80006eea:	09 08       	ld.w	r8,r4++
80006eec:	99 08       	st.w	r12[0x0],r8
80006eee:	ee cc ff e0 	sub	r12,r7,-32
80006ef2:	09 08       	ld.w	r8,r4++
80006ef4:	8f 78       	st.w	r7[0x1c],r8
80006ef6:	09 08       	ld.w	r8,r4++
80006ef8:	18 a8       	st.w	r12++,r8
80006efa:	68 08       	ld.w	r8,r4[0x0]
80006efc:	99 08       	st.w	r12[0x0],r8
80006efe:	68 18       	ld.w	r8,r4[0x4]
80006f00:	99 18       	st.w	r12[0x4],r8
80006f02:	c4 78       	rjmp	80006f90 <_realloc_r+0x268>
80006f04:	08 9b       	mov	r11,r4
80006f06:	e0 a0 1d 4e 	rcall	8000a9a2 <memmove>
80006f0a:	c4 38       	rjmp	80006f90 <_realloc_r+0x268>
80006f0c:	04 9c       	mov	r12,r2
80006f0e:	fe b0 fc 45 	rcall	80006798 <_malloc_r>
80006f12:	18 95       	mov	r5,r12
80006f14:	c3 a0       	breq	80006f88 <_realloc_r+0x260>
80006f16:	62 18       	ld.w	r8,r1[0x4]
80006f18:	f8 c9 00 08 	sub	r9,r12,8
80006f1c:	a1 c8       	cbr	r8,0x0
80006f1e:	e2 08 00 08 	add	r8,r1,r8
80006f22:	10 39       	cp.w	r9,r8
80006f24:	c0 71       	brne	80006f32 <_realloc_r+0x20a>
80006f26:	72 13       	ld.w	r3,r9[0x4]
80006f28:	02 97       	mov	r7,r1
80006f2a:	e0 13 ff fc 	andl	r3,0xfffc
80006f2e:	00 03       	add	r3,r0
80006f30:	c3 08       	rjmp	80006f90 <_realloc_r+0x268>
80006f32:	e0 ca 00 04 	sub	r10,r0,4
80006f36:	e0 4a 00 24 	cp.w	r10,36
80006f3a:	e0 8b 00 20 	brhi	80006f7a <_realloc_r+0x252>
80006f3e:	08 99       	mov	r9,r4
80006f40:	18 98       	mov	r8,r12
80006f42:	59 3a       	cp.w	r10,19
80006f44:	e0 88 00 14 	brls	80006f6c <_realloc_r+0x244>
80006f48:	13 0b       	ld.w	r11,r9++
80006f4a:	10 ab       	st.w	r8++,r11
80006f4c:	13 0b       	ld.w	r11,r9++
80006f4e:	10 ab       	st.w	r8++,r11
80006f50:	59 ba       	cp.w	r10,27
80006f52:	e0 88 00 0d 	brls	80006f6c <_realloc_r+0x244>
80006f56:	13 0b       	ld.w	r11,r9++
80006f58:	10 ab       	st.w	r8++,r11
80006f5a:	13 0b       	ld.w	r11,r9++
80006f5c:	10 ab       	st.w	r8++,r11
80006f5e:	e0 4a 00 24 	cp.w	r10,36
80006f62:	c0 51       	brne	80006f6c <_realloc_r+0x244>
80006f64:	13 0a       	ld.w	r10,r9++
80006f66:	10 aa       	st.w	r8++,r10
80006f68:	13 0a       	ld.w	r10,r9++
80006f6a:	10 aa       	st.w	r8++,r10
80006f6c:	13 0a       	ld.w	r10,r9++
80006f6e:	10 aa       	st.w	r8++,r10
80006f70:	72 0a       	ld.w	r10,r9[0x0]
80006f72:	91 0a       	st.w	r8[0x0],r10
80006f74:	72 19       	ld.w	r9,r9[0x4]
80006f76:	91 19       	st.w	r8[0x4],r9
80006f78:	c0 48       	rjmp	80006f80 <_realloc_r+0x258>
80006f7a:	08 9b       	mov	r11,r4
80006f7c:	e0 a0 1d 13 	rcall	8000a9a2 <memmove>
80006f80:	08 9b       	mov	r11,r4
80006f82:	04 9c       	mov	r12,r2
80006f84:	e0 a0 1a 6c 	rcall	8000a45c <_free_r>
80006f88:	04 9c       	mov	r12,r2
80006f8a:	c2 a8       	rjmp	80006fde <_realloc_r+0x2b6>
80006f8c:	00 93       	mov	r3,r0
80006f8e:	02 97       	mov	r7,r1
80006f90:	e6 06 01 09 	sub	r9,r3,r6
80006f94:	6e 18       	ld.w	r8,r7[0x4]
80006f96:	58 f9       	cp.w	r9,15
80006f98:	e0 88 00 16 	brls	80006fc4 <_realloc_r+0x29c>
80006f9c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006fa0:	ed e8 10 08 	or	r8,r6,r8
80006fa4:	8f 18       	st.w	r7[0x4],r8
80006fa6:	12 98       	mov	r8,r9
80006fa8:	a1 a8       	sbr	r8,0x0
80006faa:	ee 06 00 0b 	add	r11,r7,r6
80006fae:	f6 09 00 09 	add	r9,r11,r9
80006fb2:	97 18       	st.w	r11[0x4],r8
80006fb4:	72 18       	ld.w	r8,r9[0x4]
80006fb6:	a1 a8       	sbr	r8,0x0
80006fb8:	2f 8b       	sub	r11,-8
80006fba:	93 18       	st.w	r9[0x4],r8
80006fbc:	04 9c       	mov	r12,r2
80006fbe:	e0 a0 1a 4f 	rcall	8000a45c <_free_r>
80006fc2:	c0 b8       	rjmp	80006fd8 <_realloc_r+0x2b0>
80006fc4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006fc8:	e7 e8 10 08 	or	r8,r3,r8
80006fcc:	8f 18       	st.w	r7[0x4],r8
80006fce:	ee 03 00 03 	add	r3,r7,r3
80006fd2:	66 18       	ld.w	r8,r3[0x4]
80006fd4:	a1 a8       	sbr	r8,0x0
80006fd6:	87 18       	st.w	r3[0x4],r8
80006fd8:	04 9c       	mov	r12,r2
80006fda:	ee c5 ff f8 	sub	r5,r7,-8
80006fde:	fe b0 f1 4f 	rcall	8000527c <__malloc_unlock>
80006fe2:	0a 9c       	mov	r12,r5
80006fe4:	2f fd       	sub	sp,-4
80006fe6:	d8 32       	popm	r0-r7,pc

80006fe8 <_sbrk_r>:
80006fe8:	d4 21       	pushm	r4-r7,lr
80006fea:	30 08       	mov	r8,0
80006fec:	18 97       	mov	r7,r12
80006fee:	e0 66 41 18 	mov	r6,16664
80006ff2:	16 9c       	mov	r12,r11
80006ff4:	8d 08       	st.w	r6[0x0],r8
80006ff6:	c9 1c       	rcall	80007118 <_sbrk>
80006ff8:	5b fc       	cp.w	r12,-1
80006ffa:	c0 51       	brne	80007004 <_sbrk_r+0x1c>
80006ffc:	6c 08       	ld.w	r8,r6[0x0]
80006ffe:	58 08       	cp.w	r8,0
80007000:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007004:	d8 22       	popm	r4-r7,pc
80007006:	d7 03       	nop

80007008 <sprintf>:
80007008:	d4 01       	pushm	lr
8000700a:	21 7d       	sub	sp,92
8000700c:	e0 68 ff ff 	mov	r8,65535
80007010:	ea 18 7f ff 	orh	r8,0x7fff
80007014:	50 58       	stdsp	sp[0x14],r8
80007016:	50 28       	stdsp	sp[0x8],r8
80007018:	e0 68 02 08 	mov	r8,520
8000701c:	ba 68       	st.h	sp[0xc],r8
8000701e:	3f f8       	mov	r8,-1
80007020:	ba 78       	st.h	sp[0xe],r8
80007022:	e0 68 0a 30 	mov	r8,2608
80007026:	50 4c       	stdsp	sp[0x10],r12
80007028:	16 9a       	mov	r10,r11
8000702a:	50 0c       	stdsp	sp[0x0],r12
8000702c:	fa c9 ff a0 	sub	r9,sp,-96
80007030:	70 0c       	ld.w	r12,r8[0x0]
80007032:	1a 9b       	mov	r11,sp
80007034:	e0 a0 02 26 	rcall	80007480 <_vfprintf_r>
80007038:	30 09       	mov	r9,0
8000703a:	40 08       	lddsp	r8,sp[0x0]
8000703c:	b0 89       	st.b	r8[0x0],r9
8000703e:	2e 9d       	sub	sp,-92
80007040:	d8 02       	popm	pc
80007042:	d7 03       	nop

80007044 <strlen>:
80007044:	30 09       	mov	r9,0
80007046:	18 98       	mov	r8,r12
80007048:	c0 28       	rjmp	8000704c <strlen+0x8>
8000704a:	2f f8       	sub	r8,-1
8000704c:	11 8a       	ld.ub	r10,r8[0x0]
8000704e:	f2 0a 18 00 	cp.b	r10,r9
80007052:	cf c1       	brne	8000704a <strlen+0x6>
80007054:	f0 0c 01 0c 	sub	r12,r8,r12
80007058:	5e fc       	retal	r12
8000705a:	d7 03       	nop

8000705c <strncpy>:
8000705c:	30 08       	mov	r8,0
8000705e:	10 3a       	cp.w	r10,r8
80007060:	5e 0c       	reteq	r12
80007062:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007066:	f8 08 0b 09 	st.b	r12[r8],r9
8000706a:	2f f8       	sub	r8,-1
8000706c:	58 09       	cp.w	r9,0
8000706e:	cf 81       	brne	8000705e <strncpy+0x2>
80007070:	10 3a       	cp.w	r10,r8
80007072:	5e 0c       	reteq	r12
80007074:	f8 08 0b 09 	st.b	r12[r8],r9
80007078:	2f f8       	sub	r8,-1
8000707a:	cf bb       	rjmp	80007070 <strncpy+0x14>

8000707c <_close>:
8000707c:	30 28       	mov	r8,2
8000707e:	d6 73       	breakpoint
80007080:	3f fc       	mov	r12,-1
80007082:	35 8b       	mov	r11,88
80007084:	58 0c       	cp.w	r12,0
80007086:	5e 4c       	retge	r12
80007088:	e0 6a 41 18 	mov	r10,16664
8000708c:	95 0b       	st.w	r10[0x0],r11
8000708e:	5e fc       	retal	r12

80007090 <_lseek>:
80007090:	30 58       	mov	r8,5
80007092:	d6 73       	breakpoint
80007094:	3f fc       	mov	r12,-1
80007096:	35 8b       	mov	r11,88
80007098:	58 0c       	cp.w	r12,0
8000709a:	5e 4c       	retge	r12
8000709c:	e0 6a 41 18 	mov	r10,16664
800070a0:	95 0b       	st.w	r10[0x0],r11
800070a2:	5e fc       	retal	r12

800070a4 <isatty>:
800070a4:	30 b8       	mov	r8,11
800070a6:	d6 73       	breakpoint
800070a8:	3f fc       	mov	r12,-1
800070aa:	35 8b       	mov	r11,88
800070ac:	58 0c       	cp.w	r12,0
800070ae:	5e 4c       	retge	r12
800070b0:	e0 6a 41 18 	mov	r10,16664
800070b4:	95 0b       	st.w	r10[0x0],r11
800070b6:	5e fc       	retal	r12

800070b8 <_fstat_host>:
800070b8:	30 98       	mov	r8,9
800070ba:	d6 73       	breakpoint
800070bc:	3f fc       	mov	r12,-1
800070be:	35 8b       	mov	r11,88
800070c0:	58 0c       	cp.w	r12,0
800070c2:	5e 4c       	retge	r12
800070c4:	e0 6a 41 18 	mov	r10,16664
800070c8:	95 0b       	st.w	r10[0x0],r11
800070ca:	5e fc       	retal	r12

800070cc <_fstat>:
800070cc:	d4 21       	pushm	r4-r7,lr
800070ce:	21 0d       	sub	sp,64
800070d0:	16 97       	mov	r7,r11
800070d2:	1a 9b       	mov	r11,sp
800070d4:	cf 2f       	rcall	800070b8 <_fstat_host>
800070d6:	c0 34       	brge	800070dc <_fstat+0x10>
800070d8:	3f fc       	mov	r12,-1
800070da:	c1 c8       	rjmp	80007112 <_fstat+0x46>
800070dc:	40 08       	lddsp	r8,sp[0x0]
800070de:	ae 08       	st.h	r7[0x0],r8
800070e0:	40 18       	lddsp	r8,sp[0x4]
800070e2:	ae 18       	st.h	r7[0x2],r8
800070e4:	40 28       	lddsp	r8,sp[0x8]
800070e6:	8f 18       	st.w	r7[0x4],r8
800070e8:	40 38       	lddsp	r8,sp[0xc]
800070ea:	ae 48       	st.h	r7[0x8],r8
800070ec:	40 48       	lddsp	r8,sp[0x10]
800070ee:	ae 58       	st.h	r7[0xa],r8
800070f0:	40 58       	lddsp	r8,sp[0x14]
800070f2:	ae 68       	st.h	r7[0xc],r8
800070f4:	40 68       	lddsp	r8,sp[0x18]
800070f6:	ae 78       	st.h	r7[0xe],r8
800070f8:	40 88       	lddsp	r8,sp[0x20]
800070fa:	8f 48       	st.w	r7[0x10],r8
800070fc:	40 a8       	lddsp	r8,sp[0x28]
800070fe:	8f b8       	st.w	r7[0x2c],r8
80007100:	40 c8       	lddsp	r8,sp[0x30]
80007102:	8f c8       	st.w	r7[0x30],r8
80007104:	40 d8       	lddsp	r8,sp[0x34]
80007106:	8f 58       	st.w	r7[0x14],r8
80007108:	40 e8       	lddsp	r8,sp[0x38]
8000710a:	30 0c       	mov	r12,0
8000710c:	8f 78       	st.w	r7[0x1c],r8
8000710e:	40 f8       	lddsp	r8,sp[0x3c]
80007110:	8f 98       	st.w	r7[0x24],r8
80007112:	2f 0d       	sub	sp,-64
80007114:	d8 22       	popm	r4-r7,pc
80007116:	d7 03       	nop

80007118 <_sbrk>:
80007118:	d4 01       	pushm	lr
8000711a:	e0 68 0d 94 	mov	r8,3476
8000711e:	70 09       	ld.w	r9,r8[0x0]
80007120:	58 09       	cp.w	r9,0
80007122:	c0 41       	brne	8000712a <_sbrk+0x12>
80007124:	e0 69 41 20 	mov	r9,16672
80007128:	91 09       	st.w	r8[0x0],r9
8000712a:	e0 69 0d 94 	mov	r9,3476
8000712e:	e0 7a 70 00 	mov	r10,94208
80007132:	72 08       	ld.w	r8,r9[0x0]
80007134:	f0 0c 00 0c 	add	r12,r8,r12
80007138:	14 3c       	cp.w	r12,r10
8000713a:	e0 8b 00 04 	brhi	80007142 <_sbrk+0x2a>
8000713e:	93 0c       	st.w	r9[0x0],r12
80007140:	c0 68       	rjmp	8000714c <_sbrk+0x34>
80007142:	e0 a0 18 15 	rcall	8000a16c <__errno>
80007146:	30 c8       	mov	r8,12
80007148:	99 08       	st.w	r12[0x0],r8
8000714a:	3f f8       	mov	r8,-1
8000714c:	10 9c       	mov	r12,r8
8000714e:	d8 02       	popm	pc

80007150 <get_arg>:
80007150:	d4 31       	pushm	r0-r7,lr
80007152:	20 8d       	sub	sp,32
80007154:	fa c4 ff bc 	sub	r4,sp,-68
80007158:	50 4b       	stdsp	sp[0x10],r11
8000715a:	68 2e       	ld.w	lr,r4[0x8]
8000715c:	50 58       	stdsp	sp[0x14],r8
8000715e:	12 96       	mov	r6,r9
80007160:	7c 0b       	ld.w	r11,lr[0x0]
80007162:	70 05       	ld.w	r5,r8[0x0]
80007164:	50 6e       	stdsp	sp[0x18],lr
80007166:	58 0b       	cp.w	r11,0
80007168:	f4 0b 17 00 	moveq	r11,r10
8000716c:	68 03       	ld.w	r3,r4[0x0]
8000716e:	68 11       	ld.w	r1,r4[0x4]
80007170:	40 49       	lddsp	r9,sp[0x10]
80007172:	30 08       	mov	r8,0
80007174:	c2 89       	rjmp	800073c4 <get_arg+0x274>
80007176:	2f fb       	sub	r11,-1
80007178:	32 5c       	mov	r12,37
8000717a:	17 8a       	ld.ub	r10,r11[0x0]
8000717c:	f8 0a 18 00 	cp.b	r10,r12
80007180:	5f 1e       	srne	lr
80007182:	f0 0a 18 00 	cp.b	r10,r8
80007186:	5f 1c       	srne	r12
80007188:	fd ec 00 0c 	and	r12,lr,r12
8000718c:	f0 0c 18 00 	cp.b	r12,r8
80007190:	cf 31       	brne	80007176 <get_arg+0x26>
80007192:	58 0a       	cp.w	r10,0
80007194:	e0 80 01 25 	breq	800073de <get_arg+0x28e>
80007198:	30 0c       	mov	r12,0
8000719a:	3f fa       	mov	r10,-1
8000719c:	18 90       	mov	r0,r12
8000719e:	50 3a       	stdsp	sp[0xc],r10
800071a0:	18 94       	mov	r4,r12
800071a2:	18 92       	mov	r2,r12
800071a4:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800071a8:	16 97       	mov	r7,r11
800071aa:	50 7c       	stdsp	sp[0x1c],r12
800071ac:	fe cc 9f 24 	sub	r12,pc,-24796
800071b0:	0f 3a       	ld.ub	r10,r7++
800071b2:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800071b6:	40 7c       	lddsp	r12,sp[0x1c]
800071b8:	1c 0c       	add	r12,lr
800071ba:	fe ce 9f fa 	sub	lr,pc,-24582
800071be:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800071c2:	20 1e       	sub	lr,1
800071c4:	50 0e       	stdsp	sp[0x0],lr
800071c6:	fe ce a0 72 	sub	lr,pc,-24462
800071ca:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800071ce:	50 7c       	stdsp	sp[0x1c],r12
800071d0:	40 0c       	lddsp	r12,sp[0x0]
800071d2:	58 7c       	cp.w	r12,7
800071d4:	e0 8b 00 f1 	brhi	800073b6 <get_arg+0x266>
800071d8:	fe ce a2 24 	sub	lr,pc,-24028
800071dc:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
800071e0:	36 8b       	mov	r11,104
800071e2:	f6 0a 18 00 	cp.b	r10,r11
800071e6:	e0 80 00 e8 	breq	800073b6 <get_arg+0x266>
800071ea:	37 1b       	mov	r11,113
800071ec:	f6 0a 18 00 	cp.b	r10,r11
800071f0:	c0 70       	breq	800071fe <get_arg+0xae>
800071f2:	34 cb       	mov	r11,76
800071f4:	f6 0a 18 00 	cp.b	r10,r11
800071f8:	c0 51       	brne	80007202 <get_arg+0xb2>
800071fa:	a3 b4       	sbr	r4,0x3
800071fc:	cd d8       	rjmp	800073b6 <get_arg+0x266>
800071fe:	a5 b4       	sbr	r4,0x5
80007200:	cd b8       	rjmp	800073b6 <get_arg+0x266>
80007202:	08 9a       	mov	r10,r4
80007204:	0e 9b       	mov	r11,r7
80007206:	a5 aa       	sbr	r10,0x4
80007208:	17 3c       	ld.ub	r12,r11++
8000720a:	a5 b4       	sbr	r4,0x5
8000720c:	36 ce       	mov	lr,108
8000720e:	fc 0c 18 00 	cp.b	r12,lr
80007212:	e0 80 00 d3 	breq	800073b8 <get_arg+0x268>
80007216:	14 94       	mov	r4,r10
80007218:	cc f8       	rjmp	800073b6 <get_arg+0x266>
8000721a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000721e:	36 7c       	mov	r12,103
80007220:	f8 0a 18 00 	cp.b	r10,r12
80007224:	e0 8b 00 27 	brhi	80007272 <get_arg+0x122>
80007228:	36 5b       	mov	r11,101
8000722a:	f6 0a 18 00 	cp.b	r10,r11
8000722e:	c4 82       	brcc	800072be <get_arg+0x16e>
80007230:	34 fb       	mov	r11,79
80007232:	f6 0a 18 00 	cp.b	r10,r11
80007236:	c4 80       	breq	800072c6 <get_arg+0x176>
80007238:	e0 8b 00 0c 	brhi	80007250 <get_arg+0x100>
8000723c:	34 5b       	mov	r11,69
8000723e:	f6 0a 18 00 	cp.b	r10,r11
80007242:	c3 e0       	breq	800072be <get_arg+0x16e>
80007244:	34 7b       	mov	r11,71
80007246:	f6 0a 18 00 	cp.b	r10,r11
8000724a:	c3 a0       	breq	800072be <get_arg+0x16e>
8000724c:	34 4b       	mov	r11,68
8000724e:	c0 88       	rjmp	8000725e <get_arg+0x10e>
80007250:	35 8b       	mov	r11,88
80007252:	f6 0a 18 00 	cp.b	r10,r11
80007256:	c2 c0       	breq	800072ae <get_arg+0x15e>
80007258:	e0 8b 00 07 	brhi	80007266 <get_arg+0x116>
8000725c:	35 5b       	mov	r11,85
8000725e:	f6 0a 18 00 	cp.b	r10,r11
80007262:	c3 51       	brne	800072cc <get_arg+0x17c>
80007264:	c3 18       	rjmp	800072c6 <get_arg+0x176>
80007266:	36 3b       	mov	r11,99
80007268:	f6 0a 18 00 	cp.b	r10,r11
8000726c:	c2 f0       	breq	800072ca <get_arg+0x17a>
8000726e:	36 4b       	mov	r11,100
80007270:	c0 e8       	rjmp	8000728c <get_arg+0x13c>
80007272:	37 0b       	mov	r11,112
80007274:	f6 0a 18 00 	cp.b	r10,r11
80007278:	c2 50       	breq	800072c2 <get_arg+0x172>
8000727a:	e0 8b 00 0d 	brhi	80007294 <get_arg+0x144>
8000727e:	36 eb       	mov	r11,110
80007280:	f6 0a 18 00 	cp.b	r10,r11
80007284:	c1 f0       	breq	800072c2 <get_arg+0x172>
80007286:	e0 8b 00 14 	brhi	800072ae <get_arg+0x15e>
8000728a:	36 9b       	mov	r11,105
8000728c:	f6 0a 18 00 	cp.b	r10,r11
80007290:	c1 e1       	brne	800072cc <get_arg+0x17c>
80007292:	c0 e8       	rjmp	800072ae <get_arg+0x15e>
80007294:	37 5b       	mov	r11,117
80007296:	f6 0a 18 00 	cp.b	r10,r11
8000729a:	c0 a0       	breq	800072ae <get_arg+0x15e>
8000729c:	37 8b       	mov	r11,120
8000729e:	f6 0a 18 00 	cp.b	r10,r11
800072a2:	c0 60       	breq	800072ae <get_arg+0x15e>
800072a4:	37 3b       	mov	r11,115
800072a6:	f6 0a 18 00 	cp.b	r10,r11
800072aa:	c1 11       	brne	800072cc <get_arg+0x17c>
800072ac:	c0 b8       	rjmp	800072c2 <get_arg+0x172>
800072ae:	ed b4 00 04 	bld	r4,0x4
800072b2:	c0 a0       	breq	800072c6 <get_arg+0x176>
800072b4:	ed b4 00 05 	bld	r4,0x5
800072b8:	c0 91       	brne	800072ca <get_arg+0x17a>
800072ba:	30 20       	mov	r0,2
800072bc:	c0 88       	rjmp	800072cc <get_arg+0x17c>
800072be:	30 40       	mov	r0,4
800072c0:	c0 68       	rjmp	800072cc <get_arg+0x17c>
800072c2:	30 30       	mov	r0,3
800072c4:	c0 48       	rjmp	800072cc <get_arg+0x17c>
800072c6:	30 10       	mov	r0,1
800072c8:	c0 28       	rjmp	800072cc <get_arg+0x17c>
800072ca:	30 00       	mov	r0,0
800072cc:	40 3b       	lddsp	r11,sp[0xc]
800072ce:	5b fb       	cp.w	r11,-1
800072d0:	c0 40       	breq	800072d8 <get_arg+0x188>
800072d2:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800072d6:	c7 08       	rjmp	800073b6 <get_arg+0x266>
800072d8:	58 60       	cp.w	r0,6
800072da:	e0 8b 00 6e 	brhi	800073b6 <get_arg+0x266>
800072de:	6c 0a       	ld.w	r10,r6[0x0]
800072e0:	ea cc ff ff 	sub	r12,r5,-1
800072e4:	fe ce a3 10 	sub	lr,pc,-23792
800072e8:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
800072ec:	f4 cb ff f8 	sub	r11,r10,-8
800072f0:	8d 0b       	st.w	r6[0x0],r11
800072f2:	f4 ea 00 00 	ld.d	r10,r10[0]
800072f6:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800072fa:	c0 f8       	rjmp	80007318 <get_arg+0x1c8>
800072fc:	f4 cb ff fc 	sub	r11,r10,-4
80007300:	8d 0b       	st.w	r6[0x0],r11
80007302:	74 0a       	ld.w	r10,r10[0x0]
80007304:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007308:	c0 88       	rjmp	80007318 <get_arg+0x1c8>
8000730a:	f4 cb ff f8 	sub	r11,r10,-8
8000730e:	8d 0b       	st.w	r6[0x0],r11
80007310:	f4 ea 00 00 	ld.d	r10,r10[0]
80007314:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007318:	0e 9b       	mov	r11,r7
8000731a:	18 95       	mov	r5,r12
8000731c:	c4 e8       	rjmp	800073b8 <get_arg+0x268>
8000731e:	62 0a       	ld.w	r10,r1[0x0]
80007320:	5b fa       	cp.w	r10,-1
80007322:	c0 b1       	brne	80007338 <get_arg+0x1e8>
80007324:	50 19       	stdsp	sp[0x4],r9
80007326:	50 28       	stdsp	sp[0x8],r8
80007328:	e0 6a 00 80 	mov	r10,128
8000732c:	30 0b       	mov	r11,0
8000732e:	02 9c       	mov	r12,r1
80007330:	fe b0 fc f4 	rcall	80006d18 <memset>
80007334:	40 28       	lddsp	r8,sp[0x8]
80007336:	40 19       	lddsp	r9,sp[0x4]
80007338:	e4 cc 00 01 	sub	r12,r2,1
8000733c:	0e 9b       	mov	r11,r7
8000733e:	50 3c       	stdsp	sp[0xc],r12
80007340:	f2 0c 0c 49 	max	r9,r9,r12
80007344:	c3 a8       	rjmp	800073b8 <get_arg+0x268>
80007346:	62 0a       	ld.w	r10,r1[0x0]
80007348:	5b fa       	cp.w	r10,-1
8000734a:	c0 b1       	brne	80007360 <get_arg+0x210>
8000734c:	50 19       	stdsp	sp[0x4],r9
8000734e:	50 28       	stdsp	sp[0x8],r8
80007350:	e0 6a 00 80 	mov	r10,128
80007354:	30 0b       	mov	r11,0
80007356:	02 9c       	mov	r12,r1
80007358:	fe b0 fc e0 	rcall	80006d18 <memset>
8000735c:	40 28       	lddsp	r8,sp[0x8]
8000735e:	40 19       	lddsp	r9,sp[0x4]
80007360:	20 12       	sub	r2,1
80007362:	30 0a       	mov	r10,0
80007364:	0e 9b       	mov	r11,r7
80007366:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000736a:	f2 02 0c 49 	max	r9,r9,r2
8000736e:	c2 58       	rjmp	800073b8 <get_arg+0x268>
80007370:	16 97       	mov	r7,r11
80007372:	6c 0a       	ld.w	r10,r6[0x0]
80007374:	f4 cb ff fc 	sub	r11,r10,-4
80007378:	8d 0b       	st.w	r6[0x0],r11
8000737a:	74 0a       	ld.w	r10,r10[0x0]
8000737c:	0e 9b       	mov	r11,r7
8000737e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007382:	2f f5       	sub	r5,-1
80007384:	c1 a8       	rjmp	800073b8 <get_arg+0x268>
80007386:	f4 c2 00 30 	sub	r2,r10,48
8000738a:	c0 68       	rjmp	80007396 <get_arg+0x246>
8000738c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007390:	2f f7       	sub	r7,-1
80007392:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007396:	0f 8a       	ld.ub	r10,r7[0x0]
80007398:	58 0a       	cp.w	r10,0
8000739a:	c0 e0       	breq	800073b6 <get_arg+0x266>
8000739c:	23 0a       	sub	r10,48
8000739e:	58 9a       	cp.w	r10,9
800073a0:	fe 98 ff f6 	brls	8000738c <get_arg+0x23c>
800073a4:	c0 98       	rjmp	800073b6 <get_arg+0x266>
800073a6:	2f f7       	sub	r7,-1
800073a8:	0f 8a       	ld.ub	r10,r7[0x0]
800073aa:	58 0a       	cp.w	r10,0
800073ac:	c0 50       	breq	800073b6 <get_arg+0x266>
800073ae:	23 0a       	sub	r10,48
800073b0:	58 9a       	cp.w	r10,9
800073b2:	fe 98 ff fa 	brls	800073a6 <get_arg+0x256>
800073b6:	0e 9b       	mov	r11,r7
800073b8:	40 7c       	lddsp	r12,sp[0x1c]
800073ba:	30 ba       	mov	r10,11
800073bc:	f4 0c 18 00 	cp.b	r12,r10
800073c0:	fe 91 fe f2 	brne	800071a4 <get_arg+0x54>
800073c4:	40 42       	lddsp	r2,sp[0x10]
800073c6:	17 8c       	ld.ub	r12,r11[0x0]
800073c8:	0a 32       	cp.w	r2,r5
800073ca:	5f 4a       	srge	r10
800073cc:	f0 0c 18 00 	cp.b	r12,r8
800073d0:	5f 1c       	srne	r12
800073d2:	f9 ea 00 0a 	and	r10,r12,r10
800073d6:	f0 0a 18 00 	cp.b	r10,r8
800073da:	fe 91 fe cf 	brne	80007178 <get_arg+0x28>
800073de:	30 08       	mov	r8,0
800073e0:	40 4e       	lddsp	lr,sp[0x10]
800073e2:	17 8a       	ld.ub	r10,r11[0x0]
800073e4:	e2 05 00 21 	add	r1,r1,r5<<0x2
800073e8:	f0 0a 18 00 	cp.b	r10,r8
800073ec:	fc 09 17 10 	movne	r9,lr
800073f0:	e6 05 00 38 	add	r8,r3,r5<<0x3
800073f4:	06 9e       	mov	lr,r3
800073f6:	c2 a8       	rjmp	8000744a <get_arg+0x2fa>
800073f8:	62 0a       	ld.w	r10,r1[0x0]
800073fa:	58 3a       	cp.w	r10,3
800073fc:	c1 e0       	breq	80007438 <get_arg+0x2e8>
800073fe:	e0 89 00 07 	brgt	8000740c <get_arg+0x2bc>
80007402:	58 1a       	cp.w	r10,1
80007404:	c1 a0       	breq	80007438 <get_arg+0x2e8>
80007406:	58 2a       	cp.w	r10,2
80007408:	c1 81       	brne	80007438 <get_arg+0x2e8>
8000740a:	c0 58       	rjmp	80007414 <get_arg+0x2c4>
8000740c:	58 5a       	cp.w	r10,5
8000740e:	c0 c0       	breq	80007426 <get_arg+0x2d6>
80007410:	c0 b5       	brlt	80007426 <get_arg+0x2d6>
80007412:	c1 38       	rjmp	80007438 <get_arg+0x2e8>
80007414:	6c 0a       	ld.w	r10,r6[0x0]
80007416:	f4 cc ff f8 	sub	r12,r10,-8
8000741a:	8d 0c       	st.w	r6[0x0],r12
8000741c:	f4 e2 00 00 	ld.d	r2,r10[0]
80007420:	f0 e3 00 00 	st.d	r8[0],r2
80007424:	c1 08       	rjmp	80007444 <get_arg+0x2f4>
80007426:	6c 0a       	ld.w	r10,r6[0x0]
80007428:	f4 cc ff f8 	sub	r12,r10,-8
8000742c:	8d 0c       	st.w	r6[0x0],r12
8000742e:	f4 e2 00 00 	ld.d	r2,r10[0]
80007432:	f0 e3 00 00 	st.d	r8[0],r2
80007436:	c0 78       	rjmp	80007444 <get_arg+0x2f4>
80007438:	6c 0a       	ld.w	r10,r6[0x0]
8000743a:	f4 cc ff fc 	sub	r12,r10,-4
8000743e:	8d 0c       	st.w	r6[0x0],r12
80007440:	74 0a       	ld.w	r10,r10[0x0]
80007442:	91 0a       	st.w	r8[0x0],r10
80007444:	2f f5       	sub	r5,-1
80007446:	2f 88       	sub	r8,-8
80007448:	2f c1       	sub	r1,-4
8000744a:	12 35       	cp.w	r5,r9
8000744c:	fe 9a ff d6 	brle	800073f8 <get_arg+0x2a8>
80007450:	1c 93       	mov	r3,lr
80007452:	40 52       	lddsp	r2,sp[0x14]
80007454:	40 6e       	lddsp	lr,sp[0x18]
80007456:	85 05       	st.w	r2[0x0],r5
80007458:	9d 0b       	st.w	lr[0x0],r11
8000745a:	40 4b       	lddsp	r11,sp[0x10]
8000745c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007460:	2f 8d       	sub	sp,-32
80007462:	d8 32       	popm	r0-r7,pc

80007464 <__sprint_r>:
80007464:	d4 21       	pushm	r4-r7,lr
80007466:	14 97       	mov	r7,r10
80007468:	74 28       	ld.w	r8,r10[0x8]
8000746a:	58 08       	cp.w	r8,0
8000746c:	c0 41       	brne	80007474 <__sprint_r+0x10>
8000746e:	95 18       	st.w	r10[0x4],r8
80007470:	10 9c       	mov	r12,r8
80007472:	d8 22       	popm	r4-r7,pc
80007474:	e0 a0 18 ba 	rcall	8000a5e8 <__sfvwrite_r>
80007478:	30 08       	mov	r8,0
8000747a:	8f 18       	st.w	r7[0x4],r8
8000747c:	8f 28       	st.w	r7[0x8],r8
8000747e:	d8 22       	popm	r4-r7,pc

80007480 <_vfprintf_r>:
80007480:	d4 31       	pushm	r0-r7,lr
80007482:	fa cd 06 bc 	sub	sp,sp,1724
80007486:	51 09       	stdsp	sp[0x40],r9
80007488:	16 91       	mov	r1,r11
8000748a:	14 97       	mov	r7,r10
8000748c:	18 95       	mov	r5,r12
8000748e:	e0 a0 1a 1d 	rcall	8000a8c8 <_localeconv_r>
80007492:	78 0c       	ld.w	r12,r12[0x0]
80007494:	50 cc       	stdsp	sp[0x30],r12
80007496:	58 05       	cp.w	r5,0
80007498:	c0 70       	breq	800074a6 <_vfprintf_r+0x26>
8000749a:	6a 68       	ld.w	r8,r5[0x18]
8000749c:	58 08       	cp.w	r8,0
8000749e:	c0 41       	brne	800074a6 <_vfprintf_r+0x26>
800074a0:	0a 9c       	mov	r12,r5
800074a2:	e0 a0 17 43 	rcall	8000a328 <__sinit>
800074a6:	fe c8 a1 0e 	sub	r8,pc,-24306
800074aa:	10 31       	cp.w	r1,r8
800074ac:	c0 31       	brne	800074b2 <_vfprintf_r+0x32>
800074ae:	6a 01       	ld.w	r1,r5[0x0]
800074b0:	c0 c8       	rjmp	800074c8 <_vfprintf_r+0x48>
800074b2:	fe c8 a0 fa 	sub	r8,pc,-24326
800074b6:	10 31       	cp.w	r1,r8
800074b8:	c0 31       	brne	800074be <_vfprintf_r+0x3e>
800074ba:	6a 11       	ld.w	r1,r5[0x4]
800074bc:	c0 68       	rjmp	800074c8 <_vfprintf_r+0x48>
800074be:	fe c8 a0 e6 	sub	r8,pc,-24346
800074c2:	10 31       	cp.w	r1,r8
800074c4:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800074c8:	82 68       	ld.sh	r8,r1[0xc]
800074ca:	ed b8 00 03 	bld	r8,0x3
800074ce:	c0 41       	brne	800074d6 <_vfprintf_r+0x56>
800074d0:	62 48       	ld.w	r8,r1[0x10]
800074d2:	58 08       	cp.w	r8,0
800074d4:	c0 71       	brne	800074e2 <_vfprintf_r+0x62>
800074d6:	02 9b       	mov	r11,r1
800074d8:	0a 9c       	mov	r12,r5
800074da:	e0 a0 0f 5d 	rcall	80009394 <__swsetup_r>
800074de:	e0 81 0f 54 	brne	80009386 <_vfprintf_r+0x1f06>
800074e2:	82 68       	ld.sh	r8,r1[0xc]
800074e4:	10 99       	mov	r9,r8
800074e6:	e2 19 00 1a 	andl	r9,0x1a,COH
800074ea:	58 a9       	cp.w	r9,10
800074ec:	c3 c1       	brne	80007564 <_vfprintf_r+0xe4>
800074ee:	82 79       	ld.sh	r9,r1[0xe]
800074f0:	30 0a       	mov	r10,0
800074f2:	f4 09 19 00 	cp.h	r9,r10
800074f6:	c3 75       	brlt	80007564 <_vfprintf_r+0xe4>
800074f8:	a1 d8       	cbr	r8,0x1
800074fa:	fb 58 05 d0 	st.h	sp[1488],r8
800074fe:	62 88       	ld.w	r8,r1[0x20]
80007500:	fb 48 05 e4 	st.w	sp[1508],r8
80007504:	62 a8       	ld.w	r8,r1[0x28]
80007506:	fb 48 05 ec 	st.w	sp[1516],r8
8000750a:	fa c8 ff bc 	sub	r8,sp,-68
8000750e:	fb 48 05 d4 	st.w	sp[1492],r8
80007512:	fb 48 05 c4 	st.w	sp[1476],r8
80007516:	e0 68 04 00 	mov	r8,1024
8000751a:	fb 48 05 d8 	st.w	sp[1496],r8
8000751e:	fb 48 05 cc 	st.w	sp[1484],r8
80007522:	30 08       	mov	r8,0
80007524:	fb 59 05 d2 	st.h	sp[1490],r9
80007528:	0e 9a       	mov	r10,r7
8000752a:	41 09       	lddsp	r9,sp[0x40]
8000752c:	fa c7 fa 3c 	sub	r7,sp,-1476
80007530:	fb 48 05 dc 	st.w	sp[1500],r8
80007534:	0a 9c       	mov	r12,r5
80007536:	0e 9b       	mov	r11,r7
80007538:	ca 4f       	rcall	80007480 <_vfprintf_r>
8000753a:	50 bc       	stdsp	sp[0x2c],r12
8000753c:	c0 95       	brlt	8000754e <_vfprintf_r+0xce>
8000753e:	0e 9b       	mov	r11,r7
80007540:	0a 9c       	mov	r12,r5
80007542:	e0 a0 16 1b 	rcall	8000a178 <_fflush_r>
80007546:	40 be       	lddsp	lr,sp[0x2c]
80007548:	f9 be 01 ff 	movne	lr,-1
8000754c:	50 be       	stdsp	sp[0x2c],lr
8000754e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007552:	ed b8 00 06 	bld	r8,0x6
80007556:	e0 81 0f 1a 	brne	8000938a <_vfprintf_r+0x1f0a>
8000755a:	82 68       	ld.sh	r8,r1[0xc]
8000755c:	a7 a8       	sbr	r8,0x6
8000755e:	a2 68       	st.h	r1[0xc],r8
80007560:	e0 8f 0f 15 	bral	8000938a <_vfprintf_r+0x1f0a>
80007564:	30 08       	mov	r8,0
80007566:	fb 48 06 b4 	st.w	sp[1716],r8
8000756a:	fb 48 06 90 	st.w	sp[1680],r8
8000756e:	fb 48 06 8c 	st.w	sp[1676],r8
80007572:	fb 48 06 b0 	st.w	sp[1712],r8
80007576:	30 08       	mov	r8,0
80007578:	30 09       	mov	r9,0
8000757a:	50 a7       	stdsp	sp[0x28],r7
8000757c:	50 78       	stdsp	sp[0x1c],r8
8000757e:	fa c3 f9 e0 	sub	r3,sp,-1568
80007582:	3f f8       	mov	r8,-1
80007584:	50 59       	stdsp	sp[0x14],r9
80007586:	fb 43 06 88 	st.w	sp[1672],r3
8000758a:	fb 48 05 44 	st.w	sp[1348],r8
8000758e:	12 9c       	mov	r12,r9
80007590:	50 69       	stdsp	sp[0x18],r9
80007592:	50 d9       	stdsp	sp[0x34],r9
80007594:	50 e9       	stdsp	sp[0x38],r9
80007596:	50 b9       	stdsp	sp[0x2c],r9
80007598:	12 97       	mov	r7,r9
8000759a:	0a 94       	mov	r4,r5
8000759c:	40 a2       	lddsp	r2,sp[0x28]
8000759e:	32 5a       	mov	r10,37
800075a0:	30 08       	mov	r8,0
800075a2:	c0 28       	rjmp	800075a6 <_vfprintf_r+0x126>
800075a4:	2f f2       	sub	r2,-1
800075a6:	05 89       	ld.ub	r9,r2[0x0]
800075a8:	f0 09 18 00 	cp.b	r9,r8
800075ac:	5f 1b       	srne	r11
800075ae:	f4 09 18 00 	cp.b	r9,r10
800075b2:	5f 19       	srne	r9
800075b4:	f3 eb 00 0b 	and	r11,r9,r11
800075b8:	f0 0b 18 00 	cp.b	r11,r8
800075bc:	cf 41       	brne	800075a4 <_vfprintf_r+0x124>
800075be:	40 ab       	lddsp	r11,sp[0x28]
800075c0:	e4 0b 01 06 	sub	r6,r2,r11
800075c4:	c1 e0       	breq	80007600 <_vfprintf_r+0x180>
800075c6:	fa f8 06 90 	ld.w	r8,sp[1680]
800075ca:	0c 08       	add	r8,r6
800075cc:	87 0b       	st.w	r3[0x0],r11
800075ce:	fb 48 06 90 	st.w	sp[1680],r8
800075d2:	87 16       	st.w	r3[0x4],r6
800075d4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800075d8:	2f f8       	sub	r8,-1
800075da:	fb 48 06 8c 	st.w	sp[1676],r8
800075de:	58 78       	cp.w	r8,7
800075e0:	e0 89 00 04 	brgt	800075e8 <_vfprintf_r+0x168>
800075e4:	2f 83       	sub	r3,-8
800075e6:	c0 a8       	rjmp	800075fa <_vfprintf_r+0x17a>
800075e8:	fa ca f9 78 	sub	r10,sp,-1672
800075ec:	02 9b       	mov	r11,r1
800075ee:	08 9c       	mov	r12,r4
800075f0:	c3 af       	rcall	80007464 <__sprint_r>
800075f2:	e0 81 0e c6 	brne	8000937e <_vfprintf_r+0x1efe>
800075f6:	fa c3 f9 e0 	sub	r3,sp,-1568
800075fa:	40 ba       	lddsp	r10,sp[0x2c]
800075fc:	0c 0a       	add	r10,r6
800075fe:	50 ba       	stdsp	sp[0x2c],r10
80007600:	05 89       	ld.ub	r9,r2[0x0]
80007602:	30 08       	mov	r8,0
80007604:	f0 09 18 00 	cp.b	r9,r8
80007608:	e0 80 0e aa 	breq	8000935c <_vfprintf_r+0x1edc>
8000760c:	30 09       	mov	r9,0
8000760e:	fb 68 06 bb 	st.b	sp[1723],r8
80007612:	0e 96       	mov	r6,r7
80007614:	e4 c8 ff ff 	sub	r8,r2,-1
80007618:	3f fe       	mov	lr,-1
8000761a:	50 93       	stdsp	sp[0x24],r3
8000761c:	50 41       	stdsp	sp[0x10],r1
8000761e:	0e 93       	mov	r3,r7
80007620:	04 91       	mov	r1,r2
80007622:	50 89       	stdsp	sp[0x20],r9
80007624:	50 a8       	stdsp	sp[0x28],r8
80007626:	50 2e       	stdsp	sp[0x8],lr
80007628:	50 39       	stdsp	sp[0xc],r9
8000762a:	12 95       	mov	r5,r9
8000762c:	12 90       	mov	r0,r9
8000762e:	10 97       	mov	r7,r8
80007630:	08 92       	mov	r2,r4
80007632:	c0 78       	rjmp	80007640 <_vfprintf_r+0x1c0>
80007634:	3f fc       	mov	r12,-1
80007636:	08 97       	mov	r7,r4
80007638:	50 2c       	stdsp	sp[0x8],r12
8000763a:	c0 38       	rjmp	80007640 <_vfprintf_r+0x1c0>
8000763c:	30 0b       	mov	r11,0
8000763e:	50 3b       	stdsp	sp[0xc],r11
80007640:	0f 38       	ld.ub	r8,r7++
80007642:	c0 28       	rjmp	80007646 <_vfprintf_r+0x1c6>
80007644:	12 90       	mov	r0,r9
80007646:	f0 c9 00 20 	sub	r9,r8,32
8000764a:	e0 49 00 58 	cp.w	r9,88
8000764e:	e0 8b 0a 30 	brhi	80008aae <_vfprintf_r+0x162e>
80007652:	fe ca a6 62 	sub	r10,pc,-22942
80007656:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000765a:	50 a7       	stdsp	sp[0x28],r7
8000765c:	50 80       	stdsp	sp[0x20],r0
8000765e:	0c 97       	mov	r7,r6
80007660:	04 94       	mov	r4,r2
80007662:	06 96       	mov	r6,r3
80007664:	02 92       	mov	r2,r1
80007666:	fe c9 a4 3a 	sub	r9,pc,-23494
8000766a:	40 93       	lddsp	r3,sp[0x24]
8000766c:	10 90       	mov	r0,r8
8000766e:	40 41       	lddsp	r1,sp[0x10]
80007670:	50 d9       	stdsp	sp[0x34],r9
80007672:	e0 8f 08 8e 	bral	8000878e <_vfprintf_r+0x130e>
80007676:	30 08       	mov	r8,0
80007678:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000767c:	f0 09 18 00 	cp.b	r9,r8
80007680:	ce 01       	brne	80007640 <_vfprintf_r+0x1c0>
80007682:	32 08       	mov	r8,32
80007684:	c6 e8       	rjmp	80007760 <_vfprintf_r+0x2e0>
80007686:	a1 a5       	sbr	r5,0x0
80007688:	cd cb       	rjmp	80007640 <_vfprintf_r+0x1c0>
8000768a:	0f 89       	ld.ub	r9,r7[0x0]
8000768c:	f2 c8 00 30 	sub	r8,r9,48
80007690:	58 98       	cp.w	r8,9
80007692:	e0 8b 00 1d 	brhi	800076cc <_vfprintf_r+0x24c>
80007696:	ee c8 ff ff 	sub	r8,r7,-1
8000769a:	30 0b       	mov	r11,0
8000769c:	23 09       	sub	r9,48
8000769e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800076a2:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800076a6:	11 39       	ld.ub	r9,r8++
800076a8:	f2 ca 00 30 	sub	r10,r9,48
800076ac:	58 9a       	cp.w	r10,9
800076ae:	fe 98 ff f7 	brls	8000769c <_vfprintf_r+0x21c>
800076b2:	e0 49 00 24 	cp.w	r9,36
800076b6:	cc 31       	brne	8000763c <_vfprintf_r+0x1bc>
800076b8:	e0 4b 00 20 	cp.w	r11,32
800076bc:	e0 89 0e 60 	brgt	8000937c <_vfprintf_r+0x1efc>
800076c0:	20 1b       	sub	r11,1
800076c2:	fa f9 06 b4 	ld.w	r9,sp[1716]
800076c6:	12 3b       	cp.w	r11,r9
800076c8:	c0 95       	brlt	800076da <_vfprintf_r+0x25a>
800076ca:	c1 08       	rjmp	800076ea <_vfprintf_r+0x26a>
800076cc:	fa f9 06 b4 	ld.w	r9,sp[1716]
800076d0:	ec ca ff ff 	sub	r10,r6,-1
800076d4:	12 36       	cp.w	r6,r9
800076d6:	c1 f5       	brlt	80007714 <_vfprintf_r+0x294>
800076d8:	c2 68       	rjmp	80007724 <_vfprintf_r+0x2a4>
800076da:	fa ce f9 44 	sub	lr,sp,-1724
800076de:	10 97       	mov	r7,r8
800076e0:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
800076e4:	f6 f0 fd 88 	ld.w	r0,r11[-632]
800076e8:	c3 58       	rjmp	80007752 <_vfprintf_r+0x2d2>
800076ea:	10 97       	mov	r7,r8
800076ec:	fa c8 f9 50 	sub	r8,sp,-1712
800076f0:	1a d8       	st.w	--sp,r8
800076f2:	fa c8 fa b8 	sub	r8,sp,-1352
800076f6:	1a d8       	st.w	--sp,r8
800076f8:	fa c8 fb b4 	sub	r8,sp,-1100
800076fc:	02 9a       	mov	r10,r1
800076fe:	1a d8       	st.w	--sp,r8
80007700:	04 9c       	mov	r12,r2
80007702:	fa c8 f9 40 	sub	r8,sp,-1728
80007706:	fa c9 ff b4 	sub	r9,sp,-76
8000770a:	fe b0 fd 23 	rcall	80007150 <get_arg>
8000770e:	2f dd       	sub	sp,-12
80007710:	78 00       	ld.w	r0,r12[0x0]
80007712:	c2 08       	rjmp	80007752 <_vfprintf_r+0x2d2>
80007714:	fa cc f9 44 	sub	r12,sp,-1724
80007718:	14 96       	mov	r6,r10
8000771a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000771e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007722:	c1 88       	rjmp	80007752 <_vfprintf_r+0x2d2>
80007724:	41 08       	lddsp	r8,sp[0x40]
80007726:	59 f9       	cp.w	r9,31
80007728:	e0 89 00 11 	brgt	8000774a <_vfprintf_r+0x2ca>
8000772c:	f0 cb ff fc 	sub	r11,r8,-4
80007730:	51 0b       	stdsp	sp[0x40],r11
80007732:	70 00       	ld.w	r0,r8[0x0]
80007734:	fa cb f9 44 	sub	r11,sp,-1724
80007738:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000773c:	f1 40 fd 88 	st.w	r8[-632],r0
80007740:	2f f9       	sub	r9,-1
80007742:	14 96       	mov	r6,r10
80007744:	fb 49 06 b4 	st.w	sp[1716],r9
80007748:	c0 58       	rjmp	80007752 <_vfprintf_r+0x2d2>
8000774a:	70 00       	ld.w	r0,r8[0x0]
8000774c:	14 96       	mov	r6,r10
8000774e:	2f c8       	sub	r8,-4
80007750:	51 08       	stdsp	sp[0x40],r8
80007752:	58 00       	cp.w	r0,0
80007754:	fe 94 ff 76 	brge	80007640 <_vfprintf_r+0x1c0>
80007758:	5c 30       	neg	r0
8000775a:	a3 a5       	sbr	r5,0x2
8000775c:	c7 2b       	rjmp	80007640 <_vfprintf_r+0x1c0>
8000775e:	32 b8       	mov	r8,43
80007760:	fb 68 06 bb 	st.b	sp[1723],r8
80007764:	c6 eb       	rjmp	80007640 <_vfprintf_r+0x1c0>
80007766:	0f 38       	ld.ub	r8,r7++
80007768:	e0 48 00 2a 	cp.w	r8,42
8000776c:	c0 30       	breq	80007772 <_vfprintf_r+0x2f2>
8000776e:	30 09       	mov	r9,0
80007770:	c7 98       	rjmp	80007862 <_vfprintf_r+0x3e2>
80007772:	0f 88       	ld.ub	r8,r7[0x0]
80007774:	f0 c9 00 30 	sub	r9,r8,48
80007778:	58 99       	cp.w	r9,9
8000777a:	e0 8b 00 1f 	brhi	800077b8 <_vfprintf_r+0x338>
8000777e:	ee c4 ff ff 	sub	r4,r7,-1
80007782:	30 0b       	mov	r11,0
80007784:	23 08       	sub	r8,48
80007786:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000778a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000778e:	09 38       	ld.ub	r8,r4++
80007790:	f0 c9 00 30 	sub	r9,r8,48
80007794:	58 99       	cp.w	r9,9
80007796:	fe 98 ff f7 	brls	80007784 <_vfprintf_r+0x304>
8000779a:	e0 48 00 24 	cp.w	r8,36
8000779e:	fe 91 ff 4f 	brne	8000763c <_vfprintf_r+0x1bc>
800077a2:	e0 4b 00 20 	cp.w	r11,32
800077a6:	e0 89 0d eb 	brgt	8000937c <_vfprintf_r+0x1efc>
800077aa:	20 1b       	sub	r11,1
800077ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077b0:	10 3b       	cp.w	r11,r8
800077b2:	c0 a5       	brlt	800077c6 <_vfprintf_r+0x346>
800077b4:	c1 18       	rjmp	800077d6 <_vfprintf_r+0x356>
800077b6:	d7 03       	nop
800077b8:	fa fa 06 b4 	ld.w	r10,sp[1716]
800077bc:	ec c9 ff ff 	sub	r9,r6,-1
800077c0:	14 36       	cp.w	r6,r10
800077c2:	c1 f5       	brlt	80007800 <_vfprintf_r+0x380>
800077c4:	c2 88       	rjmp	80007814 <_vfprintf_r+0x394>
800077c6:	fa ca f9 44 	sub	r10,sp,-1724
800077ca:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800077ce:	f6 fb fd 88 	ld.w	r11,r11[-632]
800077d2:	50 2b       	stdsp	sp[0x8],r11
800077d4:	c3 c8       	rjmp	8000784c <_vfprintf_r+0x3cc>
800077d6:	fa c8 f9 50 	sub	r8,sp,-1712
800077da:	1a d8       	st.w	--sp,r8
800077dc:	fa c8 fa b8 	sub	r8,sp,-1352
800077e0:	1a d8       	st.w	--sp,r8
800077e2:	fa c8 fb b4 	sub	r8,sp,-1100
800077e6:	02 9a       	mov	r10,r1
800077e8:	1a d8       	st.w	--sp,r8
800077ea:	04 9c       	mov	r12,r2
800077ec:	fa c8 f9 40 	sub	r8,sp,-1728
800077f0:	fa c9 ff b4 	sub	r9,sp,-76
800077f4:	fe b0 fc ae 	rcall	80007150 <get_arg>
800077f8:	2f dd       	sub	sp,-12
800077fa:	78 0c       	ld.w	r12,r12[0x0]
800077fc:	50 2c       	stdsp	sp[0x8],r12
800077fe:	c2 78       	rjmp	8000784c <_vfprintf_r+0x3cc>
80007800:	12 96       	mov	r6,r9
80007802:	0e 94       	mov	r4,r7
80007804:	fa c9 f9 44 	sub	r9,sp,-1724
80007808:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000780c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007810:	50 28       	stdsp	sp[0x8],r8
80007812:	c1 d8       	rjmp	8000784c <_vfprintf_r+0x3cc>
80007814:	41 08       	lddsp	r8,sp[0x40]
80007816:	59 fa       	cp.w	r10,31
80007818:	e0 89 00 14 	brgt	80007840 <_vfprintf_r+0x3c0>
8000781c:	f0 cb ff fc 	sub	r11,r8,-4
80007820:	70 08       	ld.w	r8,r8[0x0]
80007822:	51 0b       	stdsp	sp[0x40],r11
80007824:	50 28       	stdsp	sp[0x8],r8
80007826:	fa c6 f9 44 	sub	r6,sp,-1724
8000782a:	40 2e       	lddsp	lr,sp[0x8]
8000782c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007830:	f1 4e fd 88 	st.w	r8[-632],lr
80007834:	2f fa       	sub	r10,-1
80007836:	0e 94       	mov	r4,r7
80007838:	fb 4a 06 b4 	st.w	sp[1716],r10
8000783c:	12 96       	mov	r6,r9
8000783e:	c0 78       	rjmp	8000784c <_vfprintf_r+0x3cc>
80007840:	70 0c       	ld.w	r12,r8[0x0]
80007842:	0e 94       	mov	r4,r7
80007844:	2f c8       	sub	r8,-4
80007846:	50 2c       	stdsp	sp[0x8],r12
80007848:	12 96       	mov	r6,r9
8000784a:	51 08       	stdsp	sp[0x40],r8
8000784c:	40 2b       	lddsp	r11,sp[0x8]
8000784e:	58 0b       	cp.w	r11,0
80007850:	fe 95 fe f2 	brlt	80007634 <_vfprintf_r+0x1b4>
80007854:	08 97       	mov	r7,r4
80007856:	cf 5a       	rjmp	80007640 <_vfprintf_r+0x1c0>
80007858:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000785c:	0f 38       	ld.ub	r8,r7++
8000785e:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007862:	f0 ca 00 30 	sub	r10,r8,48
80007866:	58 9a       	cp.w	r10,9
80007868:	fe 98 ff f8 	brls	80007858 <_vfprintf_r+0x3d8>
8000786c:	3f fa       	mov	r10,-1
8000786e:	f2 0a 0c 49 	max	r9,r9,r10
80007872:	50 29       	stdsp	sp[0x8],r9
80007874:	ce 9a       	rjmp	80007646 <_vfprintf_r+0x1c6>
80007876:	a7 b5       	sbr	r5,0x7
80007878:	ce 4a       	rjmp	80007640 <_vfprintf_r+0x1c0>
8000787a:	30 09       	mov	r9,0
8000787c:	23 08       	sub	r8,48
8000787e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007882:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007886:	0f 38       	ld.ub	r8,r7++
80007888:	f0 ca 00 30 	sub	r10,r8,48
8000788c:	58 9a       	cp.w	r10,9
8000788e:	fe 98 ff f7 	brls	8000787c <_vfprintf_r+0x3fc>
80007892:	e0 48 00 24 	cp.w	r8,36
80007896:	fe 91 fe d7 	brne	80007644 <_vfprintf_r+0x1c4>
8000789a:	e0 49 00 20 	cp.w	r9,32
8000789e:	e0 89 0d 6f 	brgt	8000937c <_vfprintf_r+0x1efc>
800078a2:	f2 c3 00 01 	sub	r3,r9,1
800078a6:	30 19       	mov	r9,1
800078a8:	50 39       	stdsp	sp[0xc],r9
800078aa:	cc ba       	rjmp	80007640 <_vfprintf_r+0x1c0>
800078ac:	a3 b5       	sbr	r5,0x3
800078ae:	cc 9a       	rjmp	80007640 <_vfprintf_r+0x1c0>
800078b0:	a7 a5       	sbr	r5,0x6
800078b2:	cc 7a       	rjmp	80007640 <_vfprintf_r+0x1c0>
800078b4:	0a 98       	mov	r8,r5
800078b6:	a5 b5       	sbr	r5,0x5
800078b8:	a5 a8       	sbr	r8,0x4
800078ba:	0f 89       	ld.ub	r9,r7[0x0]
800078bc:	36 ce       	mov	lr,108
800078be:	fc 09 18 00 	cp.b	r9,lr
800078c2:	f7 b7 00 ff 	subeq	r7,-1
800078c6:	f0 05 17 10 	movne	r5,r8
800078ca:	cb ba       	rjmp	80007640 <_vfprintf_r+0x1c0>
800078cc:	a5 b5       	sbr	r5,0x5
800078ce:	cb 9a       	rjmp	80007640 <_vfprintf_r+0x1c0>
800078d0:	50 a7       	stdsp	sp[0x28],r7
800078d2:	50 80       	stdsp	sp[0x20],r0
800078d4:	0c 97       	mov	r7,r6
800078d6:	10 90       	mov	r0,r8
800078d8:	06 96       	mov	r6,r3
800078da:	04 94       	mov	r4,r2
800078dc:	40 93       	lddsp	r3,sp[0x24]
800078de:	02 92       	mov	r2,r1
800078e0:	0e 99       	mov	r9,r7
800078e2:	40 41       	lddsp	r1,sp[0x10]
800078e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078e8:	40 3c       	lddsp	r12,sp[0xc]
800078ea:	58 0c       	cp.w	r12,0
800078ec:	c1 d0       	breq	80007926 <_vfprintf_r+0x4a6>
800078ee:	10 36       	cp.w	r6,r8
800078f0:	c0 64       	brge	800078fc <_vfprintf_r+0x47c>
800078f2:	fa cb f9 44 	sub	r11,sp,-1724
800078f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800078fa:	c1 d8       	rjmp	80007934 <_vfprintf_r+0x4b4>
800078fc:	fa c8 f9 50 	sub	r8,sp,-1712
80007900:	1a d8       	st.w	--sp,r8
80007902:	fa c8 fa b8 	sub	r8,sp,-1352
80007906:	1a d8       	st.w	--sp,r8
80007908:	fa c8 fb b4 	sub	r8,sp,-1100
8000790c:	1a d8       	st.w	--sp,r8
8000790e:	fa c8 f9 40 	sub	r8,sp,-1728
80007912:	fa c9 ff b4 	sub	r9,sp,-76
80007916:	04 9a       	mov	r10,r2
80007918:	0c 9b       	mov	r11,r6
8000791a:	08 9c       	mov	r12,r4
8000791c:	fe b0 fc 1a 	rcall	80007150 <get_arg>
80007920:	2f dd       	sub	sp,-12
80007922:	19 b8       	ld.ub	r8,r12[0x3]
80007924:	c2 28       	rjmp	80007968 <_vfprintf_r+0x4e8>
80007926:	2f f7       	sub	r7,-1
80007928:	10 39       	cp.w	r9,r8
8000792a:	c0 84       	brge	8000793a <_vfprintf_r+0x4ba>
8000792c:	fa ca f9 44 	sub	r10,sp,-1724
80007930:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007934:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007938:	c1 88       	rjmp	80007968 <_vfprintf_r+0x4e8>
8000793a:	41 09       	lddsp	r9,sp[0x40]
8000793c:	59 f8       	cp.w	r8,31
8000793e:	e0 89 00 12 	brgt	80007962 <_vfprintf_r+0x4e2>
80007942:	f2 ca ff fc 	sub	r10,r9,-4
80007946:	51 0a       	stdsp	sp[0x40],r10
80007948:	72 09       	ld.w	r9,r9[0x0]
8000794a:	fa c6 f9 44 	sub	r6,sp,-1724
8000794e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007952:	2f f8       	sub	r8,-1
80007954:	f5 49 fd 88 	st.w	r10[-632],r9
80007958:	fb 48 06 b4 	st.w	sp[1716],r8
8000795c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007960:	c0 48       	rjmp	80007968 <_vfprintf_r+0x4e8>
80007962:	13 b8       	ld.ub	r8,r9[0x3]
80007964:	2f c9       	sub	r9,-4
80007966:	51 09       	stdsp	sp[0x40],r9
80007968:	fb 68 06 60 	st.b	sp[1632],r8
8000796c:	30 0e       	mov	lr,0
8000796e:	30 08       	mov	r8,0
80007970:	30 12       	mov	r2,1
80007972:	fb 68 06 bb 	st.b	sp[1723],r8
80007976:	50 2e       	stdsp	sp[0x8],lr
80007978:	e0 8f 08 ad 	bral	80008ad2 <_vfprintf_r+0x1652>
8000797c:	50 a7       	stdsp	sp[0x28],r7
8000797e:	50 80       	stdsp	sp[0x20],r0
80007980:	0c 97       	mov	r7,r6
80007982:	04 94       	mov	r4,r2
80007984:	06 96       	mov	r6,r3
80007986:	02 92       	mov	r2,r1
80007988:	40 93       	lddsp	r3,sp[0x24]
8000798a:	10 90       	mov	r0,r8
8000798c:	40 41       	lddsp	r1,sp[0x10]
8000798e:	a5 a5       	sbr	r5,0x4
80007990:	c0 a8       	rjmp	800079a4 <_vfprintf_r+0x524>
80007992:	50 a7       	stdsp	sp[0x28],r7
80007994:	50 80       	stdsp	sp[0x20],r0
80007996:	0c 97       	mov	r7,r6
80007998:	04 94       	mov	r4,r2
8000799a:	06 96       	mov	r6,r3
8000799c:	02 92       	mov	r2,r1
8000799e:	40 93       	lddsp	r3,sp[0x24]
800079a0:	10 90       	mov	r0,r8
800079a2:	40 41       	lddsp	r1,sp[0x10]
800079a4:	ed b5 00 05 	bld	r5,0x5
800079a8:	c5 11       	brne	80007a4a <_vfprintf_r+0x5ca>
800079aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079ae:	40 3c       	lddsp	r12,sp[0xc]
800079b0:	58 0c       	cp.w	r12,0
800079b2:	c1 e0       	breq	800079ee <_vfprintf_r+0x56e>
800079b4:	10 36       	cp.w	r6,r8
800079b6:	c0 64       	brge	800079c2 <_vfprintf_r+0x542>
800079b8:	fa cb f9 44 	sub	r11,sp,-1724
800079bc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800079c0:	c2 08       	rjmp	80007a00 <_vfprintf_r+0x580>
800079c2:	fa c8 f9 50 	sub	r8,sp,-1712
800079c6:	1a d8       	st.w	--sp,r8
800079c8:	fa c8 fa b8 	sub	r8,sp,-1352
800079cc:	0c 9b       	mov	r11,r6
800079ce:	1a d8       	st.w	--sp,r8
800079d0:	fa c8 fb b4 	sub	r8,sp,-1100
800079d4:	1a d8       	st.w	--sp,r8
800079d6:	fa c9 ff b4 	sub	r9,sp,-76
800079da:	fa c8 f9 40 	sub	r8,sp,-1728
800079de:	04 9a       	mov	r10,r2
800079e0:	08 9c       	mov	r12,r4
800079e2:	fe b0 fb b7 	rcall	80007150 <get_arg>
800079e6:	2f dd       	sub	sp,-12
800079e8:	78 1b       	ld.w	r11,r12[0x4]
800079ea:	78 09       	ld.w	r9,r12[0x0]
800079ec:	c2 b8       	rjmp	80007a42 <_vfprintf_r+0x5c2>
800079ee:	ee ca ff ff 	sub	r10,r7,-1
800079f2:	10 37       	cp.w	r7,r8
800079f4:	c0 b4       	brge	80007a0a <_vfprintf_r+0x58a>
800079f6:	fa c9 f9 44 	sub	r9,sp,-1724
800079fa:	14 97       	mov	r7,r10
800079fc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007a00:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007a04:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007a08:	c1 d8       	rjmp	80007a42 <_vfprintf_r+0x5c2>
80007a0a:	41 09       	lddsp	r9,sp[0x40]
80007a0c:	59 f8       	cp.w	r8,31
80007a0e:	e0 89 00 14 	brgt	80007a36 <_vfprintf_r+0x5b6>
80007a12:	f2 cb ff f8 	sub	r11,r9,-8
80007a16:	51 0b       	stdsp	sp[0x40],r11
80007a18:	fa c6 f9 44 	sub	r6,sp,-1724
80007a1c:	72 1b       	ld.w	r11,r9[0x4]
80007a1e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007a22:	72 09       	ld.w	r9,r9[0x0]
80007a24:	f9 4b fd 8c 	st.w	r12[-628],r11
80007a28:	f9 49 fd 88 	st.w	r12[-632],r9
80007a2c:	2f f8       	sub	r8,-1
80007a2e:	14 97       	mov	r7,r10
80007a30:	fb 48 06 b4 	st.w	sp[1716],r8
80007a34:	c0 78       	rjmp	80007a42 <_vfprintf_r+0x5c2>
80007a36:	f2 c8 ff f8 	sub	r8,r9,-8
80007a3a:	72 1b       	ld.w	r11,r9[0x4]
80007a3c:	14 97       	mov	r7,r10
80007a3e:	51 08       	stdsp	sp[0x40],r8
80007a40:	72 09       	ld.w	r9,r9[0x0]
80007a42:	16 98       	mov	r8,r11
80007a44:	fa e9 00 00 	st.d	sp[0],r8
80007a48:	ca e8       	rjmp	80007ba4 <_vfprintf_r+0x724>
80007a4a:	ed b5 00 04 	bld	r5,0x4
80007a4e:	c1 71       	brne	80007a7c <_vfprintf_r+0x5fc>
80007a50:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a54:	40 3e       	lddsp	lr,sp[0xc]
80007a56:	58 0e       	cp.w	lr,0
80007a58:	c0 80       	breq	80007a68 <_vfprintf_r+0x5e8>
80007a5a:	10 36       	cp.w	r6,r8
80007a5c:	c6 94       	brge	80007b2e <_vfprintf_r+0x6ae>
80007a5e:	fa cc f9 44 	sub	r12,sp,-1724
80007a62:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007a66:	c8 28       	rjmp	80007b6a <_vfprintf_r+0x6ea>
80007a68:	ee ca ff ff 	sub	r10,r7,-1
80007a6c:	10 37       	cp.w	r7,r8
80007a6e:	e0 84 00 81 	brge	80007b70 <_vfprintf_r+0x6f0>
80007a72:	fa cb f9 44 	sub	r11,sp,-1724
80007a76:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a7a:	c7 78       	rjmp	80007b68 <_vfprintf_r+0x6e8>
80007a7c:	ed b5 00 06 	bld	r5,0x6
80007a80:	c4 b1       	brne	80007b16 <_vfprintf_r+0x696>
80007a82:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a86:	40 3c       	lddsp	r12,sp[0xc]
80007a88:	58 0c       	cp.w	r12,0
80007a8a:	c1 d0       	breq	80007ac4 <_vfprintf_r+0x644>
80007a8c:	10 36       	cp.w	r6,r8
80007a8e:	c0 64       	brge	80007a9a <_vfprintf_r+0x61a>
80007a90:	fa cb f9 44 	sub	r11,sp,-1724
80007a94:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a98:	c1 f8       	rjmp	80007ad6 <_vfprintf_r+0x656>
80007a9a:	fa c8 f9 50 	sub	r8,sp,-1712
80007a9e:	1a d8       	st.w	--sp,r8
80007aa0:	fa c8 fa b8 	sub	r8,sp,-1352
80007aa4:	1a d8       	st.w	--sp,r8
80007aa6:	fa c8 fb b4 	sub	r8,sp,-1100
80007aaa:	1a d8       	st.w	--sp,r8
80007aac:	fa c8 f9 40 	sub	r8,sp,-1728
80007ab0:	fa c9 ff b4 	sub	r9,sp,-76
80007ab4:	04 9a       	mov	r10,r2
80007ab6:	0c 9b       	mov	r11,r6
80007ab8:	08 9c       	mov	r12,r4
80007aba:	fe b0 fb 4b 	rcall	80007150 <get_arg>
80007abe:	2f dd       	sub	sp,-12
80007ac0:	98 18       	ld.sh	r8,r12[0x2]
80007ac2:	c2 68       	rjmp	80007b0e <_vfprintf_r+0x68e>
80007ac4:	ee ca ff ff 	sub	r10,r7,-1
80007ac8:	10 37       	cp.w	r7,r8
80007aca:	c0 94       	brge	80007adc <_vfprintf_r+0x65c>
80007acc:	fa c9 f9 44 	sub	r9,sp,-1724
80007ad0:	14 97       	mov	r7,r10
80007ad2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ad6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007ada:	c1 a8       	rjmp	80007b0e <_vfprintf_r+0x68e>
80007adc:	41 09       	lddsp	r9,sp[0x40]
80007ade:	59 f8       	cp.w	r8,31
80007ae0:	e0 89 00 13 	brgt	80007b06 <_vfprintf_r+0x686>
80007ae4:	f2 cb ff fc 	sub	r11,r9,-4
80007ae8:	51 0b       	stdsp	sp[0x40],r11
80007aea:	72 09       	ld.w	r9,r9[0x0]
80007aec:	fa c6 f9 44 	sub	r6,sp,-1724
80007af0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007af4:	2f f8       	sub	r8,-1
80007af6:	f7 49 fd 88 	st.w	r11[-632],r9
80007afa:	fb 48 06 b4 	st.w	sp[1716],r8
80007afe:	14 97       	mov	r7,r10
80007b00:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007b04:	c0 58       	rjmp	80007b0e <_vfprintf_r+0x68e>
80007b06:	92 18       	ld.sh	r8,r9[0x2]
80007b08:	14 97       	mov	r7,r10
80007b0a:	2f c9       	sub	r9,-4
80007b0c:	51 09       	stdsp	sp[0x40],r9
80007b0e:	50 18       	stdsp	sp[0x4],r8
80007b10:	bf 58       	asr	r8,0x1f
80007b12:	50 08       	stdsp	sp[0x0],r8
80007b14:	c4 88       	rjmp	80007ba4 <_vfprintf_r+0x724>
80007b16:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b1a:	40 3c       	lddsp	r12,sp[0xc]
80007b1c:	58 0c       	cp.w	r12,0
80007b1e:	c1 d0       	breq	80007b58 <_vfprintf_r+0x6d8>
80007b20:	10 36       	cp.w	r6,r8
80007b22:	c0 64       	brge	80007b2e <_vfprintf_r+0x6ae>
80007b24:	fa cb f9 44 	sub	r11,sp,-1724
80007b28:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b2c:	c1 f8       	rjmp	80007b6a <_vfprintf_r+0x6ea>
80007b2e:	fa c8 f9 50 	sub	r8,sp,-1712
80007b32:	1a d8       	st.w	--sp,r8
80007b34:	fa c8 fa b8 	sub	r8,sp,-1352
80007b38:	0c 9b       	mov	r11,r6
80007b3a:	1a d8       	st.w	--sp,r8
80007b3c:	fa c8 fb b4 	sub	r8,sp,-1100
80007b40:	04 9a       	mov	r10,r2
80007b42:	1a d8       	st.w	--sp,r8
80007b44:	08 9c       	mov	r12,r4
80007b46:	fa c8 f9 40 	sub	r8,sp,-1728
80007b4a:	fa c9 ff b4 	sub	r9,sp,-76
80007b4e:	fe b0 fb 01 	rcall	80007150 <get_arg>
80007b52:	2f dd       	sub	sp,-12
80007b54:	78 0b       	ld.w	r11,r12[0x0]
80007b56:	c2 48       	rjmp	80007b9e <_vfprintf_r+0x71e>
80007b58:	ee ca ff ff 	sub	r10,r7,-1
80007b5c:	10 37       	cp.w	r7,r8
80007b5e:	c0 94       	brge	80007b70 <_vfprintf_r+0x6f0>
80007b60:	fa c9 f9 44 	sub	r9,sp,-1724
80007b64:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007b68:	14 97       	mov	r7,r10
80007b6a:	ec fb fd 88 	ld.w	r11,r6[-632]
80007b6e:	c1 88       	rjmp	80007b9e <_vfprintf_r+0x71e>
80007b70:	41 09       	lddsp	r9,sp[0x40]
80007b72:	59 f8       	cp.w	r8,31
80007b74:	e0 89 00 11 	brgt	80007b96 <_vfprintf_r+0x716>
80007b78:	f2 cb ff fc 	sub	r11,r9,-4
80007b7c:	51 0b       	stdsp	sp[0x40],r11
80007b7e:	fa c6 f9 44 	sub	r6,sp,-1724
80007b82:	72 0b       	ld.w	r11,r9[0x0]
80007b84:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007b88:	f3 4b fd 88 	st.w	r9[-632],r11
80007b8c:	2f f8       	sub	r8,-1
80007b8e:	14 97       	mov	r7,r10
80007b90:	fb 48 06 b4 	st.w	sp[1716],r8
80007b94:	c0 58       	rjmp	80007b9e <_vfprintf_r+0x71e>
80007b96:	72 0b       	ld.w	r11,r9[0x0]
80007b98:	14 97       	mov	r7,r10
80007b9a:	2f c9       	sub	r9,-4
80007b9c:	51 09       	stdsp	sp[0x40],r9
80007b9e:	50 1b       	stdsp	sp[0x4],r11
80007ba0:	bf 5b       	asr	r11,0x1f
80007ba2:	50 0b       	stdsp	sp[0x0],r11
80007ba4:	fa ea 00 00 	ld.d	r10,sp[0]
80007ba8:	58 0a       	cp.w	r10,0
80007baa:	5c 2b       	cpc	r11
80007bac:	c0 e4       	brge	80007bc8 <_vfprintf_r+0x748>
80007bae:	30 08       	mov	r8,0
80007bb0:	fa ea 00 00 	ld.d	r10,sp[0]
80007bb4:	30 09       	mov	r9,0
80007bb6:	f0 0a 01 0a 	sub	r10,r8,r10
80007bba:	f2 0b 01 4b 	sbc	r11,r9,r11
80007bbe:	32 d8       	mov	r8,45
80007bc0:	fa eb 00 00 	st.d	sp[0],r10
80007bc4:	fb 68 06 bb 	st.b	sp[1723],r8
80007bc8:	30 18       	mov	r8,1
80007bca:	e0 8f 06 fa 	bral	800089be <_vfprintf_r+0x153e>
80007bce:	50 a7       	stdsp	sp[0x28],r7
80007bd0:	50 80       	stdsp	sp[0x20],r0
80007bd2:	0c 97       	mov	r7,r6
80007bd4:	04 94       	mov	r4,r2
80007bd6:	06 96       	mov	r6,r3
80007bd8:	02 92       	mov	r2,r1
80007bda:	40 93       	lddsp	r3,sp[0x24]
80007bdc:	10 90       	mov	r0,r8
80007bde:	40 41       	lddsp	r1,sp[0x10]
80007be0:	0e 99       	mov	r9,r7
80007be2:	ed b5 00 03 	bld	r5,0x3
80007be6:	c4 11       	brne	80007c68 <_vfprintf_r+0x7e8>
80007be8:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bec:	40 3a       	lddsp	r10,sp[0xc]
80007bee:	58 0a       	cp.w	r10,0
80007bf0:	c1 90       	breq	80007c22 <_vfprintf_r+0x7a2>
80007bf2:	10 36       	cp.w	r6,r8
80007bf4:	c6 45       	brlt	80007cbc <_vfprintf_r+0x83c>
80007bf6:	fa c8 f9 50 	sub	r8,sp,-1712
80007bfa:	1a d8       	st.w	--sp,r8
80007bfc:	fa c8 fa b8 	sub	r8,sp,-1352
80007c00:	1a d8       	st.w	--sp,r8
80007c02:	fa c8 fb b4 	sub	r8,sp,-1100
80007c06:	0c 9b       	mov	r11,r6
80007c08:	1a d8       	st.w	--sp,r8
80007c0a:	04 9a       	mov	r10,r2
80007c0c:	fa c8 f9 40 	sub	r8,sp,-1728
80007c10:	fa c9 ff b4 	sub	r9,sp,-76
80007c14:	08 9c       	mov	r12,r4
80007c16:	fe b0 fa 9d 	rcall	80007150 <get_arg>
80007c1a:	2f dd       	sub	sp,-12
80007c1c:	78 16       	ld.w	r6,r12[0x4]
80007c1e:	50 76       	stdsp	sp[0x1c],r6
80007c20:	c4 88       	rjmp	80007cb0 <_vfprintf_r+0x830>
80007c22:	2f f7       	sub	r7,-1
80007c24:	10 39       	cp.w	r9,r8
80007c26:	c0 c4       	brge	80007c3e <_vfprintf_r+0x7be>
80007c28:	fa ce f9 44 	sub	lr,sp,-1724
80007c2c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007c30:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007c34:	50 7c       	stdsp	sp[0x1c],r12
80007c36:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007c3a:	50 56       	stdsp	sp[0x14],r6
80007c3c:	c6 68       	rjmp	80007d08 <_vfprintf_r+0x888>
80007c3e:	41 09       	lddsp	r9,sp[0x40]
80007c40:	59 f8       	cp.w	r8,31
80007c42:	e0 89 00 10 	brgt	80007c62 <_vfprintf_r+0x7e2>
80007c46:	f2 ca ff f8 	sub	r10,r9,-8
80007c4a:	72 1b       	ld.w	r11,r9[0x4]
80007c4c:	51 0a       	stdsp	sp[0x40],r10
80007c4e:	72 09       	ld.w	r9,r9[0x0]
80007c50:	fa ca f9 44 	sub	r10,sp,-1724
80007c54:	50 7b       	stdsp	sp[0x1c],r11
80007c56:	50 59       	stdsp	sp[0x14],r9
80007c58:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007c5c:	40 5b       	lddsp	r11,sp[0x14]
80007c5e:	40 7a       	lddsp	r10,sp[0x1c]
80007c60:	c4 78       	rjmp	80007cee <_vfprintf_r+0x86e>
80007c62:	72 18       	ld.w	r8,r9[0x4]
80007c64:	50 78       	stdsp	sp[0x1c],r8
80007c66:	c4 c8       	rjmp	80007cfe <_vfprintf_r+0x87e>
80007c68:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c6c:	40 3e       	lddsp	lr,sp[0xc]
80007c6e:	58 0e       	cp.w	lr,0
80007c70:	c2 30       	breq	80007cb6 <_vfprintf_r+0x836>
80007c72:	10 36       	cp.w	r6,r8
80007c74:	c0 94       	brge	80007c86 <_vfprintf_r+0x806>
80007c76:	fa cc f9 44 	sub	r12,sp,-1724
80007c7a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007c7e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007c82:	50 7b       	stdsp	sp[0x1c],r11
80007c84:	cd 9b       	rjmp	80007c36 <_vfprintf_r+0x7b6>
80007c86:	fa c8 f9 50 	sub	r8,sp,-1712
80007c8a:	1a d8       	st.w	--sp,r8
80007c8c:	fa c8 fa b8 	sub	r8,sp,-1352
80007c90:	04 9a       	mov	r10,r2
80007c92:	1a d8       	st.w	--sp,r8
80007c94:	fa c8 fb b4 	sub	r8,sp,-1100
80007c98:	0c 9b       	mov	r11,r6
80007c9a:	1a d8       	st.w	--sp,r8
80007c9c:	08 9c       	mov	r12,r4
80007c9e:	fa c8 f9 40 	sub	r8,sp,-1728
80007ca2:	fa c9 ff b4 	sub	r9,sp,-76
80007ca6:	fe b0 fa 55 	rcall	80007150 <get_arg>
80007caa:	2f dd       	sub	sp,-12
80007cac:	78 1a       	ld.w	r10,r12[0x4]
80007cae:	50 7a       	stdsp	sp[0x1c],r10
80007cb0:	78 0c       	ld.w	r12,r12[0x0]
80007cb2:	50 5c       	stdsp	sp[0x14],r12
80007cb4:	c2 a8       	rjmp	80007d08 <_vfprintf_r+0x888>
80007cb6:	2f f7       	sub	r7,-1
80007cb8:	10 39       	cp.w	r9,r8
80007cba:	c0 94       	brge	80007ccc <_vfprintf_r+0x84c>
80007cbc:	fa c9 f9 44 	sub	r9,sp,-1724
80007cc0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007cc4:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007cc8:	50 78       	stdsp	sp[0x1c],r8
80007cca:	cb 6b       	rjmp	80007c36 <_vfprintf_r+0x7b6>
80007ccc:	41 09       	lddsp	r9,sp[0x40]
80007cce:	59 f8       	cp.w	r8,31
80007cd0:	e0 89 00 15 	brgt	80007cfa <_vfprintf_r+0x87a>
80007cd4:	f2 ca ff f8 	sub	r10,r9,-8
80007cd8:	72 16       	ld.w	r6,r9[0x4]
80007cda:	72 09       	ld.w	r9,r9[0x0]
80007cdc:	51 0a       	stdsp	sp[0x40],r10
80007cde:	50 59       	stdsp	sp[0x14],r9
80007ce0:	fa ce f9 44 	sub	lr,sp,-1724
80007ce4:	50 76       	stdsp	sp[0x1c],r6
80007ce6:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007cea:	40 5b       	lddsp	r11,sp[0x14]
80007cec:	0c 9a       	mov	r10,r6
80007cee:	f2 eb fd 88 	st.d	r9[-632],r10
80007cf2:	2f f8       	sub	r8,-1
80007cf4:	fb 48 06 b4 	st.w	sp[1716],r8
80007cf8:	c0 88       	rjmp	80007d08 <_vfprintf_r+0x888>
80007cfa:	72 1c       	ld.w	r12,r9[0x4]
80007cfc:	50 7c       	stdsp	sp[0x1c],r12
80007cfe:	f2 c8 ff f8 	sub	r8,r9,-8
80007d02:	51 08       	stdsp	sp[0x40],r8
80007d04:	72 09       	ld.w	r9,r9[0x0]
80007d06:	50 59       	stdsp	sp[0x14],r9
80007d08:	40 5b       	lddsp	r11,sp[0x14]
80007d0a:	40 7a       	lddsp	r10,sp[0x1c]
80007d0c:	e0 a0 19 54 	rcall	8000afb4 <__isinfd>
80007d10:	18 96       	mov	r6,r12
80007d12:	c1 70       	breq	80007d40 <_vfprintf_r+0x8c0>
80007d14:	30 08       	mov	r8,0
80007d16:	30 09       	mov	r9,0
80007d18:	40 5b       	lddsp	r11,sp[0x14]
80007d1a:	40 7a       	lddsp	r10,sp[0x1c]
80007d1c:	e0 a0 1d a8 	rcall	8000b86c <__avr32_f64_cmp_lt>
80007d20:	c0 40       	breq	80007d28 <_vfprintf_r+0x8a8>
80007d22:	32 d8       	mov	r8,45
80007d24:	fb 68 06 bb 	st.b	sp[1723],r8
80007d28:	fe c8 aa e8 	sub	r8,pc,-21784
80007d2c:	fe c6 aa e8 	sub	r6,pc,-21784
80007d30:	a7 d5       	cbr	r5,0x7
80007d32:	e0 40 00 47 	cp.w	r0,71
80007d36:	f0 06 17 a0 	movle	r6,r8
80007d3a:	30 32       	mov	r2,3
80007d3c:	e0 8f 06 ce 	bral	80008ad8 <_vfprintf_r+0x1658>
80007d40:	40 5b       	lddsp	r11,sp[0x14]
80007d42:	40 7a       	lddsp	r10,sp[0x1c]
80007d44:	e0 a0 19 4d 	rcall	8000afde <__isnand>
80007d48:	c0 e0       	breq	80007d64 <_vfprintf_r+0x8e4>
80007d4a:	50 26       	stdsp	sp[0x8],r6
80007d4c:	fe c8 ab 04 	sub	r8,pc,-21756
80007d50:	fe c6 ab 04 	sub	r6,pc,-21756
80007d54:	a7 d5       	cbr	r5,0x7
80007d56:	e0 40 00 47 	cp.w	r0,71
80007d5a:	f0 06 17 a0 	movle	r6,r8
80007d5e:	30 32       	mov	r2,3
80007d60:	e0 8f 06 c2 	bral	80008ae4 <_vfprintf_r+0x1664>
80007d64:	40 2a       	lddsp	r10,sp[0x8]
80007d66:	5b fa       	cp.w	r10,-1
80007d68:	c0 41       	brne	80007d70 <_vfprintf_r+0x8f0>
80007d6a:	30 69       	mov	r9,6
80007d6c:	50 29       	stdsp	sp[0x8],r9
80007d6e:	c1 18       	rjmp	80007d90 <_vfprintf_r+0x910>
80007d70:	e0 40 00 47 	cp.w	r0,71
80007d74:	5f 09       	sreq	r9
80007d76:	e0 40 00 67 	cp.w	r0,103
80007d7a:	5f 08       	sreq	r8
80007d7c:	f3 e8 10 08 	or	r8,r9,r8
80007d80:	f8 08 18 00 	cp.b	r8,r12
80007d84:	c0 60       	breq	80007d90 <_vfprintf_r+0x910>
80007d86:	40 28       	lddsp	r8,sp[0x8]
80007d88:	58 08       	cp.w	r8,0
80007d8a:	f9 b8 00 01 	moveq	r8,1
80007d8e:	50 28       	stdsp	sp[0x8],r8
80007d90:	40 78       	lddsp	r8,sp[0x1c]
80007d92:	40 59       	lddsp	r9,sp[0x14]
80007d94:	fa e9 06 94 	st.d	sp[1684],r8
80007d98:	a9 a5       	sbr	r5,0x8
80007d9a:	fa f8 06 94 	ld.w	r8,sp[1684]
80007d9e:	58 08       	cp.w	r8,0
80007da0:	c0 65       	brlt	80007dac <_vfprintf_r+0x92c>
80007da2:	40 5e       	lddsp	lr,sp[0x14]
80007da4:	30 0c       	mov	r12,0
80007da6:	50 6e       	stdsp	sp[0x18],lr
80007da8:	50 9c       	stdsp	sp[0x24],r12
80007daa:	c0 78       	rjmp	80007db8 <_vfprintf_r+0x938>
80007dac:	40 5b       	lddsp	r11,sp[0x14]
80007dae:	32 da       	mov	r10,45
80007db0:	ee 1b 80 00 	eorh	r11,0x8000
80007db4:	50 9a       	stdsp	sp[0x24],r10
80007db6:	50 6b       	stdsp	sp[0x18],r11
80007db8:	e0 40 00 46 	cp.w	r0,70
80007dbc:	5f 09       	sreq	r9
80007dbe:	e0 40 00 66 	cp.w	r0,102
80007dc2:	5f 08       	sreq	r8
80007dc4:	f3 e8 10 08 	or	r8,r9,r8
80007dc8:	50 48       	stdsp	sp[0x10],r8
80007dca:	c0 40       	breq	80007dd2 <_vfprintf_r+0x952>
80007dcc:	40 22       	lddsp	r2,sp[0x8]
80007dce:	30 39       	mov	r9,3
80007dd0:	c1 08       	rjmp	80007df0 <_vfprintf_r+0x970>
80007dd2:	e0 40 00 45 	cp.w	r0,69
80007dd6:	5f 09       	sreq	r9
80007dd8:	e0 40 00 65 	cp.w	r0,101
80007ddc:	5f 08       	sreq	r8
80007dde:	40 22       	lddsp	r2,sp[0x8]
80007de0:	10 49       	or	r9,r8
80007de2:	2f f2       	sub	r2,-1
80007de4:	40 46       	lddsp	r6,sp[0x10]
80007de6:	ec 09 18 00 	cp.b	r9,r6
80007dea:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007dee:	30 29       	mov	r9,2
80007df0:	fa c8 f9 5c 	sub	r8,sp,-1700
80007df4:	1a d8       	st.w	--sp,r8
80007df6:	fa c8 f9 54 	sub	r8,sp,-1708
80007dfa:	1a d8       	st.w	--sp,r8
80007dfc:	fa c8 f9 4c 	sub	r8,sp,-1716
80007e00:	08 9c       	mov	r12,r4
80007e02:	1a d8       	st.w	--sp,r8
80007e04:	04 98       	mov	r8,r2
80007e06:	40 9b       	lddsp	r11,sp[0x24]
80007e08:	40 aa       	lddsp	r10,sp[0x28]
80007e0a:	e0 a0 0b c3 	rcall	80009590 <_dtoa_r>
80007e0e:	e0 40 00 47 	cp.w	r0,71
80007e12:	5f 19       	srne	r9
80007e14:	e0 40 00 67 	cp.w	r0,103
80007e18:	5f 18       	srne	r8
80007e1a:	18 96       	mov	r6,r12
80007e1c:	2f dd       	sub	sp,-12
80007e1e:	f3 e8 00 08 	and	r8,r9,r8
80007e22:	c0 41       	brne	80007e2a <_vfprintf_r+0x9aa>
80007e24:	ed b5 00 00 	bld	r5,0x0
80007e28:	c3 01       	brne	80007e88 <_vfprintf_r+0xa08>
80007e2a:	ec 02 00 0e 	add	lr,r6,r2
80007e2e:	50 3e       	stdsp	sp[0xc],lr
80007e30:	40 4c       	lddsp	r12,sp[0x10]
80007e32:	58 0c       	cp.w	r12,0
80007e34:	c1 50       	breq	80007e5e <_vfprintf_r+0x9de>
80007e36:	0d 89       	ld.ub	r9,r6[0x0]
80007e38:	33 08       	mov	r8,48
80007e3a:	f0 09 18 00 	cp.b	r9,r8
80007e3e:	c0 b1       	brne	80007e54 <_vfprintf_r+0x9d4>
80007e40:	30 08       	mov	r8,0
80007e42:	30 09       	mov	r9,0
80007e44:	40 6b       	lddsp	r11,sp[0x18]
80007e46:	40 7a       	lddsp	r10,sp[0x1c]
80007e48:	e0 a0 1c cb 	rcall	8000b7de <__avr32_f64_cmp_eq>
80007e4c:	fb b2 00 01 	rsubeq	r2,1
80007e50:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007e54:	40 3b       	lddsp	r11,sp[0xc]
80007e56:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007e5a:	10 0b       	add	r11,r8
80007e5c:	50 3b       	stdsp	sp[0xc],r11
80007e5e:	40 6b       	lddsp	r11,sp[0x18]
80007e60:	30 08       	mov	r8,0
80007e62:	30 09       	mov	r9,0
80007e64:	40 7a       	lddsp	r10,sp[0x1c]
80007e66:	e0 a0 1c bc 	rcall	8000b7de <__avr32_f64_cmp_eq>
80007e6a:	c0 90       	breq	80007e7c <_vfprintf_r+0x9fc>
80007e6c:	40 3a       	lddsp	r10,sp[0xc]
80007e6e:	fb 4a 06 a4 	st.w	sp[1700],r10
80007e72:	c0 58       	rjmp	80007e7c <_vfprintf_r+0x9fc>
80007e74:	10 c9       	st.b	r8++,r9
80007e76:	fb 48 06 a4 	st.w	sp[1700],r8
80007e7a:	c0 28       	rjmp	80007e7e <_vfprintf_r+0x9fe>
80007e7c:	33 09       	mov	r9,48
80007e7e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007e82:	40 3e       	lddsp	lr,sp[0xc]
80007e84:	1c 38       	cp.w	r8,lr
80007e86:	cf 73       	brcs	80007e74 <_vfprintf_r+0x9f4>
80007e88:	e0 40 00 47 	cp.w	r0,71
80007e8c:	5f 09       	sreq	r9
80007e8e:	e0 40 00 67 	cp.w	r0,103
80007e92:	5f 08       	sreq	r8
80007e94:	f3 e8 10 08 	or	r8,r9,r8
80007e98:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007e9c:	0c 19       	sub	r9,r6
80007e9e:	50 69       	stdsp	sp[0x18],r9
80007ea0:	58 08       	cp.w	r8,0
80007ea2:	c0 b0       	breq	80007eb8 <_vfprintf_r+0xa38>
80007ea4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007ea8:	5b d8       	cp.w	r8,-3
80007eaa:	c0 55       	brlt	80007eb4 <_vfprintf_r+0xa34>
80007eac:	40 2c       	lddsp	r12,sp[0x8]
80007eae:	18 38       	cp.w	r8,r12
80007eb0:	e0 8a 00 6a 	brle	80007f84 <_vfprintf_r+0xb04>
80007eb4:	20 20       	sub	r0,2
80007eb6:	c0 58       	rjmp	80007ec0 <_vfprintf_r+0xa40>
80007eb8:	e0 40 00 65 	cp.w	r0,101
80007ebc:	e0 89 00 46 	brgt	80007f48 <_vfprintf_r+0xac8>
80007ec0:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007ec4:	fb 60 06 9c 	st.b	sp[1692],r0
80007ec8:	20 1b       	sub	r11,1
80007eca:	fb 4b 06 ac 	st.w	sp[1708],r11
80007ece:	c0 47       	brpl	80007ed6 <_vfprintf_r+0xa56>
80007ed0:	5c 3b       	neg	r11
80007ed2:	32 d8       	mov	r8,45
80007ed4:	c0 28       	rjmp	80007ed8 <_vfprintf_r+0xa58>
80007ed6:	32 b8       	mov	r8,43
80007ed8:	fb 68 06 9d 	st.b	sp[1693],r8
80007edc:	58 9b       	cp.w	r11,9
80007ede:	e0 8a 00 1d 	brle	80007f18 <_vfprintf_r+0xa98>
80007ee2:	fa c9 fa 35 	sub	r9,sp,-1483
80007ee6:	30 aa       	mov	r10,10
80007ee8:	12 98       	mov	r8,r9
80007eea:	0e 9c       	mov	r12,r7
80007eec:	0c 92       	mov	r2,r6
80007eee:	f6 0a 0c 06 	divs	r6,r11,r10
80007ef2:	0e 9b       	mov	r11,r7
80007ef4:	2d 0b       	sub	r11,-48
80007ef6:	10 fb       	st.b	--r8,r11
80007ef8:	0c 9b       	mov	r11,r6
80007efa:	58 96       	cp.w	r6,9
80007efc:	fe 99 ff f9 	brgt	80007eee <_vfprintf_r+0xa6e>
80007f00:	2d 0b       	sub	r11,-48
80007f02:	18 97       	mov	r7,r12
80007f04:	04 96       	mov	r6,r2
80007f06:	10 fb       	st.b	--r8,r11
80007f08:	fa ca f9 62 	sub	r10,sp,-1694
80007f0c:	c0 38       	rjmp	80007f12 <_vfprintf_r+0xa92>
80007f0e:	11 3b       	ld.ub	r11,r8++
80007f10:	14 cb       	st.b	r10++,r11
80007f12:	12 38       	cp.w	r8,r9
80007f14:	cf d3       	brcs	80007f0e <_vfprintf_r+0xa8e>
80007f16:	c0 98       	rjmp	80007f28 <_vfprintf_r+0xaa8>
80007f18:	2d 0b       	sub	r11,-48
80007f1a:	33 08       	mov	r8,48
80007f1c:	fb 6b 06 9f 	st.b	sp[1695],r11
80007f20:	fb 68 06 9e 	st.b	sp[1694],r8
80007f24:	fa ca f9 60 	sub	r10,sp,-1696
80007f28:	fa c8 f9 64 	sub	r8,sp,-1692
80007f2c:	f4 08 01 08 	sub	r8,r10,r8
80007f30:	50 e8       	stdsp	sp[0x38],r8
80007f32:	10 92       	mov	r2,r8
80007f34:	40 6b       	lddsp	r11,sp[0x18]
80007f36:	16 02       	add	r2,r11
80007f38:	58 1b       	cp.w	r11,1
80007f3a:	e0 89 00 05 	brgt	80007f44 <_vfprintf_r+0xac4>
80007f3e:	ed b5 00 00 	bld	r5,0x0
80007f42:	c3 51       	brne	80007fac <_vfprintf_r+0xb2c>
80007f44:	2f f2       	sub	r2,-1
80007f46:	c3 38       	rjmp	80007fac <_vfprintf_r+0xb2c>
80007f48:	e0 40 00 66 	cp.w	r0,102
80007f4c:	c1 c1       	brne	80007f84 <_vfprintf_r+0xb04>
80007f4e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007f52:	58 02       	cp.w	r2,0
80007f54:	e0 8a 00 0c 	brle	80007f6c <_vfprintf_r+0xaec>
80007f58:	40 2a       	lddsp	r10,sp[0x8]
80007f5a:	58 0a       	cp.w	r10,0
80007f5c:	c0 41       	brne	80007f64 <_vfprintf_r+0xae4>
80007f5e:	ed b5 00 00 	bld	r5,0x0
80007f62:	c2 51       	brne	80007fac <_vfprintf_r+0xb2c>
80007f64:	2f f2       	sub	r2,-1
80007f66:	40 29       	lddsp	r9,sp[0x8]
80007f68:	12 02       	add	r2,r9
80007f6a:	c0 b8       	rjmp	80007f80 <_vfprintf_r+0xb00>
80007f6c:	40 28       	lddsp	r8,sp[0x8]
80007f6e:	58 08       	cp.w	r8,0
80007f70:	c0 61       	brne	80007f7c <_vfprintf_r+0xafc>
80007f72:	ed b5 00 00 	bld	r5,0x0
80007f76:	c0 30       	breq	80007f7c <_vfprintf_r+0xafc>
80007f78:	30 12       	mov	r2,1
80007f7a:	c1 98       	rjmp	80007fac <_vfprintf_r+0xb2c>
80007f7c:	40 22       	lddsp	r2,sp[0x8]
80007f7e:	2f e2       	sub	r2,-2
80007f80:	36 60       	mov	r0,102
80007f82:	c1 58       	rjmp	80007fac <_vfprintf_r+0xb2c>
80007f84:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007f88:	40 6e       	lddsp	lr,sp[0x18]
80007f8a:	1c 32       	cp.w	r2,lr
80007f8c:	c0 65       	brlt	80007f98 <_vfprintf_r+0xb18>
80007f8e:	ed b5 00 00 	bld	r5,0x0
80007f92:	f7 b2 00 ff 	subeq	r2,-1
80007f96:	c0 a8       	rjmp	80007faa <_vfprintf_r+0xb2a>
80007f98:	e4 08 11 02 	rsub	r8,r2,2
80007f9c:	40 6c       	lddsp	r12,sp[0x18]
80007f9e:	58 02       	cp.w	r2,0
80007fa0:	f0 02 17 a0 	movle	r2,r8
80007fa4:	f9 b2 09 01 	movgt	r2,1
80007fa8:	18 02       	add	r2,r12
80007faa:	36 70       	mov	r0,103
80007fac:	40 9b       	lddsp	r11,sp[0x24]
80007fae:	58 0b       	cp.w	r11,0
80007fb0:	e0 80 05 94 	breq	80008ad8 <_vfprintf_r+0x1658>
80007fb4:	32 d8       	mov	r8,45
80007fb6:	fb 68 06 bb 	st.b	sp[1723],r8
80007fba:	e0 8f 05 93 	bral	80008ae0 <_vfprintf_r+0x1660>
80007fbe:	50 a7       	stdsp	sp[0x28],r7
80007fc0:	04 94       	mov	r4,r2
80007fc2:	0c 97       	mov	r7,r6
80007fc4:	02 92       	mov	r2,r1
80007fc6:	06 96       	mov	r6,r3
80007fc8:	40 41       	lddsp	r1,sp[0x10]
80007fca:	40 93       	lddsp	r3,sp[0x24]
80007fcc:	0e 99       	mov	r9,r7
80007fce:	ed b5 00 05 	bld	r5,0x5
80007fd2:	c4 81       	brne	80008062 <_vfprintf_r+0xbe2>
80007fd4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fd8:	40 3e       	lddsp	lr,sp[0xc]
80007fda:	58 0e       	cp.w	lr,0
80007fdc:	c1 d0       	breq	80008016 <_vfprintf_r+0xb96>
80007fde:	10 36       	cp.w	r6,r8
80007fe0:	c0 64       	brge	80007fec <_vfprintf_r+0xb6c>
80007fe2:	fa cc f9 44 	sub	r12,sp,-1724
80007fe6:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007fea:	c1 d8       	rjmp	80008024 <_vfprintf_r+0xba4>
80007fec:	fa c8 f9 50 	sub	r8,sp,-1712
80007ff0:	1a d8       	st.w	--sp,r8
80007ff2:	fa c8 fa b8 	sub	r8,sp,-1352
80007ff6:	04 9a       	mov	r10,r2
80007ff8:	1a d8       	st.w	--sp,r8
80007ffa:	fa c8 fb b4 	sub	r8,sp,-1100
80007ffe:	0c 9b       	mov	r11,r6
80008000:	1a d8       	st.w	--sp,r8
80008002:	08 9c       	mov	r12,r4
80008004:	fa c8 f9 40 	sub	r8,sp,-1728
80008008:	fa c9 ff b4 	sub	r9,sp,-76
8000800c:	fe b0 f8 a2 	rcall	80007150 <get_arg>
80008010:	2f dd       	sub	sp,-12
80008012:	78 0a       	ld.w	r10,r12[0x0]
80008014:	c2 08       	rjmp	80008054 <_vfprintf_r+0xbd4>
80008016:	2f f7       	sub	r7,-1
80008018:	10 39       	cp.w	r9,r8
8000801a:	c0 84       	brge	8000802a <_vfprintf_r+0xbaa>
8000801c:	fa cb f9 44 	sub	r11,sp,-1724
80008020:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008024:	ec fa fd 88 	ld.w	r10,r6[-632]
80008028:	c1 68       	rjmp	80008054 <_vfprintf_r+0xbd4>
8000802a:	41 09       	lddsp	r9,sp[0x40]
8000802c:	59 f8       	cp.w	r8,31
8000802e:	e0 89 00 10 	brgt	8000804e <_vfprintf_r+0xbce>
80008032:	f2 ca ff fc 	sub	r10,r9,-4
80008036:	51 0a       	stdsp	sp[0x40],r10
80008038:	fa c6 f9 44 	sub	r6,sp,-1724
8000803c:	72 0a       	ld.w	r10,r9[0x0]
8000803e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008042:	f3 4a fd 88 	st.w	r9[-632],r10
80008046:	2f f8       	sub	r8,-1
80008048:	fb 48 06 b4 	st.w	sp[1716],r8
8000804c:	c0 48       	rjmp	80008054 <_vfprintf_r+0xbd4>
8000804e:	72 0a       	ld.w	r10,r9[0x0]
80008050:	2f c9       	sub	r9,-4
80008052:	51 09       	stdsp	sp[0x40],r9
80008054:	40 be       	lddsp	lr,sp[0x2c]
80008056:	1c 98       	mov	r8,lr
80008058:	95 1e       	st.w	r10[0x4],lr
8000805a:	bf 58       	asr	r8,0x1f
8000805c:	95 08       	st.w	r10[0x0],r8
8000805e:	fe 9f fa 9f 	bral	8000759c <_vfprintf_r+0x11c>
80008062:	ed b5 00 04 	bld	r5,0x4
80008066:	c4 80       	breq	800080f6 <_vfprintf_r+0xc76>
80008068:	e2 15 00 40 	andl	r5,0x40,COH
8000806c:	c4 50       	breq	800080f6 <_vfprintf_r+0xc76>
8000806e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008072:	40 3c       	lddsp	r12,sp[0xc]
80008074:	58 0c       	cp.w	r12,0
80008076:	c1 d0       	breq	800080b0 <_vfprintf_r+0xc30>
80008078:	10 36       	cp.w	r6,r8
8000807a:	c0 64       	brge	80008086 <_vfprintf_r+0xc06>
8000807c:	fa cb f9 44 	sub	r11,sp,-1724
80008080:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008084:	c1 d8       	rjmp	800080be <_vfprintf_r+0xc3e>
80008086:	fa c8 f9 50 	sub	r8,sp,-1712
8000808a:	1a d8       	st.w	--sp,r8
8000808c:	fa c8 fa b8 	sub	r8,sp,-1352
80008090:	04 9a       	mov	r10,r2
80008092:	1a d8       	st.w	--sp,r8
80008094:	fa c8 fb b4 	sub	r8,sp,-1100
80008098:	0c 9b       	mov	r11,r6
8000809a:	1a d8       	st.w	--sp,r8
8000809c:	08 9c       	mov	r12,r4
8000809e:	fa c8 f9 40 	sub	r8,sp,-1728
800080a2:	fa c9 ff b4 	sub	r9,sp,-76
800080a6:	fe b0 f8 55 	rcall	80007150 <get_arg>
800080aa:	2f dd       	sub	sp,-12
800080ac:	78 0a       	ld.w	r10,r12[0x0]
800080ae:	c2 08       	rjmp	800080ee <_vfprintf_r+0xc6e>
800080b0:	2f f7       	sub	r7,-1
800080b2:	10 39       	cp.w	r9,r8
800080b4:	c0 84       	brge	800080c4 <_vfprintf_r+0xc44>
800080b6:	fa ca f9 44 	sub	r10,sp,-1724
800080ba:	f4 06 00 36 	add	r6,r10,r6<<0x3
800080be:	ec fa fd 88 	ld.w	r10,r6[-632]
800080c2:	c1 68       	rjmp	800080ee <_vfprintf_r+0xc6e>
800080c4:	41 09       	lddsp	r9,sp[0x40]
800080c6:	59 f8       	cp.w	r8,31
800080c8:	e0 89 00 10 	brgt	800080e8 <_vfprintf_r+0xc68>
800080cc:	f2 ca ff fc 	sub	r10,r9,-4
800080d0:	51 0a       	stdsp	sp[0x40],r10
800080d2:	fa c6 f9 44 	sub	r6,sp,-1724
800080d6:	72 0a       	ld.w	r10,r9[0x0]
800080d8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800080dc:	f3 4a fd 88 	st.w	r9[-632],r10
800080e0:	2f f8       	sub	r8,-1
800080e2:	fb 48 06 b4 	st.w	sp[1716],r8
800080e6:	c0 48       	rjmp	800080ee <_vfprintf_r+0xc6e>
800080e8:	72 0a       	ld.w	r10,r9[0x0]
800080ea:	2f c9       	sub	r9,-4
800080ec:	51 09       	stdsp	sp[0x40],r9
800080ee:	40 be       	lddsp	lr,sp[0x2c]
800080f0:	b4 0e       	st.h	r10[0x0],lr
800080f2:	fe 9f fa 55 	bral	8000759c <_vfprintf_r+0x11c>
800080f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080fa:	40 3c       	lddsp	r12,sp[0xc]
800080fc:	58 0c       	cp.w	r12,0
800080fe:	c1 d0       	breq	80008138 <_vfprintf_r+0xcb8>
80008100:	10 36       	cp.w	r6,r8
80008102:	c0 64       	brge	8000810e <_vfprintf_r+0xc8e>
80008104:	fa cb f9 44 	sub	r11,sp,-1724
80008108:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000810c:	c1 d8       	rjmp	80008146 <_vfprintf_r+0xcc6>
8000810e:	fa c8 f9 50 	sub	r8,sp,-1712
80008112:	1a d8       	st.w	--sp,r8
80008114:	fa c8 fa b8 	sub	r8,sp,-1352
80008118:	04 9a       	mov	r10,r2
8000811a:	1a d8       	st.w	--sp,r8
8000811c:	fa c8 fb b4 	sub	r8,sp,-1100
80008120:	0c 9b       	mov	r11,r6
80008122:	1a d8       	st.w	--sp,r8
80008124:	08 9c       	mov	r12,r4
80008126:	fa c8 f9 40 	sub	r8,sp,-1728
8000812a:	fa c9 ff b4 	sub	r9,sp,-76
8000812e:	fe b0 f8 11 	rcall	80007150 <get_arg>
80008132:	2f dd       	sub	sp,-12
80008134:	78 0a       	ld.w	r10,r12[0x0]
80008136:	c2 08       	rjmp	80008176 <_vfprintf_r+0xcf6>
80008138:	2f f7       	sub	r7,-1
8000813a:	10 39       	cp.w	r9,r8
8000813c:	c0 84       	brge	8000814c <_vfprintf_r+0xccc>
8000813e:	fa ca f9 44 	sub	r10,sp,-1724
80008142:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008146:	ec fa fd 88 	ld.w	r10,r6[-632]
8000814a:	c1 68       	rjmp	80008176 <_vfprintf_r+0xcf6>
8000814c:	41 09       	lddsp	r9,sp[0x40]
8000814e:	59 f8       	cp.w	r8,31
80008150:	e0 89 00 10 	brgt	80008170 <_vfprintf_r+0xcf0>
80008154:	f2 ca ff fc 	sub	r10,r9,-4
80008158:	51 0a       	stdsp	sp[0x40],r10
8000815a:	fa c6 f9 44 	sub	r6,sp,-1724
8000815e:	72 0a       	ld.w	r10,r9[0x0]
80008160:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008164:	f3 4a fd 88 	st.w	r9[-632],r10
80008168:	2f f8       	sub	r8,-1
8000816a:	fb 48 06 b4 	st.w	sp[1716],r8
8000816e:	c0 48       	rjmp	80008176 <_vfprintf_r+0xcf6>
80008170:	72 0a       	ld.w	r10,r9[0x0]
80008172:	2f c9       	sub	r9,-4
80008174:	51 09       	stdsp	sp[0x40],r9
80008176:	40 be       	lddsp	lr,sp[0x2c]
80008178:	95 0e       	st.w	r10[0x0],lr
8000817a:	fe 9f fa 11 	bral	8000759c <_vfprintf_r+0x11c>
8000817e:	50 a7       	stdsp	sp[0x28],r7
80008180:	50 80       	stdsp	sp[0x20],r0
80008182:	0c 97       	mov	r7,r6
80008184:	04 94       	mov	r4,r2
80008186:	06 96       	mov	r6,r3
80008188:	02 92       	mov	r2,r1
8000818a:	40 93       	lddsp	r3,sp[0x24]
8000818c:	10 90       	mov	r0,r8
8000818e:	40 41       	lddsp	r1,sp[0x10]
80008190:	a5 a5       	sbr	r5,0x4
80008192:	c0 a8       	rjmp	800081a6 <_vfprintf_r+0xd26>
80008194:	50 a7       	stdsp	sp[0x28],r7
80008196:	50 80       	stdsp	sp[0x20],r0
80008198:	0c 97       	mov	r7,r6
8000819a:	04 94       	mov	r4,r2
8000819c:	06 96       	mov	r6,r3
8000819e:	02 92       	mov	r2,r1
800081a0:	40 93       	lddsp	r3,sp[0x24]
800081a2:	10 90       	mov	r0,r8
800081a4:	40 41       	lddsp	r1,sp[0x10]
800081a6:	ed b5 00 05 	bld	r5,0x5
800081aa:	c5 d1       	brne	80008264 <_vfprintf_r+0xde4>
800081ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081b0:	40 3c       	lddsp	r12,sp[0xc]
800081b2:	58 0c       	cp.w	r12,0
800081b4:	c2 60       	breq	80008200 <_vfprintf_r+0xd80>
800081b6:	10 36       	cp.w	r6,r8
800081b8:	c0 a4       	brge	800081cc <_vfprintf_r+0xd4c>
800081ba:	fa cb f9 44 	sub	r11,sp,-1724
800081be:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081c2:	ec e8 fd 88 	ld.d	r8,r6[-632]
800081c6:	fa e9 00 00 	st.d	sp[0],r8
800081ca:	c1 88       	rjmp	800081fa <_vfprintf_r+0xd7a>
800081cc:	fa c8 f9 50 	sub	r8,sp,-1712
800081d0:	1a d8       	st.w	--sp,r8
800081d2:	fa c8 fa b8 	sub	r8,sp,-1352
800081d6:	04 9a       	mov	r10,r2
800081d8:	1a d8       	st.w	--sp,r8
800081da:	0c 9b       	mov	r11,r6
800081dc:	fa c8 fb b4 	sub	r8,sp,-1100
800081e0:	08 9c       	mov	r12,r4
800081e2:	1a d8       	st.w	--sp,r8
800081e4:	fa c8 f9 40 	sub	r8,sp,-1728
800081e8:	fa c9 ff b4 	sub	r9,sp,-76
800081ec:	fe b0 f7 b2 	rcall	80007150 <get_arg>
800081f0:	2f dd       	sub	sp,-12
800081f2:	f8 ea 00 00 	ld.d	r10,r12[0]
800081f6:	fa eb 00 00 	st.d	sp[0],r10
800081fa:	30 08       	mov	r8,0
800081fc:	e0 8f 03 de 	bral	800089b8 <_vfprintf_r+0x1538>
80008200:	ee ca ff ff 	sub	r10,r7,-1
80008204:	10 37       	cp.w	r7,r8
80008206:	c0 b4       	brge	8000821c <_vfprintf_r+0xd9c>
80008208:	fa c9 f9 44 	sub	r9,sp,-1724
8000820c:	14 97       	mov	r7,r10
8000820e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008212:	ec ea fd 88 	ld.d	r10,r6[-632]
80008216:	fa eb 00 00 	st.d	sp[0],r10
8000821a:	c1 88       	rjmp	8000824a <_vfprintf_r+0xdca>
8000821c:	41 09       	lddsp	r9,sp[0x40]
8000821e:	59 f8       	cp.w	r8,31
80008220:	e0 89 00 18 	brgt	80008250 <_vfprintf_r+0xdd0>
80008224:	f2 e6 00 00 	ld.d	r6,r9[0]
80008228:	f2 cb ff f8 	sub	r11,r9,-8
8000822c:	fa e7 00 00 	st.d	sp[0],r6
80008230:	51 0b       	stdsp	sp[0x40],r11
80008232:	fa c6 f9 44 	sub	r6,sp,-1724
80008236:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000823a:	fa e6 00 00 	ld.d	r6,sp[0]
8000823e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008242:	2f f8       	sub	r8,-1
80008244:	14 97       	mov	r7,r10
80008246:	fb 48 06 b4 	st.w	sp[1716],r8
8000824a:	40 38       	lddsp	r8,sp[0xc]
8000824c:	e0 8f 03 b6 	bral	800089b8 <_vfprintf_r+0x1538>
80008250:	f2 e6 00 00 	ld.d	r6,r9[0]
80008254:	40 38       	lddsp	r8,sp[0xc]
80008256:	fa e7 00 00 	st.d	sp[0],r6
8000825a:	2f 89       	sub	r9,-8
8000825c:	14 97       	mov	r7,r10
8000825e:	51 09       	stdsp	sp[0x40],r9
80008260:	e0 8f 03 ac 	bral	800089b8 <_vfprintf_r+0x1538>
80008264:	ed b5 00 04 	bld	r5,0x4
80008268:	c1 61       	brne	80008294 <_vfprintf_r+0xe14>
8000826a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000826e:	40 3e       	lddsp	lr,sp[0xc]
80008270:	58 0e       	cp.w	lr,0
80008272:	c0 80       	breq	80008282 <_vfprintf_r+0xe02>
80008274:	10 36       	cp.w	r6,r8
80008276:	c6 74       	brge	80008344 <_vfprintf_r+0xec4>
80008278:	fa cc f9 44 	sub	r12,sp,-1724
8000827c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008280:	c8 08       	rjmp	80008380 <_vfprintf_r+0xf00>
80008282:	ee ca ff ff 	sub	r10,r7,-1
80008286:	10 37       	cp.w	r7,r8
80008288:	c7 f4       	brge	80008386 <_vfprintf_r+0xf06>
8000828a:	fa cb f9 44 	sub	r11,sp,-1724
8000828e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008292:	c7 68       	rjmp	8000837e <_vfprintf_r+0xefe>
80008294:	ed b5 00 06 	bld	r5,0x6
80008298:	c4 a1       	brne	8000832c <_vfprintf_r+0xeac>
8000829a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000829e:	40 3c       	lddsp	r12,sp[0xc]
800082a0:	58 0c       	cp.w	r12,0
800082a2:	c1 d0       	breq	800082dc <_vfprintf_r+0xe5c>
800082a4:	10 36       	cp.w	r6,r8
800082a6:	c0 64       	brge	800082b2 <_vfprintf_r+0xe32>
800082a8:	fa cb f9 44 	sub	r11,sp,-1724
800082ac:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082b0:	c1 f8       	rjmp	800082ee <_vfprintf_r+0xe6e>
800082b2:	fa c8 f9 50 	sub	r8,sp,-1712
800082b6:	1a d8       	st.w	--sp,r8
800082b8:	fa c8 fa b8 	sub	r8,sp,-1352
800082bc:	1a d8       	st.w	--sp,r8
800082be:	fa c8 fb b4 	sub	r8,sp,-1100
800082c2:	1a d8       	st.w	--sp,r8
800082c4:	fa c8 f9 40 	sub	r8,sp,-1728
800082c8:	fa c9 ff b4 	sub	r9,sp,-76
800082cc:	04 9a       	mov	r10,r2
800082ce:	0c 9b       	mov	r11,r6
800082d0:	08 9c       	mov	r12,r4
800082d2:	fe b0 f7 3f 	rcall	80007150 <get_arg>
800082d6:	2f dd       	sub	sp,-12
800082d8:	98 18       	ld.sh	r8,r12[0x2]
800082da:	c2 68       	rjmp	80008326 <_vfprintf_r+0xea6>
800082dc:	ee ca ff ff 	sub	r10,r7,-1
800082e0:	10 37       	cp.w	r7,r8
800082e2:	c0 94       	brge	800082f4 <_vfprintf_r+0xe74>
800082e4:	fa c9 f9 44 	sub	r9,sp,-1724
800082e8:	14 97       	mov	r7,r10
800082ea:	f2 06 00 36 	add	r6,r9,r6<<0x3
800082ee:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800082f2:	c1 a8       	rjmp	80008326 <_vfprintf_r+0xea6>
800082f4:	41 09       	lddsp	r9,sp[0x40]
800082f6:	59 f8       	cp.w	r8,31
800082f8:	e0 89 00 13 	brgt	8000831e <_vfprintf_r+0xe9e>
800082fc:	f2 cb ff fc 	sub	r11,r9,-4
80008300:	51 0b       	stdsp	sp[0x40],r11
80008302:	72 09       	ld.w	r9,r9[0x0]
80008304:	fa c6 f9 44 	sub	r6,sp,-1724
80008308:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000830c:	2f f8       	sub	r8,-1
8000830e:	f7 49 fd 88 	st.w	r11[-632],r9
80008312:	fb 48 06 b4 	st.w	sp[1716],r8
80008316:	14 97       	mov	r7,r10
80008318:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000831c:	c0 58       	rjmp	80008326 <_vfprintf_r+0xea6>
8000831e:	92 18       	ld.sh	r8,r9[0x2]
80008320:	14 97       	mov	r7,r10
80008322:	2f c9       	sub	r9,-4
80008324:	51 09       	stdsp	sp[0x40],r9
80008326:	5c 78       	castu.h	r8
80008328:	50 18       	stdsp	sp[0x4],r8
8000832a:	c4 68       	rjmp	800083b6 <_vfprintf_r+0xf36>
8000832c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008330:	40 3c       	lddsp	r12,sp[0xc]
80008332:	58 0c       	cp.w	r12,0
80008334:	c1 d0       	breq	8000836e <_vfprintf_r+0xeee>
80008336:	10 36       	cp.w	r6,r8
80008338:	c0 64       	brge	80008344 <_vfprintf_r+0xec4>
8000833a:	fa cb f9 44 	sub	r11,sp,-1724
8000833e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008342:	c1 f8       	rjmp	80008380 <_vfprintf_r+0xf00>
80008344:	fa c8 f9 50 	sub	r8,sp,-1712
80008348:	1a d8       	st.w	--sp,r8
8000834a:	fa c8 fa b8 	sub	r8,sp,-1352
8000834e:	0c 9b       	mov	r11,r6
80008350:	1a d8       	st.w	--sp,r8
80008352:	fa c8 fb b4 	sub	r8,sp,-1100
80008356:	04 9a       	mov	r10,r2
80008358:	1a d8       	st.w	--sp,r8
8000835a:	08 9c       	mov	r12,r4
8000835c:	fa c8 f9 40 	sub	r8,sp,-1728
80008360:	fa c9 ff b4 	sub	r9,sp,-76
80008364:	fe b0 f6 f6 	rcall	80007150 <get_arg>
80008368:	2f dd       	sub	sp,-12
8000836a:	78 0b       	ld.w	r11,r12[0x0]
8000836c:	c2 48       	rjmp	800083b4 <_vfprintf_r+0xf34>
8000836e:	ee ca ff ff 	sub	r10,r7,-1
80008372:	10 37       	cp.w	r7,r8
80008374:	c0 94       	brge	80008386 <_vfprintf_r+0xf06>
80008376:	fa c9 f9 44 	sub	r9,sp,-1724
8000837a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000837e:	14 97       	mov	r7,r10
80008380:	ec fb fd 88 	ld.w	r11,r6[-632]
80008384:	c1 88       	rjmp	800083b4 <_vfprintf_r+0xf34>
80008386:	41 09       	lddsp	r9,sp[0x40]
80008388:	59 f8       	cp.w	r8,31
8000838a:	e0 89 00 11 	brgt	800083ac <_vfprintf_r+0xf2c>
8000838e:	f2 cb ff fc 	sub	r11,r9,-4
80008392:	51 0b       	stdsp	sp[0x40],r11
80008394:	fa c6 f9 44 	sub	r6,sp,-1724
80008398:	72 0b       	ld.w	r11,r9[0x0]
8000839a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000839e:	f3 4b fd 88 	st.w	r9[-632],r11
800083a2:	2f f8       	sub	r8,-1
800083a4:	14 97       	mov	r7,r10
800083a6:	fb 48 06 b4 	st.w	sp[1716],r8
800083aa:	c0 58       	rjmp	800083b4 <_vfprintf_r+0xf34>
800083ac:	72 0b       	ld.w	r11,r9[0x0]
800083ae:	14 97       	mov	r7,r10
800083b0:	2f c9       	sub	r9,-4
800083b2:	51 09       	stdsp	sp[0x40],r9
800083b4:	50 1b       	stdsp	sp[0x4],r11
800083b6:	30 0e       	mov	lr,0
800083b8:	50 0e       	stdsp	sp[0x0],lr
800083ba:	1c 98       	mov	r8,lr
800083bc:	e0 8f 02 fe 	bral	800089b8 <_vfprintf_r+0x1538>
800083c0:	50 a7       	stdsp	sp[0x28],r7
800083c2:	50 80       	stdsp	sp[0x20],r0
800083c4:	0c 97       	mov	r7,r6
800083c6:	04 94       	mov	r4,r2
800083c8:	06 96       	mov	r6,r3
800083ca:	02 92       	mov	r2,r1
800083cc:	40 93       	lddsp	r3,sp[0x24]
800083ce:	40 41       	lddsp	r1,sp[0x10]
800083d0:	0e 99       	mov	r9,r7
800083d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083d6:	40 3c       	lddsp	r12,sp[0xc]
800083d8:	58 0c       	cp.w	r12,0
800083da:	c1 d0       	breq	80008414 <_vfprintf_r+0xf94>
800083dc:	10 36       	cp.w	r6,r8
800083de:	c0 64       	brge	800083ea <_vfprintf_r+0xf6a>
800083e0:	fa cb f9 44 	sub	r11,sp,-1724
800083e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083e8:	c1 d8       	rjmp	80008422 <_vfprintf_r+0xfa2>
800083ea:	fa c8 f9 50 	sub	r8,sp,-1712
800083ee:	1a d8       	st.w	--sp,r8
800083f0:	fa c8 fa b8 	sub	r8,sp,-1352
800083f4:	1a d8       	st.w	--sp,r8
800083f6:	fa c8 fb b4 	sub	r8,sp,-1100
800083fa:	1a d8       	st.w	--sp,r8
800083fc:	fa c9 ff b4 	sub	r9,sp,-76
80008400:	fa c8 f9 40 	sub	r8,sp,-1728
80008404:	04 9a       	mov	r10,r2
80008406:	0c 9b       	mov	r11,r6
80008408:	08 9c       	mov	r12,r4
8000840a:	fe b0 f6 a3 	rcall	80007150 <get_arg>
8000840e:	2f dd       	sub	sp,-12
80008410:	78 09       	ld.w	r9,r12[0x0]
80008412:	c2 18       	rjmp	80008454 <_vfprintf_r+0xfd4>
80008414:	2f f7       	sub	r7,-1
80008416:	10 39       	cp.w	r9,r8
80008418:	c0 84       	brge	80008428 <_vfprintf_r+0xfa8>
8000841a:	fa ca f9 44 	sub	r10,sp,-1724
8000841e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008422:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008426:	c1 78       	rjmp	80008454 <_vfprintf_r+0xfd4>
80008428:	41 09       	lddsp	r9,sp[0x40]
8000842a:	59 f8       	cp.w	r8,31
8000842c:	e0 89 00 10 	brgt	8000844c <_vfprintf_r+0xfcc>
80008430:	f2 ca ff fc 	sub	r10,r9,-4
80008434:	51 0a       	stdsp	sp[0x40],r10
80008436:	fa c6 f9 44 	sub	r6,sp,-1724
8000843a:	72 09       	ld.w	r9,r9[0x0]
8000843c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008440:	f5 49 fd 88 	st.w	r10[-632],r9
80008444:	2f f8       	sub	r8,-1
80008446:	fb 48 06 b4 	st.w	sp[1716],r8
8000844a:	c0 58       	rjmp	80008454 <_vfprintf_r+0xfd4>
8000844c:	f2 c8 ff fc 	sub	r8,r9,-4
80008450:	51 08       	stdsp	sp[0x40],r8
80008452:	72 09       	ld.w	r9,r9[0x0]
80008454:	33 08       	mov	r8,48
80008456:	fb 68 06 b8 	st.b	sp[1720],r8
8000845a:	37 88       	mov	r8,120
8000845c:	30 0e       	mov	lr,0
8000845e:	fb 68 06 b9 	st.b	sp[1721],r8
80008462:	fe cc b2 12 	sub	r12,pc,-19950
80008466:	50 19       	stdsp	sp[0x4],r9
80008468:	a1 b5       	sbr	r5,0x1
8000846a:	50 0e       	stdsp	sp[0x0],lr
8000846c:	50 dc       	stdsp	sp[0x34],r12
8000846e:	30 28       	mov	r8,2
80008470:	37 80       	mov	r0,120
80008472:	e0 8f 02 a3 	bral	800089b8 <_vfprintf_r+0x1538>
80008476:	50 a7       	stdsp	sp[0x28],r7
80008478:	50 80       	stdsp	sp[0x20],r0
8000847a:	10 90       	mov	r0,r8
8000847c:	30 08       	mov	r8,0
8000847e:	fb 68 06 bb 	st.b	sp[1723],r8
80008482:	0c 97       	mov	r7,r6
80008484:	04 94       	mov	r4,r2
80008486:	06 96       	mov	r6,r3
80008488:	02 92       	mov	r2,r1
8000848a:	40 93       	lddsp	r3,sp[0x24]
8000848c:	40 41       	lddsp	r1,sp[0x10]
8000848e:	0e 99       	mov	r9,r7
80008490:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008494:	40 3b       	lddsp	r11,sp[0xc]
80008496:	58 0b       	cp.w	r11,0
80008498:	c1 d0       	breq	800084d2 <_vfprintf_r+0x1052>
8000849a:	10 36       	cp.w	r6,r8
8000849c:	c0 64       	brge	800084a8 <_vfprintf_r+0x1028>
8000849e:	fa ca f9 44 	sub	r10,sp,-1724
800084a2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800084a6:	c1 d8       	rjmp	800084e0 <_vfprintf_r+0x1060>
800084a8:	fa c8 f9 50 	sub	r8,sp,-1712
800084ac:	1a d8       	st.w	--sp,r8
800084ae:	fa c8 fa b8 	sub	r8,sp,-1352
800084b2:	1a d8       	st.w	--sp,r8
800084b4:	fa c8 fb b4 	sub	r8,sp,-1100
800084b8:	0c 9b       	mov	r11,r6
800084ba:	1a d8       	st.w	--sp,r8
800084bc:	04 9a       	mov	r10,r2
800084be:	fa c8 f9 40 	sub	r8,sp,-1728
800084c2:	fa c9 ff b4 	sub	r9,sp,-76
800084c6:	08 9c       	mov	r12,r4
800084c8:	fe b0 f6 44 	rcall	80007150 <get_arg>
800084cc:	2f dd       	sub	sp,-12
800084ce:	78 06       	ld.w	r6,r12[0x0]
800084d0:	c2 08       	rjmp	80008510 <_vfprintf_r+0x1090>
800084d2:	2f f7       	sub	r7,-1
800084d4:	10 39       	cp.w	r9,r8
800084d6:	c0 84       	brge	800084e6 <_vfprintf_r+0x1066>
800084d8:	fa c9 f9 44 	sub	r9,sp,-1724
800084dc:	f2 06 00 36 	add	r6,r9,r6<<0x3
800084e0:	ec f6 fd 88 	ld.w	r6,r6[-632]
800084e4:	c1 68       	rjmp	80008510 <_vfprintf_r+0x1090>
800084e6:	41 09       	lddsp	r9,sp[0x40]
800084e8:	59 f8       	cp.w	r8,31
800084ea:	e0 89 00 10 	brgt	8000850a <_vfprintf_r+0x108a>
800084ee:	f2 ca ff fc 	sub	r10,r9,-4
800084f2:	51 0a       	stdsp	sp[0x40],r10
800084f4:	72 06       	ld.w	r6,r9[0x0]
800084f6:	fa ce f9 44 	sub	lr,sp,-1724
800084fa:	fc 08 00 39 	add	r9,lr,r8<<0x3
800084fe:	f3 46 fd 88 	st.w	r9[-632],r6
80008502:	2f f8       	sub	r8,-1
80008504:	fb 48 06 b4 	st.w	sp[1716],r8
80008508:	c0 48       	rjmp	80008510 <_vfprintf_r+0x1090>
8000850a:	72 06       	ld.w	r6,r9[0x0]
8000850c:	2f c9       	sub	r9,-4
8000850e:	51 09       	stdsp	sp[0x40],r9
80008510:	40 2c       	lddsp	r12,sp[0x8]
80008512:	58 0c       	cp.w	r12,0
80008514:	c1 05       	brlt	80008534 <_vfprintf_r+0x10b4>
80008516:	18 9a       	mov	r10,r12
80008518:	30 0b       	mov	r11,0
8000851a:	0c 9c       	mov	r12,r6
8000851c:	e0 a0 12 38 	rcall	8000a98c <memchr>
80008520:	e0 80 02 df 	breq	80008ade <_vfprintf_r+0x165e>
80008524:	f8 06 01 02 	sub	r2,r12,r6
80008528:	40 2b       	lddsp	r11,sp[0x8]
8000852a:	16 32       	cp.w	r2,r11
8000852c:	e0 89 02 d9 	brgt	80008ade <_vfprintf_r+0x165e>
80008530:	e0 8f 02 d4 	bral	80008ad8 <_vfprintf_r+0x1658>
80008534:	30 0a       	mov	r10,0
80008536:	0c 9c       	mov	r12,r6
80008538:	50 2a       	stdsp	sp[0x8],r10
8000853a:	fe b0 f5 85 	rcall	80007044 <strlen>
8000853e:	18 92       	mov	r2,r12
80008540:	e0 8f 02 d2 	bral	80008ae4 <_vfprintf_r+0x1664>
80008544:	50 a7       	stdsp	sp[0x28],r7
80008546:	50 80       	stdsp	sp[0x20],r0
80008548:	0c 97       	mov	r7,r6
8000854a:	04 94       	mov	r4,r2
8000854c:	06 96       	mov	r6,r3
8000854e:	02 92       	mov	r2,r1
80008550:	40 93       	lddsp	r3,sp[0x24]
80008552:	10 90       	mov	r0,r8
80008554:	40 41       	lddsp	r1,sp[0x10]
80008556:	a5 a5       	sbr	r5,0x4
80008558:	c0 a8       	rjmp	8000856c <_vfprintf_r+0x10ec>
8000855a:	50 a7       	stdsp	sp[0x28],r7
8000855c:	50 80       	stdsp	sp[0x20],r0
8000855e:	0c 97       	mov	r7,r6
80008560:	04 94       	mov	r4,r2
80008562:	06 96       	mov	r6,r3
80008564:	02 92       	mov	r2,r1
80008566:	40 93       	lddsp	r3,sp[0x24]
80008568:	10 90       	mov	r0,r8
8000856a:	40 41       	lddsp	r1,sp[0x10]
8000856c:	ed b5 00 05 	bld	r5,0x5
80008570:	c5 61       	brne	8000861c <_vfprintf_r+0x119c>
80008572:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008576:	40 39       	lddsp	r9,sp[0xc]
80008578:	58 09       	cp.w	r9,0
8000857a:	c2 10       	breq	800085bc <_vfprintf_r+0x113c>
8000857c:	10 36       	cp.w	r6,r8
8000857e:	c0 74       	brge	8000858c <_vfprintf_r+0x110c>
80008580:	fa c8 f9 44 	sub	r8,sp,-1724
80008584:	f0 06 00 36 	add	r6,r8,r6<<0x3
80008588:	c2 38       	rjmp	800085ce <_vfprintf_r+0x114e>
8000858a:	d7 03       	nop
8000858c:	fa c8 f9 50 	sub	r8,sp,-1712
80008590:	1a d8       	st.w	--sp,r8
80008592:	fa c8 fa b8 	sub	r8,sp,-1352
80008596:	1a d8       	st.w	--sp,r8
80008598:	fa c8 fb b4 	sub	r8,sp,-1100
8000859c:	1a d8       	st.w	--sp,r8
8000859e:	fa c8 f9 40 	sub	r8,sp,-1728
800085a2:	fa c9 ff b4 	sub	r9,sp,-76
800085a6:	04 9a       	mov	r10,r2
800085a8:	0c 9b       	mov	r11,r6
800085aa:	08 9c       	mov	r12,r4
800085ac:	fe b0 f5 d2 	rcall	80007150 <get_arg>
800085b0:	2f dd       	sub	sp,-12
800085b2:	f8 e8 00 00 	ld.d	r8,r12[0]
800085b6:	fa e9 00 00 	st.d	sp[0],r8
800085ba:	c2 e8       	rjmp	80008616 <_vfprintf_r+0x1196>
800085bc:	ee ca ff ff 	sub	r10,r7,-1
800085c0:	10 37       	cp.w	r7,r8
800085c2:	c0 b4       	brge	800085d8 <_vfprintf_r+0x1158>
800085c4:	fa c8 f9 44 	sub	r8,sp,-1724
800085c8:	14 97       	mov	r7,r10
800085ca:	f0 06 00 36 	add	r6,r8,r6<<0x3
800085ce:	ec ea fd 88 	ld.d	r10,r6[-632]
800085d2:	fa eb 00 00 	st.d	sp[0],r10
800085d6:	c2 08       	rjmp	80008616 <_vfprintf_r+0x1196>
800085d8:	41 09       	lddsp	r9,sp[0x40]
800085da:	59 f8       	cp.w	r8,31
800085dc:	e0 89 00 16 	brgt	80008608 <_vfprintf_r+0x1188>
800085e0:	f2 e6 00 00 	ld.d	r6,r9[0]
800085e4:	f2 cb ff f8 	sub	r11,r9,-8
800085e8:	fa e7 00 00 	st.d	sp[0],r6
800085ec:	51 0b       	stdsp	sp[0x40],r11
800085ee:	fa c6 f9 44 	sub	r6,sp,-1724
800085f2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085f6:	fa e6 00 00 	ld.d	r6,sp[0]
800085fa:	f2 e7 fd 88 	st.d	r9[-632],r6
800085fe:	2f f8       	sub	r8,-1
80008600:	14 97       	mov	r7,r10
80008602:	fb 48 06 b4 	st.w	sp[1716],r8
80008606:	c0 88       	rjmp	80008616 <_vfprintf_r+0x1196>
80008608:	f2 e6 00 00 	ld.d	r6,r9[0]
8000860c:	2f 89       	sub	r9,-8
8000860e:	fa e7 00 00 	st.d	sp[0],r6
80008612:	51 09       	stdsp	sp[0x40],r9
80008614:	14 97       	mov	r7,r10
80008616:	30 18       	mov	r8,1
80008618:	e0 8f 01 d0 	bral	800089b8 <_vfprintf_r+0x1538>
8000861c:	ed b5 00 04 	bld	r5,0x4
80008620:	c1 61       	brne	8000864c <_vfprintf_r+0x11cc>
80008622:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008626:	40 3e       	lddsp	lr,sp[0xc]
80008628:	58 0e       	cp.w	lr,0
8000862a:	c0 80       	breq	8000863a <_vfprintf_r+0x11ba>
8000862c:	10 36       	cp.w	r6,r8
8000862e:	c6 74       	brge	800086fc <_vfprintf_r+0x127c>
80008630:	fa cc f9 44 	sub	r12,sp,-1724
80008634:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008638:	c8 08       	rjmp	80008738 <_vfprintf_r+0x12b8>
8000863a:	ee ca ff ff 	sub	r10,r7,-1
8000863e:	10 37       	cp.w	r7,r8
80008640:	c7 f4       	brge	8000873e <_vfprintf_r+0x12be>
80008642:	fa cb f9 44 	sub	r11,sp,-1724
80008646:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000864a:	c7 68       	rjmp	80008736 <_vfprintf_r+0x12b6>
8000864c:	ed b5 00 06 	bld	r5,0x6
80008650:	c4 a1       	brne	800086e4 <_vfprintf_r+0x1264>
80008652:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008656:	40 3c       	lddsp	r12,sp[0xc]
80008658:	58 0c       	cp.w	r12,0
8000865a:	c1 d0       	breq	80008694 <_vfprintf_r+0x1214>
8000865c:	10 36       	cp.w	r6,r8
8000865e:	c0 64       	brge	8000866a <_vfprintf_r+0x11ea>
80008660:	fa cb f9 44 	sub	r11,sp,-1724
80008664:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008668:	c1 f8       	rjmp	800086a6 <_vfprintf_r+0x1226>
8000866a:	fa c8 f9 50 	sub	r8,sp,-1712
8000866e:	1a d8       	st.w	--sp,r8
80008670:	fa c8 fa b8 	sub	r8,sp,-1352
80008674:	1a d8       	st.w	--sp,r8
80008676:	fa c8 fb b4 	sub	r8,sp,-1100
8000867a:	1a d8       	st.w	--sp,r8
8000867c:	fa c8 f9 40 	sub	r8,sp,-1728
80008680:	fa c9 ff b4 	sub	r9,sp,-76
80008684:	04 9a       	mov	r10,r2
80008686:	0c 9b       	mov	r11,r6
80008688:	08 9c       	mov	r12,r4
8000868a:	fe b0 f5 63 	rcall	80007150 <get_arg>
8000868e:	2f dd       	sub	sp,-12
80008690:	98 18       	ld.sh	r8,r12[0x2]
80008692:	c2 68       	rjmp	800086de <_vfprintf_r+0x125e>
80008694:	ee ca ff ff 	sub	r10,r7,-1
80008698:	10 37       	cp.w	r7,r8
8000869a:	c0 94       	brge	800086ac <_vfprintf_r+0x122c>
8000869c:	fa c9 f9 44 	sub	r9,sp,-1724
800086a0:	14 97       	mov	r7,r10
800086a2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086a6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800086aa:	c1 a8       	rjmp	800086de <_vfprintf_r+0x125e>
800086ac:	41 09       	lddsp	r9,sp[0x40]
800086ae:	59 f8       	cp.w	r8,31
800086b0:	e0 89 00 13 	brgt	800086d6 <_vfprintf_r+0x1256>
800086b4:	f2 cb ff fc 	sub	r11,r9,-4
800086b8:	51 0b       	stdsp	sp[0x40],r11
800086ba:	72 09       	ld.w	r9,r9[0x0]
800086bc:	fa c6 f9 44 	sub	r6,sp,-1724
800086c0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800086c4:	2f f8       	sub	r8,-1
800086c6:	f7 49 fd 88 	st.w	r11[-632],r9
800086ca:	fb 48 06 b4 	st.w	sp[1716],r8
800086ce:	14 97       	mov	r7,r10
800086d0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800086d4:	c0 58       	rjmp	800086de <_vfprintf_r+0x125e>
800086d6:	92 18       	ld.sh	r8,r9[0x2]
800086d8:	14 97       	mov	r7,r10
800086da:	2f c9       	sub	r9,-4
800086dc:	51 09       	stdsp	sp[0x40],r9
800086de:	5c 78       	castu.h	r8
800086e0:	50 18       	stdsp	sp[0x4],r8
800086e2:	c4 68       	rjmp	8000876e <_vfprintf_r+0x12ee>
800086e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086e8:	40 3c       	lddsp	r12,sp[0xc]
800086ea:	58 0c       	cp.w	r12,0
800086ec:	c1 d0       	breq	80008726 <_vfprintf_r+0x12a6>
800086ee:	10 36       	cp.w	r6,r8
800086f0:	c0 64       	brge	800086fc <_vfprintf_r+0x127c>
800086f2:	fa cb f9 44 	sub	r11,sp,-1724
800086f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800086fa:	c1 f8       	rjmp	80008738 <_vfprintf_r+0x12b8>
800086fc:	fa c8 f9 50 	sub	r8,sp,-1712
80008700:	1a d8       	st.w	--sp,r8
80008702:	fa c8 fa b8 	sub	r8,sp,-1352
80008706:	0c 9b       	mov	r11,r6
80008708:	1a d8       	st.w	--sp,r8
8000870a:	fa c8 fb b4 	sub	r8,sp,-1100
8000870e:	04 9a       	mov	r10,r2
80008710:	1a d8       	st.w	--sp,r8
80008712:	08 9c       	mov	r12,r4
80008714:	fa c8 f9 40 	sub	r8,sp,-1728
80008718:	fa c9 ff b4 	sub	r9,sp,-76
8000871c:	fe b0 f5 1a 	rcall	80007150 <get_arg>
80008720:	2f dd       	sub	sp,-12
80008722:	78 0b       	ld.w	r11,r12[0x0]
80008724:	c2 48       	rjmp	8000876c <_vfprintf_r+0x12ec>
80008726:	ee ca ff ff 	sub	r10,r7,-1
8000872a:	10 37       	cp.w	r7,r8
8000872c:	c0 94       	brge	8000873e <_vfprintf_r+0x12be>
8000872e:	fa c9 f9 44 	sub	r9,sp,-1724
80008732:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008736:	14 97       	mov	r7,r10
80008738:	ec fb fd 88 	ld.w	r11,r6[-632]
8000873c:	c1 88       	rjmp	8000876c <_vfprintf_r+0x12ec>
8000873e:	41 09       	lddsp	r9,sp[0x40]
80008740:	59 f8       	cp.w	r8,31
80008742:	e0 89 00 11 	brgt	80008764 <_vfprintf_r+0x12e4>
80008746:	f2 cb ff fc 	sub	r11,r9,-4
8000874a:	51 0b       	stdsp	sp[0x40],r11
8000874c:	fa c6 f9 44 	sub	r6,sp,-1724
80008750:	72 0b       	ld.w	r11,r9[0x0]
80008752:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008756:	f3 4b fd 88 	st.w	r9[-632],r11
8000875a:	2f f8       	sub	r8,-1
8000875c:	14 97       	mov	r7,r10
8000875e:	fb 48 06 b4 	st.w	sp[1716],r8
80008762:	c0 58       	rjmp	8000876c <_vfprintf_r+0x12ec>
80008764:	72 0b       	ld.w	r11,r9[0x0]
80008766:	14 97       	mov	r7,r10
80008768:	2f c9       	sub	r9,-4
8000876a:	51 09       	stdsp	sp[0x40],r9
8000876c:	50 1b       	stdsp	sp[0x4],r11
8000876e:	30 0e       	mov	lr,0
80008770:	30 18       	mov	r8,1
80008772:	50 0e       	stdsp	sp[0x0],lr
80008774:	c2 29       	rjmp	800089b8 <_vfprintf_r+0x1538>
80008776:	50 a7       	stdsp	sp[0x28],r7
80008778:	50 80       	stdsp	sp[0x20],r0
8000877a:	0c 97       	mov	r7,r6
8000877c:	04 94       	mov	r4,r2
8000877e:	06 96       	mov	r6,r3
80008780:	02 92       	mov	r2,r1
80008782:	fe cc b5 32 	sub	r12,pc,-19150
80008786:	40 93       	lddsp	r3,sp[0x24]
80008788:	10 90       	mov	r0,r8
8000878a:	40 41       	lddsp	r1,sp[0x10]
8000878c:	50 dc       	stdsp	sp[0x34],r12
8000878e:	ed b5 00 05 	bld	r5,0x5
80008792:	c5 51       	brne	8000883c <_vfprintf_r+0x13bc>
80008794:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008798:	40 3b       	lddsp	r11,sp[0xc]
8000879a:	58 0b       	cp.w	r11,0
8000879c:	c2 20       	breq	800087e0 <_vfprintf_r+0x1360>
8000879e:	10 36       	cp.w	r6,r8
800087a0:	c0 a4       	brge	800087b4 <_vfprintf_r+0x1334>
800087a2:	fa ca f9 44 	sub	r10,sp,-1724
800087a6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800087aa:	ec e8 fd 88 	ld.d	r8,r6[-632]
800087ae:	fa e9 00 00 	st.d	sp[0],r8
800087b2:	cf 28       	rjmp	80008996 <_vfprintf_r+0x1516>
800087b4:	fa c8 f9 50 	sub	r8,sp,-1712
800087b8:	1a d8       	st.w	--sp,r8
800087ba:	fa c8 fa b8 	sub	r8,sp,-1352
800087be:	04 9a       	mov	r10,r2
800087c0:	1a d8       	st.w	--sp,r8
800087c2:	0c 9b       	mov	r11,r6
800087c4:	fa c8 fb b4 	sub	r8,sp,-1100
800087c8:	08 9c       	mov	r12,r4
800087ca:	1a d8       	st.w	--sp,r8
800087cc:	fa c8 f9 40 	sub	r8,sp,-1728
800087d0:	fa c9 ff b4 	sub	r9,sp,-76
800087d4:	fe b0 f4 be 	rcall	80007150 <get_arg>
800087d8:	2f dd       	sub	sp,-12
800087da:	f8 ea 00 00 	ld.d	r10,r12[0]
800087de:	c0 c8       	rjmp	800087f6 <_vfprintf_r+0x1376>
800087e0:	ee ca ff ff 	sub	r10,r7,-1
800087e4:	10 37       	cp.w	r7,r8
800087e6:	c0 b4       	brge	800087fc <_vfprintf_r+0x137c>
800087e8:	fa c9 f9 44 	sub	r9,sp,-1724
800087ec:	14 97       	mov	r7,r10
800087ee:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087f2:	ec ea fd 88 	ld.d	r10,r6[-632]
800087f6:	fa eb 00 00 	st.d	sp[0],r10
800087fa:	cc e8       	rjmp	80008996 <_vfprintf_r+0x1516>
800087fc:	41 09       	lddsp	r9,sp[0x40]
800087fe:	59 f8       	cp.w	r8,31
80008800:	e0 89 00 16 	brgt	8000882c <_vfprintf_r+0x13ac>
80008804:	f2 e6 00 00 	ld.d	r6,r9[0]
80008808:	f2 cb ff f8 	sub	r11,r9,-8
8000880c:	fa e7 00 00 	st.d	sp[0],r6
80008810:	51 0b       	stdsp	sp[0x40],r11
80008812:	fa c6 f9 44 	sub	r6,sp,-1724
80008816:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000881a:	fa e6 00 00 	ld.d	r6,sp[0]
8000881e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008822:	2f f8       	sub	r8,-1
80008824:	14 97       	mov	r7,r10
80008826:	fb 48 06 b4 	st.w	sp[1716],r8
8000882a:	cb 68       	rjmp	80008996 <_vfprintf_r+0x1516>
8000882c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008830:	2f 89       	sub	r9,-8
80008832:	fa e7 00 00 	st.d	sp[0],r6
80008836:	51 09       	stdsp	sp[0x40],r9
80008838:	14 97       	mov	r7,r10
8000883a:	ca e8       	rjmp	80008996 <_vfprintf_r+0x1516>
8000883c:	ed b5 00 04 	bld	r5,0x4
80008840:	c1 71       	brne	8000886e <_vfprintf_r+0x13ee>
80008842:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008846:	40 3e       	lddsp	lr,sp[0xc]
80008848:	58 0e       	cp.w	lr,0
8000884a:	c0 80       	breq	8000885a <_vfprintf_r+0x13da>
8000884c:	10 36       	cp.w	r6,r8
8000884e:	c6 94       	brge	80008920 <_vfprintf_r+0x14a0>
80008850:	fa cc f9 44 	sub	r12,sp,-1724
80008854:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008858:	c8 28       	rjmp	8000895c <_vfprintf_r+0x14dc>
8000885a:	ee ca ff ff 	sub	r10,r7,-1
8000885e:	10 37       	cp.w	r7,r8
80008860:	e0 84 00 81 	brge	80008962 <_vfprintf_r+0x14e2>
80008864:	fa cb f9 44 	sub	r11,sp,-1724
80008868:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000886c:	c7 78       	rjmp	8000895a <_vfprintf_r+0x14da>
8000886e:	ed b5 00 06 	bld	r5,0x6
80008872:	c4 b1       	brne	80008908 <_vfprintf_r+0x1488>
80008874:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008878:	40 3c       	lddsp	r12,sp[0xc]
8000887a:	58 0c       	cp.w	r12,0
8000887c:	c1 d0       	breq	800088b6 <_vfprintf_r+0x1436>
8000887e:	10 36       	cp.w	r6,r8
80008880:	c0 64       	brge	8000888c <_vfprintf_r+0x140c>
80008882:	fa cb f9 44 	sub	r11,sp,-1724
80008886:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000888a:	c1 f8       	rjmp	800088c8 <_vfprintf_r+0x1448>
8000888c:	fa c8 f9 50 	sub	r8,sp,-1712
80008890:	1a d8       	st.w	--sp,r8
80008892:	fa c8 fa b8 	sub	r8,sp,-1352
80008896:	1a d8       	st.w	--sp,r8
80008898:	fa c8 fb b4 	sub	r8,sp,-1100
8000889c:	1a d8       	st.w	--sp,r8
8000889e:	fa c8 f9 40 	sub	r8,sp,-1728
800088a2:	fa c9 ff b4 	sub	r9,sp,-76
800088a6:	04 9a       	mov	r10,r2
800088a8:	0c 9b       	mov	r11,r6
800088aa:	08 9c       	mov	r12,r4
800088ac:	fe b0 f4 52 	rcall	80007150 <get_arg>
800088b0:	2f dd       	sub	sp,-12
800088b2:	98 18       	ld.sh	r8,r12[0x2]
800088b4:	c2 78       	rjmp	80008902 <_vfprintf_r+0x1482>
800088b6:	ee ca ff ff 	sub	r10,r7,-1
800088ba:	10 37       	cp.w	r7,r8
800088bc:	c0 a4       	brge	800088d0 <_vfprintf_r+0x1450>
800088be:	fa c9 f9 44 	sub	r9,sp,-1724
800088c2:	14 97       	mov	r7,r10
800088c4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088c8:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800088cc:	c1 b8       	rjmp	80008902 <_vfprintf_r+0x1482>
800088ce:	d7 03       	nop
800088d0:	41 09       	lddsp	r9,sp[0x40]
800088d2:	59 f8       	cp.w	r8,31
800088d4:	e0 89 00 13 	brgt	800088fa <_vfprintf_r+0x147a>
800088d8:	f2 cb ff fc 	sub	r11,r9,-4
800088dc:	51 0b       	stdsp	sp[0x40],r11
800088de:	72 09       	ld.w	r9,r9[0x0]
800088e0:	fa c6 f9 44 	sub	r6,sp,-1724
800088e4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800088e8:	2f f8       	sub	r8,-1
800088ea:	f7 49 fd 88 	st.w	r11[-632],r9
800088ee:	fb 48 06 b4 	st.w	sp[1716],r8
800088f2:	14 97       	mov	r7,r10
800088f4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800088f8:	c0 58       	rjmp	80008902 <_vfprintf_r+0x1482>
800088fa:	92 18       	ld.sh	r8,r9[0x2]
800088fc:	14 97       	mov	r7,r10
800088fe:	2f c9       	sub	r9,-4
80008900:	51 09       	stdsp	sp[0x40],r9
80008902:	5c 78       	castu.h	r8
80008904:	50 18       	stdsp	sp[0x4],r8
80008906:	c4 68       	rjmp	80008992 <_vfprintf_r+0x1512>
80008908:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000890c:	40 3c       	lddsp	r12,sp[0xc]
8000890e:	58 0c       	cp.w	r12,0
80008910:	c1 d0       	breq	8000894a <_vfprintf_r+0x14ca>
80008912:	10 36       	cp.w	r6,r8
80008914:	c0 64       	brge	80008920 <_vfprintf_r+0x14a0>
80008916:	fa cb f9 44 	sub	r11,sp,-1724
8000891a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000891e:	c1 f8       	rjmp	8000895c <_vfprintf_r+0x14dc>
80008920:	fa c8 f9 50 	sub	r8,sp,-1712
80008924:	1a d8       	st.w	--sp,r8
80008926:	fa c8 fa b8 	sub	r8,sp,-1352
8000892a:	0c 9b       	mov	r11,r6
8000892c:	1a d8       	st.w	--sp,r8
8000892e:	fa c8 fb b4 	sub	r8,sp,-1100
80008932:	04 9a       	mov	r10,r2
80008934:	1a d8       	st.w	--sp,r8
80008936:	08 9c       	mov	r12,r4
80008938:	fa c8 f9 40 	sub	r8,sp,-1728
8000893c:	fa c9 ff b4 	sub	r9,sp,-76
80008940:	fe b0 f4 08 	rcall	80007150 <get_arg>
80008944:	2f dd       	sub	sp,-12
80008946:	78 0b       	ld.w	r11,r12[0x0]
80008948:	c2 48       	rjmp	80008990 <_vfprintf_r+0x1510>
8000894a:	ee ca ff ff 	sub	r10,r7,-1
8000894e:	10 37       	cp.w	r7,r8
80008950:	c0 94       	brge	80008962 <_vfprintf_r+0x14e2>
80008952:	fa c9 f9 44 	sub	r9,sp,-1724
80008956:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000895a:	14 97       	mov	r7,r10
8000895c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008960:	c1 88       	rjmp	80008990 <_vfprintf_r+0x1510>
80008962:	41 09       	lddsp	r9,sp[0x40]
80008964:	59 f8       	cp.w	r8,31
80008966:	e0 89 00 11 	brgt	80008988 <_vfprintf_r+0x1508>
8000896a:	f2 cb ff fc 	sub	r11,r9,-4
8000896e:	51 0b       	stdsp	sp[0x40],r11
80008970:	fa c6 f9 44 	sub	r6,sp,-1724
80008974:	72 0b       	ld.w	r11,r9[0x0]
80008976:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000897a:	f3 4b fd 88 	st.w	r9[-632],r11
8000897e:	2f f8       	sub	r8,-1
80008980:	14 97       	mov	r7,r10
80008982:	fb 48 06 b4 	st.w	sp[1716],r8
80008986:	c0 58       	rjmp	80008990 <_vfprintf_r+0x1510>
80008988:	72 0b       	ld.w	r11,r9[0x0]
8000898a:	14 97       	mov	r7,r10
8000898c:	2f c9       	sub	r9,-4
8000898e:	51 09       	stdsp	sp[0x40],r9
80008990:	50 1b       	stdsp	sp[0x4],r11
80008992:	30 0e       	mov	lr,0
80008994:	50 0e       	stdsp	sp[0x0],lr
80008996:	40 08       	lddsp	r8,sp[0x0]
80008998:	40 1c       	lddsp	r12,sp[0x4]
8000899a:	18 48       	or	r8,r12
8000899c:	5f 19       	srne	r9
8000899e:	0a 98       	mov	r8,r5
800089a0:	eb e9 00 09 	and	r9,r5,r9
800089a4:	a1 b8       	sbr	r8,0x1
800089a6:	58 09       	cp.w	r9,0
800089a8:	c0 70       	breq	800089b6 <_vfprintf_r+0x1536>
800089aa:	10 95       	mov	r5,r8
800089ac:	fb 60 06 b9 	st.b	sp[1721],r0
800089b0:	33 08       	mov	r8,48
800089b2:	fb 68 06 b8 	st.b	sp[1720],r8
800089b6:	30 28       	mov	r8,2
800089b8:	30 09       	mov	r9,0
800089ba:	fb 69 06 bb 	st.b	sp[1723],r9
800089be:	0a 99       	mov	r9,r5
800089c0:	a7 d9       	cbr	r9,0x7
800089c2:	40 2b       	lddsp	r11,sp[0x8]
800089c4:	40 16       	lddsp	r6,sp[0x4]
800089c6:	58 0b       	cp.w	r11,0
800089c8:	5f 1a       	srne	r10
800089ca:	f2 05 17 40 	movge	r5,r9
800089ce:	fa c2 f9 78 	sub	r2,sp,-1672
800089d2:	40 09       	lddsp	r9,sp[0x0]
800089d4:	0c 49       	or	r9,r6
800089d6:	5f 19       	srne	r9
800089d8:	f5 e9 10 09 	or	r9,r10,r9
800089dc:	c5 c0       	breq	80008a94 <_vfprintf_r+0x1614>
800089de:	30 19       	mov	r9,1
800089e0:	f2 08 18 00 	cp.b	r8,r9
800089e4:	c0 60       	breq	800089f0 <_vfprintf_r+0x1570>
800089e6:	30 29       	mov	r9,2
800089e8:	f2 08 18 00 	cp.b	r8,r9
800089ec:	c0 41       	brne	800089f4 <_vfprintf_r+0x1574>
800089ee:	c3 c8       	rjmp	80008a66 <_vfprintf_r+0x15e6>
800089f0:	04 96       	mov	r6,r2
800089f2:	c3 08       	rjmp	80008a52 <_vfprintf_r+0x15d2>
800089f4:	04 96       	mov	r6,r2
800089f6:	fa e8 00 00 	ld.d	r8,sp[0]
800089fa:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800089fe:	2d 0a       	sub	r10,-48
80008a00:	0c fa       	st.b	--r6,r10
80008a02:	f0 0b 16 03 	lsr	r11,r8,0x3
80008a06:	f2 0c 16 03 	lsr	r12,r9,0x3
80008a0a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008a0e:	18 99       	mov	r9,r12
80008a10:	16 98       	mov	r8,r11
80008a12:	58 08       	cp.w	r8,0
80008a14:	5c 29       	cpc	r9
80008a16:	cf 21       	brne	800089fa <_vfprintf_r+0x157a>
80008a18:	fa e9 00 00 	st.d	sp[0],r8
80008a1c:	ed b5 00 00 	bld	r5,0x0
80008a20:	c4 51       	brne	80008aaa <_vfprintf_r+0x162a>
80008a22:	33 09       	mov	r9,48
80008a24:	f2 0a 18 00 	cp.b	r10,r9
80008a28:	c4 10       	breq	80008aaa <_vfprintf_r+0x162a>
80008a2a:	0c f9       	st.b	--r6,r9
80008a2c:	c3 f8       	rjmp	80008aaa <_vfprintf_r+0x162a>
80008a2e:	fa ea 00 00 	ld.d	r10,sp[0]
80008a32:	30 a8       	mov	r8,10
80008a34:	30 09       	mov	r9,0
80008a36:	e0 a0 1a 0d 	rcall	8000be50 <__avr32_umod64>
80008a3a:	30 a8       	mov	r8,10
80008a3c:	2d 0a       	sub	r10,-48
80008a3e:	30 09       	mov	r9,0
80008a40:	ac 8a       	st.b	r6[0x0],r10
80008a42:	fa ea 00 00 	ld.d	r10,sp[0]
80008a46:	e0 a0 18 d3 	rcall	8000bbec <__avr32_udiv64>
80008a4a:	16 99       	mov	r9,r11
80008a4c:	14 98       	mov	r8,r10
80008a4e:	fa e9 00 00 	st.d	sp[0],r8
80008a52:	20 16       	sub	r6,1
80008a54:	fa ea 00 00 	ld.d	r10,sp[0]
80008a58:	58 9a       	cp.w	r10,9
80008a5a:	5c 2b       	cpc	r11
80008a5c:	fe 9b ff e9 	brhi	80008a2e <_vfprintf_r+0x15ae>
80008a60:	1b f8       	ld.ub	r8,sp[0x7]
80008a62:	2d 08       	sub	r8,-48
80008a64:	c2 08       	rjmp	80008aa4 <_vfprintf_r+0x1624>
80008a66:	04 96       	mov	r6,r2
80008a68:	fa e8 00 00 	ld.d	r8,sp[0]
80008a6c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008a70:	40 de       	lddsp	lr,sp[0x34]
80008a72:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008a76:	0c fa       	st.b	--r6,r10
80008a78:	f2 0b 16 04 	lsr	r11,r9,0x4
80008a7c:	f0 0a 16 04 	lsr	r10,r8,0x4
80008a80:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008a84:	16 99       	mov	r9,r11
80008a86:	14 98       	mov	r8,r10
80008a88:	58 08       	cp.w	r8,0
80008a8a:	5c 29       	cpc	r9
80008a8c:	cf 01       	brne	80008a6c <_vfprintf_r+0x15ec>
80008a8e:	fa e9 00 00 	st.d	sp[0],r8
80008a92:	c0 c8       	rjmp	80008aaa <_vfprintf_r+0x162a>
80008a94:	58 08       	cp.w	r8,0
80008a96:	c0 91       	brne	80008aa8 <_vfprintf_r+0x1628>
80008a98:	ed b5 00 00 	bld	r5,0x0
80008a9c:	c0 61       	brne	80008aa8 <_vfprintf_r+0x1628>
80008a9e:	fa c6 f9 79 	sub	r6,sp,-1671
80008aa2:	33 08       	mov	r8,48
80008aa4:	ac 88       	st.b	r6[0x0],r8
80008aa6:	c0 28       	rjmp	80008aaa <_vfprintf_r+0x162a>
80008aa8:	04 96       	mov	r6,r2
80008aaa:	0c 12       	sub	r2,r6
80008aac:	c1 c8       	rjmp	80008ae4 <_vfprintf_r+0x1664>
80008aae:	50 a7       	stdsp	sp[0x28],r7
80008ab0:	50 80       	stdsp	sp[0x20],r0
80008ab2:	40 93       	lddsp	r3,sp[0x24]
80008ab4:	0c 97       	mov	r7,r6
80008ab6:	10 90       	mov	r0,r8
80008ab8:	04 94       	mov	r4,r2
80008aba:	40 41       	lddsp	r1,sp[0x10]
80008abc:	58 08       	cp.w	r8,0
80008abe:	e0 80 04 4f 	breq	8000935c <_vfprintf_r+0x1edc>
80008ac2:	fb 68 06 60 	st.b	sp[1632],r8
80008ac6:	30 0c       	mov	r12,0
80008ac8:	30 08       	mov	r8,0
80008aca:	30 12       	mov	r2,1
80008acc:	fb 68 06 bb 	st.b	sp[1723],r8
80008ad0:	50 2c       	stdsp	sp[0x8],r12
80008ad2:	fa c6 f9 a0 	sub	r6,sp,-1632
80008ad6:	c0 78       	rjmp	80008ae4 <_vfprintf_r+0x1664>
80008ad8:	30 0b       	mov	r11,0
80008ada:	50 2b       	stdsp	sp[0x8],r11
80008adc:	c0 48       	rjmp	80008ae4 <_vfprintf_r+0x1664>
80008ade:	40 22       	lddsp	r2,sp[0x8]
80008ae0:	30 0a       	mov	r10,0
80008ae2:	50 2a       	stdsp	sp[0x8],r10
80008ae4:	40 29       	lddsp	r9,sp[0x8]
80008ae6:	e4 09 0c 49 	max	r9,r2,r9
80008aea:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008aee:	50 39       	stdsp	sp[0xc],r9
80008af0:	0a 9e       	mov	lr,r5
80008af2:	30 09       	mov	r9,0
80008af4:	e2 1e 00 02 	andl	lr,0x2,COH
80008af8:	f2 08 18 00 	cp.b	r8,r9
80008afc:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008b00:	f7 b8 01 ff 	subne	r8,-1
80008b04:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008b08:	0a 9b       	mov	r11,r5
80008b0a:	58 0e       	cp.w	lr,0
80008b0c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008b10:	f7 bc 01 fe 	subne	r12,-2
80008b14:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008b18:	e2 1b 00 84 	andl	r11,0x84,COH
80008b1c:	50 fe       	stdsp	sp[0x3c],lr
80008b1e:	50 9b       	stdsp	sp[0x24],r11
80008b20:	c4 71       	brne	80008bae <_vfprintf_r+0x172e>
80008b22:	40 8a       	lddsp	r10,sp[0x20]
80008b24:	40 39       	lddsp	r9,sp[0xc]
80008b26:	12 1a       	sub	r10,r9
80008b28:	50 4a       	stdsp	sp[0x10],r10
80008b2a:	58 0a       	cp.w	r10,0
80008b2c:	e0 89 00 20 	brgt	80008b6c <_vfprintf_r+0x16ec>
80008b30:	c3 f8       	rjmp	80008bae <_vfprintf_r+0x172e>
80008b32:	2f 09       	sub	r9,-16
80008b34:	2f f8       	sub	r8,-1
80008b36:	fe ce b8 ce 	sub	lr,pc,-18226
80008b3a:	31 0c       	mov	r12,16
80008b3c:	fb 49 06 90 	st.w	sp[1680],r9
80008b40:	87 0e       	st.w	r3[0x0],lr
80008b42:	87 1c       	st.w	r3[0x4],r12
80008b44:	fb 48 06 8c 	st.w	sp[1676],r8
80008b48:	58 78       	cp.w	r8,7
80008b4a:	e0 89 00 04 	brgt	80008b52 <_vfprintf_r+0x16d2>
80008b4e:	2f 83       	sub	r3,-8
80008b50:	c0 b8       	rjmp	80008b66 <_vfprintf_r+0x16e6>
80008b52:	fa ca f9 78 	sub	r10,sp,-1672
80008b56:	02 9b       	mov	r11,r1
80008b58:	08 9c       	mov	r12,r4
80008b5a:	fe b0 f4 85 	rcall	80007464 <__sprint_r>
80008b5e:	e0 81 04 10 	brne	8000937e <_vfprintf_r+0x1efe>
80008b62:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b66:	40 4b       	lddsp	r11,sp[0x10]
80008b68:	21 0b       	sub	r11,16
80008b6a:	50 4b       	stdsp	sp[0x10],r11
80008b6c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b70:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b74:	fe ca b9 0c 	sub	r10,pc,-18164
80008b78:	40 4e       	lddsp	lr,sp[0x10]
80008b7a:	59 0e       	cp.w	lr,16
80008b7c:	fe 99 ff db 	brgt	80008b32 <_vfprintf_r+0x16b2>
80008b80:	1c 09       	add	r9,lr
80008b82:	2f f8       	sub	r8,-1
80008b84:	87 0a       	st.w	r3[0x0],r10
80008b86:	fb 49 06 90 	st.w	sp[1680],r9
80008b8a:	87 1e       	st.w	r3[0x4],lr
80008b8c:	fb 48 06 8c 	st.w	sp[1676],r8
80008b90:	58 78       	cp.w	r8,7
80008b92:	e0 89 00 04 	brgt	80008b9a <_vfprintf_r+0x171a>
80008b96:	2f 83       	sub	r3,-8
80008b98:	c0 b8       	rjmp	80008bae <_vfprintf_r+0x172e>
80008b9a:	fa ca f9 78 	sub	r10,sp,-1672
80008b9e:	02 9b       	mov	r11,r1
80008ba0:	08 9c       	mov	r12,r4
80008ba2:	fe b0 f4 61 	rcall	80007464 <__sprint_r>
80008ba6:	e0 81 03 ec 	brne	8000937e <_vfprintf_r+0x1efe>
80008baa:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bae:	30 09       	mov	r9,0
80008bb0:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008bb4:	f2 08 18 00 	cp.b	r8,r9
80008bb8:	c1 f0       	breq	80008bf6 <_vfprintf_r+0x1776>
80008bba:	fa f8 06 90 	ld.w	r8,sp[1680]
80008bbe:	fa c9 f9 45 	sub	r9,sp,-1723
80008bc2:	2f f8       	sub	r8,-1
80008bc4:	87 09       	st.w	r3[0x0],r9
80008bc6:	fb 48 06 90 	st.w	sp[1680],r8
80008bca:	30 19       	mov	r9,1
80008bcc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bd0:	87 19       	st.w	r3[0x4],r9
80008bd2:	2f f8       	sub	r8,-1
80008bd4:	fb 48 06 8c 	st.w	sp[1676],r8
80008bd8:	58 78       	cp.w	r8,7
80008bda:	e0 89 00 04 	brgt	80008be2 <_vfprintf_r+0x1762>
80008bde:	2f 83       	sub	r3,-8
80008be0:	c0 b8       	rjmp	80008bf6 <_vfprintf_r+0x1776>
80008be2:	fa ca f9 78 	sub	r10,sp,-1672
80008be6:	02 9b       	mov	r11,r1
80008be8:	08 9c       	mov	r12,r4
80008bea:	fe b0 f4 3d 	rcall	80007464 <__sprint_r>
80008bee:	e0 81 03 c8 	brne	8000937e <_vfprintf_r+0x1efe>
80008bf2:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bf6:	40 fc       	lddsp	r12,sp[0x3c]
80008bf8:	58 0c       	cp.w	r12,0
80008bfa:	c1 f0       	breq	80008c38 <_vfprintf_r+0x17b8>
80008bfc:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c00:	fa c9 f9 48 	sub	r9,sp,-1720
80008c04:	2f e8       	sub	r8,-2
80008c06:	87 09       	st.w	r3[0x0],r9
80008c08:	fb 48 06 90 	st.w	sp[1680],r8
80008c0c:	30 29       	mov	r9,2
80008c0e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c12:	87 19       	st.w	r3[0x4],r9
80008c14:	2f f8       	sub	r8,-1
80008c16:	fb 48 06 8c 	st.w	sp[1676],r8
80008c1a:	58 78       	cp.w	r8,7
80008c1c:	e0 89 00 04 	brgt	80008c24 <_vfprintf_r+0x17a4>
80008c20:	2f 83       	sub	r3,-8
80008c22:	c0 b8       	rjmp	80008c38 <_vfprintf_r+0x17b8>
80008c24:	fa ca f9 78 	sub	r10,sp,-1672
80008c28:	02 9b       	mov	r11,r1
80008c2a:	08 9c       	mov	r12,r4
80008c2c:	fe b0 f4 1c 	rcall	80007464 <__sprint_r>
80008c30:	e0 81 03 a7 	brne	8000937e <_vfprintf_r+0x1efe>
80008c34:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c38:	40 9b       	lddsp	r11,sp[0x24]
80008c3a:	e0 4b 00 80 	cp.w	r11,128
80008c3e:	c4 71       	brne	80008ccc <_vfprintf_r+0x184c>
80008c40:	40 8a       	lddsp	r10,sp[0x20]
80008c42:	40 39       	lddsp	r9,sp[0xc]
80008c44:	12 1a       	sub	r10,r9
80008c46:	50 4a       	stdsp	sp[0x10],r10
80008c48:	58 0a       	cp.w	r10,0
80008c4a:	e0 89 00 20 	brgt	80008c8a <_vfprintf_r+0x180a>
80008c4e:	c3 f8       	rjmp	80008ccc <_vfprintf_r+0x184c>
80008c50:	2f 09       	sub	r9,-16
80008c52:	2f f8       	sub	r8,-1
80008c54:	fe ce b9 dc 	sub	lr,pc,-17956
80008c58:	31 0c       	mov	r12,16
80008c5a:	fb 49 06 90 	st.w	sp[1680],r9
80008c5e:	87 0e       	st.w	r3[0x0],lr
80008c60:	87 1c       	st.w	r3[0x4],r12
80008c62:	fb 48 06 8c 	st.w	sp[1676],r8
80008c66:	58 78       	cp.w	r8,7
80008c68:	e0 89 00 04 	brgt	80008c70 <_vfprintf_r+0x17f0>
80008c6c:	2f 83       	sub	r3,-8
80008c6e:	c0 b8       	rjmp	80008c84 <_vfprintf_r+0x1804>
80008c70:	fa ca f9 78 	sub	r10,sp,-1672
80008c74:	02 9b       	mov	r11,r1
80008c76:	08 9c       	mov	r12,r4
80008c78:	fe b0 f3 f6 	rcall	80007464 <__sprint_r>
80008c7c:	e0 81 03 81 	brne	8000937e <_vfprintf_r+0x1efe>
80008c80:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c84:	40 4b       	lddsp	r11,sp[0x10]
80008c86:	21 0b       	sub	r11,16
80008c88:	50 4b       	stdsp	sp[0x10],r11
80008c8a:	fa f9 06 90 	ld.w	r9,sp[1680]
80008c8e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c92:	fe ca ba 1a 	sub	r10,pc,-17894
80008c96:	40 4e       	lddsp	lr,sp[0x10]
80008c98:	59 0e       	cp.w	lr,16
80008c9a:	fe 99 ff db 	brgt	80008c50 <_vfprintf_r+0x17d0>
80008c9e:	1c 09       	add	r9,lr
80008ca0:	2f f8       	sub	r8,-1
80008ca2:	87 0a       	st.w	r3[0x0],r10
80008ca4:	fb 49 06 90 	st.w	sp[1680],r9
80008ca8:	87 1e       	st.w	r3[0x4],lr
80008caa:	fb 48 06 8c 	st.w	sp[1676],r8
80008cae:	58 78       	cp.w	r8,7
80008cb0:	e0 89 00 04 	brgt	80008cb8 <_vfprintf_r+0x1838>
80008cb4:	2f 83       	sub	r3,-8
80008cb6:	c0 b8       	rjmp	80008ccc <_vfprintf_r+0x184c>
80008cb8:	fa ca f9 78 	sub	r10,sp,-1672
80008cbc:	02 9b       	mov	r11,r1
80008cbe:	08 9c       	mov	r12,r4
80008cc0:	fe b0 f3 d2 	rcall	80007464 <__sprint_r>
80008cc4:	e0 81 03 5d 	brne	8000937e <_vfprintf_r+0x1efe>
80008cc8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ccc:	40 2c       	lddsp	r12,sp[0x8]
80008cce:	04 1c       	sub	r12,r2
80008cd0:	50 2c       	stdsp	sp[0x8],r12
80008cd2:	58 0c       	cp.w	r12,0
80008cd4:	e0 89 00 20 	brgt	80008d14 <_vfprintf_r+0x1894>
80008cd8:	c3 f8       	rjmp	80008d56 <_vfprintf_r+0x18d6>
80008cda:	2f 09       	sub	r9,-16
80008cdc:	2f f8       	sub	r8,-1
80008cde:	fe cb ba 66 	sub	r11,pc,-17818
80008ce2:	31 0a       	mov	r10,16
80008ce4:	fb 49 06 90 	st.w	sp[1680],r9
80008ce8:	87 0b       	st.w	r3[0x0],r11
80008cea:	87 1a       	st.w	r3[0x4],r10
80008cec:	fb 48 06 8c 	st.w	sp[1676],r8
80008cf0:	58 78       	cp.w	r8,7
80008cf2:	e0 89 00 04 	brgt	80008cfa <_vfprintf_r+0x187a>
80008cf6:	2f 83       	sub	r3,-8
80008cf8:	c0 b8       	rjmp	80008d0e <_vfprintf_r+0x188e>
80008cfa:	fa ca f9 78 	sub	r10,sp,-1672
80008cfe:	02 9b       	mov	r11,r1
80008d00:	08 9c       	mov	r12,r4
80008d02:	fe b0 f3 b1 	rcall	80007464 <__sprint_r>
80008d06:	e0 81 03 3c 	brne	8000937e <_vfprintf_r+0x1efe>
80008d0a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d0e:	40 29       	lddsp	r9,sp[0x8]
80008d10:	21 09       	sub	r9,16
80008d12:	50 29       	stdsp	sp[0x8],r9
80008d14:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d18:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d1c:	fe ca ba a4 	sub	r10,pc,-17756
80008d20:	40 2e       	lddsp	lr,sp[0x8]
80008d22:	59 0e       	cp.w	lr,16
80008d24:	fe 99 ff db 	brgt	80008cda <_vfprintf_r+0x185a>
80008d28:	1c 09       	add	r9,lr
80008d2a:	2f f8       	sub	r8,-1
80008d2c:	87 0a       	st.w	r3[0x0],r10
80008d2e:	fb 49 06 90 	st.w	sp[1680],r9
80008d32:	87 1e       	st.w	r3[0x4],lr
80008d34:	fb 48 06 8c 	st.w	sp[1676],r8
80008d38:	58 78       	cp.w	r8,7
80008d3a:	e0 89 00 04 	brgt	80008d42 <_vfprintf_r+0x18c2>
80008d3e:	2f 83       	sub	r3,-8
80008d40:	c0 b8       	rjmp	80008d56 <_vfprintf_r+0x18d6>
80008d42:	fa ca f9 78 	sub	r10,sp,-1672
80008d46:	02 9b       	mov	r11,r1
80008d48:	08 9c       	mov	r12,r4
80008d4a:	fe b0 f3 8d 	rcall	80007464 <__sprint_r>
80008d4e:	e0 81 03 18 	brne	8000937e <_vfprintf_r+0x1efe>
80008d52:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d56:	ed b5 00 08 	bld	r5,0x8
80008d5a:	c0 b0       	breq	80008d70 <_vfprintf_r+0x18f0>
80008d5c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d60:	87 12       	st.w	r3[0x4],r2
80008d62:	87 06       	st.w	r3[0x0],r6
80008d64:	f0 02 00 02 	add	r2,r8,r2
80008d68:	fb 42 06 90 	st.w	sp[1680],r2
80008d6c:	e0 8f 01 d4 	bral	80009114 <_vfprintf_r+0x1c94>
80008d70:	e0 40 00 65 	cp.w	r0,101
80008d74:	e0 8a 01 d6 	brle	80009120 <_vfprintf_r+0x1ca0>
80008d78:	30 08       	mov	r8,0
80008d7a:	30 09       	mov	r9,0
80008d7c:	40 5b       	lddsp	r11,sp[0x14]
80008d7e:	40 7a       	lddsp	r10,sp[0x1c]
80008d80:	e0 a0 15 2f 	rcall	8000b7de <__avr32_f64_cmp_eq>
80008d84:	c7 90       	breq	80008e76 <_vfprintf_r+0x19f6>
80008d86:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d8a:	fe c9 bb 26 	sub	r9,pc,-17626
80008d8e:	2f f8       	sub	r8,-1
80008d90:	87 09       	st.w	r3[0x0],r9
80008d92:	fb 48 06 90 	st.w	sp[1680],r8
80008d96:	30 19       	mov	r9,1
80008d98:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d9c:	87 19       	st.w	r3[0x4],r9
80008d9e:	2f f8       	sub	r8,-1
80008da0:	fb 48 06 8c 	st.w	sp[1676],r8
80008da4:	58 78       	cp.w	r8,7
80008da6:	e0 89 00 05 	brgt	80008db0 <_vfprintf_r+0x1930>
80008daa:	2f 83       	sub	r3,-8
80008dac:	c0 c8       	rjmp	80008dc4 <_vfprintf_r+0x1944>
80008dae:	d7 03       	nop
80008db0:	fa ca f9 78 	sub	r10,sp,-1672
80008db4:	02 9b       	mov	r11,r1
80008db6:	08 9c       	mov	r12,r4
80008db8:	fe b0 f3 56 	rcall	80007464 <__sprint_r>
80008dbc:	e0 81 02 e1 	brne	8000937e <_vfprintf_r+0x1efe>
80008dc0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dc4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008dc8:	40 6c       	lddsp	r12,sp[0x18]
80008dca:	18 38       	cp.w	r8,r12
80008dcc:	c0 55       	brlt	80008dd6 <_vfprintf_r+0x1956>
80008dce:	ed b5 00 00 	bld	r5,0x0
80008dd2:	e0 81 02 6b 	brne	800092a8 <_vfprintf_r+0x1e28>
80008dd6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008dda:	2f f8       	sub	r8,-1
80008ddc:	40 cb       	lddsp	r11,sp[0x30]
80008dde:	fb 48 06 90 	st.w	sp[1680],r8
80008de2:	30 19       	mov	r9,1
80008de4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008de8:	87 0b       	st.w	r3[0x0],r11
80008dea:	2f f8       	sub	r8,-1
80008dec:	87 19       	st.w	r3[0x4],r9
80008dee:	fb 48 06 8c 	st.w	sp[1676],r8
80008df2:	58 78       	cp.w	r8,7
80008df4:	e0 89 00 04 	brgt	80008dfc <_vfprintf_r+0x197c>
80008df8:	2f 83       	sub	r3,-8
80008dfa:	c0 b8       	rjmp	80008e10 <_vfprintf_r+0x1990>
80008dfc:	fa ca f9 78 	sub	r10,sp,-1672
80008e00:	02 9b       	mov	r11,r1
80008e02:	08 9c       	mov	r12,r4
80008e04:	fe b0 f3 30 	rcall	80007464 <__sprint_r>
80008e08:	e0 81 02 bb 	brne	8000937e <_vfprintf_r+0x1efe>
80008e0c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e10:	40 66       	lddsp	r6,sp[0x18]
80008e12:	20 16       	sub	r6,1
80008e14:	58 06       	cp.w	r6,0
80008e16:	e0 89 00 1d 	brgt	80008e50 <_vfprintf_r+0x19d0>
80008e1a:	e0 8f 02 47 	bral	800092a8 <_vfprintf_r+0x1e28>
80008e1e:	2f 09       	sub	r9,-16
80008e20:	2f f8       	sub	r8,-1
80008e22:	fb 49 06 90 	st.w	sp[1680],r9
80008e26:	87 02       	st.w	r3[0x0],r2
80008e28:	87 10       	st.w	r3[0x4],r0
80008e2a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e2e:	58 78       	cp.w	r8,7
80008e30:	e0 89 00 04 	brgt	80008e38 <_vfprintf_r+0x19b8>
80008e34:	2f 83       	sub	r3,-8
80008e36:	c0 b8       	rjmp	80008e4c <_vfprintf_r+0x19cc>
80008e38:	fa ca f9 78 	sub	r10,sp,-1672
80008e3c:	02 9b       	mov	r11,r1
80008e3e:	08 9c       	mov	r12,r4
80008e40:	fe b0 f3 12 	rcall	80007464 <__sprint_r>
80008e44:	e0 81 02 9d 	brne	8000937e <_vfprintf_r+0x1efe>
80008e48:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e4c:	21 06       	sub	r6,16
80008e4e:	c0 48       	rjmp	80008e56 <_vfprintf_r+0x19d6>
80008e50:	fe c2 bb d8 	sub	r2,pc,-17448
80008e54:	31 00       	mov	r0,16
80008e56:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e5a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e5e:	fe ca bb e6 	sub	r10,pc,-17434
80008e62:	59 06       	cp.w	r6,16
80008e64:	fe 99 ff dd 	brgt	80008e1e <_vfprintf_r+0x199e>
80008e68:	0c 09       	add	r9,r6
80008e6a:	87 0a       	st.w	r3[0x0],r10
80008e6c:	fb 49 06 90 	st.w	sp[1680],r9
80008e70:	2f f8       	sub	r8,-1
80008e72:	87 16       	st.w	r3[0x4],r6
80008e74:	c5 39       	rjmp	8000911a <_vfprintf_r+0x1c9a>
80008e76:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008e7a:	58 0a       	cp.w	r10,0
80008e7c:	e0 89 00 92 	brgt	80008fa0 <_vfprintf_r+0x1b20>
80008e80:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e84:	fe c9 bc 20 	sub	r9,pc,-17376
80008e88:	2f f8       	sub	r8,-1
80008e8a:	87 09       	st.w	r3[0x0],r9
80008e8c:	fb 48 06 90 	st.w	sp[1680],r8
80008e90:	30 19       	mov	r9,1
80008e92:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e96:	87 19       	st.w	r3[0x4],r9
80008e98:	2f f8       	sub	r8,-1
80008e9a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e9e:	58 78       	cp.w	r8,7
80008ea0:	e0 89 00 04 	brgt	80008ea8 <_vfprintf_r+0x1a28>
80008ea4:	2f 83       	sub	r3,-8
80008ea6:	c0 b8       	rjmp	80008ebc <_vfprintf_r+0x1a3c>
80008ea8:	fa ca f9 78 	sub	r10,sp,-1672
80008eac:	02 9b       	mov	r11,r1
80008eae:	08 9c       	mov	r12,r4
80008eb0:	fe b0 f2 da 	rcall	80007464 <__sprint_r>
80008eb4:	e0 81 02 65 	brne	8000937e <_vfprintf_r+0x1efe>
80008eb8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ebc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ec0:	58 08       	cp.w	r8,0
80008ec2:	c0 81       	brne	80008ed2 <_vfprintf_r+0x1a52>
80008ec4:	40 6a       	lddsp	r10,sp[0x18]
80008ec6:	58 0a       	cp.w	r10,0
80008ec8:	c0 51       	brne	80008ed2 <_vfprintf_r+0x1a52>
80008eca:	ed b5 00 00 	bld	r5,0x0
80008ece:	e0 81 01 ed 	brne	800092a8 <_vfprintf_r+0x1e28>
80008ed2:	40 c9       	lddsp	r9,sp[0x30]
80008ed4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ed8:	2f f8       	sub	r8,-1
80008eda:	87 09       	st.w	r3[0x0],r9
80008edc:	fb 48 06 90 	st.w	sp[1680],r8
80008ee0:	30 19       	mov	r9,1
80008ee2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ee6:	87 19       	st.w	r3[0x4],r9
80008ee8:	2f f8       	sub	r8,-1
80008eea:	fb 48 06 8c 	st.w	sp[1676],r8
80008eee:	58 78       	cp.w	r8,7
80008ef0:	e0 89 00 04 	brgt	80008ef8 <_vfprintf_r+0x1a78>
80008ef4:	2f 83       	sub	r3,-8
80008ef6:	c0 b8       	rjmp	80008f0c <_vfprintf_r+0x1a8c>
80008ef8:	fa ca f9 78 	sub	r10,sp,-1672
80008efc:	02 9b       	mov	r11,r1
80008efe:	08 9c       	mov	r12,r4
80008f00:	fe b0 f2 b2 	rcall	80007464 <__sprint_r>
80008f04:	e0 81 02 3d 	brne	8000937e <_vfprintf_r+0x1efe>
80008f08:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f0c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008f10:	5c 32       	neg	r2
80008f12:	58 02       	cp.w	r2,0
80008f14:	e0 89 00 1d 	brgt	80008f4e <_vfprintf_r+0x1ace>
80008f18:	c3 d8       	rjmp	80008f92 <_vfprintf_r+0x1b12>
80008f1a:	2f 09       	sub	r9,-16
80008f1c:	2f f8       	sub	r8,-1
80008f1e:	31 0e       	mov	lr,16
80008f20:	fb 49 06 90 	st.w	sp[1680],r9
80008f24:	87 00       	st.w	r3[0x0],r0
80008f26:	87 1e       	st.w	r3[0x4],lr
80008f28:	fb 48 06 8c 	st.w	sp[1676],r8
80008f2c:	58 78       	cp.w	r8,7
80008f2e:	e0 89 00 04 	brgt	80008f36 <_vfprintf_r+0x1ab6>
80008f32:	2f 83       	sub	r3,-8
80008f34:	c0 b8       	rjmp	80008f4a <_vfprintf_r+0x1aca>
80008f36:	fa ca f9 78 	sub	r10,sp,-1672
80008f3a:	02 9b       	mov	r11,r1
80008f3c:	08 9c       	mov	r12,r4
80008f3e:	fe b0 f2 93 	rcall	80007464 <__sprint_r>
80008f42:	e0 81 02 1e 	brne	8000937e <_vfprintf_r+0x1efe>
80008f46:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f4a:	21 02       	sub	r2,16
80008f4c:	c0 38       	rjmp	80008f52 <_vfprintf_r+0x1ad2>
80008f4e:	fe c0 bc d6 	sub	r0,pc,-17194
80008f52:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f56:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f5a:	fe ca bc e2 	sub	r10,pc,-17182
80008f5e:	59 02       	cp.w	r2,16
80008f60:	fe 99 ff dd 	brgt	80008f1a <_vfprintf_r+0x1a9a>
80008f64:	04 09       	add	r9,r2
80008f66:	2f f8       	sub	r8,-1
80008f68:	87 0a       	st.w	r3[0x0],r10
80008f6a:	fb 49 06 90 	st.w	sp[1680],r9
80008f6e:	87 12       	st.w	r3[0x4],r2
80008f70:	fb 48 06 8c 	st.w	sp[1676],r8
80008f74:	58 78       	cp.w	r8,7
80008f76:	e0 89 00 04 	brgt	80008f7e <_vfprintf_r+0x1afe>
80008f7a:	2f 83       	sub	r3,-8
80008f7c:	c0 b8       	rjmp	80008f92 <_vfprintf_r+0x1b12>
80008f7e:	fa ca f9 78 	sub	r10,sp,-1672
80008f82:	02 9b       	mov	r11,r1
80008f84:	08 9c       	mov	r12,r4
80008f86:	fe b0 f2 6f 	rcall	80007464 <__sprint_r>
80008f8a:	e0 81 01 fa 	brne	8000937e <_vfprintf_r+0x1efe>
80008f8e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f92:	40 6c       	lddsp	r12,sp[0x18]
80008f94:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f98:	87 06       	st.w	r3[0x0],r6
80008f9a:	87 1c       	st.w	r3[0x4],r12
80008f9c:	18 08       	add	r8,r12
80008f9e:	cb 98       	rjmp	80009110 <_vfprintf_r+0x1c90>
80008fa0:	fa f9 06 90 	ld.w	r9,sp[1680]
80008fa4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fa8:	40 6b       	lddsp	r11,sp[0x18]
80008faa:	16 3a       	cp.w	r10,r11
80008fac:	c6 f5       	brlt	8000908a <_vfprintf_r+0x1c0a>
80008fae:	16 09       	add	r9,r11
80008fb0:	2f f8       	sub	r8,-1
80008fb2:	87 06       	st.w	r3[0x0],r6
80008fb4:	fb 49 06 90 	st.w	sp[1680],r9
80008fb8:	87 1b       	st.w	r3[0x4],r11
80008fba:	fb 48 06 8c 	st.w	sp[1676],r8
80008fbe:	58 78       	cp.w	r8,7
80008fc0:	e0 89 00 04 	brgt	80008fc8 <_vfprintf_r+0x1b48>
80008fc4:	2f 83       	sub	r3,-8
80008fc6:	c0 b8       	rjmp	80008fdc <_vfprintf_r+0x1b5c>
80008fc8:	fa ca f9 78 	sub	r10,sp,-1672
80008fcc:	02 9b       	mov	r11,r1
80008fce:	08 9c       	mov	r12,r4
80008fd0:	fe b0 f2 4a 	rcall	80007464 <__sprint_r>
80008fd4:	e0 81 01 d5 	brne	8000937e <_vfprintf_r+0x1efe>
80008fd8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fdc:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008fe0:	40 6a       	lddsp	r10,sp[0x18]
80008fe2:	14 16       	sub	r6,r10
80008fe4:	58 06       	cp.w	r6,0
80008fe6:	e0 89 00 1c 	brgt	8000901e <_vfprintf_r+0x1b9e>
80008fea:	c3 d8       	rjmp	80009064 <_vfprintf_r+0x1be4>
80008fec:	2f 09       	sub	r9,-16
80008fee:	2f f8       	sub	r8,-1
80008ff0:	fb 49 06 90 	st.w	sp[1680],r9
80008ff4:	87 02       	st.w	r3[0x0],r2
80008ff6:	87 10       	st.w	r3[0x4],r0
80008ff8:	fb 48 06 8c 	st.w	sp[1676],r8
80008ffc:	58 78       	cp.w	r8,7
80008ffe:	e0 89 00 04 	brgt	80009006 <_vfprintf_r+0x1b86>
80009002:	2f 83       	sub	r3,-8
80009004:	c0 b8       	rjmp	8000901a <_vfprintf_r+0x1b9a>
80009006:	fa ca f9 78 	sub	r10,sp,-1672
8000900a:	02 9b       	mov	r11,r1
8000900c:	08 9c       	mov	r12,r4
8000900e:	fe b0 f2 2b 	rcall	80007464 <__sprint_r>
80009012:	e0 81 01 b6 	brne	8000937e <_vfprintf_r+0x1efe>
80009016:	fa c3 f9 e0 	sub	r3,sp,-1568
8000901a:	21 06       	sub	r6,16
8000901c:	c0 48       	rjmp	80009024 <_vfprintf_r+0x1ba4>
8000901e:	fe c2 bd a6 	sub	r2,pc,-16986
80009022:	31 00       	mov	r0,16
80009024:	fa f9 06 90 	ld.w	r9,sp[1680]
80009028:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000902c:	fe ca bd b4 	sub	r10,pc,-16972
80009030:	59 06       	cp.w	r6,16
80009032:	fe 99 ff dd 	brgt	80008fec <_vfprintf_r+0x1b6c>
80009036:	0c 09       	add	r9,r6
80009038:	2f f8       	sub	r8,-1
8000903a:	87 0a       	st.w	r3[0x0],r10
8000903c:	fb 49 06 90 	st.w	sp[1680],r9
80009040:	87 16       	st.w	r3[0x4],r6
80009042:	fb 48 06 8c 	st.w	sp[1676],r8
80009046:	58 78       	cp.w	r8,7
80009048:	e0 89 00 04 	brgt	80009050 <_vfprintf_r+0x1bd0>
8000904c:	2f 83       	sub	r3,-8
8000904e:	c0 b8       	rjmp	80009064 <_vfprintf_r+0x1be4>
80009050:	fa ca f9 78 	sub	r10,sp,-1672
80009054:	02 9b       	mov	r11,r1
80009056:	08 9c       	mov	r12,r4
80009058:	fe b0 f2 06 	rcall	80007464 <__sprint_r>
8000905c:	e0 81 01 91 	brne	8000937e <_vfprintf_r+0x1efe>
80009060:	fa c3 f9 e0 	sub	r3,sp,-1568
80009064:	ed b5 00 00 	bld	r5,0x0
80009068:	e0 81 01 20 	brne	800092a8 <_vfprintf_r+0x1e28>
8000906c:	40 c9       	lddsp	r9,sp[0x30]
8000906e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009072:	2f f8       	sub	r8,-1
80009074:	87 09       	st.w	r3[0x0],r9
80009076:	fb 48 06 90 	st.w	sp[1680],r8
8000907a:	30 19       	mov	r9,1
8000907c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009080:	87 19       	st.w	r3[0x4],r9
80009082:	2f f8       	sub	r8,-1
80009084:	fb 48 06 8c 	st.w	sp[1676],r8
80009088:	c0 29       	rjmp	8000928c <_vfprintf_r+0x1e0c>
8000908a:	14 09       	add	r9,r10
8000908c:	2f f8       	sub	r8,-1
8000908e:	fb 49 06 90 	st.w	sp[1680],r9
80009092:	87 06       	st.w	r3[0x0],r6
80009094:	87 1a       	st.w	r3[0x4],r10
80009096:	fb 48 06 8c 	st.w	sp[1676],r8
8000909a:	58 78       	cp.w	r8,7
8000909c:	e0 89 00 04 	brgt	800090a4 <_vfprintf_r+0x1c24>
800090a0:	2f 83       	sub	r3,-8
800090a2:	c0 b8       	rjmp	800090b8 <_vfprintf_r+0x1c38>
800090a4:	fa ca f9 78 	sub	r10,sp,-1672
800090a8:	02 9b       	mov	r11,r1
800090aa:	08 9c       	mov	r12,r4
800090ac:	fe b0 f1 dc 	rcall	80007464 <__sprint_r>
800090b0:	e0 81 01 67 	brne	8000937e <_vfprintf_r+0x1efe>
800090b4:	fa c3 f9 e0 	sub	r3,sp,-1568
800090b8:	40 c8       	lddsp	r8,sp[0x30]
800090ba:	87 08       	st.w	r3[0x0],r8
800090bc:	fa f8 06 90 	ld.w	r8,sp[1680]
800090c0:	2f f8       	sub	r8,-1
800090c2:	30 19       	mov	r9,1
800090c4:	fb 48 06 90 	st.w	sp[1680],r8
800090c8:	87 19       	st.w	r3[0x4],r9
800090ca:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090ce:	2f f8       	sub	r8,-1
800090d0:	fb 48 06 8c 	st.w	sp[1676],r8
800090d4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800090d8:	58 78       	cp.w	r8,7
800090da:	e0 89 00 04 	brgt	800090e2 <_vfprintf_r+0x1c62>
800090de:	2f 83       	sub	r3,-8
800090e0:	c0 b8       	rjmp	800090f6 <_vfprintf_r+0x1c76>
800090e2:	fa ca f9 78 	sub	r10,sp,-1672
800090e6:	02 9b       	mov	r11,r1
800090e8:	08 9c       	mov	r12,r4
800090ea:	fe b0 f1 bd 	rcall	80007464 <__sprint_r>
800090ee:	e0 81 01 48 	brne	8000937e <_vfprintf_r+0x1efe>
800090f2:	fa c3 f9 e0 	sub	r3,sp,-1568
800090f6:	04 06       	add	r6,r2
800090f8:	fa f8 06 ac 	ld.w	r8,sp[1708]
800090fc:	87 06       	st.w	r3[0x0],r6
800090fe:	fa f9 06 90 	ld.w	r9,sp[1680]
80009102:	40 66       	lddsp	r6,sp[0x18]
80009104:	40 6e       	lddsp	lr,sp[0x18]
80009106:	10 16       	sub	r6,r8
80009108:	f2 08 01 08 	sub	r8,r9,r8
8000910c:	87 16       	st.w	r3[0x4],r6
8000910e:	1c 08       	add	r8,lr
80009110:	fb 48 06 90 	st.w	sp[1680],r8
80009114:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009118:	2f f8       	sub	r8,-1
8000911a:	fb 48 06 8c 	st.w	sp[1676],r8
8000911e:	cb 78       	rjmp	8000928c <_vfprintf_r+0x1e0c>
80009120:	40 6c       	lddsp	r12,sp[0x18]
80009122:	58 1c       	cp.w	r12,1
80009124:	e0 89 00 06 	brgt	80009130 <_vfprintf_r+0x1cb0>
80009128:	ed b5 00 00 	bld	r5,0x0
8000912c:	e0 81 00 85 	brne	80009236 <_vfprintf_r+0x1db6>
80009130:	fa f8 06 90 	ld.w	r8,sp[1680]
80009134:	2f f8       	sub	r8,-1
80009136:	30 19       	mov	r9,1
80009138:	fb 48 06 90 	st.w	sp[1680],r8
8000913c:	87 06       	st.w	r3[0x0],r6
8000913e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009142:	87 19       	st.w	r3[0x4],r9
80009144:	2f f8       	sub	r8,-1
80009146:	fb 48 06 8c 	st.w	sp[1676],r8
8000914a:	58 78       	cp.w	r8,7
8000914c:	e0 89 00 04 	brgt	80009154 <_vfprintf_r+0x1cd4>
80009150:	2f 83       	sub	r3,-8
80009152:	c0 b8       	rjmp	80009168 <_vfprintf_r+0x1ce8>
80009154:	fa ca f9 78 	sub	r10,sp,-1672
80009158:	02 9b       	mov	r11,r1
8000915a:	08 9c       	mov	r12,r4
8000915c:	fe b0 f1 84 	rcall	80007464 <__sprint_r>
80009160:	e0 81 01 0f 	brne	8000937e <_vfprintf_r+0x1efe>
80009164:	fa c3 f9 e0 	sub	r3,sp,-1568
80009168:	fa f8 06 90 	ld.w	r8,sp[1680]
8000916c:	2f f8       	sub	r8,-1
8000916e:	40 cb       	lddsp	r11,sp[0x30]
80009170:	fb 48 06 90 	st.w	sp[1680],r8
80009174:	30 19       	mov	r9,1
80009176:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000917a:	87 0b       	st.w	r3[0x0],r11
8000917c:	2f f8       	sub	r8,-1
8000917e:	87 19       	st.w	r3[0x4],r9
80009180:	fb 48 06 8c 	st.w	sp[1676],r8
80009184:	58 78       	cp.w	r8,7
80009186:	e0 89 00 05 	brgt	80009190 <_vfprintf_r+0x1d10>
8000918a:	2f 83       	sub	r3,-8
8000918c:	c0 c8       	rjmp	800091a4 <_vfprintf_r+0x1d24>
8000918e:	d7 03       	nop
80009190:	fa ca f9 78 	sub	r10,sp,-1672
80009194:	02 9b       	mov	r11,r1
80009196:	08 9c       	mov	r12,r4
80009198:	fe b0 f1 66 	rcall	80007464 <__sprint_r>
8000919c:	e0 81 00 f1 	brne	8000937e <_vfprintf_r+0x1efe>
800091a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800091a4:	30 08       	mov	r8,0
800091a6:	30 09       	mov	r9,0
800091a8:	40 5b       	lddsp	r11,sp[0x14]
800091aa:	40 7a       	lddsp	r10,sp[0x1c]
800091ac:	e0 a0 13 19 	rcall	8000b7de <__avr32_f64_cmp_eq>
800091b0:	40 68       	lddsp	r8,sp[0x18]
800091b2:	20 18       	sub	r8,1
800091b4:	58 0c       	cp.w	r12,0
800091b6:	c0 d1       	brne	800091d0 <_vfprintf_r+0x1d50>
800091b8:	2f f6       	sub	r6,-1
800091ba:	87 18       	st.w	r3[0x4],r8
800091bc:	87 06       	st.w	r3[0x0],r6
800091be:	fa f6 06 90 	ld.w	r6,sp[1680]
800091c2:	10 06       	add	r6,r8
800091c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091c8:	fb 46 06 90 	st.w	sp[1680],r6
800091cc:	2f f8       	sub	r8,-1
800091ce:	c3 18       	rjmp	80009230 <_vfprintf_r+0x1db0>
800091d0:	10 96       	mov	r6,r8
800091d2:	58 08       	cp.w	r8,0
800091d4:	e0 89 00 1c 	brgt	8000920c <_vfprintf_r+0x1d8c>
800091d8:	c4 b8       	rjmp	8000926e <_vfprintf_r+0x1dee>
800091da:	2f 09       	sub	r9,-16
800091dc:	2f f8       	sub	r8,-1
800091de:	fb 49 06 90 	st.w	sp[1680],r9
800091e2:	87 02       	st.w	r3[0x0],r2
800091e4:	87 10       	st.w	r3[0x4],r0
800091e6:	fb 48 06 8c 	st.w	sp[1676],r8
800091ea:	58 78       	cp.w	r8,7
800091ec:	e0 89 00 04 	brgt	800091f4 <_vfprintf_r+0x1d74>
800091f0:	2f 83       	sub	r3,-8
800091f2:	c0 b8       	rjmp	80009208 <_vfprintf_r+0x1d88>
800091f4:	fa ca f9 78 	sub	r10,sp,-1672
800091f8:	02 9b       	mov	r11,r1
800091fa:	08 9c       	mov	r12,r4
800091fc:	fe b0 f1 34 	rcall	80007464 <__sprint_r>
80009200:	e0 81 00 bf 	brne	8000937e <_vfprintf_r+0x1efe>
80009204:	fa c3 f9 e0 	sub	r3,sp,-1568
80009208:	21 06       	sub	r6,16
8000920a:	c0 48       	rjmp	80009212 <_vfprintf_r+0x1d92>
8000920c:	fe c2 bf 94 	sub	r2,pc,-16492
80009210:	31 00       	mov	r0,16
80009212:	fa f9 06 90 	ld.w	r9,sp[1680]
80009216:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000921a:	fe ca bf a2 	sub	r10,pc,-16478
8000921e:	59 06       	cp.w	r6,16
80009220:	fe 99 ff dd 	brgt	800091da <_vfprintf_r+0x1d5a>
80009224:	0c 09       	add	r9,r6
80009226:	87 0a       	st.w	r3[0x0],r10
80009228:	fb 49 06 90 	st.w	sp[1680],r9
8000922c:	2f f8       	sub	r8,-1
8000922e:	87 16       	st.w	r3[0x4],r6
80009230:	fb 48 06 8c 	st.w	sp[1676],r8
80009234:	c0 e8       	rjmp	80009250 <_vfprintf_r+0x1dd0>
80009236:	fa f8 06 90 	ld.w	r8,sp[1680]
8000923a:	2f f8       	sub	r8,-1
8000923c:	30 19       	mov	r9,1
8000923e:	fb 48 06 90 	st.w	sp[1680],r8
80009242:	87 06       	st.w	r3[0x0],r6
80009244:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009248:	87 19       	st.w	r3[0x4],r9
8000924a:	2f f8       	sub	r8,-1
8000924c:	fb 48 06 8c 	st.w	sp[1676],r8
80009250:	58 78       	cp.w	r8,7
80009252:	e0 89 00 04 	brgt	8000925a <_vfprintf_r+0x1dda>
80009256:	2f 83       	sub	r3,-8
80009258:	c0 b8       	rjmp	8000926e <_vfprintf_r+0x1dee>
8000925a:	fa ca f9 78 	sub	r10,sp,-1672
8000925e:	02 9b       	mov	r11,r1
80009260:	08 9c       	mov	r12,r4
80009262:	fe b0 f1 01 	rcall	80007464 <__sprint_r>
80009266:	e0 81 00 8c 	brne	8000937e <_vfprintf_r+0x1efe>
8000926a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000926e:	40 ea       	lddsp	r10,sp[0x38]
80009270:	fa f8 06 90 	ld.w	r8,sp[1680]
80009274:	14 08       	add	r8,r10
80009276:	fa c9 f9 64 	sub	r9,sp,-1692
8000927a:	fb 48 06 90 	st.w	sp[1680],r8
8000927e:	87 1a       	st.w	r3[0x4],r10
80009280:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009284:	87 09       	st.w	r3[0x0],r9
80009286:	2f f8       	sub	r8,-1
80009288:	fb 48 06 8c 	st.w	sp[1676],r8
8000928c:	58 78       	cp.w	r8,7
8000928e:	e0 89 00 04 	brgt	80009296 <_vfprintf_r+0x1e16>
80009292:	2f 83       	sub	r3,-8
80009294:	c0 a8       	rjmp	800092a8 <_vfprintf_r+0x1e28>
80009296:	fa ca f9 78 	sub	r10,sp,-1672
8000929a:	02 9b       	mov	r11,r1
8000929c:	08 9c       	mov	r12,r4
8000929e:	fe b0 f0 e3 	rcall	80007464 <__sprint_r>
800092a2:	c6 e1       	brne	8000937e <_vfprintf_r+0x1efe>
800092a4:	fa c3 f9 e0 	sub	r3,sp,-1568
800092a8:	e2 15 00 04 	andl	r5,0x4,COH
800092ac:	c3 f0       	breq	8000932a <_vfprintf_r+0x1eaa>
800092ae:	40 86       	lddsp	r6,sp[0x20]
800092b0:	40 39       	lddsp	r9,sp[0xc]
800092b2:	12 16       	sub	r6,r9
800092b4:	58 06       	cp.w	r6,0
800092b6:	e0 89 00 1a 	brgt	800092ea <_vfprintf_r+0x1e6a>
800092ba:	c3 88       	rjmp	8000932a <_vfprintf_r+0x1eaa>
800092bc:	2f 09       	sub	r9,-16
800092be:	2f f8       	sub	r8,-1
800092c0:	fb 49 06 90 	st.w	sp[1680],r9
800092c4:	87 05       	st.w	r3[0x0],r5
800092c6:	87 12       	st.w	r3[0x4],r2
800092c8:	fb 48 06 8c 	st.w	sp[1676],r8
800092cc:	58 78       	cp.w	r8,7
800092ce:	e0 89 00 04 	brgt	800092d6 <_vfprintf_r+0x1e56>
800092d2:	2f 83       	sub	r3,-8
800092d4:	c0 98       	rjmp	800092e6 <_vfprintf_r+0x1e66>
800092d6:	00 9a       	mov	r10,r0
800092d8:	02 9b       	mov	r11,r1
800092da:	08 9c       	mov	r12,r4
800092dc:	fe b0 f0 c4 	rcall	80007464 <__sprint_r>
800092e0:	c4 f1       	brne	8000937e <_vfprintf_r+0x1efe>
800092e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800092e6:	21 06       	sub	r6,16
800092e8:	c0 68       	rjmp	800092f4 <_vfprintf_r+0x1e74>
800092ea:	fe c5 c0 82 	sub	r5,pc,-16254
800092ee:	31 02       	mov	r2,16
800092f0:	fa c0 f9 78 	sub	r0,sp,-1672
800092f4:	fa f9 06 90 	ld.w	r9,sp[1680]
800092f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092fc:	fe ca c0 94 	sub	r10,pc,-16236
80009300:	59 06       	cp.w	r6,16
80009302:	fe 99 ff dd 	brgt	800092bc <_vfprintf_r+0x1e3c>
80009306:	0c 09       	add	r9,r6
80009308:	2f f8       	sub	r8,-1
8000930a:	87 0a       	st.w	r3[0x0],r10
8000930c:	87 16       	st.w	r3[0x4],r6
8000930e:	fb 49 06 90 	st.w	sp[1680],r9
80009312:	fb 48 06 8c 	st.w	sp[1676],r8
80009316:	58 78       	cp.w	r8,7
80009318:	e0 8a 00 09 	brle	8000932a <_vfprintf_r+0x1eaa>
8000931c:	fa ca f9 78 	sub	r10,sp,-1672
80009320:	02 9b       	mov	r11,r1
80009322:	08 9c       	mov	r12,r4
80009324:	fe b0 f0 a0 	rcall	80007464 <__sprint_r>
80009328:	c2 b1       	brne	8000937e <_vfprintf_r+0x1efe>
8000932a:	40 bc       	lddsp	r12,sp[0x2c]
8000932c:	40 36       	lddsp	r6,sp[0xc]
8000932e:	40 8e       	lddsp	lr,sp[0x20]
80009330:	ec 0e 0c 48 	max	r8,r6,lr
80009334:	10 0c       	add	r12,r8
80009336:	50 bc       	stdsp	sp[0x2c],r12
80009338:	fa f8 06 90 	ld.w	r8,sp[1680]
8000933c:	58 08       	cp.w	r8,0
8000933e:	c0 80       	breq	8000934e <_vfprintf_r+0x1ece>
80009340:	fa ca f9 78 	sub	r10,sp,-1672
80009344:	02 9b       	mov	r11,r1
80009346:	08 9c       	mov	r12,r4
80009348:	fe b0 f0 8e 	rcall	80007464 <__sprint_r>
8000934c:	c1 91       	brne	8000937e <_vfprintf_r+0x1efe>
8000934e:	30 0b       	mov	r11,0
80009350:	fa c3 f9 e0 	sub	r3,sp,-1568
80009354:	fb 4b 06 8c 	st.w	sp[1676],r11
80009358:	fe 9f f1 22 	bral	8000759c <_vfprintf_r+0x11c>
8000935c:	08 95       	mov	r5,r4
8000935e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009362:	58 08       	cp.w	r8,0
80009364:	c0 80       	breq	80009374 <_vfprintf_r+0x1ef4>
80009366:	08 9c       	mov	r12,r4
80009368:	fa ca f9 78 	sub	r10,sp,-1672
8000936c:	02 9b       	mov	r11,r1
8000936e:	fe b0 f0 7b 	rcall	80007464 <__sprint_r>
80009372:	c0 61       	brne	8000937e <_vfprintf_r+0x1efe>
80009374:	30 08       	mov	r8,0
80009376:	fb 48 06 8c 	st.w	sp[1676],r8
8000937a:	c0 28       	rjmp	8000937e <_vfprintf_r+0x1efe>
8000937c:	40 41       	lddsp	r1,sp[0x10]
8000937e:	82 68       	ld.sh	r8,r1[0xc]
80009380:	ed b8 00 06 	bld	r8,0x6
80009384:	c0 31       	brne	8000938a <_vfprintf_r+0x1f0a>
80009386:	3f fa       	mov	r10,-1
80009388:	50 ba       	stdsp	sp[0x2c],r10
8000938a:	40 bc       	lddsp	r12,sp[0x2c]
8000938c:	fe 3d f9 44 	sub	sp,-1724
80009390:	d8 32       	popm	r0-r7,pc
80009392:	d7 03       	nop

80009394 <__swsetup_r>:
80009394:	d4 21       	pushm	r4-r7,lr
80009396:	e0 68 0a 30 	mov	r8,2608
8000939a:	18 96       	mov	r6,r12
8000939c:	16 97       	mov	r7,r11
8000939e:	70 0c       	ld.w	r12,r8[0x0]
800093a0:	58 0c       	cp.w	r12,0
800093a2:	c0 60       	breq	800093ae <__swsetup_r+0x1a>
800093a4:	78 68       	ld.w	r8,r12[0x18]
800093a6:	58 08       	cp.w	r8,0
800093a8:	c0 31       	brne	800093ae <__swsetup_r+0x1a>
800093aa:	e0 a0 07 bf 	rcall	8000a328 <__sinit>
800093ae:	fe c8 c0 16 	sub	r8,pc,-16362
800093b2:	10 37       	cp.w	r7,r8
800093b4:	c0 61       	brne	800093c0 <__swsetup_r+0x2c>
800093b6:	e0 68 0a 30 	mov	r8,2608
800093ba:	70 08       	ld.w	r8,r8[0x0]
800093bc:	70 07       	ld.w	r7,r8[0x0]
800093be:	c1 28       	rjmp	800093e2 <__swsetup_r+0x4e>
800093c0:	fe c8 c0 08 	sub	r8,pc,-16376
800093c4:	10 37       	cp.w	r7,r8
800093c6:	c0 61       	brne	800093d2 <__swsetup_r+0x3e>
800093c8:	e0 68 0a 30 	mov	r8,2608
800093cc:	70 08       	ld.w	r8,r8[0x0]
800093ce:	70 17       	ld.w	r7,r8[0x4]
800093d0:	c0 98       	rjmp	800093e2 <__swsetup_r+0x4e>
800093d2:	fe c8 bf fa 	sub	r8,pc,-16390
800093d6:	10 37       	cp.w	r7,r8
800093d8:	c0 51       	brne	800093e2 <__swsetup_r+0x4e>
800093da:	e0 68 0a 30 	mov	r8,2608
800093de:	70 08       	ld.w	r8,r8[0x0]
800093e0:	70 27       	ld.w	r7,r8[0x8]
800093e2:	8e 68       	ld.sh	r8,r7[0xc]
800093e4:	ed b8 00 03 	bld	r8,0x3
800093e8:	c1 e0       	breq	80009424 <__swsetup_r+0x90>
800093ea:	ed b8 00 04 	bld	r8,0x4
800093ee:	c3 e1       	brne	8000946a <__swsetup_r+0xd6>
800093f0:	ed b8 00 02 	bld	r8,0x2
800093f4:	c1 51       	brne	8000941e <__swsetup_r+0x8a>
800093f6:	6e db       	ld.w	r11,r7[0x34]
800093f8:	58 0b       	cp.w	r11,0
800093fa:	c0 a0       	breq	8000940e <__swsetup_r+0x7a>
800093fc:	ee c8 ff bc 	sub	r8,r7,-68
80009400:	10 3b       	cp.w	r11,r8
80009402:	c0 40       	breq	8000940a <__swsetup_r+0x76>
80009404:	0c 9c       	mov	r12,r6
80009406:	e0 a0 08 2b 	rcall	8000a45c <_free_r>
8000940a:	30 08       	mov	r8,0
8000940c:	8f d8       	st.w	r7[0x34],r8
8000940e:	8e 68       	ld.sh	r8,r7[0xc]
80009410:	e0 18 ff db 	andl	r8,0xffdb
80009414:	ae 68       	st.h	r7[0xc],r8
80009416:	30 08       	mov	r8,0
80009418:	8f 18       	st.w	r7[0x4],r8
8000941a:	6e 48       	ld.w	r8,r7[0x10]
8000941c:	8f 08       	st.w	r7[0x0],r8
8000941e:	8e 68       	ld.sh	r8,r7[0xc]
80009420:	a3 b8       	sbr	r8,0x3
80009422:	ae 68       	st.h	r7[0xc],r8
80009424:	6e 48       	ld.w	r8,r7[0x10]
80009426:	58 08       	cp.w	r8,0
80009428:	c0 b1       	brne	8000943e <__swsetup_r+0xaa>
8000942a:	8e 68       	ld.sh	r8,r7[0xc]
8000942c:	e2 18 02 80 	andl	r8,0x280,COH
80009430:	e0 48 02 00 	cp.w	r8,512
80009434:	c0 50       	breq	8000943e <__swsetup_r+0xaa>
80009436:	0c 9c       	mov	r12,r6
80009438:	0e 9b       	mov	r11,r7
8000943a:	e0 a0 0a 4b 	rcall	8000a8d0 <__smakebuf_r>
8000943e:	8e 69       	ld.sh	r9,r7[0xc]
80009440:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009444:	c0 70       	breq	80009452 <__swsetup_r+0xbe>
80009446:	30 08       	mov	r8,0
80009448:	8f 28       	st.w	r7[0x8],r8
8000944a:	6e 58       	ld.w	r8,r7[0x14]
8000944c:	5c 38       	neg	r8
8000944e:	8f 68       	st.w	r7[0x18],r8
80009450:	c0 68       	rjmp	8000945c <__swsetup_r+0xc8>
80009452:	ed b9 00 01 	bld	r9,0x1
80009456:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000945a:	8f 28       	st.w	r7[0x8],r8
8000945c:	6e 48       	ld.w	r8,r7[0x10]
8000945e:	58 08       	cp.w	r8,0
80009460:	c0 61       	brne	8000946c <__swsetup_r+0xd8>
80009462:	8e 68       	ld.sh	r8,r7[0xc]
80009464:	ed b8 00 07 	bld	r8,0x7
80009468:	c0 21       	brne	8000946c <__swsetup_r+0xd8>
8000946a:	dc 2a       	popm	r4-r7,pc,r12=-1
8000946c:	d8 2a       	popm	r4-r7,pc,r12=0
8000946e:	d7 03       	nop

80009470 <quorem>:
80009470:	d4 31       	pushm	r0-r7,lr
80009472:	20 2d       	sub	sp,8
80009474:	18 97       	mov	r7,r12
80009476:	78 48       	ld.w	r8,r12[0x10]
80009478:	76 46       	ld.w	r6,r11[0x10]
8000947a:	0c 38       	cp.w	r8,r6
8000947c:	c0 34       	brge	80009482 <quorem+0x12>
8000947e:	30 0c       	mov	r12,0
80009480:	c8 58       	rjmp	8000958a <quorem+0x11a>
80009482:	ec c2 ff fc 	sub	r2,r6,-4
80009486:	f6 c3 ff ec 	sub	r3,r11,-20
8000948a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000948e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009492:	2f f9       	sub	r9,-1
80009494:	20 16       	sub	r6,1
80009496:	f8 09 0d 08 	divu	r8,r12,r9
8000949a:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000949e:	ee c4 ff ec 	sub	r4,r7,-20
800094a2:	10 95       	mov	r5,r8
800094a4:	58 08       	cp.w	r8,0
800094a6:	c4 10       	breq	80009528 <quorem+0xb8>
800094a8:	30 09       	mov	r9,0
800094aa:	06 9a       	mov	r10,r3
800094ac:	08 98       	mov	r8,r4
800094ae:	12 91       	mov	r1,r9
800094b0:	50 0b       	stdsp	sp[0x0],r11
800094b2:	70 0e       	ld.w	lr,r8[0x0]
800094b4:	b1 8e       	lsr	lr,0x10
800094b6:	50 1e       	stdsp	sp[0x4],lr
800094b8:	15 0e       	ld.w	lr,r10++
800094ba:	fc 00 16 10 	lsr	r0,lr,0x10
800094be:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800094c2:	ea 0e 03 41 	mac	r1,r5,lr
800094c6:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800094ca:	b1 81       	lsr	r1,0x10
800094cc:	40 1b       	lddsp	r11,sp[0x4]
800094ce:	ea 00 02 40 	mul	r0,r5,r0
800094d2:	e2 00 00 00 	add	r0,r1,r0
800094d6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800094da:	02 1b       	sub	r11,r1
800094dc:	50 1b       	stdsp	sp[0x4],r11
800094de:	70 0b       	ld.w	r11,r8[0x0]
800094e0:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
800094e4:	02 09       	add	r9,r1
800094e6:	f2 0e 01 0e 	sub	lr,r9,lr
800094ea:	b0 1e       	st.h	r8[0x2],lr
800094ec:	fc 09 14 10 	asr	r9,lr,0x10
800094f0:	40 1e       	lddsp	lr,sp[0x4]
800094f2:	fc 09 00 09 	add	r9,lr,r9
800094f6:	b0 09       	st.h	r8[0x0],r9
800094f8:	e0 01 16 10 	lsr	r1,r0,0x10
800094fc:	2f c8       	sub	r8,-4
800094fe:	b1 49       	asr	r9,0x10
80009500:	04 3a       	cp.w	r10,r2
80009502:	fe 98 ff d8 	brls	800094b2 <quorem+0x42>
80009506:	40 0b       	lddsp	r11,sp[0x0]
80009508:	58 0c       	cp.w	r12,0
8000950a:	c0 f1       	brne	80009528 <quorem+0xb8>
8000950c:	ec c8 ff fb 	sub	r8,r6,-5
80009510:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009514:	c0 28       	rjmp	80009518 <quorem+0xa8>
80009516:	20 16       	sub	r6,1
80009518:	20 48       	sub	r8,4
8000951a:	08 38       	cp.w	r8,r4
8000951c:	e0 88 00 05 	brls	80009526 <quorem+0xb6>
80009520:	70 09       	ld.w	r9,r8[0x0]
80009522:	58 09       	cp.w	r9,0
80009524:	cf 90       	breq	80009516 <quorem+0xa6>
80009526:	8f 46       	st.w	r7[0x10],r6
80009528:	0e 9c       	mov	r12,r7
8000952a:	e0 a0 0a d2 	rcall	8000aace <__mcmp>
8000952e:	c2 d5       	brlt	80009588 <quorem+0x118>
80009530:	2f f5       	sub	r5,-1
80009532:	08 98       	mov	r8,r4
80009534:	30 09       	mov	r9,0
80009536:	07 0b       	ld.w	r11,r3++
80009538:	f6 0a 16 10 	lsr	r10,r11,0x10
8000953c:	70 0c       	ld.w	r12,r8[0x0]
8000953e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009542:	f8 0e 16 10 	lsr	lr,r12,0x10
80009546:	14 1e       	sub	lr,r10
80009548:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000954c:	16 1a       	sub	r10,r11
8000954e:	12 0a       	add	r10,r9
80009550:	b0 1a       	st.h	r8[0x2],r10
80009552:	b1 4a       	asr	r10,0x10
80009554:	fc 0a 00 09 	add	r9,lr,r10
80009558:	b0 09       	st.h	r8[0x0],r9
8000955a:	2f c8       	sub	r8,-4
8000955c:	b1 49       	asr	r9,0x10
8000955e:	04 33       	cp.w	r3,r2
80009560:	fe 98 ff eb 	brls	80009536 <quorem+0xc6>
80009564:	ec c8 ff fb 	sub	r8,r6,-5
80009568:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000956c:	58 09       	cp.w	r9,0
8000956e:	c0 d1       	brne	80009588 <quorem+0x118>
80009570:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009574:	c0 28       	rjmp	80009578 <quorem+0x108>
80009576:	20 16       	sub	r6,1
80009578:	20 48       	sub	r8,4
8000957a:	08 38       	cp.w	r8,r4
8000957c:	e0 88 00 05 	brls	80009586 <quorem+0x116>
80009580:	70 09       	ld.w	r9,r8[0x0]
80009582:	58 09       	cp.w	r9,0
80009584:	cf 90       	breq	80009576 <quorem+0x106>
80009586:	8f 46       	st.w	r7[0x10],r6
80009588:	0a 9c       	mov	r12,r5
8000958a:	2f ed       	sub	sp,-8
8000958c:	d8 32       	popm	r0-r7,pc
8000958e:	d7 03       	nop

80009590 <_dtoa_r>:
80009590:	d4 31       	pushm	r0-r7,lr
80009592:	21 ad       	sub	sp,104
80009594:	fa c4 ff 74 	sub	r4,sp,-140
80009598:	18 97       	mov	r7,r12
8000959a:	16 95       	mov	r5,r11
8000959c:	68 2c       	ld.w	r12,r4[0x8]
8000959e:	50 c9       	stdsp	sp[0x30],r9
800095a0:	68 16       	ld.w	r6,r4[0x4]
800095a2:	68 09       	ld.w	r9,r4[0x0]
800095a4:	50 e8       	stdsp	sp[0x38],r8
800095a6:	14 94       	mov	r4,r10
800095a8:	51 2c       	stdsp	sp[0x48],r12
800095aa:	fa e5 00 08 	st.d	sp[8],r4
800095ae:	51 59       	stdsp	sp[0x54],r9
800095b0:	6e 95       	ld.w	r5,r7[0x24]
800095b2:	58 05       	cp.w	r5,0
800095b4:	c0 91       	brne	800095c6 <_dtoa_r+0x36>
800095b6:	31 0c       	mov	r12,16
800095b8:	fe b0 e8 e8 	rcall	80006788 <malloc>
800095bc:	99 35       	st.w	r12[0xc],r5
800095be:	8f 9c       	st.w	r7[0x24],r12
800095c0:	99 15       	st.w	r12[0x4],r5
800095c2:	99 25       	st.w	r12[0x8],r5
800095c4:	99 05       	st.w	r12[0x0],r5
800095c6:	6e 99       	ld.w	r9,r7[0x24]
800095c8:	72 08       	ld.w	r8,r9[0x0]
800095ca:	58 08       	cp.w	r8,0
800095cc:	c0 f0       	breq	800095ea <_dtoa_r+0x5a>
800095ce:	72 1a       	ld.w	r10,r9[0x4]
800095d0:	91 1a       	st.w	r8[0x4],r10
800095d2:	30 1a       	mov	r10,1
800095d4:	72 19       	ld.w	r9,r9[0x4]
800095d6:	f4 09 09 49 	lsl	r9,r10,r9
800095da:	10 9b       	mov	r11,r8
800095dc:	91 29       	st.w	r8[0x8],r9
800095de:	0e 9c       	mov	r12,r7
800095e0:	e0 a0 0a 90 	rcall	8000ab00 <_Bfree>
800095e4:	6e 98       	ld.w	r8,r7[0x24]
800095e6:	30 09       	mov	r9,0
800095e8:	91 09       	st.w	r8[0x0],r9
800095ea:	40 28       	lddsp	r8,sp[0x8]
800095ec:	10 94       	mov	r4,r8
800095ee:	58 08       	cp.w	r8,0
800095f0:	c0 64       	brge	800095fc <_dtoa_r+0x6c>
800095f2:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
800095f6:	50 28       	stdsp	sp[0x8],r8
800095f8:	30 18       	mov	r8,1
800095fa:	c0 28       	rjmp	800095fe <_dtoa_r+0x6e>
800095fc:	30 08       	mov	r8,0
800095fe:	8d 08       	st.w	r6[0x0],r8
80009600:	fc 1c 7f f0 	movh	r12,0x7ff0
80009604:	40 26       	lddsp	r6,sp[0x8]
80009606:	0c 98       	mov	r8,r6
80009608:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000960c:	18 38       	cp.w	r8,r12
8000960e:	c2 01       	brne	8000964e <_dtoa_r+0xbe>
80009610:	e0 68 27 0f 	mov	r8,9999
80009614:	41 5b       	lddsp	r11,sp[0x54]
80009616:	97 08       	st.w	r11[0x0],r8
80009618:	40 3a       	lddsp	r10,sp[0xc]
8000961a:	58 0a       	cp.w	r10,0
8000961c:	c0 71       	brne	8000962a <_dtoa_r+0x9a>
8000961e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009622:	c0 41       	brne	8000962a <_dtoa_r+0x9a>
80009624:	fe cc c2 9c 	sub	r12,pc,-15716
80009628:	c0 38       	rjmp	8000962e <_dtoa_r+0x9e>
8000962a:	fe cc c2 96 	sub	r12,pc,-15722
8000962e:	41 29       	lddsp	r9,sp[0x48]
80009630:	58 09       	cp.w	r9,0
80009632:	e0 80 05 9a 	breq	8000a166 <_dtoa_r+0xbd6>
80009636:	f8 c8 ff fd 	sub	r8,r12,-3
8000963a:	f8 c9 ff f8 	sub	r9,r12,-8
8000963e:	11 8b       	ld.ub	r11,r8[0x0]
80009640:	30 0a       	mov	r10,0
80009642:	41 25       	lddsp	r5,sp[0x48]
80009644:	f4 0b 18 00 	cp.b	r11,r10
80009648:	f2 08 17 10 	movne	r8,r9
8000964c:	c1 68       	rjmp	80009678 <_dtoa_r+0xe8>
8000964e:	fa ea 00 08 	ld.d	r10,sp[8]
80009652:	30 08       	mov	r8,0
80009654:	fa eb 00 3c 	st.d	sp[60],r10
80009658:	30 09       	mov	r9,0
8000965a:	e0 a0 10 c2 	rcall	8000b7de <__avr32_f64_cmp_eq>
8000965e:	c1 00       	breq	8000967e <_dtoa_r+0xee>
80009660:	30 18       	mov	r8,1
80009662:	41 5a       	lddsp	r10,sp[0x54]
80009664:	95 08       	st.w	r10[0x0],r8
80009666:	fe cc c4 02 	sub	r12,pc,-15358
8000966a:	41 29       	lddsp	r9,sp[0x48]
8000966c:	f8 08 00 08 	add	r8,r12,r8
80009670:	58 09       	cp.w	r9,0
80009672:	e0 80 05 7a 	breq	8000a166 <_dtoa_r+0xbd6>
80009676:	12 95       	mov	r5,r9
80009678:	8b 08       	st.w	r5[0x0],r8
8000967a:	e0 8f 05 76 	bral	8000a166 <_dtoa_r+0xbd6>
8000967e:	fa c8 ff 9c 	sub	r8,sp,-100
80009682:	fa c9 ff a0 	sub	r9,sp,-96
80009686:	fa ea 00 3c 	ld.d	r10,sp[60]
8000968a:	0e 9c       	mov	r12,r7
8000968c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80009690:	e0 a0 0a 8a 	rcall	8000aba4 <__d2b>
80009694:	18 93       	mov	r3,r12
80009696:	58 05       	cp.w	r5,0
80009698:	c0 d0       	breq	800096b2 <_dtoa_r+0x122>
8000969a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000969e:	30 04       	mov	r4,0
800096a0:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800096a4:	ea c5 03 ff 	sub	r5,r5,1023
800096a8:	10 9b       	mov	r11,r8
800096aa:	51 74       	stdsp	sp[0x5c],r4
800096ac:	ea 1b 3f f0 	orh	r11,0x3ff0
800096b0:	c2 58       	rjmp	800096fa <_dtoa_r+0x16a>
800096b2:	41 88       	lddsp	r8,sp[0x60]
800096b4:	41 9c       	lddsp	r12,sp[0x64]
800096b6:	10 0c       	add	r12,r8
800096b8:	f8 c5 fb ce 	sub	r5,r12,-1074
800096bc:	e0 45 00 20 	cp.w	r5,32
800096c0:	e0 8a 00 0e 	brle	800096dc <_dtoa_r+0x14c>
800096c4:	f8 cc fb ee 	sub	r12,r12,-1042
800096c8:	40 3b       	lddsp	r11,sp[0xc]
800096ca:	ea 08 11 40 	rsub	r8,r5,64
800096ce:	f6 0c 0a 4c 	lsr	r12,r11,r12
800096d2:	ec 08 09 46 	lsl	r6,r6,r8
800096d6:	0c 4c       	or	r12,r6
800096d8:	c0 78       	rjmp	800096e6 <_dtoa_r+0x156>
800096da:	d7 03       	nop
800096dc:	ea 0c 11 20 	rsub	r12,r5,32
800096e0:	40 3a       	lddsp	r10,sp[0xc]
800096e2:	f4 0c 09 4c 	lsl	r12,r10,r12
800096e6:	e0 a0 10 08 	rcall	8000b6f6 <__avr32_u32_to_f64>
800096ea:	fc 18 fe 10 	movh	r8,0xfe10
800096ee:	30 19       	mov	r9,1
800096f0:	ea c5 04 33 	sub	r5,r5,1075
800096f4:	f0 0b 00 0b 	add	r11,r8,r11
800096f8:	51 79       	stdsp	sp[0x5c],r9
800096fa:	30 08       	mov	r8,0
800096fc:	fc 19 3f f8 	movh	r9,0x3ff8
80009700:	e0 a0 0e 90 	rcall	8000b420 <__avr32_f64_sub>
80009704:	e0 68 43 61 	mov	r8,17249
80009708:	ea 18 63 6f 	orh	r8,0x636f
8000970c:	e0 69 87 a7 	mov	r9,34727
80009710:	ea 19 3f d2 	orh	r9,0x3fd2
80009714:	e0 a0 0d 9a 	rcall	8000b248 <__avr32_f64_mul>
80009718:	e0 68 c8 b3 	mov	r8,51379
8000971c:	ea 18 8b 60 	orh	r8,0x8b60
80009720:	e0 69 8a 28 	mov	r9,35368
80009724:	ea 19 3f c6 	orh	r9,0x3fc6
80009728:	e0 a0 0f 4a 	rcall	8000b5bc <__avr32_f64_add>
8000972c:	0a 9c       	mov	r12,r5
8000972e:	14 90       	mov	r0,r10
80009730:	16 91       	mov	r1,r11
80009732:	e0 a0 0f e6 	rcall	8000b6fe <__avr32_s32_to_f64>
80009736:	e0 68 79 fb 	mov	r8,31227
8000973a:	ea 18 50 9f 	orh	r8,0x509f
8000973e:	e0 69 44 13 	mov	r9,17427
80009742:	ea 19 3f d3 	orh	r9,0x3fd3
80009746:	e0 a0 0d 81 	rcall	8000b248 <__avr32_f64_mul>
8000974a:	14 98       	mov	r8,r10
8000974c:	16 99       	mov	r9,r11
8000974e:	00 9a       	mov	r10,r0
80009750:	02 9b       	mov	r11,r1
80009752:	e0 a0 0f 35 	rcall	8000b5bc <__avr32_f64_add>
80009756:	14 90       	mov	r0,r10
80009758:	16 91       	mov	r1,r11
8000975a:	e0 a0 0f bb 	rcall	8000b6d0 <__avr32_f64_to_s32>
8000975e:	30 08       	mov	r8,0
80009760:	18 96       	mov	r6,r12
80009762:	30 09       	mov	r9,0
80009764:	00 9a       	mov	r10,r0
80009766:	02 9b       	mov	r11,r1
80009768:	e0 a0 10 82 	rcall	8000b86c <__avr32_f64_cmp_lt>
8000976c:	c0 c0       	breq	80009784 <_dtoa_r+0x1f4>
8000976e:	0c 9c       	mov	r12,r6
80009770:	e0 a0 0f c7 	rcall	8000b6fe <__avr32_s32_to_f64>
80009774:	14 98       	mov	r8,r10
80009776:	16 99       	mov	r9,r11
80009778:	00 9a       	mov	r10,r0
8000977a:	02 9b       	mov	r11,r1
8000977c:	e0 a0 10 31 	rcall	8000b7de <__avr32_f64_cmp_eq>
80009780:	f7 b6 00 01 	subeq	r6,1
80009784:	59 66       	cp.w	r6,22
80009786:	e0 88 00 05 	brls	80009790 <_dtoa_r+0x200>
8000978a:	30 18       	mov	r8,1
8000978c:	51 48       	stdsp	sp[0x50],r8
8000978e:	c1 38       	rjmp	800097b4 <_dtoa_r+0x224>
80009790:	fe c8 c3 48 	sub	r8,pc,-15544
80009794:	fa ea 00 3c 	ld.d	r10,sp[60]
80009798:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000979c:	e0 a0 10 68 	rcall	8000b86c <__avr32_f64_cmp_lt>
800097a0:	f9 b4 00 00 	moveq	r4,0
800097a4:	fb f4 0a 14 	st.weq	sp[0x50],r4
800097a8:	f7 b6 01 01 	subne	r6,1
800097ac:	f9 bc 01 00 	movne	r12,0
800097b0:	fb fc 1a 14 	st.wne	sp[0x50],r12
800097b4:	41 90       	lddsp	r0,sp[0x64]
800097b6:	20 10       	sub	r0,1
800097b8:	0a 10       	sub	r0,r5
800097ba:	c0 46       	brmi	800097c2 <_dtoa_r+0x232>
800097bc:	50 40       	stdsp	sp[0x10],r0
800097be:	30 00       	mov	r0,0
800097c0:	c0 48       	rjmp	800097c8 <_dtoa_r+0x238>
800097c2:	30 0b       	mov	r11,0
800097c4:	5c 30       	neg	r0
800097c6:	50 4b       	stdsp	sp[0x10],r11
800097c8:	ec 02 11 00 	rsub	r2,r6,0
800097cc:	58 06       	cp.w	r6,0
800097ce:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800097d2:	f5 d6 e4 0a 	addge	r10,r10,r6
800097d6:	fb fa 4a 04 	st.wge	sp[0x10],r10
800097da:	fb f6 4a 11 	st.wge	sp[0x44],r6
800097de:	f9 b2 04 00 	movge	r2,0
800097e2:	e1 d6 e5 10 	sublt	r0,r0,r6
800097e6:	f9 b9 05 00 	movlt	r9,0
800097ea:	fb f9 5a 11 	st.wlt	sp[0x44],r9
800097ee:	40 c8       	lddsp	r8,sp[0x30]
800097f0:	58 98       	cp.w	r8,9
800097f2:	e0 8b 00 20 	brhi	80009832 <_dtoa_r+0x2a2>
800097f6:	58 58       	cp.w	r8,5
800097f8:	f9 b4 0a 01 	movle	r4,1
800097fc:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009800:	f7 b5 09 04 	subgt	r5,4
80009804:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009808:	f9 b4 09 00 	movgt	r4,0
8000980c:	40 cc       	lddsp	r12,sp[0x30]
8000980e:	58 3c       	cp.w	r12,3
80009810:	c2 d0       	breq	8000986a <_dtoa_r+0x2da>
80009812:	e0 89 00 05 	brgt	8000981c <_dtoa_r+0x28c>
80009816:	58 2c       	cp.w	r12,2
80009818:	c1 01       	brne	80009838 <_dtoa_r+0x2a8>
8000981a:	c1 88       	rjmp	8000984a <_dtoa_r+0x2ba>
8000981c:	40 cb       	lddsp	r11,sp[0x30]
8000981e:	58 4b       	cp.w	r11,4
80009820:	c0 60       	breq	8000982c <_dtoa_r+0x29c>
80009822:	58 5b       	cp.w	r11,5
80009824:	c0 a1       	brne	80009838 <_dtoa_r+0x2a8>
80009826:	30 1a       	mov	r10,1
80009828:	50 da       	stdsp	sp[0x34],r10
8000982a:	c2 28       	rjmp	8000986e <_dtoa_r+0x2de>
8000982c:	30 19       	mov	r9,1
8000982e:	50 d9       	stdsp	sp[0x34],r9
80009830:	c0 f8       	rjmp	8000984e <_dtoa_r+0x2be>
80009832:	30 08       	mov	r8,0
80009834:	30 14       	mov	r4,1
80009836:	50 c8       	stdsp	sp[0x30],r8
80009838:	3f f5       	mov	r5,-1
8000983a:	30 1c       	mov	r12,1
8000983c:	30 0b       	mov	r11,0
8000983e:	50 95       	stdsp	sp[0x24],r5
80009840:	50 dc       	stdsp	sp[0x34],r12
80009842:	0a 91       	mov	r1,r5
80009844:	31 28       	mov	r8,18
80009846:	50 eb       	stdsp	sp[0x38],r11
80009848:	c2 08       	rjmp	80009888 <_dtoa_r+0x2f8>
8000984a:	30 0a       	mov	r10,0
8000984c:	50 da       	stdsp	sp[0x34],r10
8000984e:	40 e9       	lddsp	r9,sp[0x38]
80009850:	58 09       	cp.w	r9,0
80009852:	e0 89 00 07 	brgt	80009860 <_dtoa_r+0x2d0>
80009856:	30 18       	mov	r8,1
80009858:	50 98       	stdsp	sp[0x24],r8
8000985a:	10 91       	mov	r1,r8
8000985c:	50 e8       	stdsp	sp[0x38],r8
8000985e:	c1 58       	rjmp	80009888 <_dtoa_r+0x2f8>
80009860:	40 e5       	lddsp	r5,sp[0x38]
80009862:	50 95       	stdsp	sp[0x24],r5
80009864:	0a 91       	mov	r1,r5
80009866:	0a 98       	mov	r8,r5
80009868:	c1 08       	rjmp	80009888 <_dtoa_r+0x2f8>
8000986a:	30 0c       	mov	r12,0
8000986c:	50 dc       	stdsp	sp[0x34],r12
8000986e:	40 eb       	lddsp	r11,sp[0x38]
80009870:	ec 0b 00 0b 	add	r11,r6,r11
80009874:	50 9b       	stdsp	sp[0x24],r11
80009876:	16 98       	mov	r8,r11
80009878:	2f f8       	sub	r8,-1
8000987a:	58 08       	cp.w	r8,0
8000987c:	e0 89 00 05 	brgt	80009886 <_dtoa_r+0x2f6>
80009880:	10 91       	mov	r1,r8
80009882:	30 18       	mov	r8,1
80009884:	c0 28       	rjmp	80009888 <_dtoa_r+0x2f8>
80009886:	10 91       	mov	r1,r8
80009888:	30 09       	mov	r9,0
8000988a:	6e 9a       	ld.w	r10,r7[0x24]
8000988c:	95 19       	st.w	r10[0x4],r9
8000988e:	30 49       	mov	r9,4
80009890:	c0 68       	rjmp	8000989c <_dtoa_r+0x30c>
80009892:	d7 03       	nop
80009894:	6a 1a       	ld.w	r10,r5[0x4]
80009896:	a1 79       	lsl	r9,0x1
80009898:	2f fa       	sub	r10,-1
8000989a:	8b 1a       	st.w	r5[0x4],r10
8000989c:	6e 95       	ld.w	r5,r7[0x24]
8000989e:	f2 ca ff ec 	sub	r10,r9,-20
800098a2:	10 3a       	cp.w	r10,r8
800098a4:	fe 98 ff f8 	brls	80009894 <_dtoa_r+0x304>
800098a8:	6a 1b       	ld.w	r11,r5[0x4]
800098aa:	0e 9c       	mov	r12,r7
800098ac:	e0 a0 09 44 	rcall	8000ab34 <_Balloc>
800098b0:	58 e1       	cp.w	r1,14
800098b2:	5f 88       	srls	r8
800098b4:	8b 0c       	st.w	r5[0x0],r12
800098b6:	f1 e4 00 04 	and	r4,r8,r4
800098ba:	6e 98       	ld.w	r8,r7[0x24]
800098bc:	70 08       	ld.w	r8,r8[0x0]
800098be:	50 88       	stdsp	sp[0x20],r8
800098c0:	e0 80 01 82 	breq	80009bc4 <_dtoa_r+0x634>
800098c4:	58 06       	cp.w	r6,0
800098c6:	e0 8a 00 43 	brle	8000994c <_dtoa_r+0x3bc>
800098ca:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800098ce:	fe c8 c4 86 	sub	r8,pc,-15226
800098d2:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800098d6:	fa e5 00 18 	st.d	sp[24],r4
800098da:	ec 04 14 04 	asr	r4,r6,0x4
800098de:	ed b4 00 04 	bld	r4,0x4
800098e2:	c0 30       	breq	800098e8 <_dtoa_r+0x358>
800098e4:	30 25       	mov	r5,2
800098e6:	c1 08       	rjmp	80009906 <_dtoa_r+0x376>
800098e8:	fe c8 c3 d8 	sub	r8,pc,-15400
800098ec:	f0 e8 00 20 	ld.d	r8,r8[32]
800098f0:	fa ea 00 3c 	ld.d	r10,sp[60]
800098f4:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
800098f8:	e0 a0 0f ee 	rcall	8000b8d4 <__avr32_f64_div>
800098fc:	30 35       	mov	r5,3
800098fe:	14 98       	mov	r8,r10
80009900:	16 99       	mov	r9,r11
80009902:	fa e9 00 08 	st.d	sp[8],r8
80009906:	fe cc c3 f6 	sub	r12,pc,-15370
8000990a:	50 a3       	stdsp	sp[0x28],r3
8000990c:	0c 93       	mov	r3,r6
8000990e:	18 96       	mov	r6,r12
80009910:	c0 f8       	rjmp	8000992e <_dtoa_r+0x39e>
80009912:	fa ea 00 18 	ld.d	r10,sp[24]
80009916:	ed b4 00 00 	bld	r4,0x0
8000991a:	c0 81       	brne	8000992a <_dtoa_r+0x39a>
8000991c:	ec e8 00 00 	ld.d	r8,r6[0]
80009920:	2f f5       	sub	r5,-1
80009922:	e0 a0 0c 93 	rcall	8000b248 <__avr32_f64_mul>
80009926:	fa eb 00 18 	st.d	sp[24],r10
8000992a:	a1 54       	asr	r4,0x1
8000992c:	2f 86       	sub	r6,-8
8000992e:	58 04       	cp.w	r4,0
80009930:	cf 11       	brne	80009912 <_dtoa_r+0x382>
80009932:	fa e8 00 18 	ld.d	r8,sp[24]
80009936:	fa ea 00 08 	ld.d	r10,sp[8]
8000993a:	06 96       	mov	r6,r3
8000993c:	e0 a0 0f cc 	rcall	8000b8d4 <__avr32_f64_div>
80009940:	40 a3       	lddsp	r3,sp[0x28]
80009942:	14 98       	mov	r8,r10
80009944:	16 99       	mov	r9,r11
80009946:	fa e9 00 08 	st.d	sp[8],r8
8000994a:	c2 f8       	rjmp	800099a8 <_dtoa_r+0x418>
8000994c:	ec 08 11 00 	rsub	r8,r6,0
80009950:	c0 31       	brne	80009956 <_dtoa_r+0x3c6>
80009952:	30 25       	mov	r5,2
80009954:	c2 a8       	rjmp	800099a8 <_dtoa_r+0x418>
80009956:	fe cc c4 46 	sub	r12,pc,-15290
8000995a:	f0 04 14 04 	asr	r4,r8,0x4
8000995e:	50 1c       	stdsp	sp[0x4],r12
80009960:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009964:	fe c9 c5 1c 	sub	r9,pc,-15076
80009968:	fa ea 00 3c 	ld.d	r10,sp[60]
8000996c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009970:	e0 a0 0c 6c 	rcall	8000b248 <__avr32_f64_mul>
80009974:	40 1c       	lddsp	r12,sp[0x4]
80009976:	50 63       	stdsp	sp[0x18],r3
80009978:	30 25       	mov	r5,2
8000997a:	0c 93       	mov	r3,r6
8000997c:	fa eb 00 08 	st.d	sp[8],r10
80009980:	18 96       	mov	r6,r12
80009982:	c0 f8       	rjmp	800099a0 <_dtoa_r+0x410>
80009984:	fa ea 00 08 	ld.d	r10,sp[8]
80009988:	ed b4 00 00 	bld	r4,0x0
8000998c:	c0 81       	brne	8000999c <_dtoa_r+0x40c>
8000998e:	ec e8 00 00 	ld.d	r8,r6[0]
80009992:	2f f5       	sub	r5,-1
80009994:	e0 a0 0c 5a 	rcall	8000b248 <__avr32_f64_mul>
80009998:	fa eb 00 08 	st.d	sp[8],r10
8000999c:	a1 54       	asr	r4,0x1
8000999e:	2f 86       	sub	r6,-8
800099a0:	58 04       	cp.w	r4,0
800099a2:	cf 11       	brne	80009984 <_dtoa_r+0x3f4>
800099a4:	06 96       	mov	r6,r3
800099a6:	40 63       	lddsp	r3,sp[0x18]
800099a8:	41 4a       	lddsp	r10,sp[0x50]
800099aa:	58 0a       	cp.w	r10,0
800099ac:	c2 a0       	breq	80009a00 <_dtoa_r+0x470>
800099ae:	fa e8 00 08 	ld.d	r8,sp[8]
800099b2:	58 01       	cp.w	r1,0
800099b4:	5f 94       	srgt	r4
800099b6:	fa e9 00 18 	st.d	sp[24],r8
800099ba:	30 08       	mov	r8,0
800099bc:	fc 19 3f f0 	movh	r9,0x3ff0
800099c0:	fa ea 00 18 	ld.d	r10,sp[24]
800099c4:	e0 a0 0f 54 	rcall	8000b86c <__avr32_f64_cmp_lt>
800099c8:	f9 bc 00 00 	moveq	r12,0
800099cc:	f9 bc 01 01 	movne	r12,1
800099d0:	e9 ec 00 0c 	and	r12,r4,r12
800099d4:	c1 60       	breq	80009a00 <_dtoa_r+0x470>
800099d6:	40 98       	lddsp	r8,sp[0x24]
800099d8:	58 08       	cp.w	r8,0
800099da:	e0 8a 00 f1 	brle	80009bbc <_dtoa_r+0x62c>
800099de:	30 08       	mov	r8,0
800099e0:	fc 19 40 24 	movh	r9,0x4024
800099e4:	ec c4 00 01 	sub	r4,r6,1
800099e8:	fa ea 00 18 	ld.d	r10,sp[24]
800099ec:	2f f5       	sub	r5,-1
800099ee:	50 64       	stdsp	sp[0x18],r4
800099f0:	e0 a0 0c 2c 	rcall	8000b248 <__avr32_f64_mul>
800099f4:	40 94       	lddsp	r4,sp[0x24]
800099f6:	14 98       	mov	r8,r10
800099f8:	16 99       	mov	r9,r11
800099fa:	fa e9 00 08 	st.d	sp[8],r8
800099fe:	c0 38       	rjmp	80009a04 <_dtoa_r+0x474>
80009a00:	50 66       	stdsp	sp[0x18],r6
80009a02:	02 94       	mov	r4,r1
80009a04:	0a 9c       	mov	r12,r5
80009a06:	e0 a0 0e 7c 	rcall	8000b6fe <__avr32_s32_to_f64>
80009a0a:	fa e8 00 08 	ld.d	r8,sp[8]
80009a0e:	e0 a0 0c 1d 	rcall	8000b248 <__avr32_f64_mul>
80009a12:	30 08       	mov	r8,0
80009a14:	fc 19 40 1c 	movh	r9,0x401c
80009a18:	e0 a0 0d d2 	rcall	8000b5bc <__avr32_f64_add>
80009a1c:	14 98       	mov	r8,r10
80009a1e:	16 99       	mov	r9,r11
80009a20:	fa e9 00 28 	st.d	sp[40],r8
80009a24:	fc 18 fc c0 	movh	r8,0xfcc0
80009a28:	40 a5       	lddsp	r5,sp[0x28]
80009a2a:	10 05       	add	r5,r8
80009a2c:	50 a5       	stdsp	sp[0x28],r5
80009a2e:	58 04       	cp.w	r4,0
80009a30:	c2 11       	brne	80009a72 <_dtoa_r+0x4e2>
80009a32:	fa ea 00 08 	ld.d	r10,sp[8]
80009a36:	30 08       	mov	r8,0
80009a38:	fc 19 40 14 	movh	r9,0x4014
80009a3c:	e0 a0 0c f2 	rcall	8000b420 <__avr32_f64_sub>
80009a40:	40 bc       	lddsp	r12,sp[0x2c]
80009a42:	fa eb 00 08 	st.d	sp[8],r10
80009a46:	14 98       	mov	r8,r10
80009a48:	16 99       	mov	r9,r11
80009a4a:	18 9a       	mov	r10,r12
80009a4c:	0a 9b       	mov	r11,r5
80009a4e:	e0 a0 0f 0f 	rcall	8000b86c <__avr32_f64_cmp_lt>
80009a52:	e0 81 02 54 	brne	80009efa <_dtoa_r+0x96a>
80009a56:	0a 98       	mov	r8,r5
80009a58:	40 b9       	lddsp	r9,sp[0x2c]
80009a5a:	ee 18 80 00 	eorh	r8,0x8000
80009a5e:	fa ea 00 08 	ld.d	r10,sp[8]
80009a62:	10 95       	mov	r5,r8
80009a64:	12 98       	mov	r8,r9
80009a66:	0a 99       	mov	r9,r5
80009a68:	e0 a0 0f 02 	rcall	8000b86c <__avr32_f64_cmp_lt>
80009a6c:	e0 81 02 3e 	brne	80009ee8 <_dtoa_r+0x958>
80009a70:	ca 68       	rjmp	80009bbc <_dtoa_r+0x62c>
80009a72:	fe c9 c6 2a 	sub	r9,pc,-14806
80009a76:	e8 c8 00 01 	sub	r8,r4,1
80009a7a:	40 d5       	lddsp	r5,sp[0x34]
80009a7c:	58 05       	cp.w	r5,0
80009a7e:	c4 f0       	breq	80009b1c <_dtoa_r+0x58c>
80009a80:	30 0c       	mov	r12,0
80009a82:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009a86:	51 3c       	stdsp	sp[0x4c],r12
80009a88:	30 0a       	mov	r10,0
80009a8a:	fc 1b 3f e0 	movh	r11,0x3fe0
80009a8e:	e0 a0 0f 23 	rcall	8000b8d4 <__avr32_f64_div>
80009a92:	fa e8 00 28 	ld.d	r8,sp[40]
80009a96:	40 85       	lddsp	r5,sp[0x20]
80009a98:	e0 a0 0c c4 	rcall	8000b420 <__avr32_f64_sub>
80009a9c:	fa eb 00 28 	st.d	sp[40],r10
80009aa0:	fa ea 00 08 	ld.d	r10,sp[8]
80009aa4:	e0 a0 0e 16 	rcall	8000b6d0 <__avr32_f64_to_s32>
80009aa8:	51 6c       	stdsp	sp[0x58],r12
80009aaa:	e0 a0 0e 2a 	rcall	8000b6fe <__avr32_s32_to_f64>
80009aae:	14 98       	mov	r8,r10
80009ab0:	16 99       	mov	r9,r11
80009ab2:	fa ea 00 08 	ld.d	r10,sp[8]
80009ab6:	e0 a0 0c b5 	rcall	8000b420 <__avr32_f64_sub>
80009aba:	fa eb 00 08 	st.d	sp[8],r10
80009abe:	41 68       	lddsp	r8,sp[0x58]
80009ac0:	2d 08       	sub	r8,-48
80009ac2:	0a c8       	st.b	r5++,r8
80009ac4:	41 39       	lddsp	r9,sp[0x4c]
80009ac6:	2f f9       	sub	r9,-1
80009ac8:	51 39       	stdsp	sp[0x4c],r9
80009aca:	fa e8 00 28 	ld.d	r8,sp[40]
80009ace:	e0 a0 0e cf 	rcall	8000b86c <__avr32_f64_cmp_lt>
80009ad2:	e0 81 03 39 	brne	8000a144 <_dtoa_r+0xbb4>
80009ad6:	fa e8 00 08 	ld.d	r8,sp[8]
80009ada:	30 0a       	mov	r10,0
80009adc:	fc 1b 3f f0 	movh	r11,0x3ff0
80009ae0:	e0 a0 0c a0 	rcall	8000b420 <__avr32_f64_sub>
80009ae4:	fa e8 00 28 	ld.d	r8,sp[40]
80009ae8:	e0 a0 0e c2 	rcall	8000b86c <__avr32_f64_cmp_lt>
80009aec:	fa ea 00 28 	ld.d	r10,sp[40]
80009af0:	30 08       	mov	r8,0
80009af2:	fc 19 40 24 	movh	r9,0x4024
80009af6:	e0 81 00 da 	brne	80009caa <_dtoa_r+0x71a>
80009afa:	41 3c       	lddsp	r12,sp[0x4c]
80009afc:	08 3c       	cp.w	r12,r4
80009afe:	c5 f4       	brge	80009bbc <_dtoa_r+0x62c>
80009b00:	e0 a0 0b a4 	rcall	8000b248 <__avr32_f64_mul>
80009b04:	30 08       	mov	r8,0
80009b06:	fa eb 00 28 	st.d	sp[40],r10
80009b0a:	fc 19 40 24 	movh	r9,0x4024
80009b0e:	fa ea 00 08 	ld.d	r10,sp[8]
80009b12:	e0 a0 0b 9b 	rcall	8000b248 <__avr32_f64_mul>
80009b16:	fa eb 00 08 	st.d	sp[8],r10
80009b1a:	cc 3b       	rjmp	80009aa0 <_dtoa_r+0x510>
80009b1c:	40 85       	lddsp	r5,sp[0x20]
80009b1e:	08 05       	add	r5,r4
80009b20:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009b24:	51 35       	stdsp	sp[0x4c],r5
80009b26:	fa e8 00 28 	ld.d	r8,sp[40]
80009b2a:	40 85       	lddsp	r5,sp[0x20]
80009b2c:	e0 a0 0b 8e 	rcall	8000b248 <__avr32_f64_mul>
80009b30:	fa eb 00 28 	st.d	sp[40],r10
80009b34:	fa ea 00 08 	ld.d	r10,sp[8]
80009b38:	e0 a0 0d cc 	rcall	8000b6d0 <__avr32_f64_to_s32>
80009b3c:	51 6c       	stdsp	sp[0x58],r12
80009b3e:	e0 a0 0d e0 	rcall	8000b6fe <__avr32_s32_to_f64>
80009b42:	14 98       	mov	r8,r10
80009b44:	16 99       	mov	r9,r11
80009b46:	fa ea 00 08 	ld.d	r10,sp[8]
80009b4a:	e0 a0 0c 6b 	rcall	8000b420 <__avr32_f64_sub>
80009b4e:	fa eb 00 08 	st.d	sp[8],r10
80009b52:	41 68       	lddsp	r8,sp[0x58]
80009b54:	2d 08       	sub	r8,-48
80009b56:	0a c8       	st.b	r5++,r8
80009b58:	41 3c       	lddsp	r12,sp[0x4c]
80009b5a:	18 35       	cp.w	r5,r12
80009b5c:	c2 81       	brne	80009bac <_dtoa_r+0x61c>
80009b5e:	30 08       	mov	r8,0
80009b60:	fc 19 3f e0 	movh	r9,0x3fe0
80009b64:	fa ea 00 28 	ld.d	r10,sp[40]
80009b68:	e0 a0 0d 2a 	rcall	8000b5bc <__avr32_f64_add>
80009b6c:	40 85       	lddsp	r5,sp[0x20]
80009b6e:	fa e8 00 08 	ld.d	r8,sp[8]
80009b72:	08 05       	add	r5,r4
80009b74:	e0 a0 0e 7c 	rcall	8000b86c <__avr32_f64_cmp_lt>
80009b78:	e0 81 00 99 	brne	80009caa <_dtoa_r+0x71a>
80009b7c:	fa e8 00 28 	ld.d	r8,sp[40]
80009b80:	30 0a       	mov	r10,0
80009b82:	fc 1b 3f e0 	movh	r11,0x3fe0
80009b86:	e0 a0 0c 4d 	rcall	8000b420 <__avr32_f64_sub>
80009b8a:	14 98       	mov	r8,r10
80009b8c:	16 99       	mov	r9,r11
80009b8e:	fa ea 00 08 	ld.d	r10,sp[8]
80009b92:	e0 a0 0e 6d 	rcall	8000b86c <__avr32_f64_cmp_lt>
80009b96:	c1 30       	breq	80009bbc <_dtoa_r+0x62c>
80009b98:	33 09       	mov	r9,48
80009b9a:	0a 98       	mov	r8,r5
80009b9c:	11 7a       	ld.ub	r10,--r8
80009b9e:	f2 0a 18 00 	cp.b	r10,r9
80009ba2:	e0 81 02 d1 	brne	8000a144 <_dtoa_r+0xbb4>
80009ba6:	10 95       	mov	r5,r8
80009ba8:	cf 9b       	rjmp	80009b9a <_dtoa_r+0x60a>
80009baa:	d7 03       	nop
80009bac:	30 08       	mov	r8,0
80009bae:	fc 19 40 24 	movh	r9,0x4024
80009bb2:	e0 a0 0b 4b 	rcall	8000b248 <__avr32_f64_mul>
80009bb6:	fa eb 00 08 	st.d	sp[8],r10
80009bba:	cb db       	rjmp	80009b34 <_dtoa_r+0x5a4>
80009bbc:	fa ea 00 3c 	ld.d	r10,sp[60]
80009bc0:	fa eb 00 08 	st.d	sp[8],r10
80009bc4:	58 e6       	cp.w	r6,14
80009bc6:	5f ab       	srle	r11
80009bc8:	41 8a       	lddsp	r10,sp[0x60]
80009bca:	30 08       	mov	r8,0
80009bcc:	f4 09 11 ff 	rsub	r9,r10,-1
80009bd0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009bd4:	f0 09 18 00 	cp.b	r9,r8
80009bd8:	e0 80 00 82 	breq	80009cdc <_dtoa_r+0x74c>
80009bdc:	40 ea       	lddsp	r10,sp[0x38]
80009bde:	58 01       	cp.w	r1,0
80009be0:	5f a9       	srle	r9
80009be2:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009be6:	fe ca c7 9e 	sub	r10,pc,-14434
80009bea:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009bee:	fa e5 00 10 	st.d	sp[16],r4
80009bf2:	f0 09 18 00 	cp.b	r9,r8
80009bf6:	c1 40       	breq	80009c1e <_dtoa_r+0x68e>
80009bf8:	58 01       	cp.w	r1,0
80009bfa:	e0 81 01 77 	brne	80009ee8 <_dtoa_r+0x958>
80009bfe:	30 08       	mov	r8,0
80009c00:	fc 19 40 14 	movh	r9,0x4014
80009c04:	08 9a       	mov	r10,r4
80009c06:	0a 9b       	mov	r11,r5
80009c08:	e0 a0 0b 20 	rcall	8000b248 <__avr32_f64_mul>
80009c0c:	fa e8 00 08 	ld.d	r8,sp[8]
80009c10:	e0 a0 0d fa 	rcall	8000b804 <__avr32_f64_cmp_ge>
80009c14:	e0 81 01 6a 	brne	80009ee8 <_dtoa_r+0x958>
80009c18:	02 92       	mov	r2,r1
80009c1a:	e0 8f 01 72 	bral	80009efe <_dtoa_r+0x96e>
80009c1e:	40 85       	lddsp	r5,sp[0x20]
80009c20:	30 14       	mov	r4,1
80009c22:	fa e8 00 10 	ld.d	r8,sp[16]
80009c26:	fa ea 00 08 	ld.d	r10,sp[8]
80009c2a:	e0 a0 0e 55 	rcall	8000b8d4 <__avr32_f64_div>
80009c2e:	e0 a0 0d 51 	rcall	8000b6d0 <__avr32_f64_to_s32>
80009c32:	18 92       	mov	r2,r12
80009c34:	e0 a0 0d 65 	rcall	8000b6fe <__avr32_s32_to_f64>
80009c38:	fa e8 00 10 	ld.d	r8,sp[16]
80009c3c:	e0 a0 0b 06 	rcall	8000b248 <__avr32_f64_mul>
80009c40:	14 98       	mov	r8,r10
80009c42:	16 99       	mov	r9,r11
80009c44:	fa ea 00 08 	ld.d	r10,sp[8]
80009c48:	e0 a0 0b ec 	rcall	8000b420 <__avr32_f64_sub>
80009c4c:	fa eb 00 08 	st.d	sp[8],r10
80009c50:	e4 c8 ff d0 	sub	r8,r2,-48
80009c54:	0a c8       	st.b	r5++,r8
80009c56:	fc 19 40 24 	movh	r9,0x4024
80009c5a:	30 08       	mov	r8,0
80009c5c:	02 34       	cp.w	r4,r1
80009c5e:	c3 31       	brne	80009cc4 <_dtoa_r+0x734>
80009c60:	fa e8 00 08 	ld.d	r8,sp[8]
80009c64:	e0 a0 0c ac 	rcall	8000b5bc <__avr32_f64_add>
80009c68:	16 91       	mov	r1,r11
80009c6a:	14 90       	mov	r0,r10
80009c6c:	14 98       	mov	r8,r10
80009c6e:	02 99       	mov	r9,r1
80009c70:	fa ea 00 10 	ld.d	r10,sp[16]
80009c74:	e0 a0 0d fc 	rcall	8000b86c <__avr32_f64_cmp_lt>
80009c78:	c1 a1       	brne	80009cac <_dtoa_r+0x71c>
80009c7a:	fa e8 00 10 	ld.d	r8,sp[16]
80009c7e:	00 9a       	mov	r10,r0
80009c80:	02 9b       	mov	r11,r1
80009c82:	e0 a0 0d ae 	rcall	8000b7de <__avr32_f64_cmp_eq>
80009c86:	e0 80 02 5e 	breq	8000a142 <_dtoa_r+0xbb2>
80009c8a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009c8e:	c0 f1       	brne	80009cac <_dtoa_r+0x71c>
80009c90:	e0 8f 02 59 	bral	8000a142 <_dtoa_r+0xbb2>
80009c94:	40 8a       	lddsp	r10,sp[0x20]
80009c96:	14 38       	cp.w	r8,r10
80009c98:	c0 30       	breq	80009c9e <_dtoa_r+0x70e>
80009c9a:	10 95       	mov	r5,r8
80009c9c:	c0 98       	rjmp	80009cae <_dtoa_r+0x71e>
80009c9e:	33 08       	mov	r8,48
80009ca0:	40 89       	lddsp	r9,sp[0x20]
80009ca2:	2f f6       	sub	r6,-1
80009ca4:	b2 88       	st.b	r9[0x0],r8
80009ca6:	40 88       	lddsp	r8,sp[0x20]
80009ca8:	c0 88       	rjmp	80009cb8 <_dtoa_r+0x728>
80009caa:	40 66       	lddsp	r6,sp[0x18]
80009cac:	33 99       	mov	r9,57
80009cae:	0a 98       	mov	r8,r5
80009cb0:	11 7a       	ld.ub	r10,--r8
80009cb2:	f2 0a 18 00 	cp.b	r10,r9
80009cb6:	ce f0       	breq	80009c94 <_dtoa_r+0x704>
80009cb8:	50 66       	stdsp	sp[0x18],r6
80009cba:	11 89       	ld.ub	r9,r8[0x0]
80009cbc:	2f f9       	sub	r9,-1
80009cbe:	b0 89       	st.b	r8[0x0],r9
80009cc0:	e0 8f 02 42 	bral	8000a144 <_dtoa_r+0xbb4>
80009cc4:	e0 a0 0a c2 	rcall	8000b248 <__avr32_f64_mul>
80009cc8:	2f f4       	sub	r4,-1
80009cca:	fa eb 00 08 	st.d	sp[8],r10
80009cce:	30 08       	mov	r8,0
80009cd0:	30 09       	mov	r9,0
80009cd2:	e0 a0 0d 86 	rcall	8000b7de <__avr32_f64_cmp_eq>
80009cd6:	ca 60       	breq	80009c22 <_dtoa_r+0x692>
80009cd8:	e0 8f 02 35 	bral	8000a142 <_dtoa_r+0xbb2>
80009cdc:	40 d8       	lddsp	r8,sp[0x34]
80009cde:	58 08       	cp.w	r8,0
80009ce0:	c0 51       	brne	80009cea <_dtoa_r+0x75a>
80009ce2:	04 98       	mov	r8,r2
80009ce4:	00 95       	mov	r5,r0
80009ce6:	40 d4       	lddsp	r4,sp[0x34]
80009ce8:	c3 78       	rjmp	80009d56 <_dtoa_r+0x7c6>
80009cea:	40 c5       	lddsp	r5,sp[0x30]
80009cec:	58 15       	cp.w	r5,1
80009cee:	e0 89 00 0f 	brgt	80009d0c <_dtoa_r+0x77c>
80009cf2:	41 74       	lddsp	r4,sp[0x5c]
80009cf4:	58 04       	cp.w	r4,0
80009cf6:	c0 40       	breq	80009cfe <_dtoa_r+0x76e>
80009cf8:	f4 c9 fb cd 	sub	r9,r10,-1075
80009cfc:	c0 48       	rjmp	80009d04 <_dtoa_r+0x774>
80009cfe:	41 99       	lddsp	r9,sp[0x64]
80009d00:	f2 09 11 36 	rsub	r9,r9,54
80009d04:	04 98       	mov	r8,r2
80009d06:	00 95       	mov	r5,r0
80009d08:	c1 c8       	rjmp	80009d40 <_dtoa_r+0x7b0>
80009d0a:	d7 03       	nop
80009d0c:	e2 c8 00 01 	sub	r8,r1,1
80009d10:	58 01       	cp.w	r1,0
80009d12:	e0 05 17 40 	movge	r5,r0
80009d16:	e2 09 17 40 	movge	r9,r1
80009d1a:	e1 d1 e5 15 	sublt	r5,r0,r1
80009d1e:	f9 b9 05 00 	movlt	r9,0
80009d22:	10 32       	cp.w	r2,r8
80009d24:	e5 d8 e4 18 	subge	r8,r2,r8
80009d28:	f1 d2 e5 18 	sublt	r8,r8,r2
80009d2c:	e5 d8 e5 02 	addlt	r2,r2,r8
80009d30:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009d34:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009d38:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009d3c:	f9 b8 05 00 	movlt	r8,0
80009d40:	40 4b       	lddsp	r11,sp[0x10]
80009d42:	12 0b       	add	r11,r9
80009d44:	50 08       	stdsp	sp[0x0],r8
80009d46:	50 4b       	stdsp	sp[0x10],r11
80009d48:	12 00       	add	r0,r9
80009d4a:	30 1b       	mov	r11,1
80009d4c:	0e 9c       	mov	r12,r7
80009d4e:	e0 a0 08 a7 	rcall	8000ae9c <__i2b>
80009d52:	40 08       	lddsp	r8,sp[0x0]
80009d54:	18 94       	mov	r4,r12
80009d56:	40 4a       	lddsp	r10,sp[0x10]
80009d58:	58 05       	cp.w	r5,0
80009d5a:	5f 99       	srgt	r9
80009d5c:	58 0a       	cp.w	r10,0
80009d5e:	5f 9a       	srgt	r10
80009d60:	f5 e9 00 09 	and	r9,r10,r9
80009d64:	c0 80       	breq	80009d74 <_dtoa_r+0x7e4>
80009d66:	40 4c       	lddsp	r12,sp[0x10]
80009d68:	f8 05 0d 49 	min	r9,r12,r5
80009d6c:	12 1c       	sub	r12,r9
80009d6e:	12 10       	sub	r0,r9
80009d70:	50 4c       	stdsp	sp[0x10],r12
80009d72:	12 15       	sub	r5,r9
80009d74:	58 02       	cp.w	r2,0
80009d76:	e0 8a 00 27 	brle	80009dc4 <_dtoa_r+0x834>
80009d7a:	40 db       	lddsp	r11,sp[0x34]
80009d7c:	58 0b       	cp.w	r11,0
80009d7e:	c1 d0       	breq	80009db8 <_dtoa_r+0x828>
80009d80:	58 08       	cp.w	r8,0
80009d82:	e0 8a 00 17 	brle	80009db0 <_dtoa_r+0x820>
80009d86:	10 9a       	mov	r10,r8
80009d88:	50 08       	stdsp	sp[0x0],r8
80009d8a:	08 9b       	mov	r11,r4
80009d8c:	0e 9c       	mov	r12,r7
80009d8e:	e0 a0 08 cd 	rcall	8000af28 <__pow5mult>
80009d92:	06 9a       	mov	r10,r3
80009d94:	18 9b       	mov	r11,r12
80009d96:	18 94       	mov	r4,r12
80009d98:	0e 9c       	mov	r12,r7
80009d9a:	e0 a0 08 01 	rcall	8000ad9c <__multiply>
80009d9e:	18 99       	mov	r9,r12
80009da0:	06 9b       	mov	r11,r3
80009da2:	50 19       	stdsp	sp[0x4],r9
80009da4:	0e 9c       	mov	r12,r7
80009da6:	e0 a0 06 ad 	rcall	8000ab00 <_Bfree>
80009daa:	40 19       	lddsp	r9,sp[0x4]
80009dac:	40 08       	lddsp	r8,sp[0x0]
80009dae:	12 93       	mov	r3,r9
80009db0:	e4 08 01 0a 	sub	r10,r2,r8
80009db4:	c0 80       	breq	80009dc4 <_dtoa_r+0x834>
80009db6:	c0 28       	rjmp	80009dba <_dtoa_r+0x82a>
80009db8:	04 9a       	mov	r10,r2
80009dba:	06 9b       	mov	r11,r3
80009dbc:	0e 9c       	mov	r12,r7
80009dbe:	e0 a0 08 b5 	rcall	8000af28 <__pow5mult>
80009dc2:	18 93       	mov	r3,r12
80009dc4:	30 1b       	mov	r11,1
80009dc6:	0e 9c       	mov	r12,r7
80009dc8:	e0 a0 08 6a 	rcall	8000ae9c <__i2b>
80009dcc:	41 1a       	lddsp	r10,sp[0x44]
80009dce:	18 92       	mov	r2,r12
80009dd0:	58 0a       	cp.w	r10,0
80009dd2:	e0 8a 00 07 	brle	80009de0 <_dtoa_r+0x850>
80009dd6:	18 9b       	mov	r11,r12
80009dd8:	0e 9c       	mov	r12,r7
80009dda:	e0 a0 08 a7 	rcall	8000af28 <__pow5mult>
80009dde:	18 92       	mov	r2,r12
80009de0:	40 c9       	lddsp	r9,sp[0x30]
80009de2:	58 19       	cp.w	r9,1
80009de4:	e0 89 00 14 	brgt	80009e0c <_dtoa_r+0x87c>
80009de8:	40 38       	lddsp	r8,sp[0xc]
80009dea:	58 08       	cp.w	r8,0
80009dec:	c1 01       	brne	80009e0c <_dtoa_r+0x87c>
80009dee:	40 29       	lddsp	r9,sp[0x8]
80009df0:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009df4:	c0 c1       	brne	80009e0c <_dtoa_r+0x87c>
80009df6:	12 98       	mov	r8,r9
80009df8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009dfc:	c0 80       	breq	80009e0c <_dtoa_r+0x87c>
80009dfe:	40 4c       	lddsp	r12,sp[0x10]
80009e00:	30 1b       	mov	r11,1
80009e02:	2f fc       	sub	r12,-1
80009e04:	2f f0       	sub	r0,-1
80009e06:	50 4c       	stdsp	sp[0x10],r12
80009e08:	50 6b       	stdsp	sp[0x18],r11
80009e0a:	c0 38       	rjmp	80009e10 <_dtoa_r+0x880>
80009e0c:	30 0a       	mov	r10,0
80009e0e:	50 6a       	stdsp	sp[0x18],r10
80009e10:	41 19       	lddsp	r9,sp[0x44]
80009e12:	58 09       	cp.w	r9,0
80009e14:	c0 31       	brne	80009e1a <_dtoa_r+0x88a>
80009e16:	30 1c       	mov	r12,1
80009e18:	c0 98       	rjmp	80009e2a <_dtoa_r+0x89a>
80009e1a:	64 48       	ld.w	r8,r2[0x10]
80009e1c:	2f c8       	sub	r8,-4
80009e1e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009e22:	e0 a0 05 df 	rcall	8000a9e0 <__hi0bits>
80009e26:	f8 0c 11 20 	rsub	r12,r12,32
80009e2a:	40 4b       	lddsp	r11,sp[0x10]
80009e2c:	f8 0b 00 08 	add	r8,r12,r11
80009e30:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009e34:	c0 c0       	breq	80009e4c <_dtoa_r+0x8bc>
80009e36:	f0 08 11 20 	rsub	r8,r8,32
80009e3a:	58 48       	cp.w	r8,4
80009e3c:	e0 8a 00 06 	brle	80009e48 <_dtoa_r+0x8b8>
80009e40:	20 48       	sub	r8,4
80009e42:	10 0b       	add	r11,r8
80009e44:	50 4b       	stdsp	sp[0x10],r11
80009e46:	c0 78       	rjmp	80009e54 <_dtoa_r+0x8c4>
80009e48:	58 48       	cp.w	r8,4
80009e4a:	c0 70       	breq	80009e58 <_dtoa_r+0x8c8>
80009e4c:	40 4a       	lddsp	r10,sp[0x10]
80009e4e:	2e 48       	sub	r8,-28
80009e50:	10 0a       	add	r10,r8
80009e52:	50 4a       	stdsp	sp[0x10],r10
80009e54:	10 00       	add	r0,r8
80009e56:	10 05       	add	r5,r8
80009e58:	58 00       	cp.w	r0,0
80009e5a:	e0 8a 00 08 	brle	80009e6a <_dtoa_r+0x8da>
80009e5e:	06 9b       	mov	r11,r3
80009e60:	00 9a       	mov	r10,r0
80009e62:	0e 9c       	mov	r12,r7
80009e64:	e0 a0 07 58 	rcall	8000ad14 <__lshift>
80009e68:	18 93       	mov	r3,r12
80009e6a:	40 49       	lddsp	r9,sp[0x10]
80009e6c:	58 09       	cp.w	r9,0
80009e6e:	e0 8a 00 08 	brle	80009e7e <_dtoa_r+0x8ee>
80009e72:	04 9b       	mov	r11,r2
80009e74:	12 9a       	mov	r10,r9
80009e76:	0e 9c       	mov	r12,r7
80009e78:	e0 a0 07 4e 	rcall	8000ad14 <__lshift>
80009e7c:	18 92       	mov	r2,r12
80009e7e:	41 48       	lddsp	r8,sp[0x50]
80009e80:	58 08       	cp.w	r8,0
80009e82:	c1 b0       	breq	80009eb8 <_dtoa_r+0x928>
80009e84:	04 9b       	mov	r11,r2
80009e86:	06 9c       	mov	r12,r3
80009e88:	e0 a0 06 23 	rcall	8000aace <__mcmp>
80009e8c:	c1 64       	brge	80009eb8 <_dtoa_r+0x928>
80009e8e:	06 9b       	mov	r11,r3
80009e90:	30 09       	mov	r9,0
80009e92:	30 aa       	mov	r10,10
80009e94:	0e 9c       	mov	r12,r7
80009e96:	e0 a0 08 0b 	rcall	8000aeac <__multadd>
80009e9a:	20 16       	sub	r6,1
80009e9c:	18 93       	mov	r3,r12
80009e9e:	40 dc       	lddsp	r12,sp[0x34]
80009ea0:	58 0c       	cp.w	r12,0
80009ea2:	c0 31       	brne	80009ea8 <_dtoa_r+0x918>
80009ea4:	40 91       	lddsp	r1,sp[0x24]
80009ea6:	c0 98       	rjmp	80009eb8 <_dtoa_r+0x928>
80009ea8:	08 9b       	mov	r11,r4
80009eaa:	40 91       	lddsp	r1,sp[0x24]
80009eac:	30 09       	mov	r9,0
80009eae:	30 aa       	mov	r10,10
80009eb0:	0e 9c       	mov	r12,r7
80009eb2:	e0 a0 07 fd 	rcall	8000aeac <__multadd>
80009eb6:	18 94       	mov	r4,r12
80009eb8:	58 01       	cp.w	r1,0
80009eba:	5f a9       	srle	r9
80009ebc:	40 cb       	lddsp	r11,sp[0x30]
80009ebe:	58 2b       	cp.w	r11,2
80009ec0:	5f 98       	srgt	r8
80009ec2:	f3 e8 00 08 	and	r8,r9,r8
80009ec6:	c2 50       	breq	80009f10 <_dtoa_r+0x980>
80009ec8:	58 01       	cp.w	r1,0
80009eca:	c1 11       	brne	80009eec <_dtoa_r+0x95c>
80009ecc:	04 9b       	mov	r11,r2
80009ece:	02 99       	mov	r9,r1
80009ed0:	30 5a       	mov	r10,5
80009ed2:	0e 9c       	mov	r12,r7
80009ed4:	e0 a0 07 ec 	rcall	8000aeac <__multadd>
80009ed8:	18 92       	mov	r2,r12
80009eda:	18 9b       	mov	r11,r12
80009edc:	06 9c       	mov	r12,r3
80009ede:	e0 a0 05 f8 	rcall	8000aace <__mcmp>
80009ee2:	e0 89 00 0f 	brgt	80009f00 <_dtoa_r+0x970>
80009ee6:	c0 38       	rjmp	80009eec <_dtoa_r+0x95c>
80009ee8:	30 02       	mov	r2,0
80009eea:	04 94       	mov	r4,r2
80009eec:	40 ea       	lddsp	r10,sp[0x38]
80009eee:	30 09       	mov	r9,0
80009ef0:	5c da       	com	r10
80009ef2:	40 85       	lddsp	r5,sp[0x20]
80009ef4:	50 6a       	stdsp	sp[0x18],r10
80009ef6:	50 49       	stdsp	sp[0x10],r9
80009ef8:	c0 f9       	rjmp	8000a116 <_dtoa_r+0xb86>
80009efa:	08 92       	mov	r2,r4
80009efc:	40 66       	lddsp	r6,sp[0x18]
80009efe:	04 94       	mov	r4,r2
80009f00:	2f f6       	sub	r6,-1
80009f02:	50 66       	stdsp	sp[0x18],r6
80009f04:	33 18       	mov	r8,49
80009f06:	40 85       	lddsp	r5,sp[0x20]
80009f08:	0a c8       	st.b	r5++,r8
80009f0a:	30 08       	mov	r8,0
80009f0c:	50 48       	stdsp	sp[0x10],r8
80009f0e:	c0 49       	rjmp	8000a116 <_dtoa_r+0xb86>
80009f10:	40 dc       	lddsp	r12,sp[0x34]
80009f12:	58 0c       	cp.w	r12,0
80009f14:	e0 80 00 b5 	breq	8000a07e <_dtoa_r+0xaee>
80009f18:	58 05       	cp.w	r5,0
80009f1a:	e0 8a 00 08 	brle	80009f2a <_dtoa_r+0x99a>
80009f1e:	08 9b       	mov	r11,r4
80009f20:	0a 9a       	mov	r10,r5
80009f22:	0e 9c       	mov	r12,r7
80009f24:	e0 a0 06 f8 	rcall	8000ad14 <__lshift>
80009f28:	18 94       	mov	r4,r12
80009f2a:	40 6b       	lddsp	r11,sp[0x18]
80009f2c:	58 0b       	cp.w	r11,0
80009f2e:	c0 31       	brne	80009f34 <_dtoa_r+0x9a4>
80009f30:	08 9c       	mov	r12,r4
80009f32:	c1 38       	rjmp	80009f58 <_dtoa_r+0x9c8>
80009f34:	68 1b       	ld.w	r11,r4[0x4]
80009f36:	0e 9c       	mov	r12,r7
80009f38:	e0 a0 05 fe 	rcall	8000ab34 <_Balloc>
80009f3c:	68 4a       	ld.w	r10,r4[0x10]
80009f3e:	18 95       	mov	r5,r12
80009f40:	e8 cb ff f4 	sub	r11,r4,-12
80009f44:	2f ea       	sub	r10,-2
80009f46:	2f 4c       	sub	r12,-12
80009f48:	a3 6a       	lsl	r10,0x2
80009f4a:	fe b0 e6 43 	rcall	80006bd0 <memcpy>
80009f4e:	0a 9b       	mov	r11,r5
80009f50:	30 1a       	mov	r10,1
80009f52:	0e 9c       	mov	r12,r7
80009f54:	e0 a0 06 e0 	rcall	8000ad14 <__lshift>
80009f58:	50 44       	stdsp	sp[0x10],r4
80009f5a:	40 3a       	lddsp	r10,sp[0xc]
80009f5c:	30 19       	mov	r9,1
80009f5e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009f62:	18 94       	mov	r4,r12
80009f64:	50 da       	stdsp	sp[0x34],r10
80009f66:	40 85       	lddsp	r5,sp[0x20]
80009f68:	50 99       	stdsp	sp[0x24],r9
80009f6a:	50 26       	stdsp	sp[0x8],r6
80009f6c:	50 e1       	stdsp	sp[0x38],r1
80009f6e:	04 9b       	mov	r11,r2
80009f70:	06 9c       	mov	r12,r3
80009f72:	fe b0 fa 7f 	rcall	80009470 <quorem>
80009f76:	40 4b       	lddsp	r11,sp[0x10]
80009f78:	f8 c0 ff d0 	sub	r0,r12,-48
80009f7c:	06 9c       	mov	r12,r3
80009f7e:	e0 a0 05 a8 	rcall	8000aace <__mcmp>
80009f82:	08 9a       	mov	r10,r4
80009f84:	50 6c       	stdsp	sp[0x18],r12
80009f86:	04 9b       	mov	r11,r2
80009f88:	0e 9c       	mov	r12,r7
80009f8a:	e0 a0 06 5d 	rcall	8000ac44 <__mdiff>
80009f8e:	18 91       	mov	r1,r12
80009f90:	78 38       	ld.w	r8,r12[0xc]
80009f92:	58 08       	cp.w	r8,0
80009f94:	c0 30       	breq	80009f9a <_dtoa_r+0xa0a>
80009f96:	30 16       	mov	r6,1
80009f98:	c0 68       	rjmp	80009fa4 <_dtoa_r+0xa14>
80009f9a:	18 9b       	mov	r11,r12
80009f9c:	06 9c       	mov	r12,r3
80009f9e:	e0 a0 05 98 	rcall	8000aace <__mcmp>
80009fa2:	18 96       	mov	r6,r12
80009fa4:	0e 9c       	mov	r12,r7
80009fa6:	02 9b       	mov	r11,r1
80009fa8:	e0 a0 05 ac 	rcall	8000ab00 <_Bfree>
80009fac:	40 cc       	lddsp	r12,sp[0x30]
80009fae:	ed ec 10 08 	or	r8,r6,r12
80009fb2:	c0 d1       	brne	80009fcc <_dtoa_r+0xa3c>
80009fb4:	40 db       	lddsp	r11,sp[0x34]
80009fb6:	58 0b       	cp.w	r11,0
80009fb8:	c0 a1       	brne	80009fcc <_dtoa_r+0xa3c>
80009fba:	40 26       	lddsp	r6,sp[0x8]
80009fbc:	e0 40 00 39 	cp.w	r0,57
80009fc0:	c3 00       	breq	8000a020 <_dtoa_r+0xa90>
80009fc2:	40 6a       	lddsp	r10,sp[0x18]
80009fc4:	58 0a       	cp.w	r10,0
80009fc6:	e0 89 00 24 	brgt	8000a00e <_dtoa_r+0xa7e>
80009fca:	c2 f8       	rjmp	8000a028 <_dtoa_r+0xa98>
80009fcc:	40 69       	lddsp	r9,sp[0x18]
80009fce:	58 09       	cp.w	r9,0
80009fd0:	c0 85       	brlt	80009fe0 <_dtoa_r+0xa50>
80009fd2:	12 98       	mov	r8,r9
80009fd4:	40 cc       	lddsp	r12,sp[0x30]
80009fd6:	18 48       	or	r8,r12
80009fd8:	c1 d1       	brne	8000a012 <_dtoa_r+0xa82>
80009fda:	40 db       	lddsp	r11,sp[0x34]
80009fdc:	58 0b       	cp.w	r11,0
80009fde:	c1 a1       	brne	8000a012 <_dtoa_r+0xa82>
80009fe0:	0c 99       	mov	r9,r6
80009fe2:	40 26       	lddsp	r6,sp[0x8]
80009fe4:	58 09       	cp.w	r9,0
80009fe6:	e0 8a 00 21 	brle	8000a028 <_dtoa_r+0xa98>
80009fea:	06 9b       	mov	r11,r3
80009fec:	30 1a       	mov	r10,1
80009fee:	0e 9c       	mov	r12,r7
80009ff0:	e0 a0 06 92 	rcall	8000ad14 <__lshift>
80009ff4:	04 9b       	mov	r11,r2
80009ff6:	18 93       	mov	r3,r12
80009ff8:	e0 a0 05 6b 	rcall	8000aace <__mcmp>
80009ffc:	e0 89 00 06 	brgt	8000a008 <_dtoa_r+0xa78>
8000a000:	c1 41       	brne	8000a028 <_dtoa_r+0xa98>
8000a002:	ed b0 00 00 	bld	r0,0x0
8000a006:	c1 11       	brne	8000a028 <_dtoa_r+0xa98>
8000a008:	e0 40 00 39 	cp.w	r0,57
8000a00c:	c0 a0       	breq	8000a020 <_dtoa_r+0xa90>
8000a00e:	2f f0       	sub	r0,-1
8000a010:	c0 c8       	rjmp	8000a028 <_dtoa_r+0xa98>
8000a012:	58 06       	cp.w	r6,0
8000a014:	e0 8a 00 0c 	brle	8000a02c <_dtoa_r+0xa9c>
8000a018:	40 26       	lddsp	r6,sp[0x8]
8000a01a:	e0 40 00 39 	cp.w	r0,57
8000a01e:	c0 41       	brne	8000a026 <_dtoa_r+0xa96>
8000a020:	33 98       	mov	r8,57
8000a022:	0a c8       	st.b	r5++,r8
8000a024:	c6 78       	rjmp	8000a0f2 <_dtoa_r+0xb62>
8000a026:	2f f0       	sub	r0,-1
8000a028:	0a c0       	st.b	r5++,r0
8000a02a:	c7 58       	rjmp	8000a114 <_dtoa_r+0xb84>
8000a02c:	0a c0       	st.b	r5++,r0
8000a02e:	40 9a       	lddsp	r10,sp[0x24]
8000a030:	40 e9       	lddsp	r9,sp[0x38]
8000a032:	12 3a       	cp.w	r10,r9
8000a034:	c4 30       	breq	8000a0ba <_dtoa_r+0xb2a>
8000a036:	06 9b       	mov	r11,r3
8000a038:	30 09       	mov	r9,0
8000a03a:	30 aa       	mov	r10,10
8000a03c:	0e 9c       	mov	r12,r7
8000a03e:	e0 a0 07 37 	rcall	8000aeac <__multadd>
8000a042:	40 48       	lddsp	r8,sp[0x10]
8000a044:	18 93       	mov	r3,r12
8000a046:	08 38       	cp.w	r8,r4
8000a048:	c0 91       	brne	8000a05a <_dtoa_r+0xaca>
8000a04a:	10 9b       	mov	r11,r8
8000a04c:	30 09       	mov	r9,0
8000a04e:	30 aa       	mov	r10,10
8000a050:	0e 9c       	mov	r12,r7
8000a052:	e0 a0 07 2d 	rcall	8000aeac <__multadd>
8000a056:	50 4c       	stdsp	sp[0x10],r12
8000a058:	c0 e8       	rjmp	8000a074 <_dtoa_r+0xae4>
8000a05a:	40 4b       	lddsp	r11,sp[0x10]
8000a05c:	30 09       	mov	r9,0
8000a05e:	30 aa       	mov	r10,10
8000a060:	0e 9c       	mov	r12,r7
8000a062:	e0 a0 07 25 	rcall	8000aeac <__multadd>
8000a066:	08 9b       	mov	r11,r4
8000a068:	50 4c       	stdsp	sp[0x10],r12
8000a06a:	30 09       	mov	r9,0
8000a06c:	30 aa       	mov	r10,10
8000a06e:	0e 9c       	mov	r12,r7
8000a070:	e0 a0 07 1e 	rcall	8000aeac <__multadd>
8000a074:	18 94       	mov	r4,r12
8000a076:	40 9c       	lddsp	r12,sp[0x24]
8000a078:	2f fc       	sub	r12,-1
8000a07a:	50 9c       	stdsp	sp[0x24],r12
8000a07c:	c7 9b       	rjmp	80009f6e <_dtoa_r+0x9de>
8000a07e:	30 18       	mov	r8,1
8000a080:	06 90       	mov	r0,r3
8000a082:	40 85       	lddsp	r5,sp[0x20]
8000a084:	08 93       	mov	r3,r4
8000a086:	0c 94       	mov	r4,r6
8000a088:	10 96       	mov	r6,r8
8000a08a:	04 9b       	mov	r11,r2
8000a08c:	00 9c       	mov	r12,r0
8000a08e:	fe b0 f9 f1 	rcall	80009470 <quorem>
8000a092:	2d 0c       	sub	r12,-48
8000a094:	0a cc       	st.b	r5++,r12
8000a096:	02 36       	cp.w	r6,r1
8000a098:	c0 a4       	brge	8000a0ac <_dtoa_r+0xb1c>
8000a09a:	00 9b       	mov	r11,r0
8000a09c:	30 09       	mov	r9,0
8000a09e:	30 aa       	mov	r10,10
8000a0a0:	0e 9c       	mov	r12,r7
8000a0a2:	2f f6       	sub	r6,-1
8000a0a4:	e0 a0 07 04 	rcall	8000aeac <__multadd>
8000a0a8:	18 90       	mov	r0,r12
8000a0aa:	cf 0b       	rjmp	8000a08a <_dtoa_r+0xafa>
8000a0ac:	08 96       	mov	r6,r4
8000a0ae:	30 0b       	mov	r11,0
8000a0b0:	06 94       	mov	r4,r3
8000a0b2:	50 4b       	stdsp	sp[0x10],r11
8000a0b4:	00 93       	mov	r3,r0
8000a0b6:	18 90       	mov	r0,r12
8000a0b8:	c0 28       	rjmp	8000a0bc <_dtoa_r+0xb2c>
8000a0ba:	40 26       	lddsp	r6,sp[0x8]
8000a0bc:	06 9b       	mov	r11,r3
8000a0be:	30 1a       	mov	r10,1
8000a0c0:	0e 9c       	mov	r12,r7
8000a0c2:	e0 a0 06 29 	rcall	8000ad14 <__lshift>
8000a0c6:	04 9b       	mov	r11,r2
8000a0c8:	18 93       	mov	r3,r12
8000a0ca:	e0 a0 05 02 	rcall	8000aace <__mcmp>
8000a0ce:	e0 89 00 12 	brgt	8000a0f2 <_dtoa_r+0xb62>
8000a0d2:	c1 b1       	brne	8000a108 <_dtoa_r+0xb78>
8000a0d4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a0d8:	c0 d1       	brne	8000a0f2 <_dtoa_r+0xb62>
8000a0da:	c1 78       	rjmp	8000a108 <_dtoa_r+0xb78>
8000a0dc:	40 89       	lddsp	r9,sp[0x20]
8000a0de:	12 38       	cp.w	r8,r9
8000a0e0:	c0 30       	breq	8000a0e6 <_dtoa_r+0xb56>
8000a0e2:	10 95       	mov	r5,r8
8000a0e4:	c0 88       	rjmp	8000a0f4 <_dtoa_r+0xb64>
8000a0e6:	2f f6       	sub	r6,-1
8000a0e8:	50 66       	stdsp	sp[0x18],r6
8000a0ea:	33 18       	mov	r8,49
8000a0ec:	40 8c       	lddsp	r12,sp[0x20]
8000a0ee:	b8 88       	st.b	r12[0x0],r8
8000a0f0:	c1 38       	rjmp	8000a116 <_dtoa_r+0xb86>
8000a0f2:	33 9a       	mov	r10,57
8000a0f4:	0a 98       	mov	r8,r5
8000a0f6:	11 79       	ld.ub	r9,--r8
8000a0f8:	f4 09 18 00 	cp.b	r9,r10
8000a0fc:	cf 00       	breq	8000a0dc <_dtoa_r+0xb4c>
8000a0fe:	2f f9       	sub	r9,-1
8000a100:	b0 89       	st.b	r8[0x0],r9
8000a102:	c0 98       	rjmp	8000a114 <_dtoa_r+0xb84>
8000a104:	10 95       	mov	r5,r8
8000a106:	c0 28       	rjmp	8000a10a <_dtoa_r+0xb7a>
8000a108:	33 09       	mov	r9,48
8000a10a:	0a 98       	mov	r8,r5
8000a10c:	11 7a       	ld.ub	r10,--r8
8000a10e:	f2 0a 18 00 	cp.b	r10,r9
8000a112:	cf 90       	breq	8000a104 <_dtoa_r+0xb74>
8000a114:	50 66       	stdsp	sp[0x18],r6
8000a116:	04 9b       	mov	r11,r2
8000a118:	0e 9c       	mov	r12,r7
8000a11a:	e0 a0 04 f3 	rcall	8000ab00 <_Bfree>
8000a11e:	58 04       	cp.w	r4,0
8000a120:	c1 20       	breq	8000a144 <_dtoa_r+0xbb4>
8000a122:	40 4b       	lddsp	r11,sp[0x10]
8000a124:	08 3b       	cp.w	r11,r4
8000a126:	5f 19       	srne	r9
8000a128:	58 0b       	cp.w	r11,0
8000a12a:	5f 18       	srne	r8
8000a12c:	f3 e8 00 08 	and	r8,r9,r8
8000a130:	c0 40       	breq	8000a138 <_dtoa_r+0xba8>
8000a132:	0e 9c       	mov	r12,r7
8000a134:	e0 a0 04 e6 	rcall	8000ab00 <_Bfree>
8000a138:	08 9b       	mov	r11,r4
8000a13a:	0e 9c       	mov	r12,r7
8000a13c:	e0 a0 04 e2 	rcall	8000ab00 <_Bfree>
8000a140:	c0 28       	rjmp	8000a144 <_dtoa_r+0xbb4>
8000a142:	50 66       	stdsp	sp[0x18],r6
8000a144:	0e 9c       	mov	r12,r7
8000a146:	06 9b       	mov	r11,r3
8000a148:	e0 a0 04 dc 	rcall	8000ab00 <_Bfree>
8000a14c:	30 08       	mov	r8,0
8000a14e:	aa 88       	st.b	r5[0x0],r8
8000a150:	40 68       	lddsp	r8,sp[0x18]
8000a152:	41 5a       	lddsp	r10,sp[0x54]
8000a154:	2f f8       	sub	r8,-1
8000a156:	41 29       	lddsp	r9,sp[0x48]
8000a158:	95 08       	st.w	r10[0x0],r8
8000a15a:	40 8c       	lddsp	r12,sp[0x20]
8000a15c:	58 09       	cp.w	r9,0
8000a15e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a162:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a166:	2e 6d       	sub	sp,-104
8000a168:	d8 32       	popm	r0-r7,pc
8000a16a:	d7 03       	nop

8000a16c <__errno>:
8000a16c:	e0 68 0a 30 	mov	r8,2608
8000a170:	70 0c       	ld.w	r12,r8[0x0]
8000a172:	2f 4c       	sub	r12,-12
8000a174:	5e fc       	retal	r12
8000a176:	d7 03       	nop

8000a178 <_fflush_r>:
8000a178:	d4 21       	pushm	r4-r7,lr
8000a17a:	16 97       	mov	r7,r11
8000a17c:	18 96       	mov	r6,r12
8000a17e:	76 48       	ld.w	r8,r11[0x10]
8000a180:	58 08       	cp.w	r8,0
8000a182:	c7 f0       	breq	8000a280 <_fflush_r+0x108>
8000a184:	58 0c       	cp.w	r12,0
8000a186:	c0 50       	breq	8000a190 <_fflush_r+0x18>
8000a188:	78 68       	ld.w	r8,r12[0x18]
8000a18a:	58 08       	cp.w	r8,0
8000a18c:	c0 21       	brne	8000a190 <_fflush_r+0x18>
8000a18e:	cc dc       	rcall	8000a328 <__sinit>
8000a190:	fe c8 cd f8 	sub	r8,pc,-12808
8000a194:	10 37       	cp.w	r7,r8
8000a196:	c0 31       	brne	8000a19c <_fflush_r+0x24>
8000a198:	6c 07       	ld.w	r7,r6[0x0]
8000a19a:	c0 c8       	rjmp	8000a1b2 <_fflush_r+0x3a>
8000a19c:	fe c8 cd e4 	sub	r8,pc,-12828
8000a1a0:	10 37       	cp.w	r7,r8
8000a1a2:	c0 31       	brne	8000a1a8 <_fflush_r+0x30>
8000a1a4:	6c 17       	ld.w	r7,r6[0x4]
8000a1a6:	c0 68       	rjmp	8000a1b2 <_fflush_r+0x3a>
8000a1a8:	fe c8 cd d0 	sub	r8,pc,-12848
8000a1ac:	10 37       	cp.w	r7,r8
8000a1ae:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a1b2:	8e 6a       	ld.sh	r10,r7[0xc]
8000a1b4:	14 98       	mov	r8,r10
8000a1b6:	ed ba 00 03 	bld	r10,0x3
8000a1ba:	c4 20       	breq	8000a23e <_fflush_r+0xc6>
8000a1bc:	ab ba       	sbr	r10,0xb
8000a1be:	ae 6a       	st.h	r7[0xc],r10
8000a1c0:	6e 18       	ld.w	r8,r7[0x4]
8000a1c2:	58 08       	cp.w	r8,0
8000a1c4:	e0 89 00 06 	brgt	8000a1d0 <_fflush_r+0x58>
8000a1c8:	6f 08       	ld.w	r8,r7[0x40]
8000a1ca:	58 08       	cp.w	r8,0
8000a1cc:	e0 8a 00 5a 	brle	8000a280 <_fflush_r+0x108>
8000a1d0:	6e b8       	ld.w	r8,r7[0x2c]
8000a1d2:	58 08       	cp.w	r8,0
8000a1d4:	c5 60       	breq	8000a280 <_fflush_r+0x108>
8000a1d6:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a1da:	c0 30       	breq	8000a1e0 <_fflush_r+0x68>
8000a1dc:	6f 55       	ld.w	r5,r7[0x54]
8000a1de:	c0 f8       	rjmp	8000a1fc <_fflush_r+0x84>
8000a1e0:	30 19       	mov	r9,1
8000a1e2:	6e 8b       	ld.w	r11,r7[0x20]
8000a1e4:	0c 9c       	mov	r12,r6
8000a1e6:	5d 18       	icall	r8
8000a1e8:	18 95       	mov	r5,r12
8000a1ea:	5b fc       	cp.w	r12,-1
8000a1ec:	c0 81       	brne	8000a1fc <_fflush_r+0x84>
8000a1ee:	6c 38       	ld.w	r8,r6[0xc]
8000a1f0:	59 d8       	cp.w	r8,29
8000a1f2:	c4 70       	breq	8000a280 <_fflush_r+0x108>
8000a1f4:	8e 68       	ld.sh	r8,r7[0xc]
8000a1f6:	a7 a8       	sbr	r8,0x6
8000a1f8:	ae 68       	st.h	r7[0xc],r8
8000a1fa:	d8 22       	popm	r4-r7,pc
8000a1fc:	8e 68       	ld.sh	r8,r7[0xc]
8000a1fe:	ed b8 00 02 	bld	r8,0x2
8000a202:	c0 91       	brne	8000a214 <_fflush_r+0x9c>
8000a204:	6e 18       	ld.w	r8,r7[0x4]
8000a206:	10 15       	sub	r5,r8
8000a208:	6e d8       	ld.w	r8,r7[0x34]
8000a20a:	58 08       	cp.w	r8,0
8000a20c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a210:	eb d8 e1 15 	subne	r5,r5,r8
8000a214:	6e b8       	ld.w	r8,r7[0x2c]
8000a216:	0c 9c       	mov	r12,r6
8000a218:	30 09       	mov	r9,0
8000a21a:	0a 9a       	mov	r10,r5
8000a21c:	6e 8b       	ld.w	r11,r7[0x20]
8000a21e:	5d 18       	icall	r8
8000a220:	8e 68       	ld.sh	r8,r7[0xc]
8000a222:	0a 3c       	cp.w	r12,r5
8000a224:	c2 61       	brne	8000a270 <_fflush_r+0xf8>
8000a226:	ab d8       	cbr	r8,0xb
8000a228:	30 0c       	mov	r12,0
8000a22a:	6e 49       	ld.w	r9,r7[0x10]
8000a22c:	ae 68       	st.h	r7[0xc],r8
8000a22e:	8f 1c       	st.w	r7[0x4],r12
8000a230:	8f 09       	st.w	r7[0x0],r9
8000a232:	ed b8 00 0c 	bld	r8,0xc
8000a236:	c2 51       	brne	8000a280 <_fflush_r+0x108>
8000a238:	ef 45 00 54 	st.w	r7[84],r5
8000a23c:	d8 22       	popm	r4-r7,pc
8000a23e:	6e 45       	ld.w	r5,r7[0x10]
8000a240:	58 05       	cp.w	r5,0
8000a242:	c1 f0       	breq	8000a280 <_fflush_r+0x108>
8000a244:	6e 04       	ld.w	r4,r7[0x0]
8000a246:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a24a:	8f 05       	st.w	r7[0x0],r5
8000a24c:	f9 b8 01 00 	movne	r8,0
8000a250:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a254:	0a 14       	sub	r4,r5
8000a256:	8f 28       	st.w	r7[0x8],r8
8000a258:	c1 18       	rjmp	8000a27a <_fflush_r+0x102>
8000a25a:	08 99       	mov	r9,r4
8000a25c:	0a 9a       	mov	r10,r5
8000a25e:	6e a8       	ld.w	r8,r7[0x28]
8000a260:	6e 8b       	ld.w	r11,r7[0x20]
8000a262:	0c 9c       	mov	r12,r6
8000a264:	5d 18       	icall	r8
8000a266:	18 14       	sub	r4,r12
8000a268:	58 0c       	cp.w	r12,0
8000a26a:	e0 89 00 07 	brgt	8000a278 <_fflush_r+0x100>
8000a26e:	8e 68       	ld.sh	r8,r7[0xc]
8000a270:	a7 a8       	sbr	r8,0x6
8000a272:	3f fc       	mov	r12,-1
8000a274:	ae 68       	st.h	r7[0xc],r8
8000a276:	d8 22       	popm	r4-r7,pc
8000a278:	18 05       	add	r5,r12
8000a27a:	58 04       	cp.w	r4,0
8000a27c:	fe 99 ff ef 	brgt	8000a25a <_fflush_r+0xe2>
8000a280:	d8 2a       	popm	r4-r7,pc,r12=0
8000a282:	d7 03       	nop

8000a284 <__sfp_lock_acquire>:
8000a284:	5e fc       	retal	r12

8000a286 <__sfp_lock_release>:
8000a286:	5e fc       	retal	r12

8000a288 <_cleanup_r>:
8000a288:	d4 01       	pushm	lr
8000a28a:	fe cb f0 c6 	sub	r11,pc,-3898
8000a28e:	e0 a0 02 f7 	rcall	8000a87c <_fwalk>
8000a292:	d8 02       	popm	pc

8000a294 <__sfmoreglue>:
8000a294:	d4 21       	pushm	r4-r7,lr
8000a296:	16 95       	mov	r5,r11
8000a298:	f6 06 10 5c 	mul	r6,r11,92
8000a29c:	ec cb ff f4 	sub	r11,r6,-12
8000a2a0:	fe b0 e2 7c 	rcall	80006798 <_malloc_r>
8000a2a4:	18 97       	mov	r7,r12
8000a2a6:	c0 90       	breq	8000a2b8 <__sfmoreglue+0x24>
8000a2a8:	99 15       	st.w	r12[0x4],r5
8000a2aa:	30 0b       	mov	r11,0
8000a2ac:	2f 4c       	sub	r12,-12
8000a2ae:	0c 9a       	mov	r10,r6
8000a2b0:	8f 2c       	st.w	r7[0x8],r12
8000a2b2:	8f 0b       	st.w	r7[0x0],r11
8000a2b4:	fe b0 e5 32 	rcall	80006d18 <memset>
8000a2b8:	0e 9c       	mov	r12,r7
8000a2ba:	d8 22       	popm	r4-r7,pc

8000a2bc <__sfp>:
8000a2bc:	d4 21       	pushm	r4-r7,lr
8000a2be:	fe c8 ce c2 	sub	r8,pc,-12606
8000a2c2:	18 96       	mov	r6,r12
8000a2c4:	70 07       	ld.w	r7,r8[0x0]
8000a2c6:	6e 68       	ld.w	r8,r7[0x18]
8000a2c8:	58 08       	cp.w	r8,0
8000a2ca:	c0 31       	brne	8000a2d0 <__sfp+0x14>
8000a2cc:	0e 9c       	mov	r12,r7
8000a2ce:	c2 dc       	rcall	8000a328 <__sinit>
8000a2d0:	ee c7 ff 28 	sub	r7,r7,-216
8000a2d4:	30 05       	mov	r5,0
8000a2d6:	6e 2c       	ld.w	r12,r7[0x8]
8000a2d8:	6e 18       	ld.w	r8,r7[0x4]
8000a2da:	c0 68       	rjmp	8000a2e6 <__sfp+0x2a>
8000a2dc:	98 69       	ld.sh	r9,r12[0xc]
8000a2de:	ea 09 19 00 	cp.h	r9,r5
8000a2e2:	c1 10       	breq	8000a304 <__sfp+0x48>
8000a2e4:	2a 4c       	sub	r12,-92
8000a2e6:	20 18       	sub	r8,1
8000a2e8:	cf a7       	brpl	8000a2dc <__sfp+0x20>
8000a2ea:	6e 08       	ld.w	r8,r7[0x0]
8000a2ec:	58 08       	cp.w	r8,0
8000a2ee:	c0 61       	brne	8000a2fa <__sfp+0x3e>
8000a2f0:	30 4b       	mov	r11,4
8000a2f2:	0c 9c       	mov	r12,r6
8000a2f4:	cd 0f       	rcall	8000a294 <__sfmoreglue>
8000a2f6:	8f 0c       	st.w	r7[0x0],r12
8000a2f8:	c0 30       	breq	8000a2fe <__sfp+0x42>
8000a2fa:	6e 07       	ld.w	r7,r7[0x0]
8000a2fc:	ce db       	rjmp	8000a2d6 <__sfp+0x1a>
8000a2fe:	30 c8       	mov	r8,12
8000a300:	8d 38       	st.w	r6[0xc],r8
8000a302:	d8 22       	popm	r4-r7,pc
8000a304:	30 08       	mov	r8,0
8000a306:	f9 48 00 4c 	st.w	r12[76],r8
8000a30a:	99 08       	st.w	r12[0x0],r8
8000a30c:	99 28       	st.w	r12[0x8],r8
8000a30e:	99 18       	st.w	r12[0x4],r8
8000a310:	99 48       	st.w	r12[0x10],r8
8000a312:	99 58       	st.w	r12[0x14],r8
8000a314:	99 68       	st.w	r12[0x18],r8
8000a316:	99 d8       	st.w	r12[0x34],r8
8000a318:	99 e8       	st.w	r12[0x38],r8
8000a31a:	f9 48 00 48 	st.w	r12[72],r8
8000a31e:	3f f8       	mov	r8,-1
8000a320:	b8 78       	st.h	r12[0xe],r8
8000a322:	30 18       	mov	r8,1
8000a324:	b8 68       	st.h	r12[0xc],r8
8000a326:	d8 22       	popm	r4-r7,pc

8000a328 <__sinit>:
8000a328:	d4 21       	pushm	r4-r7,lr
8000a32a:	18 96       	mov	r6,r12
8000a32c:	78 67       	ld.w	r7,r12[0x18]
8000a32e:	58 07       	cp.w	r7,0
8000a330:	c4 91       	brne	8000a3c2 <__sinit+0x9a>
8000a332:	fe c8 00 aa 	sub	r8,pc,170
8000a336:	30 15       	mov	r5,1
8000a338:	99 a8       	st.w	r12[0x28],r8
8000a33a:	f9 47 00 d8 	st.w	r12[216],r7
8000a33e:	f9 47 00 dc 	st.w	r12[220],r7
8000a342:	f9 47 00 e0 	st.w	r12[224],r7
8000a346:	99 65       	st.w	r12[0x18],r5
8000a348:	cb af       	rcall	8000a2bc <__sfp>
8000a34a:	8d 0c       	st.w	r6[0x0],r12
8000a34c:	0c 9c       	mov	r12,r6
8000a34e:	cb 7f       	rcall	8000a2bc <__sfp>
8000a350:	8d 1c       	st.w	r6[0x4],r12
8000a352:	0c 9c       	mov	r12,r6
8000a354:	cb 4f       	rcall	8000a2bc <__sfp>
8000a356:	6c 09       	ld.w	r9,r6[0x0]
8000a358:	30 48       	mov	r8,4
8000a35a:	93 07       	st.w	r9[0x0],r7
8000a35c:	b2 68       	st.h	r9[0xc],r8
8000a35e:	93 17       	st.w	r9[0x4],r7
8000a360:	93 27       	st.w	r9[0x8],r7
8000a362:	6c 18       	ld.w	r8,r6[0x4]
8000a364:	b2 77       	st.h	r9[0xe],r7
8000a366:	93 47       	st.w	r9[0x10],r7
8000a368:	93 57       	st.w	r9[0x14],r7
8000a36a:	93 67       	st.w	r9[0x18],r7
8000a36c:	93 89       	st.w	r9[0x20],r9
8000a36e:	91 07       	st.w	r8[0x0],r7
8000a370:	91 17       	st.w	r8[0x4],r7
8000a372:	91 27       	st.w	r8[0x8],r7
8000a374:	fe ce f3 24 	sub	lr,pc,-3292
8000a378:	fe cb f3 54 	sub	r11,pc,-3244
8000a37c:	93 9e       	st.w	r9[0x24],lr
8000a37e:	93 ab       	st.w	r9[0x28],r11
8000a380:	fe ca f3 7c 	sub	r10,pc,-3204
8000a384:	fe c4 f3 88 	sub	r4,pc,-3192
8000a388:	93 ba       	st.w	r9[0x2c],r10
8000a38a:	93 c4       	st.w	r9[0x30],r4
8000a38c:	30 99       	mov	r9,9
8000a38e:	b0 69       	st.h	r8[0xc],r9
8000a390:	b0 75       	st.h	r8[0xe],r5
8000a392:	91 c4       	st.w	r8[0x30],r4
8000a394:	91 47       	st.w	r8[0x10],r7
8000a396:	91 57       	st.w	r8[0x14],r7
8000a398:	91 67       	st.w	r8[0x18],r7
8000a39a:	91 88       	st.w	r8[0x20],r8
8000a39c:	91 9e       	st.w	r8[0x24],lr
8000a39e:	91 ab       	st.w	r8[0x28],r11
8000a3a0:	91 ba       	st.w	r8[0x2c],r10
8000a3a2:	8d 2c       	st.w	r6[0x8],r12
8000a3a4:	31 28       	mov	r8,18
8000a3a6:	99 07       	st.w	r12[0x0],r7
8000a3a8:	b8 68       	st.h	r12[0xc],r8
8000a3aa:	99 17       	st.w	r12[0x4],r7
8000a3ac:	99 27       	st.w	r12[0x8],r7
8000a3ae:	30 28       	mov	r8,2
8000a3b0:	b8 78       	st.h	r12[0xe],r8
8000a3b2:	99 c4       	st.w	r12[0x30],r4
8000a3b4:	99 67       	st.w	r12[0x18],r7
8000a3b6:	99 9e       	st.w	r12[0x24],lr
8000a3b8:	99 ab       	st.w	r12[0x28],r11
8000a3ba:	99 ba       	st.w	r12[0x2c],r10
8000a3bc:	99 47       	st.w	r12[0x10],r7
8000a3be:	99 57       	st.w	r12[0x14],r7
8000a3c0:	99 8c       	st.w	r12[0x20],r12
8000a3c2:	d8 22       	popm	r4-r7,pc

8000a3c4 <_malloc_trim_r>:
8000a3c4:	d4 21       	pushm	r4-r7,lr
8000a3c6:	16 95       	mov	r5,r11
8000a3c8:	18 97       	mov	r7,r12
8000a3ca:	fe b0 d7 53 	rcall	80005270 <__malloc_lock>
8000a3ce:	e0 64 05 30 	mov	r4,1328
8000a3d2:	68 28       	ld.w	r8,r4[0x8]
8000a3d4:	70 16       	ld.w	r6,r8[0x4]
8000a3d6:	e0 16 ff fc 	andl	r6,0xfffc
8000a3da:	ec c8 ff 91 	sub	r8,r6,-111
8000a3de:	f0 05 01 05 	sub	r5,r8,r5
8000a3e2:	e0 15 ff 80 	andl	r5,0xff80
8000a3e6:	ea c5 00 80 	sub	r5,r5,128
8000a3ea:	e0 45 00 7f 	cp.w	r5,127
8000a3ee:	e0 8a 00 25 	brle	8000a438 <_malloc_trim_r+0x74>
8000a3f2:	30 0b       	mov	r11,0
8000a3f4:	0e 9c       	mov	r12,r7
8000a3f6:	fe b0 e5 f9 	rcall	80006fe8 <_sbrk_r>
8000a3fa:	68 28       	ld.w	r8,r4[0x8]
8000a3fc:	0c 08       	add	r8,r6
8000a3fe:	10 3c       	cp.w	r12,r8
8000a400:	c1 c1       	brne	8000a438 <_malloc_trim_r+0x74>
8000a402:	ea 0b 11 00 	rsub	r11,r5,0
8000a406:	0e 9c       	mov	r12,r7
8000a408:	fe b0 e5 f0 	rcall	80006fe8 <_sbrk_r>
8000a40c:	5b fc       	cp.w	r12,-1
8000a40e:	c1 91       	brne	8000a440 <_malloc_trim_r+0x7c>
8000a410:	30 0b       	mov	r11,0
8000a412:	0e 9c       	mov	r12,r7
8000a414:	fe b0 e5 ea 	rcall	80006fe8 <_sbrk_r>
8000a418:	68 28       	ld.w	r8,r4[0x8]
8000a41a:	f8 08 01 09 	sub	r9,r12,r8
8000a41e:	58 f9       	cp.w	r9,15
8000a420:	e0 8a 00 0c 	brle	8000a438 <_malloc_trim_r+0x74>
8000a424:	a1 a9       	sbr	r9,0x0
8000a426:	91 19       	st.w	r8[0x4],r9
8000a428:	e0 68 09 3c 	mov	r8,2364
8000a42c:	70 09       	ld.w	r9,r8[0x0]
8000a42e:	e0 68 0d 6c 	mov	r8,3436
8000a432:	f8 09 01 09 	sub	r9,r12,r9
8000a436:	91 09       	st.w	r8[0x0],r9
8000a438:	0e 9c       	mov	r12,r7
8000a43a:	fe b0 d7 21 	rcall	8000527c <__malloc_unlock>
8000a43e:	d8 2a       	popm	r4-r7,pc,r12=0
8000a440:	68 28       	ld.w	r8,r4[0x8]
8000a442:	0a 16       	sub	r6,r5
8000a444:	a1 a6       	sbr	r6,0x0
8000a446:	91 16       	st.w	r8[0x4],r6
8000a448:	e0 68 0d 6c 	mov	r8,3436
8000a44c:	70 09       	ld.w	r9,r8[0x0]
8000a44e:	0a 19       	sub	r9,r5
8000a450:	0e 9c       	mov	r12,r7
8000a452:	91 09       	st.w	r8[0x0],r9
8000a454:	fe b0 d7 14 	rcall	8000527c <__malloc_unlock>
8000a458:	da 2a       	popm	r4-r7,pc,r12=1
8000a45a:	d7 03       	nop

8000a45c <_free_r>:
8000a45c:	d4 21       	pushm	r4-r7,lr
8000a45e:	16 96       	mov	r6,r11
8000a460:	18 97       	mov	r7,r12
8000a462:	58 0b       	cp.w	r11,0
8000a464:	e0 80 00 c0 	breq	8000a5e4 <_free_r+0x188>
8000a468:	fe b0 d7 04 	rcall	80005270 <__malloc_lock>
8000a46c:	20 86       	sub	r6,8
8000a46e:	e0 6a 05 30 	mov	r10,1328
8000a472:	6c 18       	ld.w	r8,r6[0x4]
8000a474:	74 2e       	ld.w	lr,r10[0x8]
8000a476:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a47a:	a1 c8       	cbr	r8,0x0
8000a47c:	ec 08 00 09 	add	r9,r6,r8
8000a480:	72 1b       	ld.w	r11,r9[0x4]
8000a482:	e0 1b ff fc 	andl	r11,0xfffc
8000a486:	1c 39       	cp.w	r9,lr
8000a488:	c1 e1       	brne	8000a4c4 <_free_r+0x68>
8000a48a:	f6 08 00 08 	add	r8,r11,r8
8000a48e:	58 0c       	cp.w	r12,0
8000a490:	c0 81       	brne	8000a4a0 <_free_r+0x44>
8000a492:	6c 09       	ld.w	r9,r6[0x0]
8000a494:	12 16       	sub	r6,r9
8000a496:	12 08       	add	r8,r9
8000a498:	6c 3b       	ld.w	r11,r6[0xc]
8000a49a:	6c 29       	ld.w	r9,r6[0x8]
8000a49c:	97 29       	st.w	r11[0x8],r9
8000a49e:	93 3b       	st.w	r9[0xc],r11
8000a4a0:	10 99       	mov	r9,r8
8000a4a2:	95 26       	st.w	r10[0x8],r6
8000a4a4:	a1 a9       	sbr	r9,0x0
8000a4a6:	8d 19       	st.w	r6[0x4],r9
8000a4a8:	e0 69 09 38 	mov	r9,2360
8000a4ac:	72 09       	ld.w	r9,r9[0x0]
8000a4ae:	12 38       	cp.w	r8,r9
8000a4b0:	c0 63       	brcs	8000a4bc <_free_r+0x60>
8000a4b2:	e0 68 0d 68 	mov	r8,3432
8000a4b6:	0e 9c       	mov	r12,r7
8000a4b8:	70 0b       	ld.w	r11,r8[0x0]
8000a4ba:	c8 5f       	rcall	8000a3c4 <_malloc_trim_r>
8000a4bc:	0e 9c       	mov	r12,r7
8000a4be:	fe b0 d6 df 	rcall	8000527c <__malloc_unlock>
8000a4c2:	d8 22       	popm	r4-r7,pc
8000a4c4:	93 1b       	st.w	r9[0x4],r11
8000a4c6:	58 0c       	cp.w	r12,0
8000a4c8:	c0 30       	breq	8000a4ce <_free_r+0x72>
8000a4ca:	30 0c       	mov	r12,0
8000a4cc:	c1 08       	rjmp	8000a4ec <_free_r+0x90>
8000a4ce:	6c 0e       	ld.w	lr,r6[0x0]
8000a4d0:	f4 c5 ff f8 	sub	r5,r10,-8
8000a4d4:	1c 16       	sub	r6,lr
8000a4d6:	1c 08       	add	r8,lr
8000a4d8:	6c 2e       	ld.w	lr,r6[0x8]
8000a4da:	0a 3e       	cp.w	lr,r5
8000a4dc:	f9 bc 00 01 	moveq	r12,1
8000a4e0:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a4e4:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a4e8:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a4ec:	f2 0b 00 0e 	add	lr,r9,r11
8000a4f0:	7c 1e       	ld.w	lr,lr[0x4]
8000a4f2:	ed be 00 00 	bld	lr,0x0
8000a4f6:	c1 40       	breq	8000a51e <_free_r+0xc2>
8000a4f8:	16 08       	add	r8,r11
8000a4fa:	58 0c       	cp.w	r12,0
8000a4fc:	c0 d1       	brne	8000a516 <_free_r+0xba>
8000a4fe:	e0 6e 05 30 	mov	lr,1328
8000a502:	72 2b       	ld.w	r11,r9[0x8]
8000a504:	2f 8e       	sub	lr,-8
8000a506:	1c 3b       	cp.w	r11,lr
8000a508:	c0 71       	brne	8000a516 <_free_r+0xba>
8000a50a:	97 36       	st.w	r11[0xc],r6
8000a50c:	97 26       	st.w	r11[0x8],r6
8000a50e:	8d 2b       	st.w	r6[0x8],r11
8000a510:	8d 3b       	st.w	r6[0xc],r11
8000a512:	30 1c       	mov	r12,1
8000a514:	c0 58       	rjmp	8000a51e <_free_r+0xc2>
8000a516:	72 2b       	ld.w	r11,r9[0x8]
8000a518:	72 39       	ld.w	r9,r9[0xc]
8000a51a:	93 2b       	st.w	r9[0x8],r11
8000a51c:	97 39       	st.w	r11[0xc],r9
8000a51e:	10 99       	mov	r9,r8
8000a520:	ec 08 09 08 	st.w	r6[r8],r8
8000a524:	a1 a9       	sbr	r9,0x0
8000a526:	8d 19       	st.w	r6[0x4],r9
8000a528:	58 0c       	cp.w	r12,0
8000a52a:	c5 a1       	brne	8000a5de <_free_r+0x182>
8000a52c:	e0 48 01 ff 	cp.w	r8,511
8000a530:	e0 8b 00 13 	brhi	8000a556 <_free_r+0xfa>
8000a534:	a3 98       	lsr	r8,0x3
8000a536:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a53a:	72 2b       	ld.w	r11,r9[0x8]
8000a53c:	8d 39       	st.w	r6[0xc],r9
8000a53e:	8d 2b       	st.w	r6[0x8],r11
8000a540:	97 36       	st.w	r11[0xc],r6
8000a542:	93 26       	st.w	r9[0x8],r6
8000a544:	a3 48       	asr	r8,0x2
8000a546:	74 19       	ld.w	r9,r10[0x4]
8000a548:	30 1b       	mov	r11,1
8000a54a:	f6 08 09 48 	lsl	r8,r11,r8
8000a54e:	f3 e8 10 08 	or	r8,r9,r8
8000a552:	95 18       	st.w	r10[0x4],r8
8000a554:	c4 58       	rjmp	8000a5de <_free_r+0x182>
8000a556:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a55a:	58 4b       	cp.w	r11,4
8000a55c:	e0 8b 00 06 	brhi	8000a568 <_free_r+0x10c>
8000a560:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a564:	2c 8b       	sub	r11,-56
8000a566:	c2 08       	rjmp	8000a5a6 <_free_r+0x14a>
8000a568:	59 4b       	cp.w	r11,20
8000a56a:	e0 8b 00 04 	brhi	8000a572 <_free_r+0x116>
8000a56e:	2a 5b       	sub	r11,-91
8000a570:	c1 b8       	rjmp	8000a5a6 <_free_r+0x14a>
8000a572:	e0 4b 00 54 	cp.w	r11,84
8000a576:	e0 8b 00 06 	brhi	8000a582 <_free_r+0x126>
8000a57a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a57e:	29 2b       	sub	r11,-110
8000a580:	c1 38       	rjmp	8000a5a6 <_free_r+0x14a>
8000a582:	e0 4b 01 54 	cp.w	r11,340
8000a586:	e0 8b 00 06 	brhi	8000a592 <_free_r+0x136>
8000a58a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a58e:	28 9b       	sub	r11,-119
8000a590:	c0 b8       	rjmp	8000a5a6 <_free_r+0x14a>
8000a592:	e0 4b 05 54 	cp.w	r11,1364
8000a596:	e0 88 00 05 	brls	8000a5a0 <_free_r+0x144>
8000a59a:	37 eb       	mov	r11,126
8000a59c:	c0 58       	rjmp	8000a5a6 <_free_r+0x14a>
8000a59e:	d7 03       	nop
8000a5a0:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a5a4:	28 4b       	sub	r11,-124
8000a5a6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a5aa:	78 29       	ld.w	r9,r12[0x8]
8000a5ac:	18 39       	cp.w	r9,r12
8000a5ae:	c0 e1       	brne	8000a5ca <_free_r+0x16e>
8000a5b0:	74 18       	ld.w	r8,r10[0x4]
8000a5b2:	a3 4b       	asr	r11,0x2
8000a5b4:	30 1c       	mov	r12,1
8000a5b6:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a5ba:	f1 eb 10 0b 	or	r11,r8,r11
8000a5be:	12 98       	mov	r8,r9
8000a5c0:	95 1b       	st.w	r10[0x4],r11
8000a5c2:	c0 a8       	rjmp	8000a5d6 <_free_r+0x17a>
8000a5c4:	72 29       	ld.w	r9,r9[0x8]
8000a5c6:	18 39       	cp.w	r9,r12
8000a5c8:	c0 60       	breq	8000a5d4 <_free_r+0x178>
8000a5ca:	72 1a       	ld.w	r10,r9[0x4]
8000a5cc:	e0 1a ff fc 	andl	r10,0xfffc
8000a5d0:	14 38       	cp.w	r8,r10
8000a5d2:	cf 93       	brcs	8000a5c4 <_free_r+0x168>
8000a5d4:	72 38       	ld.w	r8,r9[0xc]
8000a5d6:	8d 38       	st.w	r6[0xc],r8
8000a5d8:	8d 29       	st.w	r6[0x8],r9
8000a5da:	93 36       	st.w	r9[0xc],r6
8000a5dc:	91 26       	st.w	r8[0x8],r6
8000a5de:	0e 9c       	mov	r12,r7
8000a5e0:	fe b0 d6 4e 	rcall	8000527c <__malloc_unlock>
8000a5e4:	d8 22       	popm	r4-r7,pc
8000a5e6:	d7 03       	nop

8000a5e8 <__sfvwrite_r>:
8000a5e8:	d4 31       	pushm	r0-r7,lr
8000a5ea:	20 3d       	sub	sp,12
8000a5ec:	14 94       	mov	r4,r10
8000a5ee:	18 95       	mov	r5,r12
8000a5f0:	16 97       	mov	r7,r11
8000a5f2:	74 28       	ld.w	r8,r10[0x8]
8000a5f4:	58 08       	cp.w	r8,0
8000a5f6:	e0 80 01 40 	breq	8000a876 <__sfvwrite_r+0x28e>
8000a5fa:	96 68       	ld.sh	r8,r11[0xc]
8000a5fc:	ed b8 00 03 	bld	r8,0x3
8000a600:	c0 41       	brne	8000a608 <__sfvwrite_r+0x20>
8000a602:	76 48       	ld.w	r8,r11[0x10]
8000a604:	58 08       	cp.w	r8,0
8000a606:	c0 c1       	brne	8000a61e <__sfvwrite_r+0x36>
8000a608:	0e 9b       	mov	r11,r7
8000a60a:	0a 9c       	mov	r12,r5
8000a60c:	fe b0 f6 c4 	rcall	80009394 <__swsetup_r>
8000a610:	c0 70       	breq	8000a61e <__sfvwrite_r+0x36>
8000a612:	8e 68       	ld.sh	r8,r7[0xc]
8000a614:	a7 a8       	sbr	r8,0x6
8000a616:	ae 68       	st.h	r7[0xc],r8
8000a618:	30 98       	mov	r8,9
8000a61a:	8b 38       	st.w	r5[0xc],r8
8000a61c:	c2 b9       	rjmp	8000a872 <__sfvwrite_r+0x28a>
8000a61e:	8e 63       	ld.sh	r3,r7[0xc]
8000a620:	68 00       	ld.w	r0,r4[0x0]
8000a622:	06 96       	mov	r6,r3
8000a624:	e2 16 00 02 	andl	r6,0x2,COH
8000a628:	c2 10       	breq	8000a66a <__sfvwrite_r+0x82>
8000a62a:	30 03       	mov	r3,0
8000a62c:	e0 62 04 00 	mov	r2,1024
8000a630:	06 96       	mov	r6,r3
8000a632:	c0 48       	rjmp	8000a63a <__sfvwrite_r+0x52>
8000a634:	60 03       	ld.w	r3,r0[0x0]
8000a636:	60 16       	ld.w	r6,r0[0x4]
8000a638:	2f 80       	sub	r0,-8
8000a63a:	58 06       	cp.w	r6,0
8000a63c:	cf c0       	breq	8000a634 <__sfvwrite_r+0x4c>
8000a63e:	e0 46 04 00 	cp.w	r6,1024
8000a642:	ec 09 17 80 	movls	r9,r6
8000a646:	e4 09 17 b0 	movhi	r9,r2
8000a64a:	06 9a       	mov	r10,r3
8000a64c:	6e a8       	ld.w	r8,r7[0x28]
8000a64e:	6e 8b       	ld.w	r11,r7[0x20]
8000a650:	0a 9c       	mov	r12,r5
8000a652:	5d 18       	icall	r8
8000a654:	18 16       	sub	r6,r12
8000a656:	58 0c       	cp.w	r12,0
8000a658:	e0 8a 01 0a 	brle	8000a86c <__sfvwrite_r+0x284>
8000a65c:	68 28       	ld.w	r8,r4[0x8]
8000a65e:	18 18       	sub	r8,r12
8000a660:	89 28       	st.w	r4[0x8],r8
8000a662:	e0 80 01 0a 	breq	8000a876 <__sfvwrite_r+0x28e>
8000a666:	18 03       	add	r3,r12
8000a668:	ce 9b       	rjmp	8000a63a <__sfvwrite_r+0x52>
8000a66a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a66e:	c0 70       	breq	8000a67c <__sfvwrite_r+0x94>
8000a670:	50 06       	stdsp	sp[0x0],r6
8000a672:	0c 93       	mov	r3,r6
8000a674:	0c 91       	mov	r1,r6
8000a676:	50 15       	stdsp	sp[0x4],r5
8000a678:	08 92       	mov	r2,r4
8000a67a:	c9 c8       	rjmp	8000a7b2 <__sfvwrite_r+0x1ca>
8000a67c:	06 96       	mov	r6,r3
8000a67e:	08 91       	mov	r1,r4
8000a680:	c0 48       	rjmp	8000a688 <__sfvwrite_r+0xa0>
8000a682:	60 03       	ld.w	r3,r0[0x0]
8000a684:	60 16       	ld.w	r6,r0[0x4]
8000a686:	2f 80       	sub	r0,-8
8000a688:	58 06       	cp.w	r6,0
8000a68a:	cf c0       	breq	8000a682 <__sfvwrite_r+0x9a>
8000a68c:	8e 68       	ld.sh	r8,r7[0xc]
8000a68e:	6e 24       	ld.w	r4,r7[0x8]
8000a690:	10 99       	mov	r9,r8
8000a692:	e2 19 02 00 	andl	r9,0x200,COH
8000a696:	c5 50       	breq	8000a740 <__sfvwrite_r+0x158>
8000a698:	08 36       	cp.w	r6,r4
8000a69a:	c4 43       	brcs	8000a722 <__sfvwrite_r+0x13a>
8000a69c:	10 99       	mov	r9,r8
8000a69e:	e2 19 04 80 	andl	r9,0x480,COH
8000a6a2:	c4 00       	breq	8000a722 <__sfvwrite_r+0x13a>
8000a6a4:	6e 4b       	ld.w	r11,r7[0x10]
8000a6a6:	6e 09       	ld.w	r9,r7[0x0]
8000a6a8:	16 19       	sub	r9,r11
8000a6aa:	50 09       	stdsp	sp[0x0],r9
8000a6ac:	6e 59       	ld.w	r9,r7[0x14]
8000a6ae:	10 9c       	mov	r12,r8
8000a6b0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a6b4:	30 28       	mov	r8,2
8000a6b6:	f4 08 0c 08 	divs	r8,r10,r8
8000a6ba:	fa e9 00 04 	st.d	sp[4],r8
8000a6be:	10 94       	mov	r4,r8
8000a6c0:	40 09       	lddsp	r9,sp[0x0]
8000a6c2:	e2 1c 04 00 	andl	r12,0x400,COH
8000a6c6:	2f f9       	sub	r9,-1
8000a6c8:	0c 09       	add	r9,r6
8000a6ca:	12 38       	cp.w	r8,r9
8000a6cc:	f2 04 17 30 	movlo	r4,r9
8000a6d0:	58 0c       	cp.w	r12,0
8000a6d2:	c1 10       	breq	8000a6f4 <__sfvwrite_r+0x10c>
8000a6d4:	08 9b       	mov	r11,r4
8000a6d6:	0a 9c       	mov	r12,r5
8000a6d8:	fe b0 e0 60 	rcall	80006798 <_malloc_r>
8000a6dc:	18 92       	mov	r2,r12
8000a6de:	c1 40       	breq	8000a706 <__sfvwrite_r+0x11e>
8000a6e0:	40 0a       	lddsp	r10,sp[0x0]
8000a6e2:	6e 4b       	ld.w	r11,r7[0x10]
8000a6e4:	fe b0 e2 76 	rcall	80006bd0 <memcpy>
8000a6e8:	8e 68       	ld.sh	r8,r7[0xc]
8000a6ea:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a6ee:	a7 b8       	sbr	r8,0x7
8000a6f0:	ae 68       	st.h	r7[0xc],r8
8000a6f2:	c0 d8       	rjmp	8000a70c <__sfvwrite_r+0x124>
8000a6f4:	08 9a       	mov	r10,r4
8000a6f6:	0a 9c       	mov	r12,r5
8000a6f8:	fe b0 e3 18 	rcall	80006d28 <_realloc_r>
8000a6fc:	18 92       	mov	r2,r12
8000a6fe:	c0 71       	brne	8000a70c <__sfvwrite_r+0x124>
8000a700:	6e 4b       	ld.w	r11,r7[0x10]
8000a702:	0a 9c       	mov	r12,r5
8000a704:	ca ce       	rcall	8000a45c <_free_r>
8000a706:	30 c8       	mov	r8,12
8000a708:	8b 38       	st.w	r5[0xc],r8
8000a70a:	cb 18       	rjmp	8000a86c <__sfvwrite_r+0x284>
8000a70c:	40 0a       	lddsp	r10,sp[0x0]
8000a70e:	40 09       	lddsp	r9,sp[0x0]
8000a710:	e8 0a 01 0a 	sub	r10,r4,r10
8000a714:	e4 09 00 08 	add	r8,r2,r9
8000a718:	8f 54       	st.w	r7[0x14],r4
8000a71a:	8f 2a       	st.w	r7[0x8],r10
8000a71c:	8f 08       	st.w	r7[0x0],r8
8000a71e:	8f 42       	st.w	r7[0x10],r2
8000a720:	0c 94       	mov	r4,r6
8000a722:	08 36       	cp.w	r6,r4
8000a724:	ec 04 17 30 	movlo	r4,r6
8000a728:	06 9b       	mov	r11,r3
8000a72a:	08 9a       	mov	r10,r4
8000a72c:	6e 0c       	ld.w	r12,r7[0x0]
8000a72e:	c3 ad       	rcall	8000a9a2 <memmove>
8000a730:	6e 08       	ld.w	r8,r7[0x0]
8000a732:	08 08       	add	r8,r4
8000a734:	8f 08       	st.w	r7[0x0],r8
8000a736:	6e 28       	ld.w	r8,r7[0x8]
8000a738:	08 18       	sub	r8,r4
8000a73a:	0c 94       	mov	r4,r6
8000a73c:	8f 28       	st.w	r7[0x8],r8
8000a73e:	c2 e8       	rjmp	8000a79a <__sfvwrite_r+0x1b2>
8000a740:	08 36       	cp.w	r6,r4
8000a742:	5f ba       	srhi	r10
8000a744:	6e 0c       	ld.w	r12,r7[0x0]
8000a746:	6e 48       	ld.w	r8,r7[0x10]
8000a748:	10 3c       	cp.w	r12,r8
8000a74a:	5f b8       	srhi	r8
8000a74c:	f5 e8 00 08 	and	r8,r10,r8
8000a750:	f2 08 18 00 	cp.b	r8,r9
8000a754:	c0 d0       	breq	8000a76e <__sfvwrite_r+0x186>
8000a756:	06 9b       	mov	r11,r3
8000a758:	08 9a       	mov	r10,r4
8000a75a:	c2 4d       	rcall	8000a9a2 <memmove>
8000a75c:	6e 08       	ld.w	r8,r7[0x0]
8000a75e:	08 08       	add	r8,r4
8000a760:	0e 9b       	mov	r11,r7
8000a762:	8f 08       	st.w	r7[0x0],r8
8000a764:	0a 9c       	mov	r12,r5
8000a766:	fe b0 fd 09 	rcall	8000a178 <_fflush_r>
8000a76a:	c1 80       	breq	8000a79a <__sfvwrite_r+0x1b2>
8000a76c:	c8 08       	rjmp	8000a86c <__sfvwrite_r+0x284>
8000a76e:	6e 59       	ld.w	r9,r7[0x14]
8000a770:	12 36       	cp.w	r6,r9
8000a772:	c0 a3       	brcs	8000a786 <__sfvwrite_r+0x19e>
8000a774:	6e a8       	ld.w	r8,r7[0x28]
8000a776:	06 9a       	mov	r10,r3
8000a778:	6e 8b       	ld.w	r11,r7[0x20]
8000a77a:	0a 9c       	mov	r12,r5
8000a77c:	5d 18       	icall	r8
8000a77e:	18 94       	mov	r4,r12
8000a780:	e0 89 00 0d 	brgt	8000a79a <__sfvwrite_r+0x1b2>
8000a784:	c7 48       	rjmp	8000a86c <__sfvwrite_r+0x284>
8000a786:	0c 9a       	mov	r10,r6
8000a788:	06 9b       	mov	r11,r3
8000a78a:	c0 cd       	rcall	8000a9a2 <memmove>
8000a78c:	6e 08       	ld.w	r8,r7[0x0]
8000a78e:	0c 08       	add	r8,r6
8000a790:	0c 94       	mov	r4,r6
8000a792:	8f 08       	st.w	r7[0x0],r8
8000a794:	6e 28       	ld.w	r8,r7[0x8]
8000a796:	0c 18       	sub	r8,r6
8000a798:	8f 28       	st.w	r7[0x8],r8
8000a79a:	62 28       	ld.w	r8,r1[0x8]
8000a79c:	08 18       	sub	r8,r4
8000a79e:	83 28       	st.w	r1[0x8],r8
8000a7a0:	c6 b0       	breq	8000a876 <__sfvwrite_r+0x28e>
8000a7a2:	08 16       	sub	r6,r4
8000a7a4:	08 03       	add	r3,r4
8000a7a6:	c7 1b       	rjmp	8000a688 <__sfvwrite_r+0xa0>
8000a7a8:	60 03       	ld.w	r3,r0[0x0]
8000a7aa:	60 11       	ld.w	r1,r0[0x4]
8000a7ac:	30 08       	mov	r8,0
8000a7ae:	2f 80       	sub	r0,-8
8000a7b0:	50 08       	stdsp	sp[0x0],r8
8000a7b2:	58 01       	cp.w	r1,0
8000a7b4:	cf a0       	breq	8000a7a8 <__sfvwrite_r+0x1c0>
8000a7b6:	40 0a       	lddsp	r10,sp[0x0]
8000a7b8:	58 0a       	cp.w	r10,0
8000a7ba:	c1 41       	brne	8000a7e2 <__sfvwrite_r+0x1fa>
8000a7bc:	e2 c6 ff ff 	sub	r6,r1,-1
8000a7c0:	02 9a       	mov	r10,r1
8000a7c2:	30 ab       	mov	r11,10
8000a7c4:	06 9c       	mov	r12,r3
8000a7c6:	ce 3c       	rcall	8000a98c <memchr>
8000a7c8:	f8 c8 ff ff 	sub	r8,r12,-1
8000a7cc:	58 0c       	cp.w	r12,0
8000a7ce:	f1 d3 e1 16 	subne	r6,r8,r3
8000a7d2:	f9 b9 01 01 	movne	r9,1
8000a7d6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a7da:	f9 b8 00 01 	moveq	r8,1
8000a7de:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a7e2:	02 36       	cp.w	r6,r1
8000a7e4:	ec 04 17 80 	movls	r4,r6
8000a7e8:	e2 04 17 b0 	movhi	r4,r1
8000a7ec:	6e 59       	ld.w	r9,r7[0x14]
8000a7ee:	6e 25       	ld.w	r5,r7[0x8]
8000a7f0:	f2 05 00 05 	add	r5,r9,r5
8000a7f4:	0a 34       	cp.w	r4,r5
8000a7f6:	5f 9a       	srgt	r10
8000a7f8:	6e 0c       	ld.w	r12,r7[0x0]
8000a7fa:	6e 48       	ld.w	r8,r7[0x10]
8000a7fc:	10 3c       	cp.w	r12,r8
8000a7fe:	5f b8       	srhi	r8
8000a800:	f5 e8 00 08 	and	r8,r10,r8
8000a804:	30 0a       	mov	r10,0
8000a806:	f4 08 18 00 	cp.b	r8,r10
8000a80a:	c0 d0       	breq	8000a824 <__sfvwrite_r+0x23c>
8000a80c:	06 9b       	mov	r11,r3
8000a80e:	0a 9a       	mov	r10,r5
8000a810:	cc 9c       	rcall	8000a9a2 <memmove>
8000a812:	6e 08       	ld.w	r8,r7[0x0]
8000a814:	0a 08       	add	r8,r5
8000a816:	0e 9b       	mov	r11,r7
8000a818:	8f 08       	st.w	r7[0x0],r8
8000a81a:	40 1c       	lddsp	r12,sp[0x4]
8000a81c:	fe b0 fc ae 	rcall	8000a178 <_fflush_r>
8000a820:	c1 70       	breq	8000a84e <__sfvwrite_r+0x266>
8000a822:	c2 58       	rjmp	8000a86c <__sfvwrite_r+0x284>
8000a824:	12 34       	cp.w	r4,r9
8000a826:	c0 a5       	brlt	8000a83a <__sfvwrite_r+0x252>
8000a828:	6e a8       	ld.w	r8,r7[0x28]
8000a82a:	06 9a       	mov	r10,r3
8000a82c:	6e 8b       	ld.w	r11,r7[0x20]
8000a82e:	40 1c       	lddsp	r12,sp[0x4]
8000a830:	5d 18       	icall	r8
8000a832:	18 95       	mov	r5,r12
8000a834:	e0 89 00 0d 	brgt	8000a84e <__sfvwrite_r+0x266>
8000a838:	c1 a8       	rjmp	8000a86c <__sfvwrite_r+0x284>
8000a83a:	08 9a       	mov	r10,r4
8000a83c:	06 9b       	mov	r11,r3
8000a83e:	cb 2c       	rcall	8000a9a2 <memmove>
8000a840:	6e 08       	ld.w	r8,r7[0x0]
8000a842:	08 08       	add	r8,r4
8000a844:	08 95       	mov	r5,r4
8000a846:	8f 08       	st.w	r7[0x0],r8
8000a848:	6e 28       	ld.w	r8,r7[0x8]
8000a84a:	08 18       	sub	r8,r4
8000a84c:	8f 28       	st.w	r7[0x8],r8
8000a84e:	0a 16       	sub	r6,r5
8000a850:	c0 71       	brne	8000a85e <__sfvwrite_r+0x276>
8000a852:	0e 9b       	mov	r11,r7
8000a854:	40 1c       	lddsp	r12,sp[0x4]
8000a856:	fe b0 fc 91 	rcall	8000a178 <_fflush_r>
8000a85a:	c0 91       	brne	8000a86c <__sfvwrite_r+0x284>
8000a85c:	50 06       	stdsp	sp[0x0],r6
8000a85e:	64 28       	ld.w	r8,r2[0x8]
8000a860:	0a 18       	sub	r8,r5
8000a862:	85 28       	st.w	r2[0x8],r8
8000a864:	c0 90       	breq	8000a876 <__sfvwrite_r+0x28e>
8000a866:	0a 11       	sub	r1,r5
8000a868:	0a 03       	add	r3,r5
8000a86a:	ca 4b       	rjmp	8000a7b2 <__sfvwrite_r+0x1ca>
8000a86c:	8e 68       	ld.sh	r8,r7[0xc]
8000a86e:	a7 a8       	sbr	r8,0x6
8000a870:	ae 68       	st.h	r7[0xc],r8
8000a872:	3f fc       	mov	r12,-1
8000a874:	c0 28       	rjmp	8000a878 <__sfvwrite_r+0x290>
8000a876:	30 0c       	mov	r12,0
8000a878:	2f dd       	sub	sp,-12
8000a87a:	d8 32       	popm	r0-r7,pc

8000a87c <_fwalk>:
8000a87c:	d4 31       	pushm	r0-r7,lr
8000a87e:	30 05       	mov	r5,0
8000a880:	16 91       	mov	r1,r11
8000a882:	f8 c7 ff 28 	sub	r7,r12,-216
8000a886:	0a 92       	mov	r2,r5
8000a888:	fe b0 fc fe 	rcall	8000a284 <__sfp_lock_acquire>
8000a88c:	3f f3       	mov	r3,-1
8000a88e:	c1 68       	rjmp	8000a8ba <_fwalk+0x3e>
8000a890:	6e 26       	ld.w	r6,r7[0x8]
8000a892:	6e 14       	ld.w	r4,r7[0x4]
8000a894:	2f 46       	sub	r6,-12
8000a896:	c0 c8       	rjmp	8000a8ae <_fwalk+0x32>
8000a898:	8c 08       	ld.sh	r8,r6[0x0]
8000a89a:	e4 08 19 00 	cp.h	r8,r2
8000a89e:	c0 70       	breq	8000a8ac <_fwalk+0x30>
8000a8a0:	8c 18       	ld.sh	r8,r6[0x2]
8000a8a2:	e6 08 19 00 	cp.h	r8,r3
8000a8a6:	c0 30       	breq	8000a8ac <_fwalk+0x30>
8000a8a8:	5d 11       	icall	r1
8000a8aa:	18 45       	or	r5,r12
8000a8ac:	2a 46       	sub	r6,-92
8000a8ae:	20 14       	sub	r4,1
8000a8b0:	ec cc 00 0c 	sub	r12,r6,12
8000a8b4:	58 04       	cp.w	r4,0
8000a8b6:	cf 14       	brge	8000a898 <_fwalk+0x1c>
8000a8b8:	6e 07       	ld.w	r7,r7[0x0]
8000a8ba:	58 07       	cp.w	r7,0
8000a8bc:	ce a1       	brne	8000a890 <_fwalk+0x14>
8000a8be:	fe b0 fc e4 	rcall	8000a286 <__sfp_lock_release>
8000a8c2:	0a 9c       	mov	r12,r5
8000a8c4:	d8 32       	popm	r0-r7,pc
8000a8c6:	d7 03       	nop

8000a8c8 <_localeconv_r>:
8000a8c8:	fe cc d4 c8 	sub	r12,pc,-11064
8000a8cc:	5e fc       	retal	r12
8000a8ce:	d7 03       	nop

8000a8d0 <__smakebuf_r>:
8000a8d0:	d4 21       	pushm	r4-r7,lr
8000a8d2:	20 fd       	sub	sp,60
8000a8d4:	96 68       	ld.sh	r8,r11[0xc]
8000a8d6:	16 97       	mov	r7,r11
8000a8d8:	18 96       	mov	r6,r12
8000a8da:	e2 18 00 02 	andl	r8,0x2,COH
8000a8de:	c3 d1       	brne	8000a958 <__smakebuf_r+0x88>
8000a8e0:	96 7b       	ld.sh	r11,r11[0xe]
8000a8e2:	f0 0b 19 00 	cp.h	r11,r8
8000a8e6:	c0 55       	brlt	8000a8f0 <__smakebuf_r+0x20>
8000a8e8:	1a 9a       	mov	r10,sp
8000a8ea:	e0 a0 04 75 	rcall	8000b1d4 <_fstat_r>
8000a8ee:	c0 f4       	brge	8000a90c <__smakebuf_r+0x3c>
8000a8f0:	8e 65       	ld.sh	r5,r7[0xc]
8000a8f2:	0a 98       	mov	r8,r5
8000a8f4:	ab b8       	sbr	r8,0xb
8000a8f6:	e2 15 00 80 	andl	r5,0x80,COH
8000a8fa:	ae 68       	st.h	r7[0xc],r8
8000a8fc:	30 04       	mov	r4,0
8000a8fe:	e0 68 04 00 	mov	r8,1024
8000a902:	f9 b5 01 40 	movne	r5,64
8000a906:	f0 05 17 00 	moveq	r5,r8
8000a90a:	c1 c8       	rjmp	8000a942 <__smakebuf_r+0x72>
8000a90c:	40 18       	lddsp	r8,sp[0x4]
8000a90e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a912:	e0 48 20 00 	cp.w	r8,8192
8000a916:	5f 04       	sreq	r4
8000a918:	e0 48 80 00 	cp.w	r8,32768
8000a91c:	c0 e1       	brne	8000a938 <__smakebuf_r+0x68>
8000a91e:	6e b9       	ld.w	r9,r7[0x2c]
8000a920:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a924:	10 39       	cp.w	r9,r8
8000a926:	c0 91       	brne	8000a938 <__smakebuf_r+0x68>
8000a928:	8e 68       	ld.sh	r8,r7[0xc]
8000a92a:	e0 65 04 00 	mov	r5,1024
8000a92e:	ab a8       	sbr	r8,0xa
8000a930:	ef 45 00 50 	st.w	r7[80],r5
8000a934:	ae 68       	st.h	r7[0xc],r8
8000a936:	c0 68       	rjmp	8000a942 <__smakebuf_r+0x72>
8000a938:	8e 68       	ld.sh	r8,r7[0xc]
8000a93a:	e0 65 04 00 	mov	r5,1024
8000a93e:	ab b8       	sbr	r8,0xb
8000a940:	ae 68       	st.h	r7[0xc],r8
8000a942:	0a 9b       	mov	r11,r5
8000a944:	0c 9c       	mov	r12,r6
8000a946:	fe b0 df 29 	rcall	80006798 <_malloc_r>
8000a94a:	8e 68       	ld.sh	r8,r7[0xc]
8000a94c:	c0 d1       	brne	8000a966 <__smakebuf_r+0x96>
8000a94e:	ed b8 00 09 	bld	r8,0x9
8000a952:	c1 b0       	breq	8000a988 <__smakebuf_r+0xb8>
8000a954:	a1 b8       	sbr	r8,0x1
8000a956:	ae 68       	st.h	r7[0xc],r8
8000a958:	ee c8 ff b9 	sub	r8,r7,-71
8000a95c:	8f 48       	st.w	r7[0x10],r8
8000a95e:	8f 08       	st.w	r7[0x0],r8
8000a960:	30 18       	mov	r8,1
8000a962:	8f 58       	st.w	r7[0x14],r8
8000a964:	c1 28       	rjmp	8000a988 <__smakebuf_r+0xb8>
8000a966:	a7 b8       	sbr	r8,0x7
8000a968:	8f 4c       	st.w	r7[0x10],r12
8000a96a:	ae 68       	st.h	r7[0xc],r8
8000a96c:	8f 55       	st.w	r7[0x14],r5
8000a96e:	fe c8 06 e6 	sub	r8,pc,1766
8000a972:	8f 0c       	st.w	r7[0x0],r12
8000a974:	8d a8       	st.w	r6[0x28],r8
8000a976:	58 04       	cp.w	r4,0
8000a978:	c0 80       	breq	8000a988 <__smakebuf_r+0xb8>
8000a97a:	8e 7c       	ld.sh	r12,r7[0xe]
8000a97c:	fe b0 e3 94 	rcall	800070a4 <isatty>
8000a980:	c0 40       	breq	8000a988 <__smakebuf_r+0xb8>
8000a982:	8e 68       	ld.sh	r8,r7[0xc]
8000a984:	a1 a8       	sbr	r8,0x0
8000a986:	ae 68       	st.h	r7[0xc],r8
8000a988:	2f 1d       	sub	sp,-60
8000a98a:	d8 22       	popm	r4-r7,pc

8000a98c <memchr>:
8000a98c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a990:	c0 68       	rjmp	8000a99c <memchr+0x10>
8000a992:	20 1a       	sub	r10,1
8000a994:	19 88       	ld.ub	r8,r12[0x0]
8000a996:	16 38       	cp.w	r8,r11
8000a998:	5e 0c       	reteq	r12
8000a99a:	2f fc       	sub	r12,-1
8000a99c:	58 0a       	cp.w	r10,0
8000a99e:	cf a1       	brne	8000a992 <memchr+0x6>
8000a9a0:	5e fa       	retal	r10

8000a9a2 <memmove>:
8000a9a2:	d4 01       	pushm	lr
8000a9a4:	18 3b       	cp.w	r11,r12
8000a9a6:	c1 92       	brcc	8000a9d8 <memmove+0x36>
8000a9a8:	f6 0a 00 09 	add	r9,r11,r10
8000a9ac:	12 3c       	cp.w	r12,r9
8000a9ae:	c1 52       	brcc	8000a9d8 <memmove+0x36>
8000a9b0:	f8 0a 00 0b 	add	r11,r12,r10
8000a9b4:	30 08       	mov	r8,0
8000a9b6:	c0 68       	rjmp	8000a9c2 <memmove+0x20>
8000a9b8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a9bc:	20 1a       	sub	r10,1
8000a9be:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a9c2:	20 18       	sub	r8,1
8000a9c4:	58 0a       	cp.w	r10,0
8000a9c6:	cf 91       	brne	8000a9b8 <memmove+0x16>
8000a9c8:	d8 02       	popm	pc
8000a9ca:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a9ce:	20 1a       	sub	r10,1
8000a9d0:	f8 08 0b 09 	st.b	r12[r8],r9
8000a9d4:	2f f8       	sub	r8,-1
8000a9d6:	c0 28       	rjmp	8000a9da <memmove+0x38>
8000a9d8:	30 08       	mov	r8,0
8000a9da:	58 0a       	cp.w	r10,0
8000a9dc:	cf 71       	brne	8000a9ca <memmove+0x28>
8000a9de:	d8 02       	popm	pc

8000a9e0 <__hi0bits>:
8000a9e0:	18 98       	mov	r8,r12
8000a9e2:	e0 1c 00 00 	andl	r12,0x0
8000a9e6:	f0 09 15 10 	lsl	r9,r8,0x10
8000a9ea:	58 0c       	cp.w	r12,0
8000a9ec:	f2 08 17 00 	moveq	r8,r9
8000a9f0:	f9 bc 00 10 	moveq	r12,16
8000a9f4:	f9 bc 01 00 	movne	r12,0
8000a9f8:	10 9a       	mov	r10,r8
8000a9fa:	f0 09 15 08 	lsl	r9,r8,0x8
8000a9fe:	e6 1a ff 00 	andh	r10,0xff00,COH
8000aa02:	f7 bc 00 f8 	subeq	r12,-8
8000aa06:	f2 08 17 00 	moveq	r8,r9
8000aa0a:	10 9a       	mov	r10,r8
8000aa0c:	f0 09 15 04 	lsl	r9,r8,0x4
8000aa10:	e6 1a f0 00 	andh	r10,0xf000,COH
8000aa14:	f7 bc 00 fc 	subeq	r12,-4
8000aa18:	f2 08 17 00 	moveq	r8,r9
8000aa1c:	10 9a       	mov	r10,r8
8000aa1e:	f0 09 15 02 	lsl	r9,r8,0x2
8000aa22:	e6 1a c0 00 	andh	r10,0xc000,COH
8000aa26:	f7 bc 00 fe 	subeq	r12,-2
8000aa2a:	f2 08 17 00 	moveq	r8,r9
8000aa2e:	58 08       	cp.w	r8,0
8000aa30:	5e 5c       	retlt	r12
8000aa32:	ed b8 00 1e 	bld	r8,0x1e
8000aa36:	f9 bc 01 20 	movne	r12,32
8000aa3a:	f7 bc 00 ff 	subeq	r12,-1
8000aa3e:	5e fc       	retal	r12

8000aa40 <__lo0bits>:
8000aa40:	18 99       	mov	r9,r12
8000aa42:	78 08       	ld.w	r8,r12[0x0]
8000aa44:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000aa48:	c1 50       	breq	8000aa72 <__lo0bits+0x32>
8000aa4a:	ed b8 00 00 	bld	r8,0x0
8000aa4e:	c0 21       	brne	8000aa52 <__lo0bits+0x12>
8000aa50:	5e fd       	retal	0
8000aa52:	10 9b       	mov	r11,r8
8000aa54:	f0 0a 16 01 	lsr	r10,r8,0x1
8000aa58:	e2 1b 00 02 	andl	r11,0x2,COH
8000aa5c:	a3 88       	lsr	r8,0x2
8000aa5e:	58 0b       	cp.w	r11,0
8000aa60:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000aa64:	f9 bc 01 01 	movne	r12,1
8000aa68:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000aa6c:	f9 bc 00 02 	moveq	r12,2
8000aa70:	5e fc       	retal	r12
8000aa72:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000aa76:	f0 0b 16 10 	lsr	r11,r8,0x10
8000aa7a:	58 0a       	cp.w	r10,0
8000aa7c:	f6 08 17 00 	moveq	r8,r11
8000aa80:	f9 bc 00 10 	moveq	r12,16
8000aa84:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000aa88:	f0 0a 16 08 	lsr	r10,r8,0x8
8000aa8c:	58 0b       	cp.w	r11,0
8000aa8e:	f7 bc 00 f8 	subeq	r12,-8
8000aa92:	f4 08 17 00 	moveq	r8,r10
8000aa96:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000aa9a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000aa9e:	58 0b       	cp.w	r11,0
8000aaa0:	f7 bc 00 fc 	subeq	r12,-4
8000aaa4:	f4 08 17 00 	moveq	r8,r10
8000aaa8:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000aaac:	f0 0a 16 02 	lsr	r10,r8,0x2
8000aab0:	58 0b       	cp.w	r11,0
8000aab2:	f7 bc 00 fe 	subeq	r12,-2
8000aab6:	f4 08 17 00 	moveq	r8,r10
8000aaba:	ed b8 00 00 	bld	r8,0x0
8000aabe:	c0 60       	breq	8000aaca <__lo0bits+0x8a>
8000aac0:	a1 98       	lsr	r8,0x1
8000aac2:	c0 31       	brne	8000aac8 <__lo0bits+0x88>
8000aac4:	32 0c       	mov	r12,32
8000aac6:	5e fc       	retal	r12
8000aac8:	2f fc       	sub	r12,-1
8000aaca:	93 08       	st.w	r9[0x0],r8
8000aacc:	5e fc       	retal	r12

8000aace <__mcmp>:
8000aace:	d4 01       	pushm	lr
8000aad0:	18 98       	mov	r8,r12
8000aad2:	76 49       	ld.w	r9,r11[0x10]
8000aad4:	78 4c       	ld.w	r12,r12[0x10]
8000aad6:	12 1c       	sub	r12,r9
8000aad8:	c1 31       	brne	8000aafe <__mcmp+0x30>
8000aada:	2f b9       	sub	r9,-5
8000aadc:	a3 69       	lsl	r9,0x2
8000aade:	12 0b       	add	r11,r9
8000aae0:	f0 09 00 09 	add	r9,r8,r9
8000aae4:	2e c8       	sub	r8,-20
8000aae6:	13 4e       	ld.w	lr,--r9
8000aae8:	17 4a       	ld.w	r10,--r11
8000aaea:	14 3e       	cp.w	lr,r10
8000aaec:	c0 60       	breq	8000aaf8 <__mcmp+0x2a>
8000aaee:	f9 bc 03 ff 	movlo	r12,-1
8000aaf2:	f9 bc 02 01 	movhs	r12,1
8000aaf6:	d8 02       	popm	pc
8000aaf8:	10 39       	cp.w	r9,r8
8000aafa:	fe 9b ff f6 	brhi	8000aae6 <__mcmp+0x18>
8000aafe:	d8 02       	popm	pc

8000ab00 <_Bfree>:
8000ab00:	d4 21       	pushm	r4-r7,lr
8000ab02:	18 97       	mov	r7,r12
8000ab04:	16 95       	mov	r5,r11
8000ab06:	78 96       	ld.w	r6,r12[0x24]
8000ab08:	58 06       	cp.w	r6,0
8000ab0a:	c0 91       	brne	8000ab1c <_Bfree+0x1c>
8000ab0c:	31 0c       	mov	r12,16
8000ab0e:	fe b0 de 3d 	rcall	80006788 <malloc>
8000ab12:	99 36       	st.w	r12[0xc],r6
8000ab14:	8f 9c       	st.w	r7[0x24],r12
8000ab16:	99 16       	st.w	r12[0x4],r6
8000ab18:	99 26       	st.w	r12[0x8],r6
8000ab1a:	99 06       	st.w	r12[0x0],r6
8000ab1c:	58 05       	cp.w	r5,0
8000ab1e:	c0 90       	breq	8000ab30 <_Bfree+0x30>
8000ab20:	6a 19       	ld.w	r9,r5[0x4]
8000ab22:	6e 98       	ld.w	r8,r7[0x24]
8000ab24:	70 38       	ld.w	r8,r8[0xc]
8000ab26:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000ab2a:	8b 0a       	st.w	r5[0x0],r10
8000ab2c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000ab30:	d8 22       	popm	r4-r7,pc
8000ab32:	d7 03       	nop

8000ab34 <_Balloc>:
8000ab34:	d4 21       	pushm	r4-r7,lr
8000ab36:	18 97       	mov	r7,r12
8000ab38:	16 96       	mov	r6,r11
8000ab3a:	78 95       	ld.w	r5,r12[0x24]
8000ab3c:	58 05       	cp.w	r5,0
8000ab3e:	c0 91       	brne	8000ab50 <_Balloc+0x1c>
8000ab40:	31 0c       	mov	r12,16
8000ab42:	fe b0 de 23 	rcall	80006788 <malloc>
8000ab46:	99 35       	st.w	r12[0xc],r5
8000ab48:	8f 9c       	st.w	r7[0x24],r12
8000ab4a:	99 15       	st.w	r12[0x4],r5
8000ab4c:	99 25       	st.w	r12[0x8],r5
8000ab4e:	99 05       	st.w	r12[0x0],r5
8000ab50:	6e 95       	ld.w	r5,r7[0x24]
8000ab52:	6a 38       	ld.w	r8,r5[0xc]
8000ab54:	58 08       	cp.w	r8,0
8000ab56:	c0 b1       	brne	8000ab6c <_Balloc+0x38>
8000ab58:	31 0a       	mov	r10,16
8000ab5a:	30 4b       	mov	r11,4
8000ab5c:	0e 9c       	mov	r12,r7
8000ab5e:	e0 a0 02 9b 	rcall	8000b094 <_calloc_r>
8000ab62:	8b 3c       	st.w	r5[0xc],r12
8000ab64:	6e 98       	ld.w	r8,r7[0x24]
8000ab66:	70 3c       	ld.w	r12,r8[0xc]
8000ab68:	58 0c       	cp.w	r12,0
8000ab6a:	c1 b0       	breq	8000aba0 <_Balloc+0x6c>
8000ab6c:	6e 98       	ld.w	r8,r7[0x24]
8000ab6e:	70 38       	ld.w	r8,r8[0xc]
8000ab70:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000ab74:	70 0c       	ld.w	r12,r8[0x0]
8000ab76:	58 0c       	cp.w	r12,0
8000ab78:	c0 40       	breq	8000ab80 <_Balloc+0x4c>
8000ab7a:	78 09       	ld.w	r9,r12[0x0]
8000ab7c:	91 09       	st.w	r8[0x0],r9
8000ab7e:	c0 e8       	rjmp	8000ab9a <_Balloc+0x66>
8000ab80:	0e 9c       	mov	r12,r7
8000ab82:	30 17       	mov	r7,1
8000ab84:	0e 9b       	mov	r11,r7
8000ab86:	ee 06 09 47 	lsl	r7,r7,r6
8000ab8a:	ee ca ff fb 	sub	r10,r7,-5
8000ab8e:	a3 6a       	lsl	r10,0x2
8000ab90:	e0 a0 02 82 	rcall	8000b094 <_calloc_r>
8000ab94:	c0 60       	breq	8000aba0 <_Balloc+0x6c>
8000ab96:	99 16       	st.w	r12[0x4],r6
8000ab98:	99 27       	st.w	r12[0x8],r7
8000ab9a:	30 08       	mov	r8,0
8000ab9c:	99 38       	st.w	r12[0xc],r8
8000ab9e:	99 48       	st.w	r12[0x10],r8
8000aba0:	d8 22       	popm	r4-r7,pc
8000aba2:	d7 03       	nop

8000aba4 <__d2b>:
8000aba4:	d4 31       	pushm	r0-r7,lr
8000aba6:	20 2d       	sub	sp,8
8000aba8:	16 93       	mov	r3,r11
8000abaa:	12 96       	mov	r6,r9
8000abac:	10 95       	mov	r5,r8
8000abae:	14 92       	mov	r2,r10
8000abb0:	30 1b       	mov	r11,1
8000abb2:	cc 1f       	rcall	8000ab34 <_Balloc>
8000abb4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000abb8:	50 09       	stdsp	sp[0x0],r9
8000abba:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000abbe:	b5 a9       	sbr	r9,0x14
8000abc0:	f0 01 16 14 	lsr	r1,r8,0x14
8000abc4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000abc8:	18 94       	mov	r4,r12
8000abca:	58 02       	cp.w	r2,0
8000abcc:	c1 d0       	breq	8000ac06 <__d2b+0x62>
8000abce:	fa cc ff f8 	sub	r12,sp,-8
8000abd2:	18 d2       	st.w	--r12,r2
8000abd4:	c3 6f       	rcall	8000aa40 <__lo0bits>
8000abd6:	40 18       	lddsp	r8,sp[0x4]
8000abd8:	c0 d0       	breq	8000abf2 <__d2b+0x4e>
8000abda:	40 09       	lddsp	r9,sp[0x0]
8000abdc:	f8 0a 11 20 	rsub	r10,r12,32
8000abe0:	f2 0a 09 4a 	lsl	r10,r9,r10
8000abe4:	f5 e8 10 08 	or	r8,r10,r8
8000abe8:	89 58       	st.w	r4[0x14],r8
8000abea:	f2 0c 0a 49 	lsr	r9,r9,r12
8000abee:	50 09       	stdsp	sp[0x0],r9
8000abf0:	c0 28       	rjmp	8000abf4 <__d2b+0x50>
8000abf2:	89 58       	st.w	r4[0x14],r8
8000abf4:	40 08       	lddsp	r8,sp[0x0]
8000abf6:	58 08       	cp.w	r8,0
8000abf8:	f9 b3 01 02 	movne	r3,2
8000abfc:	f9 b3 00 01 	moveq	r3,1
8000ac00:	89 68       	st.w	r4[0x18],r8
8000ac02:	89 43       	st.w	r4[0x10],r3
8000ac04:	c0 88       	rjmp	8000ac14 <__d2b+0x70>
8000ac06:	1a 9c       	mov	r12,sp
8000ac08:	c1 cf       	rcall	8000aa40 <__lo0bits>
8000ac0a:	30 13       	mov	r3,1
8000ac0c:	40 08       	lddsp	r8,sp[0x0]
8000ac0e:	2e 0c       	sub	r12,-32
8000ac10:	89 43       	st.w	r4[0x10],r3
8000ac12:	89 58       	st.w	r4[0x14],r8
8000ac14:	58 01       	cp.w	r1,0
8000ac16:	c0 90       	breq	8000ac28 <__d2b+0x84>
8000ac18:	e2 c1 04 33 	sub	r1,r1,1075
8000ac1c:	18 01       	add	r1,r12
8000ac1e:	8d 01       	st.w	r6[0x0],r1
8000ac20:	f8 0c 11 35 	rsub	r12,r12,53
8000ac24:	8b 0c       	st.w	r5[0x0],r12
8000ac26:	c0 c8       	rjmp	8000ac3e <__d2b+0x9a>
8000ac28:	e6 c8 ff fc 	sub	r8,r3,-4
8000ac2c:	f8 cc 04 32 	sub	r12,r12,1074
8000ac30:	a5 73       	lsl	r3,0x5
8000ac32:	8d 0c       	st.w	r6[0x0],r12
8000ac34:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000ac38:	cd 4e       	rcall	8000a9e0 <__hi0bits>
8000ac3a:	18 13       	sub	r3,r12
8000ac3c:	8b 03       	st.w	r5[0x0],r3
8000ac3e:	08 9c       	mov	r12,r4
8000ac40:	2f ed       	sub	sp,-8
8000ac42:	d8 32       	popm	r0-r7,pc

8000ac44 <__mdiff>:
8000ac44:	d4 31       	pushm	r0-r7,lr
8000ac46:	74 48       	ld.w	r8,r10[0x10]
8000ac48:	76 45       	ld.w	r5,r11[0x10]
8000ac4a:	16 97       	mov	r7,r11
8000ac4c:	14 96       	mov	r6,r10
8000ac4e:	10 15       	sub	r5,r8
8000ac50:	c1 31       	brne	8000ac76 <__mdiff+0x32>
8000ac52:	2f b8       	sub	r8,-5
8000ac54:	ee ce ff ec 	sub	lr,r7,-20
8000ac58:	a3 68       	lsl	r8,0x2
8000ac5a:	f4 08 00 0b 	add	r11,r10,r8
8000ac5e:	ee 08 00 08 	add	r8,r7,r8
8000ac62:	11 4a       	ld.w	r10,--r8
8000ac64:	17 49       	ld.w	r9,--r11
8000ac66:	12 3a       	cp.w	r10,r9
8000ac68:	c0 30       	breq	8000ac6e <__mdiff+0x2a>
8000ac6a:	c0 e2       	brcc	8000ac86 <__mdiff+0x42>
8000ac6c:	c0 78       	rjmp	8000ac7a <__mdiff+0x36>
8000ac6e:	1c 38       	cp.w	r8,lr
8000ac70:	fe 9b ff f9 	brhi	8000ac62 <__mdiff+0x1e>
8000ac74:	c4 98       	rjmp	8000ad06 <__mdiff+0xc2>
8000ac76:	58 05       	cp.w	r5,0
8000ac78:	c0 64       	brge	8000ac84 <__mdiff+0x40>
8000ac7a:	0e 98       	mov	r8,r7
8000ac7c:	30 15       	mov	r5,1
8000ac7e:	0c 97       	mov	r7,r6
8000ac80:	10 96       	mov	r6,r8
8000ac82:	c0 28       	rjmp	8000ac86 <__mdiff+0x42>
8000ac84:	30 05       	mov	r5,0
8000ac86:	6e 1b       	ld.w	r11,r7[0x4]
8000ac88:	c5 6f       	rcall	8000ab34 <_Balloc>
8000ac8a:	6e 49       	ld.w	r9,r7[0x10]
8000ac8c:	6c 44       	ld.w	r4,r6[0x10]
8000ac8e:	99 35       	st.w	r12[0xc],r5
8000ac90:	2f b4       	sub	r4,-5
8000ac92:	f2 c5 ff fb 	sub	r5,r9,-5
8000ac96:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000ac9a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000ac9e:	2e c6       	sub	r6,-20
8000aca0:	2e c7       	sub	r7,-20
8000aca2:	f8 c8 ff ec 	sub	r8,r12,-20
8000aca6:	30 0a       	mov	r10,0
8000aca8:	0f 0e       	ld.w	lr,r7++
8000acaa:	0d 0b       	ld.w	r11,r6++
8000acac:	fc 02 16 10 	lsr	r2,lr,0x10
8000acb0:	f6 03 16 10 	lsr	r3,r11,0x10
8000acb4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000acb8:	e4 03 01 03 	sub	r3,r2,r3
8000acbc:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000acc0:	fc 0b 01 0b 	sub	r11,lr,r11
8000acc4:	f6 0a 00 0a 	add	r10,r11,r10
8000acc8:	b0 1a       	st.h	r8[0x2],r10
8000acca:	b1 4a       	asr	r10,0x10
8000accc:	e6 0a 00 0a 	add	r10,r3,r10
8000acd0:	b0 0a       	st.h	r8[0x0],r10
8000acd2:	2f c8       	sub	r8,-4
8000acd4:	b1 4a       	asr	r10,0x10
8000acd6:	08 36       	cp.w	r6,r4
8000acd8:	ce 83       	brcs	8000aca8 <__mdiff+0x64>
8000acda:	c0 d8       	rjmp	8000acf4 <__mdiff+0xb0>
8000acdc:	0f 0b       	ld.w	r11,r7++
8000acde:	f6 0e 16 10 	lsr	lr,r11,0x10
8000ace2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ace6:	16 0a       	add	r10,r11
8000ace8:	b0 1a       	st.h	r8[0x2],r10
8000acea:	b1 4a       	asr	r10,0x10
8000acec:	1c 0a       	add	r10,lr
8000acee:	b0 0a       	st.h	r8[0x0],r10
8000acf0:	2f c8       	sub	r8,-4
8000acf2:	b1 4a       	asr	r10,0x10
8000acf4:	0a 37       	cp.w	r7,r5
8000acf6:	cf 33       	brcs	8000acdc <__mdiff+0x98>
8000acf8:	c0 28       	rjmp	8000acfc <__mdiff+0xb8>
8000acfa:	20 19       	sub	r9,1
8000acfc:	11 4a       	ld.w	r10,--r8
8000acfe:	58 0a       	cp.w	r10,0
8000ad00:	cf d0       	breq	8000acfa <__mdiff+0xb6>
8000ad02:	99 49       	st.w	r12[0x10],r9
8000ad04:	d8 32       	popm	r0-r7,pc
8000ad06:	30 0b       	mov	r11,0
8000ad08:	c1 6f       	rcall	8000ab34 <_Balloc>
8000ad0a:	30 18       	mov	r8,1
8000ad0c:	99 48       	st.w	r12[0x10],r8
8000ad0e:	30 08       	mov	r8,0
8000ad10:	99 58       	st.w	r12[0x14],r8
8000ad12:	d8 32       	popm	r0-r7,pc

8000ad14 <__lshift>:
8000ad14:	d4 31       	pushm	r0-r7,lr
8000ad16:	16 97       	mov	r7,r11
8000ad18:	76 46       	ld.w	r6,r11[0x10]
8000ad1a:	f4 02 14 05 	asr	r2,r10,0x5
8000ad1e:	2f f6       	sub	r6,-1
8000ad20:	14 93       	mov	r3,r10
8000ad22:	18 94       	mov	r4,r12
8000ad24:	04 06       	add	r6,r2
8000ad26:	76 1b       	ld.w	r11,r11[0x4]
8000ad28:	6e 28       	ld.w	r8,r7[0x8]
8000ad2a:	c0 38       	rjmp	8000ad30 <__lshift+0x1c>
8000ad2c:	2f fb       	sub	r11,-1
8000ad2e:	a1 78       	lsl	r8,0x1
8000ad30:	10 36       	cp.w	r6,r8
8000ad32:	fe 99 ff fd 	brgt	8000ad2c <__lshift+0x18>
8000ad36:	08 9c       	mov	r12,r4
8000ad38:	cf ee       	rcall	8000ab34 <_Balloc>
8000ad3a:	30 09       	mov	r9,0
8000ad3c:	18 95       	mov	r5,r12
8000ad3e:	f8 c8 ff ec 	sub	r8,r12,-20
8000ad42:	12 9a       	mov	r10,r9
8000ad44:	c0 38       	rjmp	8000ad4a <__lshift+0x36>
8000ad46:	10 aa       	st.w	r8++,r10
8000ad48:	2f f9       	sub	r9,-1
8000ad4a:	04 39       	cp.w	r9,r2
8000ad4c:	cf d5       	brlt	8000ad46 <__lshift+0x32>
8000ad4e:	6e 4b       	ld.w	r11,r7[0x10]
8000ad50:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ad54:	2f bb       	sub	r11,-5
8000ad56:	ee c9 ff ec 	sub	r9,r7,-20
8000ad5a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ad5e:	58 03       	cp.w	r3,0
8000ad60:	c1 30       	breq	8000ad86 <__lshift+0x72>
8000ad62:	e6 0c 11 20 	rsub	r12,r3,32
8000ad66:	30 0a       	mov	r10,0
8000ad68:	72 02       	ld.w	r2,r9[0x0]
8000ad6a:	e4 03 09 42 	lsl	r2,r2,r3
8000ad6e:	04 4a       	or	r10,r2
8000ad70:	10 aa       	st.w	r8++,r10
8000ad72:	13 0a       	ld.w	r10,r9++
8000ad74:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ad78:	16 39       	cp.w	r9,r11
8000ad7a:	cf 73       	brcs	8000ad68 <__lshift+0x54>
8000ad7c:	91 0a       	st.w	r8[0x0],r10
8000ad7e:	58 0a       	cp.w	r10,0
8000ad80:	c0 70       	breq	8000ad8e <__lshift+0x7a>
8000ad82:	2f f6       	sub	r6,-1
8000ad84:	c0 58       	rjmp	8000ad8e <__lshift+0x7a>
8000ad86:	13 0a       	ld.w	r10,r9++
8000ad88:	10 aa       	st.w	r8++,r10
8000ad8a:	16 39       	cp.w	r9,r11
8000ad8c:	cf d3       	brcs	8000ad86 <__lshift+0x72>
8000ad8e:	08 9c       	mov	r12,r4
8000ad90:	20 16       	sub	r6,1
8000ad92:	0e 9b       	mov	r11,r7
8000ad94:	8b 46       	st.w	r5[0x10],r6
8000ad96:	cb 5e       	rcall	8000ab00 <_Bfree>
8000ad98:	0a 9c       	mov	r12,r5
8000ad9a:	d8 32       	popm	r0-r7,pc

8000ad9c <__multiply>:
8000ad9c:	d4 31       	pushm	r0-r7,lr
8000ad9e:	20 2d       	sub	sp,8
8000ada0:	76 49       	ld.w	r9,r11[0x10]
8000ada2:	74 48       	ld.w	r8,r10[0x10]
8000ada4:	16 96       	mov	r6,r11
8000ada6:	14 95       	mov	r5,r10
8000ada8:	10 39       	cp.w	r9,r8
8000adaa:	ec 08 17 50 	movlt	r8,r6
8000adae:	ea 06 17 50 	movlt	r6,r5
8000adb2:	f0 05 17 50 	movlt	r5,r8
8000adb6:	6c 28       	ld.w	r8,r6[0x8]
8000adb8:	76 43       	ld.w	r3,r11[0x10]
8000adba:	74 42       	ld.w	r2,r10[0x10]
8000adbc:	76 1b       	ld.w	r11,r11[0x4]
8000adbe:	e4 03 00 07 	add	r7,r2,r3
8000adc2:	10 37       	cp.w	r7,r8
8000adc4:	f7 bb 09 ff 	subgt	r11,-1
8000adc8:	cb 6e       	rcall	8000ab34 <_Balloc>
8000adca:	ee c4 ff fb 	sub	r4,r7,-5
8000adce:	f8 c9 ff ec 	sub	r9,r12,-20
8000add2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000add6:	30 0a       	mov	r10,0
8000add8:	12 98       	mov	r8,r9
8000adda:	c0 28       	rjmp	8000adde <__multiply+0x42>
8000addc:	10 aa       	st.w	r8++,r10
8000adde:	08 38       	cp.w	r8,r4
8000ade0:	cf e3       	brcs	8000addc <__multiply+0x40>
8000ade2:	2f b3       	sub	r3,-5
8000ade4:	2f b2       	sub	r2,-5
8000ade6:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000adea:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000adee:	ec cb ff ec 	sub	r11,r6,-20
8000adf2:	50 12       	stdsp	sp[0x4],r2
8000adf4:	ea ca ff ec 	sub	r10,r5,-20
8000adf8:	c4 48       	rjmp	8000ae80 <__multiply+0xe4>
8000adfa:	94 95       	ld.uh	r5,r10[0x2]
8000adfc:	58 05       	cp.w	r5,0
8000adfe:	c2 00       	breq	8000ae3e <__multiply+0xa2>
8000ae00:	12 98       	mov	r8,r9
8000ae02:	16 96       	mov	r6,r11
8000ae04:	30 0e       	mov	lr,0
8000ae06:	50 09       	stdsp	sp[0x0],r9
8000ae08:	0d 02       	ld.w	r2,r6++
8000ae0a:	e4 00 16 10 	lsr	r0,r2,0x10
8000ae0e:	70 01       	ld.w	r1,r8[0x0]
8000ae10:	70 09       	ld.w	r9,r8[0x0]
8000ae12:	b1 81       	lsr	r1,0x10
8000ae14:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ae18:	e0 05 03 41 	mac	r1,r0,r5
8000ae1c:	ab 32       	mul	r2,r5
8000ae1e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ae22:	00 02       	add	r2,r0
8000ae24:	e4 0e 00 0e 	add	lr,r2,lr
8000ae28:	b0 1e       	st.h	r8[0x2],lr
8000ae2a:	b1 8e       	lsr	lr,0x10
8000ae2c:	1c 01       	add	r1,lr
8000ae2e:	b0 01       	st.h	r8[0x0],r1
8000ae30:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ae34:	2f c8       	sub	r8,-4
8000ae36:	06 36       	cp.w	r6,r3
8000ae38:	ce 83       	brcs	8000ae08 <__multiply+0x6c>
8000ae3a:	40 09       	lddsp	r9,sp[0x0]
8000ae3c:	91 0e       	st.w	r8[0x0],lr
8000ae3e:	94 86       	ld.uh	r6,r10[0x0]
8000ae40:	58 06       	cp.w	r6,0
8000ae42:	c1 d0       	breq	8000ae7c <__multiply+0xe0>
8000ae44:	72 02       	ld.w	r2,r9[0x0]
8000ae46:	12 98       	mov	r8,r9
8000ae48:	16 9e       	mov	lr,r11
8000ae4a:	30 05       	mov	r5,0
8000ae4c:	b0 12       	st.h	r8[0x2],r2
8000ae4e:	1d 01       	ld.w	r1,lr++
8000ae50:	90 82       	ld.uh	r2,r8[0x0]
8000ae52:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ae56:	ad 30       	mul	r0,r6
8000ae58:	e0 02 00 02 	add	r2,r0,r2
8000ae5c:	e4 05 00 05 	add	r5,r2,r5
8000ae60:	b0 05       	st.h	r8[0x0],r5
8000ae62:	b1 85       	lsr	r5,0x10
8000ae64:	b1 81       	lsr	r1,0x10
8000ae66:	2f c8       	sub	r8,-4
8000ae68:	ad 31       	mul	r1,r6
8000ae6a:	90 92       	ld.uh	r2,r8[0x2]
8000ae6c:	e2 02 00 02 	add	r2,r1,r2
8000ae70:	0a 02       	add	r2,r5
8000ae72:	e4 05 16 10 	lsr	r5,r2,0x10
8000ae76:	06 3e       	cp.w	lr,r3
8000ae78:	ce a3       	brcs	8000ae4c <__multiply+0xb0>
8000ae7a:	91 02       	st.w	r8[0x0],r2
8000ae7c:	2f ca       	sub	r10,-4
8000ae7e:	2f c9       	sub	r9,-4
8000ae80:	40 18       	lddsp	r8,sp[0x4]
8000ae82:	10 3a       	cp.w	r10,r8
8000ae84:	cb b3       	brcs	8000adfa <__multiply+0x5e>
8000ae86:	c0 28       	rjmp	8000ae8a <__multiply+0xee>
8000ae88:	20 17       	sub	r7,1
8000ae8a:	58 07       	cp.w	r7,0
8000ae8c:	e0 8a 00 05 	brle	8000ae96 <__multiply+0xfa>
8000ae90:	09 48       	ld.w	r8,--r4
8000ae92:	58 08       	cp.w	r8,0
8000ae94:	cf a0       	breq	8000ae88 <__multiply+0xec>
8000ae96:	99 47       	st.w	r12[0x10],r7
8000ae98:	2f ed       	sub	sp,-8
8000ae9a:	d8 32       	popm	r0-r7,pc

8000ae9c <__i2b>:
8000ae9c:	d4 21       	pushm	r4-r7,lr
8000ae9e:	16 97       	mov	r7,r11
8000aea0:	30 1b       	mov	r11,1
8000aea2:	c4 9e       	rcall	8000ab34 <_Balloc>
8000aea4:	30 19       	mov	r9,1
8000aea6:	99 57       	st.w	r12[0x14],r7
8000aea8:	99 49       	st.w	r12[0x10],r9
8000aeaa:	d8 22       	popm	r4-r7,pc

8000aeac <__multadd>:
8000aeac:	d4 31       	pushm	r0-r7,lr
8000aeae:	30 08       	mov	r8,0
8000aeb0:	12 95       	mov	r5,r9
8000aeb2:	16 97       	mov	r7,r11
8000aeb4:	18 96       	mov	r6,r12
8000aeb6:	76 44       	ld.w	r4,r11[0x10]
8000aeb8:	f6 c9 ff ec 	sub	r9,r11,-20
8000aebc:	72 0b       	ld.w	r11,r9[0x0]
8000aebe:	f6 0c 16 10 	lsr	r12,r11,0x10
8000aec2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aec6:	f4 0c 02 4c 	mul	r12,r10,r12
8000aeca:	f4 0b 03 45 	mac	r5,r10,r11
8000aece:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000aed2:	b1 85       	lsr	r5,0x10
8000aed4:	18 05       	add	r5,r12
8000aed6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000aeda:	f8 0b 00 0b 	add	r11,r12,r11
8000aede:	12 ab       	st.w	r9++,r11
8000aee0:	2f f8       	sub	r8,-1
8000aee2:	b1 85       	lsr	r5,0x10
8000aee4:	08 38       	cp.w	r8,r4
8000aee6:	ce b5       	brlt	8000aebc <__multadd+0x10>
8000aee8:	58 05       	cp.w	r5,0
8000aeea:	c1 c0       	breq	8000af22 <__multadd+0x76>
8000aeec:	6e 28       	ld.w	r8,r7[0x8]
8000aeee:	10 34       	cp.w	r4,r8
8000aef0:	c1 35       	brlt	8000af16 <__multadd+0x6a>
8000aef2:	6e 1b       	ld.w	r11,r7[0x4]
8000aef4:	0c 9c       	mov	r12,r6
8000aef6:	2f fb       	sub	r11,-1
8000aef8:	c1 ee       	rcall	8000ab34 <_Balloc>
8000aefa:	6e 4a       	ld.w	r10,r7[0x10]
8000aefc:	ee cb ff f4 	sub	r11,r7,-12
8000af00:	18 93       	mov	r3,r12
8000af02:	2f ea       	sub	r10,-2
8000af04:	2f 4c       	sub	r12,-12
8000af06:	a3 6a       	lsl	r10,0x2
8000af08:	fe b0 de 64 	rcall	80006bd0 <memcpy>
8000af0c:	0e 9b       	mov	r11,r7
8000af0e:	0c 9c       	mov	r12,r6
8000af10:	fe b0 fd f8 	rcall	8000ab00 <_Bfree>
8000af14:	06 97       	mov	r7,r3
8000af16:	e8 c8 ff ff 	sub	r8,r4,-1
8000af1a:	2f b4       	sub	r4,-5
8000af1c:	8f 48       	st.w	r7[0x10],r8
8000af1e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000af22:	0e 9c       	mov	r12,r7
8000af24:	d8 32       	popm	r0-r7,pc
8000af26:	d7 03       	nop

8000af28 <__pow5mult>:
8000af28:	d4 31       	pushm	r0-r7,lr
8000af2a:	14 96       	mov	r6,r10
8000af2c:	18 97       	mov	r7,r12
8000af2e:	16 94       	mov	r4,r11
8000af30:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000af34:	c0 90       	breq	8000af46 <__pow5mult+0x1e>
8000af36:	20 18       	sub	r8,1
8000af38:	fe c9 da fc 	sub	r9,pc,-9476
8000af3c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000af40:	30 09       	mov	r9,0
8000af42:	cb 5f       	rcall	8000aeac <__multadd>
8000af44:	18 94       	mov	r4,r12
8000af46:	a3 46       	asr	r6,0x2
8000af48:	c3 40       	breq	8000afb0 <__pow5mult+0x88>
8000af4a:	6e 95       	ld.w	r5,r7[0x24]
8000af4c:	58 05       	cp.w	r5,0
8000af4e:	c0 91       	brne	8000af60 <__pow5mult+0x38>
8000af50:	31 0c       	mov	r12,16
8000af52:	fe b0 dc 1b 	rcall	80006788 <malloc>
8000af56:	99 35       	st.w	r12[0xc],r5
8000af58:	8f 9c       	st.w	r7[0x24],r12
8000af5a:	99 15       	st.w	r12[0x4],r5
8000af5c:	99 25       	st.w	r12[0x8],r5
8000af5e:	99 05       	st.w	r12[0x0],r5
8000af60:	6e 93       	ld.w	r3,r7[0x24]
8000af62:	66 25       	ld.w	r5,r3[0x8]
8000af64:	58 05       	cp.w	r5,0
8000af66:	c0 c1       	brne	8000af7e <__pow5mult+0x56>
8000af68:	e0 6b 02 71 	mov	r11,625
8000af6c:	0e 9c       	mov	r12,r7
8000af6e:	c9 7f       	rcall	8000ae9c <__i2b>
8000af70:	87 2c       	st.w	r3[0x8],r12
8000af72:	30 08       	mov	r8,0
8000af74:	18 95       	mov	r5,r12
8000af76:	99 08       	st.w	r12[0x0],r8
8000af78:	c0 38       	rjmp	8000af7e <__pow5mult+0x56>
8000af7a:	06 9c       	mov	r12,r3
8000af7c:	18 95       	mov	r5,r12
8000af7e:	ed b6 00 00 	bld	r6,0x0
8000af82:	c0 b1       	brne	8000af98 <__pow5mult+0x70>
8000af84:	08 9b       	mov	r11,r4
8000af86:	0a 9a       	mov	r10,r5
8000af88:	0e 9c       	mov	r12,r7
8000af8a:	c0 9f       	rcall	8000ad9c <__multiply>
8000af8c:	08 9b       	mov	r11,r4
8000af8e:	18 93       	mov	r3,r12
8000af90:	0e 9c       	mov	r12,r7
8000af92:	06 94       	mov	r4,r3
8000af94:	fe b0 fd b6 	rcall	8000ab00 <_Bfree>
8000af98:	a1 56       	asr	r6,0x1
8000af9a:	c0 b0       	breq	8000afb0 <__pow5mult+0x88>
8000af9c:	6a 03       	ld.w	r3,r5[0x0]
8000af9e:	58 03       	cp.w	r3,0
8000afa0:	ce d1       	brne	8000af7a <__pow5mult+0x52>
8000afa2:	0a 9a       	mov	r10,r5
8000afa4:	0a 9b       	mov	r11,r5
8000afa6:	0e 9c       	mov	r12,r7
8000afa8:	cf ae       	rcall	8000ad9c <__multiply>
8000afaa:	8b 0c       	st.w	r5[0x0],r12
8000afac:	99 03       	st.w	r12[0x0],r3
8000afae:	ce 7b       	rjmp	8000af7c <__pow5mult+0x54>
8000afb0:	08 9c       	mov	r12,r4
8000afb2:	d8 32       	popm	r0-r7,pc

8000afb4 <__isinfd>:
8000afb4:	14 98       	mov	r8,r10
8000afb6:	fc 19 7f f0 	movh	r9,0x7ff0
8000afba:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000afbe:	f0 0b 11 00 	rsub	r11,r8,0
8000afc2:	f7 e8 10 08 	or	r8,r11,r8
8000afc6:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000afca:	f2 08 01 08 	sub	r8,r9,r8
8000afce:	f0 0c 11 00 	rsub	r12,r8,0
8000afd2:	f9 e8 10 08 	or	r8,r12,r8
8000afd6:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000afda:	2f fc       	sub	r12,-1
8000afdc:	5e fc       	retal	r12

8000afde <__isnand>:
8000afde:	14 98       	mov	r8,r10
8000afe0:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000afe4:	f0 0c 11 00 	rsub	r12,r8,0
8000afe8:	10 4c       	or	r12,r8
8000afea:	fc 18 7f f0 	movh	r8,0x7ff0
8000afee:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000aff2:	f0 0c 01 0c 	sub	r12,r8,r12
8000aff6:	bf 9c       	lsr	r12,0x1f
8000aff8:	5e fc       	retal	r12
8000affa:	d7 03       	nop

8000affc <__sclose>:
8000affc:	d4 01       	pushm	lr
8000affe:	96 7b       	ld.sh	r11,r11[0xe]
8000b000:	c7 6c       	rcall	8000b0ec <_close_r>
8000b002:	d8 02       	popm	pc

8000b004 <__sseek>:
8000b004:	d4 21       	pushm	r4-r7,lr
8000b006:	16 97       	mov	r7,r11
8000b008:	96 7b       	ld.sh	r11,r11[0xe]
8000b00a:	cf 7c       	rcall	8000b1f8 <_lseek_r>
8000b00c:	8e 68       	ld.sh	r8,r7[0xc]
8000b00e:	10 99       	mov	r9,r8
8000b010:	ad c8       	cbr	r8,0xc
8000b012:	ad a9       	sbr	r9,0xc
8000b014:	5b fc       	cp.w	r12,-1
8000b016:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b01a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b01e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b022:	d8 22       	popm	r4-r7,pc

8000b024 <__swrite>:
8000b024:	d4 21       	pushm	r4-r7,lr
8000b026:	96 68       	ld.sh	r8,r11[0xc]
8000b028:	16 97       	mov	r7,r11
8000b02a:	14 95       	mov	r5,r10
8000b02c:	12 94       	mov	r4,r9
8000b02e:	e2 18 01 00 	andl	r8,0x100,COH
8000b032:	18 96       	mov	r6,r12
8000b034:	c0 50       	breq	8000b03e <__swrite+0x1a>
8000b036:	30 29       	mov	r9,2
8000b038:	30 0a       	mov	r10,0
8000b03a:	96 7b       	ld.sh	r11,r11[0xe]
8000b03c:	cd ec       	rcall	8000b1f8 <_lseek_r>
8000b03e:	8e 68       	ld.sh	r8,r7[0xc]
8000b040:	ad c8       	cbr	r8,0xc
8000b042:	08 99       	mov	r9,r4
8000b044:	0a 9a       	mov	r10,r5
8000b046:	8e 7b       	ld.sh	r11,r7[0xe]
8000b048:	0c 9c       	mov	r12,r6
8000b04a:	ae 68       	st.h	r7[0xc],r8
8000b04c:	c1 0c       	rcall	8000b06c <_write_r>
8000b04e:	d8 22       	popm	r4-r7,pc

8000b050 <__sread>:
8000b050:	d4 21       	pushm	r4-r7,lr
8000b052:	16 97       	mov	r7,r11
8000b054:	96 7b       	ld.sh	r11,r11[0xe]
8000b056:	ce 5c       	rcall	8000b220 <_read_r>
8000b058:	c0 65       	brlt	8000b064 <__sread+0x14>
8000b05a:	6f 58       	ld.w	r8,r7[0x54]
8000b05c:	18 08       	add	r8,r12
8000b05e:	ef 48 00 54 	st.w	r7[84],r8
8000b062:	d8 22       	popm	r4-r7,pc
8000b064:	8e 68       	ld.sh	r8,r7[0xc]
8000b066:	ad c8       	cbr	r8,0xc
8000b068:	ae 68       	st.h	r7[0xc],r8
8000b06a:	d8 22       	popm	r4-r7,pc

8000b06c <_write_r>:
8000b06c:	d4 21       	pushm	r4-r7,lr
8000b06e:	16 98       	mov	r8,r11
8000b070:	18 97       	mov	r7,r12
8000b072:	10 9c       	mov	r12,r8
8000b074:	30 08       	mov	r8,0
8000b076:	14 9b       	mov	r11,r10
8000b078:	e0 66 41 18 	mov	r6,16664
8000b07c:	12 9a       	mov	r10,r9
8000b07e:	8d 08       	st.w	r6[0x0],r8
8000b080:	fe b0 d1 24 	rcall	800052c8 <_write>
8000b084:	5b fc       	cp.w	r12,-1
8000b086:	c0 51       	brne	8000b090 <_write_r+0x24>
8000b088:	6c 08       	ld.w	r8,r6[0x0]
8000b08a:	58 08       	cp.w	r8,0
8000b08c:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b090:	d8 22       	popm	r4-r7,pc
8000b092:	d7 03       	nop

8000b094 <_calloc_r>:
8000b094:	d4 21       	pushm	r4-r7,lr
8000b096:	f4 0b 02 4b 	mul	r11,r10,r11
8000b09a:	fe b0 db 7f 	rcall	80006798 <_malloc_r>
8000b09e:	18 97       	mov	r7,r12
8000b0a0:	c2 30       	breq	8000b0e6 <_calloc_r+0x52>
8000b0a2:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b0a6:	e0 1a ff fc 	andl	r10,0xfffc
8000b0aa:	20 4a       	sub	r10,4
8000b0ac:	e0 4a 00 24 	cp.w	r10,36
8000b0b0:	e0 8b 00 18 	brhi	8000b0e0 <_calloc_r+0x4c>
8000b0b4:	18 98       	mov	r8,r12
8000b0b6:	59 3a       	cp.w	r10,19
8000b0b8:	e0 88 00 0f 	brls	8000b0d6 <_calloc_r+0x42>
8000b0bc:	30 09       	mov	r9,0
8000b0be:	10 a9       	st.w	r8++,r9
8000b0c0:	10 a9       	st.w	r8++,r9
8000b0c2:	59 ba       	cp.w	r10,27
8000b0c4:	e0 88 00 09 	brls	8000b0d6 <_calloc_r+0x42>
8000b0c8:	10 a9       	st.w	r8++,r9
8000b0ca:	10 a9       	st.w	r8++,r9
8000b0cc:	e0 4a 00 24 	cp.w	r10,36
8000b0d0:	c0 31       	brne	8000b0d6 <_calloc_r+0x42>
8000b0d2:	10 a9       	st.w	r8++,r9
8000b0d4:	10 a9       	st.w	r8++,r9
8000b0d6:	30 09       	mov	r9,0
8000b0d8:	10 a9       	st.w	r8++,r9
8000b0da:	91 19       	st.w	r8[0x4],r9
8000b0dc:	91 09       	st.w	r8[0x0],r9
8000b0de:	c0 48       	rjmp	8000b0e6 <_calloc_r+0x52>
8000b0e0:	30 0b       	mov	r11,0
8000b0e2:	fe b0 de 1b 	rcall	80006d18 <memset>
8000b0e6:	0e 9c       	mov	r12,r7
8000b0e8:	d8 22       	popm	r4-r7,pc
8000b0ea:	d7 03       	nop

8000b0ec <_close_r>:
8000b0ec:	d4 21       	pushm	r4-r7,lr
8000b0ee:	30 08       	mov	r8,0
8000b0f0:	18 97       	mov	r7,r12
8000b0f2:	e0 66 41 18 	mov	r6,16664
8000b0f6:	16 9c       	mov	r12,r11
8000b0f8:	8d 08       	st.w	r6[0x0],r8
8000b0fa:	fe b0 df c1 	rcall	8000707c <_close>
8000b0fe:	5b fc       	cp.w	r12,-1
8000b100:	c0 51       	brne	8000b10a <_close_r+0x1e>
8000b102:	6c 08       	ld.w	r8,r6[0x0]
8000b104:	58 08       	cp.w	r8,0
8000b106:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b10a:	d8 22       	popm	r4-r7,pc

8000b10c <_fclose_r>:
8000b10c:	d4 21       	pushm	r4-r7,lr
8000b10e:	18 96       	mov	r6,r12
8000b110:	16 97       	mov	r7,r11
8000b112:	58 0b       	cp.w	r11,0
8000b114:	c0 31       	brne	8000b11a <_fclose_r+0xe>
8000b116:	16 95       	mov	r5,r11
8000b118:	c5 38       	rjmp	8000b1be <_fclose_r+0xb2>
8000b11a:	fe b0 f8 b5 	rcall	8000a284 <__sfp_lock_acquire>
8000b11e:	58 06       	cp.w	r6,0
8000b120:	c0 70       	breq	8000b12e <_fclose_r+0x22>
8000b122:	6c 68       	ld.w	r8,r6[0x18]
8000b124:	58 08       	cp.w	r8,0
8000b126:	c0 41       	brne	8000b12e <_fclose_r+0x22>
8000b128:	0c 9c       	mov	r12,r6
8000b12a:	fe b0 f8 ff 	rcall	8000a328 <__sinit>
8000b12e:	fe c8 dd 96 	sub	r8,pc,-8810
8000b132:	10 37       	cp.w	r7,r8
8000b134:	c0 31       	brne	8000b13a <_fclose_r+0x2e>
8000b136:	6c 07       	ld.w	r7,r6[0x0]
8000b138:	c0 c8       	rjmp	8000b150 <_fclose_r+0x44>
8000b13a:	fe c8 dd 82 	sub	r8,pc,-8830
8000b13e:	10 37       	cp.w	r7,r8
8000b140:	c0 31       	brne	8000b146 <_fclose_r+0x3a>
8000b142:	6c 17       	ld.w	r7,r6[0x4]
8000b144:	c0 68       	rjmp	8000b150 <_fclose_r+0x44>
8000b146:	fe c8 dd 6e 	sub	r8,pc,-8850
8000b14a:	10 37       	cp.w	r7,r8
8000b14c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b150:	8e 69       	ld.sh	r9,r7[0xc]
8000b152:	30 08       	mov	r8,0
8000b154:	f0 09 19 00 	cp.h	r9,r8
8000b158:	c0 51       	brne	8000b162 <_fclose_r+0x56>
8000b15a:	fe b0 f8 96 	rcall	8000a286 <__sfp_lock_release>
8000b15e:	30 05       	mov	r5,0
8000b160:	c2 f8       	rjmp	8000b1be <_fclose_r+0xb2>
8000b162:	0e 9b       	mov	r11,r7
8000b164:	0c 9c       	mov	r12,r6
8000b166:	fe b0 f8 09 	rcall	8000a178 <_fflush_r>
8000b16a:	6e c8       	ld.w	r8,r7[0x30]
8000b16c:	18 95       	mov	r5,r12
8000b16e:	58 08       	cp.w	r8,0
8000b170:	c0 60       	breq	8000b17c <_fclose_r+0x70>
8000b172:	6e 8b       	ld.w	r11,r7[0x20]
8000b174:	0c 9c       	mov	r12,r6
8000b176:	5d 18       	icall	r8
8000b178:	f9 b5 05 ff 	movlt	r5,-1
8000b17c:	8e 68       	ld.sh	r8,r7[0xc]
8000b17e:	ed b8 00 07 	bld	r8,0x7
8000b182:	c0 51       	brne	8000b18c <_fclose_r+0x80>
8000b184:	6e 4b       	ld.w	r11,r7[0x10]
8000b186:	0c 9c       	mov	r12,r6
8000b188:	fe b0 f9 6a 	rcall	8000a45c <_free_r>
8000b18c:	6e db       	ld.w	r11,r7[0x34]
8000b18e:	58 0b       	cp.w	r11,0
8000b190:	c0 a0       	breq	8000b1a4 <_fclose_r+0x98>
8000b192:	ee c8 ff bc 	sub	r8,r7,-68
8000b196:	10 3b       	cp.w	r11,r8
8000b198:	c0 40       	breq	8000b1a0 <_fclose_r+0x94>
8000b19a:	0c 9c       	mov	r12,r6
8000b19c:	fe b0 f9 60 	rcall	8000a45c <_free_r>
8000b1a0:	30 08       	mov	r8,0
8000b1a2:	8f d8       	st.w	r7[0x34],r8
8000b1a4:	6f 2b       	ld.w	r11,r7[0x48]
8000b1a6:	58 0b       	cp.w	r11,0
8000b1a8:	c0 70       	breq	8000b1b6 <_fclose_r+0xaa>
8000b1aa:	0c 9c       	mov	r12,r6
8000b1ac:	fe b0 f9 58 	rcall	8000a45c <_free_r>
8000b1b0:	30 08       	mov	r8,0
8000b1b2:	ef 48 00 48 	st.w	r7[72],r8
8000b1b6:	30 08       	mov	r8,0
8000b1b8:	ae 68       	st.h	r7[0xc],r8
8000b1ba:	fe b0 f8 66 	rcall	8000a286 <__sfp_lock_release>
8000b1be:	0a 9c       	mov	r12,r5
8000b1c0:	d8 22       	popm	r4-r7,pc
8000b1c2:	d7 03       	nop

8000b1c4 <fclose>:
8000b1c4:	d4 01       	pushm	lr
8000b1c6:	e0 68 0a 30 	mov	r8,2608
8000b1ca:	18 9b       	mov	r11,r12
8000b1cc:	70 0c       	ld.w	r12,r8[0x0]
8000b1ce:	c9 ff       	rcall	8000b10c <_fclose_r>
8000b1d0:	d8 02       	popm	pc
8000b1d2:	d7 03       	nop

8000b1d4 <_fstat_r>:
8000b1d4:	d4 21       	pushm	r4-r7,lr
8000b1d6:	16 98       	mov	r8,r11
8000b1d8:	18 97       	mov	r7,r12
8000b1da:	10 9c       	mov	r12,r8
8000b1dc:	30 08       	mov	r8,0
8000b1de:	e0 66 41 18 	mov	r6,16664
8000b1e2:	14 9b       	mov	r11,r10
8000b1e4:	8d 08       	st.w	r6[0x0],r8
8000b1e6:	fe b0 df 73 	rcall	800070cc <_fstat>
8000b1ea:	5b fc       	cp.w	r12,-1
8000b1ec:	c0 51       	brne	8000b1f6 <_fstat_r+0x22>
8000b1ee:	6c 08       	ld.w	r8,r6[0x0]
8000b1f0:	58 08       	cp.w	r8,0
8000b1f2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b1f6:	d8 22       	popm	r4-r7,pc

8000b1f8 <_lseek_r>:
8000b1f8:	d4 21       	pushm	r4-r7,lr
8000b1fa:	16 98       	mov	r8,r11
8000b1fc:	18 97       	mov	r7,r12
8000b1fe:	10 9c       	mov	r12,r8
8000b200:	30 08       	mov	r8,0
8000b202:	14 9b       	mov	r11,r10
8000b204:	e0 66 41 18 	mov	r6,16664
8000b208:	12 9a       	mov	r10,r9
8000b20a:	8d 08       	st.w	r6[0x0],r8
8000b20c:	fe b0 df 42 	rcall	80007090 <_lseek>
8000b210:	5b fc       	cp.w	r12,-1
8000b212:	c0 51       	brne	8000b21c <_lseek_r+0x24>
8000b214:	6c 08       	ld.w	r8,r6[0x0]
8000b216:	58 08       	cp.w	r8,0
8000b218:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b21c:	d8 22       	popm	r4-r7,pc
8000b21e:	d7 03       	nop

8000b220 <_read_r>:
8000b220:	d4 21       	pushm	r4-r7,lr
8000b222:	16 98       	mov	r8,r11
8000b224:	18 97       	mov	r7,r12
8000b226:	10 9c       	mov	r12,r8
8000b228:	30 08       	mov	r8,0
8000b22a:	14 9b       	mov	r11,r10
8000b22c:	e0 66 41 18 	mov	r6,16664
8000b230:	12 9a       	mov	r10,r9
8000b232:	8d 08       	st.w	r6[0x0],r8
8000b234:	fe b0 d0 2a 	rcall	80005288 <_read>
8000b238:	5b fc       	cp.w	r12,-1
8000b23a:	c0 51       	brne	8000b244 <_read_r+0x24>
8000b23c:	6c 08       	ld.w	r8,r6[0x0]
8000b23e:	58 08       	cp.w	r8,0
8000b240:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b244:	d8 22       	popm	r4-r7,pc
8000b246:	d7 03       	nop

8000b248 <__avr32_f64_mul>:
8000b248:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b24c:	e0 80 00 dc 	breq	8000b404 <__avr32_f64_mul_op1_zero>
8000b250:	d4 21       	pushm	r4-r7,lr
8000b252:	f7 e9 20 0e 	eor	lr,r11,r9
8000b256:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b25a:	30 15       	mov	r5,1
8000b25c:	c4 30       	breq	8000b2e2 <__avr32_f64_mul_op1_subnormal>
8000b25e:	ab 6b       	lsl	r11,0xa
8000b260:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b264:	ab 6a       	lsl	r10,0xa
8000b266:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b26a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b26e:	c5 c0       	breq	8000b326 <__avr32_f64_mul_op2_subnormal>
8000b270:	a1 78       	lsl	r8,0x1
8000b272:	5c f9       	rol	r9
8000b274:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b278:	e0 47 07 ff 	cp.w	r7,2047
8000b27c:	c7 70       	breq	8000b36a <__avr32_f64_mul_op_nan_or_inf>
8000b27e:	e0 46 07 ff 	cp.w	r6,2047
8000b282:	c7 40       	breq	8000b36a <__avr32_f64_mul_op_nan_or_inf>
8000b284:	ee 06 00 0c 	add	r12,r7,r6
8000b288:	e0 2c 03 fe 	sub	r12,1022
8000b28c:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b290:	f4 09 07 44 	macu.d	r4,r10,r9
8000b294:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b298:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b29c:	08 07       	add	r7,r4
8000b29e:	f4 05 00 4a 	adc	r10,r10,r5
8000b2a2:	5c 0b       	acr	r11
8000b2a4:	ed bb 00 14 	bld	r11,0x14
8000b2a8:	c0 50       	breq	8000b2b2 <__avr32_f64_mul+0x6a>
8000b2aa:	a1 77       	lsl	r7,0x1
8000b2ac:	5c fa       	rol	r10
8000b2ae:	5c fb       	rol	r11
8000b2b0:	20 1c       	sub	r12,1
8000b2b2:	58 0c       	cp.w	r12,0
8000b2b4:	e0 8a 00 6f 	brle	8000b392 <__avr32_f64_mul_res_subnormal>
8000b2b8:	e0 4c 07 ff 	cp.w	r12,2047
8000b2bc:	e0 84 00 9c 	brge	8000b3f4 <__avr32_f64_mul_res_inf>
8000b2c0:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b2c4:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b2c8:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b2cc:	ee 17 80 00 	eorh	r7,0x8000
8000b2d0:	f1 b7 04 20 	satu	r7,0x1
8000b2d4:	0e 0a       	add	r10,r7
8000b2d6:	5c 0b       	acr	r11
8000b2d8:	ed be 00 1f 	bld	lr,0x1f
8000b2dc:	ef bb 00 1f 	bst	r11,0x1f
8000b2e0:	d8 22       	popm	r4-r7,pc

8000b2e2 <__avr32_f64_mul_op1_subnormal>:
8000b2e2:	e4 1b 00 0f 	andh	r11,0xf
8000b2e6:	f4 0c 12 00 	clz	r12,r10
8000b2ea:	f6 06 12 00 	clz	r6,r11
8000b2ee:	f7 bc 03 e1 	sublo	r12,-31
8000b2f2:	f8 06 17 30 	movlo	r6,r12
8000b2f6:	f7 b6 02 01 	subhs	r6,1
8000b2fa:	e0 46 00 20 	cp.w	r6,32
8000b2fe:	c0 d4       	brge	8000b318 <__avr32_f64_mul_op1_subnormal+0x36>
8000b300:	ec 0c 11 20 	rsub	r12,r6,32
8000b304:	f6 06 09 4b 	lsl	r11,r11,r6
8000b308:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b30c:	18 4b       	or	r11,r12
8000b30e:	f4 06 09 4a 	lsl	r10,r10,r6
8000b312:	20 b6       	sub	r6,11
8000b314:	0c 17       	sub	r7,r6
8000b316:	ca ab       	rjmp	8000b26a <__avr32_f64_mul+0x22>
8000b318:	f4 06 09 4b 	lsl	r11,r10,r6
8000b31c:	c6 40       	breq	8000b3e4 <__avr32_f64_mul_res_zero>
8000b31e:	30 0a       	mov	r10,0
8000b320:	20 b6       	sub	r6,11
8000b322:	0c 17       	sub	r7,r6
8000b324:	ca 3b       	rjmp	8000b26a <__avr32_f64_mul+0x22>

8000b326 <__avr32_f64_mul_op2_subnormal>:
8000b326:	e4 19 00 0f 	andh	r9,0xf
8000b32a:	f0 0c 12 00 	clz	r12,r8
8000b32e:	f2 05 12 00 	clz	r5,r9
8000b332:	f7 bc 03 ea 	sublo	r12,-22
8000b336:	f8 05 17 30 	movlo	r5,r12
8000b33a:	f7 b5 02 0a 	subhs	r5,10
8000b33e:	e0 45 00 20 	cp.w	r5,32
8000b342:	c0 d4       	brge	8000b35c <__avr32_f64_mul_op2_subnormal+0x36>
8000b344:	ea 0c 11 20 	rsub	r12,r5,32
8000b348:	f2 05 09 49 	lsl	r9,r9,r5
8000b34c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b350:	18 49       	or	r9,r12
8000b352:	f0 05 09 48 	lsl	r8,r8,r5
8000b356:	20 25       	sub	r5,2
8000b358:	0a 16       	sub	r6,r5
8000b35a:	c8 fb       	rjmp	8000b278 <__avr32_f64_mul+0x30>
8000b35c:	f0 05 09 49 	lsl	r9,r8,r5
8000b360:	c4 20       	breq	8000b3e4 <__avr32_f64_mul_res_zero>
8000b362:	30 08       	mov	r8,0
8000b364:	20 25       	sub	r5,2
8000b366:	0a 16       	sub	r6,r5
8000b368:	c8 8b       	rjmp	8000b278 <__avr32_f64_mul+0x30>

8000b36a <__avr32_f64_mul_op_nan_or_inf>:
8000b36a:	e4 19 00 0f 	andh	r9,0xf
8000b36e:	e4 1b 00 0f 	andh	r11,0xf
8000b372:	14 4b       	or	r11,r10
8000b374:	10 49       	or	r9,r8
8000b376:	e0 47 07 ff 	cp.w	r7,2047
8000b37a:	c0 91       	brne	8000b38c <__avr32_f64_mul_op1_not_naninf>
8000b37c:	58 0b       	cp.w	r11,0
8000b37e:	c3 81       	brne	8000b3ee <__avr32_f64_mul_res_nan>
8000b380:	e0 46 07 ff 	cp.w	r6,2047
8000b384:	c3 81       	brne	8000b3f4 <__avr32_f64_mul_res_inf>
8000b386:	58 09       	cp.w	r9,0
8000b388:	c3 60       	breq	8000b3f4 <__avr32_f64_mul_res_inf>
8000b38a:	c3 28       	rjmp	8000b3ee <__avr32_f64_mul_res_nan>

8000b38c <__avr32_f64_mul_op1_not_naninf>:
8000b38c:	58 09       	cp.w	r9,0
8000b38e:	c3 30       	breq	8000b3f4 <__avr32_f64_mul_res_inf>
8000b390:	c2 f8       	rjmp	8000b3ee <__avr32_f64_mul_res_nan>

8000b392 <__avr32_f64_mul_res_subnormal>:
8000b392:	5c 3c       	neg	r12
8000b394:	2f fc       	sub	r12,-1
8000b396:	f1 bc 04 c0 	satu	r12,0x6
8000b39a:	e0 4c 00 20 	cp.w	r12,32
8000b39e:	c1 14       	brge	8000b3c0 <__avr32_f64_mul_res_subnormal+0x2e>
8000b3a0:	f8 08 11 20 	rsub	r8,r12,32
8000b3a4:	0e 46       	or	r6,r7
8000b3a6:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b3aa:	f4 08 09 49 	lsl	r9,r10,r8
8000b3ae:	12 47       	or	r7,r9
8000b3b0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b3b4:	f6 08 09 49 	lsl	r9,r11,r8
8000b3b8:	12 4a       	or	r10,r9
8000b3ba:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b3be:	c8 3b       	rjmp	8000b2c4 <__avr32_f64_mul+0x7c>
8000b3c0:	f8 08 11 20 	rsub	r8,r12,32
8000b3c4:	f9 b9 00 00 	moveq	r9,0
8000b3c8:	c0 30       	breq	8000b3ce <__avr32_f64_mul_res_subnormal+0x3c>
8000b3ca:	f6 08 09 49 	lsl	r9,r11,r8
8000b3ce:	0e 46       	or	r6,r7
8000b3d0:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b3d4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b3d8:	f3 ea 10 07 	or	r7,r9,r10
8000b3dc:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b3e0:	30 0b       	mov	r11,0
8000b3e2:	c7 1b       	rjmp	8000b2c4 <__avr32_f64_mul+0x7c>

8000b3e4 <__avr32_f64_mul_res_zero>:
8000b3e4:	1c 9b       	mov	r11,lr
8000b3e6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b3ea:	30 0a       	mov	r10,0
8000b3ec:	d8 22       	popm	r4-r7,pc

8000b3ee <__avr32_f64_mul_res_nan>:
8000b3ee:	3f fb       	mov	r11,-1
8000b3f0:	3f fa       	mov	r10,-1
8000b3f2:	d8 22       	popm	r4-r7,pc

8000b3f4 <__avr32_f64_mul_res_inf>:
8000b3f4:	f0 6b 00 00 	mov	r11,-1048576
8000b3f8:	ed be 00 1f 	bld	lr,0x1f
8000b3fc:	ef bb 00 1f 	bst	r11,0x1f
8000b400:	30 0a       	mov	r10,0
8000b402:	d8 22       	popm	r4-r7,pc

8000b404 <__avr32_f64_mul_op1_zero>:
8000b404:	f7 e9 20 0b 	eor	r11,r11,r9
8000b408:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b40c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b410:	e0 4c 07 ff 	cp.w	r12,2047
8000b414:	5e 1c       	retne	r12
8000b416:	3f fa       	mov	r10,-1
8000b418:	3f fb       	mov	r11,-1
8000b41a:	5e fc       	retal	r12

8000b41c <__avr32_f64_sub_from_add>:
8000b41c:	ee 19 80 00 	eorh	r9,0x8000

8000b420 <__avr32_f64_sub>:
8000b420:	f7 e9 20 0c 	eor	r12,r11,r9
8000b424:	e0 86 00 ca 	brmi	8000b5b8 <__avr32_f64_add_from_sub>
8000b428:	eb cd 40 e0 	pushm	r5-r7,lr
8000b42c:	16 9c       	mov	r12,r11
8000b42e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b432:	bf db       	cbr	r11,0x1f
8000b434:	bf d9       	cbr	r9,0x1f
8000b436:	10 3a       	cp.w	r10,r8
8000b438:	f2 0b 13 00 	cpc	r11,r9
8000b43c:	c0 92       	brcc	8000b44e <__avr32_f64_sub+0x2e>
8000b43e:	16 97       	mov	r7,r11
8000b440:	12 9b       	mov	r11,r9
8000b442:	0e 99       	mov	r9,r7
8000b444:	14 97       	mov	r7,r10
8000b446:	10 9a       	mov	r10,r8
8000b448:	0e 98       	mov	r8,r7
8000b44a:	ee 1c 80 00 	eorh	r12,0x8000
8000b44e:	f6 07 16 14 	lsr	r7,r11,0x14
8000b452:	ab 7b       	lsl	r11,0xb
8000b454:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b458:	ab 7a       	lsl	r10,0xb
8000b45a:	bf bb       	sbr	r11,0x1f
8000b45c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b460:	c4 40       	breq	8000b4e8 <__avr32_f64_sub_opL_subnormal>
8000b462:	ab 79       	lsl	r9,0xb
8000b464:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b468:	ab 78       	lsl	r8,0xb
8000b46a:	bf b9       	sbr	r9,0x1f

8000b46c <__avr32_f64_sub_opL_subnormal_done>:
8000b46c:	e0 47 07 ff 	cp.w	r7,2047
8000b470:	c4 f0       	breq	8000b50e <__avr32_f64_sub_opH_nan_or_inf>
8000b472:	0e 26       	rsub	r6,r7
8000b474:	c1 20       	breq	8000b498 <__avr32_f64_sub_shift_done>
8000b476:	ec 05 11 20 	rsub	r5,r6,32
8000b47a:	e0 46 00 20 	cp.w	r6,32
8000b47e:	c7 c2       	brcc	8000b576 <__avr32_f64_sub_longshift>
8000b480:	f0 05 09 4e 	lsl	lr,r8,r5
8000b484:	f2 05 09 45 	lsl	r5,r9,r5
8000b488:	f0 06 0a 48 	lsr	r8,r8,r6
8000b48c:	f2 06 0a 49 	lsr	r9,r9,r6
8000b490:	0a 48       	or	r8,r5
8000b492:	58 0e       	cp.w	lr,0
8000b494:	5f 1e       	srne	lr
8000b496:	1c 48       	or	r8,lr

8000b498 <__avr32_f64_sub_shift_done>:
8000b498:	10 1a       	sub	r10,r8
8000b49a:	f6 09 01 4b 	sbc	r11,r11,r9
8000b49e:	f6 06 12 00 	clz	r6,r11
8000b4a2:	c0 e0       	breq	8000b4be <__avr32_f64_sub_longnormalize_done>
8000b4a4:	c7 83       	brcs	8000b594 <__avr32_f64_sub_longnormalize>
8000b4a6:	ec 0e 11 20 	rsub	lr,r6,32
8000b4aa:	f6 06 09 4b 	lsl	r11,r11,r6
8000b4ae:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b4b2:	1c 4b       	or	r11,lr
8000b4b4:	f4 06 09 4a 	lsl	r10,r10,r6
8000b4b8:	0c 17       	sub	r7,r6
8000b4ba:	e0 8a 00 39 	brle	8000b52c <__avr32_f64_sub_subnormal_result>

8000b4be <__avr32_f64_sub_longnormalize_done>:
8000b4be:	f4 09 15 15 	lsl	r9,r10,0x15
8000b4c2:	ab 9a       	lsr	r10,0xb
8000b4c4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b4c8:	ab 9b       	lsr	r11,0xb
8000b4ca:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b4ce:	18 4b       	or	r11,r12

8000b4d0 <__avr32_f64_sub_round>:
8000b4d0:	fc 17 80 00 	movh	r7,0x8000
8000b4d4:	ed ba 00 00 	bld	r10,0x0
8000b4d8:	f7 b7 01 ff 	subne	r7,-1
8000b4dc:	0e 39       	cp.w	r9,r7
8000b4de:	5f 29       	srhs	r9
8000b4e0:	12 0a       	add	r10,r9
8000b4e2:	5c 0b       	acr	r11
8000b4e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b4e8 <__avr32_f64_sub_opL_subnormal>:
8000b4e8:	ab 79       	lsl	r9,0xb
8000b4ea:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b4ee:	ab 78       	lsl	r8,0xb
8000b4f0:	f3 e8 10 0e 	or	lr,r9,r8
8000b4f4:	f9 b6 01 01 	movne	r6,1
8000b4f8:	ee 0e 11 00 	rsub	lr,r7,0
8000b4fc:	f9 b7 00 01 	moveq	r7,1
8000b500:	ef bb 00 1f 	bst	r11,0x1f
8000b504:	f7 ea 10 0e 	or	lr,r11,r10
8000b508:	f9 b7 00 00 	moveq	r7,0
8000b50c:	cb 0b       	rjmp	8000b46c <__avr32_f64_sub_opL_subnormal_done>

8000b50e <__avr32_f64_sub_opH_nan_or_inf>:
8000b50e:	bf db       	cbr	r11,0x1f
8000b510:	f7 ea 10 0e 	or	lr,r11,r10
8000b514:	c0 81       	brne	8000b524 <__avr32_f64_sub_return_nan>
8000b516:	e0 46 07 ff 	cp.w	r6,2047
8000b51a:	c0 50       	breq	8000b524 <__avr32_f64_sub_return_nan>
8000b51c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b520:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b524 <__avr32_f64_sub_return_nan>:
8000b524:	3f fa       	mov	r10,-1
8000b526:	3f fb       	mov	r11,-1
8000b528:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b52c <__avr32_f64_sub_subnormal_result>:
8000b52c:	5c 37       	neg	r7
8000b52e:	2f f7       	sub	r7,-1
8000b530:	f1 b7 04 c0 	satu	r7,0x6
8000b534:	e0 47 00 20 	cp.w	r7,32
8000b538:	c1 14       	brge	8000b55a <__avr32_f64_sub_subnormal_result+0x2e>
8000b53a:	ee 08 11 20 	rsub	r8,r7,32
8000b53e:	f4 08 09 49 	lsl	r9,r10,r8
8000b542:	5f 16       	srne	r6
8000b544:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b548:	0c 4a       	or	r10,r6
8000b54a:	f6 08 09 49 	lsl	r9,r11,r8
8000b54e:	f5 e9 10 0a 	or	r10,r10,r9
8000b552:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b556:	30 07       	mov	r7,0
8000b558:	cb 3b       	rjmp	8000b4be <__avr32_f64_sub_longnormalize_done>
8000b55a:	ee 08 11 40 	rsub	r8,r7,64
8000b55e:	f6 08 09 49 	lsl	r9,r11,r8
8000b562:	14 49       	or	r9,r10
8000b564:	5f 16       	srne	r6
8000b566:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b56a:	0c 4a       	or	r10,r6
8000b56c:	30 0b       	mov	r11,0
8000b56e:	30 07       	mov	r7,0
8000b570:	ca 7b       	rjmp	8000b4be <__avr32_f64_sub_longnormalize_done>
8000b572:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b576 <__avr32_f64_sub_longshift>:
8000b576:	f1 b6 04 c0 	satu	r6,0x6
8000b57a:	f0 0e 17 00 	moveq	lr,r8
8000b57e:	c0 40       	breq	8000b586 <__avr32_f64_sub_longshift+0x10>
8000b580:	f2 05 09 4e 	lsl	lr,r9,r5
8000b584:	10 4e       	or	lr,r8
8000b586:	f2 06 0a 48 	lsr	r8,r9,r6
8000b58a:	30 09       	mov	r9,0
8000b58c:	58 0e       	cp.w	lr,0
8000b58e:	5f 1e       	srne	lr
8000b590:	1c 48       	or	r8,lr
8000b592:	c8 3b       	rjmp	8000b498 <__avr32_f64_sub_shift_done>

8000b594 <__avr32_f64_sub_longnormalize>:
8000b594:	f4 06 12 00 	clz	r6,r10
8000b598:	f9 b7 03 00 	movlo	r7,0
8000b59c:	f9 b6 03 00 	movlo	r6,0
8000b5a0:	f9 bc 03 00 	movlo	r12,0
8000b5a4:	f7 b6 02 e0 	subhs	r6,-32
8000b5a8:	f4 06 09 4b 	lsl	r11,r10,r6
8000b5ac:	30 0a       	mov	r10,0
8000b5ae:	0c 17       	sub	r7,r6
8000b5b0:	fe 9a ff be 	brle	8000b52c <__avr32_f64_sub_subnormal_result>
8000b5b4:	c8 5b       	rjmp	8000b4be <__avr32_f64_sub_longnormalize_done>
8000b5b6:	d7 03       	nop

8000b5b8 <__avr32_f64_add_from_sub>:
8000b5b8:	ee 19 80 00 	eorh	r9,0x8000

8000b5bc <__avr32_f64_add>:
8000b5bc:	f7 e9 20 0c 	eor	r12,r11,r9
8000b5c0:	fe 96 ff 2e 	brmi	8000b41c <__avr32_f64_sub_from_add>
8000b5c4:	eb cd 40 e0 	pushm	r5-r7,lr
8000b5c8:	16 9c       	mov	r12,r11
8000b5ca:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b5ce:	bf db       	cbr	r11,0x1f
8000b5d0:	bf d9       	cbr	r9,0x1f
8000b5d2:	12 3b       	cp.w	r11,r9
8000b5d4:	c0 72       	brcc	8000b5e2 <__avr32_f64_add+0x26>
8000b5d6:	16 97       	mov	r7,r11
8000b5d8:	12 9b       	mov	r11,r9
8000b5da:	0e 99       	mov	r9,r7
8000b5dc:	14 97       	mov	r7,r10
8000b5de:	10 9a       	mov	r10,r8
8000b5e0:	0e 98       	mov	r8,r7
8000b5e2:	30 0e       	mov	lr,0
8000b5e4:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b5e8:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b5ec:	b5 ab       	sbr	r11,0x14
8000b5ee:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b5f2:	c6 20       	breq	8000b6b6 <__avr32_f64_add_op2_subnormal>
8000b5f4:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b5f8:	b5 a9       	sbr	r9,0x14
8000b5fa:	e0 47 07 ff 	cp.w	r7,2047
8000b5fe:	c2 80       	breq	8000b64e <__avr32_f64_add_opH_nan_or_inf>
8000b600:	0e 26       	rsub	r6,r7
8000b602:	c1 20       	breq	8000b626 <__avr32_f64_add_shift_done>
8000b604:	e0 46 00 36 	cp.w	r6,54
8000b608:	c1 52       	brcc	8000b632 <__avr32_f64_add_res_of_done>
8000b60a:	ec 05 11 20 	rsub	r5,r6,32
8000b60e:	e0 46 00 20 	cp.w	r6,32
8000b612:	c3 52       	brcc	8000b67c <__avr32_f64_add_longshift>
8000b614:	f0 05 09 4e 	lsl	lr,r8,r5
8000b618:	f2 05 09 45 	lsl	r5,r9,r5
8000b61c:	f0 06 0a 48 	lsr	r8,r8,r6
8000b620:	f2 06 0a 49 	lsr	r9,r9,r6
8000b624:	0a 48       	or	r8,r5

8000b626 <__avr32_f64_add_shift_done>:
8000b626:	10 0a       	add	r10,r8
8000b628:	f6 09 00 4b 	adc	r11,r11,r9
8000b62c:	ed bb 00 15 	bld	r11,0x15
8000b630:	c3 40       	breq	8000b698 <__avr32_f64_add_res_of>

8000b632 <__avr32_f64_add_res_of_done>:
8000b632:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b636:	18 4b       	or	r11,r12

8000b638 <__avr32_f64_add_round>:
8000b638:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b63c:	18 4e       	or	lr,r12
8000b63e:	ee 1e 80 00 	eorh	lr,0x8000
8000b642:	f1 be 04 20 	satu	lr,0x1
8000b646:	1c 0a       	add	r10,lr
8000b648:	5c 0b       	acr	r11
8000b64a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b64e <__avr32_f64_add_opH_nan_or_inf>:
8000b64e:	b5 cb       	cbr	r11,0x14
8000b650:	f7 ea 10 0e 	or	lr,r11,r10
8000b654:	c1 01       	brne	8000b674 <__avr32_f64_add_return_nan>
8000b656:	e0 46 07 ff 	cp.w	r6,2047
8000b65a:	c0 30       	breq	8000b660 <__avr32_f64_add_opL_nan_or_inf>
8000b65c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b660 <__avr32_f64_add_opL_nan_or_inf>:
8000b660:	b5 c9       	cbr	r9,0x14
8000b662:	f3 e8 10 0e 	or	lr,r9,r8
8000b666:	c0 71       	brne	8000b674 <__avr32_f64_add_return_nan>
8000b668:	30 0a       	mov	r10,0
8000b66a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b66e:	18 4b       	or	r11,r12
8000b670:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b674 <__avr32_f64_add_return_nan>:
8000b674:	3f fa       	mov	r10,-1
8000b676:	3f fb       	mov	r11,-1
8000b678:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b67c <__avr32_f64_add_longshift>:
8000b67c:	f1 b6 04 c0 	satu	r6,0x6
8000b680:	f0 0e 17 00 	moveq	lr,r8
8000b684:	c0 60       	breq	8000b690 <__avr32_f64_add_longshift+0x14>
8000b686:	f2 05 09 4e 	lsl	lr,r9,r5
8000b68a:	58 08       	cp.w	r8,0
8000b68c:	5f 18       	srne	r8
8000b68e:	10 4e       	or	lr,r8
8000b690:	f2 06 0a 48 	lsr	r8,r9,r6
8000b694:	30 09       	mov	r9,0
8000b696:	cc 8b       	rjmp	8000b626 <__avr32_f64_add_shift_done>

8000b698 <__avr32_f64_add_res_of>:
8000b698:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b69c:	a1 9b       	lsr	r11,0x1
8000b69e:	5d 0a       	ror	r10
8000b6a0:	5d 0e       	ror	lr
8000b6a2:	2f f7       	sub	r7,-1
8000b6a4:	e0 47 07 ff 	cp.w	r7,2047
8000b6a8:	f9 ba 00 00 	moveq	r10,0
8000b6ac:	f9 bb 00 00 	moveq	r11,0
8000b6b0:	f9 be 00 00 	moveq	lr,0
8000b6b4:	cb fb       	rjmp	8000b632 <__avr32_f64_add_res_of_done>

8000b6b6 <__avr32_f64_add_op2_subnormal>:
8000b6b6:	30 16       	mov	r6,1
8000b6b8:	58 07       	cp.w	r7,0
8000b6ba:	ca 01       	brne	8000b5fa <__avr32_f64_add+0x3e>
8000b6bc:	b5 cb       	cbr	r11,0x14
8000b6be:	10 0a       	add	r10,r8
8000b6c0:	f6 09 00 4b 	adc	r11,r11,r9
8000b6c4:	18 4b       	or	r11,r12
8000b6c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b6ca:	d7 03       	nop

8000b6cc <__avr32_f64_to_u32>:
8000b6cc:	58 0b       	cp.w	r11,0
8000b6ce:	5e 6d       	retmi	0

8000b6d0 <__avr32_f64_to_s32>:
8000b6d0:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b6d4:	b5 9c       	lsr	r12,0x15
8000b6d6:	e0 2c 03 ff 	sub	r12,1023
8000b6da:	5e 3d       	retlo	0
8000b6dc:	f8 0c 11 1f 	rsub	r12,r12,31
8000b6e0:	16 99       	mov	r9,r11
8000b6e2:	ab 7b       	lsl	r11,0xb
8000b6e4:	bf bb       	sbr	r11,0x1f
8000b6e6:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b6ea:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b6ee:	a1 79       	lsl	r9,0x1
8000b6f0:	5e 2b       	reths	r11
8000b6f2:	5c 3b       	neg	r11
8000b6f4:	5e fb       	retal	r11

8000b6f6 <__avr32_u32_to_f64>:
8000b6f6:	f8 cb 00 00 	sub	r11,r12,0
8000b6fa:	30 0c       	mov	r12,0
8000b6fc:	c0 38       	rjmp	8000b702 <__avr32_s32_to_f64+0x4>

8000b6fe <__avr32_s32_to_f64>:
8000b6fe:	18 9b       	mov	r11,r12
8000b700:	5c 4b       	abs	r11
8000b702:	30 0a       	mov	r10,0
8000b704:	5e 0b       	reteq	r11
8000b706:	d4 01       	pushm	lr
8000b708:	e0 69 04 1e 	mov	r9,1054
8000b70c:	f6 08 12 00 	clz	r8,r11
8000b710:	c1 70       	breq	8000b73e <__avr32_s32_to_f64+0x40>
8000b712:	c0 c3       	brcs	8000b72a <__avr32_s32_to_f64+0x2c>
8000b714:	f0 0e 11 20 	rsub	lr,r8,32
8000b718:	f6 08 09 4b 	lsl	r11,r11,r8
8000b71c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b720:	1c 4b       	or	r11,lr
8000b722:	f4 08 09 4a 	lsl	r10,r10,r8
8000b726:	10 19       	sub	r9,r8
8000b728:	c0 b8       	rjmp	8000b73e <__avr32_s32_to_f64+0x40>
8000b72a:	f4 08 12 00 	clz	r8,r10
8000b72e:	f9 b8 03 00 	movlo	r8,0
8000b732:	f7 b8 02 e0 	subhs	r8,-32
8000b736:	f4 08 09 4b 	lsl	r11,r10,r8
8000b73a:	30 0a       	mov	r10,0
8000b73c:	10 19       	sub	r9,r8
8000b73e:	58 09       	cp.w	r9,0
8000b740:	e0 89 00 30 	brgt	8000b7a0 <__avr32_s32_to_f64+0xa2>
8000b744:	5c 39       	neg	r9
8000b746:	2f f9       	sub	r9,-1
8000b748:	e0 49 00 36 	cp.w	r9,54
8000b74c:	c0 43       	brcs	8000b754 <__avr32_s32_to_f64+0x56>
8000b74e:	30 0b       	mov	r11,0
8000b750:	30 0a       	mov	r10,0
8000b752:	c2 68       	rjmp	8000b79e <__avr32_s32_to_f64+0xa0>
8000b754:	2f 69       	sub	r9,-10
8000b756:	f2 08 11 20 	rsub	r8,r9,32
8000b75a:	e0 49 00 20 	cp.w	r9,32
8000b75e:	c0 b2       	brcc	8000b774 <__avr32_s32_to_f64+0x76>
8000b760:	f4 08 09 4e 	lsl	lr,r10,r8
8000b764:	f6 08 09 48 	lsl	r8,r11,r8
8000b768:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b76c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b770:	10 4b       	or	r11,r8
8000b772:	c0 88       	rjmp	8000b782 <__avr32_s32_to_f64+0x84>
8000b774:	f6 08 09 4e 	lsl	lr,r11,r8
8000b778:	14 4e       	or	lr,r10
8000b77a:	16 9a       	mov	r10,r11
8000b77c:	30 0b       	mov	r11,0
8000b77e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b782:	ed ba 00 00 	bld	r10,0x0
8000b786:	c0 92       	brcc	8000b798 <__avr32_s32_to_f64+0x9a>
8000b788:	1c 7e       	tst	lr,lr
8000b78a:	c0 41       	brne	8000b792 <__avr32_s32_to_f64+0x94>
8000b78c:	ed ba 00 01 	bld	r10,0x1
8000b790:	c0 42       	brcc	8000b798 <__avr32_s32_to_f64+0x9a>
8000b792:	2f fa       	sub	r10,-1
8000b794:	f7 bb 02 ff 	subhs	r11,-1
8000b798:	5c fc       	rol	r12
8000b79a:	5d 0b       	ror	r11
8000b79c:	5d 0a       	ror	r10
8000b79e:	d8 02       	popm	pc
8000b7a0:	e0 68 03 ff 	mov	r8,1023
8000b7a4:	ed ba 00 0b 	bld	r10,0xb
8000b7a8:	f7 b8 00 ff 	subeq	r8,-1
8000b7ac:	10 0a       	add	r10,r8
8000b7ae:	5c 0b       	acr	r11
8000b7b0:	f7 b9 03 fe 	sublo	r9,-2
8000b7b4:	e0 49 07 ff 	cp.w	r9,2047
8000b7b8:	c0 55       	brlt	8000b7c2 <__avr32_s32_to_f64+0xc4>
8000b7ba:	30 0a       	mov	r10,0
8000b7bc:	fc 1b ff e0 	movh	r11,0xffe0
8000b7c0:	c0 c8       	rjmp	8000b7d8 <__floatsidf_return_op1>
8000b7c2:	ed bb 00 1f 	bld	r11,0x1f
8000b7c6:	f7 b9 01 01 	subne	r9,1
8000b7ca:	ab 9a       	lsr	r10,0xb
8000b7cc:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b7d0:	a1 7b       	lsl	r11,0x1
8000b7d2:	ab 9b       	lsr	r11,0xb
8000b7d4:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b7d8 <__floatsidf_return_op1>:
8000b7d8:	a1 7c       	lsl	r12,0x1
8000b7da:	5d 0b       	ror	r11
8000b7dc:	d8 02       	popm	pc

8000b7de <__avr32_f64_cmp_eq>:
8000b7de:	10 3a       	cp.w	r10,r8
8000b7e0:	f2 0b 13 00 	cpc	r11,r9
8000b7e4:	c0 80       	breq	8000b7f4 <__avr32_f64_cmp_eq+0x16>
8000b7e6:	a1 7b       	lsl	r11,0x1
8000b7e8:	a1 79       	lsl	r9,0x1
8000b7ea:	14 4b       	or	r11,r10
8000b7ec:	12 4b       	or	r11,r9
8000b7ee:	10 4b       	or	r11,r8
8000b7f0:	5e 0f       	reteq	1
8000b7f2:	5e fd       	retal	0
8000b7f4:	a1 7b       	lsl	r11,0x1
8000b7f6:	fc 1c ff e0 	movh	r12,0xffe0
8000b7fa:	58 0a       	cp.w	r10,0
8000b7fc:	f8 0b 13 00 	cpc	r11,r12
8000b800:	5e 8f       	retls	1
8000b802:	5e fd       	retal	0

8000b804 <__avr32_f64_cmp_ge>:
8000b804:	1a de       	st.w	--sp,lr
8000b806:	1a d7       	st.w	--sp,r7
8000b808:	a1 7b       	lsl	r11,0x1
8000b80a:	5f 3c       	srlo	r12
8000b80c:	a1 79       	lsl	r9,0x1
8000b80e:	5f 37       	srlo	r7
8000b810:	5c fc       	rol	r12
8000b812:	fc 1e ff e0 	movh	lr,0xffe0
8000b816:	58 0a       	cp.w	r10,0
8000b818:	fc 0b 13 00 	cpc	r11,lr
8000b81c:	e0 8b 00 1d 	brhi	8000b856 <__avr32_f64_cmp_ge+0x52>
8000b820:	58 08       	cp.w	r8,0
8000b822:	fc 09 13 00 	cpc	r9,lr
8000b826:	e0 8b 00 18 	brhi	8000b856 <__avr32_f64_cmp_ge+0x52>
8000b82a:	58 0b       	cp.w	r11,0
8000b82c:	f5 ba 00 00 	subfeq	r10,0
8000b830:	c1 50       	breq	8000b85a <__avr32_f64_cmp_ge+0x56>
8000b832:	1b 07       	ld.w	r7,sp++
8000b834:	1b 0e       	ld.w	lr,sp++
8000b836:	58 3c       	cp.w	r12,3
8000b838:	c0 a0       	breq	8000b84c <__avr32_f64_cmp_ge+0x48>
8000b83a:	58 1c       	cp.w	r12,1
8000b83c:	c0 33       	brcs	8000b842 <__avr32_f64_cmp_ge+0x3e>
8000b83e:	5e 0f       	reteq	1
8000b840:	5e 1d       	retne	0
8000b842:	10 3a       	cp.w	r10,r8
8000b844:	f2 0b 13 00 	cpc	r11,r9
8000b848:	5e 2f       	reths	1
8000b84a:	5e 3d       	retlo	0
8000b84c:	14 38       	cp.w	r8,r10
8000b84e:	f6 09 13 00 	cpc	r9,r11
8000b852:	5e 2f       	reths	1
8000b854:	5e 3d       	retlo	0
8000b856:	1b 07       	ld.w	r7,sp++
8000b858:	d8 0a       	popm	pc,r12=0
8000b85a:	58 17       	cp.w	r7,1
8000b85c:	5f 0c       	sreq	r12
8000b85e:	58 09       	cp.w	r9,0
8000b860:	f5 b8 00 00 	subfeq	r8,0
8000b864:	1b 07       	ld.w	r7,sp++
8000b866:	1b 0e       	ld.w	lr,sp++
8000b868:	5e 0f       	reteq	1
8000b86a:	5e fc       	retal	r12

8000b86c <__avr32_f64_cmp_lt>:
8000b86c:	1a de       	st.w	--sp,lr
8000b86e:	1a d7       	st.w	--sp,r7
8000b870:	a1 7b       	lsl	r11,0x1
8000b872:	5f 3c       	srlo	r12
8000b874:	a1 79       	lsl	r9,0x1
8000b876:	5f 37       	srlo	r7
8000b878:	5c fc       	rol	r12
8000b87a:	fc 1e ff e0 	movh	lr,0xffe0
8000b87e:	58 0a       	cp.w	r10,0
8000b880:	fc 0b 13 00 	cpc	r11,lr
8000b884:	e0 8b 00 1d 	brhi	8000b8be <__avr32_f64_cmp_lt+0x52>
8000b888:	58 08       	cp.w	r8,0
8000b88a:	fc 09 13 00 	cpc	r9,lr
8000b88e:	e0 8b 00 18 	brhi	8000b8be <__avr32_f64_cmp_lt+0x52>
8000b892:	58 0b       	cp.w	r11,0
8000b894:	f5 ba 00 00 	subfeq	r10,0
8000b898:	c1 50       	breq	8000b8c2 <__avr32_f64_cmp_lt+0x56>
8000b89a:	1b 07       	ld.w	r7,sp++
8000b89c:	1b 0e       	ld.w	lr,sp++
8000b89e:	58 3c       	cp.w	r12,3
8000b8a0:	c0 a0       	breq	8000b8b4 <__avr32_f64_cmp_lt+0x48>
8000b8a2:	58 1c       	cp.w	r12,1
8000b8a4:	c0 33       	brcs	8000b8aa <__avr32_f64_cmp_lt+0x3e>
8000b8a6:	5e 0d       	reteq	0
8000b8a8:	5e 1f       	retne	1
8000b8aa:	10 3a       	cp.w	r10,r8
8000b8ac:	f2 0b 13 00 	cpc	r11,r9
8000b8b0:	5e 2d       	reths	0
8000b8b2:	5e 3f       	retlo	1
8000b8b4:	14 38       	cp.w	r8,r10
8000b8b6:	f6 09 13 00 	cpc	r9,r11
8000b8ba:	5e 2d       	reths	0
8000b8bc:	5e 3f       	retlo	1
8000b8be:	1b 07       	ld.w	r7,sp++
8000b8c0:	d8 0a       	popm	pc,r12=0
8000b8c2:	58 17       	cp.w	r7,1
8000b8c4:	5f 1c       	srne	r12
8000b8c6:	58 09       	cp.w	r9,0
8000b8c8:	f5 b8 00 00 	subfeq	r8,0
8000b8cc:	1b 07       	ld.w	r7,sp++
8000b8ce:	1b 0e       	ld.w	lr,sp++
8000b8d0:	5e 0d       	reteq	0
8000b8d2:	5e fc       	retal	r12

8000b8d4 <__avr32_f64_div>:
8000b8d4:	eb cd 40 ff 	pushm	r0-r7,lr
8000b8d8:	f7 e9 20 0e 	eor	lr,r11,r9
8000b8dc:	f6 07 16 14 	lsr	r7,r11,0x14
8000b8e0:	a9 7b       	lsl	r11,0x9
8000b8e2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b8e6:	a9 7a       	lsl	r10,0x9
8000b8e8:	bd bb       	sbr	r11,0x1d
8000b8ea:	e4 1b 3f ff 	andh	r11,0x3fff
8000b8ee:	ab d7       	cbr	r7,0xb
8000b8f0:	e0 80 00 cc 	breq	8000ba88 <__avr32_f64_div_round_subnormal+0x54>
8000b8f4:	e0 47 07 ff 	cp.w	r7,2047
8000b8f8:	e0 84 00 b5 	brge	8000ba62 <__avr32_f64_div_round_subnormal+0x2e>
8000b8fc:	f2 06 16 14 	lsr	r6,r9,0x14
8000b900:	a9 79       	lsl	r9,0x9
8000b902:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b906:	a9 78       	lsl	r8,0x9
8000b908:	bd b9       	sbr	r9,0x1d
8000b90a:	e4 19 3f ff 	andh	r9,0x3fff
8000b90e:	ab d6       	cbr	r6,0xb
8000b910:	e0 80 00 e2 	breq	8000bad4 <__avr32_f64_div_round_subnormal+0xa0>
8000b914:	e0 46 07 ff 	cp.w	r6,2047
8000b918:	e0 84 00 b2 	brge	8000ba7c <__avr32_f64_div_round_subnormal+0x48>
8000b91c:	0c 17       	sub	r7,r6
8000b91e:	fe 37 fc 01 	sub	r7,-1023
8000b922:	fc 1c 80 00 	movh	r12,0x8000
8000b926:	f8 03 16 01 	lsr	r3,r12,0x1
8000b92a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b92e:	5c d4       	com	r4
8000b930:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b934:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b938:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b93c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b940:	ea 03 15 02 	lsl	r3,r5,0x2
8000b944:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b948:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b94c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b950:	ea 03 15 02 	lsl	r3,r5,0x2
8000b954:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b958:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b95c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b960:	ea 03 15 02 	lsl	r3,r5,0x2
8000b964:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b968:	e4 09 07 40 	macu.d	r0,r2,r9
8000b96c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b970:	02 04       	add	r4,r1
8000b972:	5c 05       	acr	r5
8000b974:	a3 65       	lsl	r5,0x2
8000b976:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b97a:	a3 64       	lsl	r4,0x2
8000b97c:	5c 34       	neg	r4
8000b97e:	f8 05 01 45 	sbc	r5,r12,r5
8000b982:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b986:	e4 05 07 40 	macu.d	r0,r2,r5
8000b98a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b98e:	02 04       	add	r4,r1
8000b990:	5c 05       	acr	r5
8000b992:	ea 03 15 02 	lsl	r3,r5,0x2
8000b996:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b99a:	e8 02 15 02 	lsl	r2,r4,0x2
8000b99e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b9a2:	e4 09 07 40 	macu.d	r0,r2,r9
8000b9a6:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b9aa:	02 04       	add	r4,r1
8000b9ac:	5c 05       	acr	r5
8000b9ae:	a3 65       	lsl	r5,0x2
8000b9b0:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b9b4:	a3 64       	lsl	r4,0x2
8000b9b6:	5c 34       	neg	r4
8000b9b8:	f8 05 01 45 	sbc	r5,r12,r5
8000b9bc:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b9c0:	e4 05 07 40 	macu.d	r0,r2,r5
8000b9c4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b9c8:	02 04       	add	r4,r1
8000b9ca:	5c 05       	acr	r5
8000b9cc:	ea 03 15 02 	lsl	r3,r5,0x2
8000b9d0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b9d4:	e8 02 15 02 	lsl	r2,r4,0x2
8000b9d8:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b9dc:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b9e0:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b9e4:	02 02       	add	r2,r1
8000b9e6:	5c 03       	acr	r3
8000b9e8:	ed b3 00 1c 	bld	r3,0x1c
8000b9ec:	c0 90       	breq	8000b9fe <__avr32_f64_div+0x12a>
8000b9ee:	a1 72       	lsl	r2,0x1
8000b9f0:	5c f3       	rol	r3
8000b9f2:	20 17       	sub	r7,1
8000b9f4:	a3 9a       	lsr	r10,0x3
8000b9f6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b9fa:	a3 9b       	lsr	r11,0x3
8000b9fc:	c0 58       	rjmp	8000ba06 <__avr32_f64_div+0x132>
8000b9fe:	a5 8a       	lsr	r10,0x4
8000ba00:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000ba04:	a5 8b       	lsr	r11,0x4
8000ba06:	58 07       	cp.w	r7,0
8000ba08:	e0 8a 00 8b 	brle	8000bb1e <__avr32_f64_div_res_subnormal>
8000ba0c:	e0 12 ff 00 	andl	r2,0xff00
8000ba10:	e8 12 00 80 	orl	r2,0x80
8000ba14:	e6 08 06 40 	mulu.d	r0,r3,r8
8000ba18:	e4 09 07 40 	macu.d	r0,r2,r9
8000ba1c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000ba20:	e6 09 06 48 	mulu.d	r8,r3,r9
8000ba24:	00 05       	add	r5,r0
8000ba26:	f0 01 00 48 	adc	r8,r8,r1
8000ba2a:	5c 09       	acr	r9
8000ba2c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000ba30:	58 04       	cp.w	r4,0
8000ba32:	5c 25       	cpc	r5

8000ba34 <__avr32_f64_div_round_subnormal>:
8000ba34:	f4 08 13 00 	cpc	r8,r10
8000ba38:	f6 09 13 00 	cpc	r9,r11
8000ba3c:	5f 36       	srlo	r6
8000ba3e:	f8 06 17 00 	moveq	r6,r12
8000ba42:	e4 0a 16 08 	lsr	r10,r2,0x8
8000ba46:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000ba4a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000ba4e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ba52:	ed be 00 1f 	bld	lr,0x1f
8000ba56:	ef bb 00 1f 	bst	r11,0x1f
8000ba5a:	0c 0a       	add	r10,r6
8000ba5c:	5c 0b       	acr	r11
8000ba5e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000ba62:	e4 1b 00 0f 	andh	r11,0xf
8000ba66:	14 4b       	or	r11,r10
8000ba68:	e0 81 00 a7 	brne	8000bbb6 <__avr32_f64_div_res_subnormal+0x98>
8000ba6c:	f2 06 16 14 	lsr	r6,r9,0x14
8000ba70:	ab d6       	cbr	r6,0xb
8000ba72:	e0 46 07 ff 	cp.w	r6,2047
8000ba76:	e0 81 00 a4 	brne	8000bbbe <__avr32_f64_div_res_subnormal+0xa0>
8000ba7a:	c9 e8       	rjmp	8000bbb6 <__avr32_f64_div_res_subnormal+0x98>
8000ba7c:	e4 19 00 0f 	andh	r9,0xf
8000ba80:	10 49       	or	r9,r8
8000ba82:	e0 81 00 9a 	brne	8000bbb6 <__avr32_f64_div_res_subnormal+0x98>
8000ba86:	c9 28       	rjmp	8000bbaa <__avr32_f64_div_res_subnormal+0x8c>
8000ba88:	a3 7b       	lsl	r11,0x3
8000ba8a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000ba8e:	a3 7a       	lsl	r10,0x3
8000ba90:	f5 eb 10 04 	or	r4,r10,r11
8000ba94:	e0 80 00 a0 	breq	8000bbd4 <__avr32_f64_div_op1_zero>
8000ba98:	f6 04 12 00 	clz	r4,r11
8000ba9c:	c1 70       	breq	8000baca <__avr32_f64_div_round_subnormal+0x96>
8000ba9e:	c0 c3       	brcs	8000bab6 <__avr32_f64_div_round_subnormal+0x82>
8000baa0:	e8 05 11 20 	rsub	r5,r4,32
8000baa4:	f6 04 09 4b 	lsl	r11,r11,r4
8000baa8:	f4 05 0a 45 	lsr	r5,r10,r5
8000baac:	0a 4b       	or	r11,r5
8000baae:	f4 04 09 4a 	lsl	r10,r10,r4
8000bab2:	08 17       	sub	r7,r4
8000bab4:	c0 b8       	rjmp	8000baca <__avr32_f64_div_round_subnormal+0x96>
8000bab6:	f4 04 12 00 	clz	r4,r10
8000baba:	f9 b4 03 00 	movlo	r4,0
8000babe:	f7 b4 02 e0 	subhs	r4,-32
8000bac2:	f4 04 09 4b 	lsl	r11,r10,r4
8000bac6:	30 0a       	mov	r10,0
8000bac8:	08 17       	sub	r7,r4
8000baca:	a3 8a       	lsr	r10,0x2
8000bacc:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000bad0:	a3 8b       	lsr	r11,0x2
8000bad2:	c1 1b       	rjmp	8000b8f4 <__avr32_f64_div+0x20>
8000bad4:	a3 79       	lsl	r9,0x3
8000bad6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bada:	a3 78       	lsl	r8,0x3
8000badc:	f3 e8 10 04 	or	r4,r9,r8
8000bae0:	c6 f0       	breq	8000bbbe <__avr32_f64_div_res_subnormal+0xa0>
8000bae2:	f2 04 12 00 	clz	r4,r9
8000bae6:	c1 70       	breq	8000bb14 <__avr32_f64_div_round_subnormal+0xe0>
8000bae8:	c0 c3       	brcs	8000bb00 <__avr32_f64_div_round_subnormal+0xcc>
8000baea:	e8 05 11 20 	rsub	r5,r4,32
8000baee:	f2 04 09 49 	lsl	r9,r9,r4
8000baf2:	f0 05 0a 45 	lsr	r5,r8,r5
8000baf6:	0a 49       	or	r9,r5
8000baf8:	f0 04 09 48 	lsl	r8,r8,r4
8000bafc:	08 16       	sub	r6,r4
8000bafe:	c0 b8       	rjmp	8000bb14 <__avr32_f64_div_round_subnormal+0xe0>
8000bb00:	f0 04 12 00 	clz	r4,r8
8000bb04:	f9 b4 03 00 	movlo	r4,0
8000bb08:	f7 b4 02 e0 	subhs	r4,-32
8000bb0c:	f0 04 09 49 	lsl	r9,r8,r4
8000bb10:	30 08       	mov	r8,0
8000bb12:	08 16       	sub	r6,r4
8000bb14:	a3 88       	lsr	r8,0x2
8000bb16:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000bb1a:	a3 89       	lsr	r9,0x2
8000bb1c:	cf ca       	rjmp	8000b914 <__avr32_f64_div+0x40>

8000bb1e <__avr32_f64_div_res_subnormal>:
8000bb1e:	5c 37       	neg	r7
8000bb20:	2f f7       	sub	r7,-1
8000bb22:	f1 b7 04 c0 	satu	r7,0x6
8000bb26:	e0 47 00 20 	cp.w	r7,32
8000bb2a:	c1 54       	brge	8000bb54 <__avr32_f64_div_res_subnormal+0x36>
8000bb2c:	ee 06 11 20 	rsub	r6,r7,32
8000bb30:	e4 07 0a 42 	lsr	r2,r2,r7
8000bb34:	e6 06 09 4c 	lsl	r12,r3,r6
8000bb38:	18 42       	or	r2,r12
8000bb3a:	e6 07 0a 43 	lsr	r3,r3,r7
8000bb3e:	f4 06 09 41 	lsl	r1,r10,r6
8000bb42:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bb46:	f6 06 09 4c 	lsl	r12,r11,r6
8000bb4a:	18 4a       	or	r10,r12
8000bb4c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bb50:	30 00       	mov	r0,0
8000bb52:	c1 58       	rjmp	8000bb7c <__avr32_f64_div_res_subnormal+0x5e>
8000bb54:	ee 06 11 20 	rsub	r6,r7,32
8000bb58:	f9 b0 00 00 	moveq	r0,0
8000bb5c:	f9 bc 00 00 	moveq	r12,0
8000bb60:	c0 50       	breq	8000bb6a <__avr32_f64_div_res_subnormal+0x4c>
8000bb62:	f4 06 09 40 	lsl	r0,r10,r6
8000bb66:	f6 06 09 4c 	lsl	r12,r11,r6
8000bb6a:	e6 07 0a 42 	lsr	r2,r3,r7
8000bb6e:	30 03       	mov	r3,0
8000bb70:	f4 07 0a 41 	lsr	r1,r10,r7
8000bb74:	18 41       	or	r1,r12
8000bb76:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bb7a:	30 0b       	mov	r11,0
8000bb7c:	e0 12 ff 00 	andl	r2,0xff00
8000bb80:	e8 12 00 80 	orl	r2,0x80
8000bb84:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bb88:	e4 09 07 46 	macu.d	r6,r2,r9
8000bb8c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bb90:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bb94:	0c 05       	add	r5,r6
8000bb96:	f0 07 00 48 	adc	r8,r8,r7
8000bb9a:	5c 09       	acr	r9
8000bb9c:	30 07       	mov	r7,0
8000bb9e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bba2:	00 34       	cp.w	r4,r0
8000bba4:	e2 05 13 00 	cpc	r5,r1
8000bba8:	c4 6b       	rjmp	8000ba34 <__avr32_f64_div_round_subnormal>
8000bbaa:	1c 9b       	mov	r11,lr
8000bbac:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bbb0:	30 0a       	mov	r10,0
8000bbb2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bbb6:	3f fb       	mov	r11,-1
8000bbb8:	30 0a       	mov	r10,0
8000bbba:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bbbe:	f5 eb 10 04 	or	r4,r10,r11
8000bbc2:	c0 90       	breq	8000bbd4 <__avr32_f64_div_op1_zero>
8000bbc4:	1c 9b       	mov	r11,lr
8000bbc6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bbca:	ea 1b 7f f0 	orh	r11,0x7ff0
8000bbce:	30 0a       	mov	r10,0
8000bbd0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000bbd4 <__avr32_f64_div_op1_zero>:
8000bbd4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000bbd8:	ce f0       	breq	8000bbb6 <__avr32_f64_div_res_subnormal+0x98>
8000bbda:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bbde:	e0 44 07 ff 	cp.w	r4,2047
8000bbe2:	ce 41       	brne	8000bbaa <__avr32_f64_div_res_subnormal+0x8c>
8000bbe4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000bbe8:	ce 10       	breq	8000bbaa <__avr32_f64_div_res_subnormal+0x8c>
8000bbea:	ce 6b       	rjmp	8000bbb6 <__avr32_f64_div_res_subnormal+0x98>

8000bbec <__avr32_udiv64>:
8000bbec:	d4 31       	pushm	r0-r7,lr
8000bbee:	1a 97       	mov	r7,sp
8000bbf0:	20 3d       	sub	sp,12
8000bbf2:	10 9c       	mov	r12,r8
8000bbf4:	12 9e       	mov	lr,r9
8000bbf6:	14 93       	mov	r3,r10
8000bbf8:	58 09       	cp.w	r9,0
8000bbfa:	e0 81 00 bd 	brne	8000bd74 <__avr32_udiv64+0x188>
8000bbfe:	16 38       	cp.w	r8,r11
8000bc00:	e0 88 00 40 	brls	8000bc80 <__avr32_udiv64+0x94>
8000bc04:	f0 08 12 00 	clz	r8,r8
8000bc08:	c0 d0       	breq	8000bc22 <__avr32_udiv64+0x36>
8000bc0a:	f6 08 09 4b 	lsl	r11,r11,r8
8000bc0e:	f0 09 11 20 	rsub	r9,r8,32
8000bc12:	f8 08 09 4c 	lsl	r12,r12,r8
8000bc16:	f4 09 0a 49 	lsr	r9,r10,r9
8000bc1a:	f4 08 09 43 	lsl	r3,r10,r8
8000bc1e:	f3 eb 10 0b 	or	r11,r9,r11
8000bc22:	f8 0e 16 10 	lsr	lr,r12,0x10
8000bc26:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000bc2a:	f6 0e 0d 00 	divu	r0,r11,lr
8000bc2e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bc32:	00 99       	mov	r9,r0
8000bc34:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bc38:	e0 0a 02 48 	mul	r8,r0,r10
8000bc3c:	10 3b       	cp.w	r11,r8
8000bc3e:	c0 a2       	brcc	8000bc52 <__avr32_udiv64+0x66>
8000bc40:	20 19       	sub	r9,1
8000bc42:	18 0b       	add	r11,r12
8000bc44:	18 3b       	cp.w	r11,r12
8000bc46:	c0 63       	brcs	8000bc52 <__avr32_udiv64+0x66>
8000bc48:	10 3b       	cp.w	r11,r8
8000bc4a:	f7 b9 03 01 	sublo	r9,1
8000bc4e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bc52:	f6 08 01 01 	sub	r1,r11,r8
8000bc56:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bc5a:	e2 0e 0d 00 	divu	r0,r1,lr
8000bc5e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bc62:	00 98       	mov	r8,r0
8000bc64:	e0 0a 02 4a 	mul	r10,r0,r10
8000bc68:	14 33       	cp.w	r3,r10
8000bc6a:	c0 82       	brcc	8000bc7a <__avr32_udiv64+0x8e>
8000bc6c:	20 18       	sub	r8,1
8000bc6e:	18 03       	add	r3,r12
8000bc70:	18 33       	cp.w	r3,r12
8000bc72:	c0 43       	brcs	8000bc7a <__avr32_udiv64+0x8e>
8000bc74:	14 33       	cp.w	r3,r10
8000bc76:	f7 b8 03 01 	sublo	r8,1
8000bc7a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000bc7e:	cd f8       	rjmp	8000be3c <__avr32_udiv64+0x250>
8000bc80:	58 08       	cp.w	r8,0
8000bc82:	c0 51       	brne	8000bc8c <__avr32_udiv64+0xa0>
8000bc84:	30 19       	mov	r9,1
8000bc86:	f2 08 0d 08 	divu	r8,r9,r8
8000bc8a:	10 9c       	mov	r12,r8
8000bc8c:	f8 06 12 00 	clz	r6,r12
8000bc90:	c0 41       	brne	8000bc98 <__avr32_udiv64+0xac>
8000bc92:	18 1b       	sub	r11,r12
8000bc94:	30 19       	mov	r9,1
8000bc96:	c4 08       	rjmp	8000bd16 <__avr32_udiv64+0x12a>
8000bc98:	ec 01 11 20 	rsub	r1,r6,32
8000bc9c:	f4 01 0a 49 	lsr	r9,r10,r1
8000bca0:	f8 06 09 4c 	lsl	r12,r12,r6
8000bca4:	f6 06 09 48 	lsl	r8,r11,r6
8000bca8:	f6 01 0a 41 	lsr	r1,r11,r1
8000bcac:	f3 e8 10 08 	or	r8,r9,r8
8000bcb0:	f8 03 16 10 	lsr	r3,r12,0x10
8000bcb4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bcb8:	e2 03 0d 00 	divu	r0,r1,r3
8000bcbc:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bcc0:	00 9e       	mov	lr,r0
8000bcc2:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bcc6:	e0 05 02 49 	mul	r9,r0,r5
8000bcca:	12 3b       	cp.w	r11,r9
8000bccc:	c0 a2       	brcc	8000bce0 <__avr32_udiv64+0xf4>
8000bcce:	20 1e       	sub	lr,1
8000bcd0:	18 0b       	add	r11,r12
8000bcd2:	18 3b       	cp.w	r11,r12
8000bcd4:	c0 63       	brcs	8000bce0 <__avr32_udiv64+0xf4>
8000bcd6:	12 3b       	cp.w	r11,r9
8000bcd8:	f7 be 03 01 	sublo	lr,1
8000bcdc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bce0:	12 1b       	sub	r11,r9
8000bce2:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000bce6:	f6 03 0d 02 	divu	r2,r11,r3
8000bcea:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000bcee:	04 99       	mov	r9,r2
8000bcf0:	e4 05 02 4b 	mul	r11,r2,r5
8000bcf4:	16 38       	cp.w	r8,r11
8000bcf6:	c0 a2       	brcc	8000bd0a <__avr32_udiv64+0x11e>
8000bcf8:	20 19       	sub	r9,1
8000bcfa:	18 08       	add	r8,r12
8000bcfc:	18 38       	cp.w	r8,r12
8000bcfe:	c0 63       	brcs	8000bd0a <__avr32_udiv64+0x11e>
8000bd00:	16 38       	cp.w	r8,r11
8000bd02:	f7 b9 03 01 	sublo	r9,1
8000bd06:	f1 dc e3 08 	addcs	r8,r8,r12
8000bd0a:	f4 06 09 43 	lsl	r3,r10,r6
8000bd0e:	f0 0b 01 0b 	sub	r11,r8,r11
8000bd12:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000bd16:	f8 06 16 10 	lsr	r6,r12,0x10
8000bd1a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000bd1e:	f6 06 0d 00 	divu	r0,r11,r6
8000bd22:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bd26:	00 9a       	mov	r10,r0
8000bd28:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bd2c:	e0 0e 02 48 	mul	r8,r0,lr
8000bd30:	10 3b       	cp.w	r11,r8
8000bd32:	c0 a2       	brcc	8000bd46 <__avr32_udiv64+0x15a>
8000bd34:	20 1a       	sub	r10,1
8000bd36:	18 0b       	add	r11,r12
8000bd38:	18 3b       	cp.w	r11,r12
8000bd3a:	c0 63       	brcs	8000bd46 <__avr32_udiv64+0x15a>
8000bd3c:	10 3b       	cp.w	r11,r8
8000bd3e:	f7 ba 03 01 	sublo	r10,1
8000bd42:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bd46:	f6 08 01 01 	sub	r1,r11,r8
8000bd4a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bd4e:	e2 06 0d 00 	divu	r0,r1,r6
8000bd52:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bd56:	00 98       	mov	r8,r0
8000bd58:	e0 0e 02 4b 	mul	r11,r0,lr
8000bd5c:	16 33       	cp.w	r3,r11
8000bd5e:	c0 82       	brcc	8000bd6e <__avr32_udiv64+0x182>
8000bd60:	20 18       	sub	r8,1
8000bd62:	18 03       	add	r3,r12
8000bd64:	18 33       	cp.w	r3,r12
8000bd66:	c0 43       	brcs	8000bd6e <__avr32_udiv64+0x182>
8000bd68:	16 33       	cp.w	r3,r11
8000bd6a:	f7 b8 03 01 	sublo	r8,1
8000bd6e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bd72:	c6 98       	rjmp	8000be44 <__avr32_udiv64+0x258>
8000bd74:	16 39       	cp.w	r9,r11
8000bd76:	e0 8b 00 65 	brhi	8000be40 <__avr32_udiv64+0x254>
8000bd7a:	f2 09 12 00 	clz	r9,r9
8000bd7e:	c0 b1       	brne	8000bd94 <__avr32_udiv64+0x1a8>
8000bd80:	10 3a       	cp.w	r10,r8
8000bd82:	5f 2a       	srhs	r10
8000bd84:	1c 3b       	cp.w	r11,lr
8000bd86:	5f b8       	srhi	r8
8000bd88:	10 4a       	or	r10,r8
8000bd8a:	f2 0a 18 00 	cp.b	r10,r9
8000bd8e:	c5 90       	breq	8000be40 <__avr32_udiv64+0x254>
8000bd90:	30 18       	mov	r8,1
8000bd92:	c5 98       	rjmp	8000be44 <__avr32_udiv64+0x258>
8000bd94:	f0 09 09 46 	lsl	r6,r8,r9
8000bd98:	f2 03 11 20 	rsub	r3,r9,32
8000bd9c:	fc 09 09 4e 	lsl	lr,lr,r9
8000bda0:	f0 03 0a 48 	lsr	r8,r8,r3
8000bda4:	f6 09 09 4c 	lsl	r12,r11,r9
8000bda8:	f4 03 0a 42 	lsr	r2,r10,r3
8000bdac:	ef 46 ff f4 	st.w	r7[-12],r6
8000bdb0:	f6 03 0a 43 	lsr	r3,r11,r3
8000bdb4:	18 42       	or	r2,r12
8000bdb6:	f1 ee 10 0c 	or	r12,r8,lr
8000bdba:	f8 01 16 10 	lsr	r1,r12,0x10
8000bdbe:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bdc2:	e6 01 0d 04 	divu	r4,r3,r1
8000bdc6:	e4 03 16 10 	lsr	r3,r2,0x10
8000bdca:	08 9e       	mov	lr,r4
8000bdcc:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bdd0:	e8 06 02 48 	mul	r8,r4,r6
8000bdd4:	10 33       	cp.w	r3,r8
8000bdd6:	c0 a2       	brcc	8000bdea <__avr32_udiv64+0x1fe>
8000bdd8:	20 1e       	sub	lr,1
8000bdda:	18 03       	add	r3,r12
8000bddc:	18 33       	cp.w	r3,r12
8000bdde:	c0 63       	brcs	8000bdea <__avr32_udiv64+0x1fe>
8000bde0:	10 33       	cp.w	r3,r8
8000bde2:	f7 be 03 01 	sublo	lr,1
8000bde6:	e7 dc e3 03 	addcs	r3,r3,r12
8000bdea:	10 13       	sub	r3,r8
8000bdec:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000bdf0:	e6 01 0d 00 	divu	r0,r3,r1
8000bdf4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bdf8:	00 98       	mov	r8,r0
8000bdfa:	e0 06 02 46 	mul	r6,r0,r6
8000bdfe:	0c 3b       	cp.w	r11,r6
8000be00:	c0 a2       	brcc	8000be14 <__avr32_udiv64+0x228>
8000be02:	20 18       	sub	r8,1
8000be04:	18 0b       	add	r11,r12
8000be06:	18 3b       	cp.w	r11,r12
8000be08:	c0 63       	brcs	8000be14 <__avr32_udiv64+0x228>
8000be0a:	0c 3b       	cp.w	r11,r6
8000be0c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000be10:	f7 b8 03 01 	sublo	r8,1
8000be14:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000be18:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000be1c:	0c 1b       	sub	r11,r6
8000be1e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000be22:	06 95       	mov	r5,r3
8000be24:	16 35       	cp.w	r5,r11
8000be26:	e0 8b 00 0a 	brhi	8000be3a <__avr32_udiv64+0x24e>
8000be2a:	5f 0b       	sreq	r11
8000be2c:	f4 09 09 49 	lsl	r9,r10,r9
8000be30:	12 32       	cp.w	r2,r9
8000be32:	5f b9       	srhi	r9
8000be34:	f7 e9 00 09 	and	r9,r11,r9
8000be38:	c0 60       	breq	8000be44 <__avr32_udiv64+0x258>
8000be3a:	20 18       	sub	r8,1
8000be3c:	30 09       	mov	r9,0
8000be3e:	c0 38       	rjmp	8000be44 <__avr32_udiv64+0x258>
8000be40:	30 09       	mov	r9,0
8000be42:	12 98       	mov	r8,r9
8000be44:	10 9a       	mov	r10,r8
8000be46:	12 93       	mov	r3,r9
8000be48:	10 92       	mov	r2,r8
8000be4a:	12 9b       	mov	r11,r9
8000be4c:	2f dd       	sub	sp,-12
8000be4e:	d8 32       	popm	r0-r7,pc

8000be50 <__avr32_umod64>:
8000be50:	d4 31       	pushm	r0-r7,lr
8000be52:	1a 97       	mov	r7,sp
8000be54:	20 3d       	sub	sp,12
8000be56:	10 9c       	mov	r12,r8
8000be58:	12 95       	mov	r5,r9
8000be5a:	14 9e       	mov	lr,r10
8000be5c:	16 91       	mov	r1,r11
8000be5e:	16 96       	mov	r6,r11
8000be60:	58 09       	cp.w	r9,0
8000be62:	e0 81 00 81 	brne	8000bf64 <__avr32_umod64+0x114>
8000be66:	16 38       	cp.w	r8,r11
8000be68:	e0 88 00 12 	brls	8000be8c <__avr32_umod64+0x3c>
8000be6c:	f0 08 12 00 	clz	r8,r8
8000be70:	c4 e0       	breq	8000bf0c <__avr32_umod64+0xbc>
8000be72:	f6 08 09 46 	lsl	r6,r11,r8
8000be76:	f8 08 09 4c 	lsl	r12,r12,r8
8000be7a:	f0 0b 11 20 	rsub	r11,r8,32
8000be7e:	f4 08 09 4e 	lsl	lr,r10,r8
8000be82:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000be86:	f7 e6 10 06 	or	r6,r11,r6
8000be8a:	c4 18       	rjmp	8000bf0c <__avr32_umod64+0xbc>
8000be8c:	58 08       	cp.w	r8,0
8000be8e:	c0 51       	brne	8000be98 <__avr32_umod64+0x48>
8000be90:	30 19       	mov	r9,1
8000be92:	f2 08 0d 08 	divu	r8,r9,r8
8000be96:	10 9c       	mov	r12,r8
8000be98:	f8 08 12 00 	clz	r8,r12
8000be9c:	c0 31       	brne	8000bea2 <__avr32_umod64+0x52>
8000be9e:	18 16       	sub	r6,r12
8000bea0:	c3 68       	rjmp	8000bf0c <__avr32_umod64+0xbc>
8000bea2:	f0 03 11 20 	rsub	r3,r8,32
8000bea6:	f4 03 0a 4b 	lsr	r11,r10,r3
8000beaa:	f8 08 09 4c 	lsl	r12,r12,r8
8000beae:	ec 08 09 49 	lsl	r9,r6,r8
8000beb2:	ec 03 0a 43 	lsr	r3,r6,r3
8000beb6:	f7 e9 10 09 	or	r9,r11,r9
8000beba:	f8 05 16 10 	lsr	r5,r12,0x10
8000bebe:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bec2:	e6 05 0d 02 	divu	r2,r3,r5
8000bec6:	f2 0e 16 10 	lsr	lr,r9,0x10
8000beca:	ec 02 02 4b 	mul	r11,r6,r2
8000bece:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bed2:	16 3e       	cp.w	lr,r11
8000bed4:	c0 72       	brcc	8000bee2 <__avr32_umod64+0x92>
8000bed6:	18 0e       	add	lr,r12
8000bed8:	18 3e       	cp.w	lr,r12
8000beda:	c0 43       	brcs	8000bee2 <__avr32_umod64+0x92>
8000bedc:	16 3e       	cp.w	lr,r11
8000bede:	fd dc e3 0e 	addcs	lr,lr,r12
8000bee2:	fc 0b 01 03 	sub	r3,lr,r11
8000bee6:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000beea:	e6 05 0d 02 	divu	r2,r3,r5
8000beee:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bef2:	a5 36       	mul	r6,r2
8000bef4:	0c 39       	cp.w	r9,r6
8000bef6:	c0 72       	brcc	8000bf04 <__avr32_umod64+0xb4>
8000bef8:	18 09       	add	r9,r12
8000befa:	18 39       	cp.w	r9,r12
8000befc:	c0 43       	brcs	8000bf04 <__avr32_umod64+0xb4>
8000befe:	0c 39       	cp.w	r9,r6
8000bf00:	f3 dc e3 09 	addcs	r9,r9,r12
8000bf04:	f2 06 01 06 	sub	r6,r9,r6
8000bf08:	f4 08 09 4e 	lsl	lr,r10,r8
8000bf0c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bf10:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bf14:	ec 0a 0d 02 	divu	r2,r6,r10
8000bf18:	fc 09 16 10 	lsr	r9,lr,0x10
8000bf1c:	ea 02 02 4b 	mul	r11,r5,r2
8000bf20:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bf24:	16 39       	cp.w	r9,r11
8000bf26:	c0 72       	brcc	8000bf34 <__avr32_umod64+0xe4>
8000bf28:	18 09       	add	r9,r12
8000bf2a:	18 39       	cp.w	r9,r12
8000bf2c:	c0 43       	brcs	8000bf34 <__avr32_umod64+0xe4>
8000bf2e:	16 39       	cp.w	r9,r11
8000bf30:	f3 dc e3 09 	addcs	r9,r9,r12
8000bf34:	f2 0b 01 0b 	sub	r11,r9,r11
8000bf38:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bf3c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bf40:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bf44:	ea 0a 02 4a 	mul	r10,r5,r10
8000bf48:	14 3e       	cp.w	lr,r10
8000bf4a:	c0 72       	brcc	8000bf58 <__avr32_umod64+0x108>
8000bf4c:	18 0e       	add	lr,r12
8000bf4e:	18 3e       	cp.w	lr,r12
8000bf50:	c0 43       	brcs	8000bf58 <__avr32_umod64+0x108>
8000bf52:	14 3e       	cp.w	lr,r10
8000bf54:	fd dc e3 0e 	addcs	lr,lr,r12
8000bf58:	fc 0a 01 0a 	sub	r10,lr,r10
8000bf5c:	30 0b       	mov	r11,0
8000bf5e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bf62:	c7 b8       	rjmp	8000c058 <__avr32_umod64+0x208>
8000bf64:	16 39       	cp.w	r9,r11
8000bf66:	e0 8b 00 79 	brhi	8000c058 <__avr32_umod64+0x208>
8000bf6a:	f2 09 12 00 	clz	r9,r9
8000bf6e:	c1 21       	brne	8000bf92 <__avr32_umod64+0x142>
8000bf70:	10 3a       	cp.w	r10,r8
8000bf72:	5f 2b       	srhs	r11
8000bf74:	0a 31       	cp.w	r1,r5
8000bf76:	5f ba       	srhi	r10
8000bf78:	f7 ea 10 0a 	or	r10,r11,r10
8000bf7c:	f2 0a 18 00 	cp.b	r10,r9
8000bf80:	c0 60       	breq	8000bf8c <__avr32_umod64+0x13c>
8000bf82:	fc 08 01 0c 	sub	r12,lr,r8
8000bf86:	e2 05 01 46 	sbc	r6,r1,r5
8000bf8a:	18 9e       	mov	lr,r12
8000bf8c:	0c 9b       	mov	r11,r6
8000bf8e:	1c 9a       	mov	r10,lr
8000bf90:	c6 48       	rjmp	8000c058 <__avr32_umod64+0x208>
8000bf92:	ea 09 09 4c 	lsl	r12,r5,r9
8000bf96:	f2 06 11 20 	rsub	r6,r9,32
8000bf9a:	f6 09 09 4b 	lsl	r11,r11,r9
8000bf9e:	f0 09 09 42 	lsl	r2,r8,r9
8000bfa2:	ef 46 ff f4 	st.w	r7[-12],r6
8000bfa6:	f0 06 0a 48 	lsr	r8,r8,r6
8000bfaa:	18 48       	or	r8,r12
8000bfac:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bfb0:	f4 09 09 43 	lsl	r3,r10,r9
8000bfb4:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bfb8:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bfbc:	16 4a       	or	r10,r11
8000bfbe:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bfc2:	f8 0b 0d 04 	divu	r4,r12,r11
8000bfc6:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bfca:	08 91       	mov	r1,r4
8000bfcc:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bfd0:	e8 0e 02 46 	mul	r6,r4,lr
8000bfd4:	0c 3c       	cp.w	r12,r6
8000bfd6:	c0 a2       	brcc	8000bfea <__avr32_umod64+0x19a>
8000bfd8:	20 11       	sub	r1,1
8000bfda:	10 0c       	add	r12,r8
8000bfdc:	10 3c       	cp.w	r12,r8
8000bfde:	c0 63       	brcs	8000bfea <__avr32_umod64+0x19a>
8000bfe0:	0c 3c       	cp.w	r12,r6
8000bfe2:	f7 b1 03 01 	sublo	r1,1
8000bfe6:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000bfea:	0c 1c       	sub	r12,r6
8000bfec:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000bff0:	f8 0b 0d 04 	divu	r4,r12,r11
8000bff4:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000bff8:	08 96       	mov	r6,r4
8000bffa:	e8 0e 02 4e 	mul	lr,r4,lr
8000bffe:	1c 3b       	cp.w	r11,lr
8000c000:	c0 a2       	brcc	8000c014 <__avr32_umod64+0x1c4>
8000c002:	20 16       	sub	r6,1
8000c004:	10 0b       	add	r11,r8
8000c006:	10 3b       	cp.w	r11,r8
8000c008:	c0 63       	brcs	8000c014 <__avr32_umod64+0x1c4>
8000c00a:	1c 3b       	cp.w	r11,lr
8000c00c:	f7 b6 03 01 	sublo	r6,1
8000c010:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c014:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c018:	1c 1b       	sub	r11,lr
8000c01a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c01e:	00 9e       	mov	lr,r0
8000c020:	02 9c       	mov	r12,r1
8000c022:	16 3c       	cp.w	r12,r11
8000c024:	e0 8b 00 08 	brhi	8000c034 <__avr32_umod64+0x1e4>
8000c028:	5f 06       	sreq	r6
8000c02a:	06 30       	cp.w	r0,r3
8000c02c:	5f ba       	srhi	r10
8000c02e:	ed ea 00 0a 	and	r10,r6,r10
8000c032:	c0 60       	breq	8000c03e <__avr32_umod64+0x1ee>
8000c034:	fc 02 01 04 	sub	r4,lr,r2
8000c038:	f8 08 01 4c 	sbc	r12,r12,r8
8000c03c:	08 9e       	mov	lr,r4
8000c03e:	e6 0e 01 0a 	sub	r10,r3,lr
8000c042:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c046:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c04a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c04e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c052:	f8 01 09 4c 	lsl	r12,r12,r1
8000c056:	18 4a       	or	r10,r12
8000c058:	2f dd       	sub	sp,-12
8000c05a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c200 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c200:	c0 08       	rjmp	8000c200 <_evba>
	...

8000c204 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c204:	c0 08       	rjmp	8000c204 <_handle_TLB_Multiple_Hit>
	...

8000c208 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c208:	c0 08       	rjmp	8000c208 <_handle_Bus_Error_Data_Fetch>
	...

8000c20c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c20c:	c0 08       	rjmp	8000c20c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c210 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c210:	c0 08       	rjmp	8000c210 <_handle_NMI>
	...

8000c214 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c214:	c0 08       	rjmp	8000c214 <_handle_Instruction_Address>
	...

8000c218 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c218:	c0 08       	rjmp	8000c218 <_handle_ITLB_Protection>
	...

8000c21c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c21c:	c0 08       	rjmp	8000c21c <_handle_Breakpoint>
	...

8000c220 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c220:	c0 08       	rjmp	8000c220 <_handle_Illegal_Opcode>
	...

8000c224 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c224:	c0 08       	rjmp	8000c224 <_handle_Unimplemented_Instruction>
	...

8000c228 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c228:	c0 08       	rjmp	8000c228 <_handle_Privilege_Violation>
	...

8000c22c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c22c:	c0 08       	rjmp	8000c22c <_handle_Floating_Point>
	...

8000c230 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c230:	c0 08       	rjmp	8000c230 <_handle_Coprocessor_Absent>
	...

8000c234 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c234:	c0 08       	rjmp	8000c234 <_handle_Data_Address_Read>
	...

8000c238 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c238:	c0 08       	rjmp	8000c238 <_handle_Data_Address_Write>
	...

8000c23c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c23c:	c0 08       	rjmp	8000c23c <_handle_DTLB_Protection_Read>
	...

8000c240 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c240:	c0 08       	rjmp	8000c240 <_handle_DTLB_Protection_Write>
	...

8000c244 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c244:	c0 08       	rjmp	8000c244 <_handle_DTLB_Modified>
	...

8000c250 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c250:	c0 08       	rjmp	8000c250 <_handle_ITLB_Miss>
	...

8000c260 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c260:	c0 08       	rjmp	8000c260 <_handle_DTLB_Miss_Read>
	...

8000c270 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c270:	c0 08       	rjmp	8000c270 <_handle_DTLB_Miss_Write>
	...

8000c300 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c300:	fe cf 71 d8 	sub	pc,pc,29144

8000c304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c304:	30 0c       	mov	r12,0
8000c306:	fe b0 c3 85 	rcall	80004a10 <_get_interrupt_handler>
8000c30a:	58 0c       	cp.w	r12,0
8000c30c:	f8 0f 17 10 	movne	pc,r12
8000c310:	d6 03       	rete

8000c312 <_int1>:
8000c312:	30 1c       	mov	r12,1
8000c314:	fe b0 c3 7e 	rcall	80004a10 <_get_interrupt_handler>
8000c318:	58 0c       	cp.w	r12,0
8000c31a:	f8 0f 17 10 	movne	pc,r12
8000c31e:	d6 03       	rete

8000c320 <_int2>:
8000c320:	30 2c       	mov	r12,2
8000c322:	fe b0 c3 77 	rcall	80004a10 <_get_interrupt_handler>
8000c326:	58 0c       	cp.w	r12,0
8000c328:	f8 0f 17 10 	movne	pc,r12
8000c32c:	d6 03       	rete

8000c32e <_int3>:
8000c32e:	30 3c       	mov	r12,3
8000c330:	fe b0 c3 70 	rcall	80004a10 <_get_interrupt_handler>
8000c334:	58 0c       	cp.w	r12,0
8000c336:	f8 0f 17 10 	movne	pc,r12
8000c33a:	d6 03       	rete

8000c33c <ipr_val>:
8000c33c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c34c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c35c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c36c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c37c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c38c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c39c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3fc:	d7 03 d7 03                                         ....
