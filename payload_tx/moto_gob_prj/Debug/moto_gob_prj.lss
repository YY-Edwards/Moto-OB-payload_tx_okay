
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a074  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c200  8000c200  0000c600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001150  8000c400  8000c400  0000c800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a2c  00000008  8000d550  0000dc08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a34  8000df7c  0000e634  2**0
                  ALLOC
  8 .bss          000036e0  00000a38  00000a38  00000000  2**2
                  ALLOC
  9 .heap         00012ee8  00004118  00004118  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000e634  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001158  00000000  00000000  0000e668  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000024f9  00000000  00000000  0000f7c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002835a  00000000  00000000  00011cb9  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00006793  00000000  00000000  0003a013  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c196  00000000  00000000  000407a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002d34  00000000  00000000  0004c93c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006cf5  00000000  00000000  0004f670  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000ca32  00000000  00000000  00056365  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001240  00000000  00000000  00062d98  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 98 a8 	sub	pc,pc,-26456

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b8 ac 	sub	pc,pc,-18260

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d 94       	ld.ub	r4,r6[0x1]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12
8000202e:	d7 03       	nop

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 50       	eor	r0,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 20       	sub	r0,18
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 38       	sub	r8,-125
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	29 08       	sub	r8,-112
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	3e 84       	mov	r4,-24
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c4 00       	breq	80002106 <app_cfg+0x72>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	5e cc       	retvs	r12
80002090:	00 00       	add	r0,r0
80002092:	0a 44       	or	r4,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 1a 	mcall	800020fc <app_cfg+0x68>
8000209a:	49 a8       	lddpc	r8,80002100 <app_cfg+0x6c>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 a6       	lddpc	r6,80002104 <app_cfg+0x70>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 a4       	lddpc	r4,80002108 <app_cfg+0x74>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 41       	mov	r1,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 32       	mov	r2,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 20       	mov	r0,2
					xcmp_enter_enhanced_OB_mode();
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 07 d0 	mov	r5,2000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 d1       	brne	800020f2 <app_cfg+0x5e>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020ba:	68 08       	ld.w	r8,r4[0x0]
800020bc:	58 08       	cp.w	r8,0
800020be:	c0 71       	brne	800020cc <app_cfg+0x38>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
800020c0:	f0 1f 00 13 	mcall	8000210c <app_cfg+0x78>
					xcmp_enter_enhanced_OB_mode();
800020c4:	f0 1f 00 13 	mcall	80002110 <app_cfg+0x7c>
					//xcmp_unmute_speaker();
					//Speaker_is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c8:	89 03       	st.w	r4[0x0],r3
800020ca:	c1 48       	rjmp	800020f2 <app_cfg+0x5e>
				}
				else if(isAudioRouting == 1)
800020cc:	58 18       	cp.w	r8,1
800020ce:	c0 71       	brne	800020dc <app_cfg+0x48>
				{
					xcmp_exit_device_control_mode();
800020d0:	f0 1f 00 11 	mcall	80002114 <app_cfg+0x80>
					xcmp_audio_route_AMBE();
800020d4:	f0 1f 00 11 	mcall	80002118 <app_cfg+0x84>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020d8:	89 00       	st.w	r4[0x0],r0
800020da:	c0 c8       	rjmp	800020f2 <app_cfg+0x5e>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020dc:	58 28       	cp.w	r8,2
800020de:	c0 31       	brne	800020e4 <app_cfg+0x50>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020e0:	89 02       	st.w	r4[0x0],r2
800020e2:	c0 88       	rjmp	800020f2 <app_cfg+0x5e>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020e4:	58 38       	cp.w	r8,3
800020e6:	e9 f1 0a 00 	st.weq	r4[0x0],r1
					
				}
				else
				{
					isAudioRouting++;
800020ea:	f7 b8 01 ff 	subne	r8,-1
800020ee:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 1000*2 / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
800020f2:	0a 9b       	mov	r11,r5
800020f4:	0e 9c       	mov	r12,r7
800020f6:	f0 1f 00 0a 	mcall	8000211c <app_cfg+0x88>
	}
800020fa:	cd bb       	rjmp	800020b0 <app_cfg+0x1c>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	5c 04       	acr	r4
80002100:	00 00       	add	r0,r0
80002102:	0a 4c       	or	r12,r5
80002104:	00 00       	add	r0,r0
80002106:	0d 94       	ld.ub	r4,r6[0x1]
80002108:	00 00       	add	r0,r0
8000210a:	0a 3c       	cp.w	r12,r5
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	3f 08       	mov	r8,-16
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	3f 94       	mov	r4,-7
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	3e d8       	mov	r8,-19
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	3f 34       	mov	r4,-13
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	5d 6c       	*unknown*

80002120 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002120:	d4 01       	pushm	lr
  log("R");
80002122:	48 3c       	lddpc	r12,8000212c <app_payload_tx_proc+0xc>
80002124:	f0 1f 00 03 	mcall	80002130 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002128:	d8 02       	popm	pc
8000212a:	00 00       	add	r0,r0
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	c4 08       	rjmp	800021ae <EnOB_reply_func+0x2a>
80002130:	80 00       	ld.sh	r0,r0[0x0]
80002132:	62 90       	ld.w	r0,r1[0x24]

80002134 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
80002134:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
80002136:	48 3c       	lddpc	r12,80002140 <FD_brdcst_func+0xc>
80002138:	f0 1f 00 03 	mcall	80002144 <FD_brdcst_func+0x10>
	
}
8000213c:	d8 02       	popm	pc
8000213e:	00 00       	add	r0,r0
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	c4 0c       	rcall	800021c2 <EnOB_reply_func+0x3e>
80002144:	80 00       	ld.sh	r0,r0[0x0]
80002146:	62 90       	ld.w	r0,r1[0x24]

80002148 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002148:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
8000214a:	48 3c       	lddpc	r12,80002154 <FD_reply_func+0xc>
8000214c:	f0 1f 00 03 	mcall	80002158 <FD_reply_func+0x10>
	
	
}
80002150:	d8 02       	popm	pc
80002152:	00 00       	add	r0,r0
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	c4 2c       	rcall	800021da <EnOB_reply_func+0x56>
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	62 90       	ld.w	r0,r1[0x24]

8000215c <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
8000215c:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
8000215e:	48 3c       	lddpc	r12,80002168 <FD_request_func+0xc>
80002160:	f0 1f 00 03 	mcall	8000216c <FD_request_func+0x10>
	
	
}
80002164:	d8 02       	popm	pc
80002166:	00 00       	add	r0,r0
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	c4 48       	rjmp	800021f2 <EnOB_reply_func+0x6e>
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	62 90       	ld.w	r0,r1[0x24]

80002170 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002170:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002172:	48 3c       	lddpc	r12,8000217c <EnOB_brdcst_func+0xc>
80002174:	f0 1f 00 03 	mcall	80002180 <EnOB_brdcst_func+0x10>
}
80002178:	d8 02       	popm	pc
8000217a:	00 00       	add	r0,r0
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	c4 64       	brge	8000220a <SingleDetection_brdcst_func+0x16>
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	62 90       	ld.w	r0,r1[0x24]

80002184 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002184:	eb cd 40 80 	pushm	r7,lr
80002188:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000218a:	19 a9       	ld.ub	r9,r12[0x2]
8000218c:	30 08       	mov	r8,0
8000218e:	f0 09 18 00 	cp.b	r9,r8
80002192:	c1 91       	brne	800021c4 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002194:	19 b8       	ld.ub	r8,r12[0x3]
80002196:	30 19       	mov	r9,1
80002198:	f2 08 18 00 	cp.b	r8,r9
8000219c:	c0 61       	brne	800021a8 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
8000219e:	49 0c       	lddpc	r12,800021dc <EnOB_reply_func+0x58>
800021a0:	f0 1f 00 10 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021a4:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
800021a8:	58 08       	cp.w	r8,0
800021aa:	c0 61       	brne	800021b6 <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
800021ac:	48 ec       	lddpc	r12,800021e4 <EnOB_reply_func+0x60>
800021ae:	f0 1f 00 0d 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021b2:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
800021b6:	1a d8       	st.w	--sp,r8
800021b8:	48 cc       	lddpc	r12,800021e8 <EnOB_reply_func+0x64>
800021ba:	f0 1f 00 0a 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021be:	2f fd       	sub	sp,-4
800021c0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021c4:	48 ac       	lddpc	r12,800021ec <EnOB_reply_func+0x68>
800021c6:	f0 1f 00 07 	mcall	800021e0 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021ca:	0f a8       	ld.ub	r8,r7[0x2]
800021cc:	1a d8       	st.w	--sp,r8
800021ce:	48 9c       	lddpc	r12,800021f0 <EnOB_reply_func+0x6c>
800021d0:	f0 1f 00 04 	mcall	800021e0 <EnOB_reply_func+0x5c>
800021d4:	2f fd       	sub	sp,-4
800021d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800021da:	00 00       	add	r0,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	c4 7c       	rcall	8000226c <ButtonConfig_brdcst_func+0x5c>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	62 90       	ld.w	r0,r1[0x24]
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	c4 94       	brge	80002278 <ButtonConfig_brdcst_func+0x68>
800021e8:	80 00       	ld.sh	r0,r0[0x0]
800021ea:	c4 a8       	rjmp	8000227e <ButtonConfig_brdcst_func+0x6e>
800021ec:	80 00       	ld.sh	r0,r0[0x0]
800021ee:	c4 c0       	breq	80002286 <ButtonConfig_brdcst_func+0x76>
800021f0:	80 00       	ld.sh	r0,r0[0x0]
800021f2:	c4 dc       	rcall	8000228c <ButtonConfig_brdcst_func+0x7c>

800021f4 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021f4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
800021f6:	19 a9       	ld.ub	r9,r12[0x2]
800021f8:	31 18       	mov	r8,17
800021fa:	f0 09 18 00 	cp.b	r9,r8
800021fe:	c0 41       	brne	80002206 <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002200:	48 2c       	lddpc	r12,80002208 <SingleDetection_brdcst_func+0x14>
80002202:	f0 1f 00 03 	mcall	8000220c <SingleDetection_brdcst_func+0x18>
80002206:	d8 02       	popm	pc
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	c4 f4       	brge	800022a8 <ButtonConfig_brdcst_func+0x98>
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	62 90       	ld.w	r0,r1[0x24]

80002210 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
80002210:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
80002212:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002216:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002218:	4a bc       	lddpc	r12,800022c4 <ButtonConfig_brdcst_func+0xb4>
8000221a:	f0 1f 00 2c 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000221e:	0f 88       	ld.ub	r8,r7[0x0]
80002220:	1a d8       	st.w	--sp,r8
80002222:	4a bc       	lddpc	r12,800022cc <ButtonConfig_brdcst_func+0xbc>
80002224:	f0 1f 00 29 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002228:	1a d5       	st.w	--sp,r5
8000222a:	4a ac       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xc0>
8000222c:	f0 1f 00 27 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002230:	0f a8       	ld.ub	r8,r7[0x2]
80002232:	1a d8       	st.w	--sp,r8
80002234:	4a 8c       	lddpc	r12,800022d4 <ButtonConfig_brdcst_func+0xc4>
80002236:	f0 1f 00 25 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000223a:	2f dd       	sub	sp,-12
8000223c:	58 05       	cp.w	r5,0
8000223e:	c4 10       	breq	800022c0 <ButtonConfig_brdcst_func+0xb0>
80002240:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002242:	4a 64       	lddpc	r4,800022d8 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002244:	4a 63       	lddpc	r3,800022dc <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002246:	4a 72       	lddpc	r2,800022e0 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002248:	4a 71       	lddpc	r1,800022e4 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000224a:	4a 80       	lddpc	r0,800022e8 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000224c:	0f b9       	ld.ub	r9,r7[0x3]
8000224e:	0f c8       	ld.ub	r8,r7[0x4]
80002250:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002254:	1a d8       	st.w	--sp,r8
80002256:	1a d6       	st.w	--sp,r6
80002258:	08 9c       	mov	r12,r4
8000225a:	f0 1f 00 1c 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000225e:	0f d9       	ld.ub	r9,r7[0x5]
80002260:	0f e8       	ld.ub	r8,r7[0x6]
80002262:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002266:	1a d8       	st.w	--sp,r8
80002268:	1a d6       	st.w	--sp,r6
8000226a:	06 9c       	mov	r12,r3
8000226c:	f0 1f 00 17 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002270:	0f f9       	ld.ub	r9,r7[0x7]
80002272:	ef 38 00 08 	ld.ub	r8,r7[8]
80002276:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227a:	1a d8       	st.w	--sp,r8
8000227c:	1a d6       	st.w	--sp,r6
8000227e:	04 9c       	mov	r12,r2
80002280:	f0 1f 00 12 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002284:	ef 39 00 09 	ld.ub	r9,r7[9]
80002288:	ef 38 00 0a 	ld.ub	r8,r7[10]
8000228c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002290:	1a d8       	st.w	--sp,r8
80002292:	1a d6       	st.w	--sp,r6
80002294:	02 9c       	mov	r12,r1
80002296:	f0 1f 00 0d 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000229a:	2f 8d       	sub	sp,-32
8000229c:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022a0:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022a4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022a8:	1a d8       	st.w	--sp,r8
800022aa:	1a d6       	st.w	--sp,r6
800022ac:	00 9c       	mov	r12,r0
800022ae:	f0 1f 00 07 	mcall	800022c8 <ButtonConfig_brdcst_func+0xb8>
800022b2:	2f f6       	sub	r6,-1
800022b4:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022b6:	2f ed       	sub	sp,-8
800022b8:	ec 05 18 00 	cp.b	r5,r6
800022bc:	fe 9b ff c8 	brhi	8000224c <ButtonConfig_brdcst_func+0x3c>
800022c0:	d8 32       	popm	r0-r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	c5 08       	rjmp	80002366 <ButtonConfig_reply_func+0x2>
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	62 90       	ld.w	r0,r1[0x24]
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	c5 28       	rjmp	80002372 <ButtonConfig_reply_func+0xe>
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c5 3c       	rcall	80002378 <ButtonConfig_reply_func+0x14>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	c5 54       	brge	80002380 <ButtonConfig_reply_func+0x1c>
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c5 74       	brge	80002388 <ButtonConfig_reply_func+0x24>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c5 9c       	rcall	80002390 <ButtonConfig_reply_func+0x2c>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c5 c4       	brge	8000239a <ButtonConfig_reply_func+0x36>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c5 e8       	rjmp	800023a2 <ButtonConfig_reply_func+0x3e>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c6 10       	breq	800023ac <DataSession_brdcst_func+0x4>

800022ec <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022ec:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022f0:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022f2:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800022f4:	19 c7       	ld.ub	r7,r12[0x4]
800022f6:	19 d8       	ld.ub	r8,r12[0x5]
800022f8:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
800022fc:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
800022fe:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002300:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002304:	49 0c       	lddpc	r12,80002344 <Phyuserinput_brdcst_func+0x58>
80002306:	f0 1f 00 11 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
8000230a:	1a d6       	st.w	--sp,r6
8000230c:	49 0c       	lddpc	r12,8000234c <Phyuserinput_brdcst_func+0x60>
8000230e:	f0 1f 00 0f 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
80002312:	1a d5       	st.w	--sp,r5
80002314:	48 fc       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x64>
80002316:	f0 1f 00 0d 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
8000231a:	5c 77       	castu.h	r7
8000231c:	1a d7       	st.w	--sp,r7
8000231e:	48 ec       	lddpc	r12,80002354 <Phyuserinput_brdcst_func+0x68>
80002320:	f0 1f 00 0a 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002324:	1a d4       	st.w	--sp,r4
80002326:	48 dc       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x6c>
80002328:	f0 1f 00 08 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
8000232c:	1a d3       	st.w	--sp,r3
8000232e:	48 cc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x70>
80002330:	f0 1f 00 06 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002334:	1a d2       	st.w	--sp,r2
80002336:	48 bc       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x74>
80002338:	f0 1f 00 04 	mcall	80002348 <Phyuserinput_brdcst_func+0x5c>
8000233c:	2f ad       	sub	sp,-24
	
	
	
	
	
}
8000233e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002342:	00 00       	add	r0,r0
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	c6 34       	brge	8000240c <DataSession_brdcst_func+0x64>
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	62 90       	ld.w	r0,r1[0x24]
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	c6 58       	rjmp	80002418 <DataSession_brdcst_func+0x70>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c6 70       	breq	80002420 <DataSession_brdcst_func+0x78>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	c6 84       	brge	80002426 <DataSession_brdcst_func+0x7e>
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	c6 98       	rjmp	8000242c <DataSession_reply_func>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	c6 ac       	rcall	80002432 <DataSession_reply_func+0x6>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	c6 cc       	rcall	8000243a <DataSession_reply_func+0xe>

80002364 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002364:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002368:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
8000236c:	0f 89       	ld.ub	r9,r7[0x0]
8000236e:	30 08       	mov	r8,0
80002370:	f0 09 18 00 	cp.b	r9,r8
80002374:	c0 c1       	brne	8000238c <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002376:	48 9c       	lddpc	r12,80002398 <ButtonConfig_reply_func+0x34>
80002378:	f0 1f 00 09 	mcall	8000239c <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
8000237c:	0f 98       	ld.ub	r8,r7[0x1]
8000237e:	1a d8       	st.w	--sp,r8
80002380:	48 8c       	lddpc	r12,800023a0 <ButtonConfig_reply_func+0x3c>
80002382:	f0 1f 00 07 	mcall	8000239c <ButtonConfig_reply_func+0x38>
80002386:	2f fd       	sub	sp,-4
80002388:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
8000238c:	48 6c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x40>
8000238e:	f0 1f 00 04 	mcall	8000239c <ButtonConfig_reply_func+0x38>
80002392:	e3 cd 80 80 	ldm	sp++,r7,pc
80002396:	00 00       	add	r0,r0
80002398:	80 00       	ld.sh	r0,r0[0x0]
8000239a:	c6 ec       	rcall	80002476 <DataSession_reply_func+0x4a>
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	62 90       	ld.w	r0,r1[0x24]
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	c5 28       	rjmp	80002446 <DataSession_reply_func+0x1a>
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	c7 04       	brge	80002486 <CallControl_brdcst_func+0x2>

800023a8 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023a8:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023aa:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023ae:	0d 88       	ld.ub	r8,r6[0x0]
800023b0:	32 49       	mov	r9,36
800023b2:	f2 08 18 00 	cp.b	r8,r9
800023b6:	c2 91       	brne	80002408 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023b8:	49 7c       	lddpc	r12,80002414 <DataSession_brdcst_func+0x6c>
800023ba:	f0 1f 00 18 	mcall	80002418 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023be:	0d a5       	ld.ub	r5,r6[0x2]
800023c0:	0d b8       	ld.ub	r8,r6[0x3]
800023c2:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023c6:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023c8:	0d 98       	ld.ub	r8,r6[0x1]
800023ca:	1a d8       	st.w	--sp,r8
800023cc:	49 4c       	lddpc	r12,8000241c <DataSession_brdcst_func+0x74>
800023ce:	f0 1f 00 13 	mcall	80002418 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023d2:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023d6:	1a d8       	st.w	--sp,r8
800023d8:	49 2c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x78>
800023da:	f0 1f 00 10 	mcall	80002418 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023de:	2f ed       	sub	sp,-8
800023e0:	58 05       	cp.w	r5,0
800023e2:	c1 80       	breq	80002412 <DataSession_brdcst_func+0x6a>
800023e4:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023e6:	49 04       	lddpc	r4,80002424 <DataSession_brdcst_func+0x7c>
800023e8:	ec 07 00 08 	add	r8,r6,r7
800023ec:	11 c8       	ld.ub	r8,r8[0x4]
800023ee:	1a d8       	st.w	--sp,r8
800023f0:	1a d7       	st.w	--sp,r7
800023f2:	08 9c       	mov	r12,r4
800023f4:	f0 1f 00 09 	mcall	80002418 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
800023f8:	2f f7       	sub	r7,-1
800023fa:	5c 57       	castu.b	r7
800023fc:	2f ed       	sub	sp,-8
800023fe:	ee 05 19 00 	cp.h	r5,r7
80002402:	fe 9b ff f3 	brhi	800023e8 <DataSession_brdcst_func+0x40>
80002406:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002408:	1a d8       	st.w	--sp,r8
8000240a:	48 8c       	lddpc	r12,80002428 <DataSession_brdcst_func+0x80>
8000240c:	f0 1f 00 03 	mcall	80002418 <DataSession_brdcst_func+0x70>
80002410:	2f fd       	sub	sp,-4
80002412:	d8 22       	popm	r4-r7,pc
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	c7 20       	breq	800024fa <TransmitControl_brdcst_func+0x32>
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	62 90       	ld.w	r0,r1[0x24]
8000241c:	80 00       	ld.sh	r0,r0[0x0]
8000241e:	c7 34       	brge	80002504 <TransmitControl_brdcst_func+0x3c>
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	c7 4c       	rcall	8000250a <TransmitControl_brdcst_func+0x42>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	c7 68       	rjmp	80002512 <TransmitControl_reply_func+0x2>
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	c7 80       	breq	8000251a <TransmitControl_reply_func+0xa>

8000242c <DataSession_reply_func>:
}



void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
8000242c:	eb cd 40 80 	pushm	r7,lr
80002430:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002432:	19 a8       	ld.ub	r8,r12[0x2]
80002434:	58 08       	cp.w	r8,0
80002436:	c0 61       	brne	80002442 <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002438:	48 dc       	lddpc	r12,8000246c <DataSession_reply_func+0x40>
8000243a:	f0 1f 00 0e 	mcall	80002470 <DataSession_reply_func+0x44>
8000243e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
80002442:	1a d8       	st.w	--sp,r8
80002444:	48 cc       	lddpc	r12,80002474 <DataSession_reply_func+0x48>
80002446:	f0 1f 00 0b 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
8000244a:	48 cc       	lddpc	r12,80002478 <DataSession_reply_func+0x4c>
8000244c:	f0 1f 00 09 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
80002450:	0f b8       	ld.ub	r8,r7[0x3]
80002452:	1a d8       	st.w	--sp,r8
80002454:	48 ac       	lddpc	r12,8000247c <DataSession_reply_func+0x50>
80002456:	f0 1f 00 07 	mcall	80002470 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
8000245a:	0f c8       	ld.ub	r8,r7[0x4]
8000245c:	1a d8       	st.w	--sp,r8
8000245e:	48 9c       	lddpc	r12,80002480 <DataSession_reply_func+0x54>
80002460:	f0 1f 00 04 	mcall	80002470 <DataSession_reply_func+0x44>
80002464:	2f dd       	sub	sp,-12
80002466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000246a:	00 00       	add	r0,r0
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	c7 94       	brge	80002560 <TransmitControl_reply_func+0x50>
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	62 90       	ld.w	r0,r1[0x24]
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	c7 a8       	rjmp	8000256a <TransmitControl_reply_func+0x5a>
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	c7 bc       	rcall	80002570 <AudioRoutingControl_brdcst_func>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	c7 d0       	breq	80002578 <AudioRoutingControl_brdcst_func+0x8>
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	c7 e0       	breq	8000257e <AudioRoutingControl_brdcst_func+0xe>

80002484 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002484:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002488:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
8000248c:	0f 98       	ld.ub	r8,r7[0x1]
8000248e:	1a d8       	st.w	--sp,r8
80002490:	48 bc       	lddpc	r12,800024bc <CallControl_brdcst_func+0x38>
80002492:	f0 1f 00 0c 	mcall	800024c0 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002496:	2f fd       	sub	sp,-4
80002498:	0f 99       	ld.ub	r9,r7[0x1]
8000249a:	30 38       	mov	r8,3
8000249c:	f0 09 18 00 	cp.b	r9,r8
800024a0:	c0 41       	brne	800024a8 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
800024a2:	30 09       	mov	r9,0
800024a4:	48 88       	lddpc	r8,800024c4 <CallControl_brdcst_func+0x40>
800024a6:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800024a8:	0f 99       	ld.ub	r9,r7[0x1]
800024aa:	30 48       	mov	r8,4
800024ac:	f0 09 18 00 	cp.b	r9,r8
800024b0:	c0 41       	brne	800024b8 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800024b2:	30 19       	mov	r9,1
800024b4:	48 48       	lddpc	r8,800024c4 <CallControl_brdcst_func+0x40>
800024b6:	b0 89       	st.b	r8[0x0],r9
800024b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	c7 f0       	breq	800025bc <Volume_reply_func+0x2c>
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	62 90       	ld.w	r0,r1[0x24]
800024c4:	00 00       	add	r0,r0
800024c6:	0a 42       	or	r2,r5

800024c8 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800024c8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800024cc:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800024d0:	0f 99       	ld.ub	r9,r7[0x1]
800024d2:	30 08       	mov	r8,0
800024d4:	f0 09 18 00 	cp.b	r9,r8
800024d8:	c0 71       	brne	800024e6 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024da:	48 ac       	lddpc	r12,80002500 <TransmitControl_brdcst_func+0x38>
800024dc:	f0 1f 00 0a 	mcall	80002504 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024e0:	30 09       	mov	r9,0
800024e2:	48 a8       	lddpc	r8,80002508 <TransmitControl_brdcst_func+0x40>
800024e4:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024e6:	0f 99       	ld.ub	r9,r7[0x1]
800024e8:	30 18       	mov	r8,1
800024ea:	f0 09 18 00 	cp.b	r9,r8
800024ee:	c0 71       	brne	800024fc <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024f0:	48 7c       	lddpc	r12,8000250c <TransmitControl_brdcst_func+0x44>
800024f2:	f0 1f 00 05 	mcall	80002504 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024f6:	30 19       	mov	r9,1
800024f8:	48 48       	lddpc	r8,80002508 <TransmitControl_brdcst_func+0x40>
800024fa:	b0 89       	st.b	r8[0x0],r9
800024fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	c8 08       	rjmp	80002602 <spk_brdcst_func+0xe>
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	62 90       	ld.w	r0,r1[0x24]
80002508:	00 00       	add	r0,r0
8000250a:	0a 41       	or	r1,r5
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	c8 20       	breq	80002412 <DataSession_brdcst_func+0x6a>

80002510 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002510:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002514:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002518:	0f 89       	ld.ub	r9,r7[0x0]
8000251a:	30 08       	mov	r8,0
8000251c:	f0 09 18 00 	cp.b	r9,r8
80002520:	c1 61       	brne	8000254c <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002522:	48 ec       	lddpc	r12,80002558 <TransmitControl_reply_func+0x48>
80002524:	f0 1f 00 0e 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002528:	0f 98       	ld.ub	r8,r7[0x1]
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 dc       	lddpc	r12,80002560 <TransmitControl_reply_func+0x50>
8000252e:	f0 1f 00 0c 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
80002532:	0f a8       	ld.ub	r8,r7[0x2]
80002534:	1a d8       	st.w	--sp,r8
80002536:	48 cc       	lddpc	r12,80002564 <TransmitControl_reply_func+0x54>
80002538:	f0 1f 00 09 	mcall	8000255c <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
8000253c:	0f b8       	ld.ub	r8,r7[0x3]
8000253e:	1a d8       	st.w	--sp,r8
80002540:	48 ac       	lddpc	r12,80002568 <TransmitControl_reply_func+0x58>
80002542:	f0 1f 00 07 	mcall	8000255c <TransmitControl_reply_func+0x4c>
80002546:	2f dd       	sub	sp,-12
80002548:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
8000254c:	48 8c       	lddpc	r12,8000256c <TransmitControl_reply_func+0x5c>
8000254e:	f0 1f 00 04 	mcall	8000255c <TransmitControl_reply_func+0x4c>
80002552:	e3 cd 80 80 	ldm	sp++,r7,pc
80002556:	00 00       	add	r0,r0
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	c8 34       	brge	80002460 <DataSession_reply_func+0x34>
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	62 90       	ld.w	r0,r1[0x24]
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	c8 50       	breq	8000246c <DataSession_reply_func+0x40>
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	c8 64       	brge	80002472 <DataSession_reply_func+0x46>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	c8 80       	breq	8000247a <DataSession_reply_func+0x4e>
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	c8 90       	breq	80002480 <DataSession_reply_func+0x54>

80002570 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002570:	d4 01       	pushm	lr
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
80002572:	19 a9       	ld.ub	r9,r12[0x2]
80002574:	19 b8       	ld.ub	r8,r12[0x3]
80002576:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000257a:	1a d8       	st.w	--sp,r8
8000257c:	48 3c       	lddpc	r12,80002588 <AudioRoutingControl_brdcst_func+0x18>
8000257e:	f0 1f 00 04 	mcall	8000258c <AudioRoutingControl_brdcst_func+0x1c>
80002582:	2f fd       	sub	sp,-4
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
80002584:	d8 02       	popm	pc
80002586:	00 00       	add	r0,r0
80002588:	80 00       	ld.sh	r0,r0[0x0]
8000258a:	c8 a8       	rjmp	8000269e <mic_brdcst_func+0x2a>
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	62 90       	ld.w	r0,r1[0x24]

80002590 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002590:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002594:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002598:	0f 89       	ld.ub	r9,r7[0x0]
8000259a:	30 08       	mov	r8,0
8000259c:	f0 09 18 00 	cp.b	r9,r8
800025a0:	c1 b1       	brne	800025d6 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025a2:	0f b8       	ld.ub	r8,r7[0x3]
800025a4:	31 09       	mov	r9,16
800025a6:	f2 08 18 00 	cp.b	r8,r9
800025aa:	c0 f1       	brne	800025c8 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025ac:	48 dc       	lddpc	r12,800025e0 <Volume_reply_func+0x50>
800025ae:	f0 1f 00 0e 	mcall	800025e4 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025b2:	0f 99       	ld.ub	r9,r7[0x1]
800025b4:	0f a8       	ld.ub	r8,r7[0x2]
800025b6:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025ba:	1a d8       	st.w	--sp,r8
800025bc:	48 bc       	lddpc	r12,800025e8 <Volume_reply_func+0x58>
800025be:	f0 1f 00 0a 	mcall	800025e4 <Volume_reply_func+0x54>
800025c2:	2f fd       	sub	sp,-4
800025c4:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800025c8:	1a d8       	st.w	--sp,r8
800025ca:	48 9c       	lddpc	r12,800025ec <Volume_reply_func+0x5c>
800025cc:	f0 1f 00 06 	mcall	800025e4 <Volume_reply_func+0x54>
800025d0:	2f fd       	sub	sp,-4
800025d2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800025d6:	48 7c       	lddpc	r12,800025f0 <Volume_reply_func+0x60>
800025d8:	f0 1f 00 03 	mcall	800025e4 <Volume_reply_func+0x54>
800025dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	c8 c0       	breq	800024fa <TransmitControl_brdcst_func+0x32>
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	62 90       	ld.w	r0,r1[0x24]
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	c8 d4       	brge	80002504 <TransmitControl_brdcst_func+0x3c>
800025ec:	80 00       	ld.sh	r0,r0[0x0]
800025ee:	c8 f0       	breq	8000250c <TransmitControl_brdcst_func+0x44>
800025f0:	80 00       	ld.sh	r0,r0[0x0]
800025f2:	c9 08       	rjmp	80002712 <mic_reply_func+0x46>

800025f4 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800025f4:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800025f6:	19 d9       	ld.ub	r9,r12[0x5]
800025f8:	30 08       	mov	r8,0
800025fa:	f0 09 18 00 	cp.b	r9,r8
800025fe:	c0 81       	brne	8000260e <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002600:	10 99       	mov	r9,r8
80002602:	48 78       	lddpc	r8,8000261c <spk_brdcst_func+0x28>
80002604:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002606:	48 7c       	lddpc	r12,80002620 <spk_brdcst_func+0x2c>
80002608:	f0 1f 00 07 	mcall	80002624 <spk_brdcst_func+0x30>
8000260c:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000260e:	30 19       	mov	r9,1
80002610:	48 38       	lddpc	r8,8000261c <spk_brdcst_func+0x28>
80002612:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002614:	48 5c       	lddpc	r12,80002628 <spk_brdcst_func+0x34>
80002616:	f0 1f 00 04 	mcall	80002624 <spk_brdcst_func+0x30>
8000261a:	d8 02       	popm	pc
8000261c:	00 00       	add	r0,r0
8000261e:	0a 38       	cp.w	r8,r5
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	c9 20       	breq	80002546 <TransmitControl_reply_func+0x36>
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	62 90       	ld.w	r0,r1[0x24]
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	c9 30       	breq	80002550 <TransmitControl_reply_func+0x40>

8000262c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000262c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000262e:	19 a9       	ld.ub	r9,r12[0x2]
80002630:	30 08       	mov	r8,0
80002632:	f0 09 18 00 	cp.b	r9,r8
80002636:	c0 f1       	brne	80002654 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
80002638:	19 e9       	ld.ub	r9,r12[0x6]
8000263a:	f0 09 18 00 	cp.b	r9,r8
8000263e:	c0 40       	breq	80002646 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002640:	30 19       	mov	r9,1
80002642:	48 98       	lddpc	r8,80002664 <spk_reply_func+0x38>
80002644:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
80002646:	19 e8       	ld.ub	r8,r12[0x6]
80002648:	1a d8       	st.w	--sp,r8
8000264a:	48 8c       	lddpc	r12,80002668 <spk_reply_func+0x3c>
8000264c:	f0 1f 00 08 	mcall	8000266c <spk_reply_func+0x40>
80002650:	2f fd       	sub	sp,-4
80002652:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002654:	30 09       	mov	r9,0
80002656:	48 48       	lddpc	r8,80002664 <spk_reply_func+0x38>
80002658:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000265a:	48 6c       	lddpc	r12,80002670 <spk_reply_func+0x44>
8000265c:	f0 1f 00 04 	mcall	8000266c <spk_reply_func+0x40>
80002660:	d8 02       	popm	pc
80002662:	00 00       	add	r0,r0
80002664:	00 00       	add	r0,r0
80002666:	0a 38       	cp.w	r8,r5
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	c9 3c       	rcall	80002790 <dcm_brdcst_func+0x30>
8000266c:	80 00       	ld.sh	r0,r0[0x0]
8000266e:	62 90       	ld.w	r0,r1[0x24]
80002670:	80 00       	ld.sh	r0,r0[0x0]
80002672:	c9 4c       	rcall	8000279a <dcm_brdcst_func+0x3a>

80002674 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002674:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002678:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
8000267c:	0f a9       	ld.ub	r9,r7[0x2]
8000267e:	30 08       	mov	r8,0
80002680:	f0 09 18 00 	cp.b	r9,r8
80002684:	c0 71       	brne	80002692 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002686:	48 dc       	lddpc	r12,800026b8 <mic_brdcst_func+0x44>
80002688:	f0 1f 00 0d 	mcall	800026bc <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
8000268c:	30 09       	mov	r9,0
8000268e:	48 d8       	lddpc	r8,800026c0 <mic_brdcst_func+0x4c>
80002690:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002692:	0f a9       	ld.ub	r9,r7[0x2]
80002694:	31 18       	mov	r8,17
80002696:	f0 09 18 00 	cp.b	r9,r8
8000269a:	c0 d1       	brne	800026b4 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000269c:	48 ac       	lddpc	r12,800026c4 <mic_brdcst_func+0x50>
8000269e:	f0 1f 00 08 	mcall	800026bc <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800026a2:	48 89       	lddpc	r9,800026c0 <mic_brdcst_func+0x4c>
800026a4:	30 18       	mov	r8,1
800026a6:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800026a8:	13 89       	ld.ub	r9,r9[0x0]
800026aa:	f0 09 18 00 	cp.b	r9,r8
800026ae:	c0 31       	brne	800026b4 <mic_brdcst_func+0x40>
800026b0:	48 68       	lddpc	r8,800026c8 <mic_brdcst_func+0x54>
800026b2:	11 88       	ld.ub	r8,r8[0x0]
800026b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	c9 58       	rjmp	800027e4 <dcm_reply_func+0x3c>
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	62 90       	ld.w	r0,r1[0x24]
800026c0:	00 00       	add	r0,r0
800026c2:	0a 49       	or	r9,r5
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	c9 6c       	rcall	800027f2 <dcm_reply_func+0x4a>
800026c8:	00 00       	add	r0,r0
800026ca:	0a 42       	or	r2,r5

800026cc <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026cc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026d0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026d4:	49 ac       	lddpc	r12,8000273c <mic_reply_func+0x70>
800026d6:	f0 1f 00 1b 	mcall	80002740 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026da:	0f 89       	ld.ub	r9,r7[0x0]
800026dc:	30 08       	mov	r8,0
800026de:	f0 09 18 00 	cp.b	r9,r8
800026e2:	c2 71       	brne	80002730 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026e4:	0f 98       	ld.ub	r8,r7[0x1]
800026e6:	30 29       	mov	r9,2
800026e8:	f2 08 18 00 	cp.b	r8,r9
800026ec:	c1 b1       	brne	80002722 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026ee:	49 6c       	lddpc	r12,80002744 <mic_reply_func+0x78>
800026f0:	f0 1f 00 14 	mcall	80002740 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800026f4:	0f a8       	ld.ub	r8,r7[0x2]
800026f6:	1a d8       	st.w	--sp,r8
800026f8:	49 4c       	lddpc	r12,80002748 <mic_reply_func+0x7c>
800026fa:	f0 1f 00 12 	mcall	80002740 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800026fe:	0f b8       	ld.ub	r8,r7[0x3]
80002700:	1a d8       	st.w	--sp,r8
80002702:	49 3c       	lddpc	r12,8000274c <mic_reply_func+0x80>
80002704:	f0 1f 00 0f 	mcall	80002740 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002708:	0f c8       	ld.ub	r8,r7[0x4]
8000270a:	1a d8       	st.w	--sp,r8
8000270c:	49 1c       	lddpc	r12,80002750 <mic_reply_func+0x84>
8000270e:	f0 1f 00 0d 	mcall	80002740 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002712:	0f d8       	ld.ub	r8,r7[0x5]
80002714:	1a d8       	st.w	--sp,r8
80002716:	49 0c       	lddpc	r12,80002754 <mic_reply_func+0x88>
80002718:	f0 1f 00 0a 	mcall	80002740 <mic_reply_func+0x74>
8000271c:	2f cd       	sub	sp,-16
8000271e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002722:	1a d8       	st.w	--sp,r8
80002724:	48 dc       	lddpc	r12,80002758 <mic_reply_func+0x8c>
80002726:	f0 1f 00 07 	mcall	80002740 <mic_reply_func+0x74>
8000272a:	2f fd       	sub	sp,-4
8000272c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002730:	48 bc       	lddpc	r12,8000275c <mic_reply_func+0x90>
80002732:	f0 1f 00 04 	mcall	80002740 <mic_reply_func+0x74>
80002736:	e3 cd 80 80 	ldm	sp++,r7,pc
8000273a:	00 00       	add	r0,r0
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	c9 80       	breq	8000266e <spk_reply_func+0x42>
80002740:	80 00       	ld.sh	r0,r0[0x0]
80002742:	62 90       	ld.w	r0,r1[0x24]
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	c9 90       	breq	80002678 <mic_brdcst_func+0x4>
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	c9 a4       	brge	8000267e <mic_brdcst_func+0xa>
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	c9 b8       	rjmp	80002884 <AudioRoutingControl_reply_func>
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	c9 d4       	brge	8000268c <mic_brdcst_func+0x18>
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	c9 ec       	rcall	80002892 <AudioRoutingControl_reply_func+0xe>
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	ca 04       	brge	8000269a <mic_brdcst_func+0x26>
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	ca 1c       	rcall	800028a0 <AudioRoutingControl_reply_func+0x1c>

80002760 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002760:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002764:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002768:	48 bc       	lddpc	r12,80002794 <dcm_brdcst_func+0x34>
8000276a:	f0 1f 00 0c 	mcall	80002798 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000276e:	0f 88       	ld.ub	r8,r7[0x0]
80002770:	1a d8       	st.w	--sp,r8
80002772:	48 bc       	lddpc	r12,8000279c <dcm_brdcst_func+0x3c>
80002774:	f0 1f 00 09 	mcall	80002798 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002778:	0f a8       	ld.ub	r8,r7[0x2]
8000277a:	1a d8       	st.w	--sp,r8
8000277c:	48 9c       	lddpc	r12,800027a0 <dcm_brdcst_func+0x40>
8000277e:	f0 1f 00 07 	mcall	80002798 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002782:	0f 98       	ld.ub	r8,r7[0x1]
80002784:	1a d8       	st.w	--sp,r8
80002786:	48 8c       	lddpc	r12,800027a4 <dcm_brdcst_func+0x44>
80002788:	f0 1f 00 04 	mcall	80002798 <dcm_brdcst_func+0x38>
8000278c:	2f dd       	sub	sp,-12
	
	
}
8000278e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002792:	00 00       	add	r0,r0
80002794:	80 00       	ld.sh	r0,r0[0x0]
80002796:	ca 2c       	rcall	800028da <DeviceInitializationStatus_brdcst_func+0x26>
80002798:	80 00       	ld.sh	r0,r0[0x0]
8000279a:	62 90       	ld.w	r0,r1[0x24]
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	ca 40       	breq	800026e6 <mic_reply_func+0x1a>
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	ca 54       	brge	800026ec <mic_reply_func+0x20>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	ca 6c       	rcall	800028f2 <CalculateBurst+0x6>

800027a8 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027a8:	eb cd 40 80 	pushm	r7,lr
800027ac:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027ae:	19 a9       	ld.ub	r9,r12[0x2]
800027b0:	30 08       	mov	r8,0
800027b2:	f0 09 18 00 	cp.b	r9,r8
800027b6:	c1 b1       	brne	800027ec <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027b8:	19 b8       	ld.ub	r8,r12[0x3]
800027ba:	30 19       	mov	r9,1
800027bc:	f2 08 18 00 	cp.b	r8,r9
800027c0:	c0 51       	brne	800027ca <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027c2:	48 ec       	lddpc	r12,800027f8 <dcm_reply_func+0x50>
800027c4:	f0 1f 00 0e 	mcall	800027fc <dcm_reply_func+0x54>
800027c8:	c0 a8       	rjmp	800027dc <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027ca:	58 08       	cp.w	r8,0
800027cc:	c0 51       	brne	800027d6 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027ce:	48 dc       	lddpc	r12,80002800 <dcm_reply_func+0x58>
800027d0:	f0 1f 00 0b 	mcall	800027fc <dcm_reply_func+0x54>
800027d4:	c0 48       	rjmp	800027dc <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027d6:	48 cc       	lddpc	r12,80002804 <dcm_reply_func+0x5c>
800027d8:	f0 1f 00 09 	mcall	800027fc <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027dc:	0f d8       	ld.ub	r8,r7[0x5]
800027de:	1a d8       	st.w	--sp,r8
800027e0:	48 ac       	lddpc	r12,80002808 <dcm_reply_func+0x60>
800027e2:	f0 1f 00 07 	mcall	800027fc <dcm_reply_func+0x54>
800027e6:	2f fd       	sub	sp,-4
800027e8:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027ec:	48 8c       	lddpc	r12,8000280c <dcm_reply_func+0x64>
800027ee:	f0 1f 00 04 	mcall	800027fc <dcm_reply_func+0x54>
800027f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800027f6:	00 00       	add	r0,r0
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	ca 88       	rjmp	8000294a <payload_rx_process+0xa>
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	62 90       	ld.w	r0,r1[0x24]
80002800:	80 00       	ld.sh	r0,r0[0x0]
80002802:	ca 9c       	rcall	80002954 <payload_rx_process+0x14>
80002804:	80 00       	ld.sh	r0,r0[0x0]
80002806:	ca b0       	breq	8000275c <mic_reply_func+0x90>
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	ca c4       	brge	80002762 <dcm_brdcst_func+0x2>
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	ca d0       	breq	80002768 <dcm_brdcst_func+0x8>

80002810 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002810:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002812:	19 a9       	ld.ub	r9,r12[0x2]
80002814:	30 08       	mov	r8,0
80002816:	f0 09 18 00 	cp.b	r9,r8
8000281a:	c0 51       	brne	80002824 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
8000281c:	48 4c       	lddpc	r12,8000282c <ToneControl_reply_func+0x1c>
8000281e:	f0 1f 00 05 	mcall	80002830 <ToneControl_reply_func+0x20>
80002822:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002824:	48 4c       	lddpc	r12,80002834 <ToneControl_reply_func+0x24>
80002826:	f0 1f 00 03 	mcall	80002830 <ToneControl_reply_func+0x20>
8000282a:	d8 02       	popm	pc
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	ca dc       	rcall	80002988 <payload_rx_process+0x48>
80002830:	80 00       	ld.sh	r0,r0[0x0]
80002832:	62 90       	ld.w	r0,r1[0x24]
80002834:	80 00       	ld.sh	r0,r0[0x0]
80002836:	ca e4       	brge	80002792 <dcm_brdcst_func+0x32>

80002838 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002838:	eb cd 40 80 	pushm	r7,lr
8000283c:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000283e:	48 c9       	lddpc	r9,8000286c <app_payload_rx_proc+0x34>
80002840:	13 88       	ld.ub	r8,r9[0x0]
80002842:	2f f8       	sub	r8,-1
80002844:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
80002846:	30 39       	mov	r9,3
80002848:	f2 08 18 00 	cp.b	r8,r9
8000284c:	c0 71       	brne	8000285a <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000284e:	30 09       	mov	r9,0
80002850:	48 78       	lddpc	r8,8000286c <app_payload_rx_proc+0x34>
80002852:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002854:	48 7c       	lddpc	r12,80002870 <app_payload_rx_proc+0x38>
80002856:	f0 1f 00 08 	mcall	80002874 <app_payload_rx_proc+0x3c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
8000285a:	48 88       	lddpc	r8,80002878 <app_payload_rx_proc+0x40>
8000285c:	11 88       	ld.ub	r8,r8[0x0]
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000285e:	48 88       	lddpc	r8,8000287c <app_payload_rx_proc+0x44>
80002860:	70 0c       	ld.w	r12,r8[0x0]
80002862:	0e 9b       	mov	r11,r7
80002864:	f0 1f 00 07 	mcall	80002880 <app_payload_rx_proc+0x48>

}
80002868:	e3 cd 80 80 	ldm	sp++,r7,pc
8000286c:	00 00       	add	r0,r0
8000286e:	0a 48       	or	r8,r5
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	ca f0       	breq	800027d0 <dcm_reply_func+0x28>
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	62 90       	ld.w	r0,r1[0x24]
80002878:	00 00       	add	r0,r0
8000287a:	0a 40       	or	r0,r5
8000287c:	00 00       	add	r0,r0
8000287e:	0a 68       	and	r8,r5
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	29 e0       	sub	r0,-98

80002884 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002884:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002886:	19 a9       	ld.ub	r9,r12[0x2]
80002888:	30 08       	mov	r8,0
8000288a:	f0 09 18 00 	cp.b	r9,r8
8000288e:	c0 71       	brne	8000289c <AudioRoutingControl_reply_func+0x18>
	{
		log("AudioRouting OK");
80002890:	48 5c       	lddpc	r12,800028a4 <AudioRoutingControl_reply_func+0x20>
80002892:	f0 1f 00 06 	mcall	800028a8 <AudioRoutingControl_reply_func+0x24>
		xcmp_IdleTestTone();//提示通道配置成功
80002896:	f0 1f 00 06 	mcall	800028ac <AudioRoutingControl_reply_func+0x28>
8000289a:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
8000289c:	48 5c       	lddpc	r12,800028b0 <AudioRoutingControl_reply_func+0x2c>
8000289e:	f0 1f 00 03 	mcall	800028a8 <AudioRoutingControl_reply_func+0x24>
800028a2:	d8 02       	popm	pc
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	ca fc       	rcall	80002a04 <phy_tx+0x4>
800028a8:	80 00       	ld.sh	r0,r0[0x0]
800028aa:	62 90       	ld.w	r0,r1[0x24]
800028ac:	80 00       	ld.sh	r0,r0[0x0]
800028ae:	40 64       	lddsp	r4,sp[0x18]
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	cb 0c       	rcall	80002a12 <phy_tx+0x12>

800028b4 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028b4:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028b6:	19 e8       	ld.ub	r8,r12[0x6]
800028b8:	30 19       	mov	r9,1
800028ba:	f2 08 18 00 	cp.b	r8,r9
800028be:	c0 61       	brne	800028ca <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028c0:	48 98       	lddpc	r8,800028e4 <DeviceInitializationStatus_brdcst_func+0x30>
800028c2:	70 09       	ld.w	r9,r8[0x0]
800028c4:	a1 a9       	sbr	r9,0x0
800028c6:	91 09       	st.w	r8[0x0],r9
800028c8:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028ca:	30 29       	mov	r9,2
800028cc:	f2 08 18 00 	cp.b	r8,r9
800028d0:	c0 80       	breq	800028e0 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028d2:	48 58       	lddpc	r8,800028e4 <DeviceInitializationStatus_brdcst_func+0x30>
800028d4:	70 09       	ld.w	r9,r8[0x0]
800028d6:	e0 19 ff fc 	andl	r9,0xfffc
800028da:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028dc:	f0 1f 00 03 	mcall	800028e8 <DeviceInitializationStatus_brdcst_func+0x34>
800028e0:	d8 02       	popm	pc
800028e2:	00 00       	add	r0,r0
800028e4:	00 00       	add	r0,r0
800028e6:	0d 94       	ld.ub	r4,r6[0x1]
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	3f b8       	mov	r8,-5

800028ec <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800028ec:	20 1c       	sub	r12,1
800028ee:	5c 5c       	castu.b	r12
800028f0:	31 18       	mov	r8,17
800028f2:	f0 0c 18 00 	cp.b	r12,r8
800028f6:	e0 88 00 03 	brls	800028fc <CalculateBurst+0x10>
800028fa:	5e fd       	retal	0
800028fc:	48 28       	lddpc	r8,80002904 <CalculateBurst+0x18>
800028fe:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002902:	5e fc       	retal	r12
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	cb 28       	rjmp	80002a6a <get_idle_store_isr+0xe>

80002908 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
80002908:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000290a:	48 98       	lddpc	r8,8000292c <payload_init+0x24>
8000290c:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
8000290e:	48 98       	lddpc	r8,80002930 <payload_init+0x28>
80002910:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002912:	30 09       	mov	r9,0
80002914:	1a d9       	st.w	--sp,r9
80002916:	1a d9       	st.w	--sp,r9
80002918:	1a d9       	st.w	--sp,r9
8000291a:	30 28       	mov	r8,2
8000291c:	e0 6a 04 00 	mov	r10,1024
80002920:	48 5b       	lddpc	r11,80002934 <payload_init+0x2c>
80002922:	48 6c       	lddpc	r12,80002938 <payload_init+0x30>
80002924:	f0 1f 00 06 	mcall	8000293c <payload_init+0x34>
80002928:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000292a:	d8 02       	popm	pc
8000292c:	00 00       	add	r0,r0
8000292e:	0a 54       	eor	r4,r5
80002930:	00 00       	add	r0,r0
80002932:	0a 58       	eor	r8,r5
80002934:	80 00       	ld.sh	r0,r0[0x0]
80002936:	cb 70       	breq	800028a4 <AudioRoutingControl_reply_func+0x20>
80002938:	80 00       	ld.sh	r0,r0[0x0]
8000293a:	29 40       	sub	r0,-108
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	5e cc       	retvs	r12

80002940 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002940:	eb cd 40 f8 	pushm	r3-r7,lr
80002944:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002946:	48 e8       	lddpc	r8,8000297c <payload_rx_process+0x3c>
80002948:	70 08       	ld.w	r8,r8[0x0]
8000294a:	58 08       	cp.w	r8,0
8000294c:	c0 71       	brne	8000295a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000294e:	30 4b       	mov	r11,4
80002950:	30 5c       	mov	r12,5
80002952:	f0 1f 00 0c 	mcall	80002980 <payload_rx_process+0x40>
80002956:	48 a8       	lddpc	r8,8000297c <payload_rx_process+0x3c>
80002958:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000295a:	48 96       	lddpc	r6,8000297c <payload_rx_process+0x3c>
8000295c:	30 05       	mov	r5,0
8000295e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002960:	48 93       	lddpc	r3,80002984 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002962:	6c 0c       	ld.w	r12,r6[0x0]
80002964:	0a 99       	mov	r9,r5
80002966:	08 9a       	mov	r10,r4
80002968:	1a 9b       	mov	r11,sp
8000296a:	f0 1f 00 08 	mcall	80002988 <payload_rx_process+0x48>
8000296e:	58 1c       	cp.w	r12,1
80002970:	cf 91       	brne	80002962 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002972:	66 08       	ld.w	r8,r3[0x0]
80002974:	40 0c       	lddsp	r12,sp[0x0]
80002976:	5d 18       	icall	r8
80002978:	cf 5b       	rjmp	80002962 <payload_rx_process+0x22>
8000297a:	00 00       	add	r0,r0
8000297c:	00 00       	add	r0,r0
8000297e:	0a 8c       	andn	r12,r5
80002980:	80 00       	ld.sh	r0,r0[0x0]
80002982:	57 f8       	stdsp	sp[0x1fc],r8
80002984:	00 00       	add	r0,r0
80002986:	0a 54       	eor	r4,r5
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	54 94       	stdsp	sp[0x124],r4

8000298c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000298c:	d4 01       	pushm	lr
8000298e:	20 2d       	sub	sp,8
80002990:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002992:	30 09       	mov	r9,0
80002994:	fa ca ff f8 	sub	r10,sp,-8
80002998:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000299a:	1a 9b       	mov	r11,sp
8000299c:	f0 1f 00 02 	mcall	800029a4 <set_idle_store_isr+0x18>
}
800029a0:	2f ed       	sub	sp,-8
800029a2:	d8 02       	popm	pc
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	56 50       	stdsp	sp[0x194],r0

800029a8 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800029a8:	d4 01       	pushm	lr
800029aa:	20 2d       	sub	sp,8
800029ac:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800029ae:	58 0c       	cp.w	r12,0
800029b0:	c1 10       	breq	800029d2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029b2:	30 08       	mov	r8,0
800029b4:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029b6:	98 88       	ld.uh	r8,r12[0x0]
800029b8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029bc:	e0 48 40 00 	cp.w	r8,16384
800029c0:	c0 91       	brne	800029d2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029c2:	48 68       	lddpc	r8,800029d8 <phy_rx+0x30>
800029c4:	70 0c       	ld.w	r12,r8[0x0]
800029c6:	30 09       	mov	r9,0
800029c8:	fa ca ff fc 	sub	r10,sp,-4
800029cc:	1a 9b       	mov	r11,sp
800029ce:	f0 1f 00 04 	mcall	800029dc <phy_rx+0x34>
		}	

    }
		
 
}
800029d2:	2f ed       	sub	sp,-8
800029d4:	d8 02       	popm	pc
800029d6:	00 00       	add	r0,r0
800029d8:	00 00       	add	r0,r0
800029da:	0a b0       	st.h	r5++,r0
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	56 50       	stdsp	sp[0x194],r0

800029e0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029e0:	eb cd 40 80 	pushm	r7,lr
800029e4:	20 1d       	sub	sp,4
800029e6:	fa c7 ff fc 	sub	r7,sp,-4
800029ea:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029ec:	30 09       	mov	r9,0
800029ee:	12 9a       	mov	r10,r9
800029f0:	1a 9b       	mov	r11,sp
800029f2:	f0 1f 00 03 	mcall	800029fc <set_idle_store+0x1c>
}
800029f6:	2f fd       	sub	sp,-4
800029f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	56 a0       	stdsp	sp[0x1a8],r0

80002a00 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a00:	d4 01       	pushm	lr
80002a02:	20 1d       	sub	sp,4
80002a04:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a06:	98 88       	ld.uh	r8,r12[0x0]
80002a08:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a0c:	e0 48 40 00 	cp.w	r8,16384
80002a10:	c0 d1       	brne	80002a2a <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a12:	49 08       	lddpc	r8,80002a50 <phy_tx+0x50>
80002a14:	70 08       	ld.w	r8,r8[0x0]
80002a16:	58 08       	cp.w	r8,0
80002a18:	c1 a0       	breq	80002a4c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a1a:	48 e8       	lddpc	r8,80002a50 <phy_tx+0x50>
80002a1c:	70 0c       	ld.w	r12,r8[0x0]
80002a1e:	30 09       	mov	r9,0
80002a20:	12 9a       	mov	r10,r9
80002a22:	1a 9b       	mov	r11,sp
80002a24:	f0 1f 00 0c 	mcall	80002a54 <phy_tx+0x54>
80002a28:	c1 28       	rjmp	80002a4c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a2a:	e0 48 10 00 	cp.w	r8,4096
80002a2e:	5f 0a       	sreq	r10
80002a30:	e0 48 20 00 	cp.w	r8,8192
80002a34:	5f 09       	sreq	r9
80002a36:	f5 e9 10 09 	or	r9,r10,r9
80002a3a:	c0 71       	brne	80002a48 <phy_tx+0x48>
80002a3c:	e0 48 50 00 	cp.w	r8,20480
80002a40:	c0 40       	breq	80002a48 <phy_tx+0x48>
80002a42:	e0 48 60 00 	cp.w	r8,24576
80002a46:	c0 31       	brne	80002a4c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a48:	48 48       	lddpc	r8,80002a58 <phy_tx+0x58>
80002a4a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a4c:	2f fd       	sub	sp,-4
80002a4e:	d8 02       	popm	pc
80002a50:	00 00       	add	r0,r0
80002a52:	0a c4       	st.b	r5++,r4
80002a54:	80 00       	ld.sh	r0,r0[0x0]
80002a56:	56 a0       	stdsp	sp[0x1a8],r0
80002a58:	00 00       	add	r0,r0
80002a5a:	0a ac       	st.w	r5++,r12

80002a5c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a5c:	d4 01       	pushm	lr
80002a5e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a60:	30 08       	mov	r8,0
80002a62:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a64:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a66:	1a 9a       	mov	r10,sp
80002a68:	fa cb ff fc 	sub	r11,sp,-4
80002a6c:	f0 1f 00 05 	mcall	80002a80 <get_idle_store_isr+0x24>
80002a70:	58 1c       	cp.w	r12,1
80002a72:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a76:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a7a:	2f ed       	sub	sp,-8
80002a7c:	d8 02       	popm	pc
80002a7e:	00 00       	add	r0,r0
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	53 a4       	stdsp	sp[0xe8],r4

80002a84 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a84:	eb cd 40 c0 	pushm	r6-r7,lr
80002a88:	20 1d       	sub	sp,4
80002a8a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a8c:	fe f8 04 6c 	ld.w	r8,pc[1132]
80002a90:	70 08       	ld.w	r8,r8[0x0]
80002a92:	58 08       	cp.w	r8,0
80002a94:	c7 40       	breq	80002b7c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a96:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a98:	30 08       	mov	r8,0
80002a9a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a9c:	fe f8 04 60 	ld.w	r8,pc[1120]
80002aa0:	70 08       	ld.w	r8,r8[0x0]
80002aa2:	58 18       	cp.w	r8,1
80002aa4:	c2 90       	breq	80002af6 <phy_tx_func+0x72>
80002aa6:	c0 43       	brcs	80002aae <phy_tx_func+0x2a>
80002aa8:	58 28       	cp.w	r8,2
80002aaa:	c6 91       	brne	80002b7c <phy_tx_func+0xf8>
80002aac:	c6 18       	rjmp	80002b6e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002aae:	fe f8 04 4a 	ld.w	r8,pc[1098]
80002ab2:	70 0c       	ld.w	r12,r8[0x0]
80002ab4:	1a 9a       	mov	r10,sp
80002ab6:	fe fb 04 4a 	ld.w	r11,pc[1098]
80002aba:	f0 1f 01 13 	mcall	80002f04 <phy_tx_func+0x480>
80002abe:	58 1c       	cp.w	r12,1
80002ac0:	c1 51       	brne	80002aea <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002ac2:	fe f8 04 3e 	ld.w	r8,pc[1086]
80002ac6:	70 08       	ld.w	r8,r8[0x0]
80002ac8:	11 9a       	ld.ub	r10,r8[0x1]
80002aca:	fe f9 04 3e 	ld.w	r9,pc[1086]
80002ace:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002ad0:	90 88       	ld.uh	r8,r8[0x0]
80002ad2:	ea 18 ab cd 	orh	r8,0xabcd
80002ad6:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002ad8:	30 19       	mov	r9,1
80002ada:	fe f8 04 32 	ld.w	r8,pc[1074]
80002ade:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ae0:	30 19       	mov	r9,1
80002ae2:	fe f8 04 1a 	ld.w	r8,pc[1050]
80002ae6:	91 09       	st.w	r8[0x0],r9
80002ae8:	c4 a8       	rjmp	80002b7c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002aea:	e0 68 5a 5a 	mov	r8,23130
80002aee:	ea 18 ab cd 	orh	r8,0xabcd
80002af2:	8f 18       	st.w	r7[0x4],r8
80002af4:	c4 48       	rjmp	80002b7c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002af6:	fe f9 04 16 	ld.w	r9,pc[1046]
80002afa:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002afc:	fe fa 04 04 	ld.w	r10,pc[1028]
80002b00:	74 0a       	ld.w	r10,r10[0x0]
80002b02:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b06:	b1 6a       	lsl	r10,0x10
80002b08:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b0a:	2f f8       	sub	r8,-1
80002b0c:	5c 58       	castu.b	r8
80002b0e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b10:	fe fa 03 f8 	ld.w	r10,pc[1016]
80002b14:	94 09       	ld.sh	r9,r10[0x0]
80002b16:	20 29       	sub	r9,2
80002b18:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b1a:	30 0a       	mov	r10,0
80002b1c:	f4 09 19 00 	cp.h	r9,r10
80002b20:	e0 89 00 0b 	brgt	80002b36 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b24:	78 18       	ld.w	r8,r12[0x4]
80002b26:	e8 18 00 ba 	orl	r8,0xba
80002b2a:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b2c:	30 09       	mov	r9,0
80002b2e:	fe f8 03 ce 	ld.w	r8,pc[974]
80002b32:	91 09       	st.w	r8[0x0],r9
80002b34:	c2 48       	rjmp	80002b7c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b36:	fe f9 03 ca 	ld.w	r9,pc[970]
80002b3a:	72 09       	ld.w	r9,r9[0x0]
80002b3c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b40:	78 1a       	ld.w	r10,r12[0x4]
80002b42:	f5 e9 10 09 	or	r9,r10,r9
80002b46:	99 19       	st.w	r12[0x4],r9
80002b48:	2f f8       	sub	r8,-1
80002b4a:	fe f9 03 c2 	ld.w	r9,pc[962]
80002b4e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b50:	fe f9 03 b8 	ld.w	r9,pc[952]
80002b54:	92 08       	ld.sh	r8,r9[0x0]
80002b56:	20 28       	sub	r8,2
80002b58:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b5a:	30 09       	mov	r9,0
80002b5c:	f2 08 19 00 	cp.h	r8,r9
80002b60:	e0 89 00 0e 	brgt	80002b7c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b64:	30 29       	mov	r9,2
80002b66:	fe f8 03 96 	ld.w	r8,pc[918]
80002b6a:	91 09       	st.w	r8[0x0],r9
80002b6c:	c0 88       	rjmp	80002b7c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b6e:	fc 18 00 ba 	movh	r8,0xba
80002b72:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b74:	30 09       	mov	r9,0
80002b76:	fe f8 03 86 	ld.w	r8,pc[902]
80002b7a:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_Media == TRUE))
80002b7c:	fe f8 03 94 	ld.w	r8,pc[916]
80002b80:	11 89       	ld.ub	r9,r8[0x0]
80002b82:	30 18       	mov	r8,1
80002b84:	f0 09 18 00 	cp.b	r9,r8
80002b88:	e0 81 01 ad 	brne	80002ee2 <phy_tx_func+0x45e>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002b8c:	fe f8 03 88 	ld.w	r8,pc[904]
80002b90:	70 08       	ld.w	r8,r8[0x0]
80002b92:	e0 48 05 b0 	cp.w	r8,1456
80002b96:	f9 b8 02 00 	movhs	r8,0
80002b9a:	fe f9 03 7a 	ld.w	r9,pc[890]
80002b9e:	93 08       	st.w	r9[0x0],r8
	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002ba0:	fe f8 03 78 	ld.w	r8,pc[888]
80002ba4:	70 08       	ld.w	r8,r8[0x0]
80002ba6:	58 68       	cp.w	r8,6
80002ba8:	e0 8b 01 93 	brhi	80002ece <phy_tx_func+0x44a>
80002bac:	fe f9 03 70 	ld.w	r9,pc[880]
80002bb0:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002bb4:	fe f8 03 6c 	ld.w	r8,pc[876]
80002bb8:	70 08       	ld.w	r8,r8[0x0]
80002bba:	58 08       	cp.w	r8,0
80002bbc:	c0 b0       	breq	80002bd2 <phy_tx_func+0x14e>
80002bbe:	fe f8 03 62 	ld.w	r8,pc[866]
80002bc2:	70 08       	ld.w	r8,r8[0x0]
80002bc4:	58 a8       	cp.w	r8,10
80002bc6:	c0 60       	breq	80002bd2 <phy_tx_func+0x14e>
80002bc8:	fe f8 03 58 	ld.w	r8,pc[856]
80002bcc:	70 08       	ld.w	r8,r8[0x0]
80002bce:	58 18       	cp.w	r8,1
80002bd0:	c0 a1       	brne	80002be4 <phy_tx_func+0x160>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002bd2:	e0 68 5a 5a 	mov	r8,23130
80002bd6:	ea 18 ab cd 	orh	r8,0xabcd
80002bda:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002bdc:	30 08       	mov	r8,0
80002bde:	8f 38       	st.w	r7[0xc],r8
80002be0:	e0 8f 01 88 	bral	80002ef0 <phy_tx_func+0x46c>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002be4:	fe f8 03 3c 	ld.w	r8,pc[828]
80002be8:	70 08       	ld.w	r8,r8[0x0]
80002bea:	58 38       	cp.w	r8,3
80002bec:	c0 91       	brne	80002bfe <phy_tx_func+0x17a>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002bee:	fe f8 03 36 	ld.w	r8,pc[822]
80002bf2:	70 09       	ld.w	r9,r8[0x0]
80002bf4:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002bf6:	70 18       	ld.w	r8,r8[0x4]
80002bf8:	8f 38       	st.w	r7[0xc],r8
80002bfa:	e0 8f 01 7b 	bral	80002ef0 <phy_tx_func+0x46c>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + soft decision value + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 4 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002bfe:	fe f8 03 22 	ld.w	r8,pc[802]
80002c02:	70 08       	ld.w	r8,r8[0x0]
80002c04:	58 28       	cp.w	r8,2
80002c06:	c1 31       	brne	80002c2c <phy_tx_func+0x1a8>
					{
						//0xABCDCO32
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//50bytes
80002c08:	e0 68 c0 32 	mov	r8,49202
80002c0c:	ea 18 ab cd 	orh	r8,0xabcd
80002c10:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c12:	fe 78 84 7f 	mov	r8,-31617
80002c16:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c18:	fe f8 03 10 	ld.w	r8,pc[784]
80002c1c:	90 08       	ld.sh	r8,r8[0x0]
80002c1e:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c20:	30 39       	mov	r9,3
80002c22:	fe f8 02 f6 	ld.w	r8,pc[758]
80002c26:	91 09       	st.w	r8[0x0],r9
80002c28:	e0 8f 01 64 	bral	80002ef0 <phy_tx_func+0x46c>
					//assemble 2 items into 1 Command. Send it to Radio.
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c2c:	e0 68 c0 0e 	mov	r8,49166
80002c30:	ea 18 ab cd 	orh	r8,0xabcd
80002c34:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c36:	fe f8 02 f6 	ld.w	r8,pc[758]
80002c3a:	90 09       	ld.sh	r9,r8[0x0]
80002c3c:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c3e:	90 18       	ld.sh	r8,r8[0x2]
80002c40:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c42:	30 19       	mov	r9,1
80002c44:	fe f8 02 d4 	ld.w	r8,pc[724]
80002c48:	91 09       	st.w	r8[0x0],r9
80002c4a:	e0 8f 01 53 	bral	80002ef0 <phy_tx_func+0x46c>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c4e:	fe 78 88 f2 	mov	r8,-30478
80002c52:	ae 48       	st.h	r7[0x8],r8
				//A_index+=2;
				//
				//AMBEpayload_tx_state = AMBE_EN_LAST;
				
			
				switch (m_RxBurstType)//在发送函数中去做加密处理
80002c54:	fe f8 02 cc 	ld.w	r8,pc[716]
80002c58:	70 08       	ld.w	r8,r8[0x0]
80002c5a:	58 48       	cp.w	r8,4
80002c5c:	c0 60       	breq	80002c68 <phy_tx_func+0x1e4>
80002c5e:	c4 53       	brcs	80002ce8 <phy_tx_func+0x264>
80002c60:	58 98       	cp.w	r8,9
80002c62:	e0 8b 00 43 	brhi	80002ce8 <phy_tx_func+0x264>
80002c66:	c2 98       	rjmp	80002cb8 <phy_tx_func+0x234>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002c68:	fe f8 02 c8 	ld.w	r8,pc[712]
80002c6c:	11 89       	ld.ub	r9,r8[0x0]
80002c6e:	30 18       	mov	r8,1
80002c70:	f0 09 18 00 	cp.b	r9,r8
80002c74:	c0 a1       	brne	80002c88 <phy_tx_func+0x204>
							{	
								
								
								//Place public key
								payload_tx_channel->word[1] = Public_AMBEkey[0];
80002c76:	fe f8 02 be 	ld.w	r8,pc[702]
80002c7a:	90 09       	ld.sh	r9,r8[0x0]
80002c7c:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = Public_AMBEkey[1];
80002c7e:	90 19       	ld.sh	r9,r8[0x2]
80002c80:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = Public_AMBEkey[2];
80002c82:	90 28       	ld.sh	r8,r8[0x4]
80002c84:	ae 78       	st.h	r7[0xe],r8
80002c86:	c1 48       	rjmp	80002cae <phy_tx_func+0x22a>
							{
								
								
						
								//Encrypted AMBE data(XOR)
								payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002c88:	fe f9 02 b0 	ld.w	r9,pc[688]
80002c8c:	92 0b       	ld.sh	r11,r9[0x0]
80002c8e:	fe f8 02 a6 	ld.w	r8,pc[678]
80002c92:	90 0a       	ld.sh	r10,r8[0x0]
80002c94:	f7 ea 20 0a 	eor	r10,r11,r10
80002c98:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002c9a:	92 1b       	ld.sh	r11,r9[0x2]
80002c9c:	90 1a       	ld.sh	r10,r8[0x2]
80002c9e:	f7 ea 20 0a 	eor	r10,r11,r10
80002ca2:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002ca4:	92 29       	ld.sh	r9,r9[0x4]
80002ca6:	90 28       	ld.sh	r8,r8[0x4]
80002ca8:	f3 e8 20 08 	eor	r8,r9,r8
80002cac:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cae:	30 29       	mov	r9,2
80002cb0:	fe f8 02 68 	ld.w	r8,pc[616]
80002cb4:	91 09       	st.w	r8[0x0],r9
80002cb6:	c1 d9       	rjmp	80002ef0 <phy_tx_func+0x46c>
							//Encrypted AMBE data(XOR)
						
							//payload_tx_channel->word[1] = AMBEBurst_rawdata[0];
							//payload_tx_channel->word[2] = AMBEBurst_rawdata[1];
							//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							payload_tx_channel->word[1] = ((Public_AMBEkey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002cb8:	fe f9 02 80 	ld.w	r9,pc[640]
80002cbc:	92 0b       	ld.sh	r11,r9[0x0]
80002cbe:	fe f8 02 76 	ld.w	r8,pc[630]
80002cc2:	90 0a       	ld.sh	r10,r8[0x0]
80002cc4:	f7 ea 20 0a 	eor	r10,r11,r10
80002cc8:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((Public_AMBEkey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002cca:	92 1b       	ld.sh	r11,r9[0x2]
80002ccc:	90 1a       	ld.sh	r10,r8[0x2]
80002cce:	f7 ea 20 0a 	eor	r10,r11,r10
80002cd2:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((Public_AMBEkey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002cd4:	92 29       	ld.sh	r9,r9[0x4]
80002cd6:	90 28       	ld.sh	r8,r8[0x4]
80002cd8:	f3 e8 20 08 	eor	r8,r9,r8
80002cdc:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_EN_LAST;
80002cde:	30 29       	mov	r9,2
80002ce0:	fe f8 02 38 	ld.w	r8,pc[568]
80002ce4:	91 09       	st.w	r8[0x0],r9
80002ce6:	c0 59       	rjmp	80002ef0 <phy_tx_func+0x46c>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ce8:	e0 68 5a 5a 	mov	r8,23130
80002cec:	ea 18 ab cd 	orh	r8,0xabcd
80002cf0:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002cf2:	30 08       	mov	r8,0
80002cf4:	8f 38       	st.w	r7[0xc],r8
							
							AMBEpayload_tx_state = AMBE_IDLE;
80002cf6:	fe f9 02 22 	ld.w	r9,pc[546]
80002cfa:	93 08       	st.w	r9[0x0],r8
80002cfc:	cf a8       	rjmp	80002ef0 <phy_tx_func+0x46c>
					
				
					//Encrypted AMBE data(XOR)
					//payload_tx_channel->word[0] = AMBEBurst_rawdata[3];
				
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
80002cfe:	fe f8 02 22 	ld.w	r8,pc[546]
80002d02:	70 08       	ld.w	r8,r8[0x0]
80002d04:	58 48       	cp.w	r8,4
80002d06:	c0 d1       	brne	80002d20 <phy_tx_func+0x29c>
80002d08:	fe f8 02 28 	ld.w	r8,pc[552]
80002d0c:	11 89       	ld.ub	r9,r8[0x0]
80002d0e:	30 18       	mov	r8,1
80002d10:	f0 09 18 00 	cp.b	r9,r8
80002d14:	c0 61       	brne	80002d20 <phy_tx_func+0x29c>
					{
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3])) ;
80002d16:	fe f8 02 1e 	ld.w	r8,pc[542]
80002d1a:	90 38       	ld.sh	r8,r8[0x6]
80002d1c:	ae 48       	st.h	r7[0x8],r8
80002d1e:	c0 a8       	rjmp	80002d32 <phy_tx_func+0x2ae>
					}
					else{
						
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002d20:	fe f8 02 18 	ld.w	r8,pc[536]
80002d24:	90 39       	ld.sh	r9,r8[0x6]
80002d26:	fe f8 02 0e 	ld.w	r8,pc[526]
80002d2a:	90 38       	ld.sh	r8,r8[0x6]
80002d2c:	f3 e8 20 08 	eor	r8,r9,r8
80002d30:	ae 48       	st.h	r7[0x8],r8
					
					
					//payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
					//A_index+=1;
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d32:	e0 68 00 ba 	mov	r8,186
80002d36:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d38:	30 08       	mov	r8,0
80002d3a:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d3c:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d3e:	30 09       	mov	r9,0
80002d40:	4f 68       	lddpc	r8,80002f18 <phy_tx_func+0x494>
80002d42:	91 09       	st.w	r8[0x0],r9
80002d44:	cd 68       	rjmp	80002ef0 <phy_tx_func+0x46c>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d46:	4f 98       	lddpc	r8,80002f28 <phy_tx_func+0x4a4>
80002d48:	90 18       	ld.sh	r8,r8[0x2]
80002d4a:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d4c:	4f 88       	lddpc	r8,80002f2c <phy_tx_func+0x4a8>
80002d4e:	90 08       	ld.sh	r8,r8[0x0]
80002d50:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d52:	4f 48       	lddpc	r8,80002f20 <phy_tx_func+0x49c>
80002d54:	70 08       	ld.w	r8,r8[0x0]
80002d56:	58 48       	cp.w	r8,4
80002d58:	c0 c1       	brne	80002d70 <phy_tx_func+0x2ec>
80002d5a:	4f 68       	lddpc	r8,80002f30 <phy_tx_func+0x4ac>
80002d5c:	11 89       	ld.ub	r9,r8[0x0]
80002d5e:	30 18       	mov	r8,1
80002d60:	f0 09 18 00 	cp.b	r9,r8
80002d64:	c0 61       	brne	80002d70 <phy_tx_func+0x2ec>
					{
						// Vocoder Bits Stream Parameter("E(bit8)" flag = 1)
						//0xF0(8+)x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0100));
80002d66:	4f 28       	lddpc	r8,80002f2c <phy_tx_func+0x4a8>
80002d68:	90 18       	ld.sh	r8,r8[0x2]
80002d6a:	a9 a8       	sbr	r8,0x8
80002d6c:	ae 68       	st.h	r7[0xc],r8
80002d6e:	c0 48       	rjmp	80002d76 <phy_tx_func+0x2f2>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d70:	4e f8       	lddpc	r8,80002f2c <phy_tx_func+0x4a8>
80002d72:	90 18       	ld.sh	r8,r8[0x2]
80002d74:	ae 68       	st.h	r7[0xc],r8
					
					//0x9A13
					payload_tx_channel->word[3] = SDV_PAYLOAD;
80002d76:	fe 78 9a 13 	mov	r8,-26093
80002d7a:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d7c:	30 49       	mov	r9,4
80002d7e:	4e 78       	lddpc	r8,80002f18 <phy_tx_func+0x494>
80002d80:	91 09       	st.w	r8[0x0],r9
80002d82:	cb 78       	rjmp	80002ef0 <phy_tx_func+0x46c>
				break;
			
			case AMBE_DE_SECOND:
					//Post back soft decision value data

						payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002d84:	4e e8       	lddpc	r8,80002f3c <phy_tx_func+0x4b8>
80002d86:	70 0a       	ld.w	r10,r8[0x0]
80002d88:	4e e9       	lddpc	r9,80002f40 <phy_tx_func+0x4bc>
80002d8a:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d8e:	ae 4a       	st.h	r7[0x8],r10
						payload_tx_channel->word[1] = Soft_Decision_Data[Soft_index+1] ;
80002d90:	70 0a       	ld.w	r10,r8[0x0]
80002d92:	2f fa       	sub	r10,-1
80002d94:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002d98:	ae 5a       	st.h	r7[0xa],r10
						payload_tx_channel->word[2] = Soft_Decision_Data[Soft_index+2] ;
80002d9a:	70 0a       	ld.w	r10,r8[0x0]
80002d9c:	2f ea       	sub	r10,-2
80002d9e:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
80002da2:	ae 6a       	st.h	r7[0xc],r10
						payload_tx_channel->word[3] = Soft_Decision_Data[Soft_index+3] ;
80002da4:	70 0a       	ld.w	r10,r8[0x0]
80002da6:	2f da       	sub	r10,-3
80002da8:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002dac:	ae 79       	st.h	r7[0xe],r9
						Soft_index +=4;
80002dae:	70 09       	ld.w	r9,r8[0x0]
80002db0:	2f c9       	sub	r9,-4
80002db2:	91 09       	st.w	r8[0x0],r9
						
						if (Soft_index == 12)
80002db4:	58 c9       	cp.w	r9,12
80002db6:	c0 51       	brne	80002dc0 <phy_tx_func+0x33c>
						{
							AMBEpayload_tx_state = AMBE_DE_THIRD;
80002db8:	30 59       	mov	r9,5
80002dba:	4d 88       	lddpc	r8,80002f18 <phy_tx_func+0x494>
80002dbc:	91 09       	st.w	r8[0x0],r9
80002dbe:	c9 98       	rjmp	80002ef0 <phy_tx_func+0x46c>
							//Soft_index = 0 ;
							
						}
						else
						AMBEpayload_tx_state = AMBE_DE_SECOND;
80002dc0:	30 49       	mov	r9,4
80002dc2:	4d 68       	lddpc	r8,80002f18 <phy_tx_func+0x494>
80002dc4:	91 09       	st.w	r8[0x0],r9
80002dc6:	c9 58       	rjmp	80002ef0 <phy_tx_func+0x46c>
				break;	
				
			case AMBE_DE_THIRD:
					
					//0x xxxx
					payload_tx_channel->word[0] = Soft_Decision_Data[Soft_index] ;
80002dc8:	4d d8       	lddpc	r8,80002f3c <phy_tx_func+0x4b8>
80002dca:	70 0a       	ld.w	r10,r8[0x0]
80002dcc:	4d d9       	lddpc	r9,80002f40 <phy_tx_func+0x4bc>
80002dce:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
80002dd2:	ae 49       	st.h	r7[0x8],r9
					Soft_index = 0 ;//索引清零
80002dd4:	30 09       	mov	r9,0
80002dd6:	91 09       	st.w	r8[0x0],r9
					
					//0x8003 隔离符号？
					payload_tx_channel->word[1] = 0x8003;
80002dd8:	fe 78 80 03 	mov	r8,-32765
80002ddc:	ae 58       	st.h	r7[0xa],r8
					//0x88F3
					payload_tx_channel->word[2] = DECODER_PAYLOAD;
80002dde:	fe 78 88 f3 	mov	r8,-30477
80002de2:	ae 68       	st.h	r7[0xc],r8
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002de4:	4c f8       	lddpc	r8,80002f20 <phy_tx_func+0x49c>
80002de6:	70 08       	ld.w	r8,r8[0x0]
80002de8:	58 48       	cp.w	r8,4
80002dea:	c0 60       	breq	80002df6 <phy_tx_func+0x372>
80002dec:	c2 03       	brcs	80002e2c <phy_tx_func+0x3a8>
80002dee:	58 98       	cp.w	r8,9
80002df0:	e0 8b 00 1e 	brhi	80002e2c <phy_tx_func+0x3a8>
80002df4:	c1 58       	rjmp	80002e1e <phy_tx_func+0x39a>
					{
						case VOICEBURST_A:
								if (VF_SN == 1)
80002df6:	4c f8       	lddpc	r8,80002f30 <phy_tx_func+0x4ac>
80002df8:	11 89       	ld.ub	r9,r8[0x0]
80002dfa:	30 18       	mov	r8,1
80002dfc:	f0 09 18 00 	cp.b	r9,r8
80002e00:	c0 81       	brne	80002e10 <phy_tx_func+0x38c>
								{	
									//Pick up public key
									AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002e02:	4c e8       	lddpc	r8,80002f38 <phy_tx_func+0x4b4>
80002e04:	90 0a       	ld.sh	r10,r8[0x0]
80002e06:	4d 09       	lddpc	r9,80002f44 <phy_tx_func+0x4c0>
80002e08:	b2 0a       	st.h	r9[0x0],r10
									
									//Post back data
									payload_tx_channel->word[3] = AMBEBurst_rawdata[0] ;
80002e0a:	90 08       	ld.sh	r8,r8[0x0]
80002e0c:	ae 78       	st.h	r7[0xe],r8
80002e0e:	c0 48       	rjmp	80002e16 <phy_tx_func+0x392>
									//Decrypt AMBE data(XOR) 
									//Recover data

									//payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
									
									payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
80002e10:	4c a8       	lddpc	r8,80002f38 <phy_tx_func+0x4b4>
80002e12:	90 08       	ld.sh	r8,r8[0x0]
80002e14:	ae 78       	st.h	r7[0xe],r8
						
								}
					
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e16:	30 69       	mov	r9,6
80002e18:	4c 08       	lddpc	r8,80002f18 <phy_tx_func+0x494>
80002e1a:	91 09       	st.w	r8[0x0],r9
80002e1c:	c6 a8       	rjmp	80002ef0 <phy_tx_func+0x46c>
								//Encrypted AMBE data(XOR)
						
								//Decrypt AMBE data(XOR)
								//Recover data
								//payload_tx_channel->word[3] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
								payload_tx_channel->word[3] = ((AMBEBurst_rawdata[0])) ;
80002e1e:	4c 78       	lddpc	r8,80002f38 <phy_tx_func+0x4b4>
80002e20:	90 08       	ld.sh	r8,r8[0x0]
80002e22:	ae 78       	st.h	r7[0xe],r8
						
								AMBEpayload_tx_state = AMBE_DE_LAST;
80002e24:	30 69       	mov	r9,6
80002e26:	4b d8       	lddpc	r8,80002f18 <phy_tx_func+0x494>
80002e28:	91 09       	st.w	r8[0x0],r9
80002e2a:	c6 38       	rjmp	80002ef0 <phy_tx_func+0x46c>
				
							break;
						default://This shouldn't happen, but must check;
					
								payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e2c:	e0 68 5a 5a 	mov	r8,23130
80002e30:	ea 18 ab cd 	orh	r8,0xabcd
80002e34:	8f 28       	st.w	r7[0x8],r8
								payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e36:	30 08       	mov	r8,0
80002e38:	8f 38       	st.w	r7[0xc],r8
								AMBEpayload_tx_state = AMBE_IDLE;
80002e3a:	4b 89       	lddpc	r9,80002f18 <phy_tx_func+0x494>
80002e3c:	93 08       	st.w	r9[0x0],r8
80002e3e:	c5 98       	rjmp	80002ef0 <phy_tx_func+0x46c>
		
					break;
				
			case AMBE_DE_LAST:
				
					switch (m_RxBurstType)//在发送函数中去做解密处理
80002e40:	4b 88       	lddpc	r8,80002f20 <phy_tx_func+0x49c>
80002e42:	70 08       	ld.w	r8,r8[0x0]
80002e44:	58 48       	cp.w	r8,4
80002e46:	c0 60       	breq	80002e52 <phy_tx_func+0x3ce>
80002e48:	c3 93       	brcs	80002eba <phy_tx_func+0x436>
80002e4a:	58 98       	cp.w	r8,9
80002e4c:	e0 8b 00 37 	brhi	80002eba <phy_tx_func+0x436>
80002e50:	c2 78       	rjmp	80002e9e <phy_tx_func+0x41a>
					{
						case VOICEBURST_A:
							if (VF_SN == 1)
80002e52:	4b 88       	lddpc	r8,80002f30 <phy_tx_func+0x4ac>
80002e54:	11 89       	ld.ub	r9,r8[0x0]
80002e56:	30 18       	mov	r8,1
80002e58:	f0 09 18 00 	cp.b	r9,r8
80002e5c:	c1 31       	brne	80002e82 <phy_tx_func+0x3fe>
							{
								//Pick up public key
							
								AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002e5e:	4b 78       	lddpc	r8,80002f38 <phy_tx_func+0x4b4>
80002e60:	90 1a       	ld.sh	r10,r8[0x2]
80002e62:	4b 99       	lddpc	r9,80002f44 <phy_tx_func+0x4c0>
80002e64:	b2 1a       	st.h	r9[0x2],r10
								AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002e66:	90 2a       	ld.sh	r10,r8[0x4]
80002e68:	b2 2a       	st.h	r9[0x4],r10
								AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002e6a:	90 3a       	ld.sh	r10,r8[0x6]
80002e6c:	b2 3a       	st.h	r9[0x6],r10
							
								//Post back data
								payload_tx_channel->word[0] = AMBEBurst_rawdata[1] ;
80002e6e:	90 19       	ld.sh	r9,r8[0x2]
80002e70:	ae 49       	st.h	r7[0x8],r9
								payload_tx_channel->word[1] = AMBEBurst_rawdata[2] ;
80002e72:	90 29       	ld.sh	r9,r8[0x4]
80002e74:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = AMBEBurst_rawdata[3] ;
80002e76:	90 38       	ld.sh	r8,r8[0x6]
80002e78:	ae 68       	st.h	r7[0xc],r8
								payload_tx_channel->word[3] = 0x00BA ;
80002e7a:	e0 68 00 ba 	mov	r8,186
80002e7e:	ae 78       	st.h	r7[0xe],r8
80002e80:	c0 b8       	rjmp	80002e96 <phy_tx_func+0x412>

									//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
									//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
									//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3] ^ AMBE_DecryptionKey[3]);
									
									payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
80002e82:	4a e8       	lddpc	r8,80002f38 <phy_tx_func+0x4b4>
80002e84:	90 19       	ld.sh	r9,r8[0x2]
80002e86:	ae 49       	st.h	r7[0x8],r9
									payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
80002e88:	90 29       	ld.sh	r9,r8[0x4]
80002e8a:	ae 59       	st.h	r7[0xa],r9
									payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]) ;
80002e8c:	90 38       	ld.sh	r8,r8[0x6]
80002e8e:	ae 68       	st.h	r7[0xc],r8
									
									payload_tx_channel->word[3] = 0x00BA ;
80002e90:	e0 68 00 ba 	mov	r8,186
80002e94:	ae 78       	st.h	r7[0xe],r8
							
							
							}
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002e96:	30 09       	mov	r9,0
80002e98:	4a 08       	lddpc	r8,80002f18 <phy_tx_func+0x494>
80002e9a:	91 09       	st.w	r8[0x0],r9
80002e9c:	c2 a8       	rjmp	80002ef0 <phy_tx_func+0x46c>
							//Recover data
							//payload_tx_channel->word[0] = (AMBEBurst_rawdata[1] ^ AMBE_DecryptionKey[1]);
							//payload_tx_channel->word[1] = (AMBEBurst_rawdata[2] ^ AMBE_DecryptionKey[2]);
							//payload_tx_channel->word[2] = (AMBEBurst_rawdata[3] ^ AMBE_DecryptionKey[3]);
							
							payload_tx_channel->word[0] = (AMBEBurst_rawdata[1]);
80002e9e:	4a 78       	lddpc	r8,80002f38 <phy_tx_func+0x4b4>
80002ea0:	90 19       	ld.sh	r9,r8[0x2]
80002ea2:	ae 49       	st.h	r7[0x8],r9
							payload_tx_channel->word[1] = (AMBEBurst_rawdata[2]);
80002ea4:	90 29       	ld.sh	r9,r8[0x4]
80002ea6:	ae 59       	st.h	r7[0xa],r9
							payload_tx_channel->word[2] = (AMBEBurst_rawdata[3]) ;
80002ea8:	90 38       	ld.sh	r8,r8[0x6]
80002eaa:	ae 68       	st.h	r7[0xc],r8
							
							payload_tx_channel->word[3] = 0x00BA ;
80002eac:	e0 68 00 ba 	mov	r8,186
80002eb0:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_IDLE;
80002eb2:	30 09       	mov	r9,0
80002eb4:	49 98       	lddpc	r8,80002f18 <phy_tx_func+0x494>
80002eb6:	91 09       	st.w	r8[0x0],r9
80002eb8:	c1 c8       	rjmp	80002ef0 <phy_tx_func+0x46c>
						
							break;
						default://This shouldn't happen, but must check;
						
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002eba:	e0 68 5a 5a 	mov	r8,23130
80002ebe:	ea 18 ab cd 	orh	r8,0xabcd
80002ec2:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ec4:	30 08       	mov	r8,0
80002ec6:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002ec8:	49 49       	lddpc	r9,80002f18 <phy_tx_func+0x494>
80002eca:	93 08       	st.w	r9[0x0],r8
80002ecc:	c1 28       	rjmp	80002ef0 <phy_tx_func+0x46c>

				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ece:	e0 68 5a 5a 	mov	r8,23130
80002ed2:	ea 18 ab cd 	orh	r8,0xabcd
80002ed6:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002ed8:	30 08       	mov	r8,0
80002eda:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002edc:	48 f9       	lddpc	r9,80002f18 <phy_tx_func+0x494>
80002ede:	93 08       	st.w	r9[0x0],r8
80002ee0:	c0 88       	rjmp	80002ef0 <phy_tx_func+0x46c>

	}//end of Send-AMBE-data

	else
	{
		payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ee2:	e0 68 5a 5a 	mov	r8,23130
80002ee6:	ea 18 ab cd 	orh	r8,0xabcd
80002eea:	8f 28       	st.w	r7[0x8],r8
		payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002eec:	30 08       	mov	r8,0
80002eee:	8f 38       	st.w	r7[0xc],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002ef0:	2f fd       	sub	sp,-4
80002ef2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ef6:	00 00       	add	r0,r0
80002ef8:	00 00       	add	r0,r0
80002efa:	0a c4       	st.b	r5++,r4
80002efc:	00 00       	add	r0,r0
80002efe:	0a 70       	tst	r0,r5
80002f00:	00 00       	add	r0,r0
80002f02:	0a 78       	tst	r8,r5
80002f04:	80 00       	ld.sh	r0,r0[0x0]
80002f06:	53 a4       	stdsp	sp[0xe8],r4
80002f08:	00 00       	add	r0,r0
80002f0a:	0a c0       	st.b	r5++,r0
80002f0c:	00 00       	add	r0,r0
80002f0e:	0a 84       	andn	r4,r5
80002f10:	00 00       	add	r0,r0
80002f12:	0a 43       	or	r3,r5
80002f14:	00 00       	add	r0,r0
80002f16:	0a 74       	tst	r4,r5
80002f18:	00 00       	add	r0,r0
80002f1a:	0a a4       	st.w	r5++,r4
80002f1c:	80 00       	ld.sh	r0,r0[0x0]
80002f1e:	cb 7c       	rcall	8000308c <phy_rx_func>
80002f20:	00 00       	add	r0,r0
80002f22:	0a 60       	and	r0,r5
80002f24:	00 00       	add	r0,r0
80002f26:	0a cc       	st.b	r5++,r12
80002f28:	00 00       	add	r0,r0
80002f2a:	0d a0       	ld.ub	r0,r6[0x2]
80002f2c:	00 00       	add	r0,r0
80002f2e:	0e 9c       	mov	r12,r7
80002f30:	00 00       	add	r0,r0
80002f32:	0a 3a       	cp.w	r10,r5
80002f34:	80 00       	ld.sh	r0,r0[0x0]
80002f36:	cb 20       	breq	80002e9a <phy_tx_func+0x416>
80002f38:	00 00       	add	r0,r0
80002f3a:	0d 98       	ld.ub	r8,r6[0x1]
80002f3c:	00 00       	add	r0,r0
80002f3e:	0a 9c       	mov	r12,r5
80002f40:	00 00       	add	r0,r0
80002f42:	0e a0       	st.w	r7++,r0
80002f44:	00 00       	add	r0,r0
80002f46:	0d a4       	ld.ub	r4,r6[0x2]

80002f48 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f48:	d4 01       	pushm	lr
80002f4a:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f4c:	30 0a       	mov	r10,0
80002f4e:	fa cb ff fc 	sub	r11,sp,-4
80002f52:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f54:	14 99       	mov	r9,r10
80002f56:	1a 9b       	mov	r11,sp
80002f58:	f0 1f 00 05 	mcall	80002f6c <get_idle_store+0x24>
80002f5c:	58 1c       	cp.w	r12,1
80002f5e:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f62:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f66:	2f fd       	sub	sp,-4
80002f68:	d8 02       	popm	pc
80002f6a:	00 00       	add	r0,r0
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	54 94       	stdsp	sp[0x124],r4

80002f70 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f70:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002f74:	f0 1f 00 21 	mcall	80002ff8 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002f78:	4a 1b       	lddpc	r11,80002ffc <phy_init+0x8c>
80002f7a:	4a 2c       	lddpc	r12,80003000 <phy_init+0x90>
80002f7c:	f0 1f 00 22 	mcall	80003004 <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002f80:	30 4b       	mov	r11,4
80002f82:	31 ec       	mov	r12,30
80002f84:	f0 1f 00 21 	mcall	80003008 <phy_init+0x98>
80002f88:	4a 18       	lddpc	r8,8000300c <phy_init+0x9c>
80002f8a:	91 0c       	st.w	r8[0x0],r12
80002f8c:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002f8e:	10 96       	mov	r6,r8
80002f90:	4a 05       	lddpc	r5,80003010 <phy_init+0xa0>
80002f92:	6c 0c       	ld.w	r12,r6[0x0]
80002f94:	ea 07 00 0b 	add	r11,r5,r7
80002f98:	f0 1f 00 1f 	mcall	80003014 <phy_init+0xa4>
80002f9c:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002fa0:	e0 47 1e 00 	cp.w	r7,7680
80002fa4:	cf 71       	brne	80002f92 <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002fa6:	30 4b       	mov	r11,4
80002fa8:	31 4c       	mov	r12,20
80002faa:	f0 1f 00 18 	mcall	80003008 <phy_init+0x98>
80002fae:	49 b8       	lddpc	r8,80003018 <phy_init+0xa8>
80002fb0:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002fb2:	30 4b       	mov	r11,4
80002fb4:	30 ac       	mov	r12,10
80002fb6:	f0 1f 00 15 	mcall	80003008 <phy_init+0x98>
80002fba:	49 98       	lddpc	r8,8000301c <phy_init+0xac>
80002fbc:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002fbe:	30 4b       	mov	r11,4
80002fc0:	30 ac       	mov	r12,10
80002fc2:	f0 1f 00 12 	mcall	80003008 <phy_init+0x98>
80002fc6:	49 78       	lddpc	r8,80003020 <phy_init+0xb0>
80002fc8:	91 0c       	st.w	r8[0x0],r12
80002fca:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002fcc:	10 96       	mov	r6,r8
80002fce:	49 65       	lddpc	r5,80003024 <phy_init+0xb4>
80002fd0:	6c 0c       	ld.w	r12,r6[0x0]
80002fd2:	ea 07 00 0b 	add	r11,r5,r7
80002fd6:	f0 1f 00 10 	mcall	80003014 <phy_init+0xa4>
80002fda:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002fde:	e0 47 14 00 	cp.w	r7,5120
80002fe2:	cf 71       	brne	80002fd0 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80002fe4:	e0 6b 01 00 	mov	r11,256
80002fe8:	30 5c       	mov	r12,5
80002fea:	f0 1f 00 08 	mcall	80003008 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80002fee:	48 f8       	lddpc	r8,80003028 <phy_init+0xb8>
80002ff0:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80002ff2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002ff6:	00 00       	add	r0,r0
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	3e 1c       	mov	r12,-31
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	2a 84       	sub	r4,-88
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	30 8c       	mov	r12,8
80003004:	80 00       	ld.sh	r0,r0[0x0]
80003006:	3e 08       	mov	r8,-32
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	57 f8       	stdsp	sp[0x1fc],r8
8000300c:	00 00       	add	r0,r0
8000300e:	0a 94       	mov	r4,r5
80003010:	00 00       	add	r0,r0
80003012:	22 ba       	sub	r10,43
80003014:	80 00       	ld.sh	r0,r0[0x0]
80003016:	29 e0       	sub	r0,-98
80003018:	00 00       	add	r0,r0
8000301a:	0a c4       	st.b	r5++,r4
8000301c:	00 00       	add	r0,r0
8000301e:	0a b0       	st.h	r5++,r0
80003020:	00 00       	add	r0,r0
80003022:	0a 68       	and	r8,r5
80003024:	00 00       	add	r0,r0
80003026:	0e ba       	st.h	r7++,r10
80003028:	00 00       	add	r0,r0
8000302a:	0a ac       	st.w	r5++,r12

8000302c <payload_rx>:




static void payload_rx(void * payload)
{
8000302c:	d4 01       	pushm	lr
8000302e:	20 2d       	sub	sp,8
80003030:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80003032:	30 08       	mov	r8,0
80003034:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80003036:	48 f8       	lddpc	r8,80003070 <payload_rx+0x44>
80003038:	70 08       	ld.w	r8,r8[0x0]
8000303a:	58 08       	cp.w	r8,0
8000303c:	c0 71       	brne	8000304a <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
8000303e:	30 4b       	mov	r11,4
80003040:	30 5c       	mov	r12,5
80003042:	f0 1f 00 0d 	mcall	80003074 <payload_rx+0x48>
80003046:	48 b8       	lddpc	r8,80003070 <payload_rx+0x44>
80003048:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
8000304a:	48 a8       	lddpc	r8,80003070 <payload_rx+0x44>
8000304c:	70 0c       	ld.w	r12,r8[0x0]
8000304e:	30 09       	mov	r9,0
80003050:	fa ca ff fc 	sub	r10,sp,-4
80003054:	1a 9b       	mov	r11,sp
80003056:	f0 1f 00 09 	mcall	80003078 <payload_rx+0x4c>
8000305a:	c0 91       	brne	8000306c <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
8000305c:	48 88       	lddpc	r8,8000307c <payload_rx+0x50>
8000305e:	70 0c       	ld.w	r12,r8[0x0]
80003060:	40 0b       	lddsp	r11,sp[0x0]
80003062:	f0 1f 00 08 	mcall	80003080 <payload_rx+0x54>
		logFromISR("mm");
80003066:	48 8c       	lddpc	r12,80003084 <payload_rx+0x58>
80003068:	f0 1f 00 08 	mcall	80003088 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
8000306c:	2f ed       	sub	sp,-8
8000306e:	d8 02       	popm	pc
80003070:	00 00       	add	r0,r0
80003072:	0a 8c       	andn	r12,r5
80003074:	80 00       	ld.sh	r0,r0[0x0]
80003076:	57 f8       	stdsp	sp[0x1fc],r8
80003078:	80 00       	ld.sh	r0,r0[0x0]
8000307a:	56 50       	stdsp	sp[0x194],r0
8000307c:	00 00       	add	r0,r0
8000307e:	0a 68       	and	r8,r5
80003080:	80 00       	ld.sh	r0,r0[0x0]
80003082:	29 8c       	sub	r12,-104
80003084:	80 00       	ld.sh	r0,r0[0x0]
80003086:	cb 98       	rjmp	800031f8 <phy_rx_func+0x16c>
80003088:	80 00       	ld.sh	r0,r0[0x0]
8000308a:	64 1c       	ld.w	r12,r2[0x4]

8000308c <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
8000308c:	eb cd 40 e0 	pushm	r5-r7,lr
80003090:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80003092:	fe f8 0b be 	ld.w	r8,pc[3006]
80003096:	70 08       	ld.w	r8,r8[0x0]
80003098:	58 08       	cp.w	r8,0
8000309a:	e0 80 01 05 	breq	800032a4 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
8000309e:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800030a0:	fe f8 0b b4 	ld.w	r8,pc[2996]
800030a4:	70 09       	ld.w	r9,r8[0x0]
800030a6:	2f f9       	sub	r9,-1
800030a8:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800030aa:	fe f8 0b ae 	ld.w	r8,pc[2990]
800030ae:	70 08       	ld.w	r8,r8[0x0]
800030b0:	58 18       	cp.w	r8,1
800030b2:	e0 80 00 84 	breq	800031ba <phy_rx_func+0x12e>
800030b6:	c0 73       	brcs	800030c4 <phy_rx_func+0x38>
800030b8:	58 28       	cp.w	r8,2
800030ba:	c5 b0       	breq	80003170 <phy_rx_func+0xe4>
800030bc:	58 38       	cp.w	r8,3
800030be:	e0 81 00 f3 	brne	800032a4 <phy_rx_func+0x218>
800030c2:	cd 38       	rjmp	80003268 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
800030c4:	e0 6a 5a 5a 	mov	r10,23130
800030c8:	ea 1a ab cd 	orh	r10,0xabcd
800030cc:	14 36       	cp.w	r6,r10
800030ce:	e0 80 00 eb 	breq	800032a4 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
800030d2:	ec 08 16 10 	lsr	r8,r6,0x10
800030d6:	e0 48 ab cd 	cp.w	r8,43981
800030da:	e0 81 00 e5 	brne	800032a4 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
800030de:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
800030e2:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
800030e6:	20 28       	sub	r8,2
800030e8:	fe f9 0b 74 	ld.w	r9,pc[2932]
800030ec:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
800030ee:	30 09       	mov	r9,0
800030f0:	f2 08 19 00 	cp.h	r8,r9
800030f4:	e0 8a 00 d8 	brle	800032a4 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
800030f8:	fe f8 0b 68 	ld.w	r8,pc[2920]
800030fc:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
800030fe:	fe f8 0b 66 	ld.w	r8,pc[2918]
80003102:	70 0c       	ld.w	r12,r8[0x0]
80003104:	f0 1f 02 d9 	mcall	80003c68 <phy_rx_func+0xbdc>
80003108:	fe f8 0b 64 	ld.w	r8,pc[2916]
8000310c:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000310e:	58 0c       	cp.w	r12,0
80003110:	e0 80 00 ca 	breq	800032a4 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003114:	fe f8 0b 4c 	ld.w	r8,pc[2892]
80003118:	90 09       	ld.sh	r9,r8[0x0]
8000311a:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
8000311e:	2f f9       	sub	r9,-1
80003120:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003122:	fe fa 0b 4a 	ld.w	r10,pc[2890]
80003126:	74 0a       	ld.w	r10,r10[0x0]
80003128:	fe fb 0b 2c 	ld.w	r11,pc[2860]
8000312c:	76 0b       	ld.w	r11,r11[0x0]
8000312e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80003132:	2f f9       	sub	r9,-1
80003134:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003136:	e2 16 0f 00 	andl	r6,0xf00,COH
8000313a:	e0 46 01 00 	cp.w	r6,256
8000313e:	c0 c0       	breq	80003156 <phy_rx_func+0xca>
80003140:	e0 8b 00 05 	brhi	8000314a <phy_rx_func+0xbe>
80003144:	58 06       	cp.w	r6,0
80003146:	c0 80       	breq	80003156 <phy_rx_func+0xca>
80003148:	c0 c8       	rjmp	80003160 <phy_rx_func+0xd4>
8000314a:	e0 46 02 00 	cp.w	r6,512
8000314e:	c0 40       	breq	80003156 <phy_rx_func+0xca>
80003150:	e0 46 03 00 	cp.w	r6,768
80003154:	c0 61       	brne	80003160 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003156:	30 29       	mov	r9,2
80003158:	fe f8 0b 00 	ld.w	r8,pc[2816]
8000315c:	91 09       	st.w	r8[0x0],r9
8000315e:	ca 38       	rjmp	800032a4 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
80003160:	fe f6 0b 0c 	ld.w	r6,pc[2828]
80003164:	6c 0c       	ld.w	r12,r6[0x0]
80003166:	f0 1f 02 c3 	mcall	80003c70 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;					
8000316a:	30 08       	mov	r8,0
8000316c:	8d 08       	st.w	r6[0x0],r8
8000316e:	c9 b8       	rjmp	800032a4 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80003170:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80003174:	b1 86       	lsr	r6,0x10
80003176:	14 06       	add	r6,r10
80003178:	fe f8 0a fc 	ld.w	r8,pc[2812]
8000317c:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
8000317e:	fe f8 0a e2 	ld.w	r8,pc[2786]
80003182:	90 09       	ld.sh	r9,r8[0x0]
80003184:	fe fb 0a e8 	ld.w	r11,pc[2792]
80003188:	76 0b       	ld.w	r11,r11[0x0]
8000318a:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
8000318e:	2f f9       	sub	r9,-1
80003190:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80003192:	fe f9 0a ca 	ld.w	r9,pc[2762]
80003196:	92 08       	ld.sh	r8,r9[0x0]
80003198:	20 28       	sub	r8,2
8000319a:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
8000319c:	30 09       	mov	r9,0
8000319e:	f2 08 19 00 	cp.h	r8,r9
800031a2:	e0 8a 00 07 	brle	800031b0 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
800031a6:	30 19       	mov	r9,1
800031a8:	fe f8 0a b0 	ld.w	r8,pc[2736]
800031ac:	91 09       	st.w	r8[0x0],r9
800031ae:	c7 b8       	rjmp	800032a4 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800031b0:	30 39       	mov	r9,3
800031b2:	fe f8 0a a6 	ld.w	r8,pc[2726]
800031b6:	91 09       	st.w	r8[0x0],r9
800031b8:	c7 68       	rjmp	800032a4 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800031ba:	ec 0a 14 10 	asr	r10,r6,0x10
800031be:	fe f8 0a b6 	ld.w	r8,pc[2742]
800031c2:	90 09       	ld.sh	r9,r8[0x0]
800031c4:	14 09       	add	r9,r10
800031c6:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800031c8:	fe f9 0a 98 	ld.w	r9,pc[2712]
800031cc:	92 08       	ld.sh	r8,r9[0x0]
800031ce:	fe fb 0a 9e 	ld.w	r11,pc[2718]
800031d2:	76 0b       	ld.w	r11,r11[0x0]
800031d4:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
800031d8:	2f f8       	sub	r8,-1
800031da:	5c 88       	casts.h	r8
800031dc:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
800031de:	fe fa 0a 7e 	ld.w	r10,pc[2686]
800031e2:	94 09       	ld.sh	r9,r10[0x0]
800031e4:	20 29       	sub	r9,2
800031e6:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
800031e8:	30 0a       	mov	r10,0
800031ea:	f4 09 19 00 	cp.h	r9,r10
800031ee:	e0 89 00 1f 	brgt	8000322c <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
800031f2:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800031f6:	e0 46 00 ba 	cp.w	r6,186
800031fa:	c0 d1       	brne	80003214 <phy_rx_func+0x188>
800031fc:	fe f8 0a 78 	ld.w	r8,pc[2680]
80003200:	90 09       	ld.sh	r9,r8[0x0]
80003202:	f4 09 19 00 	cp.h	r9,r10
80003206:	c0 71       	brne	80003214 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003208:	fe f8 0a 64 	ld.w	r8,pc[2660]
8000320c:	70 0c       	ld.w	r12,r8[0x0]
8000320e:	f0 1f 02 9b 	mcall	80003c78 <phy_rx_func+0xbec>
80003212:	c0 88       	rjmp	80003222 <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003214:	fe f6 0a 58 	ld.w	r6,pc[2648]
80003218:	6c 0c       	ld.w	r12,r6[0x0]
8000321a:	f0 1f 02 96 	mcall	80003c70 <phy_rx_func+0xbe4>
					phy_frame_ptr = NULL;
8000321e:	30 08       	mov	r8,0
80003220:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
80003222:	30 09       	mov	r9,0
80003224:	fe f8 0a 34 	ld.w	r8,pc[2612]
80003228:	91 09       	st.w	r8[0x0],r9
8000322a:	c3 d8       	rjmp	800032a4 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
8000322c:	5c 86       	casts.h	r6
8000322e:	fe f9 0a 46 	ld.w	r9,pc[2630]
80003232:	92 0a       	ld.sh	r10,r9[0x0]
80003234:	0c 0a       	add	r10,r6
80003236:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003238:	fe f9 0a 34 	ld.w	r9,pc[2612]
8000323c:	72 09       	ld.w	r9,r9[0x0]
8000323e:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80003242:	2f f8       	sub	r8,-1
80003244:	fe f9 0a 1c 	ld.w	r9,pc[2588]
80003248:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
8000324a:	fe f9 0a 12 	ld.w	r9,pc[2578]
8000324e:	92 08       	ld.sh	r8,r9[0x0]
80003250:	20 28       	sub	r8,2
80003252:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003254:	30 09       	mov	r9,0
80003256:	f2 08 19 00 	cp.h	r8,r9
8000325a:	e0 89 00 25 	brgt	800032a4 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000325e:	30 39       	mov	r9,3
80003260:	fe f8 09 f8 	ld.w	r8,pc[2552]
80003264:	91 09       	st.w	r8[0x0],r9
80003266:	c1 f8       	rjmp	800032a4 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80003268:	e6 16 00 ff 	andh	r6,0xff,COH
8000326c:	fc 19 00 ba 	movh	r9,0xba
80003270:	12 36       	cp.w	r6,r9
80003272:	c0 e1       	brne	8000328e <phy_rx_func+0x202>
80003274:	fe f8 0a 00 	ld.w	r8,pc[2560]
80003278:	90 09       	ld.sh	r9,r8[0x0]
8000327a:	30 08       	mov	r8,0
8000327c:	f0 09 19 00 	cp.h	r9,r8
80003280:	c0 71       	brne	8000328e <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80003282:	fe f8 09 ea 	ld.w	r8,pc[2538]
80003286:	70 0c       	ld.w	r12,r8[0x0]
80003288:	f0 1f 02 7c 	mcall	80003c78 <phy_rx_func+0xbec>
8000328c:	c0 88       	rjmp	8000329c <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
8000328e:	fe f6 09 de 	ld.w	r6,pc[2526]
80003292:	6c 0c       	ld.w	r12,r6[0x0]
80003294:	f0 1f 02 77 	mcall	80003c70 <phy_rx_func+0xbe4>
				phy_frame_ptr = NULL;
80003298:	30 08       	mov	r8,0
8000329a:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000329c:	30 09       	mov	r9,0
8000329e:	fe f8 09 ba 	ld.w	r8,pc[2490]
800032a2:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800032a4:	fe f8 09 d8 	ld.w	r8,pc[2520]
800032a8:	11 89       	ld.ub	r9,r8[0x0]
800032aa:	30 08       	mov	r8,0
800032ac:	f0 09 18 00 	cp.b	r9,r8
800032b0:	c0 d1       	brne	800032ca <phy_rx_func+0x23e>
	{
		//payload_ptr = get_payload_idle_isr();
		AMBE_payload_ptr = get_payload_idle_isr();
800032b2:	fe f8 09 ce 	ld.w	r8,pc[2510]
800032b6:	70 0c       	ld.w	r12,r8[0x0]
800032b8:	f0 1f 02 6c 	mcall	80003c68 <phy_rx_func+0xbdc>
800032bc:	fe f8 09 c8 	ld.w	r8,pc[2504]
800032c0:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
800032c2:	30 19       	mov	r9,1
800032c4:	fe f8 09 b8 	ld.w	r8,pc[2488]
800032c8:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
800032ca:	fe f8 09 be 	ld.w	r8,pc[2494]
800032ce:	70 08       	ld.w	r8,r8[0x0]
800032d0:	58 38       	cp.w	r8,3
800032d2:	e0 80 04 7a 	breq	80003bc6 <phy_rx_func+0xb3a>
800032d6:	58 48       	cp.w	r8,4
800032d8:	e0 80 01 02 	breq	800034dc <phy_rx_func+0x450>
800032dc:	58 08       	cp.w	r8,0
800032de:	e0 81 04 b7 	brne	80003c4c <phy_rx_func+0xbc0>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
800032e2:	6e 28       	ld.w	r8,r7[0x8]
800032e4:	e0 6a 5a 5a 	mov	r10,23130
800032e8:	ea 1a ab cd 	orh	r10,0xabcd
800032ec:	14 38       	cp.w	r8,r10
800032ee:	c0 71       	brne	800032fc <phy_rx_func+0x270>
			{
				m_RxBurstType = VOICE_WATING;
800032f0:	30 09       	mov	r9,0
800032f2:	fe f8 09 9a 	ld.w	r8,pc[2458]
800032f6:	91 09       	st.w	r8[0x0],r9
800032f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800032fc:	10 99       	mov	r9,r8
800032fe:	e0 19 00 00 	andl	r9,0x0
80003302:	fc 1a ab cd 	movh	r10,0xabcd
80003306:	14 39       	cp.w	r9,r10
80003308:	e0 81 04 a2 	brne	80003c4c <phy_rx_func+0xbc0>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
8000330c:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003310:	fe f9 09 80 	ld.w	r9,pc[2432]
80003314:	93 08       	st.w	r9[0x0],r8
		
			if( (NULL== AMBE_payload_ptr))
80003316:	fe f8 09 6e 	ld.w	r8,pc[2414]
8000331a:	70 08       	ld.w	r8,r8[0x0]
8000331c:	58 08       	cp.w	r8,0
8000331e:	c1 11       	brne	80003340 <phy_rx_func+0x2b4>
			{
				//payload_ptr = get_payload_idle_isr();
				AMBE_payload_ptr = get_payload_idle_isr();
80003320:	fe f8 09 60 	ld.w	r8,pc[2400]
80003324:	70 0c       	ld.w	r12,r8[0x0]
80003326:	f0 1f 02 51 	mcall	80003c68 <phy_rx_func+0xbdc>
8000332a:	fe f8 09 5a 	ld.w	r8,pc[2394]
8000332e:	91 0c       	st.w	r8[0x0],r12
				
				if (NULL== AMBE_payload_ptr)
80003330:	58 0c       	cp.w	r12,0
80003332:	c0 71       	brne	80003340 <phy_rx_func+0x2b4>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003334:	fe fc 09 60 	ld.w	r12,pc[2400]
80003338:	f0 1f 02 58 	mcall	80003c98 <phy_rx_func+0xc0c>
8000333c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003340:	6e 28       	ld.w	r8,r7[0x8]
80003342:	e2 18 f0 00 	andl	r8,0xf000,COH
80003346:	e0 48 c0 00 	cp.w	r8,49152
8000334a:	e0 81 00 c3 	brne	800034d0 <phy_rx_func+0x444>
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
			{
				AMBE_Media = 1;	
8000334e:	30 19       	mov	r9,1
80003350:	fe f8 09 4c 	ld.w	r8,pc[2380]
80003354:	b0 89       	st.b	r8[0x0],r9
											
				Item_ID = payload_rx_channel->byte[5];
80003356:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000335a:	fe f8 09 46 	ld.w	r8,pc[2374]
8000335e:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003360:	ef 3a 00 0c 	ld.ub	r10,r7[12]
80003364:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
80003368:	fe f9 09 3c 	ld.w	r9,pc[2364]
8000336c:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
8000336e:	11 88       	ld.ub	r8,r8[0x0]
80003370:	37 f9       	mov	r9,127
80003372:	f2 08 18 00 	cp.b	r8,r9
80003376:	c6 d0       	breq	80003450 <phy_rx_func+0x3c4>
80003378:	e0 8b 00 0c 	brhi	80003390 <phy_rx_func+0x304>
8000337c:	31 29       	mov	r9,18
8000337e:	f2 08 18 00 	cp.b	r8,r9
80003382:	c4 20       	breq	80003406 <phy_rx_func+0x37a>
80003384:	31 39       	mov	r9,19
80003386:	f2 08 18 00 	cp.b	r8,r9
8000338a:	e0 81 00 83 	brne	80003490 <phy_rx_func+0x404>
8000338e:	c5 b8       	rjmp	80003444 <phy_rx_func+0x3b8>
80003390:	2f 08       	sub	r8,-16
80003392:	30 19       	mov	r9,1
80003394:	f2 08 18 00 	cp.b	r8,r9
80003398:	e0 8b 00 7c 	brhi	80003490 <phy_rx_func+0x404>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000339c:	ef 38 00 0e 	ld.ub	r8,r7[14]
800033a0:	e2 18 00 f0 	andl	r8,0xf0,COH
800033a4:	59 08       	cp.w	r8,16
800033a6:	c0 71       	brne	800033b4 <phy_rx_func+0x328>
							{
								m_RxBurstType = VOICEHEADER;
800033a8:	30 19       	mov	r9,1
800033aa:	fe f8 08 e2 	ld.w	r8,pc[2274]
800033ae:	91 09       	st.w	r8[0x0],r9
800033b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
800033b4:	e0 48 00 20 	cp.w	r8,32
800033b8:	c2 11       	brne	800033fa <phy_rx_func+0x36e>
							{
								m_RxBurstType = VOICETERMINATOR;
800033ba:	30 a9       	mov	r9,10
800033bc:	fe f8 08 d0 	ld.w	r8,pc[2256]
800033c0:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
800033c2:	fe f6 08 e6 	ld.w	r6,pc[2278]
800033c6:	6c 08       	ld.w	r8,r6[0x0]
800033c8:	f0 0a 11 ff 	rsub	r10,r8,-1
800033cc:	fe f7 08 b8 	ld.w	r7,pc[2232]
800033d0:	2f f8       	sub	r8,-1
800033d2:	6e 0c       	ld.w	r12,r7[0x0]
800033d4:	f4 ca fe 00 	sub	r10,r10,-512
800033d8:	30 0b       	mov	r11,0
800033da:	10 0c       	add	r12,r8
800033dc:	f0 1f 02 34 	mcall	80003cac <phy_rx_func+0xc20>
								
								RxAMBE_IsFillingNext8 = 0;
800033e0:	30 08       	mov	r8,0
800033e2:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
800033e4:	6e 0c       	ld.w	r12,r7[0x0]
800033e6:	f0 1f 02 33 	mcall	80003cb0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800033ea:	fe f8 08 96 	ld.w	r8,pc[2198]
800033ee:	70 0c       	ld.w	r12,r8[0x0]
800033f0:	f0 1f 02 1e 	mcall	80003c68 <phy_rx_func+0xbdc>
800033f4:	8f 0c       	st.w	r7[0x0],r12
800033f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
800033fa:	30 09       	mov	r9,0
800033fc:	fe f8 08 90 	ld.w	r8,pc[2192]
80003400:	91 09       	st.w	r8[0x0],r9
80003402:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003406:	fe f9 08 8a 	ld.w	r9,pc[2186]
8000340a:	72 08       	ld.w	r8,r9[0x0]
8000340c:	20 48       	sub	r8,4
8000340e:	93 08       	st.w	r9[0x0],r8
80003410:	e0 80 04 1e 	breq	80003c4c <phy_rx_func+0xbc0>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003414:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003418:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
8000341c:	fe f8 08 98 	ld.w	r8,pc[2200]
80003420:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003422:	8e 69       	ld.sh	r9,r7[0xc]
80003424:	fe f8 08 94 	ld.w	r8,pc[2196]
80003428:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000342a:	8e 79       	ld.sh	r9,r7[0xe]
8000342c:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
8000342e:	f0 1f 02 24 	mcall	80003cbc <phy_rx_func+0xc30>
80003432:	fe f8 08 5a 	ld.w	r8,pc[2138]
80003436:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003438:	30 49       	mov	r9,4
8000343a:	fe f8 08 4e 	ld.w	r8,pc[2126]
8000343e:	91 09       	st.w	r8[0x0],r9
80003440:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003444:	30 09       	mov	r9,0
80003446:	fe f8 08 46 	ld.w	r8,pc[2118]
8000344a:	91 09       	st.w	r8[0x0],r9
8000344c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003450:	fe f9 08 40 	ld.w	r9,pc[2112]
80003454:	72 08       	ld.w	r8,r9[0x0]
80003456:	20 48       	sub	r8,4
80003458:	93 08       	st.w	r9[0x0],r8
8000345a:	e0 80 03 f9 	breq	80003c4c <phy_rx_func+0xbc0>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
8000345e:	fe f8 08 62 	ld.w	r8,pc[2146]
80003462:	70 09       	ld.w	r9,r8[0x0]
80003464:	8e 7b       	ld.sh	r11,r7[0xe]
80003466:	fe fa 08 5e 	ld.w	r10,pc[2142]
8000346a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
8000346e:	2f f9       	sub	r9,-1
80003470:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003472:	fe f8 08 32 	ld.w	r8,pc[2098]
80003476:	70 09       	ld.w	r9,r8[0x0]
80003478:	20 29       	sub	r9,2
8000347a:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000347c:	30 29       	mov	r9,2
8000347e:	fe f8 08 0e 	ld.w	r8,pc[2062]
80003482:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003484:	30 39       	mov	r9,3
80003486:	fe f8 08 02 	ld.w	r8,pc[2050]
8000348a:	91 09       	st.w	r8[0x0],r9
8000348c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003490:	30 39       	mov	r9,3
80003492:	fe f8 07 fa 	ld.w	r8,pc[2042]
80003496:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003498:	6e 29       	ld.w	r9,r7[0x8]
8000349a:	fe f8 08 2e 	ld.w	r8,pc[2094]
8000349e:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
800034a0:	6e 39       	ld.w	r9,r7[0xc]
800034a2:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
800034a4:	fe f8 07 ec 	ld.w	r8,pc[2028]
800034a8:	70 08       	ld.w	r8,r8[0x0]
800034aa:	59 48       	cp.w	r8,20
800034ac:	c0 61       	brne	800034b8 <phy_rx_func+0x42c>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
800034ae:	31 89       	mov	r9,24
800034b0:	fe f8 07 e0 	ld.w	r8,pc[2016]
800034b4:	91 09       	st.w	r8[0x0],r9
800034b6:	c0 78       	rjmp	800034c4 <phy_rx_func+0x438>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
800034b8:	59 08       	cp.w	r8,16
800034ba:	c0 51       	brne	800034c4 <phy_rx_func+0x438>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
800034bc:	31 09       	mov	r9,16
800034be:	fe f8 07 d2 	ld.w	r8,pc[2002]
800034c2:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034c4:	30 49       	mov	r9,4
800034c6:	fe f8 07 c2 	ld.w	r8,pc[1986]
800034ca:	91 09       	st.w	r8[0x0],r9
800034cc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				break;
			}
			
			else
			{
				AMBE_Media = 0;	
800034d0:	30 09       	mov	r9,0
800034d2:	fe f8 07 ca 	ld.w	r8,pc[1994]
800034d6:	b0 89       	st.b	r8[0x0],r9
800034d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
800034dc:	fe f8 07 c4 	ld.w	r8,pc[1988]
800034e0:	11 89       	ld.ub	r9,r8[0x0]
800034e2:	31 28       	mov	r8,18
800034e4:	f0 09 18 00 	cp.b	r9,r8
800034e8:	e0 81 01 4c 	brne	80003780 <phy_rx_func+0x6f4>
					{
						Item_ID = payload_rx_channel->byte[1];
800034ec:	ef 39 00 09 	ld.ub	r9,r7[9]
800034f0:	fe f8 07 b0 	ld.w	r8,pc[1968]
800034f4:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
800034f6:	11 89       	ld.ub	r9,r8[0x0]
800034f8:	3f 28       	mov	r8,-14
800034fa:	f0 09 18 00 	cp.b	r9,r8
800034fe:	e0 81 01 3b 	brne	80003774 <phy_rx_func+0x6e8>
						{
							AMBE_tx_flag = 1;
80003502:	30 19       	mov	r9,1
80003504:	fe f8 07 c8 	ld.w	r8,pc[1992]
80003508:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000350a:	6e 29       	ld.w	r9,r7[0x8]
8000350c:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003510:	fe f8 07 80 	ld.w	r8,pc[1920]
80003514:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003516:	8e 59       	ld.sh	r9,r7[0xa]
80003518:	fe f8 07 b8 	ld.w	r8,pc[1976]
8000351c:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
8000351e:	8e 69       	ld.sh	r9,r7[0xc]
80003520:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003522:	8e 79       	ld.sh	r9,r7[0xe]
80003524:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003526:	fe f8 07 82 	ld.w	r8,pc[1922]
8000352a:	fe f9 07 5a 	ld.w	r9,pc[1882]
8000352e:	72 0a       	ld.w	r10,r9[0x0]
80003530:	70 09       	ld.w	r9,r8[0x0]
80003532:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003536:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000353a:	70 09       	ld.w	r9,r8[0x0]
8000353c:	2f f9       	sub	r9,-1
8000353e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003540:	e0 49 01 ff 	cp.w	r9,511
80003544:	e0 88 00 16 	brls	80003570 <phy_rx_func+0x4e4>
							{
								RxAMBE_IsFillingNext8 = 0;
80003548:	30 09       	mov	r9,0
8000354a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000354c:	fe f6 07 38 	ld.w	r6,pc[1848]
80003550:	6c 0c       	ld.w	r12,r6[0x0]
80003552:	f0 1f 01 d8 	mcall	80003cb0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003556:	fe f8 07 2a 	ld.w	r8,pc[1834]
8000355a:	70 0c       	ld.w	r12,r8[0x0]
8000355c:	f0 1f 01 c3 	mcall	80003c68 <phy_rx_func+0xbdc>
80003560:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003562:	c0 71       	brne	80003570 <phy_rx_func+0x4e4>
								{
									RxMediaState = WAITINGABAB;
80003564:	30 09       	mov	r9,0
80003566:	fe f8 07 22 	ld.w	r8,pc[1826]
8000356a:	91 09       	st.w	r8[0x0],r9
8000356c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003570:	fe f9 07 20 	ld.w	r9,pc[1824]
80003574:	72 08       	ld.w	r8,r9[0x0]
80003576:	20 18       	sub	r8,1
80003578:	93 08       	st.w	r9[0x0],r8
8000357a:	c0 71       	brne	80003588 <phy_rx_func+0x4fc>
								RxMediaState = WAITINGABAB;
8000357c:	30 09       	mov	r9,0
8000357e:	fe f8 07 0a 	ld.w	r8,pc[1802]
80003582:	91 09       	st.w	r8[0x0],r9
80003584:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003588:	fe f8 07 20 	ld.w	r8,pc[1824]
8000358c:	fe f9 06 f8 	ld.w	r9,pc[1784]
80003590:	72 0a       	ld.w	r10,r9[0x0]
80003592:	70 09       	ld.w	r9,r8[0x0]
80003594:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003598:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000359c:	70 09       	ld.w	r9,r8[0x0]
8000359e:	2f f9       	sub	r9,-1
800035a0:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035a2:	e0 49 01 ff 	cp.w	r9,511
800035a6:	e0 88 00 16 	brls	800035d2 <phy_rx_func+0x546>
							{
								RxAMBE_IsFillingNext8 = 0;
800035aa:	30 09       	mov	r9,0
800035ac:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035ae:	fe f6 06 d6 	ld.w	r6,pc[1750]
800035b2:	6c 0c       	ld.w	r12,r6[0x0]
800035b4:	f0 1f 01 bf 	mcall	80003cb0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800035b8:	fe f8 06 c8 	ld.w	r8,pc[1736]
800035bc:	70 0c       	ld.w	r12,r8[0x0]
800035be:	f0 1f 01 ab 	mcall	80003c68 <phy_rx_func+0xbdc>
800035c2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035c4:	c0 71       	brne	800035d2 <phy_rx_func+0x546>
								{
									RxMediaState = WAITINGABAB;
800035c6:	30 09       	mov	r9,0
800035c8:	fe f8 06 c0 	ld.w	r8,pc[1728]
800035cc:	91 09       	st.w	r8[0x0],r9
800035ce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035d2:	fe f9 06 be 	ld.w	r9,pc[1726]
800035d6:	72 08       	ld.w	r8,r9[0x0]
800035d8:	20 18       	sub	r8,1
800035da:	93 08       	st.w	r9[0x0],r8
800035dc:	c0 71       	brne	800035ea <phy_rx_func+0x55e>
								RxMediaState = WAITINGABAB;
800035de:	30 09       	mov	r9,0
800035e0:	fe f8 06 a8 	ld.w	r8,pc[1704]
800035e4:	91 09       	st.w	r8[0x0],r9
800035e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
800035ea:	fe f8 06 be 	ld.w	r8,pc[1726]
800035ee:	fe f9 06 96 	ld.w	r9,pc[1686]
800035f2:	72 0a       	ld.w	r10,r9[0x0]
800035f4:	70 09       	ld.w	r9,r8[0x0]
800035f6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800035fa:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035fe:	70 09       	ld.w	r9,r8[0x0]
80003600:	2f f9       	sub	r9,-1
80003602:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003604:	e0 49 01 ff 	cp.w	r9,511
80003608:	e0 88 00 16 	brls	80003634 <phy_rx_func+0x5a8>
							{
								RxAMBE_IsFillingNext8 = 0;
8000360c:	30 09       	mov	r9,0
8000360e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003610:	fe f6 06 74 	ld.w	r6,pc[1652]
80003614:	6c 0c       	ld.w	r12,r6[0x0]
80003616:	f0 1f 01 a7 	mcall	80003cb0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000361a:	fe f8 06 66 	ld.w	r8,pc[1638]
8000361e:	70 0c       	ld.w	r12,r8[0x0]
80003620:	f0 1f 01 92 	mcall	80003c68 <phy_rx_func+0xbdc>
80003624:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003626:	c0 71       	brne	80003634 <phy_rx_func+0x5a8>
								{
									RxMediaState = WAITINGABAB;
80003628:	30 09       	mov	r9,0
8000362a:	fe f8 06 5e 	ld.w	r8,pc[1630]
8000362e:	91 09       	st.w	r8[0x0],r9
80003630:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003634:	fe f9 06 5c 	ld.w	r9,pc[1628]
80003638:	72 08       	ld.w	r8,r9[0x0]
8000363a:	20 18       	sub	r8,1
8000363c:	93 08       	st.w	r9[0x0],r8
8000363e:	c0 71       	brne	8000364c <phy_rx_func+0x5c0>
								RxMediaState = WAITINGABAB;
80003640:	30 09       	mov	r9,0
80003642:	fe f8 06 46 	ld.w	r8,pc[1606]
80003646:	91 09       	st.w	r8[0x0],r9
80003648:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000364c:	fe f8 06 5c 	ld.w	r8,pc[1628]
80003650:	fe f9 06 34 	ld.w	r9,pc[1588]
80003654:	72 0a       	ld.w	r10,r9[0x0]
80003656:	70 09       	ld.w	r9,r8[0x0]
80003658:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000365c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003660:	70 09       	ld.w	r9,r8[0x0]
80003662:	2f f9       	sub	r9,-1
80003664:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003666:	e0 49 01 ff 	cp.w	r9,511
8000366a:	e0 88 00 16 	brls	80003696 <phy_rx_func+0x60a>
							{
								RxAMBE_IsFillingNext8 = 0;
8000366e:	30 09       	mov	r9,0
80003670:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003672:	fe f6 06 12 	ld.w	r6,pc[1554]
80003676:	6c 0c       	ld.w	r12,r6[0x0]
80003678:	f0 1f 01 8e 	mcall	80003cb0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
8000367c:	fe f8 06 04 	ld.w	r8,pc[1540]
80003680:	70 0c       	ld.w	r12,r8[0x0]
80003682:	f0 1f 01 7a 	mcall	80003c68 <phy_rx_func+0xbdc>
80003686:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003688:	c0 71       	brne	80003696 <phy_rx_func+0x60a>
								{
									RxMediaState = WAITINGABAB;
8000368a:	30 09       	mov	r9,0
8000368c:	fe f8 05 fc 	ld.w	r8,pc[1532]
80003690:	91 09       	st.w	r8[0x0],r9
80003692:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003696:	fe f9 05 fa 	ld.w	r9,pc[1530]
8000369a:	72 08       	ld.w	r8,r9[0x0]
8000369c:	20 18       	sub	r8,1
8000369e:	93 08       	st.w	r9[0x0],r8
800036a0:	c0 71       	brne	800036ae <phy_rx_func+0x622>
								RxMediaState = WAITINGABAB;
800036a2:	30 09       	mov	r9,0
800036a4:	fe f8 05 e4 	ld.w	r8,pc[1508]
800036a8:	91 09       	st.w	r8[0x0],r9
800036aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800036ae:	fe f8 05 fa 	ld.w	r8,pc[1530]
800036b2:	fe f9 05 d2 	ld.w	r9,pc[1490]
800036b6:	72 0a       	ld.w	r10,r9[0x0]
800036b8:	70 09       	ld.w	r9,r8[0x0]
800036ba:	ef 3b 00 0e 	ld.ub	r11,r7[14]
800036be:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800036c2:	70 09       	ld.w	r9,r8[0x0]
800036c4:	2f f9       	sub	r9,-1
800036c6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036c8:	e0 49 01 ff 	cp.w	r9,511
800036cc:	e0 88 00 16 	brls	800036f8 <phy_rx_func+0x66c>
							{
								RxAMBE_IsFillingNext8 = 0;
800036d0:	30 09       	mov	r9,0
800036d2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800036d4:	fe f6 05 b0 	ld.w	r6,pc[1456]
800036d8:	6c 0c       	ld.w	r12,r6[0x0]
800036da:	f0 1f 01 76 	mcall	80003cb0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
800036de:	fe f8 05 a2 	ld.w	r8,pc[1442]
800036e2:	70 0c       	ld.w	r12,r8[0x0]
800036e4:	f0 1f 01 61 	mcall	80003c68 <phy_rx_func+0xbdc>
800036e8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800036ea:	c0 71       	brne	800036f8 <phy_rx_func+0x66c>
								{
									RxMediaState = WAITINGABAB;
800036ec:	30 09       	mov	r9,0
800036ee:	fe f8 05 9a 	ld.w	r8,pc[1434]
800036f2:	91 09       	st.w	r8[0x0],r9
800036f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036f8:	fe f9 05 98 	ld.w	r9,pc[1432]
800036fc:	72 08       	ld.w	r8,r9[0x0]
800036fe:	20 18       	sub	r8,1
80003700:	93 08       	st.w	r9[0x0],r8
80003702:	c0 71       	brne	80003710 <phy_rx_func+0x684>
								RxMediaState = WAITINGABAB;
80003704:	30 09       	mov	r9,0
80003706:	fe f8 05 82 	ld.w	r8,pc[1410]
8000370a:	91 09       	st.w	r8[0x0],r9
8000370c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003710:	fe f8 05 98 	ld.w	r8,pc[1432]
80003714:	fe f9 05 70 	ld.w	r9,pc[1392]
80003718:	72 0a       	ld.w	r10,r9[0x0]
8000371a:	70 09       	ld.w	r9,r8[0x0]
8000371c:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003720:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003724:	70 09       	ld.w	r9,r8[0x0]
80003726:	2f f9       	sub	r9,-1
80003728:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000372a:	e0 49 01 ff 	cp.w	r9,511
8000372e:	e0 88 00 16 	brls	8000375a <phy_rx_func+0x6ce>
							{
								RxAMBE_IsFillingNext8 = 0;
80003732:	30 09       	mov	r9,0
80003734:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003736:	fe f7 05 4e 	ld.w	r7,pc[1358]
8000373a:	6e 0c       	ld.w	r12,r7[0x0]
8000373c:	f0 1f 01 5d 	mcall	80003cb0 <phy_rx_func+0xc24>
								AMBE_payload_ptr = get_payload_idle_isr();
80003740:	fe f8 05 40 	ld.w	r8,pc[1344]
80003744:	70 0c       	ld.w	r12,r8[0x0]
80003746:	f0 1f 01 49 	mcall	80003c68 <phy_rx_func+0xbdc>
8000374a:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000374c:	c0 71       	brne	8000375a <phy_rx_func+0x6ce>
								{
									RxMediaState = WAITINGABAB;
8000374e:	30 09       	mov	r9,0
80003750:	fe f8 05 38 	ld.w	r8,pc[1336]
80003754:	91 09       	st.w	r8[0x0],r9
80003756:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
8000375a:	fe f9 05 36 	ld.w	r9,pc[1334]
8000375e:	72 08       	ld.w	r8,r9[0x0]
80003760:	20 18       	sub	r8,1
80003762:	93 08       	st.w	r9[0x0],r8
80003764:	e0 81 02 74 	brne	80003c4c <phy_rx_func+0xbc0>
								RxMediaState = WAITINGABAB;
80003768:	30 09       	mov	r9,0
8000376a:	fe f8 05 1e 	ld.w	r8,pc[1310]
8000376e:	91 09       	st.w	r8[0x0],r9
80003770:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003774:	30 09       	mov	r9,0
80003776:	fe f8 05 12 	ld.w	r8,pc[1298]
8000377a:	91 09       	st.w	r8[0x0],r9
8000377c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003780:	fe f8 05 20 	ld.w	r8,pc[1312]
80003784:	11 89       	ld.ub	r9,r8[0x0]
80003786:	3f 28       	mov	r8,-14
80003788:	f0 09 18 00 	cp.b	r9,r8
8000378c:	c4 31       	brne	80003812 <phy_rx_func+0x786>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
8000378e:	8e 49       	ld.sh	r9,r7[0x8]
80003790:	fe f8 05 40 	ld.w	r8,pc[1344]
80003794:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003796:	fe f8 05 12 	ld.w	r8,pc[1298]
8000379a:	fe f9 04 ea 	ld.w	r9,pc[1258]
8000379e:	72 0a       	ld.w	r10,r9[0x0]
800037a0:	70 09       	ld.w	r9,r8[0x0]
800037a2:	ef 3b 00 08 	ld.ub	r11,r7[8]
800037a6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037aa:	70 09       	ld.w	r9,r8[0x0]
800037ac:	2f f9       	sub	r9,-1
800037ae:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037b0:	e0 49 01 ff 	cp.w	r9,511
800037b4:	e0 88 00 16 	brls	800037e0 <phy_rx_func+0x754>
						{
							RxAMBE_IsFillingNext8 = 0;
800037b8:	30 09       	mov	r9,0
800037ba:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037bc:	fe f7 04 c8 	ld.w	r7,pc[1224]
800037c0:	6e 0c       	ld.w	r12,r7[0x0]
800037c2:	f0 1f 01 3c 	mcall	80003cb0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800037c6:	fe f8 04 ba 	ld.w	r8,pc[1210]
800037ca:	70 0c       	ld.w	r12,r8[0x0]
800037cc:	f0 1f 01 27 	mcall	80003c68 <phy_rx_func+0xbdc>
800037d0:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037d2:	c0 71       	brne	800037e0 <phy_rx_func+0x754>
							{
								RxMediaState = WAITINGABAB;
800037d4:	30 09       	mov	r9,0
800037d6:	fe f8 04 b2 	ld.w	r8,pc[1202]
800037da:	91 09       	st.w	r8[0x0],r9
800037dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037e0:	fe f9 04 b0 	ld.w	r9,pc[1200]
800037e4:	72 08       	ld.w	r8,r9[0x0]
800037e6:	20 18       	sub	r8,1
800037e8:	93 08       	st.w	r9[0x0],r8
800037ea:	c0 71       	brne	800037f8 <phy_rx_func+0x76c>
							RxMediaState = WAITINGABAB;
800037ec:	30 09       	mov	r9,0
800037ee:	fe f8 04 9a 	ld.w	r8,pc[1178]
800037f2:	91 09       	st.w	r8[0x0],r9
800037f4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
800037f8:	20 18       	sub	r8,1
800037fa:	fe f9 04 96 	ld.w	r9,pc[1174]
800037fe:	93 08       	st.w	r9[0x0],r8
80003800:	58 08       	cp.w	r8,0
80003802:	e0 81 02 25 	brne	80003c4c <phy_rx_func+0xbc0>
							RxMediaState = WAITINGABAB;
80003806:	30 09       	mov	r9,0
80003808:	fe f8 04 80 	ld.w	r8,pc[1152]
8000380c:	91 09       	st.w	r8[0x0],r9
8000380e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003812:	fe f8 04 8e 	ld.w	r8,pc[1166]
80003816:	11 89       	ld.ub	r9,r8[0x0]
80003818:	3f 38       	mov	r8,-13
8000381a:	f0 09 18 00 	cp.b	r9,r8
8000381e:	e0 81 01 0c 	brne	80003a36 <phy_rx_func+0x9aa>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003822:	8e 49       	ld.sh	r9,r7[0x8]
80003824:	fe f8 04 ac 	ld.w	r8,pc[1196]
80003828:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
8000382a:	8e 59       	ld.sh	r9,r7[0xa]
8000382c:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000382e:	8e 69       	ld.sh	r9,r7[0xc]
80003830:	b0 39       	st.h	r8[0x6],r9
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003832:	fe f8 04 76 	ld.w	r8,pc[1142]
80003836:	fe f9 04 4e 	ld.w	r9,pc[1102]
8000383a:	72 0a       	ld.w	r10,r9[0x0]
8000383c:	70 09       	ld.w	r9,r8[0x0]
8000383e:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003842:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003846:	70 09       	ld.w	r9,r8[0x0]
80003848:	2f f9       	sub	r9,-1
8000384a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000384c:	e0 49 01 ff 	cp.w	r9,511
80003850:	e0 88 00 16 	brls	8000387c <phy_rx_func+0x7f0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003854:	30 09       	mov	r9,0
80003856:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003858:	fe f6 04 2c 	ld.w	r6,pc[1068]
8000385c:	6c 0c       	ld.w	r12,r6[0x0]
8000385e:	f0 1f 01 15 	mcall	80003cb0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003862:	fe f8 04 1e 	ld.w	r8,pc[1054]
80003866:	70 0c       	ld.w	r12,r8[0x0]
80003868:	f0 1f 01 00 	mcall	80003c68 <phy_rx_func+0xbdc>
8000386c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000386e:	c0 71       	brne	8000387c <phy_rx_func+0x7f0>
							{
								RxMediaState = WAITINGABAB;
80003870:	30 09       	mov	r9,0
80003872:	fe f8 04 16 	ld.w	r8,pc[1046]
80003876:	91 09       	st.w	r8[0x0],r9
80003878:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000387c:	fe f9 04 14 	ld.w	r9,pc[1044]
80003880:	72 08       	ld.w	r8,r9[0x0]
80003882:	20 18       	sub	r8,1
80003884:	93 08       	st.w	r9[0x0],r8
80003886:	c0 71       	brne	80003894 <phy_rx_func+0x808>
							RxMediaState = WAITINGABAB;
80003888:	30 09       	mov	r9,0
8000388a:	fe f8 03 fe 	ld.w	r8,pc[1022]
8000388e:	91 09       	st.w	r8[0x0],r9
80003890:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003894:	fe f8 04 14 	ld.w	r8,pc[1044]
80003898:	fe f9 03 ec 	ld.w	r9,pc[1004]
8000389c:	72 0a       	ld.w	r10,r9[0x0]
8000389e:	70 09       	ld.w	r9,r8[0x0]
800038a0:	ef 3b 00 09 	ld.ub	r11,r7[9]
800038a4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038a8:	70 09       	ld.w	r9,r8[0x0]
800038aa:	2f f9       	sub	r9,-1
800038ac:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038ae:	e0 49 01 ff 	cp.w	r9,511
800038b2:	e0 88 00 16 	brls	800038de <phy_rx_func+0x852>
						{
							RxAMBE_IsFillingNext8 = 0;
800038b6:	30 09       	mov	r9,0
800038b8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038ba:	fe f6 03 ca 	ld.w	r6,pc[970]
800038be:	6c 0c       	ld.w	r12,r6[0x0]
800038c0:	f0 1f 00 fc 	mcall	80003cb0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800038c4:	fe f8 03 bc 	ld.w	r8,pc[956]
800038c8:	70 0c       	ld.w	r12,r8[0x0]
800038ca:	f0 1f 00 e8 	mcall	80003c68 <phy_rx_func+0xbdc>
800038ce:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038d0:	c0 71       	brne	800038de <phy_rx_func+0x852>
							{
								RxMediaState = WAITINGABAB;
800038d2:	30 09       	mov	r9,0
800038d4:	fe f8 03 b4 	ld.w	r8,pc[948]
800038d8:	91 09       	st.w	r8[0x0],r9
800038da:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038de:	fe f9 03 b2 	ld.w	r9,pc[946]
800038e2:	72 08       	ld.w	r8,r9[0x0]
800038e4:	20 18       	sub	r8,1
800038e6:	93 08       	st.w	r9[0x0],r8
800038e8:	c0 71       	brne	800038f6 <phy_rx_func+0x86a>
							RxMediaState = WAITINGABAB;
800038ea:	30 09       	mov	r9,0
800038ec:	fe f8 03 9c 	ld.w	r8,pc[924]
800038f0:	91 09       	st.w	r8[0x0],r9
800038f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
800038f6:	fe f8 03 b2 	ld.w	r8,pc[946]
800038fa:	fe f9 03 8a 	ld.w	r9,pc[906]
800038fe:	72 0a       	ld.w	r10,r9[0x0]
80003900:	70 09       	ld.w	r9,r8[0x0]
80003902:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003906:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000390a:	70 09       	ld.w	r9,r8[0x0]
8000390c:	2f f9       	sub	r9,-1
8000390e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003910:	e0 49 01 ff 	cp.w	r9,511
80003914:	e0 88 00 16 	brls	80003940 <phy_rx_func+0x8b4>
						{
							RxAMBE_IsFillingNext8 = 0;
80003918:	30 09       	mov	r9,0
8000391a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000391c:	fe f6 03 68 	ld.w	r6,pc[872]
80003920:	6c 0c       	ld.w	r12,r6[0x0]
80003922:	f0 1f 00 e4 	mcall	80003cb0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003926:	fe f8 03 5a 	ld.w	r8,pc[858]
8000392a:	70 0c       	ld.w	r12,r8[0x0]
8000392c:	f0 1f 00 cf 	mcall	80003c68 <phy_rx_func+0xbdc>
80003930:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003932:	c0 71       	brne	80003940 <phy_rx_func+0x8b4>
							{
								RxMediaState = WAITINGABAB;
80003934:	30 09       	mov	r9,0
80003936:	fe f8 03 52 	ld.w	r8,pc[850]
8000393a:	91 09       	st.w	r8[0x0],r9
8000393c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003940:	fe f9 03 50 	ld.w	r9,pc[848]
80003944:	72 08       	ld.w	r8,r9[0x0]
80003946:	20 18       	sub	r8,1
80003948:	93 08       	st.w	r9[0x0],r8
8000394a:	c0 71       	brne	80003958 <phy_rx_func+0x8cc>
							RxMediaState = WAITINGABAB;
8000394c:	30 09       	mov	r9,0
8000394e:	fe f8 03 3a 	ld.w	r8,pc[826]
80003952:	91 09       	st.w	r8[0x0],r9
80003954:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003958:	fe f8 03 50 	ld.w	r8,pc[848]
8000395c:	fe f9 03 28 	ld.w	r9,pc[808]
80003960:	72 0a       	ld.w	r10,r9[0x0]
80003962:	70 09       	ld.w	r9,r8[0x0]
80003964:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003968:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000396c:	70 09       	ld.w	r9,r8[0x0]
8000396e:	2f f9       	sub	r9,-1
80003970:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003972:	e0 49 01 ff 	cp.w	r9,511
80003976:	e0 88 00 16 	brls	800039a2 <phy_rx_func+0x916>
						{
							RxAMBE_IsFillingNext8 = 0;
8000397a:	30 09       	mov	r9,0
8000397c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000397e:	fe f6 03 06 	ld.w	r6,pc[774]
80003982:	6c 0c       	ld.w	r12,r6[0x0]
80003984:	f0 1f 00 cb 	mcall	80003cb0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
80003988:	fe f8 02 f8 	ld.w	r8,pc[760]
8000398c:	70 0c       	ld.w	r12,r8[0x0]
8000398e:	f0 1f 00 b7 	mcall	80003c68 <phy_rx_func+0xbdc>
80003992:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003994:	c0 71       	brne	800039a2 <phy_rx_func+0x916>
							{
								RxMediaState = WAITINGABAB;
80003996:	30 09       	mov	r9,0
80003998:	fe f8 02 f0 	ld.w	r8,pc[752]
8000399c:	91 09       	st.w	r8[0x0],r9
8000399e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800039a2:	fe f9 02 ee 	ld.w	r9,pc[750]
800039a6:	72 08       	ld.w	r8,r9[0x0]
800039a8:	20 18       	sub	r8,1
800039aa:	93 08       	st.w	r9[0x0],r8
800039ac:	c0 71       	brne	800039ba <phy_rx_func+0x92e>
							RxMediaState = WAITINGABAB;
800039ae:	30 09       	mov	r9,0
800039b0:	fe f8 02 d8 	ld.w	r8,pc[728]
800039b4:	91 09       	st.w	r8[0x0],r9
800039b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
800039ba:	fe f8 02 ee 	ld.w	r8,pc[750]
800039be:	fe f9 02 c6 	ld.w	r9,pc[710]
800039c2:	72 0a       	ld.w	r10,r9[0x0]
800039c4:	70 09       	ld.w	r9,r8[0x0]
800039c6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800039ca:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800039ce:	70 09       	ld.w	r9,r8[0x0]
800039d0:	2f f9       	sub	r9,-1
800039d2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039d4:	e0 49 01 ff 	cp.w	r9,511
800039d8:	e0 88 00 16 	brls	80003a04 <phy_rx_func+0x978>
						{
							RxAMBE_IsFillingNext8 = 0;
800039dc:	30 09       	mov	r9,0
800039de:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800039e0:	fe f7 02 a4 	ld.w	r7,pc[676]
800039e4:	6e 0c       	ld.w	r12,r7[0x0]
800039e6:	f0 1f 00 b3 	mcall	80003cb0 <phy_rx_func+0xc24>
							AMBE_payload_ptr = get_payload_idle_isr();
800039ea:	fe f8 02 96 	ld.w	r8,pc[662]
800039ee:	70 0c       	ld.w	r12,r8[0x0]
800039f0:	f0 1f 00 9e 	mcall	80003c68 <phy_rx_func+0xbdc>
800039f4:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
800039f6:	c0 71       	brne	80003a04 <phy_rx_func+0x978>
							{
								RxMediaState = WAITINGABAB;
800039f8:	30 09       	mov	r9,0
800039fa:	fe f8 02 8e 	ld.w	r8,pc[654]
800039fe:	91 09       	st.w	r8[0x0],r9
80003a00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003a04:	fe f9 02 8c 	ld.w	r9,pc[652]
80003a08:	72 08       	ld.w	r8,r9[0x0]
80003a0a:	20 18       	sub	r8,1
80003a0c:	93 08       	st.w	r9[0x0],r8
80003a0e:	c0 71       	brne	80003a1c <phy_rx_func+0x990>
							RxMediaState = WAITINGABAB;
80003a10:	30 09       	mov	r9,0
80003a12:	fe f8 02 76 	ld.w	r8,pc[630]
80003a16:	91 09       	st.w	r8[0x0],r9
80003a18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003a1c:	20 18       	sub	r8,1
80003a1e:	fe f9 02 72 	ld.w	r9,pc[626]
80003a22:	93 08       	st.w	r9[0x0],r8
80003a24:	58 08       	cp.w	r8,0
80003a26:	e0 81 01 13 	brne	80003c4c <phy_rx_func+0xbc0>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003a2a:	30 09       	mov	r9,0
80003a2c:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a30:	91 09       	st.w	r8[0x0],r9
80003a32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003a36:	fe f8 02 6a 	ld.w	r8,pc[618]
80003a3a:	11 89       	ld.ub	r9,r8[0x0]
80003a3c:	30 48       	mov	r8,4
80003a3e:	f0 09 18 00 	cp.b	r9,r8
80003a42:	c0 80       	breq	80003a52 <phy_rx_func+0x9c6>
80003a44:	fe f8 02 5c 	ld.w	r8,pc[604]
80003a48:	11 89       	ld.ub	r9,r8[0x0]
80003a4a:	30 38       	mov	r8,3
80003a4c:	f0 09 18 00 	cp.b	r9,r8
80003a50:	c1 41       	brne	80003a78 <phy_rx_func+0x9ec>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003a52:	6e 29       	ld.w	r9,r7[0x8]
80003a54:	fe f8 02 74 	ld.w	r8,pc[628]
80003a58:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003a5a:	6e 39       	ld.w	r9,r7[0xc]
80003a5c:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003a5e:	fe f9 02 32 	ld.w	r9,pc[562]
80003a62:	72 08       	ld.w	r8,r9[0x0]
80003a64:	20 88       	sub	r8,8
80003a66:	93 08       	st.w	r9[0x0],r8
80003a68:	e0 81 00 f2 	brne	80003c4c <phy_rx_func+0xbc0>
						{
					
							RxBytesWaiting = 0;
80003a6c:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003a6e:	fe f9 02 1a 	ld.w	r9,pc[538]
80003a72:	93 08       	st.w	r9[0x0],r8
80003a74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003a78:	fe f8 02 28 	ld.w	r8,pc[552]
80003a7c:	11 89       	ld.ub	r9,r8[0x0]
80003a7e:	31 38       	mov	r8,19
80003a80:	f0 09 18 00 	cp.b	r9,r8
80003a84:	e0 81 00 9c 	brne	80003bbc <phy_rx_func+0xb30>
					{							
						if (SDV_Index == 12)
80003a88:	fe f8 02 4c 	ld.w	r8,pc[588]
80003a8c:	11 88       	ld.ub	r8,r8[0x0]
80003a8e:	30 c9       	mov	r9,12
80003a90:	f2 08 18 00 	cp.b	r8,r9
80003a94:	e0 81 00 7b 	brne	80003b8a <phy_rx_func+0xafe>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003a98:	8e 49       	ld.sh	r9,r7[0x8]
80003a9a:	fe f8 02 3e 	ld.w	r8,pc[574]
80003a9e:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003aa2:	30 09       	mov	r9,0
80003aa4:	fe f8 02 30 	ld.w	r8,pc[560]
80003aa8:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003aaa:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003aae:	3f 38       	mov	r8,-13
80003ab0:	f0 09 18 00 	cp.b	r9,r8
80003ab4:	c6 61       	brne	80003b80 <phy_rx_func+0xaf4>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003ab6:	10 99       	mov	r9,r8
80003ab8:	4f a8       	lddpc	r8,80003ca0 <phy_rx_func+0xc14>
80003aba:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003abc:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003ac0:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003ac4:	4f 38       	lddpc	r8,80003c90 <phy_rx_func+0xc04>
80003ac6:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003ac8:	30 19       	mov	r9,1
80003aca:	fe f8 02 12 	ld.w	r8,pc[530]
80003ace:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003ad0:	8e 79       	ld.sh	r9,r7[0xe]
80003ad2:	fe f8 01 fe 	ld.w	r8,pc[510]
80003ad6:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003ad8:	4f 48       	lddpc	r8,80003ca8 <phy_rx_func+0xc1c>
80003ada:	4e b9       	lddpc	r9,80003c84 <phy_rx_func+0xbf8>
80003adc:	72 0a       	ld.w	r10,r9[0x0]
80003ade:	70 09       	ld.w	r9,r8[0x0]
80003ae0:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003ae4:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003ae8:	70 09       	ld.w	r9,r8[0x0]
80003aea:	2f f9       	sub	r9,-1
80003aec:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003aee:	e0 49 01 ff 	cp.w	r9,511
80003af2:	e0 88 00 13 	brls	80003b18 <phy_rx_func+0xa8c>
									{
										RxAMBE_IsFillingNext8 = 0;
80003af6:	30 09       	mov	r9,0
80003af8:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003afa:	4e 36       	lddpc	r6,80003c84 <phy_rx_func+0xbf8>
80003afc:	6c 0c       	ld.w	r12,r6[0x0]
80003afe:	f0 1f 00 6d 	mcall	80003cb0 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b02:	4e 08       	lddpc	r8,80003c80 <phy_rx_func+0xbf4>
80003b04:	70 0c       	ld.w	r12,r8[0x0]
80003b06:	f0 1f 00 59 	mcall	80003c68 <phy_rx_func+0xbdc>
80003b0a:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b0c:	c0 61       	brne	80003b18 <phy_rx_func+0xa8c>
										{
											RxMediaState = WAITINGABAB;
80003b0e:	30 09       	mov	r9,0
80003b10:	4d e8       	lddpc	r8,80003c88 <phy_rx_func+0xbfc>
80003b12:	91 09       	st.w	r8[0x0],r9
80003b14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b18:	4d e9       	lddpc	r9,80003c90 <phy_rx_func+0xc04>
80003b1a:	72 08       	ld.w	r8,r9[0x0]
80003b1c:	20 18       	sub	r8,1
80003b1e:	93 08       	st.w	r9[0x0],r8
80003b20:	c0 61       	brne	80003b2c <phy_rx_func+0xaa0>
										RxMediaState = WAITINGABAB;
80003b22:	30 09       	mov	r9,0
80003b24:	4d 98       	lddpc	r8,80003c88 <phy_rx_func+0xbfc>
80003b26:	91 09       	st.w	r8[0x0],r9
80003b28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003b2c:	4d f8       	lddpc	r8,80003ca8 <phy_rx_func+0xc1c>
80003b2e:	4d 69       	lddpc	r9,80003c84 <phy_rx_func+0xbf8>
80003b30:	72 0a       	ld.w	r10,r9[0x0]
80003b32:	70 09       	ld.w	r9,r8[0x0]
80003b34:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003b38:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003b3c:	70 09       	ld.w	r9,r8[0x0]
80003b3e:	2f f9       	sub	r9,-1
80003b40:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b42:	e0 49 01 ff 	cp.w	r9,511
80003b46:	e0 88 00 13 	brls	80003b6c <phy_rx_func+0xae0>
									{
										RxAMBE_IsFillingNext8 = 0;
80003b4a:	30 09       	mov	r9,0
80003b4c:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003b4e:	4c e7       	lddpc	r7,80003c84 <phy_rx_func+0xbf8>
80003b50:	6e 0c       	ld.w	r12,r7[0x0]
80003b52:	f0 1f 00 58 	mcall	80003cb0 <phy_rx_func+0xc24>
										AMBE_payload_ptr = get_payload_idle_isr();
80003b56:	4c b8       	lddpc	r8,80003c80 <phy_rx_func+0xbf4>
80003b58:	70 0c       	ld.w	r12,r8[0x0]
80003b5a:	f0 1f 00 44 	mcall	80003c68 <phy_rx_func+0xbdc>
80003b5e:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003b60:	c0 61       	brne	80003b6c <phy_rx_func+0xae0>
										{
											RxMediaState = WAITINGABAB;
80003b62:	30 09       	mov	r9,0
80003b64:	4c 98       	lddpc	r8,80003c88 <phy_rx_func+0xbfc>
80003b66:	91 09       	st.w	r8[0x0],r9
80003b68:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003b6c:	4c 99       	lddpc	r9,80003c90 <phy_rx_func+0xc04>
80003b6e:	72 08       	ld.w	r8,r9[0x0]
80003b70:	20 18       	sub	r8,1
80003b72:	93 08       	st.w	r9[0x0],r8
80003b74:	c6 c1       	brne	80003c4c <phy_rx_func+0xbc0>
										RxMediaState = WAITINGABAB;
80003b76:	30 09       	mov	r9,0
80003b78:	4c 48       	lddpc	r8,80003c88 <phy_rx_func+0xbfc>
80003b7a:	91 09       	st.w	r8[0x0],r9
80003b7c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003b80:	30 09       	mov	r9,0
80003b82:	4c 28       	lddpc	r8,80003c88 <phy_rx_func+0xbfc>
80003b84:	91 09       	st.w	r8[0x0],r9
80003b86:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003b8a:	8e 4a       	ld.sh	r10,r7[0x8]
80003b8c:	4d 39       	lddpc	r9,80003cd8 <phy_rx_func+0xc4c>
80003b8e:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003b92:	4d 1a       	lddpc	r10,80003cd4 <phy_rx_func+0xc48>
80003b94:	15 88       	ld.ub	r8,r10[0x0]
80003b96:	f0 cb ff ff 	sub	r11,r8,-1
80003b9a:	8e 5c       	ld.sh	r12,r7[0xa]
80003b9c:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003ba0:	f0 cb ff fe 	sub	r11,r8,-2
80003ba4:	8e 6c       	ld.sh	r12,r7[0xc]
80003ba6:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003baa:	f0 cb ff fd 	sub	r11,r8,-3
80003bae:	8e 7c       	ld.sh	r12,r7[0xe]
80003bb0:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003bb4:	2f c8       	sub	r8,-4
80003bb6:	b4 88       	st.b	r10[0x0],r8
80003bb8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003bbc:	30 09       	mov	r9,0
80003bbe:	4b 38       	lddpc	r8,80003c88 <phy_rx_func+0xbfc>
80003bc0:	91 09       	st.w	r8[0x0],r9
80003bc2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003bc6:	4b f8       	lddpc	r8,80003cc0 <phy_rx_func+0xc34>
80003bc8:	70 09       	ld.w	r9,r8[0x0]
80003bca:	8e 4b       	ld.sh	r11,r7[0x8]
80003bcc:	4b ea       	lddpc	r10,80003cc4 <phy_rx_func+0xc38>
80003bce:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003bd2:	2f f9       	sub	r9,-1
80003bd4:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003bd6:	4b 48       	lddpc	r8,80003ca4 <phy_rx_func+0xc18>
80003bd8:	70 09       	ld.w	r9,r8[0x0]
80003bda:	20 29       	sub	r9,2
80003bdc:	91 09       	st.w	r8[0x0],r9
80003bde:	70 08       	ld.w	r8,r8[0x0]
80003be0:	58 08       	cp.w	r8,0
80003be2:	c2 f1       	brne	80003c40 <phy_rx_func+0xbb4>
				{
					RxData_IsFillingNext16 = 0;
80003be4:	30 09       	mov	r9,0
80003be6:	4b 78       	lddpc	r8,80003cc0 <phy_rx_func+0xc34>
80003be8:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003bea:	8e 59       	ld.sh	r9,r7[0xa]
80003bec:	fe 78 82 12 	mov	r8,-32238
80003bf0:	f0 09 19 00 	cp.h	r9,r8
80003bf4:	c2 11       	brne	80003c36 <phy_rx_func+0xbaa>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003bf6:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003bfa:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003bfe:	4a e8       	lddpc	r8,80003cb4 <phy_rx_func+0xc28>
80003c00:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003c02:	8e 59       	ld.sh	r9,r7[0xa]
80003c04:	4a d8       	lddpc	r8,80003cb8 <phy_rx_func+0xc2c>
80003c06:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003c08:	8e 69       	ld.sh	r9,r7[0xc]
80003c0a:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003c0c:	f0 1f 00 2c 	mcall	80003cbc <phy_rx_func+0xc30>
80003c10:	49 f8       	lddpc	r8,80003c8c <phy_rx_func+0xc00>
80003c12:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003c14:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003c18:	31 38       	mov	r8,19
80003c1a:	f0 09 18 00 	cp.b	r9,r8
80003c1e:	c0 71       	brne	80003c2c <phy_rx_func+0xba0>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003c20:	10 99       	mov	r9,r8
80003c22:	4a 08       	lddpc	r8,80003ca0 <phy_rx_func+0xc14>
80003c24:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003c26:	30 09       	mov	r9,0
80003c28:	49 a8       	lddpc	r8,80003c90 <phy_rx_func+0xc04>
80003c2a:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003c2c:	30 49       	mov	r9,4
80003c2e:	49 78       	lddpc	r8,80003c88 <phy_rx_func+0xbfc>
80003c30:	91 09       	st.w	r8[0x0],r9
80003c32:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003c36:	30 09       	mov	r9,0
80003c38:	49 48       	lddpc	r8,80003c88 <phy_rx_func+0xbfc>
80003c3a:	91 09       	st.w	r8[0x0],r9
80003c3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003c40:	4a 8c       	lddpc	r12,80003ce0 <phy_rx_func+0xc54>
80003c42:	f0 1f 00 16 	mcall	80003c98 <phy_rx_func+0xc0c>
					RxMediaState = WAITINGABAB;//Jump
80003c46:	30 09       	mov	r9,0
80003c48:	49 08       	lddpc	r8,80003c88 <phy_rx_func+0xbfc>
80003c4a:	91 09       	st.w	r8[0x0],r9
80003c4c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003c50:	00 00       	add	r0,r0
80003c52:	0a b0       	st.h	r5++,r0
80003c54:	00 00       	add	r0,r0
80003c56:	0a a8       	st.w	r5++,r8
80003c58:	00 00       	add	r0,r0
80003c5a:	0a 64       	and	r4,r5
80003c5c:	00 00       	add	r0,r0
80003c5e:	0a 5c       	eor	r12,r5
80003c60:	00 00       	add	r0,r0
80003c62:	0a c8       	st.b	r5++,r8
80003c64:	00 00       	add	r0,r0
80003c66:	0a 94       	mov	r4,r5
80003c68:	80 00       	ld.sh	r0,r0[0x0]
80003c6a:	2a 5c       	sub	r12,-91
80003c6c:	00 00       	add	r0,r0
80003c6e:	0a 6c       	and	r12,r5
80003c70:	80 00       	ld.sh	r0,r0[0x0]
80003c72:	53 24       	stdsp	sp[0xc8],r4
80003c74:	00 00       	add	r0,r0
80003c76:	0a 90       	mov	r0,r5
80003c78:	80 00       	ld.sh	r0,r0[0x0]
80003c7a:	29 a8       	sub	r8,-102
80003c7c:	00 00       	add	r0,r0
80003c7e:	0a a0       	st.w	r5++,r0
80003c80:	00 00       	add	r0,r0
80003c82:	0a 68       	and	r8,r5
80003c84:	00 00       	add	r0,r0
80003c86:	0a 88       	andn	r8,r5
80003c88:	00 00       	add	r0,r0
80003c8a:	0a b4       	st.h	r5++,r4
80003c8c:	00 00       	add	r0,r0
80003c8e:	0a 60       	and	r0,r5
80003c90:	00 00       	add	r0,r0
80003c92:	0a bc       	st.h	r5++,r12
80003c94:	80 00       	ld.sh	r0,r0[0x0]
80003c96:	cb 9c       	rcall	80003e08 <register_rx_tx_func>
80003c98:	80 00       	ld.sh	r0,r0[0x0]
80003c9a:	64 1c       	ld.w	r12,r2[0x4]
80003c9c:	00 00       	add	r0,r0
80003c9e:	0a 43       	or	r3,r5
80003ca0:	00 00       	add	r0,r0
80003ca2:	0a c2       	st.b	r5++,r2
80003ca4:	00 00       	add	r0,r0
80003ca6:	0a 80       	andn	r0,r5
80003ca8:	00 00       	add	r0,r0
80003caa:	0a 98       	mov	r8,r5
80003cac:	80 00       	ld.sh	r0,r0[0x0]
80003cae:	6d 38       	ld.w	r8,r6[0x4c]
80003cb0:	80 00       	ld.sh	r0,r0[0x0]
80003cb2:	30 2c       	mov	r12,2
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a 3a       	cp.w	r10,r5
80003cb8:	00 00       	add	r0,r0
80003cba:	0e 9c       	mov	r12,r7
80003cbc:	80 00       	ld.sh	r0,r0[0x0]
80003cbe:	28 ec       	sub	r12,-114
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a b8       	st.h	r5++,r8
80003cc4:	00 00       	add	r0,r0
80003cc6:	0d a0       	ld.ub	r0,r6[0x2]
80003cc8:	00 00       	add	r0,r0
80003cca:	0a cc       	st.b	r5++,r12
80003ccc:	00 00       	add	r0,r0
80003cce:	0a 40       	or	r0,r5
80003cd0:	00 00       	add	r0,r0
80003cd2:	0d 98       	ld.ub	r8,r6[0x1]
80003cd4:	00 00       	add	r0,r0
80003cd6:	0a 7c       	tst	r12,r5
80003cd8:	00 00       	add	r0,r0
80003cda:	0e a0       	st.w	r7++,r0
80003cdc:	00 00       	add	r0,r0
80003cde:	0a 39       	cp.w	r9,r5
80003ce0:	80 00       	ld.sh	r0,r0[0x0]
80003ce2:	cb b4       	brge	80003c58 <phy_rx_func+0xbcc>

80003ce4 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003ce4:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003ce6:	49 88       	lddpc	r8,80003d44 <pdca_int_handler+0x60>
80003ce8:	11 89       	ld.ub	r9,r8[0x0]
80003cea:	ec 19 00 01 	eorl	r9,0x1
80003cee:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003cf0:	11 89       	ld.ub	r9,r8[0x0]
80003cf2:	a5 69       	lsl	r9,0x4
80003cf4:	2f c9       	sub	r9,-4
80003cf6:	49 5a       	lddpc	r10,80003d48 <pdca_int_handler+0x64>
80003cf8:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003cfa:	fe 7a 00 40 	mov	r10,-65472
80003cfe:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d00:	30 39       	mov	r9,3
80003d02:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003d04:	11 8a       	ld.ub	r10,r8[0x0]
80003d06:	a5 6a       	lsl	r10,0x4
80003d08:	2f ca       	sub	r10,-4
80003d0a:	49 18       	lddpc	r8,80003d4c <pdca_int_handler+0x68>
80003d0c:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003d0e:	fe 78 00 00 	mov	r8,-65536
80003d12:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d14:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003d16:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003d18:	48 e8       	lddpc	r8,80003d50 <pdca_int_handler+0x6c>
80003d1a:	70 08       	ld.w	r8,r8[0x0]
80003d1c:	58 08       	cp.w	r8,0
80003d1e:	c0 70       	breq	80003d2c <pdca_int_handler+0x48>
80003d20:	48 99       	lddpc	r9,80003d44 <pdca_int_handler+0x60>
80003d22:	13 89       	ld.ub	r9,r9[0x0]
80003d24:	a5 69       	lsl	r9,0x4
80003d26:	48 ac       	lddpc	r12,80003d4c <pdca_int_handler+0x68>
80003d28:	12 0c       	add	r12,r9
80003d2a:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003d2c:	48 a8       	lddpc	r8,80003d54 <pdca_int_handler+0x70>
80003d2e:	70 08       	ld.w	r8,r8[0x0]
80003d30:	58 08       	cp.w	r8,0
80003d32:	c0 70       	breq	80003d40 <pdca_int_handler+0x5c>
80003d34:	48 49       	lddpc	r9,80003d44 <pdca_int_handler+0x60>
80003d36:	13 89       	ld.ub	r9,r9[0x0]
80003d38:	a5 69       	lsl	r9,0x4
80003d3a:	48 4c       	lddpc	r12,80003d48 <pdca_int_handler+0x64>
80003d3c:	12 0c       	add	r12,r9
80003d3e:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003d40:	d4 02       	popm	lr
80003d42:	d6 03       	rete
80003d44:	00 00       	add	r0,r0
80003d46:	40 c0       	lddsp	r0,sp[0x30]
80003d48:	00 00       	add	r0,r0
80003d4a:	40 e8       	lddsp	r8,sp[0x38]
80003d4c:	00 00       	add	r0,r0
80003d4e:	40 c8       	lddsp	r8,sp[0x30]
80003d50:	00 00       	add	r0,r0
80003d52:	0a d4       	st.w	--r5,r4
80003d54:	00 00       	add	r0,r0
80003d56:	0a d8       	st.w	--r5,r8

80003d58 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003d58:	fe 78 10 00 	mov	r8,-61440
80003d5c:	e0 69 0d c0 	mov	r9,3520
80003d60:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003d64:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003d68:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003d6c:	fe 78 34 00 	mov	r8,-52224
80003d70:	e0 69 80 00 	mov	r9,32768
80003d74:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003d76:	30 09       	mov	r9,0
80003d78:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003d7a:	e0 69 04 21 	mov	r9,1057
80003d7e:	ea 19 3f 20 	orh	r9,0x3f20
80003d82:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80003d84:	e0 69 02 9f 	mov	r9,671
80003d88:	ea 19 01 00 	orh	r9,0x100
80003d8c:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80003d8e:	e0 6a 04 02 	mov	r10,1026
80003d92:	ea 1a 3f 20 	orh	r10,0x3f20
80003d96:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
80003d98:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003d9a:	5e fc       	retal	r12

80003d9c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003d9c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003d9e:	30 19       	mov	r9,1
80003da0:	49 78       	lddpc	r8,80003dfc <local_start_PDC+0x60>
80003da2:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003da4:	fe 78 00 00 	mov	r8,-65536
80003da8:	30 7b       	mov	r11,7
80003daa:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003dac:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003dae:	49 59       	lddpc	r9,80003e00 <local_start_PDC+0x64>
80003db0:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003db4:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003db6:	30 3a       	mov	r10,3
80003db8:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003dba:	30 1c       	mov	r12,1
80003dbc:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003dbe:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003dc0:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003dc2:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003dc4:	30 2c       	mov	r12,2
80003dc6:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003dc8:	48 f9       	lddpc	r9,80003e04 <local_start_PDC+0x68>
80003dca:	e0 68 5a 5a 	mov	r8,23130
80003dce:	ea 18 ab cd 	orh	r8,0xabcd
80003dd2:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003dd4:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003dd6:	30 0e       	mov	lr,0
80003dd8:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003dda:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003ddc:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003dde:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003de0:	fe 78 00 40 	mov	r8,-65472
80003de4:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003de6:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003de8:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003dec:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003dee:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003df0:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003df2:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003df4:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003df6:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003df8:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003dfa:	d8 02       	popm	pc
80003dfc:	00 00       	add	r0,r0
80003dfe:	40 c0       	lddsp	r0,sp[0x30]
80003e00:	00 00       	add	r0,r0
80003e02:	40 c8       	lddsp	r8,sp[0x30]
80003e04:	00 00       	add	r0,r0
80003e06:	40 e8       	lddsp	r8,sp[0x38]

80003e08 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003e08:	48 38       	lddpc	r8,80003e14 <register_rx_tx_func+0xc>
80003e0a:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003e0c:	48 38       	lddpc	r8,80003e18 <register_rx_tx_func+0x10>
80003e0e:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003e10:	5e fc       	retal	r12
80003e12:	00 00       	add	r0,r0
80003e14:	00 00       	add	r0,r0
80003e16:	0a d4       	st.w	--r5,r4
80003e18:	00 00       	add	r0,r0
80003e1a:	0a d8       	st.w	--r5,r8

80003e1c <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003e1c:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003e1e:	fe 78 10 00 	mov	r8,-61440
80003e22:	30 29       	mov	r9,2
80003e24:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003e28:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003e2c:	10 99       	mov	r9,r8
80003e2e:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e32:	e2 18 00 02 	andl	r8,0x2,COH
80003e36:	cf c0       	breq	80003e2e <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003e38:	fe 79 10 00 	mov	r9,-61440
80003e3c:	f2 f8 01 60 	ld.w	r8,r9[352]
80003e40:	e2 18 00 02 	andl	r8,0x2,COH
80003e44:	cf c1       	brne	80003e3c <ssc_init+0x20>
				
    INTC_register_interrupt (
80003e46:	30 3a       	mov	r10,3
80003e48:	36 0b       	mov	r11,96
80003e4a:	48 bc       	lddpc	r12,80003e74 <ssc_init+0x58>
80003e4c:	f0 1f 00 0b 	mcall	80003e78 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
80003e50:	f0 1f 00 0b 	mcall	80003e7c <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
80003e54:	f0 1f 00 0b 	mcall	80003e80 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e58:	fe 79 00 00 	mov	r9,-65536
80003e5c:	30 18       	mov	r8,1
80003e5e:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003e60:	fe 7a 00 40 	mov	r10,-65472
80003e64:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003e66:	e0 6b 01 01 	mov	r11,257
80003e6a:	fe 7a 34 00 	mov	r10,-52224
80003e6e:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80003e70:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80003e72:	d8 02       	popm	pc
80003e74:	80 00       	ld.sh	r0,r0[0x0]
80003e76:	3c e4       	mov	r4,-50
80003e78:	80 00       	ld.sh	r0,r0[0x0]
80003e7a:	49 5c       	lddpc	r12,80003ecc <xcmp_tx+0x3c>
80003e7c:	80 00       	ld.sh	r0,r0[0x0]
80003e7e:	3d 58       	mov	r8,-43
80003e80:	80 00       	ld.sh	r0,r0[0x0]
80003e82:	3d 9c       	mov	r12,-39

80003e84 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003e84:	48 28       	lddpc	r8,80003e8c <xcmp_register_app_list+0x8>
80003e86:	91 0c       	st.w	r8[0x0],r12
}
80003e88:	5e fc       	retal	r12
80003e8a:	00 00       	add	r0,r0
80003e8c:	00 00       	add	r0,r0
80003e8e:	41 08       	lddsp	r8,sp[0x40]

80003e90 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003e90:	eb cd 40 80 	pushm	r7,lr
80003e94:	fa cd 01 00 	sub	sp,sp,256
80003e98:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003e9a:	16 98       	mov	r8,r11
80003e9c:	2f 08       	sub	r8,-16
80003e9e:	af a8       	sbr	r8,0xe
80003ea0:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003ea2:	3f f8       	mov	r8,-1
80003ea4:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003ea6:	30 b9       	mov	r9,11
80003ea8:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003eaa:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003eac:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003eae:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003eb0:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003eb2:	f6 ca ff fe 	sub	r10,r11,-2
80003eb6:	18 9b       	mov	r11,r12
80003eb8:	fa cc ff f0 	sub	r12,sp,-16
80003ebc:	f0 1f 00 05 	mcall	80003ed0 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003ec0:	2f e7       	sub	r7,-2
80003ec2:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003ec4:	1a 9c       	mov	r12,sp
80003ec6:	f0 1f 00 04 	mcall	80003ed4 <xcmp_tx+0x44>
}
80003eca:	2c 0d       	sub	sp,-256
80003ecc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ed0:	80 00       	ld.sh	r0,r0[0x0]
80003ed2:	6b f0       	ld.w	r0,r5[0x7c]
80003ed4:	80 00       	ld.sh	r0,r0[0x0]
80003ed6:	43 c0       	lddsp	r0,sp[0xf0]

80003ed8 <xcmp_exit_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_exit_device_control_mode(void)
{
80003ed8:	d4 01       	pushm	lr
80003eda:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80003ede:	e0 68 04 21 	mov	r8,1057
80003ee2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80003ee4:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_EXIT;
80003ee8:	30 09       	mov	r9,0
80003eea:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80003eec:	30 19       	mov	r9,1
80003eee:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;//DCM_SPEAKER_CTRL;
80003ef0:	30 39       	mov	r9,3
80003ef2:	b0 a9       	st.b	r8[0x2],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80003ef4:	30 3b       	mov	r11,3
80003ef6:	fa cc ff fe 	sub	r12,sp,-2
80003efa:	f0 1f 00 03 	mcall	80003f04 <xcmp_exit_device_control_mode+0x2c>
}
80003efe:	2c dd       	sub	sp,-204
80003f00:	d8 02       	popm	pc
80003f02:	00 00       	add	r0,r0
80003f04:	80 00       	ld.sh	r0,r0[0x0]
80003f06:	3e 90       	mov	r0,-23

80003f08 <xcmp_enter_device_control_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_device_control_mode(void)
{
80003f08:	d4 01       	pushm	lr
80003f0a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DEVICE_CONTROL_MODE;
80003f0e:	e0 68 04 21 	mov	r8,1057
80003f12:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceControlMode_req_t * ptr = (DeviceControlMode_req_t *)xcmp_farme.u8;
80003f14:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = DCM_ENTER;
80003f18:	30 19       	mov	r9,1
80003f1a:	b0 89       	st.b	r8[0x0],r9
	ptr->ControlTypeSize = 1;
80003f1c:	b0 99       	st.b	r8[0x1],r9
	ptr->ControlType = 0x03;// 0xEB;//user-input
80003f1e:	30 39       	mov	r9,3
80003f20:	b0 a9       	st.b	r8[0x2],r9
	//ptr->ControlType = DCM_SPEAKER_CTRL;
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(DeviceControlMode_req_t));
80003f22:	30 3b       	mov	r11,3
80003f24:	fa cc ff fe 	sub	r12,sp,-2
80003f28:	f0 1f 00 02 	mcall	80003f30 <xcmp_enter_device_control_mode+0x28>
}
80003f2c:	2c dd       	sub	sp,-204
80003f2e:	d8 02       	popm	pc
80003f30:	80 00       	ld.sh	r0,r0[0x0]
80003f32:	3e 90       	mov	r0,-23

80003f34 <xcmp_audio_route_AMBE>:
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
}


void xcmp_audio_route_AMBE(void)
{
80003f34:	d4 01       	pushm	lr
80003f36:	fa cd 00 cc 	sub	sp,sp,204

	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80003f3a:	e0 68 04 14 	mov	r8,1044
80003f3e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80003f40:	fa c8 ff fc 	sub	r8,sp,-4
	
	ptr->Function = Routing_Func_Update_Source;
80003f44:	30 19       	mov	r9,1
80003f46:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 6;// 4;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80003f48:	30 09       	mov	r9,0
80003f4a:	b0 99       	st.b	r8[0x1],r9
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80003f4c:	30 69       	mov	r9,6
80003f4e:	b0 a9       	st.b	r8[0x2],r9
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//Post_AMBE_Encoder;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput = OUT_Option_Board;//Post_AMBE_Encoder;//OUT_Microphone_Data;//测试
	//注意：经测试发现，这里的路径配置，需要特别注意先后顺序，否则会提示参数错误。
	ptr->RoutingData[0].audioInput = Post_AMBE_Encoder;//IN_Option_Board;
80003f50:	30 fa       	mov	r10,15
80003f52:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f54:	30 c9       	mov	r9,12
80003f56:	b0 c9       	st.b	r8[0x4],r9
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
80003f58:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = Post_AMBE_Encoder;// OUT_Speaker;
80003f5a:	b0 ea       	st.b	r8[0x6],r10
	
	ptr->RoutingData[2].audioInput = Pre_AMBE_Decoder;//IN_Option_Board;
80003f5c:	31 0a       	mov	r10,16
80003f5e:	b0 fa       	st.b	r8[0x7],r10
	ptr->RoutingData[2].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f60:	f1 69 00 08 	st.b	r8[8],r9
	ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
80003f64:	f1 69 00 09 	st.b	r8[9],r9
	ptr->RoutingData[3].audioOutput = Pre_AMBE_Decoder;// OUT_Speaker;
80003f68:	f1 6a 00 0a 	st.b	r8[10],r10
	
	ptr->RoutingData[4].audioInput = Tx_Voice_Header;//IN_Option_Board;
80003f6c:	31 1a       	mov	r10,17
80003f6e:	f1 6a 00 0b 	st.b	r8[11],r10
	ptr->RoutingData[4].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f72:	f1 69 00 0c 	st.b	r8[12],r9
	//ptr->RoutingData[3].audioInput = IN_Option_Board;//IN_Option_Board;
	//ptr->RoutingData[3].audioOutput = Tx_Voice_Header;// OUT_Speaker;
	
	ptr->RoutingData[5].audioInput = Tx_Voice_Terminator;//IN_Option_Board;
80003f76:	31 3a       	mov	r10,19
80003f78:	f1 6a 00 0d 	st.b	r8[13],r10
	ptr->RoutingData[5].audioOutput = OUT_Option_Board;// OUT_Speaker;
80003f7c:	f1 69 00 0e 	st.b	r8[14],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
80003f80:	30 fb       	mov	r11,15
80003f82:	fa cc ff fe 	sub	r12,sp,-2
80003f86:	f0 1f 00 03 	mcall	80003f90 <xcmp_audio_route_AMBE+0x5c>

	
}
80003f8a:	2c dd       	sub	sp,-204
80003f8c:	d8 02       	popm	pc
80003f8e:	00 00       	add	r0,r0
80003f90:	80 00       	ld.sh	r0,r0[0x0]
80003f92:	3e 90       	mov	r0,-23

80003f94 <xcmp_enter_enhanced_OB_mode>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_enter_enhanced_OB_mode(void)
{
80003f94:	d4 01       	pushm	lr
80003f96:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | EN_OB_CONTROL;
80003f9a:	e0 68 04 65 	mov	r8,1125
80003f9e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	En_OB_Control_req_t * ptr = (En_OB_Control_req_t *)xcmp_farme.u8;
	
	ptr->Function = EN_OB_Enter;
80003fa0:	fa cc ff fe 	sub	r12,sp,-2
80003fa4:	30 18       	mov	r8,1
80003fa6:	b8 a8       	st.b	r12[0x2],r8
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(En_OB_Control_req_t));
80003fa8:	30 1b       	mov	r11,1
80003faa:	f0 1f 00 03 	mcall	80003fb4 <xcmp_enter_enhanced_OB_mode+0x20>
}
80003fae:	2c dd       	sub	sp,-204
80003fb0:	d8 02       	popm	pc
80003fb2:	00 00       	add	r0,r0
80003fb4:	80 00       	ld.sh	r0,r0[0x0]
80003fb6:	3e 90       	mov	r0,-23

80003fb8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003fb8:	d4 01       	pushm	lr
80003fba:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003fbe:	fe 78 b4 00 	mov	r8,-19456
80003fc2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003fc4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003fc8:	30 89       	mov	r9,8
80003fca:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003fcc:	30 19       	mov	r9,1
80003fce:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003fd0:	30 09       	mov	r9,0
80003fd2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003fd4:	30 5a       	mov	r10,5
80003fd6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003fd8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003fda:	30 7a       	mov	r10,7
80003fdc:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003fde:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003fe0:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003fe2:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003fe6:	30 9b       	mov	r11,9
80003fe8:	fa cc ff fe 	sub	r12,sp,-2
80003fec:	f0 1f 00 02 	mcall	80003ff4 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003ff0:	2c dd       	sub	sp,-204
80003ff2:	d8 02       	popm	pc
80003ff4:	80 00       	ld.sh	r0,r0[0x0]
80003ff6:	3e 90       	mov	r0,-23

80003ff8 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003ff8:	d4 01       	pushm	lr
80003ffa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003ffe:	fe 78 80 00 	mov	r8,-32768
80004002:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004004:	30 38       	mov	r8,3
80004006:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004008:	30 1b       	mov	r11,1
8000400a:	fa cc ff fe 	sub	r12,sp,-2
8000400e:	f0 1f 00 03 	mcall	80004018 <xcmp_opcode_not_supported+0x20>
}
80004012:	2c dd       	sub	sp,-204
80004014:	d8 02       	popm	pc
80004016:	00 00       	add	r0,r0
80004018:	80 00       	ld.sh	r0,r0[0x0]
8000401a:	3e 90       	mov	r0,-23

8000401c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
8000401c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
8000401e:	96 88       	ld.uh	r8,r11[0x0]
80004020:	e2 18 f0 00 	andl	r8,0xf000,COH
80004024:	e0 48 80 00 	cp.w	r8,32768
80004028:	c0 f0       	breq	80004046 <xcmp_exec_func+0x2a>
8000402a:	e0 48 b0 00 	cp.w	r8,45056
8000402e:	c1 20       	breq	80004052 <xcmp_exec_func+0x36>
80004030:	58 08       	cp.w	r8,0
80004032:	c1 51       	brne	8000405c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004034:	78 08       	ld.w	r8,r12[0x0]
80004036:	58 08       	cp.w	r8,0
80004038:	c0 40       	breq	80004040 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000403a:	16 9c       	mov	r12,r11
8000403c:	5d 18       	icall	r8
8000403e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004040:	f0 1f 00 08 	mcall	80004060 <xcmp_exec_func+0x44>
80004044:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004046:	78 18       	ld.w	r8,r12[0x4]
80004048:	58 08       	cp.w	r8,0
8000404a:	c0 90       	breq	8000405c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
8000404c:	16 9c       	mov	r12,r11
8000404e:	5d 18       	icall	r8
80004050:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004052:	78 28       	ld.w	r8,r12[0x8]
80004054:	58 08       	cp.w	r8,0
80004056:	c0 30       	breq	8000405c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004058:	16 9c       	mov	r12,r11
8000405a:	5d 18       	icall	r8
8000405c:	d8 02       	popm	pc
8000405e:	00 00       	add	r0,r0
80004060:	80 00       	ld.sh	r0,r0[0x0]
80004062:	3f f8       	mov	r8,-1

80004064 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004064:	d4 01       	pushm	lr
80004066:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000406a:	e0 68 04 09 	mov	r8,1033
8000406e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004070:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004074:	30 19       	mov	r9,1
80004076:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80004078:	30 09       	mov	r9,0
8000407a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
8000407c:	30 ca       	mov	r10,12
8000407e:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004080:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004082:	fb 69 00 08 	st.b	sp[8],r9
80004086:	fa c8 ff f7 	sub	r8,sp,-9
8000408a:	b0 89       	st.b	r8[0x0],r9
8000408c:	fa c8 ff f6 	sub	r8,sp,-10
80004090:	b0 89       	st.b	r8[0x0],r9
80004092:	fa c8 ff f5 	sub	r8,sp,-11
80004096:	b0 89       	st.b	r8[0x0],r9
80004098:	fa c8 ff f4 	sub	r8,sp,-12
8000409c:	b0 89       	st.b	r8[0x0],r9
8000409e:	fa c8 ff f3 	sub	r8,sp,-13
800040a2:	b0 89       	st.b	r8[0x0],r9
800040a4:	fa c8 ff f2 	sub	r8,sp,-14
800040a8:	b0 89       	st.b	r8[0x0],r9
800040aa:	fa c8 ff f1 	sub	r8,sp,-15
800040ae:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800040b0:	30 cb       	mov	r11,12
800040b2:	fa cc ff fe 	sub	r12,sp,-2
800040b6:	f0 1f 00 03 	mcall	800040c0 <xcmp_IdleTestTone+0x5c>
}
800040ba:	2c dd       	sub	sp,-204
800040bc:	d8 02       	popm	pc
800040be:	00 00       	add	r0,r0
800040c0:	80 00       	ld.sh	r0,r0[0x0]
800040c2:	3e 90       	mov	r0,-23

800040c4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800040c4:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
800040c6:	f0 1f 00 0d 	mcall	800040f8 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800040ca:	48 dc       	lddpc	r12,800040fc <xcmp_init+0x38>
800040cc:	f0 1f 00 0d 	mcall	80004100 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800040d0:	30 4b       	mov	r11,4
800040d2:	31 4c       	mov	r12,20
800040d4:	f0 1f 00 0c 	mcall	80004104 <xcmp_init+0x40>
800040d8:	48 c8       	lddpc	r8,80004108 <xcmp_init+0x44>
800040da:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800040dc:	30 09       	mov	r9,0
800040de:	1a d9       	st.w	--sp,r9
800040e0:	1a d9       	st.w	--sp,r9
800040e2:	1a d9       	st.w	--sp,r9
800040e4:	30 38       	mov	r8,3
800040e6:	e0 6a 01 80 	mov	r10,384
800040ea:	48 9b       	lddpc	r11,8000410c <xcmp_init+0x48>
800040ec:	48 9c       	lddpc	r12,80004110 <xcmp_init+0x4c>
800040ee:	f0 1f 00 0a 	mcall	80004114 <xcmp_init+0x50>
800040f2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
800040f4:	d8 02       	popm	pc
800040f6:	00 00       	add	r0,r0
800040f8:	80 00       	ld.sh	r0,r0[0x0]
800040fa:	44 a4       	lddsp	r4,sp[0x128]
800040fc:	80 00       	ld.sh	r0,r0[0x0]
800040fe:	42 14       	lddsp	r4,sp[0x84]
80004100:	80 00       	ld.sh	r0,r0[0x0]
80004102:	42 60       	lddsp	r0,sp[0x98]
80004104:	80 00       	ld.sh	r0,r0[0x0]
80004106:	57 f8       	stdsp	sp[0x1fc],r8
80004108:	00 00       	add	r0,r0
8000410a:	0a e8       	st.h	--r5,r8
8000410c:	80 00       	ld.sh	r0,r0[0x0]
8000410e:	cb e0       	breq	8000408a <xcmp_IdleTestTone+0x26>
80004110:	80 00       	ld.sh	r0,r0[0x0]
80004112:	41 18       	lddsp	r8,sp[0x44]
80004114:	80 00       	ld.sh	r0,r0[0x0]
80004116:	5e cc       	retvs	r12

80004118 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004118:	d4 31       	pushm	r0-r7,lr
8000411a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000411c:	4b 16       	lddpc	r6,800041e0 <xcmp_rx_process+0xc8>
8000411e:	30 05       	mov	r5,0
80004120:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004122:	4b 13       	lddpc	r3,800041e4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004124:	4b 12       	lddpc	r2,800041e8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004126:	4b 21       	lddpc	r1,800041ec <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004128:	4b 20       	lddpc	r0,800041f0 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000412a:	6c 0c       	ld.w	r12,r6[0x0]
8000412c:	0a 99       	mov	r9,r5
8000412e:	08 9a       	mov	r10,r4
80004130:	1a 9b       	mov	r11,sp
80004132:	f0 1f 00 31 	mcall	800041f4 <xcmp_rx_process+0xdc>
80004136:	58 1c       	cp.w	r12,1
80004138:	cf 91       	brne	8000412a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000413a:	40 0b       	lddsp	r11,sp[0x0]
8000413c:	58 0b       	cp.w	r11,0
8000413e:	cf 60       	breq	8000412a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004140:	96 0a       	ld.sh	r10,r11[0x0]
80004142:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004146:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000414a:	59 c8       	cp.w	r8,28
8000414c:	c1 e0       	breq	80004188 <xcmp_rx_process+0x70>
8000414e:	e0 89 00 07 	brgt	8000415c <xcmp_rx_process+0x44>
80004152:	58 e8       	cp.w	r8,14
80004154:	c0 e0       	breq	80004170 <xcmp_rx_process+0x58>
80004156:	58 f8       	cp.w	r8,15
80004158:	c2 41       	brne	800041a0 <xcmp_rx_process+0x88>
8000415a:	c0 f8       	rjmp	80004178 <xcmp_rx_process+0x60>
8000415c:	e0 48 01 09 	cp.w	r8,265
80004160:	c1 80       	breq	80004190 <xcmp_rx_process+0x78>
80004162:	e0 48 01 0a 	cp.w	r8,266
80004166:	c1 90       	breq	80004198 <xcmp_rx_process+0x80>
80004168:	e0 48 00 2c 	cp.w	r8,44
8000416c:	c1 a1       	brne	800041a0 <xcmp_rx_process+0x88>
8000416e:	c0 98       	rjmp	80004180 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004170:	4a 2c       	lddpc	r12,800041f8 <xcmp_rx_process+0xe0>
80004172:	f0 1f 00 23 	mcall	800041fc <xcmp_rx_process+0xe4>
					break;
80004176:	c2 f8       	rjmp	800041d4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004178:	4a 2c       	lddpc	r12,80004200 <xcmp_rx_process+0xe8>
8000417a:	f0 1f 00 21 	mcall	800041fc <xcmp_rx_process+0xe4>
					break;
8000417e:	c2 b8       	rjmp	800041d4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004180:	4a 1c       	lddpc	r12,80004204 <xcmp_rx_process+0xec>
80004182:	f0 1f 00 1f 	mcall	800041fc <xcmp_rx_process+0xe4>
					break;
80004186:	c2 78       	rjmp	800041d4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004188:	04 9c       	mov	r12,r2
8000418a:	f0 1f 00 1d 	mcall	800041fc <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000418e:	c2 38       	rjmp	800041d4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004190:	02 9c       	mov	r12,r1
80004192:	f0 1f 00 1b 	mcall	800041fc <xcmp_rx_process+0xe4>
					break;
80004196:	c1 f8       	rjmp	800041d4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004198:	00 9c       	mov	r12,r0
8000419a:	f0 1f 00 19 	mcall	800041fc <xcmp_rx_process+0xe4>
					break;
8000419e:	c1 b8       	rjmp	800041d4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800041a0:	12 98       	mov	r8,r9
800041a2:	e2 18 04 00 	andl	r8,0x400,COH
800041a6:	c0 70       	breq	800041b4 <xcmp_rx_process+0x9c>
800041a8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800041ac:	e0 48 00 68 	cp.w	r8,104
800041b0:	e0 8a 00 08 	brle	800041c0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800041b4:	e2 19 f0 00 	andl	r9,0xf000,COH
800041b8:	c0 e1       	brne	800041d4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800041ba:	f0 1f 00 14 	mcall	80004208 <xcmp_rx_process+0xf0>
800041be:	c0 b8       	rjmp	800041d4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800041c0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800041c4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800041c8:	49 19       	lddpc	r9,8000420c <xcmp_rx_process+0xf4>
800041ca:	72 08       	ld.w	r8,r9[0x0]
800041cc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800041d0:	f0 1f 00 0b 	mcall	800041fc <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800041d4:	66 0c       	ld.w	r12,r3[0x0]
800041d6:	40 0b       	lddsp	r11,sp[0x0]
800041d8:	f0 1f 00 0e 	mcall	80004210 <xcmp_rx_process+0xf8>
800041dc:	ca 7b       	rjmp	8000412a <xcmp_rx_process+0x12>
800041de:	00 00       	add	r0,r0
800041e0:	00 00       	add	r0,r0
800041e2:	0a e8       	st.h	--r5,r8
800041e4:	00 00       	add	r0,r0
800041e6:	0a 94       	mov	r4,r5
800041e8:	00 00       	add	r0,r0
800041ea:	0a f8       	st.b	--r5,r8
800041ec:	00 00       	add	r0,r0
800041ee:	0a ec       	st.h	--r5,r12
800041f0:	00 00       	add	r0,r0
800041f2:	0b 04       	ld.w	r4,r5++
800041f4:	80 00       	ld.sh	r0,r0[0x0]
800041f6:	54 94       	stdsp	sp[0x124],r4
800041f8:	00 00       	add	r0,r0
800041fa:	0b 1c       	ld.sh	r12,r5++
800041fc:	80 00       	ld.sh	r0,r0[0x0]
800041fe:	40 1c       	lddsp	r12,sp[0x4]
80004200:	00 00       	add	r0,r0
80004202:	0a dc       	st.w	--r5,r12
80004204:	00 00       	add	r0,r0
80004206:	0b 10       	ld.sh	r0,r5++
80004208:	80 00       	ld.sh	r0,r0[0x0]
8000420a:	3f f8       	mov	r8,-1
8000420c:	00 00       	add	r0,r0
8000420e:	41 08       	lddsp	r8,sp[0x40]
80004210:	80 00       	ld.sh	r0,r0[0x0]
80004212:	29 e0       	sub	r0,-98

80004214 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004214:	eb cd 40 90 	pushm	r4,r7,lr
80004218:	20 1d       	sub	sp,4
8000421a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000421e:	48 c8       	lddpc	r8,8000424c <xcmp_rx+0x38>
80004220:	70 0c       	ld.w	r12,r8[0x0]
80004222:	f0 1f 00 0c 	mcall	80004250 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004226:	c1 00       	breq	80004246 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004228:	fa c7 ff fc 	sub	r7,sp,-4
8000422c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000422e:	e0 6a 00 ca 	mov	r10,202
80004232:	08 9b       	mov	r11,r4
80004234:	f0 1f 00 08 	mcall	80004254 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004238:	48 88       	lddpc	r8,80004258 <xcmp_rx+0x44>
8000423a:	70 0c       	ld.w	r12,r8[0x0]
8000423c:	30 09       	mov	r9,0
8000423e:	12 9a       	mov	r10,r9
80004240:	1a 9b       	mov	r11,sp
80004242:	f0 1f 00 07 	mcall	8000425c <xcmp_rx+0x48>
	}	
}
80004246:	2f fd       	sub	sp,-4
80004248:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000424c:	00 00       	add	r0,r0
8000424e:	0a 94       	mov	r4,r5
80004250:	80 00       	ld.sh	r0,r0[0x0]
80004252:	2f 48       	sub	r8,-12
80004254:	80 00       	ld.sh	r0,r0[0x0]
80004256:	6b f0       	ld.w	r0,r5[0x7c]
80004258:	00 00       	add	r0,r0
8000425a:	0a e8       	st.h	--r5,r8
8000425c:	80 00       	ld.sh	r0,r0[0x0]
8000425e:	56 a0       	stdsp	sp[0x1a8],r0

80004260 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004260:	48 28       	lddpc	r8,80004268 <xnl_register_xcmp_func+0x8>
80004262:	91 0c       	st.w	r8[0x0],r12
}
80004264:	5e fc       	retal	r12
80004266:	00 00       	add	r0,r0
80004268:	00 00       	add	r0,r0
8000426a:	0b 48       	ld.w	r8,--r5

8000426c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000426c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000426e:	48 88       	lddpc	r8,8000428c <xnl_get_msg_ack_func+0x20>
80004270:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004272:	98 49       	ld.sh	r9,r12[0x8]
80004274:	f0 09 19 00 	cp.h	r9,r8
80004278:	c0 81       	brne	80004288 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000427a:	48 68       	lddpc	r8,80004290 <xnl_get_msg_ack_func+0x24>
8000427c:	70 0c       	ld.w	r12,r8[0x0]
8000427e:	30 09       	mov	r9,0
80004280:	12 9a       	mov	r10,r9
80004282:	12 9b       	mov	r11,r9
80004284:	f0 1f 00 04 	mcall	80004294 <xnl_get_msg_ack_func+0x28>
80004288:	d8 02       	popm	pc
8000428a:	00 00       	add	r0,r0
8000428c:	00 00       	add	r0,r0
8000428e:	0b 2e       	ld.uh	lr,r5++
80004290:	00 00       	add	r0,r0
80004292:	0b 28       	ld.uh	r8,r5++
80004294:	80 00       	ld.sh	r0,r0[0x0]
80004296:	56 a0       	stdsp	sp[0x1a8],r0

80004298 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004298:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000429a:	4a 86       	lddpc	r6,80004338 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000429c:	4a 82       	lddpc	r2,8000433c <xnl_tx_process+0xa4>
8000429e:	4a 94       	lddpc	r4,80004340 <xnl_tx_process+0xa8>
800042a0:	30 07       	mov	r7,0
800042a2:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800042a4:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800042a6:	4a 85       	lddpc	r5,80004344 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800042a8:	4a 83       	lddpc	r3,80004348 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800042aa:	6c 08       	ld.w	r8,r6[0x0]
800042ac:	58 08       	cp.w	r8,0
800042ae:	c0 40       	breq	800042b6 <xnl_tx_process+0x1e>
800042b0:	58 18       	cp.w	r8,1
800042b2:	cf d1       	brne	800042ac <xnl_tx_process+0x14>
800042b4:	c2 08       	rjmp	800042f4 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800042b6:	64 0c       	ld.w	r12,r2[0x0]
800042b8:	0e 99       	mov	r9,r7
800042ba:	02 9a       	mov	r10,r1
800042bc:	08 9b       	mov	r11,r4
800042be:	f0 1f 00 24 	mcall	8000434c <xnl_tx_process+0xb4>
800042c2:	58 1c       	cp.w	r12,1
800042c4:	cf 31       	brne	800042aa <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800042c6:	68 0c       	ld.w	r12,r4[0x0]
800042c8:	58 0c       	cp.w	r12,0
800042ca:	cf 00       	breq	800042aa <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800042cc:	98 28       	ld.sh	r8,r12[0x4]
800042ce:	e0 08 19 00 	cp.h	r8,r0
800042d2:	c0 41       	brne	800042da <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800042d4:	f0 1f 00 1f 	mcall	80004350 <xnl_tx_process+0xb8>
						break;
800042d8:	ce 9b       	rjmp	800042aa <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800042da:	f0 1f 00 1f 	mcall	80004354 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800042de:	30 18       	mov	r8,1
800042e0:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800042e2:	66 0c       	ld.w	r12,r3[0x0]
800042e4:	0e 99       	mov	r9,r7
800042e6:	0e 9a       	mov	r10,r7
800042e8:	0e 9b       	mov	r11,r7
800042ea:	f0 1f 00 19 	mcall	8000434c <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800042ee:	30 18       	mov	r8,1
800042f0:	8d 08       	st.w	r6[0x0],r8
800042f2:	cd cb       	rjmp	800042aa <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800042f4:	66 0c       	ld.w	r12,r3[0x0]
800042f6:	0e 99       	mov	r9,r7
800042f8:	36 4a       	mov	r10,100
800042fa:	0e 9b       	mov	r11,r7
800042fc:	f0 1f 00 14 	mcall	8000434c <xnl_tx_process+0xb4>
80004300:	58 1c       	cp.w	r12,1
80004302:	c0 81       	brne	80004312 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80004304:	49 58       	lddpc	r8,80004358 <xnl_tx_process+0xc0>
80004306:	70 0c       	ld.w	r12,r8[0x0]
80004308:	68 0b       	ld.w	r11,r4[0x0]
8000430a:	f0 1f 00 15 	mcall	8000435c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000430e:	8d 07       	st.w	r6[0x0],r7
80004310:	cc db       	rjmp	800042aa <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004312:	6a 08       	ld.w	r8,r5[0x0]
80004314:	58 38       	cp.w	r8,3
80004316:	e0 89 00 09 	brgt	80004328 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000431a:	68 0c       	ld.w	r12,r4[0x0]
8000431c:	f0 1f 00 0e 	mcall	80004354 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004320:	6a 08       	ld.w	r8,r5[0x0]
80004322:	2f f8       	sub	r8,-1
80004324:	8b 08       	st.w	r5[0x0],r8
80004326:	cc 2b       	rjmp	800042aa <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004328:	48 c8       	lddpc	r8,80004358 <xnl_tx_process+0xc0>
8000432a:	70 0c       	ld.w	r12,r8[0x0]
8000432c:	68 0b       	ld.w	r11,r4[0x0]
8000432e:	f0 1f 00 0c 	mcall	8000435c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004332:	8d 07       	st.w	r6[0x0],r7
80004334:	cb bb       	rjmp	800042aa <xnl_tx_process+0x12>
80004336:	00 00       	add	r0,r0
80004338:	00 00       	add	r0,r0
8000433a:	0b 44       	ld.w	r4,--r5
8000433c:	00 00       	add	r0,r0
8000433e:	0b 38       	ld.ub	r8,r5++
80004340:	00 00       	add	r0,r0
80004342:	0b 3c       	ld.ub	r12,r5++
80004344:	00 00       	add	r0,r0
80004346:	0b 40       	ld.w	r0,--r5
80004348:	00 00       	add	r0,r0
8000434a:	0b 28       	ld.uh	r8,r5++
8000434c:	80 00       	ld.sh	r0,r0[0x0]
8000434e:	54 94       	stdsp	sp[0x124],r4
80004350:	80 00       	ld.sh	r0,r0[0x0]
80004352:	53 24       	stdsp	sp[0xc8],r4
80004354:	80 00       	ld.sh	r0,r0[0x0]
80004356:	2a 00       	sub	r0,-96
80004358:	00 00       	add	r0,r0
8000435a:	0a 94       	mov	r4,r5
8000435c:	80 00       	ld.sh	r0,r0[0x0]
8000435e:	29 e0       	sub	r0,-98

80004360 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004360:	eb cd 40 fe 	pushm	r1-r7,lr
80004364:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004366:	49 26       	lddpc	r6,800043ac <xnl_rx_process+0x4c>
80004368:	30 05       	mov	r5,0
8000436a:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000436c:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000436e:	49 11       	lddpc	r1,800043b0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004370:	49 12       	lddpc	r2,800043b4 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004372:	6c 0c       	ld.w	r12,r6[0x0]
80004374:	0a 99       	mov	r9,r5
80004376:	08 9a       	mov	r10,r4
80004378:	1a 9b       	mov	r11,sp
8000437a:	f0 1f 00 10 	mcall	800043b8 <xnl_rx_process+0x58>
8000437e:	58 1c       	cp.w	r12,1
80004380:	cf 91       	brne	80004372 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004382:	40 0c       	lddsp	r12,sp[0x0]
80004384:	58 0c       	cp.w	r12,0
80004386:	cf 60       	breq	80004372 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004388:	98 28       	ld.sh	r8,r12[0x4]
8000438a:	e6 08 19 00 	cp.h	r8,r3
8000438e:	e0 8b 00 0a 	brhi	800043a2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004392:	5c 78       	castu.h	r8
80004394:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004398:	58 09       	cp.w	r9,0
8000439a:	c0 40       	breq	800043a2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
8000439c:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800043a0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800043a2:	62 0c       	ld.w	r12,r1[0x0]
800043a4:	40 0b       	lddsp	r11,sp[0x0]
800043a6:	f0 1f 00 06 	mcall	800043bc <xnl_rx_process+0x5c>
800043aa:	ce 4b       	rjmp	80004372 <xnl_rx_process+0x12>
800043ac:	00 00       	add	r0,r0
800043ae:	0a b0       	st.h	r5++,r0
800043b0:	00 00       	add	r0,r0
800043b2:	0a 94       	mov	r4,r5
800043b4:	00 00       	add	r0,r0
800043b6:	04 f4       	st.b	--r2,r4
800043b8:	80 00       	ld.sh	r0,r0[0x0]
800043ba:	54 94       	stdsp	sp[0x124],r4
800043bc:	80 00       	ld.sh	r0,r0[0x0]
800043be:	29 e0       	sub	r0,-98

800043c0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800043c0:	eb cd 40 c0 	pushm	r6-r7,lr
800043c4:	20 1d       	sub	sp,4
800043c6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800043c8:	98 39       	ld.sh	r9,r12[0x6]
800043ca:	3f f8       	mov	r8,-1
800043cc:	f0 09 19 00 	cp.h	r9,r8
800043d0:	c0 a1       	brne	800043e4 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800043d2:	4a e9       	lddpc	r9,80004488 <xnl_tx+0xc8>
800043d4:	13 88       	ld.ub	r8,r9[0x0]
800043d6:	2f f8       	sub	r8,-1
800043d8:	5c 58       	castu.b	r8
800043da:	b2 88       	st.b	r9[0x0],r8
800043dc:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800043e0:	a9 a8       	sbr	r8,0x8
800043e2:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800043e4:	8c 49       	ld.sh	r9,r6[0x8]
800043e6:	3f f8       	mov	r8,-1
800043e8:	f0 09 19 00 	cp.h	r9,r8
800043ec:	c0 41       	brne	800043f4 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800043ee:	4a 88       	lddpc	r8,8000448c <xnl_tx+0xcc>
800043f0:	90 18       	ld.sh	r8,r8[0x2]
800043f2:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800043f4:	8c 59       	ld.sh	r9,r6[0xa]
800043f6:	3f f8       	mov	r8,-1
800043f8:	f0 09 19 00 	cp.h	r9,r8
800043fc:	c0 41       	brne	80004404 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800043fe:	4a 48       	lddpc	r8,8000448c <xnl_tx+0xcc>
80004400:	90 28       	ld.sh	r8,r8[0x4]
80004402:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004404:	8c 69       	ld.sh	r9,r6[0xc]
80004406:	3f f8       	mov	r8,-1
80004408:	f0 09 19 00 	cp.h	r9,r8
8000440c:	c0 e1       	brne	80004428 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000440e:	4a 08       	lddpc	r8,8000448c <xnl_tx+0xcc>
80004410:	90 49       	ld.sh	r9,r8[0x8]
80004412:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004414:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004416:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004418:	90 49       	ld.sh	r9,r8[0x8]
8000441a:	e0 19 ff 00 	andl	r9,0xff00
8000441e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004422:	f3 e8 10 08 	or	r8,r9,r8
80004426:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004428:	0d 98       	ld.ub	r8,r6[0x1]
8000442a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000442c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004430:	10 0c       	add	r12,r8
80004432:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004434:	58 0c       	cp.w	r12,0
80004436:	e0 89 00 04 	brgt	8000443e <xnl_tx+0x7e>
8000443a:	30 09       	mov	r9,0
8000443c:	c0 d8       	rjmp	80004456 <xnl_tx+0x96>
8000443e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004442:	2f ec       	sub	r12,-2
80004444:	30 09       	mov	r9,0
80004446:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004448:	15 1b       	ld.sh	r11,r10++
8000444a:	f6 09 00 09 	add	r9,r11,r9
8000444e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004450:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004452:	18 38       	cp.w	r8,r12
80004454:	cf a1       	brne	80004448 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004456:	5c 39       	neg	r9
80004458:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000445a:	48 e8       	lddpc	r8,80004490 <xnl_tx+0xd0>
8000445c:	70 0c       	ld.w	r12,r8[0x0]
8000445e:	f0 1f 00 0e 	mcall	80004494 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004462:	c1 00       	breq	80004482 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004464:	fa c7 ff fc 	sub	r7,sp,-4
80004468:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000446a:	e0 6a 01 00 	mov	r10,256
8000446e:	0c 9b       	mov	r11,r6
80004470:	f0 1f 00 0a 	mcall	80004498 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004474:	48 a8       	lddpc	r8,8000449c <xnl_tx+0xdc>
80004476:	70 0c       	ld.w	r12,r8[0x0]
80004478:	30 09       	mov	r9,0
8000447a:	12 9a       	mov	r10,r9
8000447c:	1a 9b       	mov	r11,sp
8000447e:	f0 1f 00 09 	mcall	800044a0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004482:	2f fd       	sub	sp,-4
80004484:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004488:	00 00       	add	r0,r0
8000448a:	0b 2c       	ld.uh	r12,r5++
8000448c:	00 00       	add	r0,r0
8000448e:	0b 2e       	ld.uh	lr,r5++
80004490:	00 00       	add	r0,r0
80004492:	0a 94       	mov	r4,r5
80004494:	80 00       	ld.sh	r0,r0[0x0]
80004496:	2f 48       	sub	r8,-12
80004498:	80 00       	ld.sh	r0,r0[0x0]
8000449a:	6b f0       	ld.w	r0,r5[0x7c]
8000449c:	00 00       	add	r0,r0
8000449e:	0b 38       	ld.ub	r8,r5++
800044a0:	80 00       	ld.sh	r0,r0[0x0]
800044a2:	56 a0       	stdsp	sp[0x1a8],r0

800044a4 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800044a4:	eb cd 40 80 	pushm	r7,lr
800044a8:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
800044ac:	f0 1f 00 27 	mcall	80004548 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
800044b0:	30 09       	mov	r9,0
800044b2:	4a 78       	lddpc	r8,8000454c <xnl_init+0xa8>
800044b4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800044b6:	30 0b       	mov	r11,0
800044b8:	30 1c       	mov	r12,1
800044ba:	f0 1f 00 26 	mcall	80004550 <xnl_init+0xac>
800044be:	4a 68       	lddpc	r8,80004554 <xnl_init+0xb0>
800044c0:	91 0c       	st.w	r8[0x0],r12
800044c2:	70 08       	ld.w	r8,r8[0x0]
800044c4:	58 08       	cp.w	r8,0
800044c6:	c0 80       	breq	800044d6 <xnl_init+0x32>
800044c8:	4a 38       	lddpc	r8,80004554 <xnl_init+0xb0>
800044ca:	70 0c       	ld.w	r12,r8[0x0]
800044cc:	30 09       	mov	r9,0
800044ce:	12 9a       	mov	r10,r9
800044d0:	12 9b       	mov	r11,r9
800044d2:	f0 1f 00 22 	mcall	80004558 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800044d6:	30 4b       	mov	r11,4
800044d8:	31 4c       	mov	r12,20
800044da:	f0 1f 00 1e 	mcall	80004550 <xnl_init+0xac>
800044de:	4a 08       	lddpc	r8,8000455c <xnl_init+0xb8>
800044e0:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800044e2:	30 07       	mov	r7,0
800044e4:	1a d7       	st.w	--sp,r7
800044e6:	1a d7       	st.w	--sp,r7
800044e8:	1a d7       	st.w	--sp,r7
800044ea:	30 38       	mov	r8,3
800044ec:	0e 99       	mov	r9,r7
800044ee:	e0 6a 02 00 	mov	r10,512
800044f2:	49 cb       	lddpc	r11,80004560 <xnl_init+0xbc>
800044f4:	49 cc       	lddpc	r12,80004564 <xnl_init+0xc0>
800044f6:	f0 1f 00 1d 	mcall	80004568 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800044fa:	1a d7       	st.w	--sp,r7
800044fc:	1a d7       	st.w	--sp,r7
800044fe:	1a d7       	st.w	--sp,r7
80004500:	30 38       	mov	r8,3
80004502:	0e 99       	mov	r9,r7
80004504:	e0 6a 03 20 	mov	r10,800
80004508:	49 9b       	lddpc	r11,8000456c <xnl_init+0xc8>
8000450a:	49 ac       	lddpc	r12,80004570 <xnl_init+0xcc>
8000450c:	f0 1f 00 17 	mcall	80004568 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004510:	e0 68 40 0e 	mov	r8,16398
80004514:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004518:	3f f8       	mov	r8,-1
8000451a:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000451e:	30 38       	mov	r8,3
80004520:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004524:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004528:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000452c:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004530:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004534:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004538:	fa cc ff e8 	sub	r12,sp,-24
8000453c:	f0 1f 00 0e 	mcall	80004574 <xnl_init+0xd0>
80004540:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80004542:	2c 0d       	sub	sp,-256
80004544:	e3 cd 80 80 	ldm	sp++,r7,pc
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	2f 70       	sub	r0,-9
8000454c:	00 00       	add	r0,r0
8000454e:	0b 2e       	ld.uh	lr,r5++
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	57 f8       	stdsp	sp[0x1fc],r8
80004554:	00 00       	add	r0,r0
80004556:	0b 28       	ld.uh	r8,r5++
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	56 a0       	stdsp	sp[0x1a8],r0
8000455c:	00 00       	add	r0,r0
8000455e:	0b 38       	ld.ub	r8,r5++
80004560:	80 00       	ld.sh	r0,r0[0x0]
80004562:	cb e8       	rjmp	800046de <xnl_device_auth_reply_func+0x106>
80004564:	80 00       	ld.sh	r0,r0[0x0]
80004566:	43 60       	lddsp	r0,sp[0xd8]
80004568:	80 00       	ld.sh	r0,r0[0x0]
8000456a:	5e cc       	retvs	r12
8000456c:	80 00       	ld.sh	r0,r0[0x0]
8000456e:	c4 00       	breq	800045ee <xnl_device_auth_reply_func+0x16>
80004570:	80 00       	ld.sh	r0,r0[0x0]
80004572:	42 98       	lddsp	r8,sp[0xa4]
80004574:	80 00       	ld.sh	r0,r0[0x0]
80004576:	43 c0       	lddsp	r0,sp[0xf0]

80004578 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004578:	eb cd 40 80 	pushm	r7,lr
8000457c:	fa cd 01 00 	sub	sp,sp,256
80004580:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004582:	e0 68 40 0e 	mov	r8,16398
80004586:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004588:	3f f8       	mov	r8,-1
8000458a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000458c:	30 c8       	mov	r8,12
8000458e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004590:	98 38       	ld.sh	r8,r12[0x6]
80004592:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004594:	98 58       	ld.sh	r8,r12[0xa]
80004596:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004598:	98 48       	ld.sh	r8,r12[0x8]
8000459a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000459c:	98 68       	ld.sh	r8,r12[0xc]
8000459e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800045a0:	30 08       	mov	r8,0
800045a2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800045a4:	1a 9c       	mov	r12,sp
800045a6:	f0 1f 00 0a 	mcall	800045cc <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800045aa:	fa cd 00 cc 	sub	sp,sp,204
800045ae:	e0 6a 00 ca 	mov	r10,202
800045b2:	ee cb ff f0 	sub	r11,r7,-16
800045b6:	1a 9c       	mov	r12,sp
800045b8:	f0 1f 00 06 	mcall	800045d0 <xnl_data_msg_func+0x58>
800045bc:	48 68       	lddpc	r8,800045d4 <xnl_data_msg_func+0x5c>
800045be:	70 08       	ld.w	r8,r8[0x0]
800045c0:	5d 18       	icall	r8
800045c2:	fa cd ff 34 	sub	sp,sp,-204
}
800045c6:	2c 0d       	sub	sp,-256
800045c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800045cc:	80 00       	ld.sh	r0,r0[0x0]
800045ce:	43 c0       	lddsp	r0,sp[0xf0]
800045d0:	80 00       	ld.sh	r0,r0[0x0]
800045d2:	6b f0       	ld.w	r0,r5[0x7c]
800045d4:	00 00       	add	r0,r0
800045d6:	0b 48       	ld.w	r8,--r5

800045d8 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800045d8:	d4 21       	pushm	r4-r7,lr
800045da:	fa cd 01 00 	sub	sp,sp,256
800045de:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800045e0:	4c 28       	lddpc	r8,800046e8 <xnl_device_auth_reply_func+0x110>
800045e2:	11 88       	ld.ub	r8,r8[0x0]
800045e4:	58 08       	cp.w	r8,0
800045e6:	e0 81 00 7f 	brne	800046e4 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800045ea:	4c 18       	lddpc	r8,800046ec <xnl_device_auth_reply_func+0x114>
800045ec:	70 0c       	ld.w	r12,r8[0x0]
800045ee:	30 09       	mov	r9,0
800045f0:	12 9a       	mov	r10,r9
800045f2:	12 9b       	mov	r11,r9
800045f4:	f0 1f 00 3f 	mcall	800046f0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800045f8:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800045fc:	4b b8       	lddpc	r8,800046e8 <xnl_device_auth_reply_func+0x110>
800045fe:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004600:	ef 39 00 12 	ld.ub	r9,r7[18]
80004604:	ef 38 00 13 	ld.ub	r8,r7[19]
80004608:	b1 68       	lsl	r8,0x10
8000460a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000460e:	ef 38 00 15 	ld.ub	r8,r7[21]
80004612:	f3 e8 10 08 	or	r8,r9,r8
80004616:	ef 39 00 14 	ld.ub	r9,r7[20]
8000461a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000461e:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004622:	ef 38 00 17 	ld.ub	r8,r7[23]
80004626:	b1 68       	lsl	r8,0x10
80004628:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000462c:	ef 38 00 19 	ld.ub	r8,r7[25]
80004630:	f5 e8 10 08 	or	r8,r10,r8
80004634:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004638:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000463c:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000463e:	e0 64 79 b9 	mov	r4,31161
80004642:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004646:	e0 65 45 07 	mov	r5,17671
8000464a:	ea 15 8a bd 	orh	r5,0x8abd
8000464e:	e0 66 f9 3d 	mov	r6,63805
80004652:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004656:	e0 6e b8 cf 	mov	lr,47311
8000465a:	ea 1e 36 83 	orh	lr,0x3683
8000465e:	e0 67 aa 1c 	mov	r7,43548
80004662:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004666:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004668:	f4 08 00 0c 	add	r12,r10,r8
8000466c:	f0 0b 15 04 	lsl	r11,r8,0x4
80004670:	0a 0b       	add	r11,r5
80004672:	f9 eb 20 0b 	eor	r11,r12,r11
80004676:	f0 0c 16 05 	lsr	r12,r8,0x5
8000467a:	0c 0c       	add	r12,r6
8000467c:	18 5b       	eor	r11,r12
8000467e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004680:	f2 0c 15 04 	lsl	r12,r9,0x4
80004684:	1c 0c       	add	r12,lr
80004686:	f2 0b 16 05 	lsr	r11,r9,0x5
8000468a:	0e 0b       	add	r11,r7
8000468c:	f9 eb 20 0b 	eor	r11,r12,r11
80004690:	f2 0a 00 0c 	add	r12,r9,r10
80004694:	18 5b       	eor	r11,r12
80004696:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004698:	e0 6b 37 20 	mov	r11,14112
8000469c:	ea 1b c6 ef 	orh	r11,0xc6ef
800046a0:	16 3a       	cp.w	r10,r11
800046a2:	ce 21       	brne	80004666 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800046a4:	e0 6a 40 1a 	mov	r10,16410
800046a8:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046aa:	3f fa       	mov	r10,-1
800046ac:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800046ae:	30 6b       	mov	r11,6
800046b0:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046b2:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046b4:	48 db       	lddpc	r11,800046e8 <xnl_device_auth_reply_func+0x110>
800046b6:	96 1c       	ld.sh	r12,r11[0x2]
800046b8:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800046ba:	96 2b       	ld.sh	r11,r11[0x4]
800046bc:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046be:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800046c0:	30 ca       	mov	r10,12
800046c2:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800046c4:	30 0a       	mov	r10,0
800046c6:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800046ca:	30 7a       	mov	r10,7
800046cc:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800046d0:	30 2a       	mov	r10,2
800046d2:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800046d6:	fa ca ff ec 	sub	r10,sp,-20
800046da:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800046dc:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800046de:	1a 9c       	mov	r12,sp
800046e0:	f0 1f 00 05 	mcall	800046f4 <xnl_device_auth_reply_func+0x11c>
}
800046e4:	2c 0d       	sub	sp,-256
800046e6:	d8 22       	popm	r4-r7,pc
800046e8:	00 00       	add	r0,r0
800046ea:	0b 2e       	ld.uh	lr,r5++
800046ec:	00 00       	add	r0,r0
800046ee:	0b 28       	ld.uh	r8,r5++
800046f0:	80 00       	ld.sh	r0,r0[0x0]
800046f2:	56 a0       	stdsp	sp[0x1a8],r0
800046f4:	80 00       	ld.sh	r0,r0[0x0]
800046f6:	43 c0       	lddsp	r0,sp[0xf0]

800046f8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800046f8:	eb cd 40 80 	pushm	r7,lr
800046fc:	fa cd 01 00 	sub	sp,sp,256
80004700:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004702:	49 28       	lddpc	r8,80004748 <xnl_master_status_brdcst_func+0x50>
80004704:	11 88       	ld.ub	r8,r8[0x0]
80004706:	58 08       	cp.w	r8,0
80004708:	c1 c1       	brne	80004740 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000470a:	49 18       	lddpc	r8,8000474c <xnl_master_status_brdcst_func+0x54>
8000470c:	70 0c       	ld.w	r12,r8[0x0]
8000470e:	30 09       	mov	r9,0
80004710:	12 9a       	mov	r10,r9
80004712:	12 9b       	mov	r11,r9
80004714:	f0 1f 00 0f 	mcall	80004750 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004718:	8e 58       	ld.sh	r8,r7[0xa]
8000471a:	48 c9       	lddpc	r9,80004748 <xnl_master_status_brdcst_func+0x50>
8000471c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000471e:	e0 68 40 0e 	mov	r8,16398
80004722:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004724:	3f f8       	mov	r8,-1
80004726:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004728:	30 4a       	mov	r10,4
8000472a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000472c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000472e:	92 19       	ld.sh	r9,r9[0x2]
80004730:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004732:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004734:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004736:	30 08       	mov	r8,0
80004738:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000473a:	1a 9c       	mov	r12,sp
8000473c:	f0 1f 00 06 	mcall	80004754 <xnl_master_status_brdcst_func+0x5c>
}
80004740:	2c 0d       	sub	sp,-256
80004742:	e3 cd 80 80 	ldm	sp++,r7,pc
80004746:	00 00       	add	r0,r0
80004748:	00 00       	add	r0,r0
8000474a:	0b 2e       	ld.uh	lr,r5++
8000474c:	00 00       	add	r0,r0
8000474e:	0b 28       	ld.uh	r8,r5++
80004750:	80 00       	ld.sh	r0,r0[0x0]
80004752:	56 a0       	stdsp	sp[0x1a8],r0
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	43 c0       	lddsp	r0,sp[0xf0]

80004758 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004758:	eb cd 40 80 	pushm	r7,lr
8000475c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000475e:	49 38       	lddpc	r8,800047a8 <xnl_device_conn_reply_func+0x50>
80004760:	70 0c       	ld.w	r12,r8[0x0]
80004762:	30 09       	mov	r9,0
80004764:	12 9a       	mov	r10,r9
80004766:	12 9b       	mov	r11,r9
80004768:	f0 1f 00 11 	mcall	800047ac <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000476c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004770:	10 99       	mov	r9,r8
80004772:	e2 19 ff 00 	andl	r9,0xff00,COH
80004776:	e0 49 01 00 	cp.w	r9,256
8000477a:	c0 60       	breq	80004786 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000477c:	0e 9c       	mov	r12,r7
8000477e:	f0 1f 00 0d 	mcall	800047b0 <xnl_device_conn_reply_func+0x58>
80004782:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004786:	a9 68       	lsl	r8,0x8
80004788:	48 b9       	lddpc	r9,800047b4 <xnl_device_conn_reply_func+0x5c>
8000478a:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
8000478c:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004790:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004792:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004796:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004798:	30 18       	mov	r8,1
8000479a:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
8000479c:	48 7c       	lddpc	r12,800047b8 <xnl_device_conn_reply_func+0x60>
8000479e:	f0 1f 00 08 	mcall	800047bc <xnl_device_conn_reply_func+0x64>
800047a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800047a6:	00 00       	add	r0,r0
800047a8:	00 00       	add	r0,r0
800047aa:	0b 28       	ld.uh	r8,r5++
800047ac:	80 00       	ld.sh	r0,r0[0x0]
800047ae:	56 a0       	stdsp	sp[0x1a8],r0
800047b0:	80 00       	ld.sh	r0,r0[0x0]
800047b2:	46 f8       	lddsp	r8,sp[0x1bc]
800047b4:	00 00       	add	r0,r0
800047b6:	0b 2e       	ld.uh	lr,r5++
800047b8:	80 00       	ld.sh	r0,r0[0x0]
800047ba:	cb f0       	breq	80004738 <xnl_master_status_brdcst_func+0x40>
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	62 90       	ld.w	r0,r1[0x24]

800047c0 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800047c0:	fe 78 0c 00 	mov	r8,-62464
800047c4:	e0 69 03 07 	mov	r9,775
800047c8:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800047ca:	30 49       	mov	r9,4
800047cc:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800047ce:	71 59       	ld.w	r9,r8[0x54]
800047d0:	e2 19 00 80 	andl	r9,0x80,COH
800047d4:	cf d0       	breq	800047ce <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800047d6:	fe 78 0c 00 	mov	r8,-62464
800047da:	30 59       	mov	r9,5
800047dc:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800047de:	e0 69 01 0d 	mov	r9,269
800047e2:	ea 19 10 07 	orh	r9,0x1007
800047e6:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800047e8:	71 59       	ld.w	r9,r8[0x54]
800047ea:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800047ee:	cf d0       	breq	800047e8 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800047f0:	fe 78 0c 00 	mov	r8,-62464
800047f4:	fc 19 00 80 	movh	r9,0x80
800047f8:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800047fa:	34 0a       	mov	r10,64
800047fc:	fe 69 14 00 	mov	r9,-125952
80004800:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004802:	30 69       	mov	r9,6
80004804:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004806:	30 19       	mov	r9,1
80004808:	fe 68 10 00 	mov	r8,-126976
8000480c:	91 19       	st.w	r8[0x4],r9
}
8000480e:	5e fc       	retal	r12

80004810 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80004810:	eb cd 40 c0 	pushm	r6-r7,lr
80004814:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80004816:	f0 1f 00 1a 	mcall	8000487c <rtc_init+0x6c>
8000481a:	49 a8       	lddpc	r8,80004880 <rtc_init+0x70>
8000481c:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
8000481e:	70 08       	ld.w	r8,r8[0x0]
80004820:	58 08       	cp.w	r8,0
80004822:	c0 31       	brne	80004828 <rtc_init+0x18>
80004824:	30 3c       	mov	r12,3
80004826:	c2 78       	rjmp	80004874 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80004828:	49 66       	lddpc	r6,80004880 <rtc_init+0x70>
8000482a:	6c 0c       	ld.w	r12,r6[0x0]
8000482c:	30 09       	mov	r9,0
8000482e:	3f fa       	mov	r10,-1
80004830:	12 9b       	mov	r11,r9
80004832:	f0 1f 00 15 	mcall	80004884 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80004836:	30 2b       	mov	r11,2
80004838:	49 4c       	lddpc	r12,80004888 <rtc_init+0x78>
8000483a:	f0 1f 00 15 	mcall	8000488c <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
8000483e:	e0 68 36 00 	mov	r8,13824
80004842:	ea 18 01 6e 	orh	r8,0x16e
80004846:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80004848:	e2 78 0d 40 	mov	r8,200000
8000484c:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
8000484e:	35 18       	mov	r8,81
80004850:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80004854:	1a 9b       	mov	r11,sp
80004856:	fe 7c 2c 00 	mov	r12,-54272
8000485a:	f0 1f 00 0e 	mcall	80004890 <rtc_init+0x80>
8000485e:	48 e7       	lddpc	r7,80004894 <rtc_init+0x84>
80004860:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80004862:	6c 0c       	ld.w	r12,r6[0x0]
80004864:	30 09       	mov	r9,0
80004866:	12 9a       	mov	r10,r9
80004868:	12 9b       	mov	r11,r9
8000486a:	f0 1f 00 0c 	mcall	80004898 <rtc_init+0x88>
8000486e:	6e 08       	ld.w	r8,r7[0x0]
80004870:	58 08       	cp.w	r8,0
80004872:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80004874:	2f dd       	sub	sp,-12
80004876:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000487a:	00 00       	add	r0,r0
8000487c:	80 00       	ld.sh	r0,r0[0x0]
8000487e:	57 a0       	stdsp	sp[0x1e8],r0
80004880:	00 00       	add	r0,r0
80004882:	0b 50       	ld.sh	r0,--r5
80004884:	80 00       	ld.sh	r0,r0[0x0]
80004886:	54 94       	stdsp	sp[0x124],r4
80004888:	80 00       	ld.sh	r0,r0[0x0]
8000488a:	cc 04       	brge	8000480a <local_start_pll0+0x4a>
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	67 28       	ld.w	r8,r3[0x48]
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	4d 20       	lddpc	r0,800049d8 <INTC_register_interrupt+0x7c>
80004894:	00 00       	add	r0,r0
80004896:	0b 4c       	ld.w	r12,--r5
80004898:	80 00       	ld.sh	r0,r0[0x0]
8000489a:	56 a0       	stdsp	sp[0x1a8],r0

8000489c <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
8000489c:	fe 78 10 00 	mov	r8,-61440
800048a0:	fc 19 00 10 	movh	r9,0x10
800048a4:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
800048a6:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
800048a8:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
800048aa:	30 39       	mov	r9,3
800048ac:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
800048b0:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
800048b4:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
800048b8:	fe 78 38 00 	mov	r8,-51200
800048bc:	30 49       	mov	r9,4
800048be:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
800048c2:	e0 69 91 0d 	mov	r9,37133
800048c6:	ea 19 00 52 	orh	r9,0x52
800048ca:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800048cc:	32 09       	mov	r9,32
800048ce:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800048d0:	30 59       	mov	r9,5
800048d2:	91 09       	st.w	r8[0x0],r9
}
800048d4:	5e fc       	retal	r12
800048d6:	d7 03       	nop

800048d8 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
800048d8:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
800048da:	30 2a       	mov	r10,2
800048dc:	e0 6b 01 c1 	mov	r11,449
800048e0:	48 ec       	lddpc	r12,80004918 <tc_init+0x40>
800048e2:	f0 1f 00 0f 	mcall	8000491c <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
800048e6:	48 fb       	lddpc	r11,80004920 <tc_init+0x48>
800048e8:	fe 7c 38 00 	mov	r12,-51200
800048ec:	f0 1f 00 0e 	mcall	80004924 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
800048f0:	e0 6a 75 30 	mov	r10,30000
800048f4:	30 1b       	mov	r11,1
800048f6:	fe 7c 38 00 	mov	r12,-51200
800048fa:	f0 1f 00 0c 	mcall	80004928 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
800048fe:	48 ca       	lddpc	r10,8000492c <tc_init+0x54>
80004900:	30 1b       	mov	r11,1
80004902:	fe 7c 38 00 	mov	r12,-51200
80004906:	f0 1f 00 0b 	mcall	80004930 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
8000490a:	30 1b       	mov	r11,1
8000490c:	fe 7c 38 00 	mov	r12,-51200
80004910:	f0 1f 00 09 	mcall	80004934 <tc_init+0x5c>
80004914:	d8 02       	popm	pc
80004916:	00 00       	add	r0,r0
80004918:	80 00       	ld.sh	r0,r0[0x0]
8000491a:	49 38       	lddpc	r8,80004964 <INTC_register_interrupt+0x8>
8000491c:	80 00       	ld.sh	r0,r0[0x0]
8000491e:	49 5c       	lddpc	r12,80004970 <INTC_register_interrupt+0x14>
80004920:	80 00       	ld.sh	r0,r0[0x0]
80004922:	cc 18       	rjmp	80004aa4 <tc_init_waveform+0x3c>
80004924:	80 00       	ld.sh	r0,r0[0x0]
80004926:	4a 68       	lddpc	r8,800049bc <INTC_register_interrupt+0x60>
80004928:	80 00       	ld.sh	r0,r0[0x0]
8000492a:	4b 28       	lddpc	r8,800049f0 <INTC_init_interrupts+0x14>
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	cc 14       	brge	800048b0 <local_start_timer+0x14>
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	4b 5c       	lddpc	r12,80004a04 <INTC_init_interrupts+0x28>
80004934:	80 00       	ld.sh	r0,r0[0x0]
80004936:	4b 04       	lddpc	r4,800049f4 <INTC_init_interrupts+0x18>

80004938 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004938:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
8000493a:	48 68       	lddpc	r8,80004950 <_tc_interrupt+0x18>
8000493c:	70 09       	ld.w	r9,r8[0x0]
8000493e:	2f f9       	sub	r9,-1
80004940:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004942:	30 1b       	mov	r11,1
80004944:	fe 7c 38 00 	mov	r12,-51200
80004948:	f0 1f 00 03 	mcall	80004954 <_tc_interrupt+0x1c>
	
}
8000494c:	d4 02       	popm	lr
8000494e:	d6 03       	rete
80004950:	00 00       	add	r0,r0
80004952:	0b 54       	ld.sh	r4,--r5
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	4b 16       	lddpc	r6,80004a18 <INTC_init_interrupts+0x3c>

80004958 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004958:	c0 08       	rjmp	80004958 <_unhandled_interrupt>
8000495a:	d7 03       	nop

8000495c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000495c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004960:	49 99       	lddpc	r9,800049c4 <INTC_register_interrupt+0x68>
80004962:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004966:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000496a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000496c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004970:	58 0a       	cp.w	r10,0
80004972:	c0 91       	brne	80004984 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004974:	49 59       	lddpc	r9,800049c8 <INTC_register_interrupt+0x6c>
80004976:	49 6a       	lddpc	r10,800049cc <INTC_register_interrupt+0x70>
80004978:	12 1a       	sub	r10,r9
8000497a:	fe 79 08 00 	mov	r9,-63488
8000497e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004982:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004984:	58 1a       	cp.w	r10,1
80004986:	c0 a1       	brne	8000499a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004988:	49 09       	lddpc	r9,800049c8 <INTC_register_interrupt+0x6c>
8000498a:	49 2a       	lddpc	r10,800049d0 <INTC_register_interrupt+0x74>
8000498c:	12 1a       	sub	r10,r9
8000498e:	bf aa       	sbr	r10,0x1e
80004990:	fe 79 08 00 	mov	r9,-63488
80004994:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004998:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000499a:	58 2a       	cp.w	r10,2
8000499c:	c0 a1       	brne	800049b0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000499e:	48 b9       	lddpc	r9,800049c8 <INTC_register_interrupt+0x6c>
800049a0:	48 da       	lddpc	r10,800049d4 <INTC_register_interrupt+0x78>
800049a2:	12 1a       	sub	r10,r9
800049a4:	bf ba       	sbr	r10,0x1f
800049a6:	fe 79 08 00 	mov	r9,-63488
800049aa:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800049ae:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800049b0:	48 69       	lddpc	r9,800049c8 <INTC_register_interrupt+0x6c>
800049b2:	48 aa       	lddpc	r10,800049d8 <INTC_register_interrupt+0x7c>
800049b4:	12 1a       	sub	r10,r9
800049b6:	ea 1a c0 00 	orh	r10,0xc000
800049ba:	fe 79 08 00 	mov	r9,-63488
800049be:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800049c2:	5e fc       	retal	r12
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	cc 20       	breq	8000494a <_tc_interrupt+0x12>
800049c8:	80 00       	ld.sh	r0,r0[0x0]
800049ca:	c2 00       	breq	80004a0a <INTC_init_interrupts+0x2e>
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	c3 04       	brge	80004a2e <INTC_init_interrupts+0x52>
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	c3 12       	brcc	80004a34 <_get_interrupt_handler+0x4>
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	c3 20       	breq	80004a3a <_get_interrupt_handler+0xa>
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	c3 2e       	rcall	8000463e <xnl_device_auth_reply_func+0x66>

800049dc <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800049dc:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800049de:	49 18       	lddpc	r8,80004a20 <INTC_init_interrupts+0x44>
800049e0:	e3 b8 00 01 	mtsr	0x4,r8
800049e4:	49 0e       	lddpc	lr,80004a24 <INTC_init_interrupts+0x48>
800049e6:	30 07       	mov	r7,0
800049e8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800049ea:	49 0c       	lddpc	r12,80004a28 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800049ec:	49 05       	lddpc	r5,80004a2c <INTC_init_interrupts+0x50>
800049ee:	10 15       	sub	r5,r8
800049f0:	fe 76 08 00 	mov	r6,-63488
800049f4:	c1 08       	rjmp	80004a14 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800049f6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800049f8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800049fa:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800049fc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004a00:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004a02:	10 3a       	cp.w	r10,r8
80004a04:	fe 9b ff fc 	brhi	800049fc <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004a08:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004a0c:	2f f7       	sub	r7,-1
80004a0e:	2f 8e       	sub	lr,-8
80004a10:	59 37       	cp.w	r7,19
80004a12:	c0 50       	breq	80004a1c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004a14:	7c 08       	ld.w	r8,lr[0x0]
80004a16:	58 08       	cp.w	r8,0
80004a18:	ce f1       	brne	800049f6 <INTC_init_interrupts+0x1a>
80004a1a:	cf 7b       	rjmp	80004a08 <INTC_init_interrupts+0x2c>
80004a1c:	d8 22       	popm	r4-r7,pc
80004a1e:	00 00       	add	r0,r0
80004a20:	80 00       	ld.sh	r0,r0[0x0]
80004a22:	c2 00       	breq	80004a62 <_get_interrupt_handler+0x32>
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	cc 20       	breq	800049aa <INTC_register_interrupt+0x4e>
80004a28:	80 00       	ld.sh	r0,r0[0x0]
80004a2a:	49 58       	lddpc	r8,80004a7c <tc_init_waveform+0x14>
80004a2c:	80 00       	ld.sh	r0,r0[0x0]
80004a2e:	c3 04       	brge	80004a8e <tc_init_waveform+0x26>

80004a30 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004a30:	fe 78 08 00 	mov	r8,-63488
80004a34:	e0 69 00 83 	mov	r9,131
80004a38:	f2 0c 01 0c 	sub	r12,r9,r12
80004a3c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004a40:	f2 ca ff c0 	sub	r10,r9,-64
80004a44:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004a48:	58 08       	cp.w	r8,0
80004a4a:	c0 21       	brne	80004a4e <_get_interrupt_handler+0x1e>
80004a4c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004a4e:	f0 08 12 00 	clz	r8,r8
80004a52:	48 5a       	lddpc	r10,80004a64 <_get_interrupt_handler+0x34>
80004a54:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004a58:	f0 08 11 1f 	rsub	r8,r8,31
80004a5c:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004a5e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004a62:	5e fc       	retal	r12
80004a64:	80 00       	ld.sh	r0,r0[0x0]
80004a66:	cc 20       	breq	800049ea <INTC_init_interrupts+0xe>

80004a68 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004a68:	76 09       	ld.w	r9,r11[0x0]
80004a6a:	58 29       	cp.w	r9,2
80004a6c:	e0 88 00 03 	brls	80004a72 <tc_init_waveform+0xa>
80004a70:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004a72:	76 18       	ld.w	r8,r11[0x4]
80004a74:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004a78:	af ba       	sbr	r10,0xf
80004a7a:	10 9b       	mov	r11,r8
80004a7c:	e6 1b c0 00 	andh	r11,0xc000,COH
80004a80:	16 4a       	or	r10,r11
80004a82:	10 9b       	mov	r11,r8
80004a84:	e6 1b 30 00 	andh	r11,0x3000,COH
80004a88:	16 4a       	or	r10,r11
80004a8a:	10 9b       	mov	r11,r8
80004a8c:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004a90:	16 4a       	or	r10,r11
80004a92:	10 9b       	mov	r11,r8
80004a94:	e6 1b 03 00 	andh	r11,0x300,COH
80004a98:	16 4a       	or	r10,r11
80004a9a:	10 9b       	mov	r11,r8
80004a9c:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004aa0:	16 4a       	or	r10,r11
80004aa2:	10 9b       	mov	r11,r8
80004aa4:	e6 1b 00 30 	andh	r11,0x30,COH
80004aa8:	16 4a       	or	r10,r11
80004aaa:	10 9b       	mov	r11,r8
80004aac:	e6 1b 00 0c 	andh	r11,0xc,COH
80004ab0:	16 4a       	or	r10,r11
80004ab2:	10 9b       	mov	r11,r8
80004ab4:	e6 1b 00 03 	andh	r11,0x3,COH
80004ab8:	16 4a       	or	r10,r11
80004aba:	10 9b       	mov	r11,r8
80004abc:	e2 1b 60 00 	andl	r11,0x6000,COH
80004ac0:	16 4a       	or	r10,r11
80004ac2:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80004ac6:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80004aca:	10 9b       	mov	r11,r8
80004acc:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004ad0:	16 4a       	or	r10,r11
80004ad2:	10 9b       	mov	r11,r8
80004ad4:	e2 1b 03 00 	andl	r11,0x300,COH
80004ad8:	16 4a       	or	r10,r11
80004ada:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004ade:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80004ae2:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80004ae6:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80004aea:	10 9b       	mov	r11,r8
80004aec:	e2 1b 00 30 	andl	r11,0x30,COH
80004af0:	16 4a       	or	r10,r11
80004af2:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004af6:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80004afa:	a5 69       	lsl	r9,0x4
80004afc:	2f f9       	sub	r9,-1
80004afe:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004b02:	5e fd       	retal	0

80004b04 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004b04:	58 2b       	cp.w	r11,2
80004b06:	e0 88 00 03 	brls	80004b0c <tc_start+0x8>
80004b0a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004b0c:	a7 6b       	lsl	r11,0x6
80004b0e:	16 0c       	add	r12,r11
80004b10:	30 58       	mov	r8,5
80004b12:	99 08       	st.w	r12[0x0],r8
80004b14:	5e fd       	retal	0

80004b16 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004b16:	58 2b       	cp.w	r11,2
80004b18:	e0 88 00 03 	brls	80004b1e <tc_read_sr+0x8>
80004b1c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004b1e:	a7 6b       	lsl	r11,0x6
80004b20:	2e 0b       	sub	r11,-32
80004b22:	16 0c       	add	r12,r11
80004b24:	78 0c       	ld.w	r12,r12[0x0]
}
80004b26:	5e fc       	retal	r12

80004b28 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004b28:	58 2b       	cp.w	r11,2
80004b2a:	e0 88 00 03 	brls	80004b30 <tc_write_rc+0x8>
80004b2e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004b30:	f6 08 15 04 	lsl	r8,r11,0x4
80004b34:	2f f8       	sub	r8,-1
80004b36:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004b3a:	e2 18 80 00 	andl	r8,0x8000,COH
80004b3e:	c0 c0       	breq	80004b56 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004b40:	a7 6b       	lsl	r11,0x6
80004b42:	16 0c       	add	r12,r11
80004b44:	2e 4c       	sub	r12,-28
80004b46:	78 08       	ld.w	r8,r12[0x0]
80004b48:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004b4c:	e0 18 00 00 	andl	r8,0x0
80004b50:	f3 e8 10 08 	or	r8,r9,r8
80004b54:	99 08       	st.w	r12[0x0],r8

  return value;
80004b56:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004b5a:	5e fc       	retal	r12

80004b5c <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004b5c:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004b60:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004b64:	58 2b       	cp.w	r11,2
80004b66:	e0 88 00 04 	brls	80004b6e <tc_configure_interrupts+0x12>
80004b6a:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004b6e:	ee 19 00 01 	eorh	r9,0x1
80004b72:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004b76:	74 08       	ld.w	r8,r10[0x0]
80004b78:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004b7c:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004b80:	a7 6e       	lsl	lr,0x6
80004b82:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004b86:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004b8a:	0e 4e       	or	lr,r7
80004b8c:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004b90:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004b94:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004b98:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004b9c:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004ba0:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004ba4:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004ba8:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004bac:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004bb0:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004bb4:	f6 0e 15 06 	lsl	lr,r11,0x6
80004bb8:	f8 0e 00 0e 	add	lr,r12,lr
80004bbc:	2d ce       	sub	lr,-36
80004bbe:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004bc0:	58 09       	cp.w	r9,0
80004bc2:	c0 20       	breq	80004bc6 <tc_configure_interrupts+0x6a>
80004bc4:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004bc6:	74 08       	ld.w	r8,r10[0x0]
80004bc8:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004bcc:	e0 65 00 80 	mov	r5,128
80004bd0:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004bd4:	74 08       	ld.w	r8,r10[0x0]
80004bd6:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004bda:	f9 b4 00 40 	moveq	r4,64
80004bde:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004be2:	74 08       	ld.w	r8,r10[0x0]
80004be4:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004be8:	f9 b3 00 20 	moveq	r3,32
80004bec:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004bf0:	74 08       	ld.w	r8,r10[0x0]
80004bf2:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80004bf6:	f9 b2 00 10 	moveq	r2,16
80004bfa:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004bfe:	74 08       	ld.w	r8,r10[0x0]
80004c00:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004c04:	f9 b6 00 08 	moveq	r6,8
80004c08:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004c0c:	74 08       	ld.w	r8,r10[0x0]
80004c0e:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004c12:	f9 b7 00 04 	moveq	r7,4
80004c16:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004c1a:	74 08       	ld.w	r8,r10[0x0]
80004c1c:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004c20:	f9 be 00 02 	moveq	lr,2
80004c24:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004c28:	74 08       	ld.w	r8,r10[0x0]
80004c2a:	ec 18 00 01 	eorl	r8,0x1
80004c2e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004c32:	eb e8 10 08 	or	r8,r5,r8
80004c36:	08 48       	or	r8,r4
80004c38:	06 48       	or	r8,r3
80004c3a:	04 48       	or	r8,r2
80004c3c:	0c 48       	or	r8,r6
80004c3e:	0e 48       	or	r8,r7
80004c40:	1c 48       	or	r8,lr
80004c42:	f6 0a 15 06 	lsl	r10,r11,0x6
80004c46:	f8 0a 00 0a 	add	r10,r12,r10
80004c4a:	2d 8a       	sub	r10,-40
80004c4c:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004c4e:	a7 6b       	lsl	r11,0x6
80004c50:	2e 0b       	sub	r11,-32
80004c52:	16 0c       	add	r12,r11
80004c54:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004c56:	58 09       	cp.w	r9,0
80004c58:	c0 31       	brne	80004c5e <tc_configure_interrupts+0x102>
80004c5a:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004c5e:	d5 03       	csrf	0x10
80004c60:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004c64 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80004c64:	4a 78       	lddpc	r8,80004d00 <twi_master_interrupt_handler+0x9c>
80004c66:	70 08       	ld.w	r8,r8[0x0]
80004c68:	70 89       	ld.w	r9,r8[0x20]
80004c6a:	4a 7a       	lddpc	r10,80004d04 <twi_master_interrupt_handler+0xa0>
80004c6c:	74 0a       	ld.w	r10,r10[0x0]
80004c6e:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80004c72:	12 9a       	mov	r10,r9
80004c74:	e2 1a 01 00 	andl	r10,0x100,COH
80004c78:	c3 91       	brne	80004cea <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80004c7a:	12 9a       	mov	r10,r9
80004c7c:	e2 1a 00 02 	andl	r10,0x2,COH
80004c80:	c1 70       	breq	80004cae <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80004c82:	4a 29       	lddpc	r9,80004d08 <twi_master_interrupt_handler+0xa4>
80004c84:	72 0a       	ld.w	r10,r9[0x0]
80004c86:	70 cb       	ld.w	r11,r8[0x30]
80004c88:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80004c8a:	72 0a       	ld.w	r10,r9[0x0]
80004c8c:	2f fa       	sub	r10,-1
80004c8e:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80004c90:	49 f9       	lddpc	r9,80004d0c <twi_master_interrupt_handler+0xa8>
80004c92:	72 0a       	ld.w	r10,r9[0x0]
80004c94:	20 1a       	sub	r10,1
80004c96:	93 0a       	st.w	r9[0x0],r10
80004c98:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80004c9a:	58 19       	cp.w	r9,1
80004c9c:	f9 b9 00 02 	moveq	r9,2
80004ca0:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80004ca4:	49 a9       	lddpc	r9,80004d0c <twi_master_interrupt_handler+0xa8>
80004ca6:	72 09       	ld.w	r9,r9[0x0]
80004ca8:	58 09       	cp.w	r9,0
80004caa:	c2 30       	breq	80004cf0 <twi_master_interrupt_handler+0x8c>
80004cac:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80004cae:	12 9a       	mov	r10,r9
80004cb0:	e2 1a 00 04 	andl	r10,0x4,COH
80004cb4:	c1 70       	breq	80004ce2 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80004cb6:	49 79       	lddpc	r9,80004d10 <twi_master_interrupt_handler+0xac>
80004cb8:	72 0a       	ld.w	r10,r9[0x0]
80004cba:	20 1a       	sub	r10,1
80004cbc:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80004cbe:	72 09       	ld.w	r9,r9[0x0]
80004cc0:	58 09       	cp.w	r9,0
80004cc2:	e0 89 00 0a 	brgt	80004cd6 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004cc6:	49 09       	lddpc	r9,80004d04 <twi_master_interrupt_handler+0xa0>
80004cc8:	30 1a       	mov	r10,1
80004cca:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80004ccc:	3f fa       	mov	r10,-1
80004cce:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80004cd0:	72 09       	ld.w	r9,r9[0x0]
80004cd2:	91 99       	st.w	r8[0x24],r9
80004cd4:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80004cd6:	49 0a       	lddpc	r10,80004d14 <twi_master_interrupt_handler+0xb0>
80004cd8:	74 09       	ld.w	r9,r10[0x0]
80004cda:	13 3b       	ld.ub	r11,r9++
80004cdc:	91 db       	st.w	r8[0x34],r11
80004cde:	95 09       	st.w	r10[0x0],r9
80004ce0:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80004ce2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004ce6:	c0 51       	brne	80004cf0 <twi_master_interrupt_handler+0x8c>
80004ce8:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80004cea:	30 1a       	mov	r10,1
80004cec:	48 b9       	lddpc	r9,80004d18 <twi_master_interrupt_handler+0xb4>
80004cee:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80004cf0:	3f f9       	mov	r9,-1
80004cf2:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80004cf4:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80004cf6:	30 09       	mov	r9,0
80004cf8:	48 98       	lddpc	r8,80004d1c <twi_master_interrupt_handler+0xb8>
80004cfa:	b0 89       	st.b	r8[0x0],r9
80004cfc:	d6 03       	rete
80004cfe:	00 00       	add	r0,r0
80004d00:	00 00       	add	r0,r0
80004d02:	0c 0c       	add	r12,r6
80004d04:	00 00       	add	r0,r0
80004d06:	0c 08       	add	r8,r6
80004d08:	00 00       	add	r0,r0
80004d0a:	0c 18       	sub	r8,r6
80004d0c:	00 00       	add	r0,r0
80004d0e:	0c 14       	sub	r4,r6
80004d10:	00 00       	add	r0,r0
80004d12:	0c 04       	add	r4,r6
80004d14:	00 00       	add	r0,r0
80004d16:	0c 10       	sub	r0,r6
80004d18:	00 00       	add	r0,r0
80004d1a:	0c 01       	add	r1,r6
80004d1c:	00 00       	add	r0,r0
80004d1e:	0c 00       	add	r0,r6

80004d20 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004d20:	eb cd 40 e0 	pushm	r5-r7,lr
80004d24:	18 97       	mov	r7,r12
80004d26:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80004d28:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80004d2c:	49 f9       	lddpc	r9,80004da8 <twi_master_init+0x88>
80004d2e:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80004d30:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80004d32:	3f f9       	mov	r9,-1
80004d34:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80004d36:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004d38:	e0 69 00 80 	mov	r9,128
80004d3c:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004d3e:	e6 18 00 01 	andh	r8,0x1,COH
80004d42:	c0 21       	brne	80004d46 <twi_master_init+0x26>
      cpu_irq_enable();
80004d44:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80004d46:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004d48:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80004d4c:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80004d4e:	30 3a       	mov	r10,3
80004d50:	e0 6b 01 60 	mov	r11,352
80004d54:	49 6c       	lddpc	r12,80004dac <twi_master_init+0x8c>
80004d56:	f0 1f 00 17 	mcall	80004db0 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004d5a:	e6 16 00 01 	andh	r6,0x1,COH
80004d5e:	c0 21       	brne	80004d62 <twi_master_init+0x42>
      cpu_irq_enable();
80004d60:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80004d62:	6a 19       	ld.w	r9,r5[0x4]
80004d64:	a1 79       	lsl	r9,0x1
80004d66:	6a 08       	ld.w	r8,r5[0x0]
80004d68:	f0 09 0d 08 	divu	r8,r8,r9
80004d6c:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004d6e:	e0 48 00 ff 	cp.w	r8,255
80004d72:	e0 8b 00 04 	brhi	80004d7a <twi_master_init+0x5a>
80004d76:	30 09       	mov	r9,0
80004d78:	c0 f8       	rjmp	80004d96 <twi_master_init+0x76>
80004d7a:	30 09       	mov	r9,0
80004d7c:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80004d7e:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80004d80:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004d82:	e0 48 00 ff 	cp.w	r8,255
80004d86:	5f bb       	srhi	r11
80004d88:	58 69       	cp.w	r9,6
80004d8a:	5f 8a       	srls	r10
80004d8c:	f7 ea 00 0a 	and	r10,r11,r10
80004d90:	f8 0a 18 00 	cp.b	r10,r12
80004d94:	cf 51       	brne	80004d7e <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80004d96:	b1 69       	lsl	r9,0x10
80004d98:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80004d9c:	f3 e8 10 08 	or	r8,r9,r8
80004da0:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80004da2:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80004da6:	00 00       	add	r0,r0
80004da8:	00 00       	add	r0,r0
80004daa:	0c 0c       	add	r12,r6
80004dac:	80 00       	ld.sh	r0,r0[0x0]
80004dae:	4c 64       	lddpc	r4,80004ec4 <usart_reset>
80004db0:	80 00       	ld.sh	r0,r0[0x0]
80004db2:	49 5c       	lddpc	r12,80004e04 <usart_set_async_baudrate+0x50>

80004db4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004db4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004db6:	f6 08 15 04 	lsl	r8,r11,0x4
80004dba:	14 38       	cp.w	r8,r10
80004dbc:	f9 b8 08 10 	movls	r8,16
80004dc0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004dc4:	f0 0b 02 4b 	mul	r11,r8,r11
80004dc8:	f6 09 16 01 	lsr	r9,r11,0x1
80004dcc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004dd0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004dd4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004dd8:	f2 cb 00 01 	sub	r11,r9,1
80004ddc:	e0 4b ff fe 	cp.w	r11,65534
80004de0:	e0 88 00 03 	brls	80004de6 <usart_set_async_baudrate+0x32>
80004de4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004de6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004de8:	e8 6e 00 00 	mov	lr,524288
80004dec:	59 08       	cp.w	r8,16
80004dee:	fc 08 17 10 	movne	r8,lr
80004df2:	f9 b8 00 00 	moveq	r8,0
80004df6:	e4 1b ff f7 	andh	r11,0xfff7
80004dfa:	e0 1b fe cf 	andl	r11,0xfecf
80004dfe:	16 48       	or	r8,r11
80004e00:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80004e02:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004e06:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004e0a:	99 89       	st.w	r12[0x20],r9
80004e0c:	d8 0a       	popm	pc,r12=0

80004e0e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80004e0e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004e10:	e2 18 00 02 	andl	r8,0x2,COH
80004e14:	c0 31       	brne	80004e1a <usart_write_char+0xc>
80004e16:	30 2c       	mov	r12,2
80004e18:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80004e1a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80004e1e:	99 7b       	st.w	r12[0x1c],r11
80004e20:	5e fd       	retal	0
80004e22:	d7 03       	nop

80004e24 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004e24:	eb cd 40 e0 	pushm	r5-r7,lr
80004e28:	18 96       	mov	r6,r12
80004e2a:	16 95       	mov	r5,r11
80004e2c:	e0 67 27 0f 	mov	r7,9999
80004e30:	c0 68       	rjmp	80004e3c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004e32:	58 07       	cp.w	r7,0
80004e34:	c0 31       	brne	80004e3a <usart_putchar+0x16>
80004e36:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80004e3a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004e3c:	0a 9b       	mov	r11,r5
80004e3e:	0c 9c       	mov	r12,r6
80004e40:	f0 1f 00 03 	mcall	80004e4c <usart_putchar+0x28>
80004e44:	cf 71       	brne	80004e32 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004e46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004e4a:	00 00       	add	r0,r0
80004e4c:	80 00       	ld.sh	r0,r0[0x0]
80004e4e:	4e 0e       	lddpc	lr,80004fcc <vListInitialise+0x10>

80004e50 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004e50:	78 58       	ld.w	r8,r12[0x14]
80004e52:	e2 18 00 e0 	andl	r8,0xe0,COH
80004e56:	c0 30       	breq	80004e5c <usart_read_char+0xc>
80004e58:	30 4c       	mov	r12,4
80004e5a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004e5c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004e5e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e62:	c0 31       	brne	80004e68 <usart_read_char+0x18>
80004e64:	30 3c       	mov	r12,3
80004e66:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004e68:	78 68       	ld.w	r8,r12[0x18]
80004e6a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004e6e:	97 08       	st.w	r11[0x0],r8
80004e70:	5e fd       	retal	0
80004e72:	d7 03       	nop

80004e74 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004e74:	eb cd 40 c0 	pushm	r6-r7,lr
80004e78:	20 1d       	sub	sp,4
80004e7a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004e7c:	1a 97       	mov	r7,sp
80004e7e:	1a 9b       	mov	r11,sp
80004e80:	0c 9c       	mov	r12,r6
80004e82:	f0 1f 00 07 	mcall	80004e9c <usart_getchar+0x28>
80004e86:	58 3c       	cp.w	r12,3
80004e88:	cf b0       	breq	80004e7e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004e8a:	58 4c       	cp.w	r12,4
80004e8c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004e90:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004e94:	2f fd       	sub	sp,-4
80004e96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e9a:	00 00       	add	r0,r0
80004e9c:	80 00       	ld.sh	r0,r0[0x0]
80004e9e:	4e 50       	lddpc	r0,80005030 <vListRemove+0xa>

80004ea0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004ea0:	eb cd 40 c0 	pushm	r6-r7,lr
80004ea4:	18 96       	mov	r6,r12
80004ea6:	16 97       	mov	r7,r11
  while (*string != '\0')
80004ea8:	17 8b       	ld.ub	r11,r11[0x0]
80004eaa:	58 0b       	cp.w	r11,0
80004eac:	c0 80       	breq	80004ebc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004eae:	2f f7       	sub	r7,-1
80004eb0:	0c 9c       	mov	r12,r6
80004eb2:	f0 1f 00 04 	mcall	80004ec0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004eb6:	0f 8b       	ld.ub	r11,r7[0x0]
80004eb8:	58 0b       	cp.w	r11,0
80004eba:	cf a1       	brne	80004eae <usart_write_line+0xe>
80004ebc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ec0:	80 00       	ld.sh	r0,r0[0x0]
80004ec2:	4e 24       	lddpc	r4,80005048 <vListRemove+0x22>

80004ec4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80004ec4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004ec8:	e6 18 00 01 	andh	r8,0x1,COH
80004ecc:	c0 71       	brne	80004eda <usart_reset+0x16>
80004ece:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004ed0:	3f f8       	mov	r8,-1
80004ed2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004ed4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80004ed6:	d5 03       	csrf	0x10
80004ed8:	c0 48       	rjmp	80004ee0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004eda:	3f f8       	mov	r8,-1
80004edc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004ede:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004ee0:	30 08       	mov	r8,0
80004ee2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80004ee4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80004ee6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80004ee8:	ea 68 61 0c 	mov	r8,680204
80004eec:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80004eee:	5e fc       	retal	r12

80004ef0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80004ef0:	eb cd 40 e0 	pushm	r5-r7,lr
80004ef4:	18 96       	mov	r6,r12
80004ef6:	16 97       	mov	r7,r11
80004ef8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80004efa:	f0 1f 00 2f 	mcall	80004fb4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80004efe:	58 07       	cp.w	r7,0
80004f00:	c5 80       	breq	80004fb0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80004f02:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004f04:	30 49       	mov	r9,4
80004f06:	f2 08 18 00 	cp.b	r8,r9
80004f0a:	e0 88 00 53 	brls	80004fb0 <usart_init_rs232+0xc0>
80004f0e:	30 99       	mov	r9,9
80004f10:	f2 08 18 00 	cp.b	r8,r9
80004f14:	e0 8b 00 4e 	brhi	80004fb0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004f18:	0f d9       	ld.ub	r9,r7[0x5]
80004f1a:	30 78       	mov	r8,7
80004f1c:	f0 09 18 00 	cp.b	r9,r8
80004f20:	e0 8b 00 48 	brhi	80004fb0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004f24:	8e 39       	ld.sh	r9,r7[0x6]
80004f26:	e0 68 01 01 	mov	r8,257
80004f2a:	f0 09 19 00 	cp.h	r9,r8
80004f2e:	e0 8b 00 41 	brhi	80004fb0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004f32:	ef 39 00 08 	ld.ub	r9,r7[8]
80004f36:	30 38       	mov	r8,3
80004f38:	f0 09 18 00 	cp.b	r9,r8
80004f3c:	e0 8b 00 3a 	brhi	80004fb0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004f40:	0a 9a       	mov	r10,r5
80004f42:	6e 0b       	ld.w	r11,r7[0x0]
80004f44:	0c 9c       	mov	r12,r6
80004f46:	f0 1f 00 1d 	mcall	80004fb8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004f4a:	58 1c       	cp.w	r12,1
80004f4c:	c3 20       	breq	80004fb0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004f4e:	0f c8       	ld.ub	r8,r7[0x4]
80004f50:	30 99       	mov	r9,9
80004f52:	f2 08 18 00 	cp.b	r8,r9
80004f56:	c0 51       	brne	80004f60 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004f58:	6c 18       	ld.w	r8,r6[0x4]
80004f5a:	b1 b8       	sbr	r8,0x11
80004f5c:	8d 18       	st.w	r6[0x4],r8
80004f5e:	c0 68       	rjmp	80004f6a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004f60:	6c 19       	ld.w	r9,r6[0x4]
80004f62:	20 58       	sub	r8,5
80004f64:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004f68:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004f6a:	6c 19       	ld.w	r9,r6[0x4]
80004f6c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004f70:	0f d8       	ld.ub	r8,r7[0x5]
80004f72:	a9 78       	lsl	r8,0x9
80004f74:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004f78:	12 48       	or	r8,r9
80004f7a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004f7c:	8e 38       	ld.sh	r8,r7[0x6]
80004f7e:	30 29       	mov	r9,2
80004f80:	f2 08 19 00 	cp.h	r8,r9
80004f84:	e0 88 00 09 	brls	80004f96 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004f88:	6c 18       	ld.w	r8,r6[0x4]
80004f8a:	ad b8       	sbr	r8,0xd
80004f8c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004f8e:	8e b8       	ld.uh	r8,r7[0x6]
80004f90:	20 28       	sub	r8,2
80004f92:	8d a8       	st.w	r6[0x28],r8
80004f94:	c0 68       	rjmp	80004fa0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004f96:	6c 19       	ld.w	r9,r6[0x4]
80004f98:	5c 78       	castu.h	r8
80004f9a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004f9e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004fa0:	6c 18       	ld.w	r8,r6[0x4]
80004fa2:	e0 18 ff f0 	andl	r8,0xfff0
80004fa6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004fa8:	35 08       	mov	r8,80
80004faa:	8d 08       	st.w	r6[0x0],r8
80004fac:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004fb0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004fb4:	80 00       	ld.sh	r0,r0[0x0]
80004fb6:	4e c4       	lddpc	r4,80005164 <SCALLYield+0x1c>
80004fb8:	80 00       	ld.sh	r0,r0[0x0]
80004fba:	4d b4       	lddpc	r4,80005124 <xPortStartScheduler+0x34>

80004fbc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004fbc:	f8 c8 ff f8 	sub	r8,r12,-8
80004fc0:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004fc2:	3f f9       	mov	r9,-1
80004fc4:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004fc6:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004fc8:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004fca:	30 08       	mov	r8,0
80004fcc:	99 08       	st.w	r12[0x0],r8
}
80004fce:	5e fc       	retal	r12

80004fd0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004fd0:	30 08       	mov	r8,0
80004fd2:	99 48       	st.w	r12[0x10],r8
}
80004fd4:	5e fc       	retal	r12

80004fd6 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004fd6:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004fd8:	70 19       	ld.w	r9,r8[0x4]
80004fda:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004fdc:	78 19       	ld.w	r9,r12[0x4]
80004fde:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004fe0:	70 19       	ld.w	r9,r8[0x4]
80004fe2:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004fe4:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004fe6:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004fe8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004fea:	78 08       	ld.w	r8,r12[0x0]
80004fec:	2f f8       	sub	r8,-1
80004fee:	99 08       	st.w	r12[0x0],r8
}
80004ff0:	5e fc       	retal	r12

80004ff2 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004ff2:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004ff4:	5b fa       	cp.w	r10,-1
80004ff6:	c0 31       	brne	80004ffc <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004ff8:	78 48       	ld.w	r8,r12[0x10]
80004ffa:	c0 c8       	rjmp	80005012 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004ffc:	f8 c8 ff f8 	sub	r8,r12,-8
80005000:	70 19       	ld.w	r9,r8[0x4]
80005002:	72 09       	ld.w	r9,r9[0x0]
80005004:	12 3a       	cp.w	r10,r9
80005006:	c0 63       	brcs	80005012 <vListInsert+0x20>
80005008:	70 18       	ld.w	r8,r8[0x4]
8000500a:	70 19       	ld.w	r9,r8[0x4]
8000500c:	72 09       	ld.w	r9,r9[0x0]
8000500e:	12 3a       	cp.w	r10,r9
80005010:	cf c2       	brcc	80005008 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005012:	70 19       	ld.w	r9,r8[0x4]
80005014:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005016:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005018:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000501a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000501c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000501e:	78 08       	ld.w	r8,r12[0x0]
80005020:	2f f8       	sub	r8,-1
80005022:	99 08       	st.w	r12[0x0],r8
}
80005024:	5e fc       	retal	r12

80005026 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005026:	78 18       	ld.w	r8,r12[0x4]
80005028:	78 29       	ld.w	r9,r12[0x8]
8000502a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000502c:	78 28       	ld.w	r8,r12[0x8]
8000502e:	78 19       	ld.w	r9,r12[0x4]
80005030:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005032:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005034:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005036:	18 39       	cp.w	r9,r12
80005038:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
8000503c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005040:	30 09       	mov	r9,0
80005042:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005044:	70 09       	ld.w	r9,r8[0x0]
80005046:	20 19       	sub	r9,1
80005048:	91 09       	st.w	r8[0x0],r9
}
8000504a:	5e fc       	retal	r12

8000504c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000504c:	e0 68 08 08 	mov	r8,2056
80005050:	ea 18 08 08 	orh	r8,0x808
80005054:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005056:	e0 68 09 09 	mov	r8,2313
8000505a:	ea 18 09 09 	orh	r8,0x909
8000505e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005060:	e0 68 0a 0a 	mov	r8,2570
80005064:	ea 18 0a 0a 	orh	r8,0xa0a
80005068:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000506a:	e0 68 0b 0b 	mov	r8,2827
8000506e:	ea 18 0b 0b 	orh	r8,0xb0b
80005072:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005074:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005076:	e0 68 be ef 	mov	r8,48879
8000507a:	ea 18 de ad 	orh	r8,0xdead
8000507e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005080:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005082:	fc 18 00 40 	movh	r8,0x40
80005086:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005088:	e0 68 00 ff 	mov	r8,255
8000508c:	ea 18 ff 00 	orh	r8,0xff00
80005090:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005092:	e0 68 01 01 	mov	r8,257
80005096:	ea 18 01 01 	orh	r8,0x101
8000509a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000509c:	e0 68 02 02 	mov	r8,514
800050a0:	ea 18 02 02 	orh	r8,0x202
800050a4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800050a6:	e0 68 03 03 	mov	r8,771
800050aa:	ea 18 03 03 	orh	r8,0x303
800050ae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800050b0:	e0 68 04 04 	mov	r8,1028
800050b4:	ea 18 04 04 	orh	r8,0x404
800050b8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800050ba:	e0 68 05 05 	mov	r8,1285
800050be:	ea 18 05 05 	orh	r8,0x505
800050c2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800050c4:	e0 68 06 06 	mov	r8,1542
800050c8:	ea 18 06 06 	orh	r8,0x606
800050cc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800050ce:	e0 68 07 07 	mov	r8,1799
800050d2:	ea 18 07 07 	orh	r8,0x707
800050d6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800050d8:	30 08       	mov	r8,0
800050da:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800050dc:	5e fc       	retal	r12
800050de:	d7 03       	nop

800050e0 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800050e0:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800050e2:	48 38       	lddpc	r8,800050ec <vPortEnterCritical+0xc>
800050e4:	70 09       	ld.w	r9,r8[0x0]
800050e6:	2f f9       	sub	r9,-1
800050e8:	91 09       	st.w	r8[0x0],r9
}
800050ea:	5e fc       	retal	r12
800050ec:	00 00       	add	r0,r0
800050ee:	05 28       	ld.uh	r8,r2++

800050f0 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800050f0:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800050f2:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800050f4:	30 0a       	mov	r10,0
800050f6:	14 9b       	mov	r11,r10
800050f8:	49 2c       	lddpc	r12,80005140 <xPortStartScheduler+0x50>
800050fa:	f0 1f 00 13 	mcall	80005144 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800050fe:	e0 68 5d c0 	mov	r8,24000
80005102:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005106:	30 08       	mov	r8,0
80005108:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000510c:	e0 68 0c ec 	mov	r8,3308
80005110:	ea 18 00 00 	orh	r8,0x0
80005114:	70 00       	ld.w	r0,r8[0x0]
80005116:	60 0d       	ld.w	sp,r0[0x0]
80005118:	1b 00       	ld.w	r0,sp++
8000511a:	e0 68 05 28 	mov	r8,1320
8000511e:	ea 18 00 00 	orh	r8,0x0
80005122:	91 00       	st.w	r8[0x0],r0
80005124:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005128:	2f ed       	sub	sp,-8
8000512a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000512e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005132:	e3 b0 00 00 	mtsr	0x0,r0
80005136:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000513a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000513e:	d8 0a       	popm	pc,r12=0
80005140:	80 00       	ld.sh	r0,r0[0x0]
80005142:	52 0c       	stdsp	sp[0x80],r12
80005144:	80 00       	ld.sh	r0,r0[0x0]
80005146:	49 5c       	lddpc	r12,80005198 <SCALLYield+0x50>

80005148 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005148:	20 6d       	sub	sp,24
8000514a:	eb cd 00 ff 	pushm	r0-r7
8000514e:	fa c7 ff c0 	sub	r7,sp,-64
80005152:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005156:	ef 40 ff e0 	st.w	r7[-32],r0
8000515a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000515e:	ef 40 ff e4 	st.w	r7[-28],r0
80005162:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005166:	e0 68 05 28 	mov	r8,1320
8000516a:	ea 18 00 00 	orh	r8,0x0
8000516e:	70 00       	ld.w	r0,r8[0x0]
80005170:	1a d0       	st.w	--sp,r0
80005172:	f0 1f 00 1a 	mcall	800051d8 <LABEL_RET_SCALL_263+0x14>
80005176:	e0 68 0c ec 	mov	r8,3308
8000517a:	ea 18 00 00 	orh	r8,0x0
8000517e:	70 00       	ld.w	r0,r8[0x0]
80005180:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005182:	f0 1f 00 17 	mcall	800051dc <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005186:	e0 68 0c ec 	mov	r8,3308
8000518a:	ea 18 00 00 	orh	r8,0x0
8000518e:	70 00       	ld.w	r0,r8[0x0]
80005190:	60 0d       	ld.w	sp,r0[0x0]
80005192:	1b 00       	ld.w	r0,sp++
80005194:	e0 68 05 28 	mov	r8,1320
80005198:	ea 18 00 00 	orh	r8,0x0
8000519c:	91 00       	st.w	r8[0x0],r0
8000519e:	fa c7 ff d8 	sub	r7,sp,-40
800051a2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800051a6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800051aa:	e0 61 05 28 	mov	r1,1320
800051ae:	ea 11 00 00 	orh	r1,0x0
800051b2:	62 02       	ld.w	r2,r1[0x0]
800051b4:	58 02       	cp.w	r2,0
800051b6:	c0 70       	breq	800051c4 <LABEL_RET_SCALL_263>
800051b8:	e4 c2 00 01 	sub	r2,r2,1
800051bc:	83 02       	st.w	r1[0x0],r2
800051be:	58 02       	cp.w	r2,0
800051c0:	c0 21       	brne	800051c4 <LABEL_RET_SCALL_263>
800051c2:	b1 c0       	cbr	r0,0x10

800051c4 <LABEL_RET_SCALL_263>:
800051c4:	ef 40 ff f8 	st.w	r7[-8],r0
800051c8:	ee f0 ff e4 	ld.w	r0,r7[-28]
800051cc:	ef 40 ff fc 	st.w	r7[-4],r0
800051d0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800051d4:	2f ad       	sub	sp,-24
800051d6:	d6 13       	rets
800051d8:	80 00       	ld.sh	r0,r0[0x0]
800051da:	50 e0       	stdsp	sp[0x38],r0
800051dc:	80 00       	ld.sh	r0,r0[0x0]
800051de:	58 7c       	cp.w	r12,7

800051e0 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800051e0:	e1 b8 00 43 	mfsr	r8,0x10c
800051e4:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800051e8:	5e fc       	retal	r12
800051ea:	d7 03       	nop

800051ec <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800051ec:	48 78       	lddpc	r8,80005208 <vPortExitCritical+0x1c>
800051ee:	70 08       	ld.w	r8,r8[0x0]
800051f0:	58 08       	cp.w	r8,0
800051f2:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800051f4:	48 58       	lddpc	r8,80005208 <vPortExitCritical+0x1c>
800051f6:	70 09       	ld.w	r9,r8[0x0]
800051f8:	20 19       	sub	r9,1
800051fa:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800051fc:	70 08       	ld.w	r8,r8[0x0]
800051fe:	58 08       	cp.w	r8,0
80005200:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005202:	d5 03       	csrf	0x10
80005204:	5e fc       	retal	r12
80005206:	00 00       	add	r0,r0
80005208:	00 00       	add	r0,r0
8000520a:	05 28       	ld.uh	r8,r2++

8000520c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000520c:	eb cd 00 ff 	pushm	r0-r7
80005210:	e0 68 05 28 	mov	r8,1320
80005214:	ea 18 00 00 	orh	r8,0x0
80005218:	70 00       	ld.w	r0,r8[0x0]
8000521a:	1a d0       	st.w	--sp,r0
8000521c:	7a 90       	ld.w	r0,sp[0x24]
8000521e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005222:	58 10       	cp.w	r0,1
80005224:	e0 8b 00 08 	brhi	80005234 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005228:	e0 68 0c ec 	mov	r8,3308
8000522c:	ea 18 00 00 	orh	r8,0x0
80005230:	70 00       	ld.w	r0,r8[0x0]
80005232:	81 0d       	st.w	r0[0x0],sp

80005234 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005234:	f0 1f 00 12 	mcall	8000527c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005238:	f0 1f 00 12 	mcall	80005280 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
8000523c:	f0 1f 00 12 	mcall	80005284 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005240:	f0 1f 00 12 	mcall	80005288 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005244:	7a 90       	ld.w	r0,sp[0x24]
80005246:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000524a:	58 10       	cp.w	r0,1
8000524c:	e0 8b 00 0e 	brhi	80005268 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005250:	f0 1f 00 0c 	mcall	80005280 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005254:	f0 1f 00 0e 	mcall	8000528c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005258:	f0 1f 00 0c 	mcall	80005288 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
8000525c:	e0 68 0c ec 	mov	r8,3308
80005260:	ea 18 00 00 	orh	r8,0x0
80005264:	70 00       	ld.w	r0,r8[0x0]
80005266:	60 0d       	ld.w	sp,r0[0x0]

80005268 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005268:	1b 00       	ld.w	r0,sp++
8000526a:	e0 68 05 28 	mov	r8,1320
8000526e:	ea 18 00 00 	orh	r8,0x0
80005272:	91 00       	st.w	r8[0x0],r0
80005274:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005278:	d6 03       	rete
8000527a:	00 00       	add	r0,r0
8000527c:	80 00       	ld.sh	r0,r0[0x0]
8000527e:	51 e0       	stdsp	sp[0x78],r0
80005280:	80 00       	ld.sh	r0,r0[0x0]
80005282:	50 e0       	stdsp	sp[0x38],r0
80005284:	80 00       	ld.sh	r0,r0[0x0]
80005286:	5a 80       	cp.w	r0,-24
80005288:	80 00       	ld.sh	r0,r0[0x0]
8000528a:	51 ec       	stdsp	sp[0x78],r12
8000528c:	80 00       	ld.sh	r0,r0[0x0]
8000528e:	58 7c       	cp.w	r12,7

80005290 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005290:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005292:	f0 1f 00 02 	mcall	80005298 <__malloc_lock+0x8>
}
80005296:	d8 02       	popm	pc
80005298:	80 00       	ld.sh	r0,r0[0x0]
8000529a:	58 6c       	cp.w	r12,6

8000529c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000529c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000529e:	f0 1f 00 02 	mcall	800052a4 <__malloc_unlock+0x8>
}
800052a2:	d8 02       	popm	pc
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	5c 28       	cpc	r8

800052a8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800052a8:	d4 21       	pushm	r4-r7,lr
800052aa:	16 95       	mov	r5,r11
800052ac:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800052ae:	58 0c       	cp.w	r12,0
800052b0:	c0 30       	breq	800052b6 <_read+0xe>
800052b2:	3f f7       	mov	r7,-1
800052b4:	c1 48       	rjmp	800052dc <_read+0x34>
    return -1;

  for (; len > 0; --len)
800052b6:	58 0a       	cp.w	r10,0
800052b8:	e0 89 00 04 	brgt	800052c0 <_read+0x18>
800052bc:	30 07       	mov	r7,0
800052be:	c0 f8       	rjmp	800052dc <_read+0x34>
800052c0:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800052c2:	48 84       	lddpc	r4,800052e0 <_read+0x38>
800052c4:	68 0c       	ld.w	r12,r4[0x0]
800052c6:	f0 1f 00 08 	mcall	800052e4 <_read+0x3c>
    if (c < 0)
800052ca:	c0 95       	brlt	800052dc <_read+0x34>
      break;

    *ptr++ = c;
800052cc:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800052d0:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800052d2:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800052d6:	58 08       	cp.w	r8,0
800052d8:	fe 99 ff f6 	brgt	800052c4 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800052dc:	0e 9c       	mov	r12,r7
800052de:	d8 22       	popm	r4-r7,pc
800052e0:	00 00       	add	r0,r0
800052e2:	41 0c       	lddsp	r12,sp[0x40]
800052e4:	80 00       	ld.sh	r0,r0[0x0]
800052e6:	4e 74       	lddpc	r4,80005480 <prvUnlockQueue+0x8c>

800052e8 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800052e8:	d4 21       	pushm	r4-r7,lr
800052ea:	16 95       	mov	r5,r11
800052ec:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800052ee:	20 1c       	sub	r12,1
800052f0:	58 2c       	cp.w	r12,2
800052f2:	e0 8b 00 12 	brhi	80005316 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800052f6:	58 0a       	cp.w	r10,0
800052f8:	c0 31       	brne	800052fe <_write+0x16>
800052fa:	30 07       	mov	r7,0
800052fc:	c0 e8       	rjmp	80005318 <_write+0x30>
800052fe:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005300:	48 74       	lddpc	r4,8000531c <_write+0x34>
80005302:	68 0c       	ld.w	r12,r4[0x0]
80005304:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005308:	f0 1f 00 06 	mcall	80005320 <_write+0x38>
8000530c:	c0 55       	brlt	80005316 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000530e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005310:	0e 36       	cp.w	r6,r7
80005312:	cf 81       	brne	80005302 <_write+0x1a>
80005314:	c0 28       	rjmp	80005318 <_write+0x30>
80005316:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005318:	0e 9c       	mov	r12,r7
8000531a:	d8 22       	popm	r4-r7,pc
8000531c:	00 00       	add	r0,r0
8000531e:	41 0c       	lddsp	r12,sp[0x40]
80005320:	80 00       	ld.sh	r0,r0[0x0]
80005322:	4e 24       	lddpc	r4,800054a8 <xQueueGenericReceive+0x14>

80005324 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005324:	eb cd 40 80 	pushm	r7,lr
80005328:	18 97       	mov	r7,r12
	if( pv )
8000532a:	58 0c       	cp.w	r12,0
8000532c:	c0 80       	breq	8000533c <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000532e:	f0 1f 00 05 	mcall	80005340 <vPortFree+0x1c>
		{
			free( pv );
80005332:	0e 9c       	mov	r12,r7
80005334:	f0 1f 00 04 	mcall	80005344 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005338:	f0 1f 00 04 	mcall	80005348 <vPortFree+0x24>
8000533c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	58 6c       	cp.w	r12,6
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	67 98       	ld.w	r8,r3[0x64]
80005348:	80 00       	ld.sh	r0,r0[0x0]
8000534a:	5c 28       	cpc	r8

8000534c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000534c:	eb cd 40 80 	pushm	r7,lr
80005350:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005352:	f0 1f 00 06 	mcall	80005368 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005356:	0e 9c       	mov	r12,r7
80005358:	f0 1f 00 05 	mcall	8000536c <pvPortMalloc+0x20>
8000535c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000535e:	f0 1f 00 05 	mcall	80005370 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005362:	0e 9c       	mov	r12,r7
80005364:	e3 cd 80 80 	ldm	sp++,r7,pc
80005368:	80 00       	ld.sh	r0,r0[0x0]
8000536a:	58 6c       	cp.w	r12,6
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	67 a8       	ld.w	r8,r3[0x68]
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	5c 28       	cpc	r8

80005374 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005374:	d4 01       	pushm	lr
80005376:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005378:	78 09       	ld.w	r9,r12[0x0]
8000537a:	58 09       	cp.w	r9,0
8000537c:	c1 10       	breq	8000539e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000537e:	78 3a       	ld.w	r10,r12[0xc]
80005380:	79 09       	ld.w	r9,r12[0x40]
80005382:	f4 09 00 09 	add	r9,r10,r9
80005386:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005388:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000538a:	14 39       	cp.w	r9,r10
8000538c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005390:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005394:	79 0a       	ld.w	r10,r12[0x40]
80005396:	78 3b       	ld.w	r11,r12[0xc]
80005398:	10 9c       	mov	r12,r8
8000539a:	f0 1f 00 02 	mcall	800053a0 <prvCopyDataFromQueue+0x2c>
8000539e:	d8 02       	popm	pc
800053a0:	80 00       	ld.sh	r0,r0[0x0]
800053a2:	6b f0       	ld.w	r0,r5[0x7c]

800053a4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800053a4:	eb cd 40 c0 	pushm	r6-r7,lr
800053a8:	18 97       	mov	r7,r12
800053aa:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800053ac:	78 e8       	ld.w	r8,r12[0x38]
800053ae:	58 08       	cp.w	r8,0
800053b0:	c0 31       	brne	800053b6 <xQueueReceiveFromISR+0x12>
800053b2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800053b6:	f0 1f 00 0e 	mcall	800053ec <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800053ba:	6e e8       	ld.w	r8,r7[0x38]
800053bc:	20 18       	sub	r8,1
800053be:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800053c0:	6f 18       	ld.w	r8,r7[0x44]
800053c2:	5b f8       	cp.w	r8,-1
800053c4:	c0 d1       	brne	800053de <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800053c6:	6e 48       	ld.w	r8,r7[0x10]
800053c8:	58 08       	cp.w	r8,0
800053ca:	c0 f0       	breq	800053e8 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800053cc:	ee cc ff f0 	sub	r12,r7,-16
800053d0:	f0 1f 00 08 	mcall	800053f0 <xQueueReceiveFromISR+0x4c>
800053d4:	c0 a0       	breq	800053e8 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800053d6:	30 1c       	mov	r12,1
800053d8:	8d 0c       	st.w	r6[0x0],r12
800053da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800053de:	2f f8       	sub	r8,-1
800053e0:	ef 48 00 44 	st.w	r7[68],r8
800053e4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800053e8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	53 74       	stdsp	sp[0xdc],r4
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	5a 04       	cp.w	r4,-32

800053f4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800053f4:	eb cd 40 c0 	pushm	r6-r7,lr
800053f8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800053fa:	f0 1f 00 23 	mcall	80005484 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800053fe:	6f 28       	ld.w	r8,r7[0x48]
80005400:	58 08       	cp.w	r8,0
80005402:	e0 8a 00 18 	brle	80005432 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005406:	6e 98       	ld.w	r8,r7[0x24]
80005408:	58 08       	cp.w	r8,0
8000540a:	c1 40       	breq	80005432 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000540c:	ee c6 ff dc 	sub	r6,r7,-36
80005410:	c0 48       	rjmp	80005418 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005412:	6e 98       	ld.w	r8,r7[0x24]
80005414:	58 08       	cp.w	r8,0
80005416:	c0 e0       	breq	80005432 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005418:	0c 9c       	mov	r12,r6
8000541a:	f0 1f 00 1c 	mcall	80005488 <prvUnlockQueue+0x94>
8000541e:	c0 30       	breq	80005424 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005420:	f0 1f 00 1b 	mcall	8000548c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005424:	6f 28       	ld.w	r8,r7[0x48]
80005426:	20 18       	sub	r8,1
80005428:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000542c:	58 08       	cp.w	r8,0
8000542e:	fe 99 ff f2 	brgt	80005412 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005432:	3f f8       	mov	r8,-1
80005434:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005438:	f0 1f 00 16 	mcall	80005490 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000543c:	f0 1f 00 12 	mcall	80005484 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005440:	6f 18       	ld.w	r8,r7[0x44]
80005442:	58 08       	cp.w	r8,0
80005444:	e0 8a 00 18 	brle	80005474 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005448:	6e 48       	ld.w	r8,r7[0x10]
8000544a:	58 08       	cp.w	r8,0
8000544c:	c1 40       	breq	80005474 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000544e:	ee c6 ff f0 	sub	r6,r7,-16
80005452:	c0 48       	rjmp	8000545a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005454:	6e 48       	ld.w	r8,r7[0x10]
80005456:	58 08       	cp.w	r8,0
80005458:	c0 e0       	breq	80005474 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000545a:	0c 9c       	mov	r12,r6
8000545c:	f0 1f 00 0b 	mcall	80005488 <prvUnlockQueue+0x94>
80005460:	c0 30       	breq	80005466 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005462:	f0 1f 00 0b 	mcall	8000548c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005466:	6f 18       	ld.w	r8,r7[0x44]
80005468:	20 18       	sub	r8,1
8000546a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000546e:	58 08       	cp.w	r8,0
80005470:	fe 99 ff f2 	brgt	80005454 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005474:	3f f8       	mov	r8,-1
80005476:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000547a:	f0 1f 00 06 	mcall	80005490 <prvUnlockQueue+0x9c>
}
8000547e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005482:	00 00       	add	r0,r0
80005484:	80 00       	ld.sh	r0,r0[0x0]
80005486:	50 e0       	stdsp	sp[0x38],r0
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	5a 04       	cp.w	r4,-32
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	59 10       	cp.w	r0,17
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	51 ec       	stdsp	sp[0x78],r12

80005494 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005494:	d4 31       	pushm	r0-r7,lr
80005496:	20 5d       	sub	sp,20
80005498:	18 97       	mov	r7,r12
8000549a:	50 0b       	stdsp	sp[0x0],r11
8000549c:	50 2a       	stdsp	sp[0x8],r10
8000549e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800054a0:	f8 c2 ff dc 	sub	r2,r12,-36
800054a4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800054a6:	fa c4 ff f4 	sub	r4,sp,-12
800054aa:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800054ac:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800054ae:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800054b2:	f0 1f 00 3e 	mcall	800055a8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800054b6:	6e e8       	ld.w	r8,r7[0x38]
800054b8:	58 08       	cp.w	r8,0
800054ba:	c2 a0       	breq	8000550e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800054bc:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800054be:	40 0b       	lddsp	r11,sp[0x0]
800054c0:	0e 9c       	mov	r12,r7
800054c2:	f0 1f 00 3b 	mcall	800055ac <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800054c6:	40 18       	lddsp	r8,sp[0x4]
800054c8:	58 08       	cp.w	r8,0
800054ca:	c1 51       	brne	800054f4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800054cc:	6e e8       	ld.w	r8,r7[0x38]
800054ce:	20 18       	sub	r8,1
800054d0:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800054d2:	6e 08       	ld.w	r8,r7[0x0]
800054d4:	58 08       	cp.w	r8,0
800054d6:	c0 41       	brne	800054de <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800054d8:	f0 1f 00 36 	mcall	800055b0 <xQueueGenericReceive+0x11c>
800054dc:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800054de:	6e 48       	ld.w	r8,r7[0x10]
800054e0:	58 08       	cp.w	r8,0
800054e2:	c1 20       	breq	80005506 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800054e4:	ee cc ff f0 	sub	r12,r7,-16
800054e8:	f0 1f 00 33 	mcall	800055b4 <xQueueGenericReceive+0x120>
800054ec:	58 1c       	cp.w	r12,1
800054ee:	c0 c1       	brne	80005506 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800054f0:	d7 33       	scall
800054f2:	c0 a8       	rjmp	80005506 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800054f4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800054f6:	6e 98       	ld.w	r8,r7[0x24]
800054f8:	58 08       	cp.w	r8,0
800054fa:	c0 60       	breq	80005506 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800054fc:	04 9c       	mov	r12,r2
800054fe:	f0 1f 00 2e 	mcall	800055b4 <xQueueGenericReceive+0x120>
80005502:	c0 20       	breq	80005506 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005504:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005506:	f0 1f 00 2d 	mcall	800055b8 <xQueueGenericReceive+0x124>
8000550a:	30 1c       	mov	r12,1
				return pdPASS;
8000550c:	c4 c8       	rjmp	800055a4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000550e:	40 28       	lddsp	r8,sp[0x8]
80005510:	58 08       	cp.w	r8,0
80005512:	c0 51       	brne	8000551c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005514:	f0 1f 00 29 	mcall	800055b8 <xQueueGenericReceive+0x124>
80005518:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000551a:	c4 58       	rjmp	800055a4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000551c:	58 05       	cp.w	r5,0
8000551e:	c0 51       	brne	80005528 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005520:	08 9c       	mov	r12,r4
80005522:	f0 1f 00 27 	mcall	800055bc <xQueueGenericReceive+0x128>
80005526:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005528:	f0 1f 00 24 	mcall	800055b8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000552c:	f0 1f 00 25 	mcall	800055c0 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005530:	f0 1f 00 1e 	mcall	800055a8 <xQueueGenericReceive+0x114>
80005534:	6f 18       	ld.w	r8,r7[0x44]
80005536:	5b f8       	cp.w	r8,-1
80005538:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000553c:	6f 28       	ld.w	r8,r7[0x48]
8000553e:	5b f8       	cp.w	r8,-1
80005540:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005544:	f0 1f 00 1d 	mcall	800055b8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005548:	06 9b       	mov	r11,r3
8000554a:	08 9c       	mov	r12,r4
8000554c:	f0 1f 00 1e 	mcall	800055c4 <xQueueGenericReceive+0x130>
80005550:	c2 41       	brne	80005598 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005552:	f0 1f 00 16 	mcall	800055a8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005556:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005558:	f0 1f 00 18 	mcall	800055b8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000555c:	58 06       	cp.w	r6,0
8000555e:	c1 71       	brne	8000558c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005560:	6e 08       	ld.w	r8,r7[0x0]
80005562:	58 08       	cp.w	r8,0
80005564:	c0 81       	brne	80005574 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005566:	f0 1f 00 11 	mcall	800055a8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000556a:	6e 1c       	ld.w	r12,r7[0x4]
8000556c:	f0 1f 00 17 	mcall	800055c8 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005570:	f0 1f 00 12 	mcall	800055b8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005574:	40 2b       	lddsp	r11,sp[0x8]
80005576:	04 9c       	mov	r12,r2
80005578:	f0 1f 00 15 	mcall	800055cc <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000557c:	0e 9c       	mov	r12,r7
8000557e:	f0 1f 00 15 	mcall	800055d0 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005582:	f0 1f 00 15 	mcall	800055d4 <xQueueGenericReceive+0x140>
80005586:	c9 61       	brne	800054b2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005588:	d7 33       	scall
8000558a:	c9 4b       	rjmp	800054b2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000558c:	0e 9c       	mov	r12,r7
8000558e:	f0 1f 00 11 	mcall	800055d0 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005592:	f0 1f 00 11 	mcall	800055d4 <xQueueGenericReceive+0x140>
80005596:	c8 eb       	rjmp	800054b2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005598:	0e 9c       	mov	r12,r7
8000559a:	f0 1f 00 0e 	mcall	800055d0 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000559e:	f0 1f 00 0e 	mcall	800055d4 <xQueueGenericReceive+0x140>
800055a2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800055a4:	2f bd       	sub	sp,-20
800055a6:	d8 32       	popm	r0-r7,pc
800055a8:	80 00       	ld.sh	r0,r0[0x0]
800055aa:	50 e0       	stdsp	sp[0x38],r0
800055ac:	80 00       	ld.sh	r0,r0[0x0]
800055ae:	53 74       	stdsp	sp[0xdc],r4
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	59 1c       	cp.w	r12,17
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	5a 04       	cp.w	r4,-32
800055b8:	80 00       	ld.sh	r0,r0[0x0]
800055ba:	51 ec       	stdsp	sp[0x78],r12
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	58 f8       	cp.w	r8,15
800055c0:	80 00       	ld.sh	r0,r0[0x0]
800055c2:	58 6c       	cp.w	r12,6
800055c4:	80 00       	ld.sh	r0,r0[0x0]
800055c6:	5b 94       	cp.w	r4,-7
800055c8:	80 00       	ld.sh	r0,r0[0x0]
800055ca:	59 80       	cp.w	r0,24
800055cc:	80 00       	ld.sh	r0,r0[0x0]
800055ce:	5d ec       	*unknown*
800055d0:	80 00       	ld.sh	r0,r0[0x0]
800055d2:	53 f4       	stdsp	sp[0xfc],r4
800055d4:	80 00       	ld.sh	r0,r0[0x0]
800055d6:	5c 28       	cpc	r8

800055d8 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800055d8:	eb cd 40 80 	pushm	r7,lr
800055dc:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800055de:	79 08       	ld.w	r8,r12[0x40]
800055e0:	58 08       	cp.w	r8,0
800055e2:	c0 a1       	brne	800055f6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800055e4:	78 08       	ld.w	r8,r12[0x0]
800055e6:	58 08       	cp.w	r8,0
800055e8:	c2 b1       	brne	8000563e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800055ea:	78 1c       	ld.w	r12,r12[0x4]
800055ec:	f0 1f 00 17 	mcall	80005648 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800055f0:	30 08       	mov	r8,0
800055f2:	8f 18       	st.w	r7[0x4],r8
800055f4:	c2 58       	rjmp	8000563e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800055f6:	58 0a       	cp.w	r10,0
800055f8:	c1 01       	brne	80005618 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800055fa:	10 9a       	mov	r10,r8
800055fc:	78 2c       	ld.w	r12,r12[0x8]
800055fe:	f0 1f 00 14 	mcall	8000564c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005602:	6e 29       	ld.w	r9,r7[0x8]
80005604:	6f 08       	ld.w	r8,r7[0x40]
80005606:	f2 08 00 08 	add	r8,r9,r8
8000560a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000560c:	6e 19       	ld.w	r9,r7[0x4]
8000560e:	12 38       	cp.w	r8,r9
80005610:	c1 73       	brcs	8000563e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005612:	6e 08       	ld.w	r8,r7[0x0]
80005614:	8f 28       	st.w	r7[0x8],r8
80005616:	c1 48       	rjmp	8000563e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005618:	10 9a       	mov	r10,r8
8000561a:	78 3c       	ld.w	r12,r12[0xc]
8000561c:	f0 1f 00 0c 	mcall	8000564c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005620:	6f 08       	ld.w	r8,r7[0x40]
80005622:	6e 39       	ld.w	r9,r7[0xc]
80005624:	f2 08 01 08 	sub	r8,r9,r8
80005628:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000562a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000562c:	12 38       	cp.w	r8,r9
8000562e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005632:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005636:	f3 d8 e3 19 	subcs	r9,r9,r8
8000563a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000563e:	6e e8       	ld.w	r8,r7[0x38]
80005640:	2f f8       	sub	r8,-1
80005642:	8f e8       	st.w	r7[0x38],r8
}
80005644:	e3 cd 80 80 	ldm	sp++,r7,pc
80005648:	80 00       	ld.sh	r0,r0[0x0]
8000564a:	59 28       	cp.w	r8,18
8000564c:	80 00       	ld.sh	r0,r0[0x0]
8000564e:	6b f0       	ld.w	r0,r5[0x7c]

80005650 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005650:	eb cd 40 c0 	pushm	r6-r7,lr
80005654:	18 97       	mov	r7,r12
80005656:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005658:	78 ec       	ld.w	r12,r12[0x38]
8000565a:	6e f8       	ld.w	r8,r7[0x3c]
8000565c:	10 3c       	cp.w	r12,r8
8000565e:	c0 33       	brcs	80005664 <xQueueGenericSendFromISR+0x14>
80005660:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005664:	12 9a       	mov	r10,r9
80005666:	0e 9c       	mov	r12,r7
80005668:	f0 1f 00 0c 	mcall	80005698 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000566c:	6f 28       	ld.w	r8,r7[0x48]
8000566e:	5b f8       	cp.w	r8,-1
80005670:	c0 d1       	brne	8000568a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005672:	6e 98       	ld.w	r8,r7[0x24]
80005674:	58 08       	cp.w	r8,0
80005676:	c0 f0       	breq	80005694 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005678:	ee cc ff dc 	sub	r12,r7,-36
8000567c:	f0 1f 00 08 	mcall	8000569c <xQueueGenericSendFromISR+0x4c>
80005680:	c0 a0       	breq	80005694 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005682:	30 1c       	mov	r12,1
80005684:	8d 0c       	st.w	r6[0x0],r12
80005686:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000568a:	2f f8       	sub	r8,-1
8000568c:	ef 48 00 48 	st.w	r7[72],r8
80005690:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005694:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005698:	80 00       	ld.sh	r0,r0[0x0]
8000569a:	55 d8       	stdsp	sp[0x174],r8
8000569c:	80 00       	ld.sh	r0,r0[0x0]
8000569e:	5a 04       	cp.w	r4,-32

800056a0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800056a0:	d4 31       	pushm	r0-r7,lr
800056a2:	20 5d       	sub	sp,20
800056a4:	18 97       	mov	r7,r12
800056a6:	50 0b       	stdsp	sp[0x0],r11
800056a8:	50 2a       	stdsp	sp[0x8],r10
800056aa:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800056ac:	f8 c0 ff f0 	sub	r0,r12,-16
800056b0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800056b2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800056b6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800056b8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800056bc:	f0 1f 00 2f 	mcall	80005778 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800056c0:	6e e9       	ld.w	r9,r7[0x38]
800056c2:	6e f8       	ld.w	r8,r7[0x3c]
800056c4:	10 39       	cp.w	r9,r8
800056c6:	c1 42       	brcc	800056ee <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800056c8:	40 1a       	lddsp	r10,sp[0x4]
800056ca:	40 0b       	lddsp	r11,sp[0x0]
800056cc:	0e 9c       	mov	r12,r7
800056ce:	f0 1f 00 2c 	mcall	8000577c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800056d2:	6e 98       	ld.w	r8,r7[0x24]
800056d4:	58 08       	cp.w	r8,0
800056d6:	c0 80       	breq	800056e6 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800056d8:	ee cc ff dc 	sub	r12,r7,-36
800056dc:	f0 1f 00 29 	mcall	80005780 <xQueueGenericSend+0xe0>
800056e0:	58 1c       	cp.w	r12,1
800056e2:	c0 21       	brne	800056e6 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800056e4:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800056e6:	f0 1f 00 28 	mcall	80005784 <xQueueGenericSend+0xe4>
800056ea:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800056ec:	c4 38       	rjmp	80005772 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800056ee:	40 28       	lddsp	r8,sp[0x8]
800056f0:	58 08       	cp.w	r8,0
800056f2:	c0 51       	brne	800056fc <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800056f4:	f0 1f 00 24 	mcall	80005784 <xQueueGenericSend+0xe4>
800056f8:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800056fa:	c3 c8       	rjmp	80005772 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800056fc:	58 04       	cp.w	r4,0
800056fe:	c0 51       	brne	80005708 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005700:	06 9c       	mov	r12,r3
80005702:	f0 1f 00 22 	mcall	80005788 <xQueueGenericSend+0xe8>
80005706:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005708:	f0 1f 00 1f 	mcall	80005784 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000570c:	f0 1f 00 20 	mcall	8000578c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005710:	f0 1f 00 1a 	mcall	80005778 <xQueueGenericSend+0xd8>
80005714:	6f 18       	ld.w	r8,r7[0x44]
80005716:	5b f8       	cp.w	r8,-1
80005718:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000571c:	6f 28       	ld.w	r8,r7[0x48]
8000571e:	5b f8       	cp.w	r8,-1
80005720:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005724:	f0 1f 00 18 	mcall	80005784 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005728:	04 9b       	mov	r11,r2
8000572a:	06 9c       	mov	r12,r3
8000572c:	f0 1f 00 19 	mcall	80005790 <xQueueGenericSend+0xf0>
80005730:	c1 b1       	brne	80005766 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005732:	f0 1f 00 12 	mcall	80005778 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005736:	6e e5       	ld.w	r5,r7[0x38]
80005738:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000573a:	f0 1f 00 13 	mcall	80005784 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000573e:	0c 35       	cp.w	r5,r6
80005740:	c0 d1       	brne	8000575a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005742:	40 2b       	lddsp	r11,sp[0x8]
80005744:	00 9c       	mov	r12,r0
80005746:	f0 1f 00 14 	mcall	80005794 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000574a:	0e 9c       	mov	r12,r7
8000574c:	f0 1f 00 13 	mcall	80005798 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005750:	f0 1f 00 13 	mcall	8000579c <xQueueGenericSend+0xfc>
80005754:	cb 41       	brne	800056bc <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005756:	d7 33       	scall
80005758:	cb 2b       	rjmp	800056bc <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000575a:	0e 9c       	mov	r12,r7
8000575c:	f0 1f 00 0f 	mcall	80005798 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005760:	f0 1f 00 0f 	mcall	8000579c <xQueueGenericSend+0xfc>
80005764:	ca cb       	rjmp	800056bc <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005766:	0e 9c       	mov	r12,r7
80005768:	f0 1f 00 0c 	mcall	80005798 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000576c:	f0 1f 00 0c 	mcall	8000579c <xQueueGenericSend+0xfc>
80005770:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005772:	2f bd       	sub	sp,-20
80005774:	d8 32       	popm	r0-r7,pc
80005776:	00 00       	add	r0,r0
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	50 e0       	stdsp	sp[0x38],r0
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	55 d8       	stdsp	sp[0x174],r8
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	5a 04       	cp.w	r4,-32
80005784:	80 00       	ld.sh	r0,r0[0x0]
80005786:	51 ec       	stdsp	sp[0x78],r12
80005788:	80 00       	ld.sh	r0,r0[0x0]
8000578a:	58 f8       	cp.w	r8,15
8000578c:	80 00       	ld.sh	r0,r0[0x0]
8000578e:	58 6c       	cp.w	r12,6
80005790:	80 00       	ld.sh	r0,r0[0x0]
80005792:	5b 94       	cp.w	r4,-7
80005794:	80 00       	ld.sh	r0,r0[0x0]
80005796:	5d ec       	*unknown*
80005798:	80 00       	ld.sh	r0,r0[0x0]
8000579a:	53 f4       	stdsp	sp[0xfc],r4
8000579c:	80 00       	ld.sh	r0,r0[0x0]
8000579e:	5c 28       	cpc	r8

800057a0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800057a0:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800057a4:	34 cc       	mov	r12,76
800057a6:	f0 1f 00 12 	mcall	800057ec <xQueueCreateMutex+0x4c>
800057aa:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800057ac:	c1 d0       	breq	800057e6 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800057ae:	30 06       	mov	r6,0
800057b0:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800057b2:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800057b4:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800057b6:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800057b8:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800057ba:	30 18       	mov	r8,1
800057bc:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800057be:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800057c2:	3f f8       	mov	r8,-1
800057c4:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800057c8:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800057cc:	2f 0c       	sub	r12,-16
800057ce:	f0 1f 00 09 	mcall	800057f0 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800057d2:	ee cc ff dc 	sub	r12,r7,-36
800057d6:	f0 1f 00 07 	mcall	800057f0 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800057da:	0c 99       	mov	r9,r6
800057dc:	0c 9a       	mov	r10,r6
800057de:	0c 9b       	mov	r11,r6
800057e0:	0e 9c       	mov	r12,r7
800057e2:	f0 1f 00 05 	mcall	800057f4 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800057e6:	0e 9c       	mov	r12,r7
800057e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800057ec:	80 00       	ld.sh	r0,r0[0x0]
800057ee:	53 4c       	stdsp	sp[0xd0],r12
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	4f bc       	lddpc	r12,800059dc <vTaskPriorityInherit+0x5c>
800057f4:	80 00       	ld.sh	r0,r0[0x0]
800057f6:	56 a0       	stdsp	sp[0x1a8],r0

800057f8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800057f8:	d4 21       	pushm	r4-r7,lr
800057fa:	18 97       	mov	r7,r12
800057fc:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800057fe:	58 0c       	cp.w	r12,0
80005800:	c2 f0       	breq	8000585e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005802:	34 cc       	mov	r12,76
80005804:	f0 1f 00 17 	mcall	80005860 <xQueueCreate+0x68>
80005808:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000580a:	c2 a0       	breq	8000585e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000580c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005810:	e8 cc ff ff 	sub	r12,r4,-1
80005814:	f0 1f 00 13 	mcall	80005860 <xQueueCreate+0x68>
80005818:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000581a:	c1 e0       	breq	80005856 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000581c:	f8 04 00 04 	add	r4,r12,r4
80005820:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005822:	30 08       	mov	r8,0
80005824:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005826:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005828:	ee c8 00 01 	sub	r8,r7,1
8000582c:	ad 38       	mul	r8,r6
8000582e:	10 0c       	add	r12,r8
80005830:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005832:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005834:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005838:	3f f8       	mov	r8,-1
8000583a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
8000583e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005842:	ea cc ff f0 	sub	r12,r5,-16
80005846:	f0 1f 00 08 	mcall	80005864 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000584a:	ea cc ff dc 	sub	r12,r5,-36
8000584e:	f0 1f 00 06 	mcall	80005864 <xQueueCreate+0x6c>
80005852:	0a 9c       	mov	r12,r5
80005854:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005856:	0a 9c       	mov	r12,r5
80005858:	f0 1f 00 04 	mcall	80005868 <xQueueCreate+0x70>
8000585c:	d8 2a       	popm	r4-r7,pc,r12=0
8000585e:	d8 2a       	popm	r4-r7,pc,r12=0
80005860:	80 00       	ld.sh	r0,r0[0x0]
80005862:	53 4c       	stdsp	sp[0xd0],r12
80005864:	80 00       	ld.sh	r0,r0[0x0]
80005866:	4f bc       	lddpc	r12,80005a50 <xTaskRemoveFromEventList+0x4c>
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	53 24       	stdsp	sp[0xc8],r4

8000586c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000586c:	48 38       	lddpc	r8,80005878 <vTaskSuspendAll+0xc>
8000586e:	70 09       	ld.w	r9,r8[0x0]
80005870:	2f f9       	sub	r9,-1
80005872:	91 09       	st.w	r8[0x0],r9
}
80005874:	5e fc       	retal	r12
80005876:	00 00       	add	r0,r0
80005878:	00 00       	add	r0,r0
8000587a:	0d 1c       	ld.sh	r12,r6++

8000587c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000587c:	49 a8       	lddpc	r8,800058e4 <vTaskSwitchContext+0x68>
8000587e:	70 08       	ld.w	r8,r8[0x0]
80005880:	58 08       	cp.w	r8,0
80005882:	c0 b1       	brne	80005898 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005884:	49 98       	lddpc	r8,800058e8 <vTaskSwitchContext+0x6c>
80005886:	70 08       	ld.w	r8,r8[0x0]
80005888:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000588c:	49 89       	lddpc	r9,800058ec <vTaskSwitchContext+0x70>
8000588e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005892:	58 08       	cp.w	r8,0
80005894:	c0 60       	breq	800058a0 <vTaskSwitchContext+0x24>
80005896:	c1 18       	rjmp	800058b8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005898:	30 19       	mov	r9,1
8000589a:	49 68       	lddpc	r8,800058f0 <vTaskSwitchContext+0x74>
8000589c:	91 09       	st.w	r8[0x0],r9
8000589e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800058a0:	49 28       	lddpc	r8,800058e8 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800058a2:	49 3a       	lddpc	r10,800058ec <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800058a4:	70 09       	ld.w	r9,r8[0x0]
800058a6:	20 19       	sub	r9,1
800058a8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800058aa:	70 09       	ld.w	r9,r8[0x0]
800058ac:	f2 09 00 29 	add	r9,r9,r9<<0x2
800058b0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800058b4:	58 09       	cp.w	r9,0
800058b6:	cf 70       	breq	800058a4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800058b8:	48 c8       	lddpc	r8,800058e8 <vTaskSwitchContext+0x6c>
800058ba:	70 08       	ld.w	r8,r8[0x0]
800058bc:	f0 08 00 28 	add	r8,r8,r8<<0x2
800058c0:	48 b9       	lddpc	r9,800058ec <vTaskSwitchContext+0x70>
800058c2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800058c6:	70 19       	ld.w	r9,r8[0x4]
800058c8:	72 19       	ld.w	r9,r9[0x4]
800058ca:	91 19       	st.w	r8[0x4],r9
800058cc:	f0 ca ff f8 	sub	r10,r8,-8
800058d0:	14 39       	cp.w	r9,r10
800058d2:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800058d6:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800058da:	70 18       	ld.w	r8,r8[0x4]
800058dc:	70 39       	ld.w	r9,r8[0xc]
800058de:	48 68       	lddpc	r8,800058f4 <vTaskSwitchContext+0x78>
800058e0:	91 09       	st.w	r8[0x0],r9
800058e2:	5e fc       	retal	r12
800058e4:	00 00       	add	r0,r0
800058e6:	0d 1c       	ld.sh	r12,r6++
800058e8:	00 00       	add	r0,r0
800058ea:	0d 54       	ld.sh	r4,--r6
800058ec:	00 00       	add	r0,r0
800058ee:	0c 38       	cp.w	r8,r6
800058f0:	00 00       	add	r0,r0
800058f2:	0d 3c       	ld.ub	r12,r6++
800058f4:	00 00       	add	r0,r0
800058f6:	0c ec       	st.h	--r6,r12

800058f8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800058f8:	48 48       	lddpc	r8,80005908 <vTaskSetTimeOutState+0x10>
800058fa:	70 08       	ld.w	r8,r8[0x0]
800058fc:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800058fe:	48 48       	lddpc	r8,8000590c <vTaskSetTimeOutState+0x14>
80005900:	70 08       	ld.w	r8,r8[0x0]
80005902:	99 18       	st.w	r12[0x4],r8
}
80005904:	5e fc       	retal	r12
80005906:	00 00       	add	r0,r0
80005908:	00 00       	add	r0,r0
8000590a:	0c 30       	cp.w	r0,r6
8000590c:	00 00       	add	r0,r0
8000590e:	0d 18       	ld.sh	r8,r6++

80005910 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005910:	30 19       	mov	r9,1
80005912:	48 28       	lddpc	r8,80005918 <vTaskMissedYield+0x8>
80005914:	91 09       	st.w	r8[0x0],r9
}
80005916:	5e fc       	retal	r12
80005918:	00 00       	add	r0,r0
8000591a:	0d 3c       	ld.ub	r12,r6++

8000591c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
8000591c:	48 28       	lddpc	r8,80005924 <xTaskGetCurrentTaskHandle+0x8>
8000591e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005920:	5e fc       	retal	r12
80005922:	00 00       	add	r0,r0
80005924:	00 00       	add	r0,r0
80005926:	0c ec       	st.h	--r6,r12

80005928 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005928:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
8000592c:	58 0c       	cp.w	r12,0
8000592e:	c1 f0       	breq	8000596c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005930:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005932:	78 b9       	ld.w	r9,r12[0x2c]
80005934:	79 18       	ld.w	r8,r12[0x44]
80005936:	10 39       	cp.w	r9,r8
80005938:	c1 a0       	breq	8000596c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000593a:	f8 c6 ff fc 	sub	r6,r12,-4
8000593e:	0c 9c       	mov	r12,r6
80005940:	f0 1f 00 0c 	mcall	80005970 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005944:	6f 1c       	ld.w	r12,r7[0x44]
80005946:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005948:	f8 08 11 08 	rsub	r8,r12,8
8000594c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
8000594e:	48 a8       	lddpc	r8,80005974 <vTaskPriorityDisinherit+0x4c>
80005950:	70 08       	ld.w	r8,r8[0x0]
80005952:	10 3c       	cp.w	r12,r8
80005954:	e0 88 00 04 	brls	8000595c <vTaskPriorityDisinherit+0x34>
80005958:	48 78       	lddpc	r8,80005974 <vTaskPriorityDisinherit+0x4c>
8000595a:	91 0c       	st.w	r8[0x0],r12
8000595c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005960:	0c 9b       	mov	r11,r6
80005962:	48 68       	lddpc	r8,80005978 <vTaskPriorityDisinherit+0x50>
80005964:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005968:	f0 1f 00 05 	mcall	8000597c <vTaskPriorityDisinherit+0x54>
8000596c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005970:	80 00       	ld.sh	r0,r0[0x0]
80005972:	50 26       	stdsp	sp[0x8],r6
80005974:	00 00       	add	r0,r0
80005976:	0d 54       	ld.sh	r4,--r6
80005978:	00 00       	add	r0,r0
8000597a:	0c 38       	cp.w	r8,r6
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	4f d6       	lddpc	r6,80005b70 <vTaskIncrementTick+0xf0>

80005980 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005980:	eb cd 40 c0 	pushm	r6-r7,lr
80005984:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005986:	49 b8       	lddpc	r8,800059f0 <vTaskPriorityInherit+0x70>
80005988:	70 08       	ld.w	r8,r8[0x0]
8000598a:	78 b9       	ld.w	r9,r12[0x2c]
8000598c:	70 b8       	ld.w	r8,r8[0x2c]
8000598e:	10 39       	cp.w	r9,r8
80005990:	c2 d2       	brcc	800059ea <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005992:	49 88       	lddpc	r8,800059f0 <vTaskPriorityInherit+0x70>
80005994:	70 08       	ld.w	r8,r8[0x0]
80005996:	70 b8       	ld.w	r8,r8[0x2c]
80005998:	f0 08 11 08 	rsub	r8,r8,8
8000599c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000599e:	f2 09 00 28 	add	r8,r9,r9<<0x2
800059a2:	49 59       	lddpc	r9,800059f4 <vTaskPriorityInherit+0x74>
800059a4:	f2 08 00 28 	add	r8,r9,r8<<0x2
800059a8:	78 59       	ld.w	r9,r12[0x14]
800059aa:	10 39       	cp.w	r9,r8
800059ac:	c1 b1       	brne	800059e2 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800059ae:	f8 c6 ff fc 	sub	r6,r12,-4
800059b2:	0c 9c       	mov	r12,r6
800059b4:	f0 1f 00 11 	mcall	800059f8 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800059b8:	48 e8       	lddpc	r8,800059f0 <vTaskPriorityInherit+0x70>
800059ba:	70 08       	ld.w	r8,r8[0x0]
800059bc:	70 bc       	ld.w	r12,r8[0x2c]
800059be:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800059c0:	48 f8       	lddpc	r8,800059fc <vTaskPriorityInherit+0x7c>
800059c2:	70 08       	ld.w	r8,r8[0x0]
800059c4:	10 3c       	cp.w	r12,r8
800059c6:	e0 88 00 04 	brls	800059ce <vTaskPriorityInherit+0x4e>
800059ca:	48 d8       	lddpc	r8,800059fc <vTaskPriorityInherit+0x7c>
800059cc:	91 0c       	st.w	r8[0x0],r12
800059ce:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800059d2:	0c 9b       	mov	r11,r6
800059d4:	48 88       	lddpc	r8,800059f4 <vTaskPriorityInherit+0x74>
800059d6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800059da:	f0 1f 00 0a 	mcall	80005a00 <vTaskPriorityInherit+0x80>
800059de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800059e2:	48 48       	lddpc	r8,800059f0 <vTaskPriorityInherit+0x70>
800059e4:	70 08       	ld.w	r8,r8[0x0]
800059e6:	70 b8       	ld.w	r8,r8[0x2c]
800059e8:	99 b8       	st.w	r12[0x2c],r8
800059ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059ee:	00 00       	add	r0,r0
800059f0:	00 00       	add	r0,r0
800059f2:	0c ec       	st.h	--r6,r12
800059f4:	00 00       	add	r0,r0
800059f6:	0c 38       	cp.w	r8,r6
800059f8:	80 00       	ld.sh	r0,r0[0x0]
800059fa:	50 26       	stdsp	sp[0x8],r6
800059fc:	00 00       	add	r0,r0
800059fe:	0d 54       	ld.sh	r4,--r6
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	4f d6       	lddpc	r6,80005bf4 <xTaskCheckForTimeOut+0x60>

80005a04 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005a04:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005a08:	78 38       	ld.w	r8,r12[0xc]
80005a0a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005a0c:	ee c6 ff e8 	sub	r6,r7,-24
80005a10:	0c 9c       	mov	r12,r6
80005a12:	f0 1f 00 15 	mcall	80005a64 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a16:	49 58       	lddpc	r8,80005a68 <xTaskRemoveFromEventList+0x64>
80005a18:	70 08       	ld.w	r8,r8[0x0]
80005a1a:	58 08       	cp.w	r8,0
80005a1c:	c1 71       	brne	80005a4a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005a1e:	ee c6 ff fc 	sub	r6,r7,-4
80005a22:	0c 9c       	mov	r12,r6
80005a24:	f0 1f 00 10 	mcall	80005a64 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005a28:	6e bc       	ld.w	r12,r7[0x2c]
80005a2a:	49 18       	lddpc	r8,80005a6c <xTaskRemoveFromEventList+0x68>
80005a2c:	70 08       	ld.w	r8,r8[0x0]
80005a2e:	10 3c       	cp.w	r12,r8
80005a30:	e0 88 00 04 	brls	80005a38 <xTaskRemoveFromEventList+0x34>
80005a34:	48 e8       	lddpc	r8,80005a6c <xTaskRemoveFromEventList+0x68>
80005a36:	91 0c       	st.w	r8[0x0],r12
80005a38:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a3c:	0c 9b       	mov	r11,r6
80005a3e:	48 d8       	lddpc	r8,80005a70 <xTaskRemoveFromEventList+0x6c>
80005a40:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005a44:	f0 1f 00 0c 	mcall	80005a74 <xTaskRemoveFromEventList+0x70>
80005a48:	c0 58       	rjmp	80005a52 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005a4a:	0c 9b       	mov	r11,r6
80005a4c:	48 bc       	lddpc	r12,80005a78 <xTaskRemoveFromEventList+0x74>
80005a4e:	f0 1f 00 0a 	mcall	80005a74 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005a52:	48 b8       	lddpc	r8,80005a7c <xTaskRemoveFromEventList+0x78>
80005a54:	70 08       	ld.w	r8,r8[0x0]
80005a56:	6e b9       	ld.w	r9,r7[0x2c]
80005a58:	70 b8       	ld.w	r8,r8[0x2c]
80005a5a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005a5c:	5f 2c       	srhs	r12
80005a5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a62:	00 00       	add	r0,r0
80005a64:	80 00       	ld.sh	r0,r0[0x0]
80005a66:	50 26       	stdsp	sp[0x8],r6
80005a68:	00 00       	add	r0,r0
80005a6a:	0d 1c       	ld.sh	r12,r6++
80005a6c:	00 00       	add	r0,r0
80005a6e:	0d 54       	ld.sh	r4,--r6
80005a70:	00 00       	add	r0,r0
80005a72:	0c 38       	cp.w	r8,r6
80005a74:	80 00       	ld.sh	r0,r0[0x0]
80005a76:	4f d6       	lddpc	r6,80005c68 <xTaskResumeAll+0x40>
80005a78:	00 00       	add	r0,r0
80005a7a:	0c f0       	st.b	--r6,r0
80005a7c:	00 00       	add	r0,r0
80005a7e:	0c ec       	st.h	--r6,r12

80005a80 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005a80:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a84:	4b 98       	lddpc	r8,80005b68 <vTaskIncrementTick+0xe8>
80005a86:	70 08       	ld.w	r8,r8[0x0]
80005a88:	58 08       	cp.w	r8,0
80005a8a:	c6 91       	brne	80005b5c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005a8c:	4b 88       	lddpc	r8,80005b6c <vTaskIncrementTick+0xec>
80005a8e:	70 09       	ld.w	r9,r8[0x0]
80005a90:	2f f9       	sub	r9,-1
80005a92:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005a94:	70 08       	ld.w	r8,r8[0x0]
80005a96:	58 08       	cp.w	r8,0
80005a98:	c1 a1       	brne	80005acc <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005a9a:	4b 68       	lddpc	r8,80005b70 <vTaskIncrementTick+0xf0>
80005a9c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005a9e:	4b 69       	lddpc	r9,80005b74 <vTaskIncrementTick+0xf4>
80005aa0:	72 0b       	ld.w	r11,r9[0x0]
80005aa2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005aa4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005aa6:	4b 59       	lddpc	r9,80005b78 <vTaskIncrementTick+0xf8>
80005aa8:	72 0a       	ld.w	r10,r9[0x0]
80005aaa:	2f fa       	sub	r10,-1
80005aac:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005aae:	70 08       	ld.w	r8,r8[0x0]
80005ab0:	70 08       	ld.w	r8,r8[0x0]
80005ab2:	58 08       	cp.w	r8,0
80005ab4:	c0 51       	brne	80005abe <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005ab6:	3f f9       	mov	r9,-1
80005ab8:	4b 18       	lddpc	r8,80005b7c <vTaskIncrementTick+0xfc>
80005aba:	91 09       	st.w	r8[0x0],r9
80005abc:	c0 88       	rjmp	80005acc <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005abe:	4a d8       	lddpc	r8,80005b70 <vTaskIncrementTick+0xf0>
80005ac0:	70 08       	ld.w	r8,r8[0x0]
80005ac2:	70 38       	ld.w	r8,r8[0xc]
80005ac4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005ac6:	70 19       	ld.w	r9,r8[0x4]
80005ac8:	4a d8       	lddpc	r8,80005b7c <vTaskIncrementTick+0xfc>
80005aca:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005acc:	4a 88       	lddpc	r8,80005b6c <vTaskIncrementTick+0xec>
80005ace:	70 09       	ld.w	r9,r8[0x0]
80005ad0:	4a b8       	lddpc	r8,80005b7c <vTaskIncrementTick+0xfc>
80005ad2:	70 08       	ld.w	r8,r8[0x0]
80005ad4:	10 39       	cp.w	r9,r8
80005ad6:	c4 73       	brcs	80005b64 <vTaskIncrementTick+0xe4>
80005ad8:	4a 68       	lddpc	r8,80005b70 <vTaskIncrementTick+0xf0>
80005ada:	70 08       	ld.w	r8,r8[0x0]
80005adc:	70 08       	ld.w	r8,r8[0x0]
80005ade:	58 08       	cp.w	r8,0
80005ae0:	c0 c0       	breq	80005af8 <vTaskIncrementTick+0x78>
80005ae2:	4a 48       	lddpc	r8,80005b70 <vTaskIncrementTick+0xf0>
80005ae4:	70 08       	ld.w	r8,r8[0x0]
80005ae6:	70 38       	ld.w	r8,r8[0xc]
80005ae8:	70 37       	ld.w	r7,r8[0xc]
80005aea:	6e 18       	ld.w	r8,r7[0x4]
80005aec:	4a 09       	lddpc	r9,80005b6c <vTaskIncrementTick+0xec>
80005aee:	72 09       	ld.w	r9,r9[0x0]
80005af0:	12 38       	cp.w	r8,r9
80005af2:	e0 88 00 14 	brls	80005b1a <vTaskIncrementTick+0x9a>
80005af6:	c0 e8       	rjmp	80005b12 <vTaskIncrementTick+0x92>
80005af8:	3f f9       	mov	r9,-1
80005afa:	4a 18       	lddpc	r8,80005b7c <vTaskIncrementTick+0xfc>
80005afc:	91 09       	st.w	r8[0x0],r9
80005afe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005b02:	6a 08       	ld.w	r8,r5[0x0]
80005b04:	70 38       	ld.w	r8,r8[0xc]
80005b06:	70 37       	ld.w	r7,r8[0xc]
80005b08:	6e 18       	ld.w	r8,r7[0x4]
80005b0a:	64 09       	ld.w	r9,r2[0x0]
80005b0c:	12 38       	cp.w	r8,r9
80005b0e:	e0 88 00 0a 	brls	80005b22 <vTaskIncrementTick+0xa2>
80005b12:	49 b9       	lddpc	r9,80005b7c <vTaskIncrementTick+0xfc>
80005b14:	93 08       	st.w	r9[0x0],r8
80005b16:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005b1a:	49 a4       	lddpc	r4,80005b80 <vTaskIncrementTick+0x100>
80005b1c:	49 a3       	lddpc	r3,80005b84 <vTaskIncrementTick+0x104>
80005b1e:	49 55       	lddpc	r5,80005b70 <vTaskIncrementTick+0xf0>
80005b20:	49 32       	lddpc	r2,80005b6c <vTaskIncrementTick+0xec>
80005b22:	ee c6 ff fc 	sub	r6,r7,-4
80005b26:	0c 9c       	mov	r12,r6
80005b28:	f0 1f 00 18 	mcall	80005b88 <vTaskIncrementTick+0x108>
80005b2c:	6e a8       	ld.w	r8,r7[0x28]
80005b2e:	58 08       	cp.w	r8,0
80005b30:	c0 50       	breq	80005b3a <vTaskIncrementTick+0xba>
80005b32:	ee cc ff e8 	sub	r12,r7,-24
80005b36:	f0 1f 00 15 	mcall	80005b88 <vTaskIncrementTick+0x108>
80005b3a:	6e bc       	ld.w	r12,r7[0x2c]
80005b3c:	68 08       	ld.w	r8,r4[0x0]
80005b3e:	10 3c       	cp.w	r12,r8
80005b40:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005b44:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005b48:	0c 9b       	mov	r11,r6
80005b4a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005b4e:	f0 1f 00 10 	mcall	80005b8c <vTaskIncrementTick+0x10c>
80005b52:	6a 08       	ld.w	r8,r5[0x0]
80005b54:	70 08       	ld.w	r8,r8[0x0]
80005b56:	58 08       	cp.w	r8,0
80005b58:	cd 51       	brne	80005b02 <vTaskIncrementTick+0x82>
80005b5a:	cc fb       	rjmp	80005af8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005b5c:	48 d8       	lddpc	r8,80005b90 <vTaskIncrementTick+0x110>
80005b5e:	70 09       	ld.w	r9,r8[0x0]
80005b60:	2f f9       	sub	r9,-1
80005b62:	91 09       	st.w	r8[0x0],r9
80005b64:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005b68:	00 00       	add	r0,r0
80005b6a:	0d 1c       	ld.sh	r12,r6++
80005b6c:	00 00       	add	r0,r0
80005b6e:	0d 18       	ld.sh	r8,r6++
80005b70:	00 00       	add	r0,r0
80005b72:	0c 24       	rsub	r4,r6
80005b74:	00 00       	add	r0,r0
80005b76:	0c 34       	cp.w	r4,r6
80005b78:	00 00       	add	r0,r0
80005b7a:	0c 30       	cp.w	r0,r6
80005b7c:	00 00       	add	r0,r0
80005b7e:	05 2c       	ld.uh	r12,r2++
80005b80:	00 00       	add	r0,r0
80005b82:	0d 54       	ld.sh	r4,--r6
80005b84:	00 00       	add	r0,r0
80005b86:	0c 38       	cp.w	r8,r6
80005b88:	80 00       	ld.sh	r0,r0[0x0]
80005b8a:	50 26       	stdsp	sp[0x8],r6
80005b8c:	80 00       	ld.sh	r0,r0[0x0]
80005b8e:	4f d6       	lddpc	r6,80005d80 <vTaskDelayUntil+0x14>
80005b90:	00 00       	add	r0,r0
80005b92:	0c 1c       	sub	r12,r6

80005b94 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005b94:	eb cd 40 c0 	pushm	r6-r7,lr
80005b98:	18 97       	mov	r7,r12
80005b9a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005b9c:	f0 1f 00 15 	mcall	80005bf0 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005ba0:	6c 08       	ld.w	r8,r6[0x0]
80005ba2:	5b f8       	cp.w	r8,-1
80005ba4:	c0 31       	brne	80005baa <xTaskCheckForTimeOut+0x16>
80005ba6:	30 07       	mov	r7,0
80005ba8:	c1 f8       	rjmp	80005be6 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005baa:	49 39       	lddpc	r9,80005bf4 <xTaskCheckForTimeOut+0x60>
80005bac:	72 09       	ld.w	r9,r9[0x0]
80005bae:	6e 0a       	ld.w	r10,r7[0x0]
80005bb0:	12 3a       	cp.w	r10,r9
80005bb2:	c0 70       	breq	80005bc0 <xTaskCheckForTimeOut+0x2c>
80005bb4:	49 19       	lddpc	r9,80005bf8 <xTaskCheckForTimeOut+0x64>
80005bb6:	72 09       	ld.w	r9,r9[0x0]
80005bb8:	6e 1a       	ld.w	r10,r7[0x4]
80005bba:	12 3a       	cp.w	r10,r9
80005bbc:	e0 88 00 14 	brls	80005be4 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005bc0:	48 e9       	lddpc	r9,80005bf8 <xTaskCheckForTimeOut+0x64>
80005bc2:	72 0a       	ld.w	r10,r9[0x0]
80005bc4:	6e 19       	ld.w	r9,r7[0x4]
80005bc6:	12 1a       	sub	r10,r9
80005bc8:	14 38       	cp.w	r8,r10
80005bca:	e0 88 00 0d 	brls	80005be4 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005bce:	48 ba       	lddpc	r10,80005bf8 <xTaskCheckForTimeOut+0x64>
80005bd0:	74 0a       	ld.w	r10,r10[0x0]
80005bd2:	14 19       	sub	r9,r10
80005bd4:	f2 08 00 08 	add	r8,r9,r8
80005bd8:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005bda:	0e 9c       	mov	r12,r7
80005bdc:	f0 1f 00 08 	mcall	80005bfc <xTaskCheckForTimeOut+0x68>
80005be0:	30 07       	mov	r7,0
80005be2:	c0 28       	rjmp	80005be6 <xTaskCheckForTimeOut+0x52>
80005be4:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005be6:	f0 1f 00 07 	mcall	80005c00 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005bea:	0e 9c       	mov	r12,r7
80005bec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bf0:	80 00       	ld.sh	r0,r0[0x0]
80005bf2:	50 e0       	stdsp	sp[0x38],r0
80005bf4:	00 00       	add	r0,r0
80005bf6:	0c 30       	cp.w	r0,r6
80005bf8:	00 00       	add	r0,r0
80005bfa:	0d 18       	ld.sh	r8,r6++
80005bfc:	80 00       	ld.sh	r0,r0[0x0]
80005bfe:	58 f8       	cp.w	r8,15
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	51 ec       	stdsp	sp[0x78],r12

80005c04 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005c04:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005c08:	f0 1f 00 05 	mcall	80005c1c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005c0c:	48 58       	lddpc	r8,80005c20 <xTaskGetTickCount+0x1c>
80005c0e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005c10:	f0 1f 00 05 	mcall	80005c24 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005c14:	0e 9c       	mov	r12,r7
80005c16:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c1a:	00 00       	add	r0,r0
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	50 e0       	stdsp	sp[0x38],r0
80005c20:	00 00       	add	r0,r0
80005c22:	0d 18       	ld.sh	r8,r6++
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	51 ec       	stdsp	sp[0x78],r12

80005c28 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005c28:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005c2c:	f0 1f 00 2c 	mcall	80005cdc <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005c30:	4a c8       	lddpc	r8,80005ce0 <xTaskResumeAll+0xb8>
80005c32:	70 09       	ld.w	r9,r8[0x0]
80005c34:	20 19       	sub	r9,1
80005c36:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005c38:	70 08       	ld.w	r8,r8[0x0]
80005c3a:	58 08       	cp.w	r8,0
80005c3c:	c4 91       	brne	80005cce <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005c3e:	4a a8       	lddpc	r8,80005ce4 <xTaskResumeAll+0xbc>
80005c40:	70 08       	ld.w	r8,r8[0x0]
80005c42:	58 08       	cp.w	r8,0
80005c44:	c4 50       	breq	80005cce <xTaskResumeAll+0xa6>
80005c46:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005c48:	4a 85       	lddpc	r5,80005ce8 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005c4a:	4a 93       	lddpc	r3,80005cec <xTaskResumeAll+0xc4>
80005c4c:	4a 92       	lddpc	r2,80005cf0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c4e:	4a a1       	lddpc	r1,80005cf4 <xTaskResumeAll+0xcc>
80005c50:	c1 e8       	rjmp	80005c8c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005c52:	6a 38       	ld.w	r8,r5[0xc]
80005c54:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005c56:	ee cc ff e8 	sub	r12,r7,-24
80005c5a:	f0 1f 00 28 	mcall	80005cf8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005c5e:	ee c6 ff fc 	sub	r6,r7,-4
80005c62:	0c 9c       	mov	r12,r6
80005c64:	f0 1f 00 25 	mcall	80005cf8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005c68:	6e bc       	ld.w	r12,r7[0x2c]
80005c6a:	66 08       	ld.w	r8,r3[0x0]
80005c6c:	10 3c       	cp.w	r12,r8
80005c6e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005c72:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005c76:	0c 9b       	mov	r11,r6
80005c78:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005c7c:	f0 1f 00 20 	mcall	80005cfc <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c80:	62 08       	ld.w	r8,r1[0x0]
80005c82:	6e b9       	ld.w	r9,r7[0x2c]
80005c84:	70 b8       	ld.w	r8,r8[0x2c]
80005c86:	10 39       	cp.w	r9,r8
80005c88:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005c8c:	6a 08       	ld.w	r8,r5[0x0]
80005c8e:	58 08       	cp.w	r8,0
80005c90:	ce 11       	brne	80005c52 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c92:	49 c8       	lddpc	r8,80005d00 <xTaskResumeAll+0xd8>
80005c94:	70 08       	ld.w	r8,r8[0x0]
80005c96:	58 08       	cp.w	r8,0
80005c98:	c0 f0       	breq	80005cb6 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c9a:	49 a8       	lddpc	r8,80005d00 <xTaskResumeAll+0xd8>
80005c9c:	70 08       	ld.w	r8,r8[0x0]
80005c9e:	58 08       	cp.w	r8,0
80005ca0:	c1 10       	breq	80005cc2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005ca2:	49 87       	lddpc	r7,80005d00 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005ca4:	f0 1f 00 18 	mcall	80005d04 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005ca8:	6e 08       	ld.w	r8,r7[0x0]
80005caa:	20 18       	sub	r8,1
80005cac:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005cae:	6e 08       	ld.w	r8,r7[0x0]
80005cb0:	58 08       	cp.w	r8,0
80005cb2:	cf 91       	brne	80005ca4 <xTaskResumeAll+0x7c>
80005cb4:	c0 78       	rjmp	80005cc2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005cb6:	58 14       	cp.w	r4,1
80005cb8:	c0 50       	breq	80005cc2 <xTaskResumeAll+0x9a>
80005cba:	49 48       	lddpc	r8,80005d08 <xTaskResumeAll+0xe0>
80005cbc:	70 08       	ld.w	r8,r8[0x0]
80005cbe:	58 18       	cp.w	r8,1
80005cc0:	c0 71       	brne	80005cce <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005cc2:	30 09       	mov	r9,0
80005cc4:	49 18       	lddpc	r8,80005d08 <xTaskResumeAll+0xe0>
80005cc6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005cc8:	d7 33       	scall
80005cca:	30 17       	mov	r7,1
80005ccc:	c0 28       	rjmp	80005cd0 <xTaskResumeAll+0xa8>
80005cce:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005cd0:	f0 1f 00 0f 	mcall	80005d0c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005cd4:	0e 9c       	mov	r12,r7
80005cd6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005cda:	00 00       	add	r0,r0
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	50 e0       	stdsp	sp[0x38],r0
80005ce0:	00 00       	add	r0,r0
80005ce2:	0d 1c       	ld.sh	r12,r6++
80005ce4:	00 00       	add	r0,r0
80005ce6:	0d 38       	ld.ub	r8,r6++
80005ce8:	00 00       	add	r0,r0
80005cea:	0c f0       	st.b	--r6,r0
80005cec:	00 00       	add	r0,r0
80005cee:	0d 54       	ld.sh	r4,--r6
80005cf0:	00 00       	add	r0,r0
80005cf2:	0c 38       	cp.w	r8,r6
80005cf4:	00 00       	add	r0,r0
80005cf6:	0c ec       	st.h	--r6,r12
80005cf8:	80 00       	ld.sh	r0,r0[0x0]
80005cfa:	50 26       	stdsp	sp[0x8],r6
80005cfc:	80 00       	ld.sh	r0,r0[0x0]
80005cfe:	4f d6       	lddpc	r6,80005ef0 <xTaskGenericCreate+0x24>
80005d00:	00 00       	add	r0,r0
80005d02:	0c 1c       	sub	r12,r6
80005d04:	80 00       	ld.sh	r0,r0[0x0]
80005d06:	5a 80       	cp.w	r0,-24
80005d08:	00 00       	add	r0,r0
80005d0a:	0d 3c       	ld.ub	r12,r6++
80005d0c:	80 00       	ld.sh	r0,r0[0x0]
80005d0e:	51 ec       	stdsp	sp[0x78],r12

80005d10 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005d10:	eb cd 40 80 	pushm	r7,lr
80005d14:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005d16:	49 08       	lddpc	r8,80005d54 <prvAddCurrentTaskToDelayedList+0x44>
80005d18:	70 08       	ld.w	r8,r8[0x0]
80005d1a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005d1c:	48 f8       	lddpc	r8,80005d58 <prvAddCurrentTaskToDelayedList+0x48>
80005d1e:	70 08       	ld.w	r8,r8[0x0]
80005d20:	10 3c       	cp.w	r12,r8
80005d22:	c0 a2       	brcc	80005d36 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d24:	48 c8       	lddpc	r8,80005d54 <prvAddCurrentTaskToDelayedList+0x44>
80005d26:	70 0b       	ld.w	r11,r8[0x0]
80005d28:	48 d8       	lddpc	r8,80005d5c <prvAddCurrentTaskToDelayedList+0x4c>
80005d2a:	70 0c       	ld.w	r12,r8[0x0]
80005d2c:	2f cb       	sub	r11,-4
80005d2e:	f0 1f 00 0d 	mcall	80005d60 <prvAddCurrentTaskToDelayedList+0x50>
80005d32:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d36:	48 88       	lddpc	r8,80005d54 <prvAddCurrentTaskToDelayedList+0x44>
80005d38:	70 0b       	ld.w	r11,r8[0x0]
80005d3a:	48 b8       	lddpc	r8,80005d64 <prvAddCurrentTaskToDelayedList+0x54>
80005d3c:	70 0c       	ld.w	r12,r8[0x0]
80005d3e:	2f cb       	sub	r11,-4
80005d40:	f0 1f 00 08 	mcall	80005d60 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005d44:	48 98       	lddpc	r8,80005d68 <prvAddCurrentTaskToDelayedList+0x58>
80005d46:	70 08       	ld.w	r8,r8[0x0]
80005d48:	10 37       	cp.w	r7,r8
80005d4a:	c0 32       	brcc	80005d50 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005d4c:	48 78       	lddpc	r8,80005d68 <prvAddCurrentTaskToDelayedList+0x58>
80005d4e:	91 07       	st.w	r8[0x0],r7
80005d50:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d54:	00 00       	add	r0,r0
80005d56:	0c ec       	st.h	--r6,r12
80005d58:	00 00       	add	r0,r0
80005d5a:	0d 18       	ld.sh	r8,r6++
80005d5c:	00 00       	add	r0,r0
80005d5e:	0c 34       	cp.w	r4,r6
80005d60:	80 00       	ld.sh	r0,r0[0x0]
80005d62:	4f f2       	lddpc	r2,80005f5c <xTaskGenericCreate+0x90>
80005d64:	00 00       	add	r0,r0
80005d66:	0c 24       	rsub	r4,r6
80005d68:	00 00       	add	r0,r0
80005d6a:	05 2c       	ld.uh	r12,r2++

80005d6c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005d6c:	eb cd 40 c0 	pushm	r6-r7,lr
80005d70:	18 96       	mov	r6,r12
80005d72:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005d74:	f0 1f 00 18 	mcall	80005dd4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005d78:	6c 08       	ld.w	r8,r6[0x0]
80005d7a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005d7c:	49 79       	lddpc	r9,80005dd8 <vTaskDelayUntil+0x6c>
80005d7e:	72 09       	ld.w	r9,r9[0x0]
80005d80:	12 38       	cp.w	r8,r9
80005d82:	e0 88 00 0c 	brls	80005d9a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005d86:	0e 38       	cp.w	r8,r7
80005d88:	e0 88 00 22 	brls	80005dcc <vTaskDelayUntil+0x60>
80005d8c:	49 38       	lddpc	r8,80005dd8 <vTaskDelayUntil+0x6c>
80005d8e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005d90:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005d92:	10 37       	cp.w	r7,r8
80005d94:	e0 88 00 14 	brls	80005dbc <vTaskDelayUntil+0x50>
80005d98:	c0 a8       	rjmp	80005dac <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005d9a:	0e 38       	cp.w	r8,r7
80005d9c:	e0 8b 00 16 	brhi	80005dc8 <vTaskDelayUntil+0x5c>
80005da0:	48 e8       	lddpc	r8,80005dd8 <vTaskDelayUntil+0x6c>
80005da2:	70 08       	ld.w	r8,r8[0x0]
80005da4:	10 37       	cp.w	r7,r8
80005da6:	e0 8b 00 11 	brhi	80005dc8 <vTaskDelayUntil+0x5c>
80005daa:	c1 18       	rjmp	80005dcc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005dac:	48 c8       	lddpc	r8,80005ddc <vTaskDelayUntil+0x70>
80005dae:	70 0c       	ld.w	r12,r8[0x0]
80005db0:	2f cc       	sub	r12,-4
80005db2:	f0 1f 00 0c 	mcall	80005de0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005db6:	0e 9c       	mov	r12,r7
80005db8:	f0 1f 00 0b 	mcall	80005de4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005dbc:	f0 1f 00 0b 	mcall	80005de8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005dc0:	c0 81       	brne	80005dd0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005dc2:	d7 33       	scall
80005dc4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005dc8:	8d 07       	st.w	r6[0x0],r7
80005dca:	cf 1b       	rjmp	80005dac <vTaskDelayUntil+0x40>
80005dcc:	8d 07       	st.w	r6[0x0],r7
80005dce:	cf 7b       	rjmp	80005dbc <vTaskDelayUntil+0x50>
80005dd0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005dd4:	80 00       	ld.sh	r0,r0[0x0]
80005dd6:	58 6c       	cp.w	r12,6
80005dd8:	00 00       	add	r0,r0
80005dda:	0d 18       	ld.sh	r8,r6++
80005ddc:	00 00       	add	r0,r0
80005dde:	0c ec       	st.h	--r6,r12
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	50 26       	stdsp	sp[0x8],r6
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	5d 10       	icall	r0
80005de8:	80 00       	ld.sh	r0,r0[0x0]
80005dea:	5c 28       	cpc	r8

80005dec <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005dec:	eb cd 40 c0 	pushm	r6-r7,lr
80005df0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005df2:	48 e7       	lddpc	r7,80005e28 <vTaskPlaceOnEventList+0x3c>
80005df4:	6e 0b       	ld.w	r11,r7[0x0]
80005df6:	2e 8b       	sub	r11,-24
80005df8:	f0 1f 00 0d 	mcall	80005e2c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005dfc:	6e 0c       	ld.w	r12,r7[0x0]
80005dfe:	2f cc       	sub	r12,-4
80005e00:	f0 1f 00 0c 	mcall	80005e30 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005e04:	5b f6       	cp.w	r6,-1
80005e06:	c0 81       	brne	80005e16 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005e08:	6e 0b       	ld.w	r11,r7[0x0]
80005e0a:	2f cb       	sub	r11,-4
80005e0c:	48 ac       	lddpc	r12,80005e34 <vTaskPlaceOnEventList+0x48>
80005e0e:	f0 1f 00 0b 	mcall	80005e38 <vTaskPlaceOnEventList+0x4c>
80005e12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005e16:	48 a8       	lddpc	r8,80005e3c <vTaskPlaceOnEventList+0x50>
80005e18:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005e1a:	ec 0c 00 0c 	add	r12,r6,r12
80005e1e:	f0 1f 00 09 	mcall	80005e40 <vTaskPlaceOnEventList+0x54>
80005e22:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e26:	00 00       	add	r0,r0
80005e28:	00 00       	add	r0,r0
80005e2a:	0c ec       	st.h	--r6,r12
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	4f f2       	lddpc	r2,80006028 <xTaskGenericCreate+0x15c>
80005e30:	80 00       	ld.sh	r0,r0[0x0]
80005e32:	50 26       	stdsp	sp[0x8],r6
80005e34:	00 00       	add	r0,r0
80005e36:	0d 40       	ld.w	r0,--r6
80005e38:	80 00       	ld.sh	r0,r0[0x0]
80005e3a:	4f d6       	lddpc	r6,8000602c <xTaskGenericCreate+0x160>
80005e3c:	00 00       	add	r0,r0
80005e3e:	0d 18       	ld.sh	r8,r6++
80005e40:	80 00       	ld.sh	r0,r0[0x0]
80005e42:	5d 10       	icall	r0

80005e44 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005e44:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005e48:	49 67       	lddpc	r7,80005ea0 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005e4a:	49 74       	lddpc	r4,80005ea4 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005e4c:	49 73       	lddpc	r3,80005ea8 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005e4e:	49 85       	lddpc	r5,80005eac <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005e50:	6e 08       	ld.w	r8,r7[0x0]
80005e52:	58 08       	cp.w	r8,0
80005e54:	c1 e0       	breq	80005e90 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005e56:	f0 1f 00 17 	mcall	80005eb0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005e5a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005e5c:	f0 1f 00 16 	mcall	80005eb4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005e60:	58 06       	cp.w	r6,0
80005e62:	c1 70       	breq	80005e90 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005e64:	f0 1f 00 15 	mcall	80005eb8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005e68:	68 38       	ld.w	r8,r4[0xc]
80005e6a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005e6c:	ec cc ff fc 	sub	r12,r6,-4
80005e70:	f0 1f 00 13 	mcall	80005ebc <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80005e74:	66 08       	ld.w	r8,r3[0x0]
80005e76:	20 18       	sub	r8,1
80005e78:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005e7a:	6e 08       	ld.w	r8,r7[0x0]
80005e7c:	20 18       	sub	r8,1
80005e7e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005e80:	f0 1f 00 10 	mcall	80005ec0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005e84:	6c cc       	ld.w	r12,r6[0x30]
80005e86:	f0 1f 00 10 	mcall	80005ec4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005e8a:	0c 9c       	mov	r12,r6
80005e8c:	f0 1f 00 0e 	mcall	80005ec4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005e90:	6a 08       	ld.w	r8,r5[0x0]
80005e92:	58 18       	cp.w	r8,1
80005e94:	e0 88 00 03 	brls	80005e9a <prvIdleTask+0x56>
			{
				taskYIELD();
80005e98:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005e9a:	f0 1f 00 0c 	mcall	80005ec8 <prvIdleTask+0x84>
		}
		#endif
	}
80005e9e:	cd 9b       	rjmp	80005e50 <prvIdleTask+0xc>
80005ea0:	00 00       	add	r0,r0
80005ea2:	0c 2c       	rsub	r12,r6
80005ea4:	00 00       	add	r0,r0
80005ea6:	0c d8       	st.w	--r6,r8
80005ea8:	00 00       	add	r0,r0
80005eaa:	0d 38       	ld.ub	r8,r6++
80005eac:	00 00       	add	r0,r0
80005eae:	0c 38       	cp.w	r8,r6
80005eb0:	80 00       	ld.sh	r0,r0[0x0]
80005eb2:	58 6c       	cp.w	r12,6
80005eb4:	80 00       	ld.sh	r0,r0[0x0]
80005eb6:	5c 28       	cpc	r8
80005eb8:	80 00       	ld.sh	r0,r0[0x0]
80005eba:	50 e0       	stdsp	sp[0x38],r0
80005ebc:	80 00       	ld.sh	r0,r0[0x0]
80005ebe:	50 26       	stdsp	sp[0x8],r6
80005ec0:	80 00       	ld.sh	r0,r0[0x0]
80005ec2:	51 ec       	stdsp	sp[0x78],r12
80005ec4:	80 00       	ld.sh	r0,r0[0x0]
80005ec6:	53 24       	stdsp	sp[0xc8],r4
80005ec8:	80 00       	ld.sh	r0,r0[0x0]
80005eca:	20 30       	sub	r0,3

80005ecc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005ecc:	d4 31       	pushm	r0-r7,lr
80005ece:	20 1d       	sub	sp,4
80005ed0:	fa c4 ff d8 	sub	r4,sp,-40
80005ed4:	50 0c       	stdsp	sp[0x0],r12
80005ed6:	16 91       	mov	r1,r11
80005ed8:	14 97       	mov	r7,r10
80005eda:	12 90       	mov	r0,r9
80005edc:	10 93       	mov	r3,r8
80005ede:	68 02       	ld.w	r2,r4[0x0]
80005ee0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005ee2:	34 8c       	mov	r12,72
80005ee4:	f0 1f 00 5c 	mcall	80006054 <xTaskGenericCreate+0x188>
80005ee8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005eea:	c0 31       	brne	80005ef0 <xTaskGenericCreate+0x24>
80005eec:	3f fc       	mov	r12,-1
80005eee:	ca f8       	rjmp	8000604c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005ef0:	58 06       	cp.w	r6,0
80005ef2:	e0 81 00 af 	brne	80006050 <xTaskGenericCreate+0x184>
80005ef6:	0e 9c       	mov	r12,r7
80005ef8:	5c 7c       	castu.h	r12
80005efa:	a3 6c       	lsl	r12,0x2
80005efc:	f0 1f 00 56 	mcall	80006054 <xTaskGenericCreate+0x188>
80005f00:	18 96       	mov	r6,r12
80005f02:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005f04:	c0 61       	brne	80005f10 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005f06:	0a 9c       	mov	r12,r5
80005f08:	f0 1f 00 54 	mcall	80006058 <xTaskGenericCreate+0x18c>
80005f0c:	3f fc       	mov	r12,-1
80005f0e:	c9 f8       	rjmp	8000604c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005f10:	5c 77       	castu.h	r7
80005f12:	ee 0a 15 02 	lsl	r10,r7,0x2
80005f16:	e0 6b 00 a5 	mov	r11,165
80005f1a:	0c 9c       	mov	r12,r6
80005f1c:	f0 1f 00 50 	mcall	8000605c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005f20:	ee c6 00 01 	sub	r6,r7,1
80005f24:	6a c8       	ld.w	r8,r5[0x30]
80005f26:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005f2a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005f2e:	31 0a       	mov	r10,16
80005f30:	02 9b       	mov	r11,r1
80005f32:	ea cc ff cc 	sub	r12,r5,-52
80005f36:	f0 1f 00 4b 	mcall	80006060 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005f3a:	30 08       	mov	r8,0
80005f3c:	eb 68 00 43 	st.b	r5[67],r8
80005f40:	58 73       	cp.w	r3,7
80005f42:	e6 07 17 80 	movls	r7,r3
80005f46:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005f4a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005f4c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005f50:	ea c4 ff fc 	sub	r4,r5,-4
80005f54:	08 9c       	mov	r12,r4
80005f56:	f0 1f 00 44 	mcall	80006064 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005f5a:	ea cc ff e8 	sub	r12,r5,-24
80005f5e:	f0 1f 00 42 	mcall	80006064 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005f62:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005f64:	ee 07 11 08 	rsub	r7,r7,8
80005f68:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005f6a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005f6c:	00 9a       	mov	r10,r0
80005f6e:	40 0b       	lddsp	r11,sp[0x0]
80005f70:	0c 9c       	mov	r12,r6
80005f72:	f0 1f 00 3e 	mcall	80006068 <xTaskGenericCreate+0x19c>
80005f76:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005f78:	58 02       	cp.w	r2,0
80005f7a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005f7e:	f0 1f 00 3c 	mcall	8000606c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005f82:	4b c8       	lddpc	r8,80006070 <xTaskGenericCreate+0x1a4>
80005f84:	70 09       	ld.w	r9,r8[0x0]
80005f86:	2f f9       	sub	r9,-1
80005f88:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005f8a:	4b b8       	lddpc	r8,80006074 <xTaskGenericCreate+0x1a8>
80005f8c:	70 08       	ld.w	r8,r8[0x0]
80005f8e:	58 08       	cp.w	r8,0
80005f90:	c2 61       	brne	80005fdc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005f92:	4b 98       	lddpc	r8,80006074 <xTaskGenericCreate+0x1a8>
80005f94:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005f96:	4b 78       	lddpc	r8,80006070 <xTaskGenericCreate+0x1a4>
80005f98:	70 08       	ld.w	r8,r8[0x0]
80005f9a:	58 18       	cp.w	r8,1
80005f9c:	c2 b1       	brne	80005ff2 <xTaskGenericCreate+0x126>
80005f9e:	4b 77       	lddpc	r7,80006078 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005fa0:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005fa4:	0e 9c       	mov	r12,r7
80005fa6:	f0 1f 00 36 	mcall	8000607c <xTaskGenericCreate+0x1b0>
80005faa:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005fac:	0c 37       	cp.w	r7,r6
80005fae:	cf b1       	brne	80005fa4 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005fb0:	4b 47       	lddpc	r7,80006080 <xTaskGenericCreate+0x1b4>
80005fb2:	0e 9c       	mov	r12,r7
80005fb4:	f0 1f 00 32 	mcall	8000607c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005fb8:	4b 36       	lddpc	r6,80006084 <xTaskGenericCreate+0x1b8>
80005fba:	0c 9c       	mov	r12,r6
80005fbc:	f0 1f 00 30 	mcall	8000607c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005fc0:	4b 2c       	lddpc	r12,80006088 <xTaskGenericCreate+0x1bc>
80005fc2:	f0 1f 00 2f 	mcall	8000607c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005fc6:	4b 2c       	lddpc	r12,8000608c <xTaskGenericCreate+0x1c0>
80005fc8:	f0 1f 00 2d 	mcall	8000607c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005fcc:	4b 1c       	lddpc	r12,80006090 <xTaskGenericCreate+0x1c4>
80005fce:	f0 1f 00 2c 	mcall	8000607c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005fd2:	4b 18       	lddpc	r8,80006094 <xTaskGenericCreate+0x1c8>
80005fd4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005fd6:	4b 18       	lddpc	r8,80006098 <xTaskGenericCreate+0x1cc>
80005fd8:	91 06       	st.w	r8[0x0],r6
80005fda:	c0 c8       	rjmp	80005ff2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005fdc:	4b 08       	lddpc	r8,8000609c <xTaskGenericCreate+0x1d0>
80005fde:	70 08       	ld.w	r8,r8[0x0]
80005fe0:	58 08       	cp.w	r8,0
80005fe2:	c0 81       	brne	80005ff2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005fe4:	4a 48       	lddpc	r8,80006074 <xTaskGenericCreate+0x1a8>
80005fe6:	70 08       	ld.w	r8,r8[0x0]
80005fe8:	70 b8       	ld.w	r8,r8[0x2c]
80005fea:	10 33       	cp.w	r3,r8
80005fec:	c0 33       	brcs	80005ff2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005fee:	4a 28       	lddpc	r8,80006074 <xTaskGenericCreate+0x1a8>
80005ff0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005ff2:	6a b8       	ld.w	r8,r5[0x2c]
80005ff4:	4a b9       	lddpc	r9,800060a0 <xTaskGenericCreate+0x1d4>
80005ff6:	72 09       	ld.w	r9,r9[0x0]
80005ff8:	12 38       	cp.w	r8,r9
80005ffa:	e0 88 00 04 	brls	80006002 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005ffe:	4a 99       	lddpc	r9,800060a0 <xTaskGenericCreate+0x1d4>
80006000:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006002:	4a 98       	lddpc	r8,800060a4 <xTaskGenericCreate+0x1d8>
80006004:	70 09       	ld.w	r9,r8[0x0]
80006006:	2f f9       	sub	r9,-1
80006008:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000600a:	6a b8       	ld.w	r8,r5[0x2c]
8000600c:	4a 79       	lddpc	r9,800060a8 <xTaskGenericCreate+0x1dc>
8000600e:	72 09       	ld.w	r9,r9[0x0]
80006010:	12 38       	cp.w	r8,r9
80006012:	e0 88 00 04 	brls	8000601a <xTaskGenericCreate+0x14e>
80006016:	4a 59       	lddpc	r9,800060a8 <xTaskGenericCreate+0x1dc>
80006018:	93 08       	st.w	r9[0x0],r8
8000601a:	6a bc       	ld.w	r12,r5[0x2c]
8000601c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006020:	08 9b       	mov	r11,r4
80006022:	49 68       	lddpc	r8,80006078 <xTaskGenericCreate+0x1ac>
80006024:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006028:	f0 1f 00 21 	mcall	800060ac <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000602c:	f0 1f 00 21 	mcall	800060b0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006030:	49 b8       	lddpc	r8,8000609c <xTaskGenericCreate+0x1d0>
80006032:	70 08       	ld.w	r8,r8[0x0]
80006034:	58 08       	cp.w	r8,0
80006036:	c0 a0       	breq	8000604a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006038:	48 f8       	lddpc	r8,80006074 <xTaskGenericCreate+0x1a8>
8000603a:	70 08       	ld.w	r8,r8[0x0]
8000603c:	70 b8       	ld.w	r8,r8[0x2c]
8000603e:	10 33       	cp.w	r3,r8
80006040:	e0 88 00 05 	brls	8000604a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006044:	d7 33       	scall
80006046:	30 1c       	mov	r12,1
80006048:	c0 28       	rjmp	8000604c <xTaskGenericCreate+0x180>
8000604a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000604c:	2f fd       	sub	sp,-4
8000604e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006050:	99 c6       	st.w	r12[0x30],r6
80006052:	c5 fb       	rjmp	80005f10 <xTaskGenericCreate+0x44>
80006054:	80 00       	ld.sh	r0,r0[0x0]
80006056:	53 4c       	stdsp	sp[0xd0],r12
80006058:	80 00       	ld.sh	r0,r0[0x0]
8000605a:	53 24       	stdsp	sp[0xc8],r4
8000605c:	80 00       	ld.sh	r0,r0[0x0]
8000605e:	6d 38       	ld.w	r8,r6[0x4c]
80006060:	80 00       	ld.sh	r0,r0[0x0]
80006062:	70 7c       	ld.w	r12,r8[0x1c]
80006064:	80 00       	ld.sh	r0,r0[0x0]
80006066:	4f d0       	lddpc	r0,80006258 <PrintDec+0xa2>
80006068:	80 00       	ld.sh	r0,r0[0x0]
8000606a:	50 4c       	stdsp	sp[0x10],r12
8000606c:	80 00       	ld.sh	r0,r0[0x0]
8000606e:	50 e0       	stdsp	sp[0x38],r0
80006070:	00 00       	add	r0,r0
80006072:	0d 38       	ld.ub	r8,r6++
80006074:	00 00       	add	r0,r0
80006076:	0c ec       	st.h	--r6,r12
80006078:	00 00       	add	r0,r0
8000607a:	0c 38       	cp.w	r8,r6
8000607c:	80 00       	ld.sh	r0,r0[0x0]
8000607e:	4f bc       	lddpc	r12,80006268 <PrintDec+0xb2>
80006080:	00 00       	add	r0,r0
80006082:	0d 04       	ld.w	r4,r6++
80006084:	00 00       	add	r0,r0
80006086:	0d 20       	ld.uh	r0,r6++
80006088:	00 00       	add	r0,r0
8000608a:	0c f0       	st.b	--r6,r0
8000608c:	00 00       	add	r0,r0
8000608e:	0c d8       	st.w	--r6,r8
80006090:	00 00       	add	r0,r0
80006092:	0d 40       	ld.w	r0,--r6
80006094:	00 00       	add	r0,r0
80006096:	0c 24       	rsub	r4,r6
80006098:	00 00       	add	r0,r0
8000609a:	0c 34       	cp.w	r4,r6
8000609c:	00 00       	add	r0,r0
8000609e:	0c 28       	rsub	r8,r6
800060a0:	00 00       	add	r0,r0
800060a2:	0c 20       	rsub	r0,r6
800060a4:	00 00       	add	r0,r0
800060a6:	0d 34       	ld.ub	r4,r6++
800060a8:	00 00       	add	r0,r0
800060aa:	0d 54       	ld.sh	r4,--r6
800060ac:	80 00       	ld.sh	r0,r0[0x0]
800060ae:	4f d6       	lddpc	r6,800062a0 <log+0x10>
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	51 ec       	stdsp	sp[0x78],r12

800060b4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800060b4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800060b6:	30 09       	mov	r9,0
800060b8:	1a d9       	st.w	--sp,r9
800060ba:	1a d9       	st.w	--sp,r9
800060bc:	1a d9       	st.w	--sp,r9
800060be:	12 98       	mov	r8,r9
800060c0:	e0 6a 01 00 	mov	r10,256
800060c4:	48 9b       	lddpc	r11,800060e8 <vTaskStartScheduler+0x34>
800060c6:	48 ac       	lddpc	r12,800060ec <vTaskStartScheduler+0x38>
800060c8:	f0 1f 00 0a 	mcall	800060f0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800060cc:	2f dd       	sub	sp,-12
800060ce:	58 1c       	cp.w	r12,1
800060d0:	c0 a1       	brne	800060e4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800060d2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800060d4:	30 19       	mov	r9,1
800060d6:	48 88       	lddpc	r8,800060f4 <vTaskStartScheduler+0x40>
800060d8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800060da:	30 09       	mov	r9,0
800060dc:	48 78       	lddpc	r8,800060f8 <vTaskStartScheduler+0x44>
800060de:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800060e0:	f0 1f 00 07 	mcall	800060fc <vTaskStartScheduler+0x48>
800060e4:	d8 02       	popm	pc
800060e6:	00 00       	add	r0,r0
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	cc b8       	rjmp	80006280 <PrintDec+0xca>
800060ec:	80 00       	ld.sh	r0,r0[0x0]
800060ee:	5e 44       	retge	r4
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	5e cc       	retvs	r12
800060f4:	00 00       	add	r0,r0
800060f6:	0c 28       	rsub	r8,r6
800060f8:	00 00       	add	r0,r0
800060fa:	0d 18       	ld.sh	r8,r6++
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	50 f0       	stdsp	sp[0x3c],r0

80006100 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006100:	16 cc       	st.b	r11++,r12
	return str;
}
80006102:	5e fb       	retal	r11

80006104 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006104:	eb cd 40 c0 	pushm	r6-r7,lr
80006108:	20 3d       	sub	sp,12
8000610a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
8000610c:	30 06       	mov	r6,0
8000610e:	30 07       	mov	r7,0
80006110:	fa e7 00 00 	st.d	sp[0],r6
80006114:	30 0c       	mov	r12,0
80006116:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006118:	58 08       	cp.w	r8,0
8000611a:	c1 30       	breq	80006140 <PrintHex+0x3c>
8000611c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000611e:	1a 9c       	mov	r12,sp
80006120:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006124:	58 9e       	cp.w	lr,9
80006126:	e0 8a 00 04 	brle	8000612e <PrintHex+0x2a>
8000612a:	2c 9e       	sub	lr,-55
8000612c:	c0 48       	rjmp	80006134 <PrintHex+0x30>
8000612e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006132:	2d 0e       	sub	lr,-48
80006134:	f8 09 0b 0e 	st.b	r12[r9],lr
80006138:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000613a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000613c:	cf 21       	brne	80006120 <PrintHex+0x1c>
8000613e:	c0 48       	rjmp	80006146 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006140:	33 08       	mov	r8,48
80006142:	ba 88       	st.b	sp[0x0],r8
80006144:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006146:	f6 09 01 08 	sub	r8,r11,r9
8000614a:	58 08       	cp.w	r8,0
8000614c:	e0 8a 00 13 	brle	80006172 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006150:	12 1b       	sub	r11,r9
80006152:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006156:	18 9e       	mov	lr,r12
80006158:	58 0c       	cp.w	r12,0
8000615a:	e0 8a 00 0c 	brle	80006172 <PrintHex+0x6e>
8000615e:	1a 9b       	mov	r11,sp
80006160:	12 0b       	add	r11,r9
80006162:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006164:	33 07       	mov	r7,48
80006166:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006168:	2f f8       	sub	r8,-1
8000616a:	1c 38       	cp.w	r8,lr
8000616c:	cf d5       	brlt	80006166 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000616e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006172:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006176:	f0 cb ff ff 	sub	r11,r8,-1
8000617a:	58 0b       	cp.w	r11,0
8000617c:	e0 8a 00 19 	brle	800061ae <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006180:	fa cb ff f4 	sub	r11,sp,-12
80006184:	f6 09 00 09 	add	r9,r11,r9
80006188:	37 8b       	mov	r11,120
8000618a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000618e:	fa c9 ff f4 	sub	r9,sp,-12
80006192:	10 09       	add	r9,r8
80006194:	33 0b       	mov	r11,48
80006196:	f3 6b ff f4 	st.b	r9[-12],r11
8000619a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000619e:	fa ce 00 01 	sub	lr,sp,1
800061a2:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800061a4:	11 8b       	ld.ub	r11,r8[0x0]
800061a6:	12 cb       	st.b	r9++,r11
800061a8:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800061aa:	1c 38       	cp.w	r8,lr
800061ac:	cf c1       	brne	800061a4 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800061ae:	14 9c       	mov	r12,r10
800061b0:	2f dd       	sub	sp,-12
800061b2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800061b6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800061b6:	d4 21       	pushm	r4-r7,lr
800061b8:	20 3d       	sub	sp,12
800061ba:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800061bc:	30 06       	mov	r6,0
800061be:	30 07       	mov	r7,0
800061c0:	fa e7 00 00 	st.d	sp[0],r6
800061c4:	30 0c       	mov	r12,0
800061c6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800061c8:	58 08       	cp.w	r8,0
800061ca:	c0 35       	brlt	800061d0 <PrintDec+0x1a>
800061cc:	14 97       	mov	r7,r10
800061ce:	c0 58       	rjmp	800061d8 <PrintDec+0x22>
	{
		*p++ = '-';
800061d0:	14 97       	mov	r7,r10
800061d2:	32 d9       	mov	r9,45
800061d4:	0e c9       	st.b	r7++,r9
		i = -i;
800061d6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800061d8:	58 08       	cp.w	r8,0
800061da:	c0 51       	brne	800061e4 <PrintDec+0x2e>
800061dc:	33 08       	mov	r8,48
800061de:	ba 88       	st.b	sp[0x0],r8
800061e0:	30 1e       	mov	lr,1
800061e2:	c2 f8       	rjmp	80006240 <PrintDec+0x8a>
	
	int ten = i%10;
800061e4:	e0 65 66 67 	mov	r5,26215
800061e8:	ea 15 66 66 	orh	r5,0x6666
800061ec:	f0 05 04 44 	muls.d	r4,r8,r5
800061f0:	ea 0c 14 02 	asr	r12,r5,0x2
800061f4:	f0 09 14 1f 	asr	r9,r8,0x1f
800061f8:	f8 09 01 09 	sub	r9,r12,r9
800061fc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006200:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006204:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006206:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006208:	e0 66 66 67 	mov	r6,26215
8000620c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006210:	2d 09       	sub	r9,-48
80006212:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006216:	2f fe       	sub	lr,-1
		i /= 10;
80006218:	f0 06 04 44 	muls.d	r4,r8,r6
8000621c:	ea 09 14 02 	asr	r9,r5,0x2
80006220:	bf 58       	asr	r8,0x1f
80006222:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006226:	f0 06 04 44 	muls.d	r4,r8,r6
8000622a:	ea 09 14 02 	asr	r9,r5,0x2
8000622e:	f0 05 14 1f 	asr	r5,r8,0x1f
80006232:	0a 19       	sub	r9,r5
80006234:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006238:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000623c:	58 08       	cp.w	r8,0
8000623e:	ce 91       	brne	80006210 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006240:	f6 0e 01 08 	sub	r8,r11,lr
80006244:	58 08       	cp.w	r8,0
80006246:	e0 89 00 06 	brgt	80006252 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000624a:	58 0e       	cp.w	lr,0
8000624c:	e0 89 00 14 	brgt	80006274 <PrintDec+0xbe>
80006250:	c1 d8       	rjmp	8000628a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006252:	1c 1b       	sub	r11,lr
80006254:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006256:	16 9c       	mov	r12,r11
80006258:	58 0b       	cp.w	r11,0
8000625a:	fe 9a ff f8 	brle	8000624a <PrintDec+0x94>
8000625e:	1a 99       	mov	r9,sp
80006260:	1c 09       	add	r9,lr
80006262:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006264:	33 06       	mov	r6,48
80006266:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006268:	2f f8       	sub	r8,-1
8000626a:	18 38       	cp.w	r8,r12
8000626c:	cf d5       	brlt	80006266 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000626e:	f6 0e 00 0e 	add	lr,r11,lr
80006272:	ce cb       	rjmp	8000624a <PrintDec+0x94>
80006274:	fa c8 ff f4 	sub	r8,sp,-12
80006278:	1c 08       	add	r8,lr
8000627a:	20 d8       	sub	r8,13
8000627c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006280:	11 89       	ld.ub	r9,r8[0x0]
80006282:	0e c9       	st.b	r7++,r9
80006284:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006286:	16 38       	cp.w	r8,r11
80006288:	cf c1       	brne	80006280 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000628a:	14 9c       	mov	r12,r10
8000628c:	2f dd       	sub	sp,-12
8000628e:	d8 22       	popm	r4-r7,pc

80006290 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006290:	d4 31       	pushm	r0-r7,lr
80006292:	fa cd 02 08 	sub	sp,sp,520
80006296:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006298:	e0 6a 01 00 	mov	r10,256
8000629c:	30 0b       	mov	r11,0
8000629e:	fa cc fe f8 	sub	r12,sp,-264
800062a2:	f0 1f 00 4e 	mcall	800063d8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800062a6:	fa c4 fd d4 	sub	r4,sp,-556
800062aa:	30 0a       	mov	r10,0
800062ac:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800062ae:	fa c3 ff fc 	sub	r3,sp,-4
800062b2:	e0 61 01 00 	mov	r1,256
800062b6:	14 90       	mov	r0,r10
			
					if(*str == '%')
800062b8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800062ba:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800062be:	02 9a       	mov	r10,r1
800062c0:	00 9b       	mov	r11,r0
800062c2:	06 9c       	mov	r12,r3
800062c4:	f0 1f 00 45 	mcall	800063d8 <log+0x148>
			
					if(*str == '%')
800062c8:	0f 88       	ld.ub	r8,r7[0x0]
800062ca:	e4 08 18 00 	cp.b	r8,r2
800062ce:	c5 71       	brne	8000637c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800062d0:	ee c8 ff ff 	sub	r8,r7,-1
800062d4:	11 89       	ld.ub	r9,r8[0x0]
800062d6:	4c 2a       	lddpc	r10,800063dc <log+0x14c>
800062d8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800062da:	23 09       	sub	r9,48
800062dc:	30 9a       	mov	r10,9
800062de:	f4 09 18 00 	cp.b	r9,r10
800062e2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800062e6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800062ea:	f7 b9 08 30 	subls	r9,48
800062ee:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800062f2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800062f6:	0f 88       	ld.ub	r8,r7[0x0]
800062f8:	22 58       	sub	r8,37
800062fa:	e0 48 00 53 	cp.w	r8,83
800062fe:	e0 8b 00 31 	brhi	80006360 <log+0xd0>
80006302:	4b 89       	lddpc	r9,800063e0 <log+0x150>
80006304:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006308:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
8000630c:	06 9a       	mov	r10,r3
8000630e:	40 0b       	lddsp	r11,sp[0x0]
80006310:	5c 5b       	castu.b	r11
80006312:	68 0c       	ld.w	r12,r4[0x0]
80006314:	f0 1f 00 34 	mcall	800063e4 <log+0x154>
							break;
80006318:	c2 98       	rjmp	8000636a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000631a:	4b 4c       	lddpc	r12,800063e8 <log+0x158>
8000631c:	f0 1f 00 34 	mcall	800063ec <log+0x15c>
80006320:	08 95       	mov	r5,r4
80006322:	06 9c       	mov	r12,r3
							break;
80006324:	c2 38       	rjmp	8000636a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006326:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000632a:	06 9a       	mov	r10,r3
8000632c:	40 0b       	lddsp	r11,sp[0x0]
8000632e:	5c 5b       	castu.b	r11
80006330:	68 0c       	ld.w	r12,r4[0x0]
80006332:	f0 1f 00 30 	mcall	800063f0 <log+0x160>
80006336:	06 9c       	mov	r12,r3
							break;
80006338:	c1 98       	rjmp	8000636a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000633a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000633e:	06 9b       	mov	r11,r3
80006340:	09 bc       	ld.ub	r12,r4[0x3]
80006342:	f0 1f 00 2d 	mcall	800063f4 <log+0x164>
80006346:	06 9c       	mov	r12,r3
							break;
80006348:	c1 18       	rjmp	8000636a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000634a:	e8 c5 ff fc 	sub	r5,r4,-4
8000634e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006350:	c0 d8       	rjmp	8000636a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006352:	06 9b       	mov	r11,r3
80006354:	32 5c       	mov	r12,37
80006356:	f0 1f 00 28 	mcall	800063f4 <log+0x164>
8000635a:	08 95       	mov	r5,r4
8000635c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000635e:	c0 68       	rjmp	8000636a <log+0xda>
							
							default:
							log("I need relax.");
80006360:	4a 6c       	lddpc	r12,800063f8 <log+0x168>
80006362:	f0 1f 00 23 	mcall	800063ec <log+0x15c>
80006366:	08 95       	mov	r5,r4
80006368:	06 9c       	mov	r12,r3
						}
						str++;
8000636a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000636c:	1a dc       	st.w	--sp,r12
8000636e:	1a d6       	st.w	--sp,r6
80006370:	4a 3b       	lddpc	r11,800063fc <log+0x16c>
80006372:	0c 9c       	mov	r12,r6
80006374:	f0 1f 00 23 	mcall	80006400 <log+0x170>
80006378:	2f ed       	sub	sp,-8
8000637a:	c0 a8       	rjmp	8000638e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000637c:	2f f7       	sub	r7,-1
8000637e:	1a d8       	st.w	--sp,r8
80006380:	1a d6       	st.w	--sp,r6
80006382:	4a 1b       	lddpc	r11,80006404 <log+0x174>
80006384:	0c 9c       	mov	r12,r6
80006386:	f0 1f 00 1f 	mcall	80006400 <log+0x170>
8000638a:	08 95       	mov	r5,r4
8000638c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000638e:	0f 89       	ld.ub	r9,r7[0x0]
80006390:	30 08       	mov	r8,0
80006392:	f0 09 18 00 	cp.b	r9,r8
80006396:	c0 30       	breq	8000639c <log+0x10c>
80006398:	0a 94       	mov	r4,r5
8000639a:	c9 2b       	rjmp	800062be <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000639c:	fa c7 fe f8 	sub	r7,sp,-264
800063a0:	1a d7       	st.w	--sp,r7
800063a2:	49 ab       	lddpc	r11,80006408 <log+0x178>
800063a4:	0e 9c       	mov	r12,r7
800063a6:	f0 1f 00 17 	mcall	80006400 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800063aa:	5c 5c       	castu.b	r12
800063ac:	f8 c6 ff ff 	sub	r6,r12,-1
800063b0:	0c 9c       	mov	r12,r6
800063b2:	f0 1f 00 17 	mcall	8000640c <log+0x17c>
800063b6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800063b8:	0c 9a       	mov	r10,r6
800063ba:	0e 9b       	mov	r11,r7
800063bc:	f0 1f 00 15 	mcall	80006410 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
800063c0:	30 09       	mov	r9,0
800063c2:	30 5a       	mov	r10,5
800063c4:	fa cb fe f8 	sub	r11,sp,-264
800063c8:	49 38       	lddpc	r8,80006414 <log+0x184>
800063ca:	70 0c       	ld.w	r12,r8[0x0]
800063cc:	f0 1f 00 13 	mcall	80006418 <log+0x188>
800063d0:	2f fd       	sub	sp,-4
}
800063d2:	fe 3d fd f8 	sub	sp,-520
800063d6:	d8 32       	popm	r0-r7,pc
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	6d 38       	ld.w	r8,r6[0x4c]
800063dc:	00 00       	add	r0,r0
800063de:	0d 58       	ld.sh	r8,--r6
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	cc c0       	breq	8000637a <log+0xea>
800063e4:	80 00       	ld.sh	r0,r0[0x0]
800063e6:	61 b6       	ld.w	r6,r0[0x6c]
800063e8:	80 00       	ld.sh	r0,r0[0x0]
800063ea:	cf 6c       	rcall	800065d6 <log_init+0x3a>
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	62 90       	ld.w	r0,r1[0x24]
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	61 04       	ld.w	r4,r0[0x40]
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	61 00       	ld.w	r0,r0[0x40]
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	cf 7c       	rcall	800065e8 <log_init+0x4c>
800063fc:	80 00       	ld.sh	r0,r0[0x0]
800063fe:	cf 8c       	rcall	800065ee <log_init+0x52>
80006400:	80 00       	ld.sh	r0,r0[0x0]
80006402:	70 28       	ld.w	r8,r8[0x8]
80006404:	80 00       	ld.sh	r0,r0[0x0]
80006406:	cf 94       	brge	800063f8 <log+0x168>
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	cf 9c       	rcall	800065fc <log_init+0x60>
8000640c:	80 00       	ld.sh	r0,r0[0x0]
8000640e:	53 4c       	stdsp	sp[0xd0],r12
80006410:	80 00       	ld.sh	r0,r0[0x0]
80006412:	6b f0       	ld.w	r0,r5[0x7c]
80006414:	00 00       	add	r0,r0
80006416:	41 10       	lddsp	r0,sp[0x44]
80006418:	80 00       	ld.sh	r0,r0[0x0]
8000641a:	56 a0       	stdsp	sp[0x1a8],r0

8000641c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000641c:	d4 31       	pushm	r0-r7,lr
8000641e:	fa cd 02 0c 	sub	sp,sp,524
80006422:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006424:	e0 6a 01 00 	mov	r10,256
80006428:	30 0b       	mov	r11,0
8000642a:	fa cc fe f4 	sub	r12,sp,-268
8000642e:	f0 1f 00 4c 	mcall	8000655c <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80006432:	fa c4 fd d0 	sub	r4,sp,-560
80006436:	30 0a       	mov	r10,0
80006438:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000643a:	fa c3 ff fc 	sub	r3,sp,-4
8000643e:	e0 61 01 00 	mov	r1,256
80006442:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006444:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006446:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000644a:	02 9a       	mov	r10,r1
8000644c:	00 9b       	mov	r11,r0
8000644e:	06 9c       	mov	r12,r3
80006450:	f0 1f 00 43 	mcall	8000655c <logFromISR+0x140>
			
			if(*str == '%')
80006454:	0f 88       	ld.ub	r8,r7[0x0]
80006456:	e4 08 18 00 	cp.b	r8,r2
8000645a:	c5 11       	brne	800064fc <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000645c:	ee c8 ff ff 	sub	r8,r7,-1
80006460:	11 89       	ld.ub	r9,r8[0x0]
80006462:	4c 0a       	lddpc	r10,80006560 <logFromISR+0x144>
80006464:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006466:	23 09       	sub	r9,48
80006468:	30 9a       	mov	r10,9
8000646a:	f4 09 18 00 	cp.b	r9,r10
8000646e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006472:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006476:	f7 b9 08 30 	subls	r9,48
8000647a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000647e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006482:	0f 88       	ld.ub	r8,r7[0x0]
80006484:	22 58       	sub	r8,37
80006486:	e0 48 00 53 	cp.w	r8,83
8000648a:	e0 8b 00 2b 	brhi	800064e0 <logFromISR+0xc4>
8000648e:	4b 69       	lddpc	r9,80006564 <logFromISR+0x148>
80006490:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006494:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006498:	06 9a       	mov	r10,r3
8000649a:	40 0b       	lddsp	r11,sp[0x0]
8000649c:	5c 5b       	castu.b	r11
8000649e:	68 0c       	ld.w	r12,r4[0x0]
800064a0:	f0 1f 00 32 	mcall	80006568 <logFromISR+0x14c>
					break;
800064a4:	c2 38       	rjmp	800064ea <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800064a6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800064aa:	06 9a       	mov	r10,r3
800064ac:	40 0b       	lddsp	r11,sp[0x0]
800064ae:	5c 5b       	castu.b	r11
800064b0:	68 0c       	ld.w	r12,r4[0x0]
800064b2:	f0 1f 00 2f 	mcall	8000656c <logFromISR+0x150>
800064b6:	06 9c       	mov	r12,r3
					break;
800064b8:	c1 98       	rjmp	800064ea <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800064ba:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800064be:	06 9b       	mov	r11,r3
800064c0:	09 bc       	ld.ub	r12,r4[0x3]
800064c2:	f0 1f 00 2c 	mcall	80006570 <logFromISR+0x154>
800064c6:	06 9c       	mov	r12,r3
					break;
800064c8:	c1 18       	rjmp	800064ea <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800064ca:	e8 c5 ff fc 	sub	r5,r4,-4
800064ce:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800064d0:	c0 d8       	rjmp	800064ea <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800064d2:	06 9b       	mov	r11,r3
800064d4:	32 5c       	mov	r12,37
800064d6:	f0 1f 00 27 	mcall	80006570 <logFromISR+0x154>
800064da:	08 95       	mov	r5,r4
800064dc:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800064de:	c0 68       	rjmp	800064ea <logFromISR+0xce>
					default:
					log("I need relax.");
800064e0:	4a 5c       	lddpc	r12,80006574 <logFromISR+0x158>
800064e2:	f0 1f 00 26 	mcall	80006578 <logFromISR+0x15c>
800064e6:	08 95       	mov	r5,r4
800064e8:	06 9c       	mov	r12,r3
				}
				str++;
800064ea:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800064ec:	1a dc       	st.w	--sp,r12
800064ee:	1a d6       	st.w	--sp,r6
800064f0:	4a 3b       	lddpc	r11,8000657c <logFromISR+0x160>
800064f2:	0c 9c       	mov	r12,r6
800064f4:	f0 1f 00 23 	mcall	80006580 <logFromISR+0x164>
800064f8:	2f ed       	sub	sp,-8
800064fa:	c0 a8       	rjmp	8000650e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800064fc:	2f f7       	sub	r7,-1
800064fe:	1a d8       	st.w	--sp,r8
80006500:	1a d6       	st.w	--sp,r6
80006502:	4a 1b       	lddpc	r11,80006584 <logFromISR+0x168>
80006504:	0c 9c       	mov	r12,r6
80006506:	f0 1f 00 1f 	mcall	80006580 <logFromISR+0x164>
8000650a:	08 95       	mov	r5,r4
8000650c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000650e:	0f 89       	ld.ub	r9,r7[0x0]
80006510:	30 08       	mov	r8,0
80006512:	f0 09 18 00 	cp.b	r9,r8
80006516:	c0 30       	breq	8000651c <logFromISR+0x100>
80006518:	0a 94       	mov	r4,r5
8000651a:	c9 8b       	rjmp	8000644a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000651c:	fa c7 fe f4 	sub	r7,sp,-268
80006520:	1a d7       	st.w	--sp,r7
80006522:	49 ab       	lddpc	r11,80006588 <logFromISR+0x16c>
80006524:	0e 9c       	mov	r12,r7
80006526:	f0 1f 00 17 	mcall	80006580 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000652a:	5c 5c       	castu.b	r12
8000652c:	f8 c6 ff ff 	sub	r6,r12,-1
80006530:	0c 9c       	mov	r12,r6
80006532:	f0 1f 00 17 	mcall	8000658c <logFromISR+0x170>
80006536:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006538:	0c 9a       	mov	r10,r6
8000653a:	0e 9b       	mov	r11,r7
8000653c:	f0 1f 00 15 	mcall	80006590 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006540:	30 09       	mov	r9,0
80006542:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006544:	fa ca fe f8 	sub	r10,sp,-264
80006548:	fa cb fe f4 	sub	r11,sp,-268
8000654c:	49 28       	lddpc	r8,80006594 <logFromISR+0x178>
8000654e:	70 0c       	ld.w	r12,r8[0x0]
80006550:	f0 1f 00 12 	mcall	80006598 <logFromISR+0x17c>
80006554:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006556:	fe 3d fd f4 	sub	sp,-524
8000655a:	d8 32       	popm	r0-r7,pc
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	6d 38       	ld.w	r8,r6[0x4c]
80006560:	00 00       	add	r0,r0
80006562:	0d 59       	ld.sh	r9,--r6
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	ce 10       	breq	80006528 <logFromISR+0x10c>
80006568:	80 00       	ld.sh	r0,r0[0x0]
8000656a:	61 b6       	ld.w	r6,r0[0x6c]
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	61 04       	ld.w	r4,r0[0x40]
80006570:	80 00       	ld.sh	r0,r0[0x0]
80006572:	61 00       	ld.w	r0,r0[0x40]
80006574:	80 00       	ld.sh	r0,r0[0x0]
80006576:	cf 7c       	rcall	80006764 <_stext+0xc>
80006578:	80 00       	ld.sh	r0,r0[0x0]
8000657a:	62 90       	ld.w	r0,r1[0x24]
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	cf 8c       	rcall	8000676e <_stext+0x16>
80006580:	80 00       	ld.sh	r0,r0[0x0]
80006582:	70 28       	ld.w	r8,r8[0x8]
80006584:	80 00       	ld.sh	r0,r0[0x0]
80006586:	cf 94       	brge	80006578 <logFromISR+0x15c>
80006588:	80 00       	ld.sh	r0,r0[0x0]
8000658a:	cf 9c       	rcall	8000677c <idata_load_loop_end>
8000658c:	80 00       	ld.sh	r0,r0[0x0]
8000658e:	53 4c       	stdsp	sp[0xd0],r12
80006590:	80 00       	ld.sh	r0,r0[0x0]
80006592:	6b f0       	ld.w	r0,r5[0x7c]
80006594:	00 00       	add	r0,r0
80006596:	41 10       	lddsp	r0,sp[0x44]
80006598:	80 00       	ld.sh	r0,r0[0x0]
8000659a:	56 50       	stdsp	sp[0x194],r0

8000659c <log_init>:
		
	return str;
}

void log_init(void)
{
8000659c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000659e:	30 2b       	mov	r11,2
800065a0:	49 0c       	lddpc	r12,800065e0 <log_init+0x44>
800065a2:	f0 1f 00 11 	mcall	800065e4 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800065a6:	e0 6a 36 00 	mov	r10,13824
800065aa:	ea 1a 01 6e 	orh	r10,0x16e
800065ae:	48 fb       	lddpc	r11,800065e8 <log_init+0x4c>
800065b0:	fe 7c 18 00 	mov	r12,-59392
800065b4:	f0 1f 00 0e 	mcall	800065ec <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800065b8:	30 4b       	mov	r11,4
800065ba:	33 2c       	mov	r12,50
800065bc:	f0 1f 00 0d 	mcall	800065f0 <log_init+0x54>
800065c0:	48 d8       	lddpc	r8,800065f4 <log_init+0x58>
800065c2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800065c4:	30 09       	mov	r9,0
800065c6:	1a d9       	st.w	--sp,r9
800065c8:	1a d9       	st.w	--sp,r9
800065ca:	1a d9       	st.w	--sp,r9
800065cc:	30 28       	mov	r8,2
800065ce:	e0 6a 01 80 	mov	r10,384
800065d2:	48 ab       	lddpc	r11,800065f8 <log_init+0x5c>
800065d4:	48 ac       	lddpc	r12,800065fc <log_init+0x60>
800065d6:	f0 1f 00 0b 	mcall	80006600 <log_init+0x64>
800065da:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800065dc:	d8 02       	popm	pc
800065de:	00 00       	add	r0,r0
800065e0:	80 00       	ld.sh	r0,r0[0x0]
800065e2:	cf a8       	rjmp	800067d6 <_malloc_r+0x1e>
800065e4:	80 00       	ld.sh	r0,r0[0x0]
800065e6:	67 28       	ld.w	r8,r3[0x48]
800065e8:	80 00       	ld.sh	r0,r0[0x0]
800065ea:	cf 60       	breq	800065d6 <log_init+0x3a>
800065ec:	80 00       	ld.sh	r0,r0[0x0]
800065ee:	4e f0       	lddpc	r0,800067a8 <malloc>
800065f0:	80 00       	ld.sh	r0,r0[0x0]
800065f2:	57 f8       	stdsp	sp[0x1fc],r8
800065f4:	00 00       	add	r0,r0
800065f6:	41 10       	lddsp	r0,sp[0x44]
800065f8:	80 00       	ld.sh	r0,r0[0x0]
800065fa:	cf a4       	brge	800065ee <log_init+0x52>
800065fc:	80 00       	ld.sh	r0,r0[0x0]
800065fe:	66 04       	ld.w	r4,r3[0x0]
80006600:	80 00       	ld.sh	r0,r0[0x0]
80006602:	5e cc       	retvs	r12

80006604 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006604:	eb cd 40 f8 	pushm	r3-r7,lr
80006608:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000660a:	48 c7       	lddpc	r7,80006638 <task_log+0x34>
8000660c:	30 05       	mov	r5,0
8000660e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006610:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006614:	0a 99       	mov	r9,r5
80006616:	08 9a       	mov	r10,r4
80006618:	1a 9b       	mov	r11,sp
8000661a:	6e 0c       	ld.w	r12,r7[0x0]
8000661c:	f0 1f 00 08 	mcall	8000663c <task_log+0x38>
80006620:	58 1c       	cp.w	r12,1
80006622:	cf 91       	brne	80006614 <task_log+0x10>
		{
			if( NULL != str)
80006624:	40 0b       	lddsp	r11,sp[0x0]
80006626:	58 0b       	cp.w	r11,0
80006628:	cf 60       	breq	80006614 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000662a:	06 9c       	mov	r12,r3
8000662c:	f0 1f 00 05 	mcall	80006640 <task_log+0x3c>
				vPortFree(str);
80006630:	40 0c       	lddsp	r12,sp[0x0]
80006632:	f0 1f 00 05 	mcall	80006644 <task_log+0x40>
80006636:	ce fb       	rjmp	80006614 <task_log+0x10>
80006638:	00 00       	add	r0,r0
8000663a:	41 10       	lddsp	r0,sp[0x44]
8000663c:	80 00       	ld.sh	r0,r0[0x0]
8000663e:	54 94       	stdsp	sp[0x124],r4
80006640:	80 00       	ld.sh	r0,r0[0x0]
80006642:	4e a0       	lddpc	r0,800067e8 <_malloc_r+0x30>
80006644:	80 00       	ld.sh	r0,r0[0x0]
80006646:	53 24       	stdsp	sp[0xc8],r4

80006648 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80006648:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000664a:	fe 78 10 00 	mov	r8,-61440
8000664e:	30 19       	mov	r9,1
80006650:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006654:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006658:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000665c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000665e:	f0 1f 00 13 	mcall	800066a8 <main+0x60>
		
	INTC_init_interrupts();
80006662:	f0 1f 00 13 	mcall	800066ac <main+0x64>
	
	log_init();		
80006666:	f0 1f 00 13 	mcall	800066b0 <main+0x68>
	log("----start debug----");	
8000666a:	49 3c       	lddpc	r12,800066b4 <main+0x6c>
8000666c:	f0 1f 00 13 	mcall	800066b8 <main+0x70>
		
	rtc_init();
80006670:	f0 1f 00 13 	mcall	800066bc <main+0x74>
	
	//fs_init();//65795机器无法通过文件系统初始化

	tc_init();	
80006674:	f0 1f 00 13 	mcall	800066c0 <main+0x78>
			
	xcmp_init();
80006678:	f0 1f 00 13 	mcall	800066c4 <main+0x7c>
	
	app_init();
8000667c:	f0 1f 00 13 	mcall	800066c8 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006680:	fe 79 10 00 	mov	r9,-61440
80006684:	f2 f8 01 60 	ld.w	r8,r9[352]
80006688:	e2 18 00 02 	andl	r8,0x2,COH
8000668c:	cf c0       	breq	80006684 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000668e:	fe 79 10 00 	mov	r9,-61440
80006692:	f2 f8 01 60 	ld.w	r8,r9[352]
80006696:	e2 18 00 02 	andl	r8,0x2,COH
8000669a:	cf c1       	brne	80006692 <main+0x4a>
	local_start_timer();
8000669c:	f0 1f 00 0c 	mcall	800066cc <main+0x84>
	
	Enable_global_interrupt();
800066a0:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
800066a2:	f0 1f 00 0c 	mcall	800066d0 <main+0x88>
	return 0;
}
800066a6:	d8 0a       	popm	pc,r12=0
800066a8:	80 00       	ld.sh	r0,r0[0x0]
800066aa:	47 c0       	lddsp	r0,sp[0x1f0]
800066ac:	80 00       	ld.sh	r0,r0[0x0]
800066ae:	49 dc       	lddpc	r12,80006720 <gpio_enable_module_pin+0x4c>
800066b0:	80 00       	ld.sh	r0,r0[0x0]
800066b2:	65 9c       	ld.w	r12,r2[0x64]
800066b4:	80 00       	ld.sh	r0,r0[0x0]
800066b6:	cf b8       	rjmp	800068ac <_malloc_r+0xf4>
800066b8:	80 00       	ld.sh	r0,r0[0x0]
800066ba:	62 90       	ld.w	r0,r1[0x24]
800066bc:	80 00       	ld.sh	r0,r0[0x0]
800066be:	48 10       	lddpc	r0,800066c0 <main+0x78>
800066c0:	80 00       	ld.sh	r0,r0[0x0]
800066c2:	48 d8       	lddpc	r8,800066f4 <gpio_enable_module_pin+0x20>
800066c4:	80 00       	ld.sh	r0,r0[0x0]
800066c6:	40 c4       	lddsp	r4,sp[0x30]
800066c8:	80 00       	ld.sh	r0,r0[0x0]
800066ca:	20 40       	sub	r0,4
800066cc:	80 00       	ld.sh	r0,r0[0x0]
800066ce:	48 9c       	lddpc	r12,800066f0 <gpio_enable_module_pin+0x1c>
800066d0:	80 00       	ld.sh	r0,r0[0x0]
800066d2:	60 b4       	ld.w	r4,r0[0x2c]

800066d4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800066d4:	f8 08 16 05 	lsr	r8,r12,0x5
800066d8:	a9 68       	lsl	r8,0x8
800066da:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800066de:	58 1b       	cp.w	r11,1
800066e0:	c0 d0       	breq	800066fa <gpio_enable_module_pin+0x26>
800066e2:	c0 63       	brcs	800066ee <gpio_enable_module_pin+0x1a>
800066e4:	58 2b       	cp.w	r11,2
800066e6:	c1 00       	breq	80006706 <gpio_enable_module_pin+0x32>
800066e8:	58 3b       	cp.w	r11,3
800066ea:	c1 40       	breq	80006712 <gpio_enable_module_pin+0x3e>
800066ec:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800066ee:	30 19       	mov	r9,1
800066f0:	f2 0c 09 49 	lsl	r9,r9,r12
800066f4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800066f6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800066f8:	c1 28       	rjmp	8000671c <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800066fa:	30 19       	mov	r9,1
800066fc:	f2 0c 09 49 	lsl	r9,r9,r12
80006700:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006702:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006704:	c0 c8       	rjmp	8000671c <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006706:	30 19       	mov	r9,1
80006708:	f2 0c 09 49 	lsl	r9,r9,r12
8000670c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000670e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006710:	c0 68       	rjmp	8000671c <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006712:	30 19       	mov	r9,1
80006714:	f2 0c 09 49 	lsl	r9,r9,r12
80006718:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000671a:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000671c:	30 19       	mov	r9,1
8000671e:	f2 0c 09 4c 	lsl	r12,r9,r12
80006722:	91 2c       	st.w	r8[0x8],r12
80006724:	5e fd       	retal	0
80006726:	d7 03       	nop

80006728 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006728:	d4 21       	pushm	r4-r7,lr
8000672a:	18 97       	mov	r7,r12
8000672c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000672e:	58 0b       	cp.w	r11,0
80006730:	c0 31       	brne	80006736 <gpio_enable_module+0xe>
80006732:	30 05       	mov	r5,0
80006734:	c0 d8       	rjmp	8000674e <gpio_enable_module+0x26>
80006736:	30 06       	mov	r6,0
80006738:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000673a:	6e 1b       	ld.w	r11,r7[0x4]
8000673c:	6e 0c       	ld.w	r12,r7[0x0]
8000673e:	f0 1f 00 06 	mcall	80006754 <gpio_enable_module+0x2c>
80006742:	18 45       	or	r5,r12
		gpiomap++;
80006744:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006746:	2f f6       	sub	r6,-1
80006748:	0c 34       	cp.w	r4,r6
8000674a:	fe 9b ff f8 	brhi	8000673a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000674e:	0a 9c       	mov	r12,r5
80006750:	d8 22       	popm	r4-r7,pc
80006752:	00 00       	add	r0,r0
80006754:	80 00       	ld.sh	r0,r0[0x0]
80006756:	66 d4       	ld.w	r4,r3[0x34]

80006758 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006758:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000675c:	fe c0 a5 5c 	sub	r0,pc,-23204

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006760:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006764:	d5 53       	csrf	0x15
  cp      r0, r1
80006766:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006768:	e0 61 0a 38 	mov	r1,2616
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000676c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000676e:	c0 72       	brcc	8000677c <idata_load_loop_end>
  cp      r0, r1
80006770:	fe c2 92 20 	sub	r2,pc,-28128

80006774 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006774:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80006776:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80006778:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000677a:	cf d3       	brcs	80006774 <idata_load_loop>

8000677c <idata_load_loop_end>:
  mov     r2, 0
8000677c:	e0 60 0a 38 	mov	r0,2616
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006780:	e0 61 41 18 	mov	r1,16664
  cp      r0, r1
  brlo    udata_clear_loop
80006784:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006786:	c0 62       	brcc	80006792 <udata_clear_loop_end>
80006788:	30 02       	mov	r2,0
8000678a:	30 03       	mov	r3,0

8000678c <udata_clear_loop>:
8000678c:	a1 22       	st.d	r0++,r2
8000678e:	02 30       	cp.w	r0,r1
80006790:	cf e3       	brcs	8000678c <udata_clear_loop>

80006792 <udata_clear_loop_end>:
80006792:	fe cf 01 4a 	sub	pc,pc,330
80006796:	d7 03       	nop

80006798 <free>:
80006798:	d4 01       	pushm	lr
8000679a:	e0 68 0a 30 	mov	r8,2608
8000679e:	18 9b       	mov	r11,r12
800067a0:	70 0c       	ld.w	r12,r8[0x0]
800067a2:	e0 a0 1e 6d 	rcall	8000a47c <_free_r>
800067a6:	d8 02       	popm	pc

800067a8 <malloc>:
800067a8:	d4 01       	pushm	lr
800067aa:	e0 68 0a 30 	mov	r8,2608
800067ae:	18 9b       	mov	r11,r12
800067b0:	70 0c       	ld.w	r12,r8[0x0]
800067b2:	c0 3c       	rcall	800067b8 <_malloc_r>
800067b4:	d8 02       	popm	pc
800067b6:	d7 03       	nop

800067b8 <_malloc_r>:
800067b8:	d4 31       	pushm	r0-r7,lr
800067ba:	f6 c8 ff f5 	sub	r8,r11,-11
800067be:	18 95       	mov	r5,r12
800067c0:	10 97       	mov	r7,r8
800067c2:	e0 17 ff f8 	andl	r7,0xfff8
800067c6:	59 68       	cp.w	r8,22
800067c8:	f9 b7 08 10 	movls	r7,16
800067cc:	16 37       	cp.w	r7,r11
800067ce:	5f 38       	srlo	r8
800067d0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800067d4:	c0 50       	breq	800067de <_malloc_r+0x26>
800067d6:	30 c8       	mov	r8,12
800067d8:	99 38       	st.w	r12[0xc],r8
800067da:	e0 8f 01 fa 	bral	80006bce <_malloc_r+0x416>
800067de:	fe b0 f5 59 	rcall	80005290 <__malloc_lock>
800067e2:	e0 47 01 f7 	cp.w	r7,503
800067e6:	e0 8b 00 1d 	brhi	80006820 <_malloc_r+0x68>
800067ea:	ee 03 16 03 	lsr	r3,r7,0x3
800067ee:	e0 68 05 30 	mov	r8,1328
800067f2:	f0 03 00 38 	add	r8,r8,r3<<0x3
800067f6:	70 36       	ld.w	r6,r8[0xc]
800067f8:	10 36       	cp.w	r6,r8
800067fa:	c0 61       	brne	80006806 <_malloc_r+0x4e>
800067fc:	ec c8 ff f8 	sub	r8,r6,-8
80006800:	70 36       	ld.w	r6,r8[0xc]
80006802:	10 36       	cp.w	r6,r8
80006804:	c0 c0       	breq	8000681c <_malloc_r+0x64>
80006806:	6c 18       	ld.w	r8,r6[0x4]
80006808:	e0 18 ff fc 	andl	r8,0xfffc
8000680c:	6c 3a       	ld.w	r10,r6[0xc]
8000680e:	ec 08 00 09 	add	r9,r6,r8
80006812:	0a 9c       	mov	r12,r5
80006814:	6c 28       	ld.w	r8,r6[0x8]
80006816:	95 28       	st.w	r10[0x8],r8
80006818:	91 3a       	st.w	r8[0xc],r10
8000681a:	c4 78       	rjmp	800068a8 <_malloc_r+0xf0>
8000681c:	2f e3       	sub	r3,-2
8000681e:	c4 d8       	rjmp	800068b8 <_malloc_r+0x100>
80006820:	ee 03 16 09 	lsr	r3,r7,0x9
80006824:	c0 41       	brne	8000682c <_malloc_r+0x74>
80006826:	ee 03 16 03 	lsr	r3,r7,0x3
8000682a:	c2 68       	rjmp	80006876 <_malloc_r+0xbe>
8000682c:	58 43       	cp.w	r3,4
8000682e:	e0 8b 00 06 	brhi	8000683a <_malloc_r+0x82>
80006832:	ee 03 16 06 	lsr	r3,r7,0x6
80006836:	2c 83       	sub	r3,-56
80006838:	c1 f8       	rjmp	80006876 <_malloc_r+0xbe>
8000683a:	59 43       	cp.w	r3,20
8000683c:	e0 8b 00 04 	brhi	80006844 <_malloc_r+0x8c>
80006840:	2a 53       	sub	r3,-91
80006842:	c1 a8       	rjmp	80006876 <_malloc_r+0xbe>
80006844:	e0 43 00 54 	cp.w	r3,84
80006848:	e0 8b 00 06 	brhi	80006854 <_malloc_r+0x9c>
8000684c:	ee 03 16 0c 	lsr	r3,r7,0xc
80006850:	29 23       	sub	r3,-110
80006852:	c1 28       	rjmp	80006876 <_malloc_r+0xbe>
80006854:	e0 43 01 54 	cp.w	r3,340
80006858:	e0 8b 00 06 	brhi	80006864 <_malloc_r+0xac>
8000685c:	ee 03 16 0f 	lsr	r3,r7,0xf
80006860:	28 93       	sub	r3,-119
80006862:	c0 a8       	rjmp	80006876 <_malloc_r+0xbe>
80006864:	e0 43 05 54 	cp.w	r3,1364
80006868:	e0 88 00 04 	brls	80006870 <_malloc_r+0xb8>
8000686c:	37 e3       	mov	r3,126
8000686e:	c0 48       	rjmp	80006876 <_malloc_r+0xbe>
80006870:	ee 03 16 12 	lsr	r3,r7,0x12
80006874:	28 43       	sub	r3,-124
80006876:	e0 6a 05 30 	mov	r10,1328
8000687a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000687e:	74 36       	ld.w	r6,r10[0xc]
80006880:	c1 98       	rjmp	800068b2 <_malloc_r+0xfa>
80006882:	6c 19       	ld.w	r9,r6[0x4]
80006884:	e0 19 ff fc 	andl	r9,0xfffc
80006888:	f2 07 01 0b 	sub	r11,r9,r7
8000688c:	58 fb       	cp.w	r11,15
8000688e:	e0 8a 00 04 	brle	80006896 <_malloc_r+0xde>
80006892:	20 13       	sub	r3,1
80006894:	c1 18       	rjmp	800068b6 <_malloc_r+0xfe>
80006896:	6c 38       	ld.w	r8,r6[0xc]
80006898:	58 0b       	cp.w	r11,0
8000689a:	c0 b5       	brlt	800068b0 <_malloc_r+0xf8>
8000689c:	6c 2a       	ld.w	r10,r6[0x8]
8000689e:	ec 09 00 09 	add	r9,r6,r9
800068a2:	0a 9c       	mov	r12,r5
800068a4:	91 2a       	st.w	r8[0x8],r10
800068a6:	95 38       	st.w	r10[0xc],r8
800068a8:	72 18       	ld.w	r8,r9[0x4]
800068aa:	a1 a8       	sbr	r8,0x0
800068ac:	93 18       	st.w	r9[0x4],r8
800068ae:	cb c8       	rjmp	80006a26 <_malloc_r+0x26e>
800068b0:	10 96       	mov	r6,r8
800068b2:	14 36       	cp.w	r6,r10
800068b4:	ce 71       	brne	80006882 <_malloc_r+0xca>
800068b6:	2f f3       	sub	r3,-1
800068b8:	e0 6a 05 30 	mov	r10,1328
800068bc:	f4 cc ff f8 	sub	r12,r10,-8
800068c0:	78 26       	ld.w	r6,r12[0x8]
800068c2:	18 36       	cp.w	r6,r12
800068c4:	c6 c0       	breq	8000699c <_malloc_r+0x1e4>
800068c6:	6c 19       	ld.w	r9,r6[0x4]
800068c8:	e0 19 ff fc 	andl	r9,0xfffc
800068cc:	f2 07 01 08 	sub	r8,r9,r7
800068d0:	58 f8       	cp.w	r8,15
800068d2:	e0 89 00 8f 	brgt	800069f0 <_malloc_r+0x238>
800068d6:	99 3c       	st.w	r12[0xc],r12
800068d8:	99 2c       	st.w	r12[0x8],r12
800068da:	58 08       	cp.w	r8,0
800068dc:	c0 55       	brlt	800068e6 <_malloc_r+0x12e>
800068de:	ec 09 00 09 	add	r9,r6,r9
800068e2:	0a 9c       	mov	r12,r5
800068e4:	ce 2b       	rjmp	800068a8 <_malloc_r+0xf0>
800068e6:	e0 49 01 ff 	cp.w	r9,511
800068ea:	e0 8b 00 13 	brhi	80006910 <_malloc_r+0x158>
800068ee:	a3 99       	lsr	r9,0x3
800068f0:	f4 09 00 38 	add	r8,r10,r9<<0x3
800068f4:	70 2b       	ld.w	r11,r8[0x8]
800068f6:	8d 38       	st.w	r6[0xc],r8
800068f8:	8d 2b       	st.w	r6[0x8],r11
800068fa:	97 36       	st.w	r11[0xc],r6
800068fc:	91 26       	st.w	r8[0x8],r6
800068fe:	a3 49       	asr	r9,0x2
80006900:	74 18       	ld.w	r8,r10[0x4]
80006902:	30 1b       	mov	r11,1
80006904:	f6 09 09 49 	lsl	r9,r11,r9
80006908:	f1 e9 10 09 	or	r9,r8,r9
8000690c:	95 19       	st.w	r10[0x4],r9
8000690e:	c4 78       	rjmp	8000699c <_malloc_r+0x1e4>
80006910:	f2 0a 16 09 	lsr	r10,r9,0x9
80006914:	58 4a       	cp.w	r10,4
80006916:	e0 8b 00 07 	brhi	80006924 <_malloc_r+0x16c>
8000691a:	f2 0a 16 06 	lsr	r10,r9,0x6
8000691e:	2c 8a       	sub	r10,-56
80006920:	c2 08       	rjmp	80006960 <_malloc_r+0x1a8>
80006922:	d7 03       	nop
80006924:	59 4a       	cp.w	r10,20
80006926:	e0 8b 00 04 	brhi	8000692e <_malloc_r+0x176>
8000692a:	2a 5a       	sub	r10,-91
8000692c:	c1 a8       	rjmp	80006960 <_malloc_r+0x1a8>
8000692e:	e0 4a 00 54 	cp.w	r10,84
80006932:	e0 8b 00 06 	brhi	8000693e <_malloc_r+0x186>
80006936:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000693a:	29 2a       	sub	r10,-110
8000693c:	c1 28       	rjmp	80006960 <_malloc_r+0x1a8>
8000693e:	e0 4a 01 54 	cp.w	r10,340
80006942:	e0 8b 00 06 	brhi	8000694e <_malloc_r+0x196>
80006946:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000694a:	28 9a       	sub	r10,-119
8000694c:	c0 a8       	rjmp	80006960 <_malloc_r+0x1a8>
8000694e:	e0 4a 05 54 	cp.w	r10,1364
80006952:	e0 88 00 04 	brls	8000695a <_malloc_r+0x1a2>
80006956:	37 ea       	mov	r10,126
80006958:	c0 48       	rjmp	80006960 <_malloc_r+0x1a8>
8000695a:	f2 0a 16 12 	lsr	r10,r9,0x12
8000695e:	28 4a       	sub	r10,-124
80006960:	e0 6b 05 30 	mov	r11,1328
80006964:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006968:	68 28       	ld.w	r8,r4[0x8]
8000696a:	08 38       	cp.w	r8,r4
8000696c:	c0 e1       	brne	80006988 <_malloc_r+0x1d0>
8000696e:	76 19       	ld.w	r9,r11[0x4]
80006970:	a3 4a       	asr	r10,0x2
80006972:	30 1e       	mov	lr,1
80006974:	fc 0a 09 4a 	lsl	r10,lr,r10
80006978:	f3 ea 10 0a 	or	r10,r9,r10
8000697c:	10 99       	mov	r9,r8
8000697e:	97 1a       	st.w	r11[0x4],r10
80006980:	c0 a8       	rjmp	80006994 <_malloc_r+0x1dc>
80006982:	70 28       	ld.w	r8,r8[0x8]
80006984:	08 38       	cp.w	r8,r4
80006986:	c0 60       	breq	80006992 <_malloc_r+0x1da>
80006988:	70 1a       	ld.w	r10,r8[0x4]
8000698a:	e0 1a ff fc 	andl	r10,0xfffc
8000698e:	14 39       	cp.w	r9,r10
80006990:	cf 93       	brcs	80006982 <_malloc_r+0x1ca>
80006992:	70 39       	ld.w	r9,r8[0xc]
80006994:	8d 39       	st.w	r6[0xc],r9
80006996:	8d 28       	st.w	r6[0x8],r8
80006998:	91 36       	st.w	r8[0xc],r6
8000699a:	93 26       	st.w	r9[0x8],r6
8000699c:	e6 08 14 02 	asr	r8,r3,0x2
800069a0:	30 1b       	mov	r11,1
800069a2:	e0 64 05 30 	mov	r4,1328
800069a6:	f6 08 09 4b 	lsl	r11,r11,r8
800069aa:	68 18       	ld.w	r8,r4[0x4]
800069ac:	10 3b       	cp.w	r11,r8
800069ae:	e0 8b 00 6b 	brhi	80006a84 <_malloc_r+0x2cc>
800069b2:	f7 e8 00 09 	and	r9,r11,r8
800069b6:	c0 b1       	brne	800069cc <_malloc_r+0x214>
800069b8:	e0 13 ff fc 	andl	r3,0xfffc
800069bc:	a1 7b       	lsl	r11,0x1
800069be:	2f c3       	sub	r3,-4
800069c0:	c0 38       	rjmp	800069c6 <_malloc_r+0x20e>
800069c2:	2f c3       	sub	r3,-4
800069c4:	a1 7b       	lsl	r11,0x1
800069c6:	f7 e8 00 09 	and	r9,r11,r8
800069ca:	cf c0       	breq	800069c2 <_malloc_r+0x20a>
800069cc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800069d0:	06 92       	mov	r2,r3
800069d2:	1c 91       	mov	r1,lr
800069d4:	62 36       	ld.w	r6,r1[0xc]
800069d6:	c2 e8       	rjmp	80006a32 <_malloc_r+0x27a>
800069d8:	6c 1a       	ld.w	r10,r6[0x4]
800069da:	e0 1a ff fc 	andl	r10,0xfffc
800069de:	f4 07 01 08 	sub	r8,r10,r7
800069e2:	58 f8       	cp.w	r8,15
800069e4:	e0 8a 00 15 	brle	80006a0e <_malloc_r+0x256>
800069e8:	6c 3a       	ld.w	r10,r6[0xc]
800069ea:	6c 29       	ld.w	r9,r6[0x8]
800069ec:	95 29       	st.w	r10[0x8],r9
800069ee:	93 3a       	st.w	r9[0xc],r10
800069f0:	0e 99       	mov	r9,r7
800069f2:	ec 07 00 07 	add	r7,r6,r7
800069f6:	a1 a9       	sbr	r9,0x0
800069f8:	99 37       	st.w	r12[0xc],r7
800069fa:	99 27       	st.w	r12[0x8],r7
800069fc:	8d 19       	st.w	r6[0x4],r9
800069fe:	ee 08 09 08 	st.w	r7[r8],r8
80006a02:	8f 2c       	st.w	r7[0x8],r12
80006a04:	8f 3c       	st.w	r7[0xc],r12
80006a06:	a1 a8       	sbr	r8,0x0
80006a08:	0a 9c       	mov	r12,r5
80006a0a:	8f 18       	st.w	r7[0x4],r8
80006a0c:	c0 d8       	rjmp	80006a26 <_malloc_r+0x26e>
80006a0e:	6c 39       	ld.w	r9,r6[0xc]
80006a10:	58 08       	cp.w	r8,0
80006a12:	c0 f5       	brlt	80006a30 <_malloc_r+0x278>
80006a14:	ec 0a 00 0a 	add	r10,r6,r10
80006a18:	74 18       	ld.w	r8,r10[0x4]
80006a1a:	a1 a8       	sbr	r8,0x0
80006a1c:	0a 9c       	mov	r12,r5
80006a1e:	95 18       	st.w	r10[0x4],r8
80006a20:	6c 28       	ld.w	r8,r6[0x8]
80006a22:	93 28       	st.w	r9[0x8],r8
80006a24:	91 39       	st.w	r8[0xc],r9
80006a26:	fe b0 f4 3b 	rcall	8000529c <__malloc_unlock>
80006a2a:	ec cc ff f8 	sub	r12,r6,-8
80006a2e:	d8 32       	popm	r0-r7,pc
80006a30:	12 96       	mov	r6,r9
80006a32:	02 36       	cp.w	r6,r1
80006a34:	cd 21       	brne	800069d8 <_malloc_r+0x220>
80006a36:	2f f2       	sub	r2,-1
80006a38:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006a3c:	c0 30       	breq	80006a42 <_malloc_r+0x28a>
80006a3e:	2f 81       	sub	r1,-8
80006a40:	cc ab       	rjmp	800069d4 <_malloc_r+0x21c>
80006a42:	1c 98       	mov	r8,lr
80006a44:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006a48:	c0 81       	brne	80006a58 <_malloc_r+0x2a0>
80006a4a:	68 19       	ld.w	r9,r4[0x4]
80006a4c:	f6 08 11 ff 	rsub	r8,r11,-1
80006a50:	f3 e8 00 08 	and	r8,r9,r8
80006a54:	89 18       	st.w	r4[0x4],r8
80006a56:	c0 78       	rjmp	80006a64 <_malloc_r+0x2ac>
80006a58:	f0 c9 00 08 	sub	r9,r8,8
80006a5c:	20 13       	sub	r3,1
80006a5e:	70 08       	ld.w	r8,r8[0x0]
80006a60:	12 38       	cp.w	r8,r9
80006a62:	cf 10       	breq	80006a44 <_malloc_r+0x28c>
80006a64:	a1 7b       	lsl	r11,0x1
80006a66:	68 18       	ld.w	r8,r4[0x4]
80006a68:	10 3b       	cp.w	r11,r8
80006a6a:	e0 8b 00 0d 	brhi	80006a84 <_malloc_r+0x2cc>
80006a6e:	58 0b       	cp.w	r11,0
80006a70:	c0 a0       	breq	80006a84 <_malloc_r+0x2cc>
80006a72:	04 93       	mov	r3,r2
80006a74:	c0 38       	rjmp	80006a7a <_malloc_r+0x2c2>
80006a76:	2f c3       	sub	r3,-4
80006a78:	a1 7b       	lsl	r11,0x1
80006a7a:	f7 e8 00 09 	and	r9,r11,r8
80006a7e:	ca 71       	brne	800069cc <_malloc_r+0x214>
80006a80:	cf bb       	rjmp	80006a76 <_malloc_r+0x2be>
80006a82:	d7 03       	nop
80006a84:	68 23       	ld.w	r3,r4[0x8]
80006a86:	66 12       	ld.w	r2,r3[0x4]
80006a88:	e0 12 ff fc 	andl	r2,0xfffc
80006a8c:	0e 32       	cp.w	r2,r7
80006a8e:	5f 39       	srlo	r9
80006a90:	e4 07 01 08 	sub	r8,r2,r7
80006a94:	58 f8       	cp.w	r8,15
80006a96:	5f aa       	srle	r10
80006a98:	f5 e9 10 09 	or	r9,r10,r9
80006a9c:	e0 80 00 9a 	breq	80006bd0 <_malloc_r+0x418>
80006aa0:	e0 68 0d 64 	mov	r8,3428
80006aa4:	70 01       	ld.w	r1,r8[0x0]
80006aa6:	e0 68 09 3c 	mov	r8,2364
80006aaa:	2f 01       	sub	r1,-16
80006aac:	70 08       	ld.w	r8,r8[0x0]
80006aae:	0e 01       	add	r1,r7
80006ab0:	5b f8       	cp.w	r8,-1
80006ab2:	c0 40       	breq	80006aba <_malloc_r+0x302>
80006ab4:	28 11       	sub	r1,-127
80006ab6:	e0 11 ff 80 	andl	r1,0xff80
80006aba:	02 9b       	mov	r11,r1
80006abc:	0a 9c       	mov	r12,r5
80006abe:	e0 a0 02 a5 	rcall	80007008 <_sbrk_r>
80006ac2:	18 96       	mov	r6,r12
80006ac4:	5b fc       	cp.w	r12,-1
80006ac6:	c7 50       	breq	80006bb0 <_malloc_r+0x3f8>
80006ac8:	e6 02 00 08 	add	r8,r3,r2
80006acc:	10 3c       	cp.w	r12,r8
80006ace:	c0 32       	brcc	80006ad4 <_malloc_r+0x31c>
80006ad0:	08 33       	cp.w	r3,r4
80006ad2:	c6 f1       	brne	80006bb0 <_malloc_r+0x3f8>
80006ad4:	e0 6a 0d 68 	mov	r10,3432
80006ad8:	74 09       	ld.w	r9,r10[0x0]
80006ada:	e2 09 00 09 	add	r9,r1,r9
80006ade:	95 09       	st.w	r10[0x0],r9
80006ae0:	10 36       	cp.w	r6,r8
80006ae2:	c0 a1       	brne	80006af6 <_malloc_r+0x33e>
80006ae4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006ae8:	c0 71       	brne	80006af6 <_malloc_r+0x33e>
80006aea:	e2 02 00 02 	add	r2,r1,r2
80006aee:	68 28       	ld.w	r8,r4[0x8]
80006af0:	a1 a2       	sbr	r2,0x0
80006af2:	91 12       	st.w	r8[0x4],r2
80006af4:	c4 f8       	rjmp	80006b92 <_malloc_r+0x3da>
80006af6:	e0 6a 09 3c 	mov	r10,2364
80006afa:	74 0b       	ld.w	r11,r10[0x0]
80006afc:	5b fb       	cp.w	r11,-1
80006afe:	c0 31       	brne	80006b04 <_malloc_r+0x34c>
80006b00:	95 06       	st.w	r10[0x0],r6
80006b02:	c0 78       	rjmp	80006b10 <_malloc_r+0x358>
80006b04:	ec 09 00 09 	add	r9,r6,r9
80006b08:	e0 6a 0d 68 	mov	r10,3432
80006b0c:	10 19       	sub	r9,r8
80006b0e:	95 09       	st.w	r10[0x0],r9
80006b10:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006b14:	f0 09 11 08 	rsub	r9,r8,8
80006b18:	58 08       	cp.w	r8,0
80006b1a:	f2 08 17 10 	movne	r8,r9
80006b1e:	ed d8 e1 06 	addne	r6,r6,r8
80006b22:	28 08       	sub	r8,-128
80006b24:	ec 01 00 01 	add	r1,r6,r1
80006b28:	0a 9c       	mov	r12,r5
80006b2a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006b2e:	f0 01 01 01 	sub	r1,r8,r1
80006b32:	02 9b       	mov	r11,r1
80006b34:	e0 a0 02 6a 	rcall	80007008 <_sbrk_r>
80006b38:	e0 68 0d 68 	mov	r8,3432
80006b3c:	5b fc       	cp.w	r12,-1
80006b3e:	ec 0c 17 00 	moveq	r12,r6
80006b42:	f9 b1 00 00 	moveq	r1,0
80006b46:	70 09       	ld.w	r9,r8[0x0]
80006b48:	0c 1c       	sub	r12,r6
80006b4a:	89 26       	st.w	r4[0x8],r6
80006b4c:	02 0c       	add	r12,r1
80006b4e:	12 01       	add	r1,r9
80006b50:	a1 ac       	sbr	r12,0x0
80006b52:	91 01       	st.w	r8[0x0],r1
80006b54:	8d 1c       	st.w	r6[0x4],r12
80006b56:	08 33       	cp.w	r3,r4
80006b58:	c1 d0       	breq	80006b92 <_malloc_r+0x3da>
80006b5a:	58 f2       	cp.w	r2,15
80006b5c:	e0 8b 00 05 	brhi	80006b66 <_malloc_r+0x3ae>
80006b60:	30 18       	mov	r8,1
80006b62:	8d 18       	st.w	r6[0x4],r8
80006b64:	c2 68       	rjmp	80006bb0 <_malloc_r+0x3f8>
80006b66:	30 59       	mov	r9,5
80006b68:	20 c2       	sub	r2,12
80006b6a:	e0 12 ff f8 	andl	r2,0xfff8
80006b6e:	e6 02 00 08 	add	r8,r3,r2
80006b72:	91 29       	st.w	r8[0x8],r9
80006b74:	91 19       	st.w	r8[0x4],r9
80006b76:	66 18       	ld.w	r8,r3[0x4]
80006b78:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006b7c:	e5 e8 10 08 	or	r8,r2,r8
80006b80:	87 18       	st.w	r3[0x4],r8
80006b82:	58 f2       	cp.w	r2,15
80006b84:	e0 88 00 07 	brls	80006b92 <_malloc_r+0x3da>
80006b88:	e6 cb ff f8 	sub	r11,r3,-8
80006b8c:	0a 9c       	mov	r12,r5
80006b8e:	e0 a0 1c 77 	rcall	8000a47c <_free_r>
80006b92:	e0 69 0d 60 	mov	r9,3424
80006b96:	72 0a       	ld.w	r10,r9[0x0]
80006b98:	e0 68 0d 68 	mov	r8,3432
80006b9c:	70 08       	ld.w	r8,r8[0x0]
80006b9e:	14 38       	cp.w	r8,r10
80006ba0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006ba4:	e0 69 0d 5c 	mov	r9,3420
80006ba8:	72 0a       	ld.w	r10,r9[0x0]
80006baa:	14 38       	cp.w	r8,r10
80006bac:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006bb0:	68 28       	ld.w	r8,r4[0x8]
80006bb2:	70 18       	ld.w	r8,r8[0x4]
80006bb4:	e0 18 ff fc 	andl	r8,0xfffc
80006bb8:	0e 38       	cp.w	r8,r7
80006bba:	5f 39       	srlo	r9
80006bbc:	0e 18       	sub	r8,r7
80006bbe:	58 f8       	cp.w	r8,15
80006bc0:	5f aa       	srle	r10
80006bc2:	f5 e9 10 09 	or	r9,r10,r9
80006bc6:	c0 50       	breq	80006bd0 <_malloc_r+0x418>
80006bc8:	0a 9c       	mov	r12,r5
80006bca:	fe b0 f3 69 	rcall	8000529c <__malloc_unlock>
80006bce:	d8 3a       	popm	r0-r7,pc,r12=0
80006bd0:	68 26       	ld.w	r6,r4[0x8]
80006bd2:	a1 a8       	sbr	r8,0x0
80006bd4:	0e 99       	mov	r9,r7
80006bd6:	a1 a9       	sbr	r9,0x0
80006bd8:	8d 19       	st.w	r6[0x4],r9
80006bda:	ec 07 00 07 	add	r7,r6,r7
80006bde:	0a 9c       	mov	r12,r5
80006be0:	89 27       	st.w	r4[0x8],r7
80006be2:	8f 18       	st.w	r7[0x4],r8
80006be4:	fe b0 f3 5c 	rcall	8000529c <__malloc_unlock>
80006be8:	ec cc ff f8 	sub	r12,r6,-8
80006bec:	d8 32       	popm	r0-r7,pc
80006bee:	d7 03       	nop

80006bf0 <memcpy>:
80006bf0:	58 8a       	cp.w	r10,8
80006bf2:	c2 f5       	brlt	80006c50 <memcpy+0x60>
80006bf4:	f9 eb 10 09 	or	r9,r12,r11
80006bf8:	e2 19 00 03 	andl	r9,0x3,COH
80006bfc:	e0 81 00 97 	brne	80006d2a <memcpy+0x13a>
80006c00:	e0 4a 00 20 	cp.w	r10,32
80006c04:	c3 b4       	brge	80006c7a <memcpy+0x8a>
80006c06:	f4 08 14 02 	asr	r8,r10,0x2
80006c0a:	f0 09 11 08 	rsub	r9,r8,8
80006c0e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006c12:	76 69       	ld.w	r9,r11[0x18]
80006c14:	99 69       	st.w	r12[0x18],r9
80006c16:	76 59       	ld.w	r9,r11[0x14]
80006c18:	99 59       	st.w	r12[0x14],r9
80006c1a:	76 49       	ld.w	r9,r11[0x10]
80006c1c:	99 49       	st.w	r12[0x10],r9
80006c1e:	76 39       	ld.w	r9,r11[0xc]
80006c20:	99 39       	st.w	r12[0xc],r9
80006c22:	76 29       	ld.w	r9,r11[0x8]
80006c24:	99 29       	st.w	r12[0x8],r9
80006c26:	76 19       	ld.w	r9,r11[0x4]
80006c28:	99 19       	st.w	r12[0x4],r9
80006c2a:	76 09       	ld.w	r9,r11[0x0]
80006c2c:	99 09       	st.w	r12[0x0],r9
80006c2e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006c32:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006c36:	e0 1a 00 03 	andl	r10,0x3
80006c3a:	f4 0a 11 04 	rsub	r10,r10,4
80006c3e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006c42:	17 a9       	ld.ub	r9,r11[0x2]
80006c44:	b0 a9       	st.b	r8[0x2],r9
80006c46:	17 99       	ld.ub	r9,r11[0x1]
80006c48:	b0 99       	st.b	r8[0x1],r9
80006c4a:	17 89       	ld.ub	r9,r11[0x0]
80006c4c:	b0 89       	st.b	r8[0x0],r9
80006c4e:	5e fc       	retal	r12
80006c50:	f4 0a 11 09 	rsub	r10,r10,9
80006c54:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006c58:	17 f9       	ld.ub	r9,r11[0x7]
80006c5a:	b8 f9       	st.b	r12[0x7],r9
80006c5c:	17 e9       	ld.ub	r9,r11[0x6]
80006c5e:	b8 e9       	st.b	r12[0x6],r9
80006c60:	17 d9       	ld.ub	r9,r11[0x5]
80006c62:	b8 d9       	st.b	r12[0x5],r9
80006c64:	17 c9       	ld.ub	r9,r11[0x4]
80006c66:	b8 c9       	st.b	r12[0x4],r9
80006c68:	17 b9       	ld.ub	r9,r11[0x3]
80006c6a:	b8 b9       	st.b	r12[0x3],r9
80006c6c:	17 a9       	ld.ub	r9,r11[0x2]
80006c6e:	b8 a9       	st.b	r12[0x2],r9
80006c70:	17 99       	ld.ub	r9,r11[0x1]
80006c72:	b8 99       	st.b	r12[0x1],r9
80006c74:	17 89       	ld.ub	r9,r11[0x0]
80006c76:	b8 89       	st.b	r12[0x0],r9
80006c78:	5e fc       	retal	r12
80006c7a:	eb cd 40 c0 	pushm	r6-r7,lr
80006c7e:	18 99       	mov	r9,r12
80006c80:	22 0a       	sub	r10,32
80006c82:	b7 07       	ld.d	r6,r11++
80006c84:	b3 26       	st.d	r9++,r6
80006c86:	b7 07       	ld.d	r6,r11++
80006c88:	b3 26       	st.d	r9++,r6
80006c8a:	b7 07       	ld.d	r6,r11++
80006c8c:	b3 26       	st.d	r9++,r6
80006c8e:	b7 07       	ld.d	r6,r11++
80006c90:	b3 26       	st.d	r9++,r6
80006c92:	22 0a       	sub	r10,32
80006c94:	cf 74       	brge	80006c82 <memcpy+0x92>
80006c96:	2f 0a       	sub	r10,-16
80006c98:	c0 65       	brlt	80006ca4 <memcpy+0xb4>
80006c9a:	b7 07       	ld.d	r6,r11++
80006c9c:	b3 26       	st.d	r9++,r6
80006c9e:	b7 07       	ld.d	r6,r11++
80006ca0:	b3 26       	st.d	r9++,r6
80006ca2:	21 0a       	sub	r10,16
80006ca4:	5c 3a       	neg	r10
80006ca6:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006caa:	d7 03       	nop
80006cac:	d7 03       	nop
80006cae:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006cb2:	f3 66 00 0e 	st.b	r9[14],r6
80006cb6:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006cba:	f3 66 00 0d 	st.b	r9[13],r6
80006cbe:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006cc2:	f3 66 00 0c 	st.b	r9[12],r6
80006cc6:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006cca:	f3 66 00 0b 	st.b	r9[11],r6
80006cce:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006cd2:	f3 66 00 0a 	st.b	r9[10],r6
80006cd6:	f7 36 00 09 	ld.ub	r6,r11[9]
80006cda:	f3 66 00 09 	st.b	r9[9],r6
80006cde:	f7 36 00 08 	ld.ub	r6,r11[8]
80006ce2:	f3 66 00 08 	st.b	r9[8],r6
80006ce6:	f7 36 00 07 	ld.ub	r6,r11[7]
80006cea:	f3 66 00 07 	st.b	r9[7],r6
80006cee:	f7 36 00 06 	ld.ub	r6,r11[6]
80006cf2:	f3 66 00 06 	st.b	r9[6],r6
80006cf6:	f7 36 00 05 	ld.ub	r6,r11[5]
80006cfa:	f3 66 00 05 	st.b	r9[5],r6
80006cfe:	f7 36 00 04 	ld.ub	r6,r11[4]
80006d02:	f3 66 00 04 	st.b	r9[4],r6
80006d06:	f7 36 00 03 	ld.ub	r6,r11[3]
80006d0a:	f3 66 00 03 	st.b	r9[3],r6
80006d0e:	f7 36 00 02 	ld.ub	r6,r11[2]
80006d12:	f3 66 00 02 	st.b	r9[2],r6
80006d16:	f7 36 00 01 	ld.ub	r6,r11[1]
80006d1a:	f3 66 00 01 	st.b	r9[1],r6
80006d1e:	f7 36 00 00 	ld.ub	r6,r11[0]
80006d22:	f3 66 00 00 	st.b	r9[0],r6
80006d26:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006d2a:	20 1a       	sub	r10,1
80006d2c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006d30:	f8 0a 0b 09 	st.b	r12[r10],r9
80006d34:	cf b1       	brne	80006d2a <memcpy+0x13a>
80006d36:	5e fc       	retal	r12

80006d38 <memset>:
80006d38:	18 98       	mov	r8,r12
80006d3a:	c0 38       	rjmp	80006d40 <memset+0x8>
80006d3c:	10 cb       	st.b	r8++,r11
80006d3e:	20 1a       	sub	r10,1
80006d40:	58 0a       	cp.w	r10,0
80006d42:	cf d1       	brne	80006d3c <memset+0x4>
80006d44:	5e fc       	retal	r12
80006d46:	d7 03       	nop

80006d48 <_realloc_r>:
80006d48:	d4 31       	pushm	r0-r7,lr
80006d4a:	20 1d       	sub	sp,4
80006d4c:	16 94       	mov	r4,r11
80006d4e:	18 92       	mov	r2,r12
80006d50:	14 9b       	mov	r11,r10
80006d52:	58 04       	cp.w	r4,0
80006d54:	c0 51       	brne	80006d5e <_realloc_r+0x16>
80006d56:	fe b0 fd 31 	rcall	800067b8 <_malloc_r>
80006d5a:	18 95       	mov	r5,r12
80006d5c:	c5 39       	rjmp	80007002 <_realloc_r+0x2ba>
80006d5e:	50 0a       	stdsp	sp[0x0],r10
80006d60:	fe b0 f2 98 	rcall	80005290 <__malloc_lock>
80006d64:	40 0b       	lddsp	r11,sp[0x0]
80006d66:	f6 c8 ff f5 	sub	r8,r11,-11
80006d6a:	e8 c1 00 08 	sub	r1,r4,8
80006d6e:	10 96       	mov	r6,r8
80006d70:	62 1c       	ld.w	r12,r1[0x4]
80006d72:	e0 16 ff f8 	andl	r6,0xfff8
80006d76:	59 68       	cp.w	r8,22
80006d78:	f9 b6 08 10 	movls	r6,16
80006d7c:	16 36       	cp.w	r6,r11
80006d7e:	5f 38       	srlo	r8
80006d80:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006d84:	c0 50       	breq	80006d8e <_realloc_r+0x46>
80006d86:	30 c8       	mov	r8,12
80006d88:	30 05       	mov	r5,0
80006d8a:	85 38       	st.w	r2[0xc],r8
80006d8c:	c3 b9       	rjmp	80007002 <_realloc_r+0x2ba>
80006d8e:	18 90       	mov	r0,r12
80006d90:	e0 10 ff fc 	andl	r0,0xfffc
80006d94:	0c 30       	cp.w	r0,r6
80006d96:	e0 84 01 0b 	brge	80006fac <_realloc_r+0x264>
80006d9a:	e0 68 05 30 	mov	r8,1328
80006d9e:	e2 00 00 09 	add	r9,r1,r0
80006da2:	70 25       	ld.w	r5,r8[0x8]
80006da4:	0a 39       	cp.w	r9,r5
80006da6:	c0 90       	breq	80006db8 <_realloc_r+0x70>
80006da8:	72 1a       	ld.w	r10,r9[0x4]
80006daa:	a1 ca       	cbr	r10,0x0
80006dac:	f2 0a 00 0a 	add	r10,r9,r10
80006db0:	74 1a       	ld.w	r10,r10[0x4]
80006db2:	ed ba 00 00 	bld	r10,0x0
80006db6:	c2 20       	breq	80006dfa <_realloc_r+0xb2>
80006db8:	72 1a       	ld.w	r10,r9[0x4]
80006dba:	e0 1a ff fc 	andl	r10,0xfffc
80006dbe:	f4 00 00 03 	add	r3,r10,r0
80006dc2:	0a 39       	cp.w	r9,r5
80006dc4:	c1 31       	brne	80006dea <_realloc_r+0xa2>
80006dc6:	ec c7 ff f0 	sub	r7,r6,-16
80006dca:	0e 33       	cp.w	r3,r7
80006dcc:	c1 95       	brlt	80006dfe <_realloc_r+0xb6>
80006dce:	e2 06 00 09 	add	r9,r1,r6
80006dd2:	0c 13       	sub	r3,r6
80006dd4:	a1 a3       	sbr	r3,0x0
80006dd6:	93 13       	st.w	r9[0x4],r3
80006dd8:	91 29       	st.w	r8[0x8],r9
80006dda:	04 9c       	mov	r12,r2
80006ddc:	62 18       	ld.w	r8,r1[0x4]
80006dde:	08 95       	mov	r5,r4
80006de0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006de4:	10 46       	or	r6,r8
80006de6:	83 16       	st.w	r1[0x4],r6
80006de8:	c0 b9       	rjmp	80006ffe <_realloc_r+0x2b6>
80006dea:	0c 33       	cp.w	r3,r6
80006dec:	c0 95       	brlt	80006dfe <_realloc_r+0xb6>
80006dee:	72 28       	ld.w	r8,r9[0x8]
80006df0:	02 97       	mov	r7,r1
80006df2:	72 39       	ld.w	r9,r9[0xc]
80006df4:	93 28       	st.w	r9[0x8],r8
80006df6:	91 39       	st.w	r8[0xc],r9
80006df8:	cd c8       	rjmp	80006fb0 <_realloc_r+0x268>
80006dfa:	30 0a       	mov	r10,0
80006dfc:	14 99       	mov	r9,r10
80006dfe:	ed bc 00 00 	bld	r12,0x0
80006e02:	e0 80 00 95 	breq	80006f2c <_realloc_r+0x1e4>
80006e06:	62 07       	ld.w	r7,r1[0x0]
80006e08:	e2 07 01 07 	sub	r7,r1,r7
80006e0c:	6e 1c       	ld.w	r12,r7[0x4]
80006e0e:	e0 1c ff fc 	andl	r12,0xfffc
80006e12:	58 09       	cp.w	r9,0
80006e14:	c5 60       	breq	80006ec0 <_realloc_r+0x178>
80006e16:	f8 00 00 03 	add	r3,r12,r0
80006e1a:	0a 39       	cp.w	r9,r5
80006e1c:	c4 81       	brne	80006eac <_realloc_r+0x164>
80006e1e:	14 03       	add	r3,r10
80006e20:	ec c9 ff f0 	sub	r9,r6,-16
80006e24:	12 33       	cp.w	r3,r9
80006e26:	c4 d5       	brlt	80006ec0 <_realloc_r+0x178>
80006e28:	6e 3a       	ld.w	r10,r7[0xc]
80006e2a:	6e 29       	ld.w	r9,r7[0x8]
80006e2c:	95 29       	st.w	r10[0x8],r9
80006e2e:	93 3a       	st.w	r9[0xc],r10
80006e30:	ee c5 ff f8 	sub	r5,r7,-8
80006e34:	e0 ca 00 04 	sub	r10,r0,4
80006e38:	e0 4a 00 24 	cp.w	r10,36
80006e3c:	e0 8b 00 25 	brhi	80006e86 <_realloc_r+0x13e>
80006e40:	0a 99       	mov	r9,r5
80006e42:	59 3a       	cp.w	r10,19
80006e44:	e0 88 00 1a 	brls	80006e78 <_realloc_r+0x130>
80006e48:	09 09       	ld.w	r9,r4++
80006e4a:	8b 09       	st.w	r5[0x0],r9
80006e4c:	09 09       	ld.w	r9,r4++
80006e4e:	8f 39       	st.w	r7[0xc],r9
80006e50:	ee c9 ff f0 	sub	r9,r7,-16
80006e54:	59 ba       	cp.w	r10,27
80006e56:	e0 88 00 11 	brls	80006e78 <_realloc_r+0x130>
80006e5a:	09 0b       	ld.w	r11,r4++
80006e5c:	93 0b       	st.w	r9[0x0],r11
80006e5e:	09 09       	ld.w	r9,r4++
80006e60:	8f 59       	st.w	r7[0x14],r9
80006e62:	ee c9 ff e8 	sub	r9,r7,-24
80006e66:	e0 4a 00 24 	cp.w	r10,36
80006e6a:	c0 71       	brne	80006e78 <_realloc_r+0x130>
80006e6c:	09 0a       	ld.w	r10,r4++
80006e6e:	93 0a       	st.w	r9[0x0],r10
80006e70:	ee c9 ff e0 	sub	r9,r7,-32
80006e74:	09 0a       	ld.w	r10,r4++
80006e76:	8f 7a       	st.w	r7[0x1c],r10
80006e78:	09 0a       	ld.w	r10,r4++
80006e7a:	12 aa       	st.w	r9++,r10
80006e7c:	68 0a       	ld.w	r10,r4[0x0]
80006e7e:	93 0a       	st.w	r9[0x0],r10
80006e80:	68 1a       	ld.w	r10,r4[0x4]
80006e82:	93 1a       	st.w	r9[0x4],r10
80006e84:	c0 78       	rjmp	80006e92 <_realloc_r+0x14a>
80006e86:	50 08       	stdsp	sp[0x0],r8
80006e88:	08 9b       	mov	r11,r4
80006e8a:	0a 9c       	mov	r12,r5
80006e8c:	e0 a0 1d 9b 	rcall	8000a9c2 <memmove>
80006e90:	40 08       	lddsp	r8,sp[0x0]
80006e92:	ee 06 00 09 	add	r9,r7,r6
80006e96:	0c 13       	sub	r3,r6
80006e98:	a1 a3       	sbr	r3,0x0
80006e9a:	93 13       	st.w	r9[0x4],r3
80006e9c:	91 29       	st.w	r8[0x8],r9
80006e9e:	04 9c       	mov	r12,r2
80006ea0:	6e 18       	ld.w	r8,r7[0x4]
80006ea2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006ea6:	10 46       	or	r6,r8
80006ea8:	8f 16       	st.w	r7[0x4],r6
80006eaa:	ca a8       	rjmp	80006ffe <_realloc_r+0x2b6>
80006eac:	14 03       	add	r3,r10
80006eae:	0c 33       	cp.w	r3,r6
80006eb0:	c0 85       	brlt	80006ec0 <_realloc_r+0x178>
80006eb2:	72 28       	ld.w	r8,r9[0x8]
80006eb4:	72 39       	ld.w	r9,r9[0xc]
80006eb6:	93 28       	st.w	r9[0x8],r8
80006eb8:	91 39       	st.w	r8[0xc],r9
80006eba:	6e 28       	ld.w	r8,r7[0x8]
80006ebc:	6e 39       	ld.w	r9,r7[0xc]
80006ebe:	c0 78       	rjmp	80006ecc <_realloc_r+0x184>
80006ec0:	f8 00 00 03 	add	r3,r12,r0
80006ec4:	0c 33       	cp.w	r3,r6
80006ec6:	c3 35       	brlt	80006f2c <_realloc_r+0x1e4>
80006ec8:	6e 39       	ld.w	r9,r7[0xc]
80006eca:	6e 28       	ld.w	r8,r7[0x8]
80006ecc:	93 28       	st.w	r9[0x8],r8
80006ece:	91 39       	st.w	r8[0xc],r9
80006ed0:	e0 ca 00 04 	sub	r10,r0,4
80006ed4:	ee cc ff f8 	sub	r12,r7,-8
80006ed8:	e0 4a 00 24 	cp.w	r10,36
80006edc:	e0 8b 00 24 	brhi	80006f24 <_realloc_r+0x1dc>
80006ee0:	59 3a       	cp.w	r10,19
80006ee2:	e0 88 00 1a 	brls	80006f16 <_realloc_r+0x1ce>
80006ee6:	09 08       	ld.w	r8,r4++
80006ee8:	99 08       	st.w	r12[0x0],r8
80006eea:	09 08       	ld.w	r8,r4++
80006eec:	8f 38       	st.w	r7[0xc],r8
80006eee:	ee cc ff f0 	sub	r12,r7,-16
80006ef2:	59 ba       	cp.w	r10,27
80006ef4:	e0 88 00 11 	brls	80006f16 <_realloc_r+0x1ce>
80006ef8:	09 08       	ld.w	r8,r4++
80006efa:	99 08       	st.w	r12[0x0],r8
80006efc:	09 08       	ld.w	r8,r4++
80006efe:	8f 58       	st.w	r7[0x14],r8
80006f00:	ee cc ff e8 	sub	r12,r7,-24
80006f04:	e0 4a 00 24 	cp.w	r10,36
80006f08:	c0 71       	brne	80006f16 <_realloc_r+0x1ce>
80006f0a:	09 08       	ld.w	r8,r4++
80006f0c:	99 08       	st.w	r12[0x0],r8
80006f0e:	ee cc ff e0 	sub	r12,r7,-32
80006f12:	09 08       	ld.w	r8,r4++
80006f14:	8f 78       	st.w	r7[0x1c],r8
80006f16:	09 08       	ld.w	r8,r4++
80006f18:	18 a8       	st.w	r12++,r8
80006f1a:	68 08       	ld.w	r8,r4[0x0]
80006f1c:	99 08       	st.w	r12[0x0],r8
80006f1e:	68 18       	ld.w	r8,r4[0x4]
80006f20:	99 18       	st.w	r12[0x4],r8
80006f22:	c4 78       	rjmp	80006fb0 <_realloc_r+0x268>
80006f24:	08 9b       	mov	r11,r4
80006f26:	e0 a0 1d 4e 	rcall	8000a9c2 <memmove>
80006f2a:	c4 38       	rjmp	80006fb0 <_realloc_r+0x268>
80006f2c:	04 9c       	mov	r12,r2
80006f2e:	fe b0 fc 45 	rcall	800067b8 <_malloc_r>
80006f32:	18 95       	mov	r5,r12
80006f34:	c3 a0       	breq	80006fa8 <_realloc_r+0x260>
80006f36:	62 18       	ld.w	r8,r1[0x4]
80006f38:	f8 c9 00 08 	sub	r9,r12,8
80006f3c:	a1 c8       	cbr	r8,0x0
80006f3e:	e2 08 00 08 	add	r8,r1,r8
80006f42:	10 39       	cp.w	r9,r8
80006f44:	c0 71       	brne	80006f52 <_realloc_r+0x20a>
80006f46:	72 13       	ld.w	r3,r9[0x4]
80006f48:	02 97       	mov	r7,r1
80006f4a:	e0 13 ff fc 	andl	r3,0xfffc
80006f4e:	00 03       	add	r3,r0
80006f50:	c3 08       	rjmp	80006fb0 <_realloc_r+0x268>
80006f52:	e0 ca 00 04 	sub	r10,r0,4
80006f56:	e0 4a 00 24 	cp.w	r10,36
80006f5a:	e0 8b 00 20 	brhi	80006f9a <_realloc_r+0x252>
80006f5e:	08 99       	mov	r9,r4
80006f60:	18 98       	mov	r8,r12
80006f62:	59 3a       	cp.w	r10,19
80006f64:	e0 88 00 14 	brls	80006f8c <_realloc_r+0x244>
80006f68:	13 0b       	ld.w	r11,r9++
80006f6a:	10 ab       	st.w	r8++,r11
80006f6c:	13 0b       	ld.w	r11,r9++
80006f6e:	10 ab       	st.w	r8++,r11
80006f70:	59 ba       	cp.w	r10,27
80006f72:	e0 88 00 0d 	brls	80006f8c <_realloc_r+0x244>
80006f76:	13 0b       	ld.w	r11,r9++
80006f78:	10 ab       	st.w	r8++,r11
80006f7a:	13 0b       	ld.w	r11,r9++
80006f7c:	10 ab       	st.w	r8++,r11
80006f7e:	e0 4a 00 24 	cp.w	r10,36
80006f82:	c0 51       	brne	80006f8c <_realloc_r+0x244>
80006f84:	13 0a       	ld.w	r10,r9++
80006f86:	10 aa       	st.w	r8++,r10
80006f88:	13 0a       	ld.w	r10,r9++
80006f8a:	10 aa       	st.w	r8++,r10
80006f8c:	13 0a       	ld.w	r10,r9++
80006f8e:	10 aa       	st.w	r8++,r10
80006f90:	72 0a       	ld.w	r10,r9[0x0]
80006f92:	91 0a       	st.w	r8[0x0],r10
80006f94:	72 19       	ld.w	r9,r9[0x4]
80006f96:	91 19       	st.w	r8[0x4],r9
80006f98:	c0 48       	rjmp	80006fa0 <_realloc_r+0x258>
80006f9a:	08 9b       	mov	r11,r4
80006f9c:	e0 a0 1d 13 	rcall	8000a9c2 <memmove>
80006fa0:	08 9b       	mov	r11,r4
80006fa2:	04 9c       	mov	r12,r2
80006fa4:	e0 a0 1a 6c 	rcall	8000a47c <_free_r>
80006fa8:	04 9c       	mov	r12,r2
80006faa:	c2 a8       	rjmp	80006ffe <_realloc_r+0x2b6>
80006fac:	00 93       	mov	r3,r0
80006fae:	02 97       	mov	r7,r1
80006fb0:	e6 06 01 09 	sub	r9,r3,r6
80006fb4:	6e 18       	ld.w	r8,r7[0x4]
80006fb6:	58 f9       	cp.w	r9,15
80006fb8:	e0 88 00 16 	brls	80006fe4 <_realloc_r+0x29c>
80006fbc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006fc0:	ed e8 10 08 	or	r8,r6,r8
80006fc4:	8f 18       	st.w	r7[0x4],r8
80006fc6:	12 98       	mov	r8,r9
80006fc8:	a1 a8       	sbr	r8,0x0
80006fca:	ee 06 00 0b 	add	r11,r7,r6
80006fce:	f6 09 00 09 	add	r9,r11,r9
80006fd2:	97 18       	st.w	r11[0x4],r8
80006fd4:	72 18       	ld.w	r8,r9[0x4]
80006fd6:	a1 a8       	sbr	r8,0x0
80006fd8:	2f 8b       	sub	r11,-8
80006fda:	93 18       	st.w	r9[0x4],r8
80006fdc:	04 9c       	mov	r12,r2
80006fde:	e0 a0 1a 4f 	rcall	8000a47c <_free_r>
80006fe2:	c0 b8       	rjmp	80006ff8 <_realloc_r+0x2b0>
80006fe4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006fe8:	e7 e8 10 08 	or	r8,r3,r8
80006fec:	8f 18       	st.w	r7[0x4],r8
80006fee:	ee 03 00 03 	add	r3,r7,r3
80006ff2:	66 18       	ld.w	r8,r3[0x4]
80006ff4:	a1 a8       	sbr	r8,0x0
80006ff6:	87 18       	st.w	r3[0x4],r8
80006ff8:	04 9c       	mov	r12,r2
80006ffa:	ee c5 ff f8 	sub	r5,r7,-8
80006ffe:	fe b0 f1 4f 	rcall	8000529c <__malloc_unlock>
80007002:	0a 9c       	mov	r12,r5
80007004:	2f fd       	sub	sp,-4
80007006:	d8 32       	popm	r0-r7,pc

80007008 <_sbrk_r>:
80007008:	d4 21       	pushm	r4-r7,lr
8000700a:	30 08       	mov	r8,0
8000700c:	18 97       	mov	r7,r12
8000700e:	e0 66 41 14 	mov	r6,16660
80007012:	16 9c       	mov	r12,r11
80007014:	8d 08       	st.w	r6[0x0],r8
80007016:	c9 1c       	rcall	80007138 <_sbrk>
80007018:	5b fc       	cp.w	r12,-1
8000701a:	c0 51       	brne	80007024 <_sbrk_r+0x1c>
8000701c:	6c 08       	ld.w	r8,r6[0x0]
8000701e:	58 08       	cp.w	r8,0
80007020:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007024:	d8 22       	popm	r4-r7,pc
80007026:	d7 03       	nop

80007028 <sprintf>:
80007028:	d4 01       	pushm	lr
8000702a:	21 7d       	sub	sp,92
8000702c:	e0 68 ff ff 	mov	r8,65535
80007030:	ea 18 7f ff 	orh	r8,0x7fff
80007034:	50 58       	stdsp	sp[0x14],r8
80007036:	50 28       	stdsp	sp[0x8],r8
80007038:	e0 68 02 08 	mov	r8,520
8000703c:	ba 68       	st.h	sp[0xc],r8
8000703e:	3f f8       	mov	r8,-1
80007040:	ba 78       	st.h	sp[0xe],r8
80007042:	e0 68 0a 30 	mov	r8,2608
80007046:	50 4c       	stdsp	sp[0x10],r12
80007048:	16 9a       	mov	r10,r11
8000704a:	50 0c       	stdsp	sp[0x0],r12
8000704c:	fa c9 ff a0 	sub	r9,sp,-96
80007050:	70 0c       	ld.w	r12,r8[0x0]
80007052:	1a 9b       	mov	r11,sp
80007054:	e0 a0 02 26 	rcall	800074a0 <_vfprintf_r>
80007058:	30 09       	mov	r9,0
8000705a:	40 08       	lddsp	r8,sp[0x0]
8000705c:	b0 89       	st.b	r8[0x0],r9
8000705e:	2e 9d       	sub	sp,-92
80007060:	d8 02       	popm	pc
80007062:	d7 03       	nop

80007064 <strlen>:
80007064:	30 09       	mov	r9,0
80007066:	18 98       	mov	r8,r12
80007068:	c0 28       	rjmp	8000706c <strlen+0x8>
8000706a:	2f f8       	sub	r8,-1
8000706c:	11 8a       	ld.ub	r10,r8[0x0]
8000706e:	f2 0a 18 00 	cp.b	r10,r9
80007072:	cf c1       	brne	8000706a <strlen+0x6>
80007074:	f0 0c 01 0c 	sub	r12,r8,r12
80007078:	5e fc       	retal	r12
8000707a:	d7 03       	nop

8000707c <strncpy>:
8000707c:	30 08       	mov	r8,0
8000707e:	10 3a       	cp.w	r10,r8
80007080:	5e 0c       	reteq	r12
80007082:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007086:	f8 08 0b 09 	st.b	r12[r8],r9
8000708a:	2f f8       	sub	r8,-1
8000708c:	58 09       	cp.w	r9,0
8000708e:	cf 81       	brne	8000707e <strncpy+0x2>
80007090:	10 3a       	cp.w	r10,r8
80007092:	5e 0c       	reteq	r12
80007094:	f8 08 0b 09 	st.b	r12[r8],r9
80007098:	2f f8       	sub	r8,-1
8000709a:	cf bb       	rjmp	80007090 <strncpy+0x14>

8000709c <_close>:
8000709c:	30 28       	mov	r8,2
8000709e:	d6 73       	breakpoint
800070a0:	3f fc       	mov	r12,-1
800070a2:	35 8b       	mov	r11,88
800070a4:	58 0c       	cp.w	r12,0
800070a6:	5e 4c       	retge	r12
800070a8:	e0 6a 41 14 	mov	r10,16660
800070ac:	95 0b       	st.w	r10[0x0],r11
800070ae:	5e fc       	retal	r12

800070b0 <_lseek>:
800070b0:	30 58       	mov	r8,5
800070b2:	d6 73       	breakpoint
800070b4:	3f fc       	mov	r12,-1
800070b6:	35 8b       	mov	r11,88
800070b8:	58 0c       	cp.w	r12,0
800070ba:	5e 4c       	retge	r12
800070bc:	e0 6a 41 14 	mov	r10,16660
800070c0:	95 0b       	st.w	r10[0x0],r11
800070c2:	5e fc       	retal	r12

800070c4 <isatty>:
800070c4:	30 b8       	mov	r8,11
800070c6:	d6 73       	breakpoint
800070c8:	3f fc       	mov	r12,-1
800070ca:	35 8b       	mov	r11,88
800070cc:	58 0c       	cp.w	r12,0
800070ce:	5e 4c       	retge	r12
800070d0:	e0 6a 41 14 	mov	r10,16660
800070d4:	95 0b       	st.w	r10[0x0],r11
800070d6:	5e fc       	retal	r12

800070d8 <_fstat_host>:
800070d8:	30 98       	mov	r8,9
800070da:	d6 73       	breakpoint
800070dc:	3f fc       	mov	r12,-1
800070de:	35 8b       	mov	r11,88
800070e0:	58 0c       	cp.w	r12,0
800070e2:	5e 4c       	retge	r12
800070e4:	e0 6a 41 14 	mov	r10,16660
800070e8:	95 0b       	st.w	r10[0x0],r11
800070ea:	5e fc       	retal	r12

800070ec <_fstat>:
800070ec:	d4 21       	pushm	r4-r7,lr
800070ee:	21 0d       	sub	sp,64
800070f0:	16 97       	mov	r7,r11
800070f2:	1a 9b       	mov	r11,sp
800070f4:	cf 2f       	rcall	800070d8 <_fstat_host>
800070f6:	c0 34       	brge	800070fc <_fstat+0x10>
800070f8:	3f fc       	mov	r12,-1
800070fa:	c1 c8       	rjmp	80007132 <_fstat+0x46>
800070fc:	40 08       	lddsp	r8,sp[0x0]
800070fe:	ae 08       	st.h	r7[0x0],r8
80007100:	40 18       	lddsp	r8,sp[0x4]
80007102:	ae 18       	st.h	r7[0x2],r8
80007104:	40 28       	lddsp	r8,sp[0x8]
80007106:	8f 18       	st.w	r7[0x4],r8
80007108:	40 38       	lddsp	r8,sp[0xc]
8000710a:	ae 48       	st.h	r7[0x8],r8
8000710c:	40 48       	lddsp	r8,sp[0x10]
8000710e:	ae 58       	st.h	r7[0xa],r8
80007110:	40 58       	lddsp	r8,sp[0x14]
80007112:	ae 68       	st.h	r7[0xc],r8
80007114:	40 68       	lddsp	r8,sp[0x18]
80007116:	ae 78       	st.h	r7[0xe],r8
80007118:	40 88       	lddsp	r8,sp[0x20]
8000711a:	8f 48       	st.w	r7[0x10],r8
8000711c:	40 a8       	lddsp	r8,sp[0x28]
8000711e:	8f b8       	st.w	r7[0x2c],r8
80007120:	40 c8       	lddsp	r8,sp[0x30]
80007122:	8f c8       	st.w	r7[0x30],r8
80007124:	40 d8       	lddsp	r8,sp[0x34]
80007126:	8f 58       	st.w	r7[0x14],r8
80007128:	40 e8       	lddsp	r8,sp[0x38]
8000712a:	30 0c       	mov	r12,0
8000712c:	8f 78       	st.w	r7[0x1c],r8
8000712e:	40 f8       	lddsp	r8,sp[0x3c]
80007130:	8f 98       	st.w	r7[0x24],r8
80007132:	2f 0d       	sub	sp,-64
80007134:	d8 22       	popm	r4-r7,pc
80007136:	d7 03       	nop

80007138 <_sbrk>:
80007138:	d4 01       	pushm	lr
8000713a:	e0 68 0d 90 	mov	r8,3472
8000713e:	70 09       	ld.w	r9,r8[0x0]
80007140:	58 09       	cp.w	r9,0
80007142:	c0 41       	brne	8000714a <_sbrk+0x12>
80007144:	e0 69 41 18 	mov	r9,16664
80007148:	91 09       	st.w	r8[0x0],r9
8000714a:	e0 69 0d 90 	mov	r9,3472
8000714e:	e0 7a 70 00 	mov	r10,94208
80007152:	72 08       	ld.w	r8,r9[0x0]
80007154:	f0 0c 00 0c 	add	r12,r8,r12
80007158:	14 3c       	cp.w	r12,r10
8000715a:	e0 8b 00 04 	brhi	80007162 <_sbrk+0x2a>
8000715e:	93 0c       	st.w	r9[0x0],r12
80007160:	c0 68       	rjmp	8000716c <_sbrk+0x34>
80007162:	e0 a0 18 15 	rcall	8000a18c <__errno>
80007166:	30 c8       	mov	r8,12
80007168:	99 08       	st.w	r12[0x0],r8
8000716a:	3f f8       	mov	r8,-1
8000716c:	10 9c       	mov	r12,r8
8000716e:	d8 02       	popm	pc

80007170 <get_arg>:
80007170:	d4 31       	pushm	r0-r7,lr
80007172:	20 8d       	sub	sp,32
80007174:	fa c4 ff bc 	sub	r4,sp,-68
80007178:	50 4b       	stdsp	sp[0x10],r11
8000717a:	68 2e       	ld.w	lr,r4[0x8]
8000717c:	50 58       	stdsp	sp[0x14],r8
8000717e:	12 96       	mov	r6,r9
80007180:	7c 0b       	ld.w	r11,lr[0x0]
80007182:	70 05       	ld.w	r5,r8[0x0]
80007184:	50 6e       	stdsp	sp[0x18],lr
80007186:	58 0b       	cp.w	r11,0
80007188:	f4 0b 17 00 	moveq	r11,r10
8000718c:	68 03       	ld.w	r3,r4[0x0]
8000718e:	68 11       	ld.w	r1,r4[0x4]
80007190:	40 49       	lddsp	r9,sp[0x10]
80007192:	30 08       	mov	r8,0
80007194:	c2 89       	rjmp	800073e4 <get_arg+0x274>
80007196:	2f fb       	sub	r11,-1
80007198:	32 5c       	mov	r12,37
8000719a:	17 8a       	ld.ub	r10,r11[0x0]
8000719c:	f8 0a 18 00 	cp.b	r10,r12
800071a0:	5f 1e       	srne	lr
800071a2:	f0 0a 18 00 	cp.b	r10,r8
800071a6:	5f 1c       	srne	r12
800071a8:	fd ec 00 0c 	and	r12,lr,r12
800071ac:	f0 0c 18 00 	cp.b	r12,r8
800071b0:	cf 31       	brne	80007196 <get_arg+0x26>
800071b2:	58 0a       	cp.w	r10,0
800071b4:	e0 80 01 25 	breq	800073fe <get_arg+0x28e>
800071b8:	30 0c       	mov	r12,0
800071ba:	3f fa       	mov	r10,-1
800071bc:	18 90       	mov	r0,r12
800071be:	50 3a       	stdsp	sp[0xc],r10
800071c0:	18 94       	mov	r4,r12
800071c2:	18 92       	mov	r2,r12
800071c4:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800071c8:	16 97       	mov	r7,r11
800071ca:	50 7c       	stdsp	sp[0x1c],r12
800071cc:	fe cc 9f 2c 	sub	r12,pc,-24788
800071d0:	0f 3a       	ld.ub	r10,r7++
800071d2:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800071d6:	40 7c       	lddsp	r12,sp[0x1c]
800071d8:	1c 0c       	add	r12,lr
800071da:	fe ce a0 02 	sub	lr,pc,-24574
800071de:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800071e2:	20 1e       	sub	lr,1
800071e4:	50 0e       	stdsp	sp[0x0],lr
800071e6:	fe ce a0 7a 	sub	lr,pc,-24454
800071ea:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800071ee:	50 7c       	stdsp	sp[0x1c],r12
800071f0:	40 0c       	lddsp	r12,sp[0x0]
800071f2:	58 7c       	cp.w	r12,7
800071f4:	e0 8b 00 f1 	brhi	800073d6 <get_arg+0x266>
800071f8:	fe ce a2 2c 	sub	lr,pc,-24020
800071fc:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007200:	36 8b       	mov	r11,104
80007202:	f6 0a 18 00 	cp.b	r10,r11
80007206:	e0 80 00 e8 	breq	800073d6 <get_arg+0x266>
8000720a:	37 1b       	mov	r11,113
8000720c:	f6 0a 18 00 	cp.b	r10,r11
80007210:	c0 70       	breq	8000721e <get_arg+0xae>
80007212:	34 cb       	mov	r11,76
80007214:	f6 0a 18 00 	cp.b	r10,r11
80007218:	c0 51       	brne	80007222 <get_arg+0xb2>
8000721a:	a3 b4       	sbr	r4,0x3
8000721c:	cd d8       	rjmp	800073d6 <get_arg+0x266>
8000721e:	a5 b4       	sbr	r4,0x5
80007220:	cd b8       	rjmp	800073d6 <get_arg+0x266>
80007222:	08 9a       	mov	r10,r4
80007224:	0e 9b       	mov	r11,r7
80007226:	a5 aa       	sbr	r10,0x4
80007228:	17 3c       	ld.ub	r12,r11++
8000722a:	a5 b4       	sbr	r4,0x5
8000722c:	36 ce       	mov	lr,108
8000722e:	fc 0c 18 00 	cp.b	r12,lr
80007232:	e0 80 00 d3 	breq	800073d8 <get_arg+0x268>
80007236:	14 94       	mov	r4,r10
80007238:	cc f8       	rjmp	800073d6 <get_arg+0x266>
8000723a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000723e:	36 7c       	mov	r12,103
80007240:	f8 0a 18 00 	cp.b	r10,r12
80007244:	e0 8b 00 27 	brhi	80007292 <get_arg+0x122>
80007248:	36 5b       	mov	r11,101
8000724a:	f6 0a 18 00 	cp.b	r10,r11
8000724e:	c4 82       	brcc	800072de <get_arg+0x16e>
80007250:	34 fb       	mov	r11,79
80007252:	f6 0a 18 00 	cp.b	r10,r11
80007256:	c4 80       	breq	800072e6 <get_arg+0x176>
80007258:	e0 8b 00 0c 	brhi	80007270 <get_arg+0x100>
8000725c:	34 5b       	mov	r11,69
8000725e:	f6 0a 18 00 	cp.b	r10,r11
80007262:	c3 e0       	breq	800072de <get_arg+0x16e>
80007264:	34 7b       	mov	r11,71
80007266:	f6 0a 18 00 	cp.b	r10,r11
8000726a:	c3 a0       	breq	800072de <get_arg+0x16e>
8000726c:	34 4b       	mov	r11,68
8000726e:	c0 88       	rjmp	8000727e <get_arg+0x10e>
80007270:	35 8b       	mov	r11,88
80007272:	f6 0a 18 00 	cp.b	r10,r11
80007276:	c2 c0       	breq	800072ce <get_arg+0x15e>
80007278:	e0 8b 00 07 	brhi	80007286 <get_arg+0x116>
8000727c:	35 5b       	mov	r11,85
8000727e:	f6 0a 18 00 	cp.b	r10,r11
80007282:	c3 51       	brne	800072ec <get_arg+0x17c>
80007284:	c3 18       	rjmp	800072e6 <get_arg+0x176>
80007286:	36 3b       	mov	r11,99
80007288:	f6 0a 18 00 	cp.b	r10,r11
8000728c:	c2 f0       	breq	800072ea <get_arg+0x17a>
8000728e:	36 4b       	mov	r11,100
80007290:	c0 e8       	rjmp	800072ac <get_arg+0x13c>
80007292:	37 0b       	mov	r11,112
80007294:	f6 0a 18 00 	cp.b	r10,r11
80007298:	c2 50       	breq	800072e2 <get_arg+0x172>
8000729a:	e0 8b 00 0d 	brhi	800072b4 <get_arg+0x144>
8000729e:	36 eb       	mov	r11,110
800072a0:	f6 0a 18 00 	cp.b	r10,r11
800072a4:	c1 f0       	breq	800072e2 <get_arg+0x172>
800072a6:	e0 8b 00 14 	brhi	800072ce <get_arg+0x15e>
800072aa:	36 9b       	mov	r11,105
800072ac:	f6 0a 18 00 	cp.b	r10,r11
800072b0:	c1 e1       	brne	800072ec <get_arg+0x17c>
800072b2:	c0 e8       	rjmp	800072ce <get_arg+0x15e>
800072b4:	37 5b       	mov	r11,117
800072b6:	f6 0a 18 00 	cp.b	r10,r11
800072ba:	c0 a0       	breq	800072ce <get_arg+0x15e>
800072bc:	37 8b       	mov	r11,120
800072be:	f6 0a 18 00 	cp.b	r10,r11
800072c2:	c0 60       	breq	800072ce <get_arg+0x15e>
800072c4:	37 3b       	mov	r11,115
800072c6:	f6 0a 18 00 	cp.b	r10,r11
800072ca:	c1 11       	brne	800072ec <get_arg+0x17c>
800072cc:	c0 b8       	rjmp	800072e2 <get_arg+0x172>
800072ce:	ed b4 00 04 	bld	r4,0x4
800072d2:	c0 a0       	breq	800072e6 <get_arg+0x176>
800072d4:	ed b4 00 05 	bld	r4,0x5
800072d8:	c0 91       	brne	800072ea <get_arg+0x17a>
800072da:	30 20       	mov	r0,2
800072dc:	c0 88       	rjmp	800072ec <get_arg+0x17c>
800072de:	30 40       	mov	r0,4
800072e0:	c0 68       	rjmp	800072ec <get_arg+0x17c>
800072e2:	30 30       	mov	r0,3
800072e4:	c0 48       	rjmp	800072ec <get_arg+0x17c>
800072e6:	30 10       	mov	r0,1
800072e8:	c0 28       	rjmp	800072ec <get_arg+0x17c>
800072ea:	30 00       	mov	r0,0
800072ec:	40 3b       	lddsp	r11,sp[0xc]
800072ee:	5b fb       	cp.w	r11,-1
800072f0:	c0 40       	breq	800072f8 <get_arg+0x188>
800072f2:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800072f6:	c7 08       	rjmp	800073d6 <get_arg+0x266>
800072f8:	58 60       	cp.w	r0,6
800072fa:	e0 8b 00 6e 	brhi	800073d6 <get_arg+0x266>
800072fe:	6c 0a       	ld.w	r10,r6[0x0]
80007300:	ea cc ff ff 	sub	r12,r5,-1
80007304:	fe ce a3 18 	sub	lr,pc,-23784
80007308:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000730c:	f4 cb ff f8 	sub	r11,r10,-8
80007310:	8d 0b       	st.w	r6[0x0],r11
80007312:	f4 ea 00 00 	ld.d	r10,r10[0]
80007316:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000731a:	c0 f8       	rjmp	80007338 <get_arg+0x1c8>
8000731c:	f4 cb ff fc 	sub	r11,r10,-4
80007320:	8d 0b       	st.w	r6[0x0],r11
80007322:	74 0a       	ld.w	r10,r10[0x0]
80007324:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007328:	c0 88       	rjmp	80007338 <get_arg+0x1c8>
8000732a:	f4 cb ff f8 	sub	r11,r10,-8
8000732e:	8d 0b       	st.w	r6[0x0],r11
80007330:	f4 ea 00 00 	ld.d	r10,r10[0]
80007334:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007338:	0e 9b       	mov	r11,r7
8000733a:	18 95       	mov	r5,r12
8000733c:	c4 e8       	rjmp	800073d8 <get_arg+0x268>
8000733e:	62 0a       	ld.w	r10,r1[0x0]
80007340:	5b fa       	cp.w	r10,-1
80007342:	c0 b1       	brne	80007358 <get_arg+0x1e8>
80007344:	50 19       	stdsp	sp[0x4],r9
80007346:	50 28       	stdsp	sp[0x8],r8
80007348:	e0 6a 00 80 	mov	r10,128
8000734c:	30 0b       	mov	r11,0
8000734e:	02 9c       	mov	r12,r1
80007350:	fe b0 fc f4 	rcall	80006d38 <memset>
80007354:	40 28       	lddsp	r8,sp[0x8]
80007356:	40 19       	lddsp	r9,sp[0x4]
80007358:	e4 cc 00 01 	sub	r12,r2,1
8000735c:	0e 9b       	mov	r11,r7
8000735e:	50 3c       	stdsp	sp[0xc],r12
80007360:	f2 0c 0c 49 	max	r9,r9,r12
80007364:	c3 a8       	rjmp	800073d8 <get_arg+0x268>
80007366:	62 0a       	ld.w	r10,r1[0x0]
80007368:	5b fa       	cp.w	r10,-1
8000736a:	c0 b1       	brne	80007380 <get_arg+0x210>
8000736c:	50 19       	stdsp	sp[0x4],r9
8000736e:	50 28       	stdsp	sp[0x8],r8
80007370:	e0 6a 00 80 	mov	r10,128
80007374:	30 0b       	mov	r11,0
80007376:	02 9c       	mov	r12,r1
80007378:	fe b0 fc e0 	rcall	80006d38 <memset>
8000737c:	40 28       	lddsp	r8,sp[0x8]
8000737e:	40 19       	lddsp	r9,sp[0x4]
80007380:	20 12       	sub	r2,1
80007382:	30 0a       	mov	r10,0
80007384:	0e 9b       	mov	r11,r7
80007386:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000738a:	f2 02 0c 49 	max	r9,r9,r2
8000738e:	c2 58       	rjmp	800073d8 <get_arg+0x268>
80007390:	16 97       	mov	r7,r11
80007392:	6c 0a       	ld.w	r10,r6[0x0]
80007394:	f4 cb ff fc 	sub	r11,r10,-4
80007398:	8d 0b       	st.w	r6[0x0],r11
8000739a:	74 0a       	ld.w	r10,r10[0x0]
8000739c:	0e 9b       	mov	r11,r7
8000739e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800073a2:	2f f5       	sub	r5,-1
800073a4:	c1 a8       	rjmp	800073d8 <get_arg+0x268>
800073a6:	f4 c2 00 30 	sub	r2,r10,48
800073aa:	c0 68       	rjmp	800073b6 <get_arg+0x246>
800073ac:	e4 02 00 22 	add	r2,r2,r2<<0x2
800073b0:	2f f7       	sub	r7,-1
800073b2:	f4 02 00 12 	add	r2,r10,r2<<0x1
800073b6:	0f 8a       	ld.ub	r10,r7[0x0]
800073b8:	58 0a       	cp.w	r10,0
800073ba:	c0 e0       	breq	800073d6 <get_arg+0x266>
800073bc:	23 0a       	sub	r10,48
800073be:	58 9a       	cp.w	r10,9
800073c0:	fe 98 ff f6 	brls	800073ac <get_arg+0x23c>
800073c4:	c0 98       	rjmp	800073d6 <get_arg+0x266>
800073c6:	2f f7       	sub	r7,-1
800073c8:	0f 8a       	ld.ub	r10,r7[0x0]
800073ca:	58 0a       	cp.w	r10,0
800073cc:	c0 50       	breq	800073d6 <get_arg+0x266>
800073ce:	23 0a       	sub	r10,48
800073d0:	58 9a       	cp.w	r10,9
800073d2:	fe 98 ff fa 	brls	800073c6 <get_arg+0x256>
800073d6:	0e 9b       	mov	r11,r7
800073d8:	40 7c       	lddsp	r12,sp[0x1c]
800073da:	30 ba       	mov	r10,11
800073dc:	f4 0c 18 00 	cp.b	r12,r10
800073e0:	fe 91 fe f2 	brne	800071c4 <get_arg+0x54>
800073e4:	40 42       	lddsp	r2,sp[0x10]
800073e6:	17 8c       	ld.ub	r12,r11[0x0]
800073e8:	0a 32       	cp.w	r2,r5
800073ea:	5f 4a       	srge	r10
800073ec:	f0 0c 18 00 	cp.b	r12,r8
800073f0:	5f 1c       	srne	r12
800073f2:	f9 ea 00 0a 	and	r10,r12,r10
800073f6:	f0 0a 18 00 	cp.b	r10,r8
800073fa:	fe 91 fe cf 	brne	80007198 <get_arg+0x28>
800073fe:	30 08       	mov	r8,0
80007400:	40 4e       	lddsp	lr,sp[0x10]
80007402:	17 8a       	ld.ub	r10,r11[0x0]
80007404:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007408:	f0 0a 18 00 	cp.b	r10,r8
8000740c:	fc 09 17 10 	movne	r9,lr
80007410:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007414:	06 9e       	mov	lr,r3
80007416:	c2 a8       	rjmp	8000746a <get_arg+0x2fa>
80007418:	62 0a       	ld.w	r10,r1[0x0]
8000741a:	58 3a       	cp.w	r10,3
8000741c:	c1 e0       	breq	80007458 <get_arg+0x2e8>
8000741e:	e0 89 00 07 	brgt	8000742c <get_arg+0x2bc>
80007422:	58 1a       	cp.w	r10,1
80007424:	c1 a0       	breq	80007458 <get_arg+0x2e8>
80007426:	58 2a       	cp.w	r10,2
80007428:	c1 81       	brne	80007458 <get_arg+0x2e8>
8000742a:	c0 58       	rjmp	80007434 <get_arg+0x2c4>
8000742c:	58 5a       	cp.w	r10,5
8000742e:	c0 c0       	breq	80007446 <get_arg+0x2d6>
80007430:	c0 b5       	brlt	80007446 <get_arg+0x2d6>
80007432:	c1 38       	rjmp	80007458 <get_arg+0x2e8>
80007434:	6c 0a       	ld.w	r10,r6[0x0]
80007436:	f4 cc ff f8 	sub	r12,r10,-8
8000743a:	8d 0c       	st.w	r6[0x0],r12
8000743c:	f4 e2 00 00 	ld.d	r2,r10[0]
80007440:	f0 e3 00 00 	st.d	r8[0],r2
80007444:	c1 08       	rjmp	80007464 <get_arg+0x2f4>
80007446:	6c 0a       	ld.w	r10,r6[0x0]
80007448:	f4 cc ff f8 	sub	r12,r10,-8
8000744c:	8d 0c       	st.w	r6[0x0],r12
8000744e:	f4 e2 00 00 	ld.d	r2,r10[0]
80007452:	f0 e3 00 00 	st.d	r8[0],r2
80007456:	c0 78       	rjmp	80007464 <get_arg+0x2f4>
80007458:	6c 0a       	ld.w	r10,r6[0x0]
8000745a:	f4 cc ff fc 	sub	r12,r10,-4
8000745e:	8d 0c       	st.w	r6[0x0],r12
80007460:	74 0a       	ld.w	r10,r10[0x0]
80007462:	91 0a       	st.w	r8[0x0],r10
80007464:	2f f5       	sub	r5,-1
80007466:	2f 88       	sub	r8,-8
80007468:	2f c1       	sub	r1,-4
8000746a:	12 35       	cp.w	r5,r9
8000746c:	fe 9a ff d6 	brle	80007418 <get_arg+0x2a8>
80007470:	1c 93       	mov	r3,lr
80007472:	40 52       	lddsp	r2,sp[0x14]
80007474:	40 6e       	lddsp	lr,sp[0x18]
80007476:	85 05       	st.w	r2[0x0],r5
80007478:	9d 0b       	st.w	lr[0x0],r11
8000747a:	40 4b       	lddsp	r11,sp[0x10]
8000747c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007480:	2f 8d       	sub	sp,-32
80007482:	d8 32       	popm	r0-r7,pc

80007484 <__sprint_r>:
80007484:	d4 21       	pushm	r4-r7,lr
80007486:	14 97       	mov	r7,r10
80007488:	74 28       	ld.w	r8,r10[0x8]
8000748a:	58 08       	cp.w	r8,0
8000748c:	c0 41       	brne	80007494 <__sprint_r+0x10>
8000748e:	95 18       	st.w	r10[0x4],r8
80007490:	10 9c       	mov	r12,r8
80007492:	d8 22       	popm	r4-r7,pc
80007494:	e0 a0 18 ba 	rcall	8000a608 <__sfvwrite_r>
80007498:	30 08       	mov	r8,0
8000749a:	8f 18       	st.w	r7[0x4],r8
8000749c:	8f 28       	st.w	r7[0x8],r8
8000749e:	d8 22       	popm	r4-r7,pc

800074a0 <_vfprintf_r>:
800074a0:	d4 31       	pushm	r0-r7,lr
800074a2:	fa cd 06 bc 	sub	sp,sp,1724
800074a6:	51 09       	stdsp	sp[0x40],r9
800074a8:	16 91       	mov	r1,r11
800074aa:	14 97       	mov	r7,r10
800074ac:	18 95       	mov	r5,r12
800074ae:	e0 a0 1a 1d 	rcall	8000a8e8 <_localeconv_r>
800074b2:	78 0c       	ld.w	r12,r12[0x0]
800074b4:	50 cc       	stdsp	sp[0x30],r12
800074b6:	58 05       	cp.w	r5,0
800074b8:	c0 70       	breq	800074c6 <_vfprintf_r+0x26>
800074ba:	6a 68       	ld.w	r8,r5[0x18]
800074bc:	58 08       	cp.w	r8,0
800074be:	c0 41       	brne	800074c6 <_vfprintf_r+0x26>
800074c0:	0a 9c       	mov	r12,r5
800074c2:	e0 a0 17 43 	rcall	8000a348 <__sinit>
800074c6:	fe c8 a1 16 	sub	r8,pc,-24298
800074ca:	10 31       	cp.w	r1,r8
800074cc:	c0 31       	brne	800074d2 <_vfprintf_r+0x32>
800074ce:	6a 01       	ld.w	r1,r5[0x0]
800074d0:	c0 c8       	rjmp	800074e8 <_vfprintf_r+0x48>
800074d2:	fe c8 a1 02 	sub	r8,pc,-24318
800074d6:	10 31       	cp.w	r1,r8
800074d8:	c0 31       	brne	800074de <_vfprintf_r+0x3e>
800074da:	6a 11       	ld.w	r1,r5[0x4]
800074dc:	c0 68       	rjmp	800074e8 <_vfprintf_r+0x48>
800074de:	fe c8 a0 ee 	sub	r8,pc,-24338
800074e2:	10 31       	cp.w	r1,r8
800074e4:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800074e8:	82 68       	ld.sh	r8,r1[0xc]
800074ea:	ed b8 00 03 	bld	r8,0x3
800074ee:	c0 41       	brne	800074f6 <_vfprintf_r+0x56>
800074f0:	62 48       	ld.w	r8,r1[0x10]
800074f2:	58 08       	cp.w	r8,0
800074f4:	c0 71       	brne	80007502 <_vfprintf_r+0x62>
800074f6:	02 9b       	mov	r11,r1
800074f8:	0a 9c       	mov	r12,r5
800074fa:	e0 a0 0f 5d 	rcall	800093b4 <__swsetup_r>
800074fe:	e0 81 0f 54 	brne	800093a6 <_vfprintf_r+0x1f06>
80007502:	82 68       	ld.sh	r8,r1[0xc]
80007504:	10 99       	mov	r9,r8
80007506:	e2 19 00 1a 	andl	r9,0x1a,COH
8000750a:	58 a9       	cp.w	r9,10
8000750c:	c3 c1       	brne	80007584 <_vfprintf_r+0xe4>
8000750e:	82 79       	ld.sh	r9,r1[0xe]
80007510:	30 0a       	mov	r10,0
80007512:	f4 09 19 00 	cp.h	r9,r10
80007516:	c3 75       	brlt	80007584 <_vfprintf_r+0xe4>
80007518:	a1 d8       	cbr	r8,0x1
8000751a:	fb 58 05 d0 	st.h	sp[1488],r8
8000751e:	62 88       	ld.w	r8,r1[0x20]
80007520:	fb 48 05 e4 	st.w	sp[1508],r8
80007524:	62 a8       	ld.w	r8,r1[0x28]
80007526:	fb 48 05 ec 	st.w	sp[1516],r8
8000752a:	fa c8 ff bc 	sub	r8,sp,-68
8000752e:	fb 48 05 d4 	st.w	sp[1492],r8
80007532:	fb 48 05 c4 	st.w	sp[1476],r8
80007536:	e0 68 04 00 	mov	r8,1024
8000753a:	fb 48 05 d8 	st.w	sp[1496],r8
8000753e:	fb 48 05 cc 	st.w	sp[1484],r8
80007542:	30 08       	mov	r8,0
80007544:	fb 59 05 d2 	st.h	sp[1490],r9
80007548:	0e 9a       	mov	r10,r7
8000754a:	41 09       	lddsp	r9,sp[0x40]
8000754c:	fa c7 fa 3c 	sub	r7,sp,-1476
80007550:	fb 48 05 dc 	st.w	sp[1500],r8
80007554:	0a 9c       	mov	r12,r5
80007556:	0e 9b       	mov	r11,r7
80007558:	ca 4f       	rcall	800074a0 <_vfprintf_r>
8000755a:	50 bc       	stdsp	sp[0x2c],r12
8000755c:	c0 95       	brlt	8000756e <_vfprintf_r+0xce>
8000755e:	0e 9b       	mov	r11,r7
80007560:	0a 9c       	mov	r12,r5
80007562:	e0 a0 16 1b 	rcall	8000a198 <_fflush_r>
80007566:	40 be       	lddsp	lr,sp[0x2c]
80007568:	f9 be 01 ff 	movne	lr,-1
8000756c:	50 be       	stdsp	sp[0x2c],lr
8000756e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007572:	ed b8 00 06 	bld	r8,0x6
80007576:	e0 81 0f 1a 	brne	800093aa <_vfprintf_r+0x1f0a>
8000757a:	82 68       	ld.sh	r8,r1[0xc]
8000757c:	a7 a8       	sbr	r8,0x6
8000757e:	a2 68       	st.h	r1[0xc],r8
80007580:	e0 8f 0f 15 	bral	800093aa <_vfprintf_r+0x1f0a>
80007584:	30 08       	mov	r8,0
80007586:	fb 48 06 b4 	st.w	sp[1716],r8
8000758a:	fb 48 06 90 	st.w	sp[1680],r8
8000758e:	fb 48 06 8c 	st.w	sp[1676],r8
80007592:	fb 48 06 b0 	st.w	sp[1712],r8
80007596:	30 08       	mov	r8,0
80007598:	30 09       	mov	r9,0
8000759a:	50 a7       	stdsp	sp[0x28],r7
8000759c:	50 78       	stdsp	sp[0x1c],r8
8000759e:	fa c3 f9 e0 	sub	r3,sp,-1568
800075a2:	3f f8       	mov	r8,-1
800075a4:	50 59       	stdsp	sp[0x14],r9
800075a6:	fb 43 06 88 	st.w	sp[1672],r3
800075aa:	fb 48 05 44 	st.w	sp[1348],r8
800075ae:	12 9c       	mov	r12,r9
800075b0:	50 69       	stdsp	sp[0x18],r9
800075b2:	50 d9       	stdsp	sp[0x34],r9
800075b4:	50 e9       	stdsp	sp[0x38],r9
800075b6:	50 b9       	stdsp	sp[0x2c],r9
800075b8:	12 97       	mov	r7,r9
800075ba:	0a 94       	mov	r4,r5
800075bc:	40 a2       	lddsp	r2,sp[0x28]
800075be:	32 5a       	mov	r10,37
800075c0:	30 08       	mov	r8,0
800075c2:	c0 28       	rjmp	800075c6 <_vfprintf_r+0x126>
800075c4:	2f f2       	sub	r2,-1
800075c6:	05 89       	ld.ub	r9,r2[0x0]
800075c8:	f0 09 18 00 	cp.b	r9,r8
800075cc:	5f 1b       	srne	r11
800075ce:	f4 09 18 00 	cp.b	r9,r10
800075d2:	5f 19       	srne	r9
800075d4:	f3 eb 00 0b 	and	r11,r9,r11
800075d8:	f0 0b 18 00 	cp.b	r11,r8
800075dc:	cf 41       	brne	800075c4 <_vfprintf_r+0x124>
800075de:	40 ab       	lddsp	r11,sp[0x28]
800075e0:	e4 0b 01 06 	sub	r6,r2,r11
800075e4:	c1 e0       	breq	80007620 <_vfprintf_r+0x180>
800075e6:	fa f8 06 90 	ld.w	r8,sp[1680]
800075ea:	0c 08       	add	r8,r6
800075ec:	87 0b       	st.w	r3[0x0],r11
800075ee:	fb 48 06 90 	st.w	sp[1680],r8
800075f2:	87 16       	st.w	r3[0x4],r6
800075f4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800075f8:	2f f8       	sub	r8,-1
800075fa:	fb 48 06 8c 	st.w	sp[1676],r8
800075fe:	58 78       	cp.w	r8,7
80007600:	e0 89 00 04 	brgt	80007608 <_vfprintf_r+0x168>
80007604:	2f 83       	sub	r3,-8
80007606:	c0 a8       	rjmp	8000761a <_vfprintf_r+0x17a>
80007608:	fa ca f9 78 	sub	r10,sp,-1672
8000760c:	02 9b       	mov	r11,r1
8000760e:	08 9c       	mov	r12,r4
80007610:	c3 af       	rcall	80007484 <__sprint_r>
80007612:	e0 81 0e c6 	brne	8000939e <_vfprintf_r+0x1efe>
80007616:	fa c3 f9 e0 	sub	r3,sp,-1568
8000761a:	40 ba       	lddsp	r10,sp[0x2c]
8000761c:	0c 0a       	add	r10,r6
8000761e:	50 ba       	stdsp	sp[0x2c],r10
80007620:	05 89       	ld.ub	r9,r2[0x0]
80007622:	30 08       	mov	r8,0
80007624:	f0 09 18 00 	cp.b	r9,r8
80007628:	e0 80 0e aa 	breq	8000937c <_vfprintf_r+0x1edc>
8000762c:	30 09       	mov	r9,0
8000762e:	fb 68 06 bb 	st.b	sp[1723],r8
80007632:	0e 96       	mov	r6,r7
80007634:	e4 c8 ff ff 	sub	r8,r2,-1
80007638:	3f fe       	mov	lr,-1
8000763a:	50 93       	stdsp	sp[0x24],r3
8000763c:	50 41       	stdsp	sp[0x10],r1
8000763e:	0e 93       	mov	r3,r7
80007640:	04 91       	mov	r1,r2
80007642:	50 89       	stdsp	sp[0x20],r9
80007644:	50 a8       	stdsp	sp[0x28],r8
80007646:	50 2e       	stdsp	sp[0x8],lr
80007648:	50 39       	stdsp	sp[0xc],r9
8000764a:	12 95       	mov	r5,r9
8000764c:	12 90       	mov	r0,r9
8000764e:	10 97       	mov	r7,r8
80007650:	08 92       	mov	r2,r4
80007652:	c0 78       	rjmp	80007660 <_vfprintf_r+0x1c0>
80007654:	3f fc       	mov	r12,-1
80007656:	08 97       	mov	r7,r4
80007658:	50 2c       	stdsp	sp[0x8],r12
8000765a:	c0 38       	rjmp	80007660 <_vfprintf_r+0x1c0>
8000765c:	30 0b       	mov	r11,0
8000765e:	50 3b       	stdsp	sp[0xc],r11
80007660:	0f 38       	ld.ub	r8,r7++
80007662:	c0 28       	rjmp	80007666 <_vfprintf_r+0x1c6>
80007664:	12 90       	mov	r0,r9
80007666:	f0 c9 00 20 	sub	r9,r8,32
8000766a:	e0 49 00 58 	cp.w	r9,88
8000766e:	e0 8b 0a 30 	brhi	80008ace <_vfprintf_r+0x162e>
80007672:	fe ca a6 6a 	sub	r10,pc,-22934
80007676:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000767a:	50 a7       	stdsp	sp[0x28],r7
8000767c:	50 80       	stdsp	sp[0x20],r0
8000767e:	0c 97       	mov	r7,r6
80007680:	04 94       	mov	r4,r2
80007682:	06 96       	mov	r6,r3
80007684:	02 92       	mov	r2,r1
80007686:	fe c9 a4 42 	sub	r9,pc,-23486
8000768a:	40 93       	lddsp	r3,sp[0x24]
8000768c:	10 90       	mov	r0,r8
8000768e:	40 41       	lddsp	r1,sp[0x10]
80007690:	50 d9       	stdsp	sp[0x34],r9
80007692:	e0 8f 08 8e 	bral	800087ae <_vfprintf_r+0x130e>
80007696:	30 08       	mov	r8,0
80007698:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000769c:	f0 09 18 00 	cp.b	r9,r8
800076a0:	ce 01       	brne	80007660 <_vfprintf_r+0x1c0>
800076a2:	32 08       	mov	r8,32
800076a4:	c6 e8       	rjmp	80007780 <_vfprintf_r+0x2e0>
800076a6:	a1 a5       	sbr	r5,0x0
800076a8:	cd cb       	rjmp	80007660 <_vfprintf_r+0x1c0>
800076aa:	0f 89       	ld.ub	r9,r7[0x0]
800076ac:	f2 c8 00 30 	sub	r8,r9,48
800076b0:	58 98       	cp.w	r8,9
800076b2:	e0 8b 00 1d 	brhi	800076ec <_vfprintf_r+0x24c>
800076b6:	ee c8 ff ff 	sub	r8,r7,-1
800076ba:	30 0b       	mov	r11,0
800076bc:	23 09       	sub	r9,48
800076be:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800076c2:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800076c6:	11 39       	ld.ub	r9,r8++
800076c8:	f2 ca 00 30 	sub	r10,r9,48
800076cc:	58 9a       	cp.w	r10,9
800076ce:	fe 98 ff f7 	brls	800076bc <_vfprintf_r+0x21c>
800076d2:	e0 49 00 24 	cp.w	r9,36
800076d6:	cc 31       	brne	8000765c <_vfprintf_r+0x1bc>
800076d8:	e0 4b 00 20 	cp.w	r11,32
800076dc:	e0 89 0e 60 	brgt	8000939c <_vfprintf_r+0x1efc>
800076e0:	20 1b       	sub	r11,1
800076e2:	fa f9 06 b4 	ld.w	r9,sp[1716]
800076e6:	12 3b       	cp.w	r11,r9
800076e8:	c0 95       	brlt	800076fa <_vfprintf_r+0x25a>
800076ea:	c1 08       	rjmp	8000770a <_vfprintf_r+0x26a>
800076ec:	fa f9 06 b4 	ld.w	r9,sp[1716]
800076f0:	ec ca ff ff 	sub	r10,r6,-1
800076f4:	12 36       	cp.w	r6,r9
800076f6:	c1 f5       	brlt	80007734 <_vfprintf_r+0x294>
800076f8:	c2 68       	rjmp	80007744 <_vfprintf_r+0x2a4>
800076fa:	fa ce f9 44 	sub	lr,sp,-1724
800076fe:	10 97       	mov	r7,r8
80007700:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007704:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007708:	c3 58       	rjmp	80007772 <_vfprintf_r+0x2d2>
8000770a:	10 97       	mov	r7,r8
8000770c:	fa c8 f9 50 	sub	r8,sp,-1712
80007710:	1a d8       	st.w	--sp,r8
80007712:	fa c8 fa b8 	sub	r8,sp,-1352
80007716:	1a d8       	st.w	--sp,r8
80007718:	fa c8 fb b4 	sub	r8,sp,-1100
8000771c:	02 9a       	mov	r10,r1
8000771e:	1a d8       	st.w	--sp,r8
80007720:	04 9c       	mov	r12,r2
80007722:	fa c8 f9 40 	sub	r8,sp,-1728
80007726:	fa c9 ff b4 	sub	r9,sp,-76
8000772a:	fe b0 fd 23 	rcall	80007170 <get_arg>
8000772e:	2f dd       	sub	sp,-12
80007730:	78 00       	ld.w	r0,r12[0x0]
80007732:	c2 08       	rjmp	80007772 <_vfprintf_r+0x2d2>
80007734:	fa cc f9 44 	sub	r12,sp,-1724
80007738:	14 96       	mov	r6,r10
8000773a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000773e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007742:	c1 88       	rjmp	80007772 <_vfprintf_r+0x2d2>
80007744:	41 08       	lddsp	r8,sp[0x40]
80007746:	59 f9       	cp.w	r9,31
80007748:	e0 89 00 11 	brgt	8000776a <_vfprintf_r+0x2ca>
8000774c:	f0 cb ff fc 	sub	r11,r8,-4
80007750:	51 0b       	stdsp	sp[0x40],r11
80007752:	70 00       	ld.w	r0,r8[0x0]
80007754:	fa cb f9 44 	sub	r11,sp,-1724
80007758:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000775c:	f1 40 fd 88 	st.w	r8[-632],r0
80007760:	2f f9       	sub	r9,-1
80007762:	14 96       	mov	r6,r10
80007764:	fb 49 06 b4 	st.w	sp[1716],r9
80007768:	c0 58       	rjmp	80007772 <_vfprintf_r+0x2d2>
8000776a:	70 00       	ld.w	r0,r8[0x0]
8000776c:	14 96       	mov	r6,r10
8000776e:	2f c8       	sub	r8,-4
80007770:	51 08       	stdsp	sp[0x40],r8
80007772:	58 00       	cp.w	r0,0
80007774:	fe 94 ff 76 	brge	80007660 <_vfprintf_r+0x1c0>
80007778:	5c 30       	neg	r0
8000777a:	a3 a5       	sbr	r5,0x2
8000777c:	c7 2b       	rjmp	80007660 <_vfprintf_r+0x1c0>
8000777e:	32 b8       	mov	r8,43
80007780:	fb 68 06 bb 	st.b	sp[1723],r8
80007784:	c6 eb       	rjmp	80007660 <_vfprintf_r+0x1c0>
80007786:	0f 38       	ld.ub	r8,r7++
80007788:	e0 48 00 2a 	cp.w	r8,42
8000778c:	c0 30       	breq	80007792 <_vfprintf_r+0x2f2>
8000778e:	30 09       	mov	r9,0
80007790:	c7 98       	rjmp	80007882 <_vfprintf_r+0x3e2>
80007792:	0f 88       	ld.ub	r8,r7[0x0]
80007794:	f0 c9 00 30 	sub	r9,r8,48
80007798:	58 99       	cp.w	r9,9
8000779a:	e0 8b 00 1f 	brhi	800077d8 <_vfprintf_r+0x338>
8000779e:	ee c4 ff ff 	sub	r4,r7,-1
800077a2:	30 0b       	mov	r11,0
800077a4:	23 08       	sub	r8,48
800077a6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800077aa:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800077ae:	09 38       	ld.ub	r8,r4++
800077b0:	f0 c9 00 30 	sub	r9,r8,48
800077b4:	58 99       	cp.w	r9,9
800077b6:	fe 98 ff f7 	brls	800077a4 <_vfprintf_r+0x304>
800077ba:	e0 48 00 24 	cp.w	r8,36
800077be:	fe 91 ff 4f 	brne	8000765c <_vfprintf_r+0x1bc>
800077c2:	e0 4b 00 20 	cp.w	r11,32
800077c6:	e0 89 0d eb 	brgt	8000939c <_vfprintf_r+0x1efc>
800077ca:	20 1b       	sub	r11,1
800077cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800077d0:	10 3b       	cp.w	r11,r8
800077d2:	c0 a5       	brlt	800077e6 <_vfprintf_r+0x346>
800077d4:	c1 18       	rjmp	800077f6 <_vfprintf_r+0x356>
800077d6:	d7 03       	nop
800077d8:	fa fa 06 b4 	ld.w	r10,sp[1716]
800077dc:	ec c9 ff ff 	sub	r9,r6,-1
800077e0:	14 36       	cp.w	r6,r10
800077e2:	c1 f5       	brlt	80007820 <_vfprintf_r+0x380>
800077e4:	c2 88       	rjmp	80007834 <_vfprintf_r+0x394>
800077e6:	fa ca f9 44 	sub	r10,sp,-1724
800077ea:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800077ee:	f6 fb fd 88 	ld.w	r11,r11[-632]
800077f2:	50 2b       	stdsp	sp[0x8],r11
800077f4:	c3 c8       	rjmp	8000786c <_vfprintf_r+0x3cc>
800077f6:	fa c8 f9 50 	sub	r8,sp,-1712
800077fa:	1a d8       	st.w	--sp,r8
800077fc:	fa c8 fa b8 	sub	r8,sp,-1352
80007800:	1a d8       	st.w	--sp,r8
80007802:	fa c8 fb b4 	sub	r8,sp,-1100
80007806:	02 9a       	mov	r10,r1
80007808:	1a d8       	st.w	--sp,r8
8000780a:	04 9c       	mov	r12,r2
8000780c:	fa c8 f9 40 	sub	r8,sp,-1728
80007810:	fa c9 ff b4 	sub	r9,sp,-76
80007814:	fe b0 fc ae 	rcall	80007170 <get_arg>
80007818:	2f dd       	sub	sp,-12
8000781a:	78 0c       	ld.w	r12,r12[0x0]
8000781c:	50 2c       	stdsp	sp[0x8],r12
8000781e:	c2 78       	rjmp	8000786c <_vfprintf_r+0x3cc>
80007820:	12 96       	mov	r6,r9
80007822:	0e 94       	mov	r4,r7
80007824:	fa c9 f9 44 	sub	r9,sp,-1724
80007828:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000782c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007830:	50 28       	stdsp	sp[0x8],r8
80007832:	c1 d8       	rjmp	8000786c <_vfprintf_r+0x3cc>
80007834:	41 08       	lddsp	r8,sp[0x40]
80007836:	59 fa       	cp.w	r10,31
80007838:	e0 89 00 14 	brgt	80007860 <_vfprintf_r+0x3c0>
8000783c:	f0 cb ff fc 	sub	r11,r8,-4
80007840:	70 08       	ld.w	r8,r8[0x0]
80007842:	51 0b       	stdsp	sp[0x40],r11
80007844:	50 28       	stdsp	sp[0x8],r8
80007846:	fa c6 f9 44 	sub	r6,sp,-1724
8000784a:	40 2e       	lddsp	lr,sp[0x8]
8000784c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007850:	f1 4e fd 88 	st.w	r8[-632],lr
80007854:	2f fa       	sub	r10,-1
80007856:	0e 94       	mov	r4,r7
80007858:	fb 4a 06 b4 	st.w	sp[1716],r10
8000785c:	12 96       	mov	r6,r9
8000785e:	c0 78       	rjmp	8000786c <_vfprintf_r+0x3cc>
80007860:	70 0c       	ld.w	r12,r8[0x0]
80007862:	0e 94       	mov	r4,r7
80007864:	2f c8       	sub	r8,-4
80007866:	50 2c       	stdsp	sp[0x8],r12
80007868:	12 96       	mov	r6,r9
8000786a:	51 08       	stdsp	sp[0x40],r8
8000786c:	40 2b       	lddsp	r11,sp[0x8]
8000786e:	58 0b       	cp.w	r11,0
80007870:	fe 95 fe f2 	brlt	80007654 <_vfprintf_r+0x1b4>
80007874:	08 97       	mov	r7,r4
80007876:	cf 5a       	rjmp	80007660 <_vfprintf_r+0x1c0>
80007878:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000787c:	0f 38       	ld.ub	r8,r7++
8000787e:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007882:	f0 ca 00 30 	sub	r10,r8,48
80007886:	58 9a       	cp.w	r10,9
80007888:	fe 98 ff f8 	brls	80007878 <_vfprintf_r+0x3d8>
8000788c:	3f fa       	mov	r10,-1
8000788e:	f2 0a 0c 49 	max	r9,r9,r10
80007892:	50 29       	stdsp	sp[0x8],r9
80007894:	ce 9a       	rjmp	80007666 <_vfprintf_r+0x1c6>
80007896:	a7 b5       	sbr	r5,0x7
80007898:	ce 4a       	rjmp	80007660 <_vfprintf_r+0x1c0>
8000789a:	30 09       	mov	r9,0
8000789c:	23 08       	sub	r8,48
8000789e:	f2 09 00 29 	add	r9,r9,r9<<0x2
800078a2:	f0 09 00 19 	add	r9,r8,r9<<0x1
800078a6:	0f 38       	ld.ub	r8,r7++
800078a8:	f0 ca 00 30 	sub	r10,r8,48
800078ac:	58 9a       	cp.w	r10,9
800078ae:	fe 98 ff f7 	brls	8000789c <_vfprintf_r+0x3fc>
800078b2:	e0 48 00 24 	cp.w	r8,36
800078b6:	fe 91 fe d7 	brne	80007664 <_vfprintf_r+0x1c4>
800078ba:	e0 49 00 20 	cp.w	r9,32
800078be:	e0 89 0d 6f 	brgt	8000939c <_vfprintf_r+0x1efc>
800078c2:	f2 c3 00 01 	sub	r3,r9,1
800078c6:	30 19       	mov	r9,1
800078c8:	50 39       	stdsp	sp[0xc],r9
800078ca:	cc ba       	rjmp	80007660 <_vfprintf_r+0x1c0>
800078cc:	a3 b5       	sbr	r5,0x3
800078ce:	cc 9a       	rjmp	80007660 <_vfprintf_r+0x1c0>
800078d0:	a7 a5       	sbr	r5,0x6
800078d2:	cc 7a       	rjmp	80007660 <_vfprintf_r+0x1c0>
800078d4:	0a 98       	mov	r8,r5
800078d6:	a5 b5       	sbr	r5,0x5
800078d8:	a5 a8       	sbr	r8,0x4
800078da:	0f 89       	ld.ub	r9,r7[0x0]
800078dc:	36 ce       	mov	lr,108
800078de:	fc 09 18 00 	cp.b	r9,lr
800078e2:	f7 b7 00 ff 	subeq	r7,-1
800078e6:	f0 05 17 10 	movne	r5,r8
800078ea:	cb ba       	rjmp	80007660 <_vfprintf_r+0x1c0>
800078ec:	a5 b5       	sbr	r5,0x5
800078ee:	cb 9a       	rjmp	80007660 <_vfprintf_r+0x1c0>
800078f0:	50 a7       	stdsp	sp[0x28],r7
800078f2:	50 80       	stdsp	sp[0x20],r0
800078f4:	0c 97       	mov	r7,r6
800078f6:	10 90       	mov	r0,r8
800078f8:	06 96       	mov	r6,r3
800078fa:	04 94       	mov	r4,r2
800078fc:	40 93       	lddsp	r3,sp[0x24]
800078fe:	02 92       	mov	r2,r1
80007900:	0e 99       	mov	r9,r7
80007902:	40 41       	lddsp	r1,sp[0x10]
80007904:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007908:	40 3c       	lddsp	r12,sp[0xc]
8000790a:	58 0c       	cp.w	r12,0
8000790c:	c1 d0       	breq	80007946 <_vfprintf_r+0x4a6>
8000790e:	10 36       	cp.w	r6,r8
80007910:	c0 64       	brge	8000791c <_vfprintf_r+0x47c>
80007912:	fa cb f9 44 	sub	r11,sp,-1724
80007916:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000791a:	c1 d8       	rjmp	80007954 <_vfprintf_r+0x4b4>
8000791c:	fa c8 f9 50 	sub	r8,sp,-1712
80007920:	1a d8       	st.w	--sp,r8
80007922:	fa c8 fa b8 	sub	r8,sp,-1352
80007926:	1a d8       	st.w	--sp,r8
80007928:	fa c8 fb b4 	sub	r8,sp,-1100
8000792c:	1a d8       	st.w	--sp,r8
8000792e:	fa c8 f9 40 	sub	r8,sp,-1728
80007932:	fa c9 ff b4 	sub	r9,sp,-76
80007936:	04 9a       	mov	r10,r2
80007938:	0c 9b       	mov	r11,r6
8000793a:	08 9c       	mov	r12,r4
8000793c:	fe b0 fc 1a 	rcall	80007170 <get_arg>
80007940:	2f dd       	sub	sp,-12
80007942:	19 b8       	ld.ub	r8,r12[0x3]
80007944:	c2 28       	rjmp	80007988 <_vfprintf_r+0x4e8>
80007946:	2f f7       	sub	r7,-1
80007948:	10 39       	cp.w	r9,r8
8000794a:	c0 84       	brge	8000795a <_vfprintf_r+0x4ba>
8000794c:	fa ca f9 44 	sub	r10,sp,-1724
80007950:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007954:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007958:	c1 88       	rjmp	80007988 <_vfprintf_r+0x4e8>
8000795a:	41 09       	lddsp	r9,sp[0x40]
8000795c:	59 f8       	cp.w	r8,31
8000795e:	e0 89 00 12 	brgt	80007982 <_vfprintf_r+0x4e2>
80007962:	f2 ca ff fc 	sub	r10,r9,-4
80007966:	51 0a       	stdsp	sp[0x40],r10
80007968:	72 09       	ld.w	r9,r9[0x0]
8000796a:	fa c6 f9 44 	sub	r6,sp,-1724
8000796e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007972:	2f f8       	sub	r8,-1
80007974:	f5 49 fd 88 	st.w	r10[-632],r9
80007978:	fb 48 06 b4 	st.w	sp[1716],r8
8000797c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007980:	c0 48       	rjmp	80007988 <_vfprintf_r+0x4e8>
80007982:	13 b8       	ld.ub	r8,r9[0x3]
80007984:	2f c9       	sub	r9,-4
80007986:	51 09       	stdsp	sp[0x40],r9
80007988:	fb 68 06 60 	st.b	sp[1632],r8
8000798c:	30 0e       	mov	lr,0
8000798e:	30 08       	mov	r8,0
80007990:	30 12       	mov	r2,1
80007992:	fb 68 06 bb 	st.b	sp[1723],r8
80007996:	50 2e       	stdsp	sp[0x8],lr
80007998:	e0 8f 08 ad 	bral	80008af2 <_vfprintf_r+0x1652>
8000799c:	50 a7       	stdsp	sp[0x28],r7
8000799e:	50 80       	stdsp	sp[0x20],r0
800079a0:	0c 97       	mov	r7,r6
800079a2:	04 94       	mov	r4,r2
800079a4:	06 96       	mov	r6,r3
800079a6:	02 92       	mov	r2,r1
800079a8:	40 93       	lddsp	r3,sp[0x24]
800079aa:	10 90       	mov	r0,r8
800079ac:	40 41       	lddsp	r1,sp[0x10]
800079ae:	a5 a5       	sbr	r5,0x4
800079b0:	c0 a8       	rjmp	800079c4 <_vfprintf_r+0x524>
800079b2:	50 a7       	stdsp	sp[0x28],r7
800079b4:	50 80       	stdsp	sp[0x20],r0
800079b6:	0c 97       	mov	r7,r6
800079b8:	04 94       	mov	r4,r2
800079ba:	06 96       	mov	r6,r3
800079bc:	02 92       	mov	r2,r1
800079be:	40 93       	lddsp	r3,sp[0x24]
800079c0:	10 90       	mov	r0,r8
800079c2:	40 41       	lddsp	r1,sp[0x10]
800079c4:	ed b5 00 05 	bld	r5,0x5
800079c8:	c5 11       	brne	80007a6a <_vfprintf_r+0x5ca>
800079ca:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079ce:	40 3c       	lddsp	r12,sp[0xc]
800079d0:	58 0c       	cp.w	r12,0
800079d2:	c1 e0       	breq	80007a0e <_vfprintf_r+0x56e>
800079d4:	10 36       	cp.w	r6,r8
800079d6:	c0 64       	brge	800079e2 <_vfprintf_r+0x542>
800079d8:	fa cb f9 44 	sub	r11,sp,-1724
800079dc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800079e0:	c2 08       	rjmp	80007a20 <_vfprintf_r+0x580>
800079e2:	fa c8 f9 50 	sub	r8,sp,-1712
800079e6:	1a d8       	st.w	--sp,r8
800079e8:	fa c8 fa b8 	sub	r8,sp,-1352
800079ec:	0c 9b       	mov	r11,r6
800079ee:	1a d8       	st.w	--sp,r8
800079f0:	fa c8 fb b4 	sub	r8,sp,-1100
800079f4:	1a d8       	st.w	--sp,r8
800079f6:	fa c9 ff b4 	sub	r9,sp,-76
800079fa:	fa c8 f9 40 	sub	r8,sp,-1728
800079fe:	04 9a       	mov	r10,r2
80007a00:	08 9c       	mov	r12,r4
80007a02:	fe b0 fb b7 	rcall	80007170 <get_arg>
80007a06:	2f dd       	sub	sp,-12
80007a08:	78 1b       	ld.w	r11,r12[0x4]
80007a0a:	78 09       	ld.w	r9,r12[0x0]
80007a0c:	c2 b8       	rjmp	80007a62 <_vfprintf_r+0x5c2>
80007a0e:	ee ca ff ff 	sub	r10,r7,-1
80007a12:	10 37       	cp.w	r7,r8
80007a14:	c0 b4       	brge	80007a2a <_vfprintf_r+0x58a>
80007a16:	fa c9 f9 44 	sub	r9,sp,-1724
80007a1a:	14 97       	mov	r7,r10
80007a1c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007a20:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007a24:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007a28:	c1 d8       	rjmp	80007a62 <_vfprintf_r+0x5c2>
80007a2a:	41 09       	lddsp	r9,sp[0x40]
80007a2c:	59 f8       	cp.w	r8,31
80007a2e:	e0 89 00 14 	brgt	80007a56 <_vfprintf_r+0x5b6>
80007a32:	f2 cb ff f8 	sub	r11,r9,-8
80007a36:	51 0b       	stdsp	sp[0x40],r11
80007a38:	fa c6 f9 44 	sub	r6,sp,-1724
80007a3c:	72 1b       	ld.w	r11,r9[0x4]
80007a3e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007a42:	72 09       	ld.w	r9,r9[0x0]
80007a44:	f9 4b fd 8c 	st.w	r12[-628],r11
80007a48:	f9 49 fd 88 	st.w	r12[-632],r9
80007a4c:	2f f8       	sub	r8,-1
80007a4e:	14 97       	mov	r7,r10
80007a50:	fb 48 06 b4 	st.w	sp[1716],r8
80007a54:	c0 78       	rjmp	80007a62 <_vfprintf_r+0x5c2>
80007a56:	f2 c8 ff f8 	sub	r8,r9,-8
80007a5a:	72 1b       	ld.w	r11,r9[0x4]
80007a5c:	14 97       	mov	r7,r10
80007a5e:	51 08       	stdsp	sp[0x40],r8
80007a60:	72 09       	ld.w	r9,r9[0x0]
80007a62:	16 98       	mov	r8,r11
80007a64:	fa e9 00 00 	st.d	sp[0],r8
80007a68:	ca e8       	rjmp	80007bc4 <_vfprintf_r+0x724>
80007a6a:	ed b5 00 04 	bld	r5,0x4
80007a6e:	c1 71       	brne	80007a9c <_vfprintf_r+0x5fc>
80007a70:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a74:	40 3e       	lddsp	lr,sp[0xc]
80007a76:	58 0e       	cp.w	lr,0
80007a78:	c0 80       	breq	80007a88 <_vfprintf_r+0x5e8>
80007a7a:	10 36       	cp.w	r6,r8
80007a7c:	c6 94       	brge	80007b4e <_vfprintf_r+0x6ae>
80007a7e:	fa cc f9 44 	sub	r12,sp,-1724
80007a82:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007a86:	c8 28       	rjmp	80007b8a <_vfprintf_r+0x6ea>
80007a88:	ee ca ff ff 	sub	r10,r7,-1
80007a8c:	10 37       	cp.w	r7,r8
80007a8e:	e0 84 00 81 	brge	80007b90 <_vfprintf_r+0x6f0>
80007a92:	fa cb f9 44 	sub	r11,sp,-1724
80007a96:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a9a:	c7 78       	rjmp	80007b88 <_vfprintf_r+0x6e8>
80007a9c:	ed b5 00 06 	bld	r5,0x6
80007aa0:	c4 b1       	brne	80007b36 <_vfprintf_r+0x696>
80007aa2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007aa6:	40 3c       	lddsp	r12,sp[0xc]
80007aa8:	58 0c       	cp.w	r12,0
80007aaa:	c1 d0       	breq	80007ae4 <_vfprintf_r+0x644>
80007aac:	10 36       	cp.w	r6,r8
80007aae:	c0 64       	brge	80007aba <_vfprintf_r+0x61a>
80007ab0:	fa cb f9 44 	sub	r11,sp,-1724
80007ab4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007ab8:	c1 f8       	rjmp	80007af6 <_vfprintf_r+0x656>
80007aba:	fa c8 f9 50 	sub	r8,sp,-1712
80007abe:	1a d8       	st.w	--sp,r8
80007ac0:	fa c8 fa b8 	sub	r8,sp,-1352
80007ac4:	1a d8       	st.w	--sp,r8
80007ac6:	fa c8 fb b4 	sub	r8,sp,-1100
80007aca:	1a d8       	st.w	--sp,r8
80007acc:	fa c8 f9 40 	sub	r8,sp,-1728
80007ad0:	fa c9 ff b4 	sub	r9,sp,-76
80007ad4:	04 9a       	mov	r10,r2
80007ad6:	0c 9b       	mov	r11,r6
80007ad8:	08 9c       	mov	r12,r4
80007ada:	fe b0 fb 4b 	rcall	80007170 <get_arg>
80007ade:	2f dd       	sub	sp,-12
80007ae0:	98 18       	ld.sh	r8,r12[0x2]
80007ae2:	c2 68       	rjmp	80007b2e <_vfprintf_r+0x68e>
80007ae4:	ee ca ff ff 	sub	r10,r7,-1
80007ae8:	10 37       	cp.w	r7,r8
80007aea:	c0 94       	brge	80007afc <_vfprintf_r+0x65c>
80007aec:	fa c9 f9 44 	sub	r9,sp,-1724
80007af0:	14 97       	mov	r7,r10
80007af2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007af6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007afa:	c1 a8       	rjmp	80007b2e <_vfprintf_r+0x68e>
80007afc:	41 09       	lddsp	r9,sp[0x40]
80007afe:	59 f8       	cp.w	r8,31
80007b00:	e0 89 00 13 	brgt	80007b26 <_vfprintf_r+0x686>
80007b04:	f2 cb ff fc 	sub	r11,r9,-4
80007b08:	51 0b       	stdsp	sp[0x40],r11
80007b0a:	72 09       	ld.w	r9,r9[0x0]
80007b0c:	fa c6 f9 44 	sub	r6,sp,-1724
80007b10:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007b14:	2f f8       	sub	r8,-1
80007b16:	f7 49 fd 88 	st.w	r11[-632],r9
80007b1a:	fb 48 06 b4 	st.w	sp[1716],r8
80007b1e:	14 97       	mov	r7,r10
80007b20:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007b24:	c0 58       	rjmp	80007b2e <_vfprintf_r+0x68e>
80007b26:	92 18       	ld.sh	r8,r9[0x2]
80007b28:	14 97       	mov	r7,r10
80007b2a:	2f c9       	sub	r9,-4
80007b2c:	51 09       	stdsp	sp[0x40],r9
80007b2e:	50 18       	stdsp	sp[0x4],r8
80007b30:	bf 58       	asr	r8,0x1f
80007b32:	50 08       	stdsp	sp[0x0],r8
80007b34:	c4 88       	rjmp	80007bc4 <_vfprintf_r+0x724>
80007b36:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b3a:	40 3c       	lddsp	r12,sp[0xc]
80007b3c:	58 0c       	cp.w	r12,0
80007b3e:	c1 d0       	breq	80007b78 <_vfprintf_r+0x6d8>
80007b40:	10 36       	cp.w	r6,r8
80007b42:	c0 64       	brge	80007b4e <_vfprintf_r+0x6ae>
80007b44:	fa cb f9 44 	sub	r11,sp,-1724
80007b48:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b4c:	c1 f8       	rjmp	80007b8a <_vfprintf_r+0x6ea>
80007b4e:	fa c8 f9 50 	sub	r8,sp,-1712
80007b52:	1a d8       	st.w	--sp,r8
80007b54:	fa c8 fa b8 	sub	r8,sp,-1352
80007b58:	0c 9b       	mov	r11,r6
80007b5a:	1a d8       	st.w	--sp,r8
80007b5c:	fa c8 fb b4 	sub	r8,sp,-1100
80007b60:	04 9a       	mov	r10,r2
80007b62:	1a d8       	st.w	--sp,r8
80007b64:	08 9c       	mov	r12,r4
80007b66:	fa c8 f9 40 	sub	r8,sp,-1728
80007b6a:	fa c9 ff b4 	sub	r9,sp,-76
80007b6e:	fe b0 fb 01 	rcall	80007170 <get_arg>
80007b72:	2f dd       	sub	sp,-12
80007b74:	78 0b       	ld.w	r11,r12[0x0]
80007b76:	c2 48       	rjmp	80007bbe <_vfprintf_r+0x71e>
80007b78:	ee ca ff ff 	sub	r10,r7,-1
80007b7c:	10 37       	cp.w	r7,r8
80007b7e:	c0 94       	brge	80007b90 <_vfprintf_r+0x6f0>
80007b80:	fa c9 f9 44 	sub	r9,sp,-1724
80007b84:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007b88:	14 97       	mov	r7,r10
80007b8a:	ec fb fd 88 	ld.w	r11,r6[-632]
80007b8e:	c1 88       	rjmp	80007bbe <_vfprintf_r+0x71e>
80007b90:	41 09       	lddsp	r9,sp[0x40]
80007b92:	59 f8       	cp.w	r8,31
80007b94:	e0 89 00 11 	brgt	80007bb6 <_vfprintf_r+0x716>
80007b98:	f2 cb ff fc 	sub	r11,r9,-4
80007b9c:	51 0b       	stdsp	sp[0x40],r11
80007b9e:	fa c6 f9 44 	sub	r6,sp,-1724
80007ba2:	72 0b       	ld.w	r11,r9[0x0]
80007ba4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ba8:	f3 4b fd 88 	st.w	r9[-632],r11
80007bac:	2f f8       	sub	r8,-1
80007bae:	14 97       	mov	r7,r10
80007bb0:	fb 48 06 b4 	st.w	sp[1716],r8
80007bb4:	c0 58       	rjmp	80007bbe <_vfprintf_r+0x71e>
80007bb6:	72 0b       	ld.w	r11,r9[0x0]
80007bb8:	14 97       	mov	r7,r10
80007bba:	2f c9       	sub	r9,-4
80007bbc:	51 09       	stdsp	sp[0x40],r9
80007bbe:	50 1b       	stdsp	sp[0x4],r11
80007bc0:	bf 5b       	asr	r11,0x1f
80007bc2:	50 0b       	stdsp	sp[0x0],r11
80007bc4:	fa ea 00 00 	ld.d	r10,sp[0]
80007bc8:	58 0a       	cp.w	r10,0
80007bca:	5c 2b       	cpc	r11
80007bcc:	c0 e4       	brge	80007be8 <_vfprintf_r+0x748>
80007bce:	30 08       	mov	r8,0
80007bd0:	fa ea 00 00 	ld.d	r10,sp[0]
80007bd4:	30 09       	mov	r9,0
80007bd6:	f0 0a 01 0a 	sub	r10,r8,r10
80007bda:	f2 0b 01 4b 	sbc	r11,r9,r11
80007bde:	32 d8       	mov	r8,45
80007be0:	fa eb 00 00 	st.d	sp[0],r10
80007be4:	fb 68 06 bb 	st.b	sp[1723],r8
80007be8:	30 18       	mov	r8,1
80007bea:	e0 8f 06 fa 	bral	800089de <_vfprintf_r+0x153e>
80007bee:	50 a7       	stdsp	sp[0x28],r7
80007bf0:	50 80       	stdsp	sp[0x20],r0
80007bf2:	0c 97       	mov	r7,r6
80007bf4:	04 94       	mov	r4,r2
80007bf6:	06 96       	mov	r6,r3
80007bf8:	02 92       	mov	r2,r1
80007bfa:	40 93       	lddsp	r3,sp[0x24]
80007bfc:	10 90       	mov	r0,r8
80007bfe:	40 41       	lddsp	r1,sp[0x10]
80007c00:	0e 99       	mov	r9,r7
80007c02:	ed b5 00 03 	bld	r5,0x3
80007c06:	c4 11       	brne	80007c88 <_vfprintf_r+0x7e8>
80007c08:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c0c:	40 3a       	lddsp	r10,sp[0xc]
80007c0e:	58 0a       	cp.w	r10,0
80007c10:	c1 90       	breq	80007c42 <_vfprintf_r+0x7a2>
80007c12:	10 36       	cp.w	r6,r8
80007c14:	c6 45       	brlt	80007cdc <_vfprintf_r+0x83c>
80007c16:	fa c8 f9 50 	sub	r8,sp,-1712
80007c1a:	1a d8       	st.w	--sp,r8
80007c1c:	fa c8 fa b8 	sub	r8,sp,-1352
80007c20:	1a d8       	st.w	--sp,r8
80007c22:	fa c8 fb b4 	sub	r8,sp,-1100
80007c26:	0c 9b       	mov	r11,r6
80007c28:	1a d8       	st.w	--sp,r8
80007c2a:	04 9a       	mov	r10,r2
80007c2c:	fa c8 f9 40 	sub	r8,sp,-1728
80007c30:	fa c9 ff b4 	sub	r9,sp,-76
80007c34:	08 9c       	mov	r12,r4
80007c36:	fe b0 fa 9d 	rcall	80007170 <get_arg>
80007c3a:	2f dd       	sub	sp,-12
80007c3c:	78 16       	ld.w	r6,r12[0x4]
80007c3e:	50 76       	stdsp	sp[0x1c],r6
80007c40:	c4 88       	rjmp	80007cd0 <_vfprintf_r+0x830>
80007c42:	2f f7       	sub	r7,-1
80007c44:	10 39       	cp.w	r9,r8
80007c46:	c0 c4       	brge	80007c5e <_vfprintf_r+0x7be>
80007c48:	fa ce f9 44 	sub	lr,sp,-1724
80007c4c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007c50:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007c54:	50 7c       	stdsp	sp[0x1c],r12
80007c56:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007c5a:	50 56       	stdsp	sp[0x14],r6
80007c5c:	c6 68       	rjmp	80007d28 <_vfprintf_r+0x888>
80007c5e:	41 09       	lddsp	r9,sp[0x40]
80007c60:	59 f8       	cp.w	r8,31
80007c62:	e0 89 00 10 	brgt	80007c82 <_vfprintf_r+0x7e2>
80007c66:	f2 ca ff f8 	sub	r10,r9,-8
80007c6a:	72 1b       	ld.w	r11,r9[0x4]
80007c6c:	51 0a       	stdsp	sp[0x40],r10
80007c6e:	72 09       	ld.w	r9,r9[0x0]
80007c70:	fa ca f9 44 	sub	r10,sp,-1724
80007c74:	50 7b       	stdsp	sp[0x1c],r11
80007c76:	50 59       	stdsp	sp[0x14],r9
80007c78:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007c7c:	40 5b       	lddsp	r11,sp[0x14]
80007c7e:	40 7a       	lddsp	r10,sp[0x1c]
80007c80:	c4 78       	rjmp	80007d0e <_vfprintf_r+0x86e>
80007c82:	72 18       	ld.w	r8,r9[0x4]
80007c84:	50 78       	stdsp	sp[0x1c],r8
80007c86:	c4 c8       	rjmp	80007d1e <_vfprintf_r+0x87e>
80007c88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c8c:	40 3e       	lddsp	lr,sp[0xc]
80007c8e:	58 0e       	cp.w	lr,0
80007c90:	c2 30       	breq	80007cd6 <_vfprintf_r+0x836>
80007c92:	10 36       	cp.w	r6,r8
80007c94:	c0 94       	brge	80007ca6 <_vfprintf_r+0x806>
80007c96:	fa cc f9 44 	sub	r12,sp,-1724
80007c9a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007c9e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007ca2:	50 7b       	stdsp	sp[0x1c],r11
80007ca4:	cd 9b       	rjmp	80007c56 <_vfprintf_r+0x7b6>
80007ca6:	fa c8 f9 50 	sub	r8,sp,-1712
80007caa:	1a d8       	st.w	--sp,r8
80007cac:	fa c8 fa b8 	sub	r8,sp,-1352
80007cb0:	04 9a       	mov	r10,r2
80007cb2:	1a d8       	st.w	--sp,r8
80007cb4:	fa c8 fb b4 	sub	r8,sp,-1100
80007cb8:	0c 9b       	mov	r11,r6
80007cba:	1a d8       	st.w	--sp,r8
80007cbc:	08 9c       	mov	r12,r4
80007cbe:	fa c8 f9 40 	sub	r8,sp,-1728
80007cc2:	fa c9 ff b4 	sub	r9,sp,-76
80007cc6:	fe b0 fa 55 	rcall	80007170 <get_arg>
80007cca:	2f dd       	sub	sp,-12
80007ccc:	78 1a       	ld.w	r10,r12[0x4]
80007cce:	50 7a       	stdsp	sp[0x1c],r10
80007cd0:	78 0c       	ld.w	r12,r12[0x0]
80007cd2:	50 5c       	stdsp	sp[0x14],r12
80007cd4:	c2 a8       	rjmp	80007d28 <_vfprintf_r+0x888>
80007cd6:	2f f7       	sub	r7,-1
80007cd8:	10 39       	cp.w	r9,r8
80007cda:	c0 94       	brge	80007cec <_vfprintf_r+0x84c>
80007cdc:	fa c9 f9 44 	sub	r9,sp,-1724
80007ce0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ce4:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007ce8:	50 78       	stdsp	sp[0x1c],r8
80007cea:	cb 6b       	rjmp	80007c56 <_vfprintf_r+0x7b6>
80007cec:	41 09       	lddsp	r9,sp[0x40]
80007cee:	59 f8       	cp.w	r8,31
80007cf0:	e0 89 00 15 	brgt	80007d1a <_vfprintf_r+0x87a>
80007cf4:	f2 ca ff f8 	sub	r10,r9,-8
80007cf8:	72 16       	ld.w	r6,r9[0x4]
80007cfa:	72 09       	ld.w	r9,r9[0x0]
80007cfc:	51 0a       	stdsp	sp[0x40],r10
80007cfe:	50 59       	stdsp	sp[0x14],r9
80007d00:	fa ce f9 44 	sub	lr,sp,-1724
80007d04:	50 76       	stdsp	sp[0x1c],r6
80007d06:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007d0a:	40 5b       	lddsp	r11,sp[0x14]
80007d0c:	0c 9a       	mov	r10,r6
80007d0e:	f2 eb fd 88 	st.d	r9[-632],r10
80007d12:	2f f8       	sub	r8,-1
80007d14:	fb 48 06 b4 	st.w	sp[1716],r8
80007d18:	c0 88       	rjmp	80007d28 <_vfprintf_r+0x888>
80007d1a:	72 1c       	ld.w	r12,r9[0x4]
80007d1c:	50 7c       	stdsp	sp[0x1c],r12
80007d1e:	f2 c8 ff f8 	sub	r8,r9,-8
80007d22:	51 08       	stdsp	sp[0x40],r8
80007d24:	72 09       	ld.w	r9,r9[0x0]
80007d26:	50 59       	stdsp	sp[0x14],r9
80007d28:	40 5b       	lddsp	r11,sp[0x14]
80007d2a:	40 7a       	lddsp	r10,sp[0x1c]
80007d2c:	e0 a0 19 54 	rcall	8000afd4 <__isinfd>
80007d30:	18 96       	mov	r6,r12
80007d32:	c1 70       	breq	80007d60 <_vfprintf_r+0x8c0>
80007d34:	30 08       	mov	r8,0
80007d36:	30 09       	mov	r9,0
80007d38:	40 5b       	lddsp	r11,sp[0x14]
80007d3a:	40 7a       	lddsp	r10,sp[0x1c]
80007d3c:	e0 a0 1d a8 	rcall	8000b88c <__avr32_f64_cmp_lt>
80007d40:	c0 40       	breq	80007d48 <_vfprintf_r+0x8a8>
80007d42:	32 d8       	mov	r8,45
80007d44:	fb 68 06 bb 	st.b	sp[1723],r8
80007d48:	fe c8 aa f0 	sub	r8,pc,-21776
80007d4c:	fe c6 aa f0 	sub	r6,pc,-21776
80007d50:	a7 d5       	cbr	r5,0x7
80007d52:	e0 40 00 47 	cp.w	r0,71
80007d56:	f0 06 17 a0 	movle	r6,r8
80007d5a:	30 32       	mov	r2,3
80007d5c:	e0 8f 06 ce 	bral	80008af8 <_vfprintf_r+0x1658>
80007d60:	40 5b       	lddsp	r11,sp[0x14]
80007d62:	40 7a       	lddsp	r10,sp[0x1c]
80007d64:	e0 a0 19 4d 	rcall	8000affe <__isnand>
80007d68:	c0 e0       	breq	80007d84 <_vfprintf_r+0x8e4>
80007d6a:	50 26       	stdsp	sp[0x8],r6
80007d6c:	fe c8 ab 0c 	sub	r8,pc,-21748
80007d70:	fe c6 ab 0c 	sub	r6,pc,-21748
80007d74:	a7 d5       	cbr	r5,0x7
80007d76:	e0 40 00 47 	cp.w	r0,71
80007d7a:	f0 06 17 a0 	movle	r6,r8
80007d7e:	30 32       	mov	r2,3
80007d80:	e0 8f 06 c2 	bral	80008b04 <_vfprintf_r+0x1664>
80007d84:	40 2a       	lddsp	r10,sp[0x8]
80007d86:	5b fa       	cp.w	r10,-1
80007d88:	c0 41       	brne	80007d90 <_vfprintf_r+0x8f0>
80007d8a:	30 69       	mov	r9,6
80007d8c:	50 29       	stdsp	sp[0x8],r9
80007d8e:	c1 18       	rjmp	80007db0 <_vfprintf_r+0x910>
80007d90:	e0 40 00 47 	cp.w	r0,71
80007d94:	5f 09       	sreq	r9
80007d96:	e0 40 00 67 	cp.w	r0,103
80007d9a:	5f 08       	sreq	r8
80007d9c:	f3 e8 10 08 	or	r8,r9,r8
80007da0:	f8 08 18 00 	cp.b	r8,r12
80007da4:	c0 60       	breq	80007db0 <_vfprintf_r+0x910>
80007da6:	40 28       	lddsp	r8,sp[0x8]
80007da8:	58 08       	cp.w	r8,0
80007daa:	f9 b8 00 01 	moveq	r8,1
80007dae:	50 28       	stdsp	sp[0x8],r8
80007db0:	40 78       	lddsp	r8,sp[0x1c]
80007db2:	40 59       	lddsp	r9,sp[0x14]
80007db4:	fa e9 06 94 	st.d	sp[1684],r8
80007db8:	a9 a5       	sbr	r5,0x8
80007dba:	fa f8 06 94 	ld.w	r8,sp[1684]
80007dbe:	58 08       	cp.w	r8,0
80007dc0:	c0 65       	brlt	80007dcc <_vfprintf_r+0x92c>
80007dc2:	40 5e       	lddsp	lr,sp[0x14]
80007dc4:	30 0c       	mov	r12,0
80007dc6:	50 6e       	stdsp	sp[0x18],lr
80007dc8:	50 9c       	stdsp	sp[0x24],r12
80007dca:	c0 78       	rjmp	80007dd8 <_vfprintf_r+0x938>
80007dcc:	40 5b       	lddsp	r11,sp[0x14]
80007dce:	32 da       	mov	r10,45
80007dd0:	ee 1b 80 00 	eorh	r11,0x8000
80007dd4:	50 9a       	stdsp	sp[0x24],r10
80007dd6:	50 6b       	stdsp	sp[0x18],r11
80007dd8:	e0 40 00 46 	cp.w	r0,70
80007ddc:	5f 09       	sreq	r9
80007dde:	e0 40 00 66 	cp.w	r0,102
80007de2:	5f 08       	sreq	r8
80007de4:	f3 e8 10 08 	or	r8,r9,r8
80007de8:	50 48       	stdsp	sp[0x10],r8
80007dea:	c0 40       	breq	80007df2 <_vfprintf_r+0x952>
80007dec:	40 22       	lddsp	r2,sp[0x8]
80007dee:	30 39       	mov	r9,3
80007df0:	c1 08       	rjmp	80007e10 <_vfprintf_r+0x970>
80007df2:	e0 40 00 45 	cp.w	r0,69
80007df6:	5f 09       	sreq	r9
80007df8:	e0 40 00 65 	cp.w	r0,101
80007dfc:	5f 08       	sreq	r8
80007dfe:	40 22       	lddsp	r2,sp[0x8]
80007e00:	10 49       	or	r9,r8
80007e02:	2f f2       	sub	r2,-1
80007e04:	40 46       	lddsp	r6,sp[0x10]
80007e06:	ec 09 18 00 	cp.b	r9,r6
80007e0a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80007e0e:	30 29       	mov	r9,2
80007e10:	fa c8 f9 5c 	sub	r8,sp,-1700
80007e14:	1a d8       	st.w	--sp,r8
80007e16:	fa c8 f9 54 	sub	r8,sp,-1708
80007e1a:	1a d8       	st.w	--sp,r8
80007e1c:	fa c8 f9 4c 	sub	r8,sp,-1716
80007e20:	08 9c       	mov	r12,r4
80007e22:	1a d8       	st.w	--sp,r8
80007e24:	04 98       	mov	r8,r2
80007e26:	40 9b       	lddsp	r11,sp[0x24]
80007e28:	40 aa       	lddsp	r10,sp[0x28]
80007e2a:	e0 a0 0b c3 	rcall	800095b0 <_dtoa_r>
80007e2e:	e0 40 00 47 	cp.w	r0,71
80007e32:	5f 19       	srne	r9
80007e34:	e0 40 00 67 	cp.w	r0,103
80007e38:	5f 18       	srne	r8
80007e3a:	18 96       	mov	r6,r12
80007e3c:	2f dd       	sub	sp,-12
80007e3e:	f3 e8 00 08 	and	r8,r9,r8
80007e42:	c0 41       	brne	80007e4a <_vfprintf_r+0x9aa>
80007e44:	ed b5 00 00 	bld	r5,0x0
80007e48:	c3 01       	brne	80007ea8 <_vfprintf_r+0xa08>
80007e4a:	ec 02 00 0e 	add	lr,r6,r2
80007e4e:	50 3e       	stdsp	sp[0xc],lr
80007e50:	40 4c       	lddsp	r12,sp[0x10]
80007e52:	58 0c       	cp.w	r12,0
80007e54:	c1 50       	breq	80007e7e <_vfprintf_r+0x9de>
80007e56:	0d 89       	ld.ub	r9,r6[0x0]
80007e58:	33 08       	mov	r8,48
80007e5a:	f0 09 18 00 	cp.b	r9,r8
80007e5e:	c0 b1       	brne	80007e74 <_vfprintf_r+0x9d4>
80007e60:	30 08       	mov	r8,0
80007e62:	30 09       	mov	r9,0
80007e64:	40 6b       	lddsp	r11,sp[0x18]
80007e66:	40 7a       	lddsp	r10,sp[0x1c]
80007e68:	e0 a0 1c cb 	rcall	8000b7fe <__avr32_f64_cmp_eq>
80007e6c:	fb b2 00 01 	rsubeq	r2,1
80007e70:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80007e74:	40 3b       	lddsp	r11,sp[0xc]
80007e76:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007e7a:	10 0b       	add	r11,r8
80007e7c:	50 3b       	stdsp	sp[0xc],r11
80007e7e:	40 6b       	lddsp	r11,sp[0x18]
80007e80:	30 08       	mov	r8,0
80007e82:	30 09       	mov	r9,0
80007e84:	40 7a       	lddsp	r10,sp[0x1c]
80007e86:	e0 a0 1c bc 	rcall	8000b7fe <__avr32_f64_cmp_eq>
80007e8a:	c0 90       	breq	80007e9c <_vfprintf_r+0x9fc>
80007e8c:	40 3a       	lddsp	r10,sp[0xc]
80007e8e:	fb 4a 06 a4 	st.w	sp[1700],r10
80007e92:	c0 58       	rjmp	80007e9c <_vfprintf_r+0x9fc>
80007e94:	10 c9       	st.b	r8++,r9
80007e96:	fb 48 06 a4 	st.w	sp[1700],r8
80007e9a:	c0 28       	rjmp	80007e9e <_vfprintf_r+0x9fe>
80007e9c:	33 09       	mov	r9,48
80007e9e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007ea2:	40 3e       	lddsp	lr,sp[0xc]
80007ea4:	1c 38       	cp.w	r8,lr
80007ea6:	cf 73       	brcs	80007e94 <_vfprintf_r+0x9f4>
80007ea8:	e0 40 00 47 	cp.w	r0,71
80007eac:	5f 09       	sreq	r9
80007eae:	e0 40 00 67 	cp.w	r0,103
80007eb2:	5f 08       	sreq	r8
80007eb4:	f3 e8 10 08 	or	r8,r9,r8
80007eb8:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007ebc:	0c 19       	sub	r9,r6
80007ebe:	50 69       	stdsp	sp[0x18],r9
80007ec0:	58 08       	cp.w	r8,0
80007ec2:	c0 b0       	breq	80007ed8 <_vfprintf_r+0xa38>
80007ec4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007ec8:	5b d8       	cp.w	r8,-3
80007eca:	c0 55       	brlt	80007ed4 <_vfprintf_r+0xa34>
80007ecc:	40 2c       	lddsp	r12,sp[0x8]
80007ece:	18 38       	cp.w	r8,r12
80007ed0:	e0 8a 00 6a 	brle	80007fa4 <_vfprintf_r+0xb04>
80007ed4:	20 20       	sub	r0,2
80007ed6:	c0 58       	rjmp	80007ee0 <_vfprintf_r+0xa40>
80007ed8:	e0 40 00 65 	cp.w	r0,101
80007edc:	e0 89 00 46 	brgt	80007f68 <_vfprintf_r+0xac8>
80007ee0:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007ee4:	fb 60 06 9c 	st.b	sp[1692],r0
80007ee8:	20 1b       	sub	r11,1
80007eea:	fb 4b 06 ac 	st.w	sp[1708],r11
80007eee:	c0 47       	brpl	80007ef6 <_vfprintf_r+0xa56>
80007ef0:	5c 3b       	neg	r11
80007ef2:	32 d8       	mov	r8,45
80007ef4:	c0 28       	rjmp	80007ef8 <_vfprintf_r+0xa58>
80007ef6:	32 b8       	mov	r8,43
80007ef8:	fb 68 06 9d 	st.b	sp[1693],r8
80007efc:	58 9b       	cp.w	r11,9
80007efe:	e0 8a 00 1d 	brle	80007f38 <_vfprintf_r+0xa98>
80007f02:	fa c9 fa 35 	sub	r9,sp,-1483
80007f06:	30 aa       	mov	r10,10
80007f08:	12 98       	mov	r8,r9
80007f0a:	0e 9c       	mov	r12,r7
80007f0c:	0c 92       	mov	r2,r6
80007f0e:	f6 0a 0c 06 	divs	r6,r11,r10
80007f12:	0e 9b       	mov	r11,r7
80007f14:	2d 0b       	sub	r11,-48
80007f16:	10 fb       	st.b	--r8,r11
80007f18:	0c 9b       	mov	r11,r6
80007f1a:	58 96       	cp.w	r6,9
80007f1c:	fe 99 ff f9 	brgt	80007f0e <_vfprintf_r+0xa6e>
80007f20:	2d 0b       	sub	r11,-48
80007f22:	18 97       	mov	r7,r12
80007f24:	04 96       	mov	r6,r2
80007f26:	10 fb       	st.b	--r8,r11
80007f28:	fa ca f9 62 	sub	r10,sp,-1694
80007f2c:	c0 38       	rjmp	80007f32 <_vfprintf_r+0xa92>
80007f2e:	11 3b       	ld.ub	r11,r8++
80007f30:	14 cb       	st.b	r10++,r11
80007f32:	12 38       	cp.w	r8,r9
80007f34:	cf d3       	brcs	80007f2e <_vfprintf_r+0xa8e>
80007f36:	c0 98       	rjmp	80007f48 <_vfprintf_r+0xaa8>
80007f38:	2d 0b       	sub	r11,-48
80007f3a:	33 08       	mov	r8,48
80007f3c:	fb 6b 06 9f 	st.b	sp[1695],r11
80007f40:	fb 68 06 9e 	st.b	sp[1694],r8
80007f44:	fa ca f9 60 	sub	r10,sp,-1696
80007f48:	fa c8 f9 64 	sub	r8,sp,-1692
80007f4c:	f4 08 01 08 	sub	r8,r10,r8
80007f50:	50 e8       	stdsp	sp[0x38],r8
80007f52:	10 92       	mov	r2,r8
80007f54:	40 6b       	lddsp	r11,sp[0x18]
80007f56:	16 02       	add	r2,r11
80007f58:	58 1b       	cp.w	r11,1
80007f5a:	e0 89 00 05 	brgt	80007f64 <_vfprintf_r+0xac4>
80007f5e:	ed b5 00 00 	bld	r5,0x0
80007f62:	c3 51       	brne	80007fcc <_vfprintf_r+0xb2c>
80007f64:	2f f2       	sub	r2,-1
80007f66:	c3 38       	rjmp	80007fcc <_vfprintf_r+0xb2c>
80007f68:	e0 40 00 66 	cp.w	r0,102
80007f6c:	c1 c1       	brne	80007fa4 <_vfprintf_r+0xb04>
80007f6e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007f72:	58 02       	cp.w	r2,0
80007f74:	e0 8a 00 0c 	brle	80007f8c <_vfprintf_r+0xaec>
80007f78:	40 2a       	lddsp	r10,sp[0x8]
80007f7a:	58 0a       	cp.w	r10,0
80007f7c:	c0 41       	brne	80007f84 <_vfprintf_r+0xae4>
80007f7e:	ed b5 00 00 	bld	r5,0x0
80007f82:	c2 51       	brne	80007fcc <_vfprintf_r+0xb2c>
80007f84:	2f f2       	sub	r2,-1
80007f86:	40 29       	lddsp	r9,sp[0x8]
80007f88:	12 02       	add	r2,r9
80007f8a:	c0 b8       	rjmp	80007fa0 <_vfprintf_r+0xb00>
80007f8c:	40 28       	lddsp	r8,sp[0x8]
80007f8e:	58 08       	cp.w	r8,0
80007f90:	c0 61       	brne	80007f9c <_vfprintf_r+0xafc>
80007f92:	ed b5 00 00 	bld	r5,0x0
80007f96:	c0 30       	breq	80007f9c <_vfprintf_r+0xafc>
80007f98:	30 12       	mov	r2,1
80007f9a:	c1 98       	rjmp	80007fcc <_vfprintf_r+0xb2c>
80007f9c:	40 22       	lddsp	r2,sp[0x8]
80007f9e:	2f e2       	sub	r2,-2
80007fa0:	36 60       	mov	r0,102
80007fa2:	c1 58       	rjmp	80007fcc <_vfprintf_r+0xb2c>
80007fa4:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007fa8:	40 6e       	lddsp	lr,sp[0x18]
80007faa:	1c 32       	cp.w	r2,lr
80007fac:	c0 65       	brlt	80007fb8 <_vfprintf_r+0xb18>
80007fae:	ed b5 00 00 	bld	r5,0x0
80007fb2:	f7 b2 00 ff 	subeq	r2,-1
80007fb6:	c0 a8       	rjmp	80007fca <_vfprintf_r+0xb2a>
80007fb8:	e4 08 11 02 	rsub	r8,r2,2
80007fbc:	40 6c       	lddsp	r12,sp[0x18]
80007fbe:	58 02       	cp.w	r2,0
80007fc0:	f0 02 17 a0 	movle	r2,r8
80007fc4:	f9 b2 09 01 	movgt	r2,1
80007fc8:	18 02       	add	r2,r12
80007fca:	36 70       	mov	r0,103
80007fcc:	40 9b       	lddsp	r11,sp[0x24]
80007fce:	58 0b       	cp.w	r11,0
80007fd0:	e0 80 05 94 	breq	80008af8 <_vfprintf_r+0x1658>
80007fd4:	32 d8       	mov	r8,45
80007fd6:	fb 68 06 bb 	st.b	sp[1723],r8
80007fda:	e0 8f 05 93 	bral	80008b00 <_vfprintf_r+0x1660>
80007fde:	50 a7       	stdsp	sp[0x28],r7
80007fe0:	04 94       	mov	r4,r2
80007fe2:	0c 97       	mov	r7,r6
80007fe4:	02 92       	mov	r2,r1
80007fe6:	06 96       	mov	r6,r3
80007fe8:	40 41       	lddsp	r1,sp[0x10]
80007fea:	40 93       	lddsp	r3,sp[0x24]
80007fec:	0e 99       	mov	r9,r7
80007fee:	ed b5 00 05 	bld	r5,0x5
80007ff2:	c4 81       	brne	80008082 <_vfprintf_r+0xbe2>
80007ff4:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ff8:	40 3e       	lddsp	lr,sp[0xc]
80007ffa:	58 0e       	cp.w	lr,0
80007ffc:	c1 d0       	breq	80008036 <_vfprintf_r+0xb96>
80007ffe:	10 36       	cp.w	r6,r8
80008000:	c0 64       	brge	8000800c <_vfprintf_r+0xb6c>
80008002:	fa cc f9 44 	sub	r12,sp,-1724
80008006:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000800a:	c1 d8       	rjmp	80008044 <_vfprintf_r+0xba4>
8000800c:	fa c8 f9 50 	sub	r8,sp,-1712
80008010:	1a d8       	st.w	--sp,r8
80008012:	fa c8 fa b8 	sub	r8,sp,-1352
80008016:	04 9a       	mov	r10,r2
80008018:	1a d8       	st.w	--sp,r8
8000801a:	fa c8 fb b4 	sub	r8,sp,-1100
8000801e:	0c 9b       	mov	r11,r6
80008020:	1a d8       	st.w	--sp,r8
80008022:	08 9c       	mov	r12,r4
80008024:	fa c8 f9 40 	sub	r8,sp,-1728
80008028:	fa c9 ff b4 	sub	r9,sp,-76
8000802c:	fe b0 f8 a2 	rcall	80007170 <get_arg>
80008030:	2f dd       	sub	sp,-12
80008032:	78 0a       	ld.w	r10,r12[0x0]
80008034:	c2 08       	rjmp	80008074 <_vfprintf_r+0xbd4>
80008036:	2f f7       	sub	r7,-1
80008038:	10 39       	cp.w	r9,r8
8000803a:	c0 84       	brge	8000804a <_vfprintf_r+0xbaa>
8000803c:	fa cb f9 44 	sub	r11,sp,-1724
80008040:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008044:	ec fa fd 88 	ld.w	r10,r6[-632]
80008048:	c1 68       	rjmp	80008074 <_vfprintf_r+0xbd4>
8000804a:	41 09       	lddsp	r9,sp[0x40]
8000804c:	59 f8       	cp.w	r8,31
8000804e:	e0 89 00 10 	brgt	8000806e <_vfprintf_r+0xbce>
80008052:	f2 ca ff fc 	sub	r10,r9,-4
80008056:	51 0a       	stdsp	sp[0x40],r10
80008058:	fa c6 f9 44 	sub	r6,sp,-1724
8000805c:	72 0a       	ld.w	r10,r9[0x0]
8000805e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008062:	f3 4a fd 88 	st.w	r9[-632],r10
80008066:	2f f8       	sub	r8,-1
80008068:	fb 48 06 b4 	st.w	sp[1716],r8
8000806c:	c0 48       	rjmp	80008074 <_vfprintf_r+0xbd4>
8000806e:	72 0a       	ld.w	r10,r9[0x0]
80008070:	2f c9       	sub	r9,-4
80008072:	51 09       	stdsp	sp[0x40],r9
80008074:	40 be       	lddsp	lr,sp[0x2c]
80008076:	1c 98       	mov	r8,lr
80008078:	95 1e       	st.w	r10[0x4],lr
8000807a:	bf 58       	asr	r8,0x1f
8000807c:	95 08       	st.w	r10[0x0],r8
8000807e:	fe 9f fa 9f 	bral	800075bc <_vfprintf_r+0x11c>
80008082:	ed b5 00 04 	bld	r5,0x4
80008086:	c4 80       	breq	80008116 <_vfprintf_r+0xc76>
80008088:	e2 15 00 40 	andl	r5,0x40,COH
8000808c:	c4 50       	breq	80008116 <_vfprintf_r+0xc76>
8000808e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008092:	40 3c       	lddsp	r12,sp[0xc]
80008094:	58 0c       	cp.w	r12,0
80008096:	c1 d0       	breq	800080d0 <_vfprintf_r+0xc30>
80008098:	10 36       	cp.w	r6,r8
8000809a:	c0 64       	brge	800080a6 <_vfprintf_r+0xc06>
8000809c:	fa cb f9 44 	sub	r11,sp,-1724
800080a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800080a4:	c1 d8       	rjmp	800080de <_vfprintf_r+0xc3e>
800080a6:	fa c8 f9 50 	sub	r8,sp,-1712
800080aa:	1a d8       	st.w	--sp,r8
800080ac:	fa c8 fa b8 	sub	r8,sp,-1352
800080b0:	04 9a       	mov	r10,r2
800080b2:	1a d8       	st.w	--sp,r8
800080b4:	fa c8 fb b4 	sub	r8,sp,-1100
800080b8:	0c 9b       	mov	r11,r6
800080ba:	1a d8       	st.w	--sp,r8
800080bc:	08 9c       	mov	r12,r4
800080be:	fa c8 f9 40 	sub	r8,sp,-1728
800080c2:	fa c9 ff b4 	sub	r9,sp,-76
800080c6:	fe b0 f8 55 	rcall	80007170 <get_arg>
800080ca:	2f dd       	sub	sp,-12
800080cc:	78 0a       	ld.w	r10,r12[0x0]
800080ce:	c2 08       	rjmp	8000810e <_vfprintf_r+0xc6e>
800080d0:	2f f7       	sub	r7,-1
800080d2:	10 39       	cp.w	r9,r8
800080d4:	c0 84       	brge	800080e4 <_vfprintf_r+0xc44>
800080d6:	fa ca f9 44 	sub	r10,sp,-1724
800080da:	f4 06 00 36 	add	r6,r10,r6<<0x3
800080de:	ec fa fd 88 	ld.w	r10,r6[-632]
800080e2:	c1 68       	rjmp	8000810e <_vfprintf_r+0xc6e>
800080e4:	41 09       	lddsp	r9,sp[0x40]
800080e6:	59 f8       	cp.w	r8,31
800080e8:	e0 89 00 10 	brgt	80008108 <_vfprintf_r+0xc68>
800080ec:	f2 ca ff fc 	sub	r10,r9,-4
800080f0:	51 0a       	stdsp	sp[0x40],r10
800080f2:	fa c6 f9 44 	sub	r6,sp,-1724
800080f6:	72 0a       	ld.w	r10,r9[0x0]
800080f8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800080fc:	f3 4a fd 88 	st.w	r9[-632],r10
80008100:	2f f8       	sub	r8,-1
80008102:	fb 48 06 b4 	st.w	sp[1716],r8
80008106:	c0 48       	rjmp	8000810e <_vfprintf_r+0xc6e>
80008108:	72 0a       	ld.w	r10,r9[0x0]
8000810a:	2f c9       	sub	r9,-4
8000810c:	51 09       	stdsp	sp[0x40],r9
8000810e:	40 be       	lddsp	lr,sp[0x2c]
80008110:	b4 0e       	st.h	r10[0x0],lr
80008112:	fe 9f fa 55 	bral	800075bc <_vfprintf_r+0x11c>
80008116:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000811a:	40 3c       	lddsp	r12,sp[0xc]
8000811c:	58 0c       	cp.w	r12,0
8000811e:	c1 d0       	breq	80008158 <_vfprintf_r+0xcb8>
80008120:	10 36       	cp.w	r6,r8
80008122:	c0 64       	brge	8000812e <_vfprintf_r+0xc8e>
80008124:	fa cb f9 44 	sub	r11,sp,-1724
80008128:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000812c:	c1 d8       	rjmp	80008166 <_vfprintf_r+0xcc6>
8000812e:	fa c8 f9 50 	sub	r8,sp,-1712
80008132:	1a d8       	st.w	--sp,r8
80008134:	fa c8 fa b8 	sub	r8,sp,-1352
80008138:	04 9a       	mov	r10,r2
8000813a:	1a d8       	st.w	--sp,r8
8000813c:	fa c8 fb b4 	sub	r8,sp,-1100
80008140:	0c 9b       	mov	r11,r6
80008142:	1a d8       	st.w	--sp,r8
80008144:	08 9c       	mov	r12,r4
80008146:	fa c8 f9 40 	sub	r8,sp,-1728
8000814a:	fa c9 ff b4 	sub	r9,sp,-76
8000814e:	fe b0 f8 11 	rcall	80007170 <get_arg>
80008152:	2f dd       	sub	sp,-12
80008154:	78 0a       	ld.w	r10,r12[0x0]
80008156:	c2 08       	rjmp	80008196 <_vfprintf_r+0xcf6>
80008158:	2f f7       	sub	r7,-1
8000815a:	10 39       	cp.w	r9,r8
8000815c:	c0 84       	brge	8000816c <_vfprintf_r+0xccc>
8000815e:	fa ca f9 44 	sub	r10,sp,-1724
80008162:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008166:	ec fa fd 88 	ld.w	r10,r6[-632]
8000816a:	c1 68       	rjmp	80008196 <_vfprintf_r+0xcf6>
8000816c:	41 09       	lddsp	r9,sp[0x40]
8000816e:	59 f8       	cp.w	r8,31
80008170:	e0 89 00 10 	brgt	80008190 <_vfprintf_r+0xcf0>
80008174:	f2 ca ff fc 	sub	r10,r9,-4
80008178:	51 0a       	stdsp	sp[0x40],r10
8000817a:	fa c6 f9 44 	sub	r6,sp,-1724
8000817e:	72 0a       	ld.w	r10,r9[0x0]
80008180:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008184:	f3 4a fd 88 	st.w	r9[-632],r10
80008188:	2f f8       	sub	r8,-1
8000818a:	fb 48 06 b4 	st.w	sp[1716],r8
8000818e:	c0 48       	rjmp	80008196 <_vfprintf_r+0xcf6>
80008190:	72 0a       	ld.w	r10,r9[0x0]
80008192:	2f c9       	sub	r9,-4
80008194:	51 09       	stdsp	sp[0x40],r9
80008196:	40 be       	lddsp	lr,sp[0x2c]
80008198:	95 0e       	st.w	r10[0x0],lr
8000819a:	fe 9f fa 11 	bral	800075bc <_vfprintf_r+0x11c>
8000819e:	50 a7       	stdsp	sp[0x28],r7
800081a0:	50 80       	stdsp	sp[0x20],r0
800081a2:	0c 97       	mov	r7,r6
800081a4:	04 94       	mov	r4,r2
800081a6:	06 96       	mov	r6,r3
800081a8:	02 92       	mov	r2,r1
800081aa:	40 93       	lddsp	r3,sp[0x24]
800081ac:	10 90       	mov	r0,r8
800081ae:	40 41       	lddsp	r1,sp[0x10]
800081b0:	a5 a5       	sbr	r5,0x4
800081b2:	c0 a8       	rjmp	800081c6 <_vfprintf_r+0xd26>
800081b4:	50 a7       	stdsp	sp[0x28],r7
800081b6:	50 80       	stdsp	sp[0x20],r0
800081b8:	0c 97       	mov	r7,r6
800081ba:	04 94       	mov	r4,r2
800081bc:	06 96       	mov	r6,r3
800081be:	02 92       	mov	r2,r1
800081c0:	40 93       	lddsp	r3,sp[0x24]
800081c2:	10 90       	mov	r0,r8
800081c4:	40 41       	lddsp	r1,sp[0x10]
800081c6:	ed b5 00 05 	bld	r5,0x5
800081ca:	c5 d1       	brne	80008284 <_vfprintf_r+0xde4>
800081cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081d0:	40 3c       	lddsp	r12,sp[0xc]
800081d2:	58 0c       	cp.w	r12,0
800081d4:	c2 60       	breq	80008220 <_vfprintf_r+0xd80>
800081d6:	10 36       	cp.w	r6,r8
800081d8:	c0 a4       	brge	800081ec <_vfprintf_r+0xd4c>
800081da:	fa cb f9 44 	sub	r11,sp,-1724
800081de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081e2:	ec e8 fd 88 	ld.d	r8,r6[-632]
800081e6:	fa e9 00 00 	st.d	sp[0],r8
800081ea:	c1 88       	rjmp	8000821a <_vfprintf_r+0xd7a>
800081ec:	fa c8 f9 50 	sub	r8,sp,-1712
800081f0:	1a d8       	st.w	--sp,r8
800081f2:	fa c8 fa b8 	sub	r8,sp,-1352
800081f6:	04 9a       	mov	r10,r2
800081f8:	1a d8       	st.w	--sp,r8
800081fa:	0c 9b       	mov	r11,r6
800081fc:	fa c8 fb b4 	sub	r8,sp,-1100
80008200:	08 9c       	mov	r12,r4
80008202:	1a d8       	st.w	--sp,r8
80008204:	fa c8 f9 40 	sub	r8,sp,-1728
80008208:	fa c9 ff b4 	sub	r9,sp,-76
8000820c:	fe b0 f7 b2 	rcall	80007170 <get_arg>
80008210:	2f dd       	sub	sp,-12
80008212:	f8 ea 00 00 	ld.d	r10,r12[0]
80008216:	fa eb 00 00 	st.d	sp[0],r10
8000821a:	30 08       	mov	r8,0
8000821c:	e0 8f 03 de 	bral	800089d8 <_vfprintf_r+0x1538>
80008220:	ee ca ff ff 	sub	r10,r7,-1
80008224:	10 37       	cp.w	r7,r8
80008226:	c0 b4       	brge	8000823c <_vfprintf_r+0xd9c>
80008228:	fa c9 f9 44 	sub	r9,sp,-1724
8000822c:	14 97       	mov	r7,r10
8000822e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008232:	ec ea fd 88 	ld.d	r10,r6[-632]
80008236:	fa eb 00 00 	st.d	sp[0],r10
8000823a:	c1 88       	rjmp	8000826a <_vfprintf_r+0xdca>
8000823c:	41 09       	lddsp	r9,sp[0x40]
8000823e:	59 f8       	cp.w	r8,31
80008240:	e0 89 00 18 	brgt	80008270 <_vfprintf_r+0xdd0>
80008244:	f2 e6 00 00 	ld.d	r6,r9[0]
80008248:	f2 cb ff f8 	sub	r11,r9,-8
8000824c:	fa e7 00 00 	st.d	sp[0],r6
80008250:	51 0b       	stdsp	sp[0x40],r11
80008252:	fa c6 f9 44 	sub	r6,sp,-1724
80008256:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000825a:	fa e6 00 00 	ld.d	r6,sp[0]
8000825e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008262:	2f f8       	sub	r8,-1
80008264:	14 97       	mov	r7,r10
80008266:	fb 48 06 b4 	st.w	sp[1716],r8
8000826a:	40 38       	lddsp	r8,sp[0xc]
8000826c:	e0 8f 03 b6 	bral	800089d8 <_vfprintf_r+0x1538>
80008270:	f2 e6 00 00 	ld.d	r6,r9[0]
80008274:	40 38       	lddsp	r8,sp[0xc]
80008276:	fa e7 00 00 	st.d	sp[0],r6
8000827a:	2f 89       	sub	r9,-8
8000827c:	14 97       	mov	r7,r10
8000827e:	51 09       	stdsp	sp[0x40],r9
80008280:	e0 8f 03 ac 	bral	800089d8 <_vfprintf_r+0x1538>
80008284:	ed b5 00 04 	bld	r5,0x4
80008288:	c1 61       	brne	800082b4 <_vfprintf_r+0xe14>
8000828a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000828e:	40 3e       	lddsp	lr,sp[0xc]
80008290:	58 0e       	cp.w	lr,0
80008292:	c0 80       	breq	800082a2 <_vfprintf_r+0xe02>
80008294:	10 36       	cp.w	r6,r8
80008296:	c6 74       	brge	80008364 <_vfprintf_r+0xec4>
80008298:	fa cc f9 44 	sub	r12,sp,-1724
8000829c:	f8 06 00 36 	add	r6,r12,r6<<0x3
800082a0:	c8 08       	rjmp	800083a0 <_vfprintf_r+0xf00>
800082a2:	ee ca ff ff 	sub	r10,r7,-1
800082a6:	10 37       	cp.w	r7,r8
800082a8:	c7 f4       	brge	800083a6 <_vfprintf_r+0xf06>
800082aa:	fa cb f9 44 	sub	r11,sp,-1724
800082ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082b2:	c7 68       	rjmp	8000839e <_vfprintf_r+0xefe>
800082b4:	ed b5 00 06 	bld	r5,0x6
800082b8:	c4 a1       	brne	8000834c <_vfprintf_r+0xeac>
800082ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800082be:	40 3c       	lddsp	r12,sp[0xc]
800082c0:	58 0c       	cp.w	r12,0
800082c2:	c1 d0       	breq	800082fc <_vfprintf_r+0xe5c>
800082c4:	10 36       	cp.w	r6,r8
800082c6:	c0 64       	brge	800082d2 <_vfprintf_r+0xe32>
800082c8:	fa cb f9 44 	sub	r11,sp,-1724
800082cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082d0:	c1 f8       	rjmp	8000830e <_vfprintf_r+0xe6e>
800082d2:	fa c8 f9 50 	sub	r8,sp,-1712
800082d6:	1a d8       	st.w	--sp,r8
800082d8:	fa c8 fa b8 	sub	r8,sp,-1352
800082dc:	1a d8       	st.w	--sp,r8
800082de:	fa c8 fb b4 	sub	r8,sp,-1100
800082e2:	1a d8       	st.w	--sp,r8
800082e4:	fa c8 f9 40 	sub	r8,sp,-1728
800082e8:	fa c9 ff b4 	sub	r9,sp,-76
800082ec:	04 9a       	mov	r10,r2
800082ee:	0c 9b       	mov	r11,r6
800082f0:	08 9c       	mov	r12,r4
800082f2:	fe b0 f7 3f 	rcall	80007170 <get_arg>
800082f6:	2f dd       	sub	sp,-12
800082f8:	98 18       	ld.sh	r8,r12[0x2]
800082fa:	c2 68       	rjmp	80008346 <_vfprintf_r+0xea6>
800082fc:	ee ca ff ff 	sub	r10,r7,-1
80008300:	10 37       	cp.w	r7,r8
80008302:	c0 94       	brge	80008314 <_vfprintf_r+0xe74>
80008304:	fa c9 f9 44 	sub	r9,sp,-1724
80008308:	14 97       	mov	r7,r10
8000830a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000830e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008312:	c1 a8       	rjmp	80008346 <_vfprintf_r+0xea6>
80008314:	41 09       	lddsp	r9,sp[0x40]
80008316:	59 f8       	cp.w	r8,31
80008318:	e0 89 00 13 	brgt	8000833e <_vfprintf_r+0xe9e>
8000831c:	f2 cb ff fc 	sub	r11,r9,-4
80008320:	51 0b       	stdsp	sp[0x40],r11
80008322:	72 09       	ld.w	r9,r9[0x0]
80008324:	fa c6 f9 44 	sub	r6,sp,-1724
80008328:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000832c:	2f f8       	sub	r8,-1
8000832e:	f7 49 fd 88 	st.w	r11[-632],r9
80008332:	fb 48 06 b4 	st.w	sp[1716],r8
80008336:	14 97       	mov	r7,r10
80008338:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000833c:	c0 58       	rjmp	80008346 <_vfprintf_r+0xea6>
8000833e:	92 18       	ld.sh	r8,r9[0x2]
80008340:	14 97       	mov	r7,r10
80008342:	2f c9       	sub	r9,-4
80008344:	51 09       	stdsp	sp[0x40],r9
80008346:	5c 78       	castu.h	r8
80008348:	50 18       	stdsp	sp[0x4],r8
8000834a:	c4 68       	rjmp	800083d6 <_vfprintf_r+0xf36>
8000834c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008350:	40 3c       	lddsp	r12,sp[0xc]
80008352:	58 0c       	cp.w	r12,0
80008354:	c1 d0       	breq	8000838e <_vfprintf_r+0xeee>
80008356:	10 36       	cp.w	r6,r8
80008358:	c0 64       	brge	80008364 <_vfprintf_r+0xec4>
8000835a:	fa cb f9 44 	sub	r11,sp,-1724
8000835e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008362:	c1 f8       	rjmp	800083a0 <_vfprintf_r+0xf00>
80008364:	fa c8 f9 50 	sub	r8,sp,-1712
80008368:	1a d8       	st.w	--sp,r8
8000836a:	fa c8 fa b8 	sub	r8,sp,-1352
8000836e:	0c 9b       	mov	r11,r6
80008370:	1a d8       	st.w	--sp,r8
80008372:	fa c8 fb b4 	sub	r8,sp,-1100
80008376:	04 9a       	mov	r10,r2
80008378:	1a d8       	st.w	--sp,r8
8000837a:	08 9c       	mov	r12,r4
8000837c:	fa c8 f9 40 	sub	r8,sp,-1728
80008380:	fa c9 ff b4 	sub	r9,sp,-76
80008384:	fe b0 f6 f6 	rcall	80007170 <get_arg>
80008388:	2f dd       	sub	sp,-12
8000838a:	78 0b       	ld.w	r11,r12[0x0]
8000838c:	c2 48       	rjmp	800083d4 <_vfprintf_r+0xf34>
8000838e:	ee ca ff ff 	sub	r10,r7,-1
80008392:	10 37       	cp.w	r7,r8
80008394:	c0 94       	brge	800083a6 <_vfprintf_r+0xf06>
80008396:	fa c9 f9 44 	sub	r9,sp,-1724
8000839a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000839e:	14 97       	mov	r7,r10
800083a0:	ec fb fd 88 	ld.w	r11,r6[-632]
800083a4:	c1 88       	rjmp	800083d4 <_vfprintf_r+0xf34>
800083a6:	41 09       	lddsp	r9,sp[0x40]
800083a8:	59 f8       	cp.w	r8,31
800083aa:	e0 89 00 11 	brgt	800083cc <_vfprintf_r+0xf2c>
800083ae:	f2 cb ff fc 	sub	r11,r9,-4
800083b2:	51 0b       	stdsp	sp[0x40],r11
800083b4:	fa c6 f9 44 	sub	r6,sp,-1724
800083b8:	72 0b       	ld.w	r11,r9[0x0]
800083ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
800083be:	f3 4b fd 88 	st.w	r9[-632],r11
800083c2:	2f f8       	sub	r8,-1
800083c4:	14 97       	mov	r7,r10
800083c6:	fb 48 06 b4 	st.w	sp[1716],r8
800083ca:	c0 58       	rjmp	800083d4 <_vfprintf_r+0xf34>
800083cc:	72 0b       	ld.w	r11,r9[0x0]
800083ce:	14 97       	mov	r7,r10
800083d0:	2f c9       	sub	r9,-4
800083d2:	51 09       	stdsp	sp[0x40],r9
800083d4:	50 1b       	stdsp	sp[0x4],r11
800083d6:	30 0e       	mov	lr,0
800083d8:	50 0e       	stdsp	sp[0x0],lr
800083da:	1c 98       	mov	r8,lr
800083dc:	e0 8f 02 fe 	bral	800089d8 <_vfprintf_r+0x1538>
800083e0:	50 a7       	stdsp	sp[0x28],r7
800083e2:	50 80       	stdsp	sp[0x20],r0
800083e4:	0c 97       	mov	r7,r6
800083e6:	04 94       	mov	r4,r2
800083e8:	06 96       	mov	r6,r3
800083ea:	02 92       	mov	r2,r1
800083ec:	40 93       	lddsp	r3,sp[0x24]
800083ee:	40 41       	lddsp	r1,sp[0x10]
800083f0:	0e 99       	mov	r9,r7
800083f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083f6:	40 3c       	lddsp	r12,sp[0xc]
800083f8:	58 0c       	cp.w	r12,0
800083fa:	c1 d0       	breq	80008434 <_vfprintf_r+0xf94>
800083fc:	10 36       	cp.w	r6,r8
800083fe:	c0 64       	brge	8000840a <_vfprintf_r+0xf6a>
80008400:	fa cb f9 44 	sub	r11,sp,-1724
80008404:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008408:	c1 d8       	rjmp	80008442 <_vfprintf_r+0xfa2>
8000840a:	fa c8 f9 50 	sub	r8,sp,-1712
8000840e:	1a d8       	st.w	--sp,r8
80008410:	fa c8 fa b8 	sub	r8,sp,-1352
80008414:	1a d8       	st.w	--sp,r8
80008416:	fa c8 fb b4 	sub	r8,sp,-1100
8000841a:	1a d8       	st.w	--sp,r8
8000841c:	fa c9 ff b4 	sub	r9,sp,-76
80008420:	fa c8 f9 40 	sub	r8,sp,-1728
80008424:	04 9a       	mov	r10,r2
80008426:	0c 9b       	mov	r11,r6
80008428:	08 9c       	mov	r12,r4
8000842a:	fe b0 f6 a3 	rcall	80007170 <get_arg>
8000842e:	2f dd       	sub	sp,-12
80008430:	78 09       	ld.w	r9,r12[0x0]
80008432:	c2 18       	rjmp	80008474 <_vfprintf_r+0xfd4>
80008434:	2f f7       	sub	r7,-1
80008436:	10 39       	cp.w	r9,r8
80008438:	c0 84       	brge	80008448 <_vfprintf_r+0xfa8>
8000843a:	fa ca f9 44 	sub	r10,sp,-1724
8000843e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008442:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008446:	c1 78       	rjmp	80008474 <_vfprintf_r+0xfd4>
80008448:	41 09       	lddsp	r9,sp[0x40]
8000844a:	59 f8       	cp.w	r8,31
8000844c:	e0 89 00 10 	brgt	8000846c <_vfprintf_r+0xfcc>
80008450:	f2 ca ff fc 	sub	r10,r9,-4
80008454:	51 0a       	stdsp	sp[0x40],r10
80008456:	fa c6 f9 44 	sub	r6,sp,-1724
8000845a:	72 09       	ld.w	r9,r9[0x0]
8000845c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008460:	f5 49 fd 88 	st.w	r10[-632],r9
80008464:	2f f8       	sub	r8,-1
80008466:	fb 48 06 b4 	st.w	sp[1716],r8
8000846a:	c0 58       	rjmp	80008474 <_vfprintf_r+0xfd4>
8000846c:	f2 c8 ff fc 	sub	r8,r9,-4
80008470:	51 08       	stdsp	sp[0x40],r8
80008472:	72 09       	ld.w	r9,r9[0x0]
80008474:	33 08       	mov	r8,48
80008476:	fb 68 06 b8 	st.b	sp[1720],r8
8000847a:	37 88       	mov	r8,120
8000847c:	30 0e       	mov	lr,0
8000847e:	fb 68 06 b9 	st.b	sp[1721],r8
80008482:	fe cc b2 1a 	sub	r12,pc,-19942
80008486:	50 19       	stdsp	sp[0x4],r9
80008488:	a1 b5       	sbr	r5,0x1
8000848a:	50 0e       	stdsp	sp[0x0],lr
8000848c:	50 dc       	stdsp	sp[0x34],r12
8000848e:	30 28       	mov	r8,2
80008490:	37 80       	mov	r0,120
80008492:	e0 8f 02 a3 	bral	800089d8 <_vfprintf_r+0x1538>
80008496:	50 a7       	stdsp	sp[0x28],r7
80008498:	50 80       	stdsp	sp[0x20],r0
8000849a:	10 90       	mov	r0,r8
8000849c:	30 08       	mov	r8,0
8000849e:	fb 68 06 bb 	st.b	sp[1723],r8
800084a2:	0c 97       	mov	r7,r6
800084a4:	04 94       	mov	r4,r2
800084a6:	06 96       	mov	r6,r3
800084a8:	02 92       	mov	r2,r1
800084aa:	40 93       	lddsp	r3,sp[0x24]
800084ac:	40 41       	lddsp	r1,sp[0x10]
800084ae:	0e 99       	mov	r9,r7
800084b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084b4:	40 3b       	lddsp	r11,sp[0xc]
800084b6:	58 0b       	cp.w	r11,0
800084b8:	c1 d0       	breq	800084f2 <_vfprintf_r+0x1052>
800084ba:	10 36       	cp.w	r6,r8
800084bc:	c0 64       	brge	800084c8 <_vfprintf_r+0x1028>
800084be:	fa ca f9 44 	sub	r10,sp,-1724
800084c2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800084c6:	c1 d8       	rjmp	80008500 <_vfprintf_r+0x1060>
800084c8:	fa c8 f9 50 	sub	r8,sp,-1712
800084cc:	1a d8       	st.w	--sp,r8
800084ce:	fa c8 fa b8 	sub	r8,sp,-1352
800084d2:	1a d8       	st.w	--sp,r8
800084d4:	fa c8 fb b4 	sub	r8,sp,-1100
800084d8:	0c 9b       	mov	r11,r6
800084da:	1a d8       	st.w	--sp,r8
800084dc:	04 9a       	mov	r10,r2
800084de:	fa c8 f9 40 	sub	r8,sp,-1728
800084e2:	fa c9 ff b4 	sub	r9,sp,-76
800084e6:	08 9c       	mov	r12,r4
800084e8:	fe b0 f6 44 	rcall	80007170 <get_arg>
800084ec:	2f dd       	sub	sp,-12
800084ee:	78 06       	ld.w	r6,r12[0x0]
800084f0:	c2 08       	rjmp	80008530 <_vfprintf_r+0x1090>
800084f2:	2f f7       	sub	r7,-1
800084f4:	10 39       	cp.w	r9,r8
800084f6:	c0 84       	brge	80008506 <_vfprintf_r+0x1066>
800084f8:	fa c9 f9 44 	sub	r9,sp,-1724
800084fc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008500:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008504:	c1 68       	rjmp	80008530 <_vfprintf_r+0x1090>
80008506:	41 09       	lddsp	r9,sp[0x40]
80008508:	59 f8       	cp.w	r8,31
8000850a:	e0 89 00 10 	brgt	8000852a <_vfprintf_r+0x108a>
8000850e:	f2 ca ff fc 	sub	r10,r9,-4
80008512:	51 0a       	stdsp	sp[0x40],r10
80008514:	72 06       	ld.w	r6,r9[0x0]
80008516:	fa ce f9 44 	sub	lr,sp,-1724
8000851a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000851e:	f3 46 fd 88 	st.w	r9[-632],r6
80008522:	2f f8       	sub	r8,-1
80008524:	fb 48 06 b4 	st.w	sp[1716],r8
80008528:	c0 48       	rjmp	80008530 <_vfprintf_r+0x1090>
8000852a:	72 06       	ld.w	r6,r9[0x0]
8000852c:	2f c9       	sub	r9,-4
8000852e:	51 09       	stdsp	sp[0x40],r9
80008530:	40 2c       	lddsp	r12,sp[0x8]
80008532:	58 0c       	cp.w	r12,0
80008534:	c1 05       	brlt	80008554 <_vfprintf_r+0x10b4>
80008536:	18 9a       	mov	r10,r12
80008538:	30 0b       	mov	r11,0
8000853a:	0c 9c       	mov	r12,r6
8000853c:	e0 a0 12 38 	rcall	8000a9ac <memchr>
80008540:	e0 80 02 df 	breq	80008afe <_vfprintf_r+0x165e>
80008544:	f8 06 01 02 	sub	r2,r12,r6
80008548:	40 2b       	lddsp	r11,sp[0x8]
8000854a:	16 32       	cp.w	r2,r11
8000854c:	e0 89 02 d9 	brgt	80008afe <_vfprintf_r+0x165e>
80008550:	e0 8f 02 d4 	bral	80008af8 <_vfprintf_r+0x1658>
80008554:	30 0a       	mov	r10,0
80008556:	0c 9c       	mov	r12,r6
80008558:	50 2a       	stdsp	sp[0x8],r10
8000855a:	fe b0 f5 85 	rcall	80007064 <strlen>
8000855e:	18 92       	mov	r2,r12
80008560:	e0 8f 02 d2 	bral	80008b04 <_vfprintf_r+0x1664>
80008564:	50 a7       	stdsp	sp[0x28],r7
80008566:	50 80       	stdsp	sp[0x20],r0
80008568:	0c 97       	mov	r7,r6
8000856a:	04 94       	mov	r4,r2
8000856c:	06 96       	mov	r6,r3
8000856e:	02 92       	mov	r2,r1
80008570:	40 93       	lddsp	r3,sp[0x24]
80008572:	10 90       	mov	r0,r8
80008574:	40 41       	lddsp	r1,sp[0x10]
80008576:	a5 a5       	sbr	r5,0x4
80008578:	c0 a8       	rjmp	8000858c <_vfprintf_r+0x10ec>
8000857a:	50 a7       	stdsp	sp[0x28],r7
8000857c:	50 80       	stdsp	sp[0x20],r0
8000857e:	0c 97       	mov	r7,r6
80008580:	04 94       	mov	r4,r2
80008582:	06 96       	mov	r6,r3
80008584:	02 92       	mov	r2,r1
80008586:	40 93       	lddsp	r3,sp[0x24]
80008588:	10 90       	mov	r0,r8
8000858a:	40 41       	lddsp	r1,sp[0x10]
8000858c:	ed b5 00 05 	bld	r5,0x5
80008590:	c5 61       	brne	8000863c <_vfprintf_r+0x119c>
80008592:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008596:	40 39       	lddsp	r9,sp[0xc]
80008598:	58 09       	cp.w	r9,0
8000859a:	c2 10       	breq	800085dc <_vfprintf_r+0x113c>
8000859c:	10 36       	cp.w	r6,r8
8000859e:	c0 74       	brge	800085ac <_vfprintf_r+0x110c>
800085a0:	fa c8 f9 44 	sub	r8,sp,-1724
800085a4:	f0 06 00 36 	add	r6,r8,r6<<0x3
800085a8:	c2 38       	rjmp	800085ee <_vfprintf_r+0x114e>
800085aa:	d7 03       	nop
800085ac:	fa c8 f9 50 	sub	r8,sp,-1712
800085b0:	1a d8       	st.w	--sp,r8
800085b2:	fa c8 fa b8 	sub	r8,sp,-1352
800085b6:	1a d8       	st.w	--sp,r8
800085b8:	fa c8 fb b4 	sub	r8,sp,-1100
800085bc:	1a d8       	st.w	--sp,r8
800085be:	fa c8 f9 40 	sub	r8,sp,-1728
800085c2:	fa c9 ff b4 	sub	r9,sp,-76
800085c6:	04 9a       	mov	r10,r2
800085c8:	0c 9b       	mov	r11,r6
800085ca:	08 9c       	mov	r12,r4
800085cc:	fe b0 f5 d2 	rcall	80007170 <get_arg>
800085d0:	2f dd       	sub	sp,-12
800085d2:	f8 e8 00 00 	ld.d	r8,r12[0]
800085d6:	fa e9 00 00 	st.d	sp[0],r8
800085da:	c2 e8       	rjmp	80008636 <_vfprintf_r+0x1196>
800085dc:	ee ca ff ff 	sub	r10,r7,-1
800085e0:	10 37       	cp.w	r7,r8
800085e2:	c0 b4       	brge	800085f8 <_vfprintf_r+0x1158>
800085e4:	fa c8 f9 44 	sub	r8,sp,-1724
800085e8:	14 97       	mov	r7,r10
800085ea:	f0 06 00 36 	add	r6,r8,r6<<0x3
800085ee:	ec ea fd 88 	ld.d	r10,r6[-632]
800085f2:	fa eb 00 00 	st.d	sp[0],r10
800085f6:	c2 08       	rjmp	80008636 <_vfprintf_r+0x1196>
800085f8:	41 09       	lddsp	r9,sp[0x40]
800085fa:	59 f8       	cp.w	r8,31
800085fc:	e0 89 00 16 	brgt	80008628 <_vfprintf_r+0x1188>
80008600:	f2 e6 00 00 	ld.d	r6,r9[0]
80008604:	f2 cb ff f8 	sub	r11,r9,-8
80008608:	fa e7 00 00 	st.d	sp[0],r6
8000860c:	51 0b       	stdsp	sp[0x40],r11
8000860e:	fa c6 f9 44 	sub	r6,sp,-1724
80008612:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008616:	fa e6 00 00 	ld.d	r6,sp[0]
8000861a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000861e:	2f f8       	sub	r8,-1
80008620:	14 97       	mov	r7,r10
80008622:	fb 48 06 b4 	st.w	sp[1716],r8
80008626:	c0 88       	rjmp	80008636 <_vfprintf_r+0x1196>
80008628:	f2 e6 00 00 	ld.d	r6,r9[0]
8000862c:	2f 89       	sub	r9,-8
8000862e:	fa e7 00 00 	st.d	sp[0],r6
80008632:	51 09       	stdsp	sp[0x40],r9
80008634:	14 97       	mov	r7,r10
80008636:	30 18       	mov	r8,1
80008638:	e0 8f 01 d0 	bral	800089d8 <_vfprintf_r+0x1538>
8000863c:	ed b5 00 04 	bld	r5,0x4
80008640:	c1 61       	brne	8000866c <_vfprintf_r+0x11cc>
80008642:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008646:	40 3e       	lddsp	lr,sp[0xc]
80008648:	58 0e       	cp.w	lr,0
8000864a:	c0 80       	breq	8000865a <_vfprintf_r+0x11ba>
8000864c:	10 36       	cp.w	r6,r8
8000864e:	c6 74       	brge	8000871c <_vfprintf_r+0x127c>
80008650:	fa cc f9 44 	sub	r12,sp,-1724
80008654:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008658:	c8 08       	rjmp	80008758 <_vfprintf_r+0x12b8>
8000865a:	ee ca ff ff 	sub	r10,r7,-1
8000865e:	10 37       	cp.w	r7,r8
80008660:	c7 f4       	brge	8000875e <_vfprintf_r+0x12be>
80008662:	fa cb f9 44 	sub	r11,sp,-1724
80008666:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000866a:	c7 68       	rjmp	80008756 <_vfprintf_r+0x12b6>
8000866c:	ed b5 00 06 	bld	r5,0x6
80008670:	c4 a1       	brne	80008704 <_vfprintf_r+0x1264>
80008672:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008676:	40 3c       	lddsp	r12,sp[0xc]
80008678:	58 0c       	cp.w	r12,0
8000867a:	c1 d0       	breq	800086b4 <_vfprintf_r+0x1214>
8000867c:	10 36       	cp.w	r6,r8
8000867e:	c0 64       	brge	8000868a <_vfprintf_r+0x11ea>
80008680:	fa cb f9 44 	sub	r11,sp,-1724
80008684:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008688:	c1 f8       	rjmp	800086c6 <_vfprintf_r+0x1226>
8000868a:	fa c8 f9 50 	sub	r8,sp,-1712
8000868e:	1a d8       	st.w	--sp,r8
80008690:	fa c8 fa b8 	sub	r8,sp,-1352
80008694:	1a d8       	st.w	--sp,r8
80008696:	fa c8 fb b4 	sub	r8,sp,-1100
8000869a:	1a d8       	st.w	--sp,r8
8000869c:	fa c8 f9 40 	sub	r8,sp,-1728
800086a0:	fa c9 ff b4 	sub	r9,sp,-76
800086a4:	04 9a       	mov	r10,r2
800086a6:	0c 9b       	mov	r11,r6
800086a8:	08 9c       	mov	r12,r4
800086aa:	fe b0 f5 63 	rcall	80007170 <get_arg>
800086ae:	2f dd       	sub	sp,-12
800086b0:	98 18       	ld.sh	r8,r12[0x2]
800086b2:	c2 68       	rjmp	800086fe <_vfprintf_r+0x125e>
800086b4:	ee ca ff ff 	sub	r10,r7,-1
800086b8:	10 37       	cp.w	r7,r8
800086ba:	c0 94       	brge	800086cc <_vfprintf_r+0x122c>
800086bc:	fa c9 f9 44 	sub	r9,sp,-1724
800086c0:	14 97       	mov	r7,r10
800086c2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800086c6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800086ca:	c1 a8       	rjmp	800086fe <_vfprintf_r+0x125e>
800086cc:	41 09       	lddsp	r9,sp[0x40]
800086ce:	59 f8       	cp.w	r8,31
800086d0:	e0 89 00 13 	brgt	800086f6 <_vfprintf_r+0x1256>
800086d4:	f2 cb ff fc 	sub	r11,r9,-4
800086d8:	51 0b       	stdsp	sp[0x40],r11
800086da:	72 09       	ld.w	r9,r9[0x0]
800086dc:	fa c6 f9 44 	sub	r6,sp,-1724
800086e0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800086e4:	2f f8       	sub	r8,-1
800086e6:	f7 49 fd 88 	st.w	r11[-632],r9
800086ea:	fb 48 06 b4 	st.w	sp[1716],r8
800086ee:	14 97       	mov	r7,r10
800086f0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800086f4:	c0 58       	rjmp	800086fe <_vfprintf_r+0x125e>
800086f6:	92 18       	ld.sh	r8,r9[0x2]
800086f8:	14 97       	mov	r7,r10
800086fa:	2f c9       	sub	r9,-4
800086fc:	51 09       	stdsp	sp[0x40],r9
800086fe:	5c 78       	castu.h	r8
80008700:	50 18       	stdsp	sp[0x4],r8
80008702:	c4 68       	rjmp	8000878e <_vfprintf_r+0x12ee>
80008704:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008708:	40 3c       	lddsp	r12,sp[0xc]
8000870a:	58 0c       	cp.w	r12,0
8000870c:	c1 d0       	breq	80008746 <_vfprintf_r+0x12a6>
8000870e:	10 36       	cp.w	r6,r8
80008710:	c0 64       	brge	8000871c <_vfprintf_r+0x127c>
80008712:	fa cb f9 44 	sub	r11,sp,-1724
80008716:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000871a:	c1 f8       	rjmp	80008758 <_vfprintf_r+0x12b8>
8000871c:	fa c8 f9 50 	sub	r8,sp,-1712
80008720:	1a d8       	st.w	--sp,r8
80008722:	fa c8 fa b8 	sub	r8,sp,-1352
80008726:	0c 9b       	mov	r11,r6
80008728:	1a d8       	st.w	--sp,r8
8000872a:	fa c8 fb b4 	sub	r8,sp,-1100
8000872e:	04 9a       	mov	r10,r2
80008730:	1a d8       	st.w	--sp,r8
80008732:	08 9c       	mov	r12,r4
80008734:	fa c8 f9 40 	sub	r8,sp,-1728
80008738:	fa c9 ff b4 	sub	r9,sp,-76
8000873c:	fe b0 f5 1a 	rcall	80007170 <get_arg>
80008740:	2f dd       	sub	sp,-12
80008742:	78 0b       	ld.w	r11,r12[0x0]
80008744:	c2 48       	rjmp	8000878c <_vfprintf_r+0x12ec>
80008746:	ee ca ff ff 	sub	r10,r7,-1
8000874a:	10 37       	cp.w	r7,r8
8000874c:	c0 94       	brge	8000875e <_vfprintf_r+0x12be>
8000874e:	fa c9 f9 44 	sub	r9,sp,-1724
80008752:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008756:	14 97       	mov	r7,r10
80008758:	ec fb fd 88 	ld.w	r11,r6[-632]
8000875c:	c1 88       	rjmp	8000878c <_vfprintf_r+0x12ec>
8000875e:	41 09       	lddsp	r9,sp[0x40]
80008760:	59 f8       	cp.w	r8,31
80008762:	e0 89 00 11 	brgt	80008784 <_vfprintf_r+0x12e4>
80008766:	f2 cb ff fc 	sub	r11,r9,-4
8000876a:	51 0b       	stdsp	sp[0x40],r11
8000876c:	fa c6 f9 44 	sub	r6,sp,-1724
80008770:	72 0b       	ld.w	r11,r9[0x0]
80008772:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008776:	f3 4b fd 88 	st.w	r9[-632],r11
8000877a:	2f f8       	sub	r8,-1
8000877c:	14 97       	mov	r7,r10
8000877e:	fb 48 06 b4 	st.w	sp[1716],r8
80008782:	c0 58       	rjmp	8000878c <_vfprintf_r+0x12ec>
80008784:	72 0b       	ld.w	r11,r9[0x0]
80008786:	14 97       	mov	r7,r10
80008788:	2f c9       	sub	r9,-4
8000878a:	51 09       	stdsp	sp[0x40],r9
8000878c:	50 1b       	stdsp	sp[0x4],r11
8000878e:	30 0e       	mov	lr,0
80008790:	30 18       	mov	r8,1
80008792:	50 0e       	stdsp	sp[0x0],lr
80008794:	c2 29       	rjmp	800089d8 <_vfprintf_r+0x1538>
80008796:	50 a7       	stdsp	sp[0x28],r7
80008798:	50 80       	stdsp	sp[0x20],r0
8000879a:	0c 97       	mov	r7,r6
8000879c:	04 94       	mov	r4,r2
8000879e:	06 96       	mov	r6,r3
800087a0:	02 92       	mov	r2,r1
800087a2:	fe cc b5 3a 	sub	r12,pc,-19142
800087a6:	40 93       	lddsp	r3,sp[0x24]
800087a8:	10 90       	mov	r0,r8
800087aa:	40 41       	lddsp	r1,sp[0x10]
800087ac:	50 dc       	stdsp	sp[0x34],r12
800087ae:	ed b5 00 05 	bld	r5,0x5
800087b2:	c5 51       	brne	8000885c <_vfprintf_r+0x13bc>
800087b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087b8:	40 3b       	lddsp	r11,sp[0xc]
800087ba:	58 0b       	cp.w	r11,0
800087bc:	c2 20       	breq	80008800 <_vfprintf_r+0x1360>
800087be:	10 36       	cp.w	r6,r8
800087c0:	c0 a4       	brge	800087d4 <_vfprintf_r+0x1334>
800087c2:	fa ca f9 44 	sub	r10,sp,-1724
800087c6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800087ca:	ec e8 fd 88 	ld.d	r8,r6[-632]
800087ce:	fa e9 00 00 	st.d	sp[0],r8
800087d2:	cf 28       	rjmp	800089b6 <_vfprintf_r+0x1516>
800087d4:	fa c8 f9 50 	sub	r8,sp,-1712
800087d8:	1a d8       	st.w	--sp,r8
800087da:	fa c8 fa b8 	sub	r8,sp,-1352
800087de:	04 9a       	mov	r10,r2
800087e0:	1a d8       	st.w	--sp,r8
800087e2:	0c 9b       	mov	r11,r6
800087e4:	fa c8 fb b4 	sub	r8,sp,-1100
800087e8:	08 9c       	mov	r12,r4
800087ea:	1a d8       	st.w	--sp,r8
800087ec:	fa c8 f9 40 	sub	r8,sp,-1728
800087f0:	fa c9 ff b4 	sub	r9,sp,-76
800087f4:	fe b0 f4 be 	rcall	80007170 <get_arg>
800087f8:	2f dd       	sub	sp,-12
800087fa:	f8 ea 00 00 	ld.d	r10,r12[0]
800087fe:	c0 c8       	rjmp	80008816 <_vfprintf_r+0x1376>
80008800:	ee ca ff ff 	sub	r10,r7,-1
80008804:	10 37       	cp.w	r7,r8
80008806:	c0 b4       	brge	8000881c <_vfprintf_r+0x137c>
80008808:	fa c9 f9 44 	sub	r9,sp,-1724
8000880c:	14 97       	mov	r7,r10
8000880e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008812:	ec ea fd 88 	ld.d	r10,r6[-632]
80008816:	fa eb 00 00 	st.d	sp[0],r10
8000881a:	cc e8       	rjmp	800089b6 <_vfprintf_r+0x1516>
8000881c:	41 09       	lddsp	r9,sp[0x40]
8000881e:	59 f8       	cp.w	r8,31
80008820:	e0 89 00 16 	brgt	8000884c <_vfprintf_r+0x13ac>
80008824:	f2 e6 00 00 	ld.d	r6,r9[0]
80008828:	f2 cb ff f8 	sub	r11,r9,-8
8000882c:	fa e7 00 00 	st.d	sp[0],r6
80008830:	51 0b       	stdsp	sp[0x40],r11
80008832:	fa c6 f9 44 	sub	r6,sp,-1724
80008836:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000883a:	fa e6 00 00 	ld.d	r6,sp[0]
8000883e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008842:	2f f8       	sub	r8,-1
80008844:	14 97       	mov	r7,r10
80008846:	fb 48 06 b4 	st.w	sp[1716],r8
8000884a:	cb 68       	rjmp	800089b6 <_vfprintf_r+0x1516>
8000884c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008850:	2f 89       	sub	r9,-8
80008852:	fa e7 00 00 	st.d	sp[0],r6
80008856:	51 09       	stdsp	sp[0x40],r9
80008858:	14 97       	mov	r7,r10
8000885a:	ca e8       	rjmp	800089b6 <_vfprintf_r+0x1516>
8000885c:	ed b5 00 04 	bld	r5,0x4
80008860:	c1 71       	brne	8000888e <_vfprintf_r+0x13ee>
80008862:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008866:	40 3e       	lddsp	lr,sp[0xc]
80008868:	58 0e       	cp.w	lr,0
8000886a:	c0 80       	breq	8000887a <_vfprintf_r+0x13da>
8000886c:	10 36       	cp.w	r6,r8
8000886e:	c6 94       	brge	80008940 <_vfprintf_r+0x14a0>
80008870:	fa cc f9 44 	sub	r12,sp,-1724
80008874:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008878:	c8 28       	rjmp	8000897c <_vfprintf_r+0x14dc>
8000887a:	ee ca ff ff 	sub	r10,r7,-1
8000887e:	10 37       	cp.w	r7,r8
80008880:	e0 84 00 81 	brge	80008982 <_vfprintf_r+0x14e2>
80008884:	fa cb f9 44 	sub	r11,sp,-1724
80008888:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000888c:	c7 78       	rjmp	8000897a <_vfprintf_r+0x14da>
8000888e:	ed b5 00 06 	bld	r5,0x6
80008892:	c4 b1       	brne	80008928 <_vfprintf_r+0x1488>
80008894:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008898:	40 3c       	lddsp	r12,sp[0xc]
8000889a:	58 0c       	cp.w	r12,0
8000889c:	c1 d0       	breq	800088d6 <_vfprintf_r+0x1436>
8000889e:	10 36       	cp.w	r6,r8
800088a0:	c0 64       	brge	800088ac <_vfprintf_r+0x140c>
800088a2:	fa cb f9 44 	sub	r11,sp,-1724
800088a6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088aa:	c1 f8       	rjmp	800088e8 <_vfprintf_r+0x1448>
800088ac:	fa c8 f9 50 	sub	r8,sp,-1712
800088b0:	1a d8       	st.w	--sp,r8
800088b2:	fa c8 fa b8 	sub	r8,sp,-1352
800088b6:	1a d8       	st.w	--sp,r8
800088b8:	fa c8 fb b4 	sub	r8,sp,-1100
800088bc:	1a d8       	st.w	--sp,r8
800088be:	fa c8 f9 40 	sub	r8,sp,-1728
800088c2:	fa c9 ff b4 	sub	r9,sp,-76
800088c6:	04 9a       	mov	r10,r2
800088c8:	0c 9b       	mov	r11,r6
800088ca:	08 9c       	mov	r12,r4
800088cc:	fe b0 f4 52 	rcall	80007170 <get_arg>
800088d0:	2f dd       	sub	sp,-12
800088d2:	98 18       	ld.sh	r8,r12[0x2]
800088d4:	c2 78       	rjmp	80008922 <_vfprintf_r+0x1482>
800088d6:	ee ca ff ff 	sub	r10,r7,-1
800088da:	10 37       	cp.w	r7,r8
800088dc:	c0 a4       	brge	800088f0 <_vfprintf_r+0x1450>
800088de:	fa c9 f9 44 	sub	r9,sp,-1724
800088e2:	14 97       	mov	r7,r10
800088e4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088e8:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800088ec:	c1 b8       	rjmp	80008922 <_vfprintf_r+0x1482>
800088ee:	d7 03       	nop
800088f0:	41 09       	lddsp	r9,sp[0x40]
800088f2:	59 f8       	cp.w	r8,31
800088f4:	e0 89 00 13 	brgt	8000891a <_vfprintf_r+0x147a>
800088f8:	f2 cb ff fc 	sub	r11,r9,-4
800088fc:	51 0b       	stdsp	sp[0x40],r11
800088fe:	72 09       	ld.w	r9,r9[0x0]
80008900:	fa c6 f9 44 	sub	r6,sp,-1724
80008904:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008908:	2f f8       	sub	r8,-1
8000890a:	f7 49 fd 88 	st.w	r11[-632],r9
8000890e:	fb 48 06 b4 	st.w	sp[1716],r8
80008912:	14 97       	mov	r7,r10
80008914:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008918:	c0 58       	rjmp	80008922 <_vfprintf_r+0x1482>
8000891a:	92 18       	ld.sh	r8,r9[0x2]
8000891c:	14 97       	mov	r7,r10
8000891e:	2f c9       	sub	r9,-4
80008920:	51 09       	stdsp	sp[0x40],r9
80008922:	5c 78       	castu.h	r8
80008924:	50 18       	stdsp	sp[0x4],r8
80008926:	c4 68       	rjmp	800089b2 <_vfprintf_r+0x1512>
80008928:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000892c:	40 3c       	lddsp	r12,sp[0xc]
8000892e:	58 0c       	cp.w	r12,0
80008930:	c1 d0       	breq	8000896a <_vfprintf_r+0x14ca>
80008932:	10 36       	cp.w	r6,r8
80008934:	c0 64       	brge	80008940 <_vfprintf_r+0x14a0>
80008936:	fa cb f9 44 	sub	r11,sp,-1724
8000893a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000893e:	c1 f8       	rjmp	8000897c <_vfprintf_r+0x14dc>
80008940:	fa c8 f9 50 	sub	r8,sp,-1712
80008944:	1a d8       	st.w	--sp,r8
80008946:	fa c8 fa b8 	sub	r8,sp,-1352
8000894a:	0c 9b       	mov	r11,r6
8000894c:	1a d8       	st.w	--sp,r8
8000894e:	fa c8 fb b4 	sub	r8,sp,-1100
80008952:	04 9a       	mov	r10,r2
80008954:	1a d8       	st.w	--sp,r8
80008956:	08 9c       	mov	r12,r4
80008958:	fa c8 f9 40 	sub	r8,sp,-1728
8000895c:	fa c9 ff b4 	sub	r9,sp,-76
80008960:	fe b0 f4 08 	rcall	80007170 <get_arg>
80008964:	2f dd       	sub	sp,-12
80008966:	78 0b       	ld.w	r11,r12[0x0]
80008968:	c2 48       	rjmp	800089b0 <_vfprintf_r+0x1510>
8000896a:	ee ca ff ff 	sub	r10,r7,-1
8000896e:	10 37       	cp.w	r7,r8
80008970:	c0 94       	brge	80008982 <_vfprintf_r+0x14e2>
80008972:	fa c9 f9 44 	sub	r9,sp,-1724
80008976:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000897a:	14 97       	mov	r7,r10
8000897c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008980:	c1 88       	rjmp	800089b0 <_vfprintf_r+0x1510>
80008982:	41 09       	lddsp	r9,sp[0x40]
80008984:	59 f8       	cp.w	r8,31
80008986:	e0 89 00 11 	brgt	800089a8 <_vfprintf_r+0x1508>
8000898a:	f2 cb ff fc 	sub	r11,r9,-4
8000898e:	51 0b       	stdsp	sp[0x40],r11
80008990:	fa c6 f9 44 	sub	r6,sp,-1724
80008994:	72 0b       	ld.w	r11,r9[0x0]
80008996:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000899a:	f3 4b fd 88 	st.w	r9[-632],r11
8000899e:	2f f8       	sub	r8,-1
800089a0:	14 97       	mov	r7,r10
800089a2:	fb 48 06 b4 	st.w	sp[1716],r8
800089a6:	c0 58       	rjmp	800089b0 <_vfprintf_r+0x1510>
800089a8:	72 0b       	ld.w	r11,r9[0x0]
800089aa:	14 97       	mov	r7,r10
800089ac:	2f c9       	sub	r9,-4
800089ae:	51 09       	stdsp	sp[0x40],r9
800089b0:	50 1b       	stdsp	sp[0x4],r11
800089b2:	30 0e       	mov	lr,0
800089b4:	50 0e       	stdsp	sp[0x0],lr
800089b6:	40 08       	lddsp	r8,sp[0x0]
800089b8:	40 1c       	lddsp	r12,sp[0x4]
800089ba:	18 48       	or	r8,r12
800089bc:	5f 19       	srne	r9
800089be:	0a 98       	mov	r8,r5
800089c0:	eb e9 00 09 	and	r9,r5,r9
800089c4:	a1 b8       	sbr	r8,0x1
800089c6:	58 09       	cp.w	r9,0
800089c8:	c0 70       	breq	800089d6 <_vfprintf_r+0x1536>
800089ca:	10 95       	mov	r5,r8
800089cc:	fb 60 06 b9 	st.b	sp[1721],r0
800089d0:	33 08       	mov	r8,48
800089d2:	fb 68 06 b8 	st.b	sp[1720],r8
800089d6:	30 28       	mov	r8,2
800089d8:	30 09       	mov	r9,0
800089da:	fb 69 06 bb 	st.b	sp[1723],r9
800089de:	0a 99       	mov	r9,r5
800089e0:	a7 d9       	cbr	r9,0x7
800089e2:	40 2b       	lddsp	r11,sp[0x8]
800089e4:	40 16       	lddsp	r6,sp[0x4]
800089e6:	58 0b       	cp.w	r11,0
800089e8:	5f 1a       	srne	r10
800089ea:	f2 05 17 40 	movge	r5,r9
800089ee:	fa c2 f9 78 	sub	r2,sp,-1672
800089f2:	40 09       	lddsp	r9,sp[0x0]
800089f4:	0c 49       	or	r9,r6
800089f6:	5f 19       	srne	r9
800089f8:	f5 e9 10 09 	or	r9,r10,r9
800089fc:	c5 c0       	breq	80008ab4 <_vfprintf_r+0x1614>
800089fe:	30 19       	mov	r9,1
80008a00:	f2 08 18 00 	cp.b	r8,r9
80008a04:	c0 60       	breq	80008a10 <_vfprintf_r+0x1570>
80008a06:	30 29       	mov	r9,2
80008a08:	f2 08 18 00 	cp.b	r8,r9
80008a0c:	c0 41       	brne	80008a14 <_vfprintf_r+0x1574>
80008a0e:	c3 c8       	rjmp	80008a86 <_vfprintf_r+0x15e6>
80008a10:	04 96       	mov	r6,r2
80008a12:	c3 08       	rjmp	80008a72 <_vfprintf_r+0x15d2>
80008a14:	04 96       	mov	r6,r2
80008a16:	fa e8 00 00 	ld.d	r8,sp[0]
80008a1a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008a1e:	2d 0a       	sub	r10,-48
80008a20:	0c fa       	st.b	--r6,r10
80008a22:	f0 0b 16 03 	lsr	r11,r8,0x3
80008a26:	f2 0c 16 03 	lsr	r12,r9,0x3
80008a2a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008a2e:	18 99       	mov	r9,r12
80008a30:	16 98       	mov	r8,r11
80008a32:	58 08       	cp.w	r8,0
80008a34:	5c 29       	cpc	r9
80008a36:	cf 21       	brne	80008a1a <_vfprintf_r+0x157a>
80008a38:	fa e9 00 00 	st.d	sp[0],r8
80008a3c:	ed b5 00 00 	bld	r5,0x0
80008a40:	c4 51       	brne	80008aca <_vfprintf_r+0x162a>
80008a42:	33 09       	mov	r9,48
80008a44:	f2 0a 18 00 	cp.b	r10,r9
80008a48:	c4 10       	breq	80008aca <_vfprintf_r+0x162a>
80008a4a:	0c f9       	st.b	--r6,r9
80008a4c:	c3 f8       	rjmp	80008aca <_vfprintf_r+0x162a>
80008a4e:	fa ea 00 00 	ld.d	r10,sp[0]
80008a52:	30 a8       	mov	r8,10
80008a54:	30 09       	mov	r9,0
80008a56:	e0 a0 1a 0d 	rcall	8000be70 <__avr32_umod64>
80008a5a:	30 a8       	mov	r8,10
80008a5c:	2d 0a       	sub	r10,-48
80008a5e:	30 09       	mov	r9,0
80008a60:	ac 8a       	st.b	r6[0x0],r10
80008a62:	fa ea 00 00 	ld.d	r10,sp[0]
80008a66:	e0 a0 18 d3 	rcall	8000bc0c <__avr32_udiv64>
80008a6a:	16 99       	mov	r9,r11
80008a6c:	14 98       	mov	r8,r10
80008a6e:	fa e9 00 00 	st.d	sp[0],r8
80008a72:	20 16       	sub	r6,1
80008a74:	fa ea 00 00 	ld.d	r10,sp[0]
80008a78:	58 9a       	cp.w	r10,9
80008a7a:	5c 2b       	cpc	r11
80008a7c:	fe 9b ff e9 	brhi	80008a4e <_vfprintf_r+0x15ae>
80008a80:	1b f8       	ld.ub	r8,sp[0x7]
80008a82:	2d 08       	sub	r8,-48
80008a84:	c2 08       	rjmp	80008ac4 <_vfprintf_r+0x1624>
80008a86:	04 96       	mov	r6,r2
80008a88:	fa e8 00 00 	ld.d	r8,sp[0]
80008a8c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008a90:	40 de       	lddsp	lr,sp[0x34]
80008a92:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008a96:	0c fa       	st.b	--r6,r10
80008a98:	f2 0b 16 04 	lsr	r11,r9,0x4
80008a9c:	f0 0a 16 04 	lsr	r10,r8,0x4
80008aa0:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008aa4:	16 99       	mov	r9,r11
80008aa6:	14 98       	mov	r8,r10
80008aa8:	58 08       	cp.w	r8,0
80008aaa:	5c 29       	cpc	r9
80008aac:	cf 01       	brne	80008a8c <_vfprintf_r+0x15ec>
80008aae:	fa e9 00 00 	st.d	sp[0],r8
80008ab2:	c0 c8       	rjmp	80008aca <_vfprintf_r+0x162a>
80008ab4:	58 08       	cp.w	r8,0
80008ab6:	c0 91       	brne	80008ac8 <_vfprintf_r+0x1628>
80008ab8:	ed b5 00 00 	bld	r5,0x0
80008abc:	c0 61       	brne	80008ac8 <_vfprintf_r+0x1628>
80008abe:	fa c6 f9 79 	sub	r6,sp,-1671
80008ac2:	33 08       	mov	r8,48
80008ac4:	ac 88       	st.b	r6[0x0],r8
80008ac6:	c0 28       	rjmp	80008aca <_vfprintf_r+0x162a>
80008ac8:	04 96       	mov	r6,r2
80008aca:	0c 12       	sub	r2,r6
80008acc:	c1 c8       	rjmp	80008b04 <_vfprintf_r+0x1664>
80008ace:	50 a7       	stdsp	sp[0x28],r7
80008ad0:	50 80       	stdsp	sp[0x20],r0
80008ad2:	40 93       	lddsp	r3,sp[0x24]
80008ad4:	0c 97       	mov	r7,r6
80008ad6:	10 90       	mov	r0,r8
80008ad8:	04 94       	mov	r4,r2
80008ada:	40 41       	lddsp	r1,sp[0x10]
80008adc:	58 08       	cp.w	r8,0
80008ade:	e0 80 04 4f 	breq	8000937c <_vfprintf_r+0x1edc>
80008ae2:	fb 68 06 60 	st.b	sp[1632],r8
80008ae6:	30 0c       	mov	r12,0
80008ae8:	30 08       	mov	r8,0
80008aea:	30 12       	mov	r2,1
80008aec:	fb 68 06 bb 	st.b	sp[1723],r8
80008af0:	50 2c       	stdsp	sp[0x8],r12
80008af2:	fa c6 f9 a0 	sub	r6,sp,-1632
80008af6:	c0 78       	rjmp	80008b04 <_vfprintf_r+0x1664>
80008af8:	30 0b       	mov	r11,0
80008afa:	50 2b       	stdsp	sp[0x8],r11
80008afc:	c0 48       	rjmp	80008b04 <_vfprintf_r+0x1664>
80008afe:	40 22       	lddsp	r2,sp[0x8]
80008b00:	30 0a       	mov	r10,0
80008b02:	50 2a       	stdsp	sp[0x8],r10
80008b04:	40 29       	lddsp	r9,sp[0x8]
80008b06:	e4 09 0c 49 	max	r9,r2,r9
80008b0a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008b0e:	50 39       	stdsp	sp[0xc],r9
80008b10:	0a 9e       	mov	lr,r5
80008b12:	30 09       	mov	r9,0
80008b14:	e2 1e 00 02 	andl	lr,0x2,COH
80008b18:	f2 08 18 00 	cp.b	r8,r9
80008b1c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008b20:	f7 b8 01 ff 	subne	r8,-1
80008b24:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008b28:	0a 9b       	mov	r11,r5
80008b2a:	58 0e       	cp.w	lr,0
80008b2c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008b30:	f7 bc 01 fe 	subne	r12,-2
80008b34:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008b38:	e2 1b 00 84 	andl	r11,0x84,COH
80008b3c:	50 fe       	stdsp	sp[0x3c],lr
80008b3e:	50 9b       	stdsp	sp[0x24],r11
80008b40:	c4 71       	brne	80008bce <_vfprintf_r+0x172e>
80008b42:	40 8a       	lddsp	r10,sp[0x20]
80008b44:	40 39       	lddsp	r9,sp[0xc]
80008b46:	12 1a       	sub	r10,r9
80008b48:	50 4a       	stdsp	sp[0x10],r10
80008b4a:	58 0a       	cp.w	r10,0
80008b4c:	e0 89 00 20 	brgt	80008b8c <_vfprintf_r+0x16ec>
80008b50:	c3 f8       	rjmp	80008bce <_vfprintf_r+0x172e>
80008b52:	2f 09       	sub	r9,-16
80008b54:	2f f8       	sub	r8,-1
80008b56:	fe ce b8 d6 	sub	lr,pc,-18218
80008b5a:	31 0c       	mov	r12,16
80008b5c:	fb 49 06 90 	st.w	sp[1680],r9
80008b60:	87 0e       	st.w	r3[0x0],lr
80008b62:	87 1c       	st.w	r3[0x4],r12
80008b64:	fb 48 06 8c 	st.w	sp[1676],r8
80008b68:	58 78       	cp.w	r8,7
80008b6a:	e0 89 00 04 	brgt	80008b72 <_vfprintf_r+0x16d2>
80008b6e:	2f 83       	sub	r3,-8
80008b70:	c0 b8       	rjmp	80008b86 <_vfprintf_r+0x16e6>
80008b72:	fa ca f9 78 	sub	r10,sp,-1672
80008b76:	02 9b       	mov	r11,r1
80008b78:	08 9c       	mov	r12,r4
80008b7a:	fe b0 f4 85 	rcall	80007484 <__sprint_r>
80008b7e:	e0 81 04 10 	brne	8000939e <_vfprintf_r+0x1efe>
80008b82:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b86:	40 4b       	lddsp	r11,sp[0x10]
80008b88:	21 0b       	sub	r11,16
80008b8a:	50 4b       	stdsp	sp[0x10],r11
80008b8c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b90:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b94:	fe ca b9 14 	sub	r10,pc,-18156
80008b98:	40 4e       	lddsp	lr,sp[0x10]
80008b9a:	59 0e       	cp.w	lr,16
80008b9c:	fe 99 ff db 	brgt	80008b52 <_vfprintf_r+0x16b2>
80008ba0:	1c 09       	add	r9,lr
80008ba2:	2f f8       	sub	r8,-1
80008ba4:	87 0a       	st.w	r3[0x0],r10
80008ba6:	fb 49 06 90 	st.w	sp[1680],r9
80008baa:	87 1e       	st.w	r3[0x4],lr
80008bac:	fb 48 06 8c 	st.w	sp[1676],r8
80008bb0:	58 78       	cp.w	r8,7
80008bb2:	e0 89 00 04 	brgt	80008bba <_vfprintf_r+0x171a>
80008bb6:	2f 83       	sub	r3,-8
80008bb8:	c0 b8       	rjmp	80008bce <_vfprintf_r+0x172e>
80008bba:	fa ca f9 78 	sub	r10,sp,-1672
80008bbe:	02 9b       	mov	r11,r1
80008bc0:	08 9c       	mov	r12,r4
80008bc2:	fe b0 f4 61 	rcall	80007484 <__sprint_r>
80008bc6:	e0 81 03 ec 	brne	8000939e <_vfprintf_r+0x1efe>
80008bca:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bce:	30 09       	mov	r9,0
80008bd0:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008bd4:	f2 08 18 00 	cp.b	r8,r9
80008bd8:	c1 f0       	breq	80008c16 <_vfprintf_r+0x1776>
80008bda:	fa f8 06 90 	ld.w	r8,sp[1680]
80008bde:	fa c9 f9 45 	sub	r9,sp,-1723
80008be2:	2f f8       	sub	r8,-1
80008be4:	87 09       	st.w	r3[0x0],r9
80008be6:	fb 48 06 90 	st.w	sp[1680],r8
80008bea:	30 19       	mov	r9,1
80008bec:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bf0:	87 19       	st.w	r3[0x4],r9
80008bf2:	2f f8       	sub	r8,-1
80008bf4:	fb 48 06 8c 	st.w	sp[1676],r8
80008bf8:	58 78       	cp.w	r8,7
80008bfa:	e0 89 00 04 	brgt	80008c02 <_vfprintf_r+0x1762>
80008bfe:	2f 83       	sub	r3,-8
80008c00:	c0 b8       	rjmp	80008c16 <_vfprintf_r+0x1776>
80008c02:	fa ca f9 78 	sub	r10,sp,-1672
80008c06:	02 9b       	mov	r11,r1
80008c08:	08 9c       	mov	r12,r4
80008c0a:	fe b0 f4 3d 	rcall	80007484 <__sprint_r>
80008c0e:	e0 81 03 c8 	brne	8000939e <_vfprintf_r+0x1efe>
80008c12:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c16:	40 fc       	lddsp	r12,sp[0x3c]
80008c18:	58 0c       	cp.w	r12,0
80008c1a:	c1 f0       	breq	80008c58 <_vfprintf_r+0x17b8>
80008c1c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c20:	fa c9 f9 48 	sub	r9,sp,-1720
80008c24:	2f e8       	sub	r8,-2
80008c26:	87 09       	st.w	r3[0x0],r9
80008c28:	fb 48 06 90 	st.w	sp[1680],r8
80008c2c:	30 29       	mov	r9,2
80008c2e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008c32:	87 19       	st.w	r3[0x4],r9
80008c34:	2f f8       	sub	r8,-1
80008c36:	fb 48 06 8c 	st.w	sp[1676],r8
80008c3a:	58 78       	cp.w	r8,7
80008c3c:	e0 89 00 04 	brgt	80008c44 <_vfprintf_r+0x17a4>
80008c40:	2f 83       	sub	r3,-8
80008c42:	c0 b8       	rjmp	80008c58 <_vfprintf_r+0x17b8>
80008c44:	fa ca f9 78 	sub	r10,sp,-1672
80008c48:	02 9b       	mov	r11,r1
80008c4a:	08 9c       	mov	r12,r4
80008c4c:	fe b0 f4 1c 	rcall	80007484 <__sprint_r>
80008c50:	e0 81 03 a7 	brne	8000939e <_vfprintf_r+0x1efe>
80008c54:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c58:	40 9b       	lddsp	r11,sp[0x24]
80008c5a:	e0 4b 00 80 	cp.w	r11,128
80008c5e:	c4 71       	brne	80008cec <_vfprintf_r+0x184c>
80008c60:	40 8a       	lddsp	r10,sp[0x20]
80008c62:	40 39       	lddsp	r9,sp[0xc]
80008c64:	12 1a       	sub	r10,r9
80008c66:	50 4a       	stdsp	sp[0x10],r10
80008c68:	58 0a       	cp.w	r10,0
80008c6a:	e0 89 00 20 	brgt	80008caa <_vfprintf_r+0x180a>
80008c6e:	c3 f8       	rjmp	80008cec <_vfprintf_r+0x184c>
80008c70:	2f 09       	sub	r9,-16
80008c72:	2f f8       	sub	r8,-1
80008c74:	fe ce b9 e4 	sub	lr,pc,-17948
80008c78:	31 0c       	mov	r12,16
80008c7a:	fb 49 06 90 	st.w	sp[1680],r9
80008c7e:	87 0e       	st.w	r3[0x0],lr
80008c80:	87 1c       	st.w	r3[0x4],r12
80008c82:	fb 48 06 8c 	st.w	sp[1676],r8
80008c86:	58 78       	cp.w	r8,7
80008c88:	e0 89 00 04 	brgt	80008c90 <_vfprintf_r+0x17f0>
80008c8c:	2f 83       	sub	r3,-8
80008c8e:	c0 b8       	rjmp	80008ca4 <_vfprintf_r+0x1804>
80008c90:	fa ca f9 78 	sub	r10,sp,-1672
80008c94:	02 9b       	mov	r11,r1
80008c96:	08 9c       	mov	r12,r4
80008c98:	fe b0 f3 f6 	rcall	80007484 <__sprint_r>
80008c9c:	e0 81 03 81 	brne	8000939e <_vfprintf_r+0x1efe>
80008ca0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ca4:	40 4b       	lddsp	r11,sp[0x10]
80008ca6:	21 0b       	sub	r11,16
80008ca8:	50 4b       	stdsp	sp[0x10],r11
80008caa:	fa f9 06 90 	ld.w	r9,sp[1680]
80008cae:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008cb2:	fe ca ba 22 	sub	r10,pc,-17886
80008cb6:	40 4e       	lddsp	lr,sp[0x10]
80008cb8:	59 0e       	cp.w	lr,16
80008cba:	fe 99 ff db 	brgt	80008c70 <_vfprintf_r+0x17d0>
80008cbe:	1c 09       	add	r9,lr
80008cc0:	2f f8       	sub	r8,-1
80008cc2:	87 0a       	st.w	r3[0x0],r10
80008cc4:	fb 49 06 90 	st.w	sp[1680],r9
80008cc8:	87 1e       	st.w	r3[0x4],lr
80008cca:	fb 48 06 8c 	st.w	sp[1676],r8
80008cce:	58 78       	cp.w	r8,7
80008cd0:	e0 89 00 04 	brgt	80008cd8 <_vfprintf_r+0x1838>
80008cd4:	2f 83       	sub	r3,-8
80008cd6:	c0 b8       	rjmp	80008cec <_vfprintf_r+0x184c>
80008cd8:	fa ca f9 78 	sub	r10,sp,-1672
80008cdc:	02 9b       	mov	r11,r1
80008cde:	08 9c       	mov	r12,r4
80008ce0:	fe b0 f3 d2 	rcall	80007484 <__sprint_r>
80008ce4:	e0 81 03 5d 	brne	8000939e <_vfprintf_r+0x1efe>
80008ce8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008cec:	40 2c       	lddsp	r12,sp[0x8]
80008cee:	04 1c       	sub	r12,r2
80008cf0:	50 2c       	stdsp	sp[0x8],r12
80008cf2:	58 0c       	cp.w	r12,0
80008cf4:	e0 89 00 20 	brgt	80008d34 <_vfprintf_r+0x1894>
80008cf8:	c3 f8       	rjmp	80008d76 <_vfprintf_r+0x18d6>
80008cfa:	2f 09       	sub	r9,-16
80008cfc:	2f f8       	sub	r8,-1
80008cfe:	fe cb ba 6e 	sub	r11,pc,-17810
80008d02:	31 0a       	mov	r10,16
80008d04:	fb 49 06 90 	st.w	sp[1680],r9
80008d08:	87 0b       	st.w	r3[0x0],r11
80008d0a:	87 1a       	st.w	r3[0x4],r10
80008d0c:	fb 48 06 8c 	st.w	sp[1676],r8
80008d10:	58 78       	cp.w	r8,7
80008d12:	e0 89 00 04 	brgt	80008d1a <_vfprintf_r+0x187a>
80008d16:	2f 83       	sub	r3,-8
80008d18:	c0 b8       	rjmp	80008d2e <_vfprintf_r+0x188e>
80008d1a:	fa ca f9 78 	sub	r10,sp,-1672
80008d1e:	02 9b       	mov	r11,r1
80008d20:	08 9c       	mov	r12,r4
80008d22:	fe b0 f3 b1 	rcall	80007484 <__sprint_r>
80008d26:	e0 81 03 3c 	brne	8000939e <_vfprintf_r+0x1efe>
80008d2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d2e:	40 29       	lddsp	r9,sp[0x8]
80008d30:	21 09       	sub	r9,16
80008d32:	50 29       	stdsp	sp[0x8],r9
80008d34:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d38:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d3c:	fe ca ba ac 	sub	r10,pc,-17748
80008d40:	40 2e       	lddsp	lr,sp[0x8]
80008d42:	59 0e       	cp.w	lr,16
80008d44:	fe 99 ff db 	brgt	80008cfa <_vfprintf_r+0x185a>
80008d48:	1c 09       	add	r9,lr
80008d4a:	2f f8       	sub	r8,-1
80008d4c:	87 0a       	st.w	r3[0x0],r10
80008d4e:	fb 49 06 90 	st.w	sp[1680],r9
80008d52:	87 1e       	st.w	r3[0x4],lr
80008d54:	fb 48 06 8c 	st.w	sp[1676],r8
80008d58:	58 78       	cp.w	r8,7
80008d5a:	e0 89 00 04 	brgt	80008d62 <_vfprintf_r+0x18c2>
80008d5e:	2f 83       	sub	r3,-8
80008d60:	c0 b8       	rjmp	80008d76 <_vfprintf_r+0x18d6>
80008d62:	fa ca f9 78 	sub	r10,sp,-1672
80008d66:	02 9b       	mov	r11,r1
80008d68:	08 9c       	mov	r12,r4
80008d6a:	fe b0 f3 8d 	rcall	80007484 <__sprint_r>
80008d6e:	e0 81 03 18 	brne	8000939e <_vfprintf_r+0x1efe>
80008d72:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d76:	ed b5 00 08 	bld	r5,0x8
80008d7a:	c0 b0       	breq	80008d90 <_vfprintf_r+0x18f0>
80008d7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008d80:	87 12       	st.w	r3[0x4],r2
80008d82:	87 06       	st.w	r3[0x0],r6
80008d84:	f0 02 00 02 	add	r2,r8,r2
80008d88:	fb 42 06 90 	st.w	sp[1680],r2
80008d8c:	e0 8f 01 d4 	bral	80009134 <_vfprintf_r+0x1c94>
80008d90:	e0 40 00 65 	cp.w	r0,101
80008d94:	e0 8a 01 d6 	brle	80009140 <_vfprintf_r+0x1ca0>
80008d98:	30 08       	mov	r8,0
80008d9a:	30 09       	mov	r9,0
80008d9c:	40 5b       	lddsp	r11,sp[0x14]
80008d9e:	40 7a       	lddsp	r10,sp[0x1c]
80008da0:	e0 a0 15 2f 	rcall	8000b7fe <__avr32_f64_cmp_eq>
80008da4:	c7 90       	breq	80008e96 <_vfprintf_r+0x19f6>
80008da6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008daa:	fe c9 bb 2e 	sub	r9,pc,-17618
80008dae:	2f f8       	sub	r8,-1
80008db0:	87 09       	st.w	r3[0x0],r9
80008db2:	fb 48 06 90 	st.w	sp[1680],r8
80008db6:	30 19       	mov	r9,1
80008db8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008dbc:	87 19       	st.w	r3[0x4],r9
80008dbe:	2f f8       	sub	r8,-1
80008dc0:	fb 48 06 8c 	st.w	sp[1676],r8
80008dc4:	58 78       	cp.w	r8,7
80008dc6:	e0 89 00 05 	brgt	80008dd0 <_vfprintf_r+0x1930>
80008dca:	2f 83       	sub	r3,-8
80008dcc:	c0 c8       	rjmp	80008de4 <_vfprintf_r+0x1944>
80008dce:	d7 03       	nop
80008dd0:	fa ca f9 78 	sub	r10,sp,-1672
80008dd4:	02 9b       	mov	r11,r1
80008dd6:	08 9c       	mov	r12,r4
80008dd8:	fe b0 f3 56 	rcall	80007484 <__sprint_r>
80008ddc:	e0 81 02 e1 	brne	8000939e <_vfprintf_r+0x1efe>
80008de0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008de4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008de8:	40 6c       	lddsp	r12,sp[0x18]
80008dea:	18 38       	cp.w	r8,r12
80008dec:	c0 55       	brlt	80008df6 <_vfprintf_r+0x1956>
80008dee:	ed b5 00 00 	bld	r5,0x0
80008df2:	e0 81 02 6b 	brne	800092c8 <_vfprintf_r+0x1e28>
80008df6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008dfa:	2f f8       	sub	r8,-1
80008dfc:	40 cb       	lddsp	r11,sp[0x30]
80008dfe:	fb 48 06 90 	st.w	sp[1680],r8
80008e02:	30 19       	mov	r9,1
80008e04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e08:	87 0b       	st.w	r3[0x0],r11
80008e0a:	2f f8       	sub	r8,-1
80008e0c:	87 19       	st.w	r3[0x4],r9
80008e0e:	fb 48 06 8c 	st.w	sp[1676],r8
80008e12:	58 78       	cp.w	r8,7
80008e14:	e0 89 00 04 	brgt	80008e1c <_vfprintf_r+0x197c>
80008e18:	2f 83       	sub	r3,-8
80008e1a:	c0 b8       	rjmp	80008e30 <_vfprintf_r+0x1990>
80008e1c:	fa ca f9 78 	sub	r10,sp,-1672
80008e20:	02 9b       	mov	r11,r1
80008e22:	08 9c       	mov	r12,r4
80008e24:	fe b0 f3 30 	rcall	80007484 <__sprint_r>
80008e28:	e0 81 02 bb 	brne	8000939e <_vfprintf_r+0x1efe>
80008e2c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e30:	40 66       	lddsp	r6,sp[0x18]
80008e32:	20 16       	sub	r6,1
80008e34:	58 06       	cp.w	r6,0
80008e36:	e0 89 00 1d 	brgt	80008e70 <_vfprintf_r+0x19d0>
80008e3a:	e0 8f 02 47 	bral	800092c8 <_vfprintf_r+0x1e28>
80008e3e:	2f 09       	sub	r9,-16
80008e40:	2f f8       	sub	r8,-1
80008e42:	fb 49 06 90 	st.w	sp[1680],r9
80008e46:	87 02       	st.w	r3[0x0],r2
80008e48:	87 10       	st.w	r3[0x4],r0
80008e4a:	fb 48 06 8c 	st.w	sp[1676],r8
80008e4e:	58 78       	cp.w	r8,7
80008e50:	e0 89 00 04 	brgt	80008e58 <_vfprintf_r+0x19b8>
80008e54:	2f 83       	sub	r3,-8
80008e56:	c0 b8       	rjmp	80008e6c <_vfprintf_r+0x19cc>
80008e58:	fa ca f9 78 	sub	r10,sp,-1672
80008e5c:	02 9b       	mov	r11,r1
80008e5e:	08 9c       	mov	r12,r4
80008e60:	fe b0 f3 12 	rcall	80007484 <__sprint_r>
80008e64:	e0 81 02 9d 	brne	8000939e <_vfprintf_r+0x1efe>
80008e68:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e6c:	21 06       	sub	r6,16
80008e6e:	c0 48       	rjmp	80008e76 <_vfprintf_r+0x19d6>
80008e70:	fe c2 bb e0 	sub	r2,pc,-17440
80008e74:	31 00       	mov	r0,16
80008e76:	fa f9 06 90 	ld.w	r9,sp[1680]
80008e7a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e7e:	fe ca bb ee 	sub	r10,pc,-17426
80008e82:	59 06       	cp.w	r6,16
80008e84:	fe 99 ff dd 	brgt	80008e3e <_vfprintf_r+0x199e>
80008e88:	0c 09       	add	r9,r6
80008e8a:	87 0a       	st.w	r3[0x0],r10
80008e8c:	fb 49 06 90 	st.w	sp[1680],r9
80008e90:	2f f8       	sub	r8,-1
80008e92:	87 16       	st.w	r3[0x4],r6
80008e94:	c5 39       	rjmp	8000913a <_vfprintf_r+0x1c9a>
80008e96:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008e9a:	58 0a       	cp.w	r10,0
80008e9c:	e0 89 00 92 	brgt	80008fc0 <_vfprintf_r+0x1b20>
80008ea0:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ea4:	fe c9 bc 28 	sub	r9,pc,-17368
80008ea8:	2f f8       	sub	r8,-1
80008eaa:	87 09       	st.w	r3[0x0],r9
80008eac:	fb 48 06 90 	st.w	sp[1680],r8
80008eb0:	30 19       	mov	r9,1
80008eb2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008eb6:	87 19       	st.w	r3[0x4],r9
80008eb8:	2f f8       	sub	r8,-1
80008eba:	fb 48 06 8c 	st.w	sp[1676],r8
80008ebe:	58 78       	cp.w	r8,7
80008ec0:	e0 89 00 04 	brgt	80008ec8 <_vfprintf_r+0x1a28>
80008ec4:	2f 83       	sub	r3,-8
80008ec6:	c0 b8       	rjmp	80008edc <_vfprintf_r+0x1a3c>
80008ec8:	fa ca f9 78 	sub	r10,sp,-1672
80008ecc:	02 9b       	mov	r11,r1
80008ece:	08 9c       	mov	r12,r4
80008ed0:	fe b0 f2 da 	rcall	80007484 <__sprint_r>
80008ed4:	e0 81 02 65 	brne	8000939e <_vfprintf_r+0x1efe>
80008ed8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008edc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008ee0:	58 08       	cp.w	r8,0
80008ee2:	c0 81       	brne	80008ef2 <_vfprintf_r+0x1a52>
80008ee4:	40 6a       	lddsp	r10,sp[0x18]
80008ee6:	58 0a       	cp.w	r10,0
80008ee8:	c0 51       	brne	80008ef2 <_vfprintf_r+0x1a52>
80008eea:	ed b5 00 00 	bld	r5,0x0
80008eee:	e0 81 01 ed 	brne	800092c8 <_vfprintf_r+0x1e28>
80008ef2:	40 c9       	lddsp	r9,sp[0x30]
80008ef4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ef8:	2f f8       	sub	r8,-1
80008efa:	87 09       	st.w	r3[0x0],r9
80008efc:	fb 48 06 90 	st.w	sp[1680],r8
80008f00:	30 19       	mov	r9,1
80008f02:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f06:	87 19       	st.w	r3[0x4],r9
80008f08:	2f f8       	sub	r8,-1
80008f0a:	fb 48 06 8c 	st.w	sp[1676],r8
80008f0e:	58 78       	cp.w	r8,7
80008f10:	e0 89 00 04 	brgt	80008f18 <_vfprintf_r+0x1a78>
80008f14:	2f 83       	sub	r3,-8
80008f16:	c0 b8       	rjmp	80008f2c <_vfprintf_r+0x1a8c>
80008f18:	fa ca f9 78 	sub	r10,sp,-1672
80008f1c:	02 9b       	mov	r11,r1
80008f1e:	08 9c       	mov	r12,r4
80008f20:	fe b0 f2 b2 	rcall	80007484 <__sprint_r>
80008f24:	e0 81 02 3d 	brne	8000939e <_vfprintf_r+0x1efe>
80008f28:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f2c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008f30:	5c 32       	neg	r2
80008f32:	58 02       	cp.w	r2,0
80008f34:	e0 89 00 1d 	brgt	80008f6e <_vfprintf_r+0x1ace>
80008f38:	c3 d8       	rjmp	80008fb2 <_vfprintf_r+0x1b12>
80008f3a:	2f 09       	sub	r9,-16
80008f3c:	2f f8       	sub	r8,-1
80008f3e:	31 0e       	mov	lr,16
80008f40:	fb 49 06 90 	st.w	sp[1680],r9
80008f44:	87 00       	st.w	r3[0x0],r0
80008f46:	87 1e       	st.w	r3[0x4],lr
80008f48:	fb 48 06 8c 	st.w	sp[1676],r8
80008f4c:	58 78       	cp.w	r8,7
80008f4e:	e0 89 00 04 	brgt	80008f56 <_vfprintf_r+0x1ab6>
80008f52:	2f 83       	sub	r3,-8
80008f54:	c0 b8       	rjmp	80008f6a <_vfprintf_r+0x1aca>
80008f56:	fa ca f9 78 	sub	r10,sp,-1672
80008f5a:	02 9b       	mov	r11,r1
80008f5c:	08 9c       	mov	r12,r4
80008f5e:	fe b0 f2 93 	rcall	80007484 <__sprint_r>
80008f62:	e0 81 02 1e 	brne	8000939e <_vfprintf_r+0x1efe>
80008f66:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f6a:	21 02       	sub	r2,16
80008f6c:	c0 38       	rjmp	80008f72 <_vfprintf_r+0x1ad2>
80008f6e:	fe c0 bc de 	sub	r0,pc,-17186
80008f72:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f76:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f7a:	fe ca bc ea 	sub	r10,pc,-17174
80008f7e:	59 02       	cp.w	r2,16
80008f80:	fe 99 ff dd 	brgt	80008f3a <_vfprintf_r+0x1a9a>
80008f84:	04 09       	add	r9,r2
80008f86:	2f f8       	sub	r8,-1
80008f88:	87 0a       	st.w	r3[0x0],r10
80008f8a:	fb 49 06 90 	st.w	sp[1680],r9
80008f8e:	87 12       	st.w	r3[0x4],r2
80008f90:	fb 48 06 8c 	st.w	sp[1676],r8
80008f94:	58 78       	cp.w	r8,7
80008f96:	e0 89 00 04 	brgt	80008f9e <_vfprintf_r+0x1afe>
80008f9a:	2f 83       	sub	r3,-8
80008f9c:	c0 b8       	rjmp	80008fb2 <_vfprintf_r+0x1b12>
80008f9e:	fa ca f9 78 	sub	r10,sp,-1672
80008fa2:	02 9b       	mov	r11,r1
80008fa4:	08 9c       	mov	r12,r4
80008fa6:	fe b0 f2 6f 	rcall	80007484 <__sprint_r>
80008faa:	e0 81 01 fa 	brne	8000939e <_vfprintf_r+0x1efe>
80008fae:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fb2:	40 6c       	lddsp	r12,sp[0x18]
80008fb4:	fa f8 06 90 	ld.w	r8,sp[1680]
80008fb8:	87 06       	st.w	r3[0x0],r6
80008fba:	87 1c       	st.w	r3[0x4],r12
80008fbc:	18 08       	add	r8,r12
80008fbe:	cb 98       	rjmp	80009130 <_vfprintf_r+0x1c90>
80008fc0:	fa f9 06 90 	ld.w	r9,sp[1680]
80008fc4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fc8:	40 6b       	lddsp	r11,sp[0x18]
80008fca:	16 3a       	cp.w	r10,r11
80008fcc:	c6 f5       	brlt	800090aa <_vfprintf_r+0x1c0a>
80008fce:	16 09       	add	r9,r11
80008fd0:	2f f8       	sub	r8,-1
80008fd2:	87 06       	st.w	r3[0x0],r6
80008fd4:	fb 49 06 90 	st.w	sp[1680],r9
80008fd8:	87 1b       	st.w	r3[0x4],r11
80008fda:	fb 48 06 8c 	st.w	sp[1676],r8
80008fde:	58 78       	cp.w	r8,7
80008fe0:	e0 89 00 04 	brgt	80008fe8 <_vfprintf_r+0x1b48>
80008fe4:	2f 83       	sub	r3,-8
80008fe6:	c0 b8       	rjmp	80008ffc <_vfprintf_r+0x1b5c>
80008fe8:	fa ca f9 78 	sub	r10,sp,-1672
80008fec:	02 9b       	mov	r11,r1
80008fee:	08 9c       	mov	r12,r4
80008ff0:	fe b0 f2 4a 	rcall	80007484 <__sprint_r>
80008ff4:	e0 81 01 d5 	brne	8000939e <_vfprintf_r+0x1efe>
80008ff8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ffc:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009000:	40 6a       	lddsp	r10,sp[0x18]
80009002:	14 16       	sub	r6,r10
80009004:	58 06       	cp.w	r6,0
80009006:	e0 89 00 1c 	brgt	8000903e <_vfprintf_r+0x1b9e>
8000900a:	c3 d8       	rjmp	80009084 <_vfprintf_r+0x1be4>
8000900c:	2f 09       	sub	r9,-16
8000900e:	2f f8       	sub	r8,-1
80009010:	fb 49 06 90 	st.w	sp[1680],r9
80009014:	87 02       	st.w	r3[0x0],r2
80009016:	87 10       	st.w	r3[0x4],r0
80009018:	fb 48 06 8c 	st.w	sp[1676],r8
8000901c:	58 78       	cp.w	r8,7
8000901e:	e0 89 00 04 	brgt	80009026 <_vfprintf_r+0x1b86>
80009022:	2f 83       	sub	r3,-8
80009024:	c0 b8       	rjmp	8000903a <_vfprintf_r+0x1b9a>
80009026:	fa ca f9 78 	sub	r10,sp,-1672
8000902a:	02 9b       	mov	r11,r1
8000902c:	08 9c       	mov	r12,r4
8000902e:	fe b0 f2 2b 	rcall	80007484 <__sprint_r>
80009032:	e0 81 01 b6 	brne	8000939e <_vfprintf_r+0x1efe>
80009036:	fa c3 f9 e0 	sub	r3,sp,-1568
8000903a:	21 06       	sub	r6,16
8000903c:	c0 48       	rjmp	80009044 <_vfprintf_r+0x1ba4>
8000903e:	fe c2 bd ae 	sub	r2,pc,-16978
80009042:	31 00       	mov	r0,16
80009044:	fa f9 06 90 	ld.w	r9,sp[1680]
80009048:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000904c:	fe ca bd bc 	sub	r10,pc,-16964
80009050:	59 06       	cp.w	r6,16
80009052:	fe 99 ff dd 	brgt	8000900c <_vfprintf_r+0x1b6c>
80009056:	0c 09       	add	r9,r6
80009058:	2f f8       	sub	r8,-1
8000905a:	87 0a       	st.w	r3[0x0],r10
8000905c:	fb 49 06 90 	st.w	sp[1680],r9
80009060:	87 16       	st.w	r3[0x4],r6
80009062:	fb 48 06 8c 	st.w	sp[1676],r8
80009066:	58 78       	cp.w	r8,7
80009068:	e0 89 00 04 	brgt	80009070 <_vfprintf_r+0x1bd0>
8000906c:	2f 83       	sub	r3,-8
8000906e:	c0 b8       	rjmp	80009084 <_vfprintf_r+0x1be4>
80009070:	fa ca f9 78 	sub	r10,sp,-1672
80009074:	02 9b       	mov	r11,r1
80009076:	08 9c       	mov	r12,r4
80009078:	fe b0 f2 06 	rcall	80007484 <__sprint_r>
8000907c:	e0 81 01 91 	brne	8000939e <_vfprintf_r+0x1efe>
80009080:	fa c3 f9 e0 	sub	r3,sp,-1568
80009084:	ed b5 00 00 	bld	r5,0x0
80009088:	e0 81 01 20 	brne	800092c8 <_vfprintf_r+0x1e28>
8000908c:	40 c9       	lddsp	r9,sp[0x30]
8000908e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009092:	2f f8       	sub	r8,-1
80009094:	87 09       	st.w	r3[0x0],r9
80009096:	fb 48 06 90 	st.w	sp[1680],r8
8000909a:	30 19       	mov	r9,1
8000909c:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090a0:	87 19       	st.w	r3[0x4],r9
800090a2:	2f f8       	sub	r8,-1
800090a4:	fb 48 06 8c 	st.w	sp[1676],r8
800090a8:	c0 29       	rjmp	800092ac <_vfprintf_r+0x1e0c>
800090aa:	14 09       	add	r9,r10
800090ac:	2f f8       	sub	r8,-1
800090ae:	fb 49 06 90 	st.w	sp[1680],r9
800090b2:	87 06       	st.w	r3[0x0],r6
800090b4:	87 1a       	st.w	r3[0x4],r10
800090b6:	fb 48 06 8c 	st.w	sp[1676],r8
800090ba:	58 78       	cp.w	r8,7
800090bc:	e0 89 00 04 	brgt	800090c4 <_vfprintf_r+0x1c24>
800090c0:	2f 83       	sub	r3,-8
800090c2:	c0 b8       	rjmp	800090d8 <_vfprintf_r+0x1c38>
800090c4:	fa ca f9 78 	sub	r10,sp,-1672
800090c8:	02 9b       	mov	r11,r1
800090ca:	08 9c       	mov	r12,r4
800090cc:	fe b0 f1 dc 	rcall	80007484 <__sprint_r>
800090d0:	e0 81 01 67 	brne	8000939e <_vfprintf_r+0x1efe>
800090d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800090d8:	40 c8       	lddsp	r8,sp[0x30]
800090da:	87 08       	st.w	r3[0x0],r8
800090dc:	fa f8 06 90 	ld.w	r8,sp[1680]
800090e0:	2f f8       	sub	r8,-1
800090e2:	30 19       	mov	r9,1
800090e4:	fb 48 06 90 	st.w	sp[1680],r8
800090e8:	87 19       	st.w	r3[0x4],r9
800090ea:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090ee:	2f f8       	sub	r8,-1
800090f0:	fb 48 06 8c 	st.w	sp[1676],r8
800090f4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800090f8:	58 78       	cp.w	r8,7
800090fa:	e0 89 00 04 	brgt	80009102 <_vfprintf_r+0x1c62>
800090fe:	2f 83       	sub	r3,-8
80009100:	c0 b8       	rjmp	80009116 <_vfprintf_r+0x1c76>
80009102:	fa ca f9 78 	sub	r10,sp,-1672
80009106:	02 9b       	mov	r11,r1
80009108:	08 9c       	mov	r12,r4
8000910a:	fe b0 f1 bd 	rcall	80007484 <__sprint_r>
8000910e:	e0 81 01 48 	brne	8000939e <_vfprintf_r+0x1efe>
80009112:	fa c3 f9 e0 	sub	r3,sp,-1568
80009116:	04 06       	add	r6,r2
80009118:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000911c:	87 06       	st.w	r3[0x0],r6
8000911e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009122:	40 66       	lddsp	r6,sp[0x18]
80009124:	40 6e       	lddsp	lr,sp[0x18]
80009126:	10 16       	sub	r6,r8
80009128:	f2 08 01 08 	sub	r8,r9,r8
8000912c:	87 16       	st.w	r3[0x4],r6
8000912e:	1c 08       	add	r8,lr
80009130:	fb 48 06 90 	st.w	sp[1680],r8
80009134:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009138:	2f f8       	sub	r8,-1
8000913a:	fb 48 06 8c 	st.w	sp[1676],r8
8000913e:	cb 78       	rjmp	800092ac <_vfprintf_r+0x1e0c>
80009140:	40 6c       	lddsp	r12,sp[0x18]
80009142:	58 1c       	cp.w	r12,1
80009144:	e0 89 00 06 	brgt	80009150 <_vfprintf_r+0x1cb0>
80009148:	ed b5 00 00 	bld	r5,0x0
8000914c:	e0 81 00 85 	brne	80009256 <_vfprintf_r+0x1db6>
80009150:	fa f8 06 90 	ld.w	r8,sp[1680]
80009154:	2f f8       	sub	r8,-1
80009156:	30 19       	mov	r9,1
80009158:	fb 48 06 90 	st.w	sp[1680],r8
8000915c:	87 06       	st.w	r3[0x0],r6
8000915e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009162:	87 19       	st.w	r3[0x4],r9
80009164:	2f f8       	sub	r8,-1
80009166:	fb 48 06 8c 	st.w	sp[1676],r8
8000916a:	58 78       	cp.w	r8,7
8000916c:	e0 89 00 04 	brgt	80009174 <_vfprintf_r+0x1cd4>
80009170:	2f 83       	sub	r3,-8
80009172:	c0 b8       	rjmp	80009188 <_vfprintf_r+0x1ce8>
80009174:	fa ca f9 78 	sub	r10,sp,-1672
80009178:	02 9b       	mov	r11,r1
8000917a:	08 9c       	mov	r12,r4
8000917c:	fe b0 f1 84 	rcall	80007484 <__sprint_r>
80009180:	e0 81 01 0f 	brne	8000939e <_vfprintf_r+0x1efe>
80009184:	fa c3 f9 e0 	sub	r3,sp,-1568
80009188:	fa f8 06 90 	ld.w	r8,sp[1680]
8000918c:	2f f8       	sub	r8,-1
8000918e:	40 cb       	lddsp	r11,sp[0x30]
80009190:	fb 48 06 90 	st.w	sp[1680],r8
80009194:	30 19       	mov	r9,1
80009196:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000919a:	87 0b       	st.w	r3[0x0],r11
8000919c:	2f f8       	sub	r8,-1
8000919e:	87 19       	st.w	r3[0x4],r9
800091a0:	fb 48 06 8c 	st.w	sp[1676],r8
800091a4:	58 78       	cp.w	r8,7
800091a6:	e0 89 00 05 	brgt	800091b0 <_vfprintf_r+0x1d10>
800091aa:	2f 83       	sub	r3,-8
800091ac:	c0 c8       	rjmp	800091c4 <_vfprintf_r+0x1d24>
800091ae:	d7 03       	nop
800091b0:	fa ca f9 78 	sub	r10,sp,-1672
800091b4:	02 9b       	mov	r11,r1
800091b6:	08 9c       	mov	r12,r4
800091b8:	fe b0 f1 66 	rcall	80007484 <__sprint_r>
800091bc:	e0 81 00 f1 	brne	8000939e <_vfprintf_r+0x1efe>
800091c0:	fa c3 f9 e0 	sub	r3,sp,-1568
800091c4:	30 08       	mov	r8,0
800091c6:	30 09       	mov	r9,0
800091c8:	40 5b       	lddsp	r11,sp[0x14]
800091ca:	40 7a       	lddsp	r10,sp[0x1c]
800091cc:	e0 a0 13 19 	rcall	8000b7fe <__avr32_f64_cmp_eq>
800091d0:	40 68       	lddsp	r8,sp[0x18]
800091d2:	20 18       	sub	r8,1
800091d4:	58 0c       	cp.w	r12,0
800091d6:	c0 d1       	brne	800091f0 <_vfprintf_r+0x1d50>
800091d8:	2f f6       	sub	r6,-1
800091da:	87 18       	st.w	r3[0x4],r8
800091dc:	87 06       	st.w	r3[0x0],r6
800091de:	fa f6 06 90 	ld.w	r6,sp[1680]
800091e2:	10 06       	add	r6,r8
800091e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091e8:	fb 46 06 90 	st.w	sp[1680],r6
800091ec:	2f f8       	sub	r8,-1
800091ee:	c3 18       	rjmp	80009250 <_vfprintf_r+0x1db0>
800091f0:	10 96       	mov	r6,r8
800091f2:	58 08       	cp.w	r8,0
800091f4:	e0 89 00 1c 	brgt	8000922c <_vfprintf_r+0x1d8c>
800091f8:	c4 b8       	rjmp	8000928e <_vfprintf_r+0x1dee>
800091fa:	2f 09       	sub	r9,-16
800091fc:	2f f8       	sub	r8,-1
800091fe:	fb 49 06 90 	st.w	sp[1680],r9
80009202:	87 02       	st.w	r3[0x0],r2
80009204:	87 10       	st.w	r3[0x4],r0
80009206:	fb 48 06 8c 	st.w	sp[1676],r8
8000920a:	58 78       	cp.w	r8,7
8000920c:	e0 89 00 04 	brgt	80009214 <_vfprintf_r+0x1d74>
80009210:	2f 83       	sub	r3,-8
80009212:	c0 b8       	rjmp	80009228 <_vfprintf_r+0x1d88>
80009214:	fa ca f9 78 	sub	r10,sp,-1672
80009218:	02 9b       	mov	r11,r1
8000921a:	08 9c       	mov	r12,r4
8000921c:	fe b0 f1 34 	rcall	80007484 <__sprint_r>
80009220:	e0 81 00 bf 	brne	8000939e <_vfprintf_r+0x1efe>
80009224:	fa c3 f9 e0 	sub	r3,sp,-1568
80009228:	21 06       	sub	r6,16
8000922a:	c0 48       	rjmp	80009232 <_vfprintf_r+0x1d92>
8000922c:	fe c2 bf 9c 	sub	r2,pc,-16484
80009230:	31 00       	mov	r0,16
80009232:	fa f9 06 90 	ld.w	r9,sp[1680]
80009236:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000923a:	fe ca bf aa 	sub	r10,pc,-16470
8000923e:	59 06       	cp.w	r6,16
80009240:	fe 99 ff dd 	brgt	800091fa <_vfprintf_r+0x1d5a>
80009244:	0c 09       	add	r9,r6
80009246:	87 0a       	st.w	r3[0x0],r10
80009248:	fb 49 06 90 	st.w	sp[1680],r9
8000924c:	2f f8       	sub	r8,-1
8000924e:	87 16       	st.w	r3[0x4],r6
80009250:	fb 48 06 8c 	st.w	sp[1676],r8
80009254:	c0 e8       	rjmp	80009270 <_vfprintf_r+0x1dd0>
80009256:	fa f8 06 90 	ld.w	r8,sp[1680]
8000925a:	2f f8       	sub	r8,-1
8000925c:	30 19       	mov	r9,1
8000925e:	fb 48 06 90 	st.w	sp[1680],r8
80009262:	87 06       	st.w	r3[0x0],r6
80009264:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009268:	87 19       	st.w	r3[0x4],r9
8000926a:	2f f8       	sub	r8,-1
8000926c:	fb 48 06 8c 	st.w	sp[1676],r8
80009270:	58 78       	cp.w	r8,7
80009272:	e0 89 00 04 	brgt	8000927a <_vfprintf_r+0x1dda>
80009276:	2f 83       	sub	r3,-8
80009278:	c0 b8       	rjmp	8000928e <_vfprintf_r+0x1dee>
8000927a:	fa ca f9 78 	sub	r10,sp,-1672
8000927e:	02 9b       	mov	r11,r1
80009280:	08 9c       	mov	r12,r4
80009282:	fe b0 f1 01 	rcall	80007484 <__sprint_r>
80009286:	e0 81 00 8c 	brne	8000939e <_vfprintf_r+0x1efe>
8000928a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000928e:	40 ea       	lddsp	r10,sp[0x38]
80009290:	fa f8 06 90 	ld.w	r8,sp[1680]
80009294:	14 08       	add	r8,r10
80009296:	fa c9 f9 64 	sub	r9,sp,-1692
8000929a:	fb 48 06 90 	st.w	sp[1680],r8
8000929e:	87 1a       	st.w	r3[0x4],r10
800092a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092a4:	87 09       	st.w	r3[0x0],r9
800092a6:	2f f8       	sub	r8,-1
800092a8:	fb 48 06 8c 	st.w	sp[1676],r8
800092ac:	58 78       	cp.w	r8,7
800092ae:	e0 89 00 04 	brgt	800092b6 <_vfprintf_r+0x1e16>
800092b2:	2f 83       	sub	r3,-8
800092b4:	c0 a8       	rjmp	800092c8 <_vfprintf_r+0x1e28>
800092b6:	fa ca f9 78 	sub	r10,sp,-1672
800092ba:	02 9b       	mov	r11,r1
800092bc:	08 9c       	mov	r12,r4
800092be:	fe b0 f0 e3 	rcall	80007484 <__sprint_r>
800092c2:	c6 e1       	brne	8000939e <_vfprintf_r+0x1efe>
800092c4:	fa c3 f9 e0 	sub	r3,sp,-1568
800092c8:	e2 15 00 04 	andl	r5,0x4,COH
800092cc:	c3 f0       	breq	8000934a <_vfprintf_r+0x1eaa>
800092ce:	40 86       	lddsp	r6,sp[0x20]
800092d0:	40 39       	lddsp	r9,sp[0xc]
800092d2:	12 16       	sub	r6,r9
800092d4:	58 06       	cp.w	r6,0
800092d6:	e0 89 00 1a 	brgt	8000930a <_vfprintf_r+0x1e6a>
800092da:	c3 88       	rjmp	8000934a <_vfprintf_r+0x1eaa>
800092dc:	2f 09       	sub	r9,-16
800092de:	2f f8       	sub	r8,-1
800092e0:	fb 49 06 90 	st.w	sp[1680],r9
800092e4:	87 05       	st.w	r3[0x0],r5
800092e6:	87 12       	st.w	r3[0x4],r2
800092e8:	fb 48 06 8c 	st.w	sp[1676],r8
800092ec:	58 78       	cp.w	r8,7
800092ee:	e0 89 00 04 	brgt	800092f6 <_vfprintf_r+0x1e56>
800092f2:	2f 83       	sub	r3,-8
800092f4:	c0 98       	rjmp	80009306 <_vfprintf_r+0x1e66>
800092f6:	00 9a       	mov	r10,r0
800092f8:	02 9b       	mov	r11,r1
800092fa:	08 9c       	mov	r12,r4
800092fc:	fe b0 f0 c4 	rcall	80007484 <__sprint_r>
80009300:	c4 f1       	brne	8000939e <_vfprintf_r+0x1efe>
80009302:	fa c3 f9 e0 	sub	r3,sp,-1568
80009306:	21 06       	sub	r6,16
80009308:	c0 68       	rjmp	80009314 <_vfprintf_r+0x1e74>
8000930a:	fe c5 c0 8a 	sub	r5,pc,-16246
8000930e:	31 02       	mov	r2,16
80009310:	fa c0 f9 78 	sub	r0,sp,-1672
80009314:	fa f9 06 90 	ld.w	r9,sp[1680]
80009318:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000931c:	fe ca c0 9c 	sub	r10,pc,-16228
80009320:	59 06       	cp.w	r6,16
80009322:	fe 99 ff dd 	brgt	800092dc <_vfprintf_r+0x1e3c>
80009326:	0c 09       	add	r9,r6
80009328:	2f f8       	sub	r8,-1
8000932a:	87 0a       	st.w	r3[0x0],r10
8000932c:	87 16       	st.w	r3[0x4],r6
8000932e:	fb 49 06 90 	st.w	sp[1680],r9
80009332:	fb 48 06 8c 	st.w	sp[1676],r8
80009336:	58 78       	cp.w	r8,7
80009338:	e0 8a 00 09 	brle	8000934a <_vfprintf_r+0x1eaa>
8000933c:	fa ca f9 78 	sub	r10,sp,-1672
80009340:	02 9b       	mov	r11,r1
80009342:	08 9c       	mov	r12,r4
80009344:	fe b0 f0 a0 	rcall	80007484 <__sprint_r>
80009348:	c2 b1       	brne	8000939e <_vfprintf_r+0x1efe>
8000934a:	40 bc       	lddsp	r12,sp[0x2c]
8000934c:	40 36       	lddsp	r6,sp[0xc]
8000934e:	40 8e       	lddsp	lr,sp[0x20]
80009350:	ec 0e 0c 48 	max	r8,r6,lr
80009354:	10 0c       	add	r12,r8
80009356:	50 bc       	stdsp	sp[0x2c],r12
80009358:	fa f8 06 90 	ld.w	r8,sp[1680]
8000935c:	58 08       	cp.w	r8,0
8000935e:	c0 80       	breq	8000936e <_vfprintf_r+0x1ece>
80009360:	fa ca f9 78 	sub	r10,sp,-1672
80009364:	02 9b       	mov	r11,r1
80009366:	08 9c       	mov	r12,r4
80009368:	fe b0 f0 8e 	rcall	80007484 <__sprint_r>
8000936c:	c1 91       	brne	8000939e <_vfprintf_r+0x1efe>
8000936e:	30 0b       	mov	r11,0
80009370:	fa c3 f9 e0 	sub	r3,sp,-1568
80009374:	fb 4b 06 8c 	st.w	sp[1676],r11
80009378:	fe 9f f1 22 	bral	800075bc <_vfprintf_r+0x11c>
8000937c:	08 95       	mov	r5,r4
8000937e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009382:	58 08       	cp.w	r8,0
80009384:	c0 80       	breq	80009394 <_vfprintf_r+0x1ef4>
80009386:	08 9c       	mov	r12,r4
80009388:	fa ca f9 78 	sub	r10,sp,-1672
8000938c:	02 9b       	mov	r11,r1
8000938e:	fe b0 f0 7b 	rcall	80007484 <__sprint_r>
80009392:	c0 61       	brne	8000939e <_vfprintf_r+0x1efe>
80009394:	30 08       	mov	r8,0
80009396:	fb 48 06 8c 	st.w	sp[1676],r8
8000939a:	c0 28       	rjmp	8000939e <_vfprintf_r+0x1efe>
8000939c:	40 41       	lddsp	r1,sp[0x10]
8000939e:	82 68       	ld.sh	r8,r1[0xc]
800093a0:	ed b8 00 06 	bld	r8,0x6
800093a4:	c0 31       	brne	800093aa <_vfprintf_r+0x1f0a>
800093a6:	3f fa       	mov	r10,-1
800093a8:	50 ba       	stdsp	sp[0x2c],r10
800093aa:	40 bc       	lddsp	r12,sp[0x2c]
800093ac:	fe 3d f9 44 	sub	sp,-1724
800093b0:	d8 32       	popm	r0-r7,pc
800093b2:	d7 03       	nop

800093b4 <__swsetup_r>:
800093b4:	d4 21       	pushm	r4-r7,lr
800093b6:	e0 68 0a 30 	mov	r8,2608
800093ba:	18 96       	mov	r6,r12
800093bc:	16 97       	mov	r7,r11
800093be:	70 0c       	ld.w	r12,r8[0x0]
800093c0:	58 0c       	cp.w	r12,0
800093c2:	c0 60       	breq	800093ce <__swsetup_r+0x1a>
800093c4:	78 68       	ld.w	r8,r12[0x18]
800093c6:	58 08       	cp.w	r8,0
800093c8:	c0 31       	brne	800093ce <__swsetup_r+0x1a>
800093ca:	e0 a0 07 bf 	rcall	8000a348 <__sinit>
800093ce:	fe c8 c0 1e 	sub	r8,pc,-16354
800093d2:	10 37       	cp.w	r7,r8
800093d4:	c0 61       	brne	800093e0 <__swsetup_r+0x2c>
800093d6:	e0 68 0a 30 	mov	r8,2608
800093da:	70 08       	ld.w	r8,r8[0x0]
800093dc:	70 07       	ld.w	r7,r8[0x0]
800093de:	c1 28       	rjmp	80009402 <__swsetup_r+0x4e>
800093e0:	fe c8 c0 10 	sub	r8,pc,-16368
800093e4:	10 37       	cp.w	r7,r8
800093e6:	c0 61       	brne	800093f2 <__swsetup_r+0x3e>
800093e8:	e0 68 0a 30 	mov	r8,2608
800093ec:	70 08       	ld.w	r8,r8[0x0]
800093ee:	70 17       	ld.w	r7,r8[0x4]
800093f0:	c0 98       	rjmp	80009402 <__swsetup_r+0x4e>
800093f2:	fe c8 c0 02 	sub	r8,pc,-16382
800093f6:	10 37       	cp.w	r7,r8
800093f8:	c0 51       	brne	80009402 <__swsetup_r+0x4e>
800093fa:	e0 68 0a 30 	mov	r8,2608
800093fe:	70 08       	ld.w	r8,r8[0x0]
80009400:	70 27       	ld.w	r7,r8[0x8]
80009402:	8e 68       	ld.sh	r8,r7[0xc]
80009404:	ed b8 00 03 	bld	r8,0x3
80009408:	c1 e0       	breq	80009444 <__swsetup_r+0x90>
8000940a:	ed b8 00 04 	bld	r8,0x4
8000940e:	c3 e1       	brne	8000948a <__swsetup_r+0xd6>
80009410:	ed b8 00 02 	bld	r8,0x2
80009414:	c1 51       	brne	8000943e <__swsetup_r+0x8a>
80009416:	6e db       	ld.w	r11,r7[0x34]
80009418:	58 0b       	cp.w	r11,0
8000941a:	c0 a0       	breq	8000942e <__swsetup_r+0x7a>
8000941c:	ee c8 ff bc 	sub	r8,r7,-68
80009420:	10 3b       	cp.w	r11,r8
80009422:	c0 40       	breq	8000942a <__swsetup_r+0x76>
80009424:	0c 9c       	mov	r12,r6
80009426:	e0 a0 08 2b 	rcall	8000a47c <_free_r>
8000942a:	30 08       	mov	r8,0
8000942c:	8f d8       	st.w	r7[0x34],r8
8000942e:	8e 68       	ld.sh	r8,r7[0xc]
80009430:	e0 18 ff db 	andl	r8,0xffdb
80009434:	ae 68       	st.h	r7[0xc],r8
80009436:	30 08       	mov	r8,0
80009438:	8f 18       	st.w	r7[0x4],r8
8000943a:	6e 48       	ld.w	r8,r7[0x10]
8000943c:	8f 08       	st.w	r7[0x0],r8
8000943e:	8e 68       	ld.sh	r8,r7[0xc]
80009440:	a3 b8       	sbr	r8,0x3
80009442:	ae 68       	st.h	r7[0xc],r8
80009444:	6e 48       	ld.w	r8,r7[0x10]
80009446:	58 08       	cp.w	r8,0
80009448:	c0 b1       	brne	8000945e <__swsetup_r+0xaa>
8000944a:	8e 68       	ld.sh	r8,r7[0xc]
8000944c:	e2 18 02 80 	andl	r8,0x280,COH
80009450:	e0 48 02 00 	cp.w	r8,512
80009454:	c0 50       	breq	8000945e <__swsetup_r+0xaa>
80009456:	0c 9c       	mov	r12,r6
80009458:	0e 9b       	mov	r11,r7
8000945a:	e0 a0 0a 4b 	rcall	8000a8f0 <__smakebuf_r>
8000945e:	8e 69       	ld.sh	r9,r7[0xc]
80009460:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009464:	c0 70       	breq	80009472 <__swsetup_r+0xbe>
80009466:	30 08       	mov	r8,0
80009468:	8f 28       	st.w	r7[0x8],r8
8000946a:	6e 58       	ld.w	r8,r7[0x14]
8000946c:	5c 38       	neg	r8
8000946e:	8f 68       	st.w	r7[0x18],r8
80009470:	c0 68       	rjmp	8000947c <__swsetup_r+0xc8>
80009472:	ed b9 00 01 	bld	r9,0x1
80009476:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000947a:	8f 28       	st.w	r7[0x8],r8
8000947c:	6e 48       	ld.w	r8,r7[0x10]
8000947e:	58 08       	cp.w	r8,0
80009480:	c0 61       	brne	8000948c <__swsetup_r+0xd8>
80009482:	8e 68       	ld.sh	r8,r7[0xc]
80009484:	ed b8 00 07 	bld	r8,0x7
80009488:	c0 21       	brne	8000948c <__swsetup_r+0xd8>
8000948a:	dc 2a       	popm	r4-r7,pc,r12=-1
8000948c:	d8 2a       	popm	r4-r7,pc,r12=0
8000948e:	d7 03       	nop

80009490 <quorem>:
80009490:	d4 31       	pushm	r0-r7,lr
80009492:	20 2d       	sub	sp,8
80009494:	18 97       	mov	r7,r12
80009496:	78 48       	ld.w	r8,r12[0x10]
80009498:	76 46       	ld.w	r6,r11[0x10]
8000949a:	0c 38       	cp.w	r8,r6
8000949c:	c0 34       	brge	800094a2 <quorem+0x12>
8000949e:	30 0c       	mov	r12,0
800094a0:	c8 58       	rjmp	800095aa <quorem+0x11a>
800094a2:	ec c2 ff fc 	sub	r2,r6,-4
800094a6:	f6 c3 ff ec 	sub	r3,r11,-20
800094aa:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800094ae:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800094b2:	2f f9       	sub	r9,-1
800094b4:	20 16       	sub	r6,1
800094b6:	f8 09 0d 08 	divu	r8,r12,r9
800094ba:	f6 02 00 22 	add	r2,r11,r2<<0x2
800094be:	ee c4 ff ec 	sub	r4,r7,-20
800094c2:	10 95       	mov	r5,r8
800094c4:	58 08       	cp.w	r8,0
800094c6:	c4 10       	breq	80009548 <quorem+0xb8>
800094c8:	30 09       	mov	r9,0
800094ca:	06 9a       	mov	r10,r3
800094cc:	08 98       	mov	r8,r4
800094ce:	12 91       	mov	r1,r9
800094d0:	50 0b       	stdsp	sp[0x0],r11
800094d2:	70 0e       	ld.w	lr,r8[0x0]
800094d4:	b1 8e       	lsr	lr,0x10
800094d6:	50 1e       	stdsp	sp[0x4],lr
800094d8:	15 0e       	ld.w	lr,r10++
800094da:	fc 00 16 10 	lsr	r0,lr,0x10
800094de:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800094e2:	ea 0e 03 41 	mac	r1,r5,lr
800094e6:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800094ea:	b1 81       	lsr	r1,0x10
800094ec:	40 1b       	lddsp	r11,sp[0x4]
800094ee:	ea 00 02 40 	mul	r0,r5,r0
800094f2:	e2 00 00 00 	add	r0,r1,r0
800094f6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800094fa:	02 1b       	sub	r11,r1
800094fc:	50 1b       	stdsp	sp[0x4],r11
800094fe:	70 0b       	ld.w	r11,r8[0x0]
80009500:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009504:	02 09       	add	r9,r1
80009506:	f2 0e 01 0e 	sub	lr,r9,lr
8000950a:	b0 1e       	st.h	r8[0x2],lr
8000950c:	fc 09 14 10 	asr	r9,lr,0x10
80009510:	40 1e       	lddsp	lr,sp[0x4]
80009512:	fc 09 00 09 	add	r9,lr,r9
80009516:	b0 09       	st.h	r8[0x0],r9
80009518:	e0 01 16 10 	lsr	r1,r0,0x10
8000951c:	2f c8       	sub	r8,-4
8000951e:	b1 49       	asr	r9,0x10
80009520:	04 3a       	cp.w	r10,r2
80009522:	fe 98 ff d8 	brls	800094d2 <quorem+0x42>
80009526:	40 0b       	lddsp	r11,sp[0x0]
80009528:	58 0c       	cp.w	r12,0
8000952a:	c0 f1       	brne	80009548 <quorem+0xb8>
8000952c:	ec c8 ff fb 	sub	r8,r6,-5
80009530:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009534:	c0 28       	rjmp	80009538 <quorem+0xa8>
80009536:	20 16       	sub	r6,1
80009538:	20 48       	sub	r8,4
8000953a:	08 38       	cp.w	r8,r4
8000953c:	e0 88 00 05 	brls	80009546 <quorem+0xb6>
80009540:	70 09       	ld.w	r9,r8[0x0]
80009542:	58 09       	cp.w	r9,0
80009544:	cf 90       	breq	80009536 <quorem+0xa6>
80009546:	8f 46       	st.w	r7[0x10],r6
80009548:	0e 9c       	mov	r12,r7
8000954a:	e0 a0 0a d2 	rcall	8000aaee <__mcmp>
8000954e:	c2 d5       	brlt	800095a8 <quorem+0x118>
80009550:	2f f5       	sub	r5,-1
80009552:	08 98       	mov	r8,r4
80009554:	30 09       	mov	r9,0
80009556:	07 0b       	ld.w	r11,r3++
80009558:	f6 0a 16 10 	lsr	r10,r11,0x10
8000955c:	70 0c       	ld.w	r12,r8[0x0]
8000955e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009562:	f8 0e 16 10 	lsr	lr,r12,0x10
80009566:	14 1e       	sub	lr,r10
80009568:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000956c:	16 1a       	sub	r10,r11
8000956e:	12 0a       	add	r10,r9
80009570:	b0 1a       	st.h	r8[0x2],r10
80009572:	b1 4a       	asr	r10,0x10
80009574:	fc 0a 00 09 	add	r9,lr,r10
80009578:	b0 09       	st.h	r8[0x0],r9
8000957a:	2f c8       	sub	r8,-4
8000957c:	b1 49       	asr	r9,0x10
8000957e:	04 33       	cp.w	r3,r2
80009580:	fe 98 ff eb 	brls	80009556 <quorem+0xc6>
80009584:	ec c8 ff fb 	sub	r8,r6,-5
80009588:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000958c:	58 09       	cp.w	r9,0
8000958e:	c0 d1       	brne	800095a8 <quorem+0x118>
80009590:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009594:	c0 28       	rjmp	80009598 <quorem+0x108>
80009596:	20 16       	sub	r6,1
80009598:	20 48       	sub	r8,4
8000959a:	08 38       	cp.w	r8,r4
8000959c:	e0 88 00 05 	brls	800095a6 <quorem+0x116>
800095a0:	70 09       	ld.w	r9,r8[0x0]
800095a2:	58 09       	cp.w	r9,0
800095a4:	cf 90       	breq	80009596 <quorem+0x106>
800095a6:	8f 46       	st.w	r7[0x10],r6
800095a8:	0a 9c       	mov	r12,r5
800095aa:	2f ed       	sub	sp,-8
800095ac:	d8 32       	popm	r0-r7,pc
800095ae:	d7 03       	nop

800095b0 <_dtoa_r>:
800095b0:	d4 31       	pushm	r0-r7,lr
800095b2:	21 ad       	sub	sp,104
800095b4:	fa c4 ff 74 	sub	r4,sp,-140
800095b8:	18 97       	mov	r7,r12
800095ba:	16 95       	mov	r5,r11
800095bc:	68 2c       	ld.w	r12,r4[0x8]
800095be:	50 c9       	stdsp	sp[0x30],r9
800095c0:	68 16       	ld.w	r6,r4[0x4]
800095c2:	68 09       	ld.w	r9,r4[0x0]
800095c4:	50 e8       	stdsp	sp[0x38],r8
800095c6:	14 94       	mov	r4,r10
800095c8:	51 2c       	stdsp	sp[0x48],r12
800095ca:	fa e5 00 08 	st.d	sp[8],r4
800095ce:	51 59       	stdsp	sp[0x54],r9
800095d0:	6e 95       	ld.w	r5,r7[0x24]
800095d2:	58 05       	cp.w	r5,0
800095d4:	c0 91       	brne	800095e6 <_dtoa_r+0x36>
800095d6:	31 0c       	mov	r12,16
800095d8:	fe b0 e8 e8 	rcall	800067a8 <malloc>
800095dc:	99 35       	st.w	r12[0xc],r5
800095de:	8f 9c       	st.w	r7[0x24],r12
800095e0:	99 15       	st.w	r12[0x4],r5
800095e2:	99 25       	st.w	r12[0x8],r5
800095e4:	99 05       	st.w	r12[0x0],r5
800095e6:	6e 99       	ld.w	r9,r7[0x24]
800095e8:	72 08       	ld.w	r8,r9[0x0]
800095ea:	58 08       	cp.w	r8,0
800095ec:	c0 f0       	breq	8000960a <_dtoa_r+0x5a>
800095ee:	72 1a       	ld.w	r10,r9[0x4]
800095f0:	91 1a       	st.w	r8[0x4],r10
800095f2:	30 1a       	mov	r10,1
800095f4:	72 19       	ld.w	r9,r9[0x4]
800095f6:	f4 09 09 49 	lsl	r9,r10,r9
800095fa:	10 9b       	mov	r11,r8
800095fc:	91 29       	st.w	r8[0x8],r9
800095fe:	0e 9c       	mov	r12,r7
80009600:	e0 a0 0a 90 	rcall	8000ab20 <_Bfree>
80009604:	6e 98       	ld.w	r8,r7[0x24]
80009606:	30 09       	mov	r9,0
80009608:	91 09       	st.w	r8[0x0],r9
8000960a:	40 28       	lddsp	r8,sp[0x8]
8000960c:	10 94       	mov	r4,r8
8000960e:	58 08       	cp.w	r8,0
80009610:	c0 64       	brge	8000961c <_dtoa_r+0x6c>
80009612:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009616:	50 28       	stdsp	sp[0x8],r8
80009618:	30 18       	mov	r8,1
8000961a:	c0 28       	rjmp	8000961e <_dtoa_r+0x6e>
8000961c:	30 08       	mov	r8,0
8000961e:	8d 08       	st.w	r6[0x0],r8
80009620:	fc 1c 7f f0 	movh	r12,0x7ff0
80009624:	40 26       	lddsp	r6,sp[0x8]
80009626:	0c 98       	mov	r8,r6
80009628:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000962c:	18 38       	cp.w	r8,r12
8000962e:	c2 01       	brne	8000966e <_dtoa_r+0xbe>
80009630:	e0 68 27 0f 	mov	r8,9999
80009634:	41 5b       	lddsp	r11,sp[0x54]
80009636:	97 08       	st.w	r11[0x0],r8
80009638:	40 3a       	lddsp	r10,sp[0xc]
8000963a:	58 0a       	cp.w	r10,0
8000963c:	c0 71       	brne	8000964a <_dtoa_r+0x9a>
8000963e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009642:	c0 41       	brne	8000964a <_dtoa_r+0x9a>
80009644:	fe cc c2 a4 	sub	r12,pc,-15708
80009648:	c0 38       	rjmp	8000964e <_dtoa_r+0x9e>
8000964a:	fe cc c2 9e 	sub	r12,pc,-15714
8000964e:	41 29       	lddsp	r9,sp[0x48]
80009650:	58 09       	cp.w	r9,0
80009652:	e0 80 05 9a 	breq	8000a186 <_dtoa_r+0xbd6>
80009656:	f8 c8 ff fd 	sub	r8,r12,-3
8000965a:	f8 c9 ff f8 	sub	r9,r12,-8
8000965e:	11 8b       	ld.ub	r11,r8[0x0]
80009660:	30 0a       	mov	r10,0
80009662:	41 25       	lddsp	r5,sp[0x48]
80009664:	f4 0b 18 00 	cp.b	r11,r10
80009668:	f2 08 17 10 	movne	r8,r9
8000966c:	c1 68       	rjmp	80009698 <_dtoa_r+0xe8>
8000966e:	fa ea 00 08 	ld.d	r10,sp[8]
80009672:	30 08       	mov	r8,0
80009674:	fa eb 00 3c 	st.d	sp[60],r10
80009678:	30 09       	mov	r9,0
8000967a:	e0 a0 10 c2 	rcall	8000b7fe <__avr32_f64_cmp_eq>
8000967e:	c1 00       	breq	8000969e <_dtoa_r+0xee>
80009680:	30 18       	mov	r8,1
80009682:	41 5a       	lddsp	r10,sp[0x54]
80009684:	95 08       	st.w	r10[0x0],r8
80009686:	fe cc c4 0a 	sub	r12,pc,-15350
8000968a:	41 29       	lddsp	r9,sp[0x48]
8000968c:	f8 08 00 08 	add	r8,r12,r8
80009690:	58 09       	cp.w	r9,0
80009692:	e0 80 05 7a 	breq	8000a186 <_dtoa_r+0xbd6>
80009696:	12 95       	mov	r5,r9
80009698:	8b 08       	st.w	r5[0x0],r8
8000969a:	e0 8f 05 76 	bral	8000a186 <_dtoa_r+0xbd6>
8000969e:	fa c8 ff 9c 	sub	r8,sp,-100
800096a2:	fa c9 ff a0 	sub	r9,sp,-96
800096a6:	fa ea 00 3c 	ld.d	r10,sp[60]
800096aa:	0e 9c       	mov	r12,r7
800096ac:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
800096b0:	e0 a0 0a 8a 	rcall	8000abc4 <__d2b>
800096b4:	18 93       	mov	r3,r12
800096b6:	58 05       	cp.w	r5,0
800096b8:	c0 d0       	breq	800096d2 <_dtoa_r+0x122>
800096ba:	fa ea 00 3c 	ld.d	r10,sp[60]
800096be:	30 04       	mov	r4,0
800096c0:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800096c4:	ea c5 03 ff 	sub	r5,r5,1023
800096c8:	10 9b       	mov	r11,r8
800096ca:	51 74       	stdsp	sp[0x5c],r4
800096cc:	ea 1b 3f f0 	orh	r11,0x3ff0
800096d0:	c2 58       	rjmp	8000971a <_dtoa_r+0x16a>
800096d2:	41 88       	lddsp	r8,sp[0x60]
800096d4:	41 9c       	lddsp	r12,sp[0x64]
800096d6:	10 0c       	add	r12,r8
800096d8:	f8 c5 fb ce 	sub	r5,r12,-1074
800096dc:	e0 45 00 20 	cp.w	r5,32
800096e0:	e0 8a 00 0e 	brle	800096fc <_dtoa_r+0x14c>
800096e4:	f8 cc fb ee 	sub	r12,r12,-1042
800096e8:	40 3b       	lddsp	r11,sp[0xc]
800096ea:	ea 08 11 40 	rsub	r8,r5,64
800096ee:	f6 0c 0a 4c 	lsr	r12,r11,r12
800096f2:	ec 08 09 46 	lsl	r6,r6,r8
800096f6:	0c 4c       	or	r12,r6
800096f8:	c0 78       	rjmp	80009706 <_dtoa_r+0x156>
800096fa:	d7 03       	nop
800096fc:	ea 0c 11 20 	rsub	r12,r5,32
80009700:	40 3a       	lddsp	r10,sp[0xc]
80009702:	f4 0c 09 4c 	lsl	r12,r10,r12
80009706:	e0 a0 10 08 	rcall	8000b716 <__avr32_u32_to_f64>
8000970a:	fc 18 fe 10 	movh	r8,0xfe10
8000970e:	30 19       	mov	r9,1
80009710:	ea c5 04 33 	sub	r5,r5,1075
80009714:	f0 0b 00 0b 	add	r11,r8,r11
80009718:	51 79       	stdsp	sp[0x5c],r9
8000971a:	30 08       	mov	r8,0
8000971c:	fc 19 3f f8 	movh	r9,0x3ff8
80009720:	e0 a0 0e 90 	rcall	8000b440 <__avr32_f64_sub>
80009724:	e0 68 43 61 	mov	r8,17249
80009728:	ea 18 63 6f 	orh	r8,0x636f
8000972c:	e0 69 87 a7 	mov	r9,34727
80009730:	ea 19 3f d2 	orh	r9,0x3fd2
80009734:	e0 a0 0d 9a 	rcall	8000b268 <__avr32_f64_mul>
80009738:	e0 68 c8 b3 	mov	r8,51379
8000973c:	ea 18 8b 60 	orh	r8,0x8b60
80009740:	e0 69 8a 28 	mov	r9,35368
80009744:	ea 19 3f c6 	orh	r9,0x3fc6
80009748:	e0 a0 0f 4a 	rcall	8000b5dc <__avr32_f64_add>
8000974c:	0a 9c       	mov	r12,r5
8000974e:	14 90       	mov	r0,r10
80009750:	16 91       	mov	r1,r11
80009752:	e0 a0 0f e6 	rcall	8000b71e <__avr32_s32_to_f64>
80009756:	e0 68 79 fb 	mov	r8,31227
8000975a:	ea 18 50 9f 	orh	r8,0x509f
8000975e:	e0 69 44 13 	mov	r9,17427
80009762:	ea 19 3f d3 	orh	r9,0x3fd3
80009766:	e0 a0 0d 81 	rcall	8000b268 <__avr32_f64_mul>
8000976a:	14 98       	mov	r8,r10
8000976c:	16 99       	mov	r9,r11
8000976e:	00 9a       	mov	r10,r0
80009770:	02 9b       	mov	r11,r1
80009772:	e0 a0 0f 35 	rcall	8000b5dc <__avr32_f64_add>
80009776:	14 90       	mov	r0,r10
80009778:	16 91       	mov	r1,r11
8000977a:	e0 a0 0f bb 	rcall	8000b6f0 <__avr32_f64_to_s32>
8000977e:	30 08       	mov	r8,0
80009780:	18 96       	mov	r6,r12
80009782:	30 09       	mov	r9,0
80009784:	00 9a       	mov	r10,r0
80009786:	02 9b       	mov	r11,r1
80009788:	e0 a0 10 82 	rcall	8000b88c <__avr32_f64_cmp_lt>
8000978c:	c0 c0       	breq	800097a4 <_dtoa_r+0x1f4>
8000978e:	0c 9c       	mov	r12,r6
80009790:	e0 a0 0f c7 	rcall	8000b71e <__avr32_s32_to_f64>
80009794:	14 98       	mov	r8,r10
80009796:	16 99       	mov	r9,r11
80009798:	00 9a       	mov	r10,r0
8000979a:	02 9b       	mov	r11,r1
8000979c:	e0 a0 10 31 	rcall	8000b7fe <__avr32_f64_cmp_eq>
800097a0:	f7 b6 00 01 	subeq	r6,1
800097a4:	59 66       	cp.w	r6,22
800097a6:	e0 88 00 05 	brls	800097b0 <_dtoa_r+0x200>
800097aa:	30 18       	mov	r8,1
800097ac:	51 48       	stdsp	sp[0x50],r8
800097ae:	c1 38       	rjmp	800097d4 <_dtoa_r+0x224>
800097b0:	fe c8 c3 50 	sub	r8,pc,-15536
800097b4:	fa ea 00 3c 	ld.d	r10,sp[60]
800097b8:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800097bc:	e0 a0 10 68 	rcall	8000b88c <__avr32_f64_cmp_lt>
800097c0:	f9 b4 00 00 	moveq	r4,0
800097c4:	fb f4 0a 14 	st.weq	sp[0x50],r4
800097c8:	f7 b6 01 01 	subne	r6,1
800097cc:	f9 bc 01 00 	movne	r12,0
800097d0:	fb fc 1a 14 	st.wne	sp[0x50],r12
800097d4:	41 90       	lddsp	r0,sp[0x64]
800097d6:	20 10       	sub	r0,1
800097d8:	0a 10       	sub	r0,r5
800097da:	c0 46       	brmi	800097e2 <_dtoa_r+0x232>
800097dc:	50 40       	stdsp	sp[0x10],r0
800097de:	30 00       	mov	r0,0
800097e0:	c0 48       	rjmp	800097e8 <_dtoa_r+0x238>
800097e2:	30 0b       	mov	r11,0
800097e4:	5c 30       	neg	r0
800097e6:	50 4b       	stdsp	sp[0x10],r11
800097e8:	ec 02 11 00 	rsub	r2,r6,0
800097ec:	58 06       	cp.w	r6,0
800097ee:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800097f2:	f5 d6 e4 0a 	addge	r10,r10,r6
800097f6:	fb fa 4a 04 	st.wge	sp[0x10],r10
800097fa:	fb f6 4a 11 	st.wge	sp[0x44],r6
800097fe:	f9 b2 04 00 	movge	r2,0
80009802:	e1 d6 e5 10 	sublt	r0,r0,r6
80009806:	f9 b9 05 00 	movlt	r9,0
8000980a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000980e:	40 c8       	lddsp	r8,sp[0x30]
80009810:	58 98       	cp.w	r8,9
80009812:	e0 8b 00 20 	brhi	80009852 <_dtoa_r+0x2a2>
80009816:	58 58       	cp.w	r8,5
80009818:	f9 b4 0a 01 	movle	r4,1
8000981c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009820:	f7 b5 09 04 	subgt	r5,4
80009824:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009828:	f9 b4 09 00 	movgt	r4,0
8000982c:	40 cc       	lddsp	r12,sp[0x30]
8000982e:	58 3c       	cp.w	r12,3
80009830:	c2 d0       	breq	8000988a <_dtoa_r+0x2da>
80009832:	e0 89 00 05 	brgt	8000983c <_dtoa_r+0x28c>
80009836:	58 2c       	cp.w	r12,2
80009838:	c1 01       	brne	80009858 <_dtoa_r+0x2a8>
8000983a:	c1 88       	rjmp	8000986a <_dtoa_r+0x2ba>
8000983c:	40 cb       	lddsp	r11,sp[0x30]
8000983e:	58 4b       	cp.w	r11,4
80009840:	c0 60       	breq	8000984c <_dtoa_r+0x29c>
80009842:	58 5b       	cp.w	r11,5
80009844:	c0 a1       	brne	80009858 <_dtoa_r+0x2a8>
80009846:	30 1a       	mov	r10,1
80009848:	50 da       	stdsp	sp[0x34],r10
8000984a:	c2 28       	rjmp	8000988e <_dtoa_r+0x2de>
8000984c:	30 19       	mov	r9,1
8000984e:	50 d9       	stdsp	sp[0x34],r9
80009850:	c0 f8       	rjmp	8000986e <_dtoa_r+0x2be>
80009852:	30 08       	mov	r8,0
80009854:	30 14       	mov	r4,1
80009856:	50 c8       	stdsp	sp[0x30],r8
80009858:	3f f5       	mov	r5,-1
8000985a:	30 1c       	mov	r12,1
8000985c:	30 0b       	mov	r11,0
8000985e:	50 95       	stdsp	sp[0x24],r5
80009860:	50 dc       	stdsp	sp[0x34],r12
80009862:	0a 91       	mov	r1,r5
80009864:	31 28       	mov	r8,18
80009866:	50 eb       	stdsp	sp[0x38],r11
80009868:	c2 08       	rjmp	800098a8 <_dtoa_r+0x2f8>
8000986a:	30 0a       	mov	r10,0
8000986c:	50 da       	stdsp	sp[0x34],r10
8000986e:	40 e9       	lddsp	r9,sp[0x38]
80009870:	58 09       	cp.w	r9,0
80009872:	e0 89 00 07 	brgt	80009880 <_dtoa_r+0x2d0>
80009876:	30 18       	mov	r8,1
80009878:	50 98       	stdsp	sp[0x24],r8
8000987a:	10 91       	mov	r1,r8
8000987c:	50 e8       	stdsp	sp[0x38],r8
8000987e:	c1 58       	rjmp	800098a8 <_dtoa_r+0x2f8>
80009880:	40 e5       	lddsp	r5,sp[0x38]
80009882:	50 95       	stdsp	sp[0x24],r5
80009884:	0a 91       	mov	r1,r5
80009886:	0a 98       	mov	r8,r5
80009888:	c1 08       	rjmp	800098a8 <_dtoa_r+0x2f8>
8000988a:	30 0c       	mov	r12,0
8000988c:	50 dc       	stdsp	sp[0x34],r12
8000988e:	40 eb       	lddsp	r11,sp[0x38]
80009890:	ec 0b 00 0b 	add	r11,r6,r11
80009894:	50 9b       	stdsp	sp[0x24],r11
80009896:	16 98       	mov	r8,r11
80009898:	2f f8       	sub	r8,-1
8000989a:	58 08       	cp.w	r8,0
8000989c:	e0 89 00 05 	brgt	800098a6 <_dtoa_r+0x2f6>
800098a0:	10 91       	mov	r1,r8
800098a2:	30 18       	mov	r8,1
800098a4:	c0 28       	rjmp	800098a8 <_dtoa_r+0x2f8>
800098a6:	10 91       	mov	r1,r8
800098a8:	30 09       	mov	r9,0
800098aa:	6e 9a       	ld.w	r10,r7[0x24]
800098ac:	95 19       	st.w	r10[0x4],r9
800098ae:	30 49       	mov	r9,4
800098b0:	c0 68       	rjmp	800098bc <_dtoa_r+0x30c>
800098b2:	d7 03       	nop
800098b4:	6a 1a       	ld.w	r10,r5[0x4]
800098b6:	a1 79       	lsl	r9,0x1
800098b8:	2f fa       	sub	r10,-1
800098ba:	8b 1a       	st.w	r5[0x4],r10
800098bc:	6e 95       	ld.w	r5,r7[0x24]
800098be:	f2 ca ff ec 	sub	r10,r9,-20
800098c2:	10 3a       	cp.w	r10,r8
800098c4:	fe 98 ff f8 	brls	800098b4 <_dtoa_r+0x304>
800098c8:	6a 1b       	ld.w	r11,r5[0x4]
800098ca:	0e 9c       	mov	r12,r7
800098cc:	e0 a0 09 44 	rcall	8000ab54 <_Balloc>
800098d0:	58 e1       	cp.w	r1,14
800098d2:	5f 88       	srls	r8
800098d4:	8b 0c       	st.w	r5[0x0],r12
800098d6:	f1 e4 00 04 	and	r4,r8,r4
800098da:	6e 98       	ld.w	r8,r7[0x24]
800098dc:	70 08       	ld.w	r8,r8[0x0]
800098de:	50 88       	stdsp	sp[0x20],r8
800098e0:	e0 80 01 82 	breq	80009be4 <_dtoa_r+0x634>
800098e4:	58 06       	cp.w	r6,0
800098e6:	e0 8a 00 43 	brle	8000996c <_dtoa_r+0x3bc>
800098ea:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800098ee:	fe c8 c4 8e 	sub	r8,pc,-15218
800098f2:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800098f6:	fa e5 00 18 	st.d	sp[24],r4
800098fa:	ec 04 14 04 	asr	r4,r6,0x4
800098fe:	ed b4 00 04 	bld	r4,0x4
80009902:	c0 30       	breq	80009908 <_dtoa_r+0x358>
80009904:	30 25       	mov	r5,2
80009906:	c1 08       	rjmp	80009926 <_dtoa_r+0x376>
80009908:	fe c8 c3 e0 	sub	r8,pc,-15392
8000990c:	f0 e8 00 20 	ld.d	r8,r8[32]
80009910:	fa ea 00 3c 	ld.d	r10,sp[60]
80009914:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009918:	e0 a0 0f ee 	rcall	8000b8f4 <__avr32_f64_div>
8000991c:	30 35       	mov	r5,3
8000991e:	14 98       	mov	r8,r10
80009920:	16 99       	mov	r9,r11
80009922:	fa e9 00 08 	st.d	sp[8],r8
80009926:	fe cc c3 fe 	sub	r12,pc,-15362
8000992a:	50 a3       	stdsp	sp[0x28],r3
8000992c:	0c 93       	mov	r3,r6
8000992e:	18 96       	mov	r6,r12
80009930:	c0 f8       	rjmp	8000994e <_dtoa_r+0x39e>
80009932:	fa ea 00 18 	ld.d	r10,sp[24]
80009936:	ed b4 00 00 	bld	r4,0x0
8000993a:	c0 81       	brne	8000994a <_dtoa_r+0x39a>
8000993c:	ec e8 00 00 	ld.d	r8,r6[0]
80009940:	2f f5       	sub	r5,-1
80009942:	e0 a0 0c 93 	rcall	8000b268 <__avr32_f64_mul>
80009946:	fa eb 00 18 	st.d	sp[24],r10
8000994a:	a1 54       	asr	r4,0x1
8000994c:	2f 86       	sub	r6,-8
8000994e:	58 04       	cp.w	r4,0
80009950:	cf 11       	brne	80009932 <_dtoa_r+0x382>
80009952:	fa e8 00 18 	ld.d	r8,sp[24]
80009956:	fa ea 00 08 	ld.d	r10,sp[8]
8000995a:	06 96       	mov	r6,r3
8000995c:	e0 a0 0f cc 	rcall	8000b8f4 <__avr32_f64_div>
80009960:	40 a3       	lddsp	r3,sp[0x28]
80009962:	14 98       	mov	r8,r10
80009964:	16 99       	mov	r9,r11
80009966:	fa e9 00 08 	st.d	sp[8],r8
8000996a:	c2 f8       	rjmp	800099c8 <_dtoa_r+0x418>
8000996c:	ec 08 11 00 	rsub	r8,r6,0
80009970:	c0 31       	brne	80009976 <_dtoa_r+0x3c6>
80009972:	30 25       	mov	r5,2
80009974:	c2 a8       	rjmp	800099c8 <_dtoa_r+0x418>
80009976:	fe cc c4 4e 	sub	r12,pc,-15282
8000997a:	f0 04 14 04 	asr	r4,r8,0x4
8000997e:	50 1c       	stdsp	sp[0x4],r12
80009980:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009984:	fe c9 c5 24 	sub	r9,pc,-15068
80009988:	fa ea 00 3c 	ld.d	r10,sp[60]
8000998c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009990:	e0 a0 0c 6c 	rcall	8000b268 <__avr32_f64_mul>
80009994:	40 1c       	lddsp	r12,sp[0x4]
80009996:	50 63       	stdsp	sp[0x18],r3
80009998:	30 25       	mov	r5,2
8000999a:	0c 93       	mov	r3,r6
8000999c:	fa eb 00 08 	st.d	sp[8],r10
800099a0:	18 96       	mov	r6,r12
800099a2:	c0 f8       	rjmp	800099c0 <_dtoa_r+0x410>
800099a4:	fa ea 00 08 	ld.d	r10,sp[8]
800099a8:	ed b4 00 00 	bld	r4,0x0
800099ac:	c0 81       	brne	800099bc <_dtoa_r+0x40c>
800099ae:	ec e8 00 00 	ld.d	r8,r6[0]
800099b2:	2f f5       	sub	r5,-1
800099b4:	e0 a0 0c 5a 	rcall	8000b268 <__avr32_f64_mul>
800099b8:	fa eb 00 08 	st.d	sp[8],r10
800099bc:	a1 54       	asr	r4,0x1
800099be:	2f 86       	sub	r6,-8
800099c0:	58 04       	cp.w	r4,0
800099c2:	cf 11       	brne	800099a4 <_dtoa_r+0x3f4>
800099c4:	06 96       	mov	r6,r3
800099c6:	40 63       	lddsp	r3,sp[0x18]
800099c8:	41 4a       	lddsp	r10,sp[0x50]
800099ca:	58 0a       	cp.w	r10,0
800099cc:	c2 a0       	breq	80009a20 <_dtoa_r+0x470>
800099ce:	fa e8 00 08 	ld.d	r8,sp[8]
800099d2:	58 01       	cp.w	r1,0
800099d4:	5f 94       	srgt	r4
800099d6:	fa e9 00 18 	st.d	sp[24],r8
800099da:	30 08       	mov	r8,0
800099dc:	fc 19 3f f0 	movh	r9,0x3ff0
800099e0:	fa ea 00 18 	ld.d	r10,sp[24]
800099e4:	e0 a0 0f 54 	rcall	8000b88c <__avr32_f64_cmp_lt>
800099e8:	f9 bc 00 00 	moveq	r12,0
800099ec:	f9 bc 01 01 	movne	r12,1
800099f0:	e9 ec 00 0c 	and	r12,r4,r12
800099f4:	c1 60       	breq	80009a20 <_dtoa_r+0x470>
800099f6:	40 98       	lddsp	r8,sp[0x24]
800099f8:	58 08       	cp.w	r8,0
800099fa:	e0 8a 00 f1 	brle	80009bdc <_dtoa_r+0x62c>
800099fe:	30 08       	mov	r8,0
80009a00:	fc 19 40 24 	movh	r9,0x4024
80009a04:	ec c4 00 01 	sub	r4,r6,1
80009a08:	fa ea 00 18 	ld.d	r10,sp[24]
80009a0c:	2f f5       	sub	r5,-1
80009a0e:	50 64       	stdsp	sp[0x18],r4
80009a10:	e0 a0 0c 2c 	rcall	8000b268 <__avr32_f64_mul>
80009a14:	40 94       	lddsp	r4,sp[0x24]
80009a16:	14 98       	mov	r8,r10
80009a18:	16 99       	mov	r9,r11
80009a1a:	fa e9 00 08 	st.d	sp[8],r8
80009a1e:	c0 38       	rjmp	80009a24 <_dtoa_r+0x474>
80009a20:	50 66       	stdsp	sp[0x18],r6
80009a22:	02 94       	mov	r4,r1
80009a24:	0a 9c       	mov	r12,r5
80009a26:	e0 a0 0e 7c 	rcall	8000b71e <__avr32_s32_to_f64>
80009a2a:	fa e8 00 08 	ld.d	r8,sp[8]
80009a2e:	e0 a0 0c 1d 	rcall	8000b268 <__avr32_f64_mul>
80009a32:	30 08       	mov	r8,0
80009a34:	fc 19 40 1c 	movh	r9,0x401c
80009a38:	e0 a0 0d d2 	rcall	8000b5dc <__avr32_f64_add>
80009a3c:	14 98       	mov	r8,r10
80009a3e:	16 99       	mov	r9,r11
80009a40:	fa e9 00 28 	st.d	sp[40],r8
80009a44:	fc 18 fc c0 	movh	r8,0xfcc0
80009a48:	40 a5       	lddsp	r5,sp[0x28]
80009a4a:	10 05       	add	r5,r8
80009a4c:	50 a5       	stdsp	sp[0x28],r5
80009a4e:	58 04       	cp.w	r4,0
80009a50:	c2 11       	brne	80009a92 <_dtoa_r+0x4e2>
80009a52:	fa ea 00 08 	ld.d	r10,sp[8]
80009a56:	30 08       	mov	r8,0
80009a58:	fc 19 40 14 	movh	r9,0x4014
80009a5c:	e0 a0 0c f2 	rcall	8000b440 <__avr32_f64_sub>
80009a60:	40 bc       	lddsp	r12,sp[0x2c]
80009a62:	fa eb 00 08 	st.d	sp[8],r10
80009a66:	14 98       	mov	r8,r10
80009a68:	16 99       	mov	r9,r11
80009a6a:	18 9a       	mov	r10,r12
80009a6c:	0a 9b       	mov	r11,r5
80009a6e:	e0 a0 0f 0f 	rcall	8000b88c <__avr32_f64_cmp_lt>
80009a72:	e0 81 02 54 	brne	80009f1a <_dtoa_r+0x96a>
80009a76:	0a 98       	mov	r8,r5
80009a78:	40 b9       	lddsp	r9,sp[0x2c]
80009a7a:	ee 18 80 00 	eorh	r8,0x8000
80009a7e:	fa ea 00 08 	ld.d	r10,sp[8]
80009a82:	10 95       	mov	r5,r8
80009a84:	12 98       	mov	r8,r9
80009a86:	0a 99       	mov	r9,r5
80009a88:	e0 a0 0f 02 	rcall	8000b88c <__avr32_f64_cmp_lt>
80009a8c:	e0 81 02 3e 	brne	80009f08 <_dtoa_r+0x958>
80009a90:	ca 68       	rjmp	80009bdc <_dtoa_r+0x62c>
80009a92:	fe c9 c6 32 	sub	r9,pc,-14798
80009a96:	e8 c8 00 01 	sub	r8,r4,1
80009a9a:	40 d5       	lddsp	r5,sp[0x34]
80009a9c:	58 05       	cp.w	r5,0
80009a9e:	c4 f0       	breq	80009b3c <_dtoa_r+0x58c>
80009aa0:	30 0c       	mov	r12,0
80009aa2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009aa6:	51 3c       	stdsp	sp[0x4c],r12
80009aa8:	30 0a       	mov	r10,0
80009aaa:	fc 1b 3f e0 	movh	r11,0x3fe0
80009aae:	e0 a0 0f 23 	rcall	8000b8f4 <__avr32_f64_div>
80009ab2:	fa e8 00 28 	ld.d	r8,sp[40]
80009ab6:	40 85       	lddsp	r5,sp[0x20]
80009ab8:	e0 a0 0c c4 	rcall	8000b440 <__avr32_f64_sub>
80009abc:	fa eb 00 28 	st.d	sp[40],r10
80009ac0:	fa ea 00 08 	ld.d	r10,sp[8]
80009ac4:	e0 a0 0e 16 	rcall	8000b6f0 <__avr32_f64_to_s32>
80009ac8:	51 6c       	stdsp	sp[0x58],r12
80009aca:	e0 a0 0e 2a 	rcall	8000b71e <__avr32_s32_to_f64>
80009ace:	14 98       	mov	r8,r10
80009ad0:	16 99       	mov	r9,r11
80009ad2:	fa ea 00 08 	ld.d	r10,sp[8]
80009ad6:	e0 a0 0c b5 	rcall	8000b440 <__avr32_f64_sub>
80009ada:	fa eb 00 08 	st.d	sp[8],r10
80009ade:	41 68       	lddsp	r8,sp[0x58]
80009ae0:	2d 08       	sub	r8,-48
80009ae2:	0a c8       	st.b	r5++,r8
80009ae4:	41 39       	lddsp	r9,sp[0x4c]
80009ae6:	2f f9       	sub	r9,-1
80009ae8:	51 39       	stdsp	sp[0x4c],r9
80009aea:	fa e8 00 28 	ld.d	r8,sp[40]
80009aee:	e0 a0 0e cf 	rcall	8000b88c <__avr32_f64_cmp_lt>
80009af2:	e0 81 03 39 	brne	8000a164 <_dtoa_r+0xbb4>
80009af6:	fa e8 00 08 	ld.d	r8,sp[8]
80009afa:	30 0a       	mov	r10,0
80009afc:	fc 1b 3f f0 	movh	r11,0x3ff0
80009b00:	e0 a0 0c a0 	rcall	8000b440 <__avr32_f64_sub>
80009b04:	fa e8 00 28 	ld.d	r8,sp[40]
80009b08:	e0 a0 0e c2 	rcall	8000b88c <__avr32_f64_cmp_lt>
80009b0c:	fa ea 00 28 	ld.d	r10,sp[40]
80009b10:	30 08       	mov	r8,0
80009b12:	fc 19 40 24 	movh	r9,0x4024
80009b16:	e0 81 00 da 	brne	80009cca <_dtoa_r+0x71a>
80009b1a:	41 3c       	lddsp	r12,sp[0x4c]
80009b1c:	08 3c       	cp.w	r12,r4
80009b1e:	c5 f4       	brge	80009bdc <_dtoa_r+0x62c>
80009b20:	e0 a0 0b a4 	rcall	8000b268 <__avr32_f64_mul>
80009b24:	30 08       	mov	r8,0
80009b26:	fa eb 00 28 	st.d	sp[40],r10
80009b2a:	fc 19 40 24 	movh	r9,0x4024
80009b2e:	fa ea 00 08 	ld.d	r10,sp[8]
80009b32:	e0 a0 0b 9b 	rcall	8000b268 <__avr32_f64_mul>
80009b36:	fa eb 00 08 	st.d	sp[8],r10
80009b3a:	cc 3b       	rjmp	80009ac0 <_dtoa_r+0x510>
80009b3c:	40 85       	lddsp	r5,sp[0x20]
80009b3e:	08 05       	add	r5,r4
80009b40:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009b44:	51 35       	stdsp	sp[0x4c],r5
80009b46:	fa e8 00 28 	ld.d	r8,sp[40]
80009b4a:	40 85       	lddsp	r5,sp[0x20]
80009b4c:	e0 a0 0b 8e 	rcall	8000b268 <__avr32_f64_mul>
80009b50:	fa eb 00 28 	st.d	sp[40],r10
80009b54:	fa ea 00 08 	ld.d	r10,sp[8]
80009b58:	e0 a0 0d cc 	rcall	8000b6f0 <__avr32_f64_to_s32>
80009b5c:	51 6c       	stdsp	sp[0x58],r12
80009b5e:	e0 a0 0d e0 	rcall	8000b71e <__avr32_s32_to_f64>
80009b62:	14 98       	mov	r8,r10
80009b64:	16 99       	mov	r9,r11
80009b66:	fa ea 00 08 	ld.d	r10,sp[8]
80009b6a:	e0 a0 0c 6b 	rcall	8000b440 <__avr32_f64_sub>
80009b6e:	fa eb 00 08 	st.d	sp[8],r10
80009b72:	41 68       	lddsp	r8,sp[0x58]
80009b74:	2d 08       	sub	r8,-48
80009b76:	0a c8       	st.b	r5++,r8
80009b78:	41 3c       	lddsp	r12,sp[0x4c]
80009b7a:	18 35       	cp.w	r5,r12
80009b7c:	c2 81       	brne	80009bcc <_dtoa_r+0x61c>
80009b7e:	30 08       	mov	r8,0
80009b80:	fc 19 3f e0 	movh	r9,0x3fe0
80009b84:	fa ea 00 28 	ld.d	r10,sp[40]
80009b88:	e0 a0 0d 2a 	rcall	8000b5dc <__avr32_f64_add>
80009b8c:	40 85       	lddsp	r5,sp[0x20]
80009b8e:	fa e8 00 08 	ld.d	r8,sp[8]
80009b92:	08 05       	add	r5,r4
80009b94:	e0 a0 0e 7c 	rcall	8000b88c <__avr32_f64_cmp_lt>
80009b98:	e0 81 00 99 	brne	80009cca <_dtoa_r+0x71a>
80009b9c:	fa e8 00 28 	ld.d	r8,sp[40]
80009ba0:	30 0a       	mov	r10,0
80009ba2:	fc 1b 3f e0 	movh	r11,0x3fe0
80009ba6:	e0 a0 0c 4d 	rcall	8000b440 <__avr32_f64_sub>
80009baa:	14 98       	mov	r8,r10
80009bac:	16 99       	mov	r9,r11
80009bae:	fa ea 00 08 	ld.d	r10,sp[8]
80009bb2:	e0 a0 0e 6d 	rcall	8000b88c <__avr32_f64_cmp_lt>
80009bb6:	c1 30       	breq	80009bdc <_dtoa_r+0x62c>
80009bb8:	33 09       	mov	r9,48
80009bba:	0a 98       	mov	r8,r5
80009bbc:	11 7a       	ld.ub	r10,--r8
80009bbe:	f2 0a 18 00 	cp.b	r10,r9
80009bc2:	e0 81 02 d1 	brne	8000a164 <_dtoa_r+0xbb4>
80009bc6:	10 95       	mov	r5,r8
80009bc8:	cf 9b       	rjmp	80009bba <_dtoa_r+0x60a>
80009bca:	d7 03       	nop
80009bcc:	30 08       	mov	r8,0
80009bce:	fc 19 40 24 	movh	r9,0x4024
80009bd2:	e0 a0 0b 4b 	rcall	8000b268 <__avr32_f64_mul>
80009bd6:	fa eb 00 08 	st.d	sp[8],r10
80009bda:	cb db       	rjmp	80009b54 <_dtoa_r+0x5a4>
80009bdc:	fa ea 00 3c 	ld.d	r10,sp[60]
80009be0:	fa eb 00 08 	st.d	sp[8],r10
80009be4:	58 e6       	cp.w	r6,14
80009be6:	5f ab       	srle	r11
80009be8:	41 8a       	lddsp	r10,sp[0x60]
80009bea:	30 08       	mov	r8,0
80009bec:	f4 09 11 ff 	rsub	r9,r10,-1
80009bf0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009bf4:	f0 09 18 00 	cp.b	r9,r8
80009bf8:	e0 80 00 82 	breq	80009cfc <_dtoa_r+0x74c>
80009bfc:	40 ea       	lddsp	r10,sp[0x38]
80009bfe:	58 01       	cp.w	r1,0
80009c00:	5f a9       	srle	r9
80009c02:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009c06:	fe ca c7 a6 	sub	r10,pc,-14426
80009c0a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009c0e:	fa e5 00 10 	st.d	sp[16],r4
80009c12:	f0 09 18 00 	cp.b	r9,r8
80009c16:	c1 40       	breq	80009c3e <_dtoa_r+0x68e>
80009c18:	58 01       	cp.w	r1,0
80009c1a:	e0 81 01 77 	brne	80009f08 <_dtoa_r+0x958>
80009c1e:	30 08       	mov	r8,0
80009c20:	fc 19 40 14 	movh	r9,0x4014
80009c24:	08 9a       	mov	r10,r4
80009c26:	0a 9b       	mov	r11,r5
80009c28:	e0 a0 0b 20 	rcall	8000b268 <__avr32_f64_mul>
80009c2c:	fa e8 00 08 	ld.d	r8,sp[8]
80009c30:	e0 a0 0d fa 	rcall	8000b824 <__avr32_f64_cmp_ge>
80009c34:	e0 81 01 6a 	brne	80009f08 <_dtoa_r+0x958>
80009c38:	02 92       	mov	r2,r1
80009c3a:	e0 8f 01 72 	bral	80009f1e <_dtoa_r+0x96e>
80009c3e:	40 85       	lddsp	r5,sp[0x20]
80009c40:	30 14       	mov	r4,1
80009c42:	fa e8 00 10 	ld.d	r8,sp[16]
80009c46:	fa ea 00 08 	ld.d	r10,sp[8]
80009c4a:	e0 a0 0e 55 	rcall	8000b8f4 <__avr32_f64_div>
80009c4e:	e0 a0 0d 51 	rcall	8000b6f0 <__avr32_f64_to_s32>
80009c52:	18 92       	mov	r2,r12
80009c54:	e0 a0 0d 65 	rcall	8000b71e <__avr32_s32_to_f64>
80009c58:	fa e8 00 10 	ld.d	r8,sp[16]
80009c5c:	e0 a0 0b 06 	rcall	8000b268 <__avr32_f64_mul>
80009c60:	14 98       	mov	r8,r10
80009c62:	16 99       	mov	r9,r11
80009c64:	fa ea 00 08 	ld.d	r10,sp[8]
80009c68:	e0 a0 0b ec 	rcall	8000b440 <__avr32_f64_sub>
80009c6c:	fa eb 00 08 	st.d	sp[8],r10
80009c70:	e4 c8 ff d0 	sub	r8,r2,-48
80009c74:	0a c8       	st.b	r5++,r8
80009c76:	fc 19 40 24 	movh	r9,0x4024
80009c7a:	30 08       	mov	r8,0
80009c7c:	02 34       	cp.w	r4,r1
80009c7e:	c3 31       	brne	80009ce4 <_dtoa_r+0x734>
80009c80:	fa e8 00 08 	ld.d	r8,sp[8]
80009c84:	e0 a0 0c ac 	rcall	8000b5dc <__avr32_f64_add>
80009c88:	16 91       	mov	r1,r11
80009c8a:	14 90       	mov	r0,r10
80009c8c:	14 98       	mov	r8,r10
80009c8e:	02 99       	mov	r9,r1
80009c90:	fa ea 00 10 	ld.d	r10,sp[16]
80009c94:	e0 a0 0d fc 	rcall	8000b88c <__avr32_f64_cmp_lt>
80009c98:	c1 a1       	brne	80009ccc <_dtoa_r+0x71c>
80009c9a:	fa e8 00 10 	ld.d	r8,sp[16]
80009c9e:	00 9a       	mov	r10,r0
80009ca0:	02 9b       	mov	r11,r1
80009ca2:	e0 a0 0d ae 	rcall	8000b7fe <__avr32_f64_cmp_eq>
80009ca6:	e0 80 02 5e 	breq	8000a162 <_dtoa_r+0xbb2>
80009caa:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009cae:	c0 f1       	brne	80009ccc <_dtoa_r+0x71c>
80009cb0:	e0 8f 02 59 	bral	8000a162 <_dtoa_r+0xbb2>
80009cb4:	40 8a       	lddsp	r10,sp[0x20]
80009cb6:	14 38       	cp.w	r8,r10
80009cb8:	c0 30       	breq	80009cbe <_dtoa_r+0x70e>
80009cba:	10 95       	mov	r5,r8
80009cbc:	c0 98       	rjmp	80009cce <_dtoa_r+0x71e>
80009cbe:	33 08       	mov	r8,48
80009cc0:	40 89       	lddsp	r9,sp[0x20]
80009cc2:	2f f6       	sub	r6,-1
80009cc4:	b2 88       	st.b	r9[0x0],r8
80009cc6:	40 88       	lddsp	r8,sp[0x20]
80009cc8:	c0 88       	rjmp	80009cd8 <_dtoa_r+0x728>
80009cca:	40 66       	lddsp	r6,sp[0x18]
80009ccc:	33 99       	mov	r9,57
80009cce:	0a 98       	mov	r8,r5
80009cd0:	11 7a       	ld.ub	r10,--r8
80009cd2:	f2 0a 18 00 	cp.b	r10,r9
80009cd6:	ce f0       	breq	80009cb4 <_dtoa_r+0x704>
80009cd8:	50 66       	stdsp	sp[0x18],r6
80009cda:	11 89       	ld.ub	r9,r8[0x0]
80009cdc:	2f f9       	sub	r9,-1
80009cde:	b0 89       	st.b	r8[0x0],r9
80009ce0:	e0 8f 02 42 	bral	8000a164 <_dtoa_r+0xbb4>
80009ce4:	e0 a0 0a c2 	rcall	8000b268 <__avr32_f64_mul>
80009ce8:	2f f4       	sub	r4,-1
80009cea:	fa eb 00 08 	st.d	sp[8],r10
80009cee:	30 08       	mov	r8,0
80009cf0:	30 09       	mov	r9,0
80009cf2:	e0 a0 0d 86 	rcall	8000b7fe <__avr32_f64_cmp_eq>
80009cf6:	ca 60       	breq	80009c42 <_dtoa_r+0x692>
80009cf8:	e0 8f 02 35 	bral	8000a162 <_dtoa_r+0xbb2>
80009cfc:	40 d8       	lddsp	r8,sp[0x34]
80009cfe:	58 08       	cp.w	r8,0
80009d00:	c0 51       	brne	80009d0a <_dtoa_r+0x75a>
80009d02:	04 98       	mov	r8,r2
80009d04:	00 95       	mov	r5,r0
80009d06:	40 d4       	lddsp	r4,sp[0x34]
80009d08:	c3 78       	rjmp	80009d76 <_dtoa_r+0x7c6>
80009d0a:	40 c5       	lddsp	r5,sp[0x30]
80009d0c:	58 15       	cp.w	r5,1
80009d0e:	e0 89 00 0f 	brgt	80009d2c <_dtoa_r+0x77c>
80009d12:	41 74       	lddsp	r4,sp[0x5c]
80009d14:	58 04       	cp.w	r4,0
80009d16:	c0 40       	breq	80009d1e <_dtoa_r+0x76e>
80009d18:	f4 c9 fb cd 	sub	r9,r10,-1075
80009d1c:	c0 48       	rjmp	80009d24 <_dtoa_r+0x774>
80009d1e:	41 99       	lddsp	r9,sp[0x64]
80009d20:	f2 09 11 36 	rsub	r9,r9,54
80009d24:	04 98       	mov	r8,r2
80009d26:	00 95       	mov	r5,r0
80009d28:	c1 c8       	rjmp	80009d60 <_dtoa_r+0x7b0>
80009d2a:	d7 03       	nop
80009d2c:	e2 c8 00 01 	sub	r8,r1,1
80009d30:	58 01       	cp.w	r1,0
80009d32:	e0 05 17 40 	movge	r5,r0
80009d36:	e2 09 17 40 	movge	r9,r1
80009d3a:	e1 d1 e5 15 	sublt	r5,r0,r1
80009d3e:	f9 b9 05 00 	movlt	r9,0
80009d42:	10 32       	cp.w	r2,r8
80009d44:	e5 d8 e4 18 	subge	r8,r2,r8
80009d48:	f1 d2 e5 18 	sublt	r8,r8,r2
80009d4c:	e5 d8 e5 02 	addlt	r2,r2,r8
80009d50:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009d54:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009d58:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009d5c:	f9 b8 05 00 	movlt	r8,0
80009d60:	40 4b       	lddsp	r11,sp[0x10]
80009d62:	12 0b       	add	r11,r9
80009d64:	50 08       	stdsp	sp[0x0],r8
80009d66:	50 4b       	stdsp	sp[0x10],r11
80009d68:	12 00       	add	r0,r9
80009d6a:	30 1b       	mov	r11,1
80009d6c:	0e 9c       	mov	r12,r7
80009d6e:	e0 a0 08 a7 	rcall	8000aebc <__i2b>
80009d72:	40 08       	lddsp	r8,sp[0x0]
80009d74:	18 94       	mov	r4,r12
80009d76:	40 4a       	lddsp	r10,sp[0x10]
80009d78:	58 05       	cp.w	r5,0
80009d7a:	5f 99       	srgt	r9
80009d7c:	58 0a       	cp.w	r10,0
80009d7e:	5f 9a       	srgt	r10
80009d80:	f5 e9 00 09 	and	r9,r10,r9
80009d84:	c0 80       	breq	80009d94 <_dtoa_r+0x7e4>
80009d86:	40 4c       	lddsp	r12,sp[0x10]
80009d88:	f8 05 0d 49 	min	r9,r12,r5
80009d8c:	12 1c       	sub	r12,r9
80009d8e:	12 10       	sub	r0,r9
80009d90:	50 4c       	stdsp	sp[0x10],r12
80009d92:	12 15       	sub	r5,r9
80009d94:	58 02       	cp.w	r2,0
80009d96:	e0 8a 00 27 	brle	80009de4 <_dtoa_r+0x834>
80009d9a:	40 db       	lddsp	r11,sp[0x34]
80009d9c:	58 0b       	cp.w	r11,0
80009d9e:	c1 d0       	breq	80009dd8 <_dtoa_r+0x828>
80009da0:	58 08       	cp.w	r8,0
80009da2:	e0 8a 00 17 	brle	80009dd0 <_dtoa_r+0x820>
80009da6:	10 9a       	mov	r10,r8
80009da8:	50 08       	stdsp	sp[0x0],r8
80009daa:	08 9b       	mov	r11,r4
80009dac:	0e 9c       	mov	r12,r7
80009dae:	e0 a0 08 cd 	rcall	8000af48 <__pow5mult>
80009db2:	06 9a       	mov	r10,r3
80009db4:	18 9b       	mov	r11,r12
80009db6:	18 94       	mov	r4,r12
80009db8:	0e 9c       	mov	r12,r7
80009dba:	e0 a0 08 01 	rcall	8000adbc <__multiply>
80009dbe:	18 99       	mov	r9,r12
80009dc0:	06 9b       	mov	r11,r3
80009dc2:	50 19       	stdsp	sp[0x4],r9
80009dc4:	0e 9c       	mov	r12,r7
80009dc6:	e0 a0 06 ad 	rcall	8000ab20 <_Bfree>
80009dca:	40 19       	lddsp	r9,sp[0x4]
80009dcc:	40 08       	lddsp	r8,sp[0x0]
80009dce:	12 93       	mov	r3,r9
80009dd0:	e4 08 01 0a 	sub	r10,r2,r8
80009dd4:	c0 80       	breq	80009de4 <_dtoa_r+0x834>
80009dd6:	c0 28       	rjmp	80009dda <_dtoa_r+0x82a>
80009dd8:	04 9a       	mov	r10,r2
80009dda:	06 9b       	mov	r11,r3
80009ddc:	0e 9c       	mov	r12,r7
80009dde:	e0 a0 08 b5 	rcall	8000af48 <__pow5mult>
80009de2:	18 93       	mov	r3,r12
80009de4:	30 1b       	mov	r11,1
80009de6:	0e 9c       	mov	r12,r7
80009de8:	e0 a0 08 6a 	rcall	8000aebc <__i2b>
80009dec:	41 1a       	lddsp	r10,sp[0x44]
80009dee:	18 92       	mov	r2,r12
80009df0:	58 0a       	cp.w	r10,0
80009df2:	e0 8a 00 07 	brle	80009e00 <_dtoa_r+0x850>
80009df6:	18 9b       	mov	r11,r12
80009df8:	0e 9c       	mov	r12,r7
80009dfa:	e0 a0 08 a7 	rcall	8000af48 <__pow5mult>
80009dfe:	18 92       	mov	r2,r12
80009e00:	40 c9       	lddsp	r9,sp[0x30]
80009e02:	58 19       	cp.w	r9,1
80009e04:	e0 89 00 14 	brgt	80009e2c <_dtoa_r+0x87c>
80009e08:	40 38       	lddsp	r8,sp[0xc]
80009e0a:	58 08       	cp.w	r8,0
80009e0c:	c1 01       	brne	80009e2c <_dtoa_r+0x87c>
80009e0e:	40 29       	lddsp	r9,sp[0x8]
80009e10:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009e14:	c0 c1       	brne	80009e2c <_dtoa_r+0x87c>
80009e16:	12 98       	mov	r8,r9
80009e18:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80009e1c:	c0 80       	breq	80009e2c <_dtoa_r+0x87c>
80009e1e:	40 4c       	lddsp	r12,sp[0x10]
80009e20:	30 1b       	mov	r11,1
80009e22:	2f fc       	sub	r12,-1
80009e24:	2f f0       	sub	r0,-1
80009e26:	50 4c       	stdsp	sp[0x10],r12
80009e28:	50 6b       	stdsp	sp[0x18],r11
80009e2a:	c0 38       	rjmp	80009e30 <_dtoa_r+0x880>
80009e2c:	30 0a       	mov	r10,0
80009e2e:	50 6a       	stdsp	sp[0x18],r10
80009e30:	41 19       	lddsp	r9,sp[0x44]
80009e32:	58 09       	cp.w	r9,0
80009e34:	c0 31       	brne	80009e3a <_dtoa_r+0x88a>
80009e36:	30 1c       	mov	r12,1
80009e38:	c0 98       	rjmp	80009e4a <_dtoa_r+0x89a>
80009e3a:	64 48       	ld.w	r8,r2[0x10]
80009e3c:	2f c8       	sub	r8,-4
80009e3e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
80009e42:	e0 a0 05 df 	rcall	8000aa00 <__hi0bits>
80009e46:	f8 0c 11 20 	rsub	r12,r12,32
80009e4a:	40 4b       	lddsp	r11,sp[0x10]
80009e4c:	f8 0b 00 08 	add	r8,r12,r11
80009e50:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80009e54:	c0 c0       	breq	80009e6c <_dtoa_r+0x8bc>
80009e56:	f0 08 11 20 	rsub	r8,r8,32
80009e5a:	58 48       	cp.w	r8,4
80009e5c:	e0 8a 00 06 	brle	80009e68 <_dtoa_r+0x8b8>
80009e60:	20 48       	sub	r8,4
80009e62:	10 0b       	add	r11,r8
80009e64:	50 4b       	stdsp	sp[0x10],r11
80009e66:	c0 78       	rjmp	80009e74 <_dtoa_r+0x8c4>
80009e68:	58 48       	cp.w	r8,4
80009e6a:	c0 70       	breq	80009e78 <_dtoa_r+0x8c8>
80009e6c:	40 4a       	lddsp	r10,sp[0x10]
80009e6e:	2e 48       	sub	r8,-28
80009e70:	10 0a       	add	r10,r8
80009e72:	50 4a       	stdsp	sp[0x10],r10
80009e74:	10 00       	add	r0,r8
80009e76:	10 05       	add	r5,r8
80009e78:	58 00       	cp.w	r0,0
80009e7a:	e0 8a 00 08 	brle	80009e8a <_dtoa_r+0x8da>
80009e7e:	06 9b       	mov	r11,r3
80009e80:	00 9a       	mov	r10,r0
80009e82:	0e 9c       	mov	r12,r7
80009e84:	e0 a0 07 58 	rcall	8000ad34 <__lshift>
80009e88:	18 93       	mov	r3,r12
80009e8a:	40 49       	lddsp	r9,sp[0x10]
80009e8c:	58 09       	cp.w	r9,0
80009e8e:	e0 8a 00 08 	brle	80009e9e <_dtoa_r+0x8ee>
80009e92:	04 9b       	mov	r11,r2
80009e94:	12 9a       	mov	r10,r9
80009e96:	0e 9c       	mov	r12,r7
80009e98:	e0 a0 07 4e 	rcall	8000ad34 <__lshift>
80009e9c:	18 92       	mov	r2,r12
80009e9e:	41 48       	lddsp	r8,sp[0x50]
80009ea0:	58 08       	cp.w	r8,0
80009ea2:	c1 b0       	breq	80009ed8 <_dtoa_r+0x928>
80009ea4:	04 9b       	mov	r11,r2
80009ea6:	06 9c       	mov	r12,r3
80009ea8:	e0 a0 06 23 	rcall	8000aaee <__mcmp>
80009eac:	c1 64       	brge	80009ed8 <_dtoa_r+0x928>
80009eae:	06 9b       	mov	r11,r3
80009eb0:	30 09       	mov	r9,0
80009eb2:	30 aa       	mov	r10,10
80009eb4:	0e 9c       	mov	r12,r7
80009eb6:	e0 a0 08 0b 	rcall	8000aecc <__multadd>
80009eba:	20 16       	sub	r6,1
80009ebc:	18 93       	mov	r3,r12
80009ebe:	40 dc       	lddsp	r12,sp[0x34]
80009ec0:	58 0c       	cp.w	r12,0
80009ec2:	c0 31       	brne	80009ec8 <_dtoa_r+0x918>
80009ec4:	40 91       	lddsp	r1,sp[0x24]
80009ec6:	c0 98       	rjmp	80009ed8 <_dtoa_r+0x928>
80009ec8:	08 9b       	mov	r11,r4
80009eca:	40 91       	lddsp	r1,sp[0x24]
80009ecc:	30 09       	mov	r9,0
80009ece:	30 aa       	mov	r10,10
80009ed0:	0e 9c       	mov	r12,r7
80009ed2:	e0 a0 07 fd 	rcall	8000aecc <__multadd>
80009ed6:	18 94       	mov	r4,r12
80009ed8:	58 01       	cp.w	r1,0
80009eda:	5f a9       	srle	r9
80009edc:	40 cb       	lddsp	r11,sp[0x30]
80009ede:	58 2b       	cp.w	r11,2
80009ee0:	5f 98       	srgt	r8
80009ee2:	f3 e8 00 08 	and	r8,r9,r8
80009ee6:	c2 50       	breq	80009f30 <_dtoa_r+0x980>
80009ee8:	58 01       	cp.w	r1,0
80009eea:	c1 11       	brne	80009f0c <_dtoa_r+0x95c>
80009eec:	04 9b       	mov	r11,r2
80009eee:	02 99       	mov	r9,r1
80009ef0:	30 5a       	mov	r10,5
80009ef2:	0e 9c       	mov	r12,r7
80009ef4:	e0 a0 07 ec 	rcall	8000aecc <__multadd>
80009ef8:	18 92       	mov	r2,r12
80009efa:	18 9b       	mov	r11,r12
80009efc:	06 9c       	mov	r12,r3
80009efe:	e0 a0 05 f8 	rcall	8000aaee <__mcmp>
80009f02:	e0 89 00 0f 	brgt	80009f20 <_dtoa_r+0x970>
80009f06:	c0 38       	rjmp	80009f0c <_dtoa_r+0x95c>
80009f08:	30 02       	mov	r2,0
80009f0a:	04 94       	mov	r4,r2
80009f0c:	40 ea       	lddsp	r10,sp[0x38]
80009f0e:	30 09       	mov	r9,0
80009f10:	5c da       	com	r10
80009f12:	40 85       	lddsp	r5,sp[0x20]
80009f14:	50 6a       	stdsp	sp[0x18],r10
80009f16:	50 49       	stdsp	sp[0x10],r9
80009f18:	c0 f9       	rjmp	8000a136 <_dtoa_r+0xb86>
80009f1a:	08 92       	mov	r2,r4
80009f1c:	40 66       	lddsp	r6,sp[0x18]
80009f1e:	04 94       	mov	r4,r2
80009f20:	2f f6       	sub	r6,-1
80009f22:	50 66       	stdsp	sp[0x18],r6
80009f24:	33 18       	mov	r8,49
80009f26:	40 85       	lddsp	r5,sp[0x20]
80009f28:	0a c8       	st.b	r5++,r8
80009f2a:	30 08       	mov	r8,0
80009f2c:	50 48       	stdsp	sp[0x10],r8
80009f2e:	c0 49       	rjmp	8000a136 <_dtoa_r+0xb86>
80009f30:	40 dc       	lddsp	r12,sp[0x34]
80009f32:	58 0c       	cp.w	r12,0
80009f34:	e0 80 00 b5 	breq	8000a09e <_dtoa_r+0xaee>
80009f38:	58 05       	cp.w	r5,0
80009f3a:	e0 8a 00 08 	brle	80009f4a <_dtoa_r+0x99a>
80009f3e:	08 9b       	mov	r11,r4
80009f40:	0a 9a       	mov	r10,r5
80009f42:	0e 9c       	mov	r12,r7
80009f44:	e0 a0 06 f8 	rcall	8000ad34 <__lshift>
80009f48:	18 94       	mov	r4,r12
80009f4a:	40 6b       	lddsp	r11,sp[0x18]
80009f4c:	58 0b       	cp.w	r11,0
80009f4e:	c0 31       	brne	80009f54 <_dtoa_r+0x9a4>
80009f50:	08 9c       	mov	r12,r4
80009f52:	c1 38       	rjmp	80009f78 <_dtoa_r+0x9c8>
80009f54:	68 1b       	ld.w	r11,r4[0x4]
80009f56:	0e 9c       	mov	r12,r7
80009f58:	e0 a0 05 fe 	rcall	8000ab54 <_Balloc>
80009f5c:	68 4a       	ld.w	r10,r4[0x10]
80009f5e:	18 95       	mov	r5,r12
80009f60:	e8 cb ff f4 	sub	r11,r4,-12
80009f64:	2f ea       	sub	r10,-2
80009f66:	2f 4c       	sub	r12,-12
80009f68:	a3 6a       	lsl	r10,0x2
80009f6a:	fe b0 e6 43 	rcall	80006bf0 <memcpy>
80009f6e:	0a 9b       	mov	r11,r5
80009f70:	30 1a       	mov	r10,1
80009f72:	0e 9c       	mov	r12,r7
80009f74:	e0 a0 06 e0 	rcall	8000ad34 <__lshift>
80009f78:	50 44       	stdsp	sp[0x10],r4
80009f7a:	40 3a       	lddsp	r10,sp[0xc]
80009f7c:	30 19       	mov	r9,1
80009f7e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009f82:	18 94       	mov	r4,r12
80009f84:	50 da       	stdsp	sp[0x34],r10
80009f86:	40 85       	lddsp	r5,sp[0x20]
80009f88:	50 99       	stdsp	sp[0x24],r9
80009f8a:	50 26       	stdsp	sp[0x8],r6
80009f8c:	50 e1       	stdsp	sp[0x38],r1
80009f8e:	04 9b       	mov	r11,r2
80009f90:	06 9c       	mov	r12,r3
80009f92:	fe b0 fa 7f 	rcall	80009490 <quorem>
80009f96:	40 4b       	lddsp	r11,sp[0x10]
80009f98:	f8 c0 ff d0 	sub	r0,r12,-48
80009f9c:	06 9c       	mov	r12,r3
80009f9e:	e0 a0 05 a8 	rcall	8000aaee <__mcmp>
80009fa2:	08 9a       	mov	r10,r4
80009fa4:	50 6c       	stdsp	sp[0x18],r12
80009fa6:	04 9b       	mov	r11,r2
80009fa8:	0e 9c       	mov	r12,r7
80009faa:	e0 a0 06 5d 	rcall	8000ac64 <__mdiff>
80009fae:	18 91       	mov	r1,r12
80009fb0:	78 38       	ld.w	r8,r12[0xc]
80009fb2:	58 08       	cp.w	r8,0
80009fb4:	c0 30       	breq	80009fba <_dtoa_r+0xa0a>
80009fb6:	30 16       	mov	r6,1
80009fb8:	c0 68       	rjmp	80009fc4 <_dtoa_r+0xa14>
80009fba:	18 9b       	mov	r11,r12
80009fbc:	06 9c       	mov	r12,r3
80009fbe:	e0 a0 05 98 	rcall	8000aaee <__mcmp>
80009fc2:	18 96       	mov	r6,r12
80009fc4:	0e 9c       	mov	r12,r7
80009fc6:	02 9b       	mov	r11,r1
80009fc8:	e0 a0 05 ac 	rcall	8000ab20 <_Bfree>
80009fcc:	40 cc       	lddsp	r12,sp[0x30]
80009fce:	ed ec 10 08 	or	r8,r6,r12
80009fd2:	c0 d1       	brne	80009fec <_dtoa_r+0xa3c>
80009fd4:	40 db       	lddsp	r11,sp[0x34]
80009fd6:	58 0b       	cp.w	r11,0
80009fd8:	c0 a1       	brne	80009fec <_dtoa_r+0xa3c>
80009fda:	40 26       	lddsp	r6,sp[0x8]
80009fdc:	e0 40 00 39 	cp.w	r0,57
80009fe0:	c3 00       	breq	8000a040 <_dtoa_r+0xa90>
80009fe2:	40 6a       	lddsp	r10,sp[0x18]
80009fe4:	58 0a       	cp.w	r10,0
80009fe6:	e0 89 00 24 	brgt	8000a02e <_dtoa_r+0xa7e>
80009fea:	c2 f8       	rjmp	8000a048 <_dtoa_r+0xa98>
80009fec:	40 69       	lddsp	r9,sp[0x18]
80009fee:	58 09       	cp.w	r9,0
80009ff0:	c0 85       	brlt	8000a000 <_dtoa_r+0xa50>
80009ff2:	12 98       	mov	r8,r9
80009ff4:	40 cc       	lddsp	r12,sp[0x30]
80009ff6:	18 48       	or	r8,r12
80009ff8:	c1 d1       	brne	8000a032 <_dtoa_r+0xa82>
80009ffa:	40 db       	lddsp	r11,sp[0x34]
80009ffc:	58 0b       	cp.w	r11,0
80009ffe:	c1 a1       	brne	8000a032 <_dtoa_r+0xa82>
8000a000:	0c 99       	mov	r9,r6
8000a002:	40 26       	lddsp	r6,sp[0x8]
8000a004:	58 09       	cp.w	r9,0
8000a006:	e0 8a 00 21 	brle	8000a048 <_dtoa_r+0xa98>
8000a00a:	06 9b       	mov	r11,r3
8000a00c:	30 1a       	mov	r10,1
8000a00e:	0e 9c       	mov	r12,r7
8000a010:	e0 a0 06 92 	rcall	8000ad34 <__lshift>
8000a014:	04 9b       	mov	r11,r2
8000a016:	18 93       	mov	r3,r12
8000a018:	e0 a0 05 6b 	rcall	8000aaee <__mcmp>
8000a01c:	e0 89 00 06 	brgt	8000a028 <_dtoa_r+0xa78>
8000a020:	c1 41       	brne	8000a048 <_dtoa_r+0xa98>
8000a022:	ed b0 00 00 	bld	r0,0x0
8000a026:	c1 11       	brne	8000a048 <_dtoa_r+0xa98>
8000a028:	e0 40 00 39 	cp.w	r0,57
8000a02c:	c0 a0       	breq	8000a040 <_dtoa_r+0xa90>
8000a02e:	2f f0       	sub	r0,-1
8000a030:	c0 c8       	rjmp	8000a048 <_dtoa_r+0xa98>
8000a032:	58 06       	cp.w	r6,0
8000a034:	e0 8a 00 0c 	brle	8000a04c <_dtoa_r+0xa9c>
8000a038:	40 26       	lddsp	r6,sp[0x8]
8000a03a:	e0 40 00 39 	cp.w	r0,57
8000a03e:	c0 41       	brne	8000a046 <_dtoa_r+0xa96>
8000a040:	33 98       	mov	r8,57
8000a042:	0a c8       	st.b	r5++,r8
8000a044:	c6 78       	rjmp	8000a112 <_dtoa_r+0xb62>
8000a046:	2f f0       	sub	r0,-1
8000a048:	0a c0       	st.b	r5++,r0
8000a04a:	c7 58       	rjmp	8000a134 <_dtoa_r+0xb84>
8000a04c:	0a c0       	st.b	r5++,r0
8000a04e:	40 9a       	lddsp	r10,sp[0x24]
8000a050:	40 e9       	lddsp	r9,sp[0x38]
8000a052:	12 3a       	cp.w	r10,r9
8000a054:	c4 30       	breq	8000a0da <_dtoa_r+0xb2a>
8000a056:	06 9b       	mov	r11,r3
8000a058:	30 09       	mov	r9,0
8000a05a:	30 aa       	mov	r10,10
8000a05c:	0e 9c       	mov	r12,r7
8000a05e:	e0 a0 07 37 	rcall	8000aecc <__multadd>
8000a062:	40 48       	lddsp	r8,sp[0x10]
8000a064:	18 93       	mov	r3,r12
8000a066:	08 38       	cp.w	r8,r4
8000a068:	c0 91       	brne	8000a07a <_dtoa_r+0xaca>
8000a06a:	10 9b       	mov	r11,r8
8000a06c:	30 09       	mov	r9,0
8000a06e:	30 aa       	mov	r10,10
8000a070:	0e 9c       	mov	r12,r7
8000a072:	e0 a0 07 2d 	rcall	8000aecc <__multadd>
8000a076:	50 4c       	stdsp	sp[0x10],r12
8000a078:	c0 e8       	rjmp	8000a094 <_dtoa_r+0xae4>
8000a07a:	40 4b       	lddsp	r11,sp[0x10]
8000a07c:	30 09       	mov	r9,0
8000a07e:	30 aa       	mov	r10,10
8000a080:	0e 9c       	mov	r12,r7
8000a082:	e0 a0 07 25 	rcall	8000aecc <__multadd>
8000a086:	08 9b       	mov	r11,r4
8000a088:	50 4c       	stdsp	sp[0x10],r12
8000a08a:	30 09       	mov	r9,0
8000a08c:	30 aa       	mov	r10,10
8000a08e:	0e 9c       	mov	r12,r7
8000a090:	e0 a0 07 1e 	rcall	8000aecc <__multadd>
8000a094:	18 94       	mov	r4,r12
8000a096:	40 9c       	lddsp	r12,sp[0x24]
8000a098:	2f fc       	sub	r12,-1
8000a09a:	50 9c       	stdsp	sp[0x24],r12
8000a09c:	c7 9b       	rjmp	80009f8e <_dtoa_r+0x9de>
8000a09e:	30 18       	mov	r8,1
8000a0a0:	06 90       	mov	r0,r3
8000a0a2:	40 85       	lddsp	r5,sp[0x20]
8000a0a4:	08 93       	mov	r3,r4
8000a0a6:	0c 94       	mov	r4,r6
8000a0a8:	10 96       	mov	r6,r8
8000a0aa:	04 9b       	mov	r11,r2
8000a0ac:	00 9c       	mov	r12,r0
8000a0ae:	fe b0 f9 f1 	rcall	80009490 <quorem>
8000a0b2:	2d 0c       	sub	r12,-48
8000a0b4:	0a cc       	st.b	r5++,r12
8000a0b6:	02 36       	cp.w	r6,r1
8000a0b8:	c0 a4       	brge	8000a0cc <_dtoa_r+0xb1c>
8000a0ba:	00 9b       	mov	r11,r0
8000a0bc:	30 09       	mov	r9,0
8000a0be:	30 aa       	mov	r10,10
8000a0c0:	0e 9c       	mov	r12,r7
8000a0c2:	2f f6       	sub	r6,-1
8000a0c4:	e0 a0 07 04 	rcall	8000aecc <__multadd>
8000a0c8:	18 90       	mov	r0,r12
8000a0ca:	cf 0b       	rjmp	8000a0aa <_dtoa_r+0xafa>
8000a0cc:	08 96       	mov	r6,r4
8000a0ce:	30 0b       	mov	r11,0
8000a0d0:	06 94       	mov	r4,r3
8000a0d2:	50 4b       	stdsp	sp[0x10],r11
8000a0d4:	00 93       	mov	r3,r0
8000a0d6:	18 90       	mov	r0,r12
8000a0d8:	c0 28       	rjmp	8000a0dc <_dtoa_r+0xb2c>
8000a0da:	40 26       	lddsp	r6,sp[0x8]
8000a0dc:	06 9b       	mov	r11,r3
8000a0de:	30 1a       	mov	r10,1
8000a0e0:	0e 9c       	mov	r12,r7
8000a0e2:	e0 a0 06 29 	rcall	8000ad34 <__lshift>
8000a0e6:	04 9b       	mov	r11,r2
8000a0e8:	18 93       	mov	r3,r12
8000a0ea:	e0 a0 05 02 	rcall	8000aaee <__mcmp>
8000a0ee:	e0 89 00 12 	brgt	8000a112 <_dtoa_r+0xb62>
8000a0f2:	c1 b1       	brne	8000a128 <_dtoa_r+0xb78>
8000a0f4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a0f8:	c0 d1       	brne	8000a112 <_dtoa_r+0xb62>
8000a0fa:	c1 78       	rjmp	8000a128 <_dtoa_r+0xb78>
8000a0fc:	40 89       	lddsp	r9,sp[0x20]
8000a0fe:	12 38       	cp.w	r8,r9
8000a100:	c0 30       	breq	8000a106 <_dtoa_r+0xb56>
8000a102:	10 95       	mov	r5,r8
8000a104:	c0 88       	rjmp	8000a114 <_dtoa_r+0xb64>
8000a106:	2f f6       	sub	r6,-1
8000a108:	50 66       	stdsp	sp[0x18],r6
8000a10a:	33 18       	mov	r8,49
8000a10c:	40 8c       	lddsp	r12,sp[0x20]
8000a10e:	b8 88       	st.b	r12[0x0],r8
8000a110:	c1 38       	rjmp	8000a136 <_dtoa_r+0xb86>
8000a112:	33 9a       	mov	r10,57
8000a114:	0a 98       	mov	r8,r5
8000a116:	11 79       	ld.ub	r9,--r8
8000a118:	f4 09 18 00 	cp.b	r9,r10
8000a11c:	cf 00       	breq	8000a0fc <_dtoa_r+0xb4c>
8000a11e:	2f f9       	sub	r9,-1
8000a120:	b0 89       	st.b	r8[0x0],r9
8000a122:	c0 98       	rjmp	8000a134 <_dtoa_r+0xb84>
8000a124:	10 95       	mov	r5,r8
8000a126:	c0 28       	rjmp	8000a12a <_dtoa_r+0xb7a>
8000a128:	33 09       	mov	r9,48
8000a12a:	0a 98       	mov	r8,r5
8000a12c:	11 7a       	ld.ub	r10,--r8
8000a12e:	f2 0a 18 00 	cp.b	r10,r9
8000a132:	cf 90       	breq	8000a124 <_dtoa_r+0xb74>
8000a134:	50 66       	stdsp	sp[0x18],r6
8000a136:	04 9b       	mov	r11,r2
8000a138:	0e 9c       	mov	r12,r7
8000a13a:	e0 a0 04 f3 	rcall	8000ab20 <_Bfree>
8000a13e:	58 04       	cp.w	r4,0
8000a140:	c1 20       	breq	8000a164 <_dtoa_r+0xbb4>
8000a142:	40 4b       	lddsp	r11,sp[0x10]
8000a144:	08 3b       	cp.w	r11,r4
8000a146:	5f 19       	srne	r9
8000a148:	58 0b       	cp.w	r11,0
8000a14a:	5f 18       	srne	r8
8000a14c:	f3 e8 00 08 	and	r8,r9,r8
8000a150:	c0 40       	breq	8000a158 <_dtoa_r+0xba8>
8000a152:	0e 9c       	mov	r12,r7
8000a154:	e0 a0 04 e6 	rcall	8000ab20 <_Bfree>
8000a158:	08 9b       	mov	r11,r4
8000a15a:	0e 9c       	mov	r12,r7
8000a15c:	e0 a0 04 e2 	rcall	8000ab20 <_Bfree>
8000a160:	c0 28       	rjmp	8000a164 <_dtoa_r+0xbb4>
8000a162:	50 66       	stdsp	sp[0x18],r6
8000a164:	0e 9c       	mov	r12,r7
8000a166:	06 9b       	mov	r11,r3
8000a168:	e0 a0 04 dc 	rcall	8000ab20 <_Bfree>
8000a16c:	30 08       	mov	r8,0
8000a16e:	aa 88       	st.b	r5[0x0],r8
8000a170:	40 68       	lddsp	r8,sp[0x18]
8000a172:	41 5a       	lddsp	r10,sp[0x54]
8000a174:	2f f8       	sub	r8,-1
8000a176:	41 29       	lddsp	r9,sp[0x48]
8000a178:	95 08       	st.w	r10[0x0],r8
8000a17a:	40 8c       	lddsp	r12,sp[0x20]
8000a17c:	58 09       	cp.w	r9,0
8000a17e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a182:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a186:	2e 6d       	sub	sp,-104
8000a188:	d8 32       	popm	r0-r7,pc
8000a18a:	d7 03       	nop

8000a18c <__errno>:
8000a18c:	e0 68 0a 30 	mov	r8,2608
8000a190:	70 0c       	ld.w	r12,r8[0x0]
8000a192:	2f 4c       	sub	r12,-12
8000a194:	5e fc       	retal	r12
8000a196:	d7 03       	nop

8000a198 <_fflush_r>:
8000a198:	d4 21       	pushm	r4-r7,lr
8000a19a:	16 97       	mov	r7,r11
8000a19c:	18 96       	mov	r6,r12
8000a19e:	76 48       	ld.w	r8,r11[0x10]
8000a1a0:	58 08       	cp.w	r8,0
8000a1a2:	c7 f0       	breq	8000a2a0 <_fflush_r+0x108>
8000a1a4:	58 0c       	cp.w	r12,0
8000a1a6:	c0 50       	breq	8000a1b0 <_fflush_r+0x18>
8000a1a8:	78 68       	ld.w	r8,r12[0x18]
8000a1aa:	58 08       	cp.w	r8,0
8000a1ac:	c0 21       	brne	8000a1b0 <_fflush_r+0x18>
8000a1ae:	cc dc       	rcall	8000a348 <__sinit>
8000a1b0:	fe c8 ce 00 	sub	r8,pc,-12800
8000a1b4:	10 37       	cp.w	r7,r8
8000a1b6:	c0 31       	brne	8000a1bc <_fflush_r+0x24>
8000a1b8:	6c 07       	ld.w	r7,r6[0x0]
8000a1ba:	c0 c8       	rjmp	8000a1d2 <_fflush_r+0x3a>
8000a1bc:	fe c8 cd ec 	sub	r8,pc,-12820
8000a1c0:	10 37       	cp.w	r7,r8
8000a1c2:	c0 31       	brne	8000a1c8 <_fflush_r+0x30>
8000a1c4:	6c 17       	ld.w	r7,r6[0x4]
8000a1c6:	c0 68       	rjmp	8000a1d2 <_fflush_r+0x3a>
8000a1c8:	fe c8 cd d8 	sub	r8,pc,-12840
8000a1cc:	10 37       	cp.w	r7,r8
8000a1ce:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a1d2:	8e 6a       	ld.sh	r10,r7[0xc]
8000a1d4:	14 98       	mov	r8,r10
8000a1d6:	ed ba 00 03 	bld	r10,0x3
8000a1da:	c4 20       	breq	8000a25e <_fflush_r+0xc6>
8000a1dc:	ab ba       	sbr	r10,0xb
8000a1de:	ae 6a       	st.h	r7[0xc],r10
8000a1e0:	6e 18       	ld.w	r8,r7[0x4]
8000a1e2:	58 08       	cp.w	r8,0
8000a1e4:	e0 89 00 06 	brgt	8000a1f0 <_fflush_r+0x58>
8000a1e8:	6f 08       	ld.w	r8,r7[0x40]
8000a1ea:	58 08       	cp.w	r8,0
8000a1ec:	e0 8a 00 5a 	brle	8000a2a0 <_fflush_r+0x108>
8000a1f0:	6e b8       	ld.w	r8,r7[0x2c]
8000a1f2:	58 08       	cp.w	r8,0
8000a1f4:	c5 60       	breq	8000a2a0 <_fflush_r+0x108>
8000a1f6:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a1fa:	c0 30       	breq	8000a200 <_fflush_r+0x68>
8000a1fc:	6f 55       	ld.w	r5,r7[0x54]
8000a1fe:	c0 f8       	rjmp	8000a21c <_fflush_r+0x84>
8000a200:	30 19       	mov	r9,1
8000a202:	6e 8b       	ld.w	r11,r7[0x20]
8000a204:	0c 9c       	mov	r12,r6
8000a206:	5d 18       	icall	r8
8000a208:	18 95       	mov	r5,r12
8000a20a:	5b fc       	cp.w	r12,-1
8000a20c:	c0 81       	brne	8000a21c <_fflush_r+0x84>
8000a20e:	6c 38       	ld.w	r8,r6[0xc]
8000a210:	59 d8       	cp.w	r8,29
8000a212:	c4 70       	breq	8000a2a0 <_fflush_r+0x108>
8000a214:	8e 68       	ld.sh	r8,r7[0xc]
8000a216:	a7 a8       	sbr	r8,0x6
8000a218:	ae 68       	st.h	r7[0xc],r8
8000a21a:	d8 22       	popm	r4-r7,pc
8000a21c:	8e 68       	ld.sh	r8,r7[0xc]
8000a21e:	ed b8 00 02 	bld	r8,0x2
8000a222:	c0 91       	brne	8000a234 <_fflush_r+0x9c>
8000a224:	6e 18       	ld.w	r8,r7[0x4]
8000a226:	10 15       	sub	r5,r8
8000a228:	6e d8       	ld.w	r8,r7[0x34]
8000a22a:	58 08       	cp.w	r8,0
8000a22c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a230:	eb d8 e1 15 	subne	r5,r5,r8
8000a234:	6e b8       	ld.w	r8,r7[0x2c]
8000a236:	0c 9c       	mov	r12,r6
8000a238:	30 09       	mov	r9,0
8000a23a:	0a 9a       	mov	r10,r5
8000a23c:	6e 8b       	ld.w	r11,r7[0x20]
8000a23e:	5d 18       	icall	r8
8000a240:	8e 68       	ld.sh	r8,r7[0xc]
8000a242:	0a 3c       	cp.w	r12,r5
8000a244:	c2 61       	brne	8000a290 <_fflush_r+0xf8>
8000a246:	ab d8       	cbr	r8,0xb
8000a248:	30 0c       	mov	r12,0
8000a24a:	6e 49       	ld.w	r9,r7[0x10]
8000a24c:	ae 68       	st.h	r7[0xc],r8
8000a24e:	8f 1c       	st.w	r7[0x4],r12
8000a250:	8f 09       	st.w	r7[0x0],r9
8000a252:	ed b8 00 0c 	bld	r8,0xc
8000a256:	c2 51       	brne	8000a2a0 <_fflush_r+0x108>
8000a258:	ef 45 00 54 	st.w	r7[84],r5
8000a25c:	d8 22       	popm	r4-r7,pc
8000a25e:	6e 45       	ld.w	r5,r7[0x10]
8000a260:	58 05       	cp.w	r5,0
8000a262:	c1 f0       	breq	8000a2a0 <_fflush_r+0x108>
8000a264:	6e 04       	ld.w	r4,r7[0x0]
8000a266:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a26a:	8f 05       	st.w	r7[0x0],r5
8000a26c:	f9 b8 01 00 	movne	r8,0
8000a270:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a274:	0a 14       	sub	r4,r5
8000a276:	8f 28       	st.w	r7[0x8],r8
8000a278:	c1 18       	rjmp	8000a29a <_fflush_r+0x102>
8000a27a:	08 99       	mov	r9,r4
8000a27c:	0a 9a       	mov	r10,r5
8000a27e:	6e a8       	ld.w	r8,r7[0x28]
8000a280:	6e 8b       	ld.w	r11,r7[0x20]
8000a282:	0c 9c       	mov	r12,r6
8000a284:	5d 18       	icall	r8
8000a286:	18 14       	sub	r4,r12
8000a288:	58 0c       	cp.w	r12,0
8000a28a:	e0 89 00 07 	brgt	8000a298 <_fflush_r+0x100>
8000a28e:	8e 68       	ld.sh	r8,r7[0xc]
8000a290:	a7 a8       	sbr	r8,0x6
8000a292:	3f fc       	mov	r12,-1
8000a294:	ae 68       	st.h	r7[0xc],r8
8000a296:	d8 22       	popm	r4-r7,pc
8000a298:	18 05       	add	r5,r12
8000a29a:	58 04       	cp.w	r4,0
8000a29c:	fe 99 ff ef 	brgt	8000a27a <_fflush_r+0xe2>
8000a2a0:	d8 2a       	popm	r4-r7,pc,r12=0
8000a2a2:	d7 03       	nop

8000a2a4 <__sfp_lock_acquire>:
8000a2a4:	5e fc       	retal	r12

8000a2a6 <__sfp_lock_release>:
8000a2a6:	5e fc       	retal	r12

8000a2a8 <_cleanup_r>:
8000a2a8:	d4 01       	pushm	lr
8000a2aa:	fe cb f0 c6 	sub	r11,pc,-3898
8000a2ae:	e0 a0 02 f7 	rcall	8000a89c <_fwalk>
8000a2b2:	d8 02       	popm	pc

8000a2b4 <__sfmoreglue>:
8000a2b4:	d4 21       	pushm	r4-r7,lr
8000a2b6:	16 95       	mov	r5,r11
8000a2b8:	f6 06 10 5c 	mul	r6,r11,92
8000a2bc:	ec cb ff f4 	sub	r11,r6,-12
8000a2c0:	fe b0 e2 7c 	rcall	800067b8 <_malloc_r>
8000a2c4:	18 97       	mov	r7,r12
8000a2c6:	c0 90       	breq	8000a2d8 <__sfmoreglue+0x24>
8000a2c8:	99 15       	st.w	r12[0x4],r5
8000a2ca:	30 0b       	mov	r11,0
8000a2cc:	2f 4c       	sub	r12,-12
8000a2ce:	0c 9a       	mov	r10,r6
8000a2d0:	8f 2c       	st.w	r7[0x8],r12
8000a2d2:	8f 0b       	st.w	r7[0x0],r11
8000a2d4:	fe b0 e5 32 	rcall	80006d38 <memset>
8000a2d8:	0e 9c       	mov	r12,r7
8000a2da:	d8 22       	popm	r4-r7,pc

8000a2dc <__sfp>:
8000a2dc:	d4 21       	pushm	r4-r7,lr
8000a2de:	fe c8 ce ca 	sub	r8,pc,-12598
8000a2e2:	18 96       	mov	r6,r12
8000a2e4:	70 07       	ld.w	r7,r8[0x0]
8000a2e6:	6e 68       	ld.w	r8,r7[0x18]
8000a2e8:	58 08       	cp.w	r8,0
8000a2ea:	c0 31       	brne	8000a2f0 <__sfp+0x14>
8000a2ec:	0e 9c       	mov	r12,r7
8000a2ee:	c2 dc       	rcall	8000a348 <__sinit>
8000a2f0:	ee c7 ff 28 	sub	r7,r7,-216
8000a2f4:	30 05       	mov	r5,0
8000a2f6:	6e 2c       	ld.w	r12,r7[0x8]
8000a2f8:	6e 18       	ld.w	r8,r7[0x4]
8000a2fa:	c0 68       	rjmp	8000a306 <__sfp+0x2a>
8000a2fc:	98 69       	ld.sh	r9,r12[0xc]
8000a2fe:	ea 09 19 00 	cp.h	r9,r5
8000a302:	c1 10       	breq	8000a324 <__sfp+0x48>
8000a304:	2a 4c       	sub	r12,-92
8000a306:	20 18       	sub	r8,1
8000a308:	cf a7       	brpl	8000a2fc <__sfp+0x20>
8000a30a:	6e 08       	ld.w	r8,r7[0x0]
8000a30c:	58 08       	cp.w	r8,0
8000a30e:	c0 61       	brne	8000a31a <__sfp+0x3e>
8000a310:	30 4b       	mov	r11,4
8000a312:	0c 9c       	mov	r12,r6
8000a314:	cd 0f       	rcall	8000a2b4 <__sfmoreglue>
8000a316:	8f 0c       	st.w	r7[0x0],r12
8000a318:	c0 30       	breq	8000a31e <__sfp+0x42>
8000a31a:	6e 07       	ld.w	r7,r7[0x0]
8000a31c:	ce db       	rjmp	8000a2f6 <__sfp+0x1a>
8000a31e:	30 c8       	mov	r8,12
8000a320:	8d 38       	st.w	r6[0xc],r8
8000a322:	d8 22       	popm	r4-r7,pc
8000a324:	30 08       	mov	r8,0
8000a326:	f9 48 00 4c 	st.w	r12[76],r8
8000a32a:	99 08       	st.w	r12[0x0],r8
8000a32c:	99 28       	st.w	r12[0x8],r8
8000a32e:	99 18       	st.w	r12[0x4],r8
8000a330:	99 48       	st.w	r12[0x10],r8
8000a332:	99 58       	st.w	r12[0x14],r8
8000a334:	99 68       	st.w	r12[0x18],r8
8000a336:	99 d8       	st.w	r12[0x34],r8
8000a338:	99 e8       	st.w	r12[0x38],r8
8000a33a:	f9 48 00 48 	st.w	r12[72],r8
8000a33e:	3f f8       	mov	r8,-1
8000a340:	b8 78       	st.h	r12[0xe],r8
8000a342:	30 18       	mov	r8,1
8000a344:	b8 68       	st.h	r12[0xc],r8
8000a346:	d8 22       	popm	r4-r7,pc

8000a348 <__sinit>:
8000a348:	d4 21       	pushm	r4-r7,lr
8000a34a:	18 96       	mov	r6,r12
8000a34c:	78 67       	ld.w	r7,r12[0x18]
8000a34e:	58 07       	cp.w	r7,0
8000a350:	c4 91       	brne	8000a3e2 <__sinit+0x9a>
8000a352:	fe c8 00 aa 	sub	r8,pc,170
8000a356:	30 15       	mov	r5,1
8000a358:	99 a8       	st.w	r12[0x28],r8
8000a35a:	f9 47 00 d8 	st.w	r12[216],r7
8000a35e:	f9 47 00 dc 	st.w	r12[220],r7
8000a362:	f9 47 00 e0 	st.w	r12[224],r7
8000a366:	99 65       	st.w	r12[0x18],r5
8000a368:	cb af       	rcall	8000a2dc <__sfp>
8000a36a:	8d 0c       	st.w	r6[0x0],r12
8000a36c:	0c 9c       	mov	r12,r6
8000a36e:	cb 7f       	rcall	8000a2dc <__sfp>
8000a370:	8d 1c       	st.w	r6[0x4],r12
8000a372:	0c 9c       	mov	r12,r6
8000a374:	cb 4f       	rcall	8000a2dc <__sfp>
8000a376:	6c 09       	ld.w	r9,r6[0x0]
8000a378:	30 48       	mov	r8,4
8000a37a:	93 07       	st.w	r9[0x0],r7
8000a37c:	b2 68       	st.h	r9[0xc],r8
8000a37e:	93 17       	st.w	r9[0x4],r7
8000a380:	93 27       	st.w	r9[0x8],r7
8000a382:	6c 18       	ld.w	r8,r6[0x4]
8000a384:	b2 77       	st.h	r9[0xe],r7
8000a386:	93 47       	st.w	r9[0x10],r7
8000a388:	93 57       	st.w	r9[0x14],r7
8000a38a:	93 67       	st.w	r9[0x18],r7
8000a38c:	93 89       	st.w	r9[0x20],r9
8000a38e:	91 07       	st.w	r8[0x0],r7
8000a390:	91 17       	st.w	r8[0x4],r7
8000a392:	91 27       	st.w	r8[0x8],r7
8000a394:	fe ce f3 24 	sub	lr,pc,-3292
8000a398:	fe cb f3 54 	sub	r11,pc,-3244
8000a39c:	93 9e       	st.w	r9[0x24],lr
8000a39e:	93 ab       	st.w	r9[0x28],r11
8000a3a0:	fe ca f3 7c 	sub	r10,pc,-3204
8000a3a4:	fe c4 f3 88 	sub	r4,pc,-3192
8000a3a8:	93 ba       	st.w	r9[0x2c],r10
8000a3aa:	93 c4       	st.w	r9[0x30],r4
8000a3ac:	30 99       	mov	r9,9
8000a3ae:	b0 69       	st.h	r8[0xc],r9
8000a3b0:	b0 75       	st.h	r8[0xe],r5
8000a3b2:	91 c4       	st.w	r8[0x30],r4
8000a3b4:	91 47       	st.w	r8[0x10],r7
8000a3b6:	91 57       	st.w	r8[0x14],r7
8000a3b8:	91 67       	st.w	r8[0x18],r7
8000a3ba:	91 88       	st.w	r8[0x20],r8
8000a3bc:	91 9e       	st.w	r8[0x24],lr
8000a3be:	91 ab       	st.w	r8[0x28],r11
8000a3c0:	91 ba       	st.w	r8[0x2c],r10
8000a3c2:	8d 2c       	st.w	r6[0x8],r12
8000a3c4:	31 28       	mov	r8,18
8000a3c6:	99 07       	st.w	r12[0x0],r7
8000a3c8:	b8 68       	st.h	r12[0xc],r8
8000a3ca:	99 17       	st.w	r12[0x4],r7
8000a3cc:	99 27       	st.w	r12[0x8],r7
8000a3ce:	30 28       	mov	r8,2
8000a3d0:	b8 78       	st.h	r12[0xe],r8
8000a3d2:	99 c4       	st.w	r12[0x30],r4
8000a3d4:	99 67       	st.w	r12[0x18],r7
8000a3d6:	99 9e       	st.w	r12[0x24],lr
8000a3d8:	99 ab       	st.w	r12[0x28],r11
8000a3da:	99 ba       	st.w	r12[0x2c],r10
8000a3dc:	99 47       	st.w	r12[0x10],r7
8000a3de:	99 57       	st.w	r12[0x14],r7
8000a3e0:	99 8c       	st.w	r12[0x20],r12
8000a3e2:	d8 22       	popm	r4-r7,pc

8000a3e4 <_malloc_trim_r>:
8000a3e4:	d4 21       	pushm	r4-r7,lr
8000a3e6:	16 95       	mov	r5,r11
8000a3e8:	18 97       	mov	r7,r12
8000a3ea:	fe b0 d7 53 	rcall	80005290 <__malloc_lock>
8000a3ee:	e0 64 05 30 	mov	r4,1328
8000a3f2:	68 28       	ld.w	r8,r4[0x8]
8000a3f4:	70 16       	ld.w	r6,r8[0x4]
8000a3f6:	e0 16 ff fc 	andl	r6,0xfffc
8000a3fa:	ec c8 ff 91 	sub	r8,r6,-111
8000a3fe:	f0 05 01 05 	sub	r5,r8,r5
8000a402:	e0 15 ff 80 	andl	r5,0xff80
8000a406:	ea c5 00 80 	sub	r5,r5,128
8000a40a:	e0 45 00 7f 	cp.w	r5,127
8000a40e:	e0 8a 00 25 	brle	8000a458 <_malloc_trim_r+0x74>
8000a412:	30 0b       	mov	r11,0
8000a414:	0e 9c       	mov	r12,r7
8000a416:	fe b0 e5 f9 	rcall	80007008 <_sbrk_r>
8000a41a:	68 28       	ld.w	r8,r4[0x8]
8000a41c:	0c 08       	add	r8,r6
8000a41e:	10 3c       	cp.w	r12,r8
8000a420:	c1 c1       	brne	8000a458 <_malloc_trim_r+0x74>
8000a422:	ea 0b 11 00 	rsub	r11,r5,0
8000a426:	0e 9c       	mov	r12,r7
8000a428:	fe b0 e5 f0 	rcall	80007008 <_sbrk_r>
8000a42c:	5b fc       	cp.w	r12,-1
8000a42e:	c1 91       	brne	8000a460 <_malloc_trim_r+0x7c>
8000a430:	30 0b       	mov	r11,0
8000a432:	0e 9c       	mov	r12,r7
8000a434:	fe b0 e5 ea 	rcall	80007008 <_sbrk_r>
8000a438:	68 28       	ld.w	r8,r4[0x8]
8000a43a:	f8 08 01 09 	sub	r9,r12,r8
8000a43e:	58 f9       	cp.w	r9,15
8000a440:	e0 8a 00 0c 	brle	8000a458 <_malloc_trim_r+0x74>
8000a444:	a1 a9       	sbr	r9,0x0
8000a446:	91 19       	st.w	r8[0x4],r9
8000a448:	e0 68 09 3c 	mov	r8,2364
8000a44c:	70 09       	ld.w	r9,r8[0x0]
8000a44e:	e0 68 0d 68 	mov	r8,3432
8000a452:	f8 09 01 09 	sub	r9,r12,r9
8000a456:	91 09       	st.w	r8[0x0],r9
8000a458:	0e 9c       	mov	r12,r7
8000a45a:	fe b0 d7 21 	rcall	8000529c <__malloc_unlock>
8000a45e:	d8 2a       	popm	r4-r7,pc,r12=0
8000a460:	68 28       	ld.w	r8,r4[0x8]
8000a462:	0a 16       	sub	r6,r5
8000a464:	a1 a6       	sbr	r6,0x0
8000a466:	91 16       	st.w	r8[0x4],r6
8000a468:	e0 68 0d 68 	mov	r8,3432
8000a46c:	70 09       	ld.w	r9,r8[0x0]
8000a46e:	0a 19       	sub	r9,r5
8000a470:	0e 9c       	mov	r12,r7
8000a472:	91 09       	st.w	r8[0x0],r9
8000a474:	fe b0 d7 14 	rcall	8000529c <__malloc_unlock>
8000a478:	da 2a       	popm	r4-r7,pc,r12=1
8000a47a:	d7 03       	nop

8000a47c <_free_r>:
8000a47c:	d4 21       	pushm	r4-r7,lr
8000a47e:	16 96       	mov	r6,r11
8000a480:	18 97       	mov	r7,r12
8000a482:	58 0b       	cp.w	r11,0
8000a484:	e0 80 00 c0 	breq	8000a604 <_free_r+0x188>
8000a488:	fe b0 d7 04 	rcall	80005290 <__malloc_lock>
8000a48c:	20 86       	sub	r6,8
8000a48e:	e0 6a 05 30 	mov	r10,1328
8000a492:	6c 18       	ld.w	r8,r6[0x4]
8000a494:	74 2e       	ld.w	lr,r10[0x8]
8000a496:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a49a:	a1 c8       	cbr	r8,0x0
8000a49c:	ec 08 00 09 	add	r9,r6,r8
8000a4a0:	72 1b       	ld.w	r11,r9[0x4]
8000a4a2:	e0 1b ff fc 	andl	r11,0xfffc
8000a4a6:	1c 39       	cp.w	r9,lr
8000a4a8:	c1 e1       	brne	8000a4e4 <_free_r+0x68>
8000a4aa:	f6 08 00 08 	add	r8,r11,r8
8000a4ae:	58 0c       	cp.w	r12,0
8000a4b0:	c0 81       	brne	8000a4c0 <_free_r+0x44>
8000a4b2:	6c 09       	ld.w	r9,r6[0x0]
8000a4b4:	12 16       	sub	r6,r9
8000a4b6:	12 08       	add	r8,r9
8000a4b8:	6c 3b       	ld.w	r11,r6[0xc]
8000a4ba:	6c 29       	ld.w	r9,r6[0x8]
8000a4bc:	97 29       	st.w	r11[0x8],r9
8000a4be:	93 3b       	st.w	r9[0xc],r11
8000a4c0:	10 99       	mov	r9,r8
8000a4c2:	95 26       	st.w	r10[0x8],r6
8000a4c4:	a1 a9       	sbr	r9,0x0
8000a4c6:	8d 19       	st.w	r6[0x4],r9
8000a4c8:	e0 69 09 38 	mov	r9,2360
8000a4cc:	72 09       	ld.w	r9,r9[0x0]
8000a4ce:	12 38       	cp.w	r8,r9
8000a4d0:	c0 63       	brcs	8000a4dc <_free_r+0x60>
8000a4d2:	e0 68 0d 64 	mov	r8,3428
8000a4d6:	0e 9c       	mov	r12,r7
8000a4d8:	70 0b       	ld.w	r11,r8[0x0]
8000a4da:	c8 5f       	rcall	8000a3e4 <_malloc_trim_r>
8000a4dc:	0e 9c       	mov	r12,r7
8000a4de:	fe b0 d6 df 	rcall	8000529c <__malloc_unlock>
8000a4e2:	d8 22       	popm	r4-r7,pc
8000a4e4:	93 1b       	st.w	r9[0x4],r11
8000a4e6:	58 0c       	cp.w	r12,0
8000a4e8:	c0 30       	breq	8000a4ee <_free_r+0x72>
8000a4ea:	30 0c       	mov	r12,0
8000a4ec:	c1 08       	rjmp	8000a50c <_free_r+0x90>
8000a4ee:	6c 0e       	ld.w	lr,r6[0x0]
8000a4f0:	f4 c5 ff f8 	sub	r5,r10,-8
8000a4f4:	1c 16       	sub	r6,lr
8000a4f6:	1c 08       	add	r8,lr
8000a4f8:	6c 2e       	ld.w	lr,r6[0x8]
8000a4fa:	0a 3e       	cp.w	lr,r5
8000a4fc:	f9 bc 00 01 	moveq	r12,1
8000a500:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a504:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a508:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a50c:	f2 0b 00 0e 	add	lr,r9,r11
8000a510:	7c 1e       	ld.w	lr,lr[0x4]
8000a512:	ed be 00 00 	bld	lr,0x0
8000a516:	c1 40       	breq	8000a53e <_free_r+0xc2>
8000a518:	16 08       	add	r8,r11
8000a51a:	58 0c       	cp.w	r12,0
8000a51c:	c0 d1       	brne	8000a536 <_free_r+0xba>
8000a51e:	e0 6e 05 30 	mov	lr,1328
8000a522:	72 2b       	ld.w	r11,r9[0x8]
8000a524:	2f 8e       	sub	lr,-8
8000a526:	1c 3b       	cp.w	r11,lr
8000a528:	c0 71       	brne	8000a536 <_free_r+0xba>
8000a52a:	97 36       	st.w	r11[0xc],r6
8000a52c:	97 26       	st.w	r11[0x8],r6
8000a52e:	8d 2b       	st.w	r6[0x8],r11
8000a530:	8d 3b       	st.w	r6[0xc],r11
8000a532:	30 1c       	mov	r12,1
8000a534:	c0 58       	rjmp	8000a53e <_free_r+0xc2>
8000a536:	72 2b       	ld.w	r11,r9[0x8]
8000a538:	72 39       	ld.w	r9,r9[0xc]
8000a53a:	93 2b       	st.w	r9[0x8],r11
8000a53c:	97 39       	st.w	r11[0xc],r9
8000a53e:	10 99       	mov	r9,r8
8000a540:	ec 08 09 08 	st.w	r6[r8],r8
8000a544:	a1 a9       	sbr	r9,0x0
8000a546:	8d 19       	st.w	r6[0x4],r9
8000a548:	58 0c       	cp.w	r12,0
8000a54a:	c5 a1       	brne	8000a5fe <_free_r+0x182>
8000a54c:	e0 48 01 ff 	cp.w	r8,511
8000a550:	e0 8b 00 13 	brhi	8000a576 <_free_r+0xfa>
8000a554:	a3 98       	lsr	r8,0x3
8000a556:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a55a:	72 2b       	ld.w	r11,r9[0x8]
8000a55c:	8d 39       	st.w	r6[0xc],r9
8000a55e:	8d 2b       	st.w	r6[0x8],r11
8000a560:	97 36       	st.w	r11[0xc],r6
8000a562:	93 26       	st.w	r9[0x8],r6
8000a564:	a3 48       	asr	r8,0x2
8000a566:	74 19       	ld.w	r9,r10[0x4]
8000a568:	30 1b       	mov	r11,1
8000a56a:	f6 08 09 48 	lsl	r8,r11,r8
8000a56e:	f3 e8 10 08 	or	r8,r9,r8
8000a572:	95 18       	st.w	r10[0x4],r8
8000a574:	c4 58       	rjmp	8000a5fe <_free_r+0x182>
8000a576:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a57a:	58 4b       	cp.w	r11,4
8000a57c:	e0 8b 00 06 	brhi	8000a588 <_free_r+0x10c>
8000a580:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a584:	2c 8b       	sub	r11,-56
8000a586:	c2 08       	rjmp	8000a5c6 <_free_r+0x14a>
8000a588:	59 4b       	cp.w	r11,20
8000a58a:	e0 8b 00 04 	brhi	8000a592 <_free_r+0x116>
8000a58e:	2a 5b       	sub	r11,-91
8000a590:	c1 b8       	rjmp	8000a5c6 <_free_r+0x14a>
8000a592:	e0 4b 00 54 	cp.w	r11,84
8000a596:	e0 8b 00 06 	brhi	8000a5a2 <_free_r+0x126>
8000a59a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a59e:	29 2b       	sub	r11,-110
8000a5a0:	c1 38       	rjmp	8000a5c6 <_free_r+0x14a>
8000a5a2:	e0 4b 01 54 	cp.w	r11,340
8000a5a6:	e0 8b 00 06 	brhi	8000a5b2 <_free_r+0x136>
8000a5aa:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a5ae:	28 9b       	sub	r11,-119
8000a5b0:	c0 b8       	rjmp	8000a5c6 <_free_r+0x14a>
8000a5b2:	e0 4b 05 54 	cp.w	r11,1364
8000a5b6:	e0 88 00 05 	brls	8000a5c0 <_free_r+0x144>
8000a5ba:	37 eb       	mov	r11,126
8000a5bc:	c0 58       	rjmp	8000a5c6 <_free_r+0x14a>
8000a5be:	d7 03       	nop
8000a5c0:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a5c4:	28 4b       	sub	r11,-124
8000a5c6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a5ca:	78 29       	ld.w	r9,r12[0x8]
8000a5cc:	18 39       	cp.w	r9,r12
8000a5ce:	c0 e1       	brne	8000a5ea <_free_r+0x16e>
8000a5d0:	74 18       	ld.w	r8,r10[0x4]
8000a5d2:	a3 4b       	asr	r11,0x2
8000a5d4:	30 1c       	mov	r12,1
8000a5d6:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a5da:	f1 eb 10 0b 	or	r11,r8,r11
8000a5de:	12 98       	mov	r8,r9
8000a5e0:	95 1b       	st.w	r10[0x4],r11
8000a5e2:	c0 a8       	rjmp	8000a5f6 <_free_r+0x17a>
8000a5e4:	72 29       	ld.w	r9,r9[0x8]
8000a5e6:	18 39       	cp.w	r9,r12
8000a5e8:	c0 60       	breq	8000a5f4 <_free_r+0x178>
8000a5ea:	72 1a       	ld.w	r10,r9[0x4]
8000a5ec:	e0 1a ff fc 	andl	r10,0xfffc
8000a5f0:	14 38       	cp.w	r8,r10
8000a5f2:	cf 93       	brcs	8000a5e4 <_free_r+0x168>
8000a5f4:	72 38       	ld.w	r8,r9[0xc]
8000a5f6:	8d 38       	st.w	r6[0xc],r8
8000a5f8:	8d 29       	st.w	r6[0x8],r9
8000a5fa:	93 36       	st.w	r9[0xc],r6
8000a5fc:	91 26       	st.w	r8[0x8],r6
8000a5fe:	0e 9c       	mov	r12,r7
8000a600:	fe b0 d6 4e 	rcall	8000529c <__malloc_unlock>
8000a604:	d8 22       	popm	r4-r7,pc
8000a606:	d7 03       	nop

8000a608 <__sfvwrite_r>:
8000a608:	d4 31       	pushm	r0-r7,lr
8000a60a:	20 3d       	sub	sp,12
8000a60c:	14 94       	mov	r4,r10
8000a60e:	18 95       	mov	r5,r12
8000a610:	16 97       	mov	r7,r11
8000a612:	74 28       	ld.w	r8,r10[0x8]
8000a614:	58 08       	cp.w	r8,0
8000a616:	e0 80 01 40 	breq	8000a896 <__sfvwrite_r+0x28e>
8000a61a:	96 68       	ld.sh	r8,r11[0xc]
8000a61c:	ed b8 00 03 	bld	r8,0x3
8000a620:	c0 41       	brne	8000a628 <__sfvwrite_r+0x20>
8000a622:	76 48       	ld.w	r8,r11[0x10]
8000a624:	58 08       	cp.w	r8,0
8000a626:	c0 c1       	brne	8000a63e <__sfvwrite_r+0x36>
8000a628:	0e 9b       	mov	r11,r7
8000a62a:	0a 9c       	mov	r12,r5
8000a62c:	fe b0 f6 c4 	rcall	800093b4 <__swsetup_r>
8000a630:	c0 70       	breq	8000a63e <__sfvwrite_r+0x36>
8000a632:	8e 68       	ld.sh	r8,r7[0xc]
8000a634:	a7 a8       	sbr	r8,0x6
8000a636:	ae 68       	st.h	r7[0xc],r8
8000a638:	30 98       	mov	r8,9
8000a63a:	8b 38       	st.w	r5[0xc],r8
8000a63c:	c2 b9       	rjmp	8000a892 <__sfvwrite_r+0x28a>
8000a63e:	8e 63       	ld.sh	r3,r7[0xc]
8000a640:	68 00       	ld.w	r0,r4[0x0]
8000a642:	06 96       	mov	r6,r3
8000a644:	e2 16 00 02 	andl	r6,0x2,COH
8000a648:	c2 10       	breq	8000a68a <__sfvwrite_r+0x82>
8000a64a:	30 03       	mov	r3,0
8000a64c:	e0 62 04 00 	mov	r2,1024
8000a650:	06 96       	mov	r6,r3
8000a652:	c0 48       	rjmp	8000a65a <__sfvwrite_r+0x52>
8000a654:	60 03       	ld.w	r3,r0[0x0]
8000a656:	60 16       	ld.w	r6,r0[0x4]
8000a658:	2f 80       	sub	r0,-8
8000a65a:	58 06       	cp.w	r6,0
8000a65c:	cf c0       	breq	8000a654 <__sfvwrite_r+0x4c>
8000a65e:	e0 46 04 00 	cp.w	r6,1024
8000a662:	ec 09 17 80 	movls	r9,r6
8000a666:	e4 09 17 b0 	movhi	r9,r2
8000a66a:	06 9a       	mov	r10,r3
8000a66c:	6e a8       	ld.w	r8,r7[0x28]
8000a66e:	6e 8b       	ld.w	r11,r7[0x20]
8000a670:	0a 9c       	mov	r12,r5
8000a672:	5d 18       	icall	r8
8000a674:	18 16       	sub	r6,r12
8000a676:	58 0c       	cp.w	r12,0
8000a678:	e0 8a 01 0a 	brle	8000a88c <__sfvwrite_r+0x284>
8000a67c:	68 28       	ld.w	r8,r4[0x8]
8000a67e:	18 18       	sub	r8,r12
8000a680:	89 28       	st.w	r4[0x8],r8
8000a682:	e0 80 01 0a 	breq	8000a896 <__sfvwrite_r+0x28e>
8000a686:	18 03       	add	r3,r12
8000a688:	ce 9b       	rjmp	8000a65a <__sfvwrite_r+0x52>
8000a68a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a68e:	c0 70       	breq	8000a69c <__sfvwrite_r+0x94>
8000a690:	50 06       	stdsp	sp[0x0],r6
8000a692:	0c 93       	mov	r3,r6
8000a694:	0c 91       	mov	r1,r6
8000a696:	50 15       	stdsp	sp[0x4],r5
8000a698:	08 92       	mov	r2,r4
8000a69a:	c9 c8       	rjmp	8000a7d2 <__sfvwrite_r+0x1ca>
8000a69c:	06 96       	mov	r6,r3
8000a69e:	08 91       	mov	r1,r4
8000a6a0:	c0 48       	rjmp	8000a6a8 <__sfvwrite_r+0xa0>
8000a6a2:	60 03       	ld.w	r3,r0[0x0]
8000a6a4:	60 16       	ld.w	r6,r0[0x4]
8000a6a6:	2f 80       	sub	r0,-8
8000a6a8:	58 06       	cp.w	r6,0
8000a6aa:	cf c0       	breq	8000a6a2 <__sfvwrite_r+0x9a>
8000a6ac:	8e 68       	ld.sh	r8,r7[0xc]
8000a6ae:	6e 24       	ld.w	r4,r7[0x8]
8000a6b0:	10 99       	mov	r9,r8
8000a6b2:	e2 19 02 00 	andl	r9,0x200,COH
8000a6b6:	c5 50       	breq	8000a760 <__sfvwrite_r+0x158>
8000a6b8:	08 36       	cp.w	r6,r4
8000a6ba:	c4 43       	brcs	8000a742 <__sfvwrite_r+0x13a>
8000a6bc:	10 99       	mov	r9,r8
8000a6be:	e2 19 04 80 	andl	r9,0x480,COH
8000a6c2:	c4 00       	breq	8000a742 <__sfvwrite_r+0x13a>
8000a6c4:	6e 4b       	ld.w	r11,r7[0x10]
8000a6c6:	6e 09       	ld.w	r9,r7[0x0]
8000a6c8:	16 19       	sub	r9,r11
8000a6ca:	50 09       	stdsp	sp[0x0],r9
8000a6cc:	6e 59       	ld.w	r9,r7[0x14]
8000a6ce:	10 9c       	mov	r12,r8
8000a6d0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a6d4:	30 28       	mov	r8,2
8000a6d6:	f4 08 0c 08 	divs	r8,r10,r8
8000a6da:	fa e9 00 04 	st.d	sp[4],r8
8000a6de:	10 94       	mov	r4,r8
8000a6e0:	40 09       	lddsp	r9,sp[0x0]
8000a6e2:	e2 1c 04 00 	andl	r12,0x400,COH
8000a6e6:	2f f9       	sub	r9,-1
8000a6e8:	0c 09       	add	r9,r6
8000a6ea:	12 38       	cp.w	r8,r9
8000a6ec:	f2 04 17 30 	movlo	r4,r9
8000a6f0:	58 0c       	cp.w	r12,0
8000a6f2:	c1 10       	breq	8000a714 <__sfvwrite_r+0x10c>
8000a6f4:	08 9b       	mov	r11,r4
8000a6f6:	0a 9c       	mov	r12,r5
8000a6f8:	fe b0 e0 60 	rcall	800067b8 <_malloc_r>
8000a6fc:	18 92       	mov	r2,r12
8000a6fe:	c1 40       	breq	8000a726 <__sfvwrite_r+0x11e>
8000a700:	40 0a       	lddsp	r10,sp[0x0]
8000a702:	6e 4b       	ld.w	r11,r7[0x10]
8000a704:	fe b0 e2 76 	rcall	80006bf0 <memcpy>
8000a708:	8e 68       	ld.sh	r8,r7[0xc]
8000a70a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a70e:	a7 b8       	sbr	r8,0x7
8000a710:	ae 68       	st.h	r7[0xc],r8
8000a712:	c0 d8       	rjmp	8000a72c <__sfvwrite_r+0x124>
8000a714:	08 9a       	mov	r10,r4
8000a716:	0a 9c       	mov	r12,r5
8000a718:	fe b0 e3 18 	rcall	80006d48 <_realloc_r>
8000a71c:	18 92       	mov	r2,r12
8000a71e:	c0 71       	brne	8000a72c <__sfvwrite_r+0x124>
8000a720:	6e 4b       	ld.w	r11,r7[0x10]
8000a722:	0a 9c       	mov	r12,r5
8000a724:	ca ce       	rcall	8000a47c <_free_r>
8000a726:	30 c8       	mov	r8,12
8000a728:	8b 38       	st.w	r5[0xc],r8
8000a72a:	cb 18       	rjmp	8000a88c <__sfvwrite_r+0x284>
8000a72c:	40 0a       	lddsp	r10,sp[0x0]
8000a72e:	40 09       	lddsp	r9,sp[0x0]
8000a730:	e8 0a 01 0a 	sub	r10,r4,r10
8000a734:	e4 09 00 08 	add	r8,r2,r9
8000a738:	8f 54       	st.w	r7[0x14],r4
8000a73a:	8f 2a       	st.w	r7[0x8],r10
8000a73c:	8f 08       	st.w	r7[0x0],r8
8000a73e:	8f 42       	st.w	r7[0x10],r2
8000a740:	0c 94       	mov	r4,r6
8000a742:	08 36       	cp.w	r6,r4
8000a744:	ec 04 17 30 	movlo	r4,r6
8000a748:	06 9b       	mov	r11,r3
8000a74a:	08 9a       	mov	r10,r4
8000a74c:	6e 0c       	ld.w	r12,r7[0x0]
8000a74e:	c3 ad       	rcall	8000a9c2 <memmove>
8000a750:	6e 08       	ld.w	r8,r7[0x0]
8000a752:	08 08       	add	r8,r4
8000a754:	8f 08       	st.w	r7[0x0],r8
8000a756:	6e 28       	ld.w	r8,r7[0x8]
8000a758:	08 18       	sub	r8,r4
8000a75a:	0c 94       	mov	r4,r6
8000a75c:	8f 28       	st.w	r7[0x8],r8
8000a75e:	c2 e8       	rjmp	8000a7ba <__sfvwrite_r+0x1b2>
8000a760:	08 36       	cp.w	r6,r4
8000a762:	5f ba       	srhi	r10
8000a764:	6e 0c       	ld.w	r12,r7[0x0]
8000a766:	6e 48       	ld.w	r8,r7[0x10]
8000a768:	10 3c       	cp.w	r12,r8
8000a76a:	5f b8       	srhi	r8
8000a76c:	f5 e8 00 08 	and	r8,r10,r8
8000a770:	f2 08 18 00 	cp.b	r8,r9
8000a774:	c0 d0       	breq	8000a78e <__sfvwrite_r+0x186>
8000a776:	06 9b       	mov	r11,r3
8000a778:	08 9a       	mov	r10,r4
8000a77a:	c2 4d       	rcall	8000a9c2 <memmove>
8000a77c:	6e 08       	ld.w	r8,r7[0x0]
8000a77e:	08 08       	add	r8,r4
8000a780:	0e 9b       	mov	r11,r7
8000a782:	8f 08       	st.w	r7[0x0],r8
8000a784:	0a 9c       	mov	r12,r5
8000a786:	fe b0 fd 09 	rcall	8000a198 <_fflush_r>
8000a78a:	c1 80       	breq	8000a7ba <__sfvwrite_r+0x1b2>
8000a78c:	c8 08       	rjmp	8000a88c <__sfvwrite_r+0x284>
8000a78e:	6e 59       	ld.w	r9,r7[0x14]
8000a790:	12 36       	cp.w	r6,r9
8000a792:	c0 a3       	brcs	8000a7a6 <__sfvwrite_r+0x19e>
8000a794:	6e a8       	ld.w	r8,r7[0x28]
8000a796:	06 9a       	mov	r10,r3
8000a798:	6e 8b       	ld.w	r11,r7[0x20]
8000a79a:	0a 9c       	mov	r12,r5
8000a79c:	5d 18       	icall	r8
8000a79e:	18 94       	mov	r4,r12
8000a7a0:	e0 89 00 0d 	brgt	8000a7ba <__sfvwrite_r+0x1b2>
8000a7a4:	c7 48       	rjmp	8000a88c <__sfvwrite_r+0x284>
8000a7a6:	0c 9a       	mov	r10,r6
8000a7a8:	06 9b       	mov	r11,r3
8000a7aa:	c0 cd       	rcall	8000a9c2 <memmove>
8000a7ac:	6e 08       	ld.w	r8,r7[0x0]
8000a7ae:	0c 08       	add	r8,r6
8000a7b0:	0c 94       	mov	r4,r6
8000a7b2:	8f 08       	st.w	r7[0x0],r8
8000a7b4:	6e 28       	ld.w	r8,r7[0x8]
8000a7b6:	0c 18       	sub	r8,r6
8000a7b8:	8f 28       	st.w	r7[0x8],r8
8000a7ba:	62 28       	ld.w	r8,r1[0x8]
8000a7bc:	08 18       	sub	r8,r4
8000a7be:	83 28       	st.w	r1[0x8],r8
8000a7c0:	c6 b0       	breq	8000a896 <__sfvwrite_r+0x28e>
8000a7c2:	08 16       	sub	r6,r4
8000a7c4:	08 03       	add	r3,r4
8000a7c6:	c7 1b       	rjmp	8000a6a8 <__sfvwrite_r+0xa0>
8000a7c8:	60 03       	ld.w	r3,r0[0x0]
8000a7ca:	60 11       	ld.w	r1,r0[0x4]
8000a7cc:	30 08       	mov	r8,0
8000a7ce:	2f 80       	sub	r0,-8
8000a7d0:	50 08       	stdsp	sp[0x0],r8
8000a7d2:	58 01       	cp.w	r1,0
8000a7d4:	cf a0       	breq	8000a7c8 <__sfvwrite_r+0x1c0>
8000a7d6:	40 0a       	lddsp	r10,sp[0x0]
8000a7d8:	58 0a       	cp.w	r10,0
8000a7da:	c1 41       	brne	8000a802 <__sfvwrite_r+0x1fa>
8000a7dc:	e2 c6 ff ff 	sub	r6,r1,-1
8000a7e0:	02 9a       	mov	r10,r1
8000a7e2:	30 ab       	mov	r11,10
8000a7e4:	06 9c       	mov	r12,r3
8000a7e6:	ce 3c       	rcall	8000a9ac <memchr>
8000a7e8:	f8 c8 ff ff 	sub	r8,r12,-1
8000a7ec:	58 0c       	cp.w	r12,0
8000a7ee:	f1 d3 e1 16 	subne	r6,r8,r3
8000a7f2:	f9 b9 01 01 	movne	r9,1
8000a7f6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a7fa:	f9 b8 00 01 	moveq	r8,1
8000a7fe:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a802:	02 36       	cp.w	r6,r1
8000a804:	ec 04 17 80 	movls	r4,r6
8000a808:	e2 04 17 b0 	movhi	r4,r1
8000a80c:	6e 59       	ld.w	r9,r7[0x14]
8000a80e:	6e 25       	ld.w	r5,r7[0x8]
8000a810:	f2 05 00 05 	add	r5,r9,r5
8000a814:	0a 34       	cp.w	r4,r5
8000a816:	5f 9a       	srgt	r10
8000a818:	6e 0c       	ld.w	r12,r7[0x0]
8000a81a:	6e 48       	ld.w	r8,r7[0x10]
8000a81c:	10 3c       	cp.w	r12,r8
8000a81e:	5f b8       	srhi	r8
8000a820:	f5 e8 00 08 	and	r8,r10,r8
8000a824:	30 0a       	mov	r10,0
8000a826:	f4 08 18 00 	cp.b	r8,r10
8000a82a:	c0 d0       	breq	8000a844 <__sfvwrite_r+0x23c>
8000a82c:	06 9b       	mov	r11,r3
8000a82e:	0a 9a       	mov	r10,r5
8000a830:	cc 9c       	rcall	8000a9c2 <memmove>
8000a832:	6e 08       	ld.w	r8,r7[0x0]
8000a834:	0a 08       	add	r8,r5
8000a836:	0e 9b       	mov	r11,r7
8000a838:	8f 08       	st.w	r7[0x0],r8
8000a83a:	40 1c       	lddsp	r12,sp[0x4]
8000a83c:	fe b0 fc ae 	rcall	8000a198 <_fflush_r>
8000a840:	c1 70       	breq	8000a86e <__sfvwrite_r+0x266>
8000a842:	c2 58       	rjmp	8000a88c <__sfvwrite_r+0x284>
8000a844:	12 34       	cp.w	r4,r9
8000a846:	c0 a5       	brlt	8000a85a <__sfvwrite_r+0x252>
8000a848:	6e a8       	ld.w	r8,r7[0x28]
8000a84a:	06 9a       	mov	r10,r3
8000a84c:	6e 8b       	ld.w	r11,r7[0x20]
8000a84e:	40 1c       	lddsp	r12,sp[0x4]
8000a850:	5d 18       	icall	r8
8000a852:	18 95       	mov	r5,r12
8000a854:	e0 89 00 0d 	brgt	8000a86e <__sfvwrite_r+0x266>
8000a858:	c1 a8       	rjmp	8000a88c <__sfvwrite_r+0x284>
8000a85a:	08 9a       	mov	r10,r4
8000a85c:	06 9b       	mov	r11,r3
8000a85e:	cb 2c       	rcall	8000a9c2 <memmove>
8000a860:	6e 08       	ld.w	r8,r7[0x0]
8000a862:	08 08       	add	r8,r4
8000a864:	08 95       	mov	r5,r4
8000a866:	8f 08       	st.w	r7[0x0],r8
8000a868:	6e 28       	ld.w	r8,r7[0x8]
8000a86a:	08 18       	sub	r8,r4
8000a86c:	8f 28       	st.w	r7[0x8],r8
8000a86e:	0a 16       	sub	r6,r5
8000a870:	c0 71       	brne	8000a87e <__sfvwrite_r+0x276>
8000a872:	0e 9b       	mov	r11,r7
8000a874:	40 1c       	lddsp	r12,sp[0x4]
8000a876:	fe b0 fc 91 	rcall	8000a198 <_fflush_r>
8000a87a:	c0 91       	brne	8000a88c <__sfvwrite_r+0x284>
8000a87c:	50 06       	stdsp	sp[0x0],r6
8000a87e:	64 28       	ld.w	r8,r2[0x8]
8000a880:	0a 18       	sub	r8,r5
8000a882:	85 28       	st.w	r2[0x8],r8
8000a884:	c0 90       	breq	8000a896 <__sfvwrite_r+0x28e>
8000a886:	0a 11       	sub	r1,r5
8000a888:	0a 03       	add	r3,r5
8000a88a:	ca 4b       	rjmp	8000a7d2 <__sfvwrite_r+0x1ca>
8000a88c:	8e 68       	ld.sh	r8,r7[0xc]
8000a88e:	a7 a8       	sbr	r8,0x6
8000a890:	ae 68       	st.h	r7[0xc],r8
8000a892:	3f fc       	mov	r12,-1
8000a894:	c0 28       	rjmp	8000a898 <__sfvwrite_r+0x290>
8000a896:	30 0c       	mov	r12,0
8000a898:	2f dd       	sub	sp,-12
8000a89a:	d8 32       	popm	r0-r7,pc

8000a89c <_fwalk>:
8000a89c:	d4 31       	pushm	r0-r7,lr
8000a89e:	30 05       	mov	r5,0
8000a8a0:	16 91       	mov	r1,r11
8000a8a2:	f8 c7 ff 28 	sub	r7,r12,-216
8000a8a6:	0a 92       	mov	r2,r5
8000a8a8:	fe b0 fc fe 	rcall	8000a2a4 <__sfp_lock_acquire>
8000a8ac:	3f f3       	mov	r3,-1
8000a8ae:	c1 68       	rjmp	8000a8da <_fwalk+0x3e>
8000a8b0:	6e 26       	ld.w	r6,r7[0x8]
8000a8b2:	6e 14       	ld.w	r4,r7[0x4]
8000a8b4:	2f 46       	sub	r6,-12
8000a8b6:	c0 c8       	rjmp	8000a8ce <_fwalk+0x32>
8000a8b8:	8c 08       	ld.sh	r8,r6[0x0]
8000a8ba:	e4 08 19 00 	cp.h	r8,r2
8000a8be:	c0 70       	breq	8000a8cc <_fwalk+0x30>
8000a8c0:	8c 18       	ld.sh	r8,r6[0x2]
8000a8c2:	e6 08 19 00 	cp.h	r8,r3
8000a8c6:	c0 30       	breq	8000a8cc <_fwalk+0x30>
8000a8c8:	5d 11       	icall	r1
8000a8ca:	18 45       	or	r5,r12
8000a8cc:	2a 46       	sub	r6,-92
8000a8ce:	20 14       	sub	r4,1
8000a8d0:	ec cc 00 0c 	sub	r12,r6,12
8000a8d4:	58 04       	cp.w	r4,0
8000a8d6:	cf 14       	brge	8000a8b8 <_fwalk+0x1c>
8000a8d8:	6e 07       	ld.w	r7,r7[0x0]
8000a8da:	58 07       	cp.w	r7,0
8000a8dc:	ce a1       	brne	8000a8b0 <_fwalk+0x14>
8000a8de:	fe b0 fc e4 	rcall	8000a2a6 <__sfp_lock_release>
8000a8e2:	0a 9c       	mov	r12,r5
8000a8e4:	d8 32       	popm	r0-r7,pc
8000a8e6:	d7 03       	nop

8000a8e8 <_localeconv_r>:
8000a8e8:	fe cc d4 d0 	sub	r12,pc,-11056
8000a8ec:	5e fc       	retal	r12
8000a8ee:	d7 03       	nop

8000a8f0 <__smakebuf_r>:
8000a8f0:	d4 21       	pushm	r4-r7,lr
8000a8f2:	20 fd       	sub	sp,60
8000a8f4:	96 68       	ld.sh	r8,r11[0xc]
8000a8f6:	16 97       	mov	r7,r11
8000a8f8:	18 96       	mov	r6,r12
8000a8fa:	e2 18 00 02 	andl	r8,0x2,COH
8000a8fe:	c3 d1       	brne	8000a978 <__smakebuf_r+0x88>
8000a900:	96 7b       	ld.sh	r11,r11[0xe]
8000a902:	f0 0b 19 00 	cp.h	r11,r8
8000a906:	c0 55       	brlt	8000a910 <__smakebuf_r+0x20>
8000a908:	1a 9a       	mov	r10,sp
8000a90a:	e0 a0 04 75 	rcall	8000b1f4 <_fstat_r>
8000a90e:	c0 f4       	brge	8000a92c <__smakebuf_r+0x3c>
8000a910:	8e 65       	ld.sh	r5,r7[0xc]
8000a912:	0a 98       	mov	r8,r5
8000a914:	ab b8       	sbr	r8,0xb
8000a916:	e2 15 00 80 	andl	r5,0x80,COH
8000a91a:	ae 68       	st.h	r7[0xc],r8
8000a91c:	30 04       	mov	r4,0
8000a91e:	e0 68 04 00 	mov	r8,1024
8000a922:	f9 b5 01 40 	movne	r5,64
8000a926:	f0 05 17 00 	moveq	r5,r8
8000a92a:	c1 c8       	rjmp	8000a962 <__smakebuf_r+0x72>
8000a92c:	40 18       	lddsp	r8,sp[0x4]
8000a92e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a932:	e0 48 20 00 	cp.w	r8,8192
8000a936:	5f 04       	sreq	r4
8000a938:	e0 48 80 00 	cp.w	r8,32768
8000a93c:	c0 e1       	brne	8000a958 <__smakebuf_r+0x68>
8000a93e:	6e b9       	ld.w	r9,r7[0x2c]
8000a940:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a944:	10 39       	cp.w	r9,r8
8000a946:	c0 91       	brne	8000a958 <__smakebuf_r+0x68>
8000a948:	8e 68       	ld.sh	r8,r7[0xc]
8000a94a:	e0 65 04 00 	mov	r5,1024
8000a94e:	ab a8       	sbr	r8,0xa
8000a950:	ef 45 00 50 	st.w	r7[80],r5
8000a954:	ae 68       	st.h	r7[0xc],r8
8000a956:	c0 68       	rjmp	8000a962 <__smakebuf_r+0x72>
8000a958:	8e 68       	ld.sh	r8,r7[0xc]
8000a95a:	e0 65 04 00 	mov	r5,1024
8000a95e:	ab b8       	sbr	r8,0xb
8000a960:	ae 68       	st.h	r7[0xc],r8
8000a962:	0a 9b       	mov	r11,r5
8000a964:	0c 9c       	mov	r12,r6
8000a966:	fe b0 df 29 	rcall	800067b8 <_malloc_r>
8000a96a:	8e 68       	ld.sh	r8,r7[0xc]
8000a96c:	c0 d1       	brne	8000a986 <__smakebuf_r+0x96>
8000a96e:	ed b8 00 09 	bld	r8,0x9
8000a972:	c1 b0       	breq	8000a9a8 <__smakebuf_r+0xb8>
8000a974:	a1 b8       	sbr	r8,0x1
8000a976:	ae 68       	st.h	r7[0xc],r8
8000a978:	ee c8 ff b9 	sub	r8,r7,-71
8000a97c:	8f 48       	st.w	r7[0x10],r8
8000a97e:	8f 08       	st.w	r7[0x0],r8
8000a980:	30 18       	mov	r8,1
8000a982:	8f 58       	st.w	r7[0x14],r8
8000a984:	c1 28       	rjmp	8000a9a8 <__smakebuf_r+0xb8>
8000a986:	a7 b8       	sbr	r8,0x7
8000a988:	8f 4c       	st.w	r7[0x10],r12
8000a98a:	ae 68       	st.h	r7[0xc],r8
8000a98c:	8f 55       	st.w	r7[0x14],r5
8000a98e:	fe c8 06 e6 	sub	r8,pc,1766
8000a992:	8f 0c       	st.w	r7[0x0],r12
8000a994:	8d a8       	st.w	r6[0x28],r8
8000a996:	58 04       	cp.w	r4,0
8000a998:	c0 80       	breq	8000a9a8 <__smakebuf_r+0xb8>
8000a99a:	8e 7c       	ld.sh	r12,r7[0xe]
8000a99c:	fe b0 e3 94 	rcall	800070c4 <isatty>
8000a9a0:	c0 40       	breq	8000a9a8 <__smakebuf_r+0xb8>
8000a9a2:	8e 68       	ld.sh	r8,r7[0xc]
8000a9a4:	a1 a8       	sbr	r8,0x0
8000a9a6:	ae 68       	st.h	r7[0xc],r8
8000a9a8:	2f 1d       	sub	sp,-60
8000a9aa:	d8 22       	popm	r4-r7,pc

8000a9ac <memchr>:
8000a9ac:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a9b0:	c0 68       	rjmp	8000a9bc <memchr+0x10>
8000a9b2:	20 1a       	sub	r10,1
8000a9b4:	19 88       	ld.ub	r8,r12[0x0]
8000a9b6:	16 38       	cp.w	r8,r11
8000a9b8:	5e 0c       	reteq	r12
8000a9ba:	2f fc       	sub	r12,-1
8000a9bc:	58 0a       	cp.w	r10,0
8000a9be:	cf a1       	brne	8000a9b2 <memchr+0x6>
8000a9c0:	5e fa       	retal	r10

8000a9c2 <memmove>:
8000a9c2:	d4 01       	pushm	lr
8000a9c4:	18 3b       	cp.w	r11,r12
8000a9c6:	c1 92       	brcc	8000a9f8 <memmove+0x36>
8000a9c8:	f6 0a 00 09 	add	r9,r11,r10
8000a9cc:	12 3c       	cp.w	r12,r9
8000a9ce:	c1 52       	brcc	8000a9f8 <memmove+0x36>
8000a9d0:	f8 0a 00 0b 	add	r11,r12,r10
8000a9d4:	30 08       	mov	r8,0
8000a9d6:	c0 68       	rjmp	8000a9e2 <memmove+0x20>
8000a9d8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a9dc:	20 1a       	sub	r10,1
8000a9de:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a9e2:	20 18       	sub	r8,1
8000a9e4:	58 0a       	cp.w	r10,0
8000a9e6:	cf 91       	brne	8000a9d8 <memmove+0x16>
8000a9e8:	d8 02       	popm	pc
8000a9ea:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a9ee:	20 1a       	sub	r10,1
8000a9f0:	f8 08 0b 09 	st.b	r12[r8],r9
8000a9f4:	2f f8       	sub	r8,-1
8000a9f6:	c0 28       	rjmp	8000a9fa <memmove+0x38>
8000a9f8:	30 08       	mov	r8,0
8000a9fa:	58 0a       	cp.w	r10,0
8000a9fc:	cf 71       	brne	8000a9ea <memmove+0x28>
8000a9fe:	d8 02       	popm	pc

8000aa00 <__hi0bits>:
8000aa00:	18 98       	mov	r8,r12
8000aa02:	e0 1c 00 00 	andl	r12,0x0
8000aa06:	f0 09 15 10 	lsl	r9,r8,0x10
8000aa0a:	58 0c       	cp.w	r12,0
8000aa0c:	f2 08 17 00 	moveq	r8,r9
8000aa10:	f9 bc 00 10 	moveq	r12,16
8000aa14:	f9 bc 01 00 	movne	r12,0
8000aa18:	10 9a       	mov	r10,r8
8000aa1a:	f0 09 15 08 	lsl	r9,r8,0x8
8000aa1e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000aa22:	f7 bc 00 f8 	subeq	r12,-8
8000aa26:	f2 08 17 00 	moveq	r8,r9
8000aa2a:	10 9a       	mov	r10,r8
8000aa2c:	f0 09 15 04 	lsl	r9,r8,0x4
8000aa30:	e6 1a f0 00 	andh	r10,0xf000,COH
8000aa34:	f7 bc 00 fc 	subeq	r12,-4
8000aa38:	f2 08 17 00 	moveq	r8,r9
8000aa3c:	10 9a       	mov	r10,r8
8000aa3e:	f0 09 15 02 	lsl	r9,r8,0x2
8000aa42:	e6 1a c0 00 	andh	r10,0xc000,COH
8000aa46:	f7 bc 00 fe 	subeq	r12,-2
8000aa4a:	f2 08 17 00 	moveq	r8,r9
8000aa4e:	58 08       	cp.w	r8,0
8000aa50:	5e 5c       	retlt	r12
8000aa52:	ed b8 00 1e 	bld	r8,0x1e
8000aa56:	f9 bc 01 20 	movne	r12,32
8000aa5a:	f7 bc 00 ff 	subeq	r12,-1
8000aa5e:	5e fc       	retal	r12

8000aa60 <__lo0bits>:
8000aa60:	18 99       	mov	r9,r12
8000aa62:	78 08       	ld.w	r8,r12[0x0]
8000aa64:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000aa68:	c1 50       	breq	8000aa92 <__lo0bits+0x32>
8000aa6a:	ed b8 00 00 	bld	r8,0x0
8000aa6e:	c0 21       	brne	8000aa72 <__lo0bits+0x12>
8000aa70:	5e fd       	retal	0
8000aa72:	10 9b       	mov	r11,r8
8000aa74:	f0 0a 16 01 	lsr	r10,r8,0x1
8000aa78:	e2 1b 00 02 	andl	r11,0x2,COH
8000aa7c:	a3 88       	lsr	r8,0x2
8000aa7e:	58 0b       	cp.w	r11,0
8000aa80:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000aa84:	f9 bc 01 01 	movne	r12,1
8000aa88:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000aa8c:	f9 bc 00 02 	moveq	r12,2
8000aa90:	5e fc       	retal	r12
8000aa92:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000aa96:	f0 0b 16 10 	lsr	r11,r8,0x10
8000aa9a:	58 0a       	cp.w	r10,0
8000aa9c:	f6 08 17 00 	moveq	r8,r11
8000aaa0:	f9 bc 00 10 	moveq	r12,16
8000aaa4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000aaa8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000aaac:	58 0b       	cp.w	r11,0
8000aaae:	f7 bc 00 f8 	subeq	r12,-8
8000aab2:	f4 08 17 00 	moveq	r8,r10
8000aab6:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000aaba:	f0 0a 16 04 	lsr	r10,r8,0x4
8000aabe:	58 0b       	cp.w	r11,0
8000aac0:	f7 bc 00 fc 	subeq	r12,-4
8000aac4:	f4 08 17 00 	moveq	r8,r10
8000aac8:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000aacc:	f0 0a 16 02 	lsr	r10,r8,0x2
8000aad0:	58 0b       	cp.w	r11,0
8000aad2:	f7 bc 00 fe 	subeq	r12,-2
8000aad6:	f4 08 17 00 	moveq	r8,r10
8000aada:	ed b8 00 00 	bld	r8,0x0
8000aade:	c0 60       	breq	8000aaea <__lo0bits+0x8a>
8000aae0:	a1 98       	lsr	r8,0x1
8000aae2:	c0 31       	brne	8000aae8 <__lo0bits+0x88>
8000aae4:	32 0c       	mov	r12,32
8000aae6:	5e fc       	retal	r12
8000aae8:	2f fc       	sub	r12,-1
8000aaea:	93 08       	st.w	r9[0x0],r8
8000aaec:	5e fc       	retal	r12

8000aaee <__mcmp>:
8000aaee:	d4 01       	pushm	lr
8000aaf0:	18 98       	mov	r8,r12
8000aaf2:	76 49       	ld.w	r9,r11[0x10]
8000aaf4:	78 4c       	ld.w	r12,r12[0x10]
8000aaf6:	12 1c       	sub	r12,r9
8000aaf8:	c1 31       	brne	8000ab1e <__mcmp+0x30>
8000aafa:	2f b9       	sub	r9,-5
8000aafc:	a3 69       	lsl	r9,0x2
8000aafe:	12 0b       	add	r11,r9
8000ab00:	f0 09 00 09 	add	r9,r8,r9
8000ab04:	2e c8       	sub	r8,-20
8000ab06:	13 4e       	ld.w	lr,--r9
8000ab08:	17 4a       	ld.w	r10,--r11
8000ab0a:	14 3e       	cp.w	lr,r10
8000ab0c:	c0 60       	breq	8000ab18 <__mcmp+0x2a>
8000ab0e:	f9 bc 03 ff 	movlo	r12,-1
8000ab12:	f9 bc 02 01 	movhs	r12,1
8000ab16:	d8 02       	popm	pc
8000ab18:	10 39       	cp.w	r9,r8
8000ab1a:	fe 9b ff f6 	brhi	8000ab06 <__mcmp+0x18>
8000ab1e:	d8 02       	popm	pc

8000ab20 <_Bfree>:
8000ab20:	d4 21       	pushm	r4-r7,lr
8000ab22:	18 97       	mov	r7,r12
8000ab24:	16 95       	mov	r5,r11
8000ab26:	78 96       	ld.w	r6,r12[0x24]
8000ab28:	58 06       	cp.w	r6,0
8000ab2a:	c0 91       	brne	8000ab3c <_Bfree+0x1c>
8000ab2c:	31 0c       	mov	r12,16
8000ab2e:	fe b0 de 3d 	rcall	800067a8 <malloc>
8000ab32:	99 36       	st.w	r12[0xc],r6
8000ab34:	8f 9c       	st.w	r7[0x24],r12
8000ab36:	99 16       	st.w	r12[0x4],r6
8000ab38:	99 26       	st.w	r12[0x8],r6
8000ab3a:	99 06       	st.w	r12[0x0],r6
8000ab3c:	58 05       	cp.w	r5,0
8000ab3e:	c0 90       	breq	8000ab50 <_Bfree+0x30>
8000ab40:	6a 19       	ld.w	r9,r5[0x4]
8000ab42:	6e 98       	ld.w	r8,r7[0x24]
8000ab44:	70 38       	ld.w	r8,r8[0xc]
8000ab46:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000ab4a:	8b 0a       	st.w	r5[0x0],r10
8000ab4c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000ab50:	d8 22       	popm	r4-r7,pc
8000ab52:	d7 03       	nop

8000ab54 <_Balloc>:
8000ab54:	d4 21       	pushm	r4-r7,lr
8000ab56:	18 97       	mov	r7,r12
8000ab58:	16 96       	mov	r6,r11
8000ab5a:	78 95       	ld.w	r5,r12[0x24]
8000ab5c:	58 05       	cp.w	r5,0
8000ab5e:	c0 91       	brne	8000ab70 <_Balloc+0x1c>
8000ab60:	31 0c       	mov	r12,16
8000ab62:	fe b0 de 23 	rcall	800067a8 <malloc>
8000ab66:	99 35       	st.w	r12[0xc],r5
8000ab68:	8f 9c       	st.w	r7[0x24],r12
8000ab6a:	99 15       	st.w	r12[0x4],r5
8000ab6c:	99 25       	st.w	r12[0x8],r5
8000ab6e:	99 05       	st.w	r12[0x0],r5
8000ab70:	6e 95       	ld.w	r5,r7[0x24]
8000ab72:	6a 38       	ld.w	r8,r5[0xc]
8000ab74:	58 08       	cp.w	r8,0
8000ab76:	c0 b1       	brne	8000ab8c <_Balloc+0x38>
8000ab78:	31 0a       	mov	r10,16
8000ab7a:	30 4b       	mov	r11,4
8000ab7c:	0e 9c       	mov	r12,r7
8000ab7e:	e0 a0 02 9b 	rcall	8000b0b4 <_calloc_r>
8000ab82:	8b 3c       	st.w	r5[0xc],r12
8000ab84:	6e 98       	ld.w	r8,r7[0x24]
8000ab86:	70 3c       	ld.w	r12,r8[0xc]
8000ab88:	58 0c       	cp.w	r12,0
8000ab8a:	c1 b0       	breq	8000abc0 <_Balloc+0x6c>
8000ab8c:	6e 98       	ld.w	r8,r7[0x24]
8000ab8e:	70 38       	ld.w	r8,r8[0xc]
8000ab90:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000ab94:	70 0c       	ld.w	r12,r8[0x0]
8000ab96:	58 0c       	cp.w	r12,0
8000ab98:	c0 40       	breq	8000aba0 <_Balloc+0x4c>
8000ab9a:	78 09       	ld.w	r9,r12[0x0]
8000ab9c:	91 09       	st.w	r8[0x0],r9
8000ab9e:	c0 e8       	rjmp	8000abba <_Balloc+0x66>
8000aba0:	0e 9c       	mov	r12,r7
8000aba2:	30 17       	mov	r7,1
8000aba4:	0e 9b       	mov	r11,r7
8000aba6:	ee 06 09 47 	lsl	r7,r7,r6
8000abaa:	ee ca ff fb 	sub	r10,r7,-5
8000abae:	a3 6a       	lsl	r10,0x2
8000abb0:	e0 a0 02 82 	rcall	8000b0b4 <_calloc_r>
8000abb4:	c0 60       	breq	8000abc0 <_Balloc+0x6c>
8000abb6:	99 16       	st.w	r12[0x4],r6
8000abb8:	99 27       	st.w	r12[0x8],r7
8000abba:	30 08       	mov	r8,0
8000abbc:	99 38       	st.w	r12[0xc],r8
8000abbe:	99 48       	st.w	r12[0x10],r8
8000abc0:	d8 22       	popm	r4-r7,pc
8000abc2:	d7 03       	nop

8000abc4 <__d2b>:
8000abc4:	d4 31       	pushm	r0-r7,lr
8000abc6:	20 2d       	sub	sp,8
8000abc8:	16 93       	mov	r3,r11
8000abca:	12 96       	mov	r6,r9
8000abcc:	10 95       	mov	r5,r8
8000abce:	14 92       	mov	r2,r10
8000abd0:	30 1b       	mov	r11,1
8000abd2:	cc 1f       	rcall	8000ab54 <_Balloc>
8000abd4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000abd8:	50 09       	stdsp	sp[0x0],r9
8000abda:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000abde:	b5 a9       	sbr	r9,0x14
8000abe0:	f0 01 16 14 	lsr	r1,r8,0x14
8000abe4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000abe8:	18 94       	mov	r4,r12
8000abea:	58 02       	cp.w	r2,0
8000abec:	c1 d0       	breq	8000ac26 <__d2b+0x62>
8000abee:	fa cc ff f8 	sub	r12,sp,-8
8000abf2:	18 d2       	st.w	--r12,r2
8000abf4:	c3 6f       	rcall	8000aa60 <__lo0bits>
8000abf6:	40 18       	lddsp	r8,sp[0x4]
8000abf8:	c0 d0       	breq	8000ac12 <__d2b+0x4e>
8000abfa:	40 09       	lddsp	r9,sp[0x0]
8000abfc:	f8 0a 11 20 	rsub	r10,r12,32
8000ac00:	f2 0a 09 4a 	lsl	r10,r9,r10
8000ac04:	f5 e8 10 08 	or	r8,r10,r8
8000ac08:	89 58       	st.w	r4[0x14],r8
8000ac0a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000ac0e:	50 09       	stdsp	sp[0x0],r9
8000ac10:	c0 28       	rjmp	8000ac14 <__d2b+0x50>
8000ac12:	89 58       	st.w	r4[0x14],r8
8000ac14:	40 08       	lddsp	r8,sp[0x0]
8000ac16:	58 08       	cp.w	r8,0
8000ac18:	f9 b3 01 02 	movne	r3,2
8000ac1c:	f9 b3 00 01 	moveq	r3,1
8000ac20:	89 68       	st.w	r4[0x18],r8
8000ac22:	89 43       	st.w	r4[0x10],r3
8000ac24:	c0 88       	rjmp	8000ac34 <__d2b+0x70>
8000ac26:	1a 9c       	mov	r12,sp
8000ac28:	c1 cf       	rcall	8000aa60 <__lo0bits>
8000ac2a:	30 13       	mov	r3,1
8000ac2c:	40 08       	lddsp	r8,sp[0x0]
8000ac2e:	2e 0c       	sub	r12,-32
8000ac30:	89 43       	st.w	r4[0x10],r3
8000ac32:	89 58       	st.w	r4[0x14],r8
8000ac34:	58 01       	cp.w	r1,0
8000ac36:	c0 90       	breq	8000ac48 <__d2b+0x84>
8000ac38:	e2 c1 04 33 	sub	r1,r1,1075
8000ac3c:	18 01       	add	r1,r12
8000ac3e:	8d 01       	st.w	r6[0x0],r1
8000ac40:	f8 0c 11 35 	rsub	r12,r12,53
8000ac44:	8b 0c       	st.w	r5[0x0],r12
8000ac46:	c0 c8       	rjmp	8000ac5e <__d2b+0x9a>
8000ac48:	e6 c8 ff fc 	sub	r8,r3,-4
8000ac4c:	f8 cc 04 32 	sub	r12,r12,1074
8000ac50:	a5 73       	lsl	r3,0x5
8000ac52:	8d 0c       	st.w	r6[0x0],r12
8000ac54:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000ac58:	cd 4e       	rcall	8000aa00 <__hi0bits>
8000ac5a:	18 13       	sub	r3,r12
8000ac5c:	8b 03       	st.w	r5[0x0],r3
8000ac5e:	08 9c       	mov	r12,r4
8000ac60:	2f ed       	sub	sp,-8
8000ac62:	d8 32       	popm	r0-r7,pc

8000ac64 <__mdiff>:
8000ac64:	d4 31       	pushm	r0-r7,lr
8000ac66:	74 48       	ld.w	r8,r10[0x10]
8000ac68:	76 45       	ld.w	r5,r11[0x10]
8000ac6a:	16 97       	mov	r7,r11
8000ac6c:	14 96       	mov	r6,r10
8000ac6e:	10 15       	sub	r5,r8
8000ac70:	c1 31       	brne	8000ac96 <__mdiff+0x32>
8000ac72:	2f b8       	sub	r8,-5
8000ac74:	ee ce ff ec 	sub	lr,r7,-20
8000ac78:	a3 68       	lsl	r8,0x2
8000ac7a:	f4 08 00 0b 	add	r11,r10,r8
8000ac7e:	ee 08 00 08 	add	r8,r7,r8
8000ac82:	11 4a       	ld.w	r10,--r8
8000ac84:	17 49       	ld.w	r9,--r11
8000ac86:	12 3a       	cp.w	r10,r9
8000ac88:	c0 30       	breq	8000ac8e <__mdiff+0x2a>
8000ac8a:	c0 e2       	brcc	8000aca6 <__mdiff+0x42>
8000ac8c:	c0 78       	rjmp	8000ac9a <__mdiff+0x36>
8000ac8e:	1c 38       	cp.w	r8,lr
8000ac90:	fe 9b ff f9 	brhi	8000ac82 <__mdiff+0x1e>
8000ac94:	c4 98       	rjmp	8000ad26 <__mdiff+0xc2>
8000ac96:	58 05       	cp.w	r5,0
8000ac98:	c0 64       	brge	8000aca4 <__mdiff+0x40>
8000ac9a:	0e 98       	mov	r8,r7
8000ac9c:	30 15       	mov	r5,1
8000ac9e:	0c 97       	mov	r7,r6
8000aca0:	10 96       	mov	r6,r8
8000aca2:	c0 28       	rjmp	8000aca6 <__mdiff+0x42>
8000aca4:	30 05       	mov	r5,0
8000aca6:	6e 1b       	ld.w	r11,r7[0x4]
8000aca8:	c5 6f       	rcall	8000ab54 <_Balloc>
8000acaa:	6e 49       	ld.w	r9,r7[0x10]
8000acac:	6c 44       	ld.w	r4,r6[0x10]
8000acae:	99 35       	st.w	r12[0xc],r5
8000acb0:	2f b4       	sub	r4,-5
8000acb2:	f2 c5 ff fb 	sub	r5,r9,-5
8000acb6:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000acba:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000acbe:	2e c6       	sub	r6,-20
8000acc0:	2e c7       	sub	r7,-20
8000acc2:	f8 c8 ff ec 	sub	r8,r12,-20
8000acc6:	30 0a       	mov	r10,0
8000acc8:	0f 0e       	ld.w	lr,r7++
8000acca:	0d 0b       	ld.w	r11,r6++
8000accc:	fc 02 16 10 	lsr	r2,lr,0x10
8000acd0:	f6 03 16 10 	lsr	r3,r11,0x10
8000acd4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000acd8:	e4 03 01 03 	sub	r3,r2,r3
8000acdc:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ace0:	fc 0b 01 0b 	sub	r11,lr,r11
8000ace4:	f6 0a 00 0a 	add	r10,r11,r10
8000ace8:	b0 1a       	st.h	r8[0x2],r10
8000acea:	b1 4a       	asr	r10,0x10
8000acec:	e6 0a 00 0a 	add	r10,r3,r10
8000acf0:	b0 0a       	st.h	r8[0x0],r10
8000acf2:	2f c8       	sub	r8,-4
8000acf4:	b1 4a       	asr	r10,0x10
8000acf6:	08 36       	cp.w	r6,r4
8000acf8:	ce 83       	brcs	8000acc8 <__mdiff+0x64>
8000acfa:	c0 d8       	rjmp	8000ad14 <__mdiff+0xb0>
8000acfc:	0f 0b       	ld.w	r11,r7++
8000acfe:	f6 0e 16 10 	lsr	lr,r11,0x10
8000ad02:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ad06:	16 0a       	add	r10,r11
8000ad08:	b0 1a       	st.h	r8[0x2],r10
8000ad0a:	b1 4a       	asr	r10,0x10
8000ad0c:	1c 0a       	add	r10,lr
8000ad0e:	b0 0a       	st.h	r8[0x0],r10
8000ad10:	2f c8       	sub	r8,-4
8000ad12:	b1 4a       	asr	r10,0x10
8000ad14:	0a 37       	cp.w	r7,r5
8000ad16:	cf 33       	brcs	8000acfc <__mdiff+0x98>
8000ad18:	c0 28       	rjmp	8000ad1c <__mdiff+0xb8>
8000ad1a:	20 19       	sub	r9,1
8000ad1c:	11 4a       	ld.w	r10,--r8
8000ad1e:	58 0a       	cp.w	r10,0
8000ad20:	cf d0       	breq	8000ad1a <__mdiff+0xb6>
8000ad22:	99 49       	st.w	r12[0x10],r9
8000ad24:	d8 32       	popm	r0-r7,pc
8000ad26:	30 0b       	mov	r11,0
8000ad28:	c1 6f       	rcall	8000ab54 <_Balloc>
8000ad2a:	30 18       	mov	r8,1
8000ad2c:	99 48       	st.w	r12[0x10],r8
8000ad2e:	30 08       	mov	r8,0
8000ad30:	99 58       	st.w	r12[0x14],r8
8000ad32:	d8 32       	popm	r0-r7,pc

8000ad34 <__lshift>:
8000ad34:	d4 31       	pushm	r0-r7,lr
8000ad36:	16 97       	mov	r7,r11
8000ad38:	76 46       	ld.w	r6,r11[0x10]
8000ad3a:	f4 02 14 05 	asr	r2,r10,0x5
8000ad3e:	2f f6       	sub	r6,-1
8000ad40:	14 93       	mov	r3,r10
8000ad42:	18 94       	mov	r4,r12
8000ad44:	04 06       	add	r6,r2
8000ad46:	76 1b       	ld.w	r11,r11[0x4]
8000ad48:	6e 28       	ld.w	r8,r7[0x8]
8000ad4a:	c0 38       	rjmp	8000ad50 <__lshift+0x1c>
8000ad4c:	2f fb       	sub	r11,-1
8000ad4e:	a1 78       	lsl	r8,0x1
8000ad50:	10 36       	cp.w	r6,r8
8000ad52:	fe 99 ff fd 	brgt	8000ad4c <__lshift+0x18>
8000ad56:	08 9c       	mov	r12,r4
8000ad58:	cf ee       	rcall	8000ab54 <_Balloc>
8000ad5a:	30 09       	mov	r9,0
8000ad5c:	18 95       	mov	r5,r12
8000ad5e:	f8 c8 ff ec 	sub	r8,r12,-20
8000ad62:	12 9a       	mov	r10,r9
8000ad64:	c0 38       	rjmp	8000ad6a <__lshift+0x36>
8000ad66:	10 aa       	st.w	r8++,r10
8000ad68:	2f f9       	sub	r9,-1
8000ad6a:	04 39       	cp.w	r9,r2
8000ad6c:	cf d5       	brlt	8000ad66 <__lshift+0x32>
8000ad6e:	6e 4b       	ld.w	r11,r7[0x10]
8000ad70:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000ad74:	2f bb       	sub	r11,-5
8000ad76:	ee c9 ff ec 	sub	r9,r7,-20
8000ad7a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000ad7e:	58 03       	cp.w	r3,0
8000ad80:	c1 30       	breq	8000ada6 <__lshift+0x72>
8000ad82:	e6 0c 11 20 	rsub	r12,r3,32
8000ad86:	30 0a       	mov	r10,0
8000ad88:	72 02       	ld.w	r2,r9[0x0]
8000ad8a:	e4 03 09 42 	lsl	r2,r2,r3
8000ad8e:	04 4a       	or	r10,r2
8000ad90:	10 aa       	st.w	r8++,r10
8000ad92:	13 0a       	ld.w	r10,r9++
8000ad94:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ad98:	16 39       	cp.w	r9,r11
8000ad9a:	cf 73       	brcs	8000ad88 <__lshift+0x54>
8000ad9c:	91 0a       	st.w	r8[0x0],r10
8000ad9e:	58 0a       	cp.w	r10,0
8000ada0:	c0 70       	breq	8000adae <__lshift+0x7a>
8000ada2:	2f f6       	sub	r6,-1
8000ada4:	c0 58       	rjmp	8000adae <__lshift+0x7a>
8000ada6:	13 0a       	ld.w	r10,r9++
8000ada8:	10 aa       	st.w	r8++,r10
8000adaa:	16 39       	cp.w	r9,r11
8000adac:	cf d3       	brcs	8000ada6 <__lshift+0x72>
8000adae:	08 9c       	mov	r12,r4
8000adb0:	20 16       	sub	r6,1
8000adb2:	0e 9b       	mov	r11,r7
8000adb4:	8b 46       	st.w	r5[0x10],r6
8000adb6:	cb 5e       	rcall	8000ab20 <_Bfree>
8000adb8:	0a 9c       	mov	r12,r5
8000adba:	d8 32       	popm	r0-r7,pc

8000adbc <__multiply>:
8000adbc:	d4 31       	pushm	r0-r7,lr
8000adbe:	20 2d       	sub	sp,8
8000adc0:	76 49       	ld.w	r9,r11[0x10]
8000adc2:	74 48       	ld.w	r8,r10[0x10]
8000adc4:	16 96       	mov	r6,r11
8000adc6:	14 95       	mov	r5,r10
8000adc8:	10 39       	cp.w	r9,r8
8000adca:	ec 08 17 50 	movlt	r8,r6
8000adce:	ea 06 17 50 	movlt	r6,r5
8000add2:	f0 05 17 50 	movlt	r5,r8
8000add6:	6c 28       	ld.w	r8,r6[0x8]
8000add8:	76 43       	ld.w	r3,r11[0x10]
8000adda:	74 42       	ld.w	r2,r10[0x10]
8000addc:	76 1b       	ld.w	r11,r11[0x4]
8000adde:	e4 03 00 07 	add	r7,r2,r3
8000ade2:	10 37       	cp.w	r7,r8
8000ade4:	f7 bb 09 ff 	subgt	r11,-1
8000ade8:	cb 6e       	rcall	8000ab54 <_Balloc>
8000adea:	ee c4 ff fb 	sub	r4,r7,-5
8000adee:	f8 c9 ff ec 	sub	r9,r12,-20
8000adf2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000adf6:	30 0a       	mov	r10,0
8000adf8:	12 98       	mov	r8,r9
8000adfa:	c0 28       	rjmp	8000adfe <__multiply+0x42>
8000adfc:	10 aa       	st.w	r8++,r10
8000adfe:	08 38       	cp.w	r8,r4
8000ae00:	cf e3       	brcs	8000adfc <__multiply+0x40>
8000ae02:	2f b3       	sub	r3,-5
8000ae04:	2f b2       	sub	r2,-5
8000ae06:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000ae0a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000ae0e:	ec cb ff ec 	sub	r11,r6,-20
8000ae12:	50 12       	stdsp	sp[0x4],r2
8000ae14:	ea ca ff ec 	sub	r10,r5,-20
8000ae18:	c4 48       	rjmp	8000aea0 <__multiply+0xe4>
8000ae1a:	94 95       	ld.uh	r5,r10[0x2]
8000ae1c:	58 05       	cp.w	r5,0
8000ae1e:	c2 00       	breq	8000ae5e <__multiply+0xa2>
8000ae20:	12 98       	mov	r8,r9
8000ae22:	16 96       	mov	r6,r11
8000ae24:	30 0e       	mov	lr,0
8000ae26:	50 09       	stdsp	sp[0x0],r9
8000ae28:	0d 02       	ld.w	r2,r6++
8000ae2a:	e4 00 16 10 	lsr	r0,r2,0x10
8000ae2e:	70 01       	ld.w	r1,r8[0x0]
8000ae30:	70 09       	ld.w	r9,r8[0x0]
8000ae32:	b1 81       	lsr	r1,0x10
8000ae34:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000ae38:	e0 05 03 41 	mac	r1,r0,r5
8000ae3c:	ab 32       	mul	r2,r5
8000ae3e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000ae42:	00 02       	add	r2,r0
8000ae44:	e4 0e 00 0e 	add	lr,r2,lr
8000ae48:	b0 1e       	st.h	r8[0x2],lr
8000ae4a:	b1 8e       	lsr	lr,0x10
8000ae4c:	1c 01       	add	r1,lr
8000ae4e:	b0 01       	st.h	r8[0x0],r1
8000ae50:	e2 0e 16 10 	lsr	lr,r1,0x10
8000ae54:	2f c8       	sub	r8,-4
8000ae56:	06 36       	cp.w	r6,r3
8000ae58:	ce 83       	brcs	8000ae28 <__multiply+0x6c>
8000ae5a:	40 09       	lddsp	r9,sp[0x0]
8000ae5c:	91 0e       	st.w	r8[0x0],lr
8000ae5e:	94 86       	ld.uh	r6,r10[0x0]
8000ae60:	58 06       	cp.w	r6,0
8000ae62:	c1 d0       	breq	8000ae9c <__multiply+0xe0>
8000ae64:	72 02       	ld.w	r2,r9[0x0]
8000ae66:	12 98       	mov	r8,r9
8000ae68:	16 9e       	mov	lr,r11
8000ae6a:	30 05       	mov	r5,0
8000ae6c:	b0 12       	st.h	r8[0x2],r2
8000ae6e:	1d 01       	ld.w	r1,lr++
8000ae70:	90 82       	ld.uh	r2,r8[0x0]
8000ae72:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000ae76:	ad 30       	mul	r0,r6
8000ae78:	e0 02 00 02 	add	r2,r0,r2
8000ae7c:	e4 05 00 05 	add	r5,r2,r5
8000ae80:	b0 05       	st.h	r8[0x0],r5
8000ae82:	b1 85       	lsr	r5,0x10
8000ae84:	b1 81       	lsr	r1,0x10
8000ae86:	2f c8       	sub	r8,-4
8000ae88:	ad 31       	mul	r1,r6
8000ae8a:	90 92       	ld.uh	r2,r8[0x2]
8000ae8c:	e2 02 00 02 	add	r2,r1,r2
8000ae90:	0a 02       	add	r2,r5
8000ae92:	e4 05 16 10 	lsr	r5,r2,0x10
8000ae96:	06 3e       	cp.w	lr,r3
8000ae98:	ce a3       	brcs	8000ae6c <__multiply+0xb0>
8000ae9a:	91 02       	st.w	r8[0x0],r2
8000ae9c:	2f ca       	sub	r10,-4
8000ae9e:	2f c9       	sub	r9,-4
8000aea0:	40 18       	lddsp	r8,sp[0x4]
8000aea2:	10 3a       	cp.w	r10,r8
8000aea4:	cb b3       	brcs	8000ae1a <__multiply+0x5e>
8000aea6:	c0 28       	rjmp	8000aeaa <__multiply+0xee>
8000aea8:	20 17       	sub	r7,1
8000aeaa:	58 07       	cp.w	r7,0
8000aeac:	e0 8a 00 05 	brle	8000aeb6 <__multiply+0xfa>
8000aeb0:	09 48       	ld.w	r8,--r4
8000aeb2:	58 08       	cp.w	r8,0
8000aeb4:	cf a0       	breq	8000aea8 <__multiply+0xec>
8000aeb6:	99 47       	st.w	r12[0x10],r7
8000aeb8:	2f ed       	sub	sp,-8
8000aeba:	d8 32       	popm	r0-r7,pc

8000aebc <__i2b>:
8000aebc:	d4 21       	pushm	r4-r7,lr
8000aebe:	16 97       	mov	r7,r11
8000aec0:	30 1b       	mov	r11,1
8000aec2:	c4 9e       	rcall	8000ab54 <_Balloc>
8000aec4:	30 19       	mov	r9,1
8000aec6:	99 57       	st.w	r12[0x14],r7
8000aec8:	99 49       	st.w	r12[0x10],r9
8000aeca:	d8 22       	popm	r4-r7,pc

8000aecc <__multadd>:
8000aecc:	d4 31       	pushm	r0-r7,lr
8000aece:	30 08       	mov	r8,0
8000aed0:	12 95       	mov	r5,r9
8000aed2:	16 97       	mov	r7,r11
8000aed4:	18 96       	mov	r6,r12
8000aed6:	76 44       	ld.w	r4,r11[0x10]
8000aed8:	f6 c9 ff ec 	sub	r9,r11,-20
8000aedc:	72 0b       	ld.w	r11,r9[0x0]
8000aede:	f6 0c 16 10 	lsr	r12,r11,0x10
8000aee2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aee6:	f4 0c 02 4c 	mul	r12,r10,r12
8000aeea:	f4 0b 03 45 	mac	r5,r10,r11
8000aeee:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000aef2:	b1 85       	lsr	r5,0x10
8000aef4:	18 05       	add	r5,r12
8000aef6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000aefa:	f8 0b 00 0b 	add	r11,r12,r11
8000aefe:	12 ab       	st.w	r9++,r11
8000af00:	2f f8       	sub	r8,-1
8000af02:	b1 85       	lsr	r5,0x10
8000af04:	08 38       	cp.w	r8,r4
8000af06:	ce b5       	brlt	8000aedc <__multadd+0x10>
8000af08:	58 05       	cp.w	r5,0
8000af0a:	c1 c0       	breq	8000af42 <__multadd+0x76>
8000af0c:	6e 28       	ld.w	r8,r7[0x8]
8000af0e:	10 34       	cp.w	r4,r8
8000af10:	c1 35       	brlt	8000af36 <__multadd+0x6a>
8000af12:	6e 1b       	ld.w	r11,r7[0x4]
8000af14:	0c 9c       	mov	r12,r6
8000af16:	2f fb       	sub	r11,-1
8000af18:	c1 ee       	rcall	8000ab54 <_Balloc>
8000af1a:	6e 4a       	ld.w	r10,r7[0x10]
8000af1c:	ee cb ff f4 	sub	r11,r7,-12
8000af20:	18 93       	mov	r3,r12
8000af22:	2f ea       	sub	r10,-2
8000af24:	2f 4c       	sub	r12,-12
8000af26:	a3 6a       	lsl	r10,0x2
8000af28:	fe b0 de 64 	rcall	80006bf0 <memcpy>
8000af2c:	0e 9b       	mov	r11,r7
8000af2e:	0c 9c       	mov	r12,r6
8000af30:	fe b0 fd f8 	rcall	8000ab20 <_Bfree>
8000af34:	06 97       	mov	r7,r3
8000af36:	e8 c8 ff ff 	sub	r8,r4,-1
8000af3a:	2f b4       	sub	r4,-5
8000af3c:	8f 48       	st.w	r7[0x10],r8
8000af3e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000af42:	0e 9c       	mov	r12,r7
8000af44:	d8 32       	popm	r0-r7,pc
8000af46:	d7 03       	nop

8000af48 <__pow5mult>:
8000af48:	d4 31       	pushm	r0-r7,lr
8000af4a:	14 96       	mov	r6,r10
8000af4c:	18 97       	mov	r7,r12
8000af4e:	16 94       	mov	r4,r11
8000af50:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000af54:	c0 90       	breq	8000af66 <__pow5mult+0x1e>
8000af56:	20 18       	sub	r8,1
8000af58:	fe c9 db 04 	sub	r9,pc,-9468
8000af5c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000af60:	30 09       	mov	r9,0
8000af62:	cb 5f       	rcall	8000aecc <__multadd>
8000af64:	18 94       	mov	r4,r12
8000af66:	a3 46       	asr	r6,0x2
8000af68:	c3 40       	breq	8000afd0 <__pow5mult+0x88>
8000af6a:	6e 95       	ld.w	r5,r7[0x24]
8000af6c:	58 05       	cp.w	r5,0
8000af6e:	c0 91       	brne	8000af80 <__pow5mult+0x38>
8000af70:	31 0c       	mov	r12,16
8000af72:	fe b0 dc 1b 	rcall	800067a8 <malloc>
8000af76:	99 35       	st.w	r12[0xc],r5
8000af78:	8f 9c       	st.w	r7[0x24],r12
8000af7a:	99 15       	st.w	r12[0x4],r5
8000af7c:	99 25       	st.w	r12[0x8],r5
8000af7e:	99 05       	st.w	r12[0x0],r5
8000af80:	6e 93       	ld.w	r3,r7[0x24]
8000af82:	66 25       	ld.w	r5,r3[0x8]
8000af84:	58 05       	cp.w	r5,0
8000af86:	c0 c1       	brne	8000af9e <__pow5mult+0x56>
8000af88:	e0 6b 02 71 	mov	r11,625
8000af8c:	0e 9c       	mov	r12,r7
8000af8e:	c9 7f       	rcall	8000aebc <__i2b>
8000af90:	87 2c       	st.w	r3[0x8],r12
8000af92:	30 08       	mov	r8,0
8000af94:	18 95       	mov	r5,r12
8000af96:	99 08       	st.w	r12[0x0],r8
8000af98:	c0 38       	rjmp	8000af9e <__pow5mult+0x56>
8000af9a:	06 9c       	mov	r12,r3
8000af9c:	18 95       	mov	r5,r12
8000af9e:	ed b6 00 00 	bld	r6,0x0
8000afa2:	c0 b1       	brne	8000afb8 <__pow5mult+0x70>
8000afa4:	08 9b       	mov	r11,r4
8000afa6:	0a 9a       	mov	r10,r5
8000afa8:	0e 9c       	mov	r12,r7
8000afaa:	c0 9f       	rcall	8000adbc <__multiply>
8000afac:	08 9b       	mov	r11,r4
8000afae:	18 93       	mov	r3,r12
8000afb0:	0e 9c       	mov	r12,r7
8000afb2:	06 94       	mov	r4,r3
8000afb4:	fe b0 fd b6 	rcall	8000ab20 <_Bfree>
8000afb8:	a1 56       	asr	r6,0x1
8000afba:	c0 b0       	breq	8000afd0 <__pow5mult+0x88>
8000afbc:	6a 03       	ld.w	r3,r5[0x0]
8000afbe:	58 03       	cp.w	r3,0
8000afc0:	ce d1       	brne	8000af9a <__pow5mult+0x52>
8000afc2:	0a 9a       	mov	r10,r5
8000afc4:	0a 9b       	mov	r11,r5
8000afc6:	0e 9c       	mov	r12,r7
8000afc8:	cf ae       	rcall	8000adbc <__multiply>
8000afca:	8b 0c       	st.w	r5[0x0],r12
8000afcc:	99 03       	st.w	r12[0x0],r3
8000afce:	ce 7b       	rjmp	8000af9c <__pow5mult+0x54>
8000afd0:	08 9c       	mov	r12,r4
8000afd2:	d8 32       	popm	r0-r7,pc

8000afd4 <__isinfd>:
8000afd4:	14 98       	mov	r8,r10
8000afd6:	fc 19 7f f0 	movh	r9,0x7ff0
8000afda:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000afde:	f0 0b 11 00 	rsub	r11,r8,0
8000afe2:	f7 e8 10 08 	or	r8,r11,r8
8000afe6:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000afea:	f2 08 01 08 	sub	r8,r9,r8
8000afee:	f0 0c 11 00 	rsub	r12,r8,0
8000aff2:	f9 e8 10 08 	or	r8,r12,r8
8000aff6:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000affa:	2f fc       	sub	r12,-1
8000affc:	5e fc       	retal	r12

8000affe <__isnand>:
8000affe:	14 98       	mov	r8,r10
8000b000:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b004:	f0 0c 11 00 	rsub	r12,r8,0
8000b008:	10 4c       	or	r12,r8
8000b00a:	fc 18 7f f0 	movh	r8,0x7ff0
8000b00e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b012:	f0 0c 01 0c 	sub	r12,r8,r12
8000b016:	bf 9c       	lsr	r12,0x1f
8000b018:	5e fc       	retal	r12
8000b01a:	d7 03       	nop

8000b01c <__sclose>:
8000b01c:	d4 01       	pushm	lr
8000b01e:	96 7b       	ld.sh	r11,r11[0xe]
8000b020:	c7 6c       	rcall	8000b10c <_close_r>
8000b022:	d8 02       	popm	pc

8000b024 <__sseek>:
8000b024:	d4 21       	pushm	r4-r7,lr
8000b026:	16 97       	mov	r7,r11
8000b028:	96 7b       	ld.sh	r11,r11[0xe]
8000b02a:	cf 7c       	rcall	8000b218 <_lseek_r>
8000b02c:	8e 68       	ld.sh	r8,r7[0xc]
8000b02e:	10 99       	mov	r9,r8
8000b030:	ad c8       	cbr	r8,0xc
8000b032:	ad a9       	sbr	r9,0xc
8000b034:	5b fc       	cp.w	r12,-1
8000b036:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b03a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b03e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b042:	d8 22       	popm	r4-r7,pc

8000b044 <__swrite>:
8000b044:	d4 21       	pushm	r4-r7,lr
8000b046:	96 68       	ld.sh	r8,r11[0xc]
8000b048:	16 97       	mov	r7,r11
8000b04a:	14 95       	mov	r5,r10
8000b04c:	12 94       	mov	r4,r9
8000b04e:	e2 18 01 00 	andl	r8,0x100,COH
8000b052:	18 96       	mov	r6,r12
8000b054:	c0 50       	breq	8000b05e <__swrite+0x1a>
8000b056:	30 29       	mov	r9,2
8000b058:	30 0a       	mov	r10,0
8000b05a:	96 7b       	ld.sh	r11,r11[0xe]
8000b05c:	cd ec       	rcall	8000b218 <_lseek_r>
8000b05e:	8e 68       	ld.sh	r8,r7[0xc]
8000b060:	ad c8       	cbr	r8,0xc
8000b062:	08 99       	mov	r9,r4
8000b064:	0a 9a       	mov	r10,r5
8000b066:	8e 7b       	ld.sh	r11,r7[0xe]
8000b068:	0c 9c       	mov	r12,r6
8000b06a:	ae 68       	st.h	r7[0xc],r8
8000b06c:	c1 0c       	rcall	8000b08c <_write_r>
8000b06e:	d8 22       	popm	r4-r7,pc

8000b070 <__sread>:
8000b070:	d4 21       	pushm	r4-r7,lr
8000b072:	16 97       	mov	r7,r11
8000b074:	96 7b       	ld.sh	r11,r11[0xe]
8000b076:	ce 5c       	rcall	8000b240 <_read_r>
8000b078:	c0 65       	brlt	8000b084 <__sread+0x14>
8000b07a:	6f 58       	ld.w	r8,r7[0x54]
8000b07c:	18 08       	add	r8,r12
8000b07e:	ef 48 00 54 	st.w	r7[84],r8
8000b082:	d8 22       	popm	r4-r7,pc
8000b084:	8e 68       	ld.sh	r8,r7[0xc]
8000b086:	ad c8       	cbr	r8,0xc
8000b088:	ae 68       	st.h	r7[0xc],r8
8000b08a:	d8 22       	popm	r4-r7,pc

8000b08c <_write_r>:
8000b08c:	d4 21       	pushm	r4-r7,lr
8000b08e:	16 98       	mov	r8,r11
8000b090:	18 97       	mov	r7,r12
8000b092:	10 9c       	mov	r12,r8
8000b094:	30 08       	mov	r8,0
8000b096:	14 9b       	mov	r11,r10
8000b098:	e0 66 41 14 	mov	r6,16660
8000b09c:	12 9a       	mov	r10,r9
8000b09e:	8d 08       	st.w	r6[0x0],r8
8000b0a0:	fe b0 d1 24 	rcall	800052e8 <_write>
8000b0a4:	5b fc       	cp.w	r12,-1
8000b0a6:	c0 51       	brne	8000b0b0 <_write_r+0x24>
8000b0a8:	6c 08       	ld.w	r8,r6[0x0]
8000b0aa:	58 08       	cp.w	r8,0
8000b0ac:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b0b0:	d8 22       	popm	r4-r7,pc
8000b0b2:	d7 03       	nop

8000b0b4 <_calloc_r>:
8000b0b4:	d4 21       	pushm	r4-r7,lr
8000b0b6:	f4 0b 02 4b 	mul	r11,r10,r11
8000b0ba:	fe b0 db 7f 	rcall	800067b8 <_malloc_r>
8000b0be:	18 97       	mov	r7,r12
8000b0c0:	c2 30       	breq	8000b106 <_calloc_r+0x52>
8000b0c2:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b0c6:	e0 1a ff fc 	andl	r10,0xfffc
8000b0ca:	20 4a       	sub	r10,4
8000b0cc:	e0 4a 00 24 	cp.w	r10,36
8000b0d0:	e0 8b 00 18 	brhi	8000b100 <_calloc_r+0x4c>
8000b0d4:	18 98       	mov	r8,r12
8000b0d6:	59 3a       	cp.w	r10,19
8000b0d8:	e0 88 00 0f 	brls	8000b0f6 <_calloc_r+0x42>
8000b0dc:	30 09       	mov	r9,0
8000b0de:	10 a9       	st.w	r8++,r9
8000b0e0:	10 a9       	st.w	r8++,r9
8000b0e2:	59 ba       	cp.w	r10,27
8000b0e4:	e0 88 00 09 	brls	8000b0f6 <_calloc_r+0x42>
8000b0e8:	10 a9       	st.w	r8++,r9
8000b0ea:	10 a9       	st.w	r8++,r9
8000b0ec:	e0 4a 00 24 	cp.w	r10,36
8000b0f0:	c0 31       	brne	8000b0f6 <_calloc_r+0x42>
8000b0f2:	10 a9       	st.w	r8++,r9
8000b0f4:	10 a9       	st.w	r8++,r9
8000b0f6:	30 09       	mov	r9,0
8000b0f8:	10 a9       	st.w	r8++,r9
8000b0fa:	91 19       	st.w	r8[0x4],r9
8000b0fc:	91 09       	st.w	r8[0x0],r9
8000b0fe:	c0 48       	rjmp	8000b106 <_calloc_r+0x52>
8000b100:	30 0b       	mov	r11,0
8000b102:	fe b0 de 1b 	rcall	80006d38 <memset>
8000b106:	0e 9c       	mov	r12,r7
8000b108:	d8 22       	popm	r4-r7,pc
8000b10a:	d7 03       	nop

8000b10c <_close_r>:
8000b10c:	d4 21       	pushm	r4-r7,lr
8000b10e:	30 08       	mov	r8,0
8000b110:	18 97       	mov	r7,r12
8000b112:	e0 66 41 14 	mov	r6,16660
8000b116:	16 9c       	mov	r12,r11
8000b118:	8d 08       	st.w	r6[0x0],r8
8000b11a:	fe b0 df c1 	rcall	8000709c <_close>
8000b11e:	5b fc       	cp.w	r12,-1
8000b120:	c0 51       	brne	8000b12a <_close_r+0x1e>
8000b122:	6c 08       	ld.w	r8,r6[0x0]
8000b124:	58 08       	cp.w	r8,0
8000b126:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b12a:	d8 22       	popm	r4-r7,pc

8000b12c <_fclose_r>:
8000b12c:	d4 21       	pushm	r4-r7,lr
8000b12e:	18 96       	mov	r6,r12
8000b130:	16 97       	mov	r7,r11
8000b132:	58 0b       	cp.w	r11,0
8000b134:	c0 31       	brne	8000b13a <_fclose_r+0xe>
8000b136:	16 95       	mov	r5,r11
8000b138:	c5 38       	rjmp	8000b1de <_fclose_r+0xb2>
8000b13a:	fe b0 f8 b5 	rcall	8000a2a4 <__sfp_lock_acquire>
8000b13e:	58 06       	cp.w	r6,0
8000b140:	c0 70       	breq	8000b14e <_fclose_r+0x22>
8000b142:	6c 68       	ld.w	r8,r6[0x18]
8000b144:	58 08       	cp.w	r8,0
8000b146:	c0 41       	brne	8000b14e <_fclose_r+0x22>
8000b148:	0c 9c       	mov	r12,r6
8000b14a:	fe b0 f8 ff 	rcall	8000a348 <__sinit>
8000b14e:	fe c8 dd 9e 	sub	r8,pc,-8802
8000b152:	10 37       	cp.w	r7,r8
8000b154:	c0 31       	brne	8000b15a <_fclose_r+0x2e>
8000b156:	6c 07       	ld.w	r7,r6[0x0]
8000b158:	c0 c8       	rjmp	8000b170 <_fclose_r+0x44>
8000b15a:	fe c8 dd 8a 	sub	r8,pc,-8822
8000b15e:	10 37       	cp.w	r7,r8
8000b160:	c0 31       	brne	8000b166 <_fclose_r+0x3a>
8000b162:	6c 17       	ld.w	r7,r6[0x4]
8000b164:	c0 68       	rjmp	8000b170 <_fclose_r+0x44>
8000b166:	fe c8 dd 76 	sub	r8,pc,-8842
8000b16a:	10 37       	cp.w	r7,r8
8000b16c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b170:	8e 69       	ld.sh	r9,r7[0xc]
8000b172:	30 08       	mov	r8,0
8000b174:	f0 09 19 00 	cp.h	r9,r8
8000b178:	c0 51       	brne	8000b182 <_fclose_r+0x56>
8000b17a:	fe b0 f8 96 	rcall	8000a2a6 <__sfp_lock_release>
8000b17e:	30 05       	mov	r5,0
8000b180:	c2 f8       	rjmp	8000b1de <_fclose_r+0xb2>
8000b182:	0e 9b       	mov	r11,r7
8000b184:	0c 9c       	mov	r12,r6
8000b186:	fe b0 f8 09 	rcall	8000a198 <_fflush_r>
8000b18a:	6e c8       	ld.w	r8,r7[0x30]
8000b18c:	18 95       	mov	r5,r12
8000b18e:	58 08       	cp.w	r8,0
8000b190:	c0 60       	breq	8000b19c <_fclose_r+0x70>
8000b192:	6e 8b       	ld.w	r11,r7[0x20]
8000b194:	0c 9c       	mov	r12,r6
8000b196:	5d 18       	icall	r8
8000b198:	f9 b5 05 ff 	movlt	r5,-1
8000b19c:	8e 68       	ld.sh	r8,r7[0xc]
8000b19e:	ed b8 00 07 	bld	r8,0x7
8000b1a2:	c0 51       	brne	8000b1ac <_fclose_r+0x80>
8000b1a4:	6e 4b       	ld.w	r11,r7[0x10]
8000b1a6:	0c 9c       	mov	r12,r6
8000b1a8:	fe b0 f9 6a 	rcall	8000a47c <_free_r>
8000b1ac:	6e db       	ld.w	r11,r7[0x34]
8000b1ae:	58 0b       	cp.w	r11,0
8000b1b0:	c0 a0       	breq	8000b1c4 <_fclose_r+0x98>
8000b1b2:	ee c8 ff bc 	sub	r8,r7,-68
8000b1b6:	10 3b       	cp.w	r11,r8
8000b1b8:	c0 40       	breq	8000b1c0 <_fclose_r+0x94>
8000b1ba:	0c 9c       	mov	r12,r6
8000b1bc:	fe b0 f9 60 	rcall	8000a47c <_free_r>
8000b1c0:	30 08       	mov	r8,0
8000b1c2:	8f d8       	st.w	r7[0x34],r8
8000b1c4:	6f 2b       	ld.w	r11,r7[0x48]
8000b1c6:	58 0b       	cp.w	r11,0
8000b1c8:	c0 70       	breq	8000b1d6 <_fclose_r+0xaa>
8000b1ca:	0c 9c       	mov	r12,r6
8000b1cc:	fe b0 f9 58 	rcall	8000a47c <_free_r>
8000b1d0:	30 08       	mov	r8,0
8000b1d2:	ef 48 00 48 	st.w	r7[72],r8
8000b1d6:	30 08       	mov	r8,0
8000b1d8:	ae 68       	st.h	r7[0xc],r8
8000b1da:	fe b0 f8 66 	rcall	8000a2a6 <__sfp_lock_release>
8000b1de:	0a 9c       	mov	r12,r5
8000b1e0:	d8 22       	popm	r4-r7,pc
8000b1e2:	d7 03       	nop

8000b1e4 <fclose>:
8000b1e4:	d4 01       	pushm	lr
8000b1e6:	e0 68 0a 30 	mov	r8,2608
8000b1ea:	18 9b       	mov	r11,r12
8000b1ec:	70 0c       	ld.w	r12,r8[0x0]
8000b1ee:	c9 ff       	rcall	8000b12c <_fclose_r>
8000b1f0:	d8 02       	popm	pc
8000b1f2:	d7 03       	nop

8000b1f4 <_fstat_r>:
8000b1f4:	d4 21       	pushm	r4-r7,lr
8000b1f6:	16 98       	mov	r8,r11
8000b1f8:	18 97       	mov	r7,r12
8000b1fa:	10 9c       	mov	r12,r8
8000b1fc:	30 08       	mov	r8,0
8000b1fe:	e0 66 41 14 	mov	r6,16660
8000b202:	14 9b       	mov	r11,r10
8000b204:	8d 08       	st.w	r6[0x0],r8
8000b206:	fe b0 df 73 	rcall	800070ec <_fstat>
8000b20a:	5b fc       	cp.w	r12,-1
8000b20c:	c0 51       	brne	8000b216 <_fstat_r+0x22>
8000b20e:	6c 08       	ld.w	r8,r6[0x0]
8000b210:	58 08       	cp.w	r8,0
8000b212:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b216:	d8 22       	popm	r4-r7,pc

8000b218 <_lseek_r>:
8000b218:	d4 21       	pushm	r4-r7,lr
8000b21a:	16 98       	mov	r8,r11
8000b21c:	18 97       	mov	r7,r12
8000b21e:	10 9c       	mov	r12,r8
8000b220:	30 08       	mov	r8,0
8000b222:	14 9b       	mov	r11,r10
8000b224:	e0 66 41 14 	mov	r6,16660
8000b228:	12 9a       	mov	r10,r9
8000b22a:	8d 08       	st.w	r6[0x0],r8
8000b22c:	fe b0 df 42 	rcall	800070b0 <_lseek>
8000b230:	5b fc       	cp.w	r12,-1
8000b232:	c0 51       	brne	8000b23c <_lseek_r+0x24>
8000b234:	6c 08       	ld.w	r8,r6[0x0]
8000b236:	58 08       	cp.w	r8,0
8000b238:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b23c:	d8 22       	popm	r4-r7,pc
8000b23e:	d7 03       	nop

8000b240 <_read_r>:
8000b240:	d4 21       	pushm	r4-r7,lr
8000b242:	16 98       	mov	r8,r11
8000b244:	18 97       	mov	r7,r12
8000b246:	10 9c       	mov	r12,r8
8000b248:	30 08       	mov	r8,0
8000b24a:	14 9b       	mov	r11,r10
8000b24c:	e0 66 41 14 	mov	r6,16660
8000b250:	12 9a       	mov	r10,r9
8000b252:	8d 08       	st.w	r6[0x0],r8
8000b254:	fe b0 d0 2a 	rcall	800052a8 <_read>
8000b258:	5b fc       	cp.w	r12,-1
8000b25a:	c0 51       	brne	8000b264 <_read_r+0x24>
8000b25c:	6c 08       	ld.w	r8,r6[0x0]
8000b25e:	58 08       	cp.w	r8,0
8000b260:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b264:	d8 22       	popm	r4-r7,pc
8000b266:	d7 03       	nop

8000b268 <__avr32_f64_mul>:
8000b268:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b26c:	e0 80 00 dc 	breq	8000b424 <__avr32_f64_mul_op1_zero>
8000b270:	d4 21       	pushm	r4-r7,lr
8000b272:	f7 e9 20 0e 	eor	lr,r11,r9
8000b276:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b27a:	30 15       	mov	r5,1
8000b27c:	c4 30       	breq	8000b302 <__avr32_f64_mul_op1_subnormal>
8000b27e:	ab 6b       	lsl	r11,0xa
8000b280:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b284:	ab 6a       	lsl	r10,0xa
8000b286:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b28a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b28e:	c5 c0       	breq	8000b346 <__avr32_f64_mul_op2_subnormal>
8000b290:	a1 78       	lsl	r8,0x1
8000b292:	5c f9       	rol	r9
8000b294:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b298:	e0 47 07 ff 	cp.w	r7,2047
8000b29c:	c7 70       	breq	8000b38a <__avr32_f64_mul_op_nan_or_inf>
8000b29e:	e0 46 07 ff 	cp.w	r6,2047
8000b2a2:	c7 40       	breq	8000b38a <__avr32_f64_mul_op_nan_or_inf>
8000b2a4:	ee 06 00 0c 	add	r12,r7,r6
8000b2a8:	e0 2c 03 fe 	sub	r12,1022
8000b2ac:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b2b0:	f4 09 07 44 	macu.d	r4,r10,r9
8000b2b4:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b2b8:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b2bc:	08 07       	add	r7,r4
8000b2be:	f4 05 00 4a 	adc	r10,r10,r5
8000b2c2:	5c 0b       	acr	r11
8000b2c4:	ed bb 00 14 	bld	r11,0x14
8000b2c8:	c0 50       	breq	8000b2d2 <__avr32_f64_mul+0x6a>
8000b2ca:	a1 77       	lsl	r7,0x1
8000b2cc:	5c fa       	rol	r10
8000b2ce:	5c fb       	rol	r11
8000b2d0:	20 1c       	sub	r12,1
8000b2d2:	58 0c       	cp.w	r12,0
8000b2d4:	e0 8a 00 6f 	brle	8000b3b2 <__avr32_f64_mul_res_subnormal>
8000b2d8:	e0 4c 07 ff 	cp.w	r12,2047
8000b2dc:	e0 84 00 9c 	brge	8000b414 <__avr32_f64_mul_res_inf>
8000b2e0:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b2e4:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b2e8:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b2ec:	ee 17 80 00 	eorh	r7,0x8000
8000b2f0:	f1 b7 04 20 	satu	r7,0x1
8000b2f4:	0e 0a       	add	r10,r7
8000b2f6:	5c 0b       	acr	r11
8000b2f8:	ed be 00 1f 	bld	lr,0x1f
8000b2fc:	ef bb 00 1f 	bst	r11,0x1f
8000b300:	d8 22       	popm	r4-r7,pc

8000b302 <__avr32_f64_mul_op1_subnormal>:
8000b302:	e4 1b 00 0f 	andh	r11,0xf
8000b306:	f4 0c 12 00 	clz	r12,r10
8000b30a:	f6 06 12 00 	clz	r6,r11
8000b30e:	f7 bc 03 e1 	sublo	r12,-31
8000b312:	f8 06 17 30 	movlo	r6,r12
8000b316:	f7 b6 02 01 	subhs	r6,1
8000b31a:	e0 46 00 20 	cp.w	r6,32
8000b31e:	c0 d4       	brge	8000b338 <__avr32_f64_mul_op1_subnormal+0x36>
8000b320:	ec 0c 11 20 	rsub	r12,r6,32
8000b324:	f6 06 09 4b 	lsl	r11,r11,r6
8000b328:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b32c:	18 4b       	or	r11,r12
8000b32e:	f4 06 09 4a 	lsl	r10,r10,r6
8000b332:	20 b6       	sub	r6,11
8000b334:	0c 17       	sub	r7,r6
8000b336:	ca ab       	rjmp	8000b28a <__avr32_f64_mul+0x22>
8000b338:	f4 06 09 4b 	lsl	r11,r10,r6
8000b33c:	c6 40       	breq	8000b404 <__avr32_f64_mul_res_zero>
8000b33e:	30 0a       	mov	r10,0
8000b340:	20 b6       	sub	r6,11
8000b342:	0c 17       	sub	r7,r6
8000b344:	ca 3b       	rjmp	8000b28a <__avr32_f64_mul+0x22>

8000b346 <__avr32_f64_mul_op2_subnormal>:
8000b346:	e4 19 00 0f 	andh	r9,0xf
8000b34a:	f0 0c 12 00 	clz	r12,r8
8000b34e:	f2 05 12 00 	clz	r5,r9
8000b352:	f7 bc 03 ea 	sublo	r12,-22
8000b356:	f8 05 17 30 	movlo	r5,r12
8000b35a:	f7 b5 02 0a 	subhs	r5,10
8000b35e:	e0 45 00 20 	cp.w	r5,32
8000b362:	c0 d4       	brge	8000b37c <__avr32_f64_mul_op2_subnormal+0x36>
8000b364:	ea 0c 11 20 	rsub	r12,r5,32
8000b368:	f2 05 09 49 	lsl	r9,r9,r5
8000b36c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b370:	18 49       	or	r9,r12
8000b372:	f0 05 09 48 	lsl	r8,r8,r5
8000b376:	20 25       	sub	r5,2
8000b378:	0a 16       	sub	r6,r5
8000b37a:	c8 fb       	rjmp	8000b298 <__avr32_f64_mul+0x30>
8000b37c:	f0 05 09 49 	lsl	r9,r8,r5
8000b380:	c4 20       	breq	8000b404 <__avr32_f64_mul_res_zero>
8000b382:	30 08       	mov	r8,0
8000b384:	20 25       	sub	r5,2
8000b386:	0a 16       	sub	r6,r5
8000b388:	c8 8b       	rjmp	8000b298 <__avr32_f64_mul+0x30>

8000b38a <__avr32_f64_mul_op_nan_or_inf>:
8000b38a:	e4 19 00 0f 	andh	r9,0xf
8000b38e:	e4 1b 00 0f 	andh	r11,0xf
8000b392:	14 4b       	or	r11,r10
8000b394:	10 49       	or	r9,r8
8000b396:	e0 47 07 ff 	cp.w	r7,2047
8000b39a:	c0 91       	brne	8000b3ac <__avr32_f64_mul_op1_not_naninf>
8000b39c:	58 0b       	cp.w	r11,0
8000b39e:	c3 81       	brne	8000b40e <__avr32_f64_mul_res_nan>
8000b3a0:	e0 46 07 ff 	cp.w	r6,2047
8000b3a4:	c3 81       	brne	8000b414 <__avr32_f64_mul_res_inf>
8000b3a6:	58 09       	cp.w	r9,0
8000b3a8:	c3 60       	breq	8000b414 <__avr32_f64_mul_res_inf>
8000b3aa:	c3 28       	rjmp	8000b40e <__avr32_f64_mul_res_nan>

8000b3ac <__avr32_f64_mul_op1_not_naninf>:
8000b3ac:	58 09       	cp.w	r9,0
8000b3ae:	c3 30       	breq	8000b414 <__avr32_f64_mul_res_inf>
8000b3b0:	c2 f8       	rjmp	8000b40e <__avr32_f64_mul_res_nan>

8000b3b2 <__avr32_f64_mul_res_subnormal>:
8000b3b2:	5c 3c       	neg	r12
8000b3b4:	2f fc       	sub	r12,-1
8000b3b6:	f1 bc 04 c0 	satu	r12,0x6
8000b3ba:	e0 4c 00 20 	cp.w	r12,32
8000b3be:	c1 14       	brge	8000b3e0 <__avr32_f64_mul_res_subnormal+0x2e>
8000b3c0:	f8 08 11 20 	rsub	r8,r12,32
8000b3c4:	0e 46       	or	r6,r7
8000b3c6:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b3ca:	f4 08 09 49 	lsl	r9,r10,r8
8000b3ce:	12 47       	or	r7,r9
8000b3d0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b3d4:	f6 08 09 49 	lsl	r9,r11,r8
8000b3d8:	12 4a       	or	r10,r9
8000b3da:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b3de:	c8 3b       	rjmp	8000b2e4 <__avr32_f64_mul+0x7c>
8000b3e0:	f8 08 11 20 	rsub	r8,r12,32
8000b3e4:	f9 b9 00 00 	moveq	r9,0
8000b3e8:	c0 30       	breq	8000b3ee <__avr32_f64_mul_res_subnormal+0x3c>
8000b3ea:	f6 08 09 49 	lsl	r9,r11,r8
8000b3ee:	0e 46       	or	r6,r7
8000b3f0:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b3f4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b3f8:	f3 ea 10 07 	or	r7,r9,r10
8000b3fc:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b400:	30 0b       	mov	r11,0
8000b402:	c7 1b       	rjmp	8000b2e4 <__avr32_f64_mul+0x7c>

8000b404 <__avr32_f64_mul_res_zero>:
8000b404:	1c 9b       	mov	r11,lr
8000b406:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b40a:	30 0a       	mov	r10,0
8000b40c:	d8 22       	popm	r4-r7,pc

8000b40e <__avr32_f64_mul_res_nan>:
8000b40e:	3f fb       	mov	r11,-1
8000b410:	3f fa       	mov	r10,-1
8000b412:	d8 22       	popm	r4-r7,pc

8000b414 <__avr32_f64_mul_res_inf>:
8000b414:	f0 6b 00 00 	mov	r11,-1048576
8000b418:	ed be 00 1f 	bld	lr,0x1f
8000b41c:	ef bb 00 1f 	bst	r11,0x1f
8000b420:	30 0a       	mov	r10,0
8000b422:	d8 22       	popm	r4-r7,pc

8000b424 <__avr32_f64_mul_op1_zero>:
8000b424:	f7 e9 20 0b 	eor	r11,r11,r9
8000b428:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b42c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b430:	e0 4c 07 ff 	cp.w	r12,2047
8000b434:	5e 1c       	retne	r12
8000b436:	3f fa       	mov	r10,-1
8000b438:	3f fb       	mov	r11,-1
8000b43a:	5e fc       	retal	r12

8000b43c <__avr32_f64_sub_from_add>:
8000b43c:	ee 19 80 00 	eorh	r9,0x8000

8000b440 <__avr32_f64_sub>:
8000b440:	f7 e9 20 0c 	eor	r12,r11,r9
8000b444:	e0 86 00 ca 	brmi	8000b5d8 <__avr32_f64_add_from_sub>
8000b448:	eb cd 40 e0 	pushm	r5-r7,lr
8000b44c:	16 9c       	mov	r12,r11
8000b44e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b452:	bf db       	cbr	r11,0x1f
8000b454:	bf d9       	cbr	r9,0x1f
8000b456:	10 3a       	cp.w	r10,r8
8000b458:	f2 0b 13 00 	cpc	r11,r9
8000b45c:	c0 92       	brcc	8000b46e <__avr32_f64_sub+0x2e>
8000b45e:	16 97       	mov	r7,r11
8000b460:	12 9b       	mov	r11,r9
8000b462:	0e 99       	mov	r9,r7
8000b464:	14 97       	mov	r7,r10
8000b466:	10 9a       	mov	r10,r8
8000b468:	0e 98       	mov	r8,r7
8000b46a:	ee 1c 80 00 	eorh	r12,0x8000
8000b46e:	f6 07 16 14 	lsr	r7,r11,0x14
8000b472:	ab 7b       	lsl	r11,0xb
8000b474:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b478:	ab 7a       	lsl	r10,0xb
8000b47a:	bf bb       	sbr	r11,0x1f
8000b47c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b480:	c4 40       	breq	8000b508 <__avr32_f64_sub_opL_subnormal>
8000b482:	ab 79       	lsl	r9,0xb
8000b484:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b488:	ab 78       	lsl	r8,0xb
8000b48a:	bf b9       	sbr	r9,0x1f

8000b48c <__avr32_f64_sub_opL_subnormal_done>:
8000b48c:	e0 47 07 ff 	cp.w	r7,2047
8000b490:	c4 f0       	breq	8000b52e <__avr32_f64_sub_opH_nan_or_inf>
8000b492:	0e 26       	rsub	r6,r7
8000b494:	c1 20       	breq	8000b4b8 <__avr32_f64_sub_shift_done>
8000b496:	ec 05 11 20 	rsub	r5,r6,32
8000b49a:	e0 46 00 20 	cp.w	r6,32
8000b49e:	c7 c2       	brcc	8000b596 <__avr32_f64_sub_longshift>
8000b4a0:	f0 05 09 4e 	lsl	lr,r8,r5
8000b4a4:	f2 05 09 45 	lsl	r5,r9,r5
8000b4a8:	f0 06 0a 48 	lsr	r8,r8,r6
8000b4ac:	f2 06 0a 49 	lsr	r9,r9,r6
8000b4b0:	0a 48       	or	r8,r5
8000b4b2:	58 0e       	cp.w	lr,0
8000b4b4:	5f 1e       	srne	lr
8000b4b6:	1c 48       	or	r8,lr

8000b4b8 <__avr32_f64_sub_shift_done>:
8000b4b8:	10 1a       	sub	r10,r8
8000b4ba:	f6 09 01 4b 	sbc	r11,r11,r9
8000b4be:	f6 06 12 00 	clz	r6,r11
8000b4c2:	c0 e0       	breq	8000b4de <__avr32_f64_sub_longnormalize_done>
8000b4c4:	c7 83       	brcs	8000b5b4 <__avr32_f64_sub_longnormalize>
8000b4c6:	ec 0e 11 20 	rsub	lr,r6,32
8000b4ca:	f6 06 09 4b 	lsl	r11,r11,r6
8000b4ce:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b4d2:	1c 4b       	or	r11,lr
8000b4d4:	f4 06 09 4a 	lsl	r10,r10,r6
8000b4d8:	0c 17       	sub	r7,r6
8000b4da:	e0 8a 00 39 	brle	8000b54c <__avr32_f64_sub_subnormal_result>

8000b4de <__avr32_f64_sub_longnormalize_done>:
8000b4de:	f4 09 15 15 	lsl	r9,r10,0x15
8000b4e2:	ab 9a       	lsr	r10,0xb
8000b4e4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b4e8:	ab 9b       	lsr	r11,0xb
8000b4ea:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b4ee:	18 4b       	or	r11,r12

8000b4f0 <__avr32_f64_sub_round>:
8000b4f0:	fc 17 80 00 	movh	r7,0x8000
8000b4f4:	ed ba 00 00 	bld	r10,0x0
8000b4f8:	f7 b7 01 ff 	subne	r7,-1
8000b4fc:	0e 39       	cp.w	r9,r7
8000b4fe:	5f 29       	srhs	r9
8000b500:	12 0a       	add	r10,r9
8000b502:	5c 0b       	acr	r11
8000b504:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b508 <__avr32_f64_sub_opL_subnormal>:
8000b508:	ab 79       	lsl	r9,0xb
8000b50a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b50e:	ab 78       	lsl	r8,0xb
8000b510:	f3 e8 10 0e 	or	lr,r9,r8
8000b514:	f9 b6 01 01 	movne	r6,1
8000b518:	ee 0e 11 00 	rsub	lr,r7,0
8000b51c:	f9 b7 00 01 	moveq	r7,1
8000b520:	ef bb 00 1f 	bst	r11,0x1f
8000b524:	f7 ea 10 0e 	or	lr,r11,r10
8000b528:	f9 b7 00 00 	moveq	r7,0
8000b52c:	cb 0b       	rjmp	8000b48c <__avr32_f64_sub_opL_subnormal_done>

8000b52e <__avr32_f64_sub_opH_nan_or_inf>:
8000b52e:	bf db       	cbr	r11,0x1f
8000b530:	f7 ea 10 0e 	or	lr,r11,r10
8000b534:	c0 81       	brne	8000b544 <__avr32_f64_sub_return_nan>
8000b536:	e0 46 07 ff 	cp.w	r6,2047
8000b53a:	c0 50       	breq	8000b544 <__avr32_f64_sub_return_nan>
8000b53c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b540:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b544 <__avr32_f64_sub_return_nan>:
8000b544:	3f fa       	mov	r10,-1
8000b546:	3f fb       	mov	r11,-1
8000b548:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b54c <__avr32_f64_sub_subnormal_result>:
8000b54c:	5c 37       	neg	r7
8000b54e:	2f f7       	sub	r7,-1
8000b550:	f1 b7 04 c0 	satu	r7,0x6
8000b554:	e0 47 00 20 	cp.w	r7,32
8000b558:	c1 14       	brge	8000b57a <__avr32_f64_sub_subnormal_result+0x2e>
8000b55a:	ee 08 11 20 	rsub	r8,r7,32
8000b55e:	f4 08 09 49 	lsl	r9,r10,r8
8000b562:	5f 16       	srne	r6
8000b564:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b568:	0c 4a       	or	r10,r6
8000b56a:	f6 08 09 49 	lsl	r9,r11,r8
8000b56e:	f5 e9 10 0a 	or	r10,r10,r9
8000b572:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b576:	30 07       	mov	r7,0
8000b578:	cb 3b       	rjmp	8000b4de <__avr32_f64_sub_longnormalize_done>
8000b57a:	ee 08 11 40 	rsub	r8,r7,64
8000b57e:	f6 08 09 49 	lsl	r9,r11,r8
8000b582:	14 49       	or	r9,r10
8000b584:	5f 16       	srne	r6
8000b586:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b58a:	0c 4a       	or	r10,r6
8000b58c:	30 0b       	mov	r11,0
8000b58e:	30 07       	mov	r7,0
8000b590:	ca 7b       	rjmp	8000b4de <__avr32_f64_sub_longnormalize_done>
8000b592:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b596 <__avr32_f64_sub_longshift>:
8000b596:	f1 b6 04 c0 	satu	r6,0x6
8000b59a:	f0 0e 17 00 	moveq	lr,r8
8000b59e:	c0 40       	breq	8000b5a6 <__avr32_f64_sub_longshift+0x10>
8000b5a0:	f2 05 09 4e 	lsl	lr,r9,r5
8000b5a4:	10 4e       	or	lr,r8
8000b5a6:	f2 06 0a 48 	lsr	r8,r9,r6
8000b5aa:	30 09       	mov	r9,0
8000b5ac:	58 0e       	cp.w	lr,0
8000b5ae:	5f 1e       	srne	lr
8000b5b0:	1c 48       	or	r8,lr
8000b5b2:	c8 3b       	rjmp	8000b4b8 <__avr32_f64_sub_shift_done>

8000b5b4 <__avr32_f64_sub_longnormalize>:
8000b5b4:	f4 06 12 00 	clz	r6,r10
8000b5b8:	f9 b7 03 00 	movlo	r7,0
8000b5bc:	f9 b6 03 00 	movlo	r6,0
8000b5c0:	f9 bc 03 00 	movlo	r12,0
8000b5c4:	f7 b6 02 e0 	subhs	r6,-32
8000b5c8:	f4 06 09 4b 	lsl	r11,r10,r6
8000b5cc:	30 0a       	mov	r10,0
8000b5ce:	0c 17       	sub	r7,r6
8000b5d0:	fe 9a ff be 	brle	8000b54c <__avr32_f64_sub_subnormal_result>
8000b5d4:	c8 5b       	rjmp	8000b4de <__avr32_f64_sub_longnormalize_done>
8000b5d6:	d7 03       	nop

8000b5d8 <__avr32_f64_add_from_sub>:
8000b5d8:	ee 19 80 00 	eorh	r9,0x8000

8000b5dc <__avr32_f64_add>:
8000b5dc:	f7 e9 20 0c 	eor	r12,r11,r9
8000b5e0:	fe 96 ff 2e 	brmi	8000b43c <__avr32_f64_sub_from_add>
8000b5e4:	eb cd 40 e0 	pushm	r5-r7,lr
8000b5e8:	16 9c       	mov	r12,r11
8000b5ea:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b5ee:	bf db       	cbr	r11,0x1f
8000b5f0:	bf d9       	cbr	r9,0x1f
8000b5f2:	12 3b       	cp.w	r11,r9
8000b5f4:	c0 72       	brcc	8000b602 <__avr32_f64_add+0x26>
8000b5f6:	16 97       	mov	r7,r11
8000b5f8:	12 9b       	mov	r11,r9
8000b5fa:	0e 99       	mov	r9,r7
8000b5fc:	14 97       	mov	r7,r10
8000b5fe:	10 9a       	mov	r10,r8
8000b600:	0e 98       	mov	r8,r7
8000b602:	30 0e       	mov	lr,0
8000b604:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b608:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b60c:	b5 ab       	sbr	r11,0x14
8000b60e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b612:	c6 20       	breq	8000b6d6 <__avr32_f64_add_op2_subnormal>
8000b614:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b618:	b5 a9       	sbr	r9,0x14
8000b61a:	e0 47 07 ff 	cp.w	r7,2047
8000b61e:	c2 80       	breq	8000b66e <__avr32_f64_add_opH_nan_or_inf>
8000b620:	0e 26       	rsub	r6,r7
8000b622:	c1 20       	breq	8000b646 <__avr32_f64_add_shift_done>
8000b624:	e0 46 00 36 	cp.w	r6,54
8000b628:	c1 52       	brcc	8000b652 <__avr32_f64_add_res_of_done>
8000b62a:	ec 05 11 20 	rsub	r5,r6,32
8000b62e:	e0 46 00 20 	cp.w	r6,32
8000b632:	c3 52       	brcc	8000b69c <__avr32_f64_add_longshift>
8000b634:	f0 05 09 4e 	lsl	lr,r8,r5
8000b638:	f2 05 09 45 	lsl	r5,r9,r5
8000b63c:	f0 06 0a 48 	lsr	r8,r8,r6
8000b640:	f2 06 0a 49 	lsr	r9,r9,r6
8000b644:	0a 48       	or	r8,r5

8000b646 <__avr32_f64_add_shift_done>:
8000b646:	10 0a       	add	r10,r8
8000b648:	f6 09 00 4b 	adc	r11,r11,r9
8000b64c:	ed bb 00 15 	bld	r11,0x15
8000b650:	c3 40       	breq	8000b6b8 <__avr32_f64_add_res_of>

8000b652 <__avr32_f64_add_res_of_done>:
8000b652:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b656:	18 4b       	or	r11,r12

8000b658 <__avr32_f64_add_round>:
8000b658:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b65c:	18 4e       	or	lr,r12
8000b65e:	ee 1e 80 00 	eorh	lr,0x8000
8000b662:	f1 be 04 20 	satu	lr,0x1
8000b666:	1c 0a       	add	r10,lr
8000b668:	5c 0b       	acr	r11
8000b66a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b66e <__avr32_f64_add_opH_nan_or_inf>:
8000b66e:	b5 cb       	cbr	r11,0x14
8000b670:	f7 ea 10 0e 	or	lr,r11,r10
8000b674:	c1 01       	brne	8000b694 <__avr32_f64_add_return_nan>
8000b676:	e0 46 07 ff 	cp.w	r6,2047
8000b67a:	c0 30       	breq	8000b680 <__avr32_f64_add_opL_nan_or_inf>
8000b67c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b680 <__avr32_f64_add_opL_nan_or_inf>:
8000b680:	b5 c9       	cbr	r9,0x14
8000b682:	f3 e8 10 0e 	or	lr,r9,r8
8000b686:	c0 71       	brne	8000b694 <__avr32_f64_add_return_nan>
8000b688:	30 0a       	mov	r10,0
8000b68a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b68e:	18 4b       	or	r11,r12
8000b690:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b694 <__avr32_f64_add_return_nan>:
8000b694:	3f fa       	mov	r10,-1
8000b696:	3f fb       	mov	r11,-1
8000b698:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b69c <__avr32_f64_add_longshift>:
8000b69c:	f1 b6 04 c0 	satu	r6,0x6
8000b6a0:	f0 0e 17 00 	moveq	lr,r8
8000b6a4:	c0 60       	breq	8000b6b0 <__avr32_f64_add_longshift+0x14>
8000b6a6:	f2 05 09 4e 	lsl	lr,r9,r5
8000b6aa:	58 08       	cp.w	r8,0
8000b6ac:	5f 18       	srne	r8
8000b6ae:	10 4e       	or	lr,r8
8000b6b0:	f2 06 0a 48 	lsr	r8,r9,r6
8000b6b4:	30 09       	mov	r9,0
8000b6b6:	cc 8b       	rjmp	8000b646 <__avr32_f64_add_shift_done>

8000b6b8 <__avr32_f64_add_res_of>:
8000b6b8:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b6bc:	a1 9b       	lsr	r11,0x1
8000b6be:	5d 0a       	ror	r10
8000b6c0:	5d 0e       	ror	lr
8000b6c2:	2f f7       	sub	r7,-1
8000b6c4:	e0 47 07 ff 	cp.w	r7,2047
8000b6c8:	f9 ba 00 00 	moveq	r10,0
8000b6cc:	f9 bb 00 00 	moveq	r11,0
8000b6d0:	f9 be 00 00 	moveq	lr,0
8000b6d4:	cb fb       	rjmp	8000b652 <__avr32_f64_add_res_of_done>

8000b6d6 <__avr32_f64_add_op2_subnormal>:
8000b6d6:	30 16       	mov	r6,1
8000b6d8:	58 07       	cp.w	r7,0
8000b6da:	ca 01       	brne	8000b61a <__avr32_f64_add+0x3e>
8000b6dc:	b5 cb       	cbr	r11,0x14
8000b6de:	10 0a       	add	r10,r8
8000b6e0:	f6 09 00 4b 	adc	r11,r11,r9
8000b6e4:	18 4b       	or	r11,r12
8000b6e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b6ea:	d7 03       	nop

8000b6ec <__avr32_f64_to_u32>:
8000b6ec:	58 0b       	cp.w	r11,0
8000b6ee:	5e 6d       	retmi	0

8000b6f0 <__avr32_f64_to_s32>:
8000b6f0:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b6f4:	b5 9c       	lsr	r12,0x15
8000b6f6:	e0 2c 03 ff 	sub	r12,1023
8000b6fa:	5e 3d       	retlo	0
8000b6fc:	f8 0c 11 1f 	rsub	r12,r12,31
8000b700:	16 99       	mov	r9,r11
8000b702:	ab 7b       	lsl	r11,0xb
8000b704:	bf bb       	sbr	r11,0x1f
8000b706:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b70a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b70e:	a1 79       	lsl	r9,0x1
8000b710:	5e 2b       	reths	r11
8000b712:	5c 3b       	neg	r11
8000b714:	5e fb       	retal	r11

8000b716 <__avr32_u32_to_f64>:
8000b716:	f8 cb 00 00 	sub	r11,r12,0
8000b71a:	30 0c       	mov	r12,0
8000b71c:	c0 38       	rjmp	8000b722 <__avr32_s32_to_f64+0x4>

8000b71e <__avr32_s32_to_f64>:
8000b71e:	18 9b       	mov	r11,r12
8000b720:	5c 4b       	abs	r11
8000b722:	30 0a       	mov	r10,0
8000b724:	5e 0b       	reteq	r11
8000b726:	d4 01       	pushm	lr
8000b728:	e0 69 04 1e 	mov	r9,1054
8000b72c:	f6 08 12 00 	clz	r8,r11
8000b730:	c1 70       	breq	8000b75e <__avr32_s32_to_f64+0x40>
8000b732:	c0 c3       	brcs	8000b74a <__avr32_s32_to_f64+0x2c>
8000b734:	f0 0e 11 20 	rsub	lr,r8,32
8000b738:	f6 08 09 4b 	lsl	r11,r11,r8
8000b73c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b740:	1c 4b       	or	r11,lr
8000b742:	f4 08 09 4a 	lsl	r10,r10,r8
8000b746:	10 19       	sub	r9,r8
8000b748:	c0 b8       	rjmp	8000b75e <__avr32_s32_to_f64+0x40>
8000b74a:	f4 08 12 00 	clz	r8,r10
8000b74e:	f9 b8 03 00 	movlo	r8,0
8000b752:	f7 b8 02 e0 	subhs	r8,-32
8000b756:	f4 08 09 4b 	lsl	r11,r10,r8
8000b75a:	30 0a       	mov	r10,0
8000b75c:	10 19       	sub	r9,r8
8000b75e:	58 09       	cp.w	r9,0
8000b760:	e0 89 00 30 	brgt	8000b7c0 <__avr32_s32_to_f64+0xa2>
8000b764:	5c 39       	neg	r9
8000b766:	2f f9       	sub	r9,-1
8000b768:	e0 49 00 36 	cp.w	r9,54
8000b76c:	c0 43       	brcs	8000b774 <__avr32_s32_to_f64+0x56>
8000b76e:	30 0b       	mov	r11,0
8000b770:	30 0a       	mov	r10,0
8000b772:	c2 68       	rjmp	8000b7be <__avr32_s32_to_f64+0xa0>
8000b774:	2f 69       	sub	r9,-10
8000b776:	f2 08 11 20 	rsub	r8,r9,32
8000b77a:	e0 49 00 20 	cp.w	r9,32
8000b77e:	c0 b2       	brcc	8000b794 <__avr32_s32_to_f64+0x76>
8000b780:	f4 08 09 4e 	lsl	lr,r10,r8
8000b784:	f6 08 09 48 	lsl	r8,r11,r8
8000b788:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b78c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b790:	10 4b       	or	r11,r8
8000b792:	c0 88       	rjmp	8000b7a2 <__avr32_s32_to_f64+0x84>
8000b794:	f6 08 09 4e 	lsl	lr,r11,r8
8000b798:	14 4e       	or	lr,r10
8000b79a:	16 9a       	mov	r10,r11
8000b79c:	30 0b       	mov	r11,0
8000b79e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b7a2:	ed ba 00 00 	bld	r10,0x0
8000b7a6:	c0 92       	brcc	8000b7b8 <__avr32_s32_to_f64+0x9a>
8000b7a8:	1c 7e       	tst	lr,lr
8000b7aa:	c0 41       	brne	8000b7b2 <__avr32_s32_to_f64+0x94>
8000b7ac:	ed ba 00 01 	bld	r10,0x1
8000b7b0:	c0 42       	brcc	8000b7b8 <__avr32_s32_to_f64+0x9a>
8000b7b2:	2f fa       	sub	r10,-1
8000b7b4:	f7 bb 02 ff 	subhs	r11,-1
8000b7b8:	5c fc       	rol	r12
8000b7ba:	5d 0b       	ror	r11
8000b7bc:	5d 0a       	ror	r10
8000b7be:	d8 02       	popm	pc
8000b7c0:	e0 68 03 ff 	mov	r8,1023
8000b7c4:	ed ba 00 0b 	bld	r10,0xb
8000b7c8:	f7 b8 00 ff 	subeq	r8,-1
8000b7cc:	10 0a       	add	r10,r8
8000b7ce:	5c 0b       	acr	r11
8000b7d0:	f7 b9 03 fe 	sublo	r9,-2
8000b7d4:	e0 49 07 ff 	cp.w	r9,2047
8000b7d8:	c0 55       	brlt	8000b7e2 <__avr32_s32_to_f64+0xc4>
8000b7da:	30 0a       	mov	r10,0
8000b7dc:	fc 1b ff e0 	movh	r11,0xffe0
8000b7e0:	c0 c8       	rjmp	8000b7f8 <__floatsidf_return_op1>
8000b7e2:	ed bb 00 1f 	bld	r11,0x1f
8000b7e6:	f7 b9 01 01 	subne	r9,1
8000b7ea:	ab 9a       	lsr	r10,0xb
8000b7ec:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b7f0:	a1 7b       	lsl	r11,0x1
8000b7f2:	ab 9b       	lsr	r11,0xb
8000b7f4:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b7f8 <__floatsidf_return_op1>:
8000b7f8:	a1 7c       	lsl	r12,0x1
8000b7fa:	5d 0b       	ror	r11
8000b7fc:	d8 02       	popm	pc

8000b7fe <__avr32_f64_cmp_eq>:
8000b7fe:	10 3a       	cp.w	r10,r8
8000b800:	f2 0b 13 00 	cpc	r11,r9
8000b804:	c0 80       	breq	8000b814 <__avr32_f64_cmp_eq+0x16>
8000b806:	a1 7b       	lsl	r11,0x1
8000b808:	a1 79       	lsl	r9,0x1
8000b80a:	14 4b       	or	r11,r10
8000b80c:	12 4b       	or	r11,r9
8000b80e:	10 4b       	or	r11,r8
8000b810:	5e 0f       	reteq	1
8000b812:	5e fd       	retal	0
8000b814:	a1 7b       	lsl	r11,0x1
8000b816:	fc 1c ff e0 	movh	r12,0xffe0
8000b81a:	58 0a       	cp.w	r10,0
8000b81c:	f8 0b 13 00 	cpc	r11,r12
8000b820:	5e 8f       	retls	1
8000b822:	5e fd       	retal	0

8000b824 <__avr32_f64_cmp_ge>:
8000b824:	1a de       	st.w	--sp,lr
8000b826:	1a d7       	st.w	--sp,r7
8000b828:	a1 7b       	lsl	r11,0x1
8000b82a:	5f 3c       	srlo	r12
8000b82c:	a1 79       	lsl	r9,0x1
8000b82e:	5f 37       	srlo	r7
8000b830:	5c fc       	rol	r12
8000b832:	fc 1e ff e0 	movh	lr,0xffe0
8000b836:	58 0a       	cp.w	r10,0
8000b838:	fc 0b 13 00 	cpc	r11,lr
8000b83c:	e0 8b 00 1d 	brhi	8000b876 <__avr32_f64_cmp_ge+0x52>
8000b840:	58 08       	cp.w	r8,0
8000b842:	fc 09 13 00 	cpc	r9,lr
8000b846:	e0 8b 00 18 	brhi	8000b876 <__avr32_f64_cmp_ge+0x52>
8000b84a:	58 0b       	cp.w	r11,0
8000b84c:	f5 ba 00 00 	subfeq	r10,0
8000b850:	c1 50       	breq	8000b87a <__avr32_f64_cmp_ge+0x56>
8000b852:	1b 07       	ld.w	r7,sp++
8000b854:	1b 0e       	ld.w	lr,sp++
8000b856:	58 3c       	cp.w	r12,3
8000b858:	c0 a0       	breq	8000b86c <__avr32_f64_cmp_ge+0x48>
8000b85a:	58 1c       	cp.w	r12,1
8000b85c:	c0 33       	brcs	8000b862 <__avr32_f64_cmp_ge+0x3e>
8000b85e:	5e 0f       	reteq	1
8000b860:	5e 1d       	retne	0
8000b862:	10 3a       	cp.w	r10,r8
8000b864:	f2 0b 13 00 	cpc	r11,r9
8000b868:	5e 2f       	reths	1
8000b86a:	5e 3d       	retlo	0
8000b86c:	14 38       	cp.w	r8,r10
8000b86e:	f6 09 13 00 	cpc	r9,r11
8000b872:	5e 2f       	reths	1
8000b874:	5e 3d       	retlo	0
8000b876:	1b 07       	ld.w	r7,sp++
8000b878:	d8 0a       	popm	pc,r12=0
8000b87a:	58 17       	cp.w	r7,1
8000b87c:	5f 0c       	sreq	r12
8000b87e:	58 09       	cp.w	r9,0
8000b880:	f5 b8 00 00 	subfeq	r8,0
8000b884:	1b 07       	ld.w	r7,sp++
8000b886:	1b 0e       	ld.w	lr,sp++
8000b888:	5e 0f       	reteq	1
8000b88a:	5e fc       	retal	r12

8000b88c <__avr32_f64_cmp_lt>:
8000b88c:	1a de       	st.w	--sp,lr
8000b88e:	1a d7       	st.w	--sp,r7
8000b890:	a1 7b       	lsl	r11,0x1
8000b892:	5f 3c       	srlo	r12
8000b894:	a1 79       	lsl	r9,0x1
8000b896:	5f 37       	srlo	r7
8000b898:	5c fc       	rol	r12
8000b89a:	fc 1e ff e0 	movh	lr,0xffe0
8000b89e:	58 0a       	cp.w	r10,0
8000b8a0:	fc 0b 13 00 	cpc	r11,lr
8000b8a4:	e0 8b 00 1d 	brhi	8000b8de <__avr32_f64_cmp_lt+0x52>
8000b8a8:	58 08       	cp.w	r8,0
8000b8aa:	fc 09 13 00 	cpc	r9,lr
8000b8ae:	e0 8b 00 18 	brhi	8000b8de <__avr32_f64_cmp_lt+0x52>
8000b8b2:	58 0b       	cp.w	r11,0
8000b8b4:	f5 ba 00 00 	subfeq	r10,0
8000b8b8:	c1 50       	breq	8000b8e2 <__avr32_f64_cmp_lt+0x56>
8000b8ba:	1b 07       	ld.w	r7,sp++
8000b8bc:	1b 0e       	ld.w	lr,sp++
8000b8be:	58 3c       	cp.w	r12,3
8000b8c0:	c0 a0       	breq	8000b8d4 <__avr32_f64_cmp_lt+0x48>
8000b8c2:	58 1c       	cp.w	r12,1
8000b8c4:	c0 33       	brcs	8000b8ca <__avr32_f64_cmp_lt+0x3e>
8000b8c6:	5e 0d       	reteq	0
8000b8c8:	5e 1f       	retne	1
8000b8ca:	10 3a       	cp.w	r10,r8
8000b8cc:	f2 0b 13 00 	cpc	r11,r9
8000b8d0:	5e 2d       	reths	0
8000b8d2:	5e 3f       	retlo	1
8000b8d4:	14 38       	cp.w	r8,r10
8000b8d6:	f6 09 13 00 	cpc	r9,r11
8000b8da:	5e 2d       	reths	0
8000b8dc:	5e 3f       	retlo	1
8000b8de:	1b 07       	ld.w	r7,sp++
8000b8e0:	d8 0a       	popm	pc,r12=0
8000b8e2:	58 17       	cp.w	r7,1
8000b8e4:	5f 1c       	srne	r12
8000b8e6:	58 09       	cp.w	r9,0
8000b8e8:	f5 b8 00 00 	subfeq	r8,0
8000b8ec:	1b 07       	ld.w	r7,sp++
8000b8ee:	1b 0e       	ld.w	lr,sp++
8000b8f0:	5e 0d       	reteq	0
8000b8f2:	5e fc       	retal	r12

8000b8f4 <__avr32_f64_div>:
8000b8f4:	eb cd 40 ff 	pushm	r0-r7,lr
8000b8f8:	f7 e9 20 0e 	eor	lr,r11,r9
8000b8fc:	f6 07 16 14 	lsr	r7,r11,0x14
8000b900:	a9 7b       	lsl	r11,0x9
8000b902:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b906:	a9 7a       	lsl	r10,0x9
8000b908:	bd bb       	sbr	r11,0x1d
8000b90a:	e4 1b 3f ff 	andh	r11,0x3fff
8000b90e:	ab d7       	cbr	r7,0xb
8000b910:	e0 80 00 cc 	breq	8000baa8 <__avr32_f64_div_round_subnormal+0x54>
8000b914:	e0 47 07 ff 	cp.w	r7,2047
8000b918:	e0 84 00 b5 	brge	8000ba82 <__avr32_f64_div_round_subnormal+0x2e>
8000b91c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b920:	a9 79       	lsl	r9,0x9
8000b922:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b926:	a9 78       	lsl	r8,0x9
8000b928:	bd b9       	sbr	r9,0x1d
8000b92a:	e4 19 3f ff 	andh	r9,0x3fff
8000b92e:	ab d6       	cbr	r6,0xb
8000b930:	e0 80 00 e2 	breq	8000baf4 <__avr32_f64_div_round_subnormal+0xa0>
8000b934:	e0 46 07 ff 	cp.w	r6,2047
8000b938:	e0 84 00 b2 	brge	8000ba9c <__avr32_f64_div_round_subnormal+0x48>
8000b93c:	0c 17       	sub	r7,r6
8000b93e:	fe 37 fc 01 	sub	r7,-1023
8000b942:	fc 1c 80 00 	movh	r12,0x8000
8000b946:	f8 03 16 01 	lsr	r3,r12,0x1
8000b94a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b94e:	5c d4       	com	r4
8000b950:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b954:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b958:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b95c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b960:	ea 03 15 02 	lsl	r3,r5,0x2
8000b964:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b968:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b96c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b970:	ea 03 15 02 	lsl	r3,r5,0x2
8000b974:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b978:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b97c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b980:	ea 03 15 02 	lsl	r3,r5,0x2
8000b984:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b988:	e4 09 07 40 	macu.d	r0,r2,r9
8000b98c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b990:	02 04       	add	r4,r1
8000b992:	5c 05       	acr	r5
8000b994:	a3 65       	lsl	r5,0x2
8000b996:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b99a:	a3 64       	lsl	r4,0x2
8000b99c:	5c 34       	neg	r4
8000b99e:	f8 05 01 45 	sbc	r5,r12,r5
8000b9a2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b9a6:	e4 05 07 40 	macu.d	r0,r2,r5
8000b9aa:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b9ae:	02 04       	add	r4,r1
8000b9b0:	5c 05       	acr	r5
8000b9b2:	ea 03 15 02 	lsl	r3,r5,0x2
8000b9b6:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b9ba:	e8 02 15 02 	lsl	r2,r4,0x2
8000b9be:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b9c2:	e4 09 07 40 	macu.d	r0,r2,r9
8000b9c6:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b9ca:	02 04       	add	r4,r1
8000b9cc:	5c 05       	acr	r5
8000b9ce:	a3 65       	lsl	r5,0x2
8000b9d0:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b9d4:	a3 64       	lsl	r4,0x2
8000b9d6:	5c 34       	neg	r4
8000b9d8:	f8 05 01 45 	sbc	r5,r12,r5
8000b9dc:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b9e0:	e4 05 07 40 	macu.d	r0,r2,r5
8000b9e4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b9e8:	02 04       	add	r4,r1
8000b9ea:	5c 05       	acr	r5
8000b9ec:	ea 03 15 02 	lsl	r3,r5,0x2
8000b9f0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b9f4:	e8 02 15 02 	lsl	r2,r4,0x2
8000b9f8:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b9fc:	e4 0b 07 40 	macu.d	r0,r2,r11
8000ba00:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000ba04:	02 02       	add	r2,r1
8000ba06:	5c 03       	acr	r3
8000ba08:	ed b3 00 1c 	bld	r3,0x1c
8000ba0c:	c0 90       	breq	8000ba1e <__avr32_f64_div+0x12a>
8000ba0e:	a1 72       	lsl	r2,0x1
8000ba10:	5c f3       	rol	r3
8000ba12:	20 17       	sub	r7,1
8000ba14:	a3 9a       	lsr	r10,0x3
8000ba16:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000ba1a:	a3 9b       	lsr	r11,0x3
8000ba1c:	c0 58       	rjmp	8000ba26 <__avr32_f64_div+0x132>
8000ba1e:	a5 8a       	lsr	r10,0x4
8000ba20:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000ba24:	a5 8b       	lsr	r11,0x4
8000ba26:	58 07       	cp.w	r7,0
8000ba28:	e0 8a 00 8b 	brle	8000bb3e <__avr32_f64_div_res_subnormal>
8000ba2c:	e0 12 ff 00 	andl	r2,0xff00
8000ba30:	e8 12 00 80 	orl	r2,0x80
8000ba34:	e6 08 06 40 	mulu.d	r0,r3,r8
8000ba38:	e4 09 07 40 	macu.d	r0,r2,r9
8000ba3c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000ba40:	e6 09 06 48 	mulu.d	r8,r3,r9
8000ba44:	00 05       	add	r5,r0
8000ba46:	f0 01 00 48 	adc	r8,r8,r1
8000ba4a:	5c 09       	acr	r9
8000ba4c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000ba50:	58 04       	cp.w	r4,0
8000ba52:	5c 25       	cpc	r5

8000ba54 <__avr32_f64_div_round_subnormal>:
8000ba54:	f4 08 13 00 	cpc	r8,r10
8000ba58:	f6 09 13 00 	cpc	r9,r11
8000ba5c:	5f 36       	srlo	r6
8000ba5e:	f8 06 17 00 	moveq	r6,r12
8000ba62:	e4 0a 16 08 	lsr	r10,r2,0x8
8000ba66:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000ba6a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000ba6e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ba72:	ed be 00 1f 	bld	lr,0x1f
8000ba76:	ef bb 00 1f 	bst	r11,0x1f
8000ba7a:	0c 0a       	add	r10,r6
8000ba7c:	5c 0b       	acr	r11
8000ba7e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000ba82:	e4 1b 00 0f 	andh	r11,0xf
8000ba86:	14 4b       	or	r11,r10
8000ba88:	e0 81 00 a7 	brne	8000bbd6 <__avr32_f64_div_res_subnormal+0x98>
8000ba8c:	f2 06 16 14 	lsr	r6,r9,0x14
8000ba90:	ab d6       	cbr	r6,0xb
8000ba92:	e0 46 07 ff 	cp.w	r6,2047
8000ba96:	e0 81 00 a4 	brne	8000bbde <__avr32_f64_div_res_subnormal+0xa0>
8000ba9a:	c9 e8       	rjmp	8000bbd6 <__avr32_f64_div_res_subnormal+0x98>
8000ba9c:	e4 19 00 0f 	andh	r9,0xf
8000baa0:	10 49       	or	r9,r8
8000baa2:	e0 81 00 9a 	brne	8000bbd6 <__avr32_f64_div_res_subnormal+0x98>
8000baa6:	c9 28       	rjmp	8000bbca <__avr32_f64_div_res_subnormal+0x8c>
8000baa8:	a3 7b       	lsl	r11,0x3
8000baaa:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000baae:	a3 7a       	lsl	r10,0x3
8000bab0:	f5 eb 10 04 	or	r4,r10,r11
8000bab4:	e0 80 00 a0 	breq	8000bbf4 <__avr32_f64_div_op1_zero>
8000bab8:	f6 04 12 00 	clz	r4,r11
8000babc:	c1 70       	breq	8000baea <__avr32_f64_div_round_subnormal+0x96>
8000babe:	c0 c3       	brcs	8000bad6 <__avr32_f64_div_round_subnormal+0x82>
8000bac0:	e8 05 11 20 	rsub	r5,r4,32
8000bac4:	f6 04 09 4b 	lsl	r11,r11,r4
8000bac8:	f4 05 0a 45 	lsr	r5,r10,r5
8000bacc:	0a 4b       	or	r11,r5
8000bace:	f4 04 09 4a 	lsl	r10,r10,r4
8000bad2:	08 17       	sub	r7,r4
8000bad4:	c0 b8       	rjmp	8000baea <__avr32_f64_div_round_subnormal+0x96>
8000bad6:	f4 04 12 00 	clz	r4,r10
8000bada:	f9 b4 03 00 	movlo	r4,0
8000bade:	f7 b4 02 e0 	subhs	r4,-32
8000bae2:	f4 04 09 4b 	lsl	r11,r10,r4
8000bae6:	30 0a       	mov	r10,0
8000bae8:	08 17       	sub	r7,r4
8000baea:	a3 8a       	lsr	r10,0x2
8000baec:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000baf0:	a3 8b       	lsr	r11,0x2
8000baf2:	c1 1b       	rjmp	8000b914 <__avr32_f64_div+0x20>
8000baf4:	a3 79       	lsl	r9,0x3
8000baf6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bafa:	a3 78       	lsl	r8,0x3
8000bafc:	f3 e8 10 04 	or	r4,r9,r8
8000bb00:	c6 f0       	breq	8000bbde <__avr32_f64_div_res_subnormal+0xa0>
8000bb02:	f2 04 12 00 	clz	r4,r9
8000bb06:	c1 70       	breq	8000bb34 <__avr32_f64_div_round_subnormal+0xe0>
8000bb08:	c0 c3       	brcs	8000bb20 <__avr32_f64_div_round_subnormal+0xcc>
8000bb0a:	e8 05 11 20 	rsub	r5,r4,32
8000bb0e:	f2 04 09 49 	lsl	r9,r9,r4
8000bb12:	f0 05 0a 45 	lsr	r5,r8,r5
8000bb16:	0a 49       	or	r9,r5
8000bb18:	f0 04 09 48 	lsl	r8,r8,r4
8000bb1c:	08 16       	sub	r6,r4
8000bb1e:	c0 b8       	rjmp	8000bb34 <__avr32_f64_div_round_subnormal+0xe0>
8000bb20:	f0 04 12 00 	clz	r4,r8
8000bb24:	f9 b4 03 00 	movlo	r4,0
8000bb28:	f7 b4 02 e0 	subhs	r4,-32
8000bb2c:	f0 04 09 49 	lsl	r9,r8,r4
8000bb30:	30 08       	mov	r8,0
8000bb32:	08 16       	sub	r6,r4
8000bb34:	a3 88       	lsr	r8,0x2
8000bb36:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000bb3a:	a3 89       	lsr	r9,0x2
8000bb3c:	cf ca       	rjmp	8000b934 <__avr32_f64_div+0x40>

8000bb3e <__avr32_f64_div_res_subnormal>:
8000bb3e:	5c 37       	neg	r7
8000bb40:	2f f7       	sub	r7,-1
8000bb42:	f1 b7 04 c0 	satu	r7,0x6
8000bb46:	e0 47 00 20 	cp.w	r7,32
8000bb4a:	c1 54       	brge	8000bb74 <__avr32_f64_div_res_subnormal+0x36>
8000bb4c:	ee 06 11 20 	rsub	r6,r7,32
8000bb50:	e4 07 0a 42 	lsr	r2,r2,r7
8000bb54:	e6 06 09 4c 	lsl	r12,r3,r6
8000bb58:	18 42       	or	r2,r12
8000bb5a:	e6 07 0a 43 	lsr	r3,r3,r7
8000bb5e:	f4 06 09 41 	lsl	r1,r10,r6
8000bb62:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bb66:	f6 06 09 4c 	lsl	r12,r11,r6
8000bb6a:	18 4a       	or	r10,r12
8000bb6c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bb70:	30 00       	mov	r0,0
8000bb72:	c1 58       	rjmp	8000bb9c <__avr32_f64_div_res_subnormal+0x5e>
8000bb74:	ee 06 11 20 	rsub	r6,r7,32
8000bb78:	f9 b0 00 00 	moveq	r0,0
8000bb7c:	f9 bc 00 00 	moveq	r12,0
8000bb80:	c0 50       	breq	8000bb8a <__avr32_f64_div_res_subnormal+0x4c>
8000bb82:	f4 06 09 40 	lsl	r0,r10,r6
8000bb86:	f6 06 09 4c 	lsl	r12,r11,r6
8000bb8a:	e6 07 0a 42 	lsr	r2,r3,r7
8000bb8e:	30 03       	mov	r3,0
8000bb90:	f4 07 0a 41 	lsr	r1,r10,r7
8000bb94:	18 41       	or	r1,r12
8000bb96:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bb9a:	30 0b       	mov	r11,0
8000bb9c:	e0 12 ff 00 	andl	r2,0xff00
8000bba0:	e8 12 00 80 	orl	r2,0x80
8000bba4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bba8:	e4 09 07 46 	macu.d	r6,r2,r9
8000bbac:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bbb0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bbb4:	0c 05       	add	r5,r6
8000bbb6:	f0 07 00 48 	adc	r8,r8,r7
8000bbba:	5c 09       	acr	r9
8000bbbc:	30 07       	mov	r7,0
8000bbbe:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bbc2:	00 34       	cp.w	r4,r0
8000bbc4:	e2 05 13 00 	cpc	r5,r1
8000bbc8:	c4 6b       	rjmp	8000ba54 <__avr32_f64_div_round_subnormal>
8000bbca:	1c 9b       	mov	r11,lr
8000bbcc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bbd0:	30 0a       	mov	r10,0
8000bbd2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bbd6:	3f fb       	mov	r11,-1
8000bbd8:	30 0a       	mov	r10,0
8000bbda:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bbde:	f5 eb 10 04 	or	r4,r10,r11
8000bbe2:	c0 90       	breq	8000bbf4 <__avr32_f64_div_op1_zero>
8000bbe4:	1c 9b       	mov	r11,lr
8000bbe6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bbea:	ea 1b 7f f0 	orh	r11,0x7ff0
8000bbee:	30 0a       	mov	r10,0
8000bbf0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000bbf4 <__avr32_f64_div_op1_zero>:
8000bbf4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000bbf8:	ce f0       	breq	8000bbd6 <__avr32_f64_div_res_subnormal+0x98>
8000bbfa:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bbfe:	e0 44 07 ff 	cp.w	r4,2047
8000bc02:	ce 41       	brne	8000bbca <__avr32_f64_div_res_subnormal+0x8c>
8000bc04:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000bc08:	ce 10       	breq	8000bbca <__avr32_f64_div_res_subnormal+0x8c>
8000bc0a:	ce 6b       	rjmp	8000bbd6 <__avr32_f64_div_res_subnormal+0x98>

8000bc0c <__avr32_udiv64>:
8000bc0c:	d4 31       	pushm	r0-r7,lr
8000bc0e:	1a 97       	mov	r7,sp
8000bc10:	20 3d       	sub	sp,12
8000bc12:	10 9c       	mov	r12,r8
8000bc14:	12 9e       	mov	lr,r9
8000bc16:	14 93       	mov	r3,r10
8000bc18:	58 09       	cp.w	r9,0
8000bc1a:	e0 81 00 bd 	brne	8000bd94 <__avr32_udiv64+0x188>
8000bc1e:	16 38       	cp.w	r8,r11
8000bc20:	e0 88 00 40 	brls	8000bca0 <__avr32_udiv64+0x94>
8000bc24:	f0 08 12 00 	clz	r8,r8
8000bc28:	c0 d0       	breq	8000bc42 <__avr32_udiv64+0x36>
8000bc2a:	f6 08 09 4b 	lsl	r11,r11,r8
8000bc2e:	f0 09 11 20 	rsub	r9,r8,32
8000bc32:	f8 08 09 4c 	lsl	r12,r12,r8
8000bc36:	f4 09 0a 49 	lsr	r9,r10,r9
8000bc3a:	f4 08 09 43 	lsl	r3,r10,r8
8000bc3e:	f3 eb 10 0b 	or	r11,r9,r11
8000bc42:	f8 0e 16 10 	lsr	lr,r12,0x10
8000bc46:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000bc4a:	f6 0e 0d 00 	divu	r0,r11,lr
8000bc4e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bc52:	00 99       	mov	r9,r0
8000bc54:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bc58:	e0 0a 02 48 	mul	r8,r0,r10
8000bc5c:	10 3b       	cp.w	r11,r8
8000bc5e:	c0 a2       	brcc	8000bc72 <__avr32_udiv64+0x66>
8000bc60:	20 19       	sub	r9,1
8000bc62:	18 0b       	add	r11,r12
8000bc64:	18 3b       	cp.w	r11,r12
8000bc66:	c0 63       	brcs	8000bc72 <__avr32_udiv64+0x66>
8000bc68:	10 3b       	cp.w	r11,r8
8000bc6a:	f7 b9 03 01 	sublo	r9,1
8000bc6e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bc72:	f6 08 01 01 	sub	r1,r11,r8
8000bc76:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bc7a:	e2 0e 0d 00 	divu	r0,r1,lr
8000bc7e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bc82:	00 98       	mov	r8,r0
8000bc84:	e0 0a 02 4a 	mul	r10,r0,r10
8000bc88:	14 33       	cp.w	r3,r10
8000bc8a:	c0 82       	brcc	8000bc9a <__avr32_udiv64+0x8e>
8000bc8c:	20 18       	sub	r8,1
8000bc8e:	18 03       	add	r3,r12
8000bc90:	18 33       	cp.w	r3,r12
8000bc92:	c0 43       	brcs	8000bc9a <__avr32_udiv64+0x8e>
8000bc94:	14 33       	cp.w	r3,r10
8000bc96:	f7 b8 03 01 	sublo	r8,1
8000bc9a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000bc9e:	cd f8       	rjmp	8000be5c <__avr32_udiv64+0x250>
8000bca0:	58 08       	cp.w	r8,0
8000bca2:	c0 51       	brne	8000bcac <__avr32_udiv64+0xa0>
8000bca4:	30 19       	mov	r9,1
8000bca6:	f2 08 0d 08 	divu	r8,r9,r8
8000bcaa:	10 9c       	mov	r12,r8
8000bcac:	f8 06 12 00 	clz	r6,r12
8000bcb0:	c0 41       	brne	8000bcb8 <__avr32_udiv64+0xac>
8000bcb2:	18 1b       	sub	r11,r12
8000bcb4:	30 19       	mov	r9,1
8000bcb6:	c4 08       	rjmp	8000bd36 <__avr32_udiv64+0x12a>
8000bcb8:	ec 01 11 20 	rsub	r1,r6,32
8000bcbc:	f4 01 0a 49 	lsr	r9,r10,r1
8000bcc0:	f8 06 09 4c 	lsl	r12,r12,r6
8000bcc4:	f6 06 09 48 	lsl	r8,r11,r6
8000bcc8:	f6 01 0a 41 	lsr	r1,r11,r1
8000bccc:	f3 e8 10 08 	or	r8,r9,r8
8000bcd0:	f8 03 16 10 	lsr	r3,r12,0x10
8000bcd4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bcd8:	e2 03 0d 00 	divu	r0,r1,r3
8000bcdc:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bce0:	00 9e       	mov	lr,r0
8000bce2:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bce6:	e0 05 02 49 	mul	r9,r0,r5
8000bcea:	12 3b       	cp.w	r11,r9
8000bcec:	c0 a2       	brcc	8000bd00 <__avr32_udiv64+0xf4>
8000bcee:	20 1e       	sub	lr,1
8000bcf0:	18 0b       	add	r11,r12
8000bcf2:	18 3b       	cp.w	r11,r12
8000bcf4:	c0 63       	brcs	8000bd00 <__avr32_udiv64+0xf4>
8000bcf6:	12 3b       	cp.w	r11,r9
8000bcf8:	f7 be 03 01 	sublo	lr,1
8000bcfc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bd00:	12 1b       	sub	r11,r9
8000bd02:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000bd06:	f6 03 0d 02 	divu	r2,r11,r3
8000bd0a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000bd0e:	04 99       	mov	r9,r2
8000bd10:	e4 05 02 4b 	mul	r11,r2,r5
8000bd14:	16 38       	cp.w	r8,r11
8000bd16:	c0 a2       	brcc	8000bd2a <__avr32_udiv64+0x11e>
8000bd18:	20 19       	sub	r9,1
8000bd1a:	18 08       	add	r8,r12
8000bd1c:	18 38       	cp.w	r8,r12
8000bd1e:	c0 63       	brcs	8000bd2a <__avr32_udiv64+0x11e>
8000bd20:	16 38       	cp.w	r8,r11
8000bd22:	f7 b9 03 01 	sublo	r9,1
8000bd26:	f1 dc e3 08 	addcs	r8,r8,r12
8000bd2a:	f4 06 09 43 	lsl	r3,r10,r6
8000bd2e:	f0 0b 01 0b 	sub	r11,r8,r11
8000bd32:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000bd36:	f8 06 16 10 	lsr	r6,r12,0x10
8000bd3a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000bd3e:	f6 06 0d 00 	divu	r0,r11,r6
8000bd42:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bd46:	00 9a       	mov	r10,r0
8000bd48:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bd4c:	e0 0e 02 48 	mul	r8,r0,lr
8000bd50:	10 3b       	cp.w	r11,r8
8000bd52:	c0 a2       	brcc	8000bd66 <__avr32_udiv64+0x15a>
8000bd54:	20 1a       	sub	r10,1
8000bd56:	18 0b       	add	r11,r12
8000bd58:	18 3b       	cp.w	r11,r12
8000bd5a:	c0 63       	brcs	8000bd66 <__avr32_udiv64+0x15a>
8000bd5c:	10 3b       	cp.w	r11,r8
8000bd5e:	f7 ba 03 01 	sublo	r10,1
8000bd62:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bd66:	f6 08 01 01 	sub	r1,r11,r8
8000bd6a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bd6e:	e2 06 0d 00 	divu	r0,r1,r6
8000bd72:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bd76:	00 98       	mov	r8,r0
8000bd78:	e0 0e 02 4b 	mul	r11,r0,lr
8000bd7c:	16 33       	cp.w	r3,r11
8000bd7e:	c0 82       	brcc	8000bd8e <__avr32_udiv64+0x182>
8000bd80:	20 18       	sub	r8,1
8000bd82:	18 03       	add	r3,r12
8000bd84:	18 33       	cp.w	r3,r12
8000bd86:	c0 43       	brcs	8000bd8e <__avr32_udiv64+0x182>
8000bd88:	16 33       	cp.w	r3,r11
8000bd8a:	f7 b8 03 01 	sublo	r8,1
8000bd8e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bd92:	c6 98       	rjmp	8000be64 <__avr32_udiv64+0x258>
8000bd94:	16 39       	cp.w	r9,r11
8000bd96:	e0 8b 00 65 	brhi	8000be60 <__avr32_udiv64+0x254>
8000bd9a:	f2 09 12 00 	clz	r9,r9
8000bd9e:	c0 b1       	brne	8000bdb4 <__avr32_udiv64+0x1a8>
8000bda0:	10 3a       	cp.w	r10,r8
8000bda2:	5f 2a       	srhs	r10
8000bda4:	1c 3b       	cp.w	r11,lr
8000bda6:	5f b8       	srhi	r8
8000bda8:	10 4a       	or	r10,r8
8000bdaa:	f2 0a 18 00 	cp.b	r10,r9
8000bdae:	c5 90       	breq	8000be60 <__avr32_udiv64+0x254>
8000bdb0:	30 18       	mov	r8,1
8000bdb2:	c5 98       	rjmp	8000be64 <__avr32_udiv64+0x258>
8000bdb4:	f0 09 09 46 	lsl	r6,r8,r9
8000bdb8:	f2 03 11 20 	rsub	r3,r9,32
8000bdbc:	fc 09 09 4e 	lsl	lr,lr,r9
8000bdc0:	f0 03 0a 48 	lsr	r8,r8,r3
8000bdc4:	f6 09 09 4c 	lsl	r12,r11,r9
8000bdc8:	f4 03 0a 42 	lsr	r2,r10,r3
8000bdcc:	ef 46 ff f4 	st.w	r7[-12],r6
8000bdd0:	f6 03 0a 43 	lsr	r3,r11,r3
8000bdd4:	18 42       	or	r2,r12
8000bdd6:	f1 ee 10 0c 	or	r12,r8,lr
8000bdda:	f8 01 16 10 	lsr	r1,r12,0x10
8000bdde:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bde2:	e6 01 0d 04 	divu	r4,r3,r1
8000bde6:	e4 03 16 10 	lsr	r3,r2,0x10
8000bdea:	08 9e       	mov	lr,r4
8000bdec:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bdf0:	e8 06 02 48 	mul	r8,r4,r6
8000bdf4:	10 33       	cp.w	r3,r8
8000bdf6:	c0 a2       	brcc	8000be0a <__avr32_udiv64+0x1fe>
8000bdf8:	20 1e       	sub	lr,1
8000bdfa:	18 03       	add	r3,r12
8000bdfc:	18 33       	cp.w	r3,r12
8000bdfe:	c0 63       	brcs	8000be0a <__avr32_udiv64+0x1fe>
8000be00:	10 33       	cp.w	r3,r8
8000be02:	f7 be 03 01 	sublo	lr,1
8000be06:	e7 dc e3 03 	addcs	r3,r3,r12
8000be0a:	10 13       	sub	r3,r8
8000be0c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000be10:	e6 01 0d 00 	divu	r0,r3,r1
8000be14:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000be18:	00 98       	mov	r8,r0
8000be1a:	e0 06 02 46 	mul	r6,r0,r6
8000be1e:	0c 3b       	cp.w	r11,r6
8000be20:	c0 a2       	brcc	8000be34 <__avr32_udiv64+0x228>
8000be22:	20 18       	sub	r8,1
8000be24:	18 0b       	add	r11,r12
8000be26:	18 3b       	cp.w	r11,r12
8000be28:	c0 63       	brcs	8000be34 <__avr32_udiv64+0x228>
8000be2a:	0c 3b       	cp.w	r11,r6
8000be2c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000be30:	f7 b8 03 01 	sublo	r8,1
8000be34:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000be38:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000be3c:	0c 1b       	sub	r11,r6
8000be3e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000be42:	06 95       	mov	r5,r3
8000be44:	16 35       	cp.w	r5,r11
8000be46:	e0 8b 00 0a 	brhi	8000be5a <__avr32_udiv64+0x24e>
8000be4a:	5f 0b       	sreq	r11
8000be4c:	f4 09 09 49 	lsl	r9,r10,r9
8000be50:	12 32       	cp.w	r2,r9
8000be52:	5f b9       	srhi	r9
8000be54:	f7 e9 00 09 	and	r9,r11,r9
8000be58:	c0 60       	breq	8000be64 <__avr32_udiv64+0x258>
8000be5a:	20 18       	sub	r8,1
8000be5c:	30 09       	mov	r9,0
8000be5e:	c0 38       	rjmp	8000be64 <__avr32_udiv64+0x258>
8000be60:	30 09       	mov	r9,0
8000be62:	12 98       	mov	r8,r9
8000be64:	10 9a       	mov	r10,r8
8000be66:	12 93       	mov	r3,r9
8000be68:	10 92       	mov	r2,r8
8000be6a:	12 9b       	mov	r11,r9
8000be6c:	2f dd       	sub	sp,-12
8000be6e:	d8 32       	popm	r0-r7,pc

8000be70 <__avr32_umod64>:
8000be70:	d4 31       	pushm	r0-r7,lr
8000be72:	1a 97       	mov	r7,sp
8000be74:	20 3d       	sub	sp,12
8000be76:	10 9c       	mov	r12,r8
8000be78:	12 95       	mov	r5,r9
8000be7a:	14 9e       	mov	lr,r10
8000be7c:	16 91       	mov	r1,r11
8000be7e:	16 96       	mov	r6,r11
8000be80:	58 09       	cp.w	r9,0
8000be82:	e0 81 00 81 	brne	8000bf84 <__avr32_umod64+0x114>
8000be86:	16 38       	cp.w	r8,r11
8000be88:	e0 88 00 12 	brls	8000beac <__avr32_umod64+0x3c>
8000be8c:	f0 08 12 00 	clz	r8,r8
8000be90:	c4 e0       	breq	8000bf2c <__avr32_umod64+0xbc>
8000be92:	f6 08 09 46 	lsl	r6,r11,r8
8000be96:	f8 08 09 4c 	lsl	r12,r12,r8
8000be9a:	f0 0b 11 20 	rsub	r11,r8,32
8000be9e:	f4 08 09 4e 	lsl	lr,r10,r8
8000bea2:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000bea6:	f7 e6 10 06 	or	r6,r11,r6
8000beaa:	c4 18       	rjmp	8000bf2c <__avr32_umod64+0xbc>
8000beac:	58 08       	cp.w	r8,0
8000beae:	c0 51       	brne	8000beb8 <__avr32_umod64+0x48>
8000beb0:	30 19       	mov	r9,1
8000beb2:	f2 08 0d 08 	divu	r8,r9,r8
8000beb6:	10 9c       	mov	r12,r8
8000beb8:	f8 08 12 00 	clz	r8,r12
8000bebc:	c0 31       	brne	8000bec2 <__avr32_umod64+0x52>
8000bebe:	18 16       	sub	r6,r12
8000bec0:	c3 68       	rjmp	8000bf2c <__avr32_umod64+0xbc>
8000bec2:	f0 03 11 20 	rsub	r3,r8,32
8000bec6:	f4 03 0a 4b 	lsr	r11,r10,r3
8000beca:	f8 08 09 4c 	lsl	r12,r12,r8
8000bece:	ec 08 09 49 	lsl	r9,r6,r8
8000bed2:	ec 03 0a 43 	lsr	r3,r6,r3
8000bed6:	f7 e9 10 09 	or	r9,r11,r9
8000beda:	f8 05 16 10 	lsr	r5,r12,0x10
8000bede:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bee2:	e6 05 0d 02 	divu	r2,r3,r5
8000bee6:	f2 0e 16 10 	lsr	lr,r9,0x10
8000beea:	ec 02 02 4b 	mul	r11,r6,r2
8000beee:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000bef2:	16 3e       	cp.w	lr,r11
8000bef4:	c0 72       	brcc	8000bf02 <__avr32_umod64+0x92>
8000bef6:	18 0e       	add	lr,r12
8000bef8:	18 3e       	cp.w	lr,r12
8000befa:	c0 43       	brcs	8000bf02 <__avr32_umod64+0x92>
8000befc:	16 3e       	cp.w	lr,r11
8000befe:	fd dc e3 0e 	addcs	lr,lr,r12
8000bf02:	fc 0b 01 03 	sub	r3,lr,r11
8000bf06:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000bf0a:	e6 05 0d 02 	divu	r2,r3,r5
8000bf0e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bf12:	a5 36       	mul	r6,r2
8000bf14:	0c 39       	cp.w	r9,r6
8000bf16:	c0 72       	brcc	8000bf24 <__avr32_umod64+0xb4>
8000bf18:	18 09       	add	r9,r12
8000bf1a:	18 39       	cp.w	r9,r12
8000bf1c:	c0 43       	brcs	8000bf24 <__avr32_umod64+0xb4>
8000bf1e:	0c 39       	cp.w	r9,r6
8000bf20:	f3 dc e3 09 	addcs	r9,r9,r12
8000bf24:	f2 06 01 06 	sub	r6,r9,r6
8000bf28:	f4 08 09 4e 	lsl	lr,r10,r8
8000bf2c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000bf30:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bf34:	ec 0a 0d 02 	divu	r2,r6,r10
8000bf38:	fc 09 16 10 	lsr	r9,lr,0x10
8000bf3c:	ea 02 02 4b 	mul	r11,r5,r2
8000bf40:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000bf44:	16 39       	cp.w	r9,r11
8000bf46:	c0 72       	brcc	8000bf54 <__avr32_umod64+0xe4>
8000bf48:	18 09       	add	r9,r12
8000bf4a:	18 39       	cp.w	r9,r12
8000bf4c:	c0 43       	brcs	8000bf54 <__avr32_umod64+0xe4>
8000bf4e:	16 39       	cp.w	r9,r11
8000bf50:	f3 dc e3 09 	addcs	r9,r9,r12
8000bf54:	f2 0b 01 0b 	sub	r11,r9,r11
8000bf58:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bf5c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000bf60:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000bf64:	ea 0a 02 4a 	mul	r10,r5,r10
8000bf68:	14 3e       	cp.w	lr,r10
8000bf6a:	c0 72       	brcc	8000bf78 <__avr32_umod64+0x108>
8000bf6c:	18 0e       	add	lr,r12
8000bf6e:	18 3e       	cp.w	lr,r12
8000bf70:	c0 43       	brcs	8000bf78 <__avr32_umod64+0x108>
8000bf72:	14 3e       	cp.w	lr,r10
8000bf74:	fd dc e3 0e 	addcs	lr,lr,r12
8000bf78:	fc 0a 01 0a 	sub	r10,lr,r10
8000bf7c:	30 0b       	mov	r11,0
8000bf7e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000bf82:	c7 b8       	rjmp	8000c078 <__avr32_umod64+0x208>
8000bf84:	16 39       	cp.w	r9,r11
8000bf86:	e0 8b 00 79 	brhi	8000c078 <__avr32_umod64+0x208>
8000bf8a:	f2 09 12 00 	clz	r9,r9
8000bf8e:	c1 21       	brne	8000bfb2 <__avr32_umod64+0x142>
8000bf90:	10 3a       	cp.w	r10,r8
8000bf92:	5f 2b       	srhs	r11
8000bf94:	0a 31       	cp.w	r1,r5
8000bf96:	5f ba       	srhi	r10
8000bf98:	f7 ea 10 0a 	or	r10,r11,r10
8000bf9c:	f2 0a 18 00 	cp.b	r10,r9
8000bfa0:	c0 60       	breq	8000bfac <__avr32_umod64+0x13c>
8000bfa2:	fc 08 01 0c 	sub	r12,lr,r8
8000bfa6:	e2 05 01 46 	sbc	r6,r1,r5
8000bfaa:	18 9e       	mov	lr,r12
8000bfac:	0c 9b       	mov	r11,r6
8000bfae:	1c 9a       	mov	r10,lr
8000bfb0:	c6 48       	rjmp	8000c078 <__avr32_umod64+0x208>
8000bfb2:	ea 09 09 4c 	lsl	r12,r5,r9
8000bfb6:	f2 06 11 20 	rsub	r6,r9,32
8000bfba:	f6 09 09 4b 	lsl	r11,r11,r9
8000bfbe:	f0 09 09 42 	lsl	r2,r8,r9
8000bfc2:	ef 46 ff f4 	st.w	r7[-12],r6
8000bfc6:	f0 06 0a 48 	lsr	r8,r8,r6
8000bfca:	18 48       	or	r8,r12
8000bfcc:	e2 06 0a 4c 	lsr	r12,r1,r6
8000bfd0:	f4 09 09 43 	lsl	r3,r10,r9
8000bfd4:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000bfd8:	f4 06 0a 4a 	lsr	r10,r10,r6
8000bfdc:	16 4a       	or	r10,r11
8000bfde:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bfe2:	f8 0b 0d 04 	divu	r4,r12,r11
8000bfe6:	f4 0c 16 10 	lsr	r12,r10,0x10
8000bfea:	08 91       	mov	r1,r4
8000bfec:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000bff0:	e8 0e 02 46 	mul	r6,r4,lr
8000bff4:	0c 3c       	cp.w	r12,r6
8000bff6:	c0 a2       	brcc	8000c00a <__avr32_umod64+0x19a>
8000bff8:	20 11       	sub	r1,1
8000bffa:	10 0c       	add	r12,r8
8000bffc:	10 3c       	cp.w	r12,r8
8000bffe:	c0 63       	brcs	8000c00a <__avr32_umod64+0x19a>
8000c000:	0c 3c       	cp.w	r12,r6
8000c002:	f7 b1 03 01 	sublo	r1,1
8000c006:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c00a:	0c 1c       	sub	r12,r6
8000c00c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c010:	f8 0b 0d 04 	divu	r4,r12,r11
8000c014:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c018:	08 96       	mov	r6,r4
8000c01a:	e8 0e 02 4e 	mul	lr,r4,lr
8000c01e:	1c 3b       	cp.w	r11,lr
8000c020:	c0 a2       	brcc	8000c034 <__avr32_umod64+0x1c4>
8000c022:	20 16       	sub	r6,1
8000c024:	10 0b       	add	r11,r8
8000c026:	10 3b       	cp.w	r11,r8
8000c028:	c0 63       	brcs	8000c034 <__avr32_umod64+0x1c4>
8000c02a:	1c 3b       	cp.w	r11,lr
8000c02c:	f7 b6 03 01 	sublo	r6,1
8000c030:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c034:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c038:	1c 1b       	sub	r11,lr
8000c03a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c03e:	00 9e       	mov	lr,r0
8000c040:	02 9c       	mov	r12,r1
8000c042:	16 3c       	cp.w	r12,r11
8000c044:	e0 8b 00 08 	brhi	8000c054 <__avr32_umod64+0x1e4>
8000c048:	5f 06       	sreq	r6
8000c04a:	06 30       	cp.w	r0,r3
8000c04c:	5f ba       	srhi	r10
8000c04e:	ed ea 00 0a 	and	r10,r6,r10
8000c052:	c0 60       	breq	8000c05e <__avr32_umod64+0x1ee>
8000c054:	fc 02 01 04 	sub	r4,lr,r2
8000c058:	f8 08 01 4c 	sbc	r12,r12,r8
8000c05c:	08 9e       	mov	lr,r4
8000c05e:	e6 0e 01 0a 	sub	r10,r3,lr
8000c062:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c066:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c06a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c06e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c072:	f8 01 09 4c 	lsl	r12,r12,r1
8000c076:	18 4a       	or	r10,r12
8000c078:	2f dd       	sub	sp,-12
8000c07a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c200 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c200:	c0 08       	rjmp	8000c200 <_evba>
	...

8000c204 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c204:	c0 08       	rjmp	8000c204 <_handle_TLB_Multiple_Hit>
	...

8000c208 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c208:	c0 08       	rjmp	8000c208 <_handle_Bus_Error_Data_Fetch>
	...

8000c20c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c20c:	c0 08       	rjmp	8000c20c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c210 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c210:	c0 08       	rjmp	8000c210 <_handle_NMI>
	...

8000c214 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c214:	c0 08       	rjmp	8000c214 <_handle_Instruction_Address>
	...

8000c218 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c218:	c0 08       	rjmp	8000c218 <_handle_ITLB_Protection>
	...

8000c21c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c21c:	c0 08       	rjmp	8000c21c <_handle_Breakpoint>
	...

8000c220 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c220:	c0 08       	rjmp	8000c220 <_handle_Illegal_Opcode>
	...

8000c224 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c224:	c0 08       	rjmp	8000c224 <_handle_Unimplemented_Instruction>
	...

8000c228 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c228:	c0 08       	rjmp	8000c228 <_handle_Privilege_Violation>
	...

8000c22c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c22c:	c0 08       	rjmp	8000c22c <_handle_Floating_Point>
	...

8000c230 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c230:	c0 08       	rjmp	8000c230 <_handle_Coprocessor_Absent>
	...

8000c234 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c234:	c0 08       	rjmp	8000c234 <_handle_Data_Address_Read>
	...

8000c238 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c238:	c0 08       	rjmp	8000c238 <_handle_Data_Address_Write>
	...

8000c23c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c23c:	c0 08       	rjmp	8000c23c <_handle_DTLB_Protection_Read>
	...

8000c240 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c240:	c0 08       	rjmp	8000c240 <_handle_DTLB_Protection_Write>
	...

8000c244 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c244:	c0 08       	rjmp	8000c244 <_handle_DTLB_Modified>
	...

8000c250 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c250:	c0 08       	rjmp	8000c250 <_handle_ITLB_Miss>
	...

8000c260 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c260:	c0 08       	rjmp	8000c260 <_handle_DTLB_Miss_Read>
	...

8000c270 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c270:	c0 08       	rjmp	8000c270 <_handle_DTLB_Miss_Write>
	...

8000c300 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c300:	fe cf 71 b8 	sub	pc,pc,29112

8000c304 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c304:	30 0c       	mov	r12,0
8000c306:	fe b0 c3 95 	rcall	80004a30 <_get_interrupt_handler>
8000c30a:	58 0c       	cp.w	r12,0
8000c30c:	f8 0f 17 10 	movne	pc,r12
8000c310:	d6 03       	rete

8000c312 <_int1>:
8000c312:	30 1c       	mov	r12,1
8000c314:	fe b0 c3 8e 	rcall	80004a30 <_get_interrupt_handler>
8000c318:	58 0c       	cp.w	r12,0
8000c31a:	f8 0f 17 10 	movne	pc,r12
8000c31e:	d6 03       	rete

8000c320 <_int2>:
8000c320:	30 2c       	mov	r12,2
8000c322:	fe b0 c3 87 	rcall	80004a30 <_get_interrupt_handler>
8000c326:	58 0c       	cp.w	r12,0
8000c328:	f8 0f 17 10 	movne	pc,r12
8000c32c:	d6 03       	rete

8000c32e <_int3>:
8000c32e:	30 3c       	mov	r12,3
8000c330:	fe b0 c3 80 	rcall	80004a30 <_get_interrupt_handler>
8000c334:	58 0c       	cp.w	r12,0
8000c336:	f8 0f 17 10 	movne	pc,r12
8000c33a:	d6 03       	rete

8000c33c <ipr_val>:
8000c33c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c34c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c35c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c36c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c37c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c38c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c39c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c3fc:	d7 03 d7 03                                         ....
