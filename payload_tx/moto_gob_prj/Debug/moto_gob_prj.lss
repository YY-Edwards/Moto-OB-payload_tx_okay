
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a274  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000c400  8000c400  0000c800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001760  8000c600  8000c600  0000ca00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000a34  00000008  8000dd60  0000e408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a3c  8000e794  0000ee3c  2**0
                  ALLOC
  8 .bss          000036d8  00000a40  00000a40  00000000  2**2
                  ALLOC
  9 .heap         00012ee8  00004118  00004118  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000ee3c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00001140  00000000  00000000  0000ee70  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 000024b9  00000000  00000000  0000ffb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0002829e  00000000  00000000  00012469  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000067e5  00000000  00000000  0003a707  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000c1dc  00000000  00000000  00040eec  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002d28  00000000  00000000  0004d0c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006cb7  00000000  00000000  0004fdf0  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000ca5f  00000000  00000000  00056aa7  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 20 .debug_ranges 00001228  00000000  00000000  00063508  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 96 a8 	sub	pc,pc,-26968

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf b6 ac 	sub	pc,pc,-18772

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d a8       	ld.ub	r8,r6[0x2]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12
8000202e:	d7 03       	nop

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 58       	eor	r8,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	21 08       	sub	r8,16
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 44       	sub	r4,-124
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	29 2c       	sub	r12,-110
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	41 28       	lddsp	r8,sp[0x48]
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	c6 00       	breq	80002146 <FD_request_func+0x2>
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	20 94       	sub	r4,9
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	60 cc       	ld.w	r12,r0[0x30]
80002090:	00 00       	add	r0,r0
80002092:	0a 4c       	or	r12,r5

80002094 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002094:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002096:	f0 1f 00 17 	mcall	800020f0 <app_cfg+0x5c>
8000209a:	49 78       	lddpc	r8,800020f4 <app_cfg+0x60>
8000209c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000209e:	49 76       	lddpc	r6,800020f8 <app_cfg+0x64>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020a0:	49 74       	lddpc	r4,800020fc <app_cfg+0x68>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020a2:	30 40       	mov	r0,4
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020a4:	30 31       	mov	r1,3
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020a6:	30 22       	mov	r2,2
					//xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020a8:	30 13       	mov	r3,1
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020aa:	10 97       	mov	r7,r8
800020ac:	e0 65 0f a0 	mov	r5,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
800020b0:	6c 08       	ld.w	r8,r6[0x0]
800020b2:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800020b6:	58 38       	cp.w	r8,3
800020b8:	c1 71       	brne	800020e6 <app_cfg+0x52>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
800020ba:	68 08       	ld.w	r8,r4[0x0]
800020bc:	58 08       	cp.w	r8,0
800020be:	c0 51       	brne	800020c8 <app_cfg+0x34>
				{
					//xcmp_data_session();
					//xcmp_audio_route_mic();
					//xcmp_button_config();
					xcmp_audio_route_speaker();
800020c0:	f0 1f 00 10 	mcall	80002100 <app_cfg+0x6c>
					//xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
800020c4:	89 03       	st.w	r4[0x0],r3
800020c6:	c1 08       	rjmp	800020e6 <app_cfg+0x52>
				}
				else if(isAudioRouting == 1)
800020c8:	58 18       	cp.w	r8,1
800020ca:	c0 31       	brne	800020d0 <app_cfg+0x3c>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
800020cc:	89 02       	st.w	r4[0x0],r2
800020ce:	c0 c8       	rjmp	800020e6 <app_cfg+0x52>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
800020d0:	58 28       	cp.w	r8,2
800020d2:	c0 31       	brne	800020d8 <app_cfg+0x44>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
800020d4:	89 01       	st.w	r4[0x0],r1
800020d6:	c0 88       	rjmp	800020e6 <app_cfg+0x52>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
800020d8:	58 38       	cp.w	r8,3
800020da:	e9 f0 0a 00 	st.weq	r4[0x0],r0
					
				}
				else
				{
					isAudioRouting++;
800020de:	f7 b8 01 ff 	subne	r8,-1
800020e2:	e9 f8 1a 00 	st.wne	r4[0x0],r8
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800020e6:	0a 9b       	mov	r11,r5
800020e8:	0e 9c       	mov	r12,r7
800020ea:	f0 1f 00 07 	mcall	80002104 <app_cfg+0x70>
	}
800020ee:	ce 1b       	rjmp	800020b0 <app_cfg+0x1c>
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	5e 04       	reteq	r4
800020f4:	00 00       	add	r0,r0
800020f6:	0a 48       	or	r8,r5
800020f8:	00 00       	add	r0,r0
800020fa:	0d a8       	ld.ub	r8,r6[0x2]
800020fc:	00 00       	add	r0,r0
800020fe:	0a 44       	or	r4,r5
80002100:	80 00       	ld.sh	r0,r0[0x0]
80002102:	41 7c       	lddsp	r12,sp[0x5c]
80002104:	80 00       	ld.sh	r0,r0[0x0]
80002106:	5f 6c       	srmi	r12

80002108 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002108:	d4 01       	pushm	lr
  log("R");
8000210a:	48 3c       	lddpc	r12,80002114 <app_payload_tx_proc+0xc>
8000210c:	f0 1f 00 03 	mcall	80002118 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002110:	d8 02       	popm	pc
80002112:	00 00       	add	r0,r0
80002114:	80 00       	ld.sh	r0,r0[0x0]
80002116:	c6 08       	rjmp	800021d6 <EnOB_reply_func+0x6a>
80002118:	80 00       	ld.sh	r0,r0[0x0]
8000211a:	64 90       	ld.w	r0,r2[0x24]

8000211c <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
8000211c:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
8000211e:	48 3c       	lddpc	r12,80002128 <FD_brdcst_func+0xc>
80002120:	f0 1f 00 03 	mcall	8000212c <FD_brdcst_func+0x10>
	
}
80002124:	d8 02       	popm	pc
80002126:	00 00       	add	r0,r0
80002128:	80 00       	ld.sh	r0,r0[0x0]
8000212a:	c6 0c       	rcall	800021ea <SingleDetection_brdcst_func+0xe>
8000212c:	80 00       	ld.sh	r0,r0[0x0]
8000212e:	64 90       	ld.w	r0,r2[0x24]

80002130 <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
80002130:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
80002132:	48 3c       	lddpc	r12,8000213c <FD_reply_func+0xc>
80002134:	f0 1f 00 03 	mcall	80002140 <FD_reply_func+0x10>
	
	
}
80002138:	d8 02       	popm	pc
8000213a:	00 00       	add	r0,r0
8000213c:	80 00       	ld.sh	r0,r0[0x0]
8000213e:	c6 2c       	rcall	80002202 <SingleDetection_brdcst_func+0x26>
80002140:	80 00       	ld.sh	r0,r0[0x0]
80002142:	64 90       	ld.w	r0,r2[0x24]

80002144 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002144:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002146:	48 3c       	lddpc	r12,80002150 <FD_request_func+0xc>
80002148:	f0 1f 00 03 	mcall	80002154 <FD_request_func+0x10>
	
	
}
8000214c:	d8 02       	popm	pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	c6 48       	rjmp	8000221a <SingleDetection_brdcst_func+0x3e>
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	64 90       	ld.w	r0,r2[0x24]

80002158 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002158:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
8000215a:	48 3c       	lddpc	r12,80002164 <EnOB_brdcst_func+0xc>
8000215c:	f0 1f 00 03 	mcall	80002168 <EnOB_brdcst_func+0x10>
}
80002160:	d8 02       	popm	pc
80002162:	00 00       	add	r0,r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	c6 64       	brge	80002232 <ButtonConfig_brdcst_func+0x16>
80002168:	80 00       	ld.sh	r0,r0[0x0]
8000216a:	64 90       	ld.w	r0,r2[0x24]

8000216c <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
8000216c:	eb cd 40 80 	pushm	r7,lr
80002170:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
80002172:	19 a9       	ld.ub	r9,r12[0x2]
80002174:	30 08       	mov	r8,0
80002176:	f0 09 18 00 	cp.b	r9,r8
8000217a:	c1 91       	brne	800021ac <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
8000217c:	19 b8       	ld.ub	r8,r12[0x3]
8000217e:	30 19       	mov	r9,1
80002180:	f2 08 18 00 	cp.b	r8,r9
80002184:	c0 61       	brne	80002190 <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002186:	49 0c       	lddpc	r12,800021c4 <EnOB_reply_func+0x58>
80002188:	f0 1f 00 10 	mcall	800021c8 <EnOB_reply_func+0x5c>
8000218c:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
80002190:	58 08       	cp.w	r8,0
80002192:	c0 61       	brne	8000219e <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002194:	48 ec       	lddpc	r12,800021cc <EnOB_reply_func+0x60>
80002196:	f0 1f 00 0d 	mcall	800021c8 <EnOB_reply_func+0x5c>
8000219a:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000219e:	1a d8       	st.w	--sp,r8
800021a0:	48 cc       	lddpc	r12,800021d0 <EnOB_reply_func+0x64>
800021a2:	f0 1f 00 0a 	mcall	800021c8 <EnOB_reply_func+0x5c>
800021a6:	2f fd       	sub	sp,-4
800021a8:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
800021ac:	48 ac       	lddpc	r12,800021d4 <EnOB_reply_func+0x68>
800021ae:	f0 1f 00 07 	mcall	800021c8 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
800021b2:	0f a8       	ld.ub	r8,r7[0x2]
800021b4:	1a d8       	st.w	--sp,r8
800021b6:	48 9c       	lddpc	r12,800021d8 <EnOB_reply_func+0x6c>
800021b8:	f0 1f 00 04 	mcall	800021c8 <EnOB_reply_func+0x5c>
800021bc:	2f fd       	sub	sp,-4
800021be:	e3 cd 80 80 	ldm	sp++,r7,pc
800021c2:	00 00       	add	r0,r0
800021c4:	80 00       	ld.sh	r0,r0[0x0]
800021c6:	c6 7c       	rcall	80002294 <ButtonConfig_brdcst_func+0x78>
800021c8:	80 00       	ld.sh	r0,r0[0x0]
800021ca:	64 90       	ld.w	r0,r2[0x24]
800021cc:	80 00       	ld.sh	r0,r0[0x0]
800021ce:	c6 94       	brge	800022a0 <ButtonConfig_brdcst_func+0x84>
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	c6 a8       	rjmp	800022a6 <ButtonConfig_brdcst_func+0x8a>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	c6 c0       	breq	800022ae <ButtonConfig_brdcst_func+0x92>
800021d8:	80 00       	ld.sh	r0,r0[0x0]
800021da:	c6 dc       	rcall	800022b4 <ButtonConfig_brdcst_func+0x98>

800021dc <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
800021dc:	eb cd 40 80 	pushm	r7,lr
800021e0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
800021e2:	19 a9       	ld.ub	r9,r12[0x2]
800021e4:	31 18       	mov	r8,17
800021e6:	f0 09 18 00 	cp.b	r9,r8
800021ea:	c0 61       	brne	800021f6 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021ec:	48 8c       	lddpc	r12,8000220c <SingleDetection_brdcst_func+0x30>
800021ee:	f0 1f 00 09 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
800021f2:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
800021f6:	48 8c       	lddpc	r12,80002214 <SingleDetection_brdcst_func+0x38>
800021f8:	f0 1f 00 06 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
800021fc:	0f a8       	ld.ub	r8,r7[0x2]
800021fe:	1a d8       	st.w	--sp,r8
80002200:	48 6c       	lddpc	r12,80002218 <SingleDetection_brdcst_func+0x3c>
80002202:	f0 1f 00 04 	mcall	80002210 <SingleDetection_brdcst_func+0x34>
80002206:	2f fd       	sub	sp,-4
80002208:	e3 cd 80 80 	ldm	sp++,r7,pc
8000220c:	80 00       	ld.sh	r0,r0[0x0]
8000220e:	c6 f4       	brge	800022ec <ButtonConfig_brdcst_func+0xd0>
80002210:	80 00       	ld.sh	r0,r0[0x0]
80002212:	64 90       	ld.w	r0,r2[0x24]
80002214:	80 00       	ld.sh	r0,r0[0x0]
80002216:	c7 08       	rjmp	800022f6 <ButtonConfig_brdcst_func+0xda>
80002218:	80 00       	ld.sh	r0,r0[0x0]
8000221a:	c7 18       	rjmp	800022fc <Phyuserinput_brdcst_func+0x4>

8000221c <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
8000221c:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
8000221e:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
80002222:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
80002224:	4a bc       	lddpc	r12,800022d0 <ButtonConfig_brdcst_func+0xb4>
80002226:	f0 1f 00 2c 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
8000222a:	0f 88       	ld.ub	r8,r7[0x0]
8000222c:	1a d8       	st.w	--sp,r8
8000222e:	4a bc       	lddpc	r12,800022d8 <ButtonConfig_brdcst_func+0xbc>
80002230:	f0 1f 00 29 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
80002234:	1a d5       	st.w	--sp,r5
80002236:	4a ac       	lddpc	r12,800022dc <ButtonConfig_brdcst_func+0xc0>
80002238:	f0 1f 00 27 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
8000223c:	0f a8       	ld.ub	r8,r7[0x2]
8000223e:	1a d8       	st.w	--sp,r8
80002240:	4a 8c       	lddpc	r12,800022e0 <ButtonConfig_brdcst_func+0xc4>
80002242:	f0 1f 00 25 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
80002246:	2f dd       	sub	sp,-12
80002248:	58 05       	cp.w	r5,0
8000224a:	c4 10       	breq	800022cc <ButtonConfig_brdcst_func+0xb0>
8000224c:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
8000224e:	4a 64       	lddpc	r4,800022e4 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002250:	4a 63       	lddpc	r3,800022e8 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002252:	4a 72       	lddpc	r2,800022ec <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002254:	4a 71       	lddpc	r1,800022f0 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002256:	4a 80       	lddpc	r0,800022f4 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002258:	0f b9       	ld.ub	r9,r7[0x3]
8000225a:	0f c8       	ld.ub	r8,r7[0x4]
8000225c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002260:	1a d8       	st.w	--sp,r8
80002262:	1a d6       	st.w	--sp,r6
80002264:	08 9c       	mov	r12,r4
80002266:	f0 1f 00 1c 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
8000226a:	0f d9       	ld.ub	r9,r7[0x5]
8000226c:	0f e8       	ld.ub	r8,r7[0x6]
8000226e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002272:	1a d8       	st.w	--sp,r8
80002274:	1a d6       	st.w	--sp,r6
80002276:	06 9c       	mov	r12,r3
80002278:	f0 1f 00 17 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000227c:	0f f9       	ld.ub	r9,r7[0x7]
8000227e:	ef 38 00 08 	ld.ub	r8,r7[8]
80002282:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002286:	1a d8       	st.w	--sp,r8
80002288:	1a d6       	st.w	--sp,r6
8000228a:	04 9c       	mov	r12,r2
8000228c:	f0 1f 00 12 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002290:	ef 39 00 09 	ld.ub	r9,r7[9]
80002294:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002298:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000229c:	1a d8       	st.w	--sp,r8
8000229e:	1a d6       	st.w	--sp,r6
800022a0:	02 9c       	mov	r12,r1
800022a2:	f0 1f 00 0d 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800022a6:	2f 8d       	sub	sp,-32
800022a8:	ef 39 00 0b 	ld.ub	r9,r7[11]
800022ac:	ef 38 00 0c 	ld.ub	r8,r7[12]
800022b0:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800022b4:	1a d8       	st.w	--sp,r8
800022b6:	1a d6       	st.w	--sp,r6
800022b8:	00 9c       	mov	r12,r0
800022ba:	f0 1f 00 07 	mcall	800022d4 <ButtonConfig_brdcst_func+0xb8>
800022be:	2f f6       	sub	r6,-1
800022c0:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
800022c2:	2f ed       	sub	sp,-8
800022c4:	ec 05 18 00 	cp.b	r5,r6
800022c8:	fe 9b ff c8 	brhi	80002258 <ButtonConfig_brdcst_func+0x3c>
800022cc:	d8 32       	popm	r0-r7,pc
800022ce:	00 00       	add	r0,r0
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	c7 30       	breq	800023b8 <DataSession_brdcst_func+0x4>
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	64 90       	ld.w	r0,r2[0x24]
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	c7 50       	breq	800023c4 <DataSession_brdcst_func+0x10>
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	c7 64       	brge	800023ca <DataSession_brdcst_func+0x16>
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	c7 7c       	rcall	800023d0 <DataSession_brdcst_func+0x1c>
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	c7 9c       	rcall	800023d8 <DataSession_brdcst_func+0x24>
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	c7 c4       	brge	800023e2 <DataSession_brdcst_func+0x2e>
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	c7 ec       	rcall	800023ea <DataSession_brdcst_func+0x36>
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	c8 10       	breq	800021f4 <SingleDetection_brdcst_func+0x18>
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	c8 38       	rjmp	800023fc <DataSession_brdcst_func+0x48>

800022f8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800022f8:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
800022fc:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
800022fe:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
80002300:	19 c7       	ld.ub	r7,r12[0x4]
80002302:	19 d8       	ld.ub	r8,r12[0x5]
80002304:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002308:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
8000230a:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
8000230c:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
80002310:	49 0c       	lddpc	r12,80002350 <Phyuserinput_brdcst_func+0x58>
80002312:	f0 1f 00 11 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
80002316:	1a d6       	st.w	--sp,r6
80002318:	49 0c       	lddpc	r12,80002358 <Phyuserinput_brdcst_func+0x60>
8000231a:	f0 1f 00 0f 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
8000231e:	1a d5       	st.w	--sp,r5
80002320:	48 fc       	lddpc	r12,8000235c <Phyuserinput_brdcst_func+0x64>
80002322:	f0 1f 00 0d 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
80002326:	5c 77       	castu.h	r7
80002328:	1a d7       	st.w	--sp,r7
8000232a:	48 ec       	lddpc	r12,80002360 <Phyuserinput_brdcst_func+0x68>
8000232c:	f0 1f 00 0a 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
80002330:	1a d4       	st.w	--sp,r4
80002332:	48 dc       	lddpc	r12,80002364 <Phyuserinput_brdcst_func+0x6c>
80002334:	f0 1f 00 08 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
80002338:	1a d3       	st.w	--sp,r3
8000233a:	48 cc       	lddpc	r12,80002368 <Phyuserinput_brdcst_func+0x70>
8000233c:	f0 1f 00 06 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
80002340:	1a d2       	st.w	--sp,r2
80002342:	48 bc       	lddpc	r12,8000236c <Phyuserinput_brdcst_func+0x74>
80002344:	f0 1f 00 04 	mcall	80002354 <Phyuserinput_brdcst_func+0x5c>
80002348:	2f ad       	sub	sp,-24
	
	
	
	
	
}
8000234a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000234e:	00 00       	add	r0,r0
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	c8 5c       	rcall	8000245c <DataSession_reply_func+0x24>
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	64 90       	ld.w	r0,r2[0x24]
80002358:	80 00       	ld.sh	r0,r0[0x0]
8000235a:	c8 80       	breq	8000226a <ButtonConfig_brdcst_func+0x4e>
8000235c:	80 00       	ld.sh	r0,r0[0x0]
8000235e:	c8 98       	rjmp	80002470 <DataSession_reply_func+0x38>
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	c8 ac       	rcall	80002476 <DataSession_reply_func+0x3e>
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	c8 c0       	breq	8000227e <ButtonConfig_brdcst_func+0x62>
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	c8 d4       	brge	80002284 <ButtonConfig_brdcst_func+0x68>
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	c8 f4       	brge	8000228c <ButtonConfig_brdcst_func+0x70>

80002370 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002370:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002374:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002378:	0f 89       	ld.ub	r9,r7[0x0]
8000237a:	30 08       	mov	r8,0
8000237c:	f0 09 18 00 	cp.b	r9,r8
80002380:	c0 c1       	brne	80002398 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
80002382:	48 9c       	lddpc	r12,800023a4 <ButtonConfig_reply_func+0x34>
80002384:	f0 1f 00 09 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 8c       	lddpc	r12,800023ac <ButtonConfig_reply_func+0x3c>
8000238e:	f0 1f 00 07 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
80002392:	2f fd       	sub	sp,-4
80002394:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002398:	48 6c       	lddpc	r12,800023b0 <ButtonConfig_reply_func+0x40>
8000239a:	f0 1f 00 04 	mcall	800023a8 <ButtonConfig_reply_func+0x38>
8000239e:	e3 cd 80 80 	ldm	sp++,r7,pc
800023a2:	00 00       	add	r0,r0
800023a4:	80 00       	ld.sh	r0,r0[0x0]
800023a6:	c9 14       	brge	800022c8 <ButtonConfig_brdcst_func+0xac>
800023a8:	80 00       	ld.sh	r0,r0[0x0]
800023aa:	64 90       	ld.w	r0,r2[0x24]
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	c7 50       	breq	80002498 <TransmitControl_brdcst_func+0x8>
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	c9 2c       	rcall	800024d6 <TransmitControl_brdcst_func+0x46>

800023b4 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800023b4:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800023b6:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
800023ba:	0d 88       	ld.ub	r8,r6[0x0]
800023bc:	32 49       	mov	r9,36
800023be:	f2 08 18 00 	cp.b	r8,r9
800023c2:	c2 91       	brne	80002414 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800023c4:	49 7c       	lddpc	r12,80002420 <DataSession_brdcst_func+0x6c>
800023c6:	f0 1f 00 18 	mcall	80002424 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800023ca:	0d a5       	ld.ub	r5,r6[0x2]
800023cc:	0d b8       	ld.ub	r8,r6[0x3]
800023ce:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800023d2:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800023d4:	0d 98       	ld.ub	r8,r6[0x1]
800023d6:	1a d8       	st.w	--sp,r8
800023d8:	49 4c       	lddpc	r12,80002428 <DataSession_brdcst_func+0x74>
800023da:	f0 1f 00 13 	mcall	80002424 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
800023de:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
800023e2:	1a d8       	st.w	--sp,r8
800023e4:	49 2c       	lddpc	r12,8000242c <DataSession_brdcst_func+0x78>
800023e6:	f0 1f 00 10 	mcall	80002424 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
800023ea:	2f ed       	sub	sp,-8
800023ec:	58 05       	cp.w	r5,0
800023ee:	c1 80       	breq	8000241e <DataSession_brdcst_func+0x6a>
800023f0:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
800023f2:	49 04       	lddpc	r4,80002430 <DataSession_brdcst_func+0x7c>
800023f4:	ec 07 00 08 	add	r8,r6,r7
800023f8:	11 c8       	ld.ub	r8,r8[0x4]
800023fa:	1a d8       	st.w	--sp,r8
800023fc:	1a d7       	st.w	--sp,r7
800023fe:	08 9c       	mov	r12,r4
80002400:	f0 1f 00 09 	mcall	80002424 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002404:	2f f7       	sub	r7,-1
80002406:	5c 57       	castu.b	r7
80002408:	2f ed       	sub	sp,-8
8000240a:	ee 05 19 00 	cp.h	r5,r7
8000240e:	fe 9b ff f3 	brhi	800023f4 <DataSession_brdcst_func+0x40>
80002412:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
80002414:	1a d8       	st.w	--sp,r8
80002416:	48 8c       	lddpc	r12,80002434 <DataSession_brdcst_func+0x80>
80002418:	f0 1f 00 03 	mcall	80002424 <DataSession_brdcst_func+0x70>
8000241c:	2f fd       	sub	sp,-4
8000241e:	d8 22       	popm	r4-r7,pc
80002420:	80 00       	ld.sh	r0,r0[0x0]
80002422:	c9 48       	rjmp	8000254a <AudioRoutingControl_brdcst_func+0x12>
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	64 90       	ld.w	r0,r2[0x24]
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	c9 5c       	rcall	80002554 <AudioRoutingControl_brdcst_func+0x1c>
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	c9 74       	brge	8000235c <Phyuserinput_brdcst_func+0x64>
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	c9 90       	breq	80002364 <Phyuserinput_brdcst_func+0x6c>
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	c9 a8       	rjmp	8000256a <AudioRoutingControl_brdcst_func+0x32>

80002438 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002438:	eb cd 40 80 	pushm	r7,lr
8000243c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000243e:	19 a8       	ld.ub	r8,r12[0x2]
80002440:	58 08       	cp.w	r8,0
80002442:	c0 61       	brne	8000244e <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
80002444:	48 dc       	lddpc	r12,80002478 <DataSession_reply_func+0x40>
80002446:	f0 1f 00 0e 	mcall	8000247c <DataSession_reply_func+0x44>
8000244a:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
8000244e:	1a d8       	st.w	--sp,r8
80002450:	48 cc       	lddpc	r12,80002480 <DataSession_reply_func+0x48>
80002452:	f0 1f 00 0b 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
80002456:	48 cc       	lddpc	r12,80002484 <DataSession_reply_func+0x4c>
80002458:	f0 1f 00 09 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
8000245c:	0f b8       	ld.ub	r8,r7[0x3]
8000245e:	1a d8       	st.w	--sp,r8
80002460:	48 ac       	lddpc	r12,80002488 <DataSession_reply_func+0x50>
80002462:	f0 1f 00 07 	mcall	8000247c <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
80002466:	0f c8       	ld.ub	r8,r7[0x4]
80002468:	1a d8       	st.w	--sp,r8
8000246a:	48 9c       	lddpc	r12,8000248c <DataSession_reply_func+0x54>
8000246c:	f0 1f 00 04 	mcall	8000247c <DataSession_reply_func+0x44>
80002470:	2f dd       	sub	sp,-12
80002472:	e3 cd 80 80 	ldm	sp++,r7,pc
80002476:	00 00       	add	r0,r0
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	c9 bc       	rcall	800025b0 <AudioRoutingControl_brdcst_func+0x78>
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	64 90       	ld.w	r0,r2[0x24]
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	c9 d0       	breq	800023bc <DataSession_brdcst_func+0x8>
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	c9 e4       	brge	800023c2 <DataSession_brdcst_func+0xe>
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	c9 f8       	rjmp	800025c8 <Volume_reply_func>
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	ca 08       	rjmp	800025ce <Volume_reply_func+0x6>

80002490 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002490:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002494:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002498:	0f 99       	ld.ub	r9,r7[0x1]
8000249a:	30 08       	mov	r8,0
8000249c:	f0 09 18 00 	cp.b	r9,r8
800024a0:	c0 71       	brne	800024ae <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800024a2:	48 ac       	lddpc	r12,800024c8 <TransmitControl_brdcst_func+0x38>
800024a4:	f0 1f 00 0a 	mcall	800024cc <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800024a8:	30 09       	mov	r9,0
800024aa:	48 a8       	lddpc	r8,800024d0 <TransmitControl_brdcst_func+0x40>
800024ac:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800024ae:	0f 99       	ld.ub	r9,r7[0x1]
800024b0:	30 18       	mov	r8,1
800024b2:	f0 09 18 00 	cp.b	r9,r8
800024b6:	c0 71       	brne	800024c4 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800024b8:	48 7c       	lddpc	r12,800024d4 <TransmitControl_brdcst_func+0x44>
800024ba:	f0 1f 00 05 	mcall	800024cc <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800024be:	30 19       	mov	r9,1
800024c0:	48 48       	lddpc	r8,800024d0 <TransmitControl_brdcst_func+0x40>
800024c2:	b0 89       	st.b	r8[0x0],r9
800024c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	ca 18       	rjmp	8000260c <Volume_reply_func+0x44>
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	64 90       	ld.w	r0,r2[0x24]
800024d0:	00 00       	add	r0,r0
800024d2:	0a 51       	eor	r1,r5
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	ca 30       	breq	8000241c <DataSession_brdcst_func+0x68>

800024d8 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800024d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800024dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800024e0:	0f 89       	ld.ub	r9,r7[0x0]
800024e2:	30 08       	mov	r8,0
800024e4:	f0 09 18 00 	cp.b	r9,r8
800024e8:	c1 61       	brne	80002514 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800024ea:	48 ec       	lddpc	r12,80002520 <TransmitControl_reply_func+0x48>
800024ec:	f0 1f 00 0e 	mcall	80002524 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800024f0:	0f 98       	ld.ub	r8,r7[0x1]
800024f2:	1a d8       	st.w	--sp,r8
800024f4:	48 dc       	lddpc	r12,80002528 <TransmitControl_reply_func+0x50>
800024f6:	f0 1f 00 0c 	mcall	80002524 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800024fa:	0f a8       	ld.ub	r8,r7[0x2]
800024fc:	1a d8       	st.w	--sp,r8
800024fe:	48 cc       	lddpc	r12,8000252c <TransmitControl_reply_func+0x54>
80002500:	f0 1f 00 09 	mcall	80002524 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002504:	0f b8       	ld.ub	r8,r7[0x3]
80002506:	1a d8       	st.w	--sp,r8
80002508:	48 ac       	lddpc	r12,80002530 <TransmitControl_reply_func+0x58>
8000250a:	f0 1f 00 07 	mcall	80002524 <TransmitControl_reply_func+0x4c>
8000250e:	2f dd       	sub	sp,-12
80002510:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002514:	48 8c       	lddpc	r12,80002534 <TransmitControl_reply_func+0x5c>
80002516:	f0 1f 00 04 	mcall	80002524 <TransmitControl_reply_func+0x4c>
8000251a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000251e:	00 00       	add	r0,r0
80002520:	80 00       	ld.sh	r0,r0[0x0]
80002522:	ca 44       	brge	8000246a <DataSession_reply_func+0x32>
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	64 90       	ld.w	r0,r2[0x24]
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	ca 60       	breq	80002476 <DataSession_reply_func+0x3e>
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	ca 74       	brge	8000247c <DataSession_reply_func+0x44>
80002530:	80 00       	ld.sh	r0,r0[0x0]
80002532:	ca 90       	breq	80002484 <DataSession_reply_func+0x4c>
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	ca a0       	breq	8000248a <DataSession_reply_func+0x52>

80002538 <AudioRoutingControl_brdcst_func>:
	}
}


void AudioRoutingControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002538:	d4 31       	pushm	r0-r7,lr
8000253a:	18 95       	mov	r5,r12
	
	U16 num_routings = 0;
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
8000253c:	19 a3       	ld.ub	r3,r12[0x2]
8000253e:	19 b8       	ld.ub	r8,r12[0x3]
80002540:	f1 e3 10 83 	or	r3,r8,r3<<0x8
80002544:	5c 83       	casts.h	r3
	log("\n\r num_routings: %d \n\r", num_routings);
80002546:	f1 d3 c0 10 	bfextu	r8,r3,0x0,0x10
8000254a:	1a d8       	st.w	--sp,r8
8000254c:	49 ac       	lddpc	r12,800025b4 <AudioRoutingControl_brdcst_func+0x7c>
8000254e:	f0 1f 00 1b 	mcall	800025b8 <AudioRoutingControl_brdcst_func+0x80>
	
	for(j = 0; j< num_routings ; j++ )
80002552:	2f fd       	sub	sp,-4
80002554:	58 03       	cp.w	r3,0
80002556:	c2 d0       	breq	800025b0 <AudioRoutingControl_brdcst_func+0x78>
80002558:	30 07       	mov	r7,0
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
8000255a:	49 91       	lddpc	r1,800025bc <AudioRoutingControl_brdcst_func+0x84>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
8000255c:	49 90       	lddpc	r0,800025c0 <AudioRoutingControl_brdcst_func+0x88>
		if (xcmp->u8[2+j*2] == 0x0d)
8000255e:	30 d2       	mov	r2,13
	
	for(j = 0; j< num_routings ; j++ )
	{
		
		
		log("\n\r Audio-Input: %x \n\r", xcmp->u8[2+j*2]);
80002560:	ee c6 ff ff 	sub	r6,r7,-1
80002564:	ea 06 00 16 	add	r6,r5,r6<<0x1
80002568:	0d a8       	ld.ub	r8,r6[0x2]
8000256a:	1a d8       	st.w	--sp,r8
8000256c:	02 9c       	mov	r12,r1
8000256e:	f0 1f 00 13 	mcall	800025b8 <AudioRoutingControl_brdcst_func+0x80>
		log("\n\r Audio-Output: %x \n\r", xcmp->u8[3+j*2]);
80002572:	ee 04 15 01 	lsl	r4,r7,0x1
80002576:	2f d4       	sub	r4,-3
80002578:	ea 04 00 08 	add	r8,r5,r4
8000257c:	11 a8       	ld.ub	r8,r8[0x2]
8000257e:	1a d8       	st.w	--sp,r8
80002580:	00 9c       	mov	r12,r0
80002582:	f0 1f 00 0e 	mcall	800025b8 <AudioRoutingControl_brdcst_func+0x80>
		if (xcmp->u8[2+j*2] == 0x0d)
80002586:	2f ed       	sub	sp,-8
80002588:	0d a8       	ld.ub	r8,r6[0x2]
8000258a:	e4 08 18 00 	cp.b	r8,r2
8000258e:	c0 b1       	brne	800025a4 <AudioRoutingControl_brdcst_func+0x6c>
		{
			if (xcmp->u8[3+j*2] == 0x0c)
80002590:	ea 04 00 04 	add	r4,r5,r4
80002594:	09 a8       	ld.ub	r8,r4[0x2]
80002596:	30 c9       	mov	r9,12
80002598:	f2 08 18 00 	cp.b	r8,r9
8000259c:	c0 41       	brne	800025a4 <AudioRoutingControl_brdcst_func+0x6c>
			{
				//Speaker_is_unmute = 1;
				log("Speaker IA OK");
8000259e:	48 ac       	lddpc	r12,800025c4 <AudioRoutingControl_brdcst_func+0x8c>
800025a0:	f0 1f 00 06 	mcall	800025b8 <AudioRoutingControl_brdcst_func+0x80>
	U8 j = 0 ;
	
	num_routings = ((xcmp->u8[0]<< 8) | (xcmp->u8[1]) );
	log("\n\r num_routings: %d \n\r", num_routings);
	
	for(j = 0; j< num_routings ; j++ )
800025a4:	2f f7       	sub	r7,-1
800025a6:	5c 57       	castu.b	r7
800025a8:	ee 03 19 00 	cp.h	r3,r7
800025ac:	fe 9b ff da 	brhi	80002560 <AudioRoutingControl_brdcst_func+0x28>
800025b0:	d8 32       	popm	r0-r7,pc
800025b2:	00 00       	add	r0,r0
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	ca b8       	rjmp	8000270c <mic_reply_func+0x34>
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	64 90       	ld.w	r0,r2[0x24]
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	ca d0       	breq	80002518 <TransmitControl_reply_func+0x40>
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	ca e8       	rjmp	8000271e <mic_reply_func+0x46>
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	cb 00       	breq	80002526 <TransmitControl_reply_func+0x4e>

800025c8 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800025c8:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800025cc:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800025d0:	0f 89       	ld.ub	r9,r7[0x0]
800025d2:	30 08       	mov	r8,0
800025d4:	f0 09 18 00 	cp.b	r9,r8
800025d8:	c1 b1       	brne	8000260e <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800025da:	0f b8       	ld.ub	r8,r7[0x3]
800025dc:	31 09       	mov	r9,16
800025de:	f2 08 18 00 	cp.b	r8,r9
800025e2:	c0 f1       	brne	80002600 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800025e4:	48 dc       	lddpc	r12,80002618 <Volume_reply_func+0x50>
800025e6:	f0 1f 00 0e 	mcall	8000261c <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800025ea:	0f 99       	ld.ub	r9,r7[0x1]
800025ec:	0f a8       	ld.ub	r8,r7[0x2]
800025ee:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800025f2:	1a d8       	st.w	--sp,r8
800025f4:	48 bc       	lddpc	r12,80002620 <Volume_reply_func+0x58>
800025f6:	f0 1f 00 0a 	mcall	8000261c <Volume_reply_func+0x54>
800025fa:	2f fd       	sub	sp,-4
800025fc:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002600:	1a d8       	st.w	--sp,r8
80002602:	48 9c       	lddpc	r12,80002624 <Volume_reply_func+0x5c>
80002604:	f0 1f 00 06 	mcall	8000261c <Volume_reply_func+0x54>
80002608:	2f fd       	sub	sp,-4
8000260a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
8000260e:	48 7c       	lddpc	r12,80002628 <Volume_reply_func+0x60>
80002610:	f0 1f 00 03 	mcall	8000261c <Volume_reply_func+0x54>
80002614:	e3 cd 80 80 	ldm	sp++,r7,pc
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	cb 10       	breq	8000257c <AudioRoutingControl_brdcst_func+0x44>
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	64 90       	ld.w	r0,r2[0x24]
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	cb 24       	brge	80002586 <AudioRoutingControl_brdcst_func+0x4e>
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	cb 40       	breq	8000258e <AudioRoutingControl_brdcst_func+0x56>
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	cb 58       	rjmp	80002794 <dcm_brdcst_func+0x28>

8000262c <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
8000262c:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000262e:	19 d9       	ld.ub	r9,r12[0x5]
80002630:	30 08       	mov	r8,0
80002632:	f0 09 18 00 	cp.b	r9,r8
80002636:	c0 81       	brne	80002646 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002638:	10 99       	mov	r9,r8
8000263a:	48 68       	lddpc	r8,80002650 <spk_brdcst_func+0x24>
8000263c:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000263e:	48 6c       	lddpc	r12,80002654 <spk_brdcst_func+0x28>
80002640:	f0 1f 00 06 	mcall	80002658 <spk_brdcst_func+0x2c>
80002644:	d8 02       	popm	pc
	}
	else
	{
		//Silent_flag = 1;
		//Speaker_is_unmute = 1;
		log("spk_s_open ");
80002646:	48 6c       	lddpc	r12,8000265c <spk_brdcst_func+0x30>
80002648:	f0 1f 00 04 	mcall	80002658 <spk_brdcst_func+0x2c>
8000264c:	d8 02       	popm	pc
8000264e:	00 00       	add	r0,r0
80002650:	00 00       	add	r0,r0
80002652:	0a 40       	or	r0,r5
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	cb 70       	breq	800025c4 <AudioRoutingControl_brdcst_func+0x8c>
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	64 90       	ld.w	r0,r2[0x24]
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	cb 80       	breq	800025ce <Volume_reply_func+0x6>

80002660 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002660:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002662:	19 a9       	ld.ub	r9,r12[0x2]
80002664:	30 08       	mov	r8,0
80002666:	f0 09 18 00 	cp.b	r9,r8
8000266a:	c0 81       	brne	8000267a <spk_reply_func+0x1a>
		{
			//Speaker_is_unmute = 1;
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000266c:	19 e8       	ld.ub	r8,r12[0x6]
8000266e:	1a d8       	st.w	--sp,r8
80002670:	48 5c       	lddpc	r12,80002684 <spk_reply_func+0x24>
80002672:	f0 1f 00 06 	mcall	80002688 <spk_reply_func+0x28>
80002676:	2f fd       	sub	sp,-4
80002678:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
8000267a:	48 5c       	lddpc	r12,8000268c <spk_reply_func+0x2c>
8000267c:	f0 1f 00 03 	mcall	80002688 <spk_reply_func+0x28>
80002680:	d8 02       	popm	pc
80002682:	00 00       	add	r0,r0
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	cb 8c       	rcall	800027f6 <dcm_reply_func+0x42>
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	64 90       	ld.w	r0,r2[0x24]
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	cb 9c       	rcall	80002800 <dcm_reply_func+0x4c>

80002690 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002690:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002694:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002698:	0f a9       	ld.ub	r9,r7[0x2]
8000269a:	30 08       	mov	r8,0
8000269c:	f0 09 18 00 	cp.b	r9,r8
800026a0:	c0 71       	brne	800026ae <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800026a2:	48 ac       	lddpc	r12,800026c8 <mic_brdcst_func+0x38>
800026a4:	f0 1f 00 0a 	mcall	800026cc <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 0;
800026a8:	30 09       	mov	r9,0
800026aa:	48 a8       	lddpc	r8,800026d0 <mic_brdcst_func+0x40>
800026ac:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
800026ae:	0f a9       	ld.ub	r9,r7[0x2]
800026b0:	31 18       	mov	r8,17
800026b2:	f0 09 18 00 	cp.b	r9,r8
800026b6:	c0 71       	brne	800026c4 <mic_brdcst_func+0x34>
	{
		log("\n\r Mic_Enabled \n\r");	
800026b8:	48 7c       	lddpc	r12,800026d4 <mic_brdcst_func+0x44>
800026ba:	f0 1f 00 05 	mcall	800026cc <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 1;
800026be:	30 19       	mov	r9,1
800026c0:	48 48       	lddpc	r8,800026d0 <mic_brdcst_func+0x40>
800026c2:	b0 89       	st.b	r8[0x0],r9
800026c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	cb a8       	rjmp	8000283e <ToneControl_reply_func+0x22>
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	64 90       	ld.w	r0,r2[0x24]
800026d0:	00 00       	add	r0,r0
800026d2:	0a 55       	eor	r5,r5
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	cb bc       	rcall	8000284c <app_payload_rx_proc+0x8>

800026d8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800026d8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800026dc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800026e0:	49 ac       	lddpc	r12,80002748 <mic_reply_func+0x70>
800026e2:	f0 1f 00 1b 	mcall	8000274c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800026e6:	0f 89       	ld.ub	r9,r7[0x0]
800026e8:	30 08       	mov	r8,0
800026ea:	f0 09 18 00 	cp.b	r9,r8
800026ee:	c2 71       	brne	8000273c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800026f0:	0f 98       	ld.ub	r8,r7[0x1]
800026f2:	30 29       	mov	r9,2
800026f4:	f2 08 18 00 	cp.b	r8,r9
800026f8:	c1 b1       	brne	8000272e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800026fa:	49 6c       	lddpc	r12,80002750 <mic_reply_func+0x78>
800026fc:	f0 1f 00 14 	mcall	8000274c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002700:	0f a8       	ld.ub	r8,r7[0x2]
80002702:	1a d8       	st.w	--sp,r8
80002704:	49 4c       	lddpc	r12,80002754 <mic_reply_func+0x7c>
80002706:	f0 1f 00 12 	mcall	8000274c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000270a:	0f b8       	ld.ub	r8,r7[0x3]
8000270c:	1a d8       	st.w	--sp,r8
8000270e:	49 3c       	lddpc	r12,80002758 <mic_reply_func+0x80>
80002710:	f0 1f 00 0f 	mcall	8000274c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002714:	0f c8       	ld.ub	r8,r7[0x4]
80002716:	1a d8       	st.w	--sp,r8
80002718:	49 1c       	lddpc	r12,8000275c <mic_reply_func+0x84>
8000271a:	f0 1f 00 0d 	mcall	8000274c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
8000271e:	0f d8       	ld.ub	r8,r7[0x5]
80002720:	1a d8       	st.w	--sp,r8
80002722:	49 0c       	lddpc	r12,80002760 <mic_reply_func+0x88>
80002724:	f0 1f 00 0a 	mcall	8000274c <mic_reply_func+0x74>
80002728:	2f cd       	sub	sp,-16
8000272a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000272e:	1a d8       	st.w	--sp,r8
80002730:	48 dc       	lddpc	r12,80002764 <mic_reply_func+0x8c>
80002732:	f0 1f 00 07 	mcall	8000274c <mic_reply_func+0x74>
80002736:	2f fd       	sub	sp,-4
80002738:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000273c:	48 bc       	lddpc	r12,80002768 <mic_reply_func+0x90>
8000273e:	f0 1f 00 04 	mcall	8000274c <mic_reply_func+0x74>
80002742:	e3 cd 80 80 	ldm	sp++,r7,pc
80002746:	00 00       	add	r0,r0
80002748:	80 00       	ld.sh	r0,r0[0x0]
8000274a:	cb d0       	breq	800026c4 <mic_brdcst_func+0x34>
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	64 90       	ld.w	r0,r2[0x24]
80002750:	80 00       	ld.sh	r0,r0[0x0]
80002752:	cb e0       	breq	800026ce <mic_brdcst_func+0x3e>
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	cb f4       	brge	800026d4 <mic_brdcst_func+0x44>
80002758:	80 00       	ld.sh	r0,r0[0x0]
8000275a:	cc 08       	rjmp	800028da <DeviceInitializationStatus_brdcst_func+0x2>
8000275c:	80 00       	ld.sh	r0,r0[0x0]
8000275e:	cc 24       	brge	800026e2 <mic_reply_func+0xa>
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	cc 3c       	rcall	800028e8 <DeviceInitializationStatus_brdcst_func+0x10>
80002764:	80 00       	ld.sh	r0,r0[0x0]
80002766:	cc 54       	brge	800026f0 <mic_reply_func+0x18>
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	cc 6c       	rcall	800028f6 <DeviceInitializationStatus_brdcst_func+0x1e>

8000276c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000276c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002770:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002774:	48 bc       	lddpc	r12,800027a0 <dcm_brdcst_func+0x34>
80002776:	f0 1f 00 0c 	mcall	800027a4 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000277a:	0f 88       	ld.ub	r8,r7[0x0]
8000277c:	1a d8       	st.w	--sp,r8
8000277e:	48 bc       	lddpc	r12,800027a8 <dcm_brdcst_func+0x3c>
80002780:	f0 1f 00 09 	mcall	800027a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002784:	0f a8       	ld.ub	r8,r7[0x2]
80002786:	1a d8       	st.w	--sp,r8
80002788:	48 9c       	lddpc	r12,800027ac <dcm_brdcst_func+0x40>
8000278a:	f0 1f 00 07 	mcall	800027a4 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000278e:	0f 98       	ld.ub	r8,r7[0x1]
80002790:	1a d8       	st.w	--sp,r8
80002792:	48 8c       	lddpc	r12,800027b0 <dcm_brdcst_func+0x44>
80002794:	f0 1f 00 04 	mcall	800027a4 <dcm_brdcst_func+0x38>
80002798:	2f dd       	sub	sp,-12
	
	
}
8000279a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000279e:	00 00       	add	r0,r0
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	cc 7c       	rcall	80002930 <payload_init+0x4>
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	64 90       	ld.w	r0,r2[0x24]
800027a8:	80 00       	ld.sh	r0,r0[0x0]
800027aa:	cc 90       	breq	8000273c <mic_reply_func+0x64>
800027ac:	80 00       	ld.sh	r0,r0[0x0]
800027ae:	cc a4       	brge	80002742 <mic_reply_func+0x6a>
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	cc bc       	rcall	80002948 <payload_init+0x1c>

800027b4 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800027b4:	eb cd 40 80 	pushm	r7,lr
800027b8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800027ba:	19 a9       	ld.ub	r9,r12[0x2]
800027bc:	30 08       	mov	r8,0
800027be:	f0 09 18 00 	cp.b	r9,r8
800027c2:	c1 b1       	brne	800027f8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800027c4:	19 b8       	ld.ub	r8,r12[0x3]
800027c6:	30 19       	mov	r9,1
800027c8:	f2 08 18 00 	cp.b	r8,r9
800027cc:	c0 51       	brne	800027d6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800027ce:	48 ec       	lddpc	r12,80002804 <dcm_reply_func+0x50>
800027d0:	f0 1f 00 0e 	mcall	80002808 <dcm_reply_func+0x54>
800027d4:	c0 a8       	rjmp	800027e8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800027d6:	58 08       	cp.w	r8,0
800027d8:	c0 51       	brne	800027e2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800027da:	48 dc       	lddpc	r12,8000280c <dcm_reply_func+0x58>
800027dc:	f0 1f 00 0b 	mcall	80002808 <dcm_reply_func+0x54>
800027e0:	c0 48       	rjmp	800027e8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800027e2:	48 cc       	lddpc	r12,80002810 <dcm_reply_func+0x5c>
800027e4:	f0 1f 00 09 	mcall	80002808 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800027e8:	0f d8       	ld.ub	r8,r7[0x5]
800027ea:	1a d8       	st.w	--sp,r8
800027ec:	48 ac       	lddpc	r12,80002814 <dcm_reply_func+0x60>
800027ee:	f0 1f 00 07 	mcall	80002808 <dcm_reply_func+0x54>
800027f2:	2f fd       	sub	sp,-4
800027f4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800027f8:	48 8c       	lddpc	r12,80002818 <dcm_reply_func+0x64>
800027fa:	f0 1f 00 04 	mcall	80002808 <dcm_reply_func+0x54>
800027fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002802:	00 00       	add	r0,r0
80002804:	80 00       	ld.sh	r0,r0[0x0]
80002806:	cc d8       	rjmp	800029a0 <payload_rx_process+0x3c>
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	64 90       	ld.w	r0,r2[0x24]
8000280c:	80 00       	ld.sh	r0,r0[0x0]
8000280e:	cc ec       	rcall	800029aa <payload_rx_process+0x46>
80002810:	80 00       	ld.sh	r0,r0[0x0]
80002812:	cd 00       	breq	800027b2 <dcm_brdcst_func+0x46>
80002814:	80 00       	ld.sh	r0,r0[0x0]
80002816:	cd 14       	brge	800027b8 <dcm_reply_func+0x4>
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	cd 20       	breq	800027be <dcm_reply_func+0xa>

8000281c <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
8000281c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000281e:	19 a9       	ld.ub	r9,r12[0x2]
80002820:	30 08       	mov	r8,0
80002822:	f0 09 18 00 	cp.b	r9,r8
80002826:	c0 51       	brne	80002830 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
80002828:	48 4c       	lddpc	r12,80002838 <ToneControl_reply_func+0x1c>
8000282a:	f0 1f 00 05 	mcall	8000283c <ToneControl_reply_func+0x20>
8000282e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002830:	48 4c       	lddpc	r12,80002840 <ToneControl_reply_func+0x24>
80002832:	f0 1f 00 03 	mcall	8000283c <ToneControl_reply_func+0x20>
80002836:	d8 02       	popm	pc
80002838:	80 00       	ld.sh	r0,r0[0x0]
8000283a:	cd 2c       	rcall	800029de <phy_rx+0x12>
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	64 90       	ld.w	r0,r2[0x24]
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	cd 34       	brge	800027e8 <dcm_reply_func+0x34>

80002844 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
80002844:	eb cd 40 80 	pushm	r7,lr
80002848:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
8000284a:	48 b9       	lddpc	r9,80002874 <app_payload_rx_proc+0x30>
8000284c:	13 88       	ld.ub	r8,r9[0x0]
8000284e:	2f f8       	sub	r8,-1
80002850:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 110)
80002852:	36 e9       	mov	r9,110
80002854:	f2 08 18 00 	cp.b	r8,r9
80002858:	c0 71       	brne	80002866 <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
8000285a:	30 09       	mov	r9,0
8000285c:	48 68       	lddpc	r8,80002874 <app_payload_rx_proc+0x30>
8000285e:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002860:	48 6c       	lddpc	r12,80002878 <app_payload_rx_proc+0x34>
80002862:	f0 1f 00 07 	mcall	8000287c <app_payload_rx_proc+0x38>
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
80002866:	48 78       	lddpc	r8,80002880 <app_payload_rx_proc+0x3c>
80002868:	70 0c       	ld.w	r12,r8[0x0]
8000286a:	0e 9b       	mov	r11,r7
8000286c:	f0 1f 00 06 	mcall	80002884 <app_payload_rx_proc+0x40>

}
80002870:	e3 cd 80 80 	ldm	sp++,r7,pc
80002874:	00 00       	add	r0,r0
80002876:	0a 53       	eor	r3,r5
80002878:	80 00       	ld.sh	r0,r0[0x0]
8000287a:	cd 40       	breq	80002822 <ToneControl_reply_func+0x6>
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	64 90       	ld.w	r0,r2[0x24]
80002880:	00 00       	add	r0,r0
80002882:	0a 70       	tst	r0,r5
80002884:	80 00       	ld.sh	r0,r0[0x0]
80002886:	2a 04       	sub	r4,-96

80002888 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002888:	eb cd 40 80 	pushm	r7,lr
8000288c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000288e:	19 a9       	ld.ub	r9,r12[0x2]
80002890:	30 08       	mov	r8,0
80002892:	f0 09 18 00 	cp.b	r9,r8
80002896:	c0 c1       	brne	800028ae <AudioRoutingControl_reply_func+0x26>
	{
		
		log("AudioRouting OK");
80002898:	48 bc       	lddpc	r12,800028c4 <AudioRoutingControl_reply_func+0x3c>
8000289a:	f0 1f 00 0c 	mcall	800028c8 <AudioRoutingControl_reply_func+0x40>
		xcmp_IdleTestTone();//提示通道配置成功
8000289e:	f0 1f 00 0c 	mcall	800028cc <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
800028a2:	f0 1f 00 0b 	mcall	800028cc <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
800028a6:	f0 1f 00 0a 	mcall	800028cc <AudioRoutingControl_reply_func+0x44>
800028aa:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800028ae:	48 9c       	lddpc	r12,800028d0 <AudioRoutingControl_reply_func+0x48>
800028b0:	f0 1f 00 06 	mcall	800028c8 <AudioRoutingControl_reply_func+0x40>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
800028b4:	0f a8       	ld.ub	r8,r7[0x2]
800028b6:	1a d8       	st.w	--sp,r8
800028b8:	48 7c       	lddpc	r12,800028d4 <AudioRoutingControl_reply_func+0x4c>
800028ba:	f0 1f 00 04 	mcall	800028c8 <AudioRoutingControl_reply_func+0x40>
800028be:	2f fd       	sub	sp,-4
800028c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	cd 4c       	rcall	80002a6e <phy_tx+0x4a>
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	64 90       	ld.w	r0,r2[0x24]
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	42 64       	lddsp	r4,sp[0x98]
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	cd 5c       	rcall	80002a7c <phy_tx+0x58>
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	cd 70       	breq	80002884 <app_payload_rx_proc+0x40>

800028d8 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028d8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028da:	19 e8       	ld.ub	r8,r12[0x6]
800028dc:	30 19       	mov	r9,1
800028de:	f2 08 18 00 	cp.b	r8,r9
800028e2:	c0 61       	brne	800028ee <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028e4:	48 98       	lddpc	r8,80002908 <DeviceInitializationStatus_brdcst_func+0x30>
800028e6:	70 09       	ld.w	r9,r8[0x0]
800028e8:	a1 a9       	sbr	r9,0x0
800028ea:	91 09       	st.w	r8[0x0],r9
800028ec:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028ee:	30 29       	mov	r9,2
800028f0:	f2 08 18 00 	cp.b	r8,r9
800028f4:	c0 80       	breq	80002904 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028f6:	48 58       	lddpc	r8,80002908 <DeviceInitializationStatus_brdcst_func+0x30>
800028f8:	70 09       	ld.w	r9,r8[0x0]
800028fa:	e0 19 ff fc 	andl	r9,0xfffc
800028fe:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002900:	f0 1f 00 03 	mcall	8000290c <DeviceInitializationStatus_brdcst_func+0x34>
80002904:	d8 02       	popm	pc
80002906:	00 00       	add	r0,r0
80002908:	00 00       	add	r0,r0
8000290a:	0d a8       	ld.ub	r8,r6[0x2]
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	41 b8       	lddsp	r8,sp[0x6c]

80002910 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002910:	20 1c       	sub	r12,1
80002912:	5c 5c       	castu.b	r12
80002914:	31 18       	mov	r8,17
80002916:	f0 0c 18 00 	cp.b	r12,r8
8000291a:	e0 88 00 03 	brls	80002920 <CalculateBurst+0x10>
8000291e:	5e fd       	retal	0
80002920:	48 28       	lddpc	r8,80002928 <CalculateBurst+0x18>
80002922:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002926:	5e fc       	retal	r12
80002928:	80 00       	ld.sh	r0,r0[0x0]
8000292a:	cd 90       	breq	800028dc <DeviceInitializationStatus_brdcst_func+0x4>

8000292c <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
8000292c:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
8000292e:	48 98       	lddpc	r8,80002950 <payload_init+0x24>
80002930:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002932:	48 98       	lddpc	r8,80002954 <payload_init+0x28>
80002934:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80002936:	30 09       	mov	r9,0
80002938:	1a d9       	st.w	--sp,r9
8000293a:	1a d9       	st.w	--sp,r9
8000293c:	1a d9       	st.w	--sp,r9
8000293e:	30 28       	mov	r8,2
80002940:	e0 6a 04 00 	mov	r10,1024
80002944:	48 5b       	lddpc	r11,80002958 <payload_init+0x2c>
80002946:	48 6c       	lddpc	r12,8000295c <payload_init+0x30>
80002948:	f0 1f 00 06 	mcall	80002960 <payload_init+0x34>
8000294c:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
8000294e:	d8 02       	popm	pc
80002950:	00 00       	add	r0,r0
80002952:	0a 5c       	eor	r12,r5
80002954:	00 00       	add	r0,r0
80002956:	0a 60       	and	r0,r5
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	d3 88       	*unknown*
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	29 64       	sub	r4,-106
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	60 cc       	ld.w	r12,r0[0x30]

80002964 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002964:	eb cd 40 f8 	pushm	r3-r7,lr
80002968:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
8000296a:	48 e8       	lddpc	r8,800029a0 <payload_rx_process+0x3c>
8000296c:	70 08       	ld.w	r8,r8[0x0]
8000296e:	58 08       	cp.w	r8,0
80002970:	c0 71       	brne	8000297e <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002972:	30 4b       	mov	r11,4
80002974:	30 5c       	mov	r12,5
80002976:	f0 1f 00 0c 	mcall	800029a4 <payload_rx_process+0x40>
8000297a:	48 a8       	lddpc	r8,800029a0 <payload_rx_process+0x3c>
8000297c:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000297e:	48 96       	lddpc	r6,800029a0 <payload_rx_process+0x3c>
80002980:	30 05       	mov	r5,0
80002982:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();//此处跳转。。。。
80002984:	48 93       	lddpc	r3,800029a8 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002986:	6c 0c       	ld.w	r12,r6[0x0]
80002988:	0a 99       	mov	r9,r5
8000298a:	08 9a       	mov	r10,r4
8000298c:	1a 9b       	mov	r11,sp
8000298e:	f0 1f 00 08 	mcall	800029ac <payload_rx_process+0x48>
80002992:	58 1c       	cp.w	r12,1
80002994:	cf 91       	brne	80002986 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();//此处跳转。。。。
80002996:	66 08       	ld.w	r8,r3[0x0]
80002998:	40 0c       	lddsp	r12,sp[0x0]
8000299a:	5d 18       	icall	r8
8000299c:	cf 5b       	rjmp	80002986 <payload_rx_process+0x22>
8000299e:	00 00       	add	r0,r0
800029a0:	00 00       	add	r0,r0
800029a2:	0a 74       	tst	r4,r5
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	59 f8       	cp.w	r8,31
800029a8:	00 00       	add	r0,r0
800029aa:	0a 5c       	eor	r12,r5
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	56 94       	stdsp	sp[0x1a4],r4

800029b0 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800029b0:	d4 01       	pushm	lr
800029b2:	20 2d       	sub	sp,8
800029b4:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029b6:	30 09       	mov	r9,0
800029b8:	fa ca ff f8 	sub	r10,sp,-8
800029bc:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
800029be:	1a 9b       	mov	r11,sp
800029c0:	f0 1f 00 02 	mcall	800029c8 <set_idle_store_isr+0x18>
}
800029c4:	2f ed       	sub	sp,-8
800029c6:	d8 02       	popm	pc
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	58 50       	cp.w	r0,5

800029cc <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
800029cc:	d4 01       	pushm	lr
800029ce:	20 2d       	sub	sp,8
800029d0:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
800029d2:	58 0c       	cp.w	r12,0
800029d4:	c1 10       	breq	800029f6 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029d6:	30 08       	mov	r8,0
800029d8:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
800029da:	98 88       	ld.uh	r8,r12[0x0]
800029dc:	e2 18 f0 00 	andl	r8,0xf000,COH
800029e0:	e0 48 40 00 	cp.w	r8,16384
800029e4:	c0 91       	brne	800029f6 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
800029e6:	48 68       	lddpc	r8,800029fc <phy_rx+0x30>
800029e8:	70 0c       	ld.w	r12,r8[0x0]
800029ea:	30 09       	mov	r9,0
800029ec:	fa ca ff fc 	sub	r10,sp,-4
800029f0:	1a 9b       	mov	r11,sp
800029f2:	f0 1f 00 04 	mcall	80002a00 <phy_rx+0x34>
		}	

    }
		
 
}
800029f6:	2f ed       	sub	sp,-8
800029f8:	d8 02       	popm	pc
800029fa:	00 00       	add	r0,r0
800029fc:	00 00       	add	r0,r0
800029fe:	0a bc       	st.h	r5++,r12
80002a00:	80 00       	ld.sh	r0,r0[0x0]
80002a02:	58 50       	cp.w	r0,5

80002a04 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a04:	eb cd 40 80 	pushm	r7,lr
80002a08:	20 1d       	sub	sp,4
80002a0a:	fa c7 ff fc 	sub	r7,sp,-4
80002a0e:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a10:	30 09       	mov	r9,0
80002a12:	12 9a       	mov	r10,r9
80002a14:	1a 9b       	mov	r11,sp
80002a16:	f0 1f 00 03 	mcall	80002a20 <set_idle_store+0x1c>
}
80002a1a:	2f fd       	sub	sp,-4
80002a1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	58 a0       	cp.w	r0,10

80002a24 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a24:	d4 01       	pushm	lr
80002a26:	20 1d       	sub	sp,4
80002a28:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a2a:	98 88       	ld.uh	r8,r12[0x0]
80002a2c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a30:	e0 48 40 00 	cp.w	r8,16384
80002a34:	c0 d1       	brne	80002a4e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a36:	49 08       	lddpc	r8,80002a74 <phy_tx+0x50>
80002a38:	70 08       	ld.w	r8,r8[0x0]
80002a3a:	58 08       	cp.w	r8,0
80002a3c:	c1 a0       	breq	80002a70 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a3e:	48 e8       	lddpc	r8,80002a74 <phy_tx+0x50>
80002a40:	70 0c       	ld.w	r12,r8[0x0]
80002a42:	30 09       	mov	r9,0
80002a44:	12 9a       	mov	r10,r9
80002a46:	1a 9b       	mov	r11,sp
80002a48:	f0 1f 00 0c 	mcall	80002a78 <phy_tx+0x54>
80002a4c:	c1 28       	rjmp	80002a70 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002a4e:	e0 48 10 00 	cp.w	r8,4096
80002a52:	5f 0a       	sreq	r10
80002a54:	e0 48 20 00 	cp.w	r8,8192
80002a58:	5f 09       	sreq	r9
80002a5a:	f5 e9 10 09 	or	r9,r10,r9
80002a5e:	c0 71       	brne	80002a6c <phy_tx+0x48>
80002a60:	e0 48 50 00 	cp.w	r8,20480
80002a64:	c0 40       	breq	80002a6c <phy_tx+0x48>
80002a66:	e0 48 60 00 	cp.w	r8,24576
80002a6a:	c0 31       	brne	80002a70 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a6c:	48 48       	lddpc	r8,80002a7c <phy_tx+0x58>
80002a6e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a70:	2f fd       	sub	sp,-4
80002a72:	d8 02       	popm	pc
80002a74:	00 00       	add	r0,r0
80002a76:	0a d0       	st.w	--r5,r0
80002a78:	80 00       	ld.sh	r0,r0[0x0]
80002a7a:	58 a0       	cp.w	r0,10
80002a7c:	00 00       	add	r0,r0
80002a7e:	0a c8       	st.b	r5++,r8

80002a80 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a80:	d4 01       	pushm	lr
80002a82:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a84:	30 08       	mov	r8,0
80002a86:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a88:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a8a:	1a 9a       	mov	r10,sp
80002a8c:	fa cb ff fc 	sub	r11,sp,-4
80002a90:	f0 1f 00 05 	mcall	80002aa4 <get_idle_store_isr+0x24>
80002a94:	58 1c       	cp.w	r12,1
80002a96:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a9a:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a9e:	2f ed       	sub	sp,-8
80002aa0:	d8 02       	popm	pc
80002aa2:	00 00       	add	r0,r0
80002aa4:	80 00       	ld.sh	r0,r0[0x0]
80002aa6:	55 a4       	stdsp	sp[0x168],r4

80002aa8 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002aa8:	eb cd 40 c0 	pushm	r6-r7,lr
80002aac:	20 1d       	sub	sp,4
80002aae:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002ab0:	fe f8 04 6c 	ld.w	r8,pc[1132]
80002ab4:	70 08       	ld.w	r8,r8[0x0]
80002ab6:	58 08       	cp.w	r8,0
80002ab8:	c7 40       	breq	80002ba0 <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002aba:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002abc:	30 08       	mov	r8,0
80002abe:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002ac0:	fe f8 04 60 	ld.w	r8,pc[1120]
80002ac4:	70 08       	ld.w	r8,r8[0x0]
80002ac6:	58 18       	cp.w	r8,1
80002ac8:	c2 90       	breq	80002b1a <phy_tx_func+0x72>
80002aca:	c0 43       	brcs	80002ad2 <phy_tx_func+0x2a>
80002acc:	58 28       	cp.w	r8,2
80002ace:	c6 91       	brne	80002ba0 <phy_tx_func+0xf8>
80002ad0:	c6 18       	rjmp	80002b92 <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002ad2:	fe f8 04 4a 	ld.w	r8,pc[1098]
80002ad6:	70 0c       	ld.w	r12,r8[0x0]
80002ad8:	1a 9a       	mov	r10,sp
80002ada:	fe fb 04 4a 	ld.w	r11,pc[1098]
80002ade:	f0 1f 01 13 	mcall	80002f28 <phy_tx_func+0x480>
80002ae2:	58 1c       	cp.w	r12,1
80002ae4:	c1 51       	brne	80002b0e <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002ae6:	fe f8 04 3e 	ld.w	r8,pc[1086]
80002aea:	70 08       	ld.w	r8,r8[0x0]
80002aec:	11 9a       	ld.ub	r10,r8[0x1]
80002aee:	fe f9 04 3e 	ld.w	r9,pc[1086]
80002af2:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002af4:	90 88       	ld.uh	r8,r8[0x0]
80002af6:	ea 18 ab cd 	orh	r8,0xabcd
80002afa:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002afc:	30 19       	mov	r9,1
80002afe:	fe f8 04 32 	ld.w	r8,pc[1074]
80002b02:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b04:	30 19       	mov	r9,1
80002b06:	fe f8 04 1a 	ld.w	r8,pc[1050]
80002b0a:	91 09       	st.w	r8[0x0],r9
80002b0c:	c4 a8       	rjmp	80002ba0 <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b0e:	e0 68 5a 5a 	mov	r8,23130
80002b12:	ea 18 ab cd 	orh	r8,0xabcd
80002b16:	8f 18       	st.w	r7[0x4],r8
80002b18:	c4 48       	rjmp	80002ba0 <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b1a:	fe f9 04 16 	ld.w	r9,pc[1046]
80002b1e:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b20:	fe fa 04 04 	ld.w	r10,pc[1028]
80002b24:	74 0a       	ld.w	r10,r10[0x0]
80002b26:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002b2a:	b1 6a       	lsl	r10,0x10
80002b2c:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b2e:	2f f8       	sub	r8,-1
80002b30:	5c 58       	castu.b	r8
80002b32:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b34:	fe fa 03 f8 	ld.w	r10,pc[1016]
80002b38:	94 09       	ld.sh	r9,r10[0x0]
80002b3a:	20 29       	sub	r9,2
80002b3c:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b3e:	30 0a       	mov	r10,0
80002b40:	f4 09 19 00 	cp.h	r9,r10
80002b44:	e0 89 00 0b 	brgt	80002b5a <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b48:	78 18       	ld.w	r8,r12[0x4]
80002b4a:	e8 18 00 ba 	orl	r8,0xba
80002b4e:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002b50:	30 09       	mov	r9,0
80002b52:	fe f8 03 ce 	ld.w	r8,pc[974]
80002b56:	91 09       	st.w	r8[0x0],r9
80002b58:	c2 48       	rjmp	80002ba0 <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b5a:	fe f9 03 ca 	ld.w	r9,pc[970]
80002b5e:	72 09       	ld.w	r9,r9[0x0]
80002b60:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b64:	78 1a       	ld.w	r10,r12[0x4]
80002b66:	f5 e9 10 09 	or	r9,r10,r9
80002b6a:	99 19       	st.w	r12[0x4],r9
80002b6c:	2f f8       	sub	r8,-1
80002b6e:	fe f9 03 c2 	ld.w	r9,pc[962]
80002b72:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b74:	fe f9 03 b8 	ld.w	r9,pc[952]
80002b78:	92 08       	ld.sh	r8,r9[0x0]
80002b7a:	20 28       	sub	r8,2
80002b7c:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b7e:	30 09       	mov	r9,0
80002b80:	f2 08 19 00 	cp.h	r8,r9
80002b84:	e0 89 00 0e 	brgt	80002ba0 <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b88:	30 29       	mov	r9,2
80002b8a:	fe f8 03 96 	ld.w	r8,pc[918]
80002b8e:	91 09       	st.w	r8[0x0],r9
80002b90:	c0 88       	rjmp	80002ba0 <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b92:	fc 18 00 ba 	movh	r8,0xba
80002b96:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b98:	30 09       	mov	r9,0
80002b9a:	fe f8 03 86 	ld.w	r8,pc[902]
80002b9e:	91 09       	st.w	r8[0x0],r9
	
	//static U8 frame_5_end = 0;
	//static U16 pay[256];
	
	//Send-AMBE-data
	if ((AMBE_tx_flag == TRUE) || (AMBE_rx_flag == TRUE))
80002ba0:	fe f8 03 94 	ld.w	r8,pc[916]
80002ba4:	11 89       	ld.ub	r9,r8[0x0]
80002ba6:	30 18       	mov	r8,1
80002ba8:	f0 09 18 00 	cp.b	r9,r8
80002bac:	c0 90       	breq	80002bbe <phy_tx_func+0x116>
80002bae:	fe f8 03 8a 	ld.w	r8,pc[906]
80002bb2:	11 89       	ld.ub	r9,r8[0x0]
80002bb4:	30 18       	mov	r8,1
80002bb6:	f0 09 18 00 	cp.b	r9,r8
80002bba:	e0 81 01 4e 	brne	80002e56 <phy_tx_func+0x3ae>
	{
		A_index = (A_index >=1456) ? 0 : A_index;
80002bbe:	fe f8 03 7e 	ld.w	r8,pc[894]
80002bc2:	70 08       	ld.w	r8,r8[0x0]
80002bc4:	e0 48 05 b0 	cp.w	r8,1456
80002bc8:	f9 b8 02 00 	movhs	r8,0
80002bcc:	fe f9 03 70 	ld.w	r9,pc[880]
80002bd0:	93 08       	st.w	r9[0x0],r8

	  //AMBE_flag
		switch(AMBEpayload_tx_state)
80002bd2:	fe f9 03 6e 	ld.w	r9,pc[878]
80002bd6:	72 09       	ld.w	r9,r9[0x0]
80002bd8:	58 29       	cp.w	r9,2
80002bda:	e0 80 00 91 	breq	80002cfc <phy_tx_func+0x254>
80002bde:	e0 8b 00 08 	brhi	80002bee <phy_tx_func+0x146>
80002be2:	58 09       	cp.w	r9,0
80002be4:	c0 e0       	breq	80002c00 <phy_tx_func+0x158>
80002be6:	58 19       	cp.w	r9,1
80002be8:	e0 81 01 2d 	brne	80002e42 <phy_tx_func+0x39a>
80002bec:	c5 78       	rjmp	80002c9a <phy_tx_func+0x1f2>
80002bee:	58 49       	cp.w	r9,4
80002bf0:	e0 80 00 c0 	breq	80002d70 <phy_tx_func+0x2c8>
80002bf4:	e0 83 00 9a 	brlo	80002d28 <phy_tx_func+0x280>
80002bf8:	58 59       	cp.w	r9,5
80002bfa:	e0 81 01 24 	brne	80002e42 <phy_tx_func+0x39a>
80002bfe:	c1 79       	rjmp	80002e2c <phy_tx_func+0x384>
		{
			case AMBE_IDLE:
		
				if ((m_RxBurstType == VOICE_WATING) || (m_RxBurstType == VOICETERMINATOR)  || (m_RxBurstType == VOICEHEADER))
80002c00:	fe f8 03 44 	ld.w	r8,pc[836]
80002c04:	70 08       	ld.w	r8,r8[0x0]
80002c06:	58 08       	cp.w	r8,0
80002c08:	c0 b0       	breq	80002c1e <phy_tx_func+0x176>
80002c0a:	fe f8 03 3a 	ld.w	r8,pc[826]
80002c0e:	70 08       	ld.w	r8,r8[0x0]
80002c10:	58 a8       	cp.w	r8,10
80002c12:	c0 60       	breq	80002c1e <phy_tx_func+0x176>
80002c14:	fe f8 03 30 	ld.w	r8,pc[816]
80002c18:	70 08       	ld.w	r8,r8[0x0]
80002c1a:	58 18       	cp.w	r8,1
80002c1c:	c0 a1       	brne	80002c30 <phy_tx_func+0x188>
				{
							
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002c1e:	e0 68 5a 5a 	mov	r8,23130
80002c22:	ea 18 ab cd 	orh	r8,0xabcd
80002c26:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002c28:	30 08       	mov	r8,0
80002c2a:	8f 38       	st.w	r7[0xc],r8
80002c2c:	e0 8f 01 75 	bral	80002f16 <phy_tx_func+0x46e>
			
				}
				else if((m_RxBurstType == UNSUREDATA))
80002c30:	fe f8 03 14 	ld.w	r8,pc[788]
80002c34:	70 08       	ld.w	r8,r8[0x0]
80002c36:	58 38       	cp.w	r8,3
80002c38:	c0 91       	brne	80002c4a <phy_tx_func+0x1a2>
				{
					payload_tx_channel->dword[0] = AMBE_HT[0];
80002c3a:	fe f8 03 0e 	ld.w	r8,pc[782]
80002c3e:	70 09       	ld.w	r9,r8[0x0]
80002c40:	8f 29       	st.w	r7[0x8],r9
					payload_tx_channel->dword[1] = AMBE_HT[1];
80002c42:	70 18       	ld.w	r8,r8[0x4]
80002c44:	8f 38       	st.w	r7[0xc],r8
80002c46:	e0 8f 01 68 	bral	80002f16 <phy_tx_func+0x46e>
				else//加密和解密的激励类型
				{
					
					//Radio Internal Parameter + Vocoder Bits Stream Parameter + 1st 20ms AMBE bits of Voice Burst A 
					//assemble 3 items into 1 Command. Send it to Radio.
					if (m_RxBurstType == RADIOINTERNAL)//解密数据
80002c4a:	fe f8 02 fa 	ld.w	r8,pc[762]
80002c4e:	70 08       	ld.w	r8,r8[0x0]
80002c50:	58 28       	cp.w	r8,2
80002c52:	c1 31       	brne	80002c78 <phy_tx_func+0x1d0>
					{
						//0xABCDCO14
						payload_tx_channel->dword[0] = DE_OB_PAYLOAD;//49bits
80002c54:	e0 68 c0 14 	mov	r8,49172
80002c58:	ea 18 ab cd 	orh	r8,0xabcd
80002c5c:	8f 28       	st.w	r7[0x8],r8
						//0x847F
						payload_tx_channel->word[2] = RIP_PAYLOAD;
80002c5e:	fe 78 84 7f 	mov	r8,-31617
80002c62:	ae 68       	st.h	r7[0xc],r8
						//0xxxxx
						payload_tx_channel->word[3] = Radio_Internal_Data[0];
80002c64:	fe f8 02 e8 	ld.w	r8,pc[744]
80002c68:	90 08       	ld.sh	r8,r8[0x0]
80002c6a:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_DE_FIRST;
80002c6c:	30 39       	mov	r9,3
80002c6e:	fe f8 02 d2 	ld.w	r8,pc[722]
80002c72:	91 09       	st.w	r8[0x0],r9
80002c74:	e0 8f 01 51 	bral	80002f16 <phy_tx_func+0x46e>
					
					else//加密数据
					{
	
						//0xABCDCOOE
						payload_tx_channel->dword[0] = EN_OB_PAYLOAD;//49bits
80002c78:	e0 68 c0 0e 	mov	r8,49166
80002c7c:	ea 18 ab cd 	orh	r8,0xabcd
80002c80:	8f 28       	st.w	r7[0x8],r8
						//0x8212
						payload_tx_channel->word[2] = VBSP_data[0];
80002c82:	fe f8 02 ce 	ld.w	r8,pc[718]
80002c86:	90 09       	ld.sh	r9,r8[0x0]
80002c88:	ae 69       	st.h	r7[0xc],r9
						//0xF00x
						payload_tx_channel->word[3] = VBSP_data[1];
80002c8a:	90 18       	ld.sh	r8,r8[0x2]
80002c8c:	ae 78       	st.h	r7[0xe],r8
						
						AMBEpayload_tx_state = AMBE_EN_FIRST;
80002c8e:	30 19       	mov	r9,1
80002c90:	fe f8 02 b0 	ld.w	r8,pc[688]
80002c94:	91 09       	st.w	r8[0x0],r9
80002c96:	e0 8f 01 40 	bral	80002f16 <phy_tx_func+0x46e>
			
			case AMBE_EN_FIRST:
			
			
				//0x88F2
				payload_tx_channel->word[0] = ENCODER_PAYLOAD;//49bits
80002c9a:	fe 78 88 f2 	mov	r8,-30478
80002c9e:	ae 48       	st.h	r7[0x8],r8
				
				payload_tx_channel->word[1] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002ca0:	fe f8 02 9c 	ld.w	r8,pc[668]
80002ca4:	70 0a       	ld.w	r10,r8[0x0]
80002ca6:	fe f9 02 ae 	ld.w	r9,pc[686]
80002caa:	f2 0a 00 0b 	add	r11,r9,r10
80002cae:	17 9b       	ld.ub	r11,r11[0x1]
80002cb0:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002cb4:	a9 6a       	lsl	r10,0x8
80002cb6:	f6 0a 00 0a 	add	r10,r11,r10
80002cba:	ae 5a       	st.h	r7[0xa],r10
				A_index+=2;
80002cbc:	70 0a       	ld.w	r10,r8[0x0]
80002cbe:	2f ea       	sub	r10,-2
80002cc0:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[2] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002cc2:	f2 0a 00 0b 	add	r11,r9,r10
80002cc6:	17 9b       	ld.ub	r11,r11[0x1]
80002cc8:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
80002ccc:	a9 6a       	lsl	r10,0x8
80002cce:	f6 0a 00 0a 	add	r10,r11,r10
80002cd2:	ae 6a       	st.h	r7[0xc],r10
				A_index+=2;
80002cd4:	70 0a       	ld.w	r10,r8[0x0]
80002cd6:	2f ea       	sub	r10,-2
80002cd8:	91 0a       	st.w	r8[0x0],r10
				
				payload_tx_channel->word[3] = ((AMBE_AudioData[A_index]<<8) + AMBE_AudioData[A_index+1]) ;
80002cda:	f2 0a 00 0b 	add	r11,r9,r10
80002cde:	17 9b       	ld.ub	r11,r11[0x1]
80002ce0:	f2 0a 07 09 	ld.ub	r9,r9[r10]
80002ce4:	a9 69       	lsl	r9,0x8
80002ce6:	f6 09 00 09 	add	r9,r11,r9
80002cea:	ae 79       	st.h	r7[0xe],r9
				A_index+=2;
80002cec:	70 09       	ld.w	r9,r8[0x0]
80002cee:	2f e9       	sub	r9,-2
80002cf0:	91 09       	st.w	r8[0x0],r9
				
				AMBEpayload_tx_state = AMBE_EN_LAST;
80002cf2:	30 29       	mov	r9,2
80002cf4:	fe f8 02 4c 	ld.w	r8,pc[588]
80002cf8:	91 09       	st.w	r8[0x0],r9
80002cfa:	c0 e9       	rjmp	80002f16 <phy_tx_func+0x46e>
						payload_tx_channel->word[0]	= ((Public_AMBEkey[3]) ^ (AMBEBurst_rawdata[3])) ;
					
					}
					
					***/
					payload_tx_channel->word[0] = ((AMBE_AudioData[A_index]<<8) + 0x00) ;//需要补充Pad_bits位
80002cfc:	fe f9 02 58 	ld.w	r9,pc[600]
80002d00:	f2 08 07 08 	ld.ub	r8,r9[r8]
80002d04:	a9 68       	lsl	r8,0x8
80002d06:	ae 48       	st.h	r7[0x8],r8
					A_index+=1;
80002d08:	fe f8 02 34 	ld.w	r8,pc[564]
80002d0c:	70 09       	ld.w	r9,r8[0x0]
80002d0e:	2f f9       	sub	r9,-1
80002d10:	91 09       	st.w	r8[0x0],r9
					
					payload_tx_channel->word[1]	= 0x00BA ; 
80002d12:	e0 68 00 ba 	mov	r8,186
80002d16:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002d18:	30 08       	mov	r8,0
80002d1a:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002d1c:	ae 78       	st.h	r7[0xe],r8
				
					AMBEpayload_tx_state = AMBE_IDLE;
80002d1e:	30 09       	mov	r9,0
80002d20:	fe f8 02 20 	ld.w	r8,pc[544]
80002d24:	91 09       	st.w	r8[0x0],r9
80002d26:	cf 88       	rjmp	80002f16 <phy_tx_func+0x46e>
				break;
				
			case AMBE_DE_FIRST:
				
					//0xxxxx
					payload_tx_channel->word[0] = Radio_Internal_Data[1];
80002d28:	fe f8 02 24 	ld.w	r8,pc[548]
80002d2c:	90 18       	ld.sh	r8,r8[0x2]
80002d2e:	ae 48       	st.h	r7[0x8],r8
					//0x8212
					payload_tx_channel->word[1] = VBSP_data[0];
80002d30:	fe f8 02 20 	ld.w	r8,pc[544]
80002d34:	90 08       	ld.sh	r8,r8[0x0]
80002d36:	ae 58       	st.h	r7[0xa],r8
					
					if ((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1) )
80002d38:	fe f8 02 0c 	ld.w	r8,pc[524]
80002d3c:	70 08       	ld.w	r8,r8[0x0]
80002d3e:	58 48       	cp.w	r8,4
80002d40:	c0 e1       	brne	80002d5c <phy_tx_func+0x2b4>
80002d42:	fe f8 02 16 	ld.w	r8,pc[534]
80002d46:	11 89       	ld.ub	r9,r8[0x0]
80002d48:	30 18       	mov	r8,1
80002d4a:	f0 09 18 00 	cp.b	r9,r8
80002d4e:	c0 71       	brne	80002d5c <phy_tx_func+0x2b4>
					{
						// Vocoder Bits Stream Parameter("E" flag = 1)
						//0xF08x
						payload_tx_channel->word[2] = ((VBSP_data[1]) | (0x0080));
80002d50:	fe f8 02 00 	ld.w	r8,pc[512]
80002d54:	90 18       	ld.sh	r8,r8[0x2]
80002d56:	a7 b8       	sbr	r8,0x7
80002d58:	ae 68       	st.h	r7[0xc],r8
80002d5a:	c0 48       	rjmp	80002d62 <phy_tx_func+0x2ba>
					}
					else
						//0xF00x
						payload_tx_channel->word[2] = (VBSP_data[1]) ;
80002d5c:	4f d8       	lddpc	r8,80002f50 <phy_tx_func+0x4a8>
80002d5e:	90 18       	ld.sh	r8,r8[0x2]
80002d60:	ae 68       	st.h	r7[0xc],r8
					
					//0x88F3
					payload_tx_channel->word[3] = DECODER_PAYLOAD;
80002d62:	fe 78 88 f3 	mov	r8,-30477
80002d66:	ae 78       	st.h	r7[0xe],r8
		
					AMBEpayload_tx_state = AMBE_DE_SECOND;
80002d68:	30 49       	mov	r9,4
80002d6a:	4f 68       	lddpc	r8,80002f40 <phy_tx_func+0x498>
80002d6c:	91 09       	st.w	r8[0x0],r9
80002d6e:	cd 48       	rjmp	80002f16 <phy_tx_func+0x46e>
					
				break;
			case AMBE_DE_SECOND:
					
				switch (m_RxBurstType)//在发送函数中去做解密处理
80002d70:	4f 58       	lddpc	r8,80002f44 <phy_tx_func+0x49c>
80002d72:	70 08       	ld.w	r8,r8[0x0]
80002d74:	58 48       	cp.w	r8,4
80002d76:	c0 60       	breq	80002d82 <phy_tx_func+0x2da>
80002d78:	c5 03       	brcs	80002e18 <phy_tx_func+0x370>
80002d7a:	58 98       	cp.w	r8,9
80002d7c:	e0 8b 00 4e 	brhi	80002e18 <phy_tx_func+0x370>
80002d80:	c3 38       	rjmp	80002de6 <phy_tx_func+0x33e>
				{
					case VOICEBURST_A:
							if (VF_SN == 1)
80002d82:	4f 68       	lddpc	r8,80002f58 <phy_tx_func+0x4b0>
80002d84:	11 89       	ld.ub	r9,r8[0x0]
80002d86:	30 18       	mov	r8,1
80002d88:	f0 09 18 00 	cp.b	r9,r8
80002d8c:	c1 41       	brne	80002db4 <phy_tx_func+0x30c>
							{	
								//Pick up public key
								
								AMBE_DecryptionKey[0] = AMBEBurst_rawdata[0];
80002d8e:	4f 48       	lddpc	r8,80002f5c <phy_tx_func+0x4b4>
80002d90:	90 0a       	ld.sh	r10,r8[0x0]
80002d92:	4f 49       	lddpc	r9,80002f60 <phy_tx_func+0x4b8>
80002d94:	b2 0a       	st.h	r9[0x0],r10
								AMBE_DecryptionKey[1] = AMBEBurst_rawdata[1];
80002d96:	90 1a       	ld.sh	r10,r8[0x2]
80002d98:	b2 1a       	st.h	r9[0x2],r10
								AMBE_DecryptionKey[2] = AMBEBurst_rawdata[2];
80002d9a:	90 2a       	ld.sh	r10,r8[0x4]
80002d9c:	b2 2a       	st.h	r9[0x4],r10
								AMBE_DecryptionKey[3] = AMBEBurst_rawdata[3];
80002d9e:	90 3a       	ld.sh	r10,r8[0x6]
80002da0:	b2 3a       	st.h	r9[0x6],r10
								
								//Post back data
								payload_tx_channel->word[0] = AMBEBurst_rawdata[0] ;
80002da2:	90 09       	ld.sh	r9,r8[0x0]
80002da4:	ae 49       	st.h	r7[0x8],r9
								payload_tx_channel->word[1] = AMBEBurst_rawdata[1] ;
80002da6:	90 19       	ld.sh	r9,r8[0x2]
80002da8:	ae 59       	st.h	r7[0xa],r9
								payload_tx_channel->word[2] = AMBEBurst_rawdata[2] ;
80002daa:	90 29       	ld.sh	r9,r8[0x4]
80002dac:	ae 69       	st.h	r7[0xc],r9
								payload_tx_channel->word[3] = AMBEBurst_rawdata[3] ;
80002dae:	90 38       	ld.sh	r8,r8[0x6]
80002db0:	ae 78       	st.h	r7[0xe],r8
80002db2:	c1 68       	rjmp	80002dde <phy_tx_func+0x336>
								
								
						
								//Decrypt AMBE data(XOR) 
								//Recover data
								payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002db4:	4e b9       	lddpc	r9,80002f60 <phy_tx_func+0x4b8>
80002db6:	92 0a       	ld.sh	r10,r9[0x0]
80002db8:	4e 98       	lddpc	r8,80002f5c <phy_tx_func+0x4b4>
80002dba:	90 0b       	ld.sh	r11,r8[0x0]
80002dbc:	f7 ea 20 0a 	eor	r10,r11,r10
80002dc0:	ae 4a       	st.h	r7[0x8],r10
								payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002dc2:	92 1a       	ld.sh	r10,r9[0x2]
80002dc4:	90 1b       	ld.sh	r11,r8[0x2]
80002dc6:	f7 ea 20 0a 	eor	r10,r11,r10
80002dca:	ae 5a       	st.h	r7[0xa],r10
								payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002dcc:	92 2a       	ld.sh	r10,r9[0x4]
80002dce:	90 2b       	ld.sh	r11,r8[0x4]
80002dd0:	f7 ea 20 0a 	eor	r10,r11,r10
80002dd4:	ae 6a       	st.h	r7[0xc],r10
								payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002dd6:	92 39       	ld.sh	r9,r9[0x6]
80002dd8:	90 38       	ld.sh	r8,r8[0x6]
80002dda:	12 58       	eor	r8,r9
80002ddc:	ae 78       	st.h	r7[0xe],r8
								//payload_tx_channel->word[3] = AMBEBurst_rawdata[2];
							
						
							}
					
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002dde:	30 59       	mov	r9,5
80002de0:	4d 88       	lddpc	r8,80002f40 <phy_tx_func+0x498>
80002de2:	91 09       	st.w	r8[0x0],r9
80002de4:	c9 98       	rjmp	80002f16 <phy_tx_func+0x46e>
						
							//Encrypted AMBE data(XOR)
						
							//Decrypt AMBE data(XOR)
							//Recover data
							payload_tx_channel->word[0] = ((AMBE_DecryptionKey[0]) ^ (AMBEBurst_rawdata[0])) ;
80002de6:	4d f9       	lddpc	r9,80002f60 <phy_tx_func+0x4b8>
80002de8:	92 0a       	ld.sh	r10,r9[0x0]
80002dea:	4d d8       	lddpc	r8,80002f5c <phy_tx_func+0x4b4>
80002dec:	90 0b       	ld.sh	r11,r8[0x0]
80002dee:	f7 ea 20 0a 	eor	r10,r11,r10
80002df2:	ae 4a       	st.h	r7[0x8],r10
							payload_tx_channel->word[1] = ((AMBE_DecryptionKey[1]) ^ (AMBEBurst_rawdata[1])) ;
80002df4:	92 1a       	ld.sh	r10,r9[0x2]
80002df6:	90 1b       	ld.sh	r11,r8[0x2]
80002df8:	f7 ea 20 0a 	eor	r10,r11,r10
80002dfc:	ae 5a       	st.h	r7[0xa],r10
							payload_tx_channel->word[2] = ((AMBE_DecryptionKey[2]) ^ (AMBEBurst_rawdata[2])) ;
80002dfe:	92 2a       	ld.sh	r10,r9[0x4]
80002e00:	90 2b       	ld.sh	r11,r8[0x4]
80002e02:	f7 ea 20 0a 	eor	r10,r11,r10
80002e06:	ae 6a       	st.h	r7[0xc],r10
							payload_tx_channel->word[3] = ((AMBE_DecryptionKey[3]) ^ (AMBEBurst_rawdata[3])) ;
80002e08:	92 39       	ld.sh	r9,r9[0x6]
80002e0a:	90 38       	ld.sh	r8,r8[0x6]
80002e0c:	12 58       	eor	r8,r9
80002e0e:	ae 78       	st.h	r7[0xe],r8
						
							AMBEpayload_tx_state = AMBE_DE_LAST;
80002e10:	30 59       	mov	r9,5
80002e12:	4c c8       	lddpc	r8,80002f40 <phy_tx_func+0x498>
80002e14:	91 09       	st.w	r8[0x0],r9
80002e16:	c8 08       	rjmp	80002f16 <phy_tx_func+0x46e>
				
						break;
					default://This shouldn't happen, but must check;
					
							payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e18:	e0 68 5a 5a 	mov	r8,23130
80002e1c:	ea 18 ab cd 	orh	r8,0xabcd
80002e20:	8f 28       	st.w	r7[0x8],r8
							payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e22:	30 08       	mov	r8,0
80002e24:	8f 38       	st.w	r7[0xc],r8
							AMBEpayload_tx_state = AMBE_IDLE;
80002e26:	4c 79       	lddpc	r9,80002f40 <phy_tx_func+0x498>
80002e28:	93 08       	st.w	r9[0x0],r8
80002e2a:	c7 68       	rjmp	80002f16 <phy_tx_func+0x46e>
		
				break;
				
			case AMBE_DE_LAST:
				
					payload_tx_channel->word[0]	= 0x00BA ;
80002e2c:	e0 68 00 ba 	mov	r8,186
80002e30:	ae 48       	st.h	r7[0x8],r8
					payload_tx_channel->word[1]	= 0x0000 ;
80002e32:	30 08       	mov	r8,0
80002e34:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2]	= 0x0000 ;
80002e36:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3]	= 0x0000 ;
80002e38:	ae 78       	st.h	r7[0xe],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002e3a:	30 09       	mov	r9,0
80002e3c:	4c 18       	lddpc	r8,80002f40 <phy_tx_func+0x498>
80002e3e:	91 09       	st.w	r8[0x0],r9
80002e40:	c6 b8       	rjmp	80002f16 <phy_tx_func+0x46e>
				
				break;
		
			default:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e42:	e0 68 5a 5a 	mov	r8,23130
80002e46:	ea 18 ab cd 	orh	r8,0xabcd
80002e4a:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e4c:	30 08       	mov	r8,0
80002e4e:	8f 38       	st.w	r7[0xc],r8
					
					AMBEpayload_tx_state = AMBE_IDLE;
80002e50:	4b c9       	lddpc	r9,80002f40 <phy_tx_func+0x498>
80002e52:	93 08       	st.w	r9[0x0],r8
80002e54:	c6 18       	rjmp	80002f16 <phy_tx_func+0x46e>

	else//Send-PCM-data（注意测试回放时：数字信道码流为320bytes/20ms)
	{
		
		
		Payload_frame_DATA_1 = ((PCM_frame_Payload[0]<<16) | (PCM_frame_Payload[1]));
80002e56:	4c 49       	lddpc	r9,80002f64 <phy_tx_func+0x4bc>
80002e58:	92 0a       	ld.sh	r10,r9[0x0]
80002e5a:	92 18       	ld.sh	r8,r9[0x2]
80002e5c:	5c 78       	castu.h	r8
80002e5e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80002e62:	4c 2a       	lddpc	r10,80002f68 <phy_tx_func+0x4c0>
80002e64:	95 08       	st.w	r10[0x0],r8
		Payload_frame_DATA_2 = ((PCM_frame_Payload[2]<<16) | (PCM_frame_Payload[3]));
80002e66:	92 2a       	ld.sh	r10,r9[0x4]
80002e68:	92 39       	ld.sh	r9,r9[0x6]
80002e6a:	5c 79       	castu.h	r9
80002e6c:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80002e70:	4b fa       	lddpc	r10,80002f6c <phy_tx_func+0x4c4>
80002e72:	95 09       	st.w	r10[0x0],r9
		
		
		
		if ((Payload_frame_DATA_1 == PAYLOADIDLE0) && (Payload_frame_DATA_2 == PAYLOADIDLE1))//loop IDLE frame
80002e74:	e0 6b 5a 5a 	mov	r11,23130
80002e78:	ea 1b ab cd 	orh	r11,0xabcd
80002e7c:	16 38       	cp.w	r8,r11
80002e7e:	c1 01       	brne	80002e9e <phy_tx_func+0x3f6>
80002e80:	58 09       	cp.w	r9,0
80002e82:	c0 60       	breq	80002e8e <phy_tx_func+0x3e6>
80002e84:	e0 69 50 00 	mov	r9,20480
80002e88:	ea 19 ab cd 	orh	r9,0xabcd
80002e8c:	c1 98       	rjmp	80002ebe <phy_tx_func+0x416>
		{
			payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002e8e:	e0 68 5a 5a 	mov	r8,23130
80002e92:	ea 18 ab cd 	orh	r8,0xabcd
80002e96:	8f 28       	st.w	r7[0x8],r8
			payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002e98:	30 08       	mov	r8,0
80002e9a:	8f 38       	st.w	r7[0xc],r8
80002e9c:	c3 d8       	rjmp	80002f16 <phy_tx_func+0x46e>
		{
		
			//if((Radio_Transmit_State == 1) && (Mic_is_Enabled == 1))//加密发送
			{//发送方加密
						
				if ( ((Payload_frame_DATA_1 & 0xFFFFF000) == 0xABCD2000)
80002e9e:	10 99       	mov	r9,r8
80002ea0:	e0 19 f0 00 	andl	r9,0xf000
80002ea4:	e0 6a 20 00 	mov	r10,8192
80002ea8:	ea 1a ab cd 	orh	r10,0xabcd
80002eac:	14 39       	cp.w	r9,r10
80002eae:	c1 30       	breq	80002ed4 <phy_tx_func+0x42c>
80002eb0:	10 9a       	mov	r10,r8
80002eb2:	e0 1a 00 00 	andl	r10,0x0
80002eb6:	fc 1b 00 ba 	movh	r11,0xba
80002eba:	16 3a       	cp.w	r10,r11
80002ebc:	c0 c0       	breq	80002ed4 <phy_tx_func+0x42c>
80002ebe:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80002ec2:	e0 4a 00 ba 	cp.w	r10,186
80002ec6:	c0 70       	breq	80002ed4 <phy_tx_func+0x42c>
80002ec8:	e0 6a 10 00 	mov	r10,4096
80002ecc:	ea 1a ab cd 	orh	r10,0xabcd
80002ed0:	14 39       	cp.w	r9,r10
80002ed2:	c0 61       	brne	80002ede <phy_tx_func+0x436>
				|| ((Payload_frame_DATA_1 & 0xFFFF0000) == 0x00BA0000) || ((Payload_frame_DATA_1 & 0x0000FFFF) == 0x000000BA)
				|| ((Payload_frame_DATA_1 & 0xFFFFF000) == 0xABCD1000))
				{
			
				
					payload_tx_channel->dword[0] = Payload_frame_DATA_1;
80002ed4:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = Payload_frame_DATA_2;
80002ed6:	4a 68       	lddpc	r8,80002f6c <phy_tx_func+0x4c4>
80002ed8:	70 08       	ld.w	r8,r8[0x0]
80002eda:	8f 38       	st.w	r7[0xc],r8
80002edc:	c1 d8       	rjmp	80002f16 <phy_tx_func+0x46e>
				
				}
				else//PCM encryption
				{
					if (Silent_flag)
80002ede:	4a 59       	lddpc	r9,80002f70 <phy_tx_func+0x4c8>
80002ee0:	13 8a       	ld.ub	r10,r9[0x0]
80002ee2:	30 09       	mov	r9,0
80002ee4:	f2 0a 18 00 	cp.b	r10,r9
80002ee8:	c0 60       	breq	80002ef4 <phy_tx_func+0x44c>
					{
						payload_tx_channel->dword[0] = Payload_frame_DATA_1;
80002eea:	8f 28       	st.w	r7[0x8],r8
						payload_tx_channel->dword[1] = Payload_frame_DATA_2;
80002eec:	4a 08       	lddpc	r8,80002f6c <phy_tx_func+0x4c4>
80002eee:	70 08       	ld.w	r8,r8[0x0]
80002ef0:	8f 38       	st.w	r7[0xc],r8
80002ef2:	c1 28       	rjmp	80002f16 <phy_tx_func+0x46e>

					}
					else
					{
				
						payload_tx_channel->word[0] = (PCM_frame_Payload[0]);
80002ef4:	49 c8       	lddpc	r8,80002f64 <phy_tx_func+0x4bc>
80002ef6:	90 09       	ld.sh	r9,r8[0x0]
80002ef8:	ae 49       	st.h	r7[0x8],r9
						payload_tx_channel->word[1] = (PCM_frame_Payload[1]);
80002efa:	90 19       	ld.sh	r9,r8[0x2]
80002efc:	ae 59       	st.h	r7[0xa],r9
						payload_tx_channel->word[2] = (PCM_frame_Payload[2] ^ Public_PCMkey);
80002efe:	90 29       	ld.sh	r9,r8[0x4]
80002f00:	ee 19 ff ff 	eorh	r9,0xffff
80002f04:	ec 19 b2 f5 	eorl	r9,0xb2f5
80002f08:	ae 69       	st.h	r7[0xc],r9
						payload_tx_channel->word[3] = (PCM_frame_Payload[3] ^ Public_PCMkey);//加密方有bug,尝试用逻辑分析仪查看
80002f0a:	90 38       	ld.sh	r8,r8[0x6]
80002f0c:	ee 18 ff ff 	eorh	r8,0xffff
80002f10:	ec 18 b2 f5 	eorl	r8,0xb2f5
80002f14:	ae 78       	st.h	r7[0xe],r8
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002f16:	2f fd       	sub	sp,-4
80002f18:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002f1c:	00 00       	add	r0,r0
80002f1e:	0a d0       	st.w	--r5,r0
80002f20:	00 00       	add	r0,r0
80002f22:	0a ac       	st.w	r5++,r12
80002f24:	00 00       	add	r0,r0
80002f26:	0a 84       	andn	r4,r5
80002f28:	80 00       	ld.sh	r0,r0[0x0]
80002f2a:	55 a4       	stdsp	sp[0x168],r4
80002f2c:	00 00       	add	r0,r0
80002f2e:	0a cc       	st.b	r5++,r12
80002f30:	00 00       	add	r0,r0
80002f32:	0a 90       	mov	r0,r5
80002f34:	00 00       	add	r0,r0
80002f36:	0a 50       	eor	r0,r5
80002f38:	00 00       	add	r0,r0
80002f3a:	0a 52       	eor	r2,r5
80002f3c:	00 00       	add	r0,r0
80002f3e:	0a 7c       	tst	r12,r5
80002f40:	00 00       	add	r0,r0
80002f42:	0a a8       	st.w	r5++,r8
80002f44:	00 00       	add	r0,r0
80002f46:	0a 68       	and	r8,r5
80002f48:	00 00       	add	r0,r0
80002f4a:	0a 98       	mov	r8,r5
80002f4c:	00 00       	add	r0,r0
80002f4e:	0d bc       	ld.ub	r12,r6[0x3]
80002f50:	00 00       	add	r0,r0
80002f52:	0e b8       	st.h	r7++,r8
80002f54:	80 00       	ld.sh	r0,r0[0x0]
80002f56:	cd d8       	rjmp	80003110 <phy_rx_func+0x48>
80002f58:	00 00       	add	r0,r0
80002f5a:	0a 54       	eor	r4,r5
80002f5c:	00 00       	add	r0,r0
80002f5e:	0d b4       	ld.ub	r4,r6[0x3]
80002f60:	00 00       	add	r0,r0
80002f62:	0d c0       	ld.ub	r0,r6[0x4]
80002f64:	00 00       	add	r0,r0
80002f66:	04 f4       	st.b	--r2,r4
80002f68:	00 00       	add	r0,r0
80002f6a:	0a dc       	st.w	--r5,r12
80002f6c:	00 00       	add	r0,r0
80002f6e:	0a 88       	andn	r8,r5
80002f70:	00 00       	add	r0,r0
80002f72:	0a 56       	eor	r6,r5

80002f74 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002f74:	d4 01       	pushm	lr
80002f76:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002f78:	30 0a       	mov	r10,0
80002f7a:	fa cb ff fc 	sub	r11,sp,-4
80002f7e:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002f80:	14 99       	mov	r9,r10
80002f82:	1a 9b       	mov	r11,sp
80002f84:	f0 1f 00 05 	mcall	80002f98 <get_idle_store+0x24>
80002f88:	58 1c       	cp.w	r12,1
80002f8a:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002f8e:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002f92:	2f fd       	sub	sp,-4
80002f94:	d8 02       	popm	pc
80002f96:	00 00       	add	r0,r0
80002f98:	80 00       	ld.sh	r0,r0[0x0]
80002f9a:	56 94       	stdsp	sp[0x1a4],r4

80002f9c <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002f9c:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002fa0:	f0 1f 00 24 	mcall	80003030 <phy_init+0x94>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002fa4:	4a 4b       	lddpc	r11,80003034 <phy_init+0x98>
80002fa6:	4a 5c       	lddpc	r12,80003038 <phy_init+0x9c>
80002fa8:	f0 1f 00 25 	mcall	8000303c <phy_init+0xa0>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002fac:	30 4b       	mov	r11,4
80002fae:	31 ec       	mov	r12,30
80002fb0:	f0 1f 00 24 	mcall	80003040 <phy_init+0xa4>
80002fb4:	4a 48       	lddpc	r8,80003044 <phy_init+0xa8>
80002fb6:	91 0c       	st.w	r8[0x0],r12
80002fb8:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002fba:	10 96       	mov	r6,r8
80002fbc:	4a 35       	lddpc	r5,80003048 <phy_init+0xac>
80002fbe:	6c 0c       	ld.w	r12,r6[0x0]
80002fc0:	ea 07 00 0b 	add	r11,r5,r7
80002fc4:	f0 1f 00 22 	mcall	8000304c <phy_init+0xb0>
80002fc8:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002fcc:	e0 47 1e 00 	cp.w	r7,7680
80002fd0:	cf 71       	brne	80002fbe <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002fd2:	30 4b       	mov	r11,4
80002fd4:	31 4c       	mov	r12,20
80002fd6:	f0 1f 00 1b 	mcall	80003040 <phy_init+0xa4>
80002fda:	49 e8       	lddpc	r8,80003050 <phy_init+0xb4>
80002fdc:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002fde:	30 4b       	mov	r11,4
80002fe0:	30 ac       	mov	r12,10
80002fe2:	f0 1f 00 18 	mcall	80003040 <phy_init+0xa4>
80002fe6:	49 c8       	lddpc	r8,80003054 <phy_init+0xb8>
80002fe8:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002fea:	30 4b       	mov	r11,4
80002fec:	30 ac       	mov	r12,10
80002fee:	f0 1f 00 15 	mcall	80003040 <phy_init+0xa4>
80002ff2:	49 a8       	lddpc	r8,80003058 <phy_init+0xbc>
80002ff4:	91 0c       	st.w	r8[0x0],r12
80002ff6:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002ff8:	10 96       	mov	r6,r8
80002ffa:	49 95       	lddpc	r5,8000305c <phy_init+0xc0>
80002ffc:	6c 0c       	ld.w	r12,r6[0x0]
80002ffe:	ea 07 00 0b 	add	r11,r5,r7
80003002:	f0 1f 00 13 	mcall	8000304c <phy_init+0xb0>
80003006:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
8000300a:	e0 47 14 00 	cp.w	r7,5120
8000300e:	cf 71       	brne	80002ffc <phy_init+0x60>
		
	/*initialize the queue to send/receive xnl packet */
	
		
	phy_payload_frame_rx =
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80003010:	30 4b       	mov	r11,4
80003012:	30 5c       	mov	r12,5
80003014:	f0 1f 00 0b 	mcall	80003040 <phy_init+0xa4>
	}
		
	/*initialize the queue to send/receive xnl packet */
	
		
	phy_payload_frame_rx =
80003018:	49 28       	lddpc	r8,80003060 <phy_init+0xc4>
8000301a:	91 0c       	st.w	r8[0x0],r12
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));//未知bug不能屏蔽
8000301c:	e0 6b 01 00 	mov	r11,256
80003020:	30 5c       	mov	r12,5
80003022:	f0 1f 00 08 	mcall	80003040 <phy_init+0xa4>
	
		
	phy_payload_frame_rx =
	xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	phy_payload_frame_tx =
80003026:	49 08       	lddpc	r8,80003064 <phy_init+0xc8>
80003028:	91 0c       	st.w	r8[0x0],r12
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));//未知bug不能屏蔽
	#endif /*end if*/
	
}
8000302a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000302e:	00 00       	add	r0,r0
80003030:	80 00       	ld.sh	r0,r0[0x0]
80003032:	40 c0       	lddsp	r0,sp[0x30]
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	2a a8       	sub	r8,-86
80003038:	80 00       	ld.sh	r0,r0[0x0]
8000303a:	30 c8       	mov	r8,12
8000303c:	80 00       	ld.sh	r0,r0[0x0]
8000303e:	40 ac       	lddsp	r12,sp[0x28]
80003040:	80 00       	ld.sh	r0,r0[0x0]
80003042:	59 f8       	cp.w	r8,31
80003044:	00 00       	add	r0,r0
80003046:	0a b8       	st.h	r5++,r8
80003048:	00 00       	add	r0,r0
8000304a:	22 bc       	sub	r12,43
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	2a 04       	sub	r4,-96
80003050:	00 00       	add	r0,r0
80003052:	0a d0       	st.w	--r5,r0
80003054:	00 00       	add	r0,r0
80003056:	0a bc       	st.h	r5++,r12
80003058:	00 00       	add	r0,r0
8000305a:	0a 70       	tst	r0,r5
8000305c:	00 00       	add	r0,r0
8000305e:	0e bc       	st.h	r7++,r12
80003060:	00 00       	add	r0,r0
80003062:	0a 74       	tst	r4,r5
80003064:	00 00       	add	r0,r0
80003066:	0a c8       	st.b	r5++,r8

80003068 <payload_rx>:




static void payload_rx(void * payload)
{
80003068:	d4 01       	pushm	lr
8000306a:	20 2d       	sub	sp,8
8000306c:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
8000306e:	30 08       	mov	r8,0
80003070:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80003072:	48 f8       	lddpc	r8,800030ac <payload_rx+0x44>
80003074:	70 08       	ld.w	r8,r8[0x0]
80003076:	58 08       	cp.w	r8,0
80003078:	c0 71       	brne	80003086 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
8000307a:	30 4b       	mov	r11,4
8000307c:	30 5c       	mov	r12,5
8000307e:	f0 1f 00 0d 	mcall	800030b0 <payload_rx+0x48>
80003082:	48 b8       	lddpc	r8,800030ac <payload_rx+0x44>
80003084:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80003086:	48 a8       	lddpc	r8,800030ac <payload_rx+0x44>
80003088:	70 0c       	ld.w	r12,r8[0x0]
8000308a:	30 09       	mov	r9,0
8000308c:	fa ca ff fc 	sub	r10,sp,-4
80003090:	1a 9b       	mov	r11,sp
80003092:	f0 1f 00 09 	mcall	800030b4 <payload_rx+0x4c>
80003096:	c0 91       	brne	800030a8 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80003098:	48 88       	lddpc	r8,800030b8 <payload_rx+0x50>
8000309a:	70 0c       	ld.w	r12,r8[0x0]
8000309c:	40 0b       	lddsp	r11,sp[0x0]
8000309e:	f0 1f 00 08 	mcall	800030bc <payload_rx+0x54>
		logFromISR("mm");//触发未知BUG时，此处会被触发。
800030a2:	48 8c       	lddpc	r12,800030c0 <payload_rx+0x58>
800030a4:	f0 1f 00 08 	mcall	800030c4 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
800030a8:	2f ed       	sub	sp,-8
800030aa:	d8 02       	popm	pc
800030ac:	00 00       	add	r0,r0
800030ae:	0a 74       	tst	r4,r5
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	59 f8       	cp.w	r8,31
800030b4:	80 00       	ld.sh	r0,r0[0x0]
800030b6:	58 50       	cp.w	r0,5
800030b8:	00 00       	add	r0,r0
800030ba:	0a 70       	tst	r0,r5
800030bc:	80 00       	ld.sh	r0,r0[0x0]
800030be:	29 b0       	sub	r0,-101
800030c0:	80 00       	ld.sh	r0,r0[0x0]
800030c2:	d3 94       	*unknown*
800030c4:	80 00       	ld.sh	r0,r0[0x0]
800030c6:	66 1c       	ld.w	r12,r3[0x4]

800030c8 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
800030c8:	eb cd 40 e0 	pushm	r5-r7,lr
800030cc:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
800030ce:	fe f8 0e 16 	ld.w	r8,pc[3606]
800030d2:	70 08       	ld.w	r8,r8[0x0]
800030d4:	58 08       	cp.w	r8,0
800030d6:	e0 80 01 05 	breq	800032e0 <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
800030da:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
800030dc:	fe f8 0e 0c 	ld.w	r8,pc[3596]
800030e0:	70 09       	ld.w	r9,r8[0x0]
800030e2:	2f f9       	sub	r9,-1
800030e4:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
800030e6:	fe f8 0e 06 	ld.w	r8,pc[3590]
800030ea:	70 08       	ld.w	r8,r8[0x0]
800030ec:	58 18       	cp.w	r8,1
800030ee:	e0 80 00 84 	breq	800031f6 <phy_rx_func+0x12e>
800030f2:	c0 73       	brcs	80003100 <phy_rx_func+0x38>
800030f4:	58 28       	cp.w	r8,2
800030f6:	c5 b0       	breq	800031ac <phy_rx_func+0xe4>
800030f8:	58 38       	cp.w	r8,3
800030fa:	e0 81 00 f3 	brne	800032e0 <phy_rx_func+0x218>
800030fe:	cd 38       	rjmp	800032a4 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80003100:	e0 6a 5a 5a 	mov	r10,23130
80003104:	ea 1a ab cd 	orh	r10,0xabcd
80003108:	14 36       	cp.w	r6,r10
8000310a:	e0 80 00 eb 	breq	800032e0 <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000310e:	ec 08 16 10 	lsr	r8,r6,0x10
80003112:	e0 48 ab cd 	cp.w	r8,43981
80003116:	e0 81 00 e5 	brne	800032e0 <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
8000311a:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000311e:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80003122:	20 28       	sub	r8,2
80003124:	fe f9 0d cc 	ld.w	r9,pc[3532]
80003128:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
8000312a:	30 09       	mov	r9,0
8000312c:	f2 08 19 00 	cp.h	r8,r9
80003130:	e0 8a 00 d8 	brle	800032e0 <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80003134:	fe f8 0d c0 	ld.w	r8,pc[3520]
80003138:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
8000313a:	fe f8 0d be 	ld.w	r8,pc[3518]
8000313e:	70 0c       	ld.w	r12,r8[0x0]
80003140:	f0 1f 03 6f 	mcall	80003efc <phy_rx_func+0xe34>
80003144:	fe f8 0d bc 	ld.w	r8,pc[3516]
80003148:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
8000314a:	58 0c       	cp.w	r12,0
8000314c:	e0 80 00 ca 	breq	800032e0 <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80003150:	fe f8 0d a4 	ld.w	r8,pc[3492]
80003154:	90 09       	ld.sh	r9,r8[0x0]
80003156:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
8000315a:	2f f9       	sub	r9,-1
8000315c:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000315e:	fe fa 0d a2 	ld.w	r10,pc[3490]
80003162:	74 0a       	ld.w	r10,r10[0x0]
80003164:	fe fb 0d 84 	ld.w	r11,pc[3460]
80003168:	76 0b       	ld.w	r11,r11[0x0]
8000316a:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000316e:	2f f9       	sub	r9,-1
80003170:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80003172:	e2 16 0f 00 	andl	r6,0xf00,COH
80003176:	e0 46 01 00 	cp.w	r6,256
8000317a:	c0 c0       	breq	80003192 <phy_rx_func+0xca>
8000317c:	e0 8b 00 05 	brhi	80003186 <phy_rx_func+0xbe>
80003180:	58 06       	cp.w	r6,0
80003182:	c0 80       	breq	80003192 <phy_rx_func+0xca>
80003184:	c0 c8       	rjmp	8000319c <phy_rx_func+0xd4>
80003186:	e0 46 02 00 	cp.w	r6,512
8000318a:	c0 40       	breq	80003192 <phy_rx_func+0xca>
8000318c:	e0 46 03 00 	cp.w	r6,768
80003190:	c0 61       	brne	8000319c <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80003192:	30 29       	mov	r9,2
80003194:	fe f8 0d 58 	ld.w	r8,pc[3416]
80003198:	91 09       	st.w	r8[0x0],r9
8000319a:	ca 38       	rjmp	800032e0 <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
8000319c:	fe f6 0d 64 	ld.w	r6,pc[3428]
800031a0:	6c 0c       	ld.w	r12,r6[0x0]
800031a2:	f0 1f 03 59 	mcall	80003f04 <phy_rx_func+0xe3c>
					phy_frame_ptr = NULL;					
800031a6:	30 08       	mov	r8,0
800031a8:	8d 08       	st.w	r6[0x0],r8
800031aa:	c9 b8       	rjmp	800032e0 <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800031ac:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800031b0:	b1 86       	lsr	r6,0x10
800031b2:	14 06       	add	r6,r10
800031b4:	fe f8 0d 54 	ld.w	r8,pc[3412]
800031b8:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800031ba:	fe f8 0d 3a 	ld.w	r8,pc[3386]
800031be:	90 09       	ld.sh	r9,r8[0x0]
800031c0:	fe fb 0d 40 	ld.w	r11,pc[3392]
800031c4:	76 0b       	ld.w	r11,r11[0x0]
800031c6:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800031ca:	2f f9       	sub	r9,-1
800031cc:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800031ce:	fe f9 0d 22 	ld.w	r9,pc[3362]
800031d2:	92 08       	ld.sh	r8,r9[0x0]
800031d4:	20 28       	sub	r8,2
800031d6:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
800031d8:	30 09       	mov	r9,0
800031da:	f2 08 19 00 	cp.h	r8,r9
800031de:	e0 8a 00 07 	brle	800031ec <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
800031e2:	30 19       	mov	r9,1
800031e4:	fe f8 0d 08 	ld.w	r8,pc[3336]
800031e8:	91 09       	st.w	r8[0x0],r9
800031ea:	c7 b8       	rjmp	800032e0 <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
800031ec:	30 39       	mov	r9,3
800031ee:	fe f8 0c fe 	ld.w	r8,pc[3326]
800031f2:	91 09       	st.w	r8[0x0],r9
800031f4:	c7 68       	rjmp	800032e0 <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
800031f6:	ec 0a 14 10 	asr	r10,r6,0x10
800031fa:	fe f8 0d 0e 	ld.w	r8,pc[3342]
800031fe:	90 09       	ld.sh	r9,r8[0x0]
80003200:	14 09       	add	r9,r10
80003202:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003204:	fe f9 0c f0 	ld.w	r9,pc[3312]
80003208:	92 08       	ld.sh	r8,r9[0x0]
8000320a:	fe fb 0c f6 	ld.w	r11,pc[3318]
8000320e:	76 0b       	ld.w	r11,r11[0x0]
80003210:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003214:	2f f8       	sub	r8,-1
80003216:	5c 88       	casts.h	r8
80003218:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
8000321a:	fe fa 0c d6 	ld.w	r10,pc[3286]
8000321e:	94 09       	ld.sh	r9,r10[0x0]
80003220:	20 29       	sub	r9,2
80003222:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003224:	30 0a       	mov	r10,0
80003226:	f4 09 19 00 	cp.h	r9,r10
8000322a:	e0 89 00 1f 	brgt	80003268 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000322e:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003232:	e0 46 00 ba 	cp.w	r6,186
80003236:	c0 d1       	brne	80003250 <phy_rx_func+0x188>
80003238:	fe f8 0c d0 	ld.w	r8,pc[3280]
8000323c:	90 09       	ld.sh	r9,r8[0x0]
8000323e:	f4 09 19 00 	cp.h	r9,r10
80003242:	c0 71       	brne	80003250 <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003244:	fe f8 0c bc 	ld.w	r8,pc[3260]
80003248:	70 0c       	ld.w	r12,r8[0x0]
8000324a:	f0 1f 03 31 	mcall	80003f0c <phy_rx_func+0xe44>
8000324e:	c0 88       	rjmp	8000325e <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
80003250:	fe f6 0c b0 	ld.w	r6,pc[3248]
80003254:	6c 0c       	ld.w	r12,r6[0x0]
80003256:	f0 1f 03 2c 	mcall	80003f04 <phy_rx_func+0xe3c>
					phy_frame_ptr = NULL;
8000325a:	30 08       	mov	r8,0
8000325c:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000325e:	30 09       	mov	r9,0
80003260:	fe f8 0c 8c 	ld.w	r8,pc[3212]
80003264:	91 09       	st.w	r8[0x0],r9
80003266:	c3 d8       	rjmp	800032e0 <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003268:	5c 86       	casts.h	r6
8000326a:	fe f9 0c 9e 	ld.w	r9,pc[3230]
8000326e:	92 0a       	ld.sh	r10,r9[0x0]
80003270:	0c 0a       	add	r10,r6
80003272:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003274:	fe f9 0c 8c 	ld.w	r9,pc[3212]
80003278:	72 09       	ld.w	r9,r9[0x0]
8000327a:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
8000327e:	2f f8       	sub	r8,-1
80003280:	fe f9 0c 74 	ld.w	r9,pc[3188]
80003284:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80003286:	fe f9 0c 6a 	ld.w	r9,pc[3178]
8000328a:	92 08       	ld.sh	r8,r9[0x0]
8000328c:	20 28       	sub	r8,2
8000328e:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80003290:	30 09       	mov	r9,0
80003292:	f2 08 19 00 	cp.h	r8,r9
80003296:	e0 89 00 25 	brgt	800032e0 <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
8000329a:	30 39       	mov	r9,3
8000329c:	fe f8 0c 50 	ld.w	r8,pc[3152]
800032a0:	91 09       	st.w	r8[0x0],r9
800032a2:	c1 f8       	rjmp	800032e0 <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800032a4:	e6 16 00 ff 	andh	r6,0xff,COH
800032a8:	fc 19 00 ba 	movh	r9,0xba
800032ac:	12 36       	cp.w	r6,r9
800032ae:	c0 e1       	brne	800032ca <phy_rx_func+0x202>
800032b0:	fe f8 0c 58 	ld.w	r8,pc[3160]
800032b4:	90 09       	ld.sh	r9,r8[0x0]
800032b6:	30 08       	mov	r8,0
800032b8:	f0 09 19 00 	cp.h	r9,r8
800032bc:	c0 71       	brne	800032ca <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800032be:	fe f8 0c 42 	ld.w	r8,pc[3138]
800032c2:	70 0c       	ld.w	r12,r8[0x0]
800032c4:	f0 1f 03 12 	mcall	80003f0c <phy_rx_func+0xe44>
800032c8:	c0 88       	rjmp	800032d8 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800032ca:	fe f6 0c 36 	ld.w	r6,pc[3126]
800032ce:	6c 0c       	ld.w	r12,r6[0x0]
800032d0:	f0 1f 03 0d 	mcall	80003f04 <phy_rx_func+0xe3c>
				phy_frame_ptr = NULL;
800032d4:	30 08       	mov	r8,0
800032d6:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
800032d8:	30 09       	mov	r9,0
800032da:	fe f8 0c 12 	ld.w	r8,pc[3090]
800032de:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
800032e0:	fe f8 0c 30 	ld.w	r8,pc[3120]
800032e4:	11 89       	ld.ub	r9,r8[0x0]
800032e6:	30 08       	mov	r8,0
800032e8:	f0 09 18 00 	cp.b	r9,r8
800032ec:	c1 31       	brne	80003312 <phy_rx_func+0x24a>
	{
		payload_ptr = get_payload_idle_isr();
800032ee:	fe f6 0c 26 	ld.w	r6,pc[3110]
800032f2:	6c 0c       	ld.w	r12,r6[0x0]
800032f4:	f0 1f 03 02 	mcall	80003efc <phy_rx_func+0xe34>
800032f8:	fe f8 0c 20 	ld.w	r8,pc[3104]
800032fc:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
800032fe:	6c 0c       	ld.w	r12,r6[0x0]
80003300:	f0 1f 02 ff 	mcall	80003efc <phy_rx_func+0xe34>
80003304:	fe f8 0c 18 	ld.w	r8,pc[3096]
80003308:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000330a:	30 19       	mov	r9,1
8000330c:	fe f8 0c 04 	ld.w	r8,pc[3076]
80003310:	b0 89       	st.b	r8[0x0],r9
	}	
	
	
	PCM_frame_Payload[0] = payload_rx_channel->word[0];
80003312:	8e 49       	ld.sh	r9,r7[0x8]
80003314:	fe f8 0c 0c 	ld.w	r8,pc[3084]
80003318:	b0 09       	st.h	r8[0x0],r9
	PCM_frame_Payload[1] = payload_rx_channel->word[1];
8000331a:	8e 59       	ld.sh	r9,r7[0xa]
8000331c:	b0 19       	st.h	r8[0x2],r9
	PCM_frame_Payload[2] = payload_rx_channel->word[2];
8000331e:	8e 69       	ld.sh	r9,r7[0xc]
80003320:	b0 29       	st.h	r8[0x4],r9
	PCM_frame_Payload[3] = payload_rx_channel->word[3];
80003322:	8e 79       	ld.sh	r9,r7[0xe]
80003324:	b0 39       	st.h	r8[0x6],r9
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003326:	fe f8 0b fe 	ld.w	r8,pc[3070]
8000332a:	70 08       	ld.w	r8,r8[0x0]
8000332c:	58 28       	cp.w	r8,2
8000332e:	e0 80 01 b8 	breq	8000369e <phy_rx_func+0x5d6>
80003332:	e0 8b 00 06 	brhi	8000333e <phy_rx_func+0x276>
80003336:	58 08       	cp.w	r8,0
80003338:	c0 b0       	breq	8000334e <phy_rx_func+0x286>
8000333a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000333e:	58 38       	cp.w	r8,3
80003340:	e0 80 05 8b 	breq	80003e56 <phy_rx_func+0xd8e>
80003344:	58 48       	cp.w	r8,4
80003346:	e0 81 05 cc 	brne	80003ede <phy_rx_func+0xe16>
8000334a:	e0 8f 02 6b 	bral	80003820 <phy_rx_func+0x758>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000334e:	6e 28       	ld.w	r8,r7[0x8]
80003350:	e0 6a 5a 5a 	mov	r10,23130
80003354:	ea 1a ab cd 	orh	r10,0xabcd
80003358:	14 38       	cp.w	r8,r10
8000335a:	c0 71       	brne	80003368 <phy_rx_func+0x2a0>
			{
				
				m_RxBurstType = VOICE_WATING;
8000335c:	30 09       	mov	r9,0
8000335e:	fe f8 0b ca 	ld.w	r8,pc[3018]
80003362:	91 09       	st.w	r8[0x0],r9
80003364:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003368:	10 99       	mov	r9,r8
8000336a:	e0 19 00 00 	andl	r9,0x0
8000336e:	fc 1a ab cd 	movh	r10,0xabcd
80003372:	14 39       	cp.w	r9,r10
80003374:	e0 81 05 b5 	brne	80003ede <phy_rx_func+0xe16>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003378:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000337c:	fe f9 0b b0 	ld.w	r9,pc[2992]
80003380:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
80003382:	fe f8 0b 96 	ld.w	r8,pc[2966]
80003386:	70 08       	ld.w	r8,r8[0x0]
80003388:	58 08       	cp.w	r8,0
8000338a:	c0 60       	breq	80003396 <phy_rx_func+0x2ce>
8000338c:	fe f8 0b 90 	ld.w	r8,pc[2960]
80003390:	70 08       	ld.w	r8,r8[0x0]
80003392:	58 08       	cp.w	r8,0
80003394:	c1 a1       	brne	800033c8 <phy_rx_func+0x300>
			{
				payload_ptr = get_payload_idle_isr();
80003396:	fe f6 0b 7e 	ld.w	r6,pc[2942]
8000339a:	6c 0c       	ld.w	r12,r6[0x0]
8000339c:	f0 1f 02 d8 	mcall	80003efc <phy_rx_func+0xe34>
800033a0:	fe f5 0b 78 	ld.w	r5,pc[2936]
800033a4:	8b 0c       	st.w	r5[0x0],r12
				AMBE_payload_ptr = get_payload_idle_isr();
800033a6:	6c 0c       	ld.w	r12,r6[0x0]
800033a8:	f0 1f 02 d5 	mcall	80003efc <phy_rx_func+0xe34>
800033ac:	fe f8 0b 70 	ld.w	r8,pc[2928]
800033b0:	91 0c       	st.w	r8[0x0],r12
				
				if((NULL== payload_ptr) || (NULL== AMBE_payload_ptr))
800033b2:	6a 08       	ld.w	r8,r5[0x0]
800033b4:	58 08       	cp.w	r8,0
800033b6:	c0 30       	breq	800033bc <phy_rx_func+0x2f4>
800033b8:	58 0c       	cp.w	r12,0
800033ba:	c0 71       	brne	800033c8 <phy_rx_func+0x300>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800033bc:	fe fc 0b 74 	ld.w	r12,pc[2932]
800033c0:	f0 1f 02 dd 	mcall	80003f34 <phy_rx_func+0xe6c>
800033c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			}
			
		
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800033c8:	6e 28       	ld.w	r8,r7[0x8]
800033ca:	e2 18 f0 00 	andl	r8,0xf000,COH
800033ce:	e0 48 c0 00 	cp.w	r8,49152
800033d2:	e0 81 00 c7 	brne	80003560 <phy_rx_func+0x498>
			{
											
				Item_ID = payload_rx_channel->byte[5];
800033d6:	ef 39 00 0d 	ld.ub	r9,r7[13]
800033da:	fe f8 0b 5e 	ld.w	r8,pc[2910]
800033de:	b0 89       	st.b	r8[0x0],r9
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800033e0:	ef 3a 00 0c 	ld.ub	r10,r7[12]
800033e4:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
800033e8:	fe f9 0b 54 	ld.w	r9,pc[2900]
800033ec:	93 0a       	st.w	r9[0x0],r10
								
				switch(Item_ID)
800033ee:	11 88       	ld.ub	r8,r8[0x0]
800033f0:	37 f9       	mov	r9,127
800033f2:	f2 08 18 00 	cp.b	r8,r9
800033f6:	c6 b0       	breq	800034cc <phy_rx_func+0x404>
800033f8:	e0 8b 00 0c 	brhi	80003410 <phy_rx_func+0x348>
800033fc:	31 29       	mov	r9,18
800033fe:	f2 08 18 00 	cp.b	r8,r9
80003402:	c4 20       	breq	80003486 <phy_rx_func+0x3be>
80003404:	31 39       	mov	r9,19
80003406:	f2 08 18 00 	cp.b	r8,r9
8000340a:	e0 81 00 8b 	brne	80003520 <phy_rx_func+0x458>
8000340e:	c5 98       	rjmp	800034c0 <phy_rx_func+0x3f8>
80003410:	2f 08       	sub	r8,-16
80003412:	30 19       	mov	r9,1
80003414:	f2 08 18 00 	cp.b	r8,r9
80003418:	e0 8b 00 84 	brhi	80003520 <phy_rx_func+0x458>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000341c:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003420:	e2 18 00 f0 	andl	r8,0xf0,COH
80003424:	59 08       	cp.w	r8,16
80003426:	c0 71       	brne	80003434 <phy_rx_func+0x36c>
							{
								m_RxBurstType = VOICEHEADER;
80003428:	30 19       	mov	r9,1
8000342a:	fe f8 0a fe 	ld.w	r8,pc[2814]
8000342e:	91 09       	st.w	r8[0x0],r9
80003430:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003434:	e0 48 00 20 	cp.w	r8,32
80003438:	c2 11       	brne	8000347a <phy_rx_func+0x3b2>
							{
								m_RxBurstType = VOICETERMINATOR;
8000343a:	30 a9       	mov	r9,10
8000343c:	fe f8 0a ec 	ld.w	r8,pc[2796]
80003440:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003442:	fe f6 0a fe 	ld.w	r6,pc[2814]
80003446:	6c 08       	ld.w	r8,r6[0x0]
80003448:	f0 0a 11 ff 	rsub	r10,r8,-1
8000344c:	fe f7 0a d0 	ld.w	r7,pc[2768]
80003450:	2f f8       	sub	r8,-1
80003452:	6e 0c       	ld.w	r12,r7[0x0]
80003454:	f4 ca fe 00 	sub	r10,r10,-512
80003458:	30 0b       	mov	r11,0
8000345a:	10 0c       	add	r12,r8
8000345c:	f0 1f 02 ba 	mcall	80003f44 <phy_rx_func+0xe7c>
								
								RxAMBE_IsFillingNext8 = 0;
80003460:	30 08       	mov	r8,0
80003462:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003464:	6e 0c       	ld.w	r12,r7[0x0]
80003466:	f0 1f 02 b9 	mcall	80003f48 <phy_rx_func+0xe80>
								AMBE_payload_ptr = get_payload_idle_isr();
8000346a:	fe f8 0a aa 	ld.w	r8,pc[2730]
8000346e:	70 0c       	ld.w	r12,r8[0x0]
80003470:	f0 1f 02 a3 	mcall	80003efc <phy_rx_func+0xe34>
80003474:	8f 0c       	st.w	r7[0x0],r12
80003476:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000347a:	30 09       	mov	r9,0
8000347c:	fe f8 0a ac 	ld.w	r8,pc[2732]
80003480:	91 09       	st.w	r8[0x0],r9
80003482:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003486:	fe f9 0a a6 	ld.w	r9,pc[2726]
8000348a:	72 08       	ld.w	r8,r9[0x0]
8000348c:	20 48       	sub	r8,4
8000348e:	93 08       	st.w	r9[0x0],r8
80003490:	e0 80 05 27 	breq	80003ede <phy_rx_func+0xe16>
					
							//Vocoder Bits Stream Parameter
							VF_SN = payload_rx_channel->byte[7];//This parameter is very important to the loop back Radio, as a reference.
80003494:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80003498:	fe f8 0a b4 	ld.w	r8,pc[2740]
8000349c:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
8000349e:	8e 69       	ld.sh	r9,r7[0xc]
800034a0:	fe f8 0a b0 	ld.w	r8,pc[2736]
800034a4:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800034a6:	8e 79       	ld.sh	r9,r7[0xe]
800034a8:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800034aa:	f0 1f 02 ab 	mcall	80003f54 <phy_rx_func+0xe8c>
800034ae:	fe f8 0a 7a 	ld.w	r8,pc[2682]
800034b2:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034b4:	30 49       	mov	r9,4
800034b6:	fe f8 0a 6e 	ld.w	r8,pc[2670]
800034ba:	91 09       	st.w	r8[0x0],r9
800034bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800034c0:	30 09       	mov	r9,0
800034c2:	fe f8 0a 66 	ld.w	r8,pc[2662]
800034c6:	91 09       	st.w	r8[0x0],r9
800034c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
							
								
					case Radio_Internal_Parameter://0x7F
							
							logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
800034cc:	fe f8 0a 70 	ld.w	r8,pc[2672]
800034d0:	70 08       	ld.w	r8,r8[0x0]
800034d2:	1a d8       	st.w	--sp,r8
800034d4:	fe fc 0a 84 	ld.w	r12,pc[2692]
800034d8:	f0 1f 02 97 	mcall	80003f34 <phy_rx_func+0xe6c>
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800034dc:	fe f9 0a 50 	ld.w	r9,pc[2640]
800034e0:	72 08       	ld.w	r8,r9[0x0]
800034e2:	20 48       	sub	r8,4
800034e4:	93 08       	st.w	r9[0x0],r8
800034e6:	2f fd       	sub	sp,-4
800034e8:	58 08       	cp.w	r8,0
800034ea:	e0 80 04 fa 	breq	80003ede <phy_rx_func+0xe16>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800034ee:	fe f8 0a 6e 	ld.w	r8,pc[2670]
800034f2:	70 09       	ld.w	r9,r8[0x0]
800034f4:	8e 7b       	ld.sh	r11,r7[0xe]
800034f6:	fe fa 0a 6a 	ld.w	r10,pc[2666]
800034fa:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
800034fe:	2f f9       	sub	r9,-1
80003500:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003502:	fe f8 0a 3a 	ld.w	r8,pc[2618]
80003506:	70 09       	ld.w	r9,r8[0x0]
80003508:	20 29       	sub	r9,2
8000350a:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000350c:	30 29       	mov	r9,2
8000350e:	fe f8 0a 1a 	ld.w	r8,pc[2586]
80003512:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003514:	30 39       	mov	r9,3
80003516:	fe f8 0a 0e 	ld.w	r8,pc[2574]
8000351a:	91 09       	st.w	r8[0x0],r9
8000351c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003520:	30 39       	mov	r9,3
80003522:	fe f8 0a 06 	ld.w	r8,pc[2566]
80003526:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[0] = payload_rx_channel->dword[0];
80003528:	6e 29       	ld.w	r9,r7[0x8]
8000352a:	fe f8 0a 3a 	ld.w	r8,pc[2618]
8000352e:	91 09       	st.w	r8[0x0],r9
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003530:	6e 39       	ld.w	r9,r7[0xc]
80003532:	91 19       	st.w	r8[0x4],r9
							
							if (RxBytesWaiting == 0x00000014)
80003534:	fe f8 09 f8 	ld.w	r8,pc[2552]
80003538:	70 08       	ld.w	r8,r8[0x0]
8000353a:	59 48       	cp.w	r8,20
8000353c:	c0 61       	brne	80003548 <phy_rx_func+0x480>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000353e:	31 89       	mov	r9,24
80003540:	fe f8 09 ec 	ld.w	r8,pc[2540]
80003544:	91 09       	st.w	r8[0x0],r9
80003546:	c0 78       	rjmp	80003554 <phy_rx_func+0x48c>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003548:	59 08       	cp.w	r8,16
8000354a:	c0 51       	brne	80003554 <phy_rx_func+0x48c>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000354c:	31 09       	mov	r9,16
8000354e:	fe f8 09 de 	ld.w	r8,pc[2526]
80003552:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003554:	30 49       	mov	r9,4
80003556:	fe f8 09 ce 	ld.w	r8,pc[2510]
8000355a:	91 09       	st.w	r8[0x0],r9
8000355c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003560:	e0 48 10 00 	cp.w	r8,4096
80003564:	5f 19       	srne	r9
80003566:	e0 48 20 00 	cp.w	r8,8192
8000356a:	5f 18       	srne	r8
8000356c:	f3 e8 00 08 	and	r8,r9,r8
80003570:	e0 81 04 b7 	brne	80003ede <phy_rx_func+0xe16>
							
					//if ((payload_rx_channel->dword[0] & 0x0000F000 ) == SPEAKER_DATA)
					//{
						//break;//65794的机器通道有问题
					//}
				AMBE_tx_flag = 0;
80003574:	fe f9 09 f4 	ld.w	r9,pc[2548]
80003578:	b2 88       	st.b	r9[0x0],r8
				AMBE_rx_flag = 0;
8000357a:	fe f9 09 f2 	ld.w	r9,pc[2546]
8000357e:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
80003580:	fe f9 09 b8 	ld.w	r9,pc[2488]
80003584:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003586:	6e 28       	ld.w	r8,r7[0x8]
80003588:	e2 18 0f 00 	andl	r8,0xf00,COH
8000358c:	58 18       	cp.w	r8,1
8000358e:	e0 8b 00 56 	brhi	8000363a <phy_rx_func+0x572>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003592:	fe f9 09 9a 	ld.w	r9,pc[2458]
80003596:	72 08       	ld.w	r8,r9[0x0]
80003598:	20 48       	sub	r8,4
8000359a:	93 08       	st.w	r9[0x0],r8
8000359c:	e0 80 04 a1 	breq	80003ede <phy_rx_func+0xe16>
				ArrayDiscLength = payload_rx_channel->word[2];
800035a0:	8e 68       	ld.sh	r8,r7[0xc]
800035a2:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800035a6:	fe f9 09 ca 	ld.w	r9,pc[2506]
800035aa:	93 0a       	st.w	r9[0x0],r10
				
				switch (ArrayDiscLength){
800035ac:	30 09       	mov	r9,0
800035ae:	f2 08 19 00 	cp.h	r8,r9
800035b2:	c0 70       	breq	800035c0 <phy_rx_func+0x4f8>
800035b4:	30 19       	mov	r9,1
800035b6:	f2 08 19 00 	cp.h	r8,r9
800035ba:	e0 81 04 92 	brne	80003ede <phy_rx_func+0xe16>
800035be:	c2 68       	rjmp	8000360a <phy_rx_func+0x542>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800035c0:	fe f8 09 b4 	ld.w	r8,pc[2484]
800035c4:	70 0a       	ld.w	r10,r8[0x0]
800035c6:	fe f9 09 52 	ld.w	r9,pc[2386]
800035ca:	72 09       	ld.w	r9,r9[0x0]
800035cc:	8e 7b       	ld.sh	r11,r7[0xe]
800035ce:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
800035d2:	70 09       	ld.w	r9,r8[0x0]
800035d4:	2f f9       	sub	r9,-1
800035d6:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035d8:	e0 49 00 ff 	cp.w	r9,255
800035dc:	e0 88 00 11 	brls	800035fe <phy_rx_func+0x536>
						{
							RxMedia_IsFillingNext16 = 0;	
800035e0:	30 09       	mov	r9,0
800035e2:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
800035e4:	fe f7 09 34 	ld.w	r7,pc[2356]
800035e8:	6e 0c       	ld.w	r12,r7[0x0]
800035ea:	f0 1f 02 58 	mcall	80003f48 <phy_rx_func+0xe80>
							payload_ptr = get_payload_idle_isr();
800035ee:	fe f8 09 26 	ld.w	r8,pc[2342]
800035f2:	70 0c       	ld.w	r12,r8[0x0]
800035f4:	f0 1f 02 42 	mcall	80003efc <phy_rx_func+0xe34>
800035f8:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
800035fa:	e0 80 04 72 	breq	80003ede <phy_rx_func+0xe16>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
800035fe:	30 29       	mov	r9,2
80003600:	fe f8 09 24 	ld.w	r8,pc[2340]
80003604:	91 09       	st.w	r8[0x0],r9
80003606:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
8000360a:	8e 78       	ld.sh	r8,r7[0xe]
8000360c:	30 39       	mov	r9,3
8000360e:	f2 08 19 00 	cp.h	r8,r9
80003612:	c0 61       	brne	8000361e <phy_rx_func+0x556>
							{
								Terminator_Flag = 1;
80003614:	30 19       	mov	r9,1
80003616:	fe f8 09 62 	ld.w	r8,pc[2402]
8000361a:	b0 89       	st.b	r8[0x0],r9
8000361c:	c0 98       	rjmp	8000362e <phy_rx_func+0x566>

							}
							else if(payload_rx_channel->word[3] == 0x0004)//Silent Descriptor
8000361e:	30 49       	mov	r9,4
80003620:	f2 08 19 00 	cp.h	r8,r9
80003624:	c0 51       	brne	8000362e <phy_rx_func+0x566>
							{
							
								Silent_flag = 1;
80003626:	30 19       	mov	r9,1
80003628:	fe f8 09 54 	ld.w	r8,pc[2388]
8000362c:	b0 89       	st.b	r8[0x0],r9
							{
								//Terminator_Flag = 0;
							}
					
					
							RxMediaState = READINGMEDIA;
8000362e:	30 29       	mov	r9,2
80003630:	fe f8 08 f4 	ld.w	r8,pc[2292]
80003634:	91 09       	st.w	r8[0x0],r9
80003636:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
8000363a:	fe f8 08 f2 	ld.w	r8,pc[2290]
8000363e:	70 08       	ld.w	r8,r8[0x0]
80003640:	58 18       	cp.w	r8,1
80003642:	e0 88 04 4e 	brls	80003ede <phy_rx_func+0xe16>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003646:	fe f8 09 2e 	ld.w	r8,pc[2350]
8000364a:	70 0a       	ld.w	r10,r8[0x0]
8000364c:	fe f9 08 cc 	ld.w	r9,pc[2252]
80003650:	72 09       	ld.w	r9,r9[0x0]
80003652:	6e 3b       	ld.w	r11,r7[0xc]
80003654:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003658:	70 09       	ld.w	r9,r8[0x0]
8000365a:	2f f9       	sub	r9,-1
8000365c:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000365e:	e0 49 00 ff 	cp.w	r9,255
80003662:	e0 88 00 11 	brls	80003684 <phy_rx_func+0x5bc>
				{
					RxMedia_IsFillingNext16 = 0;
80003666:	30 09       	mov	r9,0
80003668:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000366a:	fe f7 08 ae 	ld.w	r7,pc[2222]
8000366e:	6e 0c       	ld.w	r12,r7[0x0]
80003670:	f0 1f 02 36 	mcall	80003f48 <phy_rx_func+0xe80>
								payload_ptr = get_payload_idle_isr();
80003674:	fe f8 08 a0 	ld.w	r8,pc[2208]
80003678:	70 0c       	ld.w	r12,r8[0x0]
8000367a:	f0 1f 02 21 	mcall	80003efc <phy_rx_func+0xe34>
8000367e:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
80003680:	e0 80 04 2f 	breq	80003ede <phy_rx_func+0xe16>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003684:	fe f9 08 a8 	ld.w	r9,pc[2216]
80003688:	72 08       	ld.w	r8,r9[0x0]
8000368a:	20 28       	sub	r8,2
8000368c:	93 08       	st.w	r9[0x0],r8
8000368e:	e0 80 04 28 	breq	80003ede <phy_rx_func+0xe16>
				RxMediaState = READINGMEDIA;
80003692:	30 29       	mov	r9,2
80003694:	fe f8 08 90 	ld.w	r8,pc[2192]
80003698:	91 09       	st.w	r8[0x0],r9
8000369a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
						
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000369e:	fe f8 08 d6 	ld.w	r8,pc[2262]
800036a2:	70 0a       	ld.w	r10,r8[0x0]
800036a4:	fe f9 08 74 	ld.w	r9,pc[2164]
800036a8:	72 09       	ld.w	r9,r9[0x0]
800036aa:	8e 4b       	ld.sh	r11,r7[0x8]
800036ac:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800036b0:	70 09       	ld.w	r9,r8[0x0]
800036b2:	2f f9       	sub	r9,-1
800036b4:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036b6:	e0 49 00 ff 	cp.w	r9,255
800036ba:	e0 88 00 16 	brls	800036e6 <phy_rx_func+0x61e>
					{
							RxMedia_IsFillingNext16 = 0;
800036be:	30 09       	mov	r9,0
800036c0:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
800036c2:	fe f6 08 56 	ld.w	r6,pc[2134]
800036c6:	6c 0c       	ld.w	r12,r6[0x0]
800036c8:	f0 1f 02 20 	mcall	80003f48 <phy_rx_func+0xe80>
							payload_ptr = get_payload_idle_isr();
800036cc:	fe f8 08 48 	ld.w	r8,pc[2120]
800036d0:	70 0c       	ld.w	r12,r8[0x0]
800036d2:	f0 1f 02 0b 	mcall	80003efc <phy_rx_func+0xe34>
800036d6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
800036d8:	c0 71       	brne	800036e6 <phy_rx_func+0x61e>
							{
								RxMediaState = WAITINGABAB;
800036da:	30 09       	mov	r9,0
800036dc:	fe f8 08 48 	ld.w	r8,pc[2120]
800036e0:	91 09       	st.w	r8[0x0],r9
800036e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
800036e6:	fe f9 08 46 	ld.w	r9,pc[2118]
800036ea:	72 08       	ld.w	r8,r9[0x0]
800036ec:	20 28       	sub	r8,2
800036ee:	93 08       	st.w	r9[0x0],r8
800036f0:	c0 71       	brne	800036fe <phy_rx_func+0x636>
				{
					RxMediaState = WAITINGABAB;
800036f2:	30 09       	mov	r9,0
800036f4:	fe f8 08 30 	ld.w	r8,pc[2096]
800036f8:	91 09       	st.w	r8[0x0],r9
800036fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800036fe:	fe f8 08 76 	ld.w	r8,pc[2166]
80003702:	70 0a       	ld.w	r10,r8[0x0]
80003704:	fe f9 08 14 	ld.w	r9,pc[2068]
80003708:	72 09       	ld.w	r9,r9[0x0]
8000370a:	8e 5b       	ld.sh	r11,r7[0xa]
8000370c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003710:	70 09       	ld.w	r9,r8[0x0]
80003712:	2f f9       	sub	r9,-1
80003714:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003716:	e0 49 00 ff 	cp.w	r9,255
8000371a:	e0 88 00 16 	brls	80003746 <phy_rx_func+0x67e>
						{
							RxMedia_IsFillingNext16 = 0;
8000371e:	30 09       	mov	r9,0
80003720:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003722:	fe f6 07 f6 	ld.w	r6,pc[2038]
80003726:	6c 0c       	ld.w	r12,r6[0x0]
80003728:	f0 1f 02 08 	mcall	80003f48 <phy_rx_func+0xe80>
								payload_ptr = get_payload_idle_isr();
8000372c:	fe f8 07 e8 	ld.w	r8,pc[2024]
80003730:	70 0c       	ld.w	r12,r8[0x0]
80003732:	f0 1f 01 f3 	mcall	80003efc <phy_rx_func+0xe34>
80003736:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
80003738:	c0 71       	brne	80003746 <phy_rx_func+0x67e>
								{
									RxMediaState = WAITINGABAB;
8000373a:	30 09       	mov	r9,0
8000373c:	fe f8 07 e8 	ld.w	r8,pc[2024]
80003740:	91 09       	st.w	r8[0x0],r9
80003742:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003746:	fe f9 07 e6 	ld.w	r9,pc[2022]
8000374a:	72 08       	ld.w	r8,r9[0x0]
8000374c:	20 28       	sub	r8,2
8000374e:	93 08       	st.w	r9[0x0],r8
80003750:	c0 71       	brne	8000375e <phy_rx_func+0x696>
					RxMediaState = WAITINGABAB;
80003752:	30 09       	mov	r9,0
80003754:	fe f8 07 d0 	ld.w	r8,pc[2000]
80003758:	91 09       	st.w	r8[0x0],r9
8000375a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000375e:	fe f8 08 16 	ld.w	r8,pc[2070]
80003762:	70 0a       	ld.w	r10,r8[0x0]
80003764:	fe f9 07 b4 	ld.w	r9,pc[1972]
80003768:	72 09       	ld.w	r9,r9[0x0]
8000376a:	8e 6b       	ld.sh	r11,r7[0xc]
8000376c:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003770:	70 09       	ld.w	r9,r8[0x0]
80003772:	2f f9       	sub	r9,-1
80003774:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003776:	e0 49 00 ff 	cp.w	r9,255
8000377a:	e0 88 00 16 	brls	800037a6 <phy_rx_func+0x6de>
						{
							RxMedia_IsFillingNext16 = 0;
8000377e:	30 09       	mov	r9,0
80003780:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
80003782:	fe f6 07 96 	ld.w	r6,pc[1942]
80003786:	6c 0c       	ld.w	r12,r6[0x0]
80003788:	f0 1f 01 f0 	mcall	80003f48 <phy_rx_func+0xe80>
									payload_ptr = get_payload_idle_isr();
8000378c:	fe f8 07 88 	ld.w	r8,pc[1928]
80003790:	70 0c       	ld.w	r12,r8[0x0]
80003792:	f0 1f 01 db 	mcall	80003efc <phy_rx_func+0xe34>
80003796:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
80003798:	c0 71       	brne	800037a6 <phy_rx_func+0x6de>
									{
										RxMediaState = WAITINGABAB;
8000379a:	30 09       	mov	r9,0
8000379c:	fe f8 07 88 	ld.w	r8,pc[1928]
800037a0:	91 09       	st.w	r8[0x0],r9
800037a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800037a6:	fe f9 07 86 	ld.w	r9,pc[1926]
800037aa:	72 08       	ld.w	r8,r9[0x0]
800037ac:	20 28       	sub	r8,2
800037ae:	93 08       	st.w	r9[0x0],r8
800037b0:	c0 71       	brne	800037be <phy_rx_func+0x6f6>
					RxMediaState = WAITINGABAB;
800037b2:	30 09       	mov	r9,0
800037b4:	fe f8 07 70 	ld.w	r8,pc[1904]
800037b8:	91 09       	st.w	r8[0x0],r9
800037ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800037be:	fe f8 07 b6 	ld.w	r8,pc[1974]
800037c2:	70 0a       	ld.w	r10,r8[0x0]
800037c4:	fe f9 07 54 	ld.w	r9,pc[1876]
800037c8:	72 09       	ld.w	r9,r9[0x0]
800037ca:	8e 7b       	ld.sh	r11,r7[0xe]
800037cc:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800037d0:	70 09       	ld.w	r9,r8[0x0]
800037d2:	2f f9       	sub	r9,-1
800037d4:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800037d6:	e0 49 00 ff 	cp.w	r9,255
800037da:	e0 88 00 16 	brls	80003806 <phy_rx_func+0x73e>
						{
							RxMedia_IsFillingNext16 = 0;
800037de:	30 09       	mov	r9,0
800037e0:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
800037e2:	fe f7 07 36 	ld.w	r7,pc[1846]
800037e6:	6e 0c       	ld.w	r12,r7[0x0]
800037e8:	f0 1f 01 d8 	mcall	80003f48 <phy_rx_func+0xe80>
							payload_ptr = get_payload_idle_isr();
800037ec:	fe f8 07 28 	ld.w	r8,pc[1832]
800037f0:	70 0c       	ld.w	r12,r8[0x0]
800037f2:	f0 1f 01 c3 	mcall	80003efc <phy_rx_func+0xe34>
800037f6:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
800037f8:	c0 71       	brne	80003806 <phy_rx_func+0x73e>
							{
								RxMediaState = WAITINGABAB;
800037fa:	30 09       	mov	r9,0
800037fc:	fe f8 07 28 	ld.w	r8,pc[1832]
80003800:	91 09       	st.w	r8[0x0],r9
80003802:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003806:	fe f9 07 26 	ld.w	r9,pc[1830]
8000380a:	72 08       	ld.w	r8,r9[0x0]
8000380c:	20 28       	sub	r8,2
8000380e:	93 08       	st.w	r9[0x0],r8
80003810:	e0 81 03 67 	brne	80003ede <phy_rx_func+0xe16>
					RxMediaState = WAITINGABAB;
80003814:	30 09       	mov	r9,0
80003816:	fe f8 07 0e 	ld.w	r8,pc[1806]
8000381a:	91 09       	st.w	r8[0x0],r9
8000381c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
80003820:	fe f8 07 18 	ld.w	r8,pc[1816]
80003824:	11 89       	ld.ub	r9,r8[0x0]
80003826:	31 28       	mov	r8,18
80003828:	f0 09 18 00 	cp.b	r9,r8
8000382c:	e0 81 01 4c 	brne	80003ac4 <phy_rx_func+0x9fc>
					{
						Item_ID = payload_rx_channel->byte[1];
80003830:	ef 39 00 09 	ld.ub	r9,r7[9]
80003834:	fe f8 07 04 	ld.w	r8,pc[1796]
80003838:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
8000383a:	11 89       	ld.ub	r9,r8[0x0]
8000383c:	3f 28       	mov	r8,-14
8000383e:	f0 09 18 00 	cp.b	r9,r8
80003842:	e0 81 01 3b 	brne	80003ab8 <phy_rx_func+0x9f0>
						{
							AMBE_tx_flag = 1;
80003846:	30 19       	mov	r9,1
80003848:	fe f8 07 20 	ld.w	r8,pc[1824]
8000384c:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000384e:	6e 29       	ld.w	r9,r7[0x8]
80003850:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003854:	fe f8 06 d8 	ld.w	r8,pc[1752]
80003858:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
8000385a:	8e 59       	ld.sh	r9,r7[0xa]
8000385c:	fe f8 07 24 	ld.w	r8,pc[1828]
80003860:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003862:	8e 69       	ld.sh	r9,r7[0xc]
80003864:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003866:	8e 79       	ld.sh	r9,r7[0xe]
80003868:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
8000386a:	fe f8 06 d6 	ld.w	r8,pc[1750]
8000386e:	fe f9 06 ae 	ld.w	r9,pc[1710]
80003872:	72 0a       	ld.w	r10,r9[0x0]
80003874:	70 09       	ld.w	r9,r8[0x0]
80003876:	ef 3b 00 0a 	ld.ub	r11,r7[10]
8000387a:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000387e:	70 09       	ld.w	r9,r8[0x0]
80003880:	2f f9       	sub	r9,-1
80003882:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003884:	e0 49 01 ff 	cp.w	r9,511
80003888:	e0 88 00 16 	brls	800038b4 <phy_rx_func+0x7ec>
							{
								RxAMBE_IsFillingNext8 = 0;
8000388c:	30 09       	mov	r9,0
8000388e:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003890:	fe f6 06 8c 	ld.w	r6,pc[1676]
80003894:	6c 0c       	ld.w	r12,r6[0x0]
80003896:	f0 1f 01 ad 	mcall	80003f48 <phy_rx_func+0xe80>
								AMBE_payload_ptr = get_payload_idle_isr();
8000389a:	fe f8 06 7a 	ld.w	r8,pc[1658]
8000389e:	70 0c       	ld.w	r12,r8[0x0]
800038a0:	f0 1f 01 97 	mcall	80003efc <phy_rx_func+0xe34>
800038a4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800038a6:	c0 71       	brne	800038b4 <phy_rx_func+0x7ec>
								{
									RxMediaState = WAITINGABAB;
800038a8:	30 09       	mov	r9,0
800038aa:	fe f8 06 7a 	ld.w	r8,pc[1658]
800038ae:	91 09       	st.w	r8[0x0],r9
800038b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800038b4:	fe f9 06 78 	ld.w	r9,pc[1656]
800038b8:	72 08       	ld.w	r8,r9[0x0]
800038ba:	20 18       	sub	r8,1
800038bc:	93 08       	st.w	r9[0x0],r8
800038be:	c0 71       	brne	800038cc <phy_rx_func+0x804>
								RxMediaState = WAITINGABAB;
800038c0:	30 09       	mov	r9,0
800038c2:	fe f8 06 62 	ld.w	r8,pc[1634]
800038c6:	91 09       	st.w	r8[0x0],r9
800038c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800038cc:	fe f8 06 74 	ld.w	r8,pc[1652]
800038d0:	fe f9 06 4c 	ld.w	r9,pc[1612]
800038d4:	72 0a       	ld.w	r10,r9[0x0]
800038d6:	70 09       	ld.w	r9,r8[0x0]
800038d8:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800038dc:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800038e0:	70 09       	ld.w	r9,r8[0x0]
800038e2:	2f f9       	sub	r9,-1
800038e4:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038e6:	e0 49 01 ff 	cp.w	r9,511
800038ea:	e0 88 00 16 	brls	80003916 <phy_rx_func+0x84e>
							{
								RxAMBE_IsFillingNext8 = 0;
800038ee:	30 09       	mov	r9,0
800038f0:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800038f2:	fe f6 06 2a 	ld.w	r6,pc[1578]
800038f6:	6c 0c       	ld.w	r12,r6[0x0]
800038f8:	f0 1f 01 94 	mcall	80003f48 <phy_rx_func+0xe80>
								AMBE_payload_ptr = get_payload_idle_isr();
800038fc:	fe f8 06 18 	ld.w	r8,pc[1560]
80003900:	70 0c       	ld.w	r12,r8[0x0]
80003902:	f0 1f 01 7f 	mcall	80003efc <phy_rx_func+0xe34>
80003906:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003908:	c0 71       	brne	80003916 <phy_rx_func+0x84e>
								{
									RxMediaState = WAITINGABAB;
8000390a:	30 09       	mov	r9,0
8000390c:	fe f8 06 18 	ld.w	r8,pc[1560]
80003910:	91 09       	st.w	r8[0x0],r9
80003912:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003916:	fe f9 06 16 	ld.w	r9,pc[1558]
8000391a:	72 08       	ld.w	r8,r9[0x0]
8000391c:	20 18       	sub	r8,1
8000391e:	93 08       	st.w	r9[0x0],r8
80003920:	c0 71       	brne	8000392e <phy_rx_func+0x866>
								RxMediaState = WAITINGABAB;
80003922:	30 09       	mov	r9,0
80003924:	fe f8 06 00 	ld.w	r8,pc[1536]
80003928:	91 09       	st.w	r8[0x0],r9
8000392a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
8000392e:	fe f8 06 12 	ld.w	r8,pc[1554]
80003932:	fe f9 05 ea 	ld.w	r9,pc[1514]
80003936:	72 0a       	ld.w	r10,r9[0x0]
80003938:	70 09       	ld.w	r9,r8[0x0]
8000393a:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000393e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003942:	70 09       	ld.w	r9,r8[0x0]
80003944:	2f f9       	sub	r9,-1
80003946:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003948:	e0 49 01 ff 	cp.w	r9,511
8000394c:	e0 88 00 16 	brls	80003978 <phy_rx_func+0x8b0>
							{
								RxAMBE_IsFillingNext8 = 0;
80003950:	30 09       	mov	r9,0
80003952:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003954:	fe f6 05 c8 	ld.w	r6,pc[1480]
80003958:	6c 0c       	ld.w	r12,r6[0x0]
8000395a:	f0 1f 01 7c 	mcall	80003f48 <phy_rx_func+0xe80>
								AMBE_payload_ptr = get_payload_idle_isr();
8000395e:	fe f8 05 b6 	ld.w	r8,pc[1462]
80003962:	70 0c       	ld.w	r12,r8[0x0]
80003964:	f0 1f 01 66 	mcall	80003efc <phy_rx_func+0xe34>
80003968:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000396a:	c0 71       	brne	80003978 <phy_rx_func+0x8b0>
								{
									RxMediaState = WAITINGABAB;
8000396c:	30 09       	mov	r9,0
8000396e:	fe f8 05 b6 	ld.w	r8,pc[1462]
80003972:	91 09       	st.w	r8[0x0],r9
80003974:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003978:	fe f9 05 b4 	ld.w	r9,pc[1460]
8000397c:	72 08       	ld.w	r8,r9[0x0]
8000397e:	20 18       	sub	r8,1
80003980:	93 08       	st.w	r9[0x0],r8
80003982:	c0 71       	brne	80003990 <phy_rx_func+0x8c8>
								RxMediaState = WAITINGABAB;
80003984:	30 09       	mov	r9,0
80003986:	fe f8 05 9e 	ld.w	r8,pc[1438]
8000398a:	91 09       	st.w	r8[0x0],r9
8000398c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
80003990:	fe f8 05 b0 	ld.w	r8,pc[1456]
80003994:	fe f9 05 88 	ld.w	r9,pc[1416]
80003998:	72 0a       	ld.w	r10,r9[0x0]
8000399a:	70 09       	ld.w	r9,r8[0x0]
8000399c:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800039a0:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800039a4:	70 09       	ld.w	r9,r8[0x0]
800039a6:	2f f9       	sub	r9,-1
800039a8:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039aa:	e0 49 01 ff 	cp.w	r9,511
800039ae:	e0 88 00 16 	brls	800039da <phy_rx_func+0x912>
							{
								RxAMBE_IsFillingNext8 = 0;
800039b2:	30 09       	mov	r9,0
800039b4:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800039b6:	fe f6 05 66 	ld.w	r6,pc[1382]
800039ba:	6c 0c       	ld.w	r12,r6[0x0]
800039bc:	f0 1f 01 63 	mcall	80003f48 <phy_rx_func+0xe80>
								AMBE_payload_ptr = get_payload_idle_isr();
800039c0:	fe f8 05 54 	ld.w	r8,pc[1364]
800039c4:	70 0c       	ld.w	r12,r8[0x0]
800039c6:	f0 1f 01 4e 	mcall	80003efc <phy_rx_func+0xe34>
800039ca:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800039cc:	c0 71       	brne	800039da <phy_rx_func+0x912>
								{
									RxMediaState = WAITINGABAB;
800039ce:	30 09       	mov	r9,0
800039d0:	fe f8 05 54 	ld.w	r8,pc[1364]
800039d4:	91 09       	st.w	r8[0x0],r9
800039d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800039da:	fe f9 05 52 	ld.w	r9,pc[1362]
800039de:	72 08       	ld.w	r8,r9[0x0]
800039e0:	20 18       	sub	r8,1
800039e2:	93 08       	st.w	r9[0x0],r8
800039e4:	c0 71       	brne	800039f2 <phy_rx_func+0x92a>
								RxMediaState = WAITINGABAB;
800039e6:	30 09       	mov	r9,0
800039e8:	fe f8 05 3c 	ld.w	r8,pc[1340]
800039ec:	91 09       	st.w	r8[0x0],r9
800039ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800039f2:	fe f8 05 4e 	ld.w	r8,pc[1358]
800039f6:	fe f9 05 26 	ld.w	r9,pc[1318]
800039fa:	72 0a       	ld.w	r10,r9[0x0]
800039fc:	70 09       	ld.w	r9,r8[0x0]
800039fe:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003a02:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a06:	70 09       	ld.w	r9,r8[0x0]
80003a08:	2f f9       	sub	r9,-1
80003a0a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a0c:	e0 49 01 ff 	cp.w	r9,511
80003a10:	e0 88 00 16 	brls	80003a3c <phy_rx_func+0x974>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a14:	30 09       	mov	r9,0
80003a16:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a18:	fe f6 05 04 	ld.w	r6,pc[1284]
80003a1c:	6c 0c       	ld.w	r12,r6[0x0]
80003a1e:	f0 1f 01 4b 	mcall	80003f48 <phy_rx_func+0xe80>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a22:	fe f8 04 f2 	ld.w	r8,pc[1266]
80003a26:	70 0c       	ld.w	r12,r8[0x0]
80003a28:	f0 1f 01 35 	mcall	80003efc <phy_rx_func+0xe34>
80003a2c:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a2e:	c0 71       	brne	80003a3c <phy_rx_func+0x974>
								{
									RxMediaState = WAITINGABAB;
80003a30:	30 09       	mov	r9,0
80003a32:	fe f8 04 f2 	ld.w	r8,pc[1266]
80003a36:	91 09       	st.w	r8[0x0],r9
80003a38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a3c:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003a40:	72 08       	ld.w	r8,r9[0x0]
80003a42:	20 18       	sub	r8,1
80003a44:	93 08       	st.w	r9[0x0],r8
80003a46:	c0 71       	brne	80003a54 <phy_rx_func+0x98c>
								RxMediaState = WAITINGABAB;
80003a48:	30 09       	mov	r9,0
80003a4a:	fe f8 04 da 	ld.w	r8,pc[1242]
80003a4e:	91 09       	st.w	r8[0x0],r9
80003a50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003a54:	fe f8 04 ec 	ld.w	r8,pc[1260]
80003a58:	fe f9 04 c4 	ld.w	r9,pc[1220]
80003a5c:	72 0a       	ld.w	r10,r9[0x0]
80003a5e:	70 09       	ld.w	r9,r8[0x0]
80003a60:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003a64:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a68:	70 09       	ld.w	r9,r8[0x0]
80003a6a:	2f f9       	sub	r9,-1
80003a6c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a6e:	e0 49 01 ff 	cp.w	r9,511
80003a72:	e0 88 00 16 	brls	80003a9e <phy_rx_func+0x9d6>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a76:	30 09       	mov	r9,0
80003a78:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a7a:	fe f7 04 a2 	ld.w	r7,pc[1186]
80003a7e:	6e 0c       	ld.w	r12,r7[0x0]
80003a80:	f0 1f 01 32 	mcall	80003f48 <phy_rx_func+0xe80>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a84:	fe f8 04 90 	ld.w	r8,pc[1168]
80003a88:	70 0c       	ld.w	r12,r8[0x0]
80003a8a:	f0 1f 01 1d 	mcall	80003efc <phy_rx_func+0xe34>
80003a8e:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a90:	c0 71       	brne	80003a9e <phy_rx_func+0x9d6>
								{
									RxMediaState = WAITINGABAB;
80003a92:	30 09       	mov	r9,0
80003a94:	fe f8 04 90 	ld.w	r8,pc[1168]
80003a98:	91 09       	st.w	r8[0x0],r9
80003a9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a9e:	fe f9 04 8e 	ld.w	r9,pc[1166]
80003aa2:	72 08       	ld.w	r8,r9[0x0]
80003aa4:	20 18       	sub	r8,1
80003aa6:	93 08       	st.w	r9[0x0],r8
80003aa8:	e0 81 02 1b 	brne	80003ede <phy_rx_func+0xe16>
								RxMediaState = WAITINGABAB;
80003aac:	30 09       	mov	r9,0
80003aae:	fe f8 04 76 	ld.w	r8,pc[1142]
80003ab2:	91 09       	st.w	r8[0x0],r9
80003ab4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003ab8:	30 09       	mov	r9,0
80003aba:	fe f8 04 6a 	ld.w	r8,pc[1130]
80003abe:	91 09       	st.w	r8[0x0],r9
80003ac0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003ac4:	fe f8 04 74 	ld.w	r8,pc[1140]
80003ac8:	11 89       	ld.ub	r9,r8[0x0]
80003aca:	3f 28       	mov	r8,-14
80003acc:	f0 09 18 00 	cp.b	r9,r8
80003ad0:	c4 31       	brne	80003b56 <phy_rx_func+0xa8e>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003ad2:	8e 49       	ld.sh	r9,r7[0x8]
80003ad4:	fe f8 04 ac 	ld.w	r8,pc[1196]
80003ad8:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003ada:	fe f8 04 66 	ld.w	r8,pc[1126]
80003ade:	fe f9 04 3e 	ld.w	r9,pc[1086]
80003ae2:	72 0a       	ld.w	r10,r9[0x0]
80003ae4:	70 09       	ld.w	r9,r8[0x0]
80003ae6:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003aea:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003aee:	70 09       	ld.w	r9,r8[0x0]
80003af0:	2f f9       	sub	r9,-1
80003af2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003af4:	e0 49 01 ff 	cp.w	r9,511
80003af8:	e0 88 00 16 	brls	80003b24 <phy_rx_func+0xa5c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003afc:	30 09       	mov	r9,0
80003afe:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b00:	fe f7 04 1c 	ld.w	r7,pc[1052]
80003b04:	6e 0c       	ld.w	r12,r7[0x0]
80003b06:	f0 1f 01 11 	mcall	80003f48 <phy_rx_func+0xe80>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b0a:	fe f8 04 0a 	ld.w	r8,pc[1034]
80003b0e:	70 0c       	ld.w	r12,r8[0x0]
80003b10:	f0 1f 00 fb 	mcall	80003efc <phy_rx_func+0xe34>
80003b14:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b16:	c0 71       	brne	80003b24 <phy_rx_func+0xa5c>
							{
								RxMediaState = WAITINGABAB;
80003b18:	30 09       	mov	r9,0
80003b1a:	fe f8 04 0a 	ld.w	r8,pc[1034]
80003b1e:	91 09       	st.w	r8[0x0],r9
80003b20:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b24:	fe f9 04 08 	ld.w	r9,pc[1032]
80003b28:	72 08       	ld.w	r8,r9[0x0]
80003b2a:	20 18       	sub	r8,1
80003b2c:	93 08       	st.w	r9[0x0],r8
80003b2e:	c0 71       	brne	80003b3c <phy_rx_func+0xa74>
							RxMediaState = WAITINGABAB;
80003b30:	30 09       	mov	r9,0
80003b32:	fe f8 03 f2 	ld.w	r8,pc[1010]
80003b36:	91 09       	st.w	r8[0x0],r9
80003b38:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003b3c:	20 18       	sub	r8,1
80003b3e:	fe f9 03 ee 	ld.w	r9,pc[1006]
80003b42:	93 08       	st.w	r9[0x0],r8
80003b44:	58 08       	cp.w	r8,0
80003b46:	e0 81 01 cc 	brne	80003ede <phy_rx_func+0xe16>
							RxMediaState = WAITINGABAB;
80003b4a:	30 09       	mov	r9,0
80003b4c:	fe f8 03 d8 	ld.w	r8,pc[984]
80003b50:	91 09       	st.w	r8[0x0],r9
80003b52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit0~bit63
80003b56:	fe f8 03 e2 	ld.w	r8,pc[994]
80003b5a:	11 89       	ld.ub	r9,r8[0x0]
80003b5c:	3f 38       	mov	r8,-13
80003b5e:	f0 09 18 00 	cp.b	r9,r8
80003b62:	e0 81 01 5a 	brne	80003e16 <phy_rx_func+0xd4e>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[0] = payload_rx_channel->word[0];
80003b66:	8e 49       	ld.sh	r9,r7[0x8]
80003b68:	fe f8 04 18 	ld.w	r8,pc[1048]
80003b6c:	b0 09       	st.h	r8[0x0],r9
						AMBEBurst_rawdata[1] = payload_rx_channel->word[1];
80003b6e:	8e 59       	ld.sh	r9,r7[0xa]
80003b70:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[2];
80003b72:	8e 69       	ld.sh	r9,r7[0xc]
80003b74:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[3];
80003b76:	8e 79       	ld.sh	r9,r7[0xe]
80003b78:	b0 39       	st.h	r8[0x6],r9
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//1
80003b7a:	fe f8 03 c6 	ld.w	r8,pc[966]
80003b7e:	fe f9 03 9e 	ld.w	r9,pc[926]
80003b82:	72 0a       	ld.w	r10,r9[0x0]
80003b84:	70 09       	ld.w	r9,r8[0x0]
80003b86:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003b8a:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b8e:	70 09       	ld.w	r9,r8[0x0]
80003b90:	2f f9       	sub	r9,-1
80003b92:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b94:	e0 49 01 ff 	cp.w	r9,511
80003b98:	e0 88 00 16 	brls	80003bc4 <phy_rx_func+0xafc>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b9c:	30 09       	mov	r9,0
80003b9e:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003ba0:	fe f6 03 7c 	ld.w	r6,pc[892]
80003ba4:	6c 0c       	ld.w	r12,r6[0x0]
80003ba6:	f0 1f 00 e9 	mcall	80003f48 <phy_rx_func+0xe80>
							AMBE_payload_ptr = get_payload_idle_isr();
80003baa:	fe f8 03 6a 	ld.w	r8,pc[874]
80003bae:	70 0c       	ld.w	r12,r8[0x0]
80003bb0:	f0 1f 00 d3 	mcall	80003efc <phy_rx_func+0xe34>
80003bb4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003bb6:	c0 71       	brne	80003bc4 <phy_rx_func+0xafc>
							{
								RxMediaState = WAITINGABAB;
80003bb8:	30 09       	mov	r9,0
80003bba:	fe f8 03 6a 	ld.w	r8,pc[874]
80003bbe:	91 09       	st.w	r8[0x0],r9
80003bc0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003bc4:	fe f9 03 68 	ld.w	r9,pc[872]
80003bc8:	72 08       	ld.w	r8,r9[0x0]
80003bca:	20 18       	sub	r8,1
80003bcc:	93 08       	st.w	r9[0x0],r8
80003bce:	c0 71       	brne	80003bdc <phy_rx_func+0xb14>
							RxMediaState = WAITINGABAB;
80003bd0:	30 09       	mov	r9,0
80003bd2:	fe f8 03 52 	ld.w	r8,pc[850]
80003bd6:	91 09       	st.w	r8[0x0],r9
80003bd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//2
80003bdc:	fe f8 03 64 	ld.w	r8,pc[868]
80003be0:	fe f9 03 3c 	ld.w	r9,pc[828]
80003be4:	72 0a       	ld.w	r10,r9[0x0]
80003be6:	70 09       	ld.w	r9,r8[0x0]
80003be8:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003bec:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003bf0:	70 09       	ld.w	r9,r8[0x0]
80003bf2:	2f f9       	sub	r9,-1
80003bf4:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bf6:	e0 49 01 ff 	cp.w	r9,511
80003bfa:	e0 88 00 16 	brls	80003c26 <phy_rx_func+0xb5e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003bfe:	30 09       	mov	r9,0
80003c00:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c02:	fe f6 03 1a 	ld.w	r6,pc[794]
80003c06:	6c 0c       	ld.w	r12,r6[0x0]
80003c08:	f0 1f 00 d0 	mcall	80003f48 <phy_rx_func+0xe80>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c0c:	fe f8 03 08 	ld.w	r8,pc[776]
80003c10:	70 0c       	ld.w	r12,r8[0x0]
80003c12:	f0 1f 00 bb 	mcall	80003efc <phy_rx_func+0xe34>
80003c16:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c18:	c0 71       	brne	80003c26 <phy_rx_func+0xb5e>
							{
								RxMediaState = WAITINGABAB;
80003c1a:	30 09       	mov	r9,0
80003c1c:	fe f8 03 08 	ld.w	r8,pc[776]
80003c20:	91 09       	st.w	r8[0x0],r9
80003c22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c26:	fe f9 03 06 	ld.w	r9,pc[774]
80003c2a:	72 08       	ld.w	r8,r9[0x0]
80003c2c:	20 18       	sub	r8,1
80003c2e:	93 08       	st.w	r9[0x0],r8
80003c30:	c0 71       	brne	80003c3e <phy_rx_func+0xb76>
							RxMediaState = WAITINGABAB;
80003c32:	30 09       	mov	r9,0
80003c34:	fe f8 02 f0 	ld.w	r8,pc[752]
80003c38:	91 09       	st.w	r8[0x0],r9
80003c3a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//3
80003c3e:	fe f8 03 02 	ld.w	r8,pc[770]
80003c42:	fe f9 02 da 	ld.w	r9,pc[730]
80003c46:	72 0a       	ld.w	r10,r9[0x0]
80003c48:	70 09       	ld.w	r9,r8[0x0]
80003c4a:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003c4e:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c52:	70 09       	ld.w	r9,r8[0x0]
80003c54:	2f f9       	sub	r9,-1
80003c56:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c58:	e0 49 01 ff 	cp.w	r9,511
80003c5c:	e0 88 00 16 	brls	80003c88 <phy_rx_func+0xbc0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c60:	30 09       	mov	r9,0
80003c62:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c64:	fe f6 02 b8 	ld.w	r6,pc[696]
80003c68:	6c 0c       	ld.w	r12,r6[0x0]
80003c6a:	f0 1f 00 b8 	mcall	80003f48 <phy_rx_func+0xe80>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c6e:	fe f8 02 a6 	ld.w	r8,pc[678]
80003c72:	70 0c       	ld.w	r12,r8[0x0]
80003c74:	f0 1f 00 a2 	mcall	80003efc <phy_rx_func+0xe34>
80003c78:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c7a:	c0 71       	brne	80003c88 <phy_rx_func+0xbc0>
							{
								RxMediaState = WAITINGABAB;
80003c7c:	30 09       	mov	r9,0
80003c7e:	fe f8 02 a6 	ld.w	r8,pc[678]
80003c82:	91 09       	st.w	r8[0x0],r9
80003c84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c88:	fe f9 02 a4 	ld.w	r9,pc[676]
80003c8c:	72 08       	ld.w	r8,r9[0x0]
80003c8e:	20 18       	sub	r8,1
80003c90:	93 08       	st.w	r9[0x0],r8
80003c92:	c0 71       	brne	80003ca0 <phy_rx_func+0xbd8>
							RxMediaState = WAITINGABAB;
80003c94:	30 09       	mov	r9,0
80003c96:	fe f8 02 8e 	ld.w	r8,pc[654]
80003c9a:	91 09       	st.w	r8[0x0],r9
80003c9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//4
80003ca0:	fe f8 02 a0 	ld.w	r8,pc[672]
80003ca4:	fe f9 02 78 	ld.w	r9,pc[632]
80003ca8:	72 0a       	ld.w	r10,r9[0x0]
80003caa:	70 09       	ld.w	r9,r8[0x0]
80003cac:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003cb0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003cb4:	70 09       	ld.w	r9,r8[0x0]
80003cb6:	2f f9       	sub	r9,-1
80003cb8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cba:	e0 49 01 ff 	cp.w	r9,511
80003cbe:	e0 88 00 16 	brls	80003cea <phy_rx_func+0xc22>
						{
							RxAMBE_IsFillingNext8 = 0;
80003cc2:	30 09       	mov	r9,0
80003cc4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003cc6:	fe f6 02 56 	ld.w	r6,pc[598]
80003cca:	6c 0c       	ld.w	r12,r6[0x0]
80003ccc:	f0 1f 00 9f 	mcall	80003f48 <phy_rx_func+0xe80>
							AMBE_payload_ptr = get_payload_idle_isr();
80003cd0:	fe f8 02 44 	ld.w	r8,pc[580]
80003cd4:	70 0c       	ld.w	r12,r8[0x0]
80003cd6:	f0 1f 00 8a 	mcall	80003efc <phy_rx_func+0xe34>
80003cda:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003cdc:	c0 71       	brne	80003cea <phy_rx_func+0xc22>
							{
								RxMediaState = WAITINGABAB;
80003cde:	30 09       	mov	r9,0
80003ce0:	fe f8 02 44 	ld.w	r8,pc[580]
80003ce4:	91 09       	st.w	r8[0x0],r9
80003ce6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003cea:	fe f9 02 42 	ld.w	r9,pc[578]
80003cee:	72 08       	ld.w	r8,r9[0x0]
80003cf0:	20 18       	sub	r8,1
80003cf2:	93 08       	st.w	r9[0x0],r8
80003cf4:	c0 71       	brne	80003d02 <phy_rx_func+0xc3a>
							RxMediaState = WAITINGABAB;
80003cf6:	30 09       	mov	r9,0
80003cf8:	fe f8 02 2c 	ld.w	r8,pc[556]
80003cfc:	91 09       	st.w	r8[0x0],r9
80003cfe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//5
80003d02:	fe f8 02 3e 	ld.w	r8,pc[574]
80003d06:	fe f9 02 16 	ld.w	r9,pc[534]
80003d0a:	72 0a       	ld.w	r10,r9[0x0]
80003d0c:	70 09       	ld.w	r9,r8[0x0]
80003d0e:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003d12:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d16:	70 09       	ld.w	r9,r8[0x0]
80003d18:	2f f9       	sub	r9,-1
80003d1a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d1c:	e0 49 01 ff 	cp.w	r9,511
80003d20:	e0 88 00 13 	brls	80003d46 <phy_rx_func+0xc7e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d24:	30 09       	mov	r9,0
80003d26:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d28:	4f d6       	lddpc	r6,80003f1c <phy_rx_func+0xe54>
80003d2a:	6c 0c       	ld.w	r12,r6[0x0]
80003d2c:	f0 1f 00 87 	mcall	80003f48 <phy_rx_func+0xe80>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d30:	4f 98       	lddpc	r8,80003f14 <phy_rx_func+0xe4c>
80003d32:	70 0c       	ld.w	r12,r8[0x0]
80003d34:	f0 1f 00 72 	mcall	80003efc <phy_rx_func+0xe34>
80003d38:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d3a:	c0 61       	brne	80003d46 <phy_rx_func+0xc7e>
							{
								RxMediaState = WAITINGABAB;
80003d3c:	30 09       	mov	r9,0
80003d3e:	4f a8       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003d40:	91 09       	st.w	r8[0x0],r9
80003d42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d46:	4f a9       	lddpc	r9,80003f2c <phy_rx_func+0xe64>
80003d48:	72 08       	ld.w	r8,r9[0x0]
80003d4a:	20 18       	sub	r8,1
80003d4c:	93 08       	st.w	r9[0x0],r8
80003d4e:	c0 61       	brne	80003d5a <phy_rx_func+0xc92>
							RxMediaState = WAITINGABAB;
80003d50:	30 09       	mov	r9,0
80003d52:	4f 58       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003d54:	91 09       	st.w	r8[0x0],r9
80003d56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//6
80003d5a:	4f a8       	lddpc	r8,80003f40 <phy_rx_func+0xe78>
80003d5c:	4f 09       	lddpc	r9,80003f1c <phy_rx_func+0xe54>
80003d5e:	72 0a       	ld.w	r10,r9[0x0]
80003d60:	70 09       	ld.w	r9,r8[0x0]
80003d62:	ef 3b 00 0d 	ld.ub	r11,r7[13]
80003d66:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d6a:	70 09       	ld.w	r9,r8[0x0]
80003d6c:	2f f9       	sub	r9,-1
80003d6e:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d70:	e0 49 01 ff 	cp.w	r9,511
80003d74:	e0 88 00 13 	brls	80003d9a <phy_rx_func+0xcd2>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d78:	30 09       	mov	r9,0
80003d7a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d7c:	4e 86       	lddpc	r6,80003f1c <phy_rx_func+0xe54>
80003d7e:	6c 0c       	ld.w	r12,r6[0x0]
80003d80:	f0 1f 00 72 	mcall	80003f48 <phy_rx_func+0xe80>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d84:	4e 48       	lddpc	r8,80003f14 <phy_rx_func+0xe4c>
80003d86:	70 0c       	ld.w	r12,r8[0x0]
80003d88:	f0 1f 00 5d 	mcall	80003efc <phy_rx_func+0xe34>
80003d8c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d8e:	c0 61       	brne	80003d9a <phy_rx_func+0xcd2>
							{
								RxMediaState = WAITINGABAB;
80003d90:	30 09       	mov	r9,0
80003d92:	4e 58       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003d94:	91 09       	st.w	r8[0x0],r9
80003d96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d9a:	4e 59       	lddpc	r9,80003f2c <phy_rx_func+0xe64>
80003d9c:	72 08       	ld.w	r8,r9[0x0]
80003d9e:	20 18       	sub	r8,1
80003da0:	93 08       	st.w	r9[0x0],r8
80003da2:	c0 61       	brne	80003dae <phy_rx_func+0xce6>
							RxMediaState = WAITINGABAB;
80003da4:	30 09       	mov	r9,0
80003da6:	4e 08       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003da8:	91 09       	st.w	r8[0x0],r9
80003daa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//7
80003dae:	4e 58       	lddpc	r8,80003f40 <phy_rx_func+0xe78>
80003db0:	4d b9       	lddpc	r9,80003f1c <phy_rx_func+0xe54>
80003db2:	72 0a       	ld.w	r10,r9[0x0]
80003db4:	70 09       	ld.w	r9,r8[0x0]
80003db6:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003dba:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003dbe:	70 09       	ld.w	r9,r8[0x0]
80003dc0:	2f f9       	sub	r9,-1
80003dc2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003dc4:	e0 49 01 ff 	cp.w	r9,511
80003dc8:	e0 88 00 13 	brls	80003dee <phy_rx_func+0xd26>
						{
							RxAMBE_IsFillingNext8 = 0;
80003dcc:	30 09       	mov	r9,0
80003dce:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003dd0:	4d 37       	lddpc	r7,80003f1c <phy_rx_func+0xe54>
80003dd2:	6e 0c       	ld.w	r12,r7[0x0]
80003dd4:	f0 1f 00 5d 	mcall	80003f48 <phy_rx_func+0xe80>
							AMBE_payload_ptr = get_payload_idle_isr();
80003dd8:	4c f8       	lddpc	r8,80003f14 <phy_rx_func+0xe4c>
80003dda:	70 0c       	ld.w	r12,r8[0x0]
80003ddc:	f0 1f 00 48 	mcall	80003efc <phy_rx_func+0xe34>
80003de0:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003de2:	c0 61       	brne	80003dee <phy_rx_func+0xd26>
							{
								RxMediaState = WAITINGABAB;
80003de4:	30 09       	mov	r9,0
80003de6:	4d 08       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003de8:	91 09       	st.w	r8[0x0],r9
80003dea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003dee:	4d 09       	lddpc	r9,80003f2c <phy_rx_func+0xe64>
80003df0:	72 08       	ld.w	r8,r9[0x0]
80003df2:	20 18       	sub	r8,1
80003df4:	93 08       	st.w	r9[0x0],r8
80003df6:	c0 61       	brne	80003e02 <phy_rx_func+0xd3a>
							RxMediaState = WAITINGABAB;
80003df8:	30 09       	mov	r9,0
80003dfa:	4c b8       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003dfc:	91 09       	st.w	r8[0x0],r9
80003dfe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003e02:	20 18       	sub	r8,1
80003e04:	4c a9       	lddpc	r9,80003f2c <phy_rx_func+0xe64>
80003e06:	93 08       	st.w	r9[0x0],r8
80003e08:	58 08       	cp.w	r8,0
80003e0a:	c6 a1       	brne	80003ede <phy_rx_func+0xe16>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003e0c:	30 09       	mov	r9,0
80003e0e:	4c 68       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003e10:	91 09       	st.w	r8[0x0],r9
80003e12:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003e16:	4c 98       	lddpc	r8,80003f38 <phy_rx_func+0xe70>
80003e18:	11 89       	ld.ub	r9,r8[0x0]
80003e1a:	30 48       	mov	r8,4
80003e1c:	f0 09 18 00 	cp.b	r9,r8
80003e20:	c0 70       	breq	80003e2e <phy_rx_func+0xd66>
80003e22:	4c 68       	lddpc	r8,80003f38 <phy_rx_func+0xe70>
80003e24:	11 89       	ld.ub	r9,r8[0x0]
80003e26:	30 38       	mov	r8,3
80003e28:	f0 09 18 00 	cp.b	r9,r8
80003e2c:	c1 01       	brne	80003e4c <phy_rx_func+0xd84>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003e2e:	6e 29       	ld.w	r9,r7[0x8]
80003e30:	4c d8       	lddpc	r8,80003f64 <phy_rx_func+0xe9c>
80003e32:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003e34:	6e 39       	ld.w	r9,r7[0xc]
80003e36:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003e38:	4b d9       	lddpc	r9,80003f2c <phy_rx_func+0xe64>
80003e3a:	72 08       	ld.w	r8,r9[0x0]
80003e3c:	20 88       	sub	r8,8
80003e3e:	93 08       	st.w	r9[0x0],r8
80003e40:	c4 f1       	brne	80003ede <phy_rx_func+0xe16>
						{
					
							RxBytesWaiting = 0;
80003e42:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003e44:	4b 89       	lddpc	r9,80003f24 <phy_rx_func+0xe5c>
80003e46:	93 08       	st.w	r9[0x0],r8
80003e48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003e4c:	30 09       	mov	r9,0
80003e4e:	4b 68       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003e50:	91 09       	st.w	r8[0x0],r9
80003e52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
			break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003e56:	4c 28       	lddpc	r8,80003f5c <phy_rx_func+0xe94>
80003e58:	70 09       	ld.w	r9,r8[0x0]
80003e5a:	8e 4b       	ld.sh	r11,r7[0x8]
80003e5c:	4c 1a       	lddpc	r10,80003f60 <phy_rx_func+0xe98>
80003e5e:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003e62:	2f f9       	sub	r9,-1
80003e64:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003e66:	4b 68       	lddpc	r8,80003f3c <phy_rx_func+0xe74>
80003e68:	70 09       	ld.w	r9,r8[0x0]
80003e6a:	20 29       	sub	r9,2
80003e6c:	91 09       	st.w	r8[0x0],r9
80003e6e:	70 08       	ld.w	r8,r8[0x0]
80003e70:	58 08       	cp.w	r8,0
80003e72:	c3 01       	brne	80003ed2 <phy_rx_func+0xe0a>
				{
					RxData_IsFillingNext16 = 0;
80003e74:	30 09       	mov	r9,0
80003e76:	4b a8       	lddpc	r8,80003f5c <phy_rx_func+0xe94>
80003e78:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003e7a:	8e 59       	ld.sh	r9,r7[0xa]
80003e7c:	fe 78 82 12 	mov	r8,-32238
80003e80:	f0 09 19 00 	cp.h	r9,r8
80003e84:	c2 21       	brne	80003ec8 <phy_rx_func+0xe00>
				
					if (payload_rx_channel->word[1] == 0x8212 )
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						VF_SN = payload_rx_channel->byte[5];//This parameter is very important to the loop back Radio, as a reference.
80003e86:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003e8a:	4b 18       	lddpc	r8,80003f4c <phy_rx_func+0xe84>
80003e8c:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003e8e:	8e 59       	ld.sh	r9,r7[0xa]
80003e90:	4b 08       	lddpc	r8,80003f50 <phy_rx_func+0xe88>
80003e92:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003e94:	8e 69       	ld.sh	r9,r7[0xc]
80003e96:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003e98:	f0 1f 00 2f 	mcall	80003f54 <phy_rx_func+0xe8c>
80003e9c:	4a 38       	lddpc	r8,80003f28 <phy_rx_func+0xe60>
80003e9e:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003ea0:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003ea4:	3f 38       	mov	r8,-13
80003ea6:	f0 09 18 00 	cp.b	r9,r8
80003eaa:	c0 a1       	brne	80003ebe <phy_rx_func+0xdf6>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Pre_Voice_Decoder_Data)//0xF3
						{
							Item_ID = Pre_Voice_Decoder_Data;
80003eac:	10 99       	mov	r9,r8
80003eae:	4a 38       	lddpc	r8,80003f38 <phy_rx_func+0xe70>
80003eb0:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 8
80003eb2:	30 09       	mov	r9,0
80003eb4:	49 e8       	lddpc	r8,80003f2c <phy_rx_func+0xe64>
80003eb6:	91 09       	st.w	r8[0x0],r9
							AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003eb8:	30 19       	mov	r9,1
80003eba:	4a d8       	lddpc	r8,80003f6c <phy_rx_func+0xea4>
80003ebc:	b0 89       	st.b	r8[0x0],r9
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003ebe:	30 49       	mov	r9,4
80003ec0:	49 98       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003ec2:	91 09       	st.w	r8[0x0],r9
80003ec4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003ec8:	30 09       	mov	r9,0
80003eca:	49 78       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003ecc:	91 09       	st.w	r8[0x0],r9
80003ece:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003ed2:	4a dc       	lddpc	r12,80003f84 <phy_rx_func+0xebc>
80003ed4:	f0 1f 00 18 	mcall	80003f34 <phy_rx_func+0xe6c>
					RxMediaState = WAITINGABAB;//Jump
80003ed8:	30 09       	mov	r9,0
80003eda:	49 38       	lddpc	r8,80003f24 <phy_rx_func+0xe5c>
80003edc:	91 09       	st.w	r8[0x0],r9
80003ede:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003ee2:	00 00       	add	r0,r0
80003ee4:	00 00       	add	r0,r0
80003ee6:	0a bc       	st.h	r5++,r12
80003ee8:	00 00       	add	r0,r0
80003eea:	0a b4       	st.h	r5++,r4
80003eec:	00 00       	add	r0,r0
80003eee:	0a 94       	mov	r4,r5
80003ef0:	00 00       	add	r0,r0
80003ef2:	0a e0       	st.h	--r5,r0
80003ef4:	00 00       	add	r0,r0
80003ef6:	0a d8       	st.w	--r5,r8
80003ef8:	00 00       	add	r0,r0
80003efa:	0a b8       	st.h	r5++,r8
80003efc:	80 00       	ld.sh	r0,r0[0x0]
80003efe:	2a 80       	sub	r0,-88
80003f00:	00 00       	add	r0,r0
80003f02:	0a 78       	tst	r8,r5
80003f04:	80 00       	ld.sh	r0,r0[0x0]
80003f06:	55 24       	stdsp	sp[0x148],r4
80003f08:	00 00       	add	r0,r0
80003f0a:	0a a0       	st.w	r5++,r0
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	29 cc       	sub	r12,-100
80003f10:	00 00       	add	r0,r0
80003f12:	0a a3       	st.w	r5++,r3
80003f14:	00 00       	add	r0,r0
80003f16:	0a 70       	tst	r0,r5
80003f18:	00 00       	add	r0,r0
80003f1a:	0a c4       	st.b	r5++,r4
80003f1c:	00 00       	add	r0,r0
80003f1e:	0a 6c       	and	r12,r5
80003f20:	00 00       	add	r0,r0
80003f22:	04 f4       	st.b	--r2,r4
80003f24:	00 00       	add	r0,r0
80003f26:	0a b0       	st.h	r5++,r0
80003f28:	00 00       	add	r0,r0
80003f2a:	0a 68       	and	r8,r5
80003f2c:	00 00       	add	r0,r0
80003f2e:	0a 8c       	andn	r12,r5
80003f30:	80 00       	ld.sh	r0,r0[0x0]
80003f32:	d3 98       	*unknown*
80003f34:	80 00       	ld.sh	r0,r0[0x0]
80003f36:	66 1c       	ld.w	r12,r3[0x4]
80003f38:	00 00       	add	r0,r0
80003f3a:	0a a2       	st.w	r5++,r2
80003f3c:	00 00       	add	r0,r0
80003f3e:	0a 80       	andn	r0,r5
80003f40:	00 00       	add	r0,r0
80003f42:	0a c0       	st.b	r5++,r0
80003f44:	80 00       	ld.sh	r0,r0[0x0]
80003f46:	6f 38       	ld.w	r8,r7[0x4c]
80003f48:	80 00       	ld.sh	r0,r0[0x0]
80003f4a:	30 68       	mov	r8,6
80003f4c:	00 00       	add	r0,r0
80003f4e:	0a 54       	eor	r4,r5
80003f50:	00 00       	add	r0,r0
80003f52:	0e b8       	st.h	r7++,r8
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	29 10       	sub	r0,-111
80003f58:	80 00       	ld.sh	r0,r0[0x0]
80003f5a:	d3 b0       	acall	0x3b
80003f5c:	00 00       	add	r0,r0
80003f5e:	0a a4       	st.w	r5++,r4
80003f60:	00 00       	add	r0,r0
80003f62:	0d bc       	ld.ub	r12,r6[0x3]
80003f64:	00 00       	add	r0,r0
80003f66:	0a 98       	mov	r8,r5
80003f68:	00 00       	add	r0,r0
80003f6a:	0a 50       	eor	r0,r5
80003f6c:	00 00       	add	r0,r0
80003f6e:	0a 52       	eor	r2,r5
80003f70:	00 00       	add	r0,r0
80003f72:	0a 64       	and	r4,r5
80003f74:	00 00       	add	r0,r0
80003f76:	0a d4       	st.w	--r5,r4
80003f78:	00 00       	add	r0,r0
80003f7a:	0a 57       	eor	r7,r5
80003f7c:	00 00       	add	r0,r0
80003f7e:	0a 56       	eor	r6,r5
80003f80:	00 00       	add	r0,r0
80003f82:	0d b4       	ld.ub	r4,r6[0x3]
80003f84:	80 00       	ld.sh	r0,r0[0x0]
80003f86:	d3 c4       	*unknown*

80003f88 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003f88:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003f8a:	49 88       	lddpc	r8,80003fe8 <pdca_int_handler+0x60>
80003f8c:	11 89       	ld.ub	r9,r8[0x0]
80003f8e:	ec 19 00 01 	eorl	r9,0x1
80003f92:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003f94:	11 89       	ld.ub	r9,r8[0x0]
80003f96:	a5 69       	lsl	r9,0x4
80003f98:	2f c9       	sub	r9,-4
80003f9a:	49 5a       	lddpc	r10,80003fec <pdca_int_handler+0x64>
80003f9c:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003f9e:	fe 7a 00 40 	mov	r10,-65472
80003fa2:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003fa4:	30 39       	mov	r9,3
80003fa6:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003fa8:	11 8a       	ld.ub	r10,r8[0x0]
80003faa:	a5 6a       	lsl	r10,0x4
80003fac:	2f ca       	sub	r10,-4
80003fae:	49 18       	lddpc	r8,80003ff0 <pdca_int_handler+0x68>
80003fb0:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003fb2:	fe 78 00 00 	mov	r8,-65536
80003fb6:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003fb8:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003fba:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003fbc:	48 e8       	lddpc	r8,80003ff4 <pdca_int_handler+0x6c>
80003fbe:	70 08       	ld.w	r8,r8[0x0]
80003fc0:	58 08       	cp.w	r8,0
80003fc2:	c0 70       	breq	80003fd0 <pdca_int_handler+0x48>
80003fc4:	48 99       	lddpc	r9,80003fe8 <pdca_int_handler+0x60>
80003fc6:	13 89       	ld.ub	r9,r9[0x0]
80003fc8:	a5 69       	lsl	r9,0x4
80003fca:	48 ac       	lddpc	r12,80003ff0 <pdca_int_handler+0x68>
80003fcc:	12 0c       	add	r12,r9
80003fce:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003fd0:	48 a8       	lddpc	r8,80003ff8 <pdca_int_handler+0x70>
80003fd2:	70 08       	ld.w	r8,r8[0x0]
80003fd4:	58 08       	cp.w	r8,0
80003fd6:	c0 70       	breq	80003fe4 <pdca_int_handler+0x5c>
80003fd8:	48 49       	lddpc	r9,80003fe8 <pdca_int_handler+0x60>
80003fda:	13 89       	ld.ub	r9,r9[0x0]
80003fdc:	a5 69       	lsl	r9,0x4
80003fde:	48 4c       	lddpc	r12,80003fec <pdca_int_handler+0x64>
80003fe0:	12 0c       	add	r12,r9
80003fe2:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003fe4:	d4 02       	popm	lr
80003fe6:	d6 03       	rete
80003fe8:	00 00       	add	r0,r0
80003fea:	40 c0       	lddsp	r0,sp[0x30]
80003fec:	00 00       	add	r0,r0
80003fee:	40 e8       	lddsp	r8,sp[0x38]
80003ff0:	00 00       	add	r0,r0
80003ff2:	40 c8       	lddsp	r8,sp[0x30]
80003ff4:	00 00       	add	r0,r0
80003ff6:	0a e4       	st.h	--r5,r4
80003ff8:	00 00       	add	r0,r0
80003ffa:	0a e8       	st.h	--r5,r8

80003ffc <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003ffc:	fe 78 10 00 	mov	r8,-61440
80004000:	e0 69 0d c0 	mov	r9,3520
80004004:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80004008:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
8000400c:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80004010:	fe 78 34 00 	mov	r8,-52224
80004014:	e0 69 80 00 	mov	r9,32768
80004018:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
8000401a:	30 09       	mov	r9,0
8000401c:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
8000401e:	e0 69 04 21 	mov	r9,1057
80004022:	ea 19 3f 20 	orh	r9,0x3f20
80004026:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
80004028:	e0 69 02 9f 	mov	r9,671
8000402c:	ea 19 01 00 	orh	r9,0x100
80004030:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
80004032:	e0 6a 04 02 	mov	r10,1026
80004036:	ea 1a 3f 20 	orh	r10,0x3f20
8000403a:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
8000403c:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
8000403e:	5e fc       	retal	r12

80004040 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004040:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80004042:	30 19       	mov	r9,1
80004044:	49 78       	lddpc	r8,800040a0 <local_start_PDC+0x60>
80004046:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004048:	fe 78 00 00 	mov	r8,-65536
8000404c:	30 7b       	mov	r11,7
8000404e:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004050:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80004052:	49 59       	lddpc	r9,800040a4 <local_start_PDC+0x64>
80004054:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004058:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
8000405a:	30 3a       	mov	r10,3
8000405c:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
8000405e:	30 1c       	mov	r12,1
80004060:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80004062:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80004064:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004066:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004068:	30 2c       	mov	r12,2
8000406a:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
8000406c:	48 f9       	lddpc	r9,800040a8 <local_start_PDC+0x68>
8000406e:	e0 68 5a 5a 	mov	r8,23130
80004072:	ea 18 ab cd 	orh	r8,0xabcd
80004076:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004078:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
8000407a:	30 0e       	mov	lr,0
8000407c:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
8000407e:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004080:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80004082:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80004084:	fe 78 00 40 	mov	r8,-65472
80004088:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
8000408a:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
8000408c:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004090:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80004092:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80004094:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80004096:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004098:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000409a:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
8000409c:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
8000409e:	d8 02       	popm	pc
800040a0:	00 00       	add	r0,r0
800040a2:	40 c0       	lddsp	r0,sp[0x30]
800040a4:	00 00       	add	r0,r0
800040a6:	40 c8       	lddsp	r8,sp[0x30]
800040a8:	00 00       	add	r0,r0
800040aa:	40 e8       	lddsp	r8,sp[0x38]

800040ac <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
800040ac:	48 38       	lddpc	r8,800040b8 <register_rx_tx_func+0xc>
800040ae:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
800040b0:	48 38       	lddpc	r8,800040bc <register_rx_tx_func+0x10>
800040b2:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
800040b4:	5e fc       	retal	r12
800040b6:	00 00       	add	r0,r0
800040b8:	00 00       	add	r0,r0
800040ba:	0a e4       	st.h	--r5,r4
800040bc:	00 00       	add	r0,r0
800040be:	0a e8       	st.h	--r5,r8

800040c0 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
800040c0:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
800040c2:	fe 78 10 00 	mov	r8,-61440
800040c6:	30 29       	mov	r9,2
800040c8:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
800040cc:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800040d0:	10 99       	mov	r9,r8
800040d2:	f2 f8 01 60 	ld.w	r8,r9[352]
800040d6:	e2 18 00 02 	andl	r8,0x2,COH
800040da:	cf c0       	breq	800040d2 <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800040dc:	fe 79 10 00 	mov	r9,-61440
800040e0:	f2 f8 01 60 	ld.w	r8,r9[352]
800040e4:	e2 18 00 02 	andl	r8,0x2,COH
800040e8:	cf c1       	brne	800040e0 <ssc_init+0x20>
				
    INTC_register_interrupt (
800040ea:	30 3a       	mov	r10,3
800040ec:	36 0b       	mov	r11,96
800040ee:	48 bc       	lddpc	r12,80004118 <ssc_init+0x58>
800040f0:	f0 1f 00 0b 	mcall	8000411c <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
800040f4:	f0 1f 00 0b 	mcall	80004120 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
800040f8:	f0 1f 00 0b 	mcall	80004124 <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800040fc:	fe 79 00 00 	mov	r9,-65536
80004100:	30 18       	mov	r8,1
80004102:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80004104:	fe 7a 00 40 	mov	r10,-65472
80004108:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
8000410a:	e0 6b 01 01 	mov	r11,257
8000410e:	fe 7a 34 00 	mov	r10,-52224
80004112:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
80004114:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
80004116:	d8 02       	popm	pc
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	3f 88       	mov	r8,-8
8000411c:	80 00       	ld.sh	r0,r0[0x0]
8000411e:	4b 5c       	lddpc	r12,800041f0 <xcmp_DeviceInitializationStatus_request+0x38>
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	3f fc       	mov	r12,-1
80004124:	80 00       	ld.sh	r0,r0[0x0]
80004126:	40 40       	lddsp	r0,sp[0x10]

80004128 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80004128:	48 28       	lddpc	r8,80004130 <xcmp_register_app_list+0x8>
8000412a:	91 0c       	st.w	r8[0x0],r12
}
8000412c:	5e fc       	retal	r12
8000412e:	00 00       	add	r0,r0
80004130:	00 00       	add	r0,r0
80004132:	41 08       	lddsp	r8,sp[0x40]

80004134 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004134:	eb cd 40 80 	pushm	r7,lr
80004138:	fa cd 01 00 	sub	sp,sp,256
8000413c:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000413e:	16 98       	mov	r8,r11
80004140:	2f 08       	sub	r8,-16
80004142:	af a8       	sbr	r8,0xe
80004144:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80004146:	3f f8       	mov	r8,-1
80004148:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000414a:	30 b9       	mov	r9,11
8000414c:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000414e:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004150:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004152:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004154:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80004156:	f6 ca ff fe 	sub	r10,r11,-2
8000415a:	18 9b       	mov	r11,r12
8000415c:	fa cc ff f0 	sub	r12,sp,-16
80004160:	f0 1f 00 05 	mcall	80004174 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004164:	2f e7       	sub	r7,-2
80004166:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80004168:	1a 9c       	mov	r12,sp
8000416a:	f0 1f 00 04 	mcall	80004178 <xcmp_tx+0x44>
}
8000416e:	2c 0d       	sub	sp,-256
80004170:	e3 cd 80 80 	ldm	sp++,r7,pc
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	6d f0       	ld.w	r0,r6[0x7c]
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	45 c0       	lddsp	r0,sp[0x170]

8000417c <xcmp_audio_route_speaker>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_speaker(void)
{
8000417c:	d4 01       	pushm	lr
8000417e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
80004182:	e0 68 04 14 	mov	r8,1044
80004186:	ba 18       	st.h	sp[0x2],r8
		
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80004188:	fa c8 ff fc 	sub	r8,sp,-4
		
	ptr->Function = Routing_Func_Update_Source;
8000418c:	30 19       	mov	r9,1
8000418e:	b0 89       	st.b	r8[0x0],r9
		
		
	unsigned short NumberofRoutings =  2;//2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80004190:	30 0a       	mov	r10,0
80004192:	b0 9a       	st.b	r8[0x1],r10
	ptr->NumberofRoutings[1] =  NumberofRoutings & 0xFF;
80004194:	30 2a       	mov	r10,2
80004196:	b0 aa       	st.b	r8[0x2],r10
		
	
	
	
	ptr->RoutingData[0].audioInput = IN_Pre_Speaker_Audio_Data;//IN_Pre_Speaker_Audio_Data;//IN_Microphone;//IN_Option_Board;
80004198:	30 da       	mov	r10,13
8000419a:	b0 ba       	st.b	r8[0x3],r10
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;//OUT_Option_Board;//OUT_Microphone_Data;//测试
8000419c:	30 ca       	mov	r10,12
8000419e:	b0 ca       	st.b	r8[0x4],r10
	
	
	//ptr->RoutingData[0].audioInput = IN_Microphone;//IN_Option_Board;
	//ptr->RoutingData[0].audioOutput =OUT_Option_Board;// OUT_Speaker;
	
	ptr->RoutingData[1].audioInput = IN_Option_Board;//IN_Option_Board;
800041a0:	b0 da       	st.b	r8[0x5],r10
	ptr->RoutingData[1].audioOutput = OUT_Speaker;//OUT_Microphone_Data;//测试
800041a2:	b0 e9       	st.b	r8[0x6],r9
	
	//ptr->RoutingData[1].audioInput = IN_Option_Board;
	//ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;//测试OUT_Speaker;//
		
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
800041a4:	30 7b       	mov	r11,7
800041a6:	fa cc ff fe 	sub	r12,sp,-2
800041aa:	f0 1f 00 03 	mcall	800041b4 <xcmp_audio_route_speaker+0x38>
}
800041ae:	2c dd       	sub	sp,-204
800041b0:	d8 02       	popm	pc
800041b2:	00 00       	add	r0,r0
800041b4:	80 00       	ld.sh	r0,r0[0x0]
800041b6:	41 34       	lddsp	r4,sp[0x4c]

800041b8 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800041b8:	d4 01       	pushm	lr
800041ba:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800041be:	fe 78 b4 00 	mov	r8,-19456
800041c2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800041c4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800041c8:	30 89       	mov	r9,8
800041ca:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800041cc:	30 19       	mov	r9,1
800041ce:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800041d0:	30 09       	mov	r9,0
800041d2:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800041d4:	30 5a       	mov	r10,5
800041d6:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800041d8:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800041da:	30 7a       	mov	r10,7
800041dc:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
800041de:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
800041e0:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
800041e2:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
800041e6:	30 9b       	mov	r11,9
800041e8:	fa cc ff fe 	sub	r12,sp,-2
800041ec:	f0 1f 00 02 	mcall	800041f4 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800041f0:	2c dd       	sub	sp,-204
800041f2:	d8 02       	popm	pc
800041f4:	80 00       	ld.sh	r0,r0[0x0]
800041f6:	41 34       	lddsp	r4,sp[0x4c]

800041f8 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800041f8:	d4 01       	pushm	lr
800041fa:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800041fe:	fe 78 80 00 	mov	r8,-32768
80004202:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004204:	30 38       	mov	r8,3
80004206:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80004208:	30 1b       	mov	r11,1
8000420a:	fa cc ff fe 	sub	r12,sp,-2
8000420e:	f0 1f 00 03 	mcall	80004218 <xcmp_opcode_not_supported+0x20>
}
80004212:	2c dd       	sub	sp,-204
80004214:	d8 02       	popm	pc
80004216:	00 00       	add	r0,r0
80004218:	80 00       	ld.sh	r0,r0[0x0]
8000421a:	41 34       	lddsp	r4,sp[0x4c]

8000421c <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
8000421c:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
8000421e:	96 88       	ld.uh	r8,r11[0x0]
80004220:	e2 18 f0 00 	andl	r8,0xf000,COH
80004224:	e0 48 80 00 	cp.w	r8,32768
80004228:	c0 f0       	breq	80004246 <xcmp_exec_func+0x2a>
8000422a:	e0 48 b0 00 	cp.w	r8,45056
8000422e:	c1 20       	breq	80004252 <xcmp_exec_func+0x36>
80004230:	58 08       	cp.w	r8,0
80004232:	c1 51       	brne	8000425c <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004234:	78 08       	ld.w	r8,r12[0x0]
80004236:	58 08       	cp.w	r8,0
80004238:	c0 40       	breq	80004240 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000423a:	16 9c       	mov	r12,r11
8000423c:	5d 18       	icall	r8
8000423e:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004240:	f0 1f 00 08 	mcall	80004260 <xcmp_exec_func+0x44>
80004244:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80004246:	78 18       	ld.w	r8,r12[0x4]
80004248:	58 08       	cp.w	r8,0
8000424a:	c0 90       	breq	8000425c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
8000424c:	16 9c       	mov	r12,r11
8000424e:	5d 18       	icall	r8
80004250:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004252:	78 28       	ld.w	r8,r12[0x8]
80004254:	58 08       	cp.w	r8,0
80004256:	c0 30       	breq	8000425c <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80004258:	16 9c       	mov	r12,r11
8000425a:	5d 18       	icall	r8
8000425c:	d8 02       	popm	pc
8000425e:	00 00       	add	r0,r0
80004260:	80 00       	ld.sh	r0,r0[0x0]
80004262:	41 f8       	lddsp	r8,sp[0x7c]

80004264 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
80004264:	d4 01       	pushm	lr
80004266:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000426a:	e0 68 04 09 	mov	r8,1033
8000426e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004270:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
80004274:	30 19       	mov	r9,1
80004276:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80004278:	30 09       	mov	r9,0
8000427a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
8000427c:	30 ca       	mov	r10,12
8000427e:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80004280:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80004282:	fb 69 00 08 	st.b	sp[8],r9
80004286:	fa c8 ff f7 	sub	r8,sp,-9
8000428a:	b0 89       	st.b	r8[0x0],r9
8000428c:	fa c8 ff f6 	sub	r8,sp,-10
80004290:	b0 89       	st.b	r8[0x0],r9
80004292:	fa c8 ff f5 	sub	r8,sp,-11
80004296:	b0 89       	st.b	r8[0x0],r9
80004298:	fa c8 ff f4 	sub	r8,sp,-12
8000429c:	b0 89       	st.b	r8[0x0],r9
8000429e:	fa c8 ff f3 	sub	r8,sp,-13
800042a2:	b0 89       	st.b	r8[0x0],r9
800042a4:	fa c8 ff f2 	sub	r8,sp,-14
800042a8:	b0 89       	st.b	r8[0x0],r9
800042aa:	fa c8 ff f1 	sub	r8,sp,-15
800042ae:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800042b0:	30 cb       	mov	r11,12
800042b2:	fa cc ff fe 	sub	r12,sp,-2
800042b6:	f0 1f 00 03 	mcall	800042c0 <xcmp_IdleTestTone+0x5c>
}
800042ba:	2c dd       	sub	sp,-204
800042bc:	d8 02       	popm	pc
800042be:	00 00       	add	r0,r0
800042c0:	80 00       	ld.sh	r0,r0[0x0]
800042c2:	41 34       	lddsp	r4,sp[0x4c]

800042c4 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800042c4:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
800042c6:	f0 1f 00 0d 	mcall	800042f8 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800042ca:	48 dc       	lddpc	r12,800042fc <xcmp_init+0x38>
800042cc:	f0 1f 00 0d 	mcall	80004300 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800042d0:	30 4b       	mov	r11,4
800042d2:	31 4c       	mov	r12,20
800042d4:	f0 1f 00 0c 	mcall	80004304 <xcmp_init+0x40>
800042d8:	48 c8       	lddpc	r8,80004308 <xcmp_init+0x44>
800042da:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800042dc:	30 09       	mov	r9,0
800042de:	1a d9       	st.w	--sp,r9
800042e0:	1a d9       	st.w	--sp,r9
800042e2:	1a d9       	st.w	--sp,r9
800042e4:	30 38       	mov	r8,3
800042e6:	e0 6a 01 80 	mov	r10,384
800042ea:	48 9b       	lddpc	r11,8000430c <xcmp_init+0x48>
800042ec:	48 9c       	lddpc	r12,80004310 <xcmp_init+0x4c>
800042ee:	f0 1f 00 0a 	mcall	80004314 <xcmp_init+0x50>
800042f2:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
800042f4:	d8 02       	popm	pc
800042f6:	00 00       	add	r0,r0
800042f8:	80 00       	ld.sh	r0,r0[0x0]
800042fa:	46 a4       	lddsp	r4,sp[0x1a8]
800042fc:	80 00       	ld.sh	r0,r0[0x0]
800042fe:	44 14       	lddsp	r4,sp[0x104]
80004300:	80 00       	ld.sh	r0,r0[0x0]
80004302:	44 60       	lddsp	r0,sp[0x118]
80004304:	80 00       	ld.sh	r0,r0[0x0]
80004306:	59 f8       	cp.w	r8,31
80004308:	00 00       	add	r0,r0
8000430a:	0a f8       	st.b	--r5,r8
8000430c:	80 00       	ld.sh	r0,r0[0x0]
8000430e:	d3 f0       	acall	0x3f
80004310:	80 00       	ld.sh	r0,r0[0x0]
80004312:	43 18       	lddsp	r8,sp[0xc4]
80004314:	80 00       	ld.sh	r0,r0[0x0]
80004316:	60 cc       	ld.w	r12,r0[0x30]

80004318 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80004318:	d4 31       	pushm	r0-r7,lr
8000431a:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000431c:	4b 16       	lddpc	r6,800043e0 <xcmp_rx_process+0xc8>
8000431e:	30 05       	mov	r5,0
80004320:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004322:	4b 13       	lddpc	r3,800043e4 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004324:	4b 12       	lddpc	r2,800043e8 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004326:	4b 21       	lddpc	r1,800043ec <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004328:	4b 20       	lddpc	r0,800043f0 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000432a:	6c 0c       	ld.w	r12,r6[0x0]
8000432c:	0a 99       	mov	r9,r5
8000432e:	08 9a       	mov	r10,r4
80004330:	1a 9b       	mov	r11,sp
80004332:	f0 1f 00 31 	mcall	800043f4 <xcmp_rx_process+0xdc>
80004336:	58 1c       	cp.w	r12,1
80004338:	cf 91       	brne	8000432a <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000433a:	40 0b       	lddsp	r11,sp[0x0]
8000433c:	58 0b       	cp.w	r11,0
8000433e:	cf 60       	breq	8000432a <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
80004340:	96 0a       	ld.sh	r10,r11[0x0]
80004342:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004346:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000434a:	59 c8       	cp.w	r8,28
8000434c:	c1 e0       	breq	80004388 <xcmp_rx_process+0x70>
8000434e:	e0 89 00 07 	brgt	8000435c <xcmp_rx_process+0x44>
80004352:	58 e8       	cp.w	r8,14
80004354:	c0 e0       	breq	80004370 <xcmp_rx_process+0x58>
80004356:	58 f8       	cp.w	r8,15
80004358:	c2 41       	brne	800043a0 <xcmp_rx_process+0x88>
8000435a:	c0 f8       	rjmp	80004378 <xcmp_rx_process+0x60>
8000435c:	e0 48 01 09 	cp.w	r8,265
80004360:	c1 80       	breq	80004390 <xcmp_rx_process+0x78>
80004362:	e0 48 01 0a 	cp.w	r8,266
80004366:	c1 90       	breq	80004398 <xcmp_rx_process+0x80>
80004368:	e0 48 00 2c 	cp.w	r8,44
8000436c:	c1 a1       	brne	800043a0 <xcmp_rx_process+0x88>
8000436e:	c0 98       	rjmp	80004380 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004370:	4a 2c       	lddpc	r12,800043f8 <xcmp_rx_process+0xe0>
80004372:	f0 1f 00 23 	mcall	800043fc <xcmp_rx_process+0xe4>
					break;
80004376:	c2 f8       	rjmp	800043d4 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80004378:	4a 2c       	lddpc	r12,80004400 <xcmp_rx_process+0xe8>
8000437a:	f0 1f 00 21 	mcall	800043fc <xcmp_rx_process+0xe4>
					break;
8000437e:	c2 b8       	rjmp	800043d4 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80004380:	4a 1c       	lddpc	r12,80004404 <xcmp_rx_process+0xec>
80004382:	f0 1f 00 1f 	mcall	800043fc <xcmp_rx_process+0xe4>
					break;
80004386:	c2 78       	rjmp	800043d4 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004388:	04 9c       	mov	r12,r2
8000438a:	f0 1f 00 1d 	mcall	800043fc <xcmp_rx_process+0xe4>
						, ptr);
					break;
8000438e:	c2 38       	rjmp	800043d4 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80004390:	02 9c       	mov	r12,r1
80004392:	f0 1f 00 1b 	mcall	800043fc <xcmp_rx_process+0xe4>
					break;
80004396:	c1 f8       	rjmp	800043d4 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80004398:	00 9c       	mov	r12,r0
8000439a:	f0 1f 00 19 	mcall	800043fc <xcmp_rx_process+0xe4>
					break;
8000439e:	c1 b8       	rjmp	800043d4 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800043a0:	12 98       	mov	r8,r9
800043a2:	e2 18 04 00 	andl	r8,0x400,COH
800043a6:	c0 70       	breq	800043b4 <xcmp_rx_process+0x9c>
800043a8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800043ac:	e0 48 00 68 	cp.w	r8,104
800043b0:	e0 8a 00 08 	brle	800043c0 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800043b4:	e2 19 f0 00 	andl	r9,0xf000,COH
800043b8:	c0 e1       	brne	800043d4 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800043ba:	f0 1f 00 14 	mcall	80004408 <xcmp_rx_process+0xf0>
800043be:	c0 b8       	rjmp	800043d4 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800043c0:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800043c4:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800043c8:	49 19       	lddpc	r9,8000440c <xcmp_rx_process+0xf4>
800043ca:	72 08       	ld.w	r8,r9[0x0]
800043cc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800043d0:	f0 1f 00 0b 	mcall	800043fc <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800043d4:	66 0c       	ld.w	r12,r3[0x0]
800043d6:	40 0b       	lddsp	r11,sp[0x0]
800043d8:	f0 1f 00 0e 	mcall	80004410 <xcmp_rx_process+0xf8>
800043dc:	ca 7b       	rjmp	8000432a <xcmp_rx_process+0x12>
800043de:	00 00       	add	r0,r0
800043e0:	00 00       	add	r0,r0
800043e2:	0a f8       	st.b	--r5,r8
800043e4:	00 00       	add	r0,r0
800043e6:	0a b8       	st.h	r5++,r8
800043e8:	00 00       	add	r0,r0
800043ea:	0b 08       	ld.w	r8,r5++
800043ec:	00 00       	add	r0,r0
800043ee:	0a fc       	st.b	--r5,r12
800043f0:	00 00       	add	r0,r0
800043f2:	0b 14       	ld.sh	r4,r5++
800043f4:	80 00       	ld.sh	r0,r0[0x0]
800043f6:	56 94       	stdsp	sp[0x1a4],r4
800043f8:	00 00       	add	r0,r0
800043fa:	0b 2c       	ld.uh	r12,r5++
800043fc:	80 00       	ld.sh	r0,r0[0x0]
800043fe:	42 1c       	lddsp	r12,sp[0x84]
80004400:	00 00       	add	r0,r0
80004402:	0a ec       	st.h	--r5,r12
80004404:	00 00       	add	r0,r0
80004406:	0b 20       	ld.uh	r0,r5++
80004408:	80 00       	ld.sh	r0,r0[0x0]
8000440a:	41 f8       	lddsp	r8,sp[0x7c]
8000440c:	00 00       	add	r0,r0
8000440e:	41 08       	lddsp	r8,sp[0x40]
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	2a 04       	sub	r4,-96

80004414 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004414:	eb cd 40 90 	pushm	r4,r7,lr
80004418:	20 1d       	sub	sp,4
8000441a:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000441e:	48 c8       	lddpc	r8,8000444c <xcmp_rx+0x38>
80004420:	70 0c       	ld.w	r12,r8[0x0]
80004422:	f0 1f 00 0c 	mcall	80004450 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80004426:	c1 00       	breq	80004446 <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004428:	fa c7 ff fc 	sub	r7,sp,-4
8000442c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
8000442e:	e0 6a 00 ca 	mov	r10,202
80004432:	08 9b       	mov	r11,r4
80004434:	f0 1f 00 08 	mcall	80004454 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80004438:	48 88       	lddpc	r8,80004458 <xcmp_rx+0x44>
8000443a:	70 0c       	ld.w	r12,r8[0x0]
8000443c:	30 09       	mov	r9,0
8000443e:	12 9a       	mov	r10,r9
80004440:	1a 9b       	mov	r11,sp
80004442:	f0 1f 00 07 	mcall	8000445c <xcmp_rx+0x48>
	}	
}
80004446:	2f fd       	sub	sp,-4
80004448:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
8000444c:	00 00       	add	r0,r0
8000444e:	0a b8       	st.h	r5++,r8
80004450:	80 00       	ld.sh	r0,r0[0x0]
80004452:	2f 74       	sub	r4,-9
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	6d f0       	ld.w	r0,r6[0x7c]
80004458:	00 00       	add	r0,r0
8000445a:	0a f8       	st.b	--r5,r8
8000445c:	80 00       	ld.sh	r0,r0[0x0]
8000445e:	58 a0       	cp.w	r0,10

80004460 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004460:	48 28       	lddpc	r8,80004468 <xnl_register_xcmp_func+0x8>
80004462:	91 0c       	st.w	r8[0x0],r12
}
80004464:	5e fc       	retal	r12
80004466:	00 00       	add	r0,r0
80004468:	00 00       	add	r0,r0
8000446a:	0b 5c       	ld.sh	r12,--r5

8000446c <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
8000446c:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
8000446e:	48 88       	lddpc	r8,8000448c <xnl_get_msg_ack_func+0x20>
80004470:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004472:	98 49       	ld.sh	r9,r12[0x8]
80004474:	f0 09 19 00 	cp.h	r9,r8
80004478:	c0 81       	brne	80004488 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000447a:	48 68       	lddpc	r8,80004490 <xnl_get_msg_ack_func+0x24>
8000447c:	70 0c       	ld.w	r12,r8[0x0]
8000447e:	30 09       	mov	r9,0
80004480:	12 9a       	mov	r10,r9
80004482:	12 9b       	mov	r11,r9
80004484:	f0 1f 00 04 	mcall	80004494 <xnl_get_msg_ack_func+0x28>
80004488:	d8 02       	popm	pc
8000448a:	00 00       	add	r0,r0
8000448c:	00 00       	add	r0,r0
8000448e:	0b 3c       	ld.ub	r12,r5++
80004490:	00 00       	add	r0,r0
80004492:	0b 38       	ld.ub	r8,r5++
80004494:	80 00       	ld.sh	r0,r0[0x0]
80004496:	58 a0       	cp.w	r0,10

80004498 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80004498:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
8000449a:	4a 86       	lddpc	r6,80004538 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000449c:	4a 82       	lddpc	r2,8000453c <xnl_tx_process+0xa4>
8000449e:	4a 94       	lddpc	r4,80004540 <xnl_tx_process+0xa8>
800044a0:	30 07       	mov	r7,0
800044a2:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800044a4:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800044a6:	4a 85       	lddpc	r5,80004544 <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800044a8:	4a 83       	lddpc	r3,80004548 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
800044aa:	6c 08       	ld.w	r8,r6[0x0]
800044ac:	58 08       	cp.w	r8,0
800044ae:	c0 40       	breq	800044b6 <xnl_tx_process+0x1e>
800044b0:	58 18       	cp.w	r8,1
800044b2:	cf d1       	brne	800044ac <xnl_tx_process+0x14>
800044b4:	c2 08       	rjmp	800044f4 <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
800044b6:	64 0c       	ld.w	r12,r2[0x0]
800044b8:	0e 99       	mov	r9,r7
800044ba:	02 9a       	mov	r10,r1
800044bc:	08 9b       	mov	r11,r4
800044be:	f0 1f 00 24 	mcall	8000454c <xnl_tx_process+0xb4>
800044c2:	58 1c       	cp.w	r12,1
800044c4:	cf 31       	brne	800044aa <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800044c6:	68 0c       	ld.w	r12,r4[0x0]
800044c8:	58 0c       	cp.w	r12,0
800044ca:	cf 00       	breq	800044aa <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800044cc:	98 28       	ld.sh	r8,r12[0x4]
800044ce:	e0 08 19 00 	cp.h	r8,r0
800044d2:	c0 41       	brne	800044da <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
800044d4:	f0 1f 00 1f 	mcall	80004550 <xnl_tx_process+0xb8>
						break;
800044d8:	ce 9b       	rjmp	800044aa <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800044da:	f0 1f 00 1f 	mcall	80004554 <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
800044de:	30 18       	mov	r8,1
800044e0:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800044e2:	66 0c       	ld.w	r12,r3[0x0]
800044e4:	0e 99       	mov	r9,r7
800044e6:	0e 9a       	mov	r10,r7
800044e8:	0e 9b       	mov	r11,r7
800044ea:	f0 1f 00 19 	mcall	8000454c <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
800044ee:	30 18       	mov	r8,1
800044f0:	8d 08       	st.w	r6[0x0],r8
800044f2:	cd cb       	rjmp	800044aa <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800044f4:	66 0c       	ld.w	r12,r3[0x0]
800044f6:	0e 99       	mov	r9,r7
800044f8:	36 4a       	mov	r10,100
800044fa:	0e 9b       	mov	r11,r7
800044fc:	f0 1f 00 14 	mcall	8000454c <xnl_tx_process+0xb4>
80004500:	58 1c       	cp.w	r12,1
80004502:	c0 81       	brne	80004512 <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80004504:	49 58       	lddpc	r8,80004558 <xnl_tx_process+0xc0>
80004506:	70 0c       	ld.w	r12,r8[0x0]
80004508:	68 0b       	ld.w	r11,r4[0x0]
8000450a:	f0 1f 00 15 	mcall	8000455c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
8000450e:	8d 07       	st.w	r6[0x0],r7
80004510:	cc db       	rjmp	800044aa <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80004512:	6a 08       	ld.w	r8,r5[0x0]
80004514:	58 38       	cp.w	r8,3
80004516:	e0 89 00 09 	brgt	80004528 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
8000451a:	68 0c       	ld.w	r12,r4[0x0]
8000451c:	f0 1f 00 0e 	mcall	80004554 <xnl_tx_process+0xbc>
						xnl_send_times++;
80004520:	6a 08       	ld.w	r8,r5[0x0]
80004522:	2f f8       	sub	r8,-1
80004524:	8b 08       	st.w	r5[0x0],r8
80004526:	cc 2b       	rjmp	800044aa <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004528:	48 c8       	lddpc	r8,80004558 <xnl_tx_process+0xc0>
8000452a:	70 0c       	ld.w	r12,r8[0x0]
8000452c:	68 0b       	ld.w	r11,r4[0x0]
8000452e:	f0 1f 00 0c 	mcall	8000455c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80004532:	8d 07       	st.w	r6[0x0],r7
80004534:	cb bb       	rjmp	800044aa <xnl_tx_process+0x12>
80004536:	00 00       	add	r0,r0
80004538:	00 00       	add	r0,r0
8000453a:	0b 58       	ld.sh	r8,--r5
8000453c:	00 00       	add	r0,r0
8000453e:	0b 4c       	ld.w	r12,--r5
80004540:	00 00       	add	r0,r0
80004542:	0b 50       	ld.sh	r0,--r5
80004544:	00 00       	add	r0,r0
80004546:	0b 48       	ld.w	r8,--r5
80004548:	00 00       	add	r0,r0
8000454a:	0b 38       	ld.ub	r8,r5++
8000454c:	80 00       	ld.sh	r0,r0[0x0]
8000454e:	56 94       	stdsp	sp[0x1a4],r4
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	55 24       	stdsp	sp[0x148],r4
80004554:	80 00       	ld.sh	r0,r0[0x0]
80004556:	2a 24       	sub	r4,-94
80004558:	00 00       	add	r0,r0
8000455a:	0a b8       	st.h	r5++,r8
8000455c:	80 00       	ld.sh	r0,r0[0x0]
8000455e:	2a 04       	sub	r4,-96

80004560 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80004560:	eb cd 40 fe 	pushm	r1-r7,lr
80004564:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004566:	49 26       	lddpc	r6,800045ac <xnl_rx_process+0x4c>
80004568:	30 05       	mov	r5,0
8000456a:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
8000456c:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000456e:	49 11       	lddpc	r1,800045b0 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004570:	49 12       	lddpc	r2,800045b4 <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80004572:	6c 0c       	ld.w	r12,r6[0x0]
80004574:	0a 99       	mov	r9,r5
80004576:	08 9a       	mov	r10,r4
80004578:	1a 9b       	mov	r11,sp
8000457a:	f0 1f 00 10 	mcall	800045b8 <xnl_rx_process+0x58>
8000457e:	58 1c       	cp.w	r12,1
80004580:	cf 91       	brne	80004572 <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80004582:	40 0c       	lddsp	r12,sp[0x0]
80004584:	58 0c       	cp.w	r12,0
80004586:	cf 60       	breq	80004572 <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004588:	98 28       	ld.sh	r8,r12[0x4]
8000458a:	e6 08 19 00 	cp.h	r8,r3
8000458e:	e0 8b 00 0a 	brhi	800045a2 <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004592:	5c 78       	castu.h	r8
80004594:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004598:	58 09       	cp.w	r9,0
8000459a:	c0 40       	breq	800045a2 <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
8000459c:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
800045a0:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800045a2:	62 0c       	ld.w	r12,r1[0x0]
800045a4:	40 0b       	lddsp	r11,sp[0x0]
800045a6:	f0 1f 00 06 	mcall	800045bc <xnl_rx_process+0x5c>
800045aa:	ce 4b       	rjmp	80004572 <xnl_rx_process+0x12>
800045ac:	00 00       	add	r0,r0
800045ae:	0a bc       	st.h	r5++,r12
800045b0:	00 00       	add	r0,r0
800045b2:	0a b8       	st.h	r5++,r8
800045b4:	00 00       	add	r0,r0
800045b6:	04 fc       	st.b	--r2,r12
800045b8:	80 00       	ld.sh	r0,r0[0x0]
800045ba:	56 94       	stdsp	sp[0x1a4],r4
800045bc:	80 00       	ld.sh	r0,r0[0x0]
800045be:	2a 04       	sub	r4,-96

800045c0 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
800045c0:	eb cd 40 c0 	pushm	r6-r7,lr
800045c4:	20 1d       	sub	sp,4
800045c6:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
800045c8:	98 39       	ld.sh	r9,r12[0x6]
800045ca:	3f f8       	mov	r8,-1
800045cc:	f0 09 19 00 	cp.h	r9,r8
800045d0:	c0 a1       	brne	800045e4 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
800045d2:	4a e9       	lddpc	r9,80004688 <xnl_tx+0xc8>
800045d4:	13 88       	ld.ub	r8,r9[0x0]
800045d6:	2f f8       	sub	r8,-1
800045d8:	5c 58       	castu.b	r8
800045da:	b2 88       	st.b	r9[0x0],r8
800045dc:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800045e0:	a9 a8       	sbr	r8,0x8
800045e2:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800045e4:	8c 49       	ld.sh	r9,r6[0x8]
800045e6:	3f f8       	mov	r8,-1
800045e8:	f0 09 19 00 	cp.h	r9,r8
800045ec:	c0 41       	brne	800045f4 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800045ee:	4a 88       	lddpc	r8,8000468c <xnl_tx+0xcc>
800045f0:	90 18       	ld.sh	r8,r8[0x2]
800045f2:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800045f4:	8c 59       	ld.sh	r9,r6[0xa]
800045f6:	3f f8       	mov	r8,-1
800045f8:	f0 09 19 00 	cp.h	r9,r8
800045fc:	c0 41       	brne	80004604 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800045fe:	4a 48       	lddpc	r8,8000468c <xnl_tx+0xcc>
80004600:	90 28       	ld.sh	r8,r8[0x4]
80004602:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004604:	8c 69       	ld.sh	r9,r6[0xc]
80004606:	3f f8       	mov	r8,-1
80004608:	f0 09 19 00 	cp.h	r9,r8
8000460c:	c0 e1       	brne	80004628 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
8000460e:	4a 08       	lddpc	r8,8000468c <xnl_tx+0xcc>
80004610:	90 49       	ld.sh	r9,r8[0x8]
80004612:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004614:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80004616:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004618:	90 49       	ld.sh	r9,r8[0x8]
8000461a:	e0 19 ff 00 	andl	r9,0xff00
8000461e:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004622:	f3 e8 10 08 	or	r8,r9,r8
80004626:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80004628:	0d 98       	ld.ub	r8,r6[0x1]
8000462a:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
8000462c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004630:	10 0c       	add	r12,r8
80004632:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004634:	58 0c       	cp.w	r12,0
80004636:	e0 89 00 04 	brgt	8000463e <xnl_tx+0x7e>
8000463a:	30 09       	mov	r9,0
8000463c:	c0 d8       	rjmp	80004656 <xnl_tx+0x96>
8000463e:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004642:	2f ec       	sub	r12,-2
80004644:	30 09       	mov	r9,0
80004646:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80004648:	15 1b       	ld.sh	r11,r10++
8000464a:	f6 09 00 09 	add	r9,r11,r9
8000464e:	5c 89       	casts.h	r9
		indextohWord     += 1;
80004650:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004652:	18 38       	cp.w	r8,r12
80004654:	cf a1       	brne	80004648 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80004656:	5c 39       	neg	r9
80004658:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000465a:	48 e8       	lddpc	r8,80004690 <xnl_tx+0xd0>
8000465c:	70 0c       	ld.w	r12,r8[0x0]
8000465e:	f0 1f 00 0e 	mcall	80004694 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80004662:	c1 00       	breq	80004682 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80004664:	fa c7 ff fc 	sub	r7,sp,-4
80004668:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000466a:	e0 6a 01 00 	mov	r10,256
8000466e:	0c 9b       	mov	r11,r6
80004670:	f0 1f 00 0a 	mcall	80004698 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80004674:	48 a8       	lddpc	r8,8000469c <xnl_tx+0xdc>
80004676:	70 0c       	ld.w	r12,r8[0x0]
80004678:	30 09       	mov	r9,0
8000467a:	12 9a       	mov	r10,r9
8000467c:	1a 9b       	mov	r11,sp
8000467e:	f0 1f 00 09 	mcall	800046a0 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004682:	2f fd       	sub	sp,-4
80004684:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004688:	00 00       	add	r0,r0
8000468a:	0b 54       	ld.sh	r4,--r5
8000468c:	00 00       	add	r0,r0
8000468e:	0b 3c       	ld.ub	r12,r5++
80004690:	00 00       	add	r0,r0
80004692:	0a b8       	st.h	r5++,r8
80004694:	80 00       	ld.sh	r0,r0[0x0]
80004696:	2f 74       	sub	r4,-9
80004698:	80 00       	ld.sh	r0,r0[0x0]
8000469a:	6d f0       	ld.w	r0,r6[0x7c]
8000469c:	00 00       	add	r0,r0
8000469e:	0b 4c       	ld.w	r12,--r5
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	58 a0       	cp.w	r0,10

800046a4 <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800046a4:	eb cd 40 80 	pushm	r7,lr
800046a8:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
800046ac:	f0 1f 00 27 	mcall	80004748 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
800046b0:	30 09       	mov	r9,0
800046b2:	4a 78       	lddpc	r8,8000474c <xnl_init+0xa8>
800046b4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800046b6:	30 0b       	mov	r11,0
800046b8:	30 1c       	mov	r12,1
800046ba:	f0 1f 00 26 	mcall	80004750 <xnl_init+0xac>
800046be:	4a 68       	lddpc	r8,80004754 <xnl_init+0xb0>
800046c0:	91 0c       	st.w	r8[0x0],r12
800046c2:	70 08       	ld.w	r8,r8[0x0]
800046c4:	58 08       	cp.w	r8,0
800046c6:	c0 80       	breq	800046d6 <xnl_init+0x32>
800046c8:	4a 38       	lddpc	r8,80004754 <xnl_init+0xb0>
800046ca:	70 0c       	ld.w	r12,r8[0x0]
800046cc:	30 09       	mov	r9,0
800046ce:	12 9a       	mov	r10,r9
800046d0:	12 9b       	mov	r11,r9
800046d2:	f0 1f 00 22 	mcall	80004758 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800046d6:	30 4b       	mov	r11,4
800046d8:	31 4c       	mov	r12,20
800046da:	f0 1f 00 1e 	mcall	80004750 <xnl_init+0xac>
800046de:	4a 08       	lddpc	r8,8000475c <xnl_init+0xb8>
800046e0:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800046e2:	30 07       	mov	r7,0
800046e4:	1a d7       	st.w	--sp,r7
800046e6:	1a d7       	st.w	--sp,r7
800046e8:	1a d7       	st.w	--sp,r7
800046ea:	30 38       	mov	r8,3
800046ec:	0e 99       	mov	r9,r7
800046ee:	e0 6a 02 00 	mov	r10,512
800046f2:	49 cb       	lddpc	r11,80004760 <xnl_init+0xbc>
800046f4:	49 cc       	lddpc	r12,80004764 <xnl_init+0xc0>
800046f6:	f0 1f 00 1d 	mcall	80004768 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800046fa:	1a d7       	st.w	--sp,r7
800046fc:	1a d7       	st.w	--sp,r7
800046fe:	1a d7       	st.w	--sp,r7
80004700:	30 38       	mov	r8,3
80004702:	0e 99       	mov	r9,r7
80004704:	e0 6a 03 20 	mov	r10,800
80004708:	49 9b       	lddpc	r11,8000476c <xnl_init+0xc8>
8000470a:	49 ac       	lddpc	r12,80004770 <xnl_init+0xcc>
8000470c:	f0 1f 00 17 	mcall	80004768 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004710:	e0 68 40 0e 	mov	r8,16398
80004714:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004718:	3f f8       	mov	r8,-1
8000471a:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
8000471e:	30 38       	mov	r8,3
80004720:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004724:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004728:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000472c:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004730:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004734:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004738:	fa cc ff e8 	sub	r12,sp,-24
8000473c:	f0 1f 00 0e 	mcall	80004774 <xnl_init+0xd0>
80004740:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80004742:	2c 0d       	sub	sp,-256
80004744:	e3 cd 80 80 	ldm	sp++,r7,pc
80004748:	80 00       	ld.sh	r0,r0[0x0]
8000474a:	2f 9c       	sub	r12,-7
8000474c:	00 00       	add	r0,r0
8000474e:	0b 3c       	ld.ub	r12,r5++
80004750:	80 00       	ld.sh	r0,r0[0x0]
80004752:	59 f8       	cp.w	r8,31
80004754:	00 00       	add	r0,r0
80004756:	0b 38       	ld.ub	r8,r5++
80004758:	80 00       	ld.sh	r0,r0[0x0]
8000475a:	58 a0       	cp.w	r0,10
8000475c:	00 00       	add	r0,r0
8000475e:	0b 4c       	ld.w	r12,--r5
80004760:	80 00       	ld.sh	r0,r0[0x0]
80004762:	d3 f8       	*unknown*
80004764:	80 00       	ld.sh	r0,r0[0x0]
80004766:	45 60       	lddsp	r0,sp[0x158]
80004768:	80 00       	ld.sh	r0,r0[0x0]
8000476a:	60 cc       	ld.w	r12,r0[0x30]
8000476c:	80 00       	ld.sh	r0,r0[0x0]
8000476e:	c6 00       	breq	8000482e <xnl_device_auth_reply_func+0x56>
80004770:	80 00       	ld.sh	r0,r0[0x0]
80004772:	44 98       	lddsp	r8,sp[0x124]
80004774:	80 00       	ld.sh	r0,r0[0x0]
80004776:	45 c0       	lddsp	r0,sp[0x170]

80004778 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004778:	eb cd 40 80 	pushm	r7,lr
8000477c:	fa cd 01 00 	sub	sp,sp,256
80004780:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004782:	e0 68 40 0e 	mov	r8,16398
80004786:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004788:	3f f8       	mov	r8,-1
8000478a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000478c:	30 c8       	mov	r8,12
8000478e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004790:	98 38       	ld.sh	r8,r12[0x6]
80004792:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004794:	98 58       	ld.sh	r8,r12[0xa]
80004796:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004798:	98 48       	ld.sh	r8,r12[0x8]
8000479a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000479c:	98 68       	ld.sh	r8,r12[0xc]
8000479e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
800047a0:	30 08       	mov	r8,0
800047a2:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
800047a4:	1a 9c       	mov	r12,sp
800047a6:	f0 1f 00 0a 	mcall	800047cc <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
800047aa:	fa cd 00 cc 	sub	sp,sp,204
800047ae:	e0 6a 00 ca 	mov	r10,202
800047b2:	ee cb ff f0 	sub	r11,r7,-16
800047b6:	1a 9c       	mov	r12,sp
800047b8:	f0 1f 00 06 	mcall	800047d0 <xnl_data_msg_func+0x58>
800047bc:	48 68       	lddpc	r8,800047d4 <xnl_data_msg_func+0x5c>
800047be:	70 08       	ld.w	r8,r8[0x0]
800047c0:	5d 18       	icall	r8
800047c2:	fa cd ff 34 	sub	sp,sp,-204
}
800047c6:	2c 0d       	sub	sp,-256
800047c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800047cc:	80 00       	ld.sh	r0,r0[0x0]
800047ce:	45 c0       	lddsp	r0,sp[0x170]
800047d0:	80 00       	ld.sh	r0,r0[0x0]
800047d2:	6d f0       	ld.w	r0,r6[0x7c]
800047d4:	00 00       	add	r0,r0
800047d6:	0b 5c       	ld.sh	r12,--r5

800047d8 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
800047d8:	d4 21       	pushm	r4-r7,lr
800047da:	fa cd 01 00 	sub	sp,sp,256
800047de:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
800047e0:	4c 28       	lddpc	r8,800048e8 <xnl_device_auth_reply_func+0x110>
800047e2:	11 88       	ld.ub	r8,r8[0x0]
800047e4:	58 08       	cp.w	r8,0
800047e6:	e0 81 00 7f 	brne	800048e4 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
800047ea:	4c 18       	lddpc	r8,800048ec <xnl_device_auth_reply_func+0x114>
800047ec:	70 0c       	ld.w	r12,r8[0x0]
800047ee:	30 09       	mov	r9,0
800047f0:	12 9a       	mov	r10,r9
800047f2:	12 9b       	mov	r11,r9
800047f4:	f0 1f 00 3f 	mcall	800048f0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800047f8:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800047fc:	4b b8       	lddpc	r8,800048e8 <xnl_device_auth_reply_func+0x110>
800047fe:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004800:	ef 39 00 12 	ld.ub	r9,r7[18]
80004804:	ef 38 00 13 	ld.ub	r8,r7[19]
80004808:	b1 68       	lsl	r8,0x10
8000480a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000480e:	ef 38 00 15 	ld.ub	r8,r7[21]
80004812:	f3 e8 10 08 	or	r8,r9,r8
80004816:	ef 39 00 14 	ld.ub	r9,r7[20]
8000481a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000481e:	ef 3a 00 16 	ld.ub	r10,r7[22]
80004822:	ef 38 00 17 	ld.ub	r8,r7[23]
80004826:	b1 68       	lsl	r8,0x10
80004828:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
8000482c:	ef 38 00 19 	ld.ub	r8,r7[25]
80004830:	f5 e8 10 08 	or	r8,r10,r8
80004834:	ef 3a 00 18 	ld.ub	r10,r7[24]
80004838:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000483c:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
8000483e:	e0 64 79 b9 	mov	r4,31161
80004842:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004846:	e0 65 45 07 	mov	r5,17671
8000484a:	ea 15 8a bd 	orh	r5,0x8abd
8000484e:	e0 66 f9 3d 	mov	r6,63805
80004852:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004856:	e0 6e b8 cf 	mov	lr,47311
8000485a:	ea 1e 36 83 	orh	lr,0x3683
8000485e:	e0 67 aa 1c 	mov	r7,43548
80004862:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004866:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004868:	f4 08 00 0c 	add	r12,r10,r8
8000486c:	f0 0b 15 04 	lsl	r11,r8,0x4
80004870:	0a 0b       	add	r11,r5
80004872:	f9 eb 20 0b 	eor	r11,r12,r11
80004876:	f0 0c 16 05 	lsr	r12,r8,0x5
8000487a:	0c 0c       	add	r12,r6
8000487c:	18 5b       	eor	r11,r12
8000487e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004880:	f2 0c 15 04 	lsl	r12,r9,0x4
80004884:	1c 0c       	add	r12,lr
80004886:	f2 0b 16 05 	lsr	r11,r9,0x5
8000488a:	0e 0b       	add	r11,r7
8000488c:	f9 eb 20 0b 	eor	r11,r12,r11
80004890:	f2 0a 00 0c 	add	r12,r9,r10
80004894:	18 5b       	eor	r11,r12
80004896:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004898:	e0 6b 37 20 	mov	r11,14112
8000489c:	ea 1b c6 ef 	orh	r11,0xc6ef
800048a0:	16 3a       	cp.w	r10,r11
800048a2:	ce 21       	brne	80004866 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
800048a4:	e0 6a 40 1a 	mov	r10,16410
800048a8:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800048aa:	3f fa       	mov	r10,-1
800048ac:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
800048ae:	30 6b       	mov	r11,6
800048b0:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800048b2:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800048b4:	48 db       	lddpc	r11,800048e8 <xnl_device_auth_reply_func+0x110>
800048b6:	96 1c       	ld.sh	r12,r11[0x2]
800048b8:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
800048ba:	96 2b       	ld.sh	r11,r11[0x4]
800048bc:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800048be:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
800048c0:	30 ca       	mov	r10,12
800048c2:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
800048c4:	30 0a       	mov	r10,0
800048c6:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
800048ca:	30 7a       	mov	r10,7
800048cc:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
800048d0:	30 2a       	mov	r10,2
800048d2:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800048d6:	fa ca ff ec 	sub	r10,sp,-20
800048da:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
800048dc:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
800048de:	1a 9c       	mov	r12,sp
800048e0:	f0 1f 00 05 	mcall	800048f4 <xnl_device_auth_reply_func+0x11c>
}
800048e4:	2c 0d       	sub	sp,-256
800048e6:	d8 22       	popm	r4-r7,pc
800048e8:	00 00       	add	r0,r0
800048ea:	0b 3c       	ld.ub	r12,r5++
800048ec:	00 00       	add	r0,r0
800048ee:	0b 38       	ld.ub	r8,r5++
800048f0:	80 00       	ld.sh	r0,r0[0x0]
800048f2:	58 a0       	cp.w	r0,10
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	45 c0       	lddsp	r0,sp[0x170]

800048f8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800048f8:	eb cd 40 80 	pushm	r7,lr
800048fc:	fa cd 01 00 	sub	sp,sp,256
80004900:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004902:	49 28       	lddpc	r8,80004948 <xnl_master_status_brdcst_func+0x50>
80004904:	11 88       	ld.ub	r8,r8[0x0]
80004906:	58 08       	cp.w	r8,0
80004908:	c1 c1       	brne	80004940 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000490a:	49 18       	lddpc	r8,8000494c <xnl_master_status_brdcst_func+0x54>
8000490c:	70 0c       	ld.w	r12,r8[0x0]
8000490e:	30 09       	mov	r9,0
80004910:	12 9a       	mov	r10,r9
80004912:	12 9b       	mov	r11,r9
80004914:	f0 1f 00 0f 	mcall	80004950 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004918:	8e 58       	ld.sh	r8,r7[0xa]
8000491a:	48 c9       	lddpc	r9,80004948 <xnl_master_status_brdcst_func+0x50>
8000491c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000491e:	e0 68 40 0e 	mov	r8,16398
80004922:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004924:	3f f8       	mov	r8,-1
80004926:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004928:	30 4a       	mov	r10,4
8000492a:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
8000492c:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
8000492e:	92 19       	ld.sh	r9,r9[0x2]
80004930:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004932:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004934:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004936:	30 08       	mov	r8,0
80004938:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
8000493a:	1a 9c       	mov	r12,sp
8000493c:	f0 1f 00 06 	mcall	80004954 <xnl_master_status_brdcst_func+0x5c>
}
80004940:	2c 0d       	sub	sp,-256
80004942:	e3 cd 80 80 	ldm	sp++,r7,pc
80004946:	00 00       	add	r0,r0
80004948:	00 00       	add	r0,r0
8000494a:	0b 3c       	ld.ub	r12,r5++
8000494c:	00 00       	add	r0,r0
8000494e:	0b 38       	ld.ub	r8,r5++
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	58 a0       	cp.w	r0,10
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	45 c0       	lddsp	r0,sp[0x170]

80004958 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004958:	eb cd 40 80 	pushm	r7,lr
8000495c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000495e:	49 38       	lddpc	r8,800049a8 <xnl_device_conn_reply_func+0x50>
80004960:	70 0c       	ld.w	r12,r8[0x0]
80004962:	30 09       	mov	r9,0
80004964:	12 9a       	mov	r10,r9
80004966:	12 9b       	mov	r11,r9
80004968:	f0 1f 00 11 	mcall	800049ac <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000496c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004970:	10 99       	mov	r9,r8
80004972:	e2 19 ff 00 	andl	r9,0xff00,COH
80004976:	e0 49 01 00 	cp.w	r9,256
8000497a:	c0 60       	breq	80004986 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000497c:	0e 9c       	mov	r12,r7
8000497e:	f0 1f 00 0d 	mcall	800049b0 <xnl_device_conn_reply_func+0x58>
80004982:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004986:	a9 68       	lsl	r8,0x8
80004988:	48 b9       	lddpc	r9,800049b4 <xnl_device_conn_reply_func+0x5c>
8000498a:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
8000498c:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004990:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004992:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004996:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004998:	30 18       	mov	r8,1
8000499a:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
8000499c:	48 7c       	lddpc	r12,800049b8 <xnl_device_conn_reply_func+0x60>
8000499e:	f0 1f 00 08 	mcall	800049bc <xnl_device_conn_reply_func+0x64>
800049a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800049a6:	00 00       	add	r0,r0
800049a8:	00 00       	add	r0,r0
800049aa:	0b 38       	ld.ub	r8,r5++
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	58 a0       	cp.w	r0,10
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	48 f8       	lddpc	r8,800049ec <local_start_pll0+0x2c>
800049b4:	00 00       	add	r0,r0
800049b6:	0b 3c       	ld.ub	r12,r5++
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	d4 00       	acall	0x40
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	64 90       	ld.w	r0,r2[0x24]

800049c0 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
800049c0:	fe 78 0c 00 	mov	r8,-62464
800049c4:	e0 69 03 07 	mov	r9,775
800049c8:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
800049ca:	30 49       	mov	r9,4
800049cc:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800049ce:	71 59       	ld.w	r9,r8[0x54]
800049d0:	e2 19 00 80 	andl	r9,0x80,COH
800049d4:	cf d0       	breq	800049ce <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
800049d6:	fe 78 0c 00 	mov	r8,-62464
800049da:	30 59       	mov	r9,5
800049dc:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
800049de:	e0 69 01 0d 	mov	r9,269
800049e2:	ea 19 10 07 	orh	r9,0x1007
800049e6:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800049e8:	71 59       	ld.w	r9,r8[0x54]
800049ea:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800049ee:	cf d0       	breq	800049e8 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800049f0:	fe 78 0c 00 	mov	r8,-62464
800049f4:	fc 19 00 80 	movh	r9,0x80
800049f8:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800049fa:	34 0a       	mov	r10,64
800049fc:	fe 69 14 00 	mov	r9,-125952
80004a00:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
80004a02:	30 69       	mov	r9,6
80004a04:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
80004a06:	30 19       	mov	r9,1
80004a08:	fe 68 10 00 	mov	r8,-126976
80004a0c:	91 19       	st.w	r8[0x4],r9
}
80004a0e:	5e fc       	retal	r12

80004a10 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
80004a10:	eb cd 40 c0 	pushm	r6-r7,lr
80004a14:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
80004a16:	f0 1f 00 1a 	mcall	80004a7c <rtc_init+0x6c>
80004a1a:	49 a8       	lddpc	r8,80004a80 <rtc_init+0x70>
80004a1c:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
80004a1e:	70 08       	ld.w	r8,r8[0x0]
80004a20:	58 08       	cp.w	r8,0
80004a22:	c0 31       	brne	80004a28 <rtc_init+0x18>
80004a24:	30 3c       	mov	r12,3
80004a26:	c2 78       	rjmp	80004a74 <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
80004a28:	49 66       	lddpc	r6,80004a80 <rtc_init+0x70>
80004a2a:	6c 0c       	ld.w	r12,r6[0x0]
80004a2c:	30 09       	mov	r9,0
80004a2e:	3f fa       	mov	r10,-1
80004a30:	12 9b       	mov	r11,r9
80004a32:	f0 1f 00 15 	mcall	80004a84 <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80004a36:	30 2b       	mov	r11,2
80004a38:	49 4c       	lddpc	r12,80004a88 <rtc_init+0x78>
80004a3a:	f0 1f 00 15 	mcall	80004a8c <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
80004a3e:	e0 68 36 00 	mov	r8,13824
80004a42:	ea 18 01 6e 	orh	r8,0x16e
80004a46:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80004a48:	e2 78 0d 40 	mov	r8,200000
80004a4c:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80004a4e:	35 18       	mov	r8,81
80004a50:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
80004a54:	1a 9b       	mov	r11,sp
80004a56:	fe 7c 2c 00 	mov	r12,-54272
80004a5a:	f0 1f 00 0e 	mcall	80004a90 <rtc_init+0x80>
80004a5e:	48 e7       	lddpc	r7,80004a94 <rtc_init+0x84>
80004a60:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
80004a62:	6c 0c       	ld.w	r12,r6[0x0]
80004a64:	30 09       	mov	r9,0
80004a66:	12 9a       	mov	r10,r9
80004a68:	12 9b       	mov	r11,r9
80004a6a:	f0 1f 00 0c 	mcall	80004a98 <rtc_init+0x88>
80004a6e:	6e 08       	ld.w	r8,r7[0x0]
80004a70:	58 08       	cp.w	r8,0
80004a72:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
80004a74:	2f dd       	sub	sp,-12
80004a76:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004a7a:	00 00       	add	r0,r0
80004a7c:	80 00       	ld.sh	r0,r0[0x0]
80004a7e:	59 a0       	cp.w	r0,26
80004a80:	00 00       	add	r0,r0
80004a82:	0b 64       	ld.uh	r4,--r5
80004a84:	80 00       	ld.sh	r0,r0[0x0]
80004a86:	56 94       	stdsp	sp[0x1a4],r4
80004a88:	80 00       	ld.sh	r0,r0[0x0]
80004a8a:	d4 14       	*unknown*
80004a8c:	80 00       	ld.sh	r0,r0[0x0]
80004a8e:	69 28       	ld.w	r8,r4[0x48]
80004a90:	80 00       	ld.sh	r0,r0[0x0]
80004a92:	4f 20       	lddpc	r0,80004c58 <_get_interrupt_handler+0x28>
80004a94:	00 00       	add	r0,r0
80004a96:	0b 60       	ld.uh	r0,--r5
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	58 a0       	cp.w	r0,10

80004a9c <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004a9c:	fe 78 10 00 	mov	r8,-61440
80004aa0:	fc 19 00 10 	movh	r9,0x10
80004aa4:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
80004aa6:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004aa8:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004aaa:	30 39       	mov	r9,3
80004aac:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004ab0:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
80004ab4:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004ab8:	fe 78 38 00 	mov	r8,-51200
80004abc:	30 49       	mov	r9,4
80004abe:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
80004ac2:	e0 69 91 0d 	mov	r9,37133
80004ac6:	ea 19 00 52 	orh	r9,0x52
80004aca:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004acc:	32 09       	mov	r9,32
80004ace:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004ad0:	30 59       	mov	r9,5
80004ad2:	91 09       	st.w	r8[0x0],r9
}
80004ad4:	5e fc       	retal	r12
80004ad6:	d7 03       	nop

80004ad8 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004ad8:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004ada:	30 2a       	mov	r10,2
80004adc:	e0 6b 01 c1 	mov	r11,449
80004ae0:	48 ec       	lddpc	r12,80004b18 <tc_init+0x40>
80004ae2:	f0 1f 00 0f 	mcall	80004b1c <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
80004ae6:	48 fb       	lddpc	r11,80004b20 <tc_init+0x48>
80004ae8:	fe 7c 38 00 	mov	r12,-51200
80004aec:	f0 1f 00 0e 	mcall	80004b24 <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
80004af0:	e0 6a 75 30 	mov	r10,30000
80004af4:	30 1b       	mov	r11,1
80004af6:	fe 7c 38 00 	mov	r12,-51200
80004afa:	f0 1f 00 0c 	mcall	80004b28 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
80004afe:	48 ca       	lddpc	r10,80004b2c <tc_init+0x54>
80004b00:	30 1b       	mov	r11,1
80004b02:	fe 7c 38 00 	mov	r12,-51200
80004b06:	f0 1f 00 0b 	mcall	80004b30 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
80004b0a:	30 1b       	mov	r11,1
80004b0c:	fe 7c 38 00 	mov	r12,-51200
80004b10:	f0 1f 00 09 	mcall	80004b34 <tc_init+0x5c>
80004b14:	d8 02       	popm	pc
80004b16:	00 00       	add	r0,r0
80004b18:	80 00       	ld.sh	r0,r0[0x0]
80004b1a:	4b 38       	lddpc	r8,80004be4 <INTC_init_interrupts+0x8>
80004b1c:	80 00       	ld.sh	r0,r0[0x0]
80004b1e:	4b 5c       	lddpc	r12,80004bf0 <INTC_init_interrupts+0x14>
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	d4 28       	*unknown*
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	4c 68       	lddpc	r8,80004c3c <_get_interrupt_handler+0xc>
80004b28:	80 00       	ld.sh	r0,r0[0x0]
80004b2a:	4d 28       	lddpc	r8,80004c70 <tc_init_waveform+0x8>
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	d4 24       	*unknown*
80004b30:	80 00       	ld.sh	r0,r0[0x0]
80004b32:	4d 5c       	lddpc	r12,80004c84 <tc_init_waveform+0x1c>
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	4d 04       	lddpc	r4,80004c74 <tc_init_waveform+0xc>

80004b38 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
80004b38:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
80004b3a:	48 68       	lddpc	r8,80004b50 <_tc_interrupt+0x18>
80004b3c:	70 09       	ld.w	r9,r8[0x0]
80004b3e:	2f f9       	sub	r9,-1
80004b40:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
80004b42:	30 1b       	mov	r11,1
80004b44:	fe 7c 38 00 	mov	r12,-51200
80004b48:	f0 1f 00 03 	mcall	80004b54 <_tc_interrupt+0x1c>
	
}
80004b4c:	d4 02       	popm	lr
80004b4e:	d6 03       	rete
80004b50:	00 00       	add	r0,r0
80004b52:	0b 68       	ld.uh	r8,--r5
80004b54:	80 00       	ld.sh	r0,r0[0x0]
80004b56:	4d 16       	lddpc	r6,80004c98 <tc_init_waveform+0x30>

80004b58 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004b58:	c0 08       	rjmp	80004b58 <_unhandled_interrupt>
80004b5a:	d7 03       	nop

80004b5c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004b5c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004b60:	49 99       	lddpc	r9,80004bc4 <INTC_register_interrupt+0x68>
80004b62:	f2 08 00 39 	add	r9,r9,r8<<0x3
80004b66:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004b6a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004b6c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004b70:	58 0a       	cp.w	r10,0
80004b72:	c0 91       	brne	80004b84 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004b74:	49 59       	lddpc	r9,80004bc8 <INTC_register_interrupt+0x6c>
80004b76:	49 6a       	lddpc	r10,80004bcc <INTC_register_interrupt+0x70>
80004b78:	12 1a       	sub	r10,r9
80004b7a:	fe 79 08 00 	mov	r9,-63488
80004b7e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004b82:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004b84:	58 1a       	cp.w	r10,1
80004b86:	c0 a1       	brne	80004b9a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004b88:	49 09       	lddpc	r9,80004bc8 <INTC_register_interrupt+0x6c>
80004b8a:	49 2a       	lddpc	r10,80004bd0 <INTC_register_interrupt+0x74>
80004b8c:	12 1a       	sub	r10,r9
80004b8e:	bf aa       	sbr	r10,0x1e
80004b90:	fe 79 08 00 	mov	r9,-63488
80004b94:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004b98:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004b9a:	58 2a       	cp.w	r10,2
80004b9c:	c0 a1       	brne	80004bb0 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004b9e:	48 b9       	lddpc	r9,80004bc8 <INTC_register_interrupt+0x6c>
80004ba0:	48 da       	lddpc	r10,80004bd4 <INTC_register_interrupt+0x78>
80004ba2:	12 1a       	sub	r10,r9
80004ba4:	bf ba       	sbr	r10,0x1f
80004ba6:	fe 79 08 00 	mov	r9,-63488
80004baa:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004bae:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004bb0:	48 69       	lddpc	r9,80004bc8 <INTC_register_interrupt+0x6c>
80004bb2:	48 aa       	lddpc	r10,80004bd8 <INTC_register_interrupt+0x7c>
80004bb4:	12 1a       	sub	r10,r9
80004bb6:	ea 1a c0 00 	orh	r10,0xc000
80004bba:	fe 79 08 00 	mov	r9,-63488
80004bbe:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004bc2:	5e fc       	retal	r12
80004bc4:	80 00       	ld.sh	r0,r0[0x0]
80004bc6:	d4 30       	acall	0x43
80004bc8:	80 00       	ld.sh	r0,r0[0x0]
80004bca:	c4 00       	breq	80004c4a <_get_interrupt_handler+0x1a>
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	c5 04       	brge	80004c6e <tc_init_waveform+0x6>
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	c5 12       	brcc	80004c74 <tc_init_waveform+0xc>
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	c5 20       	breq	80004c7a <tc_init_waveform+0x12>
80004bd8:	80 00       	ld.sh	r0,r0[0x0]
80004bda:	c5 2e       	rcall	8000487e <xnl_device_auth_reply_func+0xa6>

80004bdc <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004bdc:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004bde:	49 18       	lddpc	r8,80004c20 <INTC_init_interrupts+0x44>
80004be0:	e3 b8 00 01 	mtsr	0x4,r8
80004be4:	49 0e       	lddpc	lr,80004c24 <INTC_init_interrupts+0x48>
80004be6:	30 07       	mov	r7,0
80004be8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004bea:	49 0c       	lddpc	r12,80004c28 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004bec:	49 05       	lddpc	r5,80004c2c <INTC_init_interrupts+0x50>
80004bee:	10 15       	sub	r5,r8
80004bf0:	fe 76 08 00 	mov	r6,-63488
80004bf4:	c1 08       	rjmp	80004c14 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004bf6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80004bf8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004bfa:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004bfc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004c00:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004c02:	10 3a       	cp.w	r10,r8
80004c04:	fe 9b ff fc 	brhi	80004bfc <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004c08:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004c0c:	2f f7       	sub	r7,-1
80004c0e:	2f 8e       	sub	lr,-8
80004c10:	59 37       	cp.w	r7,19
80004c12:	c0 50       	breq	80004c1c <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004c14:	7c 08       	ld.w	r8,lr[0x0]
80004c16:	58 08       	cp.w	r8,0
80004c18:	ce f1       	brne	80004bf6 <INTC_init_interrupts+0x1a>
80004c1a:	cf 7b       	rjmp	80004c08 <INTC_init_interrupts+0x2c>
80004c1c:	d8 22       	popm	r4-r7,pc
80004c1e:	00 00       	add	r0,r0
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	c4 00       	breq	80004ca2 <tc_init_waveform+0x3a>
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	d4 30       	acall	0x43
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	4b 58       	lddpc	r8,80004cfc <tc_init_waveform+0x94>
80004c2c:	80 00       	ld.sh	r0,r0[0x0]
80004c2e:	c5 04       	brge	80004cce <tc_init_waveform+0x66>

80004c30 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004c30:	fe 78 08 00 	mov	r8,-63488
80004c34:	e0 69 00 83 	mov	r9,131
80004c38:	f2 0c 01 0c 	sub	r12,r9,r12
80004c3c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004c40:	f2 ca ff c0 	sub	r10,r9,-64
80004c44:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004c48:	58 08       	cp.w	r8,0
80004c4a:	c0 21       	brne	80004c4e <_get_interrupt_handler+0x1e>
80004c4c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004c4e:	f0 08 12 00 	clz	r8,r8
80004c52:	48 5a       	lddpc	r10,80004c64 <_get_interrupt_handler+0x34>
80004c54:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004c58:	f0 08 11 1f 	rsub	r8,r8,31
80004c5c:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004c5e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004c62:	5e fc       	retal	r12
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	d4 30       	acall	0x43

80004c68 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004c68:	76 09       	ld.w	r9,r11[0x0]
80004c6a:	58 29       	cp.w	r9,2
80004c6c:	e0 88 00 03 	brls	80004c72 <tc_init_waveform+0xa>
80004c70:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80004c72:	76 18       	ld.w	r8,r11[0x4]
80004c74:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004c78:	af ba       	sbr	r10,0xf
80004c7a:	10 9b       	mov	r11,r8
80004c7c:	e6 1b c0 00 	andh	r11,0xc000,COH
80004c80:	16 4a       	or	r10,r11
80004c82:	10 9b       	mov	r11,r8
80004c84:	e6 1b 30 00 	andh	r11,0x3000,COH
80004c88:	16 4a       	or	r10,r11
80004c8a:	10 9b       	mov	r11,r8
80004c8c:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004c90:	16 4a       	or	r10,r11
80004c92:	10 9b       	mov	r11,r8
80004c94:	e6 1b 03 00 	andh	r11,0x300,COH
80004c98:	16 4a       	or	r10,r11
80004c9a:	10 9b       	mov	r11,r8
80004c9c:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004ca0:	16 4a       	or	r10,r11
80004ca2:	10 9b       	mov	r11,r8
80004ca4:	e6 1b 00 30 	andh	r11,0x30,COH
80004ca8:	16 4a       	or	r10,r11
80004caa:	10 9b       	mov	r11,r8
80004cac:	e6 1b 00 0c 	andh	r11,0xc,COH
80004cb0:	16 4a       	or	r10,r11
80004cb2:	10 9b       	mov	r11,r8
80004cb4:	e6 1b 00 03 	andh	r11,0x3,COH
80004cb8:	16 4a       	or	r10,r11
80004cba:	10 9b       	mov	r11,r8
80004cbc:	e2 1b 60 00 	andl	r11,0x6000,COH
80004cc0:	16 4a       	or	r10,r11
80004cc2:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80004cc6:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80004cca:	10 9b       	mov	r11,r8
80004ccc:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004cd0:	16 4a       	or	r10,r11
80004cd2:	10 9b       	mov	r11,r8
80004cd4:	e2 1b 03 00 	andl	r11,0x300,COH
80004cd8:	16 4a       	or	r10,r11
80004cda:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004cde:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80004ce2:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80004ce6:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
80004cea:	10 9b       	mov	r11,r8
80004cec:	e2 1b 00 30 	andl	r11,0x30,COH
80004cf0:	16 4a       	or	r10,r11
80004cf2:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004cf6:	f5 e8 10 38 	or	r8,r10,r8<<0x3
80004cfa:	a5 69       	lsl	r9,0x4
80004cfc:	2f f9       	sub	r9,-1
80004cfe:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
80004d02:	5e fd       	retal	0

80004d04 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004d04:	58 2b       	cp.w	r11,2
80004d06:	e0 88 00 03 	brls	80004d0c <tc_start+0x8>
80004d0a:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004d0c:	a7 6b       	lsl	r11,0x6
80004d0e:	16 0c       	add	r12,r11
80004d10:	30 58       	mov	r8,5
80004d12:	99 08       	st.w	r12[0x0],r8
80004d14:	5e fd       	retal	0

80004d16 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004d16:	58 2b       	cp.w	r11,2
80004d18:	e0 88 00 03 	brls	80004d1e <tc_read_sr+0x8>
80004d1c:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
80004d1e:	a7 6b       	lsl	r11,0x6
80004d20:	2e 0b       	sub	r11,-32
80004d22:	16 0c       	add	r12,r11
80004d24:	78 0c       	ld.w	r12,r12[0x0]
}
80004d26:	5e fc       	retal	r12

80004d28 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004d28:	58 2b       	cp.w	r11,2
80004d2a:	e0 88 00 03 	brls	80004d30 <tc_write_rc+0x8>
80004d2e:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
80004d30:	f6 08 15 04 	lsl	r8,r11,0x4
80004d34:	2f f8       	sub	r8,-1
80004d36:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
80004d3a:	e2 18 80 00 	andl	r8,0x8000,COH
80004d3e:	c0 c0       	breq	80004d56 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
80004d40:	a7 6b       	lsl	r11,0x6
80004d42:	16 0c       	add	r12,r11
80004d44:	2e 4c       	sub	r12,-28
80004d46:	78 08       	ld.w	r8,r12[0x0]
80004d48:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004d4c:	e0 18 00 00 	andl	r8,0x0
80004d50:	f3 e8 10 08 	or	r8,r9,r8
80004d54:	99 08       	st.w	r12[0x0],r8

  return value;
80004d56:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004d5a:	5e fc       	retal	r12

80004d5c <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004d5c:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004d60:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80004d64:	58 2b       	cp.w	r11,2
80004d66:	e0 88 00 04 	brls	80004d6e <tc_configure_interrupts+0x12>
80004d6a:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004d6e:	ee 19 00 01 	eorh	r9,0x1
80004d72:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80004d76:	74 08       	ld.w	r8,r10[0x0]
80004d78:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004d7c:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004d80:	a7 6e       	lsl	lr,0x6
80004d82:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80004d86:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004d8a:	0e 4e       	or	lr,r7
80004d8c:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004d90:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80004d94:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004d98:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004d9c:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004da0:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80004da4:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004da8:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004dac:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004db0:	fd e8 10 18 	or	r8,lr,r8<<0x1
80004db4:	f6 0e 15 06 	lsl	lr,r11,0x6
80004db8:	f8 0e 00 0e 	add	lr,r12,lr
80004dbc:	2d ce       	sub	lr,-36
80004dbe:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004dc0:	58 09       	cp.w	r9,0
80004dc2:	c0 20       	breq	80004dc6 <tc_configure_interrupts+0x6a>
80004dc4:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004dc6:	74 08       	ld.w	r8,r10[0x0]
80004dc8:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004dcc:	e0 65 00 80 	mov	r5,128
80004dd0:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80004dd4:	74 08       	ld.w	r8,r10[0x0]
80004dd6:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004dda:	f9 b4 00 40 	moveq	r4,64
80004dde:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80004de2:	74 08       	ld.w	r8,r10[0x0]
80004de4:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
80004de8:	f9 b3 00 20 	moveq	r3,32
80004dec:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
80004df0:	74 08       	ld.w	r8,r10[0x0]
80004df2:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
80004df6:	f9 b2 00 10 	moveq	r2,16
80004dfa:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
80004dfe:	74 08       	ld.w	r8,r10[0x0]
80004e00:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80004e04:	f9 b6 00 08 	moveq	r6,8
80004e08:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
80004e0c:	74 08       	ld.w	r8,r10[0x0]
80004e0e:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
80004e12:	f9 b7 00 04 	moveq	r7,4
80004e16:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
80004e1a:	74 08       	ld.w	r8,r10[0x0]
80004e1c:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004e20:	f9 be 00 02 	moveq	lr,2
80004e24:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80004e28:	74 08       	ld.w	r8,r10[0x0]
80004e2a:	ec 18 00 01 	eorl	r8,0x1
80004e2e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e32:	eb e8 10 08 	or	r8,r5,r8
80004e36:	08 48       	or	r8,r4
80004e38:	06 48       	or	r8,r3
80004e3a:	04 48       	or	r8,r2
80004e3c:	0c 48       	or	r8,r6
80004e3e:	0e 48       	or	r8,r7
80004e40:	1c 48       	or	r8,lr
80004e42:	f6 0a 15 06 	lsl	r10,r11,0x6
80004e46:	f8 0a 00 0a 	add	r10,r12,r10
80004e4a:	2d 8a       	sub	r10,-40
80004e4c:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004e4e:	a7 6b       	lsl	r11,0x6
80004e50:	2e 0b       	sub	r11,-32
80004e52:	16 0c       	add	r12,r11
80004e54:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80004e56:	58 09       	cp.w	r9,0
80004e58:	c0 31       	brne	80004e5e <tc_configure_interrupts+0x102>
80004e5a:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004e5e:	d5 03       	csrf	0x10
80004e60:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

80004e64 <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
80004e64:	4a 78       	lddpc	r8,80004f00 <twi_master_interrupt_handler+0x9c>
80004e66:	70 08       	ld.w	r8,r8[0x0]
80004e68:	70 89       	ld.w	r9,r8[0x20]
80004e6a:	4a 7a       	lddpc	r10,80004f04 <twi_master_interrupt_handler+0xa0>
80004e6c:	74 0a       	ld.w	r10,r10[0x0]
80004e6e:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
80004e72:	12 9a       	mov	r10,r9
80004e74:	e2 1a 01 00 	andl	r10,0x100,COH
80004e78:	c3 91       	brne	80004eea <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80004e7a:	12 9a       	mov	r10,r9
80004e7c:	e2 1a 00 02 	andl	r10,0x2,COH
80004e80:	c1 70       	breq	80004eae <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
80004e82:	4a 29       	lddpc	r9,80004f08 <twi_master_interrupt_handler+0xa4>
80004e84:	72 0a       	ld.w	r10,r9[0x0]
80004e86:	70 cb       	ld.w	r11,r8[0x30]
80004e88:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80004e8a:	72 0a       	ld.w	r10,r9[0x0]
80004e8c:	2f fa       	sub	r10,-1
80004e8e:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80004e90:	49 f9       	lddpc	r9,80004f0c <twi_master_interrupt_handler+0xa8>
80004e92:	72 0a       	ld.w	r10,r9[0x0]
80004e94:	20 1a       	sub	r10,1
80004e96:	93 0a       	st.w	r9[0x0],r10
80004e98:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80004e9a:	58 19       	cp.w	r9,1
80004e9c:	f9 b9 00 02 	moveq	r9,2
80004ea0:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
80004ea4:	49 a9       	lddpc	r9,80004f0c <twi_master_interrupt_handler+0xa8>
80004ea6:	72 09       	ld.w	r9,r9[0x0]
80004ea8:	58 09       	cp.w	r9,0
80004eaa:	c2 30       	breq	80004ef0 <twi_master_interrupt_handler+0x8c>
80004eac:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80004eae:	12 9a       	mov	r10,r9
80004eb0:	e2 1a 00 04 	andl	r10,0x4,COH
80004eb4:	c1 70       	breq	80004ee2 <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
80004eb6:	49 79       	lddpc	r9,80004f10 <twi_master_interrupt_handler+0xac>
80004eb8:	72 0a       	ld.w	r10,r9[0x0]
80004eba:	20 1a       	sub	r10,1
80004ebc:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80004ebe:	72 09       	ld.w	r9,r9[0x0]
80004ec0:	58 09       	cp.w	r9,0
80004ec2:	e0 89 00 0a 	brgt	80004ed6 <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80004ec6:	49 09       	lddpc	r9,80004f04 <twi_master_interrupt_handler+0xa0>
80004ec8:	30 1a       	mov	r10,1
80004eca:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80004ecc:	3f fa       	mov	r10,-1
80004ece:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80004ed0:	72 09       	ld.w	r9,r9[0x0]
80004ed2:	91 99       	st.w	r8[0x24],r9
80004ed4:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
80004ed6:	49 0a       	lddpc	r10,80004f14 <twi_master_interrupt_handler+0xb0>
80004ed8:	74 09       	ld.w	r9,r10[0x0]
80004eda:	13 3b       	ld.ub	r11,r9++
80004edc:	91 db       	st.w	r8[0x34],r11
80004ede:	95 09       	st.w	r10[0x0],r9
80004ee0:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
80004ee2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004ee6:	c0 51       	brne	80004ef0 <twi_master_interrupt_handler+0x8c>
80004ee8:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
80004eea:	30 1a       	mov	r10,1
80004eec:	48 b9       	lddpc	r9,80004f18 <twi_master_interrupt_handler+0xb4>
80004eee:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
80004ef0:	3f f9       	mov	r9,-1
80004ef2:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
80004ef4:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
80004ef6:	30 09       	mov	r9,0
80004ef8:	48 98       	lddpc	r8,80004f1c <twi_master_interrupt_handler+0xb8>
80004efa:	b0 89       	st.b	r8[0x0],r9
80004efc:	d6 03       	rete
80004efe:	00 00       	add	r0,r0
80004f00:	00 00       	add	r0,r0
80004f02:	0c 20       	rsub	r0,r6
80004f04:	00 00       	add	r0,r0
80004f06:	0c 1c       	sub	r12,r6
80004f08:	00 00       	add	r0,r0
80004f0a:	0c 2c       	rsub	r12,r6
80004f0c:	00 00       	add	r0,r0
80004f0e:	0c 28       	rsub	r8,r6
80004f10:	00 00       	add	r0,r0
80004f12:	0c 18       	sub	r8,r6
80004f14:	00 00       	add	r0,r0
80004f16:	0c 24       	rsub	r4,r6
80004f18:	00 00       	add	r0,r0
80004f1a:	0c 15       	sub	r5,r6
80004f1c:	00 00       	add	r0,r0
80004f1e:	0c 14       	sub	r4,r6

80004f20 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80004f20:	eb cd 40 e0 	pushm	r5-r7,lr
80004f24:	18 97       	mov	r7,r12
80004f26:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
80004f28:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
80004f2c:	49 f9       	lddpc	r9,80004fa8 <twi_master_init+0x88>
80004f2e:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
80004f30:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
80004f32:	3f f9       	mov	r9,-1
80004f34:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
80004f36:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
80004f38:	e0 69 00 80 	mov	r9,128
80004f3c:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004f3e:	e6 18 00 01 	andh	r8,0x1,COH
80004f42:	c0 21       	brne	80004f46 <twi_master_init+0x26>
      cpu_irq_enable();
80004f44:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
80004f46:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004f48:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80004f4c:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80004f4e:	30 3a       	mov	r10,3
80004f50:	e0 6b 01 60 	mov	r11,352
80004f54:	49 6c       	lddpc	r12,80004fac <twi_master_init+0x8c>
80004f56:	f0 1f 00 17 	mcall	80004fb0 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004f5a:	e6 16 00 01 	andh	r6,0x1,COH
80004f5e:	c0 21       	brne	80004f62 <twi_master_init+0x42>
      cpu_irq_enable();
80004f60:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
80004f62:	6a 19       	ld.w	r9,r5[0x4]
80004f64:	a1 79       	lsl	r9,0x1
80004f66:	6a 08       	ld.w	r8,r5[0x0]
80004f68:	f0 09 0d 08 	divu	r8,r8,r9
80004f6c:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004f6e:	e0 48 00 ff 	cp.w	r8,255
80004f72:	e0 8b 00 04 	brhi	80004f7a <twi_master_init+0x5a>
80004f76:	30 09       	mov	r9,0
80004f78:	c0 f8       	rjmp	80004f96 <twi_master_init+0x76>
80004f7a:	30 09       	mov	r9,0
80004f7c:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80004f7e:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80004f80:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004f82:	e0 48 00 ff 	cp.w	r8,255
80004f86:	5f bb       	srhi	r11
80004f88:	58 69       	cp.w	r9,6
80004f8a:	5f 8a       	srls	r10
80004f8c:	f7 ea 00 0a 	and	r10,r11,r10
80004f90:	f8 0a 18 00 	cp.b	r10,r12
80004f94:	cf 51       	brne	80004f7e <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
80004f96:	b1 69       	lsl	r9,0x10
80004f98:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80004f9c:	f3 e8 10 08 	or	r8,r9,r8
80004fa0:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
80004fa2:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80004fa6:	00 00       	add	r0,r0
80004fa8:	00 00       	add	r0,r0
80004faa:	0c 20       	rsub	r0,r6
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	4e 64       	lddpc	r4,80005144 <usart_init_rs232+0x54>
80004fb0:	80 00       	ld.sh	r0,r0[0x0]
80004fb2:	4b 5c       	lddpc	r12,80005084 <usart_getchar+0x10>

80004fb4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004fb4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004fb6:	f6 08 15 04 	lsl	r8,r11,0x4
80004fba:	14 38       	cp.w	r8,r10
80004fbc:	f9 b8 08 10 	movls	r8,16
80004fc0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004fc4:	f0 0b 02 4b 	mul	r11,r8,r11
80004fc8:	f6 09 16 01 	lsr	r9,r11,0x1
80004fcc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004fd0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004fd4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004fd8:	f2 cb 00 01 	sub	r11,r9,1
80004fdc:	e0 4b ff fe 	cp.w	r11,65534
80004fe0:	e0 88 00 03 	brls	80004fe6 <usart_set_async_baudrate+0x32>
80004fe4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004fe6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004fe8:	e8 6e 00 00 	mov	lr,524288
80004fec:	59 08       	cp.w	r8,16
80004fee:	fc 08 17 10 	movne	r8,lr
80004ff2:	f9 b8 00 00 	moveq	r8,0
80004ff6:	e4 1b ff f7 	andh	r11,0xfff7
80004ffa:	e0 1b fe cf 	andl	r11,0xfecf
80004ffe:	16 48       	or	r8,r11
80005000:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005002:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005006:	f3 ea 11 09 	or	r9,r9,r10<<0x10
8000500a:	99 89       	st.w	r12[0x20],r9
8000500c:	d8 0a       	popm	pc,r12=0

8000500e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000500e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005010:	e2 18 00 02 	andl	r8,0x2,COH
80005014:	c0 31       	brne	8000501a <usart_write_char+0xc>
80005016:	30 2c       	mov	r12,2
80005018:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000501a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000501e:	99 7b       	st.w	r12[0x1c],r11
80005020:	5e fd       	retal	0
80005022:	d7 03       	nop

80005024 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005024:	eb cd 40 e0 	pushm	r5-r7,lr
80005028:	18 96       	mov	r6,r12
8000502a:	16 95       	mov	r5,r11
8000502c:	e0 67 27 0f 	mov	r7,9999
80005030:	c0 68       	rjmp	8000503c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005032:	58 07       	cp.w	r7,0
80005034:	c0 31       	brne	8000503a <usart_putchar+0x16>
80005036:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000503a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
8000503c:	0a 9b       	mov	r11,r5
8000503e:	0c 9c       	mov	r12,r6
80005040:	f0 1f 00 03 	mcall	8000504c <usart_putchar+0x28>
80005044:	cf 71       	brne	80005032 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005046:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000504a:	00 00       	add	r0,r0
8000504c:	80 00       	ld.sh	r0,r0[0x0]
8000504e:	50 0e       	stdsp	sp[0x0],lr

80005050 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005050:	78 58       	ld.w	r8,r12[0x14]
80005052:	e2 18 00 e0 	andl	r8,0xe0,COH
80005056:	c0 30       	breq	8000505c <usart_read_char+0xc>
80005058:	30 4c       	mov	r12,4
8000505a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
8000505c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000505e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005062:	c0 31       	brne	80005068 <usart_read_char+0x18>
80005064:	30 3c       	mov	r12,3
80005066:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005068:	78 68       	ld.w	r8,r12[0x18]
8000506a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000506e:	97 08       	st.w	r11[0x0],r8
80005070:	5e fd       	retal	0
80005072:	d7 03       	nop

80005074 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005074:	eb cd 40 c0 	pushm	r6-r7,lr
80005078:	20 1d       	sub	sp,4
8000507a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
8000507c:	1a 97       	mov	r7,sp
8000507e:	1a 9b       	mov	r11,sp
80005080:	0c 9c       	mov	r12,r6
80005082:	f0 1f 00 07 	mcall	8000509c <usart_getchar+0x28>
80005086:	58 3c       	cp.w	r12,3
80005088:	cf b0       	breq	8000507e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000508a:	58 4c       	cp.w	r12,4
8000508c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005090:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005094:	2f fd       	sub	sp,-4
80005096:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000509a:	00 00       	add	r0,r0
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	50 50       	stdsp	sp[0x14],r0

800050a0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800050a0:	eb cd 40 c0 	pushm	r6-r7,lr
800050a4:	18 96       	mov	r6,r12
800050a6:	16 97       	mov	r7,r11
  while (*string != '\0')
800050a8:	17 8b       	ld.ub	r11,r11[0x0]
800050aa:	58 0b       	cp.w	r11,0
800050ac:	c0 80       	breq	800050bc <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800050ae:	2f f7       	sub	r7,-1
800050b0:	0c 9c       	mov	r12,r6
800050b2:	f0 1f 00 04 	mcall	800050c0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800050b6:	0f 8b       	ld.ub	r11,r7[0x0]
800050b8:	58 0b       	cp.w	r11,0
800050ba:	cf a1       	brne	800050ae <usart_write_line+0xe>
800050bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800050c0:	80 00       	ld.sh	r0,r0[0x0]
800050c2:	50 24       	stdsp	sp[0x8],r4

800050c4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800050c4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800050c8:	e6 18 00 01 	andh	r8,0x1,COH
800050cc:	c0 71       	brne	800050da <usart_reset+0x16>
800050ce:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800050d0:	3f f8       	mov	r8,-1
800050d2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800050d4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800050d6:	d5 03       	csrf	0x10
800050d8:	c0 48       	rjmp	800050e0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800050da:	3f f8       	mov	r8,-1
800050dc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800050de:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800050e0:	30 08       	mov	r8,0
800050e2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800050e4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800050e6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800050e8:	ea 68 61 0c 	mov	r8,680204
800050ec:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800050ee:	5e fc       	retal	r12

800050f0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800050f0:	eb cd 40 e0 	pushm	r5-r7,lr
800050f4:	18 96       	mov	r6,r12
800050f6:	16 97       	mov	r7,r11
800050f8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800050fa:	f0 1f 00 2f 	mcall	800051b4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800050fe:	58 07       	cp.w	r7,0
80005100:	c5 80       	breq	800051b0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005102:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005104:	30 49       	mov	r9,4
80005106:	f2 08 18 00 	cp.b	r8,r9
8000510a:	e0 88 00 53 	brls	800051b0 <usart_init_rs232+0xc0>
8000510e:	30 99       	mov	r9,9
80005110:	f2 08 18 00 	cp.b	r8,r9
80005114:	e0 8b 00 4e 	brhi	800051b0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005118:	0f d9       	ld.ub	r9,r7[0x5]
8000511a:	30 78       	mov	r8,7
8000511c:	f0 09 18 00 	cp.b	r9,r8
80005120:	e0 8b 00 48 	brhi	800051b0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005124:	8e 39       	ld.sh	r9,r7[0x6]
80005126:	e0 68 01 01 	mov	r8,257
8000512a:	f0 09 19 00 	cp.h	r9,r8
8000512e:	e0 8b 00 41 	brhi	800051b0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005132:	ef 39 00 08 	ld.ub	r9,r7[8]
80005136:	30 38       	mov	r8,3
80005138:	f0 09 18 00 	cp.b	r9,r8
8000513c:	e0 8b 00 3a 	brhi	800051b0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005140:	0a 9a       	mov	r10,r5
80005142:	6e 0b       	ld.w	r11,r7[0x0]
80005144:	0c 9c       	mov	r12,r6
80005146:	f0 1f 00 1d 	mcall	800051b8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
8000514a:	58 1c       	cp.w	r12,1
8000514c:	c3 20       	breq	800051b0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
8000514e:	0f c8       	ld.ub	r8,r7[0x4]
80005150:	30 99       	mov	r9,9
80005152:	f2 08 18 00 	cp.b	r8,r9
80005156:	c0 51       	brne	80005160 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005158:	6c 18       	ld.w	r8,r6[0x4]
8000515a:	b1 b8       	sbr	r8,0x11
8000515c:	8d 18       	st.w	r6[0x4],r8
8000515e:	c0 68       	rjmp	8000516a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005160:	6c 19       	ld.w	r9,r6[0x4]
80005162:	20 58       	sub	r8,5
80005164:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005168:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000516a:	6c 19       	ld.w	r9,r6[0x4]
8000516c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005170:	0f d8       	ld.ub	r8,r7[0x5]
80005172:	a9 78       	lsl	r8,0x9
80005174:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005178:	12 48       	or	r8,r9
8000517a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
8000517c:	8e 38       	ld.sh	r8,r7[0x6]
8000517e:	30 29       	mov	r9,2
80005180:	f2 08 19 00 	cp.h	r8,r9
80005184:	e0 88 00 09 	brls	80005196 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005188:	6c 18       	ld.w	r8,r6[0x4]
8000518a:	ad b8       	sbr	r8,0xd
8000518c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
8000518e:	8e b8       	ld.uh	r8,r7[0x6]
80005190:	20 28       	sub	r8,2
80005192:	8d a8       	st.w	r6[0x28],r8
80005194:	c0 68       	rjmp	800051a0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005196:	6c 19       	ld.w	r9,r6[0x4]
80005198:	5c 78       	castu.h	r8
8000519a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
8000519e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
800051a0:	6c 18       	ld.w	r8,r6[0x4]
800051a2:	e0 18 ff f0 	andl	r8,0xfff0
800051a6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800051a8:	35 08       	mov	r8,80
800051aa:	8d 08       	st.w	r6[0x0],r8
800051ac:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800051b0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	50 c4       	stdsp	sp[0x30],r4
800051b8:	80 00       	ld.sh	r0,r0[0x0]
800051ba:	4f b4       	lddpc	r4,800053a4 <SCALLYield+0x5c>

800051bc <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800051bc:	f8 c8 ff f8 	sub	r8,r12,-8
800051c0:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800051c2:	3f f9       	mov	r9,-1
800051c4:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800051c6:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800051c8:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800051ca:	30 08       	mov	r8,0
800051cc:	99 08       	st.w	r12[0x0],r8
}
800051ce:	5e fc       	retal	r12

800051d0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800051d0:	30 08       	mov	r8,0
800051d2:	99 48       	st.w	r12[0x10],r8
}
800051d4:	5e fc       	retal	r12

800051d6 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800051d6:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800051d8:	70 19       	ld.w	r9,r8[0x4]
800051da:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800051dc:	78 19       	ld.w	r9,r12[0x4]
800051de:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800051e0:	70 19       	ld.w	r9,r8[0x4]
800051e2:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800051e4:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800051e6:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800051e8:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800051ea:	78 08       	ld.w	r8,r12[0x0]
800051ec:	2f f8       	sub	r8,-1
800051ee:	99 08       	st.w	r12[0x0],r8
}
800051f0:	5e fc       	retal	r12

800051f2 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800051f2:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800051f4:	5b fa       	cp.w	r10,-1
800051f6:	c0 31       	brne	800051fc <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800051f8:	78 48       	ld.w	r8,r12[0x10]
800051fa:	c0 c8       	rjmp	80005212 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800051fc:	f8 c8 ff f8 	sub	r8,r12,-8
80005200:	70 19       	ld.w	r9,r8[0x4]
80005202:	72 09       	ld.w	r9,r9[0x0]
80005204:	12 3a       	cp.w	r10,r9
80005206:	c0 63       	brcs	80005212 <vListInsert+0x20>
80005208:	70 18       	ld.w	r8,r8[0x4]
8000520a:	70 19       	ld.w	r9,r8[0x4]
8000520c:	72 09       	ld.w	r9,r9[0x0]
8000520e:	12 3a       	cp.w	r10,r9
80005210:	cf c2       	brcc	80005208 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005212:	70 19       	ld.w	r9,r8[0x4]
80005214:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005216:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005218:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
8000521a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
8000521c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000521e:	78 08       	ld.w	r8,r12[0x0]
80005220:	2f f8       	sub	r8,-1
80005222:	99 08       	st.w	r12[0x0],r8
}
80005224:	5e fc       	retal	r12

80005226 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005226:	78 18       	ld.w	r8,r12[0x4]
80005228:	78 29       	ld.w	r9,r12[0x8]
8000522a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8000522c:	78 28       	ld.w	r8,r12[0x8]
8000522e:	78 19       	ld.w	r9,r12[0x4]
80005230:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005232:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005234:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005236:	18 39       	cp.w	r9,r12
80005238:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
8000523c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005240:	30 09       	mov	r9,0
80005242:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005244:	70 09       	ld.w	r9,r8[0x0]
80005246:	20 19       	sub	r9,1
80005248:	91 09       	st.w	r8[0x0],r9
}
8000524a:	5e fc       	retal	r12

8000524c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
8000524c:	e0 68 08 08 	mov	r8,2056
80005250:	ea 18 08 08 	orh	r8,0x808
80005254:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005256:	e0 68 09 09 	mov	r8,2313
8000525a:	ea 18 09 09 	orh	r8,0x909
8000525e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005260:	e0 68 0a 0a 	mov	r8,2570
80005264:	ea 18 0a 0a 	orh	r8,0xa0a
80005268:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
8000526a:	e0 68 0b 0b 	mov	r8,2827
8000526e:	ea 18 0b 0b 	orh	r8,0xb0b
80005272:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005274:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005276:	e0 68 be ef 	mov	r8,48879
8000527a:	ea 18 de ad 	orh	r8,0xdead
8000527e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005280:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005282:	fc 18 00 40 	movh	r8,0x40
80005286:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005288:	e0 68 00 ff 	mov	r8,255
8000528c:	ea 18 ff 00 	orh	r8,0xff00
80005290:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005292:	e0 68 01 01 	mov	r8,257
80005296:	ea 18 01 01 	orh	r8,0x101
8000529a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000529c:	e0 68 02 02 	mov	r8,514
800052a0:	ea 18 02 02 	orh	r8,0x202
800052a4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800052a6:	e0 68 03 03 	mov	r8,771
800052aa:	ea 18 03 03 	orh	r8,0x303
800052ae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800052b0:	e0 68 04 04 	mov	r8,1028
800052b4:	ea 18 04 04 	orh	r8,0x404
800052b8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800052ba:	e0 68 05 05 	mov	r8,1285
800052be:	ea 18 05 05 	orh	r8,0x505
800052c2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800052c4:	e0 68 06 06 	mov	r8,1542
800052c8:	ea 18 06 06 	orh	r8,0x606
800052cc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800052ce:	e0 68 07 07 	mov	r8,1799
800052d2:	ea 18 07 07 	orh	r8,0x707
800052d6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800052d8:	30 08       	mov	r8,0
800052da:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800052dc:	5e fc       	retal	r12
800052de:	d7 03       	nop

800052e0 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800052e0:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800052e2:	48 38       	lddpc	r8,800052ec <vPortEnterCritical+0xc>
800052e4:	70 09       	ld.w	r9,r8[0x0]
800052e6:	2f f9       	sub	r9,-1
800052e8:	91 09       	st.w	r8[0x0],r9
}
800052ea:	5e fc       	retal	r12
800052ec:	00 00       	add	r0,r0
800052ee:	05 30       	ld.ub	r0,r2++

800052f0 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800052f0:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800052f2:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800052f4:	30 0a       	mov	r10,0
800052f6:	14 9b       	mov	r11,r10
800052f8:	49 2c       	lddpc	r12,80005340 <xPortStartScheduler+0x50>
800052fa:	f0 1f 00 13 	mcall	80005344 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800052fe:	e0 68 5d c0 	mov	r8,24000
80005302:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005306:	30 08       	mov	r8,0
80005308:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000530c:	e0 68 0d 00 	mov	r8,3328
80005310:	ea 18 00 00 	orh	r8,0x0
80005314:	70 00       	ld.w	r0,r8[0x0]
80005316:	60 0d       	ld.w	sp,r0[0x0]
80005318:	1b 00       	ld.w	r0,sp++
8000531a:	e0 68 05 30 	mov	r8,1328
8000531e:	ea 18 00 00 	orh	r8,0x0
80005322:	91 00       	st.w	r8[0x0],r0
80005324:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005328:	2f ed       	sub	sp,-8
8000532a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000532e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005332:	e3 b0 00 00 	mtsr	0x0,r0
80005336:	fa f0 ff dc 	ld.w	r0,sp[-36]
8000533a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000533e:	d8 0a       	popm	pc,r12=0
80005340:	80 00       	ld.sh	r0,r0[0x0]
80005342:	54 0c       	stdsp	sp[0x100],r12
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	4b 5c       	lddpc	r12,80005418 <vTick+0xc>

80005348 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005348:	20 6d       	sub	sp,24
8000534a:	eb cd 00 ff 	pushm	r0-r7
8000534e:	fa c7 ff c0 	sub	r7,sp,-64
80005352:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005356:	ef 40 ff e0 	st.w	r7[-32],r0
8000535a:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000535e:	ef 40 ff e4 	st.w	r7[-28],r0
80005362:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005366:	e0 68 05 30 	mov	r8,1328
8000536a:	ea 18 00 00 	orh	r8,0x0
8000536e:	70 00       	ld.w	r0,r8[0x0]
80005370:	1a d0       	st.w	--sp,r0
80005372:	f0 1f 00 1a 	mcall	800053d8 <LABEL_RET_SCALL_263+0x14>
80005376:	e0 68 0d 00 	mov	r8,3328
8000537a:	ea 18 00 00 	orh	r8,0x0
8000537e:	70 00       	ld.w	r0,r8[0x0]
80005380:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005382:	f0 1f 00 17 	mcall	800053dc <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005386:	e0 68 0d 00 	mov	r8,3328
8000538a:	ea 18 00 00 	orh	r8,0x0
8000538e:	70 00       	ld.w	r0,r8[0x0]
80005390:	60 0d       	ld.w	sp,r0[0x0]
80005392:	1b 00       	ld.w	r0,sp++
80005394:	e0 68 05 30 	mov	r8,1328
80005398:	ea 18 00 00 	orh	r8,0x0
8000539c:	91 00       	st.w	r8[0x0],r0
8000539e:	fa c7 ff d8 	sub	r7,sp,-40
800053a2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800053a6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800053aa:	e0 61 05 30 	mov	r1,1328
800053ae:	ea 11 00 00 	orh	r1,0x0
800053b2:	62 02       	ld.w	r2,r1[0x0]
800053b4:	58 02       	cp.w	r2,0
800053b6:	c0 70       	breq	800053c4 <LABEL_RET_SCALL_263>
800053b8:	e4 c2 00 01 	sub	r2,r2,1
800053bc:	83 02       	st.w	r1[0x0],r2
800053be:	58 02       	cp.w	r2,0
800053c0:	c0 21       	brne	800053c4 <LABEL_RET_SCALL_263>
800053c2:	b1 c0       	cbr	r0,0x10

800053c4 <LABEL_RET_SCALL_263>:
800053c4:	ef 40 ff f8 	st.w	r7[-8],r0
800053c8:	ee f0 ff e4 	ld.w	r0,r7[-28]
800053cc:	ef 40 ff fc 	st.w	r7[-4],r0
800053d0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800053d4:	2f ad       	sub	sp,-24
800053d6:	d6 13       	rets
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	52 e0       	stdsp	sp[0xb8],r0
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	5a 7c       	cp.w	r12,-25

800053e0 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800053e0:	e1 b8 00 43 	mfsr	r8,0x10c
800053e4:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800053e8:	5e fc       	retal	r12
800053ea:	d7 03       	nop

800053ec <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800053ec:	48 78       	lddpc	r8,80005408 <vPortExitCritical+0x1c>
800053ee:	70 08       	ld.w	r8,r8[0x0]
800053f0:	58 08       	cp.w	r8,0
800053f2:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800053f4:	48 58       	lddpc	r8,80005408 <vPortExitCritical+0x1c>
800053f6:	70 09       	ld.w	r9,r8[0x0]
800053f8:	20 19       	sub	r9,1
800053fa:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800053fc:	70 08       	ld.w	r8,r8[0x0]
800053fe:	58 08       	cp.w	r8,0
80005400:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005402:	d5 03       	csrf	0x10
80005404:	5e fc       	retal	r12
80005406:	00 00       	add	r0,r0
80005408:	00 00       	add	r0,r0
8000540a:	05 30       	ld.ub	r0,r2++

8000540c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000540c:	eb cd 00 ff 	pushm	r0-r7
80005410:	e0 68 05 30 	mov	r8,1328
80005414:	ea 18 00 00 	orh	r8,0x0
80005418:	70 00       	ld.w	r0,r8[0x0]
8000541a:	1a d0       	st.w	--sp,r0
8000541c:	7a 90       	ld.w	r0,sp[0x24]
8000541e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005422:	58 10       	cp.w	r0,1
80005424:	e0 8b 00 08 	brhi	80005434 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005428:	e0 68 0d 00 	mov	r8,3328
8000542c:	ea 18 00 00 	orh	r8,0x0
80005430:	70 00       	ld.w	r0,r8[0x0]
80005432:	81 0d       	st.w	r0[0x0],sp

80005434 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005434:	f0 1f 00 12 	mcall	8000547c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005438:	f0 1f 00 12 	mcall	80005480 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
8000543c:	f0 1f 00 12 	mcall	80005484 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005440:	f0 1f 00 12 	mcall	80005488 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005444:	7a 90       	ld.w	r0,sp[0x24]
80005446:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000544a:	58 10       	cp.w	r0,1
8000544c:	e0 8b 00 0e 	brhi	80005468 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005450:	f0 1f 00 0c 	mcall	80005480 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005454:	f0 1f 00 0e 	mcall	8000548c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005458:	f0 1f 00 0c 	mcall	80005488 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
8000545c:	e0 68 0d 00 	mov	r8,3328
80005460:	ea 18 00 00 	orh	r8,0x0
80005464:	70 00       	ld.w	r0,r8[0x0]
80005466:	60 0d       	ld.w	sp,r0[0x0]

80005468 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005468:	1b 00       	ld.w	r0,sp++
8000546a:	e0 68 05 30 	mov	r8,1328
8000546e:	ea 18 00 00 	orh	r8,0x0
80005472:	91 00       	st.w	r8[0x0],r0
80005474:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005478:	d6 03       	rete
8000547a:	00 00       	add	r0,r0
8000547c:	80 00       	ld.sh	r0,r0[0x0]
8000547e:	53 e0       	stdsp	sp[0xf8],r0
80005480:	80 00       	ld.sh	r0,r0[0x0]
80005482:	52 e0       	stdsp	sp[0xb8],r0
80005484:	80 00       	ld.sh	r0,r0[0x0]
80005486:	5c 80       	casts.h	r0
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	53 ec       	stdsp	sp[0xf8],r12
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	5a 7c       	cp.w	r12,-25

80005490 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005490:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005492:	f0 1f 00 02 	mcall	80005498 <__malloc_lock+0x8>
}
80005496:	d8 02       	popm	pc
80005498:	80 00       	ld.sh	r0,r0[0x0]
8000549a:	5a 6c       	cp.w	r12,-26

8000549c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000549c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000549e:	f0 1f 00 02 	mcall	800054a4 <__malloc_unlock+0x8>
}
800054a2:	d8 02       	popm	pc
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	5e 28       	reths	r8

800054a8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800054a8:	d4 21       	pushm	r4-r7,lr
800054aa:	16 95       	mov	r5,r11
800054ac:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800054ae:	58 0c       	cp.w	r12,0
800054b0:	c0 30       	breq	800054b6 <_read+0xe>
800054b2:	3f f7       	mov	r7,-1
800054b4:	c1 48       	rjmp	800054dc <_read+0x34>
    return -1;

  for (; len > 0; --len)
800054b6:	58 0a       	cp.w	r10,0
800054b8:	e0 89 00 04 	brgt	800054c0 <_read+0x18>
800054bc:	30 07       	mov	r7,0
800054be:	c0 f8       	rjmp	800054dc <_read+0x34>
800054c0:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800054c2:	48 84       	lddpc	r4,800054e0 <_read+0x38>
800054c4:	68 0c       	ld.w	r12,r4[0x0]
800054c6:	f0 1f 00 08 	mcall	800054e4 <_read+0x3c>
    if (c < 0)
800054ca:	c0 95       	brlt	800054dc <_read+0x34>
      break;

    *ptr++ = c;
800054cc:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
800054d0:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
800054d2:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
800054d6:	58 08       	cp.w	r8,0
800054d8:	fe 99 ff f6 	brgt	800054c4 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
800054dc:	0e 9c       	mov	r12,r7
800054de:	d8 22       	popm	r4-r7,pc
800054e0:	00 00       	add	r0,r0
800054e2:	41 0c       	lddsp	r12,sp[0x40]
800054e4:	80 00       	ld.sh	r0,r0[0x0]
800054e6:	50 74       	stdsp	sp[0x1c],r4

800054e8 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
800054e8:	d4 21       	pushm	r4-r7,lr
800054ea:	16 95       	mov	r5,r11
800054ec:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
800054ee:	20 1c       	sub	r12,1
800054f0:	58 2c       	cp.w	r12,2
800054f2:	e0 8b 00 12 	brhi	80005516 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
800054f6:	58 0a       	cp.w	r10,0
800054f8:	c0 31       	brne	800054fe <_write+0x16>
800054fa:	30 07       	mov	r7,0
800054fc:	c0 e8       	rjmp	80005518 <_write+0x30>
800054fe:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005500:	48 74       	lddpc	r4,8000551c <_write+0x34>
80005502:	68 0c       	ld.w	r12,r4[0x0]
80005504:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005508:	f0 1f 00 06 	mcall	80005520 <_write+0x38>
8000550c:	c0 55       	brlt	80005516 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000550e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005510:	0e 36       	cp.w	r6,r7
80005512:	cf 81       	brne	80005502 <_write+0x1a>
80005514:	c0 28       	rjmp	80005518 <_write+0x30>
80005516:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005518:	0e 9c       	mov	r12,r7
8000551a:	d8 22       	popm	r4-r7,pc
8000551c:	00 00       	add	r0,r0
8000551e:	41 0c       	lddsp	r12,sp[0x40]
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	50 24       	stdsp	sp[0x8],r4

80005524 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005524:	eb cd 40 80 	pushm	r7,lr
80005528:	18 97       	mov	r7,r12
	if( pv )
8000552a:	58 0c       	cp.w	r12,0
8000552c:	c0 80       	breq	8000553c <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000552e:	f0 1f 00 05 	mcall	80005540 <vPortFree+0x1c>
		{
			free( pv );
80005532:	0e 9c       	mov	r12,r7
80005534:	f0 1f 00 04 	mcall	80005544 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005538:	f0 1f 00 04 	mcall	80005548 <vPortFree+0x24>
8000553c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	5a 6c       	cp.w	r12,-26
80005544:	80 00       	ld.sh	r0,r0[0x0]
80005546:	69 98       	ld.w	r8,r4[0x64]
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	5e 28       	reths	r8

8000554c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
8000554c:	eb cd 40 80 	pushm	r7,lr
80005550:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005552:	f0 1f 00 06 	mcall	80005568 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005556:	0e 9c       	mov	r12,r7
80005558:	f0 1f 00 05 	mcall	8000556c <pvPortMalloc+0x20>
8000555c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
8000555e:	f0 1f 00 05 	mcall	80005570 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005562:	0e 9c       	mov	r12,r7
80005564:	e3 cd 80 80 	ldm	sp++,r7,pc
80005568:	80 00       	ld.sh	r0,r0[0x0]
8000556a:	5a 6c       	cp.w	r12,-26
8000556c:	80 00       	ld.sh	r0,r0[0x0]
8000556e:	69 a8       	ld.w	r8,r4[0x68]
80005570:	80 00       	ld.sh	r0,r0[0x0]
80005572:	5e 28       	reths	r8

80005574 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005574:	d4 01       	pushm	lr
80005576:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005578:	78 09       	ld.w	r9,r12[0x0]
8000557a:	58 09       	cp.w	r9,0
8000557c:	c1 10       	breq	8000559e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
8000557e:	78 3a       	ld.w	r10,r12[0xc]
80005580:	79 09       	ld.w	r9,r12[0x40]
80005582:	f4 09 00 09 	add	r9,r10,r9
80005586:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005588:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
8000558a:	14 39       	cp.w	r9,r10
8000558c:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005590:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005594:	79 0a       	ld.w	r10,r12[0x40]
80005596:	78 3b       	ld.w	r11,r12[0xc]
80005598:	10 9c       	mov	r12,r8
8000559a:	f0 1f 00 02 	mcall	800055a0 <prvCopyDataFromQueue+0x2c>
8000559e:	d8 02       	popm	pc
800055a0:	80 00       	ld.sh	r0,r0[0x0]
800055a2:	6d f0       	ld.w	r0,r6[0x7c]

800055a4 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800055a4:	eb cd 40 c0 	pushm	r6-r7,lr
800055a8:	18 97       	mov	r7,r12
800055aa:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800055ac:	78 e8       	ld.w	r8,r12[0x38]
800055ae:	58 08       	cp.w	r8,0
800055b0:	c0 31       	brne	800055b6 <xQueueReceiveFromISR+0x12>
800055b2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800055b6:	f0 1f 00 0e 	mcall	800055ec <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800055ba:	6e e8       	ld.w	r8,r7[0x38]
800055bc:	20 18       	sub	r8,1
800055be:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800055c0:	6f 18       	ld.w	r8,r7[0x44]
800055c2:	5b f8       	cp.w	r8,-1
800055c4:	c0 d1       	brne	800055de <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800055c6:	6e 48       	ld.w	r8,r7[0x10]
800055c8:	58 08       	cp.w	r8,0
800055ca:	c0 f0       	breq	800055e8 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800055cc:	ee cc ff f0 	sub	r12,r7,-16
800055d0:	f0 1f 00 08 	mcall	800055f0 <xQueueReceiveFromISR+0x4c>
800055d4:	c0 a0       	breq	800055e8 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
800055d6:	30 1c       	mov	r12,1
800055d8:	8d 0c       	st.w	r6[0x0],r12
800055da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
800055de:	2f f8       	sub	r8,-1
800055e0:	ef 48 00 44 	st.w	r7[68],r8
800055e4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800055e8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	55 74       	stdsp	sp[0x15c],r4
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	5c 04       	acr	r4

800055f4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
800055f4:	eb cd 40 c0 	pushm	r6-r7,lr
800055f8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
800055fa:	f0 1f 00 23 	mcall	80005684 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
800055fe:	6f 28       	ld.w	r8,r7[0x48]
80005600:	58 08       	cp.w	r8,0
80005602:	e0 8a 00 18 	brle	80005632 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005606:	6e 98       	ld.w	r8,r7[0x24]
80005608:	58 08       	cp.w	r8,0
8000560a:	c1 40       	breq	80005632 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000560c:	ee c6 ff dc 	sub	r6,r7,-36
80005610:	c0 48       	rjmp	80005618 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005612:	6e 98       	ld.w	r8,r7[0x24]
80005614:	58 08       	cp.w	r8,0
80005616:	c0 e0       	breq	80005632 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005618:	0c 9c       	mov	r12,r6
8000561a:	f0 1f 00 1c 	mcall	80005688 <prvUnlockQueue+0x94>
8000561e:	c0 30       	breq	80005624 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005620:	f0 1f 00 1b 	mcall	8000568c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005624:	6f 28       	ld.w	r8,r7[0x48]
80005626:	20 18       	sub	r8,1
80005628:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000562c:	58 08       	cp.w	r8,0
8000562e:	fe 99 ff f2 	brgt	80005612 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005632:	3f f8       	mov	r8,-1
80005634:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005638:	f0 1f 00 16 	mcall	80005690 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8000563c:	f0 1f 00 12 	mcall	80005684 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005640:	6f 18       	ld.w	r8,r7[0x44]
80005642:	58 08       	cp.w	r8,0
80005644:	e0 8a 00 18 	brle	80005674 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005648:	6e 48       	ld.w	r8,r7[0x10]
8000564a:	58 08       	cp.w	r8,0
8000564c:	c1 40       	breq	80005674 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000564e:	ee c6 ff f0 	sub	r6,r7,-16
80005652:	c0 48       	rjmp	8000565a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005654:	6e 48       	ld.w	r8,r7[0x10]
80005656:	58 08       	cp.w	r8,0
80005658:	c0 e0       	breq	80005674 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000565a:	0c 9c       	mov	r12,r6
8000565c:	f0 1f 00 0b 	mcall	80005688 <prvUnlockQueue+0x94>
80005660:	c0 30       	breq	80005666 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005662:	f0 1f 00 0b 	mcall	8000568c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005666:	6f 18       	ld.w	r8,r7[0x44]
80005668:	20 18       	sub	r8,1
8000566a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
8000566e:	58 08       	cp.w	r8,0
80005670:	fe 99 ff f2 	brgt	80005654 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005674:	3f f8       	mov	r8,-1
80005676:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
8000567a:	f0 1f 00 06 	mcall	80005690 <prvUnlockQueue+0x9c>
}
8000567e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005682:	00 00       	add	r0,r0
80005684:	80 00       	ld.sh	r0,r0[0x0]
80005686:	52 e0       	stdsp	sp[0xb8],r0
80005688:	80 00       	ld.sh	r0,r0[0x0]
8000568a:	5c 04       	acr	r4
8000568c:	80 00       	ld.sh	r0,r0[0x0]
8000568e:	5b 10       	cp.w	r0,-15
80005690:	80 00       	ld.sh	r0,r0[0x0]
80005692:	53 ec       	stdsp	sp[0xf8],r12

80005694 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80005694:	d4 31       	pushm	r0-r7,lr
80005696:	20 5d       	sub	sp,20
80005698:	18 97       	mov	r7,r12
8000569a:	50 0b       	stdsp	sp[0x0],r11
8000569c:	50 2a       	stdsp	sp[0x8],r10
8000569e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800056a0:	f8 c2 ff dc 	sub	r2,r12,-36
800056a4:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800056a6:	fa c4 ff f4 	sub	r4,sp,-12
800056aa:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800056ac:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800056ae:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800056b2:	f0 1f 00 3e 	mcall	800057a8 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800056b6:	6e e8       	ld.w	r8,r7[0x38]
800056b8:	58 08       	cp.w	r8,0
800056ba:	c2 a0       	breq	8000570e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800056bc:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800056be:	40 0b       	lddsp	r11,sp[0x0]
800056c0:	0e 9c       	mov	r12,r7
800056c2:	f0 1f 00 3b 	mcall	800057ac <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800056c6:	40 18       	lddsp	r8,sp[0x4]
800056c8:	58 08       	cp.w	r8,0
800056ca:	c1 51       	brne	800056f4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800056cc:	6e e8       	ld.w	r8,r7[0x38]
800056ce:	20 18       	sub	r8,1
800056d0:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800056d2:	6e 08       	ld.w	r8,r7[0x0]
800056d4:	58 08       	cp.w	r8,0
800056d6:	c0 41       	brne	800056de <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800056d8:	f0 1f 00 36 	mcall	800057b0 <xQueueGenericReceive+0x11c>
800056dc:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800056de:	6e 48       	ld.w	r8,r7[0x10]
800056e0:	58 08       	cp.w	r8,0
800056e2:	c1 20       	breq	80005706 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800056e4:	ee cc ff f0 	sub	r12,r7,-16
800056e8:	f0 1f 00 33 	mcall	800057b4 <xQueueGenericReceive+0x120>
800056ec:	58 1c       	cp.w	r12,1
800056ee:	c0 c1       	brne	80005706 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
800056f0:	d7 33       	scall
800056f2:	c0 a8       	rjmp	80005706 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800056f4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800056f6:	6e 98       	ld.w	r8,r7[0x24]
800056f8:	58 08       	cp.w	r8,0
800056fa:	c0 60       	breq	80005706 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800056fc:	04 9c       	mov	r12,r2
800056fe:	f0 1f 00 2e 	mcall	800057b4 <xQueueGenericReceive+0x120>
80005702:	c0 20       	breq	80005706 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80005704:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80005706:	f0 1f 00 2d 	mcall	800057b8 <xQueueGenericReceive+0x124>
8000570a:	30 1c       	mov	r12,1
				return pdPASS;
8000570c:	c4 c8       	rjmp	800057a4 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000570e:	40 28       	lddsp	r8,sp[0x8]
80005710:	58 08       	cp.w	r8,0
80005712:	c0 51       	brne	8000571c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005714:	f0 1f 00 29 	mcall	800057b8 <xQueueGenericReceive+0x124>
80005718:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000571a:	c4 58       	rjmp	800057a4 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000571c:	58 05       	cp.w	r5,0
8000571e:	c0 51       	brne	80005728 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005720:	08 9c       	mov	r12,r4
80005722:	f0 1f 00 27 	mcall	800057bc <xQueueGenericReceive+0x128>
80005726:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005728:	f0 1f 00 24 	mcall	800057b8 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000572c:	f0 1f 00 25 	mcall	800057c0 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005730:	f0 1f 00 1e 	mcall	800057a8 <xQueueGenericReceive+0x114>
80005734:	6f 18       	ld.w	r8,r7[0x44]
80005736:	5b f8       	cp.w	r8,-1
80005738:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000573c:	6f 28       	ld.w	r8,r7[0x48]
8000573e:	5b f8       	cp.w	r8,-1
80005740:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005744:	f0 1f 00 1d 	mcall	800057b8 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005748:	06 9b       	mov	r11,r3
8000574a:	08 9c       	mov	r12,r4
8000574c:	f0 1f 00 1e 	mcall	800057c4 <xQueueGenericReceive+0x130>
80005750:	c2 41       	brne	80005798 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005752:	f0 1f 00 16 	mcall	800057a8 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005756:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005758:	f0 1f 00 18 	mcall	800057b8 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000575c:	58 06       	cp.w	r6,0
8000575e:	c1 71       	brne	8000578c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005760:	6e 08       	ld.w	r8,r7[0x0]
80005762:	58 08       	cp.w	r8,0
80005764:	c0 81       	brne	80005774 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005766:	f0 1f 00 11 	mcall	800057a8 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000576a:	6e 1c       	ld.w	r12,r7[0x4]
8000576c:	f0 1f 00 17 	mcall	800057c8 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005770:	f0 1f 00 12 	mcall	800057b8 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005774:	40 2b       	lddsp	r11,sp[0x8]
80005776:	04 9c       	mov	r12,r2
80005778:	f0 1f 00 15 	mcall	800057cc <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000577c:	0e 9c       	mov	r12,r7
8000577e:	f0 1f 00 15 	mcall	800057d0 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005782:	f0 1f 00 15 	mcall	800057d4 <xQueueGenericReceive+0x140>
80005786:	c9 61       	brne	800056b2 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005788:	d7 33       	scall
8000578a:	c9 4b       	rjmp	800056b2 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000578c:	0e 9c       	mov	r12,r7
8000578e:	f0 1f 00 11 	mcall	800057d0 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005792:	f0 1f 00 11 	mcall	800057d4 <xQueueGenericReceive+0x140>
80005796:	c8 eb       	rjmp	800056b2 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005798:	0e 9c       	mov	r12,r7
8000579a:	f0 1f 00 0e 	mcall	800057d0 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000579e:	f0 1f 00 0e 	mcall	800057d4 <xQueueGenericReceive+0x140>
800057a2:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800057a4:	2f bd       	sub	sp,-20
800057a6:	d8 32       	popm	r0-r7,pc
800057a8:	80 00       	ld.sh	r0,r0[0x0]
800057aa:	52 e0       	stdsp	sp[0xb8],r0
800057ac:	80 00       	ld.sh	r0,r0[0x0]
800057ae:	55 74       	stdsp	sp[0x15c],r4
800057b0:	80 00       	ld.sh	r0,r0[0x0]
800057b2:	5b 1c       	cp.w	r12,-15
800057b4:	80 00       	ld.sh	r0,r0[0x0]
800057b6:	5c 04       	acr	r4
800057b8:	80 00       	ld.sh	r0,r0[0x0]
800057ba:	53 ec       	stdsp	sp[0xf8],r12
800057bc:	80 00       	ld.sh	r0,r0[0x0]
800057be:	5a f8       	cp.w	r8,-17
800057c0:	80 00       	ld.sh	r0,r0[0x0]
800057c2:	5a 6c       	cp.w	r12,-26
800057c4:	80 00       	ld.sh	r0,r0[0x0]
800057c6:	5d 94       	*unknown*
800057c8:	80 00       	ld.sh	r0,r0[0x0]
800057ca:	5b 80       	cp.w	r0,-8
800057cc:	80 00       	ld.sh	r0,r0[0x0]
800057ce:	5f ec       	srqs	r12
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	55 f4       	stdsp	sp[0x17c],r4
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	5e 28       	reths	r8

800057d8 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800057d8:	eb cd 40 80 	pushm	r7,lr
800057dc:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800057de:	79 08       	ld.w	r8,r12[0x40]
800057e0:	58 08       	cp.w	r8,0
800057e2:	c0 a1       	brne	800057f6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800057e4:	78 08       	ld.w	r8,r12[0x0]
800057e6:	58 08       	cp.w	r8,0
800057e8:	c2 b1       	brne	8000583e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800057ea:	78 1c       	ld.w	r12,r12[0x4]
800057ec:	f0 1f 00 17 	mcall	80005848 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800057f0:	30 08       	mov	r8,0
800057f2:	8f 18       	st.w	r7[0x4],r8
800057f4:	c2 58       	rjmp	8000583e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800057f6:	58 0a       	cp.w	r10,0
800057f8:	c1 01       	brne	80005818 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800057fa:	10 9a       	mov	r10,r8
800057fc:	78 2c       	ld.w	r12,r12[0x8]
800057fe:	f0 1f 00 14 	mcall	8000584c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005802:	6e 29       	ld.w	r9,r7[0x8]
80005804:	6f 08       	ld.w	r8,r7[0x40]
80005806:	f2 08 00 08 	add	r8,r9,r8
8000580a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000580c:	6e 19       	ld.w	r9,r7[0x4]
8000580e:	12 38       	cp.w	r8,r9
80005810:	c1 73       	brcs	8000583e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005812:	6e 08       	ld.w	r8,r7[0x0]
80005814:	8f 28       	st.w	r7[0x8],r8
80005816:	c1 48       	rjmp	8000583e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005818:	10 9a       	mov	r10,r8
8000581a:	78 3c       	ld.w	r12,r12[0xc]
8000581c:	f0 1f 00 0c 	mcall	8000584c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005820:	6f 08       	ld.w	r8,r7[0x40]
80005822:	6e 39       	ld.w	r9,r7[0xc]
80005824:	f2 08 01 08 	sub	r8,r9,r8
80005828:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000582a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000582c:	12 38       	cp.w	r8,r9
8000582e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005832:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005836:	f3 d8 e3 19 	subcs	r9,r9,r8
8000583a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000583e:	6e e8       	ld.w	r8,r7[0x38]
80005840:	2f f8       	sub	r8,-1
80005842:	8f e8       	st.w	r7[0x38],r8
}
80005844:	e3 cd 80 80 	ldm	sp++,r7,pc
80005848:	80 00       	ld.sh	r0,r0[0x0]
8000584a:	5b 28       	cp.w	r8,-14
8000584c:	80 00       	ld.sh	r0,r0[0x0]
8000584e:	6d f0       	ld.w	r0,r6[0x7c]

80005850 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80005850:	eb cd 40 c0 	pushm	r6-r7,lr
80005854:	18 97       	mov	r7,r12
80005856:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005858:	78 ec       	ld.w	r12,r12[0x38]
8000585a:	6e f8       	ld.w	r8,r7[0x3c]
8000585c:	10 3c       	cp.w	r12,r8
8000585e:	c0 33       	brcs	80005864 <xQueueGenericSendFromISR+0x14>
80005860:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005864:	12 9a       	mov	r10,r9
80005866:	0e 9c       	mov	r12,r7
80005868:	f0 1f 00 0c 	mcall	80005898 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
8000586c:	6f 28       	ld.w	r8,r7[0x48]
8000586e:	5b f8       	cp.w	r8,-1
80005870:	c0 d1       	brne	8000588a <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005872:	6e 98       	ld.w	r8,r7[0x24]
80005874:	58 08       	cp.w	r8,0
80005876:	c0 f0       	breq	80005894 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005878:	ee cc ff dc 	sub	r12,r7,-36
8000587c:	f0 1f 00 08 	mcall	8000589c <xQueueGenericSendFromISR+0x4c>
80005880:	c0 a0       	breq	80005894 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80005882:	30 1c       	mov	r12,1
80005884:	8d 0c       	st.w	r6[0x0],r12
80005886:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
8000588a:	2f f8       	sub	r8,-1
8000588c:	ef 48 00 48 	st.w	r7[72],r8
80005890:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005894:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005898:	80 00       	ld.sh	r0,r0[0x0]
8000589a:	57 d8       	stdsp	sp[0x1f4],r8
8000589c:	80 00       	ld.sh	r0,r0[0x0]
8000589e:	5c 04       	acr	r4

800058a0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800058a0:	d4 31       	pushm	r0-r7,lr
800058a2:	20 5d       	sub	sp,20
800058a4:	18 97       	mov	r7,r12
800058a6:	50 0b       	stdsp	sp[0x0],r11
800058a8:	50 2a       	stdsp	sp[0x8],r10
800058aa:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800058ac:	f8 c0 ff f0 	sub	r0,r12,-16
800058b0:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800058b2:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800058b6:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800058b8:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800058bc:	f0 1f 00 2f 	mcall	80005978 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800058c0:	6e e9       	ld.w	r9,r7[0x38]
800058c2:	6e f8       	ld.w	r8,r7[0x3c]
800058c4:	10 39       	cp.w	r9,r8
800058c6:	c1 42       	brcc	800058ee <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800058c8:	40 1a       	lddsp	r10,sp[0x4]
800058ca:	40 0b       	lddsp	r11,sp[0x0]
800058cc:	0e 9c       	mov	r12,r7
800058ce:	f0 1f 00 2c 	mcall	8000597c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800058d2:	6e 98       	ld.w	r8,r7[0x24]
800058d4:	58 08       	cp.w	r8,0
800058d6:	c0 80       	breq	800058e6 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800058d8:	ee cc ff dc 	sub	r12,r7,-36
800058dc:	f0 1f 00 29 	mcall	80005980 <xQueueGenericSend+0xe0>
800058e0:	58 1c       	cp.w	r12,1
800058e2:	c0 21       	brne	800058e6 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
800058e4:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
800058e6:	f0 1f 00 28 	mcall	80005984 <xQueueGenericSend+0xe4>
800058ea:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
800058ec:	c4 38       	rjmp	80005972 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
800058ee:	40 28       	lddsp	r8,sp[0x8]
800058f0:	58 08       	cp.w	r8,0
800058f2:	c0 51       	brne	800058fc <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
800058f4:	f0 1f 00 24 	mcall	80005984 <xQueueGenericSend+0xe4>
800058f8:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
800058fa:	c3 c8       	rjmp	80005972 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
800058fc:	58 04       	cp.w	r4,0
800058fe:	c0 51       	brne	80005908 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005900:	06 9c       	mov	r12,r3
80005902:	f0 1f 00 22 	mcall	80005988 <xQueueGenericSend+0xe8>
80005906:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005908:	f0 1f 00 1f 	mcall	80005984 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000590c:	f0 1f 00 20 	mcall	8000598c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80005910:	f0 1f 00 1a 	mcall	80005978 <xQueueGenericSend+0xd8>
80005914:	6f 18       	ld.w	r8,r7[0x44]
80005916:	5b f8       	cp.w	r8,-1
80005918:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000591c:	6f 28       	ld.w	r8,r7[0x48]
8000591e:	5b f8       	cp.w	r8,-1
80005920:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005924:	f0 1f 00 18 	mcall	80005984 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005928:	04 9b       	mov	r11,r2
8000592a:	06 9c       	mov	r12,r3
8000592c:	f0 1f 00 19 	mcall	80005990 <xQueueGenericSend+0xf0>
80005930:	c1 b1       	brne	80005966 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005932:	f0 1f 00 12 	mcall	80005978 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80005936:	6e e5       	ld.w	r5,r7[0x38]
80005938:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
8000593a:	f0 1f 00 13 	mcall	80005984 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
8000593e:	0c 35       	cp.w	r5,r6
80005940:	c0 d1       	brne	8000595a <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005942:	40 2b       	lddsp	r11,sp[0x8]
80005944:	00 9c       	mov	r12,r0
80005946:	f0 1f 00 14 	mcall	80005994 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
8000594a:	0e 9c       	mov	r12,r7
8000594c:	f0 1f 00 13 	mcall	80005998 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005950:	f0 1f 00 13 	mcall	8000599c <xQueueGenericSend+0xfc>
80005954:	cb 41       	brne	800058bc <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
80005956:	d7 33       	scall
80005958:	cb 2b       	rjmp	800058bc <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000595a:	0e 9c       	mov	r12,r7
8000595c:	f0 1f 00 0f 	mcall	80005998 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005960:	f0 1f 00 0f 	mcall	8000599c <xQueueGenericSend+0xfc>
80005964:	ca cb       	rjmp	800058bc <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80005966:	0e 9c       	mov	r12,r7
80005968:	f0 1f 00 0c 	mcall	80005998 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
8000596c:	f0 1f 00 0c 	mcall	8000599c <xQueueGenericSend+0xfc>
80005970:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005972:	2f bd       	sub	sp,-20
80005974:	d8 32       	popm	r0-r7,pc
80005976:	00 00       	add	r0,r0
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	52 e0       	stdsp	sp[0xb8],r0
8000597c:	80 00       	ld.sh	r0,r0[0x0]
8000597e:	57 d8       	stdsp	sp[0x1f4],r8
80005980:	80 00       	ld.sh	r0,r0[0x0]
80005982:	5c 04       	acr	r4
80005984:	80 00       	ld.sh	r0,r0[0x0]
80005986:	53 ec       	stdsp	sp[0xf8],r12
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	5a f8       	cp.w	r8,-17
8000598c:	80 00       	ld.sh	r0,r0[0x0]
8000598e:	5a 6c       	cp.w	r12,-26
80005990:	80 00       	ld.sh	r0,r0[0x0]
80005992:	5d 94       	*unknown*
80005994:	80 00       	ld.sh	r0,r0[0x0]
80005996:	5f ec       	srqs	r12
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	55 f4       	stdsp	sp[0x17c],r4
8000599c:	80 00       	ld.sh	r0,r0[0x0]
8000599e:	5e 28       	reths	r8

800059a0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800059a0:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800059a4:	34 cc       	mov	r12,76
800059a6:	f0 1f 00 12 	mcall	800059ec <xQueueCreateMutex+0x4c>
800059aa:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800059ac:	c1 d0       	breq	800059e6 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800059ae:	30 06       	mov	r6,0
800059b0:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800059b2:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800059b4:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800059b6:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800059b8:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800059ba:	30 18       	mov	r8,1
800059bc:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800059be:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800059c2:	3f f8       	mov	r8,-1
800059c4:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
800059c8:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800059cc:	2f 0c       	sub	r12,-16
800059ce:	f0 1f 00 09 	mcall	800059f0 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800059d2:	ee cc ff dc 	sub	r12,r7,-36
800059d6:	f0 1f 00 07 	mcall	800059f0 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
800059da:	0c 99       	mov	r9,r6
800059dc:	0c 9a       	mov	r10,r6
800059de:	0c 9b       	mov	r11,r6
800059e0:	0e 9c       	mov	r12,r7
800059e2:	f0 1f 00 05 	mcall	800059f4 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
800059e6:	0e 9c       	mov	r12,r7
800059e8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	55 4c       	stdsp	sp[0x150],r12
800059f0:	80 00       	ld.sh	r0,r0[0x0]
800059f2:	51 bc       	stdsp	sp[0x6c],r12
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	58 a0       	cp.w	r0,10

800059f8 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800059f8:	d4 21       	pushm	r4-r7,lr
800059fa:	18 97       	mov	r7,r12
800059fc:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800059fe:	58 0c       	cp.w	r12,0
80005a00:	c2 f0       	breq	80005a5e <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005a02:	34 cc       	mov	r12,76
80005a04:	f0 1f 00 17 	mcall	80005a60 <xQueueCreate+0x68>
80005a08:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80005a0a:	c2 a0       	breq	80005a5e <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80005a0c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80005a10:	e8 cc ff ff 	sub	r12,r4,-1
80005a14:	f0 1f 00 13 	mcall	80005a60 <xQueueCreate+0x68>
80005a18:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80005a1a:	c1 e0       	breq	80005a56 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80005a1c:	f8 04 00 04 	add	r4,r12,r4
80005a20:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005a22:	30 08       	mov	r8,0
80005a24:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005a26:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80005a28:	ee c8 00 01 	sub	r8,r7,1
80005a2c:	ad 38       	mul	r8,r6
80005a2e:	10 0c       	add	r12,r8
80005a30:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80005a32:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80005a34:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80005a38:	3f f8       	mov	r8,-1
80005a3a:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80005a3e:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005a42:	ea cc ff f0 	sub	r12,r5,-16
80005a46:	f0 1f 00 08 	mcall	80005a64 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005a4a:	ea cc ff dc 	sub	r12,r5,-36
80005a4e:	f0 1f 00 06 	mcall	80005a64 <xQueueCreate+0x6c>
80005a52:	0a 9c       	mov	r12,r5
80005a54:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
80005a56:	0a 9c       	mov	r12,r5
80005a58:	f0 1f 00 04 	mcall	80005a68 <xQueueCreate+0x70>
80005a5c:	d8 2a       	popm	r4-r7,pc,r12=0
80005a5e:	d8 2a       	popm	r4-r7,pc,r12=0
80005a60:	80 00       	ld.sh	r0,r0[0x0]
80005a62:	55 4c       	stdsp	sp[0x150],r12
80005a64:	80 00       	ld.sh	r0,r0[0x0]
80005a66:	51 bc       	stdsp	sp[0x6c],r12
80005a68:	80 00       	ld.sh	r0,r0[0x0]
80005a6a:	55 24       	stdsp	sp[0x148],r4

80005a6c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005a6c:	48 38       	lddpc	r8,80005a78 <vTaskSuspendAll+0xc>
80005a6e:	70 09       	ld.w	r9,r8[0x0]
80005a70:	2f f9       	sub	r9,-1
80005a72:	91 09       	st.w	r8[0x0],r9
}
80005a74:	5e fc       	retal	r12
80005a76:	00 00       	add	r0,r0
80005a78:	00 00       	add	r0,r0
80005a7a:	0d 30       	ld.ub	r0,r6++

80005a7c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005a7c:	49 a8       	lddpc	r8,80005ae4 <vTaskSwitchContext+0x68>
80005a7e:	70 08       	ld.w	r8,r8[0x0]
80005a80:	58 08       	cp.w	r8,0
80005a82:	c0 b1       	brne	80005a98 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005a84:	49 98       	lddpc	r8,80005ae8 <vTaskSwitchContext+0x6c>
80005a86:	70 08       	ld.w	r8,r8[0x0]
80005a88:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005a8c:	49 89       	lddpc	r9,80005aec <vTaskSwitchContext+0x70>
80005a8e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005a92:	58 08       	cp.w	r8,0
80005a94:	c0 60       	breq	80005aa0 <vTaskSwitchContext+0x24>
80005a96:	c1 18       	rjmp	80005ab8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005a98:	30 19       	mov	r9,1
80005a9a:	49 68       	lddpc	r8,80005af0 <vTaskSwitchContext+0x74>
80005a9c:	91 09       	st.w	r8[0x0],r9
80005a9e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005aa0:	49 28       	lddpc	r8,80005ae8 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005aa2:	49 3a       	lddpc	r10,80005aec <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005aa4:	70 09       	ld.w	r9,r8[0x0]
80005aa6:	20 19       	sub	r9,1
80005aa8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005aaa:	70 09       	ld.w	r9,r8[0x0]
80005aac:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005ab0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005ab4:	58 09       	cp.w	r9,0
80005ab6:	cf 70       	breq	80005aa4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005ab8:	48 c8       	lddpc	r8,80005ae8 <vTaskSwitchContext+0x6c>
80005aba:	70 08       	ld.w	r8,r8[0x0]
80005abc:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005ac0:	48 b9       	lddpc	r9,80005aec <vTaskSwitchContext+0x70>
80005ac2:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005ac6:	70 19       	ld.w	r9,r8[0x4]
80005ac8:	72 19       	ld.w	r9,r9[0x4]
80005aca:	91 19       	st.w	r8[0x4],r9
80005acc:	f0 ca ff f8 	sub	r10,r8,-8
80005ad0:	14 39       	cp.w	r9,r10
80005ad2:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005ad6:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005ada:	70 18       	ld.w	r8,r8[0x4]
80005adc:	70 39       	ld.w	r9,r8[0xc]
80005ade:	48 68       	lddpc	r8,80005af4 <vTaskSwitchContext+0x78>
80005ae0:	91 09       	st.w	r8[0x0],r9
80005ae2:	5e fc       	retal	r12
80005ae4:	00 00       	add	r0,r0
80005ae6:	0d 30       	ld.ub	r0,r6++
80005ae8:	00 00       	add	r0,r0
80005aea:	0d 68       	ld.uh	r8,--r6
80005aec:	00 00       	add	r0,r0
80005aee:	0c 4c       	or	r12,r6
80005af0:	00 00       	add	r0,r0
80005af2:	0d 50       	ld.sh	r0,--r6
80005af4:	00 00       	add	r0,r0
80005af6:	0d 00       	ld.w	r0,r6++

80005af8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005af8:	48 48       	lddpc	r8,80005b08 <vTaskSetTimeOutState+0x10>
80005afa:	70 08       	ld.w	r8,r8[0x0]
80005afc:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005afe:	48 48       	lddpc	r8,80005b0c <vTaskSetTimeOutState+0x14>
80005b00:	70 08       	ld.w	r8,r8[0x0]
80005b02:	99 18       	st.w	r12[0x4],r8
}
80005b04:	5e fc       	retal	r12
80005b06:	00 00       	add	r0,r0
80005b08:	00 00       	add	r0,r0
80005b0a:	0c 44       	or	r4,r6
80005b0c:	00 00       	add	r0,r0
80005b0e:	0d 2c       	ld.uh	r12,r6++

80005b10 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005b10:	30 19       	mov	r9,1
80005b12:	48 28       	lddpc	r8,80005b18 <vTaskMissedYield+0x8>
80005b14:	91 09       	st.w	r8[0x0],r9
}
80005b16:	5e fc       	retal	r12
80005b18:	00 00       	add	r0,r0
80005b1a:	0d 50       	ld.sh	r0,--r6

80005b1c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80005b1c:	48 28       	lddpc	r8,80005b24 <xTaskGetCurrentTaskHandle+0x8>
80005b1e:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80005b20:	5e fc       	retal	r12
80005b22:	00 00       	add	r0,r0
80005b24:	00 00       	add	r0,r0
80005b26:	0d 00       	ld.w	r0,r6++

80005b28 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005b28:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005b2c:	58 0c       	cp.w	r12,0
80005b2e:	c1 f0       	breq	80005b6c <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005b30:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80005b32:	78 b9       	ld.w	r9,r12[0x2c]
80005b34:	79 18       	ld.w	r8,r12[0x44]
80005b36:	10 39       	cp.w	r9,r8
80005b38:	c1 a0       	breq	80005b6c <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005b3a:	f8 c6 ff fc 	sub	r6,r12,-4
80005b3e:	0c 9c       	mov	r12,r6
80005b40:	f0 1f 00 0c 	mcall	80005b70 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80005b44:	6f 1c       	ld.w	r12,r7[0x44]
80005b46:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005b48:	f8 08 11 08 	rsub	r8,r12,8
80005b4c:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005b4e:	48 a8       	lddpc	r8,80005b74 <vTaskPriorityDisinherit+0x4c>
80005b50:	70 08       	ld.w	r8,r8[0x0]
80005b52:	10 3c       	cp.w	r12,r8
80005b54:	e0 88 00 04 	brls	80005b5c <vTaskPriorityDisinherit+0x34>
80005b58:	48 78       	lddpc	r8,80005b74 <vTaskPriorityDisinherit+0x4c>
80005b5a:	91 0c       	st.w	r8[0x0],r12
80005b5c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005b60:	0c 9b       	mov	r11,r6
80005b62:	48 68       	lddpc	r8,80005b78 <vTaskPriorityDisinherit+0x50>
80005b64:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005b68:	f0 1f 00 05 	mcall	80005b7c <vTaskPriorityDisinherit+0x54>
80005b6c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b70:	80 00       	ld.sh	r0,r0[0x0]
80005b72:	52 26       	stdsp	sp[0x88],r6
80005b74:	00 00       	add	r0,r0
80005b76:	0d 68       	ld.uh	r8,--r6
80005b78:	00 00       	add	r0,r0
80005b7a:	0c 4c       	or	r12,r6
80005b7c:	80 00       	ld.sh	r0,r0[0x0]
80005b7e:	51 d6       	stdsp	sp[0x74],r6

80005b80 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005b80:	eb cd 40 c0 	pushm	r6-r7,lr
80005b84:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005b86:	49 b8       	lddpc	r8,80005bf0 <vTaskPriorityInherit+0x70>
80005b88:	70 08       	ld.w	r8,r8[0x0]
80005b8a:	78 b9       	ld.w	r9,r12[0x2c]
80005b8c:	70 b8       	ld.w	r8,r8[0x2c]
80005b8e:	10 39       	cp.w	r9,r8
80005b90:	c2 d2       	brcc	80005bea <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005b92:	49 88       	lddpc	r8,80005bf0 <vTaskPriorityInherit+0x70>
80005b94:	70 08       	ld.w	r8,r8[0x0]
80005b96:	70 b8       	ld.w	r8,r8[0x2c]
80005b98:	f0 08 11 08 	rsub	r8,r8,8
80005b9c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005b9e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005ba2:	49 59       	lddpc	r9,80005bf4 <vTaskPriorityInherit+0x74>
80005ba4:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005ba8:	78 59       	ld.w	r9,r12[0x14]
80005baa:	10 39       	cp.w	r9,r8
80005bac:	c1 b1       	brne	80005be2 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005bae:	f8 c6 ff fc 	sub	r6,r12,-4
80005bb2:	0c 9c       	mov	r12,r6
80005bb4:	f0 1f 00 11 	mcall	80005bf8 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005bb8:	48 e8       	lddpc	r8,80005bf0 <vTaskPriorityInherit+0x70>
80005bba:	70 08       	ld.w	r8,r8[0x0]
80005bbc:	70 bc       	ld.w	r12,r8[0x2c]
80005bbe:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005bc0:	48 f8       	lddpc	r8,80005bfc <vTaskPriorityInherit+0x7c>
80005bc2:	70 08       	ld.w	r8,r8[0x0]
80005bc4:	10 3c       	cp.w	r12,r8
80005bc6:	e0 88 00 04 	brls	80005bce <vTaskPriorityInherit+0x4e>
80005bca:	48 d8       	lddpc	r8,80005bfc <vTaskPriorityInherit+0x7c>
80005bcc:	91 0c       	st.w	r8[0x0],r12
80005bce:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005bd2:	0c 9b       	mov	r11,r6
80005bd4:	48 88       	lddpc	r8,80005bf4 <vTaskPriorityInherit+0x74>
80005bd6:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005bda:	f0 1f 00 0a 	mcall	80005c00 <vTaskPriorityInherit+0x80>
80005bde:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005be2:	48 48       	lddpc	r8,80005bf0 <vTaskPriorityInherit+0x70>
80005be4:	70 08       	ld.w	r8,r8[0x0]
80005be6:	70 b8       	ld.w	r8,r8[0x2c]
80005be8:	99 b8       	st.w	r12[0x2c],r8
80005bea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bee:	00 00       	add	r0,r0
80005bf0:	00 00       	add	r0,r0
80005bf2:	0d 00       	ld.w	r0,r6++
80005bf4:	00 00       	add	r0,r0
80005bf6:	0c 4c       	or	r12,r6
80005bf8:	80 00       	ld.sh	r0,r0[0x0]
80005bfa:	52 26       	stdsp	sp[0x88],r6
80005bfc:	00 00       	add	r0,r0
80005bfe:	0d 68       	ld.uh	r8,--r6
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	51 d6       	stdsp	sp[0x74],r6

80005c04 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005c04:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005c08:	78 38       	ld.w	r8,r12[0xc]
80005c0a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005c0c:	ee c6 ff e8 	sub	r6,r7,-24
80005c10:	0c 9c       	mov	r12,r6
80005c12:	f0 1f 00 15 	mcall	80005c64 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005c16:	49 58       	lddpc	r8,80005c68 <xTaskRemoveFromEventList+0x64>
80005c18:	70 08       	ld.w	r8,r8[0x0]
80005c1a:	58 08       	cp.w	r8,0
80005c1c:	c1 71       	brne	80005c4a <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005c1e:	ee c6 ff fc 	sub	r6,r7,-4
80005c22:	0c 9c       	mov	r12,r6
80005c24:	f0 1f 00 10 	mcall	80005c64 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005c28:	6e bc       	ld.w	r12,r7[0x2c]
80005c2a:	49 18       	lddpc	r8,80005c6c <xTaskRemoveFromEventList+0x68>
80005c2c:	70 08       	ld.w	r8,r8[0x0]
80005c2e:	10 3c       	cp.w	r12,r8
80005c30:	e0 88 00 04 	brls	80005c38 <xTaskRemoveFromEventList+0x34>
80005c34:	48 e8       	lddpc	r8,80005c6c <xTaskRemoveFromEventList+0x68>
80005c36:	91 0c       	st.w	r8[0x0],r12
80005c38:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005c3c:	0c 9b       	mov	r11,r6
80005c3e:	48 d8       	lddpc	r8,80005c70 <xTaskRemoveFromEventList+0x6c>
80005c40:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005c44:	f0 1f 00 0c 	mcall	80005c74 <xTaskRemoveFromEventList+0x70>
80005c48:	c0 58       	rjmp	80005c52 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005c4a:	0c 9b       	mov	r11,r6
80005c4c:	48 bc       	lddpc	r12,80005c78 <xTaskRemoveFromEventList+0x74>
80005c4e:	f0 1f 00 0a 	mcall	80005c74 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c52:	48 b8       	lddpc	r8,80005c7c <xTaskRemoveFromEventList+0x78>
80005c54:	70 08       	ld.w	r8,r8[0x0]
80005c56:	6e b9       	ld.w	r9,r7[0x2c]
80005c58:	70 b8       	ld.w	r8,r8[0x2c]
80005c5a:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005c5c:	5f 2c       	srhs	r12
80005c5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c62:	00 00       	add	r0,r0
80005c64:	80 00       	ld.sh	r0,r0[0x0]
80005c66:	52 26       	stdsp	sp[0x88],r6
80005c68:	00 00       	add	r0,r0
80005c6a:	0d 30       	ld.ub	r0,r6++
80005c6c:	00 00       	add	r0,r0
80005c6e:	0d 68       	ld.uh	r8,--r6
80005c70:	00 00       	add	r0,r0
80005c72:	0c 4c       	or	r12,r6
80005c74:	80 00       	ld.sh	r0,r0[0x0]
80005c76:	51 d6       	stdsp	sp[0x74],r6
80005c78:	00 00       	add	r0,r0
80005c7a:	0d 04       	ld.w	r4,r6++
80005c7c:	00 00       	add	r0,r0
80005c7e:	0d 00       	ld.w	r0,r6++

80005c80 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005c80:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005c84:	4b 98       	lddpc	r8,80005d68 <vTaskIncrementTick+0xe8>
80005c86:	70 08       	ld.w	r8,r8[0x0]
80005c88:	58 08       	cp.w	r8,0
80005c8a:	c6 91       	brne	80005d5c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005c8c:	4b 88       	lddpc	r8,80005d6c <vTaskIncrementTick+0xec>
80005c8e:	70 09       	ld.w	r9,r8[0x0]
80005c90:	2f f9       	sub	r9,-1
80005c92:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005c94:	70 08       	ld.w	r8,r8[0x0]
80005c96:	58 08       	cp.w	r8,0
80005c98:	c1 a1       	brne	80005ccc <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005c9a:	4b 68       	lddpc	r8,80005d70 <vTaskIncrementTick+0xf0>
80005c9c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005c9e:	4b 69       	lddpc	r9,80005d74 <vTaskIncrementTick+0xf4>
80005ca0:	72 0b       	ld.w	r11,r9[0x0]
80005ca2:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005ca4:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005ca6:	4b 59       	lddpc	r9,80005d78 <vTaskIncrementTick+0xf8>
80005ca8:	72 0a       	ld.w	r10,r9[0x0]
80005caa:	2f fa       	sub	r10,-1
80005cac:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005cae:	70 08       	ld.w	r8,r8[0x0]
80005cb0:	70 08       	ld.w	r8,r8[0x0]
80005cb2:	58 08       	cp.w	r8,0
80005cb4:	c0 51       	brne	80005cbe <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005cb6:	3f f9       	mov	r9,-1
80005cb8:	4b 18       	lddpc	r8,80005d7c <vTaskIncrementTick+0xfc>
80005cba:	91 09       	st.w	r8[0x0],r9
80005cbc:	c0 88       	rjmp	80005ccc <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005cbe:	4a d8       	lddpc	r8,80005d70 <vTaskIncrementTick+0xf0>
80005cc0:	70 08       	ld.w	r8,r8[0x0]
80005cc2:	70 38       	ld.w	r8,r8[0xc]
80005cc4:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005cc6:	70 19       	ld.w	r9,r8[0x4]
80005cc8:	4a d8       	lddpc	r8,80005d7c <vTaskIncrementTick+0xfc>
80005cca:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005ccc:	4a 88       	lddpc	r8,80005d6c <vTaskIncrementTick+0xec>
80005cce:	70 09       	ld.w	r9,r8[0x0]
80005cd0:	4a b8       	lddpc	r8,80005d7c <vTaskIncrementTick+0xfc>
80005cd2:	70 08       	ld.w	r8,r8[0x0]
80005cd4:	10 39       	cp.w	r9,r8
80005cd6:	c4 73       	brcs	80005d64 <vTaskIncrementTick+0xe4>
80005cd8:	4a 68       	lddpc	r8,80005d70 <vTaskIncrementTick+0xf0>
80005cda:	70 08       	ld.w	r8,r8[0x0]
80005cdc:	70 08       	ld.w	r8,r8[0x0]
80005cde:	58 08       	cp.w	r8,0
80005ce0:	c0 c0       	breq	80005cf8 <vTaskIncrementTick+0x78>
80005ce2:	4a 48       	lddpc	r8,80005d70 <vTaskIncrementTick+0xf0>
80005ce4:	70 08       	ld.w	r8,r8[0x0]
80005ce6:	70 38       	ld.w	r8,r8[0xc]
80005ce8:	70 37       	ld.w	r7,r8[0xc]
80005cea:	6e 18       	ld.w	r8,r7[0x4]
80005cec:	4a 09       	lddpc	r9,80005d6c <vTaskIncrementTick+0xec>
80005cee:	72 09       	ld.w	r9,r9[0x0]
80005cf0:	12 38       	cp.w	r8,r9
80005cf2:	e0 88 00 14 	brls	80005d1a <vTaskIncrementTick+0x9a>
80005cf6:	c0 e8       	rjmp	80005d12 <vTaskIncrementTick+0x92>
80005cf8:	3f f9       	mov	r9,-1
80005cfa:	4a 18       	lddpc	r8,80005d7c <vTaskIncrementTick+0xfc>
80005cfc:	91 09       	st.w	r8[0x0],r9
80005cfe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005d02:	6a 08       	ld.w	r8,r5[0x0]
80005d04:	70 38       	ld.w	r8,r8[0xc]
80005d06:	70 37       	ld.w	r7,r8[0xc]
80005d08:	6e 18       	ld.w	r8,r7[0x4]
80005d0a:	64 09       	ld.w	r9,r2[0x0]
80005d0c:	12 38       	cp.w	r8,r9
80005d0e:	e0 88 00 0a 	brls	80005d22 <vTaskIncrementTick+0xa2>
80005d12:	49 b9       	lddpc	r9,80005d7c <vTaskIncrementTick+0xfc>
80005d14:	93 08       	st.w	r9[0x0],r8
80005d16:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005d1a:	49 a4       	lddpc	r4,80005d80 <vTaskIncrementTick+0x100>
80005d1c:	49 a3       	lddpc	r3,80005d84 <vTaskIncrementTick+0x104>
80005d1e:	49 55       	lddpc	r5,80005d70 <vTaskIncrementTick+0xf0>
80005d20:	49 32       	lddpc	r2,80005d6c <vTaskIncrementTick+0xec>
80005d22:	ee c6 ff fc 	sub	r6,r7,-4
80005d26:	0c 9c       	mov	r12,r6
80005d28:	f0 1f 00 18 	mcall	80005d88 <vTaskIncrementTick+0x108>
80005d2c:	6e a8       	ld.w	r8,r7[0x28]
80005d2e:	58 08       	cp.w	r8,0
80005d30:	c0 50       	breq	80005d3a <vTaskIncrementTick+0xba>
80005d32:	ee cc ff e8 	sub	r12,r7,-24
80005d36:	f0 1f 00 15 	mcall	80005d88 <vTaskIncrementTick+0x108>
80005d3a:	6e bc       	ld.w	r12,r7[0x2c]
80005d3c:	68 08       	ld.w	r8,r4[0x0]
80005d3e:	10 3c       	cp.w	r12,r8
80005d40:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005d44:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005d48:	0c 9b       	mov	r11,r6
80005d4a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005d4e:	f0 1f 00 10 	mcall	80005d8c <vTaskIncrementTick+0x10c>
80005d52:	6a 08       	ld.w	r8,r5[0x0]
80005d54:	70 08       	ld.w	r8,r8[0x0]
80005d56:	58 08       	cp.w	r8,0
80005d58:	cd 51       	brne	80005d02 <vTaskIncrementTick+0x82>
80005d5a:	cc fb       	rjmp	80005cf8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005d5c:	48 d8       	lddpc	r8,80005d90 <vTaskIncrementTick+0x110>
80005d5e:	70 09       	ld.w	r9,r8[0x0]
80005d60:	2f f9       	sub	r9,-1
80005d62:	91 09       	st.w	r8[0x0],r9
80005d64:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005d68:	00 00       	add	r0,r0
80005d6a:	0d 30       	ld.ub	r0,r6++
80005d6c:	00 00       	add	r0,r0
80005d6e:	0d 2c       	ld.uh	r12,r6++
80005d70:	00 00       	add	r0,r0
80005d72:	0c 38       	cp.w	r8,r6
80005d74:	00 00       	add	r0,r0
80005d76:	0c 48       	or	r8,r6
80005d78:	00 00       	add	r0,r0
80005d7a:	0c 44       	or	r4,r6
80005d7c:	00 00       	add	r0,r0
80005d7e:	05 34       	ld.ub	r4,r2++
80005d80:	00 00       	add	r0,r0
80005d82:	0d 68       	ld.uh	r8,--r6
80005d84:	00 00       	add	r0,r0
80005d86:	0c 4c       	or	r12,r6
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	52 26       	stdsp	sp[0x88],r6
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	51 d6       	stdsp	sp[0x74],r6
80005d90:	00 00       	add	r0,r0
80005d92:	0c 30       	cp.w	r0,r6

80005d94 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005d94:	eb cd 40 c0 	pushm	r6-r7,lr
80005d98:	18 97       	mov	r7,r12
80005d9a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005d9c:	f0 1f 00 15 	mcall	80005df0 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005da0:	6c 08       	ld.w	r8,r6[0x0]
80005da2:	5b f8       	cp.w	r8,-1
80005da4:	c0 31       	brne	80005daa <xTaskCheckForTimeOut+0x16>
80005da6:	30 07       	mov	r7,0
80005da8:	c1 f8       	rjmp	80005de6 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005daa:	49 39       	lddpc	r9,80005df4 <xTaskCheckForTimeOut+0x60>
80005dac:	72 09       	ld.w	r9,r9[0x0]
80005dae:	6e 0a       	ld.w	r10,r7[0x0]
80005db0:	12 3a       	cp.w	r10,r9
80005db2:	c0 70       	breq	80005dc0 <xTaskCheckForTimeOut+0x2c>
80005db4:	49 19       	lddpc	r9,80005df8 <xTaskCheckForTimeOut+0x64>
80005db6:	72 09       	ld.w	r9,r9[0x0]
80005db8:	6e 1a       	ld.w	r10,r7[0x4]
80005dba:	12 3a       	cp.w	r10,r9
80005dbc:	e0 88 00 14 	brls	80005de4 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005dc0:	48 e9       	lddpc	r9,80005df8 <xTaskCheckForTimeOut+0x64>
80005dc2:	72 0a       	ld.w	r10,r9[0x0]
80005dc4:	6e 19       	ld.w	r9,r7[0x4]
80005dc6:	12 1a       	sub	r10,r9
80005dc8:	14 38       	cp.w	r8,r10
80005dca:	e0 88 00 0d 	brls	80005de4 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005dce:	48 ba       	lddpc	r10,80005df8 <xTaskCheckForTimeOut+0x64>
80005dd0:	74 0a       	ld.w	r10,r10[0x0]
80005dd2:	14 19       	sub	r9,r10
80005dd4:	f2 08 00 08 	add	r8,r9,r8
80005dd8:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005dda:	0e 9c       	mov	r12,r7
80005ddc:	f0 1f 00 08 	mcall	80005dfc <xTaskCheckForTimeOut+0x68>
80005de0:	30 07       	mov	r7,0
80005de2:	c0 28       	rjmp	80005de6 <xTaskCheckForTimeOut+0x52>
80005de4:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005de6:	f0 1f 00 07 	mcall	80005e00 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005dea:	0e 9c       	mov	r12,r7
80005dec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	52 e0       	stdsp	sp[0xb8],r0
80005df4:	00 00       	add	r0,r0
80005df6:	0c 44       	or	r4,r6
80005df8:	00 00       	add	r0,r0
80005dfa:	0d 2c       	ld.uh	r12,r6++
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	5a f8       	cp.w	r8,-17
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	53 ec       	stdsp	sp[0xf8],r12

80005e04 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005e04:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005e08:	f0 1f 00 05 	mcall	80005e1c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005e0c:	48 58       	lddpc	r8,80005e20 <xTaskGetTickCount+0x1c>
80005e0e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005e10:	f0 1f 00 05 	mcall	80005e24 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005e14:	0e 9c       	mov	r12,r7
80005e16:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e1a:	00 00       	add	r0,r0
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	52 e0       	stdsp	sp[0xb8],r0
80005e20:	00 00       	add	r0,r0
80005e22:	0d 2c       	ld.uh	r12,r6++
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	53 ec       	stdsp	sp[0xf8],r12

80005e28 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005e28:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005e2c:	f0 1f 00 2c 	mcall	80005edc <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005e30:	4a c8       	lddpc	r8,80005ee0 <xTaskResumeAll+0xb8>
80005e32:	70 09       	ld.w	r9,r8[0x0]
80005e34:	20 19       	sub	r9,1
80005e36:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005e38:	70 08       	ld.w	r8,r8[0x0]
80005e3a:	58 08       	cp.w	r8,0
80005e3c:	c4 91       	brne	80005ece <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005e3e:	4a a8       	lddpc	r8,80005ee4 <xTaskResumeAll+0xbc>
80005e40:	70 08       	ld.w	r8,r8[0x0]
80005e42:	58 08       	cp.w	r8,0
80005e44:	c4 50       	breq	80005ece <xTaskResumeAll+0xa6>
80005e46:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005e48:	4a 85       	lddpc	r5,80005ee8 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005e4a:	4a 93       	lddpc	r3,80005eec <xTaskResumeAll+0xc4>
80005e4c:	4a 92       	lddpc	r2,80005ef0 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005e4e:	4a a1       	lddpc	r1,80005ef4 <xTaskResumeAll+0xcc>
80005e50:	c1 e8       	rjmp	80005e8c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005e52:	6a 38       	ld.w	r8,r5[0xc]
80005e54:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005e56:	ee cc ff e8 	sub	r12,r7,-24
80005e5a:	f0 1f 00 28 	mcall	80005ef8 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005e5e:	ee c6 ff fc 	sub	r6,r7,-4
80005e62:	0c 9c       	mov	r12,r6
80005e64:	f0 1f 00 25 	mcall	80005ef8 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005e68:	6e bc       	ld.w	r12,r7[0x2c]
80005e6a:	66 08       	ld.w	r8,r3[0x0]
80005e6c:	10 3c       	cp.w	r12,r8
80005e6e:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005e72:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005e76:	0c 9b       	mov	r11,r6
80005e78:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005e7c:	f0 1f 00 20 	mcall	80005efc <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005e80:	62 08       	ld.w	r8,r1[0x0]
80005e82:	6e b9       	ld.w	r9,r7[0x2c]
80005e84:	70 b8       	ld.w	r8,r8[0x2c]
80005e86:	10 39       	cp.w	r9,r8
80005e88:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005e8c:	6a 08       	ld.w	r8,r5[0x0]
80005e8e:	58 08       	cp.w	r8,0
80005e90:	ce 11       	brne	80005e52 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e92:	49 c8       	lddpc	r8,80005f00 <xTaskResumeAll+0xd8>
80005e94:	70 08       	ld.w	r8,r8[0x0]
80005e96:	58 08       	cp.w	r8,0
80005e98:	c0 f0       	breq	80005eb6 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005e9a:	49 a8       	lddpc	r8,80005f00 <xTaskResumeAll+0xd8>
80005e9c:	70 08       	ld.w	r8,r8[0x0]
80005e9e:	58 08       	cp.w	r8,0
80005ea0:	c1 10       	breq	80005ec2 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005ea2:	49 87       	lddpc	r7,80005f00 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005ea4:	f0 1f 00 18 	mcall	80005f04 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005ea8:	6e 08       	ld.w	r8,r7[0x0]
80005eaa:	20 18       	sub	r8,1
80005eac:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005eae:	6e 08       	ld.w	r8,r7[0x0]
80005eb0:	58 08       	cp.w	r8,0
80005eb2:	cf 91       	brne	80005ea4 <xTaskResumeAll+0x7c>
80005eb4:	c0 78       	rjmp	80005ec2 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005eb6:	58 14       	cp.w	r4,1
80005eb8:	c0 50       	breq	80005ec2 <xTaskResumeAll+0x9a>
80005eba:	49 48       	lddpc	r8,80005f08 <xTaskResumeAll+0xe0>
80005ebc:	70 08       	ld.w	r8,r8[0x0]
80005ebe:	58 18       	cp.w	r8,1
80005ec0:	c0 71       	brne	80005ece <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005ec2:	30 09       	mov	r9,0
80005ec4:	49 18       	lddpc	r8,80005f08 <xTaskResumeAll+0xe0>
80005ec6:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005ec8:	d7 33       	scall
80005eca:	30 17       	mov	r7,1
80005ecc:	c0 28       	rjmp	80005ed0 <xTaskResumeAll+0xa8>
80005ece:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005ed0:	f0 1f 00 0f 	mcall	80005f0c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005ed4:	0e 9c       	mov	r12,r7
80005ed6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005eda:	00 00       	add	r0,r0
80005edc:	80 00       	ld.sh	r0,r0[0x0]
80005ede:	52 e0       	stdsp	sp[0xb8],r0
80005ee0:	00 00       	add	r0,r0
80005ee2:	0d 30       	ld.ub	r0,r6++
80005ee4:	00 00       	add	r0,r0
80005ee6:	0d 4c       	ld.w	r12,--r6
80005ee8:	00 00       	add	r0,r0
80005eea:	0d 04       	ld.w	r4,r6++
80005eec:	00 00       	add	r0,r0
80005eee:	0d 68       	ld.uh	r8,--r6
80005ef0:	00 00       	add	r0,r0
80005ef2:	0c 4c       	or	r12,r6
80005ef4:	00 00       	add	r0,r0
80005ef6:	0d 00       	ld.w	r0,r6++
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	52 26       	stdsp	sp[0x88],r6
80005efc:	80 00       	ld.sh	r0,r0[0x0]
80005efe:	51 d6       	stdsp	sp[0x74],r6
80005f00:	00 00       	add	r0,r0
80005f02:	0c 30       	cp.w	r0,r6
80005f04:	80 00       	ld.sh	r0,r0[0x0]
80005f06:	5c 80       	casts.h	r0
80005f08:	00 00       	add	r0,r0
80005f0a:	0d 50       	ld.sh	r0,--r6
80005f0c:	80 00       	ld.sh	r0,r0[0x0]
80005f0e:	53 ec       	stdsp	sp[0xf8],r12

80005f10 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005f10:	eb cd 40 80 	pushm	r7,lr
80005f14:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005f16:	49 08       	lddpc	r8,80005f54 <prvAddCurrentTaskToDelayedList+0x44>
80005f18:	70 08       	ld.w	r8,r8[0x0]
80005f1a:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005f1c:	48 f8       	lddpc	r8,80005f58 <prvAddCurrentTaskToDelayedList+0x48>
80005f1e:	70 08       	ld.w	r8,r8[0x0]
80005f20:	10 3c       	cp.w	r12,r8
80005f22:	c0 a2       	brcc	80005f36 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005f24:	48 c8       	lddpc	r8,80005f54 <prvAddCurrentTaskToDelayedList+0x44>
80005f26:	70 0b       	ld.w	r11,r8[0x0]
80005f28:	48 d8       	lddpc	r8,80005f5c <prvAddCurrentTaskToDelayedList+0x4c>
80005f2a:	70 0c       	ld.w	r12,r8[0x0]
80005f2c:	2f cb       	sub	r11,-4
80005f2e:	f0 1f 00 0d 	mcall	80005f60 <prvAddCurrentTaskToDelayedList+0x50>
80005f32:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005f36:	48 88       	lddpc	r8,80005f54 <prvAddCurrentTaskToDelayedList+0x44>
80005f38:	70 0b       	ld.w	r11,r8[0x0]
80005f3a:	48 b8       	lddpc	r8,80005f64 <prvAddCurrentTaskToDelayedList+0x54>
80005f3c:	70 0c       	ld.w	r12,r8[0x0]
80005f3e:	2f cb       	sub	r11,-4
80005f40:	f0 1f 00 08 	mcall	80005f60 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005f44:	48 98       	lddpc	r8,80005f68 <prvAddCurrentTaskToDelayedList+0x58>
80005f46:	70 08       	ld.w	r8,r8[0x0]
80005f48:	10 37       	cp.w	r7,r8
80005f4a:	c0 32       	brcc	80005f50 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005f4c:	48 78       	lddpc	r8,80005f68 <prvAddCurrentTaskToDelayedList+0x58>
80005f4e:	91 07       	st.w	r8[0x0],r7
80005f50:	e3 cd 80 80 	ldm	sp++,r7,pc
80005f54:	00 00       	add	r0,r0
80005f56:	0d 00       	ld.w	r0,r6++
80005f58:	00 00       	add	r0,r0
80005f5a:	0d 2c       	ld.uh	r12,r6++
80005f5c:	00 00       	add	r0,r0
80005f5e:	0c 48       	or	r8,r6
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	51 f2       	stdsp	sp[0x7c],r2
80005f64:	00 00       	add	r0,r0
80005f66:	0c 38       	cp.w	r8,r6
80005f68:	00 00       	add	r0,r0
80005f6a:	05 34       	ld.ub	r4,r2++

80005f6c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005f6c:	eb cd 40 c0 	pushm	r6-r7,lr
80005f70:	18 96       	mov	r6,r12
80005f72:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005f74:	f0 1f 00 18 	mcall	80005fd4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005f78:	6c 08       	ld.w	r8,r6[0x0]
80005f7a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005f7c:	49 79       	lddpc	r9,80005fd8 <vTaskDelayUntil+0x6c>
80005f7e:	72 09       	ld.w	r9,r9[0x0]
80005f80:	12 38       	cp.w	r8,r9
80005f82:	e0 88 00 0c 	brls	80005f9a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005f86:	0e 38       	cp.w	r8,r7
80005f88:	e0 88 00 22 	brls	80005fcc <vTaskDelayUntil+0x60>
80005f8c:	49 38       	lddpc	r8,80005fd8 <vTaskDelayUntil+0x6c>
80005f8e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005f90:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005f92:	10 37       	cp.w	r7,r8
80005f94:	e0 88 00 14 	brls	80005fbc <vTaskDelayUntil+0x50>
80005f98:	c0 a8       	rjmp	80005fac <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005f9a:	0e 38       	cp.w	r8,r7
80005f9c:	e0 8b 00 16 	brhi	80005fc8 <vTaskDelayUntil+0x5c>
80005fa0:	48 e8       	lddpc	r8,80005fd8 <vTaskDelayUntil+0x6c>
80005fa2:	70 08       	ld.w	r8,r8[0x0]
80005fa4:	10 37       	cp.w	r7,r8
80005fa6:	e0 8b 00 11 	brhi	80005fc8 <vTaskDelayUntil+0x5c>
80005faa:	c1 18       	rjmp	80005fcc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005fac:	48 c8       	lddpc	r8,80005fdc <vTaskDelayUntil+0x70>
80005fae:	70 0c       	ld.w	r12,r8[0x0]
80005fb0:	2f cc       	sub	r12,-4
80005fb2:	f0 1f 00 0c 	mcall	80005fe0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005fb6:	0e 9c       	mov	r12,r7
80005fb8:	f0 1f 00 0b 	mcall	80005fe4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005fbc:	f0 1f 00 0b 	mcall	80005fe8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005fc0:	c0 81       	brne	80005fd0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005fc2:	d7 33       	scall
80005fc4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005fc8:	8d 07       	st.w	r6[0x0],r7
80005fca:	cf 1b       	rjmp	80005fac <vTaskDelayUntil+0x40>
80005fcc:	8d 07       	st.w	r6[0x0],r7
80005fce:	cf 7b       	rjmp	80005fbc <vTaskDelayUntil+0x50>
80005fd0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005fd4:	80 00       	ld.sh	r0,r0[0x0]
80005fd6:	5a 6c       	cp.w	r12,-26
80005fd8:	00 00       	add	r0,r0
80005fda:	0d 2c       	ld.uh	r12,r6++
80005fdc:	00 00       	add	r0,r0
80005fde:	0d 00       	ld.w	r0,r6++
80005fe0:	80 00       	ld.sh	r0,r0[0x0]
80005fe2:	52 26       	stdsp	sp[0x88],r6
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	5f 10       	srne	r0
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	5e 28       	reths	r8

80005fec <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005fec:	eb cd 40 c0 	pushm	r6-r7,lr
80005ff0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005ff2:	48 e7       	lddpc	r7,80006028 <vTaskPlaceOnEventList+0x3c>
80005ff4:	6e 0b       	ld.w	r11,r7[0x0]
80005ff6:	2e 8b       	sub	r11,-24
80005ff8:	f0 1f 00 0d 	mcall	8000602c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ffc:	6e 0c       	ld.w	r12,r7[0x0]
80005ffe:	2f cc       	sub	r12,-4
80006000:	f0 1f 00 0c 	mcall	80006030 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006004:	5b f6       	cp.w	r6,-1
80006006:	c0 81       	brne	80006016 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006008:	6e 0b       	ld.w	r11,r7[0x0]
8000600a:	2f cb       	sub	r11,-4
8000600c:	48 ac       	lddpc	r12,80006034 <vTaskPlaceOnEventList+0x48>
8000600e:	f0 1f 00 0b 	mcall	80006038 <vTaskPlaceOnEventList+0x4c>
80006012:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006016:	48 a8       	lddpc	r8,8000603c <vTaskPlaceOnEventList+0x50>
80006018:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
8000601a:	ec 0c 00 0c 	add	r12,r6,r12
8000601e:	f0 1f 00 09 	mcall	80006040 <vTaskPlaceOnEventList+0x54>
80006022:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006026:	00 00       	add	r0,r0
80006028:	00 00       	add	r0,r0
8000602a:	0d 00       	ld.w	r0,r6++
8000602c:	80 00       	ld.sh	r0,r0[0x0]
8000602e:	51 f2       	stdsp	sp[0x7c],r2
80006030:	80 00       	ld.sh	r0,r0[0x0]
80006032:	52 26       	stdsp	sp[0x88],r6
80006034:	00 00       	add	r0,r0
80006036:	0d 54       	ld.sh	r4,--r6
80006038:	80 00       	ld.sh	r0,r0[0x0]
8000603a:	51 d6       	stdsp	sp[0x74],r6
8000603c:	00 00       	add	r0,r0
8000603e:	0d 2c       	ld.uh	r12,r6++
80006040:	80 00       	ld.sh	r0,r0[0x0]
80006042:	5f 10       	srne	r0

80006044 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006044:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006048:	49 67       	lddpc	r7,800060a0 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000604a:	49 74       	lddpc	r4,800060a4 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
8000604c:	49 73       	lddpc	r3,800060a8 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
8000604e:	49 85       	lddpc	r5,800060ac <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006050:	6e 08       	ld.w	r8,r7[0x0]
80006052:	58 08       	cp.w	r8,0
80006054:	c1 e0       	breq	80006090 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006056:	f0 1f 00 17 	mcall	800060b0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
8000605a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
8000605c:	f0 1f 00 16 	mcall	800060b4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006060:	58 06       	cp.w	r6,0
80006062:	c1 70       	breq	80006090 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006064:	f0 1f 00 15 	mcall	800060b8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006068:	68 38       	ld.w	r8,r4[0xc]
8000606a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
8000606c:	ec cc ff fc 	sub	r12,r6,-4
80006070:	f0 1f 00 13 	mcall	800060bc <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006074:	66 08       	ld.w	r8,r3[0x0]
80006076:	20 18       	sub	r8,1
80006078:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
8000607a:	6e 08       	ld.w	r8,r7[0x0]
8000607c:	20 18       	sub	r8,1
8000607e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006080:	f0 1f 00 10 	mcall	800060c0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006084:	6c cc       	ld.w	r12,r6[0x30]
80006086:	f0 1f 00 10 	mcall	800060c4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
8000608a:	0c 9c       	mov	r12,r6
8000608c:	f0 1f 00 0e 	mcall	800060c4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006090:	6a 08       	ld.w	r8,r5[0x0]
80006092:	58 18       	cp.w	r8,1
80006094:	e0 88 00 03 	brls	8000609a <prvIdleTask+0x56>
			{
				taskYIELD();
80006098:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
8000609a:	f0 1f 00 0c 	mcall	800060c8 <prvIdleTask+0x84>
		}
		#endif
	}
8000609e:	cd 9b       	rjmp	80006050 <prvIdleTask+0xc>
800060a0:	00 00       	add	r0,r0
800060a2:	0c 40       	or	r0,r6
800060a4:	00 00       	add	r0,r0
800060a6:	0c ec       	st.h	--r6,r12
800060a8:	00 00       	add	r0,r0
800060aa:	0d 4c       	ld.w	r12,--r6
800060ac:	00 00       	add	r0,r0
800060ae:	0c 4c       	or	r12,r6
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	5a 6c       	cp.w	r12,-26
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	5e 28       	reths	r8
800060b8:	80 00       	ld.sh	r0,r0[0x0]
800060ba:	52 e0       	stdsp	sp[0xb8],r0
800060bc:	80 00       	ld.sh	r0,r0[0x0]
800060be:	52 26       	stdsp	sp[0x88],r6
800060c0:	80 00       	ld.sh	r0,r0[0x0]
800060c2:	53 ec       	stdsp	sp[0xf8],r12
800060c4:	80 00       	ld.sh	r0,r0[0x0]
800060c6:	55 24       	stdsp	sp[0x148],r4
800060c8:	80 00       	ld.sh	r0,r0[0x0]
800060ca:	20 30       	sub	r0,3

800060cc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800060cc:	d4 31       	pushm	r0-r7,lr
800060ce:	20 1d       	sub	sp,4
800060d0:	fa c4 ff d8 	sub	r4,sp,-40
800060d4:	50 0c       	stdsp	sp[0x0],r12
800060d6:	16 91       	mov	r1,r11
800060d8:	14 97       	mov	r7,r10
800060da:	12 90       	mov	r0,r9
800060dc:	10 93       	mov	r3,r8
800060de:	68 02       	ld.w	r2,r4[0x0]
800060e0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800060e2:	34 8c       	mov	r12,72
800060e4:	f0 1f 00 5c 	mcall	80006254 <xTaskGenericCreate+0x188>
800060e8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800060ea:	c0 31       	brne	800060f0 <xTaskGenericCreate+0x24>
800060ec:	3f fc       	mov	r12,-1
800060ee:	ca f8       	rjmp	8000624c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800060f0:	58 06       	cp.w	r6,0
800060f2:	e0 81 00 af 	brne	80006250 <xTaskGenericCreate+0x184>
800060f6:	0e 9c       	mov	r12,r7
800060f8:	5c 7c       	castu.h	r12
800060fa:	a3 6c       	lsl	r12,0x2
800060fc:	f0 1f 00 56 	mcall	80006254 <xTaskGenericCreate+0x188>
80006100:	18 96       	mov	r6,r12
80006102:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006104:	c0 61       	brne	80006110 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006106:	0a 9c       	mov	r12,r5
80006108:	f0 1f 00 54 	mcall	80006258 <xTaskGenericCreate+0x18c>
8000610c:	3f fc       	mov	r12,-1
8000610e:	c9 f8       	rjmp	8000624c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006110:	5c 77       	castu.h	r7
80006112:	ee 0a 15 02 	lsl	r10,r7,0x2
80006116:	e0 6b 00 a5 	mov	r11,165
8000611a:	0c 9c       	mov	r12,r6
8000611c:	f0 1f 00 50 	mcall	8000625c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006120:	ee c6 00 01 	sub	r6,r7,1
80006124:	6a c8       	ld.w	r8,r5[0x30]
80006126:	f0 06 00 26 	add	r6,r8,r6<<0x2
8000612a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000612e:	31 0a       	mov	r10,16
80006130:	02 9b       	mov	r11,r1
80006132:	ea cc ff cc 	sub	r12,r5,-52
80006136:	f0 1f 00 4b 	mcall	80006260 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
8000613a:	30 08       	mov	r8,0
8000613c:	eb 68 00 43 	st.b	r5[67],r8
80006140:	58 73       	cp.w	r3,7
80006142:	e6 07 17 80 	movls	r7,r3
80006146:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
8000614a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
8000614c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006150:	ea c4 ff fc 	sub	r4,r5,-4
80006154:	08 9c       	mov	r12,r4
80006156:	f0 1f 00 44 	mcall	80006264 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000615a:	ea cc ff e8 	sub	r12,r5,-24
8000615e:	f0 1f 00 42 	mcall	80006264 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006162:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006164:	ee 07 11 08 	rsub	r7,r7,8
80006168:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000616a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
8000616c:	00 9a       	mov	r10,r0
8000616e:	40 0b       	lddsp	r11,sp[0x0]
80006170:	0c 9c       	mov	r12,r6
80006172:	f0 1f 00 3e 	mcall	80006268 <xTaskGenericCreate+0x19c>
80006176:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006178:	58 02       	cp.w	r2,0
8000617a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000617e:	f0 1f 00 3c 	mcall	8000626c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006182:	4b c8       	lddpc	r8,80006270 <xTaskGenericCreate+0x1a4>
80006184:	70 09       	ld.w	r9,r8[0x0]
80006186:	2f f9       	sub	r9,-1
80006188:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
8000618a:	4b b8       	lddpc	r8,80006274 <xTaskGenericCreate+0x1a8>
8000618c:	70 08       	ld.w	r8,r8[0x0]
8000618e:	58 08       	cp.w	r8,0
80006190:	c2 61       	brne	800061dc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006192:	4b 98       	lddpc	r8,80006274 <xTaskGenericCreate+0x1a8>
80006194:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006196:	4b 78       	lddpc	r8,80006270 <xTaskGenericCreate+0x1a4>
80006198:	70 08       	ld.w	r8,r8[0x0]
8000619a:	58 18       	cp.w	r8,1
8000619c:	c2 b1       	brne	800061f2 <xTaskGenericCreate+0x126>
8000619e:	4b 77       	lddpc	r7,80006278 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800061a0:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800061a4:	0e 9c       	mov	r12,r7
800061a6:	f0 1f 00 36 	mcall	8000627c <xTaskGenericCreate+0x1b0>
800061aa:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800061ac:	0c 37       	cp.w	r7,r6
800061ae:	cf b1       	brne	800061a4 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800061b0:	4b 47       	lddpc	r7,80006280 <xTaskGenericCreate+0x1b4>
800061b2:	0e 9c       	mov	r12,r7
800061b4:	f0 1f 00 32 	mcall	8000627c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800061b8:	4b 36       	lddpc	r6,80006284 <xTaskGenericCreate+0x1b8>
800061ba:	0c 9c       	mov	r12,r6
800061bc:	f0 1f 00 30 	mcall	8000627c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
800061c0:	4b 2c       	lddpc	r12,80006288 <xTaskGenericCreate+0x1bc>
800061c2:	f0 1f 00 2f 	mcall	8000627c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800061c6:	4b 2c       	lddpc	r12,8000628c <xTaskGenericCreate+0x1c0>
800061c8:	f0 1f 00 2d 	mcall	8000627c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800061cc:	4b 1c       	lddpc	r12,80006290 <xTaskGenericCreate+0x1c4>
800061ce:	f0 1f 00 2c 	mcall	8000627c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800061d2:	4b 18       	lddpc	r8,80006294 <xTaskGenericCreate+0x1c8>
800061d4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800061d6:	4b 18       	lddpc	r8,80006298 <xTaskGenericCreate+0x1cc>
800061d8:	91 06       	st.w	r8[0x0],r6
800061da:	c0 c8       	rjmp	800061f2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800061dc:	4b 08       	lddpc	r8,8000629c <xTaskGenericCreate+0x1d0>
800061de:	70 08       	ld.w	r8,r8[0x0]
800061e0:	58 08       	cp.w	r8,0
800061e2:	c0 81       	brne	800061f2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800061e4:	4a 48       	lddpc	r8,80006274 <xTaskGenericCreate+0x1a8>
800061e6:	70 08       	ld.w	r8,r8[0x0]
800061e8:	70 b8       	ld.w	r8,r8[0x2c]
800061ea:	10 33       	cp.w	r3,r8
800061ec:	c0 33       	brcs	800061f2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800061ee:	4a 28       	lddpc	r8,80006274 <xTaskGenericCreate+0x1a8>
800061f0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800061f2:	6a b8       	ld.w	r8,r5[0x2c]
800061f4:	4a b9       	lddpc	r9,800062a0 <xTaskGenericCreate+0x1d4>
800061f6:	72 09       	ld.w	r9,r9[0x0]
800061f8:	12 38       	cp.w	r8,r9
800061fa:	e0 88 00 04 	brls	80006202 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800061fe:	4a 99       	lddpc	r9,800062a0 <xTaskGenericCreate+0x1d4>
80006200:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006202:	4a 98       	lddpc	r8,800062a4 <xTaskGenericCreate+0x1d8>
80006204:	70 09       	ld.w	r9,r8[0x0]
80006206:	2f f9       	sub	r9,-1
80006208:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
8000620a:	6a b8       	ld.w	r8,r5[0x2c]
8000620c:	4a 79       	lddpc	r9,800062a8 <xTaskGenericCreate+0x1dc>
8000620e:	72 09       	ld.w	r9,r9[0x0]
80006210:	12 38       	cp.w	r8,r9
80006212:	e0 88 00 04 	brls	8000621a <xTaskGenericCreate+0x14e>
80006216:	4a 59       	lddpc	r9,800062a8 <xTaskGenericCreate+0x1dc>
80006218:	93 08       	st.w	r9[0x0],r8
8000621a:	6a bc       	ld.w	r12,r5[0x2c]
8000621c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006220:	08 9b       	mov	r11,r4
80006222:	49 68       	lddpc	r8,80006278 <xTaskGenericCreate+0x1ac>
80006224:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006228:	f0 1f 00 21 	mcall	800062ac <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000622c:	f0 1f 00 21 	mcall	800062b0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006230:	49 b8       	lddpc	r8,8000629c <xTaskGenericCreate+0x1d0>
80006232:	70 08       	ld.w	r8,r8[0x0]
80006234:	58 08       	cp.w	r8,0
80006236:	c0 a0       	breq	8000624a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006238:	48 f8       	lddpc	r8,80006274 <xTaskGenericCreate+0x1a8>
8000623a:	70 08       	ld.w	r8,r8[0x0]
8000623c:	70 b8       	ld.w	r8,r8[0x2c]
8000623e:	10 33       	cp.w	r3,r8
80006240:	e0 88 00 05 	brls	8000624a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006244:	d7 33       	scall
80006246:	30 1c       	mov	r12,1
80006248:	c0 28       	rjmp	8000624c <xTaskGenericCreate+0x180>
8000624a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000624c:	2f fd       	sub	sp,-4
8000624e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006250:	99 c6       	st.w	r12[0x30],r6
80006252:	c5 fb       	rjmp	80006110 <xTaskGenericCreate+0x44>
80006254:	80 00       	ld.sh	r0,r0[0x0]
80006256:	55 4c       	stdsp	sp[0x150],r12
80006258:	80 00       	ld.sh	r0,r0[0x0]
8000625a:	55 24       	stdsp	sp[0x148],r4
8000625c:	80 00       	ld.sh	r0,r0[0x0]
8000625e:	6f 38       	ld.w	r8,r7[0x4c]
80006260:	80 00       	ld.sh	r0,r0[0x0]
80006262:	72 7c       	ld.w	r12,r9[0x1c]
80006264:	80 00       	ld.sh	r0,r0[0x0]
80006266:	51 d0       	stdsp	sp[0x74],r0
80006268:	80 00       	ld.sh	r0,r0[0x0]
8000626a:	52 4c       	stdsp	sp[0x90],r12
8000626c:	80 00       	ld.sh	r0,r0[0x0]
8000626e:	52 e0       	stdsp	sp[0xb8],r0
80006270:	00 00       	add	r0,r0
80006272:	0d 4c       	ld.w	r12,--r6
80006274:	00 00       	add	r0,r0
80006276:	0d 00       	ld.w	r0,r6++
80006278:	00 00       	add	r0,r0
8000627a:	0c 4c       	or	r12,r6
8000627c:	80 00       	ld.sh	r0,r0[0x0]
8000627e:	51 bc       	stdsp	sp[0x6c],r12
80006280:	00 00       	add	r0,r0
80006282:	0d 18       	ld.sh	r8,r6++
80006284:	00 00       	add	r0,r0
80006286:	0d 34       	ld.ub	r4,r6++
80006288:	00 00       	add	r0,r0
8000628a:	0d 04       	ld.w	r4,r6++
8000628c:	00 00       	add	r0,r0
8000628e:	0c ec       	st.h	--r6,r12
80006290:	00 00       	add	r0,r0
80006292:	0d 54       	ld.sh	r4,--r6
80006294:	00 00       	add	r0,r0
80006296:	0c 38       	cp.w	r8,r6
80006298:	00 00       	add	r0,r0
8000629a:	0c 48       	or	r8,r6
8000629c:	00 00       	add	r0,r0
8000629e:	0c 3c       	cp.w	r12,r6
800062a0:	00 00       	add	r0,r0
800062a2:	0c 34       	cp.w	r4,r6
800062a4:	00 00       	add	r0,r0
800062a6:	0d 48       	ld.w	r8,--r6
800062a8:	00 00       	add	r0,r0
800062aa:	0d 68       	ld.uh	r8,--r6
800062ac:	80 00       	ld.sh	r0,r0[0x0]
800062ae:	51 d6       	stdsp	sp[0x74],r6
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	53 ec       	stdsp	sp[0xf8],r12

800062b4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800062b4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800062b6:	30 09       	mov	r9,0
800062b8:	1a d9       	st.w	--sp,r9
800062ba:	1a d9       	st.w	--sp,r9
800062bc:	1a d9       	st.w	--sp,r9
800062be:	12 98       	mov	r8,r9
800062c0:	e0 6a 01 00 	mov	r10,256
800062c4:	48 9b       	lddpc	r11,800062e8 <vTaskStartScheduler+0x34>
800062c6:	48 ac       	lddpc	r12,800062ec <vTaskStartScheduler+0x38>
800062c8:	f0 1f 00 0a 	mcall	800062f0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800062cc:	2f dd       	sub	sp,-12
800062ce:	58 1c       	cp.w	r12,1
800062d0:	c0 a1       	brne	800062e4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800062d2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800062d4:	30 19       	mov	r9,1
800062d6:	48 88       	lddpc	r8,800062f4 <vTaskStartScheduler+0x40>
800062d8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800062da:	30 09       	mov	r9,0
800062dc:	48 78       	lddpc	r8,800062f8 <vTaskStartScheduler+0x44>
800062de:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800062e0:	f0 1f 00 07 	mcall	800062fc <vTaskStartScheduler+0x48>
800062e4:	d8 02       	popm	pc
800062e6:	00 00       	add	r0,r0
800062e8:	80 00       	ld.sh	r0,r0[0x0]
800062ea:	d4 c8       	*unknown*
800062ec:	80 00       	ld.sh	r0,r0[0x0]
800062ee:	60 44       	ld.w	r4,r0[0x10]
800062f0:	80 00       	ld.sh	r0,r0[0x0]
800062f2:	60 cc       	ld.w	r12,r0[0x30]
800062f4:	00 00       	add	r0,r0
800062f6:	0c 3c       	cp.w	r12,r6
800062f8:	00 00       	add	r0,r0
800062fa:	0d 2c       	ld.uh	r12,r6++
800062fc:	80 00       	ld.sh	r0,r0[0x0]
800062fe:	52 f0       	stdsp	sp[0xbc],r0

80006300 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006300:	16 cc       	st.b	r11++,r12
	return str;
}
80006302:	5e fb       	retal	r11

80006304 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006304:	eb cd 40 c0 	pushm	r6-r7,lr
80006308:	20 3d       	sub	sp,12
8000630a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
8000630c:	30 06       	mov	r6,0
8000630e:	30 07       	mov	r7,0
80006310:	fa e7 00 00 	st.d	sp[0],r6
80006314:	30 0c       	mov	r12,0
80006316:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006318:	58 08       	cp.w	r8,0
8000631a:	c1 30       	breq	80006340 <PrintHex+0x3c>
8000631c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000631e:	1a 9c       	mov	r12,sp
80006320:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006324:	58 9e       	cp.w	lr,9
80006326:	e0 8a 00 04 	brle	8000632e <PrintHex+0x2a>
8000632a:	2c 9e       	sub	lr,-55
8000632c:	c0 48       	rjmp	80006334 <PrintHex+0x30>
8000632e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006332:	2d 0e       	sub	lr,-48
80006334:	f8 09 0b 0e 	st.b	r12[r9],lr
80006338:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000633a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000633c:	cf 21       	brne	80006320 <PrintHex+0x1c>
8000633e:	c0 48       	rjmp	80006346 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006340:	33 08       	mov	r8,48
80006342:	ba 88       	st.b	sp[0x0],r8
80006344:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006346:	f6 09 01 08 	sub	r8,r11,r9
8000634a:	58 08       	cp.w	r8,0
8000634c:	e0 8a 00 13 	brle	80006372 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006350:	12 1b       	sub	r11,r9
80006352:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006356:	18 9e       	mov	lr,r12
80006358:	58 0c       	cp.w	r12,0
8000635a:	e0 8a 00 0c 	brle	80006372 <PrintHex+0x6e>
8000635e:	1a 9b       	mov	r11,sp
80006360:	12 0b       	add	r11,r9
80006362:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006364:	33 07       	mov	r7,48
80006366:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006368:	2f f8       	sub	r8,-1
8000636a:	1c 38       	cp.w	r8,lr
8000636c:	cf d5       	brlt	80006366 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000636e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006372:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006376:	f0 cb ff ff 	sub	r11,r8,-1
8000637a:	58 0b       	cp.w	r11,0
8000637c:	e0 8a 00 19 	brle	800063ae <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006380:	fa cb ff f4 	sub	r11,sp,-12
80006384:	f6 09 00 09 	add	r9,r11,r9
80006388:	37 8b       	mov	r11,120
8000638a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000638e:	fa c9 ff f4 	sub	r9,sp,-12
80006392:	10 09       	add	r9,r8
80006394:	33 0b       	mov	r11,48
80006396:	f3 6b ff f4 	st.b	r9[-12],r11
8000639a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000639e:	fa ce 00 01 	sub	lr,sp,1
800063a2:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
800063a4:	11 8b       	ld.ub	r11,r8[0x0]
800063a6:	12 cb       	st.b	r9++,r11
800063a8:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
800063aa:	1c 38       	cp.w	r8,lr
800063ac:	cf c1       	brne	800063a4 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
800063ae:	14 9c       	mov	r12,r10
800063b0:	2f dd       	sub	sp,-12
800063b2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800063b6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800063b6:	d4 21       	pushm	r4-r7,lr
800063b8:	20 3d       	sub	sp,12
800063ba:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800063bc:	30 06       	mov	r6,0
800063be:	30 07       	mov	r7,0
800063c0:	fa e7 00 00 	st.d	sp[0],r6
800063c4:	30 0c       	mov	r12,0
800063c6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800063c8:	58 08       	cp.w	r8,0
800063ca:	c0 35       	brlt	800063d0 <PrintDec+0x1a>
800063cc:	14 97       	mov	r7,r10
800063ce:	c0 58       	rjmp	800063d8 <PrintDec+0x22>
	{
		*p++ = '-';
800063d0:	14 97       	mov	r7,r10
800063d2:	32 d9       	mov	r9,45
800063d4:	0e c9       	st.b	r7++,r9
		i = -i;
800063d6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800063d8:	58 08       	cp.w	r8,0
800063da:	c0 51       	brne	800063e4 <PrintDec+0x2e>
800063dc:	33 08       	mov	r8,48
800063de:	ba 88       	st.b	sp[0x0],r8
800063e0:	30 1e       	mov	lr,1
800063e2:	c2 f8       	rjmp	80006440 <PrintDec+0x8a>
	
	int ten = i%10;
800063e4:	e0 65 66 67 	mov	r5,26215
800063e8:	ea 15 66 66 	orh	r5,0x6666
800063ec:	f0 05 04 44 	muls.d	r4,r8,r5
800063f0:	ea 0c 14 02 	asr	r12,r5,0x2
800063f4:	f0 09 14 1f 	asr	r9,r8,0x1f
800063f8:	f8 09 01 09 	sub	r9,r12,r9
800063fc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006400:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006404:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006406:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006408:	e0 66 66 67 	mov	r6,26215
8000640c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006410:	2d 09       	sub	r9,-48
80006412:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006416:	2f fe       	sub	lr,-1
		i /= 10;
80006418:	f0 06 04 44 	muls.d	r4,r8,r6
8000641c:	ea 09 14 02 	asr	r9,r5,0x2
80006420:	bf 58       	asr	r8,0x1f
80006422:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006426:	f0 06 04 44 	muls.d	r4,r8,r6
8000642a:	ea 09 14 02 	asr	r9,r5,0x2
8000642e:	f0 05 14 1f 	asr	r5,r8,0x1f
80006432:	0a 19       	sub	r9,r5
80006434:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006438:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000643c:	58 08       	cp.w	r8,0
8000643e:	ce 91       	brne	80006410 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006440:	f6 0e 01 08 	sub	r8,r11,lr
80006444:	58 08       	cp.w	r8,0
80006446:	e0 89 00 06 	brgt	80006452 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000644a:	58 0e       	cp.w	lr,0
8000644c:	e0 89 00 14 	brgt	80006474 <PrintDec+0xbe>
80006450:	c1 d8       	rjmp	8000648a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006452:	1c 1b       	sub	r11,lr
80006454:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006456:	16 9c       	mov	r12,r11
80006458:	58 0b       	cp.w	r11,0
8000645a:	fe 9a ff f8 	brle	8000644a <PrintDec+0x94>
8000645e:	1a 99       	mov	r9,sp
80006460:	1c 09       	add	r9,lr
80006462:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006464:	33 06       	mov	r6,48
80006466:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006468:	2f f8       	sub	r8,-1
8000646a:	18 38       	cp.w	r8,r12
8000646c:	cf d5       	brlt	80006466 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000646e:	f6 0e 00 0e 	add	lr,r11,lr
80006472:	ce cb       	rjmp	8000644a <PrintDec+0x94>
80006474:	fa c8 ff f4 	sub	r8,sp,-12
80006478:	1c 08       	add	r8,lr
8000647a:	20 d8       	sub	r8,13
8000647c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006480:	11 89       	ld.ub	r9,r8[0x0]
80006482:	0e c9       	st.b	r7++,r9
80006484:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006486:	16 38       	cp.w	r8,r11
80006488:	cf c1       	brne	80006480 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000648a:	14 9c       	mov	r12,r10
8000648c:	2f dd       	sub	sp,-12
8000648e:	d8 22       	popm	r4-r7,pc

80006490 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006490:	d4 31       	pushm	r0-r7,lr
80006492:	fa cd 02 08 	sub	sp,sp,520
80006496:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006498:	e0 6a 01 00 	mov	r10,256
8000649c:	30 0b       	mov	r11,0
8000649e:	fa cc fe f8 	sub	r12,sp,-264
800064a2:	f0 1f 00 4e 	mcall	800065d8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
800064a6:	fa c4 fd d4 	sub	r4,sp,-556
800064aa:	30 0a       	mov	r10,0
800064ac:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800064ae:	fa c3 ff fc 	sub	r3,sp,-4
800064b2:	e0 61 01 00 	mov	r1,256
800064b6:	14 90       	mov	r0,r10
			
					if(*str == '%')
800064b8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800064ba:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800064be:	02 9a       	mov	r10,r1
800064c0:	00 9b       	mov	r11,r0
800064c2:	06 9c       	mov	r12,r3
800064c4:	f0 1f 00 45 	mcall	800065d8 <log+0x148>
			
					if(*str == '%')
800064c8:	0f 88       	ld.ub	r8,r7[0x0]
800064ca:	e4 08 18 00 	cp.b	r8,r2
800064ce:	c5 71       	brne	8000657c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800064d0:	ee c8 ff ff 	sub	r8,r7,-1
800064d4:	11 89       	ld.ub	r9,r8[0x0]
800064d6:	4c 2a       	lddpc	r10,800065dc <log+0x14c>
800064d8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800064da:	23 09       	sub	r9,48
800064dc:	30 9a       	mov	r10,9
800064de:	f4 09 18 00 	cp.b	r9,r10
800064e2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800064e6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800064ea:	f7 b9 08 30 	subls	r9,48
800064ee:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800064f2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800064f6:	0f 88       	ld.ub	r8,r7[0x0]
800064f8:	22 58       	sub	r8,37
800064fa:	e0 48 00 53 	cp.w	r8,83
800064fe:	e0 8b 00 31 	brhi	80006560 <log+0xd0>
80006502:	4b 89       	lddpc	r9,800065e0 <log+0x150>
80006504:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006508:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
8000650c:	06 9a       	mov	r10,r3
8000650e:	40 0b       	lddsp	r11,sp[0x0]
80006510:	5c 5b       	castu.b	r11
80006512:	68 0c       	ld.w	r12,r4[0x0]
80006514:	f0 1f 00 34 	mcall	800065e4 <log+0x154>
							break;
80006518:	c2 98       	rjmp	8000656a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000651a:	4b 4c       	lddpc	r12,800065e8 <log+0x158>
8000651c:	f0 1f 00 34 	mcall	800065ec <log+0x15c>
80006520:	08 95       	mov	r5,r4
80006522:	06 9c       	mov	r12,r3
							break;
80006524:	c2 38       	rjmp	8000656a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006526:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000652a:	06 9a       	mov	r10,r3
8000652c:	40 0b       	lddsp	r11,sp[0x0]
8000652e:	5c 5b       	castu.b	r11
80006530:	68 0c       	ld.w	r12,r4[0x0]
80006532:	f0 1f 00 30 	mcall	800065f0 <log+0x160>
80006536:	06 9c       	mov	r12,r3
							break;
80006538:	c1 98       	rjmp	8000656a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000653a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000653e:	06 9b       	mov	r11,r3
80006540:	09 bc       	ld.ub	r12,r4[0x3]
80006542:	f0 1f 00 2d 	mcall	800065f4 <log+0x164>
80006546:	06 9c       	mov	r12,r3
							break;
80006548:	c1 18       	rjmp	8000656a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000654a:	e8 c5 ff fc 	sub	r5,r4,-4
8000654e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006550:	c0 d8       	rjmp	8000656a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006552:	06 9b       	mov	r11,r3
80006554:	32 5c       	mov	r12,37
80006556:	f0 1f 00 28 	mcall	800065f4 <log+0x164>
8000655a:	08 95       	mov	r5,r4
8000655c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000655e:	c0 68       	rjmp	8000656a <log+0xda>
							
							default:
							log("I need relax.");
80006560:	4a 6c       	lddpc	r12,800065f8 <log+0x168>
80006562:	f0 1f 00 23 	mcall	800065ec <log+0x15c>
80006566:	08 95       	mov	r5,r4
80006568:	06 9c       	mov	r12,r3
						}
						str++;
8000656a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000656c:	1a dc       	st.w	--sp,r12
8000656e:	1a d6       	st.w	--sp,r6
80006570:	4a 3b       	lddpc	r11,800065fc <log+0x16c>
80006572:	0c 9c       	mov	r12,r6
80006574:	f0 1f 00 23 	mcall	80006600 <log+0x170>
80006578:	2f ed       	sub	sp,-8
8000657a:	c0 a8       	rjmp	8000658e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000657c:	2f f7       	sub	r7,-1
8000657e:	1a d8       	st.w	--sp,r8
80006580:	1a d6       	st.w	--sp,r6
80006582:	4a 1b       	lddpc	r11,80006604 <log+0x174>
80006584:	0c 9c       	mov	r12,r6
80006586:	f0 1f 00 1f 	mcall	80006600 <log+0x170>
8000658a:	08 95       	mov	r5,r4
8000658c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000658e:	0f 89       	ld.ub	r9,r7[0x0]
80006590:	30 08       	mov	r8,0
80006592:	f0 09 18 00 	cp.b	r9,r8
80006596:	c0 30       	breq	8000659c <log+0x10c>
80006598:	0a 94       	mov	r4,r5
8000659a:	c9 2b       	rjmp	800064be <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000659c:	fa c7 fe f8 	sub	r7,sp,-264
800065a0:	1a d7       	st.w	--sp,r7
800065a2:	49 ab       	lddpc	r11,80006608 <log+0x178>
800065a4:	0e 9c       	mov	r12,r7
800065a6:	f0 1f 00 17 	mcall	80006600 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
800065aa:	5c 5c       	castu.b	r12
800065ac:	f8 c6 ff ff 	sub	r6,r12,-1
800065b0:	0c 9c       	mov	r12,r6
800065b2:	f0 1f 00 17 	mcall	8000660c <log+0x17c>
800065b6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800065b8:	0c 9a       	mov	r10,r6
800065ba:	0e 9b       	mov	r11,r7
800065bc:	f0 1f 00 15 	mcall	80006610 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
800065c0:	30 09       	mov	r9,0
800065c2:	30 5a       	mov	r10,5
800065c4:	fa cb fe f8 	sub	r11,sp,-264
800065c8:	49 38       	lddpc	r8,80006614 <log+0x184>
800065ca:	70 0c       	ld.w	r12,r8[0x0]
800065cc:	f0 1f 00 13 	mcall	80006618 <log+0x188>
800065d0:	2f fd       	sub	sp,-4
}
800065d2:	fe 3d fd f8 	sub	sp,-520
800065d6:	d8 32       	popm	r0-r7,pc
800065d8:	80 00       	ld.sh	r0,r0[0x0]
800065da:	6f 38       	ld.w	r8,r7[0x4c]
800065dc:	00 00       	add	r0,r0
800065de:	0d 6c       	ld.uh	r12,--r6
800065e0:	80 00       	ld.sh	r0,r0[0x0]
800065e2:	d4 d0       	acall	0x4d
800065e4:	80 00       	ld.sh	r0,r0[0x0]
800065e6:	63 b6       	ld.w	r6,r1[0x6c]
800065e8:	80 00       	ld.sh	r0,r0[0x0]
800065ea:	d7 7c       	*unknown*
800065ec:	80 00       	ld.sh	r0,r0[0x0]
800065ee:	64 90       	ld.w	r0,r2[0x24]
800065f0:	80 00       	ld.sh	r0,r0[0x0]
800065f2:	63 04       	ld.w	r4,r1[0x40]
800065f4:	80 00       	ld.sh	r0,r0[0x0]
800065f6:	63 00       	ld.w	r0,r1[0x40]
800065f8:	80 00       	ld.sh	r0,r0[0x0]
800065fa:	d7 8c       	*unknown*
800065fc:	80 00       	ld.sh	r0,r0[0x0]
800065fe:	d7 9c       	*unknown*
80006600:	80 00       	ld.sh	r0,r0[0x0]
80006602:	72 28       	ld.w	r8,r9[0x8]
80006604:	80 00       	ld.sh	r0,r0[0x0]
80006606:	d7 a4       	*unknown*
80006608:	80 00       	ld.sh	r0,r0[0x0]
8000660a:	d7 ac       	*unknown*
8000660c:	80 00       	ld.sh	r0,r0[0x0]
8000660e:	55 4c       	stdsp	sp[0x150],r12
80006610:	80 00       	ld.sh	r0,r0[0x0]
80006612:	6d f0       	ld.w	r0,r6[0x7c]
80006614:	00 00       	add	r0,r0
80006616:	41 10       	lddsp	r0,sp[0x44]
80006618:	80 00       	ld.sh	r0,r0[0x0]
8000661a:	58 a0       	cp.w	r0,10

8000661c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000661c:	d4 31       	pushm	r0-r7,lr
8000661e:	fa cd 02 0c 	sub	sp,sp,524
80006622:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006624:	e0 6a 01 00 	mov	r10,256
80006628:	30 0b       	mov	r11,0
8000662a:	fa cc fe f4 	sub	r12,sp,-268
8000662e:	f0 1f 00 4c 	mcall	8000675c <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80006632:	fa c4 fd d0 	sub	r4,sp,-560
80006636:	30 0a       	mov	r10,0
80006638:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000663a:	fa c3 ff fc 	sub	r3,sp,-4
8000663e:	e0 61 01 00 	mov	r1,256
80006642:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006644:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006646:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000664a:	02 9a       	mov	r10,r1
8000664c:	00 9b       	mov	r11,r0
8000664e:	06 9c       	mov	r12,r3
80006650:	f0 1f 00 43 	mcall	8000675c <logFromISR+0x140>
			
			if(*str == '%')
80006654:	0f 88       	ld.ub	r8,r7[0x0]
80006656:	e4 08 18 00 	cp.b	r8,r2
8000665a:	c5 11       	brne	800066fc <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000665c:	ee c8 ff ff 	sub	r8,r7,-1
80006660:	11 89       	ld.ub	r9,r8[0x0]
80006662:	4c 0a       	lddpc	r10,80006760 <logFromISR+0x144>
80006664:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006666:	23 09       	sub	r9,48
80006668:	30 9a       	mov	r10,9
8000666a:	f4 09 18 00 	cp.b	r9,r10
8000666e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006672:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006676:	f7 b9 08 30 	subls	r9,48
8000667a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000667e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006682:	0f 88       	ld.ub	r8,r7[0x0]
80006684:	22 58       	sub	r8,37
80006686:	e0 48 00 53 	cp.w	r8,83
8000668a:	e0 8b 00 2b 	brhi	800066e0 <logFromISR+0xc4>
8000668e:	4b 69       	lddpc	r9,80006764 <logFromISR+0x148>
80006690:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80006694:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80006698:	06 9a       	mov	r10,r3
8000669a:	40 0b       	lddsp	r11,sp[0x0]
8000669c:	5c 5b       	castu.b	r11
8000669e:	68 0c       	ld.w	r12,r4[0x0]
800066a0:	f0 1f 00 32 	mcall	80006768 <logFromISR+0x14c>
					break;
800066a4:	c2 38       	rjmp	800066ea <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
800066a6:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
800066aa:	06 9a       	mov	r10,r3
800066ac:	40 0b       	lddsp	r11,sp[0x0]
800066ae:	5c 5b       	castu.b	r11
800066b0:	68 0c       	ld.w	r12,r4[0x0]
800066b2:	f0 1f 00 2f 	mcall	8000676c <logFromISR+0x150>
800066b6:	06 9c       	mov	r12,r3
					break;
800066b8:	c1 98       	rjmp	800066ea <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800066ba:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800066be:	06 9b       	mov	r11,r3
800066c0:	09 bc       	ld.ub	r12,r4[0x3]
800066c2:	f0 1f 00 2c 	mcall	80006770 <logFromISR+0x154>
800066c6:	06 9c       	mov	r12,r3
					break;
800066c8:	c1 18       	rjmp	800066ea <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800066ca:	e8 c5 ff fc 	sub	r5,r4,-4
800066ce:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800066d0:	c0 d8       	rjmp	800066ea <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800066d2:	06 9b       	mov	r11,r3
800066d4:	32 5c       	mov	r12,37
800066d6:	f0 1f 00 27 	mcall	80006770 <logFromISR+0x154>
800066da:	08 95       	mov	r5,r4
800066dc:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800066de:	c0 68       	rjmp	800066ea <logFromISR+0xce>
					default:
					log("I need relax.");
800066e0:	4a 5c       	lddpc	r12,80006774 <logFromISR+0x158>
800066e2:	f0 1f 00 26 	mcall	80006778 <logFromISR+0x15c>
800066e6:	08 95       	mov	r5,r4
800066e8:	06 9c       	mov	r12,r3
				}
				str++;
800066ea:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800066ec:	1a dc       	st.w	--sp,r12
800066ee:	1a d6       	st.w	--sp,r6
800066f0:	4a 3b       	lddpc	r11,8000677c <logFromISR+0x160>
800066f2:	0c 9c       	mov	r12,r6
800066f4:	f0 1f 00 23 	mcall	80006780 <logFromISR+0x164>
800066f8:	2f ed       	sub	sp,-8
800066fa:	c0 a8       	rjmp	8000670e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800066fc:	2f f7       	sub	r7,-1
800066fe:	1a d8       	st.w	--sp,r8
80006700:	1a d6       	st.w	--sp,r6
80006702:	4a 1b       	lddpc	r11,80006784 <logFromISR+0x168>
80006704:	0c 9c       	mov	r12,r6
80006706:	f0 1f 00 1f 	mcall	80006780 <logFromISR+0x164>
8000670a:	08 95       	mov	r5,r4
8000670c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000670e:	0f 89       	ld.ub	r9,r7[0x0]
80006710:	30 08       	mov	r8,0
80006712:	f0 09 18 00 	cp.b	r9,r8
80006716:	c0 30       	breq	8000671c <logFromISR+0x100>
80006718:	0a 94       	mov	r4,r5
8000671a:	c9 8b       	rjmp	8000664a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000671c:	fa c7 fe f4 	sub	r7,sp,-268
80006720:	1a d7       	st.w	--sp,r7
80006722:	49 ab       	lddpc	r11,80006788 <logFromISR+0x16c>
80006724:	0e 9c       	mov	r12,r7
80006726:	f0 1f 00 17 	mcall	80006780 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000672a:	5c 5c       	castu.b	r12
8000672c:	f8 c6 ff ff 	sub	r6,r12,-1
80006730:	0c 9c       	mov	r12,r6
80006732:	f0 1f 00 17 	mcall	8000678c <logFromISR+0x170>
80006736:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80006738:	0c 9a       	mov	r10,r6
8000673a:	0e 9b       	mov	r11,r7
8000673c:	f0 1f 00 15 	mcall	80006790 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80006740:	30 09       	mov	r9,0
80006742:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80006744:	fa ca fe f8 	sub	r10,sp,-264
80006748:	fa cb fe f4 	sub	r11,sp,-268
8000674c:	49 28       	lddpc	r8,80006794 <logFromISR+0x178>
8000674e:	70 0c       	ld.w	r12,r8[0x0]
80006750:	f0 1f 00 12 	mcall	80006798 <logFromISR+0x17c>
80006754:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80006756:	fe 3d fd f4 	sub	sp,-524
8000675a:	d8 32       	popm	r0-r7,pc
8000675c:	80 00       	ld.sh	r0,r0[0x0]
8000675e:	6f 38       	ld.w	r8,r7[0x4c]
80006760:	00 00       	add	r0,r0
80006762:	0d 6d       	ld.uh	sp,--r6
80006764:	80 00       	ld.sh	r0,r0[0x0]
80006766:	d6 20       	acall	0x62
80006768:	80 00       	ld.sh	r0,r0[0x0]
8000676a:	63 b6       	ld.w	r6,r1[0x6c]
8000676c:	80 00       	ld.sh	r0,r0[0x0]
8000676e:	63 04       	ld.w	r4,r1[0x40]
80006770:	80 00       	ld.sh	r0,r0[0x0]
80006772:	63 00       	ld.w	r0,r1[0x40]
80006774:	80 00       	ld.sh	r0,r0[0x0]
80006776:	d7 8c       	*unknown*
80006778:	80 00       	ld.sh	r0,r0[0x0]
8000677a:	64 90       	ld.w	r0,r2[0x24]
8000677c:	80 00       	ld.sh	r0,r0[0x0]
8000677e:	d7 9c       	*unknown*
80006780:	80 00       	ld.sh	r0,r0[0x0]
80006782:	72 28       	ld.w	r8,r9[0x8]
80006784:	80 00       	ld.sh	r0,r0[0x0]
80006786:	d7 a4       	*unknown*
80006788:	80 00       	ld.sh	r0,r0[0x0]
8000678a:	d7 ac       	*unknown*
8000678c:	80 00       	ld.sh	r0,r0[0x0]
8000678e:	55 4c       	stdsp	sp[0x150],r12
80006790:	80 00       	ld.sh	r0,r0[0x0]
80006792:	6d f0       	ld.w	r0,r6[0x7c]
80006794:	00 00       	add	r0,r0
80006796:	41 10       	lddsp	r0,sp[0x44]
80006798:	80 00       	ld.sh	r0,r0[0x0]
8000679a:	58 50       	cp.w	r0,5

8000679c <log_init>:
		
	return str;
}

void log_init(void)
{
8000679c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000679e:	30 2b       	mov	r11,2
800067a0:	49 0c       	lddpc	r12,800067e0 <log_init+0x44>
800067a2:	f0 1f 00 11 	mcall	800067e4 <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
800067a6:	e0 6a 36 00 	mov	r10,13824
800067aa:	ea 1a 01 6e 	orh	r10,0x16e
800067ae:	48 fb       	lddpc	r11,800067e8 <log_init+0x4c>
800067b0:	fe 7c 18 00 	mov	r12,-59392
800067b4:	f0 1f 00 0e 	mcall	800067ec <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800067b8:	30 4b       	mov	r11,4
800067ba:	33 2c       	mov	r12,50
800067bc:	f0 1f 00 0d 	mcall	800067f0 <log_init+0x54>
800067c0:	48 d8       	lddpc	r8,800067f4 <log_init+0x58>
800067c2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800067c4:	30 09       	mov	r9,0
800067c6:	1a d9       	st.w	--sp,r9
800067c8:	1a d9       	st.w	--sp,r9
800067ca:	1a d9       	st.w	--sp,r9
800067cc:	30 28       	mov	r8,2
800067ce:	e0 6a 01 80 	mov	r10,384
800067d2:	48 ab       	lddpc	r11,800067f8 <log_init+0x5c>
800067d4:	48 ac       	lddpc	r12,800067fc <log_init+0x60>
800067d6:	f0 1f 00 0b 	mcall	80006800 <log_init+0x64>
800067da:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800067dc:	d8 02       	popm	pc
800067de:	00 00       	add	r0,r0
800067e0:	80 00       	ld.sh	r0,r0[0x0]
800067e2:	d7 b8       	*unknown*
800067e4:	80 00       	ld.sh	r0,r0[0x0]
800067e6:	69 28       	ld.w	r8,r4[0x48]
800067e8:	80 00       	ld.sh	r0,r0[0x0]
800067ea:	d7 70       	acall	0x77
800067ec:	80 00       	ld.sh	r0,r0[0x0]
800067ee:	50 f0       	stdsp	sp[0x3c],r0
800067f0:	80 00       	ld.sh	r0,r0[0x0]
800067f2:	59 f8       	cp.w	r8,31
800067f4:	00 00       	add	r0,r0
800067f6:	41 10       	lddsp	r0,sp[0x44]
800067f8:	80 00       	ld.sh	r0,r0[0x0]
800067fa:	d7 b4       	*unknown*
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	68 04       	ld.w	r4,r4[0x0]
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	60 cc       	ld.w	r12,r0[0x30]

80006804 <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80006804:	eb cd 40 f8 	pushm	r3-r7,lr
80006808:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000680a:	48 c7       	lddpc	r7,80006838 <task_log+0x34>
8000680c:	30 05       	mov	r5,0
8000680e:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80006810:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80006814:	0a 99       	mov	r9,r5
80006816:	08 9a       	mov	r10,r4
80006818:	1a 9b       	mov	r11,sp
8000681a:	6e 0c       	ld.w	r12,r7[0x0]
8000681c:	f0 1f 00 08 	mcall	8000683c <task_log+0x38>
80006820:	58 1c       	cp.w	r12,1
80006822:	cf 91       	brne	80006814 <task_log+0x10>
		{
			if( NULL != str)
80006824:	40 0b       	lddsp	r11,sp[0x0]
80006826:	58 0b       	cp.w	r11,0
80006828:	cf 60       	breq	80006814 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
8000682a:	06 9c       	mov	r12,r3
8000682c:	f0 1f 00 05 	mcall	80006840 <task_log+0x3c>
				vPortFree(str);
80006830:	40 0c       	lddsp	r12,sp[0x0]
80006832:	f0 1f 00 05 	mcall	80006844 <task_log+0x40>
80006836:	ce fb       	rjmp	80006814 <task_log+0x10>
80006838:	00 00       	add	r0,r0
8000683a:	41 10       	lddsp	r0,sp[0x44]
8000683c:	80 00       	ld.sh	r0,r0[0x0]
8000683e:	56 94       	stdsp	sp[0x1a4],r4
80006840:	80 00       	ld.sh	r0,r0[0x0]
80006842:	50 a0       	stdsp	sp[0x28],r0
80006844:	80 00       	ld.sh	r0,r0[0x0]
80006846:	55 24       	stdsp	sp[0x148],r4

80006848 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80006848:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
8000684a:	fe 78 10 00 	mov	r8,-61440
8000684e:	30 19       	mov	r9,1
80006850:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80006854:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80006858:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
8000685c:	d3 03       	ssrf	0x10
	local_start_pll0();
8000685e:	f0 1f 00 13 	mcall	800068a8 <main+0x60>
		
	INTC_init_interrupts();
80006862:	f0 1f 00 13 	mcall	800068ac <main+0x64>
	
	log_init();		
80006866:	f0 1f 00 13 	mcall	800068b0 <main+0x68>
	log("----start debug----");	
8000686a:	49 3c       	lddpc	r12,800068b4 <main+0x6c>
8000686c:	f0 1f 00 13 	mcall	800068b8 <main+0x70>
		
	rtc_init();
80006870:	f0 1f 00 13 	mcall	800068bc <main+0x74>
	
	//fs_init();//65795机器无法通过文件系统初始化

	tc_init();	
80006874:	f0 1f 00 13 	mcall	800068c0 <main+0x78>
			
	xcmp_init();
80006878:	f0 1f 00 13 	mcall	800068c4 <main+0x7c>
	
	app_init();
8000687c:	f0 1f 00 13 	mcall	800068c8 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80006880:	fe 79 10 00 	mov	r9,-61440
80006884:	f2 f8 01 60 	ld.w	r8,r9[352]
80006888:	e2 18 00 02 	andl	r8,0x2,COH
8000688c:	cf c0       	breq	80006884 <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
8000688e:	fe 79 10 00 	mov	r9,-61440
80006892:	f2 f8 01 60 	ld.w	r8,r9[352]
80006896:	e2 18 00 02 	andl	r8,0x2,COH
8000689a:	cf c1       	brne	80006892 <main+0x4a>
	local_start_timer();
8000689c:	f0 1f 00 0c 	mcall	800068cc <main+0x84>
	
	Enable_global_interrupt();
800068a0:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
800068a2:	f0 1f 00 0c 	mcall	800068d0 <main+0x88>
	return 0;
}
800068a6:	d8 0a       	popm	pc,r12=0
800068a8:	80 00       	ld.sh	r0,r0[0x0]
800068aa:	49 c0       	lddpc	r0,80006918 <gpio_enable_module_pin+0x44>
800068ac:	80 00       	ld.sh	r0,r0[0x0]
800068ae:	4b dc       	lddpc	r12,800069a0 <free+0x8>
800068b0:	80 00       	ld.sh	r0,r0[0x0]
800068b2:	67 9c       	ld.w	r12,r3[0x64]
800068b4:	80 00       	ld.sh	r0,r0[0x0]
800068b6:	d7 c8       	*unknown*
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	64 90       	ld.w	r0,r2[0x24]
800068bc:	80 00       	ld.sh	r0,r0[0x0]
800068be:	4a 10       	lddpc	r0,80006940 <gpio_enable_module+0x18>
800068c0:	80 00       	ld.sh	r0,r0[0x0]
800068c2:	4a d8       	lddpc	r8,80006974 <idata_load_loop>
800068c4:	80 00       	ld.sh	r0,r0[0x0]
800068c6:	42 c4       	lddsp	r4,sp[0xb0]
800068c8:	80 00       	ld.sh	r0,r0[0x0]
800068ca:	20 40       	sub	r0,4
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	4a 9c       	lddpc	r12,80006970 <_stext+0x18>
800068d0:	80 00       	ld.sh	r0,r0[0x0]
800068d2:	62 b4       	ld.w	r4,r1[0x2c]

800068d4 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800068d4:	f8 08 16 05 	lsr	r8,r12,0x5
800068d8:	a9 68       	lsl	r8,0x8
800068da:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800068de:	58 1b       	cp.w	r11,1
800068e0:	c0 d0       	breq	800068fa <gpio_enable_module_pin+0x26>
800068e2:	c0 63       	brcs	800068ee <gpio_enable_module_pin+0x1a>
800068e4:	58 2b       	cp.w	r11,2
800068e6:	c1 00       	breq	80006906 <gpio_enable_module_pin+0x32>
800068e8:	58 3b       	cp.w	r11,3
800068ea:	c1 40       	breq	80006912 <gpio_enable_module_pin+0x3e>
800068ec:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800068ee:	30 19       	mov	r9,1
800068f0:	f2 0c 09 49 	lsl	r9,r9,r12
800068f4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800068f6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800068f8:	c1 28       	rjmp	8000691c <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800068fa:	30 19       	mov	r9,1
800068fc:	f2 0c 09 49 	lsl	r9,r9,r12
80006900:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006902:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006904:	c0 c8       	rjmp	8000691c <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006906:	30 19       	mov	r9,1
80006908:	f2 0c 09 49 	lsl	r9,r9,r12
8000690c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000690e:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80006910:	c0 68       	rjmp	8000691c <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006912:	30 19       	mov	r9,1
80006914:	f2 0c 09 49 	lsl	r9,r9,r12
80006918:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000691a:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000691c:	30 19       	mov	r9,1
8000691e:	f2 0c 09 4c 	lsl	r12,r9,r12
80006922:	91 2c       	st.w	r8[0x8],r12
80006924:	5e fd       	retal	0
80006926:	d7 03       	nop

80006928 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006928:	d4 21       	pushm	r4-r7,lr
8000692a:	18 97       	mov	r7,r12
8000692c:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000692e:	58 0b       	cp.w	r11,0
80006930:	c0 31       	brne	80006936 <gpio_enable_module+0xe>
80006932:	30 05       	mov	r5,0
80006934:	c0 d8       	rjmp	8000694e <gpio_enable_module+0x26>
80006936:	30 06       	mov	r6,0
80006938:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000693a:	6e 1b       	ld.w	r11,r7[0x4]
8000693c:	6e 0c       	ld.w	r12,r7[0x0]
8000693e:	f0 1f 00 06 	mcall	80006954 <gpio_enable_module+0x2c>
80006942:	18 45       	or	r5,r12
		gpiomap++;
80006944:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006946:	2f f6       	sub	r6,-1
80006948:	0c 34       	cp.w	r4,r6
8000694a:	fe 9b ff f8 	brhi	8000693a <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000694e:	0a 9c       	mov	r12,r5
80006950:	d8 22       	popm	r4-r7,pc
80006952:	00 00       	add	r0,r0
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	68 d4       	ld.w	r4,r4[0x34]

80006958 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006958:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
8000695c:	fe c0 a5 5c 	sub	r0,pc,-23204

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006960:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006964:	d5 53       	csrf	0x15
  cp      r0, r1
80006966:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006968:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
8000696c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
8000696e:	c0 72       	brcc	8000697c <idata_load_loop_end>
  cp      r0, r1
80006970:	fe c2 8c 10 	sub	r2,pc,-29680

80006974 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006974:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80006976:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80006978:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000697a:	cf d3       	brcs	80006974 <idata_load_loop>

8000697c <idata_load_loop_end>:
  mov     r2, 0
8000697c:	e0 60 0a 40 	mov	r0,2624
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006980:	e0 61 41 18 	mov	r1,16664
  cp      r0, r1
  brlo    udata_clear_loop
80006984:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006986:	c0 62       	brcc	80006992 <udata_clear_loop_end>
80006988:	30 02       	mov	r2,0
8000698a:	30 03       	mov	r3,0

8000698c <udata_clear_loop>:
8000698c:	a1 22       	st.d	r0++,r2
8000698e:	02 30       	cp.w	r0,r1
80006990:	cf e3       	brcs	8000698c <udata_clear_loop>

80006992 <udata_clear_loop_end>:
80006992:	fe cf 01 4a 	sub	pc,pc,330
80006996:	d7 03       	nop

80006998 <free>:
80006998:	d4 01       	pushm	lr
8000699a:	e0 68 0a 38 	mov	r8,2616
8000699e:	18 9b       	mov	r11,r12
800069a0:	70 0c       	ld.w	r12,r8[0x0]
800069a2:	e0 a0 1e 6d 	rcall	8000a67c <_free_r>
800069a6:	d8 02       	popm	pc

800069a8 <malloc>:
800069a8:	d4 01       	pushm	lr
800069aa:	e0 68 0a 38 	mov	r8,2616
800069ae:	18 9b       	mov	r11,r12
800069b0:	70 0c       	ld.w	r12,r8[0x0]
800069b2:	c0 3c       	rcall	800069b8 <_malloc_r>
800069b4:	d8 02       	popm	pc
800069b6:	d7 03       	nop

800069b8 <_malloc_r>:
800069b8:	d4 31       	pushm	r0-r7,lr
800069ba:	f6 c8 ff f5 	sub	r8,r11,-11
800069be:	18 95       	mov	r5,r12
800069c0:	10 97       	mov	r7,r8
800069c2:	e0 17 ff f8 	andl	r7,0xfff8
800069c6:	59 68       	cp.w	r8,22
800069c8:	f9 b7 08 10 	movls	r7,16
800069cc:	16 37       	cp.w	r7,r11
800069ce:	5f 38       	srlo	r8
800069d0:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800069d4:	c0 50       	breq	800069de <_malloc_r+0x26>
800069d6:	30 c8       	mov	r8,12
800069d8:	99 38       	st.w	r12[0xc],r8
800069da:	e0 8f 01 fa 	bral	80006dce <_malloc_r+0x416>
800069de:	fe b0 f5 59 	rcall	80005490 <__malloc_lock>
800069e2:	e0 47 01 f7 	cp.w	r7,503
800069e6:	e0 8b 00 1d 	brhi	80006a20 <_malloc_r+0x68>
800069ea:	ee 03 16 03 	lsr	r3,r7,0x3
800069ee:	e0 68 05 38 	mov	r8,1336
800069f2:	f0 03 00 38 	add	r8,r8,r3<<0x3
800069f6:	70 36       	ld.w	r6,r8[0xc]
800069f8:	10 36       	cp.w	r6,r8
800069fa:	c0 61       	brne	80006a06 <_malloc_r+0x4e>
800069fc:	ec c8 ff f8 	sub	r8,r6,-8
80006a00:	70 36       	ld.w	r6,r8[0xc]
80006a02:	10 36       	cp.w	r6,r8
80006a04:	c0 c0       	breq	80006a1c <_malloc_r+0x64>
80006a06:	6c 18       	ld.w	r8,r6[0x4]
80006a08:	e0 18 ff fc 	andl	r8,0xfffc
80006a0c:	6c 3a       	ld.w	r10,r6[0xc]
80006a0e:	ec 08 00 09 	add	r9,r6,r8
80006a12:	0a 9c       	mov	r12,r5
80006a14:	6c 28       	ld.w	r8,r6[0x8]
80006a16:	95 28       	st.w	r10[0x8],r8
80006a18:	91 3a       	st.w	r8[0xc],r10
80006a1a:	c4 78       	rjmp	80006aa8 <_malloc_r+0xf0>
80006a1c:	2f e3       	sub	r3,-2
80006a1e:	c4 d8       	rjmp	80006ab8 <_malloc_r+0x100>
80006a20:	ee 03 16 09 	lsr	r3,r7,0x9
80006a24:	c0 41       	brne	80006a2c <_malloc_r+0x74>
80006a26:	ee 03 16 03 	lsr	r3,r7,0x3
80006a2a:	c2 68       	rjmp	80006a76 <_malloc_r+0xbe>
80006a2c:	58 43       	cp.w	r3,4
80006a2e:	e0 8b 00 06 	brhi	80006a3a <_malloc_r+0x82>
80006a32:	ee 03 16 06 	lsr	r3,r7,0x6
80006a36:	2c 83       	sub	r3,-56
80006a38:	c1 f8       	rjmp	80006a76 <_malloc_r+0xbe>
80006a3a:	59 43       	cp.w	r3,20
80006a3c:	e0 8b 00 04 	brhi	80006a44 <_malloc_r+0x8c>
80006a40:	2a 53       	sub	r3,-91
80006a42:	c1 a8       	rjmp	80006a76 <_malloc_r+0xbe>
80006a44:	e0 43 00 54 	cp.w	r3,84
80006a48:	e0 8b 00 06 	brhi	80006a54 <_malloc_r+0x9c>
80006a4c:	ee 03 16 0c 	lsr	r3,r7,0xc
80006a50:	29 23       	sub	r3,-110
80006a52:	c1 28       	rjmp	80006a76 <_malloc_r+0xbe>
80006a54:	e0 43 01 54 	cp.w	r3,340
80006a58:	e0 8b 00 06 	brhi	80006a64 <_malloc_r+0xac>
80006a5c:	ee 03 16 0f 	lsr	r3,r7,0xf
80006a60:	28 93       	sub	r3,-119
80006a62:	c0 a8       	rjmp	80006a76 <_malloc_r+0xbe>
80006a64:	e0 43 05 54 	cp.w	r3,1364
80006a68:	e0 88 00 04 	brls	80006a70 <_malloc_r+0xb8>
80006a6c:	37 e3       	mov	r3,126
80006a6e:	c0 48       	rjmp	80006a76 <_malloc_r+0xbe>
80006a70:	ee 03 16 12 	lsr	r3,r7,0x12
80006a74:	28 43       	sub	r3,-124
80006a76:	e0 6a 05 38 	mov	r10,1336
80006a7a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006a7e:	74 36       	ld.w	r6,r10[0xc]
80006a80:	c1 98       	rjmp	80006ab2 <_malloc_r+0xfa>
80006a82:	6c 19       	ld.w	r9,r6[0x4]
80006a84:	e0 19 ff fc 	andl	r9,0xfffc
80006a88:	f2 07 01 0b 	sub	r11,r9,r7
80006a8c:	58 fb       	cp.w	r11,15
80006a8e:	e0 8a 00 04 	brle	80006a96 <_malloc_r+0xde>
80006a92:	20 13       	sub	r3,1
80006a94:	c1 18       	rjmp	80006ab6 <_malloc_r+0xfe>
80006a96:	6c 38       	ld.w	r8,r6[0xc]
80006a98:	58 0b       	cp.w	r11,0
80006a9a:	c0 b5       	brlt	80006ab0 <_malloc_r+0xf8>
80006a9c:	6c 2a       	ld.w	r10,r6[0x8]
80006a9e:	ec 09 00 09 	add	r9,r6,r9
80006aa2:	0a 9c       	mov	r12,r5
80006aa4:	91 2a       	st.w	r8[0x8],r10
80006aa6:	95 38       	st.w	r10[0xc],r8
80006aa8:	72 18       	ld.w	r8,r9[0x4]
80006aaa:	a1 a8       	sbr	r8,0x0
80006aac:	93 18       	st.w	r9[0x4],r8
80006aae:	cb c8       	rjmp	80006c26 <_malloc_r+0x26e>
80006ab0:	10 96       	mov	r6,r8
80006ab2:	14 36       	cp.w	r6,r10
80006ab4:	ce 71       	brne	80006a82 <_malloc_r+0xca>
80006ab6:	2f f3       	sub	r3,-1
80006ab8:	e0 6a 05 38 	mov	r10,1336
80006abc:	f4 cc ff f8 	sub	r12,r10,-8
80006ac0:	78 26       	ld.w	r6,r12[0x8]
80006ac2:	18 36       	cp.w	r6,r12
80006ac4:	c6 c0       	breq	80006b9c <_malloc_r+0x1e4>
80006ac6:	6c 19       	ld.w	r9,r6[0x4]
80006ac8:	e0 19 ff fc 	andl	r9,0xfffc
80006acc:	f2 07 01 08 	sub	r8,r9,r7
80006ad0:	58 f8       	cp.w	r8,15
80006ad2:	e0 89 00 8f 	brgt	80006bf0 <_malloc_r+0x238>
80006ad6:	99 3c       	st.w	r12[0xc],r12
80006ad8:	99 2c       	st.w	r12[0x8],r12
80006ada:	58 08       	cp.w	r8,0
80006adc:	c0 55       	brlt	80006ae6 <_malloc_r+0x12e>
80006ade:	ec 09 00 09 	add	r9,r6,r9
80006ae2:	0a 9c       	mov	r12,r5
80006ae4:	ce 2b       	rjmp	80006aa8 <_malloc_r+0xf0>
80006ae6:	e0 49 01 ff 	cp.w	r9,511
80006aea:	e0 8b 00 13 	brhi	80006b10 <_malloc_r+0x158>
80006aee:	a3 99       	lsr	r9,0x3
80006af0:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006af4:	70 2b       	ld.w	r11,r8[0x8]
80006af6:	8d 38       	st.w	r6[0xc],r8
80006af8:	8d 2b       	st.w	r6[0x8],r11
80006afa:	97 36       	st.w	r11[0xc],r6
80006afc:	91 26       	st.w	r8[0x8],r6
80006afe:	a3 49       	asr	r9,0x2
80006b00:	74 18       	ld.w	r8,r10[0x4]
80006b02:	30 1b       	mov	r11,1
80006b04:	f6 09 09 49 	lsl	r9,r11,r9
80006b08:	f1 e9 10 09 	or	r9,r8,r9
80006b0c:	95 19       	st.w	r10[0x4],r9
80006b0e:	c4 78       	rjmp	80006b9c <_malloc_r+0x1e4>
80006b10:	f2 0a 16 09 	lsr	r10,r9,0x9
80006b14:	58 4a       	cp.w	r10,4
80006b16:	e0 8b 00 07 	brhi	80006b24 <_malloc_r+0x16c>
80006b1a:	f2 0a 16 06 	lsr	r10,r9,0x6
80006b1e:	2c 8a       	sub	r10,-56
80006b20:	c2 08       	rjmp	80006b60 <_malloc_r+0x1a8>
80006b22:	d7 03       	nop
80006b24:	59 4a       	cp.w	r10,20
80006b26:	e0 8b 00 04 	brhi	80006b2e <_malloc_r+0x176>
80006b2a:	2a 5a       	sub	r10,-91
80006b2c:	c1 a8       	rjmp	80006b60 <_malloc_r+0x1a8>
80006b2e:	e0 4a 00 54 	cp.w	r10,84
80006b32:	e0 8b 00 06 	brhi	80006b3e <_malloc_r+0x186>
80006b36:	f2 0a 16 0c 	lsr	r10,r9,0xc
80006b3a:	29 2a       	sub	r10,-110
80006b3c:	c1 28       	rjmp	80006b60 <_malloc_r+0x1a8>
80006b3e:	e0 4a 01 54 	cp.w	r10,340
80006b42:	e0 8b 00 06 	brhi	80006b4e <_malloc_r+0x196>
80006b46:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006b4a:	28 9a       	sub	r10,-119
80006b4c:	c0 a8       	rjmp	80006b60 <_malloc_r+0x1a8>
80006b4e:	e0 4a 05 54 	cp.w	r10,1364
80006b52:	e0 88 00 04 	brls	80006b5a <_malloc_r+0x1a2>
80006b56:	37 ea       	mov	r10,126
80006b58:	c0 48       	rjmp	80006b60 <_malloc_r+0x1a8>
80006b5a:	f2 0a 16 12 	lsr	r10,r9,0x12
80006b5e:	28 4a       	sub	r10,-124
80006b60:	e0 6b 05 38 	mov	r11,1336
80006b64:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006b68:	68 28       	ld.w	r8,r4[0x8]
80006b6a:	08 38       	cp.w	r8,r4
80006b6c:	c0 e1       	brne	80006b88 <_malloc_r+0x1d0>
80006b6e:	76 19       	ld.w	r9,r11[0x4]
80006b70:	a3 4a       	asr	r10,0x2
80006b72:	30 1e       	mov	lr,1
80006b74:	fc 0a 09 4a 	lsl	r10,lr,r10
80006b78:	f3 ea 10 0a 	or	r10,r9,r10
80006b7c:	10 99       	mov	r9,r8
80006b7e:	97 1a       	st.w	r11[0x4],r10
80006b80:	c0 a8       	rjmp	80006b94 <_malloc_r+0x1dc>
80006b82:	70 28       	ld.w	r8,r8[0x8]
80006b84:	08 38       	cp.w	r8,r4
80006b86:	c0 60       	breq	80006b92 <_malloc_r+0x1da>
80006b88:	70 1a       	ld.w	r10,r8[0x4]
80006b8a:	e0 1a ff fc 	andl	r10,0xfffc
80006b8e:	14 39       	cp.w	r9,r10
80006b90:	cf 93       	brcs	80006b82 <_malloc_r+0x1ca>
80006b92:	70 39       	ld.w	r9,r8[0xc]
80006b94:	8d 39       	st.w	r6[0xc],r9
80006b96:	8d 28       	st.w	r6[0x8],r8
80006b98:	91 36       	st.w	r8[0xc],r6
80006b9a:	93 26       	st.w	r9[0x8],r6
80006b9c:	e6 08 14 02 	asr	r8,r3,0x2
80006ba0:	30 1b       	mov	r11,1
80006ba2:	e0 64 05 38 	mov	r4,1336
80006ba6:	f6 08 09 4b 	lsl	r11,r11,r8
80006baa:	68 18       	ld.w	r8,r4[0x4]
80006bac:	10 3b       	cp.w	r11,r8
80006bae:	e0 8b 00 6b 	brhi	80006c84 <_malloc_r+0x2cc>
80006bb2:	f7 e8 00 09 	and	r9,r11,r8
80006bb6:	c0 b1       	brne	80006bcc <_malloc_r+0x214>
80006bb8:	e0 13 ff fc 	andl	r3,0xfffc
80006bbc:	a1 7b       	lsl	r11,0x1
80006bbe:	2f c3       	sub	r3,-4
80006bc0:	c0 38       	rjmp	80006bc6 <_malloc_r+0x20e>
80006bc2:	2f c3       	sub	r3,-4
80006bc4:	a1 7b       	lsl	r11,0x1
80006bc6:	f7 e8 00 09 	and	r9,r11,r8
80006bca:	cf c0       	breq	80006bc2 <_malloc_r+0x20a>
80006bcc:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006bd0:	06 92       	mov	r2,r3
80006bd2:	1c 91       	mov	r1,lr
80006bd4:	62 36       	ld.w	r6,r1[0xc]
80006bd6:	c2 e8       	rjmp	80006c32 <_malloc_r+0x27a>
80006bd8:	6c 1a       	ld.w	r10,r6[0x4]
80006bda:	e0 1a ff fc 	andl	r10,0xfffc
80006bde:	f4 07 01 08 	sub	r8,r10,r7
80006be2:	58 f8       	cp.w	r8,15
80006be4:	e0 8a 00 15 	brle	80006c0e <_malloc_r+0x256>
80006be8:	6c 3a       	ld.w	r10,r6[0xc]
80006bea:	6c 29       	ld.w	r9,r6[0x8]
80006bec:	95 29       	st.w	r10[0x8],r9
80006bee:	93 3a       	st.w	r9[0xc],r10
80006bf0:	0e 99       	mov	r9,r7
80006bf2:	ec 07 00 07 	add	r7,r6,r7
80006bf6:	a1 a9       	sbr	r9,0x0
80006bf8:	99 37       	st.w	r12[0xc],r7
80006bfa:	99 27       	st.w	r12[0x8],r7
80006bfc:	8d 19       	st.w	r6[0x4],r9
80006bfe:	ee 08 09 08 	st.w	r7[r8],r8
80006c02:	8f 2c       	st.w	r7[0x8],r12
80006c04:	8f 3c       	st.w	r7[0xc],r12
80006c06:	a1 a8       	sbr	r8,0x0
80006c08:	0a 9c       	mov	r12,r5
80006c0a:	8f 18       	st.w	r7[0x4],r8
80006c0c:	c0 d8       	rjmp	80006c26 <_malloc_r+0x26e>
80006c0e:	6c 39       	ld.w	r9,r6[0xc]
80006c10:	58 08       	cp.w	r8,0
80006c12:	c0 f5       	brlt	80006c30 <_malloc_r+0x278>
80006c14:	ec 0a 00 0a 	add	r10,r6,r10
80006c18:	74 18       	ld.w	r8,r10[0x4]
80006c1a:	a1 a8       	sbr	r8,0x0
80006c1c:	0a 9c       	mov	r12,r5
80006c1e:	95 18       	st.w	r10[0x4],r8
80006c20:	6c 28       	ld.w	r8,r6[0x8]
80006c22:	93 28       	st.w	r9[0x8],r8
80006c24:	91 39       	st.w	r8[0xc],r9
80006c26:	fe b0 f4 3b 	rcall	8000549c <__malloc_unlock>
80006c2a:	ec cc ff f8 	sub	r12,r6,-8
80006c2e:	d8 32       	popm	r0-r7,pc
80006c30:	12 96       	mov	r6,r9
80006c32:	02 36       	cp.w	r6,r1
80006c34:	cd 21       	brne	80006bd8 <_malloc_r+0x220>
80006c36:	2f f2       	sub	r2,-1
80006c38:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80006c3c:	c0 30       	breq	80006c42 <_malloc_r+0x28a>
80006c3e:	2f 81       	sub	r1,-8
80006c40:	cc ab       	rjmp	80006bd4 <_malloc_r+0x21c>
80006c42:	1c 98       	mov	r8,lr
80006c44:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006c48:	c0 81       	brne	80006c58 <_malloc_r+0x2a0>
80006c4a:	68 19       	ld.w	r9,r4[0x4]
80006c4c:	f6 08 11 ff 	rsub	r8,r11,-1
80006c50:	f3 e8 00 08 	and	r8,r9,r8
80006c54:	89 18       	st.w	r4[0x4],r8
80006c56:	c0 78       	rjmp	80006c64 <_malloc_r+0x2ac>
80006c58:	f0 c9 00 08 	sub	r9,r8,8
80006c5c:	20 13       	sub	r3,1
80006c5e:	70 08       	ld.w	r8,r8[0x0]
80006c60:	12 38       	cp.w	r8,r9
80006c62:	cf 10       	breq	80006c44 <_malloc_r+0x28c>
80006c64:	a1 7b       	lsl	r11,0x1
80006c66:	68 18       	ld.w	r8,r4[0x4]
80006c68:	10 3b       	cp.w	r11,r8
80006c6a:	e0 8b 00 0d 	brhi	80006c84 <_malloc_r+0x2cc>
80006c6e:	58 0b       	cp.w	r11,0
80006c70:	c0 a0       	breq	80006c84 <_malloc_r+0x2cc>
80006c72:	04 93       	mov	r3,r2
80006c74:	c0 38       	rjmp	80006c7a <_malloc_r+0x2c2>
80006c76:	2f c3       	sub	r3,-4
80006c78:	a1 7b       	lsl	r11,0x1
80006c7a:	f7 e8 00 09 	and	r9,r11,r8
80006c7e:	ca 71       	brne	80006bcc <_malloc_r+0x214>
80006c80:	cf bb       	rjmp	80006c76 <_malloc_r+0x2be>
80006c82:	d7 03       	nop
80006c84:	68 23       	ld.w	r3,r4[0x8]
80006c86:	66 12       	ld.w	r2,r3[0x4]
80006c88:	e0 12 ff fc 	andl	r2,0xfffc
80006c8c:	0e 32       	cp.w	r2,r7
80006c8e:	5f 39       	srlo	r9
80006c90:	e4 07 01 08 	sub	r8,r2,r7
80006c94:	58 f8       	cp.w	r8,15
80006c96:	5f aa       	srle	r10
80006c98:	f5 e9 10 09 	or	r9,r10,r9
80006c9c:	e0 80 00 9a 	breq	80006dd0 <_malloc_r+0x418>
80006ca0:	e0 68 0d 78 	mov	r8,3448
80006ca4:	70 01       	ld.w	r1,r8[0x0]
80006ca6:	e0 68 09 44 	mov	r8,2372
80006caa:	2f 01       	sub	r1,-16
80006cac:	70 08       	ld.w	r8,r8[0x0]
80006cae:	0e 01       	add	r1,r7
80006cb0:	5b f8       	cp.w	r8,-1
80006cb2:	c0 40       	breq	80006cba <_malloc_r+0x302>
80006cb4:	28 11       	sub	r1,-127
80006cb6:	e0 11 ff 80 	andl	r1,0xff80
80006cba:	02 9b       	mov	r11,r1
80006cbc:	0a 9c       	mov	r12,r5
80006cbe:	e0 a0 02 a5 	rcall	80007208 <_sbrk_r>
80006cc2:	18 96       	mov	r6,r12
80006cc4:	5b fc       	cp.w	r12,-1
80006cc6:	c7 50       	breq	80006db0 <_malloc_r+0x3f8>
80006cc8:	e6 02 00 08 	add	r8,r3,r2
80006ccc:	10 3c       	cp.w	r12,r8
80006cce:	c0 32       	brcc	80006cd4 <_malloc_r+0x31c>
80006cd0:	08 33       	cp.w	r3,r4
80006cd2:	c6 f1       	brne	80006db0 <_malloc_r+0x3f8>
80006cd4:	e0 6a 0d 7c 	mov	r10,3452
80006cd8:	74 09       	ld.w	r9,r10[0x0]
80006cda:	e2 09 00 09 	add	r9,r1,r9
80006cde:	95 09       	st.w	r10[0x0],r9
80006ce0:	10 36       	cp.w	r6,r8
80006ce2:	c0 a1       	brne	80006cf6 <_malloc_r+0x33e>
80006ce4:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80006ce8:	c0 71       	brne	80006cf6 <_malloc_r+0x33e>
80006cea:	e2 02 00 02 	add	r2,r1,r2
80006cee:	68 28       	ld.w	r8,r4[0x8]
80006cf0:	a1 a2       	sbr	r2,0x0
80006cf2:	91 12       	st.w	r8[0x4],r2
80006cf4:	c4 f8       	rjmp	80006d92 <_malloc_r+0x3da>
80006cf6:	e0 6a 09 44 	mov	r10,2372
80006cfa:	74 0b       	ld.w	r11,r10[0x0]
80006cfc:	5b fb       	cp.w	r11,-1
80006cfe:	c0 31       	brne	80006d04 <_malloc_r+0x34c>
80006d00:	95 06       	st.w	r10[0x0],r6
80006d02:	c0 78       	rjmp	80006d10 <_malloc_r+0x358>
80006d04:	ec 09 00 09 	add	r9,r6,r9
80006d08:	e0 6a 0d 7c 	mov	r10,3452
80006d0c:	10 19       	sub	r9,r8
80006d0e:	95 09       	st.w	r10[0x0],r9
80006d10:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006d14:	f0 09 11 08 	rsub	r9,r8,8
80006d18:	58 08       	cp.w	r8,0
80006d1a:	f2 08 17 10 	movne	r8,r9
80006d1e:	ed d8 e1 06 	addne	r6,r6,r8
80006d22:	28 08       	sub	r8,-128
80006d24:	ec 01 00 01 	add	r1,r6,r1
80006d28:	0a 9c       	mov	r12,r5
80006d2a:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80006d2e:	f0 01 01 01 	sub	r1,r8,r1
80006d32:	02 9b       	mov	r11,r1
80006d34:	e0 a0 02 6a 	rcall	80007208 <_sbrk_r>
80006d38:	e0 68 0d 7c 	mov	r8,3452
80006d3c:	5b fc       	cp.w	r12,-1
80006d3e:	ec 0c 17 00 	moveq	r12,r6
80006d42:	f9 b1 00 00 	moveq	r1,0
80006d46:	70 09       	ld.w	r9,r8[0x0]
80006d48:	0c 1c       	sub	r12,r6
80006d4a:	89 26       	st.w	r4[0x8],r6
80006d4c:	02 0c       	add	r12,r1
80006d4e:	12 01       	add	r1,r9
80006d50:	a1 ac       	sbr	r12,0x0
80006d52:	91 01       	st.w	r8[0x0],r1
80006d54:	8d 1c       	st.w	r6[0x4],r12
80006d56:	08 33       	cp.w	r3,r4
80006d58:	c1 d0       	breq	80006d92 <_malloc_r+0x3da>
80006d5a:	58 f2       	cp.w	r2,15
80006d5c:	e0 8b 00 05 	brhi	80006d66 <_malloc_r+0x3ae>
80006d60:	30 18       	mov	r8,1
80006d62:	8d 18       	st.w	r6[0x4],r8
80006d64:	c2 68       	rjmp	80006db0 <_malloc_r+0x3f8>
80006d66:	30 59       	mov	r9,5
80006d68:	20 c2       	sub	r2,12
80006d6a:	e0 12 ff f8 	andl	r2,0xfff8
80006d6e:	e6 02 00 08 	add	r8,r3,r2
80006d72:	91 29       	st.w	r8[0x8],r9
80006d74:	91 19       	st.w	r8[0x4],r9
80006d76:	66 18       	ld.w	r8,r3[0x4]
80006d78:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d7c:	e5 e8 10 08 	or	r8,r2,r8
80006d80:	87 18       	st.w	r3[0x4],r8
80006d82:	58 f2       	cp.w	r2,15
80006d84:	e0 88 00 07 	brls	80006d92 <_malloc_r+0x3da>
80006d88:	e6 cb ff f8 	sub	r11,r3,-8
80006d8c:	0a 9c       	mov	r12,r5
80006d8e:	e0 a0 1c 77 	rcall	8000a67c <_free_r>
80006d92:	e0 69 0d 74 	mov	r9,3444
80006d96:	72 0a       	ld.w	r10,r9[0x0]
80006d98:	e0 68 0d 7c 	mov	r8,3452
80006d9c:	70 08       	ld.w	r8,r8[0x0]
80006d9e:	14 38       	cp.w	r8,r10
80006da0:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006da4:	e0 69 0d 70 	mov	r9,3440
80006da8:	72 0a       	ld.w	r10,r9[0x0]
80006daa:	14 38       	cp.w	r8,r10
80006dac:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006db0:	68 28       	ld.w	r8,r4[0x8]
80006db2:	70 18       	ld.w	r8,r8[0x4]
80006db4:	e0 18 ff fc 	andl	r8,0xfffc
80006db8:	0e 38       	cp.w	r8,r7
80006dba:	5f 39       	srlo	r9
80006dbc:	0e 18       	sub	r8,r7
80006dbe:	58 f8       	cp.w	r8,15
80006dc0:	5f aa       	srle	r10
80006dc2:	f5 e9 10 09 	or	r9,r10,r9
80006dc6:	c0 50       	breq	80006dd0 <_malloc_r+0x418>
80006dc8:	0a 9c       	mov	r12,r5
80006dca:	fe b0 f3 69 	rcall	8000549c <__malloc_unlock>
80006dce:	d8 3a       	popm	r0-r7,pc,r12=0
80006dd0:	68 26       	ld.w	r6,r4[0x8]
80006dd2:	a1 a8       	sbr	r8,0x0
80006dd4:	0e 99       	mov	r9,r7
80006dd6:	a1 a9       	sbr	r9,0x0
80006dd8:	8d 19       	st.w	r6[0x4],r9
80006dda:	ec 07 00 07 	add	r7,r6,r7
80006dde:	0a 9c       	mov	r12,r5
80006de0:	89 27       	st.w	r4[0x8],r7
80006de2:	8f 18       	st.w	r7[0x4],r8
80006de4:	fe b0 f3 5c 	rcall	8000549c <__malloc_unlock>
80006de8:	ec cc ff f8 	sub	r12,r6,-8
80006dec:	d8 32       	popm	r0-r7,pc
80006dee:	d7 03       	nop

80006df0 <memcpy>:
80006df0:	58 8a       	cp.w	r10,8
80006df2:	c2 f5       	brlt	80006e50 <memcpy+0x60>
80006df4:	f9 eb 10 09 	or	r9,r12,r11
80006df8:	e2 19 00 03 	andl	r9,0x3,COH
80006dfc:	e0 81 00 97 	brne	80006f2a <memcpy+0x13a>
80006e00:	e0 4a 00 20 	cp.w	r10,32
80006e04:	c3 b4       	brge	80006e7a <memcpy+0x8a>
80006e06:	f4 08 14 02 	asr	r8,r10,0x2
80006e0a:	f0 09 11 08 	rsub	r9,r8,8
80006e0e:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80006e12:	76 69       	ld.w	r9,r11[0x18]
80006e14:	99 69       	st.w	r12[0x18],r9
80006e16:	76 59       	ld.w	r9,r11[0x14]
80006e18:	99 59       	st.w	r12[0x14],r9
80006e1a:	76 49       	ld.w	r9,r11[0x10]
80006e1c:	99 49       	st.w	r12[0x10],r9
80006e1e:	76 39       	ld.w	r9,r11[0xc]
80006e20:	99 39       	st.w	r12[0xc],r9
80006e22:	76 29       	ld.w	r9,r11[0x8]
80006e24:	99 29       	st.w	r12[0x8],r9
80006e26:	76 19       	ld.w	r9,r11[0x4]
80006e28:	99 19       	st.w	r12[0x4],r9
80006e2a:	76 09       	ld.w	r9,r11[0x0]
80006e2c:	99 09       	st.w	r12[0x0],r9
80006e2e:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80006e32:	f8 08 00 28 	add	r8,r12,r8<<0x2
80006e36:	e0 1a 00 03 	andl	r10,0x3
80006e3a:	f4 0a 11 04 	rsub	r10,r10,4
80006e3e:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006e42:	17 a9       	ld.ub	r9,r11[0x2]
80006e44:	b0 a9       	st.b	r8[0x2],r9
80006e46:	17 99       	ld.ub	r9,r11[0x1]
80006e48:	b0 99       	st.b	r8[0x1],r9
80006e4a:	17 89       	ld.ub	r9,r11[0x0]
80006e4c:	b0 89       	st.b	r8[0x0],r9
80006e4e:	5e fc       	retal	r12
80006e50:	f4 0a 11 09 	rsub	r10,r10,9
80006e54:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006e58:	17 f9       	ld.ub	r9,r11[0x7]
80006e5a:	b8 f9       	st.b	r12[0x7],r9
80006e5c:	17 e9       	ld.ub	r9,r11[0x6]
80006e5e:	b8 e9       	st.b	r12[0x6],r9
80006e60:	17 d9       	ld.ub	r9,r11[0x5]
80006e62:	b8 d9       	st.b	r12[0x5],r9
80006e64:	17 c9       	ld.ub	r9,r11[0x4]
80006e66:	b8 c9       	st.b	r12[0x4],r9
80006e68:	17 b9       	ld.ub	r9,r11[0x3]
80006e6a:	b8 b9       	st.b	r12[0x3],r9
80006e6c:	17 a9       	ld.ub	r9,r11[0x2]
80006e6e:	b8 a9       	st.b	r12[0x2],r9
80006e70:	17 99       	ld.ub	r9,r11[0x1]
80006e72:	b8 99       	st.b	r12[0x1],r9
80006e74:	17 89       	ld.ub	r9,r11[0x0]
80006e76:	b8 89       	st.b	r12[0x0],r9
80006e78:	5e fc       	retal	r12
80006e7a:	eb cd 40 c0 	pushm	r6-r7,lr
80006e7e:	18 99       	mov	r9,r12
80006e80:	22 0a       	sub	r10,32
80006e82:	b7 07       	ld.d	r6,r11++
80006e84:	b3 26       	st.d	r9++,r6
80006e86:	b7 07       	ld.d	r6,r11++
80006e88:	b3 26       	st.d	r9++,r6
80006e8a:	b7 07       	ld.d	r6,r11++
80006e8c:	b3 26       	st.d	r9++,r6
80006e8e:	b7 07       	ld.d	r6,r11++
80006e90:	b3 26       	st.d	r9++,r6
80006e92:	22 0a       	sub	r10,32
80006e94:	cf 74       	brge	80006e82 <memcpy+0x92>
80006e96:	2f 0a       	sub	r10,-16
80006e98:	c0 65       	brlt	80006ea4 <memcpy+0xb4>
80006e9a:	b7 07       	ld.d	r6,r11++
80006e9c:	b3 26       	st.d	r9++,r6
80006e9e:	b7 07       	ld.d	r6,r11++
80006ea0:	b3 26       	st.d	r9++,r6
80006ea2:	21 0a       	sub	r10,16
80006ea4:	5c 3a       	neg	r10
80006ea6:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006eaa:	d7 03       	nop
80006eac:	d7 03       	nop
80006eae:	f7 36 00 0e 	ld.ub	r6,r11[14]
80006eb2:	f3 66 00 0e 	st.b	r9[14],r6
80006eb6:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006eba:	f3 66 00 0d 	st.b	r9[13],r6
80006ebe:	f7 36 00 0c 	ld.ub	r6,r11[12]
80006ec2:	f3 66 00 0c 	st.b	r9[12],r6
80006ec6:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006eca:	f3 66 00 0b 	st.b	r9[11],r6
80006ece:	f7 36 00 0a 	ld.ub	r6,r11[10]
80006ed2:	f3 66 00 0a 	st.b	r9[10],r6
80006ed6:	f7 36 00 09 	ld.ub	r6,r11[9]
80006eda:	f3 66 00 09 	st.b	r9[9],r6
80006ede:	f7 36 00 08 	ld.ub	r6,r11[8]
80006ee2:	f3 66 00 08 	st.b	r9[8],r6
80006ee6:	f7 36 00 07 	ld.ub	r6,r11[7]
80006eea:	f3 66 00 07 	st.b	r9[7],r6
80006eee:	f7 36 00 06 	ld.ub	r6,r11[6]
80006ef2:	f3 66 00 06 	st.b	r9[6],r6
80006ef6:	f7 36 00 05 	ld.ub	r6,r11[5]
80006efa:	f3 66 00 05 	st.b	r9[5],r6
80006efe:	f7 36 00 04 	ld.ub	r6,r11[4]
80006f02:	f3 66 00 04 	st.b	r9[4],r6
80006f06:	f7 36 00 03 	ld.ub	r6,r11[3]
80006f0a:	f3 66 00 03 	st.b	r9[3],r6
80006f0e:	f7 36 00 02 	ld.ub	r6,r11[2]
80006f12:	f3 66 00 02 	st.b	r9[2],r6
80006f16:	f7 36 00 01 	ld.ub	r6,r11[1]
80006f1a:	f3 66 00 01 	st.b	r9[1],r6
80006f1e:	f7 36 00 00 	ld.ub	r6,r11[0]
80006f22:	f3 66 00 00 	st.b	r9[0],r6
80006f26:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006f2a:	20 1a       	sub	r10,1
80006f2c:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80006f30:	f8 0a 0b 09 	st.b	r12[r10],r9
80006f34:	cf b1       	brne	80006f2a <memcpy+0x13a>
80006f36:	5e fc       	retal	r12

80006f38 <memset>:
80006f38:	18 98       	mov	r8,r12
80006f3a:	c0 38       	rjmp	80006f40 <memset+0x8>
80006f3c:	10 cb       	st.b	r8++,r11
80006f3e:	20 1a       	sub	r10,1
80006f40:	58 0a       	cp.w	r10,0
80006f42:	cf d1       	brne	80006f3c <memset+0x4>
80006f44:	5e fc       	retal	r12
80006f46:	d7 03       	nop

80006f48 <_realloc_r>:
80006f48:	d4 31       	pushm	r0-r7,lr
80006f4a:	20 1d       	sub	sp,4
80006f4c:	16 94       	mov	r4,r11
80006f4e:	18 92       	mov	r2,r12
80006f50:	14 9b       	mov	r11,r10
80006f52:	58 04       	cp.w	r4,0
80006f54:	c0 51       	brne	80006f5e <_realloc_r+0x16>
80006f56:	fe b0 fd 31 	rcall	800069b8 <_malloc_r>
80006f5a:	18 95       	mov	r5,r12
80006f5c:	c5 39       	rjmp	80007202 <_realloc_r+0x2ba>
80006f5e:	50 0a       	stdsp	sp[0x0],r10
80006f60:	fe b0 f2 98 	rcall	80005490 <__malloc_lock>
80006f64:	40 0b       	lddsp	r11,sp[0x0]
80006f66:	f6 c8 ff f5 	sub	r8,r11,-11
80006f6a:	e8 c1 00 08 	sub	r1,r4,8
80006f6e:	10 96       	mov	r6,r8
80006f70:	62 1c       	ld.w	r12,r1[0x4]
80006f72:	e0 16 ff f8 	andl	r6,0xfff8
80006f76:	59 68       	cp.w	r8,22
80006f78:	f9 b6 08 10 	movls	r6,16
80006f7c:	16 36       	cp.w	r6,r11
80006f7e:	5f 38       	srlo	r8
80006f80:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80006f84:	c0 50       	breq	80006f8e <_realloc_r+0x46>
80006f86:	30 c8       	mov	r8,12
80006f88:	30 05       	mov	r5,0
80006f8a:	85 38       	st.w	r2[0xc],r8
80006f8c:	c3 b9       	rjmp	80007202 <_realloc_r+0x2ba>
80006f8e:	18 90       	mov	r0,r12
80006f90:	e0 10 ff fc 	andl	r0,0xfffc
80006f94:	0c 30       	cp.w	r0,r6
80006f96:	e0 84 01 0b 	brge	800071ac <_realloc_r+0x264>
80006f9a:	e0 68 05 38 	mov	r8,1336
80006f9e:	e2 00 00 09 	add	r9,r1,r0
80006fa2:	70 25       	ld.w	r5,r8[0x8]
80006fa4:	0a 39       	cp.w	r9,r5
80006fa6:	c0 90       	breq	80006fb8 <_realloc_r+0x70>
80006fa8:	72 1a       	ld.w	r10,r9[0x4]
80006faa:	a1 ca       	cbr	r10,0x0
80006fac:	f2 0a 00 0a 	add	r10,r9,r10
80006fb0:	74 1a       	ld.w	r10,r10[0x4]
80006fb2:	ed ba 00 00 	bld	r10,0x0
80006fb6:	c2 20       	breq	80006ffa <_realloc_r+0xb2>
80006fb8:	72 1a       	ld.w	r10,r9[0x4]
80006fba:	e0 1a ff fc 	andl	r10,0xfffc
80006fbe:	f4 00 00 03 	add	r3,r10,r0
80006fc2:	0a 39       	cp.w	r9,r5
80006fc4:	c1 31       	brne	80006fea <_realloc_r+0xa2>
80006fc6:	ec c7 ff f0 	sub	r7,r6,-16
80006fca:	0e 33       	cp.w	r3,r7
80006fcc:	c1 95       	brlt	80006ffe <_realloc_r+0xb6>
80006fce:	e2 06 00 09 	add	r9,r1,r6
80006fd2:	0c 13       	sub	r3,r6
80006fd4:	a1 a3       	sbr	r3,0x0
80006fd6:	93 13       	st.w	r9[0x4],r3
80006fd8:	91 29       	st.w	r8[0x8],r9
80006fda:	04 9c       	mov	r12,r2
80006fdc:	62 18       	ld.w	r8,r1[0x4]
80006fde:	08 95       	mov	r5,r4
80006fe0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006fe4:	10 46       	or	r6,r8
80006fe6:	83 16       	st.w	r1[0x4],r6
80006fe8:	c0 b9       	rjmp	800071fe <_realloc_r+0x2b6>
80006fea:	0c 33       	cp.w	r3,r6
80006fec:	c0 95       	brlt	80006ffe <_realloc_r+0xb6>
80006fee:	72 28       	ld.w	r8,r9[0x8]
80006ff0:	02 97       	mov	r7,r1
80006ff2:	72 39       	ld.w	r9,r9[0xc]
80006ff4:	93 28       	st.w	r9[0x8],r8
80006ff6:	91 39       	st.w	r8[0xc],r9
80006ff8:	cd c8       	rjmp	800071b0 <_realloc_r+0x268>
80006ffa:	30 0a       	mov	r10,0
80006ffc:	14 99       	mov	r9,r10
80006ffe:	ed bc 00 00 	bld	r12,0x0
80007002:	e0 80 00 95 	breq	8000712c <_realloc_r+0x1e4>
80007006:	62 07       	ld.w	r7,r1[0x0]
80007008:	e2 07 01 07 	sub	r7,r1,r7
8000700c:	6e 1c       	ld.w	r12,r7[0x4]
8000700e:	e0 1c ff fc 	andl	r12,0xfffc
80007012:	58 09       	cp.w	r9,0
80007014:	c5 60       	breq	800070c0 <_realloc_r+0x178>
80007016:	f8 00 00 03 	add	r3,r12,r0
8000701a:	0a 39       	cp.w	r9,r5
8000701c:	c4 81       	brne	800070ac <_realloc_r+0x164>
8000701e:	14 03       	add	r3,r10
80007020:	ec c9 ff f0 	sub	r9,r6,-16
80007024:	12 33       	cp.w	r3,r9
80007026:	c4 d5       	brlt	800070c0 <_realloc_r+0x178>
80007028:	6e 3a       	ld.w	r10,r7[0xc]
8000702a:	6e 29       	ld.w	r9,r7[0x8]
8000702c:	95 29       	st.w	r10[0x8],r9
8000702e:	93 3a       	st.w	r9[0xc],r10
80007030:	ee c5 ff f8 	sub	r5,r7,-8
80007034:	e0 ca 00 04 	sub	r10,r0,4
80007038:	e0 4a 00 24 	cp.w	r10,36
8000703c:	e0 8b 00 25 	brhi	80007086 <_realloc_r+0x13e>
80007040:	0a 99       	mov	r9,r5
80007042:	59 3a       	cp.w	r10,19
80007044:	e0 88 00 1a 	brls	80007078 <_realloc_r+0x130>
80007048:	09 09       	ld.w	r9,r4++
8000704a:	8b 09       	st.w	r5[0x0],r9
8000704c:	09 09       	ld.w	r9,r4++
8000704e:	8f 39       	st.w	r7[0xc],r9
80007050:	ee c9 ff f0 	sub	r9,r7,-16
80007054:	59 ba       	cp.w	r10,27
80007056:	e0 88 00 11 	brls	80007078 <_realloc_r+0x130>
8000705a:	09 0b       	ld.w	r11,r4++
8000705c:	93 0b       	st.w	r9[0x0],r11
8000705e:	09 09       	ld.w	r9,r4++
80007060:	8f 59       	st.w	r7[0x14],r9
80007062:	ee c9 ff e8 	sub	r9,r7,-24
80007066:	e0 4a 00 24 	cp.w	r10,36
8000706a:	c0 71       	brne	80007078 <_realloc_r+0x130>
8000706c:	09 0a       	ld.w	r10,r4++
8000706e:	93 0a       	st.w	r9[0x0],r10
80007070:	ee c9 ff e0 	sub	r9,r7,-32
80007074:	09 0a       	ld.w	r10,r4++
80007076:	8f 7a       	st.w	r7[0x1c],r10
80007078:	09 0a       	ld.w	r10,r4++
8000707a:	12 aa       	st.w	r9++,r10
8000707c:	68 0a       	ld.w	r10,r4[0x0]
8000707e:	93 0a       	st.w	r9[0x0],r10
80007080:	68 1a       	ld.w	r10,r4[0x4]
80007082:	93 1a       	st.w	r9[0x4],r10
80007084:	c0 78       	rjmp	80007092 <_realloc_r+0x14a>
80007086:	50 08       	stdsp	sp[0x0],r8
80007088:	08 9b       	mov	r11,r4
8000708a:	0a 9c       	mov	r12,r5
8000708c:	e0 a0 1d 9b 	rcall	8000abc2 <memmove>
80007090:	40 08       	lddsp	r8,sp[0x0]
80007092:	ee 06 00 09 	add	r9,r7,r6
80007096:	0c 13       	sub	r3,r6
80007098:	a1 a3       	sbr	r3,0x0
8000709a:	93 13       	st.w	r9[0x4],r3
8000709c:	91 29       	st.w	r8[0x8],r9
8000709e:	04 9c       	mov	r12,r2
800070a0:	6e 18       	ld.w	r8,r7[0x4]
800070a2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800070a6:	10 46       	or	r6,r8
800070a8:	8f 16       	st.w	r7[0x4],r6
800070aa:	ca a8       	rjmp	800071fe <_realloc_r+0x2b6>
800070ac:	14 03       	add	r3,r10
800070ae:	0c 33       	cp.w	r3,r6
800070b0:	c0 85       	brlt	800070c0 <_realloc_r+0x178>
800070b2:	72 28       	ld.w	r8,r9[0x8]
800070b4:	72 39       	ld.w	r9,r9[0xc]
800070b6:	93 28       	st.w	r9[0x8],r8
800070b8:	91 39       	st.w	r8[0xc],r9
800070ba:	6e 28       	ld.w	r8,r7[0x8]
800070bc:	6e 39       	ld.w	r9,r7[0xc]
800070be:	c0 78       	rjmp	800070cc <_realloc_r+0x184>
800070c0:	f8 00 00 03 	add	r3,r12,r0
800070c4:	0c 33       	cp.w	r3,r6
800070c6:	c3 35       	brlt	8000712c <_realloc_r+0x1e4>
800070c8:	6e 39       	ld.w	r9,r7[0xc]
800070ca:	6e 28       	ld.w	r8,r7[0x8]
800070cc:	93 28       	st.w	r9[0x8],r8
800070ce:	91 39       	st.w	r8[0xc],r9
800070d0:	e0 ca 00 04 	sub	r10,r0,4
800070d4:	ee cc ff f8 	sub	r12,r7,-8
800070d8:	e0 4a 00 24 	cp.w	r10,36
800070dc:	e0 8b 00 24 	brhi	80007124 <_realloc_r+0x1dc>
800070e0:	59 3a       	cp.w	r10,19
800070e2:	e0 88 00 1a 	brls	80007116 <_realloc_r+0x1ce>
800070e6:	09 08       	ld.w	r8,r4++
800070e8:	99 08       	st.w	r12[0x0],r8
800070ea:	09 08       	ld.w	r8,r4++
800070ec:	8f 38       	st.w	r7[0xc],r8
800070ee:	ee cc ff f0 	sub	r12,r7,-16
800070f2:	59 ba       	cp.w	r10,27
800070f4:	e0 88 00 11 	brls	80007116 <_realloc_r+0x1ce>
800070f8:	09 08       	ld.w	r8,r4++
800070fa:	99 08       	st.w	r12[0x0],r8
800070fc:	09 08       	ld.w	r8,r4++
800070fe:	8f 58       	st.w	r7[0x14],r8
80007100:	ee cc ff e8 	sub	r12,r7,-24
80007104:	e0 4a 00 24 	cp.w	r10,36
80007108:	c0 71       	brne	80007116 <_realloc_r+0x1ce>
8000710a:	09 08       	ld.w	r8,r4++
8000710c:	99 08       	st.w	r12[0x0],r8
8000710e:	ee cc ff e0 	sub	r12,r7,-32
80007112:	09 08       	ld.w	r8,r4++
80007114:	8f 78       	st.w	r7[0x1c],r8
80007116:	09 08       	ld.w	r8,r4++
80007118:	18 a8       	st.w	r12++,r8
8000711a:	68 08       	ld.w	r8,r4[0x0]
8000711c:	99 08       	st.w	r12[0x0],r8
8000711e:	68 18       	ld.w	r8,r4[0x4]
80007120:	99 18       	st.w	r12[0x4],r8
80007122:	c4 78       	rjmp	800071b0 <_realloc_r+0x268>
80007124:	08 9b       	mov	r11,r4
80007126:	e0 a0 1d 4e 	rcall	8000abc2 <memmove>
8000712a:	c4 38       	rjmp	800071b0 <_realloc_r+0x268>
8000712c:	04 9c       	mov	r12,r2
8000712e:	fe b0 fc 45 	rcall	800069b8 <_malloc_r>
80007132:	18 95       	mov	r5,r12
80007134:	c3 a0       	breq	800071a8 <_realloc_r+0x260>
80007136:	62 18       	ld.w	r8,r1[0x4]
80007138:	f8 c9 00 08 	sub	r9,r12,8
8000713c:	a1 c8       	cbr	r8,0x0
8000713e:	e2 08 00 08 	add	r8,r1,r8
80007142:	10 39       	cp.w	r9,r8
80007144:	c0 71       	brne	80007152 <_realloc_r+0x20a>
80007146:	72 13       	ld.w	r3,r9[0x4]
80007148:	02 97       	mov	r7,r1
8000714a:	e0 13 ff fc 	andl	r3,0xfffc
8000714e:	00 03       	add	r3,r0
80007150:	c3 08       	rjmp	800071b0 <_realloc_r+0x268>
80007152:	e0 ca 00 04 	sub	r10,r0,4
80007156:	e0 4a 00 24 	cp.w	r10,36
8000715a:	e0 8b 00 20 	brhi	8000719a <_realloc_r+0x252>
8000715e:	08 99       	mov	r9,r4
80007160:	18 98       	mov	r8,r12
80007162:	59 3a       	cp.w	r10,19
80007164:	e0 88 00 14 	brls	8000718c <_realloc_r+0x244>
80007168:	13 0b       	ld.w	r11,r9++
8000716a:	10 ab       	st.w	r8++,r11
8000716c:	13 0b       	ld.w	r11,r9++
8000716e:	10 ab       	st.w	r8++,r11
80007170:	59 ba       	cp.w	r10,27
80007172:	e0 88 00 0d 	brls	8000718c <_realloc_r+0x244>
80007176:	13 0b       	ld.w	r11,r9++
80007178:	10 ab       	st.w	r8++,r11
8000717a:	13 0b       	ld.w	r11,r9++
8000717c:	10 ab       	st.w	r8++,r11
8000717e:	e0 4a 00 24 	cp.w	r10,36
80007182:	c0 51       	brne	8000718c <_realloc_r+0x244>
80007184:	13 0a       	ld.w	r10,r9++
80007186:	10 aa       	st.w	r8++,r10
80007188:	13 0a       	ld.w	r10,r9++
8000718a:	10 aa       	st.w	r8++,r10
8000718c:	13 0a       	ld.w	r10,r9++
8000718e:	10 aa       	st.w	r8++,r10
80007190:	72 0a       	ld.w	r10,r9[0x0]
80007192:	91 0a       	st.w	r8[0x0],r10
80007194:	72 19       	ld.w	r9,r9[0x4]
80007196:	91 19       	st.w	r8[0x4],r9
80007198:	c0 48       	rjmp	800071a0 <_realloc_r+0x258>
8000719a:	08 9b       	mov	r11,r4
8000719c:	e0 a0 1d 13 	rcall	8000abc2 <memmove>
800071a0:	08 9b       	mov	r11,r4
800071a2:	04 9c       	mov	r12,r2
800071a4:	e0 a0 1a 6c 	rcall	8000a67c <_free_r>
800071a8:	04 9c       	mov	r12,r2
800071aa:	c2 a8       	rjmp	800071fe <_realloc_r+0x2b6>
800071ac:	00 93       	mov	r3,r0
800071ae:	02 97       	mov	r7,r1
800071b0:	e6 06 01 09 	sub	r9,r3,r6
800071b4:	6e 18       	ld.w	r8,r7[0x4]
800071b6:	58 f9       	cp.w	r9,15
800071b8:	e0 88 00 16 	brls	800071e4 <_realloc_r+0x29c>
800071bc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800071c0:	ed e8 10 08 	or	r8,r6,r8
800071c4:	8f 18       	st.w	r7[0x4],r8
800071c6:	12 98       	mov	r8,r9
800071c8:	a1 a8       	sbr	r8,0x0
800071ca:	ee 06 00 0b 	add	r11,r7,r6
800071ce:	f6 09 00 09 	add	r9,r11,r9
800071d2:	97 18       	st.w	r11[0x4],r8
800071d4:	72 18       	ld.w	r8,r9[0x4]
800071d6:	a1 a8       	sbr	r8,0x0
800071d8:	2f 8b       	sub	r11,-8
800071da:	93 18       	st.w	r9[0x4],r8
800071dc:	04 9c       	mov	r12,r2
800071de:	e0 a0 1a 4f 	rcall	8000a67c <_free_r>
800071e2:	c0 b8       	rjmp	800071f8 <_realloc_r+0x2b0>
800071e4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800071e8:	e7 e8 10 08 	or	r8,r3,r8
800071ec:	8f 18       	st.w	r7[0x4],r8
800071ee:	ee 03 00 03 	add	r3,r7,r3
800071f2:	66 18       	ld.w	r8,r3[0x4]
800071f4:	a1 a8       	sbr	r8,0x0
800071f6:	87 18       	st.w	r3[0x4],r8
800071f8:	04 9c       	mov	r12,r2
800071fa:	ee c5 ff f8 	sub	r5,r7,-8
800071fe:	fe b0 f1 4f 	rcall	8000549c <__malloc_unlock>
80007202:	0a 9c       	mov	r12,r5
80007204:	2f fd       	sub	sp,-4
80007206:	d8 32       	popm	r0-r7,pc

80007208 <_sbrk_r>:
80007208:	d4 21       	pushm	r4-r7,lr
8000720a:	30 08       	mov	r8,0
8000720c:	18 97       	mov	r7,r12
8000720e:	e0 66 41 14 	mov	r6,16660
80007212:	16 9c       	mov	r12,r11
80007214:	8d 08       	st.w	r6[0x0],r8
80007216:	c9 1c       	rcall	80007338 <_sbrk>
80007218:	5b fc       	cp.w	r12,-1
8000721a:	c0 51       	brne	80007224 <_sbrk_r+0x1c>
8000721c:	6c 08       	ld.w	r8,r6[0x0]
8000721e:	58 08       	cp.w	r8,0
80007220:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007224:	d8 22       	popm	r4-r7,pc
80007226:	d7 03       	nop

80007228 <sprintf>:
80007228:	d4 01       	pushm	lr
8000722a:	21 7d       	sub	sp,92
8000722c:	e0 68 ff ff 	mov	r8,65535
80007230:	ea 18 7f ff 	orh	r8,0x7fff
80007234:	50 58       	stdsp	sp[0x14],r8
80007236:	50 28       	stdsp	sp[0x8],r8
80007238:	e0 68 02 08 	mov	r8,520
8000723c:	ba 68       	st.h	sp[0xc],r8
8000723e:	3f f8       	mov	r8,-1
80007240:	ba 78       	st.h	sp[0xe],r8
80007242:	e0 68 0a 38 	mov	r8,2616
80007246:	50 4c       	stdsp	sp[0x10],r12
80007248:	16 9a       	mov	r10,r11
8000724a:	50 0c       	stdsp	sp[0x0],r12
8000724c:	fa c9 ff a0 	sub	r9,sp,-96
80007250:	70 0c       	ld.w	r12,r8[0x0]
80007252:	1a 9b       	mov	r11,sp
80007254:	e0 a0 02 26 	rcall	800076a0 <_vfprintf_r>
80007258:	30 09       	mov	r9,0
8000725a:	40 08       	lddsp	r8,sp[0x0]
8000725c:	b0 89       	st.b	r8[0x0],r9
8000725e:	2e 9d       	sub	sp,-92
80007260:	d8 02       	popm	pc
80007262:	d7 03       	nop

80007264 <strlen>:
80007264:	30 09       	mov	r9,0
80007266:	18 98       	mov	r8,r12
80007268:	c0 28       	rjmp	8000726c <strlen+0x8>
8000726a:	2f f8       	sub	r8,-1
8000726c:	11 8a       	ld.ub	r10,r8[0x0]
8000726e:	f2 0a 18 00 	cp.b	r10,r9
80007272:	cf c1       	brne	8000726a <strlen+0x6>
80007274:	f0 0c 01 0c 	sub	r12,r8,r12
80007278:	5e fc       	retal	r12
8000727a:	d7 03       	nop

8000727c <strncpy>:
8000727c:	30 08       	mov	r8,0
8000727e:	10 3a       	cp.w	r10,r8
80007280:	5e 0c       	reteq	r12
80007282:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007286:	f8 08 0b 09 	st.b	r12[r8],r9
8000728a:	2f f8       	sub	r8,-1
8000728c:	58 09       	cp.w	r9,0
8000728e:	cf 81       	brne	8000727e <strncpy+0x2>
80007290:	10 3a       	cp.w	r10,r8
80007292:	5e 0c       	reteq	r12
80007294:	f8 08 0b 09 	st.b	r12[r8],r9
80007298:	2f f8       	sub	r8,-1
8000729a:	cf bb       	rjmp	80007290 <strncpy+0x14>

8000729c <_close>:
8000729c:	30 28       	mov	r8,2
8000729e:	d6 73       	breakpoint
800072a0:	3f fc       	mov	r12,-1
800072a2:	35 8b       	mov	r11,88
800072a4:	58 0c       	cp.w	r12,0
800072a6:	5e 4c       	retge	r12
800072a8:	e0 6a 41 14 	mov	r10,16660
800072ac:	95 0b       	st.w	r10[0x0],r11
800072ae:	5e fc       	retal	r12

800072b0 <_lseek>:
800072b0:	30 58       	mov	r8,5
800072b2:	d6 73       	breakpoint
800072b4:	3f fc       	mov	r12,-1
800072b6:	35 8b       	mov	r11,88
800072b8:	58 0c       	cp.w	r12,0
800072ba:	5e 4c       	retge	r12
800072bc:	e0 6a 41 14 	mov	r10,16660
800072c0:	95 0b       	st.w	r10[0x0],r11
800072c2:	5e fc       	retal	r12

800072c4 <isatty>:
800072c4:	30 b8       	mov	r8,11
800072c6:	d6 73       	breakpoint
800072c8:	3f fc       	mov	r12,-1
800072ca:	35 8b       	mov	r11,88
800072cc:	58 0c       	cp.w	r12,0
800072ce:	5e 4c       	retge	r12
800072d0:	e0 6a 41 14 	mov	r10,16660
800072d4:	95 0b       	st.w	r10[0x0],r11
800072d6:	5e fc       	retal	r12

800072d8 <_fstat_host>:
800072d8:	30 98       	mov	r8,9
800072da:	d6 73       	breakpoint
800072dc:	3f fc       	mov	r12,-1
800072de:	35 8b       	mov	r11,88
800072e0:	58 0c       	cp.w	r12,0
800072e2:	5e 4c       	retge	r12
800072e4:	e0 6a 41 14 	mov	r10,16660
800072e8:	95 0b       	st.w	r10[0x0],r11
800072ea:	5e fc       	retal	r12

800072ec <_fstat>:
800072ec:	d4 21       	pushm	r4-r7,lr
800072ee:	21 0d       	sub	sp,64
800072f0:	16 97       	mov	r7,r11
800072f2:	1a 9b       	mov	r11,sp
800072f4:	cf 2f       	rcall	800072d8 <_fstat_host>
800072f6:	c0 34       	brge	800072fc <_fstat+0x10>
800072f8:	3f fc       	mov	r12,-1
800072fa:	c1 c8       	rjmp	80007332 <_fstat+0x46>
800072fc:	40 08       	lddsp	r8,sp[0x0]
800072fe:	ae 08       	st.h	r7[0x0],r8
80007300:	40 18       	lddsp	r8,sp[0x4]
80007302:	ae 18       	st.h	r7[0x2],r8
80007304:	40 28       	lddsp	r8,sp[0x8]
80007306:	8f 18       	st.w	r7[0x4],r8
80007308:	40 38       	lddsp	r8,sp[0xc]
8000730a:	ae 48       	st.h	r7[0x8],r8
8000730c:	40 48       	lddsp	r8,sp[0x10]
8000730e:	ae 58       	st.h	r7[0xa],r8
80007310:	40 58       	lddsp	r8,sp[0x14]
80007312:	ae 68       	st.h	r7[0xc],r8
80007314:	40 68       	lddsp	r8,sp[0x18]
80007316:	ae 78       	st.h	r7[0xe],r8
80007318:	40 88       	lddsp	r8,sp[0x20]
8000731a:	8f 48       	st.w	r7[0x10],r8
8000731c:	40 a8       	lddsp	r8,sp[0x28]
8000731e:	8f b8       	st.w	r7[0x2c],r8
80007320:	40 c8       	lddsp	r8,sp[0x30]
80007322:	8f c8       	st.w	r7[0x30],r8
80007324:	40 d8       	lddsp	r8,sp[0x34]
80007326:	8f 58       	st.w	r7[0x14],r8
80007328:	40 e8       	lddsp	r8,sp[0x38]
8000732a:	30 0c       	mov	r12,0
8000732c:	8f 78       	st.w	r7[0x1c],r8
8000732e:	40 f8       	lddsp	r8,sp[0x3c]
80007330:	8f 98       	st.w	r7[0x24],r8
80007332:	2f 0d       	sub	sp,-64
80007334:	d8 22       	popm	r4-r7,pc
80007336:	d7 03       	nop

80007338 <_sbrk>:
80007338:	d4 01       	pushm	lr
8000733a:	e0 68 0d a4 	mov	r8,3492
8000733e:	70 09       	ld.w	r9,r8[0x0]
80007340:	58 09       	cp.w	r9,0
80007342:	c0 41       	brne	8000734a <_sbrk+0x12>
80007344:	e0 69 41 18 	mov	r9,16664
80007348:	91 09       	st.w	r8[0x0],r9
8000734a:	e0 69 0d a4 	mov	r9,3492
8000734e:	e0 7a 70 00 	mov	r10,94208
80007352:	72 08       	ld.w	r8,r9[0x0]
80007354:	f0 0c 00 0c 	add	r12,r8,r12
80007358:	14 3c       	cp.w	r12,r10
8000735a:	e0 8b 00 04 	brhi	80007362 <_sbrk+0x2a>
8000735e:	93 0c       	st.w	r9[0x0],r12
80007360:	c0 68       	rjmp	8000736c <_sbrk+0x34>
80007362:	e0 a0 18 15 	rcall	8000a38c <__errno>
80007366:	30 c8       	mov	r8,12
80007368:	99 08       	st.w	r12[0x0],r8
8000736a:	3f f8       	mov	r8,-1
8000736c:	10 9c       	mov	r12,r8
8000736e:	d8 02       	popm	pc

80007370 <get_arg>:
80007370:	d4 31       	pushm	r0-r7,lr
80007372:	20 8d       	sub	sp,32
80007374:	fa c4 ff bc 	sub	r4,sp,-68
80007378:	50 4b       	stdsp	sp[0x10],r11
8000737a:	68 2e       	ld.w	lr,r4[0x8]
8000737c:	50 58       	stdsp	sp[0x14],r8
8000737e:	12 96       	mov	r6,r9
80007380:	7c 0b       	ld.w	r11,lr[0x0]
80007382:	70 05       	ld.w	r5,r8[0x0]
80007384:	50 6e       	stdsp	sp[0x18],lr
80007386:	58 0b       	cp.w	r11,0
80007388:	f4 0b 17 00 	moveq	r11,r10
8000738c:	68 03       	ld.w	r3,r4[0x0]
8000738e:	68 11       	ld.w	r1,r4[0x4]
80007390:	40 49       	lddsp	r9,sp[0x10]
80007392:	30 08       	mov	r8,0
80007394:	c2 89       	rjmp	800075e4 <get_arg+0x274>
80007396:	2f fb       	sub	r11,-1
80007398:	32 5c       	mov	r12,37
8000739a:	17 8a       	ld.ub	r10,r11[0x0]
8000739c:	f8 0a 18 00 	cp.b	r10,r12
800073a0:	5f 1e       	srne	lr
800073a2:	f0 0a 18 00 	cp.b	r10,r8
800073a6:	5f 1c       	srne	r12
800073a8:	fd ec 00 0c 	and	r12,lr,r12
800073ac:	f0 0c 18 00 	cp.b	r12,r8
800073b0:	cf 31       	brne	80007396 <get_arg+0x26>
800073b2:	58 0a       	cp.w	r10,0
800073b4:	e0 80 01 25 	breq	800075fe <get_arg+0x28e>
800073b8:	30 0c       	mov	r12,0
800073ba:	3f fa       	mov	r10,-1
800073bc:	18 90       	mov	r0,r12
800073be:	50 3a       	stdsp	sp[0xc],r10
800073c0:	18 94       	mov	r4,r12
800073c2:	18 92       	mov	r2,r12
800073c4:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800073c8:	16 97       	mov	r7,r11
800073ca:	50 7c       	stdsp	sp[0x1c],r12
800073cc:	fe cc 99 1c 	sub	r12,pc,-26340
800073d0:	0f 3a       	ld.ub	r10,r7++
800073d2:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800073d6:	40 7c       	lddsp	r12,sp[0x1c]
800073d8:	1c 0c       	add	r12,lr
800073da:	fe ce 99 f2 	sub	lr,pc,-26126
800073de:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800073e2:	20 1e       	sub	lr,1
800073e4:	50 0e       	stdsp	sp[0x0],lr
800073e6:	fe ce 9a 6a 	sub	lr,pc,-26006
800073ea:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
800073ee:	50 7c       	stdsp	sp[0x1c],r12
800073f0:	40 0c       	lddsp	r12,sp[0x0]
800073f2:	58 7c       	cp.w	r12,7
800073f4:	e0 8b 00 f1 	brhi	800075d6 <get_arg+0x266>
800073f8:	fe ce 9c 1c 	sub	lr,pc,-25572
800073fc:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007400:	36 8b       	mov	r11,104
80007402:	f6 0a 18 00 	cp.b	r10,r11
80007406:	e0 80 00 e8 	breq	800075d6 <get_arg+0x266>
8000740a:	37 1b       	mov	r11,113
8000740c:	f6 0a 18 00 	cp.b	r10,r11
80007410:	c0 70       	breq	8000741e <get_arg+0xae>
80007412:	34 cb       	mov	r11,76
80007414:	f6 0a 18 00 	cp.b	r10,r11
80007418:	c0 51       	brne	80007422 <get_arg+0xb2>
8000741a:	a3 b4       	sbr	r4,0x3
8000741c:	cd d8       	rjmp	800075d6 <get_arg+0x266>
8000741e:	a5 b4       	sbr	r4,0x5
80007420:	cd b8       	rjmp	800075d6 <get_arg+0x266>
80007422:	08 9a       	mov	r10,r4
80007424:	0e 9b       	mov	r11,r7
80007426:	a5 aa       	sbr	r10,0x4
80007428:	17 3c       	ld.ub	r12,r11++
8000742a:	a5 b4       	sbr	r4,0x5
8000742c:	36 ce       	mov	lr,108
8000742e:	fc 0c 18 00 	cp.b	r12,lr
80007432:	e0 80 00 d3 	breq	800075d8 <get_arg+0x268>
80007436:	14 94       	mov	r4,r10
80007438:	cc f8       	rjmp	800075d6 <get_arg+0x266>
8000743a:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000743e:	36 7c       	mov	r12,103
80007440:	f8 0a 18 00 	cp.b	r10,r12
80007444:	e0 8b 00 27 	brhi	80007492 <get_arg+0x122>
80007448:	36 5b       	mov	r11,101
8000744a:	f6 0a 18 00 	cp.b	r10,r11
8000744e:	c4 82       	brcc	800074de <get_arg+0x16e>
80007450:	34 fb       	mov	r11,79
80007452:	f6 0a 18 00 	cp.b	r10,r11
80007456:	c4 80       	breq	800074e6 <get_arg+0x176>
80007458:	e0 8b 00 0c 	brhi	80007470 <get_arg+0x100>
8000745c:	34 5b       	mov	r11,69
8000745e:	f6 0a 18 00 	cp.b	r10,r11
80007462:	c3 e0       	breq	800074de <get_arg+0x16e>
80007464:	34 7b       	mov	r11,71
80007466:	f6 0a 18 00 	cp.b	r10,r11
8000746a:	c3 a0       	breq	800074de <get_arg+0x16e>
8000746c:	34 4b       	mov	r11,68
8000746e:	c0 88       	rjmp	8000747e <get_arg+0x10e>
80007470:	35 8b       	mov	r11,88
80007472:	f6 0a 18 00 	cp.b	r10,r11
80007476:	c2 c0       	breq	800074ce <get_arg+0x15e>
80007478:	e0 8b 00 07 	brhi	80007486 <get_arg+0x116>
8000747c:	35 5b       	mov	r11,85
8000747e:	f6 0a 18 00 	cp.b	r10,r11
80007482:	c3 51       	brne	800074ec <get_arg+0x17c>
80007484:	c3 18       	rjmp	800074e6 <get_arg+0x176>
80007486:	36 3b       	mov	r11,99
80007488:	f6 0a 18 00 	cp.b	r10,r11
8000748c:	c2 f0       	breq	800074ea <get_arg+0x17a>
8000748e:	36 4b       	mov	r11,100
80007490:	c0 e8       	rjmp	800074ac <get_arg+0x13c>
80007492:	37 0b       	mov	r11,112
80007494:	f6 0a 18 00 	cp.b	r10,r11
80007498:	c2 50       	breq	800074e2 <get_arg+0x172>
8000749a:	e0 8b 00 0d 	brhi	800074b4 <get_arg+0x144>
8000749e:	36 eb       	mov	r11,110
800074a0:	f6 0a 18 00 	cp.b	r10,r11
800074a4:	c1 f0       	breq	800074e2 <get_arg+0x172>
800074a6:	e0 8b 00 14 	brhi	800074ce <get_arg+0x15e>
800074aa:	36 9b       	mov	r11,105
800074ac:	f6 0a 18 00 	cp.b	r10,r11
800074b0:	c1 e1       	brne	800074ec <get_arg+0x17c>
800074b2:	c0 e8       	rjmp	800074ce <get_arg+0x15e>
800074b4:	37 5b       	mov	r11,117
800074b6:	f6 0a 18 00 	cp.b	r10,r11
800074ba:	c0 a0       	breq	800074ce <get_arg+0x15e>
800074bc:	37 8b       	mov	r11,120
800074be:	f6 0a 18 00 	cp.b	r10,r11
800074c2:	c0 60       	breq	800074ce <get_arg+0x15e>
800074c4:	37 3b       	mov	r11,115
800074c6:	f6 0a 18 00 	cp.b	r10,r11
800074ca:	c1 11       	brne	800074ec <get_arg+0x17c>
800074cc:	c0 b8       	rjmp	800074e2 <get_arg+0x172>
800074ce:	ed b4 00 04 	bld	r4,0x4
800074d2:	c0 a0       	breq	800074e6 <get_arg+0x176>
800074d4:	ed b4 00 05 	bld	r4,0x5
800074d8:	c0 91       	brne	800074ea <get_arg+0x17a>
800074da:	30 20       	mov	r0,2
800074dc:	c0 88       	rjmp	800074ec <get_arg+0x17c>
800074de:	30 40       	mov	r0,4
800074e0:	c0 68       	rjmp	800074ec <get_arg+0x17c>
800074e2:	30 30       	mov	r0,3
800074e4:	c0 48       	rjmp	800074ec <get_arg+0x17c>
800074e6:	30 10       	mov	r0,1
800074e8:	c0 28       	rjmp	800074ec <get_arg+0x17c>
800074ea:	30 00       	mov	r0,0
800074ec:	40 3b       	lddsp	r11,sp[0xc]
800074ee:	5b fb       	cp.w	r11,-1
800074f0:	c0 40       	breq	800074f8 <get_arg+0x188>
800074f2:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
800074f6:	c7 08       	rjmp	800075d6 <get_arg+0x266>
800074f8:	58 60       	cp.w	r0,6
800074fa:	e0 8b 00 6e 	brhi	800075d6 <get_arg+0x266>
800074fe:	6c 0a       	ld.w	r10,r6[0x0]
80007500:	ea cc ff ff 	sub	r12,r5,-1
80007504:	fe ce 9d 08 	sub	lr,pc,-25336
80007508:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000750c:	f4 cb ff f8 	sub	r11,r10,-8
80007510:	8d 0b       	st.w	r6[0x0],r11
80007512:	f4 ea 00 00 	ld.d	r10,r10[0]
80007516:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000751a:	c0 f8       	rjmp	80007538 <get_arg+0x1c8>
8000751c:	f4 cb ff fc 	sub	r11,r10,-4
80007520:	8d 0b       	st.w	r6[0x0],r11
80007522:	74 0a       	ld.w	r10,r10[0x0]
80007524:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007528:	c0 88       	rjmp	80007538 <get_arg+0x1c8>
8000752a:	f4 cb ff f8 	sub	r11,r10,-8
8000752e:	8d 0b       	st.w	r6[0x0],r11
80007530:	f4 ea 00 00 	ld.d	r10,r10[0]
80007534:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007538:	0e 9b       	mov	r11,r7
8000753a:	18 95       	mov	r5,r12
8000753c:	c4 e8       	rjmp	800075d8 <get_arg+0x268>
8000753e:	62 0a       	ld.w	r10,r1[0x0]
80007540:	5b fa       	cp.w	r10,-1
80007542:	c0 b1       	brne	80007558 <get_arg+0x1e8>
80007544:	50 19       	stdsp	sp[0x4],r9
80007546:	50 28       	stdsp	sp[0x8],r8
80007548:	e0 6a 00 80 	mov	r10,128
8000754c:	30 0b       	mov	r11,0
8000754e:	02 9c       	mov	r12,r1
80007550:	fe b0 fc f4 	rcall	80006f38 <memset>
80007554:	40 28       	lddsp	r8,sp[0x8]
80007556:	40 19       	lddsp	r9,sp[0x4]
80007558:	e4 cc 00 01 	sub	r12,r2,1
8000755c:	0e 9b       	mov	r11,r7
8000755e:	50 3c       	stdsp	sp[0xc],r12
80007560:	f2 0c 0c 49 	max	r9,r9,r12
80007564:	c3 a8       	rjmp	800075d8 <get_arg+0x268>
80007566:	62 0a       	ld.w	r10,r1[0x0]
80007568:	5b fa       	cp.w	r10,-1
8000756a:	c0 b1       	brne	80007580 <get_arg+0x210>
8000756c:	50 19       	stdsp	sp[0x4],r9
8000756e:	50 28       	stdsp	sp[0x8],r8
80007570:	e0 6a 00 80 	mov	r10,128
80007574:	30 0b       	mov	r11,0
80007576:	02 9c       	mov	r12,r1
80007578:	fe b0 fc e0 	rcall	80006f38 <memset>
8000757c:	40 28       	lddsp	r8,sp[0x8]
8000757e:	40 19       	lddsp	r9,sp[0x4]
80007580:	20 12       	sub	r2,1
80007582:	30 0a       	mov	r10,0
80007584:	0e 9b       	mov	r11,r7
80007586:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000758a:	f2 02 0c 49 	max	r9,r9,r2
8000758e:	c2 58       	rjmp	800075d8 <get_arg+0x268>
80007590:	16 97       	mov	r7,r11
80007592:	6c 0a       	ld.w	r10,r6[0x0]
80007594:	f4 cb ff fc 	sub	r11,r10,-4
80007598:	8d 0b       	st.w	r6[0x0],r11
8000759a:	74 0a       	ld.w	r10,r10[0x0]
8000759c:	0e 9b       	mov	r11,r7
8000759e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800075a2:	2f f5       	sub	r5,-1
800075a4:	c1 a8       	rjmp	800075d8 <get_arg+0x268>
800075a6:	f4 c2 00 30 	sub	r2,r10,48
800075aa:	c0 68       	rjmp	800075b6 <get_arg+0x246>
800075ac:	e4 02 00 22 	add	r2,r2,r2<<0x2
800075b0:	2f f7       	sub	r7,-1
800075b2:	f4 02 00 12 	add	r2,r10,r2<<0x1
800075b6:	0f 8a       	ld.ub	r10,r7[0x0]
800075b8:	58 0a       	cp.w	r10,0
800075ba:	c0 e0       	breq	800075d6 <get_arg+0x266>
800075bc:	23 0a       	sub	r10,48
800075be:	58 9a       	cp.w	r10,9
800075c0:	fe 98 ff f6 	brls	800075ac <get_arg+0x23c>
800075c4:	c0 98       	rjmp	800075d6 <get_arg+0x266>
800075c6:	2f f7       	sub	r7,-1
800075c8:	0f 8a       	ld.ub	r10,r7[0x0]
800075ca:	58 0a       	cp.w	r10,0
800075cc:	c0 50       	breq	800075d6 <get_arg+0x266>
800075ce:	23 0a       	sub	r10,48
800075d0:	58 9a       	cp.w	r10,9
800075d2:	fe 98 ff fa 	brls	800075c6 <get_arg+0x256>
800075d6:	0e 9b       	mov	r11,r7
800075d8:	40 7c       	lddsp	r12,sp[0x1c]
800075da:	30 ba       	mov	r10,11
800075dc:	f4 0c 18 00 	cp.b	r12,r10
800075e0:	fe 91 fe f2 	brne	800073c4 <get_arg+0x54>
800075e4:	40 42       	lddsp	r2,sp[0x10]
800075e6:	17 8c       	ld.ub	r12,r11[0x0]
800075e8:	0a 32       	cp.w	r2,r5
800075ea:	5f 4a       	srge	r10
800075ec:	f0 0c 18 00 	cp.b	r12,r8
800075f0:	5f 1c       	srne	r12
800075f2:	f9 ea 00 0a 	and	r10,r12,r10
800075f6:	f0 0a 18 00 	cp.b	r10,r8
800075fa:	fe 91 fe cf 	brne	80007398 <get_arg+0x28>
800075fe:	30 08       	mov	r8,0
80007600:	40 4e       	lddsp	lr,sp[0x10]
80007602:	17 8a       	ld.ub	r10,r11[0x0]
80007604:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007608:	f0 0a 18 00 	cp.b	r10,r8
8000760c:	fc 09 17 10 	movne	r9,lr
80007610:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007614:	06 9e       	mov	lr,r3
80007616:	c2 a8       	rjmp	8000766a <get_arg+0x2fa>
80007618:	62 0a       	ld.w	r10,r1[0x0]
8000761a:	58 3a       	cp.w	r10,3
8000761c:	c1 e0       	breq	80007658 <get_arg+0x2e8>
8000761e:	e0 89 00 07 	brgt	8000762c <get_arg+0x2bc>
80007622:	58 1a       	cp.w	r10,1
80007624:	c1 a0       	breq	80007658 <get_arg+0x2e8>
80007626:	58 2a       	cp.w	r10,2
80007628:	c1 81       	brne	80007658 <get_arg+0x2e8>
8000762a:	c0 58       	rjmp	80007634 <get_arg+0x2c4>
8000762c:	58 5a       	cp.w	r10,5
8000762e:	c0 c0       	breq	80007646 <get_arg+0x2d6>
80007630:	c0 b5       	brlt	80007646 <get_arg+0x2d6>
80007632:	c1 38       	rjmp	80007658 <get_arg+0x2e8>
80007634:	6c 0a       	ld.w	r10,r6[0x0]
80007636:	f4 cc ff f8 	sub	r12,r10,-8
8000763a:	8d 0c       	st.w	r6[0x0],r12
8000763c:	f4 e2 00 00 	ld.d	r2,r10[0]
80007640:	f0 e3 00 00 	st.d	r8[0],r2
80007644:	c1 08       	rjmp	80007664 <get_arg+0x2f4>
80007646:	6c 0a       	ld.w	r10,r6[0x0]
80007648:	f4 cc ff f8 	sub	r12,r10,-8
8000764c:	8d 0c       	st.w	r6[0x0],r12
8000764e:	f4 e2 00 00 	ld.d	r2,r10[0]
80007652:	f0 e3 00 00 	st.d	r8[0],r2
80007656:	c0 78       	rjmp	80007664 <get_arg+0x2f4>
80007658:	6c 0a       	ld.w	r10,r6[0x0]
8000765a:	f4 cc ff fc 	sub	r12,r10,-4
8000765e:	8d 0c       	st.w	r6[0x0],r12
80007660:	74 0a       	ld.w	r10,r10[0x0]
80007662:	91 0a       	st.w	r8[0x0],r10
80007664:	2f f5       	sub	r5,-1
80007666:	2f 88       	sub	r8,-8
80007668:	2f c1       	sub	r1,-4
8000766a:	12 35       	cp.w	r5,r9
8000766c:	fe 9a ff d6 	brle	80007618 <get_arg+0x2a8>
80007670:	1c 93       	mov	r3,lr
80007672:	40 52       	lddsp	r2,sp[0x14]
80007674:	40 6e       	lddsp	lr,sp[0x18]
80007676:	85 05       	st.w	r2[0x0],r5
80007678:	9d 0b       	st.w	lr[0x0],r11
8000767a:	40 4b       	lddsp	r11,sp[0x10]
8000767c:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007680:	2f 8d       	sub	sp,-32
80007682:	d8 32       	popm	r0-r7,pc

80007684 <__sprint_r>:
80007684:	d4 21       	pushm	r4-r7,lr
80007686:	14 97       	mov	r7,r10
80007688:	74 28       	ld.w	r8,r10[0x8]
8000768a:	58 08       	cp.w	r8,0
8000768c:	c0 41       	brne	80007694 <__sprint_r+0x10>
8000768e:	95 18       	st.w	r10[0x4],r8
80007690:	10 9c       	mov	r12,r8
80007692:	d8 22       	popm	r4-r7,pc
80007694:	e0 a0 18 ba 	rcall	8000a808 <__sfvwrite_r>
80007698:	30 08       	mov	r8,0
8000769a:	8f 18       	st.w	r7[0x4],r8
8000769c:	8f 28       	st.w	r7[0x8],r8
8000769e:	d8 22       	popm	r4-r7,pc

800076a0 <_vfprintf_r>:
800076a0:	d4 31       	pushm	r0-r7,lr
800076a2:	fa cd 06 bc 	sub	sp,sp,1724
800076a6:	51 09       	stdsp	sp[0x40],r9
800076a8:	16 91       	mov	r1,r11
800076aa:	14 97       	mov	r7,r10
800076ac:	18 95       	mov	r5,r12
800076ae:	e0 a0 1a 1d 	rcall	8000aae8 <_localeconv_r>
800076b2:	78 0c       	ld.w	r12,r12[0x0]
800076b4:	50 cc       	stdsp	sp[0x30],r12
800076b6:	58 05       	cp.w	r5,0
800076b8:	c0 70       	breq	800076c6 <_vfprintf_r+0x26>
800076ba:	6a 68       	ld.w	r8,r5[0x18]
800076bc:	58 08       	cp.w	r8,0
800076be:	c0 41       	brne	800076c6 <_vfprintf_r+0x26>
800076c0:	0a 9c       	mov	r12,r5
800076c2:	e0 a0 17 43 	rcall	8000a548 <__sinit>
800076c6:	fe c8 9b 06 	sub	r8,pc,-25850
800076ca:	10 31       	cp.w	r1,r8
800076cc:	c0 31       	brne	800076d2 <_vfprintf_r+0x32>
800076ce:	6a 01       	ld.w	r1,r5[0x0]
800076d0:	c0 c8       	rjmp	800076e8 <_vfprintf_r+0x48>
800076d2:	fe c8 9a f2 	sub	r8,pc,-25870
800076d6:	10 31       	cp.w	r1,r8
800076d8:	c0 31       	brne	800076de <_vfprintf_r+0x3e>
800076da:	6a 11       	ld.w	r1,r5[0x4]
800076dc:	c0 68       	rjmp	800076e8 <_vfprintf_r+0x48>
800076de:	fe c8 9a de 	sub	r8,pc,-25890
800076e2:	10 31       	cp.w	r1,r8
800076e4:	eb f1 00 02 	ld.weq	r1,r5[0x8]
800076e8:	82 68       	ld.sh	r8,r1[0xc]
800076ea:	ed b8 00 03 	bld	r8,0x3
800076ee:	c0 41       	brne	800076f6 <_vfprintf_r+0x56>
800076f0:	62 48       	ld.w	r8,r1[0x10]
800076f2:	58 08       	cp.w	r8,0
800076f4:	c0 71       	brne	80007702 <_vfprintf_r+0x62>
800076f6:	02 9b       	mov	r11,r1
800076f8:	0a 9c       	mov	r12,r5
800076fa:	e0 a0 0f 5d 	rcall	800095b4 <__swsetup_r>
800076fe:	e0 81 0f 54 	brne	800095a6 <_vfprintf_r+0x1f06>
80007702:	82 68       	ld.sh	r8,r1[0xc]
80007704:	10 99       	mov	r9,r8
80007706:	e2 19 00 1a 	andl	r9,0x1a,COH
8000770a:	58 a9       	cp.w	r9,10
8000770c:	c3 c1       	brne	80007784 <_vfprintf_r+0xe4>
8000770e:	82 79       	ld.sh	r9,r1[0xe]
80007710:	30 0a       	mov	r10,0
80007712:	f4 09 19 00 	cp.h	r9,r10
80007716:	c3 75       	brlt	80007784 <_vfprintf_r+0xe4>
80007718:	a1 d8       	cbr	r8,0x1
8000771a:	fb 58 05 d0 	st.h	sp[1488],r8
8000771e:	62 88       	ld.w	r8,r1[0x20]
80007720:	fb 48 05 e4 	st.w	sp[1508],r8
80007724:	62 a8       	ld.w	r8,r1[0x28]
80007726:	fb 48 05 ec 	st.w	sp[1516],r8
8000772a:	fa c8 ff bc 	sub	r8,sp,-68
8000772e:	fb 48 05 d4 	st.w	sp[1492],r8
80007732:	fb 48 05 c4 	st.w	sp[1476],r8
80007736:	e0 68 04 00 	mov	r8,1024
8000773a:	fb 48 05 d8 	st.w	sp[1496],r8
8000773e:	fb 48 05 cc 	st.w	sp[1484],r8
80007742:	30 08       	mov	r8,0
80007744:	fb 59 05 d2 	st.h	sp[1490],r9
80007748:	0e 9a       	mov	r10,r7
8000774a:	41 09       	lddsp	r9,sp[0x40]
8000774c:	fa c7 fa 3c 	sub	r7,sp,-1476
80007750:	fb 48 05 dc 	st.w	sp[1500],r8
80007754:	0a 9c       	mov	r12,r5
80007756:	0e 9b       	mov	r11,r7
80007758:	ca 4f       	rcall	800076a0 <_vfprintf_r>
8000775a:	50 bc       	stdsp	sp[0x2c],r12
8000775c:	c0 95       	brlt	8000776e <_vfprintf_r+0xce>
8000775e:	0e 9b       	mov	r11,r7
80007760:	0a 9c       	mov	r12,r5
80007762:	e0 a0 16 1b 	rcall	8000a398 <_fflush_r>
80007766:	40 be       	lddsp	lr,sp[0x2c]
80007768:	f9 be 01 ff 	movne	lr,-1
8000776c:	50 be       	stdsp	sp[0x2c],lr
8000776e:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007772:	ed b8 00 06 	bld	r8,0x6
80007776:	e0 81 0f 1a 	brne	800095aa <_vfprintf_r+0x1f0a>
8000777a:	82 68       	ld.sh	r8,r1[0xc]
8000777c:	a7 a8       	sbr	r8,0x6
8000777e:	a2 68       	st.h	r1[0xc],r8
80007780:	e0 8f 0f 15 	bral	800095aa <_vfprintf_r+0x1f0a>
80007784:	30 08       	mov	r8,0
80007786:	fb 48 06 b4 	st.w	sp[1716],r8
8000778a:	fb 48 06 90 	st.w	sp[1680],r8
8000778e:	fb 48 06 8c 	st.w	sp[1676],r8
80007792:	fb 48 06 b0 	st.w	sp[1712],r8
80007796:	30 08       	mov	r8,0
80007798:	30 09       	mov	r9,0
8000779a:	50 a7       	stdsp	sp[0x28],r7
8000779c:	50 78       	stdsp	sp[0x1c],r8
8000779e:	fa c3 f9 e0 	sub	r3,sp,-1568
800077a2:	3f f8       	mov	r8,-1
800077a4:	50 59       	stdsp	sp[0x14],r9
800077a6:	fb 43 06 88 	st.w	sp[1672],r3
800077aa:	fb 48 05 44 	st.w	sp[1348],r8
800077ae:	12 9c       	mov	r12,r9
800077b0:	50 69       	stdsp	sp[0x18],r9
800077b2:	50 d9       	stdsp	sp[0x34],r9
800077b4:	50 e9       	stdsp	sp[0x38],r9
800077b6:	50 b9       	stdsp	sp[0x2c],r9
800077b8:	12 97       	mov	r7,r9
800077ba:	0a 94       	mov	r4,r5
800077bc:	40 a2       	lddsp	r2,sp[0x28]
800077be:	32 5a       	mov	r10,37
800077c0:	30 08       	mov	r8,0
800077c2:	c0 28       	rjmp	800077c6 <_vfprintf_r+0x126>
800077c4:	2f f2       	sub	r2,-1
800077c6:	05 89       	ld.ub	r9,r2[0x0]
800077c8:	f0 09 18 00 	cp.b	r9,r8
800077cc:	5f 1b       	srne	r11
800077ce:	f4 09 18 00 	cp.b	r9,r10
800077d2:	5f 19       	srne	r9
800077d4:	f3 eb 00 0b 	and	r11,r9,r11
800077d8:	f0 0b 18 00 	cp.b	r11,r8
800077dc:	cf 41       	brne	800077c4 <_vfprintf_r+0x124>
800077de:	40 ab       	lddsp	r11,sp[0x28]
800077e0:	e4 0b 01 06 	sub	r6,r2,r11
800077e4:	c1 e0       	breq	80007820 <_vfprintf_r+0x180>
800077e6:	fa f8 06 90 	ld.w	r8,sp[1680]
800077ea:	0c 08       	add	r8,r6
800077ec:	87 0b       	st.w	r3[0x0],r11
800077ee:	fb 48 06 90 	st.w	sp[1680],r8
800077f2:	87 16       	st.w	r3[0x4],r6
800077f4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800077f8:	2f f8       	sub	r8,-1
800077fa:	fb 48 06 8c 	st.w	sp[1676],r8
800077fe:	58 78       	cp.w	r8,7
80007800:	e0 89 00 04 	brgt	80007808 <_vfprintf_r+0x168>
80007804:	2f 83       	sub	r3,-8
80007806:	c0 a8       	rjmp	8000781a <_vfprintf_r+0x17a>
80007808:	fa ca f9 78 	sub	r10,sp,-1672
8000780c:	02 9b       	mov	r11,r1
8000780e:	08 9c       	mov	r12,r4
80007810:	c3 af       	rcall	80007684 <__sprint_r>
80007812:	e0 81 0e c6 	brne	8000959e <_vfprintf_r+0x1efe>
80007816:	fa c3 f9 e0 	sub	r3,sp,-1568
8000781a:	40 ba       	lddsp	r10,sp[0x2c]
8000781c:	0c 0a       	add	r10,r6
8000781e:	50 ba       	stdsp	sp[0x2c],r10
80007820:	05 89       	ld.ub	r9,r2[0x0]
80007822:	30 08       	mov	r8,0
80007824:	f0 09 18 00 	cp.b	r9,r8
80007828:	e0 80 0e aa 	breq	8000957c <_vfprintf_r+0x1edc>
8000782c:	30 09       	mov	r9,0
8000782e:	fb 68 06 bb 	st.b	sp[1723],r8
80007832:	0e 96       	mov	r6,r7
80007834:	e4 c8 ff ff 	sub	r8,r2,-1
80007838:	3f fe       	mov	lr,-1
8000783a:	50 93       	stdsp	sp[0x24],r3
8000783c:	50 41       	stdsp	sp[0x10],r1
8000783e:	0e 93       	mov	r3,r7
80007840:	04 91       	mov	r1,r2
80007842:	50 89       	stdsp	sp[0x20],r9
80007844:	50 a8       	stdsp	sp[0x28],r8
80007846:	50 2e       	stdsp	sp[0x8],lr
80007848:	50 39       	stdsp	sp[0xc],r9
8000784a:	12 95       	mov	r5,r9
8000784c:	12 90       	mov	r0,r9
8000784e:	10 97       	mov	r7,r8
80007850:	08 92       	mov	r2,r4
80007852:	c0 78       	rjmp	80007860 <_vfprintf_r+0x1c0>
80007854:	3f fc       	mov	r12,-1
80007856:	08 97       	mov	r7,r4
80007858:	50 2c       	stdsp	sp[0x8],r12
8000785a:	c0 38       	rjmp	80007860 <_vfprintf_r+0x1c0>
8000785c:	30 0b       	mov	r11,0
8000785e:	50 3b       	stdsp	sp[0xc],r11
80007860:	0f 38       	ld.ub	r8,r7++
80007862:	c0 28       	rjmp	80007866 <_vfprintf_r+0x1c6>
80007864:	12 90       	mov	r0,r9
80007866:	f0 c9 00 20 	sub	r9,r8,32
8000786a:	e0 49 00 58 	cp.w	r9,88
8000786e:	e0 8b 0a 30 	brhi	80008cce <_vfprintf_r+0x162e>
80007872:	fe ca a0 5a 	sub	r10,pc,-24486
80007876:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000787a:	50 a7       	stdsp	sp[0x28],r7
8000787c:	50 80       	stdsp	sp[0x20],r0
8000787e:	0c 97       	mov	r7,r6
80007880:	04 94       	mov	r4,r2
80007882:	06 96       	mov	r6,r3
80007884:	02 92       	mov	r2,r1
80007886:	fe c9 9e 32 	sub	r9,pc,-25038
8000788a:	40 93       	lddsp	r3,sp[0x24]
8000788c:	10 90       	mov	r0,r8
8000788e:	40 41       	lddsp	r1,sp[0x10]
80007890:	50 d9       	stdsp	sp[0x34],r9
80007892:	e0 8f 08 8e 	bral	800089ae <_vfprintf_r+0x130e>
80007896:	30 08       	mov	r8,0
80007898:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000789c:	f0 09 18 00 	cp.b	r9,r8
800078a0:	ce 01       	brne	80007860 <_vfprintf_r+0x1c0>
800078a2:	32 08       	mov	r8,32
800078a4:	c6 e8       	rjmp	80007980 <_vfprintf_r+0x2e0>
800078a6:	a1 a5       	sbr	r5,0x0
800078a8:	cd cb       	rjmp	80007860 <_vfprintf_r+0x1c0>
800078aa:	0f 89       	ld.ub	r9,r7[0x0]
800078ac:	f2 c8 00 30 	sub	r8,r9,48
800078b0:	58 98       	cp.w	r8,9
800078b2:	e0 8b 00 1d 	brhi	800078ec <_vfprintf_r+0x24c>
800078b6:	ee c8 ff ff 	sub	r8,r7,-1
800078ba:	30 0b       	mov	r11,0
800078bc:	23 09       	sub	r9,48
800078be:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800078c2:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800078c6:	11 39       	ld.ub	r9,r8++
800078c8:	f2 ca 00 30 	sub	r10,r9,48
800078cc:	58 9a       	cp.w	r10,9
800078ce:	fe 98 ff f7 	brls	800078bc <_vfprintf_r+0x21c>
800078d2:	e0 49 00 24 	cp.w	r9,36
800078d6:	cc 31       	brne	8000785c <_vfprintf_r+0x1bc>
800078d8:	e0 4b 00 20 	cp.w	r11,32
800078dc:	e0 89 0e 60 	brgt	8000959c <_vfprintf_r+0x1efc>
800078e0:	20 1b       	sub	r11,1
800078e2:	fa f9 06 b4 	ld.w	r9,sp[1716]
800078e6:	12 3b       	cp.w	r11,r9
800078e8:	c0 95       	brlt	800078fa <_vfprintf_r+0x25a>
800078ea:	c1 08       	rjmp	8000790a <_vfprintf_r+0x26a>
800078ec:	fa f9 06 b4 	ld.w	r9,sp[1716]
800078f0:	ec ca ff ff 	sub	r10,r6,-1
800078f4:	12 36       	cp.w	r6,r9
800078f6:	c1 f5       	brlt	80007934 <_vfprintf_r+0x294>
800078f8:	c2 68       	rjmp	80007944 <_vfprintf_r+0x2a4>
800078fa:	fa ce f9 44 	sub	lr,sp,-1724
800078fe:	10 97       	mov	r7,r8
80007900:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80007904:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80007908:	c3 58       	rjmp	80007972 <_vfprintf_r+0x2d2>
8000790a:	10 97       	mov	r7,r8
8000790c:	fa c8 f9 50 	sub	r8,sp,-1712
80007910:	1a d8       	st.w	--sp,r8
80007912:	fa c8 fa b8 	sub	r8,sp,-1352
80007916:	1a d8       	st.w	--sp,r8
80007918:	fa c8 fb b4 	sub	r8,sp,-1100
8000791c:	02 9a       	mov	r10,r1
8000791e:	1a d8       	st.w	--sp,r8
80007920:	04 9c       	mov	r12,r2
80007922:	fa c8 f9 40 	sub	r8,sp,-1728
80007926:	fa c9 ff b4 	sub	r9,sp,-76
8000792a:	fe b0 fd 23 	rcall	80007370 <get_arg>
8000792e:	2f dd       	sub	sp,-12
80007930:	78 00       	ld.w	r0,r12[0x0]
80007932:	c2 08       	rjmp	80007972 <_vfprintf_r+0x2d2>
80007934:	fa cc f9 44 	sub	r12,sp,-1724
80007938:	14 96       	mov	r6,r10
8000793a:	f8 03 00 38 	add	r8,r12,r3<<0x3
8000793e:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80007942:	c1 88       	rjmp	80007972 <_vfprintf_r+0x2d2>
80007944:	41 08       	lddsp	r8,sp[0x40]
80007946:	59 f9       	cp.w	r9,31
80007948:	e0 89 00 11 	brgt	8000796a <_vfprintf_r+0x2ca>
8000794c:	f0 cb ff fc 	sub	r11,r8,-4
80007950:	51 0b       	stdsp	sp[0x40],r11
80007952:	70 00       	ld.w	r0,r8[0x0]
80007954:	fa cb f9 44 	sub	r11,sp,-1724
80007958:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000795c:	f1 40 fd 88 	st.w	r8[-632],r0
80007960:	2f f9       	sub	r9,-1
80007962:	14 96       	mov	r6,r10
80007964:	fb 49 06 b4 	st.w	sp[1716],r9
80007968:	c0 58       	rjmp	80007972 <_vfprintf_r+0x2d2>
8000796a:	70 00       	ld.w	r0,r8[0x0]
8000796c:	14 96       	mov	r6,r10
8000796e:	2f c8       	sub	r8,-4
80007970:	51 08       	stdsp	sp[0x40],r8
80007972:	58 00       	cp.w	r0,0
80007974:	fe 94 ff 76 	brge	80007860 <_vfprintf_r+0x1c0>
80007978:	5c 30       	neg	r0
8000797a:	a3 a5       	sbr	r5,0x2
8000797c:	c7 2b       	rjmp	80007860 <_vfprintf_r+0x1c0>
8000797e:	32 b8       	mov	r8,43
80007980:	fb 68 06 bb 	st.b	sp[1723],r8
80007984:	c6 eb       	rjmp	80007860 <_vfprintf_r+0x1c0>
80007986:	0f 38       	ld.ub	r8,r7++
80007988:	e0 48 00 2a 	cp.w	r8,42
8000798c:	c0 30       	breq	80007992 <_vfprintf_r+0x2f2>
8000798e:	30 09       	mov	r9,0
80007990:	c7 98       	rjmp	80007a82 <_vfprintf_r+0x3e2>
80007992:	0f 88       	ld.ub	r8,r7[0x0]
80007994:	f0 c9 00 30 	sub	r9,r8,48
80007998:	58 99       	cp.w	r9,9
8000799a:	e0 8b 00 1f 	brhi	800079d8 <_vfprintf_r+0x338>
8000799e:	ee c4 ff ff 	sub	r4,r7,-1
800079a2:	30 0b       	mov	r11,0
800079a4:	23 08       	sub	r8,48
800079a6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800079aa:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800079ae:	09 38       	ld.ub	r8,r4++
800079b0:	f0 c9 00 30 	sub	r9,r8,48
800079b4:	58 99       	cp.w	r9,9
800079b6:	fe 98 ff f7 	brls	800079a4 <_vfprintf_r+0x304>
800079ba:	e0 48 00 24 	cp.w	r8,36
800079be:	fe 91 ff 4f 	brne	8000785c <_vfprintf_r+0x1bc>
800079c2:	e0 4b 00 20 	cp.w	r11,32
800079c6:	e0 89 0d eb 	brgt	8000959c <_vfprintf_r+0x1efc>
800079ca:	20 1b       	sub	r11,1
800079cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079d0:	10 3b       	cp.w	r11,r8
800079d2:	c0 a5       	brlt	800079e6 <_vfprintf_r+0x346>
800079d4:	c1 18       	rjmp	800079f6 <_vfprintf_r+0x356>
800079d6:	d7 03       	nop
800079d8:	fa fa 06 b4 	ld.w	r10,sp[1716]
800079dc:	ec c9 ff ff 	sub	r9,r6,-1
800079e0:	14 36       	cp.w	r6,r10
800079e2:	c1 f5       	brlt	80007a20 <_vfprintf_r+0x380>
800079e4:	c2 88       	rjmp	80007a34 <_vfprintf_r+0x394>
800079e6:	fa ca f9 44 	sub	r10,sp,-1724
800079ea:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800079ee:	f6 fb fd 88 	ld.w	r11,r11[-632]
800079f2:	50 2b       	stdsp	sp[0x8],r11
800079f4:	c3 c8       	rjmp	80007a6c <_vfprintf_r+0x3cc>
800079f6:	fa c8 f9 50 	sub	r8,sp,-1712
800079fa:	1a d8       	st.w	--sp,r8
800079fc:	fa c8 fa b8 	sub	r8,sp,-1352
80007a00:	1a d8       	st.w	--sp,r8
80007a02:	fa c8 fb b4 	sub	r8,sp,-1100
80007a06:	02 9a       	mov	r10,r1
80007a08:	1a d8       	st.w	--sp,r8
80007a0a:	04 9c       	mov	r12,r2
80007a0c:	fa c8 f9 40 	sub	r8,sp,-1728
80007a10:	fa c9 ff b4 	sub	r9,sp,-76
80007a14:	fe b0 fc ae 	rcall	80007370 <get_arg>
80007a18:	2f dd       	sub	sp,-12
80007a1a:	78 0c       	ld.w	r12,r12[0x0]
80007a1c:	50 2c       	stdsp	sp[0x8],r12
80007a1e:	c2 78       	rjmp	80007a6c <_vfprintf_r+0x3cc>
80007a20:	12 96       	mov	r6,r9
80007a22:	0e 94       	mov	r4,r7
80007a24:	fa c9 f9 44 	sub	r9,sp,-1724
80007a28:	f2 03 00 38 	add	r8,r9,r3<<0x3
80007a2c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80007a30:	50 28       	stdsp	sp[0x8],r8
80007a32:	c1 d8       	rjmp	80007a6c <_vfprintf_r+0x3cc>
80007a34:	41 08       	lddsp	r8,sp[0x40]
80007a36:	59 fa       	cp.w	r10,31
80007a38:	e0 89 00 14 	brgt	80007a60 <_vfprintf_r+0x3c0>
80007a3c:	f0 cb ff fc 	sub	r11,r8,-4
80007a40:	70 08       	ld.w	r8,r8[0x0]
80007a42:	51 0b       	stdsp	sp[0x40],r11
80007a44:	50 28       	stdsp	sp[0x8],r8
80007a46:	fa c6 f9 44 	sub	r6,sp,-1724
80007a4a:	40 2e       	lddsp	lr,sp[0x8]
80007a4c:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007a50:	f1 4e fd 88 	st.w	r8[-632],lr
80007a54:	2f fa       	sub	r10,-1
80007a56:	0e 94       	mov	r4,r7
80007a58:	fb 4a 06 b4 	st.w	sp[1716],r10
80007a5c:	12 96       	mov	r6,r9
80007a5e:	c0 78       	rjmp	80007a6c <_vfprintf_r+0x3cc>
80007a60:	70 0c       	ld.w	r12,r8[0x0]
80007a62:	0e 94       	mov	r4,r7
80007a64:	2f c8       	sub	r8,-4
80007a66:	50 2c       	stdsp	sp[0x8],r12
80007a68:	12 96       	mov	r6,r9
80007a6a:	51 08       	stdsp	sp[0x40],r8
80007a6c:	40 2b       	lddsp	r11,sp[0x8]
80007a6e:	58 0b       	cp.w	r11,0
80007a70:	fe 95 fe f2 	brlt	80007854 <_vfprintf_r+0x1b4>
80007a74:	08 97       	mov	r7,r4
80007a76:	cf 5a       	rjmp	80007860 <_vfprintf_r+0x1c0>
80007a78:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007a7c:	0f 38       	ld.ub	r8,r7++
80007a7e:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007a82:	f0 ca 00 30 	sub	r10,r8,48
80007a86:	58 9a       	cp.w	r10,9
80007a88:	fe 98 ff f8 	brls	80007a78 <_vfprintf_r+0x3d8>
80007a8c:	3f fa       	mov	r10,-1
80007a8e:	f2 0a 0c 49 	max	r9,r9,r10
80007a92:	50 29       	stdsp	sp[0x8],r9
80007a94:	ce 9a       	rjmp	80007866 <_vfprintf_r+0x1c6>
80007a96:	a7 b5       	sbr	r5,0x7
80007a98:	ce 4a       	rjmp	80007860 <_vfprintf_r+0x1c0>
80007a9a:	30 09       	mov	r9,0
80007a9c:	23 08       	sub	r8,48
80007a9e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007aa2:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007aa6:	0f 38       	ld.ub	r8,r7++
80007aa8:	f0 ca 00 30 	sub	r10,r8,48
80007aac:	58 9a       	cp.w	r10,9
80007aae:	fe 98 ff f7 	brls	80007a9c <_vfprintf_r+0x3fc>
80007ab2:	e0 48 00 24 	cp.w	r8,36
80007ab6:	fe 91 fe d7 	brne	80007864 <_vfprintf_r+0x1c4>
80007aba:	e0 49 00 20 	cp.w	r9,32
80007abe:	e0 89 0d 6f 	brgt	8000959c <_vfprintf_r+0x1efc>
80007ac2:	f2 c3 00 01 	sub	r3,r9,1
80007ac6:	30 19       	mov	r9,1
80007ac8:	50 39       	stdsp	sp[0xc],r9
80007aca:	cc ba       	rjmp	80007860 <_vfprintf_r+0x1c0>
80007acc:	a3 b5       	sbr	r5,0x3
80007ace:	cc 9a       	rjmp	80007860 <_vfprintf_r+0x1c0>
80007ad0:	a7 a5       	sbr	r5,0x6
80007ad2:	cc 7a       	rjmp	80007860 <_vfprintf_r+0x1c0>
80007ad4:	0a 98       	mov	r8,r5
80007ad6:	a5 b5       	sbr	r5,0x5
80007ad8:	a5 a8       	sbr	r8,0x4
80007ada:	0f 89       	ld.ub	r9,r7[0x0]
80007adc:	36 ce       	mov	lr,108
80007ade:	fc 09 18 00 	cp.b	r9,lr
80007ae2:	f7 b7 00 ff 	subeq	r7,-1
80007ae6:	f0 05 17 10 	movne	r5,r8
80007aea:	cb ba       	rjmp	80007860 <_vfprintf_r+0x1c0>
80007aec:	a5 b5       	sbr	r5,0x5
80007aee:	cb 9a       	rjmp	80007860 <_vfprintf_r+0x1c0>
80007af0:	50 a7       	stdsp	sp[0x28],r7
80007af2:	50 80       	stdsp	sp[0x20],r0
80007af4:	0c 97       	mov	r7,r6
80007af6:	10 90       	mov	r0,r8
80007af8:	06 96       	mov	r6,r3
80007afa:	04 94       	mov	r4,r2
80007afc:	40 93       	lddsp	r3,sp[0x24]
80007afe:	02 92       	mov	r2,r1
80007b00:	0e 99       	mov	r9,r7
80007b02:	40 41       	lddsp	r1,sp[0x10]
80007b04:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b08:	40 3c       	lddsp	r12,sp[0xc]
80007b0a:	58 0c       	cp.w	r12,0
80007b0c:	c1 d0       	breq	80007b46 <_vfprintf_r+0x4a6>
80007b0e:	10 36       	cp.w	r6,r8
80007b10:	c0 64       	brge	80007b1c <_vfprintf_r+0x47c>
80007b12:	fa cb f9 44 	sub	r11,sp,-1724
80007b16:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b1a:	c1 d8       	rjmp	80007b54 <_vfprintf_r+0x4b4>
80007b1c:	fa c8 f9 50 	sub	r8,sp,-1712
80007b20:	1a d8       	st.w	--sp,r8
80007b22:	fa c8 fa b8 	sub	r8,sp,-1352
80007b26:	1a d8       	st.w	--sp,r8
80007b28:	fa c8 fb b4 	sub	r8,sp,-1100
80007b2c:	1a d8       	st.w	--sp,r8
80007b2e:	fa c8 f9 40 	sub	r8,sp,-1728
80007b32:	fa c9 ff b4 	sub	r9,sp,-76
80007b36:	04 9a       	mov	r10,r2
80007b38:	0c 9b       	mov	r11,r6
80007b3a:	08 9c       	mov	r12,r4
80007b3c:	fe b0 fc 1a 	rcall	80007370 <get_arg>
80007b40:	2f dd       	sub	sp,-12
80007b42:	19 b8       	ld.ub	r8,r12[0x3]
80007b44:	c2 28       	rjmp	80007b88 <_vfprintf_r+0x4e8>
80007b46:	2f f7       	sub	r7,-1
80007b48:	10 39       	cp.w	r9,r8
80007b4a:	c0 84       	brge	80007b5a <_vfprintf_r+0x4ba>
80007b4c:	fa ca f9 44 	sub	r10,sp,-1724
80007b50:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007b54:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007b58:	c1 88       	rjmp	80007b88 <_vfprintf_r+0x4e8>
80007b5a:	41 09       	lddsp	r9,sp[0x40]
80007b5c:	59 f8       	cp.w	r8,31
80007b5e:	e0 89 00 12 	brgt	80007b82 <_vfprintf_r+0x4e2>
80007b62:	f2 ca ff fc 	sub	r10,r9,-4
80007b66:	51 0a       	stdsp	sp[0x40],r10
80007b68:	72 09       	ld.w	r9,r9[0x0]
80007b6a:	fa c6 f9 44 	sub	r6,sp,-1724
80007b6e:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007b72:	2f f8       	sub	r8,-1
80007b74:	f5 49 fd 88 	st.w	r10[-632],r9
80007b78:	fb 48 06 b4 	st.w	sp[1716],r8
80007b7c:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007b80:	c0 48       	rjmp	80007b88 <_vfprintf_r+0x4e8>
80007b82:	13 b8       	ld.ub	r8,r9[0x3]
80007b84:	2f c9       	sub	r9,-4
80007b86:	51 09       	stdsp	sp[0x40],r9
80007b88:	fb 68 06 60 	st.b	sp[1632],r8
80007b8c:	30 0e       	mov	lr,0
80007b8e:	30 08       	mov	r8,0
80007b90:	30 12       	mov	r2,1
80007b92:	fb 68 06 bb 	st.b	sp[1723],r8
80007b96:	50 2e       	stdsp	sp[0x8],lr
80007b98:	e0 8f 08 ad 	bral	80008cf2 <_vfprintf_r+0x1652>
80007b9c:	50 a7       	stdsp	sp[0x28],r7
80007b9e:	50 80       	stdsp	sp[0x20],r0
80007ba0:	0c 97       	mov	r7,r6
80007ba2:	04 94       	mov	r4,r2
80007ba4:	06 96       	mov	r6,r3
80007ba6:	02 92       	mov	r2,r1
80007ba8:	40 93       	lddsp	r3,sp[0x24]
80007baa:	10 90       	mov	r0,r8
80007bac:	40 41       	lddsp	r1,sp[0x10]
80007bae:	a5 a5       	sbr	r5,0x4
80007bb0:	c0 a8       	rjmp	80007bc4 <_vfprintf_r+0x524>
80007bb2:	50 a7       	stdsp	sp[0x28],r7
80007bb4:	50 80       	stdsp	sp[0x20],r0
80007bb6:	0c 97       	mov	r7,r6
80007bb8:	04 94       	mov	r4,r2
80007bba:	06 96       	mov	r6,r3
80007bbc:	02 92       	mov	r2,r1
80007bbe:	40 93       	lddsp	r3,sp[0x24]
80007bc0:	10 90       	mov	r0,r8
80007bc2:	40 41       	lddsp	r1,sp[0x10]
80007bc4:	ed b5 00 05 	bld	r5,0x5
80007bc8:	c5 11       	brne	80007c6a <_vfprintf_r+0x5ca>
80007bca:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bce:	40 3c       	lddsp	r12,sp[0xc]
80007bd0:	58 0c       	cp.w	r12,0
80007bd2:	c1 e0       	breq	80007c0e <_vfprintf_r+0x56e>
80007bd4:	10 36       	cp.w	r6,r8
80007bd6:	c0 64       	brge	80007be2 <_vfprintf_r+0x542>
80007bd8:	fa cb f9 44 	sub	r11,sp,-1724
80007bdc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007be0:	c2 08       	rjmp	80007c20 <_vfprintf_r+0x580>
80007be2:	fa c8 f9 50 	sub	r8,sp,-1712
80007be6:	1a d8       	st.w	--sp,r8
80007be8:	fa c8 fa b8 	sub	r8,sp,-1352
80007bec:	0c 9b       	mov	r11,r6
80007bee:	1a d8       	st.w	--sp,r8
80007bf0:	fa c8 fb b4 	sub	r8,sp,-1100
80007bf4:	1a d8       	st.w	--sp,r8
80007bf6:	fa c9 ff b4 	sub	r9,sp,-76
80007bfa:	fa c8 f9 40 	sub	r8,sp,-1728
80007bfe:	04 9a       	mov	r10,r2
80007c00:	08 9c       	mov	r12,r4
80007c02:	fe b0 fb b7 	rcall	80007370 <get_arg>
80007c06:	2f dd       	sub	sp,-12
80007c08:	78 1b       	ld.w	r11,r12[0x4]
80007c0a:	78 09       	ld.w	r9,r12[0x0]
80007c0c:	c2 b8       	rjmp	80007c62 <_vfprintf_r+0x5c2>
80007c0e:	ee ca ff ff 	sub	r10,r7,-1
80007c12:	10 37       	cp.w	r7,r8
80007c14:	c0 b4       	brge	80007c2a <_vfprintf_r+0x58a>
80007c16:	fa c9 f9 44 	sub	r9,sp,-1724
80007c1a:	14 97       	mov	r7,r10
80007c1c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c20:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007c24:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007c28:	c1 d8       	rjmp	80007c62 <_vfprintf_r+0x5c2>
80007c2a:	41 09       	lddsp	r9,sp[0x40]
80007c2c:	59 f8       	cp.w	r8,31
80007c2e:	e0 89 00 14 	brgt	80007c56 <_vfprintf_r+0x5b6>
80007c32:	f2 cb ff f8 	sub	r11,r9,-8
80007c36:	51 0b       	stdsp	sp[0x40],r11
80007c38:	fa c6 f9 44 	sub	r6,sp,-1724
80007c3c:	72 1b       	ld.w	r11,r9[0x4]
80007c3e:	ec 08 00 3c 	add	r12,r6,r8<<0x3
80007c42:	72 09       	ld.w	r9,r9[0x0]
80007c44:	f9 4b fd 8c 	st.w	r12[-628],r11
80007c48:	f9 49 fd 88 	st.w	r12[-632],r9
80007c4c:	2f f8       	sub	r8,-1
80007c4e:	14 97       	mov	r7,r10
80007c50:	fb 48 06 b4 	st.w	sp[1716],r8
80007c54:	c0 78       	rjmp	80007c62 <_vfprintf_r+0x5c2>
80007c56:	f2 c8 ff f8 	sub	r8,r9,-8
80007c5a:	72 1b       	ld.w	r11,r9[0x4]
80007c5c:	14 97       	mov	r7,r10
80007c5e:	51 08       	stdsp	sp[0x40],r8
80007c60:	72 09       	ld.w	r9,r9[0x0]
80007c62:	16 98       	mov	r8,r11
80007c64:	fa e9 00 00 	st.d	sp[0],r8
80007c68:	ca e8       	rjmp	80007dc4 <_vfprintf_r+0x724>
80007c6a:	ed b5 00 04 	bld	r5,0x4
80007c6e:	c1 71       	brne	80007c9c <_vfprintf_r+0x5fc>
80007c70:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c74:	40 3e       	lddsp	lr,sp[0xc]
80007c76:	58 0e       	cp.w	lr,0
80007c78:	c0 80       	breq	80007c88 <_vfprintf_r+0x5e8>
80007c7a:	10 36       	cp.w	r6,r8
80007c7c:	c6 94       	brge	80007d4e <_vfprintf_r+0x6ae>
80007c7e:	fa cc f9 44 	sub	r12,sp,-1724
80007c82:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007c86:	c8 28       	rjmp	80007d8a <_vfprintf_r+0x6ea>
80007c88:	ee ca ff ff 	sub	r10,r7,-1
80007c8c:	10 37       	cp.w	r7,r8
80007c8e:	e0 84 00 81 	brge	80007d90 <_vfprintf_r+0x6f0>
80007c92:	fa cb f9 44 	sub	r11,sp,-1724
80007c96:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c9a:	c7 78       	rjmp	80007d88 <_vfprintf_r+0x6e8>
80007c9c:	ed b5 00 06 	bld	r5,0x6
80007ca0:	c4 b1       	brne	80007d36 <_vfprintf_r+0x696>
80007ca2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ca6:	40 3c       	lddsp	r12,sp[0xc]
80007ca8:	58 0c       	cp.w	r12,0
80007caa:	c1 d0       	breq	80007ce4 <_vfprintf_r+0x644>
80007cac:	10 36       	cp.w	r6,r8
80007cae:	c0 64       	brge	80007cba <_vfprintf_r+0x61a>
80007cb0:	fa cb f9 44 	sub	r11,sp,-1724
80007cb4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007cb8:	c1 f8       	rjmp	80007cf6 <_vfprintf_r+0x656>
80007cba:	fa c8 f9 50 	sub	r8,sp,-1712
80007cbe:	1a d8       	st.w	--sp,r8
80007cc0:	fa c8 fa b8 	sub	r8,sp,-1352
80007cc4:	1a d8       	st.w	--sp,r8
80007cc6:	fa c8 fb b4 	sub	r8,sp,-1100
80007cca:	1a d8       	st.w	--sp,r8
80007ccc:	fa c8 f9 40 	sub	r8,sp,-1728
80007cd0:	fa c9 ff b4 	sub	r9,sp,-76
80007cd4:	04 9a       	mov	r10,r2
80007cd6:	0c 9b       	mov	r11,r6
80007cd8:	08 9c       	mov	r12,r4
80007cda:	fe b0 fb 4b 	rcall	80007370 <get_arg>
80007cde:	2f dd       	sub	sp,-12
80007ce0:	98 18       	ld.sh	r8,r12[0x2]
80007ce2:	c2 68       	rjmp	80007d2e <_vfprintf_r+0x68e>
80007ce4:	ee ca ff ff 	sub	r10,r7,-1
80007ce8:	10 37       	cp.w	r7,r8
80007cea:	c0 94       	brge	80007cfc <_vfprintf_r+0x65c>
80007cec:	fa c9 f9 44 	sub	r9,sp,-1724
80007cf0:	14 97       	mov	r7,r10
80007cf2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007cf6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007cfa:	c1 a8       	rjmp	80007d2e <_vfprintf_r+0x68e>
80007cfc:	41 09       	lddsp	r9,sp[0x40]
80007cfe:	59 f8       	cp.w	r8,31
80007d00:	e0 89 00 13 	brgt	80007d26 <_vfprintf_r+0x686>
80007d04:	f2 cb ff fc 	sub	r11,r9,-4
80007d08:	51 0b       	stdsp	sp[0x40],r11
80007d0a:	72 09       	ld.w	r9,r9[0x0]
80007d0c:	fa c6 f9 44 	sub	r6,sp,-1724
80007d10:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007d14:	2f f8       	sub	r8,-1
80007d16:	f7 49 fd 88 	st.w	r11[-632],r9
80007d1a:	fb 48 06 b4 	st.w	sp[1716],r8
80007d1e:	14 97       	mov	r7,r10
80007d20:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007d24:	c0 58       	rjmp	80007d2e <_vfprintf_r+0x68e>
80007d26:	92 18       	ld.sh	r8,r9[0x2]
80007d28:	14 97       	mov	r7,r10
80007d2a:	2f c9       	sub	r9,-4
80007d2c:	51 09       	stdsp	sp[0x40],r9
80007d2e:	50 18       	stdsp	sp[0x4],r8
80007d30:	bf 58       	asr	r8,0x1f
80007d32:	50 08       	stdsp	sp[0x0],r8
80007d34:	c4 88       	rjmp	80007dc4 <_vfprintf_r+0x724>
80007d36:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d3a:	40 3c       	lddsp	r12,sp[0xc]
80007d3c:	58 0c       	cp.w	r12,0
80007d3e:	c1 d0       	breq	80007d78 <_vfprintf_r+0x6d8>
80007d40:	10 36       	cp.w	r6,r8
80007d42:	c0 64       	brge	80007d4e <_vfprintf_r+0x6ae>
80007d44:	fa cb f9 44 	sub	r11,sp,-1724
80007d48:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007d4c:	c1 f8       	rjmp	80007d8a <_vfprintf_r+0x6ea>
80007d4e:	fa c8 f9 50 	sub	r8,sp,-1712
80007d52:	1a d8       	st.w	--sp,r8
80007d54:	fa c8 fa b8 	sub	r8,sp,-1352
80007d58:	0c 9b       	mov	r11,r6
80007d5a:	1a d8       	st.w	--sp,r8
80007d5c:	fa c8 fb b4 	sub	r8,sp,-1100
80007d60:	04 9a       	mov	r10,r2
80007d62:	1a d8       	st.w	--sp,r8
80007d64:	08 9c       	mov	r12,r4
80007d66:	fa c8 f9 40 	sub	r8,sp,-1728
80007d6a:	fa c9 ff b4 	sub	r9,sp,-76
80007d6e:	fe b0 fb 01 	rcall	80007370 <get_arg>
80007d72:	2f dd       	sub	sp,-12
80007d74:	78 0b       	ld.w	r11,r12[0x0]
80007d76:	c2 48       	rjmp	80007dbe <_vfprintf_r+0x71e>
80007d78:	ee ca ff ff 	sub	r10,r7,-1
80007d7c:	10 37       	cp.w	r7,r8
80007d7e:	c0 94       	brge	80007d90 <_vfprintf_r+0x6f0>
80007d80:	fa c9 f9 44 	sub	r9,sp,-1724
80007d84:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007d88:	14 97       	mov	r7,r10
80007d8a:	ec fb fd 88 	ld.w	r11,r6[-632]
80007d8e:	c1 88       	rjmp	80007dbe <_vfprintf_r+0x71e>
80007d90:	41 09       	lddsp	r9,sp[0x40]
80007d92:	59 f8       	cp.w	r8,31
80007d94:	e0 89 00 11 	brgt	80007db6 <_vfprintf_r+0x716>
80007d98:	f2 cb ff fc 	sub	r11,r9,-4
80007d9c:	51 0b       	stdsp	sp[0x40],r11
80007d9e:	fa c6 f9 44 	sub	r6,sp,-1724
80007da2:	72 0b       	ld.w	r11,r9[0x0]
80007da4:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007da8:	f3 4b fd 88 	st.w	r9[-632],r11
80007dac:	2f f8       	sub	r8,-1
80007dae:	14 97       	mov	r7,r10
80007db0:	fb 48 06 b4 	st.w	sp[1716],r8
80007db4:	c0 58       	rjmp	80007dbe <_vfprintf_r+0x71e>
80007db6:	72 0b       	ld.w	r11,r9[0x0]
80007db8:	14 97       	mov	r7,r10
80007dba:	2f c9       	sub	r9,-4
80007dbc:	51 09       	stdsp	sp[0x40],r9
80007dbe:	50 1b       	stdsp	sp[0x4],r11
80007dc0:	bf 5b       	asr	r11,0x1f
80007dc2:	50 0b       	stdsp	sp[0x0],r11
80007dc4:	fa ea 00 00 	ld.d	r10,sp[0]
80007dc8:	58 0a       	cp.w	r10,0
80007dca:	5c 2b       	cpc	r11
80007dcc:	c0 e4       	brge	80007de8 <_vfprintf_r+0x748>
80007dce:	30 08       	mov	r8,0
80007dd0:	fa ea 00 00 	ld.d	r10,sp[0]
80007dd4:	30 09       	mov	r9,0
80007dd6:	f0 0a 01 0a 	sub	r10,r8,r10
80007dda:	f2 0b 01 4b 	sbc	r11,r9,r11
80007dde:	32 d8       	mov	r8,45
80007de0:	fa eb 00 00 	st.d	sp[0],r10
80007de4:	fb 68 06 bb 	st.b	sp[1723],r8
80007de8:	30 18       	mov	r8,1
80007dea:	e0 8f 06 fa 	bral	80008bde <_vfprintf_r+0x153e>
80007dee:	50 a7       	stdsp	sp[0x28],r7
80007df0:	50 80       	stdsp	sp[0x20],r0
80007df2:	0c 97       	mov	r7,r6
80007df4:	04 94       	mov	r4,r2
80007df6:	06 96       	mov	r6,r3
80007df8:	02 92       	mov	r2,r1
80007dfa:	40 93       	lddsp	r3,sp[0x24]
80007dfc:	10 90       	mov	r0,r8
80007dfe:	40 41       	lddsp	r1,sp[0x10]
80007e00:	0e 99       	mov	r9,r7
80007e02:	ed b5 00 03 	bld	r5,0x3
80007e06:	c4 11       	brne	80007e88 <_vfprintf_r+0x7e8>
80007e08:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e0c:	40 3a       	lddsp	r10,sp[0xc]
80007e0e:	58 0a       	cp.w	r10,0
80007e10:	c1 90       	breq	80007e42 <_vfprintf_r+0x7a2>
80007e12:	10 36       	cp.w	r6,r8
80007e14:	c6 45       	brlt	80007edc <_vfprintf_r+0x83c>
80007e16:	fa c8 f9 50 	sub	r8,sp,-1712
80007e1a:	1a d8       	st.w	--sp,r8
80007e1c:	fa c8 fa b8 	sub	r8,sp,-1352
80007e20:	1a d8       	st.w	--sp,r8
80007e22:	fa c8 fb b4 	sub	r8,sp,-1100
80007e26:	0c 9b       	mov	r11,r6
80007e28:	1a d8       	st.w	--sp,r8
80007e2a:	04 9a       	mov	r10,r2
80007e2c:	fa c8 f9 40 	sub	r8,sp,-1728
80007e30:	fa c9 ff b4 	sub	r9,sp,-76
80007e34:	08 9c       	mov	r12,r4
80007e36:	fe b0 fa 9d 	rcall	80007370 <get_arg>
80007e3a:	2f dd       	sub	sp,-12
80007e3c:	78 16       	ld.w	r6,r12[0x4]
80007e3e:	50 76       	stdsp	sp[0x1c],r6
80007e40:	c4 88       	rjmp	80007ed0 <_vfprintf_r+0x830>
80007e42:	2f f7       	sub	r7,-1
80007e44:	10 39       	cp.w	r9,r8
80007e46:	c0 c4       	brge	80007e5e <_vfprintf_r+0x7be>
80007e48:	fa ce f9 44 	sub	lr,sp,-1724
80007e4c:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007e50:	ec fc fd 8c 	ld.w	r12,r6[-628]
80007e54:	50 7c       	stdsp	sp[0x1c],r12
80007e56:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007e5a:	50 56       	stdsp	sp[0x14],r6
80007e5c:	c6 68       	rjmp	80007f28 <_vfprintf_r+0x888>
80007e5e:	41 09       	lddsp	r9,sp[0x40]
80007e60:	59 f8       	cp.w	r8,31
80007e62:	e0 89 00 10 	brgt	80007e82 <_vfprintf_r+0x7e2>
80007e66:	f2 ca ff f8 	sub	r10,r9,-8
80007e6a:	72 1b       	ld.w	r11,r9[0x4]
80007e6c:	51 0a       	stdsp	sp[0x40],r10
80007e6e:	72 09       	ld.w	r9,r9[0x0]
80007e70:	fa ca f9 44 	sub	r10,sp,-1724
80007e74:	50 7b       	stdsp	sp[0x1c],r11
80007e76:	50 59       	stdsp	sp[0x14],r9
80007e78:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007e7c:	40 5b       	lddsp	r11,sp[0x14]
80007e7e:	40 7a       	lddsp	r10,sp[0x1c]
80007e80:	c4 78       	rjmp	80007f0e <_vfprintf_r+0x86e>
80007e82:	72 18       	ld.w	r8,r9[0x4]
80007e84:	50 78       	stdsp	sp[0x1c],r8
80007e86:	c4 c8       	rjmp	80007f1e <_vfprintf_r+0x87e>
80007e88:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e8c:	40 3e       	lddsp	lr,sp[0xc]
80007e8e:	58 0e       	cp.w	lr,0
80007e90:	c2 30       	breq	80007ed6 <_vfprintf_r+0x836>
80007e92:	10 36       	cp.w	r6,r8
80007e94:	c0 94       	brge	80007ea6 <_vfprintf_r+0x806>
80007e96:	fa cc f9 44 	sub	r12,sp,-1724
80007e9a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007e9e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007ea2:	50 7b       	stdsp	sp[0x1c],r11
80007ea4:	cd 9b       	rjmp	80007e56 <_vfprintf_r+0x7b6>
80007ea6:	fa c8 f9 50 	sub	r8,sp,-1712
80007eaa:	1a d8       	st.w	--sp,r8
80007eac:	fa c8 fa b8 	sub	r8,sp,-1352
80007eb0:	04 9a       	mov	r10,r2
80007eb2:	1a d8       	st.w	--sp,r8
80007eb4:	fa c8 fb b4 	sub	r8,sp,-1100
80007eb8:	0c 9b       	mov	r11,r6
80007eba:	1a d8       	st.w	--sp,r8
80007ebc:	08 9c       	mov	r12,r4
80007ebe:	fa c8 f9 40 	sub	r8,sp,-1728
80007ec2:	fa c9 ff b4 	sub	r9,sp,-76
80007ec6:	fe b0 fa 55 	rcall	80007370 <get_arg>
80007eca:	2f dd       	sub	sp,-12
80007ecc:	78 1a       	ld.w	r10,r12[0x4]
80007ece:	50 7a       	stdsp	sp[0x1c],r10
80007ed0:	78 0c       	ld.w	r12,r12[0x0]
80007ed2:	50 5c       	stdsp	sp[0x14],r12
80007ed4:	c2 a8       	rjmp	80007f28 <_vfprintf_r+0x888>
80007ed6:	2f f7       	sub	r7,-1
80007ed8:	10 39       	cp.w	r9,r8
80007eda:	c0 94       	brge	80007eec <_vfprintf_r+0x84c>
80007edc:	fa c9 f9 44 	sub	r9,sp,-1724
80007ee0:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ee4:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007ee8:	50 78       	stdsp	sp[0x1c],r8
80007eea:	cb 6b       	rjmp	80007e56 <_vfprintf_r+0x7b6>
80007eec:	41 09       	lddsp	r9,sp[0x40]
80007eee:	59 f8       	cp.w	r8,31
80007ef0:	e0 89 00 15 	brgt	80007f1a <_vfprintf_r+0x87a>
80007ef4:	f2 ca ff f8 	sub	r10,r9,-8
80007ef8:	72 16       	ld.w	r6,r9[0x4]
80007efa:	72 09       	ld.w	r9,r9[0x0]
80007efc:	51 0a       	stdsp	sp[0x40],r10
80007efe:	50 59       	stdsp	sp[0x14],r9
80007f00:	fa ce f9 44 	sub	lr,sp,-1724
80007f04:	50 76       	stdsp	sp[0x1c],r6
80007f06:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007f0a:	40 5b       	lddsp	r11,sp[0x14]
80007f0c:	0c 9a       	mov	r10,r6
80007f0e:	f2 eb fd 88 	st.d	r9[-632],r10
80007f12:	2f f8       	sub	r8,-1
80007f14:	fb 48 06 b4 	st.w	sp[1716],r8
80007f18:	c0 88       	rjmp	80007f28 <_vfprintf_r+0x888>
80007f1a:	72 1c       	ld.w	r12,r9[0x4]
80007f1c:	50 7c       	stdsp	sp[0x1c],r12
80007f1e:	f2 c8 ff f8 	sub	r8,r9,-8
80007f22:	51 08       	stdsp	sp[0x40],r8
80007f24:	72 09       	ld.w	r9,r9[0x0]
80007f26:	50 59       	stdsp	sp[0x14],r9
80007f28:	40 5b       	lddsp	r11,sp[0x14]
80007f2a:	40 7a       	lddsp	r10,sp[0x1c]
80007f2c:	e0 a0 19 54 	rcall	8000b1d4 <__isinfd>
80007f30:	18 96       	mov	r6,r12
80007f32:	c1 70       	breq	80007f60 <_vfprintf_r+0x8c0>
80007f34:	30 08       	mov	r8,0
80007f36:	30 09       	mov	r9,0
80007f38:	40 5b       	lddsp	r11,sp[0x14]
80007f3a:	40 7a       	lddsp	r10,sp[0x1c]
80007f3c:	e0 a0 1d a8 	rcall	8000ba8c <__avr32_f64_cmp_lt>
80007f40:	c0 40       	breq	80007f48 <_vfprintf_r+0x8a8>
80007f42:	32 d8       	mov	r8,45
80007f44:	fb 68 06 bb 	st.b	sp[1723],r8
80007f48:	fe c8 a4 e0 	sub	r8,pc,-23328
80007f4c:	fe c6 a4 e0 	sub	r6,pc,-23328
80007f50:	a7 d5       	cbr	r5,0x7
80007f52:	e0 40 00 47 	cp.w	r0,71
80007f56:	f0 06 17 a0 	movle	r6,r8
80007f5a:	30 32       	mov	r2,3
80007f5c:	e0 8f 06 ce 	bral	80008cf8 <_vfprintf_r+0x1658>
80007f60:	40 5b       	lddsp	r11,sp[0x14]
80007f62:	40 7a       	lddsp	r10,sp[0x1c]
80007f64:	e0 a0 19 4d 	rcall	8000b1fe <__isnand>
80007f68:	c0 e0       	breq	80007f84 <_vfprintf_r+0x8e4>
80007f6a:	50 26       	stdsp	sp[0x8],r6
80007f6c:	fe c8 a4 fc 	sub	r8,pc,-23300
80007f70:	fe c6 a4 fc 	sub	r6,pc,-23300
80007f74:	a7 d5       	cbr	r5,0x7
80007f76:	e0 40 00 47 	cp.w	r0,71
80007f7a:	f0 06 17 a0 	movle	r6,r8
80007f7e:	30 32       	mov	r2,3
80007f80:	e0 8f 06 c2 	bral	80008d04 <_vfprintf_r+0x1664>
80007f84:	40 2a       	lddsp	r10,sp[0x8]
80007f86:	5b fa       	cp.w	r10,-1
80007f88:	c0 41       	brne	80007f90 <_vfprintf_r+0x8f0>
80007f8a:	30 69       	mov	r9,6
80007f8c:	50 29       	stdsp	sp[0x8],r9
80007f8e:	c1 18       	rjmp	80007fb0 <_vfprintf_r+0x910>
80007f90:	e0 40 00 47 	cp.w	r0,71
80007f94:	5f 09       	sreq	r9
80007f96:	e0 40 00 67 	cp.w	r0,103
80007f9a:	5f 08       	sreq	r8
80007f9c:	f3 e8 10 08 	or	r8,r9,r8
80007fa0:	f8 08 18 00 	cp.b	r8,r12
80007fa4:	c0 60       	breq	80007fb0 <_vfprintf_r+0x910>
80007fa6:	40 28       	lddsp	r8,sp[0x8]
80007fa8:	58 08       	cp.w	r8,0
80007faa:	f9 b8 00 01 	moveq	r8,1
80007fae:	50 28       	stdsp	sp[0x8],r8
80007fb0:	40 78       	lddsp	r8,sp[0x1c]
80007fb2:	40 59       	lddsp	r9,sp[0x14]
80007fb4:	fa e9 06 94 	st.d	sp[1684],r8
80007fb8:	a9 a5       	sbr	r5,0x8
80007fba:	fa f8 06 94 	ld.w	r8,sp[1684]
80007fbe:	58 08       	cp.w	r8,0
80007fc0:	c0 65       	brlt	80007fcc <_vfprintf_r+0x92c>
80007fc2:	40 5e       	lddsp	lr,sp[0x14]
80007fc4:	30 0c       	mov	r12,0
80007fc6:	50 6e       	stdsp	sp[0x18],lr
80007fc8:	50 9c       	stdsp	sp[0x24],r12
80007fca:	c0 78       	rjmp	80007fd8 <_vfprintf_r+0x938>
80007fcc:	40 5b       	lddsp	r11,sp[0x14]
80007fce:	32 da       	mov	r10,45
80007fd0:	ee 1b 80 00 	eorh	r11,0x8000
80007fd4:	50 9a       	stdsp	sp[0x24],r10
80007fd6:	50 6b       	stdsp	sp[0x18],r11
80007fd8:	e0 40 00 46 	cp.w	r0,70
80007fdc:	5f 09       	sreq	r9
80007fde:	e0 40 00 66 	cp.w	r0,102
80007fe2:	5f 08       	sreq	r8
80007fe4:	f3 e8 10 08 	or	r8,r9,r8
80007fe8:	50 48       	stdsp	sp[0x10],r8
80007fea:	c0 40       	breq	80007ff2 <_vfprintf_r+0x952>
80007fec:	40 22       	lddsp	r2,sp[0x8]
80007fee:	30 39       	mov	r9,3
80007ff0:	c1 08       	rjmp	80008010 <_vfprintf_r+0x970>
80007ff2:	e0 40 00 45 	cp.w	r0,69
80007ff6:	5f 09       	sreq	r9
80007ff8:	e0 40 00 65 	cp.w	r0,101
80007ffc:	5f 08       	sreq	r8
80007ffe:	40 22       	lddsp	r2,sp[0x8]
80008000:	10 49       	or	r9,r8
80008002:	2f f2       	sub	r2,-1
80008004:	40 46       	lddsp	r6,sp[0x10]
80008006:	ec 09 18 00 	cp.b	r9,r6
8000800a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000800e:	30 29       	mov	r9,2
80008010:	fa c8 f9 5c 	sub	r8,sp,-1700
80008014:	1a d8       	st.w	--sp,r8
80008016:	fa c8 f9 54 	sub	r8,sp,-1708
8000801a:	1a d8       	st.w	--sp,r8
8000801c:	fa c8 f9 4c 	sub	r8,sp,-1716
80008020:	08 9c       	mov	r12,r4
80008022:	1a d8       	st.w	--sp,r8
80008024:	04 98       	mov	r8,r2
80008026:	40 9b       	lddsp	r11,sp[0x24]
80008028:	40 aa       	lddsp	r10,sp[0x28]
8000802a:	e0 a0 0b c3 	rcall	800097b0 <_dtoa_r>
8000802e:	e0 40 00 47 	cp.w	r0,71
80008032:	5f 19       	srne	r9
80008034:	e0 40 00 67 	cp.w	r0,103
80008038:	5f 18       	srne	r8
8000803a:	18 96       	mov	r6,r12
8000803c:	2f dd       	sub	sp,-12
8000803e:	f3 e8 00 08 	and	r8,r9,r8
80008042:	c0 41       	brne	8000804a <_vfprintf_r+0x9aa>
80008044:	ed b5 00 00 	bld	r5,0x0
80008048:	c3 01       	brne	800080a8 <_vfprintf_r+0xa08>
8000804a:	ec 02 00 0e 	add	lr,r6,r2
8000804e:	50 3e       	stdsp	sp[0xc],lr
80008050:	40 4c       	lddsp	r12,sp[0x10]
80008052:	58 0c       	cp.w	r12,0
80008054:	c1 50       	breq	8000807e <_vfprintf_r+0x9de>
80008056:	0d 89       	ld.ub	r9,r6[0x0]
80008058:	33 08       	mov	r8,48
8000805a:	f0 09 18 00 	cp.b	r9,r8
8000805e:	c0 b1       	brne	80008074 <_vfprintf_r+0x9d4>
80008060:	30 08       	mov	r8,0
80008062:	30 09       	mov	r9,0
80008064:	40 6b       	lddsp	r11,sp[0x18]
80008066:	40 7a       	lddsp	r10,sp[0x1c]
80008068:	e0 a0 1c cb 	rcall	8000b9fe <__avr32_f64_cmp_eq>
8000806c:	fb b2 00 01 	rsubeq	r2,1
80008070:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008074:	40 3b       	lddsp	r11,sp[0xc]
80008076:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000807a:	10 0b       	add	r11,r8
8000807c:	50 3b       	stdsp	sp[0xc],r11
8000807e:	40 6b       	lddsp	r11,sp[0x18]
80008080:	30 08       	mov	r8,0
80008082:	30 09       	mov	r9,0
80008084:	40 7a       	lddsp	r10,sp[0x1c]
80008086:	e0 a0 1c bc 	rcall	8000b9fe <__avr32_f64_cmp_eq>
8000808a:	c0 90       	breq	8000809c <_vfprintf_r+0x9fc>
8000808c:	40 3a       	lddsp	r10,sp[0xc]
8000808e:	fb 4a 06 a4 	st.w	sp[1700],r10
80008092:	c0 58       	rjmp	8000809c <_vfprintf_r+0x9fc>
80008094:	10 c9       	st.b	r8++,r9
80008096:	fb 48 06 a4 	st.w	sp[1700],r8
8000809a:	c0 28       	rjmp	8000809e <_vfprintf_r+0x9fe>
8000809c:	33 09       	mov	r9,48
8000809e:	fa f8 06 a4 	ld.w	r8,sp[1700]
800080a2:	40 3e       	lddsp	lr,sp[0xc]
800080a4:	1c 38       	cp.w	r8,lr
800080a6:	cf 73       	brcs	80008094 <_vfprintf_r+0x9f4>
800080a8:	e0 40 00 47 	cp.w	r0,71
800080ac:	5f 09       	sreq	r9
800080ae:	e0 40 00 67 	cp.w	r0,103
800080b2:	5f 08       	sreq	r8
800080b4:	f3 e8 10 08 	or	r8,r9,r8
800080b8:	fa f9 06 a4 	ld.w	r9,sp[1700]
800080bc:	0c 19       	sub	r9,r6
800080be:	50 69       	stdsp	sp[0x18],r9
800080c0:	58 08       	cp.w	r8,0
800080c2:	c0 b0       	breq	800080d8 <_vfprintf_r+0xa38>
800080c4:	fa f8 06 ac 	ld.w	r8,sp[1708]
800080c8:	5b d8       	cp.w	r8,-3
800080ca:	c0 55       	brlt	800080d4 <_vfprintf_r+0xa34>
800080cc:	40 2c       	lddsp	r12,sp[0x8]
800080ce:	18 38       	cp.w	r8,r12
800080d0:	e0 8a 00 6a 	brle	800081a4 <_vfprintf_r+0xb04>
800080d4:	20 20       	sub	r0,2
800080d6:	c0 58       	rjmp	800080e0 <_vfprintf_r+0xa40>
800080d8:	e0 40 00 65 	cp.w	r0,101
800080dc:	e0 89 00 46 	brgt	80008168 <_vfprintf_r+0xac8>
800080e0:	fa fb 06 ac 	ld.w	r11,sp[1708]
800080e4:	fb 60 06 9c 	st.b	sp[1692],r0
800080e8:	20 1b       	sub	r11,1
800080ea:	fb 4b 06 ac 	st.w	sp[1708],r11
800080ee:	c0 47       	brpl	800080f6 <_vfprintf_r+0xa56>
800080f0:	5c 3b       	neg	r11
800080f2:	32 d8       	mov	r8,45
800080f4:	c0 28       	rjmp	800080f8 <_vfprintf_r+0xa58>
800080f6:	32 b8       	mov	r8,43
800080f8:	fb 68 06 9d 	st.b	sp[1693],r8
800080fc:	58 9b       	cp.w	r11,9
800080fe:	e0 8a 00 1d 	brle	80008138 <_vfprintf_r+0xa98>
80008102:	fa c9 fa 35 	sub	r9,sp,-1483
80008106:	30 aa       	mov	r10,10
80008108:	12 98       	mov	r8,r9
8000810a:	0e 9c       	mov	r12,r7
8000810c:	0c 92       	mov	r2,r6
8000810e:	f6 0a 0c 06 	divs	r6,r11,r10
80008112:	0e 9b       	mov	r11,r7
80008114:	2d 0b       	sub	r11,-48
80008116:	10 fb       	st.b	--r8,r11
80008118:	0c 9b       	mov	r11,r6
8000811a:	58 96       	cp.w	r6,9
8000811c:	fe 99 ff f9 	brgt	8000810e <_vfprintf_r+0xa6e>
80008120:	2d 0b       	sub	r11,-48
80008122:	18 97       	mov	r7,r12
80008124:	04 96       	mov	r6,r2
80008126:	10 fb       	st.b	--r8,r11
80008128:	fa ca f9 62 	sub	r10,sp,-1694
8000812c:	c0 38       	rjmp	80008132 <_vfprintf_r+0xa92>
8000812e:	11 3b       	ld.ub	r11,r8++
80008130:	14 cb       	st.b	r10++,r11
80008132:	12 38       	cp.w	r8,r9
80008134:	cf d3       	brcs	8000812e <_vfprintf_r+0xa8e>
80008136:	c0 98       	rjmp	80008148 <_vfprintf_r+0xaa8>
80008138:	2d 0b       	sub	r11,-48
8000813a:	33 08       	mov	r8,48
8000813c:	fb 6b 06 9f 	st.b	sp[1695],r11
80008140:	fb 68 06 9e 	st.b	sp[1694],r8
80008144:	fa ca f9 60 	sub	r10,sp,-1696
80008148:	fa c8 f9 64 	sub	r8,sp,-1692
8000814c:	f4 08 01 08 	sub	r8,r10,r8
80008150:	50 e8       	stdsp	sp[0x38],r8
80008152:	10 92       	mov	r2,r8
80008154:	40 6b       	lddsp	r11,sp[0x18]
80008156:	16 02       	add	r2,r11
80008158:	58 1b       	cp.w	r11,1
8000815a:	e0 89 00 05 	brgt	80008164 <_vfprintf_r+0xac4>
8000815e:	ed b5 00 00 	bld	r5,0x0
80008162:	c3 51       	brne	800081cc <_vfprintf_r+0xb2c>
80008164:	2f f2       	sub	r2,-1
80008166:	c3 38       	rjmp	800081cc <_vfprintf_r+0xb2c>
80008168:	e0 40 00 66 	cp.w	r0,102
8000816c:	c1 c1       	brne	800081a4 <_vfprintf_r+0xb04>
8000816e:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008172:	58 02       	cp.w	r2,0
80008174:	e0 8a 00 0c 	brle	8000818c <_vfprintf_r+0xaec>
80008178:	40 2a       	lddsp	r10,sp[0x8]
8000817a:	58 0a       	cp.w	r10,0
8000817c:	c0 41       	brne	80008184 <_vfprintf_r+0xae4>
8000817e:	ed b5 00 00 	bld	r5,0x0
80008182:	c2 51       	brne	800081cc <_vfprintf_r+0xb2c>
80008184:	2f f2       	sub	r2,-1
80008186:	40 29       	lddsp	r9,sp[0x8]
80008188:	12 02       	add	r2,r9
8000818a:	c0 b8       	rjmp	800081a0 <_vfprintf_r+0xb00>
8000818c:	40 28       	lddsp	r8,sp[0x8]
8000818e:	58 08       	cp.w	r8,0
80008190:	c0 61       	brne	8000819c <_vfprintf_r+0xafc>
80008192:	ed b5 00 00 	bld	r5,0x0
80008196:	c0 30       	breq	8000819c <_vfprintf_r+0xafc>
80008198:	30 12       	mov	r2,1
8000819a:	c1 98       	rjmp	800081cc <_vfprintf_r+0xb2c>
8000819c:	40 22       	lddsp	r2,sp[0x8]
8000819e:	2f e2       	sub	r2,-2
800081a0:	36 60       	mov	r0,102
800081a2:	c1 58       	rjmp	800081cc <_vfprintf_r+0xb2c>
800081a4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800081a8:	40 6e       	lddsp	lr,sp[0x18]
800081aa:	1c 32       	cp.w	r2,lr
800081ac:	c0 65       	brlt	800081b8 <_vfprintf_r+0xb18>
800081ae:	ed b5 00 00 	bld	r5,0x0
800081b2:	f7 b2 00 ff 	subeq	r2,-1
800081b6:	c0 a8       	rjmp	800081ca <_vfprintf_r+0xb2a>
800081b8:	e4 08 11 02 	rsub	r8,r2,2
800081bc:	40 6c       	lddsp	r12,sp[0x18]
800081be:	58 02       	cp.w	r2,0
800081c0:	f0 02 17 a0 	movle	r2,r8
800081c4:	f9 b2 09 01 	movgt	r2,1
800081c8:	18 02       	add	r2,r12
800081ca:	36 70       	mov	r0,103
800081cc:	40 9b       	lddsp	r11,sp[0x24]
800081ce:	58 0b       	cp.w	r11,0
800081d0:	e0 80 05 94 	breq	80008cf8 <_vfprintf_r+0x1658>
800081d4:	32 d8       	mov	r8,45
800081d6:	fb 68 06 bb 	st.b	sp[1723],r8
800081da:	e0 8f 05 93 	bral	80008d00 <_vfprintf_r+0x1660>
800081de:	50 a7       	stdsp	sp[0x28],r7
800081e0:	04 94       	mov	r4,r2
800081e2:	0c 97       	mov	r7,r6
800081e4:	02 92       	mov	r2,r1
800081e6:	06 96       	mov	r6,r3
800081e8:	40 41       	lddsp	r1,sp[0x10]
800081ea:	40 93       	lddsp	r3,sp[0x24]
800081ec:	0e 99       	mov	r9,r7
800081ee:	ed b5 00 05 	bld	r5,0x5
800081f2:	c4 81       	brne	80008282 <_vfprintf_r+0xbe2>
800081f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081f8:	40 3e       	lddsp	lr,sp[0xc]
800081fa:	58 0e       	cp.w	lr,0
800081fc:	c1 d0       	breq	80008236 <_vfprintf_r+0xb96>
800081fe:	10 36       	cp.w	r6,r8
80008200:	c0 64       	brge	8000820c <_vfprintf_r+0xb6c>
80008202:	fa cc f9 44 	sub	r12,sp,-1724
80008206:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000820a:	c1 d8       	rjmp	80008244 <_vfprintf_r+0xba4>
8000820c:	fa c8 f9 50 	sub	r8,sp,-1712
80008210:	1a d8       	st.w	--sp,r8
80008212:	fa c8 fa b8 	sub	r8,sp,-1352
80008216:	04 9a       	mov	r10,r2
80008218:	1a d8       	st.w	--sp,r8
8000821a:	fa c8 fb b4 	sub	r8,sp,-1100
8000821e:	0c 9b       	mov	r11,r6
80008220:	1a d8       	st.w	--sp,r8
80008222:	08 9c       	mov	r12,r4
80008224:	fa c8 f9 40 	sub	r8,sp,-1728
80008228:	fa c9 ff b4 	sub	r9,sp,-76
8000822c:	fe b0 f8 a2 	rcall	80007370 <get_arg>
80008230:	2f dd       	sub	sp,-12
80008232:	78 0a       	ld.w	r10,r12[0x0]
80008234:	c2 08       	rjmp	80008274 <_vfprintf_r+0xbd4>
80008236:	2f f7       	sub	r7,-1
80008238:	10 39       	cp.w	r9,r8
8000823a:	c0 84       	brge	8000824a <_vfprintf_r+0xbaa>
8000823c:	fa cb f9 44 	sub	r11,sp,-1724
80008240:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008244:	ec fa fd 88 	ld.w	r10,r6[-632]
80008248:	c1 68       	rjmp	80008274 <_vfprintf_r+0xbd4>
8000824a:	41 09       	lddsp	r9,sp[0x40]
8000824c:	59 f8       	cp.w	r8,31
8000824e:	e0 89 00 10 	brgt	8000826e <_vfprintf_r+0xbce>
80008252:	f2 ca ff fc 	sub	r10,r9,-4
80008256:	51 0a       	stdsp	sp[0x40],r10
80008258:	fa c6 f9 44 	sub	r6,sp,-1724
8000825c:	72 0a       	ld.w	r10,r9[0x0]
8000825e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008262:	f3 4a fd 88 	st.w	r9[-632],r10
80008266:	2f f8       	sub	r8,-1
80008268:	fb 48 06 b4 	st.w	sp[1716],r8
8000826c:	c0 48       	rjmp	80008274 <_vfprintf_r+0xbd4>
8000826e:	72 0a       	ld.w	r10,r9[0x0]
80008270:	2f c9       	sub	r9,-4
80008272:	51 09       	stdsp	sp[0x40],r9
80008274:	40 be       	lddsp	lr,sp[0x2c]
80008276:	1c 98       	mov	r8,lr
80008278:	95 1e       	st.w	r10[0x4],lr
8000827a:	bf 58       	asr	r8,0x1f
8000827c:	95 08       	st.w	r10[0x0],r8
8000827e:	fe 9f fa 9f 	bral	800077bc <_vfprintf_r+0x11c>
80008282:	ed b5 00 04 	bld	r5,0x4
80008286:	c4 80       	breq	80008316 <_vfprintf_r+0xc76>
80008288:	e2 15 00 40 	andl	r5,0x40,COH
8000828c:	c4 50       	breq	80008316 <_vfprintf_r+0xc76>
8000828e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008292:	40 3c       	lddsp	r12,sp[0xc]
80008294:	58 0c       	cp.w	r12,0
80008296:	c1 d0       	breq	800082d0 <_vfprintf_r+0xc30>
80008298:	10 36       	cp.w	r6,r8
8000829a:	c0 64       	brge	800082a6 <_vfprintf_r+0xc06>
8000829c:	fa cb f9 44 	sub	r11,sp,-1724
800082a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800082a4:	c1 d8       	rjmp	800082de <_vfprintf_r+0xc3e>
800082a6:	fa c8 f9 50 	sub	r8,sp,-1712
800082aa:	1a d8       	st.w	--sp,r8
800082ac:	fa c8 fa b8 	sub	r8,sp,-1352
800082b0:	04 9a       	mov	r10,r2
800082b2:	1a d8       	st.w	--sp,r8
800082b4:	fa c8 fb b4 	sub	r8,sp,-1100
800082b8:	0c 9b       	mov	r11,r6
800082ba:	1a d8       	st.w	--sp,r8
800082bc:	08 9c       	mov	r12,r4
800082be:	fa c8 f9 40 	sub	r8,sp,-1728
800082c2:	fa c9 ff b4 	sub	r9,sp,-76
800082c6:	fe b0 f8 55 	rcall	80007370 <get_arg>
800082ca:	2f dd       	sub	sp,-12
800082cc:	78 0a       	ld.w	r10,r12[0x0]
800082ce:	c2 08       	rjmp	8000830e <_vfprintf_r+0xc6e>
800082d0:	2f f7       	sub	r7,-1
800082d2:	10 39       	cp.w	r9,r8
800082d4:	c0 84       	brge	800082e4 <_vfprintf_r+0xc44>
800082d6:	fa ca f9 44 	sub	r10,sp,-1724
800082da:	f4 06 00 36 	add	r6,r10,r6<<0x3
800082de:	ec fa fd 88 	ld.w	r10,r6[-632]
800082e2:	c1 68       	rjmp	8000830e <_vfprintf_r+0xc6e>
800082e4:	41 09       	lddsp	r9,sp[0x40]
800082e6:	59 f8       	cp.w	r8,31
800082e8:	e0 89 00 10 	brgt	80008308 <_vfprintf_r+0xc68>
800082ec:	f2 ca ff fc 	sub	r10,r9,-4
800082f0:	51 0a       	stdsp	sp[0x40],r10
800082f2:	fa c6 f9 44 	sub	r6,sp,-1724
800082f6:	72 0a       	ld.w	r10,r9[0x0]
800082f8:	ec 08 00 39 	add	r9,r6,r8<<0x3
800082fc:	f3 4a fd 88 	st.w	r9[-632],r10
80008300:	2f f8       	sub	r8,-1
80008302:	fb 48 06 b4 	st.w	sp[1716],r8
80008306:	c0 48       	rjmp	8000830e <_vfprintf_r+0xc6e>
80008308:	72 0a       	ld.w	r10,r9[0x0]
8000830a:	2f c9       	sub	r9,-4
8000830c:	51 09       	stdsp	sp[0x40],r9
8000830e:	40 be       	lddsp	lr,sp[0x2c]
80008310:	b4 0e       	st.h	r10[0x0],lr
80008312:	fe 9f fa 55 	bral	800077bc <_vfprintf_r+0x11c>
80008316:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000831a:	40 3c       	lddsp	r12,sp[0xc]
8000831c:	58 0c       	cp.w	r12,0
8000831e:	c1 d0       	breq	80008358 <_vfprintf_r+0xcb8>
80008320:	10 36       	cp.w	r6,r8
80008322:	c0 64       	brge	8000832e <_vfprintf_r+0xc8e>
80008324:	fa cb f9 44 	sub	r11,sp,-1724
80008328:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000832c:	c1 d8       	rjmp	80008366 <_vfprintf_r+0xcc6>
8000832e:	fa c8 f9 50 	sub	r8,sp,-1712
80008332:	1a d8       	st.w	--sp,r8
80008334:	fa c8 fa b8 	sub	r8,sp,-1352
80008338:	04 9a       	mov	r10,r2
8000833a:	1a d8       	st.w	--sp,r8
8000833c:	fa c8 fb b4 	sub	r8,sp,-1100
80008340:	0c 9b       	mov	r11,r6
80008342:	1a d8       	st.w	--sp,r8
80008344:	08 9c       	mov	r12,r4
80008346:	fa c8 f9 40 	sub	r8,sp,-1728
8000834a:	fa c9 ff b4 	sub	r9,sp,-76
8000834e:	fe b0 f8 11 	rcall	80007370 <get_arg>
80008352:	2f dd       	sub	sp,-12
80008354:	78 0a       	ld.w	r10,r12[0x0]
80008356:	c2 08       	rjmp	80008396 <_vfprintf_r+0xcf6>
80008358:	2f f7       	sub	r7,-1
8000835a:	10 39       	cp.w	r9,r8
8000835c:	c0 84       	brge	8000836c <_vfprintf_r+0xccc>
8000835e:	fa ca f9 44 	sub	r10,sp,-1724
80008362:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008366:	ec fa fd 88 	ld.w	r10,r6[-632]
8000836a:	c1 68       	rjmp	80008396 <_vfprintf_r+0xcf6>
8000836c:	41 09       	lddsp	r9,sp[0x40]
8000836e:	59 f8       	cp.w	r8,31
80008370:	e0 89 00 10 	brgt	80008390 <_vfprintf_r+0xcf0>
80008374:	f2 ca ff fc 	sub	r10,r9,-4
80008378:	51 0a       	stdsp	sp[0x40],r10
8000837a:	fa c6 f9 44 	sub	r6,sp,-1724
8000837e:	72 0a       	ld.w	r10,r9[0x0]
80008380:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008384:	f3 4a fd 88 	st.w	r9[-632],r10
80008388:	2f f8       	sub	r8,-1
8000838a:	fb 48 06 b4 	st.w	sp[1716],r8
8000838e:	c0 48       	rjmp	80008396 <_vfprintf_r+0xcf6>
80008390:	72 0a       	ld.w	r10,r9[0x0]
80008392:	2f c9       	sub	r9,-4
80008394:	51 09       	stdsp	sp[0x40],r9
80008396:	40 be       	lddsp	lr,sp[0x2c]
80008398:	95 0e       	st.w	r10[0x0],lr
8000839a:	fe 9f fa 11 	bral	800077bc <_vfprintf_r+0x11c>
8000839e:	50 a7       	stdsp	sp[0x28],r7
800083a0:	50 80       	stdsp	sp[0x20],r0
800083a2:	0c 97       	mov	r7,r6
800083a4:	04 94       	mov	r4,r2
800083a6:	06 96       	mov	r6,r3
800083a8:	02 92       	mov	r2,r1
800083aa:	40 93       	lddsp	r3,sp[0x24]
800083ac:	10 90       	mov	r0,r8
800083ae:	40 41       	lddsp	r1,sp[0x10]
800083b0:	a5 a5       	sbr	r5,0x4
800083b2:	c0 a8       	rjmp	800083c6 <_vfprintf_r+0xd26>
800083b4:	50 a7       	stdsp	sp[0x28],r7
800083b6:	50 80       	stdsp	sp[0x20],r0
800083b8:	0c 97       	mov	r7,r6
800083ba:	04 94       	mov	r4,r2
800083bc:	06 96       	mov	r6,r3
800083be:	02 92       	mov	r2,r1
800083c0:	40 93       	lddsp	r3,sp[0x24]
800083c2:	10 90       	mov	r0,r8
800083c4:	40 41       	lddsp	r1,sp[0x10]
800083c6:	ed b5 00 05 	bld	r5,0x5
800083ca:	c5 d1       	brne	80008484 <_vfprintf_r+0xde4>
800083cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800083d0:	40 3c       	lddsp	r12,sp[0xc]
800083d2:	58 0c       	cp.w	r12,0
800083d4:	c2 60       	breq	80008420 <_vfprintf_r+0xd80>
800083d6:	10 36       	cp.w	r6,r8
800083d8:	c0 a4       	brge	800083ec <_vfprintf_r+0xd4c>
800083da:	fa cb f9 44 	sub	r11,sp,-1724
800083de:	f6 06 00 36 	add	r6,r11,r6<<0x3
800083e2:	ec e8 fd 88 	ld.d	r8,r6[-632]
800083e6:	fa e9 00 00 	st.d	sp[0],r8
800083ea:	c1 88       	rjmp	8000841a <_vfprintf_r+0xd7a>
800083ec:	fa c8 f9 50 	sub	r8,sp,-1712
800083f0:	1a d8       	st.w	--sp,r8
800083f2:	fa c8 fa b8 	sub	r8,sp,-1352
800083f6:	04 9a       	mov	r10,r2
800083f8:	1a d8       	st.w	--sp,r8
800083fa:	0c 9b       	mov	r11,r6
800083fc:	fa c8 fb b4 	sub	r8,sp,-1100
80008400:	08 9c       	mov	r12,r4
80008402:	1a d8       	st.w	--sp,r8
80008404:	fa c8 f9 40 	sub	r8,sp,-1728
80008408:	fa c9 ff b4 	sub	r9,sp,-76
8000840c:	fe b0 f7 b2 	rcall	80007370 <get_arg>
80008410:	2f dd       	sub	sp,-12
80008412:	f8 ea 00 00 	ld.d	r10,r12[0]
80008416:	fa eb 00 00 	st.d	sp[0],r10
8000841a:	30 08       	mov	r8,0
8000841c:	e0 8f 03 de 	bral	80008bd8 <_vfprintf_r+0x1538>
80008420:	ee ca ff ff 	sub	r10,r7,-1
80008424:	10 37       	cp.w	r7,r8
80008426:	c0 b4       	brge	8000843c <_vfprintf_r+0xd9c>
80008428:	fa c9 f9 44 	sub	r9,sp,-1724
8000842c:	14 97       	mov	r7,r10
8000842e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008432:	ec ea fd 88 	ld.d	r10,r6[-632]
80008436:	fa eb 00 00 	st.d	sp[0],r10
8000843a:	c1 88       	rjmp	8000846a <_vfprintf_r+0xdca>
8000843c:	41 09       	lddsp	r9,sp[0x40]
8000843e:	59 f8       	cp.w	r8,31
80008440:	e0 89 00 18 	brgt	80008470 <_vfprintf_r+0xdd0>
80008444:	f2 e6 00 00 	ld.d	r6,r9[0]
80008448:	f2 cb ff f8 	sub	r11,r9,-8
8000844c:	fa e7 00 00 	st.d	sp[0],r6
80008450:	51 0b       	stdsp	sp[0x40],r11
80008452:	fa c6 f9 44 	sub	r6,sp,-1724
80008456:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000845a:	fa e6 00 00 	ld.d	r6,sp[0]
8000845e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008462:	2f f8       	sub	r8,-1
80008464:	14 97       	mov	r7,r10
80008466:	fb 48 06 b4 	st.w	sp[1716],r8
8000846a:	40 38       	lddsp	r8,sp[0xc]
8000846c:	e0 8f 03 b6 	bral	80008bd8 <_vfprintf_r+0x1538>
80008470:	f2 e6 00 00 	ld.d	r6,r9[0]
80008474:	40 38       	lddsp	r8,sp[0xc]
80008476:	fa e7 00 00 	st.d	sp[0],r6
8000847a:	2f 89       	sub	r9,-8
8000847c:	14 97       	mov	r7,r10
8000847e:	51 09       	stdsp	sp[0x40],r9
80008480:	e0 8f 03 ac 	bral	80008bd8 <_vfprintf_r+0x1538>
80008484:	ed b5 00 04 	bld	r5,0x4
80008488:	c1 61       	brne	800084b4 <_vfprintf_r+0xe14>
8000848a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000848e:	40 3e       	lddsp	lr,sp[0xc]
80008490:	58 0e       	cp.w	lr,0
80008492:	c0 80       	breq	800084a2 <_vfprintf_r+0xe02>
80008494:	10 36       	cp.w	r6,r8
80008496:	c6 74       	brge	80008564 <_vfprintf_r+0xec4>
80008498:	fa cc f9 44 	sub	r12,sp,-1724
8000849c:	f8 06 00 36 	add	r6,r12,r6<<0x3
800084a0:	c8 08       	rjmp	800085a0 <_vfprintf_r+0xf00>
800084a2:	ee ca ff ff 	sub	r10,r7,-1
800084a6:	10 37       	cp.w	r7,r8
800084a8:	c7 f4       	brge	800085a6 <_vfprintf_r+0xf06>
800084aa:	fa cb f9 44 	sub	r11,sp,-1724
800084ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084b2:	c7 68       	rjmp	8000859e <_vfprintf_r+0xefe>
800084b4:	ed b5 00 06 	bld	r5,0x6
800084b8:	c4 a1       	brne	8000854c <_vfprintf_r+0xeac>
800084ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084be:	40 3c       	lddsp	r12,sp[0xc]
800084c0:	58 0c       	cp.w	r12,0
800084c2:	c1 d0       	breq	800084fc <_vfprintf_r+0xe5c>
800084c4:	10 36       	cp.w	r6,r8
800084c6:	c0 64       	brge	800084d2 <_vfprintf_r+0xe32>
800084c8:	fa cb f9 44 	sub	r11,sp,-1724
800084cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800084d0:	c1 f8       	rjmp	8000850e <_vfprintf_r+0xe6e>
800084d2:	fa c8 f9 50 	sub	r8,sp,-1712
800084d6:	1a d8       	st.w	--sp,r8
800084d8:	fa c8 fa b8 	sub	r8,sp,-1352
800084dc:	1a d8       	st.w	--sp,r8
800084de:	fa c8 fb b4 	sub	r8,sp,-1100
800084e2:	1a d8       	st.w	--sp,r8
800084e4:	fa c8 f9 40 	sub	r8,sp,-1728
800084e8:	fa c9 ff b4 	sub	r9,sp,-76
800084ec:	04 9a       	mov	r10,r2
800084ee:	0c 9b       	mov	r11,r6
800084f0:	08 9c       	mov	r12,r4
800084f2:	fe b0 f7 3f 	rcall	80007370 <get_arg>
800084f6:	2f dd       	sub	sp,-12
800084f8:	98 18       	ld.sh	r8,r12[0x2]
800084fa:	c2 68       	rjmp	80008546 <_vfprintf_r+0xea6>
800084fc:	ee ca ff ff 	sub	r10,r7,-1
80008500:	10 37       	cp.w	r7,r8
80008502:	c0 94       	brge	80008514 <_vfprintf_r+0xe74>
80008504:	fa c9 f9 44 	sub	r9,sp,-1724
80008508:	14 97       	mov	r7,r10
8000850a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000850e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008512:	c1 a8       	rjmp	80008546 <_vfprintf_r+0xea6>
80008514:	41 09       	lddsp	r9,sp[0x40]
80008516:	59 f8       	cp.w	r8,31
80008518:	e0 89 00 13 	brgt	8000853e <_vfprintf_r+0xe9e>
8000851c:	f2 cb ff fc 	sub	r11,r9,-4
80008520:	51 0b       	stdsp	sp[0x40],r11
80008522:	72 09       	ld.w	r9,r9[0x0]
80008524:	fa c6 f9 44 	sub	r6,sp,-1724
80008528:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000852c:	2f f8       	sub	r8,-1
8000852e:	f7 49 fd 88 	st.w	r11[-632],r9
80008532:	fb 48 06 b4 	st.w	sp[1716],r8
80008536:	14 97       	mov	r7,r10
80008538:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000853c:	c0 58       	rjmp	80008546 <_vfprintf_r+0xea6>
8000853e:	92 18       	ld.sh	r8,r9[0x2]
80008540:	14 97       	mov	r7,r10
80008542:	2f c9       	sub	r9,-4
80008544:	51 09       	stdsp	sp[0x40],r9
80008546:	5c 78       	castu.h	r8
80008548:	50 18       	stdsp	sp[0x4],r8
8000854a:	c4 68       	rjmp	800085d6 <_vfprintf_r+0xf36>
8000854c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008550:	40 3c       	lddsp	r12,sp[0xc]
80008552:	58 0c       	cp.w	r12,0
80008554:	c1 d0       	breq	8000858e <_vfprintf_r+0xeee>
80008556:	10 36       	cp.w	r6,r8
80008558:	c0 64       	brge	80008564 <_vfprintf_r+0xec4>
8000855a:	fa cb f9 44 	sub	r11,sp,-1724
8000855e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008562:	c1 f8       	rjmp	800085a0 <_vfprintf_r+0xf00>
80008564:	fa c8 f9 50 	sub	r8,sp,-1712
80008568:	1a d8       	st.w	--sp,r8
8000856a:	fa c8 fa b8 	sub	r8,sp,-1352
8000856e:	0c 9b       	mov	r11,r6
80008570:	1a d8       	st.w	--sp,r8
80008572:	fa c8 fb b4 	sub	r8,sp,-1100
80008576:	04 9a       	mov	r10,r2
80008578:	1a d8       	st.w	--sp,r8
8000857a:	08 9c       	mov	r12,r4
8000857c:	fa c8 f9 40 	sub	r8,sp,-1728
80008580:	fa c9 ff b4 	sub	r9,sp,-76
80008584:	fe b0 f6 f6 	rcall	80007370 <get_arg>
80008588:	2f dd       	sub	sp,-12
8000858a:	78 0b       	ld.w	r11,r12[0x0]
8000858c:	c2 48       	rjmp	800085d4 <_vfprintf_r+0xf34>
8000858e:	ee ca ff ff 	sub	r10,r7,-1
80008592:	10 37       	cp.w	r7,r8
80008594:	c0 94       	brge	800085a6 <_vfprintf_r+0xf06>
80008596:	fa c9 f9 44 	sub	r9,sp,-1724
8000859a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000859e:	14 97       	mov	r7,r10
800085a0:	ec fb fd 88 	ld.w	r11,r6[-632]
800085a4:	c1 88       	rjmp	800085d4 <_vfprintf_r+0xf34>
800085a6:	41 09       	lddsp	r9,sp[0x40]
800085a8:	59 f8       	cp.w	r8,31
800085aa:	e0 89 00 11 	brgt	800085cc <_vfprintf_r+0xf2c>
800085ae:	f2 cb ff fc 	sub	r11,r9,-4
800085b2:	51 0b       	stdsp	sp[0x40],r11
800085b4:	fa c6 f9 44 	sub	r6,sp,-1724
800085b8:	72 0b       	ld.w	r11,r9[0x0]
800085ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
800085be:	f3 4b fd 88 	st.w	r9[-632],r11
800085c2:	2f f8       	sub	r8,-1
800085c4:	14 97       	mov	r7,r10
800085c6:	fb 48 06 b4 	st.w	sp[1716],r8
800085ca:	c0 58       	rjmp	800085d4 <_vfprintf_r+0xf34>
800085cc:	72 0b       	ld.w	r11,r9[0x0]
800085ce:	14 97       	mov	r7,r10
800085d0:	2f c9       	sub	r9,-4
800085d2:	51 09       	stdsp	sp[0x40],r9
800085d4:	50 1b       	stdsp	sp[0x4],r11
800085d6:	30 0e       	mov	lr,0
800085d8:	50 0e       	stdsp	sp[0x0],lr
800085da:	1c 98       	mov	r8,lr
800085dc:	e0 8f 02 fe 	bral	80008bd8 <_vfprintf_r+0x1538>
800085e0:	50 a7       	stdsp	sp[0x28],r7
800085e2:	50 80       	stdsp	sp[0x20],r0
800085e4:	0c 97       	mov	r7,r6
800085e6:	04 94       	mov	r4,r2
800085e8:	06 96       	mov	r6,r3
800085ea:	02 92       	mov	r2,r1
800085ec:	40 93       	lddsp	r3,sp[0x24]
800085ee:	40 41       	lddsp	r1,sp[0x10]
800085f0:	0e 99       	mov	r9,r7
800085f2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085f6:	40 3c       	lddsp	r12,sp[0xc]
800085f8:	58 0c       	cp.w	r12,0
800085fa:	c1 d0       	breq	80008634 <_vfprintf_r+0xf94>
800085fc:	10 36       	cp.w	r6,r8
800085fe:	c0 64       	brge	8000860a <_vfprintf_r+0xf6a>
80008600:	fa cb f9 44 	sub	r11,sp,-1724
80008604:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008608:	c1 d8       	rjmp	80008642 <_vfprintf_r+0xfa2>
8000860a:	fa c8 f9 50 	sub	r8,sp,-1712
8000860e:	1a d8       	st.w	--sp,r8
80008610:	fa c8 fa b8 	sub	r8,sp,-1352
80008614:	1a d8       	st.w	--sp,r8
80008616:	fa c8 fb b4 	sub	r8,sp,-1100
8000861a:	1a d8       	st.w	--sp,r8
8000861c:	fa c9 ff b4 	sub	r9,sp,-76
80008620:	fa c8 f9 40 	sub	r8,sp,-1728
80008624:	04 9a       	mov	r10,r2
80008626:	0c 9b       	mov	r11,r6
80008628:	08 9c       	mov	r12,r4
8000862a:	fe b0 f6 a3 	rcall	80007370 <get_arg>
8000862e:	2f dd       	sub	sp,-12
80008630:	78 09       	ld.w	r9,r12[0x0]
80008632:	c2 18       	rjmp	80008674 <_vfprintf_r+0xfd4>
80008634:	2f f7       	sub	r7,-1
80008636:	10 39       	cp.w	r9,r8
80008638:	c0 84       	brge	80008648 <_vfprintf_r+0xfa8>
8000863a:	fa ca f9 44 	sub	r10,sp,-1724
8000863e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008642:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008646:	c1 78       	rjmp	80008674 <_vfprintf_r+0xfd4>
80008648:	41 09       	lddsp	r9,sp[0x40]
8000864a:	59 f8       	cp.w	r8,31
8000864c:	e0 89 00 10 	brgt	8000866c <_vfprintf_r+0xfcc>
80008650:	f2 ca ff fc 	sub	r10,r9,-4
80008654:	51 0a       	stdsp	sp[0x40],r10
80008656:	fa c6 f9 44 	sub	r6,sp,-1724
8000865a:	72 09       	ld.w	r9,r9[0x0]
8000865c:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008660:	f5 49 fd 88 	st.w	r10[-632],r9
80008664:	2f f8       	sub	r8,-1
80008666:	fb 48 06 b4 	st.w	sp[1716],r8
8000866a:	c0 58       	rjmp	80008674 <_vfprintf_r+0xfd4>
8000866c:	f2 c8 ff fc 	sub	r8,r9,-4
80008670:	51 08       	stdsp	sp[0x40],r8
80008672:	72 09       	ld.w	r9,r9[0x0]
80008674:	33 08       	mov	r8,48
80008676:	fb 68 06 b8 	st.b	sp[1720],r8
8000867a:	37 88       	mov	r8,120
8000867c:	30 0e       	mov	lr,0
8000867e:	fb 68 06 b9 	st.b	sp[1721],r8
80008682:	fe cc ac 0a 	sub	r12,pc,-21494
80008686:	50 19       	stdsp	sp[0x4],r9
80008688:	a1 b5       	sbr	r5,0x1
8000868a:	50 0e       	stdsp	sp[0x0],lr
8000868c:	50 dc       	stdsp	sp[0x34],r12
8000868e:	30 28       	mov	r8,2
80008690:	37 80       	mov	r0,120
80008692:	e0 8f 02 a3 	bral	80008bd8 <_vfprintf_r+0x1538>
80008696:	50 a7       	stdsp	sp[0x28],r7
80008698:	50 80       	stdsp	sp[0x20],r0
8000869a:	10 90       	mov	r0,r8
8000869c:	30 08       	mov	r8,0
8000869e:	fb 68 06 bb 	st.b	sp[1723],r8
800086a2:	0c 97       	mov	r7,r6
800086a4:	04 94       	mov	r4,r2
800086a6:	06 96       	mov	r6,r3
800086a8:	02 92       	mov	r2,r1
800086aa:	40 93       	lddsp	r3,sp[0x24]
800086ac:	40 41       	lddsp	r1,sp[0x10]
800086ae:	0e 99       	mov	r9,r7
800086b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086b4:	40 3b       	lddsp	r11,sp[0xc]
800086b6:	58 0b       	cp.w	r11,0
800086b8:	c1 d0       	breq	800086f2 <_vfprintf_r+0x1052>
800086ba:	10 36       	cp.w	r6,r8
800086bc:	c0 64       	brge	800086c8 <_vfprintf_r+0x1028>
800086be:	fa ca f9 44 	sub	r10,sp,-1724
800086c2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800086c6:	c1 d8       	rjmp	80008700 <_vfprintf_r+0x1060>
800086c8:	fa c8 f9 50 	sub	r8,sp,-1712
800086cc:	1a d8       	st.w	--sp,r8
800086ce:	fa c8 fa b8 	sub	r8,sp,-1352
800086d2:	1a d8       	st.w	--sp,r8
800086d4:	fa c8 fb b4 	sub	r8,sp,-1100
800086d8:	0c 9b       	mov	r11,r6
800086da:	1a d8       	st.w	--sp,r8
800086dc:	04 9a       	mov	r10,r2
800086de:	fa c8 f9 40 	sub	r8,sp,-1728
800086e2:	fa c9 ff b4 	sub	r9,sp,-76
800086e6:	08 9c       	mov	r12,r4
800086e8:	fe b0 f6 44 	rcall	80007370 <get_arg>
800086ec:	2f dd       	sub	sp,-12
800086ee:	78 06       	ld.w	r6,r12[0x0]
800086f0:	c2 08       	rjmp	80008730 <_vfprintf_r+0x1090>
800086f2:	2f f7       	sub	r7,-1
800086f4:	10 39       	cp.w	r9,r8
800086f6:	c0 84       	brge	80008706 <_vfprintf_r+0x1066>
800086f8:	fa c9 f9 44 	sub	r9,sp,-1724
800086fc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008700:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008704:	c1 68       	rjmp	80008730 <_vfprintf_r+0x1090>
80008706:	41 09       	lddsp	r9,sp[0x40]
80008708:	59 f8       	cp.w	r8,31
8000870a:	e0 89 00 10 	brgt	8000872a <_vfprintf_r+0x108a>
8000870e:	f2 ca ff fc 	sub	r10,r9,-4
80008712:	51 0a       	stdsp	sp[0x40],r10
80008714:	72 06       	ld.w	r6,r9[0x0]
80008716:	fa ce f9 44 	sub	lr,sp,-1724
8000871a:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000871e:	f3 46 fd 88 	st.w	r9[-632],r6
80008722:	2f f8       	sub	r8,-1
80008724:	fb 48 06 b4 	st.w	sp[1716],r8
80008728:	c0 48       	rjmp	80008730 <_vfprintf_r+0x1090>
8000872a:	72 06       	ld.w	r6,r9[0x0]
8000872c:	2f c9       	sub	r9,-4
8000872e:	51 09       	stdsp	sp[0x40],r9
80008730:	40 2c       	lddsp	r12,sp[0x8]
80008732:	58 0c       	cp.w	r12,0
80008734:	c1 05       	brlt	80008754 <_vfprintf_r+0x10b4>
80008736:	18 9a       	mov	r10,r12
80008738:	30 0b       	mov	r11,0
8000873a:	0c 9c       	mov	r12,r6
8000873c:	e0 a0 12 38 	rcall	8000abac <memchr>
80008740:	e0 80 02 df 	breq	80008cfe <_vfprintf_r+0x165e>
80008744:	f8 06 01 02 	sub	r2,r12,r6
80008748:	40 2b       	lddsp	r11,sp[0x8]
8000874a:	16 32       	cp.w	r2,r11
8000874c:	e0 89 02 d9 	brgt	80008cfe <_vfprintf_r+0x165e>
80008750:	e0 8f 02 d4 	bral	80008cf8 <_vfprintf_r+0x1658>
80008754:	30 0a       	mov	r10,0
80008756:	0c 9c       	mov	r12,r6
80008758:	50 2a       	stdsp	sp[0x8],r10
8000875a:	fe b0 f5 85 	rcall	80007264 <strlen>
8000875e:	18 92       	mov	r2,r12
80008760:	e0 8f 02 d2 	bral	80008d04 <_vfprintf_r+0x1664>
80008764:	50 a7       	stdsp	sp[0x28],r7
80008766:	50 80       	stdsp	sp[0x20],r0
80008768:	0c 97       	mov	r7,r6
8000876a:	04 94       	mov	r4,r2
8000876c:	06 96       	mov	r6,r3
8000876e:	02 92       	mov	r2,r1
80008770:	40 93       	lddsp	r3,sp[0x24]
80008772:	10 90       	mov	r0,r8
80008774:	40 41       	lddsp	r1,sp[0x10]
80008776:	a5 a5       	sbr	r5,0x4
80008778:	c0 a8       	rjmp	8000878c <_vfprintf_r+0x10ec>
8000877a:	50 a7       	stdsp	sp[0x28],r7
8000877c:	50 80       	stdsp	sp[0x20],r0
8000877e:	0c 97       	mov	r7,r6
80008780:	04 94       	mov	r4,r2
80008782:	06 96       	mov	r6,r3
80008784:	02 92       	mov	r2,r1
80008786:	40 93       	lddsp	r3,sp[0x24]
80008788:	10 90       	mov	r0,r8
8000878a:	40 41       	lddsp	r1,sp[0x10]
8000878c:	ed b5 00 05 	bld	r5,0x5
80008790:	c5 61       	brne	8000883c <_vfprintf_r+0x119c>
80008792:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008796:	40 39       	lddsp	r9,sp[0xc]
80008798:	58 09       	cp.w	r9,0
8000879a:	c2 10       	breq	800087dc <_vfprintf_r+0x113c>
8000879c:	10 36       	cp.w	r6,r8
8000879e:	c0 74       	brge	800087ac <_vfprintf_r+0x110c>
800087a0:	fa c8 f9 44 	sub	r8,sp,-1724
800087a4:	f0 06 00 36 	add	r6,r8,r6<<0x3
800087a8:	c2 38       	rjmp	800087ee <_vfprintf_r+0x114e>
800087aa:	d7 03       	nop
800087ac:	fa c8 f9 50 	sub	r8,sp,-1712
800087b0:	1a d8       	st.w	--sp,r8
800087b2:	fa c8 fa b8 	sub	r8,sp,-1352
800087b6:	1a d8       	st.w	--sp,r8
800087b8:	fa c8 fb b4 	sub	r8,sp,-1100
800087bc:	1a d8       	st.w	--sp,r8
800087be:	fa c8 f9 40 	sub	r8,sp,-1728
800087c2:	fa c9 ff b4 	sub	r9,sp,-76
800087c6:	04 9a       	mov	r10,r2
800087c8:	0c 9b       	mov	r11,r6
800087ca:	08 9c       	mov	r12,r4
800087cc:	fe b0 f5 d2 	rcall	80007370 <get_arg>
800087d0:	2f dd       	sub	sp,-12
800087d2:	f8 e8 00 00 	ld.d	r8,r12[0]
800087d6:	fa e9 00 00 	st.d	sp[0],r8
800087da:	c2 e8       	rjmp	80008836 <_vfprintf_r+0x1196>
800087dc:	ee ca ff ff 	sub	r10,r7,-1
800087e0:	10 37       	cp.w	r7,r8
800087e2:	c0 b4       	brge	800087f8 <_vfprintf_r+0x1158>
800087e4:	fa c8 f9 44 	sub	r8,sp,-1724
800087e8:	14 97       	mov	r7,r10
800087ea:	f0 06 00 36 	add	r6,r8,r6<<0x3
800087ee:	ec ea fd 88 	ld.d	r10,r6[-632]
800087f2:	fa eb 00 00 	st.d	sp[0],r10
800087f6:	c2 08       	rjmp	80008836 <_vfprintf_r+0x1196>
800087f8:	41 09       	lddsp	r9,sp[0x40]
800087fa:	59 f8       	cp.w	r8,31
800087fc:	e0 89 00 16 	brgt	80008828 <_vfprintf_r+0x1188>
80008800:	f2 e6 00 00 	ld.d	r6,r9[0]
80008804:	f2 cb ff f8 	sub	r11,r9,-8
80008808:	fa e7 00 00 	st.d	sp[0],r6
8000880c:	51 0b       	stdsp	sp[0x40],r11
8000880e:	fa c6 f9 44 	sub	r6,sp,-1724
80008812:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008816:	fa e6 00 00 	ld.d	r6,sp[0]
8000881a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000881e:	2f f8       	sub	r8,-1
80008820:	14 97       	mov	r7,r10
80008822:	fb 48 06 b4 	st.w	sp[1716],r8
80008826:	c0 88       	rjmp	80008836 <_vfprintf_r+0x1196>
80008828:	f2 e6 00 00 	ld.d	r6,r9[0]
8000882c:	2f 89       	sub	r9,-8
8000882e:	fa e7 00 00 	st.d	sp[0],r6
80008832:	51 09       	stdsp	sp[0x40],r9
80008834:	14 97       	mov	r7,r10
80008836:	30 18       	mov	r8,1
80008838:	e0 8f 01 d0 	bral	80008bd8 <_vfprintf_r+0x1538>
8000883c:	ed b5 00 04 	bld	r5,0x4
80008840:	c1 61       	brne	8000886c <_vfprintf_r+0x11cc>
80008842:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008846:	40 3e       	lddsp	lr,sp[0xc]
80008848:	58 0e       	cp.w	lr,0
8000884a:	c0 80       	breq	8000885a <_vfprintf_r+0x11ba>
8000884c:	10 36       	cp.w	r6,r8
8000884e:	c6 74       	brge	8000891c <_vfprintf_r+0x127c>
80008850:	fa cc f9 44 	sub	r12,sp,-1724
80008854:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008858:	c8 08       	rjmp	80008958 <_vfprintf_r+0x12b8>
8000885a:	ee ca ff ff 	sub	r10,r7,-1
8000885e:	10 37       	cp.w	r7,r8
80008860:	c7 f4       	brge	8000895e <_vfprintf_r+0x12be>
80008862:	fa cb f9 44 	sub	r11,sp,-1724
80008866:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000886a:	c7 68       	rjmp	80008956 <_vfprintf_r+0x12b6>
8000886c:	ed b5 00 06 	bld	r5,0x6
80008870:	c4 a1       	brne	80008904 <_vfprintf_r+0x1264>
80008872:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008876:	40 3c       	lddsp	r12,sp[0xc]
80008878:	58 0c       	cp.w	r12,0
8000887a:	c1 d0       	breq	800088b4 <_vfprintf_r+0x1214>
8000887c:	10 36       	cp.w	r6,r8
8000887e:	c0 64       	brge	8000888a <_vfprintf_r+0x11ea>
80008880:	fa cb f9 44 	sub	r11,sp,-1724
80008884:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008888:	c1 f8       	rjmp	800088c6 <_vfprintf_r+0x1226>
8000888a:	fa c8 f9 50 	sub	r8,sp,-1712
8000888e:	1a d8       	st.w	--sp,r8
80008890:	fa c8 fa b8 	sub	r8,sp,-1352
80008894:	1a d8       	st.w	--sp,r8
80008896:	fa c8 fb b4 	sub	r8,sp,-1100
8000889a:	1a d8       	st.w	--sp,r8
8000889c:	fa c8 f9 40 	sub	r8,sp,-1728
800088a0:	fa c9 ff b4 	sub	r9,sp,-76
800088a4:	04 9a       	mov	r10,r2
800088a6:	0c 9b       	mov	r11,r6
800088a8:	08 9c       	mov	r12,r4
800088aa:	fe b0 f5 63 	rcall	80007370 <get_arg>
800088ae:	2f dd       	sub	sp,-12
800088b0:	98 18       	ld.sh	r8,r12[0x2]
800088b2:	c2 68       	rjmp	800088fe <_vfprintf_r+0x125e>
800088b4:	ee ca ff ff 	sub	r10,r7,-1
800088b8:	10 37       	cp.w	r7,r8
800088ba:	c0 94       	brge	800088cc <_vfprintf_r+0x122c>
800088bc:	fa c9 f9 44 	sub	r9,sp,-1724
800088c0:	14 97       	mov	r7,r10
800088c2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800088c6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800088ca:	c1 a8       	rjmp	800088fe <_vfprintf_r+0x125e>
800088cc:	41 09       	lddsp	r9,sp[0x40]
800088ce:	59 f8       	cp.w	r8,31
800088d0:	e0 89 00 13 	brgt	800088f6 <_vfprintf_r+0x1256>
800088d4:	f2 cb ff fc 	sub	r11,r9,-4
800088d8:	51 0b       	stdsp	sp[0x40],r11
800088da:	72 09       	ld.w	r9,r9[0x0]
800088dc:	fa c6 f9 44 	sub	r6,sp,-1724
800088e0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800088e4:	2f f8       	sub	r8,-1
800088e6:	f7 49 fd 88 	st.w	r11[-632],r9
800088ea:	fb 48 06 b4 	st.w	sp[1716],r8
800088ee:	14 97       	mov	r7,r10
800088f0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800088f4:	c0 58       	rjmp	800088fe <_vfprintf_r+0x125e>
800088f6:	92 18       	ld.sh	r8,r9[0x2]
800088f8:	14 97       	mov	r7,r10
800088fa:	2f c9       	sub	r9,-4
800088fc:	51 09       	stdsp	sp[0x40],r9
800088fe:	5c 78       	castu.h	r8
80008900:	50 18       	stdsp	sp[0x4],r8
80008902:	c4 68       	rjmp	8000898e <_vfprintf_r+0x12ee>
80008904:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008908:	40 3c       	lddsp	r12,sp[0xc]
8000890a:	58 0c       	cp.w	r12,0
8000890c:	c1 d0       	breq	80008946 <_vfprintf_r+0x12a6>
8000890e:	10 36       	cp.w	r6,r8
80008910:	c0 64       	brge	8000891c <_vfprintf_r+0x127c>
80008912:	fa cb f9 44 	sub	r11,sp,-1724
80008916:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000891a:	c1 f8       	rjmp	80008958 <_vfprintf_r+0x12b8>
8000891c:	fa c8 f9 50 	sub	r8,sp,-1712
80008920:	1a d8       	st.w	--sp,r8
80008922:	fa c8 fa b8 	sub	r8,sp,-1352
80008926:	0c 9b       	mov	r11,r6
80008928:	1a d8       	st.w	--sp,r8
8000892a:	fa c8 fb b4 	sub	r8,sp,-1100
8000892e:	04 9a       	mov	r10,r2
80008930:	1a d8       	st.w	--sp,r8
80008932:	08 9c       	mov	r12,r4
80008934:	fa c8 f9 40 	sub	r8,sp,-1728
80008938:	fa c9 ff b4 	sub	r9,sp,-76
8000893c:	fe b0 f5 1a 	rcall	80007370 <get_arg>
80008940:	2f dd       	sub	sp,-12
80008942:	78 0b       	ld.w	r11,r12[0x0]
80008944:	c2 48       	rjmp	8000898c <_vfprintf_r+0x12ec>
80008946:	ee ca ff ff 	sub	r10,r7,-1
8000894a:	10 37       	cp.w	r7,r8
8000894c:	c0 94       	brge	8000895e <_vfprintf_r+0x12be>
8000894e:	fa c9 f9 44 	sub	r9,sp,-1724
80008952:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008956:	14 97       	mov	r7,r10
80008958:	ec fb fd 88 	ld.w	r11,r6[-632]
8000895c:	c1 88       	rjmp	8000898c <_vfprintf_r+0x12ec>
8000895e:	41 09       	lddsp	r9,sp[0x40]
80008960:	59 f8       	cp.w	r8,31
80008962:	e0 89 00 11 	brgt	80008984 <_vfprintf_r+0x12e4>
80008966:	f2 cb ff fc 	sub	r11,r9,-4
8000896a:	51 0b       	stdsp	sp[0x40],r11
8000896c:	fa c6 f9 44 	sub	r6,sp,-1724
80008970:	72 0b       	ld.w	r11,r9[0x0]
80008972:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008976:	f3 4b fd 88 	st.w	r9[-632],r11
8000897a:	2f f8       	sub	r8,-1
8000897c:	14 97       	mov	r7,r10
8000897e:	fb 48 06 b4 	st.w	sp[1716],r8
80008982:	c0 58       	rjmp	8000898c <_vfprintf_r+0x12ec>
80008984:	72 0b       	ld.w	r11,r9[0x0]
80008986:	14 97       	mov	r7,r10
80008988:	2f c9       	sub	r9,-4
8000898a:	51 09       	stdsp	sp[0x40],r9
8000898c:	50 1b       	stdsp	sp[0x4],r11
8000898e:	30 0e       	mov	lr,0
80008990:	30 18       	mov	r8,1
80008992:	50 0e       	stdsp	sp[0x0],lr
80008994:	c2 29       	rjmp	80008bd8 <_vfprintf_r+0x1538>
80008996:	50 a7       	stdsp	sp[0x28],r7
80008998:	50 80       	stdsp	sp[0x20],r0
8000899a:	0c 97       	mov	r7,r6
8000899c:	04 94       	mov	r4,r2
8000899e:	06 96       	mov	r6,r3
800089a0:	02 92       	mov	r2,r1
800089a2:	fe cc af 2a 	sub	r12,pc,-20694
800089a6:	40 93       	lddsp	r3,sp[0x24]
800089a8:	10 90       	mov	r0,r8
800089aa:	40 41       	lddsp	r1,sp[0x10]
800089ac:	50 dc       	stdsp	sp[0x34],r12
800089ae:	ed b5 00 05 	bld	r5,0x5
800089b2:	c5 51       	brne	80008a5c <_vfprintf_r+0x13bc>
800089b4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089b8:	40 3b       	lddsp	r11,sp[0xc]
800089ba:	58 0b       	cp.w	r11,0
800089bc:	c2 20       	breq	80008a00 <_vfprintf_r+0x1360>
800089be:	10 36       	cp.w	r6,r8
800089c0:	c0 a4       	brge	800089d4 <_vfprintf_r+0x1334>
800089c2:	fa ca f9 44 	sub	r10,sp,-1724
800089c6:	f4 06 00 36 	add	r6,r10,r6<<0x3
800089ca:	ec e8 fd 88 	ld.d	r8,r6[-632]
800089ce:	fa e9 00 00 	st.d	sp[0],r8
800089d2:	cf 28       	rjmp	80008bb6 <_vfprintf_r+0x1516>
800089d4:	fa c8 f9 50 	sub	r8,sp,-1712
800089d8:	1a d8       	st.w	--sp,r8
800089da:	fa c8 fa b8 	sub	r8,sp,-1352
800089de:	04 9a       	mov	r10,r2
800089e0:	1a d8       	st.w	--sp,r8
800089e2:	0c 9b       	mov	r11,r6
800089e4:	fa c8 fb b4 	sub	r8,sp,-1100
800089e8:	08 9c       	mov	r12,r4
800089ea:	1a d8       	st.w	--sp,r8
800089ec:	fa c8 f9 40 	sub	r8,sp,-1728
800089f0:	fa c9 ff b4 	sub	r9,sp,-76
800089f4:	fe b0 f4 be 	rcall	80007370 <get_arg>
800089f8:	2f dd       	sub	sp,-12
800089fa:	f8 ea 00 00 	ld.d	r10,r12[0]
800089fe:	c0 c8       	rjmp	80008a16 <_vfprintf_r+0x1376>
80008a00:	ee ca ff ff 	sub	r10,r7,-1
80008a04:	10 37       	cp.w	r7,r8
80008a06:	c0 b4       	brge	80008a1c <_vfprintf_r+0x137c>
80008a08:	fa c9 f9 44 	sub	r9,sp,-1724
80008a0c:	14 97       	mov	r7,r10
80008a0e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a12:	ec ea fd 88 	ld.d	r10,r6[-632]
80008a16:	fa eb 00 00 	st.d	sp[0],r10
80008a1a:	cc e8       	rjmp	80008bb6 <_vfprintf_r+0x1516>
80008a1c:	41 09       	lddsp	r9,sp[0x40]
80008a1e:	59 f8       	cp.w	r8,31
80008a20:	e0 89 00 16 	brgt	80008a4c <_vfprintf_r+0x13ac>
80008a24:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a28:	f2 cb ff f8 	sub	r11,r9,-8
80008a2c:	fa e7 00 00 	st.d	sp[0],r6
80008a30:	51 0b       	stdsp	sp[0x40],r11
80008a32:	fa c6 f9 44 	sub	r6,sp,-1724
80008a36:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008a3a:	fa e6 00 00 	ld.d	r6,sp[0]
80008a3e:	f2 e7 fd 88 	st.d	r9[-632],r6
80008a42:	2f f8       	sub	r8,-1
80008a44:	14 97       	mov	r7,r10
80008a46:	fb 48 06 b4 	st.w	sp[1716],r8
80008a4a:	cb 68       	rjmp	80008bb6 <_vfprintf_r+0x1516>
80008a4c:	f2 e6 00 00 	ld.d	r6,r9[0]
80008a50:	2f 89       	sub	r9,-8
80008a52:	fa e7 00 00 	st.d	sp[0],r6
80008a56:	51 09       	stdsp	sp[0x40],r9
80008a58:	14 97       	mov	r7,r10
80008a5a:	ca e8       	rjmp	80008bb6 <_vfprintf_r+0x1516>
80008a5c:	ed b5 00 04 	bld	r5,0x4
80008a60:	c1 71       	brne	80008a8e <_vfprintf_r+0x13ee>
80008a62:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a66:	40 3e       	lddsp	lr,sp[0xc]
80008a68:	58 0e       	cp.w	lr,0
80008a6a:	c0 80       	breq	80008a7a <_vfprintf_r+0x13da>
80008a6c:	10 36       	cp.w	r6,r8
80008a6e:	c6 94       	brge	80008b40 <_vfprintf_r+0x14a0>
80008a70:	fa cc f9 44 	sub	r12,sp,-1724
80008a74:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a78:	c8 28       	rjmp	80008b7c <_vfprintf_r+0x14dc>
80008a7a:	ee ca ff ff 	sub	r10,r7,-1
80008a7e:	10 37       	cp.w	r7,r8
80008a80:	e0 84 00 81 	brge	80008b82 <_vfprintf_r+0x14e2>
80008a84:	fa cb f9 44 	sub	r11,sp,-1724
80008a88:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a8c:	c7 78       	rjmp	80008b7a <_vfprintf_r+0x14da>
80008a8e:	ed b5 00 06 	bld	r5,0x6
80008a92:	c4 b1       	brne	80008b28 <_vfprintf_r+0x1488>
80008a94:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a98:	40 3c       	lddsp	r12,sp[0xc]
80008a9a:	58 0c       	cp.w	r12,0
80008a9c:	c1 d0       	breq	80008ad6 <_vfprintf_r+0x1436>
80008a9e:	10 36       	cp.w	r6,r8
80008aa0:	c0 64       	brge	80008aac <_vfprintf_r+0x140c>
80008aa2:	fa cb f9 44 	sub	r11,sp,-1724
80008aa6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008aaa:	c1 f8       	rjmp	80008ae8 <_vfprintf_r+0x1448>
80008aac:	fa c8 f9 50 	sub	r8,sp,-1712
80008ab0:	1a d8       	st.w	--sp,r8
80008ab2:	fa c8 fa b8 	sub	r8,sp,-1352
80008ab6:	1a d8       	st.w	--sp,r8
80008ab8:	fa c8 fb b4 	sub	r8,sp,-1100
80008abc:	1a d8       	st.w	--sp,r8
80008abe:	fa c8 f9 40 	sub	r8,sp,-1728
80008ac2:	fa c9 ff b4 	sub	r9,sp,-76
80008ac6:	04 9a       	mov	r10,r2
80008ac8:	0c 9b       	mov	r11,r6
80008aca:	08 9c       	mov	r12,r4
80008acc:	fe b0 f4 52 	rcall	80007370 <get_arg>
80008ad0:	2f dd       	sub	sp,-12
80008ad2:	98 18       	ld.sh	r8,r12[0x2]
80008ad4:	c2 78       	rjmp	80008b22 <_vfprintf_r+0x1482>
80008ad6:	ee ca ff ff 	sub	r10,r7,-1
80008ada:	10 37       	cp.w	r7,r8
80008adc:	c0 a4       	brge	80008af0 <_vfprintf_r+0x1450>
80008ade:	fa c9 f9 44 	sub	r9,sp,-1724
80008ae2:	14 97       	mov	r7,r10
80008ae4:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ae8:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008aec:	c1 b8       	rjmp	80008b22 <_vfprintf_r+0x1482>
80008aee:	d7 03       	nop
80008af0:	41 09       	lddsp	r9,sp[0x40]
80008af2:	59 f8       	cp.w	r8,31
80008af4:	e0 89 00 13 	brgt	80008b1a <_vfprintf_r+0x147a>
80008af8:	f2 cb ff fc 	sub	r11,r9,-4
80008afc:	51 0b       	stdsp	sp[0x40],r11
80008afe:	72 09       	ld.w	r9,r9[0x0]
80008b00:	fa c6 f9 44 	sub	r6,sp,-1724
80008b04:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008b08:	2f f8       	sub	r8,-1
80008b0a:	f7 49 fd 88 	st.w	r11[-632],r9
80008b0e:	fb 48 06 b4 	st.w	sp[1716],r8
80008b12:	14 97       	mov	r7,r10
80008b14:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008b18:	c0 58       	rjmp	80008b22 <_vfprintf_r+0x1482>
80008b1a:	92 18       	ld.sh	r8,r9[0x2]
80008b1c:	14 97       	mov	r7,r10
80008b1e:	2f c9       	sub	r9,-4
80008b20:	51 09       	stdsp	sp[0x40],r9
80008b22:	5c 78       	castu.h	r8
80008b24:	50 18       	stdsp	sp[0x4],r8
80008b26:	c4 68       	rjmp	80008bb2 <_vfprintf_r+0x1512>
80008b28:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b2c:	40 3c       	lddsp	r12,sp[0xc]
80008b2e:	58 0c       	cp.w	r12,0
80008b30:	c1 d0       	breq	80008b6a <_vfprintf_r+0x14ca>
80008b32:	10 36       	cp.w	r6,r8
80008b34:	c0 64       	brge	80008b40 <_vfprintf_r+0x14a0>
80008b36:	fa cb f9 44 	sub	r11,sp,-1724
80008b3a:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b3e:	c1 f8       	rjmp	80008b7c <_vfprintf_r+0x14dc>
80008b40:	fa c8 f9 50 	sub	r8,sp,-1712
80008b44:	1a d8       	st.w	--sp,r8
80008b46:	fa c8 fa b8 	sub	r8,sp,-1352
80008b4a:	0c 9b       	mov	r11,r6
80008b4c:	1a d8       	st.w	--sp,r8
80008b4e:	fa c8 fb b4 	sub	r8,sp,-1100
80008b52:	04 9a       	mov	r10,r2
80008b54:	1a d8       	st.w	--sp,r8
80008b56:	08 9c       	mov	r12,r4
80008b58:	fa c8 f9 40 	sub	r8,sp,-1728
80008b5c:	fa c9 ff b4 	sub	r9,sp,-76
80008b60:	fe b0 f4 08 	rcall	80007370 <get_arg>
80008b64:	2f dd       	sub	sp,-12
80008b66:	78 0b       	ld.w	r11,r12[0x0]
80008b68:	c2 48       	rjmp	80008bb0 <_vfprintf_r+0x1510>
80008b6a:	ee ca ff ff 	sub	r10,r7,-1
80008b6e:	10 37       	cp.w	r7,r8
80008b70:	c0 94       	brge	80008b82 <_vfprintf_r+0x14e2>
80008b72:	fa c9 f9 44 	sub	r9,sp,-1724
80008b76:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008b7a:	14 97       	mov	r7,r10
80008b7c:	ec fb fd 88 	ld.w	r11,r6[-632]
80008b80:	c1 88       	rjmp	80008bb0 <_vfprintf_r+0x1510>
80008b82:	41 09       	lddsp	r9,sp[0x40]
80008b84:	59 f8       	cp.w	r8,31
80008b86:	e0 89 00 11 	brgt	80008ba8 <_vfprintf_r+0x1508>
80008b8a:	f2 cb ff fc 	sub	r11,r9,-4
80008b8e:	51 0b       	stdsp	sp[0x40],r11
80008b90:	fa c6 f9 44 	sub	r6,sp,-1724
80008b94:	72 0b       	ld.w	r11,r9[0x0]
80008b96:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b9a:	f3 4b fd 88 	st.w	r9[-632],r11
80008b9e:	2f f8       	sub	r8,-1
80008ba0:	14 97       	mov	r7,r10
80008ba2:	fb 48 06 b4 	st.w	sp[1716],r8
80008ba6:	c0 58       	rjmp	80008bb0 <_vfprintf_r+0x1510>
80008ba8:	72 0b       	ld.w	r11,r9[0x0]
80008baa:	14 97       	mov	r7,r10
80008bac:	2f c9       	sub	r9,-4
80008bae:	51 09       	stdsp	sp[0x40],r9
80008bb0:	50 1b       	stdsp	sp[0x4],r11
80008bb2:	30 0e       	mov	lr,0
80008bb4:	50 0e       	stdsp	sp[0x0],lr
80008bb6:	40 08       	lddsp	r8,sp[0x0]
80008bb8:	40 1c       	lddsp	r12,sp[0x4]
80008bba:	18 48       	or	r8,r12
80008bbc:	5f 19       	srne	r9
80008bbe:	0a 98       	mov	r8,r5
80008bc0:	eb e9 00 09 	and	r9,r5,r9
80008bc4:	a1 b8       	sbr	r8,0x1
80008bc6:	58 09       	cp.w	r9,0
80008bc8:	c0 70       	breq	80008bd6 <_vfprintf_r+0x1536>
80008bca:	10 95       	mov	r5,r8
80008bcc:	fb 60 06 b9 	st.b	sp[1721],r0
80008bd0:	33 08       	mov	r8,48
80008bd2:	fb 68 06 b8 	st.b	sp[1720],r8
80008bd6:	30 28       	mov	r8,2
80008bd8:	30 09       	mov	r9,0
80008bda:	fb 69 06 bb 	st.b	sp[1723],r9
80008bde:	0a 99       	mov	r9,r5
80008be0:	a7 d9       	cbr	r9,0x7
80008be2:	40 2b       	lddsp	r11,sp[0x8]
80008be4:	40 16       	lddsp	r6,sp[0x4]
80008be6:	58 0b       	cp.w	r11,0
80008be8:	5f 1a       	srne	r10
80008bea:	f2 05 17 40 	movge	r5,r9
80008bee:	fa c2 f9 78 	sub	r2,sp,-1672
80008bf2:	40 09       	lddsp	r9,sp[0x0]
80008bf4:	0c 49       	or	r9,r6
80008bf6:	5f 19       	srne	r9
80008bf8:	f5 e9 10 09 	or	r9,r10,r9
80008bfc:	c5 c0       	breq	80008cb4 <_vfprintf_r+0x1614>
80008bfe:	30 19       	mov	r9,1
80008c00:	f2 08 18 00 	cp.b	r8,r9
80008c04:	c0 60       	breq	80008c10 <_vfprintf_r+0x1570>
80008c06:	30 29       	mov	r9,2
80008c08:	f2 08 18 00 	cp.b	r8,r9
80008c0c:	c0 41       	brne	80008c14 <_vfprintf_r+0x1574>
80008c0e:	c3 c8       	rjmp	80008c86 <_vfprintf_r+0x15e6>
80008c10:	04 96       	mov	r6,r2
80008c12:	c3 08       	rjmp	80008c72 <_vfprintf_r+0x15d2>
80008c14:	04 96       	mov	r6,r2
80008c16:	fa e8 00 00 	ld.d	r8,sp[0]
80008c1a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80008c1e:	2d 0a       	sub	r10,-48
80008c20:	0c fa       	st.b	--r6,r10
80008c22:	f0 0b 16 03 	lsr	r11,r8,0x3
80008c26:	f2 0c 16 03 	lsr	r12,r9,0x3
80008c2a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80008c2e:	18 99       	mov	r9,r12
80008c30:	16 98       	mov	r8,r11
80008c32:	58 08       	cp.w	r8,0
80008c34:	5c 29       	cpc	r9
80008c36:	cf 21       	brne	80008c1a <_vfprintf_r+0x157a>
80008c38:	fa e9 00 00 	st.d	sp[0],r8
80008c3c:	ed b5 00 00 	bld	r5,0x0
80008c40:	c4 51       	brne	80008cca <_vfprintf_r+0x162a>
80008c42:	33 09       	mov	r9,48
80008c44:	f2 0a 18 00 	cp.b	r10,r9
80008c48:	c4 10       	breq	80008cca <_vfprintf_r+0x162a>
80008c4a:	0c f9       	st.b	--r6,r9
80008c4c:	c3 f8       	rjmp	80008cca <_vfprintf_r+0x162a>
80008c4e:	fa ea 00 00 	ld.d	r10,sp[0]
80008c52:	30 a8       	mov	r8,10
80008c54:	30 09       	mov	r9,0
80008c56:	e0 a0 1a 0d 	rcall	8000c070 <__avr32_umod64>
80008c5a:	30 a8       	mov	r8,10
80008c5c:	2d 0a       	sub	r10,-48
80008c5e:	30 09       	mov	r9,0
80008c60:	ac 8a       	st.b	r6[0x0],r10
80008c62:	fa ea 00 00 	ld.d	r10,sp[0]
80008c66:	e0 a0 18 d3 	rcall	8000be0c <__avr32_udiv64>
80008c6a:	16 99       	mov	r9,r11
80008c6c:	14 98       	mov	r8,r10
80008c6e:	fa e9 00 00 	st.d	sp[0],r8
80008c72:	20 16       	sub	r6,1
80008c74:	fa ea 00 00 	ld.d	r10,sp[0]
80008c78:	58 9a       	cp.w	r10,9
80008c7a:	5c 2b       	cpc	r11
80008c7c:	fe 9b ff e9 	brhi	80008c4e <_vfprintf_r+0x15ae>
80008c80:	1b f8       	ld.ub	r8,sp[0x7]
80008c82:	2d 08       	sub	r8,-48
80008c84:	c2 08       	rjmp	80008cc4 <_vfprintf_r+0x1624>
80008c86:	04 96       	mov	r6,r2
80008c88:	fa e8 00 00 	ld.d	r8,sp[0]
80008c8c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008c90:	40 de       	lddsp	lr,sp[0x34]
80008c92:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008c96:	0c fa       	st.b	--r6,r10
80008c98:	f2 0b 16 04 	lsr	r11,r9,0x4
80008c9c:	f0 0a 16 04 	lsr	r10,r8,0x4
80008ca0:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008ca4:	16 99       	mov	r9,r11
80008ca6:	14 98       	mov	r8,r10
80008ca8:	58 08       	cp.w	r8,0
80008caa:	5c 29       	cpc	r9
80008cac:	cf 01       	brne	80008c8c <_vfprintf_r+0x15ec>
80008cae:	fa e9 00 00 	st.d	sp[0],r8
80008cb2:	c0 c8       	rjmp	80008cca <_vfprintf_r+0x162a>
80008cb4:	58 08       	cp.w	r8,0
80008cb6:	c0 91       	brne	80008cc8 <_vfprintf_r+0x1628>
80008cb8:	ed b5 00 00 	bld	r5,0x0
80008cbc:	c0 61       	brne	80008cc8 <_vfprintf_r+0x1628>
80008cbe:	fa c6 f9 79 	sub	r6,sp,-1671
80008cc2:	33 08       	mov	r8,48
80008cc4:	ac 88       	st.b	r6[0x0],r8
80008cc6:	c0 28       	rjmp	80008cca <_vfprintf_r+0x162a>
80008cc8:	04 96       	mov	r6,r2
80008cca:	0c 12       	sub	r2,r6
80008ccc:	c1 c8       	rjmp	80008d04 <_vfprintf_r+0x1664>
80008cce:	50 a7       	stdsp	sp[0x28],r7
80008cd0:	50 80       	stdsp	sp[0x20],r0
80008cd2:	40 93       	lddsp	r3,sp[0x24]
80008cd4:	0c 97       	mov	r7,r6
80008cd6:	10 90       	mov	r0,r8
80008cd8:	04 94       	mov	r4,r2
80008cda:	40 41       	lddsp	r1,sp[0x10]
80008cdc:	58 08       	cp.w	r8,0
80008cde:	e0 80 04 4f 	breq	8000957c <_vfprintf_r+0x1edc>
80008ce2:	fb 68 06 60 	st.b	sp[1632],r8
80008ce6:	30 0c       	mov	r12,0
80008ce8:	30 08       	mov	r8,0
80008cea:	30 12       	mov	r2,1
80008cec:	fb 68 06 bb 	st.b	sp[1723],r8
80008cf0:	50 2c       	stdsp	sp[0x8],r12
80008cf2:	fa c6 f9 a0 	sub	r6,sp,-1632
80008cf6:	c0 78       	rjmp	80008d04 <_vfprintf_r+0x1664>
80008cf8:	30 0b       	mov	r11,0
80008cfa:	50 2b       	stdsp	sp[0x8],r11
80008cfc:	c0 48       	rjmp	80008d04 <_vfprintf_r+0x1664>
80008cfe:	40 22       	lddsp	r2,sp[0x8]
80008d00:	30 0a       	mov	r10,0
80008d02:	50 2a       	stdsp	sp[0x8],r10
80008d04:	40 29       	lddsp	r9,sp[0x8]
80008d06:	e4 09 0c 49 	max	r9,r2,r9
80008d0a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008d0e:	50 39       	stdsp	sp[0xc],r9
80008d10:	0a 9e       	mov	lr,r5
80008d12:	30 09       	mov	r9,0
80008d14:	e2 1e 00 02 	andl	lr,0x2,COH
80008d18:	f2 08 18 00 	cp.b	r8,r9
80008d1c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80008d20:	f7 b8 01 ff 	subne	r8,-1
80008d24:	fb f8 1a 03 	st.wne	sp[0xc],r8
80008d28:	0a 9b       	mov	r11,r5
80008d2a:	58 0e       	cp.w	lr,0
80008d2c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80008d30:	f7 bc 01 fe 	subne	r12,-2
80008d34:	fb fc 1a 03 	st.wne	sp[0xc],r12
80008d38:	e2 1b 00 84 	andl	r11,0x84,COH
80008d3c:	50 fe       	stdsp	sp[0x3c],lr
80008d3e:	50 9b       	stdsp	sp[0x24],r11
80008d40:	c4 71       	brne	80008dce <_vfprintf_r+0x172e>
80008d42:	40 8a       	lddsp	r10,sp[0x20]
80008d44:	40 39       	lddsp	r9,sp[0xc]
80008d46:	12 1a       	sub	r10,r9
80008d48:	50 4a       	stdsp	sp[0x10],r10
80008d4a:	58 0a       	cp.w	r10,0
80008d4c:	e0 89 00 20 	brgt	80008d8c <_vfprintf_r+0x16ec>
80008d50:	c3 f8       	rjmp	80008dce <_vfprintf_r+0x172e>
80008d52:	2f 09       	sub	r9,-16
80008d54:	2f f8       	sub	r8,-1
80008d56:	fe ce b2 c6 	sub	lr,pc,-19770
80008d5a:	31 0c       	mov	r12,16
80008d5c:	fb 49 06 90 	st.w	sp[1680],r9
80008d60:	87 0e       	st.w	r3[0x0],lr
80008d62:	87 1c       	st.w	r3[0x4],r12
80008d64:	fb 48 06 8c 	st.w	sp[1676],r8
80008d68:	58 78       	cp.w	r8,7
80008d6a:	e0 89 00 04 	brgt	80008d72 <_vfprintf_r+0x16d2>
80008d6e:	2f 83       	sub	r3,-8
80008d70:	c0 b8       	rjmp	80008d86 <_vfprintf_r+0x16e6>
80008d72:	fa ca f9 78 	sub	r10,sp,-1672
80008d76:	02 9b       	mov	r11,r1
80008d78:	08 9c       	mov	r12,r4
80008d7a:	fe b0 f4 85 	rcall	80007684 <__sprint_r>
80008d7e:	e0 81 04 10 	brne	8000959e <_vfprintf_r+0x1efe>
80008d82:	fa c3 f9 e0 	sub	r3,sp,-1568
80008d86:	40 4b       	lddsp	r11,sp[0x10]
80008d88:	21 0b       	sub	r11,16
80008d8a:	50 4b       	stdsp	sp[0x10],r11
80008d8c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008d90:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008d94:	fe ca b3 04 	sub	r10,pc,-19708
80008d98:	40 4e       	lddsp	lr,sp[0x10]
80008d9a:	59 0e       	cp.w	lr,16
80008d9c:	fe 99 ff db 	brgt	80008d52 <_vfprintf_r+0x16b2>
80008da0:	1c 09       	add	r9,lr
80008da2:	2f f8       	sub	r8,-1
80008da4:	87 0a       	st.w	r3[0x0],r10
80008da6:	fb 49 06 90 	st.w	sp[1680],r9
80008daa:	87 1e       	st.w	r3[0x4],lr
80008dac:	fb 48 06 8c 	st.w	sp[1676],r8
80008db0:	58 78       	cp.w	r8,7
80008db2:	e0 89 00 04 	brgt	80008dba <_vfprintf_r+0x171a>
80008db6:	2f 83       	sub	r3,-8
80008db8:	c0 b8       	rjmp	80008dce <_vfprintf_r+0x172e>
80008dba:	fa ca f9 78 	sub	r10,sp,-1672
80008dbe:	02 9b       	mov	r11,r1
80008dc0:	08 9c       	mov	r12,r4
80008dc2:	fe b0 f4 61 	rcall	80007684 <__sprint_r>
80008dc6:	e0 81 03 ec 	brne	8000959e <_vfprintf_r+0x1efe>
80008dca:	fa c3 f9 e0 	sub	r3,sp,-1568
80008dce:	30 09       	mov	r9,0
80008dd0:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008dd4:	f2 08 18 00 	cp.b	r8,r9
80008dd8:	c1 f0       	breq	80008e16 <_vfprintf_r+0x1776>
80008dda:	fa f8 06 90 	ld.w	r8,sp[1680]
80008dde:	fa c9 f9 45 	sub	r9,sp,-1723
80008de2:	2f f8       	sub	r8,-1
80008de4:	87 09       	st.w	r3[0x0],r9
80008de6:	fb 48 06 90 	st.w	sp[1680],r8
80008dea:	30 19       	mov	r9,1
80008dec:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008df0:	87 19       	st.w	r3[0x4],r9
80008df2:	2f f8       	sub	r8,-1
80008df4:	fb 48 06 8c 	st.w	sp[1676],r8
80008df8:	58 78       	cp.w	r8,7
80008dfa:	e0 89 00 04 	brgt	80008e02 <_vfprintf_r+0x1762>
80008dfe:	2f 83       	sub	r3,-8
80008e00:	c0 b8       	rjmp	80008e16 <_vfprintf_r+0x1776>
80008e02:	fa ca f9 78 	sub	r10,sp,-1672
80008e06:	02 9b       	mov	r11,r1
80008e08:	08 9c       	mov	r12,r4
80008e0a:	fe b0 f4 3d 	rcall	80007684 <__sprint_r>
80008e0e:	e0 81 03 c8 	brne	8000959e <_vfprintf_r+0x1efe>
80008e12:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e16:	40 fc       	lddsp	r12,sp[0x3c]
80008e18:	58 0c       	cp.w	r12,0
80008e1a:	c1 f0       	breq	80008e58 <_vfprintf_r+0x17b8>
80008e1c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008e20:	fa c9 f9 48 	sub	r9,sp,-1720
80008e24:	2f e8       	sub	r8,-2
80008e26:	87 09       	st.w	r3[0x0],r9
80008e28:	fb 48 06 90 	st.w	sp[1680],r8
80008e2c:	30 29       	mov	r9,2
80008e2e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008e32:	87 19       	st.w	r3[0x4],r9
80008e34:	2f f8       	sub	r8,-1
80008e36:	fb 48 06 8c 	st.w	sp[1676],r8
80008e3a:	58 78       	cp.w	r8,7
80008e3c:	e0 89 00 04 	brgt	80008e44 <_vfprintf_r+0x17a4>
80008e40:	2f 83       	sub	r3,-8
80008e42:	c0 b8       	rjmp	80008e58 <_vfprintf_r+0x17b8>
80008e44:	fa ca f9 78 	sub	r10,sp,-1672
80008e48:	02 9b       	mov	r11,r1
80008e4a:	08 9c       	mov	r12,r4
80008e4c:	fe b0 f4 1c 	rcall	80007684 <__sprint_r>
80008e50:	e0 81 03 a7 	brne	8000959e <_vfprintf_r+0x1efe>
80008e54:	fa c3 f9 e0 	sub	r3,sp,-1568
80008e58:	40 9b       	lddsp	r11,sp[0x24]
80008e5a:	e0 4b 00 80 	cp.w	r11,128
80008e5e:	c4 71       	brne	80008eec <_vfprintf_r+0x184c>
80008e60:	40 8a       	lddsp	r10,sp[0x20]
80008e62:	40 39       	lddsp	r9,sp[0xc]
80008e64:	12 1a       	sub	r10,r9
80008e66:	50 4a       	stdsp	sp[0x10],r10
80008e68:	58 0a       	cp.w	r10,0
80008e6a:	e0 89 00 20 	brgt	80008eaa <_vfprintf_r+0x180a>
80008e6e:	c3 f8       	rjmp	80008eec <_vfprintf_r+0x184c>
80008e70:	2f 09       	sub	r9,-16
80008e72:	2f f8       	sub	r8,-1
80008e74:	fe ce b3 d4 	sub	lr,pc,-19500
80008e78:	31 0c       	mov	r12,16
80008e7a:	fb 49 06 90 	st.w	sp[1680],r9
80008e7e:	87 0e       	st.w	r3[0x0],lr
80008e80:	87 1c       	st.w	r3[0x4],r12
80008e82:	fb 48 06 8c 	st.w	sp[1676],r8
80008e86:	58 78       	cp.w	r8,7
80008e88:	e0 89 00 04 	brgt	80008e90 <_vfprintf_r+0x17f0>
80008e8c:	2f 83       	sub	r3,-8
80008e8e:	c0 b8       	rjmp	80008ea4 <_vfprintf_r+0x1804>
80008e90:	fa ca f9 78 	sub	r10,sp,-1672
80008e94:	02 9b       	mov	r11,r1
80008e96:	08 9c       	mov	r12,r4
80008e98:	fe b0 f3 f6 	rcall	80007684 <__sprint_r>
80008e9c:	e0 81 03 81 	brne	8000959e <_vfprintf_r+0x1efe>
80008ea0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ea4:	40 4b       	lddsp	r11,sp[0x10]
80008ea6:	21 0b       	sub	r11,16
80008ea8:	50 4b       	stdsp	sp[0x10],r11
80008eaa:	fa f9 06 90 	ld.w	r9,sp[1680]
80008eae:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008eb2:	fe ca b4 12 	sub	r10,pc,-19438
80008eb6:	40 4e       	lddsp	lr,sp[0x10]
80008eb8:	59 0e       	cp.w	lr,16
80008eba:	fe 99 ff db 	brgt	80008e70 <_vfprintf_r+0x17d0>
80008ebe:	1c 09       	add	r9,lr
80008ec0:	2f f8       	sub	r8,-1
80008ec2:	87 0a       	st.w	r3[0x0],r10
80008ec4:	fb 49 06 90 	st.w	sp[1680],r9
80008ec8:	87 1e       	st.w	r3[0x4],lr
80008eca:	fb 48 06 8c 	st.w	sp[1676],r8
80008ece:	58 78       	cp.w	r8,7
80008ed0:	e0 89 00 04 	brgt	80008ed8 <_vfprintf_r+0x1838>
80008ed4:	2f 83       	sub	r3,-8
80008ed6:	c0 b8       	rjmp	80008eec <_vfprintf_r+0x184c>
80008ed8:	fa ca f9 78 	sub	r10,sp,-1672
80008edc:	02 9b       	mov	r11,r1
80008ede:	08 9c       	mov	r12,r4
80008ee0:	fe b0 f3 d2 	rcall	80007684 <__sprint_r>
80008ee4:	e0 81 03 5d 	brne	8000959e <_vfprintf_r+0x1efe>
80008ee8:	fa c3 f9 e0 	sub	r3,sp,-1568
80008eec:	40 2c       	lddsp	r12,sp[0x8]
80008eee:	04 1c       	sub	r12,r2
80008ef0:	50 2c       	stdsp	sp[0x8],r12
80008ef2:	58 0c       	cp.w	r12,0
80008ef4:	e0 89 00 20 	brgt	80008f34 <_vfprintf_r+0x1894>
80008ef8:	c3 f8       	rjmp	80008f76 <_vfprintf_r+0x18d6>
80008efa:	2f 09       	sub	r9,-16
80008efc:	2f f8       	sub	r8,-1
80008efe:	fe cb b4 5e 	sub	r11,pc,-19362
80008f02:	31 0a       	mov	r10,16
80008f04:	fb 49 06 90 	st.w	sp[1680],r9
80008f08:	87 0b       	st.w	r3[0x0],r11
80008f0a:	87 1a       	st.w	r3[0x4],r10
80008f0c:	fb 48 06 8c 	st.w	sp[1676],r8
80008f10:	58 78       	cp.w	r8,7
80008f12:	e0 89 00 04 	brgt	80008f1a <_vfprintf_r+0x187a>
80008f16:	2f 83       	sub	r3,-8
80008f18:	c0 b8       	rjmp	80008f2e <_vfprintf_r+0x188e>
80008f1a:	fa ca f9 78 	sub	r10,sp,-1672
80008f1e:	02 9b       	mov	r11,r1
80008f20:	08 9c       	mov	r12,r4
80008f22:	fe b0 f3 b1 	rcall	80007684 <__sprint_r>
80008f26:	e0 81 03 3c 	brne	8000959e <_vfprintf_r+0x1efe>
80008f2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f2e:	40 29       	lddsp	r9,sp[0x8]
80008f30:	21 09       	sub	r9,16
80008f32:	50 29       	stdsp	sp[0x8],r9
80008f34:	fa f9 06 90 	ld.w	r9,sp[1680]
80008f38:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008f3c:	fe ca b4 9c 	sub	r10,pc,-19300
80008f40:	40 2e       	lddsp	lr,sp[0x8]
80008f42:	59 0e       	cp.w	lr,16
80008f44:	fe 99 ff db 	brgt	80008efa <_vfprintf_r+0x185a>
80008f48:	1c 09       	add	r9,lr
80008f4a:	2f f8       	sub	r8,-1
80008f4c:	87 0a       	st.w	r3[0x0],r10
80008f4e:	fb 49 06 90 	st.w	sp[1680],r9
80008f52:	87 1e       	st.w	r3[0x4],lr
80008f54:	fb 48 06 8c 	st.w	sp[1676],r8
80008f58:	58 78       	cp.w	r8,7
80008f5a:	e0 89 00 04 	brgt	80008f62 <_vfprintf_r+0x18c2>
80008f5e:	2f 83       	sub	r3,-8
80008f60:	c0 b8       	rjmp	80008f76 <_vfprintf_r+0x18d6>
80008f62:	fa ca f9 78 	sub	r10,sp,-1672
80008f66:	02 9b       	mov	r11,r1
80008f68:	08 9c       	mov	r12,r4
80008f6a:	fe b0 f3 8d 	rcall	80007684 <__sprint_r>
80008f6e:	e0 81 03 18 	brne	8000959e <_vfprintf_r+0x1efe>
80008f72:	fa c3 f9 e0 	sub	r3,sp,-1568
80008f76:	ed b5 00 08 	bld	r5,0x8
80008f7a:	c0 b0       	breq	80008f90 <_vfprintf_r+0x18f0>
80008f7c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008f80:	87 12       	st.w	r3[0x4],r2
80008f82:	87 06       	st.w	r3[0x0],r6
80008f84:	f0 02 00 02 	add	r2,r8,r2
80008f88:	fb 42 06 90 	st.w	sp[1680],r2
80008f8c:	e0 8f 01 d4 	bral	80009334 <_vfprintf_r+0x1c94>
80008f90:	e0 40 00 65 	cp.w	r0,101
80008f94:	e0 8a 01 d6 	brle	80009340 <_vfprintf_r+0x1ca0>
80008f98:	30 08       	mov	r8,0
80008f9a:	30 09       	mov	r9,0
80008f9c:	40 5b       	lddsp	r11,sp[0x14]
80008f9e:	40 7a       	lddsp	r10,sp[0x1c]
80008fa0:	e0 a0 15 2f 	rcall	8000b9fe <__avr32_f64_cmp_eq>
80008fa4:	c7 90       	breq	80009096 <_vfprintf_r+0x19f6>
80008fa6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008faa:	fe c9 b5 1e 	sub	r9,pc,-19170
80008fae:	2f f8       	sub	r8,-1
80008fb0:	87 09       	st.w	r3[0x0],r9
80008fb2:	fb 48 06 90 	st.w	sp[1680],r8
80008fb6:	30 19       	mov	r9,1
80008fb8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008fbc:	87 19       	st.w	r3[0x4],r9
80008fbe:	2f f8       	sub	r8,-1
80008fc0:	fb 48 06 8c 	st.w	sp[1676],r8
80008fc4:	58 78       	cp.w	r8,7
80008fc6:	e0 89 00 05 	brgt	80008fd0 <_vfprintf_r+0x1930>
80008fca:	2f 83       	sub	r3,-8
80008fcc:	c0 c8       	rjmp	80008fe4 <_vfprintf_r+0x1944>
80008fce:	d7 03       	nop
80008fd0:	fa ca f9 78 	sub	r10,sp,-1672
80008fd4:	02 9b       	mov	r11,r1
80008fd6:	08 9c       	mov	r12,r4
80008fd8:	fe b0 f3 56 	rcall	80007684 <__sprint_r>
80008fdc:	e0 81 02 e1 	brne	8000959e <_vfprintf_r+0x1efe>
80008fe0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008fe4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008fe8:	40 6c       	lddsp	r12,sp[0x18]
80008fea:	18 38       	cp.w	r8,r12
80008fec:	c0 55       	brlt	80008ff6 <_vfprintf_r+0x1956>
80008fee:	ed b5 00 00 	bld	r5,0x0
80008ff2:	e0 81 02 6b 	brne	800094c8 <_vfprintf_r+0x1e28>
80008ff6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ffa:	2f f8       	sub	r8,-1
80008ffc:	40 cb       	lddsp	r11,sp[0x30]
80008ffe:	fb 48 06 90 	st.w	sp[1680],r8
80009002:	30 19       	mov	r9,1
80009004:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009008:	87 0b       	st.w	r3[0x0],r11
8000900a:	2f f8       	sub	r8,-1
8000900c:	87 19       	st.w	r3[0x4],r9
8000900e:	fb 48 06 8c 	st.w	sp[1676],r8
80009012:	58 78       	cp.w	r8,7
80009014:	e0 89 00 04 	brgt	8000901c <_vfprintf_r+0x197c>
80009018:	2f 83       	sub	r3,-8
8000901a:	c0 b8       	rjmp	80009030 <_vfprintf_r+0x1990>
8000901c:	fa ca f9 78 	sub	r10,sp,-1672
80009020:	02 9b       	mov	r11,r1
80009022:	08 9c       	mov	r12,r4
80009024:	fe b0 f3 30 	rcall	80007684 <__sprint_r>
80009028:	e0 81 02 bb 	brne	8000959e <_vfprintf_r+0x1efe>
8000902c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009030:	40 66       	lddsp	r6,sp[0x18]
80009032:	20 16       	sub	r6,1
80009034:	58 06       	cp.w	r6,0
80009036:	e0 89 00 1d 	brgt	80009070 <_vfprintf_r+0x19d0>
8000903a:	e0 8f 02 47 	bral	800094c8 <_vfprintf_r+0x1e28>
8000903e:	2f 09       	sub	r9,-16
80009040:	2f f8       	sub	r8,-1
80009042:	fb 49 06 90 	st.w	sp[1680],r9
80009046:	87 02       	st.w	r3[0x0],r2
80009048:	87 10       	st.w	r3[0x4],r0
8000904a:	fb 48 06 8c 	st.w	sp[1676],r8
8000904e:	58 78       	cp.w	r8,7
80009050:	e0 89 00 04 	brgt	80009058 <_vfprintf_r+0x19b8>
80009054:	2f 83       	sub	r3,-8
80009056:	c0 b8       	rjmp	8000906c <_vfprintf_r+0x19cc>
80009058:	fa ca f9 78 	sub	r10,sp,-1672
8000905c:	02 9b       	mov	r11,r1
8000905e:	08 9c       	mov	r12,r4
80009060:	fe b0 f3 12 	rcall	80007684 <__sprint_r>
80009064:	e0 81 02 9d 	brne	8000959e <_vfprintf_r+0x1efe>
80009068:	fa c3 f9 e0 	sub	r3,sp,-1568
8000906c:	21 06       	sub	r6,16
8000906e:	c0 48       	rjmp	80009076 <_vfprintf_r+0x19d6>
80009070:	fe c2 b5 d0 	sub	r2,pc,-18992
80009074:	31 00       	mov	r0,16
80009076:	fa f9 06 90 	ld.w	r9,sp[1680]
8000907a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000907e:	fe ca b5 de 	sub	r10,pc,-18978
80009082:	59 06       	cp.w	r6,16
80009084:	fe 99 ff dd 	brgt	8000903e <_vfprintf_r+0x199e>
80009088:	0c 09       	add	r9,r6
8000908a:	87 0a       	st.w	r3[0x0],r10
8000908c:	fb 49 06 90 	st.w	sp[1680],r9
80009090:	2f f8       	sub	r8,-1
80009092:	87 16       	st.w	r3[0x4],r6
80009094:	c5 39       	rjmp	8000933a <_vfprintf_r+0x1c9a>
80009096:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000909a:	58 0a       	cp.w	r10,0
8000909c:	e0 89 00 92 	brgt	800091c0 <_vfprintf_r+0x1b20>
800090a0:	fa f8 06 90 	ld.w	r8,sp[1680]
800090a4:	fe c9 b6 18 	sub	r9,pc,-18920
800090a8:	2f f8       	sub	r8,-1
800090aa:	87 09       	st.w	r3[0x0],r9
800090ac:	fb 48 06 90 	st.w	sp[1680],r8
800090b0:	30 19       	mov	r9,1
800090b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800090b6:	87 19       	st.w	r3[0x4],r9
800090b8:	2f f8       	sub	r8,-1
800090ba:	fb 48 06 8c 	st.w	sp[1676],r8
800090be:	58 78       	cp.w	r8,7
800090c0:	e0 89 00 04 	brgt	800090c8 <_vfprintf_r+0x1a28>
800090c4:	2f 83       	sub	r3,-8
800090c6:	c0 b8       	rjmp	800090dc <_vfprintf_r+0x1a3c>
800090c8:	fa ca f9 78 	sub	r10,sp,-1672
800090cc:	02 9b       	mov	r11,r1
800090ce:	08 9c       	mov	r12,r4
800090d0:	fe b0 f2 da 	rcall	80007684 <__sprint_r>
800090d4:	e0 81 02 65 	brne	8000959e <_vfprintf_r+0x1efe>
800090d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800090dc:	fa f8 06 ac 	ld.w	r8,sp[1708]
800090e0:	58 08       	cp.w	r8,0
800090e2:	c0 81       	brne	800090f2 <_vfprintf_r+0x1a52>
800090e4:	40 6a       	lddsp	r10,sp[0x18]
800090e6:	58 0a       	cp.w	r10,0
800090e8:	c0 51       	brne	800090f2 <_vfprintf_r+0x1a52>
800090ea:	ed b5 00 00 	bld	r5,0x0
800090ee:	e0 81 01 ed 	brne	800094c8 <_vfprintf_r+0x1e28>
800090f2:	40 c9       	lddsp	r9,sp[0x30]
800090f4:	fa f8 06 90 	ld.w	r8,sp[1680]
800090f8:	2f f8       	sub	r8,-1
800090fa:	87 09       	st.w	r3[0x0],r9
800090fc:	fb 48 06 90 	st.w	sp[1680],r8
80009100:	30 19       	mov	r9,1
80009102:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009106:	87 19       	st.w	r3[0x4],r9
80009108:	2f f8       	sub	r8,-1
8000910a:	fb 48 06 8c 	st.w	sp[1676],r8
8000910e:	58 78       	cp.w	r8,7
80009110:	e0 89 00 04 	brgt	80009118 <_vfprintf_r+0x1a78>
80009114:	2f 83       	sub	r3,-8
80009116:	c0 b8       	rjmp	8000912c <_vfprintf_r+0x1a8c>
80009118:	fa ca f9 78 	sub	r10,sp,-1672
8000911c:	02 9b       	mov	r11,r1
8000911e:	08 9c       	mov	r12,r4
80009120:	fe b0 f2 b2 	rcall	80007684 <__sprint_r>
80009124:	e0 81 02 3d 	brne	8000959e <_vfprintf_r+0x1efe>
80009128:	fa c3 f9 e0 	sub	r3,sp,-1568
8000912c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009130:	5c 32       	neg	r2
80009132:	58 02       	cp.w	r2,0
80009134:	e0 89 00 1d 	brgt	8000916e <_vfprintf_r+0x1ace>
80009138:	c3 d8       	rjmp	800091b2 <_vfprintf_r+0x1b12>
8000913a:	2f 09       	sub	r9,-16
8000913c:	2f f8       	sub	r8,-1
8000913e:	31 0e       	mov	lr,16
80009140:	fb 49 06 90 	st.w	sp[1680],r9
80009144:	87 00       	st.w	r3[0x0],r0
80009146:	87 1e       	st.w	r3[0x4],lr
80009148:	fb 48 06 8c 	st.w	sp[1676],r8
8000914c:	58 78       	cp.w	r8,7
8000914e:	e0 89 00 04 	brgt	80009156 <_vfprintf_r+0x1ab6>
80009152:	2f 83       	sub	r3,-8
80009154:	c0 b8       	rjmp	8000916a <_vfprintf_r+0x1aca>
80009156:	fa ca f9 78 	sub	r10,sp,-1672
8000915a:	02 9b       	mov	r11,r1
8000915c:	08 9c       	mov	r12,r4
8000915e:	fe b0 f2 93 	rcall	80007684 <__sprint_r>
80009162:	e0 81 02 1e 	brne	8000959e <_vfprintf_r+0x1efe>
80009166:	fa c3 f9 e0 	sub	r3,sp,-1568
8000916a:	21 02       	sub	r2,16
8000916c:	c0 38       	rjmp	80009172 <_vfprintf_r+0x1ad2>
8000916e:	fe c0 b6 ce 	sub	r0,pc,-18738
80009172:	fa f9 06 90 	ld.w	r9,sp[1680]
80009176:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000917a:	fe ca b6 da 	sub	r10,pc,-18726
8000917e:	59 02       	cp.w	r2,16
80009180:	fe 99 ff dd 	brgt	8000913a <_vfprintf_r+0x1a9a>
80009184:	04 09       	add	r9,r2
80009186:	2f f8       	sub	r8,-1
80009188:	87 0a       	st.w	r3[0x0],r10
8000918a:	fb 49 06 90 	st.w	sp[1680],r9
8000918e:	87 12       	st.w	r3[0x4],r2
80009190:	fb 48 06 8c 	st.w	sp[1676],r8
80009194:	58 78       	cp.w	r8,7
80009196:	e0 89 00 04 	brgt	8000919e <_vfprintf_r+0x1afe>
8000919a:	2f 83       	sub	r3,-8
8000919c:	c0 b8       	rjmp	800091b2 <_vfprintf_r+0x1b12>
8000919e:	fa ca f9 78 	sub	r10,sp,-1672
800091a2:	02 9b       	mov	r11,r1
800091a4:	08 9c       	mov	r12,r4
800091a6:	fe b0 f2 6f 	rcall	80007684 <__sprint_r>
800091aa:	e0 81 01 fa 	brne	8000959e <_vfprintf_r+0x1efe>
800091ae:	fa c3 f9 e0 	sub	r3,sp,-1568
800091b2:	40 6c       	lddsp	r12,sp[0x18]
800091b4:	fa f8 06 90 	ld.w	r8,sp[1680]
800091b8:	87 06       	st.w	r3[0x0],r6
800091ba:	87 1c       	st.w	r3[0x4],r12
800091bc:	18 08       	add	r8,r12
800091be:	cb 98       	rjmp	80009330 <_vfprintf_r+0x1c90>
800091c0:	fa f9 06 90 	ld.w	r9,sp[1680]
800091c4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800091c8:	40 6b       	lddsp	r11,sp[0x18]
800091ca:	16 3a       	cp.w	r10,r11
800091cc:	c6 f5       	brlt	800092aa <_vfprintf_r+0x1c0a>
800091ce:	16 09       	add	r9,r11
800091d0:	2f f8       	sub	r8,-1
800091d2:	87 06       	st.w	r3[0x0],r6
800091d4:	fb 49 06 90 	st.w	sp[1680],r9
800091d8:	87 1b       	st.w	r3[0x4],r11
800091da:	fb 48 06 8c 	st.w	sp[1676],r8
800091de:	58 78       	cp.w	r8,7
800091e0:	e0 89 00 04 	brgt	800091e8 <_vfprintf_r+0x1b48>
800091e4:	2f 83       	sub	r3,-8
800091e6:	c0 b8       	rjmp	800091fc <_vfprintf_r+0x1b5c>
800091e8:	fa ca f9 78 	sub	r10,sp,-1672
800091ec:	02 9b       	mov	r11,r1
800091ee:	08 9c       	mov	r12,r4
800091f0:	fe b0 f2 4a 	rcall	80007684 <__sprint_r>
800091f4:	e0 81 01 d5 	brne	8000959e <_vfprintf_r+0x1efe>
800091f8:	fa c3 f9 e0 	sub	r3,sp,-1568
800091fc:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009200:	40 6a       	lddsp	r10,sp[0x18]
80009202:	14 16       	sub	r6,r10
80009204:	58 06       	cp.w	r6,0
80009206:	e0 89 00 1c 	brgt	8000923e <_vfprintf_r+0x1b9e>
8000920a:	c3 d8       	rjmp	80009284 <_vfprintf_r+0x1be4>
8000920c:	2f 09       	sub	r9,-16
8000920e:	2f f8       	sub	r8,-1
80009210:	fb 49 06 90 	st.w	sp[1680],r9
80009214:	87 02       	st.w	r3[0x0],r2
80009216:	87 10       	st.w	r3[0x4],r0
80009218:	fb 48 06 8c 	st.w	sp[1676],r8
8000921c:	58 78       	cp.w	r8,7
8000921e:	e0 89 00 04 	brgt	80009226 <_vfprintf_r+0x1b86>
80009222:	2f 83       	sub	r3,-8
80009224:	c0 b8       	rjmp	8000923a <_vfprintf_r+0x1b9a>
80009226:	fa ca f9 78 	sub	r10,sp,-1672
8000922a:	02 9b       	mov	r11,r1
8000922c:	08 9c       	mov	r12,r4
8000922e:	fe b0 f2 2b 	rcall	80007684 <__sprint_r>
80009232:	e0 81 01 b6 	brne	8000959e <_vfprintf_r+0x1efe>
80009236:	fa c3 f9 e0 	sub	r3,sp,-1568
8000923a:	21 06       	sub	r6,16
8000923c:	c0 48       	rjmp	80009244 <_vfprintf_r+0x1ba4>
8000923e:	fe c2 b7 9e 	sub	r2,pc,-18530
80009242:	31 00       	mov	r0,16
80009244:	fa f9 06 90 	ld.w	r9,sp[1680]
80009248:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000924c:	fe ca b7 ac 	sub	r10,pc,-18516
80009250:	59 06       	cp.w	r6,16
80009252:	fe 99 ff dd 	brgt	8000920c <_vfprintf_r+0x1b6c>
80009256:	0c 09       	add	r9,r6
80009258:	2f f8       	sub	r8,-1
8000925a:	87 0a       	st.w	r3[0x0],r10
8000925c:	fb 49 06 90 	st.w	sp[1680],r9
80009260:	87 16       	st.w	r3[0x4],r6
80009262:	fb 48 06 8c 	st.w	sp[1676],r8
80009266:	58 78       	cp.w	r8,7
80009268:	e0 89 00 04 	brgt	80009270 <_vfprintf_r+0x1bd0>
8000926c:	2f 83       	sub	r3,-8
8000926e:	c0 b8       	rjmp	80009284 <_vfprintf_r+0x1be4>
80009270:	fa ca f9 78 	sub	r10,sp,-1672
80009274:	02 9b       	mov	r11,r1
80009276:	08 9c       	mov	r12,r4
80009278:	fe b0 f2 06 	rcall	80007684 <__sprint_r>
8000927c:	e0 81 01 91 	brne	8000959e <_vfprintf_r+0x1efe>
80009280:	fa c3 f9 e0 	sub	r3,sp,-1568
80009284:	ed b5 00 00 	bld	r5,0x0
80009288:	e0 81 01 20 	brne	800094c8 <_vfprintf_r+0x1e28>
8000928c:	40 c9       	lddsp	r9,sp[0x30]
8000928e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009292:	2f f8       	sub	r8,-1
80009294:	87 09       	st.w	r3[0x0],r9
80009296:	fb 48 06 90 	st.w	sp[1680],r8
8000929a:	30 19       	mov	r9,1
8000929c:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092a0:	87 19       	st.w	r3[0x4],r9
800092a2:	2f f8       	sub	r8,-1
800092a4:	fb 48 06 8c 	st.w	sp[1676],r8
800092a8:	c0 29       	rjmp	800094ac <_vfprintf_r+0x1e0c>
800092aa:	14 09       	add	r9,r10
800092ac:	2f f8       	sub	r8,-1
800092ae:	fb 49 06 90 	st.w	sp[1680],r9
800092b2:	87 06       	st.w	r3[0x0],r6
800092b4:	87 1a       	st.w	r3[0x4],r10
800092b6:	fb 48 06 8c 	st.w	sp[1676],r8
800092ba:	58 78       	cp.w	r8,7
800092bc:	e0 89 00 04 	brgt	800092c4 <_vfprintf_r+0x1c24>
800092c0:	2f 83       	sub	r3,-8
800092c2:	c0 b8       	rjmp	800092d8 <_vfprintf_r+0x1c38>
800092c4:	fa ca f9 78 	sub	r10,sp,-1672
800092c8:	02 9b       	mov	r11,r1
800092ca:	08 9c       	mov	r12,r4
800092cc:	fe b0 f1 dc 	rcall	80007684 <__sprint_r>
800092d0:	e0 81 01 67 	brne	8000959e <_vfprintf_r+0x1efe>
800092d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800092d8:	40 c8       	lddsp	r8,sp[0x30]
800092da:	87 08       	st.w	r3[0x0],r8
800092dc:	fa f8 06 90 	ld.w	r8,sp[1680]
800092e0:	2f f8       	sub	r8,-1
800092e2:	30 19       	mov	r9,1
800092e4:	fb 48 06 90 	st.w	sp[1680],r8
800092e8:	87 19       	st.w	r3[0x4],r9
800092ea:	fa f8 06 8c 	ld.w	r8,sp[1676]
800092ee:	2f f8       	sub	r8,-1
800092f0:	fb 48 06 8c 	st.w	sp[1676],r8
800092f4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800092f8:	58 78       	cp.w	r8,7
800092fa:	e0 89 00 04 	brgt	80009302 <_vfprintf_r+0x1c62>
800092fe:	2f 83       	sub	r3,-8
80009300:	c0 b8       	rjmp	80009316 <_vfprintf_r+0x1c76>
80009302:	fa ca f9 78 	sub	r10,sp,-1672
80009306:	02 9b       	mov	r11,r1
80009308:	08 9c       	mov	r12,r4
8000930a:	fe b0 f1 bd 	rcall	80007684 <__sprint_r>
8000930e:	e0 81 01 48 	brne	8000959e <_vfprintf_r+0x1efe>
80009312:	fa c3 f9 e0 	sub	r3,sp,-1568
80009316:	04 06       	add	r6,r2
80009318:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000931c:	87 06       	st.w	r3[0x0],r6
8000931e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009322:	40 66       	lddsp	r6,sp[0x18]
80009324:	40 6e       	lddsp	lr,sp[0x18]
80009326:	10 16       	sub	r6,r8
80009328:	f2 08 01 08 	sub	r8,r9,r8
8000932c:	87 16       	st.w	r3[0x4],r6
8000932e:	1c 08       	add	r8,lr
80009330:	fb 48 06 90 	st.w	sp[1680],r8
80009334:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009338:	2f f8       	sub	r8,-1
8000933a:	fb 48 06 8c 	st.w	sp[1676],r8
8000933e:	cb 78       	rjmp	800094ac <_vfprintf_r+0x1e0c>
80009340:	40 6c       	lddsp	r12,sp[0x18]
80009342:	58 1c       	cp.w	r12,1
80009344:	e0 89 00 06 	brgt	80009350 <_vfprintf_r+0x1cb0>
80009348:	ed b5 00 00 	bld	r5,0x0
8000934c:	e0 81 00 85 	brne	80009456 <_vfprintf_r+0x1db6>
80009350:	fa f8 06 90 	ld.w	r8,sp[1680]
80009354:	2f f8       	sub	r8,-1
80009356:	30 19       	mov	r9,1
80009358:	fb 48 06 90 	st.w	sp[1680],r8
8000935c:	87 06       	st.w	r3[0x0],r6
8000935e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009362:	87 19       	st.w	r3[0x4],r9
80009364:	2f f8       	sub	r8,-1
80009366:	fb 48 06 8c 	st.w	sp[1676],r8
8000936a:	58 78       	cp.w	r8,7
8000936c:	e0 89 00 04 	brgt	80009374 <_vfprintf_r+0x1cd4>
80009370:	2f 83       	sub	r3,-8
80009372:	c0 b8       	rjmp	80009388 <_vfprintf_r+0x1ce8>
80009374:	fa ca f9 78 	sub	r10,sp,-1672
80009378:	02 9b       	mov	r11,r1
8000937a:	08 9c       	mov	r12,r4
8000937c:	fe b0 f1 84 	rcall	80007684 <__sprint_r>
80009380:	e0 81 01 0f 	brne	8000959e <_vfprintf_r+0x1efe>
80009384:	fa c3 f9 e0 	sub	r3,sp,-1568
80009388:	fa f8 06 90 	ld.w	r8,sp[1680]
8000938c:	2f f8       	sub	r8,-1
8000938e:	40 cb       	lddsp	r11,sp[0x30]
80009390:	fb 48 06 90 	st.w	sp[1680],r8
80009394:	30 19       	mov	r9,1
80009396:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000939a:	87 0b       	st.w	r3[0x0],r11
8000939c:	2f f8       	sub	r8,-1
8000939e:	87 19       	st.w	r3[0x4],r9
800093a0:	fb 48 06 8c 	st.w	sp[1676],r8
800093a4:	58 78       	cp.w	r8,7
800093a6:	e0 89 00 05 	brgt	800093b0 <_vfprintf_r+0x1d10>
800093aa:	2f 83       	sub	r3,-8
800093ac:	c0 c8       	rjmp	800093c4 <_vfprintf_r+0x1d24>
800093ae:	d7 03       	nop
800093b0:	fa ca f9 78 	sub	r10,sp,-1672
800093b4:	02 9b       	mov	r11,r1
800093b6:	08 9c       	mov	r12,r4
800093b8:	fe b0 f1 66 	rcall	80007684 <__sprint_r>
800093bc:	e0 81 00 f1 	brne	8000959e <_vfprintf_r+0x1efe>
800093c0:	fa c3 f9 e0 	sub	r3,sp,-1568
800093c4:	30 08       	mov	r8,0
800093c6:	30 09       	mov	r9,0
800093c8:	40 5b       	lddsp	r11,sp[0x14]
800093ca:	40 7a       	lddsp	r10,sp[0x1c]
800093cc:	e0 a0 13 19 	rcall	8000b9fe <__avr32_f64_cmp_eq>
800093d0:	40 68       	lddsp	r8,sp[0x18]
800093d2:	20 18       	sub	r8,1
800093d4:	58 0c       	cp.w	r12,0
800093d6:	c0 d1       	brne	800093f0 <_vfprintf_r+0x1d50>
800093d8:	2f f6       	sub	r6,-1
800093da:	87 18       	st.w	r3[0x4],r8
800093dc:	87 06       	st.w	r3[0x0],r6
800093de:	fa f6 06 90 	ld.w	r6,sp[1680]
800093e2:	10 06       	add	r6,r8
800093e4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800093e8:	fb 46 06 90 	st.w	sp[1680],r6
800093ec:	2f f8       	sub	r8,-1
800093ee:	c3 18       	rjmp	80009450 <_vfprintf_r+0x1db0>
800093f0:	10 96       	mov	r6,r8
800093f2:	58 08       	cp.w	r8,0
800093f4:	e0 89 00 1c 	brgt	8000942c <_vfprintf_r+0x1d8c>
800093f8:	c4 b8       	rjmp	8000948e <_vfprintf_r+0x1dee>
800093fa:	2f 09       	sub	r9,-16
800093fc:	2f f8       	sub	r8,-1
800093fe:	fb 49 06 90 	st.w	sp[1680],r9
80009402:	87 02       	st.w	r3[0x0],r2
80009404:	87 10       	st.w	r3[0x4],r0
80009406:	fb 48 06 8c 	st.w	sp[1676],r8
8000940a:	58 78       	cp.w	r8,7
8000940c:	e0 89 00 04 	brgt	80009414 <_vfprintf_r+0x1d74>
80009410:	2f 83       	sub	r3,-8
80009412:	c0 b8       	rjmp	80009428 <_vfprintf_r+0x1d88>
80009414:	fa ca f9 78 	sub	r10,sp,-1672
80009418:	02 9b       	mov	r11,r1
8000941a:	08 9c       	mov	r12,r4
8000941c:	fe b0 f1 34 	rcall	80007684 <__sprint_r>
80009420:	e0 81 00 bf 	brne	8000959e <_vfprintf_r+0x1efe>
80009424:	fa c3 f9 e0 	sub	r3,sp,-1568
80009428:	21 06       	sub	r6,16
8000942a:	c0 48       	rjmp	80009432 <_vfprintf_r+0x1d92>
8000942c:	fe c2 b9 8c 	sub	r2,pc,-18036
80009430:	31 00       	mov	r0,16
80009432:	fa f9 06 90 	ld.w	r9,sp[1680]
80009436:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000943a:	fe ca b9 9a 	sub	r10,pc,-18022
8000943e:	59 06       	cp.w	r6,16
80009440:	fe 99 ff dd 	brgt	800093fa <_vfprintf_r+0x1d5a>
80009444:	0c 09       	add	r9,r6
80009446:	87 0a       	st.w	r3[0x0],r10
80009448:	fb 49 06 90 	st.w	sp[1680],r9
8000944c:	2f f8       	sub	r8,-1
8000944e:	87 16       	st.w	r3[0x4],r6
80009450:	fb 48 06 8c 	st.w	sp[1676],r8
80009454:	c0 e8       	rjmp	80009470 <_vfprintf_r+0x1dd0>
80009456:	fa f8 06 90 	ld.w	r8,sp[1680]
8000945a:	2f f8       	sub	r8,-1
8000945c:	30 19       	mov	r9,1
8000945e:	fb 48 06 90 	st.w	sp[1680],r8
80009462:	87 06       	st.w	r3[0x0],r6
80009464:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009468:	87 19       	st.w	r3[0x4],r9
8000946a:	2f f8       	sub	r8,-1
8000946c:	fb 48 06 8c 	st.w	sp[1676],r8
80009470:	58 78       	cp.w	r8,7
80009472:	e0 89 00 04 	brgt	8000947a <_vfprintf_r+0x1dda>
80009476:	2f 83       	sub	r3,-8
80009478:	c0 b8       	rjmp	8000948e <_vfprintf_r+0x1dee>
8000947a:	fa ca f9 78 	sub	r10,sp,-1672
8000947e:	02 9b       	mov	r11,r1
80009480:	08 9c       	mov	r12,r4
80009482:	fe b0 f1 01 	rcall	80007684 <__sprint_r>
80009486:	e0 81 00 8c 	brne	8000959e <_vfprintf_r+0x1efe>
8000948a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000948e:	40 ea       	lddsp	r10,sp[0x38]
80009490:	fa f8 06 90 	ld.w	r8,sp[1680]
80009494:	14 08       	add	r8,r10
80009496:	fa c9 f9 64 	sub	r9,sp,-1692
8000949a:	fb 48 06 90 	st.w	sp[1680],r8
8000949e:	87 1a       	st.w	r3[0x4],r10
800094a0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800094a4:	87 09       	st.w	r3[0x0],r9
800094a6:	2f f8       	sub	r8,-1
800094a8:	fb 48 06 8c 	st.w	sp[1676],r8
800094ac:	58 78       	cp.w	r8,7
800094ae:	e0 89 00 04 	brgt	800094b6 <_vfprintf_r+0x1e16>
800094b2:	2f 83       	sub	r3,-8
800094b4:	c0 a8       	rjmp	800094c8 <_vfprintf_r+0x1e28>
800094b6:	fa ca f9 78 	sub	r10,sp,-1672
800094ba:	02 9b       	mov	r11,r1
800094bc:	08 9c       	mov	r12,r4
800094be:	fe b0 f0 e3 	rcall	80007684 <__sprint_r>
800094c2:	c6 e1       	brne	8000959e <_vfprintf_r+0x1efe>
800094c4:	fa c3 f9 e0 	sub	r3,sp,-1568
800094c8:	e2 15 00 04 	andl	r5,0x4,COH
800094cc:	c3 f0       	breq	8000954a <_vfprintf_r+0x1eaa>
800094ce:	40 86       	lddsp	r6,sp[0x20]
800094d0:	40 39       	lddsp	r9,sp[0xc]
800094d2:	12 16       	sub	r6,r9
800094d4:	58 06       	cp.w	r6,0
800094d6:	e0 89 00 1a 	brgt	8000950a <_vfprintf_r+0x1e6a>
800094da:	c3 88       	rjmp	8000954a <_vfprintf_r+0x1eaa>
800094dc:	2f 09       	sub	r9,-16
800094de:	2f f8       	sub	r8,-1
800094e0:	fb 49 06 90 	st.w	sp[1680],r9
800094e4:	87 05       	st.w	r3[0x0],r5
800094e6:	87 12       	st.w	r3[0x4],r2
800094e8:	fb 48 06 8c 	st.w	sp[1676],r8
800094ec:	58 78       	cp.w	r8,7
800094ee:	e0 89 00 04 	brgt	800094f6 <_vfprintf_r+0x1e56>
800094f2:	2f 83       	sub	r3,-8
800094f4:	c0 98       	rjmp	80009506 <_vfprintf_r+0x1e66>
800094f6:	00 9a       	mov	r10,r0
800094f8:	02 9b       	mov	r11,r1
800094fa:	08 9c       	mov	r12,r4
800094fc:	fe b0 f0 c4 	rcall	80007684 <__sprint_r>
80009500:	c4 f1       	brne	8000959e <_vfprintf_r+0x1efe>
80009502:	fa c3 f9 e0 	sub	r3,sp,-1568
80009506:	21 06       	sub	r6,16
80009508:	c0 68       	rjmp	80009514 <_vfprintf_r+0x1e74>
8000950a:	fe c5 ba 7a 	sub	r5,pc,-17798
8000950e:	31 02       	mov	r2,16
80009510:	fa c0 f9 78 	sub	r0,sp,-1672
80009514:	fa f9 06 90 	ld.w	r9,sp[1680]
80009518:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000951c:	fe ca ba 8c 	sub	r10,pc,-17780
80009520:	59 06       	cp.w	r6,16
80009522:	fe 99 ff dd 	brgt	800094dc <_vfprintf_r+0x1e3c>
80009526:	0c 09       	add	r9,r6
80009528:	2f f8       	sub	r8,-1
8000952a:	87 0a       	st.w	r3[0x0],r10
8000952c:	87 16       	st.w	r3[0x4],r6
8000952e:	fb 49 06 90 	st.w	sp[1680],r9
80009532:	fb 48 06 8c 	st.w	sp[1676],r8
80009536:	58 78       	cp.w	r8,7
80009538:	e0 8a 00 09 	brle	8000954a <_vfprintf_r+0x1eaa>
8000953c:	fa ca f9 78 	sub	r10,sp,-1672
80009540:	02 9b       	mov	r11,r1
80009542:	08 9c       	mov	r12,r4
80009544:	fe b0 f0 a0 	rcall	80007684 <__sprint_r>
80009548:	c2 b1       	brne	8000959e <_vfprintf_r+0x1efe>
8000954a:	40 bc       	lddsp	r12,sp[0x2c]
8000954c:	40 36       	lddsp	r6,sp[0xc]
8000954e:	40 8e       	lddsp	lr,sp[0x20]
80009550:	ec 0e 0c 48 	max	r8,r6,lr
80009554:	10 0c       	add	r12,r8
80009556:	50 bc       	stdsp	sp[0x2c],r12
80009558:	fa f8 06 90 	ld.w	r8,sp[1680]
8000955c:	58 08       	cp.w	r8,0
8000955e:	c0 80       	breq	8000956e <_vfprintf_r+0x1ece>
80009560:	fa ca f9 78 	sub	r10,sp,-1672
80009564:	02 9b       	mov	r11,r1
80009566:	08 9c       	mov	r12,r4
80009568:	fe b0 f0 8e 	rcall	80007684 <__sprint_r>
8000956c:	c1 91       	brne	8000959e <_vfprintf_r+0x1efe>
8000956e:	30 0b       	mov	r11,0
80009570:	fa c3 f9 e0 	sub	r3,sp,-1568
80009574:	fb 4b 06 8c 	st.w	sp[1676],r11
80009578:	fe 9f f1 22 	bral	800077bc <_vfprintf_r+0x11c>
8000957c:	08 95       	mov	r5,r4
8000957e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009582:	58 08       	cp.w	r8,0
80009584:	c0 80       	breq	80009594 <_vfprintf_r+0x1ef4>
80009586:	08 9c       	mov	r12,r4
80009588:	fa ca f9 78 	sub	r10,sp,-1672
8000958c:	02 9b       	mov	r11,r1
8000958e:	fe b0 f0 7b 	rcall	80007684 <__sprint_r>
80009592:	c0 61       	brne	8000959e <_vfprintf_r+0x1efe>
80009594:	30 08       	mov	r8,0
80009596:	fb 48 06 8c 	st.w	sp[1676],r8
8000959a:	c0 28       	rjmp	8000959e <_vfprintf_r+0x1efe>
8000959c:	40 41       	lddsp	r1,sp[0x10]
8000959e:	82 68       	ld.sh	r8,r1[0xc]
800095a0:	ed b8 00 06 	bld	r8,0x6
800095a4:	c0 31       	brne	800095aa <_vfprintf_r+0x1f0a>
800095a6:	3f fa       	mov	r10,-1
800095a8:	50 ba       	stdsp	sp[0x2c],r10
800095aa:	40 bc       	lddsp	r12,sp[0x2c]
800095ac:	fe 3d f9 44 	sub	sp,-1724
800095b0:	d8 32       	popm	r0-r7,pc
800095b2:	d7 03       	nop

800095b4 <__swsetup_r>:
800095b4:	d4 21       	pushm	r4-r7,lr
800095b6:	e0 68 0a 38 	mov	r8,2616
800095ba:	18 96       	mov	r6,r12
800095bc:	16 97       	mov	r7,r11
800095be:	70 0c       	ld.w	r12,r8[0x0]
800095c0:	58 0c       	cp.w	r12,0
800095c2:	c0 60       	breq	800095ce <__swsetup_r+0x1a>
800095c4:	78 68       	ld.w	r8,r12[0x18]
800095c6:	58 08       	cp.w	r8,0
800095c8:	c0 31       	brne	800095ce <__swsetup_r+0x1a>
800095ca:	e0 a0 07 bf 	rcall	8000a548 <__sinit>
800095ce:	fe c8 ba 0e 	sub	r8,pc,-17906
800095d2:	10 37       	cp.w	r7,r8
800095d4:	c0 61       	brne	800095e0 <__swsetup_r+0x2c>
800095d6:	e0 68 0a 38 	mov	r8,2616
800095da:	70 08       	ld.w	r8,r8[0x0]
800095dc:	70 07       	ld.w	r7,r8[0x0]
800095de:	c1 28       	rjmp	80009602 <__swsetup_r+0x4e>
800095e0:	fe c8 ba 00 	sub	r8,pc,-17920
800095e4:	10 37       	cp.w	r7,r8
800095e6:	c0 61       	brne	800095f2 <__swsetup_r+0x3e>
800095e8:	e0 68 0a 38 	mov	r8,2616
800095ec:	70 08       	ld.w	r8,r8[0x0]
800095ee:	70 17       	ld.w	r7,r8[0x4]
800095f0:	c0 98       	rjmp	80009602 <__swsetup_r+0x4e>
800095f2:	fe c8 b9 f2 	sub	r8,pc,-17934
800095f6:	10 37       	cp.w	r7,r8
800095f8:	c0 51       	brne	80009602 <__swsetup_r+0x4e>
800095fa:	e0 68 0a 38 	mov	r8,2616
800095fe:	70 08       	ld.w	r8,r8[0x0]
80009600:	70 27       	ld.w	r7,r8[0x8]
80009602:	8e 68       	ld.sh	r8,r7[0xc]
80009604:	ed b8 00 03 	bld	r8,0x3
80009608:	c1 e0       	breq	80009644 <__swsetup_r+0x90>
8000960a:	ed b8 00 04 	bld	r8,0x4
8000960e:	c3 e1       	brne	8000968a <__swsetup_r+0xd6>
80009610:	ed b8 00 02 	bld	r8,0x2
80009614:	c1 51       	brne	8000963e <__swsetup_r+0x8a>
80009616:	6e db       	ld.w	r11,r7[0x34]
80009618:	58 0b       	cp.w	r11,0
8000961a:	c0 a0       	breq	8000962e <__swsetup_r+0x7a>
8000961c:	ee c8 ff bc 	sub	r8,r7,-68
80009620:	10 3b       	cp.w	r11,r8
80009622:	c0 40       	breq	8000962a <__swsetup_r+0x76>
80009624:	0c 9c       	mov	r12,r6
80009626:	e0 a0 08 2b 	rcall	8000a67c <_free_r>
8000962a:	30 08       	mov	r8,0
8000962c:	8f d8       	st.w	r7[0x34],r8
8000962e:	8e 68       	ld.sh	r8,r7[0xc]
80009630:	e0 18 ff db 	andl	r8,0xffdb
80009634:	ae 68       	st.h	r7[0xc],r8
80009636:	30 08       	mov	r8,0
80009638:	8f 18       	st.w	r7[0x4],r8
8000963a:	6e 48       	ld.w	r8,r7[0x10]
8000963c:	8f 08       	st.w	r7[0x0],r8
8000963e:	8e 68       	ld.sh	r8,r7[0xc]
80009640:	a3 b8       	sbr	r8,0x3
80009642:	ae 68       	st.h	r7[0xc],r8
80009644:	6e 48       	ld.w	r8,r7[0x10]
80009646:	58 08       	cp.w	r8,0
80009648:	c0 b1       	brne	8000965e <__swsetup_r+0xaa>
8000964a:	8e 68       	ld.sh	r8,r7[0xc]
8000964c:	e2 18 02 80 	andl	r8,0x280,COH
80009650:	e0 48 02 00 	cp.w	r8,512
80009654:	c0 50       	breq	8000965e <__swsetup_r+0xaa>
80009656:	0c 9c       	mov	r12,r6
80009658:	0e 9b       	mov	r11,r7
8000965a:	e0 a0 0a 4b 	rcall	8000aaf0 <__smakebuf_r>
8000965e:	8e 69       	ld.sh	r9,r7[0xc]
80009660:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009664:	c0 70       	breq	80009672 <__swsetup_r+0xbe>
80009666:	30 08       	mov	r8,0
80009668:	8f 28       	st.w	r7[0x8],r8
8000966a:	6e 58       	ld.w	r8,r7[0x14]
8000966c:	5c 38       	neg	r8
8000966e:	8f 68       	st.w	r7[0x18],r8
80009670:	c0 68       	rjmp	8000967c <__swsetup_r+0xc8>
80009672:	ed b9 00 01 	bld	r9,0x1
80009676:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000967a:	8f 28       	st.w	r7[0x8],r8
8000967c:	6e 48       	ld.w	r8,r7[0x10]
8000967e:	58 08       	cp.w	r8,0
80009680:	c0 61       	brne	8000968c <__swsetup_r+0xd8>
80009682:	8e 68       	ld.sh	r8,r7[0xc]
80009684:	ed b8 00 07 	bld	r8,0x7
80009688:	c0 21       	brne	8000968c <__swsetup_r+0xd8>
8000968a:	dc 2a       	popm	r4-r7,pc,r12=-1
8000968c:	d8 2a       	popm	r4-r7,pc,r12=0
8000968e:	d7 03       	nop

80009690 <quorem>:
80009690:	d4 31       	pushm	r0-r7,lr
80009692:	20 2d       	sub	sp,8
80009694:	18 97       	mov	r7,r12
80009696:	78 48       	ld.w	r8,r12[0x10]
80009698:	76 46       	ld.w	r6,r11[0x10]
8000969a:	0c 38       	cp.w	r8,r6
8000969c:	c0 34       	brge	800096a2 <quorem+0x12>
8000969e:	30 0c       	mov	r12,0
800096a0:	c8 58       	rjmp	800097aa <quorem+0x11a>
800096a2:	ec c2 ff fc 	sub	r2,r6,-4
800096a6:	f6 c3 ff ec 	sub	r3,r11,-20
800096aa:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
800096ae:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
800096b2:	2f f9       	sub	r9,-1
800096b4:	20 16       	sub	r6,1
800096b6:	f8 09 0d 08 	divu	r8,r12,r9
800096ba:	f6 02 00 22 	add	r2,r11,r2<<0x2
800096be:	ee c4 ff ec 	sub	r4,r7,-20
800096c2:	10 95       	mov	r5,r8
800096c4:	58 08       	cp.w	r8,0
800096c6:	c4 10       	breq	80009748 <quorem+0xb8>
800096c8:	30 09       	mov	r9,0
800096ca:	06 9a       	mov	r10,r3
800096cc:	08 98       	mov	r8,r4
800096ce:	12 91       	mov	r1,r9
800096d0:	50 0b       	stdsp	sp[0x0],r11
800096d2:	70 0e       	ld.w	lr,r8[0x0]
800096d4:	b1 8e       	lsr	lr,0x10
800096d6:	50 1e       	stdsp	sp[0x4],lr
800096d8:	15 0e       	ld.w	lr,r10++
800096da:	fc 00 16 10 	lsr	r0,lr,0x10
800096de:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800096e2:	ea 0e 03 41 	mac	r1,r5,lr
800096e6:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
800096ea:	b1 81       	lsr	r1,0x10
800096ec:	40 1b       	lddsp	r11,sp[0x4]
800096ee:	ea 00 02 40 	mul	r0,r5,r0
800096f2:	e2 00 00 00 	add	r0,r1,r0
800096f6:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
800096fa:	02 1b       	sub	r11,r1
800096fc:	50 1b       	stdsp	sp[0x4],r11
800096fe:	70 0b       	ld.w	r11,r8[0x0]
80009700:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009704:	02 09       	add	r9,r1
80009706:	f2 0e 01 0e 	sub	lr,r9,lr
8000970a:	b0 1e       	st.h	r8[0x2],lr
8000970c:	fc 09 14 10 	asr	r9,lr,0x10
80009710:	40 1e       	lddsp	lr,sp[0x4]
80009712:	fc 09 00 09 	add	r9,lr,r9
80009716:	b0 09       	st.h	r8[0x0],r9
80009718:	e0 01 16 10 	lsr	r1,r0,0x10
8000971c:	2f c8       	sub	r8,-4
8000971e:	b1 49       	asr	r9,0x10
80009720:	04 3a       	cp.w	r10,r2
80009722:	fe 98 ff d8 	brls	800096d2 <quorem+0x42>
80009726:	40 0b       	lddsp	r11,sp[0x0]
80009728:	58 0c       	cp.w	r12,0
8000972a:	c0 f1       	brne	80009748 <quorem+0xb8>
8000972c:	ec c8 ff fb 	sub	r8,r6,-5
80009730:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009734:	c0 28       	rjmp	80009738 <quorem+0xa8>
80009736:	20 16       	sub	r6,1
80009738:	20 48       	sub	r8,4
8000973a:	08 38       	cp.w	r8,r4
8000973c:	e0 88 00 05 	brls	80009746 <quorem+0xb6>
80009740:	70 09       	ld.w	r9,r8[0x0]
80009742:	58 09       	cp.w	r9,0
80009744:	cf 90       	breq	80009736 <quorem+0xa6>
80009746:	8f 46       	st.w	r7[0x10],r6
80009748:	0e 9c       	mov	r12,r7
8000974a:	e0 a0 0a d2 	rcall	8000acee <__mcmp>
8000974e:	c2 d5       	brlt	800097a8 <quorem+0x118>
80009750:	2f f5       	sub	r5,-1
80009752:	08 98       	mov	r8,r4
80009754:	30 09       	mov	r9,0
80009756:	07 0b       	ld.w	r11,r3++
80009758:	f6 0a 16 10 	lsr	r10,r11,0x10
8000975c:	70 0c       	ld.w	r12,r8[0x0]
8000975e:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009762:	f8 0e 16 10 	lsr	lr,r12,0x10
80009766:	14 1e       	sub	lr,r10
80009768:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000976c:	16 1a       	sub	r10,r11
8000976e:	12 0a       	add	r10,r9
80009770:	b0 1a       	st.h	r8[0x2],r10
80009772:	b1 4a       	asr	r10,0x10
80009774:	fc 0a 00 09 	add	r9,lr,r10
80009778:	b0 09       	st.h	r8[0x0],r9
8000977a:	2f c8       	sub	r8,-4
8000977c:	b1 49       	asr	r9,0x10
8000977e:	04 33       	cp.w	r3,r2
80009780:	fe 98 ff eb 	brls	80009756 <quorem+0xc6>
80009784:	ec c8 ff fb 	sub	r8,r6,-5
80009788:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000978c:	58 09       	cp.w	r9,0
8000978e:	c0 d1       	brne	800097a8 <quorem+0x118>
80009790:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009794:	c0 28       	rjmp	80009798 <quorem+0x108>
80009796:	20 16       	sub	r6,1
80009798:	20 48       	sub	r8,4
8000979a:	08 38       	cp.w	r8,r4
8000979c:	e0 88 00 05 	brls	800097a6 <quorem+0x116>
800097a0:	70 09       	ld.w	r9,r8[0x0]
800097a2:	58 09       	cp.w	r9,0
800097a4:	cf 90       	breq	80009796 <quorem+0x106>
800097a6:	8f 46       	st.w	r7[0x10],r6
800097a8:	0a 9c       	mov	r12,r5
800097aa:	2f ed       	sub	sp,-8
800097ac:	d8 32       	popm	r0-r7,pc
800097ae:	d7 03       	nop

800097b0 <_dtoa_r>:
800097b0:	d4 31       	pushm	r0-r7,lr
800097b2:	21 ad       	sub	sp,104
800097b4:	fa c4 ff 74 	sub	r4,sp,-140
800097b8:	18 97       	mov	r7,r12
800097ba:	16 95       	mov	r5,r11
800097bc:	68 2c       	ld.w	r12,r4[0x8]
800097be:	50 c9       	stdsp	sp[0x30],r9
800097c0:	68 16       	ld.w	r6,r4[0x4]
800097c2:	68 09       	ld.w	r9,r4[0x0]
800097c4:	50 e8       	stdsp	sp[0x38],r8
800097c6:	14 94       	mov	r4,r10
800097c8:	51 2c       	stdsp	sp[0x48],r12
800097ca:	fa e5 00 08 	st.d	sp[8],r4
800097ce:	51 59       	stdsp	sp[0x54],r9
800097d0:	6e 95       	ld.w	r5,r7[0x24]
800097d2:	58 05       	cp.w	r5,0
800097d4:	c0 91       	brne	800097e6 <_dtoa_r+0x36>
800097d6:	31 0c       	mov	r12,16
800097d8:	fe b0 e8 e8 	rcall	800069a8 <malloc>
800097dc:	99 35       	st.w	r12[0xc],r5
800097de:	8f 9c       	st.w	r7[0x24],r12
800097e0:	99 15       	st.w	r12[0x4],r5
800097e2:	99 25       	st.w	r12[0x8],r5
800097e4:	99 05       	st.w	r12[0x0],r5
800097e6:	6e 99       	ld.w	r9,r7[0x24]
800097e8:	72 08       	ld.w	r8,r9[0x0]
800097ea:	58 08       	cp.w	r8,0
800097ec:	c0 f0       	breq	8000980a <_dtoa_r+0x5a>
800097ee:	72 1a       	ld.w	r10,r9[0x4]
800097f0:	91 1a       	st.w	r8[0x4],r10
800097f2:	30 1a       	mov	r10,1
800097f4:	72 19       	ld.w	r9,r9[0x4]
800097f6:	f4 09 09 49 	lsl	r9,r10,r9
800097fa:	10 9b       	mov	r11,r8
800097fc:	91 29       	st.w	r8[0x8],r9
800097fe:	0e 9c       	mov	r12,r7
80009800:	e0 a0 0a 90 	rcall	8000ad20 <_Bfree>
80009804:	6e 98       	ld.w	r8,r7[0x24]
80009806:	30 09       	mov	r9,0
80009808:	91 09       	st.w	r8[0x0],r9
8000980a:	40 28       	lddsp	r8,sp[0x8]
8000980c:	10 94       	mov	r4,r8
8000980e:	58 08       	cp.w	r8,0
80009810:	c0 64       	brge	8000981c <_dtoa_r+0x6c>
80009812:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80009816:	50 28       	stdsp	sp[0x8],r8
80009818:	30 18       	mov	r8,1
8000981a:	c0 28       	rjmp	8000981e <_dtoa_r+0x6e>
8000981c:	30 08       	mov	r8,0
8000981e:	8d 08       	st.w	r6[0x0],r8
80009820:	fc 1c 7f f0 	movh	r12,0x7ff0
80009824:	40 26       	lddsp	r6,sp[0x8]
80009826:	0c 98       	mov	r8,r6
80009828:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000982c:	18 38       	cp.w	r8,r12
8000982e:	c2 01       	brne	8000986e <_dtoa_r+0xbe>
80009830:	e0 68 27 0f 	mov	r8,9999
80009834:	41 5b       	lddsp	r11,sp[0x54]
80009836:	97 08       	st.w	r11[0x0],r8
80009838:	40 3a       	lddsp	r10,sp[0xc]
8000983a:	58 0a       	cp.w	r10,0
8000983c:	c0 71       	brne	8000984a <_dtoa_r+0x9a>
8000983e:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80009842:	c0 41       	brne	8000984a <_dtoa_r+0x9a>
80009844:	fe cc bc 94 	sub	r12,pc,-17260
80009848:	c0 38       	rjmp	8000984e <_dtoa_r+0x9e>
8000984a:	fe cc bc 8e 	sub	r12,pc,-17266
8000984e:	41 29       	lddsp	r9,sp[0x48]
80009850:	58 09       	cp.w	r9,0
80009852:	e0 80 05 9a 	breq	8000a386 <_dtoa_r+0xbd6>
80009856:	f8 c8 ff fd 	sub	r8,r12,-3
8000985a:	f8 c9 ff f8 	sub	r9,r12,-8
8000985e:	11 8b       	ld.ub	r11,r8[0x0]
80009860:	30 0a       	mov	r10,0
80009862:	41 25       	lddsp	r5,sp[0x48]
80009864:	f4 0b 18 00 	cp.b	r11,r10
80009868:	f2 08 17 10 	movne	r8,r9
8000986c:	c1 68       	rjmp	80009898 <_dtoa_r+0xe8>
8000986e:	fa ea 00 08 	ld.d	r10,sp[8]
80009872:	30 08       	mov	r8,0
80009874:	fa eb 00 3c 	st.d	sp[60],r10
80009878:	30 09       	mov	r9,0
8000987a:	e0 a0 10 c2 	rcall	8000b9fe <__avr32_f64_cmp_eq>
8000987e:	c1 00       	breq	8000989e <_dtoa_r+0xee>
80009880:	30 18       	mov	r8,1
80009882:	41 5a       	lddsp	r10,sp[0x54]
80009884:	95 08       	st.w	r10[0x0],r8
80009886:	fe cc bd fa 	sub	r12,pc,-16902
8000988a:	41 29       	lddsp	r9,sp[0x48]
8000988c:	f8 08 00 08 	add	r8,r12,r8
80009890:	58 09       	cp.w	r9,0
80009892:	e0 80 05 7a 	breq	8000a386 <_dtoa_r+0xbd6>
80009896:	12 95       	mov	r5,r9
80009898:	8b 08       	st.w	r5[0x0],r8
8000989a:	e0 8f 05 76 	bral	8000a386 <_dtoa_r+0xbd6>
8000989e:	fa c8 ff 9c 	sub	r8,sp,-100
800098a2:	fa c9 ff a0 	sub	r9,sp,-96
800098a6:	fa ea 00 3c 	ld.d	r10,sp[60]
800098aa:	0e 9c       	mov	r12,r7
800098ac:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
800098b0:	e0 a0 0a 8a 	rcall	8000adc4 <__d2b>
800098b4:	18 93       	mov	r3,r12
800098b6:	58 05       	cp.w	r5,0
800098b8:	c0 d0       	breq	800098d2 <_dtoa_r+0x122>
800098ba:	fa ea 00 3c 	ld.d	r10,sp[60]
800098be:	30 04       	mov	r4,0
800098c0:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
800098c4:	ea c5 03 ff 	sub	r5,r5,1023
800098c8:	10 9b       	mov	r11,r8
800098ca:	51 74       	stdsp	sp[0x5c],r4
800098cc:	ea 1b 3f f0 	orh	r11,0x3ff0
800098d0:	c2 58       	rjmp	8000991a <_dtoa_r+0x16a>
800098d2:	41 88       	lddsp	r8,sp[0x60]
800098d4:	41 9c       	lddsp	r12,sp[0x64]
800098d6:	10 0c       	add	r12,r8
800098d8:	f8 c5 fb ce 	sub	r5,r12,-1074
800098dc:	e0 45 00 20 	cp.w	r5,32
800098e0:	e0 8a 00 0e 	brle	800098fc <_dtoa_r+0x14c>
800098e4:	f8 cc fb ee 	sub	r12,r12,-1042
800098e8:	40 3b       	lddsp	r11,sp[0xc]
800098ea:	ea 08 11 40 	rsub	r8,r5,64
800098ee:	f6 0c 0a 4c 	lsr	r12,r11,r12
800098f2:	ec 08 09 46 	lsl	r6,r6,r8
800098f6:	0c 4c       	or	r12,r6
800098f8:	c0 78       	rjmp	80009906 <_dtoa_r+0x156>
800098fa:	d7 03       	nop
800098fc:	ea 0c 11 20 	rsub	r12,r5,32
80009900:	40 3a       	lddsp	r10,sp[0xc]
80009902:	f4 0c 09 4c 	lsl	r12,r10,r12
80009906:	e0 a0 10 08 	rcall	8000b916 <__avr32_u32_to_f64>
8000990a:	fc 18 fe 10 	movh	r8,0xfe10
8000990e:	30 19       	mov	r9,1
80009910:	ea c5 04 33 	sub	r5,r5,1075
80009914:	f0 0b 00 0b 	add	r11,r8,r11
80009918:	51 79       	stdsp	sp[0x5c],r9
8000991a:	30 08       	mov	r8,0
8000991c:	fc 19 3f f8 	movh	r9,0x3ff8
80009920:	e0 a0 0e 90 	rcall	8000b640 <__avr32_f64_sub>
80009924:	e0 68 43 61 	mov	r8,17249
80009928:	ea 18 63 6f 	orh	r8,0x636f
8000992c:	e0 69 87 a7 	mov	r9,34727
80009930:	ea 19 3f d2 	orh	r9,0x3fd2
80009934:	e0 a0 0d 9a 	rcall	8000b468 <__avr32_f64_mul>
80009938:	e0 68 c8 b3 	mov	r8,51379
8000993c:	ea 18 8b 60 	orh	r8,0x8b60
80009940:	e0 69 8a 28 	mov	r9,35368
80009944:	ea 19 3f c6 	orh	r9,0x3fc6
80009948:	e0 a0 0f 4a 	rcall	8000b7dc <__avr32_f64_add>
8000994c:	0a 9c       	mov	r12,r5
8000994e:	14 90       	mov	r0,r10
80009950:	16 91       	mov	r1,r11
80009952:	e0 a0 0f e6 	rcall	8000b91e <__avr32_s32_to_f64>
80009956:	e0 68 79 fb 	mov	r8,31227
8000995a:	ea 18 50 9f 	orh	r8,0x509f
8000995e:	e0 69 44 13 	mov	r9,17427
80009962:	ea 19 3f d3 	orh	r9,0x3fd3
80009966:	e0 a0 0d 81 	rcall	8000b468 <__avr32_f64_mul>
8000996a:	14 98       	mov	r8,r10
8000996c:	16 99       	mov	r9,r11
8000996e:	00 9a       	mov	r10,r0
80009970:	02 9b       	mov	r11,r1
80009972:	e0 a0 0f 35 	rcall	8000b7dc <__avr32_f64_add>
80009976:	14 90       	mov	r0,r10
80009978:	16 91       	mov	r1,r11
8000997a:	e0 a0 0f bb 	rcall	8000b8f0 <__avr32_f64_to_s32>
8000997e:	30 08       	mov	r8,0
80009980:	18 96       	mov	r6,r12
80009982:	30 09       	mov	r9,0
80009984:	00 9a       	mov	r10,r0
80009986:	02 9b       	mov	r11,r1
80009988:	e0 a0 10 82 	rcall	8000ba8c <__avr32_f64_cmp_lt>
8000998c:	c0 c0       	breq	800099a4 <_dtoa_r+0x1f4>
8000998e:	0c 9c       	mov	r12,r6
80009990:	e0 a0 0f c7 	rcall	8000b91e <__avr32_s32_to_f64>
80009994:	14 98       	mov	r8,r10
80009996:	16 99       	mov	r9,r11
80009998:	00 9a       	mov	r10,r0
8000999a:	02 9b       	mov	r11,r1
8000999c:	e0 a0 10 31 	rcall	8000b9fe <__avr32_f64_cmp_eq>
800099a0:	f7 b6 00 01 	subeq	r6,1
800099a4:	59 66       	cp.w	r6,22
800099a6:	e0 88 00 05 	brls	800099b0 <_dtoa_r+0x200>
800099aa:	30 18       	mov	r8,1
800099ac:	51 48       	stdsp	sp[0x50],r8
800099ae:	c1 38       	rjmp	800099d4 <_dtoa_r+0x224>
800099b0:	fe c8 bd 40 	sub	r8,pc,-17088
800099b4:	fa ea 00 3c 	ld.d	r10,sp[60]
800099b8:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
800099bc:	e0 a0 10 68 	rcall	8000ba8c <__avr32_f64_cmp_lt>
800099c0:	f9 b4 00 00 	moveq	r4,0
800099c4:	fb f4 0a 14 	st.weq	sp[0x50],r4
800099c8:	f7 b6 01 01 	subne	r6,1
800099cc:	f9 bc 01 00 	movne	r12,0
800099d0:	fb fc 1a 14 	st.wne	sp[0x50],r12
800099d4:	41 90       	lddsp	r0,sp[0x64]
800099d6:	20 10       	sub	r0,1
800099d8:	0a 10       	sub	r0,r5
800099da:	c0 46       	brmi	800099e2 <_dtoa_r+0x232>
800099dc:	50 40       	stdsp	sp[0x10],r0
800099de:	30 00       	mov	r0,0
800099e0:	c0 48       	rjmp	800099e8 <_dtoa_r+0x238>
800099e2:	30 0b       	mov	r11,0
800099e4:	5c 30       	neg	r0
800099e6:	50 4b       	stdsp	sp[0x10],r11
800099e8:	ec 02 11 00 	rsub	r2,r6,0
800099ec:	58 06       	cp.w	r6,0
800099ee:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800099f2:	f5 d6 e4 0a 	addge	r10,r10,r6
800099f6:	fb fa 4a 04 	st.wge	sp[0x10],r10
800099fa:	fb f6 4a 11 	st.wge	sp[0x44],r6
800099fe:	f9 b2 04 00 	movge	r2,0
80009a02:	e1 d6 e5 10 	sublt	r0,r0,r6
80009a06:	f9 b9 05 00 	movlt	r9,0
80009a0a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
80009a0e:	40 c8       	lddsp	r8,sp[0x30]
80009a10:	58 98       	cp.w	r8,9
80009a12:	e0 8b 00 20 	brhi	80009a52 <_dtoa_r+0x2a2>
80009a16:	58 58       	cp.w	r8,5
80009a18:	f9 b4 0a 01 	movle	r4,1
80009a1c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
80009a20:	f7 b5 09 04 	subgt	r5,4
80009a24:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
80009a28:	f9 b4 09 00 	movgt	r4,0
80009a2c:	40 cc       	lddsp	r12,sp[0x30]
80009a2e:	58 3c       	cp.w	r12,3
80009a30:	c2 d0       	breq	80009a8a <_dtoa_r+0x2da>
80009a32:	e0 89 00 05 	brgt	80009a3c <_dtoa_r+0x28c>
80009a36:	58 2c       	cp.w	r12,2
80009a38:	c1 01       	brne	80009a58 <_dtoa_r+0x2a8>
80009a3a:	c1 88       	rjmp	80009a6a <_dtoa_r+0x2ba>
80009a3c:	40 cb       	lddsp	r11,sp[0x30]
80009a3e:	58 4b       	cp.w	r11,4
80009a40:	c0 60       	breq	80009a4c <_dtoa_r+0x29c>
80009a42:	58 5b       	cp.w	r11,5
80009a44:	c0 a1       	brne	80009a58 <_dtoa_r+0x2a8>
80009a46:	30 1a       	mov	r10,1
80009a48:	50 da       	stdsp	sp[0x34],r10
80009a4a:	c2 28       	rjmp	80009a8e <_dtoa_r+0x2de>
80009a4c:	30 19       	mov	r9,1
80009a4e:	50 d9       	stdsp	sp[0x34],r9
80009a50:	c0 f8       	rjmp	80009a6e <_dtoa_r+0x2be>
80009a52:	30 08       	mov	r8,0
80009a54:	30 14       	mov	r4,1
80009a56:	50 c8       	stdsp	sp[0x30],r8
80009a58:	3f f5       	mov	r5,-1
80009a5a:	30 1c       	mov	r12,1
80009a5c:	30 0b       	mov	r11,0
80009a5e:	50 95       	stdsp	sp[0x24],r5
80009a60:	50 dc       	stdsp	sp[0x34],r12
80009a62:	0a 91       	mov	r1,r5
80009a64:	31 28       	mov	r8,18
80009a66:	50 eb       	stdsp	sp[0x38],r11
80009a68:	c2 08       	rjmp	80009aa8 <_dtoa_r+0x2f8>
80009a6a:	30 0a       	mov	r10,0
80009a6c:	50 da       	stdsp	sp[0x34],r10
80009a6e:	40 e9       	lddsp	r9,sp[0x38]
80009a70:	58 09       	cp.w	r9,0
80009a72:	e0 89 00 07 	brgt	80009a80 <_dtoa_r+0x2d0>
80009a76:	30 18       	mov	r8,1
80009a78:	50 98       	stdsp	sp[0x24],r8
80009a7a:	10 91       	mov	r1,r8
80009a7c:	50 e8       	stdsp	sp[0x38],r8
80009a7e:	c1 58       	rjmp	80009aa8 <_dtoa_r+0x2f8>
80009a80:	40 e5       	lddsp	r5,sp[0x38]
80009a82:	50 95       	stdsp	sp[0x24],r5
80009a84:	0a 91       	mov	r1,r5
80009a86:	0a 98       	mov	r8,r5
80009a88:	c1 08       	rjmp	80009aa8 <_dtoa_r+0x2f8>
80009a8a:	30 0c       	mov	r12,0
80009a8c:	50 dc       	stdsp	sp[0x34],r12
80009a8e:	40 eb       	lddsp	r11,sp[0x38]
80009a90:	ec 0b 00 0b 	add	r11,r6,r11
80009a94:	50 9b       	stdsp	sp[0x24],r11
80009a96:	16 98       	mov	r8,r11
80009a98:	2f f8       	sub	r8,-1
80009a9a:	58 08       	cp.w	r8,0
80009a9c:	e0 89 00 05 	brgt	80009aa6 <_dtoa_r+0x2f6>
80009aa0:	10 91       	mov	r1,r8
80009aa2:	30 18       	mov	r8,1
80009aa4:	c0 28       	rjmp	80009aa8 <_dtoa_r+0x2f8>
80009aa6:	10 91       	mov	r1,r8
80009aa8:	30 09       	mov	r9,0
80009aaa:	6e 9a       	ld.w	r10,r7[0x24]
80009aac:	95 19       	st.w	r10[0x4],r9
80009aae:	30 49       	mov	r9,4
80009ab0:	c0 68       	rjmp	80009abc <_dtoa_r+0x30c>
80009ab2:	d7 03       	nop
80009ab4:	6a 1a       	ld.w	r10,r5[0x4]
80009ab6:	a1 79       	lsl	r9,0x1
80009ab8:	2f fa       	sub	r10,-1
80009aba:	8b 1a       	st.w	r5[0x4],r10
80009abc:	6e 95       	ld.w	r5,r7[0x24]
80009abe:	f2 ca ff ec 	sub	r10,r9,-20
80009ac2:	10 3a       	cp.w	r10,r8
80009ac4:	fe 98 ff f8 	brls	80009ab4 <_dtoa_r+0x304>
80009ac8:	6a 1b       	ld.w	r11,r5[0x4]
80009aca:	0e 9c       	mov	r12,r7
80009acc:	e0 a0 09 44 	rcall	8000ad54 <_Balloc>
80009ad0:	58 e1       	cp.w	r1,14
80009ad2:	5f 88       	srls	r8
80009ad4:	8b 0c       	st.w	r5[0x0],r12
80009ad6:	f1 e4 00 04 	and	r4,r8,r4
80009ada:	6e 98       	ld.w	r8,r7[0x24]
80009adc:	70 08       	ld.w	r8,r8[0x0]
80009ade:	50 88       	stdsp	sp[0x20],r8
80009ae0:	e0 80 01 82 	breq	80009de4 <_dtoa_r+0x634>
80009ae4:	58 06       	cp.w	r6,0
80009ae6:	e0 8a 00 43 	brle	80009b6c <_dtoa_r+0x3bc>
80009aea:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
80009aee:	fe c8 be 7e 	sub	r8,pc,-16770
80009af2:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009af6:	fa e5 00 18 	st.d	sp[24],r4
80009afa:	ec 04 14 04 	asr	r4,r6,0x4
80009afe:	ed b4 00 04 	bld	r4,0x4
80009b02:	c0 30       	breq	80009b08 <_dtoa_r+0x358>
80009b04:	30 25       	mov	r5,2
80009b06:	c1 08       	rjmp	80009b26 <_dtoa_r+0x376>
80009b08:	fe c8 bd d0 	sub	r8,pc,-16944
80009b0c:	f0 e8 00 20 	ld.d	r8,r8[32]
80009b10:	fa ea 00 3c 	ld.d	r10,sp[60]
80009b14:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009b18:	e0 a0 0f ee 	rcall	8000baf4 <__avr32_f64_div>
80009b1c:	30 35       	mov	r5,3
80009b1e:	14 98       	mov	r8,r10
80009b20:	16 99       	mov	r9,r11
80009b22:	fa e9 00 08 	st.d	sp[8],r8
80009b26:	fe cc bd ee 	sub	r12,pc,-16914
80009b2a:	50 a3       	stdsp	sp[0x28],r3
80009b2c:	0c 93       	mov	r3,r6
80009b2e:	18 96       	mov	r6,r12
80009b30:	c0 f8       	rjmp	80009b4e <_dtoa_r+0x39e>
80009b32:	fa ea 00 18 	ld.d	r10,sp[24]
80009b36:	ed b4 00 00 	bld	r4,0x0
80009b3a:	c0 81       	brne	80009b4a <_dtoa_r+0x39a>
80009b3c:	ec e8 00 00 	ld.d	r8,r6[0]
80009b40:	2f f5       	sub	r5,-1
80009b42:	e0 a0 0c 93 	rcall	8000b468 <__avr32_f64_mul>
80009b46:	fa eb 00 18 	st.d	sp[24],r10
80009b4a:	a1 54       	asr	r4,0x1
80009b4c:	2f 86       	sub	r6,-8
80009b4e:	58 04       	cp.w	r4,0
80009b50:	cf 11       	brne	80009b32 <_dtoa_r+0x382>
80009b52:	fa e8 00 18 	ld.d	r8,sp[24]
80009b56:	fa ea 00 08 	ld.d	r10,sp[8]
80009b5a:	06 96       	mov	r6,r3
80009b5c:	e0 a0 0f cc 	rcall	8000baf4 <__avr32_f64_div>
80009b60:	40 a3       	lddsp	r3,sp[0x28]
80009b62:	14 98       	mov	r8,r10
80009b64:	16 99       	mov	r9,r11
80009b66:	fa e9 00 08 	st.d	sp[8],r8
80009b6a:	c2 f8       	rjmp	80009bc8 <_dtoa_r+0x418>
80009b6c:	ec 08 11 00 	rsub	r8,r6,0
80009b70:	c0 31       	brne	80009b76 <_dtoa_r+0x3c6>
80009b72:	30 25       	mov	r5,2
80009b74:	c2 a8       	rjmp	80009bc8 <_dtoa_r+0x418>
80009b76:	fe cc be 3e 	sub	r12,pc,-16834
80009b7a:	f0 04 14 04 	asr	r4,r8,0x4
80009b7e:	50 1c       	stdsp	sp[0x4],r12
80009b80:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009b84:	fe c9 bf 14 	sub	r9,pc,-16620
80009b88:	fa ea 00 3c 	ld.d	r10,sp[60]
80009b8c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009b90:	e0 a0 0c 6c 	rcall	8000b468 <__avr32_f64_mul>
80009b94:	40 1c       	lddsp	r12,sp[0x4]
80009b96:	50 63       	stdsp	sp[0x18],r3
80009b98:	30 25       	mov	r5,2
80009b9a:	0c 93       	mov	r3,r6
80009b9c:	fa eb 00 08 	st.d	sp[8],r10
80009ba0:	18 96       	mov	r6,r12
80009ba2:	c0 f8       	rjmp	80009bc0 <_dtoa_r+0x410>
80009ba4:	fa ea 00 08 	ld.d	r10,sp[8]
80009ba8:	ed b4 00 00 	bld	r4,0x0
80009bac:	c0 81       	brne	80009bbc <_dtoa_r+0x40c>
80009bae:	ec e8 00 00 	ld.d	r8,r6[0]
80009bb2:	2f f5       	sub	r5,-1
80009bb4:	e0 a0 0c 5a 	rcall	8000b468 <__avr32_f64_mul>
80009bb8:	fa eb 00 08 	st.d	sp[8],r10
80009bbc:	a1 54       	asr	r4,0x1
80009bbe:	2f 86       	sub	r6,-8
80009bc0:	58 04       	cp.w	r4,0
80009bc2:	cf 11       	brne	80009ba4 <_dtoa_r+0x3f4>
80009bc4:	06 96       	mov	r6,r3
80009bc6:	40 63       	lddsp	r3,sp[0x18]
80009bc8:	41 4a       	lddsp	r10,sp[0x50]
80009bca:	58 0a       	cp.w	r10,0
80009bcc:	c2 a0       	breq	80009c20 <_dtoa_r+0x470>
80009bce:	fa e8 00 08 	ld.d	r8,sp[8]
80009bd2:	58 01       	cp.w	r1,0
80009bd4:	5f 94       	srgt	r4
80009bd6:	fa e9 00 18 	st.d	sp[24],r8
80009bda:	30 08       	mov	r8,0
80009bdc:	fc 19 3f f0 	movh	r9,0x3ff0
80009be0:	fa ea 00 18 	ld.d	r10,sp[24]
80009be4:	e0 a0 0f 54 	rcall	8000ba8c <__avr32_f64_cmp_lt>
80009be8:	f9 bc 00 00 	moveq	r12,0
80009bec:	f9 bc 01 01 	movne	r12,1
80009bf0:	e9 ec 00 0c 	and	r12,r4,r12
80009bf4:	c1 60       	breq	80009c20 <_dtoa_r+0x470>
80009bf6:	40 98       	lddsp	r8,sp[0x24]
80009bf8:	58 08       	cp.w	r8,0
80009bfa:	e0 8a 00 f1 	brle	80009ddc <_dtoa_r+0x62c>
80009bfe:	30 08       	mov	r8,0
80009c00:	fc 19 40 24 	movh	r9,0x4024
80009c04:	ec c4 00 01 	sub	r4,r6,1
80009c08:	fa ea 00 18 	ld.d	r10,sp[24]
80009c0c:	2f f5       	sub	r5,-1
80009c0e:	50 64       	stdsp	sp[0x18],r4
80009c10:	e0 a0 0c 2c 	rcall	8000b468 <__avr32_f64_mul>
80009c14:	40 94       	lddsp	r4,sp[0x24]
80009c16:	14 98       	mov	r8,r10
80009c18:	16 99       	mov	r9,r11
80009c1a:	fa e9 00 08 	st.d	sp[8],r8
80009c1e:	c0 38       	rjmp	80009c24 <_dtoa_r+0x474>
80009c20:	50 66       	stdsp	sp[0x18],r6
80009c22:	02 94       	mov	r4,r1
80009c24:	0a 9c       	mov	r12,r5
80009c26:	e0 a0 0e 7c 	rcall	8000b91e <__avr32_s32_to_f64>
80009c2a:	fa e8 00 08 	ld.d	r8,sp[8]
80009c2e:	e0 a0 0c 1d 	rcall	8000b468 <__avr32_f64_mul>
80009c32:	30 08       	mov	r8,0
80009c34:	fc 19 40 1c 	movh	r9,0x401c
80009c38:	e0 a0 0d d2 	rcall	8000b7dc <__avr32_f64_add>
80009c3c:	14 98       	mov	r8,r10
80009c3e:	16 99       	mov	r9,r11
80009c40:	fa e9 00 28 	st.d	sp[40],r8
80009c44:	fc 18 fc c0 	movh	r8,0xfcc0
80009c48:	40 a5       	lddsp	r5,sp[0x28]
80009c4a:	10 05       	add	r5,r8
80009c4c:	50 a5       	stdsp	sp[0x28],r5
80009c4e:	58 04       	cp.w	r4,0
80009c50:	c2 11       	brne	80009c92 <_dtoa_r+0x4e2>
80009c52:	fa ea 00 08 	ld.d	r10,sp[8]
80009c56:	30 08       	mov	r8,0
80009c58:	fc 19 40 14 	movh	r9,0x4014
80009c5c:	e0 a0 0c f2 	rcall	8000b640 <__avr32_f64_sub>
80009c60:	40 bc       	lddsp	r12,sp[0x2c]
80009c62:	fa eb 00 08 	st.d	sp[8],r10
80009c66:	14 98       	mov	r8,r10
80009c68:	16 99       	mov	r9,r11
80009c6a:	18 9a       	mov	r10,r12
80009c6c:	0a 9b       	mov	r11,r5
80009c6e:	e0 a0 0f 0f 	rcall	8000ba8c <__avr32_f64_cmp_lt>
80009c72:	e0 81 02 54 	brne	8000a11a <_dtoa_r+0x96a>
80009c76:	0a 98       	mov	r8,r5
80009c78:	40 b9       	lddsp	r9,sp[0x2c]
80009c7a:	ee 18 80 00 	eorh	r8,0x8000
80009c7e:	fa ea 00 08 	ld.d	r10,sp[8]
80009c82:	10 95       	mov	r5,r8
80009c84:	12 98       	mov	r8,r9
80009c86:	0a 99       	mov	r9,r5
80009c88:	e0 a0 0f 02 	rcall	8000ba8c <__avr32_f64_cmp_lt>
80009c8c:	e0 81 02 3e 	brne	8000a108 <_dtoa_r+0x958>
80009c90:	ca 68       	rjmp	80009ddc <_dtoa_r+0x62c>
80009c92:	fe c9 c0 22 	sub	r9,pc,-16350
80009c96:	e8 c8 00 01 	sub	r8,r4,1
80009c9a:	40 d5       	lddsp	r5,sp[0x34]
80009c9c:	58 05       	cp.w	r5,0
80009c9e:	c4 f0       	breq	80009d3c <_dtoa_r+0x58c>
80009ca0:	30 0c       	mov	r12,0
80009ca2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009ca6:	51 3c       	stdsp	sp[0x4c],r12
80009ca8:	30 0a       	mov	r10,0
80009caa:	fc 1b 3f e0 	movh	r11,0x3fe0
80009cae:	e0 a0 0f 23 	rcall	8000baf4 <__avr32_f64_div>
80009cb2:	fa e8 00 28 	ld.d	r8,sp[40]
80009cb6:	40 85       	lddsp	r5,sp[0x20]
80009cb8:	e0 a0 0c c4 	rcall	8000b640 <__avr32_f64_sub>
80009cbc:	fa eb 00 28 	st.d	sp[40],r10
80009cc0:	fa ea 00 08 	ld.d	r10,sp[8]
80009cc4:	e0 a0 0e 16 	rcall	8000b8f0 <__avr32_f64_to_s32>
80009cc8:	51 6c       	stdsp	sp[0x58],r12
80009cca:	e0 a0 0e 2a 	rcall	8000b91e <__avr32_s32_to_f64>
80009cce:	14 98       	mov	r8,r10
80009cd0:	16 99       	mov	r9,r11
80009cd2:	fa ea 00 08 	ld.d	r10,sp[8]
80009cd6:	e0 a0 0c b5 	rcall	8000b640 <__avr32_f64_sub>
80009cda:	fa eb 00 08 	st.d	sp[8],r10
80009cde:	41 68       	lddsp	r8,sp[0x58]
80009ce0:	2d 08       	sub	r8,-48
80009ce2:	0a c8       	st.b	r5++,r8
80009ce4:	41 39       	lddsp	r9,sp[0x4c]
80009ce6:	2f f9       	sub	r9,-1
80009ce8:	51 39       	stdsp	sp[0x4c],r9
80009cea:	fa e8 00 28 	ld.d	r8,sp[40]
80009cee:	e0 a0 0e cf 	rcall	8000ba8c <__avr32_f64_cmp_lt>
80009cf2:	e0 81 03 39 	brne	8000a364 <_dtoa_r+0xbb4>
80009cf6:	fa e8 00 08 	ld.d	r8,sp[8]
80009cfa:	30 0a       	mov	r10,0
80009cfc:	fc 1b 3f f0 	movh	r11,0x3ff0
80009d00:	e0 a0 0c a0 	rcall	8000b640 <__avr32_f64_sub>
80009d04:	fa e8 00 28 	ld.d	r8,sp[40]
80009d08:	e0 a0 0e c2 	rcall	8000ba8c <__avr32_f64_cmp_lt>
80009d0c:	fa ea 00 28 	ld.d	r10,sp[40]
80009d10:	30 08       	mov	r8,0
80009d12:	fc 19 40 24 	movh	r9,0x4024
80009d16:	e0 81 00 da 	brne	80009eca <_dtoa_r+0x71a>
80009d1a:	41 3c       	lddsp	r12,sp[0x4c]
80009d1c:	08 3c       	cp.w	r12,r4
80009d1e:	c5 f4       	brge	80009ddc <_dtoa_r+0x62c>
80009d20:	e0 a0 0b a4 	rcall	8000b468 <__avr32_f64_mul>
80009d24:	30 08       	mov	r8,0
80009d26:	fa eb 00 28 	st.d	sp[40],r10
80009d2a:	fc 19 40 24 	movh	r9,0x4024
80009d2e:	fa ea 00 08 	ld.d	r10,sp[8]
80009d32:	e0 a0 0b 9b 	rcall	8000b468 <__avr32_f64_mul>
80009d36:	fa eb 00 08 	st.d	sp[8],r10
80009d3a:	cc 3b       	rjmp	80009cc0 <_dtoa_r+0x510>
80009d3c:	40 85       	lddsp	r5,sp[0x20]
80009d3e:	08 05       	add	r5,r4
80009d40:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80009d44:	51 35       	stdsp	sp[0x4c],r5
80009d46:	fa e8 00 28 	ld.d	r8,sp[40]
80009d4a:	40 85       	lddsp	r5,sp[0x20]
80009d4c:	e0 a0 0b 8e 	rcall	8000b468 <__avr32_f64_mul>
80009d50:	fa eb 00 28 	st.d	sp[40],r10
80009d54:	fa ea 00 08 	ld.d	r10,sp[8]
80009d58:	e0 a0 0d cc 	rcall	8000b8f0 <__avr32_f64_to_s32>
80009d5c:	51 6c       	stdsp	sp[0x58],r12
80009d5e:	e0 a0 0d e0 	rcall	8000b91e <__avr32_s32_to_f64>
80009d62:	14 98       	mov	r8,r10
80009d64:	16 99       	mov	r9,r11
80009d66:	fa ea 00 08 	ld.d	r10,sp[8]
80009d6a:	e0 a0 0c 6b 	rcall	8000b640 <__avr32_f64_sub>
80009d6e:	fa eb 00 08 	st.d	sp[8],r10
80009d72:	41 68       	lddsp	r8,sp[0x58]
80009d74:	2d 08       	sub	r8,-48
80009d76:	0a c8       	st.b	r5++,r8
80009d78:	41 3c       	lddsp	r12,sp[0x4c]
80009d7a:	18 35       	cp.w	r5,r12
80009d7c:	c2 81       	brne	80009dcc <_dtoa_r+0x61c>
80009d7e:	30 08       	mov	r8,0
80009d80:	fc 19 3f e0 	movh	r9,0x3fe0
80009d84:	fa ea 00 28 	ld.d	r10,sp[40]
80009d88:	e0 a0 0d 2a 	rcall	8000b7dc <__avr32_f64_add>
80009d8c:	40 85       	lddsp	r5,sp[0x20]
80009d8e:	fa e8 00 08 	ld.d	r8,sp[8]
80009d92:	08 05       	add	r5,r4
80009d94:	e0 a0 0e 7c 	rcall	8000ba8c <__avr32_f64_cmp_lt>
80009d98:	e0 81 00 99 	brne	80009eca <_dtoa_r+0x71a>
80009d9c:	fa e8 00 28 	ld.d	r8,sp[40]
80009da0:	30 0a       	mov	r10,0
80009da2:	fc 1b 3f e0 	movh	r11,0x3fe0
80009da6:	e0 a0 0c 4d 	rcall	8000b640 <__avr32_f64_sub>
80009daa:	14 98       	mov	r8,r10
80009dac:	16 99       	mov	r9,r11
80009dae:	fa ea 00 08 	ld.d	r10,sp[8]
80009db2:	e0 a0 0e 6d 	rcall	8000ba8c <__avr32_f64_cmp_lt>
80009db6:	c1 30       	breq	80009ddc <_dtoa_r+0x62c>
80009db8:	33 09       	mov	r9,48
80009dba:	0a 98       	mov	r8,r5
80009dbc:	11 7a       	ld.ub	r10,--r8
80009dbe:	f2 0a 18 00 	cp.b	r10,r9
80009dc2:	e0 81 02 d1 	brne	8000a364 <_dtoa_r+0xbb4>
80009dc6:	10 95       	mov	r5,r8
80009dc8:	cf 9b       	rjmp	80009dba <_dtoa_r+0x60a>
80009dca:	d7 03       	nop
80009dcc:	30 08       	mov	r8,0
80009dce:	fc 19 40 24 	movh	r9,0x4024
80009dd2:	e0 a0 0b 4b 	rcall	8000b468 <__avr32_f64_mul>
80009dd6:	fa eb 00 08 	st.d	sp[8],r10
80009dda:	cb db       	rjmp	80009d54 <_dtoa_r+0x5a4>
80009ddc:	fa ea 00 3c 	ld.d	r10,sp[60]
80009de0:	fa eb 00 08 	st.d	sp[8],r10
80009de4:	58 e6       	cp.w	r6,14
80009de6:	5f ab       	srle	r11
80009de8:	41 8a       	lddsp	r10,sp[0x60]
80009dea:	30 08       	mov	r8,0
80009dec:	f4 09 11 ff 	rsub	r9,r10,-1
80009df0:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009df4:	f0 09 18 00 	cp.b	r9,r8
80009df8:	e0 80 00 82 	breq	80009efc <_dtoa_r+0x74c>
80009dfc:	40 ea       	lddsp	r10,sp[0x38]
80009dfe:	58 01       	cp.w	r1,0
80009e00:	5f a9       	srle	r9
80009e02:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009e06:	fe ca c1 96 	sub	r10,pc,-15978
80009e0a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80009e0e:	fa e5 00 10 	st.d	sp[16],r4
80009e12:	f0 09 18 00 	cp.b	r9,r8
80009e16:	c1 40       	breq	80009e3e <_dtoa_r+0x68e>
80009e18:	58 01       	cp.w	r1,0
80009e1a:	e0 81 01 77 	brne	8000a108 <_dtoa_r+0x958>
80009e1e:	30 08       	mov	r8,0
80009e20:	fc 19 40 14 	movh	r9,0x4014
80009e24:	08 9a       	mov	r10,r4
80009e26:	0a 9b       	mov	r11,r5
80009e28:	e0 a0 0b 20 	rcall	8000b468 <__avr32_f64_mul>
80009e2c:	fa e8 00 08 	ld.d	r8,sp[8]
80009e30:	e0 a0 0d fa 	rcall	8000ba24 <__avr32_f64_cmp_ge>
80009e34:	e0 81 01 6a 	brne	8000a108 <_dtoa_r+0x958>
80009e38:	02 92       	mov	r2,r1
80009e3a:	e0 8f 01 72 	bral	8000a11e <_dtoa_r+0x96e>
80009e3e:	40 85       	lddsp	r5,sp[0x20]
80009e40:	30 14       	mov	r4,1
80009e42:	fa e8 00 10 	ld.d	r8,sp[16]
80009e46:	fa ea 00 08 	ld.d	r10,sp[8]
80009e4a:	e0 a0 0e 55 	rcall	8000baf4 <__avr32_f64_div>
80009e4e:	e0 a0 0d 51 	rcall	8000b8f0 <__avr32_f64_to_s32>
80009e52:	18 92       	mov	r2,r12
80009e54:	e0 a0 0d 65 	rcall	8000b91e <__avr32_s32_to_f64>
80009e58:	fa e8 00 10 	ld.d	r8,sp[16]
80009e5c:	e0 a0 0b 06 	rcall	8000b468 <__avr32_f64_mul>
80009e60:	14 98       	mov	r8,r10
80009e62:	16 99       	mov	r9,r11
80009e64:	fa ea 00 08 	ld.d	r10,sp[8]
80009e68:	e0 a0 0b ec 	rcall	8000b640 <__avr32_f64_sub>
80009e6c:	fa eb 00 08 	st.d	sp[8],r10
80009e70:	e4 c8 ff d0 	sub	r8,r2,-48
80009e74:	0a c8       	st.b	r5++,r8
80009e76:	fc 19 40 24 	movh	r9,0x4024
80009e7a:	30 08       	mov	r8,0
80009e7c:	02 34       	cp.w	r4,r1
80009e7e:	c3 31       	brne	80009ee4 <_dtoa_r+0x734>
80009e80:	fa e8 00 08 	ld.d	r8,sp[8]
80009e84:	e0 a0 0c ac 	rcall	8000b7dc <__avr32_f64_add>
80009e88:	16 91       	mov	r1,r11
80009e8a:	14 90       	mov	r0,r10
80009e8c:	14 98       	mov	r8,r10
80009e8e:	02 99       	mov	r9,r1
80009e90:	fa ea 00 10 	ld.d	r10,sp[16]
80009e94:	e0 a0 0d fc 	rcall	8000ba8c <__avr32_f64_cmp_lt>
80009e98:	c1 a1       	brne	80009ecc <_dtoa_r+0x71c>
80009e9a:	fa e8 00 10 	ld.d	r8,sp[16]
80009e9e:	00 9a       	mov	r10,r0
80009ea0:	02 9b       	mov	r11,r1
80009ea2:	e0 a0 0d ae 	rcall	8000b9fe <__avr32_f64_cmp_eq>
80009ea6:	e0 80 02 5e 	breq	8000a362 <_dtoa_r+0xbb2>
80009eaa:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009eae:	c0 f1       	brne	80009ecc <_dtoa_r+0x71c>
80009eb0:	e0 8f 02 59 	bral	8000a362 <_dtoa_r+0xbb2>
80009eb4:	40 8a       	lddsp	r10,sp[0x20]
80009eb6:	14 38       	cp.w	r8,r10
80009eb8:	c0 30       	breq	80009ebe <_dtoa_r+0x70e>
80009eba:	10 95       	mov	r5,r8
80009ebc:	c0 98       	rjmp	80009ece <_dtoa_r+0x71e>
80009ebe:	33 08       	mov	r8,48
80009ec0:	40 89       	lddsp	r9,sp[0x20]
80009ec2:	2f f6       	sub	r6,-1
80009ec4:	b2 88       	st.b	r9[0x0],r8
80009ec6:	40 88       	lddsp	r8,sp[0x20]
80009ec8:	c0 88       	rjmp	80009ed8 <_dtoa_r+0x728>
80009eca:	40 66       	lddsp	r6,sp[0x18]
80009ecc:	33 99       	mov	r9,57
80009ece:	0a 98       	mov	r8,r5
80009ed0:	11 7a       	ld.ub	r10,--r8
80009ed2:	f2 0a 18 00 	cp.b	r10,r9
80009ed6:	ce f0       	breq	80009eb4 <_dtoa_r+0x704>
80009ed8:	50 66       	stdsp	sp[0x18],r6
80009eda:	11 89       	ld.ub	r9,r8[0x0]
80009edc:	2f f9       	sub	r9,-1
80009ede:	b0 89       	st.b	r8[0x0],r9
80009ee0:	e0 8f 02 42 	bral	8000a364 <_dtoa_r+0xbb4>
80009ee4:	e0 a0 0a c2 	rcall	8000b468 <__avr32_f64_mul>
80009ee8:	2f f4       	sub	r4,-1
80009eea:	fa eb 00 08 	st.d	sp[8],r10
80009eee:	30 08       	mov	r8,0
80009ef0:	30 09       	mov	r9,0
80009ef2:	e0 a0 0d 86 	rcall	8000b9fe <__avr32_f64_cmp_eq>
80009ef6:	ca 60       	breq	80009e42 <_dtoa_r+0x692>
80009ef8:	e0 8f 02 35 	bral	8000a362 <_dtoa_r+0xbb2>
80009efc:	40 d8       	lddsp	r8,sp[0x34]
80009efe:	58 08       	cp.w	r8,0
80009f00:	c0 51       	brne	80009f0a <_dtoa_r+0x75a>
80009f02:	04 98       	mov	r8,r2
80009f04:	00 95       	mov	r5,r0
80009f06:	40 d4       	lddsp	r4,sp[0x34]
80009f08:	c3 78       	rjmp	80009f76 <_dtoa_r+0x7c6>
80009f0a:	40 c5       	lddsp	r5,sp[0x30]
80009f0c:	58 15       	cp.w	r5,1
80009f0e:	e0 89 00 0f 	brgt	80009f2c <_dtoa_r+0x77c>
80009f12:	41 74       	lddsp	r4,sp[0x5c]
80009f14:	58 04       	cp.w	r4,0
80009f16:	c0 40       	breq	80009f1e <_dtoa_r+0x76e>
80009f18:	f4 c9 fb cd 	sub	r9,r10,-1075
80009f1c:	c0 48       	rjmp	80009f24 <_dtoa_r+0x774>
80009f1e:	41 99       	lddsp	r9,sp[0x64]
80009f20:	f2 09 11 36 	rsub	r9,r9,54
80009f24:	04 98       	mov	r8,r2
80009f26:	00 95       	mov	r5,r0
80009f28:	c1 c8       	rjmp	80009f60 <_dtoa_r+0x7b0>
80009f2a:	d7 03       	nop
80009f2c:	e2 c8 00 01 	sub	r8,r1,1
80009f30:	58 01       	cp.w	r1,0
80009f32:	e0 05 17 40 	movge	r5,r0
80009f36:	e2 09 17 40 	movge	r9,r1
80009f3a:	e1 d1 e5 15 	sublt	r5,r0,r1
80009f3e:	f9 b9 05 00 	movlt	r9,0
80009f42:	10 32       	cp.w	r2,r8
80009f44:	e5 d8 e4 18 	subge	r8,r2,r8
80009f48:	f1 d2 e5 18 	sublt	r8,r8,r2
80009f4c:	e5 d8 e5 02 	addlt	r2,r2,r8
80009f50:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
80009f54:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009f58:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009f5c:	f9 b8 05 00 	movlt	r8,0
80009f60:	40 4b       	lddsp	r11,sp[0x10]
80009f62:	12 0b       	add	r11,r9
80009f64:	50 08       	stdsp	sp[0x0],r8
80009f66:	50 4b       	stdsp	sp[0x10],r11
80009f68:	12 00       	add	r0,r9
80009f6a:	30 1b       	mov	r11,1
80009f6c:	0e 9c       	mov	r12,r7
80009f6e:	e0 a0 08 a7 	rcall	8000b0bc <__i2b>
80009f72:	40 08       	lddsp	r8,sp[0x0]
80009f74:	18 94       	mov	r4,r12
80009f76:	40 4a       	lddsp	r10,sp[0x10]
80009f78:	58 05       	cp.w	r5,0
80009f7a:	5f 99       	srgt	r9
80009f7c:	58 0a       	cp.w	r10,0
80009f7e:	5f 9a       	srgt	r10
80009f80:	f5 e9 00 09 	and	r9,r10,r9
80009f84:	c0 80       	breq	80009f94 <_dtoa_r+0x7e4>
80009f86:	40 4c       	lddsp	r12,sp[0x10]
80009f88:	f8 05 0d 49 	min	r9,r12,r5
80009f8c:	12 1c       	sub	r12,r9
80009f8e:	12 10       	sub	r0,r9
80009f90:	50 4c       	stdsp	sp[0x10],r12
80009f92:	12 15       	sub	r5,r9
80009f94:	58 02       	cp.w	r2,0
80009f96:	e0 8a 00 27 	brle	80009fe4 <_dtoa_r+0x834>
80009f9a:	40 db       	lddsp	r11,sp[0x34]
80009f9c:	58 0b       	cp.w	r11,0
80009f9e:	c1 d0       	breq	80009fd8 <_dtoa_r+0x828>
80009fa0:	58 08       	cp.w	r8,0
80009fa2:	e0 8a 00 17 	brle	80009fd0 <_dtoa_r+0x820>
80009fa6:	10 9a       	mov	r10,r8
80009fa8:	50 08       	stdsp	sp[0x0],r8
80009faa:	08 9b       	mov	r11,r4
80009fac:	0e 9c       	mov	r12,r7
80009fae:	e0 a0 08 cd 	rcall	8000b148 <__pow5mult>
80009fb2:	06 9a       	mov	r10,r3
80009fb4:	18 9b       	mov	r11,r12
80009fb6:	18 94       	mov	r4,r12
80009fb8:	0e 9c       	mov	r12,r7
80009fba:	e0 a0 08 01 	rcall	8000afbc <__multiply>
80009fbe:	18 99       	mov	r9,r12
80009fc0:	06 9b       	mov	r11,r3
80009fc2:	50 19       	stdsp	sp[0x4],r9
80009fc4:	0e 9c       	mov	r12,r7
80009fc6:	e0 a0 06 ad 	rcall	8000ad20 <_Bfree>
80009fca:	40 19       	lddsp	r9,sp[0x4]
80009fcc:	40 08       	lddsp	r8,sp[0x0]
80009fce:	12 93       	mov	r3,r9
80009fd0:	e4 08 01 0a 	sub	r10,r2,r8
80009fd4:	c0 80       	breq	80009fe4 <_dtoa_r+0x834>
80009fd6:	c0 28       	rjmp	80009fda <_dtoa_r+0x82a>
80009fd8:	04 9a       	mov	r10,r2
80009fda:	06 9b       	mov	r11,r3
80009fdc:	0e 9c       	mov	r12,r7
80009fde:	e0 a0 08 b5 	rcall	8000b148 <__pow5mult>
80009fe2:	18 93       	mov	r3,r12
80009fe4:	30 1b       	mov	r11,1
80009fe6:	0e 9c       	mov	r12,r7
80009fe8:	e0 a0 08 6a 	rcall	8000b0bc <__i2b>
80009fec:	41 1a       	lddsp	r10,sp[0x44]
80009fee:	18 92       	mov	r2,r12
80009ff0:	58 0a       	cp.w	r10,0
80009ff2:	e0 8a 00 07 	brle	8000a000 <_dtoa_r+0x850>
80009ff6:	18 9b       	mov	r11,r12
80009ff8:	0e 9c       	mov	r12,r7
80009ffa:	e0 a0 08 a7 	rcall	8000b148 <__pow5mult>
80009ffe:	18 92       	mov	r2,r12
8000a000:	40 c9       	lddsp	r9,sp[0x30]
8000a002:	58 19       	cp.w	r9,1
8000a004:	e0 89 00 14 	brgt	8000a02c <_dtoa_r+0x87c>
8000a008:	40 38       	lddsp	r8,sp[0xc]
8000a00a:	58 08       	cp.w	r8,0
8000a00c:	c1 01       	brne	8000a02c <_dtoa_r+0x87c>
8000a00e:	40 29       	lddsp	r9,sp[0x8]
8000a010:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a014:	c0 c1       	brne	8000a02c <_dtoa_r+0x87c>
8000a016:	12 98       	mov	r8,r9
8000a018:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a01c:	c0 80       	breq	8000a02c <_dtoa_r+0x87c>
8000a01e:	40 4c       	lddsp	r12,sp[0x10]
8000a020:	30 1b       	mov	r11,1
8000a022:	2f fc       	sub	r12,-1
8000a024:	2f f0       	sub	r0,-1
8000a026:	50 4c       	stdsp	sp[0x10],r12
8000a028:	50 6b       	stdsp	sp[0x18],r11
8000a02a:	c0 38       	rjmp	8000a030 <_dtoa_r+0x880>
8000a02c:	30 0a       	mov	r10,0
8000a02e:	50 6a       	stdsp	sp[0x18],r10
8000a030:	41 19       	lddsp	r9,sp[0x44]
8000a032:	58 09       	cp.w	r9,0
8000a034:	c0 31       	brne	8000a03a <_dtoa_r+0x88a>
8000a036:	30 1c       	mov	r12,1
8000a038:	c0 98       	rjmp	8000a04a <_dtoa_r+0x89a>
8000a03a:	64 48       	ld.w	r8,r2[0x10]
8000a03c:	2f c8       	sub	r8,-4
8000a03e:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a042:	e0 a0 05 df 	rcall	8000ac00 <__hi0bits>
8000a046:	f8 0c 11 20 	rsub	r12,r12,32
8000a04a:	40 4b       	lddsp	r11,sp[0x10]
8000a04c:	f8 0b 00 08 	add	r8,r12,r11
8000a050:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a054:	c0 c0       	breq	8000a06c <_dtoa_r+0x8bc>
8000a056:	f0 08 11 20 	rsub	r8,r8,32
8000a05a:	58 48       	cp.w	r8,4
8000a05c:	e0 8a 00 06 	brle	8000a068 <_dtoa_r+0x8b8>
8000a060:	20 48       	sub	r8,4
8000a062:	10 0b       	add	r11,r8
8000a064:	50 4b       	stdsp	sp[0x10],r11
8000a066:	c0 78       	rjmp	8000a074 <_dtoa_r+0x8c4>
8000a068:	58 48       	cp.w	r8,4
8000a06a:	c0 70       	breq	8000a078 <_dtoa_r+0x8c8>
8000a06c:	40 4a       	lddsp	r10,sp[0x10]
8000a06e:	2e 48       	sub	r8,-28
8000a070:	10 0a       	add	r10,r8
8000a072:	50 4a       	stdsp	sp[0x10],r10
8000a074:	10 00       	add	r0,r8
8000a076:	10 05       	add	r5,r8
8000a078:	58 00       	cp.w	r0,0
8000a07a:	e0 8a 00 08 	brle	8000a08a <_dtoa_r+0x8da>
8000a07e:	06 9b       	mov	r11,r3
8000a080:	00 9a       	mov	r10,r0
8000a082:	0e 9c       	mov	r12,r7
8000a084:	e0 a0 07 58 	rcall	8000af34 <__lshift>
8000a088:	18 93       	mov	r3,r12
8000a08a:	40 49       	lddsp	r9,sp[0x10]
8000a08c:	58 09       	cp.w	r9,0
8000a08e:	e0 8a 00 08 	brle	8000a09e <_dtoa_r+0x8ee>
8000a092:	04 9b       	mov	r11,r2
8000a094:	12 9a       	mov	r10,r9
8000a096:	0e 9c       	mov	r12,r7
8000a098:	e0 a0 07 4e 	rcall	8000af34 <__lshift>
8000a09c:	18 92       	mov	r2,r12
8000a09e:	41 48       	lddsp	r8,sp[0x50]
8000a0a0:	58 08       	cp.w	r8,0
8000a0a2:	c1 b0       	breq	8000a0d8 <_dtoa_r+0x928>
8000a0a4:	04 9b       	mov	r11,r2
8000a0a6:	06 9c       	mov	r12,r3
8000a0a8:	e0 a0 06 23 	rcall	8000acee <__mcmp>
8000a0ac:	c1 64       	brge	8000a0d8 <_dtoa_r+0x928>
8000a0ae:	06 9b       	mov	r11,r3
8000a0b0:	30 09       	mov	r9,0
8000a0b2:	30 aa       	mov	r10,10
8000a0b4:	0e 9c       	mov	r12,r7
8000a0b6:	e0 a0 08 0b 	rcall	8000b0cc <__multadd>
8000a0ba:	20 16       	sub	r6,1
8000a0bc:	18 93       	mov	r3,r12
8000a0be:	40 dc       	lddsp	r12,sp[0x34]
8000a0c0:	58 0c       	cp.w	r12,0
8000a0c2:	c0 31       	brne	8000a0c8 <_dtoa_r+0x918>
8000a0c4:	40 91       	lddsp	r1,sp[0x24]
8000a0c6:	c0 98       	rjmp	8000a0d8 <_dtoa_r+0x928>
8000a0c8:	08 9b       	mov	r11,r4
8000a0ca:	40 91       	lddsp	r1,sp[0x24]
8000a0cc:	30 09       	mov	r9,0
8000a0ce:	30 aa       	mov	r10,10
8000a0d0:	0e 9c       	mov	r12,r7
8000a0d2:	e0 a0 07 fd 	rcall	8000b0cc <__multadd>
8000a0d6:	18 94       	mov	r4,r12
8000a0d8:	58 01       	cp.w	r1,0
8000a0da:	5f a9       	srle	r9
8000a0dc:	40 cb       	lddsp	r11,sp[0x30]
8000a0de:	58 2b       	cp.w	r11,2
8000a0e0:	5f 98       	srgt	r8
8000a0e2:	f3 e8 00 08 	and	r8,r9,r8
8000a0e6:	c2 50       	breq	8000a130 <_dtoa_r+0x980>
8000a0e8:	58 01       	cp.w	r1,0
8000a0ea:	c1 11       	brne	8000a10c <_dtoa_r+0x95c>
8000a0ec:	04 9b       	mov	r11,r2
8000a0ee:	02 99       	mov	r9,r1
8000a0f0:	30 5a       	mov	r10,5
8000a0f2:	0e 9c       	mov	r12,r7
8000a0f4:	e0 a0 07 ec 	rcall	8000b0cc <__multadd>
8000a0f8:	18 92       	mov	r2,r12
8000a0fa:	18 9b       	mov	r11,r12
8000a0fc:	06 9c       	mov	r12,r3
8000a0fe:	e0 a0 05 f8 	rcall	8000acee <__mcmp>
8000a102:	e0 89 00 0f 	brgt	8000a120 <_dtoa_r+0x970>
8000a106:	c0 38       	rjmp	8000a10c <_dtoa_r+0x95c>
8000a108:	30 02       	mov	r2,0
8000a10a:	04 94       	mov	r4,r2
8000a10c:	40 ea       	lddsp	r10,sp[0x38]
8000a10e:	30 09       	mov	r9,0
8000a110:	5c da       	com	r10
8000a112:	40 85       	lddsp	r5,sp[0x20]
8000a114:	50 6a       	stdsp	sp[0x18],r10
8000a116:	50 49       	stdsp	sp[0x10],r9
8000a118:	c0 f9       	rjmp	8000a336 <_dtoa_r+0xb86>
8000a11a:	08 92       	mov	r2,r4
8000a11c:	40 66       	lddsp	r6,sp[0x18]
8000a11e:	04 94       	mov	r4,r2
8000a120:	2f f6       	sub	r6,-1
8000a122:	50 66       	stdsp	sp[0x18],r6
8000a124:	33 18       	mov	r8,49
8000a126:	40 85       	lddsp	r5,sp[0x20]
8000a128:	0a c8       	st.b	r5++,r8
8000a12a:	30 08       	mov	r8,0
8000a12c:	50 48       	stdsp	sp[0x10],r8
8000a12e:	c0 49       	rjmp	8000a336 <_dtoa_r+0xb86>
8000a130:	40 dc       	lddsp	r12,sp[0x34]
8000a132:	58 0c       	cp.w	r12,0
8000a134:	e0 80 00 b5 	breq	8000a29e <_dtoa_r+0xaee>
8000a138:	58 05       	cp.w	r5,0
8000a13a:	e0 8a 00 08 	brle	8000a14a <_dtoa_r+0x99a>
8000a13e:	08 9b       	mov	r11,r4
8000a140:	0a 9a       	mov	r10,r5
8000a142:	0e 9c       	mov	r12,r7
8000a144:	e0 a0 06 f8 	rcall	8000af34 <__lshift>
8000a148:	18 94       	mov	r4,r12
8000a14a:	40 6b       	lddsp	r11,sp[0x18]
8000a14c:	58 0b       	cp.w	r11,0
8000a14e:	c0 31       	brne	8000a154 <_dtoa_r+0x9a4>
8000a150:	08 9c       	mov	r12,r4
8000a152:	c1 38       	rjmp	8000a178 <_dtoa_r+0x9c8>
8000a154:	68 1b       	ld.w	r11,r4[0x4]
8000a156:	0e 9c       	mov	r12,r7
8000a158:	e0 a0 05 fe 	rcall	8000ad54 <_Balloc>
8000a15c:	68 4a       	ld.w	r10,r4[0x10]
8000a15e:	18 95       	mov	r5,r12
8000a160:	e8 cb ff f4 	sub	r11,r4,-12
8000a164:	2f ea       	sub	r10,-2
8000a166:	2f 4c       	sub	r12,-12
8000a168:	a3 6a       	lsl	r10,0x2
8000a16a:	fe b0 e6 43 	rcall	80006df0 <memcpy>
8000a16e:	0a 9b       	mov	r11,r5
8000a170:	30 1a       	mov	r10,1
8000a172:	0e 9c       	mov	r12,r7
8000a174:	e0 a0 06 e0 	rcall	8000af34 <__lshift>
8000a178:	50 44       	stdsp	sp[0x10],r4
8000a17a:	40 3a       	lddsp	r10,sp[0xc]
8000a17c:	30 19       	mov	r9,1
8000a17e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a182:	18 94       	mov	r4,r12
8000a184:	50 da       	stdsp	sp[0x34],r10
8000a186:	40 85       	lddsp	r5,sp[0x20]
8000a188:	50 99       	stdsp	sp[0x24],r9
8000a18a:	50 26       	stdsp	sp[0x8],r6
8000a18c:	50 e1       	stdsp	sp[0x38],r1
8000a18e:	04 9b       	mov	r11,r2
8000a190:	06 9c       	mov	r12,r3
8000a192:	fe b0 fa 7f 	rcall	80009690 <quorem>
8000a196:	40 4b       	lddsp	r11,sp[0x10]
8000a198:	f8 c0 ff d0 	sub	r0,r12,-48
8000a19c:	06 9c       	mov	r12,r3
8000a19e:	e0 a0 05 a8 	rcall	8000acee <__mcmp>
8000a1a2:	08 9a       	mov	r10,r4
8000a1a4:	50 6c       	stdsp	sp[0x18],r12
8000a1a6:	04 9b       	mov	r11,r2
8000a1a8:	0e 9c       	mov	r12,r7
8000a1aa:	e0 a0 06 5d 	rcall	8000ae64 <__mdiff>
8000a1ae:	18 91       	mov	r1,r12
8000a1b0:	78 38       	ld.w	r8,r12[0xc]
8000a1b2:	58 08       	cp.w	r8,0
8000a1b4:	c0 30       	breq	8000a1ba <_dtoa_r+0xa0a>
8000a1b6:	30 16       	mov	r6,1
8000a1b8:	c0 68       	rjmp	8000a1c4 <_dtoa_r+0xa14>
8000a1ba:	18 9b       	mov	r11,r12
8000a1bc:	06 9c       	mov	r12,r3
8000a1be:	e0 a0 05 98 	rcall	8000acee <__mcmp>
8000a1c2:	18 96       	mov	r6,r12
8000a1c4:	0e 9c       	mov	r12,r7
8000a1c6:	02 9b       	mov	r11,r1
8000a1c8:	e0 a0 05 ac 	rcall	8000ad20 <_Bfree>
8000a1cc:	40 cc       	lddsp	r12,sp[0x30]
8000a1ce:	ed ec 10 08 	or	r8,r6,r12
8000a1d2:	c0 d1       	brne	8000a1ec <_dtoa_r+0xa3c>
8000a1d4:	40 db       	lddsp	r11,sp[0x34]
8000a1d6:	58 0b       	cp.w	r11,0
8000a1d8:	c0 a1       	brne	8000a1ec <_dtoa_r+0xa3c>
8000a1da:	40 26       	lddsp	r6,sp[0x8]
8000a1dc:	e0 40 00 39 	cp.w	r0,57
8000a1e0:	c3 00       	breq	8000a240 <_dtoa_r+0xa90>
8000a1e2:	40 6a       	lddsp	r10,sp[0x18]
8000a1e4:	58 0a       	cp.w	r10,0
8000a1e6:	e0 89 00 24 	brgt	8000a22e <_dtoa_r+0xa7e>
8000a1ea:	c2 f8       	rjmp	8000a248 <_dtoa_r+0xa98>
8000a1ec:	40 69       	lddsp	r9,sp[0x18]
8000a1ee:	58 09       	cp.w	r9,0
8000a1f0:	c0 85       	brlt	8000a200 <_dtoa_r+0xa50>
8000a1f2:	12 98       	mov	r8,r9
8000a1f4:	40 cc       	lddsp	r12,sp[0x30]
8000a1f6:	18 48       	or	r8,r12
8000a1f8:	c1 d1       	brne	8000a232 <_dtoa_r+0xa82>
8000a1fa:	40 db       	lddsp	r11,sp[0x34]
8000a1fc:	58 0b       	cp.w	r11,0
8000a1fe:	c1 a1       	brne	8000a232 <_dtoa_r+0xa82>
8000a200:	0c 99       	mov	r9,r6
8000a202:	40 26       	lddsp	r6,sp[0x8]
8000a204:	58 09       	cp.w	r9,0
8000a206:	e0 8a 00 21 	brle	8000a248 <_dtoa_r+0xa98>
8000a20a:	06 9b       	mov	r11,r3
8000a20c:	30 1a       	mov	r10,1
8000a20e:	0e 9c       	mov	r12,r7
8000a210:	e0 a0 06 92 	rcall	8000af34 <__lshift>
8000a214:	04 9b       	mov	r11,r2
8000a216:	18 93       	mov	r3,r12
8000a218:	e0 a0 05 6b 	rcall	8000acee <__mcmp>
8000a21c:	e0 89 00 06 	brgt	8000a228 <_dtoa_r+0xa78>
8000a220:	c1 41       	brne	8000a248 <_dtoa_r+0xa98>
8000a222:	ed b0 00 00 	bld	r0,0x0
8000a226:	c1 11       	brne	8000a248 <_dtoa_r+0xa98>
8000a228:	e0 40 00 39 	cp.w	r0,57
8000a22c:	c0 a0       	breq	8000a240 <_dtoa_r+0xa90>
8000a22e:	2f f0       	sub	r0,-1
8000a230:	c0 c8       	rjmp	8000a248 <_dtoa_r+0xa98>
8000a232:	58 06       	cp.w	r6,0
8000a234:	e0 8a 00 0c 	brle	8000a24c <_dtoa_r+0xa9c>
8000a238:	40 26       	lddsp	r6,sp[0x8]
8000a23a:	e0 40 00 39 	cp.w	r0,57
8000a23e:	c0 41       	brne	8000a246 <_dtoa_r+0xa96>
8000a240:	33 98       	mov	r8,57
8000a242:	0a c8       	st.b	r5++,r8
8000a244:	c6 78       	rjmp	8000a312 <_dtoa_r+0xb62>
8000a246:	2f f0       	sub	r0,-1
8000a248:	0a c0       	st.b	r5++,r0
8000a24a:	c7 58       	rjmp	8000a334 <_dtoa_r+0xb84>
8000a24c:	0a c0       	st.b	r5++,r0
8000a24e:	40 9a       	lddsp	r10,sp[0x24]
8000a250:	40 e9       	lddsp	r9,sp[0x38]
8000a252:	12 3a       	cp.w	r10,r9
8000a254:	c4 30       	breq	8000a2da <_dtoa_r+0xb2a>
8000a256:	06 9b       	mov	r11,r3
8000a258:	30 09       	mov	r9,0
8000a25a:	30 aa       	mov	r10,10
8000a25c:	0e 9c       	mov	r12,r7
8000a25e:	e0 a0 07 37 	rcall	8000b0cc <__multadd>
8000a262:	40 48       	lddsp	r8,sp[0x10]
8000a264:	18 93       	mov	r3,r12
8000a266:	08 38       	cp.w	r8,r4
8000a268:	c0 91       	brne	8000a27a <_dtoa_r+0xaca>
8000a26a:	10 9b       	mov	r11,r8
8000a26c:	30 09       	mov	r9,0
8000a26e:	30 aa       	mov	r10,10
8000a270:	0e 9c       	mov	r12,r7
8000a272:	e0 a0 07 2d 	rcall	8000b0cc <__multadd>
8000a276:	50 4c       	stdsp	sp[0x10],r12
8000a278:	c0 e8       	rjmp	8000a294 <_dtoa_r+0xae4>
8000a27a:	40 4b       	lddsp	r11,sp[0x10]
8000a27c:	30 09       	mov	r9,0
8000a27e:	30 aa       	mov	r10,10
8000a280:	0e 9c       	mov	r12,r7
8000a282:	e0 a0 07 25 	rcall	8000b0cc <__multadd>
8000a286:	08 9b       	mov	r11,r4
8000a288:	50 4c       	stdsp	sp[0x10],r12
8000a28a:	30 09       	mov	r9,0
8000a28c:	30 aa       	mov	r10,10
8000a28e:	0e 9c       	mov	r12,r7
8000a290:	e0 a0 07 1e 	rcall	8000b0cc <__multadd>
8000a294:	18 94       	mov	r4,r12
8000a296:	40 9c       	lddsp	r12,sp[0x24]
8000a298:	2f fc       	sub	r12,-1
8000a29a:	50 9c       	stdsp	sp[0x24],r12
8000a29c:	c7 9b       	rjmp	8000a18e <_dtoa_r+0x9de>
8000a29e:	30 18       	mov	r8,1
8000a2a0:	06 90       	mov	r0,r3
8000a2a2:	40 85       	lddsp	r5,sp[0x20]
8000a2a4:	08 93       	mov	r3,r4
8000a2a6:	0c 94       	mov	r4,r6
8000a2a8:	10 96       	mov	r6,r8
8000a2aa:	04 9b       	mov	r11,r2
8000a2ac:	00 9c       	mov	r12,r0
8000a2ae:	fe b0 f9 f1 	rcall	80009690 <quorem>
8000a2b2:	2d 0c       	sub	r12,-48
8000a2b4:	0a cc       	st.b	r5++,r12
8000a2b6:	02 36       	cp.w	r6,r1
8000a2b8:	c0 a4       	brge	8000a2cc <_dtoa_r+0xb1c>
8000a2ba:	00 9b       	mov	r11,r0
8000a2bc:	30 09       	mov	r9,0
8000a2be:	30 aa       	mov	r10,10
8000a2c0:	0e 9c       	mov	r12,r7
8000a2c2:	2f f6       	sub	r6,-1
8000a2c4:	e0 a0 07 04 	rcall	8000b0cc <__multadd>
8000a2c8:	18 90       	mov	r0,r12
8000a2ca:	cf 0b       	rjmp	8000a2aa <_dtoa_r+0xafa>
8000a2cc:	08 96       	mov	r6,r4
8000a2ce:	30 0b       	mov	r11,0
8000a2d0:	06 94       	mov	r4,r3
8000a2d2:	50 4b       	stdsp	sp[0x10],r11
8000a2d4:	00 93       	mov	r3,r0
8000a2d6:	18 90       	mov	r0,r12
8000a2d8:	c0 28       	rjmp	8000a2dc <_dtoa_r+0xb2c>
8000a2da:	40 26       	lddsp	r6,sp[0x8]
8000a2dc:	06 9b       	mov	r11,r3
8000a2de:	30 1a       	mov	r10,1
8000a2e0:	0e 9c       	mov	r12,r7
8000a2e2:	e0 a0 06 29 	rcall	8000af34 <__lshift>
8000a2e6:	04 9b       	mov	r11,r2
8000a2e8:	18 93       	mov	r3,r12
8000a2ea:	e0 a0 05 02 	rcall	8000acee <__mcmp>
8000a2ee:	e0 89 00 12 	brgt	8000a312 <_dtoa_r+0xb62>
8000a2f2:	c1 b1       	brne	8000a328 <_dtoa_r+0xb78>
8000a2f4:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000a2f8:	c0 d1       	brne	8000a312 <_dtoa_r+0xb62>
8000a2fa:	c1 78       	rjmp	8000a328 <_dtoa_r+0xb78>
8000a2fc:	40 89       	lddsp	r9,sp[0x20]
8000a2fe:	12 38       	cp.w	r8,r9
8000a300:	c0 30       	breq	8000a306 <_dtoa_r+0xb56>
8000a302:	10 95       	mov	r5,r8
8000a304:	c0 88       	rjmp	8000a314 <_dtoa_r+0xb64>
8000a306:	2f f6       	sub	r6,-1
8000a308:	50 66       	stdsp	sp[0x18],r6
8000a30a:	33 18       	mov	r8,49
8000a30c:	40 8c       	lddsp	r12,sp[0x20]
8000a30e:	b8 88       	st.b	r12[0x0],r8
8000a310:	c1 38       	rjmp	8000a336 <_dtoa_r+0xb86>
8000a312:	33 9a       	mov	r10,57
8000a314:	0a 98       	mov	r8,r5
8000a316:	11 79       	ld.ub	r9,--r8
8000a318:	f4 09 18 00 	cp.b	r9,r10
8000a31c:	cf 00       	breq	8000a2fc <_dtoa_r+0xb4c>
8000a31e:	2f f9       	sub	r9,-1
8000a320:	b0 89       	st.b	r8[0x0],r9
8000a322:	c0 98       	rjmp	8000a334 <_dtoa_r+0xb84>
8000a324:	10 95       	mov	r5,r8
8000a326:	c0 28       	rjmp	8000a32a <_dtoa_r+0xb7a>
8000a328:	33 09       	mov	r9,48
8000a32a:	0a 98       	mov	r8,r5
8000a32c:	11 7a       	ld.ub	r10,--r8
8000a32e:	f2 0a 18 00 	cp.b	r10,r9
8000a332:	cf 90       	breq	8000a324 <_dtoa_r+0xb74>
8000a334:	50 66       	stdsp	sp[0x18],r6
8000a336:	04 9b       	mov	r11,r2
8000a338:	0e 9c       	mov	r12,r7
8000a33a:	e0 a0 04 f3 	rcall	8000ad20 <_Bfree>
8000a33e:	58 04       	cp.w	r4,0
8000a340:	c1 20       	breq	8000a364 <_dtoa_r+0xbb4>
8000a342:	40 4b       	lddsp	r11,sp[0x10]
8000a344:	08 3b       	cp.w	r11,r4
8000a346:	5f 19       	srne	r9
8000a348:	58 0b       	cp.w	r11,0
8000a34a:	5f 18       	srne	r8
8000a34c:	f3 e8 00 08 	and	r8,r9,r8
8000a350:	c0 40       	breq	8000a358 <_dtoa_r+0xba8>
8000a352:	0e 9c       	mov	r12,r7
8000a354:	e0 a0 04 e6 	rcall	8000ad20 <_Bfree>
8000a358:	08 9b       	mov	r11,r4
8000a35a:	0e 9c       	mov	r12,r7
8000a35c:	e0 a0 04 e2 	rcall	8000ad20 <_Bfree>
8000a360:	c0 28       	rjmp	8000a364 <_dtoa_r+0xbb4>
8000a362:	50 66       	stdsp	sp[0x18],r6
8000a364:	0e 9c       	mov	r12,r7
8000a366:	06 9b       	mov	r11,r3
8000a368:	e0 a0 04 dc 	rcall	8000ad20 <_Bfree>
8000a36c:	30 08       	mov	r8,0
8000a36e:	aa 88       	st.b	r5[0x0],r8
8000a370:	40 68       	lddsp	r8,sp[0x18]
8000a372:	41 5a       	lddsp	r10,sp[0x54]
8000a374:	2f f8       	sub	r8,-1
8000a376:	41 29       	lddsp	r9,sp[0x48]
8000a378:	95 08       	st.w	r10[0x0],r8
8000a37a:	40 8c       	lddsp	r12,sp[0x20]
8000a37c:	58 09       	cp.w	r9,0
8000a37e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000a382:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000a386:	2e 6d       	sub	sp,-104
8000a388:	d8 32       	popm	r0-r7,pc
8000a38a:	d7 03       	nop

8000a38c <__errno>:
8000a38c:	e0 68 0a 38 	mov	r8,2616
8000a390:	70 0c       	ld.w	r12,r8[0x0]
8000a392:	2f 4c       	sub	r12,-12
8000a394:	5e fc       	retal	r12
8000a396:	d7 03       	nop

8000a398 <_fflush_r>:
8000a398:	d4 21       	pushm	r4-r7,lr
8000a39a:	16 97       	mov	r7,r11
8000a39c:	18 96       	mov	r6,r12
8000a39e:	76 48       	ld.w	r8,r11[0x10]
8000a3a0:	58 08       	cp.w	r8,0
8000a3a2:	c7 f0       	breq	8000a4a0 <_fflush_r+0x108>
8000a3a4:	58 0c       	cp.w	r12,0
8000a3a6:	c0 50       	breq	8000a3b0 <_fflush_r+0x18>
8000a3a8:	78 68       	ld.w	r8,r12[0x18]
8000a3aa:	58 08       	cp.w	r8,0
8000a3ac:	c0 21       	brne	8000a3b0 <_fflush_r+0x18>
8000a3ae:	cc dc       	rcall	8000a548 <__sinit>
8000a3b0:	fe c8 c7 f0 	sub	r8,pc,-14352
8000a3b4:	10 37       	cp.w	r7,r8
8000a3b6:	c0 31       	brne	8000a3bc <_fflush_r+0x24>
8000a3b8:	6c 07       	ld.w	r7,r6[0x0]
8000a3ba:	c0 c8       	rjmp	8000a3d2 <_fflush_r+0x3a>
8000a3bc:	fe c8 c7 dc 	sub	r8,pc,-14372
8000a3c0:	10 37       	cp.w	r7,r8
8000a3c2:	c0 31       	brne	8000a3c8 <_fflush_r+0x30>
8000a3c4:	6c 17       	ld.w	r7,r6[0x4]
8000a3c6:	c0 68       	rjmp	8000a3d2 <_fflush_r+0x3a>
8000a3c8:	fe c8 c7 c8 	sub	r8,pc,-14392
8000a3cc:	10 37       	cp.w	r7,r8
8000a3ce:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000a3d2:	8e 6a       	ld.sh	r10,r7[0xc]
8000a3d4:	14 98       	mov	r8,r10
8000a3d6:	ed ba 00 03 	bld	r10,0x3
8000a3da:	c4 20       	breq	8000a45e <_fflush_r+0xc6>
8000a3dc:	ab ba       	sbr	r10,0xb
8000a3de:	ae 6a       	st.h	r7[0xc],r10
8000a3e0:	6e 18       	ld.w	r8,r7[0x4]
8000a3e2:	58 08       	cp.w	r8,0
8000a3e4:	e0 89 00 06 	brgt	8000a3f0 <_fflush_r+0x58>
8000a3e8:	6f 08       	ld.w	r8,r7[0x40]
8000a3ea:	58 08       	cp.w	r8,0
8000a3ec:	e0 8a 00 5a 	brle	8000a4a0 <_fflush_r+0x108>
8000a3f0:	6e b8       	ld.w	r8,r7[0x2c]
8000a3f2:	58 08       	cp.w	r8,0
8000a3f4:	c5 60       	breq	8000a4a0 <_fflush_r+0x108>
8000a3f6:	e2 1a 10 00 	andl	r10,0x1000,COH
8000a3fa:	c0 30       	breq	8000a400 <_fflush_r+0x68>
8000a3fc:	6f 55       	ld.w	r5,r7[0x54]
8000a3fe:	c0 f8       	rjmp	8000a41c <_fflush_r+0x84>
8000a400:	30 19       	mov	r9,1
8000a402:	6e 8b       	ld.w	r11,r7[0x20]
8000a404:	0c 9c       	mov	r12,r6
8000a406:	5d 18       	icall	r8
8000a408:	18 95       	mov	r5,r12
8000a40a:	5b fc       	cp.w	r12,-1
8000a40c:	c0 81       	brne	8000a41c <_fflush_r+0x84>
8000a40e:	6c 38       	ld.w	r8,r6[0xc]
8000a410:	59 d8       	cp.w	r8,29
8000a412:	c4 70       	breq	8000a4a0 <_fflush_r+0x108>
8000a414:	8e 68       	ld.sh	r8,r7[0xc]
8000a416:	a7 a8       	sbr	r8,0x6
8000a418:	ae 68       	st.h	r7[0xc],r8
8000a41a:	d8 22       	popm	r4-r7,pc
8000a41c:	8e 68       	ld.sh	r8,r7[0xc]
8000a41e:	ed b8 00 02 	bld	r8,0x2
8000a422:	c0 91       	brne	8000a434 <_fflush_r+0x9c>
8000a424:	6e 18       	ld.w	r8,r7[0x4]
8000a426:	10 15       	sub	r5,r8
8000a428:	6e d8       	ld.w	r8,r7[0x34]
8000a42a:	58 08       	cp.w	r8,0
8000a42c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000a430:	eb d8 e1 15 	subne	r5,r5,r8
8000a434:	6e b8       	ld.w	r8,r7[0x2c]
8000a436:	0c 9c       	mov	r12,r6
8000a438:	30 09       	mov	r9,0
8000a43a:	0a 9a       	mov	r10,r5
8000a43c:	6e 8b       	ld.w	r11,r7[0x20]
8000a43e:	5d 18       	icall	r8
8000a440:	8e 68       	ld.sh	r8,r7[0xc]
8000a442:	0a 3c       	cp.w	r12,r5
8000a444:	c2 61       	brne	8000a490 <_fflush_r+0xf8>
8000a446:	ab d8       	cbr	r8,0xb
8000a448:	30 0c       	mov	r12,0
8000a44a:	6e 49       	ld.w	r9,r7[0x10]
8000a44c:	ae 68       	st.h	r7[0xc],r8
8000a44e:	8f 1c       	st.w	r7[0x4],r12
8000a450:	8f 09       	st.w	r7[0x0],r9
8000a452:	ed b8 00 0c 	bld	r8,0xc
8000a456:	c2 51       	brne	8000a4a0 <_fflush_r+0x108>
8000a458:	ef 45 00 54 	st.w	r7[84],r5
8000a45c:	d8 22       	popm	r4-r7,pc
8000a45e:	6e 45       	ld.w	r5,r7[0x10]
8000a460:	58 05       	cp.w	r5,0
8000a462:	c1 f0       	breq	8000a4a0 <_fflush_r+0x108>
8000a464:	6e 04       	ld.w	r4,r7[0x0]
8000a466:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000a46a:	8f 05       	st.w	r7[0x0],r5
8000a46c:	f9 b8 01 00 	movne	r8,0
8000a470:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000a474:	0a 14       	sub	r4,r5
8000a476:	8f 28       	st.w	r7[0x8],r8
8000a478:	c1 18       	rjmp	8000a49a <_fflush_r+0x102>
8000a47a:	08 99       	mov	r9,r4
8000a47c:	0a 9a       	mov	r10,r5
8000a47e:	6e a8       	ld.w	r8,r7[0x28]
8000a480:	6e 8b       	ld.w	r11,r7[0x20]
8000a482:	0c 9c       	mov	r12,r6
8000a484:	5d 18       	icall	r8
8000a486:	18 14       	sub	r4,r12
8000a488:	58 0c       	cp.w	r12,0
8000a48a:	e0 89 00 07 	brgt	8000a498 <_fflush_r+0x100>
8000a48e:	8e 68       	ld.sh	r8,r7[0xc]
8000a490:	a7 a8       	sbr	r8,0x6
8000a492:	3f fc       	mov	r12,-1
8000a494:	ae 68       	st.h	r7[0xc],r8
8000a496:	d8 22       	popm	r4-r7,pc
8000a498:	18 05       	add	r5,r12
8000a49a:	58 04       	cp.w	r4,0
8000a49c:	fe 99 ff ef 	brgt	8000a47a <_fflush_r+0xe2>
8000a4a0:	d8 2a       	popm	r4-r7,pc,r12=0
8000a4a2:	d7 03       	nop

8000a4a4 <__sfp_lock_acquire>:
8000a4a4:	5e fc       	retal	r12

8000a4a6 <__sfp_lock_release>:
8000a4a6:	5e fc       	retal	r12

8000a4a8 <_cleanup_r>:
8000a4a8:	d4 01       	pushm	lr
8000a4aa:	fe cb f0 c6 	sub	r11,pc,-3898
8000a4ae:	e0 a0 02 f7 	rcall	8000aa9c <_fwalk>
8000a4b2:	d8 02       	popm	pc

8000a4b4 <__sfmoreglue>:
8000a4b4:	d4 21       	pushm	r4-r7,lr
8000a4b6:	16 95       	mov	r5,r11
8000a4b8:	f6 06 10 5c 	mul	r6,r11,92
8000a4bc:	ec cb ff f4 	sub	r11,r6,-12
8000a4c0:	fe b0 e2 7c 	rcall	800069b8 <_malloc_r>
8000a4c4:	18 97       	mov	r7,r12
8000a4c6:	c0 90       	breq	8000a4d8 <__sfmoreglue+0x24>
8000a4c8:	99 15       	st.w	r12[0x4],r5
8000a4ca:	30 0b       	mov	r11,0
8000a4cc:	2f 4c       	sub	r12,-12
8000a4ce:	0c 9a       	mov	r10,r6
8000a4d0:	8f 2c       	st.w	r7[0x8],r12
8000a4d2:	8f 0b       	st.w	r7[0x0],r11
8000a4d4:	fe b0 e5 32 	rcall	80006f38 <memset>
8000a4d8:	0e 9c       	mov	r12,r7
8000a4da:	d8 22       	popm	r4-r7,pc

8000a4dc <__sfp>:
8000a4dc:	d4 21       	pushm	r4-r7,lr
8000a4de:	fe c8 c8 ba 	sub	r8,pc,-14150
8000a4e2:	18 96       	mov	r6,r12
8000a4e4:	70 07       	ld.w	r7,r8[0x0]
8000a4e6:	6e 68       	ld.w	r8,r7[0x18]
8000a4e8:	58 08       	cp.w	r8,0
8000a4ea:	c0 31       	brne	8000a4f0 <__sfp+0x14>
8000a4ec:	0e 9c       	mov	r12,r7
8000a4ee:	c2 dc       	rcall	8000a548 <__sinit>
8000a4f0:	ee c7 ff 28 	sub	r7,r7,-216
8000a4f4:	30 05       	mov	r5,0
8000a4f6:	6e 2c       	ld.w	r12,r7[0x8]
8000a4f8:	6e 18       	ld.w	r8,r7[0x4]
8000a4fa:	c0 68       	rjmp	8000a506 <__sfp+0x2a>
8000a4fc:	98 69       	ld.sh	r9,r12[0xc]
8000a4fe:	ea 09 19 00 	cp.h	r9,r5
8000a502:	c1 10       	breq	8000a524 <__sfp+0x48>
8000a504:	2a 4c       	sub	r12,-92
8000a506:	20 18       	sub	r8,1
8000a508:	cf a7       	brpl	8000a4fc <__sfp+0x20>
8000a50a:	6e 08       	ld.w	r8,r7[0x0]
8000a50c:	58 08       	cp.w	r8,0
8000a50e:	c0 61       	brne	8000a51a <__sfp+0x3e>
8000a510:	30 4b       	mov	r11,4
8000a512:	0c 9c       	mov	r12,r6
8000a514:	cd 0f       	rcall	8000a4b4 <__sfmoreglue>
8000a516:	8f 0c       	st.w	r7[0x0],r12
8000a518:	c0 30       	breq	8000a51e <__sfp+0x42>
8000a51a:	6e 07       	ld.w	r7,r7[0x0]
8000a51c:	ce db       	rjmp	8000a4f6 <__sfp+0x1a>
8000a51e:	30 c8       	mov	r8,12
8000a520:	8d 38       	st.w	r6[0xc],r8
8000a522:	d8 22       	popm	r4-r7,pc
8000a524:	30 08       	mov	r8,0
8000a526:	f9 48 00 4c 	st.w	r12[76],r8
8000a52a:	99 08       	st.w	r12[0x0],r8
8000a52c:	99 28       	st.w	r12[0x8],r8
8000a52e:	99 18       	st.w	r12[0x4],r8
8000a530:	99 48       	st.w	r12[0x10],r8
8000a532:	99 58       	st.w	r12[0x14],r8
8000a534:	99 68       	st.w	r12[0x18],r8
8000a536:	99 d8       	st.w	r12[0x34],r8
8000a538:	99 e8       	st.w	r12[0x38],r8
8000a53a:	f9 48 00 48 	st.w	r12[72],r8
8000a53e:	3f f8       	mov	r8,-1
8000a540:	b8 78       	st.h	r12[0xe],r8
8000a542:	30 18       	mov	r8,1
8000a544:	b8 68       	st.h	r12[0xc],r8
8000a546:	d8 22       	popm	r4-r7,pc

8000a548 <__sinit>:
8000a548:	d4 21       	pushm	r4-r7,lr
8000a54a:	18 96       	mov	r6,r12
8000a54c:	78 67       	ld.w	r7,r12[0x18]
8000a54e:	58 07       	cp.w	r7,0
8000a550:	c4 91       	brne	8000a5e2 <__sinit+0x9a>
8000a552:	fe c8 00 aa 	sub	r8,pc,170
8000a556:	30 15       	mov	r5,1
8000a558:	99 a8       	st.w	r12[0x28],r8
8000a55a:	f9 47 00 d8 	st.w	r12[216],r7
8000a55e:	f9 47 00 dc 	st.w	r12[220],r7
8000a562:	f9 47 00 e0 	st.w	r12[224],r7
8000a566:	99 65       	st.w	r12[0x18],r5
8000a568:	cb af       	rcall	8000a4dc <__sfp>
8000a56a:	8d 0c       	st.w	r6[0x0],r12
8000a56c:	0c 9c       	mov	r12,r6
8000a56e:	cb 7f       	rcall	8000a4dc <__sfp>
8000a570:	8d 1c       	st.w	r6[0x4],r12
8000a572:	0c 9c       	mov	r12,r6
8000a574:	cb 4f       	rcall	8000a4dc <__sfp>
8000a576:	6c 09       	ld.w	r9,r6[0x0]
8000a578:	30 48       	mov	r8,4
8000a57a:	93 07       	st.w	r9[0x0],r7
8000a57c:	b2 68       	st.h	r9[0xc],r8
8000a57e:	93 17       	st.w	r9[0x4],r7
8000a580:	93 27       	st.w	r9[0x8],r7
8000a582:	6c 18       	ld.w	r8,r6[0x4]
8000a584:	b2 77       	st.h	r9[0xe],r7
8000a586:	93 47       	st.w	r9[0x10],r7
8000a588:	93 57       	st.w	r9[0x14],r7
8000a58a:	93 67       	st.w	r9[0x18],r7
8000a58c:	93 89       	st.w	r9[0x20],r9
8000a58e:	91 07       	st.w	r8[0x0],r7
8000a590:	91 17       	st.w	r8[0x4],r7
8000a592:	91 27       	st.w	r8[0x8],r7
8000a594:	fe ce f3 24 	sub	lr,pc,-3292
8000a598:	fe cb f3 54 	sub	r11,pc,-3244
8000a59c:	93 9e       	st.w	r9[0x24],lr
8000a59e:	93 ab       	st.w	r9[0x28],r11
8000a5a0:	fe ca f3 7c 	sub	r10,pc,-3204
8000a5a4:	fe c4 f3 88 	sub	r4,pc,-3192
8000a5a8:	93 ba       	st.w	r9[0x2c],r10
8000a5aa:	93 c4       	st.w	r9[0x30],r4
8000a5ac:	30 99       	mov	r9,9
8000a5ae:	b0 69       	st.h	r8[0xc],r9
8000a5b0:	b0 75       	st.h	r8[0xe],r5
8000a5b2:	91 c4       	st.w	r8[0x30],r4
8000a5b4:	91 47       	st.w	r8[0x10],r7
8000a5b6:	91 57       	st.w	r8[0x14],r7
8000a5b8:	91 67       	st.w	r8[0x18],r7
8000a5ba:	91 88       	st.w	r8[0x20],r8
8000a5bc:	91 9e       	st.w	r8[0x24],lr
8000a5be:	91 ab       	st.w	r8[0x28],r11
8000a5c0:	91 ba       	st.w	r8[0x2c],r10
8000a5c2:	8d 2c       	st.w	r6[0x8],r12
8000a5c4:	31 28       	mov	r8,18
8000a5c6:	99 07       	st.w	r12[0x0],r7
8000a5c8:	b8 68       	st.h	r12[0xc],r8
8000a5ca:	99 17       	st.w	r12[0x4],r7
8000a5cc:	99 27       	st.w	r12[0x8],r7
8000a5ce:	30 28       	mov	r8,2
8000a5d0:	b8 78       	st.h	r12[0xe],r8
8000a5d2:	99 c4       	st.w	r12[0x30],r4
8000a5d4:	99 67       	st.w	r12[0x18],r7
8000a5d6:	99 9e       	st.w	r12[0x24],lr
8000a5d8:	99 ab       	st.w	r12[0x28],r11
8000a5da:	99 ba       	st.w	r12[0x2c],r10
8000a5dc:	99 47       	st.w	r12[0x10],r7
8000a5de:	99 57       	st.w	r12[0x14],r7
8000a5e0:	99 8c       	st.w	r12[0x20],r12
8000a5e2:	d8 22       	popm	r4-r7,pc

8000a5e4 <_malloc_trim_r>:
8000a5e4:	d4 21       	pushm	r4-r7,lr
8000a5e6:	16 95       	mov	r5,r11
8000a5e8:	18 97       	mov	r7,r12
8000a5ea:	fe b0 d7 53 	rcall	80005490 <__malloc_lock>
8000a5ee:	e0 64 05 38 	mov	r4,1336
8000a5f2:	68 28       	ld.w	r8,r4[0x8]
8000a5f4:	70 16       	ld.w	r6,r8[0x4]
8000a5f6:	e0 16 ff fc 	andl	r6,0xfffc
8000a5fa:	ec c8 ff 91 	sub	r8,r6,-111
8000a5fe:	f0 05 01 05 	sub	r5,r8,r5
8000a602:	e0 15 ff 80 	andl	r5,0xff80
8000a606:	ea c5 00 80 	sub	r5,r5,128
8000a60a:	e0 45 00 7f 	cp.w	r5,127
8000a60e:	e0 8a 00 25 	brle	8000a658 <_malloc_trim_r+0x74>
8000a612:	30 0b       	mov	r11,0
8000a614:	0e 9c       	mov	r12,r7
8000a616:	fe b0 e5 f9 	rcall	80007208 <_sbrk_r>
8000a61a:	68 28       	ld.w	r8,r4[0x8]
8000a61c:	0c 08       	add	r8,r6
8000a61e:	10 3c       	cp.w	r12,r8
8000a620:	c1 c1       	brne	8000a658 <_malloc_trim_r+0x74>
8000a622:	ea 0b 11 00 	rsub	r11,r5,0
8000a626:	0e 9c       	mov	r12,r7
8000a628:	fe b0 e5 f0 	rcall	80007208 <_sbrk_r>
8000a62c:	5b fc       	cp.w	r12,-1
8000a62e:	c1 91       	brne	8000a660 <_malloc_trim_r+0x7c>
8000a630:	30 0b       	mov	r11,0
8000a632:	0e 9c       	mov	r12,r7
8000a634:	fe b0 e5 ea 	rcall	80007208 <_sbrk_r>
8000a638:	68 28       	ld.w	r8,r4[0x8]
8000a63a:	f8 08 01 09 	sub	r9,r12,r8
8000a63e:	58 f9       	cp.w	r9,15
8000a640:	e0 8a 00 0c 	brle	8000a658 <_malloc_trim_r+0x74>
8000a644:	a1 a9       	sbr	r9,0x0
8000a646:	91 19       	st.w	r8[0x4],r9
8000a648:	e0 68 09 44 	mov	r8,2372
8000a64c:	70 09       	ld.w	r9,r8[0x0]
8000a64e:	e0 68 0d 7c 	mov	r8,3452
8000a652:	f8 09 01 09 	sub	r9,r12,r9
8000a656:	91 09       	st.w	r8[0x0],r9
8000a658:	0e 9c       	mov	r12,r7
8000a65a:	fe b0 d7 21 	rcall	8000549c <__malloc_unlock>
8000a65e:	d8 2a       	popm	r4-r7,pc,r12=0
8000a660:	68 28       	ld.w	r8,r4[0x8]
8000a662:	0a 16       	sub	r6,r5
8000a664:	a1 a6       	sbr	r6,0x0
8000a666:	91 16       	st.w	r8[0x4],r6
8000a668:	e0 68 0d 7c 	mov	r8,3452
8000a66c:	70 09       	ld.w	r9,r8[0x0]
8000a66e:	0a 19       	sub	r9,r5
8000a670:	0e 9c       	mov	r12,r7
8000a672:	91 09       	st.w	r8[0x0],r9
8000a674:	fe b0 d7 14 	rcall	8000549c <__malloc_unlock>
8000a678:	da 2a       	popm	r4-r7,pc,r12=1
8000a67a:	d7 03       	nop

8000a67c <_free_r>:
8000a67c:	d4 21       	pushm	r4-r7,lr
8000a67e:	16 96       	mov	r6,r11
8000a680:	18 97       	mov	r7,r12
8000a682:	58 0b       	cp.w	r11,0
8000a684:	e0 80 00 c0 	breq	8000a804 <_free_r+0x188>
8000a688:	fe b0 d7 04 	rcall	80005490 <__malloc_lock>
8000a68c:	20 86       	sub	r6,8
8000a68e:	e0 6a 05 38 	mov	r10,1336
8000a692:	6c 18       	ld.w	r8,r6[0x4]
8000a694:	74 2e       	ld.w	lr,r10[0x8]
8000a696:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000a69a:	a1 c8       	cbr	r8,0x0
8000a69c:	ec 08 00 09 	add	r9,r6,r8
8000a6a0:	72 1b       	ld.w	r11,r9[0x4]
8000a6a2:	e0 1b ff fc 	andl	r11,0xfffc
8000a6a6:	1c 39       	cp.w	r9,lr
8000a6a8:	c1 e1       	brne	8000a6e4 <_free_r+0x68>
8000a6aa:	f6 08 00 08 	add	r8,r11,r8
8000a6ae:	58 0c       	cp.w	r12,0
8000a6b0:	c0 81       	brne	8000a6c0 <_free_r+0x44>
8000a6b2:	6c 09       	ld.w	r9,r6[0x0]
8000a6b4:	12 16       	sub	r6,r9
8000a6b6:	12 08       	add	r8,r9
8000a6b8:	6c 3b       	ld.w	r11,r6[0xc]
8000a6ba:	6c 29       	ld.w	r9,r6[0x8]
8000a6bc:	97 29       	st.w	r11[0x8],r9
8000a6be:	93 3b       	st.w	r9[0xc],r11
8000a6c0:	10 99       	mov	r9,r8
8000a6c2:	95 26       	st.w	r10[0x8],r6
8000a6c4:	a1 a9       	sbr	r9,0x0
8000a6c6:	8d 19       	st.w	r6[0x4],r9
8000a6c8:	e0 69 09 40 	mov	r9,2368
8000a6cc:	72 09       	ld.w	r9,r9[0x0]
8000a6ce:	12 38       	cp.w	r8,r9
8000a6d0:	c0 63       	brcs	8000a6dc <_free_r+0x60>
8000a6d2:	e0 68 0d 78 	mov	r8,3448
8000a6d6:	0e 9c       	mov	r12,r7
8000a6d8:	70 0b       	ld.w	r11,r8[0x0]
8000a6da:	c8 5f       	rcall	8000a5e4 <_malloc_trim_r>
8000a6dc:	0e 9c       	mov	r12,r7
8000a6de:	fe b0 d6 df 	rcall	8000549c <__malloc_unlock>
8000a6e2:	d8 22       	popm	r4-r7,pc
8000a6e4:	93 1b       	st.w	r9[0x4],r11
8000a6e6:	58 0c       	cp.w	r12,0
8000a6e8:	c0 30       	breq	8000a6ee <_free_r+0x72>
8000a6ea:	30 0c       	mov	r12,0
8000a6ec:	c1 08       	rjmp	8000a70c <_free_r+0x90>
8000a6ee:	6c 0e       	ld.w	lr,r6[0x0]
8000a6f0:	f4 c5 ff f8 	sub	r5,r10,-8
8000a6f4:	1c 16       	sub	r6,lr
8000a6f6:	1c 08       	add	r8,lr
8000a6f8:	6c 2e       	ld.w	lr,r6[0x8]
8000a6fa:	0a 3e       	cp.w	lr,r5
8000a6fc:	f9 bc 00 01 	moveq	r12,1
8000a700:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000a704:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000a708:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000a70c:	f2 0b 00 0e 	add	lr,r9,r11
8000a710:	7c 1e       	ld.w	lr,lr[0x4]
8000a712:	ed be 00 00 	bld	lr,0x0
8000a716:	c1 40       	breq	8000a73e <_free_r+0xc2>
8000a718:	16 08       	add	r8,r11
8000a71a:	58 0c       	cp.w	r12,0
8000a71c:	c0 d1       	brne	8000a736 <_free_r+0xba>
8000a71e:	e0 6e 05 38 	mov	lr,1336
8000a722:	72 2b       	ld.w	r11,r9[0x8]
8000a724:	2f 8e       	sub	lr,-8
8000a726:	1c 3b       	cp.w	r11,lr
8000a728:	c0 71       	brne	8000a736 <_free_r+0xba>
8000a72a:	97 36       	st.w	r11[0xc],r6
8000a72c:	97 26       	st.w	r11[0x8],r6
8000a72e:	8d 2b       	st.w	r6[0x8],r11
8000a730:	8d 3b       	st.w	r6[0xc],r11
8000a732:	30 1c       	mov	r12,1
8000a734:	c0 58       	rjmp	8000a73e <_free_r+0xc2>
8000a736:	72 2b       	ld.w	r11,r9[0x8]
8000a738:	72 39       	ld.w	r9,r9[0xc]
8000a73a:	93 2b       	st.w	r9[0x8],r11
8000a73c:	97 39       	st.w	r11[0xc],r9
8000a73e:	10 99       	mov	r9,r8
8000a740:	ec 08 09 08 	st.w	r6[r8],r8
8000a744:	a1 a9       	sbr	r9,0x0
8000a746:	8d 19       	st.w	r6[0x4],r9
8000a748:	58 0c       	cp.w	r12,0
8000a74a:	c5 a1       	brne	8000a7fe <_free_r+0x182>
8000a74c:	e0 48 01 ff 	cp.w	r8,511
8000a750:	e0 8b 00 13 	brhi	8000a776 <_free_r+0xfa>
8000a754:	a3 98       	lsr	r8,0x3
8000a756:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000a75a:	72 2b       	ld.w	r11,r9[0x8]
8000a75c:	8d 39       	st.w	r6[0xc],r9
8000a75e:	8d 2b       	st.w	r6[0x8],r11
8000a760:	97 36       	st.w	r11[0xc],r6
8000a762:	93 26       	st.w	r9[0x8],r6
8000a764:	a3 48       	asr	r8,0x2
8000a766:	74 19       	ld.w	r9,r10[0x4]
8000a768:	30 1b       	mov	r11,1
8000a76a:	f6 08 09 48 	lsl	r8,r11,r8
8000a76e:	f3 e8 10 08 	or	r8,r9,r8
8000a772:	95 18       	st.w	r10[0x4],r8
8000a774:	c4 58       	rjmp	8000a7fe <_free_r+0x182>
8000a776:	f0 0b 16 09 	lsr	r11,r8,0x9
8000a77a:	58 4b       	cp.w	r11,4
8000a77c:	e0 8b 00 06 	brhi	8000a788 <_free_r+0x10c>
8000a780:	f0 0b 16 06 	lsr	r11,r8,0x6
8000a784:	2c 8b       	sub	r11,-56
8000a786:	c2 08       	rjmp	8000a7c6 <_free_r+0x14a>
8000a788:	59 4b       	cp.w	r11,20
8000a78a:	e0 8b 00 04 	brhi	8000a792 <_free_r+0x116>
8000a78e:	2a 5b       	sub	r11,-91
8000a790:	c1 b8       	rjmp	8000a7c6 <_free_r+0x14a>
8000a792:	e0 4b 00 54 	cp.w	r11,84
8000a796:	e0 8b 00 06 	brhi	8000a7a2 <_free_r+0x126>
8000a79a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000a79e:	29 2b       	sub	r11,-110
8000a7a0:	c1 38       	rjmp	8000a7c6 <_free_r+0x14a>
8000a7a2:	e0 4b 01 54 	cp.w	r11,340
8000a7a6:	e0 8b 00 06 	brhi	8000a7b2 <_free_r+0x136>
8000a7aa:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000a7ae:	28 9b       	sub	r11,-119
8000a7b0:	c0 b8       	rjmp	8000a7c6 <_free_r+0x14a>
8000a7b2:	e0 4b 05 54 	cp.w	r11,1364
8000a7b6:	e0 88 00 05 	brls	8000a7c0 <_free_r+0x144>
8000a7ba:	37 eb       	mov	r11,126
8000a7bc:	c0 58       	rjmp	8000a7c6 <_free_r+0x14a>
8000a7be:	d7 03       	nop
8000a7c0:	f0 0b 16 12 	lsr	r11,r8,0x12
8000a7c4:	28 4b       	sub	r11,-124
8000a7c6:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000a7ca:	78 29       	ld.w	r9,r12[0x8]
8000a7cc:	18 39       	cp.w	r9,r12
8000a7ce:	c0 e1       	brne	8000a7ea <_free_r+0x16e>
8000a7d0:	74 18       	ld.w	r8,r10[0x4]
8000a7d2:	a3 4b       	asr	r11,0x2
8000a7d4:	30 1c       	mov	r12,1
8000a7d6:	f8 0b 09 4b 	lsl	r11,r12,r11
8000a7da:	f1 eb 10 0b 	or	r11,r8,r11
8000a7de:	12 98       	mov	r8,r9
8000a7e0:	95 1b       	st.w	r10[0x4],r11
8000a7e2:	c0 a8       	rjmp	8000a7f6 <_free_r+0x17a>
8000a7e4:	72 29       	ld.w	r9,r9[0x8]
8000a7e6:	18 39       	cp.w	r9,r12
8000a7e8:	c0 60       	breq	8000a7f4 <_free_r+0x178>
8000a7ea:	72 1a       	ld.w	r10,r9[0x4]
8000a7ec:	e0 1a ff fc 	andl	r10,0xfffc
8000a7f0:	14 38       	cp.w	r8,r10
8000a7f2:	cf 93       	brcs	8000a7e4 <_free_r+0x168>
8000a7f4:	72 38       	ld.w	r8,r9[0xc]
8000a7f6:	8d 38       	st.w	r6[0xc],r8
8000a7f8:	8d 29       	st.w	r6[0x8],r9
8000a7fa:	93 36       	st.w	r9[0xc],r6
8000a7fc:	91 26       	st.w	r8[0x8],r6
8000a7fe:	0e 9c       	mov	r12,r7
8000a800:	fe b0 d6 4e 	rcall	8000549c <__malloc_unlock>
8000a804:	d8 22       	popm	r4-r7,pc
8000a806:	d7 03       	nop

8000a808 <__sfvwrite_r>:
8000a808:	d4 31       	pushm	r0-r7,lr
8000a80a:	20 3d       	sub	sp,12
8000a80c:	14 94       	mov	r4,r10
8000a80e:	18 95       	mov	r5,r12
8000a810:	16 97       	mov	r7,r11
8000a812:	74 28       	ld.w	r8,r10[0x8]
8000a814:	58 08       	cp.w	r8,0
8000a816:	e0 80 01 40 	breq	8000aa96 <__sfvwrite_r+0x28e>
8000a81a:	96 68       	ld.sh	r8,r11[0xc]
8000a81c:	ed b8 00 03 	bld	r8,0x3
8000a820:	c0 41       	brne	8000a828 <__sfvwrite_r+0x20>
8000a822:	76 48       	ld.w	r8,r11[0x10]
8000a824:	58 08       	cp.w	r8,0
8000a826:	c0 c1       	brne	8000a83e <__sfvwrite_r+0x36>
8000a828:	0e 9b       	mov	r11,r7
8000a82a:	0a 9c       	mov	r12,r5
8000a82c:	fe b0 f6 c4 	rcall	800095b4 <__swsetup_r>
8000a830:	c0 70       	breq	8000a83e <__sfvwrite_r+0x36>
8000a832:	8e 68       	ld.sh	r8,r7[0xc]
8000a834:	a7 a8       	sbr	r8,0x6
8000a836:	ae 68       	st.h	r7[0xc],r8
8000a838:	30 98       	mov	r8,9
8000a83a:	8b 38       	st.w	r5[0xc],r8
8000a83c:	c2 b9       	rjmp	8000aa92 <__sfvwrite_r+0x28a>
8000a83e:	8e 63       	ld.sh	r3,r7[0xc]
8000a840:	68 00       	ld.w	r0,r4[0x0]
8000a842:	06 96       	mov	r6,r3
8000a844:	e2 16 00 02 	andl	r6,0x2,COH
8000a848:	c2 10       	breq	8000a88a <__sfvwrite_r+0x82>
8000a84a:	30 03       	mov	r3,0
8000a84c:	e0 62 04 00 	mov	r2,1024
8000a850:	06 96       	mov	r6,r3
8000a852:	c0 48       	rjmp	8000a85a <__sfvwrite_r+0x52>
8000a854:	60 03       	ld.w	r3,r0[0x0]
8000a856:	60 16       	ld.w	r6,r0[0x4]
8000a858:	2f 80       	sub	r0,-8
8000a85a:	58 06       	cp.w	r6,0
8000a85c:	cf c0       	breq	8000a854 <__sfvwrite_r+0x4c>
8000a85e:	e0 46 04 00 	cp.w	r6,1024
8000a862:	ec 09 17 80 	movls	r9,r6
8000a866:	e4 09 17 b0 	movhi	r9,r2
8000a86a:	06 9a       	mov	r10,r3
8000a86c:	6e a8       	ld.w	r8,r7[0x28]
8000a86e:	6e 8b       	ld.w	r11,r7[0x20]
8000a870:	0a 9c       	mov	r12,r5
8000a872:	5d 18       	icall	r8
8000a874:	18 16       	sub	r6,r12
8000a876:	58 0c       	cp.w	r12,0
8000a878:	e0 8a 01 0a 	brle	8000aa8c <__sfvwrite_r+0x284>
8000a87c:	68 28       	ld.w	r8,r4[0x8]
8000a87e:	18 18       	sub	r8,r12
8000a880:	89 28       	st.w	r4[0x8],r8
8000a882:	e0 80 01 0a 	breq	8000aa96 <__sfvwrite_r+0x28e>
8000a886:	18 03       	add	r3,r12
8000a888:	ce 9b       	rjmp	8000a85a <__sfvwrite_r+0x52>
8000a88a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000a88e:	c0 70       	breq	8000a89c <__sfvwrite_r+0x94>
8000a890:	50 06       	stdsp	sp[0x0],r6
8000a892:	0c 93       	mov	r3,r6
8000a894:	0c 91       	mov	r1,r6
8000a896:	50 15       	stdsp	sp[0x4],r5
8000a898:	08 92       	mov	r2,r4
8000a89a:	c9 c8       	rjmp	8000a9d2 <__sfvwrite_r+0x1ca>
8000a89c:	06 96       	mov	r6,r3
8000a89e:	08 91       	mov	r1,r4
8000a8a0:	c0 48       	rjmp	8000a8a8 <__sfvwrite_r+0xa0>
8000a8a2:	60 03       	ld.w	r3,r0[0x0]
8000a8a4:	60 16       	ld.w	r6,r0[0x4]
8000a8a6:	2f 80       	sub	r0,-8
8000a8a8:	58 06       	cp.w	r6,0
8000a8aa:	cf c0       	breq	8000a8a2 <__sfvwrite_r+0x9a>
8000a8ac:	8e 68       	ld.sh	r8,r7[0xc]
8000a8ae:	6e 24       	ld.w	r4,r7[0x8]
8000a8b0:	10 99       	mov	r9,r8
8000a8b2:	e2 19 02 00 	andl	r9,0x200,COH
8000a8b6:	c5 50       	breq	8000a960 <__sfvwrite_r+0x158>
8000a8b8:	08 36       	cp.w	r6,r4
8000a8ba:	c4 43       	brcs	8000a942 <__sfvwrite_r+0x13a>
8000a8bc:	10 99       	mov	r9,r8
8000a8be:	e2 19 04 80 	andl	r9,0x480,COH
8000a8c2:	c4 00       	breq	8000a942 <__sfvwrite_r+0x13a>
8000a8c4:	6e 4b       	ld.w	r11,r7[0x10]
8000a8c6:	6e 09       	ld.w	r9,r7[0x0]
8000a8c8:	16 19       	sub	r9,r11
8000a8ca:	50 09       	stdsp	sp[0x0],r9
8000a8cc:	6e 59       	ld.w	r9,r7[0x14]
8000a8ce:	10 9c       	mov	r12,r8
8000a8d0:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000a8d4:	30 28       	mov	r8,2
8000a8d6:	f4 08 0c 08 	divs	r8,r10,r8
8000a8da:	fa e9 00 04 	st.d	sp[4],r8
8000a8de:	10 94       	mov	r4,r8
8000a8e0:	40 09       	lddsp	r9,sp[0x0]
8000a8e2:	e2 1c 04 00 	andl	r12,0x400,COH
8000a8e6:	2f f9       	sub	r9,-1
8000a8e8:	0c 09       	add	r9,r6
8000a8ea:	12 38       	cp.w	r8,r9
8000a8ec:	f2 04 17 30 	movlo	r4,r9
8000a8f0:	58 0c       	cp.w	r12,0
8000a8f2:	c1 10       	breq	8000a914 <__sfvwrite_r+0x10c>
8000a8f4:	08 9b       	mov	r11,r4
8000a8f6:	0a 9c       	mov	r12,r5
8000a8f8:	fe b0 e0 60 	rcall	800069b8 <_malloc_r>
8000a8fc:	18 92       	mov	r2,r12
8000a8fe:	c1 40       	breq	8000a926 <__sfvwrite_r+0x11e>
8000a900:	40 0a       	lddsp	r10,sp[0x0]
8000a902:	6e 4b       	ld.w	r11,r7[0x10]
8000a904:	fe b0 e2 76 	rcall	80006df0 <memcpy>
8000a908:	8e 68       	ld.sh	r8,r7[0xc]
8000a90a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000a90e:	a7 b8       	sbr	r8,0x7
8000a910:	ae 68       	st.h	r7[0xc],r8
8000a912:	c0 d8       	rjmp	8000a92c <__sfvwrite_r+0x124>
8000a914:	08 9a       	mov	r10,r4
8000a916:	0a 9c       	mov	r12,r5
8000a918:	fe b0 e3 18 	rcall	80006f48 <_realloc_r>
8000a91c:	18 92       	mov	r2,r12
8000a91e:	c0 71       	brne	8000a92c <__sfvwrite_r+0x124>
8000a920:	6e 4b       	ld.w	r11,r7[0x10]
8000a922:	0a 9c       	mov	r12,r5
8000a924:	ca ce       	rcall	8000a67c <_free_r>
8000a926:	30 c8       	mov	r8,12
8000a928:	8b 38       	st.w	r5[0xc],r8
8000a92a:	cb 18       	rjmp	8000aa8c <__sfvwrite_r+0x284>
8000a92c:	40 0a       	lddsp	r10,sp[0x0]
8000a92e:	40 09       	lddsp	r9,sp[0x0]
8000a930:	e8 0a 01 0a 	sub	r10,r4,r10
8000a934:	e4 09 00 08 	add	r8,r2,r9
8000a938:	8f 54       	st.w	r7[0x14],r4
8000a93a:	8f 2a       	st.w	r7[0x8],r10
8000a93c:	8f 08       	st.w	r7[0x0],r8
8000a93e:	8f 42       	st.w	r7[0x10],r2
8000a940:	0c 94       	mov	r4,r6
8000a942:	08 36       	cp.w	r6,r4
8000a944:	ec 04 17 30 	movlo	r4,r6
8000a948:	06 9b       	mov	r11,r3
8000a94a:	08 9a       	mov	r10,r4
8000a94c:	6e 0c       	ld.w	r12,r7[0x0]
8000a94e:	c3 ad       	rcall	8000abc2 <memmove>
8000a950:	6e 08       	ld.w	r8,r7[0x0]
8000a952:	08 08       	add	r8,r4
8000a954:	8f 08       	st.w	r7[0x0],r8
8000a956:	6e 28       	ld.w	r8,r7[0x8]
8000a958:	08 18       	sub	r8,r4
8000a95a:	0c 94       	mov	r4,r6
8000a95c:	8f 28       	st.w	r7[0x8],r8
8000a95e:	c2 e8       	rjmp	8000a9ba <__sfvwrite_r+0x1b2>
8000a960:	08 36       	cp.w	r6,r4
8000a962:	5f ba       	srhi	r10
8000a964:	6e 0c       	ld.w	r12,r7[0x0]
8000a966:	6e 48       	ld.w	r8,r7[0x10]
8000a968:	10 3c       	cp.w	r12,r8
8000a96a:	5f b8       	srhi	r8
8000a96c:	f5 e8 00 08 	and	r8,r10,r8
8000a970:	f2 08 18 00 	cp.b	r8,r9
8000a974:	c0 d0       	breq	8000a98e <__sfvwrite_r+0x186>
8000a976:	06 9b       	mov	r11,r3
8000a978:	08 9a       	mov	r10,r4
8000a97a:	c2 4d       	rcall	8000abc2 <memmove>
8000a97c:	6e 08       	ld.w	r8,r7[0x0]
8000a97e:	08 08       	add	r8,r4
8000a980:	0e 9b       	mov	r11,r7
8000a982:	8f 08       	st.w	r7[0x0],r8
8000a984:	0a 9c       	mov	r12,r5
8000a986:	fe b0 fd 09 	rcall	8000a398 <_fflush_r>
8000a98a:	c1 80       	breq	8000a9ba <__sfvwrite_r+0x1b2>
8000a98c:	c8 08       	rjmp	8000aa8c <__sfvwrite_r+0x284>
8000a98e:	6e 59       	ld.w	r9,r7[0x14]
8000a990:	12 36       	cp.w	r6,r9
8000a992:	c0 a3       	brcs	8000a9a6 <__sfvwrite_r+0x19e>
8000a994:	6e a8       	ld.w	r8,r7[0x28]
8000a996:	06 9a       	mov	r10,r3
8000a998:	6e 8b       	ld.w	r11,r7[0x20]
8000a99a:	0a 9c       	mov	r12,r5
8000a99c:	5d 18       	icall	r8
8000a99e:	18 94       	mov	r4,r12
8000a9a0:	e0 89 00 0d 	brgt	8000a9ba <__sfvwrite_r+0x1b2>
8000a9a4:	c7 48       	rjmp	8000aa8c <__sfvwrite_r+0x284>
8000a9a6:	0c 9a       	mov	r10,r6
8000a9a8:	06 9b       	mov	r11,r3
8000a9aa:	c0 cd       	rcall	8000abc2 <memmove>
8000a9ac:	6e 08       	ld.w	r8,r7[0x0]
8000a9ae:	0c 08       	add	r8,r6
8000a9b0:	0c 94       	mov	r4,r6
8000a9b2:	8f 08       	st.w	r7[0x0],r8
8000a9b4:	6e 28       	ld.w	r8,r7[0x8]
8000a9b6:	0c 18       	sub	r8,r6
8000a9b8:	8f 28       	st.w	r7[0x8],r8
8000a9ba:	62 28       	ld.w	r8,r1[0x8]
8000a9bc:	08 18       	sub	r8,r4
8000a9be:	83 28       	st.w	r1[0x8],r8
8000a9c0:	c6 b0       	breq	8000aa96 <__sfvwrite_r+0x28e>
8000a9c2:	08 16       	sub	r6,r4
8000a9c4:	08 03       	add	r3,r4
8000a9c6:	c7 1b       	rjmp	8000a8a8 <__sfvwrite_r+0xa0>
8000a9c8:	60 03       	ld.w	r3,r0[0x0]
8000a9ca:	60 11       	ld.w	r1,r0[0x4]
8000a9cc:	30 08       	mov	r8,0
8000a9ce:	2f 80       	sub	r0,-8
8000a9d0:	50 08       	stdsp	sp[0x0],r8
8000a9d2:	58 01       	cp.w	r1,0
8000a9d4:	cf a0       	breq	8000a9c8 <__sfvwrite_r+0x1c0>
8000a9d6:	40 0a       	lddsp	r10,sp[0x0]
8000a9d8:	58 0a       	cp.w	r10,0
8000a9da:	c1 41       	brne	8000aa02 <__sfvwrite_r+0x1fa>
8000a9dc:	e2 c6 ff ff 	sub	r6,r1,-1
8000a9e0:	02 9a       	mov	r10,r1
8000a9e2:	30 ab       	mov	r11,10
8000a9e4:	06 9c       	mov	r12,r3
8000a9e6:	ce 3c       	rcall	8000abac <memchr>
8000a9e8:	f8 c8 ff ff 	sub	r8,r12,-1
8000a9ec:	58 0c       	cp.w	r12,0
8000a9ee:	f1 d3 e1 16 	subne	r6,r8,r3
8000a9f2:	f9 b9 01 01 	movne	r9,1
8000a9f6:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a9fa:	f9 b8 00 01 	moveq	r8,1
8000a9fe:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000aa02:	02 36       	cp.w	r6,r1
8000aa04:	ec 04 17 80 	movls	r4,r6
8000aa08:	e2 04 17 b0 	movhi	r4,r1
8000aa0c:	6e 59       	ld.w	r9,r7[0x14]
8000aa0e:	6e 25       	ld.w	r5,r7[0x8]
8000aa10:	f2 05 00 05 	add	r5,r9,r5
8000aa14:	0a 34       	cp.w	r4,r5
8000aa16:	5f 9a       	srgt	r10
8000aa18:	6e 0c       	ld.w	r12,r7[0x0]
8000aa1a:	6e 48       	ld.w	r8,r7[0x10]
8000aa1c:	10 3c       	cp.w	r12,r8
8000aa1e:	5f b8       	srhi	r8
8000aa20:	f5 e8 00 08 	and	r8,r10,r8
8000aa24:	30 0a       	mov	r10,0
8000aa26:	f4 08 18 00 	cp.b	r8,r10
8000aa2a:	c0 d0       	breq	8000aa44 <__sfvwrite_r+0x23c>
8000aa2c:	06 9b       	mov	r11,r3
8000aa2e:	0a 9a       	mov	r10,r5
8000aa30:	cc 9c       	rcall	8000abc2 <memmove>
8000aa32:	6e 08       	ld.w	r8,r7[0x0]
8000aa34:	0a 08       	add	r8,r5
8000aa36:	0e 9b       	mov	r11,r7
8000aa38:	8f 08       	st.w	r7[0x0],r8
8000aa3a:	40 1c       	lddsp	r12,sp[0x4]
8000aa3c:	fe b0 fc ae 	rcall	8000a398 <_fflush_r>
8000aa40:	c1 70       	breq	8000aa6e <__sfvwrite_r+0x266>
8000aa42:	c2 58       	rjmp	8000aa8c <__sfvwrite_r+0x284>
8000aa44:	12 34       	cp.w	r4,r9
8000aa46:	c0 a5       	brlt	8000aa5a <__sfvwrite_r+0x252>
8000aa48:	6e a8       	ld.w	r8,r7[0x28]
8000aa4a:	06 9a       	mov	r10,r3
8000aa4c:	6e 8b       	ld.w	r11,r7[0x20]
8000aa4e:	40 1c       	lddsp	r12,sp[0x4]
8000aa50:	5d 18       	icall	r8
8000aa52:	18 95       	mov	r5,r12
8000aa54:	e0 89 00 0d 	brgt	8000aa6e <__sfvwrite_r+0x266>
8000aa58:	c1 a8       	rjmp	8000aa8c <__sfvwrite_r+0x284>
8000aa5a:	08 9a       	mov	r10,r4
8000aa5c:	06 9b       	mov	r11,r3
8000aa5e:	cb 2c       	rcall	8000abc2 <memmove>
8000aa60:	6e 08       	ld.w	r8,r7[0x0]
8000aa62:	08 08       	add	r8,r4
8000aa64:	08 95       	mov	r5,r4
8000aa66:	8f 08       	st.w	r7[0x0],r8
8000aa68:	6e 28       	ld.w	r8,r7[0x8]
8000aa6a:	08 18       	sub	r8,r4
8000aa6c:	8f 28       	st.w	r7[0x8],r8
8000aa6e:	0a 16       	sub	r6,r5
8000aa70:	c0 71       	brne	8000aa7e <__sfvwrite_r+0x276>
8000aa72:	0e 9b       	mov	r11,r7
8000aa74:	40 1c       	lddsp	r12,sp[0x4]
8000aa76:	fe b0 fc 91 	rcall	8000a398 <_fflush_r>
8000aa7a:	c0 91       	brne	8000aa8c <__sfvwrite_r+0x284>
8000aa7c:	50 06       	stdsp	sp[0x0],r6
8000aa7e:	64 28       	ld.w	r8,r2[0x8]
8000aa80:	0a 18       	sub	r8,r5
8000aa82:	85 28       	st.w	r2[0x8],r8
8000aa84:	c0 90       	breq	8000aa96 <__sfvwrite_r+0x28e>
8000aa86:	0a 11       	sub	r1,r5
8000aa88:	0a 03       	add	r3,r5
8000aa8a:	ca 4b       	rjmp	8000a9d2 <__sfvwrite_r+0x1ca>
8000aa8c:	8e 68       	ld.sh	r8,r7[0xc]
8000aa8e:	a7 a8       	sbr	r8,0x6
8000aa90:	ae 68       	st.h	r7[0xc],r8
8000aa92:	3f fc       	mov	r12,-1
8000aa94:	c0 28       	rjmp	8000aa98 <__sfvwrite_r+0x290>
8000aa96:	30 0c       	mov	r12,0
8000aa98:	2f dd       	sub	sp,-12
8000aa9a:	d8 32       	popm	r0-r7,pc

8000aa9c <_fwalk>:
8000aa9c:	d4 31       	pushm	r0-r7,lr
8000aa9e:	30 05       	mov	r5,0
8000aaa0:	16 91       	mov	r1,r11
8000aaa2:	f8 c7 ff 28 	sub	r7,r12,-216
8000aaa6:	0a 92       	mov	r2,r5
8000aaa8:	fe b0 fc fe 	rcall	8000a4a4 <__sfp_lock_acquire>
8000aaac:	3f f3       	mov	r3,-1
8000aaae:	c1 68       	rjmp	8000aada <_fwalk+0x3e>
8000aab0:	6e 26       	ld.w	r6,r7[0x8]
8000aab2:	6e 14       	ld.w	r4,r7[0x4]
8000aab4:	2f 46       	sub	r6,-12
8000aab6:	c0 c8       	rjmp	8000aace <_fwalk+0x32>
8000aab8:	8c 08       	ld.sh	r8,r6[0x0]
8000aaba:	e4 08 19 00 	cp.h	r8,r2
8000aabe:	c0 70       	breq	8000aacc <_fwalk+0x30>
8000aac0:	8c 18       	ld.sh	r8,r6[0x2]
8000aac2:	e6 08 19 00 	cp.h	r8,r3
8000aac6:	c0 30       	breq	8000aacc <_fwalk+0x30>
8000aac8:	5d 11       	icall	r1
8000aaca:	18 45       	or	r5,r12
8000aacc:	2a 46       	sub	r6,-92
8000aace:	20 14       	sub	r4,1
8000aad0:	ec cc 00 0c 	sub	r12,r6,12
8000aad4:	58 04       	cp.w	r4,0
8000aad6:	cf 14       	brge	8000aab8 <_fwalk+0x1c>
8000aad8:	6e 07       	ld.w	r7,r7[0x0]
8000aada:	58 07       	cp.w	r7,0
8000aadc:	ce a1       	brne	8000aab0 <_fwalk+0x14>
8000aade:	fe b0 fc e4 	rcall	8000a4a6 <__sfp_lock_release>
8000aae2:	0a 9c       	mov	r12,r5
8000aae4:	d8 32       	popm	r0-r7,pc
8000aae6:	d7 03       	nop

8000aae8 <_localeconv_r>:
8000aae8:	fe cc ce c0 	sub	r12,pc,-12608
8000aaec:	5e fc       	retal	r12
8000aaee:	d7 03       	nop

8000aaf0 <__smakebuf_r>:
8000aaf0:	d4 21       	pushm	r4-r7,lr
8000aaf2:	20 fd       	sub	sp,60
8000aaf4:	96 68       	ld.sh	r8,r11[0xc]
8000aaf6:	16 97       	mov	r7,r11
8000aaf8:	18 96       	mov	r6,r12
8000aafa:	e2 18 00 02 	andl	r8,0x2,COH
8000aafe:	c3 d1       	brne	8000ab78 <__smakebuf_r+0x88>
8000ab00:	96 7b       	ld.sh	r11,r11[0xe]
8000ab02:	f0 0b 19 00 	cp.h	r11,r8
8000ab06:	c0 55       	brlt	8000ab10 <__smakebuf_r+0x20>
8000ab08:	1a 9a       	mov	r10,sp
8000ab0a:	e0 a0 04 75 	rcall	8000b3f4 <_fstat_r>
8000ab0e:	c0 f4       	brge	8000ab2c <__smakebuf_r+0x3c>
8000ab10:	8e 65       	ld.sh	r5,r7[0xc]
8000ab12:	0a 98       	mov	r8,r5
8000ab14:	ab b8       	sbr	r8,0xb
8000ab16:	e2 15 00 80 	andl	r5,0x80,COH
8000ab1a:	ae 68       	st.h	r7[0xc],r8
8000ab1c:	30 04       	mov	r4,0
8000ab1e:	e0 68 04 00 	mov	r8,1024
8000ab22:	f9 b5 01 40 	movne	r5,64
8000ab26:	f0 05 17 00 	moveq	r5,r8
8000ab2a:	c1 c8       	rjmp	8000ab62 <__smakebuf_r+0x72>
8000ab2c:	40 18       	lddsp	r8,sp[0x4]
8000ab2e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000ab32:	e0 48 20 00 	cp.w	r8,8192
8000ab36:	5f 04       	sreq	r4
8000ab38:	e0 48 80 00 	cp.w	r8,32768
8000ab3c:	c0 e1       	brne	8000ab58 <__smakebuf_r+0x68>
8000ab3e:	6e b9       	ld.w	r9,r7[0x2c]
8000ab40:	fe c8 f9 1c 	sub	r8,pc,-1764
8000ab44:	10 39       	cp.w	r9,r8
8000ab46:	c0 91       	brne	8000ab58 <__smakebuf_r+0x68>
8000ab48:	8e 68       	ld.sh	r8,r7[0xc]
8000ab4a:	e0 65 04 00 	mov	r5,1024
8000ab4e:	ab a8       	sbr	r8,0xa
8000ab50:	ef 45 00 50 	st.w	r7[80],r5
8000ab54:	ae 68       	st.h	r7[0xc],r8
8000ab56:	c0 68       	rjmp	8000ab62 <__smakebuf_r+0x72>
8000ab58:	8e 68       	ld.sh	r8,r7[0xc]
8000ab5a:	e0 65 04 00 	mov	r5,1024
8000ab5e:	ab b8       	sbr	r8,0xb
8000ab60:	ae 68       	st.h	r7[0xc],r8
8000ab62:	0a 9b       	mov	r11,r5
8000ab64:	0c 9c       	mov	r12,r6
8000ab66:	fe b0 df 29 	rcall	800069b8 <_malloc_r>
8000ab6a:	8e 68       	ld.sh	r8,r7[0xc]
8000ab6c:	c0 d1       	brne	8000ab86 <__smakebuf_r+0x96>
8000ab6e:	ed b8 00 09 	bld	r8,0x9
8000ab72:	c1 b0       	breq	8000aba8 <__smakebuf_r+0xb8>
8000ab74:	a1 b8       	sbr	r8,0x1
8000ab76:	ae 68       	st.h	r7[0xc],r8
8000ab78:	ee c8 ff b9 	sub	r8,r7,-71
8000ab7c:	8f 48       	st.w	r7[0x10],r8
8000ab7e:	8f 08       	st.w	r7[0x0],r8
8000ab80:	30 18       	mov	r8,1
8000ab82:	8f 58       	st.w	r7[0x14],r8
8000ab84:	c1 28       	rjmp	8000aba8 <__smakebuf_r+0xb8>
8000ab86:	a7 b8       	sbr	r8,0x7
8000ab88:	8f 4c       	st.w	r7[0x10],r12
8000ab8a:	ae 68       	st.h	r7[0xc],r8
8000ab8c:	8f 55       	st.w	r7[0x14],r5
8000ab8e:	fe c8 06 e6 	sub	r8,pc,1766
8000ab92:	8f 0c       	st.w	r7[0x0],r12
8000ab94:	8d a8       	st.w	r6[0x28],r8
8000ab96:	58 04       	cp.w	r4,0
8000ab98:	c0 80       	breq	8000aba8 <__smakebuf_r+0xb8>
8000ab9a:	8e 7c       	ld.sh	r12,r7[0xe]
8000ab9c:	fe b0 e3 94 	rcall	800072c4 <isatty>
8000aba0:	c0 40       	breq	8000aba8 <__smakebuf_r+0xb8>
8000aba2:	8e 68       	ld.sh	r8,r7[0xc]
8000aba4:	a1 a8       	sbr	r8,0x0
8000aba6:	ae 68       	st.h	r7[0xc],r8
8000aba8:	2f 1d       	sub	sp,-60
8000abaa:	d8 22       	popm	r4-r7,pc

8000abac <memchr>:
8000abac:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000abb0:	c0 68       	rjmp	8000abbc <memchr+0x10>
8000abb2:	20 1a       	sub	r10,1
8000abb4:	19 88       	ld.ub	r8,r12[0x0]
8000abb6:	16 38       	cp.w	r8,r11
8000abb8:	5e 0c       	reteq	r12
8000abba:	2f fc       	sub	r12,-1
8000abbc:	58 0a       	cp.w	r10,0
8000abbe:	cf a1       	brne	8000abb2 <memchr+0x6>
8000abc0:	5e fa       	retal	r10

8000abc2 <memmove>:
8000abc2:	d4 01       	pushm	lr
8000abc4:	18 3b       	cp.w	r11,r12
8000abc6:	c1 92       	brcc	8000abf8 <memmove+0x36>
8000abc8:	f6 0a 00 09 	add	r9,r11,r10
8000abcc:	12 3c       	cp.w	r12,r9
8000abce:	c1 52       	brcc	8000abf8 <memmove+0x36>
8000abd0:	f8 0a 00 0b 	add	r11,r12,r10
8000abd4:	30 08       	mov	r8,0
8000abd6:	c0 68       	rjmp	8000abe2 <memmove+0x20>
8000abd8:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000abdc:	20 1a       	sub	r10,1
8000abde:	f6 08 0b 0e 	st.b	r11[r8],lr
8000abe2:	20 18       	sub	r8,1
8000abe4:	58 0a       	cp.w	r10,0
8000abe6:	cf 91       	brne	8000abd8 <memmove+0x16>
8000abe8:	d8 02       	popm	pc
8000abea:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000abee:	20 1a       	sub	r10,1
8000abf0:	f8 08 0b 09 	st.b	r12[r8],r9
8000abf4:	2f f8       	sub	r8,-1
8000abf6:	c0 28       	rjmp	8000abfa <memmove+0x38>
8000abf8:	30 08       	mov	r8,0
8000abfa:	58 0a       	cp.w	r10,0
8000abfc:	cf 71       	brne	8000abea <memmove+0x28>
8000abfe:	d8 02       	popm	pc

8000ac00 <__hi0bits>:
8000ac00:	18 98       	mov	r8,r12
8000ac02:	e0 1c 00 00 	andl	r12,0x0
8000ac06:	f0 09 15 10 	lsl	r9,r8,0x10
8000ac0a:	58 0c       	cp.w	r12,0
8000ac0c:	f2 08 17 00 	moveq	r8,r9
8000ac10:	f9 bc 00 10 	moveq	r12,16
8000ac14:	f9 bc 01 00 	movne	r12,0
8000ac18:	10 9a       	mov	r10,r8
8000ac1a:	f0 09 15 08 	lsl	r9,r8,0x8
8000ac1e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000ac22:	f7 bc 00 f8 	subeq	r12,-8
8000ac26:	f2 08 17 00 	moveq	r8,r9
8000ac2a:	10 9a       	mov	r10,r8
8000ac2c:	f0 09 15 04 	lsl	r9,r8,0x4
8000ac30:	e6 1a f0 00 	andh	r10,0xf000,COH
8000ac34:	f7 bc 00 fc 	subeq	r12,-4
8000ac38:	f2 08 17 00 	moveq	r8,r9
8000ac3c:	10 9a       	mov	r10,r8
8000ac3e:	f0 09 15 02 	lsl	r9,r8,0x2
8000ac42:	e6 1a c0 00 	andh	r10,0xc000,COH
8000ac46:	f7 bc 00 fe 	subeq	r12,-2
8000ac4a:	f2 08 17 00 	moveq	r8,r9
8000ac4e:	58 08       	cp.w	r8,0
8000ac50:	5e 5c       	retlt	r12
8000ac52:	ed b8 00 1e 	bld	r8,0x1e
8000ac56:	f9 bc 01 20 	movne	r12,32
8000ac5a:	f7 bc 00 ff 	subeq	r12,-1
8000ac5e:	5e fc       	retal	r12

8000ac60 <__lo0bits>:
8000ac60:	18 99       	mov	r9,r12
8000ac62:	78 08       	ld.w	r8,r12[0x0]
8000ac64:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000ac68:	c1 50       	breq	8000ac92 <__lo0bits+0x32>
8000ac6a:	ed b8 00 00 	bld	r8,0x0
8000ac6e:	c0 21       	brne	8000ac72 <__lo0bits+0x12>
8000ac70:	5e fd       	retal	0
8000ac72:	10 9b       	mov	r11,r8
8000ac74:	f0 0a 16 01 	lsr	r10,r8,0x1
8000ac78:	e2 1b 00 02 	andl	r11,0x2,COH
8000ac7c:	a3 88       	lsr	r8,0x2
8000ac7e:	58 0b       	cp.w	r11,0
8000ac80:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000ac84:	f9 bc 01 01 	movne	r12,1
8000ac88:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000ac8c:	f9 bc 00 02 	moveq	r12,2
8000ac90:	5e fc       	retal	r12
8000ac92:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000ac96:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ac9a:	58 0a       	cp.w	r10,0
8000ac9c:	f6 08 17 00 	moveq	r8,r11
8000aca0:	f9 bc 00 10 	moveq	r12,16
8000aca4:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000aca8:	f0 0a 16 08 	lsr	r10,r8,0x8
8000acac:	58 0b       	cp.w	r11,0
8000acae:	f7 bc 00 f8 	subeq	r12,-8
8000acb2:	f4 08 17 00 	moveq	r8,r10
8000acb6:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000acba:	f0 0a 16 04 	lsr	r10,r8,0x4
8000acbe:	58 0b       	cp.w	r11,0
8000acc0:	f7 bc 00 fc 	subeq	r12,-4
8000acc4:	f4 08 17 00 	moveq	r8,r10
8000acc8:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000accc:	f0 0a 16 02 	lsr	r10,r8,0x2
8000acd0:	58 0b       	cp.w	r11,0
8000acd2:	f7 bc 00 fe 	subeq	r12,-2
8000acd6:	f4 08 17 00 	moveq	r8,r10
8000acda:	ed b8 00 00 	bld	r8,0x0
8000acde:	c0 60       	breq	8000acea <__lo0bits+0x8a>
8000ace0:	a1 98       	lsr	r8,0x1
8000ace2:	c0 31       	brne	8000ace8 <__lo0bits+0x88>
8000ace4:	32 0c       	mov	r12,32
8000ace6:	5e fc       	retal	r12
8000ace8:	2f fc       	sub	r12,-1
8000acea:	93 08       	st.w	r9[0x0],r8
8000acec:	5e fc       	retal	r12

8000acee <__mcmp>:
8000acee:	d4 01       	pushm	lr
8000acf0:	18 98       	mov	r8,r12
8000acf2:	76 49       	ld.w	r9,r11[0x10]
8000acf4:	78 4c       	ld.w	r12,r12[0x10]
8000acf6:	12 1c       	sub	r12,r9
8000acf8:	c1 31       	brne	8000ad1e <__mcmp+0x30>
8000acfa:	2f b9       	sub	r9,-5
8000acfc:	a3 69       	lsl	r9,0x2
8000acfe:	12 0b       	add	r11,r9
8000ad00:	f0 09 00 09 	add	r9,r8,r9
8000ad04:	2e c8       	sub	r8,-20
8000ad06:	13 4e       	ld.w	lr,--r9
8000ad08:	17 4a       	ld.w	r10,--r11
8000ad0a:	14 3e       	cp.w	lr,r10
8000ad0c:	c0 60       	breq	8000ad18 <__mcmp+0x2a>
8000ad0e:	f9 bc 03 ff 	movlo	r12,-1
8000ad12:	f9 bc 02 01 	movhs	r12,1
8000ad16:	d8 02       	popm	pc
8000ad18:	10 39       	cp.w	r9,r8
8000ad1a:	fe 9b ff f6 	brhi	8000ad06 <__mcmp+0x18>
8000ad1e:	d8 02       	popm	pc

8000ad20 <_Bfree>:
8000ad20:	d4 21       	pushm	r4-r7,lr
8000ad22:	18 97       	mov	r7,r12
8000ad24:	16 95       	mov	r5,r11
8000ad26:	78 96       	ld.w	r6,r12[0x24]
8000ad28:	58 06       	cp.w	r6,0
8000ad2a:	c0 91       	brne	8000ad3c <_Bfree+0x1c>
8000ad2c:	31 0c       	mov	r12,16
8000ad2e:	fe b0 de 3d 	rcall	800069a8 <malloc>
8000ad32:	99 36       	st.w	r12[0xc],r6
8000ad34:	8f 9c       	st.w	r7[0x24],r12
8000ad36:	99 16       	st.w	r12[0x4],r6
8000ad38:	99 26       	st.w	r12[0x8],r6
8000ad3a:	99 06       	st.w	r12[0x0],r6
8000ad3c:	58 05       	cp.w	r5,0
8000ad3e:	c0 90       	breq	8000ad50 <_Bfree+0x30>
8000ad40:	6a 19       	ld.w	r9,r5[0x4]
8000ad42:	6e 98       	ld.w	r8,r7[0x24]
8000ad44:	70 38       	ld.w	r8,r8[0xc]
8000ad46:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000ad4a:	8b 0a       	st.w	r5[0x0],r10
8000ad4c:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000ad50:	d8 22       	popm	r4-r7,pc
8000ad52:	d7 03       	nop

8000ad54 <_Balloc>:
8000ad54:	d4 21       	pushm	r4-r7,lr
8000ad56:	18 97       	mov	r7,r12
8000ad58:	16 96       	mov	r6,r11
8000ad5a:	78 95       	ld.w	r5,r12[0x24]
8000ad5c:	58 05       	cp.w	r5,0
8000ad5e:	c0 91       	brne	8000ad70 <_Balloc+0x1c>
8000ad60:	31 0c       	mov	r12,16
8000ad62:	fe b0 de 23 	rcall	800069a8 <malloc>
8000ad66:	99 35       	st.w	r12[0xc],r5
8000ad68:	8f 9c       	st.w	r7[0x24],r12
8000ad6a:	99 15       	st.w	r12[0x4],r5
8000ad6c:	99 25       	st.w	r12[0x8],r5
8000ad6e:	99 05       	st.w	r12[0x0],r5
8000ad70:	6e 95       	ld.w	r5,r7[0x24]
8000ad72:	6a 38       	ld.w	r8,r5[0xc]
8000ad74:	58 08       	cp.w	r8,0
8000ad76:	c0 b1       	brne	8000ad8c <_Balloc+0x38>
8000ad78:	31 0a       	mov	r10,16
8000ad7a:	30 4b       	mov	r11,4
8000ad7c:	0e 9c       	mov	r12,r7
8000ad7e:	e0 a0 02 9b 	rcall	8000b2b4 <_calloc_r>
8000ad82:	8b 3c       	st.w	r5[0xc],r12
8000ad84:	6e 98       	ld.w	r8,r7[0x24]
8000ad86:	70 3c       	ld.w	r12,r8[0xc]
8000ad88:	58 0c       	cp.w	r12,0
8000ad8a:	c1 b0       	breq	8000adc0 <_Balloc+0x6c>
8000ad8c:	6e 98       	ld.w	r8,r7[0x24]
8000ad8e:	70 38       	ld.w	r8,r8[0xc]
8000ad90:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000ad94:	70 0c       	ld.w	r12,r8[0x0]
8000ad96:	58 0c       	cp.w	r12,0
8000ad98:	c0 40       	breq	8000ada0 <_Balloc+0x4c>
8000ad9a:	78 09       	ld.w	r9,r12[0x0]
8000ad9c:	91 09       	st.w	r8[0x0],r9
8000ad9e:	c0 e8       	rjmp	8000adba <_Balloc+0x66>
8000ada0:	0e 9c       	mov	r12,r7
8000ada2:	30 17       	mov	r7,1
8000ada4:	0e 9b       	mov	r11,r7
8000ada6:	ee 06 09 47 	lsl	r7,r7,r6
8000adaa:	ee ca ff fb 	sub	r10,r7,-5
8000adae:	a3 6a       	lsl	r10,0x2
8000adb0:	e0 a0 02 82 	rcall	8000b2b4 <_calloc_r>
8000adb4:	c0 60       	breq	8000adc0 <_Balloc+0x6c>
8000adb6:	99 16       	st.w	r12[0x4],r6
8000adb8:	99 27       	st.w	r12[0x8],r7
8000adba:	30 08       	mov	r8,0
8000adbc:	99 38       	st.w	r12[0xc],r8
8000adbe:	99 48       	st.w	r12[0x10],r8
8000adc0:	d8 22       	popm	r4-r7,pc
8000adc2:	d7 03       	nop

8000adc4 <__d2b>:
8000adc4:	d4 31       	pushm	r0-r7,lr
8000adc6:	20 2d       	sub	sp,8
8000adc8:	16 93       	mov	r3,r11
8000adca:	12 96       	mov	r6,r9
8000adcc:	10 95       	mov	r5,r8
8000adce:	14 92       	mov	r2,r10
8000add0:	30 1b       	mov	r11,1
8000add2:	cc 1f       	rcall	8000ad54 <_Balloc>
8000add4:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000add8:	50 09       	stdsp	sp[0x0],r9
8000adda:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000adde:	b5 a9       	sbr	r9,0x14
8000ade0:	f0 01 16 14 	lsr	r1,r8,0x14
8000ade4:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000ade8:	18 94       	mov	r4,r12
8000adea:	58 02       	cp.w	r2,0
8000adec:	c1 d0       	breq	8000ae26 <__d2b+0x62>
8000adee:	fa cc ff f8 	sub	r12,sp,-8
8000adf2:	18 d2       	st.w	--r12,r2
8000adf4:	c3 6f       	rcall	8000ac60 <__lo0bits>
8000adf6:	40 18       	lddsp	r8,sp[0x4]
8000adf8:	c0 d0       	breq	8000ae12 <__d2b+0x4e>
8000adfa:	40 09       	lddsp	r9,sp[0x0]
8000adfc:	f8 0a 11 20 	rsub	r10,r12,32
8000ae00:	f2 0a 09 4a 	lsl	r10,r9,r10
8000ae04:	f5 e8 10 08 	or	r8,r10,r8
8000ae08:	89 58       	st.w	r4[0x14],r8
8000ae0a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000ae0e:	50 09       	stdsp	sp[0x0],r9
8000ae10:	c0 28       	rjmp	8000ae14 <__d2b+0x50>
8000ae12:	89 58       	st.w	r4[0x14],r8
8000ae14:	40 08       	lddsp	r8,sp[0x0]
8000ae16:	58 08       	cp.w	r8,0
8000ae18:	f9 b3 01 02 	movne	r3,2
8000ae1c:	f9 b3 00 01 	moveq	r3,1
8000ae20:	89 68       	st.w	r4[0x18],r8
8000ae22:	89 43       	st.w	r4[0x10],r3
8000ae24:	c0 88       	rjmp	8000ae34 <__d2b+0x70>
8000ae26:	1a 9c       	mov	r12,sp
8000ae28:	c1 cf       	rcall	8000ac60 <__lo0bits>
8000ae2a:	30 13       	mov	r3,1
8000ae2c:	40 08       	lddsp	r8,sp[0x0]
8000ae2e:	2e 0c       	sub	r12,-32
8000ae30:	89 43       	st.w	r4[0x10],r3
8000ae32:	89 58       	st.w	r4[0x14],r8
8000ae34:	58 01       	cp.w	r1,0
8000ae36:	c0 90       	breq	8000ae48 <__d2b+0x84>
8000ae38:	e2 c1 04 33 	sub	r1,r1,1075
8000ae3c:	18 01       	add	r1,r12
8000ae3e:	8d 01       	st.w	r6[0x0],r1
8000ae40:	f8 0c 11 35 	rsub	r12,r12,53
8000ae44:	8b 0c       	st.w	r5[0x0],r12
8000ae46:	c0 c8       	rjmp	8000ae5e <__d2b+0x9a>
8000ae48:	e6 c8 ff fc 	sub	r8,r3,-4
8000ae4c:	f8 cc 04 32 	sub	r12,r12,1074
8000ae50:	a5 73       	lsl	r3,0x5
8000ae52:	8d 0c       	st.w	r6[0x0],r12
8000ae54:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000ae58:	cd 4e       	rcall	8000ac00 <__hi0bits>
8000ae5a:	18 13       	sub	r3,r12
8000ae5c:	8b 03       	st.w	r5[0x0],r3
8000ae5e:	08 9c       	mov	r12,r4
8000ae60:	2f ed       	sub	sp,-8
8000ae62:	d8 32       	popm	r0-r7,pc

8000ae64 <__mdiff>:
8000ae64:	d4 31       	pushm	r0-r7,lr
8000ae66:	74 48       	ld.w	r8,r10[0x10]
8000ae68:	76 45       	ld.w	r5,r11[0x10]
8000ae6a:	16 97       	mov	r7,r11
8000ae6c:	14 96       	mov	r6,r10
8000ae6e:	10 15       	sub	r5,r8
8000ae70:	c1 31       	brne	8000ae96 <__mdiff+0x32>
8000ae72:	2f b8       	sub	r8,-5
8000ae74:	ee ce ff ec 	sub	lr,r7,-20
8000ae78:	a3 68       	lsl	r8,0x2
8000ae7a:	f4 08 00 0b 	add	r11,r10,r8
8000ae7e:	ee 08 00 08 	add	r8,r7,r8
8000ae82:	11 4a       	ld.w	r10,--r8
8000ae84:	17 49       	ld.w	r9,--r11
8000ae86:	12 3a       	cp.w	r10,r9
8000ae88:	c0 30       	breq	8000ae8e <__mdiff+0x2a>
8000ae8a:	c0 e2       	brcc	8000aea6 <__mdiff+0x42>
8000ae8c:	c0 78       	rjmp	8000ae9a <__mdiff+0x36>
8000ae8e:	1c 38       	cp.w	r8,lr
8000ae90:	fe 9b ff f9 	brhi	8000ae82 <__mdiff+0x1e>
8000ae94:	c4 98       	rjmp	8000af26 <__mdiff+0xc2>
8000ae96:	58 05       	cp.w	r5,0
8000ae98:	c0 64       	brge	8000aea4 <__mdiff+0x40>
8000ae9a:	0e 98       	mov	r8,r7
8000ae9c:	30 15       	mov	r5,1
8000ae9e:	0c 97       	mov	r7,r6
8000aea0:	10 96       	mov	r6,r8
8000aea2:	c0 28       	rjmp	8000aea6 <__mdiff+0x42>
8000aea4:	30 05       	mov	r5,0
8000aea6:	6e 1b       	ld.w	r11,r7[0x4]
8000aea8:	c5 6f       	rcall	8000ad54 <_Balloc>
8000aeaa:	6e 49       	ld.w	r9,r7[0x10]
8000aeac:	6c 44       	ld.w	r4,r6[0x10]
8000aeae:	99 35       	st.w	r12[0xc],r5
8000aeb0:	2f b4       	sub	r4,-5
8000aeb2:	f2 c5 ff fb 	sub	r5,r9,-5
8000aeb6:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000aeba:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000aebe:	2e c6       	sub	r6,-20
8000aec0:	2e c7       	sub	r7,-20
8000aec2:	f8 c8 ff ec 	sub	r8,r12,-20
8000aec6:	30 0a       	mov	r10,0
8000aec8:	0f 0e       	ld.w	lr,r7++
8000aeca:	0d 0b       	ld.w	r11,r6++
8000aecc:	fc 02 16 10 	lsr	r2,lr,0x10
8000aed0:	f6 03 16 10 	lsr	r3,r11,0x10
8000aed4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000aed8:	e4 03 01 03 	sub	r3,r2,r3
8000aedc:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000aee0:	fc 0b 01 0b 	sub	r11,lr,r11
8000aee4:	f6 0a 00 0a 	add	r10,r11,r10
8000aee8:	b0 1a       	st.h	r8[0x2],r10
8000aeea:	b1 4a       	asr	r10,0x10
8000aeec:	e6 0a 00 0a 	add	r10,r3,r10
8000aef0:	b0 0a       	st.h	r8[0x0],r10
8000aef2:	2f c8       	sub	r8,-4
8000aef4:	b1 4a       	asr	r10,0x10
8000aef6:	08 36       	cp.w	r6,r4
8000aef8:	ce 83       	brcs	8000aec8 <__mdiff+0x64>
8000aefa:	c0 d8       	rjmp	8000af14 <__mdiff+0xb0>
8000aefc:	0f 0b       	ld.w	r11,r7++
8000aefe:	f6 0e 16 10 	lsr	lr,r11,0x10
8000af02:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000af06:	16 0a       	add	r10,r11
8000af08:	b0 1a       	st.h	r8[0x2],r10
8000af0a:	b1 4a       	asr	r10,0x10
8000af0c:	1c 0a       	add	r10,lr
8000af0e:	b0 0a       	st.h	r8[0x0],r10
8000af10:	2f c8       	sub	r8,-4
8000af12:	b1 4a       	asr	r10,0x10
8000af14:	0a 37       	cp.w	r7,r5
8000af16:	cf 33       	brcs	8000aefc <__mdiff+0x98>
8000af18:	c0 28       	rjmp	8000af1c <__mdiff+0xb8>
8000af1a:	20 19       	sub	r9,1
8000af1c:	11 4a       	ld.w	r10,--r8
8000af1e:	58 0a       	cp.w	r10,0
8000af20:	cf d0       	breq	8000af1a <__mdiff+0xb6>
8000af22:	99 49       	st.w	r12[0x10],r9
8000af24:	d8 32       	popm	r0-r7,pc
8000af26:	30 0b       	mov	r11,0
8000af28:	c1 6f       	rcall	8000ad54 <_Balloc>
8000af2a:	30 18       	mov	r8,1
8000af2c:	99 48       	st.w	r12[0x10],r8
8000af2e:	30 08       	mov	r8,0
8000af30:	99 58       	st.w	r12[0x14],r8
8000af32:	d8 32       	popm	r0-r7,pc

8000af34 <__lshift>:
8000af34:	d4 31       	pushm	r0-r7,lr
8000af36:	16 97       	mov	r7,r11
8000af38:	76 46       	ld.w	r6,r11[0x10]
8000af3a:	f4 02 14 05 	asr	r2,r10,0x5
8000af3e:	2f f6       	sub	r6,-1
8000af40:	14 93       	mov	r3,r10
8000af42:	18 94       	mov	r4,r12
8000af44:	04 06       	add	r6,r2
8000af46:	76 1b       	ld.w	r11,r11[0x4]
8000af48:	6e 28       	ld.w	r8,r7[0x8]
8000af4a:	c0 38       	rjmp	8000af50 <__lshift+0x1c>
8000af4c:	2f fb       	sub	r11,-1
8000af4e:	a1 78       	lsl	r8,0x1
8000af50:	10 36       	cp.w	r6,r8
8000af52:	fe 99 ff fd 	brgt	8000af4c <__lshift+0x18>
8000af56:	08 9c       	mov	r12,r4
8000af58:	cf ee       	rcall	8000ad54 <_Balloc>
8000af5a:	30 09       	mov	r9,0
8000af5c:	18 95       	mov	r5,r12
8000af5e:	f8 c8 ff ec 	sub	r8,r12,-20
8000af62:	12 9a       	mov	r10,r9
8000af64:	c0 38       	rjmp	8000af6a <__lshift+0x36>
8000af66:	10 aa       	st.w	r8++,r10
8000af68:	2f f9       	sub	r9,-1
8000af6a:	04 39       	cp.w	r9,r2
8000af6c:	cf d5       	brlt	8000af66 <__lshift+0x32>
8000af6e:	6e 4b       	ld.w	r11,r7[0x10]
8000af70:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000af74:	2f bb       	sub	r11,-5
8000af76:	ee c9 ff ec 	sub	r9,r7,-20
8000af7a:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000af7e:	58 03       	cp.w	r3,0
8000af80:	c1 30       	breq	8000afa6 <__lshift+0x72>
8000af82:	e6 0c 11 20 	rsub	r12,r3,32
8000af86:	30 0a       	mov	r10,0
8000af88:	72 02       	ld.w	r2,r9[0x0]
8000af8a:	e4 03 09 42 	lsl	r2,r2,r3
8000af8e:	04 4a       	or	r10,r2
8000af90:	10 aa       	st.w	r8++,r10
8000af92:	13 0a       	ld.w	r10,r9++
8000af94:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000af98:	16 39       	cp.w	r9,r11
8000af9a:	cf 73       	brcs	8000af88 <__lshift+0x54>
8000af9c:	91 0a       	st.w	r8[0x0],r10
8000af9e:	58 0a       	cp.w	r10,0
8000afa0:	c0 70       	breq	8000afae <__lshift+0x7a>
8000afa2:	2f f6       	sub	r6,-1
8000afa4:	c0 58       	rjmp	8000afae <__lshift+0x7a>
8000afa6:	13 0a       	ld.w	r10,r9++
8000afa8:	10 aa       	st.w	r8++,r10
8000afaa:	16 39       	cp.w	r9,r11
8000afac:	cf d3       	brcs	8000afa6 <__lshift+0x72>
8000afae:	08 9c       	mov	r12,r4
8000afb0:	20 16       	sub	r6,1
8000afb2:	0e 9b       	mov	r11,r7
8000afb4:	8b 46       	st.w	r5[0x10],r6
8000afb6:	cb 5e       	rcall	8000ad20 <_Bfree>
8000afb8:	0a 9c       	mov	r12,r5
8000afba:	d8 32       	popm	r0-r7,pc

8000afbc <__multiply>:
8000afbc:	d4 31       	pushm	r0-r7,lr
8000afbe:	20 2d       	sub	sp,8
8000afc0:	76 49       	ld.w	r9,r11[0x10]
8000afc2:	74 48       	ld.w	r8,r10[0x10]
8000afc4:	16 96       	mov	r6,r11
8000afc6:	14 95       	mov	r5,r10
8000afc8:	10 39       	cp.w	r9,r8
8000afca:	ec 08 17 50 	movlt	r8,r6
8000afce:	ea 06 17 50 	movlt	r6,r5
8000afd2:	f0 05 17 50 	movlt	r5,r8
8000afd6:	6c 28       	ld.w	r8,r6[0x8]
8000afd8:	76 43       	ld.w	r3,r11[0x10]
8000afda:	74 42       	ld.w	r2,r10[0x10]
8000afdc:	76 1b       	ld.w	r11,r11[0x4]
8000afde:	e4 03 00 07 	add	r7,r2,r3
8000afe2:	10 37       	cp.w	r7,r8
8000afe4:	f7 bb 09 ff 	subgt	r11,-1
8000afe8:	cb 6e       	rcall	8000ad54 <_Balloc>
8000afea:	ee c4 ff fb 	sub	r4,r7,-5
8000afee:	f8 c9 ff ec 	sub	r9,r12,-20
8000aff2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000aff6:	30 0a       	mov	r10,0
8000aff8:	12 98       	mov	r8,r9
8000affa:	c0 28       	rjmp	8000affe <__multiply+0x42>
8000affc:	10 aa       	st.w	r8++,r10
8000affe:	08 38       	cp.w	r8,r4
8000b000:	cf e3       	brcs	8000affc <__multiply+0x40>
8000b002:	2f b3       	sub	r3,-5
8000b004:	2f b2       	sub	r2,-5
8000b006:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b00a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b00e:	ec cb ff ec 	sub	r11,r6,-20
8000b012:	50 12       	stdsp	sp[0x4],r2
8000b014:	ea ca ff ec 	sub	r10,r5,-20
8000b018:	c4 48       	rjmp	8000b0a0 <__multiply+0xe4>
8000b01a:	94 95       	ld.uh	r5,r10[0x2]
8000b01c:	58 05       	cp.w	r5,0
8000b01e:	c2 00       	breq	8000b05e <__multiply+0xa2>
8000b020:	12 98       	mov	r8,r9
8000b022:	16 96       	mov	r6,r11
8000b024:	30 0e       	mov	lr,0
8000b026:	50 09       	stdsp	sp[0x0],r9
8000b028:	0d 02       	ld.w	r2,r6++
8000b02a:	e4 00 16 10 	lsr	r0,r2,0x10
8000b02e:	70 01       	ld.w	r1,r8[0x0]
8000b030:	70 09       	ld.w	r9,r8[0x0]
8000b032:	b1 81       	lsr	r1,0x10
8000b034:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b038:	e0 05 03 41 	mac	r1,r0,r5
8000b03c:	ab 32       	mul	r2,r5
8000b03e:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b042:	00 02       	add	r2,r0
8000b044:	e4 0e 00 0e 	add	lr,r2,lr
8000b048:	b0 1e       	st.h	r8[0x2],lr
8000b04a:	b1 8e       	lsr	lr,0x10
8000b04c:	1c 01       	add	r1,lr
8000b04e:	b0 01       	st.h	r8[0x0],r1
8000b050:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b054:	2f c8       	sub	r8,-4
8000b056:	06 36       	cp.w	r6,r3
8000b058:	ce 83       	brcs	8000b028 <__multiply+0x6c>
8000b05a:	40 09       	lddsp	r9,sp[0x0]
8000b05c:	91 0e       	st.w	r8[0x0],lr
8000b05e:	94 86       	ld.uh	r6,r10[0x0]
8000b060:	58 06       	cp.w	r6,0
8000b062:	c1 d0       	breq	8000b09c <__multiply+0xe0>
8000b064:	72 02       	ld.w	r2,r9[0x0]
8000b066:	12 98       	mov	r8,r9
8000b068:	16 9e       	mov	lr,r11
8000b06a:	30 05       	mov	r5,0
8000b06c:	b0 12       	st.h	r8[0x2],r2
8000b06e:	1d 01       	ld.w	r1,lr++
8000b070:	90 82       	ld.uh	r2,r8[0x0]
8000b072:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b076:	ad 30       	mul	r0,r6
8000b078:	e0 02 00 02 	add	r2,r0,r2
8000b07c:	e4 05 00 05 	add	r5,r2,r5
8000b080:	b0 05       	st.h	r8[0x0],r5
8000b082:	b1 85       	lsr	r5,0x10
8000b084:	b1 81       	lsr	r1,0x10
8000b086:	2f c8       	sub	r8,-4
8000b088:	ad 31       	mul	r1,r6
8000b08a:	90 92       	ld.uh	r2,r8[0x2]
8000b08c:	e2 02 00 02 	add	r2,r1,r2
8000b090:	0a 02       	add	r2,r5
8000b092:	e4 05 16 10 	lsr	r5,r2,0x10
8000b096:	06 3e       	cp.w	lr,r3
8000b098:	ce a3       	brcs	8000b06c <__multiply+0xb0>
8000b09a:	91 02       	st.w	r8[0x0],r2
8000b09c:	2f ca       	sub	r10,-4
8000b09e:	2f c9       	sub	r9,-4
8000b0a0:	40 18       	lddsp	r8,sp[0x4]
8000b0a2:	10 3a       	cp.w	r10,r8
8000b0a4:	cb b3       	brcs	8000b01a <__multiply+0x5e>
8000b0a6:	c0 28       	rjmp	8000b0aa <__multiply+0xee>
8000b0a8:	20 17       	sub	r7,1
8000b0aa:	58 07       	cp.w	r7,0
8000b0ac:	e0 8a 00 05 	brle	8000b0b6 <__multiply+0xfa>
8000b0b0:	09 48       	ld.w	r8,--r4
8000b0b2:	58 08       	cp.w	r8,0
8000b0b4:	cf a0       	breq	8000b0a8 <__multiply+0xec>
8000b0b6:	99 47       	st.w	r12[0x10],r7
8000b0b8:	2f ed       	sub	sp,-8
8000b0ba:	d8 32       	popm	r0-r7,pc

8000b0bc <__i2b>:
8000b0bc:	d4 21       	pushm	r4-r7,lr
8000b0be:	16 97       	mov	r7,r11
8000b0c0:	30 1b       	mov	r11,1
8000b0c2:	c4 9e       	rcall	8000ad54 <_Balloc>
8000b0c4:	30 19       	mov	r9,1
8000b0c6:	99 57       	st.w	r12[0x14],r7
8000b0c8:	99 49       	st.w	r12[0x10],r9
8000b0ca:	d8 22       	popm	r4-r7,pc

8000b0cc <__multadd>:
8000b0cc:	d4 31       	pushm	r0-r7,lr
8000b0ce:	30 08       	mov	r8,0
8000b0d0:	12 95       	mov	r5,r9
8000b0d2:	16 97       	mov	r7,r11
8000b0d4:	18 96       	mov	r6,r12
8000b0d6:	76 44       	ld.w	r4,r11[0x10]
8000b0d8:	f6 c9 ff ec 	sub	r9,r11,-20
8000b0dc:	72 0b       	ld.w	r11,r9[0x0]
8000b0de:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b0e2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b0e6:	f4 0c 02 4c 	mul	r12,r10,r12
8000b0ea:	f4 0b 03 45 	mac	r5,r10,r11
8000b0ee:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b0f2:	b1 85       	lsr	r5,0x10
8000b0f4:	18 05       	add	r5,r12
8000b0f6:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b0fa:	f8 0b 00 0b 	add	r11,r12,r11
8000b0fe:	12 ab       	st.w	r9++,r11
8000b100:	2f f8       	sub	r8,-1
8000b102:	b1 85       	lsr	r5,0x10
8000b104:	08 38       	cp.w	r8,r4
8000b106:	ce b5       	brlt	8000b0dc <__multadd+0x10>
8000b108:	58 05       	cp.w	r5,0
8000b10a:	c1 c0       	breq	8000b142 <__multadd+0x76>
8000b10c:	6e 28       	ld.w	r8,r7[0x8]
8000b10e:	10 34       	cp.w	r4,r8
8000b110:	c1 35       	brlt	8000b136 <__multadd+0x6a>
8000b112:	6e 1b       	ld.w	r11,r7[0x4]
8000b114:	0c 9c       	mov	r12,r6
8000b116:	2f fb       	sub	r11,-1
8000b118:	c1 ee       	rcall	8000ad54 <_Balloc>
8000b11a:	6e 4a       	ld.w	r10,r7[0x10]
8000b11c:	ee cb ff f4 	sub	r11,r7,-12
8000b120:	18 93       	mov	r3,r12
8000b122:	2f ea       	sub	r10,-2
8000b124:	2f 4c       	sub	r12,-12
8000b126:	a3 6a       	lsl	r10,0x2
8000b128:	fe b0 de 64 	rcall	80006df0 <memcpy>
8000b12c:	0e 9b       	mov	r11,r7
8000b12e:	0c 9c       	mov	r12,r6
8000b130:	fe b0 fd f8 	rcall	8000ad20 <_Bfree>
8000b134:	06 97       	mov	r7,r3
8000b136:	e8 c8 ff ff 	sub	r8,r4,-1
8000b13a:	2f b4       	sub	r4,-5
8000b13c:	8f 48       	st.w	r7[0x10],r8
8000b13e:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b142:	0e 9c       	mov	r12,r7
8000b144:	d8 32       	popm	r0-r7,pc
8000b146:	d7 03       	nop

8000b148 <__pow5mult>:
8000b148:	d4 31       	pushm	r0-r7,lr
8000b14a:	14 96       	mov	r6,r10
8000b14c:	18 97       	mov	r7,r12
8000b14e:	16 94       	mov	r4,r11
8000b150:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b154:	c0 90       	breq	8000b166 <__pow5mult+0x1e>
8000b156:	20 18       	sub	r8,1
8000b158:	fe c9 d4 f4 	sub	r9,pc,-11020
8000b15c:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b160:	30 09       	mov	r9,0
8000b162:	cb 5f       	rcall	8000b0cc <__multadd>
8000b164:	18 94       	mov	r4,r12
8000b166:	a3 46       	asr	r6,0x2
8000b168:	c3 40       	breq	8000b1d0 <__pow5mult+0x88>
8000b16a:	6e 95       	ld.w	r5,r7[0x24]
8000b16c:	58 05       	cp.w	r5,0
8000b16e:	c0 91       	brne	8000b180 <__pow5mult+0x38>
8000b170:	31 0c       	mov	r12,16
8000b172:	fe b0 dc 1b 	rcall	800069a8 <malloc>
8000b176:	99 35       	st.w	r12[0xc],r5
8000b178:	8f 9c       	st.w	r7[0x24],r12
8000b17a:	99 15       	st.w	r12[0x4],r5
8000b17c:	99 25       	st.w	r12[0x8],r5
8000b17e:	99 05       	st.w	r12[0x0],r5
8000b180:	6e 93       	ld.w	r3,r7[0x24]
8000b182:	66 25       	ld.w	r5,r3[0x8]
8000b184:	58 05       	cp.w	r5,0
8000b186:	c0 c1       	brne	8000b19e <__pow5mult+0x56>
8000b188:	e0 6b 02 71 	mov	r11,625
8000b18c:	0e 9c       	mov	r12,r7
8000b18e:	c9 7f       	rcall	8000b0bc <__i2b>
8000b190:	87 2c       	st.w	r3[0x8],r12
8000b192:	30 08       	mov	r8,0
8000b194:	18 95       	mov	r5,r12
8000b196:	99 08       	st.w	r12[0x0],r8
8000b198:	c0 38       	rjmp	8000b19e <__pow5mult+0x56>
8000b19a:	06 9c       	mov	r12,r3
8000b19c:	18 95       	mov	r5,r12
8000b19e:	ed b6 00 00 	bld	r6,0x0
8000b1a2:	c0 b1       	brne	8000b1b8 <__pow5mult+0x70>
8000b1a4:	08 9b       	mov	r11,r4
8000b1a6:	0a 9a       	mov	r10,r5
8000b1a8:	0e 9c       	mov	r12,r7
8000b1aa:	c0 9f       	rcall	8000afbc <__multiply>
8000b1ac:	08 9b       	mov	r11,r4
8000b1ae:	18 93       	mov	r3,r12
8000b1b0:	0e 9c       	mov	r12,r7
8000b1b2:	06 94       	mov	r4,r3
8000b1b4:	fe b0 fd b6 	rcall	8000ad20 <_Bfree>
8000b1b8:	a1 56       	asr	r6,0x1
8000b1ba:	c0 b0       	breq	8000b1d0 <__pow5mult+0x88>
8000b1bc:	6a 03       	ld.w	r3,r5[0x0]
8000b1be:	58 03       	cp.w	r3,0
8000b1c0:	ce d1       	brne	8000b19a <__pow5mult+0x52>
8000b1c2:	0a 9a       	mov	r10,r5
8000b1c4:	0a 9b       	mov	r11,r5
8000b1c6:	0e 9c       	mov	r12,r7
8000b1c8:	cf ae       	rcall	8000afbc <__multiply>
8000b1ca:	8b 0c       	st.w	r5[0x0],r12
8000b1cc:	99 03       	st.w	r12[0x0],r3
8000b1ce:	ce 7b       	rjmp	8000b19c <__pow5mult+0x54>
8000b1d0:	08 9c       	mov	r12,r4
8000b1d2:	d8 32       	popm	r0-r7,pc

8000b1d4 <__isinfd>:
8000b1d4:	14 98       	mov	r8,r10
8000b1d6:	fc 19 7f f0 	movh	r9,0x7ff0
8000b1da:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b1de:	f0 0b 11 00 	rsub	r11,r8,0
8000b1e2:	f7 e8 10 08 	or	r8,r11,r8
8000b1e6:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000b1ea:	f2 08 01 08 	sub	r8,r9,r8
8000b1ee:	f0 0c 11 00 	rsub	r12,r8,0
8000b1f2:	f9 e8 10 08 	or	r8,r12,r8
8000b1f6:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000b1fa:	2f fc       	sub	r12,-1
8000b1fc:	5e fc       	retal	r12

8000b1fe <__isnand>:
8000b1fe:	14 98       	mov	r8,r10
8000b200:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000b204:	f0 0c 11 00 	rsub	r12,r8,0
8000b208:	10 4c       	or	r12,r8
8000b20a:	fc 18 7f f0 	movh	r8,0x7ff0
8000b20e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000b212:	f0 0c 01 0c 	sub	r12,r8,r12
8000b216:	bf 9c       	lsr	r12,0x1f
8000b218:	5e fc       	retal	r12
8000b21a:	d7 03       	nop

8000b21c <__sclose>:
8000b21c:	d4 01       	pushm	lr
8000b21e:	96 7b       	ld.sh	r11,r11[0xe]
8000b220:	c7 6c       	rcall	8000b30c <_close_r>
8000b222:	d8 02       	popm	pc

8000b224 <__sseek>:
8000b224:	d4 21       	pushm	r4-r7,lr
8000b226:	16 97       	mov	r7,r11
8000b228:	96 7b       	ld.sh	r11,r11[0xe]
8000b22a:	cf 7c       	rcall	8000b418 <_lseek_r>
8000b22c:	8e 68       	ld.sh	r8,r7[0xc]
8000b22e:	10 99       	mov	r9,r8
8000b230:	ad c8       	cbr	r8,0xc
8000b232:	ad a9       	sbr	r9,0xc
8000b234:	5b fc       	cp.w	r12,-1
8000b236:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000b23a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000b23e:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000b242:	d8 22       	popm	r4-r7,pc

8000b244 <__swrite>:
8000b244:	d4 21       	pushm	r4-r7,lr
8000b246:	96 68       	ld.sh	r8,r11[0xc]
8000b248:	16 97       	mov	r7,r11
8000b24a:	14 95       	mov	r5,r10
8000b24c:	12 94       	mov	r4,r9
8000b24e:	e2 18 01 00 	andl	r8,0x100,COH
8000b252:	18 96       	mov	r6,r12
8000b254:	c0 50       	breq	8000b25e <__swrite+0x1a>
8000b256:	30 29       	mov	r9,2
8000b258:	30 0a       	mov	r10,0
8000b25a:	96 7b       	ld.sh	r11,r11[0xe]
8000b25c:	cd ec       	rcall	8000b418 <_lseek_r>
8000b25e:	8e 68       	ld.sh	r8,r7[0xc]
8000b260:	ad c8       	cbr	r8,0xc
8000b262:	08 99       	mov	r9,r4
8000b264:	0a 9a       	mov	r10,r5
8000b266:	8e 7b       	ld.sh	r11,r7[0xe]
8000b268:	0c 9c       	mov	r12,r6
8000b26a:	ae 68       	st.h	r7[0xc],r8
8000b26c:	c1 0c       	rcall	8000b28c <_write_r>
8000b26e:	d8 22       	popm	r4-r7,pc

8000b270 <__sread>:
8000b270:	d4 21       	pushm	r4-r7,lr
8000b272:	16 97       	mov	r7,r11
8000b274:	96 7b       	ld.sh	r11,r11[0xe]
8000b276:	ce 5c       	rcall	8000b440 <_read_r>
8000b278:	c0 65       	brlt	8000b284 <__sread+0x14>
8000b27a:	6f 58       	ld.w	r8,r7[0x54]
8000b27c:	18 08       	add	r8,r12
8000b27e:	ef 48 00 54 	st.w	r7[84],r8
8000b282:	d8 22       	popm	r4-r7,pc
8000b284:	8e 68       	ld.sh	r8,r7[0xc]
8000b286:	ad c8       	cbr	r8,0xc
8000b288:	ae 68       	st.h	r7[0xc],r8
8000b28a:	d8 22       	popm	r4-r7,pc

8000b28c <_write_r>:
8000b28c:	d4 21       	pushm	r4-r7,lr
8000b28e:	16 98       	mov	r8,r11
8000b290:	18 97       	mov	r7,r12
8000b292:	10 9c       	mov	r12,r8
8000b294:	30 08       	mov	r8,0
8000b296:	14 9b       	mov	r11,r10
8000b298:	e0 66 41 14 	mov	r6,16660
8000b29c:	12 9a       	mov	r10,r9
8000b29e:	8d 08       	st.w	r6[0x0],r8
8000b2a0:	fe b0 d1 24 	rcall	800054e8 <_write>
8000b2a4:	5b fc       	cp.w	r12,-1
8000b2a6:	c0 51       	brne	8000b2b0 <_write_r+0x24>
8000b2a8:	6c 08       	ld.w	r8,r6[0x0]
8000b2aa:	58 08       	cp.w	r8,0
8000b2ac:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b2b0:	d8 22       	popm	r4-r7,pc
8000b2b2:	d7 03       	nop

8000b2b4 <_calloc_r>:
8000b2b4:	d4 21       	pushm	r4-r7,lr
8000b2b6:	f4 0b 02 4b 	mul	r11,r10,r11
8000b2ba:	fe b0 db 7f 	rcall	800069b8 <_malloc_r>
8000b2be:	18 97       	mov	r7,r12
8000b2c0:	c2 30       	breq	8000b306 <_calloc_r+0x52>
8000b2c2:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000b2c6:	e0 1a ff fc 	andl	r10,0xfffc
8000b2ca:	20 4a       	sub	r10,4
8000b2cc:	e0 4a 00 24 	cp.w	r10,36
8000b2d0:	e0 8b 00 18 	brhi	8000b300 <_calloc_r+0x4c>
8000b2d4:	18 98       	mov	r8,r12
8000b2d6:	59 3a       	cp.w	r10,19
8000b2d8:	e0 88 00 0f 	brls	8000b2f6 <_calloc_r+0x42>
8000b2dc:	30 09       	mov	r9,0
8000b2de:	10 a9       	st.w	r8++,r9
8000b2e0:	10 a9       	st.w	r8++,r9
8000b2e2:	59 ba       	cp.w	r10,27
8000b2e4:	e0 88 00 09 	brls	8000b2f6 <_calloc_r+0x42>
8000b2e8:	10 a9       	st.w	r8++,r9
8000b2ea:	10 a9       	st.w	r8++,r9
8000b2ec:	e0 4a 00 24 	cp.w	r10,36
8000b2f0:	c0 31       	brne	8000b2f6 <_calloc_r+0x42>
8000b2f2:	10 a9       	st.w	r8++,r9
8000b2f4:	10 a9       	st.w	r8++,r9
8000b2f6:	30 09       	mov	r9,0
8000b2f8:	10 a9       	st.w	r8++,r9
8000b2fa:	91 19       	st.w	r8[0x4],r9
8000b2fc:	91 09       	st.w	r8[0x0],r9
8000b2fe:	c0 48       	rjmp	8000b306 <_calloc_r+0x52>
8000b300:	30 0b       	mov	r11,0
8000b302:	fe b0 de 1b 	rcall	80006f38 <memset>
8000b306:	0e 9c       	mov	r12,r7
8000b308:	d8 22       	popm	r4-r7,pc
8000b30a:	d7 03       	nop

8000b30c <_close_r>:
8000b30c:	d4 21       	pushm	r4-r7,lr
8000b30e:	30 08       	mov	r8,0
8000b310:	18 97       	mov	r7,r12
8000b312:	e0 66 41 14 	mov	r6,16660
8000b316:	16 9c       	mov	r12,r11
8000b318:	8d 08       	st.w	r6[0x0],r8
8000b31a:	fe b0 df c1 	rcall	8000729c <_close>
8000b31e:	5b fc       	cp.w	r12,-1
8000b320:	c0 51       	brne	8000b32a <_close_r+0x1e>
8000b322:	6c 08       	ld.w	r8,r6[0x0]
8000b324:	58 08       	cp.w	r8,0
8000b326:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b32a:	d8 22       	popm	r4-r7,pc

8000b32c <_fclose_r>:
8000b32c:	d4 21       	pushm	r4-r7,lr
8000b32e:	18 96       	mov	r6,r12
8000b330:	16 97       	mov	r7,r11
8000b332:	58 0b       	cp.w	r11,0
8000b334:	c0 31       	brne	8000b33a <_fclose_r+0xe>
8000b336:	16 95       	mov	r5,r11
8000b338:	c5 38       	rjmp	8000b3de <_fclose_r+0xb2>
8000b33a:	fe b0 f8 b5 	rcall	8000a4a4 <__sfp_lock_acquire>
8000b33e:	58 06       	cp.w	r6,0
8000b340:	c0 70       	breq	8000b34e <_fclose_r+0x22>
8000b342:	6c 68       	ld.w	r8,r6[0x18]
8000b344:	58 08       	cp.w	r8,0
8000b346:	c0 41       	brne	8000b34e <_fclose_r+0x22>
8000b348:	0c 9c       	mov	r12,r6
8000b34a:	fe b0 f8 ff 	rcall	8000a548 <__sinit>
8000b34e:	fe c8 d7 8e 	sub	r8,pc,-10354
8000b352:	10 37       	cp.w	r7,r8
8000b354:	c0 31       	brne	8000b35a <_fclose_r+0x2e>
8000b356:	6c 07       	ld.w	r7,r6[0x0]
8000b358:	c0 c8       	rjmp	8000b370 <_fclose_r+0x44>
8000b35a:	fe c8 d7 7a 	sub	r8,pc,-10374
8000b35e:	10 37       	cp.w	r7,r8
8000b360:	c0 31       	brne	8000b366 <_fclose_r+0x3a>
8000b362:	6c 17       	ld.w	r7,r6[0x4]
8000b364:	c0 68       	rjmp	8000b370 <_fclose_r+0x44>
8000b366:	fe c8 d7 66 	sub	r8,pc,-10394
8000b36a:	10 37       	cp.w	r7,r8
8000b36c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b370:	8e 69       	ld.sh	r9,r7[0xc]
8000b372:	30 08       	mov	r8,0
8000b374:	f0 09 19 00 	cp.h	r9,r8
8000b378:	c0 51       	brne	8000b382 <_fclose_r+0x56>
8000b37a:	fe b0 f8 96 	rcall	8000a4a6 <__sfp_lock_release>
8000b37e:	30 05       	mov	r5,0
8000b380:	c2 f8       	rjmp	8000b3de <_fclose_r+0xb2>
8000b382:	0e 9b       	mov	r11,r7
8000b384:	0c 9c       	mov	r12,r6
8000b386:	fe b0 f8 09 	rcall	8000a398 <_fflush_r>
8000b38a:	6e c8       	ld.w	r8,r7[0x30]
8000b38c:	18 95       	mov	r5,r12
8000b38e:	58 08       	cp.w	r8,0
8000b390:	c0 60       	breq	8000b39c <_fclose_r+0x70>
8000b392:	6e 8b       	ld.w	r11,r7[0x20]
8000b394:	0c 9c       	mov	r12,r6
8000b396:	5d 18       	icall	r8
8000b398:	f9 b5 05 ff 	movlt	r5,-1
8000b39c:	8e 68       	ld.sh	r8,r7[0xc]
8000b39e:	ed b8 00 07 	bld	r8,0x7
8000b3a2:	c0 51       	brne	8000b3ac <_fclose_r+0x80>
8000b3a4:	6e 4b       	ld.w	r11,r7[0x10]
8000b3a6:	0c 9c       	mov	r12,r6
8000b3a8:	fe b0 f9 6a 	rcall	8000a67c <_free_r>
8000b3ac:	6e db       	ld.w	r11,r7[0x34]
8000b3ae:	58 0b       	cp.w	r11,0
8000b3b0:	c0 a0       	breq	8000b3c4 <_fclose_r+0x98>
8000b3b2:	ee c8 ff bc 	sub	r8,r7,-68
8000b3b6:	10 3b       	cp.w	r11,r8
8000b3b8:	c0 40       	breq	8000b3c0 <_fclose_r+0x94>
8000b3ba:	0c 9c       	mov	r12,r6
8000b3bc:	fe b0 f9 60 	rcall	8000a67c <_free_r>
8000b3c0:	30 08       	mov	r8,0
8000b3c2:	8f d8       	st.w	r7[0x34],r8
8000b3c4:	6f 2b       	ld.w	r11,r7[0x48]
8000b3c6:	58 0b       	cp.w	r11,0
8000b3c8:	c0 70       	breq	8000b3d6 <_fclose_r+0xaa>
8000b3ca:	0c 9c       	mov	r12,r6
8000b3cc:	fe b0 f9 58 	rcall	8000a67c <_free_r>
8000b3d0:	30 08       	mov	r8,0
8000b3d2:	ef 48 00 48 	st.w	r7[72],r8
8000b3d6:	30 08       	mov	r8,0
8000b3d8:	ae 68       	st.h	r7[0xc],r8
8000b3da:	fe b0 f8 66 	rcall	8000a4a6 <__sfp_lock_release>
8000b3de:	0a 9c       	mov	r12,r5
8000b3e0:	d8 22       	popm	r4-r7,pc
8000b3e2:	d7 03       	nop

8000b3e4 <fclose>:
8000b3e4:	d4 01       	pushm	lr
8000b3e6:	e0 68 0a 38 	mov	r8,2616
8000b3ea:	18 9b       	mov	r11,r12
8000b3ec:	70 0c       	ld.w	r12,r8[0x0]
8000b3ee:	c9 ff       	rcall	8000b32c <_fclose_r>
8000b3f0:	d8 02       	popm	pc
8000b3f2:	d7 03       	nop

8000b3f4 <_fstat_r>:
8000b3f4:	d4 21       	pushm	r4-r7,lr
8000b3f6:	16 98       	mov	r8,r11
8000b3f8:	18 97       	mov	r7,r12
8000b3fa:	10 9c       	mov	r12,r8
8000b3fc:	30 08       	mov	r8,0
8000b3fe:	e0 66 41 14 	mov	r6,16660
8000b402:	14 9b       	mov	r11,r10
8000b404:	8d 08       	st.w	r6[0x0],r8
8000b406:	fe b0 df 73 	rcall	800072ec <_fstat>
8000b40a:	5b fc       	cp.w	r12,-1
8000b40c:	c0 51       	brne	8000b416 <_fstat_r+0x22>
8000b40e:	6c 08       	ld.w	r8,r6[0x0]
8000b410:	58 08       	cp.w	r8,0
8000b412:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b416:	d8 22       	popm	r4-r7,pc

8000b418 <_lseek_r>:
8000b418:	d4 21       	pushm	r4-r7,lr
8000b41a:	16 98       	mov	r8,r11
8000b41c:	18 97       	mov	r7,r12
8000b41e:	10 9c       	mov	r12,r8
8000b420:	30 08       	mov	r8,0
8000b422:	14 9b       	mov	r11,r10
8000b424:	e0 66 41 14 	mov	r6,16660
8000b428:	12 9a       	mov	r10,r9
8000b42a:	8d 08       	st.w	r6[0x0],r8
8000b42c:	fe b0 df 42 	rcall	800072b0 <_lseek>
8000b430:	5b fc       	cp.w	r12,-1
8000b432:	c0 51       	brne	8000b43c <_lseek_r+0x24>
8000b434:	6c 08       	ld.w	r8,r6[0x0]
8000b436:	58 08       	cp.w	r8,0
8000b438:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b43c:	d8 22       	popm	r4-r7,pc
8000b43e:	d7 03       	nop

8000b440 <_read_r>:
8000b440:	d4 21       	pushm	r4-r7,lr
8000b442:	16 98       	mov	r8,r11
8000b444:	18 97       	mov	r7,r12
8000b446:	10 9c       	mov	r12,r8
8000b448:	30 08       	mov	r8,0
8000b44a:	14 9b       	mov	r11,r10
8000b44c:	e0 66 41 14 	mov	r6,16660
8000b450:	12 9a       	mov	r10,r9
8000b452:	8d 08       	st.w	r6[0x0],r8
8000b454:	fe b0 d0 2a 	rcall	800054a8 <_read>
8000b458:	5b fc       	cp.w	r12,-1
8000b45a:	c0 51       	brne	8000b464 <_read_r+0x24>
8000b45c:	6c 08       	ld.w	r8,r6[0x0]
8000b45e:	58 08       	cp.w	r8,0
8000b460:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000b464:	d8 22       	popm	r4-r7,pc
8000b466:	d7 03       	nop

8000b468 <__avr32_f64_mul>:
8000b468:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000b46c:	e0 80 00 dc 	breq	8000b624 <__avr32_f64_mul_op1_zero>
8000b470:	d4 21       	pushm	r4-r7,lr
8000b472:	f7 e9 20 0e 	eor	lr,r11,r9
8000b476:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b47a:	30 15       	mov	r5,1
8000b47c:	c4 30       	breq	8000b502 <__avr32_f64_mul_op1_subnormal>
8000b47e:	ab 6b       	lsl	r11,0xa
8000b480:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000b484:	ab 6a       	lsl	r10,0xa
8000b486:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000b48a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b48e:	c5 c0       	breq	8000b546 <__avr32_f64_mul_op2_subnormal>
8000b490:	a1 78       	lsl	r8,0x1
8000b492:	5c f9       	rol	r9
8000b494:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000b498:	e0 47 07 ff 	cp.w	r7,2047
8000b49c:	c7 70       	breq	8000b58a <__avr32_f64_mul_op_nan_or_inf>
8000b49e:	e0 46 07 ff 	cp.w	r6,2047
8000b4a2:	c7 40       	breq	8000b58a <__avr32_f64_mul_op_nan_or_inf>
8000b4a4:	ee 06 00 0c 	add	r12,r7,r6
8000b4a8:	e0 2c 03 fe 	sub	r12,1022
8000b4ac:	f6 08 06 44 	mulu.d	r4,r11,r8
8000b4b0:	f4 09 07 44 	macu.d	r4,r10,r9
8000b4b4:	f4 08 06 46 	mulu.d	r6,r10,r8
8000b4b8:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000b4bc:	08 07       	add	r7,r4
8000b4be:	f4 05 00 4a 	adc	r10,r10,r5
8000b4c2:	5c 0b       	acr	r11
8000b4c4:	ed bb 00 14 	bld	r11,0x14
8000b4c8:	c0 50       	breq	8000b4d2 <__avr32_f64_mul+0x6a>
8000b4ca:	a1 77       	lsl	r7,0x1
8000b4cc:	5c fa       	rol	r10
8000b4ce:	5c fb       	rol	r11
8000b4d0:	20 1c       	sub	r12,1
8000b4d2:	58 0c       	cp.w	r12,0
8000b4d4:	e0 8a 00 6f 	brle	8000b5b2 <__avr32_f64_mul_res_subnormal>
8000b4d8:	e0 4c 07 ff 	cp.w	r12,2047
8000b4dc:	e0 84 00 9c 	brge	8000b614 <__avr32_f64_mul_res_inf>
8000b4e0:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000b4e4:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000b4e8:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000b4ec:	ee 17 80 00 	eorh	r7,0x8000
8000b4f0:	f1 b7 04 20 	satu	r7,0x1
8000b4f4:	0e 0a       	add	r10,r7
8000b4f6:	5c 0b       	acr	r11
8000b4f8:	ed be 00 1f 	bld	lr,0x1f
8000b4fc:	ef bb 00 1f 	bst	r11,0x1f
8000b500:	d8 22       	popm	r4-r7,pc

8000b502 <__avr32_f64_mul_op1_subnormal>:
8000b502:	e4 1b 00 0f 	andh	r11,0xf
8000b506:	f4 0c 12 00 	clz	r12,r10
8000b50a:	f6 06 12 00 	clz	r6,r11
8000b50e:	f7 bc 03 e1 	sublo	r12,-31
8000b512:	f8 06 17 30 	movlo	r6,r12
8000b516:	f7 b6 02 01 	subhs	r6,1
8000b51a:	e0 46 00 20 	cp.w	r6,32
8000b51e:	c0 d4       	brge	8000b538 <__avr32_f64_mul_op1_subnormal+0x36>
8000b520:	ec 0c 11 20 	rsub	r12,r6,32
8000b524:	f6 06 09 4b 	lsl	r11,r11,r6
8000b528:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000b52c:	18 4b       	or	r11,r12
8000b52e:	f4 06 09 4a 	lsl	r10,r10,r6
8000b532:	20 b6       	sub	r6,11
8000b534:	0c 17       	sub	r7,r6
8000b536:	ca ab       	rjmp	8000b48a <__avr32_f64_mul+0x22>
8000b538:	f4 06 09 4b 	lsl	r11,r10,r6
8000b53c:	c6 40       	breq	8000b604 <__avr32_f64_mul_res_zero>
8000b53e:	30 0a       	mov	r10,0
8000b540:	20 b6       	sub	r6,11
8000b542:	0c 17       	sub	r7,r6
8000b544:	ca 3b       	rjmp	8000b48a <__avr32_f64_mul+0x22>

8000b546 <__avr32_f64_mul_op2_subnormal>:
8000b546:	e4 19 00 0f 	andh	r9,0xf
8000b54a:	f0 0c 12 00 	clz	r12,r8
8000b54e:	f2 05 12 00 	clz	r5,r9
8000b552:	f7 bc 03 ea 	sublo	r12,-22
8000b556:	f8 05 17 30 	movlo	r5,r12
8000b55a:	f7 b5 02 0a 	subhs	r5,10
8000b55e:	e0 45 00 20 	cp.w	r5,32
8000b562:	c0 d4       	brge	8000b57c <__avr32_f64_mul_op2_subnormal+0x36>
8000b564:	ea 0c 11 20 	rsub	r12,r5,32
8000b568:	f2 05 09 49 	lsl	r9,r9,r5
8000b56c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000b570:	18 49       	or	r9,r12
8000b572:	f0 05 09 48 	lsl	r8,r8,r5
8000b576:	20 25       	sub	r5,2
8000b578:	0a 16       	sub	r6,r5
8000b57a:	c8 fb       	rjmp	8000b498 <__avr32_f64_mul+0x30>
8000b57c:	f0 05 09 49 	lsl	r9,r8,r5
8000b580:	c4 20       	breq	8000b604 <__avr32_f64_mul_res_zero>
8000b582:	30 08       	mov	r8,0
8000b584:	20 25       	sub	r5,2
8000b586:	0a 16       	sub	r6,r5
8000b588:	c8 8b       	rjmp	8000b498 <__avr32_f64_mul+0x30>

8000b58a <__avr32_f64_mul_op_nan_or_inf>:
8000b58a:	e4 19 00 0f 	andh	r9,0xf
8000b58e:	e4 1b 00 0f 	andh	r11,0xf
8000b592:	14 4b       	or	r11,r10
8000b594:	10 49       	or	r9,r8
8000b596:	e0 47 07 ff 	cp.w	r7,2047
8000b59a:	c0 91       	brne	8000b5ac <__avr32_f64_mul_op1_not_naninf>
8000b59c:	58 0b       	cp.w	r11,0
8000b59e:	c3 81       	brne	8000b60e <__avr32_f64_mul_res_nan>
8000b5a0:	e0 46 07 ff 	cp.w	r6,2047
8000b5a4:	c3 81       	brne	8000b614 <__avr32_f64_mul_res_inf>
8000b5a6:	58 09       	cp.w	r9,0
8000b5a8:	c3 60       	breq	8000b614 <__avr32_f64_mul_res_inf>
8000b5aa:	c3 28       	rjmp	8000b60e <__avr32_f64_mul_res_nan>

8000b5ac <__avr32_f64_mul_op1_not_naninf>:
8000b5ac:	58 09       	cp.w	r9,0
8000b5ae:	c3 30       	breq	8000b614 <__avr32_f64_mul_res_inf>
8000b5b0:	c2 f8       	rjmp	8000b60e <__avr32_f64_mul_res_nan>

8000b5b2 <__avr32_f64_mul_res_subnormal>:
8000b5b2:	5c 3c       	neg	r12
8000b5b4:	2f fc       	sub	r12,-1
8000b5b6:	f1 bc 04 c0 	satu	r12,0x6
8000b5ba:	e0 4c 00 20 	cp.w	r12,32
8000b5be:	c1 14       	brge	8000b5e0 <__avr32_f64_mul_res_subnormal+0x2e>
8000b5c0:	f8 08 11 20 	rsub	r8,r12,32
8000b5c4:	0e 46       	or	r6,r7
8000b5c6:	ee 0c 0a 47 	lsr	r7,r7,r12
8000b5ca:	f4 08 09 49 	lsl	r9,r10,r8
8000b5ce:	12 47       	or	r7,r9
8000b5d0:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b5d4:	f6 08 09 49 	lsl	r9,r11,r8
8000b5d8:	12 4a       	or	r10,r9
8000b5da:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b5de:	c8 3b       	rjmp	8000b4e4 <__avr32_f64_mul+0x7c>
8000b5e0:	f8 08 11 20 	rsub	r8,r12,32
8000b5e4:	f9 b9 00 00 	moveq	r9,0
8000b5e8:	c0 30       	breq	8000b5ee <__avr32_f64_mul_res_subnormal+0x3c>
8000b5ea:	f6 08 09 49 	lsl	r9,r11,r8
8000b5ee:	0e 46       	or	r6,r7
8000b5f0:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000b5f4:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b5f8:	f3 ea 10 07 	or	r7,r9,r10
8000b5fc:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000b600:	30 0b       	mov	r11,0
8000b602:	c7 1b       	rjmp	8000b4e4 <__avr32_f64_mul+0x7c>

8000b604 <__avr32_f64_mul_res_zero>:
8000b604:	1c 9b       	mov	r11,lr
8000b606:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b60a:	30 0a       	mov	r10,0
8000b60c:	d8 22       	popm	r4-r7,pc

8000b60e <__avr32_f64_mul_res_nan>:
8000b60e:	3f fb       	mov	r11,-1
8000b610:	3f fa       	mov	r10,-1
8000b612:	d8 22       	popm	r4-r7,pc

8000b614 <__avr32_f64_mul_res_inf>:
8000b614:	f0 6b 00 00 	mov	r11,-1048576
8000b618:	ed be 00 1f 	bld	lr,0x1f
8000b61c:	ef bb 00 1f 	bst	r11,0x1f
8000b620:	30 0a       	mov	r10,0
8000b622:	d8 22       	popm	r4-r7,pc

8000b624 <__avr32_f64_mul_op1_zero>:
8000b624:	f7 e9 20 0b 	eor	r11,r11,r9
8000b628:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b62c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000b630:	e0 4c 07 ff 	cp.w	r12,2047
8000b634:	5e 1c       	retne	r12
8000b636:	3f fa       	mov	r10,-1
8000b638:	3f fb       	mov	r11,-1
8000b63a:	5e fc       	retal	r12

8000b63c <__avr32_f64_sub_from_add>:
8000b63c:	ee 19 80 00 	eorh	r9,0x8000

8000b640 <__avr32_f64_sub>:
8000b640:	f7 e9 20 0c 	eor	r12,r11,r9
8000b644:	e0 86 00 ca 	brmi	8000b7d8 <__avr32_f64_add_from_sub>
8000b648:	eb cd 40 e0 	pushm	r5-r7,lr
8000b64c:	16 9c       	mov	r12,r11
8000b64e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b652:	bf db       	cbr	r11,0x1f
8000b654:	bf d9       	cbr	r9,0x1f
8000b656:	10 3a       	cp.w	r10,r8
8000b658:	f2 0b 13 00 	cpc	r11,r9
8000b65c:	c0 92       	brcc	8000b66e <__avr32_f64_sub+0x2e>
8000b65e:	16 97       	mov	r7,r11
8000b660:	12 9b       	mov	r11,r9
8000b662:	0e 99       	mov	r9,r7
8000b664:	14 97       	mov	r7,r10
8000b666:	10 9a       	mov	r10,r8
8000b668:	0e 98       	mov	r8,r7
8000b66a:	ee 1c 80 00 	eorh	r12,0x8000
8000b66e:	f6 07 16 14 	lsr	r7,r11,0x14
8000b672:	ab 7b       	lsl	r11,0xb
8000b674:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b678:	ab 7a       	lsl	r10,0xb
8000b67a:	bf bb       	sbr	r11,0x1f
8000b67c:	f2 06 16 14 	lsr	r6,r9,0x14
8000b680:	c4 40       	breq	8000b708 <__avr32_f64_sub_opL_subnormal>
8000b682:	ab 79       	lsl	r9,0xb
8000b684:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b688:	ab 78       	lsl	r8,0xb
8000b68a:	bf b9       	sbr	r9,0x1f

8000b68c <__avr32_f64_sub_opL_subnormal_done>:
8000b68c:	e0 47 07 ff 	cp.w	r7,2047
8000b690:	c4 f0       	breq	8000b72e <__avr32_f64_sub_opH_nan_or_inf>
8000b692:	0e 26       	rsub	r6,r7
8000b694:	c1 20       	breq	8000b6b8 <__avr32_f64_sub_shift_done>
8000b696:	ec 05 11 20 	rsub	r5,r6,32
8000b69a:	e0 46 00 20 	cp.w	r6,32
8000b69e:	c7 c2       	brcc	8000b796 <__avr32_f64_sub_longshift>
8000b6a0:	f0 05 09 4e 	lsl	lr,r8,r5
8000b6a4:	f2 05 09 45 	lsl	r5,r9,r5
8000b6a8:	f0 06 0a 48 	lsr	r8,r8,r6
8000b6ac:	f2 06 0a 49 	lsr	r9,r9,r6
8000b6b0:	0a 48       	or	r8,r5
8000b6b2:	58 0e       	cp.w	lr,0
8000b6b4:	5f 1e       	srne	lr
8000b6b6:	1c 48       	or	r8,lr

8000b6b8 <__avr32_f64_sub_shift_done>:
8000b6b8:	10 1a       	sub	r10,r8
8000b6ba:	f6 09 01 4b 	sbc	r11,r11,r9
8000b6be:	f6 06 12 00 	clz	r6,r11
8000b6c2:	c0 e0       	breq	8000b6de <__avr32_f64_sub_longnormalize_done>
8000b6c4:	c7 83       	brcs	8000b7b4 <__avr32_f64_sub_longnormalize>
8000b6c6:	ec 0e 11 20 	rsub	lr,r6,32
8000b6ca:	f6 06 09 4b 	lsl	r11,r11,r6
8000b6ce:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b6d2:	1c 4b       	or	r11,lr
8000b6d4:	f4 06 09 4a 	lsl	r10,r10,r6
8000b6d8:	0c 17       	sub	r7,r6
8000b6da:	e0 8a 00 39 	brle	8000b74c <__avr32_f64_sub_subnormal_result>

8000b6de <__avr32_f64_sub_longnormalize_done>:
8000b6de:	f4 09 15 15 	lsl	r9,r10,0x15
8000b6e2:	ab 9a       	lsr	r10,0xb
8000b6e4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b6e8:	ab 9b       	lsr	r11,0xb
8000b6ea:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b6ee:	18 4b       	or	r11,r12

8000b6f0 <__avr32_f64_sub_round>:
8000b6f0:	fc 17 80 00 	movh	r7,0x8000
8000b6f4:	ed ba 00 00 	bld	r10,0x0
8000b6f8:	f7 b7 01 ff 	subne	r7,-1
8000b6fc:	0e 39       	cp.w	r9,r7
8000b6fe:	5f 29       	srhs	r9
8000b700:	12 0a       	add	r10,r9
8000b702:	5c 0b       	acr	r11
8000b704:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b708 <__avr32_f64_sub_opL_subnormal>:
8000b708:	ab 79       	lsl	r9,0xb
8000b70a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000b70e:	ab 78       	lsl	r8,0xb
8000b710:	f3 e8 10 0e 	or	lr,r9,r8
8000b714:	f9 b6 01 01 	movne	r6,1
8000b718:	ee 0e 11 00 	rsub	lr,r7,0
8000b71c:	f9 b7 00 01 	moveq	r7,1
8000b720:	ef bb 00 1f 	bst	r11,0x1f
8000b724:	f7 ea 10 0e 	or	lr,r11,r10
8000b728:	f9 b7 00 00 	moveq	r7,0
8000b72c:	cb 0b       	rjmp	8000b68c <__avr32_f64_sub_opL_subnormal_done>

8000b72e <__avr32_f64_sub_opH_nan_or_inf>:
8000b72e:	bf db       	cbr	r11,0x1f
8000b730:	f7 ea 10 0e 	or	lr,r11,r10
8000b734:	c0 81       	brne	8000b744 <__avr32_f64_sub_return_nan>
8000b736:	e0 46 07 ff 	cp.w	r6,2047
8000b73a:	c0 50       	breq	8000b744 <__avr32_f64_sub_return_nan>
8000b73c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000b740:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b744 <__avr32_f64_sub_return_nan>:
8000b744:	3f fa       	mov	r10,-1
8000b746:	3f fb       	mov	r11,-1
8000b748:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b74c <__avr32_f64_sub_subnormal_result>:
8000b74c:	5c 37       	neg	r7
8000b74e:	2f f7       	sub	r7,-1
8000b750:	f1 b7 04 c0 	satu	r7,0x6
8000b754:	e0 47 00 20 	cp.w	r7,32
8000b758:	c1 14       	brge	8000b77a <__avr32_f64_sub_subnormal_result+0x2e>
8000b75a:	ee 08 11 20 	rsub	r8,r7,32
8000b75e:	f4 08 09 49 	lsl	r9,r10,r8
8000b762:	5f 16       	srne	r6
8000b764:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b768:	0c 4a       	or	r10,r6
8000b76a:	f6 08 09 49 	lsl	r9,r11,r8
8000b76e:	f5 e9 10 0a 	or	r10,r10,r9
8000b772:	f4 07 0a 4b 	lsr	r11,r10,r7
8000b776:	30 07       	mov	r7,0
8000b778:	cb 3b       	rjmp	8000b6de <__avr32_f64_sub_longnormalize_done>
8000b77a:	ee 08 11 40 	rsub	r8,r7,64
8000b77e:	f6 08 09 49 	lsl	r9,r11,r8
8000b782:	14 49       	or	r9,r10
8000b784:	5f 16       	srne	r6
8000b786:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b78a:	0c 4a       	or	r10,r6
8000b78c:	30 0b       	mov	r11,0
8000b78e:	30 07       	mov	r7,0
8000b790:	ca 7b       	rjmp	8000b6de <__avr32_f64_sub_longnormalize_done>
8000b792:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b796 <__avr32_f64_sub_longshift>:
8000b796:	f1 b6 04 c0 	satu	r6,0x6
8000b79a:	f0 0e 17 00 	moveq	lr,r8
8000b79e:	c0 40       	breq	8000b7a6 <__avr32_f64_sub_longshift+0x10>
8000b7a0:	f2 05 09 4e 	lsl	lr,r9,r5
8000b7a4:	10 4e       	or	lr,r8
8000b7a6:	f2 06 0a 48 	lsr	r8,r9,r6
8000b7aa:	30 09       	mov	r9,0
8000b7ac:	58 0e       	cp.w	lr,0
8000b7ae:	5f 1e       	srne	lr
8000b7b0:	1c 48       	or	r8,lr
8000b7b2:	c8 3b       	rjmp	8000b6b8 <__avr32_f64_sub_shift_done>

8000b7b4 <__avr32_f64_sub_longnormalize>:
8000b7b4:	f4 06 12 00 	clz	r6,r10
8000b7b8:	f9 b7 03 00 	movlo	r7,0
8000b7bc:	f9 b6 03 00 	movlo	r6,0
8000b7c0:	f9 bc 03 00 	movlo	r12,0
8000b7c4:	f7 b6 02 e0 	subhs	r6,-32
8000b7c8:	f4 06 09 4b 	lsl	r11,r10,r6
8000b7cc:	30 0a       	mov	r10,0
8000b7ce:	0c 17       	sub	r7,r6
8000b7d0:	fe 9a ff be 	brle	8000b74c <__avr32_f64_sub_subnormal_result>
8000b7d4:	c8 5b       	rjmp	8000b6de <__avr32_f64_sub_longnormalize_done>
8000b7d6:	d7 03       	nop

8000b7d8 <__avr32_f64_add_from_sub>:
8000b7d8:	ee 19 80 00 	eorh	r9,0x8000

8000b7dc <__avr32_f64_add>:
8000b7dc:	f7 e9 20 0c 	eor	r12,r11,r9
8000b7e0:	fe 96 ff 2e 	brmi	8000b63c <__avr32_f64_sub_from_add>
8000b7e4:	eb cd 40 e0 	pushm	r5-r7,lr
8000b7e8:	16 9c       	mov	r12,r11
8000b7ea:	e6 1c 80 00 	andh	r12,0x8000,COH
8000b7ee:	bf db       	cbr	r11,0x1f
8000b7f0:	bf d9       	cbr	r9,0x1f
8000b7f2:	12 3b       	cp.w	r11,r9
8000b7f4:	c0 72       	brcc	8000b802 <__avr32_f64_add+0x26>
8000b7f6:	16 97       	mov	r7,r11
8000b7f8:	12 9b       	mov	r11,r9
8000b7fa:	0e 99       	mov	r9,r7
8000b7fc:	14 97       	mov	r7,r10
8000b7fe:	10 9a       	mov	r10,r8
8000b800:	0e 98       	mov	r8,r7
8000b802:	30 0e       	mov	lr,0
8000b804:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000b808:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000b80c:	b5 ab       	sbr	r11,0x14
8000b80e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000b812:	c6 20       	breq	8000b8d6 <__avr32_f64_add_op2_subnormal>
8000b814:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000b818:	b5 a9       	sbr	r9,0x14
8000b81a:	e0 47 07 ff 	cp.w	r7,2047
8000b81e:	c2 80       	breq	8000b86e <__avr32_f64_add_opH_nan_or_inf>
8000b820:	0e 26       	rsub	r6,r7
8000b822:	c1 20       	breq	8000b846 <__avr32_f64_add_shift_done>
8000b824:	e0 46 00 36 	cp.w	r6,54
8000b828:	c1 52       	brcc	8000b852 <__avr32_f64_add_res_of_done>
8000b82a:	ec 05 11 20 	rsub	r5,r6,32
8000b82e:	e0 46 00 20 	cp.w	r6,32
8000b832:	c3 52       	brcc	8000b89c <__avr32_f64_add_longshift>
8000b834:	f0 05 09 4e 	lsl	lr,r8,r5
8000b838:	f2 05 09 45 	lsl	r5,r9,r5
8000b83c:	f0 06 0a 48 	lsr	r8,r8,r6
8000b840:	f2 06 0a 49 	lsr	r9,r9,r6
8000b844:	0a 48       	or	r8,r5

8000b846 <__avr32_f64_add_shift_done>:
8000b846:	10 0a       	add	r10,r8
8000b848:	f6 09 00 4b 	adc	r11,r11,r9
8000b84c:	ed bb 00 15 	bld	r11,0x15
8000b850:	c3 40       	breq	8000b8b8 <__avr32_f64_add_res_of>

8000b852 <__avr32_f64_add_res_of_done>:
8000b852:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b856:	18 4b       	or	r11,r12

8000b858 <__avr32_f64_add_round>:
8000b858:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000b85c:	18 4e       	or	lr,r12
8000b85e:	ee 1e 80 00 	eorh	lr,0x8000
8000b862:	f1 be 04 20 	satu	lr,0x1
8000b866:	1c 0a       	add	r10,lr
8000b868:	5c 0b       	acr	r11
8000b86a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b86e <__avr32_f64_add_opH_nan_or_inf>:
8000b86e:	b5 cb       	cbr	r11,0x14
8000b870:	f7 ea 10 0e 	or	lr,r11,r10
8000b874:	c1 01       	brne	8000b894 <__avr32_f64_add_return_nan>
8000b876:	e0 46 07 ff 	cp.w	r6,2047
8000b87a:	c0 30       	breq	8000b880 <__avr32_f64_add_opL_nan_or_inf>
8000b87c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b880 <__avr32_f64_add_opL_nan_or_inf>:
8000b880:	b5 c9       	cbr	r9,0x14
8000b882:	f3 e8 10 0e 	or	lr,r9,r8
8000b886:	c0 71       	brne	8000b894 <__avr32_f64_add_return_nan>
8000b888:	30 0a       	mov	r10,0
8000b88a:	fc 1b 7f f0 	movh	r11,0x7ff0
8000b88e:	18 4b       	or	r11,r12
8000b890:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b894 <__avr32_f64_add_return_nan>:
8000b894:	3f fa       	mov	r10,-1
8000b896:	3f fb       	mov	r11,-1
8000b898:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000b89c <__avr32_f64_add_longshift>:
8000b89c:	f1 b6 04 c0 	satu	r6,0x6
8000b8a0:	f0 0e 17 00 	moveq	lr,r8
8000b8a4:	c0 60       	breq	8000b8b0 <__avr32_f64_add_longshift+0x14>
8000b8a6:	f2 05 09 4e 	lsl	lr,r9,r5
8000b8aa:	58 08       	cp.w	r8,0
8000b8ac:	5f 18       	srne	r8
8000b8ae:	10 4e       	or	lr,r8
8000b8b0:	f2 06 0a 48 	lsr	r8,r9,r6
8000b8b4:	30 09       	mov	r9,0
8000b8b6:	cc 8b       	rjmp	8000b846 <__avr32_f64_add_shift_done>

8000b8b8 <__avr32_f64_add_res_of>:
8000b8b8:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000b8bc:	a1 9b       	lsr	r11,0x1
8000b8be:	5d 0a       	ror	r10
8000b8c0:	5d 0e       	ror	lr
8000b8c2:	2f f7       	sub	r7,-1
8000b8c4:	e0 47 07 ff 	cp.w	r7,2047
8000b8c8:	f9 ba 00 00 	moveq	r10,0
8000b8cc:	f9 bb 00 00 	moveq	r11,0
8000b8d0:	f9 be 00 00 	moveq	lr,0
8000b8d4:	cb fb       	rjmp	8000b852 <__avr32_f64_add_res_of_done>

8000b8d6 <__avr32_f64_add_op2_subnormal>:
8000b8d6:	30 16       	mov	r6,1
8000b8d8:	58 07       	cp.w	r7,0
8000b8da:	ca 01       	brne	8000b81a <__avr32_f64_add+0x3e>
8000b8dc:	b5 cb       	cbr	r11,0x14
8000b8de:	10 0a       	add	r10,r8
8000b8e0:	f6 09 00 4b 	adc	r11,r11,r9
8000b8e4:	18 4b       	or	r11,r12
8000b8e6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000b8ea:	d7 03       	nop

8000b8ec <__avr32_f64_to_u32>:
8000b8ec:	58 0b       	cp.w	r11,0
8000b8ee:	5e 6d       	retmi	0

8000b8f0 <__avr32_f64_to_s32>:
8000b8f0:	f6 0c 15 01 	lsl	r12,r11,0x1
8000b8f4:	b5 9c       	lsr	r12,0x15
8000b8f6:	e0 2c 03 ff 	sub	r12,1023
8000b8fa:	5e 3d       	retlo	0
8000b8fc:	f8 0c 11 1f 	rsub	r12,r12,31
8000b900:	16 99       	mov	r9,r11
8000b902:	ab 7b       	lsl	r11,0xb
8000b904:	bf bb       	sbr	r11,0x1f
8000b906:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000b90a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000b90e:	a1 79       	lsl	r9,0x1
8000b910:	5e 2b       	reths	r11
8000b912:	5c 3b       	neg	r11
8000b914:	5e fb       	retal	r11

8000b916 <__avr32_u32_to_f64>:
8000b916:	f8 cb 00 00 	sub	r11,r12,0
8000b91a:	30 0c       	mov	r12,0
8000b91c:	c0 38       	rjmp	8000b922 <__avr32_s32_to_f64+0x4>

8000b91e <__avr32_s32_to_f64>:
8000b91e:	18 9b       	mov	r11,r12
8000b920:	5c 4b       	abs	r11
8000b922:	30 0a       	mov	r10,0
8000b924:	5e 0b       	reteq	r11
8000b926:	d4 01       	pushm	lr
8000b928:	e0 69 04 1e 	mov	r9,1054
8000b92c:	f6 08 12 00 	clz	r8,r11
8000b930:	c1 70       	breq	8000b95e <__avr32_s32_to_f64+0x40>
8000b932:	c0 c3       	brcs	8000b94a <__avr32_s32_to_f64+0x2c>
8000b934:	f0 0e 11 20 	rsub	lr,r8,32
8000b938:	f6 08 09 4b 	lsl	r11,r11,r8
8000b93c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000b940:	1c 4b       	or	r11,lr
8000b942:	f4 08 09 4a 	lsl	r10,r10,r8
8000b946:	10 19       	sub	r9,r8
8000b948:	c0 b8       	rjmp	8000b95e <__avr32_s32_to_f64+0x40>
8000b94a:	f4 08 12 00 	clz	r8,r10
8000b94e:	f9 b8 03 00 	movlo	r8,0
8000b952:	f7 b8 02 e0 	subhs	r8,-32
8000b956:	f4 08 09 4b 	lsl	r11,r10,r8
8000b95a:	30 0a       	mov	r10,0
8000b95c:	10 19       	sub	r9,r8
8000b95e:	58 09       	cp.w	r9,0
8000b960:	e0 89 00 30 	brgt	8000b9c0 <__avr32_s32_to_f64+0xa2>
8000b964:	5c 39       	neg	r9
8000b966:	2f f9       	sub	r9,-1
8000b968:	e0 49 00 36 	cp.w	r9,54
8000b96c:	c0 43       	brcs	8000b974 <__avr32_s32_to_f64+0x56>
8000b96e:	30 0b       	mov	r11,0
8000b970:	30 0a       	mov	r10,0
8000b972:	c2 68       	rjmp	8000b9be <__avr32_s32_to_f64+0xa0>
8000b974:	2f 69       	sub	r9,-10
8000b976:	f2 08 11 20 	rsub	r8,r9,32
8000b97a:	e0 49 00 20 	cp.w	r9,32
8000b97e:	c0 b2       	brcc	8000b994 <__avr32_s32_to_f64+0x76>
8000b980:	f4 08 09 4e 	lsl	lr,r10,r8
8000b984:	f6 08 09 48 	lsl	r8,r11,r8
8000b988:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b98c:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b990:	10 4b       	or	r11,r8
8000b992:	c0 88       	rjmp	8000b9a2 <__avr32_s32_to_f64+0x84>
8000b994:	f6 08 09 4e 	lsl	lr,r11,r8
8000b998:	14 4e       	or	lr,r10
8000b99a:	16 9a       	mov	r10,r11
8000b99c:	30 0b       	mov	r11,0
8000b99e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b9a2:	ed ba 00 00 	bld	r10,0x0
8000b9a6:	c0 92       	brcc	8000b9b8 <__avr32_s32_to_f64+0x9a>
8000b9a8:	1c 7e       	tst	lr,lr
8000b9aa:	c0 41       	brne	8000b9b2 <__avr32_s32_to_f64+0x94>
8000b9ac:	ed ba 00 01 	bld	r10,0x1
8000b9b0:	c0 42       	brcc	8000b9b8 <__avr32_s32_to_f64+0x9a>
8000b9b2:	2f fa       	sub	r10,-1
8000b9b4:	f7 bb 02 ff 	subhs	r11,-1
8000b9b8:	5c fc       	rol	r12
8000b9ba:	5d 0b       	ror	r11
8000b9bc:	5d 0a       	ror	r10
8000b9be:	d8 02       	popm	pc
8000b9c0:	e0 68 03 ff 	mov	r8,1023
8000b9c4:	ed ba 00 0b 	bld	r10,0xb
8000b9c8:	f7 b8 00 ff 	subeq	r8,-1
8000b9cc:	10 0a       	add	r10,r8
8000b9ce:	5c 0b       	acr	r11
8000b9d0:	f7 b9 03 fe 	sublo	r9,-2
8000b9d4:	e0 49 07 ff 	cp.w	r9,2047
8000b9d8:	c0 55       	brlt	8000b9e2 <__avr32_s32_to_f64+0xc4>
8000b9da:	30 0a       	mov	r10,0
8000b9dc:	fc 1b ff e0 	movh	r11,0xffe0
8000b9e0:	c0 c8       	rjmp	8000b9f8 <__floatsidf_return_op1>
8000b9e2:	ed bb 00 1f 	bld	r11,0x1f
8000b9e6:	f7 b9 01 01 	subne	r9,1
8000b9ea:	ab 9a       	lsr	r10,0xb
8000b9ec:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b9f0:	a1 7b       	lsl	r11,0x1
8000b9f2:	ab 9b       	lsr	r11,0xb
8000b9f4:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b9f8 <__floatsidf_return_op1>:
8000b9f8:	a1 7c       	lsl	r12,0x1
8000b9fa:	5d 0b       	ror	r11
8000b9fc:	d8 02       	popm	pc

8000b9fe <__avr32_f64_cmp_eq>:
8000b9fe:	10 3a       	cp.w	r10,r8
8000ba00:	f2 0b 13 00 	cpc	r11,r9
8000ba04:	c0 80       	breq	8000ba14 <__avr32_f64_cmp_eq+0x16>
8000ba06:	a1 7b       	lsl	r11,0x1
8000ba08:	a1 79       	lsl	r9,0x1
8000ba0a:	14 4b       	or	r11,r10
8000ba0c:	12 4b       	or	r11,r9
8000ba0e:	10 4b       	or	r11,r8
8000ba10:	5e 0f       	reteq	1
8000ba12:	5e fd       	retal	0
8000ba14:	a1 7b       	lsl	r11,0x1
8000ba16:	fc 1c ff e0 	movh	r12,0xffe0
8000ba1a:	58 0a       	cp.w	r10,0
8000ba1c:	f8 0b 13 00 	cpc	r11,r12
8000ba20:	5e 8f       	retls	1
8000ba22:	5e fd       	retal	0

8000ba24 <__avr32_f64_cmp_ge>:
8000ba24:	1a de       	st.w	--sp,lr
8000ba26:	1a d7       	st.w	--sp,r7
8000ba28:	a1 7b       	lsl	r11,0x1
8000ba2a:	5f 3c       	srlo	r12
8000ba2c:	a1 79       	lsl	r9,0x1
8000ba2e:	5f 37       	srlo	r7
8000ba30:	5c fc       	rol	r12
8000ba32:	fc 1e ff e0 	movh	lr,0xffe0
8000ba36:	58 0a       	cp.w	r10,0
8000ba38:	fc 0b 13 00 	cpc	r11,lr
8000ba3c:	e0 8b 00 1d 	brhi	8000ba76 <__avr32_f64_cmp_ge+0x52>
8000ba40:	58 08       	cp.w	r8,0
8000ba42:	fc 09 13 00 	cpc	r9,lr
8000ba46:	e0 8b 00 18 	brhi	8000ba76 <__avr32_f64_cmp_ge+0x52>
8000ba4a:	58 0b       	cp.w	r11,0
8000ba4c:	f5 ba 00 00 	subfeq	r10,0
8000ba50:	c1 50       	breq	8000ba7a <__avr32_f64_cmp_ge+0x56>
8000ba52:	1b 07       	ld.w	r7,sp++
8000ba54:	1b 0e       	ld.w	lr,sp++
8000ba56:	58 3c       	cp.w	r12,3
8000ba58:	c0 a0       	breq	8000ba6c <__avr32_f64_cmp_ge+0x48>
8000ba5a:	58 1c       	cp.w	r12,1
8000ba5c:	c0 33       	brcs	8000ba62 <__avr32_f64_cmp_ge+0x3e>
8000ba5e:	5e 0f       	reteq	1
8000ba60:	5e 1d       	retne	0
8000ba62:	10 3a       	cp.w	r10,r8
8000ba64:	f2 0b 13 00 	cpc	r11,r9
8000ba68:	5e 2f       	reths	1
8000ba6a:	5e 3d       	retlo	0
8000ba6c:	14 38       	cp.w	r8,r10
8000ba6e:	f6 09 13 00 	cpc	r9,r11
8000ba72:	5e 2f       	reths	1
8000ba74:	5e 3d       	retlo	0
8000ba76:	1b 07       	ld.w	r7,sp++
8000ba78:	d8 0a       	popm	pc,r12=0
8000ba7a:	58 17       	cp.w	r7,1
8000ba7c:	5f 0c       	sreq	r12
8000ba7e:	58 09       	cp.w	r9,0
8000ba80:	f5 b8 00 00 	subfeq	r8,0
8000ba84:	1b 07       	ld.w	r7,sp++
8000ba86:	1b 0e       	ld.w	lr,sp++
8000ba88:	5e 0f       	reteq	1
8000ba8a:	5e fc       	retal	r12

8000ba8c <__avr32_f64_cmp_lt>:
8000ba8c:	1a de       	st.w	--sp,lr
8000ba8e:	1a d7       	st.w	--sp,r7
8000ba90:	a1 7b       	lsl	r11,0x1
8000ba92:	5f 3c       	srlo	r12
8000ba94:	a1 79       	lsl	r9,0x1
8000ba96:	5f 37       	srlo	r7
8000ba98:	5c fc       	rol	r12
8000ba9a:	fc 1e ff e0 	movh	lr,0xffe0
8000ba9e:	58 0a       	cp.w	r10,0
8000baa0:	fc 0b 13 00 	cpc	r11,lr
8000baa4:	e0 8b 00 1d 	brhi	8000bade <__avr32_f64_cmp_lt+0x52>
8000baa8:	58 08       	cp.w	r8,0
8000baaa:	fc 09 13 00 	cpc	r9,lr
8000baae:	e0 8b 00 18 	brhi	8000bade <__avr32_f64_cmp_lt+0x52>
8000bab2:	58 0b       	cp.w	r11,0
8000bab4:	f5 ba 00 00 	subfeq	r10,0
8000bab8:	c1 50       	breq	8000bae2 <__avr32_f64_cmp_lt+0x56>
8000baba:	1b 07       	ld.w	r7,sp++
8000babc:	1b 0e       	ld.w	lr,sp++
8000babe:	58 3c       	cp.w	r12,3
8000bac0:	c0 a0       	breq	8000bad4 <__avr32_f64_cmp_lt+0x48>
8000bac2:	58 1c       	cp.w	r12,1
8000bac4:	c0 33       	brcs	8000baca <__avr32_f64_cmp_lt+0x3e>
8000bac6:	5e 0d       	reteq	0
8000bac8:	5e 1f       	retne	1
8000baca:	10 3a       	cp.w	r10,r8
8000bacc:	f2 0b 13 00 	cpc	r11,r9
8000bad0:	5e 2d       	reths	0
8000bad2:	5e 3f       	retlo	1
8000bad4:	14 38       	cp.w	r8,r10
8000bad6:	f6 09 13 00 	cpc	r9,r11
8000bada:	5e 2d       	reths	0
8000badc:	5e 3f       	retlo	1
8000bade:	1b 07       	ld.w	r7,sp++
8000bae0:	d8 0a       	popm	pc,r12=0
8000bae2:	58 17       	cp.w	r7,1
8000bae4:	5f 1c       	srne	r12
8000bae6:	58 09       	cp.w	r9,0
8000bae8:	f5 b8 00 00 	subfeq	r8,0
8000baec:	1b 07       	ld.w	r7,sp++
8000baee:	1b 0e       	ld.w	lr,sp++
8000baf0:	5e 0d       	reteq	0
8000baf2:	5e fc       	retal	r12

8000baf4 <__avr32_f64_div>:
8000baf4:	eb cd 40 ff 	pushm	r0-r7,lr
8000baf8:	f7 e9 20 0e 	eor	lr,r11,r9
8000bafc:	f6 07 16 14 	lsr	r7,r11,0x14
8000bb00:	a9 7b       	lsl	r11,0x9
8000bb02:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000bb06:	a9 7a       	lsl	r10,0x9
8000bb08:	bd bb       	sbr	r11,0x1d
8000bb0a:	e4 1b 3f ff 	andh	r11,0x3fff
8000bb0e:	ab d7       	cbr	r7,0xb
8000bb10:	e0 80 00 cc 	breq	8000bca8 <__avr32_f64_div_round_subnormal+0x54>
8000bb14:	e0 47 07 ff 	cp.w	r7,2047
8000bb18:	e0 84 00 b5 	brge	8000bc82 <__avr32_f64_div_round_subnormal+0x2e>
8000bb1c:	f2 06 16 14 	lsr	r6,r9,0x14
8000bb20:	a9 79       	lsl	r9,0x9
8000bb22:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000bb26:	a9 78       	lsl	r8,0x9
8000bb28:	bd b9       	sbr	r9,0x1d
8000bb2a:	e4 19 3f ff 	andh	r9,0x3fff
8000bb2e:	ab d6       	cbr	r6,0xb
8000bb30:	e0 80 00 e2 	breq	8000bcf4 <__avr32_f64_div_round_subnormal+0xa0>
8000bb34:	e0 46 07 ff 	cp.w	r6,2047
8000bb38:	e0 84 00 b2 	brge	8000bc9c <__avr32_f64_div_round_subnormal+0x48>
8000bb3c:	0c 17       	sub	r7,r6
8000bb3e:	fe 37 fc 01 	sub	r7,-1023
8000bb42:	fc 1c 80 00 	movh	r12,0x8000
8000bb46:	f8 03 16 01 	lsr	r3,r12,0x1
8000bb4a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000bb4e:	5c d4       	com	r4
8000bb50:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000bb54:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bb58:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bb5c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bb60:	ea 03 15 02 	lsl	r3,r5,0x2
8000bb64:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bb68:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bb6c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bb70:	ea 03 15 02 	lsl	r3,r5,0x2
8000bb74:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bb78:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000bb7c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bb80:	ea 03 15 02 	lsl	r3,r5,0x2
8000bb84:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bb88:	e4 09 07 40 	macu.d	r0,r2,r9
8000bb8c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bb90:	02 04       	add	r4,r1
8000bb92:	5c 05       	acr	r5
8000bb94:	a3 65       	lsl	r5,0x2
8000bb96:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bb9a:	a3 64       	lsl	r4,0x2
8000bb9c:	5c 34       	neg	r4
8000bb9e:	f8 05 01 45 	sbc	r5,r12,r5
8000bba2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bba6:	e4 05 07 40 	macu.d	r0,r2,r5
8000bbaa:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bbae:	02 04       	add	r4,r1
8000bbb0:	5c 05       	acr	r5
8000bbb2:	ea 03 15 02 	lsl	r3,r5,0x2
8000bbb6:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bbba:	e8 02 15 02 	lsl	r2,r4,0x2
8000bbbe:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bbc2:	e4 09 07 40 	macu.d	r0,r2,r9
8000bbc6:	e6 09 06 44 	mulu.d	r4,r3,r9
8000bbca:	02 04       	add	r4,r1
8000bbcc:	5c 05       	acr	r5
8000bbce:	a3 65       	lsl	r5,0x2
8000bbd0:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000bbd4:	a3 64       	lsl	r4,0x2
8000bbd6:	5c 34       	neg	r4
8000bbd8:	f8 05 01 45 	sbc	r5,r12,r5
8000bbdc:	e6 04 06 40 	mulu.d	r0,r3,r4
8000bbe0:	e4 05 07 40 	macu.d	r0,r2,r5
8000bbe4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000bbe8:	02 04       	add	r4,r1
8000bbea:	5c 05       	acr	r5
8000bbec:	ea 03 15 02 	lsl	r3,r5,0x2
8000bbf0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000bbf4:	e8 02 15 02 	lsl	r2,r4,0x2
8000bbf8:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000bbfc:	e4 0b 07 40 	macu.d	r0,r2,r11
8000bc00:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000bc04:	02 02       	add	r2,r1
8000bc06:	5c 03       	acr	r3
8000bc08:	ed b3 00 1c 	bld	r3,0x1c
8000bc0c:	c0 90       	breq	8000bc1e <__avr32_f64_div+0x12a>
8000bc0e:	a1 72       	lsl	r2,0x1
8000bc10:	5c f3       	rol	r3
8000bc12:	20 17       	sub	r7,1
8000bc14:	a3 9a       	lsr	r10,0x3
8000bc16:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000bc1a:	a3 9b       	lsr	r11,0x3
8000bc1c:	c0 58       	rjmp	8000bc26 <__avr32_f64_div+0x132>
8000bc1e:	a5 8a       	lsr	r10,0x4
8000bc20:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000bc24:	a5 8b       	lsr	r11,0x4
8000bc26:	58 07       	cp.w	r7,0
8000bc28:	e0 8a 00 8b 	brle	8000bd3e <__avr32_f64_div_res_subnormal>
8000bc2c:	e0 12 ff 00 	andl	r2,0xff00
8000bc30:	e8 12 00 80 	orl	r2,0x80
8000bc34:	e6 08 06 40 	mulu.d	r0,r3,r8
8000bc38:	e4 09 07 40 	macu.d	r0,r2,r9
8000bc3c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bc40:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bc44:	00 05       	add	r5,r0
8000bc46:	f0 01 00 48 	adc	r8,r8,r1
8000bc4a:	5c 09       	acr	r9
8000bc4c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bc50:	58 04       	cp.w	r4,0
8000bc52:	5c 25       	cpc	r5

8000bc54 <__avr32_f64_div_round_subnormal>:
8000bc54:	f4 08 13 00 	cpc	r8,r10
8000bc58:	f6 09 13 00 	cpc	r9,r11
8000bc5c:	5f 36       	srlo	r6
8000bc5e:	f8 06 17 00 	moveq	r6,r12
8000bc62:	e4 0a 16 08 	lsr	r10,r2,0x8
8000bc66:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000bc6a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000bc6e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bc72:	ed be 00 1f 	bld	lr,0x1f
8000bc76:	ef bb 00 1f 	bst	r11,0x1f
8000bc7a:	0c 0a       	add	r10,r6
8000bc7c:	5c 0b       	acr	r11
8000bc7e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bc82:	e4 1b 00 0f 	andh	r11,0xf
8000bc86:	14 4b       	or	r11,r10
8000bc88:	e0 81 00 a7 	brne	8000bdd6 <__avr32_f64_div_res_subnormal+0x98>
8000bc8c:	f2 06 16 14 	lsr	r6,r9,0x14
8000bc90:	ab d6       	cbr	r6,0xb
8000bc92:	e0 46 07 ff 	cp.w	r6,2047
8000bc96:	e0 81 00 a4 	brne	8000bdde <__avr32_f64_div_res_subnormal+0xa0>
8000bc9a:	c9 e8       	rjmp	8000bdd6 <__avr32_f64_div_res_subnormal+0x98>
8000bc9c:	e4 19 00 0f 	andh	r9,0xf
8000bca0:	10 49       	or	r9,r8
8000bca2:	e0 81 00 9a 	brne	8000bdd6 <__avr32_f64_div_res_subnormal+0x98>
8000bca6:	c9 28       	rjmp	8000bdca <__avr32_f64_div_res_subnormal+0x8c>
8000bca8:	a3 7b       	lsl	r11,0x3
8000bcaa:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000bcae:	a3 7a       	lsl	r10,0x3
8000bcb0:	f5 eb 10 04 	or	r4,r10,r11
8000bcb4:	e0 80 00 a0 	breq	8000bdf4 <__avr32_f64_div_op1_zero>
8000bcb8:	f6 04 12 00 	clz	r4,r11
8000bcbc:	c1 70       	breq	8000bcea <__avr32_f64_div_round_subnormal+0x96>
8000bcbe:	c0 c3       	brcs	8000bcd6 <__avr32_f64_div_round_subnormal+0x82>
8000bcc0:	e8 05 11 20 	rsub	r5,r4,32
8000bcc4:	f6 04 09 4b 	lsl	r11,r11,r4
8000bcc8:	f4 05 0a 45 	lsr	r5,r10,r5
8000bccc:	0a 4b       	or	r11,r5
8000bcce:	f4 04 09 4a 	lsl	r10,r10,r4
8000bcd2:	08 17       	sub	r7,r4
8000bcd4:	c0 b8       	rjmp	8000bcea <__avr32_f64_div_round_subnormal+0x96>
8000bcd6:	f4 04 12 00 	clz	r4,r10
8000bcda:	f9 b4 03 00 	movlo	r4,0
8000bcde:	f7 b4 02 e0 	subhs	r4,-32
8000bce2:	f4 04 09 4b 	lsl	r11,r10,r4
8000bce6:	30 0a       	mov	r10,0
8000bce8:	08 17       	sub	r7,r4
8000bcea:	a3 8a       	lsr	r10,0x2
8000bcec:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000bcf0:	a3 8b       	lsr	r11,0x2
8000bcf2:	c1 1b       	rjmp	8000bb14 <__avr32_f64_div+0x20>
8000bcf4:	a3 79       	lsl	r9,0x3
8000bcf6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000bcfa:	a3 78       	lsl	r8,0x3
8000bcfc:	f3 e8 10 04 	or	r4,r9,r8
8000bd00:	c6 f0       	breq	8000bdde <__avr32_f64_div_res_subnormal+0xa0>
8000bd02:	f2 04 12 00 	clz	r4,r9
8000bd06:	c1 70       	breq	8000bd34 <__avr32_f64_div_round_subnormal+0xe0>
8000bd08:	c0 c3       	brcs	8000bd20 <__avr32_f64_div_round_subnormal+0xcc>
8000bd0a:	e8 05 11 20 	rsub	r5,r4,32
8000bd0e:	f2 04 09 49 	lsl	r9,r9,r4
8000bd12:	f0 05 0a 45 	lsr	r5,r8,r5
8000bd16:	0a 49       	or	r9,r5
8000bd18:	f0 04 09 48 	lsl	r8,r8,r4
8000bd1c:	08 16       	sub	r6,r4
8000bd1e:	c0 b8       	rjmp	8000bd34 <__avr32_f64_div_round_subnormal+0xe0>
8000bd20:	f0 04 12 00 	clz	r4,r8
8000bd24:	f9 b4 03 00 	movlo	r4,0
8000bd28:	f7 b4 02 e0 	subhs	r4,-32
8000bd2c:	f0 04 09 49 	lsl	r9,r8,r4
8000bd30:	30 08       	mov	r8,0
8000bd32:	08 16       	sub	r6,r4
8000bd34:	a3 88       	lsr	r8,0x2
8000bd36:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000bd3a:	a3 89       	lsr	r9,0x2
8000bd3c:	cf ca       	rjmp	8000bb34 <__avr32_f64_div+0x40>

8000bd3e <__avr32_f64_div_res_subnormal>:
8000bd3e:	5c 37       	neg	r7
8000bd40:	2f f7       	sub	r7,-1
8000bd42:	f1 b7 04 c0 	satu	r7,0x6
8000bd46:	e0 47 00 20 	cp.w	r7,32
8000bd4a:	c1 54       	brge	8000bd74 <__avr32_f64_div_res_subnormal+0x36>
8000bd4c:	ee 06 11 20 	rsub	r6,r7,32
8000bd50:	e4 07 0a 42 	lsr	r2,r2,r7
8000bd54:	e6 06 09 4c 	lsl	r12,r3,r6
8000bd58:	18 42       	or	r2,r12
8000bd5a:	e6 07 0a 43 	lsr	r3,r3,r7
8000bd5e:	f4 06 09 41 	lsl	r1,r10,r6
8000bd62:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bd66:	f6 06 09 4c 	lsl	r12,r11,r6
8000bd6a:	18 4a       	or	r10,r12
8000bd6c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000bd70:	30 00       	mov	r0,0
8000bd72:	c1 58       	rjmp	8000bd9c <__avr32_f64_div_res_subnormal+0x5e>
8000bd74:	ee 06 11 20 	rsub	r6,r7,32
8000bd78:	f9 b0 00 00 	moveq	r0,0
8000bd7c:	f9 bc 00 00 	moveq	r12,0
8000bd80:	c0 50       	breq	8000bd8a <__avr32_f64_div_res_subnormal+0x4c>
8000bd82:	f4 06 09 40 	lsl	r0,r10,r6
8000bd86:	f6 06 09 4c 	lsl	r12,r11,r6
8000bd8a:	e6 07 0a 42 	lsr	r2,r3,r7
8000bd8e:	30 03       	mov	r3,0
8000bd90:	f4 07 0a 41 	lsr	r1,r10,r7
8000bd94:	18 41       	or	r1,r12
8000bd96:	f6 07 0a 4a 	lsr	r10,r11,r7
8000bd9a:	30 0b       	mov	r11,0
8000bd9c:	e0 12 ff 00 	andl	r2,0xff00
8000bda0:	e8 12 00 80 	orl	r2,0x80
8000bda4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000bda8:	e4 09 07 46 	macu.d	r6,r2,r9
8000bdac:	e4 08 06 44 	mulu.d	r4,r2,r8
8000bdb0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000bdb4:	0c 05       	add	r5,r6
8000bdb6:	f0 07 00 48 	adc	r8,r8,r7
8000bdba:	5c 09       	acr	r9
8000bdbc:	30 07       	mov	r7,0
8000bdbe:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000bdc2:	00 34       	cp.w	r4,r0
8000bdc4:	e2 05 13 00 	cpc	r5,r1
8000bdc8:	c4 6b       	rjmp	8000bc54 <__avr32_f64_div_round_subnormal>
8000bdca:	1c 9b       	mov	r11,lr
8000bdcc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bdd0:	30 0a       	mov	r10,0
8000bdd2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bdd6:	3f fb       	mov	r11,-1
8000bdd8:	30 0a       	mov	r10,0
8000bdda:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000bdde:	f5 eb 10 04 	or	r4,r10,r11
8000bde2:	c0 90       	breq	8000bdf4 <__avr32_f64_div_op1_zero>
8000bde4:	1c 9b       	mov	r11,lr
8000bde6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000bdea:	ea 1b 7f f0 	orh	r11,0x7ff0
8000bdee:	30 0a       	mov	r10,0
8000bdf0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000bdf4 <__avr32_f64_div_op1_zero>:
8000bdf4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000bdf8:	ce f0       	breq	8000bdd6 <__avr32_f64_div_res_subnormal+0x98>
8000bdfa:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000bdfe:	e0 44 07 ff 	cp.w	r4,2047
8000be02:	ce 41       	brne	8000bdca <__avr32_f64_div_res_subnormal+0x8c>
8000be04:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000be08:	ce 10       	breq	8000bdca <__avr32_f64_div_res_subnormal+0x8c>
8000be0a:	ce 6b       	rjmp	8000bdd6 <__avr32_f64_div_res_subnormal+0x98>

8000be0c <__avr32_udiv64>:
8000be0c:	d4 31       	pushm	r0-r7,lr
8000be0e:	1a 97       	mov	r7,sp
8000be10:	20 3d       	sub	sp,12
8000be12:	10 9c       	mov	r12,r8
8000be14:	12 9e       	mov	lr,r9
8000be16:	14 93       	mov	r3,r10
8000be18:	58 09       	cp.w	r9,0
8000be1a:	e0 81 00 bd 	brne	8000bf94 <__avr32_udiv64+0x188>
8000be1e:	16 38       	cp.w	r8,r11
8000be20:	e0 88 00 40 	brls	8000bea0 <__avr32_udiv64+0x94>
8000be24:	f0 08 12 00 	clz	r8,r8
8000be28:	c0 d0       	breq	8000be42 <__avr32_udiv64+0x36>
8000be2a:	f6 08 09 4b 	lsl	r11,r11,r8
8000be2e:	f0 09 11 20 	rsub	r9,r8,32
8000be32:	f8 08 09 4c 	lsl	r12,r12,r8
8000be36:	f4 09 0a 49 	lsr	r9,r10,r9
8000be3a:	f4 08 09 43 	lsl	r3,r10,r8
8000be3e:	f3 eb 10 0b 	or	r11,r9,r11
8000be42:	f8 0e 16 10 	lsr	lr,r12,0x10
8000be46:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000be4a:	f6 0e 0d 00 	divu	r0,r11,lr
8000be4e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000be52:	00 99       	mov	r9,r0
8000be54:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000be58:	e0 0a 02 48 	mul	r8,r0,r10
8000be5c:	10 3b       	cp.w	r11,r8
8000be5e:	c0 a2       	brcc	8000be72 <__avr32_udiv64+0x66>
8000be60:	20 19       	sub	r9,1
8000be62:	18 0b       	add	r11,r12
8000be64:	18 3b       	cp.w	r11,r12
8000be66:	c0 63       	brcs	8000be72 <__avr32_udiv64+0x66>
8000be68:	10 3b       	cp.w	r11,r8
8000be6a:	f7 b9 03 01 	sublo	r9,1
8000be6e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000be72:	f6 08 01 01 	sub	r1,r11,r8
8000be76:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000be7a:	e2 0e 0d 00 	divu	r0,r1,lr
8000be7e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000be82:	00 98       	mov	r8,r0
8000be84:	e0 0a 02 4a 	mul	r10,r0,r10
8000be88:	14 33       	cp.w	r3,r10
8000be8a:	c0 82       	brcc	8000be9a <__avr32_udiv64+0x8e>
8000be8c:	20 18       	sub	r8,1
8000be8e:	18 03       	add	r3,r12
8000be90:	18 33       	cp.w	r3,r12
8000be92:	c0 43       	brcs	8000be9a <__avr32_udiv64+0x8e>
8000be94:	14 33       	cp.w	r3,r10
8000be96:	f7 b8 03 01 	sublo	r8,1
8000be9a:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000be9e:	cd f8       	rjmp	8000c05c <__avr32_udiv64+0x250>
8000bea0:	58 08       	cp.w	r8,0
8000bea2:	c0 51       	brne	8000beac <__avr32_udiv64+0xa0>
8000bea4:	30 19       	mov	r9,1
8000bea6:	f2 08 0d 08 	divu	r8,r9,r8
8000beaa:	10 9c       	mov	r12,r8
8000beac:	f8 06 12 00 	clz	r6,r12
8000beb0:	c0 41       	brne	8000beb8 <__avr32_udiv64+0xac>
8000beb2:	18 1b       	sub	r11,r12
8000beb4:	30 19       	mov	r9,1
8000beb6:	c4 08       	rjmp	8000bf36 <__avr32_udiv64+0x12a>
8000beb8:	ec 01 11 20 	rsub	r1,r6,32
8000bebc:	f4 01 0a 49 	lsr	r9,r10,r1
8000bec0:	f8 06 09 4c 	lsl	r12,r12,r6
8000bec4:	f6 06 09 48 	lsl	r8,r11,r6
8000bec8:	f6 01 0a 41 	lsr	r1,r11,r1
8000becc:	f3 e8 10 08 	or	r8,r9,r8
8000bed0:	f8 03 16 10 	lsr	r3,r12,0x10
8000bed4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000bed8:	e2 03 0d 00 	divu	r0,r1,r3
8000bedc:	f0 0b 16 10 	lsr	r11,r8,0x10
8000bee0:	00 9e       	mov	lr,r0
8000bee2:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bee6:	e0 05 02 49 	mul	r9,r0,r5
8000beea:	12 3b       	cp.w	r11,r9
8000beec:	c0 a2       	brcc	8000bf00 <__avr32_udiv64+0xf4>
8000beee:	20 1e       	sub	lr,1
8000bef0:	18 0b       	add	r11,r12
8000bef2:	18 3b       	cp.w	r11,r12
8000bef4:	c0 63       	brcs	8000bf00 <__avr32_udiv64+0xf4>
8000bef6:	12 3b       	cp.w	r11,r9
8000bef8:	f7 be 03 01 	sublo	lr,1
8000befc:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bf00:	12 1b       	sub	r11,r9
8000bf02:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000bf06:	f6 03 0d 02 	divu	r2,r11,r3
8000bf0a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000bf0e:	04 99       	mov	r9,r2
8000bf10:	e4 05 02 4b 	mul	r11,r2,r5
8000bf14:	16 38       	cp.w	r8,r11
8000bf16:	c0 a2       	brcc	8000bf2a <__avr32_udiv64+0x11e>
8000bf18:	20 19       	sub	r9,1
8000bf1a:	18 08       	add	r8,r12
8000bf1c:	18 38       	cp.w	r8,r12
8000bf1e:	c0 63       	brcs	8000bf2a <__avr32_udiv64+0x11e>
8000bf20:	16 38       	cp.w	r8,r11
8000bf22:	f7 b9 03 01 	sublo	r9,1
8000bf26:	f1 dc e3 08 	addcs	r8,r8,r12
8000bf2a:	f4 06 09 43 	lsl	r3,r10,r6
8000bf2e:	f0 0b 01 0b 	sub	r11,r8,r11
8000bf32:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000bf36:	f8 06 16 10 	lsr	r6,r12,0x10
8000bf3a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000bf3e:	f6 06 0d 00 	divu	r0,r11,r6
8000bf42:	e6 0b 16 10 	lsr	r11,r3,0x10
8000bf46:	00 9a       	mov	r10,r0
8000bf48:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000bf4c:	e0 0e 02 48 	mul	r8,r0,lr
8000bf50:	10 3b       	cp.w	r11,r8
8000bf52:	c0 a2       	brcc	8000bf66 <__avr32_udiv64+0x15a>
8000bf54:	20 1a       	sub	r10,1
8000bf56:	18 0b       	add	r11,r12
8000bf58:	18 3b       	cp.w	r11,r12
8000bf5a:	c0 63       	brcs	8000bf66 <__avr32_udiv64+0x15a>
8000bf5c:	10 3b       	cp.w	r11,r8
8000bf5e:	f7 ba 03 01 	sublo	r10,1
8000bf62:	f7 dc e3 0b 	addcs	r11,r11,r12
8000bf66:	f6 08 01 01 	sub	r1,r11,r8
8000bf6a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000bf6e:	e2 06 0d 00 	divu	r0,r1,r6
8000bf72:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000bf76:	00 98       	mov	r8,r0
8000bf78:	e0 0e 02 4b 	mul	r11,r0,lr
8000bf7c:	16 33       	cp.w	r3,r11
8000bf7e:	c0 82       	brcc	8000bf8e <__avr32_udiv64+0x182>
8000bf80:	20 18       	sub	r8,1
8000bf82:	18 03       	add	r3,r12
8000bf84:	18 33       	cp.w	r3,r12
8000bf86:	c0 43       	brcs	8000bf8e <__avr32_udiv64+0x182>
8000bf88:	16 33       	cp.w	r3,r11
8000bf8a:	f7 b8 03 01 	sublo	r8,1
8000bf8e:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000bf92:	c6 98       	rjmp	8000c064 <__avr32_udiv64+0x258>
8000bf94:	16 39       	cp.w	r9,r11
8000bf96:	e0 8b 00 65 	brhi	8000c060 <__avr32_udiv64+0x254>
8000bf9a:	f2 09 12 00 	clz	r9,r9
8000bf9e:	c0 b1       	brne	8000bfb4 <__avr32_udiv64+0x1a8>
8000bfa0:	10 3a       	cp.w	r10,r8
8000bfa2:	5f 2a       	srhs	r10
8000bfa4:	1c 3b       	cp.w	r11,lr
8000bfa6:	5f b8       	srhi	r8
8000bfa8:	10 4a       	or	r10,r8
8000bfaa:	f2 0a 18 00 	cp.b	r10,r9
8000bfae:	c5 90       	breq	8000c060 <__avr32_udiv64+0x254>
8000bfb0:	30 18       	mov	r8,1
8000bfb2:	c5 98       	rjmp	8000c064 <__avr32_udiv64+0x258>
8000bfb4:	f0 09 09 46 	lsl	r6,r8,r9
8000bfb8:	f2 03 11 20 	rsub	r3,r9,32
8000bfbc:	fc 09 09 4e 	lsl	lr,lr,r9
8000bfc0:	f0 03 0a 48 	lsr	r8,r8,r3
8000bfc4:	f6 09 09 4c 	lsl	r12,r11,r9
8000bfc8:	f4 03 0a 42 	lsr	r2,r10,r3
8000bfcc:	ef 46 ff f4 	st.w	r7[-12],r6
8000bfd0:	f6 03 0a 43 	lsr	r3,r11,r3
8000bfd4:	18 42       	or	r2,r12
8000bfd6:	f1 ee 10 0c 	or	r12,r8,lr
8000bfda:	f8 01 16 10 	lsr	r1,r12,0x10
8000bfde:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000bfe2:	e6 01 0d 04 	divu	r4,r3,r1
8000bfe6:	e4 03 16 10 	lsr	r3,r2,0x10
8000bfea:	08 9e       	mov	lr,r4
8000bfec:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000bff0:	e8 06 02 48 	mul	r8,r4,r6
8000bff4:	10 33       	cp.w	r3,r8
8000bff6:	c0 a2       	brcc	8000c00a <__avr32_udiv64+0x1fe>
8000bff8:	20 1e       	sub	lr,1
8000bffa:	18 03       	add	r3,r12
8000bffc:	18 33       	cp.w	r3,r12
8000bffe:	c0 63       	brcs	8000c00a <__avr32_udiv64+0x1fe>
8000c000:	10 33       	cp.w	r3,r8
8000c002:	f7 be 03 01 	sublo	lr,1
8000c006:	e7 dc e3 03 	addcs	r3,r3,r12
8000c00a:	10 13       	sub	r3,r8
8000c00c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c010:	e6 01 0d 00 	divu	r0,r3,r1
8000c014:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c018:	00 98       	mov	r8,r0
8000c01a:	e0 06 02 46 	mul	r6,r0,r6
8000c01e:	0c 3b       	cp.w	r11,r6
8000c020:	c0 a2       	brcc	8000c034 <__avr32_udiv64+0x228>
8000c022:	20 18       	sub	r8,1
8000c024:	18 0b       	add	r11,r12
8000c026:	18 3b       	cp.w	r11,r12
8000c028:	c0 63       	brcs	8000c034 <__avr32_udiv64+0x228>
8000c02a:	0c 3b       	cp.w	r11,r6
8000c02c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c030:	f7 b8 03 01 	sublo	r8,1
8000c034:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c038:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c03c:	0c 1b       	sub	r11,r6
8000c03e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c042:	06 95       	mov	r5,r3
8000c044:	16 35       	cp.w	r5,r11
8000c046:	e0 8b 00 0a 	brhi	8000c05a <__avr32_udiv64+0x24e>
8000c04a:	5f 0b       	sreq	r11
8000c04c:	f4 09 09 49 	lsl	r9,r10,r9
8000c050:	12 32       	cp.w	r2,r9
8000c052:	5f b9       	srhi	r9
8000c054:	f7 e9 00 09 	and	r9,r11,r9
8000c058:	c0 60       	breq	8000c064 <__avr32_udiv64+0x258>
8000c05a:	20 18       	sub	r8,1
8000c05c:	30 09       	mov	r9,0
8000c05e:	c0 38       	rjmp	8000c064 <__avr32_udiv64+0x258>
8000c060:	30 09       	mov	r9,0
8000c062:	12 98       	mov	r8,r9
8000c064:	10 9a       	mov	r10,r8
8000c066:	12 93       	mov	r3,r9
8000c068:	10 92       	mov	r2,r8
8000c06a:	12 9b       	mov	r11,r9
8000c06c:	2f dd       	sub	sp,-12
8000c06e:	d8 32       	popm	r0-r7,pc

8000c070 <__avr32_umod64>:
8000c070:	d4 31       	pushm	r0-r7,lr
8000c072:	1a 97       	mov	r7,sp
8000c074:	20 3d       	sub	sp,12
8000c076:	10 9c       	mov	r12,r8
8000c078:	12 95       	mov	r5,r9
8000c07a:	14 9e       	mov	lr,r10
8000c07c:	16 91       	mov	r1,r11
8000c07e:	16 96       	mov	r6,r11
8000c080:	58 09       	cp.w	r9,0
8000c082:	e0 81 00 81 	brne	8000c184 <__avr32_umod64+0x114>
8000c086:	16 38       	cp.w	r8,r11
8000c088:	e0 88 00 12 	brls	8000c0ac <__avr32_umod64+0x3c>
8000c08c:	f0 08 12 00 	clz	r8,r8
8000c090:	c4 e0       	breq	8000c12c <__avr32_umod64+0xbc>
8000c092:	f6 08 09 46 	lsl	r6,r11,r8
8000c096:	f8 08 09 4c 	lsl	r12,r12,r8
8000c09a:	f0 0b 11 20 	rsub	r11,r8,32
8000c09e:	f4 08 09 4e 	lsl	lr,r10,r8
8000c0a2:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c0a6:	f7 e6 10 06 	or	r6,r11,r6
8000c0aa:	c4 18       	rjmp	8000c12c <__avr32_umod64+0xbc>
8000c0ac:	58 08       	cp.w	r8,0
8000c0ae:	c0 51       	brne	8000c0b8 <__avr32_umod64+0x48>
8000c0b0:	30 19       	mov	r9,1
8000c0b2:	f2 08 0d 08 	divu	r8,r9,r8
8000c0b6:	10 9c       	mov	r12,r8
8000c0b8:	f8 08 12 00 	clz	r8,r12
8000c0bc:	c0 31       	brne	8000c0c2 <__avr32_umod64+0x52>
8000c0be:	18 16       	sub	r6,r12
8000c0c0:	c3 68       	rjmp	8000c12c <__avr32_umod64+0xbc>
8000c0c2:	f0 03 11 20 	rsub	r3,r8,32
8000c0c6:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c0ca:	f8 08 09 4c 	lsl	r12,r12,r8
8000c0ce:	ec 08 09 49 	lsl	r9,r6,r8
8000c0d2:	ec 03 0a 43 	lsr	r3,r6,r3
8000c0d6:	f7 e9 10 09 	or	r9,r11,r9
8000c0da:	f8 05 16 10 	lsr	r5,r12,0x10
8000c0de:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c0e2:	e6 05 0d 02 	divu	r2,r3,r5
8000c0e6:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c0ea:	ec 02 02 4b 	mul	r11,r6,r2
8000c0ee:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c0f2:	16 3e       	cp.w	lr,r11
8000c0f4:	c0 72       	brcc	8000c102 <__avr32_umod64+0x92>
8000c0f6:	18 0e       	add	lr,r12
8000c0f8:	18 3e       	cp.w	lr,r12
8000c0fa:	c0 43       	brcs	8000c102 <__avr32_umod64+0x92>
8000c0fc:	16 3e       	cp.w	lr,r11
8000c0fe:	fd dc e3 0e 	addcs	lr,lr,r12
8000c102:	fc 0b 01 03 	sub	r3,lr,r11
8000c106:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c10a:	e6 05 0d 02 	divu	r2,r3,r5
8000c10e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c112:	a5 36       	mul	r6,r2
8000c114:	0c 39       	cp.w	r9,r6
8000c116:	c0 72       	brcc	8000c124 <__avr32_umod64+0xb4>
8000c118:	18 09       	add	r9,r12
8000c11a:	18 39       	cp.w	r9,r12
8000c11c:	c0 43       	brcs	8000c124 <__avr32_umod64+0xb4>
8000c11e:	0c 39       	cp.w	r9,r6
8000c120:	f3 dc e3 09 	addcs	r9,r9,r12
8000c124:	f2 06 01 06 	sub	r6,r9,r6
8000c128:	f4 08 09 4e 	lsl	lr,r10,r8
8000c12c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c130:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c134:	ec 0a 0d 02 	divu	r2,r6,r10
8000c138:	fc 09 16 10 	lsr	r9,lr,0x10
8000c13c:	ea 02 02 4b 	mul	r11,r5,r2
8000c140:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c144:	16 39       	cp.w	r9,r11
8000c146:	c0 72       	brcc	8000c154 <__avr32_umod64+0xe4>
8000c148:	18 09       	add	r9,r12
8000c14a:	18 39       	cp.w	r9,r12
8000c14c:	c0 43       	brcs	8000c154 <__avr32_umod64+0xe4>
8000c14e:	16 39       	cp.w	r9,r11
8000c150:	f3 dc e3 09 	addcs	r9,r9,r12
8000c154:	f2 0b 01 0b 	sub	r11,r9,r11
8000c158:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c15c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c160:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c164:	ea 0a 02 4a 	mul	r10,r5,r10
8000c168:	14 3e       	cp.w	lr,r10
8000c16a:	c0 72       	brcc	8000c178 <__avr32_umod64+0x108>
8000c16c:	18 0e       	add	lr,r12
8000c16e:	18 3e       	cp.w	lr,r12
8000c170:	c0 43       	brcs	8000c178 <__avr32_umod64+0x108>
8000c172:	14 3e       	cp.w	lr,r10
8000c174:	fd dc e3 0e 	addcs	lr,lr,r12
8000c178:	fc 0a 01 0a 	sub	r10,lr,r10
8000c17c:	30 0b       	mov	r11,0
8000c17e:	f4 08 0a 4a 	lsr	r10,r10,r8
8000c182:	c7 b8       	rjmp	8000c278 <__avr32_umod64+0x208>
8000c184:	16 39       	cp.w	r9,r11
8000c186:	e0 8b 00 79 	brhi	8000c278 <__avr32_umod64+0x208>
8000c18a:	f2 09 12 00 	clz	r9,r9
8000c18e:	c1 21       	brne	8000c1b2 <__avr32_umod64+0x142>
8000c190:	10 3a       	cp.w	r10,r8
8000c192:	5f 2b       	srhs	r11
8000c194:	0a 31       	cp.w	r1,r5
8000c196:	5f ba       	srhi	r10
8000c198:	f7 ea 10 0a 	or	r10,r11,r10
8000c19c:	f2 0a 18 00 	cp.b	r10,r9
8000c1a0:	c0 60       	breq	8000c1ac <__avr32_umod64+0x13c>
8000c1a2:	fc 08 01 0c 	sub	r12,lr,r8
8000c1a6:	e2 05 01 46 	sbc	r6,r1,r5
8000c1aa:	18 9e       	mov	lr,r12
8000c1ac:	0c 9b       	mov	r11,r6
8000c1ae:	1c 9a       	mov	r10,lr
8000c1b0:	c6 48       	rjmp	8000c278 <__avr32_umod64+0x208>
8000c1b2:	ea 09 09 4c 	lsl	r12,r5,r9
8000c1b6:	f2 06 11 20 	rsub	r6,r9,32
8000c1ba:	f6 09 09 4b 	lsl	r11,r11,r9
8000c1be:	f0 09 09 42 	lsl	r2,r8,r9
8000c1c2:	ef 46 ff f4 	st.w	r7[-12],r6
8000c1c6:	f0 06 0a 48 	lsr	r8,r8,r6
8000c1ca:	18 48       	or	r8,r12
8000c1cc:	e2 06 0a 4c 	lsr	r12,r1,r6
8000c1d0:	f4 09 09 43 	lsl	r3,r10,r9
8000c1d4:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000c1d8:	f4 06 0a 4a 	lsr	r10,r10,r6
8000c1dc:	16 4a       	or	r10,r11
8000c1de:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c1e2:	f8 0b 0d 04 	divu	r4,r12,r11
8000c1e6:	f4 0c 16 10 	lsr	r12,r10,0x10
8000c1ea:	08 91       	mov	r1,r4
8000c1ec:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000c1f0:	e8 0e 02 46 	mul	r6,r4,lr
8000c1f4:	0c 3c       	cp.w	r12,r6
8000c1f6:	c0 a2       	brcc	8000c20a <__avr32_umod64+0x19a>
8000c1f8:	20 11       	sub	r1,1
8000c1fa:	10 0c       	add	r12,r8
8000c1fc:	10 3c       	cp.w	r12,r8
8000c1fe:	c0 63       	brcs	8000c20a <__avr32_umod64+0x19a>
8000c200:	0c 3c       	cp.w	r12,r6
8000c202:	f7 b1 03 01 	sublo	r1,1
8000c206:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000c20a:	0c 1c       	sub	r12,r6
8000c20c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000c210:	f8 0b 0d 04 	divu	r4,r12,r11
8000c214:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000c218:	08 96       	mov	r6,r4
8000c21a:	e8 0e 02 4e 	mul	lr,r4,lr
8000c21e:	1c 3b       	cp.w	r11,lr
8000c220:	c0 a2       	brcc	8000c234 <__avr32_umod64+0x1c4>
8000c222:	20 16       	sub	r6,1
8000c224:	10 0b       	add	r11,r8
8000c226:	10 3b       	cp.w	r11,r8
8000c228:	c0 63       	brcs	8000c234 <__avr32_umod64+0x1c4>
8000c22a:	1c 3b       	cp.w	r11,lr
8000c22c:	f7 b6 03 01 	sublo	r6,1
8000c230:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000c234:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000c238:	1c 1b       	sub	r11,lr
8000c23a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000c23e:	00 9e       	mov	lr,r0
8000c240:	02 9c       	mov	r12,r1
8000c242:	16 3c       	cp.w	r12,r11
8000c244:	e0 8b 00 08 	brhi	8000c254 <__avr32_umod64+0x1e4>
8000c248:	5f 06       	sreq	r6
8000c24a:	06 30       	cp.w	r0,r3
8000c24c:	5f ba       	srhi	r10
8000c24e:	ed ea 00 0a 	and	r10,r6,r10
8000c252:	c0 60       	breq	8000c25e <__avr32_umod64+0x1ee>
8000c254:	fc 02 01 04 	sub	r4,lr,r2
8000c258:	f8 08 01 4c 	sbc	r12,r12,r8
8000c25c:	08 9e       	mov	lr,r4
8000c25e:	e6 0e 01 0a 	sub	r10,r3,lr
8000c262:	f6 0c 01 4c 	sbc	r12,r11,r12
8000c266:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000c26a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000c26e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c272:	f8 01 09 4c 	lsl	r12,r12,r1
8000c276:	18 4a       	or	r10,r12
8000c278:	2f dd       	sub	sp,-12
8000c27a:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000c400 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000c400:	c0 08       	rjmp	8000c400 <_evba>
	...

8000c404 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000c404:	c0 08       	rjmp	8000c404 <_handle_TLB_Multiple_Hit>
	...

8000c408 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000c408:	c0 08       	rjmp	8000c408 <_handle_Bus_Error_Data_Fetch>
	...

8000c40c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000c40c:	c0 08       	rjmp	8000c40c <_handle_Bus_Error_Instruction_Fetch>
	...

8000c410 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000c410:	c0 08       	rjmp	8000c410 <_handle_NMI>
	...

8000c414 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000c414:	c0 08       	rjmp	8000c414 <_handle_Instruction_Address>
	...

8000c418 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000c418:	c0 08       	rjmp	8000c418 <_handle_ITLB_Protection>
	...

8000c41c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000c41c:	c0 08       	rjmp	8000c41c <_handle_Breakpoint>
	...

8000c420 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000c420:	c0 08       	rjmp	8000c420 <_handle_Illegal_Opcode>
	...

8000c424 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000c424:	c0 08       	rjmp	8000c424 <_handle_Unimplemented_Instruction>
	...

8000c428 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000c428:	c0 08       	rjmp	8000c428 <_handle_Privilege_Violation>
	...

8000c42c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000c42c:	c0 08       	rjmp	8000c42c <_handle_Floating_Point>
	...

8000c430 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000c430:	c0 08       	rjmp	8000c430 <_handle_Coprocessor_Absent>
	...

8000c434 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000c434:	c0 08       	rjmp	8000c434 <_handle_Data_Address_Read>
	...

8000c438 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000c438:	c0 08       	rjmp	8000c438 <_handle_Data_Address_Write>
	...

8000c43c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000c43c:	c0 08       	rjmp	8000c43c <_handle_DTLB_Protection_Read>
	...

8000c440 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000c440:	c0 08       	rjmp	8000c440 <_handle_DTLB_Protection_Write>
	...

8000c444 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000c444:	c0 08       	rjmp	8000c444 <_handle_DTLB_Modified>
	...

8000c450 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000c450:	c0 08       	rjmp	8000c450 <_handle_ITLB_Miss>
	...

8000c460 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000c460:	c0 08       	rjmp	8000c460 <_handle_DTLB_Miss_Read>
	...

8000c470 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000c470:	c0 08       	rjmp	8000c470 <_handle_DTLB_Miss_Write>
	...

8000c500 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000c500:	fe cf 71 b8 	sub	pc,pc,29112

8000c504 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000c504:	30 0c       	mov	r12,0
8000c506:	fe b0 c3 95 	rcall	80004c30 <_get_interrupt_handler>
8000c50a:	58 0c       	cp.w	r12,0
8000c50c:	f8 0f 17 10 	movne	pc,r12
8000c510:	d6 03       	rete

8000c512 <_int1>:
8000c512:	30 1c       	mov	r12,1
8000c514:	fe b0 c3 8e 	rcall	80004c30 <_get_interrupt_handler>
8000c518:	58 0c       	cp.w	r12,0
8000c51a:	f8 0f 17 10 	movne	pc,r12
8000c51e:	d6 03       	rete

8000c520 <_int2>:
8000c520:	30 2c       	mov	r12,2
8000c522:	fe b0 c3 87 	rcall	80004c30 <_get_interrupt_handler>
8000c526:	58 0c       	cp.w	r12,0
8000c528:	f8 0f 17 10 	movne	pc,r12
8000c52c:	d6 03       	rete

8000c52e <_int3>:
8000c52e:	30 3c       	mov	r12,3
8000c530:	fe b0 c3 80 	rcall	80004c30 <_get_interrupt_handler>
8000c534:	58 0c       	cp.w	r12,0
8000c536:	f8 0f 17 10 	movne	pc,r12
8000c53a:	d6 03       	rete

8000c53c <ipr_val>:
8000c53c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000c54c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c55c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c56c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c57c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c58c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c59c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000c5fc:	d7 03 d7 03                                         ....
