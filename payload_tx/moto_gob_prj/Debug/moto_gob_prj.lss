
moto_gob_prj.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000992c  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ba00  8000ba00  0000be00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000011ac  8000bc00  8000bc00  0000c000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  8000cdac  8000cdac  0000d1ac  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000a34  00000008  8000cdb0  0000d408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  00000a3c  8000d7e4  0000de3c  2**0
                  ALLOC
  9 .bss          000035c8  00000a40  00000a40  00000000  2**2
                  ALLOC
 10 .heap         00012ff8  00004008  00004008  00000000  2**0
                  ALLOC
 11 .comment      00000030  00000000  00000000  0000de3c  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 00001120  00000000  00000000  0000de70  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 00002429  00000000  00000000  0000ef90  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_info   000280fc  00000000  00000000  000113b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_abbrev 0000672b  00000000  00000000  000394b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   0000bf98  00000000  00000000  0003fbe0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  00002cc0  00000000  00000000  0004bb78  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00006c8b  00000000  00000000  0004e838  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0000c717  00000000  00000000  000554c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  00017000  00017000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00001210  00000000  00000000  00061be0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf 9f f0 	sub	pc,pc,-24592

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf bf f4 	sub	pc,pc,-16396

Disassembly of section .text:

80002008 <DeviceManagement_brdcst_func>:
80002008:	19 a9       	ld.ub	r9,r12[0x2]
8000200a:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
8000200c:	f0 09 18 00 	cp.b	r9,r8
80002010:	c0 61       	brne	8000201c <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
80002012:	48 68       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
80002014:	70 09       	ld.w	r9,r8[0x0]
80002016:	a1 b9       	sbr	r9,0x1
80002018:	91 09       	st.w	r8[0x0],r9
8000201a:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
8000201c:	48 38       	lddpc	r8,80002028 <DeviceManagement_brdcst_func+0x20>
8000201e:	70 09       	ld.w	r9,r8[0x0]
80002020:	a1 d9       	cbr	r9,0x1
80002022:	91 09       	st.w	r8[0x0],r9
80002024:	5e fc       	retal	r12
80002026:	00 00       	add	r0,r0
80002028:	00 00       	add	r0,r0
8000202a:	0d a8       	ld.ub	r8,r6[0x2]

8000202c <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
8000202c:	5e fc       	retal	r12

8000202e <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202e:	5e fc       	retal	r12

80002030 <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
80002030:	48 38       	lddpc	r8,8000203c <vApplicationIdleHook+0xc>
80002032:	70 09       	ld.w	r9,r8[0x0]
80002034:	2f f9       	sub	r9,-1
80002036:	91 09       	st.w	r8[0x0],r9
	
}
80002038:	5e fc       	retal	r12
8000203a:	00 00       	add	r0,r0
8000203c:	00 00       	add	r0,r0
8000203e:	0a 68       	and	r8,r5

80002040 <app_init>:
														
		
};

void app_init(void)
{	
80002040:	d4 01       	pushm	lr
	
	payload_init( app_payload_rx_proc , app_payload_tx_proc );	
80002042:	48 cb       	lddpc	r11,80002070 <app_init+0x30>
80002044:	48 cc       	lddpc	r12,80002074 <app_init+0x34>
80002046:	f0 1f 00 0d 	mcall	80002078 <app_init+0x38>
	xcmp_register_app_list(the_app_list);
8000204a:	48 dc       	lddpc	r12,8000207c <app_init+0x3c>
8000204c:	f0 1f 00 0d 	mcall	80002080 <app_init+0x40>
			
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
80002050:	30 09       	mov	r9,0
80002052:	1a d9       	st.w	--sp,r9
80002054:	1a d9       	st.w	--sp,r9
80002056:	1a d9       	st.w	--sp,r9
80002058:	30 18       	mov	r8,1
8000205a:	e0 6a 01 80 	mov	r10,384
8000205e:	48 ab       	lddpc	r11,80002084 <app_init+0x44>
80002060:	48 ac       	lddpc	r12,80002088 <app_init+0x48>
80002062:	f0 1f 00 0b 	mcall	8000208c <app_init+0x4c>
80002066:	48 b8       	lddpc	r8,80002090 <app_init+0x50>
80002068:	91 0c       	st.w	r8[0x0],r12
8000206a:	2f dd       	sub	sp,-12
	,  NULL
	,  1
	,  NULL );
	
	
}
8000206c:	d8 02       	popm	pc
8000206e:	00 00       	add	r0,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	20 94       	sub	r4,9
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	28 0c       	sub	r12,-128
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	28 d8       	sub	r8,-115
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	37 e0       	mov	r0,126
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	bc 00       	st.h	lr[0x0],r0
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	27 24       	sub	r4,114
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	57 84       	stdsp	sp[0x1e0],r4
80002090:	00 00       	add	r0,r0
80002092:	0a 60       	and	r0,r5

80002094 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002094:	d4 01       	pushm	lr
  log("R");
80002096:	48 3c       	lddpc	r12,800020a0 <app_payload_tx_proc+0xc>
80002098:	f0 1f 00 03 	mcall	800020a4 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
8000209c:	d8 02       	popm	pc
8000209e:	00 00       	add	r0,r0
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	bc 08       	st.h	lr[0x0],r8
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	5b 48       	cp.w	r8,-12

800020a8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020a8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020aa:	48 3c       	lddpc	r12,800020b4 <FD_brdcst_func+0xc>
800020ac:	f0 1f 00 03 	mcall	800020b8 <FD_brdcst_func+0x10>
	
}
800020b0:	d8 02       	popm	pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	bc 0c       	st.h	lr[0x0],r12
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	5b 48       	cp.w	r8,-12

800020bc <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020bc:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020be:	48 3c       	lddpc	r12,800020c8 <FD_reply_func+0xc>
800020c0:	f0 1f 00 03 	mcall	800020cc <FD_reply_func+0x10>
	
	
}
800020c4:	d8 02       	popm	pc
800020c6:	00 00       	add	r0,r0
800020c8:	80 00       	ld.sh	r0,r0[0x0]
800020ca:	bc 2c       	st.h	lr[0x4],r12
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	5b 48       	cp.w	r8,-12

800020d0 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
800020d0:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
800020d2:	48 3c       	lddpc	r12,800020dc <FD_request_func+0xc>
800020d4:	f0 1f 00 03 	mcall	800020e0 <FD_request_func+0x10>
	
	
}
800020d8:	d8 02       	popm	pc
800020da:	00 00       	add	r0,r0
800020dc:	80 00       	ld.sh	r0,r0[0x0]
800020de:	bc 48       	st.h	lr[0x8],r8
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	5b 48       	cp.w	r8,-12

800020e4 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
800020e4:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
800020e6:	48 3c       	lddpc	r12,800020f0 <EnOB_brdcst_func+0xc>
800020e8:	f0 1f 00 03 	mcall	800020f4 <EnOB_brdcst_func+0x10>
}
800020ec:	d8 02       	popm	pc
800020ee:	00 00       	add	r0,r0
800020f0:	80 00       	ld.sh	r0,r0[0x0]
800020f2:	bc 64       	st.h	lr[0xc],r4
800020f4:	80 00       	ld.sh	r0,r0[0x0]
800020f6:	5b 48       	cp.w	r8,-12

800020f8 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
800020f8:	eb cd 40 80 	pushm	r7,lr
800020fc:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
800020fe:	19 a9       	ld.ub	r9,r12[0x2]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c1 91       	brne	80002138 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002108:	19 b8       	ld.ub	r8,r12[0x3]
8000210a:	30 19       	mov	r9,1
8000210c:	f2 08 18 00 	cp.b	r8,r9
80002110:	c0 61       	brne	8000211c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002112:	49 0c       	lddpc	r12,80002150 <EnOB_reply_func+0x58>
80002114:	f0 1f 00 10 	mcall	80002154 <EnOB_reply_func+0x5c>
80002118:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000211c:	58 08       	cp.w	r8,0
8000211e:	c0 61       	brne	8000212a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002120:	48 ec       	lddpc	r12,80002158 <EnOB_reply_func+0x60>
80002122:	f0 1f 00 0d 	mcall	80002154 <EnOB_reply_func+0x5c>
80002126:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000212a:	1a d8       	st.w	--sp,r8
8000212c:	48 cc       	lddpc	r12,8000215c <EnOB_reply_func+0x64>
8000212e:	f0 1f 00 0a 	mcall	80002154 <EnOB_reply_func+0x5c>
80002132:	2f fd       	sub	sp,-4
80002134:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002138:	48 ac       	lddpc	r12,80002160 <EnOB_reply_func+0x68>
8000213a:	f0 1f 00 07 	mcall	80002154 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000213e:	0f a8       	ld.ub	r8,r7[0x2]
80002140:	1a d8       	st.w	--sp,r8
80002142:	48 9c       	lddpc	r12,80002164 <EnOB_reply_func+0x6c>
80002144:	f0 1f 00 04 	mcall	80002154 <EnOB_reply_func+0x5c>
80002148:	2f fd       	sub	sp,-4
8000214a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000214e:	00 00       	add	r0,r0
80002150:	80 00       	ld.sh	r0,r0[0x0]
80002152:	bc 7c       	st.h	lr[0xe],r12
80002154:	80 00       	ld.sh	r0,r0[0x0]
80002156:	5b 48       	cp.w	r8,-12
80002158:	80 00       	ld.sh	r0,r0[0x0]
8000215a:	bc 94       	st.b	lr[0x1],r4
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	bc a8       	st.b	lr[0x2],r8
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	bc c0       	st.b	lr[0x4],r0
80002164:	80 00       	ld.sh	r0,r0[0x0]
80002166:	bc dc       	st.b	lr[0x5],r12

80002168 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002168:	eb cd 40 80 	pushm	r7,lr
8000216c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000216e:	19 a9       	ld.ub	r9,r12[0x2]
80002170:	31 18       	mov	r8,17
80002172:	f0 09 18 00 	cp.b	r9,r8
80002176:	c0 61       	brne	80002182 <SingleDetection_brdcst_func+0x1a>
	{
		log("\n\r DMR_CSBK OK \n\r");
80002178:	48 8c       	lddpc	r12,80002198 <SingleDetection_brdcst_func+0x30>
8000217a:	f0 1f 00 09 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
8000217e:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error");
80002182:	48 8c       	lddpc	r12,800021a0 <SingleDetection_brdcst_func+0x38>
80002184:	f0 1f 00 06 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
		log("\n\r Signal_type: %X \n\r", xcmp->u8[0] );
80002188:	0f a8       	ld.ub	r8,r7[0x2]
8000218a:	1a d8       	st.w	--sp,r8
8000218c:	48 6c       	lddpc	r12,800021a4 <SingleDetection_brdcst_func+0x3c>
8000218e:	f0 1f 00 04 	mcall	8000219c <SingleDetection_brdcst_func+0x34>
80002192:	2f fd       	sub	sp,-4
80002194:	e3 cd 80 80 	ldm	sp++,r7,pc
80002198:	80 00       	ld.sh	r0,r0[0x0]
8000219a:	bc f4       	st.b	lr[0x7],r4
8000219c:	80 00       	ld.sh	r0,r0[0x0]
8000219e:	5b 48       	cp.w	r8,-12
800021a0:	80 00       	ld.sh	r0,r0[0x0]
800021a2:	bd 08       	ld.d	r8,lr
800021a4:	80 00       	ld.sh	r0,r0[0x0]
800021a6:	bd 18       	ld.d	r8,--lr

800021a8 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021a8:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021aa:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ae:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021b0:	4a bc       	lddpc	r12,8000225c <ButtonConfig_brdcst_func+0xb4>
800021b2:	f0 1f 00 2c 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021b6:	0f 88       	ld.ub	r8,r7[0x0]
800021b8:	1a d8       	st.w	--sp,r8
800021ba:	4a bc       	lddpc	r12,80002264 <ButtonConfig_brdcst_func+0xbc>
800021bc:	f0 1f 00 29 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021c0:	1a d5       	st.w	--sp,r5
800021c2:	4a ac       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xc0>
800021c4:	f0 1f 00 27 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021c8:	0f a8       	ld.ub	r8,r7[0x2]
800021ca:	1a d8       	st.w	--sp,r8
800021cc:	4a 8c       	lddpc	r12,8000226c <ButtonConfig_brdcst_func+0xc4>
800021ce:	f0 1f 00 25 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021d2:	2f dd       	sub	sp,-12
800021d4:	58 05       	cp.w	r5,0
800021d6:	c4 10       	breq	80002258 <ButtonConfig_brdcst_func+0xb0>
800021d8:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021da:	4a 64       	lddpc	r4,80002270 <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021dc:	4a 63       	lddpc	r3,80002274 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021de:	4a 72       	lddpc	r2,80002278 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021e0:	4a 71       	lddpc	r1,8000227c <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021e2:	4a 80       	lddpc	r0,80002280 <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e4:	0f b9       	ld.ub	r9,r7[0x3]
800021e6:	0f c8       	ld.ub	r8,r7[0x4]
800021e8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021ec:	1a d8       	st.w	--sp,r8
800021ee:	1a d6       	st.w	--sp,r6
800021f0:	08 9c       	mov	r12,r4
800021f2:	f0 1f 00 1c 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021f6:	0f d9       	ld.ub	r9,r7[0x5]
800021f8:	0f e8       	ld.ub	r8,r7[0x6]
800021fa:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021fe:	1a d8       	st.w	--sp,r8
80002200:	1a d6       	st.w	--sp,r6
80002202:	06 9c       	mov	r12,r3
80002204:	f0 1f 00 17 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002208:	0f f9       	ld.ub	r9,r7[0x7]
8000220a:	ef 38 00 08 	ld.ub	r8,r7[8]
8000220e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002212:	1a d8       	st.w	--sp,r8
80002214:	1a d6       	st.w	--sp,r6
80002216:	04 9c       	mov	r12,r2
80002218:	f0 1f 00 12 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	ef 39 00 09 	ld.ub	r9,r7[9]
80002220:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	02 9c       	mov	r12,r1
8000222e:	f0 1f 00 0d 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
80002232:	2f 8d       	sub	sp,-32
80002234:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002238:	ef 38 00 0c 	ld.ub	r8,r7[12]
8000223c:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002240:	1a d8       	st.w	--sp,r8
80002242:	1a d6       	st.w	--sp,r6
80002244:	00 9c       	mov	r12,r0
80002246:	f0 1f 00 07 	mcall	80002260 <ButtonConfig_brdcst_func+0xb8>
8000224a:	2f f6       	sub	r6,-1
8000224c:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000224e:	2f ed       	sub	sp,-8
80002250:	ec 05 18 00 	cp.b	r5,r6
80002254:	fe 9b ff c8 	brhi	800021e4 <ButtonConfig_brdcst_func+0x3c>
80002258:	d8 32       	popm	r0-r7,pc
8000225a:	00 00       	add	r0,r0
8000225c:	80 00       	ld.sh	r0,r0[0x0]
8000225e:	bd 30       	mul	r0,lr
80002260:	80 00       	ld.sh	r0,r0[0x0]
80002262:	5b 48       	cp.w	r8,-12
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	bd 50       	asr	r0,0x1d
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	bd 64       	lsl	r4,0x1c
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	bd 7c       	lsl	r12,0x1d
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	bd 9c       	lsr	r12,0x1d
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	bd c4       	cbr	r4,0x1c
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	bd ec       	*unknown*
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	be 10       	st.h	pc[0x2],r0
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	be 38       	st.h	pc[0x6],r8

80002284 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002284:	eb cd 40 fc 	pushm	r2-r7,lr
	U16 PUI_ID =0;
	U8 PUI_State =0;
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
80002288:	19 a6       	ld.ub	r6,r12[0x2]
	PUI_Type = xcmp ->u8[1];
8000228a:	19 b5       	ld.ub	r5,r12[0x3]
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000228c:	19 c7       	ld.ub	r7,r12[0x4]
8000228e:	19 d8       	ld.ub	r8,r12[0x5]
80002290:	f1 e7 10 87 	or	r7,r8,r7<<0x8
	PUI_State = xcmp->u8[4];
80002294:	19 e4       	ld.ub	r4,r12[0x6]
	PUI_State_Min_Value = xcmp->u8[5];
80002296:	19 f3       	ld.ub	r3,r12[0x7]
	PUI_State_Max_Value = xcmp->u8[6];
80002298:	f9 32 00 08 	ld.ub	r2,r12[8]
	
	log("\n\r PhysicalUserInput_broadcast  \n\r"  );
8000229c:	49 0c       	lddpc	r12,800022dc <Phyuserinput_brdcst_func+0x58>
8000229e:	f0 1f 00 11 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	
	log("\n\r PUI_Source: %X \n\r" , PUI_Source);
800022a2:	1a d6       	st.w	--sp,r6
800022a4:	49 0c       	lddpc	r12,800022e4 <Phyuserinput_brdcst_func+0x60>
800022a6:	f0 1f 00 0f 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_Type: %X \n\r" , PUI_Type);
800022aa:	1a d5       	st.w	--sp,r5
800022ac:	48 fc       	lddpc	r12,800022e8 <Phyuserinput_brdcst_func+0x64>
800022ae:	f0 1f 00 0d 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_ID: %X \n\r" , PUI_ID);
800022b2:	5c 77       	castu.h	r7
800022b4:	1a d7       	st.w	--sp,r7
800022b6:	48 ec       	lddpc	r12,800022ec <Phyuserinput_brdcst_func+0x68>
800022b8:	f0 1f 00 0a 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State: %X \n\r" , PUI_State);
800022bc:	1a d4       	st.w	--sp,r4
800022be:	48 dc       	lddpc	r12,800022f0 <Phyuserinput_brdcst_func+0x6c>
800022c0:	f0 1f 00 08 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Min_Value: %X \n\r" , PUI_State_Min_Value);
800022c4:	1a d3       	st.w	--sp,r3
800022c6:	48 cc       	lddpc	r12,800022f4 <Phyuserinput_brdcst_func+0x70>
800022c8:	f0 1f 00 06 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
	log("\n\r PUI_State_Max_Value: %X \n\r" , PUI_State_Max_Value);
800022cc:	1a d2       	st.w	--sp,r2
800022ce:	48 bc       	lddpc	r12,800022f8 <Phyuserinput_brdcst_func+0x74>
800022d0:	f0 1f 00 04 	mcall	800022e0 <Phyuserinput_brdcst_func+0x5c>
800022d4:	2f ad       	sub	sp,-24
	
	
	
	
	
}
800022d6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800022da:	00 00       	add	r0,r0
800022dc:	80 00       	ld.sh	r0,r0[0x0]
800022de:	be 5c       	st.h	pc[0xa],r12
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	5b 48       	cp.w	r8,-12
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	be 80       	st.b	pc[0x0],r0
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	be 98       	st.b	pc[0x1],r8
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	be ac       	st.b	pc[0x2],r12
800022f0:	80 00       	ld.sh	r0,r0[0x0]
800022f2:	be c0       	st.b	pc[0x4],r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	be d4       	st.b	pc[0x5],r4
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	be f4       	st.b	pc[0x7],r4

800022fc <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022fc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002300:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002304:	0f 89       	ld.ub	r9,r7[0x0]
80002306:	30 08       	mov	r8,0
80002308:	f0 09 18 00 	cp.b	r9,r8
8000230c:	c0 c1       	brne	80002324 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
8000230e:	48 9c       	lddpc	r12,80002330 <ButtonConfig_reply_func+0x34>
80002310:	f0 1f 00 09 	mcall	80002334 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
80002314:	0f 98       	ld.ub	r8,r7[0x1]
80002316:	1a d8       	st.w	--sp,r8
80002318:	48 8c       	lddpc	r12,80002338 <ButtonConfig_reply_func+0x3c>
8000231a:	f0 1f 00 07 	mcall	80002334 <ButtonConfig_reply_func+0x38>
8000231e:	2f fd       	sub	sp,-4
80002320:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
80002324:	48 6c       	lddpc	r12,8000233c <ButtonConfig_reply_func+0x40>
80002326:	f0 1f 00 04 	mcall	80002334 <ButtonConfig_reply_func+0x38>
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	bf 14       	ld.d	r4,--pc
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	5b 48       	cp.w	r8,-12
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	bd 50       	asr	r0,0x1d
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	bf 2c       	st.d	pc++,r12

80002340 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002340:	d4 21       	pushm	r4-r7,lr
	U8 Session_number = 0;
	U16 data_length = 0;
	U8 i = 0;
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002342:	f8 c6 ff fe 	sub	r6,r12,-2

	if (ptr->State == CSBK_DATA_RX_Suc)
80002346:	0d 88       	ld.ub	r8,r6[0x0]
80002348:	32 49       	mov	r9,36
8000234a:	f2 08 18 00 	cp.b	r8,r9
8000234e:	c2 91       	brne	800023a0 <DataSession_brdcst_func+0x60>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002350:	49 7c       	lddpc	r12,800023ac <DataSession_brdcst_func+0x6c>
80002352:	f0 1f 00 18 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002356:	0d a5       	ld.ub	r5,r6[0x2]
80002358:	0d b8       	ld.ub	r8,r6[0x3]
8000235a:	f1 e5 10 85 	or	r5,r8,r5<<0x8
8000235e:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002360:	0d 98       	ld.ub	r8,r6[0x1]
80002362:	1a d8       	st.w	--sp,r8
80002364:	49 4c       	lddpc	r12,800023b4 <DataSession_brdcst_func+0x74>
80002366:	f0 1f 00 13 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000236a:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
8000236e:	1a d8       	st.w	--sp,r8
80002370:	49 2c       	lddpc	r12,800023b8 <DataSession_brdcst_func+0x78>
80002372:	f0 1f 00 10 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		for(i=0; i<data_length; i++)
80002376:	2f ed       	sub	sp,-8
80002378:	58 05       	cp.w	r5,0
8000237a:	c1 80       	breq	800023aa <DataSession_brdcst_func+0x6a>
8000237c:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
8000237e:	49 04       	lddpc	r4,800023bc <DataSession_brdcst_func+0x7c>
80002380:	ec 07 00 08 	add	r8,r6,r7
80002384:	11 c8       	ld.ub	r8,r8[0x4]
80002386:	1a d8       	st.w	--sp,r8
80002388:	1a d7       	st.w	--sp,r7
8000238a:	08 9c       	mov	r12,r4
8000238c:	f0 1f 00 09 	mcall	800023b0 <DataSession_brdcst_func+0x70>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002390:	2f f7       	sub	r7,-1
80002392:	5c 57       	castu.b	r7
80002394:	2f ed       	sub	sp,-8
80002396:	ee 05 19 00 	cp.h	r5,r7
8000239a:	fe 9b ff f3 	brhi	80002380 <DataSession_brdcst_func+0x40>
8000239e:	d8 22       	popm	r4-r7,pc
		
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		log("\n\r State: 0x %X \n\r", ptr->State);
800023a0:	1a d8       	st.w	--sp,r8
800023a2:	48 8c       	lddpc	r12,800023c0 <DataSession_brdcst_func+0x80>
800023a4:	f0 1f 00 03 	mcall	800023b0 <DataSession_brdcst_func+0x70>
800023a8:	2f fd       	sub	sp,-4
800023aa:	d8 22       	popm	r4-r7,pc
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	bf 48       	asr	r8,0x1e
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	5b 48       	cp.w	r8,-12
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	bf 5c       	asr	r12,0x1f
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	bf 74       	lsl	r4,0x1f
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	bf 90       	lsr	r0,0x1f
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	bf a8       	sbr	r8,0x1e

800023c4 <DataSession_reply_func>:
	
}


void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
800023c8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800023ca:	19 a8       	ld.ub	r8,r12[0x2]
800023cc:	58 08       	cp.w	r8,0
800023ce:	c0 61       	brne	800023da <DataSession_reply_func+0x16>
	{
		log("\n\r DATArep OK \n\r");
800023d0:	48 dc       	lddpc	r12,80002404 <DataSession_reply_func+0x40>
800023d2:	f0 1f 00 0e 	mcall	80002408 <DataSession_reply_func+0x44>
800023d6:	e3 cd 80 80 	ldm	sp++,r7,pc
		//log("\n\r ID: 0x %X \n\r", xcmp->u8[2]);
		
	}
	else
	{
		log("\n\r Result:  %X \n\r", xcmp->u8[0]);
800023da:	1a d8       	st.w	--sp,r8
800023dc:	48 cc       	lddpc	r12,8000240c <DataSession_reply_func+0x48>
800023de:	f0 1f 00 0b 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r DATArep error \n\r");
800023e2:	48 cc       	lddpc	r12,80002410 <DataSession_reply_func+0x4c>
800023e4:	f0 1f 00 09 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r Func:  %X \n\r", xcmp->u8[1]);
800023e8:	0f b8       	ld.ub	r8,r7[0x3]
800023ea:	1a d8       	st.w	--sp,r8
800023ec:	48 ac       	lddpc	r12,80002414 <DataSession_reply_func+0x50>
800023ee:	f0 1f 00 07 	mcall	80002408 <DataSession_reply_func+0x44>
		log("\n\r ID:  %X \n\r", xcmp->u8[2]);
800023f2:	0f c8       	ld.ub	r8,r7[0x4]
800023f4:	1a d8       	st.w	--sp,r8
800023f6:	48 9c       	lddpc	r12,80002418 <DataSession_reply_func+0x54>
800023f8:	f0 1f 00 04 	mcall	80002408 <DataSession_reply_func+0x44>
800023fc:	2f dd       	sub	sp,-12
800023fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002402:	00 00       	add	r0,r0
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	bf bc       	sbr	r12,0x1f
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	5b 48       	cp.w	r8,-12
8000240c:	80 00       	ld.sh	r0,r0[0x0]
8000240e:	bf d0       	cbr	r0,0x1f
80002410:	80 00       	ld.sh	r0,r0[0x0]
80002412:	bf e4       	*unknown*
80002414:	80 00       	ld.sh	r0,r0[0x0]
80002416:	bf f8       	*unknown*
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	c0 08       	rjmp	8000241a <DataSession_reply_func+0x56>

8000241c <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
8000241c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002420:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002424:	0f 99       	ld.ub	r9,r7[0x1]
80002426:	30 08       	mov	r8,0
80002428:	f0 09 18 00 	cp.b	r9,r8
8000242c:	c0 71       	brne	8000243a <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
8000242e:	48 ac       	lddpc	r12,80002454 <TransmitControl_brdcst_func+0x38>
80002430:	f0 1f 00 0a 	mcall	80002458 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002434:	30 09       	mov	r9,0
80002436:	48 a8       	lddpc	r8,8000245c <TransmitControl_brdcst_func+0x40>
80002438:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000243a:	0f 99       	ld.ub	r9,r7[0x1]
8000243c:	30 18       	mov	r8,1
8000243e:	f0 09 18 00 	cp.b	r9,r8
80002442:	c0 71       	brne	80002450 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002444:	48 7c       	lddpc	r12,80002460 <TransmitControl_brdcst_func+0x44>
80002446:	f0 1f 00 05 	mcall	80002458 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000244a:	30 19       	mov	r9,1
8000244c:	48 48       	lddpc	r8,8000245c <TransmitControl_brdcst_func+0x40>
8000244e:	b0 89       	st.b	r8[0x0],r9
80002450:	e3 cd 80 80 	ldm	sp++,r7,pc
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	c0 18       	rjmp	80002458 <TransmitControl_brdcst_func+0x3c>
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	5b 48       	cp.w	r8,-12
8000245c:	00 00       	add	r0,r0
8000245e:	0a 43       	or	r3,r5
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	c0 30       	breq	80002468 <TransmitControl_reply_func+0x4>

80002464 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002468:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
8000246c:	0f 89       	ld.ub	r9,r7[0x0]
8000246e:	30 08       	mov	r8,0
80002470:	f0 09 18 00 	cp.b	r9,r8
80002474:	c1 21       	brne	80002498 <TransmitControl_reply_func+0x34>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
80002476:	48 cc       	lddpc	r12,800024a4 <TransmitControl_reply_func+0x40>
80002478:	f0 1f 00 0c 	mcall	800024a8 <TransmitControl_reply_func+0x44>
		//log("\n\r Function: %x \n\r", ptr->Function);
		//log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
		//log("\n\r State: %x \n\r", ptr->State);
		//
		if (ptr->Function == KEY_UP)
8000247c:	0f 98       	ld.ub	r8,r7[0x1]
8000247e:	30 19       	mov	r9,1
80002480:	f2 08 18 00 	cp.b	r8,r9
80002484:	c0 d0       	breq	8000249e <TransmitControl_reply_func+0x3a>
		{
			//is_unmute = 1;
		}
		else if (ptr->Function ==DE_KEY)
80002486:	30 29       	mov	r9,2
80002488:	f2 08 18 00 	cp.b	r8,r9
8000248c:	c0 91       	brne	8000249e <TransmitControl_reply_func+0x3a>
		{
			is_unmute = 0;
8000248e:	30 09       	mov	r9,0
80002490:	48 78       	lddpc	r8,800024ac <TransmitControl_reply_func+0x48>
80002492:	b0 89       	st.b	r8[0x0],r9
80002494:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002498:	48 6c       	lddpc	r12,800024b0 <TransmitControl_reply_func+0x4c>
8000249a:	f0 1f 00 04 	mcall	800024a8 <TransmitControl_reply_func+0x44>
8000249e:	e3 cd 80 80 	ldm	sp++,r7,pc
800024a2:	00 00       	add	r0,r0
800024a4:	80 00       	ld.sh	r0,r0[0x0]
800024a6:	c0 44       	brge	800024ae <TransmitControl_reply_func+0x4a>
800024a8:	80 00       	ld.sh	r0,r0[0x0]
800024aa:	5b 48       	cp.w	r8,-12
800024ac:	00 00       	add	r0,r0
800024ae:	0a 54       	eor	r4,r5
800024b0:	80 00       	ld.sh	r0,r0[0x0]
800024b2:	c0 60       	breq	800024be <Volume_reply_func+0xa>

800024b4 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
800024b4:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
800024b8:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
800024bc:	0f 89       	ld.ub	r9,r7[0x0]
800024be:	30 08       	mov	r8,0
800024c0:	f0 09 18 00 	cp.b	r9,r8
800024c4:	c1 b1       	brne	800024fa <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024c6:	0f b8       	ld.ub	r8,r7[0x3]
800024c8:	31 09       	mov	r9,16
800024ca:	f2 08 18 00 	cp.b	r8,r9
800024ce:	c0 f1       	brne	800024ec <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024d0:	48 dc       	lddpc	r12,80002504 <Volume_reply_func+0x50>
800024d2:	f0 1f 00 0e 	mcall	80002508 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024d6:	0f 99       	ld.ub	r9,r7[0x1]
800024d8:	0f a8       	ld.ub	r8,r7[0x2]
800024da:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024de:	1a d8       	st.w	--sp,r8
800024e0:	48 bc       	lddpc	r12,8000250c <Volume_reply_func+0x58>
800024e2:	f0 1f 00 0a 	mcall	80002508 <Volume_reply_func+0x54>
800024e6:	2f fd       	sub	sp,-4
800024e8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024ec:	1a d8       	st.w	--sp,r8
800024ee:	48 9c       	lddpc	r12,80002510 <Volume_reply_func+0x5c>
800024f0:	f0 1f 00 06 	mcall	80002508 <Volume_reply_func+0x54>
800024f4:	2f fd       	sub	sp,-4
800024f6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024fa:	48 7c       	lddpc	r12,80002514 <Volume_reply_func+0x60>
800024fc:	f0 1f 00 03 	mcall	80002508 <Volume_reply_func+0x54>
80002500:	e3 cd 80 80 	ldm	sp++,r7,pc
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	c0 78       	rjmp	80002514 <Volume_reply_func+0x60>
80002508:	80 00       	ld.sh	r0,r0[0x0]
8000250a:	5b 48       	cp.w	r8,-12
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	c0 8c       	rcall	8000251e <spk_brdcst_func+0x6>
80002510:	80 00       	ld.sh	r0,r0[0x0]
80002512:	c0 a8       	rjmp	80002526 <spk_brdcst_func+0xe>
80002514:	80 00       	ld.sh	r0,r0[0x0]
80002516:	c0 c0       	breq	8000252e <spk_brdcst_func+0x16>

80002518 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002518:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
8000251a:	19 d9       	ld.ub	r9,r12[0x5]
8000251c:	30 08       	mov	r8,0
8000251e:	f0 09 18 00 	cp.b	r9,r8
80002522:	c0 51       	brne	8000252c <spk_brdcst_func+0x14>
	{
		//is_unmute =0;
		//Silent_flag = 0;
		log("spk_s_close ");
80002524:	48 4c       	lddpc	r12,80002534 <spk_brdcst_func+0x1c>
80002526:	f0 1f 00 05 	mcall	80002538 <spk_brdcst_func+0x20>
8000252a:	d8 02       	popm	pc
	}
	else
	{
		//Silent_flag = 1;
		//is_unmute = 1;
		log("spk_s_open ");
8000252c:	48 4c       	lddpc	r12,8000253c <spk_brdcst_func+0x24>
8000252e:	f0 1f 00 03 	mcall	80002538 <spk_brdcst_func+0x20>
80002532:	d8 02       	popm	pc
80002534:	80 00       	ld.sh	r0,r0[0x0]
80002536:	c0 d8       	rjmp	80002550 <spk_reply_func+0x10>
80002538:	80 00       	ld.sh	r0,r0[0x0]
8000253a:	5b 48       	cp.w	r8,-12
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	c0 e8       	rjmp	8000255a <spk_reply_func+0x1a>

80002540 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002540:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002542:	19 a9       	ld.ub	r9,r12[0x2]
80002544:	30 08       	mov	r8,0
80002546:	f0 09 18 00 	cp.b	r9,r8
8000254a:	c0 81       	brne	8000255a <spk_reply_func+0x1a>
		{
			//is_unmute = 1;
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254c:	19 e8       	ld.ub	r8,r12[0x6]
8000254e:	1a d8       	st.w	--sp,r8
80002550:	48 5c       	lddpc	r12,80002564 <spk_reply_func+0x24>
80002552:	f0 1f 00 06 	mcall	80002568 <spk_reply_func+0x28>
80002556:	2f fd       	sub	sp,-4
80002558:	d8 02       	popm	pc
		
	}
	else
	{
		log("spk error");
8000255a:	48 5c       	lddpc	r12,8000256c <spk_reply_func+0x2c>
8000255c:	f0 1f 00 03 	mcall	80002568 <spk_reply_func+0x28>
80002560:	d8 02       	popm	pc
80002562:	00 00       	add	r0,r0
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	c0 f4       	brge	80002584 <mic_brdcst_func+0x14>
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	5b 48       	cp.w	r8,-12
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	c1 04       	brge	8000258e <mic_brdcst_func+0x1e>

80002570 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002570:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
80002574:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002578:	0f a9       	ld.ub	r9,r7[0x2]
8000257a:	30 08       	mov	r8,0
8000257c:	f0 09 18 00 	cp.b	r9,r8
80002580:	c0 71       	brne	8000258e <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
80002582:	48 ac       	lddpc	r12,800025a8 <mic_brdcst_func+0x38>
80002584:	f0 1f 00 0a 	mcall	800025ac <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 0;
80002588:	30 09       	mov	r9,0
8000258a:	48 a8       	lddpc	r8,800025b0 <mic_brdcst_func+0x40>
8000258c:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
8000258e:	0f a9       	ld.ub	r9,r7[0x2]
80002590:	31 18       	mov	r8,17
80002592:	f0 09 18 00 	cp.b	r9,r8
80002596:	c0 71       	brne	800025a4 <mic_brdcst_func+0x34>
	{
		log("\n\r Mic_Enabled \n\r");	
80002598:	48 7c       	lddpc	r12,800025b4 <mic_brdcst_func+0x44>
8000259a:	f0 1f 00 05 	mcall	800025ac <mic_brdcst_func+0x3c>
		Mic_is_Enabled = 1;
8000259e:	30 19       	mov	r9,1
800025a0:	48 48       	lddpc	r8,800025b0 <mic_brdcst_func+0x40>
800025a2:	b0 89       	st.b	r8[0x0],r9
800025a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	c1 10       	breq	800025cc <mic_reply_func+0x14>
800025ac:	80 00       	ld.sh	r0,r0[0x0]
800025ae:	5b 48       	cp.w	r8,-12
800025b0:	00 00       	add	r0,r0
800025b2:	0a 55       	eor	r5,r5
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	c1 24       	brge	800025da <mic_reply_func+0x22>

800025b8 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025b8:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025bc:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025c0:	49 ac       	lddpc	r12,80002628 <mic_reply_func+0x70>
800025c2:	f0 1f 00 1b 	mcall	8000262c <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025c6:	0f 89       	ld.ub	r9,r7[0x0]
800025c8:	30 08       	mov	r8,0
800025ca:	f0 09 18 00 	cp.b	r9,r8
800025ce:	c2 71       	brne	8000261c <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025d0:	0f 98       	ld.ub	r8,r7[0x1]
800025d2:	30 29       	mov	r9,2
800025d4:	f2 08 18 00 	cp.b	r8,r9
800025d8:	c1 b1       	brne	8000260e <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025da:	49 6c       	lddpc	r12,80002630 <mic_reply_func+0x78>
800025dc:	f0 1f 00 14 	mcall	8000262c <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025e0:	0f a8       	ld.ub	r8,r7[0x2]
800025e2:	1a d8       	st.w	--sp,r8
800025e4:	49 4c       	lddpc	r12,80002634 <mic_reply_func+0x7c>
800025e6:	f0 1f 00 12 	mcall	8000262c <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800025ea:	0f b8       	ld.ub	r8,r7[0x3]
800025ec:	1a d8       	st.w	--sp,r8
800025ee:	49 3c       	lddpc	r12,80002638 <mic_reply_func+0x80>
800025f0:	f0 1f 00 0f 	mcall	8000262c <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800025f4:	0f c8       	ld.ub	r8,r7[0x4]
800025f6:	1a d8       	st.w	--sp,r8
800025f8:	49 1c       	lddpc	r12,8000263c <mic_reply_func+0x84>
800025fa:	f0 1f 00 0d 	mcall	8000262c <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800025fe:	0f d8       	ld.ub	r8,r7[0x5]
80002600:	1a d8       	st.w	--sp,r8
80002602:	49 0c       	lddpc	r12,80002640 <mic_reply_func+0x88>
80002604:	f0 1f 00 0a 	mcall	8000262c <mic_reply_func+0x74>
80002608:	2f cd       	sub	sp,-16
8000260a:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
8000260e:	1a d8       	st.w	--sp,r8
80002610:	48 dc       	lddpc	r12,80002644 <mic_reply_func+0x8c>
80002612:	f0 1f 00 07 	mcall	8000262c <mic_reply_func+0x74>
80002616:	2f fd       	sub	sp,-4
80002618:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
8000261c:	48 bc       	lddpc	r12,80002648 <mic_reply_func+0x90>
8000261e:	f0 1f 00 04 	mcall	8000262c <mic_reply_func+0x74>
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
80002626:	00 00       	add	r0,r0
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	c1 38       	rjmp	80002650 <dcm_brdcst_func+0x4>
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	5b 48       	cp.w	r8,-12
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	c1 48       	rjmp	8000265a <dcm_brdcst_func+0xe>
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	c1 5c       	rcall	80002660 <dcm_brdcst_func+0x14>
80002638:	80 00       	ld.sh	r0,r0[0x0]
8000263a:	c1 70       	breq	80002668 <dcm_brdcst_func+0x1c>
8000263c:	80 00       	ld.sh	r0,r0[0x0]
8000263e:	c1 8c       	rcall	8000266e <dcm_brdcst_func+0x22>
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	c1 a4       	brge	80002676 <dcm_brdcst_func+0x2a>
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	c1 bc       	rcall	8000267c <dcm_brdcst_func+0x30>
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	c1 d4       	brge	80002684 <dcm_brdcst_func+0x38>

8000264c <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
8000264c:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002650:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
80002654:	48 bc       	lddpc	r12,80002680 <dcm_brdcst_func+0x34>
80002656:	f0 1f 00 0c 	mcall	80002684 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
8000265a:	0f 88       	ld.ub	r8,r7[0x0]
8000265c:	1a d8       	st.w	--sp,r8
8000265e:	48 bc       	lddpc	r12,80002688 <dcm_brdcst_func+0x3c>
80002660:	f0 1f 00 09 	mcall	80002684 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
80002664:	0f a8       	ld.ub	r8,r7[0x2]
80002666:	1a d8       	st.w	--sp,r8
80002668:	48 9c       	lddpc	r12,8000268c <dcm_brdcst_func+0x40>
8000266a:	f0 1f 00 07 	mcall	80002684 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
8000266e:	0f 98       	ld.ub	r8,r7[0x1]
80002670:	1a d8       	st.w	--sp,r8
80002672:	48 8c       	lddpc	r12,80002690 <dcm_brdcst_func+0x44>
80002674:	f0 1f 00 04 	mcall	80002684 <dcm_brdcst_func+0x38>
80002678:	2f dd       	sub	sp,-12
	
	
}
8000267a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000267e:	00 00       	add	r0,r0
80002680:	80 00       	ld.sh	r0,r0[0x0]
80002682:	c1 e4       	brge	800026be <dcm_reply_func+0x2a>
80002684:	80 00       	ld.sh	r0,r0[0x0]
80002686:	5b 48       	cp.w	r8,-12
80002688:	80 00       	ld.sh	r0,r0[0x0]
8000268a:	c1 f8       	rjmp	800026c8 <dcm_reply_func+0x34>
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	c2 0c       	rcall	800026ce <dcm_reply_func+0x3a>
80002690:	80 00       	ld.sh	r0,r0[0x0]
80002692:	c2 24       	brge	800026d6 <dcm_reply_func+0x42>

80002694 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002694:	eb cd 40 80 	pushm	r7,lr
80002698:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000269a:	19 a9       	ld.ub	r9,r12[0x2]
8000269c:	30 08       	mov	r8,0
8000269e:	f0 09 18 00 	cp.b	r9,r8
800026a2:	c1 b1       	brne	800026d8 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026a4:	19 b8       	ld.ub	r8,r12[0x3]
800026a6:	30 19       	mov	r9,1
800026a8:	f2 08 18 00 	cp.b	r8,r9
800026ac:	c0 51       	brne	800026b6 <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026ae:	48 ec       	lddpc	r12,800026e4 <dcm_reply_func+0x50>
800026b0:	f0 1f 00 0e 	mcall	800026e8 <dcm_reply_func+0x54>
800026b4:	c0 a8       	rjmp	800026c8 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026b6:	58 08       	cp.w	r8,0
800026b8:	c0 51       	brne	800026c2 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026ba:	48 dc       	lddpc	r12,800026ec <dcm_reply_func+0x58>
800026bc:	f0 1f 00 0b 	mcall	800026e8 <dcm_reply_func+0x54>
800026c0:	c0 48       	rjmp	800026c8 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026c2:	48 cc       	lddpc	r12,800026f0 <dcm_reply_func+0x5c>
800026c4:	f0 1f 00 09 	mcall	800026e8 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026c8:	0f d8       	ld.ub	r8,r7[0x5]
800026ca:	1a d8       	st.w	--sp,r8
800026cc:	48 ac       	lddpc	r12,800026f4 <dcm_reply_func+0x60>
800026ce:	f0 1f 00 07 	mcall	800026e8 <dcm_reply_func+0x54>
800026d2:	2f fd       	sub	sp,-4
800026d4:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026d8:	48 8c       	lddpc	r12,800026f8 <dcm_reply_func+0x64>
800026da:	f0 1f 00 04 	mcall	800026e8 <dcm_reply_func+0x54>
800026de:	e3 cd 80 80 	ldm	sp++,r7,pc
800026e2:	00 00       	add	r0,r0
800026e4:	80 00       	ld.sh	r0,r0[0x0]
800026e6:	c2 40       	breq	8000272e <app_cfg+0xa>
800026e8:	80 00       	ld.sh	r0,r0[0x0]
800026ea:	5b 48       	cp.w	r8,-12
800026ec:	80 00       	ld.sh	r0,r0[0x0]
800026ee:	c2 54       	brge	80002738 <app_cfg+0x14>
800026f0:	80 00       	ld.sh	r0,r0[0x0]
800026f2:	c2 68       	rjmp	8000273e <app_cfg+0x1a>
800026f4:	80 00       	ld.sh	r0,r0[0x0]
800026f6:	c2 7c       	rcall	80002744 <app_cfg+0x20>
800026f8:	80 00       	ld.sh	r0,r0[0x0]
800026fa:	c2 88       	rjmp	8000274a <app_cfg+0x26>

800026fc <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800026fc:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800026fe:	19 a9       	ld.ub	r9,r12[0x2]
80002700:	30 08       	mov	r8,0
80002702:	f0 09 18 00 	cp.b	r9,r8
80002706:	c0 51       	brne	80002710 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK");
80002708:	48 4c       	lddpc	r12,80002718 <ToneControl_reply_func+0x1c>
8000270a:	f0 1f 00 05 	mcall	8000271c <ToneControl_reply_func+0x20>
8000270e:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002710:	48 4c       	lddpc	r12,80002720 <ToneControl_reply_func+0x24>
80002712:	f0 1f 00 03 	mcall	8000271c <ToneControl_reply_func+0x20>
80002716:	d8 02       	popm	pc
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	c2 94       	brge	8000276c <app_cfg+0x48>
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	5b 48       	cp.w	r8,-12
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	c2 9c       	rcall	80002774 <app_cfg+0x50>

80002724 <app_cfg>:

extern  char AudioData[];
extern U32 tc_tick;

static __app_Thread_(app_cfg)
{
80002724:	d4 31       	pushm	r0-r7,lr
	static  U32 isAudioRouting = 0;
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	
	 xLastWakeTime = xTaskGetTickCount();
80002726:	f0 1f 00 29 	mcall	800027c8 <app_cfg+0xa4>
8000272a:	4a 98       	lddpc	r8,800027cc <app_cfg+0xa8>
8000272c:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000272e:	4a 97       	lddpc	r7,800027d0 <app_cfg+0xac>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
80002730:	4a 96       	lddpc	r6,800027d4 <app_cfg+0xb0>
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				//log("\n\r un: %d \n\r", is_unmute);
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
				
				log("\r Tone_flag: %d \r", Tone_flag);
80002732:	4a a5       	lddpc	r5,800027d8 <app_cfg+0xb4>
80002734:	4a a4       	lddpc	r4,800027dc <app_cfg+0xb8>
				log("\r Terminator_Flag: %d \r", Terminator_Flag);
80002736:	4a b3       	lddpc	r3,800027e0 <app_cfg+0xbc>
80002738:	4a b2       	lddpc	r2,800027e4 <app_cfg+0xc0>
				//Terminator_Flag
				//log("\n\r Tone_counters: %d \n\r", Tone_Counters);
				log("\r Silent_flag: %d \r", Silent_flag);
8000273a:	4a c1       	lddpc	r1,800027e8 <app_cfg+0xc4>
8000273c:	4a c0       	lddpc	r0,800027ec <app_cfg+0xc8>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003))//确认连接成功了，再发送请求
8000273e:	6e 08       	ld.w	r8,r7[0x0]
80002740:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002744:	58 38       	cp.w	r8,3
80002746:	c3 a1       	brne	800027ba <app_cfg+0x96>
				//{
					////xcmp_transmit_dekeycontrol();
					//
				//}
				
				if(isAudioRouting == 0)
80002748:	6c 08       	ld.w	r8,r6[0x0]
8000274a:	58 08       	cp.w	r8,0
8000274c:	c0 61       	brne	80002758 <app_cfg+0x34>
				{
					//xcmp_data_session();
					xcmp_audio_route_mic();
8000274e:	f0 1f 00 29 	mcall	800027f0 <app_cfg+0xcc>
					//xcmp_enter_device_control_mode();//调换3个命令的顺序，则不会导致掉线。。。奇葩
					//xcmp_unmute_speaker();
					//is_unmute = 1;
					//xcmp_function_mic();
					
					isAudioRouting = 1;
80002752:	30 18       	mov	r8,1
80002754:	8d 08       	st.w	r6[0x0],r8
80002756:	c1 48       	rjmp	8000277e <app_cfg+0x5a>
				}
				else if(isAudioRouting == 1)
80002758:	58 18       	cp.w	r8,1
8000275a:	c0 41       	brne	80002762 <app_cfg+0x3e>
					//xcmp_button_config();
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//log("\n\r time: %d \n\r", tc_tick);
					
					isAudioRouting = 2;
8000275c:	30 28       	mov	r8,2
8000275e:	8d 08       	st.w	r6[0x0],r8
80002760:	c0 f8       	rjmp	8000277e <app_cfg+0x5a>
					//isAudioRouting++;
				}
				else if(isAudioRouting == 2)
80002762:	58 28       	cp.w	r8,2
80002764:	c0 41       	brne	8000276c <app_cfg+0x48>
					//xcmp_audio_route_speaker();
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_mute_speaker();	
					//log("\n\r time: %d \n\r", tc_tick); 
					isAudioRouting = 3;
80002766:	30 38       	mov	r8,3
80002768:	8d 08       	st.w	r6[0x0],r8
8000276a:	c0 a8       	rjmp	8000277e <app_cfg+0x5a>
					//xcmp_unmute_speaker();
					//xcmp_enter_device_control_mode();
					//xcmp_exit_enhanced_OB_mode();
					//xcmp_mute_speaker();
					//xcmp_enhanced_OB_mode();
					isAudioRouting = 4;
8000276c:	58 38       	cp.w	r8,3
8000276e:	f9 b8 00 04 	moveq	r8,4
80002772:	ed f8 0a 00 	st.weq	r6[0x0],r8
					
				}
				else
				{
					isAudioRouting++;
80002776:	f7 b8 01 ff 	subne	r8,-1
8000277a:	ed f8 1a 00 	st.wne	r6[0x0],r8
				//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
				//log("\n\r un: %d \n\r", is_unmute);
				//log("\n\r S_flag: %d \n\r", Silent_flag);
				//log("\n\r Tend_flag: %d \n\r", Terminator_Flag);
				
				log("\r Tone_flag: %d \r", Tone_flag);
8000277e:	0b 88       	ld.ub	r8,r5[0x0]
80002780:	1a d8       	st.w	--sp,r8
80002782:	08 9c       	mov	r12,r4
80002784:	f0 1f 00 1c 	mcall	800027f4 <app_cfg+0xd0>
				log("\r Terminator_Flag: %d \r", Terminator_Flag);
80002788:	05 88       	ld.ub	r8,r2[0x0]
8000278a:	1a d8       	st.w	--sp,r8
8000278c:	06 9c       	mov	r12,r3
8000278e:	f0 1f 00 1a 	mcall	800027f4 <app_cfg+0xd0>
				//Terminator_Flag
				//log("\n\r Tone_counters: %d \n\r", Tone_Counters);
				log("\r Silent_flag: %d \r", Silent_flag);
80002792:	03 88       	ld.ub	r8,r1[0x0]
80002794:	1a d8       	st.w	--sp,r8
80002796:	00 9c       	mov	r12,r0
80002798:	f0 1f 00 17 	mcall	800027f4 <app_cfg+0xd0>
				if (Rx_Mic_data)
8000279c:	49 79       	lddpc	r9,800027f8 <app_cfg+0xd4>
8000279e:	13 88       	ld.ub	r8,r9[0x0]
800027a0:	2f dd       	sub	sp,-12
800027a2:	58 08       	cp.w	r8,0
800027a4:	c0 40       	breq	800027ac <app_cfg+0x88>
				{
					log("\n\r OB Receive Mic Data \n\r");
800027a6:	49 6c       	lddpc	r12,800027fc <app_cfg+0xd8>
800027a8:	f0 1f 00 13 	mcall	800027f4 <app_cfg+0xd0>
				}
				if (Rx_Speaker_data)
800027ac:	49 58       	lddpc	r8,80002800 <app_cfg+0xdc>
800027ae:	11 88       	ld.ub	r8,r8[0x0]
800027b0:	58 08       	cp.w	r8,0
800027b2:	c0 40       	breq	800027ba <app_cfg+0x96>
				{
					log("\n\r OB Receive Speaker Data \n\r");
800027b4:	49 4c       	lddpc	r12,80002804 <app_cfg+0xe0>
800027b6:	f0 1f 00 10 	mcall	800027f4 <app_cfg+0xd0>
			
		}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, 2000*2 / portTICK_RATE_MS  );//精确的以2000ms为周期执行。
800027ba:	e0 6b 0f a0 	mov	r11,4000
800027be:	48 4c       	lddpc	r12,800027cc <app_cfg+0xa8>
800027c0:	f0 1f 00 12 	mcall	80002808 <app_cfg+0xe4>
	}
800027c4:	cb db       	rjmp	8000273e <app_cfg+0x1a>
800027c6:	00 00       	add	r0,r0
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	54 bc       	stdsp	sp[0x12c],r12
800027cc:	00 00       	add	r0,r0
800027ce:	0a 50       	eor	r0,r5
800027d0:	00 00       	add	r0,r0
800027d2:	0d a8       	ld.ub	r8,r6[0x2]
800027d4:	00 00       	add	r0,r0
800027d6:	0a 58       	eor	r8,r5
800027d8:	00 00       	add	r0,r0
800027da:	0a 4c       	or	r12,r5
800027dc:	80 00       	ld.sh	r0,r0[0x0]
800027de:	c2 a8       	rjmp	80002832 <app_payload_rx_proc+0x26>
800027e0:	80 00       	ld.sh	r0,r0[0x0]
800027e2:	c2 bc       	rcall	80002838 <app_payload_rx_proc+0x2c>
800027e4:	00 00       	add	r0,r0
800027e6:	0a 64       	and	r4,r5
800027e8:	00 00       	add	r0,r0
800027ea:	0a 5c       	eor	r12,r5
800027ec:	80 00       	ld.sh	r0,r0[0x0]
800027ee:	c2 d4       	brge	80002848 <app_payload_rx_proc+0x3c>
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	38 34       	mov	r4,-125
800027f4:	80 00       	ld.sh	r0,r0[0x0]
800027f6:	5b 48       	cp.w	r8,-12
800027f8:	00 00       	add	r0,r0
800027fa:	0a 44       	or	r4,r5
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	c2 e8       	rjmp	8000285a <AudioRoutingControl_reply_func+0xa>
80002800:	00 00       	add	r0,r0
80002802:	0a 56       	eor	r6,r5
80002804:	80 00       	ld.sh	r0,r0[0x0]
80002806:	c3 04       	brge	80002866 <AudioRoutingControl_reply_func+0x16>
80002808:	80 00       	ld.sh	r0,r0[0x0]
8000280a:	56 24       	stdsp	sp[0x188],r4

8000280c <app_payload_rx_proc>:
}


static void app_payload_rx_proc(void  * payload)
{
8000280c:	eb cd 40 80 	pushm	r7,lr
80002810:	18 97       	mov	r7,r12
	static  U8 times_counter = 0;
	
	times_counter++;
80002812:	48 b9       	lddpc	r9,8000283c <app_payload_rx_proc+0x30>
80002814:	13 88       	ld.ub	r8,r9[0x0]
80002816:	2f f8       	sub	r8,-1
80002818:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 30)
8000281a:	31 e9       	mov	r9,30
8000281c:	f2 08 18 00 	cp.b	r8,r9
80002820:	c0 71       	brne	8000282e <app_payload_rx_proc+0x22>
	{
		times_counter = 0 ;
80002822:	30 09       	mov	r9,0
80002824:	48 68       	lddpc	r8,8000283c <app_payload_rx_proc+0x30>
80002826:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
80002828:	48 6c       	lddpc	r12,80002840 <app_payload_rx_proc+0x34>
8000282a:	f0 1f 00 07 	mcall	80002844 <app_payload_rx_proc+0x38>
	{
		//fl_write("PCMvo.pcm", FILE_END, payload, MAX_PAYLOAD_BUFF_SIZE * 2);
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	set_payload_idle(payload);
8000282e:	48 78       	lddpc	r8,80002848 <app_payload_rx_proc+0x3c>
80002830:	70 0c       	ld.w	r12,r8[0x0]
80002832:	0e 9b       	mov	r11,r7
80002834:	f0 1f 00 06 	mcall	8000284c <app_payload_rx_proc+0x40>

}
80002838:	e3 cd 80 80 	ldm	sp++,r7,pc
8000283c:	00 00       	add	r0,r0
8000283e:	0a 41       	or	r1,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	c3 24       	brge	800028a6 <DeviceInitializationStatus_brdcst_func+0x6>
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	5b 48       	cp.w	r8,-12
80002848:	00 00       	add	r0,r0
8000284a:	0a 80       	andn	r0,r5
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	29 b0       	sub	r0,-101

80002850 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
80002850:	eb cd 40 80 	pushm	r7,lr
80002854:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002856:	19 a9       	ld.ub	r9,r12[0x2]
80002858:	30 08       	mov	r8,0
8000285a:	f0 09 18 00 	cp.b	r9,r8
8000285e:	c0 c1       	brne	80002876 <AudioRoutingControl_reply_func+0x26>
	{
		log("AudioRouting OK");
80002860:	48 bc       	lddpc	r12,8000288c <AudioRoutingControl_reply_func+0x3c>
80002862:	f0 1f 00 0c 	mcall	80002890 <AudioRoutingControl_reply_func+0x40>
		xcmp_IdleTestTone();//提示通道配置成功
80002866:	f0 1f 00 0c 	mcall	80002894 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
8000286a:	f0 1f 00 0b 	mcall	80002894 <AudioRoutingControl_reply_func+0x44>
		xcmp_IdleTestTone();
8000286e:	f0 1f 00 0a 	mcall	80002894 <AudioRoutingControl_reply_func+0x44>
80002872:	e3 cd 80 80 	ldm	sp++,r7,pc
		//is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002876:	48 9c       	lddpc	r12,80002898 <AudioRoutingControl_reply_func+0x48>
80002878:	f0 1f 00 06 	mcall	80002890 <AudioRoutingControl_reply_func+0x40>
		log("\n\r AudioRouting result: %x \n\r", xcmp->u8[0]);
8000287c:	0f a8       	ld.ub	r8,r7[0x2]
8000287e:	1a d8       	st.w	--sp,r8
80002880:	48 7c       	lddpc	r12,8000289c <AudioRoutingControl_reply_func+0x4c>
80002882:	f0 1f 00 04 	mcall	80002890 <AudioRoutingControl_reply_func+0x40>
80002886:	2f fd       	sub	sp,-4
80002888:	e3 cd 80 80 	ldm	sp++,r7,pc
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	c3 30       	breq	800028f4 <payload_init+0x1c>
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	5b 48       	cp.w	r8,-12
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	39 1c       	mov	r12,-111
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	c3 40       	breq	80002902 <payload_init+0x2a>
8000289c:	80 00       	ld.sh	r0,r0[0x0]
8000289e:	c3 54       	brge	80002908 <payload_init+0x30>

800028a0 <DeviceInitializationStatus_brdcst_func>:
static void app_payload_tx_proc(void  * payload);

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800028a0:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800028a2:	19 e8       	ld.ub	r8,r12[0x6]
800028a4:	30 19       	mov	r9,1
800028a6:	f2 08 18 00 	cp.b	r8,r9
800028aa:	c0 61       	brne	800028b6 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800028ac:	48 98       	lddpc	r8,800028d0 <DeviceInitializationStatus_brdcst_func+0x30>
800028ae:	70 09       	ld.w	r9,r8[0x0]
800028b0:	a1 a9       	sbr	r9,0x0
800028b2:	91 09       	st.w	r8[0x0],r9
800028b4:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800028b6:	30 29       	mov	r9,2
800028b8:	f2 08 18 00 	cp.b	r8,r9
800028bc:	c0 80       	breq	800028cc <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800028be:	48 58       	lddpc	r8,800028d0 <DeviceInitializationStatus_brdcst_func+0x30>
800028c0:	70 09       	ld.w	r9,r8[0x0]
800028c2:	e0 19 ff fc 	andl	r9,0xfffc
800028c6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800028c8:	f0 1f 00 03 	mcall	800028d4 <DeviceInitializationStatus_brdcst_func+0x34>
800028cc:	d8 02       	popm	pc
800028ce:	00 00       	add	r0,r0
800028d0:	00 00       	add	r0,r0
800028d2:	0d a8       	ld.ub	r8,r6[0x2]
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	38 70       	mov	r0,-121

800028d8 <payload_init>:
	Create the corresponding task;
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
800028d8:	d4 01       	pushm	lr
	payload_rx_exec = payload_rx_func;
800028da:	48 98       	lddpc	r8,800028fc <payload_init+0x24>
800028dc:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800028de:	48 98       	lddpc	r8,80002900 <payload_init+0x28>
800028e0:	91 0b       	st.w	r8[0x0],r11
	
	
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
800028e2:	30 09       	mov	r9,0
800028e4:	1a d9       	st.w	--sp,r9
800028e6:	1a d9       	st.w	--sp,r9
800028e8:	1a d9       	st.w	--sp,r9
800028ea:	30 28       	mov	r8,2
800028ec:	e0 6a 04 00 	mov	r10,1024
800028f0:	48 5b       	lddpc	r11,80002904 <payload_init+0x2c>
800028f2:	48 6c       	lddpc	r12,80002908 <payload_init+0x30>
800028f4:	f0 1f 00 06 	mcall	8000290c <payload_init+0x34>
800028f8:	2f dd       	sub	sp,-12
	//,  2
	//,  NULL
	//);
	//
	
}
800028fa:	d8 02       	popm	pc
800028fc:	00 00       	add	r0,r0
800028fe:	0a 6c       	and	r12,r5
80002900:	00 00       	add	r0,r0
80002902:	0a 70       	tst	r0,r5
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	c3 74       	brge	80002974 <set_idle_store_isr+0x18>
80002908:	80 00       	ld.sh	r0,r0[0x0]
8000290a:	29 10       	sub	r0,-111
8000290c:	80 00       	ld.sh	r0,r0[0x0]
8000290e:	57 84       	stdsp	sp[0x1e0],r4

80002910 <payload_rx_process>:
Description: Receive the payload
Calls:
Called By:task
*/
static void payload_rx_process(void * pvParameters)
{
80002910:	eb cd 40 f8 	pushm	r3-r7,lr
80002914:	20 1d       	sub	sp,4
	/*To store the elements in the queue*/
	U16  * payload_ptr;
		
	if(NULL ==   phy_payload_frame_rx)
80002916:	48 e8       	lddpc	r8,8000294c <payload_rx_process+0x3c>
80002918:	70 08       	ld.w	r8,r8[0x0]
8000291a:	58 08       	cp.w	r8,0
8000291c:	c0 71       	brne	8000292a <payload_rx_process+0x1a>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
8000291e:	30 4b       	mov	r11,4
80002920:	30 5c       	mov	r12,5
80002922:	f0 1f 00 0c 	mcall	80002950 <payload_rx_process+0x40>
80002926:	48 a8       	lddpc	r8,8000294c <payload_rx_process+0x3c>
80002928:	91 0c       	st.w	r8[0x0],r12
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
8000292a:	48 96       	lddpc	r6,8000294c <payload_rx_process+0x3c>
8000292c:	30 05       	mov	r5,0
8000292e:	3f f4       	mov	r4,-1
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002930:	48 93       	lddpc	r3,80002954 <payload_rx_process+0x44>
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	}
	
	for(;;)
	{
		if(pdTRUE == xQueueReceive( phy_payload_frame_rx, &payload_ptr,portMAX_DELAY ))
80002932:	6c 0c       	ld.w	r12,r6[0x0]
80002934:	0a 99       	mov	r9,r5
80002936:	08 9a       	mov	r10,r4
80002938:	1a 9b       	mov	r11,sp
8000293a:	f0 1f 00 08 	mcall	80002958 <payload_rx_process+0x48>
8000293e:	58 1c       	cp.w	r12,1
80002940:	cf 91       	brne	80002932 <payload_rx_process+0x22>
		{			
			payload_rx_exec(payload_ptr);//app_payload_rx_proc();
80002942:	66 08       	ld.w	r8,r3[0x0]
80002944:	40 0c       	lddsp	r12,sp[0x0]
80002946:	5d 18       	icall	r8
80002948:	cf 5b       	rjmp	80002932 <payload_rx_process+0x22>
8000294a:	00 00       	add	r0,r0
8000294c:	00 00       	add	r0,r0
8000294e:	0a c0       	st.b	r5++,r0
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	50 b0       	stdsp	sp[0x2c],r0
80002954:	00 00       	add	r0,r0
80002956:	0a 6c       	and	r12,r5
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	4d 4c       	lddpc	r12,80002aa8 <phy_tx_func+0x54>

8000295c <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
8000295c:	d4 01       	pushm	lr
8000295e:	20 2d       	sub	sp,8
80002960:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002962:	30 09       	mov	r9,0
80002964:	fa ca ff f8 	sub	r10,sp,-8
80002968:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
8000296a:	1a 9b       	mov	r11,sp
8000296c:	f0 1f 00 02 	mcall	80002974 <set_idle_store_isr+0x18>
}
80002970:	2f ed       	sub	sp,-8
80002972:	d8 02       	popm	pc
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	4f 08       	lddpc	r8,80002b34 <phy_tx_func+0xe0>

80002978 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002978:	d4 01       	pushm	lr
8000297a:	20 2d       	sub	sp,8
8000297c:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
8000297e:	58 0c       	cp.w	r12,0
80002980:	c1 10       	breq	800029a2 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002982:	30 08       	mov	r8,0
80002984:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002986:	98 88       	ld.uh	r8,r12[0x0]
80002988:	e2 18 f0 00 	andl	r8,0xf000,COH
8000298c:	e0 48 40 00 	cp.w	r8,16384
80002990:	c0 91       	brne	800029a2 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002992:	48 68       	lddpc	r8,800029a8 <phy_rx+0x30>
80002994:	70 0c       	ld.w	r12,r8[0x0]
80002996:	30 09       	mov	r9,0
80002998:	fa ca ff fc 	sub	r10,sp,-4
8000299c:	1a 9b       	mov	r11,sp
8000299e:	f0 1f 00 04 	mcall	800029ac <phy_rx+0x34>
		}	

    }
		
 
}
800029a2:	2f ed       	sub	sp,-8
800029a4:	d8 02       	popm	pc
800029a6:	00 00       	add	r0,r0
800029a8:	00 00       	add	r0,r0
800029aa:	0a b8       	st.h	r5++,r8
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	4f 08       	lddpc	r8,80002b6c <phy_tx_func+0x118>

800029b0 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800029b0:	eb cd 40 80 	pushm	r7,lr
800029b4:	20 1d       	sub	sp,4
800029b6:	fa c7 ff fc 	sub	r7,sp,-4
800029ba:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800029bc:	30 09       	mov	r9,0
800029be:	12 9a       	mov	r10,r9
800029c0:	1a 9b       	mov	r11,sp
800029c2:	f0 1f 00 03 	mcall	800029cc <set_idle_store+0x1c>
}
800029c6:	2f fd       	sub	sp,-4
800029c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	4f 58       	lddpc	r8,80002ba0 <phy_tx_func+0x14c>

800029d0 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
800029d0:	d4 01       	pushm	lr
800029d2:	20 1d       	sub	sp,4
800029d4:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
800029d6:	98 88       	ld.uh	r8,r12[0x0]
800029d8:	e2 18 f0 00 	andl	r8,0xf000,COH
800029dc:	e0 48 40 00 	cp.w	r8,16384
800029e0:	c0 d1       	brne	800029fa <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
800029e2:	49 08       	lddpc	r8,80002a20 <phy_tx+0x50>
800029e4:	70 08       	ld.w	r8,r8[0x0]
800029e6:	58 08       	cp.w	r8,0
800029e8:	c1 a0       	breq	80002a1c <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
800029ea:	48 e8       	lddpc	r8,80002a20 <phy_tx+0x50>
800029ec:	70 0c       	ld.w	r12,r8[0x0]
800029ee:	30 09       	mov	r9,0
800029f0:	12 9a       	mov	r10,r9
800029f2:	1a 9b       	mov	r11,sp
800029f4:	f0 1f 00 0c 	mcall	80002a24 <phy_tx+0x54>
800029f8:	c1 28       	rjmp	80002a1c <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
800029fa:	e0 48 10 00 	cp.w	r8,4096
800029fe:	5f 0a       	sreq	r10
80002a00:	e0 48 20 00 	cp.w	r8,8192
80002a04:	5f 09       	sreq	r9
80002a06:	f5 e9 10 09 	or	r9,r10,r9
80002a0a:	c0 71       	brne	80002a18 <phy_tx+0x48>
80002a0c:	e0 48 50 00 	cp.w	r8,20480
80002a10:	c0 40       	breq	80002a18 <phy_tx+0x48>
80002a12:	e0 48 60 00 	cp.w	r8,24576
80002a16:	c0 31       	brne	80002a1c <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002a18:	48 48       	lddpc	r8,80002a28 <phy_tx+0x58>
80002a1a:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002a1c:	2f fd       	sub	sp,-4
80002a1e:	d8 02       	popm	pc
80002a20:	00 00       	add	r0,r0
80002a22:	0a cc       	st.b	r5++,r12
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	4f 58       	lddpc	r8,80002bf8 <phy_tx_func+0x1a4>
80002a28:	00 00       	add	r0,r0
80002a2a:	0a b0       	st.h	r5++,r0

80002a2c <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002a2c:	d4 01       	pushm	lr
80002a2e:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002a30:	30 08       	mov	r8,0
80002a32:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a34:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002a36:	1a 9a       	mov	r10,sp
80002a38:	fa cb ff fc 	sub	r11,sp,-4
80002a3c:	f0 1f 00 05 	mcall	80002a50 <get_idle_store_isr+0x24>
80002a40:	58 1c       	cp.w	r12,1
80002a42:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002a46:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002a4a:	2f ed       	sub	sp,-8
80002a4c:	d8 02       	popm	pc
80002a4e:	00 00       	add	r0,r0
80002a50:	80 00       	ld.sh	r0,r0[0x0]
80002a52:	4c 5c       	lddpc	r12,80002b64 <phy_tx_func+0x110>

80002a54 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002a54:	eb cd 40 c0 	pushm	r6-r7,lr
80002a58:	20 1d       	sub	sp,4
80002a5a:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002a5c:	fe f8 04 0c 	ld.w	r8,pc[1036]
80002a60:	70 08       	ld.w	r8,r8[0x0]
80002a62:	58 08       	cp.w	r8,0
80002a64:	c7 40       	breq	80002b4c <phy_tx_func+0xf8>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002a66:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a68:	30 08       	mov	r8,0
80002a6a:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002a6c:	fe f8 04 00 	ld.w	r8,pc[1024]
80002a70:	70 08       	ld.w	r8,r8[0x0]
80002a72:	58 18       	cp.w	r8,1
80002a74:	c2 90       	breq	80002ac6 <phy_tx_func+0x72>
80002a76:	c0 43       	brcs	80002a7e <phy_tx_func+0x2a>
80002a78:	58 28       	cp.w	r8,2
80002a7a:	c6 91       	brne	80002b4c <phy_tx_func+0xf8>
80002a7c:	c6 18       	rjmp	80002b3e <phy_tx_func+0xea>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002a7e:	fe f8 03 ea 	ld.w	r8,pc[1002]
80002a82:	70 0c       	ld.w	r12,r8[0x0]
80002a84:	1a 9a       	mov	r10,sp
80002a86:	fe fb 03 ea 	ld.w	r11,pc[1002]
80002a8a:	f0 1f 00 fb 	mcall	80002e74 <phy_tx_func+0x420>
80002a8e:	58 1c       	cp.w	r12,1
80002a90:	c1 51       	brne	80002aba <phy_tx_func+0x66>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002a92:	fe f8 03 de 	ld.w	r8,pc[990]
80002a96:	70 08       	ld.w	r8,r8[0x0]
80002a98:	11 9a       	ld.ub	r10,r8[0x1]
80002a9a:	fe f9 03 de 	ld.w	r9,pc[990]
80002a9e:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002aa0:	90 88       	ld.uh	r8,r8[0x0]
80002aa2:	ea 18 ab cd 	orh	r8,0xabcd
80002aa6:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002aa8:	30 19       	mov	r9,1
80002aaa:	fe f8 03 d2 	ld.w	r8,pc[978]
80002aae:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002ab0:	30 19       	mov	r9,1
80002ab2:	fe f8 03 ba 	ld.w	r8,pc[954]
80002ab6:	91 09       	st.w	r8[0x0],r9
80002ab8:	c4 a8       	rjmp	80002b4c <phy_tx_func+0xf8>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002aba:	e0 68 5a 5a 	mov	r8,23130
80002abe:	ea 18 ab cd 	orh	r8,0xabcd
80002ac2:	8f 18       	st.w	r7[0x4],r8
80002ac4:	c4 48       	rjmp	80002b4c <phy_tx_func+0xf8>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ac6:	fe f9 03 b6 	ld.w	r9,pc[950]
80002aca:	13 88       	ld.ub	r8,r9[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002acc:	fe fa 03 a4 	ld.w	r10,pc[932]
80002ad0:	74 0a       	ld.w	r10,r10[0x0]
80002ad2:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002ad6:	b1 6a       	lsl	r10,0x10
80002ad8:	99 1a       	st.w	r12[0x4],r10
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002ada:	2f f8       	sub	r8,-1
80002adc:	5c 58       	castu.b	r8
80002ade:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002ae0:	fe fa 03 98 	ld.w	r10,pc[920]
80002ae4:	94 09       	ld.sh	r9,r10[0x0]
80002ae6:	20 29       	sub	r9,2
80002ae8:	b4 09       	st.h	r10[0x0],r9
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002aea:	30 0a       	mov	r10,0
80002aec:	f4 09 19 00 	cp.h	r9,r10
80002af0:	e0 89 00 0b 	brgt	80002b06 <phy_tx_func+0xb2>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002af4:	78 18       	ld.w	r8,r12[0x4]
80002af6:	e8 18 00 ba 	orl	r8,0xba
80002afa:	99 18       	st.w	r12[0x4],r8
				
				/*Go back to waiting.*/
				//vPortFree(phy_ptr);
				phy_tx_state = WAITING_FOR_PHY_TX;
80002afc:	30 09       	mov	r9,0
80002afe:	fe f8 03 6e 	ld.w	r8,pc[878]
80002b02:	91 09       	st.w	r8[0x0],r9
80002b04:	c2 48       	rjmp	80002b4c <phy_tx_func+0xf8>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002b06:	fe f9 03 6a 	ld.w	r9,pc[874]
80002b0a:	72 09       	ld.w	r9,r9[0x0]
80002b0c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b10:	78 1a       	ld.w	r10,r12[0x4]
80002b12:	f5 e9 10 09 	or	r9,r10,r9
80002b16:	99 19       	st.w	r12[0x4],r9
80002b18:	2f f8       	sub	r8,-1
80002b1a:	fe f9 03 62 	ld.w	r9,pc[866]
80002b1e:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002b20:	fe f9 03 58 	ld.w	r9,pc[856]
80002b24:	92 08       	ld.sh	r8,r9[0x0]
80002b26:	20 28       	sub	r8,2
80002b28:	b2 08       	st.h	r9[0x0],r8
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b2a:	30 09       	mov	r9,0
80002b2c:	f2 08 19 00 	cp.h	r8,r9
80002b30:	e0 89 00 0e 	brgt	80002b4c <phy_tx_func+0xf8>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002b34:	30 29       	mov	r9,2
80002b36:	fe f8 03 36 	ld.w	r8,pc[822]
80002b3a:	91 09       	st.w	r8[0x0],r9
80002b3c:	c0 88       	rjmp	80002b4c <phy_tx_func+0xf8>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002b3e:	fc 18 00 ba 	movh	r8,0xba
80002b42:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/	
			//vPortFree(phy_ptr);		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002b44:	30 09       	mov	r9,0
80002b46:	fe f8 03 26 	ld.w	r8,pc[806]
80002b4a:	91 09       	st.w	r8[0x0],r9
	{
		
		//index = (index >=30240) ? 0 : index;
		
		//Note:Test cycle sends 70 bytes of data
		index = (index >=70) ? 0 : index;
80002b4c:	fe f8 03 34 	ld.w	r8,pc[820]
80002b50:	70 08       	ld.w	r8,r8[0x0]
80002b52:	e0 48 00 46 	cp.w	r8,70
80002b56:	f9 b8 02 00 	movhs	r8,0
80002b5a:	fe f9 03 26 	ld.w	r9,pc[806]
80002b5e:	93 08       	st.w	r9[0x0],r8
		
		if((Radio_Transmit_State == 1) && (Mic_is_Enabled == 1))counter++;
80002b60:	fe f8 03 24 	ld.w	r8,pc[804]
80002b64:	11 89       	ld.ub	r9,r8[0x0]
80002b66:	30 18       	mov	r8,1
80002b68:	f0 09 18 00 	cp.b	r9,r8
80002b6c:	c0 d1       	brne	80002b86 <phy_tx_func+0x132>
80002b6e:	fe f8 03 1a 	ld.w	r8,pc[794]
80002b72:	11 89       	ld.ub	r9,r8[0x0]
80002b74:	30 18       	mov	r8,1
80002b76:	f0 09 18 00 	cp.b	r9,r8
80002b7a:	c0 61       	brne	80002b86 <phy_tx_func+0x132>
80002b7c:	fe f8 03 10 	ld.w	r8,pc[784]
80002b80:	70 09       	ld.w	r9,r8[0x0]
80002b82:	2f f9       	sub	r9,-1
80002b84:	91 09       	st.w	r8[0x0],r9
		
		switch(payload_tx_state)
80002b86:	fe f8 03 0a 	ld.w	r8,pc[778]
80002b8a:	11 88       	ld.ub	r8,r8[0x0]
80002b8c:	30 19       	mov	r9,1
80002b8e:	f2 08 18 00 	cp.b	r8,r9
80002b92:	c3 70       	breq	80002c00 <phy_tx_func+0x1ac>
80002b94:	c0 73       	brcs	80002ba2 <phy_tx_func+0x14e>
80002b96:	30 29       	mov	r9,2
80002b98:	f2 08 18 00 	cp.b	r8,r9
80002b9c:	e0 81 01 5f 	brne	80002e5a <phy_tx_func+0x406>
80002ba0:	c9 d8       	rjmp	80002cda <phy_tx_func+0x286>
		{
			case 0:
			
					payload_tx_channel->dword[0] = PAYLOADIDLE0;
80002ba2:	e0 68 5a 5a 	mov	r8,23130
80002ba6:	ea 18 ab cd 	orh	r8,0xabcd
80002baa:	8f 28       	st.w	r7[0x8],r8
					payload_tx_channel->dword[1] = PAYLOADIDLE1;
80002bac:	30 08       	mov	r8,0
80002bae:	8f 38       	st.w	r7[0xc],r8
	
					if((counter % 160== 0) && (counter != 0) &&(Radio_Transmit_State == 1))//160*125us = 20ms; 
80002bb0:	fe f8 02 dc 	ld.w	r8,pc[732]
80002bb4:	70 08       	ld.w	r8,r8[0x0]
80002bb6:	e0 6b cc cd 	mov	r11,52429
80002bba:	ea 1b cc cc 	orh	r11,0xcccc
80002bbe:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80002bc2:	f6 09 16 07 	lsr	r9,r11,0x7
80002bc6:	f2 09 00 29 	add	r9,r9,r9<<0x2
80002bca:	a5 79       	lsl	r9,0x5
80002bcc:	f0 09 01 09 	sub	r9,r8,r9
80002bd0:	c1 21       	brne	80002bf4 <phy_tx_func+0x1a0>
80002bd2:	58 08       	cp.w	r8,0
80002bd4:	c1 00       	breq	80002bf4 <phy_tx_func+0x1a0>
80002bd6:	fe f8 02 ae 	ld.w	r8,pc[686]
80002bda:	11 89       	ld.ub	r9,r8[0x0]
80002bdc:	30 18       	mov	r8,1
80002bde:	f0 09 18 00 	cp.b	r9,r8
80002be2:	c0 91       	brne	80002bf4 <phy_tx_func+0x1a0>
					{
						payload_tx_state = 1;
80002be4:	10 99       	mov	r9,r8
80002be6:	fe f8 02 aa 	ld.w	r8,pc[682]
80002bea:	b0 89       	st.b	r8[0x0],r9
	
						frame_number = 0;
80002bec:	30 09       	mov	r9,0
80002bee:	fe f8 02 a6 	ld.w	r8,pc[678]
80002bf2:	b0 89       	st.b	r8[0x0],r9
						//logFromISR("\n\r payload_tx_state: %d \n\r", payload_tx_state);
					}
					
					send_num++;
80002bf4:	fe f8 02 a4 	ld.w	r8,pc[676]
80002bf8:	70 09       	ld.w	r9,r8[0x0]
80002bfa:	2f f9       	sub	r9,-1
80002bfc:	91 09       	st.w	r8[0x0],r9
80002bfe:	c3 19       	rjmp	80002e60 <phy_tx_func+0x40c>
				break;
			
			case 1:
				
				//logFromISR("\n\r counter: %d \n\r", counter);
				payload_tx_channel->word[0] = 0xABCD; //254 bytes;
80002c00:	fe 78 ab cd 	mov	r8,-21555
80002c04:	ae 48       	st.h	r7[0x8],r8
	
				if(frame_number == 0)
80002c06:	fe f8 02 8e 	ld.w	r8,pc[654]
80002c0a:	11 88       	ld.ub	r8,r8[0x0]
80002c0c:	58 08       	cp.w	r8,0
80002c0e:	c0 e1       	brne	80002c2a <phy_tx_func+0x1d6>
				{
					//first frame
					expexted_length = 0xFE;
80002c10:	e0 69 00 fe 	mov	r9,254
80002c14:	fe f8 02 88 	ld.w	r8,pc[648]
80002c18:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x21FE;//0x11FE; //254 bytes;		mic_data?
80002c1a:	e0 68 21 fe 	mov	r8,8702
80002c1e:	ae 58       	st.h	r7[0xa],r8
					last_frame = FALSE;
80002c20:	30 09       	mov	r9,0
80002c22:	fe f8 02 7e 	ld.w	r8,pc[638]
80002c26:	b0 89       	st.b	r8[0x0],r9
80002c28:	c2 c8       	rjmp	80002c80 <phy_tx_func+0x22c>
				}
				else if(frame_number + 1 >= 2) //2frame
80002c2a:	2f f8       	sub	r8,-1
80002c2c:	58 18       	cp.w	r8,1
80002c2e:	e0 8a 00 1d 	brle	80002c68 <phy_tx_func+0x214>
						//expexted_length = 0x46;//经测试发现，要获取正确的语音的（按320bytes/20ms纯语音码流），并且每一个样本都添加了一个Stream Terminator Indicator的话，那么总长度-描述符相关的字段=320bytes
							//payload_tx_channel->word[1] = 0x1346;
						//send_num = 0;//满320bytes则重新计数
					//}
					//else{
					if (Silent_flag == 1)
80002c32:	fe f8 02 72 	ld.w	r8,pc[626]
80002c36:	11 89       	ld.ub	r9,r8[0x0]
80002c38:	30 18       	mov	r8,1
80002c3a:	f0 09 18 00 	cp.b	r9,r8
80002c3e:	c0 91       	brne	80002c50 <phy_tx_func+0x1fc>
					{
						//即是(254+70)324betes-4bytes= 320bytes
						expexted_length = 0x46;//One Descriptor Indicator
80002c40:	34 69       	mov	r9,70
80002c42:	fe f8 02 5a 	ld.w	r8,pc[602]
80002c46:	b0 09       	st.h	r8[0x0],r9
						payload_tx_channel->word[1] = 0x2346;//70bytes
80002c48:	e0 68 23 46 	mov	r8,9030
80002c4c:	ae 58       	st.h	r7[0xa],r8
80002c4e:	c0 88       	rjmp	80002c5e <phy_tx_func+0x20a>
					}
		
					else
					{
						///即是(254+68)322betes-2bytes(no Descriptor Indicator)= 320bytes
						expexted_length = 0x44;//no Descriptor Indicator
80002c50:	34 49       	mov	r9,68
80002c52:	fe f8 02 4a 	ld.w	r8,pc[586]
80002c56:	b0 09       	st.h	r8[0x0],r9
						payload_tx_channel->word[1] = 0x2344;//0x1344;//0x2344;// 0x1344; //68bytes
80002c58:	e0 68 23 44 	mov	r8,9028
80002c5c:	ae 58       	st.h	r7[0xa],r8
					}
					//}
		
					last_frame = TRUE;
80002c5e:	30 19       	mov	r9,1
80002c60:	fe f8 02 40 	ld.w	r8,pc[576]
80002c64:	b0 89       	st.b	r8[0x0],r9
80002c66:	c0 d8       	rjmp	80002c80 <phy_tx_func+0x22c>
					//logFromISR("\n\r time: %d \n\r", tc_tick);
				}
				else
				{
					//middle frame
					expexted_length = 0xFE;
80002c68:	e0 69 00 fe 	mov	r9,254
80002c6c:	fe f8 02 30 	ld.w	r8,pc[560]
80002c70:	b0 09       	st.h	r8[0x0],r9
					payload_tx_channel->word[1] = 0x22FE;//0x22FE;//0x12FE;
80002c72:	e0 68 22 fe 	mov	r8,8958
80002c76:	ae 58       	st.h	r7[0xa],r8
					last_frame = FALSE;
80002c78:	30 09       	mov	r9,0
80002c7a:	fe f8 02 26 	ld.w	r8,pc[550]
80002c7e:	b0 89       	st.b	r8[0x0],r9
				//
				//}
				//else//不执行
				{
		
					if (Silent_flag == 1)//发送静音指令
80002c80:	fe f8 02 24 	ld.w	r8,pc[548]
80002c84:	11 89       	ld.ub	r9,r8[0x0]
80002c86:	30 18       	mov	r8,1
80002c88:	f0 09 18 00 	cp.b	r9,r8
80002c8c:	c0 61       	brne	80002c98 <phy_tx_func+0x244>
					{
					
						payload_tx_channel->word[2] = 0x0001;//Array Descriptor Length
80002c8e:	30 18       	mov	r8,1
80002c90:	ae 68       	st.h	r7[0xc],r8
						payload_tx_channel->word[3] =  0x0004;//Silent Descriptor Indicator
80002c92:	30 48       	mov	r8,4
80002c94:	ae 78       	st.h	r7[0xe],r8
80002c96:	c1 38       	rjmp	80002cbc <phy_tx_func+0x268>
					
			
					}
					else
					{
						payload_tx_channel->word[2] = 0x0000;
80002c98:	30 08       	mov	r8,0
80002c9a:	ae 68       	st.h	r7[0xc],r8
						payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002c9c:	4f 98       	lddpc	r8,80002e80 <phy_tx_func+0x42c>
80002c9e:	70 09       	ld.w	r9,r8[0x0]
80002ca0:	fe fa 02 08 	ld.w	r10,pc[520]
80002ca4:	f4 09 00 0b 	add	r11,r10,r9
80002ca8:	17 9b       	ld.ub	r11,r11[0x1]
80002caa:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002cae:	a9 69       	lsl	r9,0x8
80002cb0:	f6 09 00 09 	add	r9,r11,r9
80002cb4:	ae 79       	st.h	r7[0xe],r9
						//payload_tx_channel->word[3] =  ((AudioData[index] )+ AudioData[index+1]<<8 );//高低换位
						
						index+=2;
80002cb6:	70 09       	ld.w	r9,r8[0x0]
80002cb8:	2f e9       	sub	r9,-2
80002cba:	91 09       	st.w	r8[0x0],r9
						
					}
					
					expexted_length -= 4;
80002cbc:	4f 88       	lddpc	r8,80002e9c <phy_tx_func+0x448>
80002cbe:	90 09       	ld.sh	r9,r8[0x0]
80002cc0:	20 49       	sub	r9,4
80002cc2:	b0 09       	st.h	r8[0x0],r9
				}
	
				//index+=2;
				//expexted_length -= 4;
		
				frame_number++;
80002cc4:	4f 48       	lddpc	r8,80002e94 <phy_tx_func+0x440>
80002cc6:	11 89       	ld.ub	r9,r8[0x0]
80002cc8:	2f f9       	sub	r9,-1
80002cca:	b0 89       	st.b	r8[0x0],r9
				payload_tx_state = 2;
80002ccc:	30 29       	mov	r9,2
80002cce:	4f 18       	lddpc	r8,80002e90 <phy_tx_func+0x43c>
80002cd0:	b0 89       	st.b	r8[0x0],r9
	
				i = 0;
80002cd2:	30 09       	mov	r9,0
80002cd4:	4f 68       	lddpc	r8,80002eac <phy_tx_func+0x458>
80002cd6:	91 09       	st.w	r8[0x0],r9
80002cd8:	cc 48       	rjmp	80002e60 <phy_tx_func+0x40c>
	
				break;
			
			case 2:
		
				if(expexted_length <= 0)
80002cda:	4f 18       	lddpc	r8,80002e9c <phy_tx_func+0x448>
80002cdc:	90 09       	ld.sh	r9,r8[0x0]
80002cde:	30 08       	mov	r8,0
80002ce0:	f0 09 19 00 	cp.h	r9,r8
80002ce4:	e0 89 00 12 	brgt	80002d08 <phy_tx_func+0x2b4>
				{
					//last word 0x00BA
					payload_tx_state = last_frame ? 0 : 1;
80002ce8:	4e e8       	lddpc	r8,80002ea0 <phy_tx_func+0x44c>
80002cea:	11 89       	ld.ub	r9,r8[0x0]
80002cec:	30 08       	mov	r8,0
80002cee:	f0 09 18 00 	cp.b	r9,r8
80002cf2:	5f 09       	sreq	r9
80002cf4:	4e 78       	lddpc	r8,80002e90 <phy_tx_func+0x43c>
80002cf6:	b0 89       	st.b	r8[0x0],r9
					payload_tx_channel->word[0] = 0x00BA;
80002cf8:	e0 68 00 ba 	mov	r8,186
80002cfc:	ae 48       	st.h	r7[0x8],r8
					payload_tx_channel->word[1] = 0x0000;
80002cfe:	30 08       	mov	r8,0
80002d00:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2] = 0x0000;
80002d02:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3] = 0x0000;
80002d04:	ae 78       	st.h	r7[0xe],r8
80002d06:	ca d8       	rjmp	80002e60 <phy_tx_func+0x40c>
					break;
				}
	
				if(Silent_flag == 1)
80002d08:	4e 78       	lddpc	r8,80002ea4 <phy_tx_func+0x450>
80002d0a:	11 89       	ld.ub	r9,r8[0x0]
80002d0c:	30 18       	mov	r8,1
80002d0e:	f0 09 18 00 	cp.b	r9,r8
80002d12:	c0 41       	brne	80002d1a <phy_tx_func+0x2c6>
				{
					payload_tx_channel->word[0] =  0x0000;
80002d14:	30 08       	mov	r8,0
80002d16:	ae 48       	st.h	r7[0x8],r8
80002d18:	c1 08       	rjmp	80002d38 <phy_tx_func+0x2e4>
				}
				else
				{
					//payload_tx_channel->word[0] =  ((AudioData[index] )+ AudioData[index+1]<<8 );//高低换位
					payload_tx_channel->word[0] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002d1a:	4d a8       	lddpc	r8,80002e80 <phy_tx_func+0x42c>
80002d1c:	70 09       	ld.w	r9,r8[0x0]
80002d1e:	4e 3a       	lddpc	r10,80002ea8 <phy_tx_func+0x454>
80002d20:	f4 09 00 0b 	add	r11,r10,r9
80002d24:	17 9b       	ld.ub	r11,r11[0x1]
80002d26:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002d2a:	a9 69       	lsl	r9,0x8
80002d2c:	f6 09 00 09 	add	r9,r11,r9
80002d30:	ae 49       	st.h	r7[0x8],r9
					index+=2;
80002d32:	70 09       	ld.w	r9,r8[0x0]
80002d34:	2f e9       	sub	r9,-2
80002d36:	91 09       	st.w	r8[0x0],r9
		
				}

				expexted_length -= 2;
80002d38:	4d 99       	lddpc	r9,80002e9c <phy_tx_func+0x448>
80002d3a:	92 08       	ld.sh	r8,r9[0x0]
80002d3c:	20 28       	sub	r8,2
80002d3e:	b2 08       	st.h	r9[0x0],r8
				if(expexted_length <= 0)
80002d40:	30 09       	mov	r9,0
80002d42:	f2 08 19 00 	cp.h	r8,r9
80002d46:	e0 89 00 11 	brgt	80002d68 <phy_tx_func+0x314>
				{
					//last word 0x00BA
					payload_tx_state = last_frame ? 0 : 1;
80002d4a:	4d 68       	lddpc	r8,80002ea0 <phy_tx_func+0x44c>
80002d4c:	11 89       	ld.ub	r9,r8[0x0]
80002d4e:	30 08       	mov	r8,0
80002d50:	f0 09 18 00 	cp.b	r9,r8
80002d54:	5f 09       	sreq	r9
80002d56:	4c f8       	lddpc	r8,80002e90 <phy_tx_func+0x43c>
80002d58:	b0 89       	st.b	r8[0x0],r9
					payload_tx_channel->word[1] = 0x00BA;
80002d5a:	e0 68 00 ba 	mov	r8,186
80002d5e:	ae 58       	st.h	r7[0xa],r8
					payload_tx_channel->word[2] = 0x0000;
80002d60:	30 08       	mov	r8,0
80002d62:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3] = 0x0000;
80002d64:	ae 78       	st.h	r7[0xe],r8
80002d66:	c7 d8       	rjmp	80002e60 <phy_tx_func+0x40c>
					break;
				}
	
				if(Silent_flag == 1)
80002d68:	4c f8       	lddpc	r8,80002ea4 <phy_tx_func+0x450>
80002d6a:	11 89       	ld.ub	r9,r8[0x0]
80002d6c:	30 18       	mov	r8,1
80002d6e:	f0 09 18 00 	cp.b	r9,r8
80002d72:	c0 41       	brne	80002d7a <phy_tx_func+0x326>
				{
					payload_tx_channel->word[1] =  0x0000;
80002d74:	30 08       	mov	r8,0
80002d76:	ae 58       	st.h	r7[0xa],r8
80002d78:	c1 08       	rjmp	80002d98 <phy_tx_func+0x344>
				}	
				else
				{
					//payload_tx_channel->word[1] =  ((AudioData[index] )+ AudioData[index+1]<<8 );//高低换位
					payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002d7a:	4c 28       	lddpc	r8,80002e80 <phy_tx_func+0x42c>
80002d7c:	70 09       	ld.w	r9,r8[0x0]
80002d7e:	4c ba       	lddpc	r10,80002ea8 <phy_tx_func+0x454>
80002d80:	f4 09 00 0b 	add	r11,r10,r9
80002d84:	17 9b       	ld.ub	r11,r11[0x1]
80002d86:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002d8a:	a9 69       	lsl	r9,0x8
80002d8c:	f6 09 00 09 	add	r9,r11,r9
80002d90:	ae 59       	st.h	r7[0xa],r9
					index+=2;
80002d92:	70 09       	ld.w	r9,r8[0x0]
80002d94:	2f e9       	sub	r9,-2
80002d96:	91 09       	st.w	r8[0x0],r9
				}
				//payload_tx_channel->word[1] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
	
				expexted_length -= 2;
80002d98:	4c 19       	lddpc	r9,80002e9c <phy_tx_func+0x448>
80002d9a:	92 08       	ld.sh	r8,r9[0x0]
80002d9c:	20 28       	sub	r8,2
80002d9e:	b2 08       	st.h	r9[0x0],r8
				if(expexted_length <= 0)
80002da0:	30 09       	mov	r9,0
80002da2:	f2 08 19 00 	cp.h	r8,r9
80002da6:	e0 89 00 10 	brgt	80002dc6 <phy_tx_func+0x372>
				{
					//last word 0x00BA
					payload_tx_state = last_frame ? 0 : 1;
80002daa:	4b e8       	lddpc	r8,80002ea0 <phy_tx_func+0x44c>
80002dac:	11 89       	ld.ub	r9,r8[0x0]
80002dae:	30 08       	mov	r8,0
80002db0:	f0 09 18 00 	cp.b	r9,r8
80002db4:	5f 09       	sreq	r9
80002db6:	4b 78       	lddpc	r8,80002e90 <phy_tx_func+0x43c>
80002db8:	b0 89       	st.b	r8[0x0],r9
					payload_tx_channel->word[2] = 0x00BA;
80002dba:	e0 68 00 ba 	mov	r8,186
80002dbe:	ae 68       	st.h	r7[0xc],r8
					payload_tx_channel->word[3] = 0x0000;
80002dc0:	30 08       	mov	r8,0
80002dc2:	ae 78       	st.h	r7[0xe],r8
80002dc4:	c4 e8       	rjmp	80002e60 <phy_tx_func+0x40c>
					break;
				}
	
				if(Silent_flag == 1)
80002dc6:	4b 88       	lddpc	r8,80002ea4 <phy_tx_func+0x450>
80002dc8:	11 89       	ld.ub	r9,r8[0x0]
80002dca:	30 18       	mov	r8,1
80002dcc:	f0 09 18 00 	cp.b	r9,r8
80002dd0:	c0 41       	brne	80002dd8 <phy_tx_func+0x384>
				{
					payload_tx_channel->word[2] =  0x0000;
80002dd2:	30 08       	mov	r8,0
80002dd4:	ae 68       	st.h	r7[0xc],r8
80002dd6:	c1 08       	rjmp	80002df6 <phy_tx_func+0x3a2>
				}
				else
				{
					//payload_tx_channel->word[2] =  ((AudioData[index] )+ AudioData[index+1]<<8 );//高低换位
					payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002dd8:	4a a8       	lddpc	r8,80002e80 <phy_tx_func+0x42c>
80002dda:	70 09       	ld.w	r9,r8[0x0]
80002ddc:	4b 3a       	lddpc	r10,80002ea8 <phy_tx_func+0x454>
80002dde:	f4 09 00 0b 	add	r11,r10,r9
80002de2:	17 9b       	ld.ub	r11,r11[0x1]
80002de4:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002de8:	a9 69       	lsl	r9,0x8
80002dea:	f6 09 00 09 	add	r9,r11,r9
80002dee:	ae 69       	st.h	r7[0xc],r9
					//此处加密测试
					//payload_tx_channel->word[2] =  (((AudioData[index]<<8 )+ AudioData[index+1] ) ^ Public_PCMkey);
					index+=2;
80002df0:	70 09       	ld.w	r9,r8[0x0]
80002df2:	2f e9       	sub	r9,-2
80002df4:	91 09       	st.w	r8[0x0],r9
				}
				//payload_tx_channel->word[2] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
	
				expexted_length -= 2;
80002df6:	4a a9       	lddpc	r9,80002e9c <phy_tx_func+0x448>
80002df8:	92 08       	ld.sh	r8,r9[0x0]
80002dfa:	20 28       	sub	r8,2
80002dfc:	b2 08       	st.h	r9[0x0],r8
				if(expexted_length <= 0)
80002dfe:	30 09       	mov	r9,0
80002e00:	f2 08 19 00 	cp.h	r8,r9
80002e04:	e0 89 00 0e 	brgt	80002e20 <phy_tx_func+0x3cc>
				{
					//last word 0x00BA
					payload_tx_state = last_frame ? 0 : 1;
80002e08:	4a 68       	lddpc	r8,80002ea0 <phy_tx_func+0x44c>
80002e0a:	11 89       	ld.ub	r9,r8[0x0]
80002e0c:	30 08       	mov	r8,0
80002e0e:	f0 09 18 00 	cp.b	r9,r8
80002e12:	5f 09       	sreq	r9
80002e14:	49 f8       	lddpc	r8,80002e90 <phy_tx_func+0x43c>
80002e16:	b0 89       	st.b	r8[0x0],r9
					payload_tx_channel->word[3] = 0x00BA;
80002e18:	e0 68 00 ba 	mov	r8,186
80002e1c:	ae 78       	st.h	r7[0xe],r8
80002e1e:	c2 18       	rjmp	80002e60 <phy_tx_func+0x40c>
					break;
				}
	
				if(Silent_flag == 1)
80002e20:	4a 18       	lddpc	r8,80002ea4 <phy_tx_func+0x450>
80002e22:	11 89       	ld.ub	r9,r8[0x0]
80002e24:	30 18       	mov	r8,1
80002e26:	f0 09 18 00 	cp.b	r9,r8
80002e2a:	c0 41       	brne	80002e32 <phy_tx_func+0x3de>
				{
					payload_tx_channel->word[3] =  0x0000;
80002e2c:	30 08       	mov	r8,0
80002e2e:	ae 78       	st.h	r7[0xe],r8
80002e30:	c1 08       	rjmp	80002e50 <phy_tx_func+0x3fc>
				}
				else
				{
					//payload_tx_channel->word[3] =  ((AudioData[index] )+ AudioData[index+1]<<8 );//高低换位
					payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
80002e32:	49 48       	lddpc	r8,80002e80 <phy_tx_func+0x42c>
80002e34:	70 09       	ld.w	r9,r8[0x0]
80002e36:	49 da       	lddpc	r10,80002ea8 <phy_tx_func+0x454>
80002e38:	f4 09 00 0b 	add	r11,r10,r9
80002e3c:	17 9b       	ld.ub	r11,r11[0x1]
80002e3e:	f4 09 07 09 	ld.ub	r9,r10[r9]
80002e42:	a9 69       	lsl	r9,0x8
80002e44:	f6 09 00 09 	add	r9,r11,r9
80002e48:	ae 79       	st.h	r7[0xe],r9
					index+=2;
80002e4a:	70 09       	ld.w	r9,r8[0x0]
80002e4c:	2f e9       	sub	r9,-2
80002e4e:	91 09       	st.w	r8[0x0],r9
				}
	
				//payload_tx_channel->word[3] =  ((AudioData[index]<<8 )+ AudioData[index+1] );
	
				expexted_length -= 2;
80002e50:	49 38       	lddpc	r8,80002e9c <phy_tx_func+0x448>
80002e52:	90 09       	ld.sh	r9,r8[0x0]
80002e54:	20 29       	sub	r9,2
80002e56:	b0 09       	st.h	r8[0x0],r9
80002e58:	c0 48       	rjmp	80002e60 <phy_tx_func+0x40c>
		
				break;
		
			default:
				payload_tx_state = 0;
80002e5a:	30 09       	mov	r9,0
80002e5c:	48 d8       	lddpc	r8,80002e90 <phy_tx_func+0x43c>
80002e5e:	b0 89       	st.b	r8[0x0],r9
	#else
	/*send idle frame*/	
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	#endif /*end if*/
}
80002e60:	2f fd       	sub	sp,-4
80002e62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002e66:	00 00       	add	r0,r0
80002e68:	00 00       	add	r0,r0
80002e6a:	0a cc       	st.b	r5++,r12
80002e6c:	00 00       	add	r0,r0
80002e6e:	0a a4       	st.w	r5++,r4
80002e70:	00 00       	add	r0,r0
80002e72:	0a 8c       	andn	r12,r5
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	4c 5c       	lddpc	r12,80002f88 <phy_init+0xb0>
80002e78:	00 00       	add	r0,r0
80002e7a:	0a a2       	st.w	r5++,r2
80002e7c:	00 00       	add	r0,r0
80002e7e:	0a 94       	mov	r4,r5
80002e80:	00 00       	add	r0,r0
80002e82:	0a 74       	tst	r4,r5
80002e84:	00 00       	add	r0,r0
80002e86:	0a 43       	or	r3,r5
80002e88:	00 00       	add	r0,r0
80002e8a:	0a 55       	eor	r5,r5
80002e8c:	00 00       	add	r0,r0
80002e8e:	0a 84       	andn	r4,r5
80002e90:	00 00       	add	r0,r0
80002e92:	0a c9       	st.b	r5++,r9
80002e94:	00 00       	add	r0,r0
80002e96:	0a bc       	st.h	r5++,r12
80002e98:	00 00       	add	r0,r0
80002e9a:	0a d8       	st.w	--r5,r8
80002e9c:	00 00       	add	r0,r0
80002e9e:	0a d2       	st.w	--r5,r2
80002ea0:	00 00       	add	r0,r0
80002ea2:	0a d1       	st.w	--r5,r1
80002ea4:	00 00       	add	r0,r0
80002ea6:	0a 5c       	eor	r12,r5
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	c3 80       	breq	80002f1a <phy_init+0x42>
80002eac:	00 00       	add	r0,r0
80002eae:	0a c4       	st.b	r5++,r4

80002eb0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002eb0:	d4 01       	pushm	lr
80002eb2:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002eb4:	30 0a       	mov	r10,0
80002eb6:	fa cb ff fc 	sub	r11,sp,-4
80002eba:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002ebc:	14 99       	mov	r9,r10
80002ebe:	1a 9b       	mov	r11,sp
80002ec0:	f0 1f 00 05 	mcall	80002ed4 <get_idle_store+0x24>
80002ec4:	58 1c       	cp.w	r12,1
80002ec6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002eca:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002ece:	2f fd       	sub	sp,-4
80002ed0:	d8 02       	popm	pc
80002ed2:	00 00       	add	r0,r0
80002ed4:	80 00       	ld.sh	r0,r0[0x0]
80002ed6:	4d 4c       	lddpc	r12,80003024 <phy_rx_func+0x30>

80002ed8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002ed8:	eb cd 40 e0 	pushm	r5-r7,lr
    /*initialize the SSC*/
    ssc_init();
80002edc:	f0 1f 00 21 	mcall	80002f60 <phy_init+0x88>

    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002ee0:	4a 1b       	lddpc	r11,80002f64 <phy_init+0x8c>
80002ee2:	4a 2c       	lddpc	r12,80002f68 <phy_init+0x90>
80002ee4:	f0 1f 00 22 	mcall	80002f6c <phy_init+0x94>
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80002ee8:	30 4b       	mov	r11,4
80002eea:	31 ec       	mov	r12,30
80002eec:	f0 1f 00 21 	mcall	80002f70 <phy_init+0x98>
80002ef0:	4a 18       	lddpc	r8,80002f74 <phy_init+0x9c>
80002ef2:	91 0c       	st.w	r8[0x0],r12
80002ef4:	30 07       	mov	r7,0
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80002ef6:	10 96       	mov	r6,r8
80002ef8:	4a 05       	lddpc	r5,80002f78 <phy_init+0xa0>
80002efa:	6c 0c       	ld.w	r12,r6[0x0]
80002efc:	ea 07 00 0b 	add	r11,r5,r7
80002f00:	f0 1f 00 1f 	mcall	80002f7c <phy_init+0xa4>
80002f04:	ee c7 ff 00 	sub	r7,r7,-256
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
	
	/*if enable send/receive payload(media), defined in physical.h*/	
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	phy_fragment_t * xnl_ptr = NULL;
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80002f08:	e0 47 1e 00 	cp.w	r7,7680
80002f0c:	cf 71       	brne	80002efa <phy_init+0x22>
	{
		set_xnl_idle(&xnl_store[i]);
	}
		
    /*initialize the queue to send/receive xnl packet */	
    phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f0e:	30 4b       	mov	r11,4
80002f10:	31 4c       	mov	r12,20
80002f12:	f0 1f 00 18 	mcall	80002f70 <phy_init+0x98>
80002f16:	49 b8       	lddpc	r8,80002f80 <phy_init+0xa8>
80002f18:	91 0c       	st.w	r8[0x0],r12
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80002f1a:	30 4b       	mov	r11,4
80002f1c:	30 ac       	mov	r12,10
80002f1e:	f0 1f 00 15 	mcall	80002f70 <phy_init+0x98>
80002f22:	49 98       	lddpc	r8,80002f84 <phy_init+0xac>
80002f24:	91 0c       	st.w	r8[0x0],r12
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80002f26:	30 4b       	mov	r11,4
80002f28:	30 ac       	mov	r12,10
80002f2a:	f0 1f 00 12 	mcall	80002f70 <phy_init+0x98>
80002f2e:	49 78       	lddpc	r8,80002f88 <phy_init+0xb0>
80002f30:	91 0c       	st.w	r8[0x0],r12
80002f32:	30 07       	mov	r7,0
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
80002f34:	10 96       	mov	r6,r8
80002f36:	49 65       	lddpc	r5,80002f8c <phy_init+0xb4>
80002f38:	6c 0c       	ld.w	r12,r6[0x0]
80002f3a:	ea 07 00 0b 	add	r11,r5,r7
80002f3e:	f0 1f 00 10 	mcall	80002f7c <phy_init+0xa4>
80002f42:	ee c7 fe 00 	sub	r7,r7,-512
    phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
	
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	U8 * payload_ptr = NULL;
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80002f46:	e0 47 14 00 	cp.w	r7,5120
80002f4a:	cf 71       	brne	80002f38 <phy_init+0x60>
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
	xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
80002f4c:	e0 6b 01 00 	mov	r11,256
80002f50:	30 5c       	mov	r12,5
80002f52:	f0 1f 00 08 	mcall	80002f70 <phy_init+0x98>
	{
		set_payload_idle(payload_store[i]);
	}
		
	/*initialize the queue to send/receive xnl packet */
	phy_payload_frame_tx =
80002f56:	48 f8       	lddpc	r8,80002f90 <phy_init+0xb8>
80002f58:	91 0c       	st.w	r8[0x0],r12
		
	//phy_payload_frame_rx =
	//xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
	#endif /*end if*/
	
}
80002f5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f5e:	00 00       	add	r0,r0
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	37 78       	mov	r8,119
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	2a 54       	sub	r4,-91
80002f68:	80 00       	ld.sh	r0,r0[0x0]
80002f6a:	2f f4       	sub	r4,-1
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	37 64       	mov	r4,118
80002f70:	80 00       	ld.sh	r0,r0[0x0]
80002f72:	50 b0       	stdsp	sp[0x2c],r0
80002f74:	00 00       	add	r0,r0
80002f76:	0a 9c       	mov	r12,r5
80002f78:	00 00       	add	r0,r0
80002f7a:	21 ac       	sub	r12,26
80002f7c:	80 00       	ld.sh	r0,r0[0x0]
80002f7e:	29 b0       	sub	r0,-101
80002f80:	00 00       	add	r0,r0
80002f82:	0a cc       	st.b	r5++,r12
80002f84:	00 00       	add	r0,r0
80002f86:	0a b8       	st.h	r5++,r8
80002f88:	00 00       	add	r0,r0
80002f8a:	0a 80       	andn	r0,r5
80002f8c:	00 00       	add	r0,r0
80002f8e:	0d ac       	ld.ub	r12,r6[0x2]
80002f90:	00 00       	add	r0,r0
80002f92:	0a b0       	st.h	r5++,r0

80002f94 <payload_rx>:




static void payload_rx(void * payload)
{
80002f94:	d4 01       	pushm	lr
80002f96:	20 2d       	sub	sp,8
80002f98:	50 0c       	stdsp	sp[0x0],r12
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002f9a:	30 08       	mov	r8,0
80002f9c:	50 18       	stdsp	sp[0x4],r8
	
	//set_payload_idle(payload);
	if(NULL == phy_payload_frame_rx)
80002f9e:	48 f8       	lddpc	r8,80002fd8 <payload_rx+0x44>
80002fa0:	70 08       	ld.w	r8,r8[0x0]
80002fa2:	58 08       	cp.w	r8,0
80002fa4:	c0 71       	brne	80002fb2 <payload_rx+0x1e>
	{
		phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));		
80002fa6:	30 4b       	mov	r11,4
80002fa8:	30 5c       	mov	r12,5
80002faa:	f0 1f 00 0d 	mcall	80002fdc <payload_rx+0x48>
80002fae:	48 b8       	lddpc	r8,80002fd8 <payload_rx+0x44>
80002fb0:	91 0c       	st.w	r8[0x0],r12
	}

	if(errQUEUE_FULL == xQueueSendFromISR(phy_payload_frame_rx, &payload, &xHigherPriorityTaskWoken))
80002fb2:	48 a8       	lddpc	r8,80002fd8 <payload_rx+0x44>
80002fb4:	70 0c       	ld.w	r12,r8[0x0]
80002fb6:	30 09       	mov	r9,0
80002fb8:	fa ca ff fc 	sub	r10,sp,-4
80002fbc:	1a 9b       	mov	r11,sp
80002fbe:	f0 1f 00 09 	mcall	80002fe0 <payload_rx+0x4c>
80002fc2:	c0 91       	brne	80002fd4 <payload_rx+0x40>
	//if(errQUEUE_FULL == xQueueSend(phy_payload_frame_rx, &payload, 0))
	{	//To payload_rx_process();	
		
		set_payload_idle_isr(payload);
80002fc4:	48 88       	lddpc	r8,80002fe4 <payload_rx+0x50>
80002fc6:	70 0c       	ld.w	r12,r8[0x0]
80002fc8:	40 0b       	lddsp	r11,sp[0x0]
80002fca:	f0 1f 00 08 	mcall	80002fe8 <payload_rx+0x54>
		logFromISR("mm");
80002fce:	48 8c       	lddpc	r12,80002fec <payload_rx+0x58>
80002fd0:	f0 1f 00 08 	mcall	80002ff0 <payload_rx+0x5c>
			
		}
		//set_payload_idle_isr(payload);
		//logFromISR("ss");
	}
}
80002fd4:	2f ed       	sub	sp,-8
80002fd6:	d8 02       	popm	pc
80002fd8:	00 00       	add	r0,r0
80002fda:	0a c0       	st.b	r5++,r0
80002fdc:	80 00       	ld.sh	r0,r0[0x0]
80002fde:	50 b0       	stdsp	sp[0x2c],r0
80002fe0:	80 00       	ld.sh	r0,r0[0x0]
80002fe2:	4f 08       	lddpc	r8,800031a0 <phy_rx_func+0x1ac>
80002fe4:	00 00       	add	r0,r0
80002fe6:	0a 80       	andn	r0,r5
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	29 5c       	sub	r12,-107
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	c4 20       	breq	80003072 <phy_rx_func+0x7e>
80002ff0:	80 00       	ld.sh	r0,r0[0x0]
80002ff2:	5c d4       	com	r4

80002ff4 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002ff4:	eb cd 40 e0 	pushm	r5-r7,lr
80002ff8:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002ffa:	fe f8 05 c6 	ld.w	r8,pc[1478]
80002ffe:	70 08       	ld.w	r8,r8[0x0]
80003000:	58 08       	cp.w	r8,0
80003002:	e0 80 01 05 	breq	8000320c <phy_rx_func+0x218>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003006:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003008:	fe f8 05 bc 	ld.w	r8,pc[1468]
8000300c:	70 09       	ld.w	r9,r8[0x0]
8000300e:	2f f9       	sub	r9,-1
80003010:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003012:	fe f8 05 b6 	ld.w	r8,pc[1462]
80003016:	70 08       	ld.w	r8,r8[0x0]
80003018:	58 18       	cp.w	r8,1
8000301a:	e0 80 00 84 	breq	80003122 <phy_rx_func+0x12e>
8000301e:	c0 73       	brcs	8000302c <phy_rx_func+0x38>
80003020:	58 28       	cp.w	r8,2
80003022:	c5 b0       	breq	800030d8 <phy_rx_func+0xe4>
80003024:	58 38       	cp.w	r8,3
80003026:	e0 81 00 f3 	brne	8000320c <phy_rx_func+0x218>
8000302a:	cd 38       	rjmp	800031d0 <phy_rx_func+0x1dc>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000302c:	e0 6a 5a 5a 	mov	r10,23130
80003030:	ea 1a ab cd 	orh	r10,0xabcd
80003034:	14 36       	cp.w	r6,r10
80003036:	e0 80 00 eb 	breq	8000320c <phy_rx_func+0x218>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000303a:	ec 08 16 10 	lsr	r8,r6,0x10
8000303e:	e0 48 ab cd 	cp.w	r8,43981
80003042:	e0 81 00 e5 	brne	8000320c <phy_rx_func+0x218>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003046:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000304a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000304e:	20 28       	sub	r8,2
80003050:	fe f9 05 7c 	ld.w	r9,pc[1404]
80003054:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003056:	30 09       	mov	r9,0
80003058:	f2 08 19 00 	cp.h	r8,r9
8000305c:	e0 8a 00 d8 	brle	8000320c <phy_rx_func+0x218>
			{
				break;
			}
		
			phy_rx_length = 0;
80003060:	fe f8 05 70 	ld.w	r8,pc[1392]
80003064:	b0 09       	st.h	r8[0x0],r9
			
			//get_xnl_idle_isr(&phy_frame_ptr, &xHigherPriorityTaskWoken);
			phy_frame_ptr = get_xnl_idle_isr();
80003066:	fe f8 05 6e 	ld.w	r8,pc[1390]
8000306a:	70 0c       	ld.w	r12,r8[0x0]
8000306c:	f0 1f 01 5b 	mcall	800035d8 <phy_rx_func+0x5e4>
80003070:	fe f8 05 6c 	ld.w	r8,pc[1388]
80003074:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003076:	58 0c       	cp.w	r12,0
80003078:	e0 80 00 ca 	breq	8000320c <phy_rx_func+0x218>
			//
			//xQueueReceiveFromISR(phy_store_idle, &phy_frame_ptr, &xHigherPriorityTaskWoken);
			
			//phy_frame_ptr = pvPortMalloc(sizeof(phy_fragment_t));
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000307c:	fe f8 05 54 	ld.w	r8,pc[1364]
80003080:	90 09       	ld.sh	r9,r8[0x0]
80003082:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80003086:	2f f9       	sub	r9,-1
80003088:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
8000308a:	fe fa 05 52 	ld.w	r10,pc[1362]
8000308e:	74 0a       	ld.w	r10,r10[0x0]
80003090:	fe fb 05 34 	ld.w	r11,pc[1332]
80003094:	76 0b       	ld.w	r11,r11[0x0]
80003096:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
8000309a:	2f f9       	sub	r9,-1
8000309c:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
8000309e:	e2 16 0f 00 	andl	r6,0xf00,COH
800030a2:	e0 46 01 00 	cp.w	r6,256
800030a6:	c0 c0       	breq	800030be <phy_rx_func+0xca>
800030a8:	e0 8b 00 05 	brhi	800030b2 <phy_rx_func+0xbe>
800030ac:	58 06       	cp.w	r6,0
800030ae:	c0 80       	breq	800030be <phy_rx_func+0xca>
800030b0:	c0 c8       	rjmp	800030c8 <phy_rx_func+0xd4>
800030b2:	e0 46 02 00 	cp.w	r6,512
800030b6:	c0 40       	breq	800030be <phy_rx_func+0xca>
800030b8:	e0 46 03 00 	cp.w	r6,768
800030bc:	c0 61       	brne	800030c8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800030be:	30 29       	mov	r9,2
800030c0:	fe f8 05 08 	ld.w	r8,pc[1288]
800030c4:	91 09       	st.w	r8[0x0],r9
800030c6:	ca 38       	rjmp	8000320c <phy_rx_func+0x218>
				break;
				default:
					vPortFree(phy_frame_ptr);
800030c8:	fe f6 05 14 	ld.w	r6,pc[1300]
800030cc:	6c 0c       	ld.w	r12,r6[0x0]
800030ce:	f0 1f 01 45 	mcall	800035e0 <phy_rx_func+0x5ec>
					phy_frame_ptr = NULL;					
800030d2:	30 08       	mov	r8,0
800030d4:	8d 08       	st.w	r6[0x0],r8
800030d6:	c9 b8       	rjmp	8000320c <phy_rx_func+0x218>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800030d8:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800030dc:	b1 86       	lsr	r6,0x10
800030de:	14 06       	add	r6,r10
800030e0:	fe f8 05 04 	ld.w	r8,pc[1284]
800030e4:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800030e6:	fe f8 04 ea 	ld.w	r8,pc[1258]
800030ea:	90 09       	ld.sh	r9,r8[0x0]
800030ec:	fe fb 04 f0 	ld.w	r11,pc[1264]
800030f0:	76 0b       	ld.w	r11,r11[0x0]
800030f2:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
800030f6:	2f f9       	sub	r9,-1
800030f8:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
800030fa:	fe f9 04 d2 	ld.w	r9,pc[1234]
800030fe:	92 08       	ld.sh	r8,r9[0x0]
80003100:	20 28       	sub	r8,2
80003102:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003104:	30 09       	mov	r9,0
80003106:	f2 08 19 00 	cp.h	r8,r9
8000310a:	e0 8a 00 07 	brle	80003118 <phy_rx_func+0x124>
			{					  
				phy_rx_state = READING_FRAGMENT;
8000310e:	30 19       	mov	r9,1
80003110:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003114:	91 09       	st.w	r8[0x0],r9
80003116:	c7 b8       	rjmp	8000320c <phy_rx_func+0x218>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80003118:	30 39       	mov	r9,3
8000311a:	fe f8 04 ae 	ld.w	r8,pc[1198]
8000311e:	91 09       	st.w	r8[0x0],r9
80003120:	c7 68       	rjmp	8000320c <phy_rx_func+0x218>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003122:	ec 0a 14 10 	asr	r10,r6,0x10
80003126:	fe f8 04 be 	ld.w	r8,pc[1214]
8000312a:	90 09       	ld.sh	r9,r8[0x0]
8000312c:	14 09       	add	r9,r10
8000312e:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003130:	fe f9 04 a0 	ld.w	r9,pc[1184]
80003134:	92 08       	ld.sh	r8,r9[0x0]
80003136:	fe fb 04 a6 	ld.w	r11,pc[1190]
8000313a:	76 0b       	ld.w	r11,r11[0x0]
8000313c:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003140:	2f f8       	sub	r8,-1
80003142:	5c 88       	casts.h	r8
80003144:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003146:	fe fa 04 86 	ld.w	r10,pc[1158]
8000314a:	94 09       	ld.sh	r9,r10[0x0]
8000314c:	20 29       	sub	r9,2
8000314e:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003150:	30 0a       	mov	r10,0
80003152:	f4 09 19 00 	cp.h	r9,r10
80003156:	e0 89 00 1f 	brgt	80003194 <phy_rx_func+0x1a0>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000315a:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000315e:	e0 46 00 ba 	cp.w	r6,186
80003162:	c0 d1       	brne	8000317c <phy_rx_func+0x188>
80003164:	fe f8 04 80 	ld.w	r8,pc[1152]
80003168:	90 09       	ld.sh	r9,r8[0x0]
8000316a:	f4 09 19 00 	cp.h	r9,r10
8000316e:	c0 71       	brne	8000317c <phy_rx_func+0x188>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003170:	fe f8 04 6c 	ld.w	r8,pc[1132]
80003174:	70 0c       	ld.w	r12,r8[0x0]
80003176:	f0 1f 01 1d 	mcall	800035e8 <phy_rx_func+0x5f4>
8000317a:	c0 88       	rjmp	8000318a <phy_rx_func+0x196>
				}
				else
				{
					vPortFree(phy_frame_ptr);
8000317c:	fe f6 04 60 	ld.w	r6,pc[1120]
80003180:	6c 0c       	ld.w	r12,r6[0x0]
80003182:	f0 1f 01 18 	mcall	800035e0 <phy_rx_func+0x5ec>
					phy_frame_ptr = NULL;
80003186:	30 08       	mov	r8,0
80003188:	8d 08       	st.w	r6[0x0],r8
				}

				phy_rx_state = WAITING_FOR_HEADER;
8000318a:	30 09       	mov	r9,0
8000318c:	fe f8 04 3c 	ld.w	r8,pc[1084]
80003190:	91 09       	st.w	r8[0x0],r9
80003192:	c3 d8       	rjmp	8000320c <phy_rx_func+0x218>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80003194:	5c 86       	casts.h	r6
80003196:	fe f9 04 4e 	ld.w	r9,pc[1102]
8000319a:	92 0a       	ld.sh	r10,r9[0x0]
8000319c:	0c 0a       	add	r10,r6
8000319e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800031a0:	fe f9 04 3c 	ld.w	r9,pc[1084]
800031a4:	72 09       	ld.w	r9,r9[0x0]
800031a6:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800031aa:	2f f8       	sub	r8,-1
800031ac:	fe f9 04 24 	ld.w	r9,pc[1060]
800031b0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800031b2:	fe f9 04 1a 	ld.w	r9,pc[1050]
800031b6:	92 08       	ld.sh	r8,r9[0x0]
800031b8:	20 28       	sub	r8,2
800031ba:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800031bc:	30 09       	mov	r9,0
800031be:	f2 08 19 00 	cp.h	r8,r9
800031c2:	e0 89 00 25 	brgt	8000320c <phy_rx_func+0x218>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800031c6:	30 39       	mov	r9,3
800031c8:	fe f8 04 00 	ld.w	r8,pc[1024]
800031cc:	91 09       	st.w	r8[0x0],r9
800031ce:	c1 f8       	rjmp	8000320c <phy_rx_func+0x218>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800031d0:	e6 16 00 ff 	andh	r6,0xff,COH
800031d4:	fc 19 00 ba 	movh	r9,0xba
800031d8:	12 36       	cp.w	r6,r9
800031da:	c0 e1       	brne	800031f6 <phy_rx_func+0x202>
800031dc:	fe f8 04 08 	ld.w	r8,pc[1032]
800031e0:	90 09       	ld.sh	r9,r8[0x0]
800031e2:	30 08       	mov	r8,0
800031e4:	f0 09 19 00 	cp.h	r9,r8
800031e8:	c0 71       	brne	800031f6 <phy_rx_func+0x202>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
800031ea:	fe f8 03 f2 	ld.w	r8,pc[1010]
800031ee:	70 0c       	ld.w	r12,r8[0x0]
800031f0:	f0 1f 00 fe 	mcall	800035e8 <phy_rx_func+0x5f4>
800031f4:	c0 88       	rjmp	80003204 <phy_rx_func+0x210>

			}
			else
			{
				vPortFree(phy_frame_ptr);
800031f6:	fe f6 03 e6 	ld.w	r6,pc[998]
800031fa:	6c 0c       	ld.w	r12,r6[0x0]
800031fc:	f0 1f 00 f9 	mcall	800035e0 <phy_rx_func+0x5ec>
				phy_frame_ptr = NULL;
80003200:	30 08       	mov	r8,0
80003202:	8d 08       	st.w	r6[0x0],r8
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80003204:	30 09       	mov	r9,0
80003206:	fe f8 03 c2 	ld.w	r8,pc[962]
8000320a:	91 09       	st.w	r8[0x0],r9
			
	//payload_ptr_t *AMBE_payload_ptr;		
				
	
	
	if(is_first == FALSE)
8000320c:	fe f8 03 e0 	ld.w	r8,pc[992]
80003210:	11 89       	ld.ub	r9,r8[0x0]
80003212:	30 08       	mov	r8,0
80003214:	f0 09 18 00 	cp.b	r9,r8
80003218:	c0 d1       	brne	80003232 <phy_rx_func+0x23e>
	{
		payload_ptr = get_payload_idle_isr();
8000321a:	fe f8 03 d6 	ld.w	r8,pc[982]
8000321e:	70 0c       	ld.w	r12,r8[0x0]
80003220:	f0 1f 00 ee 	mcall	800035d8 <phy_rx_func+0x5e4>
80003224:	fe f8 03 d0 	ld.w	r8,pc[976]
80003228:	91 0c       	st.w	r8[0x0],r12
		//AMBE_payload_ptr = get_payload_idle_isr();
		is_first = TRUE;
8000322a:	30 19       	mov	r9,1
8000322c:	fe f8 03 c0 	ld.w	r8,pc[960]
80003230:	b0 89       	st.b	r8[0x0],r9
	}	
	
	PCM_frame_Payload[0] = payload_rx_channel->word[0];
80003232:	8e 49       	ld.sh	r9,r7[0x8]
80003234:	fe f8 03 c4 	ld.w	r8,pc[964]
80003238:	b0 09       	st.h	r8[0x0],r9
	PCM_frame_Payload[1] = payload_rx_channel->word[1];
8000323a:	8e 59       	ld.sh	r9,r7[0xa]
8000323c:	b0 19       	st.h	r8[0x2],r9
	PCM_frame_Payload[2] = payload_rx_channel->word[2];
8000323e:	8e 69       	ld.sh	r9,r7[0xc]
80003240:	b0 29       	st.h	r8[0x4],r9
	PCM_frame_Payload[3] = payload_rx_channel->word[3];
80003242:	8e 79       	ld.sh	r9,r7[0xe]
80003244:	b0 39       	st.h	r8[0x6],r9
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003246:	fe f8 03 b6 	ld.w	r8,pc[950]
8000324a:	70 08       	ld.w	r8,r8[0x0]
8000324c:	58 08       	cp.w	r8,0
8000324e:	c0 50       	breq	80003258 <phy_rx_func+0x264>
80003250:	58 28       	cp.w	r8,2
80003252:	e0 81 01 b4 	brne	800035ba <phy_rx_func+0x5c6>
80003256:	c1 09       	rjmp	80003476 <phy_rx_func+0x482>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80003258:	6e 28       	ld.w	r8,r7[0x8]
8000325a:	e0 6a 5a 5a 	mov	r10,23130
8000325e:	ea 1a ab cd 	orh	r10,0xabcd
80003262:	14 38       	cp.w	r8,r10
80003264:	c0 71       	brne	80003272 <phy_rx_func+0x27e>
			{
							
				m_RxBurstType = VOICE_WATING;
80003266:	30 09       	mov	r9,0
80003268:	fe f8 03 98 	ld.w	r8,pc[920]
8000326c:	91 09       	st.w	r8[0x0],r9
8000326e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80003272:	10 99       	mov	r9,r8
80003274:	e0 19 00 00 	andl	r9,0x0
80003278:	fc 1a ab cd 	movh	r10,0xabcd
8000327c:	14 39       	cp.w	r9,r10
8000327e:	e0 81 01 9e 	brne	800035ba <phy_rx_func+0x5c6>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
			#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80003282:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80003286:	fe f9 03 7e 	ld.w	r9,pc[894]
8000328a:	93 08       	st.w	r9[0x0],r8
		
			if((NULL== payload_ptr) )
8000328c:	fe f8 03 68 	ld.w	r8,pc[872]
80003290:	70 08       	ld.w	r8,r8[0x0]
80003292:	58 08       	cp.w	r8,0
80003294:	c1 11       	brne	800032b6 <phy_rx_func+0x2c2>
			{
				payload_ptr = get_payload_idle_isr();
80003296:	fe f8 03 5a 	ld.w	r8,pc[858]
8000329a:	70 0c       	ld.w	r12,r8[0x0]
8000329c:	f0 1f 00 cf 	mcall	800035d8 <phy_rx_func+0x5e4>
800032a0:	fe f8 03 54 	ld.w	r8,pc[852]
800032a4:	91 0c       	st.w	r8[0x0],r12
				//AMBE_payload_ptr = get_payload_idle_isr();
				
				if((NULL== payload_ptr) )
800032a6:	58 0c       	cp.w	r12,0
800032a8:	c0 71       	brne	800032b6 <phy_rx_func+0x2c2>
				{
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800032aa:	fe fc 03 5e 	ld.w	r12,pc[862]
800032ae:	f0 1f 00 d8 	mcall	8000360c <phy_rx_func+0x618>
800032b2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
#endif			
			//else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800032b6:	6e 28       	ld.w	r8,r7[0x8]
800032b8:	e2 18 f0 00 	andl	r8,0xf000,COH
800032bc:	e0 48 10 00 	cp.w	r8,4096
800032c0:	5f 1a       	srne	r10
800032c2:	e0 48 20 00 	cp.w	r8,8192
800032c6:	5f 19       	srne	r9
800032c8:	f5 e9 00 09 	and	r9,r10,r9
800032cc:	e0 81 01 77 	brne	800035ba <phy_rx_func+0x5c6>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;	
				else
					{
						if ((payload_rx_channel->dword[0] & 0x0000F000 ) == MIC_DATA)
800032d0:	e0 48 20 00 	cp.w	r8,8192
800032d4:	c0 51       	brne	800032de <phy_rx_func+0x2ea>
						{
							Rx_Mic_data = 1;
800032d6:	30 19       	mov	r9,1
800032d8:	fe f8 03 38 	ld.w	r8,pc[824]
800032dc:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800032de:	6e 28       	ld.w	r8,r7[0x8]
800032e0:	e2 18 f0 00 	andl	r8,0xf000,COH
800032e4:	e0 48 10 00 	cp.w	r8,4096
800032e8:	c0 51       	brne	800032f2 <phy_rx_func+0x2fe>
							Rx_Mic_data = 1;
						}
						
						if ((payload_rx_channel->dword[0] & 0x0000F000 ) == SPEAKER_DATA )
						{
							Rx_Speaker_data = 1;
800032ea:	30 19       	mov	r9,1
800032ec:	fe f8 03 28 	ld.w	r8,pc[808]
800032f0:	b0 89       	st.b	r8[0x0],r9
						}
					}
				
				AMBE_tx_flag = 0;
800032f2:	30 08       	mov	r8,0
800032f4:	fe f9 03 24 	ld.w	r9,pc[804]
800032f8:	b2 88       	st.b	r9[0x0],r8
				AMBE_rx_flag = 0;
800032fa:	fe f9 03 22 	ld.w	r9,pc[802]
800032fe:	b2 88       	st.b	r9[0x0],r8
				
				Item_ID = 0;//To make sure your save PCM data.
80003300:	fe f9 03 20 	ld.w	r9,pc[800]
80003304:	b2 88       	st.b	r9[0x0],r8
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003306:	6e 28       	ld.w	r8,r7[0x8]
80003308:	e2 18 0f 00 	andl	r8,0xf00,COH
8000330c:	e0 48 01 00 	cp.w	r8,256
80003310:	e0 8b 00 87 	brhi	8000341e <phy_rx_func+0x42a>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 0x00000100){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
				if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
80003314:	fe f9 02 f0 	ld.w	r9,pc[752]
80003318:	72 08       	ld.w	r8,r9[0x0]
8000331a:	20 48       	sub	r8,4
8000331c:	93 08       	st.w	r9[0x0],r8
8000331e:	e0 80 01 4e 	breq	800035ba <phy_rx_func+0x5c6>
				ArrayDiscLength = payload_rx_channel->word[2];
80003322:	8e e9       	ld.uh	r9,r7[0xc]
80003324:	fe f8 03 00 	ld.w	r8,pc[768]
80003328:	91 09       	st.w	r8[0x0],r9
					//Terminator_Flag = 0;
					//Tone_flag = 0;
					//Silent_flag = 0;
				//}
		
				switch (ArrayDiscLength){
8000332a:	70 08       	ld.w	r8,r8[0x0]
8000332c:	58 08       	cp.w	r8,0
8000332e:	c0 50       	breq	80003338 <phy_rx_func+0x344>
80003330:	58 18       	cp.w	r8,1
80003332:	e0 81 01 44 	brne	800035ba <phy_rx_func+0x5c6>
80003336:	c3 08       	rjmp	80003396 <phy_rx_func+0x3a2>
					case 0:          //The usual case. Remaining word in Phy buffer is Audio.
							
						Terminator_Flag = 0;
80003338:	30 08       	mov	r8,0
8000333a:	fe f9 02 ee 	ld.w	r9,pc[750]
8000333e:	b2 88       	st.b	r9[0x0],r8
						Tone_flag = 0;
80003340:	fe f9 02 ec 	ld.w	r9,pc[748]
80003344:	b2 88       	st.b	r9[0x0],r8
						Silent_flag = 0;
80003346:	fe f9 02 ea 	ld.w	r9,pc[746]
8000334a:	b2 88       	st.b	r9[0x0],r8
						//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);		
						payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000334c:	fe f8 02 e8 	ld.w	r8,pc[744]
80003350:	70 0a       	ld.w	r10,r8[0x0]
80003352:	fe f9 02 a2 	ld.w	r9,pc[674]
80003356:	72 09       	ld.w	r9,r9[0x0]
80003358:	8e 7b       	ld.sh	r11,r7[0xe]
8000335a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
						RxMedia_IsFillingNext16 += 1;
8000335e:	70 09       	ld.w	r9,r8[0x0]
80003360:	2f f9       	sub	r9,-1
80003362:	91 09       	st.w	r8[0x0],r9
						if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003364:	e0 49 00 ff 	cp.w	r9,255
80003368:	e0 88 00 11 	brls	8000338a <phy_rx_func+0x396>
						{
							RxMedia_IsFillingNext16 = 0;	
8000336c:	30 09       	mov	r9,0
8000336e:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);	
80003370:	fe f7 02 84 	ld.w	r7,pc[644]
80003374:	6e 0c       	ld.w	r12,r7[0x0]
80003376:	f0 1f 00 b1 	mcall	80003638 <phy_rx_func+0x644>
							payload_ptr = get_payload_idle_isr();
8000337a:	fe f8 02 76 	ld.w	r8,pc[630]
8000337e:	70 0c       	ld.w	r12,r8[0x0]
80003380:	f0 1f 00 96 	mcall	800035d8 <phy_rx_func+0x5e4>
80003384:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
80003386:	e0 80 01 1a 	breq	800035ba <phy_rx_func+0x5c6>
							{
								break;
							}				
						}
							RxMediaState = READINGMEDIA;
8000338a:	30 29       	mov	r9,2
8000338c:	fe f8 02 70 	ld.w	r8,pc[624]
80003390:	91 09       	st.w	r8[0x0],r9
80003392:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				
					case 1: //The next usual case.
							//In general case, add code to process single word Array descriptor.
							if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
80003396:	8e 78       	ld.sh	r8,r7[0xe]
80003398:	30 39       	mov	r9,3
8000339a:	f2 08 19 00 	cp.h	r8,r9
8000339e:	c0 d1       	brne	800033b8 <phy_rx_func+0x3c4>
							{
								Terminator_Flag = 1;
800033a0:	30 19       	mov	r9,1
800033a2:	fe f8 02 86 	ld.w	r8,pc[646]
800033a6:	b0 89       	st.b	r8[0x0],r9
								Rx_Mic_data = 0;
800033a8:	30 08       	mov	r8,0
800033aa:	fe f9 02 66 	ld.w	r9,pc[614]
800033ae:	b2 88       	st.b	r9[0x0],r8
								Rx_Speaker_data = 0;
800033b0:	fe f9 02 64 	ld.w	r9,pc[612]
800033b4:	b2 88       	st.b	r9[0x0],r8
800033b6:	c2 f8       	rjmp	80003414 <phy_rx_func+0x420>

							}
							else if(payload_rx_channel->word[3] == 0x0004)//Silent Descriptor
800033b8:	30 49       	mov	r9,4
800033ba:	f2 08 19 00 	cp.h	r8,r9
800033be:	c0 61       	brne	800033ca <phy_rx_func+0x3d6>
							{
							
								Silent_flag = 1;
800033c0:	30 19       	mov	r9,1
800033c2:	fe f8 02 6e 	ld.w	r8,pc[622]
800033c6:	b0 89       	st.b	r8[0x0],r9
800033c8:	c2 68       	rjmp	80003414 <phy_rx_func+0x420>
							}
							else if (payload_rx_channel->word[3] == 0x1026)//Tone Descriptor
800033ca:	e0 69 10 26 	mov	r9,4134
800033ce:	f2 08 19 00 	cp.h	r8,r9
800033d2:	c1 71       	brne	80003400 <phy_rx_func+0x40c>
							{
								Tone_flag = 1;
800033d4:	30 19       	mov	r9,1
800033d6:	fe f8 02 56 	ld.w	r8,pc[598]
800033da:	b0 89       	st.b	r8[0x0],r9
								Rx_Mic_data = 0;
800033dc:	30 08       	mov	r8,0
800033de:	fe f9 02 32 	ld.w	r9,pc[562]
800033e2:	b2 88       	st.b	r9[0x0],r8
								Rx_Speaker_data = 0;
800033e4:	fe f9 02 30 	ld.w	r9,pc[560]
800033e8:	b2 88       	st.b	r9[0x0],r8
								Tone_Counters++;
800033ea:	fe f8 02 52 	ld.w	r8,pc[594]
800033ee:	70 09       	ld.w	r9,r8[0x0]
800033f0:	2f f9       	sub	r9,-1
800033f2:	91 09       	st.w	r8[0x0],r9
								RxMediaState = WAITINGABAB;
800033f4:	30 09       	mov	r9,0
800033f6:	fe f8 02 06 	ld.w	r8,pc[518]
800033fa:	91 09       	st.w	r8[0x0],r9
800033fc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
							
							}
							else
							{
								Terminator_Flag = 0;
80003400:	30 08       	mov	r8,0
80003402:	fe f9 02 26 	ld.w	r9,pc[550]
80003406:	b2 88       	st.b	r9[0x0],r8
								Tone_flag = 0;
80003408:	fe f9 02 24 	ld.w	r9,pc[548]
8000340c:	b2 88       	st.b	r9[0x0],r8
								Silent_flag = 0;
8000340e:	fe f9 02 22 	ld.w	r9,pc[546]
80003412:	b2 88       	st.b	r9[0x0],r8
								
							}
					
					
							RxMediaState = READINGMEDIA;
80003414:	30 29       	mov	r9,2
80003416:	4f a8       	lddpc	r8,800035fc <phy_rx_func+0x608>
80003418:	91 09       	st.w	r8[0x0],r9
8000341a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
				}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
8000341e:	4f a8       	lddpc	r8,80003604 <phy_rx_func+0x610>
80003420:	70 08       	ld.w	r8,r8[0x0]
80003422:	58 18       	cp.w	r8,1
80003424:	e0 88 00 cb 	brls	800035ba <phy_rx_func+0x5c6>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003428:	fe f8 02 0c 	ld.w	r8,pc[524]
8000342c:	70 0a       	ld.w	r10,r8[0x0]
8000342e:	4f 29       	lddpc	r9,800035f4 <phy_rx_func+0x600>
80003430:	72 09       	ld.w	r9,r9[0x0]
80003432:	6e 3b       	ld.w	r11,r7[0xc]
80003434:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003438:	70 09       	ld.w	r9,r8[0x0]
8000343a:	2f f9       	sub	r9,-1
8000343c:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000343e:	e0 49 00 ff 	cp.w	r9,255
80003442:	e0 88 00 0f 	brls	80003460 <phy_rx_func+0x46c>
				{
					RxMedia_IsFillingNext16 = 0;
80003446:	30 09       	mov	r9,0
80003448:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000344a:	4e b7       	lddpc	r7,800035f4 <phy_rx_func+0x600>
8000344c:	6e 0c       	ld.w	r12,r7[0x0]
8000344e:	f0 1f 00 7b 	mcall	80003638 <phy_rx_func+0x644>
								payload_ptr = get_payload_idle_isr();
80003452:	4e 88       	lddpc	r8,800035f0 <phy_rx_func+0x5fc>
80003454:	70 0c       	ld.w	r12,r8[0x0]
80003456:	f0 1f 00 61 	mcall	800035d8 <phy_rx_func+0x5e4>
8000345a:	8f 0c       	st.w	r7[0x0],r12
													if(NULL == payload_ptr)
8000345c:	e0 80 00 af 	breq	800035ba <phy_rx_func+0x5c6>
													{
														break;
													}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003460:	4e 99       	lddpc	r9,80003604 <phy_rx_func+0x610>
80003462:	72 08       	ld.w	r8,r9[0x0]
80003464:	20 28       	sub	r8,2
80003466:	93 08       	st.w	r9[0x0],r8
80003468:	e0 80 00 a9 	breq	800035ba <phy_rx_func+0x5c6>
				RxMediaState = READINGMEDIA;
8000346c:	30 29       	mov	r9,2
8000346e:	4e 48       	lddpc	r8,800035fc <phy_rx_func+0x608>
80003470:	91 09       	st.w	r8[0x0],r9
80003472:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
80003476:	4f 08       	lddpc	r8,80003634 <phy_rx_func+0x640>
80003478:	70 0a       	ld.w	r10,r8[0x0]
8000347a:	4d f9       	lddpc	r9,800035f4 <phy_rx_func+0x600>
8000347c:	72 09       	ld.w	r9,r9[0x0]
8000347e:	8e 4b       	ld.sh	r11,r7[0x8]
80003480:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
80003484:	70 09       	ld.w	r9,r8[0x0]
80003486:	2f f9       	sub	r9,-1
80003488:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000348a:	e0 49 00 ff 	cp.w	r9,255
8000348e:	e0 88 00 13 	brls	800034b4 <phy_rx_func+0x4c0>
					{
							RxMedia_IsFillingNext16 = 0;
80003492:	30 09       	mov	r9,0
80003494:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
80003496:	4d 86       	lddpc	r6,800035f4 <phy_rx_func+0x600>
80003498:	6c 0c       	ld.w	r12,r6[0x0]
8000349a:	f0 1f 00 68 	mcall	80003638 <phy_rx_func+0x644>
							payload_ptr = get_payload_idle_isr();
8000349e:	4d 58       	lddpc	r8,800035f0 <phy_rx_func+0x5fc>
800034a0:	70 0c       	ld.w	r12,r8[0x0]
800034a2:	f0 1f 00 4e 	mcall	800035d8 <phy_rx_func+0x5e4>
800034a6:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == payload_ptr)
800034a8:	c0 61       	brne	800034b4 <phy_rx_func+0x4c0>
							{
								RxMediaState = WAITINGABAB;
800034aa:	30 09       	mov	r9,0
800034ac:	4d 48       	lddpc	r8,800035fc <phy_rx_func+0x608>
800034ae:	91 09       	st.w	r8[0x0],r9
800034b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
					}
				if ((RxBytesWaiting -= 2) <= 0)
800034b4:	4d 49       	lddpc	r9,80003604 <phy_rx_func+0x610>
800034b6:	72 08       	ld.w	r8,r9[0x0]
800034b8:	20 28       	sub	r8,2
800034ba:	93 08       	st.w	r9[0x0],r8
800034bc:	c0 61       	brne	800034c8 <phy_rx_func+0x4d4>
				{
					RxMediaState = WAITINGABAB;
800034be:	30 09       	mov	r9,0
800034c0:	4c f8       	lddpc	r8,800035fc <phy_rx_func+0x608>
800034c2:	91 09       	st.w	r8[0x0],r9
800034c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800034c8:	4d b8       	lddpc	r8,80003634 <phy_rx_func+0x640>
800034ca:	70 0a       	ld.w	r10,r8[0x0]
800034cc:	4c a9       	lddpc	r9,800035f4 <phy_rx_func+0x600>
800034ce:	72 09       	ld.w	r9,r9[0x0]
800034d0:	8e 5b       	ld.sh	r11,r7[0xa]
800034d2:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800034d6:	70 09       	ld.w	r9,r8[0x0]
800034d8:	2f f9       	sub	r9,-1
800034da:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800034dc:	e0 49 00 ff 	cp.w	r9,255
800034e0:	e0 88 00 13 	brls	80003506 <phy_rx_func+0x512>
						{
							RxMedia_IsFillingNext16 = 0;
800034e4:	30 09       	mov	r9,0
800034e6:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
800034e8:	4c 36       	lddpc	r6,800035f4 <phy_rx_func+0x600>
800034ea:	6c 0c       	ld.w	r12,r6[0x0]
800034ec:	f0 1f 00 53 	mcall	80003638 <phy_rx_func+0x644>
								payload_ptr = get_payload_idle_isr();
800034f0:	4c 08       	lddpc	r8,800035f0 <phy_rx_func+0x5fc>
800034f2:	70 0c       	ld.w	r12,r8[0x0]
800034f4:	f0 1f 00 39 	mcall	800035d8 <phy_rx_func+0x5e4>
800034f8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == payload_ptr)
800034fa:	c0 61       	brne	80003506 <phy_rx_func+0x512>
								{
									RxMediaState = WAITINGABAB;
800034fc:	30 09       	mov	r9,0
800034fe:	4c 08       	lddpc	r8,800035fc <phy_rx_func+0x608>
80003500:	91 09       	st.w	r8[0x0],r9
80003502:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003506:	4c 09       	lddpc	r9,80003604 <phy_rx_func+0x610>
80003508:	72 08       	ld.w	r8,r9[0x0]
8000350a:	20 28       	sub	r8,2
8000350c:	93 08       	st.w	r9[0x0],r8
8000350e:	c0 61       	brne	8000351a <phy_rx_func+0x526>
					RxMediaState = WAITINGABAB;
80003510:	30 09       	mov	r9,0
80003512:	4b b8       	lddpc	r8,800035fc <phy_rx_func+0x608>
80003514:	91 09       	st.w	r8[0x0],r9
80003516:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000351a:	4c 78       	lddpc	r8,80003634 <phy_rx_func+0x640>
8000351c:	70 0a       	ld.w	r10,r8[0x0]
8000351e:	4b 69       	lddpc	r9,800035f4 <phy_rx_func+0x600>
80003520:	72 09       	ld.w	r9,r9[0x0]
80003522:	8e 6b       	ld.sh	r11,r7[0xc]
80003524:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003528:	70 09       	ld.w	r9,r8[0x0]
8000352a:	2f f9       	sub	r9,-1
8000352c:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000352e:	e0 49 00 ff 	cp.w	r9,255
80003532:	e0 88 00 13 	brls	80003558 <phy_rx_func+0x564>
						{
							RxMedia_IsFillingNext16 = 0;
80003536:	30 09       	mov	r9,0
80003538:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);
8000353a:	4a f6       	lddpc	r6,800035f4 <phy_rx_func+0x600>
8000353c:	6c 0c       	ld.w	r12,r6[0x0]
8000353e:	f0 1f 00 3f 	mcall	80003638 <phy_rx_func+0x644>
									payload_ptr = get_payload_idle_isr();
80003542:	4a c8       	lddpc	r8,800035f0 <phy_rx_func+0x5fc>
80003544:	70 0c       	ld.w	r12,r8[0x0]
80003546:	f0 1f 00 25 	mcall	800035d8 <phy_rx_func+0x5e4>
8000354a:	8d 0c       	st.w	r6[0x0],r12
									if(NULL == payload_ptr)
8000354c:	c0 61       	brne	80003558 <phy_rx_func+0x564>
									{
										RxMediaState = WAITINGABAB;
8000354e:	30 09       	mov	r9,0
80003550:	4a b8       	lddpc	r8,800035fc <phy_rx_func+0x608>
80003552:	91 09       	st.w	r8[0x0],r9
80003554:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
						}
				if ((RxBytesWaiting -= 2) <= 0){
80003558:	4a b9       	lddpc	r9,80003604 <phy_rx_func+0x610>
8000355a:	72 08       	ld.w	r8,r9[0x0]
8000355c:	20 28       	sub	r8,2
8000355e:	93 08       	st.w	r9[0x0],r8
80003560:	c0 61       	brne	8000356c <phy_rx_func+0x578>
					RxMediaState = WAITINGABAB;
80003562:	30 09       	mov	r9,0
80003564:	4a 68       	lddpc	r8,800035fc <phy_rx_func+0x608>
80003566:	91 09       	st.w	r8[0x0],r9
80003568:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
8000356c:	4b 28       	lddpc	r8,80003634 <phy_rx_func+0x640>
8000356e:	70 0a       	ld.w	r10,r8[0x0]
80003570:	4a 19       	lddpc	r9,800035f4 <phy_rx_func+0x600>
80003572:	72 09       	ld.w	r9,r9[0x0]
80003574:	8e 7b       	ld.sh	r11,r7[0xe]
80003576:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000357a:	70 09       	ld.w	r9,r8[0x0]
8000357c:	2f f9       	sub	r9,-1
8000357e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003580:	e0 49 00 ff 	cp.w	r9,255
80003584:	e0 88 00 13 	brls	800035aa <phy_rx_func+0x5b6>
						{
							RxMedia_IsFillingNext16 = 0;
80003588:	30 09       	mov	r9,0
8000358a:	91 09       	st.w	r8[0x0],r9
							payload_rx(payload_ptr);
8000358c:	49 a7       	lddpc	r7,800035f4 <phy_rx_func+0x600>
8000358e:	6e 0c       	ld.w	r12,r7[0x0]
80003590:	f0 1f 00 2a 	mcall	80003638 <phy_rx_func+0x644>
							payload_ptr = get_payload_idle_isr();
80003594:	49 78       	lddpc	r8,800035f0 <phy_rx_func+0x5fc>
80003596:	70 0c       	ld.w	r12,r8[0x0]
80003598:	f0 1f 00 10 	mcall	800035d8 <phy_rx_func+0x5e4>
8000359c:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == payload_ptr)
8000359e:	c0 61       	brne	800035aa <phy_rx_func+0x5b6>
							{
								RxMediaState = WAITINGABAB;
800035a0:	30 09       	mov	r9,0
800035a2:	49 78       	lddpc	r8,800035fc <phy_rx_func+0x608>
800035a4:	91 09       	st.w	r8[0x0],r9
800035a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
				if ((RxBytesWaiting -= 2) <= 0){
800035aa:	49 79       	lddpc	r9,80003604 <phy_rx_func+0x610>
800035ac:	72 08       	ld.w	r8,r9[0x0]
800035ae:	20 28       	sub	r8,2
800035b0:	93 08       	st.w	r9[0x0],r8
800035b2:	c0 41       	brne	800035ba <phy_rx_func+0x5c6>
					RxMediaState = WAITINGABAB;
800035b4:	30 09       	mov	r9,0
800035b6:	49 28       	lddpc	r8,800035fc <phy_rx_func+0x608>
800035b8:	91 09       	st.w	r8[0x0],r9
800035ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800035be:	00 00       	add	r0,r0
800035c0:	00 00       	add	r0,r0
800035c2:	0a b8       	st.h	r5++,r8
800035c4:	00 00       	add	r0,r0
800035c6:	0a b4       	st.h	r5++,r4
800035c8:	00 00       	add	r0,r0
800035ca:	0a 98       	mov	r8,r5
800035cc:	00 00       	add	r0,r0
800035ce:	0a e0       	st.h	--r5,r0
800035d0:	00 00       	add	r0,r0
800035d2:	0a d4       	st.w	--r5,r4
800035d4:	00 00       	add	r0,r0
800035d6:	0a 9c       	mov	r12,r5
800035d8:	80 00       	ld.sh	r0,r0[0x0]
800035da:	2a 2c       	sub	r12,-94
800035dc:	00 00       	add	r0,r0
800035de:	0a 7c       	tst	r12,r5
800035e0:	80 00       	ld.sh	r0,r0[0x0]
800035e2:	4b dc       	lddpc	r12,800036d4 <local_start_SSC+0x20>
800035e4:	00 00       	add	r0,r0
800035e6:	0a a0       	st.w	r5++,r0
800035e8:	80 00       	ld.sh	r0,r0[0x0]
800035ea:	29 78       	sub	r8,-105
800035ec:	00 00       	add	r0,r0
800035ee:	0a d0       	st.w	--r5,r0
800035f0:	00 00       	add	r0,r0
800035f2:	0a 80       	andn	r0,r5
800035f4:	00 00       	add	r0,r0
800035f6:	0a 88       	andn	r8,r5
800035f8:	00 00       	add	r0,r0
800035fa:	04 f4       	st.b	--r2,r4
800035fc:	00 00       	add	r0,r0
800035fe:	0a ac       	st.w	r5++,r12
80003600:	00 00       	add	r0,r0
80003602:	0a 78       	tst	r8,r5
80003604:	00 00       	add	r0,r0
80003606:	0a 90       	mov	r0,r5
80003608:	80 00       	ld.sh	r0,r0[0x0]
8000360a:	c4 24       	brge	8000368e <pdca_int_handler+0x4e>
8000360c:	80 00       	ld.sh	r0,r0[0x0]
8000360e:	5c d4       	com	r4
80003610:	00 00       	add	r0,r0
80003612:	0a 44       	or	r4,r5
80003614:	00 00       	add	r0,r0
80003616:	0a 56       	eor	r6,r5
80003618:	00 00       	add	r0,r0
8000361a:	0a 42       	or	r2,r5
8000361c:	00 00       	add	r0,r0
8000361e:	0a 40       	or	r0,r5
80003620:	00 00       	add	r0,r0
80003622:	0a c8       	st.b	r5++,r8
80003624:	00 00       	add	r0,r0
80003626:	0a a8       	st.w	r5++,r8
80003628:	00 00       	add	r0,r0
8000362a:	0a 64       	and	r4,r5
8000362c:	00 00       	add	r0,r0
8000362e:	0a 4c       	or	r12,r5
80003630:	00 00       	add	r0,r0
80003632:	0a 5c       	eor	r12,r5
80003634:	00 00       	add	r0,r0
80003636:	0a dc       	st.w	--r5,r12
80003638:	80 00       	ld.sh	r0,r0[0x0]
8000363a:	2f 94       	sub	r4,-7
8000363c:	00 00       	add	r0,r0
8000363e:	0a 48       	or	r8,r5

80003640 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003640:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003642:	49 88       	lddpc	r8,800036a0 <pdca_int_handler+0x60>
80003644:	11 89       	ld.ub	r9,r8[0x0]
80003646:	ec 19 00 01 	eorl	r9,0x1
8000364a:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
8000364c:	11 89       	ld.ub	r9,r8[0x0]
8000364e:	a5 69       	lsl	r9,0x4
80003650:	2f c9       	sub	r9,-4
80003652:	49 5a       	lddpc	r10,800036a4 <pdca_int_handler+0x64>
80003654:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003656:	fe 7a 00 40 	mov	r10,-65472
8000365a:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
8000365c:	30 39       	mov	r9,3
8000365e:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003660:	11 8a       	ld.ub	r10,r8[0x0]
80003662:	a5 6a       	lsl	r10,0x4
80003664:	2f ca       	sub	r10,-4
80003666:	49 18       	lddpc	r8,800036a8 <pdca_int_handler+0x68>
80003668:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
8000366a:	fe 78 00 00 	mov	r8,-65536
8000366e:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003670:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003672:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003674:	48 e8       	lddpc	r8,800036ac <pdca_int_handler+0x6c>
80003676:	70 08       	ld.w	r8,r8[0x0]
80003678:	58 08       	cp.w	r8,0
8000367a:	c0 70       	breq	80003688 <pdca_int_handler+0x48>
8000367c:	48 99       	lddpc	r9,800036a0 <pdca_int_handler+0x60>
8000367e:	13 89       	ld.ub	r9,r9[0x0]
80003680:	a5 69       	lsl	r9,0x4
80003682:	48 ac       	lddpc	r12,800036a8 <pdca_int_handler+0x68>
80003684:	12 0c       	add	r12,r9
80003686:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003688:	48 a8       	lddpc	r8,800036b0 <pdca_int_handler+0x70>
8000368a:	70 08       	ld.w	r8,r8[0x0]
8000368c:	58 08       	cp.w	r8,0
8000368e:	c0 70       	breq	8000369c <pdca_int_handler+0x5c>
80003690:	48 49       	lddpc	r9,800036a0 <pdca_int_handler+0x60>
80003692:	13 89       	ld.ub	r9,r9[0x0]
80003694:	a5 69       	lsl	r9,0x4
80003696:	48 4c       	lddpc	r12,800036a4 <pdca_int_handler+0x64>
80003698:	12 0c       	add	r12,r9
8000369a:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
8000369c:	d4 02       	popm	lr
8000369e:	d6 03       	rete
800036a0:	00 00       	add	r0,r0
800036a2:	3f b0       	mov	r0,-5
800036a4:	00 00       	add	r0,r0
800036a6:	3f d8       	mov	r8,-3
800036a8:	00 00       	add	r0,r0
800036aa:	3f b8       	mov	r8,-5
800036ac:	00 00       	add	r0,r0
800036ae:	0a e4       	st.h	--r5,r4
800036b0:	00 00       	add	r0,r0
800036b2:	0a e8       	st.h	--r5,r8

800036b4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800036b4:	fe 78 10 00 	mov	r8,-61440
800036b8:	e0 69 0d c0 	mov	r9,3520
800036bc:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800036c0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
800036c4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
800036c8:	fe 78 34 00 	mov	r8,-52224
800036cc:	e0 69 80 00 	mov	r9,32768
800036d0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
800036d2:	30 09       	mov	r9,0
800036d4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
800036d6:	e0 69 04 21 	mov	r9,1057
800036da:	ea 19 3f 20 	orh	r9,0x3f20
800036de:	91 69       	st.w	r8[0x18],r9
	    | 32 << AVR32_SSC_TCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 31 << AVR32_SSC_TFMR_DATLEN_OFFSET 
800036e0:	e0 69 02 9f 	mov	r9,671
800036e4:	ea 19 01 00 	orh	r9,0x100
800036e8:	91 79       	st.w	r8[0x1c],r9
	    | 0 << AVR32_SSC_TFMR_FSDEN_OFFSET
	    | 1 << AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = AVR32_SSC_RCMR_CKS_RK_PIN << AVR32_SSC_RCMR_CKS_OFFSET
800036ea:	e0 6a 04 02 	mov	r10,1026
800036ee:	ea 1a 3f 20 	orh	r10,0x3f20
800036f2:	91 4a       	st.w	r8[0x10],r10
	    | 0 << AVR32_SSC_RCMR_STOP_OFFSET
	    | 32 << AVR32_SSC_RCMR_STTDLY_OFFSET
	    | 63 << AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 31 << AVR32_SSC_RFMR_DATLEN_OFFSET
800036f4:	91 59       	st.w	r8[0x14],r9
	    | 1 << AVR32_SSC_RFMR_MSBF_OFFSET
	    | 2 << AVR32_SSC_RFMR_DATNB_OFFSET
	    | 0 << AVR32_SSC_RFMR_FSLEN_OFFSET
	    | AVR32_SSC_RFMR_FSOS_INPUT_ONLY << AVR32_SSC_RFMR_FSOS_OFFSET
	    | 1 << AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
800036f6:	5e fc       	retal	r12

800036f8 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
800036f8:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
800036fa:	30 19       	mov	r9,1
800036fc:	49 78       	lddpc	r8,80003758 <local_start_PDC+0x60>
800036fe:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003700:	fe 78 00 00 	mov	r8,-65536
80003704:	30 7b       	mov	r11,7
80003706:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003708:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000370a:	49 59       	lddpc	r9,8000375c <local_start_PDC+0x64>
8000370c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003710:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003712:	30 3a       	mov	r10,3
80003714:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003716:	30 1c       	mov	r12,1
80003718:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000371a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
8000371c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000371e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003720:	30 2c       	mov	r12,2
80003722:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003724:	48 f9       	lddpc	r9,80003760 <local_start_PDC+0x68>
80003726:	e0 68 5a 5a 	mov	r8,23130
8000372a:	ea 18 ab cd 	orh	r8,0xabcd
8000372e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003730:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003732:	30 0e       	mov	lr,0
80003734:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003736:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003738:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000373a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
8000373c:	fe 78 00 40 	mov	r8,-65472
80003740:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003742:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003744:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003748:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000374a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
8000374c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000374e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003750:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003752:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003754:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003756:	d8 02       	popm	pc
80003758:	00 00       	add	r0,r0
8000375a:	3f b0       	mov	r0,-5
8000375c:	00 00       	add	r0,r0
8000375e:	3f b8       	mov	r8,-5
80003760:	00 00       	add	r0,r0
80003762:	3f d8       	mov	r8,-3

80003764 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003764:	48 38       	lddpc	r8,80003770 <register_rx_tx_func+0xc>
80003766:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003768:	48 38       	lddpc	r8,80003774 <register_rx_tx_func+0x10>
8000376a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
8000376c:	5e fc       	retal	r12
8000376e:	00 00       	add	r0,r0
80003770:	00 00       	add	r0,r0
80003772:	0a e4       	st.h	--r5,r4
80003774:	00 00       	add	r0,r0
80003776:	0a e8       	st.h	--r5,r8

80003778 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003778:	d4 01       	pushm	lr
    /*Set up PB03 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000377a:	fe 78 10 00 	mov	r8,-61440
8000377e:	30 29       	mov	r9,2
80003780:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003784:	f1 49 01 04 	st.w	r8[260],r9

    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003788:	10 99       	mov	r9,r8
8000378a:	f2 f8 01 60 	ld.w	r8,r9[352]
8000378e:	e2 18 00 02 	andl	r8,0x2,COH
80003792:	cf c0       	breq	8000378a <ssc_init+0x12>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003794:	fe 79 10 00 	mov	r9,-61440
80003798:	f2 f8 01 60 	ld.w	r8,r9[352]
8000379c:	e2 18 00 02 	andl	r8,0x2,COH
800037a0:	cf c1       	brne	80003798 <ssc_init+0x20>
				
    INTC_register_interrupt (
800037a2:	30 3a       	mov	r10,3
800037a4:	36 0b       	mov	r11,96
800037a6:	48 bc       	lddpc	r12,800037d0 <ssc_init+0x58>
800037a8:	f0 1f 00 0b 	mcall	800037d4 <ssc_init+0x5c>
        , AVR32_PDCA_IRQ_0
        , AVR32_INTC_INT3
    );
				
    /*config the SSC*/
    local_start_SSC();
800037ac:	f0 1f 00 0b 	mcall	800037d8 <ssc_init+0x60>

    /*config the PDCA*/
    local_start_PDC();
800037b0:	f0 1f 00 0b 	mcall	800037dc <ssc_init+0x64>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800037b4:	fe 79 00 00 	mov	r9,-65536
800037b8:	30 18       	mov	r8,1
800037ba:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800037bc:	fe 7a 00 40 	mov	r10,-65472
800037c0:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800037c2:	e0 6b 01 01 	mov	r11,257
800037c6:	fe 7a 34 00 	mov	r10,-52224
800037ca:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = 
800037cc:	93 88       	st.w	r9[0x20],r8
                                                            AVR32_PDCA_RCZ_MASK;
}/*End of ssc_init.*/
800037ce:	d8 02       	popm	pc
800037d0:	80 00       	ld.sh	r0,r0[0x0]
800037d2:	36 40       	mov	r0,100
800037d4:	80 00       	ld.sh	r0,r0[0x0]
800037d6:	42 14       	lddsp	r4,sp[0x84]
800037d8:	80 00       	ld.sh	r0,r0[0x0]
800037da:	36 b4       	mov	r4,107
800037dc:	80 00       	ld.sh	r0,r0[0x0]
800037de:	36 f8       	mov	r8,111

800037e0 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800037e0:	48 28       	lddpc	r8,800037e8 <xcmp_register_app_list+0x8>
800037e2:	91 0c       	st.w	r8[0x0],r12
}
800037e4:	5e fc       	retal	r12
800037e6:	00 00       	add	r0,r0
800037e8:	00 00       	add	r0,r0
800037ea:	3f f8       	mov	r8,-1

800037ec <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
800037ec:	eb cd 40 80 	pushm	r7,lr
800037f0:	fa cd 01 00 	sub	sp,sp,256
800037f4:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
800037f6:	16 98       	mov	r8,r11
800037f8:	2f 08       	sub	r8,-16
800037fa:	af a8       	sbr	r8,0xe
800037fc:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
800037fe:	3f f8       	mov	r8,-1
80003800:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003802:	30 b9       	mov	r9,11
80003804:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003806:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003808:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000380a:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000380c:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
8000380e:	f6 ca ff fe 	sub	r10,r11,-2
80003812:	18 9b       	mov	r11,r12
80003814:	fa cc ff f0 	sub	r12,sp,-16
80003818:	f0 1f 00 05 	mcall	8000382c <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
8000381c:	2f e7       	sub	r7,-2
8000381e:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003820:	1a 9c       	mov	r12,sp
80003822:	f0 1f 00 04 	mcall	80003830 <xcmp_tx+0x44>
}
80003826:	2c 0d       	sub	sp,-256
80003828:	e3 cd 80 80 	ldm	sp++,r7,pc
8000382c:	80 00       	ld.sh	r0,r0[0x0]
8000382e:	64 a8       	ld.w	r8,r2[0x28]
80003830:	80 00       	ld.sh	r0,r0[0x0]
80003832:	3c 78       	mov	r8,-57

80003834 <xcmp_audio_route_mic>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_audio_route_mic(void)
{
80003834:	d4 01       	pushm	lr
80003836:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | AUDIO_ROUTING_CONTROL;
8000383a:	e0 68 04 14 	mov	r8,1044
8000383e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	AudioRoutingControl_req_t * ptr = (AudioRoutingControl_req_t *)xcmp_farme.u8;
80003840:	fa c8 ff fc 	sub	r8,sp,-4
			
	ptr->Function = Routing_Func_Update_Source;
80003844:	30 19       	mov	r9,1
80003846:	b0 89       	st.b	r8[0x0],r9
	
	
	unsigned short NumberofRoutings = 2;
	ptr->NumberofRoutings[0] = (NumberofRoutings >> 8) & 0xFF;
80003848:	30 0a       	mov	r10,0
8000384a:	b0 9a       	st.b	r8[0x1],r10
	ptr->NumberofRoutings[1] = NumberofRoutings & 0xFF;
8000384c:	30 2a       	mov	r10,2
8000384e:	b0 aa       	st.b	r8[0x2],r10
	
	ptr->RoutingData[0].audioInput = IN_Microphone;
80003850:	b0 b9       	st.b	r8[0x3],r9
	ptr->RoutingData[0].audioOutput = OUT_Option_Board;
80003852:	30 c9       	mov	r9,12
80003854:	b0 c9       	st.b	r8[0x4],r9
	
	ptr->RoutingData[1].audioInput = IN_Option_Board;
80003856:	b0 d9       	st.b	r8[0x5],r9
	ptr->RoutingData[1].audioOutput = OUT_Microphone_Data;
80003858:	30 d9       	mov	r9,13
8000385a:	b0 e9       	st.b	r8[0x6],r9
		//
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(AudioRoutingControl_req_t) - (MAX_ROUTING_CTR - NumberofRoutings) * sizeof(RoutingData_t));
8000385c:	30 7b       	mov	r11,7
8000385e:	fa cc ff fe 	sub	r12,sp,-2
80003862:	f0 1f 00 03 	mcall	8000386c <xcmp_audio_route_mic+0x38>
}
80003866:	2c dd       	sub	sp,-204
80003868:	d8 02       	popm	pc
8000386a:	00 00       	add	r0,r0
8000386c:	80 00       	ld.sh	r0,r0[0x0]
8000386e:	37 ec       	mov	r12,126

80003870 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003870:	d4 01       	pushm	lr
80003872:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003876:	fe 78 b4 00 	mov	r8,-19456
8000387a:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
8000387c:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003880:	30 89       	mov	r9,8
80003882:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003884:	30 19       	mov	r9,1
80003886:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003888:	30 09       	mov	r9,0
8000388a:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
8000388c:	30 5a       	mov	r10,5
8000388e:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003890:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003892:	30 7a       	mov	r10,7
80003894:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003896:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003898:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000389a:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000389e:	30 9b       	mov	r11,9
800038a0:	fa cc ff fe 	sub	r12,sp,-2
800038a4:	f0 1f 00 02 	mcall	800038ac <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
800038a8:	2c dd       	sub	sp,-204
800038aa:	d8 02       	popm	pc
800038ac:	80 00       	ld.sh	r0,r0[0x0]
800038ae:	37 ec       	mov	r12,126

800038b0 <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
800038b0:	d4 01       	pushm	lr
800038b2:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
800038b6:	fe 78 80 00 	mov	r8,-32768
800038ba:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
800038bc:	30 38       	mov	r8,3
800038be:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
800038c0:	30 1b       	mov	r11,1
800038c2:	fa cc ff fe 	sub	r12,sp,-2
800038c6:	f0 1f 00 03 	mcall	800038d0 <xcmp_opcode_not_supported+0x20>
}
800038ca:	2c dd       	sub	sp,-204
800038cc:	d8 02       	popm	pc
800038ce:	00 00       	add	r0,r0
800038d0:	80 00       	ld.sh	r0,r0[0x0]
800038d2:	37 ec       	mov	r12,126

800038d4 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
800038d4:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
800038d6:	96 88       	ld.uh	r8,r11[0x0]
800038d8:	e2 18 f0 00 	andl	r8,0xf000,COH
800038dc:	e0 48 80 00 	cp.w	r8,32768
800038e0:	c0 f0       	breq	800038fe <xcmp_exec_func+0x2a>
800038e2:	e0 48 b0 00 	cp.w	r8,45056
800038e6:	c1 20       	breq	8000390a <xcmp_exec_func+0x36>
800038e8:	58 08       	cp.w	r8,0
800038ea:	c1 51       	brne	80003914 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
800038ec:	78 08       	ld.w	r8,r12[0x0]
800038ee:	58 08       	cp.w	r8,0
800038f0:	c0 40       	breq	800038f8 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
800038f2:	16 9c       	mov	r12,r11
800038f4:	5d 18       	icall	r8
800038f6:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
800038f8:	f0 1f 00 08 	mcall	80003918 <xcmp_exec_func+0x44>
800038fc:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
800038fe:	78 18       	ld.w	r8,r12[0x4]
80003900:	58 08       	cp.w	r8,0
80003902:	c0 90       	breq	80003914 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003904:	16 9c       	mov	r12,r11
80003906:	5d 18       	icall	r8
80003908:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
8000390a:	78 28       	ld.w	r8,r12[0x8]
8000390c:	58 08       	cp.w	r8,0
8000390e:	c0 30       	breq	80003914 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003910:	16 9c       	mov	r12,r11
80003912:	5d 18       	icall	r8
80003914:	d8 02       	popm	pc
80003916:	00 00       	add	r0,r0
80003918:	80 00       	ld.sh	r0,r0[0x0]
8000391a:	38 b0       	mov	r0,-117

8000391c <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(void)
{
8000391c:	d4 01       	pushm	lr
8000391e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003922:	e0 68 04 09 	mov	r8,1033
80003926:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003928:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = Tone_Start;
8000392c:	30 19       	mov	r9,1
8000392e:	b0 89       	st.b	r8[0x0],r9
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
80003930:	30 09       	mov	r9,0
80003932:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
80003934:	30 ca       	mov	r10,12
80003936:	b0 aa       	st.b	r8[0x2],r10
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003938:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
8000393a:	fb 69 00 08 	st.b	sp[8],r9
8000393e:	fa c8 ff f7 	sub	r8,sp,-9
80003942:	b0 89       	st.b	r8[0x0],r9
80003944:	fa c8 ff f6 	sub	r8,sp,-10
80003948:	b0 89       	st.b	r8[0x0],r9
8000394a:	fa c8 ff f5 	sub	r8,sp,-11
8000394e:	b0 89       	st.b	r8[0x0],r9
80003950:	fa c8 ff f4 	sub	r8,sp,-12
80003954:	b0 89       	st.b	r8[0x0],r9
80003956:	fa c8 ff f3 	sub	r8,sp,-13
8000395a:	b0 89       	st.b	r8[0x0],r9
8000395c:	fa c8 ff f2 	sub	r8,sp,-14
80003960:	b0 89       	st.b	r8[0x0],r9
80003962:	fa c8 ff f1 	sub	r8,sp,-15
80003966:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003968:	30 cb       	mov	r11,12
8000396a:	fa cc ff fe 	sub	r12,sp,-2
8000396e:	f0 1f 00 03 	mcall	80003978 <xcmp_IdleTestTone+0x5c>
}
80003972:	2c dd       	sub	sp,-204
80003974:	d8 02       	popm	pc
80003976:	00 00       	add	r0,r0
80003978:	80 00       	ld.sh	r0,r0[0x0]
8000397a:	37 ec       	mov	r12,126

8000397c <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
8000397c:	d4 01       	pushm	lr
	/*initialize the xnl*/
	xnl_init();
8000397e:	f0 1f 00 0d 	mcall	800039b0 <xcmp_init+0x34>
	
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003982:	48 dc       	lddpc	r12,800039b4 <xcmp_init+0x38>
80003984:	f0 1f 00 0d 	mcall	800039b8 <xcmp_init+0x3c>
	
	/*initialize the queue*/
	//xcmp_frame_rx = xQueueCreate(10, sizeof(xcmp_fragment_t *));
	
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003988:	30 4b       	mov	r11,4
8000398a:	31 4c       	mov	r12,20
8000398c:	f0 1f 00 0c 	mcall	800039bc <xcmp_init+0x40>
80003990:	48 c8       	lddpc	r8,800039c0 <xcmp_init+0x44>
80003992:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003994:	30 09       	mov	r9,0
80003996:	1a d9       	st.w	--sp,r9
80003998:	1a d9       	st.w	--sp,r9
8000399a:	1a d9       	st.w	--sp,r9
8000399c:	30 38       	mov	r8,3
8000399e:	e0 6a 01 80 	mov	r10,384
800039a2:	48 9b       	lddpc	r11,800039c4 <xcmp_init+0x48>
800039a4:	48 9c       	lddpc	r12,800039c8 <xcmp_init+0x4c>
800039a6:	f0 1f 00 0a 	mcall	800039cc <xcmp_init+0x50>
800039aa:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskXCMP_PRIORITY
	,  NULL
	);
}
800039ac:	d8 02       	popm	pc
800039ae:	00 00       	add	r0,r0
800039b0:	80 00       	ld.sh	r0,r0[0x0]
800039b2:	3d 5c       	mov	r12,-43
800039b4:	80 00       	ld.sh	r0,r0[0x0]
800039b6:	3a cc       	mov	r12,-84
800039b8:	80 00       	ld.sh	r0,r0[0x0]
800039ba:	3b 18       	mov	r8,-79
800039bc:	80 00       	ld.sh	r0,r0[0x0]
800039be:	50 b0       	stdsp	sp[0x2c],r0
800039c0:	00 00       	add	r0,r0
800039c2:	0a f8       	st.b	--r5,r8
800039c4:	80 00       	ld.sh	r0,r0[0x0]
800039c6:	c4 3c       	rcall	80003a4c <xcmp_rx_process+0x7c>
800039c8:	80 00       	ld.sh	r0,r0[0x0]
800039ca:	39 d0       	mov	r0,-99
800039cc:	80 00       	ld.sh	r0,r0[0x0]
800039ce:	57 84       	stdsp	sp[0x1e0],r4

800039d0 <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
800039d0:	d4 31       	pushm	r0-r7,lr
800039d2:	20 1d       	sub	sp,4
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800039d4:	4b 16       	lddpc	r6,80003a98 <xcmp_rx_process+0xc8>
800039d6:	30 05       	mov	r5,0
800039d8:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800039da:	4b 13       	lddpc	r3,80003a9c <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800039dc:	4b 12       	lddpc	r2,80003aa0 <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800039de:	4b 21       	lddpc	r1,80003aa4 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800039e0:	4b 20       	lddpc	r0,80003aa8 <xcmp_rx_process+0xd8>
	xcmp_fragment_t xcmp;
	xcmp_fragment_t * ptr;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
800039e2:	6c 0c       	ld.w	r12,r6[0x0]
800039e4:	0a 99       	mov	r9,r5
800039e6:	08 9a       	mov	r10,r4
800039e8:	1a 9b       	mov	r11,sp
800039ea:	f0 1f 00 31 	mcall	80003aac <xcmp_rx_process+0xdc>
800039ee:	58 1c       	cp.w	r12,1
800039f0:	cf 91       	brne	800039e2 <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
800039f2:	40 0b       	lddsp	r11,sp[0x0]
800039f4:	58 0b       	cp.w	r11,0
800039f6:	cf 60       	breq	800039e2 <xcmp_rx_process+0x12>
				continue;
			}
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
						
			switch(ptr->xcmp_opcode & 0x0FFF)
800039f8:	96 0a       	ld.sh	r10,r11[0x0]
800039fa:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800039fe:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003a02:	59 c8       	cp.w	r8,28
80003a04:	c1 e0       	breq	80003a40 <xcmp_rx_process+0x70>
80003a06:	e0 89 00 07 	brgt	80003a14 <xcmp_rx_process+0x44>
80003a0a:	58 e8       	cp.w	r8,14
80003a0c:	c0 e0       	breq	80003a28 <xcmp_rx_process+0x58>
80003a0e:	58 f8       	cp.w	r8,15
80003a10:	c2 41       	brne	80003a58 <xcmp_rx_process+0x88>
80003a12:	c0 f8       	rjmp	80003a30 <xcmp_rx_process+0x60>
80003a14:	e0 48 01 09 	cp.w	r8,265
80003a18:	c1 80       	breq	80003a48 <xcmp_rx_process+0x78>
80003a1a:	e0 48 01 0a 	cp.w	r8,266
80003a1e:	c1 90       	breq	80003a50 <xcmp_rx_process+0x80>
80003a20:	e0 48 00 2c 	cp.w	r8,44
80003a24:	c1 a1       	brne	80003a58 <xcmp_rx_process+0x88>
80003a26:	c0 98       	rjmp	80003a38 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80003a28:	4a 2c       	lddpc	r12,80003ab0 <xcmp_rx_process+0xe0>
80003a2a:	f0 1f 00 23 	mcall	80003ab4 <xcmp_rx_process+0xe4>
					break;
80003a2e:	c2 f8       	rjmp	80003a8c <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80003a30:	4a 2c       	lddpc	r12,80003ab8 <xcmp_rx_process+0xe8>
80003a32:	f0 1f 00 21 	mcall	80003ab4 <xcmp_rx_process+0xe4>
					break;
80003a36:	c2 b8       	rjmp	80003a8c <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80003a38:	4a 1c       	lddpc	r12,80003abc <xcmp_rx_process+0xec>
80003a3a:	f0 1f 00 1f 	mcall	80003ab4 <xcmp_rx_process+0xe4>
					break;
80003a3e:	c2 78       	rjmp	80003a8c <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003a40:	04 9c       	mov	r12,r2
80003a42:	f0 1f 00 1d 	mcall	80003ab4 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80003a46:	c2 38       	rjmp	80003a8c <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003a48:	02 9c       	mov	r12,r1
80003a4a:	f0 1f 00 1b 	mcall	80003ab4 <xcmp_rx_process+0xe4>
					break;
80003a4e:	c1 f8       	rjmp	80003a8c <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003a50:	00 9c       	mov	r12,r0
80003a52:	f0 1f 00 19 	mcall	80003ab4 <xcmp_rx_process+0xe4>
					break;
80003a56:	c1 b8       	rjmp	80003a8c <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80003a58:	12 98       	mov	r8,r9
80003a5a:	e2 18 04 00 	andl	r8,0x400,COH
80003a5e:	c0 70       	breq	80003a6c <xcmp_rx_process+0x9c>
80003a60:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80003a64:	e0 48 00 68 	cp.w	r8,104
80003a68:	e0 8a 00 08 	brle	80003a78 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80003a6c:	e2 19 f0 00 	andl	r9,0xf000,COH
80003a70:	c0 e1       	brne	80003a8c <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
80003a72:	f0 1f 00 14 	mcall	80003ac0 <xcmp_rx_process+0xf0>
80003a76:	c0 b8       	rjmp	80003a8c <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80003a78:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80003a7c:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
80003a80:	49 19       	lddpc	r9,80003ac4 <xcmp_rx_process+0xf4>
80003a82:	72 08       	ld.w	r8,r9[0x0]
80003a84:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80003a88:	f0 1f 00 0b 	mcall	80003ab4 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003a8c:	66 0c       	ld.w	r12,r3[0x0]
80003a8e:	40 0b       	lddsp	r11,sp[0x0]
80003a90:	f0 1f 00 0e 	mcall	80003ac8 <xcmp_rx_process+0xf8>
80003a94:	ca 7b       	rjmp	800039e2 <xcmp_rx_process+0x12>
80003a96:	00 00       	add	r0,r0
80003a98:	00 00       	add	r0,r0
80003a9a:	0a f8       	st.b	--r5,r8
80003a9c:	00 00       	add	r0,r0
80003a9e:	0a 9c       	mov	r12,r5
80003aa0:	00 00       	add	r0,r0
80003aa2:	0b 08       	ld.w	r8,r5++
80003aa4:	00 00       	add	r0,r0
80003aa6:	0a fc       	st.b	--r5,r12
80003aa8:	00 00       	add	r0,r0
80003aaa:	0b 14       	ld.sh	r4,r5++
80003aac:	80 00       	ld.sh	r0,r0[0x0]
80003aae:	4d 4c       	lddpc	r12,80003bfc <xnl_tx_process+0xac>
80003ab0:	00 00       	add	r0,r0
80003ab2:	0b 2c       	ld.uh	r12,r5++
80003ab4:	80 00       	ld.sh	r0,r0[0x0]
80003ab6:	38 d4       	mov	r4,-115
80003ab8:	00 00       	add	r0,r0
80003aba:	0a ec       	st.h	--r5,r12
80003abc:	00 00       	add	r0,r0
80003abe:	0b 20       	ld.uh	r0,r5++
80003ac0:	80 00       	ld.sh	r0,r0[0x0]
80003ac2:	38 b0       	mov	r0,-117
80003ac4:	00 00       	add	r0,r0
80003ac6:	3f f8       	mov	r8,-1
80003ac8:	80 00       	ld.sh	r0,r0[0x0]
80003aca:	29 b0       	sub	r0,-101

80003acc <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80003acc:	eb cd 40 90 	pushm	r4,r7,lr
80003ad0:	20 1d       	sub	sp,4
80003ad2:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80003ad6:	48 c8       	lddpc	r8,80003b04 <xcmp_rx+0x38>
80003ad8:	70 0c       	ld.w	r12,r8[0x0]
80003ada:	f0 1f 00 0c 	mcall	80003b08 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
80003ade:	c1 00       	breq	80003afe <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80003ae0:	fa c7 ff fc 	sub	r7,sp,-4
80003ae4:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80003ae6:	e0 6a 00 ca 	mov	r10,202
80003aea:	08 9b       	mov	r11,r4
80003aec:	f0 1f 00 08 	mcall	80003b0c <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
80003af0:	48 88       	lddpc	r8,80003b10 <xcmp_rx+0x44>
80003af2:	70 0c       	ld.w	r12,r8[0x0]
80003af4:	30 09       	mov	r9,0
80003af6:	12 9a       	mov	r10,r9
80003af8:	1a 9b       	mov	r11,sp
80003afa:	f0 1f 00 07 	mcall	80003b14 <xcmp_rx+0x48>
	}	
}
80003afe:	2f fd       	sub	sp,-4
80003b00:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80003b04:	00 00       	add	r0,r0
80003b06:	0a 9c       	mov	r12,r5
80003b08:	80 00       	ld.sh	r0,r0[0x0]
80003b0a:	2e b0       	sub	r0,-21
80003b0c:	80 00       	ld.sh	r0,r0[0x0]
80003b0e:	64 a8       	ld.w	r8,r2[0x28]
80003b10:	00 00       	add	r0,r0
80003b12:	0a f8       	st.b	--r5,r8
80003b14:	80 00       	ld.sh	r0,r0[0x0]
80003b16:	4f 58       	lddpc	r8,80003ce8 <xnl_tx+0x70>

80003b18 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80003b18:	48 28       	lddpc	r8,80003b20 <xnl_register_xcmp_func+0x8>
80003b1a:	91 0c       	st.w	r8[0x0],r12
}
80003b1c:	5e fc       	retal	r12
80003b1e:	00 00       	add	r0,r0
80003b20:	00 00       	add	r0,r0
80003b22:	0b 5c       	ld.sh	r12,--r5

80003b24 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80003b24:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80003b26:	48 88       	lddpc	r8,80003b44 <xnl_get_msg_ack_func+0x20>
80003b28:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80003b2a:	98 49       	ld.sh	r9,r12[0x8]
80003b2c:	f0 09 19 00 	cp.h	r9,r8
80003b30:	c0 81       	brne	80003b40 <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
80003b32:	48 68       	lddpc	r8,80003b48 <xnl_get_msg_ack_func+0x24>
80003b34:	70 0c       	ld.w	r12,r8[0x0]
80003b36:	30 09       	mov	r9,0
80003b38:	12 9a       	mov	r10,r9
80003b3a:	12 9b       	mov	r11,r9
80003b3c:	f0 1f 00 04 	mcall	80003b4c <xnl_get_msg_ack_func+0x28>
80003b40:	d8 02       	popm	pc
80003b42:	00 00       	add	r0,r0
80003b44:	00 00       	add	r0,r0
80003b46:	0b 3c       	ld.ub	r12,r5++
80003b48:	00 00       	add	r0,r0
80003b4a:	0b 38       	ld.ub	r8,r5++
80003b4c:	80 00       	ld.sh	r0,r0[0x0]
80003b4e:	4f 58       	lddpc	r8,80003d20 <xnl_tx+0xa8>

80003b50 <xnl_tx_process>:
	xSemaphoreTake--freertos 
	phy_tx -- physical.c
Called By: task
*/
static void xnl_tx_process(void * pvParameters)
{
80003b50:	d4 31       	pushm	r0-r7,lr
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80003b52:	4a 86       	lddpc	r6,80003bf0 <xnl_tx_process+0xa0>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80003b54:	4a 82       	lddpc	r2,80003bf4 <xnl_tx_process+0xa4>
80003b56:	4a 94       	lddpc	r4,80003bf8 <xnl_tx_process+0xa8>
80003b58:	30 07       	mov	r7,0
80003b5a:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80003b5c:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80003b5e:	4a 85       	lddpc	r5,80003bfc <xnl_tx_process+0xac>
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80003b60:	4a 83       	lddpc	r3,80003c00 <xnl_tx_process+0xb0>
	static  xnl_fragment_t * ptr;//是否可以修缮为静态变量？请关注
	
	
	for(;;)
	{		
		switch(xnl_tx_state)
80003b62:	6c 08       	ld.w	r8,r6[0x0]
80003b64:	58 08       	cp.w	r8,0
80003b66:	c0 40       	breq	80003b6e <xnl_tx_process+0x1e>
80003b68:	58 18       	cp.w	r8,1
80003b6a:	cf d1       	brne	80003b64 <xnl_tx_process+0x14>
80003b6c:	c2 08       	rjmp	80003bac <xnl_tx_process+0x5c>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80003b6e:	64 0c       	ld.w	r12,r2[0x0]
80003b70:	0e 99       	mov	r9,r7
80003b72:	02 9a       	mov	r10,r1
80003b74:	08 9b       	mov	r11,r4
80003b76:	f0 1f 00 24 	mcall	80003c04 <xnl_tx_process+0xb4>
80003b7a:	58 1c       	cp.w	r12,1
80003b7c:	cf 31       	brne	80003b62 <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80003b7e:	68 0c       	ld.w	r12,r4[0x0]
80003b80:	58 0c       	cp.w	r12,0
80003b82:	cf 00       	breq	80003b62 <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80003b84:	98 28       	ld.sh	r8,r12[0x4]
80003b86:	e0 08 19 00 	cp.h	r8,r0
80003b8a:	c0 41       	brne	80003b92 <xnl_tx_process+0x42>
					{
						/*invalid XNL opcode*/
						vPortFree(ptr);
80003b8c:	f0 1f 00 1f 	mcall	80003c08 <xnl_tx_process+0xb8>
						break;
80003b90:	ce 9b       	rjmp	80003b62 <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80003b92:	f0 1f 00 1f 	mcall	80003c0c <xnl_tx_process+0xbc>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;
80003b96:	30 18       	mov	r8,1
80003b98:	8b 08       	st.w	r5[0x0],r8
					
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80003b9a:	66 0c       	ld.w	r12,r3[0x0]
80003b9c:	0e 99       	mov	r9,r7
80003b9e:	0e 9a       	mov	r10,r7
80003ba0:	0e 9b       	mov	r11,r7
80003ba2:	f0 1f 00 19 	mcall	80003c04 <xnl_tx_process+0xb4>
					xnl_tx_state = WAITING_FOR_REPLY;
80003ba6:	30 18       	mov	r8,1
80003ba8:	8d 08       	st.w	r6[0x0],r8
80003baa:	cd cb       	rjmp	80003b62 <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
80003bac:	66 0c       	ld.w	r12,r3[0x0]
80003bae:	0e 99       	mov	r9,r7
80003bb0:	36 4a       	mov	r10,100
80003bb2:	0e 9b       	mov	r11,r7
80003bb4:	f0 1f 00 14 	mcall	80003c04 <xnl_tx_process+0xb4>
80003bb8:	58 1c       	cp.w	r12,1
80003bba:	c0 81       	brne	80003bca <xnl_tx_process+0x7a>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					//vPortFree(ptr);	
					set_xnl_idle(ptr);			
80003bbc:	49 58       	lddpc	r8,80003c10 <xnl_tx_process+0xc0>
80003bbe:	70 0c       	ld.w	r12,r8[0x0]
80003bc0:	68 0b       	ld.w	r11,r4[0x0]
80003bc2:	f0 1f 00 15 	mcall	80003c14 <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
80003bc6:	8d 07       	st.w	r6[0x0],r7
80003bc8:	cc db       	rjmp	80003b62 <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
80003bca:	6a 08       	ld.w	r8,r5[0x0]
80003bcc:	58 38       	cp.w	r8,3
80003bce:	e0 89 00 09 	brgt	80003be0 <xnl_tx_process+0x90>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80003bd2:	68 0c       	ld.w	r12,r4[0x0]
80003bd4:	f0 1f 00 0e 	mcall	80003c0c <xnl_tx_process+0xbc>
						xnl_send_times++;
80003bd8:	6a 08       	ld.w	r8,r5[0x0]
80003bda:	2f f8       	sub	r8,-1
80003bdc:	8b 08       	st.w	r5[0x0],r8
80003bde:	cc 2b       	rjmp	80003b62 <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80003be0:	48 c8       	lddpc	r8,80003c10 <xnl_tx_process+0xc0>
80003be2:	70 0c       	ld.w	r12,r8[0x0]
80003be4:	68 0b       	ld.w	r11,r4[0x0]
80003be6:	f0 1f 00 0c 	mcall	80003c14 <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
80003bea:	8d 07       	st.w	r6[0x0],r7
80003bec:	cb bb       	rjmp	80003b62 <xnl_tx_process+0x12>
80003bee:	00 00       	add	r0,r0
80003bf0:	00 00       	add	r0,r0
80003bf2:	0b 58       	ld.sh	r8,--r5
80003bf4:	00 00       	add	r0,r0
80003bf6:	0b 4c       	ld.w	r12,--r5
80003bf8:	00 00       	add	r0,r0
80003bfa:	0b 50       	ld.sh	r0,--r5
80003bfc:	00 00       	add	r0,r0
80003bfe:	0b 48       	ld.w	r8,--r5
80003c00:	00 00       	add	r0,r0
80003c02:	0b 38       	ld.ub	r8,r5++
80003c04:	80 00       	ld.sh	r0,r0[0x0]
80003c06:	4d 4c       	lddpc	r12,80003d54 <xnl_tx+0xdc>
80003c08:	80 00       	ld.sh	r0,r0[0x0]
80003c0a:	4b dc       	lddpc	r12,80003cfc <xnl_tx+0x84>
80003c0c:	80 00       	ld.sh	r0,r0[0x0]
80003c0e:	29 d0       	sub	r0,-99
80003c10:	00 00       	add	r0,r0
80003c12:	0a 9c       	mov	r12,r5
80003c14:	80 00       	ld.sh	r0,r0[0x0]
80003c16:	29 b0       	sub	r0,-101

80003c18 <xnl_rx_process>:
Description: Receive the XNL
Calls: 
Called By:task
*/
static void xnl_rx_process(void * pvParameters)
{
80003c18:	eb cd 40 fe 	pushm	r1-r7,lr
80003c1c:	20 1d       	sub	sp,4
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80003c1e:	49 26       	lddpc	r6,80003c64 <xnl_rx_process+0x4c>
80003c20:	30 05       	mov	r5,0
80003c22:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80003c24:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80003c26:	49 11       	lddpc	r1,80003c68 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80003c28:	49 12       	lddpc	r2,80003c6c <xnl_rx_process+0x54>
	/*To ptr the elements in the queue*/
	xnl_fragment_t * xnl_ptr;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
80003c2a:	6c 0c       	ld.w	r12,r6[0x0]
80003c2c:	0a 99       	mov	r9,r5
80003c2e:	08 9a       	mov	r10,r4
80003c30:	1a 9b       	mov	r11,sp
80003c32:	f0 1f 00 10 	mcall	80003c70 <xnl_rx_process+0x58>
80003c36:	58 1c       	cp.w	r12,1
80003c38:	cf 91       	brne	80003c2a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
80003c3a:	40 0c       	lddsp	r12,sp[0x0]
80003c3c:	58 0c       	cp.w	r12,0
80003c3e:	cf 60       	breq	80003c2a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80003c40:	98 28       	ld.sh	r8,r12[0x4]
80003c42:	e6 08 19 00 	cp.h	r8,r3
80003c46:	e0 8b 00 0a 	brhi	80003c5a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80003c4a:	5c 78       	castu.h	r8
80003c4c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80003c50:	58 09       	cp.w	r9,0
80003c52:	c0 40       	breq	80003c5a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80003c54:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80003c58:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80003c5a:	62 0c       	ld.w	r12,r1[0x0]
80003c5c:	40 0b       	lddsp	r11,sp[0x0]
80003c5e:	f0 1f 00 06 	mcall	80003c74 <xnl_rx_process+0x5c>
80003c62:	ce 4b       	rjmp	80003c2a <xnl_rx_process+0x12>
80003c64:	00 00       	add	r0,r0
80003c66:	0a b8       	st.h	r5++,r8
80003c68:	00 00       	add	r0,r0
80003c6a:	0a 9c       	mov	r12,r5
80003c6c:	00 00       	add	r0,r0
80003c6e:	04 fc       	st.b	--r2,r12
80003c70:	80 00       	ld.sh	r0,r0[0x0]
80003c72:	4d 4c       	lddpc	r12,80003dc0 <xnl_init+0x64>
80003c74:	80 00       	ld.sh	r0,r0[0x0]
80003c76:	29 b0       	sub	r0,-101

80003c78 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80003c78:	eb cd 40 c0 	pushm	r6-r7,lr
80003c7c:	20 1d       	sub	sp,4
80003c7e:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
80003c80:	98 39       	ld.sh	r9,r12[0x6]
80003c82:	3f f8       	mov	r8,-1
80003c84:	f0 09 19 00 	cp.h	r9,r8
80003c88:	c0 a1       	brne	80003c9c <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80003c8a:	4a e9       	lddpc	r9,80003d40 <xnl_tx+0xc8>
80003c8c:	13 88       	ld.ub	r8,r9[0x0]
80003c8e:	2f f8       	sub	r8,-1
80003c90:	5c 58       	castu.b	r8
80003c92:	b2 88       	st.b	r9[0x0],r8
80003c94:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003c98:	a9 a8       	sbr	r8,0x8
80003c9a:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80003c9c:	8c 49       	ld.sh	r9,r6[0x8]
80003c9e:	3f f8       	mov	r8,-1
80003ca0:	f0 09 19 00 	cp.h	r9,r8
80003ca4:	c0 41       	brne	80003cac <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80003ca6:	4a 88       	lddpc	r8,80003d44 <xnl_tx+0xcc>
80003ca8:	90 18       	ld.sh	r8,r8[0x2]
80003caa:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80003cac:	8c 59       	ld.sh	r9,r6[0xa]
80003cae:	3f f8       	mov	r8,-1
80003cb0:	f0 09 19 00 	cp.h	r9,r8
80003cb4:	c0 41       	brne	80003cbc <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80003cb6:	4a 48       	lddpc	r8,80003d44 <xnl_tx+0xcc>
80003cb8:	90 28       	ld.sh	r8,r8[0x4]
80003cba:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80003cbc:	8c 69       	ld.sh	r9,r6[0xc]
80003cbe:	3f f8       	mov	r8,-1
80003cc0:	f0 09 19 00 	cp.h	r9,r8
80003cc4:	c0 e1       	brne	80003ce0 <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80003cc6:	4a 08       	lddpc	r8,80003d44 <xnl_tx+0xcc>
80003cc8:	90 49       	ld.sh	r9,r8[0x8]
80003cca:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80003ccc:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
80003cce:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80003cd0:	90 49       	ld.sh	r9,r8[0x8]
80003cd2:	e0 19 ff 00 	andl	r9,0xff00
80003cd6:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80003cda:	f3 e8 10 08 	or	r8,r9,r8
80003cde:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
80003ce0:	0d 98       	ld.ub	r8,r6[0x1]
80003ce2:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80003ce4:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80003ce8:	10 0c       	add	r12,r8
80003cea:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80003cec:	58 0c       	cp.w	r12,0
80003cee:	e0 89 00 04 	brgt	80003cf6 <xnl_tx+0x7e>
80003cf2:	30 09       	mov	r9,0
80003cf4:	c0 d8       	rjmp	80003d0e <xnl_tx+0x96>
80003cf6:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80003cfa:	2f ec       	sub	r12,-2
80003cfc:	30 09       	mov	r9,0
80003cfe:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
80003d00:	15 1b       	ld.sh	r11,r10++
80003d02:	f6 09 00 09 	add	r9,r11,r9
80003d06:	5c 89       	casts.h	r9
		indextohWord     += 1;
80003d08:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80003d0a:	18 38       	cp.w	r8,r12
80003d0c:	cf a1       	brne	80003d00 <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
80003d0e:	5c 39       	neg	r9
80003d10:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80003d12:	48 e8       	lddpc	r8,80003d48 <xnl_tx+0xd0>
80003d14:	70 0c       	ld.w	r12,r8[0x0]
80003d16:	f0 1f 00 0e 	mcall	80003d4c <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80003d1a:	c1 00       	breq	80003d3a <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80003d1c:	fa c7 ff fc 	sub	r7,sp,-4
80003d20:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
80003d22:	e0 6a 01 00 	mov	r10,256
80003d26:	0c 9b       	mov	r11,r6
80003d28:	f0 1f 00 0a 	mcall	80003d50 <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80003d2c:	48 a8       	lddpc	r8,80003d54 <xnl_tx+0xdc>
80003d2e:	70 0c       	ld.w	r12,r8[0x0]
80003d30:	30 09       	mov	r9,0
80003d32:	12 9a       	mov	r10,r9
80003d34:	1a 9b       	mov	r11,sp
80003d36:	f0 1f 00 09 	mcall	80003d58 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80003d3a:	2f fd       	sub	sp,-4
80003d3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003d40:	00 00       	add	r0,r0
80003d42:	0b 54       	ld.sh	r4,--r5
80003d44:	00 00       	add	r0,r0
80003d46:	0b 3c       	ld.ub	r12,r5++
80003d48:	00 00       	add	r0,r0
80003d4a:	0a 9c       	mov	r12,r5
80003d4c:	80 00       	ld.sh	r0,r0[0x0]
80003d4e:	2e b0       	sub	r0,-21
80003d50:	80 00       	ld.sh	r0,r0[0x0]
80003d52:	64 a8       	ld.w	r8,r2[0x28]
80003d54:	00 00       	add	r0,r0
80003d56:	0b 4c       	ld.w	r12,--r5
80003d58:	80 00       	ld.sh	r0,r0[0x0]
80003d5a:	4f 58       	lddpc	r8,80003f2c <xnl_device_auth_reply_func+0x9c>

80003d5c <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
80003d5c:	eb cd 40 80 	pushm	r7,lr
80003d60:	fa cd 01 00 	sub	sp,sp,256
	/*initialize the physical layer*/
	phy_init();
80003d64:	f0 1f 00 27 	mcall	80003e00 <xnl_init+0xa4>
	
	xnl_information.is_connected = FALSE;
80003d68:	30 09       	mov	r9,0
80003d6a:	4a 78       	lddpc	r8,80003e04 <xnl_init+0xa8>
80003d6c:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
80003d6e:	30 0b       	mov	r11,0
80003d70:	30 1c       	mov	r12,1
80003d72:	f0 1f 00 26 	mcall	80003e08 <xnl_init+0xac>
80003d76:	4a 68       	lddpc	r8,80003e0c <xnl_init+0xb0>
80003d78:	91 0c       	st.w	r8[0x0],r12
80003d7a:	70 08       	ld.w	r8,r8[0x0]
80003d7c:	58 08       	cp.w	r8,0
80003d7e:	c0 80       	breq	80003d8e <xnl_init+0x32>
80003d80:	4a 38       	lddpc	r8,80003e0c <xnl_init+0xb0>
80003d82:	70 0c       	ld.w	r12,r8[0x0]
80003d84:	30 09       	mov	r9,0
80003d86:	12 9a       	mov	r10,r9
80003d88:	12 9b       	mov	r11,r9
80003d8a:	f0 1f 00 22 	mcall	80003e10 <xnl_init+0xb4>
	//xnl_frame_tx = xQueueCreate(10, sizeof(xnl_fragment_t *)); 
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80003d8e:	30 4b       	mov	r11,4
80003d90:	31 4c       	mov	r12,20
80003d92:	f0 1f 00 1e 	mcall	80003e08 <xnl_init+0xac>
80003d96:	4a 08       	lddpc	r8,80003e14 <xnl_init+0xb8>
80003d98:	91 0c       	st.w	r8[0x0],r12
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80003d9a:	30 07       	mov	r7,0
80003d9c:	1a d7       	st.w	--sp,r7
80003d9e:	1a d7       	st.w	--sp,r7
80003da0:	1a d7       	st.w	--sp,r7
80003da2:	30 38       	mov	r8,3
80003da4:	0e 99       	mov	r9,r7
80003da6:	e0 6a 02 00 	mov	r10,512
80003daa:	49 cb       	lddpc	r11,80003e18 <xnl_init+0xbc>
80003dac:	49 cc       	lddpc	r12,80003e1c <xnl_init+0xc0>
80003dae:	f0 1f 00 1d 	mcall	80003e20 <xnl_init+0xc4>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
80003db2:	1a d7       	st.w	--sp,r7
80003db4:	1a d7       	st.w	--sp,r7
80003db6:	1a d7       	st.w	--sp,r7
80003db8:	30 38       	mov	r8,3
80003dba:	0e 99       	mov	r9,r7
80003dbc:	e0 6a 03 20 	mov	r10,800
80003dc0:	49 9b       	lddpc	r11,80003e24 <xnl_init+0xc8>
80003dc2:	49 ac       	lddpc	r12,80003e28 <xnl_init+0xcc>
80003dc4:	f0 1f 00 17 	mcall	80003e20 <xnl_init+0xc4>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80003dc8:	e0 68 40 0e 	mov	r8,16398
80003dcc:	fb 58 00 18 	st.h	sp[24],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80003dd0:	3f f8       	mov	r8,-1
80003dd2:	fb 58 00 1a 	st.h	sp[26],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80003dd6:	30 38       	mov	r8,3
80003dd8:	fb 58 00 1c 	st.h	sp[28],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80003ddc:	fb 57 00 1e 	st.h	sp[30],r7
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80003de0:	fb 57 00 20 	st.h	sp[32],r7
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80003de4:	fb 57 00 22 	st.h	sp[34],r7
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80003de8:	fb 57 00 24 	st.h	sp[36],r7
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80003dec:	fb 57 00 26 	st.h	sp[38],r7

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80003df0:	fa cc ff e8 	sub	r12,sp,-24
80003df4:	f0 1f 00 0e 	mcall	80003e2c <xnl_init+0xd0>
80003df8:	2f ad       	sub	sp,-24
	,  NULL
	);
	
	/*send device_master_query to connect radio*/	
	xnl_send_device_master_query();
}
80003dfa:	2c 0d       	sub	sp,-256
80003dfc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e00:	80 00       	ld.sh	r0,r0[0x0]
80003e02:	2e d8       	sub	r8,-19
80003e04:	00 00       	add	r0,r0
80003e06:	0b 3c       	ld.ub	r12,r5++
80003e08:	80 00       	ld.sh	r0,r0[0x0]
80003e0a:	50 b0       	stdsp	sp[0x2c],r0
80003e0c:	00 00       	add	r0,r0
80003e0e:	0b 38       	ld.ub	r8,r5++
80003e10:	80 00       	ld.sh	r0,r0[0x0]
80003e12:	4f 58       	lddpc	r8,80003fe4 <xnl_master_status_brdcst_func+0x34>
80003e14:	00 00       	add	r0,r0
80003e16:	0b 4c       	ld.w	r12,--r5
80003e18:	80 00       	ld.sh	r0,r0[0x0]
80003e1a:	c4 44       	brge	80003ea2 <xnl_device_auth_reply_func+0x12>
80003e1c:	80 00       	ld.sh	r0,r0[0x0]
80003e1e:	3c 18       	mov	r8,-63
80003e20:	80 00       	ld.sh	r0,r0[0x0]
80003e22:	57 84       	stdsp	sp[0x1e0],r4
80003e24:	80 00       	ld.sh	r0,r0[0x0]
80003e26:	bc 00       	st.h	lr[0x0],r0
80003e28:	80 00       	ld.sh	r0,r0[0x0]
80003e2a:	3b 50       	mov	r0,-75
80003e2c:	80 00       	ld.sh	r0,r0[0x0]
80003e2e:	3c 78       	mov	r8,-57

80003e30 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80003e30:	eb cd 40 80 	pushm	r7,lr
80003e34:	fa cd 01 00 	sub	sp,sp,256
80003e38:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80003e3a:	e0 68 40 0e 	mov	r8,16398
80003e3e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80003e40:	3f f8       	mov	r8,-1
80003e42:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
80003e44:	30 c8       	mov	r8,12
80003e46:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80003e48:	98 38       	ld.sh	r8,r12[0x6]
80003e4a:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80003e4c:	98 58       	ld.sh	r8,r12[0xa]
80003e4e:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80003e50:	98 48       	ld.sh	r8,r12[0x8]
80003e52:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
80003e54:	98 68       	ld.sh	r8,r12[0xc]
80003e56:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80003e58:	30 08       	mov	r8,0
80003e5a:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80003e5c:	1a 9c       	mov	r12,sp
80003e5e:	f0 1f 00 0a 	mcall	80003e84 <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
80003e62:	fa cd 00 cc 	sub	sp,sp,204
80003e66:	e0 6a 00 ca 	mov	r10,202
80003e6a:	ee cb ff f0 	sub	r11,r7,-16
80003e6e:	1a 9c       	mov	r12,sp
80003e70:	f0 1f 00 06 	mcall	80003e88 <xnl_data_msg_func+0x58>
80003e74:	48 68       	lddpc	r8,80003e8c <xnl_data_msg_func+0x5c>
80003e76:	70 08       	ld.w	r8,r8[0x0]
80003e78:	5d 18       	icall	r8
80003e7a:	fa cd ff 34 	sub	sp,sp,-204
}
80003e7e:	2c 0d       	sub	sp,-256
80003e80:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e84:	80 00       	ld.sh	r0,r0[0x0]
80003e86:	3c 78       	mov	r8,-57
80003e88:	80 00       	ld.sh	r0,r0[0x0]
80003e8a:	64 a8       	ld.w	r8,r2[0x28]
80003e8c:	00 00       	add	r0,r0
80003e8e:	0b 5c       	ld.sh	r12,--r5

80003e90 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80003e90:	d4 21       	pushm	r4-r7,lr
80003e92:	fa cd 01 00 	sub	sp,sp,256
80003e96:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80003e98:	4c 28       	lddpc	r8,80003fa0 <xnl_device_auth_reply_func+0x110>
80003e9a:	11 88       	ld.ub	r8,r8[0x0]
80003e9c:	58 08       	cp.w	r8,0
80003e9e:	e0 81 00 7f 	brne	80003f9c <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
80003ea2:	4c 18       	lddpc	r8,80003fa4 <xnl_device_auth_reply_func+0x114>
80003ea4:	70 0c       	ld.w	r12,r8[0x0]
80003ea6:	30 09       	mov	r9,0
80003ea8:	12 9a       	mov	r10,r9
80003eaa:	12 9b       	mov	r11,r9
80003eac:	f0 1f 00 3f 	mcall	80003fa8 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80003eb0:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
80003eb4:	4b b8       	lddpc	r8,80003fa0 <xnl_device_auth_reply_func+0x110>
80003eb6:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80003eb8:	ef 39 00 12 	ld.ub	r9,r7[18]
80003ebc:	ef 38 00 13 	ld.ub	r8,r7[19]
80003ec0:	b1 68       	lsl	r8,0x10
80003ec2:	f1 e9 11 89 	or	r9,r8,r9<<0x18
80003ec6:	ef 38 00 15 	ld.ub	r8,r7[21]
80003eca:	f3 e8 10 08 	or	r8,r9,r8
80003ece:	ef 39 00 14 	ld.ub	r9,r7[20]
80003ed2:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
80003ed6:	ef 3a 00 16 	ld.ub	r10,r7[22]
80003eda:	ef 38 00 17 	ld.ub	r8,r7[23]
80003ede:	b1 68       	lsl	r8,0x10
80003ee0:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
80003ee4:	ef 38 00 19 	ld.ub	r8,r7[25]
80003ee8:	f5 e8 10 08 	or	r8,r10,r8
80003eec:	ef 3a 00 18 	ld.ub	r10,r7[24]
80003ef0:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80003ef4:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80003ef6:	e0 64 79 b9 	mov	r4,31161
80003efa:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80003efe:	e0 65 45 07 	mov	r5,17671
80003f02:	ea 15 8a bd 	orh	r5,0x8abd
80003f06:	e0 66 f9 3d 	mov	r6,63805
80003f0a:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80003f0e:	e0 6e b8 cf 	mov	lr,47311
80003f12:	ea 1e 36 83 	orh	lr,0x3683
80003f16:	e0 67 aa 1c 	mov	r7,43548
80003f1a:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80003f1e:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80003f20:	f4 08 00 0c 	add	r12,r10,r8
80003f24:	f0 0b 15 04 	lsl	r11,r8,0x4
80003f28:	0a 0b       	add	r11,r5
80003f2a:	f9 eb 20 0b 	eor	r11,r12,r11
80003f2e:	f0 0c 16 05 	lsr	r12,r8,0x5
80003f32:	0c 0c       	add	r12,r6
80003f34:	18 5b       	eor	r11,r12
80003f36:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80003f38:	f2 0c 15 04 	lsl	r12,r9,0x4
80003f3c:	1c 0c       	add	r12,lr
80003f3e:	f2 0b 16 05 	lsr	r11,r9,0x5
80003f42:	0e 0b       	add	r11,r7
80003f44:	f9 eb 20 0b 	eor	r11,r12,r11
80003f48:	f2 0a 00 0c 	add	r12,r9,r10
80003f4c:	18 5b       	eor	r11,r12
80003f4e:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80003f50:	e0 6b 37 20 	mov	r11,14112
80003f54:	ea 1b c6 ef 	orh	r11,0xc6ef
80003f58:	16 3a       	cp.w	r10,r11
80003f5a:	ce 21       	brne	80003f1e <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80003f5c:	e0 6a 40 1a 	mov	r10,16410
80003f60:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80003f62:	3f fa       	mov	r10,-1
80003f64:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80003f66:	30 6b       	mov	r11,6
80003f68:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80003f6a:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80003f6c:	48 db       	lddpc	r11,80003fa0 <xnl_device_auth_reply_func+0x110>
80003f6e:	96 1c       	ld.sh	r12,r11[0x2]
80003f70:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80003f72:	96 2b       	ld.sh	r11,r11[0x4]
80003f74:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003f76:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80003f78:	30 ca       	mov	r10,12
80003f7a:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80003f7c:	30 0a       	mov	r10,0
80003f7e:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80003f82:	30 7a       	mov	r10,7
80003f84:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80003f88:	30 2a       	mov	r10,2
80003f8a:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80003f8e:	fa ca ff ec 	sub	r10,sp,-20
80003f92:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80003f94:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80003f96:	1a 9c       	mov	r12,sp
80003f98:	f0 1f 00 05 	mcall	80003fac <xnl_device_auth_reply_func+0x11c>
}
80003f9c:	2c 0d       	sub	sp,-256
80003f9e:	d8 22       	popm	r4-r7,pc
80003fa0:	00 00       	add	r0,r0
80003fa2:	0b 3c       	ld.ub	r12,r5++
80003fa4:	00 00       	add	r0,r0
80003fa6:	0b 38       	ld.ub	r8,r5++
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	4f 58       	lddpc	r8,8000417c <local_start_timer+0x28>
80003fac:	80 00       	ld.sh	r0,r0[0x0]
80003fae:	3c 78       	mov	r8,-57

80003fb0 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80003fb0:	eb cd 40 80 	pushm	r7,lr
80003fb4:	fa cd 01 00 	sub	sp,sp,256
80003fb8:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80003fba:	49 28       	lddpc	r8,80004000 <xnl_master_status_brdcst_func+0x50>
80003fbc:	11 88       	ld.ub	r8,r8[0x0]
80003fbe:	58 08       	cp.w	r8,0
80003fc0:	c1 c1       	brne	80003ff8 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80003fc2:	49 18       	lddpc	r8,80004004 <xnl_master_status_brdcst_func+0x54>
80003fc4:	70 0c       	ld.w	r12,r8[0x0]
80003fc6:	30 09       	mov	r9,0
80003fc8:	12 9a       	mov	r10,r9
80003fca:	12 9b       	mov	r11,r9
80003fcc:	f0 1f 00 0f 	mcall	80004008 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80003fd0:	8e 58       	ld.sh	r8,r7[0xa]
80003fd2:	48 c9       	lddpc	r9,80004000 <xnl_master_status_brdcst_func+0x50>
80003fd4:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80003fd6:	e0 68 40 0e 	mov	r8,16398
80003fda:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80003fdc:	3f f8       	mov	r8,-1
80003fde:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80003fe0:	30 4a       	mov	r10,4
80003fe2:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80003fe4:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80003fe6:	92 19       	ld.sh	r9,r9[0x2]
80003fe8:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80003fea:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003fec:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80003fee:	30 08       	mov	r8,0
80003ff0:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80003ff2:	1a 9c       	mov	r12,sp
80003ff4:	f0 1f 00 06 	mcall	8000400c <xnl_master_status_brdcst_func+0x5c>
}
80003ff8:	2c 0d       	sub	sp,-256
80003ffa:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ffe:	00 00       	add	r0,r0
80004000:	00 00       	add	r0,r0
80004002:	0b 3c       	ld.ub	r12,r5++
80004004:	00 00       	add	r0,r0
80004006:	0b 38       	ld.ub	r8,r5++
80004008:	80 00       	ld.sh	r0,r0[0x0]
8000400a:	4f 58       	lddpc	r8,800041dc <tc_init+0x4c>
8000400c:	80 00       	ld.sh	r0,r0[0x0]
8000400e:	3c 78       	mov	r8,-57

80004010 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004010:	eb cd 40 80 	pushm	r7,lr
80004014:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004016:	49 38       	lddpc	r8,80004060 <xnl_device_conn_reply_func+0x50>
80004018:	70 0c       	ld.w	r12,r8[0x0]
8000401a:	30 09       	mov	r9,0
8000401c:	12 9a       	mov	r10,r9
8000401e:	12 9b       	mov	r11,r9
80004020:	f0 1f 00 11 	mcall	80004064 <xnl_device_conn_reply_func+0x54>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004024:	ef 18 00 10 	ld.uh	r8,r7[16]
80004028:	10 99       	mov	r9,r8
8000402a:	e2 19 ff 00 	andl	r9,0xff00,COH
8000402e:	e0 49 01 00 	cp.w	r9,256
80004032:	c0 60       	breq	8000403e <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004034:	0e 9c       	mov	r12,r7
80004036:	f0 1f 00 0d 	mcall	80004068 <xnl_device_conn_reply_func+0x58>
8000403a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
8000403e:	a9 68       	lsl	r8,0x8
80004040:	48 b9       	lddpc	r9,8000406c <xnl_device_conn_reply_func+0x5c>
80004042:	b2 48       	st.h	r9[0x8],r8
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004044:	ef 08 00 14 	ld.sh	r8,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004048:	b2 38       	st.h	r9[0x6],r8
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
8000404a:	ef 08 00 12 	ld.sh	r8,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000404e:	b2 28       	st.h	r9[0x4],r8
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004050:	30 18       	mov	r8,1
80004052:	b2 88       	st.b	r9[0x0],r8
		
		log("connected finish");
80004054:	48 7c       	lddpc	r12,80004070 <xnl_device_conn_reply_func+0x60>
80004056:	f0 1f 00 08 	mcall	80004074 <xnl_device_conn_reply_func+0x64>
8000405a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000405e:	00 00       	add	r0,r0
80004060:	00 00       	add	r0,r0
80004062:	0b 38       	ld.ub	r8,r5++
80004064:	80 00       	ld.sh	r0,r0[0x0]
80004066:	4f 58       	lddpc	r8,80004238 <INTC_register_interrupt+0x24>
80004068:	80 00       	ld.sh	r0,r0[0x0]
8000406a:	3f b0       	mov	r0,-5
8000406c:	00 00       	add	r0,r0
8000406e:	0b 3c       	ld.ub	r12,r5++
80004070:	80 00       	ld.sh	r0,r0[0x0]
80004072:	c4 4c       	rcall	800040fa <rtc_init+0x32>
80004074:	80 00       	ld.sh	r0,r0[0x0]
80004076:	5b 48       	cp.w	r8,-12

80004078 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80004078:	fe 78 0c 00 	mov	r8,-62464
8000407c:	e0 69 03 07 	mov	r9,775
80004080:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80004082:	30 49       	mov	r9,4
80004084:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80004086:	71 59       	ld.w	r9,r8[0x54]
80004088:	e2 19 00 80 	andl	r9,0x80,COH
8000408c:	cf d0       	breq	80004086 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000408e:	fe 78 0c 00 	mov	r8,-62464
80004092:	30 59       	mov	r9,5
80004094:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80004096:	e0 69 01 0d 	mov	r9,269
8000409a:	ea 19 10 07 	orh	r9,0x1007
8000409e:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800040a0:	71 59       	ld.w	r9,r8[0x54]
800040a2:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800040a6:	cf d0       	breq	800040a0 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
800040a8:	fe 78 0c 00 	mov	r8,-62464
800040ac:	fc 19 00 80 	movh	r9,0x80
800040b0:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
800040b2:	34 0a       	mov	r10,64
800040b4:	fe 69 14 00 	mov	r9,-125952
800040b8:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
800040ba:	30 69       	mov	r9,6
800040bc:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
800040be:	30 19       	mov	r9,1
800040c0:	fe 68 10 00 	mov	r8,-126976
800040c4:	91 19       	st.w	r8[0x4],r9
}
800040c6:	5e fc       	retal	r12

800040c8 <rtc_init>:
    PCF8563_init
Called By: ..
Return:rtc_err_t
*/
rtc_err_t rtc_init(void)
{
800040c8:	eb cd 40 c0 	pushm	r6-r7,lr
800040cc:	20 3d       	sub	sp,12
	/* Create the mutex semaphore to guard a shared RTC(TWI).*/	
	rtc_mutex = xSemaphoreCreateMutex();
800040ce:	f0 1f 00 1a 	mcall	80004134 <rtc_init+0x6c>
800040d2:	49 a8       	lddpc	r8,80004138 <rtc_init+0x70>
800040d4:	91 0c       	st.w	r8[0x0],r12
	
	if(NULL != rtc_mutex)
800040d6:	70 08       	ld.w	r8,r8[0x0]
800040d8:	58 08       	cp.w	r8,0
800040da:	c0 31       	brne	800040e0 <rtc_init+0x18>
800040dc:	30 3c       	mov	r12,3
800040de:	c2 78       	rjmp	8000412c <rtc_init+0x64>
	{
		/*See if we can obtain the semaphore. If the semaphore is not available wait aways to see if it becomes free*/
		xSemaphoreTake( rtc_mutex, portMAX_DELAY);
800040e0:	49 66       	lddpc	r6,80004138 <rtc_init+0x70>
800040e2:	6c 0c       	ld.w	r12,r6[0x0]
800040e4:	30 09       	mov	r9,0
800040e6:	3f fa       	mov	r10,-1
800040e8:	12 9b       	mov	r11,r9
800040ea:	f0 1f 00 15 	mcall	8000413c <rtc_init+0x74>
	
	/*twi_package_t packet, packet_received*/
	static int status;

	/*TWI gpio pins configuration*/	
	gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
800040ee:	30 2b       	mov	r11,2
800040f0:	49 4c       	lddpc	r12,80004140 <rtc_init+0x78>
800040f2:	f0 1f 00 15 	mcall	80004144 <rtc_init+0x7c>
	
	/* options settings*/
	opt.pba_hz = RTC_PBACLK_FREQ_HZ;//FOSC0;24Mhz
800040f6:	e0 68 36 00 	mov	r8,13824
800040fa:	ea 18 01 6e 	orh	r8,0x16e
800040fe:	50 08       	stdsp	sp[0x0],r8
	opt.speed  = TWI_SPEED;//200Khz
80004100:	e2 78 0d 40 	mov	r8,200000
80004104:	50 18       	stdsp	sp[0x4],r8
	opt.chip   = PCF8563_ADDRESS;
80004106:	35 18       	mov	r8,81
80004108:	fb 68 00 08 	st.b	sp[8],r8

	/*initialize TWI driver with options*/
	status = twi_master_init(&AVR32_TWI, &opt);
8000410c:	1a 9b       	mov	r11,sp
8000410e:	fe 7c 2c 00 	mov	r12,-54272
80004112:	f0 1f 00 0e 	mcall	80004148 <rtc_init+0x80>
80004116:	48 e7       	lddpc	r7,8000414c <rtc_init+0x84>
80004118:	8f 0c       	st.w	r7[0x0],r12
	
	/*finished accessing the shared resource.Release the semaphore.*/
	xSemaphoreGive(rtc_mutex);		
8000411a:	6c 0c       	ld.w	r12,r6[0x0]
8000411c:	30 09       	mov	r9,0
8000411e:	12 9a       	mov	r10,r9
80004120:	12 9b       	mov	r11,r9
80004122:	f0 1f 00 0c 	mcall	80004150 <rtc_init+0x88>
80004126:	6e 08       	ld.w	r8,r7[0x0]
80004128:	58 08       	cp.w	r8,0
8000412a:	5f 1c       	srne	r12
	{
		return rtc_success;
	}
		
	return rtc_init_err;
}
8000412c:	2f dd       	sub	sp,-12
8000412e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004132:	00 00       	add	r0,r0
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	50 58       	stdsp	sp[0x14],r8
80004138:	00 00       	add	r0,r0
8000413a:	0b 64       	ld.uh	r4,--r5
8000413c:	80 00       	ld.sh	r0,r0[0x0]
8000413e:	4d 4c       	lddpc	r12,8000428c <INTC_register_interrupt+0x78>
80004140:	80 00       	ld.sh	r0,r0[0x0]
80004142:	c4 60       	breq	800041ce <tc_init+0x3e>
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	5f e0       	srqs	r0
80004148:	80 00       	ld.sh	r0,r0[0x0]
8000414a:	45 d8       	lddsp	r8,sp[0x174]
8000414c:	00 00       	add	r0,r0
8000414e:	0b 60       	ld.uh	r0,--r5
80004150:	80 00       	ld.sh	r0,r0[0x0]
80004152:	4f 58       	lddpc	r8,80004324 <tc_init_waveform+0x4>

80004154 <local_start_timer>:
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	//Route CLK to Timer
	AVR32_GPIO.port[0].pmr0s = 0x00100000;
80004154:	fe 78 10 00 	mov	r8,-61440
80004158:	fc 19 00 10 	movh	r9,0x10
8000415c:	91 59       	st.w	r8[0x14],r9
	AVR32_GPIO.port[0].pmr1c = 0x00100000;
8000415e:	91 a9       	st.w	r8[0x28],r9
	AVR32_GPIO.port[0].gperc = 0x00100000;
80004160:	91 29       	st.w	r8[0x8],r9
	//Route FS and Tri-State to Timer.
	AVR32_GPIO.port[1].pmr0c = 0x00000003;
80004162:	30 39       	mov	r9,3
80004164:	f1 49 01 18 	st.w	r8[280],r9
	AVR32_GPIO.port[1].pmr1c = 0x00000003;
80004168:	f1 49 01 28 	st.w	r8[296],r9
	AVR32_GPIO.port[1].gperc = 0x00000003;
8000416c:	f1 49 01 08 	st.w	r8[264],r9

	(&AVR32_TC)->bmr = 4;
80004170:	fe 78 38 00 	mov	r8,-51200
80004174:	30 49       	mov	r9,4
80004176:	f1 49 00 c4 	st.w	r8[196],r9
	(&AVR32_TC)->channel[0].cmr =
8000417a:	e0 69 91 0d 	mov	r9,37133
8000417e:	ea 19 00 52 	orh	r9,0x52
80004182:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80004184:	32 09       	mov	r9,32
80004186:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80004188:	30 59       	mov	r9,5
8000418a:	91 09       	st.w	r8[0x0],r9
}
8000418c:	5e fc       	retal	r12
8000418e:	d7 03       	nop

80004190 <tc_init>:
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{
80004190:	d4 01       	pushm	lr

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);
80004192:	30 2a       	mov	r10,2
80004194:	e0 6b 01 c1 	mov	r11,449
80004198:	48 ec       	lddpc	r12,800041d0 <tc_init+0x40>
8000419a:	f0 1f 00 0f 	mcall	800041d4 <tc_init+0x44>
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);
8000419e:	48 fb       	lddpc	r11,800041d8 <tc_init+0x48>
800041a0:	fe 7c 38 00 	mov	r12,-51200
800041a4:	f0 1f 00 0e 	mcall	800041dc <tc_init+0x4c>
	 * We want: (1 / (fPBA / 8)) * RC = 10 ms, hence RC = (fPBA / 8) / 100
	 * to get an interrupt every 10 ms.
	 */
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (sysclk_get_pba_hz() / 8 / 100));
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2) / 8 / 100));
800041a8:	e0 6a 75 30 	mov	r10,30000
800041ac:	30 1b       	mov	r11,1
800041ae:	fe 7c 38 00 	mov	r12,-51200
800041b2:	f0 1f 00 0c 	mcall	800041e0 <tc_init+0x50>
	
	//tc_write_rc(tc, EXAMPLE_TC_CHANNEL, (FOSC0 / 8 / 100000));
	
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
800041b6:	48 ca       	lddpc	r10,800041e4 <tc_init+0x54>
800041b8:	30 1b       	mov	r11,1
800041ba:	fe 7c 38 00 	mov	r12,-51200
800041be:	f0 1f 00 0b 	mcall	800041e8 <tc_init+0x58>
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
800041c2:	30 1b       	mov	r11,1
800041c4:	fe 7c 38 00 	mov	r12,-51200
800041c8:	f0 1f 00 09 	mcall	800041ec <tc_init+0x5c>
800041cc:	d8 02       	popm	pc
800041ce:	00 00       	add	r0,r0
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	41 f0       	lddsp	r0,sp[0x7c]
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	42 14       	lddsp	r4,sp[0x84]
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	c4 74       	brge	80004268 <INTC_register_interrupt+0x54>
800041dc:	80 00       	ld.sh	r0,r0[0x0]
800041de:	43 20       	lddsp	r0,sp[0xc8]
800041e0:	80 00       	ld.sh	r0,r0[0x0]
800041e2:	43 e0       	lddsp	r0,sp[0xf8]
800041e4:	80 00       	ld.sh	r0,r0[0x0]
800041e6:	c4 70       	breq	80004274 <INTC_register_interrupt+0x60>
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	44 14       	lddsp	r4,sp[0x104]
800041ec:	80 00       	ld.sh	r0,r0[0x0]
800041ee:	43 bc       	lddsp	r12,sp[0xec]

800041f0 <_tc_interrupt>:
volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
800041f0:	d4 01       	pushm	lr
	// Increment the 10ms seconds counter
	tc_tick++;
800041f2:	48 68       	lddpc	r8,80004208 <_tc_interrupt+0x18>
800041f4:	70 09       	ld.w	r9,r8[0x0]
800041f6:	2f f9       	sub	r9,-1
800041f8:	91 09       	st.w	r8[0x0],r9
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
800041fa:	30 1b       	mov	r11,1
800041fc:	fe 7c 38 00 	mov	r12,-51200
80004200:	f0 1f 00 03 	mcall	8000420c <_tc_interrupt+0x1c>
	
}
80004204:	d4 02       	popm	lr
80004206:	d6 03       	rete
80004208:	00 00       	add	r0,r0
8000420a:	0b 68       	ld.uh	r8,--r5
8000420c:	80 00       	ld.sh	r0,r0[0x0]
8000420e:	43 ce       	lddsp	lr,sp[0xf0]

80004210 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80004210:	c0 08       	rjmp	80004210 <_unhandled_interrupt>
80004212:	d7 03       	nop

80004214 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004214:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004218:	49 99       	lddpc	r9,8000427c <INTC_register_interrupt+0x68>
8000421a:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000421e:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80004222:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004224:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004228:	58 0a       	cp.w	r10,0
8000422a:	c0 91       	brne	8000423c <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000422c:	49 59       	lddpc	r9,80004280 <INTC_register_interrupt+0x6c>
8000422e:	49 6a       	lddpc	r10,80004284 <INTC_register_interrupt+0x70>
80004230:	12 1a       	sub	r10,r9
80004232:	fe 79 08 00 	mov	r9,-63488
80004236:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000423a:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
8000423c:	58 1a       	cp.w	r10,1
8000423e:	c0 a1       	brne	80004252 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80004240:	49 09       	lddpc	r9,80004280 <INTC_register_interrupt+0x6c>
80004242:	49 2a       	lddpc	r10,80004288 <INTC_register_interrupt+0x74>
80004244:	12 1a       	sub	r10,r9
80004246:	bf aa       	sbr	r10,0x1e
80004248:	fe 79 08 00 	mov	r9,-63488
8000424c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004250:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80004252:	58 2a       	cp.w	r10,2
80004254:	c0 a1       	brne	80004268 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80004256:	48 b9       	lddpc	r9,80004280 <INTC_register_interrupt+0x6c>
80004258:	48 da       	lddpc	r10,8000428c <INTC_register_interrupt+0x78>
8000425a:	12 1a       	sub	r10,r9
8000425c:	bf ba       	sbr	r10,0x1f
8000425e:	fe 79 08 00 	mov	r9,-63488
80004262:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004266:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80004268:	48 69       	lddpc	r9,80004280 <INTC_register_interrupt+0x6c>
8000426a:	48 aa       	lddpc	r10,80004290 <INTC_register_interrupt+0x7c>
8000426c:	12 1a       	sub	r10,r9
8000426e:	ea 1a c0 00 	orh	r10,0xc000
80004272:	fe 79 08 00 	mov	r9,-63488
80004276:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000427a:	5e fc       	retal	r12
8000427c:	80 00       	ld.sh	r0,r0[0x0]
8000427e:	c4 7c       	rcall	8000430c <_get_interrupt_handler+0x24>
80004280:	80 00       	ld.sh	r0,r0[0x0]
80004282:	ba 00       	st.h	sp[0x0],r0
80004284:	80 00       	ld.sh	r0,r0[0x0]
80004286:	bb 04       	ld.d	r4,sp
80004288:	80 00       	ld.sh	r0,r0[0x0]
8000428a:	bb 12       	ld.d	r2,--sp
8000428c:	80 00       	ld.sh	r0,r0[0x0]
8000428e:	bb 20       	st.d	sp++,r0
80004290:	80 00       	ld.sh	r0,r0[0x0]
80004292:	bb 2e       	st.d	sp++,lr

80004294 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80004294:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80004296:	49 18       	lddpc	r8,800042d8 <INTC_init_interrupts+0x44>
80004298:	e3 b8 00 01 	mtsr	0x4,r8
8000429c:	49 0e       	lddpc	lr,800042dc <INTC_init_interrupts+0x48>
8000429e:	30 07       	mov	r7,0
800042a0:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800042a2:	49 0c       	lddpc	r12,800042e0 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800042a4:	49 05       	lddpc	r5,800042e4 <INTC_init_interrupts+0x50>
800042a6:	10 15       	sub	r5,r8
800042a8:	fe 76 08 00 	mov	r6,-63488
800042ac:	c1 08       	rjmp	800042cc <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800042ae:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800042b0:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800042b2:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800042b4:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800042b8:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800042ba:	10 3a       	cp.w	r10,r8
800042bc:	fe 9b ff fc 	brhi	800042b4 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800042c0:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800042c4:	2f f7       	sub	r7,-1
800042c6:	2f 8e       	sub	lr,-8
800042c8:	59 37       	cp.w	r7,19
800042ca:	c0 50       	breq	800042d4 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800042cc:	7c 08       	ld.w	r8,lr[0x0]
800042ce:	58 08       	cp.w	r8,0
800042d0:	ce f1       	brne	800042ae <INTC_init_interrupts+0x1a>
800042d2:	cf 7b       	rjmp	800042c0 <INTC_init_interrupts+0x2c>
800042d4:	d8 22       	popm	r4-r7,pc
800042d6:	00 00       	add	r0,r0
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	ba 00       	st.h	sp[0x0],r0
800042dc:	80 00       	ld.sh	r0,r0[0x0]
800042de:	c4 7c       	rcall	8000436c <tc_init_waveform+0x4c>
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	42 10       	lddsp	r0,sp[0x84]
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	bb 04       	ld.d	r4,sp

800042e8 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800042e8:	fe 78 08 00 	mov	r8,-63488
800042ec:	e0 69 00 83 	mov	r9,131
800042f0:	f2 0c 01 0c 	sub	r12,r9,r12
800042f4:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800042f8:	f2 ca ff c0 	sub	r10,r9,-64
800042fc:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004300:	58 08       	cp.w	r8,0
80004302:	c0 21       	brne	80004306 <_get_interrupt_handler+0x1e>
80004304:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004306:	f0 08 12 00 	clz	r8,r8
8000430a:	48 5a       	lddpc	r10,8000431c <_get_interrupt_handler+0x34>
8000430c:	f4 09 00 39 	add	r9,r10,r9<<0x3
80004310:	f0 08 11 1f 	rsub	r8,r8,31
80004314:	72 19       	ld.w	r9,r9[0x4]
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	
	return (int_req)
80004316:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000431a:	5e fc       	retal	r12
8000431c:	80 00       	ld.sh	r0,r0[0x0]
8000431e:	c4 7c       	rcall	800043ac <tc_init_waveform+0x8c>

80004320 <tc_init_waveform>:


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
80004320:	76 09       	ld.w	r9,r11[0x0]
80004322:	58 29       	cp.w	r9,2
80004324:	e0 88 00 03 	brls	8000432a <tc_init_waveform+0xa>
80004328:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
8000432a:	76 18       	ld.w	r8,r11[0x4]
8000432c:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80004330:	af ba       	sbr	r10,0xf
80004332:	10 9b       	mov	r11,r8
80004334:	e6 1b c0 00 	andh	r11,0xc000,COH
80004338:	16 4a       	or	r10,r11
8000433a:	10 9b       	mov	r11,r8
8000433c:	e6 1b 30 00 	andh	r11,0x3000,COH
80004340:	16 4a       	or	r10,r11
80004342:	10 9b       	mov	r11,r8
80004344:	e6 1b 0c 00 	andh	r11,0xc00,COH
80004348:	16 4a       	or	r10,r11
8000434a:	10 9b       	mov	r11,r8
8000434c:	e6 1b 03 00 	andh	r11,0x300,COH
80004350:	16 4a       	or	r10,r11
80004352:	10 9b       	mov	r11,r8
80004354:	e6 1b 00 c0 	andh	r11,0xc0,COH
80004358:	16 4a       	or	r10,r11
8000435a:	10 9b       	mov	r11,r8
8000435c:	e6 1b 00 30 	andh	r11,0x30,COH
80004360:	16 4a       	or	r10,r11
80004362:	10 9b       	mov	r11,r8
80004364:	e6 1b 00 0c 	andh	r11,0xc,COH
80004368:	16 4a       	or	r10,r11
8000436a:	10 9b       	mov	r11,r8
8000436c:	e6 1b 00 03 	andh	r11,0x3,COH
80004370:	16 4a       	or	r10,r11
80004372:	10 9b       	mov	r11,r8
80004374:	e2 1b 60 00 	andl	r11,0x6000,COH
80004378:	16 4a       	or	r10,r11
8000437a:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
8000437e:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
80004382:	10 9b       	mov	r11,r8
80004384:	e2 1b 0c 00 	andl	r11,0xc00,COH
80004388:	16 4a       	or	r10,r11
8000438a:	10 9b       	mov	r11,r8
8000438c:	e2 1b 03 00 	andl	r11,0x300,COH
80004390:	16 4a       	or	r10,r11
80004392:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
80004396:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
8000439a:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
8000439e:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
800043a2:	10 9b       	mov	r11,r8
800043a4:	e2 1b 00 30 	andl	r11,0x30,COH
800043a8:	16 4a       	or	r10,r11
800043aa:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800043ae:	f5 e8 10 38 	or	r8,r10,r8<<0x3
800043b2:	a5 69       	lsl	r9,0x4
800043b4:	2f f9       	sub	r9,-1
800043b6:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
800043ba:	5e fd       	retal	0

800043bc <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800043bc:	58 2b       	cp.w	r11,2
800043be:	e0 88 00 03 	brls	800043c4 <tc_start+0x8>
800043c2:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800043c4:	a7 6b       	lsl	r11,0x6
800043c6:	16 0c       	add	r12,r11
800043c8:	30 58       	mov	r8,5
800043ca:	99 08       	st.w	r12[0x0],r8
800043cc:	5e fd       	retal	0

800043ce <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800043ce:	58 2b       	cp.w	r11,2
800043d0:	e0 88 00 03 	brls	800043d6 <tc_read_sr+0x8>
800043d4:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
800043d6:	a7 6b       	lsl	r11,0x6
800043d8:	2e 0b       	sub	r11,-32
800043da:	16 0c       	add	r12,r11
800043dc:	78 0c       	ld.w	r12,r12[0x0]
}
800043de:	5e fc       	retal	r12

800043e0 <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800043e0:	58 2b       	cp.w	r11,2
800043e2:	e0 88 00 03 	brls	800043e8 <tc_write_rc+0x8>
800043e6:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
800043e8:	f6 08 15 04 	lsl	r8,r11,0x4
800043ec:	2f f8       	sub	r8,-1
800043ee:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
800043f2:	e2 18 80 00 	andl	r8,0x8000,COH
800043f6:	c0 c0       	breq	8000440e <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
800043f8:	a7 6b       	lsl	r11,0x6
800043fa:	16 0c       	add	r12,r11
800043fc:	2e 4c       	sub	r12,-28
800043fe:	78 08       	ld.w	r8,r12[0x0]
80004400:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80004404:	e0 18 00 00 	andl	r8,0x0
80004408:	f3 e8 10 08 	or	r8,r9,r8
8000440c:	99 08       	st.w	r12[0x0],r8

  return value;
8000440e:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
80004412:	5e fc       	retal	r12

80004414 <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
80004414:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80004418:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
8000441c:	58 2b       	cp.w	r11,2
8000441e:	e0 88 00 04 	brls	80004426 <tc_configure_interrupts+0x12>
80004422:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80004426:	ee 19 00 01 	eorh	r9,0x1
8000442a:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
8000442e:	74 08       	ld.w	r8,r10[0x0]
80004430:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
80004434:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80004438:	a7 6e       	lsl	lr,0x6
8000443a:	fd e7 10 7e 	or	lr,lr,r7<<0x7
8000443e:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
80004442:	0e 4e       	or	lr,r7
80004444:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80004448:	fd e7 10 5e 	or	lr,lr,r7<<0x5
8000444c:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
80004450:	fd e7 10 4e 	or	lr,lr,r7<<0x4
80004454:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80004458:	fd e7 10 3e 	or	lr,lr,r7<<0x3
8000445c:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
80004460:	fd e7 10 2e 	or	lr,lr,r7<<0x2
80004464:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80004468:	fd e8 10 18 	or	r8,lr,r8<<0x1
8000446c:	f6 0e 15 06 	lsl	lr,r11,0x6
80004470:	f8 0e 00 0e 	add	lr,r12,lr
80004474:	2d ce       	sub	lr,-36
80004476:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80004478:	58 09       	cp.w	r9,0
8000447a:	c0 20       	breq	8000447e <tc_configure_interrupts+0x6a>
8000447c:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
8000447e:	74 08       	ld.w	r8,r10[0x0]
80004480:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
80004484:	e0 65 00 80 	mov	r5,128
80004488:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
8000448c:	74 08       	ld.w	r8,r10[0x0]
8000448e:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
80004492:	f9 b4 00 40 	moveq	r4,64
80004496:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
8000449a:	74 08       	ld.w	r8,r10[0x0]
8000449c:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
800044a0:	f9 b3 00 20 	moveq	r3,32
800044a4:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
800044a8:	74 08       	ld.w	r8,r10[0x0]
800044aa:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800044ae:	f9 b2 00 10 	moveq	r2,16
800044b2:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800044b6:	74 08       	ld.w	r8,r10[0x0]
800044b8:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800044bc:	f9 b6 00 08 	moveq	r6,8
800044c0:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800044c4:	74 08       	ld.w	r8,r10[0x0]
800044c6:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800044ca:	f9 b7 00 04 	moveq	r7,4
800044ce:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800044d2:	74 08       	ld.w	r8,r10[0x0]
800044d4:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800044d8:	f9 be 00 02 	moveq	lr,2
800044dc:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800044e0:	74 08       	ld.w	r8,r10[0x0]
800044e2:	ec 18 00 01 	eorl	r8,0x1
800044e6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800044ea:	eb e8 10 08 	or	r8,r5,r8
800044ee:	08 48       	or	r8,r4
800044f0:	06 48       	or	r8,r3
800044f2:	04 48       	or	r8,r2
800044f4:	0c 48       	or	r8,r6
800044f6:	0e 48       	or	r8,r7
800044f8:	1c 48       	or	r8,lr
800044fa:	f6 0a 15 06 	lsl	r10,r11,0x6
800044fe:	f8 0a 00 0a 	add	r10,r12,r10
80004502:	2d 8a       	sub	r10,-40
80004504:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80004506:	a7 6b       	lsl	r11,0x6
80004508:	2e 0b       	sub	r11,-32
8000450a:	16 0c       	add	r12,r11
8000450c:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
8000450e:	58 09       	cp.w	r9,0
80004510:	c0 31       	brne	80004516 <tc_configure_interrupts+0x102>
80004512:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80004516:	d5 03       	csrf	0x10
80004518:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0

8000451c <twi_master_interrupt_handler>:
/*! \brief TWI interrupt handler.
 */
ISR(twi_master_interrupt_handler, CONF_TWI_IRQ_GROUP, CONF_TWI_IRQ_LEVEL)
{
	// get masked status register value
	int status = twi_inst->sr & twi_it_mask;
8000451c:	4a 78       	lddpc	r8,800045b8 <twi_master_interrupt_handler+0x9c>
8000451e:	70 08       	ld.w	r8,r8[0x0]
80004520:	70 89       	ld.w	r9,r8[0x20]
80004522:	4a 7a       	lddpc	r10,800045bc <twi_master_interrupt_handler+0xa0>
80004524:	74 0a       	ld.w	r10,r10[0x0]
80004526:	f5 e9 00 09 	and	r9,r10,r9

	// this is a NACK
	if (status & AVR32_TWI_SR_NACK_MASK) {
8000452a:	12 9a       	mov	r10,r9
8000452c:	e2 1a 01 00 	andl	r10,0x100,COH
80004530:	c3 91       	brne	800045a2 <twi_master_interrupt_handler+0x86>
		goto nack;
	}
	// this is a RXRDY
	else if (status & AVR32_TWI_SR_RXRDY_MASK) {
80004532:	12 9a       	mov	r10,r9
80004534:	e2 1a 00 02 	andl	r10,0x2,COH
80004538:	c1 70       	breq	80004566 <twi_master_interrupt_handler+0x4a>
		// get data from Receive Holding Register
		*twi_rx_data = twi_inst->rhr;
8000453a:	4a 29       	lddpc	r9,800045c0 <twi_master_interrupt_handler+0xa4>
8000453c:	72 0a       	ld.w	r10,r9[0x0]
8000453e:	70 cb       	ld.w	r11,r8[0x30]
80004540:	b4 8b       	st.b	r10[0x0],r11
		twi_rx_data++;
80004542:	72 0a       	ld.w	r10,r9[0x0]
80004544:	2f fa       	sub	r10,-1
80004546:	93 0a       	st.w	r9[0x0],r10
		// last byte to receive
		if (--twi_rx_nb_bytes == 1) {
80004548:	49 f9       	lddpc	r9,800045c4 <twi_master_interrupt_handler+0xa8>
8000454a:	72 0a       	ld.w	r10,r9[0x0]
8000454c:	20 1a       	sub	r10,1
8000454e:	93 0a       	st.w	r9[0x0],r10
80004550:	72 09       	ld.w	r9,r9[0x0]
			// set stop bit
			twi_inst->cr = AVR32_TWI_STOP_MASK;
80004552:	58 19       	cp.w	r9,1
80004554:	f9 b9 00 02 	moveq	r9,2
80004558:	f1 f9 0a 00 	st.weq	r8[0x0],r9
		}
		// receive complete
		if (twi_rx_nb_bytes == 0) {
8000455c:	49 a9       	lddpc	r9,800045c4 <twi_master_interrupt_handler+0xa8>
8000455e:	72 09       	ld.w	r9,r9[0x0]
80004560:	58 09       	cp.w	r9,0
80004562:	c2 30       	breq	800045a8 <twi_master_interrupt_handler+0x8c>
80004564:	d6 03       	rete
			// finish the receive operation
			goto complete;
		}
	}
	// this is a TXRDY
	else if (status & AVR32_TWI_SR_TXRDY_MASK) {
80004566:	12 9a       	mov	r10,r9
80004568:	e2 1a 00 04 	andl	r10,0x4,COH
8000456c:	c1 70       	breq	8000459a <twi_master_interrupt_handler+0x7e>
		// decrease transmitted bytes number
		twi_tx_nb_bytes--;
8000456e:	49 79       	lddpc	r9,800045c8 <twi_master_interrupt_handler+0xac>
80004570:	72 0a       	ld.w	r10,r9[0x0]
80004572:	20 1a       	sub	r10,1
80004574:	93 0a       	st.w	r9[0x0],r10
		// no more bytes to transmit
		if (twi_tx_nb_bytes <= 0) {
80004576:	72 09       	ld.w	r9,r9[0x0]
80004578:	58 09       	cp.w	r9,0
8000457a:	e0 89 00 0a 	brgt	8000458e <twi_master_interrupt_handler+0x72>
			// enable TXCOMP IT and unmask all others IT
			twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
8000457e:	49 09       	lddpc	r9,800045bc <twi_master_interrupt_handler+0xa0>
80004580:	30 1a       	mov	r10,1
80004582:	93 0a       	st.w	r9[0x0],r10
			twi_inst->idr = ~0UL;
80004584:	3f fa       	mov	r10,-1
80004586:	91 aa       	st.w	r8[0x28],r10
			twi_inst->ier = twi_it_mask;
80004588:	72 09       	ld.w	r9,r9[0x0]
8000458a:	91 99       	st.w	r8[0x24],r9
8000458c:	d6 03       	rete
		} else {
			// put the byte in the Transmit Holding Register
			twi_inst->thr = *twi_tx_data++;
8000458e:	49 0a       	lddpc	r10,800045cc <twi_master_interrupt_handler+0xb0>
80004590:	74 09       	ld.w	r9,r10[0x0]
80004592:	13 3b       	ld.ub	r11,r9++
80004594:	91 db       	st.w	r8[0x34],r11
80004596:	95 09       	st.w	r10[0x0],r9
80004598:	d6 03       	rete
		}
	}
	// this is a TXCOMP
	else if (status & AVR32_TWI_SR_TXCOMP_MASK) {
8000459a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000459e:	c0 51       	brne	800045a8 <twi_master_interrupt_handler+0x8c>
800045a0:	d6 03       	rete
	}

	return;

nack:
	twi_nack = true;
800045a2:	30 1a       	mov	r10,1
800045a4:	48 b9       	lddpc	r9,800045d0 <twi_master_interrupt_handler+0xb4>
800045a6:	b2 8a       	st.b	r9[0x0],r10

complete:
	// disable all interrupts
	twi_inst->idr = ~0UL;
800045a8:	3f f9       	mov	r9,-1
800045aa:	91 a9       	st.w	r8[0x28],r9
	twi_inst->sr;
800045ac:	70 88       	ld.w	r8,r8[0x20]
	twi_busy = false;
800045ae:	30 09       	mov	r9,0
800045b0:	48 98       	lddpc	r8,800045d4 <twi_master_interrupt_handler+0xb8>
800045b2:	b0 89       	st.b	r8[0x0],r9
800045b4:	d6 03       	rete
800045b6:	00 00       	add	r0,r0
800045b8:	00 00       	add	r0,r0
800045ba:	0c 20       	rsub	r0,r6
800045bc:	00 00       	add	r0,r0
800045be:	0c 1c       	sub	r12,r6
800045c0:	00 00       	add	r0,r0
800045c2:	0c 2c       	rsub	r12,r6
800045c4:	00 00       	add	r0,r0
800045c6:	0c 28       	rsub	r8,r6
800045c8:	00 00       	add	r0,r0
800045ca:	0c 18       	sub	r8,r6
800045cc:	00 00       	add	r0,r0
800045ce:	0c 24       	rsub	r4,r6
800045d0:	00 00       	add	r0,r0
800045d2:	0c 15       	sub	r5,r6
800045d4:	00 00       	add	r0,r0
800045d6:	0c 14       	sub	r4,r6

800045d8 <twi_master_init>:
	return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
800045d8:	eb cd 40 e0 	pushm	r5-r7,lr
800045dc:	18 97       	mov	r7,r12
800045de:	16 95       	mov	r5,r11
	irqflags_t flags = sysreg_read(AVR32_SR);
800045e0:	e1 b8 00 00 	mfsr	r8,0x0
	int status = TWI_SUCCESS;

	// Set pointer to TWIM instance for IT
	twi_inst = twi;
800045e4:	49 f9       	lddpc	r9,80004660 <twi_master_init+0x88>
800045e6:	93 0c       	st.w	r9[0x0],r12

	// Disable TWI interrupts
	cpu_irq_disable();
800045e8:	d3 03       	ssrf	0x10
	twi->idr = ~0UL;
800045ea:	3f f9       	mov	r9,-1
800045ec:	99 a9       	st.w	r12[0x28],r9
	twi->sr;
800045ee:	78 89       	ld.w	r9,r12[0x20]

	// Reset TWI
	twi->cr = AVR32_TWI_CR_SWRST_MASK;
800045f0:	e0 69 00 80 	mov	r9,128
800045f4:	99 09       	st.w	r12[0x0],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800045f6:	e6 18 00 01 	andh	r8,0x1,COH
800045fa:	c0 21       	brne	800045fe <twi_master_init+0x26>
      cpu_irq_enable();
800045fc:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);

	// Dummy read in SR
	twi->sr;
800045fe:	6e 88       	ld.w	r8,r7[0x20]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004600:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80004604:	d3 03       	ssrf	0x10
	
	// register Register twim_master_interrupt_handler interrupt
	// on level CONF_TWI_IRQ_LEVEL
	flags = cpu_irq_save();

	irq_register_handler(&twi_master_interrupt_handler, CONF_TWI_IRQ_LINE, CONF_TWI_IRQ_LEVEL);
80004606:	30 3a       	mov	r10,3
80004608:	e0 6b 01 60 	mov	r11,352
8000460c:	49 6c       	lddpc	r12,80004664 <twi_master_init+0x8c>
8000460e:	f0 1f 00 17 	mcall	80004668 <twi_master_init+0x90>
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004612:	e6 16 00 01 	andh	r6,0x1,COH
80004616:	c0 21       	brne	8000461a <twi_master_init+0x42>
      cpu_irq_enable();
80004618:	d5 03       	csrf	0x10
		unsigned long pba_hz)
{
	unsigned int ckdiv = 0;
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;
8000461a:	6a 19       	ld.w	r9,r5[0x4]
8000461c:	a1 79       	lsl	r9,0x1
8000461e:	6a 08       	ld.w	r8,r5[0x0]
80004620:	f0 09 0d 08 	divu	r8,r8,r9
80004624:	20 48       	sub	r8,4

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
80004626:	e0 48 00 ff 	cp.w	r8,255
8000462a:	e0 8b 00 04 	brhi	80004632 <twi_master_init+0x5a>
8000462e:	30 09       	mov	r9,0
80004630:	c0 f8       	rjmp	8000464e <twi_master_init+0x76>
80004632:	30 09       	mov	r9,0
80004634:	30 0c       	mov	r12,0
		// increase clock divider
		ckdiv++;
80004636:	2f f9       	sub	r9,-1

		// divide cldiv value
		c_lh_div /= 2;
80004638:	a1 98       	lsr	r8,0x1
	unsigned int c_lh_div;

	c_lh_div = pba_hz / (speed * 2) - 4;

	// cldiv must fit in 8 bits, ckdiv must fit in 3 bits
	while ((c_lh_div > 0xFF) && (ckdiv < 0x7)) {
8000463a:	e0 48 00 ff 	cp.w	r8,255
8000463e:	5f bb       	srhi	r11
80004640:	58 69       	cp.w	r9,6
80004642:	5f 8a       	srls	r10
80004644:	f7 ea 00 0a 	and	r10,r11,r10
80004648:	f8 0a 18 00 	cp.b	r10,r12
8000464c:	cf 51       	brne	80004636 <twi_master_init+0x5e>
		// divide cldiv value
		c_lh_div /= 2;
	}

	// set clock waveform generator register
	twi->cwgr = ((c_lh_div << AVR32_TWI_CWGR_CLDIV_OFFSET) |
8000464e:	b1 69       	lsl	r9,0x10
80004650:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80004654:	f3 e8 10 08 	or	r8,r9,r8
80004658:	8f 48       	st.w	r7[0x10],r8

	//Probe the component
	//status = twi_probe(twi, opt->chip);

	return status;
}
8000465a:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000465e:	00 00       	add	r0,r0
80004660:	00 00       	add	r0,r0
80004662:	0c 20       	rsub	r0,r6
80004664:	80 00       	ld.sh	r0,r0[0x0]
80004666:	45 1c       	lddsp	r12,sp[0x144]
80004668:	80 00       	ld.sh	r0,r0[0x0]
8000466a:	42 14       	lddsp	r4,sp[0x84]

8000466c <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
8000466c:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
8000466e:	f6 08 15 04 	lsl	r8,r11,0x4
80004672:	14 38       	cp.w	r8,r10
80004674:	f9 b8 08 10 	movls	r8,16
80004678:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
8000467c:	f0 0b 02 4b 	mul	r11,r8,r11
80004680:	f6 09 16 01 	lsr	r9,r11,0x1
80004684:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80004688:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
8000468c:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004690:	f2 cb 00 01 	sub	r11,r9,1
80004694:	e0 4b ff fe 	cp.w	r11,65534
80004698:	e0 88 00 03 	brls	8000469e <usart_set_async_baudrate+0x32>
8000469c:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
8000469e:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800046a0:	e8 6e 00 00 	mov	lr,524288
800046a4:	59 08       	cp.w	r8,16
800046a6:	fc 08 17 10 	movne	r8,lr
800046aa:	f9 b8 00 00 	moveq	r8,0
800046ae:	e4 1b ff f7 	andh	r11,0xfff7
800046b2:	e0 1b fe cf 	andl	r11,0xfecf
800046b6:	16 48       	or	r8,r11
800046b8:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800046ba:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800046be:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800046c2:	99 89       	st.w	r12[0x20],r9
800046c4:	d8 0a       	popm	pc,r12=0

800046c6 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800046c6:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
800046c8:	e2 18 00 02 	andl	r8,0x2,COH
800046cc:	c0 31       	brne	800046d2 <usart_write_char+0xc>
800046ce:	30 2c       	mov	r12,2
800046d0:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800046d2:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
800046d6:	99 7b       	st.w	r12[0x1c],r11
800046d8:	5e fd       	retal	0
800046da:	d7 03       	nop

800046dc <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
800046dc:	eb cd 40 e0 	pushm	r5-r7,lr
800046e0:	18 96       	mov	r6,r12
800046e2:	16 95       	mov	r5,r11
800046e4:	e0 67 27 0f 	mov	r7,9999
800046e8:	c0 68       	rjmp	800046f4 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
800046ea:	58 07       	cp.w	r7,0
800046ec:	c0 31       	brne	800046f2 <usart_putchar+0x16>
800046ee:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
800046f2:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
800046f4:	0a 9b       	mov	r11,r5
800046f6:	0c 9c       	mov	r12,r6
800046f8:	f0 1f 00 03 	mcall	80004704 <usart_putchar+0x28>
800046fc:	cf 71       	brne	800046ea <usart_putchar+0xe>

  return USART_SUCCESS;
}
800046fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004702:	00 00       	add	r0,r0
80004704:	80 00       	ld.sh	r0,r0[0x0]
80004706:	46 c6       	lddsp	r6,sp[0x1b0]

80004708 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004708:	78 58       	ld.w	r8,r12[0x14]
8000470a:	e2 18 00 e0 	andl	r8,0xe0,COH
8000470e:	c0 30       	breq	80004714 <usart_read_char+0xc>
80004710:	30 4c       	mov	r12,4
80004712:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80004714:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80004716:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000471a:	c0 31       	brne	80004720 <usart_read_char+0x18>
8000471c:	30 3c       	mov	r12,3
8000471e:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004720:	78 68       	ld.w	r8,r12[0x18]
80004722:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80004726:	97 08       	st.w	r11[0x0],r8
80004728:	5e fd       	retal	0
8000472a:	d7 03       	nop

8000472c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
8000472c:	eb cd 40 c0 	pushm	r6-r7,lr
80004730:	20 1d       	sub	sp,4
80004732:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80004734:	1a 97       	mov	r7,sp
80004736:	1a 9b       	mov	r11,sp
80004738:	0c 9c       	mov	r12,r6
8000473a:	f0 1f 00 07 	mcall	80004754 <usart_getchar+0x28>
8000473e:	58 3c       	cp.w	r12,3
80004740:	cf b0       	breq	80004736 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80004742:	58 4c       	cp.w	r12,4
80004744:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004748:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
8000474c:	2f fd       	sub	sp,-4
8000474e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004752:	00 00       	add	r0,r0
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	47 08       	lddsp	r8,sp[0x1c0]

80004758 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004758:	eb cd 40 c0 	pushm	r6-r7,lr
8000475c:	18 96       	mov	r6,r12
8000475e:	16 97       	mov	r7,r11
  while (*string != '\0')
80004760:	17 8b       	ld.ub	r11,r11[0x0]
80004762:	58 0b       	cp.w	r11,0
80004764:	c0 80       	breq	80004774 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80004766:	2f f7       	sub	r7,-1
80004768:	0c 9c       	mov	r12,r6
8000476a:	f0 1f 00 04 	mcall	80004778 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
8000476e:	0f 8b       	ld.ub	r11,r7[0x0]
80004770:	58 0b       	cp.w	r11,0
80004772:	cf a1       	brne	80004766 <usart_write_line+0xe>
80004774:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004778:	80 00       	ld.sh	r0,r0[0x0]
8000477a:	46 dc       	lddsp	r12,sp[0x1b4]

8000477c <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000477c:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80004780:	e6 18 00 01 	andh	r8,0x1,COH
80004784:	c0 71       	brne	80004792 <usart_reset+0x16>
80004786:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004788:	3f f8       	mov	r8,-1
8000478a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000478c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
8000478e:	d5 03       	csrf	0x10
80004790:	c0 48       	rjmp	80004798 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80004792:	3f f8       	mov	r8,-1
80004794:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80004796:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80004798:	30 08       	mov	r8,0
8000479a:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
8000479c:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
8000479e:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800047a0:	ea 68 61 0c 	mov	r8,680204
800047a4:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800047a6:	5e fc       	retal	r12

800047a8 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800047a8:	eb cd 40 e0 	pushm	r5-r7,lr
800047ac:	18 96       	mov	r6,r12
800047ae:	16 97       	mov	r7,r11
800047b0:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800047b2:	f0 1f 00 2f 	mcall	8000486c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800047b6:	58 07       	cp.w	r7,0
800047b8:	c5 80       	breq	80004868 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800047ba:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800047bc:	30 49       	mov	r9,4
800047be:	f2 08 18 00 	cp.b	r8,r9
800047c2:	e0 88 00 53 	brls	80004868 <usart_init_rs232+0xc0>
800047c6:	30 99       	mov	r9,9
800047c8:	f2 08 18 00 	cp.b	r8,r9
800047cc:	e0 8b 00 4e 	brhi	80004868 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800047d0:	0f d9       	ld.ub	r9,r7[0x5]
800047d2:	30 78       	mov	r8,7
800047d4:	f0 09 18 00 	cp.b	r9,r8
800047d8:	e0 8b 00 48 	brhi	80004868 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800047dc:	8e 39       	ld.sh	r9,r7[0x6]
800047de:	e0 68 01 01 	mov	r8,257
800047e2:	f0 09 19 00 	cp.h	r9,r8
800047e6:	e0 8b 00 41 	brhi	80004868 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800047ea:	ef 39 00 08 	ld.ub	r9,r7[8]
800047ee:	30 38       	mov	r8,3
800047f0:	f0 09 18 00 	cp.b	r9,r8
800047f4:	e0 8b 00 3a 	brhi	80004868 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
800047f8:	0a 9a       	mov	r10,r5
800047fa:	6e 0b       	ld.w	r11,r7[0x0]
800047fc:	0c 9c       	mov	r12,r6
800047fe:	f0 1f 00 1d 	mcall	80004870 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004802:	58 1c       	cp.w	r12,1
80004804:	c3 20       	breq	80004868 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004806:	0f c8       	ld.ub	r8,r7[0x4]
80004808:	30 99       	mov	r9,9
8000480a:	f2 08 18 00 	cp.b	r8,r9
8000480e:	c0 51       	brne	80004818 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004810:	6c 18       	ld.w	r8,r6[0x4]
80004812:	b1 b8       	sbr	r8,0x11
80004814:	8d 18       	st.w	r6[0x4],r8
80004816:	c0 68       	rjmp	80004822 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004818:	6c 19       	ld.w	r9,r6[0x4]
8000481a:	20 58       	sub	r8,5
8000481c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004820:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004822:	6c 19       	ld.w	r9,r6[0x4]
80004824:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004828:	0f d8       	ld.ub	r8,r7[0x5]
8000482a:	a9 78       	lsl	r8,0x9
8000482c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004830:	12 48       	or	r8,r9
80004832:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004834:	8e 38       	ld.sh	r8,r7[0x6]
80004836:	30 29       	mov	r9,2
80004838:	f2 08 19 00 	cp.h	r8,r9
8000483c:	e0 88 00 09 	brls	8000484e <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004840:	6c 18       	ld.w	r8,r6[0x4]
80004842:	ad b8       	sbr	r8,0xd
80004844:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004846:	8e b8       	ld.uh	r8,r7[0x6]
80004848:	20 28       	sub	r8,2
8000484a:	8d a8       	st.w	r6[0x28],r8
8000484c:	c0 68       	rjmp	80004858 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000484e:	6c 19       	ld.w	r9,r6[0x4]
80004850:	5c 78       	castu.h	r8
80004852:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004856:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004858:	6c 18       	ld.w	r8,r6[0x4]
8000485a:	e0 18 ff f0 	andl	r8,0xfff0
8000485e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004860:	35 08       	mov	r8,80
80004862:	8d 08       	st.w	r6[0x0],r8
80004864:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004868:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	47 7c       	lddsp	r12,sp[0x1dc]
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	46 6c       	lddsp	r12,sp[0x198]

80004874 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004874:	f8 c8 ff f8 	sub	r8,r12,-8
80004878:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000487a:	3f f9       	mov	r9,-1
8000487c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000487e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004880:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004882:	30 08       	mov	r8,0
80004884:	99 08       	st.w	r12[0x0],r8
}
80004886:	5e fc       	retal	r12

80004888 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004888:	30 08       	mov	r8,0
8000488a:	99 48       	st.w	r12[0x10],r8
}
8000488c:	5e fc       	retal	r12

8000488e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000488e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004890:	70 19       	ld.w	r9,r8[0x4]
80004892:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004894:	78 19       	ld.w	r9,r12[0x4]
80004896:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004898:	70 19       	ld.w	r9,r8[0x4]
8000489a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
8000489c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000489e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800048a0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800048a2:	78 08       	ld.w	r8,r12[0x0]
800048a4:	2f f8       	sub	r8,-1
800048a6:	99 08       	st.w	r12[0x0],r8
}
800048a8:	5e fc       	retal	r12

800048aa <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800048aa:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800048ac:	5b fa       	cp.w	r10,-1
800048ae:	c0 31       	brne	800048b4 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800048b0:	78 48       	ld.w	r8,r12[0x10]
800048b2:	c0 c8       	rjmp	800048ca <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800048b4:	f8 c8 ff f8 	sub	r8,r12,-8
800048b8:	70 19       	ld.w	r9,r8[0x4]
800048ba:	72 09       	ld.w	r9,r9[0x0]
800048bc:	12 3a       	cp.w	r10,r9
800048be:	c0 63       	brcs	800048ca <vListInsert+0x20>
800048c0:	70 18       	ld.w	r8,r8[0x4]
800048c2:	70 19       	ld.w	r9,r8[0x4]
800048c4:	72 09       	ld.w	r9,r9[0x0]
800048c6:	12 3a       	cp.w	r10,r9
800048c8:	cf c2       	brcc	800048c0 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800048ca:	70 19       	ld.w	r9,r8[0x4]
800048cc:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800048ce:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800048d0:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800048d2:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800048d4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800048d6:	78 08       	ld.w	r8,r12[0x0]
800048d8:	2f f8       	sub	r8,-1
800048da:	99 08       	st.w	r12[0x0],r8
}
800048dc:	5e fc       	retal	r12

800048de <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800048de:	78 18       	ld.w	r8,r12[0x4]
800048e0:	78 29       	ld.w	r9,r12[0x8]
800048e2:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800048e4:	78 28       	ld.w	r8,r12[0x8]
800048e6:	78 19       	ld.w	r9,r12[0x4]
800048e8:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800048ea:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800048ec:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800048ee:	18 39       	cp.w	r9,r12
800048f0:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800048f4:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800048f8:	30 09       	mov	r9,0
800048fa:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800048fc:	70 09       	ld.w	r9,r8[0x0]
800048fe:	20 19       	sub	r9,1
80004900:	91 09       	st.w	r8[0x0],r9
}
80004902:	5e fc       	retal	r12

80004904 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004904:	e0 68 08 08 	mov	r8,2056
80004908:	ea 18 08 08 	orh	r8,0x808
8000490c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000490e:	e0 68 09 09 	mov	r8,2313
80004912:	ea 18 09 09 	orh	r8,0x909
80004916:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004918:	e0 68 0a 0a 	mov	r8,2570
8000491c:	ea 18 0a 0a 	orh	r8,0xa0a
80004920:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004922:	e0 68 0b 0b 	mov	r8,2827
80004926:	ea 18 0b 0b 	orh	r8,0xb0b
8000492a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
8000492c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000492e:	e0 68 be ef 	mov	r8,48879
80004932:	ea 18 de ad 	orh	r8,0xdead
80004936:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004938:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000493a:	fc 18 00 40 	movh	r8,0x40
8000493e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004940:	e0 68 00 ff 	mov	r8,255
80004944:	ea 18 ff 00 	orh	r8,0xff00
80004948:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000494a:	e0 68 01 01 	mov	r8,257
8000494e:	ea 18 01 01 	orh	r8,0x101
80004952:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004954:	e0 68 02 02 	mov	r8,514
80004958:	ea 18 02 02 	orh	r8,0x202
8000495c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000495e:	e0 68 03 03 	mov	r8,771
80004962:	ea 18 03 03 	orh	r8,0x303
80004966:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004968:	e0 68 04 04 	mov	r8,1028
8000496c:	ea 18 04 04 	orh	r8,0x404
80004970:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004972:	e0 68 05 05 	mov	r8,1285
80004976:	ea 18 05 05 	orh	r8,0x505
8000497a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
8000497c:	e0 68 06 06 	mov	r8,1542
80004980:	ea 18 06 06 	orh	r8,0x606
80004984:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004986:	e0 68 07 07 	mov	r8,1799
8000498a:	ea 18 07 07 	orh	r8,0x707
8000498e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004990:	30 08       	mov	r8,0
80004992:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004994:	5e fc       	retal	r12
80004996:	d7 03       	nop

80004998 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004998:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000499a:	48 38       	lddpc	r8,800049a4 <vPortEnterCritical+0xc>
8000499c:	70 09       	ld.w	r9,r8[0x0]
8000499e:	2f f9       	sub	r9,-1
800049a0:	91 09       	st.w	r8[0x0],r9
}
800049a2:	5e fc       	retal	r12
800049a4:	00 00       	add	r0,r0
800049a6:	05 30       	ld.ub	r0,r2++

800049a8 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800049a8:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800049aa:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800049ac:	30 0a       	mov	r10,0
800049ae:	14 9b       	mov	r11,r10
800049b0:	49 2c       	lddpc	r12,800049f8 <xPortStartScheduler+0x50>
800049b2:	f0 1f 00 13 	mcall	800049fc <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
800049b6:	e0 68 5d c0 	mov	r8,24000
800049ba:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800049be:	30 08       	mov	r8,0
800049c0:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800049c4:	e0 68 0d 00 	mov	r8,3328
800049c8:	ea 18 00 00 	orh	r8,0x0
800049cc:	70 00       	ld.w	r0,r8[0x0]
800049ce:	60 0d       	ld.w	sp,r0[0x0]
800049d0:	1b 00       	ld.w	r0,sp++
800049d2:	e0 68 05 30 	mov	r8,1328
800049d6:	ea 18 00 00 	orh	r8,0x0
800049da:	91 00       	st.w	r8[0x0],r0
800049dc:	e3 cd 00 ff 	ldm	sp++,r0-r7
800049e0:	2f ed       	sub	sp,-8
800049e2:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800049e6:	fa f0 ff e0 	ld.w	r0,sp[-32]
800049ea:	e3 b0 00 00 	mtsr	0x0,r0
800049ee:	fa f0 ff dc 	ld.w	r0,sp[-36]
800049f2:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800049f6:	d8 0a       	popm	pc,r12=0
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	4a c4       	lddpc	r4,80004aa8 <vPortExitCritical+0x4>
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	42 14       	lddsp	r4,sp[0x84]

80004a00 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004a00:	20 6d       	sub	sp,24
80004a02:	eb cd 00 ff 	pushm	r0-r7
80004a06:	fa c7 ff c0 	sub	r7,sp,-64
80004a0a:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004a0e:	ef 40 ff e0 	st.w	r7[-32],r0
80004a12:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004a16:	ef 40 ff e4 	st.w	r7[-28],r0
80004a1a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004a1e:	e0 68 05 30 	mov	r8,1328
80004a22:	ea 18 00 00 	orh	r8,0x0
80004a26:	70 00       	ld.w	r0,r8[0x0]
80004a28:	1a d0       	st.w	--sp,r0
80004a2a:	f0 1f 00 1a 	mcall	80004a90 <LABEL_RET_SCALL_263+0x14>
80004a2e:	e0 68 0d 00 	mov	r8,3328
80004a32:	ea 18 00 00 	orh	r8,0x0
80004a36:	70 00       	ld.w	r0,r8[0x0]
80004a38:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004a3a:	f0 1f 00 17 	mcall	80004a94 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004a3e:	e0 68 0d 00 	mov	r8,3328
80004a42:	ea 18 00 00 	orh	r8,0x0
80004a46:	70 00       	ld.w	r0,r8[0x0]
80004a48:	60 0d       	ld.w	sp,r0[0x0]
80004a4a:	1b 00       	ld.w	r0,sp++
80004a4c:	e0 68 05 30 	mov	r8,1328
80004a50:	ea 18 00 00 	orh	r8,0x0
80004a54:	91 00       	st.w	r8[0x0],r0
80004a56:	fa c7 ff d8 	sub	r7,sp,-40
80004a5a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004a5e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004a62:	e0 61 05 30 	mov	r1,1328
80004a66:	ea 11 00 00 	orh	r1,0x0
80004a6a:	62 02       	ld.w	r2,r1[0x0]
80004a6c:	58 02       	cp.w	r2,0
80004a6e:	c0 70       	breq	80004a7c <LABEL_RET_SCALL_263>
80004a70:	e4 c2 00 01 	sub	r2,r2,1
80004a74:	83 02       	st.w	r1[0x0],r2
80004a76:	58 02       	cp.w	r2,0
80004a78:	c0 21       	brne	80004a7c <LABEL_RET_SCALL_263>
80004a7a:	b1 c0       	cbr	r0,0x10

80004a7c <LABEL_RET_SCALL_263>:
80004a7c:	ef 40 ff f8 	st.w	r7[-8],r0
80004a80:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004a84:	ef 40 ff fc 	st.w	r7[-4],r0
80004a88:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004a8c:	2f ad       	sub	sp,-24
80004a8e:	d6 13       	rets
80004a90:	80 00       	ld.sh	r0,r0[0x0]
80004a92:	49 98       	lddpc	r8,80004af4 <LABEL_INT_SKIP_SAVE_CONTEXT_237+0x8>
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	51 34       	stdsp	sp[0x4c],r4

80004a98 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004a98:	e1 b8 00 43 	mfsr	r8,0x10c
80004a9c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004aa0:	5e fc       	retal	r12
80004aa2:	d7 03       	nop

80004aa4 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004aa4:	48 78       	lddpc	r8,80004ac0 <vPortExitCritical+0x1c>
80004aa6:	70 08       	ld.w	r8,r8[0x0]
80004aa8:	58 08       	cp.w	r8,0
80004aaa:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004aac:	48 58       	lddpc	r8,80004ac0 <vPortExitCritical+0x1c>
80004aae:	70 09       	ld.w	r9,r8[0x0]
80004ab0:	20 19       	sub	r9,1
80004ab2:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004ab4:	70 08       	ld.w	r8,r8[0x0]
80004ab6:	58 08       	cp.w	r8,0
80004ab8:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004aba:	d5 03       	csrf	0x10
80004abc:	5e fc       	retal	r12
80004abe:	00 00       	add	r0,r0
80004ac0:	00 00       	add	r0,r0
80004ac2:	05 30       	ld.ub	r0,r2++

80004ac4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004ac4:	eb cd 00 ff 	pushm	r0-r7
80004ac8:	e0 68 05 30 	mov	r8,1328
80004acc:	ea 18 00 00 	orh	r8,0x0
80004ad0:	70 00       	ld.w	r0,r8[0x0]
80004ad2:	1a d0       	st.w	--sp,r0
80004ad4:	7a 90       	ld.w	r0,sp[0x24]
80004ad6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004ada:	58 10       	cp.w	r0,1
80004adc:	e0 8b 00 08 	brhi	80004aec <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80004ae0:	e0 68 0d 00 	mov	r8,3328
80004ae4:	ea 18 00 00 	orh	r8,0x0
80004ae8:	70 00       	ld.w	r0,r8[0x0]
80004aea:	81 0d       	st.w	r0[0x0],sp

80004aec <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004aec:	f0 1f 00 12 	mcall	80004b34 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004af0:	f0 1f 00 12 	mcall	80004b38 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80004af4:	f0 1f 00 12 	mcall	80004b3c <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80004af8:	f0 1f 00 12 	mcall	80004b40 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004afc:	7a 90       	ld.w	r0,sp[0x24]
80004afe:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004b02:	58 10       	cp.w	r0,1
80004b04:	e0 8b 00 0e 	brhi	80004b20 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80004b08:	f0 1f 00 0c 	mcall	80004b38 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80004b0c:	f0 1f 00 0e 	mcall	80004b44 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80004b10:	f0 1f 00 0c 	mcall	80004b40 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004b14:	e0 68 0d 00 	mov	r8,3328
80004b18:	ea 18 00 00 	orh	r8,0x0
80004b1c:	70 00       	ld.w	r0,r8[0x0]
80004b1e:	60 0d       	ld.w	sp,r0[0x0]

80004b20 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80004b20:	1b 00       	ld.w	r0,sp++
80004b22:	e0 68 05 30 	mov	r8,1328
80004b26:	ea 18 00 00 	orh	r8,0x0
80004b2a:	91 00       	st.w	r8[0x0],r0
80004b2c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004b30:	d6 03       	rete
80004b32:	00 00       	add	r0,r0
80004b34:	80 00       	ld.sh	r0,r0[0x0]
80004b36:	4a 98       	lddpc	r8,80004bd8 <_write+0x38>
80004b38:	80 00       	ld.sh	r0,r0[0x0]
80004b3a:	49 98       	lddpc	r8,80004b9c <_read+0x3c>
80004b3c:	80 00       	ld.sh	r0,r0[0x0]
80004b3e:	53 38       	stdsp	sp[0xcc],r8
80004b40:	80 00       	ld.sh	r0,r0[0x0]
80004b42:	4a a4       	lddpc	r4,80004be8 <vPortFree+0xc>
80004b44:	80 00       	ld.sh	r0,r0[0x0]
80004b46:	51 34       	stdsp	sp[0x4c],r4

80004b48 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004b48:	d4 01       	pushm	lr
	vTaskSuspendAll();
80004b4a:	f0 1f 00 02 	mcall	80004b50 <__malloc_lock+0x8>
}
80004b4e:	d8 02       	popm	pc
80004b50:	80 00       	ld.sh	r0,r0[0x0]
80004b52:	51 24       	stdsp	sp[0x48],r4

80004b54 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004b54:	d4 01       	pushm	lr
	xTaskResumeAll();
80004b56:	f0 1f 00 02 	mcall	80004b5c <__malloc_unlock+0x8>
}
80004b5a:	d8 02       	popm	pc
80004b5c:	80 00       	ld.sh	r0,r0[0x0]
80004b5e:	54 e0       	stdsp	sp[0x138],r0

80004b60 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80004b60:	d4 21       	pushm	r4-r7,lr
80004b62:	16 95       	mov	r5,r11
80004b64:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80004b66:	58 0c       	cp.w	r12,0
80004b68:	c0 30       	breq	80004b6e <_read+0xe>
80004b6a:	3f f7       	mov	r7,-1
80004b6c:	c1 48       	rjmp	80004b94 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80004b6e:	58 0a       	cp.w	r10,0
80004b70:	e0 89 00 04 	brgt	80004b78 <_read+0x18>
80004b74:	30 07       	mov	r7,0
80004b76:	c0 f8       	rjmp	80004b94 <_read+0x34>
80004b78:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80004b7a:	48 84       	lddpc	r4,80004b98 <_read+0x38>
80004b7c:	68 0c       	ld.w	r12,r4[0x0]
80004b7e:	f0 1f 00 08 	mcall	80004b9c <_read+0x3c>
    if (c < 0)
80004b82:	c0 95       	brlt	80004b94 <_read+0x34>
      break;

    *ptr++ = c;
80004b84:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80004b88:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80004b8a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80004b8e:	58 08       	cp.w	r8,0
80004b90:	fe 99 ff f6 	brgt	80004b7c <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80004b94:	0e 9c       	mov	r12,r7
80004b96:	d8 22       	popm	r4-r7,pc
80004b98:	00 00       	add	r0,r0
80004b9a:	3f fc       	mov	r12,-1
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	47 2c       	lddsp	r12,sp[0x1c8]

80004ba0 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80004ba0:	d4 21       	pushm	r4-r7,lr
80004ba2:	16 95       	mov	r5,r11
80004ba4:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80004ba6:	20 1c       	sub	r12,1
80004ba8:	58 2c       	cp.w	r12,2
80004baa:	e0 8b 00 12 	brhi	80004bce <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004bae:	58 0a       	cp.w	r10,0
80004bb0:	c0 31       	brne	80004bb6 <_write+0x16>
80004bb2:	30 07       	mov	r7,0
80004bb4:	c0 e8       	rjmp	80004bd0 <_write+0x30>
80004bb6:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80004bb8:	48 74       	lddpc	r4,80004bd4 <_write+0x34>
80004bba:	68 0c       	ld.w	r12,r4[0x0]
80004bbc:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80004bc0:	f0 1f 00 06 	mcall	80004bd8 <_write+0x38>
80004bc4:	c0 55       	brlt	80004bce <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80004bc6:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004bc8:	0e 36       	cp.w	r6,r7
80004bca:	cf 81       	brne	80004bba <_write+0x1a>
80004bcc:	c0 28       	rjmp	80004bd0 <_write+0x30>
80004bce:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80004bd0:	0e 9c       	mov	r12,r7
80004bd2:	d8 22       	popm	r4-r7,pc
80004bd4:	00 00       	add	r0,r0
80004bd6:	3f fc       	mov	r12,-1
80004bd8:	80 00       	ld.sh	r0,r0[0x0]
80004bda:	46 dc       	lddsp	r12,sp[0x1b4]

80004bdc <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004bdc:	eb cd 40 80 	pushm	r7,lr
80004be0:	18 97       	mov	r7,r12
	if( pv )
80004be2:	58 0c       	cp.w	r12,0
80004be4:	c0 80       	breq	80004bf4 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004be6:	f0 1f 00 05 	mcall	80004bf8 <vPortFree+0x1c>
		{
			free( pv );
80004bea:	0e 9c       	mov	r12,r7
80004bec:	f0 1f 00 04 	mcall	80004bfc <vPortFree+0x20>
		}
		xTaskResumeAll();
80004bf0:	f0 1f 00 04 	mcall	80004c00 <vPortFree+0x24>
80004bf4:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bf8:	80 00       	ld.sh	r0,r0[0x0]
80004bfa:	51 24       	stdsp	sp[0x48],r4
80004bfc:	80 00       	ld.sh	r0,r0[0x0]
80004bfe:	60 50       	ld.w	r0,r0[0x14]
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	54 e0       	stdsp	sp[0x138],r0

80004c04 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004c04:	eb cd 40 80 	pushm	r7,lr
80004c08:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80004c0a:	f0 1f 00 06 	mcall	80004c20 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80004c0e:	0e 9c       	mov	r12,r7
80004c10:	f0 1f 00 05 	mcall	80004c24 <pvPortMalloc+0x20>
80004c14:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004c16:	f0 1f 00 05 	mcall	80004c28 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80004c1a:	0e 9c       	mov	r12,r7
80004c1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	51 24       	stdsp	sp[0x48],r4
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	60 60       	ld.w	r0,r0[0x18]
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	54 e0       	stdsp	sp[0x138],r0

80004c2c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80004c2c:	d4 01       	pushm	lr
80004c2e:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80004c30:	78 09       	ld.w	r9,r12[0x0]
80004c32:	58 09       	cp.w	r9,0
80004c34:	c1 10       	breq	80004c56 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80004c36:	78 3a       	ld.w	r10,r12[0xc]
80004c38:	79 09       	ld.w	r9,r12[0x40]
80004c3a:	f4 09 00 09 	add	r9,r10,r9
80004c3e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80004c40:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80004c42:	14 39       	cp.w	r9,r10
80004c44:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80004c48:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80004c4c:	79 0a       	ld.w	r10,r12[0x40]
80004c4e:	78 3b       	ld.w	r11,r12[0xc]
80004c50:	10 9c       	mov	r12,r8
80004c52:	f0 1f 00 02 	mcall	80004c58 <prvCopyDataFromQueue+0x2c>
80004c56:	d8 02       	popm	pc
80004c58:	80 00       	ld.sh	r0,r0[0x0]
80004c5a:	64 a8       	ld.w	r8,r2[0x28]

80004c5c <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80004c5c:	eb cd 40 c0 	pushm	r6-r7,lr
80004c60:	18 97       	mov	r7,r12
80004c62:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004c64:	78 e8       	ld.w	r8,r12[0x38]
80004c66:	58 08       	cp.w	r8,0
80004c68:	c0 31       	brne	80004c6e <xQueueReceiveFromISR+0x12>
80004c6a:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80004c6e:	f0 1f 00 0e 	mcall	80004ca4 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80004c72:	6e e8       	ld.w	r8,r7[0x38]
80004c74:	20 18       	sub	r8,1
80004c76:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80004c78:	6f 18       	ld.w	r8,r7[0x44]
80004c7a:	5b f8       	cp.w	r8,-1
80004c7c:	c0 d1       	brne	80004c96 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004c7e:	6e 48       	ld.w	r8,r7[0x10]
80004c80:	58 08       	cp.w	r8,0
80004c82:	c0 f0       	breq	80004ca0 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004c84:	ee cc ff f0 	sub	r12,r7,-16
80004c88:	f0 1f 00 08 	mcall	80004ca8 <xQueueReceiveFromISR+0x4c>
80004c8c:	c0 a0       	breq	80004ca0 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80004c8e:	30 1c       	mov	r12,1
80004c90:	8d 0c       	st.w	r6[0x0],r12
80004c92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80004c96:	2f f8       	sub	r8,-1
80004c98:	ef 48 00 44 	st.w	r7[68],r8
80004c9c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004ca0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004ca4:	80 00       	ld.sh	r0,r0[0x0]
80004ca6:	4c 2c       	lddpc	r12,80004dac <xQueueGenericReceive+0x60>
80004ca8:	80 00       	ld.sh	r0,r0[0x0]
80004caa:	52 bc       	stdsp	sp[0xac],r12

80004cac <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80004cac:	eb cd 40 c0 	pushm	r6-r7,lr
80004cb0:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80004cb2:	f0 1f 00 23 	mcall	80004d3c <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004cb6:	6f 28       	ld.w	r8,r7[0x48]
80004cb8:	58 08       	cp.w	r8,0
80004cba:	e0 8a 00 18 	brle	80004cea <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004cbe:	6e 98       	ld.w	r8,r7[0x24]
80004cc0:	58 08       	cp.w	r8,0
80004cc2:	c1 40       	breq	80004cea <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004cc4:	ee c6 ff dc 	sub	r6,r7,-36
80004cc8:	c0 48       	rjmp	80004cd0 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004cca:	6e 98       	ld.w	r8,r7[0x24]
80004ccc:	58 08       	cp.w	r8,0
80004cce:	c0 e0       	breq	80004cea <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004cd0:	0c 9c       	mov	r12,r6
80004cd2:	f0 1f 00 1c 	mcall	80004d40 <prvUnlockQueue+0x94>
80004cd6:	c0 30       	breq	80004cdc <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80004cd8:	f0 1f 00 1b 	mcall	80004d44 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80004cdc:	6f 28       	ld.w	r8,r7[0x48]
80004cde:	20 18       	sub	r8,1
80004ce0:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004ce4:	58 08       	cp.w	r8,0
80004ce6:	fe 99 ff f2 	brgt	80004cca <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80004cea:	3f f8       	mov	r8,-1
80004cec:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80004cf0:	f0 1f 00 16 	mcall	80004d48 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80004cf4:	f0 1f 00 12 	mcall	80004d3c <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004cf8:	6f 18       	ld.w	r8,r7[0x44]
80004cfa:	58 08       	cp.w	r8,0
80004cfc:	e0 8a 00 18 	brle	80004d2c <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004d00:	6e 48       	ld.w	r8,r7[0x10]
80004d02:	58 08       	cp.w	r8,0
80004d04:	c1 40       	breq	80004d2c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004d06:	ee c6 ff f0 	sub	r6,r7,-16
80004d0a:	c0 48       	rjmp	80004d12 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004d0c:	6e 48       	ld.w	r8,r7[0x10]
80004d0e:	58 08       	cp.w	r8,0
80004d10:	c0 e0       	breq	80004d2c <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004d12:	0c 9c       	mov	r12,r6
80004d14:	f0 1f 00 0b 	mcall	80004d40 <prvUnlockQueue+0x94>
80004d18:	c0 30       	breq	80004d1e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80004d1a:	f0 1f 00 0b 	mcall	80004d44 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80004d1e:	6f 18       	ld.w	r8,r7[0x44]
80004d20:	20 18       	sub	r8,1
80004d22:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004d26:	58 08       	cp.w	r8,0
80004d28:	fe 99 ff f2 	brgt	80004d0c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80004d2c:	3f f8       	mov	r8,-1
80004d2e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80004d32:	f0 1f 00 06 	mcall	80004d48 <prvUnlockQueue+0x9c>
}
80004d36:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d3a:	00 00       	add	r0,r0
80004d3c:	80 00       	ld.sh	r0,r0[0x0]
80004d3e:	49 98       	lddpc	r8,80004da0 <xQueueGenericReceive+0x54>
80004d40:	80 00       	ld.sh	r0,r0[0x0]
80004d42:	52 bc       	stdsp	sp[0xac],r12
80004d44:	80 00       	ld.sh	r0,r0[0x0]
80004d46:	51 c8       	stdsp	sp[0x70],r8
80004d48:	80 00       	ld.sh	r0,r0[0x0]
80004d4a:	4a a4       	lddpc	r4,80004df0 <xQueueGenericReceive+0xa4>

80004d4c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80004d4c:	d4 31       	pushm	r0-r7,lr
80004d4e:	20 5d       	sub	sp,20
80004d50:	18 97       	mov	r7,r12
80004d52:	50 0b       	stdsp	sp[0x0],r11
80004d54:	50 2a       	stdsp	sp[0x8],r10
80004d56:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004d58:	f8 c2 ff dc 	sub	r2,r12,-36
80004d5c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004d5e:	fa c4 ff f4 	sub	r4,sp,-12
80004d62:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004d64:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004d66:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80004d6a:	f0 1f 00 3e 	mcall	80004e60 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004d6e:	6e e8       	ld.w	r8,r7[0x38]
80004d70:	58 08       	cp.w	r8,0
80004d72:	c2 a0       	breq	80004dc6 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80004d74:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80004d76:	40 0b       	lddsp	r11,sp[0x0]
80004d78:	0e 9c       	mov	r12,r7
80004d7a:	f0 1f 00 3b 	mcall	80004e64 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80004d7e:	40 18       	lddsp	r8,sp[0x4]
80004d80:	58 08       	cp.w	r8,0
80004d82:	c1 51       	brne	80004dac <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80004d84:	6e e8       	ld.w	r8,r7[0x38]
80004d86:	20 18       	sub	r8,1
80004d88:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004d8a:	6e 08       	ld.w	r8,r7[0x0]
80004d8c:	58 08       	cp.w	r8,0
80004d8e:	c0 41       	brne	80004d96 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80004d90:	f0 1f 00 36 	mcall	80004e68 <xQueueGenericReceive+0x11c>
80004d94:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004d96:	6e 48       	ld.w	r8,r7[0x10]
80004d98:	58 08       	cp.w	r8,0
80004d9a:	c1 20       	breq	80004dbe <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80004d9c:	ee cc ff f0 	sub	r12,r7,-16
80004da0:	f0 1f 00 33 	mcall	80004e6c <xQueueGenericReceive+0x120>
80004da4:	58 1c       	cp.w	r12,1
80004da6:	c0 c1       	brne	80004dbe <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80004da8:	d7 33       	scall
80004daa:	c0 a8       	rjmp	80004dbe <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80004dac:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004dae:	6e 98       	ld.w	r8,r7[0x24]
80004db0:	58 08       	cp.w	r8,0
80004db2:	c0 60       	breq	80004dbe <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004db4:	04 9c       	mov	r12,r2
80004db6:	f0 1f 00 2e 	mcall	80004e6c <xQueueGenericReceive+0x120>
80004dba:	c0 20       	breq	80004dbe <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80004dbc:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80004dbe:	f0 1f 00 2d 	mcall	80004e70 <xQueueGenericReceive+0x124>
80004dc2:	30 1c       	mov	r12,1
				return pdPASS;
80004dc4:	c4 c8       	rjmp	80004e5c <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004dc6:	40 28       	lddsp	r8,sp[0x8]
80004dc8:	58 08       	cp.w	r8,0
80004dca:	c0 51       	brne	80004dd4 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004dcc:	f0 1f 00 29 	mcall	80004e70 <xQueueGenericReceive+0x124>
80004dd0:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80004dd2:	c4 58       	rjmp	80004e5c <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80004dd4:	58 05       	cp.w	r5,0
80004dd6:	c0 51       	brne	80004de0 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004dd8:	08 9c       	mov	r12,r4
80004dda:	f0 1f 00 27 	mcall	80004e74 <xQueueGenericReceive+0x128>
80004dde:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004de0:	f0 1f 00 24 	mcall	80004e70 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004de4:	f0 1f 00 25 	mcall	80004e78 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80004de8:	f0 1f 00 1e 	mcall	80004e60 <xQueueGenericReceive+0x114>
80004dec:	6f 18       	ld.w	r8,r7[0x44]
80004dee:	5b f8       	cp.w	r8,-1
80004df0:	ef f1 0a 11 	st.weq	r7[0x44],r1
80004df4:	6f 28       	ld.w	r8,r7[0x48]
80004df6:	5b f8       	cp.w	r8,-1
80004df8:	ef f1 0a 12 	st.weq	r7[0x48],r1
80004dfc:	f0 1f 00 1d 	mcall	80004e70 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004e00:	06 9b       	mov	r11,r3
80004e02:	08 9c       	mov	r12,r4
80004e04:	f0 1f 00 1e 	mcall	80004e7c <xQueueGenericReceive+0x130>
80004e08:	c2 41       	brne	80004e50 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80004e0a:	f0 1f 00 16 	mcall	80004e60 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80004e0e:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80004e10:	f0 1f 00 18 	mcall	80004e70 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80004e14:	58 06       	cp.w	r6,0
80004e16:	c1 71       	brne	80004e44 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004e18:	6e 08       	ld.w	r8,r7[0x0]
80004e1a:	58 08       	cp.w	r8,0
80004e1c:	c0 81       	brne	80004e2c <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80004e1e:	f0 1f 00 11 	mcall	80004e60 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80004e22:	6e 1c       	ld.w	r12,r7[0x4]
80004e24:	f0 1f 00 17 	mcall	80004e80 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80004e28:	f0 1f 00 12 	mcall	80004e70 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004e2c:	40 2b       	lddsp	r11,sp[0x8]
80004e2e:	04 9c       	mov	r12,r2
80004e30:	f0 1f 00 15 	mcall	80004e84 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
80004e34:	0e 9c       	mov	r12,r7
80004e36:	f0 1f 00 15 	mcall	80004e88 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80004e3a:	f0 1f 00 15 	mcall	80004e8c <xQueueGenericReceive+0x140>
80004e3e:	c9 61       	brne	80004d6a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80004e40:	d7 33       	scall
80004e42:	c9 4b       	rjmp	80004d6a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80004e44:	0e 9c       	mov	r12,r7
80004e46:	f0 1f 00 11 	mcall	80004e88 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80004e4a:	f0 1f 00 11 	mcall	80004e8c <xQueueGenericReceive+0x140>
80004e4e:	c8 eb       	rjmp	80004d6a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80004e50:	0e 9c       	mov	r12,r7
80004e52:	f0 1f 00 0e 	mcall	80004e88 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
80004e56:	f0 1f 00 0e 	mcall	80004e8c <xQueueGenericReceive+0x140>
80004e5a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80004e5c:	2f bd       	sub	sp,-20
80004e5e:	d8 32       	popm	r0-r7,pc
80004e60:	80 00       	ld.sh	r0,r0[0x0]
80004e62:	49 98       	lddpc	r8,80004ec4 <prvCopyDataToQueue+0x34>
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	4c 2c       	lddpc	r12,80004f6c <xQueueGenericSend+0x14>
80004e68:	80 00       	ld.sh	r0,r0[0x0]
80004e6a:	51 d4       	stdsp	sp[0x74],r4
80004e6c:	80 00       	ld.sh	r0,r0[0x0]
80004e6e:	52 bc       	stdsp	sp[0xac],r12
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	4a a4       	lddpc	r4,80004f18 <xQueueGenericSendFromISR+0x10>
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	51 b0       	stdsp	sp[0x6c],r0
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	51 24       	stdsp	sp[0x48],r4
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	54 4c       	stdsp	sp[0x110],r12
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	52 38       	stdsp	sp[0x8c],r8
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	56 a4       	stdsp	sp[0x1a8],r4
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	4c ac       	lddpc	r12,80004fb0 <xQueueGenericSend+0x58>
80004e8c:	80 00       	ld.sh	r0,r0[0x0]
80004e8e:	54 e0       	stdsp	sp[0x138],r0

80004e90 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80004e90:	eb cd 40 80 	pushm	r7,lr
80004e94:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80004e96:	79 08       	ld.w	r8,r12[0x40]
80004e98:	58 08       	cp.w	r8,0
80004e9a:	c0 a1       	brne	80004eae <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004e9c:	78 08       	ld.w	r8,r12[0x0]
80004e9e:	58 08       	cp.w	r8,0
80004ea0:	c2 b1       	brne	80004ef6 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80004ea2:	78 1c       	ld.w	r12,r12[0x4]
80004ea4:	f0 1f 00 17 	mcall	80004f00 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80004ea8:	30 08       	mov	r8,0
80004eaa:	8f 18       	st.w	r7[0x4],r8
80004eac:	c2 58       	rjmp	80004ef6 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80004eae:	58 0a       	cp.w	r10,0
80004eb0:	c1 01       	brne	80004ed0 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80004eb2:	10 9a       	mov	r10,r8
80004eb4:	78 2c       	ld.w	r12,r12[0x8]
80004eb6:	f0 1f 00 14 	mcall	80004f04 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80004eba:	6e 29       	ld.w	r9,r7[0x8]
80004ebc:	6f 08       	ld.w	r8,r7[0x40]
80004ebe:	f2 08 00 08 	add	r8,r9,r8
80004ec2:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80004ec4:	6e 19       	ld.w	r9,r7[0x4]
80004ec6:	12 38       	cp.w	r8,r9
80004ec8:	c1 73       	brcs	80004ef6 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80004eca:	6e 08       	ld.w	r8,r7[0x0]
80004ecc:	8f 28       	st.w	r7[0x8],r8
80004ece:	c1 48       	rjmp	80004ef6 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80004ed0:	10 9a       	mov	r10,r8
80004ed2:	78 3c       	ld.w	r12,r12[0xc]
80004ed4:	f0 1f 00 0c 	mcall	80004f04 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80004ed8:	6f 08       	ld.w	r8,r7[0x40]
80004eda:	6e 39       	ld.w	r9,r7[0xc]
80004edc:	f2 08 01 08 	sub	r8,r9,r8
80004ee0:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80004ee2:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80004ee4:	12 38       	cp.w	r8,r9
80004ee6:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80004eea:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80004eee:	f3 d8 e3 19 	subcs	r9,r9,r8
80004ef2:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80004ef6:	6e e8       	ld.w	r8,r7[0x38]
80004ef8:	2f f8       	sub	r8,-1
80004efa:	8f e8       	st.w	r7[0x38],r8
}
80004efc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f00:	80 00       	ld.sh	r0,r0[0x0]
80004f02:	51 e0       	stdsp	sp[0x78],r0
80004f04:	80 00       	ld.sh	r0,r0[0x0]
80004f06:	64 a8       	ld.w	r8,r2[0x28]

80004f08 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80004f08:	eb cd 40 c0 	pushm	r6-r7,lr
80004f0c:	18 97       	mov	r7,r12
80004f0e:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80004f10:	78 ec       	ld.w	r12,r12[0x38]
80004f12:	6e f8       	ld.w	r8,r7[0x3c]
80004f14:	10 3c       	cp.w	r12,r8
80004f16:	c0 33       	brcs	80004f1c <xQueueGenericSendFromISR+0x14>
80004f18:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80004f1c:	12 9a       	mov	r10,r9
80004f1e:	0e 9c       	mov	r12,r7
80004f20:	f0 1f 00 0c 	mcall	80004f50 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80004f24:	6f 28       	ld.w	r8,r7[0x48]
80004f26:	5b f8       	cp.w	r8,-1
80004f28:	c0 d1       	brne	80004f42 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004f2a:	6e 98       	ld.w	r8,r7[0x24]
80004f2c:	58 08       	cp.w	r8,0
80004f2e:	c0 f0       	breq	80004f4c <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004f30:	ee cc ff dc 	sub	r12,r7,-36
80004f34:	f0 1f 00 08 	mcall	80004f54 <xQueueGenericSendFromISR+0x4c>
80004f38:	c0 a0       	breq	80004f4c <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
80004f3a:	30 1c       	mov	r12,1
80004f3c:	8d 0c       	st.w	r6[0x0],r12
80004f3e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80004f42:	2f f8       	sub	r8,-1
80004f44:	ef 48 00 48 	st.w	r7[72],r8
80004f48:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004f4c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80004f50:	80 00       	ld.sh	r0,r0[0x0]
80004f52:	4e 90       	lddpc	r0,800050f4 <xQueueCreate+0x44>
80004f54:	80 00       	ld.sh	r0,r0[0x0]
80004f56:	52 bc       	stdsp	sp[0xac],r12

80004f58 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80004f58:	d4 31       	pushm	r0-r7,lr
80004f5a:	20 5d       	sub	sp,20
80004f5c:	18 97       	mov	r7,r12
80004f5e:	50 0b       	stdsp	sp[0x0],r11
80004f60:	50 2a       	stdsp	sp[0x8],r10
80004f62:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80004f64:	f8 c0 ff f0 	sub	r0,r12,-16
80004f68:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004f6a:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004f6e:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004f70:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80004f74:	f0 1f 00 2f 	mcall	80005030 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80004f78:	6e e9       	ld.w	r9,r7[0x38]
80004f7a:	6e f8       	ld.w	r8,r7[0x3c]
80004f7c:	10 39       	cp.w	r9,r8
80004f7e:	c1 42       	brcc	80004fa6 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80004f80:	40 1a       	lddsp	r10,sp[0x4]
80004f82:	40 0b       	lddsp	r11,sp[0x0]
80004f84:	0e 9c       	mov	r12,r7
80004f86:	f0 1f 00 2c 	mcall	80005034 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004f8a:	6e 98       	ld.w	r8,r7[0x24]
80004f8c:	58 08       	cp.w	r8,0
80004f8e:	c0 80       	breq	80004f9e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80004f90:	ee cc ff dc 	sub	r12,r7,-36
80004f94:	f0 1f 00 29 	mcall	80005038 <xQueueGenericSend+0xe0>
80004f98:	58 1c       	cp.w	r12,1
80004f9a:	c0 21       	brne	80004f9e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80004f9c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80004f9e:	f0 1f 00 28 	mcall	8000503c <xQueueGenericSend+0xe4>
80004fa2:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80004fa4:	c4 38       	rjmp	8000502a <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004fa6:	40 28       	lddsp	r8,sp[0x8]
80004fa8:	58 08       	cp.w	r8,0
80004faa:	c0 51       	brne	80004fb4 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004fac:	f0 1f 00 24 	mcall	8000503c <xQueueGenericSend+0xe4>
80004fb0:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80004fb2:	c3 c8       	rjmp	8000502a <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80004fb4:	58 04       	cp.w	r4,0
80004fb6:	c0 51       	brne	80004fc0 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004fb8:	06 9c       	mov	r12,r3
80004fba:	f0 1f 00 22 	mcall	80005040 <xQueueGenericSend+0xe8>
80004fbe:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80004fc0:	f0 1f 00 1f 	mcall	8000503c <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80004fc4:	f0 1f 00 20 	mcall	80005044 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80004fc8:	f0 1f 00 1a 	mcall	80005030 <xQueueGenericSend+0xd8>
80004fcc:	6f 18       	ld.w	r8,r7[0x44]
80004fce:	5b f8       	cp.w	r8,-1
80004fd0:	ef f1 0a 11 	st.weq	r7[0x44],r1
80004fd4:	6f 28       	ld.w	r8,r7[0x48]
80004fd6:	5b f8       	cp.w	r8,-1
80004fd8:	ef f1 0a 12 	st.weq	r7[0x48],r1
80004fdc:	f0 1f 00 18 	mcall	8000503c <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004fe0:	04 9b       	mov	r11,r2
80004fe2:	06 9c       	mov	r12,r3
80004fe4:	f0 1f 00 19 	mcall	80005048 <xQueueGenericSend+0xf0>
80004fe8:	c1 b1       	brne	8000501e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80004fea:	f0 1f 00 12 	mcall	80005030 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
80004fee:	6e e5       	ld.w	r5,r7[0x38]
80004ff0:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80004ff2:	f0 1f 00 13 	mcall	8000503c <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80004ff6:	0c 35       	cp.w	r5,r6
80004ff8:	c0 d1       	brne	80005012 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80004ffa:	40 2b       	lddsp	r11,sp[0x8]
80004ffc:	00 9c       	mov	r12,r0
80004ffe:	f0 1f 00 14 	mcall	8000504c <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80005002:	0e 9c       	mov	r12,r7
80005004:	f0 1f 00 13 	mcall	80005050 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80005008:	f0 1f 00 13 	mcall	80005054 <xQueueGenericSend+0xfc>
8000500c:	cb 41       	brne	80004f74 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000500e:	d7 33       	scall
80005010:	cb 2b       	rjmp	80004f74 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80005012:	0e 9c       	mov	r12,r7
80005014:	f0 1f 00 0f 	mcall	80005050 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80005018:	f0 1f 00 0f 	mcall	80005054 <xQueueGenericSend+0xfc>
8000501c:	ca cb       	rjmp	80004f74 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000501e:	0e 9c       	mov	r12,r7
80005020:	f0 1f 00 0c 	mcall	80005050 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
80005024:	f0 1f 00 0c 	mcall	80005054 <xQueueGenericSend+0xfc>
80005028:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
8000502a:	2f bd       	sub	sp,-20
8000502c:	d8 32       	popm	r0-r7,pc
8000502e:	00 00       	add	r0,r0
80005030:	80 00       	ld.sh	r0,r0[0x0]
80005032:	49 98       	lddpc	r8,80005094 <xQueueCreateMutex+0x3c>
80005034:	80 00       	ld.sh	r0,r0[0x0]
80005036:	4e 90       	lddpc	r0,800051d8 <xTaskGetCurrentTaskHandle+0x4>
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	52 bc       	stdsp	sp[0xac],r12
8000503c:	80 00       	ld.sh	r0,r0[0x0]
8000503e:	4a a4       	lddpc	r4,800050e4 <xQueueCreate+0x34>
80005040:	80 00       	ld.sh	r0,r0[0x0]
80005042:	51 b0       	stdsp	sp[0x6c],r0
80005044:	80 00       	ld.sh	r0,r0[0x0]
80005046:	51 24       	stdsp	sp[0x48],r4
80005048:	80 00       	ld.sh	r0,r0[0x0]
8000504a:	54 4c       	stdsp	sp[0x110],r12
8000504c:	80 00       	ld.sh	r0,r0[0x0]
8000504e:	56 a4       	stdsp	sp[0x1a8],r4
80005050:	80 00       	ld.sh	r0,r0[0x0]
80005052:	4c ac       	lddpc	r12,80005178 <vTaskSwitchContext+0x44>
80005054:	80 00       	ld.sh	r0,r0[0x0]
80005056:	54 e0       	stdsp	sp[0x138],r0

80005058 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005058:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000505c:	34 cc       	mov	r12,76
8000505e:	f0 1f 00 12 	mcall	800050a4 <xQueueCreateMutex+0x4c>
80005062:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80005064:	c1 d0       	breq	8000509e <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80005066:	30 06       	mov	r6,0
80005068:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000506a:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
8000506c:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
8000506e:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005070:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
80005072:	30 18       	mov	r8,1
80005074:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
80005076:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
8000507a:	3f f8       	mov	r8,-1
8000507c:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80005080:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005084:	2f 0c       	sub	r12,-16
80005086:	f0 1f 00 09 	mcall	800050a8 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000508a:	ee cc ff dc 	sub	r12,r7,-36
8000508e:	f0 1f 00 07 	mcall	800050a8 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80005092:	0c 99       	mov	r9,r6
80005094:	0c 9a       	mov	r10,r6
80005096:	0c 9b       	mov	r11,r6
80005098:	0e 9c       	mov	r12,r7
8000509a:	f0 1f 00 05 	mcall	800050ac <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
8000509e:	0e 9c       	mov	r12,r7
800050a0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	4c 04       	lddpc	r4,800051a4 <vTaskSwitchContext+0x70>
800050a8:	80 00       	ld.sh	r0,r0[0x0]
800050aa:	48 74       	lddpc	r4,800050c4 <xQueueCreate+0x14>
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	4f 58       	lddpc	r8,80005280 <vTaskPriorityInherit+0x48>

800050b0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
800050b0:	d4 21       	pushm	r4-r7,lr
800050b2:	18 97       	mov	r7,r12
800050b4:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
800050b6:	58 0c       	cp.w	r12,0
800050b8:	c2 f0       	breq	80005116 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800050ba:	34 cc       	mov	r12,76
800050bc:	f0 1f 00 17 	mcall	80005118 <xQueueCreate+0x68>
800050c0:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
800050c2:	c2 a0       	breq	80005116 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
800050c4:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800050c8:	e8 cc ff ff 	sub	r12,r4,-1
800050cc:	f0 1f 00 13 	mcall	80005118 <xQueueCreate+0x68>
800050d0:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800050d2:	c1 e0       	breq	8000510e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800050d4:	f8 04 00 04 	add	r4,r12,r4
800050d8:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800050da:	30 08       	mov	r8,0
800050dc:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800050de:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800050e0:	ee c8 00 01 	sub	r8,r7,1
800050e4:	ad 38       	mul	r8,r6
800050e6:	10 0c       	add	r12,r8
800050e8:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800050ea:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800050ec:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800050f0:	3f f8       	mov	r8,-1
800050f2:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800050f6:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800050fa:	ea cc ff f0 	sub	r12,r5,-16
800050fe:	f0 1f 00 08 	mcall	8000511c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005102:	ea cc ff dc 	sub	r12,r5,-36
80005106:	f0 1f 00 06 	mcall	8000511c <xQueueCreate+0x6c>
8000510a:	0a 9c       	mov	r12,r5
8000510c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000510e:	0a 9c       	mov	r12,r5
80005110:	f0 1f 00 04 	mcall	80005120 <xQueueCreate+0x70>
80005114:	d8 2a       	popm	r4-r7,pc,r12=0
80005116:	d8 2a       	popm	r4-r7,pc,r12=0
80005118:	80 00       	ld.sh	r0,r0[0x0]
8000511a:	4c 04       	lddpc	r4,80005218 <vTaskPriorityDisinherit+0x38>
8000511c:	80 00       	ld.sh	r0,r0[0x0]
8000511e:	48 74       	lddpc	r4,80005138 <vTaskSwitchContext+0x4>
80005120:	80 00       	ld.sh	r0,r0[0x0]
80005122:	4b dc       	lddpc	r12,80005214 <vTaskPriorityDisinherit+0x34>

80005124 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80005124:	48 38       	lddpc	r8,80005130 <vTaskSuspendAll+0xc>
80005126:	70 09       	ld.w	r9,r8[0x0]
80005128:	2f f9       	sub	r9,-1
8000512a:	91 09       	st.w	r8[0x0],r9
}
8000512c:	5e fc       	retal	r12
8000512e:	00 00       	add	r0,r0
80005130:	00 00       	add	r0,r0
80005132:	0d 30       	ld.ub	r0,r6++

80005134 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005134:	49 a8       	lddpc	r8,8000519c <vTaskSwitchContext+0x68>
80005136:	70 08       	ld.w	r8,r8[0x0]
80005138:	58 08       	cp.w	r8,0
8000513a:	c0 b1       	brne	80005150 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000513c:	49 98       	lddpc	r8,800051a0 <vTaskSwitchContext+0x6c>
8000513e:	70 08       	ld.w	r8,r8[0x0]
80005140:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005144:	49 89       	lddpc	r9,800051a4 <vTaskSwitchContext+0x70>
80005146:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
8000514a:	58 08       	cp.w	r8,0
8000514c:	c0 60       	breq	80005158 <vTaskSwitchContext+0x24>
8000514e:	c1 18       	rjmp	80005170 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005150:	30 19       	mov	r9,1
80005152:	49 68       	lddpc	r8,800051a8 <vTaskSwitchContext+0x74>
80005154:	91 09       	st.w	r8[0x0],r9
80005156:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005158:	49 28       	lddpc	r8,800051a0 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000515a:	49 3a       	lddpc	r10,800051a4 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000515c:	70 09       	ld.w	r9,r8[0x0]
8000515e:	20 19       	sub	r9,1
80005160:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005162:	70 09       	ld.w	r9,r8[0x0]
80005164:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005168:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
8000516c:	58 09       	cp.w	r9,0
8000516e:	cf 70       	breq	8000515c <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005170:	48 c8       	lddpc	r8,800051a0 <vTaskSwitchContext+0x6c>
80005172:	70 08       	ld.w	r8,r8[0x0]
80005174:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005178:	48 b9       	lddpc	r9,800051a4 <vTaskSwitchContext+0x70>
8000517a:	f2 08 00 28 	add	r8,r9,r8<<0x2
8000517e:	70 19       	ld.w	r9,r8[0x4]
80005180:	72 19       	ld.w	r9,r9[0x4]
80005182:	91 19       	st.w	r8[0x4],r9
80005184:	f0 ca ff f8 	sub	r10,r8,-8
80005188:	14 39       	cp.w	r9,r10
8000518a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000518e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005192:	70 18       	ld.w	r8,r8[0x4]
80005194:	70 39       	ld.w	r9,r8[0xc]
80005196:	48 68       	lddpc	r8,800051ac <vTaskSwitchContext+0x78>
80005198:	91 09       	st.w	r8[0x0],r9
8000519a:	5e fc       	retal	r12
8000519c:	00 00       	add	r0,r0
8000519e:	0d 30       	ld.ub	r0,r6++
800051a0:	00 00       	add	r0,r0
800051a2:	0d 68       	ld.uh	r8,--r6
800051a4:	00 00       	add	r0,r0
800051a6:	0c 4c       	or	r12,r6
800051a8:	00 00       	add	r0,r0
800051aa:	0d 50       	ld.sh	r0,--r6
800051ac:	00 00       	add	r0,r0
800051ae:	0d 00       	ld.w	r0,r6++

800051b0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
800051b0:	48 48       	lddpc	r8,800051c0 <vTaskSetTimeOutState+0x10>
800051b2:	70 08       	ld.w	r8,r8[0x0]
800051b4:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
800051b6:	48 48       	lddpc	r8,800051c4 <vTaskSetTimeOutState+0x14>
800051b8:	70 08       	ld.w	r8,r8[0x0]
800051ba:	99 18       	st.w	r12[0x4],r8
}
800051bc:	5e fc       	retal	r12
800051be:	00 00       	add	r0,r0
800051c0:	00 00       	add	r0,r0
800051c2:	0c 44       	or	r4,r6
800051c4:	00 00       	add	r0,r0
800051c6:	0d 2c       	ld.uh	r12,r6++

800051c8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800051c8:	30 19       	mov	r9,1
800051ca:	48 28       	lddpc	r8,800051d0 <vTaskMissedYield+0x8>
800051cc:	91 09       	st.w	r8[0x0],r9
}
800051ce:	5e fc       	retal	r12
800051d0:	00 00       	add	r0,r0
800051d2:	0d 50       	ld.sh	r0,--r6

800051d4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800051d4:	48 28       	lddpc	r8,800051dc <xTaskGetCurrentTaskHandle+0x8>
800051d6:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800051d8:	5e fc       	retal	r12
800051da:	00 00       	add	r0,r0
800051dc:	00 00       	add	r0,r0
800051de:	0d 00       	ld.w	r0,r6++

800051e0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800051e0:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800051e4:	58 0c       	cp.w	r12,0
800051e6:	c1 f0       	breq	80005224 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800051e8:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800051ea:	78 b9       	ld.w	r9,r12[0x2c]
800051ec:	79 18       	ld.w	r8,r12[0x44]
800051ee:	10 39       	cp.w	r9,r8
800051f0:	c1 a0       	breq	80005224 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800051f2:	f8 c6 ff fc 	sub	r6,r12,-4
800051f6:	0c 9c       	mov	r12,r6
800051f8:	f0 1f 00 0c 	mcall	80005228 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800051fc:	6f 1c       	ld.w	r12,r7[0x44]
800051fe:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005200:	f8 08 11 08 	rsub	r8,r12,8
80005204:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005206:	48 a8       	lddpc	r8,8000522c <vTaskPriorityDisinherit+0x4c>
80005208:	70 08       	ld.w	r8,r8[0x0]
8000520a:	10 3c       	cp.w	r12,r8
8000520c:	e0 88 00 04 	brls	80005214 <vTaskPriorityDisinherit+0x34>
80005210:	48 78       	lddpc	r8,8000522c <vTaskPriorityDisinherit+0x4c>
80005212:	91 0c       	st.w	r8[0x0],r12
80005214:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005218:	0c 9b       	mov	r11,r6
8000521a:	48 68       	lddpc	r8,80005230 <vTaskPriorityDisinherit+0x50>
8000521c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005220:	f0 1f 00 05 	mcall	80005234 <vTaskPriorityDisinherit+0x54>
80005224:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	48 de       	lddpc	lr,8000525c <vTaskPriorityInherit+0x24>
8000522c:	00 00       	add	r0,r0
8000522e:	0d 68       	ld.uh	r8,--r6
80005230:	00 00       	add	r0,r0
80005232:	0c 4c       	or	r12,r6
80005234:	80 00       	ld.sh	r0,r0[0x0]
80005236:	48 8e       	lddpc	lr,80005254 <vTaskPriorityInherit+0x1c>

80005238 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005238:	eb cd 40 c0 	pushm	r6-r7,lr
8000523c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000523e:	49 b8       	lddpc	r8,800052a8 <vTaskPriorityInherit+0x70>
80005240:	70 08       	ld.w	r8,r8[0x0]
80005242:	78 b9       	ld.w	r9,r12[0x2c]
80005244:	70 b8       	ld.w	r8,r8[0x2c]
80005246:	10 39       	cp.w	r9,r8
80005248:	c2 d2       	brcc	800052a2 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000524a:	49 88       	lddpc	r8,800052a8 <vTaskPriorityInherit+0x70>
8000524c:	70 08       	ld.w	r8,r8[0x0]
8000524e:	70 b8       	ld.w	r8,r8[0x2c]
80005250:	f0 08 11 08 	rsub	r8,r8,8
80005254:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80005256:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000525a:	49 59       	lddpc	r9,800052ac <vTaskPriorityInherit+0x74>
8000525c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005260:	78 59       	ld.w	r9,r12[0x14]
80005262:	10 39       	cp.w	r9,r8
80005264:	c1 b1       	brne	8000529a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80005266:	f8 c6 ff fc 	sub	r6,r12,-4
8000526a:	0c 9c       	mov	r12,r6
8000526c:	f0 1f 00 11 	mcall	800052b0 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005270:	48 e8       	lddpc	r8,800052a8 <vTaskPriorityInherit+0x70>
80005272:	70 08       	ld.w	r8,r8[0x0]
80005274:	70 bc       	ld.w	r12,r8[0x2c]
80005276:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005278:	48 f8       	lddpc	r8,800052b4 <vTaskPriorityInherit+0x7c>
8000527a:	70 08       	ld.w	r8,r8[0x0]
8000527c:	10 3c       	cp.w	r12,r8
8000527e:	e0 88 00 04 	brls	80005286 <vTaskPriorityInherit+0x4e>
80005282:	48 d8       	lddpc	r8,800052b4 <vTaskPriorityInherit+0x7c>
80005284:	91 0c       	st.w	r8[0x0],r12
80005286:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000528a:	0c 9b       	mov	r11,r6
8000528c:	48 88       	lddpc	r8,800052ac <vTaskPriorityInherit+0x74>
8000528e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005292:	f0 1f 00 0a 	mcall	800052b8 <vTaskPriorityInherit+0x80>
80005296:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000529a:	48 48       	lddpc	r8,800052a8 <vTaskPriorityInherit+0x70>
8000529c:	70 08       	ld.w	r8,r8[0x0]
8000529e:	70 b8       	ld.w	r8,r8[0x2c]
800052a0:	99 b8       	st.w	r12[0x2c],r8
800052a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800052a6:	00 00       	add	r0,r0
800052a8:	00 00       	add	r0,r0
800052aa:	0d 00       	ld.w	r0,r6++
800052ac:	00 00       	add	r0,r0
800052ae:	0c 4c       	or	r12,r6
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	48 de       	lddpc	lr,800052e4 <xTaskRemoveFromEventList+0x28>
800052b4:	00 00       	add	r0,r0
800052b6:	0d 68       	ld.uh	r8,--r6
800052b8:	80 00       	ld.sh	r0,r0[0x0]
800052ba:	48 8e       	lddpc	lr,800052d8 <xTaskRemoveFromEventList+0x1c>

800052bc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800052bc:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800052c0:	78 38       	ld.w	r8,r12[0xc]
800052c2:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800052c4:	ee c6 ff e8 	sub	r6,r7,-24
800052c8:	0c 9c       	mov	r12,r6
800052ca:	f0 1f 00 15 	mcall	8000531c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800052ce:	49 58       	lddpc	r8,80005320 <xTaskRemoveFromEventList+0x64>
800052d0:	70 08       	ld.w	r8,r8[0x0]
800052d2:	58 08       	cp.w	r8,0
800052d4:	c1 71       	brne	80005302 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800052d6:	ee c6 ff fc 	sub	r6,r7,-4
800052da:	0c 9c       	mov	r12,r6
800052dc:	f0 1f 00 10 	mcall	8000531c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800052e0:	6e bc       	ld.w	r12,r7[0x2c]
800052e2:	49 18       	lddpc	r8,80005324 <xTaskRemoveFromEventList+0x68>
800052e4:	70 08       	ld.w	r8,r8[0x0]
800052e6:	10 3c       	cp.w	r12,r8
800052e8:	e0 88 00 04 	brls	800052f0 <xTaskRemoveFromEventList+0x34>
800052ec:	48 e8       	lddpc	r8,80005324 <xTaskRemoveFromEventList+0x68>
800052ee:	91 0c       	st.w	r8[0x0],r12
800052f0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800052f4:	0c 9b       	mov	r11,r6
800052f6:	48 d8       	lddpc	r8,80005328 <xTaskRemoveFromEventList+0x6c>
800052f8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800052fc:	f0 1f 00 0c 	mcall	8000532c <xTaskRemoveFromEventList+0x70>
80005300:	c0 58       	rjmp	8000530a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005302:	0c 9b       	mov	r11,r6
80005304:	48 bc       	lddpc	r12,80005330 <xTaskRemoveFromEventList+0x74>
80005306:	f0 1f 00 0a 	mcall	8000532c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000530a:	48 b8       	lddpc	r8,80005334 <xTaskRemoveFromEventList+0x78>
8000530c:	70 08       	ld.w	r8,r8[0x0]
8000530e:	6e b9       	ld.w	r9,r7[0x2c]
80005310:	70 b8       	ld.w	r8,r8[0x2c]
80005312:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005314:	5f 2c       	srhs	r12
80005316:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000531a:	00 00       	add	r0,r0
8000531c:	80 00       	ld.sh	r0,r0[0x0]
8000531e:	48 de       	lddpc	lr,80005350 <vTaskIncrementTick+0x18>
80005320:	00 00       	add	r0,r0
80005322:	0d 30       	ld.ub	r0,r6++
80005324:	00 00       	add	r0,r0
80005326:	0d 68       	ld.uh	r8,--r6
80005328:	00 00       	add	r0,r0
8000532a:	0c 4c       	or	r12,r6
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	48 8e       	lddpc	lr,8000534c <vTaskIncrementTick+0x14>
80005330:	00 00       	add	r0,r0
80005332:	0d 04       	ld.w	r4,r6++
80005334:	00 00       	add	r0,r0
80005336:	0d 00       	ld.w	r0,r6++

80005338 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005338:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000533c:	4b 98       	lddpc	r8,80005420 <vTaskIncrementTick+0xe8>
8000533e:	70 08       	ld.w	r8,r8[0x0]
80005340:	58 08       	cp.w	r8,0
80005342:	c6 91       	brne	80005414 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005344:	4b 88       	lddpc	r8,80005424 <vTaskIncrementTick+0xec>
80005346:	70 09       	ld.w	r9,r8[0x0]
80005348:	2f f9       	sub	r9,-1
8000534a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000534c:	70 08       	ld.w	r8,r8[0x0]
8000534e:	58 08       	cp.w	r8,0
80005350:	c1 a1       	brne	80005384 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005352:	4b 68       	lddpc	r8,80005428 <vTaskIncrementTick+0xf0>
80005354:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005356:	4b 69       	lddpc	r9,8000542c <vTaskIncrementTick+0xf4>
80005358:	72 0b       	ld.w	r11,r9[0x0]
8000535a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
8000535c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
8000535e:	4b 59       	lddpc	r9,80005430 <vTaskIncrementTick+0xf8>
80005360:	72 0a       	ld.w	r10,r9[0x0]
80005362:	2f fa       	sub	r10,-1
80005364:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005366:	70 08       	ld.w	r8,r8[0x0]
80005368:	70 08       	ld.w	r8,r8[0x0]
8000536a:	58 08       	cp.w	r8,0
8000536c:	c0 51       	brne	80005376 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
8000536e:	3f f9       	mov	r9,-1
80005370:	4b 18       	lddpc	r8,80005434 <vTaskIncrementTick+0xfc>
80005372:	91 09       	st.w	r8[0x0],r9
80005374:	c0 88       	rjmp	80005384 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005376:	4a d8       	lddpc	r8,80005428 <vTaskIncrementTick+0xf0>
80005378:	70 08       	ld.w	r8,r8[0x0]
8000537a:	70 38       	ld.w	r8,r8[0xc]
8000537c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
8000537e:	70 19       	ld.w	r9,r8[0x4]
80005380:	4a d8       	lddpc	r8,80005434 <vTaskIncrementTick+0xfc>
80005382:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005384:	4a 88       	lddpc	r8,80005424 <vTaskIncrementTick+0xec>
80005386:	70 09       	ld.w	r9,r8[0x0]
80005388:	4a b8       	lddpc	r8,80005434 <vTaskIncrementTick+0xfc>
8000538a:	70 08       	ld.w	r8,r8[0x0]
8000538c:	10 39       	cp.w	r9,r8
8000538e:	c4 73       	brcs	8000541c <vTaskIncrementTick+0xe4>
80005390:	4a 68       	lddpc	r8,80005428 <vTaskIncrementTick+0xf0>
80005392:	70 08       	ld.w	r8,r8[0x0]
80005394:	70 08       	ld.w	r8,r8[0x0]
80005396:	58 08       	cp.w	r8,0
80005398:	c0 c0       	breq	800053b0 <vTaskIncrementTick+0x78>
8000539a:	4a 48       	lddpc	r8,80005428 <vTaskIncrementTick+0xf0>
8000539c:	70 08       	ld.w	r8,r8[0x0]
8000539e:	70 38       	ld.w	r8,r8[0xc]
800053a0:	70 37       	ld.w	r7,r8[0xc]
800053a2:	6e 18       	ld.w	r8,r7[0x4]
800053a4:	4a 09       	lddpc	r9,80005424 <vTaskIncrementTick+0xec>
800053a6:	72 09       	ld.w	r9,r9[0x0]
800053a8:	12 38       	cp.w	r8,r9
800053aa:	e0 88 00 14 	brls	800053d2 <vTaskIncrementTick+0x9a>
800053ae:	c0 e8       	rjmp	800053ca <vTaskIncrementTick+0x92>
800053b0:	3f f9       	mov	r9,-1
800053b2:	4a 18       	lddpc	r8,80005434 <vTaskIncrementTick+0xfc>
800053b4:	91 09       	st.w	r8[0x0],r9
800053b6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800053ba:	6a 08       	ld.w	r8,r5[0x0]
800053bc:	70 38       	ld.w	r8,r8[0xc]
800053be:	70 37       	ld.w	r7,r8[0xc]
800053c0:	6e 18       	ld.w	r8,r7[0x4]
800053c2:	64 09       	ld.w	r9,r2[0x0]
800053c4:	12 38       	cp.w	r8,r9
800053c6:	e0 88 00 0a 	brls	800053da <vTaskIncrementTick+0xa2>
800053ca:	49 b9       	lddpc	r9,80005434 <vTaskIncrementTick+0xfc>
800053cc:	93 08       	st.w	r9[0x0],r8
800053ce:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800053d2:	49 a4       	lddpc	r4,80005438 <vTaskIncrementTick+0x100>
800053d4:	49 a3       	lddpc	r3,8000543c <vTaskIncrementTick+0x104>
800053d6:	49 55       	lddpc	r5,80005428 <vTaskIncrementTick+0xf0>
800053d8:	49 32       	lddpc	r2,80005424 <vTaskIncrementTick+0xec>
800053da:	ee c6 ff fc 	sub	r6,r7,-4
800053de:	0c 9c       	mov	r12,r6
800053e0:	f0 1f 00 18 	mcall	80005440 <vTaskIncrementTick+0x108>
800053e4:	6e a8       	ld.w	r8,r7[0x28]
800053e6:	58 08       	cp.w	r8,0
800053e8:	c0 50       	breq	800053f2 <vTaskIncrementTick+0xba>
800053ea:	ee cc ff e8 	sub	r12,r7,-24
800053ee:	f0 1f 00 15 	mcall	80005440 <vTaskIncrementTick+0x108>
800053f2:	6e bc       	ld.w	r12,r7[0x2c]
800053f4:	68 08       	ld.w	r8,r4[0x0]
800053f6:	10 3c       	cp.w	r12,r8
800053f8:	e9 fc ba 00 	st.whi	r4[0x0],r12
800053fc:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005400:	0c 9b       	mov	r11,r6
80005402:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005406:	f0 1f 00 10 	mcall	80005444 <vTaskIncrementTick+0x10c>
8000540a:	6a 08       	ld.w	r8,r5[0x0]
8000540c:	70 08       	ld.w	r8,r8[0x0]
8000540e:	58 08       	cp.w	r8,0
80005410:	cd 51       	brne	800053ba <vTaskIncrementTick+0x82>
80005412:	cc fb       	rjmp	800053b0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005414:	48 d8       	lddpc	r8,80005448 <vTaskIncrementTick+0x110>
80005416:	70 09       	ld.w	r9,r8[0x0]
80005418:	2f f9       	sub	r9,-1
8000541a:	91 09       	st.w	r8[0x0],r9
8000541c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005420:	00 00       	add	r0,r0
80005422:	0d 30       	ld.ub	r0,r6++
80005424:	00 00       	add	r0,r0
80005426:	0d 2c       	ld.uh	r12,r6++
80005428:	00 00       	add	r0,r0
8000542a:	0c 38       	cp.w	r8,r6
8000542c:	00 00       	add	r0,r0
8000542e:	0c 48       	or	r8,r6
80005430:	00 00       	add	r0,r0
80005432:	0c 44       	or	r4,r6
80005434:	00 00       	add	r0,r0
80005436:	05 34       	ld.ub	r4,r2++
80005438:	00 00       	add	r0,r0
8000543a:	0d 68       	ld.uh	r8,--r6
8000543c:	00 00       	add	r0,r0
8000543e:	0c 4c       	or	r12,r6
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	48 de       	lddpc	lr,80005474 <xTaskCheckForTimeOut+0x28>
80005444:	80 00       	ld.sh	r0,r0[0x0]
80005446:	48 8e       	lddpc	lr,80005464 <xTaskCheckForTimeOut+0x18>
80005448:	00 00       	add	r0,r0
8000544a:	0c 30       	cp.w	r0,r6

8000544c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000544c:	eb cd 40 c0 	pushm	r6-r7,lr
80005450:	18 97       	mov	r7,r12
80005452:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005454:	f0 1f 00 15 	mcall	800054a8 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005458:	6c 08       	ld.w	r8,r6[0x0]
8000545a:	5b f8       	cp.w	r8,-1
8000545c:	c0 31       	brne	80005462 <xTaskCheckForTimeOut+0x16>
8000545e:	30 07       	mov	r7,0
80005460:	c1 f8       	rjmp	8000549e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005462:	49 39       	lddpc	r9,800054ac <xTaskCheckForTimeOut+0x60>
80005464:	72 09       	ld.w	r9,r9[0x0]
80005466:	6e 0a       	ld.w	r10,r7[0x0]
80005468:	12 3a       	cp.w	r10,r9
8000546a:	c0 70       	breq	80005478 <xTaskCheckForTimeOut+0x2c>
8000546c:	49 19       	lddpc	r9,800054b0 <xTaskCheckForTimeOut+0x64>
8000546e:	72 09       	ld.w	r9,r9[0x0]
80005470:	6e 1a       	ld.w	r10,r7[0x4]
80005472:	12 3a       	cp.w	r10,r9
80005474:	e0 88 00 14 	brls	8000549c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005478:	48 e9       	lddpc	r9,800054b0 <xTaskCheckForTimeOut+0x64>
8000547a:	72 0a       	ld.w	r10,r9[0x0]
8000547c:	6e 19       	ld.w	r9,r7[0x4]
8000547e:	12 1a       	sub	r10,r9
80005480:	14 38       	cp.w	r8,r10
80005482:	e0 88 00 0d 	brls	8000549c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005486:	48 ba       	lddpc	r10,800054b0 <xTaskCheckForTimeOut+0x64>
80005488:	74 0a       	ld.w	r10,r10[0x0]
8000548a:	14 19       	sub	r9,r10
8000548c:	f2 08 00 08 	add	r8,r9,r8
80005490:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005492:	0e 9c       	mov	r12,r7
80005494:	f0 1f 00 08 	mcall	800054b4 <xTaskCheckForTimeOut+0x68>
80005498:	30 07       	mov	r7,0
8000549a:	c0 28       	rjmp	8000549e <xTaskCheckForTimeOut+0x52>
8000549c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000549e:	f0 1f 00 07 	mcall	800054b8 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
800054a2:	0e 9c       	mov	r12,r7
800054a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800054a8:	80 00       	ld.sh	r0,r0[0x0]
800054aa:	49 98       	lddpc	r8,8000550c <xTaskResumeAll+0x2c>
800054ac:	00 00       	add	r0,r0
800054ae:	0c 44       	or	r4,r6
800054b0:	00 00       	add	r0,r0
800054b2:	0d 2c       	ld.uh	r12,r6++
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	51 b0       	stdsp	sp[0x6c],r0
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	4a a4       	lddpc	r4,80005560 <xTaskResumeAll+0x80>

800054bc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
800054bc:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800054c0:	f0 1f 00 05 	mcall	800054d4 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800054c4:	48 58       	lddpc	r8,800054d8 <xTaskGetTickCount+0x1c>
800054c6:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800054c8:	f0 1f 00 05 	mcall	800054dc <xTaskGetTickCount+0x20>

	return xTicks;
}
800054cc:	0e 9c       	mov	r12,r7
800054ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800054d2:	00 00       	add	r0,r0
800054d4:	80 00       	ld.sh	r0,r0[0x0]
800054d6:	49 98       	lddpc	r8,80005538 <xTaskResumeAll+0x58>
800054d8:	00 00       	add	r0,r0
800054da:	0d 2c       	ld.uh	r12,r6++
800054dc:	80 00       	ld.sh	r0,r0[0x0]
800054de:	4a a4       	lddpc	r4,80005584 <xTaskResumeAll+0xa4>

800054e0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800054e0:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800054e4:	f0 1f 00 2c 	mcall	80005594 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800054e8:	4a c8       	lddpc	r8,80005598 <xTaskResumeAll+0xb8>
800054ea:	70 09       	ld.w	r9,r8[0x0]
800054ec:	20 19       	sub	r9,1
800054ee:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800054f0:	70 08       	ld.w	r8,r8[0x0]
800054f2:	58 08       	cp.w	r8,0
800054f4:	c4 91       	brne	80005586 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800054f6:	4a a8       	lddpc	r8,8000559c <xTaskResumeAll+0xbc>
800054f8:	70 08       	ld.w	r8,r8[0x0]
800054fa:	58 08       	cp.w	r8,0
800054fc:	c4 50       	breq	80005586 <xTaskResumeAll+0xa6>
800054fe:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005500:	4a 85       	lddpc	r5,800055a0 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005502:	4a 93       	lddpc	r3,800055a4 <xTaskResumeAll+0xc4>
80005504:	4a 92       	lddpc	r2,800055a8 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005506:	4a a1       	lddpc	r1,800055ac <xTaskResumeAll+0xcc>
80005508:	c1 e8       	rjmp	80005544 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
8000550a:	6a 38       	ld.w	r8,r5[0xc]
8000550c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000550e:	ee cc ff e8 	sub	r12,r7,-24
80005512:	f0 1f 00 28 	mcall	800055b0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005516:	ee c6 ff fc 	sub	r6,r7,-4
8000551a:	0c 9c       	mov	r12,r6
8000551c:	f0 1f 00 25 	mcall	800055b0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005520:	6e bc       	ld.w	r12,r7[0x2c]
80005522:	66 08       	ld.w	r8,r3[0x0]
80005524:	10 3c       	cp.w	r12,r8
80005526:	e7 fc ba 00 	st.whi	r3[0x0],r12
8000552a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000552e:	0c 9b       	mov	r11,r6
80005530:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005534:	f0 1f 00 20 	mcall	800055b4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005538:	62 08       	ld.w	r8,r1[0x0]
8000553a:	6e b9       	ld.w	r9,r7[0x2c]
8000553c:	70 b8       	ld.w	r8,r8[0x2c]
8000553e:	10 39       	cp.w	r9,r8
80005540:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005544:	6a 08       	ld.w	r8,r5[0x0]
80005546:	58 08       	cp.w	r8,0
80005548:	ce 11       	brne	8000550a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000554a:	49 c8       	lddpc	r8,800055b8 <xTaskResumeAll+0xd8>
8000554c:	70 08       	ld.w	r8,r8[0x0]
8000554e:	58 08       	cp.w	r8,0
80005550:	c0 f0       	breq	8000556e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005552:	49 a8       	lddpc	r8,800055b8 <xTaskResumeAll+0xd8>
80005554:	70 08       	ld.w	r8,r8[0x0]
80005556:	58 08       	cp.w	r8,0
80005558:	c1 10       	breq	8000557a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000555a:	49 87       	lddpc	r7,800055b8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
8000555c:	f0 1f 00 18 	mcall	800055bc <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005560:	6e 08       	ld.w	r8,r7[0x0]
80005562:	20 18       	sub	r8,1
80005564:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005566:	6e 08       	ld.w	r8,r7[0x0]
80005568:	58 08       	cp.w	r8,0
8000556a:	cf 91       	brne	8000555c <xTaskResumeAll+0x7c>
8000556c:	c0 78       	rjmp	8000557a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000556e:	58 14       	cp.w	r4,1
80005570:	c0 50       	breq	8000557a <xTaskResumeAll+0x9a>
80005572:	49 48       	lddpc	r8,800055c0 <xTaskResumeAll+0xe0>
80005574:	70 08       	ld.w	r8,r8[0x0]
80005576:	58 18       	cp.w	r8,1
80005578:	c0 71       	brne	80005586 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000557a:	30 09       	mov	r9,0
8000557c:	49 18       	lddpc	r8,800055c0 <xTaskResumeAll+0xe0>
8000557e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005580:	d7 33       	scall
80005582:	30 17       	mov	r7,1
80005584:	c0 28       	rjmp	80005588 <xTaskResumeAll+0xa8>
80005586:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005588:	f0 1f 00 0f 	mcall	800055c4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
8000558c:	0e 9c       	mov	r12,r7
8000558e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005592:	00 00       	add	r0,r0
80005594:	80 00       	ld.sh	r0,r0[0x0]
80005596:	49 98       	lddpc	r8,800055f8 <prvAddCurrentTaskToDelayedList+0x30>
80005598:	00 00       	add	r0,r0
8000559a:	0d 30       	ld.ub	r0,r6++
8000559c:	00 00       	add	r0,r0
8000559e:	0d 4c       	ld.w	r12,--r6
800055a0:	00 00       	add	r0,r0
800055a2:	0d 04       	ld.w	r4,r6++
800055a4:	00 00       	add	r0,r0
800055a6:	0d 68       	ld.uh	r8,--r6
800055a8:	00 00       	add	r0,r0
800055aa:	0c 4c       	or	r12,r6
800055ac:	00 00       	add	r0,r0
800055ae:	0d 00       	ld.w	r0,r6++
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	48 de       	lddpc	lr,800055e4 <prvAddCurrentTaskToDelayedList+0x1c>
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	48 8e       	lddpc	lr,800055d4 <prvAddCurrentTaskToDelayedList+0xc>
800055b8:	00 00       	add	r0,r0
800055ba:	0c 30       	cp.w	r0,r6
800055bc:	80 00       	ld.sh	r0,r0[0x0]
800055be:	53 38       	stdsp	sp[0xcc],r8
800055c0:	00 00       	add	r0,r0
800055c2:	0d 50       	ld.sh	r0,--r6
800055c4:	80 00       	ld.sh	r0,r0[0x0]
800055c6:	4a a4       	lddpc	r4,8000566c <vTaskDelayUntil+0x48>

800055c8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800055c8:	eb cd 40 80 	pushm	r7,lr
800055cc:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800055ce:	49 08       	lddpc	r8,8000560c <prvAddCurrentTaskToDelayedList+0x44>
800055d0:	70 08       	ld.w	r8,r8[0x0]
800055d2:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800055d4:	48 f8       	lddpc	r8,80005610 <prvAddCurrentTaskToDelayedList+0x48>
800055d6:	70 08       	ld.w	r8,r8[0x0]
800055d8:	10 3c       	cp.w	r12,r8
800055da:	c0 a2       	brcc	800055ee <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800055dc:	48 c8       	lddpc	r8,8000560c <prvAddCurrentTaskToDelayedList+0x44>
800055de:	70 0b       	ld.w	r11,r8[0x0]
800055e0:	48 d8       	lddpc	r8,80005614 <prvAddCurrentTaskToDelayedList+0x4c>
800055e2:	70 0c       	ld.w	r12,r8[0x0]
800055e4:	2f cb       	sub	r11,-4
800055e6:	f0 1f 00 0d 	mcall	80005618 <prvAddCurrentTaskToDelayedList+0x50>
800055ea:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800055ee:	48 88       	lddpc	r8,8000560c <prvAddCurrentTaskToDelayedList+0x44>
800055f0:	70 0b       	ld.w	r11,r8[0x0]
800055f2:	48 b8       	lddpc	r8,8000561c <prvAddCurrentTaskToDelayedList+0x54>
800055f4:	70 0c       	ld.w	r12,r8[0x0]
800055f6:	2f cb       	sub	r11,-4
800055f8:	f0 1f 00 08 	mcall	80005618 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800055fc:	48 98       	lddpc	r8,80005620 <prvAddCurrentTaskToDelayedList+0x58>
800055fe:	70 08       	ld.w	r8,r8[0x0]
80005600:	10 37       	cp.w	r7,r8
80005602:	c0 32       	brcc	80005608 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005604:	48 78       	lddpc	r8,80005620 <prvAddCurrentTaskToDelayedList+0x58>
80005606:	91 07       	st.w	r8[0x0],r7
80005608:	e3 cd 80 80 	ldm	sp++,r7,pc
8000560c:	00 00       	add	r0,r0
8000560e:	0d 00       	ld.w	r0,r6++
80005610:	00 00       	add	r0,r0
80005612:	0d 2c       	ld.uh	r12,r6++
80005614:	00 00       	add	r0,r0
80005616:	0c 48       	or	r8,r6
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	48 aa       	lddpc	r10,80005640 <vTaskDelayUntil+0x1c>
8000561c:	00 00       	add	r0,r0
8000561e:	0c 38       	cp.w	r8,r6
80005620:	00 00       	add	r0,r0
80005622:	05 34       	ld.ub	r4,r2++

80005624 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005624:	eb cd 40 c0 	pushm	r6-r7,lr
80005628:	18 96       	mov	r6,r12
8000562a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000562c:	f0 1f 00 18 	mcall	8000568c <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005630:	6c 08       	ld.w	r8,r6[0x0]
80005632:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005634:	49 79       	lddpc	r9,80005690 <vTaskDelayUntil+0x6c>
80005636:	72 09       	ld.w	r9,r9[0x0]
80005638:	12 38       	cp.w	r8,r9
8000563a:	e0 88 00 0c 	brls	80005652 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000563e:	0e 38       	cp.w	r8,r7
80005640:	e0 88 00 22 	brls	80005684 <vTaskDelayUntil+0x60>
80005644:	49 38       	lddpc	r8,80005690 <vTaskDelayUntil+0x6c>
80005646:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005648:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000564a:	10 37       	cp.w	r7,r8
8000564c:	e0 88 00 14 	brls	80005674 <vTaskDelayUntil+0x50>
80005650:	c0 a8       	rjmp	80005664 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005652:	0e 38       	cp.w	r8,r7
80005654:	e0 8b 00 16 	brhi	80005680 <vTaskDelayUntil+0x5c>
80005658:	48 e8       	lddpc	r8,80005690 <vTaskDelayUntil+0x6c>
8000565a:	70 08       	ld.w	r8,r8[0x0]
8000565c:	10 37       	cp.w	r7,r8
8000565e:	e0 8b 00 11 	brhi	80005680 <vTaskDelayUntil+0x5c>
80005662:	c1 18       	rjmp	80005684 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005664:	48 c8       	lddpc	r8,80005694 <vTaskDelayUntil+0x70>
80005666:	70 0c       	ld.w	r12,r8[0x0]
80005668:	2f cc       	sub	r12,-4
8000566a:	f0 1f 00 0c 	mcall	80005698 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000566e:	0e 9c       	mov	r12,r7
80005670:	f0 1f 00 0b 	mcall	8000569c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005674:	f0 1f 00 0b 	mcall	800056a0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005678:	c0 81       	brne	80005688 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000567a:	d7 33       	scall
8000567c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005680:	8d 07       	st.w	r6[0x0],r7
80005682:	cf 1b       	rjmp	80005664 <vTaskDelayUntil+0x40>
80005684:	8d 07       	st.w	r6[0x0],r7
80005686:	cf 7b       	rjmp	80005674 <vTaskDelayUntil+0x50>
80005688:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000568c:	80 00       	ld.sh	r0,r0[0x0]
8000568e:	51 24       	stdsp	sp[0x48],r4
80005690:	00 00       	add	r0,r0
80005692:	0d 2c       	ld.uh	r12,r6++
80005694:	00 00       	add	r0,r0
80005696:	0d 00       	ld.w	r0,r6++
80005698:	80 00       	ld.sh	r0,r0[0x0]
8000569a:	48 de       	lddpc	lr,800056cc <vTaskPlaceOnEventList+0x28>
8000569c:	80 00       	ld.sh	r0,r0[0x0]
8000569e:	55 c8       	stdsp	sp[0x170],r8
800056a0:	80 00       	ld.sh	r0,r0[0x0]
800056a2:	54 e0       	stdsp	sp[0x138],r0

800056a4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800056a4:	eb cd 40 c0 	pushm	r6-r7,lr
800056a8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800056aa:	48 e7       	lddpc	r7,800056e0 <vTaskPlaceOnEventList+0x3c>
800056ac:	6e 0b       	ld.w	r11,r7[0x0]
800056ae:	2e 8b       	sub	r11,-24
800056b0:	f0 1f 00 0d 	mcall	800056e4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800056b4:	6e 0c       	ld.w	r12,r7[0x0]
800056b6:	2f cc       	sub	r12,-4
800056b8:	f0 1f 00 0c 	mcall	800056e8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800056bc:	5b f6       	cp.w	r6,-1
800056be:	c0 81       	brne	800056ce <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800056c0:	6e 0b       	ld.w	r11,r7[0x0]
800056c2:	2f cb       	sub	r11,-4
800056c4:	48 ac       	lddpc	r12,800056ec <vTaskPlaceOnEventList+0x48>
800056c6:	f0 1f 00 0b 	mcall	800056f0 <vTaskPlaceOnEventList+0x4c>
800056ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800056ce:	48 a8       	lddpc	r8,800056f4 <vTaskPlaceOnEventList+0x50>
800056d0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800056d2:	ec 0c 00 0c 	add	r12,r6,r12
800056d6:	f0 1f 00 09 	mcall	800056f8 <vTaskPlaceOnEventList+0x54>
800056da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800056de:	00 00       	add	r0,r0
800056e0:	00 00       	add	r0,r0
800056e2:	0d 00       	ld.w	r0,r6++
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	48 aa       	lddpc	r10,8000570c <prvIdleTask+0x10>
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	48 de       	lddpc	lr,8000571c <prvIdleTask+0x20>
800056ec:	00 00       	add	r0,r0
800056ee:	0d 54       	ld.sh	r4,--r6
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	48 8e       	lddpc	lr,80005710 <prvIdleTask+0x14>
800056f4:	00 00       	add	r0,r0
800056f6:	0d 2c       	ld.uh	r12,r6++
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	55 c8       	stdsp	sp[0x170],r8

800056fc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800056fc:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005700:	49 67       	lddpc	r7,80005758 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005702:	49 74       	lddpc	r4,8000575c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005704:	49 73       	lddpc	r3,80005760 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005706:	49 85       	lddpc	r5,80005764 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005708:	6e 08       	ld.w	r8,r7[0x0]
8000570a:	58 08       	cp.w	r8,0
8000570c:	c1 e0       	breq	80005748 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000570e:	f0 1f 00 17 	mcall	80005768 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005712:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005714:	f0 1f 00 16 	mcall	8000576c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005718:	58 06       	cp.w	r6,0
8000571a:	c1 70       	breq	80005748 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
8000571c:	f0 1f 00 15 	mcall	80005770 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005720:	68 38       	ld.w	r8,r4[0xc]
80005722:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005724:	ec cc ff fc 	sub	r12,r6,-4
80005728:	f0 1f 00 13 	mcall	80005774 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
8000572c:	66 08       	ld.w	r8,r3[0x0]
8000572e:	20 18       	sub	r8,1
80005730:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005732:	6e 08       	ld.w	r8,r7[0x0]
80005734:	20 18       	sub	r8,1
80005736:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005738:	f0 1f 00 10 	mcall	80005778 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
8000573c:	6c cc       	ld.w	r12,r6[0x30]
8000573e:	f0 1f 00 10 	mcall	8000577c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005742:	0c 9c       	mov	r12,r6
80005744:	f0 1f 00 0e 	mcall	8000577c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005748:	6a 08       	ld.w	r8,r5[0x0]
8000574a:	58 18       	cp.w	r8,1
8000574c:	e0 88 00 03 	brls	80005752 <prvIdleTask+0x56>
			{
				taskYIELD();
80005750:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005752:	f0 1f 00 0c 	mcall	80005780 <prvIdleTask+0x84>
		}
		#endif
	}
80005756:	cd 9b       	rjmp	80005708 <prvIdleTask+0xc>
80005758:	00 00       	add	r0,r0
8000575a:	0c 40       	or	r0,r6
8000575c:	00 00       	add	r0,r0
8000575e:	0c ec       	st.h	--r6,r12
80005760:	00 00       	add	r0,r0
80005762:	0d 4c       	ld.w	r12,--r6
80005764:	00 00       	add	r0,r0
80005766:	0c 4c       	or	r12,r6
80005768:	80 00       	ld.sh	r0,r0[0x0]
8000576a:	51 24       	stdsp	sp[0x48],r4
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	54 e0       	stdsp	sp[0x138],r0
80005770:	80 00       	ld.sh	r0,r0[0x0]
80005772:	49 98       	lddpc	r8,800057d4 <xTaskGenericCreate+0x50>
80005774:	80 00       	ld.sh	r0,r0[0x0]
80005776:	48 de       	lddpc	lr,800057a8 <xTaskGenericCreate+0x24>
80005778:	80 00       	ld.sh	r0,r0[0x0]
8000577a:	4a a4       	lddpc	r4,80005820 <xTaskGenericCreate+0x9c>
8000577c:	80 00       	ld.sh	r0,r0[0x0]
8000577e:	4b dc       	lddpc	r12,80005870 <xTaskGenericCreate+0xec>
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	20 30       	sub	r0,3

80005784 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005784:	d4 31       	pushm	r0-r7,lr
80005786:	20 1d       	sub	sp,4
80005788:	fa c4 ff d8 	sub	r4,sp,-40
8000578c:	50 0c       	stdsp	sp[0x0],r12
8000578e:	16 91       	mov	r1,r11
80005790:	14 97       	mov	r7,r10
80005792:	12 90       	mov	r0,r9
80005794:	10 93       	mov	r3,r8
80005796:	68 02       	ld.w	r2,r4[0x0]
80005798:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000579a:	34 8c       	mov	r12,72
8000579c:	f0 1f 00 5c 	mcall	8000590c <xTaskGenericCreate+0x188>
800057a0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800057a2:	c0 31       	brne	800057a8 <xTaskGenericCreate+0x24>
800057a4:	3f fc       	mov	r12,-1
800057a6:	ca f8       	rjmp	80005904 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800057a8:	58 06       	cp.w	r6,0
800057aa:	e0 81 00 af 	brne	80005908 <xTaskGenericCreate+0x184>
800057ae:	0e 9c       	mov	r12,r7
800057b0:	5c 7c       	castu.h	r12
800057b2:	a3 6c       	lsl	r12,0x2
800057b4:	f0 1f 00 56 	mcall	8000590c <xTaskGenericCreate+0x188>
800057b8:	18 96       	mov	r6,r12
800057ba:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800057bc:	c0 61       	brne	800057c8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800057be:	0a 9c       	mov	r12,r5
800057c0:	f0 1f 00 54 	mcall	80005910 <xTaskGenericCreate+0x18c>
800057c4:	3f fc       	mov	r12,-1
800057c6:	c9 f8       	rjmp	80005904 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800057c8:	5c 77       	castu.h	r7
800057ca:	ee 0a 15 02 	lsl	r10,r7,0x2
800057ce:	e0 6b 00 a5 	mov	r11,165
800057d2:	0c 9c       	mov	r12,r6
800057d4:	f0 1f 00 50 	mcall	80005914 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800057d8:	ee c6 00 01 	sub	r6,r7,1
800057dc:	6a c8       	ld.w	r8,r5[0x30]
800057de:	f0 06 00 26 	add	r6,r8,r6<<0x2
800057e2:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
800057e6:	31 0a       	mov	r10,16
800057e8:	02 9b       	mov	r11,r1
800057ea:	ea cc ff cc 	sub	r12,r5,-52
800057ee:	f0 1f 00 4b 	mcall	80005918 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
800057f2:	30 08       	mov	r8,0
800057f4:	eb 68 00 43 	st.b	r5[67],r8
800057f8:	58 73       	cp.w	r3,7
800057fa:	e6 07 17 80 	movls	r7,r3
800057fe:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005802:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005804:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005808:	ea c4 ff fc 	sub	r4,r5,-4
8000580c:	08 9c       	mov	r12,r4
8000580e:	f0 1f 00 44 	mcall	8000591c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005812:	ea cc ff e8 	sub	r12,r5,-24
80005816:	f0 1f 00 42 	mcall	8000591c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
8000581a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
8000581c:	ee 07 11 08 	rsub	r7,r7,8
80005820:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005822:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005824:	00 9a       	mov	r10,r0
80005826:	40 0b       	lddsp	r11,sp[0x0]
80005828:	0c 9c       	mov	r12,r6
8000582a:	f0 1f 00 3e 	mcall	80005920 <xTaskGenericCreate+0x19c>
8000582e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005830:	58 02       	cp.w	r2,0
80005832:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005836:	f0 1f 00 3c 	mcall	80005924 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
8000583a:	4b c8       	lddpc	r8,80005928 <xTaskGenericCreate+0x1a4>
8000583c:	70 09       	ld.w	r9,r8[0x0]
8000583e:	2f f9       	sub	r9,-1
80005840:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005842:	4b b8       	lddpc	r8,8000592c <xTaskGenericCreate+0x1a8>
80005844:	70 08       	ld.w	r8,r8[0x0]
80005846:	58 08       	cp.w	r8,0
80005848:	c2 61       	brne	80005894 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000584a:	4b 98       	lddpc	r8,8000592c <xTaskGenericCreate+0x1a8>
8000584c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
8000584e:	4b 78       	lddpc	r8,80005928 <xTaskGenericCreate+0x1a4>
80005850:	70 08       	ld.w	r8,r8[0x0]
80005852:	58 18       	cp.w	r8,1
80005854:	c2 b1       	brne	800058aa <xTaskGenericCreate+0x126>
80005856:	4b 77       	lddpc	r7,80005930 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005858:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
8000585c:	0e 9c       	mov	r12,r7
8000585e:	f0 1f 00 36 	mcall	80005934 <xTaskGenericCreate+0x1b0>
80005862:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005864:	0c 37       	cp.w	r7,r6
80005866:	cf b1       	brne	8000585c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005868:	4b 47       	lddpc	r7,80005938 <xTaskGenericCreate+0x1b4>
8000586a:	0e 9c       	mov	r12,r7
8000586c:	f0 1f 00 32 	mcall	80005934 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005870:	4b 36       	lddpc	r6,8000593c <xTaskGenericCreate+0x1b8>
80005872:	0c 9c       	mov	r12,r6
80005874:	f0 1f 00 30 	mcall	80005934 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005878:	4b 2c       	lddpc	r12,80005940 <xTaskGenericCreate+0x1bc>
8000587a:	f0 1f 00 2f 	mcall	80005934 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000587e:	4b 2c       	lddpc	r12,80005944 <xTaskGenericCreate+0x1c0>
80005880:	f0 1f 00 2d 	mcall	80005934 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005884:	4b 1c       	lddpc	r12,80005948 <xTaskGenericCreate+0x1c4>
80005886:	f0 1f 00 2c 	mcall	80005934 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000588a:	4b 18       	lddpc	r8,8000594c <xTaskGenericCreate+0x1c8>
8000588c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000588e:	4b 18       	lddpc	r8,80005950 <xTaskGenericCreate+0x1cc>
80005890:	91 06       	st.w	r8[0x0],r6
80005892:	c0 c8       	rjmp	800058aa <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005894:	4b 08       	lddpc	r8,80005954 <xTaskGenericCreate+0x1d0>
80005896:	70 08       	ld.w	r8,r8[0x0]
80005898:	58 08       	cp.w	r8,0
8000589a:	c0 81       	brne	800058aa <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
8000589c:	4a 48       	lddpc	r8,8000592c <xTaskGenericCreate+0x1a8>
8000589e:	70 08       	ld.w	r8,r8[0x0]
800058a0:	70 b8       	ld.w	r8,r8[0x2c]
800058a2:	10 33       	cp.w	r3,r8
800058a4:	c0 33       	brcs	800058aa <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
800058a6:	4a 28       	lddpc	r8,8000592c <xTaskGenericCreate+0x1a8>
800058a8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800058aa:	6a b8       	ld.w	r8,r5[0x2c]
800058ac:	4a b9       	lddpc	r9,80005958 <xTaskGenericCreate+0x1d4>
800058ae:	72 09       	ld.w	r9,r9[0x0]
800058b0:	12 38       	cp.w	r8,r9
800058b2:	e0 88 00 04 	brls	800058ba <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800058b6:	4a 99       	lddpc	r9,80005958 <xTaskGenericCreate+0x1d4>
800058b8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
800058ba:	4a 98       	lddpc	r8,8000595c <xTaskGenericCreate+0x1d8>
800058bc:	70 09       	ld.w	r9,r8[0x0]
800058be:	2f f9       	sub	r9,-1
800058c0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800058c2:	6a b8       	ld.w	r8,r5[0x2c]
800058c4:	4a 79       	lddpc	r9,80005960 <xTaskGenericCreate+0x1dc>
800058c6:	72 09       	ld.w	r9,r9[0x0]
800058c8:	12 38       	cp.w	r8,r9
800058ca:	e0 88 00 04 	brls	800058d2 <xTaskGenericCreate+0x14e>
800058ce:	4a 59       	lddpc	r9,80005960 <xTaskGenericCreate+0x1dc>
800058d0:	93 08       	st.w	r9[0x0],r8
800058d2:	6a bc       	ld.w	r12,r5[0x2c]
800058d4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800058d8:	08 9b       	mov	r11,r4
800058da:	49 68       	lddpc	r8,80005930 <xTaskGenericCreate+0x1ac>
800058dc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800058e0:	f0 1f 00 21 	mcall	80005964 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800058e4:	f0 1f 00 21 	mcall	80005968 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800058e8:	49 b8       	lddpc	r8,80005954 <xTaskGenericCreate+0x1d0>
800058ea:	70 08       	ld.w	r8,r8[0x0]
800058ec:	58 08       	cp.w	r8,0
800058ee:	c0 a0       	breq	80005902 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800058f0:	48 f8       	lddpc	r8,8000592c <xTaskGenericCreate+0x1a8>
800058f2:	70 08       	ld.w	r8,r8[0x0]
800058f4:	70 b8       	ld.w	r8,r8[0x2c]
800058f6:	10 33       	cp.w	r3,r8
800058f8:	e0 88 00 05 	brls	80005902 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
800058fc:	d7 33       	scall
800058fe:	30 1c       	mov	r12,1
80005900:	c0 28       	rjmp	80005904 <xTaskGenericCreate+0x180>
80005902:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005904:	2f fd       	sub	sp,-4
80005906:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005908:	99 c6       	st.w	r12[0x30],r6
8000590a:	c5 fb       	rjmp	800057c8 <xTaskGenericCreate+0x44>
8000590c:	80 00       	ld.sh	r0,r0[0x0]
8000590e:	4c 04       	lddpc	r4,80005a0c <PrintHex+0x50>
80005910:	80 00       	ld.sh	r0,r0[0x0]
80005912:	4b dc       	lddpc	r12,80005a04 <PrintHex+0x48>
80005914:	80 00       	ld.sh	r0,r0[0x0]
80005916:	65 f0       	ld.w	r0,r2[0x7c]
80005918:	80 00       	ld.sh	r0,r0[0x0]
8000591a:	69 34       	ld.w	r4,r4[0x4c]
8000591c:	80 00       	ld.sh	r0,r0[0x0]
8000591e:	48 88       	lddpc	r8,8000593c <xTaskGenericCreate+0x1b8>
80005920:	80 00       	ld.sh	r0,r0[0x0]
80005922:	49 04       	lddpc	r4,80005960 <xTaskGenericCreate+0x1dc>
80005924:	80 00       	ld.sh	r0,r0[0x0]
80005926:	49 98       	lddpc	r8,80005988 <vTaskStartScheduler+0x1c>
80005928:	00 00       	add	r0,r0
8000592a:	0d 4c       	ld.w	r12,--r6
8000592c:	00 00       	add	r0,r0
8000592e:	0d 00       	ld.w	r0,r6++
80005930:	00 00       	add	r0,r0
80005932:	0c 4c       	or	r12,r6
80005934:	80 00       	ld.sh	r0,r0[0x0]
80005936:	48 74       	lddpc	r4,80005950 <xTaskGenericCreate+0x1cc>
80005938:	00 00       	add	r0,r0
8000593a:	0d 18       	ld.sh	r8,r6++
8000593c:	00 00       	add	r0,r0
8000593e:	0d 34       	ld.ub	r4,r6++
80005940:	00 00       	add	r0,r0
80005942:	0d 04       	ld.w	r4,r6++
80005944:	00 00       	add	r0,r0
80005946:	0c ec       	st.h	--r6,r12
80005948:	00 00       	add	r0,r0
8000594a:	0d 54       	ld.sh	r4,--r6
8000594c:	00 00       	add	r0,r0
8000594e:	0c 38       	cp.w	r8,r6
80005950:	00 00       	add	r0,r0
80005952:	0c 48       	or	r8,r6
80005954:	00 00       	add	r0,r0
80005956:	0c 3c       	cp.w	r12,r6
80005958:	00 00       	add	r0,r0
8000595a:	0c 34       	cp.w	r4,r6
8000595c:	00 00       	add	r0,r0
8000595e:	0d 48       	ld.w	r8,--r6
80005960:	00 00       	add	r0,r0
80005962:	0d 68       	ld.uh	r8,--r6
80005964:	80 00       	ld.sh	r0,r0[0x0]
80005966:	48 8e       	lddpc	lr,80005984 <vTaskStartScheduler+0x18>
80005968:	80 00       	ld.sh	r0,r0[0x0]
8000596a:	4a a4       	lddpc	r4,80005a10 <PrintHex+0x54>

8000596c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
8000596c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
8000596e:	30 09       	mov	r9,0
80005970:	1a d9       	st.w	--sp,r9
80005972:	1a d9       	st.w	--sp,r9
80005974:	1a d9       	st.w	--sp,r9
80005976:	12 98       	mov	r8,r9
80005978:	e0 6a 01 00 	mov	r10,256
8000597c:	48 9b       	lddpc	r11,800059a0 <vTaskStartScheduler+0x34>
8000597e:	48 ac       	lddpc	r12,800059a4 <vTaskStartScheduler+0x38>
80005980:	f0 1f 00 0a 	mcall	800059a8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005984:	2f dd       	sub	sp,-12
80005986:	58 1c       	cp.w	r12,1
80005988:	c0 a1       	brne	8000599c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000598a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
8000598c:	30 19       	mov	r9,1
8000598e:	48 88       	lddpc	r8,800059ac <vTaskStartScheduler+0x40>
80005990:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005992:	30 09       	mov	r9,0
80005994:	48 78       	lddpc	r8,800059b0 <vTaskStartScheduler+0x44>
80005996:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005998:	f0 1f 00 07 	mcall	800059b4 <vTaskStartScheduler+0x48>
8000599c:	d8 02       	popm	pc
8000599e:	00 00       	add	r0,r0
800059a0:	80 00       	ld.sh	r0,r0[0x0]
800059a2:	c5 14       	brge	80005a44 <PrintHex+0x88>
800059a4:	80 00       	ld.sh	r0,r0[0x0]
800059a6:	56 fc       	stdsp	sp[0x1bc],r12
800059a8:	80 00       	ld.sh	r0,r0[0x0]
800059aa:	57 84       	stdsp	sp[0x1e0],r4
800059ac:	00 00       	add	r0,r0
800059ae:	0c 3c       	cp.w	r12,r6
800059b0:	00 00       	add	r0,r0
800059b2:	0d 2c       	ld.uh	r12,r6++
800059b4:	80 00       	ld.sh	r0,r0[0x0]
800059b6:	49 a8       	lddpc	r8,80005a1c <PrintHex+0x60>

800059b8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800059b8:	16 cc       	st.b	r11++,r12
	return str;
}
800059ba:	5e fb       	retal	r11

800059bc <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800059bc:	eb cd 40 c0 	pushm	r6-r7,lr
800059c0:	20 3d       	sub	sp,12
800059c2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800059c4:	30 06       	mov	r6,0
800059c6:	30 07       	mov	r7,0
800059c8:	fa e7 00 00 	st.d	sp[0],r6
800059cc:	30 0c       	mov	r12,0
800059ce:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
800059d0:	58 08       	cp.w	r8,0
800059d2:	c1 30       	breq	800059f8 <PrintHex+0x3c>
800059d4:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
800059d6:	1a 9c       	mov	r12,sp
800059d8:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800059dc:	58 9e       	cp.w	lr,9
800059de:	e0 8a 00 04 	brle	800059e6 <PrintHex+0x2a>
800059e2:	2c 9e       	sub	lr,-55
800059e4:	c0 48       	rjmp	800059ec <PrintHex+0x30>
800059e6:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
800059ea:	2d 0e       	sub	lr,-48
800059ec:	f8 09 0b 0e 	st.b	r12[r9],lr
800059f0:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
800059f2:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
800059f4:	cf 21       	brne	800059d8 <PrintHex+0x1c>
800059f6:	c0 48       	rjmp	800059fe <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
800059f8:	33 08       	mov	r8,48
800059fa:	ba 88       	st.b	sp[0x0],r8
800059fc:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
800059fe:	f6 09 01 08 	sub	r8,r11,r9
80005a02:	58 08       	cp.w	r8,0
80005a04:	e0 8a 00 13 	brle	80005a2a <PrintHex+0x6e>
	{
		char num = len - cnt;
80005a08:	12 1b       	sub	r11,r9
80005a0a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005a0e:	18 9e       	mov	lr,r12
80005a10:	58 0c       	cp.w	r12,0
80005a12:	e0 8a 00 0c 	brle	80005a2a <PrintHex+0x6e>
80005a16:	1a 9b       	mov	r11,sp
80005a18:	12 0b       	add	r11,r9
80005a1a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005a1c:	33 07       	mov	r7,48
80005a1e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005a20:	2f f8       	sub	r8,-1
80005a22:	1c 38       	cp.w	r8,lr
80005a24:	cf d5       	brlt	80005a1e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005a26:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005a2a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005a2e:	f0 cb ff ff 	sub	r11,r8,-1
80005a32:	58 0b       	cp.w	r11,0
80005a34:	e0 8a 00 19 	brle	80005a66 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005a38:	fa cb ff f4 	sub	r11,sp,-12
80005a3c:	f6 09 00 09 	add	r9,r11,r9
80005a40:	37 8b       	mov	r11,120
80005a42:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005a46:	fa c9 ff f4 	sub	r9,sp,-12
80005a4a:	10 09       	add	r9,r8
80005a4c:	33 0b       	mov	r11,48
80005a4e:	f3 6b ff f4 	st.b	r9[-12],r11
80005a52:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005a56:	fa ce 00 01 	sub	lr,sp,1
80005a5a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005a5c:	11 8b       	ld.ub	r11,r8[0x0]
80005a5e:	12 cb       	st.b	r9++,r11
80005a60:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005a62:	1c 38       	cp.w	r8,lr
80005a64:	cf c1       	brne	80005a5c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005a66:	14 9c       	mov	r12,r10
80005a68:	2f dd       	sub	sp,-12
80005a6a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005a6e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005a6e:	d4 21       	pushm	r4-r7,lr
80005a70:	20 3d       	sub	sp,12
80005a72:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005a74:	30 06       	mov	r6,0
80005a76:	30 07       	mov	r7,0
80005a78:	fa e7 00 00 	st.d	sp[0],r6
80005a7c:	30 0c       	mov	r12,0
80005a7e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005a80:	58 08       	cp.w	r8,0
80005a82:	c0 35       	brlt	80005a88 <PrintDec+0x1a>
80005a84:	14 97       	mov	r7,r10
80005a86:	c0 58       	rjmp	80005a90 <PrintDec+0x22>
	{
		*p++ = '-';
80005a88:	14 97       	mov	r7,r10
80005a8a:	32 d9       	mov	r9,45
80005a8c:	0e c9       	st.b	r7++,r9
		i = -i;
80005a8e:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005a90:	58 08       	cp.w	r8,0
80005a92:	c0 51       	brne	80005a9c <PrintDec+0x2e>
80005a94:	33 08       	mov	r8,48
80005a96:	ba 88       	st.b	sp[0x0],r8
80005a98:	30 1e       	mov	lr,1
80005a9a:	c2 f8       	rjmp	80005af8 <PrintDec+0x8a>
	
	int ten = i%10;
80005a9c:	e0 65 66 67 	mov	r5,26215
80005aa0:	ea 15 66 66 	orh	r5,0x6666
80005aa4:	f0 05 04 44 	muls.d	r4,r8,r5
80005aa8:	ea 0c 14 02 	asr	r12,r5,0x2
80005aac:	f0 09 14 1f 	asr	r9,r8,0x1f
80005ab0:	f8 09 01 09 	sub	r9,r12,r9
80005ab4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005ab8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005abc:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005abe:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005ac0:	e0 66 66 67 	mov	r6,26215
80005ac4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005ac8:	2d 09       	sub	r9,-48
80005aca:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005ace:	2f fe       	sub	lr,-1
		i /= 10;
80005ad0:	f0 06 04 44 	muls.d	r4,r8,r6
80005ad4:	ea 09 14 02 	asr	r9,r5,0x2
80005ad8:	bf 58       	asr	r8,0x1f
80005ada:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005ade:	f0 06 04 44 	muls.d	r4,r8,r6
80005ae2:	ea 09 14 02 	asr	r9,r5,0x2
80005ae6:	f0 05 14 1f 	asr	r5,r8,0x1f
80005aea:	0a 19       	sub	r9,r5
80005aec:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005af0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005af4:	58 08       	cp.w	r8,0
80005af6:	ce 91       	brne	80005ac8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005af8:	f6 0e 01 08 	sub	r8,r11,lr
80005afc:	58 08       	cp.w	r8,0
80005afe:	e0 89 00 06 	brgt	80005b0a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005b02:	58 0e       	cp.w	lr,0
80005b04:	e0 89 00 14 	brgt	80005b2c <PrintDec+0xbe>
80005b08:	c1 d8       	rjmp	80005b42 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005b0a:	1c 1b       	sub	r11,lr
80005b0c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80005b0e:	16 9c       	mov	r12,r11
80005b10:	58 0b       	cp.w	r11,0
80005b12:	fe 9a ff f8 	brle	80005b02 <PrintDec+0x94>
80005b16:	1a 99       	mov	r9,sp
80005b18:	1c 09       	add	r9,lr
80005b1a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005b1c:	33 06       	mov	r6,48
80005b1e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005b20:	2f f8       	sub	r8,-1
80005b22:	18 38       	cp.w	r8,r12
80005b24:	cf d5       	brlt	80005b1e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80005b26:	f6 0e 00 0e 	add	lr,r11,lr
80005b2a:	ce cb       	rjmp	80005b02 <PrintDec+0x94>
80005b2c:	fa c8 ff f4 	sub	r8,sp,-12
80005b30:	1c 08       	add	r8,lr
80005b32:	20 d8       	sub	r8,13
80005b34:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80005b38:	11 89       	ld.ub	r9,r8[0x0]
80005b3a:	0e c9       	st.b	r7++,r9
80005b3c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005b3e:	16 38       	cp.w	r8,r11
80005b40:	cf c1       	brne	80005b38 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005b42:	14 9c       	mov	r12,r10
80005b44:	2f dd       	sub	sp,-12
80005b46:	d8 22       	popm	r4-r7,pc

80005b48 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80005b48:	d4 31       	pushm	r0-r7,lr
80005b4a:	fa cd 02 08 	sub	sp,sp,520
80005b4e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80005b50:	e0 6a 01 00 	mov	r10,256
80005b54:	30 0b       	mov	r11,0
80005b56:	fa cc fe f8 	sub	r12,sp,-264
80005b5a:	f0 1f 00 4e 	mcall	80005c90 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80005b5e:	fa c4 fd d4 	sub	r4,sp,-556
80005b62:	30 0a       	mov	r10,0
80005b64:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005b66:	fa c3 ff fc 	sub	r3,sp,-4
80005b6a:	e0 61 01 00 	mov	r1,256
80005b6e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80005b70:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005b72:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005b76:	02 9a       	mov	r10,r1
80005b78:	00 9b       	mov	r11,r0
80005b7a:	06 9c       	mov	r12,r3
80005b7c:	f0 1f 00 45 	mcall	80005c90 <log+0x148>
			
					if(*str == '%')
80005b80:	0f 88       	ld.ub	r8,r7[0x0]
80005b82:	e4 08 18 00 	cp.b	r8,r2
80005b86:	c5 71       	brne	80005c34 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80005b88:	ee c8 ff ff 	sub	r8,r7,-1
80005b8c:	11 89       	ld.ub	r9,r8[0x0]
80005b8e:	4c 2a       	lddpc	r10,80005c94 <log+0x14c>
80005b90:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80005b92:	23 09       	sub	r9,48
80005b94:	30 9a       	mov	r10,9
80005b96:	f4 09 18 00 	cp.b	r9,r10
80005b9a:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80005b9e:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005ba2:	f7 b9 08 30 	subls	r9,48
80005ba6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80005baa:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80005bae:	0f 88       	ld.ub	r8,r7[0x0]
80005bb0:	22 58       	sub	r8,37
80005bb2:	e0 48 00 53 	cp.w	r8,83
80005bb6:	e0 8b 00 31 	brhi	80005c18 <log+0xd0>
80005bba:	4b 89       	lddpc	r9,80005c98 <log+0x150>
80005bbc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80005bc0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80005bc4:	06 9a       	mov	r10,r3
80005bc6:	40 0b       	lddsp	r11,sp[0x0]
80005bc8:	5c 5b       	castu.b	r11
80005bca:	68 0c       	ld.w	r12,r4[0x0]
80005bcc:	f0 1f 00 34 	mcall	80005c9c <log+0x154>
							break;
80005bd0:	c2 98       	rjmp	80005c22 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80005bd2:	4b 4c       	lddpc	r12,80005ca0 <log+0x158>
80005bd4:	f0 1f 00 34 	mcall	80005ca4 <log+0x15c>
80005bd8:	08 95       	mov	r5,r4
80005bda:	06 9c       	mov	r12,r3
							break;
80005bdc:	c2 38       	rjmp	80005c22 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80005bde:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80005be2:	06 9a       	mov	r10,r3
80005be4:	40 0b       	lddsp	r11,sp[0x0]
80005be6:	5c 5b       	castu.b	r11
80005be8:	68 0c       	ld.w	r12,r4[0x0]
80005bea:	f0 1f 00 30 	mcall	80005ca8 <log+0x160>
80005bee:	06 9c       	mov	r12,r3
							break;
80005bf0:	c1 98       	rjmp	80005c22 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80005bf2:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80005bf6:	06 9b       	mov	r11,r3
80005bf8:	09 bc       	ld.ub	r12,r4[0x3]
80005bfa:	f0 1f 00 2d 	mcall	80005cac <log+0x164>
80005bfe:	06 9c       	mov	r12,r3
							break;
80005c00:	c1 18       	rjmp	80005c22 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80005c02:	e8 c5 ff fc 	sub	r5,r4,-4
80005c06:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80005c08:	c0 d8       	rjmp	80005c22 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80005c0a:	06 9b       	mov	r11,r3
80005c0c:	32 5c       	mov	r12,37
80005c0e:	f0 1f 00 28 	mcall	80005cac <log+0x164>
80005c12:	08 95       	mov	r5,r4
80005c14:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80005c16:	c0 68       	rjmp	80005c22 <log+0xda>
							
							default:
							log("I need relax.");
80005c18:	4a 6c       	lddpc	r12,80005cb0 <log+0x168>
80005c1a:	f0 1f 00 23 	mcall	80005ca4 <log+0x15c>
80005c1e:	08 95       	mov	r5,r4
80005c20:	06 9c       	mov	r12,r3
						}
						str++;
80005c22:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005c24:	1a dc       	st.w	--sp,r12
80005c26:	1a d6       	st.w	--sp,r6
80005c28:	4a 3b       	lddpc	r11,80005cb4 <log+0x16c>
80005c2a:	0c 9c       	mov	r12,r6
80005c2c:	f0 1f 00 23 	mcall	80005cb8 <log+0x170>
80005c30:	2f ed       	sub	sp,-8
80005c32:	c0 a8       	rjmp	80005c46 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005c34:	2f f7       	sub	r7,-1
80005c36:	1a d8       	st.w	--sp,r8
80005c38:	1a d6       	st.w	--sp,r6
80005c3a:	4a 1b       	lddpc	r11,80005cbc <log+0x174>
80005c3c:	0c 9c       	mov	r12,r6
80005c3e:	f0 1f 00 1f 	mcall	80005cb8 <log+0x170>
80005c42:	08 95       	mov	r5,r4
80005c44:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80005c46:	0f 89       	ld.ub	r9,r7[0x0]
80005c48:	30 08       	mov	r8,0
80005c4a:	f0 09 18 00 	cp.b	r9,r8
80005c4e:	c0 30       	breq	80005c54 <log+0x10c>
80005c50:	0a 94       	mov	r4,r5
80005c52:	c9 2b       	rjmp	80005b76 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80005c54:	fa c7 fe f8 	sub	r7,sp,-264
80005c58:	1a d7       	st.w	--sp,r7
80005c5a:	49 ab       	lddpc	r11,80005cc0 <log+0x178>
80005c5c:	0e 9c       	mov	r12,r7
80005c5e:	f0 1f 00 17 	mcall	80005cb8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80005c62:	5c 5c       	castu.b	r12
80005c64:	f8 c6 ff ff 	sub	r6,r12,-1
80005c68:	0c 9c       	mov	r12,r6
80005c6a:	f0 1f 00 17 	mcall	80005cc4 <log+0x17c>
80005c6e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80005c70:	0c 9a       	mov	r10,r6
80005c72:	0e 9b       	mov	r11,r7
80005c74:	f0 1f 00 15 	mcall	80005cc8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
80005c78:	30 09       	mov	r9,0
80005c7a:	30 5a       	mov	r10,5
80005c7c:	fa cb fe f8 	sub	r11,sp,-264
80005c80:	49 38       	lddpc	r8,80005ccc <log+0x184>
80005c82:	70 0c       	ld.w	r12,r8[0x0]
80005c84:	f0 1f 00 13 	mcall	80005cd0 <log+0x188>
80005c88:	2f fd       	sub	sp,-4
}
80005c8a:	fe 3d fd f8 	sub	sp,-520
80005c8e:	d8 32       	popm	r0-r7,pc
80005c90:	80 00       	ld.sh	r0,r0[0x0]
80005c92:	65 f0       	ld.w	r0,r2[0x7c]
80005c94:	00 00       	add	r0,r0
80005c96:	0d 6c       	ld.uh	r12,--r6
80005c98:	80 00       	ld.sh	r0,r0[0x0]
80005c9a:	c5 1c       	rcall	80005d3c <logFromISR+0x68>
80005c9c:	80 00       	ld.sh	r0,r0[0x0]
80005c9e:	5a 6e       	cp.w	lr,-26
80005ca0:	80 00       	ld.sh	r0,r0[0x0]
80005ca2:	c7 c8       	rjmp	80005d9a <logFromISR+0xc6>
80005ca4:	80 00       	ld.sh	r0,r0[0x0]
80005ca6:	5b 48       	cp.w	r8,-12
80005ca8:	80 00       	ld.sh	r0,r0[0x0]
80005caa:	59 bc       	cp.w	r12,27
80005cac:	80 00       	ld.sh	r0,r0[0x0]
80005cae:	59 b8       	cp.w	r8,27
80005cb0:	80 00       	ld.sh	r0,r0[0x0]
80005cb2:	c7 d8       	rjmp	80005dac <logFromISR+0xd8>
80005cb4:	80 00       	ld.sh	r0,r0[0x0]
80005cb6:	c7 e8       	rjmp	80005db2 <logFromISR+0xde>
80005cb8:	80 00       	ld.sh	r0,r0[0x0]
80005cba:	68 e0       	ld.w	r0,r4[0x38]
80005cbc:	80 00       	ld.sh	r0,r0[0x0]
80005cbe:	c7 f0       	breq	80005dbc <logFromISR+0xe8>
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	c7 f8       	rjmp	80005dc0 <logFromISR+0xec>
80005cc4:	80 00       	ld.sh	r0,r0[0x0]
80005cc6:	4c 04       	lddpc	r4,80005dc4 <logFromISR+0xf0>
80005cc8:	80 00       	ld.sh	r0,r0[0x0]
80005cca:	64 a8       	ld.w	r8,r2[0x28]
80005ccc:	00 00       	add	r0,r0
80005cce:	40 00       	lddsp	r0,sp[0x0]
80005cd0:	80 00       	ld.sh	r0,r0[0x0]
80005cd2:	4f 58       	lddpc	r8,80005ea4 <log_init+0x50>

80005cd4 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80005cd4:	d4 31       	pushm	r0-r7,lr
80005cd6:	fa cd 02 0c 	sub	sp,sp,524
80005cda:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80005cdc:	e0 6a 01 00 	mov	r10,256
80005ce0:	30 0b       	mov	r11,0
80005ce2:	fa cc fe f4 	sub	r12,sp,-268
80005ce6:	f0 1f 00 4c 	mcall	80005e14 <logFromISR+0x140>
	//usart_write_line(EXAMPLE_USART, logTmp);
	xQueueSend( logQueue, &p, 5);
}
	
	
int logFromISR(char * content, ...)
80005cea:	fa c4 fd d0 	sub	r4,sp,-560
80005cee:	30 0a       	mov	r10,0
80005cf0:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005cf2:	fa c3 ff fc 	sub	r3,sp,-4
80005cf6:	e0 61 01 00 	mov	r1,256
80005cfa:	14 90       	mov	r0,r10
			
			if(*str == '%')
80005cfc:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005cfe:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005d02:	02 9a       	mov	r10,r1
80005d04:	00 9b       	mov	r11,r0
80005d06:	06 9c       	mov	r12,r3
80005d08:	f0 1f 00 43 	mcall	80005e14 <logFromISR+0x140>
			
			if(*str == '%')
80005d0c:	0f 88       	ld.ub	r8,r7[0x0]
80005d0e:	e4 08 18 00 	cp.b	r8,r2
80005d12:	c5 11       	brne	80005db4 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80005d14:	ee c8 ff ff 	sub	r8,r7,-1
80005d18:	11 89       	ld.ub	r9,r8[0x0]
80005d1a:	4c 0a       	lddpc	r10,80005e18 <logFromISR+0x144>
80005d1c:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80005d1e:	23 09       	sub	r9,48
80005d20:	30 9a       	mov	r10,9
80005d22:	f4 09 18 00 	cp.b	r9,r10
80005d26:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80005d2a:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005d2e:	f7 b9 08 30 	subls	r9,48
80005d32:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80005d36:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80005d3a:	0f 88       	ld.ub	r8,r7[0x0]
80005d3c:	22 58       	sub	r8,37
80005d3e:	e0 48 00 53 	cp.w	r8,83
80005d42:	e0 8b 00 2b 	brhi	80005d98 <logFromISR+0xc4>
80005d46:	4b 69       	lddpc	r9,80005e1c <logFromISR+0x148>
80005d48:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80005d4c:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80005d50:	06 9a       	mov	r10,r3
80005d52:	40 0b       	lddsp	r11,sp[0x0]
80005d54:	5c 5b       	castu.b	r11
80005d56:	68 0c       	ld.w	r12,r4[0x0]
80005d58:	f0 1f 00 32 	mcall	80005e20 <logFromISR+0x14c>
					break;
80005d5c:	c2 38       	rjmp	80005da2 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80005d5e:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80005d62:	06 9a       	mov	r10,r3
80005d64:	40 0b       	lddsp	r11,sp[0x0]
80005d66:	5c 5b       	castu.b	r11
80005d68:	68 0c       	ld.w	r12,r4[0x0]
80005d6a:	f0 1f 00 2f 	mcall	80005e24 <logFromISR+0x150>
80005d6e:	06 9c       	mov	r12,r3
					break;
80005d70:	c1 98       	rjmp	80005da2 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80005d72:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
80005d76:	06 9b       	mov	r11,r3
80005d78:	09 bc       	ld.ub	r12,r4[0x3]
80005d7a:	f0 1f 00 2c 	mcall	80005e28 <logFromISR+0x154>
80005d7e:	06 9c       	mov	r12,r3
					break;
80005d80:	c1 18       	rjmp	80005da2 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80005d82:	e8 c5 ff fc 	sub	r5,r4,-4
80005d86:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80005d88:	c0 d8       	rjmp	80005da2 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80005d8a:	06 9b       	mov	r11,r3
80005d8c:	32 5c       	mov	r12,37
80005d8e:	f0 1f 00 27 	mcall	80005e28 <logFromISR+0x154>
80005d92:	08 95       	mov	r5,r4
80005d94:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
80005d96:	c0 68       	rjmp	80005da2 <logFromISR+0xce>
					default:
					log("I need relax.");
80005d98:	4a 5c       	lddpc	r12,80005e2c <logFromISR+0x158>
80005d9a:	f0 1f 00 26 	mcall	80005e30 <logFromISR+0x15c>
80005d9e:	08 95       	mov	r5,r4
80005da0:	06 9c       	mov	r12,r3
				}
				str++;
80005da2:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005da4:	1a dc       	st.w	--sp,r12
80005da6:	1a d6       	st.w	--sp,r6
80005da8:	4a 3b       	lddpc	r11,80005e34 <logFromISR+0x160>
80005daa:	0c 9c       	mov	r12,r6
80005dac:	f0 1f 00 23 	mcall	80005e38 <logFromISR+0x164>
80005db0:	2f ed       	sub	sp,-8
80005db2:	c0 a8       	rjmp	80005dc6 <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005db4:	2f f7       	sub	r7,-1
80005db6:	1a d8       	st.w	--sp,r8
80005db8:	1a d6       	st.w	--sp,r6
80005dba:	4a 1b       	lddpc	r11,80005e3c <logFromISR+0x168>
80005dbc:	0c 9c       	mov	r12,r6
80005dbe:	f0 1f 00 1f 	mcall	80005e38 <logFromISR+0x164>
80005dc2:	08 95       	mov	r5,r4
80005dc4:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
80005dc6:	0f 89       	ld.ub	r9,r7[0x0]
80005dc8:	30 08       	mov	r8,0
80005dca:	f0 09 18 00 	cp.b	r9,r8
80005dce:	c0 30       	breq	80005dd4 <logFromISR+0x100>
80005dd0:	0a 94       	mov	r4,r5
80005dd2:	c9 8b       	rjmp	80005d02 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80005dd4:	fa c7 fe f4 	sub	r7,sp,-268
80005dd8:	1a d7       	st.w	--sp,r7
80005dda:	49 ab       	lddpc	r11,80005e40 <logFromISR+0x16c>
80005ddc:	0e 9c       	mov	r12,r7
80005dde:	f0 1f 00 17 	mcall	80005e38 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80005de2:	5c 5c       	castu.b	r12
80005de4:	f8 c6 ff ff 	sub	r6,r12,-1
80005de8:	0c 9c       	mov	r12,r6
80005dea:	f0 1f 00 17 	mcall	80005e44 <logFromISR+0x170>
80005dee:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80005df0:	0c 9a       	mov	r10,r6
80005df2:	0e 9b       	mov	r11,r7
80005df4:	f0 1f 00 15 	mcall	80005e48 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80005df8:	30 09       	mov	r9,0
80005dfa:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80005dfc:	fa ca fe f8 	sub	r10,sp,-264
80005e00:	fa cb fe f4 	sub	r11,sp,-268
80005e04:	49 28       	lddpc	r8,80005e4c <logFromISR+0x178>
80005e06:	70 0c       	ld.w	r12,r8[0x0]
80005e08:	f0 1f 00 12 	mcall	80005e50 <logFromISR+0x17c>
80005e0c:	2f fd       	sub	sp,-4
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80005e0e:	fe 3d fd f4 	sub	sp,-524
80005e12:	d8 32       	popm	r0-r7,pc
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	65 f0       	ld.w	r0,r2[0x7c]
80005e18:	00 00       	add	r0,r0
80005e1a:	0d 6d       	ld.uh	sp,--r6
80005e1c:	80 00       	ld.sh	r0,r0[0x0]
80005e1e:	c6 6c       	rcall	80005eea <task_log+0x2e>
80005e20:	80 00       	ld.sh	r0,r0[0x0]
80005e22:	5a 6e       	cp.w	lr,-26
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	59 bc       	cp.w	r12,27
80005e28:	80 00       	ld.sh	r0,r0[0x0]
80005e2a:	59 b8       	cp.w	r8,27
80005e2c:	80 00       	ld.sh	r0,r0[0x0]
80005e2e:	c7 d8       	rjmp	80005f28 <main+0x28>
80005e30:	80 00       	ld.sh	r0,r0[0x0]
80005e32:	5b 48       	cp.w	r8,-12
80005e34:	80 00       	ld.sh	r0,r0[0x0]
80005e36:	c7 e8       	rjmp	80005f32 <main+0x32>
80005e38:	80 00       	ld.sh	r0,r0[0x0]
80005e3a:	68 e0       	ld.w	r0,r4[0x38]
80005e3c:	80 00       	ld.sh	r0,r0[0x0]
80005e3e:	c7 f0       	breq	80005f3c <main+0x3c>
80005e40:	80 00       	ld.sh	r0,r0[0x0]
80005e42:	c7 f8       	rjmp	80005f40 <main+0x40>
80005e44:	80 00       	ld.sh	r0,r0[0x0]
80005e46:	4c 04       	lddpc	r4,80005f44 <main+0x44>
80005e48:	80 00       	ld.sh	r0,r0[0x0]
80005e4a:	64 a8       	ld.w	r8,r2[0x28]
80005e4c:	00 00       	add	r0,r0
80005e4e:	40 00       	lddsp	r0,sp[0x0]
80005e50:	80 00       	ld.sh	r0,r0[0x0]
80005e52:	4f 08       	lddpc	r8,80006010 <_stext>

80005e54 <log_init>:
		
	return str;
}

void log_init(void)
{
80005e54:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80005e56:	30 2b       	mov	r11,2
80005e58:	49 0c       	lddpc	r12,80005e98 <log_init+0x44>
80005e5a:	f0 1f 00 11 	mcall	80005e9c <log_init+0x48>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80005e5e:	e0 6a 36 00 	mov	r10,13824
80005e62:	ea 1a 01 6e 	orh	r10,0x16e
80005e66:	48 fb       	lddpc	r11,80005ea0 <log_init+0x4c>
80005e68:	fe 7c 18 00 	mov	r12,-59392
80005e6c:	f0 1f 00 0e 	mcall	80005ea4 <log_init+0x50>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80005e70:	30 4b       	mov	r11,4
80005e72:	33 2c       	mov	r12,50
80005e74:	f0 1f 00 0d 	mcall	80005ea8 <log_init+0x54>
80005e78:	48 d8       	lddpc	r8,80005eac <log_init+0x58>
80005e7a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80005e7c:	30 09       	mov	r9,0
80005e7e:	1a d9       	st.w	--sp,r9
80005e80:	1a d9       	st.w	--sp,r9
80005e82:	1a d9       	st.w	--sp,r9
80005e84:	30 28       	mov	r8,2
80005e86:	e0 6a 01 80 	mov	r10,384
80005e8a:	48 ab       	lddpc	r11,80005eb0 <log_init+0x5c>
80005e8c:	48 ac       	lddpc	r12,80005eb4 <log_init+0x60>
80005e8e:	f0 1f 00 0b 	mcall	80005eb8 <log_init+0x64>
80005e92:	2f dd       	sub	sp,-12
	,  384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80005e94:	d8 02       	popm	pc
80005e96:	00 00       	add	r0,r0
80005e98:	80 00       	ld.sh	r0,r0[0x0]
80005e9a:	c8 04       	brge	80005d9a <logFromISR+0xc6>
80005e9c:	80 00       	ld.sh	r0,r0[0x0]
80005e9e:	5f e0       	srqs	r0
80005ea0:	80 00       	ld.sh	r0,r0[0x0]
80005ea2:	c7 bc       	rcall	80005f98 <gpio_enable_module_pin+0xc>
80005ea4:	80 00       	ld.sh	r0,r0[0x0]
80005ea6:	47 a8       	lddsp	r8,sp[0x1e8]
80005ea8:	80 00       	ld.sh	r0,r0[0x0]
80005eaa:	50 b0       	stdsp	sp[0x2c],r0
80005eac:	00 00       	add	r0,r0
80005eae:	40 00       	lddsp	r0,sp[0x0]
80005eb0:	80 00       	ld.sh	r0,r0[0x0]
80005eb2:	c8 00       	breq	80005db2 <logFromISR+0xde>
80005eb4:	80 00       	ld.sh	r0,r0[0x0]
80005eb6:	5e bc       	rethi	r12
80005eb8:	80 00       	ld.sh	r0,r0[0x0]
80005eba:	57 84       	stdsp	sp[0x1e0],r4

80005ebc <task_log>:
			////taskYIELD();
		//}
	}
	
static void task_log(void * pvParameters)
{
80005ebc:	eb cd 40 f8 	pushm	r3-r7,lr
80005ec0:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80005ec2:	48 c7       	lddpc	r7,80005ef0 <task_log+0x34>
80005ec4:	30 05       	mov	r5,0
80005ec6:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80005ec8:	fe 73 18 00 	mov	r3,-59392
{
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80005ecc:	0a 99       	mov	r9,r5
80005ece:	08 9a       	mov	r10,r4
80005ed0:	1a 9b       	mov	r11,sp
80005ed2:	6e 0c       	ld.w	r12,r7[0x0]
80005ed4:	f0 1f 00 08 	mcall	80005ef4 <task_log+0x38>
80005ed8:	58 1c       	cp.w	r12,1
80005eda:	cf 91       	brne	80005ecc <task_log+0x10>
		{
			if( NULL != str)
80005edc:	40 0b       	lddsp	r11,sp[0x0]
80005ede:	58 0b       	cp.w	r11,0
80005ee0:	cf 60       	breq	80005ecc <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80005ee2:	06 9c       	mov	r12,r3
80005ee4:	f0 1f 00 05 	mcall	80005ef8 <task_log+0x3c>
				vPortFree(str);
80005ee8:	40 0c       	lddsp	r12,sp[0x0]
80005eea:	f0 1f 00 05 	mcall	80005efc <task_log+0x40>
80005eee:	ce fb       	rjmp	80005ecc <task_log+0x10>
80005ef0:	00 00       	add	r0,r0
80005ef2:	40 00       	lddsp	r0,sp[0x0]
80005ef4:	80 00       	ld.sh	r0,r0[0x0]
80005ef6:	4d 4c       	lddpc	r12,80006044 <udata_clear_loop>
80005ef8:	80 00       	ld.sh	r0,r0[0x0]
80005efa:	47 58       	lddsp	r8,sp[0x1d4]
80005efc:	80 00       	ld.sh	r0,r0[0x0]
80005efe:	4b dc       	lddpc	r12,80005ff0 <gpio_enable_module+0x10>

80005f00 <main>:

#include "fs/fs.h"
#include "rtc/rtc.h"

int main(void)
{
80005f00:	d4 01       	pushm	lr
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80005f02:	fe 78 10 00 	mov	r8,-61440
80005f06:	30 19       	mov	r9,1
80005f08:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80005f0c:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80005f10:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80005f14:	d3 03       	ssrf	0x10
	local_start_pll0();
80005f16:	f0 1f 00 13 	mcall	80005f60 <main+0x60>
		
	INTC_init_interrupts();
80005f1a:	f0 1f 00 13 	mcall	80005f64 <main+0x64>
	
	log_init();		
80005f1e:	f0 1f 00 13 	mcall	80005f68 <main+0x68>
	log("----start debug----");	
80005f22:	49 3c       	lddpc	r12,80005f6c <main+0x6c>
80005f24:	f0 1f 00 13 	mcall	80005f70 <main+0x70>
		
	rtc_init();
80005f28:	f0 1f 00 13 	mcall	80005f74 <main+0x74>
	
	//fs_init();//65795机器无法通过文件系统初始化

	tc_init();	
80005f2c:	f0 1f 00 13 	mcall	80005f78 <main+0x78>
			
	xcmp_init();
80005f30:	f0 1f 00 13 	mcall	80005f7c <main+0x7c>
	
	app_init();
80005f34:	f0 1f 00 13 	mcall	80005f80 <main+0x80>
		
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80005f38:	fe 79 10 00 	mov	r9,-61440
80005f3c:	f2 f8 01 60 	ld.w	r8,r9[352]
80005f40:	e2 18 00 02 	andl	r8,0x2,COH
80005f44:	cf c0       	breq	80005f3c <main+0x3c>
	while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80005f46:	fe 79 10 00 	mov	r9,-61440
80005f4a:	f2 f8 01 60 	ld.w	r8,r9[352]
80005f4e:	e2 18 00 02 	andl	r8,0x2,COH
80005f52:	cf c1       	brne	80005f4a <main+0x4a>
	local_start_timer();
80005f54:	f0 1f 00 0c 	mcall	80005f84 <main+0x84>
	
	Enable_global_interrupt();
80005f58:	d5 03       	csrf	0x10
	
	vTaskStartScheduler();		
80005f5a:	f0 1f 00 0c 	mcall	80005f88 <main+0x88>
	return 0;
}
80005f5e:	d8 0a       	popm	pc,r12=0
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	40 78       	lddsp	r8,sp[0x1c]
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	42 94       	lddsp	r4,sp[0xa4]
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	5e 54       	retlt	r4
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	c8 14       	brge	80005e70 <log_init+0x1c>
80005f70:	80 00       	ld.sh	r0,r0[0x0]
80005f72:	5b 48       	cp.w	r8,-12
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	40 c8       	lddsp	r8,sp[0x30]
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	41 90       	lddsp	r0,sp[0x64]
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	39 7c       	mov	r12,-105
80005f80:	80 00       	ld.sh	r0,r0[0x0]
80005f82:	20 40       	sub	r0,4
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	41 54       	lddsp	r4,sp[0x54]
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	59 6c       	cp.w	r12,22

80005f8c <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005f8c:	f8 08 16 05 	lsr	r8,r12,0x5
80005f90:	a9 68       	lsl	r8,0x8
80005f92:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005f96:	58 1b       	cp.w	r11,1
80005f98:	c0 d0       	breq	80005fb2 <gpio_enable_module_pin+0x26>
80005f9a:	c0 63       	brcs	80005fa6 <gpio_enable_module_pin+0x1a>
80005f9c:	58 2b       	cp.w	r11,2
80005f9e:	c1 00       	breq	80005fbe <gpio_enable_module_pin+0x32>
80005fa0:	58 3b       	cp.w	r11,3
80005fa2:	c1 40       	breq	80005fca <gpio_enable_module_pin+0x3e>
80005fa4:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005fa6:	30 19       	mov	r9,1
80005fa8:	f2 0c 09 49 	lsl	r9,r9,r12
80005fac:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005fae:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005fb0:	c1 28       	rjmp	80005fd4 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005fb2:	30 19       	mov	r9,1
80005fb4:	f2 0c 09 49 	lsl	r9,r9,r12
80005fb8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005fba:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005fbc:	c0 c8       	rjmp	80005fd4 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005fbe:	30 19       	mov	r9,1
80005fc0:	f2 0c 09 49 	lsl	r9,r9,r12
80005fc4:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005fc6:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005fc8:	c0 68       	rjmp	80005fd4 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005fca:	30 19       	mov	r9,1
80005fcc:	f2 0c 09 49 	lsl	r9,r9,r12
80005fd0:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005fd2:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80005fd4:	30 19       	mov	r9,1
80005fd6:	f2 0c 09 4c 	lsl	r12,r9,r12
80005fda:	91 2c       	st.w	r8[0x8],r12
80005fdc:	5e fd       	retal	0
80005fde:	d7 03       	nop

80005fe0 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80005fe0:	d4 21       	pushm	r4-r7,lr
80005fe2:	18 97       	mov	r7,r12
80005fe4:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005fe6:	58 0b       	cp.w	r11,0
80005fe8:	c0 31       	brne	80005fee <gpio_enable_module+0xe>
80005fea:	30 05       	mov	r5,0
80005fec:	c0 d8       	rjmp	80006006 <gpio_enable_module+0x26>
80005fee:	30 06       	mov	r6,0
80005ff0:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005ff2:	6e 1b       	ld.w	r11,r7[0x4]
80005ff4:	6e 0c       	ld.w	r12,r7[0x0]
80005ff6:	f0 1f 00 06 	mcall	8000600c <gpio_enable_module+0x2c>
80005ffa:	18 45       	or	r5,r12
		gpiomap++;
80005ffc:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005ffe:	2f f6       	sub	r6,-1
80006000:	0c 34       	cp.w	r4,r6
80006002:	fe 9b ff f8 	brhi	80005ff2 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006006:	0a 9c       	mov	r12,r5
80006008:	d8 22       	popm	r4-r7,pc
8000600a:	00 00       	add	r0,r0
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	5f 8c       	srls	r12

80006010 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006010:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006014:	fe c0 a6 14 	sub	r0,pc,-23020

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006018:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
8000601c:	d5 53       	csrf	0x15
  cp      r0, r1
8000601e:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80006020:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006024:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006026:	c0 72       	brcc	80006034 <idata_load_loop_end>
  cp      r0, r1
80006028:	fe c2 92 78 	sub	r2,pc,-28040

8000602c <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
8000602c:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000602e:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80006030:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80006032:	cf d3       	brcs	8000602c <idata_load_loop>

80006034 <idata_load_loop_end>:
  mov     r2, 0
80006034:	e0 60 0a 40 	mov	r0,2624
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006038:	e0 61 40 08 	mov	r1,16392
  cp      r0, r1
  brlo    udata_clear_loop
8000603c:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000603e:	c0 62       	brcc	8000604a <udata_clear_loop_end>
80006040:	30 02       	mov	r2,0
80006042:	30 03       	mov	r3,0

80006044 <udata_clear_loop>:
80006044:	a1 22       	st.d	r0++,r2
80006046:	02 30       	cp.w	r0,r1
80006048:	cf e3       	brcs	80006044 <udata_clear_loop>

8000604a <udata_clear_loop_end>:
8000604a:	fe cf 01 4a 	sub	pc,pc,330
8000604e:	d7 03       	nop

80006050 <free>:
80006050:	d4 01       	pushm	lr
80006052:	e0 68 0a 38 	mov	r8,2616
80006056:	18 9b       	mov	r11,r12
80006058:	70 0c       	ld.w	r12,r8[0x0]
8000605a:	e0 a0 1e 6d 	rcall	80009d34 <_free_r>
8000605e:	d8 02       	popm	pc

80006060 <malloc>:
80006060:	d4 01       	pushm	lr
80006062:	e0 68 0a 38 	mov	r8,2616
80006066:	18 9b       	mov	r11,r12
80006068:	70 0c       	ld.w	r12,r8[0x0]
8000606a:	c0 3c       	rcall	80006070 <_malloc_r>
8000606c:	d8 02       	popm	pc
8000606e:	d7 03       	nop

80006070 <_malloc_r>:
80006070:	d4 31       	pushm	r0-r7,lr
80006072:	f6 c8 ff f5 	sub	r8,r11,-11
80006076:	18 95       	mov	r5,r12
80006078:	10 97       	mov	r7,r8
8000607a:	e0 17 ff f8 	andl	r7,0xfff8
8000607e:	59 68       	cp.w	r8,22
80006080:	f9 b7 08 10 	movls	r7,16
80006084:	16 37       	cp.w	r7,r11
80006086:	5f 38       	srlo	r8
80006088:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000608c:	c0 50       	breq	80006096 <_malloc_r+0x26>
8000608e:	30 c8       	mov	r8,12
80006090:	99 38       	st.w	r12[0xc],r8
80006092:	e0 8f 01 fa 	bral	80006486 <_malloc_r+0x416>
80006096:	fe b0 f5 59 	rcall	80004b48 <__malloc_lock>
8000609a:	e0 47 01 f7 	cp.w	r7,503
8000609e:	e0 8b 00 1d 	brhi	800060d8 <_malloc_r+0x68>
800060a2:	ee 03 16 03 	lsr	r3,r7,0x3
800060a6:	e0 68 05 38 	mov	r8,1336
800060aa:	f0 03 00 38 	add	r8,r8,r3<<0x3
800060ae:	70 36       	ld.w	r6,r8[0xc]
800060b0:	10 36       	cp.w	r6,r8
800060b2:	c0 61       	brne	800060be <_malloc_r+0x4e>
800060b4:	ec c8 ff f8 	sub	r8,r6,-8
800060b8:	70 36       	ld.w	r6,r8[0xc]
800060ba:	10 36       	cp.w	r6,r8
800060bc:	c0 c0       	breq	800060d4 <_malloc_r+0x64>
800060be:	6c 18       	ld.w	r8,r6[0x4]
800060c0:	e0 18 ff fc 	andl	r8,0xfffc
800060c4:	6c 3a       	ld.w	r10,r6[0xc]
800060c6:	ec 08 00 09 	add	r9,r6,r8
800060ca:	0a 9c       	mov	r12,r5
800060cc:	6c 28       	ld.w	r8,r6[0x8]
800060ce:	95 28       	st.w	r10[0x8],r8
800060d0:	91 3a       	st.w	r8[0xc],r10
800060d2:	c4 78       	rjmp	80006160 <_malloc_r+0xf0>
800060d4:	2f e3       	sub	r3,-2
800060d6:	c4 d8       	rjmp	80006170 <_malloc_r+0x100>
800060d8:	ee 03 16 09 	lsr	r3,r7,0x9
800060dc:	c0 41       	brne	800060e4 <_malloc_r+0x74>
800060de:	ee 03 16 03 	lsr	r3,r7,0x3
800060e2:	c2 68       	rjmp	8000612e <_malloc_r+0xbe>
800060e4:	58 43       	cp.w	r3,4
800060e6:	e0 8b 00 06 	brhi	800060f2 <_malloc_r+0x82>
800060ea:	ee 03 16 06 	lsr	r3,r7,0x6
800060ee:	2c 83       	sub	r3,-56
800060f0:	c1 f8       	rjmp	8000612e <_malloc_r+0xbe>
800060f2:	59 43       	cp.w	r3,20
800060f4:	e0 8b 00 04 	brhi	800060fc <_malloc_r+0x8c>
800060f8:	2a 53       	sub	r3,-91
800060fa:	c1 a8       	rjmp	8000612e <_malloc_r+0xbe>
800060fc:	e0 43 00 54 	cp.w	r3,84
80006100:	e0 8b 00 06 	brhi	8000610c <_malloc_r+0x9c>
80006104:	ee 03 16 0c 	lsr	r3,r7,0xc
80006108:	29 23       	sub	r3,-110
8000610a:	c1 28       	rjmp	8000612e <_malloc_r+0xbe>
8000610c:	e0 43 01 54 	cp.w	r3,340
80006110:	e0 8b 00 06 	brhi	8000611c <_malloc_r+0xac>
80006114:	ee 03 16 0f 	lsr	r3,r7,0xf
80006118:	28 93       	sub	r3,-119
8000611a:	c0 a8       	rjmp	8000612e <_malloc_r+0xbe>
8000611c:	e0 43 05 54 	cp.w	r3,1364
80006120:	e0 88 00 04 	brls	80006128 <_malloc_r+0xb8>
80006124:	37 e3       	mov	r3,126
80006126:	c0 48       	rjmp	8000612e <_malloc_r+0xbe>
80006128:	ee 03 16 12 	lsr	r3,r7,0x12
8000612c:	28 43       	sub	r3,-124
8000612e:	e0 6a 05 38 	mov	r10,1336
80006132:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80006136:	74 36       	ld.w	r6,r10[0xc]
80006138:	c1 98       	rjmp	8000616a <_malloc_r+0xfa>
8000613a:	6c 19       	ld.w	r9,r6[0x4]
8000613c:	e0 19 ff fc 	andl	r9,0xfffc
80006140:	f2 07 01 0b 	sub	r11,r9,r7
80006144:	58 fb       	cp.w	r11,15
80006146:	e0 8a 00 04 	brle	8000614e <_malloc_r+0xde>
8000614a:	20 13       	sub	r3,1
8000614c:	c1 18       	rjmp	8000616e <_malloc_r+0xfe>
8000614e:	6c 38       	ld.w	r8,r6[0xc]
80006150:	58 0b       	cp.w	r11,0
80006152:	c0 b5       	brlt	80006168 <_malloc_r+0xf8>
80006154:	6c 2a       	ld.w	r10,r6[0x8]
80006156:	ec 09 00 09 	add	r9,r6,r9
8000615a:	0a 9c       	mov	r12,r5
8000615c:	91 2a       	st.w	r8[0x8],r10
8000615e:	95 38       	st.w	r10[0xc],r8
80006160:	72 18       	ld.w	r8,r9[0x4]
80006162:	a1 a8       	sbr	r8,0x0
80006164:	93 18       	st.w	r9[0x4],r8
80006166:	cb c8       	rjmp	800062de <_malloc_r+0x26e>
80006168:	10 96       	mov	r6,r8
8000616a:	14 36       	cp.w	r6,r10
8000616c:	ce 71       	brne	8000613a <_malloc_r+0xca>
8000616e:	2f f3       	sub	r3,-1
80006170:	e0 6a 05 38 	mov	r10,1336
80006174:	f4 cc ff f8 	sub	r12,r10,-8
80006178:	78 26       	ld.w	r6,r12[0x8]
8000617a:	18 36       	cp.w	r6,r12
8000617c:	c6 c0       	breq	80006254 <_malloc_r+0x1e4>
8000617e:	6c 19       	ld.w	r9,r6[0x4]
80006180:	e0 19 ff fc 	andl	r9,0xfffc
80006184:	f2 07 01 08 	sub	r8,r9,r7
80006188:	58 f8       	cp.w	r8,15
8000618a:	e0 89 00 8f 	brgt	800062a8 <_malloc_r+0x238>
8000618e:	99 3c       	st.w	r12[0xc],r12
80006190:	99 2c       	st.w	r12[0x8],r12
80006192:	58 08       	cp.w	r8,0
80006194:	c0 55       	brlt	8000619e <_malloc_r+0x12e>
80006196:	ec 09 00 09 	add	r9,r6,r9
8000619a:	0a 9c       	mov	r12,r5
8000619c:	ce 2b       	rjmp	80006160 <_malloc_r+0xf0>
8000619e:	e0 49 01 ff 	cp.w	r9,511
800061a2:	e0 8b 00 13 	brhi	800061c8 <_malloc_r+0x158>
800061a6:	a3 99       	lsr	r9,0x3
800061a8:	f4 09 00 38 	add	r8,r10,r9<<0x3
800061ac:	70 2b       	ld.w	r11,r8[0x8]
800061ae:	8d 38       	st.w	r6[0xc],r8
800061b0:	8d 2b       	st.w	r6[0x8],r11
800061b2:	97 36       	st.w	r11[0xc],r6
800061b4:	91 26       	st.w	r8[0x8],r6
800061b6:	a3 49       	asr	r9,0x2
800061b8:	74 18       	ld.w	r8,r10[0x4]
800061ba:	30 1b       	mov	r11,1
800061bc:	f6 09 09 49 	lsl	r9,r11,r9
800061c0:	f1 e9 10 09 	or	r9,r8,r9
800061c4:	95 19       	st.w	r10[0x4],r9
800061c6:	c4 78       	rjmp	80006254 <_malloc_r+0x1e4>
800061c8:	f2 0a 16 09 	lsr	r10,r9,0x9
800061cc:	58 4a       	cp.w	r10,4
800061ce:	e0 8b 00 07 	brhi	800061dc <_malloc_r+0x16c>
800061d2:	f2 0a 16 06 	lsr	r10,r9,0x6
800061d6:	2c 8a       	sub	r10,-56
800061d8:	c2 08       	rjmp	80006218 <_malloc_r+0x1a8>
800061da:	d7 03       	nop
800061dc:	59 4a       	cp.w	r10,20
800061de:	e0 8b 00 04 	brhi	800061e6 <_malloc_r+0x176>
800061e2:	2a 5a       	sub	r10,-91
800061e4:	c1 a8       	rjmp	80006218 <_malloc_r+0x1a8>
800061e6:	e0 4a 00 54 	cp.w	r10,84
800061ea:	e0 8b 00 06 	brhi	800061f6 <_malloc_r+0x186>
800061ee:	f2 0a 16 0c 	lsr	r10,r9,0xc
800061f2:	29 2a       	sub	r10,-110
800061f4:	c1 28       	rjmp	80006218 <_malloc_r+0x1a8>
800061f6:	e0 4a 01 54 	cp.w	r10,340
800061fa:	e0 8b 00 06 	brhi	80006206 <_malloc_r+0x196>
800061fe:	f2 0a 16 0f 	lsr	r10,r9,0xf
80006202:	28 9a       	sub	r10,-119
80006204:	c0 a8       	rjmp	80006218 <_malloc_r+0x1a8>
80006206:	e0 4a 05 54 	cp.w	r10,1364
8000620a:	e0 88 00 04 	brls	80006212 <_malloc_r+0x1a2>
8000620e:	37 ea       	mov	r10,126
80006210:	c0 48       	rjmp	80006218 <_malloc_r+0x1a8>
80006212:	f2 0a 16 12 	lsr	r10,r9,0x12
80006216:	28 4a       	sub	r10,-124
80006218:	e0 6b 05 38 	mov	r11,1336
8000621c:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80006220:	68 28       	ld.w	r8,r4[0x8]
80006222:	08 38       	cp.w	r8,r4
80006224:	c0 e1       	brne	80006240 <_malloc_r+0x1d0>
80006226:	76 19       	ld.w	r9,r11[0x4]
80006228:	a3 4a       	asr	r10,0x2
8000622a:	30 1e       	mov	lr,1
8000622c:	fc 0a 09 4a 	lsl	r10,lr,r10
80006230:	f3 ea 10 0a 	or	r10,r9,r10
80006234:	10 99       	mov	r9,r8
80006236:	97 1a       	st.w	r11[0x4],r10
80006238:	c0 a8       	rjmp	8000624c <_malloc_r+0x1dc>
8000623a:	70 28       	ld.w	r8,r8[0x8]
8000623c:	08 38       	cp.w	r8,r4
8000623e:	c0 60       	breq	8000624a <_malloc_r+0x1da>
80006240:	70 1a       	ld.w	r10,r8[0x4]
80006242:	e0 1a ff fc 	andl	r10,0xfffc
80006246:	14 39       	cp.w	r9,r10
80006248:	cf 93       	brcs	8000623a <_malloc_r+0x1ca>
8000624a:	70 39       	ld.w	r9,r8[0xc]
8000624c:	8d 39       	st.w	r6[0xc],r9
8000624e:	8d 28       	st.w	r6[0x8],r8
80006250:	91 36       	st.w	r8[0xc],r6
80006252:	93 26       	st.w	r9[0x8],r6
80006254:	e6 08 14 02 	asr	r8,r3,0x2
80006258:	30 1b       	mov	r11,1
8000625a:	e0 64 05 38 	mov	r4,1336
8000625e:	f6 08 09 4b 	lsl	r11,r11,r8
80006262:	68 18       	ld.w	r8,r4[0x4]
80006264:	10 3b       	cp.w	r11,r8
80006266:	e0 8b 00 6b 	brhi	8000633c <_malloc_r+0x2cc>
8000626a:	f7 e8 00 09 	and	r9,r11,r8
8000626e:	c0 b1       	brne	80006284 <_malloc_r+0x214>
80006270:	e0 13 ff fc 	andl	r3,0xfffc
80006274:	a1 7b       	lsl	r11,0x1
80006276:	2f c3       	sub	r3,-4
80006278:	c0 38       	rjmp	8000627e <_malloc_r+0x20e>
8000627a:	2f c3       	sub	r3,-4
8000627c:	a1 7b       	lsl	r11,0x1
8000627e:	f7 e8 00 09 	and	r9,r11,r8
80006282:	cf c0       	breq	8000627a <_malloc_r+0x20a>
80006284:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006288:	06 92       	mov	r2,r3
8000628a:	1c 91       	mov	r1,lr
8000628c:	62 36       	ld.w	r6,r1[0xc]
8000628e:	c2 e8       	rjmp	800062ea <_malloc_r+0x27a>
80006290:	6c 1a       	ld.w	r10,r6[0x4]
80006292:	e0 1a ff fc 	andl	r10,0xfffc
80006296:	f4 07 01 08 	sub	r8,r10,r7
8000629a:	58 f8       	cp.w	r8,15
8000629c:	e0 8a 00 15 	brle	800062c6 <_malloc_r+0x256>
800062a0:	6c 3a       	ld.w	r10,r6[0xc]
800062a2:	6c 29       	ld.w	r9,r6[0x8]
800062a4:	95 29       	st.w	r10[0x8],r9
800062a6:	93 3a       	st.w	r9[0xc],r10
800062a8:	0e 99       	mov	r9,r7
800062aa:	ec 07 00 07 	add	r7,r6,r7
800062ae:	a1 a9       	sbr	r9,0x0
800062b0:	99 37       	st.w	r12[0xc],r7
800062b2:	99 27       	st.w	r12[0x8],r7
800062b4:	8d 19       	st.w	r6[0x4],r9
800062b6:	ee 08 09 08 	st.w	r7[r8],r8
800062ba:	8f 2c       	st.w	r7[0x8],r12
800062bc:	8f 3c       	st.w	r7[0xc],r12
800062be:	a1 a8       	sbr	r8,0x0
800062c0:	0a 9c       	mov	r12,r5
800062c2:	8f 18       	st.w	r7[0x4],r8
800062c4:	c0 d8       	rjmp	800062de <_malloc_r+0x26e>
800062c6:	6c 39       	ld.w	r9,r6[0xc]
800062c8:	58 08       	cp.w	r8,0
800062ca:	c0 f5       	brlt	800062e8 <_malloc_r+0x278>
800062cc:	ec 0a 00 0a 	add	r10,r6,r10
800062d0:	74 18       	ld.w	r8,r10[0x4]
800062d2:	a1 a8       	sbr	r8,0x0
800062d4:	0a 9c       	mov	r12,r5
800062d6:	95 18       	st.w	r10[0x4],r8
800062d8:	6c 28       	ld.w	r8,r6[0x8]
800062da:	93 28       	st.w	r9[0x8],r8
800062dc:	91 39       	st.w	r8[0xc],r9
800062de:	fe b0 f4 3b 	rcall	80004b54 <__malloc_unlock>
800062e2:	ec cc ff f8 	sub	r12,r6,-8
800062e6:	d8 32       	popm	r0-r7,pc
800062e8:	12 96       	mov	r6,r9
800062ea:	02 36       	cp.w	r6,r1
800062ec:	cd 21       	brne	80006290 <_malloc_r+0x220>
800062ee:	2f f2       	sub	r2,-1
800062f0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800062f4:	c0 30       	breq	800062fa <_malloc_r+0x28a>
800062f6:	2f 81       	sub	r1,-8
800062f8:	cc ab       	rjmp	8000628c <_malloc_r+0x21c>
800062fa:	1c 98       	mov	r8,lr
800062fc:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80006300:	c0 81       	brne	80006310 <_malloc_r+0x2a0>
80006302:	68 19       	ld.w	r9,r4[0x4]
80006304:	f6 08 11 ff 	rsub	r8,r11,-1
80006308:	f3 e8 00 08 	and	r8,r9,r8
8000630c:	89 18       	st.w	r4[0x4],r8
8000630e:	c0 78       	rjmp	8000631c <_malloc_r+0x2ac>
80006310:	f0 c9 00 08 	sub	r9,r8,8
80006314:	20 13       	sub	r3,1
80006316:	70 08       	ld.w	r8,r8[0x0]
80006318:	12 38       	cp.w	r8,r9
8000631a:	cf 10       	breq	800062fc <_malloc_r+0x28c>
8000631c:	a1 7b       	lsl	r11,0x1
8000631e:	68 18       	ld.w	r8,r4[0x4]
80006320:	10 3b       	cp.w	r11,r8
80006322:	e0 8b 00 0d 	brhi	8000633c <_malloc_r+0x2cc>
80006326:	58 0b       	cp.w	r11,0
80006328:	c0 a0       	breq	8000633c <_malloc_r+0x2cc>
8000632a:	04 93       	mov	r3,r2
8000632c:	c0 38       	rjmp	80006332 <_malloc_r+0x2c2>
8000632e:	2f c3       	sub	r3,-4
80006330:	a1 7b       	lsl	r11,0x1
80006332:	f7 e8 00 09 	and	r9,r11,r8
80006336:	ca 71       	brne	80006284 <_malloc_r+0x214>
80006338:	cf bb       	rjmp	8000632e <_malloc_r+0x2be>
8000633a:	d7 03       	nop
8000633c:	68 23       	ld.w	r3,r4[0x8]
8000633e:	66 12       	ld.w	r2,r3[0x4]
80006340:	e0 12 ff fc 	andl	r2,0xfffc
80006344:	0e 32       	cp.w	r2,r7
80006346:	5f 39       	srlo	r9
80006348:	e4 07 01 08 	sub	r8,r2,r7
8000634c:	58 f8       	cp.w	r8,15
8000634e:	5f aa       	srle	r10
80006350:	f5 e9 10 09 	or	r9,r10,r9
80006354:	e0 80 00 9a 	breq	80006488 <_malloc_r+0x418>
80006358:	e0 68 0d 78 	mov	r8,3448
8000635c:	70 01       	ld.w	r1,r8[0x0]
8000635e:	e0 68 09 44 	mov	r8,2372
80006362:	2f 01       	sub	r1,-16
80006364:	70 08       	ld.w	r8,r8[0x0]
80006366:	0e 01       	add	r1,r7
80006368:	5b f8       	cp.w	r8,-1
8000636a:	c0 40       	breq	80006372 <_malloc_r+0x302>
8000636c:	28 11       	sub	r1,-127
8000636e:	e0 11 ff 80 	andl	r1,0xff80
80006372:	02 9b       	mov	r11,r1
80006374:	0a 9c       	mov	r12,r5
80006376:	e0 a0 02 a5 	rcall	800068c0 <_sbrk_r>
8000637a:	18 96       	mov	r6,r12
8000637c:	5b fc       	cp.w	r12,-1
8000637e:	c7 50       	breq	80006468 <_malloc_r+0x3f8>
80006380:	e6 02 00 08 	add	r8,r3,r2
80006384:	10 3c       	cp.w	r12,r8
80006386:	c0 32       	brcc	8000638c <_malloc_r+0x31c>
80006388:	08 33       	cp.w	r3,r4
8000638a:	c6 f1       	brne	80006468 <_malloc_r+0x3f8>
8000638c:	e0 6a 0d 7c 	mov	r10,3452
80006390:	74 09       	ld.w	r9,r10[0x0]
80006392:	e2 09 00 09 	add	r9,r1,r9
80006396:	95 09       	st.w	r10[0x0],r9
80006398:	10 36       	cp.w	r6,r8
8000639a:	c0 a1       	brne	800063ae <_malloc_r+0x33e>
8000639c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800063a0:	c0 71       	brne	800063ae <_malloc_r+0x33e>
800063a2:	e2 02 00 02 	add	r2,r1,r2
800063a6:	68 28       	ld.w	r8,r4[0x8]
800063a8:	a1 a2       	sbr	r2,0x0
800063aa:	91 12       	st.w	r8[0x4],r2
800063ac:	c4 f8       	rjmp	8000644a <_malloc_r+0x3da>
800063ae:	e0 6a 09 44 	mov	r10,2372
800063b2:	74 0b       	ld.w	r11,r10[0x0]
800063b4:	5b fb       	cp.w	r11,-1
800063b6:	c0 31       	brne	800063bc <_malloc_r+0x34c>
800063b8:	95 06       	st.w	r10[0x0],r6
800063ba:	c0 78       	rjmp	800063c8 <_malloc_r+0x358>
800063bc:	ec 09 00 09 	add	r9,r6,r9
800063c0:	e0 6a 0d 7c 	mov	r10,3452
800063c4:	10 19       	sub	r9,r8
800063c6:	95 09       	st.w	r10[0x0],r9
800063c8:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800063cc:	f0 09 11 08 	rsub	r9,r8,8
800063d0:	58 08       	cp.w	r8,0
800063d2:	f2 08 17 10 	movne	r8,r9
800063d6:	ed d8 e1 06 	addne	r6,r6,r8
800063da:	28 08       	sub	r8,-128
800063dc:	ec 01 00 01 	add	r1,r6,r1
800063e0:	0a 9c       	mov	r12,r5
800063e2:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800063e6:	f0 01 01 01 	sub	r1,r8,r1
800063ea:	02 9b       	mov	r11,r1
800063ec:	e0 a0 02 6a 	rcall	800068c0 <_sbrk_r>
800063f0:	e0 68 0d 7c 	mov	r8,3452
800063f4:	5b fc       	cp.w	r12,-1
800063f6:	ec 0c 17 00 	moveq	r12,r6
800063fa:	f9 b1 00 00 	moveq	r1,0
800063fe:	70 09       	ld.w	r9,r8[0x0]
80006400:	0c 1c       	sub	r12,r6
80006402:	89 26       	st.w	r4[0x8],r6
80006404:	02 0c       	add	r12,r1
80006406:	12 01       	add	r1,r9
80006408:	a1 ac       	sbr	r12,0x0
8000640a:	91 01       	st.w	r8[0x0],r1
8000640c:	8d 1c       	st.w	r6[0x4],r12
8000640e:	08 33       	cp.w	r3,r4
80006410:	c1 d0       	breq	8000644a <_malloc_r+0x3da>
80006412:	58 f2       	cp.w	r2,15
80006414:	e0 8b 00 05 	brhi	8000641e <_malloc_r+0x3ae>
80006418:	30 18       	mov	r8,1
8000641a:	8d 18       	st.w	r6[0x4],r8
8000641c:	c2 68       	rjmp	80006468 <_malloc_r+0x3f8>
8000641e:	30 59       	mov	r9,5
80006420:	20 c2       	sub	r2,12
80006422:	e0 12 ff f8 	andl	r2,0xfff8
80006426:	e6 02 00 08 	add	r8,r3,r2
8000642a:	91 29       	st.w	r8[0x8],r9
8000642c:	91 19       	st.w	r8[0x4],r9
8000642e:	66 18       	ld.w	r8,r3[0x4]
80006430:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006434:	e5 e8 10 08 	or	r8,r2,r8
80006438:	87 18       	st.w	r3[0x4],r8
8000643a:	58 f2       	cp.w	r2,15
8000643c:	e0 88 00 07 	brls	8000644a <_malloc_r+0x3da>
80006440:	e6 cb ff f8 	sub	r11,r3,-8
80006444:	0a 9c       	mov	r12,r5
80006446:	e0 a0 1c 77 	rcall	80009d34 <_free_r>
8000644a:	e0 69 0d 74 	mov	r9,3444
8000644e:	72 0a       	ld.w	r10,r9[0x0]
80006450:	e0 68 0d 7c 	mov	r8,3452
80006454:	70 08       	ld.w	r8,r8[0x0]
80006456:	14 38       	cp.w	r8,r10
80006458:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000645c:	e0 69 0d 70 	mov	r9,3440
80006460:	72 0a       	ld.w	r10,r9[0x0]
80006462:	14 38       	cp.w	r8,r10
80006464:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006468:	68 28       	ld.w	r8,r4[0x8]
8000646a:	70 18       	ld.w	r8,r8[0x4]
8000646c:	e0 18 ff fc 	andl	r8,0xfffc
80006470:	0e 38       	cp.w	r8,r7
80006472:	5f 39       	srlo	r9
80006474:	0e 18       	sub	r8,r7
80006476:	58 f8       	cp.w	r8,15
80006478:	5f aa       	srle	r10
8000647a:	f5 e9 10 09 	or	r9,r10,r9
8000647e:	c0 50       	breq	80006488 <_malloc_r+0x418>
80006480:	0a 9c       	mov	r12,r5
80006482:	fe b0 f3 69 	rcall	80004b54 <__malloc_unlock>
80006486:	d8 3a       	popm	r0-r7,pc,r12=0
80006488:	68 26       	ld.w	r6,r4[0x8]
8000648a:	a1 a8       	sbr	r8,0x0
8000648c:	0e 99       	mov	r9,r7
8000648e:	a1 a9       	sbr	r9,0x0
80006490:	8d 19       	st.w	r6[0x4],r9
80006492:	ec 07 00 07 	add	r7,r6,r7
80006496:	0a 9c       	mov	r12,r5
80006498:	89 27       	st.w	r4[0x8],r7
8000649a:	8f 18       	st.w	r7[0x4],r8
8000649c:	fe b0 f3 5c 	rcall	80004b54 <__malloc_unlock>
800064a0:	ec cc ff f8 	sub	r12,r6,-8
800064a4:	d8 32       	popm	r0-r7,pc
800064a6:	d7 03       	nop

800064a8 <memcpy>:
800064a8:	58 8a       	cp.w	r10,8
800064aa:	c2 f5       	brlt	80006508 <memcpy+0x60>
800064ac:	f9 eb 10 09 	or	r9,r12,r11
800064b0:	e2 19 00 03 	andl	r9,0x3,COH
800064b4:	e0 81 00 97 	brne	800065e2 <memcpy+0x13a>
800064b8:	e0 4a 00 20 	cp.w	r10,32
800064bc:	c3 b4       	brge	80006532 <memcpy+0x8a>
800064be:	f4 08 14 02 	asr	r8,r10,0x2
800064c2:	f0 09 11 08 	rsub	r9,r8,8
800064c6:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800064ca:	76 69       	ld.w	r9,r11[0x18]
800064cc:	99 69       	st.w	r12[0x18],r9
800064ce:	76 59       	ld.w	r9,r11[0x14]
800064d0:	99 59       	st.w	r12[0x14],r9
800064d2:	76 49       	ld.w	r9,r11[0x10]
800064d4:	99 49       	st.w	r12[0x10],r9
800064d6:	76 39       	ld.w	r9,r11[0xc]
800064d8:	99 39       	st.w	r12[0xc],r9
800064da:	76 29       	ld.w	r9,r11[0x8]
800064dc:	99 29       	st.w	r12[0x8],r9
800064de:	76 19       	ld.w	r9,r11[0x4]
800064e0:	99 19       	st.w	r12[0x4],r9
800064e2:	76 09       	ld.w	r9,r11[0x0]
800064e4:	99 09       	st.w	r12[0x0],r9
800064e6:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800064ea:	f8 08 00 28 	add	r8,r12,r8<<0x2
800064ee:	e0 1a 00 03 	andl	r10,0x3
800064f2:	f4 0a 11 04 	rsub	r10,r10,4
800064f6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800064fa:	17 a9       	ld.ub	r9,r11[0x2]
800064fc:	b0 a9       	st.b	r8[0x2],r9
800064fe:	17 99       	ld.ub	r9,r11[0x1]
80006500:	b0 99       	st.b	r8[0x1],r9
80006502:	17 89       	ld.ub	r9,r11[0x0]
80006504:	b0 89       	st.b	r8[0x0],r9
80006506:	5e fc       	retal	r12
80006508:	f4 0a 11 09 	rsub	r10,r10,9
8000650c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80006510:	17 f9       	ld.ub	r9,r11[0x7]
80006512:	b8 f9       	st.b	r12[0x7],r9
80006514:	17 e9       	ld.ub	r9,r11[0x6]
80006516:	b8 e9       	st.b	r12[0x6],r9
80006518:	17 d9       	ld.ub	r9,r11[0x5]
8000651a:	b8 d9       	st.b	r12[0x5],r9
8000651c:	17 c9       	ld.ub	r9,r11[0x4]
8000651e:	b8 c9       	st.b	r12[0x4],r9
80006520:	17 b9       	ld.ub	r9,r11[0x3]
80006522:	b8 b9       	st.b	r12[0x3],r9
80006524:	17 a9       	ld.ub	r9,r11[0x2]
80006526:	b8 a9       	st.b	r12[0x2],r9
80006528:	17 99       	ld.ub	r9,r11[0x1]
8000652a:	b8 99       	st.b	r12[0x1],r9
8000652c:	17 89       	ld.ub	r9,r11[0x0]
8000652e:	b8 89       	st.b	r12[0x0],r9
80006530:	5e fc       	retal	r12
80006532:	eb cd 40 c0 	pushm	r6-r7,lr
80006536:	18 99       	mov	r9,r12
80006538:	22 0a       	sub	r10,32
8000653a:	b7 07       	ld.d	r6,r11++
8000653c:	b3 26       	st.d	r9++,r6
8000653e:	b7 07       	ld.d	r6,r11++
80006540:	b3 26       	st.d	r9++,r6
80006542:	b7 07       	ld.d	r6,r11++
80006544:	b3 26       	st.d	r9++,r6
80006546:	b7 07       	ld.d	r6,r11++
80006548:	b3 26       	st.d	r9++,r6
8000654a:	22 0a       	sub	r10,32
8000654c:	cf 74       	brge	8000653a <memcpy+0x92>
8000654e:	2f 0a       	sub	r10,-16
80006550:	c0 65       	brlt	8000655c <memcpy+0xb4>
80006552:	b7 07       	ld.d	r6,r11++
80006554:	b3 26       	st.d	r9++,r6
80006556:	b7 07       	ld.d	r6,r11++
80006558:	b3 26       	st.d	r9++,r6
8000655a:	21 0a       	sub	r10,16
8000655c:	5c 3a       	neg	r10
8000655e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006562:	d7 03       	nop
80006564:	d7 03       	nop
80006566:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000656a:	f3 66 00 0e 	st.b	r9[14],r6
8000656e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006572:	f3 66 00 0d 	st.b	r9[13],r6
80006576:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000657a:	f3 66 00 0c 	st.b	r9[12],r6
8000657e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006582:	f3 66 00 0b 	st.b	r9[11],r6
80006586:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000658a:	f3 66 00 0a 	st.b	r9[10],r6
8000658e:	f7 36 00 09 	ld.ub	r6,r11[9]
80006592:	f3 66 00 09 	st.b	r9[9],r6
80006596:	f7 36 00 08 	ld.ub	r6,r11[8]
8000659a:	f3 66 00 08 	st.b	r9[8],r6
8000659e:	f7 36 00 07 	ld.ub	r6,r11[7]
800065a2:	f3 66 00 07 	st.b	r9[7],r6
800065a6:	f7 36 00 06 	ld.ub	r6,r11[6]
800065aa:	f3 66 00 06 	st.b	r9[6],r6
800065ae:	f7 36 00 05 	ld.ub	r6,r11[5]
800065b2:	f3 66 00 05 	st.b	r9[5],r6
800065b6:	f7 36 00 04 	ld.ub	r6,r11[4]
800065ba:	f3 66 00 04 	st.b	r9[4],r6
800065be:	f7 36 00 03 	ld.ub	r6,r11[3]
800065c2:	f3 66 00 03 	st.b	r9[3],r6
800065c6:	f7 36 00 02 	ld.ub	r6,r11[2]
800065ca:	f3 66 00 02 	st.b	r9[2],r6
800065ce:	f7 36 00 01 	ld.ub	r6,r11[1]
800065d2:	f3 66 00 01 	st.b	r9[1],r6
800065d6:	f7 36 00 00 	ld.ub	r6,r11[0]
800065da:	f3 66 00 00 	st.b	r9[0],r6
800065de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065e2:	20 1a       	sub	r10,1
800065e4:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800065e8:	f8 0a 0b 09 	st.b	r12[r10],r9
800065ec:	cf b1       	brne	800065e2 <memcpy+0x13a>
800065ee:	5e fc       	retal	r12

800065f0 <memset>:
800065f0:	18 98       	mov	r8,r12
800065f2:	c0 38       	rjmp	800065f8 <memset+0x8>
800065f4:	10 cb       	st.b	r8++,r11
800065f6:	20 1a       	sub	r10,1
800065f8:	58 0a       	cp.w	r10,0
800065fa:	cf d1       	brne	800065f4 <memset+0x4>
800065fc:	5e fc       	retal	r12
800065fe:	d7 03       	nop

80006600 <_realloc_r>:
80006600:	d4 31       	pushm	r0-r7,lr
80006602:	20 1d       	sub	sp,4
80006604:	16 94       	mov	r4,r11
80006606:	18 92       	mov	r2,r12
80006608:	14 9b       	mov	r11,r10
8000660a:	58 04       	cp.w	r4,0
8000660c:	c0 51       	brne	80006616 <_realloc_r+0x16>
8000660e:	fe b0 fd 31 	rcall	80006070 <_malloc_r>
80006612:	18 95       	mov	r5,r12
80006614:	c5 39       	rjmp	800068ba <_realloc_r+0x2ba>
80006616:	50 0a       	stdsp	sp[0x0],r10
80006618:	fe b0 f2 98 	rcall	80004b48 <__malloc_lock>
8000661c:	40 0b       	lddsp	r11,sp[0x0]
8000661e:	f6 c8 ff f5 	sub	r8,r11,-11
80006622:	e8 c1 00 08 	sub	r1,r4,8
80006626:	10 96       	mov	r6,r8
80006628:	62 1c       	ld.w	r12,r1[0x4]
8000662a:	e0 16 ff f8 	andl	r6,0xfff8
8000662e:	59 68       	cp.w	r8,22
80006630:	f9 b6 08 10 	movls	r6,16
80006634:	16 36       	cp.w	r6,r11
80006636:	5f 38       	srlo	r8
80006638:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000663c:	c0 50       	breq	80006646 <_realloc_r+0x46>
8000663e:	30 c8       	mov	r8,12
80006640:	30 05       	mov	r5,0
80006642:	85 38       	st.w	r2[0xc],r8
80006644:	c3 b9       	rjmp	800068ba <_realloc_r+0x2ba>
80006646:	18 90       	mov	r0,r12
80006648:	e0 10 ff fc 	andl	r0,0xfffc
8000664c:	0c 30       	cp.w	r0,r6
8000664e:	e0 84 01 0b 	brge	80006864 <_realloc_r+0x264>
80006652:	e0 68 05 38 	mov	r8,1336
80006656:	e2 00 00 09 	add	r9,r1,r0
8000665a:	70 25       	ld.w	r5,r8[0x8]
8000665c:	0a 39       	cp.w	r9,r5
8000665e:	c0 90       	breq	80006670 <_realloc_r+0x70>
80006660:	72 1a       	ld.w	r10,r9[0x4]
80006662:	a1 ca       	cbr	r10,0x0
80006664:	f2 0a 00 0a 	add	r10,r9,r10
80006668:	74 1a       	ld.w	r10,r10[0x4]
8000666a:	ed ba 00 00 	bld	r10,0x0
8000666e:	c2 20       	breq	800066b2 <_realloc_r+0xb2>
80006670:	72 1a       	ld.w	r10,r9[0x4]
80006672:	e0 1a ff fc 	andl	r10,0xfffc
80006676:	f4 00 00 03 	add	r3,r10,r0
8000667a:	0a 39       	cp.w	r9,r5
8000667c:	c1 31       	brne	800066a2 <_realloc_r+0xa2>
8000667e:	ec c7 ff f0 	sub	r7,r6,-16
80006682:	0e 33       	cp.w	r3,r7
80006684:	c1 95       	brlt	800066b6 <_realloc_r+0xb6>
80006686:	e2 06 00 09 	add	r9,r1,r6
8000668a:	0c 13       	sub	r3,r6
8000668c:	a1 a3       	sbr	r3,0x0
8000668e:	93 13       	st.w	r9[0x4],r3
80006690:	91 29       	st.w	r8[0x8],r9
80006692:	04 9c       	mov	r12,r2
80006694:	62 18       	ld.w	r8,r1[0x4]
80006696:	08 95       	mov	r5,r4
80006698:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000669c:	10 46       	or	r6,r8
8000669e:	83 16       	st.w	r1[0x4],r6
800066a0:	c0 b9       	rjmp	800068b6 <_realloc_r+0x2b6>
800066a2:	0c 33       	cp.w	r3,r6
800066a4:	c0 95       	brlt	800066b6 <_realloc_r+0xb6>
800066a6:	72 28       	ld.w	r8,r9[0x8]
800066a8:	02 97       	mov	r7,r1
800066aa:	72 39       	ld.w	r9,r9[0xc]
800066ac:	93 28       	st.w	r9[0x8],r8
800066ae:	91 39       	st.w	r8[0xc],r9
800066b0:	cd c8       	rjmp	80006868 <_realloc_r+0x268>
800066b2:	30 0a       	mov	r10,0
800066b4:	14 99       	mov	r9,r10
800066b6:	ed bc 00 00 	bld	r12,0x0
800066ba:	e0 80 00 95 	breq	800067e4 <_realloc_r+0x1e4>
800066be:	62 07       	ld.w	r7,r1[0x0]
800066c0:	e2 07 01 07 	sub	r7,r1,r7
800066c4:	6e 1c       	ld.w	r12,r7[0x4]
800066c6:	e0 1c ff fc 	andl	r12,0xfffc
800066ca:	58 09       	cp.w	r9,0
800066cc:	c5 60       	breq	80006778 <_realloc_r+0x178>
800066ce:	f8 00 00 03 	add	r3,r12,r0
800066d2:	0a 39       	cp.w	r9,r5
800066d4:	c4 81       	brne	80006764 <_realloc_r+0x164>
800066d6:	14 03       	add	r3,r10
800066d8:	ec c9 ff f0 	sub	r9,r6,-16
800066dc:	12 33       	cp.w	r3,r9
800066de:	c4 d5       	brlt	80006778 <_realloc_r+0x178>
800066e0:	6e 3a       	ld.w	r10,r7[0xc]
800066e2:	6e 29       	ld.w	r9,r7[0x8]
800066e4:	95 29       	st.w	r10[0x8],r9
800066e6:	93 3a       	st.w	r9[0xc],r10
800066e8:	ee c5 ff f8 	sub	r5,r7,-8
800066ec:	e0 ca 00 04 	sub	r10,r0,4
800066f0:	e0 4a 00 24 	cp.w	r10,36
800066f4:	e0 8b 00 25 	brhi	8000673e <_realloc_r+0x13e>
800066f8:	0a 99       	mov	r9,r5
800066fa:	59 3a       	cp.w	r10,19
800066fc:	e0 88 00 1a 	brls	80006730 <_realloc_r+0x130>
80006700:	09 09       	ld.w	r9,r4++
80006702:	8b 09       	st.w	r5[0x0],r9
80006704:	09 09       	ld.w	r9,r4++
80006706:	8f 39       	st.w	r7[0xc],r9
80006708:	ee c9 ff f0 	sub	r9,r7,-16
8000670c:	59 ba       	cp.w	r10,27
8000670e:	e0 88 00 11 	brls	80006730 <_realloc_r+0x130>
80006712:	09 0b       	ld.w	r11,r4++
80006714:	93 0b       	st.w	r9[0x0],r11
80006716:	09 09       	ld.w	r9,r4++
80006718:	8f 59       	st.w	r7[0x14],r9
8000671a:	ee c9 ff e8 	sub	r9,r7,-24
8000671e:	e0 4a 00 24 	cp.w	r10,36
80006722:	c0 71       	brne	80006730 <_realloc_r+0x130>
80006724:	09 0a       	ld.w	r10,r4++
80006726:	93 0a       	st.w	r9[0x0],r10
80006728:	ee c9 ff e0 	sub	r9,r7,-32
8000672c:	09 0a       	ld.w	r10,r4++
8000672e:	8f 7a       	st.w	r7[0x1c],r10
80006730:	09 0a       	ld.w	r10,r4++
80006732:	12 aa       	st.w	r9++,r10
80006734:	68 0a       	ld.w	r10,r4[0x0]
80006736:	93 0a       	st.w	r9[0x0],r10
80006738:	68 1a       	ld.w	r10,r4[0x4]
8000673a:	93 1a       	st.w	r9[0x4],r10
8000673c:	c0 78       	rjmp	8000674a <_realloc_r+0x14a>
8000673e:	50 08       	stdsp	sp[0x0],r8
80006740:	08 9b       	mov	r11,r4
80006742:	0a 9c       	mov	r12,r5
80006744:	e0 a0 1d 9b 	rcall	8000a27a <memmove>
80006748:	40 08       	lddsp	r8,sp[0x0]
8000674a:	ee 06 00 09 	add	r9,r7,r6
8000674e:	0c 13       	sub	r3,r6
80006750:	a1 a3       	sbr	r3,0x0
80006752:	93 13       	st.w	r9[0x4],r3
80006754:	91 29       	st.w	r8[0x8],r9
80006756:	04 9c       	mov	r12,r2
80006758:	6e 18       	ld.w	r8,r7[0x4]
8000675a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000675e:	10 46       	or	r6,r8
80006760:	8f 16       	st.w	r7[0x4],r6
80006762:	ca a8       	rjmp	800068b6 <_realloc_r+0x2b6>
80006764:	14 03       	add	r3,r10
80006766:	0c 33       	cp.w	r3,r6
80006768:	c0 85       	brlt	80006778 <_realloc_r+0x178>
8000676a:	72 28       	ld.w	r8,r9[0x8]
8000676c:	72 39       	ld.w	r9,r9[0xc]
8000676e:	93 28       	st.w	r9[0x8],r8
80006770:	91 39       	st.w	r8[0xc],r9
80006772:	6e 28       	ld.w	r8,r7[0x8]
80006774:	6e 39       	ld.w	r9,r7[0xc]
80006776:	c0 78       	rjmp	80006784 <_realloc_r+0x184>
80006778:	f8 00 00 03 	add	r3,r12,r0
8000677c:	0c 33       	cp.w	r3,r6
8000677e:	c3 35       	brlt	800067e4 <_realloc_r+0x1e4>
80006780:	6e 39       	ld.w	r9,r7[0xc]
80006782:	6e 28       	ld.w	r8,r7[0x8]
80006784:	93 28       	st.w	r9[0x8],r8
80006786:	91 39       	st.w	r8[0xc],r9
80006788:	e0 ca 00 04 	sub	r10,r0,4
8000678c:	ee cc ff f8 	sub	r12,r7,-8
80006790:	e0 4a 00 24 	cp.w	r10,36
80006794:	e0 8b 00 24 	brhi	800067dc <_realloc_r+0x1dc>
80006798:	59 3a       	cp.w	r10,19
8000679a:	e0 88 00 1a 	brls	800067ce <_realloc_r+0x1ce>
8000679e:	09 08       	ld.w	r8,r4++
800067a0:	99 08       	st.w	r12[0x0],r8
800067a2:	09 08       	ld.w	r8,r4++
800067a4:	8f 38       	st.w	r7[0xc],r8
800067a6:	ee cc ff f0 	sub	r12,r7,-16
800067aa:	59 ba       	cp.w	r10,27
800067ac:	e0 88 00 11 	brls	800067ce <_realloc_r+0x1ce>
800067b0:	09 08       	ld.w	r8,r4++
800067b2:	99 08       	st.w	r12[0x0],r8
800067b4:	09 08       	ld.w	r8,r4++
800067b6:	8f 58       	st.w	r7[0x14],r8
800067b8:	ee cc ff e8 	sub	r12,r7,-24
800067bc:	e0 4a 00 24 	cp.w	r10,36
800067c0:	c0 71       	brne	800067ce <_realloc_r+0x1ce>
800067c2:	09 08       	ld.w	r8,r4++
800067c4:	99 08       	st.w	r12[0x0],r8
800067c6:	ee cc ff e0 	sub	r12,r7,-32
800067ca:	09 08       	ld.w	r8,r4++
800067cc:	8f 78       	st.w	r7[0x1c],r8
800067ce:	09 08       	ld.w	r8,r4++
800067d0:	18 a8       	st.w	r12++,r8
800067d2:	68 08       	ld.w	r8,r4[0x0]
800067d4:	99 08       	st.w	r12[0x0],r8
800067d6:	68 18       	ld.w	r8,r4[0x4]
800067d8:	99 18       	st.w	r12[0x4],r8
800067da:	c4 78       	rjmp	80006868 <_realloc_r+0x268>
800067dc:	08 9b       	mov	r11,r4
800067de:	e0 a0 1d 4e 	rcall	8000a27a <memmove>
800067e2:	c4 38       	rjmp	80006868 <_realloc_r+0x268>
800067e4:	04 9c       	mov	r12,r2
800067e6:	fe b0 fc 45 	rcall	80006070 <_malloc_r>
800067ea:	18 95       	mov	r5,r12
800067ec:	c3 a0       	breq	80006860 <_realloc_r+0x260>
800067ee:	62 18       	ld.w	r8,r1[0x4]
800067f0:	f8 c9 00 08 	sub	r9,r12,8
800067f4:	a1 c8       	cbr	r8,0x0
800067f6:	e2 08 00 08 	add	r8,r1,r8
800067fa:	10 39       	cp.w	r9,r8
800067fc:	c0 71       	brne	8000680a <_realloc_r+0x20a>
800067fe:	72 13       	ld.w	r3,r9[0x4]
80006800:	02 97       	mov	r7,r1
80006802:	e0 13 ff fc 	andl	r3,0xfffc
80006806:	00 03       	add	r3,r0
80006808:	c3 08       	rjmp	80006868 <_realloc_r+0x268>
8000680a:	e0 ca 00 04 	sub	r10,r0,4
8000680e:	e0 4a 00 24 	cp.w	r10,36
80006812:	e0 8b 00 20 	brhi	80006852 <_realloc_r+0x252>
80006816:	08 99       	mov	r9,r4
80006818:	18 98       	mov	r8,r12
8000681a:	59 3a       	cp.w	r10,19
8000681c:	e0 88 00 14 	brls	80006844 <_realloc_r+0x244>
80006820:	13 0b       	ld.w	r11,r9++
80006822:	10 ab       	st.w	r8++,r11
80006824:	13 0b       	ld.w	r11,r9++
80006826:	10 ab       	st.w	r8++,r11
80006828:	59 ba       	cp.w	r10,27
8000682a:	e0 88 00 0d 	brls	80006844 <_realloc_r+0x244>
8000682e:	13 0b       	ld.w	r11,r9++
80006830:	10 ab       	st.w	r8++,r11
80006832:	13 0b       	ld.w	r11,r9++
80006834:	10 ab       	st.w	r8++,r11
80006836:	e0 4a 00 24 	cp.w	r10,36
8000683a:	c0 51       	brne	80006844 <_realloc_r+0x244>
8000683c:	13 0a       	ld.w	r10,r9++
8000683e:	10 aa       	st.w	r8++,r10
80006840:	13 0a       	ld.w	r10,r9++
80006842:	10 aa       	st.w	r8++,r10
80006844:	13 0a       	ld.w	r10,r9++
80006846:	10 aa       	st.w	r8++,r10
80006848:	72 0a       	ld.w	r10,r9[0x0]
8000684a:	91 0a       	st.w	r8[0x0],r10
8000684c:	72 19       	ld.w	r9,r9[0x4]
8000684e:	91 19       	st.w	r8[0x4],r9
80006850:	c0 48       	rjmp	80006858 <_realloc_r+0x258>
80006852:	08 9b       	mov	r11,r4
80006854:	e0 a0 1d 13 	rcall	8000a27a <memmove>
80006858:	08 9b       	mov	r11,r4
8000685a:	04 9c       	mov	r12,r2
8000685c:	e0 a0 1a 6c 	rcall	80009d34 <_free_r>
80006860:	04 9c       	mov	r12,r2
80006862:	c2 a8       	rjmp	800068b6 <_realloc_r+0x2b6>
80006864:	00 93       	mov	r3,r0
80006866:	02 97       	mov	r7,r1
80006868:	e6 06 01 09 	sub	r9,r3,r6
8000686c:	6e 18       	ld.w	r8,r7[0x4]
8000686e:	58 f9       	cp.w	r9,15
80006870:	e0 88 00 16 	brls	8000689c <_realloc_r+0x29c>
80006874:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006878:	ed e8 10 08 	or	r8,r6,r8
8000687c:	8f 18       	st.w	r7[0x4],r8
8000687e:	12 98       	mov	r8,r9
80006880:	a1 a8       	sbr	r8,0x0
80006882:	ee 06 00 0b 	add	r11,r7,r6
80006886:	f6 09 00 09 	add	r9,r11,r9
8000688a:	97 18       	st.w	r11[0x4],r8
8000688c:	72 18       	ld.w	r8,r9[0x4]
8000688e:	a1 a8       	sbr	r8,0x0
80006890:	2f 8b       	sub	r11,-8
80006892:	93 18       	st.w	r9[0x4],r8
80006894:	04 9c       	mov	r12,r2
80006896:	e0 a0 1a 4f 	rcall	80009d34 <_free_r>
8000689a:	c0 b8       	rjmp	800068b0 <_realloc_r+0x2b0>
8000689c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800068a0:	e7 e8 10 08 	or	r8,r3,r8
800068a4:	8f 18       	st.w	r7[0x4],r8
800068a6:	ee 03 00 03 	add	r3,r7,r3
800068aa:	66 18       	ld.w	r8,r3[0x4]
800068ac:	a1 a8       	sbr	r8,0x0
800068ae:	87 18       	st.w	r3[0x4],r8
800068b0:	04 9c       	mov	r12,r2
800068b2:	ee c5 ff f8 	sub	r5,r7,-8
800068b6:	fe b0 f1 4f 	rcall	80004b54 <__malloc_unlock>
800068ba:	0a 9c       	mov	r12,r5
800068bc:	2f fd       	sub	sp,-4
800068be:	d8 32       	popm	r0-r7,pc

800068c0 <_sbrk_r>:
800068c0:	d4 21       	pushm	r4-r7,lr
800068c2:	30 08       	mov	r8,0
800068c4:	18 97       	mov	r7,r12
800068c6:	e0 66 40 04 	mov	r6,16388
800068ca:	16 9c       	mov	r12,r11
800068cc:	8d 08       	st.w	r6[0x0],r8
800068ce:	c9 1c       	rcall	800069f0 <_sbrk>
800068d0:	5b fc       	cp.w	r12,-1
800068d2:	c0 51       	brne	800068dc <_sbrk_r+0x1c>
800068d4:	6c 08       	ld.w	r8,r6[0x0]
800068d6:	58 08       	cp.w	r8,0
800068d8:	ef f8 1a 03 	st.wne	r7[0xc],r8
800068dc:	d8 22       	popm	r4-r7,pc
800068de:	d7 03       	nop

800068e0 <sprintf>:
800068e0:	d4 01       	pushm	lr
800068e2:	21 7d       	sub	sp,92
800068e4:	e0 68 ff ff 	mov	r8,65535
800068e8:	ea 18 7f ff 	orh	r8,0x7fff
800068ec:	50 58       	stdsp	sp[0x14],r8
800068ee:	50 28       	stdsp	sp[0x8],r8
800068f0:	e0 68 02 08 	mov	r8,520
800068f4:	ba 68       	st.h	sp[0xc],r8
800068f6:	3f f8       	mov	r8,-1
800068f8:	ba 78       	st.h	sp[0xe],r8
800068fa:	e0 68 0a 38 	mov	r8,2616
800068fe:	50 4c       	stdsp	sp[0x10],r12
80006900:	16 9a       	mov	r10,r11
80006902:	50 0c       	stdsp	sp[0x0],r12
80006904:	fa c9 ff a0 	sub	r9,sp,-96
80006908:	70 0c       	ld.w	r12,r8[0x0]
8000690a:	1a 9b       	mov	r11,sp
8000690c:	e0 a0 02 26 	rcall	80006d58 <_vfprintf_r>
80006910:	30 09       	mov	r9,0
80006912:	40 08       	lddsp	r8,sp[0x0]
80006914:	b0 89       	st.b	r8[0x0],r9
80006916:	2e 9d       	sub	sp,-92
80006918:	d8 02       	popm	pc
8000691a:	d7 03       	nop

8000691c <strlen>:
8000691c:	30 09       	mov	r9,0
8000691e:	18 98       	mov	r8,r12
80006920:	c0 28       	rjmp	80006924 <strlen+0x8>
80006922:	2f f8       	sub	r8,-1
80006924:	11 8a       	ld.ub	r10,r8[0x0]
80006926:	f2 0a 18 00 	cp.b	r10,r9
8000692a:	cf c1       	brne	80006922 <strlen+0x6>
8000692c:	f0 0c 01 0c 	sub	r12,r8,r12
80006930:	5e fc       	retal	r12
80006932:	d7 03       	nop

80006934 <strncpy>:
80006934:	30 08       	mov	r8,0
80006936:	10 3a       	cp.w	r10,r8
80006938:	5e 0c       	reteq	r12
8000693a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000693e:	f8 08 0b 09 	st.b	r12[r8],r9
80006942:	2f f8       	sub	r8,-1
80006944:	58 09       	cp.w	r9,0
80006946:	cf 81       	brne	80006936 <strncpy+0x2>
80006948:	10 3a       	cp.w	r10,r8
8000694a:	5e 0c       	reteq	r12
8000694c:	f8 08 0b 09 	st.b	r12[r8],r9
80006950:	2f f8       	sub	r8,-1
80006952:	cf bb       	rjmp	80006948 <strncpy+0x14>

80006954 <_close>:
80006954:	30 28       	mov	r8,2
80006956:	d6 73       	breakpoint
80006958:	3f fc       	mov	r12,-1
8000695a:	35 8b       	mov	r11,88
8000695c:	58 0c       	cp.w	r12,0
8000695e:	5e 4c       	retge	r12
80006960:	e0 6a 40 04 	mov	r10,16388
80006964:	95 0b       	st.w	r10[0x0],r11
80006966:	5e fc       	retal	r12

80006968 <_lseek>:
80006968:	30 58       	mov	r8,5
8000696a:	d6 73       	breakpoint
8000696c:	3f fc       	mov	r12,-1
8000696e:	35 8b       	mov	r11,88
80006970:	58 0c       	cp.w	r12,0
80006972:	5e 4c       	retge	r12
80006974:	e0 6a 40 04 	mov	r10,16388
80006978:	95 0b       	st.w	r10[0x0],r11
8000697a:	5e fc       	retal	r12

8000697c <isatty>:
8000697c:	30 b8       	mov	r8,11
8000697e:	d6 73       	breakpoint
80006980:	3f fc       	mov	r12,-1
80006982:	35 8b       	mov	r11,88
80006984:	58 0c       	cp.w	r12,0
80006986:	5e 4c       	retge	r12
80006988:	e0 6a 40 04 	mov	r10,16388
8000698c:	95 0b       	st.w	r10[0x0],r11
8000698e:	5e fc       	retal	r12

80006990 <_fstat_host>:
80006990:	30 98       	mov	r8,9
80006992:	d6 73       	breakpoint
80006994:	3f fc       	mov	r12,-1
80006996:	35 8b       	mov	r11,88
80006998:	58 0c       	cp.w	r12,0
8000699a:	5e 4c       	retge	r12
8000699c:	e0 6a 40 04 	mov	r10,16388
800069a0:	95 0b       	st.w	r10[0x0],r11
800069a2:	5e fc       	retal	r12

800069a4 <_fstat>:
800069a4:	d4 21       	pushm	r4-r7,lr
800069a6:	21 0d       	sub	sp,64
800069a8:	16 97       	mov	r7,r11
800069aa:	1a 9b       	mov	r11,sp
800069ac:	cf 2f       	rcall	80006990 <_fstat_host>
800069ae:	c0 34       	brge	800069b4 <_fstat+0x10>
800069b0:	3f fc       	mov	r12,-1
800069b2:	c1 c8       	rjmp	800069ea <_fstat+0x46>
800069b4:	40 08       	lddsp	r8,sp[0x0]
800069b6:	ae 08       	st.h	r7[0x0],r8
800069b8:	40 18       	lddsp	r8,sp[0x4]
800069ba:	ae 18       	st.h	r7[0x2],r8
800069bc:	40 28       	lddsp	r8,sp[0x8]
800069be:	8f 18       	st.w	r7[0x4],r8
800069c0:	40 38       	lddsp	r8,sp[0xc]
800069c2:	ae 48       	st.h	r7[0x8],r8
800069c4:	40 48       	lddsp	r8,sp[0x10]
800069c6:	ae 58       	st.h	r7[0xa],r8
800069c8:	40 58       	lddsp	r8,sp[0x14]
800069ca:	ae 68       	st.h	r7[0xc],r8
800069cc:	40 68       	lddsp	r8,sp[0x18]
800069ce:	ae 78       	st.h	r7[0xe],r8
800069d0:	40 88       	lddsp	r8,sp[0x20]
800069d2:	8f 48       	st.w	r7[0x10],r8
800069d4:	40 a8       	lddsp	r8,sp[0x28]
800069d6:	8f b8       	st.w	r7[0x2c],r8
800069d8:	40 c8       	lddsp	r8,sp[0x30]
800069da:	8f c8       	st.w	r7[0x30],r8
800069dc:	40 d8       	lddsp	r8,sp[0x34]
800069de:	8f 58       	st.w	r7[0x14],r8
800069e0:	40 e8       	lddsp	r8,sp[0x38]
800069e2:	30 0c       	mov	r12,0
800069e4:	8f 78       	st.w	r7[0x1c],r8
800069e6:	40 f8       	lddsp	r8,sp[0x3c]
800069e8:	8f 98       	st.w	r7[0x24],r8
800069ea:	2f 0d       	sub	sp,-64
800069ec:	d8 22       	popm	r4-r7,pc
800069ee:	d7 03       	nop

800069f0 <_sbrk>:
800069f0:	d4 01       	pushm	lr
800069f2:	e0 68 0d a4 	mov	r8,3492
800069f6:	70 09       	ld.w	r9,r8[0x0]
800069f8:	58 09       	cp.w	r9,0
800069fa:	c0 41       	brne	80006a02 <_sbrk+0x12>
800069fc:	e0 69 40 08 	mov	r9,16392
80006a00:	91 09       	st.w	r8[0x0],r9
80006a02:	e0 69 0d a4 	mov	r9,3492
80006a06:	e0 7a 70 00 	mov	r10,94208
80006a0a:	72 08       	ld.w	r8,r9[0x0]
80006a0c:	f0 0c 00 0c 	add	r12,r8,r12
80006a10:	14 3c       	cp.w	r12,r10
80006a12:	e0 8b 00 04 	brhi	80006a1a <_sbrk+0x2a>
80006a16:	93 0c       	st.w	r9[0x0],r12
80006a18:	c0 68       	rjmp	80006a24 <_sbrk+0x34>
80006a1a:	e0 a0 18 15 	rcall	80009a44 <__errno>
80006a1e:	30 c8       	mov	r8,12
80006a20:	99 08       	st.w	r12[0x0],r8
80006a22:	3f f8       	mov	r8,-1
80006a24:	10 9c       	mov	r12,r8
80006a26:	d8 02       	popm	pc

80006a28 <get_arg>:
80006a28:	d4 31       	pushm	r0-r7,lr
80006a2a:	20 8d       	sub	sp,32
80006a2c:	fa c4 ff bc 	sub	r4,sp,-68
80006a30:	50 4b       	stdsp	sp[0x10],r11
80006a32:	68 2e       	ld.w	lr,r4[0x8]
80006a34:	50 58       	stdsp	sp[0x14],r8
80006a36:	12 96       	mov	r6,r9
80006a38:	7c 0b       	ld.w	r11,lr[0x0]
80006a3a:	70 05       	ld.w	r5,r8[0x0]
80006a3c:	50 6e       	stdsp	sp[0x18],lr
80006a3e:	58 0b       	cp.w	r11,0
80006a40:	f4 0b 17 00 	moveq	r11,r10
80006a44:	68 03       	ld.w	r3,r4[0x0]
80006a46:	68 11       	ld.w	r1,r4[0x4]
80006a48:	40 49       	lddsp	r9,sp[0x10]
80006a4a:	30 08       	mov	r8,0
80006a4c:	c2 89       	rjmp	80006c9c <get_arg+0x274>
80006a4e:	2f fb       	sub	r11,-1
80006a50:	32 5c       	mov	r12,37
80006a52:	17 8a       	ld.ub	r10,r11[0x0]
80006a54:	f8 0a 18 00 	cp.b	r10,r12
80006a58:	5f 1e       	srne	lr
80006a5a:	f0 0a 18 00 	cp.b	r10,r8
80006a5e:	5f 1c       	srne	r12
80006a60:	fd ec 00 0c 	and	r12,lr,r12
80006a64:	f0 0c 18 00 	cp.b	r12,r8
80006a68:	cf 31       	brne	80006a4e <get_arg+0x26>
80006a6a:	58 0a       	cp.w	r10,0
80006a6c:	e0 80 01 25 	breq	80006cb6 <get_arg+0x28e>
80006a70:	30 0c       	mov	r12,0
80006a72:	3f fa       	mov	r10,-1
80006a74:	18 90       	mov	r0,r12
80006a76:	50 3a       	stdsp	sp[0xc],r10
80006a78:	18 94       	mov	r4,r12
80006a7a:	18 92       	mov	r2,r12
80006a7c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006a80:	16 97       	mov	r7,r11
80006a82:	50 7c       	stdsp	sp[0x1c],r12
80006a84:	fe cc 9f 88 	sub	r12,pc,-24696
80006a88:	0f 3a       	ld.ub	r10,r7++
80006a8a:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006a8e:	40 7c       	lddsp	r12,sp[0x1c]
80006a90:	1c 0c       	add	r12,lr
80006a92:	fe ce a0 5e 	sub	lr,pc,-24482
80006a96:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006a9a:	20 1e       	sub	lr,1
80006a9c:	50 0e       	stdsp	sp[0x0],lr
80006a9e:	fe ce a0 d6 	sub	lr,pc,-24362
80006aa2:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006aa6:	50 7c       	stdsp	sp[0x1c],r12
80006aa8:	40 0c       	lddsp	r12,sp[0x0]
80006aaa:	58 7c       	cp.w	r12,7
80006aac:	e0 8b 00 f1 	brhi	80006c8e <get_arg+0x266>
80006ab0:	fe ce a2 88 	sub	lr,pc,-23928
80006ab4:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006ab8:	36 8b       	mov	r11,104
80006aba:	f6 0a 18 00 	cp.b	r10,r11
80006abe:	e0 80 00 e8 	breq	80006c8e <get_arg+0x266>
80006ac2:	37 1b       	mov	r11,113
80006ac4:	f6 0a 18 00 	cp.b	r10,r11
80006ac8:	c0 70       	breq	80006ad6 <get_arg+0xae>
80006aca:	34 cb       	mov	r11,76
80006acc:	f6 0a 18 00 	cp.b	r10,r11
80006ad0:	c0 51       	brne	80006ada <get_arg+0xb2>
80006ad2:	a3 b4       	sbr	r4,0x3
80006ad4:	cd d8       	rjmp	80006c8e <get_arg+0x266>
80006ad6:	a5 b4       	sbr	r4,0x5
80006ad8:	cd b8       	rjmp	80006c8e <get_arg+0x266>
80006ada:	08 9a       	mov	r10,r4
80006adc:	0e 9b       	mov	r11,r7
80006ade:	a5 aa       	sbr	r10,0x4
80006ae0:	17 3c       	ld.ub	r12,r11++
80006ae2:	a5 b4       	sbr	r4,0x5
80006ae4:	36 ce       	mov	lr,108
80006ae6:	fc 0c 18 00 	cp.b	r12,lr
80006aea:	e0 80 00 d3 	breq	80006c90 <get_arg+0x268>
80006aee:	14 94       	mov	r4,r10
80006af0:	cc f8       	rjmp	80006c8e <get_arg+0x266>
80006af2:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006af6:	36 7c       	mov	r12,103
80006af8:	f8 0a 18 00 	cp.b	r10,r12
80006afc:	e0 8b 00 27 	brhi	80006b4a <get_arg+0x122>
80006b00:	36 5b       	mov	r11,101
80006b02:	f6 0a 18 00 	cp.b	r10,r11
80006b06:	c4 82       	brcc	80006b96 <get_arg+0x16e>
80006b08:	34 fb       	mov	r11,79
80006b0a:	f6 0a 18 00 	cp.b	r10,r11
80006b0e:	c4 80       	breq	80006b9e <get_arg+0x176>
80006b10:	e0 8b 00 0c 	brhi	80006b28 <get_arg+0x100>
80006b14:	34 5b       	mov	r11,69
80006b16:	f6 0a 18 00 	cp.b	r10,r11
80006b1a:	c3 e0       	breq	80006b96 <get_arg+0x16e>
80006b1c:	34 7b       	mov	r11,71
80006b1e:	f6 0a 18 00 	cp.b	r10,r11
80006b22:	c3 a0       	breq	80006b96 <get_arg+0x16e>
80006b24:	34 4b       	mov	r11,68
80006b26:	c0 88       	rjmp	80006b36 <get_arg+0x10e>
80006b28:	35 8b       	mov	r11,88
80006b2a:	f6 0a 18 00 	cp.b	r10,r11
80006b2e:	c2 c0       	breq	80006b86 <get_arg+0x15e>
80006b30:	e0 8b 00 07 	brhi	80006b3e <get_arg+0x116>
80006b34:	35 5b       	mov	r11,85
80006b36:	f6 0a 18 00 	cp.b	r10,r11
80006b3a:	c3 51       	brne	80006ba4 <get_arg+0x17c>
80006b3c:	c3 18       	rjmp	80006b9e <get_arg+0x176>
80006b3e:	36 3b       	mov	r11,99
80006b40:	f6 0a 18 00 	cp.b	r10,r11
80006b44:	c2 f0       	breq	80006ba2 <get_arg+0x17a>
80006b46:	36 4b       	mov	r11,100
80006b48:	c0 e8       	rjmp	80006b64 <get_arg+0x13c>
80006b4a:	37 0b       	mov	r11,112
80006b4c:	f6 0a 18 00 	cp.b	r10,r11
80006b50:	c2 50       	breq	80006b9a <get_arg+0x172>
80006b52:	e0 8b 00 0d 	brhi	80006b6c <get_arg+0x144>
80006b56:	36 eb       	mov	r11,110
80006b58:	f6 0a 18 00 	cp.b	r10,r11
80006b5c:	c1 f0       	breq	80006b9a <get_arg+0x172>
80006b5e:	e0 8b 00 14 	brhi	80006b86 <get_arg+0x15e>
80006b62:	36 9b       	mov	r11,105
80006b64:	f6 0a 18 00 	cp.b	r10,r11
80006b68:	c1 e1       	brne	80006ba4 <get_arg+0x17c>
80006b6a:	c0 e8       	rjmp	80006b86 <get_arg+0x15e>
80006b6c:	37 5b       	mov	r11,117
80006b6e:	f6 0a 18 00 	cp.b	r10,r11
80006b72:	c0 a0       	breq	80006b86 <get_arg+0x15e>
80006b74:	37 8b       	mov	r11,120
80006b76:	f6 0a 18 00 	cp.b	r10,r11
80006b7a:	c0 60       	breq	80006b86 <get_arg+0x15e>
80006b7c:	37 3b       	mov	r11,115
80006b7e:	f6 0a 18 00 	cp.b	r10,r11
80006b82:	c1 11       	brne	80006ba4 <get_arg+0x17c>
80006b84:	c0 b8       	rjmp	80006b9a <get_arg+0x172>
80006b86:	ed b4 00 04 	bld	r4,0x4
80006b8a:	c0 a0       	breq	80006b9e <get_arg+0x176>
80006b8c:	ed b4 00 05 	bld	r4,0x5
80006b90:	c0 91       	brne	80006ba2 <get_arg+0x17a>
80006b92:	30 20       	mov	r0,2
80006b94:	c0 88       	rjmp	80006ba4 <get_arg+0x17c>
80006b96:	30 40       	mov	r0,4
80006b98:	c0 68       	rjmp	80006ba4 <get_arg+0x17c>
80006b9a:	30 30       	mov	r0,3
80006b9c:	c0 48       	rjmp	80006ba4 <get_arg+0x17c>
80006b9e:	30 10       	mov	r0,1
80006ba0:	c0 28       	rjmp	80006ba4 <get_arg+0x17c>
80006ba2:	30 00       	mov	r0,0
80006ba4:	40 3b       	lddsp	r11,sp[0xc]
80006ba6:	5b fb       	cp.w	r11,-1
80006ba8:	c0 40       	breq	80006bb0 <get_arg+0x188>
80006baa:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80006bae:	c7 08       	rjmp	80006c8e <get_arg+0x266>
80006bb0:	58 60       	cp.w	r0,6
80006bb2:	e0 8b 00 6e 	brhi	80006c8e <get_arg+0x266>
80006bb6:	6c 0a       	ld.w	r10,r6[0x0]
80006bb8:	ea cc ff ff 	sub	r12,r5,-1
80006bbc:	fe ce a3 74 	sub	lr,pc,-23692
80006bc0:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80006bc4:	f4 cb ff f8 	sub	r11,r10,-8
80006bc8:	8d 0b       	st.w	r6[0x0],r11
80006bca:	f4 ea 00 00 	ld.d	r10,r10[0]
80006bce:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006bd2:	c0 f8       	rjmp	80006bf0 <get_arg+0x1c8>
80006bd4:	f4 cb ff fc 	sub	r11,r10,-4
80006bd8:	8d 0b       	st.w	r6[0x0],r11
80006bda:	74 0a       	ld.w	r10,r10[0x0]
80006bdc:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006be0:	c0 88       	rjmp	80006bf0 <get_arg+0x1c8>
80006be2:	f4 cb ff f8 	sub	r11,r10,-8
80006be6:	8d 0b       	st.w	r6[0x0],r11
80006be8:	f4 ea 00 00 	ld.d	r10,r10[0]
80006bec:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006bf0:	0e 9b       	mov	r11,r7
80006bf2:	18 95       	mov	r5,r12
80006bf4:	c4 e8       	rjmp	80006c90 <get_arg+0x268>
80006bf6:	62 0a       	ld.w	r10,r1[0x0]
80006bf8:	5b fa       	cp.w	r10,-1
80006bfa:	c0 b1       	brne	80006c10 <get_arg+0x1e8>
80006bfc:	50 19       	stdsp	sp[0x4],r9
80006bfe:	50 28       	stdsp	sp[0x8],r8
80006c00:	e0 6a 00 80 	mov	r10,128
80006c04:	30 0b       	mov	r11,0
80006c06:	02 9c       	mov	r12,r1
80006c08:	fe b0 fc f4 	rcall	800065f0 <memset>
80006c0c:	40 28       	lddsp	r8,sp[0x8]
80006c0e:	40 19       	lddsp	r9,sp[0x4]
80006c10:	e4 cc 00 01 	sub	r12,r2,1
80006c14:	0e 9b       	mov	r11,r7
80006c16:	50 3c       	stdsp	sp[0xc],r12
80006c18:	f2 0c 0c 49 	max	r9,r9,r12
80006c1c:	c3 a8       	rjmp	80006c90 <get_arg+0x268>
80006c1e:	62 0a       	ld.w	r10,r1[0x0]
80006c20:	5b fa       	cp.w	r10,-1
80006c22:	c0 b1       	brne	80006c38 <get_arg+0x210>
80006c24:	50 19       	stdsp	sp[0x4],r9
80006c26:	50 28       	stdsp	sp[0x8],r8
80006c28:	e0 6a 00 80 	mov	r10,128
80006c2c:	30 0b       	mov	r11,0
80006c2e:	02 9c       	mov	r12,r1
80006c30:	fe b0 fc e0 	rcall	800065f0 <memset>
80006c34:	40 28       	lddsp	r8,sp[0x8]
80006c36:	40 19       	lddsp	r9,sp[0x4]
80006c38:	20 12       	sub	r2,1
80006c3a:	30 0a       	mov	r10,0
80006c3c:	0e 9b       	mov	r11,r7
80006c3e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80006c42:	f2 02 0c 49 	max	r9,r9,r2
80006c46:	c2 58       	rjmp	80006c90 <get_arg+0x268>
80006c48:	16 97       	mov	r7,r11
80006c4a:	6c 0a       	ld.w	r10,r6[0x0]
80006c4c:	f4 cb ff fc 	sub	r11,r10,-4
80006c50:	8d 0b       	st.w	r6[0x0],r11
80006c52:	74 0a       	ld.w	r10,r10[0x0]
80006c54:	0e 9b       	mov	r11,r7
80006c56:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006c5a:	2f f5       	sub	r5,-1
80006c5c:	c1 a8       	rjmp	80006c90 <get_arg+0x268>
80006c5e:	f4 c2 00 30 	sub	r2,r10,48
80006c62:	c0 68       	rjmp	80006c6e <get_arg+0x246>
80006c64:	e4 02 00 22 	add	r2,r2,r2<<0x2
80006c68:	2f f7       	sub	r7,-1
80006c6a:	f4 02 00 12 	add	r2,r10,r2<<0x1
80006c6e:	0f 8a       	ld.ub	r10,r7[0x0]
80006c70:	58 0a       	cp.w	r10,0
80006c72:	c0 e0       	breq	80006c8e <get_arg+0x266>
80006c74:	23 0a       	sub	r10,48
80006c76:	58 9a       	cp.w	r10,9
80006c78:	fe 98 ff f6 	brls	80006c64 <get_arg+0x23c>
80006c7c:	c0 98       	rjmp	80006c8e <get_arg+0x266>
80006c7e:	2f f7       	sub	r7,-1
80006c80:	0f 8a       	ld.ub	r10,r7[0x0]
80006c82:	58 0a       	cp.w	r10,0
80006c84:	c0 50       	breq	80006c8e <get_arg+0x266>
80006c86:	23 0a       	sub	r10,48
80006c88:	58 9a       	cp.w	r10,9
80006c8a:	fe 98 ff fa 	brls	80006c7e <get_arg+0x256>
80006c8e:	0e 9b       	mov	r11,r7
80006c90:	40 7c       	lddsp	r12,sp[0x1c]
80006c92:	30 ba       	mov	r10,11
80006c94:	f4 0c 18 00 	cp.b	r12,r10
80006c98:	fe 91 fe f2 	brne	80006a7c <get_arg+0x54>
80006c9c:	40 42       	lddsp	r2,sp[0x10]
80006c9e:	17 8c       	ld.ub	r12,r11[0x0]
80006ca0:	0a 32       	cp.w	r2,r5
80006ca2:	5f 4a       	srge	r10
80006ca4:	f0 0c 18 00 	cp.b	r12,r8
80006ca8:	5f 1c       	srne	r12
80006caa:	f9 ea 00 0a 	and	r10,r12,r10
80006cae:	f0 0a 18 00 	cp.b	r10,r8
80006cb2:	fe 91 fe cf 	brne	80006a50 <get_arg+0x28>
80006cb6:	30 08       	mov	r8,0
80006cb8:	40 4e       	lddsp	lr,sp[0x10]
80006cba:	17 8a       	ld.ub	r10,r11[0x0]
80006cbc:	e2 05 00 21 	add	r1,r1,r5<<0x2
80006cc0:	f0 0a 18 00 	cp.b	r10,r8
80006cc4:	fc 09 17 10 	movne	r9,lr
80006cc8:	e6 05 00 38 	add	r8,r3,r5<<0x3
80006ccc:	06 9e       	mov	lr,r3
80006cce:	c2 a8       	rjmp	80006d22 <get_arg+0x2fa>
80006cd0:	62 0a       	ld.w	r10,r1[0x0]
80006cd2:	58 3a       	cp.w	r10,3
80006cd4:	c1 e0       	breq	80006d10 <get_arg+0x2e8>
80006cd6:	e0 89 00 07 	brgt	80006ce4 <get_arg+0x2bc>
80006cda:	58 1a       	cp.w	r10,1
80006cdc:	c1 a0       	breq	80006d10 <get_arg+0x2e8>
80006cde:	58 2a       	cp.w	r10,2
80006ce0:	c1 81       	brne	80006d10 <get_arg+0x2e8>
80006ce2:	c0 58       	rjmp	80006cec <get_arg+0x2c4>
80006ce4:	58 5a       	cp.w	r10,5
80006ce6:	c0 c0       	breq	80006cfe <get_arg+0x2d6>
80006ce8:	c0 b5       	brlt	80006cfe <get_arg+0x2d6>
80006cea:	c1 38       	rjmp	80006d10 <get_arg+0x2e8>
80006cec:	6c 0a       	ld.w	r10,r6[0x0]
80006cee:	f4 cc ff f8 	sub	r12,r10,-8
80006cf2:	8d 0c       	st.w	r6[0x0],r12
80006cf4:	f4 e2 00 00 	ld.d	r2,r10[0]
80006cf8:	f0 e3 00 00 	st.d	r8[0],r2
80006cfc:	c1 08       	rjmp	80006d1c <get_arg+0x2f4>
80006cfe:	6c 0a       	ld.w	r10,r6[0x0]
80006d00:	f4 cc ff f8 	sub	r12,r10,-8
80006d04:	8d 0c       	st.w	r6[0x0],r12
80006d06:	f4 e2 00 00 	ld.d	r2,r10[0]
80006d0a:	f0 e3 00 00 	st.d	r8[0],r2
80006d0e:	c0 78       	rjmp	80006d1c <get_arg+0x2f4>
80006d10:	6c 0a       	ld.w	r10,r6[0x0]
80006d12:	f4 cc ff fc 	sub	r12,r10,-4
80006d16:	8d 0c       	st.w	r6[0x0],r12
80006d18:	74 0a       	ld.w	r10,r10[0x0]
80006d1a:	91 0a       	st.w	r8[0x0],r10
80006d1c:	2f f5       	sub	r5,-1
80006d1e:	2f 88       	sub	r8,-8
80006d20:	2f c1       	sub	r1,-4
80006d22:	12 35       	cp.w	r5,r9
80006d24:	fe 9a ff d6 	brle	80006cd0 <get_arg+0x2a8>
80006d28:	1c 93       	mov	r3,lr
80006d2a:	40 52       	lddsp	r2,sp[0x14]
80006d2c:	40 6e       	lddsp	lr,sp[0x18]
80006d2e:	85 05       	st.w	r2[0x0],r5
80006d30:	9d 0b       	st.w	lr[0x0],r11
80006d32:	40 4b       	lddsp	r11,sp[0x10]
80006d34:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80006d38:	2f 8d       	sub	sp,-32
80006d3a:	d8 32       	popm	r0-r7,pc

80006d3c <__sprint_r>:
80006d3c:	d4 21       	pushm	r4-r7,lr
80006d3e:	14 97       	mov	r7,r10
80006d40:	74 28       	ld.w	r8,r10[0x8]
80006d42:	58 08       	cp.w	r8,0
80006d44:	c0 41       	brne	80006d4c <__sprint_r+0x10>
80006d46:	95 18       	st.w	r10[0x4],r8
80006d48:	10 9c       	mov	r12,r8
80006d4a:	d8 22       	popm	r4-r7,pc
80006d4c:	e0 a0 18 ba 	rcall	80009ec0 <__sfvwrite_r>
80006d50:	30 08       	mov	r8,0
80006d52:	8f 18       	st.w	r7[0x4],r8
80006d54:	8f 28       	st.w	r7[0x8],r8
80006d56:	d8 22       	popm	r4-r7,pc

80006d58 <_vfprintf_r>:
80006d58:	d4 31       	pushm	r0-r7,lr
80006d5a:	fa cd 06 bc 	sub	sp,sp,1724
80006d5e:	51 09       	stdsp	sp[0x40],r9
80006d60:	16 91       	mov	r1,r11
80006d62:	14 97       	mov	r7,r10
80006d64:	18 95       	mov	r5,r12
80006d66:	e0 a0 1a 1d 	rcall	8000a1a0 <_localeconv_r>
80006d6a:	78 0c       	ld.w	r12,r12[0x0]
80006d6c:	50 cc       	stdsp	sp[0x30],r12
80006d6e:	58 05       	cp.w	r5,0
80006d70:	c0 70       	breq	80006d7e <_vfprintf_r+0x26>
80006d72:	6a 68       	ld.w	r8,r5[0x18]
80006d74:	58 08       	cp.w	r8,0
80006d76:	c0 41       	brne	80006d7e <_vfprintf_r+0x26>
80006d78:	0a 9c       	mov	r12,r5
80006d7a:	e0 a0 17 43 	rcall	80009c00 <__sinit>
80006d7e:	fe c8 a1 72 	sub	r8,pc,-24206
80006d82:	10 31       	cp.w	r1,r8
80006d84:	c0 31       	brne	80006d8a <_vfprintf_r+0x32>
80006d86:	6a 01       	ld.w	r1,r5[0x0]
80006d88:	c0 c8       	rjmp	80006da0 <_vfprintf_r+0x48>
80006d8a:	fe c8 a1 5e 	sub	r8,pc,-24226
80006d8e:	10 31       	cp.w	r1,r8
80006d90:	c0 31       	brne	80006d96 <_vfprintf_r+0x3e>
80006d92:	6a 11       	ld.w	r1,r5[0x4]
80006d94:	c0 68       	rjmp	80006da0 <_vfprintf_r+0x48>
80006d96:	fe c8 a1 4a 	sub	r8,pc,-24246
80006d9a:	10 31       	cp.w	r1,r8
80006d9c:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80006da0:	82 68       	ld.sh	r8,r1[0xc]
80006da2:	ed b8 00 03 	bld	r8,0x3
80006da6:	c0 41       	brne	80006dae <_vfprintf_r+0x56>
80006da8:	62 48       	ld.w	r8,r1[0x10]
80006daa:	58 08       	cp.w	r8,0
80006dac:	c0 71       	brne	80006dba <_vfprintf_r+0x62>
80006dae:	02 9b       	mov	r11,r1
80006db0:	0a 9c       	mov	r12,r5
80006db2:	e0 a0 0f 5d 	rcall	80008c6c <__swsetup_r>
80006db6:	e0 81 0f 54 	brne	80008c5e <_vfprintf_r+0x1f06>
80006dba:	82 68       	ld.sh	r8,r1[0xc]
80006dbc:	10 99       	mov	r9,r8
80006dbe:	e2 19 00 1a 	andl	r9,0x1a,COH
80006dc2:	58 a9       	cp.w	r9,10
80006dc4:	c3 c1       	brne	80006e3c <_vfprintf_r+0xe4>
80006dc6:	82 79       	ld.sh	r9,r1[0xe]
80006dc8:	30 0a       	mov	r10,0
80006dca:	f4 09 19 00 	cp.h	r9,r10
80006dce:	c3 75       	brlt	80006e3c <_vfprintf_r+0xe4>
80006dd0:	a1 d8       	cbr	r8,0x1
80006dd2:	fb 58 05 d0 	st.h	sp[1488],r8
80006dd6:	62 88       	ld.w	r8,r1[0x20]
80006dd8:	fb 48 05 e4 	st.w	sp[1508],r8
80006ddc:	62 a8       	ld.w	r8,r1[0x28]
80006dde:	fb 48 05 ec 	st.w	sp[1516],r8
80006de2:	fa c8 ff bc 	sub	r8,sp,-68
80006de6:	fb 48 05 d4 	st.w	sp[1492],r8
80006dea:	fb 48 05 c4 	st.w	sp[1476],r8
80006dee:	e0 68 04 00 	mov	r8,1024
80006df2:	fb 48 05 d8 	st.w	sp[1496],r8
80006df6:	fb 48 05 cc 	st.w	sp[1484],r8
80006dfa:	30 08       	mov	r8,0
80006dfc:	fb 59 05 d2 	st.h	sp[1490],r9
80006e00:	0e 9a       	mov	r10,r7
80006e02:	41 09       	lddsp	r9,sp[0x40]
80006e04:	fa c7 fa 3c 	sub	r7,sp,-1476
80006e08:	fb 48 05 dc 	st.w	sp[1500],r8
80006e0c:	0a 9c       	mov	r12,r5
80006e0e:	0e 9b       	mov	r11,r7
80006e10:	ca 4f       	rcall	80006d58 <_vfprintf_r>
80006e12:	50 bc       	stdsp	sp[0x2c],r12
80006e14:	c0 95       	brlt	80006e26 <_vfprintf_r+0xce>
80006e16:	0e 9b       	mov	r11,r7
80006e18:	0a 9c       	mov	r12,r5
80006e1a:	e0 a0 16 1b 	rcall	80009a50 <_fflush_r>
80006e1e:	40 be       	lddsp	lr,sp[0x2c]
80006e20:	f9 be 01 ff 	movne	lr,-1
80006e24:	50 be       	stdsp	sp[0x2c],lr
80006e26:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80006e2a:	ed b8 00 06 	bld	r8,0x6
80006e2e:	e0 81 0f 1a 	brne	80008c62 <_vfprintf_r+0x1f0a>
80006e32:	82 68       	ld.sh	r8,r1[0xc]
80006e34:	a7 a8       	sbr	r8,0x6
80006e36:	a2 68       	st.h	r1[0xc],r8
80006e38:	e0 8f 0f 15 	bral	80008c62 <_vfprintf_r+0x1f0a>
80006e3c:	30 08       	mov	r8,0
80006e3e:	fb 48 06 b4 	st.w	sp[1716],r8
80006e42:	fb 48 06 90 	st.w	sp[1680],r8
80006e46:	fb 48 06 8c 	st.w	sp[1676],r8
80006e4a:	fb 48 06 b0 	st.w	sp[1712],r8
80006e4e:	30 08       	mov	r8,0
80006e50:	30 09       	mov	r9,0
80006e52:	50 a7       	stdsp	sp[0x28],r7
80006e54:	50 78       	stdsp	sp[0x1c],r8
80006e56:	fa c3 f9 e0 	sub	r3,sp,-1568
80006e5a:	3f f8       	mov	r8,-1
80006e5c:	50 59       	stdsp	sp[0x14],r9
80006e5e:	fb 43 06 88 	st.w	sp[1672],r3
80006e62:	fb 48 05 44 	st.w	sp[1348],r8
80006e66:	12 9c       	mov	r12,r9
80006e68:	50 69       	stdsp	sp[0x18],r9
80006e6a:	50 d9       	stdsp	sp[0x34],r9
80006e6c:	50 e9       	stdsp	sp[0x38],r9
80006e6e:	50 b9       	stdsp	sp[0x2c],r9
80006e70:	12 97       	mov	r7,r9
80006e72:	0a 94       	mov	r4,r5
80006e74:	40 a2       	lddsp	r2,sp[0x28]
80006e76:	32 5a       	mov	r10,37
80006e78:	30 08       	mov	r8,0
80006e7a:	c0 28       	rjmp	80006e7e <_vfprintf_r+0x126>
80006e7c:	2f f2       	sub	r2,-1
80006e7e:	05 89       	ld.ub	r9,r2[0x0]
80006e80:	f0 09 18 00 	cp.b	r9,r8
80006e84:	5f 1b       	srne	r11
80006e86:	f4 09 18 00 	cp.b	r9,r10
80006e8a:	5f 19       	srne	r9
80006e8c:	f3 eb 00 0b 	and	r11,r9,r11
80006e90:	f0 0b 18 00 	cp.b	r11,r8
80006e94:	cf 41       	brne	80006e7c <_vfprintf_r+0x124>
80006e96:	40 ab       	lddsp	r11,sp[0x28]
80006e98:	e4 0b 01 06 	sub	r6,r2,r11
80006e9c:	c1 e0       	breq	80006ed8 <_vfprintf_r+0x180>
80006e9e:	fa f8 06 90 	ld.w	r8,sp[1680]
80006ea2:	0c 08       	add	r8,r6
80006ea4:	87 0b       	st.w	r3[0x0],r11
80006ea6:	fb 48 06 90 	st.w	sp[1680],r8
80006eaa:	87 16       	st.w	r3[0x4],r6
80006eac:	fa f8 06 8c 	ld.w	r8,sp[1676]
80006eb0:	2f f8       	sub	r8,-1
80006eb2:	fb 48 06 8c 	st.w	sp[1676],r8
80006eb6:	58 78       	cp.w	r8,7
80006eb8:	e0 89 00 04 	brgt	80006ec0 <_vfprintf_r+0x168>
80006ebc:	2f 83       	sub	r3,-8
80006ebe:	c0 a8       	rjmp	80006ed2 <_vfprintf_r+0x17a>
80006ec0:	fa ca f9 78 	sub	r10,sp,-1672
80006ec4:	02 9b       	mov	r11,r1
80006ec6:	08 9c       	mov	r12,r4
80006ec8:	c3 af       	rcall	80006d3c <__sprint_r>
80006eca:	e0 81 0e c6 	brne	80008c56 <_vfprintf_r+0x1efe>
80006ece:	fa c3 f9 e0 	sub	r3,sp,-1568
80006ed2:	40 ba       	lddsp	r10,sp[0x2c]
80006ed4:	0c 0a       	add	r10,r6
80006ed6:	50 ba       	stdsp	sp[0x2c],r10
80006ed8:	05 89       	ld.ub	r9,r2[0x0]
80006eda:	30 08       	mov	r8,0
80006edc:	f0 09 18 00 	cp.b	r9,r8
80006ee0:	e0 80 0e aa 	breq	80008c34 <_vfprintf_r+0x1edc>
80006ee4:	30 09       	mov	r9,0
80006ee6:	fb 68 06 bb 	st.b	sp[1723],r8
80006eea:	0e 96       	mov	r6,r7
80006eec:	e4 c8 ff ff 	sub	r8,r2,-1
80006ef0:	3f fe       	mov	lr,-1
80006ef2:	50 93       	stdsp	sp[0x24],r3
80006ef4:	50 41       	stdsp	sp[0x10],r1
80006ef6:	0e 93       	mov	r3,r7
80006ef8:	04 91       	mov	r1,r2
80006efa:	50 89       	stdsp	sp[0x20],r9
80006efc:	50 a8       	stdsp	sp[0x28],r8
80006efe:	50 2e       	stdsp	sp[0x8],lr
80006f00:	50 39       	stdsp	sp[0xc],r9
80006f02:	12 95       	mov	r5,r9
80006f04:	12 90       	mov	r0,r9
80006f06:	10 97       	mov	r7,r8
80006f08:	08 92       	mov	r2,r4
80006f0a:	c0 78       	rjmp	80006f18 <_vfprintf_r+0x1c0>
80006f0c:	3f fc       	mov	r12,-1
80006f0e:	08 97       	mov	r7,r4
80006f10:	50 2c       	stdsp	sp[0x8],r12
80006f12:	c0 38       	rjmp	80006f18 <_vfprintf_r+0x1c0>
80006f14:	30 0b       	mov	r11,0
80006f16:	50 3b       	stdsp	sp[0xc],r11
80006f18:	0f 38       	ld.ub	r8,r7++
80006f1a:	c0 28       	rjmp	80006f1e <_vfprintf_r+0x1c6>
80006f1c:	12 90       	mov	r0,r9
80006f1e:	f0 c9 00 20 	sub	r9,r8,32
80006f22:	e0 49 00 58 	cp.w	r9,88
80006f26:	e0 8b 0a 30 	brhi	80008386 <_vfprintf_r+0x162e>
80006f2a:	fe ca a6 c6 	sub	r10,pc,-22842
80006f2e:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80006f32:	50 a7       	stdsp	sp[0x28],r7
80006f34:	50 80       	stdsp	sp[0x20],r0
80006f36:	0c 97       	mov	r7,r6
80006f38:	04 94       	mov	r4,r2
80006f3a:	06 96       	mov	r6,r3
80006f3c:	02 92       	mov	r2,r1
80006f3e:	fe c9 a4 9e 	sub	r9,pc,-23394
80006f42:	40 93       	lddsp	r3,sp[0x24]
80006f44:	10 90       	mov	r0,r8
80006f46:	40 41       	lddsp	r1,sp[0x10]
80006f48:	50 d9       	stdsp	sp[0x34],r9
80006f4a:	e0 8f 08 8e 	bral	80008066 <_vfprintf_r+0x130e>
80006f4e:	30 08       	mov	r8,0
80006f50:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80006f54:	f0 09 18 00 	cp.b	r9,r8
80006f58:	ce 01       	brne	80006f18 <_vfprintf_r+0x1c0>
80006f5a:	32 08       	mov	r8,32
80006f5c:	c6 e8       	rjmp	80007038 <_vfprintf_r+0x2e0>
80006f5e:	a1 a5       	sbr	r5,0x0
80006f60:	cd cb       	rjmp	80006f18 <_vfprintf_r+0x1c0>
80006f62:	0f 89       	ld.ub	r9,r7[0x0]
80006f64:	f2 c8 00 30 	sub	r8,r9,48
80006f68:	58 98       	cp.w	r8,9
80006f6a:	e0 8b 00 1d 	brhi	80006fa4 <_vfprintf_r+0x24c>
80006f6e:	ee c8 ff ff 	sub	r8,r7,-1
80006f72:	30 0b       	mov	r11,0
80006f74:	23 09       	sub	r9,48
80006f76:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80006f7a:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80006f7e:	11 39       	ld.ub	r9,r8++
80006f80:	f2 ca 00 30 	sub	r10,r9,48
80006f84:	58 9a       	cp.w	r10,9
80006f86:	fe 98 ff f7 	brls	80006f74 <_vfprintf_r+0x21c>
80006f8a:	e0 49 00 24 	cp.w	r9,36
80006f8e:	cc 31       	brne	80006f14 <_vfprintf_r+0x1bc>
80006f90:	e0 4b 00 20 	cp.w	r11,32
80006f94:	e0 89 0e 60 	brgt	80008c54 <_vfprintf_r+0x1efc>
80006f98:	20 1b       	sub	r11,1
80006f9a:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006f9e:	12 3b       	cp.w	r11,r9
80006fa0:	c0 95       	brlt	80006fb2 <_vfprintf_r+0x25a>
80006fa2:	c1 08       	rjmp	80006fc2 <_vfprintf_r+0x26a>
80006fa4:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006fa8:	ec ca ff ff 	sub	r10,r6,-1
80006fac:	12 36       	cp.w	r6,r9
80006fae:	c1 f5       	brlt	80006fec <_vfprintf_r+0x294>
80006fb0:	c2 68       	rjmp	80006ffc <_vfprintf_r+0x2a4>
80006fb2:	fa ce f9 44 	sub	lr,sp,-1724
80006fb6:	10 97       	mov	r7,r8
80006fb8:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80006fbc:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80006fc0:	c3 58       	rjmp	8000702a <_vfprintf_r+0x2d2>
80006fc2:	10 97       	mov	r7,r8
80006fc4:	fa c8 f9 50 	sub	r8,sp,-1712
80006fc8:	1a d8       	st.w	--sp,r8
80006fca:	fa c8 fa b8 	sub	r8,sp,-1352
80006fce:	1a d8       	st.w	--sp,r8
80006fd0:	fa c8 fb b4 	sub	r8,sp,-1100
80006fd4:	02 9a       	mov	r10,r1
80006fd6:	1a d8       	st.w	--sp,r8
80006fd8:	04 9c       	mov	r12,r2
80006fda:	fa c8 f9 40 	sub	r8,sp,-1728
80006fde:	fa c9 ff b4 	sub	r9,sp,-76
80006fe2:	fe b0 fd 23 	rcall	80006a28 <get_arg>
80006fe6:	2f dd       	sub	sp,-12
80006fe8:	78 00       	ld.w	r0,r12[0x0]
80006fea:	c2 08       	rjmp	8000702a <_vfprintf_r+0x2d2>
80006fec:	fa cc f9 44 	sub	r12,sp,-1724
80006ff0:	14 96       	mov	r6,r10
80006ff2:	f8 03 00 38 	add	r8,r12,r3<<0x3
80006ff6:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80006ffa:	c1 88       	rjmp	8000702a <_vfprintf_r+0x2d2>
80006ffc:	41 08       	lddsp	r8,sp[0x40]
80006ffe:	59 f9       	cp.w	r9,31
80007000:	e0 89 00 11 	brgt	80007022 <_vfprintf_r+0x2ca>
80007004:	f0 cb ff fc 	sub	r11,r8,-4
80007008:	51 0b       	stdsp	sp[0x40],r11
8000700a:	70 00       	ld.w	r0,r8[0x0]
8000700c:	fa cb f9 44 	sub	r11,sp,-1724
80007010:	f6 09 00 38 	add	r8,r11,r9<<0x3
80007014:	f1 40 fd 88 	st.w	r8[-632],r0
80007018:	2f f9       	sub	r9,-1
8000701a:	14 96       	mov	r6,r10
8000701c:	fb 49 06 b4 	st.w	sp[1716],r9
80007020:	c0 58       	rjmp	8000702a <_vfprintf_r+0x2d2>
80007022:	70 00       	ld.w	r0,r8[0x0]
80007024:	14 96       	mov	r6,r10
80007026:	2f c8       	sub	r8,-4
80007028:	51 08       	stdsp	sp[0x40],r8
8000702a:	58 00       	cp.w	r0,0
8000702c:	fe 94 ff 76 	brge	80006f18 <_vfprintf_r+0x1c0>
80007030:	5c 30       	neg	r0
80007032:	a3 a5       	sbr	r5,0x2
80007034:	c7 2b       	rjmp	80006f18 <_vfprintf_r+0x1c0>
80007036:	32 b8       	mov	r8,43
80007038:	fb 68 06 bb 	st.b	sp[1723],r8
8000703c:	c6 eb       	rjmp	80006f18 <_vfprintf_r+0x1c0>
8000703e:	0f 38       	ld.ub	r8,r7++
80007040:	e0 48 00 2a 	cp.w	r8,42
80007044:	c0 30       	breq	8000704a <_vfprintf_r+0x2f2>
80007046:	30 09       	mov	r9,0
80007048:	c7 98       	rjmp	8000713a <_vfprintf_r+0x3e2>
8000704a:	0f 88       	ld.ub	r8,r7[0x0]
8000704c:	f0 c9 00 30 	sub	r9,r8,48
80007050:	58 99       	cp.w	r9,9
80007052:	e0 8b 00 1f 	brhi	80007090 <_vfprintf_r+0x338>
80007056:	ee c4 ff ff 	sub	r4,r7,-1
8000705a:	30 0b       	mov	r11,0
8000705c:	23 08       	sub	r8,48
8000705e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80007062:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80007066:	09 38       	ld.ub	r8,r4++
80007068:	f0 c9 00 30 	sub	r9,r8,48
8000706c:	58 99       	cp.w	r9,9
8000706e:	fe 98 ff f7 	brls	8000705c <_vfprintf_r+0x304>
80007072:	e0 48 00 24 	cp.w	r8,36
80007076:	fe 91 ff 4f 	brne	80006f14 <_vfprintf_r+0x1bc>
8000707a:	e0 4b 00 20 	cp.w	r11,32
8000707e:	e0 89 0d eb 	brgt	80008c54 <_vfprintf_r+0x1efc>
80007082:	20 1b       	sub	r11,1
80007084:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007088:	10 3b       	cp.w	r11,r8
8000708a:	c0 a5       	brlt	8000709e <_vfprintf_r+0x346>
8000708c:	c1 18       	rjmp	800070ae <_vfprintf_r+0x356>
8000708e:	d7 03       	nop
80007090:	fa fa 06 b4 	ld.w	r10,sp[1716]
80007094:	ec c9 ff ff 	sub	r9,r6,-1
80007098:	14 36       	cp.w	r6,r10
8000709a:	c1 f5       	brlt	800070d8 <_vfprintf_r+0x380>
8000709c:	c2 88       	rjmp	800070ec <_vfprintf_r+0x394>
8000709e:	fa ca f9 44 	sub	r10,sp,-1724
800070a2:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
800070a6:	f6 fb fd 88 	ld.w	r11,r11[-632]
800070aa:	50 2b       	stdsp	sp[0x8],r11
800070ac:	c3 c8       	rjmp	80007124 <_vfprintf_r+0x3cc>
800070ae:	fa c8 f9 50 	sub	r8,sp,-1712
800070b2:	1a d8       	st.w	--sp,r8
800070b4:	fa c8 fa b8 	sub	r8,sp,-1352
800070b8:	1a d8       	st.w	--sp,r8
800070ba:	fa c8 fb b4 	sub	r8,sp,-1100
800070be:	02 9a       	mov	r10,r1
800070c0:	1a d8       	st.w	--sp,r8
800070c2:	04 9c       	mov	r12,r2
800070c4:	fa c8 f9 40 	sub	r8,sp,-1728
800070c8:	fa c9 ff b4 	sub	r9,sp,-76
800070cc:	fe b0 fc ae 	rcall	80006a28 <get_arg>
800070d0:	2f dd       	sub	sp,-12
800070d2:	78 0c       	ld.w	r12,r12[0x0]
800070d4:	50 2c       	stdsp	sp[0x8],r12
800070d6:	c2 78       	rjmp	80007124 <_vfprintf_r+0x3cc>
800070d8:	12 96       	mov	r6,r9
800070da:	0e 94       	mov	r4,r7
800070dc:	fa c9 f9 44 	sub	r9,sp,-1724
800070e0:	f2 03 00 38 	add	r8,r9,r3<<0x3
800070e4:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800070e8:	50 28       	stdsp	sp[0x8],r8
800070ea:	c1 d8       	rjmp	80007124 <_vfprintf_r+0x3cc>
800070ec:	41 08       	lddsp	r8,sp[0x40]
800070ee:	59 fa       	cp.w	r10,31
800070f0:	e0 89 00 14 	brgt	80007118 <_vfprintf_r+0x3c0>
800070f4:	f0 cb ff fc 	sub	r11,r8,-4
800070f8:	70 08       	ld.w	r8,r8[0x0]
800070fa:	51 0b       	stdsp	sp[0x40],r11
800070fc:	50 28       	stdsp	sp[0x8],r8
800070fe:	fa c6 f9 44 	sub	r6,sp,-1724
80007102:	40 2e       	lddsp	lr,sp[0x8]
80007104:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80007108:	f1 4e fd 88 	st.w	r8[-632],lr
8000710c:	2f fa       	sub	r10,-1
8000710e:	0e 94       	mov	r4,r7
80007110:	fb 4a 06 b4 	st.w	sp[1716],r10
80007114:	12 96       	mov	r6,r9
80007116:	c0 78       	rjmp	80007124 <_vfprintf_r+0x3cc>
80007118:	70 0c       	ld.w	r12,r8[0x0]
8000711a:	0e 94       	mov	r4,r7
8000711c:	2f c8       	sub	r8,-4
8000711e:	50 2c       	stdsp	sp[0x8],r12
80007120:	12 96       	mov	r6,r9
80007122:	51 08       	stdsp	sp[0x40],r8
80007124:	40 2b       	lddsp	r11,sp[0x8]
80007126:	58 0b       	cp.w	r11,0
80007128:	fe 95 fe f2 	brlt	80006f0c <_vfprintf_r+0x1b4>
8000712c:	08 97       	mov	r7,r4
8000712e:	cf 5a       	rjmp	80006f18 <_vfprintf_r+0x1c0>
80007130:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007134:	0f 38       	ld.ub	r8,r7++
80007136:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000713a:	f0 ca 00 30 	sub	r10,r8,48
8000713e:	58 9a       	cp.w	r10,9
80007140:	fe 98 ff f8 	brls	80007130 <_vfprintf_r+0x3d8>
80007144:	3f fa       	mov	r10,-1
80007146:	f2 0a 0c 49 	max	r9,r9,r10
8000714a:	50 29       	stdsp	sp[0x8],r9
8000714c:	ce 9a       	rjmp	80006f1e <_vfprintf_r+0x1c6>
8000714e:	a7 b5       	sbr	r5,0x7
80007150:	ce 4a       	rjmp	80006f18 <_vfprintf_r+0x1c0>
80007152:	30 09       	mov	r9,0
80007154:	23 08       	sub	r8,48
80007156:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000715a:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000715e:	0f 38       	ld.ub	r8,r7++
80007160:	f0 ca 00 30 	sub	r10,r8,48
80007164:	58 9a       	cp.w	r10,9
80007166:	fe 98 ff f7 	brls	80007154 <_vfprintf_r+0x3fc>
8000716a:	e0 48 00 24 	cp.w	r8,36
8000716e:	fe 91 fe d7 	brne	80006f1c <_vfprintf_r+0x1c4>
80007172:	e0 49 00 20 	cp.w	r9,32
80007176:	e0 89 0d 6f 	brgt	80008c54 <_vfprintf_r+0x1efc>
8000717a:	f2 c3 00 01 	sub	r3,r9,1
8000717e:	30 19       	mov	r9,1
80007180:	50 39       	stdsp	sp[0xc],r9
80007182:	cc ba       	rjmp	80006f18 <_vfprintf_r+0x1c0>
80007184:	a3 b5       	sbr	r5,0x3
80007186:	cc 9a       	rjmp	80006f18 <_vfprintf_r+0x1c0>
80007188:	a7 a5       	sbr	r5,0x6
8000718a:	cc 7a       	rjmp	80006f18 <_vfprintf_r+0x1c0>
8000718c:	0a 98       	mov	r8,r5
8000718e:	a5 b5       	sbr	r5,0x5
80007190:	a5 a8       	sbr	r8,0x4
80007192:	0f 89       	ld.ub	r9,r7[0x0]
80007194:	36 ce       	mov	lr,108
80007196:	fc 09 18 00 	cp.b	r9,lr
8000719a:	f7 b7 00 ff 	subeq	r7,-1
8000719e:	f0 05 17 10 	movne	r5,r8
800071a2:	cb ba       	rjmp	80006f18 <_vfprintf_r+0x1c0>
800071a4:	a5 b5       	sbr	r5,0x5
800071a6:	cb 9a       	rjmp	80006f18 <_vfprintf_r+0x1c0>
800071a8:	50 a7       	stdsp	sp[0x28],r7
800071aa:	50 80       	stdsp	sp[0x20],r0
800071ac:	0c 97       	mov	r7,r6
800071ae:	10 90       	mov	r0,r8
800071b0:	06 96       	mov	r6,r3
800071b2:	04 94       	mov	r4,r2
800071b4:	40 93       	lddsp	r3,sp[0x24]
800071b6:	02 92       	mov	r2,r1
800071b8:	0e 99       	mov	r9,r7
800071ba:	40 41       	lddsp	r1,sp[0x10]
800071bc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800071c0:	40 3c       	lddsp	r12,sp[0xc]
800071c2:	58 0c       	cp.w	r12,0
800071c4:	c1 d0       	breq	800071fe <_vfprintf_r+0x4a6>
800071c6:	10 36       	cp.w	r6,r8
800071c8:	c0 64       	brge	800071d4 <_vfprintf_r+0x47c>
800071ca:	fa cb f9 44 	sub	r11,sp,-1724
800071ce:	f6 06 00 36 	add	r6,r11,r6<<0x3
800071d2:	c1 d8       	rjmp	8000720c <_vfprintf_r+0x4b4>
800071d4:	fa c8 f9 50 	sub	r8,sp,-1712
800071d8:	1a d8       	st.w	--sp,r8
800071da:	fa c8 fa b8 	sub	r8,sp,-1352
800071de:	1a d8       	st.w	--sp,r8
800071e0:	fa c8 fb b4 	sub	r8,sp,-1100
800071e4:	1a d8       	st.w	--sp,r8
800071e6:	fa c8 f9 40 	sub	r8,sp,-1728
800071ea:	fa c9 ff b4 	sub	r9,sp,-76
800071ee:	04 9a       	mov	r10,r2
800071f0:	0c 9b       	mov	r11,r6
800071f2:	08 9c       	mov	r12,r4
800071f4:	fe b0 fc 1a 	rcall	80006a28 <get_arg>
800071f8:	2f dd       	sub	sp,-12
800071fa:	19 b8       	ld.ub	r8,r12[0x3]
800071fc:	c2 28       	rjmp	80007240 <_vfprintf_r+0x4e8>
800071fe:	2f f7       	sub	r7,-1
80007200:	10 39       	cp.w	r9,r8
80007202:	c0 84       	brge	80007212 <_vfprintf_r+0x4ba>
80007204:	fa ca f9 44 	sub	r10,sp,-1724
80007208:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000720c:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80007210:	c1 88       	rjmp	80007240 <_vfprintf_r+0x4e8>
80007212:	41 09       	lddsp	r9,sp[0x40]
80007214:	59 f8       	cp.w	r8,31
80007216:	e0 89 00 12 	brgt	8000723a <_vfprintf_r+0x4e2>
8000721a:	f2 ca ff fc 	sub	r10,r9,-4
8000721e:	51 0a       	stdsp	sp[0x40],r10
80007220:	72 09       	ld.w	r9,r9[0x0]
80007222:	fa c6 f9 44 	sub	r6,sp,-1724
80007226:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000722a:	2f f8       	sub	r8,-1
8000722c:	f5 49 fd 88 	st.w	r10[-632],r9
80007230:	fb 48 06 b4 	st.w	sp[1716],r8
80007234:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007238:	c0 48       	rjmp	80007240 <_vfprintf_r+0x4e8>
8000723a:	13 b8       	ld.ub	r8,r9[0x3]
8000723c:	2f c9       	sub	r9,-4
8000723e:	51 09       	stdsp	sp[0x40],r9
80007240:	fb 68 06 60 	st.b	sp[1632],r8
80007244:	30 0e       	mov	lr,0
80007246:	30 08       	mov	r8,0
80007248:	30 12       	mov	r2,1
8000724a:	fb 68 06 bb 	st.b	sp[1723],r8
8000724e:	50 2e       	stdsp	sp[0x8],lr
80007250:	e0 8f 08 ad 	bral	800083aa <_vfprintf_r+0x1652>
80007254:	50 a7       	stdsp	sp[0x28],r7
80007256:	50 80       	stdsp	sp[0x20],r0
80007258:	0c 97       	mov	r7,r6
8000725a:	04 94       	mov	r4,r2
8000725c:	06 96       	mov	r6,r3
8000725e:	02 92       	mov	r2,r1
80007260:	40 93       	lddsp	r3,sp[0x24]
80007262:	10 90       	mov	r0,r8
80007264:	40 41       	lddsp	r1,sp[0x10]
80007266:	a5 a5       	sbr	r5,0x4
80007268:	c0 a8       	rjmp	8000727c <_vfprintf_r+0x524>
8000726a:	50 a7       	stdsp	sp[0x28],r7
8000726c:	50 80       	stdsp	sp[0x20],r0
8000726e:	0c 97       	mov	r7,r6
80007270:	04 94       	mov	r4,r2
80007272:	06 96       	mov	r6,r3
80007274:	02 92       	mov	r2,r1
80007276:	40 93       	lddsp	r3,sp[0x24]
80007278:	10 90       	mov	r0,r8
8000727a:	40 41       	lddsp	r1,sp[0x10]
8000727c:	ed b5 00 05 	bld	r5,0x5
80007280:	c5 11       	brne	80007322 <_vfprintf_r+0x5ca>
80007282:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007286:	40 3c       	lddsp	r12,sp[0xc]
80007288:	58 0c       	cp.w	r12,0
8000728a:	c1 e0       	breq	800072c6 <_vfprintf_r+0x56e>
8000728c:	10 36       	cp.w	r6,r8
8000728e:	c0 64       	brge	8000729a <_vfprintf_r+0x542>
80007290:	fa cb f9 44 	sub	r11,sp,-1724
80007294:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007298:	c2 08       	rjmp	800072d8 <_vfprintf_r+0x580>
8000729a:	fa c8 f9 50 	sub	r8,sp,-1712
8000729e:	1a d8       	st.w	--sp,r8
800072a0:	fa c8 fa b8 	sub	r8,sp,-1352
800072a4:	0c 9b       	mov	r11,r6
800072a6:	1a d8       	st.w	--sp,r8
800072a8:	fa c8 fb b4 	sub	r8,sp,-1100
800072ac:	1a d8       	st.w	--sp,r8
800072ae:	fa c9 ff b4 	sub	r9,sp,-76
800072b2:	fa c8 f9 40 	sub	r8,sp,-1728
800072b6:	04 9a       	mov	r10,r2
800072b8:	08 9c       	mov	r12,r4
800072ba:	fe b0 fb b7 	rcall	80006a28 <get_arg>
800072be:	2f dd       	sub	sp,-12
800072c0:	78 1b       	ld.w	r11,r12[0x4]
800072c2:	78 09       	ld.w	r9,r12[0x0]
800072c4:	c2 b8       	rjmp	8000731a <_vfprintf_r+0x5c2>
800072c6:	ee ca ff ff 	sub	r10,r7,-1
800072ca:	10 37       	cp.w	r7,r8
800072cc:	c0 b4       	brge	800072e2 <_vfprintf_r+0x58a>
800072ce:	fa c9 f9 44 	sub	r9,sp,-1724
800072d2:	14 97       	mov	r7,r10
800072d4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800072d8:	ec fb fd 8c 	ld.w	r11,r6[-628]
800072dc:	ec f9 fd 88 	ld.w	r9,r6[-632]
800072e0:	c1 d8       	rjmp	8000731a <_vfprintf_r+0x5c2>
800072e2:	41 09       	lddsp	r9,sp[0x40]
800072e4:	59 f8       	cp.w	r8,31
800072e6:	e0 89 00 14 	brgt	8000730e <_vfprintf_r+0x5b6>
800072ea:	f2 cb ff f8 	sub	r11,r9,-8
800072ee:	51 0b       	stdsp	sp[0x40],r11
800072f0:	fa c6 f9 44 	sub	r6,sp,-1724
800072f4:	72 1b       	ld.w	r11,r9[0x4]
800072f6:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800072fa:	72 09       	ld.w	r9,r9[0x0]
800072fc:	f9 4b fd 8c 	st.w	r12[-628],r11
80007300:	f9 49 fd 88 	st.w	r12[-632],r9
80007304:	2f f8       	sub	r8,-1
80007306:	14 97       	mov	r7,r10
80007308:	fb 48 06 b4 	st.w	sp[1716],r8
8000730c:	c0 78       	rjmp	8000731a <_vfprintf_r+0x5c2>
8000730e:	f2 c8 ff f8 	sub	r8,r9,-8
80007312:	72 1b       	ld.w	r11,r9[0x4]
80007314:	14 97       	mov	r7,r10
80007316:	51 08       	stdsp	sp[0x40],r8
80007318:	72 09       	ld.w	r9,r9[0x0]
8000731a:	16 98       	mov	r8,r11
8000731c:	fa e9 00 00 	st.d	sp[0],r8
80007320:	ca e8       	rjmp	8000747c <_vfprintf_r+0x724>
80007322:	ed b5 00 04 	bld	r5,0x4
80007326:	c1 71       	brne	80007354 <_vfprintf_r+0x5fc>
80007328:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000732c:	40 3e       	lddsp	lr,sp[0xc]
8000732e:	58 0e       	cp.w	lr,0
80007330:	c0 80       	breq	80007340 <_vfprintf_r+0x5e8>
80007332:	10 36       	cp.w	r6,r8
80007334:	c6 94       	brge	80007406 <_vfprintf_r+0x6ae>
80007336:	fa cc f9 44 	sub	r12,sp,-1724
8000733a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000733e:	c8 28       	rjmp	80007442 <_vfprintf_r+0x6ea>
80007340:	ee ca ff ff 	sub	r10,r7,-1
80007344:	10 37       	cp.w	r7,r8
80007346:	e0 84 00 81 	brge	80007448 <_vfprintf_r+0x6f0>
8000734a:	fa cb f9 44 	sub	r11,sp,-1724
8000734e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007352:	c7 78       	rjmp	80007440 <_vfprintf_r+0x6e8>
80007354:	ed b5 00 06 	bld	r5,0x6
80007358:	c4 b1       	brne	800073ee <_vfprintf_r+0x696>
8000735a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000735e:	40 3c       	lddsp	r12,sp[0xc]
80007360:	58 0c       	cp.w	r12,0
80007362:	c1 d0       	breq	8000739c <_vfprintf_r+0x644>
80007364:	10 36       	cp.w	r6,r8
80007366:	c0 64       	brge	80007372 <_vfprintf_r+0x61a>
80007368:	fa cb f9 44 	sub	r11,sp,-1724
8000736c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007370:	c1 f8       	rjmp	800073ae <_vfprintf_r+0x656>
80007372:	fa c8 f9 50 	sub	r8,sp,-1712
80007376:	1a d8       	st.w	--sp,r8
80007378:	fa c8 fa b8 	sub	r8,sp,-1352
8000737c:	1a d8       	st.w	--sp,r8
8000737e:	fa c8 fb b4 	sub	r8,sp,-1100
80007382:	1a d8       	st.w	--sp,r8
80007384:	fa c8 f9 40 	sub	r8,sp,-1728
80007388:	fa c9 ff b4 	sub	r9,sp,-76
8000738c:	04 9a       	mov	r10,r2
8000738e:	0c 9b       	mov	r11,r6
80007390:	08 9c       	mov	r12,r4
80007392:	fe b0 fb 4b 	rcall	80006a28 <get_arg>
80007396:	2f dd       	sub	sp,-12
80007398:	98 18       	ld.sh	r8,r12[0x2]
8000739a:	c2 68       	rjmp	800073e6 <_vfprintf_r+0x68e>
8000739c:	ee ca ff ff 	sub	r10,r7,-1
800073a0:	10 37       	cp.w	r7,r8
800073a2:	c0 94       	brge	800073b4 <_vfprintf_r+0x65c>
800073a4:	fa c9 f9 44 	sub	r9,sp,-1724
800073a8:	14 97       	mov	r7,r10
800073aa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800073ae:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800073b2:	c1 a8       	rjmp	800073e6 <_vfprintf_r+0x68e>
800073b4:	41 09       	lddsp	r9,sp[0x40]
800073b6:	59 f8       	cp.w	r8,31
800073b8:	e0 89 00 13 	brgt	800073de <_vfprintf_r+0x686>
800073bc:	f2 cb ff fc 	sub	r11,r9,-4
800073c0:	51 0b       	stdsp	sp[0x40],r11
800073c2:	72 09       	ld.w	r9,r9[0x0]
800073c4:	fa c6 f9 44 	sub	r6,sp,-1724
800073c8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800073cc:	2f f8       	sub	r8,-1
800073ce:	f7 49 fd 88 	st.w	r11[-632],r9
800073d2:	fb 48 06 b4 	st.w	sp[1716],r8
800073d6:	14 97       	mov	r7,r10
800073d8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800073dc:	c0 58       	rjmp	800073e6 <_vfprintf_r+0x68e>
800073de:	92 18       	ld.sh	r8,r9[0x2]
800073e0:	14 97       	mov	r7,r10
800073e2:	2f c9       	sub	r9,-4
800073e4:	51 09       	stdsp	sp[0x40],r9
800073e6:	50 18       	stdsp	sp[0x4],r8
800073e8:	bf 58       	asr	r8,0x1f
800073ea:	50 08       	stdsp	sp[0x0],r8
800073ec:	c4 88       	rjmp	8000747c <_vfprintf_r+0x724>
800073ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
800073f2:	40 3c       	lddsp	r12,sp[0xc]
800073f4:	58 0c       	cp.w	r12,0
800073f6:	c1 d0       	breq	80007430 <_vfprintf_r+0x6d8>
800073f8:	10 36       	cp.w	r6,r8
800073fa:	c0 64       	brge	80007406 <_vfprintf_r+0x6ae>
800073fc:	fa cb f9 44 	sub	r11,sp,-1724
80007400:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007404:	c1 f8       	rjmp	80007442 <_vfprintf_r+0x6ea>
80007406:	fa c8 f9 50 	sub	r8,sp,-1712
8000740a:	1a d8       	st.w	--sp,r8
8000740c:	fa c8 fa b8 	sub	r8,sp,-1352
80007410:	0c 9b       	mov	r11,r6
80007412:	1a d8       	st.w	--sp,r8
80007414:	fa c8 fb b4 	sub	r8,sp,-1100
80007418:	04 9a       	mov	r10,r2
8000741a:	1a d8       	st.w	--sp,r8
8000741c:	08 9c       	mov	r12,r4
8000741e:	fa c8 f9 40 	sub	r8,sp,-1728
80007422:	fa c9 ff b4 	sub	r9,sp,-76
80007426:	fe b0 fb 01 	rcall	80006a28 <get_arg>
8000742a:	2f dd       	sub	sp,-12
8000742c:	78 0b       	ld.w	r11,r12[0x0]
8000742e:	c2 48       	rjmp	80007476 <_vfprintf_r+0x71e>
80007430:	ee ca ff ff 	sub	r10,r7,-1
80007434:	10 37       	cp.w	r7,r8
80007436:	c0 94       	brge	80007448 <_vfprintf_r+0x6f0>
80007438:	fa c9 f9 44 	sub	r9,sp,-1724
8000743c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007440:	14 97       	mov	r7,r10
80007442:	ec fb fd 88 	ld.w	r11,r6[-632]
80007446:	c1 88       	rjmp	80007476 <_vfprintf_r+0x71e>
80007448:	41 09       	lddsp	r9,sp[0x40]
8000744a:	59 f8       	cp.w	r8,31
8000744c:	e0 89 00 11 	brgt	8000746e <_vfprintf_r+0x716>
80007450:	f2 cb ff fc 	sub	r11,r9,-4
80007454:	51 0b       	stdsp	sp[0x40],r11
80007456:	fa c6 f9 44 	sub	r6,sp,-1724
8000745a:	72 0b       	ld.w	r11,r9[0x0]
8000745c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007460:	f3 4b fd 88 	st.w	r9[-632],r11
80007464:	2f f8       	sub	r8,-1
80007466:	14 97       	mov	r7,r10
80007468:	fb 48 06 b4 	st.w	sp[1716],r8
8000746c:	c0 58       	rjmp	80007476 <_vfprintf_r+0x71e>
8000746e:	72 0b       	ld.w	r11,r9[0x0]
80007470:	14 97       	mov	r7,r10
80007472:	2f c9       	sub	r9,-4
80007474:	51 09       	stdsp	sp[0x40],r9
80007476:	50 1b       	stdsp	sp[0x4],r11
80007478:	bf 5b       	asr	r11,0x1f
8000747a:	50 0b       	stdsp	sp[0x0],r11
8000747c:	fa ea 00 00 	ld.d	r10,sp[0]
80007480:	58 0a       	cp.w	r10,0
80007482:	5c 2b       	cpc	r11
80007484:	c0 e4       	brge	800074a0 <_vfprintf_r+0x748>
80007486:	30 08       	mov	r8,0
80007488:	fa ea 00 00 	ld.d	r10,sp[0]
8000748c:	30 09       	mov	r9,0
8000748e:	f0 0a 01 0a 	sub	r10,r8,r10
80007492:	f2 0b 01 4b 	sbc	r11,r9,r11
80007496:	32 d8       	mov	r8,45
80007498:	fa eb 00 00 	st.d	sp[0],r10
8000749c:	fb 68 06 bb 	st.b	sp[1723],r8
800074a0:	30 18       	mov	r8,1
800074a2:	e0 8f 06 fa 	bral	80008296 <_vfprintf_r+0x153e>
800074a6:	50 a7       	stdsp	sp[0x28],r7
800074a8:	50 80       	stdsp	sp[0x20],r0
800074aa:	0c 97       	mov	r7,r6
800074ac:	04 94       	mov	r4,r2
800074ae:	06 96       	mov	r6,r3
800074b0:	02 92       	mov	r2,r1
800074b2:	40 93       	lddsp	r3,sp[0x24]
800074b4:	10 90       	mov	r0,r8
800074b6:	40 41       	lddsp	r1,sp[0x10]
800074b8:	0e 99       	mov	r9,r7
800074ba:	ed b5 00 03 	bld	r5,0x3
800074be:	c4 11       	brne	80007540 <_vfprintf_r+0x7e8>
800074c0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800074c4:	40 3a       	lddsp	r10,sp[0xc]
800074c6:	58 0a       	cp.w	r10,0
800074c8:	c1 90       	breq	800074fa <_vfprintf_r+0x7a2>
800074ca:	10 36       	cp.w	r6,r8
800074cc:	c6 45       	brlt	80007594 <_vfprintf_r+0x83c>
800074ce:	fa c8 f9 50 	sub	r8,sp,-1712
800074d2:	1a d8       	st.w	--sp,r8
800074d4:	fa c8 fa b8 	sub	r8,sp,-1352
800074d8:	1a d8       	st.w	--sp,r8
800074da:	fa c8 fb b4 	sub	r8,sp,-1100
800074de:	0c 9b       	mov	r11,r6
800074e0:	1a d8       	st.w	--sp,r8
800074e2:	04 9a       	mov	r10,r2
800074e4:	fa c8 f9 40 	sub	r8,sp,-1728
800074e8:	fa c9 ff b4 	sub	r9,sp,-76
800074ec:	08 9c       	mov	r12,r4
800074ee:	fe b0 fa 9d 	rcall	80006a28 <get_arg>
800074f2:	2f dd       	sub	sp,-12
800074f4:	78 16       	ld.w	r6,r12[0x4]
800074f6:	50 76       	stdsp	sp[0x1c],r6
800074f8:	c4 88       	rjmp	80007588 <_vfprintf_r+0x830>
800074fa:	2f f7       	sub	r7,-1
800074fc:	10 39       	cp.w	r9,r8
800074fe:	c0 c4       	brge	80007516 <_vfprintf_r+0x7be>
80007500:	fa ce f9 44 	sub	lr,sp,-1724
80007504:	fc 06 00 36 	add	r6,lr,r6<<0x3
80007508:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000750c:	50 7c       	stdsp	sp[0x1c],r12
8000750e:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007512:	50 56       	stdsp	sp[0x14],r6
80007514:	c6 68       	rjmp	800075e0 <_vfprintf_r+0x888>
80007516:	41 09       	lddsp	r9,sp[0x40]
80007518:	59 f8       	cp.w	r8,31
8000751a:	e0 89 00 10 	brgt	8000753a <_vfprintf_r+0x7e2>
8000751e:	f2 ca ff f8 	sub	r10,r9,-8
80007522:	72 1b       	ld.w	r11,r9[0x4]
80007524:	51 0a       	stdsp	sp[0x40],r10
80007526:	72 09       	ld.w	r9,r9[0x0]
80007528:	fa ca f9 44 	sub	r10,sp,-1724
8000752c:	50 7b       	stdsp	sp[0x1c],r11
8000752e:	50 59       	stdsp	sp[0x14],r9
80007530:	f4 08 00 39 	add	r9,r10,r8<<0x3
80007534:	40 5b       	lddsp	r11,sp[0x14]
80007536:	40 7a       	lddsp	r10,sp[0x1c]
80007538:	c4 78       	rjmp	800075c6 <_vfprintf_r+0x86e>
8000753a:	72 18       	ld.w	r8,r9[0x4]
8000753c:	50 78       	stdsp	sp[0x1c],r8
8000753e:	c4 c8       	rjmp	800075d6 <_vfprintf_r+0x87e>
80007540:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007544:	40 3e       	lddsp	lr,sp[0xc]
80007546:	58 0e       	cp.w	lr,0
80007548:	c2 30       	breq	8000758e <_vfprintf_r+0x836>
8000754a:	10 36       	cp.w	r6,r8
8000754c:	c0 94       	brge	8000755e <_vfprintf_r+0x806>
8000754e:	fa cc f9 44 	sub	r12,sp,-1724
80007552:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007556:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000755a:	50 7b       	stdsp	sp[0x1c],r11
8000755c:	cd 9b       	rjmp	8000750e <_vfprintf_r+0x7b6>
8000755e:	fa c8 f9 50 	sub	r8,sp,-1712
80007562:	1a d8       	st.w	--sp,r8
80007564:	fa c8 fa b8 	sub	r8,sp,-1352
80007568:	04 9a       	mov	r10,r2
8000756a:	1a d8       	st.w	--sp,r8
8000756c:	fa c8 fb b4 	sub	r8,sp,-1100
80007570:	0c 9b       	mov	r11,r6
80007572:	1a d8       	st.w	--sp,r8
80007574:	08 9c       	mov	r12,r4
80007576:	fa c8 f9 40 	sub	r8,sp,-1728
8000757a:	fa c9 ff b4 	sub	r9,sp,-76
8000757e:	fe b0 fa 55 	rcall	80006a28 <get_arg>
80007582:	2f dd       	sub	sp,-12
80007584:	78 1a       	ld.w	r10,r12[0x4]
80007586:	50 7a       	stdsp	sp[0x1c],r10
80007588:	78 0c       	ld.w	r12,r12[0x0]
8000758a:	50 5c       	stdsp	sp[0x14],r12
8000758c:	c2 a8       	rjmp	800075e0 <_vfprintf_r+0x888>
8000758e:	2f f7       	sub	r7,-1
80007590:	10 39       	cp.w	r9,r8
80007592:	c0 94       	brge	800075a4 <_vfprintf_r+0x84c>
80007594:	fa c9 f9 44 	sub	r9,sp,-1724
80007598:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000759c:	ec f8 fd 8c 	ld.w	r8,r6[-628]
800075a0:	50 78       	stdsp	sp[0x1c],r8
800075a2:	cb 6b       	rjmp	8000750e <_vfprintf_r+0x7b6>
800075a4:	41 09       	lddsp	r9,sp[0x40]
800075a6:	59 f8       	cp.w	r8,31
800075a8:	e0 89 00 15 	brgt	800075d2 <_vfprintf_r+0x87a>
800075ac:	f2 ca ff f8 	sub	r10,r9,-8
800075b0:	72 16       	ld.w	r6,r9[0x4]
800075b2:	72 09       	ld.w	r9,r9[0x0]
800075b4:	51 0a       	stdsp	sp[0x40],r10
800075b6:	50 59       	stdsp	sp[0x14],r9
800075b8:	fa ce f9 44 	sub	lr,sp,-1724
800075bc:	50 76       	stdsp	sp[0x1c],r6
800075be:	fc 08 00 39 	add	r9,lr,r8<<0x3
800075c2:	40 5b       	lddsp	r11,sp[0x14]
800075c4:	0c 9a       	mov	r10,r6
800075c6:	f2 eb fd 88 	st.d	r9[-632],r10
800075ca:	2f f8       	sub	r8,-1
800075cc:	fb 48 06 b4 	st.w	sp[1716],r8
800075d0:	c0 88       	rjmp	800075e0 <_vfprintf_r+0x888>
800075d2:	72 1c       	ld.w	r12,r9[0x4]
800075d4:	50 7c       	stdsp	sp[0x1c],r12
800075d6:	f2 c8 ff f8 	sub	r8,r9,-8
800075da:	51 08       	stdsp	sp[0x40],r8
800075dc:	72 09       	ld.w	r9,r9[0x0]
800075de:	50 59       	stdsp	sp[0x14],r9
800075e0:	40 5b       	lddsp	r11,sp[0x14]
800075e2:	40 7a       	lddsp	r10,sp[0x1c]
800075e4:	e0 a0 19 54 	rcall	8000a88c <__isinfd>
800075e8:	18 96       	mov	r6,r12
800075ea:	c1 70       	breq	80007618 <_vfprintf_r+0x8c0>
800075ec:	30 08       	mov	r8,0
800075ee:	30 09       	mov	r9,0
800075f0:	40 5b       	lddsp	r11,sp[0x14]
800075f2:	40 7a       	lddsp	r10,sp[0x1c]
800075f4:	e0 a0 1d a8 	rcall	8000b144 <__avr32_f64_cmp_lt>
800075f8:	c0 40       	breq	80007600 <_vfprintf_r+0x8a8>
800075fa:	32 d8       	mov	r8,45
800075fc:	fb 68 06 bb 	st.b	sp[1723],r8
80007600:	fe c8 ab 4c 	sub	r8,pc,-21684
80007604:	fe c6 ab 4c 	sub	r6,pc,-21684
80007608:	a7 d5       	cbr	r5,0x7
8000760a:	e0 40 00 47 	cp.w	r0,71
8000760e:	f0 06 17 a0 	movle	r6,r8
80007612:	30 32       	mov	r2,3
80007614:	e0 8f 06 ce 	bral	800083b0 <_vfprintf_r+0x1658>
80007618:	40 5b       	lddsp	r11,sp[0x14]
8000761a:	40 7a       	lddsp	r10,sp[0x1c]
8000761c:	e0 a0 19 4d 	rcall	8000a8b6 <__isnand>
80007620:	c0 e0       	breq	8000763c <_vfprintf_r+0x8e4>
80007622:	50 26       	stdsp	sp[0x8],r6
80007624:	fe c8 ab 68 	sub	r8,pc,-21656
80007628:	fe c6 ab 68 	sub	r6,pc,-21656
8000762c:	a7 d5       	cbr	r5,0x7
8000762e:	e0 40 00 47 	cp.w	r0,71
80007632:	f0 06 17 a0 	movle	r6,r8
80007636:	30 32       	mov	r2,3
80007638:	e0 8f 06 c2 	bral	800083bc <_vfprintf_r+0x1664>
8000763c:	40 2a       	lddsp	r10,sp[0x8]
8000763e:	5b fa       	cp.w	r10,-1
80007640:	c0 41       	brne	80007648 <_vfprintf_r+0x8f0>
80007642:	30 69       	mov	r9,6
80007644:	50 29       	stdsp	sp[0x8],r9
80007646:	c1 18       	rjmp	80007668 <_vfprintf_r+0x910>
80007648:	e0 40 00 47 	cp.w	r0,71
8000764c:	5f 09       	sreq	r9
8000764e:	e0 40 00 67 	cp.w	r0,103
80007652:	5f 08       	sreq	r8
80007654:	f3 e8 10 08 	or	r8,r9,r8
80007658:	f8 08 18 00 	cp.b	r8,r12
8000765c:	c0 60       	breq	80007668 <_vfprintf_r+0x910>
8000765e:	40 28       	lddsp	r8,sp[0x8]
80007660:	58 08       	cp.w	r8,0
80007662:	f9 b8 00 01 	moveq	r8,1
80007666:	50 28       	stdsp	sp[0x8],r8
80007668:	40 78       	lddsp	r8,sp[0x1c]
8000766a:	40 59       	lddsp	r9,sp[0x14]
8000766c:	fa e9 06 94 	st.d	sp[1684],r8
80007670:	a9 a5       	sbr	r5,0x8
80007672:	fa f8 06 94 	ld.w	r8,sp[1684]
80007676:	58 08       	cp.w	r8,0
80007678:	c0 65       	brlt	80007684 <_vfprintf_r+0x92c>
8000767a:	40 5e       	lddsp	lr,sp[0x14]
8000767c:	30 0c       	mov	r12,0
8000767e:	50 6e       	stdsp	sp[0x18],lr
80007680:	50 9c       	stdsp	sp[0x24],r12
80007682:	c0 78       	rjmp	80007690 <_vfprintf_r+0x938>
80007684:	40 5b       	lddsp	r11,sp[0x14]
80007686:	32 da       	mov	r10,45
80007688:	ee 1b 80 00 	eorh	r11,0x8000
8000768c:	50 9a       	stdsp	sp[0x24],r10
8000768e:	50 6b       	stdsp	sp[0x18],r11
80007690:	e0 40 00 46 	cp.w	r0,70
80007694:	5f 09       	sreq	r9
80007696:	e0 40 00 66 	cp.w	r0,102
8000769a:	5f 08       	sreq	r8
8000769c:	f3 e8 10 08 	or	r8,r9,r8
800076a0:	50 48       	stdsp	sp[0x10],r8
800076a2:	c0 40       	breq	800076aa <_vfprintf_r+0x952>
800076a4:	40 22       	lddsp	r2,sp[0x8]
800076a6:	30 39       	mov	r9,3
800076a8:	c1 08       	rjmp	800076c8 <_vfprintf_r+0x970>
800076aa:	e0 40 00 45 	cp.w	r0,69
800076ae:	5f 09       	sreq	r9
800076b0:	e0 40 00 65 	cp.w	r0,101
800076b4:	5f 08       	sreq	r8
800076b6:	40 22       	lddsp	r2,sp[0x8]
800076b8:	10 49       	or	r9,r8
800076ba:	2f f2       	sub	r2,-1
800076bc:	40 46       	lddsp	r6,sp[0x10]
800076be:	ec 09 18 00 	cp.b	r9,r6
800076c2:	fb f2 00 02 	ld.weq	r2,sp[0x8]
800076c6:	30 29       	mov	r9,2
800076c8:	fa c8 f9 5c 	sub	r8,sp,-1700
800076cc:	1a d8       	st.w	--sp,r8
800076ce:	fa c8 f9 54 	sub	r8,sp,-1708
800076d2:	1a d8       	st.w	--sp,r8
800076d4:	fa c8 f9 4c 	sub	r8,sp,-1716
800076d8:	08 9c       	mov	r12,r4
800076da:	1a d8       	st.w	--sp,r8
800076dc:	04 98       	mov	r8,r2
800076de:	40 9b       	lddsp	r11,sp[0x24]
800076e0:	40 aa       	lddsp	r10,sp[0x28]
800076e2:	e0 a0 0b c3 	rcall	80008e68 <_dtoa_r>
800076e6:	e0 40 00 47 	cp.w	r0,71
800076ea:	5f 19       	srne	r9
800076ec:	e0 40 00 67 	cp.w	r0,103
800076f0:	5f 18       	srne	r8
800076f2:	18 96       	mov	r6,r12
800076f4:	2f dd       	sub	sp,-12
800076f6:	f3 e8 00 08 	and	r8,r9,r8
800076fa:	c0 41       	brne	80007702 <_vfprintf_r+0x9aa>
800076fc:	ed b5 00 00 	bld	r5,0x0
80007700:	c3 01       	brne	80007760 <_vfprintf_r+0xa08>
80007702:	ec 02 00 0e 	add	lr,r6,r2
80007706:	50 3e       	stdsp	sp[0xc],lr
80007708:	40 4c       	lddsp	r12,sp[0x10]
8000770a:	58 0c       	cp.w	r12,0
8000770c:	c1 50       	breq	80007736 <_vfprintf_r+0x9de>
8000770e:	0d 89       	ld.ub	r9,r6[0x0]
80007710:	33 08       	mov	r8,48
80007712:	f0 09 18 00 	cp.b	r9,r8
80007716:	c0 b1       	brne	8000772c <_vfprintf_r+0x9d4>
80007718:	30 08       	mov	r8,0
8000771a:	30 09       	mov	r9,0
8000771c:	40 6b       	lddsp	r11,sp[0x18]
8000771e:	40 7a       	lddsp	r10,sp[0x1c]
80007720:	e0 a0 1c cb 	rcall	8000b0b6 <__avr32_f64_cmp_eq>
80007724:	fb b2 00 01 	rsubeq	r2,1
80007728:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000772c:	40 3b       	lddsp	r11,sp[0xc]
8000772e:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007732:	10 0b       	add	r11,r8
80007734:	50 3b       	stdsp	sp[0xc],r11
80007736:	40 6b       	lddsp	r11,sp[0x18]
80007738:	30 08       	mov	r8,0
8000773a:	30 09       	mov	r9,0
8000773c:	40 7a       	lddsp	r10,sp[0x1c]
8000773e:	e0 a0 1c bc 	rcall	8000b0b6 <__avr32_f64_cmp_eq>
80007742:	c0 90       	breq	80007754 <_vfprintf_r+0x9fc>
80007744:	40 3a       	lddsp	r10,sp[0xc]
80007746:	fb 4a 06 a4 	st.w	sp[1700],r10
8000774a:	c0 58       	rjmp	80007754 <_vfprintf_r+0x9fc>
8000774c:	10 c9       	st.b	r8++,r9
8000774e:	fb 48 06 a4 	st.w	sp[1700],r8
80007752:	c0 28       	rjmp	80007756 <_vfprintf_r+0x9fe>
80007754:	33 09       	mov	r9,48
80007756:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000775a:	40 3e       	lddsp	lr,sp[0xc]
8000775c:	1c 38       	cp.w	r8,lr
8000775e:	cf 73       	brcs	8000774c <_vfprintf_r+0x9f4>
80007760:	e0 40 00 47 	cp.w	r0,71
80007764:	5f 09       	sreq	r9
80007766:	e0 40 00 67 	cp.w	r0,103
8000776a:	5f 08       	sreq	r8
8000776c:	f3 e8 10 08 	or	r8,r9,r8
80007770:	fa f9 06 a4 	ld.w	r9,sp[1700]
80007774:	0c 19       	sub	r9,r6
80007776:	50 69       	stdsp	sp[0x18],r9
80007778:	58 08       	cp.w	r8,0
8000777a:	c0 b0       	breq	80007790 <_vfprintf_r+0xa38>
8000777c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007780:	5b d8       	cp.w	r8,-3
80007782:	c0 55       	brlt	8000778c <_vfprintf_r+0xa34>
80007784:	40 2c       	lddsp	r12,sp[0x8]
80007786:	18 38       	cp.w	r8,r12
80007788:	e0 8a 00 6a 	brle	8000785c <_vfprintf_r+0xb04>
8000778c:	20 20       	sub	r0,2
8000778e:	c0 58       	rjmp	80007798 <_vfprintf_r+0xa40>
80007790:	e0 40 00 65 	cp.w	r0,101
80007794:	e0 89 00 46 	brgt	80007820 <_vfprintf_r+0xac8>
80007798:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000779c:	fb 60 06 9c 	st.b	sp[1692],r0
800077a0:	20 1b       	sub	r11,1
800077a2:	fb 4b 06 ac 	st.w	sp[1708],r11
800077a6:	c0 47       	brpl	800077ae <_vfprintf_r+0xa56>
800077a8:	5c 3b       	neg	r11
800077aa:	32 d8       	mov	r8,45
800077ac:	c0 28       	rjmp	800077b0 <_vfprintf_r+0xa58>
800077ae:	32 b8       	mov	r8,43
800077b0:	fb 68 06 9d 	st.b	sp[1693],r8
800077b4:	58 9b       	cp.w	r11,9
800077b6:	e0 8a 00 1d 	brle	800077f0 <_vfprintf_r+0xa98>
800077ba:	fa c9 fa 35 	sub	r9,sp,-1483
800077be:	30 aa       	mov	r10,10
800077c0:	12 98       	mov	r8,r9
800077c2:	0e 9c       	mov	r12,r7
800077c4:	0c 92       	mov	r2,r6
800077c6:	f6 0a 0c 06 	divs	r6,r11,r10
800077ca:	0e 9b       	mov	r11,r7
800077cc:	2d 0b       	sub	r11,-48
800077ce:	10 fb       	st.b	--r8,r11
800077d0:	0c 9b       	mov	r11,r6
800077d2:	58 96       	cp.w	r6,9
800077d4:	fe 99 ff f9 	brgt	800077c6 <_vfprintf_r+0xa6e>
800077d8:	2d 0b       	sub	r11,-48
800077da:	18 97       	mov	r7,r12
800077dc:	04 96       	mov	r6,r2
800077de:	10 fb       	st.b	--r8,r11
800077e0:	fa ca f9 62 	sub	r10,sp,-1694
800077e4:	c0 38       	rjmp	800077ea <_vfprintf_r+0xa92>
800077e6:	11 3b       	ld.ub	r11,r8++
800077e8:	14 cb       	st.b	r10++,r11
800077ea:	12 38       	cp.w	r8,r9
800077ec:	cf d3       	brcs	800077e6 <_vfprintf_r+0xa8e>
800077ee:	c0 98       	rjmp	80007800 <_vfprintf_r+0xaa8>
800077f0:	2d 0b       	sub	r11,-48
800077f2:	33 08       	mov	r8,48
800077f4:	fb 6b 06 9f 	st.b	sp[1695],r11
800077f8:	fb 68 06 9e 	st.b	sp[1694],r8
800077fc:	fa ca f9 60 	sub	r10,sp,-1696
80007800:	fa c8 f9 64 	sub	r8,sp,-1692
80007804:	f4 08 01 08 	sub	r8,r10,r8
80007808:	50 e8       	stdsp	sp[0x38],r8
8000780a:	10 92       	mov	r2,r8
8000780c:	40 6b       	lddsp	r11,sp[0x18]
8000780e:	16 02       	add	r2,r11
80007810:	58 1b       	cp.w	r11,1
80007812:	e0 89 00 05 	brgt	8000781c <_vfprintf_r+0xac4>
80007816:	ed b5 00 00 	bld	r5,0x0
8000781a:	c3 51       	brne	80007884 <_vfprintf_r+0xb2c>
8000781c:	2f f2       	sub	r2,-1
8000781e:	c3 38       	rjmp	80007884 <_vfprintf_r+0xb2c>
80007820:	e0 40 00 66 	cp.w	r0,102
80007824:	c1 c1       	brne	8000785c <_vfprintf_r+0xb04>
80007826:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000782a:	58 02       	cp.w	r2,0
8000782c:	e0 8a 00 0c 	brle	80007844 <_vfprintf_r+0xaec>
80007830:	40 2a       	lddsp	r10,sp[0x8]
80007832:	58 0a       	cp.w	r10,0
80007834:	c0 41       	brne	8000783c <_vfprintf_r+0xae4>
80007836:	ed b5 00 00 	bld	r5,0x0
8000783a:	c2 51       	brne	80007884 <_vfprintf_r+0xb2c>
8000783c:	2f f2       	sub	r2,-1
8000783e:	40 29       	lddsp	r9,sp[0x8]
80007840:	12 02       	add	r2,r9
80007842:	c0 b8       	rjmp	80007858 <_vfprintf_r+0xb00>
80007844:	40 28       	lddsp	r8,sp[0x8]
80007846:	58 08       	cp.w	r8,0
80007848:	c0 61       	brne	80007854 <_vfprintf_r+0xafc>
8000784a:	ed b5 00 00 	bld	r5,0x0
8000784e:	c0 30       	breq	80007854 <_vfprintf_r+0xafc>
80007850:	30 12       	mov	r2,1
80007852:	c1 98       	rjmp	80007884 <_vfprintf_r+0xb2c>
80007854:	40 22       	lddsp	r2,sp[0x8]
80007856:	2f e2       	sub	r2,-2
80007858:	36 60       	mov	r0,102
8000785a:	c1 58       	rjmp	80007884 <_vfprintf_r+0xb2c>
8000785c:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007860:	40 6e       	lddsp	lr,sp[0x18]
80007862:	1c 32       	cp.w	r2,lr
80007864:	c0 65       	brlt	80007870 <_vfprintf_r+0xb18>
80007866:	ed b5 00 00 	bld	r5,0x0
8000786a:	f7 b2 00 ff 	subeq	r2,-1
8000786e:	c0 a8       	rjmp	80007882 <_vfprintf_r+0xb2a>
80007870:	e4 08 11 02 	rsub	r8,r2,2
80007874:	40 6c       	lddsp	r12,sp[0x18]
80007876:	58 02       	cp.w	r2,0
80007878:	f0 02 17 a0 	movle	r2,r8
8000787c:	f9 b2 09 01 	movgt	r2,1
80007880:	18 02       	add	r2,r12
80007882:	36 70       	mov	r0,103
80007884:	40 9b       	lddsp	r11,sp[0x24]
80007886:	58 0b       	cp.w	r11,0
80007888:	e0 80 05 94 	breq	800083b0 <_vfprintf_r+0x1658>
8000788c:	32 d8       	mov	r8,45
8000788e:	fb 68 06 bb 	st.b	sp[1723],r8
80007892:	e0 8f 05 93 	bral	800083b8 <_vfprintf_r+0x1660>
80007896:	50 a7       	stdsp	sp[0x28],r7
80007898:	04 94       	mov	r4,r2
8000789a:	0c 97       	mov	r7,r6
8000789c:	02 92       	mov	r2,r1
8000789e:	06 96       	mov	r6,r3
800078a0:	40 41       	lddsp	r1,sp[0x10]
800078a2:	40 93       	lddsp	r3,sp[0x24]
800078a4:	0e 99       	mov	r9,r7
800078a6:	ed b5 00 05 	bld	r5,0x5
800078aa:	c4 81       	brne	8000793a <_vfprintf_r+0xbe2>
800078ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800078b0:	40 3e       	lddsp	lr,sp[0xc]
800078b2:	58 0e       	cp.w	lr,0
800078b4:	c1 d0       	breq	800078ee <_vfprintf_r+0xb96>
800078b6:	10 36       	cp.w	r6,r8
800078b8:	c0 64       	brge	800078c4 <_vfprintf_r+0xb6c>
800078ba:	fa cc f9 44 	sub	r12,sp,-1724
800078be:	f8 06 00 36 	add	r6,r12,r6<<0x3
800078c2:	c1 d8       	rjmp	800078fc <_vfprintf_r+0xba4>
800078c4:	fa c8 f9 50 	sub	r8,sp,-1712
800078c8:	1a d8       	st.w	--sp,r8
800078ca:	fa c8 fa b8 	sub	r8,sp,-1352
800078ce:	04 9a       	mov	r10,r2
800078d0:	1a d8       	st.w	--sp,r8
800078d2:	fa c8 fb b4 	sub	r8,sp,-1100
800078d6:	0c 9b       	mov	r11,r6
800078d8:	1a d8       	st.w	--sp,r8
800078da:	08 9c       	mov	r12,r4
800078dc:	fa c8 f9 40 	sub	r8,sp,-1728
800078e0:	fa c9 ff b4 	sub	r9,sp,-76
800078e4:	fe b0 f8 a2 	rcall	80006a28 <get_arg>
800078e8:	2f dd       	sub	sp,-12
800078ea:	78 0a       	ld.w	r10,r12[0x0]
800078ec:	c2 08       	rjmp	8000792c <_vfprintf_r+0xbd4>
800078ee:	2f f7       	sub	r7,-1
800078f0:	10 39       	cp.w	r9,r8
800078f2:	c0 84       	brge	80007902 <_vfprintf_r+0xbaa>
800078f4:	fa cb f9 44 	sub	r11,sp,-1724
800078f8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800078fc:	ec fa fd 88 	ld.w	r10,r6[-632]
80007900:	c1 68       	rjmp	8000792c <_vfprintf_r+0xbd4>
80007902:	41 09       	lddsp	r9,sp[0x40]
80007904:	59 f8       	cp.w	r8,31
80007906:	e0 89 00 10 	brgt	80007926 <_vfprintf_r+0xbce>
8000790a:	f2 ca ff fc 	sub	r10,r9,-4
8000790e:	51 0a       	stdsp	sp[0x40],r10
80007910:	fa c6 f9 44 	sub	r6,sp,-1724
80007914:	72 0a       	ld.w	r10,r9[0x0]
80007916:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000791a:	f3 4a fd 88 	st.w	r9[-632],r10
8000791e:	2f f8       	sub	r8,-1
80007920:	fb 48 06 b4 	st.w	sp[1716],r8
80007924:	c0 48       	rjmp	8000792c <_vfprintf_r+0xbd4>
80007926:	72 0a       	ld.w	r10,r9[0x0]
80007928:	2f c9       	sub	r9,-4
8000792a:	51 09       	stdsp	sp[0x40],r9
8000792c:	40 be       	lddsp	lr,sp[0x2c]
8000792e:	1c 98       	mov	r8,lr
80007930:	95 1e       	st.w	r10[0x4],lr
80007932:	bf 58       	asr	r8,0x1f
80007934:	95 08       	st.w	r10[0x0],r8
80007936:	fe 9f fa 9f 	bral	80006e74 <_vfprintf_r+0x11c>
8000793a:	ed b5 00 04 	bld	r5,0x4
8000793e:	c4 80       	breq	800079ce <_vfprintf_r+0xc76>
80007940:	e2 15 00 40 	andl	r5,0x40,COH
80007944:	c4 50       	breq	800079ce <_vfprintf_r+0xc76>
80007946:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000794a:	40 3c       	lddsp	r12,sp[0xc]
8000794c:	58 0c       	cp.w	r12,0
8000794e:	c1 d0       	breq	80007988 <_vfprintf_r+0xc30>
80007950:	10 36       	cp.w	r6,r8
80007952:	c0 64       	brge	8000795e <_vfprintf_r+0xc06>
80007954:	fa cb f9 44 	sub	r11,sp,-1724
80007958:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000795c:	c1 d8       	rjmp	80007996 <_vfprintf_r+0xc3e>
8000795e:	fa c8 f9 50 	sub	r8,sp,-1712
80007962:	1a d8       	st.w	--sp,r8
80007964:	fa c8 fa b8 	sub	r8,sp,-1352
80007968:	04 9a       	mov	r10,r2
8000796a:	1a d8       	st.w	--sp,r8
8000796c:	fa c8 fb b4 	sub	r8,sp,-1100
80007970:	0c 9b       	mov	r11,r6
80007972:	1a d8       	st.w	--sp,r8
80007974:	08 9c       	mov	r12,r4
80007976:	fa c8 f9 40 	sub	r8,sp,-1728
8000797a:	fa c9 ff b4 	sub	r9,sp,-76
8000797e:	fe b0 f8 55 	rcall	80006a28 <get_arg>
80007982:	2f dd       	sub	sp,-12
80007984:	78 0a       	ld.w	r10,r12[0x0]
80007986:	c2 08       	rjmp	800079c6 <_vfprintf_r+0xc6e>
80007988:	2f f7       	sub	r7,-1
8000798a:	10 39       	cp.w	r9,r8
8000798c:	c0 84       	brge	8000799c <_vfprintf_r+0xc44>
8000798e:	fa ca f9 44 	sub	r10,sp,-1724
80007992:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007996:	ec fa fd 88 	ld.w	r10,r6[-632]
8000799a:	c1 68       	rjmp	800079c6 <_vfprintf_r+0xc6e>
8000799c:	41 09       	lddsp	r9,sp[0x40]
8000799e:	59 f8       	cp.w	r8,31
800079a0:	e0 89 00 10 	brgt	800079c0 <_vfprintf_r+0xc68>
800079a4:	f2 ca ff fc 	sub	r10,r9,-4
800079a8:	51 0a       	stdsp	sp[0x40],r10
800079aa:	fa c6 f9 44 	sub	r6,sp,-1724
800079ae:	72 0a       	ld.w	r10,r9[0x0]
800079b0:	ec 08 00 39 	add	r9,r6,r8<<0x3
800079b4:	f3 4a fd 88 	st.w	r9[-632],r10
800079b8:	2f f8       	sub	r8,-1
800079ba:	fb 48 06 b4 	st.w	sp[1716],r8
800079be:	c0 48       	rjmp	800079c6 <_vfprintf_r+0xc6e>
800079c0:	72 0a       	ld.w	r10,r9[0x0]
800079c2:	2f c9       	sub	r9,-4
800079c4:	51 09       	stdsp	sp[0x40],r9
800079c6:	40 be       	lddsp	lr,sp[0x2c]
800079c8:	b4 0e       	st.h	r10[0x0],lr
800079ca:	fe 9f fa 55 	bral	80006e74 <_vfprintf_r+0x11c>
800079ce:	fa f8 06 b4 	ld.w	r8,sp[1716]
800079d2:	40 3c       	lddsp	r12,sp[0xc]
800079d4:	58 0c       	cp.w	r12,0
800079d6:	c1 d0       	breq	80007a10 <_vfprintf_r+0xcb8>
800079d8:	10 36       	cp.w	r6,r8
800079da:	c0 64       	brge	800079e6 <_vfprintf_r+0xc8e>
800079dc:	fa cb f9 44 	sub	r11,sp,-1724
800079e0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800079e4:	c1 d8       	rjmp	80007a1e <_vfprintf_r+0xcc6>
800079e6:	fa c8 f9 50 	sub	r8,sp,-1712
800079ea:	1a d8       	st.w	--sp,r8
800079ec:	fa c8 fa b8 	sub	r8,sp,-1352
800079f0:	04 9a       	mov	r10,r2
800079f2:	1a d8       	st.w	--sp,r8
800079f4:	fa c8 fb b4 	sub	r8,sp,-1100
800079f8:	0c 9b       	mov	r11,r6
800079fa:	1a d8       	st.w	--sp,r8
800079fc:	08 9c       	mov	r12,r4
800079fe:	fa c8 f9 40 	sub	r8,sp,-1728
80007a02:	fa c9 ff b4 	sub	r9,sp,-76
80007a06:	fe b0 f8 11 	rcall	80006a28 <get_arg>
80007a0a:	2f dd       	sub	sp,-12
80007a0c:	78 0a       	ld.w	r10,r12[0x0]
80007a0e:	c2 08       	rjmp	80007a4e <_vfprintf_r+0xcf6>
80007a10:	2f f7       	sub	r7,-1
80007a12:	10 39       	cp.w	r9,r8
80007a14:	c0 84       	brge	80007a24 <_vfprintf_r+0xccc>
80007a16:	fa ca f9 44 	sub	r10,sp,-1724
80007a1a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007a1e:	ec fa fd 88 	ld.w	r10,r6[-632]
80007a22:	c1 68       	rjmp	80007a4e <_vfprintf_r+0xcf6>
80007a24:	41 09       	lddsp	r9,sp[0x40]
80007a26:	59 f8       	cp.w	r8,31
80007a28:	e0 89 00 10 	brgt	80007a48 <_vfprintf_r+0xcf0>
80007a2c:	f2 ca ff fc 	sub	r10,r9,-4
80007a30:	51 0a       	stdsp	sp[0x40],r10
80007a32:	fa c6 f9 44 	sub	r6,sp,-1724
80007a36:	72 0a       	ld.w	r10,r9[0x0]
80007a38:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007a3c:	f3 4a fd 88 	st.w	r9[-632],r10
80007a40:	2f f8       	sub	r8,-1
80007a42:	fb 48 06 b4 	st.w	sp[1716],r8
80007a46:	c0 48       	rjmp	80007a4e <_vfprintf_r+0xcf6>
80007a48:	72 0a       	ld.w	r10,r9[0x0]
80007a4a:	2f c9       	sub	r9,-4
80007a4c:	51 09       	stdsp	sp[0x40],r9
80007a4e:	40 be       	lddsp	lr,sp[0x2c]
80007a50:	95 0e       	st.w	r10[0x0],lr
80007a52:	fe 9f fa 11 	bral	80006e74 <_vfprintf_r+0x11c>
80007a56:	50 a7       	stdsp	sp[0x28],r7
80007a58:	50 80       	stdsp	sp[0x20],r0
80007a5a:	0c 97       	mov	r7,r6
80007a5c:	04 94       	mov	r4,r2
80007a5e:	06 96       	mov	r6,r3
80007a60:	02 92       	mov	r2,r1
80007a62:	40 93       	lddsp	r3,sp[0x24]
80007a64:	10 90       	mov	r0,r8
80007a66:	40 41       	lddsp	r1,sp[0x10]
80007a68:	a5 a5       	sbr	r5,0x4
80007a6a:	c0 a8       	rjmp	80007a7e <_vfprintf_r+0xd26>
80007a6c:	50 a7       	stdsp	sp[0x28],r7
80007a6e:	50 80       	stdsp	sp[0x20],r0
80007a70:	0c 97       	mov	r7,r6
80007a72:	04 94       	mov	r4,r2
80007a74:	06 96       	mov	r6,r3
80007a76:	02 92       	mov	r2,r1
80007a78:	40 93       	lddsp	r3,sp[0x24]
80007a7a:	10 90       	mov	r0,r8
80007a7c:	40 41       	lddsp	r1,sp[0x10]
80007a7e:	ed b5 00 05 	bld	r5,0x5
80007a82:	c5 d1       	brne	80007b3c <_vfprintf_r+0xde4>
80007a84:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a88:	40 3c       	lddsp	r12,sp[0xc]
80007a8a:	58 0c       	cp.w	r12,0
80007a8c:	c2 60       	breq	80007ad8 <_vfprintf_r+0xd80>
80007a8e:	10 36       	cp.w	r6,r8
80007a90:	c0 a4       	brge	80007aa4 <_vfprintf_r+0xd4c>
80007a92:	fa cb f9 44 	sub	r11,sp,-1724
80007a96:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a9a:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007a9e:	fa e9 00 00 	st.d	sp[0],r8
80007aa2:	c1 88       	rjmp	80007ad2 <_vfprintf_r+0xd7a>
80007aa4:	fa c8 f9 50 	sub	r8,sp,-1712
80007aa8:	1a d8       	st.w	--sp,r8
80007aaa:	fa c8 fa b8 	sub	r8,sp,-1352
80007aae:	04 9a       	mov	r10,r2
80007ab0:	1a d8       	st.w	--sp,r8
80007ab2:	0c 9b       	mov	r11,r6
80007ab4:	fa c8 fb b4 	sub	r8,sp,-1100
80007ab8:	08 9c       	mov	r12,r4
80007aba:	1a d8       	st.w	--sp,r8
80007abc:	fa c8 f9 40 	sub	r8,sp,-1728
80007ac0:	fa c9 ff b4 	sub	r9,sp,-76
80007ac4:	fe b0 f7 b2 	rcall	80006a28 <get_arg>
80007ac8:	2f dd       	sub	sp,-12
80007aca:	f8 ea 00 00 	ld.d	r10,r12[0]
80007ace:	fa eb 00 00 	st.d	sp[0],r10
80007ad2:	30 08       	mov	r8,0
80007ad4:	e0 8f 03 de 	bral	80008290 <_vfprintf_r+0x1538>
80007ad8:	ee ca ff ff 	sub	r10,r7,-1
80007adc:	10 37       	cp.w	r7,r8
80007ade:	c0 b4       	brge	80007af4 <_vfprintf_r+0xd9c>
80007ae0:	fa c9 f9 44 	sub	r9,sp,-1724
80007ae4:	14 97       	mov	r7,r10
80007ae6:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007aea:	ec ea fd 88 	ld.d	r10,r6[-632]
80007aee:	fa eb 00 00 	st.d	sp[0],r10
80007af2:	c1 88       	rjmp	80007b22 <_vfprintf_r+0xdca>
80007af4:	41 09       	lddsp	r9,sp[0x40]
80007af6:	59 f8       	cp.w	r8,31
80007af8:	e0 89 00 18 	brgt	80007b28 <_vfprintf_r+0xdd0>
80007afc:	f2 e6 00 00 	ld.d	r6,r9[0]
80007b00:	f2 cb ff f8 	sub	r11,r9,-8
80007b04:	fa e7 00 00 	st.d	sp[0],r6
80007b08:	51 0b       	stdsp	sp[0x40],r11
80007b0a:	fa c6 f9 44 	sub	r6,sp,-1724
80007b0e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007b12:	fa e6 00 00 	ld.d	r6,sp[0]
80007b16:	f2 e7 fd 88 	st.d	r9[-632],r6
80007b1a:	2f f8       	sub	r8,-1
80007b1c:	14 97       	mov	r7,r10
80007b1e:	fb 48 06 b4 	st.w	sp[1716],r8
80007b22:	40 38       	lddsp	r8,sp[0xc]
80007b24:	e0 8f 03 b6 	bral	80008290 <_vfprintf_r+0x1538>
80007b28:	f2 e6 00 00 	ld.d	r6,r9[0]
80007b2c:	40 38       	lddsp	r8,sp[0xc]
80007b2e:	fa e7 00 00 	st.d	sp[0],r6
80007b32:	2f 89       	sub	r9,-8
80007b34:	14 97       	mov	r7,r10
80007b36:	51 09       	stdsp	sp[0x40],r9
80007b38:	e0 8f 03 ac 	bral	80008290 <_vfprintf_r+0x1538>
80007b3c:	ed b5 00 04 	bld	r5,0x4
80007b40:	c1 61       	brne	80007b6c <_vfprintf_r+0xe14>
80007b42:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b46:	40 3e       	lddsp	lr,sp[0xc]
80007b48:	58 0e       	cp.w	lr,0
80007b4a:	c0 80       	breq	80007b5a <_vfprintf_r+0xe02>
80007b4c:	10 36       	cp.w	r6,r8
80007b4e:	c6 74       	brge	80007c1c <_vfprintf_r+0xec4>
80007b50:	fa cc f9 44 	sub	r12,sp,-1724
80007b54:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007b58:	c8 08       	rjmp	80007c58 <_vfprintf_r+0xf00>
80007b5a:	ee ca ff ff 	sub	r10,r7,-1
80007b5e:	10 37       	cp.w	r7,r8
80007b60:	c7 f4       	brge	80007c5e <_vfprintf_r+0xf06>
80007b62:	fa cb f9 44 	sub	r11,sp,-1724
80007b66:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b6a:	c7 68       	rjmp	80007c56 <_vfprintf_r+0xefe>
80007b6c:	ed b5 00 06 	bld	r5,0x6
80007b70:	c4 a1       	brne	80007c04 <_vfprintf_r+0xeac>
80007b72:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b76:	40 3c       	lddsp	r12,sp[0xc]
80007b78:	58 0c       	cp.w	r12,0
80007b7a:	c1 d0       	breq	80007bb4 <_vfprintf_r+0xe5c>
80007b7c:	10 36       	cp.w	r6,r8
80007b7e:	c0 64       	brge	80007b8a <_vfprintf_r+0xe32>
80007b80:	fa cb f9 44 	sub	r11,sp,-1724
80007b84:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b88:	c1 f8       	rjmp	80007bc6 <_vfprintf_r+0xe6e>
80007b8a:	fa c8 f9 50 	sub	r8,sp,-1712
80007b8e:	1a d8       	st.w	--sp,r8
80007b90:	fa c8 fa b8 	sub	r8,sp,-1352
80007b94:	1a d8       	st.w	--sp,r8
80007b96:	fa c8 fb b4 	sub	r8,sp,-1100
80007b9a:	1a d8       	st.w	--sp,r8
80007b9c:	fa c8 f9 40 	sub	r8,sp,-1728
80007ba0:	fa c9 ff b4 	sub	r9,sp,-76
80007ba4:	04 9a       	mov	r10,r2
80007ba6:	0c 9b       	mov	r11,r6
80007ba8:	08 9c       	mov	r12,r4
80007baa:	fe b0 f7 3f 	rcall	80006a28 <get_arg>
80007bae:	2f dd       	sub	sp,-12
80007bb0:	98 18       	ld.sh	r8,r12[0x2]
80007bb2:	c2 68       	rjmp	80007bfe <_vfprintf_r+0xea6>
80007bb4:	ee ca ff ff 	sub	r10,r7,-1
80007bb8:	10 37       	cp.w	r7,r8
80007bba:	c0 94       	brge	80007bcc <_vfprintf_r+0xe74>
80007bbc:	fa c9 f9 44 	sub	r9,sp,-1724
80007bc0:	14 97       	mov	r7,r10
80007bc2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007bc6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007bca:	c1 a8       	rjmp	80007bfe <_vfprintf_r+0xea6>
80007bcc:	41 09       	lddsp	r9,sp[0x40]
80007bce:	59 f8       	cp.w	r8,31
80007bd0:	e0 89 00 13 	brgt	80007bf6 <_vfprintf_r+0xe9e>
80007bd4:	f2 cb ff fc 	sub	r11,r9,-4
80007bd8:	51 0b       	stdsp	sp[0x40],r11
80007bda:	72 09       	ld.w	r9,r9[0x0]
80007bdc:	fa c6 f9 44 	sub	r6,sp,-1724
80007be0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007be4:	2f f8       	sub	r8,-1
80007be6:	f7 49 fd 88 	st.w	r11[-632],r9
80007bea:	fb 48 06 b4 	st.w	sp[1716],r8
80007bee:	14 97       	mov	r7,r10
80007bf0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007bf4:	c0 58       	rjmp	80007bfe <_vfprintf_r+0xea6>
80007bf6:	92 18       	ld.sh	r8,r9[0x2]
80007bf8:	14 97       	mov	r7,r10
80007bfa:	2f c9       	sub	r9,-4
80007bfc:	51 09       	stdsp	sp[0x40],r9
80007bfe:	5c 78       	castu.h	r8
80007c00:	50 18       	stdsp	sp[0x4],r8
80007c02:	c4 68       	rjmp	80007c8e <_vfprintf_r+0xf36>
80007c04:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c08:	40 3c       	lddsp	r12,sp[0xc]
80007c0a:	58 0c       	cp.w	r12,0
80007c0c:	c1 d0       	breq	80007c46 <_vfprintf_r+0xeee>
80007c0e:	10 36       	cp.w	r6,r8
80007c10:	c0 64       	brge	80007c1c <_vfprintf_r+0xec4>
80007c12:	fa cb f9 44 	sub	r11,sp,-1724
80007c16:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c1a:	c1 f8       	rjmp	80007c58 <_vfprintf_r+0xf00>
80007c1c:	fa c8 f9 50 	sub	r8,sp,-1712
80007c20:	1a d8       	st.w	--sp,r8
80007c22:	fa c8 fa b8 	sub	r8,sp,-1352
80007c26:	0c 9b       	mov	r11,r6
80007c28:	1a d8       	st.w	--sp,r8
80007c2a:	fa c8 fb b4 	sub	r8,sp,-1100
80007c2e:	04 9a       	mov	r10,r2
80007c30:	1a d8       	st.w	--sp,r8
80007c32:	08 9c       	mov	r12,r4
80007c34:	fa c8 f9 40 	sub	r8,sp,-1728
80007c38:	fa c9 ff b4 	sub	r9,sp,-76
80007c3c:	fe b0 f6 f6 	rcall	80006a28 <get_arg>
80007c40:	2f dd       	sub	sp,-12
80007c42:	78 0b       	ld.w	r11,r12[0x0]
80007c44:	c2 48       	rjmp	80007c8c <_vfprintf_r+0xf34>
80007c46:	ee ca ff ff 	sub	r10,r7,-1
80007c4a:	10 37       	cp.w	r7,r8
80007c4c:	c0 94       	brge	80007c5e <_vfprintf_r+0xf06>
80007c4e:	fa c9 f9 44 	sub	r9,sp,-1724
80007c52:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c56:	14 97       	mov	r7,r10
80007c58:	ec fb fd 88 	ld.w	r11,r6[-632]
80007c5c:	c1 88       	rjmp	80007c8c <_vfprintf_r+0xf34>
80007c5e:	41 09       	lddsp	r9,sp[0x40]
80007c60:	59 f8       	cp.w	r8,31
80007c62:	e0 89 00 11 	brgt	80007c84 <_vfprintf_r+0xf2c>
80007c66:	f2 cb ff fc 	sub	r11,r9,-4
80007c6a:	51 0b       	stdsp	sp[0x40],r11
80007c6c:	fa c6 f9 44 	sub	r6,sp,-1724
80007c70:	72 0b       	ld.w	r11,r9[0x0]
80007c72:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007c76:	f3 4b fd 88 	st.w	r9[-632],r11
80007c7a:	2f f8       	sub	r8,-1
80007c7c:	14 97       	mov	r7,r10
80007c7e:	fb 48 06 b4 	st.w	sp[1716],r8
80007c82:	c0 58       	rjmp	80007c8c <_vfprintf_r+0xf34>
80007c84:	72 0b       	ld.w	r11,r9[0x0]
80007c86:	14 97       	mov	r7,r10
80007c88:	2f c9       	sub	r9,-4
80007c8a:	51 09       	stdsp	sp[0x40],r9
80007c8c:	50 1b       	stdsp	sp[0x4],r11
80007c8e:	30 0e       	mov	lr,0
80007c90:	50 0e       	stdsp	sp[0x0],lr
80007c92:	1c 98       	mov	r8,lr
80007c94:	e0 8f 02 fe 	bral	80008290 <_vfprintf_r+0x1538>
80007c98:	50 a7       	stdsp	sp[0x28],r7
80007c9a:	50 80       	stdsp	sp[0x20],r0
80007c9c:	0c 97       	mov	r7,r6
80007c9e:	04 94       	mov	r4,r2
80007ca0:	06 96       	mov	r6,r3
80007ca2:	02 92       	mov	r2,r1
80007ca4:	40 93       	lddsp	r3,sp[0x24]
80007ca6:	40 41       	lddsp	r1,sp[0x10]
80007ca8:	0e 99       	mov	r9,r7
80007caa:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007cae:	40 3c       	lddsp	r12,sp[0xc]
80007cb0:	58 0c       	cp.w	r12,0
80007cb2:	c1 d0       	breq	80007cec <_vfprintf_r+0xf94>
80007cb4:	10 36       	cp.w	r6,r8
80007cb6:	c0 64       	brge	80007cc2 <_vfprintf_r+0xf6a>
80007cb8:	fa cb f9 44 	sub	r11,sp,-1724
80007cbc:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007cc0:	c1 d8       	rjmp	80007cfa <_vfprintf_r+0xfa2>
80007cc2:	fa c8 f9 50 	sub	r8,sp,-1712
80007cc6:	1a d8       	st.w	--sp,r8
80007cc8:	fa c8 fa b8 	sub	r8,sp,-1352
80007ccc:	1a d8       	st.w	--sp,r8
80007cce:	fa c8 fb b4 	sub	r8,sp,-1100
80007cd2:	1a d8       	st.w	--sp,r8
80007cd4:	fa c9 ff b4 	sub	r9,sp,-76
80007cd8:	fa c8 f9 40 	sub	r8,sp,-1728
80007cdc:	04 9a       	mov	r10,r2
80007cde:	0c 9b       	mov	r11,r6
80007ce0:	08 9c       	mov	r12,r4
80007ce2:	fe b0 f6 a3 	rcall	80006a28 <get_arg>
80007ce6:	2f dd       	sub	sp,-12
80007ce8:	78 09       	ld.w	r9,r12[0x0]
80007cea:	c2 18       	rjmp	80007d2c <_vfprintf_r+0xfd4>
80007cec:	2f f7       	sub	r7,-1
80007cee:	10 39       	cp.w	r9,r8
80007cf0:	c0 84       	brge	80007d00 <_vfprintf_r+0xfa8>
80007cf2:	fa ca f9 44 	sub	r10,sp,-1724
80007cf6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007cfa:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007cfe:	c1 78       	rjmp	80007d2c <_vfprintf_r+0xfd4>
80007d00:	41 09       	lddsp	r9,sp[0x40]
80007d02:	59 f8       	cp.w	r8,31
80007d04:	e0 89 00 10 	brgt	80007d24 <_vfprintf_r+0xfcc>
80007d08:	f2 ca ff fc 	sub	r10,r9,-4
80007d0c:	51 0a       	stdsp	sp[0x40],r10
80007d0e:	fa c6 f9 44 	sub	r6,sp,-1724
80007d12:	72 09       	ld.w	r9,r9[0x0]
80007d14:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007d18:	f5 49 fd 88 	st.w	r10[-632],r9
80007d1c:	2f f8       	sub	r8,-1
80007d1e:	fb 48 06 b4 	st.w	sp[1716],r8
80007d22:	c0 58       	rjmp	80007d2c <_vfprintf_r+0xfd4>
80007d24:	f2 c8 ff fc 	sub	r8,r9,-4
80007d28:	51 08       	stdsp	sp[0x40],r8
80007d2a:	72 09       	ld.w	r9,r9[0x0]
80007d2c:	33 08       	mov	r8,48
80007d2e:	fb 68 06 b8 	st.b	sp[1720],r8
80007d32:	37 88       	mov	r8,120
80007d34:	30 0e       	mov	lr,0
80007d36:	fb 68 06 b9 	st.b	sp[1721],r8
80007d3a:	fe cc b2 76 	sub	r12,pc,-19850
80007d3e:	50 19       	stdsp	sp[0x4],r9
80007d40:	a1 b5       	sbr	r5,0x1
80007d42:	50 0e       	stdsp	sp[0x0],lr
80007d44:	50 dc       	stdsp	sp[0x34],r12
80007d46:	30 28       	mov	r8,2
80007d48:	37 80       	mov	r0,120
80007d4a:	e0 8f 02 a3 	bral	80008290 <_vfprintf_r+0x1538>
80007d4e:	50 a7       	stdsp	sp[0x28],r7
80007d50:	50 80       	stdsp	sp[0x20],r0
80007d52:	10 90       	mov	r0,r8
80007d54:	30 08       	mov	r8,0
80007d56:	fb 68 06 bb 	st.b	sp[1723],r8
80007d5a:	0c 97       	mov	r7,r6
80007d5c:	04 94       	mov	r4,r2
80007d5e:	06 96       	mov	r6,r3
80007d60:	02 92       	mov	r2,r1
80007d62:	40 93       	lddsp	r3,sp[0x24]
80007d64:	40 41       	lddsp	r1,sp[0x10]
80007d66:	0e 99       	mov	r9,r7
80007d68:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d6c:	40 3b       	lddsp	r11,sp[0xc]
80007d6e:	58 0b       	cp.w	r11,0
80007d70:	c1 d0       	breq	80007daa <_vfprintf_r+0x1052>
80007d72:	10 36       	cp.w	r6,r8
80007d74:	c0 64       	brge	80007d80 <_vfprintf_r+0x1028>
80007d76:	fa ca f9 44 	sub	r10,sp,-1724
80007d7a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007d7e:	c1 d8       	rjmp	80007db8 <_vfprintf_r+0x1060>
80007d80:	fa c8 f9 50 	sub	r8,sp,-1712
80007d84:	1a d8       	st.w	--sp,r8
80007d86:	fa c8 fa b8 	sub	r8,sp,-1352
80007d8a:	1a d8       	st.w	--sp,r8
80007d8c:	fa c8 fb b4 	sub	r8,sp,-1100
80007d90:	0c 9b       	mov	r11,r6
80007d92:	1a d8       	st.w	--sp,r8
80007d94:	04 9a       	mov	r10,r2
80007d96:	fa c8 f9 40 	sub	r8,sp,-1728
80007d9a:	fa c9 ff b4 	sub	r9,sp,-76
80007d9e:	08 9c       	mov	r12,r4
80007da0:	fe b0 f6 44 	rcall	80006a28 <get_arg>
80007da4:	2f dd       	sub	sp,-12
80007da6:	78 06       	ld.w	r6,r12[0x0]
80007da8:	c2 08       	rjmp	80007de8 <_vfprintf_r+0x1090>
80007daa:	2f f7       	sub	r7,-1
80007dac:	10 39       	cp.w	r9,r8
80007dae:	c0 84       	brge	80007dbe <_vfprintf_r+0x1066>
80007db0:	fa c9 f9 44 	sub	r9,sp,-1724
80007db4:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007db8:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007dbc:	c1 68       	rjmp	80007de8 <_vfprintf_r+0x1090>
80007dbe:	41 09       	lddsp	r9,sp[0x40]
80007dc0:	59 f8       	cp.w	r8,31
80007dc2:	e0 89 00 10 	brgt	80007de2 <_vfprintf_r+0x108a>
80007dc6:	f2 ca ff fc 	sub	r10,r9,-4
80007dca:	51 0a       	stdsp	sp[0x40],r10
80007dcc:	72 06       	ld.w	r6,r9[0x0]
80007dce:	fa ce f9 44 	sub	lr,sp,-1724
80007dd2:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007dd6:	f3 46 fd 88 	st.w	r9[-632],r6
80007dda:	2f f8       	sub	r8,-1
80007ddc:	fb 48 06 b4 	st.w	sp[1716],r8
80007de0:	c0 48       	rjmp	80007de8 <_vfprintf_r+0x1090>
80007de2:	72 06       	ld.w	r6,r9[0x0]
80007de4:	2f c9       	sub	r9,-4
80007de6:	51 09       	stdsp	sp[0x40],r9
80007de8:	40 2c       	lddsp	r12,sp[0x8]
80007dea:	58 0c       	cp.w	r12,0
80007dec:	c1 05       	brlt	80007e0c <_vfprintf_r+0x10b4>
80007dee:	18 9a       	mov	r10,r12
80007df0:	30 0b       	mov	r11,0
80007df2:	0c 9c       	mov	r12,r6
80007df4:	e0 a0 12 38 	rcall	8000a264 <memchr>
80007df8:	e0 80 02 df 	breq	800083b6 <_vfprintf_r+0x165e>
80007dfc:	f8 06 01 02 	sub	r2,r12,r6
80007e00:	40 2b       	lddsp	r11,sp[0x8]
80007e02:	16 32       	cp.w	r2,r11
80007e04:	e0 89 02 d9 	brgt	800083b6 <_vfprintf_r+0x165e>
80007e08:	e0 8f 02 d4 	bral	800083b0 <_vfprintf_r+0x1658>
80007e0c:	30 0a       	mov	r10,0
80007e0e:	0c 9c       	mov	r12,r6
80007e10:	50 2a       	stdsp	sp[0x8],r10
80007e12:	fe b0 f5 85 	rcall	8000691c <strlen>
80007e16:	18 92       	mov	r2,r12
80007e18:	e0 8f 02 d2 	bral	800083bc <_vfprintf_r+0x1664>
80007e1c:	50 a7       	stdsp	sp[0x28],r7
80007e1e:	50 80       	stdsp	sp[0x20],r0
80007e20:	0c 97       	mov	r7,r6
80007e22:	04 94       	mov	r4,r2
80007e24:	06 96       	mov	r6,r3
80007e26:	02 92       	mov	r2,r1
80007e28:	40 93       	lddsp	r3,sp[0x24]
80007e2a:	10 90       	mov	r0,r8
80007e2c:	40 41       	lddsp	r1,sp[0x10]
80007e2e:	a5 a5       	sbr	r5,0x4
80007e30:	c0 a8       	rjmp	80007e44 <_vfprintf_r+0x10ec>
80007e32:	50 a7       	stdsp	sp[0x28],r7
80007e34:	50 80       	stdsp	sp[0x20],r0
80007e36:	0c 97       	mov	r7,r6
80007e38:	04 94       	mov	r4,r2
80007e3a:	06 96       	mov	r6,r3
80007e3c:	02 92       	mov	r2,r1
80007e3e:	40 93       	lddsp	r3,sp[0x24]
80007e40:	10 90       	mov	r0,r8
80007e42:	40 41       	lddsp	r1,sp[0x10]
80007e44:	ed b5 00 05 	bld	r5,0x5
80007e48:	c5 61       	brne	80007ef4 <_vfprintf_r+0x119c>
80007e4a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e4e:	40 39       	lddsp	r9,sp[0xc]
80007e50:	58 09       	cp.w	r9,0
80007e52:	c2 10       	breq	80007e94 <_vfprintf_r+0x113c>
80007e54:	10 36       	cp.w	r6,r8
80007e56:	c0 74       	brge	80007e64 <_vfprintf_r+0x110c>
80007e58:	fa c8 f9 44 	sub	r8,sp,-1724
80007e5c:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007e60:	c2 38       	rjmp	80007ea6 <_vfprintf_r+0x114e>
80007e62:	d7 03       	nop
80007e64:	fa c8 f9 50 	sub	r8,sp,-1712
80007e68:	1a d8       	st.w	--sp,r8
80007e6a:	fa c8 fa b8 	sub	r8,sp,-1352
80007e6e:	1a d8       	st.w	--sp,r8
80007e70:	fa c8 fb b4 	sub	r8,sp,-1100
80007e74:	1a d8       	st.w	--sp,r8
80007e76:	fa c8 f9 40 	sub	r8,sp,-1728
80007e7a:	fa c9 ff b4 	sub	r9,sp,-76
80007e7e:	04 9a       	mov	r10,r2
80007e80:	0c 9b       	mov	r11,r6
80007e82:	08 9c       	mov	r12,r4
80007e84:	fe b0 f5 d2 	rcall	80006a28 <get_arg>
80007e88:	2f dd       	sub	sp,-12
80007e8a:	f8 e8 00 00 	ld.d	r8,r12[0]
80007e8e:	fa e9 00 00 	st.d	sp[0],r8
80007e92:	c2 e8       	rjmp	80007eee <_vfprintf_r+0x1196>
80007e94:	ee ca ff ff 	sub	r10,r7,-1
80007e98:	10 37       	cp.w	r7,r8
80007e9a:	c0 b4       	brge	80007eb0 <_vfprintf_r+0x1158>
80007e9c:	fa c8 f9 44 	sub	r8,sp,-1724
80007ea0:	14 97       	mov	r7,r10
80007ea2:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007ea6:	ec ea fd 88 	ld.d	r10,r6[-632]
80007eaa:	fa eb 00 00 	st.d	sp[0],r10
80007eae:	c2 08       	rjmp	80007eee <_vfprintf_r+0x1196>
80007eb0:	41 09       	lddsp	r9,sp[0x40]
80007eb2:	59 f8       	cp.w	r8,31
80007eb4:	e0 89 00 16 	brgt	80007ee0 <_vfprintf_r+0x1188>
80007eb8:	f2 e6 00 00 	ld.d	r6,r9[0]
80007ebc:	f2 cb ff f8 	sub	r11,r9,-8
80007ec0:	fa e7 00 00 	st.d	sp[0],r6
80007ec4:	51 0b       	stdsp	sp[0x40],r11
80007ec6:	fa c6 f9 44 	sub	r6,sp,-1724
80007eca:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ece:	fa e6 00 00 	ld.d	r6,sp[0]
80007ed2:	f2 e7 fd 88 	st.d	r9[-632],r6
80007ed6:	2f f8       	sub	r8,-1
80007ed8:	14 97       	mov	r7,r10
80007eda:	fb 48 06 b4 	st.w	sp[1716],r8
80007ede:	c0 88       	rjmp	80007eee <_vfprintf_r+0x1196>
80007ee0:	f2 e6 00 00 	ld.d	r6,r9[0]
80007ee4:	2f 89       	sub	r9,-8
80007ee6:	fa e7 00 00 	st.d	sp[0],r6
80007eea:	51 09       	stdsp	sp[0x40],r9
80007eec:	14 97       	mov	r7,r10
80007eee:	30 18       	mov	r8,1
80007ef0:	e0 8f 01 d0 	bral	80008290 <_vfprintf_r+0x1538>
80007ef4:	ed b5 00 04 	bld	r5,0x4
80007ef8:	c1 61       	brne	80007f24 <_vfprintf_r+0x11cc>
80007efa:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007efe:	40 3e       	lddsp	lr,sp[0xc]
80007f00:	58 0e       	cp.w	lr,0
80007f02:	c0 80       	breq	80007f12 <_vfprintf_r+0x11ba>
80007f04:	10 36       	cp.w	r6,r8
80007f06:	c6 74       	brge	80007fd4 <_vfprintf_r+0x127c>
80007f08:	fa cc f9 44 	sub	r12,sp,-1724
80007f0c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007f10:	c8 08       	rjmp	80008010 <_vfprintf_r+0x12b8>
80007f12:	ee ca ff ff 	sub	r10,r7,-1
80007f16:	10 37       	cp.w	r7,r8
80007f18:	c7 f4       	brge	80008016 <_vfprintf_r+0x12be>
80007f1a:	fa cb f9 44 	sub	r11,sp,-1724
80007f1e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f22:	c7 68       	rjmp	8000800e <_vfprintf_r+0x12b6>
80007f24:	ed b5 00 06 	bld	r5,0x6
80007f28:	c4 a1       	brne	80007fbc <_vfprintf_r+0x1264>
80007f2a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f2e:	40 3c       	lddsp	r12,sp[0xc]
80007f30:	58 0c       	cp.w	r12,0
80007f32:	c1 d0       	breq	80007f6c <_vfprintf_r+0x1214>
80007f34:	10 36       	cp.w	r6,r8
80007f36:	c0 64       	brge	80007f42 <_vfprintf_r+0x11ea>
80007f38:	fa cb f9 44 	sub	r11,sp,-1724
80007f3c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f40:	c1 f8       	rjmp	80007f7e <_vfprintf_r+0x1226>
80007f42:	fa c8 f9 50 	sub	r8,sp,-1712
80007f46:	1a d8       	st.w	--sp,r8
80007f48:	fa c8 fa b8 	sub	r8,sp,-1352
80007f4c:	1a d8       	st.w	--sp,r8
80007f4e:	fa c8 fb b4 	sub	r8,sp,-1100
80007f52:	1a d8       	st.w	--sp,r8
80007f54:	fa c8 f9 40 	sub	r8,sp,-1728
80007f58:	fa c9 ff b4 	sub	r9,sp,-76
80007f5c:	04 9a       	mov	r10,r2
80007f5e:	0c 9b       	mov	r11,r6
80007f60:	08 9c       	mov	r12,r4
80007f62:	fe b0 f5 63 	rcall	80006a28 <get_arg>
80007f66:	2f dd       	sub	sp,-12
80007f68:	98 18       	ld.sh	r8,r12[0x2]
80007f6a:	c2 68       	rjmp	80007fb6 <_vfprintf_r+0x125e>
80007f6c:	ee ca ff ff 	sub	r10,r7,-1
80007f70:	10 37       	cp.w	r7,r8
80007f72:	c0 94       	brge	80007f84 <_vfprintf_r+0x122c>
80007f74:	fa c9 f9 44 	sub	r9,sp,-1724
80007f78:	14 97       	mov	r7,r10
80007f7a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f7e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007f82:	c1 a8       	rjmp	80007fb6 <_vfprintf_r+0x125e>
80007f84:	41 09       	lddsp	r9,sp[0x40]
80007f86:	59 f8       	cp.w	r8,31
80007f88:	e0 89 00 13 	brgt	80007fae <_vfprintf_r+0x1256>
80007f8c:	f2 cb ff fc 	sub	r11,r9,-4
80007f90:	51 0b       	stdsp	sp[0x40],r11
80007f92:	72 09       	ld.w	r9,r9[0x0]
80007f94:	fa c6 f9 44 	sub	r6,sp,-1724
80007f98:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007f9c:	2f f8       	sub	r8,-1
80007f9e:	f7 49 fd 88 	st.w	r11[-632],r9
80007fa2:	fb 48 06 b4 	st.w	sp[1716],r8
80007fa6:	14 97       	mov	r7,r10
80007fa8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007fac:	c0 58       	rjmp	80007fb6 <_vfprintf_r+0x125e>
80007fae:	92 18       	ld.sh	r8,r9[0x2]
80007fb0:	14 97       	mov	r7,r10
80007fb2:	2f c9       	sub	r9,-4
80007fb4:	51 09       	stdsp	sp[0x40],r9
80007fb6:	5c 78       	castu.h	r8
80007fb8:	50 18       	stdsp	sp[0x4],r8
80007fba:	c4 68       	rjmp	80008046 <_vfprintf_r+0x12ee>
80007fbc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007fc0:	40 3c       	lddsp	r12,sp[0xc]
80007fc2:	58 0c       	cp.w	r12,0
80007fc4:	c1 d0       	breq	80007ffe <_vfprintf_r+0x12a6>
80007fc6:	10 36       	cp.w	r6,r8
80007fc8:	c0 64       	brge	80007fd4 <_vfprintf_r+0x127c>
80007fca:	fa cb f9 44 	sub	r11,sp,-1724
80007fce:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007fd2:	c1 f8       	rjmp	80008010 <_vfprintf_r+0x12b8>
80007fd4:	fa c8 f9 50 	sub	r8,sp,-1712
80007fd8:	1a d8       	st.w	--sp,r8
80007fda:	fa c8 fa b8 	sub	r8,sp,-1352
80007fde:	0c 9b       	mov	r11,r6
80007fe0:	1a d8       	st.w	--sp,r8
80007fe2:	fa c8 fb b4 	sub	r8,sp,-1100
80007fe6:	04 9a       	mov	r10,r2
80007fe8:	1a d8       	st.w	--sp,r8
80007fea:	08 9c       	mov	r12,r4
80007fec:	fa c8 f9 40 	sub	r8,sp,-1728
80007ff0:	fa c9 ff b4 	sub	r9,sp,-76
80007ff4:	fe b0 f5 1a 	rcall	80006a28 <get_arg>
80007ff8:	2f dd       	sub	sp,-12
80007ffa:	78 0b       	ld.w	r11,r12[0x0]
80007ffc:	c2 48       	rjmp	80008044 <_vfprintf_r+0x12ec>
80007ffe:	ee ca ff ff 	sub	r10,r7,-1
80008002:	10 37       	cp.w	r7,r8
80008004:	c0 94       	brge	80008016 <_vfprintf_r+0x12be>
80008006:	fa c9 f9 44 	sub	r9,sp,-1724
8000800a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000800e:	14 97       	mov	r7,r10
80008010:	ec fb fd 88 	ld.w	r11,r6[-632]
80008014:	c1 88       	rjmp	80008044 <_vfprintf_r+0x12ec>
80008016:	41 09       	lddsp	r9,sp[0x40]
80008018:	59 f8       	cp.w	r8,31
8000801a:	e0 89 00 11 	brgt	8000803c <_vfprintf_r+0x12e4>
8000801e:	f2 cb ff fc 	sub	r11,r9,-4
80008022:	51 0b       	stdsp	sp[0x40],r11
80008024:	fa c6 f9 44 	sub	r6,sp,-1724
80008028:	72 0b       	ld.w	r11,r9[0x0]
8000802a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000802e:	f3 4b fd 88 	st.w	r9[-632],r11
80008032:	2f f8       	sub	r8,-1
80008034:	14 97       	mov	r7,r10
80008036:	fb 48 06 b4 	st.w	sp[1716],r8
8000803a:	c0 58       	rjmp	80008044 <_vfprintf_r+0x12ec>
8000803c:	72 0b       	ld.w	r11,r9[0x0]
8000803e:	14 97       	mov	r7,r10
80008040:	2f c9       	sub	r9,-4
80008042:	51 09       	stdsp	sp[0x40],r9
80008044:	50 1b       	stdsp	sp[0x4],r11
80008046:	30 0e       	mov	lr,0
80008048:	30 18       	mov	r8,1
8000804a:	50 0e       	stdsp	sp[0x0],lr
8000804c:	c2 29       	rjmp	80008290 <_vfprintf_r+0x1538>
8000804e:	50 a7       	stdsp	sp[0x28],r7
80008050:	50 80       	stdsp	sp[0x20],r0
80008052:	0c 97       	mov	r7,r6
80008054:	04 94       	mov	r4,r2
80008056:	06 96       	mov	r6,r3
80008058:	02 92       	mov	r2,r1
8000805a:	fe cc b5 96 	sub	r12,pc,-19050
8000805e:	40 93       	lddsp	r3,sp[0x24]
80008060:	10 90       	mov	r0,r8
80008062:	40 41       	lddsp	r1,sp[0x10]
80008064:	50 dc       	stdsp	sp[0x34],r12
80008066:	ed b5 00 05 	bld	r5,0x5
8000806a:	c5 51       	brne	80008114 <_vfprintf_r+0x13bc>
8000806c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008070:	40 3b       	lddsp	r11,sp[0xc]
80008072:	58 0b       	cp.w	r11,0
80008074:	c2 20       	breq	800080b8 <_vfprintf_r+0x1360>
80008076:	10 36       	cp.w	r6,r8
80008078:	c0 a4       	brge	8000808c <_vfprintf_r+0x1334>
8000807a:	fa ca f9 44 	sub	r10,sp,-1724
8000807e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008082:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008086:	fa e9 00 00 	st.d	sp[0],r8
8000808a:	cf 28       	rjmp	8000826e <_vfprintf_r+0x1516>
8000808c:	fa c8 f9 50 	sub	r8,sp,-1712
80008090:	1a d8       	st.w	--sp,r8
80008092:	fa c8 fa b8 	sub	r8,sp,-1352
80008096:	04 9a       	mov	r10,r2
80008098:	1a d8       	st.w	--sp,r8
8000809a:	0c 9b       	mov	r11,r6
8000809c:	fa c8 fb b4 	sub	r8,sp,-1100
800080a0:	08 9c       	mov	r12,r4
800080a2:	1a d8       	st.w	--sp,r8
800080a4:	fa c8 f9 40 	sub	r8,sp,-1728
800080a8:	fa c9 ff b4 	sub	r9,sp,-76
800080ac:	fe b0 f4 be 	rcall	80006a28 <get_arg>
800080b0:	2f dd       	sub	sp,-12
800080b2:	f8 ea 00 00 	ld.d	r10,r12[0]
800080b6:	c0 c8       	rjmp	800080ce <_vfprintf_r+0x1376>
800080b8:	ee ca ff ff 	sub	r10,r7,-1
800080bc:	10 37       	cp.w	r7,r8
800080be:	c0 b4       	brge	800080d4 <_vfprintf_r+0x137c>
800080c0:	fa c9 f9 44 	sub	r9,sp,-1724
800080c4:	14 97       	mov	r7,r10
800080c6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800080ca:	ec ea fd 88 	ld.d	r10,r6[-632]
800080ce:	fa eb 00 00 	st.d	sp[0],r10
800080d2:	cc e8       	rjmp	8000826e <_vfprintf_r+0x1516>
800080d4:	41 09       	lddsp	r9,sp[0x40]
800080d6:	59 f8       	cp.w	r8,31
800080d8:	e0 89 00 16 	brgt	80008104 <_vfprintf_r+0x13ac>
800080dc:	f2 e6 00 00 	ld.d	r6,r9[0]
800080e0:	f2 cb ff f8 	sub	r11,r9,-8
800080e4:	fa e7 00 00 	st.d	sp[0],r6
800080e8:	51 0b       	stdsp	sp[0x40],r11
800080ea:	fa c6 f9 44 	sub	r6,sp,-1724
800080ee:	ec 08 00 39 	add	r9,r6,r8<<0x3
800080f2:	fa e6 00 00 	ld.d	r6,sp[0]
800080f6:	f2 e7 fd 88 	st.d	r9[-632],r6
800080fa:	2f f8       	sub	r8,-1
800080fc:	14 97       	mov	r7,r10
800080fe:	fb 48 06 b4 	st.w	sp[1716],r8
80008102:	cb 68       	rjmp	8000826e <_vfprintf_r+0x1516>
80008104:	f2 e6 00 00 	ld.d	r6,r9[0]
80008108:	2f 89       	sub	r9,-8
8000810a:	fa e7 00 00 	st.d	sp[0],r6
8000810e:	51 09       	stdsp	sp[0x40],r9
80008110:	14 97       	mov	r7,r10
80008112:	ca e8       	rjmp	8000826e <_vfprintf_r+0x1516>
80008114:	ed b5 00 04 	bld	r5,0x4
80008118:	c1 71       	brne	80008146 <_vfprintf_r+0x13ee>
8000811a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000811e:	40 3e       	lddsp	lr,sp[0xc]
80008120:	58 0e       	cp.w	lr,0
80008122:	c0 80       	breq	80008132 <_vfprintf_r+0x13da>
80008124:	10 36       	cp.w	r6,r8
80008126:	c6 94       	brge	800081f8 <_vfprintf_r+0x14a0>
80008128:	fa cc f9 44 	sub	r12,sp,-1724
8000812c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008130:	c8 28       	rjmp	80008234 <_vfprintf_r+0x14dc>
80008132:	ee ca ff ff 	sub	r10,r7,-1
80008136:	10 37       	cp.w	r7,r8
80008138:	e0 84 00 81 	brge	8000823a <_vfprintf_r+0x14e2>
8000813c:	fa cb f9 44 	sub	r11,sp,-1724
80008140:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008144:	c7 78       	rjmp	80008232 <_vfprintf_r+0x14da>
80008146:	ed b5 00 06 	bld	r5,0x6
8000814a:	c4 b1       	brne	800081e0 <_vfprintf_r+0x1488>
8000814c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008150:	40 3c       	lddsp	r12,sp[0xc]
80008152:	58 0c       	cp.w	r12,0
80008154:	c1 d0       	breq	8000818e <_vfprintf_r+0x1436>
80008156:	10 36       	cp.w	r6,r8
80008158:	c0 64       	brge	80008164 <_vfprintf_r+0x140c>
8000815a:	fa cb f9 44 	sub	r11,sp,-1724
8000815e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008162:	c1 f8       	rjmp	800081a0 <_vfprintf_r+0x1448>
80008164:	fa c8 f9 50 	sub	r8,sp,-1712
80008168:	1a d8       	st.w	--sp,r8
8000816a:	fa c8 fa b8 	sub	r8,sp,-1352
8000816e:	1a d8       	st.w	--sp,r8
80008170:	fa c8 fb b4 	sub	r8,sp,-1100
80008174:	1a d8       	st.w	--sp,r8
80008176:	fa c8 f9 40 	sub	r8,sp,-1728
8000817a:	fa c9 ff b4 	sub	r9,sp,-76
8000817e:	04 9a       	mov	r10,r2
80008180:	0c 9b       	mov	r11,r6
80008182:	08 9c       	mov	r12,r4
80008184:	fe b0 f4 52 	rcall	80006a28 <get_arg>
80008188:	2f dd       	sub	sp,-12
8000818a:	98 18       	ld.sh	r8,r12[0x2]
8000818c:	c2 78       	rjmp	800081da <_vfprintf_r+0x1482>
8000818e:	ee ca ff ff 	sub	r10,r7,-1
80008192:	10 37       	cp.w	r7,r8
80008194:	c0 a4       	brge	800081a8 <_vfprintf_r+0x1450>
80008196:	fa c9 f9 44 	sub	r9,sp,-1724
8000819a:	14 97       	mov	r7,r10
8000819c:	f2 06 00 36 	add	r6,r9,r6<<0x3
800081a0:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800081a4:	c1 b8       	rjmp	800081da <_vfprintf_r+0x1482>
800081a6:	d7 03       	nop
800081a8:	41 09       	lddsp	r9,sp[0x40]
800081aa:	59 f8       	cp.w	r8,31
800081ac:	e0 89 00 13 	brgt	800081d2 <_vfprintf_r+0x147a>
800081b0:	f2 cb ff fc 	sub	r11,r9,-4
800081b4:	51 0b       	stdsp	sp[0x40],r11
800081b6:	72 09       	ld.w	r9,r9[0x0]
800081b8:	fa c6 f9 44 	sub	r6,sp,-1724
800081bc:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800081c0:	2f f8       	sub	r8,-1
800081c2:	f7 49 fd 88 	st.w	r11[-632],r9
800081c6:	fb 48 06 b4 	st.w	sp[1716],r8
800081ca:	14 97       	mov	r7,r10
800081cc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800081d0:	c0 58       	rjmp	800081da <_vfprintf_r+0x1482>
800081d2:	92 18       	ld.sh	r8,r9[0x2]
800081d4:	14 97       	mov	r7,r10
800081d6:	2f c9       	sub	r9,-4
800081d8:	51 09       	stdsp	sp[0x40],r9
800081da:	5c 78       	castu.h	r8
800081dc:	50 18       	stdsp	sp[0x4],r8
800081de:	c4 68       	rjmp	8000826a <_vfprintf_r+0x1512>
800081e0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081e4:	40 3c       	lddsp	r12,sp[0xc]
800081e6:	58 0c       	cp.w	r12,0
800081e8:	c1 d0       	breq	80008222 <_vfprintf_r+0x14ca>
800081ea:	10 36       	cp.w	r6,r8
800081ec:	c0 64       	brge	800081f8 <_vfprintf_r+0x14a0>
800081ee:	fa cb f9 44 	sub	r11,sp,-1724
800081f2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081f6:	c1 f8       	rjmp	80008234 <_vfprintf_r+0x14dc>
800081f8:	fa c8 f9 50 	sub	r8,sp,-1712
800081fc:	1a d8       	st.w	--sp,r8
800081fe:	fa c8 fa b8 	sub	r8,sp,-1352
80008202:	0c 9b       	mov	r11,r6
80008204:	1a d8       	st.w	--sp,r8
80008206:	fa c8 fb b4 	sub	r8,sp,-1100
8000820a:	04 9a       	mov	r10,r2
8000820c:	1a d8       	st.w	--sp,r8
8000820e:	08 9c       	mov	r12,r4
80008210:	fa c8 f9 40 	sub	r8,sp,-1728
80008214:	fa c9 ff b4 	sub	r9,sp,-76
80008218:	fe b0 f4 08 	rcall	80006a28 <get_arg>
8000821c:	2f dd       	sub	sp,-12
8000821e:	78 0b       	ld.w	r11,r12[0x0]
80008220:	c2 48       	rjmp	80008268 <_vfprintf_r+0x1510>
80008222:	ee ca ff ff 	sub	r10,r7,-1
80008226:	10 37       	cp.w	r7,r8
80008228:	c0 94       	brge	8000823a <_vfprintf_r+0x14e2>
8000822a:	fa c9 f9 44 	sub	r9,sp,-1724
8000822e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008232:	14 97       	mov	r7,r10
80008234:	ec fb fd 88 	ld.w	r11,r6[-632]
80008238:	c1 88       	rjmp	80008268 <_vfprintf_r+0x1510>
8000823a:	41 09       	lddsp	r9,sp[0x40]
8000823c:	59 f8       	cp.w	r8,31
8000823e:	e0 89 00 11 	brgt	80008260 <_vfprintf_r+0x1508>
80008242:	f2 cb ff fc 	sub	r11,r9,-4
80008246:	51 0b       	stdsp	sp[0x40],r11
80008248:	fa c6 f9 44 	sub	r6,sp,-1724
8000824c:	72 0b       	ld.w	r11,r9[0x0]
8000824e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008252:	f3 4b fd 88 	st.w	r9[-632],r11
80008256:	2f f8       	sub	r8,-1
80008258:	14 97       	mov	r7,r10
8000825a:	fb 48 06 b4 	st.w	sp[1716],r8
8000825e:	c0 58       	rjmp	80008268 <_vfprintf_r+0x1510>
80008260:	72 0b       	ld.w	r11,r9[0x0]
80008262:	14 97       	mov	r7,r10
80008264:	2f c9       	sub	r9,-4
80008266:	51 09       	stdsp	sp[0x40],r9
80008268:	50 1b       	stdsp	sp[0x4],r11
8000826a:	30 0e       	mov	lr,0
8000826c:	50 0e       	stdsp	sp[0x0],lr
8000826e:	40 08       	lddsp	r8,sp[0x0]
80008270:	40 1c       	lddsp	r12,sp[0x4]
80008272:	18 48       	or	r8,r12
80008274:	5f 19       	srne	r9
80008276:	0a 98       	mov	r8,r5
80008278:	eb e9 00 09 	and	r9,r5,r9
8000827c:	a1 b8       	sbr	r8,0x1
8000827e:	58 09       	cp.w	r9,0
80008280:	c0 70       	breq	8000828e <_vfprintf_r+0x1536>
80008282:	10 95       	mov	r5,r8
80008284:	fb 60 06 b9 	st.b	sp[1721],r0
80008288:	33 08       	mov	r8,48
8000828a:	fb 68 06 b8 	st.b	sp[1720],r8
8000828e:	30 28       	mov	r8,2
80008290:	30 09       	mov	r9,0
80008292:	fb 69 06 bb 	st.b	sp[1723],r9
80008296:	0a 99       	mov	r9,r5
80008298:	a7 d9       	cbr	r9,0x7
8000829a:	40 2b       	lddsp	r11,sp[0x8]
8000829c:	40 16       	lddsp	r6,sp[0x4]
8000829e:	58 0b       	cp.w	r11,0
800082a0:	5f 1a       	srne	r10
800082a2:	f2 05 17 40 	movge	r5,r9
800082a6:	fa c2 f9 78 	sub	r2,sp,-1672
800082aa:	40 09       	lddsp	r9,sp[0x0]
800082ac:	0c 49       	or	r9,r6
800082ae:	5f 19       	srne	r9
800082b0:	f5 e9 10 09 	or	r9,r10,r9
800082b4:	c5 c0       	breq	8000836c <_vfprintf_r+0x1614>
800082b6:	30 19       	mov	r9,1
800082b8:	f2 08 18 00 	cp.b	r8,r9
800082bc:	c0 60       	breq	800082c8 <_vfprintf_r+0x1570>
800082be:	30 29       	mov	r9,2
800082c0:	f2 08 18 00 	cp.b	r8,r9
800082c4:	c0 41       	brne	800082cc <_vfprintf_r+0x1574>
800082c6:	c3 c8       	rjmp	8000833e <_vfprintf_r+0x15e6>
800082c8:	04 96       	mov	r6,r2
800082ca:	c3 08       	rjmp	8000832a <_vfprintf_r+0x15d2>
800082cc:	04 96       	mov	r6,r2
800082ce:	fa e8 00 00 	ld.d	r8,sp[0]
800082d2:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800082d6:	2d 0a       	sub	r10,-48
800082d8:	0c fa       	st.b	--r6,r10
800082da:	f0 0b 16 03 	lsr	r11,r8,0x3
800082de:	f2 0c 16 03 	lsr	r12,r9,0x3
800082e2:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800082e6:	18 99       	mov	r9,r12
800082e8:	16 98       	mov	r8,r11
800082ea:	58 08       	cp.w	r8,0
800082ec:	5c 29       	cpc	r9
800082ee:	cf 21       	brne	800082d2 <_vfprintf_r+0x157a>
800082f0:	fa e9 00 00 	st.d	sp[0],r8
800082f4:	ed b5 00 00 	bld	r5,0x0
800082f8:	c4 51       	brne	80008382 <_vfprintf_r+0x162a>
800082fa:	33 09       	mov	r9,48
800082fc:	f2 0a 18 00 	cp.b	r10,r9
80008300:	c4 10       	breq	80008382 <_vfprintf_r+0x162a>
80008302:	0c f9       	st.b	--r6,r9
80008304:	c3 f8       	rjmp	80008382 <_vfprintf_r+0x162a>
80008306:	fa ea 00 00 	ld.d	r10,sp[0]
8000830a:	30 a8       	mov	r8,10
8000830c:	30 09       	mov	r9,0
8000830e:	e0 a0 1a 0d 	rcall	8000b728 <__avr32_umod64>
80008312:	30 a8       	mov	r8,10
80008314:	2d 0a       	sub	r10,-48
80008316:	30 09       	mov	r9,0
80008318:	ac 8a       	st.b	r6[0x0],r10
8000831a:	fa ea 00 00 	ld.d	r10,sp[0]
8000831e:	e0 a0 18 d3 	rcall	8000b4c4 <__avr32_udiv64>
80008322:	16 99       	mov	r9,r11
80008324:	14 98       	mov	r8,r10
80008326:	fa e9 00 00 	st.d	sp[0],r8
8000832a:	20 16       	sub	r6,1
8000832c:	fa ea 00 00 	ld.d	r10,sp[0]
80008330:	58 9a       	cp.w	r10,9
80008332:	5c 2b       	cpc	r11
80008334:	fe 9b ff e9 	brhi	80008306 <_vfprintf_r+0x15ae>
80008338:	1b f8       	ld.ub	r8,sp[0x7]
8000833a:	2d 08       	sub	r8,-48
8000833c:	c2 08       	rjmp	8000837c <_vfprintf_r+0x1624>
8000833e:	04 96       	mov	r6,r2
80008340:	fa e8 00 00 	ld.d	r8,sp[0]
80008344:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008348:	40 de       	lddsp	lr,sp[0x34]
8000834a:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000834e:	0c fa       	st.b	--r6,r10
80008350:	f2 0b 16 04 	lsr	r11,r9,0x4
80008354:	f0 0a 16 04 	lsr	r10,r8,0x4
80008358:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000835c:	16 99       	mov	r9,r11
8000835e:	14 98       	mov	r8,r10
80008360:	58 08       	cp.w	r8,0
80008362:	5c 29       	cpc	r9
80008364:	cf 01       	brne	80008344 <_vfprintf_r+0x15ec>
80008366:	fa e9 00 00 	st.d	sp[0],r8
8000836a:	c0 c8       	rjmp	80008382 <_vfprintf_r+0x162a>
8000836c:	58 08       	cp.w	r8,0
8000836e:	c0 91       	brne	80008380 <_vfprintf_r+0x1628>
80008370:	ed b5 00 00 	bld	r5,0x0
80008374:	c0 61       	brne	80008380 <_vfprintf_r+0x1628>
80008376:	fa c6 f9 79 	sub	r6,sp,-1671
8000837a:	33 08       	mov	r8,48
8000837c:	ac 88       	st.b	r6[0x0],r8
8000837e:	c0 28       	rjmp	80008382 <_vfprintf_r+0x162a>
80008380:	04 96       	mov	r6,r2
80008382:	0c 12       	sub	r2,r6
80008384:	c1 c8       	rjmp	800083bc <_vfprintf_r+0x1664>
80008386:	50 a7       	stdsp	sp[0x28],r7
80008388:	50 80       	stdsp	sp[0x20],r0
8000838a:	40 93       	lddsp	r3,sp[0x24]
8000838c:	0c 97       	mov	r7,r6
8000838e:	10 90       	mov	r0,r8
80008390:	04 94       	mov	r4,r2
80008392:	40 41       	lddsp	r1,sp[0x10]
80008394:	58 08       	cp.w	r8,0
80008396:	e0 80 04 4f 	breq	80008c34 <_vfprintf_r+0x1edc>
8000839a:	fb 68 06 60 	st.b	sp[1632],r8
8000839e:	30 0c       	mov	r12,0
800083a0:	30 08       	mov	r8,0
800083a2:	30 12       	mov	r2,1
800083a4:	fb 68 06 bb 	st.b	sp[1723],r8
800083a8:	50 2c       	stdsp	sp[0x8],r12
800083aa:	fa c6 f9 a0 	sub	r6,sp,-1632
800083ae:	c0 78       	rjmp	800083bc <_vfprintf_r+0x1664>
800083b0:	30 0b       	mov	r11,0
800083b2:	50 2b       	stdsp	sp[0x8],r11
800083b4:	c0 48       	rjmp	800083bc <_vfprintf_r+0x1664>
800083b6:	40 22       	lddsp	r2,sp[0x8]
800083b8:	30 0a       	mov	r10,0
800083ba:	50 2a       	stdsp	sp[0x8],r10
800083bc:	40 29       	lddsp	r9,sp[0x8]
800083be:	e4 09 0c 49 	max	r9,r2,r9
800083c2:	fb 38 06 bb 	ld.ub	r8,sp[1723]
800083c6:	50 39       	stdsp	sp[0xc],r9
800083c8:	0a 9e       	mov	lr,r5
800083ca:	30 09       	mov	r9,0
800083cc:	e2 1e 00 02 	andl	lr,0x2,COH
800083d0:	f2 08 18 00 	cp.b	r8,r9
800083d4:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800083d8:	f7 b8 01 ff 	subne	r8,-1
800083dc:	fb f8 1a 03 	st.wne	sp[0xc],r8
800083e0:	0a 9b       	mov	r11,r5
800083e2:	58 0e       	cp.w	lr,0
800083e4:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800083e8:	f7 bc 01 fe 	subne	r12,-2
800083ec:	fb fc 1a 03 	st.wne	sp[0xc],r12
800083f0:	e2 1b 00 84 	andl	r11,0x84,COH
800083f4:	50 fe       	stdsp	sp[0x3c],lr
800083f6:	50 9b       	stdsp	sp[0x24],r11
800083f8:	c4 71       	brne	80008486 <_vfprintf_r+0x172e>
800083fa:	40 8a       	lddsp	r10,sp[0x20]
800083fc:	40 39       	lddsp	r9,sp[0xc]
800083fe:	12 1a       	sub	r10,r9
80008400:	50 4a       	stdsp	sp[0x10],r10
80008402:	58 0a       	cp.w	r10,0
80008404:	e0 89 00 20 	brgt	80008444 <_vfprintf_r+0x16ec>
80008408:	c3 f8       	rjmp	80008486 <_vfprintf_r+0x172e>
8000840a:	2f 09       	sub	r9,-16
8000840c:	2f f8       	sub	r8,-1
8000840e:	fe ce b9 32 	sub	lr,pc,-18126
80008412:	31 0c       	mov	r12,16
80008414:	fb 49 06 90 	st.w	sp[1680],r9
80008418:	87 0e       	st.w	r3[0x0],lr
8000841a:	87 1c       	st.w	r3[0x4],r12
8000841c:	fb 48 06 8c 	st.w	sp[1676],r8
80008420:	58 78       	cp.w	r8,7
80008422:	e0 89 00 04 	brgt	8000842a <_vfprintf_r+0x16d2>
80008426:	2f 83       	sub	r3,-8
80008428:	c0 b8       	rjmp	8000843e <_vfprintf_r+0x16e6>
8000842a:	fa ca f9 78 	sub	r10,sp,-1672
8000842e:	02 9b       	mov	r11,r1
80008430:	08 9c       	mov	r12,r4
80008432:	fe b0 f4 85 	rcall	80006d3c <__sprint_r>
80008436:	e0 81 04 10 	brne	80008c56 <_vfprintf_r+0x1efe>
8000843a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000843e:	40 4b       	lddsp	r11,sp[0x10]
80008440:	21 0b       	sub	r11,16
80008442:	50 4b       	stdsp	sp[0x10],r11
80008444:	fa f9 06 90 	ld.w	r9,sp[1680]
80008448:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000844c:	fe ca b9 70 	sub	r10,pc,-18064
80008450:	40 4e       	lddsp	lr,sp[0x10]
80008452:	59 0e       	cp.w	lr,16
80008454:	fe 99 ff db 	brgt	8000840a <_vfprintf_r+0x16b2>
80008458:	1c 09       	add	r9,lr
8000845a:	2f f8       	sub	r8,-1
8000845c:	87 0a       	st.w	r3[0x0],r10
8000845e:	fb 49 06 90 	st.w	sp[1680],r9
80008462:	87 1e       	st.w	r3[0x4],lr
80008464:	fb 48 06 8c 	st.w	sp[1676],r8
80008468:	58 78       	cp.w	r8,7
8000846a:	e0 89 00 04 	brgt	80008472 <_vfprintf_r+0x171a>
8000846e:	2f 83       	sub	r3,-8
80008470:	c0 b8       	rjmp	80008486 <_vfprintf_r+0x172e>
80008472:	fa ca f9 78 	sub	r10,sp,-1672
80008476:	02 9b       	mov	r11,r1
80008478:	08 9c       	mov	r12,r4
8000847a:	fe b0 f4 61 	rcall	80006d3c <__sprint_r>
8000847e:	e0 81 03 ec 	brne	80008c56 <_vfprintf_r+0x1efe>
80008482:	fa c3 f9 e0 	sub	r3,sp,-1568
80008486:	30 09       	mov	r9,0
80008488:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000848c:	f2 08 18 00 	cp.b	r8,r9
80008490:	c1 f0       	breq	800084ce <_vfprintf_r+0x1776>
80008492:	fa f8 06 90 	ld.w	r8,sp[1680]
80008496:	fa c9 f9 45 	sub	r9,sp,-1723
8000849a:	2f f8       	sub	r8,-1
8000849c:	87 09       	st.w	r3[0x0],r9
8000849e:	fb 48 06 90 	st.w	sp[1680],r8
800084a2:	30 19       	mov	r9,1
800084a4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800084a8:	87 19       	st.w	r3[0x4],r9
800084aa:	2f f8       	sub	r8,-1
800084ac:	fb 48 06 8c 	st.w	sp[1676],r8
800084b0:	58 78       	cp.w	r8,7
800084b2:	e0 89 00 04 	brgt	800084ba <_vfprintf_r+0x1762>
800084b6:	2f 83       	sub	r3,-8
800084b8:	c0 b8       	rjmp	800084ce <_vfprintf_r+0x1776>
800084ba:	fa ca f9 78 	sub	r10,sp,-1672
800084be:	02 9b       	mov	r11,r1
800084c0:	08 9c       	mov	r12,r4
800084c2:	fe b0 f4 3d 	rcall	80006d3c <__sprint_r>
800084c6:	e0 81 03 c8 	brne	80008c56 <_vfprintf_r+0x1efe>
800084ca:	fa c3 f9 e0 	sub	r3,sp,-1568
800084ce:	40 fc       	lddsp	r12,sp[0x3c]
800084d0:	58 0c       	cp.w	r12,0
800084d2:	c1 f0       	breq	80008510 <_vfprintf_r+0x17b8>
800084d4:	fa f8 06 90 	ld.w	r8,sp[1680]
800084d8:	fa c9 f9 48 	sub	r9,sp,-1720
800084dc:	2f e8       	sub	r8,-2
800084de:	87 09       	st.w	r3[0x0],r9
800084e0:	fb 48 06 90 	st.w	sp[1680],r8
800084e4:	30 29       	mov	r9,2
800084e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800084ea:	87 19       	st.w	r3[0x4],r9
800084ec:	2f f8       	sub	r8,-1
800084ee:	fb 48 06 8c 	st.w	sp[1676],r8
800084f2:	58 78       	cp.w	r8,7
800084f4:	e0 89 00 04 	brgt	800084fc <_vfprintf_r+0x17a4>
800084f8:	2f 83       	sub	r3,-8
800084fa:	c0 b8       	rjmp	80008510 <_vfprintf_r+0x17b8>
800084fc:	fa ca f9 78 	sub	r10,sp,-1672
80008500:	02 9b       	mov	r11,r1
80008502:	08 9c       	mov	r12,r4
80008504:	fe b0 f4 1c 	rcall	80006d3c <__sprint_r>
80008508:	e0 81 03 a7 	brne	80008c56 <_vfprintf_r+0x1efe>
8000850c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008510:	40 9b       	lddsp	r11,sp[0x24]
80008512:	e0 4b 00 80 	cp.w	r11,128
80008516:	c4 71       	brne	800085a4 <_vfprintf_r+0x184c>
80008518:	40 8a       	lddsp	r10,sp[0x20]
8000851a:	40 39       	lddsp	r9,sp[0xc]
8000851c:	12 1a       	sub	r10,r9
8000851e:	50 4a       	stdsp	sp[0x10],r10
80008520:	58 0a       	cp.w	r10,0
80008522:	e0 89 00 20 	brgt	80008562 <_vfprintf_r+0x180a>
80008526:	c3 f8       	rjmp	800085a4 <_vfprintf_r+0x184c>
80008528:	2f 09       	sub	r9,-16
8000852a:	2f f8       	sub	r8,-1
8000852c:	fe ce ba 40 	sub	lr,pc,-17856
80008530:	31 0c       	mov	r12,16
80008532:	fb 49 06 90 	st.w	sp[1680],r9
80008536:	87 0e       	st.w	r3[0x0],lr
80008538:	87 1c       	st.w	r3[0x4],r12
8000853a:	fb 48 06 8c 	st.w	sp[1676],r8
8000853e:	58 78       	cp.w	r8,7
80008540:	e0 89 00 04 	brgt	80008548 <_vfprintf_r+0x17f0>
80008544:	2f 83       	sub	r3,-8
80008546:	c0 b8       	rjmp	8000855c <_vfprintf_r+0x1804>
80008548:	fa ca f9 78 	sub	r10,sp,-1672
8000854c:	02 9b       	mov	r11,r1
8000854e:	08 9c       	mov	r12,r4
80008550:	fe b0 f3 f6 	rcall	80006d3c <__sprint_r>
80008554:	e0 81 03 81 	brne	80008c56 <_vfprintf_r+0x1efe>
80008558:	fa c3 f9 e0 	sub	r3,sp,-1568
8000855c:	40 4b       	lddsp	r11,sp[0x10]
8000855e:	21 0b       	sub	r11,16
80008560:	50 4b       	stdsp	sp[0x10],r11
80008562:	fa f9 06 90 	ld.w	r9,sp[1680]
80008566:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000856a:	fe ca ba 7e 	sub	r10,pc,-17794
8000856e:	40 4e       	lddsp	lr,sp[0x10]
80008570:	59 0e       	cp.w	lr,16
80008572:	fe 99 ff db 	brgt	80008528 <_vfprintf_r+0x17d0>
80008576:	1c 09       	add	r9,lr
80008578:	2f f8       	sub	r8,-1
8000857a:	87 0a       	st.w	r3[0x0],r10
8000857c:	fb 49 06 90 	st.w	sp[1680],r9
80008580:	87 1e       	st.w	r3[0x4],lr
80008582:	fb 48 06 8c 	st.w	sp[1676],r8
80008586:	58 78       	cp.w	r8,7
80008588:	e0 89 00 04 	brgt	80008590 <_vfprintf_r+0x1838>
8000858c:	2f 83       	sub	r3,-8
8000858e:	c0 b8       	rjmp	800085a4 <_vfprintf_r+0x184c>
80008590:	fa ca f9 78 	sub	r10,sp,-1672
80008594:	02 9b       	mov	r11,r1
80008596:	08 9c       	mov	r12,r4
80008598:	fe b0 f3 d2 	rcall	80006d3c <__sprint_r>
8000859c:	e0 81 03 5d 	brne	80008c56 <_vfprintf_r+0x1efe>
800085a0:	fa c3 f9 e0 	sub	r3,sp,-1568
800085a4:	40 2c       	lddsp	r12,sp[0x8]
800085a6:	04 1c       	sub	r12,r2
800085a8:	50 2c       	stdsp	sp[0x8],r12
800085aa:	58 0c       	cp.w	r12,0
800085ac:	e0 89 00 20 	brgt	800085ec <_vfprintf_r+0x1894>
800085b0:	c3 f8       	rjmp	8000862e <_vfprintf_r+0x18d6>
800085b2:	2f 09       	sub	r9,-16
800085b4:	2f f8       	sub	r8,-1
800085b6:	fe cb ba ca 	sub	r11,pc,-17718
800085ba:	31 0a       	mov	r10,16
800085bc:	fb 49 06 90 	st.w	sp[1680],r9
800085c0:	87 0b       	st.w	r3[0x0],r11
800085c2:	87 1a       	st.w	r3[0x4],r10
800085c4:	fb 48 06 8c 	st.w	sp[1676],r8
800085c8:	58 78       	cp.w	r8,7
800085ca:	e0 89 00 04 	brgt	800085d2 <_vfprintf_r+0x187a>
800085ce:	2f 83       	sub	r3,-8
800085d0:	c0 b8       	rjmp	800085e6 <_vfprintf_r+0x188e>
800085d2:	fa ca f9 78 	sub	r10,sp,-1672
800085d6:	02 9b       	mov	r11,r1
800085d8:	08 9c       	mov	r12,r4
800085da:	fe b0 f3 b1 	rcall	80006d3c <__sprint_r>
800085de:	e0 81 03 3c 	brne	80008c56 <_vfprintf_r+0x1efe>
800085e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800085e6:	40 29       	lddsp	r9,sp[0x8]
800085e8:	21 09       	sub	r9,16
800085ea:	50 29       	stdsp	sp[0x8],r9
800085ec:	fa f9 06 90 	ld.w	r9,sp[1680]
800085f0:	fa f8 06 8c 	ld.w	r8,sp[1676]
800085f4:	fe ca bb 08 	sub	r10,pc,-17656
800085f8:	40 2e       	lddsp	lr,sp[0x8]
800085fa:	59 0e       	cp.w	lr,16
800085fc:	fe 99 ff db 	brgt	800085b2 <_vfprintf_r+0x185a>
80008600:	1c 09       	add	r9,lr
80008602:	2f f8       	sub	r8,-1
80008604:	87 0a       	st.w	r3[0x0],r10
80008606:	fb 49 06 90 	st.w	sp[1680],r9
8000860a:	87 1e       	st.w	r3[0x4],lr
8000860c:	fb 48 06 8c 	st.w	sp[1676],r8
80008610:	58 78       	cp.w	r8,7
80008612:	e0 89 00 04 	brgt	8000861a <_vfprintf_r+0x18c2>
80008616:	2f 83       	sub	r3,-8
80008618:	c0 b8       	rjmp	8000862e <_vfprintf_r+0x18d6>
8000861a:	fa ca f9 78 	sub	r10,sp,-1672
8000861e:	02 9b       	mov	r11,r1
80008620:	08 9c       	mov	r12,r4
80008622:	fe b0 f3 8d 	rcall	80006d3c <__sprint_r>
80008626:	e0 81 03 18 	brne	80008c56 <_vfprintf_r+0x1efe>
8000862a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000862e:	ed b5 00 08 	bld	r5,0x8
80008632:	c0 b0       	breq	80008648 <_vfprintf_r+0x18f0>
80008634:	fa f8 06 90 	ld.w	r8,sp[1680]
80008638:	87 12       	st.w	r3[0x4],r2
8000863a:	87 06       	st.w	r3[0x0],r6
8000863c:	f0 02 00 02 	add	r2,r8,r2
80008640:	fb 42 06 90 	st.w	sp[1680],r2
80008644:	e0 8f 01 d4 	bral	800089ec <_vfprintf_r+0x1c94>
80008648:	e0 40 00 65 	cp.w	r0,101
8000864c:	e0 8a 01 d6 	brle	800089f8 <_vfprintf_r+0x1ca0>
80008650:	30 08       	mov	r8,0
80008652:	30 09       	mov	r9,0
80008654:	40 5b       	lddsp	r11,sp[0x14]
80008656:	40 7a       	lddsp	r10,sp[0x1c]
80008658:	e0 a0 15 2f 	rcall	8000b0b6 <__avr32_f64_cmp_eq>
8000865c:	c7 90       	breq	8000874e <_vfprintf_r+0x19f6>
8000865e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008662:	fe c9 bb 8a 	sub	r9,pc,-17526
80008666:	2f f8       	sub	r8,-1
80008668:	87 09       	st.w	r3[0x0],r9
8000866a:	fb 48 06 90 	st.w	sp[1680],r8
8000866e:	30 19       	mov	r9,1
80008670:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008674:	87 19       	st.w	r3[0x4],r9
80008676:	2f f8       	sub	r8,-1
80008678:	fb 48 06 8c 	st.w	sp[1676],r8
8000867c:	58 78       	cp.w	r8,7
8000867e:	e0 89 00 05 	brgt	80008688 <_vfprintf_r+0x1930>
80008682:	2f 83       	sub	r3,-8
80008684:	c0 c8       	rjmp	8000869c <_vfprintf_r+0x1944>
80008686:	d7 03       	nop
80008688:	fa ca f9 78 	sub	r10,sp,-1672
8000868c:	02 9b       	mov	r11,r1
8000868e:	08 9c       	mov	r12,r4
80008690:	fe b0 f3 56 	rcall	80006d3c <__sprint_r>
80008694:	e0 81 02 e1 	brne	80008c56 <_vfprintf_r+0x1efe>
80008698:	fa c3 f9 e0 	sub	r3,sp,-1568
8000869c:	fa f8 06 ac 	ld.w	r8,sp[1708]
800086a0:	40 6c       	lddsp	r12,sp[0x18]
800086a2:	18 38       	cp.w	r8,r12
800086a4:	c0 55       	brlt	800086ae <_vfprintf_r+0x1956>
800086a6:	ed b5 00 00 	bld	r5,0x0
800086aa:	e0 81 02 6b 	brne	80008b80 <_vfprintf_r+0x1e28>
800086ae:	fa f8 06 90 	ld.w	r8,sp[1680]
800086b2:	2f f8       	sub	r8,-1
800086b4:	40 cb       	lddsp	r11,sp[0x30]
800086b6:	fb 48 06 90 	st.w	sp[1680],r8
800086ba:	30 19       	mov	r9,1
800086bc:	fa f8 06 8c 	ld.w	r8,sp[1676]
800086c0:	87 0b       	st.w	r3[0x0],r11
800086c2:	2f f8       	sub	r8,-1
800086c4:	87 19       	st.w	r3[0x4],r9
800086c6:	fb 48 06 8c 	st.w	sp[1676],r8
800086ca:	58 78       	cp.w	r8,7
800086cc:	e0 89 00 04 	brgt	800086d4 <_vfprintf_r+0x197c>
800086d0:	2f 83       	sub	r3,-8
800086d2:	c0 b8       	rjmp	800086e8 <_vfprintf_r+0x1990>
800086d4:	fa ca f9 78 	sub	r10,sp,-1672
800086d8:	02 9b       	mov	r11,r1
800086da:	08 9c       	mov	r12,r4
800086dc:	fe b0 f3 30 	rcall	80006d3c <__sprint_r>
800086e0:	e0 81 02 bb 	brne	80008c56 <_vfprintf_r+0x1efe>
800086e4:	fa c3 f9 e0 	sub	r3,sp,-1568
800086e8:	40 66       	lddsp	r6,sp[0x18]
800086ea:	20 16       	sub	r6,1
800086ec:	58 06       	cp.w	r6,0
800086ee:	e0 89 00 1d 	brgt	80008728 <_vfprintf_r+0x19d0>
800086f2:	e0 8f 02 47 	bral	80008b80 <_vfprintf_r+0x1e28>
800086f6:	2f 09       	sub	r9,-16
800086f8:	2f f8       	sub	r8,-1
800086fa:	fb 49 06 90 	st.w	sp[1680],r9
800086fe:	87 02       	st.w	r3[0x0],r2
80008700:	87 10       	st.w	r3[0x4],r0
80008702:	fb 48 06 8c 	st.w	sp[1676],r8
80008706:	58 78       	cp.w	r8,7
80008708:	e0 89 00 04 	brgt	80008710 <_vfprintf_r+0x19b8>
8000870c:	2f 83       	sub	r3,-8
8000870e:	c0 b8       	rjmp	80008724 <_vfprintf_r+0x19cc>
80008710:	fa ca f9 78 	sub	r10,sp,-1672
80008714:	02 9b       	mov	r11,r1
80008716:	08 9c       	mov	r12,r4
80008718:	fe b0 f3 12 	rcall	80006d3c <__sprint_r>
8000871c:	e0 81 02 9d 	brne	80008c56 <_vfprintf_r+0x1efe>
80008720:	fa c3 f9 e0 	sub	r3,sp,-1568
80008724:	21 06       	sub	r6,16
80008726:	c0 48       	rjmp	8000872e <_vfprintf_r+0x19d6>
80008728:	fe c2 bc 3c 	sub	r2,pc,-17348
8000872c:	31 00       	mov	r0,16
8000872e:	fa f9 06 90 	ld.w	r9,sp[1680]
80008732:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008736:	fe ca bc 4a 	sub	r10,pc,-17334
8000873a:	59 06       	cp.w	r6,16
8000873c:	fe 99 ff dd 	brgt	800086f6 <_vfprintf_r+0x199e>
80008740:	0c 09       	add	r9,r6
80008742:	87 0a       	st.w	r3[0x0],r10
80008744:	fb 49 06 90 	st.w	sp[1680],r9
80008748:	2f f8       	sub	r8,-1
8000874a:	87 16       	st.w	r3[0x4],r6
8000874c:	c5 39       	rjmp	800089f2 <_vfprintf_r+0x1c9a>
8000874e:	fa fa 06 ac 	ld.w	r10,sp[1708]
80008752:	58 0a       	cp.w	r10,0
80008754:	e0 89 00 92 	brgt	80008878 <_vfprintf_r+0x1b20>
80008758:	fa f8 06 90 	ld.w	r8,sp[1680]
8000875c:	fe c9 bc 84 	sub	r9,pc,-17276
80008760:	2f f8       	sub	r8,-1
80008762:	87 09       	st.w	r3[0x0],r9
80008764:	fb 48 06 90 	st.w	sp[1680],r8
80008768:	30 19       	mov	r9,1
8000876a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000876e:	87 19       	st.w	r3[0x4],r9
80008770:	2f f8       	sub	r8,-1
80008772:	fb 48 06 8c 	st.w	sp[1676],r8
80008776:	58 78       	cp.w	r8,7
80008778:	e0 89 00 04 	brgt	80008780 <_vfprintf_r+0x1a28>
8000877c:	2f 83       	sub	r3,-8
8000877e:	c0 b8       	rjmp	80008794 <_vfprintf_r+0x1a3c>
80008780:	fa ca f9 78 	sub	r10,sp,-1672
80008784:	02 9b       	mov	r11,r1
80008786:	08 9c       	mov	r12,r4
80008788:	fe b0 f2 da 	rcall	80006d3c <__sprint_r>
8000878c:	e0 81 02 65 	brne	80008c56 <_vfprintf_r+0x1efe>
80008790:	fa c3 f9 e0 	sub	r3,sp,-1568
80008794:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008798:	58 08       	cp.w	r8,0
8000879a:	c0 81       	brne	800087aa <_vfprintf_r+0x1a52>
8000879c:	40 6a       	lddsp	r10,sp[0x18]
8000879e:	58 0a       	cp.w	r10,0
800087a0:	c0 51       	brne	800087aa <_vfprintf_r+0x1a52>
800087a2:	ed b5 00 00 	bld	r5,0x0
800087a6:	e0 81 01 ed 	brne	80008b80 <_vfprintf_r+0x1e28>
800087aa:	40 c9       	lddsp	r9,sp[0x30]
800087ac:	fa f8 06 90 	ld.w	r8,sp[1680]
800087b0:	2f f8       	sub	r8,-1
800087b2:	87 09       	st.w	r3[0x0],r9
800087b4:	fb 48 06 90 	st.w	sp[1680],r8
800087b8:	30 19       	mov	r9,1
800087ba:	fa f8 06 8c 	ld.w	r8,sp[1676]
800087be:	87 19       	st.w	r3[0x4],r9
800087c0:	2f f8       	sub	r8,-1
800087c2:	fb 48 06 8c 	st.w	sp[1676],r8
800087c6:	58 78       	cp.w	r8,7
800087c8:	e0 89 00 04 	brgt	800087d0 <_vfprintf_r+0x1a78>
800087cc:	2f 83       	sub	r3,-8
800087ce:	c0 b8       	rjmp	800087e4 <_vfprintf_r+0x1a8c>
800087d0:	fa ca f9 78 	sub	r10,sp,-1672
800087d4:	02 9b       	mov	r11,r1
800087d6:	08 9c       	mov	r12,r4
800087d8:	fe b0 f2 b2 	rcall	80006d3c <__sprint_r>
800087dc:	e0 81 02 3d 	brne	80008c56 <_vfprintf_r+0x1efe>
800087e0:	fa c3 f9 e0 	sub	r3,sp,-1568
800087e4:	fa f2 06 ac 	ld.w	r2,sp[1708]
800087e8:	5c 32       	neg	r2
800087ea:	58 02       	cp.w	r2,0
800087ec:	e0 89 00 1d 	brgt	80008826 <_vfprintf_r+0x1ace>
800087f0:	c3 d8       	rjmp	8000886a <_vfprintf_r+0x1b12>
800087f2:	2f 09       	sub	r9,-16
800087f4:	2f f8       	sub	r8,-1
800087f6:	31 0e       	mov	lr,16
800087f8:	fb 49 06 90 	st.w	sp[1680],r9
800087fc:	87 00       	st.w	r3[0x0],r0
800087fe:	87 1e       	st.w	r3[0x4],lr
80008800:	fb 48 06 8c 	st.w	sp[1676],r8
80008804:	58 78       	cp.w	r8,7
80008806:	e0 89 00 04 	brgt	8000880e <_vfprintf_r+0x1ab6>
8000880a:	2f 83       	sub	r3,-8
8000880c:	c0 b8       	rjmp	80008822 <_vfprintf_r+0x1aca>
8000880e:	fa ca f9 78 	sub	r10,sp,-1672
80008812:	02 9b       	mov	r11,r1
80008814:	08 9c       	mov	r12,r4
80008816:	fe b0 f2 93 	rcall	80006d3c <__sprint_r>
8000881a:	e0 81 02 1e 	brne	80008c56 <_vfprintf_r+0x1efe>
8000881e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008822:	21 02       	sub	r2,16
80008824:	c0 38       	rjmp	8000882a <_vfprintf_r+0x1ad2>
80008826:	fe c0 bd 3a 	sub	r0,pc,-17094
8000882a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000882e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008832:	fe ca bd 46 	sub	r10,pc,-17082
80008836:	59 02       	cp.w	r2,16
80008838:	fe 99 ff dd 	brgt	800087f2 <_vfprintf_r+0x1a9a>
8000883c:	04 09       	add	r9,r2
8000883e:	2f f8       	sub	r8,-1
80008840:	87 0a       	st.w	r3[0x0],r10
80008842:	fb 49 06 90 	st.w	sp[1680],r9
80008846:	87 12       	st.w	r3[0x4],r2
80008848:	fb 48 06 8c 	st.w	sp[1676],r8
8000884c:	58 78       	cp.w	r8,7
8000884e:	e0 89 00 04 	brgt	80008856 <_vfprintf_r+0x1afe>
80008852:	2f 83       	sub	r3,-8
80008854:	c0 b8       	rjmp	8000886a <_vfprintf_r+0x1b12>
80008856:	fa ca f9 78 	sub	r10,sp,-1672
8000885a:	02 9b       	mov	r11,r1
8000885c:	08 9c       	mov	r12,r4
8000885e:	fe b0 f2 6f 	rcall	80006d3c <__sprint_r>
80008862:	e0 81 01 fa 	brne	80008c56 <_vfprintf_r+0x1efe>
80008866:	fa c3 f9 e0 	sub	r3,sp,-1568
8000886a:	40 6c       	lddsp	r12,sp[0x18]
8000886c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008870:	87 06       	st.w	r3[0x0],r6
80008872:	87 1c       	st.w	r3[0x4],r12
80008874:	18 08       	add	r8,r12
80008876:	cb 98       	rjmp	800089e8 <_vfprintf_r+0x1c90>
80008878:	fa f9 06 90 	ld.w	r9,sp[1680]
8000887c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008880:	40 6b       	lddsp	r11,sp[0x18]
80008882:	16 3a       	cp.w	r10,r11
80008884:	c6 f5       	brlt	80008962 <_vfprintf_r+0x1c0a>
80008886:	16 09       	add	r9,r11
80008888:	2f f8       	sub	r8,-1
8000888a:	87 06       	st.w	r3[0x0],r6
8000888c:	fb 49 06 90 	st.w	sp[1680],r9
80008890:	87 1b       	st.w	r3[0x4],r11
80008892:	fb 48 06 8c 	st.w	sp[1676],r8
80008896:	58 78       	cp.w	r8,7
80008898:	e0 89 00 04 	brgt	800088a0 <_vfprintf_r+0x1b48>
8000889c:	2f 83       	sub	r3,-8
8000889e:	c0 b8       	rjmp	800088b4 <_vfprintf_r+0x1b5c>
800088a0:	fa ca f9 78 	sub	r10,sp,-1672
800088a4:	02 9b       	mov	r11,r1
800088a6:	08 9c       	mov	r12,r4
800088a8:	fe b0 f2 4a 	rcall	80006d3c <__sprint_r>
800088ac:	e0 81 01 d5 	brne	80008c56 <_vfprintf_r+0x1efe>
800088b0:	fa c3 f9 e0 	sub	r3,sp,-1568
800088b4:	fa f6 06 ac 	ld.w	r6,sp[1708]
800088b8:	40 6a       	lddsp	r10,sp[0x18]
800088ba:	14 16       	sub	r6,r10
800088bc:	58 06       	cp.w	r6,0
800088be:	e0 89 00 1c 	brgt	800088f6 <_vfprintf_r+0x1b9e>
800088c2:	c3 d8       	rjmp	8000893c <_vfprintf_r+0x1be4>
800088c4:	2f 09       	sub	r9,-16
800088c6:	2f f8       	sub	r8,-1
800088c8:	fb 49 06 90 	st.w	sp[1680],r9
800088cc:	87 02       	st.w	r3[0x0],r2
800088ce:	87 10       	st.w	r3[0x4],r0
800088d0:	fb 48 06 8c 	st.w	sp[1676],r8
800088d4:	58 78       	cp.w	r8,7
800088d6:	e0 89 00 04 	brgt	800088de <_vfprintf_r+0x1b86>
800088da:	2f 83       	sub	r3,-8
800088dc:	c0 b8       	rjmp	800088f2 <_vfprintf_r+0x1b9a>
800088de:	fa ca f9 78 	sub	r10,sp,-1672
800088e2:	02 9b       	mov	r11,r1
800088e4:	08 9c       	mov	r12,r4
800088e6:	fe b0 f2 2b 	rcall	80006d3c <__sprint_r>
800088ea:	e0 81 01 b6 	brne	80008c56 <_vfprintf_r+0x1efe>
800088ee:	fa c3 f9 e0 	sub	r3,sp,-1568
800088f2:	21 06       	sub	r6,16
800088f4:	c0 48       	rjmp	800088fc <_vfprintf_r+0x1ba4>
800088f6:	fe c2 be 0a 	sub	r2,pc,-16886
800088fa:	31 00       	mov	r0,16
800088fc:	fa f9 06 90 	ld.w	r9,sp[1680]
80008900:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008904:	fe ca be 18 	sub	r10,pc,-16872
80008908:	59 06       	cp.w	r6,16
8000890a:	fe 99 ff dd 	brgt	800088c4 <_vfprintf_r+0x1b6c>
8000890e:	0c 09       	add	r9,r6
80008910:	2f f8       	sub	r8,-1
80008912:	87 0a       	st.w	r3[0x0],r10
80008914:	fb 49 06 90 	st.w	sp[1680],r9
80008918:	87 16       	st.w	r3[0x4],r6
8000891a:	fb 48 06 8c 	st.w	sp[1676],r8
8000891e:	58 78       	cp.w	r8,7
80008920:	e0 89 00 04 	brgt	80008928 <_vfprintf_r+0x1bd0>
80008924:	2f 83       	sub	r3,-8
80008926:	c0 b8       	rjmp	8000893c <_vfprintf_r+0x1be4>
80008928:	fa ca f9 78 	sub	r10,sp,-1672
8000892c:	02 9b       	mov	r11,r1
8000892e:	08 9c       	mov	r12,r4
80008930:	fe b0 f2 06 	rcall	80006d3c <__sprint_r>
80008934:	e0 81 01 91 	brne	80008c56 <_vfprintf_r+0x1efe>
80008938:	fa c3 f9 e0 	sub	r3,sp,-1568
8000893c:	ed b5 00 00 	bld	r5,0x0
80008940:	e0 81 01 20 	brne	80008b80 <_vfprintf_r+0x1e28>
80008944:	40 c9       	lddsp	r9,sp[0x30]
80008946:	fa f8 06 90 	ld.w	r8,sp[1680]
8000894a:	2f f8       	sub	r8,-1
8000894c:	87 09       	st.w	r3[0x0],r9
8000894e:	fb 48 06 90 	st.w	sp[1680],r8
80008952:	30 19       	mov	r9,1
80008954:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008958:	87 19       	st.w	r3[0x4],r9
8000895a:	2f f8       	sub	r8,-1
8000895c:	fb 48 06 8c 	st.w	sp[1676],r8
80008960:	c0 29       	rjmp	80008b64 <_vfprintf_r+0x1e0c>
80008962:	14 09       	add	r9,r10
80008964:	2f f8       	sub	r8,-1
80008966:	fb 49 06 90 	st.w	sp[1680],r9
8000896a:	87 06       	st.w	r3[0x0],r6
8000896c:	87 1a       	st.w	r3[0x4],r10
8000896e:	fb 48 06 8c 	st.w	sp[1676],r8
80008972:	58 78       	cp.w	r8,7
80008974:	e0 89 00 04 	brgt	8000897c <_vfprintf_r+0x1c24>
80008978:	2f 83       	sub	r3,-8
8000897a:	c0 b8       	rjmp	80008990 <_vfprintf_r+0x1c38>
8000897c:	fa ca f9 78 	sub	r10,sp,-1672
80008980:	02 9b       	mov	r11,r1
80008982:	08 9c       	mov	r12,r4
80008984:	fe b0 f1 dc 	rcall	80006d3c <__sprint_r>
80008988:	e0 81 01 67 	brne	80008c56 <_vfprintf_r+0x1efe>
8000898c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008990:	40 c8       	lddsp	r8,sp[0x30]
80008992:	87 08       	st.w	r3[0x0],r8
80008994:	fa f8 06 90 	ld.w	r8,sp[1680]
80008998:	2f f8       	sub	r8,-1
8000899a:	30 19       	mov	r9,1
8000899c:	fb 48 06 90 	st.w	sp[1680],r8
800089a0:	87 19       	st.w	r3[0x4],r9
800089a2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089a6:	2f f8       	sub	r8,-1
800089a8:	fb 48 06 8c 	st.w	sp[1676],r8
800089ac:	fa f2 06 ac 	ld.w	r2,sp[1708]
800089b0:	58 78       	cp.w	r8,7
800089b2:	e0 89 00 04 	brgt	800089ba <_vfprintf_r+0x1c62>
800089b6:	2f 83       	sub	r3,-8
800089b8:	c0 b8       	rjmp	800089ce <_vfprintf_r+0x1c76>
800089ba:	fa ca f9 78 	sub	r10,sp,-1672
800089be:	02 9b       	mov	r11,r1
800089c0:	08 9c       	mov	r12,r4
800089c2:	fe b0 f1 bd 	rcall	80006d3c <__sprint_r>
800089c6:	e0 81 01 48 	brne	80008c56 <_vfprintf_r+0x1efe>
800089ca:	fa c3 f9 e0 	sub	r3,sp,-1568
800089ce:	04 06       	add	r6,r2
800089d0:	fa f8 06 ac 	ld.w	r8,sp[1708]
800089d4:	87 06       	st.w	r3[0x0],r6
800089d6:	fa f9 06 90 	ld.w	r9,sp[1680]
800089da:	40 66       	lddsp	r6,sp[0x18]
800089dc:	40 6e       	lddsp	lr,sp[0x18]
800089de:	10 16       	sub	r6,r8
800089e0:	f2 08 01 08 	sub	r8,r9,r8
800089e4:	87 16       	st.w	r3[0x4],r6
800089e6:	1c 08       	add	r8,lr
800089e8:	fb 48 06 90 	st.w	sp[1680],r8
800089ec:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089f0:	2f f8       	sub	r8,-1
800089f2:	fb 48 06 8c 	st.w	sp[1676],r8
800089f6:	cb 78       	rjmp	80008b64 <_vfprintf_r+0x1e0c>
800089f8:	40 6c       	lddsp	r12,sp[0x18]
800089fa:	58 1c       	cp.w	r12,1
800089fc:	e0 89 00 06 	brgt	80008a08 <_vfprintf_r+0x1cb0>
80008a00:	ed b5 00 00 	bld	r5,0x0
80008a04:	e0 81 00 85 	brne	80008b0e <_vfprintf_r+0x1db6>
80008a08:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a0c:	2f f8       	sub	r8,-1
80008a0e:	30 19       	mov	r9,1
80008a10:	fb 48 06 90 	st.w	sp[1680],r8
80008a14:	87 06       	st.w	r3[0x0],r6
80008a16:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a1a:	87 19       	st.w	r3[0x4],r9
80008a1c:	2f f8       	sub	r8,-1
80008a1e:	fb 48 06 8c 	st.w	sp[1676],r8
80008a22:	58 78       	cp.w	r8,7
80008a24:	e0 89 00 04 	brgt	80008a2c <_vfprintf_r+0x1cd4>
80008a28:	2f 83       	sub	r3,-8
80008a2a:	c0 b8       	rjmp	80008a40 <_vfprintf_r+0x1ce8>
80008a2c:	fa ca f9 78 	sub	r10,sp,-1672
80008a30:	02 9b       	mov	r11,r1
80008a32:	08 9c       	mov	r12,r4
80008a34:	fe b0 f1 84 	rcall	80006d3c <__sprint_r>
80008a38:	e0 81 01 0f 	brne	80008c56 <_vfprintf_r+0x1efe>
80008a3c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a40:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a44:	2f f8       	sub	r8,-1
80008a46:	40 cb       	lddsp	r11,sp[0x30]
80008a48:	fb 48 06 90 	st.w	sp[1680],r8
80008a4c:	30 19       	mov	r9,1
80008a4e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a52:	87 0b       	st.w	r3[0x0],r11
80008a54:	2f f8       	sub	r8,-1
80008a56:	87 19       	st.w	r3[0x4],r9
80008a58:	fb 48 06 8c 	st.w	sp[1676],r8
80008a5c:	58 78       	cp.w	r8,7
80008a5e:	e0 89 00 05 	brgt	80008a68 <_vfprintf_r+0x1d10>
80008a62:	2f 83       	sub	r3,-8
80008a64:	c0 c8       	rjmp	80008a7c <_vfprintf_r+0x1d24>
80008a66:	d7 03       	nop
80008a68:	fa ca f9 78 	sub	r10,sp,-1672
80008a6c:	02 9b       	mov	r11,r1
80008a6e:	08 9c       	mov	r12,r4
80008a70:	fe b0 f1 66 	rcall	80006d3c <__sprint_r>
80008a74:	e0 81 00 f1 	brne	80008c56 <_vfprintf_r+0x1efe>
80008a78:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a7c:	30 08       	mov	r8,0
80008a7e:	30 09       	mov	r9,0
80008a80:	40 5b       	lddsp	r11,sp[0x14]
80008a82:	40 7a       	lddsp	r10,sp[0x1c]
80008a84:	e0 a0 13 19 	rcall	8000b0b6 <__avr32_f64_cmp_eq>
80008a88:	40 68       	lddsp	r8,sp[0x18]
80008a8a:	20 18       	sub	r8,1
80008a8c:	58 0c       	cp.w	r12,0
80008a8e:	c0 d1       	brne	80008aa8 <_vfprintf_r+0x1d50>
80008a90:	2f f6       	sub	r6,-1
80008a92:	87 18       	st.w	r3[0x4],r8
80008a94:	87 06       	st.w	r3[0x0],r6
80008a96:	fa f6 06 90 	ld.w	r6,sp[1680]
80008a9a:	10 06       	add	r6,r8
80008a9c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008aa0:	fb 46 06 90 	st.w	sp[1680],r6
80008aa4:	2f f8       	sub	r8,-1
80008aa6:	c3 18       	rjmp	80008b08 <_vfprintf_r+0x1db0>
80008aa8:	10 96       	mov	r6,r8
80008aaa:	58 08       	cp.w	r8,0
80008aac:	e0 89 00 1c 	brgt	80008ae4 <_vfprintf_r+0x1d8c>
80008ab0:	c4 b8       	rjmp	80008b46 <_vfprintf_r+0x1dee>
80008ab2:	2f 09       	sub	r9,-16
80008ab4:	2f f8       	sub	r8,-1
80008ab6:	fb 49 06 90 	st.w	sp[1680],r9
80008aba:	87 02       	st.w	r3[0x0],r2
80008abc:	87 10       	st.w	r3[0x4],r0
80008abe:	fb 48 06 8c 	st.w	sp[1676],r8
80008ac2:	58 78       	cp.w	r8,7
80008ac4:	e0 89 00 04 	brgt	80008acc <_vfprintf_r+0x1d74>
80008ac8:	2f 83       	sub	r3,-8
80008aca:	c0 b8       	rjmp	80008ae0 <_vfprintf_r+0x1d88>
80008acc:	fa ca f9 78 	sub	r10,sp,-1672
80008ad0:	02 9b       	mov	r11,r1
80008ad2:	08 9c       	mov	r12,r4
80008ad4:	fe b0 f1 34 	rcall	80006d3c <__sprint_r>
80008ad8:	e0 81 00 bf 	brne	80008c56 <_vfprintf_r+0x1efe>
80008adc:	fa c3 f9 e0 	sub	r3,sp,-1568
80008ae0:	21 06       	sub	r6,16
80008ae2:	c0 48       	rjmp	80008aea <_vfprintf_r+0x1d92>
80008ae4:	fe c2 bf f8 	sub	r2,pc,-16392
80008ae8:	31 00       	mov	r0,16
80008aea:	fa f9 06 90 	ld.w	r9,sp[1680]
80008aee:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008af2:	fe ca c0 06 	sub	r10,pc,-16378
80008af6:	59 06       	cp.w	r6,16
80008af8:	fe 99 ff dd 	brgt	80008ab2 <_vfprintf_r+0x1d5a>
80008afc:	0c 09       	add	r9,r6
80008afe:	87 0a       	st.w	r3[0x0],r10
80008b00:	fb 49 06 90 	st.w	sp[1680],r9
80008b04:	2f f8       	sub	r8,-1
80008b06:	87 16       	st.w	r3[0x4],r6
80008b08:	fb 48 06 8c 	st.w	sp[1676],r8
80008b0c:	c0 e8       	rjmp	80008b28 <_vfprintf_r+0x1dd0>
80008b0e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b12:	2f f8       	sub	r8,-1
80008b14:	30 19       	mov	r9,1
80008b16:	fb 48 06 90 	st.w	sp[1680],r8
80008b1a:	87 06       	st.w	r3[0x0],r6
80008b1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b20:	87 19       	st.w	r3[0x4],r9
80008b22:	2f f8       	sub	r8,-1
80008b24:	fb 48 06 8c 	st.w	sp[1676],r8
80008b28:	58 78       	cp.w	r8,7
80008b2a:	e0 89 00 04 	brgt	80008b32 <_vfprintf_r+0x1dda>
80008b2e:	2f 83       	sub	r3,-8
80008b30:	c0 b8       	rjmp	80008b46 <_vfprintf_r+0x1dee>
80008b32:	fa ca f9 78 	sub	r10,sp,-1672
80008b36:	02 9b       	mov	r11,r1
80008b38:	08 9c       	mov	r12,r4
80008b3a:	fe b0 f1 01 	rcall	80006d3c <__sprint_r>
80008b3e:	e0 81 00 8c 	brne	80008c56 <_vfprintf_r+0x1efe>
80008b42:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b46:	40 ea       	lddsp	r10,sp[0x38]
80008b48:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b4c:	14 08       	add	r8,r10
80008b4e:	fa c9 f9 64 	sub	r9,sp,-1692
80008b52:	fb 48 06 90 	st.w	sp[1680],r8
80008b56:	87 1a       	st.w	r3[0x4],r10
80008b58:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b5c:	87 09       	st.w	r3[0x0],r9
80008b5e:	2f f8       	sub	r8,-1
80008b60:	fb 48 06 8c 	st.w	sp[1676],r8
80008b64:	58 78       	cp.w	r8,7
80008b66:	e0 89 00 04 	brgt	80008b6e <_vfprintf_r+0x1e16>
80008b6a:	2f 83       	sub	r3,-8
80008b6c:	c0 a8       	rjmp	80008b80 <_vfprintf_r+0x1e28>
80008b6e:	fa ca f9 78 	sub	r10,sp,-1672
80008b72:	02 9b       	mov	r11,r1
80008b74:	08 9c       	mov	r12,r4
80008b76:	fe b0 f0 e3 	rcall	80006d3c <__sprint_r>
80008b7a:	c6 e1       	brne	80008c56 <_vfprintf_r+0x1efe>
80008b7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b80:	e2 15 00 04 	andl	r5,0x4,COH
80008b84:	c3 f0       	breq	80008c02 <_vfprintf_r+0x1eaa>
80008b86:	40 86       	lddsp	r6,sp[0x20]
80008b88:	40 39       	lddsp	r9,sp[0xc]
80008b8a:	12 16       	sub	r6,r9
80008b8c:	58 06       	cp.w	r6,0
80008b8e:	e0 89 00 1a 	brgt	80008bc2 <_vfprintf_r+0x1e6a>
80008b92:	c3 88       	rjmp	80008c02 <_vfprintf_r+0x1eaa>
80008b94:	2f 09       	sub	r9,-16
80008b96:	2f f8       	sub	r8,-1
80008b98:	fb 49 06 90 	st.w	sp[1680],r9
80008b9c:	87 05       	st.w	r3[0x0],r5
80008b9e:	87 12       	st.w	r3[0x4],r2
80008ba0:	fb 48 06 8c 	st.w	sp[1676],r8
80008ba4:	58 78       	cp.w	r8,7
80008ba6:	e0 89 00 04 	brgt	80008bae <_vfprintf_r+0x1e56>
80008baa:	2f 83       	sub	r3,-8
80008bac:	c0 98       	rjmp	80008bbe <_vfprintf_r+0x1e66>
80008bae:	00 9a       	mov	r10,r0
80008bb0:	02 9b       	mov	r11,r1
80008bb2:	08 9c       	mov	r12,r4
80008bb4:	fe b0 f0 c4 	rcall	80006d3c <__sprint_r>
80008bb8:	c4 f1       	brne	80008c56 <_vfprintf_r+0x1efe>
80008bba:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bbe:	21 06       	sub	r6,16
80008bc0:	c0 68       	rjmp	80008bcc <_vfprintf_r+0x1e74>
80008bc2:	fe c5 c0 e6 	sub	r5,pc,-16154
80008bc6:	31 02       	mov	r2,16
80008bc8:	fa c0 f9 78 	sub	r0,sp,-1672
80008bcc:	fa f9 06 90 	ld.w	r9,sp[1680]
80008bd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008bd4:	fe ca c0 f8 	sub	r10,pc,-16136
80008bd8:	59 06       	cp.w	r6,16
80008bda:	fe 99 ff dd 	brgt	80008b94 <_vfprintf_r+0x1e3c>
80008bde:	0c 09       	add	r9,r6
80008be0:	2f f8       	sub	r8,-1
80008be2:	87 0a       	st.w	r3[0x0],r10
80008be4:	87 16       	st.w	r3[0x4],r6
80008be6:	fb 49 06 90 	st.w	sp[1680],r9
80008bea:	fb 48 06 8c 	st.w	sp[1676],r8
80008bee:	58 78       	cp.w	r8,7
80008bf0:	e0 8a 00 09 	brle	80008c02 <_vfprintf_r+0x1eaa>
80008bf4:	fa ca f9 78 	sub	r10,sp,-1672
80008bf8:	02 9b       	mov	r11,r1
80008bfa:	08 9c       	mov	r12,r4
80008bfc:	fe b0 f0 a0 	rcall	80006d3c <__sprint_r>
80008c00:	c2 b1       	brne	80008c56 <_vfprintf_r+0x1efe>
80008c02:	40 bc       	lddsp	r12,sp[0x2c]
80008c04:	40 36       	lddsp	r6,sp[0xc]
80008c06:	40 8e       	lddsp	lr,sp[0x20]
80008c08:	ec 0e 0c 48 	max	r8,r6,lr
80008c0c:	10 0c       	add	r12,r8
80008c0e:	50 bc       	stdsp	sp[0x2c],r12
80008c10:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c14:	58 08       	cp.w	r8,0
80008c16:	c0 80       	breq	80008c26 <_vfprintf_r+0x1ece>
80008c18:	fa ca f9 78 	sub	r10,sp,-1672
80008c1c:	02 9b       	mov	r11,r1
80008c1e:	08 9c       	mov	r12,r4
80008c20:	fe b0 f0 8e 	rcall	80006d3c <__sprint_r>
80008c24:	c1 91       	brne	80008c56 <_vfprintf_r+0x1efe>
80008c26:	30 0b       	mov	r11,0
80008c28:	fa c3 f9 e0 	sub	r3,sp,-1568
80008c2c:	fb 4b 06 8c 	st.w	sp[1676],r11
80008c30:	fe 9f f1 22 	bral	80006e74 <_vfprintf_r+0x11c>
80008c34:	08 95       	mov	r5,r4
80008c36:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c3a:	58 08       	cp.w	r8,0
80008c3c:	c0 80       	breq	80008c4c <_vfprintf_r+0x1ef4>
80008c3e:	08 9c       	mov	r12,r4
80008c40:	fa ca f9 78 	sub	r10,sp,-1672
80008c44:	02 9b       	mov	r11,r1
80008c46:	fe b0 f0 7b 	rcall	80006d3c <__sprint_r>
80008c4a:	c0 61       	brne	80008c56 <_vfprintf_r+0x1efe>
80008c4c:	30 08       	mov	r8,0
80008c4e:	fb 48 06 8c 	st.w	sp[1676],r8
80008c52:	c0 28       	rjmp	80008c56 <_vfprintf_r+0x1efe>
80008c54:	40 41       	lddsp	r1,sp[0x10]
80008c56:	82 68       	ld.sh	r8,r1[0xc]
80008c58:	ed b8 00 06 	bld	r8,0x6
80008c5c:	c0 31       	brne	80008c62 <_vfprintf_r+0x1f0a>
80008c5e:	3f fa       	mov	r10,-1
80008c60:	50 ba       	stdsp	sp[0x2c],r10
80008c62:	40 bc       	lddsp	r12,sp[0x2c]
80008c64:	fe 3d f9 44 	sub	sp,-1724
80008c68:	d8 32       	popm	r0-r7,pc
80008c6a:	d7 03       	nop

80008c6c <__swsetup_r>:
80008c6c:	d4 21       	pushm	r4-r7,lr
80008c6e:	e0 68 0a 38 	mov	r8,2616
80008c72:	18 96       	mov	r6,r12
80008c74:	16 97       	mov	r7,r11
80008c76:	70 0c       	ld.w	r12,r8[0x0]
80008c78:	58 0c       	cp.w	r12,0
80008c7a:	c0 60       	breq	80008c86 <__swsetup_r+0x1a>
80008c7c:	78 68       	ld.w	r8,r12[0x18]
80008c7e:	58 08       	cp.w	r8,0
80008c80:	c0 31       	brne	80008c86 <__swsetup_r+0x1a>
80008c82:	e0 a0 07 bf 	rcall	80009c00 <__sinit>
80008c86:	fe c8 c0 7a 	sub	r8,pc,-16262
80008c8a:	10 37       	cp.w	r7,r8
80008c8c:	c0 61       	brne	80008c98 <__swsetup_r+0x2c>
80008c8e:	e0 68 0a 38 	mov	r8,2616
80008c92:	70 08       	ld.w	r8,r8[0x0]
80008c94:	70 07       	ld.w	r7,r8[0x0]
80008c96:	c1 28       	rjmp	80008cba <__swsetup_r+0x4e>
80008c98:	fe c8 c0 6c 	sub	r8,pc,-16276
80008c9c:	10 37       	cp.w	r7,r8
80008c9e:	c0 61       	brne	80008caa <__swsetup_r+0x3e>
80008ca0:	e0 68 0a 38 	mov	r8,2616
80008ca4:	70 08       	ld.w	r8,r8[0x0]
80008ca6:	70 17       	ld.w	r7,r8[0x4]
80008ca8:	c0 98       	rjmp	80008cba <__swsetup_r+0x4e>
80008caa:	fe c8 c0 5e 	sub	r8,pc,-16290
80008cae:	10 37       	cp.w	r7,r8
80008cb0:	c0 51       	brne	80008cba <__swsetup_r+0x4e>
80008cb2:	e0 68 0a 38 	mov	r8,2616
80008cb6:	70 08       	ld.w	r8,r8[0x0]
80008cb8:	70 27       	ld.w	r7,r8[0x8]
80008cba:	8e 68       	ld.sh	r8,r7[0xc]
80008cbc:	ed b8 00 03 	bld	r8,0x3
80008cc0:	c1 e0       	breq	80008cfc <__swsetup_r+0x90>
80008cc2:	ed b8 00 04 	bld	r8,0x4
80008cc6:	c3 e1       	brne	80008d42 <__swsetup_r+0xd6>
80008cc8:	ed b8 00 02 	bld	r8,0x2
80008ccc:	c1 51       	brne	80008cf6 <__swsetup_r+0x8a>
80008cce:	6e db       	ld.w	r11,r7[0x34]
80008cd0:	58 0b       	cp.w	r11,0
80008cd2:	c0 a0       	breq	80008ce6 <__swsetup_r+0x7a>
80008cd4:	ee c8 ff bc 	sub	r8,r7,-68
80008cd8:	10 3b       	cp.w	r11,r8
80008cda:	c0 40       	breq	80008ce2 <__swsetup_r+0x76>
80008cdc:	0c 9c       	mov	r12,r6
80008cde:	e0 a0 08 2b 	rcall	80009d34 <_free_r>
80008ce2:	30 08       	mov	r8,0
80008ce4:	8f d8       	st.w	r7[0x34],r8
80008ce6:	8e 68       	ld.sh	r8,r7[0xc]
80008ce8:	e0 18 ff db 	andl	r8,0xffdb
80008cec:	ae 68       	st.h	r7[0xc],r8
80008cee:	30 08       	mov	r8,0
80008cf0:	8f 18       	st.w	r7[0x4],r8
80008cf2:	6e 48       	ld.w	r8,r7[0x10]
80008cf4:	8f 08       	st.w	r7[0x0],r8
80008cf6:	8e 68       	ld.sh	r8,r7[0xc]
80008cf8:	a3 b8       	sbr	r8,0x3
80008cfa:	ae 68       	st.h	r7[0xc],r8
80008cfc:	6e 48       	ld.w	r8,r7[0x10]
80008cfe:	58 08       	cp.w	r8,0
80008d00:	c0 b1       	brne	80008d16 <__swsetup_r+0xaa>
80008d02:	8e 68       	ld.sh	r8,r7[0xc]
80008d04:	e2 18 02 80 	andl	r8,0x280,COH
80008d08:	e0 48 02 00 	cp.w	r8,512
80008d0c:	c0 50       	breq	80008d16 <__swsetup_r+0xaa>
80008d0e:	0c 9c       	mov	r12,r6
80008d10:	0e 9b       	mov	r11,r7
80008d12:	e0 a0 0a 4b 	rcall	8000a1a8 <__smakebuf_r>
80008d16:	8e 69       	ld.sh	r9,r7[0xc]
80008d18:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80008d1c:	c0 70       	breq	80008d2a <__swsetup_r+0xbe>
80008d1e:	30 08       	mov	r8,0
80008d20:	8f 28       	st.w	r7[0x8],r8
80008d22:	6e 58       	ld.w	r8,r7[0x14]
80008d24:	5c 38       	neg	r8
80008d26:	8f 68       	st.w	r7[0x18],r8
80008d28:	c0 68       	rjmp	80008d34 <__swsetup_r+0xc8>
80008d2a:	ed b9 00 01 	bld	r9,0x1
80008d2e:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80008d32:	8f 28       	st.w	r7[0x8],r8
80008d34:	6e 48       	ld.w	r8,r7[0x10]
80008d36:	58 08       	cp.w	r8,0
80008d38:	c0 61       	brne	80008d44 <__swsetup_r+0xd8>
80008d3a:	8e 68       	ld.sh	r8,r7[0xc]
80008d3c:	ed b8 00 07 	bld	r8,0x7
80008d40:	c0 21       	brne	80008d44 <__swsetup_r+0xd8>
80008d42:	dc 2a       	popm	r4-r7,pc,r12=-1
80008d44:	d8 2a       	popm	r4-r7,pc,r12=0
80008d46:	d7 03       	nop

80008d48 <quorem>:
80008d48:	d4 31       	pushm	r0-r7,lr
80008d4a:	20 2d       	sub	sp,8
80008d4c:	18 97       	mov	r7,r12
80008d4e:	78 48       	ld.w	r8,r12[0x10]
80008d50:	76 46       	ld.w	r6,r11[0x10]
80008d52:	0c 38       	cp.w	r8,r6
80008d54:	c0 34       	brge	80008d5a <quorem+0x12>
80008d56:	30 0c       	mov	r12,0
80008d58:	c8 58       	rjmp	80008e62 <quorem+0x11a>
80008d5a:	ec c2 ff fc 	sub	r2,r6,-4
80008d5e:	f6 c3 ff ec 	sub	r3,r11,-20
80008d62:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80008d66:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80008d6a:	2f f9       	sub	r9,-1
80008d6c:	20 16       	sub	r6,1
80008d6e:	f8 09 0d 08 	divu	r8,r12,r9
80008d72:	f6 02 00 22 	add	r2,r11,r2<<0x2
80008d76:	ee c4 ff ec 	sub	r4,r7,-20
80008d7a:	10 95       	mov	r5,r8
80008d7c:	58 08       	cp.w	r8,0
80008d7e:	c4 10       	breq	80008e00 <quorem+0xb8>
80008d80:	30 09       	mov	r9,0
80008d82:	06 9a       	mov	r10,r3
80008d84:	08 98       	mov	r8,r4
80008d86:	12 91       	mov	r1,r9
80008d88:	50 0b       	stdsp	sp[0x0],r11
80008d8a:	70 0e       	ld.w	lr,r8[0x0]
80008d8c:	b1 8e       	lsr	lr,0x10
80008d8e:	50 1e       	stdsp	sp[0x4],lr
80008d90:	15 0e       	ld.w	lr,r10++
80008d92:	fc 00 16 10 	lsr	r0,lr,0x10
80008d96:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80008d9a:	ea 0e 03 41 	mac	r1,r5,lr
80008d9e:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80008da2:	b1 81       	lsr	r1,0x10
80008da4:	40 1b       	lddsp	r11,sp[0x4]
80008da6:	ea 00 02 40 	mul	r0,r5,r0
80008daa:	e2 00 00 00 	add	r0,r1,r0
80008dae:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80008db2:	02 1b       	sub	r11,r1
80008db4:	50 1b       	stdsp	sp[0x4],r11
80008db6:	70 0b       	ld.w	r11,r8[0x0]
80008db8:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80008dbc:	02 09       	add	r9,r1
80008dbe:	f2 0e 01 0e 	sub	lr,r9,lr
80008dc2:	b0 1e       	st.h	r8[0x2],lr
80008dc4:	fc 09 14 10 	asr	r9,lr,0x10
80008dc8:	40 1e       	lddsp	lr,sp[0x4]
80008dca:	fc 09 00 09 	add	r9,lr,r9
80008dce:	b0 09       	st.h	r8[0x0],r9
80008dd0:	e0 01 16 10 	lsr	r1,r0,0x10
80008dd4:	2f c8       	sub	r8,-4
80008dd6:	b1 49       	asr	r9,0x10
80008dd8:	04 3a       	cp.w	r10,r2
80008dda:	fe 98 ff d8 	brls	80008d8a <quorem+0x42>
80008dde:	40 0b       	lddsp	r11,sp[0x0]
80008de0:	58 0c       	cp.w	r12,0
80008de2:	c0 f1       	brne	80008e00 <quorem+0xb8>
80008de4:	ec c8 ff fb 	sub	r8,r6,-5
80008de8:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008dec:	c0 28       	rjmp	80008df0 <quorem+0xa8>
80008dee:	20 16       	sub	r6,1
80008df0:	20 48       	sub	r8,4
80008df2:	08 38       	cp.w	r8,r4
80008df4:	e0 88 00 05 	brls	80008dfe <quorem+0xb6>
80008df8:	70 09       	ld.w	r9,r8[0x0]
80008dfa:	58 09       	cp.w	r9,0
80008dfc:	cf 90       	breq	80008dee <quorem+0xa6>
80008dfe:	8f 46       	st.w	r7[0x10],r6
80008e00:	0e 9c       	mov	r12,r7
80008e02:	e0 a0 0a d2 	rcall	8000a3a6 <__mcmp>
80008e06:	c2 d5       	brlt	80008e60 <quorem+0x118>
80008e08:	2f f5       	sub	r5,-1
80008e0a:	08 98       	mov	r8,r4
80008e0c:	30 09       	mov	r9,0
80008e0e:	07 0b       	ld.w	r11,r3++
80008e10:	f6 0a 16 10 	lsr	r10,r11,0x10
80008e14:	70 0c       	ld.w	r12,r8[0x0]
80008e16:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80008e1a:	f8 0e 16 10 	lsr	lr,r12,0x10
80008e1e:	14 1e       	sub	lr,r10
80008e20:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80008e24:	16 1a       	sub	r10,r11
80008e26:	12 0a       	add	r10,r9
80008e28:	b0 1a       	st.h	r8[0x2],r10
80008e2a:	b1 4a       	asr	r10,0x10
80008e2c:	fc 0a 00 09 	add	r9,lr,r10
80008e30:	b0 09       	st.h	r8[0x0],r9
80008e32:	2f c8       	sub	r8,-4
80008e34:	b1 49       	asr	r9,0x10
80008e36:	04 33       	cp.w	r3,r2
80008e38:	fe 98 ff eb 	brls	80008e0e <quorem+0xc6>
80008e3c:	ec c8 ff fb 	sub	r8,r6,-5
80008e40:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80008e44:	58 09       	cp.w	r9,0
80008e46:	c0 d1       	brne	80008e60 <quorem+0x118>
80008e48:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008e4c:	c0 28       	rjmp	80008e50 <quorem+0x108>
80008e4e:	20 16       	sub	r6,1
80008e50:	20 48       	sub	r8,4
80008e52:	08 38       	cp.w	r8,r4
80008e54:	e0 88 00 05 	brls	80008e5e <quorem+0x116>
80008e58:	70 09       	ld.w	r9,r8[0x0]
80008e5a:	58 09       	cp.w	r9,0
80008e5c:	cf 90       	breq	80008e4e <quorem+0x106>
80008e5e:	8f 46       	st.w	r7[0x10],r6
80008e60:	0a 9c       	mov	r12,r5
80008e62:	2f ed       	sub	sp,-8
80008e64:	d8 32       	popm	r0-r7,pc
80008e66:	d7 03       	nop

80008e68 <_dtoa_r>:
80008e68:	d4 31       	pushm	r0-r7,lr
80008e6a:	21 ad       	sub	sp,104
80008e6c:	fa c4 ff 74 	sub	r4,sp,-140
80008e70:	18 97       	mov	r7,r12
80008e72:	16 95       	mov	r5,r11
80008e74:	68 2c       	ld.w	r12,r4[0x8]
80008e76:	50 c9       	stdsp	sp[0x30],r9
80008e78:	68 16       	ld.w	r6,r4[0x4]
80008e7a:	68 09       	ld.w	r9,r4[0x0]
80008e7c:	50 e8       	stdsp	sp[0x38],r8
80008e7e:	14 94       	mov	r4,r10
80008e80:	51 2c       	stdsp	sp[0x48],r12
80008e82:	fa e5 00 08 	st.d	sp[8],r4
80008e86:	51 59       	stdsp	sp[0x54],r9
80008e88:	6e 95       	ld.w	r5,r7[0x24]
80008e8a:	58 05       	cp.w	r5,0
80008e8c:	c0 91       	brne	80008e9e <_dtoa_r+0x36>
80008e8e:	31 0c       	mov	r12,16
80008e90:	fe b0 e8 e8 	rcall	80006060 <malloc>
80008e94:	99 35       	st.w	r12[0xc],r5
80008e96:	8f 9c       	st.w	r7[0x24],r12
80008e98:	99 15       	st.w	r12[0x4],r5
80008e9a:	99 25       	st.w	r12[0x8],r5
80008e9c:	99 05       	st.w	r12[0x0],r5
80008e9e:	6e 99       	ld.w	r9,r7[0x24]
80008ea0:	72 08       	ld.w	r8,r9[0x0]
80008ea2:	58 08       	cp.w	r8,0
80008ea4:	c0 f0       	breq	80008ec2 <_dtoa_r+0x5a>
80008ea6:	72 1a       	ld.w	r10,r9[0x4]
80008ea8:	91 1a       	st.w	r8[0x4],r10
80008eaa:	30 1a       	mov	r10,1
80008eac:	72 19       	ld.w	r9,r9[0x4]
80008eae:	f4 09 09 49 	lsl	r9,r10,r9
80008eb2:	10 9b       	mov	r11,r8
80008eb4:	91 29       	st.w	r8[0x8],r9
80008eb6:	0e 9c       	mov	r12,r7
80008eb8:	e0 a0 0a 90 	rcall	8000a3d8 <_Bfree>
80008ebc:	6e 98       	ld.w	r8,r7[0x24]
80008ebe:	30 09       	mov	r9,0
80008ec0:	91 09       	st.w	r8[0x0],r9
80008ec2:	40 28       	lddsp	r8,sp[0x8]
80008ec4:	10 94       	mov	r4,r8
80008ec6:	58 08       	cp.w	r8,0
80008ec8:	c0 64       	brge	80008ed4 <_dtoa_r+0x6c>
80008eca:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80008ece:	50 28       	stdsp	sp[0x8],r8
80008ed0:	30 18       	mov	r8,1
80008ed2:	c0 28       	rjmp	80008ed6 <_dtoa_r+0x6e>
80008ed4:	30 08       	mov	r8,0
80008ed6:	8d 08       	st.w	r6[0x0],r8
80008ed8:	fc 1c 7f f0 	movh	r12,0x7ff0
80008edc:	40 26       	lddsp	r6,sp[0x8]
80008ede:	0c 98       	mov	r8,r6
80008ee0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80008ee4:	18 38       	cp.w	r8,r12
80008ee6:	c2 01       	brne	80008f26 <_dtoa_r+0xbe>
80008ee8:	e0 68 27 0f 	mov	r8,9999
80008eec:	41 5b       	lddsp	r11,sp[0x54]
80008eee:	97 08       	st.w	r11[0x0],r8
80008ef0:	40 3a       	lddsp	r10,sp[0xc]
80008ef2:	58 0a       	cp.w	r10,0
80008ef4:	c0 71       	brne	80008f02 <_dtoa_r+0x9a>
80008ef6:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80008efa:	c0 41       	brne	80008f02 <_dtoa_r+0x9a>
80008efc:	fe cc c3 00 	sub	r12,pc,-15616
80008f00:	c0 38       	rjmp	80008f06 <_dtoa_r+0x9e>
80008f02:	fe cc c2 fa 	sub	r12,pc,-15622
80008f06:	41 29       	lddsp	r9,sp[0x48]
80008f08:	58 09       	cp.w	r9,0
80008f0a:	e0 80 05 9a 	breq	80009a3e <_dtoa_r+0xbd6>
80008f0e:	f8 c8 ff fd 	sub	r8,r12,-3
80008f12:	f8 c9 ff f8 	sub	r9,r12,-8
80008f16:	11 8b       	ld.ub	r11,r8[0x0]
80008f18:	30 0a       	mov	r10,0
80008f1a:	41 25       	lddsp	r5,sp[0x48]
80008f1c:	f4 0b 18 00 	cp.b	r11,r10
80008f20:	f2 08 17 10 	movne	r8,r9
80008f24:	c1 68       	rjmp	80008f50 <_dtoa_r+0xe8>
80008f26:	fa ea 00 08 	ld.d	r10,sp[8]
80008f2a:	30 08       	mov	r8,0
80008f2c:	fa eb 00 3c 	st.d	sp[60],r10
80008f30:	30 09       	mov	r9,0
80008f32:	e0 a0 10 c2 	rcall	8000b0b6 <__avr32_f64_cmp_eq>
80008f36:	c1 00       	breq	80008f56 <_dtoa_r+0xee>
80008f38:	30 18       	mov	r8,1
80008f3a:	41 5a       	lddsp	r10,sp[0x54]
80008f3c:	95 08       	st.w	r10[0x0],r8
80008f3e:	fe cc c4 66 	sub	r12,pc,-15258
80008f42:	41 29       	lddsp	r9,sp[0x48]
80008f44:	f8 08 00 08 	add	r8,r12,r8
80008f48:	58 09       	cp.w	r9,0
80008f4a:	e0 80 05 7a 	breq	80009a3e <_dtoa_r+0xbd6>
80008f4e:	12 95       	mov	r5,r9
80008f50:	8b 08       	st.w	r5[0x0],r8
80008f52:	e0 8f 05 76 	bral	80009a3e <_dtoa_r+0xbd6>
80008f56:	fa c8 ff 9c 	sub	r8,sp,-100
80008f5a:	fa c9 ff a0 	sub	r9,sp,-96
80008f5e:	fa ea 00 3c 	ld.d	r10,sp[60]
80008f62:	0e 9c       	mov	r12,r7
80008f64:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80008f68:	e0 a0 0a 8a 	rcall	8000a47c <__d2b>
80008f6c:	18 93       	mov	r3,r12
80008f6e:	58 05       	cp.w	r5,0
80008f70:	c0 d0       	breq	80008f8a <_dtoa_r+0x122>
80008f72:	fa ea 00 3c 	ld.d	r10,sp[60]
80008f76:	30 04       	mov	r4,0
80008f78:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80008f7c:	ea c5 03 ff 	sub	r5,r5,1023
80008f80:	10 9b       	mov	r11,r8
80008f82:	51 74       	stdsp	sp[0x5c],r4
80008f84:	ea 1b 3f f0 	orh	r11,0x3ff0
80008f88:	c2 58       	rjmp	80008fd2 <_dtoa_r+0x16a>
80008f8a:	41 88       	lddsp	r8,sp[0x60]
80008f8c:	41 9c       	lddsp	r12,sp[0x64]
80008f8e:	10 0c       	add	r12,r8
80008f90:	f8 c5 fb ce 	sub	r5,r12,-1074
80008f94:	e0 45 00 20 	cp.w	r5,32
80008f98:	e0 8a 00 0e 	brle	80008fb4 <_dtoa_r+0x14c>
80008f9c:	f8 cc fb ee 	sub	r12,r12,-1042
80008fa0:	40 3b       	lddsp	r11,sp[0xc]
80008fa2:	ea 08 11 40 	rsub	r8,r5,64
80008fa6:	f6 0c 0a 4c 	lsr	r12,r11,r12
80008faa:	ec 08 09 46 	lsl	r6,r6,r8
80008fae:	0c 4c       	or	r12,r6
80008fb0:	c0 78       	rjmp	80008fbe <_dtoa_r+0x156>
80008fb2:	d7 03       	nop
80008fb4:	ea 0c 11 20 	rsub	r12,r5,32
80008fb8:	40 3a       	lddsp	r10,sp[0xc]
80008fba:	f4 0c 09 4c 	lsl	r12,r10,r12
80008fbe:	e0 a0 10 08 	rcall	8000afce <__avr32_u32_to_f64>
80008fc2:	fc 18 fe 10 	movh	r8,0xfe10
80008fc6:	30 19       	mov	r9,1
80008fc8:	ea c5 04 33 	sub	r5,r5,1075
80008fcc:	f0 0b 00 0b 	add	r11,r8,r11
80008fd0:	51 79       	stdsp	sp[0x5c],r9
80008fd2:	30 08       	mov	r8,0
80008fd4:	fc 19 3f f8 	movh	r9,0x3ff8
80008fd8:	e0 a0 0e 90 	rcall	8000acf8 <__avr32_f64_sub>
80008fdc:	e0 68 43 61 	mov	r8,17249
80008fe0:	ea 18 63 6f 	orh	r8,0x636f
80008fe4:	e0 69 87 a7 	mov	r9,34727
80008fe8:	ea 19 3f d2 	orh	r9,0x3fd2
80008fec:	e0 a0 0d 9a 	rcall	8000ab20 <__avr32_f64_mul>
80008ff0:	e0 68 c8 b3 	mov	r8,51379
80008ff4:	ea 18 8b 60 	orh	r8,0x8b60
80008ff8:	e0 69 8a 28 	mov	r9,35368
80008ffc:	ea 19 3f c6 	orh	r9,0x3fc6
80009000:	e0 a0 0f 4a 	rcall	8000ae94 <__avr32_f64_add>
80009004:	0a 9c       	mov	r12,r5
80009006:	14 90       	mov	r0,r10
80009008:	16 91       	mov	r1,r11
8000900a:	e0 a0 0f e6 	rcall	8000afd6 <__avr32_s32_to_f64>
8000900e:	e0 68 79 fb 	mov	r8,31227
80009012:	ea 18 50 9f 	orh	r8,0x509f
80009016:	e0 69 44 13 	mov	r9,17427
8000901a:	ea 19 3f d3 	orh	r9,0x3fd3
8000901e:	e0 a0 0d 81 	rcall	8000ab20 <__avr32_f64_mul>
80009022:	14 98       	mov	r8,r10
80009024:	16 99       	mov	r9,r11
80009026:	00 9a       	mov	r10,r0
80009028:	02 9b       	mov	r11,r1
8000902a:	e0 a0 0f 35 	rcall	8000ae94 <__avr32_f64_add>
8000902e:	14 90       	mov	r0,r10
80009030:	16 91       	mov	r1,r11
80009032:	e0 a0 0f bb 	rcall	8000afa8 <__avr32_f64_to_s32>
80009036:	30 08       	mov	r8,0
80009038:	18 96       	mov	r6,r12
8000903a:	30 09       	mov	r9,0
8000903c:	00 9a       	mov	r10,r0
8000903e:	02 9b       	mov	r11,r1
80009040:	e0 a0 10 82 	rcall	8000b144 <__avr32_f64_cmp_lt>
80009044:	c0 c0       	breq	8000905c <_dtoa_r+0x1f4>
80009046:	0c 9c       	mov	r12,r6
80009048:	e0 a0 0f c7 	rcall	8000afd6 <__avr32_s32_to_f64>
8000904c:	14 98       	mov	r8,r10
8000904e:	16 99       	mov	r9,r11
80009050:	00 9a       	mov	r10,r0
80009052:	02 9b       	mov	r11,r1
80009054:	e0 a0 10 31 	rcall	8000b0b6 <__avr32_f64_cmp_eq>
80009058:	f7 b6 00 01 	subeq	r6,1
8000905c:	59 66       	cp.w	r6,22
8000905e:	e0 88 00 05 	brls	80009068 <_dtoa_r+0x200>
80009062:	30 18       	mov	r8,1
80009064:	51 48       	stdsp	sp[0x50],r8
80009066:	c1 38       	rjmp	8000908c <_dtoa_r+0x224>
80009068:	fe c8 c3 ac 	sub	r8,pc,-15444
8000906c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009070:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
80009074:	e0 a0 10 68 	rcall	8000b144 <__avr32_f64_cmp_lt>
80009078:	f9 b4 00 00 	moveq	r4,0
8000907c:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009080:	f7 b6 01 01 	subne	r6,1
80009084:	f9 bc 01 00 	movne	r12,0
80009088:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000908c:	41 90       	lddsp	r0,sp[0x64]
8000908e:	20 10       	sub	r0,1
80009090:	0a 10       	sub	r0,r5
80009092:	c0 46       	brmi	8000909a <_dtoa_r+0x232>
80009094:	50 40       	stdsp	sp[0x10],r0
80009096:	30 00       	mov	r0,0
80009098:	c0 48       	rjmp	800090a0 <_dtoa_r+0x238>
8000909a:	30 0b       	mov	r11,0
8000909c:	5c 30       	neg	r0
8000909e:	50 4b       	stdsp	sp[0x10],r11
800090a0:	ec 02 11 00 	rsub	r2,r6,0
800090a4:	58 06       	cp.w	r6,0
800090a6:	fb fa 40 04 	ld.wge	r10,sp[0x10]
800090aa:	f5 d6 e4 0a 	addge	r10,r10,r6
800090ae:	fb fa 4a 04 	st.wge	sp[0x10],r10
800090b2:	fb f6 4a 11 	st.wge	sp[0x44],r6
800090b6:	f9 b2 04 00 	movge	r2,0
800090ba:	e1 d6 e5 10 	sublt	r0,r0,r6
800090be:	f9 b9 05 00 	movlt	r9,0
800090c2:	fb f9 5a 11 	st.wlt	sp[0x44],r9
800090c6:	40 c8       	lddsp	r8,sp[0x30]
800090c8:	58 98       	cp.w	r8,9
800090ca:	e0 8b 00 20 	brhi	8000910a <_dtoa_r+0x2a2>
800090ce:	58 58       	cp.w	r8,5
800090d0:	f9 b4 0a 01 	movle	r4,1
800090d4:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
800090d8:	f7 b5 09 04 	subgt	r5,4
800090dc:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
800090e0:	f9 b4 09 00 	movgt	r4,0
800090e4:	40 cc       	lddsp	r12,sp[0x30]
800090e6:	58 3c       	cp.w	r12,3
800090e8:	c2 d0       	breq	80009142 <_dtoa_r+0x2da>
800090ea:	e0 89 00 05 	brgt	800090f4 <_dtoa_r+0x28c>
800090ee:	58 2c       	cp.w	r12,2
800090f0:	c1 01       	brne	80009110 <_dtoa_r+0x2a8>
800090f2:	c1 88       	rjmp	80009122 <_dtoa_r+0x2ba>
800090f4:	40 cb       	lddsp	r11,sp[0x30]
800090f6:	58 4b       	cp.w	r11,4
800090f8:	c0 60       	breq	80009104 <_dtoa_r+0x29c>
800090fa:	58 5b       	cp.w	r11,5
800090fc:	c0 a1       	brne	80009110 <_dtoa_r+0x2a8>
800090fe:	30 1a       	mov	r10,1
80009100:	50 da       	stdsp	sp[0x34],r10
80009102:	c2 28       	rjmp	80009146 <_dtoa_r+0x2de>
80009104:	30 19       	mov	r9,1
80009106:	50 d9       	stdsp	sp[0x34],r9
80009108:	c0 f8       	rjmp	80009126 <_dtoa_r+0x2be>
8000910a:	30 08       	mov	r8,0
8000910c:	30 14       	mov	r4,1
8000910e:	50 c8       	stdsp	sp[0x30],r8
80009110:	3f f5       	mov	r5,-1
80009112:	30 1c       	mov	r12,1
80009114:	30 0b       	mov	r11,0
80009116:	50 95       	stdsp	sp[0x24],r5
80009118:	50 dc       	stdsp	sp[0x34],r12
8000911a:	0a 91       	mov	r1,r5
8000911c:	31 28       	mov	r8,18
8000911e:	50 eb       	stdsp	sp[0x38],r11
80009120:	c2 08       	rjmp	80009160 <_dtoa_r+0x2f8>
80009122:	30 0a       	mov	r10,0
80009124:	50 da       	stdsp	sp[0x34],r10
80009126:	40 e9       	lddsp	r9,sp[0x38]
80009128:	58 09       	cp.w	r9,0
8000912a:	e0 89 00 07 	brgt	80009138 <_dtoa_r+0x2d0>
8000912e:	30 18       	mov	r8,1
80009130:	50 98       	stdsp	sp[0x24],r8
80009132:	10 91       	mov	r1,r8
80009134:	50 e8       	stdsp	sp[0x38],r8
80009136:	c1 58       	rjmp	80009160 <_dtoa_r+0x2f8>
80009138:	40 e5       	lddsp	r5,sp[0x38]
8000913a:	50 95       	stdsp	sp[0x24],r5
8000913c:	0a 91       	mov	r1,r5
8000913e:	0a 98       	mov	r8,r5
80009140:	c1 08       	rjmp	80009160 <_dtoa_r+0x2f8>
80009142:	30 0c       	mov	r12,0
80009144:	50 dc       	stdsp	sp[0x34],r12
80009146:	40 eb       	lddsp	r11,sp[0x38]
80009148:	ec 0b 00 0b 	add	r11,r6,r11
8000914c:	50 9b       	stdsp	sp[0x24],r11
8000914e:	16 98       	mov	r8,r11
80009150:	2f f8       	sub	r8,-1
80009152:	58 08       	cp.w	r8,0
80009154:	e0 89 00 05 	brgt	8000915e <_dtoa_r+0x2f6>
80009158:	10 91       	mov	r1,r8
8000915a:	30 18       	mov	r8,1
8000915c:	c0 28       	rjmp	80009160 <_dtoa_r+0x2f8>
8000915e:	10 91       	mov	r1,r8
80009160:	30 09       	mov	r9,0
80009162:	6e 9a       	ld.w	r10,r7[0x24]
80009164:	95 19       	st.w	r10[0x4],r9
80009166:	30 49       	mov	r9,4
80009168:	c0 68       	rjmp	80009174 <_dtoa_r+0x30c>
8000916a:	d7 03       	nop
8000916c:	6a 1a       	ld.w	r10,r5[0x4]
8000916e:	a1 79       	lsl	r9,0x1
80009170:	2f fa       	sub	r10,-1
80009172:	8b 1a       	st.w	r5[0x4],r10
80009174:	6e 95       	ld.w	r5,r7[0x24]
80009176:	f2 ca ff ec 	sub	r10,r9,-20
8000917a:	10 3a       	cp.w	r10,r8
8000917c:	fe 98 ff f8 	brls	8000916c <_dtoa_r+0x304>
80009180:	6a 1b       	ld.w	r11,r5[0x4]
80009182:	0e 9c       	mov	r12,r7
80009184:	e0 a0 09 44 	rcall	8000a40c <_Balloc>
80009188:	58 e1       	cp.w	r1,14
8000918a:	5f 88       	srls	r8
8000918c:	8b 0c       	st.w	r5[0x0],r12
8000918e:	f1 e4 00 04 	and	r4,r8,r4
80009192:	6e 98       	ld.w	r8,r7[0x24]
80009194:	70 08       	ld.w	r8,r8[0x0]
80009196:	50 88       	stdsp	sp[0x20],r8
80009198:	e0 80 01 82 	breq	8000949c <_dtoa_r+0x634>
8000919c:	58 06       	cp.w	r6,0
8000919e:	e0 8a 00 43 	brle	80009224 <_dtoa_r+0x3bc>
800091a2:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
800091a6:	fe c8 c4 ea 	sub	r8,pc,-15126
800091aa:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
800091ae:	fa e5 00 18 	st.d	sp[24],r4
800091b2:	ec 04 14 04 	asr	r4,r6,0x4
800091b6:	ed b4 00 04 	bld	r4,0x4
800091ba:	c0 30       	breq	800091c0 <_dtoa_r+0x358>
800091bc:	30 25       	mov	r5,2
800091be:	c1 08       	rjmp	800091de <_dtoa_r+0x376>
800091c0:	fe c8 c4 3c 	sub	r8,pc,-15300
800091c4:	f0 e8 00 20 	ld.d	r8,r8[32]
800091c8:	fa ea 00 3c 	ld.d	r10,sp[60]
800091cc:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
800091d0:	e0 a0 0f ee 	rcall	8000b1ac <__avr32_f64_div>
800091d4:	30 35       	mov	r5,3
800091d6:	14 98       	mov	r8,r10
800091d8:	16 99       	mov	r9,r11
800091da:	fa e9 00 08 	st.d	sp[8],r8
800091de:	fe cc c4 5a 	sub	r12,pc,-15270
800091e2:	50 a3       	stdsp	sp[0x28],r3
800091e4:	0c 93       	mov	r3,r6
800091e6:	18 96       	mov	r6,r12
800091e8:	c0 f8       	rjmp	80009206 <_dtoa_r+0x39e>
800091ea:	fa ea 00 18 	ld.d	r10,sp[24]
800091ee:	ed b4 00 00 	bld	r4,0x0
800091f2:	c0 81       	brne	80009202 <_dtoa_r+0x39a>
800091f4:	ec e8 00 00 	ld.d	r8,r6[0]
800091f8:	2f f5       	sub	r5,-1
800091fa:	e0 a0 0c 93 	rcall	8000ab20 <__avr32_f64_mul>
800091fe:	fa eb 00 18 	st.d	sp[24],r10
80009202:	a1 54       	asr	r4,0x1
80009204:	2f 86       	sub	r6,-8
80009206:	58 04       	cp.w	r4,0
80009208:	cf 11       	brne	800091ea <_dtoa_r+0x382>
8000920a:	fa e8 00 18 	ld.d	r8,sp[24]
8000920e:	fa ea 00 08 	ld.d	r10,sp[8]
80009212:	06 96       	mov	r6,r3
80009214:	e0 a0 0f cc 	rcall	8000b1ac <__avr32_f64_div>
80009218:	40 a3       	lddsp	r3,sp[0x28]
8000921a:	14 98       	mov	r8,r10
8000921c:	16 99       	mov	r9,r11
8000921e:	fa e9 00 08 	st.d	sp[8],r8
80009222:	c2 f8       	rjmp	80009280 <_dtoa_r+0x418>
80009224:	ec 08 11 00 	rsub	r8,r6,0
80009228:	c0 31       	brne	8000922e <_dtoa_r+0x3c6>
8000922a:	30 25       	mov	r5,2
8000922c:	c2 a8       	rjmp	80009280 <_dtoa_r+0x418>
8000922e:	fe cc c4 aa 	sub	r12,pc,-15190
80009232:	f0 04 14 04 	asr	r4,r8,0x4
80009236:	50 1c       	stdsp	sp[0x4],r12
80009238:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000923c:	fe c9 c5 80 	sub	r9,pc,-14976
80009240:	fa ea 00 3c 	ld.d	r10,sp[60]
80009244:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009248:	e0 a0 0c 6c 	rcall	8000ab20 <__avr32_f64_mul>
8000924c:	40 1c       	lddsp	r12,sp[0x4]
8000924e:	50 63       	stdsp	sp[0x18],r3
80009250:	30 25       	mov	r5,2
80009252:	0c 93       	mov	r3,r6
80009254:	fa eb 00 08 	st.d	sp[8],r10
80009258:	18 96       	mov	r6,r12
8000925a:	c0 f8       	rjmp	80009278 <_dtoa_r+0x410>
8000925c:	fa ea 00 08 	ld.d	r10,sp[8]
80009260:	ed b4 00 00 	bld	r4,0x0
80009264:	c0 81       	brne	80009274 <_dtoa_r+0x40c>
80009266:	ec e8 00 00 	ld.d	r8,r6[0]
8000926a:	2f f5       	sub	r5,-1
8000926c:	e0 a0 0c 5a 	rcall	8000ab20 <__avr32_f64_mul>
80009270:	fa eb 00 08 	st.d	sp[8],r10
80009274:	a1 54       	asr	r4,0x1
80009276:	2f 86       	sub	r6,-8
80009278:	58 04       	cp.w	r4,0
8000927a:	cf 11       	brne	8000925c <_dtoa_r+0x3f4>
8000927c:	06 96       	mov	r6,r3
8000927e:	40 63       	lddsp	r3,sp[0x18]
80009280:	41 4a       	lddsp	r10,sp[0x50]
80009282:	58 0a       	cp.w	r10,0
80009284:	c2 a0       	breq	800092d8 <_dtoa_r+0x470>
80009286:	fa e8 00 08 	ld.d	r8,sp[8]
8000928a:	58 01       	cp.w	r1,0
8000928c:	5f 94       	srgt	r4
8000928e:	fa e9 00 18 	st.d	sp[24],r8
80009292:	30 08       	mov	r8,0
80009294:	fc 19 3f f0 	movh	r9,0x3ff0
80009298:	fa ea 00 18 	ld.d	r10,sp[24]
8000929c:	e0 a0 0f 54 	rcall	8000b144 <__avr32_f64_cmp_lt>
800092a0:	f9 bc 00 00 	moveq	r12,0
800092a4:	f9 bc 01 01 	movne	r12,1
800092a8:	e9 ec 00 0c 	and	r12,r4,r12
800092ac:	c1 60       	breq	800092d8 <_dtoa_r+0x470>
800092ae:	40 98       	lddsp	r8,sp[0x24]
800092b0:	58 08       	cp.w	r8,0
800092b2:	e0 8a 00 f1 	brle	80009494 <_dtoa_r+0x62c>
800092b6:	30 08       	mov	r8,0
800092b8:	fc 19 40 24 	movh	r9,0x4024
800092bc:	ec c4 00 01 	sub	r4,r6,1
800092c0:	fa ea 00 18 	ld.d	r10,sp[24]
800092c4:	2f f5       	sub	r5,-1
800092c6:	50 64       	stdsp	sp[0x18],r4
800092c8:	e0 a0 0c 2c 	rcall	8000ab20 <__avr32_f64_mul>
800092cc:	40 94       	lddsp	r4,sp[0x24]
800092ce:	14 98       	mov	r8,r10
800092d0:	16 99       	mov	r9,r11
800092d2:	fa e9 00 08 	st.d	sp[8],r8
800092d6:	c0 38       	rjmp	800092dc <_dtoa_r+0x474>
800092d8:	50 66       	stdsp	sp[0x18],r6
800092da:	02 94       	mov	r4,r1
800092dc:	0a 9c       	mov	r12,r5
800092de:	e0 a0 0e 7c 	rcall	8000afd6 <__avr32_s32_to_f64>
800092e2:	fa e8 00 08 	ld.d	r8,sp[8]
800092e6:	e0 a0 0c 1d 	rcall	8000ab20 <__avr32_f64_mul>
800092ea:	30 08       	mov	r8,0
800092ec:	fc 19 40 1c 	movh	r9,0x401c
800092f0:	e0 a0 0d d2 	rcall	8000ae94 <__avr32_f64_add>
800092f4:	14 98       	mov	r8,r10
800092f6:	16 99       	mov	r9,r11
800092f8:	fa e9 00 28 	st.d	sp[40],r8
800092fc:	fc 18 fc c0 	movh	r8,0xfcc0
80009300:	40 a5       	lddsp	r5,sp[0x28]
80009302:	10 05       	add	r5,r8
80009304:	50 a5       	stdsp	sp[0x28],r5
80009306:	58 04       	cp.w	r4,0
80009308:	c2 11       	brne	8000934a <_dtoa_r+0x4e2>
8000930a:	fa ea 00 08 	ld.d	r10,sp[8]
8000930e:	30 08       	mov	r8,0
80009310:	fc 19 40 14 	movh	r9,0x4014
80009314:	e0 a0 0c f2 	rcall	8000acf8 <__avr32_f64_sub>
80009318:	40 bc       	lddsp	r12,sp[0x2c]
8000931a:	fa eb 00 08 	st.d	sp[8],r10
8000931e:	14 98       	mov	r8,r10
80009320:	16 99       	mov	r9,r11
80009322:	18 9a       	mov	r10,r12
80009324:	0a 9b       	mov	r11,r5
80009326:	e0 a0 0f 0f 	rcall	8000b144 <__avr32_f64_cmp_lt>
8000932a:	e0 81 02 54 	brne	800097d2 <_dtoa_r+0x96a>
8000932e:	0a 98       	mov	r8,r5
80009330:	40 b9       	lddsp	r9,sp[0x2c]
80009332:	ee 18 80 00 	eorh	r8,0x8000
80009336:	fa ea 00 08 	ld.d	r10,sp[8]
8000933a:	10 95       	mov	r5,r8
8000933c:	12 98       	mov	r8,r9
8000933e:	0a 99       	mov	r9,r5
80009340:	e0 a0 0f 02 	rcall	8000b144 <__avr32_f64_cmp_lt>
80009344:	e0 81 02 3e 	brne	800097c0 <_dtoa_r+0x958>
80009348:	ca 68       	rjmp	80009494 <_dtoa_r+0x62c>
8000934a:	fe c9 c6 8e 	sub	r9,pc,-14706
8000934e:	e8 c8 00 01 	sub	r8,r4,1
80009352:	40 d5       	lddsp	r5,sp[0x34]
80009354:	58 05       	cp.w	r5,0
80009356:	c4 f0       	breq	800093f4 <_dtoa_r+0x58c>
80009358:	30 0c       	mov	r12,0
8000935a:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000935e:	51 3c       	stdsp	sp[0x4c],r12
80009360:	30 0a       	mov	r10,0
80009362:	fc 1b 3f e0 	movh	r11,0x3fe0
80009366:	e0 a0 0f 23 	rcall	8000b1ac <__avr32_f64_div>
8000936a:	fa e8 00 28 	ld.d	r8,sp[40]
8000936e:	40 85       	lddsp	r5,sp[0x20]
80009370:	e0 a0 0c c4 	rcall	8000acf8 <__avr32_f64_sub>
80009374:	fa eb 00 28 	st.d	sp[40],r10
80009378:	fa ea 00 08 	ld.d	r10,sp[8]
8000937c:	e0 a0 0e 16 	rcall	8000afa8 <__avr32_f64_to_s32>
80009380:	51 6c       	stdsp	sp[0x58],r12
80009382:	e0 a0 0e 2a 	rcall	8000afd6 <__avr32_s32_to_f64>
80009386:	14 98       	mov	r8,r10
80009388:	16 99       	mov	r9,r11
8000938a:	fa ea 00 08 	ld.d	r10,sp[8]
8000938e:	e0 a0 0c b5 	rcall	8000acf8 <__avr32_f64_sub>
80009392:	fa eb 00 08 	st.d	sp[8],r10
80009396:	41 68       	lddsp	r8,sp[0x58]
80009398:	2d 08       	sub	r8,-48
8000939a:	0a c8       	st.b	r5++,r8
8000939c:	41 39       	lddsp	r9,sp[0x4c]
8000939e:	2f f9       	sub	r9,-1
800093a0:	51 39       	stdsp	sp[0x4c],r9
800093a2:	fa e8 00 28 	ld.d	r8,sp[40]
800093a6:	e0 a0 0e cf 	rcall	8000b144 <__avr32_f64_cmp_lt>
800093aa:	e0 81 03 39 	brne	80009a1c <_dtoa_r+0xbb4>
800093ae:	fa e8 00 08 	ld.d	r8,sp[8]
800093b2:	30 0a       	mov	r10,0
800093b4:	fc 1b 3f f0 	movh	r11,0x3ff0
800093b8:	e0 a0 0c a0 	rcall	8000acf8 <__avr32_f64_sub>
800093bc:	fa e8 00 28 	ld.d	r8,sp[40]
800093c0:	e0 a0 0e c2 	rcall	8000b144 <__avr32_f64_cmp_lt>
800093c4:	fa ea 00 28 	ld.d	r10,sp[40]
800093c8:	30 08       	mov	r8,0
800093ca:	fc 19 40 24 	movh	r9,0x4024
800093ce:	e0 81 00 da 	brne	80009582 <_dtoa_r+0x71a>
800093d2:	41 3c       	lddsp	r12,sp[0x4c]
800093d4:	08 3c       	cp.w	r12,r4
800093d6:	c5 f4       	brge	80009494 <_dtoa_r+0x62c>
800093d8:	e0 a0 0b a4 	rcall	8000ab20 <__avr32_f64_mul>
800093dc:	30 08       	mov	r8,0
800093de:	fa eb 00 28 	st.d	sp[40],r10
800093e2:	fc 19 40 24 	movh	r9,0x4024
800093e6:	fa ea 00 08 	ld.d	r10,sp[8]
800093ea:	e0 a0 0b 9b 	rcall	8000ab20 <__avr32_f64_mul>
800093ee:	fa eb 00 08 	st.d	sp[8],r10
800093f2:	cc 3b       	rjmp	80009378 <_dtoa_r+0x510>
800093f4:	40 85       	lddsp	r5,sp[0x20]
800093f6:	08 05       	add	r5,r4
800093f8:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
800093fc:	51 35       	stdsp	sp[0x4c],r5
800093fe:	fa e8 00 28 	ld.d	r8,sp[40]
80009402:	40 85       	lddsp	r5,sp[0x20]
80009404:	e0 a0 0b 8e 	rcall	8000ab20 <__avr32_f64_mul>
80009408:	fa eb 00 28 	st.d	sp[40],r10
8000940c:	fa ea 00 08 	ld.d	r10,sp[8]
80009410:	e0 a0 0d cc 	rcall	8000afa8 <__avr32_f64_to_s32>
80009414:	51 6c       	stdsp	sp[0x58],r12
80009416:	e0 a0 0d e0 	rcall	8000afd6 <__avr32_s32_to_f64>
8000941a:	14 98       	mov	r8,r10
8000941c:	16 99       	mov	r9,r11
8000941e:	fa ea 00 08 	ld.d	r10,sp[8]
80009422:	e0 a0 0c 6b 	rcall	8000acf8 <__avr32_f64_sub>
80009426:	fa eb 00 08 	st.d	sp[8],r10
8000942a:	41 68       	lddsp	r8,sp[0x58]
8000942c:	2d 08       	sub	r8,-48
8000942e:	0a c8       	st.b	r5++,r8
80009430:	41 3c       	lddsp	r12,sp[0x4c]
80009432:	18 35       	cp.w	r5,r12
80009434:	c2 81       	brne	80009484 <_dtoa_r+0x61c>
80009436:	30 08       	mov	r8,0
80009438:	fc 19 3f e0 	movh	r9,0x3fe0
8000943c:	fa ea 00 28 	ld.d	r10,sp[40]
80009440:	e0 a0 0d 2a 	rcall	8000ae94 <__avr32_f64_add>
80009444:	40 85       	lddsp	r5,sp[0x20]
80009446:	fa e8 00 08 	ld.d	r8,sp[8]
8000944a:	08 05       	add	r5,r4
8000944c:	e0 a0 0e 7c 	rcall	8000b144 <__avr32_f64_cmp_lt>
80009450:	e0 81 00 99 	brne	80009582 <_dtoa_r+0x71a>
80009454:	fa e8 00 28 	ld.d	r8,sp[40]
80009458:	30 0a       	mov	r10,0
8000945a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000945e:	e0 a0 0c 4d 	rcall	8000acf8 <__avr32_f64_sub>
80009462:	14 98       	mov	r8,r10
80009464:	16 99       	mov	r9,r11
80009466:	fa ea 00 08 	ld.d	r10,sp[8]
8000946a:	e0 a0 0e 6d 	rcall	8000b144 <__avr32_f64_cmp_lt>
8000946e:	c1 30       	breq	80009494 <_dtoa_r+0x62c>
80009470:	33 09       	mov	r9,48
80009472:	0a 98       	mov	r8,r5
80009474:	11 7a       	ld.ub	r10,--r8
80009476:	f2 0a 18 00 	cp.b	r10,r9
8000947a:	e0 81 02 d1 	brne	80009a1c <_dtoa_r+0xbb4>
8000947e:	10 95       	mov	r5,r8
80009480:	cf 9b       	rjmp	80009472 <_dtoa_r+0x60a>
80009482:	d7 03       	nop
80009484:	30 08       	mov	r8,0
80009486:	fc 19 40 24 	movh	r9,0x4024
8000948a:	e0 a0 0b 4b 	rcall	8000ab20 <__avr32_f64_mul>
8000948e:	fa eb 00 08 	st.d	sp[8],r10
80009492:	cb db       	rjmp	8000940c <_dtoa_r+0x5a4>
80009494:	fa ea 00 3c 	ld.d	r10,sp[60]
80009498:	fa eb 00 08 	st.d	sp[8],r10
8000949c:	58 e6       	cp.w	r6,14
8000949e:	5f ab       	srle	r11
800094a0:	41 8a       	lddsp	r10,sp[0x60]
800094a2:	30 08       	mov	r8,0
800094a4:	f4 09 11 ff 	rsub	r9,r10,-1
800094a8:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
800094ac:	f0 09 18 00 	cp.b	r9,r8
800094b0:	e0 80 00 82 	breq	800095b4 <_dtoa_r+0x74c>
800094b4:	40 ea       	lddsp	r10,sp[0x38]
800094b6:	58 01       	cp.w	r1,0
800094b8:	5f a9       	srle	r9
800094ba:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
800094be:	fe ca c8 02 	sub	r10,pc,-14334
800094c2:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
800094c6:	fa e5 00 10 	st.d	sp[16],r4
800094ca:	f0 09 18 00 	cp.b	r9,r8
800094ce:	c1 40       	breq	800094f6 <_dtoa_r+0x68e>
800094d0:	58 01       	cp.w	r1,0
800094d2:	e0 81 01 77 	brne	800097c0 <_dtoa_r+0x958>
800094d6:	30 08       	mov	r8,0
800094d8:	fc 19 40 14 	movh	r9,0x4014
800094dc:	08 9a       	mov	r10,r4
800094de:	0a 9b       	mov	r11,r5
800094e0:	e0 a0 0b 20 	rcall	8000ab20 <__avr32_f64_mul>
800094e4:	fa e8 00 08 	ld.d	r8,sp[8]
800094e8:	e0 a0 0d fa 	rcall	8000b0dc <__avr32_f64_cmp_ge>
800094ec:	e0 81 01 6a 	brne	800097c0 <_dtoa_r+0x958>
800094f0:	02 92       	mov	r2,r1
800094f2:	e0 8f 01 72 	bral	800097d6 <_dtoa_r+0x96e>
800094f6:	40 85       	lddsp	r5,sp[0x20]
800094f8:	30 14       	mov	r4,1
800094fa:	fa e8 00 10 	ld.d	r8,sp[16]
800094fe:	fa ea 00 08 	ld.d	r10,sp[8]
80009502:	e0 a0 0e 55 	rcall	8000b1ac <__avr32_f64_div>
80009506:	e0 a0 0d 51 	rcall	8000afa8 <__avr32_f64_to_s32>
8000950a:	18 92       	mov	r2,r12
8000950c:	e0 a0 0d 65 	rcall	8000afd6 <__avr32_s32_to_f64>
80009510:	fa e8 00 10 	ld.d	r8,sp[16]
80009514:	e0 a0 0b 06 	rcall	8000ab20 <__avr32_f64_mul>
80009518:	14 98       	mov	r8,r10
8000951a:	16 99       	mov	r9,r11
8000951c:	fa ea 00 08 	ld.d	r10,sp[8]
80009520:	e0 a0 0b ec 	rcall	8000acf8 <__avr32_f64_sub>
80009524:	fa eb 00 08 	st.d	sp[8],r10
80009528:	e4 c8 ff d0 	sub	r8,r2,-48
8000952c:	0a c8       	st.b	r5++,r8
8000952e:	fc 19 40 24 	movh	r9,0x4024
80009532:	30 08       	mov	r8,0
80009534:	02 34       	cp.w	r4,r1
80009536:	c3 31       	brne	8000959c <_dtoa_r+0x734>
80009538:	fa e8 00 08 	ld.d	r8,sp[8]
8000953c:	e0 a0 0c ac 	rcall	8000ae94 <__avr32_f64_add>
80009540:	16 91       	mov	r1,r11
80009542:	14 90       	mov	r0,r10
80009544:	14 98       	mov	r8,r10
80009546:	02 99       	mov	r9,r1
80009548:	fa ea 00 10 	ld.d	r10,sp[16]
8000954c:	e0 a0 0d fc 	rcall	8000b144 <__avr32_f64_cmp_lt>
80009550:	c1 a1       	brne	80009584 <_dtoa_r+0x71c>
80009552:	fa e8 00 10 	ld.d	r8,sp[16]
80009556:	00 9a       	mov	r10,r0
80009558:	02 9b       	mov	r11,r1
8000955a:	e0 a0 0d ae 	rcall	8000b0b6 <__avr32_f64_cmp_eq>
8000955e:	e0 80 02 5e 	breq	80009a1a <_dtoa_r+0xbb2>
80009562:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80009566:	c0 f1       	brne	80009584 <_dtoa_r+0x71c>
80009568:	e0 8f 02 59 	bral	80009a1a <_dtoa_r+0xbb2>
8000956c:	40 8a       	lddsp	r10,sp[0x20]
8000956e:	14 38       	cp.w	r8,r10
80009570:	c0 30       	breq	80009576 <_dtoa_r+0x70e>
80009572:	10 95       	mov	r5,r8
80009574:	c0 98       	rjmp	80009586 <_dtoa_r+0x71e>
80009576:	33 08       	mov	r8,48
80009578:	40 89       	lddsp	r9,sp[0x20]
8000957a:	2f f6       	sub	r6,-1
8000957c:	b2 88       	st.b	r9[0x0],r8
8000957e:	40 88       	lddsp	r8,sp[0x20]
80009580:	c0 88       	rjmp	80009590 <_dtoa_r+0x728>
80009582:	40 66       	lddsp	r6,sp[0x18]
80009584:	33 99       	mov	r9,57
80009586:	0a 98       	mov	r8,r5
80009588:	11 7a       	ld.ub	r10,--r8
8000958a:	f2 0a 18 00 	cp.b	r10,r9
8000958e:	ce f0       	breq	8000956c <_dtoa_r+0x704>
80009590:	50 66       	stdsp	sp[0x18],r6
80009592:	11 89       	ld.ub	r9,r8[0x0]
80009594:	2f f9       	sub	r9,-1
80009596:	b0 89       	st.b	r8[0x0],r9
80009598:	e0 8f 02 42 	bral	80009a1c <_dtoa_r+0xbb4>
8000959c:	e0 a0 0a c2 	rcall	8000ab20 <__avr32_f64_mul>
800095a0:	2f f4       	sub	r4,-1
800095a2:	fa eb 00 08 	st.d	sp[8],r10
800095a6:	30 08       	mov	r8,0
800095a8:	30 09       	mov	r9,0
800095aa:	e0 a0 0d 86 	rcall	8000b0b6 <__avr32_f64_cmp_eq>
800095ae:	ca 60       	breq	800094fa <_dtoa_r+0x692>
800095b0:	e0 8f 02 35 	bral	80009a1a <_dtoa_r+0xbb2>
800095b4:	40 d8       	lddsp	r8,sp[0x34]
800095b6:	58 08       	cp.w	r8,0
800095b8:	c0 51       	brne	800095c2 <_dtoa_r+0x75a>
800095ba:	04 98       	mov	r8,r2
800095bc:	00 95       	mov	r5,r0
800095be:	40 d4       	lddsp	r4,sp[0x34]
800095c0:	c3 78       	rjmp	8000962e <_dtoa_r+0x7c6>
800095c2:	40 c5       	lddsp	r5,sp[0x30]
800095c4:	58 15       	cp.w	r5,1
800095c6:	e0 89 00 0f 	brgt	800095e4 <_dtoa_r+0x77c>
800095ca:	41 74       	lddsp	r4,sp[0x5c]
800095cc:	58 04       	cp.w	r4,0
800095ce:	c0 40       	breq	800095d6 <_dtoa_r+0x76e>
800095d0:	f4 c9 fb cd 	sub	r9,r10,-1075
800095d4:	c0 48       	rjmp	800095dc <_dtoa_r+0x774>
800095d6:	41 99       	lddsp	r9,sp[0x64]
800095d8:	f2 09 11 36 	rsub	r9,r9,54
800095dc:	04 98       	mov	r8,r2
800095de:	00 95       	mov	r5,r0
800095e0:	c1 c8       	rjmp	80009618 <_dtoa_r+0x7b0>
800095e2:	d7 03       	nop
800095e4:	e2 c8 00 01 	sub	r8,r1,1
800095e8:	58 01       	cp.w	r1,0
800095ea:	e0 05 17 40 	movge	r5,r0
800095ee:	e2 09 17 40 	movge	r9,r1
800095f2:	e1 d1 e5 15 	sublt	r5,r0,r1
800095f6:	f9 b9 05 00 	movlt	r9,0
800095fa:	10 32       	cp.w	r2,r8
800095fc:	e5 d8 e4 18 	subge	r8,r2,r8
80009600:	f1 d2 e5 18 	sublt	r8,r8,r2
80009604:	e5 d8 e5 02 	addlt	r2,r2,r8
80009608:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000960c:	f9 d8 e5 0c 	addlt	r12,r12,r8
80009610:	fb fc 5a 11 	st.wlt	sp[0x44],r12
80009614:	f9 b8 05 00 	movlt	r8,0
80009618:	40 4b       	lddsp	r11,sp[0x10]
8000961a:	12 0b       	add	r11,r9
8000961c:	50 08       	stdsp	sp[0x0],r8
8000961e:	50 4b       	stdsp	sp[0x10],r11
80009620:	12 00       	add	r0,r9
80009622:	30 1b       	mov	r11,1
80009624:	0e 9c       	mov	r12,r7
80009626:	e0 a0 08 a7 	rcall	8000a774 <__i2b>
8000962a:	40 08       	lddsp	r8,sp[0x0]
8000962c:	18 94       	mov	r4,r12
8000962e:	40 4a       	lddsp	r10,sp[0x10]
80009630:	58 05       	cp.w	r5,0
80009632:	5f 99       	srgt	r9
80009634:	58 0a       	cp.w	r10,0
80009636:	5f 9a       	srgt	r10
80009638:	f5 e9 00 09 	and	r9,r10,r9
8000963c:	c0 80       	breq	8000964c <_dtoa_r+0x7e4>
8000963e:	40 4c       	lddsp	r12,sp[0x10]
80009640:	f8 05 0d 49 	min	r9,r12,r5
80009644:	12 1c       	sub	r12,r9
80009646:	12 10       	sub	r0,r9
80009648:	50 4c       	stdsp	sp[0x10],r12
8000964a:	12 15       	sub	r5,r9
8000964c:	58 02       	cp.w	r2,0
8000964e:	e0 8a 00 27 	brle	8000969c <_dtoa_r+0x834>
80009652:	40 db       	lddsp	r11,sp[0x34]
80009654:	58 0b       	cp.w	r11,0
80009656:	c1 d0       	breq	80009690 <_dtoa_r+0x828>
80009658:	58 08       	cp.w	r8,0
8000965a:	e0 8a 00 17 	brle	80009688 <_dtoa_r+0x820>
8000965e:	10 9a       	mov	r10,r8
80009660:	50 08       	stdsp	sp[0x0],r8
80009662:	08 9b       	mov	r11,r4
80009664:	0e 9c       	mov	r12,r7
80009666:	e0 a0 08 cd 	rcall	8000a800 <__pow5mult>
8000966a:	06 9a       	mov	r10,r3
8000966c:	18 9b       	mov	r11,r12
8000966e:	18 94       	mov	r4,r12
80009670:	0e 9c       	mov	r12,r7
80009672:	e0 a0 08 01 	rcall	8000a674 <__multiply>
80009676:	18 99       	mov	r9,r12
80009678:	06 9b       	mov	r11,r3
8000967a:	50 19       	stdsp	sp[0x4],r9
8000967c:	0e 9c       	mov	r12,r7
8000967e:	e0 a0 06 ad 	rcall	8000a3d8 <_Bfree>
80009682:	40 19       	lddsp	r9,sp[0x4]
80009684:	40 08       	lddsp	r8,sp[0x0]
80009686:	12 93       	mov	r3,r9
80009688:	e4 08 01 0a 	sub	r10,r2,r8
8000968c:	c0 80       	breq	8000969c <_dtoa_r+0x834>
8000968e:	c0 28       	rjmp	80009692 <_dtoa_r+0x82a>
80009690:	04 9a       	mov	r10,r2
80009692:	06 9b       	mov	r11,r3
80009694:	0e 9c       	mov	r12,r7
80009696:	e0 a0 08 b5 	rcall	8000a800 <__pow5mult>
8000969a:	18 93       	mov	r3,r12
8000969c:	30 1b       	mov	r11,1
8000969e:	0e 9c       	mov	r12,r7
800096a0:	e0 a0 08 6a 	rcall	8000a774 <__i2b>
800096a4:	41 1a       	lddsp	r10,sp[0x44]
800096a6:	18 92       	mov	r2,r12
800096a8:	58 0a       	cp.w	r10,0
800096aa:	e0 8a 00 07 	brle	800096b8 <_dtoa_r+0x850>
800096ae:	18 9b       	mov	r11,r12
800096b0:	0e 9c       	mov	r12,r7
800096b2:	e0 a0 08 a7 	rcall	8000a800 <__pow5mult>
800096b6:	18 92       	mov	r2,r12
800096b8:	40 c9       	lddsp	r9,sp[0x30]
800096ba:	58 19       	cp.w	r9,1
800096bc:	e0 89 00 14 	brgt	800096e4 <_dtoa_r+0x87c>
800096c0:	40 38       	lddsp	r8,sp[0xc]
800096c2:	58 08       	cp.w	r8,0
800096c4:	c1 01       	brne	800096e4 <_dtoa_r+0x87c>
800096c6:	40 29       	lddsp	r9,sp[0x8]
800096c8:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
800096cc:	c0 c1       	brne	800096e4 <_dtoa_r+0x87c>
800096ce:	12 98       	mov	r8,r9
800096d0:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800096d4:	c0 80       	breq	800096e4 <_dtoa_r+0x87c>
800096d6:	40 4c       	lddsp	r12,sp[0x10]
800096d8:	30 1b       	mov	r11,1
800096da:	2f fc       	sub	r12,-1
800096dc:	2f f0       	sub	r0,-1
800096de:	50 4c       	stdsp	sp[0x10],r12
800096e0:	50 6b       	stdsp	sp[0x18],r11
800096e2:	c0 38       	rjmp	800096e8 <_dtoa_r+0x880>
800096e4:	30 0a       	mov	r10,0
800096e6:	50 6a       	stdsp	sp[0x18],r10
800096e8:	41 19       	lddsp	r9,sp[0x44]
800096ea:	58 09       	cp.w	r9,0
800096ec:	c0 31       	brne	800096f2 <_dtoa_r+0x88a>
800096ee:	30 1c       	mov	r12,1
800096f0:	c0 98       	rjmp	80009702 <_dtoa_r+0x89a>
800096f2:	64 48       	ld.w	r8,r2[0x10]
800096f4:	2f c8       	sub	r8,-4
800096f6:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
800096fa:	e0 a0 05 df 	rcall	8000a2b8 <__hi0bits>
800096fe:	f8 0c 11 20 	rsub	r12,r12,32
80009702:	40 4b       	lddsp	r11,sp[0x10]
80009704:	f8 0b 00 08 	add	r8,r12,r11
80009708:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000970c:	c0 c0       	breq	80009724 <_dtoa_r+0x8bc>
8000970e:	f0 08 11 20 	rsub	r8,r8,32
80009712:	58 48       	cp.w	r8,4
80009714:	e0 8a 00 06 	brle	80009720 <_dtoa_r+0x8b8>
80009718:	20 48       	sub	r8,4
8000971a:	10 0b       	add	r11,r8
8000971c:	50 4b       	stdsp	sp[0x10],r11
8000971e:	c0 78       	rjmp	8000972c <_dtoa_r+0x8c4>
80009720:	58 48       	cp.w	r8,4
80009722:	c0 70       	breq	80009730 <_dtoa_r+0x8c8>
80009724:	40 4a       	lddsp	r10,sp[0x10]
80009726:	2e 48       	sub	r8,-28
80009728:	10 0a       	add	r10,r8
8000972a:	50 4a       	stdsp	sp[0x10],r10
8000972c:	10 00       	add	r0,r8
8000972e:	10 05       	add	r5,r8
80009730:	58 00       	cp.w	r0,0
80009732:	e0 8a 00 08 	brle	80009742 <_dtoa_r+0x8da>
80009736:	06 9b       	mov	r11,r3
80009738:	00 9a       	mov	r10,r0
8000973a:	0e 9c       	mov	r12,r7
8000973c:	e0 a0 07 58 	rcall	8000a5ec <__lshift>
80009740:	18 93       	mov	r3,r12
80009742:	40 49       	lddsp	r9,sp[0x10]
80009744:	58 09       	cp.w	r9,0
80009746:	e0 8a 00 08 	brle	80009756 <_dtoa_r+0x8ee>
8000974a:	04 9b       	mov	r11,r2
8000974c:	12 9a       	mov	r10,r9
8000974e:	0e 9c       	mov	r12,r7
80009750:	e0 a0 07 4e 	rcall	8000a5ec <__lshift>
80009754:	18 92       	mov	r2,r12
80009756:	41 48       	lddsp	r8,sp[0x50]
80009758:	58 08       	cp.w	r8,0
8000975a:	c1 b0       	breq	80009790 <_dtoa_r+0x928>
8000975c:	04 9b       	mov	r11,r2
8000975e:	06 9c       	mov	r12,r3
80009760:	e0 a0 06 23 	rcall	8000a3a6 <__mcmp>
80009764:	c1 64       	brge	80009790 <_dtoa_r+0x928>
80009766:	06 9b       	mov	r11,r3
80009768:	30 09       	mov	r9,0
8000976a:	30 aa       	mov	r10,10
8000976c:	0e 9c       	mov	r12,r7
8000976e:	e0 a0 08 0b 	rcall	8000a784 <__multadd>
80009772:	20 16       	sub	r6,1
80009774:	18 93       	mov	r3,r12
80009776:	40 dc       	lddsp	r12,sp[0x34]
80009778:	58 0c       	cp.w	r12,0
8000977a:	c0 31       	brne	80009780 <_dtoa_r+0x918>
8000977c:	40 91       	lddsp	r1,sp[0x24]
8000977e:	c0 98       	rjmp	80009790 <_dtoa_r+0x928>
80009780:	08 9b       	mov	r11,r4
80009782:	40 91       	lddsp	r1,sp[0x24]
80009784:	30 09       	mov	r9,0
80009786:	30 aa       	mov	r10,10
80009788:	0e 9c       	mov	r12,r7
8000978a:	e0 a0 07 fd 	rcall	8000a784 <__multadd>
8000978e:	18 94       	mov	r4,r12
80009790:	58 01       	cp.w	r1,0
80009792:	5f a9       	srle	r9
80009794:	40 cb       	lddsp	r11,sp[0x30]
80009796:	58 2b       	cp.w	r11,2
80009798:	5f 98       	srgt	r8
8000979a:	f3 e8 00 08 	and	r8,r9,r8
8000979e:	c2 50       	breq	800097e8 <_dtoa_r+0x980>
800097a0:	58 01       	cp.w	r1,0
800097a2:	c1 11       	brne	800097c4 <_dtoa_r+0x95c>
800097a4:	04 9b       	mov	r11,r2
800097a6:	02 99       	mov	r9,r1
800097a8:	30 5a       	mov	r10,5
800097aa:	0e 9c       	mov	r12,r7
800097ac:	e0 a0 07 ec 	rcall	8000a784 <__multadd>
800097b0:	18 92       	mov	r2,r12
800097b2:	18 9b       	mov	r11,r12
800097b4:	06 9c       	mov	r12,r3
800097b6:	e0 a0 05 f8 	rcall	8000a3a6 <__mcmp>
800097ba:	e0 89 00 0f 	brgt	800097d8 <_dtoa_r+0x970>
800097be:	c0 38       	rjmp	800097c4 <_dtoa_r+0x95c>
800097c0:	30 02       	mov	r2,0
800097c2:	04 94       	mov	r4,r2
800097c4:	40 ea       	lddsp	r10,sp[0x38]
800097c6:	30 09       	mov	r9,0
800097c8:	5c da       	com	r10
800097ca:	40 85       	lddsp	r5,sp[0x20]
800097cc:	50 6a       	stdsp	sp[0x18],r10
800097ce:	50 49       	stdsp	sp[0x10],r9
800097d0:	c0 f9       	rjmp	800099ee <_dtoa_r+0xb86>
800097d2:	08 92       	mov	r2,r4
800097d4:	40 66       	lddsp	r6,sp[0x18]
800097d6:	04 94       	mov	r4,r2
800097d8:	2f f6       	sub	r6,-1
800097da:	50 66       	stdsp	sp[0x18],r6
800097dc:	33 18       	mov	r8,49
800097de:	40 85       	lddsp	r5,sp[0x20]
800097e0:	0a c8       	st.b	r5++,r8
800097e2:	30 08       	mov	r8,0
800097e4:	50 48       	stdsp	sp[0x10],r8
800097e6:	c0 49       	rjmp	800099ee <_dtoa_r+0xb86>
800097e8:	40 dc       	lddsp	r12,sp[0x34]
800097ea:	58 0c       	cp.w	r12,0
800097ec:	e0 80 00 b5 	breq	80009956 <_dtoa_r+0xaee>
800097f0:	58 05       	cp.w	r5,0
800097f2:	e0 8a 00 08 	brle	80009802 <_dtoa_r+0x99a>
800097f6:	08 9b       	mov	r11,r4
800097f8:	0a 9a       	mov	r10,r5
800097fa:	0e 9c       	mov	r12,r7
800097fc:	e0 a0 06 f8 	rcall	8000a5ec <__lshift>
80009800:	18 94       	mov	r4,r12
80009802:	40 6b       	lddsp	r11,sp[0x18]
80009804:	58 0b       	cp.w	r11,0
80009806:	c0 31       	brne	8000980c <_dtoa_r+0x9a4>
80009808:	08 9c       	mov	r12,r4
8000980a:	c1 38       	rjmp	80009830 <_dtoa_r+0x9c8>
8000980c:	68 1b       	ld.w	r11,r4[0x4]
8000980e:	0e 9c       	mov	r12,r7
80009810:	e0 a0 05 fe 	rcall	8000a40c <_Balloc>
80009814:	68 4a       	ld.w	r10,r4[0x10]
80009816:	18 95       	mov	r5,r12
80009818:	e8 cb ff f4 	sub	r11,r4,-12
8000981c:	2f ea       	sub	r10,-2
8000981e:	2f 4c       	sub	r12,-12
80009820:	a3 6a       	lsl	r10,0x2
80009822:	fe b0 e6 43 	rcall	800064a8 <memcpy>
80009826:	0a 9b       	mov	r11,r5
80009828:	30 1a       	mov	r10,1
8000982a:	0e 9c       	mov	r12,r7
8000982c:	e0 a0 06 e0 	rcall	8000a5ec <__lshift>
80009830:	50 44       	stdsp	sp[0x10],r4
80009832:	40 3a       	lddsp	r10,sp[0xc]
80009834:	30 19       	mov	r9,1
80009836:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000983a:	18 94       	mov	r4,r12
8000983c:	50 da       	stdsp	sp[0x34],r10
8000983e:	40 85       	lddsp	r5,sp[0x20]
80009840:	50 99       	stdsp	sp[0x24],r9
80009842:	50 26       	stdsp	sp[0x8],r6
80009844:	50 e1       	stdsp	sp[0x38],r1
80009846:	04 9b       	mov	r11,r2
80009848:	06 9c       	mov	r12,r3
8000984a:	fe b0 fa 7f 	rcall	80008d48 <quorem>
8000984e:	40 4b       	lddsp	r11,sp[0x10]
80009850:	f8 c0 ff d0 	sub	r0,r12,-48
80009854:	06 9c       	mov	r12,r3
80009856:	e0 a0 05 a8 	rcall	8000a3a6 <__mcmp>
8000985a:	08 9a       	mov	r10,r4
8000985c:	50 6c       	stdsp	sp[0x18],r12
8000985e:	04 9b       	mov	r11,r2
80009860:	0e 9c       	mov	r12,r7
80009862:	e0 a0 06 5d 	rcall	8000a51c <__mdiff>
80009866:	18 91       	mov	r1,r12
80009868:	78 38       	ld.w	r8,r12[0xc]
8000986a:	58 08       	cp.w	r8,0
8000986c:	c0 30       	breq	80009872 <_dtoa_r+0xa0a>
8000986e:	30 16       	mov	r6,1
80009870:	c0 68       	rjmp	8000987c <_dtoa_r+0xa14>
80009872:	18 9b       	mov	r11,r12
80009874:	06 9c       	mov	r12,r3
80009876:	e0 a0 05 98 	rcall	8000a3a6 <__mcmp>
8000987a:	18 96       	mov	r6,r12
8000987c:	0e 9c       	mov	r12,r7
8000987e:	02 9b       	mov	r11,r1
80009880:	e0 a0 05 ac 	rcall	8000a3d8 <_Bfree>
80009884:	40 cc       	lddsp	r12,sp[0x30]
80009886:	ed ec 10 08 	or	r8,r6,r12
8000988a:	c0 d1       	brne	800098a4 <_dtoa_r+0xa3c>
8000988c:	40 db       	lddsp	r11,sp[0x34]
8000988e:	58 0b       	cp.w	r11,0
80009890:	c0 a1       	brne	800098a4 <_dtoa_r+0xa3c>
80009892:	40 26       	lddsp	r6,sp[0x8]
80009894:	e0 40 00 39 	cp.w	r0,57
80009898:	c3 00       	breq	800098f8 <_dtoa_r+0xa90>
8000989a:	40 6a       	lddsp	r10,sp[0x18]
8000989c:	58 0a       	cp.w	r10,0
8000989e:	e0 89 00 24 	brgt	800098e6 <_dtoa_r+0xa7e>
800098a2:	c2 f8       	rjmp	80009900 <_dtoa_r+0xa98>
800098a4:	40 69       	lddsp	r9,sp[0x18]
800098a6:	58 09       	cp.w	r9,0
800098a8:	c0 85       	brlt	800098b8 <_dtoa_r+0xa50>
800098aa:	12 98       	mov	r8,r9
800098ac:	40 cc       	lddsp	r12,sp[0x30]
800098ae:	18 48       	or	r8,r12
800098b0:	c1 d1       	brne	800098ea <_dtoa_r+0xa82>
800098b2:	40 db       	lddsp	r11,sp[0x34]
800098b4:	58 0b       	cp.w	r11,0
800098b6:	c1 a1       	brne	800098ea <_dtoa_r+0xa82>
800098b8:	0c 99       	mov	r9,r6
800098ba:	40 26       	lddsp	r6,sp[0x8]
800098bc:	58 09       	cp.w	r9,0
800098be:	e0 8a 00 21 	brle	80009900 <_dtoa_r+0xa98>
800098c2:	06 9b       	mov	r11,r3
800098c4:	30 1a       	mov	r10,1
800098c6:	0e 9c       	mov	r12,r7
800098c8:	e0 a0 06 92 	rcall	8000a5ec <__lshift>
800098cc:	04 9b       	mov	r11,r2
800098ce:	18 93       	mov	r3,r12
800098d0:	e0 a0 05 6b 	rcall	8000a3a6 <__mcmp>
800098d4:	e0 89 00 06 	brgt	800098e0 <_dtoa_r+0xa78>
800098d8:	c1 41       	brne	80009900 <_dtoa_r+0xa98>
800098da:	ed b0 00 00 	bld	r0,0x0
800098de:	c1 11       	brne	80009900 <_dtoa_r+0xa98>
800098e0:	e0 40 00 39 	cp.w	r0,57
800098e4:	c0 a0       	breq	800098f8 <_dtoa_r+0xa90>
800098e6:	2f f0       	sub	r0,-1
800098e8:	c0 c8       	rjmp	80009900 <_dtoa_r+0xa98>
800098ea:	58 06       	cp.w	r6,0
800098ec:	e0 8a 00 0c 	brle	80009904 <_dtoa_r+0xa9c>
800098f0:	40 26       	lddsp	r6,sp[0x8]
800098f2:	e0 40 00 39 	cp.w	r0,57
800098f6:	c0 41       	brne	800098fe <_dtoa_r+0xa96>
800098f8:	33 98       	mov	r8,57
800098fa:	0a c8       	st.b	r5++,r8
800098fc:	c6 78       	rjmp	800099ca <_dtoa_r+0xb62>
800098fe:	2f f0       	sub	r0,-1
80009900:	0a c0       	st.b	r5++,r0
80009902:	c7 58       	rjmp	800099ec <_dtoa_r+0xb84>
80009904:	0a c0       	st.b	r5++,r0
80009906:	40 9a       	lddsp	r10,sp[0x24]
80009908:	40 e9       	lddsp	r9,sp[0x38]
8000990a:	12 3a       	cp.w	r10,r9
8000990c:	c4 30       	breq	80009992 <_dtoa_r+0xb2a>
8000990e:	06 9b       	mov	r11,r3
80009910:	30 09       	mov	r9,0
80009912:	30 aa       	mov	r10,10
80009914:	0e 9c       	mov	r12,r7
80009916:	e0 a0 07 37 	rcall	8000a784 <__multadd>
8000991a:	40 48       	lddsp	r8,sp[0x10]
8000991c:	18 93       	mov	r3,r12
8000991e:	08 38       	cp.w	r8,r4
80009920:	c0 91       	brne	80009932 <_dtoa_r+0xaca>
80009922:	10 9b       	mov	r11,r8
80009924:	30 09       	mov	r9,0
80009926:	30 aa       	mov	r10,10
80009928:	0e 9c       	mov	r12,r7
8000992a:	e0 a0 07 2d 	rcall	8000a784 <__multadd>
8000992e:	50 4c       	stdsp	sp[0x10],r12
80009930:	c0 e8       	rjmp	8000994c <_dtoa_r+0xae4>
80009932:	40 4b       	lddsp	r11,sp[0x10]
80009934:	30 09       	mov	r9,0
80009936:	30 aa       	mov	r10,10
80009938:	0e 9c       	mov	r12,r7
8000993a:	e0 a0 07 25 	rcall	8000a784 <__multadd>
8000993e:	08 9b       	mov	r11,r4
80009940:	50 4c       	stdsp	sp[0x10],r12
80009942:	30 09       	mov	r9,0
80009944:	30 aa       	mov	r10,10
80009946:	0e 9c       	mov	r12,r7
80009948:	e0 a0 07 1e 	rcall	8000a784 <__multadd>
8000994c:	18 94       	mov	r4,r12
8000994e:	40 9c       	lddsp	r12,sp[0x24]
80009950:	2f fc       	sub	r12,-1
80009952:	50 9c       	stdsp	sp[0x24],r12
80009954:	c7 9b       	rjmp	80009846 <_dtoa_r+0x9de>
80009956:	30 18       	mov	r8,1
80009958:	06 90       	mov	r0,r3
8000995a:	40 85       	lddsp	r5,sp[0x20]
8000995c:	08 93       	mov	r3,r4
8000995e:	0c 94       	mov	r4,r6
80009960:	10 96       	mov	r6,r8
80009962:	04 9b       	mov	r11,r2
80009964:	00 9c       	mov	r12,r0
80009966:	fe b0 f9 f1 	rcall	80008d48 <quorem>
8000996a:	2d 0c       	sub	r12,-48
8000996c:	0a cc       	st.b	r5++,r12
8000996e:	02 36       	cp.w	r6,r1
80009970:	c0 a4       	brge	80009984 <_dtoa_r+0xb1c>
80009972:	00 9b       	mov	r11,r0
80009974:	30 09       	mov	r9,0
80009976:	30 aa       	mov	r10,10
80009978:	0e 9c       	mov	r12,r7
8000997a:	2f f6       	sub	r6,-1
8000997c:	e0 a0 07 04 	rcall	8000a784 <__multadd>
80009980:	18 90       	mov	r0,r12
80009982:	cf 0b       	rjmp	80009962 <_dtoa_r+0xafa>
80009984:	08 96       	mov	r6,r4
80009986:	30 0b       	mov	r11,0
80009988:	06 94       	mov	r4,r3
8000998a:	50 4b       	stdsp	sp[0x10],r11
8000998c:	00 93       	mov	r3,r0
8000998e:	18 90       	mov	r0,r12
80009990:	c0 28       	rjmp	80009994 <_dtoa_r+0xb2c>
80009992:	40 26       	lddsp	r6,sp[0x8]
80009994:	06 9b       	mov	r11,r3
80009996:	30 1a       	mov	r10,1
80009998:	0e 9c       	mov	r12,r7
8000999a:	e0 a0 06 29 	rcall	8000a5ec <__lshift>
8000999e:	04 9b       	mov	r11,r2
800099a0:	18 93       	mov	r3,r12
800099a2:	e0 a0 05 02 	rcall	8000a3a6 <__mcmp>
800099a6:	e0 89 00 12 	brgt	800099ca <_dtoa_r+0xb62>
800099aa:	c1 b1       	brne	800099e0 <_dtoa_r+0xb78>
800099ac:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
800099b0:	c0 d1       	brne	800099ca <_dtoa_r+0xb62>
800099b2:	c1 78       	rjmp	800099e0 <_dtoa_r+0xb78>
800099b4:	40 89       	lddsp	r9,sp[0x20]
800099b6:	12 38       	cp.w	r8,r9
800099b8:	c0 30       	breq	800099be <_dtoa_r+0xb56>
800099ba:	10 95       	mov	r5,r8
800099bc:	c0 88       	rjmp	800099cc <_dtoa_r+0xb64>
800099be:	2f f6       	sub	r6,-1
800099c0:	50 66       	stdsp	sp[0x18],r6
800099c2:	33 18       	mov	r8,49
800099c4:	40 8c       	lddsp	r12,sp[0x20]
800099c6:	b8 88       	st.b	r12[0x0],r8
800099c8:	c1 38       	rjmp	800099ee <_dtoa_r+0xb86>
800099ca:	33 9a       	mov	r10,57
800099cc:	0a 98       	mov	r8,r5
800099ce:	11 79       	ld.ub	r9,--r8
800099d0:	f4 09 18 00 	cp.b	r9,r10
800099d4:	cf 00       	breq	800099b4 <_dtoa_r+0xb4c>
800099d6:	2f f9       	sub	r9,-1
800099d8:	b0 89       	st.b	r8[0x0],r9
800099da:	c0 98       	rjmp	800099ec <_dtoa_r+0xb84>
800099dc:	10 95       	mov	r5,r8
800099de:	c0 28       	rjmp	800099e2 <_dtoa_r+0xb7a>
800099e0:	33 09       	mov	r9,48
800099e2:	0a 98       	mov	r8,r5
800099e4:	11 7a       	ld.ub	r10,--r8
800099e6:	f2 0a 18 00 	cp.b	r10,r9
800099ea:	cf 90       	breq	800099dc <_dtoa_r+0xb74>
800099ec:	50 66       	stdsp	sp[0x18],r6
800099ee:	04 9b       	mov	r11,r2
800099f0:	0e 9c       	mov	r12,r7
800099f2:	e0 a0 04 f3 	rcall	8000a3d8 <_Bfree>
800099f6:	58 04       	cp.w	r4,0
800099f8:	c1 20       	breq	80009a1c <_dtoa_r+0xbb4>
800099fa:	40 4b       	lddsp	r11,sp[0x10]
800099fc:	08 3b       	cp.w	r11,r4
800099fe:	5f 19       	srne	r9
80009a00:	58 0b       	cp.w	r11,0
80009a02:	5f 18       	srne	r8
80009a04:	f3 e8 00 08 	and	r8,r9,r8
80009a08:	c0 40       	breq	80009a10 <_dtoa_r+0xba8>
80009a0a:	0e 9c       	mov	r12,r7
80009a0c:	e0 a0 04 e6 	rcall	8000a3d8 <_Bfree>
80009a10:	08 9b       	mov	r11,r4
80009a12:	0e 9c       	mov	r12,r7
80009a14:	e0 a0 04 e2 	rcall	8000a3d8 <_Bfree>
80009a18:	c0 28       	rjmp	80009a1c <_dtoa_r+0xbb4>
80009a1a:	50 66       	stdsp	sp[0x18],r6
80009a1c:	0e 9c       	mov	r12,r7
80009a1e:	06 9b       	mov	r11,r3
80009a20:	e0 a0 04 dc 	rcall	8000a3d8 <_Bfree>
80009a24:	30 08       	mov	r8,0
80009a26:	aa 88       	st.b	r5[0x0],r8
80009a28:	40 68       	lddsp	r8,sp[0x18]
80009a2a:	41 5a       	lddsp	r10,sp[0x54]
80009a2c:	2f f8       	sub	r8,-1
80009a2e:	41 29       	lddsp	r9,sp[0x48]
80009a30:	95 08       	st.w	r10[0x0],r8
80009a32:	40 8c       	lddsp	r12,sp[0x20]
80009a34:	58 09       	cp.w	r9,0
80009a36:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009a3a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009a3e:	2e 6d       	sub	sp,-104
80009a40:	d8 32       	popm	r0-r7,pc
80009a42:	d7 03       	nop

80009a44 <__errno>:
80009a44:	e0 68 0a 38 	mov	r8,2616
80009a48:	70 0c       	ld.w	r12,r8[0x0]
80009a4a:	2f 4c       	sub	r12,-12
80009a4c:	5e fc       	retal	r12
80009a4e:	d7 03       	nop

80009a50 <_fflush_r>:
80009a50:	d4 21       	pushm	r4-r7,lr
80009a52:	16 97       	mov	r7,r11
80009a54:	18 96       	mov	r6,r12
80009a56:	76 48       	ld.w	r8,r11[0x10]
80009a58:	58 08       	cp.w	r8,0
80009a5a:	c7 f0       	breq	80009b58 <_fflush_r+0x108>
80009a5c:	58 0c       	cp.w	r12,0
80009a5e:	c0 50       	breq	80009a68 <_fflush_r+0x18>
80009a60:	78 68       	ld.w	r8,r12[0x18]
80009a62:	58 08       	cp.w	r8,0
80009a64:	c0 21       	brne	80009a68 <_fflush_r+0x18>
80009a66:	cc dc       	rcall	80009c00 <__sinit>
80009a68:	fe c8 ce 5c 	sub	r8,pc,-12708
80009a6c:	10 37       	cp.w	r7,r8
80009a6e:	c0 31       	brne	80009a74 <_fflush_r+0x24>
80009a70:	6c 07       	ld.w	r7,r6[0x0]
80009a72:	c0 c8       	rjmp	80009a8a <_fflush_r+0x3a>
80009a74:	fe c8 ce 48 	sub	r8,pc,-12728
80009a78:	10 37       	cp.w	r7,r8
80009a7a:	c0 31       	brne	80009a80 <_fflush_r+0x30>
80009a7c:	6c 17       	ld.w	r7,r6[0x4]
80009a7e:	c0 68       	rjmp	80009a8a <_fflush_r+0x3a>
80009a80:	fe c8 ce 34 	sub	r8,pc,-12748
80009a84:	10 37       	cp.w	r7,r8
80009a86:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009a8a:	8e 6a       	ld.sh	r10,r7[0xc]
80009a8c:	14 98       	mov	r8,r10
80009a8e:	ed ba 00 03 	bld	r10,0x3
80009a92:	c4 20       	breq	80009b16 <_fflush_r+0xc6>
80009a94:	ab ba       	sbr	r10,0xb
80009a96:	ae 6a       	st.h	r7[0xc],r10
80009a98:	6e 18       	ld.w	r8,r7[0x4]
80009a9a:	58 08       	cp.w	r8,0
80009a9c:	e0 89 00 06 	brgt	80009aa8 <_fflush_r+0x58>
80009aa0:	6f 08       	ld.w	r8,r7[0x40]
80009aa2:	58 08       	cp.w	r8,0
80009aa4:	e0 8a 00 5a 	brle	80009b58 <_fflush_r+0x108>
80009aa8:	6e b8       	ld.w	r8,r7[0x2c]
80009aaa:	58 08       	cp.w	r8,0
80009aac:	c5 60       	breq	80009b58 <_fflush_r+0x108>
80009aae:	e2 1a 10 00 	andl	r10,0x1000,COH
80009ab2:	c0 30       	breq	80009ab8 <_fflush_r+0x68>
80009ab4:	6f 55       	ld.w	r5,r7[0x54]
80009ab6:	c0 f8       	rjmp	80009ad4 <_fflush_r+0x84>
80009ab8:	30 19       	mov	r9,1
80009aba:	6e 8b       	ld.w	r11,r7[0x20]
80009abc:	0c 9c       	mov	r12,r6
80009abe:	5d 18       	icall	r8
80009ac0:	18 95       	mov	r5,r12
80009ac2:	5b fc       	cp.w	r12,-1
80009ac4:	c0 81       	brne	80009ad4 <_fflush_r+0x84>
80009ac6:	6c 38       	ld.w	r8,r6[0xc]
80009ac8:	59 d8       	cp.w	r8,29
80009aca:	c4 70       	breq	80009b58 <_fflush_r+0x108>
80009acc:	8e 68       	ld.sh	r8,r7[0xc]
80009ace:	a7 a8       	sbr	r8,0x6
80009ad0:	ae 68       	st.h	r7[0xc],r8
80009ad2:	d8 22       	popm	r4-r7,pc
80009ad4:	8e 68       	ld.sh	r8,r7[0xc]
80009ad6:	ed b8 00 02 	bld	r8,0x2
80009ada:	c0 91       	brne	80009aec <_fflush_r+0x9c>
80009adc:	6e 18       	ld.w	r8,r7[0x4]
80009ade:	10 15       	sub	r5,r8
80009ae0:	6e d8       	ld.w	r8,r7[0x34]
80009ae2:	58 08       	cp.w	r8,0
80009ae4:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009ae8:	eb d8 e1 15 	subne	r5,r5,r8
80009aec:	6e b8       	ld.w	r8,r7[0x2c]
80009aee:	0c 9c       	mov	r12,r6
80009af0:	30 09       	mov	r9,0
80009af2:	0a 9a       	mov	r10,r5
80009af4:	6e 8b       	ld.w	r11,r7[0x20]
80009af6:	5d 18       	icall	r8
80009af8:	8e 68       	ld.sh	r8,r7[0xc]
80009afa:	0a 3c       	cp.w	r12,r5
80009afc:	c2 61       	brne	80009b48 <_fflush_r+0xf8>
80009afe:	ab d8       	cbr	r8,0xb
80009b00:	30 0c       	mov	r12,0
80009b02:	6e 49       	ld.w	r9,r7[0x10]
80009b04:	ae 68       	st.h	r7[0xc],r8
80009b06:	8f 1c       	st.w	r7[0x4],r12
80009b08:	8f 09       	st.w	r7[0x0],r9
80009b0a:	ed b8 00 0c 	bld	r8,0xc
80009b0e:	c2 51       	brne	80009b58 <_fflush_r+0x108>
80009b10:	ef 45 00 54 	st.w	r7[84],r5
80009b14:	d8 22       	popm	r4-r7,pc
80009b16:	6e 45       	ld.w	r5,r7[0x10]
80009b18:	58 05       	cp.w	r5,0
80009b1a:	c1 f0       	breq	80009b58 <_fflush_r+0x108>
80009b1c:	6e 04       	ld.w	r4,r7[0x0]
80009b1e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009b22:	8f 05       	st.w	r7[0x0],r5
80009b24:	f9 b8 01 00 	movne	r8,0
80009b28:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009b2c:	0a 14       	sub	r4,r5
80009b2e:	8f 28       	st.w	r7[0x8],r8
80009b30:	c1 18       	rjmp	80009b52 <_fflush_r+0x102>
80009b32:	08 99       	mov	r9,r4
80009b34:	0a 9a       	mov	r10,r5
80009b36:	6e a8       	ld.w	r8,r7[0x28]
80009b38:	6e 8b       	ld.w	r11,r7[0x20]
80009b3a:	0c 9c       	mov	r12,r6
80009b3c:	5d 18       	icall	r8
80009b3e:	18 14       	sub	r4,r12
80009b40:	58 0c       	cp.w	r12,0
80009b42:	e0 89 00 07 	brgt	80009b50 <_fflush_r+0x100>
80009b46:	8e 68       	ld.sh	r8,r7[0xc]
80009b48:	a7 a8       	sbr	r8,0x6
80009b4a:	3f fc       	mov	r12,-1
80009b4c:	ae 68       	st.h	r7[0xc],r8
80009b4e:	d8 22       	popm	r4-r7,pc
80009b50:	18 05       	add	r5,r12
80009b52:	58 04       	cp.w	r4,0
80009b54:	fe 99 ff ef 	brgt	80009b32 <_fflush_r+0xe2>
80009b58:	d8 2a       	popm	r4-r7,pc,r12=0
80009b5a:	d7 03       	nop

80009b5c <__sfp_lock_acquire>:
80009b5c:	5e fc       	retal	r12

80009b5e <__sfp_lock_release>:
80009b5e:	5e fc       	retal	r12

80009b60 <_cleanup_r>:
80009b60:	d4 01       	pushm	lr
80009b62:	fe cb f0 c6 	sub	r11,pc,-3898
80009b66:	e0 a0 02 f7 	rcall	8000a154 <_fwalk>
80009b6a:	d8 02       	popm	pc

80009b6c <__sfmoreglue>:
80009b6c:	d4 21       	pushm	r4-r7,lr
80009b6e:	16 95       	mov	r5,r11
80009b70:	f6 06 10 5c 	mul	r6,r11,92
80009b74:	ec cb ff f4 	sub	r11,r6,-12
80009b78:	fe b0 e2 7c 	rcall	80006070 <_malloc_r>
80009b7c:	18 97       	mov	r7,r12
80009b7e:	c0 90       	breq	80009b90 <__sfmoreglue+0x24>
80009b80:	99 15       	st.w	r12[0x4],r5
80009b82:	30 0b       	mov	r11,0
80009b84:	2f 4c       	sub	r12,-12
80009b86:	0c 9a       	mov	r10,r6
80009b88:	8f 2c       	st.w	r7[0x8],r12
80009b8a:	8f 0b       	st.w	r7[0x0],r11
80009b8c:	fe b0 e5 32 	rcall	800065f0 <memset>
80009b90:	0e 9c       	mov	r12,r7
80009b92:	d8 22       	popm	r4-r7,pc

80009b94 <__sfp>:
80009b94:	d4 21       	pushm	r4-r7,lr
80009b96:	fe c8 cf 26 	sub	r8,pc,-12506
80009b9a:	18 96       	mov	r6,r12
80009b9c:	70 07       	ld.w	r7,r8[0x0]
80009b9e:	6e 68       	ld.w	r8,r7[0x18]
80009ba0:	58 08       	cp.w	r8,0
80009ba2:	c0 31       	brne	80009ba8 <__sfp+0x14>
80009ba4:	0e 9c       	mov	r12,r7
80009ba6:	c2 dc       	rcall	80009c00 <__sinit>
80009ba8:	ee c7 ff 28 	sub	r7,r7,-216
80009bac:	30 05       	mov	r5,0
80009bae:	6e 2c       	ld.w	r12,r7[0x8]
80009bb0:	6e 18       	ld.w	r8,r7[0x4]
80009bb2:	c0 68       	rjmp	80009bbe <__sfp+0x2a>
80009bb4:	98 69       	ld.sh	r9,r12[0xc]
80009bb6:	ea 09 19 00 	cp.h	r9,r5
80009bba:	c1 10       	breq	80009bdc <__sfp+0x48>
80009bbc:	2a 4c       	sub	r12,-92
80009bbe:	20 18       	sub	r8,1
80009bc0:	cf a7       	brpl	80009bb4 <__sfp+0x20>
80009bc2:	6e 08       	ld.w	r8,r7[0x0]
80009bc4:	58 08       	cp.w	r8,0
80009bc6:	c0 61       	brne	80009bd2 <__sfp+0x3e>
80009bc8:	30 4b       	mov	r11,4
80009bca:	0c 9c       	mov	r12,r6
80009bcc:	cd 0f       	rcall	80009b6c <__sfmoreglue>
80009bce:	8f 0c       	st.w	r7[0x0],r12
80009bd0:	c0 30       	breq	80009bd6 <__sfp+0x42>
80009bd2:	6e 07       	ld.w	r7,r7[0x0]
80009bd4:	ce db       	rjmp	80009bae <__sfp+0x1a>
80009bd6:	30 c8       	mov	r8,12
80009bd8:	8d 38       	st.w	r6[0xc],r8
80009bda:	d8 22       	popm	r4-r7,pc
80009bdc:	30 08       	mov	r8,0
80009bde:	f9 48 00 4c 	st.w	r12[76],r8
80009be2:	99 08       	st.w	r12[0x0],r8
80009be4:	99 28       	st.w	r12[0x8],r8
80009be6:	99 18       	st.w	r12[0x4],r8
80009be8:	99 48       	st.w	r12[0x10],r8
80009bea:	99 58       	st.w	r12[0x14],r8
80009bec:	99 68       	st.w	r12[0x18],r8
80009bee:	99 d8       	st.w	r12[0x34],r8
80009bf0:	99 e8       	st.w	r12[0x38],r8
80009bf2:	f9 48 00 48 	st.w	r12[72],r8
80009bf6:	3f f8       	mov	r8,-1
80009bf8:	b8 78       	st.h	r12[0xe],r8
80009bfa:	30 18       	mov	r8,1
80009bfc:	b8 68       	st.h	r12[0xc],r8
80009bfe:	d8 22       	popm	r4-r7,pc

80009c00 <__sinit>:
80009c00:	d4 21       	pushm	r4-r7,lr
80009c02:	18 96       	mov	r6,r12
80009c04:	78 67       	ld.w	r7,r12[0x18]
80009c06:	58 07       	cp.w	r7,0
80009c08:	c4 91       	brne	80009c9a <__sinit+0x9a>
80009c0a:	fe c8 00 aa 	sub	r8,pc,170
80009c0e:	30 15       	mov	r5,1
80009c10:	99 a8       	st.w	r12[0x28],r8
80009c12:	f9 47 00 d8 	st.w	r12[216],r7
80009c16:	f9 47 00 dc 	st.w	r12[220],r7
80009c1a:	f9 47 00 e0 	st.w	r12[224],r7
80009c1e:	99 65       	st.w	r12[0x18],r5
80009c20:	cb af       	rcall	80009b94 <__sfp>
80009c22:	8d 0c       	st.w	r6[0x0],r12
80009c24:	0c 9c       	mov	r12,r6
80009c26:	cb 7f       	rcall	80009b94 <__sfp>
80009c28:	8d 1c       	st.w	r6[0x4],r12
80009c2a:	0c 9c       	mov	r12,r6
80009c2c:	cb 4f       	rcall	80009b94 <__sfp>
80009c2e:	6c 09       	ld.w	r9,r6[0x0]
80009c30:	30 48       	mov	r8,4
80009c32:	93 07       	st.w	r9[0x0],r7
80009c34:	b2 68       	st.h	r9[0xc],r8
80009c36:	93 17       	st.w	r9[0x4],r7
80009c38:	93 27       	st.w	r9[0x8],r7
80009c3a:	6c 18       	ld.w	r8,r6[0x4]
80009c3c:	b2 77       	st.h	r9[0xe],r7
80009c3e:	93 47       	st.w	r9[0x10],r7
80009c40:	93 57       	st.w	r9[0x14],r7
80009c42:	93 67       	st.w	r9[0x18],r7
80009c44:	93 89       	st.w	r9[0x20],r9
80009c46:	91 07       	st.w	r8[0x0],r7
80009c48:	91 17       	st.w	r8[0x4],r7
80009c4a:	91 27       	st.w	r8[0x8],r7
80009c4c:	fe ce f3 24 	sub	lr,pc,-3292
80009c50:	fe cb f3 54 	sub	r11,pc,-3244
80009c54:	93 9e       	st.w	r9[0x24],lr
80009c56:	93 ab       	st.w	r9[0x28],r11
80009c58:	fe ca f3 7c 	sub	r10,pc,-3204
80009c5c:	fe c4 f3 88 	sub	r4,pc,-3192
80009c60:	93 ba       	st.w	r9[0x2c],r10
80009c62:	93 c4       	st.w	r9[0x30],r4
80009c64:	30 99       	mov	r9,9
80009c66:	b0 69       	st.h	r8[0xc],r9
80009c68:	b0 75       	st.h	r8[0xe],r5
80009c6a:	91 c4       	st.w	r8[0x30],r4
80009c6c:	91 47       	st.w	r8[0x10],r7
80009c6e:	91 57       	st.w	r8[0x14],r7
80009c70:	91 67       	st.w	r8[0x18],r7
80009c72:	91 88       	st.w	r8[0x20],r8
80009c74:	91 9e       	st.w	r8[0x24],lr
80009c76:	91 ab       	st.w	r8[0x28],r11
80009c78:	91 ba       	st.w	r8[0x2c],r10
80009c7a:	8d 2c       	st.w	r6[0x8],r12
80009c7c:	31 28       	mov	r8,18
80009c7e:	99 07       	st.w	r12[0x0],r7
80009c80:	b8 68       	st.h	r12[0xc],r8
80009c82:	99 17       	st.w	r12[0x4],r7
80009c84:	99 27       	st.w	r12[0x8],r7
80009c86:	30 28       	mov	r8,2
80009c88:	b8 78       	st.h	r12[0xe],r8
80009c8a:	99 c4       	st.w	r12[0x30],r4
80009c8c:	99 67       	st.w	r12[0x18],r7
80009c8e:	99 9e       	st.w	r12[0x24],lr
80009c90:	99 ab       	st.w	r12[0x28],r11
80009c92:	99 ba       	st.w	r12[0x2c],r10
80009c94:	99 47       	st.w	r12[0x10],r7
80009c96:	99 57       	st.w	r12[0x14],r7
80009c98:	99 8c       	st.w	r12[0x20],r12
80009c9a:	d8 22       	popm	r4-r7,pc

80009c9c <_malloc_trim_r>:
80009c9c:	d4 21       	pushm	r4-r7,lr
80009c9e:	16 95       	mov	r5,r11
80009ca0:	18 97       	mov	r7,r12
80009ca2:	fe b0 d7 53 	rcall	80004b48 <__malloc_lock>
80009ca6:	e0 64 05 38 	mov	r4,1336
80009caa:	68 28       	ld.w	r8,r4[0x8]
80009cac:	70 16       	ld.w	r6,r8[0x4]
80009cae:	e0 16 ff fc 	andl	r6,0xfffc
80009cb2:	ec c8 ff 91 	sub	r8,r6,-111
80009cb6:	f0 05 01 05 	sub	r5,r8,r5
80009cba:	e0 15 ff 80 	andl	r5,0xff80
80009cbe:	ea c5 00 80 	sub	r5,r5,128
80009cc2:	e0 45 00 7f 	cp.w	r5,127
80009cc6:	e0 8a 00 25 	brle	80009d10 <_malloc_trim_r+0x74>
80009cca:	30 0b       	mov	r11,0
80009ccc:	0e 9c       	mov	r12,r7
80009cce:	fe b0 e5 f9 	rcall	800068c0 <_sbrk_r>
80009cd2:	68 28       	ld.w	r8,r4[0x8]
80009cd4:	0c 08       	add	r8,r6
80009cd6:	10 3c       	cp.w	r12,r8
80009cd8:	c1 c1       	brne	80009d10 <_malloc_trim_r+0x74>
80009cda:	ea 0b 11 00 	rsub	r11,r5,0
80009cde:	0e 9c       	mov	r12,r7
80009ce0:	fe b0 e5 f0 	rcall	800068c0 <_sbrk_r>
80009ce4:	5b fc       	cp.w	r12,-1
80009ce6:	c1 91       	brne	80009d18 <_malloc_trim_r+0x7c>
80009ce8:	30 0b       	mov	r11,0
80009cea:	0e 9c       	mov	r12,r7
80009cec:	fe b0 e5 ea 	rcall	800068c0 <_sbrk_r>
80009cf0:	68 28       	ld.w	r8,r4[0x8]
80009cf2:	f8 08 01 09 	sub	r9,r12,r8
80009cf6:	58 f9       	cp.w	r9,15
80009cf8:	e0 8a 00 0c 	brle	80009d10 <_malloc_trim_r+0x74>
80009cfc:	a1 a9       	sbr	r9,0x0
80009cfe:	91 19       	st.w	r8[0x4],r9
80009d00:	e0 68 09 44 	mov	r8,2372
80009d04:	70 09       	ld.w	r9,r8[0x0]
80009d06:	e0 68 0d 7c 	mov	r8,3452
80009d0a:	f8 09 01 09 	sub	r9,r12,r9
80009d0e:	91 09       	st.w	r8[0x0],r9
80009d10:	0e 9c       	mov	r12,r7
80009d12:	fe b0 d7 21 	rcall	80004b54 <__malloc_unlock>
80009d16:	d8 2a       	popm	r4-r7,pc,r12=0
80009d18:	68 28       	ld.w	r8,r4[0x8]
80009d1a:	0a 16       	sub	r6,r5
80009d1c:	a1 a6       	sbr	r6,0x0
80009d1e:	91 16       	st.w	r8[0x4],r6
80009d20:	e0 68 0d 7c 	mov	r8,3452
80009d24:	70 09       	ld.w	r9,r8[0x0]
80009d26:	0a 19       	sub	r9,r5
80009d28:	0e 9c       	mov	r12,r7
80009d2a:	91 09       	st.w	r8[0x0],r9
80009d2c:	fe b0 d7 14 	rcall	80004b54 <__malloc_unlock>
80009d30:	da 2a       	popm	r4-r7,pc,r12=1
80009d32:	d7 03       	nop

80009d34 <_free_r>:
80009d34:	d4 21       	pushm	r4-r7,lr
80009d36:	16 96       	mov	r6,r11
80009d38:	18 97       	mov	r7,r12
80009d3a:	58 0b       	cp.w	r11,0
80009d3c:	e0 80 00 c0 	breq	80009ebc <_free_r+0x188>
80009d40:	fe b0 d7 04 	rcall	80004b48 <__malloc_lock>
80009d44:	20 86       	sub	r6,8
80009d46:	e0 6a 05 38 	mov	r10,1336
80009d4a:	6c 18       	ld.w	r8,r6[0x4]
80009d4c:	74 2e       	ld.w	lr,r10[0x8]
80009d4e:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80009d52:	a1 c8       	cbr	r8,0x0
80009d54:	ec 08 00 09 	add	r9,r6,r8
80009d58:	72 1b       	ld.w	r11,r9[0x4]
80009d5a:	e0 1b ff fc 	andl	r11,0xfffc
80009d5e:	1c 39       	cp.w	r9,lr
80009d60:	c1 e1       	brne	80009d9c <_free_r+0x68>
80009d62:	f6 08 00 08 	add	r8,r11,r8
80009d66:	58 0c       	cp.w	r12,0
80009d68:	c0 81       	brne	80009d78 <_free_r+0x44>
80009d6a:	6c 09       	ld.w	r9,r6[0x0]
80009d6c:	12 16       	sub	r6,r9
80009d6e:	12 08       	add	r8,r9
80009d70:	6c 3b       	ld.w	r11,r6[0xc]
80009d72:	6c 29       	ld.w	r9,r6[0x8]
80009d74:	97 29       	st.w	r11[0x8],r9
80009d76:	93 3b       	st.w	r9[0xc],r11
80009d78:	10 99       	mov	r9,r8
80009d7a:	95 26       	st.w	r10[0x8],r6
80009d7c:	a1 a9       	sbr	r9,0x0
80009d7e:	8d 19       	st.w	r6[0x4],r9
80009d80:	e0 69 09 40 	mov	r9,2368
80009d84:	72 09       	ld.w	r9,r9[0x0]
80009d86:	12 38       	cp.w	r8,r9
80009d88:	c0 63       	brcs	80009d94 <_free_r+0x60>
80009d8a:	e0 68 0d 78 	mov	r8,3448
80009d8e:	0e 9c       	mov	r12,r7
80009d90:	70 0b       	ld.w	r11,r8[0x0]
80009d92:	c8 5f       	rcall	80009c9c <_malloc_trim_r>
80009d94:	0e 9c       	mov	r12,r7
80009d96:	fe b0 d6 df 	rcall	80004b54 <__malloc_unlock>
80009d9a:	d8 22       	popm	r4-r7,pc
80009d9c:	93 1b       	st.w	r9[0x4],r11
80009d9e:	58 0c       	cp.w	r12,0
80009da0:	c0 30       	breq	80009da6 <_free_r+0x72>
80009da2:	30 0c       	mov	r12,0
80009da4:	c1 08       	rjmp	80009dc4 <_free_r+0x90>
80009da6:	6c 0e       	ld.w	lr,r6[0x0]
80009da8:	f4 c5 ff f8 	sub	r5,r10,-8
80009dac:	1c 16       	sub	r6,lr
80009dae:	1c 08       	add	r8,lr
80009db0:	6c 2e       	ld.w	lr,r6[0x8]
80009db2:	0a 3e       	cp.w	lr,r5
80009db4:	f9 bc 00 01 	moveq	r12,1
80009db8:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80009dbc:	eb fe 1a 02 	st.wne	r5[0x8],lr
80009dc0:	fd f5 1a 03 	st.wne	lr[0xc],r5
80009dc4:	f2 0b 00 0e 	add	lr,r9,r11
80009dc8:	7c 1e       	ld.w	lr,lr[0x4]
80009dca:	ed be 00 00 	bld	lr,0x0
80009dce:	c1 40       	breq	80009df6 <_free_r+0xc2>
80009dd0:	16 08       	add	r8,r11
80009dd2:	58 0c       	cp.w	r12,0
80009dd4:	c0 d1       	brne	80009dee <_free_r+0xba>
80009dd6:	e0 6e 05 38 	mov	lr,1336
80009dda:	72 2b       	ld.w	r11,r9[0x8]
80009ddc:	2f 8e       	sub	lr,-8
80009dde:	1c 3b       	cp.w	r11,lr
80009de0:	c0 71       	brne	80009dee <_free_r+0xba>
80009de2:	97 36       	st.w	r11[0xc],r6
80009de4:	97 26       	st.w	r11[0x8],r6
80009de6:	8d 2b       	st.w	r6[0x8],r11
80009de8:	8d 3b       	st.w	r6[0xc],r11
80009dea:	30 1c       	mov	r12,1
80009dec:	c0 58       	rjmp	80009df6 <_free_r+0xc2>
80009dee:	72 2b       	ld.w	r11,r9[0x8]
80009df0:	72 39       	ld.w	r9,r9[0xc]
80009df2:	93 2b       	st.w	r9[0x8],r11
80009df4:	97 39       	st.w	r11[0xc],r9
80009df6:	10 99       	mov	r9,r8
80009df8:	ec 08 09 08 	st.w	r6[r8],r8
80009dfc:	a1 a9       	sbr	r9,0x0
80009dfe:	8d 19       	st.w	r6[0x4],r9
80009e00:	58 0c       	cp.w	r12,0
80009e02:	c5 a1       	brne	80009eb6 <_free_r+0x182>
80009e04:	e0 48 01 ff 	cp.w	r8,511
80009e08:	e0 8b 00 13 	brhi	80009e2e <_free_r+0xfa>
80009e0c:	a3 98       	lsr	r8,0x3
80009e0e:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009e12:	72 2b       	ld.w	r11,r9[0x8]
80009e14:	8d 39       	st.w	r6[0xc],r9
80009e16:	8d 2b       	st.w	r6[0x8],r11
80009e18:	97 36       	st.w	r11[0xc],r6
80009e1a:	93 26       	st.w	r9[0x8],r6
80009e1c:	a3 48       	asr	r8,0x2
80009e1e:	74 19       	ld.w	r9,r10[0x4]
80009e20:	30 1b       	mov	r11,1
80009e22:	f6 08 09 48 	lsl	r8,r11,r8
80009e26:	f3 e8 10 08 	or	r8,r9,r8
80009e2a:	95 18       	st.w	r10[0x4],r8
80009e2c:	c4 58       	rjmp	80009eb6 <_free_r+0x182>
80009e2e:	f0 0b 16 09 	lsr	r11,r8,0x9
80009e32:	58 4b       	cp.w	r11,4
80009e34:	e0 8b 00 06 	brhi	80009e40 <_free_r+0x10c>
80009e38:	f0 0b 16 06 	lsr	r11,r8,0x6
80009e3c:	2c 8b       	sub	r11,-56
80009e3e:	c2 08       	rjmp	80009e7e <_free_r+0x14a>
80009e40:	59 4b       	cp.w	r11,20
80009e42:	e0 8b 00 04 	brhi	80009e4a <_free_r+0x116>
80009e46:	2a 5b       	sub	r11,-91
80009e48:	c1 b8       	rjmp	80009e7e <_free_r+0x14a>
80009e4a:	e0 4b 00 54 	cp.w	r11,84
80009e4e:	e0 8b 00 06 	brhi	80009e5a <_free_r+0x126>
80009e52:	f0 0b 16 0c 	lsr	r11,r8,0xc
80009e56:	29 2b       	sub	r11,-110
80009e58:	c1 38       	rjmp	80009e7e <_free_r+0x14a>
80009e5a:	e0 4b 01 54 	cp.w	r11,340
80009e5e:	e0 8b 00 06 	brhi	80009e6a <_free_r+0x136>
80009e62:	f0 0b 16 0f 	lsr	r11,r8,0xf
80009e66:	28 9b       	sub	r11,-119
80009e68:	c0 b8       	rjmp	80009e7e <_free_r+0x14a>
80009e6a:	e0 4b 05 54 	cp.w	r11,1364
80009e6e:	e0 88 00 05 	brls	80009e78 <_free_r+0x144>
80009e72:	37 eb       	mov	r11,126
80009e74:	c0 58       	rjmp	80009e7e <_free_r+0x14a>
80009e76:	d7 03       	nop
80009e78:	f0 0b 16 12 	lsr	r11,r8,0x12
80009e7c:	28 4b       	sub	r11,-124
80009e7e:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80009e82:	78 29       	ld.w	r9,r12[0x8]
80009e84:	18 39       	cp.w	r9,r12
80009e86:	c0 e1       	brne	80009ea2 <_free_r+0x16e>
80009e88:	74 18       	ld.w	r8,r10[0x4]
80009e8a:	a3 4b       	asr	r11,0x2
80009e8c:	30 1c       	mov	r12,1
80009e8e:	f8 0b 09 4b 	lsl	r11,r12,r11
80009e92:	f1 eb 10 0b 	or	r11,r8,r11
80009e96:	12 98       	mov	r8,r9
80009e98:	95 1b       	st.w	r10[0x4],r11
80009e9a:	c0 a8       	rjmp	80009eae <_free_r+0x17a>
80009e9c:	72 29       	ld.w	r9,r9[0x8]
80009e9e:	18 39       	cp.w	r9,r12
80009ea0:	c0 60       	breq	80009eac <_free_r+0x178>
80009ea2:	72 1a       	ld.w	r10,r9[0x4]
80009ea4:	e0 1a ff fc 	andl	r10,0xfffc
80009ea8:	14 38       	cp.w	r8,r10
80009eaa:	cf 93       	brcs	80009e9c <_free_r+0x168>
80009eac:	72 38       	ld.w	r8,r9[0xc]
80009eae:	8d 38       	st.w	r6[0xc],r8
80009eb0:	8d 29       	st.w	r6[0x8],r9
80009eb2:	93 36       	st.w	r9[0xc],r6
80009eb4:	91 26       	st.w	r8[0x8],r6
80009eb6:	0e 9c       	mov	r12,r7
80009eb8:	fe b0 d6 4e 	rcall	80004b54 <__malloc_unlock>
80009ebc:	d8 22       	popm	r4-r7,pc
80009ebe:	d7 03       	nop

80009ec0 <__sfvwrite_r>:
80009ec0:	d4 31       	pushm	r0-r7,lr
80009ec2:	20 3d       	sub	sp,12
80009ec4:	14 94       	mov	r4,r10
80009ec6:	18 95       	mov	r5,r12
80009ec8:	16 97       	mov	r7,r11
80009eca:	74 28       	ld.w	r8,r10[0x8]
80009ecc:	58 08       	cp.w	r8,0
80009ece:	e0 80 01 40 	breq	8000a14e <__sfvwrite_r+0x28e>
80009ed2:	96 68       	ld.sh	r8,r11[0xc]
80009ed4:	ed b8 00 03 	bld	r8,0x3
80009ed8:	c0 41       	brne	80009ee0 <__sfvwrite_r+0x20>
80009eda:	76 48       	ld.w	r8,r11[0x10]
80009edc:	58 08       	cp.w	r8,0
80009ede:	c0 c1       	brne	80009ef6 <__sfvwrite_r+0x36>
80009ee0:	0e 9b       	mov	r11,r7
80009ee2:	0a 9c       	mov	r12,r5
80009ee4:	fe b0 f6 c4 	rcall	80008c6c <__swsetup_r>
80009ee8:	c0 70       	breq	80009ef6 <__sfvwrite_r+0x36>
80009eea:	8e 68       	ld.sh	r8,r7[0xc]
80009eec:	a7 a8       	sbr	r8,0x6
80009eee:	ae 68       	st.h	r7[0xc],r8
80009ef0:	30 98       	mov	r8,9
80009ef2:	8b 38       	st.w	r5[0xc],r8
80009ef4:	c2 b9       	rjmp	8000a14a <__sfvwrite_r+0x28a>
80009ef6:	8e 63       	ld.sh	r3,r7[0xc]
80009ef8:	68 00       	ld.w	r0,r4[0x0]
80009efa:	06 96       	mov	r6,r3
80009efc:	e2 16 00 02 	andl	r6,0x2,COH
80009f00:	c2 10       	breq	80009f42 <__sfvwrite_r+0x82>
80009f02:	30 03       	mov	r3,0
80009f04:	e0 62 04 00 	mov	r2,1024
80009f08:	06 96       	mov	r6,r3
80009f0a:	c0 48       	rjmp	80009f12 <__sfvwrite_r+0x52>
80009f0c:	60 03       	ld.w	r3,r0[0x0]
80009f0e:	60 16       	ld.w	r6,r0[0x4]
80009f10:	2f 80       	sub	r0,-8
80009f12:	58 06       	cp.w	r6,0
80009f14:	cf c0       	breq	80009f0c <__sfvwrite_r+0x4c>
80009f16:	e0 46 04 00 	cp.w	r6,1024
80009f1a:	ec 09 17 80 	movls	r9,r6
80009f1e:	e4 09 17 b0 	movhi	r9,r2
80009f22:	06 9a       	mov	r10,r3
80009f24:	6e a8       	ld.w	r8,r7[0x28]
80009f26:	6e 8b       	ld.w	r11,r7[0x20]
80009f28:	0a 9c       	mov	r12,r5
80009f2a:	5d 18       	icall	r8
80009f2c:	18 16       	sub	r6,r12
80009f2e:	58 0c       	cp.w	r12,0
80009f30:	e0 8a 01 0a 	brle	8000a144 <__sfvwrite_r+0x284>
80009f34:	68 28       	ld.w	r8,r4[0x8]
80009f36:	18 18       	sub	r8,r12
80009f38:	89 28       	st.w	r4[0x8],r8
80009f3a:	e0 80 01 0a 	breq	8000a14e <__sfvwrite_r+0x28e>
80009f3e:	18 03       	add	r3,r12
80009f40:	ce 9b       	rjmp	80009f12 <__sfvwrite_r+0x52>
80009f42:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80009f46:	c0 70       	breq	80009f54 <__sfvwrite_r+0x94>
80009f48:	50 06       	stdsp	sp[0x0],r6
80009f4a:	0c 93       	mov	r3,r6
80009f4c:	0c 91       	mov	r1,r6
80009f4e:	50 15       	stdsp	sp[0x4],r5
80009f50:	08 92       	mov	r2,r4
80009f52:	c9 c8       	rjmp	8000a08a <__sfvwrite_r+0x1ca>
80009f54:	06 96       	mov	r6,r3
80009f56:	08 91       	mov	r1,r4
80009f58:	c0 48       	rjmp	80009f60 <__sfvwrite_r+0xa0>
80009f5a:	60 03       	ld.w	r3,r0[0x0]
80009f5c:	60 16       	ld.w	r6,r0[0x4]
80009f5e:	2f 80       	sub	r0,-8
80009f60:	58 06       	cp.w	r6,0
80009f62:	cf c0       	breq	80009f5a <__sfvwrite_r+0x9a>
80009f64:	8e 68       	ld.sh	r8,r7[0xc]
80009f66:	6e 24       	ld.w	r4,r7[0x8]
80009f68:	10 99       	mov	r9,r8
80009f6a:	e2 19 02 00 	andl	r9,0x200,COH
80009f6e:	c5 50       	breq	8000a018 <__sfvwrite_r+0x158>
80009f70:	08 36       	cp.w	r6,r4
80009f72:	c4 43       	brcs	80009ffa <__sfvwrite_r+0x13a>
80009f74:	10 99       	mov	r9,r8
80009f76:	e2 19 04 80 	andl	r9,0x480,COH
80009f7a:	c4 00       	breq	80009ffa <__sfvwrite_r+0x13a>
80009f7c:	6e 4b       	ld.w	r11,r7[0x10]
80009f7e:	6e 09       	ld.w	r9,r7[0x0]
80009f80:	16 19       	sub	r9,r11
80009f82:	50 09       	stdsp	sp[0x0],r9
80009f84:	6e 59       	ld.w	r9,r7[0x14]
80009f86:	10 9c       	mov	r12,r8
80009f88:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80009f8c:	30 28       	mov	r8,2
80009f8e:	f4 08 0c 08 	divs	r8,r10,r8
80009f92:	fa e9 00 04 	st.d	sp[4],r8
80009f96:	10 94       	mov	r4,r8
80009f98:	40 09       	lddsp	r9,sp[0x0]
80009f9a:	e2 1c 04 00 	andl	r12,0x400,COH
80009f9e:	2f f9       	sub	r9,-1
80009fa0:	0c 09       	add	r9,r6
80009fa2:	12 38       	cp.w	r8,r9
80009fa4:	f2 04 17 30 	movlo	r4,r9
80009fa8:	58 0c       	cp.w	r12,0
80009faa:	c1 10       	breq	80009fcc <__sfvwrite_r+0x10c>
80009fac:	08 9b       	mov	r11,r4
80009fae:	0a 9c       	mov	r12,r5
80009fb0:	fe b0 e0 60 	rcall	80006070 <_malloc_r>
80009fb4:	18 92       	mov	r2,r12
80009fb6:	c1 40       	breq	80009fde <__sfvwrite_r+0x11e>
80009fb8:	40 0a       	lddsp	r10,sp[0x0]
80009fba:	6e 4b       	ld.w	r11,r7[0x10]
80009fbc:	fe b0 e2 76 	rcall	800064a8 <memcpy>
80009fc0:	8e 68       	ld.sh	r8,r7[0xc]
80009fc2:	e0 18 fb 7f 	andl	r8,0xfb7f
80009fc6:	a7 b8       	sbr	r8,0x7
80009fc8:	ae 68       	st.h	r7[0xc],r8
80009fca:	c0 d8       	rjmp	80009fe4 <__sfvwrite_r+0x124>
80009fcc:	08 9a       	mov	r10,r4
80009fce:	0a 9c       	mov	r12,r5
80009fd0:	fe b0 e3 18 	rcall	80006600 <_realloc_r>
80009fd4:	18 92       	mov	r2,r12
80009fd6:	c0 71       	brne	80009fe4 <__sfvwrite_r+0x124>
80009fd8:	6e 4b       	ld.w	r11,r7[0x10]
80009fda:	0a 9c       	mov	r12,r5
80009fdc:	ca ce       	rcall	80009d34 <_free_r>
80009fde:	30 c8       	mov	r8,12
80009fe0:	8b 38       	st.w	r5[0xc],r8
80009fe2:	cb 18       	rjmp	8000a144 <__sfvwrite_r+0x284>
80009fe4:	40 0a       	lddsp	r10,sp[0x0]
80009fe6:	40 09       	lddsp	r9,sp[0x0]
80009fe8:	e8 0a 01 0a 	sub	r10,r4,r10
80009fec:	e4 09 00 08 	add	r8,r2,r9
80009ff0:	8f 54       	st.w	r7[0x14],r4
80009ff2:	8f 2a       	st.w	r7[0x8],r10
80009ff4:	8f 08       	st.w	r7[0x0],r8
80009ff6:	8f 42       	st.w	r7[0x10],r2
80009ff8:	0c 94       	mov	r4,r6
80009ffa:	08 36       	cp.w	r6,r4
80009ffc:	ec 04 17 30 	movlo	r4,r6
8000a000:	06 9b       	mov	r11,r3
8000a002:	08 9a       	mov	r10,r4
8000a004:	6e 0c       	ld.w	r12,r7[0x0]
8000a006:	c3 ad       	rcall	8000a27a <memmove>
8000a008:	6e 08       	ld.w	r8,r7[0x0]
8000a00a:	08 08       	add	r8,r4
8000a00c:	8f 08       	st.w	r7[0x0],r8
8000a00e:	6e 28       	ld.w	r8,r7[0x8]
8000a010:	08 18       	sub	r8,r4
8000a012:	0c 94       	mov	r4,r6
8000a014:	8f 28       	st.w	r7[0x8],r8
8000a016:	c2 e8       	rjmp	8000a072 <__sfvwrite_r+0x1b2>
8000a018:	08 36       	cp.w	r6,r4
8000a01a:	5f ba       	srhi	r10
8000a01c:	6e 0c       	ld.w	r12,r7[0x0]
8000a01e:	6e 48       	ld.w	r8,r7[0x10]
8000a020:	10 3c       	cp.w	r12,r8
8000a022:	5f b8       	srhi	r8
8000a024:	f5 e8 00 08 	and	r8,r10,r8
8000a028:	f2 08 18 00 	cp.b	r8,r9
8000a02c:	c0 d0       	breq	8000a046 <__sfvwrite_r+0x186>
8000a02e:	06 9b       	mov	r11,r3
8000a030:	08 9a       	mov	r10,r4
8000a032:	c2 4d       	rcall	8000a27a <memmove>
8000a034:	6e 08       	ld.w	r8,r7[0x0]
8000a036:	08 08       	add	r8,r4
8000a038:	0e 9b       	mov	r11,r7
8000a03a:	8f 08       	st.w	r7[0x0],r8
8000a03c:	0a 9c       	mov	r12,r5
8000a03e:	fe b0 fd 09 	rcall	80009a50 <_fflush_r>
8000a042:	c1 80       	breq	8000a072 <__sfvwrite_r+0x1b2>
8000a044:	c8 08       	rjmp	8000a144 <__sfvwrite_r+0x284>
8000a046:	6e 59       	ld.w	r9,r7[0x14]
8000a048:	12 36       	cp.w	r6,r9
8000a04a:	c0 a3       	brcs	8000a05e <__sfvwrite_r+0x19e>
8000a04c:	6e a8       	ld.w	r8,r7[0x28]
8000a04e:	06 9a       	mov	r10,r3
8000a050:	6e 8b       	ld.w	r11,r7[0x20]
8000a052:	0a 9c       	mov	r12,r5
8000a054:	5d 18       	icall	r8
8000a056:	18 94       	mov	r4,r12
8000a058:	e0 89 00 0d 	brgt	8000a072 <__sfvwrite_r+0x1b2>
8000a05c:	c7 48       	rjmp	8000a144 <__sfvwrite_r+0x284>
8000a05e:	0c 9a       	mov	r10,r6
8000a060:	06 9b       	mov	r11,r3
8000a062:	c0 cd       	rcall	8000a27a <memmove>
8000a064:	6e 08       	ld.w	r8,r7[0x0]
8000a066:	0c 08       	add	r8,r6
8000a068:	0c 94       	mov	r4,r6
8000a06a:	8f 08       	st.w	r7[0x0],r8
8000a06c:	6e 28       	ld.w	r8,r7[0x8]
8000a06e:	0c 18       	sub	r8,r6
8000a070:	8f 28       	st.w	r7[0x8],r8
8000a072:	62 28       	ld.w	r8,r1[0x8]
8000a074:	08 18       	sub	r8,r4
8000a076:	83 28       	st.w	r1[0x8],r8
8000a078:	c6 b0       	breq	8000a14e <__sfvwrite_r+0x28e>
8000a07a:	08 16       	sub	r6,r4
8000a07c:	08 03       	add	r3,r4
8000a07e:	c7 1b       	rjmp	80009f60 <__sfvwrite_r+0xa0>
8000a080:	60 03       	ld.w	r3,r0[0x0]
8000a082:	60 11       	ld.w	r1,r0[0x4]
8000a084:	30 08       	mov	r8,0
8000a086:	2f 80       	sub	r0,-8
8000a088:	50 08       	stdsp	sp[0x0],r8
8000a08a:	58 01       	cp.w	r1,0
8000a08c:	cf a0       	breq	8000a080 <__sfvwrite_r+0x1c0>
8000a08e:	40 0a       	lddsp	r10,sp[0x0]
8000a090:	58 0a       	cp.w	r10,0
8000a092:	c1 41       	brne	8000a0ba <__sfvwrite_r+0x1fa>
8000a094:	e2 c6 ff ff 	sub	r6,r1,-1
8000a098:	02 9a       	mov	r10,r1
8000a09a:	30 ab       	mov	r11,10
8000a09c:	06 9c       	mov	r12,r3
8000a09e:	ce 3c       	rcall	8000a264 <memchr>
8000a0a0:	f8 c8 ff ff 	sub	r8,r12,-1
8000a0a4:	58 0c       	cp.w	r12,0
8000a0a6:	f1 d3 e1 16 	subne	r6,r8,r3
8000a0aa:	f9 b9 01 01 	movne	r9,1
8000a0ae:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a0b2:	f9 b8 00 01 	moveq	r8,1
8000a0b6:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a0ba:	02 36       	cp.w	r6,r1
8000a0bc:	ec 04 17 80 	movls	r4,r6
8000a0c0:	e2 04 17 b0 	movhi	r4,r1
8000a0c4:	6e 59       	ld.w	r9,r7[0x14]
8000a0c6:	6e 25       	ld.w	r5,r7[0x8]
8000a0c8:	f2 05 00 05 	add	r5,r9,r5
8000a0cc:	0a 34       	cp.w	r4,r5
8000a0ce:	5f 9a       	srgt	r10
8000a0d0:	6e 0c       	ld.w	r12,r7[0x0]
8000a0d2:	6e 48       	ld.w	r8,r7[0x10]
8000a0d4:	10 3c       	cp.w	r12,r8
8000a0d6:	5f b8       	srhi	r8
8000a0d8:	f5 e8 00 08 	and	r8,r10,r8
8000a0dc:	30 0a       	mov	r10,0
8000a0de:	f4 08 18 00 	cp.b	r8,r10
8000a0e2:	c0 d0       	breq	8000a0fc <__sfvwrite_r+0x23c>
8000a0e4:	06 9b       	mov	r11,r3
8000a0e6:	0a 9a       	mov	r10,r5
8000a0e8:	cc 9c       	rcall	8000a27a <memmove>
8000a0ea:	6e 08       	ld.w	r8,r7[0x0]
8000a0ec:	0a 08       	add	r8,r5
8000a0ee:	0e 9b       	mov	r11,r7
8000a0f0:	8f 08       	st.w	r7[0x0],r8
8000a0f2:	40 1c       	lddsp	r12,sp[0x4]
8000a0f4:	fe b0 fc ae 	rcall	80009a50 <_fflush_r>
8000a0f8:	c1 70       	breq	8000a126 <__sfvwrite_r+0x266>
8000a0fa:	c2 58       	rjmp	8000a144 <__sfvwrite_r+0x284>
8000a0fc:	12 34       	cp.w	r4,r9
8000a0fe:	c0 a5       	brlt	8000a112 <__sfvwrite_r+0x252>
8000a100:	6e a8       	ld.w	r8,r7[0x28]
8000a102:	06 9a       	mov	r10,r3
8000a104:	6e 8b       	ld.w	r11,r7[0x20]
8000a106:	40 1c       	lddsp	r12,sp[0x4]
8000a108:	5d 18       	icall	r8
8000a10a:	18 95       	mov	r5,r12
8000a10c:	e0 89 00 0d 	brgt	8000a126 <__sfvwrite_r+0x266>
8000a110:	c1 a8       	rjmp	8000a144 <__sfvwrite_r+0x284>
8000a112:	08 9a       	mov	r10,r4
8000a114:	06 9b       	mov	r11,r3
8000a116:	cb 2c       	rcall	8000a27a <memmove>
8000a118:	6e 08       	ld.w	r8,r7[0x0]
8000a11a:	08 08       	add	r8,r4
8000a11c:	08 95       	mov	r5,r4
8000a11e:	8f 08       	st.w	r7[0x0],r8
8000a120:	6e 28       	ld.w	r8,r7[0x8]
8000a122:	08 18       	sub	r8,r4
8000a124:	8f 28       	st.w	r7[0x8],r8
8000a126:	0a 16       	sub	r6,r5
8000a128:	c0 71       	brne	8000a136 <__sfvwrite_r+0x276>
8000a12a:	0e 9b       	mov	r11,r7
8000a12c:	40 1c       	lddsp	r12,sp[0x4]
8000a12e:	fe b0 fc 91 	rcall	80009a50 <_fflush_r>
8000a132:	c0 91       	brne	8000a144 <__sfvwrite_r+0x284>
8000a134:	50 06       	stdsp	sp[0x0],r6
8000a136:	64 28       	ld.w	r8,r2[0x8]
8000a138:	0a 18       	sub	r8,r5
8000a13a:	85 28       	st.w	r2[0x8],r8
8000a13c:	c0 90       	breq	8000a14e <__sfvwrite_r+0x28e>
8000a13e:	0a 11       	sub	r1,r5
8000a140:	0a 03       	add	r3,r5
8000a142:	ca 4b       	rjmp	8000a08a <__sfvwrite_r+0x1ca>
8000a144:	8e 68       	ld.sh	r8,r7[0xc]
8000a146:	a7 a8       	sbr	r8,0x6
8000a148:	ae 68       	st.h	r7[0xc],r8
8000a14a:	3f fc       	mov	r12,-1
8000a14c:	c0 28       	rjmp	8000a150 <__sfvwrite_r+0x290>
8000a14e:	30 0c       	mov	r12,0
8000a150:	2f dd       	sub	sp,-12
8000a152:	d8 32       	popm	r0-r7,pc

8000a154 <_fwalk>:
8000a154:	d4 31       	pushm	r0-r7,lr
8000a156:	30 05       	mov	r5,0
8000a158:	16 91       	mov	r1,r11
8000a15a:	f8 c7 ff 28 	sub	r7,r12,-216
8000a15e:	0a 92       	mov	r2,r5
8000a160:	fe b0 fc fe 	rcall	80009b5c <__sfp_lock_acquire>
8000a164:	3f f3       	mov	r3,-1
8000a166:	c1 68       	rjmp	8000a192 <_fwalk+0x3e>
8000a168:	6e 26       	ld.w	r6,r7[0x8]
8000a16a:	6e 14       	ld.w	r4,r7[0x4]
8000a16c:	2f 46       	sub	r6,-12
8000a16e:	c0 c8       	rjmp	8000a186 <_fwalk+0x32>
8000a170:	8c 08       	ld.sh	r8,r6[0x0]
8000a172:	e4 08 19 00 	cp.h	r8,r2
8000a176:	c0 70       	breq	8000a184 <_fwalk+0x30>
8000a178:	8c 18       	ld.sh	r8,r6[0x2]
8000a17a:	e6 08 19 00 	cp.h	r8,r3
8000a17e:	c0 30       	breq	8000a184 <_fwalk+0x30>
8000a180:	5d 11       	icall	r1
8000a182:	18 45       	or	r5,r12
8000a184:	2a 46       	sub	r6,-92
8000a186:	20 14       	sub	r4,1
8000a188:	ec cc 00 0c 	sub	r12,r6,12
8000a18c:	58 04       	cp.w	r4,0
8000a18e:	cf 14       	brge	8000a170 <_fwalk+0x1c>
8000a190:	6e 07       	ld.w	r7,r7[0x0]
8000a192:	58 07       	cp.w	r7,0
8000a194:	ce a1       	brne	8000a168 <_fwalk+0x14>
8000a196:	fe b0 fc e4 	rcall	80009b5e <__sfp_lock_release>
8000a19a:	0a 9c       	mov	r12,r5
8000a19c:	d8 32       	popm	r0-r7,pc
8000a19e:	d7 03       	nop

8000a1a0 <_localeconv_r>:
8000a1a0:	fe cc d5 2c 	sub	r12,pc,-10964
8000a1a4:	5e fc       	retal	r12
8000a1a6:	d7 03       	nop

8000a1a8 <__smakebuf_r>:
8000a1a8:	d4 21       	pushm	r4-r7,lr
8000a1aa:	20 fd       	sub	sp,60
8000a1ac:	96 68       	ld.sh	r8,r11[0xc]
8000a1ae:	16 97       	mov	r7,r11
8000a1b0:	18 96       	mov	r6,r12
8000a1b2:	e2 18 00 02 	andl	r8,0x2,COH
8000a1b6:	c3 d1       	brne	8000a230 <__smakebuf_r+0x88>
8000a1b8:	96 7b       	ld.sh	r11,r11[0xe]
8000a1ba:	f0 0b 19 00 	cp.h	r11,r8
8000a1be:	c0 55       	brlt	8000a1c8 <__smakebuf_r+0x20>
8000a1c0:	1a 9a       	mov	r10,sp
8000a1c2:	e0 a0 04 75 	rcall	8000aaac <_fstat_r>
8000a1c6:	c0 f4       	brge	8000a1e4 <__smakebuf_r+0x3c>
8000a1c8:	8e 65       	ld.sh	r5,r7[0xc]
8000a1ca:	0a 98       	mov	r8,r5
8000a1cc:	ab b8       	sbr	r8,0xb
8000a1ce:	e2 15 00 80 	andl	r5,0x80,COH
8000a1d2:	ae 68       	st.h	r7[0xc],r8
8000a1d4:	30 04       	mov	r4,0
8000a1d6:	e0 68 04 00 	mov	r8,1024
8000a1da:	f9 b5 01 40 	movne	r5,64
8000a1de:	f0 05 17 00 	moveq	r5,r8
8000a1e2:	c1 c8       	rjmp	8000a21a <__smakebuf_r+0x72>
8000a1e4:	40 18       	lddsp	r8,sp[0x4]
8000a1e6:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a1ea:	e0 48 20 00 	cp.w	r8,8192
8000a1ee:	5f 04       	sreq	r4
8000a1f0:	e0 48 80 00 	cp.w	r8,32768
8000a1f4:	c0 e1       	brne	8000a210 <__smakebuf_r+0x68>
8000a1f6:	6e b9       	ld.w	r9,r7[0x2c]
8000a1f8:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a1fc:	10 39       	cp.w	r9,r8
8000a1fe:	c0 91       	brne	8000a210 <__smakebuf_r+0x68>
8000a200:	8e 68       	ld.sh	r8,r7[0xc]
8000a202:	e0 65 04 00 	mov	r5,1024
8000a206:	ab a8       	sbr	r8,0xa
8000a208:	ef 45 00 50 	st.w	r7[80],r5
8000a20c:	ae 68       	st.h	r7[0xc],r8
8000a20e:	c0 68       	rjmp	8000a21a <__smakebuf_r+0x72>
8000a210:	8e 68       	ld.sh	r8,r7[0xc]
8000a212:	e0 65 04 00 	mov	r5,1024
8000a216:	ab b8       	sbr	r8,0xb
8000a218:	ae 68       	st.h	r7[0xc],r8
8000a21a:	0a 9b       	mov	r11,r5
8000a21c:	0c 9c       	mov	r12,r6
8000a21e:	fe b0 df 29 	rcall	80006070 <_malloc_r>
8000a222:	8e 68       	ld.sh	r8,r7[0xc]
8000a224:	c0 d1       	brne	8000a23e <__smakebuf_r+0x96>
8000a226:	ed b8 00 09 	bld	r8,0x9
8000a22a:	c1 b0       	breq	8000a260 <__smakebuf_r+0xb8>
8000a22c:	a1 b8       	sbr	r8,0x1
8000a22e:	ae 68       	st.h	r7[0xc],r8
8000a230:	ee c8 ff b9 	sub	r8,r7,-71
8000a234:	8f 48       	st.w	r7[0x10],r8
8000a236:	8f 08       	st.w	r7[0x0],r8
8000a238:	30 18       	mov	r8,1
8000a23a:	8f 58       	st.w	r7[0x14],r8
8000a23c:	c1 28       	rjmp	8000a260 <__smakebuf_r+0xb8>
8000a23e:	a7 b8       	sbr	r8,0x7
8000a240:	8f 4c       	st.w	r7[0x10],r12
8000a242:	ae 68       	st.h	r7[0xc],r8
8000a244:	8f 55       	st.w	r7[0x14],r5
8000a246:	fe c8 06 e6 	sub	r8,pc,1766
8000a24a:	8f 0c       	st.w	r7[0x0],r12
8000a24c:	8d a8       	st.w	r6[0x28],r8
8000a24e:	58 04       	cp.w	r4,0
8000a250:	c0 80       	breq	8000a260 <__smakebuf_r+0xb8>
8000a252:	8e 7c       	ld.sh	r12,r7[0xe]
8000a254:	fe b0 e3 94 	rcall	8000697c <isatty>
8000a258:	c0 40       	breq	8000a260 <__smakebuf_r+0xb8>
8000a25a:	8e 68       	ld.sh	r8,r7[0xc]
8000a25c:	a1 a8       	sbr	r8,0x0
8000a25e:	ae 68       	st.h	r7[0xc],r8
8000a260:	2f 1d       	sub	sp,-60
8000a262:	d8 22       	popm	r4-r7,pc

8000a264 <memchr>:
8000a264:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a268:	c0 68       	rjmp	8000a274 <memchr+0x10>
8000a26a:	20 1a       	sub	r10,1
8000a26c:	19 88       	ld.ub	r8,r12[0x0]
8000a26e:	16 38       	cp.w	r8,r11
8000a270:	5e 0c       	reteq	r12
8000a272:	2f fc       	sub	r12,-1
8000a274:	58 0a       	cp.w	r10,0
8000a276:	cf a1       	brne	8000a26a <memchr+0x6>
8000a278:	5e fa       	retal	r10

8000a27a <memmove>:
8000a27a:	d4 01       	pushm	lr
8000a27c:	18 3b       	cp.w	r11,r12
8000a27e:	c1 92       	brcc	8000a2b0 <memmove+0x36>
8000a280:	f6 0a 00 09 	add	r9,r11,r10
8000a284:	12 3c       	cp.w	r12,r9
8000a286:	c1 52       	brcc	8000a2b0 <memmove+0x36>
8000a288:	f8 0a 00 0b 	add	r11,r12,r10
8000a28c:	30 08       	mov	r8,0
8000a28e:	c0 68       	rjmp	8000a29a <memmove+0x20>
8000a290:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a294:	20 1a       	sub	r10,1
8000a296:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a29a:	20 18       	sub	r8,1
8000a29c:	58 0a       	cp.w	r10,0
8000a29e:	cf 91       	brne	8000a290 <memmove+0x16>
8000a2a0:	d8 02       	popm	pc
8000a2a2:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a2a6:	20 1a       	sub	r10,1
8000a2a8:	f8 08 0b 09 	st.b	r12[r8],r9
8000a2ac:	2f f8       	sub	r8,-1
8000a2ae:	c0 28       	rjmp	8000a2b2 <memmove+0x38>
8000a2b0:	30 08       	mov	r8,0
8000a2b2:	58 0a       	cp.w	r10,0
8000a2b4:	cf 71       	brne	8000a2a2 <memmove+0x28>
8000a2b6:	d8 02       	popm	pc

8000a2b8 <__hi0bits>:
8000a2b8:	18 98       	mov	r8,r12
8000a2ba:	e0 1c 00 00 	andl	r12,0x0
8000a2be:	f0 09 15 10 	lsl	r9,r8,0x10
8000a2c2:	58 0c       	cp.w	r12,0
8000a2c4:	f2 08 17 00 	moveq	r8,r9
8000a2c8:	f9 bc 00 10 	moveq	r12,16
8000a2cc:	f9 bc 01 00 	movne	r12,0
8000a2d0:	10 9a       	mov	r10,r8
8000a2d2:	f0 09 15 08 	lsl	r9,r8,0x8
8000a2d6:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a2da:	f7 bc 00 f8 	subeq	r12,-8
8000a2de:	f2 08 17 00 	moveq	r8,r9
8000a2e2:	10 9a       	mov	r10,r8
8000a2e4:	f0 09 15 04 	lsl	r9,r8,0x4
8000a2e8:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a2ec:	f7 bc 00 fc 	subeq	r12,-4
8000a2f0:	f2 08 17 00 	moveq	r8,r9
8000a2f4:	10 9a       	mov	r10,r8
8000a2f6:	f0 09 15 02 	lsl	r9,r8,0x2
8000a2fa:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a2fe:	f7 bc 00 fe 	subeq	r12,-2
8000a302:	f2 08 17 00 	moveq	r8,r9
8000a306:	58 08       	cp.w	r8,0
8000a308:	5e 5c       	retlt	r12
8000a30a:	ed b8 00 1e 	bld	r8,0x1e
8000a30e:	f9 bc 01 20 	movne	r12,32
8000a312:	f7 bc 00 ff 	subeq	r12,-1
8000a316:	5e fc       	retal	r12

8000a318 <__lo0bits>:
8000a318:	18 99       	mov	r9,r12
8000a31a:	78 08       	ld.w	r8,r12[0x0]
8000a31c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a320:	c1 50       	breq	8000a34a <__lo0bits+0x32>
8000a322:	ed b8 00 00 	bld	r8,0x0
8000a326:	c0 21       	brne	8000a32a <__lo0bits+0x12>
8000a328:	5e fd       	retal	0
8000a32a:	10 9b       	mov	r11,r8
8000a32c:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a330:	e2 1b 00 02 	andl	r11,0x2,COH
8000a334:	a3 88       	lsr	r8,0x2
8000a336:	58 0b       	cp.w	r11,0
8000a338:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a33c:	f9 bc 01 01 	movne	r12,1
8000a340:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a344:	f9 bc 00 02 	moveq	r12,2
8000a348:	5e fc       	retal	r12
8000a34a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a34e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a352:	58 0a       	cp.w	r10,0
8000a354:	f6 08 17 00 	moveq	r8,r11
8000a358:	f9 bc 00 10 	moveq	r12,16
8000a35c:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a360:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a364:	58 0b       	cp.w	r11,0
8000a366:	f7 bc 00 f8 	subeq	r12,-8
8000a36a:	f4 08 17 00 	moveq	r8,r10
8000a36e:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a372:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a376:	58 0b       	cp.w	r11,0
8000a378:	f7 bc 00 fc 	subeq	r12,-4
8000a37c:	f4 08 17 00 	moveq	r8,r10
8000a380:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a384:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a388:	58 0b       	cp.w	r11,0
8000a38a:	f7 bc 00 fe 	subeq	r12,-2
8000a38e:	f4 08 17 00 	moveq	r8,r10
8000a392:	ed b8 00 00 	bld	r8,0x0
8000a396:	c0 60       	breq	8000a3a2 <__lo0bits+0x8a>
8000a398:	a1 98       	lsr	r8,0x1
8000a39a:	c0 31       	brne	8000a3a0 <__lo0bits+0x88>
8000a39c:	32 0c       	mov	r12,32
8000a39e:	5e fc       	retal	r12
8000a3a0:	2f fc       	sub	r12,-1
8000a3a2:	93 08       	st.w	r9[0x0],r8
8000a3a4:	5e fc       	retal	r12

8000a3a6 <__mcmp>:
8000a3a6:	d4 01       	pushm	lr
8000a3a8:	18 98       	mov	r8,r12
8000a3aa:	76 49       	ld.w	r9,r11[0x10]
8000a3ac:	78 4c       	ld.w	r12,r12[0x10]
8000a3ae:	12 1c       	sub	r12,r9
8000a3b0:	c1 31       	brne	8000a3d6 <__mcmp+0x30>
8000a3b2:	2f b9       	sub	r9,-5
8000a3b4:	a3 69       	lsl	r9,0x2
8000a3b6:	12 0b       	add	r11,r9
8000a3b8:	f0 09 00 09 	add	r9,r8,r9
8000a3bc:	2e c8       	sub	r8,-20
8000a3be:	13 4e       	ld.w	lr,--r9
8000a3c0:	17 4a       	ld.w	r10,--r11
8000a3c2:	14 3e       	cp.w	lr,r10
8000a3c4:	c0 60       	breq	8000a3d0 <__mcmp+0x2a>
8000a3c6:	f9 bc 03 ff 	movlo	r12,-1
8000a3ca:	f9 bc 02 01 	movhs	r12,1
8000a3ce:	d8 02       	popm	pc
8000a3d0:	10 39       	cp.w	r9,r8
8000a3d2:	fe 9b ff f6 	brhi	8000a3be <__mcmp+0x18>
8000a3d6:	d8 02       	popm	pc

8000a3d8 <_Bfree>:
8000a3d8:	d4 21       	pushm	r4-r7,lr
8000a3da:	18 97       	mov	r7,r12
8000a3dc:	16 95       	mov	r5,r11
8000a3de:	78 96       	ld.w	r6,r12[0x24]
8000a3e0:	58 06       	cp.w	r6,0
8000a3e2:	c0 91       	brne	8000a3f4 <_Bfree+0x1c>
8000a3e4:	31 0c       	mov	r12,16
8000a3e6:	fe b0 de 3d 	rcall	80006060 <malloc>
8000a3ea:	99 36       	st.w	r12[0xc],r6
8000a3ec:	8f 9c       	st.w	r7[0x24],r12
8000a3ee:	99 16       	st.w	r12[0x4],r6
8000a3f0:	99 26       	st.w	r12[0x8],r6
8000a3f2:	99 06       	st.w	r12[0x0],r6
8000a3f4:	58 05       	cp.w	r5,0
8000a3f6:	c0 90       	breq	8000a408 <_Bfree+0x30>
8000a3f8:	6a 19       	ld.w	r9,r5[0x4]
8000a3fa:	6e 98       	ld.w	r8,r7[0x24]
8000a3fc:	70 38       	ld.w	r8,r8[0xc]
8000a3fe:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a402:	8b 0a       	st.w	r5[0x0],r10
8000a404:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a408:	d8 22       	popm	r4-r7,pc
8000a40a:	d7 03       	nop

8000a40c <_Balloc>:
8000a40c:	d4 21       	pushm	r4-r7,lr
8000a40e:	18 97       	mov	r7,r12
8000a410:	16 96       	mov	r6,r11
8000a412:	78 95       	ld.w	r5,r12[0x24]
8000a414:	58 05       	cp.w	r5,0
8000a416:	c0 91       	brne	8000a428 <_Balloc+0x1c>
8000a418:	31 0c       	mov	r12,16
8000a41a:	fe b0 de 23 	rcall	80006060 <malloc>
8000a41e:	99 35       	st.w	r12[0xc],r5
8000a420:	8f 9c       	st.w	r7[0x24],r12
8000a422:	99 15       	st.w	r12[0x4],r5
8000a424:	99 25       	st.w	r12[0x8],r5
8000a426:	99 05       	st.w	r12[0x0],r5
8000a428:	6e 95       	ld.w	r5,r7[0x24]
8000a42a:	6a 38       	ld.w	r8,r5[0xc]
8000a42c:	58 08       	cp.w	r8,0
8000a42e:	c0 b1       	brne	8000a444 <_Balloc+0x38>
8000a430:	31 0a       	mov	r10,16
8000a432:	30 4b       	mov	r11,4
8000a434:	0e 9c       	mov	r12,r7
8000a436:	e0 a0 02 9b 	rcall	8000a96c <_calloc_r>
8000a43a:	8b 3c       	st.w	r5[0xc],r12
8000a43c:	6e 98       	ld.w	r8,r7[0x24]
8000a43e:	70 3c       	ld.w	r12,r8[0xc]
8000a440:	58 0c       	cp.w	r12,0
8000a442:	c1 b0       	breq	8000a478 <_Balloc+0x6c>
8000a444:	6e 98       	ld.w	r8,r7[0x24]
8000a446:	70 38       	ld.w	r8,r8[0xc]
8000a448:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a44c:	70 0c       	ld.w	r12,r8[0x0]
8000a44e:	58 0c       	cp.w	r12,0
8000a450:	c0 40       	breq	8000a458 <_Balloc+0x4c>
8000a452:	78 09       	ld.w	r9,r12[0x0]
8000a454:	91 09       	st.w	r8[0x0],r9
8000a456:	c0 e8       	rjmp	8000a472 <_Balloc+0x66>
8000a458:	0e 9c       	mov	r12,r7
8000a45a:	30 17       	mov	r7,1
8000a45c:	0e 9b       	mov	r11,r7
8000a45e:	ee 06 09 47 	lsl	r7,r7,r6
8000a462:	ee ca ff fb 	sub	r10,r7,-5
8000a466:	a3 6a       	lsl	r10,0x2
8000a468:	e0 a0 02 82 	rcall	8000a96c <_calloc_r>
8000a46c:	c0 60       	breq	8000a478 <_Balloc+0x6c>
8000a46e:	99 16       	st.w	r12[0x4],r6
8000a470:	99 27       	st.w	r12[0x8],r7
8000a472:	30 08       	mov	r8,0
8000a474:	99 38       	st.w	r12[0xc],r8
8000a476:	99 48       	st.w	r12[0x10],r8
8000a478:	d8 22       	popm	r4-r7,pc
8000a47a:	d7 03       	nop

8000a47c <__d2b>:
8000a47c:	d4 31       	pushm	r0-r7,lr
8000a47e:	20 2d       	sub	sp,8
8000a480:	16 93       	mov	r3,r11
8000a482:	12 96       	mov	r6,r9
8000a484:	10 95       	mov	r5,r8
8000a486:	14 92       	mov	r2,r10
8000a488:	30 1b       	mov	r11,1
8000a48a:	cc 1f       	rcall	8000a40c <_Balloc>
8000a48c:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a490:	50 09       	stdsp	sp[0x0],r9
8000a492:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a496:	b5 a9       	sbr	r9,0x14
8000a498:	f0 01 16 14 	lsr	r1,r8,0x14
8000a49c:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a4a0:	18 94       	mov	r4,r12
8000a4a2:	58 02       	cp.w	r2,0
8000a4a4:	c1 d0       	breq	8000a4de <__d2b+0x62>
8000a4a6:	fa cc ff f8 	sub	r12,sp,-8
8000a4aa:	18 d2       	st.w	--r12,r2
8000a4ac:	c3 6f       	rcall	8000a318 <__lo0bits>
8000a4ae:	40 18       	lddsp	r8,sp[0x4]
8000a4b0:	c0 d0       	breq	8000a4ca <__d2b+0x4e>
8000a4b2:	40 09       	lddsp	r9,sp[0x0]
8000a4b4:	f8 0a 11 20 	rsub	r10,r12,32
8000a4b8:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a4bc:	f5 e8 10 08 	or	r8,r10,r8
8000a4c0:	89 58       	st.w	r4[0x14],r8
8000a4c2:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a4c6:	50 09       	stdsp	sp[0x0],r9
8000a4c8:	c0 28       	rjmp	8000a4cc <__d2b+0x50>
8000a4ca:	89 58       	st.w	r4[0x14],r8
8000a4cc:	40 08       	lddsp	r8,sp[0x0]
8000a4ce:	58 08       	cp.w	r8,0
8000a4d0:	f9 b3 01 02 	movne	r3,2
8000a4d4:	f9 b3 00 01 	moveq	r3,1
8000a4d8:	89 68       	st.w	r4[0x18],r8
8000a4da:	89 43       	st.w	r4[0x10],r3
8000a4dc:	c0 88       	rjmp	8000a4ec <__d2b+0x70>
8000a4de:	1a 9c       	mov	r12,sp
8000a4e0:	c1 cf       	rcall	8000a318 <__lo0bits>
8000a4e2:	30 13       	mov	r3,1
8000a4e4:	40 08       	lddsp	r8,sp[0x0]
8000a4e6:	2e 0c       	sub	r12,-32
8000a4e8:	89 43       	st.w	r4[0x10],r3
8000a4ea:	89 58       	st.w	r4[0x14],r8
8000a4ec:	58 01       	cp.w	r1,0
8000a4ee:	c0 90       	breq	8000a500 <__d2b+0x84>
8000a4f0:	e2 c1 04 33 	sub	r1,r1,1075
8000a4f4:	18 01       	add	r1,r12
8000a4f6:	8d 01       	st.w	r6[0x0],r1
8000a4f8:	f8 0c 11 35 	rsub	r12,r12,53
8000a4fc:	8b 0c       	st.w	r5[0x0],r12
8000a4fe:	c0 c8       	rjmp	8000a516 <__d2b+0x9a>
8000a500:	e6 c8 ff fc 	sub	r8,r3,-4
8000a504:	f8 cc 04 32 	sub	r12,r12,1074
8000a508:	a5 73       	lsl	r3,0x5
8000a50a:	8d 0c       	st.w	r6[0x0],r12
8000a50c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a510:	cd 4e       	rcall	8000a2b8 <__hi0bits>
8000a512:	18 13       	sub	r3,r12
8000a514:	8b 03       	st.w	r5[0x0],r3
8000a516:	08 9c       	mov	r12,r4
8000a518:	2f ed       	sub	sp,-8
8000a51a:	d8 32       	popm	r0-r7,pc

8000a51c <__mdiff>:
8000a51c:	d4 31       	pushm	r0-r7,lr
8000a51e:	74 48       	ld.w	r8,r10[0x10]
8000a520:	76 45       	ld.w	r5,r11[0x10]
8000a522:	16 97       	mov	r7,r11
8000a524:	14 96       	mov	r6,r10
8000a526:	10 15       	sub	r5,r8
8000a528:	c1 31       	brne	8000a54e <__mdiff+0x32>
8000a52a:	2f b8       	sub	r8,-5
8000a52c:	ee ce ff ec 	sub	lr,r7,-20
8000a530:	a3 68       	lsl	r8,0x2
8000a532:	f4 08 00 0b 	add	r11,r10,r8
8000a536:	ee 08 00 08 	add	r8,r7,r8
8000a53a:	11 4a       	ld.w	r10,--r8
8000a53c:	17 49       	ld.w	r9,--r11
8000a53e:	12 3a       	cp.w	r10,r9
8000a540:	c0 30       	breq	8000a546 <__mdiff+0x2a>
8000a542:	c0 e2       	brcc	8000a55e <__mdiff+0x42>
8000a544:	c0 78       	rjmp	8000a552 <__mdiff+0x36>
8000a546:	1c 38       	cp.w	r8,lr
8000a548:	fe 9b ff f9 	brhi	8000a53a <__mdiff+0x1e>
8000a54c:	c4 98       	rjmp	8000a5de <__mdiff+0xc2>
8000a54e:	58 05       	cp.w	r5,0
8000a550:	c0 64       	brge	8000a55c <__mdiff+0x40>
8000a552:	0e 98       	mov	r8,r7
8000a554:	30 15       	mov	r5,1
8000a556:	0c 97       	mov	r7,r6
8000a558:	10 96       	mov	r6,r8
8000a55a:	c0 28       	rjmp	8000a55e <__mdiff+0x42>
8000a55c:	30 05       	mov	r5,0
8000a55e:	6e 1b       	ld.w	r11,r7[0x4]
8000a560:	c5 6f       	rcall	8000a40c <_Balloc>
8000a562:	6e 49       	ld.w	r9,r7[0x10]
8000a564:	6c 44       	ld.w	r4,r6[0x10]
8000a566:	99 35       	st.w	r12[0xc],r5
8000a568:	2f b4       	sub	r4,-5
8000a56a:	f2 c5 ff fb 	sub	r5,r9,-5
8000a56e:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a572:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a576:	2e c6       	sub	r6,-20
8000a578:	2e c7       	sub	r7,-20
8000a57a:	f8 c8 ff ec 	sub	r8,r12,-20
8000a57e:	30 0a       	mov	r10,0
8000a580:	0f 0e       	ld.w	lr,r7++
8000a582:	0d 0b       	ld.w	r11,r6++
8000a584:	fc 02 16 10 	lsr	r2,lr,0x10
8000a588:	f6 03 16 10 	lsr	r3,r11,0x10
8000a58c:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a590:	e4 03 01 03 	sub	r3,r2,r3
8000a594:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a598:	fc 0b 01 0b 	sub	r11,lr,r11
8000a59c:	f6 0a 00 0a 	add	r10,r11,r10
8000a5a0:	b0 1a       	st.h	r8[0x2],r10
8000a5a2:	b1 4a       	asr	r10,0x10
8000a5a4:	e6 0a 00 0a 	add	r10,r3,r10
8000a5a8:	b0 0a       	st.h	r8[0x0],r10
8000a5aa:	2f c8       	sub	r8,-4
8000a5ac:	b1 4a       	asr	r10,0x10
8000a5ae:	08 36       	cp.w	r6,r4
8000a5b0:	ce 83       	brcs	8000a580 <__mdiff+0x64>
8000a5b2:	c0 d8       	rjmp	8000a5cc <__mdiff+0xb0>
8000a5b4:	0f 0b       	ld.w	r11,r7++
8000a5b6:	f6 0e 16 10 	lsr	lr,r11,0x10
8000a5ba:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a5be:	16 0a       	add	r10,r11
8000a5c0:	b0 1a       	st.h	r8[0x2],r10
8000a5c2:	b1 4a       	asr	r10,0x10
8000a5c4:	1c 0a       	add	r10,lr
8000a5c6:	b0 0a       	st.h	r8[0x0],r10
8000a5c8:	2f c8       	sub	r8,-4
8000a5ca:	b1 4a       	asr	r10,0x10
8000a5cc:	0a 37       	cp.w	r7,r5
8000a5ce:	cf 33       	brcs	8000a5b4 <__mdiff+0x98>
8000a5d0:	c0 28       	rjmp	8000a5d4 <__mdiff+0xb8>
8000a5d2:	20 19       	sub	r9,1
8000a5d4:	11 4a       	ld.w	r10,--r8
8000a5d6:	58 0a       	cp.w	r10,0
8000a5d8:	cf d0       	breq	8000a5d2 <__mdiff+0xb6>
8000a5da:	99 49       	st.w	r12[0x10],r9
8000a5dc:	d8 32       	popm	r0-r7,pc
8000a5de:	30 0b       	mov	r11,0
8000a5e0:	c1 6f       	rcall	8000a40c <_Balloc>
8000a5e2:	30 18       	mov	r8,1
8000a5e4:	99 48       	st.w	r12[0x10],r8
8000a5e6:	30 08       	mov	r8,0
8000a5e8:	99 58       	st.w	r12[0x14],r8
8000a5ea:	d8 32       	popm	r0-r7,pc

8000a5ec <__lshift>:
8000a5ec:	d4 31       	pushm	r0-r7,lr
8000a5ee:	16 97       	mov	r7,r11
8000a5f0:	76 46       	ld.w	r6,r11[0x10]
8000a5f2:	f4 02 14 05 	asr	r2,r10,0x5
8000a5f6:	2f f6       	sub	r6,-1
8000a5f8:	14 93       	mov	r3,r10
8000a5fa:	18 94       	mov	r4,r12
8000a5fc:	04 06       	add	r6,r2
8000a5fe:	76 1b       	ld.w	r11,r11[0x4]
8000a600:	6e 28       	ld.w	r8,r7[0x8]
8000a602:	c0 38       	rjmp	8000a608 <__lshift+0x1c>
8000a604:	2f fb       	sub	r11,-1
8000a606:	a1 78       	lsl	r8,0x1
8000a608:	10 36       	cp.w	r6,r8
8000a60a:	fe 99 ff fd 	brgt	8000a604 <__lshift+0x18>
8000a60e:	08 9c       	mov	r12,r4
8000a610:	cf ee       	rcall	8000a40c <_Balloc>
8000a612:	30 09       	mov	r9,0
8000a614:	18 95       	mov	r5,r12
8000a616:	f8 c8 ff ec 	sub	r8,r12,-20
8000a61a:	12 9a       	mov	r10,r9
8000a61c:	c0 38       	rjmp	8000a622 <__lshift+0x36>
8000a61e:	10 aa       	st.w	r8++,r10
8000a620:	2f f9       	sub	r9,-1
8000a622:	04 39       	cp.w	r9,r2
8000a624:	cf d5       	brlt	8000a61e <__lshift+0x32>
8000a626:	6e 4b       	ld.w	r11,r7[0x10]
8000a628:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000a62c:	2f bb       	sub	r11,-5
8000a62e:	ee c9 ff ec 	sub	r9,r7,-20
8000a632:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000a636:	58 03       	cp.w	r3,0
8000a638:	c1 30       	breq	8000a65e <__lshift+0x72>
8000a63a:	e6 0c 11 20 	rsub	r12,r3,32
8000a63e:	30 0a       	mov	r10,0
8000a640:	72 02       	ld.w	r2,r9[0x0]
8000a642:	e4 03 09 42 	lsl	r2,r2,r3
8000a646:	04 4a       	or	r10,r2
8000a648:	10 aa       	st.w	r8++,r10
8000a64a:	13 0a       	ld.w	r10,r9++
8000a64c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a650:	16 39       	cp.w	r9,r11
8000a652:	cf 73       	brcs	8000a640 <__lshift+0x54>
8000a654:	91 0a       	st.w	r8[0x0],r10
8000a656:	58 0a       	cp.w	r10,0
8000a658:	c0 70       	breq	8000a666 <__lshift+0x7a>
8000a65a:	2f f6       	sub	r6,-1
8000a65c:	c0 58       	rjmp	8000a666 <__lshift+0x7a>
8000a65e:	13 0a       	ld.w	r10,r9++
8000a660:	10 aa       	st.w	r8++,r10
8000a662:	16 39       	cp.w	r9,r11
8000a664:	cf d3       	brcs	8000a65e <__lshift+0x72>
8000a666:	08 9c       	mov	r12,r4
8000a668:	20 16       	sub	r6,1
8000a66a:	0e 9b       	mov	r11,r7
8000a66c:	8b 46       	st.w	r5[0x10],r6
8000a66e:	cb 5e       	rcall	8000a3d8 <_Bfree>
8000a670:	0a 9c       	mov	r12,r5
8000a672:	d8 32       	popm	r0-r7,pc

8000a674 <__multiply>:
8000a674:	d4 31       	pushm	r0-r7,lr
8000a676:	20 2d       	sub	sp,8
8000a678:	76 49       	ld.w	r9,r11[0x10]
8000a67a:	74 48       	ld.w	r8,r10[0x10]
8000a67c:	16 96       	mov	r6,r11
8000a67e:	14 95       	mov	r5,r10
8000a680:	10 39       	cp.w	r9,r8
8000a682:	ec 08 17 50 	movlt	r8,r6
8000a686:	ea 06 17 50 	movlt	r6,r5
8000a68a:	f0 05 17 50 	movlt	r5,r8
8000a68e:	6c 28       	ld.w	r8,r6[0x8]
8000a690:	76 43       	ld.w	r3,r11[0x10]
8000a692:	74 42       	ld.w	r2,r10[0x10]
8000a694:	76 1b       	ld.w	r11,r11[0x4]
8000a696:	e4 03 00 07 	add	r7,r2,r3
8000a69a:	10 37       	cp.w	r7,r8
8000a69c:	f7 bb 09 ff 	subgt	r11,-1
8000a6a0:	cb 6e       	rcall	8000a40c <_Balloc>
8000a6a2:	ee c4 ff fb 	sub	r4,r7,-5
8000a6a6:	f8 c9 ff ec 	sub	r9,r12,-20
8000a6aa:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000a6ae:	30 0a       	mov	r10,0
8000a6b0:	12 98       	mov	r8,r9
8000a6b2:	c0 28       	rjmp	8000a6b6 <__multiply+0x42>
8000a6b4:	10 aa       	st.w	r8++,r10
8000a6b6:	08 38       	cp.w	r8,r4
8000a6b8:	cf e3       	brcs	8000a6b4 <__multiply+0x40>
8000a6ba:	2f b3       	sub	r3,-5
8000a6bc:	2f b2       	sub	r2,-5
8000a6be:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000a6c2:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000a6c6:	ec cb ff ec 	sub	r11,r6,-20
8000a6ca:	50 12       	stdsp	sp[0x4],r2
8000a6cc:	ea ca ff ec 	sub	r10,r5,-20
8000a6d0:	c4 48       	rjmp	8000a758 <__multiply+0xe4>
8000a6d2:	94 95       	ld.uh	r5,r10[0x2]
8000a6d4:	58 05       	cp.w	r5,0
8000a6d6:	c2 00       	breq	8000a716 <__multiply+0xa2>
8000a6d8:	12 98       	mov	r8,r9
8000a6da:	16 96       	mov	r6,r11
8000a6dc:	30 0e       	mov	lr,0
8000a6de:	50 09       	stdsp	sp[0x0],r9
8000a6e0:	0d 02       	ld.w	r2,r6++
8000a6e2:	e4 00 16 10 	lsr	r0,r2,0x10
8000a6e6:	70 01       	ld.w	r1,r8[0x0]
8000a6e8:	70 09       	ld.w	r9,r8[0x0]
8000a6ea:	b1 81       	lsr	r1,0x10
8000a6ec:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000a6f0:	e0 05 03 41 	mac	r1,r0,r5
8000a6f4:	ab 32       	mul	r2,r5
8000a6f6:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000a6fa:	00 02       	add	r2,r0
8000a6fc:	e4 0e 00 0e 	add	lr,r2,lr
8000a700:	b0 1e       	st.h	r8[0x2],lr
8000a702:	b1 8e       	lsr	lr,0x10
8000a704:	1c 01       	add	r1,lr
8000a706:	b0 01       	st.h	r8[0x0],r1
8000a708:	e2 0e 16 10 	lsr	lr,r1,0x10
8000a70c:	2f c8       	sub	r8,-4
8000a70e:	06 36       	cp.w	r6,r3
8000a710:	ce 83       	brcs	8000a6e0 <__multiply+0x6c>
8000a712:	40 09       	lddsp	r9,sp[0x0]
8000a714:	91 0e       	st.w	r8[0x0],lr
8000a716:	94 86       	ld.uh	r6,r10[0x0]
8000a718:	58 06       	cp.w	r6,0
8000a71a:	c1 d0       	breq	8000a754 <__multiply+0xe0>
8000a71c:	72 02       	ld.w	r2,r9[0x0]
8000a71e:	12 98       	mov	r8,r9
8000a720:	16 9e       	mov	lr,r11
8000a722:	30 05       	mov	r5,0
8000a724:	b0 12       	st.h	r8[0x2],r2
8000a726:	1d 01       	ld.w	r1,lr++
8000a728:	90 82       	ld.uh	r2,r8[0x0]
8000a72a:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000a72e:	ad 30       	mul	r0,r6
8000a730:	e0 02 00 02 	add	r2,r0,r2
8000a734:	e4 05 00 05 	add	r5,r2,r5
8000a738:	b0 05       	st.h	r8[0x0],r5
8000a73a:	b1 85       	lsr	r5,0x10
8000a73c:	b1 81       	lsr	r1,0x10
8000a73e:	2f c8       	sub	r8,-4
8000a740:	ad 31       	mul	r1,r6
8000a742:	90 92       	ld.uh	r2,r8[0x2]
8000a744:	e2 02 00 02 	add	r2,r1,r2
8000a748:	0a 02       	add	r2,r5
8000a74a:	e4 05 16 10 	lsr	r5,r2,0x10
8000a74e:	06 3e       	cp.w	lr,r3
8000a750:	ce a3       	brcs	8000a724 <__multiply+0xb0>
8000a752:	91 02       	st.w	r8[0x0],r2
8000a754:	2f ca       	sub	r10,-4
8000a756:	2f c9       	sub	r9,-4
8000a758:	40 18       	lddsp	r8,sp[0x4]
8000a75a:	10 3a       	cp.w	r10,r8
8000a75c:	cb b3       	brcs	8000a6d2 <__multiply+0x5e>
8000a75e:	c0 28       	rjmp	8000a762 <__multiply+0xee>
8000a760:	20 17       	sub	r7,1
8000a762:	58 07       	cp.w	r7,0
8000a764:	e0 8a 00 05 	brle	8000a76e <__multiply+0xfa>
8000a768:	09 48       	ld.w	r8,--r4
8000a76a:	58 08       	cp.w	r8,0
8000a76c:	cf a0       	breq	8000a760 <__multiply+0xec>
8000a76e:	99 47       	st.w	r12[0x10],r7
8000a770:	2f ed       	sub	sp,-8
8000a772:	d8 32       	popm	r0-r7,pc

8000a774 <__i2b>:
8000a774:	d4 21       	pushm	r4-r7,lr
8000a776:	16 97       	mov	r7,r11
8000a778:	30 1b       	mov	r11,1
8000a77a:	c4 9e       	rcall	8000a40c <_Balloc>
8000a77c:	30 19       	mov	r9,1
8000a77e:	99 57       	st.w	r12[0x14],r7
8000a780:	99 49       	st.w	r12[0x10],r9
8000a782:	d8 22       	popm	r4-r7,pc

8000a784 <__multadd>:
8000a784:	d4 31       	pushm	r0-r7,lr
8000a786:	30 08       	mov	r8,0
8000a788:	12 95       	mov	r5,r9
8000a78a:	16 97       	mov	r7,r11
8000a78c:	18 96       	mov	r6,r12
8000a78e:	76 44       	ld.w	r4,r11[0x10]
8000a790:	f6 c9 ff ec 	sub	r9,r11,-20
8000a794:	72 0b       	ld.w	r11,r9[0x0]
8000a796:	f6 0c 16 10 	lsr	r12,r11,0x10
8000a79a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a79e:	f4 0c 02 4c 	mul	r12,r10,r12
8000a7a2:	f4 0b 03 45 	mac	r5,r10,r11
8000a7a6:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000a7aa:	b1 85       	lsr	r5,0x10
8000a7ac:	18 05       	add	r5,r12
8000a7ae:	ea 0c 15 10 	lsl	r12,r5,0x10
8000a7b2:	f8 0b 00 0b 	add	r11,r12,r11
8000a7b6:	12 ab       	st.w	r9++,r11
8000a7b8:	2f f8       	sub	r8,-1
8000a7ba:	b1 85       	lsr	r5,0x10
8000a7bc:	08 38       	cp.w	r8,r4
8000a7be:	ce b5       	brlt	8000a794 <__multadd+0x10>
8000a7c0:	58 05       	cp.w	r5,0
8000a7c2:	c1 c0       	breq	8000a7fa <__multadd+0x76>
8000a7c4:	6e 28       	ld.w	r8,r7[0x8]
8000a7c6:	10 34       	cp.w	r4,r8
8000a7c8:	c1 35       	brlt	8000a7ee <__multadd+0x6a>
8000a7ca:	6e 1b       	ld.w	r11,r7[0x4]
8000a7cc:	0c 9c       	mov	r12,r6
8000a7ce:	2f fb       	sub	r11,-1
8000a7d0:	c1 ee       	rcall	8000a40c <_Balloc>
8000a7d2:	6e 4a       	ld.w	r10,r7[0x10]
8000a7d4:	ee cb ff f4 	sub	r11,r7,-12
8000a7d8:	18 93       	mov	r3,r12
8000a7da:	2f ea       	sub	r10,-2
8000a7dc:	2f 4c       	sub	r12,-12
8000a7de:	a3 6a       	lsl	r10,0x2
8000a7e0:	fe b0 de 64 	rcall	800064a8 <memcpy>
8000a7e4:	0e 9b       	mov	r11,r7
8000a7e6:	0c 9c       	mov	r12,r6
8000a7e8:	fe b0 fd f8 	rcall	8000a3d8 <_Bfree>
8000a7ec:	06 97       	mov	r7,r3
8000a7ee:	e8 c8 ff ff 	sub	r8,r4,-1
8000a7f2:	2f b4       	sub	r4,-5
8000a7f4:	8f 48       	st.w	r7[0x10],r8
8000a7f6:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000a7fa:	0e 9c       	mov	r12,r7
8000a7fc:	d8 32       	popm	r0-r7,pc
8000a7fe:	d7 03       	nop

8000a800 <__pow5mult>:
8000a800:	d4 31       	pushm	r0-r7,lr
8000a802:	14 96       	mov	r6,r10
8000a804:	18 97       	mov	r7,r12
8000a806:	16 94       	mov	r4,r11
8000a808:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000a80c:	c0 90       	breq	8000a81e <__pow5mult+0x1e>
8000a80e:	20 18       	sub	r8,1
8000a810:	fe c9 db 60 	sub	r9,pc,-9376
8000a814:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000a818:	30 09       	mov	r9,0
8000a81a:	cb 5f       	rcall	8000a784 <__multadd>
8000a81c:	18 94       	mov	r4,r12
8000a81e:	a3 46       	asr	r6,0x2
8000a820:	c3 40       	breq	8000a888 <__pow5mult+0x88>
8000a822:	6e 95       	ld.w	r5,r7[0x24]
8000a824:	58 05       	cp.w	r5,0
8000a826:	c0 91       	brne	8000a838 <__pow5mult+0x38>
8000a828:	31 0c       	mov	r12,16
8000a82a:	fe b0 dc 1b 	rcall	80006060 <malloc>
8000a82e:	99 35       	st.w	r12[0xc],r5
8000a830:	8f 9c       	st.w	r7[0x24],r12
8000a832:	99 15       	st.w	r12[0x4],r5
8000a834:	99 25       	st.w	r12[0x8],r5
8000a836:	99 05       	st.w	r12[0x0],r5
8000a838:	6e 93       	ld.w	r3,r7[0x24]
8000a83a:	66 25       	ld.w	r5,r3[0x8]
8000a83c:	58 05       	cp.w	r5,0
8000a83e:	c0 c1       	brne	8000a856 <__pow5mult+0x56>
8000a840:	e0 6b 02 71 	mov	r11,625
8000a844:	0e 9c       	mov	r12,r7
8000a846:	c9 7f       	rcall	8000a774 <__i2b>
8000a848:	87 2c       	st.w	r3[0x8],r12
8000a84a:	30 08       	mov	r8,0
8000a84c:	18 95       	mov	r5,r12
8000a84e:	99 08       	st.w	r12[0x0],r8
8000a850:	c0 38       	rjmp	8000a856 <__pow5mult+0x56>
8000a852:	06 9c       	mov	r12,r3
8000a854:	18 95       	mov	r5,r12
8000a856:	ed b6 00 00 	bld	r6,0x0
8000a85a:	c0 b1       	brne	8000a870 <__pow5mult+0x70>
8000a85c:	08 9b       	mov	r11,r4
8000a85e:	0a 9a       	mov	r10,r5
8000a860:	0e 9c       	mov	r12,r7
8000a862:	c0 9f       	rcall	8000a674 <__multiply>
8000a864:	08 9b       	mov	r11,r4
8000a866:	18 93       	mov	r3,r12
8000a868:	0e 9c       	mov	r12,r7
8000a86a:	06 94       	mov	r4,r3
8000a86c:	fe b0 fd b6 	rcall	8000a3d8 <_Bfree>
8000a870:	a1 56       	asr	r6,0x1
8000a872:	c0 b0       	breq	8000a888 <__pow5mult+0x88>
8000a874:	6a 03       	ld.w	r3,r5[0x0]
8000a876:	58 03       	cp.w	r3,0
8000a878:	ce d1       	brne	8000a852 <__pow5mult+0x52>
8000a87a:	0a 9a       	mov	r10,r5
8000a87c:	0a 9b       	mov	r11,r5
8000a87e:	0e 9c       	mov	r12,r7
8000a880:	cf ae       	rcall	8000a674 <__multiply>
8000a882:	8b 0c       	st.w	r5[0x0],r12
8000a884:	99 03       	st.w	r12[0x0],r3
8000a886:	ce 7b       	rjmp	8000a854 <__pow5mult+0x54>
8000a888:	08 9c       	mov	r12,r4
8000a88a:	d8 32       	popm	r0-r7,pc

8000a88c <__isinfd>:
8000a88c:	14 98       	mov	r8,r10
8000a88e:	fc 19 7f f0 	movh	r9,0x7ff0
8000a892:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a896:	f0 0b 11 00 	rsub	r11,r8,0
8000a89a:	f7 e8 10 08 	or	r8,r11,r8
8000a89e:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000a8a2:	f2 08 01 08 	sub	r8,r9,r8
8000a8a6:	f0 0c 11 00 	rsub	r12,r8,0
8000a8aa:	f9 e8 10 08 	or	r8,r12,r8
8000a8ae:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000a8b2:	2f fc       	sub	r12,-1
8000a8b4:	5e fc       	retal	r12

8000a8b6 <__isnand>:
8000a8b6:	14 98       	mov	r8,r10
8000a8b8:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a8bc:	f0 0c 11 00 	rsub	r12,r8,0
8000a8c0:	10 4c       	or	r12,r8
8000a8c2:	fc 18 7f f0 	movh	r8,0x7ff0
8000a8c6:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000a8ca:	f0 0c 01 0c 	sub	r12,r8,r12
8000a8ce:	bf 9c       	lsr	r12,0x1f
8000a8d0:	5e fc       	retal	r12
8000a8d2:	d7 03       	nop

8000a8d4 <__sclose>:
8000a8d4:	d4 01       	pushm	lr
8000a8d6:	96 7b       	ld.sh	r11,r11[0xe]
8000a8d8:	c7 6c       	rcall	8000a9c4 <_close_r>
8000a8da:	d8 02       	popm	pc

8000a8dc <__sseek>:
8000a8dc:	d4 21       	pushm	r4-r7,lr
8000a8de:	16 97       	mov	r7,r11
8000a8e0:	96 7b       	ld.sh	r11,r11[0xe]
8000a8e2:	cf 7c       	rcall	8000aad0 <_lseek_r>
8000a8e4:	8e 68       	ld.sh	r8,r7[0xc]
8000a8e6:	10 99       	mov	r9,r8
8000a8e8:	ad c8       	cbr	r8,0xc
8000a8ea:	ad a9       	sbr	r9,0xc
8000a8ec:	5b fc       	cp.w	r12,-1
8000a8ee:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000a8f2:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000a8f6:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000a8fa:	d8 22       	popm	r4-r7,pc

8000a8fc <__swrite>:
8000a8fc:	d4 21       	pushm	r4-r7,lr
8000a8fe:	96 68       	ld.sh	r8,r11[0xc]
8000a900:	16 97       	mov	r7,r11
8000a902:	14 95       	mov	r5,r10
8000a904:	12 94       	mov	r4,r9
8000a906:	e2 18 01 00 	andl	r8,0x100,COH
8000a90a:	18 96       	mov	r6,r12
8000a90c:	c0 50       	breq	8000a916 <__swrite+0x1a>
8000a90e:	30 29       	mov	r9,2
8000a910:	30 0a       	mov	r10,0
8000a912:	96 7b       	ld.sh	r11,r11[0xe]
8000a914:	cd ec       	rcall	8000aad0 <_lseek_r>
8000a916:	8e 68       	ld.sh	r8,r7[0xc]
8000a918:	ad c8       	cbr	r8,0xc
8000a91a:	08 99       	mov	r9,r4
8000a91c:	0a 9a       	mov	r10,r5
8000a91e:	8e 7b       	ld.sh	r11,r7[0xe]
8000a920:	0c 9c       	mov	r12,r6
8000a922:	ae 68       	st.h	r7[0xc],r8
8000a924:	c1 0c       	rcall	8000a944 <_write_r>
8000a926:	d8 22       	popm	r4-r7,pc

8000a928 <__sread>:
8000a928:	d4 21       	pushm	r4-r7,lr
8000a92a:	16 97       	mov	r7,r11
8000a92c:	96 7b       	ld.sh	r11,r11[0xe]
8000a92e:	ce 5c       	rcall	8000aaf8 <_read_r>
8000a930:	c0 65       	brlt	8000a93c <__sread+0x14>
8000a932:	6f 58       	ld.w	r8,r7[0x54]
8000a934:	18 08       	add	r8,r12
8000a936:	ef 48 00 54 	st.w	r7[84],r8
8000a93a:	d8 22       	popm	r4-r7,pc
8000a93c:	8e 68       	ld.sh	r8,r7[0xc]
8000a93e:	ad c8       	cbr	r8,0xc
8000a940:	ae 68       	st.h	r7[0xc],r8
8000a942:	d8 22       	popm	r4-r7,pc

8000a944 <_write_r>:
8000a944:	d4 21       	pushm	r4-r7,lr
8000a946:	16 98       	mov	r8,r11
8000a948:	18 97       	mov	r7,r12
8000a94a:	10 9c       	mov	r12,r8
8000a94c:	30 08       	mov	r8,0
8000a94e:	14 9b       	mov	r11,r10
8000a950:	e0 66 40 04 	mov	r6,16388
8000a954:	12 9a       	mov	r10,r9
8000a956:	8d 08       	st.w	r6[0x0],r8
8000a958:	fe b0 d1 24 	rcall	80004ba0 <_write>
8000a95c:	5b fc       	cp.w	r12,-1
8000a95e:	c0 51       	brne	8000a968 <_write_r+0x24>
8000a960:	6c 08       	ld.w	r8,r6[0x0]
8000a962:	58 08       	cp.w	r8,0
8000a964:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a968:	d8 22       	popm	r4-r7,pc
8000a96a:	d7 03       	nop

8000a96c <_calloc_r>:
8000a96c:	d4 21       	pushm	r4-r7,lr
8000a96e:	f4 0b 02 4b 	mul	r11,r10,r11
8000a972:	fe b0 db 7f 	rcall	80006070 <_malloc_r>
8000a976:	18 97       	mov	r7,r12
8000a978:	c2 30       	breq	8000a9be <_calloc_r+0x52>
8000a97a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000a97e:	e0 1a ff fc 	andl	r10,0xfffc
8000a982:	20 4a       	sub	r10,4
8000a984:	e0 4a 00 24 	cp.w	r10,36
8000a988:	e0 8b 00 18 	brhi	8000a9b8 <_calloc_r+0x4c>
8000a98c:	18 98       	mov	r8,r12
8000a98e:	59 3a       	cp.w	r10,19
8000a990:	e0 88 00 0f 	brls	8000a9ae <_calloc_r+0x42>
8000a994:	30 09       	mov	r9,0
8000a996:	10 a9       	st.w	r8++,r9
8000a998:	10 a9       	st.w	r8++,r9
8000a99a:	59 ba       	cp.w	r10,27
8000a99c:	e0 88 00 09 	brls	8000a9ae <_calloc_r+0x42>
8000a9a0:	10 a9       	st.w	r8++,r9
8000a9a2:	10 a9       	st.w	r8++,r9
8000a9a4:	e0 4a 00 24 	cp.w	r10,36
8000a9a8:	c0 31       	brne	8000a9ae <_calloc_r+0x42>
8000a9aa:	10 a9       	st.w	r8++,r9
8000a9ac:	10 a9       	st.w	r8++,r9
8000a9ae:	30 09       	mov	r9,0
8000a9b0:	10 a9       	st.w	r8++,r9
8000a9b2:	91 19       	st.w	r8[0x4],r9
8000a9b4:	91 09       	st.w	r8[0x0],r9
8000a9b6:	c0 48       	rjmp	8000a9be <_calloc_r+0x52>
8000a9b8:	30 0b       	mov	r11,0
8000a9ba:	fe b0 de 1b 	rcall	800065f0 <memset>
8000a9be:	0e 9c       	mov	r12,r7
8000a9c0:	d8 22       	popm	r4-r7,pc
8000a9c2:	d7 03       	nop

8000a9c4 <_close_r>:
8000a9c4:	d4 21       	pushm	r4-r7,lr
8000a9c6:	30 08       	mov	r8,0
8000a9c8:	18 97       	mov	r7,r12
8000a9ca:	e0 66 40 04 	mov	r6,16388
8000a9ce:	16 9c       	mov	r12,r11
8000a9d0:	8d 08       	st.w	r6[0x0],r8
8000a9d2:	fe b0 df c1 	rcall	80006954 <_close>
8000a9d6:	5b fc       	cp.w	r12,-1
8000a9d8:	c0 51       	brne	8000a9e2 <_close_r+0x1e>
8000a9da:	6c 08       	ld.w	r8,r6[0x0]
8000a9dc:	58 08       	cp.w	r8,0
8000a9de:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a9e2:	d8 22       	popm	r4-r7,pc

8000a9e4 <_fclose_r>:
8000a9e4:	d4 21       	pushm	r4-r7,lr
8000a9e6:	18 96       	mov	r6,r12
8000a9e8:	16 97       	mov	r7,r11
8000a9ea:	58 0b       	cp.w	r11,0
8000a9ec:	c0 31       	brne	8000a9f2 <_fclose_r+0xe>
8000a9ee:	16 95       	mov	r5,r11
8000a9f0:	c5 38       	rjmp	8000aa96 <_fclose_r+0xb2>
8000a9f2:	fe b0 f8 b5 	rcall	80009b5c <__sfp_lock_acquire>
8000a9f6:	58 06       	cp.w	r6,0
8000a9f8:	c0 70       	breq	8000aa06 <_fclose_r+0x22>
8000a9fa:	6c 68       	ld.w	r8,r6[0x18]
8000a9fc:	58 08       	cp.w	r8,0
8000a9fe:	c0 41       	brne	8000aa06 <_fclose_r+0x22>
8000aa00:	0c 9c       	mov	r12,r6
8000aa02:	fe b0 f8 ff 	rcall	80009c00 <__sinit>
8000aa06:	fe c8 dd fa 	sub	r8,pc,-8710
8000aa0a:	10 37       	cp.w	r7,r8
8000aa0c:	c0 31       	brne	8000aa12 <_fclose_r+0x2e>
8000aa0e:	6c 07       	ld.w	r7,r6[0x0]
8000aa10:	c0 c8       	rjmp	8000aa28 <_fclose_r+0x44>
8000aa12:	fe c8 dd e6 	sub	r8,pc,-8730
8000aa16:	10 37       	cp.w	r7,r8
8000aa18:	c0 31       	brne	8000aa1e <_fclose_r+0x3a>
8000aa1a:	6c 17       	ld.w	r7,r6[0x4]
8000aa1c:	c0 68       	rjmp	8000aa28 <_fclose_r+0x44>
8000aa1e:	fe c8 dd d2 	sub	r8,pc,-8750
8000aa22:	10 37       	cp.w	r7,r8
8000aa24:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000aa28:	8e 69       	ld.sh	r9,r7[0xc]
8000aa2a:	30 08       	mov	r8,0
8000aa2c:	f0 09 19 00 	cp.h	r9,r8
8000aa30:	c0 51       	brne	8000aa3a <_fclose_r+0x56>
8000aa32:	fe b0 f8 96 	rcall	80009b5e <__sfp_lock_release>
8000aa36:	30 05       	mov	r5,0
8000aa38:	c2 f8       	rjmp	8000aa96 <_fclose_r+0xb2>
8000aa3a:	0e 9b       	mov	r11,r7
8000aa3c:	0c 9c       	mov	r12,r6
8000aa3e:	fe b0 f8 09 	rcall	80009a50 <_fflush_r>
8000aa42:	6e c8       	ld.w	r8,r7[0x30]
8000aa44:	18 95       	mov	r5,r12
8000aa46:	58 08       	cp.w	r8,0
8000aa48:	c0 60       	breq	8000aa54 <_fclose_r+0x70>
8000aa4a:	6e 8b       	ld.w	r11,r7[0x20]
8000aa4c:	0c 9c       	mov	r12,r6
8000aa4e:	5d 18       	icall	r8
8000aa50:	f9 b5 05 ff 	movlt	r5,-1
8000aa54:	8e 68       	ld.sh	r8,r7[0xc]
8000aa56:	ed b8 00 07 	bld	r8,0x7
8000aa5a:	c0 51       	brne	8000aa64 <_fclose_r+0x80>
8000aa5c:	6e 4b       	ld.w	r11,r7[0x10]
8000aa5e:	0c 9c       	mov	r12,r6
8000aa60:	fe b0 f9 6a 	rcall	80009d34 <_free_r>
8000aa64:	6e db       	ld.w	r11,r7[0x34]
8000aa66:	58 0b       	cp.w	r11,0
8000aa68:	c0 a0       	breq	8000aa7c <_fclose_r+0x98>
8000aa6a:	ee c8 ff bc 	sub	r8,r7,-68
8000aa6e:	10 3b       	cp.w	r11,r8
8000aa70:	c0 40       	breq	8000aa78 <_fclose_r+0x94>
8000aa72:	0c 9c       	mov	r12,r6
8000aa74:	fe b0 f9 60 	rcall	80009d34 <_free_r>
8000aa78:	30 08       	mov	r8,0
8000aa7a:	8f d8       	st.w	r7[0x34],r8
8000aa7c:	6f 2b       	ld.w	r11,r7[0x48]
8000aa7e:	58 0b       	cp.w	r11,0
8000aa80:	c0 70       	breq	8000aa8e <_fclose_r+0xaa>
8000aa82:	0c 9c       	mov	r12,r6
8000aa84:	fe b0 f9 58 	rcall	80009d34 <_free_r>
8000aa88:	30 08       	mov	r8,0
8000aa8a:	ef 48 00 48 	st.w	r7[72],r8
8000aa8e:	30 08       	mov	r8,0
8000aa90:	ae 68       	st.h	r7[0xc],r8
8000aa92:	fe b0 f8 66 	rcall	80009b5e <__sfp_lock_release>
8000aa96:	0a 9c       	mov	r12,r5
8000aa98:	d8 22       	popm	r4-r7,pc
8000aa9a:	d7 03       	nop

8000aa9c <fclose>:
8000aa9c:	d4 01       	pushm	lr
8000aa9e:	e0 68 0a 38 	mov	r8,2616
8000aaa2:	18 9b       	mov	r11,r12
8000aaa4:	70 0c       	ld.w	r12,r8[0x0]
8000aaa6:	c9 ff       	rcall	8000a9e4 <_fclose_r>
8000aaa8:	d8 02       	popm	pc
8000aaaa:	d7 03       	nop

8000aaac <_fstat_r>:
8000aaac:	d4 21       	pushm	r4-r7,lr
8000aaae:	16 98       	mov	r8,r11
8000aab0:	18 97       	mov	r7,r12
8000aab2:	10 9c       	mov	r12,r8
8000aab4:	30 08       	mov	r8,0
8000aab6:	e0 66 40 04 	mov	r6,16388
8000aaba:	14 9b       	mov	r11,r10
8000aabc:	8d 08       	st.w	r6[0x0],r8
8000aabe:	fe b0 df 73 	rcall	800069a4 <_fstat>
8000aac2:	5b fc       	cp.w	r12,-1
8000aac4:	c0 51       	brne	8000aace <_fstat_r+0x22>
8000aac6:	6c 08       	ld.w	r8,r6[0x0]
8000aac8:	58 08       	cp.w	r8,0
8000aaca:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aace:	d8 22       	popm	r4-r7,pc

8000aad0 <_lseek_r>:
8000aad0:	d4 21       	pushm	r4-r7,lr
8000aad2:	16 98       	mov	r8,r11
8000aad4:	18 97       	mov	r7,r12
8000aad6:	10 9c       	mov	r12,r8
8000aad8:	30 08       	mov	r8,0
8000aada:	14 9b       	mov	r11,r10
8000aadc:	e0 66 40 04 	mov	r6,16388
8000aae0:	12 9a       	mov	r10,r9
8000aae2:	8d 08       	st.w	r6[0x0],r8
8000aae4:	fe b0 df 42 	rcall	80006968 <_lseek>
8000aae8:	5b fc       	cp.w	r12,-1
8000aaea:	c0 51       	brne	8000aaf4 <_lseek_r+0x24>
8000aaec:	6c 08       	ld.w	r8,r6[0x0]
8000aaee:	58 08       	cp.w	r8,0
8000aaf0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aaf4:	d8 22       	popm	r4-r7,pc
8000aaf6:	d7 03       	nop

8000aaf8 <_read_r>:
8000aaf8:	d4 21       	pushm	r4-r7,lr
8000aafa:	16 98       	mov	r8,r11
8000aafc:	18 97       	mov	r7,r12
8000aafe:	10 9c       	mov	r12,r8
8000ab00:	30 08       	mov	r8,0
8000ab02:	14 9b       	mov	r11,r10
8000ab04:	e0 66 40 04 	mov	r6,16388
8000ab08:	12 9a       	mov	r10,r9
8000ab0a:	8d 08       	st.w	r6[0x0],r8
8000ab0c:	fe b0 d0 2a 	rcall	80004b60 <_read>
8000ab10:	5b fc       	cp.w	r12,-1
8000ab12:	c0 51       	brne	8000ab1c <_read_r+0x24>
8000ab14:	6c 08       	ld.w	r8,r6[0x0]
8000ab16:	58 08       	cp.w	r8,0
8000ab18:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000ab1c:	d8 22       	popm	r4-r7,pc
8000ab1e:	d7 03       	nop

8000ab20 <__avr32_f64_mul>:
8000ab20:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ab24:	e0 80 00 dc 	breq	8000acdc <__avr32_f64_mul_op1_zero>
8000ab28:	d4 21       	pushm	r4-r7,lr
8000ab2a:	f7 e9 20 0e 	eor	lr,r11,r9
8000ab2e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ab32:	30 15       	mov	r5,1
8000ab34:	c4 30       	breq	8000abba <__avr32_f64_mul_op1_subnormal>
8000ab36:	ab 6b       	lsl	r11,0xa
8000ab38:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ab3c:	ab 6a       	lsl	r10,0xa
8000ab3e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ab42:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ab46:	c5 c0       	breq	8000abfe <__avr32_f64_mul_op2_subnormal>
8000ab48:	a1 78       	lsl	r8,0x1
8000ab4a:	5c f9       	rol	r9
8000ab4c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ab50:	e0 47 07 ff 	cp.w	r7,2047
8000ab54:	c7 70       	breq	8000ac42 <__avr32_f64_mul_op_nan_or_inf>
8000ab56:	e0 46 07 ff 	cp.w	r6,2047
8000ab5a:	c7 40       	breq	8000ac42 <__avr32_f64_mul_op_nan_or_inf>
8000ab5c:	ee 06 00 0c 	add	r12,r7,r6
8000ab60:	e0 2c 03 fe 	sub	r12,1022
8000ab64:	f6 08 06 44 	mulu.d	r4,r11,r8
8000ab68:	f4 09 07 44 	macu.d	r4,r10,r9
8000ab6c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ab70:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000ab74:	08 07       	add	r7,r4
8000ab76:	f4 05 00 4a 	adc	r10,r10,r5
8000ab7a:	5c 0b       	acr	r11
8000ab7c:	ed bb 00 14 	bld	r11,0x14
8000ab80:	c0 50       	breq	8000ab8a <__avr32_f64_mul+0x6a>
8000ab82:	a1 77       	lsl	r7,0x1
8000ab84:	5c fa       	rol	r10
8000ab86:	5c fb       	rol	r11
8000ab88:	20 1c       	sub	r12,1
8000ab8a:	58 0c       	cp.w	r12,0
8000ab8c:	e0 8a 00 6f 	brle	8000ac6a <__avr32_f64_mul_res_subnormal>
8000ab90:	e0 4c 07 ff 	cp.w	r12,2047
8000ab94:	e0 84 00 9c 	brge	8000accc <__avr32_f64_mul_res_inf>
8000ab98:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000ab9c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000aba0:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000aba4:	ee 17 80 00 	eorh	r7,0x8000
8000aba8:	f1 b7 04 20 	satu	r7,0x1
8000abac:	0e 0a       	add	r10,r7
8000abae:	5c 0b       	acr	r11
8000abb0:	ed be 00 1f 	bld	lr,0x1f
8000abb4:	ef bb 00 1f 	bst	r11,0x1f
8000abb8:	d8 22       	popm	r4-r7,pc

8000abba <__avr32_f64_mul_op1_subnormal>:
8000abba:	e4 1b 00 0f 	andh	r11,0xf
8000abbe:	f4 0c 12 00 	clz	r12,r10
8000abc2:	f6 06 12 00 	clz	r6,r11
8000abc6:	f7 bc 03 e1 	sublo	r12,-31
8000abca:	f8 06 17 30 	movlo	r6,r12
8000abce:	f7 b6 02 01 	subhs	r6,1
8000abd2:	e0 46 00 20 	cp.w	r6,32
8000abd6:	c0 d4       	brge	8000abf0 <__avr32_f64_mul_op1_subnormal+0x36>
8000abd8:	ec 0c 11 20 	rsub	r12,r6,32
8000abdc:	f6 06 09 4b 	lsl	r11,r11,r6
8000abe0:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000abe4:	18 4b       	or	r11,r12
8000abe6:	f4 06 09 4a 	lsl	r10,r10,r6
8000abea:	20 b6       	sub	r6,11
8000abec:	0c 17       	sub	r7,r6
8000abee:	ca ab       	rjmp	8000ab42 <__avr32_f64_mul+0x22>
8000abf0:	f4 06 09 4b 	lsl	r11,r10,r6
8000abf4:	c6 40       	breq	8000acbc <__avr32_f64_mul_res_zero>
8000abf6:	30 0a       	mov	r10,0
8000abf8:	20 b6       	sub	r6,11
8000abfa:	0c 17       	sub	r7,r6
8000abfc:	ca 3b       	rjmp	8000ab42 <__avr32_f64_mul+0x22>

8000abfe <__avr32_f64_mul_op2_subnormal>:
8000abfe:	e4 19 00 0f 	andh	r9,0xf
8000ac02:	f0 0c 12 00 	clz	r12,r8
8000ac06:	f2 05 12 00 	clz	r5,r9
8000ac0a:	f7 bc 03 ea 	sublo	r12,-22
8000ac0e:	f8 05 17 30 	movlo	r5,r12
8000ac12:	f7 b5 02 0a 	subhs	r5,10
8000ac16:	e0 45 00 20 	cp.w	r5,32
8000ac1a:	c0 d4       	brge	8000ac34 <__avr32_f64_mul_op2_subnormal+0x36>
8000ac1c:	ea 0c 11 20 	rsub	r12,r5,32
8000ac20:	f2 05 09 49 	lsl	r9,r9,r5
8000ac24:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ac28:	18 49       	or	r9,r12
8000ac2a:	f0 05 09 48 	lsl	r8,r8,r5
8000ac2e:	20 25       	sub	r5,2
8000ac30:	0a 16       	sub	r6,r5
8000ac32:	c8 fb       	rjmp	8000ab50 <__avr32_f64_mul+0x30>
8000ac34:	f0 05 09 49 	lsl	r9,r8,r5
8000ac38:	c4 20       	breq	8000acbc <__avr32_f64_mul_res_zero>
8000ac3a:	30 08       	mov	r8,0
8000ac3c:	20 25       	sub	r5,2
8000ac3e:	0a 16       	sub	r6,r5
8000ac40:	c8 8b       	rjmp	8000ab50 <__avr32_f64_mul+0x30>

8000ac42 <__avr32_f64_mul_op_nan_or_inf>:
8000ac42:	e4 19 00 0f 	andh	r9,0xf
8000ac46:	e4 1b 00 0f 	andh	r11,0xf
8000ac4a:	14 4b       	or	r11,r10
8000ac4c:	10 49       	or	r9,r8
8000ac4e:	e0 47 07 ff 	cp.w	r7,2047
8000ac52:	c0 91       	brne	8000ac64 <__avr32_f64_mul_op1_not_naninf>
8000ac54:	58 0b       	cp.w	r11,0
8000ac56:	c3 81       	brne	8000acc6 <__avr32_f64_mul_res_nan>
8000ac58:	e0 46 07 ff 	cp.w	r6,2047
8000ac5c:	c3 81       	brne	8000accc <__avr32_f64_mul_res_inf>
8000ac5e:	58 09       	cp.w	r9,0
8000ac60:	c3 60       	breq	8000accc <__avr32_f64_mul_res_inf>
8000ac62:	c3 28       	rjmp	8000acc6 <__avr32_f64_mul_res_nan>

8000ac64 <__avr32_f64_mul_op1_not_naninf>:
8000ac64:	58 09       	cp.w	r9,0
8000ac66:	c3 30       	breq	8000accc <__avr32_f64_mul_res_inf>
8000ac68:	c2 f8       	rjmp	8000acc6 <__avr32_f64_mul_res_nan>

8000ac6a <__avr32_f64_mul_res_subnormal>:
8000ac6a:	5c 3c       	neg	r12
8000ac6c:	2f fc       	sub	r12,-1
8000ac6e:	f1 bc 04 c0 	satu	r12,0x6
8000ac72:	e0 4c 00 20 	cp.w	r12,32
8000ac76:	c1 14       	brge	8000ac98 <__avr32_f64_mul_res_subnormal+0x2e>
8000ac78:	f8 08 11 20 	rsub	r8,r12,32
8000ac7c:	0e 46       	or	r6,r7
8000ac7e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ac82:	f4 08 09 49 	lsl	r9,r10,r8
8000ac86:	12 47       	or	r7,r9
8000ac88:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ac8c:	f6 08 09 49 	lsl	r9,r11,r8
8000ac90:	12 4a       	or	r10,r9
8000ac92:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ac96:	c8 3b       	rjmp	8000ab9c <__avr32_f64_mul+0x7c>
8000ac98:	f8 08 11 20 	rsub	r8,r12,32
8000ac9c:	f9 b9 00 00 	moveq	r9,0
8000aca0:	c0 30       	breq	8000aca6 <__avr32_f64_mul_res_subnormal+0x3c>
8000aca2:	f6 08 09 49 	lsl	r9,r11,r8
8000aca6:	0e 46       	or	r6,r7
8000aca8:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000acac:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000acb0:	f3 ea 10 07 	or	r7,r9,r10
8000acb4:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000acb8:	30 0b       	mov	r11,0
8000acba:	c7 1b       	rjmp	8000ab9c <__avr32_f64_mul+0x7c>

8000acbc <__avr32_f64_mul_res_zero>:
8000acbc:	1c 9b       	mov	r11,lr
8000acbe:	e6 1b 80 00 	andh	r11,0x8000,COH
8000acc2:	30 0a       	mov	r10,0
8000acc4:	d8 22       	popm	r4-r7,pc

8000acc6 <__avr32_f64_mul_res_nan>:
8000acc6:	3f fb       	mov	r11,-1
8000acc8:	3f fa       	mov	r10,-1
8000acca:	d8 22       	popm	r4-r7,pc

8000accc <__avr32_f64_mul_res_inf>:
8000accc:	f0 6b 00 00 	mov	r11,-1048576
8000acd0:	ed be 00 1f 	bld	lr,0x1f
8000acd4:	ef bb 00 1f 	bst	r11,0x1f
8000acd8:	30 0a       	mov	r10,0
8000acda:	d8 22       	popm	r4-r7,pc

8000acdc <__avr32_f64_mul_op1_zero>:
8000acdc:	f7 e9 20 0b 	eor	r11,r11,r9
8000ace0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000ace4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000ace8:	e0 4c 07 ff 	cp.w	r12,2047
8000acec:	5e 1c       	retne	r12
8000acee:	3f fa       	mov	r10,-1
8000acf0:	3f fb       	mov	r11,-1
8000acf2:	5e fc       	retal	r12

8000acf4 <__avr32_f64_sub_from_add>:
8000acf4:	ee 19 80 00 	eorh	r9,0x8000

8000acf8 <__avr32_f64_sub>:
8000acf8:	f7 e9 20 0c 	eor	r12,r11,r9
8000acfc:	e0 86 00 ca 	brmi	8000ae90 <__avr32_f64_add_from_sub>
8000ad00:	eb cd 40 e0 	pushm	r5-r7,lr
8000ad04:	16 9c       	mov	r12,r11
8000ad06:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ad0a:	bf db       	cbr	r11,0x1f
8000ad0c:	bf d9       	cbr	r9,0x1f
8000ad0e:	10 3a       	cp.w	r10,r8
8000ad10:	f2 0b 13 00 	cpc	r11,r9
8000ad14:	c0 92       	brcc	8000ad26 <__avr32_f64_sub+0x2e>
8000ad16:	16 97       	mov	r7,r11
8000ad18:	12 9b       	mov	r11,r9
8000ad1a:	0e 99       	mov	r9,r7
8000ad1c:	14 97       	mov	r7,r10
8000ad1e:	10 9a       	mov	r10,r8
8000ad20:	0e 98       	mov	r8,r7
8000ad22:	ee 1c 80 00 	eorh	r12,0x8000
8000ad26:	f6 07 16 14 	lsr	r7,r11,0x14
8000ad2a:	ab 7b       	lsl	r11,0xb
8000ad2c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ad30:	ab 7a       	lsl	r10,0xb
8000ad32:	bf bb       	sbr	r11,0x1f
8000ad34:	f2 06 16 14 	lsr	r6,r9,0x14
8000ad38:	c4 40       	breq	8000adc0 <__avr32_f64_sub_opL_subnormal>
8000ad3a:	ab 79       	lsl	r9,0xb
8000ad3c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ad40:	ab 78       	lsl	r8,0xb
8000ad42:	bf b9       	sbr	r9,0x1f

8000ad44 <__avr32_f64_sub_opL_subnormal_done>:
8000ad44:	e0 47 07 ff 	cp.w	r7,2047
8000ad48:	c4 f0       	breq	8000ade6 <__avr32_f64_sub_opH_nan_or_inf>
8000ad4a:	0e 26       	rsub	r6,r7
8000ad4c:	c1 20       	breq	8000ad70 <__avr32_f64_sub_shift_done>
8000ad4e:	ec 05 11 20 	rsub	r5,r6,32
8000ad52:	e0 46 00 20 	cp.w	r6,32
8000ad56:	c7 c2       	brcc	8000ae4e <__avr32_f64_sub_longshift>
8000ad58:	f0 05 09 4e 	lsl	lr,r8,r5
8000ad5c:	f2 05 09 45 	lsl	r5,r9,r5
8000ad60:	f0 06 0a 48 	lsr	r8,r8,r6
8000ad64:	f2 06 0a 49 	lsr	r9,r9,r6
8000ad68:	0a 48       	or	r8,r5
8000ad6a:	58 0e       	cp.w	lr,0
8000ad6c:	5f 1e       	srne	lr
8000ad6e:	1c 48       	or	r8,lr

8000ad70 <__avr32_f64_sub_shift_done>:
8000ad70:	10 1a       	sub	r10,r8
8000ad72:	f6 09 01 4b 	sbc	r11,r11,r9
8000ad76:	f6 06 12 00 	clz	r6,r11
8000ad7a:	c0 e0       	breq	8000ad96 <__avr32_f64_sub_longnormalize_done>
8000ad7c:	c7 83       	brcs	8000ae6c <__avr32_f64_sub_longnormalize>
8000ad7e:	ec 0e 11 20 	rsub	lr,r6,32
8000ad82:	f6 06 09 4b 	lsl	r11,r11,r6
8000ad86:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ad8a:	1c 4b       	or	r11,lr
8000ad8c:	f4 06 09 4a 	lsl	r10,r10,r6
8000ad90:	0c 17       	sub	r7,r6
8000ad92:	e0 8a 00 39 	brle	8000ae04 <__avr32_f64_sub_subnormal_result>

8000ad96 <__avr32_f64_sub_longnormalize_done>:
8000ad96:	f4 09 15 15 	lsl	r9,r10,0x15
8000ad9a:	ab 9a       	lsr	r10,0xb
8000ad9c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ada0:	ab 9b       	lsr	r11,0xb
8000ada2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ada6:	18 4b       	or	r11,r12

8000ada8 <__avr32_f64_sub_round>:
8000ada8:	fc 17 80 00 	movh	r7,0x8000
8000adac:	ed ba 00 00 	bld	r10,0x0
8000adb0:	f7 b7 01 ff 	subne	r7,-1
8000adb4:	0e 39       	cp.w	r9,r7
8000adb6:	5f 29       	srhs	r9
8000adb8:	12 0a       	add	r10,r9
8000adba:	5c 0b       	acr	r11
8000adbc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000adc0 <__avr32_f64_sub_opL_subnormal>:
8000adc0:	ab 79       	lsl	r9,0xb
8000adc2:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000adc6:	ab 78       	lsl	r8,0xb
8000adc8:	f3 e8 10 0e 	or	lr,r9,r8
8000adcc:	f9 b6 01 01 	movne	r6,1
8000add0:	ee 0e 11 00 	rsub	lr,r7,0
8000add4:	f9 b7 00 01 	moveq	r7,1
8000add8:	ef bb 00 1f 	bst	r11,0x1f
8000addc:	f7 ea 10 0e 	or	lr,r11,r10
8000ade0:	f9 b7 00 00 	moveq	r7,0
8000ade4:	cb 0b       	rjmp	8000ad44 <__avr32_f64_sub_opL_subnormal_done>

8000ade6 <__avr32_f64_sub_opH_nan_or_inf>:
8000ade6:	bf db       	cbr	r11,0x1f
8000ade8:	f7 ea 10 0e 	or	lr,r11,r10
8000adec:	c0 81       	brne	8000adfc <__avr32_f64_sub_return_nan>
8000adee:	e0 46 07 ff 	cp.w	r6,2047
8000adf2:	c0 50       	breq	8000adfc <__avr32_f64_sub_return_nan>
8000adf4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000adf8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000adfc <__avr32_f64_sub_return_nan>:
8000adfc:	3f fa       	mov	r10,-1
8000adfe:	3f fb       	mov	r11,-1
8000ae00:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ae04 <__avr32_f64_sub_subnormal_result>:
8000ae04:	5c 37       	neg	r7
8000ae06:	2f f7       	sub	r7,-1
8000ae08:	f1 b7 04 c0 	satu	r7,0x6
8000ae0c:	e0 47 00 20 	cp.w	r7,32
8000ae10:	c1 14       	brge	8000ae32 <__avr32_f64_sub_subnormal_result+0x2e>
8000ae12:	ee 08 11 20 	rsub	r8,r7,32
8000ae16:	f4 08 09 49 	lsl	r9,r10,r8
8000ae1a:	5f 16       	srne	r6
8000ae1c:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ae20:	0c 4a       	or	r10,r6
8000ae22:	f6 08 09 49 	lsl	r9,r11,r8
8000ae26:	f5 e9 10 0a 	or	r10,r10,r9
8000ae2a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000ae2e:	30 07       	mov	r7,0
8000ae30:	cb 3b       	rjmp	8000ad96 <__avr32_f64_sub_longnormalize_done>
8000ae32:	ee 08 11 40 	rsub	r8,r7,64
8000ae36:	f6 08 09 49 	lsl	r9,r11,r8
8000ae3a:	14 49       	or	r9,r10
8000ae3c:	5f 16       	srne	r6
8000ae3e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000ae42:	0c 4a       	or	r10,r6
8000ae44:	30 0b       	mov	r11,0
8000ae46:	30 07       	mov	r7,0
8000ae48:	ca 7b       	rjmp	8000ad96 <__avr32_f64_sub_longnormalize_done>
8000ae4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ae4e <__avr32_f64_sub_longshift>:
8000ae4e:	f1 b6 04 c0 	satu	r6,0x6
8000ae52:	f0 0e 17 00 	moveq	lr,r8
8000ae56:	c0 40       	breq	8000ae5e <__avr32_f64_sub_longshift+0x10>
8000ae58:	f2 05 09 4e 	lsl	lr,r9,r5
8000ae5c:	10 4e       	or	lr,r8
8000ae5e:	f2 06 0a 48 	lsr	r8,r9,r6
8000ae62:	30 09       	mov	r9,0
8000ae64:	58 0e       	cp.w	lr,0
8000ae66:	5f 1e       	srne	lr
8000ae68:	1c 48       	or	r8,lr
8000ae6a:	c8 3b       	rjmp	8000ad70 <__avr32_f64_sub_shift_done>

8000ae6c <__avr32_f64_sub_longnormalize>:
8000ae6c:	f4 06 12 00 	clz	r6,r10
8000ae70:	f9 b7 03 00 	movlo	r7,0
8000ae74:	f9 b6 03 00 	movlo	r6,0
8000ae78:	f9 bc 03 00 	movlo	r12,0
8000ae7c:	f7 b6 02 e0 	subhs	r6,-32
8000ae80:	f4 06 09 4b 	lsl	r11,r10,r6
8000ae84:	30 0a       	mov	r10,0
8000ae86:	0c 17       	sub	r7,r6
8000ae88:	fe 9a ff be 	brle	8000ae04 <__avr32_f64_sub_subnormal_result>
8000ae8c:	c8 5b       	rjmp	8000ad96 <__avr32_f64_sub_longnormalize_done>
8000ae8e:	d7 03       	nop

8000ae90 <__avr32_f64_add_from_sub>:
8000ae90:	ee 19 80 00 	eorh	r9,0x8000

8000ae94 <__avr32_f64_add>:
8000ae94:	f7 e9 20 0c 	eor	r12,r11,r9
8000ae98:	fe 96 ff 2e 	brmi	8000acf4 <__avr32_f64_sub_from_add>
8000ae9c:	eb cd 40 e0 	pushm	r5-r7,lr
8000aea0:	16 9c       	mov	r12,r11
8000aea2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000aea6:	bf db       	cbr	r11,0x1f
8000aea8:	bf d9       	cbr	r9,0x1f
8000aeaa:	12 3b       	cp.w	r11,r9
8000aeac:	c0 72       	brcc	8000aeba <__avr32_f64_add+0x26>
8000aeae:	16 97       	mov	r7,r11
8000aeb0:	12 9b       	mov	r11,r9
8000aeb2:	0e 99       	mov	r9,r7
8000aeb4:	14 97       	mov	r7,r10
8000aeb6:	10 9a       	mov	r10,r8
8000aeb8:	0e 98       	mov	r8,r7
8000aeba:	30 0e       	mov	lr,0
8000aebc:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000aec0:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000aec4:	b5 ab       	sbr	r11,0x14
8000aec6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000aeca:	c6 20       	breq	8000af8e <__avr32_f64_add_op2_subnormal>
8000aecc:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000aed0:	b5 a9       	sbr	r9,0x14
8000aed2:	e0 47 07 ff 	cp.w	r7,2047
8000aed6:	c2 80       	breq	8000af26 <__avr32_f64_add_opH_nan_or_inf>
8000aed8:	0e 26       	rsub	r6,r7
8000aeda:	c1 20       	breq	8000aefe <__avr32_f64_add_shift_done>
8000aedc:	e0 46 00 36 	cp.w	r6,54
8000aee0:	c1 52       	brcc	8000af0a <__avr32_f64_add_res_of_done>
8000aee2:	ec 05 11 20 	rsub	r5,r6,32
8000aee6:	e0 46 00 20 	cp.w	r6,32
8000aeea:	c3 52       	brcc	8000af54 <__avr32_f64_add_longshift>
8000aeec:	f0 05 09 4e 	lsl	lr,r8,r5
8000aef0:	f2 05 09 45 	lsl	r5,r9,r5
8000aef4:	f0 06 0a 48 	lsr	r8,r8,r6
8000aef8:	f2 06 0a 49 	lsr	r9,r9,r6
8000aefc:	0a 48       	or	r8,r5

8000aefe <__avr32_f64_add_shift_done>:
8000aefe:	10 0a       	add	r10,r8
8000af00:	f6 09 00 4b 	adc	r11,r11,r9
8000af04:	ed bb 00 15 	bld	r11,0x15
8000af08:	c3 40       	breq	8000af70 <__avr32_f64_add_res_of>

8000af0a <__avr32_f64_add_res_of_done>:
8000af0a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000af0e:	18 4b       	or	r11,r12

8000af10 <__avr32_f64_add_round>:
8000af10:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000af14:	18 4e       	or	lr,r12
8000af16:	ee 1e 80 00 	eorh	lr,0x8000
8000af1a:	f1 be 04 20 	satu	lr,0x1
8000af1e:	1c 0a       	add	r10,lr
8000af20:	5c 0b       	acr	r11
8000af22:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af26 <__avr32_f64_add_opH_nan_or_inf>:
8000af26:	b5 cb       	cbr	r11,0x14
8000af28:	f7 ea 10 0e 	or	lr,r11,r10
8000af2c:	c1 01       	brne	8000af4c <__avr32_f64_add_return_nan>
8000af2e:	e0 46 07 ff 	cp.w	r6,2047
8000af32:	c0 30       	breq	8000af38 <__avr32_f64_add_opL_nan_or_inf>
8000af34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af38 <__avr32_f64_add_opL_nan_or_inf>:
8000af38:	b5 c9       	cbr	r9,0x14
8000af3a:	f3 e8 10 0e 	or	lr,r9,r8
8000af3e:	c0 71       	brne	8000af4c <__avr32_f64_add_return_nan>
8000af40:	30 0a       	mov	r10,0
8000af42:	fc 1b 7f f0 	movh	r11,0x7ff0
8000af46:	18 4b       	or	r11,r12
8000af48:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af4c <__avr32_f64_add_return_nan>:
8000af4c:	3f fa       	mov	r10,-1
8000af4e:	3f fb       	mov	r11,-1
8000af50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af54 <__avr32_f64_add_longshift>:
8000af54:	f1 b6 04 c0 	satu	r6,0x6
8000af58:	f0 0e 17 00 	moveq	lr,r8
8000af5c:	c0 60       	breq	8000af68 <__avr32_f64_add_longshift+0x14>
8000af5e:	f2 05 09 4e 	lsl	lr,r9,r5
8000af62:	58 08       	cp.w	r8,0
8000af64:	5f 18       	srne	r8
8000af66:	10 4e       	or	lr,r8
8000af68:	f2 06 0a 48 	lsr	r8,r9,r6
8000af6c:	30 09       	mov	r9,0
8000af6e:	cc 8b       	rjmp	8000aefe <__avr32_f64_add_shift_done>

8000af70 <__avr32_f64_add_res_of>:
8000af70:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000af74:	a1 9b       	lsr	r11,0x1
8000af76:	5d 0a       	ror	r10
8000af78:	5d 0e       	ror	lr
8000af7a:	2f f7       	sub	r7,-1
8000af7c:	e0 47 07 ff 	cp.w	r7,2047
8000af80:	f9 ba 00 00 	moveq	r10,0
8000af84:	f9 bb 00 00 	moveq	r11,0
8000af88:	f9 be 00 00 	moveq	lr,0
8000af8c:	cb fb       	rjmp	8000af0a <__avr32_f64_add_res_of_done>

8000af8e <__avr32_f64_add_op2_subnormal>:
8000af8e:	30 16       	mov	r6,1
8000af90:	58 07       	cp.w	r7,0
8000af92:	ca 01       	brne	8000aed2 <__avr32_f64_add+0x3e>
8000af94:	b5 cb       	cbr	r11,0x14
8000af96:	10 0a       	add	r10,r8
8000af98:	f6 09 00 4b 	adc	r11,r11,r9
8000af9c:	18 4b       	or	r11,r12
8000af9e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000afa2:	d7 03       	nop

8000afa4 <__avr32_f64_to_u32>:
8000afa4:	58 0b       	cp.w	r11,0
8000afa6:	5e 6d       	retmi	0

8000afa8 <__avr32_f64_to_s32>:
8000afa8:	f6 0c 15 01 	lsl	r12,r11,0x1
8000afac:	b5 9c       	lsr	r12,0x15
8000afae:	e0 2c 03 ff 	sub	r12,1023
8000afb2:	5e 3d       	retlo	0
8000afb4:	f8 0c 11 1f 	rsub	r12,r12,31
8000afb8:	16 99       	mov	r9,r11
8000afba:	ab 7b       	lsl	r11,0xb
8000afbc:	bf bb       	sbr	r11,0x1f
8000afbe:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000afc2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000afc6:	a1 79       	lsl	r9,0x1
8000afc8:	5e 2b       	reths	r11
8000afca:	5c 3b       	neg	r11
8000afcc:	5e fb       	retal	r11

8000afce <__avr32_u32_to_f64>:
8000afce:	f8 cb 00 00 	sub	r11,r12,0
8000afd2:	30 0c       	mov	r12,0
8000afd4:	c0 38       	rjmp	8000afda <__avr32_s32_to_f64+0x4>

8000afd6 <__avr32_s32_to_f64>:
8000afd6:	18 9b       	mov	r11,r12
8000afd8:	5c 4b       	abs	r11
8000afda:	30 0a       	mov	r10,0
8000afdc:	5e 0b       	reteq	r11
8000afde:	d4 01       	pushm	lr
8000afe0:	e0 69 04 1e 	mov	r9,1054
8000afe4:	f6 08 12 00 	clz	r8,r11
8000afe8:	c1 70       	breq	8000b016 <__avr32_s32_to_f64+0x40>
8000afea:	c0 c3       	brcs	8000b002 <__avr32_s32_to_f64+0x2c>
8000afec:	f0 0e 11 20 	rsub	lr,r8,32
8000aff0:	f6 08 09 4b 	lsl	r11,r11,r8
8000aff4:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000aff8:	1c 4b       	or	r11,lr
8000affa:	f4 08 09 4a 	lsl	r10,r10,r8
8000affe:	10 19       	sub	r9,r8
8000b000:	c0 b8       	rjmp	8000b016 <__avr32_s32_to_f64+0x40>
8000b002:	f4 08 12 00 	clz	r8,r10
8000b006:	f9 b8 03 00 	movlo	r8,0
8000b00a:	f7 b8 02 e0 	subhs	r8,-32
8000b00e:	f4 08 09 4b 	lsl	r11,r10,r8
8000b012:	30 0a       	mov	r10,0
8000b014:	10 19       	sub	r9,r8
8000b016:	58 09       	cp.w	r9,0
8000b018:	e0 89 00 30 	brgt	8000b078 <__avr32_s32_to_f64+0xa2>
8000b01c:	5c 39       	neg	r9
8000b01e:	2f f9       	sub	r9,-1
8000b020:	e0 49 00 36 	cp.w	r9,54
8000b024:	c0 43       	brcs	8000b02c <__avr32_s32_to_f64+0x56>
8000b026:	30 0b       	mov	r11,0
8000b028:	30 0a       	mov	r10,0
8000b02a:	c2 68       	rjmp	8000b076 <__avr32_s32_to_f64+0xa0>
8000b02c:	2f 69       	sub	r9,-10
8000b02e:	f2 08 11 20 	rsub	r8,r9,32
8000b032:	e0 49 00 20 	cp.w	r9,32
8000b036:	c0 b2       	brcc	8000b04c <__avr32_s32_to_f64+0x76>
8000b038:	f4 08 09 4e 	lsl	lr,r10,r8
8000b03c:	f6 08 09 48 	lsl	r8,r11,r8
8000b040:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b044:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b048:	10 4b       	or	r11,r8
8000b04a:	c0 88       	rjmp	8000b05a <__avr32_s32_to_f64+0x84>
8000b04c:	f6 08 09 4e 	lsl	lr,r11,r8
8000b050:	14 4e       	or	lr,r10
8000b052:	16 9a       	mov	r10,r11
8000b054:	30 0b       	mov	r11,0
8000b056:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b05a:	ed ba 00 00 	bld	r10,0x0
8000b05e:	c0 92       	brcc	8000b070 <__avr32_s32_to_f64+0x9a>
8000b060:	1c 7e       	tst	lr,lr
8000b062:	c0 41       	brne	8000b06a <__avr32_s32_to_f64+0x94>
8000b064:	ed ba 00 01 	bld	r10,0x1
8000b068:	c0 42       	brcc	8000b070 <__avr32_s32_to_f64+0x9a>
8000b06a:	2f fa       	sub	r10,-1
8000b06c:	f7 bb 02 ff 	subhs	r11,-1
8000b070:	5c fc       	rol	r12
8000b072:	5d 0b       	ror	r11
8000b074:	5d 0a       	ror	r10
8000b076:	d8 02       	popm	pc
8000b078:	e0 68 03 ff 	mov	r8,1023
8000b07c:	ed ba 00 0b 	bld	r10,0xb
8000b080:	f7 b8 00 ff 	subeq	r8,-1
8000b084:	10 0a       	add	r10,r8
8000b086:	5c 0b       	acr	r11
8000b088:	f7 b9 03 fe 	sublo	r9,-2
8000b08c:	e0 49 07 ff 	cp.w	r9,2047
8000b090:	c0 55       	brlt	8000b09a <__avr32_s32_to_f64+0xc4>
8000b092:	30 0a       	mov	r10,0
8000b094:	fc 1b ff e0 	movh	r11,0xffe0
8000b098:	c0 c8       	rjmp	8000b0b0 <__floatsidf_return_op1>
8000b09a:	ed bb 00 1f 	bld	r11,0x1f
8000b09e:	f7 b9 01 01 	subne	r9,1
8000b0a2:	ab 9a       	lsr	r10,0xb
8000b0a4:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b0a8:	a1 7b       	lsl	r11,0x1
8000b0aa:	ab 9b       	lsr	r11,0xb
8000b0ac:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b0b0 <__floatsidf_return_op1>:
8000b0b0:	a1 7c       	lsl	r12,0x1
8000b0b2:	5d 0b       	ror	r11
8000b0b4:	d8 02       	popm	pc

8000b0b6 <__avr32_f64_cmp_eq>:
8000b0b6:	10 3a       	cp.w	r10,r8
8000b0b8:	f2 0b 13 00 	cpc	r11,r9
8000b0bc:	c0 80       	breq	8000b0cc <__avr32_f64_cmp_eq+0x16>
8000b0be:	a1 7b       	lsl	r11,0x1
8000b0c0:	a1 79       	lsl	r9,0x1
8000b0c2:	14 4b       	or	r11,r10
8000b0c4:	12 4b       	or	r11,r9
8000b0c6:	10 4b       	or	r11,r8
8000b0c8:	5e 0f       	reteq	1
8000b0ca:	5e fd       	retal	0
8000b0cc:	a1 7b       	lsl	r11,0x1
8000b0ce:	fc 1c ff e0 	movh	r12,0xffe0
8000b0d2:	58 0a       	cp.w	r10,0
8000b0d4:	f8 0b 13 00 	cpc	r11,r12
8000b0d8:	5e 8f       	retls	1
8000b0da:	5e fd       	retal	0

8000b0dc <__avr32_f64_cmp_ge>:
8000b0dc:	1a de       	st.w	--sp,lr
8000b0de:	1a d7       	st.w	--sp,r7
8000b0e0:	a1 7b       	lsl	r11,0x1
8000b0e2:	5f 3c       	srlo	r12
8000b0e4:	a1 79       	lsl	r9,0x1
8000b0e6:	5f 37       	srlo	r7
8000b0e8:	5c fc       	rol	r12
8000b0ea:	fc 1e ff e0 	movh	lr,0xffe0
8000b0ee:	58 0a       	cp.w	r10,0
8000b0f0:	fc 0b 13 00 	cpc	r11,lr
8000b0f4:	e0 8b 00 1d 	brhi	8000b12e <__avr32_f64_cmp_ge+0x52>
8000b0f8:	58 08       	cp.w	r8,0
8000b0fa:	fc 09 13 00 	cpc	r9,lr
8000b0fe:	e0 8b 00 18 	brhi	8000b12e <__avr32_f64_cmp_ge+0x52>
8000b102:	58 0b       	cp.w	r11,0
8000b104:	f5 ba 00 00 	subfeq	r10,0
8000b108:	c1 50       	breq	8000b132 <__avr32_f64_cmp_ge+0x56>
8000b10a:	1b 07       	ld.w	r7,sp++
8000b10c:	1b 0e       	ld.w	lr,sp++
8000b10e:	58 3c       	cp.w	r12,3
8000b110:	c0 a0       	breq	8000b124 <__avr32_f64_cmp_ge+0x48>
8000b112:	58 1c       	cp.w	r12,1
8000b114:	c0 33       	brcs	8000b11a <__avr32_f64_cmp_ge+0x3e>
8000b116:	5e 0f       	reteq	1
8000b118:	5e 1d       	retne	0
8000b11a:	10 3a       	cp.w	r10,r8
8000b11c:	f2 0b 13 00 	cpc	r11,r9
8000b120:	5e 2f       	reths	1
8000b122:	5e 3d       	retlo	0
8000b124:	14 38       	cp.w	r8,r10
8000b126:	f6 09 13 00 	cpc	r9,r11
8000b12a:	5e 2f       	reths	1
8000b12c:	5e 3d       	retlo	0
8000b12e:	1b 07       	ld.w	r7,sp++
8000b130:	d8 0a       	popm	pc,r12=0
8000b132:	58 17       	cp.w	r7,1
8000b134:	5f 0c       	sreq	r12
8000b136:	58 09       	cp.w	r9,0
8000b138:	f5 b8 00 00 	subfeq	r8,0
8000b13c:	1b 07       	ld.w	r7,sp++
8000b13e:	1b 0e       	ld.w	lr,sp++
8000b140:	5e 0f       	reteq	1
8000b142:	5e fc       	retal	r12

8000b144 <__avr32_f64_cmp_lt>:
8000b144:	1a de       	st.w	--sp,lr
8000b146:	1a d7       	st.w	--sp,r7
8000b148:	a1 7b       	lsl	r11,0x1
8000b14a:	5f 3c       	srlo	r12
8000b14c:	a1 79       	lsl	r9,0x1
8000b14e:	5f 37       	srlo	r7
8000b150:	5c fc       	rol	r12
8000b152:	fc 1e ff e0 	movh	lr,0xffe0
8000b156:	58 0a       	cp.w	r10,0
8000b158:	fc 0b 13 00 	cpc	r11,lr
8000b15c:	e0 8b 00 1d 	brhi	8000b196 <__avr32_f64_cmp_lt+0x52>
8000b160:	58 08       	cp.w	r8,0
8000b162:	fc 09 13 00 	cpc	r9,lr
8000b166:	e0 8b 00 18 	brhi	8000b196 <__avr32_f64_cmp_lt+0x52>
8000b16a:	58 0b       	cp.w	r11,0
8000b16c:	f5 ba 00 00 	subfeq	r10,0
8000b170:	c1 50       	breq	8000b19a <__avr32_f64_cmp_lt+0x56>
8000b172:	1b 07       	ld.w	r7,sp++
8000b174:	1b 0e       	ld.w	lr,sp++
8000b176:	58 3c       	cp.w	r12,3
8000b178:	c0 a0       	breq	8000b18c <__avr32_f64_cmp_lt+0x48>
8000b17a:	58 1c       	cp.w	r12,1
8000b17c:	c0 33       	brcs	8000b182 <__avr32_f64_cmp_lt+0x3e>
8000b17e:	5e 0d       	reteq	0
8000b180:	5e 1f       	retne	1
8000b182:	10 3a       	cp.w	r10,r8
8000b184:	f2 0b 13 00 	cpc	r11,r9
8000b188:	5e 2d       	reths	0
8000b18a:	5e 3f       	retlo	1
8000b18c:	14 38       	cp.w	r8,r10
8000b18e:	f6 09 13 00 	cpc	r9,r11
8000b192:	5e 2d       	reths	0
8000b194:	5e 3f       	retlo	1
8000b196:	1b 07       	ld.w	r7,sp++
8000b198:	d8 0a       	popm	pc,r12=0
8000b19a:	58 17       	cp.w	r7,1
8000b19c:	5f 1c       	srne	r12
8000b19e:	58 09       	cp.w	r9,0
8000b1a0:	f5 b8 00 00 	subfeq	r8,0
8000b1a4:	1b 07       	ld.w	r7,sp++
8000b1a6:	1b 0e       	ld.w	lr,sp++
8000b1a8:	5e 0d       	reteq	0
8000b1aa:	5e fc       	retal	r12

8000b1ac <__avr32_f64_div>:
8000b1ac:	eb cd 40 ff 	pushm	r0-r7,lr
8000b1b0:	f7 e9 20 0e 	eor	lr,r11,r9
8000b1b4:	f6 07 16 14 	lsr	r7,r11,0x14
8000b1b8:	a9 7b       	lsl	r11,0x9
8000b1ba:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b1be:	a9 7a       	lsl	r10,0x9
8000b1c0:	bd bb       	sbr	r11,0x1d
8000b1c2:	e4 1b 3f ff 	andh	r11,0x3fff
8000b1c6:	ab d7       	cbr	r7,0xb
8000b1c8:	e0 80 00 cc 	breq	8000b360 <__avr32_f64_div_round_subnormal+0x54>
8000b1cc:	e0 47 07 ff 	cp.w	r7,2047
8000b1d0:	e0 84 00 b5 	brge	8000b33a <__avr32_f64_div_round_subnormal+0x2e>
8000b1d4:	f2 06 16 14 	lsr	r6,r9,0x14
8000b1d8:	a9 79       	lsl	r9,0x9
8000b1da:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b1de:	a9 78       	lsl	r8,0x9
8000b1e0:	bd b9       	sbr	r9,0x1d
8000b1e2:	e4 19 3f ff 	andh	r9,0x3fff
8000b1e6:	ab d6       	cbr	r6,0xb
8000b1e8:	e0 80 00 e2 	breq	8000b3ac <__avr32_f64_div_round_subnormal+0xa0>
8000b1ec:	e0 46 07 ff 	cp.w	r6,2047
8000b1f0:	e0 84 00 b2 	brge	8000b354 <__avr32_f64_div_round_subnormal+0x48>
8000b1f4:	0c 17       	sub	r7,r6
8000b1f6:	fe 37 fc 01 	sub	r7,-1023
8000b1fa:	fc 1c 80 00 	movh	r12,0x8000
8000b1fe:	f8 03 16 01 	lsr	r3,r12,0x1
8000b202:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b206:	5c d4       	com	r4
8000b208:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b20c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b210:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b214:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b218:	ea 03 15 02 	lsl	r3,r5,0x2
8000b21c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b220:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b224:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b228:	ea 03 15 02 	lsl	r3,r5,0x2
8000b22c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b230:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b234:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b238:	ea 03 15 02 	lsl	r3,r5,0x2
8000b23c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b240:	e4 09 07 40 	macu.d	r0,r2,r9
8000b244:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b248:	02 04       	add	r4,r1
8000b24a:	5c 05       	acr	r5
8000b24c:	a3 65       	lsl	r5,0x2
8000b24e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b252:	a3 64       	lsl	r4,0x2
8000b254:	5c 34       	neg	r4
8000b256:	f8 05 01 45 	sbc	r5,r12,r5
8000b25a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b25e:	e4 05 07 40 	macu.d	r0,r2,r5
8000b262:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b266:	02 04       	add	r4,r1
8000b268:	5c 05       	acr	r5
8000b26a:	ea 03 15 02 	lsl	r3,r5,0x2
8000b26e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b272:	e8 02 15 02 	lsl	r2,r4,0x2
8000b276:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b27a:	e4 09 07 40 	macu.d	r0,r2,r9
8000b27e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b282:	02 04       	add	r4,r1
8000b284:	5c 05       	acr	r5
8000b286:	a3 65       	lsl	r5,0x2
8000b288:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b28c:	a3 64       	lsl	r4,0x2
8000b28e:	5c 34       	neg	r4
8000b290:	f8 05 01 45 	sbc	r5,r12,r5
8000b294:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b298:	e4 05 07 40 	macu.d	r0,r2,r5
8000b29c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b2a0:	02 04       	add	r4,r1
8000b2a2:	5c 05       	acr	r5
8000b2a4:	ea 03 15 02 	lsl	r3,r5,0x2
8000b2a8:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b2ac:	e8 02 15 02 	lsl	r2,r4,0x2
8000b2b0:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b2b4:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b2b8:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b2bc:	02 02       	add	r2,r1
8000b2be:	5c 03       	acr	r3
8000b2c0:	ed b3 00 1c 	bld	r3,0x1c
8000b2c4:	c0 90       	breq	8000b2d6 <__avr32_f64_div+0x12a>
8000b2c6:	a1 72       	lsl	r2,0x1
8000b2c8:	5c f3       	rol	r3
8000b2ca:	20 17       	sub	r7,1
8000b2cc:	a3 9a       	lsr	r10,0x3
8000b2ce:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b2d2:	a3 9b       	lsr	r11,0x3
8000b2d4:	c0 58       	rjmp	8000b2de <__avr32_f64_div+0x132>
8000b2d6:	a5 8a       	lsr	r10,0x4
8000b2d8:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b2dc:	a5 8b       	lsr	r11,0x4
8000b2de:	58 07       	cp.w	r7,0
8000b2e0:	e0 8a 00 8b 	brle	8000b3f6 <__avr32_f64_div_res_subnormal>
8000b2e4:	e0 12 ff 00 	andl	r2,0xff00
8000b2e8:	e8 12 00 80 	orl	r2,0x80
8000b2ec:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b2f0:	e4 09 07 40 	macu.d	r0,r2,r9
8000b2f4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b2f8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b2fc:	00 05       	add	r5,r0
8000b2fe:	f0 01 00 48 	adc	r8,r8,r1
8000b302:	5c 09       	acr	r9
8000b304:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b308:	58 04       	cp.w	r4,0
8000b30a:	5c 25       	cpc	r5

8000b30c <__avr32_f64_div_round_subnormal>:
8000b30c:	f4 08 13 00 	cpc	r8,r10
8000b310:	f6 09 13 00 	cpc	r9,r11
8000b314:	5f 36       	srlo	r6
8000b316:	f8 06 17 00 	moveq	r6,r12
8000b31a:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b31e:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b322:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b326:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b32a:	ed be 00 1f 	bld	lr,0x1f
8000b32e:	ef bb 00 1f 	bst	r11,0x1f
8000b332:	0c 0a       	add	r10,r6
8000b334:	5c 0b       	acr	r11
8000b336:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b33a:	e4 1b 00 0f 	andh	r11,0xf
8000b33e:	14 4b       	or	r11,r10
8000b340:	e0 81 00 a7 	brne	8000b48e <__avr32_f64_div_res_subnormal+0x98>
8000b344:	f2 06 16 14 	lsr	r6,r9,0x14
8000b348:	ab d6       	cbr	r6,0xb
8000b34a:	e0 46 07 ff 	cp.w	r6,2047
8000b34e:	e0 81 00 a4 	brne	8000b496 <__avr32_f64_div_res_subnormal+0xa0>
8000b352:	c9 e8       	rjmp	8000b48e <__avr32_f64_div_res_subnormal+0x98>
8000b354:	e4 19 00 0f 	andh	r9,0xf
8000b358:	10 49       	or	r9,r8
8000b35a:	e0 81 00 9a 	brne	8000b48e <__avr32_f64_div_res_subnormal+0x98>
8000b35e:	c9 28       	rjmp	8000b482 <__avr32_f64_div_res_subnormal+0x8c>
8000b360:	a3 7b       	lsl	r11,0x3
8000b362:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b366:	a3 7a       	lsl	r10,0x3
8000b368:	f5 eb 10 04 	or	r4,r10,r11
8000b36c:	e0 80 00 a0 	breq	8000b4ac <__avr32_f64_div_op1_zero>
8000b370:	f6 04 12 00 	clz	r4,r11
8000b374:	c1 70       	breq	8000b3a2 <__avr32_f64_div_round_subnormal+0x96>
8000b376:	c0 c3       	brcs	8000b38e <__avr32_f64_div_round_subnormal+0x82>
8000b378:	e8 05 11 20 	rsub	r5,r4,32
8000b37c:	f6 04 09 4b 	lsl	r11,r11,r4
8000b380:	f4 05 0a 45 	lsr	r5,r10,r5
8000b384:	0a 4b       	or	r11,r5
8000b386:	f4 04 09 4a 	lsl	r10,r10,r4
8000b38a:	08 17       	sub	r7,r4
8000b38c:	c0 b8       	rjmp	8000b3a2 <__avr32_f64_div_round_subnormal+0x96>
8000b38e:	f4 04 12 00 	clz	r4,r10
8000b392:	f9 b4 03 00 	movlo	r4,0
8000b396:	f7 b4 02 e0 	subhs	r4,-32
8000b39a:	f4 04 09 4b 	lsl	r11,r10,r4
8000b39e:	30 0a       	mov	r10,0
8000b3a0:	08 17       	sub	r7,r4
8000b3a2:	a3 8a       	lsr	r10,0x2
8000b3a4:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b3a8:	a3 8b       	lsr	r11,0x2
8000b3aa:	c1 1b       	rjmp	8000b1cc <__avr32_f64_div+0x20>
8000b3ac:	a3 79       	lsl	r9,0x3
8000b3ae:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b3b2:	a3 78       	lsl	r8,0x3
8000b3b4:	f3 e8 10 04 	or	r4,r9,r8
8000b3b8:	c6 f0       	breq	8000b496 <__avr32_f64_div_res_subnormal+0xa0>
8000b3ba:	f2 04 12 00 	clz	r4,r9
8000b3be:	c1 70       	breq	8000b3ec <__avr32_f64_div_round_subnormal+0xe0>
8000b3c0:	c0 c3       	brcs	8000b3d8 <__avr32_f64_div_round_subnormal+0xcc>
8000b3c2:	e8 05 11 20 	rsub	r5,r4,32
8000b3c6:	f2 04 09 49 	lsl	r9,r9,r4
8000b3ca:	f0 05 0a 45 	lsr	r5,r8,r5
8000b3ce:	0a 49       	or	r9,r5
8000b3d0:	f0 04 09 48 	lsl	r8,r8,r4
8000b3d4:	08 16       	sub	r6,r4
8000b3d6:	c0 b8       	rjmp	8000b3ec <__avr32_f64_div_round_subnormal+0xe0>
8000b3d8:	f0 04 12 00 	clz	r4,r8
8000b3dc:	f9 b4 03 00 	movlo	r4,0
8000b3e0:	f7 b4 02 e0 	subhs	r4,-32
8000b3e4:	f0 04 09 49 	lsl	r9,r8,r4
8000b3e8:	30 08       	mov	r8,0
8000b3ea:	08 16       	sub	r6,r4
8000b3ec:	a3 88       	lsr	r8,0x2
8000b3ee:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b3f2:	a3 89       	lsr	r9,0x2
8000b3f4:	cf ca       	rjmp	8000b1ec <__avr32_f64_div+0x40>

8000b3f6 <__avr32_f64_div_res_subnormal>:
8000b3f6:	5c 37       	neg	r7
8000b3f8:	2f f7       	sub	r7,-1
8000b3fa:	f1 b7 04 c0 	satu	r7,0x6
8000b3fe:	e0 47 00 20 	cp.w	r7,32
8000b402:	c1 54       	brge	8000b42c <__avr32_f64_div_res_subnormal+0x36>
8000b404:	ee 06 11 20 	rsub	r6,r7,32
8000b408:	e4 07 0a 42 	lsr	r2,r2,r7
8000b40c:	e6 06 09 4c 	lsl	r12,r3,r6
8000b410:	18 42       	or	r2,r12
8000b412:	e6 07 0a 43 	lsr	r3,r3,r7
8000b416:	f4 06 09 41 	lsl	r1,r10,r6
8000b41a:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b41e:	f6 06 09 4c 	lsl	r12,r11,r6
8000b422:	18 4a       	or	r10,r12
8000b424:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b428:	30 00       	mov	r0,0
8000b42a:	c1 58       	rjmp	8000b454 <__avr32_f64_div_res_subnormal+0x5e>
8000b42c:	ee 06 11 20 	rsub	r6,r7,32
8000b430:	f9 b0 00 00 	moveq	r0,0
8000b434:	f9 bc 00 00 	moveq	r12,0
8000b438:	c0 50       	breq	8000b442 <__avr32_f64_div_res_subnormal+0x4c>
8000b43a:	f4 06 09 40 	lsl	r0,r10,r6
8000b43e:	f6 06 09 4c 	lsl	r12,r11,r6
8000b442:	e6 07 0a 42 	lsr	r2,r3,r7
8000b446:	30 03       	mov	r3,0
8000b448:	f4 07 0a 41 	lsr	r1,r10,r7
8000b44c:	18 41       	or	r1,r12
8000b44e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b452:	30 0b       	mov	r11,0
8000b454:	e0 12 ff 00 	andl	r2,0xff00
8000b458:	e8 12 00 80 	orl	r2,0x80
8000b45c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b460:	e4 09 07 46 	macu.d	r6,r2,r9
8000b464:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b468:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b46c:	0c 05       	add	r5,r6
8000b46e:	f0 07 00 48 	adc	r8,r8,r7
8000b472:	5c 09       	acr	r9
8000b474:	30 07       	mov	r7,0
8000b476:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b47a:	00 34       	cp.w	r4,r0
8000b47c:	e2 05 13 00 	cpc	r5,r1
8000b480:	c4 6b       	rjmp	8000b30c <__avr32_f64_div_round_subnormal>
8000b482:	1c 9b       	mov	r11,lr
8000b484:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b488:	30 0a       	mov	r10,0
8000b48a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b48e:	3f fb       	mov	r11,-1
8000b490:	30 0a       	mov	r10,0
8000b492:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b496:	f5 eb 10 04 	or	r4,r10,r11
8000b49a:	c0 90       	breq	8000b4ac <__avr32_f64_div_op1_zero>
8000b49c:	1c 9b       	mov	r11,lr
8000b49e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b4a2:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b4a6:	30 0a       	mov	r10,0
8000b4a8:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b4ac <__avr32_f64_div_op1_zero>:
8000b4ac:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b4b0:	ce f0       	breq	8000b48e <__avr32_f64_div_res_subnormal+0x98>
8000b4b2:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b4b6:	e0 44 07 ff 	cp.w	r4,2047
8000b4ba:	ce 41       	brne	8000b482 <__avr32_f64_div_res_subnormal+0x8c>
8000b4bc:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b4c0:	ce 10       	breq	8000b482 <__avr32_f64_div_res_subnormal+0x8c>
8000b4c2:	ce 6b       	rjmp	8000b48e <__avr32_f64_div_res_subnormal+0x98>

8000b4c4 <__avr32_udiv64>:
8000b4c4:	d4 31       	pushm	r0-r7,lr
8000b4c6:	1a 97       	mov	r7,sp
8000b4c8:	20 3d       	sub	sp,12
8000b4ca:	10 9c       	mov	r12,r8
8000b4cc:	12 9e       	mov	lr,r9
8000b4ce:	14 93       	mov	r3,r10
8000b4d0:	58 09       	cp.w	r9,0
8000b4d2:	e0 81 00 bd 	brne	8000b64c <__avr32_udiv64+0x188>
8000b4d6:	16 38       	cp.w	r8,r11
8000b4d8:	e0 88 00 40 	brls	8000b558 <__avr32_udiv64+0x94>
8000b4dc:	f0 08 12 00 	clz	r8,r8
8000b4e0:	c0 d0       	breq	8000b4fa <__avr32_udiv64+0x36>
8000b4e2:	f6 08 09 4b 	lsl	r11,r11,r8
8000b4e6:	f0 09 11 20 	rsub	r9,r8,32
8000b4ea:	f8 08 09 4c 	lsl	r12,r12,r8
8000b4ee:	f4 09 0a 49 	lsr	r9,r10,r9
8000b4f2:	f4 08 09 43 	lsl	r3,r10,r8
8000b4f6:	f3 eb 10 0b 	or	r11,r9,r11
8000b4fa:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b4fe:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b502:	f6 0e 0d 00 	divu	r0,r11,lr
8000b506:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b50a:	00 99       	mov	r9,r0
8000b50c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b510:	e0 0a 02 48 	mul	r8,r0,r10
8000b514:	10 3b       	cp.w	r11,r8
8000b516:	c0 a2       	brcc	8000b52a <__avr32_udiv64+0x66>
8000b518:	20 19       	sub	r9,1
8000b51a:	18 0b       	add	r11,r12
8000b51c:	18 3b       	cp.w	r11,r12
8000b51e:	c0 63       	brcs	8000b52a <__avr32_udiv64+0x66>
8000b520:	10 3b       	cp.w	r11,r8
8000b522:	f7 b9 03 01 	sublo	r9,1
8000b526:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b52a:	f6 08 01 01 	sub	r1,r11,r8
8000b52e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b532:	e2 0e 0d 00 	divu	r0,r1,lr
8000b536:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b53a:	00 98       	mov	r8,r0
8000b53c:	e0 0a 02 4a 	mul	r10,r0,r10
8000b540:	14 33       	cp.w	r3,r10
8000b542:	c0 82       	brcc	8000b552 <__avr32_udiv64+0x8e>
8000b544:	20 18       	sub	r8,1
8000b546:	18 03       	add	r3,r12
8000b548:	18 33       	cp.w	r3,r12
8000b54a:	c0 43       	brcs	8000b552 <__avr32_udiv64+0x8e>
8000b54c:	14 33       	cp.w	r3,r10
8000b54e:	f7 b8 03 01 	sublo	r8,1
8000b552:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b556:	cd f8       	rjmp	8000b714 <__avr32_udiv64+0x250>
8000b558:	58 08       	cp.w	r8,0
8000b55a:	c0 51       	brne	8000b564 <__avr32_udiv64+0xa0>
8000b55c:	30 19       	mov	r9,1
8000b55e:	f2 08 0d 08 	divu	r8,r9,r8
8000b562:	10 9c       	mov	r12,r8
8000b564:	f8 06 12 00 	clz	r6,r12
8000b568:	c0 41       	brne	8000b570 <__avr32_udiv64+0xac>
8000b56a:	18 1b       	sub	r11,r12
8000b56c:	30 19       	mov	r9,1
8000b56e:	c4 08       	rjmp	8000b5ee <__avr32_udiv64+0x12a>
8000b570:	ec 01 11 20 	rsub	r1,r6,32
8000b574:	f4 01 0a 49 	lsr	r9,r10,r1
8000b578:	f8 06 09 4c 	lsl	r12,r12,r6
8000b57c:	f6 06 09 48 	lsl	r8,r11,r6
8000b580:	f6 01 0a 41 	lsr	r1,r11,r1
8000b584:	f3 e8 10 08 	or	r8,r9,r8
8000b588:	f8 03 16 10 	lsr	r3,r12,0x10
8000b58c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b590:	e2 03 0d 00 	divu	r0,r1,r3
8000b594:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b598:	00 9e       	mov	lr,r0
8000b59a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b59e:	e0 05 02 49 	mul	r9,r0,r5
8000b5a2:	12 3b       	cp.w	r11,r9
8000b5a4:	c0 a2       	brcc	8000b5b8 <__avr32_udiv64+0xf4>
8000b5a6:	20 1e       	sub	lr,1
8000b5a8:	18 0b       	add	r11,r12
8000b5aa:	18 3b       	cp.w	r11,r12
8000b5ac:	c0 63       	brcs	8000b5b8 <__avr32_udiv64+0xf4>
8000b5ae:	12 3b       	cp.w	r11,r9
8000b5b0:	f7 be 03 01 	sublo	lr,1
8000b5b4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b5b8:	12 1b       	sub	r11,r9
8000b5ba:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000b5be:	f6 03 0d 02 	divu	r2,r11,r3
8000b5c2:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000b5c6:	04 99       	mov	r9,r2
8000b5c8:	e4 05 02 4b 	mul	r11,r2,r5
8000b5cc:	16 38       	cp.w	r8,r11
8000b5ce:	c0 a2       	brcc	8000b5e2 <__avr32_udiv64+0x11e>
8000b5d0:	20 19       	sub	r9,1
8000b5d2:	18 08       	add	r8,r12
8000b5d4:	18 38       	cp.w	r8,r12
8000b5d6:	c0 63       	brcs	8000b5e2 <__avr32_udiv64+0x11e>
8000b5d8:	16 38       	cp.w	r8,r11
8000b5da:	f7 b9 03 01 	sublo	r9,1
8000b5de:	f1 dc e3 08 	addcs	r8,r8,r12
8000b5e2:	f4 06 09 43 	lsl	r3,r10,r6
8000b5e6:	f0 0b 01 0b 	sub	r11,r8,r11
8000b5ea:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000b5ee:	f8 06 16 10 	lsr	r6,r12,0x10
8000b5f2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000b5f6:	f6 06 0d 00 	divu	r0,r11,r6
8000b5fa:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b5fe:	00 9a       	mov	r10,r0
8000b600:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b604:	e0 0e 02 48 	mul	r8,r0,lr
8000b608:	10 3b       	cp.w	r11,r8
8000b60a:	c0 a2       	brcc	8000b61e <__avr32_udiv64+0x15a>
8000b60c:	20 1a       	sub	r10,1
8000b60e:	18 0b       	add	r11,r12
8000b610:	18 3b       	cp.w	r11,r12
8000b612:	c0 63       	brcs	8000b61e <__avr32_udiv64+0x15a>
8000b614:	10 3b       	cp.w	r11,r8
8000b616:	f7 ba 03 01 	sublo	r10,1
8000b61a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b61e:	f6 08 01 01 	sub	r1,r11,r8
8000b622:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b626:	e2 06 0d 00 	divu	r0,r1,r6
8000b62a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b62e:	00 98       	mov	r8,r0
8000b630:	e0 0e 02 4b 	mul	r11,r0,lr
8000b634:	16 33       	cp.w	r3,r11
8000b636:	c0 82       	brcc	8000b646 <__avr32_udiv64+0x182>
8000b638:	20 18       	sub	r8,1
8000b63a:	18 03       	add	r3,r12
8000b63c:	18 33       	cp.w	r3,r12
8000b63e:	c0 43       	brcs	8000b646 <__avr32_udiv64+0x182>
8000b640:	16 33       	cp.w	r3,r11
8000b642:	f7 b8 03 01 	sublo	r8,1
8000b646:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000b64a:	c6 98       	rjmp	8000b71c <__avr32_udiv64+0x258>
8000b64c:	16 39       	cp.w	r9,r11
8000b64e:	e0 8b 00 65 	brhi	8000b718 <__avr32_udiv64+0x254>
8000b652:	f2 09 12 00 	clz	r9,r9
8000b656:	c0 b1       	brne	8000b66c <__avr32_udiv64+0x1a8>
8000b658:	10 3a       	cp.w	r10,r8
8000b65a:	5f 2a       	srhs	r10
8000b65c:	1c 3b       	cp.w	r11,lr
8000b65e:	5f b8       	srhi	r8
8000b660:	10 4a       	or	r10,r8
8000b662:	f2 0a 18 00 	cp.b	r10,r9
8000b666:	c5 90       	breq	8000b718 <__avr32_udiv64+0x254>
8000b668:	30 18       	mov	r8,1
8000b66a:	c5 98       	rjmp	8000b71c <__avr32_udiv64+0x258>
8000b66c:	f0 09 09 46 	lsl	r6,r8,r9
8000b670:	f2 03 11 20 	rsub	r3,r9,32
8000b674:	fc 09 09 4e 	lsl	lr,lr,r9
8000b678:	f0 03 0a 48 	lsr	r8,r8,r3
8000b67c:	f6 09 09 4c 	lsl	r12,r11,r9
8000b680:	f4 03 0a 42 	lsr	r2,r10,r3
8000b684:	ef 46 ff f4 	st.w	r7[-12],r6
8000b688:	f6 03 0a 43 	lsr	r3,r11,r3
8000b68c:	18 42       	or	r2,r12
8000b68e:	f1 ee 10 0c 	or	r12,r8,lr
8000b692:	f8 01 16 10 	lsr	r1,r12,0x10
8000b696:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b69a:	e6 01 0d 04 	divu	r4,r3,r1
8000b69e:	e4 03 16 10 	lsr	r3,r2,0x10
8000b6a2:	08 9e       	mov	lr,r4
8000b6a4:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000b6a8:	e8 06 02 48 	mul	r8,r4,r6
8000b6ac:	10 33       	cp.w	r3,r8
8000b6ae:	c0 a2       	brcc	8000b6c2 <__avr32_udiv64+0x1fe>
8000b6b0:	20 1e       	sub	lr,1
8000b6b2:	18 03       	add	r3,r12
8000b6b4:	18 33       	cp.w	r3,r12
8000b6b6:	c0 63       	brcs	8000b6c2 <__avr32_udiv64+0x1fe>
8000b6b8:	10 33       	cp.w	r3,r8
8000b6ba:	f7 be 03 01 	sublo	lr,1
8000b6be:	e7 dc e3 03 	addcs	r3,r3,r12
8000b6c2:	10 13       	sub	r3,r8
8000b6c4:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000b6c8:	e6 01 0d 00 	divu	r0,r3,r1
8000b6cc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b6d0:	00 98       	mov	r8,r0
8000b6d2:	e0 06 02 46 	mul	r6,r0,r6
8000b6d6:	0c 3b       	cp.w	r11,r6
8000b6d8:	c0 a2       	brcc	8000b6ec <__avr32_udiv64+0x228>
8000b6da:	20 18       	sub	r8,1
8000b6dc:	18 0b       	add	r11,r12
8000b6de:	18 3b       	cp.w	r11,r12
8000b6e0:	c0 63       	brcs	8000b6ec <__avr32_udiv64+0x228>
8000b6e2:	0c 3b       	cp.w	r11,r6
8000b6e4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b6e8:	f7 b8 03 01 	sublo	r8,1
8000b6ec:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000b6f0:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000b6f4:	0c 1b       	sub	r11,r6
8000b6f6:	f0 04 06 42 	mulu.d	r2,r8,r4
8000b6fa:	06 95       	mov	r5,r3
8000b6fc:	16 35       	cp.w	r5,r11
8000b6fe:	e0 8b 00 0a 	brhi	8000b712 <__avr32_udiv64+0x24e>
8000b702:	5f 0b       	sreq	r11
8000b704:	f4 09 09 49 	lsl	r9,r10,r9
8000b708:	12 32       	cp.w	r2,r9
8000b70a:	5f b9       	srhi	r9
8000b70c:	f7 e9 00 09 	and	r9,r11,r9
8000b710:	c0 60       	breq	8000b71c <__avr32_udiv64+0x258>
8000b712:	20 18       	sub	r8,1
8000b714:	30 09       	mov	r9,0
8000b716:	c0 38       	rjmp	8000b71c <__avr32_udiv64+0x258>
8000b718:	30 09       	mov	r9,0
8000b71a:	12 98       	mov	r8,r9
8000b71c:	10 9a       	mov	r10,r8
8000b71e:	12 93       	mov	r3,r9
8000b720:	10 92       	mov	r2,r8
8000b722:	12 9b       	mov	r11,r9
8000b724:	2f dd       	sub	sp,-12
8000b726:	d8 32       	popm	r0-r7,pc

8000b728 <__avr32_umod64>:
8000b728:	d4 31       	pushm	r0-r7,lr
8000b72a:	1a 97       	mov	r7,sp
8000b72c:	20 3d       	sub	sp,12
8000b72e:	10 9c       	mov	r12,r8
8000b730:	12 95       	mov	r5,r9
8000b732:	14 9e       	mov	lr,r10
8000b734:	16 91       	mov	r1,r11
8000b736:	16 96       	mov	r6,r11
8000b738:	58 09       	cp.w	r9,0
8000b73a:	e0 81 00 81 	brne	8000b83c <__avr32_umod64+0x114>
8000b73e:	16 38       	cp.w	r8,r11
8000b740:	e0 88 00 12 	brls	8000b764 <__avr32_umod64+0x3c>
8000b744:	f0 08 12 00 	clz	r8,r8
8000b748:	c4 e0       	breq	8000b7e4 <__avr32_umod64+0xbc>
8000b74a:	f6 08 09 46 	lsl	r6,r11,r8
8000b74e:	f8 08 09 4c 	lsl	r12,r12,r8
8000b752:	f0 0b 11 20 	rsub	r11,r8,32
8000b756:	f4 08 09 4e 	lsl	lr,r10,r8
8000b75a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000b75e:	f7 e6 10 06 	or	r6,r11,r6
8000b762:	c4 18       	rjmp	8000b7e4 <__avr32_umod64+0xbc>
8000b764:	58 08       	cp.w	r8,0
8000b766:	c0 51       	brne	8000b770 <__avr32_umod64+0x48>
8000b768:	30 19       	mov	r9,1
8000b76a:	f2 08 0d 08 	divu	r8,r9,r8
8000b76e:	10 9c       	mov	r12,r8
8000b770:	f8 08 12 00 	clz	r8,r12
8000b774:	c0 31       	brne	8000b77a <__avr32_umod64+0x52>
8000b776:	18 16       	sub	r6,r12
8000b778:	c3 68       	rjmp	8000b7e4 <__avr32_umod64+0xbc>
8000b77a:	f0 03 11 20 	rsub	r3,r8,32
8000b77e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000b782:	f8 08 09 4c 	lsl	r12,r12,r8
8000b786:	ec 08 09 49 	lsl	r9,r6,r8
8000b78a:	ec 03 0a 43 	lsr	r3,r6,r3
8000b78e:	f7 e9 10 09 	or	r9,r11,r9
8000b792:	f8 05 16 10 	lsr	r5,r12,0x10
8000b796:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b79a:	e6 05 0d 02 	divu	r2,r3,r5
8000b79e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000b7a2:	ec 02 02 4b 	mul	r11,r6,r2
8000b7a6:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000b7aa:	16 3e       	cp.w	lr,r11
8000b7ac:	c0 72       	brcc	8000b7ba <__avr32_umod64+0x92>
8000b7ae:	18 0e       	add	lr,r12
8000b7b0:	18 3e       	cp.w	lr,r12
8000b7b2:	c0 43       	brcs	8000b7ba <__avr32_umod64+0x92>
8000b7b4:	16 3e       	cp.w	lr,r11
8000b7b6:	fd dc e3 0e 	addcs	lr,lr,r12
8000b7ba:	fc 0b 01 03 	sub	r3,lr,r11
8000b7be:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000b7c2:	e6 05 0d 02 	divu	r2,r3,r5
8000b7c6:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b7ca:	a5 36       	mul	r6,r2
8000b7cc:	0c 39       	cp.w	r9,r6
8000b7ce:	c0 72       	brcc	8000b7dc <__avr32_umod64+0xb4>
8000b7d0:	18 09       	add	r9,r12
8000b7d2:	18 39       	cp.w	r9,r12
8000b7d4:	c0 43       	brcs	8000b7dc <__avr32_umod64+0xb4>
8000b7d6:	0c 39       	cp.w	r9,r6
8000b7d8:	f3 dc e3 09 	addcs	r9,r9,r12
8000b7dc:	f2 06 01 06 	sub	r6,r9,r6
8000b7e0:	f4 08 09 4e 	lsl	lr,r10,r8
8000b7e4:	f8 0a 16 10 	lsr	r10,r12,0x10
8000b7e8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b7ec:	ec 0a 0d 02 	divu	r2,r6,r10
8000b7f0:	fc 09 16 10 	lsr	r9,lr,0x10
8000b7f4:	ea 02 02 4b 	mul	r11,r5,r2
8000b7f8:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b7fc:	16 39       	cp.w	r9,r11
8000b7fe:	c0 72       	brcc	8000b80c <__avr32_umod64+0xe4>
8000b800:	18 09       	add	r9,r12
8000b802:	18 39       	cp.w	r9,r12
8000b804:	c0 43       	brcs	8000b80c <__avr32_umod64+0xe4>
8000b806:	16 39       	cp.w	r9,r11
8000b808:	f3 dc e3 09 	addcs	r9,r9,r12
8000b80c:	f2 0b 01 0b 	sub	r11,r9,r11
8000b810:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b814:	f6 0a 0d 0a 	divu	r10,r11,r10
8000b818:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000b81c:	ea 0a 02 4a 	mul	r10,r5,r10
8000b820:	14 3e       	cp.w	lr,r10
8000b822:	c0 72       	brcc	8000b830 <__avr32_umod64+0x108>
8000b824:	18 0e       	add	lr,r12
8000b826:	18 3e       	cp.w	lr,r12
8000b828:	c0 43       	brcs	8000b830 <__avr32_umod64+0x108>
8000b82a:	14 3e       	cp.w	lr,r10
8000b82c:	fd dc e3 0e 	addcs	lr,lr,r12
8000b830:	fc 0a 01 0a 	sub	r10,lr,r10
8000b834:	30 0b       	mov	r11,0
8000b836:	f4 08 0a 4a 	lsr	r10,r10,r8
8000b83a:	c7 b8       	rjmp	8000b930 <__avr32_umod64+0x208>
8000b83c:	16 39       	cp.w	r9,r11
8000b83e:	e0 8b 00 79 	brhi	8000b930 <__avr32_umod64+0x208>
8000b842:	f2 09 12 00 	clz	r9,r9
8000b846:	c1 21       	brne	8000b86a <__avr32_umod64+0x142>
8000b848:	10 3a       	cp.w	r10,r8
8000b84a:	5f 2b       	srhs	r11
8000b84c:	0a 31       	cp.w	r1,r5
8000b84e:	5f ba       	srhi	r10
8000b850:	f7 ea 10 0a 	or	r10,r11,r10
8000b854:	f2 0a 18 00 	cp.b	r10,r9
8000b858:	c0 60       	breq	8000b864 <__avr32_umod64+0x13c>
8000b85a:	fc 08 01 0c 	sub	r12,lr,r8
8000b85e:	e2 05 01 46 	sbc	r6,r1,r5
8000b862:	18 9e       	mov	lr,r12
8000b864:	0c 9b       	mov	r11,r6
8000b866:	1c 9a       	mov	r10,lr
8000b868:	c6 48       	rjmp	8000b930 <__avr32_umod64+0x208>
8000b86a:	ea 09 09 4c 	lsl	r12,r5,r9
8000b86e:	f2 06 11 20 	rsub	r6,r9,32
8000b872:	f6 09 09 4b 	lsl	r11,r11,r9
8000b876:	f0 09 09 42 	lsl	r2,r8,r9
8000b87a:	ef 46 ff f4 	st.w	r7[-12],r6
8000b87e:	f0 06 0a 48 	lsr	r8,r8,r6
8000b882:	18 48       	or	r8,r12
8000b884:	e2 06 0a 4c 	lsr	r12,r1,r6
8000b888:	f4 09 09 43 	lsl	r3,r10,r9
8000b88c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000b890:	f4 06 0a 4a 	lsr	r10,r10,r6
8000b894:	16 4a       	or	r10,r11
8000b896:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b89a:	f8 0b 0d 04 	divu	r4,r12,r11
8000b89e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000b8a2:	08 91       	mov	r1,r4
8000b8a4:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000b8a8:	e8 0e 02 46 	mul	r6,r4,lr
8000b8ac:	0c 3c       	cp.w	r12,r6
8000b8ae:	c0 a2       	brcc	8000b8c2 <__avr32_umod64+0x19a>
8000b8b0:	20 11       	sub	r1,1
8000b8b2:	10 0c       	add	r12,r8
8000b8b4:	10 3c       	cp.w	r12,r8
8000b8b6:	c0 63       	brcs	8000b8c2 <__avr32_umod64+0x19a>
8000b8b8:	0c 3c       	cp.w	r12,r6
8000b8ba:	f7 b1 03 01 	sublo	r1,1
8000b8be:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000b8c2:	0c 1c       	sub	r12,r6
8000b8c4:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000b8c8:	f8 0b 0d 04 	divu	r4,r12,r11
8000b8cc:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000b8d0:	08 96       	mov	r6,r4
8000b8d2:	e8 0e 02 4e 	mul	lr,r4,lr
8000b8d6:	1c 3b       	cp.w	r11,lr
8000b8d8:	c0 a2       	brcc	8000b8ec <__avr32_umod64+0x1c4>
8000b8da:	20 16       	sub	r6,1
8000b8dc:	10 0b       	add	r11,r8
8000b8de:	10 3b       	cp.w	r11,r8
8000b8e0:	c0 63       	brcs	8000b8ec <__avr32_umod64+0x1c4>
8000b8e2:	1c 3b       	cp.w	r11,lr
8000b8e4:	f7 b6 03 01 	sublo	r6,1
8000b8e8:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000b8ec:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000b8f0:	1c 1b       	sub	r11,lr
8000b8f2:	e2 02 06 40 	mulu.d	r0,r1,r2
8000b8f6:	00 9e       	mov	lr,r0
8000b8f8:	02 9c       	mov	r12,r1
8000b8fa:	16 3c       	cp.w	r12,r11
8000b8fc:	e0 8b 00 08 	brhi	8000b90c <__avr32_umod64+0x1e4>
8000b900:	5f 06       	sreq	r6
8000b902:	06 30       	cp.w	r0,r3
8000b904:	5f ba       	srhi	r10
8000b906:	ed ea 00 0a 	and	r10,r6,r10
8000b90a:	c0 60       	breq	8000b916 <__avr32_umod64+0x1ee>
8000b90c:	fc 02 01 04 	sub	r4,lr,r2
8000b910:	f8 08 01 4c 	sbc	r12,r12,r8
8000b914:	08 9e       	mov	lr,r4
8000b916:	e6 0e 01 0a 	sub	r10,r3,lr
8000b91a:	f6 0c 01 4c 	sbc	r12,r11,r12
8000b91e:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000b922:	f8 09 0a 4b 	lsr	r11,r12,r9
8000b926:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b92a:	f8 01 09 4c 	lsl	r12,r12,r1
8000b92e:	18 4a       	or	r10,r12
8000b930:	2f dd       	sub	sp,-12
8000b932:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ba00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ba00:	c0 08       	rjmp	8000ba00 <_evba>
	...

8000ba04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ba04:	c0 08       	rjmp	8000ba04 <_handle_TLB_Multiple_Hit>
	...

8000ba08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ba08:	c0 08       	rjmp	8000ba08 <_handle_Bus_Error_Data_Fetch>
	...

8000ba0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ba0c:	c0 08       	rjmp	8000ba0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ba10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ba10:	c0 08       	rjmp	8000ba10 <_handle_NMI>
	...

8000ba14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ba14:	c0 08       	rjmp	8000ba14 <_handle_Instruction_Address>
	...

8000ba18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ba18:	c0 08       	rjmp	8000ba18 <_handle_ITLB_Protection>
	...

8000ba1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ba1c:	c0 08       	rjmp	8000ba1c <_handle_Breakpoint>
	...

8000ba20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ba20:	c0 08       	rjmp	8000ba20 <_handle_Illegal_Opcode>
	...

8000ba24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ba24:	c0 08       	rjmp	8000ba24 <_handle_Unimplemented_Instruction>
	...

8000ba28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ba28:	c0 08       	rjmp	8000ba28 <_handle_Privilege_Violation>
	...

8000ba2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ba2c:	c0 08       	rjmp	8000ba2c <_handle_Floating_Point>
	...

8000ba30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ba30:	c0 08       	rjmp	8000ba30 <_handle_Coprocessor_Absent>
	...

8000ba34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ba34:	c0 08       	rjmp	8000ba34 <_handle_Data_Address_Read>
	...

8000ba38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ba38:	c0 08       	rjmp	8000ba38 <_handle_Data_Address_Write>
	...

8000ba3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ba3c:	c0 08       	rjmp	8000ba3c <_handle_DTLB_Protection_Read>
	...

8000ba40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ba40:	c0 08       	rjmp	8000ba40 <_handle_DTLB_Protection_Write>
	...

8000ba44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ba44:	c0 08       	rjmp	8000ba44 <_handle_DTLB_Modified>
	...

8000ba50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ba50:	c0 08       	rjmp	8000ba50 <_handle_ITLB_Miss>
	...

8000ba60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ba60:	c0 08       	rjmp	8000ba60 <_handle_DTLB_Miss_Read>
	...

8000ba70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ba70:	c0 08       	rjmp	8000ba70 <_handle_DTLB_Miss_Write>
	...

8000bb00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bb00:	fe cf 71 00 	sub	pc,pc,28928

8000bb04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bb04:	30 0c       	mov	r12,0
8000bb06:	fe b0 c3 f1 	rcall	800042e8 <_get_interrupt_handler>
8000bb0a:	58 0c       	cp.w	r12,0
8000bb0c:	f8 0f 17 10 	movne	pc,r12
8000bb10:	d6 03       	rete

8000bb12 <_int1>:
8000bb12:	30 1c       	mov	r12,1
8000bb14:	fe b0 c3 ea 	rcall	800042e8 <_get_interrupt_handler>
8000bb18:	58 0c       	cp.w	r12,0
8000bb1a:	f8 0f 17 10 	movne	pc,r12
8000bb1e:	d6 03       	rete

8000bb20 <_int2>:
8000bb20:	30 2c       	mov	r12,2
8000bb22:	fe b0 c3 e3 	rcall	800042e8 <_get_interrupt_handler>
8000bb26:	58 0c       	cp.w	r12,0
8000bb28:	f8 0f 17 10 	movne	pc,r12
8000bb2c:	d6 03       	rete

8000bb2e <_int3>:
8000bb2e:	30 3c       	mov	r12,3
8000bb30:	fe b0 c3 dc 	rcall	800042e8 <_get_interrupt_handler>
8000bb34:	58 0c       	cp.w	r12,0
8000bb36:	f8 0f 17 10 	movne	pc,r12
8000bb3a:	d6 03       	rete

8000bb3c <ipr_val>:
8000bb3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bb4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbfc:	d7 03 d7 03                                         ....
